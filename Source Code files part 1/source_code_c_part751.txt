_TIME_AM3 & APE2_GEN_TIME_PM3 below */

#define APE2_GEN_SERVER                         (APPERR2_BASE + 26)     /* @I
                        *
                        *Server%0
                        */

#define APE2_GEN_REDIR                          (APPERR2_BASE + 27)     /* @I
                        *
                        *Redirector%0
                        */

#define APE2_GEN_APP                            (APPERR2_BASE + 28)     /* @I
                        *
                        *Application%0
                        */

#define APE2_GEN_TOTAL                          (APPERR2_BASE + 29)     /* @I
                        *
                        *Total%0
                        */

#define APE2_GEN_QUESTION                       (APPERR2_BASE + 30)     /* @I
                        *
                        * ? %1 %0
                        */

#define APE2_GEN_KILOBYTES                      (APPERR2_BASE + 31)     /* @I
                        *
                        * K%0
                        */

#define APE2_GEN_MSG_NONE                       (APPERR2_BASE + 32)     /* @I
                        *
                        *(none)%0
                        */

#define APE2_GEN_DEVICE                 (APPERR2_BASE + 33)     /* @I
                        *
                        *Device%0
                        */

#define APE2_GEN_REMARK                 (APPERR2_BASE + 34)     /* @I
                        *
                        *Remark%0
                        */

#define APE2_GEN_AT                     (APPERR2_BASE + 35)     /* @I
                        *
                        *At%0
                        */

#define APE2_GEN_QUEUE                  (APPERR2_BASE + 36)     /* @I
                        *
                        *Queue%0
                        */

#define APE2_GEN_QUEUES                 (APPERR2_BASE + 37)     /* @I
                        *
                        *Queues%0
                        */

#define APE2_GEN_USER_NAME                      (APPERR2_BASE + 38)     /* @I
                        *
                        *User name%0
                        */

#define APE2_GEN_PATH                   (APPERR2_BASE + 39)     /* @I
                        *
                        *Path%0
                        */

#define APE2_GEN_DEFAULT_YES                    (APPERR2_BASE + 40)     /* @I
                        *
                        *(Y/N) [Y]%0
                        */

#define APE2_GEN_DEFAULT_NO                     (APPERR2_BASE + 41)     /* @I
                        *
                        *(Y/N) [N]%0
                        */

#define APE2_GEN_ERROR                          (APPERR2_BASE + 42)     /* @I
                        *
                        *Error%0
                        */

#define APE2_GEN_OK                             (APPERR2_BASE + 43)     /* @I
                        *
                        *OK%0
                        */


/*
 *      NOTE!! NLS_YES_CHAR & NLS_NO_CHAR MUST BE ONE (1) CHARACTER LONG!
 */
#define APE2_GEN_NLS_YES_CHAR   (APPERR2_BASE + 44)     /* @I
                        *
                        *Y%0
                        */

#define APE2_GEN_NLS_NO_CHAR    (APPERR2_BASE + 45)     /* @I
                        *
                        *N%0
                        */

#define APE2_GEN_ANY                            (APPERR2_BASE + 46)     /* @I
                        *
                        *Any%0
                        */

#define APE2_GEN_TIME_AM3                       (APPERR2_BASE + 47)     /* @I
                        *
                        *A%0
                        */

#define APE2_GEN_TIME_PM3                       (APPERR2_BASE + 48)     /* @I
                        *
                        *P%0
                        */

#define APE2_GEN_NOT_FOUND                      (APPERR2_BASE + 49)     /* @I
                        *
                        *(not found)%0
                        */

#define APE2_GEN_UKNOWN_IN_PARENS               (APPERR2_BASE + 50)     /* @I
                        *
                        *(unknown)%0
                        */


#define APE2_GEN_UsageHelp                      (APPERR2_BASE + 51)     /* @I
         *
         * For help on %1 type NET HELP %1
         */

#define APE2_GEN_GRANT                          (APPERR2_BASE + 52)     /* @I
                        *
                        *Grant%0
                        */

#define APE2_GEN_READ                           (APPERR2_BASE + 53)     /* @I
                        *
                        *Read%0
                        */

#define APE2_GEN_CHANGE                         (APPERR2_BASE + 54)     /* @I
                        *
                        *Change%0
                        */

#define APE2_GEN_FULL                           (APPERR2_BASE + 55)     /* @I
                        *
                        *Full%0
                        */


/***
 *
 *      Password prompts
 *              Moved from APPERR.H 8/21/89  -- jmh
 *
 */

#define APE_GeneralPassPrompt (APPERR2_BASE + 56) /* @P
         *
         *Please type the password: %0
         */

#define APE_UsePassPrompt (APPERR2_BASE + 57) /* @P
         *
         *Type the password for %1: %0
         */

#define APE_UserUserPass (APPERR2_BASE + 58) /* @P
         *
         *Type a password for the user: %0
         */

#define APE_ShareSharePass (APPERR2_BASE + 59) /* @P
         *
         *Type the password for the shared resource: %0
         */

#define APE_UtilPasswd (APPERR2_BASE + 60) /* @P
         *
         *Type your password: %0
         */

#define APE_UtilConfirm (APPERR2_BASE + 61) /* @P
         *
         *Retype the password to confirm: %0
         */

#define APE_PassOpass (APPERR2_BASE + 62) /* @P
         *
         *Type the user's old password: %0
         */

#define APE_PassNpass (APPERR2_BASE + 63) /* @P
         *
         *Type the user's new password: %0
         */

#define APE_LogonNewPass (APPERR2_BASE + 64) /* @P
         *
         *Type your new password: %0
         */

#define APE_StartReplPass (APPERR2_BASE + 65) /* @P
        *
        *Type the Replicator service password: %0
        */


/***
 *
 *      Other prompts
 *              Moved from APPERR.H 8/21/89 -- jmh
 *
 */

#define APE_LogoUsername (APPERR2_BASE + 66) /* @P
         *
         *Type your user name, or press ENTER if it is %1: %0
         */

#define APE_PassCname (APPERR2_BASE + 67 ) /* @P
         *
         *Type the domain or server where you want to change a password, or
         *press ENTER if it is for domain %1: %0.
         */

#define APE_PassUname (APPERR2_BASE + 68 ) /* @P
         *
         *Type your user name: %0
         */

/***
 *
 *      Display Headings
 *              Moved from APPERR.H 8/21/89  -- jmh
 *
 */

#define APE_StatsStatistics (APPERR2_BASE + 69) /* @I
         *
         *Network statistics for \\%1
         */

#define APE_PrintOptions (APPERR2_BASE + 70) /* @I
         *
         *Printing options for %1
         */

#define APE_CommPoolsAccessing (APPERR2_BASE + 71) /* @I
         *
         *Communication-device queues accessing %1
         */

#define APE_PrintJobOptions (APPERR2_BASE + 72) /* @I
         *
         *Print job detail
         */

#define APE_CommPools (APPERR2_BASE + 73) /* @I
         *
         *Communication-device queues at \\%1
         */

#define APE_PrintQueues (APPERR2_BASE + 74) /* @I
         *
         *Printers at %1
         */

#define APE_PrintQueuesDevice (APPERR2_BASE + 75) /* @I
         *
         *Printers accessing %1
         */

#define APE_PrintJobs (APPERR2_BASE + 76) /* @I
         *
         *Print jobs at %1:
         */

#define APE_ViewResourcesAt (APPERR2_BASE + 77) /* @I
         *
         *Shared resources at %1
         */

#define APE_CnfgHeader (APPERR2_BASE + 78) /* @I
         *
         *The following running services can be controlled:
         */

#define APE_StatsHeader (APPERR2_BASE + 79) /* @I
         *
         *Statistics are available for the following running services:
         */

#define APE_UserAccounts (APPERR2_BASE + 80) /* @I
         *
         *User accounts for \\%1
         */

#define APE_Syntax (APPERR2_BASE + 81) /* @I
         *
         *The syntax of this command is:
         */

#define APE_Options (APPERR2_BASE + 82) /* @I
         *
         *The options of this command are:
         */

#define APE_PDCPrompt (APPERR2_BASE + 83) /* @I
         *
         *Please enter the name of the Primary Domain Controller: %0
         */

#define APE_StringTooLong (APPERR2_BASE + 84) /* @I
         *
         *The string you have entered is too long. The maximum
         *is %1, please reenter. %0
         */

/***
 *
 *   Japanese version specific messages
 *
 */

#define APE2_GEN_NONLOCALIZED_SUNDAY (APPERR2_BASE + 85)      /* @I
                        *
                        *Sunday%0
                        */

#define APE2_GEN_NONLOCALIZED_MONDAY (APPERR2_BASE + 86)      /* @I
                        *
                        *Monday%0
                        */

#define APE2_GEN_NONLOCALIZED_TUESDAY (APPERR2_BASE + 87)      /* @I
                        *
                        *Tuesday%0
                        */

#define APE2_GEN_NONLOCALIZED_WEDNSDAY (APPERR2_BASE + 88)     /* @I
                        *
                        *Wednesday%0
                        */

#define APE2_GEN_NONLOCALIZED_THURSDAY (APPERR2_BASE + 89)     /* @I
                        *
                        *Thursday%0
                        */

#define APE2_GEN_NONLOCALIZED_FRIDAY (APPERR2_BASE + 90)     /* @I
                        *
                        *Friday%0
                        */

#define APE2_GEN_NONLOCALIZED_SATURDAY (APPERR2_BASE + 91)     /* @I
                        *
                        *Saturday%0
                        */

#define APE2_GEN_NONLOCALIZED_SUNDAY_ABBREV (APPERR2_BASE + 92)     /* @I
                        *
                        *Su%0
                        */

#define APE2_GEN_NONLOCALIZED_MONDAY_ABBREV (APPERR2_BASE + 93)     /* @I
                        *
                        *M%0
                        */

#define APE2_GEN_NONLOCALIZED_TUESDAY_ABBREV (APPERR2_BASE + 94)     /* @I
                        *
                        *T%0
                        */

#define APE2_GEN_NONLOCALIZED_WEDNSDAY_ABBREV (APPERR2_BASE + 95)     /* @I
                        *
                        *W%0
                        */

#define APE2_GEN_NONLOCALIZED_THURSDAY_ABBREV (APPERR2_BASE + 96)     /* @I
                        *
                        *Th%0
                        */

#define APE2_GEN_NONLOCALIZED_FRIDAY_ABBREV (APPERR2_BASE + 97)     /* @I
                        *
                        *F%0
                        */

#define APE2_GEN_NONLOCALIZED_SATURDAY_ABBREV (APPERR2_BASE + 98)     /* @I
                        *
                        *S%0
                        */

#define APE2_GEN_NONLOCALIZED_SATURDAY_ABBREV2 (APPERR2_BASE + 99)     /* @I
                        *
                        *Sa%0
                        */

/***
 * End Japanese specific messages
 *
 */




/*
 *      GROUPENUM -- display of all groups.  Maximum length is 50.
 *
 *      Substitution of %1 is name of current server.
 */

#define APE2_GROUPENUM_HEADER           (APPERR2_BASE + 100)    /* @I
                        *
                        *Group Accounts for \\%1
                        */

/*
 *      GROUPDISP -- group display in full detail.  Maximum length of the
 *      strings other than MEMBERS is 50.
 *
 *      Note that MEMBERS is *NOT* given a %0 at the end !!
 */

#define APE2_GROUPDISP_GROUPNAME        (APPERR2_BASE + 101)    /* @I
                        *
                        *Group name%0
                        */

#define APE2_GROUPDISP_COMMENT          (APPERR2_BASE + 102)    /* @I
                        *
                        *Comment%0
                        */

#define APE2_GROUPDISP_MEMBERS          (APPERR2_BASE + 103)    /* @I
                        *
                        *Members
                        */

/*
 *      ALIASENUM -- display of all aliases.  Maximum length is 50.
 *
 *      Substitution of %1 is name of current server.
 */

#define APE2_ALIASENUM_HEADER           (APPERR2_BASE + 105)    /* @I
                        *
                        *Aliases for \\%1
                        */

/*
 *      ALIASDISP -- group display in full detail.  Maximum length of the
 *      strings other than MEMBERS is 50.
 *
 *      Note that MEMBERS is *NOT* given a %0 at the end !!
 */

#define APE2_ALIASDISP_ALIASNAME        (APPERR2_BASE + 106)    /* @I
                        *
                        *Alias name%0
                        */

#define APE2_ALIASDISP_COMMENT          (APPERR2_BASE + 107)    /* @I
                        *
                        *Comment%0
                        */

#define APE2_ALIASDISP_MEMBERS          (APPERR2_BASE + 108)    /* @I
                        *
                        *Members
                        */



/*
 *      USERENUM -- display of all users.  Maximum length is 50.
 *
 *      Substitution of %1 is name of current server.
 */

#define APE2_USERENUM_HEADER            (APPERR2_BASE + 110)    /* @I
                        *
                        *User Accounts for \\%1
                        */

/*
 *      USERDISP -- user display in full detail.  Maximum length of each
 *      item-label string is 50, values is 25.
 *
 *      Item labels are followed immediately by any related value strings,
 *      or references to such strings.
 */

#define APE2_USERDISP_USERNAME          (APPERR2_BASE + 111)    /* @I
                        *User name%0
                        */

#define APE2_USERDISP_FULLNAME          (APPERR2_BASE + 112)    /* @I
                        *
                        *Full Name%0
                        */

#define APE2_USERDISP_COMMENT           (APPERR2_BASE + 113)    /* @I
                        *
                        *Comment%0
                        */

#define APE2_USERDISP_USRCOMMENT        (APPERR2_BASE + 114)    /* @I
                        *
                        *User's comment%0
                        */

#define APE2_USERDISP_PARMS             (APPERR2_BASE + 115)    /* @I
                        *
                        *Parameters%0
                        */

#define APE2_USERDISP_COUNTRYCODE       (APPERR2_BASE + 116)    /* @I
                        *
                        *Country code%0
                        */

#define APE2_USERDISP_PRIV              (APPERR2_BASE + 117)    /* @I
                        *
                        *Privilege level%0
                        */

        /* See APE2_SEC_PRIV_xxx for value strings */

#define APE2_USERDISP_OPRIGHTS          (APPERR2_BASE + 118)    /* @I
                        *
                        *Operator privileges%0
                        */

        /* See APE2_SEC_OPRT_xxx for value strings.     */
        /* APE2_GEN_NONE is also used.                      */


#define APE2_USERDISP_ACCENABLED        (APPERR2_BASE + 119)    /* @I
                        *
                        *Account active%0
                        */

#define APE2_USERDISP_ACCEXP            (APPERR2_BASE + 120)    /* @I
                        *
                        *Account expires%0
                        */

#define APE2_USERDISP_PSWDSET           (APPERR2_BASE + 121)    /* @I
                        *
                        *Password last set%0
                        */

#define APE2_USERDISP_PSWDEXP           (APPERR2_BASE + 122)    /* @I
                        *
                        *Password expires%0
                        */

#define APE2_USERDISP_PSWDCHNG          (APPERR2_BASE + 123)    /* @I
                        *
                        *Password changeable%0
                        */

#define APE2_USERDISP_WKSTA             (APPERR2_BASE + 124)    /* @I
                        *
                        *Workstations allowed%0
                        */

#define APE2_USERDISP_MAXDISK           (APPERR2_BASE + 125)    /* @I
                        *
                        *Maximum disk space%0
                        */

#define APE2_USERDISP_MAXDISK_UNLIM     (APPERR2_BASE + 126)    /* @I
                        *
                        *Unlimited%0
                        */

#define APE2_USERDISP_ALIASES           (APPERR2_BASE + 127)    /* @I
                        *
                        *Local Group Memberships%0
                        */

#define APE2_USERDISP_LOGONSRV_DC       (APPERR2_BASE + 128)    /* @I
                        *
                        *Domain controller%0
                        */

        /* In addition to above, APE2_GEN_ANY is used here. */

#define APE2_USERDISP_LOGONSCRIPT       (APPERR2_BASE + 129)    /* @I
                        *
                        *Logon script%0
                        */

#define APE2_USERDISP_LASTLOGON         (APPERR2_BASE + 130)    /* @I
                        *
                        *Last logon%0
                        */

#define APE2_USERDISP_GROUPS            (APPERR2_BASE + 131)    /* @I
                        *
                        *Global Group memberships%0
                        */

#define APE2_USERDISP_LOGHOURS          (APPERR2_BASE + 132)    /* @I
                        *
                        *Logon hours allowed%0
                        */

#define APE2_USERDISP_LOGHRS_ALL        (APPERR2_BASE + 133)    /* @I
                        *
                        *All%0
                        */

#define APE2_USERDISP_LOGHRS_NONE       (APPERR2_BASE + 134)    /* @I
                        *
                        *None%0
                        */

#define APE2_USERDISP_LOGHRS_DAILY      (APPERR2_BASE + 135)    /* @I
                        *
                        *Daily %1 - %2%0
                        */

#define APE2_USERDISP_HOMEDIR           (APPERR2_BASE + 136)    /* @I
                        *
                        *Home directory%0
                        */

#define APE2_USERDISP_PSWDREQ           (APPERR2_BASE + 137)    /* @I
                        *
                        *Password required%0
                        */

#define APE2_USERDISP_PSWDUCHNG         (APPERR2_BASE + 138)    /* @I
                        *
                        *User may change password%0
                        */

#define APE2_USERDISP_PROFILE           (APPERR2_BASE + 139)    /* @I
                        *
                        *User profile%0
                        */

#define APE2_USERDISP_LOCKOUT           (APPERR2_BASE + 140)    /* @I
                        *
                        *Locked%0
                        */


/*
 *      CFG_W -- Config Workstation output
 */

#define APE2_CFG_W_CNAME                (APPERR2_BASE + 150)    /* @I
                        *
                        *Computer name%0
                        */

#define APE2_CFG_W_UNAME                (APPERR2_BASE + 151)    /* @I
                        *
                        *User name%0
                        */

#define APE2_CFG_W_VERSION              (APPERR2_BASE + 152)    /* @I
                        *
                        *Software version%0
                        */

#define APE2_CFG_W_NETS                 (APPERR2_BASE + 153)    /* @I
                        *
                        *Workstation active on%0
                        */

#define APE2_CFG_W_ROOT                 (APPERR2_BASE + 154)    /* @I
                        *
                        *Windows NT root directory%0
                        */

#define APE2_CFG_W_DOMAIN_P             (APPERR2_BASE + 155)    /* @I
                        *
                        *Workstation domain%0
                        */

#define APE2_CFG_W_DOMAIN_L             (APPERR2_BASE + 156)    /* @I
                        *
                        *Logon domain%0
                        */

#define APE2_CFG_W_DOMAIN_O             (APPERR2_BASE + 157)    /* @I
                        *
                        *Other domain(s)%0
                        */

#define APE2_CFG_W_COM_OTIME            (APPERR2_BASE + 158)    /* @I
                        *
                        *COM Open Timeout (sec)%0
                        */

#define APE2_CFG_W_COM_SCNT             (APPERR2_BASE + 159)    /* @I
                        *
                        *COM Send Count (byte)%0
                        */

#define APE2_CFG_W_COM_STIME            (APPERR2_BASE + 160)    /* @I
                        *
                        *COM Send Timeout (msec)%0
                        */

#define APE2_CFG_W_3X_PRTTIME           (APPERR2_BASE + 161)    /* @I
                        *
                        *DOS session print time-out (sec)%0
                        */

#define APE2_CFG_W_MAXERRLOG            (APPERR2_BASE + 162)    /* @I
                        *
                        *Maximum error log size (K)%0
                        */

#define APE2_CFG_W_MAXCACHE             (APPERR2_BASE + 163)    /* @I
                        *
                        *Maximum cache memory (K)%0
                        */

#define APE2_CFG_W_NUMNBUF              (APPERR2_BASE + 164)    /* @I
                        *
                        *Number of network buffers%0
                        */

#define APE2_CFG_W_NUMCBUF              (APPERR2_BASE + 165)    /* @I
                        *
                        *Number of character buffers%0
                        */

#define APE2_CFG_W_SIZNBUF              (APPERR2_BASE + 166)    /* @I
                        *
                        *Size of network buffers%0
                        */

#define APE2_CFG_W_SIZCBUF              (APPERR2_BASE + 167)    /* @I
                        *
                        *Size of character buffers%0
                        */
#define APE2_CFG_W_FULL_CNAME           (APPERR2_BASE + 168)    /* @I
                        *
                        *Full Computer name%0
                        */
#define APE2_CFG_W_DOMAIN_DNS           (APPERR2_BASE + 169)    /* @I
                        *
                        *Workstation Domain DNS Name%0
                        */
#define APE2_CFG_WINDOWS2000            (APPERR2_BASE + 170)    /* @I
                        *
                        *Windows 2002%0
                        */



/*
 *      CFG_S -- Config Server output
 */


#define APE2_CFG_S_SRVNAME              (APPERR2_BASE + 181)    /* @I
                        *
                        *Server Name%0
                        */

#define APE2_CFG_S_SRVCOMM              (APPERR2_BASE + 182)    /* @I
                        *
                        *Server Comment%0
                        */

#define APE2_CFG_S_ADMINALRT            (APPERR2_BASE + 183)    /* @I
                        *
                        *Send administrative alerts to%0
                        */

#define APE2_CFG_S_VERSION              (APPERR2_BASE + 184)    /* @I
                        *
                        *Software version%0
                        */

#define APE2_CFG_S_VERSION_PS           (APPERR2_BASE + 185)    /* @I
                        *
                        *Peer Server%0
                        */

#define APE2_CFG_S_VERSION_LM           (APPERR2_BASE + 186)    /* @I
                        *
                        *Windows NT%0
                        */

#define APE2_CFG_S_LEVEL                (APPERR2_BASE + 187)    /* @I
                        *
                        *Server Level%0
                        */

#define APE2_CFG_S_VERSION_IBM          (APPERR2_BASE + 188)    /* @I
                        *
                        *Windows NT Server%0
                        */

#define APE2_CFG_S_NETS                 (APPERR2_BASE + 189)    /* @I
                        *
                        *Server is active on%0
                        */

#define APE2_CFG_S_SRVHIDDEN            (APPERR2_BASE + 192)    /* @I
                        *
                        *Server hidden%0
                        */

#define APE2_CFG_S_MAXUSERS             (APPERR2_BASE + 206)    /* @I
                        *
                        *Maximum Logged On Users%0
                        */

#define APE2_CFG_S_MAXADMINS            (APPERR2_BASE + 207)    /* @I
                        *
                        *Maximum concurrent administrators%0
                        */

#define APE2_CFG_S_MAXSHARES            (APPERR2_BASE + 208)    /* @I
                        *
                        *Maximum resources shared%0
                        */

#define APE2_CFG_S_MAXCONNS             (APPERR2_BASE + 209)    /* @I
                        *
                        *Maximum connections to resources%0
                        */

#define APE2_CFG_S_MAXOFILES            (APPERR2_BASE + 210)    /* @I
                        *
                        *Maximum open files on server%0
                        */

#define APE2_CFG_S_MAXOFILESPS          (APPERR2_BASE + 211)    /* @I
                        *
                        *Maximum open files per session%0
                        */

#define APE2_CFG_S_MAXLOCKS             (APPERR2_BASE + 212)    /* @I
                        *
                        *Maximum file locks%0
                        */

#define APE2_CFG_S_IDLETIME             (APPERR2_BASE + 220)    /* @I
                        *
                        *Idle session time (min)%0
                        */

#define APE2_CFG_S_SEC_SHARE            (APPERR2_BASE + 226)    /* @I
                        *
                        *Share-level%0
                        */

#define APE2_CFG_S_SEC_USER             (APPERR2_BASE + 227)    /* @I
                        *
                        *User-level%0
                        */

#define APE2_CFG_S_LEVEL_UNLIMITED      (APPERR2_BASE + 230)    /* @I
                        *
                        *Unlimited Server%0
                        */



/*
 *      ACCOUNTS messages
 */
#define APE2_ACCOUNTS_FORCELOGOFF       (APPERR2_BASE + 270)    /* @I
                        *
                        *Force user logoff how long after time expires?:%0
                        *
                        */

#define APE2_ACCOUNTS_LOCKOUT_COUNT     (APPERR2_BASE + 271)    /* @I
                        *
                        *Lock out account after how many bad passwords?:%0
                        *
                        */

#define APE2_ACCOUNTS_MINPWAGE          (APPERR2_BASE + 272)    /* @I
                        *
                        *Minimum password age (days):%0
                        */

#define APE2_ACCOUNTS_MAXPWAGE          (APPERR2_BASE + 273)    /* @I
                        *
                        *Maximum password age (days):%0
                        */

#define APE2_ACCOUNTS_MINPWLEN          (APPERR2_BASE + 274)    /* @I
                        *
                        *Minimum password length:%0
                        */

#define APE2_ACCOUNTS_UNIQUEPW          (APPERR2_BASE + 275)    /* @I
                        *
                        *Length of password history maintained:%0
                        */

#define APE2_ACCOUNTS_ROLE              (APPERR2_BASE + 276)    /* @I
                        *
                        *Computer role:%0
                        */

#define APE2_ACCOUNTS_CONTROLLER        (APPERR2_BASE + 277)    /* @I
                        *
                        *Primary Domain controller for workstation domain:%0.
                        */

#define APE2_ACCOUNTS_LOCKOUT_THRESHOLD (APPERR2_BASE + 278)    /* @I
                        *
                        *Lockout threshold:%0
                        */

#define APE2_ACCOUNTS_LOCKOUT_DURATION  (APPERR2_BASE + 279)    /* @I
                        *
                        *Lockout duration (minutes):%0
                        */

#define APE2_ACCOUNTS_LOCKOUT_WINDOW    (APPERR2_BASE + 280)    /* @I
                        *
                        *Lockout observation window (minutes):%0
                        */

/***
 *
 *  STATISTICS display
 */

#define APE2_STATS_STARTED              (APPERR2_BASE + 300)    /* @I
                *
                *Statistics since%0
                */

#define APE2_STATS_S_ACCEPTED           (APPERR2_BASE + 301)    /* @I
                *
                *Sessions accepted%0
                */

#define APE2_STATS_S_TIMEDOUT           (APPERR2_BASE + 302)    /* @I
                *
                *Sessions timed-out%0
                */

#define APE2_STATS_ERROREDOUT           (APPERR2_BASE + 303)    /* @I
                *
                *Sessions errored-out%0
                */

#define APE2_STATS_B_SENT               (APPERR2_BASE + 304)    /* @I
                *
                *Kilobytes sent%0
                */

#define APE2_STATS_B_RECEIVED           (APPERR2_BASE + 305)    /* @I
                *
                *Kilobytes received%0
                */

#define APE2_STATS_RESPONSE             (APPERR2_BASE + 306)    /* @I
                *
                *Mean response time (msec)%0
                */

#define APE2_STATS_NETIO_ERR            (APPERR2_BASE + 307)    /* @I
                *
                *Network errors%0
                */

#define APE2_STATS_FILES_ACC            (APPERR2_BASE + 308)    /* @I
                *
                *Files accessed%0
                */

#define APE2_STATS_PRINT_ACC            (APPERR2_BASE + 309)    /* @I
                *
                *Print jobs spooled%0
                */

#define APE2_STATS_SYSTEM_ERR           (APPERR2_BASE + 310)    /* @I
                *
                *System errors%0
                */

#define APE2_STATS_PASS_ERR             (APPERR2_BASE + 311)    /* @I
                *
                *Password violations%0
                */

#define APE2_STATS_PERM_ERR             (APPERR2_BASE + 312)    /* @I
                *
                *Permission violations%0
                */

#define APE2_STATS_COMM_ACC             (APPERR2_BASE + 313)    /* @I
                *
                *Communication devices accessed%0
                */

#define APE2_STATS_S_OPENED            (APPERR2_BASE + 314)    /* @I
                *
                *Sessions started%0
                */

#define APE2_STATS_S_RECONN            (APPERR2_BASE + 315)    /* @I
                *
                *Sessions reconnected%0
                */

#define APE2_STATS_S_FAILED            (APPERR2_BASE + 316)    /* @I
                *
                *Sessions starts failed%0
                */

#define APE2_STATS_S_DISCONN           (APPERR2_BASE + 317)    /* @I
                *
                *Sessions disconnected%0
                */

#define APE2_STATS_NETIO               (APPERR2_BASE + 318)    /* @I
                *
                *Network I/O's performed%0
                */

#define APE2_STATS_IPC                 (APPERR2_BASE + 319)    /* @I
                *
                *Files and pipes accessed%0
                */

#define APE2_STATS_BUFCOUNT            (APPERR2_BASE + 320)    /* @I
                *
                *Times buffers exhausted
                */

#define APE2_STATS_BIGBUF              (APPERR2_BASE + 321)    /* @I
                *
                *Big buffers%0
                */

#define APE2_STATS_REQBUF              (APPERR2_BASE + 322)    /* @I
                *
                *Request buffers%0
                */

#define APE2_STATS_WKSTA                (APPERR2_BASE + 323)    /* @I
                *
                *Workstation Statistics for \\%1
                */

#define APE2_STATS_SERVER                (APPERR2_BASE + 324)    /* @I
                *
                *Server Statistics for \\%1
                */

#define APE2_STATS_SINCE                 (APPERR2_BASE + 325)    /* @I
                *
                *Statistics since %1
                */

#define APE2_STATS_C_MADE                (APPERR2_BASE + 326)    /* @I
                *
                *Connections made%0
                */

#define APE2_STATS_C_FAILED              (APPERR2_BASE + 327)    /* @I
                *
                *Connections failed%0
                */

/***
 *
 * New rdr stats for NT. These guys occupy the space that AT
 * used to.
 */


#define APE2_STATS_BYTES_RECEIVED       (APPERR2_BASE + 330)       /* @I
                *
                *Bytes received%0
                */
#define APE2_STATS_SMBS_RECEIVED        (APPERR2_BASE + 331)       /* @I
                *
                *Server Message Blocks (SMBs) received%0
                */
#define APE2_STATS_BYTES_TRANSMITTED    (APPERR2_BASE + 332)       /* @I
                *
                *Bytes transmitted%0
                */
#define APE2_STATS_SMBS_TRANSMITTED     (APPERR2_BASE + 333)       /* @I
                *
                *Server Message Blocks (SMBs) transmitted%0
                */
#define APE2_STATS_READ_OPS             (APPERR2_BASE + 334)       /* @I
                *
                *Read operations%0
                */
#define APE2_STATS_WRITE_OPS            (APPERR2_BASE + 335)       /* @I
                *
                *Write operations%0
                */
#define APE2_STATS_RAW_READS_DENIED     (APPERR2_BASE + 336)       /* @I
                *
                *Raw reads denied%0
                */
#define APE2_STATS_RAW_WRITES_DENIED    (APPERR2_BASE + 337)       /* @I
                *
                *Raw writes denied%0
                */
#define APE2_STATS_NETWORK_ERRORS       (APPERR2_BASE + 338)       /* @I
                *
                *Network errors%0
                */
#define APE2_STATS_TOTAL_CONNECTS       (APPERR2_BASE + 339)       /* @I
                *
                *Connections made%0
                */
#define APE2_STATS_RECONNECTS           (APPERR2_BASE + 340)       /* @I
                *
                *Reconnections made%0
                */
#define APE2_STATS_SRV_DISCONNECTS      (APPERR2_BASE + 341)       /* @I
                *
                *Server disconnects%0
                */
#define APE2_STATS_SESSIONS             (APPERR2_BASE + 342)       /* @I
                *
                *Sessions started%0
                */
#define APE2_STATS_HUNG_SESSIONS        (APPERR2_BASE + 343)       /* @I
                *
                *Hung sessions%0
                */
#define APE2_STATS_FAILED_SESSIONS      (APPERR2_BASE + 344)       /* @I
                *
                *Failed sessions%0
                */
#define APE2_STATS_FAILED_OPS           (APPERR2_BASE + 345)       /* @I
                *
                *Failed operations%0
                */
#define APE2_STATS_USE_COUNT            (APPERR2_BASE + 346)       /* @I
                *
                *Use count%0
                */
#define APE2_STATS_FAILED_USE_COUNT     (APPERR2_BASE + 347)       /* @I
                *
                *Failed use count%0
                */


/***
 *
 *      Specific success messages
 *              Moved from APPERR.H 8/21/89  --jmh
 *
 */

#define APE_DelSuccess (APPERR2_BASE + 350 ) /* @I
        *
        *%1 was deleted successfully.
        */

#define APE_UseSuccess (APPERR2_BASE + 351 ) /* @I
         *
         *%1 was used successfully.
         */

#define APE_SendSuccess (APPERR2_BASE + 352 ) /* @I
         *
         *The message was successfully sent to %1.
         */

/*** NOTE ... see also APE_SendXxxSucess in APPERR.H  ***/

#define APE_ForwardSuccess (APPERR2_BASE + 353) /* @I
         *
         *The message name %1 was forwarded successfully.
         */

#define APE_NameSuccess (APPERR2_BASE + 354) /* @I
         *
         *The message name %1 was added successfully.
         */

#define APE_ForwardDelSuccess (APPERR2_BASE + 355) /* @I
         *
         *The message name forwarding was successfully canceled.
         */

#define APE_ShareSuccess (APPERR2_BASE + 356) /* @I
         *
         *%1 was shared successfully.
         */

#define APE_LogonSuccess (APPERR2_BASE + 357) /* @I
         *
         *The server %1 successfully logged you on as %2.
         */

#define APE_LogoffSuccess (APPERR2_BASE + 358) /* @I
         *
         *%1 was logged off successfully.
         */

#define APE_DelStickySuccess (APPERR2_BASE + 359 ) /* @I
        *
        *%1 was successfully removed from the list of shares the Server creates
        *on startup.
        */

#define APE_PassSuccess (APPERR2_BASE + 361) /* @I
         *
         *The password was changed successfully.
         */

#define APE_FilesCopied  (APPERR2_BASE + 362) /* @I
         *
         *%1 file(s) copied.
         */

#define APE_FilesMoved  (APPERR2_BASE + 363) /* @I
         *
         *%1 file(s) moved.
         */

#define APE_SendAllSuccess (APPERR2_BASE + 364 ) /* @I
         *
         *The message was successfully sent to all users of the network.
         */

#define APE_SendDomainSuccess (APPERR2_BASE + 365 ) /* @I
         *
         *The message was successfully sent to domain %1.
         */

#define APE_SendUsersSuccess (APPERR2_BASE + 366 ) /* @I
         *
         *The message was successfully sent to all users of this server.
         */

#define APE_SendGroupSuccess (APPERR2_BASE + 367 ) /* @I
         *
         *The message was successfully sent to group *%1.
         */

#define APE2_VER_Release                (APPERR2_BASE + 395)     /* @I
                *
                *Microsoft LAN Manager Version %1
                */

#define APE2_VER_ProductOS2Server       (APPERR2_BASE + 396)     /* @I
                *
                *Windows NT Server
                */

#define APE2_VER_ProductOS2Workstation  (APPERR2_BASE + 397)     /* @I
                *
                *Windows NT Workstation
                */

#define APE2_VER_ProductDOSWorkstation  (APPERR2_BASE + 398)     /* @I
                *
                *MS-DOS Enhanced Workstation
                */

#define APE2_VER_BuildTime              (APPERR2_BASE + 399)     /* @I
                *
                *Created at %1
                */

#define APE2_VIEW_ALL_HDR                (APPERR2_BASE + 400)    /* @I
                *
                *Server Name            Remark
                */

#define APE2_VIEW_UNC            (APPERR2_BASE + 402)    /* @I
                *
                *(UNC)%0
                */

#define APE2_VIEW_MORE           (APPERR2_BASE + 403)    /* @I
                *
                *...%0
                */

#define APE2_VIEW_DOMAIN_HDR             (APPERR2_BASE + 404)    /* @I
                *
                *Domain
                */

#define APE2_VIEW_OTHER_HDR             (APPERR2_BASE + 405)    /* @I
                *
                *Resources on %1
                */

#define APE2_VIEW_OTHER_LIST             (APPERR2_BASE + 406)    /* @I
                *
                *Invalid network provider.  Available networks are:
                */


#define APE2_USE_TYPE_DISK               (APPERR2_BASE + 410)    /* @I
                *
                *Disk%0
                */

#define APE2_USE_TYPE_PRINT              (APPERR2_BASE + 411)    /* @I
                *
                *Print%0
                */

#define APE2_USE_TYPE_COMM               (APPERR2_BASE + 412)    /* @I
                *
                *Comm%0
                */

#define APE2_USE_TYPE_IPC                (APPERR2_BASE + 413)    /* @I
                *
                *IPC%0
                */

#define APE2_USE_HEADER                 (APPERR2_BASE + 414)     /* @I
                *
                *Status       Local     Remote                    Network
                */

#define APE2_USE_STATUS_OK                              (APPERR2_BASE + 415)     /* @I
                *
                *OK%0
                */

#define APE2_USE_STATUS_DORMANT                 (APPERR2_BASE + 416)    /* @I
                *
                *Dormant%0
                */

#define APE2_USE_STATUS_PAUSED                  (APPERR2_BASE + 417)    /* @I
                *
                *Paused%0
                */

#define APE2_USE_STATUS_SESSION_LOST    (APPERR2_BASE + 418)    /* @I
                *
                *Disconnected%0
                */

#define APE2_USE_STATUS_NET_ERROR               (APPERR2_BASE + 419)    /* @I
                *
                *Error%0
                */

#define APE2_USE_STATUS_CONNECTING              (APPERR2_BASE + 420)    /* @I
                *
                *Connecting%0
                */

#define APE2_USE_STATUS_RECONNECTING    (APPERR2_BASE + 421)    /* @I
                *
                *Reconnecting%0
                */

#define APE2_USE_MSG_STATUS                     (APPERR2_BASE + 422)    /* @I
                *
                *Status%0
                */

#define APE2_USE_MSG_LOCAL                              (APPERR2_BASE + 423)    /* @I
                *
                *Local name%0
                */

#define APE2_USE_MSG_REMOTE                     (APPERR2_BASE + 424)    /* @I
                *
                *Remote name%0
                */

#define APE2_USE_MSG_TYPE                               (APPERR2_BASE + 425)    /* @I
                *
                *Resource type%0
                */

#define APE2_USE_MSG_OPEN_COUNT                 (APPERR2_BASE + 426)    /* @I
                *
                *# Opens%0
                */

#define APE2_USE_MSG_USE_COUNT                  (APPERR2_BASE + 427)    /* @I
                *
                *# Connections%0
                */

#define APE2_USE_STATUS_UNAVAIL                 (APPERR2_BASE + 428)    /* @I
                *
                *Unavailable%0
                */


#define APE2_SHARE_MSG_HDR                              (APPERR2_BASE + 430)    /* @I
                *
                *Share name   Resource                        Remark
                */

#define APE2_SHARE_MSG_NAME                     (APPERR2_BASE + 431)    /* @I
                *
                *Share name%0
                */

#define APE2_SHARE_MSG_DEVICE                   (APPERR2_BASE + 432)    /* @I
                *
                *Resource%0
                */

#define APE2_SHARE_MSG_SPOOLED                  (APPERR2_BASE + 433)    /* @I
                *
                *Spooled%0
                */

#define APE2_SHARE_MSG_PERM                     (APPERR2_BASE + 434)    /* @I
                *
                *Permission%0
                */

#define APE2_SHARE_MSG_MAX_USERS                (APPERR2_BASE + 435)    /* @I
                *
                *Maximum users%0
                */

#define APE2_SHARE_MSG_ULIMIT                   (APPERR2_BASE + 436)    /* @I
                *
                *No limit%0
                */

#define APE2_SHARE_MSG_USERS                    (APPERR2_BASE + 437)    /* @I
                *
                *Users%0
                */

#define APE2_SHARE_MSG_NONFAT                   (APPERR2_BASE + 438)    /* @P
         *
         *The share name entered may not be accessible from some MS-DOS workstations.
         *Are you sure you want to use this share name? %1: %0
         */

#define APE2_SHARE_MSG_CACHING                  (APPERR2_BASE + 439)    /* @I
                *
                *Caching%0
                */

#define APE2_FILE_MSG_HDR                               (APPERR2_BASE + 440)            /* @I
                *
                *ID         Path                                    User name            # Locks
                */

#define APE2_FILE_MSG_ID                                (APPERR2_BASE + 441)            /* @I
                *
                *File ID%0
                */

#define APE2_FILE_MSG_NUM_LOCKS                 (APPERR2_BASE + 442)            /* @I
                *
                *Locks%0
                */

#define APE2_FILE_MSG_OPENED_FOR                (APPERR2_BASE + 443)            /* @I
                *
                *Permissions%0
                */

#define APE2_VIEW_SVR_HDR_NAME                (APPERR2_BASE + 444)    /* @I
                *
                *Share name%0
                                */

#define APE2_VIEW_SVR_HDR_TYPE                (APPERR2_BASE + 445)    /* @I
                *
                *Type%0
                */

#define APE2_VIEW_SVR_HDR_USEDAS                (APPERR2_BASE + 446)    /* @I
                *
                *Used as%0
                */

#define APE2_VIEW_SVR_HDR_CACHEORREMARK                (APPERR2_BASE + 447)    /* @I
                *
                *Comment%0
                */


#define APE2_SESS_MSG_HDR                       (APPERR2_BASE + 450)            /* @I
                *
                *Computer               User name            Client Type       Opens Idle time
                */

#define APE2_SESS_MSG_CMPTR                     (APPERR2_BASE + 451)            /* @I
                *
                *Computer%0
                */

#define APE2_SESS_MSG_SESSTIME                  (APPERR2_BASE + 452)            /* @I
                *
                *Sess time%0
                */

#define APE2_SESS_MSG_IDLETIME                  (APPERR2_BASE + 453)            /* @I
                *
                *Idle time%0
                */

#define APE2_SESS_MSG_HDR2                      (APPERR2_BASE + 454)            /* @I
                *
                *Share name     Type     # Opens
                */

#define APE2_SESS_MSG_CLIENTTYPE                (APPERR2_BASE + 455)            /* @I
                *
                *Client type%0
                */

#define APE2_SESS_MSG_GUEST                     (APPERR2_BASE + 456)            /* @I
                *
                *Guest logon%0
                */


/*
 *
 * CLIENT SIDE CACHING Messages
 *
 */


#define APE2_GEN_CACHED_MANUAL                  (APPERR2_BASE + 470)     /* @I
         *
         * Manual caching of documents%0
         */

#define APE2_GEN_CACHED_AUTO                    (APPERR2_BASE + 471)     /* @I
         *
         * Automatic caching of documents%0
         */

#define APE2_GEN_CACHED_VDO                     (APPERR2_BASE + 472)     /* @I
         *
         * Automatic caching of programs and documents%0
         */

#define APE2_GEN_CACHED_DISABLED                (APPERR2_BASE + 473)     /* @I
         *
         * Caching disabled%0
         */

#define APE2_GEN_CACHE_AUTOMATIC                (APPERR2_BASE + 474)     /* @I
         *
         * Automatic%0
         */

#define APE2_GEN_CACHE_MANUAL                   (APPERR2_BASE + 475)     /* @I
         *
         * Manual%0
         */

#define APE2_GEN_CACHE_DOCUMENTS                (APPERR2_BASE + 476)     /* @I
         *
         * Documents%0
         */

#define APE2_GEN_CACHE_PROGRAMS                 (APPERR2_BASE + 477)     /* @I
         *
         * Programs%0
         */

#define APE2_GEN_CACHE_NONE                     (APPERR2_BASE + 478)     /* @I
         *
         * None%0
         */


#define APE2_NAME_MSG_NAME                              (APPERR2_BASE + 500)            /* @I
                *
                *Name%0
                */

#define APE2_NAME_MSG_FWD                               (APPERR2_BASE + 501)            /* @I
                *
                *Forwarded to%0
                */

#define APE2_NAME_MSG_FWD_FROM                  (APPERR2_BASE + 502)            /* @I
                *
                *Forwarded to you from%0
                */

#define APE2_SEND_MSG_USERS                     (APPERR2_BASE + 503)            /* @I
                *
                *Users of this server%0
                */

#define APE2_SEND_MSG_INTERRUPT                 (APPERR2_BASE + 504)            /* @I
                *
                *Net Send has been interrupted by a Ctrl+Break from the user.
                */

#define APE2_PRINT_MSG_HDR                              (APPERR2_BASE + 510)            /* @I
                *
                *Name                         Job #      Size            Status
                */

#define APE2_PRINT_MSG_JOBS                     (APPERR2_BASE + 511)            /* @I
                *
                *jobs%0
                */

#define APE2_PRINT_MSG_PRINT                    (APPERR2_BASE + 512)            /* @I
                *
                *Print%0
                */

#define APE2_PRINT_MSG_NAME                     (APPERR2_BASE + 513)            /* @I
                *
                *Name%0
                */

#define APE2_PRINT_MSG_JOB                              (APPERR2_BASE + 514)            /* @I
                *
                *Job #%0
                */

#define APE2_PRINT_MSG_SIZE                     (APPERR2_BASE + 515)            /* @I
                *
                *Size%0
                */

#define APE2_PRINT_MSG_STATUS                   (APPERR2_BASE + 516)            /* @I
                *
                *Status%0
                */

#define APE2_PRINT_MSG_SEPARATOR                (APPERR2_BASE + 517)            /* @I
                *
                *Separator file%0
                */

#define APE2_PRINT_MSG_COMMENT                  (APPERR2_BASE + 518)            /* @I
                *
                *Comment%0
                */

#define APE2_PRINT_MSG_PRIORITY                 (APPERR2_BASE + 519)            /* @I
                *
                *Priority%0
                */

#define APE2_PRINT_MSG_AFTER                    (APPERR2_BASE + 520)            /* @I
                *
                *Print after%0
                */

#define APE2_PRINT_MSG_UNTIL                    (APPERR2_BASE + 521)            /* @I
                *
                *Print until%0
                */

#define APE2_PRINT_MSG_PROCESSOR                (APPERR2_BASE + 522)            /* @I
                *
                *Print processor%0
                */

#define APE2_PRINT_MSG_ADDITIONAL_INFO  (APPERR2_BASE + 523)            /* @I
                *
                *Additional info%0
                */

#define APE2_PRINT_MSG_PARMS                    (APPERR2_BASE + 524)            /* @I
                *
                *Parameters%0
                */

#define APE2_PRINT_MSG_DEVS                     (APPERR2_BASE + 525)            /* @I
                *
                *Print Devices%0
                */


#define APE2_PRINT_MSG_QUEUE_ACTIVE     (APPERR2_BASE + 526)            /* @I
                *
                *Printer Active%0
                */

#define APE2_PRINT_MSG_QUEUE_PAUSED     (APPERR2_BASE + 527)            /* @I
                *
                *Printer held%0
                */

#define APE2_PRINT_MSG_QUEUE_ERROR              (APPERR2_BASE + 528)            /* @I
                *
                *Printer error%0
                */

#define APE2_PRINT_MSG_QUEUE_PENDING    (APPERR2_BASE + 529)            /* @I
                *
                *Printer being deleted%0
                */

#define APE2_PRINT_MSG_QUEUE_UNKN               (APPERR2_BASE + 530)            /* @I
                *
                *Printer status unknown%0
                */

#define APE2_PRINT_MSG_QUEUE_UNSCHED    (APPERR2_BASE + 540)            /* @I
                *
                *Held until %1%0
                */


#define APE2_PRINT_MSG_JOB_ID                   (APPERR2_BASE + 541)            /* @I
                *
                *Job #%0
                */

#define APE2_PRINT_MSG_SUBMITTING_USER  (APPERR2_BASE + 542)            /* @I
                *
                *Submitting user%0
                */

#define APE2_PRINT_MSG_NOTIFY                   (APPERR2_BASE + 543)            /* @I
                *
                *Notify%0
                */

#define APE2_PRINT_MSG_JOB_DATA_TYPE    (APPERR2_BASE + 544)            /* @I
                *
                *Job data type%0
                */

#define APE2_PRINT_MSG_JOB_PARAMETERS   (APPERR2_BASE + 545)            /* @I
                *
                *Job parameters%0
                */

#define APE2_PRINT_MSG_WAITING                  (APPERR2_BASE + 546)            /* @I
                *
                *Waiting%0
                */

#define APE2_PRINT_MSG_PAUSED_IN_QUEUE  (APPERR2_BASE + 547)            /* @I
                *
                *Held in queue%0
                */

#define APE2_PRINT_MSG_SPOOLING                 (APPERR2_BASE + 548)            /* @I
                *
                *Spooling%0
                */

#define APE2_PRINT_MSG_PRINTER_PAUSED   (APPERR2_BASE + 549)            /* @I
                *
                *Paused%0
                */

#define APE2_PRINT_MSG_PRINTER_OFFLINE  (APPERR2_BASE + 550)            /* @I
                *
                *Offline%0
                */

#define APE2_PRINT_MSG_PRINTER_ERROR    (APPERR2_BASE + 551)            /* @I
                *
                *Error%0
                */

#define APE2_PRINT_MSG_OUT_OF_PAPER             (APPERR2_BASE + 552)            /* @I
                *
                *Out of paper%0
                */

#define APE2_PRINT_MSG_PRINTER_INTERV   (APPERR2_BASE + 553)            /* @I
                *
                *Intervention required%0
                */

#define APE2_PRINT_MSG_PRINTING                 (APPERR2_BASE + 554)            /* @I
                *
                *Printing%0
                */

#define APE2_PRINT_MSG_ON_WHAT_PRINTER  (APPERR2_BASE + 555)            /* @I
                *
                * on %0
                */

#define APE2_PRINT_MSG_PRINTER_PAUS_ON  (APPERR2_BASE + 556)            /* @I
                *
                *Paused on %1%0
                */

#define APE2_PRINT_MSG_PRINTER_OFFL_ON  (APPERR2_BASE + 557)            /* @I
                *
                *Offline on %1%0
                */

#define APE2_PRINT_MSG_PRINTER_ERR_ON   (APPERR2_BASE + 558)            /* @I
                *
                *Error on%1%0
                */

#define APE2_PRINT_MSG_OUT_OF_PAPER_ON          (APPERR2_BASE + 559)            /* @I
                *
                *Out of Paper on %1%0
                */

#define APE2_PRINT_MSG_PRINTER_INTV_ON  (APPERR2_BASE + 560)            /* @I
                *
                *Check printer on %1%0
                */

#define APE2_PRINT_MSG_PRINTING_ON              (APPERR2_BASE + 561)            /* @I
                *
                *Printing on %1%0
                */

#define APE2_PRINT_MSG_DRIVER                   (APPERR2_BASE + 562)            /* @I
                *
                *Driver%0
                */

/*
 *
 *
 *      Pinball starts at BASE + 600 and will reserve through 650 for safety
 *
 *      non used in NT.
 */

/*
 *
 * AUDITING and ERROR log messages
 *
 */

#define APE2_AUDIT_HEADER               (APPERR2_BASE + 630)    /* @I
                 *
                 *User name              Type                 Date%0
                 */
#define APE2_AUDIT_LOCKOUT              (APPERR2_BASE + 631)    /* @I
                 *
                 *Lockout%0
                 */
#define APE2_AUDIT_GENERIC              (APPERR2_BASE + 632)    /* @I
                 *
                 *Service%0
                 */
#define APE2_AUDIT_SERVER               (APPERR2_BASE + 633)    /* @I
                 *
                 *Server%0
                 */
#define APE2_AUDIT_SRV_STARTED          (APPERR2_BASE + 634)    /* @I
                 *
                 *Server started%0
                 */
#define APE2_AUDIT_SRV_PAUSED           (APPERR2_BASE + 635)    /* @I
                 *
                 *Server paused%0
                 */
#define APE2_AUDIT_SRV_CONTINUED        (APPERR2_BASE + 636)    /* @I
                 *
                 *Server continued%0
                 */
#define APE2_AUDIT_SRV_STOPPED          (APPERR2_BASE + 637)    /* @I
                 *
                 *Server stopped%0
                 */
#define APE2_AUDIT_SESS                 (APPERR2_BASE + 638)    /* @I
                 *
                 *Session%0
                 */
#define APE2_AUDIT_SESS_GUEST           (APPERR2_BASE + 639)    /* @I
                 *
                 *Logon Guest%0
                 */
#define APE2_AUDIT_SESS_USER            (APPERR2_BASE + 640)    /* @I
                 *
                 *Logon User%0
                 */
#define APE2_AUDIT_SESS_ADMIN           (APPERR2_BASE + 641)    /* @I
                 *
                 *Logon Administrator%0
                 */
#define APE2_AUDIT_SESS_NORMAL          (APPERR2_BASE + 642)    /* @I
                 *
                 *Logoff normal%0
                 */
#define APE2_AUDIT_SESS_DEFAULT         (APPERR2_BASE + 643)    /* @I
                 *
                 *Logon%0
                 */
#define APE2_AUDIT_SESS_ERROR           (APPERR2_BASE + 644)    /* @I
                 *
                 *Logoff error%0
                 */
#define APE2_AUDIT_SESS_AUTODIS         (APPERR2_BASE + 645)    /* @I
                 *
                 *Logoff auto-disconnect%0
                 */
#define APE2_AUDIT_SESS_ADMINDIS        (APPERR2_BASE + 646)    /* @I
                 *
                 *Logoff administrator-disconnect%0
                 */
#define APE2_AUDIT_SESS_ACCRESTRICT     (APPERR2_BASE + 647)    /* @I
                 *
                 *Logoff forced by logon restrictions%0
                 */
#define APE2_AUDIT_SVC                  (APPERR2_BASE + 648)    /* @I
                 *
                 *Service%0
                 */
#define APE2_AUDIT_SVC_INSTALLED        (APPERR2_BASE + 649)    /* @I
                 *
                 *%1 Installed%0
                 */
#define APE2_AUDIT_SVC_INST_PEND        (APPERR2_BASE + 650)    /* @I
                 *
                 *%1 Install Pending%0
                 */
#define APE2_AUDIT_SVC_PAUSED           (APPERR2_BASE + 651)    /* @I
                 *
                 *%1 Paused%0
                 */
#define APE2_AUDIT_SVC_PAUS_PEND        (APPERR2_BASE + 652)    /* @I
                 *
                 *%1 Pause Pending%0
                 */
#define APE2_AUDIT_SVC_CONT             (APPERR2_BASE + 653)    /* @I
                 *
                 *%1 Continued%0
                 */
#define APE2_AUDIT_SVC_CONT_PEND        (APPERR2_BASE + 654)    /* @I
                 *
                 *%1 Continue Pending%0
                 */
#define APE2_AUDIT_SVC_STOP             (APPERR2_BASE + 655)    /* @I
                 *
                 *%1 Stopped%0
                 */
#define APE2_AUDIT_SVC_STOP_PEND        (APPERR2_BASE + 656)    /* @I
                 *
                 *%1 Stop Pending%0
                 */
#define APE2_AUDIT_ACCOUNT              (APPERR2_BASE + 657)    /* @I
                 *
                 *Account%0
                 */
#define APE2_AUDIT_ACCOUNT_USER_MOD     (APPERR2_BASE + 658)    /* @I
                 *
                 *User account %1 was modified.%0
                 */
#define APE2_AUDIT_ACCOUNT_GROUP_MOD    (APPERR2_BASE + 659)    /* @I
                 *
                 *Group account %1 was modified.%0
                 */
#define APE2_AUDIT_ACCOUNT_USER_DEL     (APPERR2_BASE + 660)    /* @I
                 *
                 *User account %1 was deleted%0
                 */
#define APE2_AUDIT_ACCOUNT_GROUP_DEL    (APPERR2_BASE + 661)    /* @I
                 *
                 *Group account %1 was deleted%0
                 */
#define APE2_AUDIT_ACCOUNT_USER_ADD     (APPERR2_BASE + 662)    /* @I
                 *
                 *User account %1 was added%0
                 */
#define APE2_AUDIT_ACCOUNT_GROUP_ADD    (APPERR2_BASE + 663)    /* @I
                 *
                 *Group account %1 was added%0
                 */
#define APE2_AUDIT_ACCOUNT_SETTINGS     (APPERR2_BASE + 664)    /* @I
                 *
                 *Account system settings were modified%0
                 */
#define APE2_AUDIT_ACCLIMIT             (APPERR2_BASE + 665)    /* @I
                 *
                 *Logon restriction%0
                 */
#define APE2_AUDIT_ACCLIMIT_UNKNOWN     (APPERR2_BASE + 666)    /* @I
                 *
                 *Limit exceeded:  UNKNOWN%0
                 */
#define APE2_AUDIT_ACCLIMIT_HOURS       (APPERR2_BASE + 667)    /* @I
                 *
                 *Limit exceeded:  Logon hours%0
                 */
#define APE2_AUDIT_ACCLIMIT_EXPIRED     (APPERR2_BASE + 668)    /* @I
                 *
                 *Limit exceeded:  Account expired%0
                 */
#define APE2_AUDIT_ACCLIMIT_INVAL       (APPERR2_BASE + 669)    /* @I
                 *
                 *Limit exceeded:  Workstation ID invalid%0
                 */
#define APE2_AUDIT_ACCLIMIT_DISABLED    (APPERR2_BASE + 670)    /* @I
                 *
                 *Limit exceeded:  Account disabled%0
                 */
#define APE2_AUDIT_ACCLIMIT_DELETED     (APPERR2_BASE + 671)    /* @I
                 *
                 *Limit exceeded:  Account deleted%0
                 */
#define APE2_AUDIT_SHARE                (APPERR2_BASE + 672)    /* @I
                 *
                 *Share%0
                 */
#define APE2_AUDIT_USE                  (APPERR2_BASE + 673)    /* @I
                 *
                 *Use %1%0
                 */
#define APE2_AUDIT_UNUSE                (APPERR2_BASE + 674)    /* @I
                 *
                 *Unuse %1%0
                 */
#define APE2_AUDIT_SESSDIS              (APPERR2_BASE + 675)    /* @I
                 *
                 *User's session disconnected %1%0
                 */
#define APE2_AUDIT_SHARE_D              (APPERR2_BASE + 676)    /* @I
                 *
                 *Administrator stopped sharing resource %1%0
                 */
#define APE2_AUDIT_USERLIMIT            (APPERR2_BASE + 677)    /* @I
                 *
                 *User reached limit for %1%0
                 */
#define APE2_AUDIT_BADPW                (APPERR2_BASE + 678)    /* @I
                 *
                 *Bad password%0
                 */
#define APE2_AUDIT_ADMINREQD            (APPERR2_BASE + 679)    /* @I
                 *
                 *Administrator privilege required%0
                 */
#define APE2_AUDIT_ACCESS               (APPERR2_BASE + 680)    /* @I
                 *
                 *Access%0
                 */
#define APE2_AUDIT_ACCESS_ADD           (APPERR2_BASE + 681)    /* @I
                 *
                 *%1 permissions added%0
                 */
#define APE2_AUDIT_ACCESS_MOD           (APPERR2_BASE + 682)    /* @I
                 *
                 *%1 permissions modified%0
                 */
#define APE2_AUDIT_ACCESS_DEL           (APPERR2_BASE + 683)    /* @I
                 *
                 *%1 permissions deleted%0
                 */
#define APE2_AUDIT_ACCESS_D             (APPERR2_BASE + 684)    /* @I
                 *
                 *Access denied%0
                 */
#define APE2_AUDIT_UNKNOWN              (APPERR2_BASE + 685)    /* @I
                 *
                 *Unknown%0
                 */
#define APE2_AUDIT_OTHER                (APPERR2_BASE + 686)    /* @I
                 *
                 *Other%0
                 */
#define APE2_AUDIT_DURATION             (APPERR2_BASE + 687)    /* @I
                 *
                 *Duration:%0
                 */
#define APE2_AUDIT_NO_DURATION          (APPERR2_BASE + 688)    /* @I
                 *
                 *Duration: Not available%0
                 */
#define APE2_AUDIT_TINY_DURATION        (APPERR2_BASE + 689)    /* @I
                 *
                 *Duration: Less than one second%0
                 */
#define APE2_AUDIT_NONE                 (APPERR2_BASE + 690)    /* @I
                 *
                 *(none)%0
                 */
#define APE2_AUDIT_CLOSED               (APPERR2_BASE + 691)    /* @I
                 *
                 *Closed %1%0
                 */
#define APE2_AUDIT_DISCONN              (APPERR2_BASE + 692)    /* @I
                 *
                 *Closed %1 (disconnected)%0
                 */
#define APE2_AUDIT_ADMINCLOSED          (APPERR2_BASE + 693)    /* @I
                 *
                 *Administrator closed %1%0
                 */
#define APE2_AUDIT_ACCESSEND            (APPERR2_BASE + 694)    /* @I
                 *
                 *Access ended%0
                 */
#define APE2_AUDIT_NETLOGON             (APPERR2_BASE + 695)    /* @I
                 *
                 *Log on to network%0
                 */
#define APE2_AUDIT_LOGDENY_GEN          (APPERR2_BASE + 696)    /* @I
                 *
                 *Logon denied%0
                 */
#define APE2_ERROR_HEADER               (APPERR2_BASE + 697)    /* @I
                 *
                 *Program             Message             Time%0
                 */
#define APE2_AUDIT_LKOUT_LOCK           (APPERR2_BASE + 698)    /* @I
                 *
                 *Account locked due to %1 bad passwords%0
                 */
#define APE2_AUDIT_LKOUT_ADMINUNLOCK    (APPERR2_BASE + 699)    /* @I
                 *
                 *Account unlocked by administrator%0
                 */
#define APE2_AUDIT_NETLOGOFF            (APPERR2_BASE + 700)    /* @I
                 *
                 *Log off network%0
                 */

/*
 *
 * ALERTER service messages.
 *
 *      Make sure TO, FROM, and all SUBJ messages align to the same
 *      column. Make sure, also, that APE2_ALERTER_TAB is aligned with
 *      TO, FROM, and SUBJ headers!!!!!!
 *
 */

#define APE2_ALERTER_TAB                (APPERR2_BASE + 709) /* @I
     *        */

#define APE2_ALERTER_ADMN_SUBJ          (APPERR2_BASE + 710) /* @I
     *
     *Subj:   ** ADMINISTRATOR ALERT **
     */

#define APE2_ALERTER_PRNT_SUBJ          (APPERR2_BASE + 711) /* @I
     *
     *Subj:   ** PRINTING NOTIFICATION **
     */

#define APE2_ALERTER_USER_SUBJ          (APPERR2_BASE + 712) /* @I
     *
     *Subj:   ** USER NOTIFICATION **
     */

#define APE2_ALERTER_FROM               (APPERR2_BASE + 713) /* @I
     *
     *From:   %1 at \\%2
     */


#define APE2_ALERTER_CANCELLED          (APPERR2_BASE + 714) /* @I
     *
     *Print job %1 has been canceled while printing on %2.
     */

#define APE2_ALERTER_DELETED            (APPERR2_BASE + 715) /* @I
     *
     *Print job %1 has been deleted and will not print.
     */

#define APE2_ALERTER_FINISHED           (APPERR2_BASE + 716) /* @I
     *
     *Printing Complete
     *
     *%1 printed successfully on %2.
     */

#define APE2_ALERTER_INCOMPL            (APPERR2_BASE + 717) /* @I
     *
     *Print job %1 has not completed printing on %2.
     */

#define APE2_ALERTER_PAUSED             (APPERR2_BASE + 718) /* @I
     *
     *Print job %1 has paused printing on %2.
     */

#define APE2_ALERTER_PRINTING           (APPERR2_BASE + 719) /* @I
     *
     *Print job %1 is now printing on %2.
     */

#define APE2_ALERTER_NOPAPER            (APPERR2_BASE + 720) /* @I
     *
     *The printer is out of paper.
     */

#define APE2_ALERTER_OFFLINE            (APPERR2_BASE + 721) /* @I
     *
     *The printer is offline.
     */

#define APE2_ALERTER_ERRORS             (APPERR2_BASE + 722) /* @I
     *
     *Printing errors occurred.
     */

#define APE2_ALERTER_HUMAN              (APPERR2_BASE + 723) /* @I
     *
     *There is a problem with the printer; please check it.
     */

#define APE2_ALERTER_HELD               (APPERR2_BASE + 724) /* @I
     *
     *Print job %1 is being held from printing.
     */

#define APE2_ALERTER_QUEUED             (APPERR2_BASE + 725) /* @I
     *
     *Print job %1 is queued for printing.
     */

#define APE2_ALERTER_SPOOLED            (APPERR2_BASE + 726) /* @I
     *
     *Print job %1 is being spooled.
     */

#define APE2_ALERTER_QUEUEDTO           (APPERR2_BASE + 727) /* @I
     *
     *Job was queued to %1 on %2
     */

#define APE2_ALERTER_SIZE               (APPERR2_BASE + 728) /* @I
     *
     *Size of job is %1 bytes.
     */

#define APE2_ALERTER_TO                 (APPERR2_BASE + 730) /* @I
     *
     *To:     %1
     */

#define APE2_ALERTER_DATE               (APPERR2_BASE + 731) /* @I
     *
     *Date:   %1
     */

#define APE2_ALERTER_ERROR_MSG          (APPERR2_BASE + 732) /* @I
     *
     * The error code is %1.
     * There was an error retrieving the message. Make sure the file
     * NET.MSG is available.
     */

#define APE2_ALERTER_PRINTING_FAILURE   (APPERR2_BASE + 733) /* @I
     *
     * Printing Failed
     *
     * "%1" failed to print on %2 on %3.
     *
     * For more help use the print troubleshooter.
     */

#define APE2_ALERTER_PRINTING_FAILURE2  (APPERR2_BASE + 734) /* @I
     *
     * Printing Failed
     *
     * "%1" failed to print on %2 on %3.  The Printer is %4.
     *
     * For more help use the print troubleshooter.
     */

#define APE2_ALERTER_PRINTING_SUCCESS   (APPERR2_BASE + 735) /* @I
     *
     * Printing Complete
     *
     * "%1" printed successfully on %2 on %3.
     */



/*
 * TIME related stuff go here
 */

#define APE2_TIME_JANUARY                       (APPERR2_BASE + 741)    /* @I
                        *
                        *January%0
                        */

#define APE2_TIME_FEBRUARY                      (APPERR2_BASE + 742)    /* @I
                        *
                        *February%0
                        */

#define APE2_TIME_MARCH                         (APPERR2_BASE + 743)    /* @I
                        *
                        *March%0
                        */

#define APE2_TIME_APRIL                         (APPERR2_BASE + 744)    /* @I
                        *
                        *April%0
                        */

#define APE2_TIME_MAY                           (APPERR2_BASE + 745)    /* @I
                        *
                        *May%0
                        */

#define APE2_TIME_JUNE                          (APPERR2_BASE + 746)    /* @I
                        *
                        *June%0
                        */

#define APE2_TIME_JULY                          (APPERR2_BASE + 747)    /* @I
                        *
                        *July%0
                        */

#define APE2_TIME_AUGUST                        (APPERR2_BASE + 748)    /* @I
                        *
                        *August%0
                        */

#define APE2_TIME_SEPTEMBER                     (APPERR2_BASE + 749)    /* @I
                        *
                        *September%0
                        */

#define APE2_TIME_OCTOBER                       (APPERR2_BASE + 750)    /* @I
                        *
                        *October%0
                        */

#define APE2_TIME_NOVEMBER                      (APPERR2_BASE + 751)    /* @I
                        *
                        *November%0
                        */

#define APE2_TIME_DECEMBER                      (APPERR2_BASE + 752)    /* @I
                        *
                        *December%0
                        */

#define APE2_TIME_JANUARY_ABBREV                (APPERR2_BASE + 753)    /* @I
                        *
                        *Jan%0
                        */

#define APE2_TIME_FEBRUARY_ABBREV               (APPERR2_BASE + 754)    /* @I
                        *
                        *Feb%0
                        */

#define APE2_TIME_MARCH_ABBREV                  (APPERR2_BASE + 755)    /* @I
                        *
                        *Mar%0
                        */

#define APE2_TIME_APRIL_ABBREV                  (APPERR2_BASE + 756)    /* @I
                        *
                        *Apr%0
                        */

#define APE2_TIME_MAY_ABBREV                    (APPERR2_BASE + 757)    /* @I
                        *
                        *May%0
                        */

#define APE2_TIME_JUNE_ABBREV                   (APPERR2_BASE + 758)    /* @I
                        *
                        *Jun%0
                        */

#define APE2_TIME_JULY_ABBREV                   (APPERR2_BASE + 759)    /* @I
                        *
                        *Jul%0
                        */

#define APE2_TIME_AUGUST_ABBREV                 (APPERR2_BASE + 760)    /* @I
                        *
                        *Aug%0
                        */

#define APE2_TIME_SEPTEMBER_ABBREV              (APPERR2_BASE + 761)    /* @I
                        *
                        *Sep%0
                        */

#define APE2_TIME_OCTOBER_ABBREV                (APPERR2_BASE + 762)    /* @I
                        *
                        *Oct%0
                        */

#define APE2_TIME_NOVEMBER_ABBREV               (APPERR2_BASE + 763)    /* @I
                        *
                        *Nov%0
                        */

#define APE2_TIME_DECEMBER_ABBREV               (APPERR2_BASE + 764)    /* @I
                        *
                        *Dec%0
                        */

#define APE2_TIME_DAYS_ABBREV               (APPERR2_BASE + 765)    /* @I
                        *
                        *D%0
                        */

#define APE2_TIME_HOURS_ABBREV               (APPERR2_BASE + 766)    /* @I
                        *
                        *H%0
                        */

#define APE2_TIME_MINUTES_ABBREV               (APPERR2_BASE + 767)    /* @I
                        *
                        *M%0
                        */

#define APE2_TIME_SATURDAY_ABBREV2              (APPERR2_BASE + 768)    /* @I
                        *
                        *Sa%0
                        */

/*
 * Machine Roles
 */

#define APE2_PRIMARY                            (APPERR2_BASE + 770)    /* @I
                        *
                        *PRIMARY%0.
                        */
#define APE2_BACKUP                             (APPERR2_BASE + 771)    /* @I
                        *
                        *BACKUP%0.
                        */
#define APE2_WORKSTATION                        (APPERR2_BASE + 772)    /* @I
                        *
                        *WORKSTATION%0.
                        */
#define APE2_STANDARD_SERVER                    (APPERR2_BASE + 773)    /* @I
                        *
                        *SERVER%0.
                        */

/*
 * Countries
 */

#define APE2_CTRY_System_Default                (APPERR2_BASE + 780) /* @I
        *
        * System Default%0
        */

#define APE2_CTRY_United_States                 (APPERR2_BASE + 781) /* @I
        *
        * United States%0
        */

#define APE2_CTRY_Canada_French                 (APPERR2_BASE + 782) /* @I
        *
        * Canada (French)%0
        */

#define APE2_CTRY_Latin_America                 (APPERR2_BASE + 783) /* @I
        *
        * Latin America%0
        */

#define APE2_CTRY_Netherlands                   (APPERR2_BASE + 784) /* @I
        *
        * Netherlands%0
        */

#define APE2_CTRY_Belgium                       (APPERR2_BASE + 785) /* @I
        *
        * Belgium%0
        */

#define APE2_CTRY_France                        (APPERR2_BASE + 786) /* @I
        *
        * France%0
        */

#define APE2_CTRY_Italy                         (APPERR2_BASE + 787) /* @I
        *
        * Italy%0
        */

#define APE2_CTRY_Switzerland                   (APPERR2_BASE + 788) /* @I
        *
        * Switzerland%0
        */

#define APE2_CTRY_United_Kingdom                (APPERR2_BASE + 789) /* @I
        *
        * United Kingdom%0
        */

#define APE2_CTRY_Spain                         (APPERR2_BASE + 790) /* @I
        *
        * Spain%0
        */

#define APE2_CTRY_Denmark                       (APPERR2_BASE + 791) /* @I
        *
        * Denmark%0
        */

#define APE2_CTRY_Sweden                        (APPERR2_BASE + 792) /* @I
        *
        * Sweden%0
        */

#define APE2_CTRY_Norway                        (APPERR2_BASE + 793) /* @I
        *
        * Norway%0
        */

#define APE2_CTRY_Germany                       (APPERR2_BASE + 794) /* @I
        *
        * Germany%0
        */

#define APE2_CTRY_Australia                     (APPERR2_BASE + 795) /* @I
        *
        * Australia%0
        */

#define APE2_CTRY_Japan                         (APPERR2_BASE + 796) /* @I
        *
        * Japan%0
        */

#define APE2_CTRY_Korea                         (APPERR2_BASE + 797) /* @I
        *
        * Korea%0
        */

#define APE2_CTRY_China_PRC                     (APPERR2_BASE + 798) /* @I
        *
        * China (PRC)%0
        */

#define APE2_CTRY_Taiwan                        (APPERR2_BASE + 799) /* @I
        *
        * Taiwan%0
        */

#define APE2_CTRY_Asia                          (APPERR2_BASE + 800) /* @I
        *
        * Asia%0
        */

#define APE2_CTRY_Portugal                      (APPERR2_BASE + 801) /* @I
        *
        * Portugal%0
        */

#define APE2_CTRY_Finland                       (APPERR2_BASE + 802) /* @I
        *
        * Finland%0
        */

#define APE2_CTRY_Arabic                        (APPERR2_BASE + 803) /* @I
        *
        * Arabic%0
        */

#define APE2_CTRY_Hebrew                        (APPERR2_BASE + 804) /* @I
        *
        * Hebrew%0
        */


/*
 * UPS service messages
 */

#define APE2_UPS_POWER_OUT              (APPERR2_BASE + 850)
        /*
         * A power failure has occurred at %1.  Please terminate all activity with this server.
         */

#define APE2_UPS_POWER_BACK             (APPERR2_BASE + 851)
        /*
         * Power has been restored at %1.  Normal operations have resumed.
         */

#define APE2_UPS_POWER_SHUTDOWN         (APPERR2_BASE + 852)
        /*
         * The UPS service is starting shut down at %1.
         */

#define APE2_UPS_POWER_SHUTDOWN_FINAL   (APPERR2_BASE + 853)
        /*
         * The UPS service is about to perform final shut down.
         */


/*
 * Workstation service messages
 */

#define APE2_WKSTA_CMD_LINE_START               (APPERR2_BASE + 870)    /* @I
         *
         *The Workstation must be started with the NET START command.
         */


/*
 * Server service messages
 */

#define APE2_SERVER_IPC_SHARE_REMARK            (APPERR2_BASE + 875)    /* @I
         *
         *Remote IPC%0
         */

#define APE2_SERVER_ADMIN_SHARE_REMARK          (APPERR2_BASE + 876)    /* @I
         *
         *Remote Admin%0
         */

#define APE2_SERVER_DISK_ADMIN_SHARE_REMARK     (APPERR2_BASE + 877)    /* @I
         *
         *Default share%0
         */


/***
 *
 *      Y/N questions.
 */
#define APE_UserPasswordCompatWarning  (APPERR2_BASE + 980) /* @P
         *
         *The password entered is longer than 14 characters.  Computers
         *with Windows prior to Windows 2000 will not be able to use
         *this account. Do you want to continue this operation? %1: %0
         */

#define APE_OverwriteRemembered (APPERR2_BASE + 981) /* @P
         *
         *%1 has a remembered connection to %2. Do you
         *want to overwrite the remembered connection? %3: %0
         */

#define APE_LoadResume (APPERR2_BASE + 982) /* @P
         *
         *Do you want to resume loading the profile?  The command which
         *caused the error will be ignored. %1: %0
         */

#define APE_OkToProceed  (APPERR2_BASE + 984) /* @P
         *
         *Do you want to continue this operation? %1: %0
         */

#define APE_AddAnyway  (APPERR2_BASE + 985) /* @P
         *
         *Do you want to add this? %1: %0
         */

#define APE_ProceedWOp  (APPERR2_BASE + 986) /* @P
         *
         *Do you want to continue this operation? %1: %0
         */

#define APE_StartOkToStart (APPERR2_BASE + 987) /* @P
         *
         *Is it OK to start it? %1: %0
         */

#define APE_StartRedir (APPERR2_BASE + 988) /* @P
         *
         *Do you want to start the Workstation service? %1: %0
         */

#define APE_UseBlowAway  (APPERR2_BASE + 989) /* @P
         *
         *Is it OK to continue disconnecting and force them closed? %1: %0
         */

#define APE_CreatQ  (APPERR2_BASE + 990) /* @P
         *
         *The printer does not exist.  Do you want to create it? %1: %0
         */
/***
 *
 *   #ifdef JAPAN
 *
 *   Japanese version specific messages
 *
 */

#define APE2_NEVER_FORCE_LOGOFF    (APPERR2_BASE + 991) /* @I
        *
        *Never%0
        */

#define APE2_NEVER_EXPIRED    (APPERR2_BASE + 992) /* @I
        *
        *Never%0
        */

#define APE2_NEVER_LOGON    (APPERR2_BASE + 993) /* @I
        *
        *Never%0
        */

#define APE2_

/***
 *
 *   #endif // JAPAN
 *
 */

/***
 *
 * Help file name for NETCMD
 *
 */
#define APE2_US_NETCMD_HELP_FILE    (APPERR2_BASE + 995) /* @I
        *
        *NET.HLP%0
        */

#define APE2_FE_NETCMD_HELP_FILE    (APPERR2_BASE + 996) /* @I
        *
        *NET.HLP%0
        */
=== C:/Users/treeman/Desktop/windows nt source code\Source\Win2K3\NT\public\internal\ds\inc\confname.h ===
/*++

Copyright (c) 1991-1993  Microsoft Corporation

Module Name:

    ConfName.h

Abstract:

    This header file defines the names of sections and keywords in the config
    data.

Author:

    John Rogers (JohnRo) 13-Feb-1992

Revision History:

    13-Feb-1992 JohnRo
        Moved equates here from Net/Inc/Config.h and Repl/Common/IniParm.h
    24-Feb-1992 JohnRo
        Interval is obsolete for NT: don't keep in registry.
    13-Mar-1992 JohnRo
        Added many sections and keywords as part of getting rid of old config
        helper callers.
    13-Mar-1992 JohnRo
        Added KEYWORD_TRUE and KEYWORD_FALSE for general boolean use.
    14-Mar-1992 JohnRo
        Get rid of old net config helper callers.
    23-Mar-1992 JohnRo
        Added some stuff for netlogon service.
    08-May-1992 JohnRo
        Implement wksta sticky set info.
    08-May-1992 JohnRo
        Workstation transports are now a keyword, not a section.
    09-May-1992 JohnRo
        Added SECT_NT_BROWSER and BROWSER_KEYWORD_OTHERDOMAINS.
    10-May-1992 JohnRo
        NT section names MUST be same as service names, so use thoses equates
        here.
    13-May-1992 JohnRo
        Added NetpAllocConfigName().
    08-Jul-1992 JohnRo
        RAID 10503: Corrected values of replicator's import and export sections.
    16-Aug-1992 JohnRo
        RAID 3607: REPLLOCK.RP$ is being created during tree copy.
    01-Dec-1992 JohnRo
        RAID 3844: remote NetReplSetInfo uses local machine type.
    24-Mar-1993 JohnRo
        Repl svc should use DBFlag in registry.
        Made some changes suggested by PC-LINT 5.0
    12-Apr-1993 JohnRo
        RAID 5483: server manager: wrong path given in repl dialog.

--*/

#ifndef _CONFNAME_
#define _CONFNAME_


#include <lmcons.h>     // NET_API_STATUS.
/*lint -efile(764,lmsname.h) */
/*lint -efile(766,lmsname.h) */
#include <lmsname.h>    // SERVICE_ equates.


//
// General purpose equates.
//
#define KEYWORD_FALSE           TEXT("FALSE")
#define KEYWORD_TRUE            TEXT("TRUE")

#define KEYWORD_NO              TEXT("NO")
#define KEYWORD_YES             TEXT("YES")


//
// Equate names for sections in the networking portion of the config data.
// Note that the routines in <config.h> only accept the SECT_NT_ versions.
// The others are included for use with the NetConfig APIs when they are
// remoted to downlevel machines.  (A program can tell the difference by
// looking at the platform ID from a wksta or server get info call.)
//


///////////////////////////////////////////////////////////////////////////////

#define SECT_NT_ALERTER                  SERVICE_ALERTER

#define ALERTER_KEYWORD_ALERTNAMES       TEXT("AlertNames")

///////////////////////////////////////////////////////////////////////////////

#define SECT_NT_BROWSER                  SERVICE_BROWSER

///////////////////////////////////////////////////////////////////////////////

#define ENV_KEYWORD_SYSTEMROOT           TEXT("SystemRoot")

///////////////////////////////////////////////////////////////////////////////

#define NETLOGON_KEYWORD_DBFLAG          TEXT("DBFlag")
#define NETLOGON_KEYWORD_PULSE           TEXT("Pulse")
#define NETLOGON_KEYWORD_PULSEMAXIMUM    TEXT("PulseMaximum")
#define NETLOGON_KEYWORD_PULSECONCURRENCY TEXT("PulseConcurrency")
#define NETLOGON_KEYWORD_PULSETIMEOUT1   TEXT("PulseTimeout1")
#define NETLOGON_KEYWORD_PULSETIMEOUT2   TEXT("PulseTimeout2")
#define NETLOGON_KEYWORD_RANDOMIZE       TEXT("Randomize")
#define NETLOGON_KEYWORD_SCRIPTS         TEXT("Scripts")
#define NETLOGON_KEYWORD_SYSVOL          TEXT("SysVol")
#define NETLOGON_KEYWORD_UPDATE          TEXT("Update")
#define NETLOGON_KEYWORD_DISABLEPASSWORDCHANGE TEXT("DisablePasswordChange")
#define NETLOGON_KEYWORD_REFUSEPASSWORDCHANGE  TEXT("RefusePasswordChange")
#define NETLOGON_KEYWORD_MAXIMUMLOGFILESIZE    TEXT("MaximumLogFileSize")
#define NETLOGON_KEYWORD_GOVERNOR        TEXT("ReplicationGovernor")
#define NETLOGON_KEYWORD_CHANGELOGSIZE   TEXT("ChangeLogSize")
#define NETLOGON_KEYWORD_MAXIMUMMAILSLOTMESSAGES TEXT("MaximumMailslotMessages")
#define NETLOGON_KEYWORD_MAILSLOTMESSAGETIMEOUT TEXT("MailslotMessageTimeout")
#define NETLOGON_KEYWORD_MAILSLOTDUPLICATETIMEOUT TEXT("MailslotDuplicateTimeout")
#define NETLOGON_KEYWORD_TRUSTEDDOMAINLIST TEXT("TrustedDomainList")
#define NETLOGON_KEYWORD_MAXIMUMREPLICATORTHREADCOUNT TEXT("MaximumReplicatorThreadCount")
#define NETLOGON_KEYWORD_EXPECTEDDIALUPDELAY TEXT("ExpectedDialupDelay")
#define NETLOGON_KEYWORD_SCAVENGEINTERVAL TEXT("ScavengeInterval")
#define NETLOGON_KEYWORD_LDAPSRVPRIORITY TEXT("LdapSrvPriority")
#define NETLOGON_KEYWORD_LDAPSRVWEIGHT   TEXT("LdapSrvWeight")
#define NETLOGON_KEYWORD_LDAPSRVPORT     TEXT("LdapSrvPort")
#define NETLOGON_KEYWORD_LDAPGCSRVPORT   TEXT("LdapGcSrvPort")
#define NETLOGON_KEYWORD_DNSTTL          TEXT("DnsTtl")
#define NETLOGON_KEYWORD_DNSREFRESHINTERVAL TEXT("DnsRefreshInterval")
#define NETLOGON_KEYWORD_SITENAME        TEXT("SiteName")
#define NETLOGON_KEYWORD_DYNAMICSITENAME TEXT("DynamicSiteName")
#define NETLOGON_KEYWORD_SITECOVERAGE    TEXT("SiteCoverage")
#define NETLOGON_KEYWORD_GCSITECOVERAGE  TEXT("GcSiteCoverage")
#define NETLOGON_KEYWORD_NDNCSITECOVERAGE  TEXT("NdncSiteCoverage")
#define NETLOGON_KEYWORD_MAXIMUMPASSWORDAGE  TEXT("MaximumPasswordAge")
#define NETLOGON_KEYWORD_ALLOWREPLINNONMIXED TEXT("AllowReplInNonMixed")
#define NETLOGON_KEYWORD_KERBISDDONEWITHJOIN TEXT("KerbIsDoneWithJoinDomainEntry")
#define NETLOGON_KEYWORD_DNSAVOIDNAME TEXT("DnsAvoidRegisterRecords")
#define NETLOGON_KEYWORD_NT4EMULATOR TEXT("Nt4Emulator")
#define NETLOGON_KEYWORD_NEUTRALIZENT4EMULATOR TEXT("NeutralizeNt4Emulator")

//
// Netlogons join domain paths
//
#define NETSETUPP_NETLOGON_JD_PATH                                      \
        TEXT("SYSTEM\\CurrentControlSet\\Services\\Netlogon")
#define NETSETUPP_NETLOGON_AVOID_SPN_PATH                               \
        TEXT("SYSTEM\\CurrentControlSet\\Services\\Netlogon\\AvoidSpnSet")
#define NETSETUPP_NETLOGON_AVOID_SPN   TEXT("AvoidSpnSet")
#define NETSETUPP_NETLOGON_JD       TEXT("JoinDomain")
#define NETSETUPP_NETLOGON_JD_DC    TEXT("DomainControllerName")
#define NETSETUPP_NETLOGON_JD_DCA   TEXT("DomainControllerAddress")
#define NETSETUPP_NETLOGON_JD_DCAT  TEXT("DomainControllerAddressType")
#define NETSETUPP_NETLOGON_JD_DG    TEXT("DomainGuid")
#define NETSETUPP_NETLOGON_JD_DN    TEXT("DomainName")
#define NETSETUPP_NETLOGON_JD_DFN   TEXT("DnsForestName")
#define NETSETUPP_NETLOGON_JD_F     TEXT("Flags")
#define NETSETUPP_NETLOGON_JD_DSN   TEXT("DcSiteName")
#define NETSETUPP_NETLOGON_JD_CSN   TEXT("ClientSiteName")
#define NETSETUPP_NETLOGON_JD_NAME                                      \
        TEXT("SYSTEM\\CurrentControlSet\\Services\\Netlogon\\JoinDomain")

///////////////////////////////////////////////////////////////////////////////

#define SECT_LM20_SERVER                 TEXT("Server")

///////////////////////////////////////////////////////////////////////////////

#define SECT_LM20_SERVICES               TEXT("Services")

///////////////////////////////////////////////////////////////////////////////

#define SECT_NT_WKSTA                    SERVICE_WORKSTATION

#define WKSTA_KEYWORD_OTHERDOMAINS       TEXT("OtherDomains")
#define WKSTA_KEYWORD_CHARWAIT           TEXT("CharWait")
#define WKSTA_KEYWORD_MAXCOLLECTIONCOUNT TEXT("MaxCollectionCount")
#define WKSTA_KEYWORD_COLLECTIONTIME     TEXT("CollectionTime")
#define WKSTA_KEYWORD_KEEPCONN           TEXT("KeepConn")
#define WKSTA_KEYWORD_MAXCMDS            TEXT("MaxCmds")
#define WKSTA_KEYWORD_SESSTIMEOUT        TEXT("SessTimeout")
#define WKSTA_KEYWORD_SIZCHARBUF         TEXT("SizCharBuf")
#define WKSTA_KEYWORD_MAXTHREADS         TEXT("MaxThreads")
#define WKSTA_KEYWORD_LOCKQUOTA          TEXT("LockQuota")
#define WKSTA_KEYWORD_LOCKINCREMENT      TEXT("LockIncrement")
#define WKSTA_KEYWORD_LOCKMAXIMUM        TEXT("LockMaximum")
#define WKSTA_KEYWORD_PIPEINCREMENT      TEXT("PipeIncrement")
#define WKSTA_KEYWORD_PIPEMAXIMUM        TEXT("PipeMaximum")
#define WKSTA_KEYWORD_CACHEFILETIMEOUT   TEXT("CacheFileTimeout")
#define WKSTA_KEYWORD_DORMANTFILELIMIT   TEXT("DormantFileLimit")
#define WKSTA_KEYWORD_READAHEADTHRUPUT   TEXT("ReadAheadThroughput")
#define WKSTA_KEYWORD_MAILSLOTBUFFERS    TEXT("MailslotBuffers")
#define WKSTA_KEYWORD_SERVERANNOUNCEBUFS TEXT("ServerAnnounceBuffers")
#define WKSTA_KEYWORD_NUM_ILLEGAL_DG_EVENTS TEXT("NumIllegalDatagramEvents")
#define WKSTA_KEYWORD_ILLEGAL_DG_RESET_TIME TEXT("IllegalDatagramResetTime")
#define WKSTA_KEYWORD_LOG_ELECTION_PACKETS TEXT("LogElectionPackets")
#define WKSTA_KEYWORD_USEOPLOCKING       TEXT("UseOpportunisticLocking")
#define WKSTA_KEYWORD_USEUNLOCKBEHIND    TEXT("UseUnlockBehind")
#define WKSTA_KEYWORD_USECLOSEBEHIND     TEXT("UseCloseBehind")
#define WKSTA_KEYWORD_BUFNAMEDPIPES      TEXT("BufNamedPipes")
#define WKSTA_KEYWORD_USELOCKREADUNLOCK  TEXT("UseLockReadUnlock")
#define WKSTA_KEYWORD_UTILIZENTCACHING   TEXT("UtilizeNtCaching")
#define WKSTA_KEYWORD_USERAWREAD         TEXT("UseRawRead")
#define WKSTA_KEYWORD_USERAWWRITE        TEXT("UseRawWrite")
#define WKSTA_KEYWORD_USEWRITERAWDATA    TEXT("UseWriteRawData")
#define WKSTA_KEYWORD_USEENCRYPTION      TEXT("UseEncryption")
#define WKSTA_KEYWORD_BUFFILESDENYWRITE  TEXT("BufFilesDenyWrite")
#define WKSTA_KEYWORD_BUFREADONLYFILES   TEXT("BufReadOnlyFiles")
#define WKSTA_KEYWORD_FORCECORECREATE    TEXT("ForceCoreCreateMode")
#define WKSTA_KEYWORD_USE512BYTEMAXTRANS TEXT("Use512ByteMaxTransfer")

///////////////////////////////////////////////////////////////////////////////

#define WKSTA_KEYWORD_MAINTAINSRVLST     TEXT("MaintainServerList")

#ifdef ENABLE_PSEUDO_BROWSER
// Browser modern keys
#define BROWSER_POLICY_REGPATH_W            \
        L"SOFTWARE\\Policies\\Microsoft\\Windows\\Browser"
#define BROWSER_SEND_SERVER_ENUM_REGKEY_W   \
        L"SendServerEnum"
#define BROWSER_PSEUDO_SERVER_REGKEY_W      \
        L"BrowserPseudoServer"
#endif


///////////////////////////////////////////////////////////////////////////////

NET_API_STATUS
NetpAllocConfigName(
    IN LPTSTR DatabaseName,              // SERVICES_xxx_DATABASE from winsvc.h.
    IN LPTSTR ServiceName,               // SERVICE_ name equate from lmsname.h
    IN LPTSTR AreaUnderServiceName OPTIONAL,  // defaults to "Parameters"
    OUT LPTSTR *FullConfigName           // free with NetApiBufferFree.
    );


#endif // ndef _CONFNAME_
=== C:/Users/treeman/Desktop/windows nt source code\Source\Win2K3\NT\public\internal\ds\inc\credp.h ===
/*++ BUILD Version: 0001    // Increment this if a change has global effects

Copyright (c) 2000 Microsoft Corporation

Module Name:

    credp.h

Abstract:

    This module contains the private data structures and API definitions
    needed for the Credential Manager.


Author:

    Cliff Van Dyke (CliffV) 28-February-2000

Revision History:

--*/

#ifndef _CREDP_H_
#define _CREDP_H_

#if !defined(_ADVAPI32_)
#define WINADVAPI DECLSPEC_IMPORT
#else
#define WINADVAPI
#endif

#include <lmcons.h>

#ifdef __cplusplus
extern "C" {
#endif

//
// Describe direction of character conversion
//
typedef enum _WTOA_ENUM {
    DoWtoA = 1,     // Convert unicode to ansi
    DoAtoW,         // Convert ansi to unicode
    DoWtoW          // Convert unicode to unicode
} WTOA_ENUM, *PWTOA_ENUM;

//
// Describe whether encoding or decoding should be done
//
typedef enum _ENCODE_BLOB_ENUM {
    DoBlobEncode = 0,   // Encode CredentialBlob
    DoBlobDecode,       // Decode CredentialBlob
    DoBlobNeither       // Leave Credential blob intact
} ENCODE_BLOB_ENUM, *PENCODE_BLOB_ENUM;




//
// Define the valid target name types
//

typedef enum _TARGET_NAME_TYPE {
    IsUsernameTarget,
    IsNotUsernameTarget,
    MightBeUsernameTarget
} TARGET_NAME_TYPE, *PTARGET_NAME_TYPE;

//
// enum describing different types of wildcarding in the TargetName field of a credential.
//

typedef enum _WILDCARD_TYPE {
    WcDfsShareName,         // Target name of the form <DfsRoot>\<DfsShare>
    WcServerName,           // Target name of the form <ServerName>
    WcServerWildcard,       // Wildcard of the form *.<DnsName>
    WcDomainWildcard,       // Wildcard of the form <Domain>\*
    WcUniversalSessionWildcard,   // Wildcard of the form "*Session"
    WcUniversalWildcard,    // Wildcard of the form *
    WcUserName              // Target Name equals UserName
} WILDCARD_TYPE, *PWILDCARD_TYPE;

//
// When passing a credential around, the CredentialBlob field is encrypted.
// This structure describes this encrypted form.
//
//
#ifndef _ENCRYPTED_CREDENTIAL_DEFINED
#define _ENCRYPTED_CREDENTIAL_DEFINED

typedef struct _ENCRYPTED_CREDENTIALW {

    //
    // The credential
    //
    // The CredentialBlob field points to the encrypted credential
    // The CredentialBlobSize field is the length (in bytes) of the encrypted credential
    //

    CREDENTIALW Cred;

    //
    // The size in bytes of the clear text credential blob
    //

    ULONG ClearCredentialBlobSize;

} ENCRYPTED_CREDENTIALW, *PENCRYPTED_CREDENTIALW;
#endif // _ENCRYPTED_CREDENTIAL_DEFINED


//
// Macro to determine the size of the credential blob buffer to allocate
//
// Round up for RTL_ENCRYPT_MEMORY_SIZE
//

#define AllocatedCredBlobSize( _Size ) \
                ROUND_UP_COUNT( (_Size), RTL_ENCRYPT_MEMORY_SIZE )

//
// Procedures
//

WINADVAPI
DWORD
WINAPI
CredpConvertTargetInfo (
    IN WTOA_ENUM WtoA,
    IN PCREDENTIAL_TARGET_INFORMATIONW InTargetInfo,
    OUT PCREDENTIAL_TARGET_INFORMATIONW *OutTargetInfo,
    OUT PULONG OutTargetInfoSize
    );

WINADVAPI
DWORD
WINAPI
CredpConvertCredential (
    IN WTOA_ENUM WtoA,
    IN ENCODE_BLOB_ENUM DoDecode,
    IN PCREDENTIALW InCredential,
    OUT PCREDENTIALW *OutCredential
    );

WINADVAPI
BOOL
WINAPI
CredpEncodeCredential (
    IN OUT PENCRYPTED_CREDENTIALW Credential
    );

WINADVAPI
BOOL
WINAPI
CredpDecodeCredential (
    IN OUT PENCRYPTED_CREDENTIALW Credential
    );


WINADVAPI
BOOL
WINAPI
CredProfileLoaded (
    VOID
    );


NTSTATUS
NET_API_FUNCTION
CredpValidateTargetName(
    IN OUT LPWSTR TargetName,
    IN ULONG Type,
    IN TARGET_NAME_TYPE TargetNameType,
    IN LPWSTR *UserNamePointer OPTIONAL,
    IN LPDWORD PersistPointer OPTIONAL,
    OUT PULONG TargetNameSize,
    OUT PWILDCARD_TYPE WildcardTypePointer OPTIONAL,
    OUT PUNICODE_STRING NonWildcardedTargetName OPTIONAL
    );


#ifdef __cplusplus
}
#endif

#endif // _CREDP_H_
=== C:/Users/treeman/Desktop/windows nt source code\Source\Win2K3\NT\public\internal\ds\inc\crypstub.h ===
/*++

Copyright (C) 2000  Microsoft Corporation

Module Name:

    crypstub.h

Abstract:

    RPC Proxy Stub to handle downlevel requests to the services.exe 
    pipe

Author:

    petesk   3/1/00

Revisions:


--*/

extern "C" {
NTSTATUS
WINAPI
StartCryptServiceStubs( 
     PSVCS_START_RPC_SERVER RpcpStartRpcServer,
     LPTSTR SvcsRpcPipeName
    );

NTSTATUS
WINAPI
StopCryptServiceStubs( 
    PSVCS_STOP_RPC_SERVER RpcpStopRpcServer
    );
};
=== C:/Users/treeman/Desktop/windows nt source code\Source\Win2K3\NT\public\internal\ds\inc\authzi.h ===
/*++

Copyright (c) 2000 Microsoft Corporation

Module Name:

    authzi.h

Abstract:

    This module contains the authorization framework APIs for internal callers.

Author:

    Kedar Dubhashi - October 2000

Revision History:

    Created - October 2000

--*/

#ifndef __AUTHZI_H__
#define __AUTHZI_H__

#include <authz.h>

#ifdef __cplusplus
extern "C" {
#endif

DECLARE_HANDLE(AUTHZ_AUDIT_QUEUE_HANDLE);

typedef AUTHZ_AUDIT_QUEUE_HANDLE *PAUTHZ_AUDIT_QUEUE_HANDLE;



//
// For AuthziInitializeAuditEventType
//

#define AUTHZP_INIT_GENERIC_AUDIT_EVENT 0x1

AUTHZAPI
BOOL
WINAPI
AuthziInitializeAuditEventType(
    IN  DWORD                          Flags,
    IN  USHORT                         CategoryID,
    IN  USHORT                         AuditID,
    IN  USHORT                         ParameterCount,
    OUT PAUTHZ_AUDIT_EVENT_TYPE_HANDLE phAuditEventType
    );

//
// Flags for AuthziModifyAuditEventType
//

#define AUTHZ_AUDIT_EVENT_TYPE_AUDITID 0x1
#define AUTHZ_AUDIT_EVENT_TYPE_CATEGID 0x2 // not implemented
#define AUTHZ_AUDIT_EVENT_TYPE_PARAM   0x4 // not implemented

AUTHZAPI
BOOL
WINAPI
AuthziModifyAuditEventType(
    IN DWORD Flags,
    IN USHORT CategoryID,
    IN USHORT AuditID,
    IN USHORT ParameterCount,
    IN OUT AUTHZ_AUDIT_EVENT_TYPE_HANDLE hAuditEventType
    );
    
AUTHZAPI
BOOL
WINAPI
AuthziFreeAuditEventType(
    AUTHZ_AUDIT_EVENT_TYPE_HANDLE hAuditEventType
    );

#define AUTHZ_MONITOR_AUDIT_QUEUE_SIZE 0x00000001

AUTHZAPI
BOOL
WINAPI
AuthziInitializeAuditQueue(
    IN DWORD                      Flags,
    IN DWORD                      dwAuditQueueHigh,
    IN DWORD                      dwAuditQueueLow,
    IN PVOID                      Reserved,
    OUT PAUTHZ_AUDIT_QUEUE_HANDLE phAuditQueue
    );
            
#define AUTHZ_AUDIT_QUEUE_HIGH            0x00000001
#define AUTHZ_AUDIT_QUEUE_LOW             0x00000002
#define AUTHZ_AUDIT_QUEUE_THREAD_PRIORITY 0x00000004
#define AUTHZ_AUDIT_QUEUE_FLAGS           0x00000008
#define AUTHZP_MONITOR_AUDIT_QUEUE_SIZE   0x00000010

AUTHZAPI
BOOL
WINAPI
AuthziModifyAuditQueue(
    IN OUT AUTHZ_AUDIT_QUEUE_HANDLE pQueue OPTIONAL,
    IN DWORD Flags,
    IN DWORD dwQueueFlags OPTIONAL,
    IN DWORD dwAuditQueueSizeHigh OPTIONAL,
    IN DWORD dwAuditQueueSizeLow OPTIONAL,
    IN DWORD dwThreadPriority OPTIONAL
    );

AUTHZAPI
BOOL
WINAPI
AuthziFreeAuditQueue(
    IN AUTHZ_AUDIT_QUEUE_HANDLE hQueue OPTIONAL
    );

AUTHZAPI
BOOL
WINAPI
AuthziLogAuditEvent(
    IN DWORD Flags,
    IN AUTHZ_AUDIT_EVENT_HANDLE hEvent,
    IN PVOID pReserved
    );

AUTHZAPI
BOOL
WINAPI
AuthziAllocateAuditParams(
    OUT PAUDIT_PARAMS * ppParams,
    IN USHORT NumParams
    );
    
AUTHZAPI
BOOL
WINAPI
AuthziInitializeAuditParamsWithRM(
    IN DWORD Flags,
    IN AUTHZ_RESOURCE_MANAGER_HANDLE hResourceManager,
    IN USHORT NumParams,
    OUT PAUDIT_PARAMS pParams,
    ...
    );

AUTHZAPI
BOOL
WINAPI
AuthziInitializeAuditParamsFromArray(
    IN DWORD Flags,
    IN AUTHZ_RESOURCE_MANAGER_HANDLE hResourceManager,
    IN USHORT NumParams,
    IN PAUDIT_PARAM pParamArray,
    OUT PAUDIT_PARAMS pParams
    );
    
AUTHZAPI
BOOL
WINAPI
AuthziInitializeAuditParams(
    IN  DWORD         dwFlags,
    OUT PAUDIT_PARAMS pParams,
    OUT PSID*         ppUserSid,
    IN  PCWSTR        SubsystemName,
    IN  USHORT        NumParams,
    ...
    );

AUTHZAPI
BOOL
WINAPI
AuthziFreeAuditParams(
    PAUDIT_PARAMS pParams
    );
    
#define AUTHZ_DS_CATEGORY_FLAG                   0x00000008

AUTHZAPI
BOOL
WINAPI
AuthziInitializeAuditEvent(
    IN  DWORD                         Flags,
    IN  AUTHZ_RESOURCE_MANAGER_HANDLE hRM,
    IN  AUTHZ_AUDIT_EVENT_TYPE_HANDLE hAuditEventType  OPTIONAL,
    IN  PAUDIT_PARAMS                 pAuditParams     OPTIONAL,
    IN  AUTHZ_AUDIT_QUEUE_HANDLE      hAuditQueue      OPTIONAL,
    IN  DWORD                         dwTimeOut,
    IN  PWSTR                         szOperationType,
    IN  PWSTR                         szObjectType,
    IN  PWSTR                         szObjectName,
    IN  PWSTR                         szAdditionalInfo OPTIONAL,
    OUT PAUTHZ_AUDIT_EVENT_HANDLE     phAuditEvent
    );

//                      
// Valid flags for AuthzModifyAuditEvent 
//
        
#define AUTHZ_AUDIT_EVENT_FLAGS             0x00000001
#define AUTHZ_AUDIT_EVENT_OPERATION_TYPE    0x00000002
#define AUTHZ_AUDIT_EVENT_OBJECT_TYPE       0x00000004
#define AUTHZ_AUDIT_EVENT_OBJECT_NAME       0x00000008
#define AUTHZ_AUDIT_EVENT_ADDITIONAL_INFO   0x00000010
#define AUTHZ_AUDIT_EVENT_ADDITIONAL_INFO2  0x00000020
        
#define AUTHZ_VALID_MODIFY_AUDIT_EVENT_FLAGS  (AUTHZ_AUDIT_EVENT_FLAGS            | \
                                               AUTHZ_AUDIT_EVENT_OPERATION_TYPE   | \
                                               AUTHZ_AUDIT_EVENT_OBJECT_TYPE      | \
                                               AUTHZ_AUDIT_EVENT_OBJECT_NAME      | \
                                               AUTHZ_AUDIT_EVENT_ADDITIONAL_INFO  | \
                                               AUTHZ_AUDIT_EVENT_ADDITIONAL_INFO2)
AUTHZAPI
BOOL
WINAPI
AuthziModifyAuditEvent(
    IN DWORD                    Flags,
    IN AUTHZ_AUDIT_EVENT_HANDLE hAuditEvent,
    IN DWORD                    NewFlags,
    IN PWSTR                    szOperationType,
    IN PWSTR                    szObjectType,
    IN PWSTR                    szObjectName,
    IN PWSTR                    szAdditionalInfo
    );

AUTHZAPI
BOOL
WINAPI
AuthziModifyAuditEvent2(
    IN DWORD                    Flags,
    IN AUTHZ_AUDIT_EVENT_HANDLE hAuditEvent,
    IN DWORD                    NewFlags,
    IN PWSTR                    szOperationType,
    IN PWSTR                    szObjectType,
    IN PWSTR                    szObjectName,
    IN PWSTR                    szAdditionalInfo,
    IN PWSTR                    szAdditionalInfo2
    );

AUTHZAPI
BOOL
WINAPI
AuthziQueryAuditPolicy(
    IN     DWORD                       dwFlags,
    IN     AUTHZ_CLIENT_CONTEXT_HANDLE hContext,
    IN     PCWSTR                      szResourceManager OPTIONAL,
    IN     DWORD                       dwEventID,
    OUT    PTOKEN_AUDIT_POLICY         pPolicy,
    IN OUT PDWORD                      pPolicySize
    );
    
AUTHZAPI
BOOL
WINAPI
AuthziSetAuditPolicy(
    IN DWORD                       dwFlags,
    IN AUTHZ_CLIENT_CONTEXT_HANDLE hContext,
    IN PCWSTR                      szResourceManager OPTIONAL,
    IN PTOKEN_AUDIT_POLICY         pPolicy
    );
    
AUTHZAPI
BOOL
WINAPI
AuthziSourceAudit(
    IN DWORD dwFlags,
    IN USHORT CategoryId,
    IN USHORT AuditId,
    IN PWSTR szSource,
    IN PSID pUserSid OPTIONAL,
    IN USHORT Count,
    ...
    );

AUTHZAPI
BOOL
WINAPI
AuthziInitializeContextFromSid(
    IN  DWORD                         Flags,
    IN  PSID                          UserSid,
    IN  AUTHZ_RESOURCE_MANAGER_HANDLE hAuthzResourceManager,
    IN  PLARGE_INTEGER                pExpirationTime        OPTIONAL,
    IN  LUID                          Identifier,
    IN  PVOID                         DynamicGroupArgs       OPTIONAL,
    OUT PAUTHZ_CLIENT_CONTEXT_HANDLE  phAuthzClientContext
    );

#ifdef __cplusplus
}
#endif

#endif
=== C:/Users/treeman/Desktop/windows nt source code\Source\Win2K3\NT\public\internal\ds\inc\brcommon.h ===
/*++

Copyright (c) 1991  Microsoft Corporation

Module Name:

    brcommon.h

Abstract:

    Header for utility routines for the browser service.

Author:

    Larry Osterman (LarryO) 23-Mar-1992

Environment:

    User Mode - Win32

Revision History:

--*/

#ifndef _BRCOMMON_
#define _BRCOMMON_

#include <winsvc.h>
#include <svcs.h>       //  PSVCS_NET_BIOS_RESET

#if DEVL
//
//  Codes for I_BrowserDebugCall
//

#define BROWSER_DEBUG_BREAK_POINT        0
#define BROWSER_DEBUG_DUMP_NETWORKS      1
#define BROWSER_DEBUG_DUMP_SERVERS       2
#define BROWSER_DEBUG_ENABLE_BROWSER     3
#define BROWSER_DEBUG_SET_DEBUG          4
#define BROWSER_DEBUG_CLEAR_DEBUG        5
#define BROWSER_DEBUG_TICKLE             6
#define BROWSER_DEBUG_ELECT              7
#define BROWSER_DEBUG_GET_MASTER         8
#define BROWSER_DEBUG_FIND_MASTER        9
#define BROWSER_DEBUG_GET_BACKUP_LIST   10
#define BROWSER_DEBUG_ANNOUNCE_MASTER   11
#define BROWSER_DEBUG_ILLEGAL_DGRAM     12
#define BROWSER_DEBUG_GET_OTHLIST       13
#define BROWSER_DEBUG_ADD_MASTERNAME    14
#define BROWSER_DEBUG_VIEW              15
#define BROWSER_DEBUG_FORCE_ANNOUNCE    16
#define BROWSER_DEBUG_LOCAL_BRLIST      17
#define BROWSER_DEBUG_ANNOUNCE          18
#define BROWSER_DEBUG_RPCLIST           19
#define BROWSER_DEBUG_RPCCMP            20
#define BROWSER_DEBUG_TRUNCATE_LOG      21
#define BROWSER_DEBUG_STATISTICS        22
#define BROWSER_DEBUG_BOWSERDEBUG       23
#define BROWSER_DEBUG_POPULATE_SERVER   24
#define BROWSER_DEBUG_POPULATE_DOMAIN   25
#define BROWSER_DEBUG_LIST_WFW          26
#define BROWSER_DEBUG_STATUS            27
#define BROWSER_DEBUG_GETPDC            28
#define BROWSER_DEBUG_ADD_DOMAINNAME    29
#define BROWSER_DEBUG_GET_WINSSERVER    30
#define BROWSER_DEBUG_GET_DOMAINLIST    31
#define BROWSER_DEBUG_GET_NETBIOSNAMES  32
#define BROWSER_DEBUG_SET_EMULATEDDOMAIN 33
#define BROWSER_DEBUG_SET_EMULATEDDOMAINENUM 34
#define BROWSER_DEBUG_ADD_ALTERNATE     35
#define BROWSER_DEBUG_BIND_TRANSPORT    36
#define BROWSER_DEBUG_UNBIND_TRANSPORT  37
#define BROWSER_DEBUG_RENAME_DOMAIN     38

//
// Debug trace level bits for turning on/off trace statements in the
// browser service
//

#define BR_CRITICAL     0x00000001
#define BR_INIT         0x00000002
#define BR_UTIL         0x00000020
#define BR_CONFIG       0x00000040
#define BR_MAIN         0x00000080
#define BR_BACKUP       0x00000400
#define BR_MASTER       0x00000800
#define BR_DOMAIN       0x00001000
#define BR_NETWORK      0x00002000
#define BR_CLIENT_OP	0x00004000
#define BR_COMMON       0x0000FFFF

#define BR_TIMER        0x00010000
#define BR_QUEUE        0x00020000
#define BR_LOCKS        0x00040000
#define BR_SERVER_ENUM  0x00100000

#define BR_ALL          0xFFFFFFFF

NET_API_STATUS
I_BrowserDebugCall (
    IN  LPWSTR      servername OPTIONAL,
    IN  DWORD DebugCode,
    IN  DWORD OptionalValue
    );

#endif

typedef struct _INTERIM_ELEMENT {
    LIST_ENTRY NextElement;
    ULONG   Periodicity;
    ULONG   TimeLastSeen;
    ULONG   PlatformId;
    ULONG   MajorVersionNumber;
    ULONG   MinorVersionNumber;
    ULONG   Type;
    WCHAR   Name[CNLEN+1];
    WCHAR   Comment[LM20_MAXCOMMENTSZ+1];
} INTERIM_ELEMENT, *PINTERIM_ELEMENT;

struct _INTERIM_SERVER_LIST;

typedef
VOID
(*PINTERIM_NEW_CALLBACK)(
    IN struct _INTERIM_SERVER_LIST *InterimList,
    IN PINTERIM_ELEMENT Element
    );

typedef
VOID
(*PINTERIM_EXISTING_CALLBACK)(
    IN struct _INTERIM_SERVER_LIST *InterimList,
    IN PINTERIM_ELEMENT Element
    );


typedef
VOID
(*PINTERIM_DELETE_CALLBACK)(
    IN struct _INTERIM_SERVER_LIST *InterimList,
    IN PINTERIM_ELEMENT Element
    );

typedef
BOOLEAN
(*PINTERIM_AGE_CALLBACK)(
    IN struct _INTERIM_SERVER_LIST *InterimList,
    IN PINTERIM_ELEMENT Element
    );


typedef struct _INTERIM_SERVER_LIST {
//    RTL_GENERIC_TABLE ServerTable;
    LIST_ENTRY ServerList;
    ULONG TotalBytesNeeded;
    ULONG TotalEntries;
    ULONG EntriesRead;
    PINTERIM_NEW_CALLBACK NewElementCallback;
    PINTERIM_EXISTING_CALLBACK ExistingElementCallback;
    PINTERIM_DELETE_CALLBACK DeleteElementCallback;
    PINTERIM_AGE_CALLBACK AgeElementCallback;
} INTERIM_SERVER_LIST, *PINTERIM_SERVER_LIST;


NET_API_STATUS
DeviceControlGetInfo(
    IN  HANDLE FileHandle,
    IN  ULONG DeviceControlCode,
    IN  PVOID RequestPacket,
    IN  ULONG RequestPacketLength,
    OUT LPVOID *OutputBuffer,
    IN  ULONG PreferedMaximumLength,
    IN  ULONG BufferHintSize,
    OUT PULONG Information OPTIONAL
    );

NET_API_STATUS
BrDgReceiverIoControl(
    IN  HANDLE FileHandle,
    IN  ULONG DgReceiverControlCode,
    IN  PLMDR_REQUEST_PACKET Drp,
    IN  ULONG DrpSize,
    IN  PVOID SecondBuffer OPTIONAL,
    IN  ULONG SecondBufferLength,
    OUT PULONG Information OPTIONAL
    );

NET_API_STATUS
OpenBrowser(
    OUT PHANDLE BrowserHandle
    );

NET_API_STATUS
GetBrowserServerList(
    IN PUNICODE_STRING TransportName,
    IN LPCWSTR domain,
    OUT LPWSTR *BrowserList[],
    OUT PULONG BrowserListLength,
    IN BOOLEAN ForceRescan
    );

NET_API_STATUS
InitializeInterimServerList(
    IN PINTERIM_SERVER_LIST InterimServerList,
    IN PINTERIM_NEW_CALLBACK NewCallback,
    IN PINTERIM_EXISTING_CALLBACK ExistingCallback,
    IN PINTERIM_DELETE_CALLBACK DeleteElementCallback,
    IN PINTERIM_AGE_CALLBACK AgeElementCallback
    );

NET_API_STATUS
CopyInterimServerList(
    IN PINTERIM_SERVER_LIST NewInterimServerList,
    IN PINTERIM_SERVER_LIST OldInterimServerList
    );



NET_API_STATUS
UninitializeInterimServerList(
    IN PINTERIM_SERVER_LIST InterimServerList
    );


NET_API_STATUS
InsertElementInterimServerList (
    IN PINTERIM_SERVER_LIST InterimServerList,
    IN PINTERIM_ELEMENT InterimElement,
    IN ULONG Level,
    IN PBOOLEAN NewElement OPTIONAL,
    IN PINTERIM_ELEMENT *ActualElement OPTIONAL
    );

ULONG
NumberInterimServerListElements(
    IN PINTERIM_SERVER_LIST InterimServerList
    );

NET_API_STATUS
AgeInterimServerList(
    IN PINTERIM_SERVER_LIST InterimServerList
    );


NET_API_STATUS
MergeServerList(
    IN PINTERIM_SERVER_LIST InterimServerList,
    IN ULONG level,
    IN PVOID NewServerList,
    IN ULONG NewEntriesRead,
    IN ULONG NewTotalEntries
    );

PINTERIM_ELEMENT
LookupInterimServerList(
    IN PINTERIM_SERVER_LIST InterimServerList,
    IN LPWSTR ServerNameToLookUp
    );



NET_API_STATUS
PackServerList(
    IN PINTERIM_SERVER_LIST InterimServerList,
    IN ULONG Level,
    IN ULONG ServerType,
    IN ULONG PreferedDataLength,
    OUT PVOID *bufptr,
    OUT PULONG entriesread,
    OUT PULONG totalentries,
    IN LPCWSTR FirstNameToReturn
    );

VOID
PrepareServerListForMerge(
    IN PVOID ServerInfoList,
    IN ULONG Level,
    IN ULONG EntriesInList
    );

NET_API_STATUS
CheckForService(
    IN LPWSTR ServiceName,
    OUT LPSERVICE_STATUS ServiceStatus OPTIONAL
    );


NET_API_STATUS
BrGetLanaNumFromNetworkName(
    IN LPWSTR TransportName,
    OUT CCHAR *LanaNum
    );

NET_API_STATUS
GetNetBiosMasterName(
    IN LPWSTR NetworkName,
    IN LPWSTR PrimaryDomain,
    OUT LPWSTR MasterName,
    IN  PSVCS_NET_BIOS_RESET SvcsNetBiosReset OPTIONAL
    );

NET_API_STATUS
SendDatagram(
    IN HANDLE DgReceiverHandle,
    IN PUNICODE_STRING Network,
    IN PUNICODE_STRING EmulatedDomainName,
    IN PWSTR ResponseName,
    IN DGRECEIVER_NAME_TYPE NameType,
    IN PVOID Buffer,
    IN ULONG BufferLength
    );

NET_API_STATUS
SendDatagramAsync(
    IN HANDLE DgReceiverHandle,
    IN PUNICODE_STRING Network,
    IN PUNICODE_STRING EmulatedDomainName,
    IN PWSTR ResponseName,
    IN DGRECEIVER_NAME_TYPE NameType,
    IN PVOID Buffer,
    IN ULONG BufferLength
    );

#ifdef ENABLE_PSEUDO_BROWSER
BOOL
IsEnumServerEnabled(
    VOID
    );

DWORD
GetBrowserPseudoServerLevel(
    VOID
    );
#endif

#endif  // _BRCOMMON_
=== C:/Users/treeman/Desktop/windows nt source code\Source\Win2K3\NT\public\internal\ds\inc\cryptui.h ===
//+---------------------------------------------------------------------------
//
//  Microsoft Windows
//  Copyright (C) Microsoft Corporation, 1992-1999.
//
//  File:       cryptui.h
//
//  Contents:   Common Cryptographic Dialog API Prototypes and Definitions
//
//----------------------------------------------------------------------------

#ifndef __CRYPTUI_H__
#define __CRYPTUI_H__

#if defined (_MSC_VER) && (_MSC_VER >= 1020)
#pragma once
#endif

#include <prsht.h>
#include <wintrust.h>
#include <certca.h>
#include <cryptuiapi.h>

#ifdef __cplusplus
extern "C" {
#endif

#include <pshpack8.h>


/////////////////////////////////////////////////////////////////////////////////////////////////////
//
//  the functions which return property sheet pages take this callback as one of the parameters in
//  the input structure.  it is then called when each page is about to be created and when each page
//  is about to be destroyed.  the messages are PSPCB_CREATE when a page is about to be created and
//  PSPCB_RELEASE when a page is about to be destroyed.  the pvCallbackData parameter in the callback
//  is the pvoid that was passed in with the callback in the input structure.
typedef BOOL (WINAPI * PFNCPROPPAGECALLBACK)(
        HWND        hWndPropPage,
        UINT        uMsg,
        void        *pvCallbackData);


/////////////////////////////////////////////////////////////////////////////////////////////////////
//
// dwSize                          size of this struct
// hwndParent                      parent of this dialog                                    (OPTIONAL)
// dwFlags                         flags, may a combination of any of the flags below       (OPTIONAL)
// szTitle                         title for the window                                     (OPTIONAL)
// pCertContext                    the cert context that is to be displayed
// rgszPurposes                    array of purposes that this cert is to be validated for  (OPTIONAL)
// cPurposes                       number of purposes                                       (OPTIONAL)
// pCryptProviderData/hWVTStateData if WinVerifyTrust has already been called for the cert  (OPTIONAL)
//                                 then pass in a pointer to the state struct that was
//                                 acquired through a call to WTHelperProvDataFromStateData(),
//                                 or pass in the hWVTStateData of the WINTRUST_DATA struct
//                                 if WTHelperProvDataFromStateData() was not called.
//                                 if pCryptProviderData/hWVTStateData is used then
//                                 fpCryptProviderDataTrustedUsage, idxSigner, idxCert, and
//                                 fCounterSignature must be set
// fpCryptProviderDataTrustedUsage if WinVerifyTrust was called this is the result of whether (OPTIONAL)
//                                 the cert was trusted
// idxSigner                       the index of the signer to view                          (OPTIONAL)
// idxCert                         the index of the cert that is being viewed within the    (OPTIONAL)
//                                 signer chain.  the cert context of this cert MUST match
//                                 pCertContext
// fCounterSigner                  set to TRUE if a counter signature is being viewed.  if  (OPTIONAL)
//                                 this is TRUE then idxCounterSigner must be valid
// idxCounterSigner                the index of the counter signer to view                  (OPTIONAL)
// cStores                         Count of other stores to search when building and        (OPTIONAL)
//                                 validating chain
// rghStores                       Array of other stores to search when buliding and        (OPTIONAL)
//                                 validating chain
// cPropSheetPages                 number of extra pages to add to the dialog.              (OPTIONAL)
// rgPropSheetPages                extra pages to add to the dialog.                        (OPTIONAL)
//                                 each page in this array will NOT recieve the lParam in
//                                 the PROPSHEET structure as the lParam in the
//                                 WM_INITDIALOG, instead it will receive a pointer to a
//                                 CRYPTUI_INITDIALOG_STRUCT (defined below) which contains
//                                 the lParam in the PROPSSHEET structure AND the
//                                 PCCERT_CONTEXT for which the page is being displayed.
// nStartPage                      this is the index of the initial page that will be
//                                 displayed.  if the upper most bit (0x8000) is set then
//                                 the index is assumed to index rgPropSheetPages
//                                 (after the upper most bit has been stripped off.  eg.
//                                 0x8000 will indicate the first page in rgPropSheetPages),
//                                 if the upper most bit is 0 then nStartPage will be the
//                                 starting index of the default certificate dialog pages.
//
/////////////////////////////////////////////////////////////////////////////////////////////////////

// dwFlags
#define CRYPTUI_HIDE_HIERARCHYPAGE          0x00000001
#define CRYPTUI_HIDE_DETAILPAGE             0x00000002
#define CRYPTUI_DISABLE_EDITPROPERTIES      0x00000004
#define CRYPTUI_ENABLE_EDITPROPERTIES       0x00000008
#define CRYPTUI_DISABLE_ADDTOSTORE          0x00000010
#define CRYPTUI_ENABLE_ADDTOSTORE           0x00000020
#define CRYPTUI_ACCEPT_DECLINE_STYLE        0x00000040
#define CRYPTUI_IGNORE_UNTRUSTED_ROOT       0x00000080
#define CRYPTUI_DONT_OPEN_STORES            0x00000100
#define CRYPTUI_ONLY_OPEN_ROOT_STORE        0x00000200
#define CRYPTUI_WARN_UNTRUSTED_ROOT         0x00000400  // For use with viewing of certificates on remote
                                                        // machines only.  If this flag is used rghStores[0]
                                                        // must be the handle of the root store on the remote machine.
#define CRYPTUI_ENABLE_REVOCATION_CHECKING  0x00000800  // This flag is only valid if pCryptProviderData/hWVTStateData
                                                        // is not passed in.
#define CRYPTUI_WARN_REMOTE_TRUST           0x00001000
#define CRYPTUI_DISABLE_EXPORT              0x00002000  // If this flag is set, then the "Copy to file" button will be
                                                        // disabled on the Detail page.
                                                                
// Revocation flags is only valid if pCryptProviderData/hWVTStateData is not passed in.
#define CRYPTUI_ENABLE_REVOCATION_CHECK_END_CERT           0x00004000
#define CRYPTUI_ENABLE_REVOCATION_CHECK_CHAIN              0x00008000
#define CRYPTUI_ENABLE_REVOCATION_CHECK_CHAIN_EXCLUDE_ROOT CRYPTUI_ENABLE_REVOCATION_CHECKING // Changed the default behavior
                                                                                              // to not check root.

// Following is a flag for internal use only!!
#define CRYPTUI_TREEVIEW_PAGE_FLAG          0x80000000

typedef struct tagCRYPTUI_VIEWCERTIFICATE_STRUCTW {
    DWORD                       dwSize;
    HWND                        hwndParent;                     // OPTIONAL
    DWORD                       dwFlags;                        // OPTIONAL
    LPCWSTR                     szTitle;                        // OPTIONAL
    PCCERT_CONTEXT              pCertContext;
    LPCSTR *                    rgszPurposes;                   // OPTIONAL
    DWORD                       cPurposes;                      // OPTIONAL
    union
    {
        CRYPT_PROVIDER_DATA const * pCryptProviderData;         // OPTIONAL
        HANDLE                      hWVTStateData;              // OPTIONAL
    };
    BOOL                        fpCryptProviderDataTrustedUsage;// OPTIONAL
    DWORD                       idxSigner;                      // OPTIONAL
    DWORD                       idxCert;                        // OPTIONAL
    BOOL                        fCounterSigner;                 // OPTIONAL
    DWORD                       idxCounterSigner;               // OPTIONAL
    DWORD                       cStores;                        // OPTIONAL
    HCERTSTORE *                rghStores;                      // OPTIONAL
    DWORD                       cPropSheetPages;                // OPTIONAL
    LPCPROPSHEETPAGEW           rgPropSheetPages;               // OPTIONAL
    DWORD                       nStartPage;
} CRYPTUI_VIEWCERTIFICATE_STRUCTW, *PCRYPTUI_VIEWCERTIFICATE_STRUCTW;
typedef const CRYPTUI_VIEWCERTIFICATE_STRUCTW *PCCRYPTUI_VIEWCERTIFICATE_STRUCTW;


typedef struct tagCRYPTUI_VIEWCERTIFICATE_STRUCTA {
    DWORD                       dwSize;
    HWND                        hwndParent;                     // OPTIONAL
    DWORD                       dwFlags;                        // OPTIONAL
    LPCSTR                      szTitle;                        // OPTIONAL
    PCCERT_CONTEXT              pCertContext;
    LPCSTR *                    rgszPurposes;                   // OPTIONAL
    DWORD                       cPurposes;                      // OPTIONAL
    union
    {
        CRYPT_PROVIDER_DATA const * pCryptProviderData;         // OPTIONAL
        HANDLE                      hWVTStateData;              // OPTIONAL
    };
    BOOL                        fpCryptProviderDataTrustedUsage;// OPTIONAL
    DWORD                       idxSigner;                      // OPTIONAL
    DWORD                       idxCert;                        // OPTIONAL
    BOOL                        fCounterSigner;                 // OPTIONAL
    DWORD                       idxCounterSigner;               // OPTIONAL
    DWORD                       cStores;                        // OPTIONAL
    HCERTSTORE *                rghStores;                      // OPTIONAL
    DWORD                       cPropSheetPages;                // OPTIONAL
    LPCPROPSHEETPAGEA           rgPropSheetPages;               // OPTIONAL
    DWORD                       nStartPage;
} CRYPTUI_VIEWCERTIFICATE_STRUCTA, *PCRYPTUI_VIEWCERTIFICATE_STRUCTA;
typedef const CRYPTUI_VIEWCERTIFICATE_STRUCTA *PCCRYPTUI_VIEWCERTIFICATE_STRUCTA;

//
// pfPropertiesChanged             this will be set by the dialog proc to inform the caller
//                                 if any properties have been changed on certs in the chain
//                                 while the dialog was open
//
BOOL
WINAPI
CryptUIDlgViewCertificateW(
        IN  PCCRYPTUI_VIEWCERTIFICATE_STRUCTW   pCertViewInfo,
        OUT BOOL                                *pfPropertiesChanged  // OPTIONAL
        );

BOOL
WINAPI
CryptUIDlgViewCertificateA(
        IN  PCCRYPTUI_VIEWCERTIFICATE_STRUCTA   pCertViewInfo,
        OUT BOOL                                *pfPropertiesChanged  // OPTIONAL
        );

#ifdef UNICODE
#define CryptUIDlgViewCertificate           CryptUIDlgViewCertificateW
#define PCRYPTUI_VIEWCERTIFICATE_STRUCT     PCRYPTUI_VIEWCERTIFICATE_STRUCTW
#define CRYPTUI_VIEWCERTIFICATE_STRUCT      CRYPTUI_VIEWCERTIFICATE_STRUCTW
#define PCCRYPTUI_VIEWCERTIFICATE_STRUCT    PCCRYPTUI_VIEWCERTIFICATE_STRUCTW
#else
#define CryptUIDlgViewCertificate           CryptUIDlgViewCertificateA
#define PCRYPTUI_VIEWCERTIFICATE_STRUCT     PCRYPTUI_VIEWCERTIFICATE_STRUCTA
#define CRYPTUI_VIEWCERTIFICATE_STRUCT      CRYPTUI_VIEWCERTIFICATE_STRUCTA
#define PCCRYPTUI_VIEWCERTIFICATE_STRUCT    PCCRYPTUI_VIEWCERTIFICATE_STRUCTA
#endif

//
// this struct is passed as the lParam in the WM_INITDIALOG call to each
// property sheet that is in the rgPropSheetPages array of the
// CRYPTUI_VIEWCERTIFICATE_STRUCT structure
//
typedef struct tagCRYPTUI_INITDIALOG_STRUCT {
    LPARAM          lParam;
    PCCERT_CONTEXT  pCertContext;
} CRYPTUI_INITDIALOG_STRUCT, *PCRYPTUI_INITDIALOG_STRUCT;


//
// this structure is used in CRYPTUI_VIEWCERTIFICATEPROPERTIES_STRUCT,
// and allows users of MMC to recieve notifications that properties
// on certificates have changed
//
typedef HRESULT (__stdcall * PFNCMMCCALLBACK)(LONG_PTR lNotifyHandle, LPARAM param);

typedef struct tagCRYPTUI_MMCCALLBACK_STRUCT {
    PFNCMMCCALLBACK pfnCallback;    // the address of MMCPropertyChangeNotify()
    LONG_PTR         lNotifyHandle;  // the lNotifyHandle passed to MMCPropertyChangeNotify()
    LPARAM          param;          // the param passed to MMCPropertyChangeNotify()
} CRYPTUI_MMCCALLBACK_STRUCT, *PCRYPTUI_MMCCALLBACK_STRUCT;

/////////////////////////////////////////////////////////////////////////////////////////////////////
//
// dwSize                          size of this struct
// hwndParent                      parent of this dialog                                    (OPTIONAL)
// dwFlags                         flags, must be set to 0
// union                           the szTitle field of the union is only valid if
//                                 CryptUIDlgViewCertificateProperties is being called.
//                                 the pMMCCallback field of the union is only valid if
//                                 CryptUIGetCertificatePropertiesPages is being called.
//                                 Note that if pMMCCallback is non-NULL and
//                                 CryptUIGetCertificatePropertiesPages was called, the
//                                 struct pointed to by pMMCCallback will not be referenced
//                                 by cryptui.dll after the callback has been made to MMC.
//                                 this will allow the original caller of
//                                 CryptUIGetCertificatePropertiesPages to free the struct
//                                 pointed to by pMMCCallback in the actual callback.
//      szTitle                    title for the window                                     (OPTIONAL)
//      pMMCCallback               this structure is used to callback MMC if properties     (OPTIONAL)
//                                 have changed
// pCertContext                    the cert context that is to be displayed
// pPropPageCallback               this callback will be called when each page that is      (OPTIONAL)
//                                 returned in the CryptUIGetCertificatePropertiesPages call
//                                 is about to be created or destroyed.  if this is NULL no
//                                 callback is made.  Note that this is not used if
//                                 CryptUIDlgViewCertificateProperties is called
// pvCallbackData                  this is uniterpreted data that is passed back when the   (OPTIONAL)
//                                 when pPropPageCallback is made
// cStores                         Count of other stores to search when building and        (OPTIONAL)
//                                 validating chain
// rghStores                       Array of other stores to search when buliding and        (OPTIONAL)
//                                 validating chain
// cPropSheetPages                 number of extra pages to add to the dialog               (OPTIONAL)
// rgPropSheetPages                extra pages to add to the dialog                         (OPTIONAL)
//
/////////////////////////////////////////////////////////////////////////////////////////////////////

typedef struct tagCRYPTUI_VIEWCERTIFICATEPROPERTIES_STRUCTW {
    DWORD                   dwSize;
    HWND                    hwndParent;         // OPTIONAL
    DWORD                   dwFlags;            // OPTIONAL
    union
    {
        LPCWSTR                     szTitle;    // OPTIONAL
        PCRYPTUI_MMCCALLBACK_STRUCT pMMCCallback;// OPTIONAL
    };
    PCCERT_CONTEXT          pCertContext;
    PFNCPROPPAGECALLBACK    pPropPageCallback;  // OPTIONAL
    void *                  pvCallbackData;     // OPTIONAL
    DWORD                   cStores;            // OPTIONAL
    HCERTSTORE *            rghStores;          // OPTIONAL
    DWORD                   cPropSheetPages;    // OPTIONAL
    LPCPROPSHEETPAGEW       rgPropSheetPages;   // OPTIONAL
} CRYPTUI_VIEWCERTIFICATEPROPERTIES_STRUCTW, *PCRYPTUI_VIEWCERTIFICATEPROPERTIES_STRUCTW;
typedef const CRYPTUI_VIEWCERTIFICATEPROPERTIES_STRUCTW *PCCRYPTUI_VIEWCERTIFICATEPROPERTIES_STRUCTW;

typedef struct tagCRYPTUI_VIEWCERTIFICATEPROPERTIES_STRUCTA {
    DWORD                   dwSize;
    HWND                    hwndParent;         // OPTIONAL
    DWORD                   dwFlags;            // OPTIONAL
    union
    {
        LPCSTR                      szTitle;    // OPTIONAL
        PCRYPTUI_MMCCALLBACK_STRUCT pMMCCallback;// OPTIONAL
    };
    PCCERT_CONTEXT          pCertContext;
    PFNCPROPPAGECALLBACK    pPropPageCallback;  // OPTIONAL
    void *                  pvCallbackData;     // OPTIONAL
    DWORD                   cStores;            // OPTIONAL
    HCERTSTORE *            rghStores;          // OPTIONAL
    DWORD                   cPropSheetPages;    // OPTIONAL
    LPCPROPSHEETPAGEA       rgPropSheetPages;   // OPTIONAL
} CRYPTUI_VIEWCERTIFICATEPROPERTIES_STRUCTA, *PCRYPTUI_VIEWCERTIFICATEPROPERTIES_STRUCTA;
typedef const CRYPTUI_VIEWCERTIFICATEPROPERTIES_STRUCTA *PCCRYPTUI_VIEWCERTIFICATEPROPERTIES_STRUCTA;

// pfPropertiesChanged             this will be set by the dialog proc to inform the caller
//                                 if any properties have been changed on certs in the chain
//                                 while the dialog was open
BOOL
WINAPI
CryptUIDlgViewCertificatePropertiesW(
            IN  PCCRYPTUI_VIEWCERTIFICATEPROPERTIES_STRUCTW pcsp,
            OUT BOOL                                        *pfPropertiesChanged  // OPTIONAL
            );

BOOL
WINAPI
CryptUIDlgViewCertificatePropertiesA(
            IN  PCCRYPTUI_VIEWCERTIFICATEPROPERTIES_STRUCTA pcsp,
            OUT BOOL                                        *pfPropertiesChanged  // OPTIONAL
            );


// NOTE!!   when calling this function, the following parameters of the
//          CRYPTUI_VIEWCERTIFICATEPROPERTIES_STRUCT struct are unused
//              cPropSheetPages
//              rgPropSheetPages
BOOL
WINAPI
CryptUIGetCertificatePropertiesPagesW(
            IN  PCCRYPTUI_VIEWCERTIFICATEPROPERTIES_STRUCTW pcsp,
            OUT BOOL                                        *pfPropertiesChanged,  // OPTIONAL
            OUT PROPSHEETPAGEW                              **prghPropPages,
            OUT DWORD                                       *pcPropPages
            );

BOOL
WINAPI
CryptUIGetCertificatePropertiesPagesA(
            IN  PCCRYPTUI_VIEWCERTIFICATEPROPERTIES_STRUCTA pcsp,
            OUT BOOL                                         *pfPropertiesChanged,  // OPTIONAL
            OUT PROPSHEETPAGEA                               **prghPropPages,
            OUT DWORD                                        *pcPropPages
            );

BOOL
WINAPI
CryptUIFreeCertificatePropertiesPagesW(
            IN PROPSHEETPAGEW   *rghPropPages,
            IN DWORD            cPropPages
            );

BOOL
WINAPI
CryptUIFreeCertificatePropertiesPagesA(
            IN PROPSHEETPAGEA   *rghPropPages,
            IN DWORD            cPropPages
            );

#ifdef UNICODE
#define CryptUIDlgViewCertificateProperties         CryptUIDlgViewCertificatePropertiesW
#define PCRYPTUI_VIEWCERTIFICATEPROPERTIES_STRUCT   PCRYPTUI_VIEWCERTIFICATEPROPERTIES_STRUCTW
#define CRYPTUI_VIEWCERTIFICATEPROPERTIES_STRUCT    CRYPTUI_VIEWCERTIFICATEPROPERTIES_STRUCTW
#define PCCRYPTUI_VIEWCERTIFICATEPROPERTIES_STRUCT  PCCRYPTUI_VIEWCERTIFICATEPROPERTIES_STRUCTW
#define CryptUIGetCertificatePropertiesPages        CryptUIGetCertificatePropertiesPagesW
#define CryptUIFreeCertificatePropertiesPages       CryptUIFreeCertificatePropertiesPagesW
#else
#define CryptUIDlgViewCertificateProperties         CryptUIDlgViewCertificatePropertiesA
#define PCRYPTUI_VIEWCERTIFICATEPROPERTIES_STRUCT   PCRYPTUI_VIEWCERTIFICATEPROPERTIES_STRUCTA
#define CRYPTUI_VIEWCERTIFICATEPROPERTIES_STRUCT    CRYPTUI_VIEWCERTIFICATEPROPERTIES_STRUCTA
#define PCCRYPTUI_VIEWCERTIFICATEPROPERTIES_STRUCT  PCCRYPTUI_VIEWCERTIFICATEPROPERTIES_STRUCTA
#define CryptUIGetCertificatePropertiesPages        CryptUIGetCertificatePropertiesPagesA
#define CryptUIFreeCertificatePropertiesPages       CryptUIFreeCertificatePropertiesPagesA
#endif

//
// The certificate properties property sheet dialog is extensible via a callback mechanism.
// A client needs to register their callback using CryptRegisterDefaultOIDFunction, and,
// if they need to unregister it they should use CryptUnregisterDefaultOIDFunction.
// The form for calling these functions is given below
//
// CryptRegisterDefaultOIDFunction(
//            0,
//            CRYPTUILDLG_CERTPROP_PAGES_CALLBACK,
//            CRYPT_REGISTER_FIRST_INDEX,
//            L"c:\\fully qualified path\\dll_being_registered.dll");  <<----- your dll name
//
// CryptUnregisterDefaultOIDFunction(
//            0,
//            CRYPTUILDLG_CERTPROP_PAGES_CALLBACK,
//            L"c:\\fully qualified path\\dll_being_registered.dll");  <<----- your dll name
//
// NOTE: Per the documentation on CryptRegisterDefaultOIDFunction in wincrypt.h,
//       the dll name may contain environment-variable strings
//       which are ExpandEnvironmentStrings()'ed before loading the Dll.
//
#define MAX_CLIENT_PAGES 20
#define CRYPTUILDLG_CERTPROP_PAGES_CALLBACK "CryptUIDlgClientCertPropPagesCallback"

//
//
// The typedef for the callback function which resides in the registered dll is given
// below.  Note that the callback must have the name #defined by
// CRYPTUILDLG_CERTPROP_PAGES_CALLBACK
//
// pCertContext - The certificate for which the properties are being displayed.
// rgPropPages  - An array of PropSheetPageW structures that are to be filled in by
//                the client with the property pages to be shown.
// pcPropPages  - A pointer to a DWORD that on input contains the maximum number of
//                PropSheetPages the client may supply, and on output must have been
//                filled in by the client with the number of pages they supplied in
//                rgPropPages.
//
// Return Value:  The client should return TRUE if they wish to show extra property pages,
//                in this case pcPropPages must >= 1 and rgPropPages must have the
//                corresponding number of pages.  or, return FALSE if no pages are suplied.
typedef BOOL (WINAPI *PFN_CRYPTUIDLG_CERTPROP_PAGES_CALLBACK)
        (IN     PCCERT_CONTEXT pCertContext,
         OUT    PROPSHEETPAGEW *rgPropPages,
         IN OUT DWORD *pcPropPages);


/////////////////////////////////////////////////////////////////////////////////////////////////////


/////////////////////////////////////////////////////////////////////////////////////////////////////
//
// dwSize                          size of this struct
// hwndParent                      parent of this dialog                                    (OPTIONAL)
// dwFlags                         flags, may a combination of any of the flags below
// szTitle                         title for the window                                     (OPTIONAL)
// pCTLContext                     the ctl context that is to be displayed
// cCertSearchStores;              count of other stores to search for the certs contained  (OPTIONAL)
//                                 in the ctl
// rghCertSearchStores;            array of other stores to search for the certs contained  (OPTIONAL)
//                                 in the ctl
// cStores                         Count of other stores to search when building and        (OPTIONAL)
//                                 validating chain of the cert which signed the ctl
//                                 and the certs contained in the ctl
// rghStores                       Array of other stores to search when buliding and        (OPTIONAL)
//                                 validating chain of the cert which signed the ctl
//                                 and the certs contained in the ctl
// cPropSheetPages                 number of extra pages to add to the dialog               (OPTIONAL)
// rgPropSheetPages                extra pages to add to the dialog                         (OPTIONAL)
//
/////////////////////////////////////////////////////////////////////////////////////////////////////

// dwFlags
#define CRYPTUI_HIDE_TRUSTLIST_PAGE        0x00000001

typedef struct tagCRYPTUI_VIEWCTL_STRUCTW {
    DWORD               dwSize;
    HWND                hwndParent;         // OPTIONAL
    DWORD               dwFlags;            // OPTIONAL
    LPCWSTR             szTitle;            // OPTIONAL
    PCCTL_CONTEXT       pCTLContext;
    DWORD               cCertSearchStores;  // OPTIONAL
    HCERTSTORE *        rghCertSearchStores;// OPTIONAL
    DWORD               cStores;            // OPTIONAL
    HCERTSTORE *        rghStores;          // OPTIONAL
    DWORD               cPropSheetPages;    // OPTIONAL
    LPCPROPSHEETPAGEW   rgPropSheetPages;   // OPTIONAL
} CRYPTUI_VIEWCTL_STRUCTW, *PCRYPTUI_VIEWCTL_STRUCTW;
typedef const CRYPTUI_VIEWCTL_STRUCTW *PCCRYPTUI_VIEWCTL_STRUCTW;

typedef struct tagCRYPTUI_VIEWCTL_STRUCTA {
    DWORD               dwSize;
    HWND                hwndParent;         // OPTIONAL
    DWORD               dwFlags;            // OPTIONAL
    LPCSTR              szTitle;            // OPTIONAL
    PCCTL_CONTEXT       pCTLContext;
    DWORD               cCertSearchStores;  // OPTIONAL
    HCERTSTORE *        rghCertSearchStores;// OPTIONAL
    DWORD               cStores;            // OPTIONAL
    HCERTSTORE *        rghStores;          // OPTIONAL
    DWORD               cPropSheetPages;    // OPTIONAL
    LPCPROPSHEETPAGEA   rgPropSheetPages;   // OPTIONAL
} CRYPTUI_VIEWCTL_STRUCTA, *PCRYPTUI_VIEWCTL_STRUCTA;
typedef const CRYPTUI_VIEWCTL_STRUCTA *PCCRYPTUI_VIEWCTL_STRUCTA;

BOOL
WINAPI
CryptUIDlgViewCTLW(
            IN PCCRYPTUI_VIEWCTL_STRUCTW pcvctl
            );

BOOL
WINAPI
CryptUIDlgViewCTLA(
            IN PCCRYPTUI_VIEWCTL_STRUCTA pcvctl
            );

#ifdef UNICODE
#define CryptUIDlgViewCTL           CryptUIDlgViewCTLW
#define PCRYPTUI_VIEWCTL_STRUCT     PCRYPTUI_VIEWCTL_STRUCTW
#define CRYPTUI_VIEWCTL_STRUCT      CRYPTUI_VIEWCTL_STRUCTW
#define PCCRYPTUI_VIEWCTL_STRUCT    PCCRYPTUI_VIEWCTL_STRUCTW
#else
#define CryptUIDlgViewCTL           CryptUIDlgViewCTLA
#define PCRYPTUI_VIEWCTL_STRUCT     PCRYPTUI_VIEWCTL_STRUCTA
#define CRYPTUI_VIEWCTL_STRUCT      CRYPTUI_VIEWCTL_STRUCTA
#define PCCRYPTUI_VIEWCTL_STRUCT    PCCRYPTUI_VIEWCTL_STRUCTA
#endif

/////////////////////////////////////////////////////////////////////////////////////////////////////


/////////////////////////////////////////////////////////////////////////////////////////////////////
//
// dwSize                          size of this struct
// hwndParent                      parent of this dialog                                    (OPTIONAL)
// dwFlags                         flags, may a combination of any of the flags below
// szTitle                         title for the window                                     (OPTIONAL)
// pCTLContext                     the ctl context that is to be displayed
// cStores                         count of other stores to search for the cert which       (OPTIONAL)
//                                 signed the crl and to build and validate the
//                                 cert's chain
// rghStores                       array of other stores to search for the cert which       (OPTIONAL)
//                                 signed the crl and to build and validate the
//                                 cert's chain
// cPropSheetPages                 number of extra pages to add to the dialog               (OPTIONAL)
// rgPropSheetPages                extra pages to add to the dialog                         (OPTIONAL)
//
/////////////////////////////////////////////////////////////////////////////////////////////////////

// dwFlags
#define CRYPTUI_HIDE_REVOCATIONLIST_PAGE   0x00000001

typedef struct tagCRYPTUI_VIEWCRL_STRUCTW {
    DWORD               dwSize;
    HWND                hwndParent;         // OPTIONAL
    DWORD               dwFlags;            // OPTIONAL
    LPCWSTR             szTitle;            // OPTIONAL
    PCCRL_CONTEXT       pCRLContext;
    DWORD               cStores;            // OPTIONAL
    HCERTSTORE *        rghStores;          // OPTIONAL
    DWORD               cPropSheetPages;    // OPTIONAL
    LPCPROPSHEETPAGEW   rgPropSheetPages;   // OPTIONAL
} CRYPTUI_VIEWCRL_STRUCTW, *PCRYPTUI_VIEWCRL_STRUCTW;
typedef const CRYPTUI_VIEWCRL_STRUCTW *PCCRYPTUI_VIEWCRL_STRUCTW;

typedef struct tagCRYPTUI_VIEWCRL_STRUCTA {
    DWORD               dwSize;
    HWND                hwndParent;         // OPTIONAL
    DWORD               dwFlags;            // OPTIONAL
    LPCSTR              szTitle;            // OPTIONAL
    PCCRL_CONTEXT       pCRLContext;
    DWORD               cStores;            // OPTIONAL
    HCERTSTORE *        rghStores;          // OPTIONAL
    DWORD               cPropSheetPages;    // OPTIONAL
    LPCPROPSHEETPAGEA   rgPropSheetPages;   // OPTIONAL
} CRYPTUI_VIEWCRL_STRUCTA, *PCRYPTUI_VIEWCRL_STRUCTA;
typedef const CRYPTUI_VIEWCRL_STRUCTA *PCCRYPTUI_VIEWCRL_STRUCTA;

BOOL
WINAPI
CryptUIDlgViewCRLW(
            IN PCCRYPTUI_VIEWCRL_STRUCTW pcvcrl
            );

BOOL
WINAPI
CryptUIDlgViewCRLA(
            IN PCCRYPTUI_VIEWCRL_STRUCTA pcvcrl
            );

#ifdef UNICODE
#define CryptUIDlgViewCRL           CryptUIDlgViewCRLW
#define PCRYPTUI_VIEWCRL_STRUCT     PCRYPTUI_VIEWCRL_STRUCTW
#define CRYPTUI_VIEWCRL_STRUCT      CRYPTUI_VIEWCRL_STRUCTW
#define PCCRYPTUI_VIEWCRL_STRUCT    PCCRYPTUI_VIEWCRL_STRUCTW
#else
#define CryptUIDlgViewCRL           CryptUIDlgViewCRLA
#define PCRYPTUI_VIEWCRL_STRUCT     PCRYPTUI_VIEWCRL_STRUCTA
#define CRYPTUI_VIEWCRL_STRUCT      CRYPTUI_VIEWCRL_STRUCTA
#define PCCRYPTUI_VIEWCRL_STRUCT    PCCRYPTUI_VIEWCRL_STRUCTA
#endif
/////////////////////////////////////////////////////////////////////////////////////////////////////


/////////////////////////////////////////////////////////////////////////////////////////////////////
//
// dwSize                          size of this struct
// hwndParent                      parent of this dialog                                    (OPTIONAL)
// dwFlags                         flags, may a combination of any of the flags below
// szTitle                         title for the window                                     (OPTIONAL)
// pSignerInfo                     the signer info struct that is to be displayed
// hMsg                            the HCRYPTMSG that the signer info was extracted from
// pszOID                          an OID that signifies what the certificate that did the  (OPTIONAL)
//                                 signing whould be validated for.  for instance if this is
//                                 being called to view the signature of a CTL the
//                                 szOID_KP_CTL_USAGE_SIGNING OID should be passed in.
//                                 if this is NULL then the certificate is only validated
//                                 cryptographicaly and not for usages.
// dwReserved                      reserved for future use and must be set to NULL
// cStores                         count of other stores to search for the cert which       (OPTIONAL)
//                                 did the signing and to build and validate the
//                                 cert's chain
// rghStores                       array of other stores to search for the cert which       (OPTIONAL)
//                                 did the signing and to build and validate the
//                                 cert's chain
// cPropSheetPages                 number of extra pages to add to the dialog               (OPTIONAL)
// rgPropSheetPages                extra pages to add to the dialog                         (OPTIONAL)
//
/////////////////////////////////////////////////////////////////////////////////////////////////////

// dwFlags
#define CRYPTUI_HIDE_TRUSTLIST_PAGE        0x00000001

typedef struct tagCRYPTUI_VIEWSIGNERINFO_STRUCTW {
    DWORD                   dwSize;
    HWND                    hwndParent;         // OPTIONAL
    DWORD                   dwFlags;            // OPTIONAL
    LPCWSTR                 szTitle;            // OPTIONAL
    CMSG_SIGNER_INFO const *pSignerInfo;
    HCRYPTMSG               hMsg;
    LPCSTR                  pszOID;             // OPTIONAL
    DWORD_PTR               dwReserved;
    DWORD                   cStores;            // OPTIONAL
    HCERTSTORE             *rghStores;          // OPTIONAL
    DWORD                   cPropSheetPages;    // OPTIONAL
    LPCPROPSHEETPAGEW       rgPropSheetPages;   // OPTIONAL
} CRYPTUI_VIEWSIGNERINFO_STRUCTW, *PCRYPTUI_VIEWSIGNERINFO_STRUCTW;
typedef const CRYPTUI_VIEWSIGNERINFO_STRUCTW *PCCRYPTUI_VIEWSIGNERINFO_STRUCTW;

typedef struct tagCRYPTUI_VIEWSIGNERINFO_STRUCTA {
    DWORD                   dwSize;
    HWND                    hwndParent;         // OPTIONAL
    DWORD                   dwFlags;            // OPTIONAL
    LPCSTR                  szTitle;            // OPTIONAL
    CMSG_SIGNER_INFO const *pSignerInfo;
    HCRYPTMSG               hMsg;
    LPCSTR                  pszOID;             // OPTIONAL
    DWORD_PTR               dwReserved;
    DWORD                   cStores;            // OPTIONAL
    HCERTSTORE             *rghStores;          // OPTIONAL
    DWORD                   cPropSheetPages;    // OPTIONAL
    LPCPROPSHEETPAGEA       rgPropSheetPages;   // OPTIONAL
} CRYPTUI_VIEWSIGNERINFO_STRUCTA, *PCRYPTUI_VIEWSIGNERINFO_STRUCTA;
typedef const CRYPTUI_VIEWSIGNERINFO_STRUCTA *PCCRYPTUI_VIEWSIGNERINFO_STRUCTA;

BOOL
WINAPI
CryptUIDlgViewSignerInfoW(
            IN PCCRYPTUI_VIEWSIGNERINFO_STRUCTW pcvsi
            );

BOOL
WINAPI
CryptUIDlgViewSignerInfoA(
            IN PCCRYPTUI_VIEWSIGNERINFO_STRUCTA pcvsi
            );

#ifdef UNICODE
#define CryptUIDlgViewSignerInfo        CryptUIDlgViewSignerInfoW
#define PCRYPTUI_VIEWSIGNERINFO_STRUCT  PCRYPTUI_VIEWSIGNERINFO_STRUCTW
#define CRYPTUI_VIEWSIGNERINFO_STRUCT   CRYPTUI_VIEWSIGNERINFO_STRUCTW
#define PCCRYPTUI_VIEWSIGNERINFO_STRUCT PCCRYPTUI_VIEWSIGNERINFO_STRUCTW
#else
#define CryptUIDlgViewSignerInfo        CryptUIDlgViewSignerInfoA
#define PCRYPTUI_VIEWSIGNERINFO_STRUCT  PCRYPTUI_VIEWSIGNERINFO_STRUCTA
#define CRYPTUI_VIEWSIGNERINFO_STRUCT   CRYPTUI_VIEWSIGNERINFO_STRUCTA
#define PCCRYPTUI_VIEWSIGNERINFO_STRUCT PCCRYPTUI_VIEWSIGNERINFO_STRUCTA
#endif
/////////////////////////////////////////////////////////////////////////////////////////////////////


/////////////////////////////////////////////////////////////////////////////////////////////////////
//
// dwSize                          size of this struct
// hwndParent                      parent of this dialog                                    (OPTIONAL)
// dwFlags                         flags, must be set to 0
// szTitle                         title for the window                                     (OPTIONAL)
// choice                          the form of the message that is to have its signers displayed
// u                               either an encoded message or a message handle
//          EncodedMessage         a data blob which contains a pointer to the encoded data
//                                 and the count of encoded bytes
//          hMsg                   a message handle
// szFileName                      the fully qualified file name, should be passed in if    (OPTIONAL)
//                                 signatures on a file are being viewed
// pPropPageCallback               this callback will be called when each page that is      (OPTIONAL)
//                                 returned in the CryptUIGetViewSignaturesPages call
//                                 is about to be created or destroyed.  if this is NULL no
//                                 callback is made.
// pvCallbackData                  this is uniterpreted data that is passed back when the   (OPTIONAL)
//                                 when pPropPageCallback is made
// cStores                         count of other stores to search for the cert which       (OPTIONAL)
//                                 did the signing and to build and validate the
//                                 cert's chain
// rghStores                       array of other stores to search for the cert which       (OPTIONAL)
//                                 did the signing and to build and validate the
//                                 cert's chain
// cPropSheetPages                 number of extra pages to add to the dialog               (OPTIONAL)
// rgPropSheetPages                extra pages to add to the dialog                         (OPTIONAL)
//
/////////////////////////////////////////////////////////////////////////////////////////////////////

// for the coice field of the CRYPTUI_VIEWSIGNATURES_STRUCT structure
#define EncodedMessage_Chosen   1
#define hMsg_Chosen             2

typedef struct tagCRYPTUI_VIEWSIGNATURES_STRUCTW {
    DWORD                   dwSize;
    HWND                    hwndParent;         // OPTIONAL
    DWORD                   dwFlags;            // OPTIONAL
    LPCWSTR                 szTitle;            // OPTIONAL
    unsigned short          choice;
    union {
        CRYPT_DATA_BLOB     EncodedMessage;
        HCRYPTMSG           hMsg;
    } u;
    LPCWSTR                 szFileName;         // OPTIONAL
    PFNCPROPPAGECALLBACK    pPropPageCallback;  // OPTIONAL
    void *                  pvCallbackData;     // OPTIONAL
    DWORD                   cStores;            // OPTIONAL
    HCERTSTORE *            rghStores;          // OPTIONAL
    DWORD                   cPropSheetPages;    // OPTIONAL
    LPCPROPSHEETPAGEW       rgPropSheetPages;   // OPTIONAL
} CRYPTUI_VIEWSIGNATURES_STRUCTW, *PCRYPTUI_VIEWSIGNATURES_STRUCTW;
typedef const CRYPTUI_VIEWSIGNATURES_STRUCTW *PCCRYPTUI_VIEWSIGNATURES_STRUCTW;

typedef struct tagCRYPTUI_VIEWSIGNATURES_STRUCTA {
    DWORD                   dwSize;
    HWND                    hwndParent;         // OPTIONAL
    DWORD                   dwFlags;            // OPTIONAL
    LPCSTR                  szTitle;            // OPTIONAL
    unsigned short          choice;
    union {
        CRYPT_DATA_BLOB     EncodedMessage;
        HCRYPTMSG           hMsg;
    } u;
    LPCSTR                  szFileName;         // OPTIONAL
    PFNCPROPPAGECALLBACK    pPropPageCallback;  // OPTIONAL
    void *                  pvCallbackData;     // OPTIONAL
    DWORD                   cStores;            // OPTIONAL
    HCERTSTORE *            rghStores;          // OPTIONAL
    DWORD                   cPropSheetPages;    // OPTIONAL
    LPCPROPSHEETPAGEA       rgPropSheetPages;   // OPTIONAL
} CRYPTUI_VIEWSIGNATURES_STRUCTA, *PCRYPTUI_VIEWSIGNATURES_STRUCTA;
typedef const CRYPTUI_VIEWSIGNATURES_STRUCTA *PCCRYPTUI_VIEWSIGNATURES_STRUCTA;


// NOTE!!   when calling this function, the following parameters of the
//          CRYPTUI_VIEWSIGNATURES_STRUCT struct are unused
//              cPropSheetPages
//              rgPropSheetPages
//              szTitle
BOOL
WINAPI
CryptUIGetViewSignaturesPagesW(
            IN  PCCRYPTUI_VIEWSIGNATURES_STRUCTW    pcvs,
            OUT PROPSHEETPAGEW                      **prghPropPages,
            OUT DWORD                               *pcPropPages
            );

BOOL
WINAPI
CryptUIGetViewSignaturesPagesA(
            IN  PCCRYPTUI_VIEWSIGNATURES_STRUCTA    pcvs,
            OUT PROPSHEETPAGEA                      **prghPropPages,
            OUT DWORD                               *pcPropPages
            );

BOOL
WINAPI
CryptUIFreeViewSignaturesPagesW(
            IN PROPSHEETPAGEW  *rghPropPages,
            IN DWORD           cPropPages
            );

BOOL
WINAPI
CryptUIFreeViewSignaturesPagesA(
            IN PROPSHEETPAGEA  *rghPropPages,
            IN DWORD           cPropPages
            );

#ifdef UNICODE
#define CryptUIGetViewSignaturesPages   CryptUIGetViewSignaturesPagesW
#define CryptUIFreeViewSignaturesPages  CryptUIFreeViewSignaturesPagesW
#define PCRYPTUI_VIEWSIGNATURES_STRUCT  PCRYPTUI_VIEWSIGNATURES_STRUCTW
#define CRYPTUI_VIEWSIGNATURES_STRUCT   CRYPTUI_VIEWSIGNATURES_STRUCTW
#define PCCRYPTUI_VIEWSIGNATURES_STRUCT PCCRYPTUI_VIEWSIGNATURES_STRUCTW
#else
#define CryptUIGetViewSignaturesPages   CryptUIGetViewSignaturesPagesA
#define CryptUIFreeViewSignaturesPages  CryptUIFreeViewSignaturesPagesA
#define PCRYPTUI_VIEWSIGNATURES_STRUCT  PCRYPTUI_VIEWSIGNATURES_STRUCTA
#define CRYPTUI_VIEWSIGNATURES_STRUCT   CRYPTUI_VIEWSIGNATURES_STRUCTA
#define PCCRYPTUI_VIEWSIGNATURES_STRUCT PCCRYPTUI_VIEWSIGNATURES_STRUCTA
#endif


/////////////////////////////////////////////////////////////////////////////////////////////////////
//
//  the select store dialog can be passed a callback which is called to validate the store that the
//  user selected.  Return TRUE to accept the store, or FALSE to reject the store.  It TRUE is
//  returned then the store will be returned to the caller of CryptUIDlg\, if FALSE is returned
//  then the select store dialog will remain displayed so the user may make another selection

typedef BOOL (WINAPI * PFNCVALIDATESTOREPROC)(
        HCERTSTORE  hStore,
        HWND        hWndSelectStoreDialog,
        void        *pvCallbackData);

/////////////////////////////////////////////////////////////////////////////////////////////////////
//      these two parameters are passed to the CertEnumSystemStore call and the stores that are
//      enumerated via that call are added to the store selection list.
//
//      dwFlags                    CertEnumSystemStore
//      pvSystemStoreLocationPara  CertEnumSystemStore
typedef struct _STORENUMERATION_STRUCT {
    DWORD               dwFlags;
    void *              pvSystemStoreLocationPara;
} STORENUMERATION_STRUCT, *PSTORENUMERATION_STRUCT;
typedef const STORENUMERATION_STRUCT *PCSTORENUMERATION_STRUCT;

/////////////////////////////////////////////////////////////////////////////////////////////////////
//      both the array of store handles and the array of enumeration strucs may be used to
//      populate the store selection list.  if either is not used the count must be set to 0.
//      if the array of store handles is used the cert stores must have either been opened
//      with the CERT_STORE_SET_LOCALIZED_NAME_FLAG flag, or the CertSetStoreProperty function
//      must have been called with the CERT_STORE_LOCALIZED_NAME_PROP_ID flag.  if the
//      CryptUIDlgSelectStore function is unable to obtain a name for a store that store will not
//      be displayed.
//
//      cStores                    count of stores to select from
//      rghStores                  array of stores to select from
//      cEnumerationStructs        count of enumeration structs
//      rgEnumerationStructs       array of enumeration structs
typedef struct _STORESFORSELCTION_STRUCT {
    DWORD                       cStores;
    HCERTSTORE *                rghStores;
    DWORD                       cEnumerationStructs;
    PCSTORENUMERATION_STRUCT    rgEnumerationStructs;
} STORESFORSELCTION_STRUCT, *PSTORESFORSELCTION_STRUCT;
typedef const STORESFORSELCTION_STRUCT *PCSTORESFORSELCTION_STRUCT;

/////////////////////////////////////////////////////////////////////////////////////////////////////
//
// dwSize                          size of this struct
// hwndParent                      parent of this dialog                                    (OPTIONAL)
// dwFlags                         flags, may a combination of any of the flags below
// szTitle                         title of the dialog                                      (OPTIONAL)
// szDisplayString                 a string that will be displayed in the dialog that may   (OPTIONAL)
//                                 be used to infor the user what they are selecting a store
//                                 for.  if it is not set a default string will be displayed,
//                                 the default resource is IDS_SELECT_STORE_DEFAULT
// pStoresForSelection             a struct that contains the stores that are to be selected
//                                 from.  the stores can be in two different formats, an array
//                                 of store handles and/or an array of enumeration structs
//                                 which will be used to call CertEnumSystemStore
// pValidateStoreCallback          a pointer to a PFNCVALIDATESTOREPROC which is used to    (OPTIONAL)
//                                 callback the caller of CryptUIDlgSelectStore when the
//                                 user hasselected a store and pressed OK
// pvCallbackData                  if pValidateStoreCallback is being used this value is    (OPTIONAL)
//                                 passed back to the caller when the pValidateStoreCallback
//                                 is made
//
/////////////////////////////////////////////////////////////////////////////////////////////////////

// dwFlags
#define CRYPTUI_ALLOW_PHYSICAL_STORE_VIEW       0x00000001
#define CRYPTUI_RETURN_READ_ONLY_STORE          0x00000002
#define CRYPTUI_DISPLAY_WRITE_ONLY_STORES       0x00000004
#define CRYPTUI_VALIDATE_STORES_AS_WRITABLE     0x00000008

typedef struct tagCRYPTUI_SELECTSTORE_STRUCTW {
    DWORD                       dwSize;
    HWND                        hwndParent;             // OPTIONAL
    DWORD                       dwFlags;                // OPTIONAL
    LPCWSTR                     szTitle;                // OPTIONAL
    LPCWSTR                     szDisplayString;        // OPTIONAL
    PCSTORESFORSELCTION_STRUCT  pStoresForSelection;
    PFNCVALIDATESTOREPROC       pValidateStoreCallback; // OPTIONAL
    void *                      pvCallbackData;         // OPTIONAL
} CRYPTUI_SELECTSTORE_STRUCTW, *PCRYPTUI_SELECTSTORE_STRUCTW;
typedef const CRYPTUI_SELECTSTORE_STRUCTW *PCCRYPTUI_SELECTSTORE_STRUCTW;

typedef struct tagCRYPTUI_SELECTSTORE_STRUCTA {
    DWORD                       dwSize;
    HWND                        hwndParent;             // OPTIONAL
    DWORD                       dwFlags;                // OPTIONAL
    LPCSTR                      szTitle;                // OPTIONAL
    LPCSTR                      szDisplayString;        // OPTIONAL
    PCSTORESFORSELCTION_STRUCT  pStoresForSelection;
    PFNCVALIDATESTOREPROC       pValidateStoreCallback; // OPTIONAL
    void *                      pvCallbackData;         // OPTIONAL
} CRYPTUI_SELECTSTORE_STRUCTA, *PCRYPTUI_SELECTSTORE_STRUCTA;
typedef const CRYPTUI_SELECTSTORE_STRUCTA *PCCRYPTUI_SELECTSTORE_STRUCTA;

//
// the HCERTSTORE that is returned must be closed by calling CertCloseStore
//
HCERTSTORE
WINAPI
CryptUIDlgSelectStoreW(
            IN PCCRYPTUI_SELECTSTORE_STRUCTW pcss
            );

HCERTSTORE
WINAPI
CryptUIDlgSelectStoreA(
            IN PCCRYPTUI_SELECTSTORE_STRUCTA pcss
            );

#ifdef UNICODE
#define CryptUIDlgSelectStore           CryptUIDlgSelectStoreW
#define PCRYPTUI_SELECTSTORE_STRUCT     PCRYPTUI_SELECTSTORE_STRUCTW
#define CRYPTUI_SELECTSTORE_STRUCT      CRYPTUI_SELECTSTORE_STRUCTW
#define PCCRYPTUI_SELECTSTORE_STRUCT    PCCRYPTUI_SELECTSTORE_STRUCTW
#else
#define CryptUIDlgSelectStore           CryptUIDlgSelectStoreA
#define PCRYPTUI_SELECTSTORE_STRUCT     PCRYPTUI_SELECTSTORE_STRUCTA
#define CRYPTUI_SELECTSTORE_STRUCT      CRYPTUI_SELECTSTORE_STRUCTA
#define PCCRYPTUI_SELECTSTORE_STRUCT    PCCRYPTUI_SELECTSTORE_STRUCTA
#endif
/////////////////////////////////////////////////////////////////////////////////////////////////////


#if (0) //DSIE: 7/02/2002 moved to CryptUIAPI.h per consent degree.
/////////////////////////////////////////////////////////////////////////////////////////////////////
//
//  The select cert dialog can be passed a filter proc to reduce the set of certificates
//  displayed.  Return TRUE to display the certificate and FALSE to hide it.  If TRUE is
//  returned then optionally the pfInitialSelectedCert boolean may be set to TRUE to indicate
//  to the dialog that this cert should be the initially selected cert.  Note that the
//  most recent cert that had the pfInitialSelectedCert boolean set during the callback will
//  be the initially selected cert.

typedef BOOL (WINAPI * PFNCFILTERPROC)(
        PCCERT_CONTEXT  pCertContext,
        BOOL            *pfInitialSelectedCert,
        void            *pvCallbackData);
#endif

/////////////////////////////////////////////////////////////////////////////////////////////////////
//
//  Certificates may be viewed by the user when selecting certificates from the select certificate
//  dialog.  This callback will allow the caller of the select certificate dialog to handle the
//  displaying of those certificates.  This may be useful if the caller wishes to call WinVerifyTrust
//  with their own policy module and display the certificate with that WinVerifyTrust state.  If
//  FALSE is returned from this callback it is assumed that the select certificate dialog will be
//  responsible for dislaying the certificate in question.  If TRUE is returned it is assumed that the
//  display of the certificate was already handled.

typedef BOOL (WINAPI * PFNCCERTDISPLAYPROC)(
        PCCERT_CONTEXT  pCertContext,
        HWND            hWndSelCertDlg,
        void            *pvCallbackData);

/////////////////////////////////////////////////////////////////////////////////////////////////////
//
// dwSize                          size of this struct
// hwndParent                      parent of this dialog                                    (OPTIONAL)
// dwFlags                         flags:
//                                 CRYPTUI_SELECTCERT_MULTISELECT -
//                                      if this flag is set then CryptUIDlgSelectCertificate
//                                      will return NULL, and the hSelectedCertStore
//                                      parameter must contain a valid store handle that
//                                      will be populated with all the selected certificates.
// dwDontUseColumn                 This can be used to disable the display of certain       (OPTIONAL)
//                                 columns.  It can be set with any comibnation of the
//                                 column flags below
// szTitle                         title of the dialog                                      (OPTIONAL)
// szDisplayString                 a string that will be displayed in the dialog that may   (OPTIONAL)
//                                 be used to inform the user what they are selecting a
//                                 a certificate for.  if it is not set a default string
//                                 will be displayed.  the defualt strings resourece is
//                                 IDS_SELECT_CERT_DEFAULT
// pFilterCallback                 a pointer to a PFNCMFILTERPROC which is used to filter   (OPTIONAL)
//                                 the certificates which are displayed for selection
// pDisplayCallback                a pointer to a PFNCCERTDISPLAYPROC which is used to
//                                 handle displaying certificates
// pvCallbackData                  if either or both pFilterCallback or pDisplayCallback    (OPTIONAL)
//                                 are being used this value is passed back to the caller
//                                 when the callbacks are made
// cDisplayStores                  count of stores that contain the certs to display
//                                 for selection
// rghDisplayStores                array of stores that contain the certs to display
//                                 for selection
// cStores                         count of other stores to search when building chain and  (OPTIONAL)
//                                 validating trust of the certs which are displayed, if
//                                 the user choosing a cert would like to view a particular
//                                 cert which is displayed for selection, these stores
//                                 are passed to the CertViewCert dialog
// rghStores                       array of other stores to search when building chain and  (OPTIONAL)
//                                 validating trust of the certs which are displayed, if
//                                 the user choosing a cert would like to view a particular
//                                 cert which is displayed for selection, these stores
//                                 are passed to the CertViewCert dialog
// cPropSheetPages                 PASS THROUGH - number of pages in rgPropSheetPages array (OPTIONAL)
// rgPropSheetPages                PASS THROUGH - extra pages that are passed through       (OPTIONAL)
//                                 to the certificate viewing dialog when it is invoked from
//                                 the selection dialog
// hSelectedCertStore              This certificate store is passed in by the caller if the (OPTIONAL)
//                                 CRYPTUI_SELECTCERT_MULTISELECT flag is set.  The store
//                                 will contain all the selected certificates on return.
//
/////////////////////////////////////////////////////////////////////////////////////////////////////

// flags for dwDontUseColumn
//
// The following are defined in cryptuiapi.h
// #define CRYPTUI_SELECT_ISSUEDTO_COLUMN        0x000000001
// #define CRYPTUI_SELECT_ISSUEDBY_COLUMN        0x000000002
// #define CRYPTUI_SELECT_INTENDEDUSE_COLUMN     0x000000004
// #define CRYPTUI_SELECT_FRIENDLYNAME_COLUMN    0x000000008
// #define CRYPTUI_SELECT_LOCATION_COLUMN        0x000000010
// #define CRYPTUI_SELECT_EXPIRATION_COLUMN      0x000000020

typedef struct tagCRYPTUI_SELECTCERTIFICATE_STRUCTW {
    DWORD               dwSize;
    HWND                hwndParent;         // OPTIONAL
    DWORD               dwFlags;            // OPTIONAL
    LPCWSTR             szTitle;            // OPTIONAL
    DWORD               dwDontUseColumn;    // OPTIONAL
    LPCWSTR             szDisplayString;    // OPTIONAL
    PFNCFILTERPROC      pFilterCallback;    // OPTIONAL
    PFNCCERTDISPLAYPROC pDisplayCallback;   // OPTIONAL
    void *              pvCallbackData;     // OPTIONAL
    DWORD               cDisplayStores;
    HCERTSTORE *        rghDisplayStores;
    DWORD               cStores;            // OPTIONAL
    HCERTSTORE *        rghStores;          // OPTIONAL
    DWORD               cPropSheetPages;    // OPTIONAL
    LPCPROPSHEETPAGEW   rgPropSheetPages;   // OPTIONAL
    HCERTSTORE          hSelectedCertStore; // OPTIONAL
} CRYPTUI_SELECTCERTIFICATE_STRUCTW, *PCRYPTUI_SELECTCERTIFICATE_STRUCTW;
typedef const CRYPTUI_SELECTCERTIFICATE_STRUCTW *PCCRYPTUI_SELECTCERTIFICATE_STRUCTW;

typedef struct tagCRYPTUI_SELECTCERTIFICATE_STRUCT_A {
    DWORD               dwSize;
    HWND                hwndParent;         // OPTIONAL
    DWORD               dwFlags;            // OPTIONAL
    LPCSTR              szTitle;            // OPTIONAL
    DWORD               dwDontUseColumn;    // OPTIONAL
    LPCSTR              szDisplayString;    // OPTIONAL
    PFNCFILTERPROC      pFilterCallback;    // OPTIONAL
    PFNCCERTDISPLAYPROC pDisplayCallback;   // OPTIONAL
    void *              pvCallbackData;     // OPTIONAL
    DWORD               cDisplayStores;
    HCERTSTORE *        rghDisplayStores;
    DWORD               cStores;            // OPTIONAL
    HCERTSTORE *        rghStores;          // OPTIONAL
    DWORD               cPropSheetPages;    // OPTIONAL
    LPCPROPSHEETPAGEA   rgPropSheetPages;   // OPTIONAL
    HCERTSTORE          hSelectedCertStore; // OPTIONAL
} CRYPTUI_SELECTCERTIFICATE_STRUCTA, *PCRYPTUI_SELECTCERTIFICATE_STRUCTA;
typedef const CRYPTUI_SELECTCERTIFICATE_STRUCTA *PCCRYPTUI_SELECTCERTIFICATE_STRUCTA;

//
// the PCCERT_CONTEXT that is returned must be released by calling CertFreeCertificateContext().
// if NULL is returned and GetLastError() == 0 then the user dismissed the dialog by hitting the
// "cancel" button, otherwise GetLastError() will contain the last error.
//
PCCERT_CONTEXT
WINAPI
CryptUIDlgSelectCertificateW(
            IN PCCRYPTUI_SELECTCERTIFICATE_STRUCTW pcsc
            );

PCCERT_CONTEXT
WINAPI
CryptUIDlgSelectCertificateA(
            IN PCCRYPTUI_SELECTCERTIFICATE_STRUCTA pcsc
            );

#ifdef UNICODE
#define CryptUIDlgSelectCertificate         CryptUIDlgSelectCertificateW
#define PCRYPTUI_SELECTCERTIFICATE_STRUCT   PCRYPTUI_SELECTCERTIFICATE_STRUCTW
#define CRYPTUI_SELECTCERTIFICATE_STRUCT    CRYPTUI_SELECTCERTIFICATE_STRUCTW
#define PCCRYPTUI_SELECTCERTIFICATE_STRUCT  PCCRYPTUI_SELECTCERTIFICATE_STRUCTW
#else
#define CryptUIDlgSelectCertificate         CryptUIDlgSelectCertificateA
#define PCRYPTUI_SELECTCERTIFICATE_STRUCT   PCRYPTUI_SELECTCERTIFICATE_STRUCTA
#define CRYPTUI_SELECTCERTIFICATE_STRUCT    CRYPTUI_SELECTCERTIFICATE_STRUCTA
#define PCCRYPTUI_SELECTCERTIFICATE_STRUCT  PCCRYPTUI_SELECTCERTIFICATE_STRUCTA
#endif

// dwFlags
#define     CRYPTUI_SELECTCERT_MULTISELECT                      0x00000001
#define     CRYPTUI_SELECTCERT_ADDFROMDS                        0x00010000

//flags for dwFlags in CRYPTUI_SELECT_CA_STRUCT struct
#define     CRYPTUI_DLG_SELECT_CA_FROM_NETWORK                  0x0001
#define     CRYPTUI_DLG_SELECT_CA_USE_DN                        0x0002
#define     CRYPTUI_DLG_SELECT_CA_LOCAL_MACHINE_ENUMERATION     0x0004
//-------------------------------------------------------------------------
//
//	CRYPTUI_CA_CONTEXT
//
//-------------------------------------------------------------------------
typedef struct _CRYPTUI_CA_CONTEXT
{
    DWORD                   dwSize;	
    LPCWSTR                 pwszCAName;
    LPCWSTR                 pwszCAMachineName;
}CRYPTUI_CA_CONTEXT, *PCRYPTUI_CA_CONTEXT;

typedef const CRYPTUI_CA_CONTEXT *PCCRYPTUI_CA_CONTEXT;


//-------------------------------------------------------------------------
//
//	
//
//  The select certificate authoritiy (CA) dialog can be passed a filter proc to reduce the set of CAs
//  displayed.  Return TRUE to display the CA and FALSE to hide it.  If TRUE is
//  returned then optionally the pfInitialSelectedCert boolean may be set to TRUE to indicate
//  to the dialog that this CA should be the initially selected CA.  Note that the
//  most recent cert that had the pfInitialSelectedCert boolean set during the callback will
//  be the initially selected CA.
//
//-------------------------------------------------------------------------

typedef BOOL (WINAPI * PFN_CRYPTUI_SELECT_CA_FUNC)(
        PCCRYPTUI_CA_CONTEXT        pCAContext,
        BOOL                        *pfInitialSelected,
        void                        *pvCallbackData);


//-------------------------------------------------------------------------
//
//	CRYPTUI_SELECT_CA_STRUCT
//
//  dwSize	           Required:    Must be set to sizeof(CRYPTUI_SELECT_CA_STRUCT)
//  hwndParent         Optional:    Parent of this dialog
//  dwFlags            Optional:    Flags, Can be set to any combination of the following:
//                                  CRYPTUI_DLG_SELECT_CA_FROM_NETWORK:
//                                     All the available CAs from the network will be displayed
//                                  CRYPTUI_DLG_SELECT_CA_USE_DN:
//                                     Use the full DN (Distinguished Name) as the CA name.
//                                      By default, CN (common name) is used.
//                                  CRYPTUI_DLG_SELECT_CA_LOCAL_MACHINE_ENUMERATION:
//                                      Display the CAs available to the local machine only.
//                                      By Default, CAs available to the current user will be displayed
//  wszTitle           Optional:    Title of the dialog
//  wszDisplayString   Optional:    A string that will be displayed in the dialog that may   (OPTIONAL)
//                                  be used to inform the user what they are selecting a
//                                  a certificate for.  if it is not set a default string
//                                  will be displayed.  the defualt strings resourece is
//                                  IDS_SELECT_CA_DISPLAY_DEFAULT
//  cCAContext         Optional:    The count of additional CA contexts that will be displayed
//                                  in the dialogs
//  *rgCAContext       Optioanl:    The array of additional CA contexts that will be displayed
//                                  in the dialogs
//  pSelectCACallback  Optional:    a pointer to a PCCRYPTUI_CA_CONTEXT which is used to filter
//                                  the certificate autorities which are displayed for selection
//  pvCallbackData     Optional:    if pSelectCACallback is being used this value is passed
//                                  back to the caller when the pSelectCACallback is made
//-------------------------------------------------------------------------
typedef struct _CRYPTUI_SELECT_CA_STRUCT
{
    DWORD                       dwSize;	                    // REQUIRED
    HWND                        hwndParent;                 // OPTIONAL
    DWORD                       dwFlags;                    // OPTIONAL
    LPCWSTR                     wszTitle;                   // OPTIONAL
    LPCWSTR                     wszDisplayString;           // OPTIONAL
    DWORD                       cCAContext;                 // OPTIONAL
    PCCRYPTUI_CA_CONTEXT        *rgCAContext;               // OPTIONAL
    PFN_CRYPTUI_SELECT_CA_FUNC  pSelectCACallback;          // OPTIONAL
    void                        *pvCallbackData;            // OPTIONAL
}CRYPTUI_SELECT_CA_STRUCT, *PCRYPTUI_SELECT_CA_STRUCT;

typedef const CRYPTUI_SELECT_CA_STRUCT *PCCRYPTUI_SELECT_CA_STRUCT;

//--------------------------------------------------------------
//
//  Parameters:
//      pCryptUISelectCA       IN  Required
//
//  the PCCRYPTUI_CA_CONTEXT that is returned must be released by calling
//  CryptUIDlgFreeCAContext
//  if NULL is returned and GetLastError() == 0 then the user dismissed the dialog by hitting the
//  "cancel" button, otherwise GetLastError() will contain the last error.
//
//
//--------------------------------------------------------------
PCCRYPTUI_CA_CONTEXT
WINAPI
CryptUIDlgSelectCA(
        IN PCCRYPTUI_SELECT_CA_STRUCT pCryptUISelectCA
             );

BOOL
WINAPI
CryptUIDlgFreeCAContext(
        IN PCCRYPTUI_CA_CONTEXT       pCAContext
            );


#if (0) //DSIE: 7/02/2002 moved to CryptUIAPI.h per consent degree.
//-------------------------------------------------------------------------
//
//	CRYPTUI_CERT_MGR_STRUCT
//
//  dwSize	           Required:    Must be set to sizeof(CRYPTUI_CERT_MGR_STRUCT)
//  hwndParent         Optional:    Parent of this dialog
//  dwFlags            Optional:    Personal is the default initially selected
//                                  tab.
//                                  CRYPTUI_CERT_MGR_PUBLISHER_TAB may be set
//                                  to select Trusted Publishers as the
//                                  initially selected tab.
//                                  CRYPTUI_CERT_MGR_SINGLE_TAB_FLAG may also
//                                  be set to only display the Trusted
//                                  Publishers tab.
//  wszTitle           Optional:    Title of the dialog
//  pszInitUsageOID    Optional:    The enhanced key usage object identifier (OID).
//                                  Certificates with this OID will initially
//                                  be shown as a default. User
//                                  can then choose different OIDs.
//                                  NULL means all certificates will be shown initially.
//-------------------------------------------------------------------------
typedef struct _CRYPTUI_CERT_MGR_STRUCT
{
    DWORD                       dwSize;	                    // REQUIRED
    HWND                        hwndParent;                 // OPTIONAL
    DWORD                       dwFlags;                    // OPTIONAL
    LPCWSTR                     pwszTitle;                   // OPTIONAL
    LPCSTR                      pszInitUsageOID;            // OPTIONAL
}CRYPTUI_CERT_MGR_STRUCT, *PCRYPTUI_CERT_MGR_STRUCT;

typedef const CRYPTUI_CERT_MGR_STRUCT *PCCRYPTUI_CERT_MGR_STRUCT;

#define CRYPTUI_CERT_MGR_TAB_MASK           0x0000000F
#define CRYPTUI_CERT_MGR_PUBLISHER_TAB      0x00000004

#define CRYPTUI_CERT_MGR_SINGLE_TAB_FLAG    0x00008000

//--------------------------------------------------------------
//
//  Parameters:
//      pCryptUICertMgr       IN  Required
//
//
//--------------------------------------------------------------
BOOL
WINAPI
CryptUIDlgCertMgr(
        IN PCCRYPTUI_CERT_MGR_STRUCT pCryptUICertMgr);
#endif


/////////////////////////////////////////////////////////////////////////////////////////////////////

/////////////////////////////////////////////////////////////////////////////////////////////////////

//-----------------------------------------------------------------------
//  The valid values for dwFlags for the CryptUIWiz APIs
//
//------------------------------------------------------------------------

#if (0) //DSIE: 7/02/2002 moved to CryptUIAPI.h per consent degree.
#define     CRYPTUI_WIZ_NO_UI                           0x0001
#endif
#define     CRYPTUI_WIZ_IGNORE_NO_UI_FLAG_FOR_CSPS      0x0002
#define     CRYPTUI_WIZ_NO_UI_EXCEPT_CSP                0x0003
#define     CRYPTUI_WIZ_ALLOW_ALL_TEMPLATES             0x0004
#define     CRYPTUI_WIZ_ALLOW_ALL_CAS                   0x0008
#define     CRYPTUI_WIZ_CERT_REQUEST_REQUIRE_NEW_KEY    0x0040 // The enrollment API may not reuse an existing private key

// Valid only for CryptUIWizExport.
#define     CRYPTUI_WIZ_EXPORT_PRIVATE_KEY              0x0100 // This will skip the Export Private Key page,
                                                               // and assume private key is to be exported.
#define     CRYPTUI_WIZ_EXPORT_NO_DELETE_PRIVATE_KEY    0x0200 // This will disable the "Delete the priate key..." 
                                                               // check box in the Export File Format page.


//CRYPTUI_WIZ_NO_INSTALL_ROOT is only valid for CryptUIWizCertRequest API
//the wizard will not install the issued certificate chain into the root store,
//instead, it will put the certificate chain into the CA store.
#define     CRYPTUI_WIZ_NO_INSTALL_ROOT                 0x0010


//CRYPTUI_WIZ_BUILDCTL_SKIP_DESTINATION only valid for CryptUIWizBuildCTL API.
//the wizard will skip the page which asks user to enter destination where the CTL will
//be stored.
#define     CRYPTUI_WIZ_BUILDCTL_SKIP_DESTINATION       0x0004


//CRYPTUI_WIZ_BUILDCTL_SKIP_SIGNING only valid for CryptUIWizBuildCTL API.
//the wizard will skip the page which asks user to sign the CTL.
//the CTLContext returned by CryptUIWizBuildCTL will not be signed.
//Caller can then use CryptUIWizDigitalSign to sign the CTL.
#define     CRYPTUI_WIZ_BUILDCTL_SKIP_SIGNING           0x0008

//CRYPTUI_WIZ_BUILDCTL_SKIP_PURPOSE only valid for CryptUIWizBuildCTL API.
//the wizard will skip the page which asks user for the purpose, validity,
//and list ID of the CTL.
#define     CRYPTUI_WIZ_BUILDCTL_SKIP_PURPOSE           0x0010

#define     CRYPTUI_WIZ_NO_ARCHIVE_RENEW_CERT           0x0020

#define CRYPTUI_WIZ_CREATE_ONLY 0x00010000
#define CRYPTUI_WIZ_SUBMIT_ONLY 0x00020000
#define CRYPTUI_WIZ_FREE_ONLY   0x00040000
#define CRYPTUI_WIZ_QUERY_ONLY  0x00080000
#define CRYPTUI_WIZ_NODS_MASK   0x000F0000

///-----------------------------------------------------------------------
//  CRYPTUI_WIZ_CERT_REQUEST_PVK_CERT
//
//------------------------------------------------------------------------
typedef struct _CRYPTUI_WIZ_CERT_REQUEST_PVK_CERT
{
    DWORD           dwSize;             //Required: Set to the sizeof(CRYPTUI_WIZ_CERT_REQUEST_PVK_CERT)
    PCCERT_CONTEXT  pCertContext;       //Required: Use the private key of the certificate context
                                        //          The certificate context
                                        //          has to have CERT_KEY_PROV_INFO_PROP_ID property
                                        //          and the private key has to exist
}CRYPTUI_WIZ_CERT_REQUEST_PVK_CERT, *PCRYPTUI_WIZ_CERT_REQUEST_PVK_CERT;

typedef const CRYPTUI_WIZ_CERT_REQUEST_PVK_CERT *PCCRYPTUI_WIZ_CERT_REQUEST_PVK_CERT;


///-----------------------------------------------------------------------
//  CRYPTUI_WIZ_CERT_REQUEST_PVK_EXISTING
//
//------------------------------------------------------------------------
typedef struct _CRYPTUI_WIZ_CERT_REQUEST_PVK_EXISTING
{
    DWORD                   dwSize;             //Required: Set to the sizeof(CRYPTUI_WIZ_CERT_REQUEST_PVK_EXISTING)
    PCRYPT_KEY_PROV_INFO    pKeyProvInfo;       //Required: The information about the provider and the private key
                                                //          The optional CRYPT_KEY_PROV_PARAM fields in PCRYPT_KEY_PROV_INFO
                                                //          are ignored.
}CRYPTUI_WIZ_CERT_REQUEST_PVK_EXISTING, *PCRYPTUI_WIZ_CERT_REQUEST_PVK_EXISTING;

typedef const CRYPTUI_WIZ_CERT_REQUEST_PVK_EXISTING *PCCRYPTUI_WIZ_CERT_REQUEST_PVK_EXISTING;

///-----------------------------------------------------------------------
//  CERT_REQUEST_PVK_NEW
//
//------------------------------------------------------------------------
typedef struct _CRYPTUI_WIZ_CERT_REQUEST_PVK_NEW
{
    DWORD                   dwSize;             //Required: Set to the sizeof(CRYPTUI_WIZ_CERT_REQUEST_PVK_NEW)
    PCRYPT_KEY_PROV_INFO    pKeyProvInfo;       //Optional: The information about the provider and the private key
                                                //          NULL means use the default
                                                //          The optional CRYPT_KEY_PROV_PARAM fields in PCRYPT_KEY_PROV_INFO
                                                //          are ignored.
    DWORD                   dwGenKeyFlags;      //Optional: The flags for CryptGenKey
}CRYPTUI_WIZ_CERT_REQUEST_PVK_NEW, *PCRYPTUI_WIZ_CERT_REQUEST_PVK_NEW;


typedef const CRYPTUI_WIZ_CERT_REQUEST_PVK_NEW *PCCRYPTUI_WIZ_CERT_REQUEST_PVK_NEW;


///-----------------------------------------------------------------------
//  CRYPTUI_WIZ_CERT_TYPE
//
//------------------------------------------------------------------------
typedef struct _CRYPTUI_WIZ_CERT_TYPE
{
    DWORD                   dwSize;             //Required: Set to the sizeof(CRYPTUI_WIZ_CERT_TYPE)
    DWORD                   cCertType;          //the count of rgwszCertType.  cCertType should be 1.
    LPWSTR                  *rgwszCertType;     //the array of certificate type name
}CRYPTUI_WIZ_CERT_TYPE, *PCRYPTUI_WIZ_CERT_TYPE;

typedef const CRYPTUI_WIZ_CERT_TYPE *PCCRYPTUI_WIZ_CERT_TYPE;


//-----------------------------------------------------------------------
// dwPvkChoice
//-----------------------------------------------------------------------
#define         CRYPTUI_WIZ_CERT_REQUEST_PVK_CHOICE_CERT        1
#define         CRYPTUI_WIZ_CERT_REQUEST_PVK_CHOICE_EXISTING    2
#define         CRYPTUI_WIZ_CERT_REQUEST_PVK_CHOICE_NEW         3

//-----------------------------------------------------------------------
// dwPurpose
//-----------------------------------------------------------------------

#define     CRYPTUI_WIZ_CERT_ENROLL     0x00010000
#define     CRYPTUI_WIZ_CERT_RENEW      0x00020000

//-----------------------------------------------------------------------
//
// valid flags for dwPostOption
//-----------------------------------------------------------------------
//post the requested certificate on the directory serivce
#define     CRYPTUI_WIZ_CERT_REQUEST_POST_ON_DS                     0x01

//post the requested certificate with the private key container.
#define     CRYPTUI_WIZ_CERT_REQUEST_POST_ON_CSP                    0x02


//-----------------------------------------------------------------------
//
// valid flags for dwCertChoice
//-----------------------------------------------------------------------
#define     CRYPTUI_WIZ_CERT_REQUEST_KEY_USAGE                      0x01

#define     CRYPTUI_WIZ_CERT_REQUEST_CERT_TYPE                      0x02
//-------------------------------------------------------------------------
//
//
//  CRYPTUI_WIZ_CERT_REQUEST_INFO
//-------------------------------------------------------------------------
typedef struct _CRYPTUI_WIZ_CERT_REQUEST_INFO
{
	DWORD			    dwSize;				    //Required: Has to be set to sizeof(CRYPTUI_WIZ_CERT_REQUEST_INFO)
    DWORD               dwPurpose;              //Required: If CRYPTUI_WIZ_CERT_ENROLL is set, a certificate will be enrolled,
                                                //          If CRYPTUI_WIZ_CERT_RENEW  is set, a certificate will be renewed.
                                                //          CRYPTUI_WIZ_CERT_ENROLL and CRYPTUI_WIZ_CERT_RENEW can not be set
                                                //          at the same time
    LPCWSTR             pwszMachineName;        //Optional: The machine name for which to enroll.
    LPCWSTR             pwszAccountName;        //Optional: The account name(user or service) for which to enroll
                                                //
                                                //  pwszMachineName     pwszAccountName    Meaning
                                                //---------------------------------------------------
                                                //  NULL                NULL               Request for current account on the current machine
                                                //  "fooMachine"        NULL               Request for the machine named "fooMachine"
                                                //  NULL                "fooUser"          Request for the "fooUser" account on the current machine
                                                //  "fooMachine"        "fooUser"          Request for the "fooUser" accunt on the "fooMachine" machine
                                                //
    void                *pAuthentication;       //Reserved: authenticate info.  Must be set to NULL.
    LPCWSTR             pCertRequestString;     //Reserved: The additional request string.  Must be set to NULL.
    LPCWSTR             pwszDesStore;           //Optional: The desination store where to put
                                                //              the enrolled certificate.  Default to "My" if the value is NULL
    DWORD               dwCertOpenStoreFlag;    //Optional: The value passed to dwFlags of CertOpenStore for the
                                                //          destination store
                                                //          If this value is 0, we use CERT_SYSTEM_STORE_CURRENT_USER for
                                                //          an accout and CERT_SYSTEM_STORE_LOCAL_MACHINE for a machine
    LPCSTR              pszHashAlg;             //Optional: The oid string of the hash algorithm of the certificate.
    PCCERT_CONTEXT      pRenewCertContext;      //Required  if CRYPTUI_WIZ_CERT_RENEW  is set in dwPurpose
                                                //Ignored   otherwise and shoule be set to NULL.
    DWORD               dwPvkChoice;            //Required: Specify the private key information
                                                //            CRYPTUI_WIZ_CERT_REQUEST_PVK_CHOICE_CERT
                                                //            CRYPTUI_WIZ_CERT_REQUEST_PVK_CHOICE_EXISTING
                                                //            CRYPTUI_WIZ_CERT_REQUEST_PVK_CHOICE_NEW
    union                                       //Required.
    {
		PCCRYPTUI_WIZ_CERT_REQUEST_PVK_CERT      pPvkCert;	
        PCCRYPTUI_WIZ_CERT_REQUEST_PVK_EXISTING  pPvkExisting;
        PCCRYPTUI_WIZ_CERT_REQUEST_PVK_NEW       pPvkNew;
    };

    LPCWSTR             pwszCALocation;         //Required  if dwCertChoice==CRYPTUI_WIZ_CERT_REQUEST_KEY_USAGE                                                //Optional  Otherwise
                                                //Optional  Otherwise
                                                //          The machine name of the Certiviate Authority (CA)
    LPCWSTR             pwszCAName;             //Required   if dwCertChoice==CRYPTUI_WIZ_CERT_REQUEST_KEY_USAGE
                                                //Optional  Otherwise
                                                //          The name of the Certificate Authority (CA)
    DWORD               dwPostOption;           //Optional  Can set to any combination of the following flag:
                                                //              CRYPTUI_WIZ_CERT_REQUEST_POST_ON_DS
                                                //
    DWORD               dwCertChoice;           //Optional  if CRYPTUI_WIZ_CERT_ENROLL is set in dwPurpose
                                                //          and CRYPTUI_WIZ_NO_UI is not set
                                                //Required  if CRYPTUI_WIZ_CERT_ENROLL is set in dwPurpose
                                                //          and CRYPTUI_WIZ_NO_UI is set
                                                //ignored   otherwise and should be set to 0.
                                                //          Specify the type of the requested certificate
                                                //          it can be one of the following flag:
                                                //              CRYPTUI_WIZ_CERT_REQUEST_KEY_USAGE
                                                //              CRYPTUI_WIZ_CERT_REQUEST_CERT_TYPE
    union
    {
        PCERT_ENHKEY_USAGE      pKeyUsage;      //          Indicate the enhanced key usage OIDs for the requested certificate.
        PCCRYPTUI_WIZ_CERT_TYPE pCertType;      //          Indicate the certificate type of the requested certificate
    };

    LPCWSTR             pwszFriendlyName;       //Optional  if CRYPTUI_WIZ_CERT_ENROLL is set in dwPurpose
                                                //Ignored   otherwise and should be set to NULL.
                                                //          The friendly name of the certificate
    LPCWSTR             pwszDescription;        //Optional  if CRYPTUI_WIZ_CERT_ENROLL is set in dwPurpose
                                                //Ignored   otherwise and should be set to NULL.
                                                //          The description of the certificate
    PCERT_EXTENSIONS    pCertRequestExtensions; //Optional  The extensions to add to the certificate request
    LPWSTR              pwszCertDNName;         //Optional  The certificate DN string
}CRYPTUI_WIZ_CERT_REQUEST_INFO, *PCRYPTUI_WIZ_CERT_REQUEST_INFO;

typedef const CRYPTUI_WIZ_CERT_REQUEST_INFO *PCCRYPTUI_WIZ_CERT_REQUEST_INFO;


//-------------------------------------------------------------------------
//
//
//  CRYPTUI_WIZ_CERT_REQUEST_INFO:
//  Used for three-stage no-DS enrollment API, exposed through 
//
//     CryptUIWizCreateCertRequestNoDS()
//     CryptUIWizSubmitCertRequestNoDS()
//     CryptUIWizFreeCertRequestNoDS() 
//      
// 
//-------------------------------------------------------------------------

typedef struct _CRYPTUI_WIZ_CREATE_CERT_REQUEST_INFO { 
    DWORD           dwSize;                 //Required: Has to be set to sizeof(CRYPTUI_WIZ_CREATE_CERT_REQUEST_INFO)
    DWORD           dwPurpose;              //Required: If CRYPTUI_WIZ_CERT_ENROLL is set, a certificate will be enrolled,
                                            //          If CRYPTUI_WIZ_CERT_RENEW  is set, a certificate will be renewed.
                                            //          CRYPTUI_WIZ_CERT_ENROLL and CRYPTUI_WIZ_CERT_RENEW can not be set
                                            //          at the same time
    HCERTTYPE       hCertType;              //Required: A handle to the cert type to use in request creation.  
    BOOL            fMachineContext;        //Required: TRUE if running under machine context, FALSE otherwise. 
    DWORD           dwCertOpenStoreFlag;    //Optional: The value passed to dwFlags of CertOpenStore for the
                                            //          destination store.
                                            //          If this value is 0, we use CERT_SYSTEM_STORE_CURRENT_USER for
                                            //          an accout and CERT_SYSTEM_STORE_LOCAL_MACHINE for a machine
    PCCERT_CONTEXT  pRenewCertContext;      //Required  if CRYPTUI_WIZ_CERT_RENEW  is set in dwPurpose
                                            //Ignored   otherwise and shoule be set to NULL.
    DWORD           dwPvkChoice;            //Required: Specify the private key information
                                            //            CRYPTUI_WIZ_CERT_REQUEST_PVK_CHOICE_CERT
                                            //            CRYPTUI_WIZ_CERT_REQUEST_PVK_CHOICE_EXISTING
                                            //            CRYPTUI_WIZ_CERT_REQUEST_PVK_CHOICE_NEW
    union                                   //Required.
    {
	PCCRYPTUI_WIZ_CERT_REQUEST_PVK_CERT      pPvkCert; 
	PCCRYPTUI_WIZ_CERT_REQUEST_PVK_EXISTING  pPvkExisting; 
	PCCRYPTUI_WIZ_CERT_REQUEST_PVK_NEW       pPvkNew; 
    }; 
    LPCWSTR             pwszCALocation;         //Required  if dwCertChoice==CRYPTUI_WIZ_CERT_REQUEST_KEY_USAGE                                                //Optional  Otherwise
                                                //Optional  Otherwise
                                                //          The machine name of the Certiviate Authority (CA)
    LPCWSTR             pwszCAName;             //Required   if dwCertChoice==CRYPTUI_WIZ_CERT_REQUEST_KEY_USAGE
                                                //Optional  Otherwise
                                                //          The name of the Certificate Authority (CA)

} CRYPTUI_WIZ_CREATE_CERT_REQUEST_INFO, *PCRYPTUI_WIZ_CREATE_CERT_REQUEST_INFO; 

typedef const CRYPTUI_WIZ_CREATE_CERT_REQUEST_INFO * PCCRYPTUI_WIZ_CREATE_CERT_REQUEST_INFO;

//-------------------------------------------------------------------------
//
//
//  CRYPTUI_WIZ_CERT_REQUEST_INFO:
//  Used to query the requests created by the no-DS enrollment API, exposed through 
//
//     CryptUIWizCreateCertRequestNoDS()
//     CryptUIWizSubmitCertRequestNoDS()
//     CryptUIWizFreeCertRequestNoDS() 
//     CryptUIWizQueryCertRequestNoDS()
//      
// 
//-------------------------------------------------------------------------

typedef struct _CRYPTUI_WIZ_QUERY_CERT_REQUEST_INFO { 
    DWORD dwSize;     // sizeof(CRYPTUI_WIZ_QUERY_CERT_REQUEST_INFO)
    DWORD dwStatus;   // set of flags, see below
} CRYPTUI_WIZ_QUERY_CERT_REQUEST_INFO, *PCRYPTUI_WIZ_QUERY_CERT_REQUEST_INFO; 

typedef const CRYPTUI_WIZ_QUERY_CERT_REQUEST_INFO * PCCRYPTUI_WIZ_QUERY_CERT_REQUEST_INFO; 

//-----------------------------------------------------------------------
//
// possible flags for CRYPTUI_WIZ_QUERY_CERT_REQUEST_INFO::dwStatus.
//
//-----------------------------------------------------------------------
#define     CRYPTUI_WIZ_QUERY_CERT_REQUEST_STATUS_CREATE_REUSED_PRIVATE_KEY   0x00000001


//-----------------------------------------------------------------------
//
// possible status for pdwStatus
//  Those status indicate the status value returned
//  from the certificate authority (certificate server).
//-----------------------------------------------------------------------
#define     CRYPTUI_WIZ_CERT_REQUEST_STATUS_SUCCEEDED           0
#define     CRYPTUI_WIZ_CERT_REQUEST_STATUS_REQUEST_ERROR       1
#define     CRYPTUI_WIZ_CERT_REQUEST_STATUS_REQUEST_DENIED      2
#define     CRYPTUI_WIZ_CERT_REQUEST_STATUS_ISSUED_SEPARATELY   3
#define     CRYPTUI_WIZ_CERT_REQUEST_STATUS_UNDER_SUBMISSION    4
#define     CRYPTUI_WIZ_CERT_REQUEST_STATUS_UNKNOWN             5
#define     CRYPTUI_WIZ_CERT_REQUEST_STATUS_CERT_ISSUED         6
#define     CRYPTUI_WIZ_CERT_REQUEST_STATUS_CONNECTION_FAILED   7


//-----------------------------------------------------------------------
//
//  CryptUIWizCertRequest
//
//      Request a certificate via a wizard.
//
//  dwFlags:  IN Optional
//      If CRYPTUI_WIZ_NO_UI is set in dwFlags, no UI will be shown.
//      If CRYPTUI_WIZ_NO_INSTALL_ROOT is set in dwFlags, the wizard will not
//      install the issued certificate chain into the root store,
//      instead, it will put the certificate chain into the CA store.

//
//  hwndParent:  IN Optional
//      The parent window for the UI.  Ignored if CRYPTUI_WIZ_NO_UI is set in dwFlags
//
//  pwszWizardTitle: IN Optional
//      The title of the wizard.   Ignored if CRYPTUI_WIZ_NO_UI is set in dwFlags
//
//  pCertRequestInfo: IN Required
//      A pointer to CRYPTUI_WIZ_CERT_REQUEST_INFO struct
//
//  ppCertContext: Out Optional
//      The issued certificate.  The certificate is in a memory store for remote enrollment.
//      The certificate is in a system cert store for local enrollment.
//
//      Even the function return TRUE, it does not mean the certificate is issued.  Use should
//      check for the *pdwCAStatus.  If the status is CRYPTUI_WIZ_CERT_REQUEST_STATUS_ISSUED_SEPERATELY
//      of   CRYPTUI_WIZ_CERT_REQUEST_STATUS_UNDER_SUBMISSION, *ppCertContext will be NULL.
//      It is valid only if *pdwCAStatus==CRYPTUI_WIZ_CERT_REQUEST_STATUS_SUCCEEDED
//
//  pdwCAStatus: Out Optional.
//      The return status of the certificate authority cerver.  The dwStatus can be one of
///     the following:
//         CRYPTUI_WIZ_CERT_REQUEST_STATUS_SUCCEEDED
//         CRYPTUI_WIZ_CERT_REQUEST_STATUS_REQUEST_ERROR
//         CRYPTUI_WIZ_CERT_REQUEST_STATUS_REQUEST_DENIED
//         CRYPTUI_WIZ_CERT_REQUEST_STATUS_ISSUED_SEPERATELY
//         CRYPTUI_WIZ_CERT_REQUEST_STATUS_UNDER_SUBMISSION
//------------------------------------------------------------------------
BOOL
WINAPI
CryptUIWizCertRequest(
 IN             DWORD                           dwFlags,
 IN OPTIONAL    HWND                            hwndParent,
 IN OPTIONAL    LPCWSTR                         pwszWizardTitle,
 IN             PCCRYPTUI_WIZ_CERT_REQUEST_INFO pCertRequestInfo,
 OUT OPTIONAL   PCCERT_CONTEXT                  *ppCertContext,
 OUT OPTIONAL   DWORD                           *pCAdwStatus
);


//-----------------------------------------------------------------------
//
//  CryptUIWizCreateCertRequestNoDS
//
//      Create a certificate request using the supplied parameters. 
//
//  dwFlags:  IN Required.  
//      CRYPTUI_WIZ_NO_UI:            must be set.  
//      CRYPTUI_WIZ_NO_INSTALL_ROOT:  if set, the issued certificate chain will not
//                                    be installed into the root store.  Instead, 
//                                    it will be installed in the CA store.
//  pCreateCertRequestInfo: IN Required
//      A pointer to CRYPTUI_WIZ_CREATE_CERT_REQUEST_INFO struct
//
//  phRequest: OUT Required. 
//      A HANDLE to the created request.  This HANDLE can be passed 
//      to CryptUIWizSubmitCertRequestNoDS(), and, of course, should not
//      be used for any other purpose.  
// 
//  Returns:  TRUE if successful, FALSE otherwise.  Get extended error information
//            using GetLastError(). 
// 
//------------------------------------------------------------------------
BOOL
WINAPI
CryptUIWizCreateCertRequestNoDS
(IN  DWORD                                   dwFlags, 
 IN  HWND                                    hwndParent, 
 IN  PCCRYPTUI_WIZ_CREATE_CERT_REQUEST_INFO  pCreateCertRequestInfo, 
 OUT HANDLE                                 *phRequest
);

//-----------------------------------------------------------------------
//
//  CryptUIWizSubmitCertRequestNoDS
//
//      Request a certificate using a request created by CryptUIWizCreateCertRequestNoDS(). 
//
//  hRequest: IN Required. 
//      A HANDLE to the request to submit.  Must have been created through
//      CryptUIWizCreateCertRequest(). 
//
//  ppCertContext: OUT Required. 
//      The issued certificate.  The certificate is in a memory store for remote enrollment.
//      The certificate is in a system cert store for local enrollment.
//
//      Even the function return TRUE, it does not mean the certificate is issued.  Use should
//      check for the *pdwCAStatus.  If the status is CRYPTUI_WIZ_CERT_REQUEST_STATUS_ISSUED_SEPERATELY
//      of   CRYPTUI_WIZ_CERT_REQUEST_STATUS_UNDER_SUBMISSION, *ppCertContext will be NULL.
//      It is valid only if *pdwCAStatus==CRYPTUI_WIZ_CERT_REQUEST_STATUS_SUCCEEDED
//
//  pdwCAStatus: Out Optional.
//      The return status of the certificate authority cerver.  The dwStatus can be one of
///     the following:
//         CRYPTUI_WIZ_CERT_REQUEST_STATUS_SUCCEEDED
//         CRYPTUI_WIZ_CERT_REQUEST_STATUS_REQUEST_ERROR
//         CRYPTUI_WIZ_CERT_REQUEST_STATUS_REQUEST_DENIED
//         CRYPTUI_WIZ_CERT_REQUEST_STATUS_ISSUED_SEPERATELY
//         CRYPTUI_WIZ_CERT_REQUEST_STATUS_UNDER_SUBMISSION
//
//  Returns:  TRUE if the procedure executed without an error, FALSE otherwise.  Check
//            pdwStatus to verify that the certificate was issued.  Get extended
//            error information using GetLastError(). 
// 
//------------------------------------------------------------------------
BOOL
WINAPI
CryptUIWizSubmitCertRequestNoDS
(IN HANDLE           hRequest, 
 IN HWND             hwndParent, 
 IN LPCWSTR          pwszCAName, 
 IN LPCWSTR          pwszCALocation, 
 OUT DWORD          *pdwStatus, 
 OUT PCCERT_CONTEXT *ppCertContext  // Optional
 );

//------------------------------------------------------------------------
//
//  CryptUIWizFreeCertRequestNoDS
//
//      Frees a certificate request created by CryptUIWizCreateCertRequestNoDS().
//
//  hRequest: IN Required. 
//      A HANDLE to the request to be freed.  
//
//------------------------------------------------------------------------
void
WINAPI
CryptUIWizFreeCertRequestNoDS
(IN HANDLE hRequest);

//------------------------------------------------------------------------
//
//  CryptUIWizQueryCertRequestNoDS
//
//      Queries status information about a created request. 
//
//  hRequest: IN Required. 
//      A HANDLE to the request to be freed.  
//
//------------------------------------------------------------------------
BOOL
WINAPI
CryptUIWizQueryCertRequestNoDS
(IN HANDLE hRequest, OUT CRYPTUI_WIZ_QUERY_CERT_REQUEST_INFO *pQueryInfo);

//-------------------------------------------------------------------------
//
//	Valid values for dwSubjectChoice in IMPORT_SUBJECT_INFO
//-------------------------------------------------------------------------
#define     CRYPTUI_WIZ_IMPORT_SUBJECT_FILE                 1
#define     CRYPTUI_WIZ_IMPORT_SUBJECT_CERT_CONTEXT         2
#define     CRYPTUI_WIZ_IMPORT_SUBJECT_CTL_CONTEXT          3
#define     CRYPTUI_WIZ_IMPORT_SUBJECT_CRL_CONTEXT          4
#define     CRYPTUI_WIZ_IMPORT_SUBJECT_CERT_STORE           5

//-------------------------------------------------------------------------
//
//	Struct to define the subject CertImportWizard
//
//  CRYPTUI_WIZ_IMPORT_SUBJECT_INFO
//
//-------------------------------------------------------------------------
typedef struct _CRYPTUI_WIZ_IMPORT_SUBJECT_INFO
{
	DWORD					dwSize;				//Required: should be set to sizeof(IMPORT_SUBJECT_INFO)
	DWORD					dwSubjectChoice;	//Required:	indicate the type of the subject:
                                                //          If can one of the following:
                                                //          CRYPTUI_WIZ_IMPORT_SUBJECT_FILE
                                                //          CRYPTUI_WIZ_IMPORT_SUBJECT_CERT_CONTEXT
                                                //          CRYPTUI_WIZ_IMPORT_SUBJECT_CTL_CONTEXT
                                                //          CRYPTUI_WIZ_IMPORT_SUBJECT_CRL_CONTEXT
                                                //          CRYPTUI_WIZ_IMPORT_SUBJECT_CERT_STORE
    union
	{
		LPCWSTR          	pwszFileName;	
        PCCERT_CONTEXT      pCertContext;
        PCCTL_CONTEXT       pCTLContext;
        PCCRL_CONTEXT       pCRLContext;
        HCERTSTORE          hCertStore;
    };

    DWORD                   dwFlags;            //Required if pwszFileName contains a PFX BLOB.
                                                //Ignored otherwise
                                                //This is the same flag for PFXImportCertStore
    LPCWSTR                 pwszPassword;       //Required if pwszFileName contains a PFX BLOB.
                                                //ignored otherwise
}CRYPTUI_WIZ_IMPORT_SRC_INFO, *PCRYPTUI_WIZ_IMPORT_SRC_INFO;

typedef const CRYPTUI_WIZ_IMPORT_SRC_INFO *PCCRYPTUI_WIZ_IMPORT_SRC_INFO;

//-----------------------------------------------------------------------
//
// Valid flags for dwFlags in CryptUIWizImport
//
//-----------------------------------------------------------------------
//if this flag is set in dwFlags, user will not be allowed to change
//the hDesCertStore in the wizard page
#define   CRYPTUI_WIZ_IMPORT_NO_CHANGE_DEST_STORE           0x00010000

//Allow importing certificate
#define   CRYPTUI_WIZ_IMPORT_ALLOW_CERT                     0x00020000

//Allow importing certificate revocation list
#define   CRYPTUI_WIZ_IMPORT_ALLOW_CRL                      0x00040000

//Allow importing certificate trust list
#define   CRYPTUI_WIZ_IMPORT_ALLOW_CTL                      0x00080000

//import contents to local machine (currently only applicable for PFX imports)
#define   CRYPTUI_WIZ_IMPORT_TO_LOCALMACHINE                0x00100000

//import contents to current user (currently only applicable for PFX imports)
#define   CRYPTUI_WIZ_IMPORT_TO_CURRENTUSER                 0x00200000

//if the hDesCertStore is a remote store handle, this flag should be set
#define   CRYPTUI_WIZ_IMPORT_REMOTE_DEST_STORE              0x00400000

//-----------------------------------------------------------------------
//
// CryptUIWizImport
//
//  The import wizard to import public key related files to a certificate
//  store
//
//  dwFlags can be set to any combination of the following flags:
//  CRYPTUI_WIZ_NO_UI                           No UI will be shown.  Otherwise, User will be
//                                              prompted by a wizard.
//  CRYPTUI_WIZ_IMPORT_ALLOW_CERT               Allow importing certificate
//  CRYPTUI_WIZ_IMPORT_ALLOW_CRL                Allow importing CRL(certificate revocation list)
//  CRYPTUI_WIZ_IMPORT_ALLOW_CTL                Allow importing CTL(certificate trust list)
//  CRYPTUI_WIZ_IMPORT_NO_CHANGE_DEST_STORE     user will not be allowed to change
//                                              the hDesCertStore in the wizard page
//  CRYPTUI_WIZ_IMPORT_TO_LOCALMACHINE          the contents should be imported to local machine
//                                              (currently only applicable for PFX imports)
//  CRYPTUI_WIZ_IMPORT_TO_CURRENTUSER           the contents should be imported to current user
//                                              (currently only applicable for PFX imports)
//
//  Please notice that if neither of following three flags is in dwFlags, default to is
//  allow everything.
//  CRYPTUI_WIZ_IMPORT_ALLOW_CERT
//  CRYPTUI_WIZ_IMPORT_ALLOW_CRL
//  CRYPTUI_WIZ_IMPORT_ALLOW_CTL
//
//  Also, note that the CRYPTUI_WIZ_IMPORT_TO_LOCALMACHINE and CRYPTUI_WIZ_IMPORT_TO_CURRENTUSER
//  flags are used force the content of a pfx blob into either local machine or current user.
//  If neither of these flags are used and hDesCertStore is NULL then:
//  1) The private key in the pfx blob will be forced to be imported into current user.
//  2) If CRYPTUI_WIZ_NO_UI is NOT set, the wizard will prompt the user to select a certificate
//     store from the current user stores.
//
//
//
//  If CRYPTUI_WIZ_NO_UI is set in dwFlags:
//      hwndParent:         Ignored
//      pwszWizardTitle:    Ignored
//      pImportSubject:     IN Required:    The subject to import.
//      hDesCertStore:      IN Optional:    The destination certficate store
//
//  If CRYPTUI_WIZ_NO_UI is not set in dwFlags:
//      hwndPrarent:        IN Optional:    The parent window for the wizard
//      pwszWizardTitle:    IN Optional:    The title of the wizard
//                                          If NULL, the default will be IDS_IMPORT_WIZARD_TITLE
//      pImportSubject:     IN Optional:    The file name to import.
//                                          If NULL, the wizard will prompt user to enter the file name
//      hDesCertStore:      IN Optional:    The destination certificate store where the file wil be
//                                          imported to.  The store should be opened with
//                                          flag CERT_STORE_SET_LOCALIZED_NAME_FLAG.  If NULL, the wizard will prompt user to select
//                                          a certificate store.
//------------------------------------------------------------------------
BOOL
WINAPI
CryptUIWizImport(
     DWORD                               dwFlags,
     HWND                                hwndParent,
     LPCWSTR                             pwszWizardTitle,
     PCCRYPTUI_WIZ_IMPORT_SRC_INFO       pImportSrc,
     HCERTSTORE                          hDestCertStore
);


//-------------------------------------------------------------------------
//
//	Struct to define the information needed to build a new CTL
//
//  CRYPTUI_WIZ_BUILDCTL_NEW_CTL_INFO
//
//
//-------------------------------------------------------------------------
typedef struct _CRYPTUI_WIZ_BUILDCTL_NEW_CTL_INFO
{
	DWORD			    dwSize;				    //Required: should be set to sizeof(CRYPTUI_WIZ_BUILDCTL_NEW_CTL)
    PCERT_ENHKEY_USAGE  pSubjectUsage;          //Optioanl: The purpose of the CTL
    LPWSTR              pwszListIdentifier;     //Optional: The string to identify the CTL
    LPCSTR              pszSubjectAlgorithm;    //Optional: The hashing algorithm.
                                                //          Currently, only SHA1 or MD5 hashing is supported
    HCERTSTORE          hCertStore;             //Optional: The certificate in the CTL.  Only the certificates
                                                //          with the enhanced key usage specified by pSubjectUsage
                                                //          will be included in the CTL
    FILETIME            NextUpdate;             //Optional: The next update time of the CTL.  If the value
                                                //          is more than 99 month from the current system time,
                                                //          the value will be ignored.
    LPWSTR              pwszFriendlyName;       //Optional: The friendly name of the CTL
    LPWSTR              pwszDescription;        //Optional: The description of the CTL
}CRYPTUI_WIZ_BUILDCTL_NEW_CTL_INFO, *PCRYPTUI_WIZ_BUILDCTL_NEW_CTL_INFO;

typedef const CRYPTUI_WIZ_BUILDCTL_NEW_CTL_INFO *PCCRYPTUI_WIZ_BUILDCTL_NEW_CTL_INFO;

//-------------------------------------------------------------------------
//
//	Valid values for dwSourceChoice for CRYPTUI_WIZ_BUILDCTL_SRC_INFO
//-------------------------------------------------------------------------
#define         CRYPTUI_WIZ_BUILDCTL_SRC_EXISTING_CTL       1
#define         CRYPTUI_WIZ_BUILDCTL_SRC_NEW_CTL            2

//-------------------------------------------------------------------------
//
//	Struct to define the source of certBuildCTL wizard
//
//  CRYPTUI_WIZ_BUILDCTL_SRC_INFO
//
//
//-------------------------------------------------------------------------
typedef struct _CRYPTUI_WIZ_BUILDCTL_SRC_INFO
{
	DWORD			dwSize;				//Required: should be set to sizeof(CRYPTUI_WIZ_BUILDCTL_SRC_INFO)
    DWORD           dwSourceChoice;     //Required: indicate the source from which to build the CTL
                                        //          if can be one of the following:
                                        //          CRYPTUI_WIZ_BUILDCTL_SRC_EXISTING_CTL
                                        //          CRYPTUI_WIZ_BUILDCTL_SRC_NEW_CTL
    union
    {
        PCCTL_CONTEXT                       pCTLContext;    //Required if dwSourceChoice == CRYPTUI_WIZ_BUILDCTL_SRC_EXISTING_CTL
                                                            //          An existing CTL based on which a new CTL is to be built
        PCCRYPTUI_WIZ_BUILDCTL_NEW_CTL_INFO pNewCTLInfo;        //Required if dwSourceChoise == CRYPTUI_WIZ_BUILDCTL_SRC_NEW_CTL
    };
}CRYPTUI_WIZ_BUILDCTL_SRC_INFO, *PCRYPTUI_WIZ_BUILDCTL_SRC_INFO;

typedef const CRYPTUI_WIZ_BUILDCTL_SRC_INFO *PCCRYPTUI_WIZ_BUILDCTL_SRC_INFO;

//-------------------------------------------------------------------------
//
//	Valid values for dwDestinationChoice for CRYPTUI_WIZ_BUILDCTL_DEST_INFO
//-------------------------------------------------------------------------
#define         CRYPTUI_WIZ_BUILDCTL_DEST_CERT_STORE     1
#define         CRYPTUI_WIZ_BUILDCTL_DEST_FILE           2
//-------------------------------------------------------------------------
//
//	Struct to define the desination of certBuildCTL wizard
//
//  CRYPTUI_WIZ_BUILDCTL_DEST_INFO
//
//
//-------------------------------------------------------------------------
typedef struct _CRYPTUI_WIZ_BUILDCTL_DEST_INFO
{
	DWORD					dwSize;				 //Required: should be set to sizeof(CRYPTUI_WIZ_BUILDCTL_DEST_INFO)
	DWORD					dwDestinationChoice; //Required:	indicate the type of the desination:
                                                 //          If can one of the following:
                                                 //          CRYPTUI_WIZ_BUILDCTL_DEST_CERT_STORE
                                                 //          CRYPTUI_WIZ_BUILDCTL_DEST_FILE
    union
	{
		LPCWSTR          	pwszFileName;	
        HCERTSTORE          hCertStore;
    };

}CRYPTUI_WIZ_BUILDCTL_DEST_INFO, *PCRYPTUI_WIZ_BUILDCTL_DEST_INFO;

typedef const CRYPTUI_WIZ_BUILDCTL_DEST_INFO *PCCRYPTUI_WIZ_BUILDCTL_DEST_INFO;

//-----------------------------------------------------------------------
//
// CryptUIWizBuildCTL
//
//  Build a new CTL or modify an existing CTL.   The UI for wizard will
//  always show in this case
//
//
//  dwFlags:            IN  Optional:   Can be set to the any combination of the following:
//                                      CRYPTUI_WIZ_BUILDCTL_SKIP_DESTINATION.
//                                      CRYPTUI_WIZ_BUILDCTL_SKIP_SIGNING
//                                      CRYPTUI_WIZ_BUILDCTL_SKIP_PURPOSE
//  hwndParnet:         IN  Optional:   The parent window handle
//  pwszWizardTitle:    IN  Optional:   The title of the wizard
//                                      If NULL, the default will be IDS_BUILDCTL_WIZARD_TITLE
//  pBuildCTLSrc:       IN  Optional:   The source from which the CTL will be built
//  pBuildCTLDest:      IN  Optional:   The desination where the newly
//                                      built CTL will be stored
//  ppCTLContext:       OUT Optaionl:   The newly build CTL
//
//------------------------------------------------------------------------
BOOL
WINAPI
CryptUIWizBuildCTL(
    IN              DWORD                                   dwFlags,
    IN  OPTIONAL    HWND                                    hwndParent,
    IN  OPTIONAL    LPCWSTR                                 pwszWizardTitle,
    IN  OPTIONAL    PCCRYPTUI_WIZ_BUILDCTL_SRC_INFO         pBuildCTLSrc,
    IN  OPTIONAL    PCCRYPTUI_WIZ_BUILDCTL_DEST_INFO        pBuildCTLDest,
    OUT OPTIONAL    PCCTL_CONTEXT                           *ppCTLContext
);


//-------------------------------------------------------------------------
//
//	Valid values for dwSubjectChoice in CRYPTUI_WIZ_EXPORT_INFO
//-------------------------------------------------------------------------
#define     CRYPTUI_WIZ_EXPORT_CERT_CONTEXT 			        1
#define     CRYPTUI_WIZ_EXPORT_CTL_CONTEXT  			        2
#define     CRYPTUI_WIZ_EXPORT_CRL_CONTEXT  			        3
#define     CRYPTUI_WIZ_EXPORT_CERT_STORE   			        4
#define     CRYPTUI_WIZ_EXPORT_CERT_STORE_CERTIFICATES_ONLY   	5

//-------------------------------------------------------------------------
//
//	Struct to define the object to be exported and where to export it to
//
//  CRYPTUI_WIZ_EXPORT_SUBJECT_INFO
//
//-------------------------------------------------------------------------
typedef struct _CRYPTUI_WIZ_EXPORT_INFO
{
	DWORD					dwSize;				//Required: should be set to sizeof(CRYPTUI_WIZ_EXPORT_INFO)
    LPCWSTR                 pwszExportFileName; //Required if the CRYPTUI_WIZ_NO_UI flag is set, Optional otherwise.
                                                //The fully qualified file name to export to, if this is
                                                //non-NULL and the CRYPTUI_WIZ_NO_UI flag is NOT set, then it is
                                                //displayed to the user as the default file name
	DWORD					dwSubjectChoice;	//Required:	indicate the type of the subject:
                                                //          If can one of the following:
                                                //          CRYPTUI_WIZ_EXPORT_CERT_CONTEXT
                                                //          CRYPTUI_WIZ_EXPORT_CTL_CONTEXT
                                                //          CRYPTUI_WIZ_EXPORT_CRL_CONTEXT
                                                //          CRYPTUI_WIZ_EXPORT_CERT_STORE
						                        //	        CRYPTUI_WIZ_EXPORT_CERT_STORE_CERTIFICATES_ONLY
    union
	{
	PCCERT_CONTEXT      pCertContext;
        PCCTL_CONTEXT       pCTLContext;
        PCCRL_CONTEXT       pCRLContext;
        HCERTSTORE          hCertStore;
    };

    DWORD                   cStores;            // Optional: count of extra stores to search for the certs in the
                                                //           trust chain if the chain is being exported with a cert.
                                                //           this is ignored if dwSubjectChoice is anything other
                                                //           than CRYPTUI_WIZ_EXPORT_CERT_CONTEXT
    HCERTSTORE *            rghStores;          // Optional: array of extra stores to search for the certs in the
                                                //           trust chain if the chain is being exported with a cert.
                                                //           this is ignored if dwSubjectChoice is anything other
                                                //           than CRYPTUI_WIZ_EXPORT_CERT_CONTEXT

}CRYPTUI_WIZ_EXPORT_INFO, *PCRYPTUI_WIZ_EXPORT_INFO;

typedef const CRYPTUI_WIZ_EXPORT_INFO *PCCRYPTUI_WIZ_EXPORT_INFO;


//-------------------------------------------------------------------------
//
//	Valid values for dwExportFormat in CRYPTUI_WIZ_EXPORT_CERTCONTEXT_INFO
//-------------------------------------------------------------------------
#define     CRYPTUI_WIZ_EXPORT_FORMAT_DER                   1
#define     CRYPTUI_WIZ_EXPORT_FORMAT_PFX                   2
#define     CRYPTUI_WIZ_EXPORT_FORMAT_PKCS7                 3
#define     CRYPTUI_WIZ_EXPORT_FORMAT_BASE64                4
#define     CRYPTUI_WIZ_EXPORT_FORMAT_SERIALIZED_CERT_STORE 5   // NOTE: not currently supported!!

//-------------------------------------------------------------------------
//
//	Struct to define the information needed to export a CERT_CONTEXT
//
//  CRYPTUI_WIZ_EXPORT_NOUI_INFO
//
//-------------------------------------------------------------------------
typedef struct _CRYPTUI_WIZ_EXPORT_CERTCONTEXT_INFO
{
	DWORD					dwSize;				//Required: should be set to sizeof(CRYPTUI_WIZ_EXPORT_NOUI_INFO)
	DWORD					dwExportFormat;	    //Required:
                                                //          It can be one of the following:
                                                //          CRYPTUI_WIZ_EXPORT_FORMAT_DER
                                                //          CRYPTUI_WIZ_EXPORT_FORMAT_PFX
                                                //          CRYPTUI_WIZ_EXPORT_FORMAT_PKCS7
                                                //          CRYPTUI_WIZ_EXPORT_FORMAT_SERIALIZED_CERT_STORE

    BOOL                    fExportChain;       //Required
    BOOL                    fExportPrivateKeys; //Required
    LPCWSTR                 pwszPassword;       //Required if the fExportPrivateKeys boolean is TRUE, otherwise,
                                                //it is ignored
    BOOL                    fStrongEncryption;  //Required if dwExportFormat is CRYPTUI_WIZ_EXPORT_FORMAT_PFX
                                                //Note that if this flag is TRUE then the PFX blob produced is
                                                //NOT compatible with IE4.

}CRYPTUI_WIZ_EXPORT_CERTCONTEXT_INFO, *PCRYPTUI_WIZ_EXPORT_CERTCONTEXT_INFO;

typedef const CRYPTUI_WIZ_EXPORT_CERTCONTEXT_INFO *PCCRYPTUI_WIZ_EXPORT_CERTCONTEXT_INFO;

//-----------------------------------------------------------------------
//
// CryptUIWizExport
//
//  The export wizard to export public key related objects to a file
//
//  If dwFlags is set to CRYPTUI_WIZ_NO_UI, no UI will be shown.  Otherwise,
//  User will be prompted for input through a wizard.
//
//  If CRYPTUI_WIZ_NO_UI is set in dwFlags:
//      hwndParent:         Ignored
//      pwszWizardTitle:    Ignored
//      pExportInfo:        IN Required:    The subject to export.
//      pvoid:              IN Required:    Contains information about how to do the export based on what
//                                          is being exported
//
//                                          dwSubjectChoice                     INPUT TYPE
//                                          -------------------------------------------------------------------------
//                                          CRYPTUI_WIZ_EXPORT_CERT_CONTEXT     PCCRYPTUI_WIZ_EXPORT_CERTCONTEXT_INFO
//                                          CRYPTUI_WIZ_EXPORT_CTL_CONTEXT      NULL
//                                          CRYPTUI_WIZ_EXPORT_CRL_CONTEXT      NULL
//                                          CRYPTUI_WIZ_EXPORT_CERT_STORE       NULL
//
//  If CRYPTUI_WIZ_NO_UI is not set in dwFlags:
//      hwndPrarent:        IN Optional:    The parent window for the wizard
//      pwszWizardTitle:    IN Optional:    The title of the wizard
//                                          If NULL, the default will be IDS_EXPORT_WIZARD_TITLE
//      pExportInfo:        IN Required:    The subject to export.
//      pvoid:              IN Optional:    Contains information about how to do the export based on what
//                                          is being exported.  See above table for values, if this is non-NULL
//                                          the values are displayed to the user as the default choices.
//------------------------------------------------------------------------
BOOL
WINAPI
CryptUIWizExport(
     DWORD                                  dwFlags,
     HWND                                   hwndParent,
     LPCWSTR                                pwszWizardTitle,
     PCCRYPTUI_WIZ_EXPORT_INFO              pExportInfo,
     void                                   *pvoid
);


#if (0) //DSIE: 7/02/2002 moved to CryptUIAPI.h per consent degree.
//-------------------------------------------------------------------------
//valid values for dwSubjectChoice in CRYPTUI_WIZ_DIGITAL_SIGN_INFO struct
//-------------------------------------------------------------------------
#define CRYPTUI_WIZ_DIGITAL_SIGN_SUBJECT_FILE           0x01
#define CRYPTUI_WIZ_DIGITAL_SIGN_SUBJECT_BLOB           0x02


//-------------------------------------------------------------------------
//valid values for dwSigningCertChoice in CRYPTUI_WIZ_DIGITAL_SIGN_INFO struct
//-------------------------------------------------------------------------
#define CRYPTUI_WIZ_DIGITAL_SIGN_CERT                   0x01
#define CRYPTUI_WIZ_DIGITAL_SIGN_STORE                  0x02
#define CRYPTUI_WIZ_DIGITAL_SIGN_PVK                    0x03

//-------------------------------------------------------------------------
//valid values for dwAddtionalCertChoice in CRYPTUI_WIZ_DIGITAL_SIGN_INFO struct
//-------------------------------------------------------------------------
//include the entire certificate trust chain in the signature
#define CRYPTUI_WIZ_DIGITAL_SIGN_ADD_CHAIN               0x00000001

//include the entilre certificate trust chain, with the exception of the root
//certificate, in the signature
#define CRYPTUI_WIZ_DIGITAL_SIGN_ADD_CHAIN_NO_ROOT       0x00000002

//-------------------------------------------------------------------------
//
//	CRYPTUI_WIZ_DIGITAL_SIGN_BLOB_INFO
//
//  dwSize			IN Required: should be set to sizeof(CRYPTUI_WIZ_DIGITAL_SIGN_BLOB_INFO)
//  pGuidSubject    IN Required: Idenfity the sip functions to load
//  cbBlob			IN Required: the size of BLOB, in bytes
//  pbBlob		    IN Required: the pointer to the BLOB
//  pwszDispalyName IN Optional: the display name of the BLOB to sign.
//-------------------------------------------------------------------------
typedef struct _CRYPTUI_WIZ_DIGITAL_SIGN_BLOB_INFO
{
    DWORD               dwSize;			
    GUID                *pGuidSubject;
    DWORD               cbBlob;				
    BYTE                *pbBlob;			
    LPCWSTR             pwszDisplayName;
}CRYPTUI_WIZ_DIGITAL_SIGN_BLOB_INFO, *PCRYPTUI_WIZ_DIGITAL_SIGN_BLOB_INFO;

typedef const CRYPTUI_WIZ_DIGITAL_SIGN_BLOB_INFO *PCCRYPTUI_WIZ_DIGITAL_SIGN_BLOB_INFO;

//-------------------------------------------------------------------------
//
//	CRYPTUI_WIZ_DIGITAL_SIGN_STORE_INFO
//
//	dwSize				IN Required: should be set to sizeof(CRYPTUI_WIZ_DIGITAL_SIGN_STORE_INFO)
//  cCertStore          IN Required: The acount of certificate store array that includes potentical sining certs
//  rghCertStore        IN Required: The certificate store array that includes potential signing certs
//  pFilterCallback     IN Optional: The filter call back function for display the certificate
//  pvCallbackData      IN Optional: The call back data
//-------------------------------------------------------------------------
typedef struct _CRYPTUI_WIZ_DIGITAL_SIGN_STORE_INFO
{
	DWORD               dwSize;	
	DWORD               cCertStore;			
    HCERTSTORE          *rghCertStore;
    PFNCFILTERPROC      pFilterCallback;
    void *              pvCallbackData;
}CRYPTUI_WIZ_DIGITAL_SIGN_STORE_INFO, *PCRYPTUI_WIZ_DIGITAL_SIGN_STORE_INFO;

typedef const CRYPTUI_WIZ_DIGITAL_SIGN_STORE_INFO *PCCRYPTUI_WIZ_DIGITAL_SIGN_STORE_INFO;

//-------------------------------------------------------------------------
//
//	CRYPTUI_WIZ_DIGITAL_SIGN_PVK_FILE_INFO
//
//	dwSize				        IN Required: should be set to sizeof(CRYPT_WIZ_DIGITAL_SIGN_PVK_FILE_INFO)
//  pwszPvkFileName             IN Required: the PVK file name
//  pwszProvName                IN Required: the provider name
//  dwProvType                  IN Required: the provider type
//
//-------------------------------------------------------------------------
typedef struct _CRYPTUI_WIZ_DIGITAL_SIGN_PVK_FILE_INFO
{
	DWORD                   dwSize;
    LPWSTR                  pwszPvkFileName;
    LPWSTR                  pwszProvName;
    DWORD                   dwProvType;
}CRYPTUI_WIZ_DIGITAL_SIGN_PVK_FILE_INFO, *PCRYPTUI_WIZ_DIGITAL_SIGN_PVK_FILE_INFO;

typedef const CRYPTUI_WIZ_DIGITAL_SIGN_PVK_FILE_INFO *PCCRYPTUI_WIZ_DIGITAL_SIGN_PVK_FILE_INFO;

//-------------------------------------------------------------------------
//
// valid values for dwPvkChoice in CRYPTUI_WIZ_DIGITAL_SIGN_CERT_PVK_INFO struct
//-------------------------------------------------------------------------
#define CRYPTUI_WIZ_DIGITAL_SIGN_PVK_FILE        0x01
#define CRYPTUI_WIZ_DIGITAL_SIGN_PVK_PROV        0x02


//-------------------------------------------------------------------------
//
//	CRYPTUI_WIZ_DIGITAL_SIGN_CERT_PVK_INFO
//
//	dwSize				        IN Required: should be set to sizeof(CRYPTUI_WIZ_DIGITAL_SIGN_STORE_INFO)
//  pwszSigningCertFileName     IN Required: the file name that contains the signing cert(s)
//  dwPvkChoice                 IN Required: Indicate the private key type:
//                                           It can be one of the following:
//                                           CRYPTUI_WIZ_DIGITAL_SIGN_PVK_FILE
//                                           CRYPTUI_WIZ_DIGITAL_SIGN_PVK_PROV
//  pPvkFileInfo                IN Required if dwPvkChoice == CRYPTUI_WIZ_DIGITAL_SIGN_PVK_FILE
//  pPvkProvInfo                IN Required if dwPvkContainer== CRYPTUI_WIZ_DIGITAL_SIGN_PVK_PROV
//
//-------------------------------------------------------------------------
typedef struct _CRYPTUI_WIZ_DIGITAL_SIGN_CERT_PVK_INFO
{
	DWORD                   dwSize;
    LPWSTR                  pwszSigningCertFileName;
    DWORD					dwPvkChoice;		
    union
	{
        PCCRYPTUI_WIZ_DIGITAL_SIGN_PVK_FILE_INFO      pPvkFileInfo;
        PCRYPT_KEY_PROV_INFO                        pPvkProvInfo;
    };

}CRYPTUI_WIZ_DIGITAL_SIGN_CERT_PVK_INFO, *PCRYPTUI_WIZ_DIGITAL_SIGN_CERT_PVK_INFO;

typedef const CRYPTUI_WIZ_DIGITAL_SIGN_CERT_PVK_INFO *PCCRYPTUI_WIZ_DIGITAL_SIGN_CERT_PVK_INFO;

//-------------------------------------------------------------------------
//
// valid values for dwAttrFlags in CRYPTUI_WIZ_DIGITAL_SIGN_EXTENDED_INFO struct
//-------------------------------------------------------------------------
#define     CRYPTUI_WIZ_DIGITAL_SIGN_COMMERCIAL         0x0001
#define     CRYPTUI_WIZ_DIGITAL_SIGN_INDIVIDUAL         0x0002

//-------------------------------------------------------------------------
//
//	CRYPTUI_WIZ_DIGITAL_SIGN_EXTENDED_INFO
//
//   dwSize			        IN Required:  should be set to sizeof(CRYPTUI_WIZ_DIGITAL_SIGN_EXTENDED_INFO)
//   dwAttrFlags            IN Required:  Flag to indicate signing options.
//                                        It can be one of the following:
//                                          CRYPTUI_WIZ_DIGITAL_SIGN_COMMERCIAL
//                                          CRYPTUI_WIZ_DIGITAL_SIGN_INDIVIDUAL
//   pwszDescription        IN Optional:  The description of the signing subject
//   pwszMoreInfoLocation   IN Optional:  the localtion to get more information about file
//                                        this information will be shown upon download time
//   pszHashAlg             IN Optional:  the hashing algorithm for the signature
//                                        NULL means using SHA1 hashing algorithm
//   pwszSigningCertDisplayString  IN Optional: The display string to be displayed on the
//                                        signing certificate wizard page.  The string should
//                                        prompt user to select a certificate for a particular purpose
//   hAddtionalCertStores  IN Optional:   the addtional cert store to add to the signature
//   psAuthenticated	    IN Optional:  user supplied authenticated attributes added to the signature
//   psUnauthenticated	    IN Optional:  user supplied unauthenticated attributes added to the signature
//
//-------------------------------------------------------------------------
typedef struct _CRYPTUI_WIZ_DIGITAL_SIGN_EXTENDED_INFO
{
	DWORD		            dwSize;			
    DWORD                   dwAttrFlags;
    LPCWSTR                 pwszDescription;
	LPCWSTR				    pwszMoreInfoLocation;		
    LPCSTR                  pszHashAlg;
    LPCWSTR                 pwszSigningCertDisplayString;
    HCERTSTORE              hAdditionalCertStore;
	PCRYPT_ATTRIBUTES		psAuthenticated;	
	PCRYPT_ATTRIBUTES		psUnauthenticated;	
}CRYPTUI_WIZ_DIGITAL_SIGN_EXTENDED_INFO, *PCRYPTUI_WIZ_DIGITAL_SIGN_EXTENDED_INFO;

typedef const CRYPTUI_WIZ_DIGITAL_SIGN_EXTENDED_INFO *PCCRYPTUI_WIZ_DIGITAL_SIGN_EXTENDED_INFO;
//-------------------------------------------------------------------------
//
//
//  CRYPTUI_WIZ_DIGITAL_SIGN_INFO
//
// dwSize			    IN Required: Has to be set to sizeof(CRYPTUI_WIZ_DIGITAL_SIGN_INFO)
// dwSubjectChoice	    IN Required if CRYPTUI_WIZ_NO_UI is set in dwFlags of the CryptUIWizDigitalSigning,         :
//                         Optional if CRYPTUI_WIZ_NO_UI is not set in dwFlags of the CryptUIWizDigitalSigning
//                                  Indicate whether to sign a file or to sign a memory BLOB.
//                                  0 means promting user for the file to sign
//                                  It can be one of the following:
//                                  CRYPTUI_WIZ_DIGITAL_SIGN_SUBJECT_FILE
//			                        CRYPTUI_WIZ_DIGITAL_SIGN_SUBJECT_BLOB
//
//
//pwszFileName	        IN Required if dwSubjectChoice==CRYPTUI_WIZ_DIGITAL_SIGN_SUBJECT_FILE
//pSignBlobInfo	        IN Required if dwSubhectChoice==CRYPTUI_WIZ_DIGITAL_SIGN_SUBJECT_BLOB
//
//dwSigningCertChoice   IN Optional: Indicate the signing certificate.
//                                  0 means using the certificates in "My" store"
//                                  It can be one of the following choices:
//                                  CRYPTUI_WIZ_DIGITAL_SIGN_CERT
//                                  CRYPTUI_WIZ_DIGITAL_SIGN_STORE
//                                  CRYPTUI_WIZ_DIGITAL_SIGN_PVK
//                                  If CRYPTUI_WIZ_NO_UI is set in dwFlags of the CryptUIWizDigitalSigning,
//                                  dwSigningCertChoice has to be CRYPTUI_WIZ_DIGITAL_SIGN_CERT or
//                                  CRYPTUI_WIZ_DIGITAL_SIGN_PVK
//
//pSigningCertContext       IN Required if dwSigningCertChoice==CRYPTUI_WIZ_DIGITAL_SIGN_CERT
//pSigningCertStore         IN Required if dwSigningCertChoice==CRYPTUI_WIZ_DIGITAL_SIGN_STORE
//pSigningCertPvkInfo       IN Required if dwSigningCertChoise==CRYPTUI_WIZ_DIGITAL_SIGN_PVK
//
//pwszTimestampURL      IN Optional: The timestamp URL address
//
//dwAdditionalCertChoice IN Optional: Indicate additional certificates to be included in the signature.                                                       //
//                                  0 means no addtional certificates will be added
//                                  The following flags are mutually exclusive.
//                                  Only one of them can be set:
//                                  CRYPTUI_WIZ_DIGITAL_SIGN_ADD_CHAIN
//                                  CRYPTUI_WIZ_DIGITAL_SIGN_ADD_CHAIN_NO_ROOT
//
//
//pSignExtInfo         IN Optional: The extended information for signing
//
//-------------------------------------------------------------------------
typedef struct _CRYPTUI_WIZ_DIGITAL_SIGN_INFO
{
	DWORD			                            dwSize;			
	DWORD					                    dwSubjectChoice;	
	union
	{
		LPCWSTR                                 pwszFileName;	
		PCCRYPTUI_WIZ_DIGITAL_SIGN_BLOB_INFO    pSignBlobInfo;	
	};

    DWORD                                       dwSigningCertChoice;
    union
    {
        PCCERT_CONTEXT                              pSigningCertContext;
        PCCRYPTUI_WIZ_DIGITAL_SIGN_STORE_INFO       pSigningCertStore;
        PCCRYPTUI_WIZ_DIGITAL_SIGN_CERT_PVK_INFO    pSigningCertPvkInfo;
    };

    LPCWSTR                                     pwszTimestampURL;
    DWORD                                       dwAdditionalCertChoice;
    PCCRYPTUI_WIZ_DIGITAL_SIGN_EXTENDED_INFO    pSignExtInfo;

}CRYPTUI_WIZ_DIGITAL_SIGN_INFO, *PCRYPTUI_WIZ_DIGITAL_SIGN_INFO;

typedef const CRYPTUI_WIZ_DIGITAL_SIGN_INFO *PCCRYPTUI_WIZ_DIGITAL_SIGN_INFO;

//-------------------------------------------------------------------------
//
//	CRYPTUI_WIZ_DIGITAL_SIGN_CONTEXT
//
//  dwSize			 set to sizeof(CRYPTUI_WIZ_DIGITAL_SIGN_CONTEXT)
//  cbBlob			 the size of pbBlob.  In bytes
//  pbBlob		     the signed BLOB
//-------------------------------------------------------------------------
typedef struct _CRYPTUI_WIZ_DIGITAL_SIGN_CONTEXT
{
    DWORD               dwSize;			
    DWORD               cbBlob;				
    BYTE                *pbBlob;			
}CRYPTUI_WIZ_DIGITAL_SIGN_CONTEXT, *PCRYPTUI_WIZ_DIGITAL_SIGN_CONTEXT;

typedef const CRYPTUI_WIZ_DIGITAL_SIGN_CONTEXT *PCCRYPTUI_WIZ_DIGITAL_SIGN_CONTEXT;

//-----------------------------------------------------------------------
//
// CryptUIWizDigitalSign
//
//  The wizard to digitally sign a document or a BLOB.
//
//  If CRYPTUI_WIZ_NO_UI is set in dwFlags, no UI will be shown.  Otherwise,
//  User will be prompted for input through a wizard.
//
//  dwFlags:            IN  Required:
//  hwndParnet:         IN  Optional:   The parent window handle
//  pwszWizardTitle:    IN  Optional:   The title of the wizard
//                                      If NULL, the default will be IDS_DIGITAL_SIGN_WIZARD_TITLE
//  pDigitalSignInfo:   IN  Required:   The information about the signing process
//  ppSignContext       OUT Optional:   The context pointer points to the signed BLOB
//------------------------------------------------------------------------
BOOL
WINAPI
CryptUIWizDigitalSign(
     IN                 DWORD                               dwFlags,
     IN     OPTIONAL    HWND                                hwndParent,
     IN     OPTIONAL    LPCWSTR                             pwszWizardTitle,
     IN                 PCCRYPTUI_WIZ_DIGITAL_SIGN_INFO     pDigitalSignInfo,
     OUT    OPTIONAL    PCCRYPTUI_WIZ_DIGITAL_SIGN_CONTEXT  *ppSignContext);


BOOL
WINAPI
CryptUIWizFreeDigitalSignContext(
     IN  PCCRYPTUI_WIZ_DIGITAL_SIGN_CONTEXT   pSignContext);
#endif


//-------------------------------------------------------------------------
//valid values for dwPageChoice in CRYPTUI_WIZ_SIGN_GET_PAGE_INFO
//-------------------------------------------------------------------------

#define     CRYPTUI_WIZ_DIGITAL_SIGN_TYPICAL_SIGNING_OPTION_PAGES       0x0001
#define     CRYPTUI_WIZ_DIGITAL_SIGN_MINIMAL_SIGNING_OPTION_PAGES       0x0002
#define     CRYPTUI_WIZ_DIGITAL_SIGN_CUSTOM_SIGNING_OPTION_PAGES        0x0004
#define     CRYPTUI_WIZ_DIGITAL_SIGN_ALL_SIGNING_OPTION_PAGES           0x0008

#define     CRYPTUI_WIZ_DIGITAL_SIGN_WELCOME_PAGE                       0x0100
#define     CRYPTUI_WIZ_DIGITAL_SIGN_FILE_NAME_PAGE                     0x0200
#define     CRYPTUI_WIZ_DIGITAL_SIGN_CONFIRMATION_PAGE                  0x0400


//-------------------------------------------------------------------------
//
//	CRYPTUI_WIZ_SIGN_GET_PAGE_INFO
//
//	dwSize				IN Required:    should be set to sizeof(CRYPTUI_WIZ_SIGN_GET_PAGE_INFO)
//  dwPageChoice:       IN Required:    It should one of the following:
//                                          CRYPTUI_WIZ_DIGITAL_SIGN_ALL_SIGNING_OPTION_PAGES
//                                          CRYPTUI_WIZ_DIGITAL_SIGN_TYPICAL_SIGNING_OPTION_PAGES
//                                          CRYPTUI_WIZ_DIGITAL_SIGN_MINIMAL_SIGNING_OPTION_PAGES
//                                          CRYPTUI_WIZ_DIGITAL_SIGN_CUSTOM_SIGNING_OPTION_PAGES
//                                      It can also be ORed with any of the following:
//                                          CRYPTUI_WIZ_DIGITAL_SIGN_WELCOME_PAGE
//                                          CRYPTUI_WIZ_DIGITAL_SIGN_CONFIRMATION_PAGE
//                                          CRYPTUI_WIZ_DIGITAL_SIGN_FILE_NAME_PAGE
//                                      If user tries to sign a BLOB, CRYPTUI_WIZ_DIGITAL_SIGN_FILE_NAME_PAGE
//                                      should not be set
//  dwFlags;            IN Optional:    Flags and has to be set to 0
//  hwndParent          IN Optional:    The parent window of the dialogue
//  pwszPageTitle       IN Optional:    The title for the pages and the message boxes.
//  pDigitalSignInfo    IN Optional:    the addtional information for signing
//  pPropPageCallback   IN Optional:    this callback will be called when each page that is
//                                      returned in the CryptUIGetViewSignaturesPages call
//                                      is about to be created or destroyed.  if this is NULL no
//                                      callback is made.
//  pvCallbackData      IN Optional:    this is uniterpreted data that is passed back when the
//                                      when pPropPageCallback is made
//  fResult             OUT:            The result of signing
//  dwError             OUT:            The value of GetLastError() if fResult is FALSE
//  pSignContext        OUT:            The context pointer to the signed BLOB.  User needs to free
//                                      the blob by CryptUIWizDigitalSignFreeContext
//  dwReserved          Reserved:       The private data used by the signing process.
//                                      must be set to NULL
//  pvSignReserved      Reserved:       The private data used by the signing process
//                                      must be set to NULL
//-------------------------------------------------------------------------
typedef struct _CRYPTUI_WIZ_GET_SIGN_PAGE_INFO
{
	DWORD				                dwSize;	
    DWORD                               dwPageChoice;
    DWORD                               dwFlags;
    HWND                                hwndParent;
    LPWSTR                              pwszPageTitle;
    PCCRYPTUI_WIZ_DIGITAL_SIGN_INFO     pDigitalSignInfo;
    PFNCPROPPAGECALLBACK                pPropPageCallback;
    void *                              pvCallbackData;
    BOOL                                fResult;
    DWORD                               dwError;
    PCCRYPTUI_WIZ_DIGITAL_SIGN_CONTEXT  pSignContext;
    DWORD                               dwReserved;
    void                                *pvSignReserved;
}CRYPTUI_WIZ_GET_SIGN_PAGE_INFO, *PCRYPTUI_WIZ_GET_SIGN_PAGE_INFO;

typedef const CRYPTUI_WIZ_GET_SIGN_PAGE_INFO *PCCRYPTUI_WIZ_GET_SIGN_PAGE_INFO;

//-----------------------------------------------------------------------
//
// CryptUIWizGetDigitalSignPages
//
//  Get specific wizard pages from the CryptUIWizDigitalSign wizard.
//  Application can include the pages to other wizards.  The pages will
//  gather user inputs throught the new "Parent" wizard.
//  After user clicks the finish buttion, signing process will start the signing
//  and return the result in fResult and dwError field of CRYPTUI_WIZ_SIGN_GET_PAGE_INFO
//  struct.  If not enough information can be gathered through the wizard pages,
//  user should supply addtional information in pSignGetPageInfo.
//
//
// pSignGetPageInfo    IN   Required:   The struct that user allocate.   It can be used
//                                      to supply additinal information which is not gathered
//                                      from the selected wizard pages
// prghPropPages,      OUT  Required:   The wizard pages returned.  Please
//                                      notice the pszTitle of the struct is set to NULL
// pcPropPages         OUT  Required:   The number of wizard pages returned
//------------------------------------------------------------------------
BOOL
WINAPI
CryptUIWizGetDigitalSignPages(
     IN     PCRYPTUI_WIZ_GET_SIGN_PAGE_INFO     pSignGetPageInfo,
     OUT    PROPSHEETPAGEW                      **prghPropPages,
     OUT    DWORD                               *pcPropPages);

BOOL
WINAPI
CryptUIWizFreeDigitalSignPages(
            IN PROPSHEETPAGEW    *rghPropPages,
            IN DWORD             cPropPages
            );

DWORD
WINAPI
I_CryptUIProtect(
    IN      PVOID               pvReserved1,
    IN      PVOID               pvReserved2,
    IN      DWORD               dwReserved3,
    IN      PVOID               *pvReserved4,
    IN      BOOL                fReserved5,
    IN      PVOID               pvReserved6
    );

DWORD
WINAPI
I_CryptUIProtectFailure(
    IN      PVOID               pvReserved1,
    IN      DWORD               dwReserved2,
    IN      PVOID               *pvReserved3);

#include <poppack.h>

#ifdef __cplusplus
}       // Balance extern "C" above
#endif

#endif // _CRYPTUI_H_
=== C:/Users/treeman/Desktop/windows nt source code\Source\Win2K3\NT\public\internal\ds\inc\cs.h ===
/* this ALWAYS GENERATED file contains the definitions for the interfaces */


 /* File created by MIDL compiler version 6.00.0361 */
/* Compiler settings for cs.idl:
    Oicf, W1, Zp8, env=Win32 (32b run)
    protocol : dce , ms_ext, c_ext, oldnames, robust
    error checks: allocation ref bounds_check enum stub_data 
    VC __declspec() decoration level: 
         __declspec(uuid()), __declspec(selectany), __declspec(novtable)
         DECLSPEC_UUID(), MIDL_INTERFACE()
*/
//@@MIDL_FILE_HEADING(  )

#pragma warning( disable: 4049 )  /* more than 64k source lines */


/* verify that the <rpcndr.h> version is high enough to compile this file*/
#ifndef __REQUIRED_RPCNDR_H_VERSION__
#define __REQUIRED_RPCNDR_H_VERSION__ 475
#endif

#include "rpc.h"
#include "rpcndr.h"

#ifndef __RPCNDR_H_VERSION__
#error this stub requires an updated version of <rpcndr.h>
#endif // __RPCNDR_H_VERSION__

#ifndef COM_NO_WINDOWS_H
#include "windows.h"
#include "ole2.h"
#endif /*COM_NO_WINDOWS_H*/

#ifndef __cs_h__
#define __cs_h__

#if defined(_MSC_VER) && (_MSC_VER >= 1020)
#pragma once
#endif

/* Forward Declarations */ 

#ifndef __IEnumPackage_FWD_DEFINED__
#define __IEnumPackage_FWD_DEFINED__
typedef interface IEnumPackage IEnumPackage;
#endif 	/* __IEnumPackage_FWD_DEFINED__ */


#ifndef __IClassAccess_FWD_DEFINED__
#define __IClassAccess_FWD_DEFINED__
typedef interface IClassAccess IClassAccess;
#endif 	/* __IClassAccess_FWD_DEFINED__ */


#ifndef __IClassAdmin_FWD_DEFINED__
#define __IClassAdmin_FWD_DEFINED__
typedef interface IClassAdmin IClassAdmin;
#endif 	/* __IClassAdmin_FWD_DEFINED__ */


/* header files for imported files */
#include "unknwn.h"
#include "appmgmt.h"

#ifdef __cplusplus
extern "C"{
#endif 

void * __RPC_USER MIDL_user_allocate(size_t);
void __RPC_USER MIDL_user_free( void * ); 

/* interface __MIDL_itf_cs_0000 */
/* [local] */ 

#define	ACTFLG_UninstallUnmanaged	( 0x4 )

#define	ACTFLG_Published	( 0x8 )

#define	ACTFLG_POSTBETA3	( 0x10 )

#define	ACTFLG_UserInstall	( 0x20 )

#define	ACTFLG_OnDemandInstall	( 0x40 )

#define	ACTFLG_Orphan	( 0x80 )

#define	ACTFLG_Uninstall	( 0x100 )

#define	ACTFLG_Pilot	( 0x200 )

#define	ACTFLG_Assigned	( 0x400 )

#define	ACTFLG_OrphanOnPolicyRemoval	( 0x800 )

#define	ACTFLG_UninstallOnPolicyRemoval	( 0x1000 )

#define	ACTFLG_InstallUserAssign	( 0x2000 )

#define	ACTFLG_ForceUpgrade	( 0x4000 )

#define	ACTFLG_MinimalInstallUI	( 0x8000 )

#define	ACTFLG_ExcludeX86OnWin64	( 0x10000 )

#define	ACTFLG_IgnoreLanguage	( 0x20000 )

#define	ACTFLG_HasUpgrades	( 0x40000 )

#define	ACTFLG_FullInstallUI	( 0x80000 )

#define	ACTFLG_PreserveClasses	( 0x100000 )

#define	APPQUERY_ALL	( 1 )

#define	APPQUERY_ADMINISTRATIVE	( 2 )

#define	APPQUERY_POLICY	( 3 )

#define	APPQUERY_USERDISPLAY	( 4 )

#define	APPQUERY_RSOP_LOGGING	( 5 )

#define	APPQUERY_RSOP_ARP	( 6 )

#define	UPGFLG_Uninstall	( 0x1 )

#define	UPGFLG_NoUninstall	( 0x2 )

#define	UPGFLG_UpgradedBy	( 0x4 )

#define	UPGFLG_Enforced	( 0x8 )

typedef /* [v1_enum] */ 
enum _CLASSPATHTYPE
    {	ExeNamePath	= 0,
	DllNamePath	= ExeNamePath + 1,
	TlbNamePath	= DllNamePath + 1,
	CabFilePath	= TlbNamePath + 1,
	InfFilePath	= CabFilePath + 1,
	DrwFilePath	= InfFilePath + 1,
	SetupNamePath	= DrwFilePath + 1
    } 	CLASSPATHTYPE;

typedef struct tagUPGRADEINFO
    {
    LPOLESTR szClassStore;
    GUID PackageGuid;
    GUID GpoId;
    DWORD Flag;
    } 	UPGRADEINFO;

#define	CLSCTX64_INPROC_SERVER	( 0x10000000 )

#define	CLSCTX64_INPROC_HANDLER	( 0x20000000 )

typedef struct tagCLASSDETAIL
    {
    CLSID Clsid;
    CLSID TreatAs;
    DWORD dwComClassContext;
    DWORD cProgId;
    DWORD cMaxProgId;
    /* [size_is] */ LPOLESTR *prgProgId;
    } 	CLASSDETAIL;

typedef struct tagACTVATIONINFO
    {
    UINT cClasses;
    /* [size_is] */ CLASSDETAIL *pClasses;
    UINT cShellFileExt;
    /* [size_is] */ LPOLESTR *prgShellFileExt;
    /* [size_is] */ UINT *prgPriority;
    UINT cInterfaces;
    /* [size_is] */ IID *prgInterfaceId;
    UINT cTypeLib;
    /* [size_is] */ GUID *prgTlbId;
    BOOL bHasClasses;
    } 	ACTIVATIONINFO;

typedef struct tagINSTALLINFO
    {
    DWORD dwActFlags;
    CLASSPATHTYPE PathType;
    LPOLESTR pszScriptPath;
    LPOLESTR pszSetupCommand;
    LPOLESTR pszUrl;
    ULONGLONG Usn;
    UINT InstallUiLevel;
    GUID *pClsid;
    GUID ProductCode;
    GUID PackageGuid;
    GUID Mvipc;
    DWORD dwVersionHi;
    DWORD dwVersionLo;
    DWORD dwRevision;
    UINT cUpgrades;
    /* [size_is] */ UPGRADEINFO *prgUpgradeInfoList;
    ULONG cScriptLen;
    } 	INSTALLINFO;

typedef struct tagPLATFORMINFO
    {
    UINT cPlatforms;
    /* [size_is] */ CSPLATFORM *prgPlatform;
    UINT cLocales;
    /* [size_is] */ LCID *prgLocale;
    } 	PLATFORMINFO;

typedef struct tagPACKAGEDETAIL
    {
    LPOLESTR pszPackageName;
    LPOLESTR pszPublisher;
    UINT cSources;
    /* [size_is] */ LPOLESTR *pszSourceList;
    UINT cCategories;
    /* [size_is] */ GUID *rpCategory;
    ACTIVATIONINFO *pActInfo;
    PLATFORMINFO *pPlatformInfo;
    INSTALLINFO *pInstallInfo;
    } 	PACKAGEDETAIL;

#ifndef _LPCSADMNENUM_DEFINED
#define _LPCSADMNENUM_DEFINED
typedef struct tagPACKAGEDISPINFO
    {
    LPOLESTR pszPackageName;
    DWORD dwActFlags;
    CLASSPATHTYPE PathType;
    LPOLESTR pszScriptPath;
    LPOLESTR pszPublisher;
    LPOLESTR pszUrl;
    UINT InstallUiLevel;
    GUID ProductCode;
    GUID PackageGuid;
    ULONGLONG Usn;
    DWORD dwVersionHi;
    DWORD dwVersionLo;
    DWORD dwRevision;
    GUID GpoId;
    UINT cUpgrades;
    /* [size_is] */ UPGRADEINFO *prgUpgradeInfoList;
    LANGID LangId;
    BYTE *rgSecurityDescriptor;
    UINT cbSecurityDescriptor;
    WCHAR *pszGpoPath;
    DWORD MatchedArchitecture;
    UINT cArchitectures;
    /* [size_is] */ DWORD *prgArchitectures;
    UINT cTransforms;
    /* [size_is] */ LPOLESTR *prgTransforms;
    UINT cCategories;
    /* [size_is] */ LPOLESTR *prgCategories;
    } 	PACKAGEDISPINFO;



extern RPC_IF_HANDLE __MIDL_itf_cs_0000_ClientIfHandle;
extern RPC_IF_HANDLE __MIDL_itf_cs_0000_ServerIfHandle;

#ifndef __IEnumPackage_INTERFACE_DEFINED__
#define __IEnumPackage_INTERFACE_DEFINED__

/* interface IEnumPackage */
/* [uuid][object][local] */ 


EXTERN_C const IID IID_IEnumPackage;

#if defined(__cplusplus) && !defined(CINTERFACE)
    
    MIDL_INTERFACE("00000193-0000-0000-C000-000000000046")
    IEnumPackage : public IUnknown
    {
    public:
        virtual HRESULT STDMETHODCALLTYPE Next( 
            /* [in] */ ULONG celt,
            /* [length_is][size_is][out] */ PACKAGEDISPINFO *rgelt,
            /* [out] */ ULONG *pceltFetched) = 0;
        
        virtual HRESULT STDMETHODCALLTYPE Skip( 
            /* [in] */ ULONG celt) = 0;
        
        virtual HRESULT STDMETHODCALLTYPE Reset( void) = 0;
        
    };
    
#else 	/* C style interface */

    typedef struct IEnumPackageVtbl
    {
        BEGIN_INTERFACE
        
        HRESULT ( STDMETHODCALLTYPE *QueryInterface )( 
            IEnumPackage * This,
            /* [in] */ REFIID riid,
            /* [iid_is][out] */ void **ppvObject);
        
        ULONG ( STDMETHODCALLTYPE *AddRef )( 
            IEnumPackage * This);
        
        ULONG ( STDMETHODCALLTYPE *Release )( 
            IEnumPackage * This);
        
        HRESULT ( STDMETHODCALLTYPE *Next )( 
            IEnumPackage * This,
            /* [in] */ ULONG celt,
            /* [length_is][size_is][out] */ PACKAGEDISPINFO *rgelt,
            /* [out] */ ULONG *pceltFetched);
        
        HRESULT ( STDMETHODCALLTYPE *Skip )( 
            IEnumPackage * This,
            /* [in] */ ULONG celt);
        
        HRESULT ( STDMETHODCALLTYPE *Reset )( 
            IEnumPackage * This);
        
        END_INTERFACE
    } IEnumPackageVtbl;

    interface IEnumPackage
    {
        CONST_VTBL struct IEnumPackageVtbl *lpVtbl;
    };

    

#ifdef COBJMACROS


#define IEnumPackage_QueryInterface(This,riid,ppvObject)	\
    (This)->lpVtbl -> QueryInterface(This,riid,ppvObject)

#define IEnumPackage_AddRef(This)	\
    (This)->lpVtbl -> AddRef(This)

#define IEnumPackage_Release(This)	\
    (This)->lpVtbl -> Release(This)


#define IEnumPackage_Next(This,celt,rgelt,pceltFetched)	\
    (This)->lpVtbl -> Next(This,celt,rgelt,pceltFetched)

#define IEnumPackage_Skip(This,celt)	\
    (This)->lpVtbl -> Skip(This,celt)

#define IEnumPackage_Reset(This)	\
    (This)->lpVtbl -> Reset(This)

#endif /* COBJMACROS */


#endif 	/* C style interface */



HRESULT STDMETHODCALLTYPE IEnumPackage_Next_Proxy( 
    IEnumPackage * This,
    /* [in] */ ULONG celt,
    /* [length_is][size_is][out] */ PACKAGEDISPINFO *rgelt,
    /* [out] */ ULONG *pceltFetched);


void __RPC_STUB IEnumPackage_Next_Stub(
    IRpcStubBuffer *This,
    IRpcChannelBuffer *_pRpcChannelBuffer,
    PRPC_MESSAGE _pRpcMessage,
    DWORD *_pdwStubPhase);


HRESULT STDMETHODCALLTYPE IEnumPackage_Skip_Proxy( 
    IEnumPackage * This,
    /* [in] */ ULONG celt);


void __RPC_STUB IEnumPackage_Skip_Stub(
    IRpcStubBuffer *This,
    IRpcChannelBuffer *_pRpcChannelBuffer,
    PRPC_MESSAGE _pRpcMessage,
    DWORD *_pdwStubPhase);


HRESULT STDMETHODCALLTYPE IEnumPackage_Reset_Proxy( 
    IEnumPackage * This);


void __RPC_STUB IEnumPackage_Reset_Stub(
    IRpcStubBuffer *This,
    IRpcChannelBuffer *_pRpcChannelBuffer,
    PRPC_MESSAGE _pRpcMessage,
    DWORD *_pdwStubPhase);



#endif 	/* __IEnumPackage_INTERFACE_DEFINED__ */


/* interface __MIDL_itf_cs_0011 */
/* [local] */ 

#endif


extern RPC_IF_HANDLE __MIDL_itf_cs_0011_ClientIfHandle;
extern RPC_IF_HANDLE __MIDL_itf_cs_0011_ServerIfHandle;

#ifndef __IClassAccess_INTERFACE_DEFINED__
#define __IClassAccess_INTERFACE_DEFINED__

/* interface IClassAccess */
/* [uuid][object][local] */ 


EXTERN_C const IID IID_IClassAccess;

#if defined(__cplusplus) && !defined(CINTERFACE)
    
    MIDL_INTERFACE("00000190-0000-0000-C000-000000000046")
    IClassAccess : public IUnknown
    {
    public:
        virtual HRESULT STDMETHODCALLTYPE GetAppInfo( 
            /* [in] */ uCLSSPEC *pClassSpec,
            /* [in] */ QUERYCONTEXT *pQryContext,
            /* [out] */ PACKAGEDISPINFO *pPackageInfo) = 0;
        
        virtual HRESULT STDMETHODCALLTYPE EnumPackages( 
            /* [unique][in] */ LPOLESTR pszPackageName,
            /* [unique][in] */ GUID *pCategory,
            /* [unique][in] */ ULONGLONG *pLastUsn,
            /* [in] */ DWORD dwAppFlags,
            /* [out] */ IEnumPackage **ppIEnumPackage) = 0;
        
        virtual HRESULT STDMETHODCALLTYPE SetClassStorePath( 
            /* [unique][in] */ LPOLESTR pszClassStorePath,
            /* [unique][in] */ void *pRsopUserToken) = 0;
        
    };
    
#else 	/* C style interface */

    typedef struct IClassAccessVtbl
    {
        BEGIN_INTERFACE
        
        HRESULT ( STDMETHODCALLTYPE *QueryInterface )( 
            IClassAccess * This,
            /* [in] */ REFIID riid,
            /* [iid_is][out] */ void **ppvObject);
        
        ULONG ( STDMETHODCALLTYPE *AddRef )( 
            IClassAccess * This);
        
        ULONG ( STDMETHODCALLTYPE *Release )( 
            IClassAccess * This);
        
        HRESULT ( STDMETHODCALLTYPE *GetAppInfo )( 
            IClassAccess * This,
            /* [in] */ uCLSSPEC *pClassSpec,
            /* [in] */ QUERYCONTEXT *pQryContext,
            /* [out] */ PACKAGEDISPINFO *pPackageInfo);
        
        HRESULT ( STDMETHODCALLTYPE *EnumPackages )( 
            IClassAccess * This,
            /* [unique][in] */ LPOLESTR pszPackageName,
            /* [unique][in] */ GUID *pCategory,
            /* [unique][in] */ ULONGLONG *pLastUsn,
            /* [in] */ DWORD dwAppFlags,
            /* [out] */ IEnumPackage **ppIEnumPackage);
        
        HRESULT ( STDMETHODCALLTYPE *SetClassStorePath )( 
            IClassAccess * This,
            /* [unique][in] */ LPOLESTR pszClassStorePath,
            /* [unique][in] */ void *pRsopUserToken);
        
        END_INTERFACE
    } IClassAccessVtbl;

    interface IClassAccess
    {
        CONST_VTBL struct IClassAccessVtbl *lpVtbl;
    };

    

#ifdef COBJMACROS


#define IClassAccess_QueryInterface(This,riid,ppvObject)	\
    (This)->lpVtbl -> QueryInterface(This,riid,ppvObject)

#define IClassAccess_AddRef(This)	\
    (This)->lpVtbl -> AddRef(This)

#define IClassAccess_Release(This)	\
    (This)->lpVtbl -> Release(This)


#define IClassAccess_GetAppInfo(This,pClassSpec,pQryContext,pPackageInfo)	\
    (This)->lpVtbl -> GetAppInfo(This,pClassSpec,pQryContext,pPackageInfo)

#define IClassAccess_EnumPackages(This,pszPackageName,pCategory,pLastUsn,dwAppFlags,ppIEnumPackage)	\
    (This)->lpVtbl -> EnumPackages(This,pszPackageName,pCategory,pLastUsn,dwAppFlags,ppIEnumPackage)

#define IClassAccess_SetClassStorePath(This,pszClassStorePath,pRsopUserToken)	\
    (This)->lpVtbl -> SetClassStorePath(This,pszClassStorePath,pRsopUserToken)

#endif /* COBJMACROS */


#endif 	/* C style interface */



HRESULT STDMETHODCALLTYPE IClassAccess_GetAppInfo_Proxy( 
    IClassAccess * This,
    /* [in] */ uCLSSPEC *pClassSpec,
    /* [in] */ QUERYCONTEXT *pQryContext,
    /* [out] */ PACKAGEDISPINFO *pPackageInfo);


void __RPC_STUB IClassAccess_GetAppInfo_Stub(
    IRpcStubBuffer *This,
    IRpcChannelBuffer *_pRpcChannelBuffer,
    PRPC_MESSAGE _pRpcMessage,
    DWORD *_pdwStubPhase);


HRESULT STDMETHODCALLTYPE IClassAccess_EnumPackages_Proxy( 
    IClassAccess * This,
    /* [unique][in] */ LPOLESTR pszPackageName,
    /* [unique][in] */ GUID *pCategory,
    /* [unique][in] */ ULONGLONG *pLastUsn,
    /* [in] */ DWORD dwAppFlags,
    /* [out] */ IEnumPackage **ppIEnumPackage);


void __RPC_STUB IClassAccess_EnumPackages_Stub(
    IRpcStubBuffer *This,
    IRpcChannelBuffer *_pRpcChannelBuffer,
    PRPC_MESSAGE _pRpcMessage,
    DWORD *_pdwStubPhase);


HRESULT STDMETHODCALLTYPE IClassAccess_SetClassStorePath_Proxy( 
    IClassAccess * This,
    /* [unique][in] */ LPOLESTR pszClassStorePath,
    /* [unique][in] */ void *pRsopUserToken);


void __RPC_STUB IClassAccess_SetClassStorePath_Stub(
    IRpcStubBuffer *This,
    IRpcChannelBuffer *_pRpcChannelBuffer,
    PRPC_MESSAGE _pRpcMessage,
    DWORD *_pdwStubPhase);



#endif 	/* __IClassAccess_INTERFACE_DEFINED__ */


#ifndef __IClassAdmin_INTERFACE_DEFINED__
#define __IClassAdmin_INTERFACE_DEFINED__

/* interface IClassAdmin */
/* [uuid][object][local] */ 


EXTERN_C const IID IID_IClassAdmin;

#if defined(__cplusplus) && !defined(CINTERFACE)
    
    MIDL_INTERFACE("00000191-0000-0000-C000-000000000046")
    IClassAdmin : public IUnknown
    {
    public:
        virtual HRESULT STDMETHODCALLTYPE GetGPOInfo( 
            /* [out] */ GUID *pGPOId,
            /* [out] */ LPOLESTR *pszPolicyName) = 0;
        
        virtual HRESULT STDMETHODCALLTYPE AddPackage( 
            /* [in] */ PACKAGEDETAIL *pPackageDetail,
            /* [out] */ GUID *pPkgGuid) = 0;
        
        virtual HRESULT STDMETHODCALLTYPE RemovePackage( 
            /* [in] */ LPOLESTR pszPackageName,
            /* [in] */ DWORD dwFlags) = 0;
        
        virtual HRESULT STDMETHODCALLTYPE ChangePackageProperties( 
            /* [in] */ LPOLESTR pszPackageName,
            /* [unique][in] */ LPOLESTR pszNewName,
            /* [unique][in] */ DWORD *pdwFlags,
            /* [unique][in] */ LPOLESTR pszUrl,
            /* [unique][in] */ LPOLESTR pszScriptPath,
            /* [unique][in] */ UINT *pInstallUiLevel,
            /* [unique][in] */ DWORD *pdwRevision) = 0;
        
        virtual HRESULT STDMETHODCALLTYPE ChangePackageCategories( 
            /* [in] */ LPOLESTR pszPackageName,
            /* [in] */ UINT cCategories,
            /* [unique][size_is][in] */ GUID *rpCategory) = 0;
        
        virtual HRESULT STDMETHODCALLTYPE ChangePackageSourceList( 
            /* [in] */ LPOLESTR pszPackageName,
            /* [in] */ UINT cSources,
            /* [unique][size_is][in] */ LPOLESTR *pszSourceList) = 0;
        
        virtual HRESULT STDMETHODCALLTYPE ChangePackageUpgradeList( 
            /* [in] */ LPOLESTR pszPackageName,
            /* [in] */ UINT cUpgrades,
            /* [unique][size_is][in] */ UPGRADEINFO *prgUpgradeInfoList) = 0;
        
        virtual HRESULT STDMETHODCALLTYPE ChangePackageUpgradeInfoIncremental( 
            /* [in] */ GUID PkgGuid,
            /* [in] */ UPGRADEINFO UpgradeInfo,
            /* [in] */ DWORD OpFlags) = 0;
        
        virtual HRESULT STDMETHODCALLTYPE SetPriorityByFileExt( 
            /* [in] */ LPOLESTR pszPackageName,
            /* [in] */ LPOLESTR pszFileExt,
            /* [in] */ UINT Priority) = 0;
        
        virtual HRESULT STDMETHODCALLTYPE EnumPackages( 
            /* [unique][in] */ LPOLESTR pszFileExt,
            /* [unique][in] */ GUID *pCategory,
            /* [in] */ DWORD dwAppFlags,
            /* [unique][in] */ DWORD *pdwLocale,
            /* [unique][in] */ CSPLATFORM *pPlatform,
            /* [out] */ IEnumPackage **ppIEnumPackage) = 0;
        
        virtual HRESULT STDMETHODCALLTYPE GetPackageDetails( 
            /* [in] */ LPOLESTR pszPackageName,
            /* [out] */ PACKAGEDETAIL *pPackageDetail) = 0;
        
        virtual HRESULT STDMETHODCALLTYPE GetPackageDetailsFromGuid( 
            /* [in] */ GUID PkgGuid,
            /* [out] */ PACKAGEDETAIL *pPackageDetail) = 0;
        
        virtual HRESULT STDMETHODCALLTYPE GetAppCategories( 
            /* [in] */ LCID Locale,
            /* [out] */ APPCATEGORYINFOLIST *pAppCategoryList) = 0;
        
        virtual HRESULT STDMETHODCALLTYPE RegisterAppCategory( 
            /* [in] */ APPCATEGORYINFO *pAppCategory) = 0;
        
        virtual HRESULT STDMETHODCALLTYPE UnregisterAppCategory( 
            /* [in] */ GUID *pAppCategoryId) = 0;
        
        virtual HRESULT STDMETHODCALLTYPE Cleanup( 
            /* [in] */ FILETIME *pTimeBefore) = 0;
        
        virtual HRESULT STDMETHODCALLTYPE GetDNFromPackageName( 
            /* [in] */ LPOLESTR pszPackageName,
            /* [out] */ LPOLESTR *szDN) = 0;
        
        virtual HRESULT STDMETHODCALLTYPE RedeployPackage( 
            /* [in] */ GUID *pPackageGuid,
            /* [in] */ PACKAGEDETAIL *pPackageDetail) = 0;
        
    };
    
#else 	/* C style interface */

    typedef struct IClassAdminVtbl
    {
        BEGIN_INTERFACE
        
        HRESULT ( STDMETHODCALLTYPE *QueryInterface )( 
            IClassAdmin * This,
            /* [in] */ REFIID riid,
            /* [iid_is][out] */ void **ppvObject);
        
        ULONG ( STDMETHODCALLTYPE *AddRef )( 
            IClassAdmin * This);
        
        ULONG ( STDMETHODCALLTYPE *Release )( 
            IClassAdmin * This);
        
        HRESULT ( STDMETHODCALLTYPE *GetGPOInfo )( 
            IClassAdmin * This,
            /* [out] */ GUID *pGPOId,
            /* [out] */ LPOLESTR *pszPolicyName);
        
        HRESULT ( STDMETHODCALLTYPE *AddPackage )( 
            IClassAdmin * This,
            /* [in] */ PACKAGEDETAIL *pPackageDetail,
            /* [out] */ GUID *pPkgGuid);
        
        HRESULT ( STDMETHODCALLTYPE *RemovePackage )( 
            IClassAdmin * This,
            /* [in] */ LPOLESTR pszPackageName,
            /* [in] */ DWORD dwFlags);
        
        HRESULT ( STDMETHODCALLTYPE *ChangePackageProperties )( 
            IClassAdmin * This,
            /* [in] */ LPOLESTR pszPackageName,
            /* [unique][in] */ LPOLESTR pszNewName,
            /* [unique][in] */ DWORD *pdwFlags,
            /* [unique][in] */ LPOLESTR pszUrl,
            /* [unique][in] */ LPOLESTR pszScriptPath,
            /* [unique][in] */ UINT *pInstallUiLevel,
            /* [unique][in] */ DWORD *pdwRevision);
        
        HRESULT ( STDMETHODCALLTYPE *ChangePackageCategories )( 
            IClassAdmin * This,
            /* [in] */ LPOLESTR pszPackageName,
            /* [in] */ UINT cCategories,
            /* [unique][size_is][in] */ GUID *rpCategory);
        
        HRESULT ( STDMETHODCALLTYPE *ChangePackageSourceList )( 
            IClassAdmin * This,
            /* [in] */ LPOLESTR pszPackageName,
            /* [in] */ UINT cSources,
            /* [unique][size_is][in] */ LPOLESTR *pszSourceList);
        
        HRESULT ( STDMETHODCALLTYPE *ChangePackageUpgradeList )( 
            IClassAdmin * This,
            /* [in] */ LPOLESTR pszPackageName,
            /* [in] */ UINT cUpgrades,
            /* [unique][size_is][in] */ UPGRADEINFO *prgUpgradeInfoList);
        
        HRESULT ( STDMETHODCALLTYPE *ChangePackageUpgradeInfoIncremental )( 
            IClassAdmin * This,
            /* [in] */ GUID PkgGuid,
            /* [in] */ UPGRADEINFO UpgradeInfo,
            /* [in] */ DWORD OpFlags);
        
        HRESULT ( STDMETHODCALLTYPE *SetPriorityByFileExt )( 
            IClassAdmin * This,
            /* [in] */ LPOLESTR pszPackageName,
            /* [in] */ LPOLESTR pszFileExt,
            /* [in] */ UINT Priority);
        
        HRESULT ( STDMETHODCALLTYPE *EnumPackages )( 
            IClassAdmin * This,
            /* [unique][in] */ LPOLESTR pszFileExt,
            /* [unique][in] */ GUID *pCategory,
            /* [in] */ DWORD dwAppFlags,
            /* [unique][in] */ DWORD *pdwLocale,
            /* [unique][in] */ CSPLATFORM *pPlatform,
            /* [out] */ IEnumPackage **ppIEnumPackage);
        
        HRESULT ( STDMETHODCALLTYPE *GetPackageDetails )( 
            IClassAdmin * This,
            /* [in] */ LPOLESTR pszPackageName,
            /* [out] */ PACKAGEDETAIL *pPackageDetail);
        
        HRESULT ( STDMETHODCALLTYPE *GetPackageDetailsFromGuid )( 
            IClassAdmin * This,
            /* [in] */ GUID PkgGuid,
            /* [out] */ PACKAGEDETAIL *pPackageDetail);
        
        HRESULT ( STDMETHODCALLTYPE *GetAppCategories )( 
            IClassAdmin * This,
            /* [in] */ LCID Locale,
            /* [out] */ APPCATEGORYINFOLIST *pAppCategoryList);
        
        HRESULT ( STDMETHODCALLTYPE *RegisterAppCategory )( 
            IClassAdmin * This,
            /* [in] */ APPCATEGORYINFO *pAppCategory);
        
        HRESULT ( STDMETHODCALLTYPE *UnregisterAppCategory )( 
            IClassAdmin * This,
            /* [in] */ GUID *pAppCategoryId);
        
        HRESULT ( STDMETHODCALLTYPE *Cleanup )( 
            IClassAdmin * This,
            /* [in] */ FILETIME *pTimeBefore);
        
        HRESULT ( STDMETHODCALLTYPE *GetDNFromPackageName )( 
            IClassAdmin * This,
            /* [in] */ LPOLESTR pszPackageName,
            /* [out] */ LPOLESTR *szDN);
        
        HRESULT ( STDMETHODCALLTYPE *RedeployPackage )( 
            IClassAdmin * This,
            /* [in] */ GUID *pPackageGuid,
            /* [in] */ PACKAGEDETAIL *pPackageDetail);
        
        END_INTERFACE
    } IClassAdminVtbl;

    interface IClassAdmin
    {
        CONST_VTBL struct IClassAdminVtbl *lpVtbl;
    };

    

#ifdef COBJMACROS


#define IClassAdmin_QueryInterface(This,riid,ppvObject)	\
    (This)->lpVtbl -> QueryInterface(This,riid,ppvObject)

#define IClassAdmin_AddRef(This)	\
    (This)->lpVtbl -> AddRef(This)

#define IClassAdmin_Release(This)	\
    (This)->lpVtbl -> Release(This)


#define IClassAdmin_GetGPOInfo(This,pGPOId,pszPolicyName)	\
    (This)->lpVtbl -> GetGPOInfo(This,pGPOId,pszPolicyName)

#define IClassAdmin_AddPackage(This,pPackageDetail,pPkgGuid)	\
    (This)->lpVtbl -> AddPackage(This,pPackageDetail,pPkgGuid)

#define IClassAdmin_RemovePackage(This,pszPackageName,dwFlags)	\
    (This)->lpVtbl -> RemovePackage(This,pszPackageName,dwFlags)

#define IClassAdmin_ChangePackageProperties(This,pszPackageName,pszNewName,pdwFlags,pszUrl,pszScriptPath,pInstallUiLevel,pdwRevision)	\
    (This)->lpVtbl -> ChangePackageProperties(This,pszPackageName,pszNewName,pdwFlags,pszUrl,pszScriptPath,pInstallUiLevel,pdwRevision)

#define IClassAdmin_ChangePackageCategories(This,pszPackageName,cCategories,rpCategory)	\
    (This)->lpVtbl -> ChangePackageCategories(This,pszPackageName,cCategories,rpCategory)

#define IClassAdmin_ChangePackageSourceList(This,pszPackageName,cSources,pszSourceList)	\
    (This)->lpVtbl -> ChangePackageSourceList(This,pszPackageName,cSources,pszSourceList)

#define IClassAdmin_ChangePackageUpgradeList(This,pszPackageName,cUpgrades,prgUpgradeInfoList)	\
    (This)->lpVtbl -> ChangePackageUpgradeList(This,pszPackageName,cUpgrades,prgUpgradeInfoList)

#define IClassAdmin_ChangePackageUpgradeInfoIncremental(This,PkgGuid,UpgradeInfo,OpFlags)	\
    (This)->lpVtbl -> ChangePackageUpgradeInfoIncremental(This,PkgGuid,UpgradeInfo,OpFlags)

#define IClassAdmin_SetPriorityByFileExt(This,pszPackageName,pszFileExt,Priority)	\
    (This)->lpVtbl -> SetPriorityByFileExt(This,pszPackageName,pszFileExt,Priority)

#define IClassAdmin_EnumPackages(This,pszFileExt,pCategory,dwAppFlags,pdwLocale,pPlatform,ppIEnumPackage)	\
    (This)->lpVtbl -> EnumPackages(This,pszFileExt,pCategory,dwAppFlags,pdwLocale,pPlatform,ppIEnumPackage)

#define IClassAdmin_GetPackageDetails(This,pszPackageName,pPackageDetail)	\
    (This)->lpVtbl -> GetPackageDetails(This,pszPackageName,pPackageDetail)

#define IClassAdmin_GetPackageDetailsFromGuid(This,PkgGuid,pPackageDetail)	\
    (This)->lpVtbl -> GetPackageDetailsFromGuid(This,PkgGuid,pPackageDetail)

#define IClassAdmin_GetAppCategories(This,Locale,pAppCategoryList)	\
    (This)->lpVtbl -> GetAppCategories(This,Locale,pAppCategoryList)

#define IClassAdmin_RegisterAppCategory(This,pAppCategory)	\
    (This)->lpVtbl -> RegisterAppCategory(This,pAppCategory)

#define IClassAdmin_UnregisterAppCategory(This,pAppCategoryId)	\
    (This)->lpVtbl -> UnregisterAppCategory(This,pAppCategoryId)

#define IClassAdmin_Cleanup(This,pTimeBefore)	\
    (This)->lpVtbl -> Cleanup(This,pTimeBefore)

#define IClassAdmin_GetDNFromPackageName(This,pszPackageName,szDN)	\
    (This)->lpVtbl -> GetDNFromPackageName(This,pszPackageName,szDN)

#define IClassAdmin_RedeployPackage(This,pPackageGuid,pPackageDetail)	\
    (This)->lpVtbl -> RedeployPackage(This,pPackageGuid,pPackageDetail)

#endif /* COBJMACROS */


#endif 	/* C style interface */



HRESULT STDMETHODCALLTYPE IClassAdmin_GetGPOInfo_Proxy( 
    IClassAdmin * This,
    /* [out] */ GUID *pGPOId,
    /* [out] */ LPOLESTR *pszPolicyName);


void __RPC_STUB IClassAdmin_GetGPOInfo_Stub(
    IRpcStubBuffer *This,
    IRpcChannelBuffer *_pRpcChannelBuffer,
    PRPC_MESSAGE _pRpcMessage,
    DWORD *_pdwStubPhase);


HRESULT STDMETHODCALLTYPE IClassAdmin_AddPackage_Proxy( 
    IClassAdmin * This,
    /* [in] */ PACKAGEDETAIL *pPackageDetail,
    /* [out] */ GUID *pPkgGuid);


void __RPC_STUB IClassAdmin_AddPackage_Stub(
    IRpcStubBuffer *This,
    IRpcChannelBuffer *_pRpcChannelBuffer,
    PRPC_MESSAGE _pRpcMessage,
    DWORD *_pdwStubPhase);


HRESULT STDMETHODCALLTYPE IClassAdmin_RemovePackage_Proxy( 
    IClassAdmin * This,
    /* [in] */ LPOLESTR pszPackageName,
    /* [in] */ DWORD dwFlags);


void __RPC_STUB IClassAdmin_RemovePackage_Stub(
    IRpcStubBuffer *This,
    IRpcChannelBuffer *_pRpcChannelBuffer,
    PRPC_MESSAGE _pRpcMessage,
    DWORD *_pdwStubPhase);


HRESULT STDMETHODCALLTYPE IClassAdmin_ChangePackageProperties_Proxy( 
    IClassAdmin * This,
    /* [in] */ LPOLESTR pszPackageName,
    /* [unique][in] */ LPOLESTR pszNewName,
    /* [unique][in] */ DWORD *pdwFlags,
    /* [unique][in] */ LPOLESTR pszUrl,
    /* [unique][in] */ LPOLESTR pszScriptPath,
    /* [unique][in] */ UINT *pInstallUiLevel,
    /* [unique][in] */ DWORD *pdwRevision);


void __RPC_STUB IClassAdmin_ChangePackageProperties_Stub(
    IRpcStubBuffer *This,
    IRpcChannelBuffer *_pRpcChannelBuffer,
    PRPC_MESSAGE _pRpcMessage,
    DWORD *_pdwStubPhase);


HRESULT STDMETHODCALLTYPE IClassAdmin_ChangePackageCategories_Proxy( 
    IClassAdmin * This,
    /* [in] */ LPOLESTR pszPackageName,
    /* [in] */ UINT cCategories,
    /* [unique][size_is][in] */ GUID *rpCategory);


void __RPC_STUB IClassAdmin_ChangePackageCategories_Stub(
    IRpcStubBuffer *This,
    IRpcChannelBuffer *_pRpcChannelBuffer,
    PRPC_MESSAGE _pRpcMessage,
    DWORD *_pdwStubPhase);


HRESULT STDMETHODCALLTYPE IClassAdmin_ChangePackageSourceList_Proxy( 
    IClassAdmin * This,
    /* [in] */ LPOLESTR pszPackageName,
    /* [in] */ UINT cSources,
    /* [unique][size_is][in] */ LPOLESTR *pszSourceList);


void __RPC_STUB IClassAdmin_ChangePackageSourceList_Stub(
    IRpcStubBuffer *This,
    IRpcChannelBuffer *_pRpcChannelBuffer,
    PRPC_MESSAGE _pRpcMessage,
    DWORD *_pdwStubPhase);


HRESULT STDMETHODCALLTYPE IClassAdmin_ChangePackageUpgradeList_Proxy( 
    IClassAdmin * This,
    /* [in] */ LPOLESTR pszPackageName,
    /* [in] */ UINT cUpgrades,
    /* [unique][size_is][in] */ UPGRADEINFO *prgUpgradeInfoList);


void __RPC_STUB IClassAdmin_ChangePackageUpgradeList_Stub(
    IRpcStubBuffer *This,
    IRpcChannelBuffer *_pRpcChannelBuffer,
    PRPC_MESSAGE _pRpcMessage,
    DWORD *_pdwStubPhase);


HRESULT STDMETHODCALLTYPE IClassAdmin_ChangePackageUpgradeInfoIncremental_Proxy( 
    IClassAdmin * This,
    /* [in] */ GUID PkgGuid,
    /* [in] */ UPGRADEINFO UpgradeInfo,
    /* [in] */ DWORD OpFlags);


void __RPC_STUB IClassAdmin_ChangePackageUpgradeInfoIncremental_Stub(
    IRpcStubBuffer *This,
    IRpcChannelBuffer *_pRpcChannelBuffer,
    PRPC_MESSAGE _pRpcMessage,
    DWORD *_pdwStubPhase);


HRESULT STDMETHODCALLTYPE IClassAdmin_SetPriorityByFileExt_Proxy( 
    IClassAdmin * This,
    /* [in] */ LPOLESTR pszPackageName,
    /* [in] */ LPOLESTR pszFileExt,
    /* [in] */ UINT Priority);


void __RPC_STUB IClassAdmin_SetPriorityByFileExt_Stub(
    IRpcStubBuffer *This,
    IRpcChannelBuffer *_pRpcChannelBuffer,
    PRPC_MESSAGE _pRpcMessage,
    DWORD *_pdwStubPhase);


HRESULT STDMETHODCALLTYPE IClassAdmin_EnumPackages_Proxy( 
    IClassAdmin * This,
    /* [unique][in] */ LPOLESTR pszFileExt,
    /* [unique][in] */ GUID *pCategory,
    /* [in] */ DWORD dwAppFlags,
    /* [unique][in] */ DWORD *pdwLocale,
    /* [unique][in] */ CSPLATFORM *pPlatform,
    /* [out] */ IEnumPackage **ppIEnumPackage);


void __RPC_STUB IClassAdmin_EnumPackages_Stub(
    IRpcStubBuffer *This,
    IRpcChannelBuffer *_pRpcChannelBuffer,
    PRPC_MESSAGE _pRpcMessage,
    DWORD *_pdwStubPhase);


HRESULT STDMETHODCALLTYPE IClassAdmin_GetPackageDetails_Proxy( 
    IClassAdmin * This,
    /* [in] */ LPOLESTR pszPackageName,
    /* [out] */ PACKAGEDETAIL *pPackageDetail);


void __RPC_STUB IClassAdmin_GetPackageDetails_Stub(
    IRpcStubBuffer *This,
    IRpcChannelBuffer *_pRpcChannelBuffer,
    PRPC_MESSAGE _pRpcMessage,
    DWORD *_pdwStubPhase);


HRESULT STDMETHODCALLTYPE IClassAdmin_GetPackageDetailsFromGuid_Proxy( 
    IClassAdmin * This,
    /* [in] */ GUID PkgGuid,
    /* [out] */ PACKAGEDETAIL *pPackageDetail);


void __RPC_STUB IClassAdmin_GetPackageDetailsFromGuid_Stub(
    IRpcStubBuffer *This,
    IRpcChannelBuffer *_pRpcChannelBuffer,
    PRPC_MESSAGE _pRpcMessage,
    DWORD *_pdwStubPhase);


HRESULT STDMETHODCALLTYPE IClassAdmin_GetAppCategories_Proxy( 
    IClassAdmin * This,
    /* [in] */ LCID Locale,
    /* [out] */ APPCATEGORYINFOLIST *pAppCategoryList);


void __RPC_STUB IClassAdmin_GetAppCategories_Stub(
    IRpcStubBuffer *This,
    IRpcChannelBuffer *_pRpcChannelBuffer,
    PRPC_MESSAGE _pRpcMessage,
    DWORD *_pdwStubPhase);


HRESULT STDMETHODCALLTYPE IClassAdmin_RegisterAppCategory_Proxy( 
    IClassAdmin * This,
    /* [in] */ APPCATEGORYINFO *pAppCategory);


void __RPC_STUB IClassAdmin_RegisterAppCategory_Stub(
    IRpcStubBuffer *This,
    IRpcChannelBuffer *_pRpcChannelBuffer,
    PRPC_MESSAGE _pRpcMessage,
    DWORD *_pdwStubPhase);


HRESULT STDMETHODCALLTYPE IClassAdmin_UnregisterAppCategory_Proxy( 
    IClassAdmin * This,
    /* [in] */ GUID *pAppCategoryId);


void __RPC_STUB IClassAdmin_UnregisterAppCategory_Stub(
    IRpcStubBuffer *This,
    IRpcChannelBuffer *_pRpcChannelBuffer,
    PRPC_MESSAGE _pRpcMessage,
    DWORD *_pdwStubPhase);


HRESULT STDMETHODCALLTYPE IClassAdmin_Cleanup_Proxy( 
    IClassAdmin * This,
    /* [in] */ FILETIME *pTimeBefore);


void __RPC_STUB IClassAdmin_Cleanup_Stub(
    IRpcStubBuffer *This,
    IRpcChannelBuffer *_pRpcChannelBuffer,
    PRPC_MESSAGE _pRpcMessage,
    DWORD *_pdwStubPhase);


HRESULT STDMETHODCALLTYPE IClassAdmin_GetDNFromPackageName_Proxy( 
    IClassAdmin * This,
    /* [in] */ LPOLESTR pszPackageName,
    /* [out] */ LPOLESTR *szDN);


void __RPC_STUB IClassAdmin_GetDNFromPackageName_Stub(
    IRpcStubBuffer *This,
    IRpcChannelBuffer *_pRpcChannelBuffer,
    PRPC_MESSAGE _pRpcMessage,
    DWORD *_pdwStubPhase);


HRESULT STDMETHODCALLTYPE IClassAdmin_RedeployPackage_Proxy( 
    IClassAdmin * This,
    /* [in] */ GUID *pPackageGuid,
    /* [in] */ PACKAGEDETAIL *pPackageDetail);


void __RPC_STUB IClassAdmin_RedeployPackage_Stub(
    IRpcStubBuffer *This,
    IRpcChannelBuffer *_pRpcChannelBuffer,
    PRPC_MESSAGE _pRpcMessage,
    DWORD *_pdwStubPhase);



#endif 	/* __IClassAdmin_INTERFACE_DEFINED__ */


/* interface __MIDL_itf_cs_0013 */
/* [local] */ 

//------------------------- Priorities and weights

// 
// File Extension priority
// 
// 1 bit (0)
//
#define PRI_EXTN_FACTOR        (1 << 0)

//
// CLSCTX priority
//
// 2 bits (7:8)
//
#define PRI_CLSID_INPSVR       (3 << 7)
#define PRI_CLSID_LCLSVR       (2 << 7)
#define PRI_CLSID_REMSVR       (1 << 7)

//
// UI Language priority
//
// 3 bits (9:11)
//
#define PRI_LANG_ALWAYSMATCH   (4 << 9)
#define PRI_LANG_SYSTEMLOCALE  (3 << 9)
#define PRI_LANG_ENGLISH       (2 << 9)
#define PRI_LANG_NEUTRAL       (1 << 9)

//
// Architecture priority
//
// 2 bits (12:13)
//
#define PRI_ARCH_PREF1         (2 << 12)
#define PRI_ARCH_PREF2         (1 << 12)


extern RPC_IF_HANDLE __MIDL_itf_cs_0013_ClientIfHandle;
extern RPC_IF_HANDLE __MIDL_itf_cs_0013_ServerIfHandle;

/* Additional Prototypes for ALL interfaces */

/* end of Additional Prototypes */

#ifdef __cplusplus
}
#endif

#endif
=== C:/Users/treeman/Desktop/windows nt source code\Source\Win2K3\NT\public\internal\ds\inc\crypt.h ===
/*++ BUILD Version: 0001    // Increment this if a change has global effects

Copyright (c) 1989  Microsoft Corporation

Module Name:

    crypt.h

Abstract:

    This module contains the public data structures and API definitions
    needed to utilize the encryption library


Author:

    David Chalmers (Davidc) 21-October-1991

Revision History:

    Scott Field (SField)    09-October-2000
        Add RNG and Memory encryption interfaces

--*/


#ifndef _NTCRYPT_
#define _NTCRYPT_

#ifndef MIDL_PASS    // Don't confuse MIDL

#ifndef RPC_NO_WINDOWS_H // Don't let rpc.h include windows.h
#define RPC_NO_WINDOWS_H
#endif // RPC_NO_WINDOWS_H

#include <rpc.h>
#endif // MIDL_PASS

#ifdef __cplusplus
extern "C" {
#endif

/////////////////////////////////////////////////////////////////////////
//                                                                     //
// Core encryption types                                               //
//                                                                     //
/////////////////////////////////////////////////////////////////////////

// begin_ntsubauth

#define CLEAR_BLOCK_LENGTH          8

typedef struct _CLEAR_BLOCK {
    CHAR    data[CLEAR_BLOCK_LENGTH];
}                                   CLEAR_BLOCK;
typedef CLEAR_BLOCK *               PCLEAR_BLOCK;

#define CYPHER_BLOCK_LENGTH         8

typedef struct _CYPHER_BLOCK {
    CHAR    data[CYPHER_BLOCK_LENGTH];
}                                   CYPHER_BLOCK;
typedef CYPHER_BLOCK *              PCYPHER_BLOCK;
// end_ntsubauth

#define BLOCK_KEY_LENGTH            7

typedef struct _BLOCK_KEY {
    CHAR    data[BLOCK_KEY_LENGTH];
}                                   BLOCK_KEY;
typedef BLOCK_KEY *                 PBLOCK_KEY;




/////////////////////////////////////////////////////////////////////////
//                                                                     //
// Arbitrary length data encryption types                              //
//                                                                     //
/////////////////////////////////////////////////////////////////////////

typedef struct _CRYPT_BUFFER {
    ULONG   Length;         // Number of valid bytes in buffer
    ULONG   MaximumLength;  // Number of bytes pointed to by Buffer
    PVOID   Buffer;
} CRYPT_BUFFER;
typedef CRYPT_BUFFER *  PCRYPT_BUFFER;

typedef CRYPT_BUFFER    CLEAR_DATA;
typedef CLEAR_DATA *    PCLEAR_DATA;

typedef CRYPT_BUFFER    DATA_KEY;
typedef DATA_KEY *      PDATA_KEY;

typedef CRYPT_BUFFER    CYPHER_DATA;
typedef CYPHER_DATA *   PCYPHER_DATA;



/////////////////////////////////////////////////////////////////////////
//                                                                     //
// Lan Manager data types                                              //
//                                                                     //
/////////////////////////////////////////////////////////////////////////


//
// Define a LanManager compatible password
//
// A LanManager password is a null-terminated ansi string consisting of a
// maximum of 14 characters (not including terminator)
//

typedef CHAR *                      PLM_PASSWORD;



//
// Define the result of the 'One Way Function' (OWF) on a LM password
//

#define LM_OWF_PASSWORD_LENGTH      (CYPHER_BLOCK_LENGTH * 2)

// begin_ntsubauth
typedef struct _LM_OWF_PASSWORD {
    CYPHER_BLOCK data[2];
}                                   LM_OWF_PASSWORD;
typedef LM_OWF_PASSWORD *           PLM_OWF_PASSWORD;
// end_ntsubauth



//
// Define the challenge sent by the Lanman server during logon
//

#define LM_CHALLENGE_LENGTH         CLEAR_BLOCK_LENGTH

// begin_ntsubauth
typedef CLEAR_BLOCK                 LM_CHALLENGE;
typedef LM_CHALLENGE *              PLM_CHALLENGE;
// end_ntsubauth



//
// Define the response sent by redirector in response to challenge from server
//

#define LM_RESPONSE_LENGTH          (CYPHER_BLOCK_LENGTH * 3)

typedef struct _LM_RESPONSE {
    CYPHER_BLOCK  data[3];
}                                   LM_RESPONSE;
typedef LM_RESPONSE *               PLM_RESPONSE;



//
// Define the result of the reversible encryption of an OWF'ed password.
//

#define ENCRYPTED_LM_OWF_PASSWORD_LENGTH (CYPHER_BLOCK_LENGTH * 2)

typedef struct _ENCRYPTED_LM_OWF_PASSWORD {
    CYPHER_BLOCK data[2];
}                                   ENCRYPTED_LM_OWF_PASSWORD;
typedef ENCRYPTED_LM_OWF_PASSWORD * PENCRYPTED_LM_OWF_PASSWORD;



//
// Define the session key maintained by the redirector and server
//

#define LM_SESSION_KEY_LENGTH       LM_CHALLENGE_LENGTH

typedef LM_CHALLENGE                LM_SESSION_KEY;
typedef LM_SESSION_KEY *            PLM_SESSION_KEY;



//
// Define the index type used to encrypt OWF Passwords
//

typedef LONG                        CRYPT_INDEX;
typedef CRYPT_INDEX *               PCRYPT_INDEX;



/////////////////////////////////////////////////////////////////////////
//                                                                     //
// 'NT' encryption types that are used to duplicate existing LM        //
//      functionality with improved algorithms.                        //
//                                                                     //
/////////////////////////////////////////////////////////////////////////


typedef UNICODE_STRING              NT_PASSWORD;
typedef NT_PASSWORD *               PNT_PASSWORD;


#define NT_OWF_PASSWORD_LENGTH      LM_OWF_PASSWORD_LENGTH

// begin_ntsubauth
typedef LM_OWF_PASSWORD             NT_OWF_PASSWORD;
typedef NT_OWF_PASSWORD *           PNT_OWF_PASSWORD;
// end_ntsubauth


#define NT_CHALLENGE_LENGTH         LM_CHALLENGE_LENGTH

// begin_ntsubauth
typedef LM_CHALLENGE                NT_CHALLENGE;
typedef NT_CHALLENGE *              PNT_CHALLENGE;
// end_ntsubauth


#define NT_RESPONSE_LENGTH          LM_RESPONSE_LENGTH

typedef LM_RESPONSE                 NT_RESPONSE;
typedef NT_RESPONSE *               PNT_RESPONSE;


#define ENCRYPTED_NT_OWF_PASSWORD_LENGTH ENCRYPTED_LM_OWF_PASSWORD_LENGTH

typedef ENCRYPTED_LM_OWF_PASSWORD   ENCRYPTED_NT_OWF_PASSWORD;
typedef ENCRYPTED_NT_OWF_PASSWORD * PENCRYPTED_NT_OWF_PASSWORD;


#define NT_SESSION_KEY_LENGTH       LM_SESSION_KEY_LENGTH

typedef LM_SESSION_KEY              NT_SESSION_KEY;
typedef NT_SESSION_KEY *            PNT_SESSION_KEY;



/////////////////////////////////////////////////////////////////////////
//                                                                     //
// 'NT' encryption types for new functionality not present in LM       //
//                                                                     //
/////////////////////////////////////////////////////////////////////////


//
// The user session key is similar to the LM and NT session key except it
// is different for each user on the system. This allows it to be used
// for secure user communication with a server.
//
// begin_ntsubauth
#define USER_SESSION_KEY_LENGTH     (CYPHER_BLOCK_LENGTH * 2)

typedef struct _USER_SESSION_KEY {
    CYPHER_BLOCK data[2];
}                                   USER_SESSION_KEY;
typedef USER_SESSION_KEY          * PUSER_SESSION_KEY;
// end_ntsubauth


////////////////////////////////////////////////////////////////////////////
//                                                                        //
// Encryption library API macros                                          //
//                                                                        //
// To conceal the purpose of these functions to someone dumping out the   //
// encryption dll they have been purposefully given unhelpful names.      //
// Each has an associated macro that should be used by system components  //
// to access these routines in a readable way.                            //
//                                                                        //
////////////////////////////////////////////////////////////////////////////

#define RtlEncryptBlock                 SystemFunction001
#define RtlDecryptBlock                 SystemFunction002
#define RtlEncryptStdBlock              SystemFunction003
#define RtlEncryptData                  SystemFunction004
#define RtlDecryptData                  SystemFunction005
#define RtlCalculateLmOwfPassword       SystemFunction006
#define RtlCalculateNtOwfPassword       SystemFunction007
#define RtlCalculateLmResponse          SystemFunction008
#define RtlCalculateNtResponse          SystemFunction009
#define RtlCalculateUserSessionKeyLm    SystemFunction010
#define RtlCalculateUserSessionKeyNt    SystemFunction011
#define RtlEncryptLmOwfPwdWithLmOwfPwd  SystemFunction012
#define RtlDecryptLmOwfPwdWithLmOwfPwd  SystemFunction013
#define RtlEncryptNtOwfPwdWithNtOwfPwd  SystemFunction014
#define RtlDecryptNtOwfPwdWithNtOwfPwd  SystemFunction015
#define RtlEncryptLmOwfPwdWithLmSesKey  SystemFunction016
#define RtlDecryptLmOwfPwdWithLmSesKey  SystemFunction017
#define RtlEncryptNtOwfPwdWithNtSesKey  SystemFunction018
#define RtlDecryptNtOwfPwdWithNtSesKey  SystemFunction019
#define RtlEncryptLmOwfPwdWithUserKey   SystemFunction020
#define RtlDecryptLmOwfPwdWithUserKey   SystemFunction021
#define RtlEncryptNtOwfPwdWithUserKey   SystemFunction022
#define RtlDecryptNtOwfPwdWithUserKey   SystemFunction023
#define RtlEncryptLmOwfPwdWithIndex     SystemFunction024
#define RtlDecryptLmOwfPwdWithIndex     SystemFunction025
#define RtlEncryptNtOwfPwdWithIndex     SystemFunction026
#define RtlDecryptNtOwfPwdWithIndex     SystemFunction027
#define RtlGetUserSessionKeyClient      SystemFunction028
#define RtlGetUserSessionKeyServer      SystemFunction029
#define RtlEqualLmOwfPassword           SystemFunction030
#define RtlEqualNtOwfPassword           SystemFunction031
#define RtlEncryptData2                 SystemFunction032
#define RtlDecryptData2                 SystemFunction033
#define RtlGetUserSessionKeyClientBinding SystemFunction034
#define RtlCheckSignatureInFile         SystemFunction035

#define RtlGenRandom                    SystemFunction036
// begin_ntsecapi
#define RtlEncryptMemory                SystemFunction040
#define RtlDecryptMemory                SystemFunction041
// end_ntsecapi


////////////////////////////////////////////////////////////////////////////
//                                                                        //
// Encryption library API function prototypes                             //
//                                                                        //
////////////////////////////////////////////////////////////////////////////


//
// Core block encryption functions
//

NTSTATUS
RtlEncryptBlock(
    IN PCLEAR_BLOCK ClearBlock,
    IN PBLOCK_KEY BlockKey,
    OUT PCYPHER_BLOCK CypherBlock
    );

NTSTATUS
RtlDecryptBlock(
    IN PCYPHER_BLOCK CypherBlock,
    IN PBLOCK_KEY BlockKey,
    OUT PCLEAR_BLOCK ClearBlock
    );

NTSTATUS
RtlEncryptStdBlock(
    IN PBLOCK_KEY BlockKey,
    OUT PCYPHER_BLOCK CypherBlock
    );

//
// Arbitrary length data encryption functions
//

NTSTATUS
RtlEncryptData(
    IN PCLEAR_DATA ClearData,
    IN PDATA_KEY DataKey,
    OUT PCYPHER_DATA CypherData
    );

NTSTATUS
RtlDecryptData(
    IN PCYPHER_DATA CypherData,
    IN PDATA_KEY DataKey,
    OUT PCLEAR_DATA ClearData
    );

//
// Faster arbitrary length data encryption functions (using RC4)
//

NTSTATUS
RtlEncryptData2(
    IN OUT PCRYPT_BUFFER    pData,
    IN PDATA_KEY            pKey
    );

NTSTATUS
RtlDecryptData2(
    IN OUT PCRYPT_BUFFER    pData,
    IN PDATA_KEY            pKey
    );

//
// Password hashing functions (One Way Function)
//

NTSTATUS
RtlCalculateLmOwfPassword(
    IN PLM_PASSWORD LmPassword,
    OUT PLM_OWF_PASSWORD LmOwfPassword
    );

NTSTATUS
RtlCalculateNtOwfPassword(
    IN PNT_PASSWORD NtPassword,
    OUT PNT_OWF_PASSWORD NtOwfPassword
    );



//
// OWF password comparison functions
//

BOOLEAN
RtlEqualLmOwfPassword(
    IN PLM_OWF_PASSWORD LmOwfPassword1,
    IN PLM_OWF_PASSWORD LmOwfPassword2
    );

BOOLEAN
RtlEqualNtOwfPassword(
    IN PNT_OWF_PASSWORD NtOwfPassword1,
    IN PNT_OWF_PASSWORD NtOwfPassword2
    );



//
// Functions for calculating response to server challenge
//

NTSTATUS
RtlCalculateLmResponse(
    IN PLM_CHALLENGE LmChallenge,
    IN PLM_OWF_PASSWORD LmOwfPassword,
    OUT PLM_RESPONSE LmResponse
    );


NTSTATUS
RtlCalculateNtResponse(
    IN PNT_CHALLENGE NtChallenge,
    IN PNT_OWF_PASSWORD NtOwfPassword,
    OUT PNT_RESPONSE NtResponse
    );




//
// Functions for calculating User Session Key.
//

//
// Calculate a User Session Key from LM data
//
NTSTATUS
RtlCalculateUserSessionKeyLm(
    IN PLM_RESPONSE LmResponse,
    IN PLM_OWF_PASSWORD LmOwfPassword,
    OUT PUSER_SESSION_KEY UserSessionKey
    );

//
// Calculate a User Session Key from NT data
//
NTSTATUS
RtlCalculateUserSessionKeyNt(
    IN PNT_RESPONSE NtResponse,
    IN PNT_OWF_PASSWORD NtOwfPassword,
    OUT PUSER_SESSION_KEY UserSessionKey
    );





//
// OwfPassword encryption functions
//


//
// Encrypt OwfPassword using OwfPassword as the key
//
NTSTATUS
RtlEncryptLmOwfPwdWithLmOwfPwd(
    IN PLM_OWF_PASSWORD DataLmOwfPassword,
    IN PLM_OWF_PASSWORD KeyLmOwfPassword,
    OUT PENCRYPTED_LM_OWF_PASSWORD EncryptedLmOwfPassword
    );

NTSTATUS
RtlDecryptLmOwfPwdWithLmOwfPwd(
    IN PENCRYPTED_LM_OWF_PASSWORD EncryptedLmOwfPassword,
    IN PLM_OWF_PASSWORD KeyLmOwfPassword,
    OUT PLM_OWF_PASSWORD DataLmOwfPassword
    );


NTSTATUS
RtlEncryptNtOwfPwdWithNtOwfPwd(
    IN PNT_OWF_PASSWORD DataNtOwfPassword,
    IN PNT_OWF_PASSWORD KeyNtOwfPassword,
    OUT PENCRYPTED_NT_OWF_PASSWORD EncryptedNtOwfPassword
    );

NTSTATUS
RtlDecryptNtOwfPwdWithNtOwfPwd(
    IN PENCRYPTED_NT_OWF_PASSWORD EncryptedNtOwfPassword,
    IN PNT_OWF_PASSWORD KeyNtOwfPassword,
    OUT PNT_OWF_PASSWORD DataNtOwfPassword
    );


//
// Encrypt OwfPassword using SessionKey as the key
//
NTSTATUS
RtlEncryptLmOwfPwdWithLmSesKey(
    IN PLM_OWF_PASSWORD LmOwfPassword,
    IN PLM_SESSION_KEY LmSessionKey,
    OUT PENCRYPTED_LM_OWF_PASSWORD EncryptedLmOwfPassword
    );

NTSTATUS
RtlDecryptLmOwfPwdWithLmSesKey(
    IN PENCRYPTED_LM_OWF_PASSWORD EncryptedLmOwfPassword,
    IN PLM_SESSION_KEY LmSessionKey,
    OUT PLM_OWF_PASSWORD LmOwfPassword
    );


NTSTATUS
RtlEncryptNtOwfPwdWithNtSesKey(
    IN PNT_OWF_PASSWORD NtOwfPassword,
    IN PNT_SESSION_KEY NtSessionKey,
    OUT PENCRYPTED_NT_OWF_PASSWORD EncryptedNtOwfPassword
    );

NTSTATUS
RtlDecryptNtOwfPwdWithNtSesKey(
    IN PENCRYPTED_NT_OWF_PASSWORD EncryptedNtOwfPassword,
    IN PNT_SESSION_KEY NtSessionKey,
    OUT PNT_OWF_PASSWORD NtOwfPassword
    );


//
// Encrypt OwfPassword using UserSessionKey as the key
//
NTSTATUS
RtlEncryptLmOwfPwdWithUserKey(
    IN PLM_OWF_PASSWORD LmOwfPassword,
    IN PUSER_SESSION_KEY UserSessionKey,
    OUT PENCRYPTED_LM_OWF_PASSWORD EncryptedLmOwfPassword
    );

NTSTATUS
RtlDecryptLmOwfPwdWithUserKey(
    IN PENCRYPTED_LM_OWF_PASSWORD EncryptedLmOwfPassword,
    IN PUSER_SESSION_KEY UserSessionKey,
    OUT PLM_OWF_PASSWORD LmOwfPassword
    );

NTSTATUS
RtlEncryptNtOwfPwdWithUserKey(
    IN PNT_OWF_PASSWORD NtOwfPassword,
    IN PUSER_SESSION_KEY UserSessionKey,
    OUT PENCRYPTED_NT_OWF_PASSWORD EncryptedNtOwfPassword
    );

NTSTATUS
RtlDecryptNtOwfPwdWithUserKey(
    IN PENCRYPTED_NT_OWF_PASSWORD EncryptedNtOwfPassword,
    IN PUSER_SESSION_KEY UserSessionKey,
    OUT PNT_OWF_PASSWORD NtOwfPassword
    );


//
// Encrypt OwfPassword using an index as the key
//
NTSTATUS
RtlEncryptLmOwfPwdWithIndex(
    IN PLM_OWF_PASSWORD LmOwfPassword,
    IN PCRYPT_INDEX Index,
    OUT PENCRYPTED_LM_OWF_PASSWORD EncryptedLmOwfPassword
    );

NTSTATUS
RtlDecryptLmOwfPwdWithIndex(
    IN PENCRYPTED_LM_OWF_PASSWORD EncryptedLmOwfPassword,
    IN PCRYPT_INDEX Index,
    OUT PLM_OWF_PASSWORD LmOwfPassword
    );


NTSTATUS
RtlEncryptNtOwfPwdWithIndex(
    IN PNT_OWF_PASSWORD NtOwfPassword,
    IN PCRYPT_INDEX Index,
    OUT PENCRYPTED_NT_OWF_PASSWORD EncryptedNtOwfPassword
    );

NTSTATUS
RtlDecryptNtOwfPwdWithIndex(
    IN PENCRYPTED_NT_OWF_PASSWORD EncryptedNtOwfPassword,
    IN PCRYPT_INDEX Index,
    OUT PNT_OWF_PASSWORD NtOwfPassword
    );

ULONG
RtlCheckSignatureInFile(
    IN PWSTR File
    );

BOOLEAN
RtlGenRandom(
    OUT PVOID RandomBuffer,
    IN  ULONG RandomBufferLength
    );

// begin_ntsecapi

//
// The buffer passed into RtlEncryptMemory and RtlDecryptMemory
// must be a multiple of this length.
//

#define RTL_ENCRYPT_MEMORY_SIZE             8

//
// Allow Encrypt/Decrypt across process boundaries.
// eg: encrypted buffer passed across LPC to another process which calls RtlDecryptMemory.
//

#define RTL_ENCRYPT_OPTION_CROSS_PROCESS    0x01

//
// Allow Encrypt/Decrypt across callers with same LogonId.
// eg: encrypted buffer passed across LPC to another process which calls RtlDecryptMemory whilst impersonating.
//

#define RTL_ENCRYPT_OPTION_SAME_LOGON       0x02

NTSTATUS
RtlEncryptMemory(
    IN OUT  PVOID Memory,
    IN      ULONG MemoryLength,
    IN      ULONG OptionFlags
    );

NTSTATUS
RtlDecryptMemory(
    IN OUT  PVOID Memory,
    IN      ULONG MemoryLength,
    IN      ULONG OptionFlags
    );
    
// end_ntsecapi


//
// Get the user session key for an RPC connection
//

#ifndef MIDL_PASS    // Don't confuse MIDL
NTSTATUS
RtlGetUserSessionKeyClient(
    IN PVOID RpcContextHandle,
    OUT PUSER_SESSION_KEY UserSessionKey
    );

NTSTATUS
RtlGetUserSessionKeyClientBinding(
    IN PVOID RpcBindingHandle,
    OUT HANDLE *RedirHandle,
    OUT PUSER_SESSION_KEY UserSessionKey
    );

NTSTATUS
RtlGetUserSessionKeyServer(
    IN PVOID RpcContextHandle OPTIONAL,
    OUT PUSER_SESSION_KEY UserSessionKey
    );
#endif // MIDL_PASS

#ifdef __cplusplus
}   // extern "C"
#endif

#endif // _NTCRYPT_
=== C:/Users/treeman/Desktop/windows nt source code\Source\Win2K3\NT\public\internal\ds\inc\dns.h ===
/*++

Copyright (c) 1996-2000  Microsoft Corporation

Module Name:

    dns.h

Abstract:

    Domain Name System (DNS)

    General DNS definitions.

Author:

    Jim Gilroy (jamesg)     December 7, 1996

Revision History:

--*/


#ifndef _DNS_INCLUDED_
#define _DNS_INCLUDED_

//
//  Note:  this file is dead!  DO NOT INCLUDE!!!
//

#include <dnsapi.h>

#endif // _DNS_INCLUDED_
=== C:/Users/treeman/Desktop/windows nt source code\Source\Win2K3\NT\public\internal\ds\inc\dirsync.h ===
#pragma warning( disable: 4049 )  /* more than 64k source lines */

/* this ALWAYS GENERATED file contains the definitions for the interfaces */


 /* File created by MIDL compiler version 6.00.0334 */
/* Compiler settings for dirsync.idl:
    Oicf, W1, Zp8, env=Win32 (32b run)
    protocol : dce , ms_ext, c_ext, robust
    error checks: allocation ref bounds_check enum stub_data 
    VC __declspec() decoration level: 
         __declspec(uuid()), __declspec(selectany), __declspec(novtable)
         DECLSPEC_UUID(), MIDL_INTERFACE()
*/
//@@MIDL_FILE_HEADING(  )


/* verify that the <rpcndr.h> version is high enough to compile this file*/
#ifndef __REQUIRED_RPCNDR_H_VERSION__
#define __REQUIRED_RPCNDR_H_VERSION__ 475
#endif

#include "rpc.h"
#include "rpcndr.h"

#ifndef __RPCNDR_H_VERSION__
#error this stub requires an updated version of <rpcndr.h>
#endif // __RPCNDR_H_VERSION__

#ifndef COM_NO_WINDOWS_H
#include "windows.h"
#include "ole2.h"
#endif /*COM_NO_WINDOWS_H*/

#ifndef __dirsync_h__
#define __dirsync_h__

#if defined(_MSC_VER) && (_MSC_VER >= 1020)
#pragma once
#endif

/* Forward Declarations */ 

#ifndef __IDirsyncLog_FWD_DEFINED__
#define __IDirsyncLog_FWD_DEFINED__
typedef interface IDirsyncLog IDirsyncLog;
#endif 	/* __IDirsyncLog_FWD_DEFINED__ */


#ifndef __IDirsyncStatus_FWD_DEFINED__
#define __IDirsyncStatus_FWD_DEFINED__
typedef interface IDirsyncStatus IDirsyncStatus;
#endif 	/* __IDirsyncStatus_FWD_DEFINED__ */


#ifndef __IDirsyncDatabase_FWD_DEFINED__
#define __IDirsyncDatabase_FWD_DEFINED__
typedef interface IDirsyncDatabase IDirsyncDatabase;
#endif 	/* __IDirsyncDatabase_FWD_DEFINED__ */


#ifndef __IDirsyncDatabaseTable_FWD_DEFINED__
#define __IDirsyncDatabaseTable_FWD_DEFINED__
typedef interface IDirsyncDatabaseTable IDirsyncDatabaseTable;
#endif 	/* __IDirsyncDatabaseTable_FWD_DEFINED__ */


#ifndef __IEnumDirsyncSession_FWD_DEFINED__
#define __IEnumDirsyncSession_FWD_DEFINED__
typedef interface IEnumDirsyncSession IEnumDirsyncSession;
#endif 	/* __IEnumDirsyncSession_FWD_DEFINED__ */


#ifndef __IDirsyncSessionManager_FWD_DEFINED__
#define __IDirsyncSessionManager_FWD_DEFINED__
typedef interface IDirsyncSessionManager IDirsyncSessionManager;
#endif 	/* __IDirsyncSessionManager_FWD_DEFINED__ */


#ifndef __IDirsyncObjectMapper_FWD_DEFINED__
#define __IDirsyncObjectMapper_FWD_DEFINED__
typedef interface IDirsyncObjectMapper IDirsyncObjectMapper;
#endif 	/* __IDirsyncObjectMapper_FWD_DEFINED__ */


#ifndef __IEnumDirsyncFailedObjectList_FWD_DEFINED__
#define __IEnumDirsyncFailedObjectList_FWD_DEFINED__
typedef interface IEnumDirsyncFailedObjectList IEnumDirsyncFailedObjectList;
#endif 	/* __IEnumDirsyncFailedObjectList_FWD_DEFINED__ */


#ifndef __IDirsyncFailedObjectList_FWD_DEFINED__
#define __IDirsyncFailedObjectList_FWD_DEFINED__
typedef interface IDirsyncFailedObjectList IDirsyncFailedObjectList;
#endif 	/* __IDirsyncFailedObjectList_FWD_DEFINED__ */


#ifndef __IDirsyncNamespaceMapping_FWD_DEFINED__
#define __IDirsyncNamespaceMapping_FWD_DEFINED__
typedef interface IDirsyncNamespaceMapping IDirsyncNamespaceMapping;
#endif 	/* __IDirsyncNamespaceMapping_FWD_DEFINED__ */


#ifndef __IDirsyncSession_FWD_DEFINED__
#define __IDirsyncSession_FWD_DEFINED__
typedef interface IDirsyncSession IDirsyncSession;
#endif 	/* __IDirsyncSession_FWD_DEFINED__ */


#ifndef __IDirsyncSessionCallback_FWD_DEFINED__
#define __IDirsyncSessionCallback_FWD_DEFINED__
typedef interface IDirsyncSessionCallback IDirsyncSessionCallback;
#endif 	/* __IDirsyncSessionCallback_FWD_DEFINED__ */


#ifndef __IDirsyncWriteProvider_FWD_DEFINED__
#define __IDirsyncWriteProvider_FWD_DEFINED__
typedef interface IDirsyncWriteProvider IDirsyncWriteProvider;
#endif 	/* __IDirsyncWriteProvider_FWD_DEFINED__ */


#ifndef __IDirsyncServer_FWD_DEFINED__
#define __IDirsyncServer_FWD_DEFINED__
typedef interface IDirsyncServer IDirsyncServer;
#endif 	/* __IDirsyncServer_FWD_DEFINED__ */


#ifndef __IDirsyncReadProvider_FWD_DEFINED__
#define __IDirsyncReadProvider_FWD_DEFINED__
typedef interface IDirsyncReadProvider IDirsyncReadProvider;
#endif 	/* __IDirsyncReadProvider_FWD_DEFINED__ */


#ifndef __IDirsyncNamespaceMapper_FWD_DEFINED__
#define __IDirsyncNamespaceMapper_FWD_DEFINED__
typedef interface IDirsyncNamespaceMapper IDirsyncNamespaceMapper;
#endif 	/* __IDirsyncNamespaceMapper_FWD_DEFINED__ */


#ifndef __IDirsyncAttributeMapper_FWD_DEFINED__
#define __IDirsyncAttributeMapper_FWD_DEFINED__
typedef interface IDirsyncAttributeMapper IDirsyncAttributeMapper;
#endif 	/* __IDirsyncAttributeMapper_FWD_DEFINED__ */


#ifndef __DirsyncServer_FWD_DEFINED__
#define __DirsyncServer_FWD_DEFINED__

#ifdef __cplusplus
typedef class DirsyncServer DirsyncServer;
#else
typedef struct DirsyncServer DirsyncServer;
#endif /* __cplusplus */

#endif 	/* __DirsyncServer_FWD_DEFINED__ */


/* header files for imported files */
#include "oaidl.h"
#include "iads.h"

#ifdef __cplusplus
extern "C"{
#endif 

void * __RPC_USER MIDL_user_allocate(size_t);
void __RPC_USER MIDL_user_free( void * ); 

/* interface __MIDL_itf_dirsync_0000 */
/* [local] */ 

#define	MAX_SESSION	( 128 )

#define	SCHEDULE_SIZE	( 84 )

#define	LOG_NUM_VALUE	( 16 )

typedef LPWSTR PWSTR;

typedef CHAR *PCHAR;

typedef BYTE *PBYTE;

typedef struct _DirsyncDBValue
    {
    BYTE *pByte;
    DWORD dwLength;
    } 	DirsyncDBValue;

typedef struct _DirsyncDBValue *PDirsyncDBValue;

typedef 
enum _DBTYPE
    {	DBTYPE_STRING	= 0,
	DBTYPE_LONGSTRING	= DBTYPE_STRING + 1,
	DBTYPE_GUID	= DBTYPE_LONGSTRING + 1,
	DBTYPE_OCTETSTRING	= DBTYPE_GUID + 1,
	DBTYPE_DWORD	= DBTYPE_OCTETSTRING + 1,
	DBTYPE_BOOLEAN	= DBTYPE_DWORD + 1
    } 	DBTYPE;

typedef 
enum _UPDATETYPE
    {	INSERT_ROW	= 1,
	REPLACE_ROW	= INSERT_ROW + 1
    } 	UPDATETYPE;

typedef 
enum _RETRYTYPE
    {	RT_NORETRY	= 0,
	RT_SESSIONRETRY	= RT_NORETRY + 1,
	RT_AUTORETRY	= RT_SESSIONRETRY + 1
    } 	RETRYTYPE;

typedef 
enum _SYNCDIRECTION
    {	SYNC_FORWARD	= 1,
	SYNC_REVERSE	= SYNC_FORWARD + 1
    } 	SYNCDIRECTION;

typedef 
enum _SYNCPROVIDER
    {	SUBSCRIBER	= 0,
	PUBLISHER	= 1
    } 	SYNCPROVIDER;

typedef 
enum _PROVIDERTYPE
    {	READ_PROVIDER	= 0,
	WRITE_PROVIDER	= READ_PROVIDER + 1,
	READWRITE_PROVIDER	= WRITE_PROVIDER + 1,
	OBJECT_MAPPER	= READWRITE_PROVIDER + 1
    } 	PROVIDERTYPE;

typedef 
enum _CUSTOMMAPPERTYPE
    {	ATTRIBUTE_MAPPER	= 0,
	NAMESPACE_MAPPER	= ATTRIBUTE_MAPPER + 1
    } 	CUSTOMMAPPERTYPE;

typedef 
enum _OBJECTACTION
    {	OBJECT_ADD	= 1,
	OBJECT_DELETE	= OBJECT_ADD + 1,
	OBJECT_MOVE	= OBJECT_DELETE + 1,
	OBJECT_MODIFY	= OBJECT_MOVE + 1,
	OBJECT_UPDATE	= OBJECT_MODIFY + 1,
	OBJECT_DELETE_RECURSIVE	= OBJECT_UPDATE + 1
    } 	OBJECTACTION;

typedef 
enum _ATTRACTION
    {	ATTR_INVALID	= 0,
	ATTR_REPLACE	= ATTR_INVALID + 1,
	ATTR_APPEND	= ATTR_REPLACE + 1,
	ATTR_DELETE	= ATTR_APPEND + 1,
	ATTR_CLEAR	= ATTR_DELETE + 1
    } 	ATTRACTION;

typedef 
enum _ATTRTYPE
    {	ATTR_TYPE_INVALID	= 0,
	ATTR_TYPE_BINARY	= ATTR_TYPE_INVALID + 1,
	ATTR_TYPE_UNICODE	= ATTR_TYPE_BINARY + 1,
	ATTR_TYPE_DN	= ATTR_TYPE_UNICODE + 1,
	ATTR_TYPE_INTEGER	= ATTR_TYPE_DN + 1,
	ATTR_TYPE_LARGEINTEGER	= ATTR_TYPE_INTEGER + 1,
	ATTR_TYPE_UTCTIME	= ATTR_TYPE_LARGEINTEGER + 1,
	ATTR_TYPE_BOOLEAN	= ATTR_TYPE_UTCTIME + 1,
	ATTR_TYPE_EMAIL	= ATTR_TYPE_BOOLEAN + 1,
	ATTR_TYPE_POSTALADDRESS	= ATTR_TYPE_EMAIL + 1,
	ATTR_TYPE_FAXNUMBER	= ATTR_TYPE_POSTALADDRESS + 1
    } 	ATTRTYPE;

typedef struct _BINVAL
    {
    DWORD dwLen;
    /* [size_is] */ PBYTE pVal;
    } 	BINVAL;

typedef struct _BINVAL *PBINVAL;

typedef struct _DIRSYNCVAL
    {
    /* [size_is] */ PBYTE pVal;
    DWORD dwLen;
    /* [size_is] */ PBYTE pObjectId;
    DWORD cbObjectId;
    } 	DIRSYNCVAL;

typedef struct _DIRSYNCVAL *PDIRSYNCVAL;

typedef struct _DIRSYNCATTRIBUTE
    {
    PWSTR pszName;
    ATTRTYPE attrType;
    ATTRACTION action;
    DWORD cVal;
    /* [size_is] */ PDIRSYNCVAL rgVal;
    } 	DIRSYNCATTRIBUTE;

typedef struct _DIRSYNCATTRIBUTE *PDIRSYNCATTRIBUTE;

typedef struct _DIRSYNCOBJECT
    {
    DWORD dwSize;
    PWSTR pszSourceDN;
    PWSTR pszTargetDN;
    PWSTR pszSourceOldDN;
    PWSTR pszTargetOldDN;
    PWSTR pszObjClass;
    /* [size_is] */ PBYTE pObjectId;
    DWORD cbObjectId;
    /* [size_is] */ PBYTE pTgtObjectId;
    DWORD cbTgtObjectId;
    /* [size_is] */ PBYTE pParentId;
    DWORD cbParentId;
    OBJECTACTION action;
    DWORD cAttr;
    /* [size_is] */ PDIRSYNCATTRIBUTE rgAttr;
    } 	DIRSYNCOBJECT;

typedef struct _DIRSYNCOBJECT *PDIRSYNCOBJECT;

typedef 
enum _PASSWORDTYPE
    {	PT_SPECIFIED	= 0,
	PT_USERNAME	= PT_SPECIFIED + 1,
	PT_RANDOM	= PT_USERNAME + 1,
	PASSWORDTYPE_BADVALUE	= PT_RANDOM + 1
    } 	PASSWORDTYPE;

typedef struct PASSWORDOPTIONS
    {
    PASSWORDTYPE passwordType;
    PWSTR pszPassword;
    } 	PASSWORDOPTIONS;

typedef struct _FAILEDOBJECT
    {
    PWSTR pszID;
    PDIRSYNCOBJECT pObject;
    DWORD dwRetryCount;
    LARGE_INTEGER timeLastSync;
    HRESULT hrLastSync;
    BOOL fAutoRetry;
    SYNCDIRECTION syncDirection;
    } 	FAILEDOBJECT;

typedef /* [allocate][allocate] */ struct _FAILEDOBJECT *PFAILEDOBJECT;

typedef struct _SESSIONDATA
    {
    DWORD dwFields;
    PWSTR pszName;
    PWSTR pszComments;
    DWORD dwFlags;
    DWORD dwLogLevel;
    BYTE pScheduleForward[ 84 ];
    BYTE pScheduleReverse[ 84 ];
    PWSTR pszSourceDirType;
    PWSTR pszSourceServer;
    PWSTR pszSourceUserName;
    PWSTR pszSourcePassword;
    PWSTR pszSourceBase;
    DWORD dwSourceScope;
    PWSTR pszSourceFilter;
    PASSWORDOPTIONS SourcePwdOptions;
    PWSTR pszTargetDirType;
    PWSTR pszTargetServer;
    PWSTR pszTargetUserName;
    PWSTR pszTargetPassword;
    PWSTR pszTargetBase;
    DWORD dwTargetScope;
    PWSTR pszTargetFilter;
    PASSWORDOPTIONS TargetPwdOptions;
    BINVAL bvalMapForward;
    BINVAL bvalMapBackward;
    BINVAL bvalNamespaceMap;
    } 	SESSIONDATA;

typedef struct _SESSIONDATA *PSESSIONDATA;

typedef struct _GLOBAL_SESSIONID
    {
    PWSTR pszServer;
    DWORD dwID;
    } 	GLOBAL_SESSIONID;

typedef struct _GLOBAL_SESSIONID *PGLOBAL_SESSIONID;

typedef 
enum _LOGVALUETYPE
    {	LOG_VALUETYPE_STRING	= 0,
	LOG_VALUETYPE_INTEGER_10	= LOG_VALUETYPE_STRING + 1,
	LOG_VALUETYPE_INTEGER_16	= LOG_VALUETYPE_INTEGER_10 + 1,
	LOG_VALUETYPE_WIN32_ERROR	= LOG_VALUETYPE_INTEGER_16 + 1,
	LOG_VALUETYPE_HRESULT	= LOG_VALUETYPE_WIN32_ERROR + 1,
	LOG_VALUETYPE_GUID	= LOG_VALUETYPE_HRESULT + 1,
	LOG_VALUETYPE_EXTENDED_ERROR	= LOG_VALUETYPE_GUID + 1
    } 	LOGVALUETYPE;

typedef struct _LOGVALUE
    {
    LOGVALUETYPE logValueType;
    union 
        {
        PWSTR pszString;
        DWORD dwInteger10;
        DWORD dwInteger16;
        DWORD dwWin32Error;
        HRESULT hResult;
        LPGUID pGuid;
        } 	;
    } 	LOGVALUE;

typedef struct _LOGVALUE *PLOGVALUE;

typedef struct _LOGPARAM
    {
    HANDLE hInstance;
    DWORD dwEventType;
    DWORD dwSessionId;
    DWORD dwMsgId;
    DWORD dwCount;
    LOGVALUE logValue[ 16 ];
    DWORD cbData;
    PBYTE pData;
    } 	LOGPARAM;

typedef struct _LOGPARAM *PLOGPARAM;

typedef struct COLLECTRPCDATA
    {
    long ObjectType;
    long dwInstances;
    long dwCounters;
    /* [size_is] */ PWSTR *rgpszInstanceName;
    long dwDataSize;
    /* [size_is] */ byte *pbData;
    } 	CollectRpcData;



extern RPC_IF_HANDLE __MIDL_itf_dirsync_0000_v0_0_c_ifspec;
extern RPC_IF_HANDLE __MIDL_itf_dirsync_0000_v0_0_s_ifspec;

#ifndef __IDirsyncLog_INTERFACE_DEFINED__
#define __IDirsyncLog_INTERFACE_DEFINED__

/* interface IDirsyncLog */
/* [unique][helpstring][uuid][local][object] */ 


EXTERN_C const IID IID_IDirsyncLog;

#if defined(__cplusplus) && !defined(CINTERFACE)
    
    MIDL_INTERFACE("1381ef2c-c28c-11d1-a407-00c04fb950dc")
    IDirsyncLog : public IUnknown
    {
    public:
        virtual HRESULT STDMETHODCALLTYPE SetLevel( 
            /* [in] */ DWORD dwSessionID,
            /* [in] */ DWORD dwLogLevel) = 0;
        
        virtual HRESULT STDMETHODCALLTYPE GetLevel( 
            /* [in] */ DWORD dwSessionID,
            /* [out] */ DWORD *pdwLogLevel) = 0;
        
        virtual HRESULT STDMETHODCALLTYPE RemoveLevel( 
            /* [in] */ DWORD dwSessionID) = 0;
        
        virtual HRESULT STDMETHODCALLTYPE LogEvent( 
            /* [in] */ HANDLE handle,
            /* [in] */ DWORD dwEventType,
            /* [in] */ DWORD dwSessionID,
            /* [in] */ DWORD dwMsgId,
            /* [in] */ DWORD dwNumStrings,
            /* [in] */ LPCWSTR *rgszMsgString,
            /* [in] */ DWORD dwDataSize,
            /* [in] */ PBYTE pRawData) = 0;
        
        virtual HRESULT STDMETHODCALLTYPE LogEventEx( 
            /* [in] */ PLOGPARAM pLogParam) = 0;
        
    };
    
#else 	/* C style interface */

    typedef struct IDirsyncLogVtbl
    {
        BEGIN_INTERFACE
        
        HRESULT ( STDMETHODCALLTYPE *QueryInterface )( 
            IDirsyncLog * This,
            /* [in] */ REFIID riid,
            /* [iid_is][out] */ void **ppvObject);
        
        ULONG ( STDMETHODCALLTYPE *AddRef )( 
            IDirsyncLog * This);
        
        ULONG ( STDMETHODCALLTYPE *Release )( 
            IDirsyncLog * This);
        
        HRESULT ( STDMETHODCALLTYPE *SetLevel )( 
            IDirsyncLog * This,
            /* [in] */ DWORD dwSessionID,
            /* [in] */ DWORD dwLogLevel);
        
        HRESULT ( STDMETHODCALLTYPE *GetLevel )( 
            IDirsyncLog * This,
            /* [in] */ DWORD dwSessionID,
            /* [out] */ DWORD *pdwLogLevel);
        
        HRESULT ( STDMETHODCALLTYPE *RemoveLevel )( 
            IDirsyncLog * This,
            /* [in] */ DWORD dwSessionID);
        
        HRESULT ( STDMETHODCALLTYPE *LogEvent )( 
            IDirsyncLog * This,
            /* [in] */ HANDLE handle,
            /* [in] */ DWORD dwEventType,
            /* [in] */ DWORD dwSessionID,
            /* [in] */ DWORD dwMsgId,
            /* [in] */ DWORD dwNumStrings,
            /* [in] */ LPCWSTR *rgszMsgString,
            /* [in] */ DWORD dwDataSize,
            /* [in] */ PBYTE pRawData);
        
        HRESULT ( STDMETHODCALLTYPE *LogEventEx )( 
            IDirsyncLog * This,
            /* [in] */ PLOGPARAM pLogParam);
        
        END_INTERFACE
    } IDirsyncLogVtbl;

    interface IDirsyncLog
    {
        CONST_VTBL struct IDirsyncLogVtbl *lpVtbl;
    };

    

#ifdef COBJMACROS


#define IDirsyncLog_QueryInterface(This,riid,ppvObject)	\
    (This)->lpVtbl -> QueryInterface(This,riid,ppvObject)

#define IDirsyncLog_AddRef(This)	\
    (This)->lpVtbl -> AddRef(This)

#define IDirsyncLog_Release(This)	\
    (This)->lpVtbl -> Release(This)


#define IDirsyncLog_SetLevel(This,dwSessionID,dwLogLevel)	\
    (This)->lpVtbl -> SetLevel(This,dwSessionID,dwLogLevel)

#define IDirsyncLog_GetLevel(This,dwSessionID,pdwLogLevel)	\
    (This)->lpVtbl -> GetLevel(This,dwSessionID,pdwLogLevel)

#define IDirsyncLog_RemoveLevel(This,dwSessionID)	\
    (This)->lpVtbl -> RemoveLevel(This,dwSessionID)

#define IDirsyncLog_LogEvent(This,handle,dwEventType,dwSessionID,dwMsgId,dwNumStrings,rgszMsgString,dwDataSize,pRawData)	\
    (This)->lpVtbl -> LogEvent(This,handle,dwEventType,dwSessionID,dwMsgId,dwNumStrings,rgszMsgString,dwDataSize,pRawData)

#define IDirsyncLog_LogEventEx(This,pLogParam)	\
    (This)->lpVtbl -> LogEventEx(This,pLogParam)

#endif /* COBJMACROS */


#endif 	/* C style interface */



HRESULT STDMETHODCALLTYPE IDirsyncLog_SetLevel_Proxy( 
    IDirsyncLog * This,
    /* [in] */ DWORD dwSessionID,
    /* [in] */ DWORD dwLogLevel);


void __RPC_STUB IDirsyncLog_SetLevel_Stub(
    IRpcStubBuffer *This,
    IRpcChannelBuffer *_pRpcChannelBuffer,
    PRPC_MESSAGE _pRpcMessage,
    DWORD *_pdwStubPhase);


HRESULT STDMETHODCALLTYPE IDirsyncLog_GetLevel_Proxy( 
    IDirsyncLog * This,
    /* [in] */ DWORD dwSessionID,
    /* [out] */ DWORD *pdwLogLevel);


void __RPC_STUB IDirsyncLog_GetLevel_Stub(
    IRpcStubBuffer *This,
    IRpcChannelBuffer *_pRpcChannelBuffer,
    PRPC_MESSAGE _pRpcMessage,
    DWORD *_pdwStubPhase);


HRESULT STDMETHODCALLTYPE IDirsyncLog_RemoveLevel_Proxy( 
    IDirsyncLog * This,
    /* [in] */ DWORD dwSessionID);


void __RPC_STUB IDirsyncLog_RemoveLevel_Stub(
    IRpcStubBuffer *This,
    IRpcChannelBuffer *_pRpcChannelBuffer,
    PRPC_MESSAGE _pRpcMessage,
    DWORD *_pdwStubPhase);


HRESULT STDMETHODCALLTYPE IDirsyncLog_LogEvent_Proxy( 
    IDirsyncLog * This,
    /* [in] */ HANDLE handle,
    /* [in] */ DWORD dwEventType,
    /* [in] */ DWORD dwSessionID,
    /* [in] */ DWORD dwMsgId,
    /* [in] */ DWORD dwNumStrings,
    /* [in] */ LPCWSTR *rgszMsgString,
    /* [in] */ DWORD dwDataSize,
    /* [in] */ PBYTE pRawData);


void __RPC_STUB IDirsyncLog_LogEvent_Stub(
    IRpcStubBuffer *This,
    IRpcChannelBuffer *_pRpcChannelBuffer,
    PRPC_MESSAGE _pRpcMessage,
    DWORD *_pdwStubPhase);


HRESULT STDMETHODCALLTYPE IDirsyncLog_LogEventEx_Proxy( 
    IDirsyncLog * This,
    /* [in] */ PLOGPARAM pLogParam);


void __RPC_STUB IDirsyncLog_LogEventEx_Stub(
    IRpcStubBuffer *This,
    IRpcChannelBuffer *_pRpcChannelBuffer,
    PRPC_MESSAGE _pRpcMessage,
    DWORD *_pdwStubPhase);



#endif 	/* __IDirsyncLog_INTERFACE_DEFINED__ */


/* interface __MIDL_itf_dirsync_0107 */
/* [local] */ 


enum EventType
    {	EVENTTYPE_ERROR	= 1,
	EVENTTYPE_WARNING	= 2,
	EVENTTYPE_INFORMATION	= 3,
	EVENTTYPE_BASIC_TRACE	= 4,
	EVENTTYPE_VERBOSE_TRACE	= 5
    } ;


extern RPC_IF_HANDLE __MIDL_itf_dirsync_0107_v0_0_c_ifspec;
extern RPC_IF_HANDLE __MIDL_itf_dirsync_0107_v0_0_s_ifspec;

#ifndef __IDirsyncStatus_INTERFACE_DEFINED__
#define __IDirsyncStatus_INTERFACE_DEFINED__

/* interface IDirsyncStatus */
/* [unique][helpstring][uuid][object] */ 


EXTERN_C const IID IID_IDirsyncStatus;

#if defined(__cplusplus) && !defined(CINTERFACE)
    
    MIDL_INTERFACE("041a280a-1dd6-11d3-b63a-00c04f79f834")
    IDirsyncStatus : public IUnknown
    {
    public:
        virtual HRESULT STDMETHODCALLTYPE StatusUpdate( 
            DWORD dwPercent,
            DWORD dwWarning,
            DWORD dwError) = 0;
        
    };
    
#else 	/* C style interface */

    typedef struct IDirsyncStatusVtbl
    {
        BEGIN_INTERFACE
        
        HRESULT ( STDMETHODCALLTYPE *QueryInterface )( 
            IDirsyncStatus * This,
            /* [in] */ REFIID riid,
            /* [iid_is][out] */ void **ppvObject);
        
        ULONG ( STDMETHODCALLTYPE *AddRef )( 
            IDirsyncStatus * This);
        
        ULONG ( STDMETHODCALLTYPE *Release )( 
            IDirsyncStatus * This);
        
        HRESULT ( STDMETHODCALLTYPE *StatusUpdate )( 
            IDirsyncStatus * This,
            DWORD dwPercent,
            DWORD dwWarning,
            DWORD dwError);
        
        END_INTERFACE
    } IDirsyncStatusVtbl;

    interface IDirsyncStatus
    {
        CONST_VTBL struct IDirsyncStatusVtbl *lpVtbl;
    };

    

#ifdef COBJMACROS


#define IDirsyncStatus_QueryInterface(This,riid,ppvObject)	\
    (This)->lpVtbl -> QueryInterface(This,riid,ppvObject)

#define IDirsyncStatus_AddRef(This)	\
    (This)->lpVtbl -> AddRef(This)

#define IDirsyncStatus_Release(This)	\
    (This)->lpVtbl -> Release(This)


#define IDirsyncStatus_StatusUpdate(This,dwPercent,dwWarning,dwError)	\
    (This)->lpVtbl -> StatusUpdate(This,dwPercent,dwWarning,dwError)

#endif /* COBJMACROS */


#endif 	/* C style interface */



HRESULT STDMETHODCALLTYPE IDirsyncStatus_StatusUpdate_Proxy( 
    IDirsyncStatus * This,
    DWORD dwPercent,
    DWORD dwWarning,
    DWORD dwError);


void __RPC_STUB IDirsyncStatus_StatusUpdate_Stub(
    IRpcStubBuffer *This,
    IRpcChannelBuffer *_pRpcChannelBuffer,
    PRPC_MESSAGE _pRpcMessage,
    DWORD *_pdwStubPhase);



#endif 	/* __IDirsyncStatus_INTERFACE_DEFINED__ */


/* interface __MIDL_itf_dirsync_0108 */
/* [local] */ 




extern RPC_IF_HANDLE __MIDL_itf_dirsync_0108_v0_0_c_ifspec;
extern RPC_IF_HANDLE __MIDL_itf_dirsync_0108_v0_0_s_ifspec;

#ifndef __IDirsyncDatabase_INTERFACE_DEFINED__
#define __IDirsyncDatabase_INTERFACE_DEFINED__

/* interface IDirsyncDatabase */
/* [unique][helpstring][uuid][local][object] */ 


EXTERN_C const IID IID_IDirsyncDatabase;

#if defined(__cplusplus) && !defined(CINTERFACE)
    
    MIDL_INTERFACE("df83c5d6-3098-11d3-be6d-0000f87a369e")
    IDirsyncDatabase : public IUnknown
    {
    public:
        virtual HRESULT STDMETHODCALLTYPE AddTable( 
            /* [in] */ PWSTR pszTableName,
            /* [retval][out] */ IDirsyncDatabaseTable **ppTable) = 0;
        
        virtual HRESULT STDMETHODCALLTYPE GetTable( 
            /* [in] */ PWSTR pszTableName,
            /* [retval][out] */ IDirsyncDatabaseTable **ppTable) = 0;
        
        virtual HRESULT STDMETHODCALLTYPE DeleteTable( 
            /* [in] */ PWSTR pszTableName) = 0;
        
        virtual HRESULT STDMETHODCALLTYPE BeginTransaction( void) = 0;
        
        virtual HRESULT STDMETHODCALLTYPE CommitTransaction( void) = 0;
        
        virtual HRESULT STDMETHODCALLTYPE AbortTransaction( void) = 0;
        
        virtual HRESULT STDMETHODCALLTYPE Backup( 
            /* [in] */ PWSTR pszBackupPath) = 0;
        
        virtual HRESULT STDMETHODCALLTYPE Restore( 
            /* [in] */ PWSTR pszBackupPath) = 0;
        
    };
    
#else 	/* C style interface */

    typedef struct IDirsyncDatabaseVtbl
    {
        BEGIN_INTERFACE
        
        HRESULT ( STDMETHODCALLTYPE *QueryInterface )( 
            IDirsyncDatabase * This,
            /* [in] */ REFIID riid,
            /* [iid_is][out] */ void **ppvObject);
        
        ULONG ( STDMETHODCALLTYPE *AddRef )( 
            IDirsyncDatabase * This);
        
        ULONG ( STDMETHODCALLTYPE *Release )( 
            IDirsyncDatabase * This);
        
        HRESULT ( STDMETHODCALLTYPE *AddTable )( 
            IDirsyncDatabase * This,
            /* [in] */ PWSTR pszTableName,
            /* [retval][out] */ IDirsyncDatabaseTable **ppTable);
        
        HRESULT ( STDMETHODCALLTYPE *GetTable )( 
            IDirsyncDatabase * This,
            /* [in] */ PWSTR pszTableName,
            /* [retval][out] */ IDirsyncDatabaseTable **ppTable);
        
        HRESULT ( STDMETHODCALLTYPE *DeleteTable )( 
            IDirsyncDatabase * This,
            /* [in] */ PWSTR pszTableName);
        
        HRESULT ( STDMETHODCALLTYPE *BeginTransaction )( 
            IDirsyncDatabase * This);
        
        HRESULT ( STDMETHODCALLTYPE *CommitTransaction )( 
            IDirsyncDatabase * This);
        
        HRESULT ( STDMETHODCALLTYPE *AbortTransaction )( 
            IDirsyncDatabase * This);
        
        HRESULT ( STDMETHODCALLTYPE *Backup )( 
            IDirsyncDatabase * This,
            /* [in] */ PWSTR pszBackupPath);
        
        HRESULT ( STDMETHODCALLTYPE *Restore )( 
            IDirsyncDatabase * This,
            /* [in] */ PWSTR pszBackupPath);
        
        END_INTERFACE
    } IDirsyncDatabaseVtbl;

    interface IDirsyncDatabase
    {
        CONST_VTBL struct IDirsyncDatabaseVtbl *lpVtbl;
    };

    

#ifdef COBJMACROS


#define IDirsyncDatabase_QueryInterface(This,riid,ppvObject)	\
    (This)->lpVtbl -> QueryInterface(This,riid,ppvObject)

#define IDirsyncDatabase_AddRef(This)	\
    (This)->lpVtbl -> AddRef(This)

#define IDirsyncDatabase_Release(This)	\
    (This)->lpVtbl -> Release(This)


#define IDirsyncDatabase_AddTable(This,pszTableName,ppTable)	\
    (This)->lpVtbl -> AddTable(This,pszTableName,ppTable)

#define IDirsyncDatabase_GetTable(This,pszTableName,ppTable)	\
    (This)->lpVtbl -> GetTable(This,pszTableName,ppTable)

#define IDirsyncDatabase_DeleteTable(This,pszTableName)	\
    (This)->lpVtbl -> DeleteTable(This,pszTableName)

#define IDirsyncDatabase_BeginTransaction(This)	\
    (This)->lpVtbl -> BeginTransaction(This)

#define IDirsyncDatabase_CommitTransaction(This)	\
    (This)->lpVtbl -> CommitTransaction(This)

#define IDirsyncDatabase_AbortTransaction(This)	\
    (This)->lpVtbl -> AbortTransaction(This)

#define IDirsyncDatabase_Backup(This,pszBackupPath)	\
    (This)->lpVtbl -> Backup(This,pszBackupPath)

#define IDirsyncDatabase_Restore(This,pszBackupPath)	\
    (This)->lpVtbl -> Restore(This,pszBackupPath)

#endif /* COBJMACROS */


#endif 	/* C style interface */



HRESULT STDMETHODCALLTYPE IDirsyncDatabase_AddTable_Proxy( 
    IDirsyncDatabase * This,
    /* [in] */ PWSTR pszTableName,
    /* [retval][out] */ IDirsyncDatabaseTable **ppTable);


void __RPC_STUB IDirsyncDatabase_AddTable_Stub(
    IRpcStubBuffer *This,
    IRpcChannelBuffer *_pRpcChannelBuffer,
    PRPC_MESSAGE _pRpcMessage,
    DWORD *_pdwStubPhase);


HRESULT STDMETHODCALLTYPE IDirsyncDatabase_GetTable_Proxy( 
    IDirsyncDatabase * This,
    /* [in] */ PWSTR pszTableName,
    /* [retval][out] */ IDirsyncDatabaseTable **ppTable);


void __RPC_STUB IDirsyncDatabase_GetTable_Stub(
    IRpcStubBuffer *This,
    IRpcChannelBuffer *_pRpcChannelBuffer,
    PRPC_MESSAGE _pRpcMessage,
    DWORD *_pdwStubPhase);


HRESULT STDMETHODCALLTYPE IDirsyncDatabase_DeleteTable_Proxy( 
    IDirsyncDatabase * This,
    /* [in] */ PWSTR pszTableName);


void __RPC_STUB IDirsyncDatabase_DeleteTable_Stub(
    IRpcStubBuffer *This,
    IRpcChannelBuffer *_pRpcChannelBuffer,
    PRPC_MESSAGE _pRpcMessage,
    DWORD *_pdwStubPhase);


HRESULT STDMETHODCALLTYPE IDirsyncDatabase_BeginTransaction_Proxy( 
    IDirsyncDatabase * This);


void __RPC_STUB IDirsyncDatabase_BeginTransaction_Stub(
    IRpcStubBuffer *This,
    IRpcChannelBuffer *_pRpcChannelBuffer,
    PRPC_MESSAGE _pRpcMessage,
    DWORD *_pdwStubPhase);


HRESULT STDMETHODCALLTYPE IDirsyncDatabase_CommitTransaction_Proxy( 
    IDirsyncDatabase * This);


void __RPC_STUB IDirsyncDatabase_CommitTransaction_Stub(
    IRpcStubBuffer *This,
    IRpcChannelBuffer *_pRpcChannelBuffer,
    PRPC_MESSAGE _pRpcMessage,
    DWORD *_pdwStubPhase);


HRESULT STDMETHODCALLTYPE IDirsyncDatabase_AbortTransaction_Proxy( 
    IDirsyncDatabase * This);


void __RPC_STUB IDirsyncDatabase_AbortTransaction_Stub(
    IRpcStubBuffer *This,
    IRpcChannelBuffer *_pRpcChannelBuffer,
    PRPC_MESSAGE _pRpcMessage,
    DWORD *_pdwStubPhase);


HRESULT STDMETHODCALLTYPE IDirsyncDatabase_Backup_Proxy( 
    IDirsyncDatabase * This,
    /* [in] */ PWSTR pszBackupPath);


void __RPC_STUB IDirsyncDatabase_Backup_Stub(
    IRpcStubBuffer *This,
    IRpcChannelBuffer *_pRpcChannelBuffer,
    PRPC_MESSAGE _pRpcMessage,
    DWORD *_pdwStubPhase);


HRESULT STDMETHODCALLTYPE IDirsyncDatabase_Restore_Proxy( 
    IDirsyncDatabase * This,
    /* [in] */ PWSTR pszBackupPath);


void __RPC_STUB IDirsyncDatabase_Restore_Stub(
    IRpcStubBuffer *This,
    IRpcChannelBuffer *_pRpcChannelBuffer,
    PRPC_MESSAGE _pRpcMessage,
    DWORD *_pdwStubPhase);



#endif 	/* __IDirsyncDatabase_INTERFACE_DEFINED__ */


#ifndef __IDirsyncDatabaseTable_INTERFACE_DEFINED__
#define __IDirsyncDatabaseTable_INTERFACE_DEFINED__

/* interface IDirsyncDatabaseTable */
/* [unique][helpstring][uuid][object] */ 


EXTERN_C const IID IID_IDirsyncDatabaseTable;

#if defined(__cplusplus) && !defined(CINTERFACE)
    
    MIDL_INTERFACE("da2dab58-3098-11d3-be6d-0000f87a369e")
    IDirsyncDatabaseTable : public IUnknown
    {
    public:
        virtual HRESULT STDMETHODCALLTYPE AddColumn( 
            /* [in] */ DBTYPE dwType,
            /* [in] */ PWSTR pszColumnName) = 0;
        
        virtual HRESULT STDMETHODCALLTYPE AddIndex( 
            /* [in] */ PWSTR pszColumnName,
            /* [in] */ PWSTR pszIndexName,
            /* [in] */ DWORD dwIndexType) = 0;
        
        virtual HRESULT STDMETHODCALLTYPE Seek( 
            /* [in] */ PWSTR szIndexName,
            /* [in] */ PDirsyncDBValue pValue) = 0;
        
        virtual HRESULT STDMETHODCALLTYPE UpdateRow( 
            /* [in] */ PWSTR *rgszColumnName,
            /* [in] */ PDirsyncDBValue rgValue,
            /* [in] */ UPDATETYPE prep) = 0;
        
        virtual HRESULT STDMETHODCALLTYPE RetrieveRow( 
            /* [in] */ PWSTR *rgszColumnName,
            /* [retval][out] */ PDirsyncDBValue rgValue) = 0;
        
        virtual HRESULT STDMETHODCALLTYPE DeleteRow( 
            /* [in] */ PWSTR pszIndexName,
            /* [in] */ PDirsyncDBValue pValue) = 0;
        
        virtual HRESULT STDMETHODCALLTYPE SetColumn( 
            /* [in] */ PWSTR pszColumnName,
            /* [in] */ PDirsyncDBValue pValue) = 0;
        
        virtual HRESULT STDMETHODCALLTYPE Move( 
            /* [in] */ DWORD dwOperation) = 0;
        
        virtual /* [propget] */ HRESULT STDMETHODCALLTYPE get_RowCount( 
            /* [retval][out] */ DWORD *pdwRowCount) = 0;
        
    };
    
#else 	/* C style interface */

    typedef struct IDirsyncDatabaseTableVtbl
    {
        BEGIN_INTERFACE
        
        HRESULT ( STDMETHODCALLTYPE *QueryInterface )( 
            IDirsyncDatabaseTable * This,
            /* [in] */ REFIID riid,
            /* [iid_is][out] */ void **ppvObject);
        
        ULONG ( STDMETHODCALLTYPE *AddRef )( 
            IDirsyncDatabaseTable * This);
        
        ULONG ( STDMETHODCALLTYPE *Release )( 
            IDirsyncDatabaseTable * This);
        
        HRESULT ( STDMETHODCALLTYPE *AddColumn )( 
            IDirsyncDatabaseTable * This,
            /* [in] */ DBTYPE dwType,
            /* [in] */ PWSTR pszColumnName);
        
        HRESULT ( STDMETHODCALLTYPE *AddIndex )( 
            IDirsyncDatabaseTable * This,
            /* [in] */ PWSTR pszColumnName,
            /* [in] */ PWSTR pszIndexName,
            /* [in] */ DWORD dwIndexType);
        
        HRESULT ( STDMETHODCALLTYPE *Seek )( 
            IDirsyncDatabaseTable * This,
            /* [in] */ PWSTR szIndexName,
            /* [in] */ PDirsyncDBValue pValue);
        
        HRESULT ( STDMETHODCALLTYPE *UpdateRow )( 
            IDirsyncDatabaseTable * This,
            /* [in] */ PWSTR *rgszColumnName,
            /* [in] */ PDirsyncDBValue rgValue,
            /* [in] */ UPDATETYPE prep);
        
        HRESULT ( STDMETHODCALLTYPE *RetrieveRow )( 
            IDirsyncDatabaseTable * This,
            /* [in] */ PWSTR *rgszColumnName,
            /* [retval][out] */ PDirsyncDBValue rgValue);
        
        HRESULT ( STDMETHODCALLTYPE *DeleteRow )( 
            IDirsyncDatabaseTable * This,
            /* [in] */ PWSTR pszIndexName,
            /* [in] */ PDirsyncDBValue pValue);
        
        HRESULT ( STDMETHODCALLTYPE *SetColumn )( 
            IDirsyncDatabaseTable * This,
            /* [in] */ PWSTR pszColumnName,
            /* [in] */ PDirsyncDBValue pValue);
        
        HRESULT ( STDMETHODCALLTYPE *Move )( 
            IDirsyncDatabaseTable * This,
            /* [in] */ DWORD dwOperation);
        
        /* [propget] */ HRESULT ( STDMETHODCALLTYPE *get_RowCount )( 
            IDirsyncDatabaseTable * This,
            /* [retval][out] */ DWORD *pdwRowCount);
        
        END_INTERFACE
    } IDirsyncDatabaseTableVtbl;

    interface IDirsyncDatabaseTable
    {
        CONST_VTBL struct IDirsyncDatabaseTableVtbl *lpVtbl;
    };

    

#ifdef COBJMACROS


#define IDirsyncDatabaseTable_QueryInterface(This,riid,ppvObject)	\
    (This)->lpVtbl -> QueryInterface(This,riid,ppvObject)

#define IDirsyncDatabaseTable_AddRef(This)	\
    (This)->lpVtbl -> AddRef(This)

#define IDirsyncDatabaseTable_Release(This)	\
    (This)->lpVtbl -> Release(This)


#define IDirsyncDatabaseTable_AddColumn(This,dwType,pszColumnName)	\
    (This)->lpVtbl -> AddColumn(This,dwType,pszColumnName)

#define IDirsyncDatabaseTable_AddIndex(This,pszColumnName,pszIndexName,dwIndexType)	\
    (This)->lpVtbl -> AddIndex(This,pszColumnName,pszIndexName,dwIndexType)

#define IDirsyncDatabaseTable_Seek(This,szIndexName,pValue)	\
    (This)->lpVtbl -> Seek(This,szIndexName,pValue)

#define IDirsyncDatabaseTable_UpdateRow(This,rgszColumnName,rgValue,prep)	\
    (This)->lpVtbl -> UpdateRow(This,rgszColumnName,rgValue,prep)

#define IDirsyncDatabaseTable_RetrieveRow(This,rgszColumnName,rgValue)	\
    (This)->lpVtbl -> RetrieveRow(This,rgszColumnName,rgValue)

#define IDirsyncDatabaseTable_DeleteRow(This,pszIndexName,pValue)	\
    (This)->lpVtbl -> DeleteRow(This,pszIndexName,pValue)

#define IDirsyncDatabaseTable_SetColumn(This,pszColumnName,pValue)	\
    (This)->lpVtbl -> SetColumn(This,pszColumnName,pValue)

#define IDirsyncDatabaseTable_Move(This,dwOperation)	\
    (This)->lpVtbl -> Move(This,dwOperation)

#define IDirsyncDatabaseTable_get_RowCount(This,pdwRowCount)	\
    (This)->lpVtbl -> get_RowCount(This,pdwRowCount)

#endif /* COBJMACROS */


#endif 	/* C style interface */



HRESULT STDMETHODCALLTYPE IDirsyncDatabaseTable_AddColumn_Proxy( 
    IDirsyncDatabaseTable * This,
    /* [in] */ DBTYPE dwType,
    /* [in] */ PWSTR pszColumnName);


void __RPC_STUB IDirsyncDatabaseTable_AddColumn_Stub(
    IRpcStubBuffer *This,
    IRpcChannelBuffer *_pRpcChannelBuffer,
    PRPC_MESSAGE _pRpcMessage,
    DWORD *_pdwStubPhase);


HRESULT STDMETHODCALLTYPE IDirsyncDatabaseTable_AddIndex_Proxy( 
    IDirsyncDatabaseTable * This,
    /* [in] */ PWSTR pszColumnName,
    /* [in] */ PWSTR pszIndexName,
    /* [in] */ DWORD dwIndexType);


void __RPC_STUB IDirsyncDatabaseTable_AddIndex_Stub(
    IRpcStubBuffer *This,
    IRpcChannelBuffer *_pRpcChannelBuffer,
    PRPC_MESSAGE _pRpcMessage,
    DWORD *_pdwStubPhase);


HRESULT STDMETHODCALLTYPE IDirsyncDatabaseTable_Seek_Proxy( 
    IDirsyncDatabaseTable * This,
    /* [in] */ PWSTR szIndexName,
    /* [in] */ PDirsyncDBValue pValue);


void __RPC_STUB IDirsyncDatabaseTable_Seek_Stub(
    IRpcStubBuffer *This,
    IRpcChannelBuffer *_pRpcChannelBuffer,
    PRPC_MESSAGE _pRpcMessage,
    DWORD *_pdwStubPhase);


HRESULT STDMETHODCALLTYPE IDirsyncDatabaseTable_UpdateRow_Proxy( 
    IDirsyncDatabaseTable * This,
    /* [in] */ PWSTR *rgszColumnName,
    /* [in] */ PDirsyncDBValue rgValue,
    /* [in] */ UPDATETYPE prep);


void __RPC_STUB IDirsyncDatabaseTable_UpdateRow_Stub(
    IRpcStubBuffer *This,
    IRpcChannelBuffer *_pRpcChannelBuffer,
    PRPC_MESSAGE _pRpcMessage,
    DWORD *_pdwStubPhase);


HRESULT STDMETHODCALLTYPE IDirsyncDatabaseTable_RetrieveRow_Proxy( 
    IDirsyncDatabaseTable * This,
    /* [in] */ PWSTR *rgszColumnName,
    /* [retval][out] */ PDirsyncDBValue rgValue);


void __RPC_STUB IDirsyncDatabaseTable_RetrieveRow_Stub(
    IRpcStubBuffer *This,
    IRpcChannelBuffer *_pRpcChannelBuffer,
    PRPC_MESSAGE _pRpcMessage,
    DWORD *_pdwStubPhase);


HRESULT STDMETHODCALLTYPE IDirsyncDatabaseTable_DeleteRow_Proxy( 
    IDirsyncDatabaseTable * This,
    /* [in] */ PWSTR pszIndexName,
    /* [in] */ PDirsyncDBValue pValue);


void __RPC_STUB IDirsyncDatabaseTable_DeleteRow_Stub(
    IRpcStubBuffer *This,
    IRpcChannelBuffer *_pRpcChannelBuffer,
    PRPC_MESSAGE _pRpcMessage,
    DWORD *_pdwStubPhase);


HRESULT STDMETHODCALLTYPE IDirsyncDatabaseTable_SetColumn_Proxy( 
    IDirsyncDatabaseTable * This,
    /* [in] */ PWSTR pszColumnName,
    /* [in] */ PDirsyncDBValue pValue);


void __RPC_STUB IDirsyncDatabaseTable_SetColumn_Stub(
    IRpcStubBuffer *This,
    IRpcChannelBuffer *_pRpcChannelBuffer,
    PRPC_MESSAGE _pRpcMessage,
    DWORD *_pdwStubPhase);


HRESULT STDMETHODCALLTYPE IDirsyncDatabaseTable_Move_Proxy( 
    IDirsyncDatabaseTable * This,
    /* [in] */ DWORD dwOperation);


void __RPC_STUB IDirsyncDatabaseTable_Move_Stub(
    IRpcStubBuffer *This,
    IRpcChannelBuffer *_pRpcChannelBuffer,
    PRPC_MESSAGE _pRpcMessage,
    DWORD *_pdwStubPhase);


/* [propget] */ HRESULT STDMETHODCALLTYPE IDirsyncDatabaseTable_get_RowCount_Proxy( 
    IDirsyncDatabaseTable * This,
    /* [retval][out] */ DWORD *pdwRowCount);


void __RPC_STUB IDirsyncDatabaseTable_get_RowCount_Stub(
    IRpcStubBuffer *This,
    IRpcChannelBuffer *_pRpcChannelBuffer,
    PRPC_MESSAGE _pRpcMessage,
    DWORD *_pdwStubPhase);



#endif 	/* __IDirsyncDatabaseTable_INTERFACE_DEFINED__ */


/* interface __MIDL_itf_dirsync_0110 */
/* [local] */ 


enum DatabaseMoveType
    {	DB_MOVE_FIRST	= 1,
	DB_MOVE_PREVIOUS	= 2,
	DB_MOVE_NEXT	= 3,
	DB_MOVE_LAST	= 4
    } ;

enum DatabaseIndexType
    {	DB_INDEX_PRIMARY	= 1,
	DB_INDEX_SECONDARY_UNIQUE	= 2,
	DB_INDEX_SECONDARY_NOTUNIQUE	= 3
    } ;



extern RPC_IF_HANDLE __MIDL_itf_dirsync_0110_v0_0_c_ifspec;
extern RPC_IF_HANDLE __MIDL_itf_dirsync_0110_v0_0_s_ifspec;

#ifndef __IEnumDirsyncSession_INTERFACE_DEFINED__
#define __IEnumDirsyncSession_INTERFACE_DEFINED__

/* interface IEnumDirsyncSession */
/* [unique][helpstring][uuid][object] */ 


EXTERN_C const IID IID_IEnumDirsyncSession;

#if defined(__cplusplus) && !defined(CINTERFACE)
    
    MIDL_INTERFACE("12ac92e2-ca83-11d1-a40e-00c04fb950dc")
    IEnumDirsyncSession : public IUnknown
    {
    public:
        virtual HRESULT STDMETHODCALLTYPE Next( 
            /* [in] */ ULONG cSession,
            /* [length_is][size_is][out] */ IDirsyncSession *rgSession[  ],
            /* [out] */ ULONG *pcSessionFetched) = 0;
        
        virtual HRESULT STDMETHODCALLTYPE Clone( 
            /* [retval][out] */ IEnumDirsyncSession **ppEnum) = 0;
        
        virtual HRESULT STDMETHODCALLTYPE Reset( void) = 0;
        
        virtual HRESULT STDMETHODCALLTYPE Skip( 
            /* [in] */ ULONG cSession) = 0;
        
    };
    
#else 	/* C style interface */

    typedef struct IEnumDirsyncSessionVtbl
    {
        BEGIN_INTERFACE
        
        HRESULT ( STDMETHODCALLTYPE *QueryInterface )( 
            IEnumDirsyncSession * This,
            /* [in] */ REFIID riid,
            /* [iid_is][out] */ void **ppvObject);
        
        ULONG ( STDMETHODCALLTYPE *AddRef )( 
            IEnumDirsyncSession * This);
        
        ULONG ( STDMETHODCALLTYPE *Release )( 
            IEnumDirsyncSession * This);
        
        HRESULT ( STDMETHODCALLTYPE *Next )( 
            IEnumDirsyncSession * This,
            /* [in] */ ULONG cSession,
            /* [length_is][size_is][out] */ IDirsyncSession *rgSession[  ],
            /* [out] */ ULONG *pcSessionFetched);
        
        HRESULT ( STDMETHODCALLTYPE *Clone )( 
            IEnumDirsyncSession * This,
            /* [retval][out] */ IEnumDirsyncSession **ppEnum);
        
        HRESULT ( STDMETHODCALLTYPE *Reset )( 
            IEnumDirsyncSession * This);
        
        HRESULT ( STDMETHODCALLTYPE *Skip )( 
            IEnumDirsyncSession * This,
            /* [in] */ ULONG cSession);
        
        END_INTERFACE
    } IEnumDirsyncSessionVtbl;

    interface IEnumDirsyncSession
    {
        CONST_VTBL struct IEnumDirsyncSessionVtbl *lpVtbl;
    };

    

#ifdef COBJMACROS


#define IEnumDirsyncSession_QueryInterface(This,riid,ppvObject)	\
    (This)->lpVtbl -> QueryInterface(This,riid,ppvObject)

#define IEnumDirsyncSession_AddRef(This)	\
    (This)->lpVtbl -> AddRef(This)

#define IEnumDirsyncSession_Release(This)	\
    (This)->lpVtbl -> Release(This)


#define IEnumDirsyncSession_Next(This,cSession,rgSession,pcSessionFetched)	\
    (This)->lpVtbl -> Next(This,cSession,rgSession,pcSessionFetched)

#define IEnumDirsyncSession_Clone(This,ppEnum)	\
    (This)->lpVtbl -> Clone(This,ppEnum)

#define IEnumDirsyncSession_Reset(This)	\
    (This)->lpVtbl -> Reset(This)

#define IEnumDirsyncSession_Skip(This,cSession)	\
    (This)->lpVtbl -> Skip(This,cSession)

#endif /* COBJMACROS */


#endif 	/* C style interface */



HRESULT STDMETHODCALLTYPE IEnumDirsyncSession_Next_Proxy( 
    IEnumDirsyncSession * This,
    /* [in] */ ULONG cSession,
    /* [length_is][size_is][out] */ IDirsyncSession *rgSession[  ],
    /* [out] */ ULONG *pcSessionFetched);


void __RPC_STUB IEnumDirsyncSession_Next_Stub(
    IRpcStubBuffer *This,
    IRpcChannelBuffer *_pRpcChannelBuffer,
    PRPC_MESSAGE _pRpcMessage,
    DWORD *_pdwStubPhase);


HRESULT STDMETHODCALLTYPE IEnumDirsyncSession_Clone_Proxy( 
    IEnumDirsyncSession * This,
    /* [retval][out] */ IEnumDirsyncSession **ppEnum);


void __RPC_STUB IEnumDirsyncSession_Clone_Stub(
    IRpcStubBuffer *This,
    IRpcChannelBuffer *_pRpcChannelBuffer,
    PRPC_MESSAGE _pRpcMessage,
    DWORD *_pdwStubPhase);


HRESULT STDMETHODCALLTYPE IEnumDirsyncSession_Reset_Proxy( 
    IEnumDirsyncSession * This);


void __RPC_STUB IEnumDirsyncSession_Reset_Stub(
    IRpcStubBuffer *This,
    IRpcChannelBuffer *_pRpcChannelBuffer,
    PRPC_MESSAGE _pRpcMessage,
    DWORD *_pdwStubPhase);


HRESULT STDMETHODCALLTYPE IEnumDirsyncSession_Skip_Proxy( 
    IEnumDirsyncSession * This,
    /* [in] */ ULONG cSession);


void __RPC_STUB IEnumDirsyncSession_Skip_Stub(
    IRpcStubBuffer *This,
    IRpcChannelBuffer *_pRpcChannelBuffer,
    PRPC_MESSAGE _pRpcMessage,
    DWORD *_pdwStubPhase);



#endif 	/* __IEnumDirsyncSession_INTERFACE_DEFINED__ */


/* interface __MIDL_itf_dirsync_0111 */
/* [local] */ 

//
// Bit fields for Flags property
//

#define DIRSYNC_PASSWORD_EXTRACT     0x00000001




extern RPC_IF_HANDLE __MIDL_itf_dirsync_0111_v0_0_c_ifspec;
extern RPC_IF_HANDLE __MIDL_itf_dirsync_0111_v0_0_s_ifspec;

#ifndef __IDirsyncSessionManager_INTERFACE_DEFINED__
#define __IDirsyncSessionManager_INTERFACE_DEFINED__

/* interface IDirsyncSessionManager */
/* [unique][helpstring][uuid][object] */ 


EXTERN_C const IID IID_IDirsyncSessionManager;

#if defined(__cplusplus) && !defined(CINTERFACE)
    
    MIDL_INTERFACE("fc26ad44-c430-11d1-a407-00c04fb950dc")
    IDirsyncSessionManager : public IUnknown
    {
    public:
        virtual /* [propget] */ HRESULT STDMETHODCALLTYPE get_Server( 
            /* [retval][out] */ PWSTR *ppszServer) = 0;
        
        virtual /* [propget] */ HRESULT STDMETHODCALLTYPE get_ServerGuid( 
            /* [retval][out] */ PWSTR *ppszServerGuid) = 0;
        
        virtual /* [propget] */ HRESULT STDMETHODCALLTYPE get_Flags( 
            /* [retval][out] */ DWORD *pdwFlags) = 0;
        
        virtual HRESULT STDMETHODCALLTYPE CreateSession( 
            /* [retval][out] */ IDirsyncSession **ppSession) = 0;
        
        virtual HRESULT STDMETHODCALLTYPE GetSession( 
            /* [in] */ DWORD dwSessionId,
            /* [retval][out] */ IDirsyncSession **ppSession) = 0;
        
        virtual HRESULT STDMETHODCALLTYPE DeleteSession( 
            /* [in] */ DWORD dwSessionId) = 0;
        
        virtual HRESULT STDMETHODCALLTYPE PauseSession( 
            /* [in] */ DWORD dwSessionId,
            /* [in] */ BOOL fPause) = 0;
        
        virtual HRESULT STDMETHODCALLTYPE GetSessionCount( 
            /* [retval][out] */ DWORD *pdwSessions) = 0;
        
        virtual HRESULT STDMETHODCALLTYPE GetEnumInterface( 
            /* [in] */ BOOL fGlobal,
            /* [retval][out] */ IEnumDirsyncSession **pEnumSession) = 0;
        
        virtual HRESULT STDMETHODCALLTYPE ExecuteSession( 
            /* [in] */ DWORD dwSessionId,
            /* [in] */ DWORD dwExecuteType,
            /* [in] */ BOOL fFullSync,
            /* [in] */ BOOL fSynchronous,
            /* [in] */ IDirsyncStatus *pStatus) = 0;
        
        virtual HRESULT STDMETHODCALLTYPE CancelSession( 
            /* [in] */ DWORD dwSessionId) = 0;
        
    };
    
#else 	/* C style interface */

    typedef struct IDirsyncSessionManagerVtbl
    {
        BEGIN_INTERFACE
        
        HRESULT ( STDMETHODCALLTYPE *QueryInterface )( 
            IDirsyncSessionManager * This,
            /* [in] */ REFIID riid,
            /* [iid_is][out] */ void **ppvObject);
        
        ULONG ( STDMETHODCALLTYPE *AddRef )( 
            IDirsyncSessionManager * This);
        
        ULONG ( STDMETHODCALLTYPE *Release )( 
            IDirsyncSessionManager * This);
        
        /* [propget] */ HRESULT ( STDMETHODCALLTYPE *get_Server )( 
            IDirsyncSessionManager * This,
            /* [retval][out] */ PWSTR *ppszServer);
        
        /* [propget] */ HRESULT ( STDMETHODCALLTYPE *get_ServerGuid )( 
            IDirsyncSessionManager * This,
            /* [retval][out] */ PWSTR *ppszServerGuid);
        
        /* [propget] */ HRESULT ( STDMETHODCALLTYPE *get_Flags )( 
            IDirsyncSessionManager * This,
            /* [retval][out] */ DWORD *pdwFlags);
        
        HRESULT ( STDMETHODCALLTYPE *CreateSession )( 
            IDirsyncSessionManager * This,
            /* [retval][out] */ IDirsyncSession **ppSession);
        
        HRESULT ( STDMETHODCALLTYPE *GetSession )( 
            IDirsyncSessionManager * This,
            /* [in] */ DWORD dwSessionId,
            /* [retval][out] */ IDirsyncSession **ppSession);
        
        HRESULT ( STDMETHODCALLTYPE *DeleteSession )( 
            IDirsyncSessionManager * This,
            /* [in] */ DWORD dwSessionId);
        
        HRESULT ( STDMETHODCALLTYPE *PauseSession )( 
            IDirsyncSessionManager * This,
            /* [in] */ DWORD dwSessionId,
            /* [in] */ BOOL fPause);
        
        HRESULT ( STDMETHODCALLTYPE *GetSessionCount )( 
            IDirsyncSessionManager * This,
            /* [retval][out] */ DWORD *pdwSessions);
        
        HRESULT ( STDMETHODCALLTYPE *GetEnumInterface )( 
            IDirsyncSessionManager * This,
            /* [in] */ BOOL fGlobal,
            /* [retval][out] */ IEnumDirsyncSession **pEnumSession);
        
        HRESULT ( STDMETHODCALLTYPE *ExecuteSession )( 
            IDirsyncSessionManager * This,
            /* [in] */ DWORD dwSessionId,
            /* [in] */ DWORD dwExecuteType,
            /* [in] */ BOOL fFullSync,
            /* [in] */ BOOL fSynchronous,
            /* [in] */ IDirsyncStatus *pStatus);
        
        HRESULT ( STDMETHODCALLTYPE *CancelSession )( 
            IDirsyncSessionManager * This,
            /* [in] */ DWORD dwSessionId);
        
        END_INTERFACE
    } IDirsyncSessionManagerVtbl;

    interface IDirsyncSessionManager
    {
        CONST_VTBL struct IDirsyncSessionManagerVtbl *lpVtbl;
    };

    

#ifdef COBJMACROS


#define IDirsyncSessionManager_QueryInterface(This,riid,ppvObject)	\
    (This)->lpVtbl -> QueryInterface(This,riid,ppvObject)

#define IDirsyncSessionManager_AddRef(This)	\
    (This)->lpVtbl -> AddRef(This)

#define IDirsyncSessionManager_Release(This)	\
    (This)->lpVtbl -> Release(This)


#define IDirsyncSessionManager_get_Server(This,ppszServer)	\
    (This)->lpVtbl -> get_Server(This,ppszServer)

#define IDirsyncSessionManager_get_ServerGuid(This,ppszServerGuid)	\
    (This)->lpVtbl -> get_ServerGuid(This,ppszServerGuid)

#define IDirsyncSessionManager_get_Flags(This,pdwFlags)	\
    (This)->lpVtbl -> get_Flags(This,pdwFlags)

#define IDirsyncSessionManager_CreateSession(This,ppSession)	\
    (This)->lpVtbl -> CreateSession(This,ppSession)

#define IDirsyncSessionManager_GetSession(This,dwSessionId,ppSession)	\
    (This)->lpVtbl -> GetSession(This,dwSessionId,ppSession)

#define IDirsyncSessionManager_DeleteSession(This,dwSessionId)	\
    (This)->lpVtbl -> DeleteSession(This,dwSessionId)

#define IDirsyncSessionManager_PauseSession(This,dwSessionId,fPause)	\
    (This)->lpVtbl -> PauseSession(This,dwSessionId,fPause)

#define IDirsyncSessionManager_GetSessionCount(This,pdwSessions)	\
    (This)->lpVtbl -> GetSessionCount(This,pdwSessions)

#define IDirsyncSessionManager_GetEnumInterface(This,fGlobal,pEnumSession)	\
    (This)->lpVtbl -> GetEnumInterface(This,fGlobal,pEnumSession)

#define IDirsyncSessionManager_ExecuteSession(This,dwSessionId,dwExecuteType,fFullSync,fSynchronous,pStatus)	\
    (This)->lpVtbl -> ExecuteSession(This,dwSessionId,dwExecuteType,fFullSync,fSynchronous,pStatus)

#define IDirsyncSessionManager_CancelSession(This,dwSessionId)	\
    (This)->lpVtbl -> CancelSession(This,dwSessionId)

#endif /* COBJMACROS */


#endif 	/* C style interface */



/* [propget] */ HRESULT STDMETHODCALLTYPE IDirsyncSessionManager_get_Server_Proxy( 
    IDirsyncSessionManager * This,
    /* [retval][out] */ PWSTR *ppszServer);


void __RPC_STUB IDirsyncSessionManager_get_Server_Stub(
    IRpcStubBuffer *This,
    IRpcChannelBuffer *_pRpcChannelBuffer,
    PRPC_MESSAGE _pRpcMessage,
    DWORD *_pdwStubPhase);


/* [propget] */ HRESULT STDMETHODCALLTYPE IDirsyncSessionManager_get_ServerGuid_Proxy( 
    IDirsyncSessionManager * This,
    /* [retval][out] */ PWSTR *ppszServerGuid);


void __RPC_STUB IDirsyncSessionManager_get_ServerGuid_Stub(
    IRpcStubBuffer *This,
    IRpcChannelBuffer *_pRpcChannelBuffer,
    PRPC_MESSAGE _pRpcMessage,
    DWORD *_pdwStubPhase);


/* [propget] */ HRESULT STDMETHODCALLTYPE IDirsyncSessionManager_get_Flags_Proxy( 
    IDirsyncSessionManager * This,
    /* [retval][out] */ DWORD *pdwFlags);


void __RPC_STUB IDirsyncSessionManager_get_Flags_Stub(
    IRpcStubBuffer *This,
    IRpcChannelBuffer *_pRpcChannelBuffer,
    PRPC_MESSAGE _pRpcMessage,
    DWORD *_pdwStubPhase);


HRESULT STDMETHODCALLTYPE IDirsyncSessionManager_CreateSession_Proxy( 
    IDirsyncSessionManager * This,
    /* [retval][out] */ IDirsyncSession **ppSession);


void __RPC_STUB IDirsyncSessionManager_CreateSession_Stub(
    IRpcStubBuffer *This,
    IRpcChannelBuffer *_pRpcChannelBuffer,
    PRPC_MESSAGE _pRpcMessage,
    DWORD *_pdwStubPhase);


HRESULT STDMETHODCALLTYPE IDirsyncSessionManager_GetSession_Proxy( 
    IDirsyncSessionManager * This,
    /* [in] */ DWORD dwSessionId,
    /* [retval][out] */ IDirsyncSession **ppSession);


void __RPC_STUB IDirsyncSessionManager_GetSession_Stub(
    IRpcStubBuffer *This,
    IRpcChannelBuffer *_pRpcChannelBuffer,
    PRPC_MESSAGE _pRpcMessage,
    DWORD *_pdwStubPhase);


HRESULT STDMETHODCALLTYPE IDirsyncSessionManager_DeleteSession_Proxy( 
    IDirsyncSessionManager * This,
    /* [in] */ DWORD dwSessionId);


void __RPC_STUB IDirsyncSessionManager_DeleteSession_Stub(
    IRpcStubBuffer *This,
    IRpcChannelBuffer *_pRpcChannelBuffer,
    PRPC_MESSAGE _pRpcMessage,
    DWORD *_pdwStubPhase);


HRESULT STDMETHODCALLTYPE IDirsyncSessionManager_PauseSession_Proxy( 
    IDirsyncSessionManager * This,
    /* [in] */ DWORD dwSessionId,
    /* [in] */ BOOL fPause);


void __RPC_STUB IDirsyncSessionManager_PauseSession_Stub(
    IRpcStubBuffer *This,
    IRpcChannelBuffer *_pRpcChannelBuffer,
    PRPC_MESSAGE _pRpcMessage,
    DWORD *_pdwStubPhase);


HRESULT STDMETHODCALLTYPE IDirsyncSessionManager_GetSessionCount_Proxy( 
    IDirsyncSessionManager * This,
    /* [retval][out] */ DWORD *pdwSessions);


void __RPC_STUB IDirsyncSessionManager_GetSessionCount_Stub(
    IRpcStubBuffer *This,
    IRpcChannelBuffer *_pRpcChannelBuffer,
    PRPC_MESSAGE _pRpcMessage,
    DWORD *_pdwStubPhase);


HRESULT STDMETHODCALLTYPE IDirsyncSessionManager_GetEnumInterface_Proxy( 
    IDirsyncSessionManager * This,
    /* [in] */ BOOL fGlobal,
    /* [retval][out] */ IEnumDirsyncSession **pEnumSession);


void __RPC_STUB IDirsyncSessionManager_GetEnumInterface_Stub(
    IRpcStubBuffer *This,
    IRpcChannelBuffer *_pRpcChannelBuffer,
    PRPC_MESSAGE _pRpcMessage,
    DWORD *_pdwStubPhase);


HRESULT STDMETHODCALLTYPE IDirsyncSessionManager_ExecuteSession_Proxy( 
    IDirsyncSessionManager * This,
    /* [in] */ DWORD dwSessionId,
    /* [in] */ DWORD dwExecuteType,
    /* [in] */ BOOL fFullSync,
    /* [in] */ BOOL fSynchronous,
    /* [in] */ IDirsyncStatus *pStatus);


void __RPC_STUB IDirsyncSessionManager_ExecuteSession_Stub(
    IRpcStubBuffer *This,
    IRpcChannelBuffer *_pRpcChannelBuffer,
    PRPC_MESSAGE _pRpcMessage,
    DWORD *_pdwStubPhase);


HRESULT STDMETHODCALLTYPE IDirsyncSessionManager_CancelSession_Proxy( 
    IDirsyncSessionManager * This,
    /* [in] */ DWORD dwSessionId);


void __RPC_STUB IDirsyncSessionManager_CancelSession_Stub(
    IRpcStubBuffer *This,
    IRpcChannelBuffer *_pRpcChannelBuffer,
    PRPC_MESSAGE _pRpcMessage,
    DWORD *_pdwStubPhase);



#endif 	/* __IDirsyncSessionManager_INTERFACE_DEFINED__ */


/* interface __MIDL_itf_dirsync_0112 */
/* [local] */ 


enum ExecutionType
    {	EXECUTESESSION_FORWARD	= 1,
	EXECUTESESSION_REVERSE	= 2,
	EXECUTESESSION_FORWARD_REVERSE	= 3,
	EXECUTESESSION_REVERSE_FORWARD	= 4
    } ;



extern RPC_IF_HANDLE __MIDL_itf_dirsync_0112_v0_0_c_ifspec;
extern RPC_IF_HANDLE __MIDL_itf_dirsync_0112_v0_0_s_ifspec;

#ifndef __IDirsyncObjectMapper_INTERFACE_DEFINED__
#define __IDirsyncObjectMapper_INTERFACE_DEFINED__

/* interface IDirsyncObjectMapper */
/* [unique][helpstring][uuid][local][object] */ 


EXTERN_C const IID IID_IDirsyncObjectMapper;

#if defined(__cplusplus) && !defined(CINTERFACE)
    
    MIDL_INTERFACE("c5cf7e60-e91f-11d1-b40f-00c04fb950dc")
    IDirsyncObjectMapper : public IUnknown
    {
    public:
        virtual HRESULT STDMETHODCALLTYPE Initialize( 
            /* [in] */ IDirsyncSession *pSession,
            /* [in] */ IDirsyncSessionCallback *pSessionCallback,
            /* [in] */ IDirsyncSessionManager *pSessionManager,
            /* [in] */ SYNCDIRECTION syncDirection,
            /* [in] */ BOOL fFullSync) = 0;
        
        virtual HRESULT STDMETHODCALLTYPE MapObject( 
            /* [out][in] */ PDIRSYNCOBJECT pObject,
            /* [out][in] */ BOOL *pfMore) = 0;
        
        virtual HRESULT STDMETHODCALLTYPE MapAttributeName( 
            /* [in] */ PWSTR pszClassIn,
            /* [in] */ PWSTR pszAttrIn,
            /* [out] */ PWSTR *ppszAttrOut,
            /* [in] */ SYNCDIRECTION syncDirection) = 0;
        
        virtual HRESULT STDMETHODCALLTYPE MapNamespace( 
            /* [in] */ PWSTR pszSourceDN,
            /* [out] */ PWSTR *ppszTargetDN,
            /* [in] */ PWSTR pszClassName,
            /* [in] */ PWSTR pszAttrName) = 0;
        
        virtual HRESULT STDMETHODCALLTYPE IsClassMappingValid( 
            /* [in] */ PWSTR pszClassSource,
            /* [in] */ PWSTR pszClassTarget) = 0;
        
    };
    
#else 	/* C style interface */

    typedef struct IDirsyncObjectMapperVtbl
    {
        BEGIN_INTERFACE
        
        HRESULT ( STDMETHODCALLTYPE *QueryInterface )( 
            IDirsyncObjectMapper * This,
            /* [in] */ REFIID riid,
            /* [iid_is][out] */ void **ppvObject);
        
        ULONG ( STDMETHODCALLTYPE *AddRef )( 
            IDirsyncObjectMapper * This);
        
        ULONG ( STDMETHODCALLTYPE *Release )( 
            IDirsyncObjectMapper * This);
        
        HRESULT ( STDMETHODCALLTYPE *Initialize )( 
            IDirsyncObjectMapper * This,
            /* [in] */ IDirsyncSession *pSession,
            /* [in] */ IDirsyncSessionCallback *pSessionCallback,
            /* [in] */ IDirsyncSessionManager *pSessionManager,
            /* [in] */ SYNCDIRECTION syncDirection,
            /* [in] */ BOOL fFullSync);
        
        HRESULT ( STDMETHODCALLTYPE *MapObject )( 
            IDirsyncObjectMapper * This,
            /* [out][in] */ PDIRSYNCOBJECT pObject,
            /* [out][in] */ BOOL *pfMore);
        
        HRESULT ( STDMETHODCALLTYPE *MapAttributeName )( 
            IDirsyncObjectMapper * This,
            /* [in] */ PWSTR pszClassIn,
            /* [in] */ PWSTR pszAttrIn,
            /* [out] */ PWSTR *ppszAttrOut,
            /* [in] */ SYNCDIRECTION syncDirection);
        
        HRESULT ( STDMETHODCALLTYPE *MapNamespace )( 
            IDirsyncObjectMapper * This,
            /* [in] */ PWSTR pszSourceDN,
            /* [out] */ PWSTR *ppszTargetDN,
            /* [in] */ PWSTR pszClassName,
            /* [in] */ PWSTR pszAttrName);
        
        HRESULT ( STDMETHODCALLTYPE *IsClassMappingValid )( 
            IDirsyncObjectMapper * This,
            /* [in] */ PWSTR pszClassSource,
            /* [in] */ PWSTR pszClassTarget);
        
        END_INTERFACE
    } IDirsyncObjectMapperVtbl;

    interface IDirsyncObjectMapper
    {
        CONST_VTBL struct IDirsyncObjectMapperVtbl *lpVtbl;
    };

    

#ifdef COBJMACROS


#define IDirsyncObjectMapper_QueryInterface(This,riid,ppvObject)	\
    (This)->lpVtbl -> QueryInterface(This,riid,ppvObject)

#define IDirsyncObjectMapper_AddRef(This)	\
    (This)->lpVtbl -> AddRef(This)

#define IDirsyncObjectMapper_Release(This)	\
    (This)->lpVtbl -> Release(This)


#define IDirsyncObjectMapper_Initialize(This,pSession,pSessionCallback,pSessionManager,syncDirection,fFullSync)	\
    (This)->lpVtbl -> Initialize(This,pSession,pSessionCallback,pSessionManager,syncDirection,fFullSync)

#define IDirsyncObjectMapper_MapObject(This,pObject,pfMore)	\
    (This)->lpVtbl -> MapObject(This,pObject,pfMore)

#define IDirsyncObjectMapper_MapAttributeName(This,pszClassIn,pszAttrIn,ppszAttrOut,syncDirection)	\
    (This)->lpVtbl -> MapAttributeName(This,pszClassIn,pszAttrIn,ppszAttrOut,syncDirection)

#define IDirsyncObjectMapper_MapNamespace(This,pszSourceDN,ppszTargetDN,pszClassName,pszAttrName)	\
    (This)->lpVtbl -> MapNamespace(This,pszSourceDN,ppszTargetDN,pszClassName,pszAttrName)

#define IDirsyncObjectMapper_IsClassMappingValid(This,pszClassSource,pszClassTarget)	\
    (This)->lpVtbl -> IsClassMappingValid(This,pszClassSource,pszClassTarget)

#endif /* COBJMACROS */


#endif 	/* C style interface */



HRESULT STDMETHODCALLTYPE IDirsyncObjectMapper_Initialize_Proxy( 
    IDirsyncObjectMapper * This,
    /* [in] */ IDirsyncSession *pSession,
    /* [in] */ IDirsyncSessionCallback *pSessionCallback,
    /* [in] */ IDirsyncSessionManager *pSessionManager,
    /* [in] */ SYNCDIRECTION syncDirection,
    /* [in] */ BOOL fFullSync);


void __RPC_STUB IDirsyncObjectMapper_Initialize_Stub(
    IRpcStubBuffer *This,
    IRpcChannelBuffer *_pRpcChannelBuffer,
    PRPC_MESSAGE _pRpcMessage,
    DWORD *_pdwStubPhase);


HRESULT STDMETHODCALLTYPE IDirsyncObjectMapper_MapObject_Proxy( 
    IDirsyncObjectMapper * This,
    /* [out][in] */ PDIRSYNCOBJECT pObject,
    /* [out][in] */ BOOL *pfMore);


void __RPC_STUB IDirsyncObjectMapper_MapObject_Stub(
    IRpcStubBuffer *This,
    IRpcChannelBuffer *_pRpcChannelBuffer,
    PRPC_MESSAGE _pRpcMessage,
    DWORD *_pdwStubPhase);


HRESULT STDMETHODCALLTYPE IDirsyncObjectMapper_MapAttributeName_Proxy( 
    IDirsyncObjectMapper * This,
    /* [in] */ PWSTR pszClassIn,
    /* [in] */ PWSTR pszAttrIn,
    /* [out] */ PWSTR *ppszAttrOut,
    /* [in] */ SYNCDIRECTION syncDirection);


void __RPC_STUB IDirsyncObjectMapper_MapAttributeName_Stub(
    IRpcStubBuffer *This,
    IRpcChannelBuffer *_pRpcChannelBuffer,
    PRPC_MESSAGE _pRpcMessage,
    DWORD *_pdwStubPhase);


HRESULT STDMETHODCALLTYPE IDirsyncObjectMapper_MapNamespace_Proxy( 
    IDirsyncObjectMapper * This,
    /* [in] */ PWSTR pszSourceDN,
    /* [out] */ PWSTR *ppszTargetDN,
    /* [in] */ PWSTR pszClassName,
    /* [in] */ PWSTR pszAttrName);


void __RPC_STUB IDirsyncObjectMapper_MapNamespace_Stub(
    IRpcStubBuffer *This,
    IRpcChannelBuffer *_pRpcChannelBuffer,
    PRPC_MESSAGE _pRpcMessage,
    DWORD *_pdwStubPhase);


HRESULT STDMETHODCALLTYPE IDirsyncObjectMapper_IsClassMappingValid_Proxy( 
    IDirsyncObjectMapper * This,
    /* [in] */ PWSTR pszClassSource,
    /* [in] */ PWSTR pszClassTarget);


void __RPC_STUB IDirsyncObjectMapper_IsClassMappingValid_Stub(
    IRpcStubBuffer *This,
    IRpcChannelBuffer *_pRpcChannelBuffer,
    PRPC_MESSAGE _pRpcMessage,
    DWORD *_pdwStubPhase);



#endif 	/* __IDirsyncObjectMapper_INTERFACE_DEFINED__ */


#ifndef __IEnumDirsyncFailedObjectList_INTERFACE_DEFINED__
#define __IEnumDirsyncFailedObjectList_INTERFACE_DEFINED__

/* interface IEnumDirsyncFailedObjectList */
/* [unique][helpstring][uuid][object] */ 


EXTERN_C const IID IID_IEnumDirsyncFailedObjectList;

#if defined(__cplusplus) && !defined(CINTERFACE)
    
    MIDL_INTERFACE("a74c77a2-622b-11d2-9284-00c04f79f834")
    IEnumDirsyncFailedObjectList : public IUnknown
    {
    public:
        virtual HRESULT STDMETHODCALLTYPE Next( 
            /* [in] */ ULONG cFailedObjects,
            /* [length_is][size_is][out] */ PFAILEDOBJECT rgpFailedObjects[  ],
            /* [out] */ ULONG *pcFailedObjectsFetched) = 0;
        
        virtual HRESULT STDMETHODCALLTYPE Clone( 
            /* [retval][out] */ IEnumDirsyncFailedObjectList **ppEnum) = 0;
        
        virtual HRESULT STDMETHODCALLTYPE Reset( void) = 0;
        
        virtual HRESULT STDMETHODCALLTYPE Skip( 
            /* [in] */ ULONG cFailedObjects) = 0;
        
    };
    
#else 	/* C style interface */

    typedef struct IEnumDirsyncFailedObjectListVtbl
    {
        BEGIN_INTERFACE
        
        HRESULT ( STDMETHODCALLTYPE *QueryInterface )( 
            IEnumDirsyncFailedObjectList * This,
            /* [in] */ REFIID riid,
            /* [iid_is][out] */ void **ppvObject);
        
        ULONG ( STDMETHODCALLTYPE *AddRef )( 
            IEnumDirsyncFailedObjectList * This);
        
        ULONG ( STDMETHODCALLTYPE *Release )( 
            IEnumDirsyncFailedObjectList * This);
        
        HRESULT ( STDMETHODCALLTYPE *Next )( 
            IEnumDirsyncFailedObjectList * This,
            /* [in] */ ULONG cFailedObjects,
            /* [length_is][size_is][out] */ PFAILEDOBJECT rgpFailedObjects[  ],
            /* [out] */ ULONG *pcFailedObjectsFetched);
        
        HRESULT ( STDMETHODCALLTYPE *Clone )( 
            IEnumDirsyncFailedObjectList * This,
            /* [retval][out] */ IEnumDirsyncFailedObjectList **ppEnum);
        
        HRESULT ( STDMETHODCALLTYPE *Reset )( 
            IEnumDirsyncFailedObjectList * This);
        
        HRESULT ( STDMETHODCALLTYPE *Skip )( 
            IEnumDirsyncFailedObjectList * This,
            /* [in] */ ULONG cFailedObjects);
        
        END_INTERFACE
    } IEnumDirsyncFailedObjectListVtbl;

    interface IEnumDirsyncFailedObjectList
    {
        CONST_VTBL struct IEnumDirsyncFailedObjectListVtbl *lpVtbl;
    };

    

#ifdef COBJMACROS


#define IEnumDirsyncFailedObjectList_QueryInterface(This,riid,ppvObject)	\
    (This)->lpVtbl -> QueryInterface(This,riid,ppvObject)

#define IEnumDirsyncFailedObjectList_AddRef(This)	\
    (This)->lpVtbl -> AddRef(This)

#define IEnumDirsyncFailedObjectList_Release(This)	\
    (This)->lpVtbl -> Release(This)


#define IEnumDirsyncFailedObjectList_Next(This,cFailedObjects,rgpFailedObjects,pcFailedObjectsFetched)	\
    (This)->lpVtbl -> Next(This,cFailedObjects,rgpFailedObjects,pcFailedObjectsFetched)

#define IEnumDirsyncFailedObjectList_Clone(This,ppEnum)	\
    (This)->lpVtbl -> Clone(This,ppEnum)

#define IEnumDirsyncFailedObjectList_Reset(This)	\
    (This)->lpVtbl -> Reset(This)

#define IEnumDirsyncFailedObjectList_Skip(This,cFailedObjects)	\
    (This)->lpVtbl -> Skip(This,cFailedObjects)

#endif /* COBJMACROS */


#endif 	/* C style interface */



HRESULT STDMETHODCALLTYPE IEnumDirsyncFailedObjectList_Next_Proxy( 
    IEnumDirsyncFailedObjectList * This,
    /* [in] */ ULONG cFailedObjects,
    /* [length_is][size_is][out] */ PFAILEDOBJECT rgpFailedObjects[  ],
    /* [out] */ ULONG *pcFailedObjectsFetched);


void __RPC_STUB IEnumDirsyncFailedObjectList_Next_Stub(
    IRpcStubBuffer *This,
    IRpcChannelBuffer *_pRpcChannelBuffer,
    PRPC_MESSAGE _pRpcMessage,
    DWORD *_pdwStubPhase);


HRESULT STDMETHODCALLTYPE IEnumDirsyncFailedObjectList_Clone_Proxy( 
    IEnumDirsyncFailedObjectList * This,
    /* [retval][out] */ IEnumDirsyncFailedObjectList **ppEnum);


void __RPC_STUB IEnumDirsyncFailedObjectList_Clone_Stub(
    IRpcStubBuffer *This,
    IRpcChannelBuffer *_pRpcChannelBuffer,
    PRPC_MESSAGE _pRpcMessage,
    DWORD *_pdwStubPhase);


HRESULT STDMETHODCALLTYPE IEnumDirsyncFailedObjectList_Reset_Proxy( 
    IEnumDirsyncFailedObjectList * This);


void __RPC_STUB IEnumDirsyncFailedObjectList_Reset_Stub(
    IRpcStubBuffer *This,
    IRpcChannelBuffer *_pRpcChannelBuffer,
    PRPC_MESSAGE _pRpcMessage,
    DWORD *_pdwStubPhase);


HRESULT STDMETHODCALLTYPE IEnumDirsyncFailedObjectList_Skip_Proxy( 
    IEnumDirsyncFailedObjectList * This,
    /* [in] */ ULONG cFailedObjects);


void __RPC_STUB IEnumDirsyncFailedObjectList_Skip_Stub(
    IRpcStubBuffer *This,
    IRpcChannelBuffer *_pRpcChannelBuffer,
    PRPC_MESSAGE _pRpcMessage,
    DWORD *_pdwStubPhase);



#endif 	/* __IEnumDirsyncFailedObjectList_INTERFACE_DEFINED__ */


#ifndef __IDirsyncFailedObjectList_INTERFACE_DEFINED__
#define __IDirsyncFailedObjectList_INTERFACE_DEFINED__

/* interface IDirsyncFailedObjectList */
/* [unique][helpstring][uuid][object] */ 


EXTERN_C const IID IID_IDirsyncFailedObjectList;

#if defined(__cplusplus) && !defined(CINTERFACE)
    
    MIDL_INTERFACE("a16c0bcc-622b-11d2-9284-00c04f79f834")
    IDirsyncFailedObjectList : public IUnknown
    {
    public:
        virtual /* [propget] */ HRESULT STDMETHODCALLTYPE get_Count( 
            /* [retval][out] */ DWORD *pdwCount) = 0;
        
        virtual HRESULT STDMETHODCALLTYPE GetObject( 
            /* [in] */ PWSTR pszID,
            /* [retval][out] */ PFAILEDOBJECT *ppFailedObject) = 0;
        
        virtual HRESULT STDMETHODCALLTYPE DeleteObject( 
            /* [in] */ PWSTR pszID) = 0;
        
        virtual HRESULT STDMETHODCALLTYPE UpdateObject( 
            /* [in] */ PWSTR pszID,
            /* [in] */ PFAILEDOBJECT pFailedObject) = 0;
        
        virtual HRESULT STDMETHODCALLTYPE GetEnumInterface( 
            /* [retval][out] */ IEnumDirsyncFailedObjectList **pEnumFailedObject) = 0;
        
    };
    
#else 	/* C style interface */

    typedef struct IDirsyncFailedObjectListVtbl
    {
        BEGIN_INTERFACE
        
        HRESULT ( STDMETHODCALLTYPE *QueryInterface )( 
            IDirsyncFailedObjectList * This,
            /* [in] */ REFIID riid,
            /* [iid_is][out] */ void **ppvObject);
        
        ULONG ( STDMETHODCALLTYPE *AddRef )( 
            IDirsyncFailedObjectList * This);
        
        ULONG ( STDMETHODCALLTYPE *Release )( 
            IDirsyncFailedObjectList * This);
        
        /* [propget] */ HRESULT ( STDMETHODCALLTYPE *get_Count )( 
            IDirsyncFailedObjectList * This,
            /* [retval][out] */ DWORD *pdwCount);
        
        HRESULT ( STDMETHODCALLTYPE *GetObject )( 
            IDirsyncFailedObjectList * This,
            /* [in] */ PWSTR pszID,
            /* [retval][out] */ PFAILEDOBJECT *ppFailedObject);
        
        HRESULT ( STDMETHODCALLTYPE *DeleteObject )( 
            IDirsyncFailedObjectList * This,
            /* [in] */ PWSTR pszID);
        
        HRESULT ( STDMETHODCALLTYPE *UpdateObject )( 
            IDirsyncFailedObjectList * This,
            /* [in] */ PWSTR pszID,
            /* [in] */ PFAILEDOBJECT pFailedObject);
        
        HRESULT ( STDMETHODCALLTYPE *GetEnumInterface )( 
            IDirsyncFailedObjectList * This,
            /* [retval][out] */ IEnumDirsyncFailedObjectList **pEnumFailedObject);
        
        END_INTERFACE
    } IDirsyncFailedObjectListVtbl;

    interface IDirsyncFailedObjectList
    {
        CONST_VTBL struct IDirsyncFailedObjectListVtbl *lpVtbl;
    };

    

#ifdef COBJMACROS


#define IDirsyncFailedObjectList_QueryInterface(This,riid,ppvObject)	\
    (This)->lpVtbl -> QueryInterface(This,riid,ppvObject)

#define IDirsyncFailedObjectList_AddRef(This)	\
    (This)->lpVtbl -> AddRef(This)

#define IDirsyncFailedObjectList_Release(This)	\
    (This)->lpVtbl -> Release(This)


#define IDirsyncFailedObjectList_get_Count(This,pdwCount)	\
    (This)->lpVtbl -> get_Count(This,pdwCount)

#define IDirsyncFailedObjectList_GetObject(This,pszID,ppFailedObject)	\
    (This)->lpVtbl -> GetObject(This,pszID,ppFailedObject)

#define IDirsyncFailedObjectList_DeleteObject(This,pszID)	\
    (This)->lpVtbl -> DeleteObject(This,pszID)

#define IDirsyncFailedObjectList_UpdateObject(This,pszID,pFailedObject)	\
    (This)->lpVtbl -> UpdateObject(This,pszID,pFailedObject)

#define IDirsyncFailedObjectList_GetEnumInterface(This,pEnumFailedObject)	\
    (This)->lpVtbl -> GetEnumInterface(This,pEnumFailedObject)

#endif /* COBJMACROS */


#endif 	/* C style interface */



/* [propget] */ HRESULT STDMETHODCALLTYPE IDirsyncFailedObjectList_get_Count_Proxy( 
    IDirsyncFailedObjectList * This,
    /* [retval][out] */ DWORD *pdwCount);


void __RPC_STUB IDirsyncFailedObjectList_get_Count_Stub(
    IRpcStubBuffer *This,
    IRpcChannelBuffer *_pRpcChannelBuffer,
    PRPC_MESSAGE _pRpcMessage,
    DWORD *_pdwStubPhase);


HRESULT STDMETHODCALLTYPE IDirsyncFailedObjectList_GetObject_Proxy( 
    IDirsyncFailedObjectList * This,
    /* [in] */ PWSTR pszID,
    /* [retval][out] */ PFAILEDOBJECT *ppFailedObject);


void __RPC_STUB IDirsyncFailedObjectList_GetObject_Stub(
    IRpcStubBuffer *This,
    IRpcChannelBuffer *_pRpcChannelBuffer,
    PRPC_MESSAGE _pRpcMessage,
    DWORD *_pdwStubPhase);


HRESULT STDMETHODCALLTYPE IDirsyncFailedObjectList_DeleteObject_Proxy( 
    IDirsyncFailedObjectList * This,
    /* [in] */ PWSTR pszID);


void __RPC_STUB IDirsyncFailedObjectList_DeleteObject_Stub(
    IRpcStubBuffer *This,
    IRpcChannelBuffer *_pRpcChannelBuffer,
    PRPC_MESSAGE _pRpcMessage,
    DWORD *_pdwStubPhase);


HRESULT STDMETHODCALLTYPE IDirsyncFailedObjectList_UpdateObject_Proxy( 
    IDirsyncFailedObjectList * This,
    /* [in] */ PWSTR pszID,
    /* [in] */ PFAILEDOBJECT pFailedObject);


void __RPC_STUB IDirsyncFailedObjectList_UpdateObject_Stub(
    IRpcStubBuffer *This,
    IRpcChannelBuffer *_pRpcChannelBuffer,
    PRPC_MESSAGE _pRpcMessage,
    DWORD *_pdwStubPhase);


HRESULT STDMETHODCALLTYPE IDirsyncFailedObjectList_GetEnumInterface_Proxy( 
    IDirsyncFailedObjectList * This,
    /* [retval][out] */ IEnumDirsyncFailedObjectList **pEnumFailedObject);


void __RPC_STUB IDirsyncFailedObjectList_GetEnumInterface_Stub(
    IRpcStubBuffer *This,
    IRpcChannelBuffer *_pRpcChannelBuffer,
    PRPC_MESSAGE _pRpcMessage,
    DWORD *_pdwStubPhase);



#endif 	/* __IDirsyncFailedObjectList_INTERFACE_DEFINED__ */


/* interface __MIDL_itf_dirsync_0115 */
/* [local] */ 




extern RPC_IF_HANDLE __MIDL_itf_dirsync_0115_v0_0_c_ifspec;
extern RPC_IF_HANDLE __MIDL_itf_dirsync_0115_v0_0_s_ifspec;

#ifndef __IDirsyncNamespaceMapping_INTERFACE_DEFINED__
#define __IDirsyncNamespaceMapping_INTERFACE_DEFINED__

/* interface IDirsyncNamespaceMapping */
/* [unique][helpstring][uuid][object] */ 


EXTERN_C const IID IID_IDirsyncNamespaceMapping;

#if defined(__cplusplus) && !defined(CINTERFACE)
    
    MIDL_INTERFACE("d5a63159-88e6-4a50-833d-77da95dcb327")
    IDirsyncNamespaceMapping : public IUnknown
    {
    public:
        virtual HRESULT STDMETHODCALLTYPE GetMappings( 
            /* [size_is][size_is][out] */ PWSTR **prgpszPublisher,
            /* [size_is][size_is][out] */ PWSTR **prgpszSubscriber,
            /* [out] */ DWORD *pdwCount) = 0;
        
        virtual HRESULT STDMETHODCALLTYPE AddMappings( 
            /* [size_is][in] */ PWSTR *rgpszPublisher,
            /* [size_is][in] */ PWSTR *rgpszSubscriber,
            /* [in] */ DWORD dwCount) = 0;
        
        virtual HRESULT STDMETHODCALLTYPE DeleteMapping( 
            /* [in] */ PWSTR pszPublisher,
            /* [in] */ PWSTR pszSubscriber) = 0;
        
        virtual HRESULT STDMETHODCALLTYPE LookupMapping( 
            /* [in] */ PWSTR pszSource,
            /* [in] */ BOOL fPublisher,
            /* [in] */ PWSTR *pszTarget) = 0;
        
        virtual HRESULT STDMETHODCALLTYPE UpdateMapping( 
            /* [in] */ PWSTR pszPublisherOld,
            /* [in] */ PWSTR pszSubscriberOld,
            /* [in] */ PWSTR pszPublisher,
            /* [in] */ PWSTR pszSubscriber) = 0;
        
        virtual HRESULT STDMETHODCALLTYPE ClearMappings( void) = 0;
        
        virtual HRESULT STDMETHODCALLTYPE Persist( void) = 0;
        
    };
    
#else 	/* C style interface */

    typedef struct IDirsyncNamespaceMappingVtbl
    {
        BEGIN_INTERFACE
        
        HRESULT ( STDMETHODCALLTYPE *QueryInterface )( 
            IDirsyncNamespaceMapping * This,
            /* [in] */ REFIID riid,
            /* [iid_is][out] */ void **ppvObject);
        
        ULONG ( STDMETHODCALLTYPE *AddRef )( 
            IDirsyncNamespaceMapping * This);
        
        ULONG ( STDMETHODCALLTYPE *Release )( 
            IDirsyncNamespaceMapping * This);
        
        HRESULT ( STDMETHODCALLTYPE *GetMappings )( 
            IDirsyncNamespaceMapping * This,
            /* [size_is][size_is][out] */ PWSTR **prgpszPublisher,
            /* [size_is][size_is][out] */ PWSTR **prgpszSubscriber,
            /* [out] */ DWORD *pdwCount);
        
        HRESULT ( STDMETHODCALLTYPE *AddMappings )( 
            IDirsyncNamespaceMapping * This,
            /* [size_is][in] */ PWSTR *rgpszPublisher,
            /* [size_is][in] */ PWSTR *rgpszSubscriber,
            /* [in] */ DWORD dwCount);
        
        HRESULT ( STDMETHODCALLTYPE *DeleteMapping )( 
            IDirsyncNamespaceMapping * This,
            /* [in] */ PWSTR pszPublisher,
            /* [in] */ PWSTR pszSubscriber);
        
        HRESULT ( STDMETHODCALLTYPE *LookupMapping )( 
            IDirsyncNamespaceMapping * This,
            /* [in] */ PWSTR pszSource,
            /* [in] */ BOOL fPublisher,
            /* [in] */ PWSTR *pszTarget);
        
        HRESULT ( STDMETHODCALLTYPE *UpdateMapping )( 
            IDirsyncNamespaceMapping * This,
            /* [in] */ PWSTR pszPublisherOld,
            /* [in] */ PWSTR pszSubscriberOld,
            /* [in] */ PWSTR pszPublisher,
            /* [in] */ PWSTR pszSubscriber);
        
        HRESULT ( STDMETHODCALLTYPE *ClearMappings )( 
            IDirsyncNamespaceMapping * This);
        
        HRESULT ( STDMETHODCALLTYPE *Persist )( 
            IDirsyncNamespaceMapping * This);
        
        END_INTERFACE
    } IDirsyncNamespaceMappingVtbl;

    interface IDirsyncNamespaceMapping
    {
        CONST_VTBL struct IDirsyncNamespaceMappingVtbl *lpVtbl;
    };

    

#ifdef COBJMACROS


#define IDirsyncNamespaceMapping_QueryInterface(This,riid,ppvObject)	\
    (This)->lpVtbl -> QueryInterface(This,riid,ppvObject)

#define IDirsyncNamespaceMapping_AddRef(This)	\
    (This)->lpVtbl -> AddRef(This)

#define IDirsyncNamespaceMapping_Release(This)	\
    (This)->lpVtbl -> Release(This)


#define IDirsyncNamespaceMapping_GetMappings(This,prgpszPublisher,prgpszSubscriber,pdwCount)	\
    (This)->lpVtbl -> GetMappings(This,prgpszPublisher,prgpszSubscriber,pdwCount)

#define IDirsyncNamespaceMapping_AddMappings(This,rgpszPublisher,rgpszSubscriber,dwCount)	\
    (This)->lpVtbl -> AddMappings(This,rgpszPublisher,rgpszSubscriber,dwCount)

#define IDirsyncNamespaceMapping_DeleteMapping(This,pszPublisher,pszSubscriber)	\
    (This)->lpVtbl -> DeleteMapping(This,pszPublisher,pszSubscriber)

#define IDirsyncNamespaceMapping_LookupMapping(This,pszSource,fPublisher,pszTarget)	\
    (This)->lpVtbl -> LookupMapping(This,pszSource,fPublisher,pszTarget)

#define IDirsyncNamespaceMapping_UpdateMapping(This,pszPublisherOld,pszSubscriberOld,pszPublisher,pszSubscriber)	\
    (This)->lpVtbl -> UpdateMapping(This,pszPublisherOld,pszSubscriberOld,pszPublisher,pszSubscriber)

#define IDirsyncNamespaceMapping_ClearMappings(This)	\
    (This)->lpVtbl -> ClearMappings(This)

#define IDirsyncNamespaceMapping_Persist(This)	\
    (This)->lpVtbl -> Persist(This)

#endif /* COBJMACROS */


#endif 	/* C style interface */



HRESULT STDMETHODCALLTYPE IDirsyncNamespaceMapping_GetMappings_Proxy( 
    IDirsyncNamespaceMapping * This,
    /* [size_is][size_is][out] */ PWSTR **prgpszPublisher,
    /* [size_is][size_is][out] */ PWSTR **prgpszSubscriber,
    /* [out] */ DWORD *pdwCount);


void __RPC_STUB IDirsyncNamespaceMapping_GetMappings_Stub(
    IRpcStubBuffer *This,
    IRpcChannelBuffer *_pRpcChannelBuffer,
    PRPC_MESSAGE _pRpcMessage,
    DWORD *_pdwStubPhase);


HRESULT STDMETHODCALLTYPE IDirsyncNamespaceMapping_AddMappings_Proxy( 
    IDirsyncNamespaceMapping * This,
    /* [size_is][in] */ PWSTR *rgpszPublisher,
    /* [size_is][in] */ PWSTR *rgpszSubscriber,
    /* [in] */ DWORD dwCount);


void __RPC_STUB IDirsyncNamespaceMapping_AddMappings_Stub(
    IRpcStubBuffer *This,
    IRpcChannelBuffer *_pRpcChannelBuffer,
    PRPC_MESSAGE _pRpcMessage,
    DWORD *_pdwStubPhase);


HRESULT STDMETHODCALLTYPE IDirsyncNamespaceMapping_DeleteMapping_Proxy( 
    IDirsyncNamespaceMapping * This,
    /* [in] */ PWSTR pszPublisher,
    /* [in] */ PWSTR pszSubscriber);


void __RPC_STUB IDirsyncNamespaceMapping_DeleteMapping_Stub(
    IRpcStubBuffer *This,
    IRpcChannelBuffer *_pRpcChannelBuffer,
    PRPC_MESSAGE _pRpcMessage,
    DWORD *_pdwStubPhase);


HRESULT STDMETHODCALLTYPE IDirsyncNamespaceMapping_LookupMapping_Proxy( 
    IDirsyncNamespaceMapping * This,
    /* [in] */ PWSTR pszSource,
    /* [in] */ BOOL fPublisher,
    /* [in] */ PWSTR *pszTarget);


void __RPC_STUB IDirsyncNamespaceMapping_LookupMapping_Stub(
    IRpcStubBuffer *This,
    IRpcChannelBuffer *_pRpcChannelBuffer,
    PRPC_MESSAGE _pRpcMessage,
    DWORD *_pdwStubPhase);


HRESULT STDMETHODCALLTYPE IDirsyncNamespaceMapping_UpdateMapping_Proxy( 
    IDirsyncNamespaceMapping * This,
    /* [in] */ PWSTR pszPublisherOld,
    /* [in] */ PWSTR pszSubscriberOld,
    /* [in] */ PWSTR pszPublisher,
    /* [in] */ PWSTR pszSubscriber);


void __RPC_STUB IDirsyncNamespaceMapping_UpdateMapping_Stub(
    IRpcStubBuffer *This,
    IRpcChannelBuffer *_pRpcChannelBuffer,
    PRPC_MESSAGE _pRpcMessage,
    DWORD *_pdwStubPhase);


HRESULT STDMETHODCALLTYPE IDirsyncNamespaceMapping_ClearMappings_Proxy( 
    IDirsyncNamespaceMapping * This);


void __RPC_STUB IDirsyncNamespaceMapping_ClearMappings_Stub(
    IRpcStubBuffer *This,
    IRpcChannelBuffer *_pRpcChannelBuffer,
    PRPC_MESSAGE _pRpcMessage,
    DWORD *_pdwStubPhase);


HRESULT STDMETHODCALLTYPE IDirsyncNamespaceMapping_Persist_Proxy( 
    IDirsyncNamespaceMapping * This);


void __RPC_STUB IDirsyncNamespaceMapping_Persist_Stub(
    IRpcStubBuffer *This,
    IRpcChannelBuffer *_pRpcChannelBuffer,
    PRPC_MESSAGE _pRpcMessage,
    DWORD *_pdwStubPhase);



#endif 	/* __IDirsyncNamespaceMapping_INTERFACE_DEFINED__ */


/* interface __MIDL_itf_dirsync_0116 */
/* [local] */ 

//
// Bit fields
//

#define SESSION_NAME                0x00000001
#define SESSION_COMMENTS            0x00000002
#define SESSION_FLAGS               0x00000004
#define SESSION_LOGLEVEL            0x00000008
#define SESSION_SCHEDULE_FORWARD    0x00000010
#define SESSION_SCHEDULE_REVERSE    0x00000020
#define SESSION_SRCDIRTYPE          0x00000040
#define SESSION_SRCSERVER           0x00000080
#define SESSION_SRCUSERNAME         0x00000100
#define SESSION_SRCPASSWORD         0x00000200
#define SESSION_SRCBASE             0x00000400
#define SESSION_SRCSCOPE            0x00000800
#define SESSION_SRCFILTER           0x00001000
#define SESSION_SRCPASSWORDOPTIONS  0x00002000
#define SESSION_TGTDIRTYPE          0x00004000
#define SESSION_TGTSERVER           0x00008000
#define SESSION_TGTUSERNAME         0x00010000
#define SESSION_TGTPASSWORD         0x00020000
#define SESSION_TGTBASE             0x00040000
#define SESSION_TGTSCOPE            0x00080000
#define SESSION_TGTFILTER           0x00100000
#define SESSION_TGTPASSWORDOPTIONS  0x00200000
#define SESSION_MAPFORWARD          0x00400000
#define SESSION_MAPBACKWARD         0x00800000
#define SESSION_NAMESPACEMAP        0x01000000
#define SESSION_FINEGRAINSTATUS     0x02000000


//
// Session Status
//

#define SESSION_PAUSED       1
#define SESSION_IDLE         2
#define SESSION_IN_PROGRESS  3

//
// Session Flags
//

#define FLAG_FIXUP_SAMACCOUNTNAME_CONFLICT   0x00000001
#define FLAG_FAIL_DN_CONFLICT                0x00000002
#define FLAG_CUSTOM_NAMESPACE_MAPPING        0x00000004
#define FLAG_OBJECTS_HAVE_UNIQUE_ID          0x00000008
#define FLAG_PUBLISHER_ID_IS_INDEXED         0x00000010
#define FLAG_SUBSCRIBER_ID_IS_INDEXED        0x00000020
#define FLAG_INC_SYNC_NOT_AVAILABLE          0x00000040




extern RPC_IF_HANDLE __MIDL_itf_dirsync_0116_v0_0_c_ifspec;
extern RPC_IF_HANDLE __MIDL_itf_dirsync_0116_v0_0_s_ifspec;

#ifndef __IDirsyncSession_INTERFACE_DEFINED__
#define __IDirsyncSession_INTERFACE_DEFINED__

/* interface IDirsyncSession */
/* [unique][helpstring][uuid][object] */ 


EXTERN_C const IID IID_IDirsyncSession;

#if defined(__cplusplus) && !defined(CINTERFACE)
    
    MIDL_INTERFACE("3d72b13e-c8ec-11d1-a40b-00c04fb950dc")
    IDirsyncSession : public IUnknown
    {
    public:
        virtual /* [propget] */ HRESULT STDMETHODCALLTYPE get_Name( 
            /* [retval][out] */ PWSTR *ppszName) = 0;
        
        virtual /* [propput] */ HRESULT STDMETHODCALLTYPE put_Name( 
            /* [full][in] */ PWSTR pszName) = 0;
        
        virtual /* [propget] */ HRESULT STDMETHODCALLTYPE get_Comments( 
            /* [retval][out] */ PWSTR *ppszComments) = 0;
        
        virtual /* [propput] */ HRESULT STDMETHODCALLTYPE put_Comments( 
            /* [full][in] */ PWSTR pszComments) = 0;
        
        virtual /* [propget] */ HRESULT STDMETHODCALLTYPE get_Flags( 
            /* [retval][out] */ DWORD *pdwFlags) = 0;
        
        virtual /* [propput] */ HRESULT STDMETHODCALLTYPE put_Flags( 
            /* [in] */ DWORD dwFlags) = 0;
        
        virtual /* [propget] */ HRESULT STDMETHODCALLTYPE get_Status( 
            /* [retval][out] */ DWORD *pdwStatus) = 0;
        
        virtual /* [propget] */ HRESULT STDMETHODCALLTYPE get_LogLevel( 
            /* [retval][out] */ DWORD *pdwLogLevel) = 0;
        
        virtual /* [propput] */ HRESULT STDMETHODCALLTYPE put_LogLevel( 
            /* [in] */ DWORD dwLogLevel) = 0;
        
        virtual /* [propget] */ HRESULT STDMETHODCALLTYPE get_ID( 
            /* [retval][out] */ DWORD *pdwID) = 0;
        
        virtual /* [propget] */ HRESULT STDMETHODCALLTYPE get_CreatedBy( 
            /* [retval][out] */ PWSTR *ppszCreatedBy) = 0;
        
        virtual /* [propget] */ HRESULT STDMETHODCALLTYPE get_CreationTime( 
            /* [retval][out] */ LARGE_INTEGER *pCreationTime) = 0;
        
        virtual /* [propget] */ HRESULT STDMETHODCALLTYPE get_LastChangedBy( 
            /* [retval][out] */ PWSTR *ppszLastChangedBy) = 0;
        
        virtual /* [propget] */ HRESULT STDMETHODCALLTYPE get_LastChangeTime( 
            /* [retval][out] */ LARGE_INTEGER *pLastChangeTime) = 0;
        
        virtual /* [propget] */ HRESULT STDMETHODCALLTYPE get_SourceDirType( 
            /* [retval][out] */ PWSTR *ppszSourceDirType) = 0;
        
        virtual /* [propput] */ HRESULT STDMETHODCALLTYPE put_SourceDirType( 
            /* [full][in] */ PWSTR pszSourceDirType) = 0;
        
        virtual /* [propget] */ HRESULT STDMETHODCALLTYPE get_SourceServer( 
            /* [retval][out] */ PWSTR *ppszSourceServer) = 0;
        
        virtual /* [propput] */ HRESULT STDMETHODCALLTYPE put_SourceServer( 
            /* [full][in] */ PWSTR pszSourceServer) = 0;
        
        virtual /* [propget] */ HRESULT STDMETHODCALLTYPE get_SourceUsername( 
            /* [retval][out] */ PWSTR *ppszSourceUsername) = 0;
        
        virtual /* [propput] */ HRESULT STDMETHODCALLTYPE put_SourceUsername( 
            /* [full][in] */ PWSTR pszSourceUsername) = 0;
        
        virtual /* [propget] */ HRESULT STDMETHODCALLTYPE get_SourcePassword( 
            /* [retval][out] */ PWSTR *ppszSourcePassword) = 0;
        
        virtual /* [propput] */ HRESULT STDMETHODCALLTYPE put_SourcePassword( 
            /* [full][in] */ PWSTR pszSourcePassword) = 0;
        
        virtual /* [propget] */ HRESULT STDMETHODCALLTYPE get_SourceBase( 
            /* [retval][out] */ PWSTR *ppszSourceBase) = 0;
        
        virtual /* [propput] */ HRESULT STDMETHODCALLTYPE put_SourceBase( 
            /* [full][in] */ PWSTR pszSourceBase) = 0;
        
        virtual /* [propget] */ HRESULT STDMETHODCALLTYPE get_SourceScope( 
            /* [retval][out] */ DWORD *pdwSourceScope) = 0;
        
        virtual /* [propput] */ HRESULT STDMETHODCALLTYPE put_SourceScope( 
            /* [in] */ DWORD dwSourceScope) = 0;
        
        virtual /* [propget] */ HRESULT STDMETHODCALLTYPE get_SourceFilter( 
            /* [retval][out] */ PWSTR *ppszSourceFilter) = 0;
        
        virtual /* [propput] */ HRESULT STDMETHODCALLTYPE put_SourceFilter( 
            /* [full][in] */ PWSTR pszSourceFilter) = 0;
        
        virtual /* [propget] */ HRESULT STDMETHODCALLTYPE get_TargetDirType( 
            /* [retval][out] */ PWSTR *ppszTargetDirType) = 0;
        
        virtual /* [propput] */ HRESULT STDMETHODCALLTYPE put_TargetDirType( 
            /* [full][in] */ PWSTR pszTargetDirType) = 0;
        
        virtual /* [propget] */ HRESULT STDMETHODCALLTYPE get_TargetServer( 
            /* [retval][out] */ PWSTR *ppszTargetServer) = 0;
        
        virtual /* [propput] */ HRESULT STDMETHODCALLTYPE put_TargetServer( 
            /* [full][in] */ PWSTR pszTargetServer) = 0;
        
        virtual /* [propget] */ HRESULT STDMETHODCALLTYPE get_TargetUsername( 
            /* [retval][out] */ PWSTR *ppszTargetUsername) = 0;
        
        virtual /* [propput] */ HRESULT STDMETHODCALLTYPE put_TargetUsername( 
            /* [full][in] */ PWSTR pszTargetUsername) = 0;
        
        virtual /* [propget] */ HRESULT STDMETHODCALLTYPE get_TargetPassword( 
            /* [retval][out] */ PWSTR *ppszTargetPassword) = 0;
        
        virtual /* [propput] */ HRESULT STDMETHODCALLTYPE put_TargetPassword( 
            /* [full][in] */ PWSTR pszTargetPassword) = 0;
        
        virtual /* [propget] */ HRESULT STDMETHODCALLTYPE get_TargetBase( 
            /* [retval][out] */ PWSTR *ppszTargetBase) = 0;
        
        virtual /* [propput] */ HRESULT STDMETHODCALLTYPE put_TargetBase( 
            /* [full][in] */ PWSTR pszTargetBase) = 0;
        
        virtual /* [propget] */ HRESULT STDMETHODCALLTYPE get_TargetScope( 
            /* [retval][out] */ DWORD *pdwTargetScope) = 0;
        
        virtual /* [propput] */ HRESULT STDMETHODCALLTYPE put_TargetScope( 
            /* [in] */ DWORD dwTargetScope) = 0;
        
        virtual /* [propget] */ HRESULT STDMETHODCALLTYPE get_TargetFilter( 
            /* [retval][out] */ PWSTR *ppszTargetFilter) = 0;
        
        virtual /* [propput] */ HRESULT STDMETHODCALLTYPE put_TargetFilter( 
            /* [full][in] */ PWSTR pszTargetFilter) = 0;
        
        virtual /* [propget] */ HRESULT STDMETHODCALLTYPE get_Server( 
            /* [retval][out] */ PWSTR *ppszServer) = 0;
        
        virtual HRESULT STDMETHODCALLTYPE SetData( 
            /* [in] */ PSESSIONDATA pData) = 0;
        
        virtual HRESULT STDMETHODCALLTYPE GetData( 
            /* [out] */ PSESSIONDATA *ppData) = 0;
        
        virtual HRESULT STDMETHODCALLTYPE SetSchedule( 
            /* [in] */ SYNCDIRECTION syncDirection,
            /* [in] */ BYTE schedule[ 84 ]) = 0;
        
        virtual HRESULT STDMETHODCALLTYPE GetSchedule( 
            /* [in] */ SYNCDIRECTION syncDirection,
            /* [out] */ BYTE schedule[ 84 ]) = 0;
        
        virtual HRESULT STDMETHODCALLTYPE SetMap( 
            /* [in] */ SYNCDIRECTION syncDirection,
            /* [size_is][in] */ PBYTE pByte,
            /* [in] */ DWORD dwSize) = 0;
        
        virtual HRESULT STDMETHODCALLTYPE GetMap( 
            /* [in] */ SYNCDIRECTION syncDirection,
            /* [size_is][size_is][out] */ PBYTE *ppByte,
            /* [out] */ DWORD *pdwSize) = 0;
        
        virtual HRESULT STDMETHODCALLTYPE SetPasswordOptions( 
            /* [in] */ SYNCDIRECTION syncDirection,
            /* [in] */ PASSWORDTYPE passwordType,
            /* [in] */ PWSTR pszPassword) = 0;
        
        virtual HRESULT STDMETHODCALLTYPE GetPasswordOptions( 
            /* [in] */ SYNCDIRECTION syncDirection,
            /* [out] */ PASSWORDTYPE *pPasswordType,
            /* [out] */ PWSTR *ppszPassword) = 0;
        
        virtual HRESULT STDMETHODCALLTYPE Persist( 
            /* [in] */ BOOL fForce,
            /* [size_is][size_is][full][out][in] */ PGLOBAL_SESSIONID *prgSessionID,
            /* [full][out][in] */ DWORD *pdwSize) = 0;
        
        virtual HRESULT STDMETHODCALLTYPE SetAuxData( 
            /* [size_is][in] */ PADS_ATTR_INFO pAttributeEntries,
            /* [in] */ DWORD dwNumAttributes,
            /* [out] */ DWORD *pdwNumAttributesModified) = 0;
        
        virtual HRESULT STDMETHODCALLTYPE GetAuxData( 
            /* [size_is][in] */ PWSTR *pAttributeName,
            /* [in] */ DWORD dwNumAttributes,
            /* [size_is][size_is][out] */ PADS_ATTR_INFO *ppAttributeEntries,
            /* [out] */ DWORD *pdwAttributesReturned) = 0;
        
        virtual HRESULT STDMETHODCALLTYPE GetFailedObjectList( 
            /* [retval][out] */ IDirsyncFailedObjectList **pFailedObjectList) = 0;
        
        virtual HRESULT STDMETHODCALLTYPE GetNamespaceMapping( 
            /* [retval][out] */ IDirsyncNamespaceMapping **pNamespaceMapping) = 0;
        
        virtual HRESULT STDMETHODCALLTYPE GetRuntimeNamespaceMapping( 
            /* [retval][out] */ IDirsyncNamespaceMapping **pNamespaceMapping) = 0;
        
        virtual HRESULT STDMETHODCALLTYPE IsClassMappingValid( 
            /* [in] */ PWSTR pszClassSource,
            /* [in] */ PWSTR pszClassTarget) = 0;
        
        virtual /* [propget] */ HRESULT STDMETHODCALLTYPE get_ObjMapFilePath( 
            /* [retval][out] */ PWSTR *ppszObjMapFilePath) = 0;
        
        virtual /* [propput] */ HRESULT STDMETHODCALLTYPE put_ObjMapFilePath( 
            /* [full][in] */ PWSTR pszObjMapFilePath) = 0;
        
        virtual HRESULT STDMETHODCALLTYPE GetSyncStatus( 
            /* [out] */ DWORD *pdwPercent,
            /* [out] */ DWORD *pdwWarning,
            /* [out] */ DWORD *pdwError) = 0;
        
        virtual HRESULT STDMETHODCALLTYPE UpdateTerminationStatus( void) = 0;
        
    };
    
#else 	/* C style interface */

    typedef struct IDirsyncSessionVtbl
    {
        BEGIN_INTERFACE
        
        HRESULT ( STDMETHODCALLTYPE *QueryInterface )( 
            IDirsyncSession * This,
            /* [in] */ REFIID riid,
            /* [iid_is][out] */ void **ppvObject);
        
        ULONG ( STDMETHODCALLTYPE *AddRef )( 
            IDirsyncSession * This);
        
        ULONG ( STDMETHODCALLTYPE *Release )( 
            IDirsyncSession * This);
        
        /* [propget] */ HRESULT ( STDMETHODCALLTYPE *get_Name )( 
            IDirsyncSession * This,
            /* [retval][out] */ PWSTR *ppszName);
        
        /* [propput] */ HRESULT ( STDMETHODCALLTYPE *put_Name )( 
            IDirsyncSession * This,
            /* [full][in] */ PWSTR pszName);
        
        /* [propget] */ HRESULT ( STDMETHODCALLTYPE *get_Comments )( 
            IDirsyncSession * This,
            /* [retval][out] */ PWSTR *ppszComments);
        
        /* [propput] */ HRESULT ( STDMETHODCALLTYPE *put_Comments )( 
            IDirsyncSession * This,
            /* [full][in] */ PWSTR pszComments);
        
        /* [propget] */ HRESULT ( STDMETHODCALLTYPE *get_Flags )( 
            IDirsyncSession * This,
            /* [retval][out] */ DWORD *pdwFlags);
        
        /* [propput] */ HRESULT ( STDMETHODCALLTYPE *put_Flags )( 
            IDirsyncSession * This,
            /* [in] */ DWORD dwFlags);
        
        /* [propget] */ HRESULT ( STDMETHODCALLTYPE *get_Status )( 
            IDirsyncSession * This,
            /* [retval][out] */ DWORD *pdwStatus);
        
        /* [propget] */ HRESULT ( STDMETHODCALLTYPE *get_LogLevel )( 
            IDirsyncSession * This,
            /* [retval][out] */ DWORD *pdwLogLevel);
        
        /* [propput] */ HRESULT ( STDMETHODCALLTYPE *put_LogLevel )( 
            IDirsyncSession * This,
            /* [in] */ DWORD dwLogLevel);
        
        /* [propget] */ HRESULT ( STDMETHODCALLTYPE *get_ID )( 
            IDirsyncSession * This,
            /* [retval][out] */ DWORD *pdwID);
        
        /* [propget] */ HRESULT ( STDMETHODCALLTYPE *get_CreatedBy )( 
            IDirsyncSession * This,
            /* [retval][out] */ PWSTR *ppszCreatedBy);
        
        /* [propget] */ HRESULT ( STDMETHODCALLTYPE *get_CreationTime )( 
            IDirsyncSession * This,
            /* [retval][out] */ LARGE_INTEGER *pCreationTime);
        
        /* [propget] */ HRESULT ( STDMETHODCALLTYPE *get_LastChangedBy )( 
            IDirsyncSession * This,
            /* [retval][out] */ PWSTR *ppszLastChangedBy);
        
        /* [propget] */ HRESULT ( STDMETHODCALLTYPE *get_LastChangeTime )( 
            IDirsyncSession * This,
            /* [retval][out] */ LARGE_INTEGER *pLastChangeTime);
        
        /* [propget] */ HRESULT ( STDMETHODCALLTYPE *get_SourceDirType )( 
            IDirsyncSession * This,
            /* [retval][out] */ PWSTR *ppszSourceDirType);
        
        /* [propput] */ HRESULT ( STDMETHODCALLTYPE *put_SourceDirType )( 
            IDirsyncSession * This,
            /* [full][in] */ PWSTR pszSourceDirType);
        
        /* [propget] */ HRESULT ( STDMETHODCALLTYPE *get_SourceServer )( 
            IDirsyncSession * This,
            /* [retval][out] */ PWSTR *ppszSourceServer);
        
        /* [propput] */ HRESULT ( STDMETHODCALLTYPE *put_SourceServer )( 
            IDirsyncSession * This,
            /* [full][in] */ PWSTR pszSourceServer);
        
        /* [propget] */ HRESULT ( STDMETHODCALLTYPE *get_SourceUsername )( 
            IDirsyncSession * This,
            /* [retval][out] */ PWSTR *ppszSourceUsername);
        
        /* [propput] */ HRESULT ( STDMETHODCALLTYPE *put_SourceUsername )( 
            IDirsyncSession * This,
            /* [full][in] */ PWSTR pszSourceUsername);
        
        /* [propget] */ HRESULT ( STDMETHODCALLTYPE *get_SourcePassword )( 
            IDirsyncSession * This,
            /* [retval][out] */ PWSTR *ppszSourcePassword);
        
        /* [propput] */ HRESULT ( STDMETHODCALLTYPE *put_SourcePassword )( 
            IDirsyncSession * This,
            /* [full][in] */ PWSTR pszSourcePassword);
        
        /* [propget] */ HRESULT ( STDMETHODCALLTYPE *get_SourceBase )( 
            IDirsyncSession * This,
            /* [retval][out] */ PWSTR *ppszSourceBase);
        
        /* [propput] */ HRESULT ( STDMETHODCALLTYPE *put_SourceBase )( 
            IDirsyncSession * This,
            /* [full][in] */ PWSTR pszSourceBase);
        
        /* [propget] */ HRESULT ( STDMETHODCALLTYPE *get_SourceScope )( 
            IDirsyncSession * This,
            /* [retval][out] */ DWORD *pdwSourceScope);
        
        /* [propput] */ HRESULT ( STDMETHODCALLTYPE *put_SourceScope )( 
            IDirsyncSession * This,
            /* [in] */ DWORD dwSourceScope);
        
        /* [propget] */ HRESULT ( STDMETHODCALLTYPE *get_SourceFilter )( 
            IDirsyncSession * This,
            /* [retval][out] */ PWSTR *ppszSourceFilter);
        
        /* [propput] */ HRESULT ( STDMETHODCALLTYPE *put_SourceFilter )( 
            IDirsyncSession * This,
            /* [full][in] */ PWSTR pszSourceFilter);
        
        /* [propget] */ HRESULT ( STDMETHODCALLTYPE *get_TargetDirType )( 
            IDirsyncSession * This,
            /* [retval][out] */ PWSTR *ppszTargetDirType);
        
        /* [propput] */ HRESULT ( STDMETHODCALLTYPE *put_TargetDirType )( 
            IDirsyncSession * This,
            /* [full][in] */ PWSTR pszTargetDirType);
        
        /* [propget] */ HRESULT ( STDMETHODCALLTYPE *get_TargetServer )( 
            IDirsyncSession * This,
            /* [retval][out] */ PWSTR *ppszTargetServer);
        
        /* [propput] */ HRESULT ( STDMETHODCALLTYPE *put_TargetServer )( 
            IDirsyncSession * This,
            /* [full][in] */ PWSTR pszTargetServer);
        
        /* [propget] */ HRESULT ( STDMETHODCALLTYPE *get_TargetUsername )( 
            IDirsyncSession * This,
            /* [retval][out] */ PWSTR *ppszTargetUsername);
        
        /* [propput] */ HRESULT ( STDMETHODCALLTYPE *put_TargetUsername )( 
            IDirsyncSession * This,
            /* [full][in] */ PWSTR pszTargetUsername);
        
        /* [propget] */ HRESULT ( STDMETHODCALLTYPE *get_TargetPassword )( 
            IDirsyncSession * This,
            /* [retval][out] */ PWSTR *ppszTargetPassword);
        
        /* [propput] */ HRESULT ( STDMETHODCALLTYPE *put_TargetPassword )( 
            IDirsyncSession * This,
            /* [full][in] */ PWSTR pszTargetPassword);
        
        /* [propget] */ HRESULT ( STDMETHODCALLTYPE *get_TargetBase )( 
            IDirsyncSession * This,
            /* [retval][out] */ PWSTR *ppszTargetBase);
        
        /* [propput] */ HRESULT ( STDMETHODCALLTYPE *put_TargetBase )( 
            IDirsyncSession * This,
            /* [full][in] */ PWSTR pszTargetBase);
        
        /* [propget] */ HRESULT ( STDMETHODCALLTYPE *get_TargetScope )( 
            IDirsyncSession * This,
            /* [retval][out] */ DWORD *pdwTargetScope);
        
        /* [propput] */ HRESULT ( STDMETHODCALLTYPE *put_TargetScope )( 
            IDirsyncSession * This,
            /* [in] */ DWORD dwTargetScope);
        
        /* [propget] */ HRESULT ( STDMETHODCALLTYPE *get_TargetFilter )( 
            IDirsyncSession * This,
            /* [retval][out] */ PWSTR *ppszTargetFilter);
        
        /* [propput] */ HRESULT ( STDMETHODCALLTYPE *put_TargetFilter )( 
            IDirsyncSession * This,
            /* [full][in] */ PWSTR pszTargetFilter);
        
        /* [propget] */ HRESULT ( STDMETHODCALLTYPE *get_Server )( 
            IDirsyncSession * This,
            /* [retval][out] */ PWSTR *ppszServer);
        
        HRESULT ( STDMETHODCALLTYPE *SetData )( 
            IDirsyncSession * This,
            /* [in] */ PSESSIONDATA pData);
        
        HRESULT ( STDMETHODCALLTYPE *GetData )( 
            IDirsyncSession * This,
            /* [out] */ PSESSIONDATA *ppData);
        
        HRESULT ( STDMETHODCALLTYPE *SetSchedule )( 
            IDirsyncSession * This,
            /* [in] */ SYNCDIRECTION syncDirection,
            /* [in] */ BYTE schedule[ 84 ]);
        
        HRESULT ( STDMETHODCALLTYPE *GetSchedule )( 
            IDirsyncSession * This,
            /* [in] */ SYNCDIRECTION syncDirection,
            /* [out] */ BYTE schedule[ 84 ]);
        
        HRESULT ( STDMETHODCALLTYPE *SetMap )( 
            IDirsyncSession * This,
            /* [in] */ SYNCDIRECTION syncDirection,
            /* [size_is][in] */ PBYTE pByte,
            /* [in] */ DWORD dwSize);
        
        HRESULT ( STDMETHODCALLTYPE *GetMap )( 
            IDirsyncSession * This,
            /* [in] */ SYNCDIRECTION syncDirection,
            /* [size_is][size_is][out] */ PBYTE *ppByte,
            /* [out] */ DWORD *pdwSize);
        
        HRESULT ( STDMETHODCALLTYPE *SetPasswordOptions )( 
            IDirsyncSession * This,
            /* [in] */ SYNCDIRECTION syncDirection,
            /* [in] */ PASSWORDTYPE passwordType,
            /* [in] */ PWSTR pszPassword);
        
        HRESULT ( STDMETHODCALLTYPE *GetPasswordOptions )( 
            IDirsyncSession * This,
            /* [in] */ SYNCDIRECTION syncDirection,
            /* [out] */ PASSWORDTYPE *pPasswordType,
            /* [out] */ PWSTR *ppszPassword);
        
        HRESULT ( STDMETHODCALLTYPE *Persist )( 
            IDirsyncSession * This,
            /* [in] */ BOOL fForce,
            /* [size_is][size_is][full][out][in] */ PGLOBAL_SESSIONID *prgSessionID,
            /* [full][out][in] */ DWORD *pdwSize);
        
        HRESULT ( STDMETHODCALLTYPE *SetAuxData )( 
            IDirsyncSession * This,
            /* [size_is][in] */ PADS_ATTR_INFO pAttributeEntries,
            /* [in] */ DWORD dwNumAttributes,
            /* [out] */ DWORD *pdwNumAttributesModified);
        
        HRESULT ( STDMETHODCALLTYPE *GetAuxData )( 
            IDirsyncSession * This,
            /* [size_is][in] */ PWSTR *pAttributeName,
            /* [in] */ DWORD dwNumAttributes,
            /* [size_is][size_is][out] */ PADS_ATTR_INFO *ppAttributeEntries,
            /* [out] */ DWORD *pdwAttributesReturned);
        
        HRESULT ( STDMETHODCALLTYPE *GetFailedObjectList )( 
            IDirsyncSession * This,
            /* [retval][out] */ IDirsyncFailedObjectList **pFailedObjectList);
        
        HRESULT ( STDMETHODCALLTYPE *GetNamespaceMapping )( 
            IDirsyncSession * This,
            /* [retval][out] */ IDirsyncNamespaceMapping **pNamespaceMapping);
        
        HRESULT ( STDMETHODCALLTYPE *GetRuntimeNamespaceMapping )( 
            IDirsyncSession * This,
            /* [retval][out] */ IDirsyncNamespaceMapping **pNamespaceMapping);
        
        HRESULT ( STDMETHODCALLTYPE *IsClassMappingValid )( 
            IDirsyncSession * This,
            /* [in] */ PWSTR pszClassSource,
            /* [in] */ PWSTR pszClassTarget);
        
        /* [propget] */ HRESULT ( STDMETHODCALLTYPE *get_ObjMapFilePath )( 
            IDirsyncSession * This,
            /* [retval][out] */ PWSTR *ppszObjMapFilePath);
        
        /* [propput] */ HRESULT ( STDMETHODCALLTYPE *put_ObjMapFilePath )( 
            IDirsyncSession * This,
            /* [full][in] */ PWSTR pszObjMapFilePath);
        
        HRESULT ( STDMETHODCALLTYPE *GetSyncStatus )( 
            IDirsyncSession * This,
            /* [out] */ DWORD *pdwPercent,
            /* [out] */ DWORD *pdwWarning,
            /* [out] */ DWORD *pdwError);
        
        HRESULT ( STDMETHODCALLTYPE *UpdateTerminationStatus )( 
            IDirsyncSession * This);
        
        END_INTERFACE
    } IDirsyncSessionVtbl;

    interface IDirsyncSession
    {
        CONST_VTBL struct IDirsyncSessionVtbl *lpVtbl;
    };

    

#ifdef COBJMACROS


#define IDirsyncSession_QueryInterface(This,riid,ppvObject)	\
    (This)->lpVtbl -> QueryInterface(This,riid,ppvObject)

#define IDirsyncSession_AddRef(This)	\
    (This)->lpVtbl -> AddRef(This)

#define IDirsyncSession_Release(This)	\
    (This)->lpVtbl -> Release(This)


#define IDirsyncSession_get_Name(This,ppszName)	\
    (This)->lpVtbl -> get_Name(This,ppszName)

#define IDirsyncSession_put_Name(This,pszName)	\
    (This)->lpVtbl -> put_Name(This,pszName)

#define IDirsyncSession_get_Comments(This,ppszComments)	\
    (This)->lpVtbl -> get_Comments(This,ppszComments)

#define IDirsyncSession_put_Comments(This,pszComments)	\
    (This)->lpVtbl -> put_Comments(This,pszComments)

#define IDirsyncSession_get_Flags(This,pdwFlags)	\
    (This)->lpVtbl -> get_Flags(This,pdwFlags)

#define IDirsyncSession_put_Flags(This,dwFlags)	\
    (This)->lpVtbl -> put_Flags(This,dwFlags)

#define IDirsyncSession_get_Status(This,pdwStatus)	\
    (This)->lpVtbl -> get_Status(This,pdwStatus)

#define IDirsyncSession_get_LogLevel(This,pdwLogLevel)	\
    (This)->lpVtbl -> get_LogLevel(This,pdwLogLevel)

#define IDirsyncSession_put_LogLevel(This,dwLogLevel)	\
    (This)->lpVtbl -> put_LogLevel(This,dwLogLevel)

#define IDirsyncSession_get_ID(This,pdwID)	\
    (This)->lpVtbl -> get_ID(This,pdwID)

#define IDirsyncSession_get_CreatedBy(This,ppszCreatedBy)	\
    (This)->lpVtbl -> get_CreatedBy(This,ppszCreatedBy)

#define IDirsyncSession_get_CreationTime(This,pCreationTime)	\
    (This)->lpVtbl -> get_CreationTime(This,pCreationTime)

#define IDirsyncSession_get_LastChangedBy(This,ppszLastChangedBy)	\
    (This)->lpVtbl -> get_LastChangedBy(This,ppszLastChangedBy)

#define IDirsyncSession_get_LastChangeTime(This,pLastChangeTime)	\
    (This)->lpVtbl -> get_LastChangeTime(This,pLastChangeTime)

#define IDirsyncSession_get_SourceDirType(This,ppszSourceDirType)	\
    (This)->lpVtbl -> get_SourceDirType(This,ppszSourceDirType)

#define IDirsyncSession_put_SourceDirType(This,pszSourceDirType)	\
    (This)->lpVtbl -> put_SourceDirType(This,pszSourceDirType)

#define IDirsyncSession_get_SourceServer(This,ppszSourceServer)	\
    (This)->lpVtbl -> get_SourceServer(This,ppszSourceServer)

#define IDirsyncSession_put_SourceServer(This,pszSourceServer)	\
    (This)->lpVtbl -> put_SourceServer(This,pszSourceServer)

#define IDirsyncSession_get_SourceUsername(This,ppszSourceUsername)	\
    (This)->lpVtbl -> get_SourceUsername(This,ppszSourceUsername)

#define IDirsyncSession_put_SourceUsername(This,pszSourceUsername)	\
    (This)->lpVtbl -> put_SourceUsername(This,pszSourceUsername)

#define IDirsyncSession_get_SourcePassword(This,ppszSourcePassword)	\
    (This)->lpVtbl -> get_SourcePassword(This,ppszSourcePassword)

#define IDirsyncSession_put_SourcePassword(This,pszSourcePassword)	\
    (This)->lpVtbl -> put_SourcePassword(This,pszSourcePassword)

#define IDirsyncSession_get_SourceBase(This,ppszSourceBase)	\
    (This)->lpVtbl -> get_SourceBase(This,ppszSourceBase)

#define IDirsyncSession_put_SourceBase(This,pszSourceBase)	\
    (This)->lpVtbl -> put_SourceBase(This,pszSourceBase)

#define IDirsyncSession_get_SourceScope(This,pdwSourceScope)	\
    (This)->lpVtbl -> get_SourceScope(This,pdwSourceScope)

#define IDirsyncSession_put_SourceScope(This,dwSourceScope)	\
    (This)->lpVtbl -> put_SourceScope(This,dwSourceScope)

#define IDirsyncSession_get_SourceFilter(This,ppszSourceFilter)	\
    (This)->lpVtbl -> get_SourceFilter(This,ppszSourceFilter)

#define IDirsyncSession_put_SourceFilter(This,pszSourceFilter)	\
    (This)->lpVtbl -> put_SourceFilter(This,pszSourceFilter)

#define IDirsyncSession_get_TargetDirType(This,ppszTargetDirType)	\
    (This)->lpVtbl -> get_TargetDirType(This,ppszTargetDirType)

#define IDirsyncSession_put_TargetDirType(This,pszTargetDirType)	\
    (This)->lpVtbl -> put_TargetDirType(This,pszTargetDirType)

#define IDirsyncSession_get_TargetServer(This,ppszTargetServer)	\
    (This)->lpVtbl -> get_TargetServer(This,ppszTargetServer)

#define IDirsyncSession_put_TargetServer(This,pszTargetServer)	\
    (This)->lpVtbl -> put_TargetServer(This,pszTargetServer)

#define IDirsyncSession_get_TargetUsername(This,ppszTargetUsername)	\
    (This)->lpVtbl -> get_TargetUsername(This,ppszTargetUsername)

#define IDirsyncSession_put_TargetUsername(This,pszTargetUsername)	\
    (This)->lpVtbl -> put_TargetUsername(This,pszTargetUsername)

#define IDirsyncSession_get_TargetPassword(This,ppszTargetPassword)	\
    (This)->lpVtbl -> get_TargetPassword(This,ppszTargetPassword)

#define IDirsyncSession_put_TargetPassword(This,pszTargetPassword)	\
    (This)->lpVtbl -> put_TargetPassword(This,pszTargetPassword)

#define IDirsyncSession_get_TargetBase(This,ppszTargetBase)	\
    (This)->lpVtbl -> get_TargetBase(This,ppszTargetBase)

#define IDirsyncSession_put_TargetBase(This,pszTargetBase)	\
    (This)->lpVtbl -> put_TargetBase(This,pszTargetBase)

#define IDirsyncSession_get_TargetScope(This,pdwTargetScope)	\
    (This)->lpVtbl -> get_TargetScope(This,pdwTargetScope)

#define IDirsyncSession_put_TargetScope(This,dwTargetScope)	\
    (This)->lpVtbl -> put_TargetScope(This,dwTargetScope)

#define IDirsyncSession_get_TargetFilter(This,ppszTargetFilter)	\
    (This)->lpVtbl -> get_TargetFilter(This,ppszTargetFilter)

#define IDirsyncSession_put_TargetFilter(This,pszTargetFilter)	\
    (This)->lpVtbl -> put_TargetFilter(This,pszTargetFilter)

#define IDirsyncSession_get_Server(This,ppszServer)	\
    (This)->lpVtbl -> get_Server(This,ppszServer)

#define IDirsyncSession_SetData(This,pData)	\
    (This)->lpVtbl -> SetData(This,pData)

#define IDirsyncSession_GetData(This,ppData)	\
    (This)->lpVtbl -> GetData(This,ppData)

#define IDirsyncSession_SetSchedule(This,syncDirection,schedule)	\
    (This)->lpVtbl -> SetSchedule(This,syncDirection,schedule)

#define IDirsyncSession_GetSchedule(This,syncDirection,schedule)	\
    (This)->lpVtbl -> GetSchedule(This,syncDirection,schedule)

#define IDirsyncSession_SetMap(This,syncDirection,pByte,dwSize)	\
    (This)->lpVtbl -> SetMap(This,syncDirection,pByte,dwSize)

#define IDirsyncSession_GetMap(This,syncDirection,ppByte,pdwSize)	\
    (This)->lpVtbl -> GetMap(This,syncDirection,ppByte,pdwSize)

#define IDirsyncSession_SetPasswordOptions(This,syncDirection,passwordType,pszPassword)	\
    (This)->lpVtbl -> SetPasswordOptions(This,syncDirection,passwordType,pszPassword)

#define IDirsyncSession_GetPasswordOptions(This,syncDirection,pPasswordType,ppszPassword)	\
    (This)->lpVtbl -> GetPasswordOptions(This,syncDirection,pPasswordType,ppszPassword)

#define IDirsyncSession_Persist(This,fForce,prgSessionID,pdwSize)	\
    (This)->lpVtbl -> Persist(This,fForce,prgSessionID,pdwSize)

#define IDirsyncSession_SetAuxData(This,pAttributeEntries,dwNumAttributes,pdwNumAttributesModified)	\
    (This)->lpVtbl -> SetAuxData(This,pAttributeEntries,dwNumAttributes,pdwNumAttributesModified)

#define IDirsyncSession_GetAuxData(This,pAttributeName,dwNumAttributes,ppAttributeEntries,pdwAttributesReturned)	\
    (This)->lpVtbl -> GetAuxData(This,pAttributeName,dwNumAttributes,ppAttributeEntries,pdwAttributesReturned)

#define IDirsyncSession_GetFailedObjectList(This,pFailedObjectList)	\
    (This)->lpVtbl -> GetFailedObjectList(This,pFailedObjectList)

#define IDirsyncSession_GetNamespaceMapping(This,pNamespaceMapping)	\
    (This)->lpVtbl -> GetNamespaceMapping(This,pNamespaceMapping)

#define IDirsyncSession_GetRuntimeNamespaceMapping(This,pNamespaceMapping)	\
    (This)->lpVtbl -> GetRuntimeNamespaceMapping(This,pNamespaceMapping)

#define IDirsyncSession_IsClassMappingValid(This,pszClassSource,pszClassTarget)	\
    (This)->lpVtbl -> IsClassMappingValid(This,pszClassSource,pszClassTarget)

#define IDirsyncSession_get_ObjMapFilePath(This,ppszObjMapFilePath)	\
    (This)->lpVtbl -> get_ObjMapFilePath(This,ppszObjMapFilePath)

#define IDirsyncSession_put_ObjMapFilePath(This,pszObjMapFilePath)	\
    (This)->lpVtbl -> put_ObjMapFilePath(This,pszObjMapFilePath)

#define IDirsyncSession_GetSyncStatus(This,pdwPercent,pdwWarning,pdwError)	\
    (This)->lpVtbl -> GetSyncStatus(This,pdwPercent,pdwWarning,pdwError)

#define IDirsyncSession_UpdateTerminationStatus(This)	\
    (This)->lpVtbl -> UpdateTerminationStatus(This)

#endif /* COBJMACROS */


#endif 	/* C style interface */



/* [propget] */ HRESULT STDMETHODCALLTYPE IDirsyncSession_get_Name_Proxy( 
    IDirsyncSession * This,
    /* [retval][out] */ PWSTR *ppszName);


void __RPC_STUB IDirsyncSession_get_Name_Stub(
    IRpcStubBuffer *This,
    IRpcChannelBuffer *_pRpcChannelBuffer,
    PRPC_MESSAGE _pRpcMessage,
    DWORD *_pdwStubPhase);


/* [propput] */ HRESULT STDMETHODCALLTYPE IDirsyncSession_put_Name_Proxy( 
    IDirsyncSession * This,
    /* [full][in] */ PWSTR pszName);


void __RPC_STUB IDirsyncSession_put_Name_Stub(
    IRpcStubBuffer *This,
    IRpcChannelBuffer *_pRpcChannelBuffer,
    PRPC_MESSAGE _pRpcMessage,
    DWORD *_pdwStubPhase);


/* [propget] */ HRESULT STDMETHODCALLTYPE IDirsyncSession_get_Comments_Proxy( 
    IDirsyncSession * This,
    /* [retval][out] */ PWSTR *ppszComments);


void __RPC_STUB IDirsyncSession_get_Comments_Stub(
    IRpcStubBuffer *This,
    IRpcChannelBuffer *_pRpcChannelBuffer,
    PRPC_MESSAGE _pRpcMessage,
    DWORD *_pdwStubPhase);


/* [propput] */ HRESULT STDMETHODCALLTYPE IDirsyncSession_put_Comments_Proxy( 
    IDirsyncSession * This,
    /* [full][in] */ PWSTR pszComments);


void __RPC_STUB IDirsyncSession_put_Comments_Stub(
    IRpcStubBuffer *This,
    IRpcChannelBuffer *_pRpcChannelBuffer,
    PRPC_MESSAGE _pRpcMessage,
    DWORD *_pdwStubPhase);


/* [propget] */ HRESULT STDMETHODCALLTYPE IDirsyncSession_get_Flags_Proxy( 
    IDirsyncSession * This,
    /* [retval][out] */ DWORD *pdwFlags);


void __RPC_STUB IDirsyncSession_get_Flags_Stub(
    IRpcStubBuffer *This,
    IRpcChannelBuffer *_pRpcChannelBuffer,
    PRPC_MESSAGE _pRpcMessage,
    DWORD *_pdwStubPhase);


/* [propput] */ HRESULT STDMETHODCALLTYPE IDirsyncSession_put_Flags_Proxy( 
    IDirsyncSession * This,
    /* [in] */ DWORD dwFlags);


void __RPC_STUB IDirsyncSession_put_Flags_Stub(
    IRpcStubBuffer *This,
    IRpcChannelBuffer *_pRpcChannelBuffer,
    PRPC_MESSAGE _pRpcMessage,
    DWORD *_pdwStubPhase);


/* [propget] */ HRESULT STDMETHODCALLTYPE IDirsyncSession_get_Status_Proxy( 
    IDirsyncSession * This,
    /* [retval][out] */ DWORD *pdwStatus);


void __RPC_STUB IDirsyncSession_get_Status_Stub(
    IRpcStubBuffer *This,
    IRpcChannelBuffer *_pRpcChannelBuffer,
    PRPC_MESSAGE _pRpcMessage,
    DWORD *_pdwStubPhase);


/* [propget] */ HRESULT STDMETHODCALLTYPE IDirsyncSession_get_LogLevel_Proxy( 
    IDirsyncSession * This,
    /* [retval][out] */ DWORD *pdwLogLevel);


void __RPC_STUB IDirsyncSession_get_LogLevel_Stub(
    IRpcStubBuffer *This,
    IRpcChannelBuffer *_pRpcChannelBuffer,
    PRPC_MESSAGE _pRpcMessage,
    DWORD *_pdwStubPhase);


/* [propput] */ HRESULT STDMETHODCALLTYPE IDirsyncSession_put_LogLevel_Proxy( 
    IDirsyncSession * This,
    /* [in] */ DWORD dwLogLevel);


void __RPC_STUB IDirsyncSession_put_LogLevel_Stub(
    IRpcStubBuffer *This,
    IRpcChannelBuffer *_pRpcChannelBuffer,
    PRPC_MESSAGE _pRpcMessage,
    DWORD *_pdwStubPhase);


/* [propget] */ HRESULT STDMETHODCALLTYPE IDirsyncSession_get_ID_Proxy( 
    IDirsyncSession * This,
    /* [retval][out] */ DWORD *pdwID);


void __RPC_STUB IDirsyncSession_get_ID_Stub(
    IRpcStubBuffer *This,
    IRpcChannelBuffer *_pRpcChannelBuffer,
    PRPC_MESSAGE _pRpcMessage,
    DWORD *_pdwStubPhase);


/* [propget] */ HRESULT STDMETHODCALLTYPE IDirsyncSession_get_CreatedBy_Proxy( 
    IDirsyncSession * This,
    /* [retval][out] */ PWSTR *ppszCreatedBy);


void __RPC_STUB IDirsyncSession_get_CreatedBy_Stub(
    IRpcStubBuffer *This,
    IRpcChannelBuffer *_pRpcChannelBuffer,
    PRPC_MESSAGE _pRpcMessage,
    DWORD *_pdwStubPhase);


/* [propget] */ HRESULT STDMETHODCALLTYPE IDirsyncSession_get_CreationTime_Proxy( 
    IDirsyncSession * This,
    /* [retval][out] */ LARGE_INTEGER *pCreationTime);


void __RPC_STUB IDirsyncSession_get_CreationTime_Stub(
    IRpcStubBuffer *This,
    IRpcChannelBuffer *_pRpcChannelBuffer,
    PRPC_MESSAGE _pRpcMessage,
    DWORD *_pdwStubPhase);


/* [propget] */ HRESULT STDMETHODCALLTYPE IDirsyncSession_get_LastChangedBy_Proxy( 
    IDirsyncSession * This,
    /* [retval][out] */ PWSTR *ppszLastChangedBy);


void __RPC_STUB IDirsyncSession_get_LastChangedBy_Stub(
    IRpcStubBuffer *This,
    IRpcChannelBuffer *_pRpcChannelBuffer,
    PRPC_MESSAGE _pRpcMessage,
    DWORD *_pdwStubPhase);


/* [propget] */ HRESULT STDMETHODCALLTYPE IDirsyncSession_get_LastChangeTime_Proxy( 
    IDirsyncSession * This,
    /* [retval][out] */ LARGE_INTEGER *pLastChangeTime);


void __RPC_STUB IDirsyncSession_get_LastChangeTime_Stub(
    IRpcStubBuffer *This,
    IRpcChannelBuffer *_pRpcChannelBuffer,
    PRPC_MESSAGE _pRpcMessage,
    DWORD *_pdwStubPhase);


/* [propget] */ HRESULT STDMETHODCALLTYPE IDirsyncSession_get_SourceDirType_Proxy( 
    IDirsyncSession * This,
    /* [retval][out] */ PWSTR *ppszSourceDirType);


void __RPC_STUB IDirsyncSession_get_SourceDirType_Stub(
    IRpcStubBuffer *This,
    IRpcChannelBuffer *_pRpcChannelBuffer,
    PRPC_MESSAGE _pRpcMessage,
    DWORD *_pdwStubPhase);


/* [propput] */ HRESULT STDMETHODCALLTYPE IDirsyncSession_put_SourceDirType_Proxy( 
    IDirsyncSession * This,
    /* [full][in] */ PWSTR pszSourceDirType);


void __RPC_STUB IDirsyncSession_put_SourceDirType_Stub(
    IRpcStubBuffer *This,
    IRpcChannelBuffer *_pRpcChannelBuffer,
    PRPC_MESSAGE _pRpcMessage,
    DWORD *_pdwStubPhase);


/* [propget] */ HRESULT STDMETHODCALLTYPE IDirsyncSession_get_SourceServer_Proxy( 
    IDirsyncSession * This,
    /* [retval][out] */ PWSTR *ppszSourceServer);


void __RPC_STUB IDirsyncSession_get_SourceServer_Stub(
    IRpcStubBuffer *This,
    IRpcChannelBuffer *_pRpcChannelBuffer,
    PRPC_MESSAGE _pRpcMessage,
    DWORD *_pdwStubPhase);


/* [propput] */ HRESULT STDMETHODCALLTYPE IDirsyncSession_put_SourceServer_Proxy( 
    IDirsyncSession * This,
    /* [full][in] */ PWSTR pszSourceServer);


void __RPC_STUB IDirsyncSession_put_SourceServer_Stub(
    IRpcStubBuffer *This,
    IRpcChannelBuffer *_pRpcChannelBuffer,
    PRPC_MESSAGE _pRpcMessage,
    DWORD *_pdwStubPhase);


/* [propget] */ HRESULT STDMETHODCALLTYPE IDirsyncSession_get_SourceUsername_Proxy( 
    IDirsyncSession * This,
    /* [retval][out] */ PWSTR *ppszSourceUsername);


void __RPC_STUB IDirsyncSession_get_SourceUsername_Stub(
    IRpcStubBuffer *This,
    IRpcChannelBuffer *_pRpcChannelBuffer,
    PRPC_MESSAGE _pRpcMessage,
    DWORD *_pdwStubPhase);


/* [propput] */ HRESULT STDMETHODCALLTYPE IDirsyncSession_put_SourceUsername_Proxy( 
    IDirsyncSession * This,
    /* [full][in] */ PWSTR pszSourceUsername);


void __RPC_STUB IDirsyncSession_put_SourceUsername_Stub(
    IRpcStubBuffer *This,
    IRpcChannelBuffer *_pRpcChannelBuffer,
    PRPC_MESSAGE _pRpcMessage,
    DWORD *_pdwStubPhase);


/* [propget] */ HRESULT STDMETHODCALLTYPE IDirsyncSession_get_SourcePassword_Proxy( 
    IDirsyncSession * This,
    /* [retval][out] */ PWSTR *ppszSourcePassword);


void __RPC_STUB IDirsyncSession_get_SourcePassword_Stub(
    IRpcStubBuffer *This,
    IRpcChannelBuffer *_pRpcChannelBuffer,
    PRPC_MESSAGE _pRpcMessage,
    DWORD *_pdwStubPhase);


/* [propput] */ HRESULT STDMETHODCALLTYPE IDirsyncSession_put_SourcePassword_Proxy( 
    IDirsyncSession * This,
    /* [full][in] */ PWSTR pszSourcePassword);


void __RPC_STUB IDirsyncSession_put_SourcePassword_Stub(
    IRpcStubBuffer *This,
    IRpcChannelBuffer *_pRpcChannelBuffer,
    PRPC_MESSAGE _pRpcMessage,
    DWORD *_pdwStubPhase);


/* [propget] */ HRESULT STDMETHODCALLTYPE IDirsyncSession_get_SourceBase_Proxy( 
    IDirsyncSession * This,
    /* [retval][out] */ PWSTR *ppszSourceBase);


void __RPC_STUB IDirsyncSession_get_SourceBase_Stub(
    IRpcStubBuffer *This,
    IRpcChannelBuffer *_pRpcChannelBuffer,
    PRPC_MESSAGE _pRpcMessage,
    DWORD *_pdwStubPhase);


/* [propput] */ HRESULT STDMETHODCALLTYPE IDirsyncSession_put_SourceBase_Proxy( 
    IDirsyncSession * This,
    /* [full][in] */ PWSTR pszSourceBase);


void __RPC_STUB IDirsyncSession_put_SourceBase_Stub(
    IRpcStubBuffer *This,
    IRpcChannelBuffer *_pRpcChannelBuffer,
    PRPC_MESSAGE _pRpcMessage,
    DWORD *_pdwStubPhase);


/* [propget] */ HRESULT STDMETHODCALLTYPE IDirsyncSession_get_SourceScope_Proxy( 
    IDirsyncSession * This,
    /* [retval][out] */ DWORD *pdwSourceScope);


void __RPC_STUB IDirsyncSession_get_SourceScope_Stub(
    IRpcStubBuffer *This,
    IRpcChannelBuffer *_pRpcChannelBuffer,
    PRPC_MESSAGE _pRpcMessage,
    DWORD *_pdwStubPhase);


/* [propput] */ HRESULT STDMETHODCALLTYPE IDirsyncSession_put_SourceScope_Proxy( 
    IDirsyncSession * This,
    /* [in] */ DWORD dwSourceScope);


void __RPC_STUB IDirsyncSession_put_SourceScope_Stub(
    IRpcStubBuffer *This,
    IRpcChannelBuffer *_pRpcChannelBuffer,
    PRPC_MESSAGE _pRpcMessage,
    DWORD *_pdwStubPhase);


/* [propget] */ HRESULT STDMETHODCALLTYPE IDirsyncSession_get_SourceFilter_Proxy( 
    IDirsyncSession * This,
    /* [retval][out] */ PWSTR *ppszSourceFilter);


void __RPC_STUB IDirsyncSession_get_SourceFilter_Stub(
    IRpcStubBuffer *This,
    IRpcChannelBuffer *_pRpcChannelBuffer,
    PRPC_MESSAGE _pRpcMessage,
    DWORD *_pdwStubPhase);


/* [propput] */ HRESULT STDMETHODCALLTYPE IDirsyncSession_put_SourceFilter_Proxy( 
    IDirsyncSession * This,
    /* [full][in] */ PWSTR pszSourceFilter);


void __RPC_STUB IDirsyncSession_put_SourceFilter_Stub(
    IRpcStubBuffer *This,
    IRpcChannelBuffer *_pRpcChannelBuffer,
    PRPC_MESSAGE _pRpcMessage,
    DWORD *_pdwStubPhase);


/* [propget] */ HRESULT STDMETHODCALLTYPE IDirsyncSession_get_TargetDirType_Proxy( 
    IDirsyncSession * This,
    /* [retval][out] */ PWSTR *ppszTargetDirType);


void __RPC_STUB IDirsyncSession_get_TargetDirType_Stub(
    IRpcStubBuffer *This,
    IRpcChannelBuffer *_pRpcChannelBuffer,
    PRPC_MESSAGE _pRpcMessage,
    DWORD *_pdwStubPhase);


/* [propput] */ HRESULT STDMETHODCALLTYPE IDirsyncSession_put_TargetDirType_Proxy( 
    IDirsyncSession * This,
    /* [full][in] */ PWSTR pszTargetDirType);


void __RPC_STUB IDirsyncSession_put_TargetDirType_Stub(
    IRpcStubBuffer *This,
    IRpcChannelBuffer *_pRpcChannelBuffer,
    PRPC_MESSAGE _pRpcMessage,
    DWORD *_pdwStubPhase);


/* [propget] */ HRESULT STDMETHODCALLTYPE IDirsyncSession_get_TargetServer_Proxy( 
    IDirsyncSession * This,
    /* [retval][out] */ PWSTR *ppszTargetServer);


void __RPC_STUB IDirsyncSession_get_TargetServer_Stub(
    IRpcStubBuffer *This,
    IRpcChannelBuffer *_pRpcChannelBuffer,
    PRPC_MESSAGE _pRpcMessage,
    DWORD *_pdwStubPhase);


/* [propput] */ HRESULT STDMETHODCALLTYPE IDirsyncSession_put_TargetServer_Proxy( 
    IDirsyncSession * This,
    /* [full][in] */ PWSTR pszTargetServer);


void __RPC_STUB IDirsyncSession_put_TargetServer_Stub(
    IRpcStubBuffer *This,
    IRpcChannelBuffer *_pRpcChannelBuffer,
    PRPC_MESSAGE _pRpcMessage,
    DWORD *_pdwStubPhase);


/* [propget] */ HRESULT STDMETHODCALLTYPE IDirsyncSession_get_TargetUsername_Proxy( 
    IDirsyncSession * This,
    /* [retval][out] */ PWSTR *ppszTargetUsername);


void __RPC_STUB IDirsyncSession_get_TargetUsername_Stub(
    IRpcStubBuffer *This,
    IRpcChannelBuffer *_pRpcChannelBuffer,
    PRPC_MESSAGE _pRpcMessage,
    DWORD *_pdwStubPhase);


/* [propput] */ HRESULT STDMETHODCALLTYPE IDirsyncSession_put_TargetUsername_Proxy( 
    IDirsyncSession * This,
    /* [full][in] */ PWSTR pszTargetUsername);


void __RPC_STUB IDirsyncSession_put_TargetUsername_Stub(
    IRpcStubBuffer *This,
    IRpcChannelBuffer *_pRpcChannelBuffer,
    PRPC_MESSAGE _pRpcMessage,
    DWORD *_pdwStubPhase);


/* [propget] */ HRESULT STDMETHODCALLTYPE IDirsyncSession_get_TargetPassword_Proxy( 
    IDirsyncSession * This,
    /* [retval][out] */ PWSTR *ppszTargetPassword);


void __RPC_STUB IDirsyncSession_get_TargetPassword_Stub(
    IRpcStubBuffer *This,
    IRpcChannelBuffer *_pRpcChannelBuffer,
    PRPC_MESSAGE _pRpcMessage,
    DWORD *_pdwStubPhase);


/* [propput] */ HRESULT STDMETHODCALLTYPE IDirsyncSession_put_TargetPassword_Proxy( 
    IDirsyncSession * This,
    /* [full][in] */ PWSTR pszTargetPassword);


void __RPC_STUB IDirsyncSession_put_TargetPassword_Stub(
    IRpcStubBuffer *This,
    IRpcChannelBuffer *_pRpcChannelBuffer,
    PRPC_MESSAGE _pRpcMessage,
    DWORD *_pdwStubPhase);


/* [propget] */ HRESULT STDMETHODCALLTYPE IDirsyncSession_get_TargetBase_Proxy( 
    IDirsyncSession * This,
    /* [retval][out] */ PWSTR *ppszTargetBase);


void __RPC_STUB IDirsyncSession_get_TargetBase_Stub(
    IRpcStubBuffer *This,
    IRpcChannelBuffer *_pRpcChannelBuffer,
    PRPC_MESSAGE _pRpcMessage,
    DWORD *_pdwStubPhase);


/* [propput] */ HRESULT STDMETHODCALLTYPE IDirsyncSession_put_TargetBase_Proxy( 
    IDirsyncSession * This,
    /* [full][in] */ PWSTR pszTargetBase);


void __RPC_STUB IDirsyncSession_put_TargetBase_Stub(
    IRpcStubBuffer *This,
    IRpcChannelBuffer *_pRpcChannelBuffer,
    PRPC_MESSAGE _pRpcMessage,
    DWORD *_pdwStubPhase);


/* [propget] */ HRESULT STDMETHODCALLTYPE IDirsyncSession_get_TargetScope_Proxy( 
    IDirsyncSession * This,
    /* [retval][out] */ DWORD *pdwTargetScope);


void __RPC_STUB IDirsyncSession_get_TargetScope_Stub(
    IRpcStubBuffer *This,
    IRpcChannelBuffer *_pRpcChannelBuffer,
    PRPC_MESSAGE _pRpcMessage,
    DWORD *_pdwStubPhase);


/* [propput] */ HRESULT STDMETHODCALLTYPE IDirsyncSession_put_TargetScope_Proxy( 
    IDirsyncSession * This,
    /* [in] */ DWORD dwTargetScope);


void __RPC_STUB IDirsyncSession_put_TargetScope_Stub(
    IRpcStubBuffer *This,
    IRpcChannelBuffer *_pRpcChannelBuffer,
    PRPC_MESSAGE _pRpcMessage,
    DWORD *_pdwStubPhase);


/* [propget] */ HRESULT STDMETHODCALLTYPE IDirsyncSession_get_TargetFilter_Proxy( 
    IDirsyncSession * This,
    /* [retval][out] */ PWSTR *ppszTargetFilter);


void __RPC_STUB IDirsyncSession_get_TargetFilter_Stub(
    IRpcStubBuffer *This,
    IRpcChannelBuffer *_pRpcChannelBuffer,
    PRPC_MESSAGE _pRpcMessage,
    DWORD *_pdwStubPhase);


/* [propput] */ HRESULT STDMETHODCALLTYPE IDirsyncSession_put_TargetFilter_Proxy( 
    IDirsyncSession * This,
    /* [full][in] */ PWSTR pszTargetFilter);


void __RPC_STUB IDirsyncSession_put_TargetFilter_Stub(
    IRpcStubBuffer *This,
    IRpcChannelBuffer *_pRpcChannelBuffer,
    PRPC_MESSAGE _pRpcMessage,
    DWORD *_pdwStubPhase);


/* [propget] */ HRESULT STDMETHODCALLTYPE IDirsyncSession_get_Server_Proxy( 
    IDirsyncSession * This,
    /* [retval][out] */ PWSTR *ppszServer);


void __RPC_STUB IDirsyncSession_get_Server_Stub(
    IRpcStubBuffer *This,
    IRpcChannelBuffer *_pRpcChannelBuffer,
    PRPC_MESSAGE _pRpcMessage,
    DWORD *_pdwStubPhase);


HRESULT STDMETHODCALLTYPE IDirsyncSession_SetData_Proxy( 
    IDirsyncSession * This,
    /* [in] */ PSESSIONDATA pData);


void __RPC_STUB IDirsyncSession_SetData_Stub(
    IRpcStubBuffer *This,
    IRpcChannelBuffer *_pRpcChannelBuffer,
    PRPC_MESSAGE _pRpcMessage,
    DWORD *_pdwStubPhase);


HRESULT STDMETHODCALLTYPE IDirsyncSession_GetData_Proxy( 
    IDirsyncSession * This,
    /* [out] */ PSESSIONDATA *ppData);


void __RPC_STUB IDirsyncSession_GetData_Stub(
    IRpcStubBuffer *This,
    IRpcChannelBuffer *_pRpcChannelBuffer,
    PRPC_MESSAGE _pRpcMessage,
    DWORD *_pdwStubPhase);


HRESULT STDMETHODCALLTYPE IDirsyncSession_SetSchedule_Proxy( 
    IDirsyncSession * This,
    /* [in] */ SYNCDIRECTION syncDirection,
    /* [in] */ BYTE schedule[ 84 ]);


void __RPC_STUB IDirsyncSession_SetSchedule_Stub(
    IRpcStubBuffer *This,
    IRpcChannelBuffer *_pRpcChannelBuffer,
    PRPC_MESSAGE _pRpcMessage,
    DWORD *_pdwStubPhase);


HRESULT STDMETHODCALLTYPE IDirsyncSession_GetSchedule_Proxy( 
    IDirsyncSession * This,
    /* [in] */ SYNCDIRECTION syncDirection,
    /* [out] */ BYTE schedule[ 84 ]);


void __RPC_STUB IDirsyncSession_GetSchedule_Stub(
    IRpcStubBuffer *This,
    IRpcChannelBuffer *_pRpcChannelBuffer,
    PRPC_MESSAGE _pRpcMessage,
    DWORD *_pdwStubPhase);


HRESULT STDMETHODCALLTYPE IDirsyncSession_SetMap_Proxy( 
    IDirsyncSession * This,
    /* [in] */ SYNCDIRECTION syncDirection,
    /* [size_is][in] */ PBYTE pByte,
    /* [in] */ DWORD dwSize);


void __RPC_STUB IDirsyncSession_SetMap_Stub(
    IRpcStubBuffer *This,
    IRpcChannelBuffer *_pRpcChannelBuffer,
    PRPC_MESSAGE _pRpcMessage,
    DWORD *_pdwStubPhase);


HRESULT STDMETHODCALLTYPE IDirsyncSession_GetMap_Proxy( 
    IDirsyncSession * This,
    /* [in] */ SYNCDIRECTION syncDirection,
    /* [size_is][size_is][out] */ PBYTE *ppByte,
    /* [out] */ DWORD *pdwSize);


void __RPC_STUB IDirsyncSession_GetMap_Stub(
    IRpcStubBuffer *This,
    IRpcChannelBuffer *_pRpcChannelBuffer,
    PRPC_MESSAGE _pRpcMessage,
    DWORD *_pdwStubPhase);


HRESULT STDMETHODCALLTYPE IDirsyncSession_SetPasswordOptions_Proxy( 
    IDirsyncSession * This,
    /* [in] */ SYNCDIRECTION syncDirection,
    /* [in] */ PASSWORDTYPE passwordType,
    /* [in] */ PWSTR pszPassword);


void __RPC_STUB IDirsyncSession_SetPasswordOptions_Stub(
    IRpcStubBuffer *This,
    IRpcChannelBuffer *_pRpcChannelBuffer,
    PRPC_MESSAGE _pRpcMessage,
    DWORD *_pdwStubPhase);


HRESULT STDMETHODCALLTYPE IDirsyncSession_GetPasswordOptions_Proxy( 
    IDirsyncSession * This,
    /* [in] */ SYNCDIRECTION syncDirection,
    /* [out] */ PASSWORDTYPE *pPasswordType,
    /* [out] */ PWSTR *ppszPassword);


void __RPC_STUB IDirsyncSession_GetPasswordOptions_Stub(
    IRpcStubBuffer *This,
    IRpcChannelBuffer *_pRpcChannelBuffer,
    PRPC_MESSAGE _pRpcMessage,
    DWORD *_pdwStubPhase);


HRESULT STDMETHODCALLTYPE IDirsyncSession_Persist_Proxy( 
    IDirsyncSession * This,
    /* [in] */ BOOL fForce,
    /* [size_is][size_is][full][out][in] */ PGLOBAL_SESSIONID *prgSessionID,
    /* [full][out][in] */ DWORD *pdwSize);


void __RPC_STUB IDirsyncSession_Persist_Stub(
    IRpcStubBuffer *This,
    IRpcChannelBuffer *_pRpcChannelBuffer,
    PRPC_MESSAGE _pRpcMessage,
    DWORD *_pdwStubPhase);


HRESULT STDMETHODCALLTYPE IDirsyncSession_SetAuxData_Proxy( 
    IDirsyncSession * This,
    /* [size_is][in] */ PADS_ATTR_INFO pAttributeEntries,
    /* [in] */ DWORD dwNumAttributes,
    /* [out] */ DWORD *pdwNumAttributesModified);


void __RPC_STUB IDirsyncSession_SetAuxData_Stub(
    IRpcStubBuffer *This,
    IRpcChannelBuffer *_pRpcChannelBuffer,
    PRPC_MESSAGE _pRpcMessage,
    DWORD *_pdwStubPhase);


HRESULT STDMETHODCALLTYPE IDirsyncSession_GetAuxData_Proxy( 
    IDirsyncSession * This,
    /* [size_is][in] */ PWSTR *pAttributeName,
    /* [in] */ DWORD dwNumAttributes,
    /* [size_is][size_is][out] */ PADS_ATTR_INFO *ppAttributeEntries,
    /* [out] */ DWORD *pdwAttributesReturned);


void __RPC_STUB IDirsyncSession_GetAuxData_Stub(
    IRpcStubBuffer *This,
    IRpcChannelBuffer *_pRpcChannelBuffer,
    PRPC_MESSAGE _pRpcMessage,
    DWORD *_pdwStubPhase);


HRESULT STDMETHODCALLTYPE IDirsyncSession_GetFailedObjectList_Proxy( 
    IDirsyncSession * This,
    /* [retval][out] */ IDirsyncFailedObjectList **pFailedObjectList);


void __RPC_STUB IDirsyncSession_GetFailedObjectList_Stub(
    IRpcStubBuffer *This,
    IRpcChannelBuffer *_pRpcChannelBuffer,
    PRPC_MESSAGE _pRpcMessage,
    DWORD *_pdwStubPhase);


HRESULT STDMETHODCALLTYPE IDirsyncSession_GetNamespaceMapping_Proxy( 
    IDirsyncSession * This,
    /* [retval][out] */ IDirsyncNamespaceMapping **pNamespaceMapping);


void __RPC_STUB IDirsyncSession_GetNamespaceMapping_Stub(
    IRpcStubBuffer *This,
    IRpcChannelBuffer *_pRpcChannelBuffer,
    PRPC_MESSAGE _pRpcMessage,
    DWORD *_pdwStubPhase);


HRESULT STDMETHODCALLTYPE IDirsyncSession_GetRuntimeNamespaceMapping_Proxy( 
    IDirsyncSession * This,
    /* [retval][out] */ IDirsyncNamespaceMapping **pNamespaceMapping);


void __RPC_STUB IDirsyncSession_GetRuntimeNamespaceMapping_Stub(
    IRpcStubBuffer *This,
    IRpcChannelBuffer *_pRpcChannelBuffer,
    PRPC_MESSAGE _pRpcMessage,
    DWORD *_pdwStubPhase);


HRESULT STDMETHODCALLTYPE IDirsyncSession_IsClassMappingValid_Proxy( 
    IDirsyncSession * This,
    /* [in] */ PWSTR pszClassSource,
    /* [in] */ PWSTR pszClassTarget);


void __RPC_STUB IDirsyncSession_IsClassMappingValid_Stub(
    IRpcStubBuffer *This,
    IRpcChannelBuffer *_pRpcChannelBuffer,
    PRPC_MESSAGE _pRpcMessage,
    DWORD *_pdwStubPhase);


/* [propget] */ HRESULT STDMETHODCALLTYPE IDirsyncSession_get_ObjMapFilePath_Proxy( 
    IDirsyncSession * This,
    /* [retval][out] */ PWSTR *ppszObjMapFilePath);


void __RPC_STUB IDirsyncSession_get_ObjMapFilePath_Stub(
    IRpcStubBuffer *This,
    IRpcChannelBuffer *_pRpcChannelBuffer,
    PRPC_MESSAGE _pRpcMessage,
    DWORD *_pdwStubPhase);


/* [propput] */ HRESULT STDMETHODCALLTYPE IDirsyncSession_put_ObjMapFilePath_Proxy( 
    IDirsyncSession * This,
    /* [full][in] */ PWSTR pszObjMapFilePath);


void __RPC_STUB IDirsyncSession_put_ObjMapFilePath_Stub(
    IRpcStubBuffer *This,
    IRpcChannelBuffer *_pRpcChannelBuffer,
    PRPC_MESSAGE _pRpcMessage,
    DWORD *_pdwStubPhase);


HRESULT STDMETHODCALLTYPE IDirsyncSession_GetSyncStatus_Proxy( 
    IDirsyncSession * This,
    /* [out] */ DWORD *pdwPercent,
    /* [out] */ DWORD *pdwWarning,
    /* [out] */ DWORD *pdwError);


void __RPC_STUB IDirsyncSession_GetSyncStatus_Stub(
    IRpcStubBuffer *This,
    IRpcChannelBuffer *_pRpcChannelBuffer,
    PRPC_MESSAGE _pRpcMessage,
    DWORD *_pdwStubPhase);


HRESULT STDMETHODCALLTYPE IDirsyncSession_UpdateTerminationStatus_Proxy( 
    IDirsyncSession * This);


void __RPC_STUB IDirsyncSession_UpdateTerminationStatus_Stub(
    IRpcStubBuffer *This,
    IRpcChannelBuffer *_pRpcChannelBuffer,
    PRPC_MESSAGE _pRpcMessage,
    DWORD *_pdwStubPhase);



#endif 	/* __IDirsyncSession_INTERFACE_DEFINED__ */


#ifndef __IDirsyncSessionCallback_INTERFACE_DEFINED__
#define __IDirsyncSessionCallback_INTERFACE_DEFINED__

/* interface IDirsyncSessionCallback */
/* [unique][helpstring][uuid][local][object] */ 


EXTERN_C const IID IID_IDirsyncSessionCallback;

#if defined(__cplusplus) && !defined(CINTERFACE)
    
    MIDL_INTERFACE("f0dd3480-1531-11d2-ba65-0000f87a369e")
    IDirsyncSessionCallback : public IUnknown
    {
    public:
        virtual HRESULT STDMETHODCALLTYPE AddFailedObject( 
            /* [in] */ PDIRSYNCOBJECT pObject,
            /* [in] */ HRESULT hrLastSync,
            /* [in] */ SYNCDIRECTION syncDirection,
            /* [in] */ RETRYTYPE retryType) = 0;
        
        virtual void STDMETHODCALLTYPE FreeDirsyncObject( 
            /* [in] */ PDIRSYNCOBJECT pObject,
            /* [in] */ BOOL fFreeOuter) = 0;
        
        virtual void STDMETHODCALLTYPE FreeSessionData( 
            /* [in] */ PSESSIONDATA pSessionData) = 0;
        
        virtual HRESULT STDMETHODCALLTYPE GetDataStore( 
            /* [retval][out] */ IDirsyncDatabase **ppDirsyncDatabase) = 0;
        
        virtual HRESULT STDMETHODCALLTYPE AddObjectIdMapping( 
            /* [in] */ PBYTE pSourceId,
            /* [in] */ DWORD cbSourceId,
            /* [in] */ PBYTE pTargetId,
            /* [in] */ DWORD cbTargetId,
            /* [in] */ SYNCDIRECTION syncDirection) = 0;
        
        virtual HRESULT STDMETHODCALLTYPE DeleteObjectIdMapping( 
            /* [in] */ PBYTE pTargetId,
            /* [in] */ DWORD cbTargetId,
            /* [in] */ SYNCPROVIDER Provider) = 0;
        
        virtual HRESULT STDMETHODCALLTYPE ReportSourceStatus( 
            /* [in] */ PDIRSYNCOBJECT pObject) = 0;
        
        virtual HRESULT STDMETHODCALLTYPE SetSessionPassword( 
            /* [in] */ PWSTR pszPassword,
            /* [in] */ SYNCDIRECTION syncDirection) = 0;
        
        virtual HRESULT STDMETHODCALLTYPE SetCheckSum( 
            /* [in] */ PBYTE pId,
            /* [in] */ DWORD cbId,
            /* [in] */ SYNCPROVIDER Provider,
            /* [in] */ DWORD dwCheckSum) = 0;
        
        virtual HRESULT STDMETHODCALLTYPE GetCheckSum( 
            /* [in] */ PBYTE pId,
            /* [in] */ DWORD cbId,
            /* [in] */ SYNCPROVIDER Provider,
            /* [out] */ DWORD *dwCheckSum) = 0;
        
        virtual HRESULT STDMETHODCALLTYPE SetDampeningInfo( 
            /* [in] */ PBYTE pObjectId,
            /* [in] */ DWORD cbObjectId,
            /* [in] */ SYNCPROVIDER Provider,
            /* [in] */ PBYTE pByte,
            /* [in] */ DWORD dwSize,
            /* [in] */ LONGLONG highestUSN) = 0;
        
        virtual HRESULT STDMETHODCALLTYPE GetDampeningInfo( 
            /* [in] */ PBYTE pObjectId,
            /* [in] */ DWORD cbObjectId,
            /* [in] */ SYNCPROVIDER Provider,
            /* [out] */ PBYTE *ppByte,
            /* [out] */ DWORD *pdwSize,
            /* [out] */ LONGLONG *pHighestUSN) = 0;
        
        virtual HRESULT STDMETHODCALLTYPE GetUnMarkedEntries( 
            PBYTE **prgpbId,
            DWORD *pdwEntries,
            SYNCPROVIDER Provider) = 0;
        
        virtual HRESULT STDMETHODCALLTYPE MarkEntry( 
            PBYTE pId,
            DWORD cbId,
            SYNCPROVIDER Provider) = 0;
        
        virtual HRESULT STDMETHODCALLTYPE DeleteFailedObject( 
            /* [in] */ PWSTR szObjectId) = 0;
        
    };
    
#else 	/* C style interface */

    typedef struct IDirsyncSessionCallbackVtbl
    {
        BEGIN_INTERFACE
        
        HRESULT ( STDMETHODCALLTYPE *QueryInterface )( 
            IDirsyncSessionCallback * This,
            /* [in] */ REFIID riid,
            /* [iid_is][out] */ void **ppvObject);
        
        ULONG ( STDMETHODCALLTYPE *AddRef )( 
            IDirsyncSessionCallback * This);
        
        ULONG ( STDMETHODCALLTYPE *Release )( 
            IDirsyncSessionCallback * This);
        
        HRESULT ( STDMETHODCALLTYPE *AddFailedObject )( 
            IDirsyncSessionCallback * This,
            /* [in] */ PDIRSYNCOBJECT pObject,
            /* [in] */ HRESULT hrLastSync,
            /* [in] */ SYNCDIRECTION syncDirection,
            /* [in] */ RETRYTYPE retryType);
        
        void ( STDMETHODCALLTYPE *FreeDirsyncObject )( 
            IDirsyncSessionCallback * This,
            /* [in] */ PDIRSYNCOBJECT pObject,
            /* [in] */ BOOL fFreeOuter);
        
        void ( STDMETHODCALLTYPE *FreeSessionData )( 
            IDirsyncSessionCallback * This,
            /* [in] */ PSESSIONDATA pSessionData);
        
        HRESULT ( STDMETHODCALLTYPE *GetDataStore )( 
            IDirsyncSessionCallback * This,
            /* [retval][out] */ IDirsyncDatabase **ppDirsyncDatabase);
        
        HRESULT ( STDMETHODCALLTYPE *AddObjectIdMapping )( 
            IDirsyncSessionCallback * This,
            /* [in] */ PBYTE pSourceId,
            /* [in] */ DWORD cbSourceId,
            /* [in] */ PBYTE pTargetId,
            /* [in] */ DWORD cbTargetId,
            /* [in] */ SYNCDIRECTION syncDirection);
        
        HRESULT ( STDMETHODCALLTYPE *DeleteObjectIdMapping )( 
            IDirsyncSessionCallback * This,
            /* [in] */ PBYTE pTargetId,
            /* [in] */ DWORD cbTargetId,
            /* [in] */ SYNCPROVIDER Provider);
        
        HRESULT ( STDMETHODCALLTYPE *ReportSourceStatus )( 
            IDirsyncSessionCallback * This,
            /* [in] */ PDIRSYNCOBJECT pObject);
        
        HRESULT ( STDMETHODCALLTYPE *SetSessionPassword )( 
            IDirsyncSessionCallback * This,
            /* [in] */ PWSTR pszPassword,
            /* [in] */ SYNCDIRECTION syncDirection);
        
        HRESULT ( STDMETHODCALLTYPE *SetCheckSum )( 
            IDirsyncSessionCallback * This,
            /* [in] */ PBYTE pId,
            /* [in] */ DWORD cbId,
            /* [in] */ SYNCPROVIDER Provider,
            /* [in] */ DWORD dwCheckSum);
        
        HRESULT ( STDMETHODCALLTYPE *GetCheckSum )( 
            IDirsyncSessionCallback * This,
            /* [in] */ PBYTE pId,
            /* [in] */ DWORD cbId,
            /* [in] */ SYNCPROVIDER Provider,
            /* [out] */ DWORD *dwCheckSum);
        
        HRESULT ( STDMETHODCALLTYPE *SetDampeningInfo )( 
            IDirsyncSessionCallback * This,
            /* [in] */ PBYTE pObjectId,
            /* [in] */ DWORD cbObjectId,
            /* [in] */ SYNCPROVIDER Provider,
            /* [in] */ PBYTE pByte,
            /* [in] */ DWORD dwSize,
            /* [in] */ LONGLONG highestUSN);
        
        HRESULT ( STDMETHODCALLTYPE *GetDampeningInfo )( 
            IDirsyncSessionCallback * This,
            /* [in] */ PBYTE pObjectId,
            /* [in] */ DWORD cbObjectId,
            /* [in] */ SYNCPROVIDER Provider,
            /* [out] */ PBYTE *ppByte,
            /* [out] */ DWORD *pdwSize,
            /* [out] */ LONGLONG *pHighestUSN);
        
        HRESULT ( STDMETHODCALLTYPE *GetUnMarkedEntries )( 
            IDirsyncSessionCallback * This,
            PBYTE **prgpbId,
            DWORD *pdwEntries,
            SYNCPROVIDER Provider);
        
        HRESULT ( STDMETHODCALLTYPE *MarkEntry )( 
            IDirsyncSessionCallback * This,
            PBYTE pId,
            DWORD cbId,
            SYNCPROVIDER Provider);
        
        HRESULT ( STDMETHODCALLTYPE *DeleteFailedObject )( 
            IDirsyncSessionCallback * This,
            /* [in] */ PWSTR szObjectId);
        
        END_INTERFACE
    } IDirsyncSessionCallbackVtbl;

    interface IDirsyncSessionCallback
    {
        CONST_VTBL struct IDirsyncSessionCallbackVtbl *lpVtbl;
    };

    

#ifdef COBJMACROS


#define IDirsyncSessionCallback_QueryInterface(This,riid,ppvObject)	\
    (This)->lpVtbl -> QueryInterface(This,riid,ppvObject)

#define IDirsyncSessionCallback_AddRef(This)	\
    (This)->lpVtbl -> AddRef(This)

#define IDirsyncSessionCallback_Release(This)	\
    (This)->lpVtbl -> Release(This)


#define IDirsyncSessionCallback_AddFailedObject(This,pObject,hrLastSync,syncDirection,retryType)	\
    (This)->lpVtbl -> AddFailedObject(This,pObject,hrLastSync,syncDirection,retryType)

#define IDirsyncSessionCallback_FreeDirsyncObject(This,pObject,fFreeOuter)	\
    (This)->lpVtbl -> FreeDirsyncObject(This,pObject,fFreeOuter)

#define IDirsyncSessionCallback_FreeSessionData(This,pSessionData)	\
    (This)->lpVtbl -> FreeSessionData(This,pSessionData)

#define IDirsyncSessionCallback_GetDataStore(This,ppDirsyncDatabase)	\
    (This)->lpVtbl -> GetDataStore(This,ppDirsyncDatabase)

#define IDirsyncSessionCallback_AddObjectIdMapping(This,pSourceId,cbSourceId,pTargetId,cbTargetId,syncDirection)	\
    (This)->lpVtbl -> AddObjectIdMapping(This,pSourceId,cbSourceId,pTargetId,cbTargetId,syncDirection)

#define IDirsyncSessionCallback_DeleteObjectIdMapping(This,pTargetId,cbTargetId,Provider)	\
    (This)->lpVtbl -> DeleteObjectIdMapping(This,pTargetId,cbTargetId,Provider)

#define IDirsyncSessionCallback_ReportSourceStatus(This,pObject)	\
    (This)->lpVtbl -> ReportSourceStatus(This,pObject)

#define IDirsyncSessionCallback_SetSessionPassword(This,pszPassword,syncDirection)	\
    (This)->lpVtbl -> SetSessionPassword(This,pszPassword,syncDirection)

#define IDirsyncSessionCallback_SetCheckSum(This,pId,cbId,Provider,dwCheckSum)	\
    (This)->lpVtbl -> SetCheckSum(This,pId,cbId,Provider,dwCheckSum)

#define IDirsyncSessionCallback_GetCheckSum(This,pId,cbId,Provider,dwCheckSum)	\
    (This)->lpVtbl -> GetCheckSum(This,pId,cbId,Provider,dwCheckSum)

#define IDirsyncSessionCallback_SetDampeningInfo(This,pObjectId,cbObjectId,Provider,pByte,dwSize,highestUSN)	\
    (This)->lpVtbl -> SetDampeningInfo(This,pObjectId,cbObjectId,Provider,pByte,dwSize,highestUSN)

#define IDirsyncSessionCallback_GetDampeningInfo(This,pObjectId,cbObjectId,Provider,ppByte,pdwSize,pHighestUSN)	\
    (This)->lpVtbl -> GetDampeningInfo(This,pObjectId,cbObjectId,Provider,ppByte,pdwSize,pHighestUSN)

#define IDirsyncSessionCallback_GetUnMarkedEntries(This,prgpbId,pdwEntries,Provider)	\
    (This)->lpVtbl -> GetUnMarkedEntries(This,prgpbId,pdwEntries,Provider)

#define IDirsyncSessionCallback_MarkEntry(This,pId,cbId,Provider)	\
    (This)->lpVtbl -> MarkEntry(This,pId,cbId,Provider)

#define IDirsyncSessionCallback_DeleteFailedObject(This,szObjectId)	\
    (This)->lpVtbl -> DeleteFailedObject(This,szObjectId)

#endif /* COBJMACROS */


#endif 	/* C style interface */



HRESULT STDMETHODCALLTYPE IDirsyncSessionCallback_AddFailedObject_Proxy( 
    IDirsyncSessionCallback * This,
    /* [in] */ PDIRSYNCOBJECT pObject,
    /* [in] */ HRESULT hrLastSync,
    /* [in] */ SYNCDIRECTION syncDirection,
    /* [in] */ RETRYTYPE retryType);


void __RPC_STUB IDirsyncSessionCallback_AddFailedObject_Stub(
    IRpcStubBuffer *This,
    IRpcChannelBuffer *_pRpcChannelBuffer,
    PRPC_MESSAGE _pRpcMessage,
    DWORD *_pdwStubPhase);


void STDMETHODCALLTYPE IDirsyncSessionCallback_FreeDirsyncObject_Proxy( 
    IDirsyncSessionCallback * This,
    /* [in] */ PDIRSYNCOBJECT pObject,
    /* [in] */ BOOL fFreeOuter);


void __RPC_STUB IDirsyncSessionCallback_FreeDirsyncObject_Stub(
    IRpcStubBuffer *This,
    IRpcChannelBuffer *_pRpcChannelBuffer,
    PRPC_MESSAGE _pRpcMessage,
    DWORD *_pdwStubPhase);


void STDMETHODCALLTYPE IDirsyncSessionCallback_FreeSessionData_Proxy( 
    IDirsyncSessionCallback * This,
    /* [in] */ PSESSIONDATA pSessionData);


void __RPC_STUB IDirsyncSessionCallback_FreeSessionData_Stub(
    IRpcStubBuffer *This,
    IRpcChannelBuffer *_pRpcChannelBuffer,
    PRPC_MESSAGE _pRpcMessage,
    DWORD *_pdwStubPhase);


HRESULT STDMETHODCALLTYPE IDirsyncSessionCallback_GetDataStore_Proxy( 
    IDirsyncSessionCallback * This,
    /* [retval][out] */ IDirsyncDatabase **ppDirsyncDatabase);


void __RPC_STUB IDirsyncSessionCallback_GetDataStore_Stub(
    IRpcStubBuffer *This,
    IRpcChannelBuffer *_pRpcChannelBuffer,
    PRPC_MESSAGE _pRpcMessage,
    DWORD *_pdwStubPhase);


HRESULT STDMETHODCALLTYPE IDirsyncSessionCallback_AddObjectIdMapping_Proxy( 
    IDirsyncSessionCallback * This,
    /* [in] */ PBYTE pSourceId,
    /* [in] */ DWORD cbSourceId,
    /* [in] */ PBYTE pTargetId,
    /* [in] */ DWORD cbTargetId,
    /* [in] */ SYNCDIRECTION syncDirection);


void __RPC_STUB IDirsyncSessionCallback_AddObjectIdMapping_Stub(
    IRpcStubBuffer *This,
    IRpcChannelBuffer *_pRpcChannelBuffer,
    PRPC_MESSAGE _pRpcMessage,
    DWORD *_pdwStubPhase);


HRESULT STDMETHODCALLTYPE IDirsyncSessionCallback_DeleteObjectIdMapping_Proxy( 
    IDirsyncSessionCallback * This,
    /* [in] */ PBYTE pTargetId,
    /* [in] */ DWORD cbTargetId,
    /* [in] */ SYNCPROVIDER Provider);


void __RPC_STUB IDirsyncSessionCallback_DeleteObjectIdMapping_Stub(
    IRpcStubBuffer *This,
    IRpcChannelBuffer *_pRpcChannelBuffer,
    PRPC_MESSAGE _pRpcMessage,
    DWORD *_pdwStubPhase);


HRESULT STDMETHODCALLTYPE IDirsyncSessionCallback_ReportSourceStatus_Proxy( 
    IDirsyncSessionCallback * This,
    /* [in] */ PDIRSYNCOBJECT pObject);


void __RPC_STUB IDirsyncSessionCallback_ReportSourceStatus_Stub(
    IRpcStubBuffer *This,
    IRpcChannelBuffer *_pRpcChannelBuffer,
    PRPC_MESSAGE _pRpcMessage,
    DWORD *_pdwStubPhase);


HRESULT STDMETHODCALLTYPE IDirsyncSessionCallback_SetSessionPassword_Proxy( 
    IDirsyncSessionCallback * This,
    /* [in] */ PWSTR pszPassword,
    /* [in] */ SYNCDIRECTION syncDirection);


void __RPC_STUB IDirsyncSessionCallback_SetSessionPassword_Stub(
    IRpcStubBuffer *This,
    IRpcChannelBuffer *_pRpcChannelBuffer,
    PRPC_MESSAGE _pRpcMessage,
    DWORD *_pdwStubPhase);


HRESULT STDMETHODCALLTYPE IDirsyncSessionCallback_SetCheckSum_Proxy( 
    IDirsyncSessionCallback * This,
    /* [in] */ PBYTE pId,
    /* [in] */ DWORD cbId,
    /* [in] */ SYNCPROVIDER Provider,
    /* [in] */ DWORD dwCheckSum);


void __RPC_STUB IDirsyncSessionCallback_SetCheckSum_Stub(
    IRpcStubBuffer *This,
    IRpcChannelBuffer *_pRpcChannelBuffer,
    PRPC_MESSAGE _pRpcMessage,
    DWORD *_pdwStubPhase);


HRESULT STDMETHODCALLTYPE IDirsyncSessionCallback_GetCheckSum_Proxy( 
    IDirsyncSessionCallback * This,
    /* [in] */ PBYTE pId,
    /* [in] */ DWORD cbId,
    /* [in] */ SYNCPROVIDER Provider,
    /* [out] */ DWORD *dwCheckSum);


void __RPC_STUB IDirsyncSessionCallback_GetCheckSum_Stub(
    IRpcStubBuffer *This,
    IRpcChannelBuffer *_pRpcChannelBuffer,
    PRPC_MESSAGE _pRpcMessage,
    DWORD *_pdwStubPhase);


HRESULT STDMETHODCALLTYPE IDirsyncSessionCallback_SetDampeningInfo_Proxy( 
    IDirsyncSessionCallback * This,
    /* [in] */ PBYTE pObjectId,
    /* [in] */ DWORD cbObjectId,
    /* [in] */ SYNCPROVIDER Provider,
    /* [in] */ PBYTE pByte,
    /* [in] */ DWORD dwSize,
    /* [in] */ LONGLONG highestUSN);


void __RPC_STUB IDirsyncSessionCallback_SetDampeningInfo_Stub(
    IRpcStubBuffer *This,
    IRpcChannelBuffer *_pRpcChannelBuffer,
    PRPC_MESSAGE _pRpcMessage,
    DWORD *_pdwStubPhase);


HRESULT STDMETHODCALLTYPE IDirsyncSessionCallback_GetDampeningInfo_Proxy( 
    IDirsyncSessionCallback * This,
    /* [in] */ PBYTE pObjectId,
    /* [in] */ DWORD cbObjectId,
    /* [in] */ SYNCPROVIDER Provider,
    /* [out] */ PBYTE *ppByte,
    /* [out] */ DWORD *pdwSize,
    /* [out] */ LONGLONG *pHighestUSN);


void __RPC_STUB IDirsyncSessionCallback_GetDampeningInfo_Stub(
    IRpcStubBuffer *This,
    IRpcChannelBuffer *_pRpcChannelBuffer,
    PRPC_MESSAGE _pRpcMessage,
    DWORD *_pdwStubPhase);


HRESULT STDMETHODCALLTYPE IDirsyncSessionCallback_GetUnMarkedEntries_Proxy( 
    IDirsyncSessionCallback * This,
    PBYTE **prgpbId,
    DWORD *pdwEntries,
    SYNCPROVIDER Provider);


void __RPC_STUB IDirsyncSessionCallback_GetUnMarkedEntries_Stub(
    IRpcStubBuffer *This,
    IRpcChannelBuffer *_pRpcChannelBuffer,
    PRPC_MESSAGE _pRpcMessage,
    DWORD *_pdwStubPhase);


HRESULT STDMETHODCALLTYPE IDirsyncSessionCallback_MarkEntry_Proxy( 
    IDirsyncSessionCallback * This,
    PBYTE pId,
    DWORD cbId,
    SYNCPROVIDER Provider);


void __RPC_STUB IDirsyncSessionCallback_MarkEntry_Stub(
    IRpcStubBuffer *This,
    IRpcChannelBuffer *_pRpcChannelBuffer,
    PRPC_MESSAGE _pRpcMessage,
    DWORD *_pdwStubPhase);


HRESULT STDMETHODCALLTYPE IDirsyncSessionCallback_DeleteFailedObject_Proxy( 
    IDirsyncSessionCallback * This,
    /* [in] */ PWSTR szObjectId);


void __RPC_STUB IDirsyncSessionCallback_DeleteFailedObject_Stub(
    IRpcStubBuffer *This,
    IRpcChannelBuffer *_pRpcChannelBuffer,
    PRPC_MESSAGE _pRpcMessage,
    DWORD *_pdwStubPhase);



#endif 	/* __IDirsyncSessionCallback_INTERFACE_DEFINED__ */


#ifndef __IDirsyncWriteProvider_INTERFACE_DEFINED__
#define __IDirsyncWriteProvider_INTERFACE_DEFINED__

/* interface IDirsyncWriteProvider */
/* [unique][helpstring][uuid][local][object] */ 


EXTERN_C const IID IID_IDirsyncWriteProvider;

#if defined(__cplusplus) && !defined(CINTERFACE)
    
    MIDL_INTERFACE("f260c74b-e455-11d1-b40a-00c04fb950dc")
    IDirsyncWriteProvider : public IUnknown
    {
    public:
        virtual HRESULT STDMETHODCALLTYPE Initialize( 
            /* [in] */ IDirsyncSession *pSession,
            /* [in] */ IDirsyncSessionCallback *pSessionCallback,
            /* [in] */ IDirsyncSessionManager *pSessionManager,
            /* [in] */ IDirsyncObjectMapper *pObjectMapper,
            /* [in] */ SYNCDIRECTION syncDirection,
            /* [in] */ BOOL fFullSync) = 0;
        
        virtual HRESULT STDMETHODCALLTYPE ApplyChange( 
            /* [in] */ PDIRSYNCOBJECT pObject) = 0;
        
        virtual HRESULT STDMETHODCALLTYPE CommitChanges( void) = 0;
        
        virtual HRESULT STDMETHODCALLTYPE Terminate( void) = 0;
        
    };
    
#else 	/* C style interface */

    typedef struct IDirsyncWriteProviderVtbl
    {
        BEGIN_INTERFACE
        
        HRESULT ( STDMETHODCALLTYPE *QueryInterface )( 
            IDirsyncWriteProvider * This,
            /* [in] */ REFIID riid,
            /* [iid_is][out] */ void **ppvObject);
        
        ULONG ( STDMETHODCALLTYPE *AddRef )( 
            IDirsyncWriteProvider * This);
        
        ULONG ( STDMETHODCALLTYPE *Release )( 
            IDirsyncWriteProvider * This);
        
        HRESULT ( STDMETHODCALLTYPE *Initialize )( 
            IDirsyncWriteProvider * This,
            /* [in] */ IDirsyncSession *pSession,
            /* [in] */ IDirsyncSessionCallback *pSessionCallback,
            /* [in] */ IDirsyncSessionManager *pSessionManager,
            /* [in] */ IDirsyncObjectMapper *pObjectMapper,
            /* [in] */ SYNCDIRECTION syncDirection,
            /* [in] */ BOOL fFullSync);
        
        HRESULT ( STDMETHODCALLTYPE *ApplyChange )( 
            IDirsyncWriteProvider * This,
            /* [in] */ PDIRSYNCOBJECT pObject);
        
        HRESULT ( STDMETHODCALLTYPE *CommitChanges )( 
            IDirsyncWriteProvider * This);
        
        HRESULT ( STDMETHODCALLTYPE *Terminate )( 
            IDirsyncWriteProvider * This);
        
        END_INTERFACE
    } IDirsyncWriteProviderVtbl;

    interface IDirsyncWriteProvider
    {
        CONST_VTBL struct IDirsyncWriteProviderVtbl *lpVtbl;
    };

    

#ifdef COBJMACROS


#define IDirsyncWriteProvider_QueryInterface(This,riid,ppvObject)	\
    (This)->lpVtbl -> QueryInterface(This,riid,ppvObject)

#define IDirsyncWriteProvider_AddRef(This)	\
    (This)->lpVtbl -> AddRef(This)

#define IDirsyncWriteProvider_Release(This)	\
    (This)->lpVtbl -> Release(This)


#define IDirsyncWriteProvider_Initialize(This,pSession,pSessionCallback,pSessionManager,pObjectMapper,syncDirection,fFullSync)	\
    (This)->lpVtbl -> Initialize(This,pSession,pSessionCallback,pSessionManager,pObjectMapper,syncDirection,fFullSync)

#define IDirsyncWriteProvider_ApplyChange(This,pObject)	\
    (This)->lpVtbl -> ApplyChange(This,pObject)

#define IDirsyncWriteProvider_CommitChanges(This)	\
    (This)->lpVtbl -> CommitChanges(This)

#define IDirsyncWriteProvider_Terminate(This)	\
    (This)->lpVtbl -> Terminate(This)

#endif /* COBJMACROS */


#endif 	/* C style interface */



HRESULT STDMETHODCALLTYPE IDirsyncWriteProvider_Initialize_Proxy( 
    IDirsyncWriteProvider * This,
    /* [in] */ IDirsyncSession *pSession,
    /* [in] */ IDirsyncSessionCallback *pSessionCallback,
    /* [in] */ IDirsyncSessionManager *pSessionManager,
    /* [in] */ IDirsyncObjectMapper *pObjectMapper,
    /* [in] */ SYNCDIRECTION syncDirection,
    /* [in] */ BOOL fFullSync);


void __RPC_STUB IDirsyncWriteProvider_Initialize_Stub(
    IRpcStubBuffer *This,
    IRpcChannelBuffer *_pRpcChannelBuffer,
    PRPC_MESSAGE _pRpcMessage,
    DWORD *_pdwStubPhase);


HRESULT STDMETHODCALLTYPE IDirsyncWriteProvider_ApplyChange_Proxy( 
    IDirsyncWriteProvider * This,
    /* [in] */ PDIRSYNCOBJECT pObject);


void __RPC_STUB IDirsyncWriteProvider_ApplyChange_Stub(
    IRpcStubBuffer *This,
    IRpcChannelBuffer *_pRpcChannelBuffer,
    PRPC_MESSAGE _pRpcMessage,
    DWORD *_pdwStubPhase);


HRESULT STDMETHODCALLTYPE IDirsyncWriteProvider_CommitChanges_Proxy( 
    IDirsyncWriteProvider * This);


void __RPC_STUB IDirsyncWriteProvider_CommitChanges_Stub(
    IRpcStubBuffer *This,
    IRpcChannelBuffer *_pRpcChannelBuffer,
    PRPC_MESSAGE _pRpcMessage,
    DWORD *_pdwStubPhase);


HRESULT STDMETHODCALLTYPE IDirsyncWriteProvider_Terminate_Proxy( 
    IDirsyncWriteProvider * This);


void __RPC_STUB IDirsyncWriteProvider_Terminate_Stub(
    IRpcStubBuffer *This,
    IRpcChannelBuffer *_pRpcChannelBuffer,
    PRPC_MESSAGE _pRpcMessage,
    DWORD *_pdwStubPhase);



#endif 	/* __IDirsyncWriteProvider_INTERFACE_DEFINED__ */


#ifndef __IDirsyncServer_INTERFACE_DEFINED__
#define __IDirsyncServer_INTERFACE_DEFINED__

/* interface IDirsyncServer */
/* [unique][helpstring][uuid][object] */ 


EXTERN_C const IID IID_IDirsyncServer;

#if defined(__cplusplus) && !defined(CINTERFACE)
    
    MIDL_INTERFACE("43bc048c-c8ec-11d1-a40b-00c04fb950dc")
    IDirsyncServer : public IUnknown
    {
    public:
        virtual HRESULT STDMETHODCALLTYPE RegisterProvider( 
            /* [in] */ PROVIDERTYPE providerType,
            /* [in] */ PWSTR pDirectoryType,
            /* [in] */ REFCLSID rclsid) = 0;
        
        virtual HRESULT STDMETHODCALLTYPE UnregisterProvider( 
            /* [in] */ PROVIDERTYPE providerType,
            /* [in] */ PWSTR pDirectoryType) = 0;
        
        virtual HRESULT STDMETHODCALLTYPE GetServers( 
            /* [size_is][size_is][out] */ PWSTR **prgpszServers,
            /* [out] */ DWORD *pnServers) = 0;
        
        virtual HRESULT STDMETHODCALLTYPE RegisterCustomMapper( 
            /* [in] */ CUSTOMMAPPERTYPE mapperType,
            /* [in] */ PWSTR pszDirectoryType,
            /* [in] */ PWSTR pszClassName,
            /* [in] */ PWSTR pszAttrName,
            /* [in] */ REFCLSID rclsid) = 0;
        
        virtual HRESULT STDMETHODCALLTYPE UnregisterCustomMapper( 
            /* [in] */ CUSTOMMAPPERTYPE mapperType,
            /* [in] */ PWSTR pszDirectoryType,
            /* [in] */ PWSTR pszClassName,
            /* [in] */ PWSTR pszAttrName) = 0;
        
        virtual HRESULT STDMETHODCALLTYPE GetSessionManager( 
            /* [retval][out] */ IDirsyncSessionManager **ppSessionManager) = 0;
        
    };
    
#else 	/* C style interface */

    typedef struct IDirsyncServerVtbl
    {
        BEGIN_INTERFACE
        
        HRESULT ( STDMETHODCALLTYPE *QueryInterface )( 
            IDirsyncServer * This,
            /* [in] */ REFIID riid,
            /* [iid_is][out] */ void **ppvObject);
        
        ULONG ( STDMETHODCALLTYPE *AddRef )( 
            IDirsyncServer * This);
        
        ULONG ( STDMETHODCALLTYPE *Release )( 
            IDirsyncServer * This);
        
        HRESULT ( STDMETHODCALLTYPE *RegisterProvider )( 
            IDirsyncServer * This,
            /* [in] */ PROVIDERTYPE providerType,
            /* [in] */ PWSTR pDirectoryType,
            /* [in] */ REFCLSID rclsid);
        
        HRESULT ( STDMETHODCALLTYPE *UnregisterProvider )( 
            IDirsyncServer * This,
            /* [in] */ PROVIDERTYPE providerType,
            /* [in] */ PWSTR pDirectoryType);
        
        HRESULT ( STDMETHODCALLTYPE *GetServers )( 
            IDirsyncServer * This,
            /* [size_is][size_is][out] */ PWSTR **prgpszServers,
            /* [out] */ DWORD *pnServers);
        
        HRESULT ( STDMETHODCALLTYPE *RegisterCustomMapper )( 
            IDirsyncServer * This,
            /* [in] */ CUSTOMMAPPERTYPE mapperType,
            /* [in] */ PWSTR pszDirectoryType,
            /* [in] */ PWSTR pszClassName,
            /* [in] */ PWSTR pszAttrName,
            /* [in] */ REFCLSID rclsid);
        
        HRESULT ( STDMETHODCALLTYPE *UnregisterCustomMapper )( 
            IDirsyncServer * This,
            /* [in] */ CUSTOMMAPPERTYPE mapperType,
            /* [in] */ PWSTR pszDirectoryType,
            /* [in] */ PWSTR pszClassName,
            /* [in] */ PWSTR pszAttrName);
        
        HRESULT ( STDMETHODCALLTYPE *GetSessionManager )( 
            IDirsyncServer * This,
            /* [retval][out] */ IDirsyncSessionManager **ppSessionManager);
        
        END_INTERFACE
    } IDirsyncServerVtbl;

    interface IDirsyncServer
    {
        CONST_VTBL struct IDirsyncServerVtbl *lpVtbl;
    };

    

#ifdef COBJMACROS


#define IDirsyncServer_QueryInterface(This,riid,ppvObject)	\
    (This)->lpVtbl -> QueryInterface(This,riid,ppvObject)

#define IDirsyncServer_AddRef(This)	\
    (This)->lpVtbl -> AddRef(This)

#define IDirsyncServer_Release(This)	\
    (This)->lpVtbl -> Release(This)


#define IDirsyncServer_RegisterProvider(This,providerType,pDirectoryType,rclsid)	\
    (This)->lpVtbl -> RegisterProvider(This,providerType,pDirectoryType,rclsid)

#define IDirsyncServer_UnregisterProvider(This,providerType,pDirectoryType)	\
    (This)->lpVtbl -> UnregisterProvider(This,providerType,pDirectoryType)

#define IDirsyncServer_GetServers(This,prgpszServers,pnServers)	\
    (This)->lpVtbl -> GetServers(This,prgpszServers,pnServers)

#define IDirsyncServer_RegisterCustomMapper(This,mapperType,pszDirectoryType,pszClassName,pszAttrName,rclsid)	\
    (This)->lpVtbl -> RegisterCustomMapper(This,mapperType,pszDirectoryType,pszClassName,pszAttrName,rclsid)

#define IDirsyncServer_UnregisterCustomMapper(This,mapperType,pszDirectoryType,pszClassName,pszAttrName)	\
    (This)->lpVtbl -> UnregisterCustomMapper(This,mapperType,pszDirectoryType,pszClassName,pszAttrName)

#define IDirsyncServer_GetSessionManager(This,ppSessionManager)	\
    (This)->lpVtbl -> GetSessionManager(This,ppSessionManager)

#endif /* COBJMACROS */


#endif 	/* C style interface */



HRESULT STDMETHODCALLTYPE IDirsyncServer_RegisterProvider_Proxy( 
    IDirsyncServer * This,
    /* [in] */ PROVIDERTYPE providerType,
    /* [in] */ PWSTR pDirectoryType,
    /* [in] */ REFCLSID rclsid);


void __RPC_STUB IDirsyncServer_RegisterProvider_Stub(
    IRpcStubBuffer *This,
    IRpcChannelBuffer *_pRpcChannelBuffer,
    PRPC_MESSAGE _pRpcMessage,
    DWORD *_pdwStubPhase);


HRESULT STDMETHODCALLTYPE IDirsyncServer_UnregisterProvider_Proxy( 
    IDirsyncServer * This,
    /* [in] */ PROVIDERTYPE providerType,
    /* [in] */ PWSTR pDirectoryType);


void __RPC_STUB IDirsyncServer_UnregisterProvider_Stub(
    IRpcStubBuffer *This,
    IRpcChannelBuffer *_pRpcChannelBuffer,
    PRPC_MESSAGE _pRpcMessage,
    DWORD *_pdwStubPhase);


HRESULT STDMETHODCALLTYPE IDirsyncServer_GetServers_Proxy( 
    IDirsyncServer * This,
    /* [size_is][size_is][out] */ PWSTR **prgpszServers,
    /* [out] */ DWORD *pnServers);


void __RPC_STUB IDirsyncServer_GetServers_Stub(
    IRpcStubBuffer *This,
    IRpcChannelBuffer *_pRpcChannelBuffer,
    PRPC_MESSAGE _pRpcMessage,
    DWORD *_pdwStubPhase);


HRESULT STDMETHODCALLTYPE IDirsyncServer_RegisterCustomMapper_Proxy( 
    IDirsyncServer * This,
    /* [in] */ CUSTOMMAPPERTYPE mapperType,
    /* [in] */ PWSTR pszDirectoryType,
    /* [in] */ PWSTR pszClassName,
    /* [in] */ PWSTR pszAttrName,
    /* [in] */ REFCLSID rclsid);


void __RPC_STUB IDirsyncServer_RegisterCustomMapper_Stub(
    IRpcStubBuffer *This,
    IRpcChannelBuffer *_pRpcChannelBuffer,
    PRPC_MESSAGE _pRpcMessage,
    DWORD *_pdwStubPhase);


HRESULT STDMETHODCALLTYPE IDirsyncServer_UnregisterCustomMapper_Proxy( 
    IDirsyncServer * This,
    /* [in] */ CUSTOMMAPPERTYPE mapperType,
    /* [in] */ PWSTR pszDirectoryType,
    /* [in] */ PWSTR pszClassName,
    /* [in] */ PWSTR pszAttrName);


void __RPC_STUB IDirsyncServer_UnregisterCustomMapper_Stub(
    IRpcStubBuffer *This,
    IRpcChannelBuffer *_pRpcChannelBuffer,
    PRPC_MESSAGE _pRpcMessage,
    DWORD *_pdwStubPhase);


HRESULT STDMETHODCALLTYPE IDirsyncServer_GetSessionManager_Proxy( 
    IDirsyncServer * This,
    /* [retval][out] */ IDirsyncSessionManager **ppSessionManager);


void __RPC_STUB IDirsyncServer_GetSessionManager_Stub(
    IRpcStubBuffer *This,
    IRpcChannelBuffer *_pRpcChannelBuffer,
    PRPC_MESSAGE _pRpcMessage,
    DWORD *_pdwStubPhase);



#endif 	/* __IDirsyncServer_INTERFACE_DEFINED__ */


#ifndef __IDirsyncReadProvider_INTERFACE_DEFINED__
#define __IDirsyncReadProvider_INTERFACE_DEFINED__

/* interface IDirsyncReadProvider */
/* [unique][helpstring][uuid][local][object] */ 


EXTERN_C const IID IID_IDirsyncReadProvider;

#if defined(__cplusplus) && !defined(CINTERFACE)
    
    MIDL_INTERFACE("ac80a9d2-de29-11d1-ba56-2700272c2027")
    IDirsyncReadProvider : public IUnknown
    {
    public:
        virtual HRESULT STDMETHODCALLTYPE Initialize( 
            /* [in] */ IDirsyncSession *pSession,
            /* [in] */ IDirsyncSessionCallback *pSessionCallback,
            /* [in] */ IDirsyncSessionManager *pSessionManager,
            /* [in] */ SYNCDIRECTION syncDirection,
            /* [in] */ BOOL fFullSync) = 0;
        
        virtual HRESULT STDMETHODCALLTYPE GetNextChange( 
            /* [out] */ PDIRSYNCOBJECT *ppObject,
            /* [out] */ PBYTE *ppWatermark,
            /* [out] */ DWORD *pcbWatermark,
            /* [out][in] */ DWORD *pdwPercentCompleted) = 0;
        
        virtual HRESULT STDMETHODCALLTYPE UpdateWatermark( 
            /* [in] */ PBYTE pWatermark,
            /* [in] */ DWORD cbWatermark) = 0;
        
        virtual HRESULT STDMETHODCALLTYPE Terminate( void) = 0;
        
        virtual /* [propget] */ HRESULT STDMETHODCALLTYPE get_IsIncrementalChangesAvailable( 
            /* [retval][out] */ BOOL *fIsIncrementalChangesAvailable) = 0;
        
    };
    
#else 	/* C style interface */

    typedef struct IDirsyncReadProviderVtbl
    {
        BEGIN_INTERFACE
        
        HRESULT ( STDMETHODCALLTYPE *QueryInterface )( 
            IDirsyncReadProvider * This,
            /* [in] */ REFIID riid,
            /* [iid_is][out] */ void **ppvObject);
        
        ULONG ( STDMETHODCALLTYPE *AddRef )( 
            IDirsyncReadProvider * This);
        
        ULONG ( STDMETHODCALLTYPE *Release )( 
            IDirsyncReadProvider * This);
        
        HRESULT ( STDMETHODCALLTYPE *Initialize )( 
            IDirsyncReadProvider * This,
            /* [in] */ IDirsyncSession *pSession,
            /* [in] */ IDirsyncSessionCallback *pSessionCallback,
            /* [in] */ IDirsyncSessionManager *pSessionManager,
            /* [in] */ SYNCDIRECTION syncDirection,
            /* [in] */ BOOL fFullSync);
        
        HRESULT ( STDMETHODCALLTYPE *GetNextChange )( 
            IDirsyncReadProvider * This,
            /* [out] */ PDIRSYNCOBJECT *ppObject,
            /* [out] */ PBYTE *ppWatermark,
            /* [out] */ DWORD *pcbWatermark,
            /* [out][in] */ DWORD *pdwPercentCompleted);
        
        HRESULT ( STDMETHODCALLTYPE *UpdateWatermark )( 
            IDirsyncReadProvider * This,
            /* [in] */ PBYTE pWatermark,
            /* [in] */ DWORD cbWatermark);
        
        HRESULT ( STDMETHODCALLTYPE *Terminate )( 
            IDirsyncReadProvider * This);
        
        /* [propget] */ HRESULT ( STDMETHODCALLTYPE *get_IsIncrementalChangesAvailable )( 
            IDirsyncReadProvider * This,
            /* [retval][out] */ BOOL *fIsIncrementalChangesAvailable);
        
        END_INTERFACE
    } IDirsyncReadProviderVtbl;

    interface IDirsyncReadProvider
    {
        CONST_VTBL struct IDirsyncReadProviderVtbl *lpVtbl;
    };

    

#ifdef COBJMACROS


#define IDirsyncReadProvider_QueryInterface(This,riid,ppvObject)	\
    (This)->lpVtbl -> QueryInterface(This,riid,ppvObject)

#define IDirsyncReadProvider_AddRef(This)	\
    (This)->lpVtbl -> AddRef(This)

#define IDirsyncReadProvider_Release(This)	\
    (This)->lpVtbl -> Release(This)


#define IDirsyncReadProvider_Initialize(This,pSession,pSessionCallback,pSessionManager,syncDirection,fFullSync)	\
    (This)->lpVtbl -> Initialize(This,pSession,pSessionCallback,pSessionManager,syncDirection,fFullSync)

#define IDirsyncReadProvider_GetNextChange(This,ppObject,ppWatermark,pcbWatermark,pdwPercentCompleted)	\
    (This)->lpVtbl -> GetNextChange(This,ppObject,ppWatermark,pcbWatermark,pdwPercentCompleted)

#define IDirsyncReadProvider_UpdateWatermark(This,pWatermark,cbWatermark)	\
    (This)->lpVtbl -> UpdateWatermark(This,pWatermark,cbWatermark)

#define IDirsyncReadProvider_Terminate(This)	\
    (This)->lpVtbl -> Terminate(This)

#define IDirsyncReadProvider_get_IsIncrementalChangesAvailable(This,fIsIncrementalChangesAvailable)	\
    (This)->lpVtbl -> get_IsIncrementalChangesAvailable(This,fIsIncrementalChangesAvailable)

#endif /* COBJMACROS */


#endif 	/* C style interface */



HRESULT STDMETHODCALLTYPE IDirsyncReadProvider_Initialize_Proxy( 
    IDirsyncReadProvider * This,
    /* [in] */ IDirsyncSession *pSession,
    /* [in] */ IDirsyncSessionCallback *pSessionCallback,
    /* [in] */ IDirsyncSessionManager *pSessionManager,
    /* [in] */ SYNCDIRECTION syncDirection,
    /* [in] */ BOOL fFullSync);


void __RPC_STUB IDirsyncReadProvider_Initialize_Stub(
    IRpcStubBuffer *This,
    IRpcChannelBuffer *_pRpcChannelBuffer,
    PRPC_MESSAGE _pRpcMessage,
    DWORD *_pdwStubPhase);


HRESULT STDMETHODCALLTYPE IDirsyncReadProvider_GetNextChange_Proxy( 
    IDirsyncReadProvider * This,
    /* [out] */ PDIRSYNCOBJECT *ppObject,
    /* [out] */ PBYTE *ppWatermark,
    /* [out] */ DWORD *pcbWatermark,
    /* [out][in] */ DWORD *pdwPercentCompleted);


void __RPC_STUB IDirsyncReadProvider_GetNextChange_Stub(
    IRpcStubBuffer *This,
    IRpcChannelBuffer *_pRpcChannelBuffer,
    PRPC_MESSAGE _pRpcMessage,
    DWORD *_pdwStubPhase);


HRESULT STDMETHODCALLTYPE IDirsyncReadProvider_UpdateWatermark_Proxy( 
    IDirsyncReadProvider * This,
    /* [in] */ PBYTE pWatermark,
    /* [in] */ DWORD cbWatermark);


void __RPC_STUB IDirsyncReadProvider_UpdateWatermark_Stub(
    IRpcStubBuffer *This,
    IRpcChannelBuffer *_pRpcChannelBuffer,
    PRPC_MESSAGE _pRpcMessage,
    DWORD *_pdwStubPhase);


HRESULT STDMETHODCALLTYPE IDirsyncReadProvider_Terminate_Proxy( 
    IDirsyncReadProvider * This);


void __RPC_STUB IDirsyncReadProvider_Terminate_Stub(
    IRpcStubBuffer *This,
    IRpcChannelBuffer *_pRpcChannelBuffer,
    PRPC_MESSAGE _pRpcMessage,
    DWORD *_pdwStubPhase);


/* [propget] */ HRESULT STDMETHODCALLTYPE IDirsyncReadProvider_get_IsIncrementalChangesAvailable_Proxy( 
    IDirsyncReadProvider * This,
    /* [retval][out] */ BOOL *fIsIncrementalChangesAvailable);


void __RPC_STUB IDirsyncReadProvider_get_IsIncrementalChangesAvailable_Stub(
    IRpcStubBuffer *This,
    IRpcChannelBuffer *_pRpcChannelBuffer,
    PRPC_MESSAGE _pRpcMessage,
    DWORD *_pdwStubPhase);



#endif 	/* __IDirsyncReadProvider_INTERFACE_DEFINED__ */


/* interface __MIDL_itf_dirsync_0121 */
/* [local] */ 




extern RPC_IF_HANDLE __MIDL_itf_dirsync_0121_v0_0_c_ifspec;
extern RPC_IF_HANDLE __MIDL_itf_dirsync_0121_v0_0_s_ifspec;

#ifndef __IDirsyncNamespaceMapper_INTERFACE_DEFINED__
#define __IDirsyncNamespaceMapper_INTERFACE_DEFINED__

/* interface IDirsyncNamespaceMapper */
/* [unique][helpstring][uuid][local][object] */ 


EXTERN_C const IID IID_IDirsyncNamespaceMapper;

#if defined(__cplusplus) && !defined(CINTERFACE)
    
    MIDL_INTERFACE("a4f0c94e-27e3-11d2-a159-00c04fb950dc")
    IDirsyncNamespaceMapper : public IUnknown
    {
    public:
        virtual HRESULT STDMETHODCALLTYPE Initialize( 
            /* [in] */ IDirsyncSession *pSession,
            /* [in] */ IDirsyncSessionCallback *pSessionCallback,
            /* [in] */ IDirsyncSessionManager *pSessionManager,
            /* [in] */ SYNCDIRECTION syncDirection) = 0;
        
        virtual HRESULT STDMETHODCALLTYPE MapNamespace( 
            /* [in] */ PWSTR pszSourceDN,
            /* [in] */ PWSTR pszSourceOldDN,
            /* [out] */ PWSTR *ppszTargetDN,
            /* [out] */ PWSTR *ppszTargetOldDN,
            /* [in] */ PWSTR pszAttribute,
            /* [in] */ PWSTR pszClass,
            /* [in] */ BOOL fTargetIDAvailable) = 0;
        
    };
    
#else 	/* C style interface */

    typedef struct IDirsyncNamespaceMapperVtbl
    {
        BEGIN_INTERFACE
        
        HRESULT ( STDMETHODCALLTYPE *QueryInterface )( 
            IDirsyncNamespaceMapper * This,
            /* [in] */ REFIID riid,
            /* [iid_is][out] */ void **ppvObject);
        
        ULONG ( STDMETHODCALLTYPE *AddRef )( 
            IDirsyncNamespaceMapper * This);
        
        ULONG ( STDMETHODCALLTYPE *Release )( 
            IDirsyncNamespaceMapper * This);
        
        HRESULT ( STDMETHODCALLTYPE *Initialize )( 
            IDirsyncNamespaceMapper * This,
            /* [in] */ IDirsyncSession *pSession,
            /* [in] */ IDirsyncSessionCallback *pSessionCallback,
            /* [in] */ IDirsyncSessionManager *pSessionManager,
            /* [in] */ SYNCDIRECTION syncDirection);
        
        HRESULT ( STDMETHODCALLTYPE *MapNamespace )( 
            IDirsyncNamespaceMapper * This,
            /* [in] */ PWSTR pszSourceDN,
            /* [in] */ PWSTR pszSourceOldDN,
            /* [out] */ PWSTR *ppszTargetDN,
            /* [out] */ PWSTR *ppszTargetOldDN,
            /* [in] */ PWSTR pszAttribute,
            /* [in] */ PWSTR pszClass,
            /* [in] */ BOOL fTargetIDAvailable);
        
        END_INTERFACE
    } IDirsyncNamespaceMapperVtbl;

    interface IDirsyncNamespaceMapper
    {
        CONST_VTBL struct IDirsyncNamespaceMapperVtbl *lpVtbl;
    };

    

#ifdef COBJMACROS


#define IDirsyncNamespaceMapper_QueryInterface(This,riid,ppvObject)	\
    (This)->lpVtbl -> QueryInterface(This,riid,ppvObject)

#define IDirsyncNamespaceMapper_AddRef(This)	\
    (This)->lpVtbl -> AddRef(This)

#define IDirsyncNamespaceMapper_Release(This)	\
    (This)->lpVtbl -> Release(This)


#define IDirsyncNamespaceMapper_Initialize(This,pSession,pSessionCallback,pSessionManager,syncDirection)	\
    (This)->lpVtbl -> Initialize(This,pSession,pSessionCallback,pSessionManager,syncDirection)

#define IDirsyncNamespaceMapper_MapNamespace(This,pszSourceDN,pszSourceOldDN,ppszTargetDN,ppszTargetOldDN,pszAttribute,pszClass,fTargetIDAvailable)	\
    (This)->lpVtbl -> MapNamespace(This,pszSourceDN,pszSourceOldDN,ppszTargetDN,ppszTargetOldDN,pszAttribute,pszClass,fTargetIDAvailable)

#endif /* COBJMACROS */


#endif 	/* C style interface */



HRESULT STDMETHODCALLTYPE IDirsyncNamespaceMapper_Initialize_Proxy( 
    IDirsyncNamespaceMapper * This,
    /* [in] */ IDirsyncSession *pSession,
    /* [in] */ IDirsyncSessionCallback *pSessionCallback,
    /* [in] */ IDirsyncSessionManager *pSessionManager,
    /* [in] */ SYNCDIRECTION syncDirection);


void __RPC_STUB IDirsyncNamespaceMapper_Initialize_Stub(
    IRpcStubBuffer *This,
    IRpcChannelBuffer *_pRpcChannelBuffer,
    PRPC_MESSAGE _pRpcMessage,
    DWORD *_pdwStubPhase);


HRESULT STDMETHODCALLTYPE IDirsyncNamespaceMapper_MapNamespace_Proxy( 
    IDirsyncNamespaceMapper * This,
    /* [in] */ PWSTR pszSourceDN,
    /* [in] */ PWSTR pszSourceOldDN,
    /* [out] */ PWSTR *ppszTargetDN,
    /* [out] */ PWSTR *ppszTargetOldDN,
    /* [in] */ PWSTR pszAttribute,
    /* [in] */ PWSTR pszClass,
    /* [in] */ BOOL fTargetIDAvailable);


void __RPC_STUB IDirsyncNamespaceMapper_MapNamespace_Stub(
    IRpcStubBuffer *This,
    IRpcChannelBuffer *_pRpcChannelBuffer,
    PRPC_MESSAGE _pRpcMessage,
    DWORD *_pdwStubPhase);



#endif 	/* __IDirsyncNamespaceMapper_INTERFACE_DEFINED__ */


#ifndef __IDirsyncAttributeMapper_INTERFACE_DEFINED__
#define __IDirsyncAttributeMapper_INTERFACE_DEFINED__

/* interface IDirsyncAttributeMapper */
/* [unique][helpstring][uuid][local][object] */ 


EXTERN_C const IID IID_IDirsyncAttributeMapper;

#if defined(__cplusplus) && !defined(CINTERFACE)
    
    MIDL_INTERFACE("1fff291c-413b-11d2-917d-0000f87a92ea")
    IDirsyncAttributeMapper : public IUnknown
    {
    public:
        virtual HRESULT STDMETHODCALLTYPE Initialize( 
            /* [in] */ IDirsyncSession *pSession,
            /* [in] */ IDirsyncSessionCallback *pSessionCallback,
            /* [in] */ IDirsyncSessionManager *pSessionManager,
            /* [in] */ IDirsyncObjectMapper *pObjectMapper,
            /* [in] */ SYNCDIRECTION syncDirection) = 0;
        
        virtual HRESULT STDMETHODCALLTYPE MapAttribute( 
            /* [out][in] */ PDIRSYNCOBJECT pObject,
            /* [out][in] */ PDIRSYNCATTRIBUTE pAttribute) = 0;
        
    };
    
#else 	/* C style interface */

    typedef struct IDirsyncAttributeMapperVtbl
    {
        BEGIN_INTERFACE
        
        HRESULT ( STDMETHODCALLTYPE *QueryInterface )( 
            IDirsyncAttributeMapper * This,
            /* [in] */ REFIID riid,
            /* [iid_is][out] */ void **ppvObject);
        
        ULONG ( STDMETHODCALLTYPE *AddRef )( 
            IDirsyncAttributeMapper * This);
        
        ULONG ( STDMETHODCALLTYPE *Release )( 
            IDirsyncAttributeMapper * This);
        
        HRESULT ( STDMETHODCALLTYPE *Initialize )( 
            IDirsyncAttributeMapper * This,
            /* [in] */ IDirsyncSession *pSession,
            /* [in] */ IDirsyncSessionCallback *pSessionCallback,
            /* [in] */ IDirsyncSessionManager *pSessionManager,
            /* [in] */ IDirsyncObjectMapper *pObjectMapper,
            /* [in] */ SYNCDIRECTION syncDirection);
        
        HRESULT ( STDMETHODCALLTYPE *MapAttribute )( 
            IDirsyncAttributeMapper * This,
            /* [out][in] */ PDIRSYNCOBJECT pObject,
            /* [out][in] */ PDIRSYNCATTRIBUTE pAttribute);
        
        END_INTERFACE
    } IDirsyncAttributeMapperVtbl;

    interface IDirsyncAttributeMapper
    {
        CONST_VTBL struct IDirsyncAttributeMapperVtbl *lpVtbl;
    };

    

#ifdef COBJMACROS


#define IDirsyncAttributeMapper_QueryInterface(This,riid,ppvObject)	\
    (This)->lpVtbl -> QueryInterface(This,riid,ppvObject)

#define IDirsyncAttributeMapper_AddRef(This)	\
    (This)->lpVtbl -> AddRef(This)

#define IDirsyncAttributeMapper_Release(This)	\
    (This)->lpVtbl -> Release(This)


#define IDirsyncAttributeMapper_Initialize(This,pSession,pSessionCallback,pSessionManager,pObjectMapper,syncDirection)	\
    (This)->lpVtbl -> Initialize(This,pSession,pSessionCallback,pSessionManager,pObjectMapper,syncDirection)

#define IDirsyncAttributeMapper_MapAttribute(This,pObject,pAttribute)	\
    (This)->lpVtbl -> MapAttribute(This,pObject,pAttribute)

#endif /* COBJMACROS */


#endif 	/* C style interface */



HRESULT STDMETHODCALLTYPE IDirsyncAttributeMapper_Initialize_Proxy( 
    IDirsyncAttributeMapper * This,
    /* [in] */ IDirsyncSession *pSession,
    /* [in] */ IDirsyncSessionCallback *pSessionCallback,
    /* [in] */ IDirsyncSessionManager *pSessionManager,
    /* [in] */ IDirsyncObjectMapper *pObjectMapper,
    /* [in] */ SYNCDIRECTION syncDirection);


void __RPC_STUB IDirsyncAttributeMapper_Initialize_Stub(
    IRpcStubBuffer *This,
    IRpcChannelBuffer *_pRpcChannelBuffer,
    PRPC_MESSAGE _pRpcMessage,
    DWORD *_pdwStubPhase);


HRESULT STDMETHODCALLTYPE IDirsyncAttributeMapper_MapAttribute_Proxy( 
    IDirsyncAttributeMapper * This,
    /* [out][in] */ PDIRSYNCOBJECT pObject,
    /* [out][in] */ PDIRSYNCATTRIBUTE pAttribute);


void __RPC_STUB IDirsyncAttributeMapper_MapAttribute_Stub(
    IRpcStubBuffer *This,
    IRpcChannelBuffer *_pRpcChannelBuffer,
    PRPC_MESSAGE _pRpcMessage,
    DWORD *_pdwStubPhase);



#endif 	/* __IDirsyncAttributeMapper_INTERFACE_DEFINED__ */


/* interface __MIDL_itf_dirsync_0123 */
/* [local] */ 

//
// Error codes for Dirsync
//

#define FAC_DIRSYNC                     0x07AB

#define E_SESSION_NOT_FOUND             MAKE_HRESULT(SEVERITY_ERROR, FAC_DIRSYNC, 0x0000)
#define E_SESSION_IN_PROGRESS           MAKE_HRESULT(SEVERITY_ERROR, FAC_DIRSYNC, 0x0001)
#define E_SESSION_NOT_IN_PROGRESS       MAKE_HRESULT(SEVERITY_ERROR, FAC_DIRSYNC, 0x0002)
#define E_SESSION_INVALIDDATA           MAKE_HRESULT(SEVERITY_ERROR, FAC_DIRSYNC, 0x0003)
#define E_SESSION_MAXREACHED            MAKE_HRESULT(SEVERITY_ERROR, FAC_DIRSYNC, 0x0004)
#define E_PASSWORD_UNENCRYPTED          MAKE_HRESULT(SEVERITY_ERROR, FAC_DIRSYNC, 0x0005)
#define E_PASSWORD_UNAVAILABLE          MAKE_HRESULT(SEVERITY_ERROR, FAC_DIRSYNC, 0x0006)
#define E_WRITE_CLASSCONFLICT           MAKE_HRESULT(SEVERITY_ERROR, FAC_DIRSYNC, 0x0007)
#define E_WRITE_DUPATTR                 MAKE_HRESULT(SEVERITY_ERROR, FAC_DIRSYNC, 0x0008)
#define E_WRITE_DUPSAMACCOUNT           MAKE_HRESULT(SEVERITY_ERROR, FAC_DIRSYNC, 0x0009)
#define E_DATABASE_CORRUPT              MAKE_HRESULT(SEVERITY_ERROR, FAC_DIRSYNC, 0x000a)
#define E_INITIALIZATION_IN_PROGRESS    MAKE_HRESULT(SEVERITY_ERROR, FAC_DIRSYNC, 0x000b)
#define E_SESSION_FAILEDOBJLIST_FULL    MAKE_HRESULT(SEVERITY_ERROR, FAC_DIRSYNC, 0x000c)
#define E_BACKUP_IN_PROGRESS            MAKE_HRESULT(SEVERITY_ERROR, FAC_DIRSYNC, 0x000d)
#define E_TWOWAYSYNC_RENAME_BEFORE_INIT_ADD     MAKE_HRESULT(SEVERITY_ERROR, FAC_DIRSYNC, 0x000e)
#define E_TWOWAYSYNC_MASTER_HAS_MOVED           MAKE_HRESULT(SEVERITY_ERROR, FAC_DIRSYNC, 0x000f)
#define E_WRITE_ADDED_TO_FAILEDOBJLIST_RETRY    MAKE_HRESULT(SEVERITY_ERROR, FAC_DIRSYNC, 0x0010)
#define E_WRITE_ADDED_TO_FAILEDOBJLIST_NORETRY  MAKE_HRESULT(SEVERITY_ERROR, FAC_DIRSYNC, 0x0011)
#define E_TWOWAYSYNC_MODIFY_BUT_TARGETMOVED     MAKE_HRESULT(SEVERITY_ERROR, FAC_DIRSYNC, 0x0012)



extern RPC_IF_HANDLE __MIDL_itf_dirsync_0123_v0_0_c_ifspec;
extern RPC_IF_HANDLE __MIDL_itf_dirsync_0123_v0_0_s_ifspec;


#ifndef __Dirsync_LIBRARY_DEFINED__
#define __Dirsync_LIBRARY_DEFINED__

/* library Dirsync */
/* [helpstring][version][uuid] */ 


EXTERN_C const IID LIBID_Dirsync;

EXTERN_C const CLSID CLSID_DirsyncServer;

#ifdef __cplusplus

class DECLSPEC_UUID("56374e32-cdba-11d1-a40e-00c04fb950dc")
DirsyncServer;
#endif
#endif /* __Dirsync_LIBRARY_DEFINED__ */

/* Additional Prototypes for ALL interfaces */

/* end of Additional Prototypes */

#ifdef __cplusplus
}
#endif

#endif
=== C:/Users/treeman/Desktop/windows nt source code\Source\Win2K3\NT\public\internal\ds\inc\dnsapi.h ===
/*++

Copyright (c) 1997-2001  Microsoft Corporation

Module Name:

    dnsapi.h

Abstract:

    Domain Name System (DNS)

    DNS Client API Library

Author:

    Jim Gilroy (jamesg)     December 7, 1996

Revision History:

--*/


#ifndef _DNSAPI_INCLUDED_
#define _DNSAPI_INCLUDED_

#ifndef _WINSOCK2API_
#ifndef _WINSOCKAPI_
#include <winsock2.h>
#endif
#endif

#include <windns.h>


#ifdef __cplusplus
extern "C"
{
#endif  // __cplusplus


//
//  Definitions for testing
//

#ifdef  DNS_INTERNAL
#define DNSTEST_BUILD 1   
#endif

//
//  DCR:   add to winerror.h
//

#define DNS_ERROR_REFFERAL_PACKET        9506L


//
//  Handy IP string macro
//

#define IP_STRING( IpAddr )     inet_ntoa( *(struct in_addr *)&(IpAddr) )
#define IP4_STRING( IpAddr )    inet_ntoa( *(struct in_addr *)&(IpAddr) )


//
//  Byte flipping macros
//

#define FlipUnalignedDword( pDword ) \
            (DWORD)ntohl( *(UNALIGNED DWORD *)(pDword) )

#define FlipUnalignedWord( pWord )  \
            (WORD)ntohs( *(UNALIGNED WORD *)(pWord) )

//  Inline is faster, but NO side effects allowed in marco argument

#define InlineFlipUnaligned48Bits( pch )            \
            ( ( *(PUCHAR)(pch)        << 40 ) |     \
              ( *((PUCHAR)(pch) + 1)  << 32 ) |     \
              ( *((PUCHAR)(pch) + 2)  << 24 ) |     \
              ( *((PUCHAR)(pch) + 3)  << 16 ) |     \
              ( *((PUCHAR)(pch) + 4)  <<  8 ) |     \
              ( *((PUCHAR)(pch) + 5)  )     )

#define InlineFlipUnalignedDword( pch )             \
            ( ( *(PUCHAR)(pch)        << 24 ) |     \
              ( *((PUCHAR)(pch) + 1)  << 16 ) |     \
              ( *((PUCHAR)(pch) + 2)  <<  8 ) |     \
              ( *((PUCHAR)(pch) + 3)  )     )

#define InlineFlipUnalignedWord( pch )  \
            ( ((WORD)*((PUCHAR)(pch)) << 8) + (WORD)*((PUCHAR)(pch) + 1) )


//
//  Unaligned write without flipping
//

#define WRITE_UNALIGNED_WORD( pout, word ) \
            ( *(UNALIGNED WORD *)(pout) = word )

#define WRITE_UNALIGNED_DWORD( pout, dword ) \
            ( *(UNALIGNED DWORD *)(pout) = dword )




//
//  DNS_ADDR -- IP4/6 sockaddr union
//
//  DNS_ADDR allows compile and runtime IP4/6 union but also
//  carries sockaddr LENGTH, making it more "object-like" --
//  an annoying ommission from winsock2.
//
//  In addition, this allows the developer to pack in any other
//  desirable context to travel with the address.
//

#define DNS_ADDR_MAX_SOCKADDR_LENGTH         (32)

#ifdef MIDL_PASS
typedef struct _DnsAddr
{
    CHAR        MaxSa[ DNS_ADDR_MAX_SOCKADDR_LENGTH ];
    DWORD       DnsAddrUserDword[8];
}
DNS_ADDR, *PDNS_ADDR;
#else
typedef struct _DnsAddr
{
    union
    {
        SOCKADDR        Sockaddr;
        SOCKADDR_IN     SockaddrIn;
#ifdef _WS2TCPIP_H_
        SOCKADDR_IN6    SockaddrIn6;
#endif
        CHAR            MaxSa[ DNS_ADDR_MAX_SOCKADDR_LENGTH ];
    };

    DWORD       SockaddrLength;

    //  
    //  The remaining structure is user extensible
    //  Define both common uses (some used internally by DNS)
    //  and user extensions.
    //
    //  At least one unique name is defined for every field so
    //  that user can macro to an appropriate name for their application
    //  to produce readable code.
    //

    union
    {
        struct
        {
            DWORD       SubnetLength;
            DWORD       Flags;
            DWORD       Status;
        };
        struct
        {
            DWORD       DnsAddrUser0Dword2;
            DWORD       DnsAddrUser0Dword3;
            DWORD       DnsAddrUser0Dword4;
        };
    };

    //
    //  Last 16 bytes setup with multiple unions to give
    //  user choice of byte, DWORD and pointer fields.
    //
    //  Note that pointer fields are setup to be both 32 and 64 bit
    //  capable.  (A loss of space, but necessary -- otherwise the
    //  structure would balloon beyond 64 bytes in 64-bit architectures.)
    //
    //  Note that obviously any use of pointers will not be "understood"
    //  by MIDL compile or transmitted by RPC.
    //
    
    union
    {
        CHAR    DnsAddrUserBytes[16];

        struct
        {
            DWORD       Priority;
            DWORD       Weight;
            DWORD       Tag;
            DWORD       Reserved;
        };
        struct
        {
            DWORD       DnsAddrUser1Dword1;
            DWORD       DnsAddrUser1Dword2;
            DWORD       DnsAddrUser1Dword3;
            DWORD       DnsAddrUser1Dword4;
        };
        struct
        {
            DWORD       DnsAddrUser2Dword1;
            DWORD       DnsAddrUser2Dword2;
            UINT_PTR    DnsAddrUser2Ptr1;
        };
        struct
        {
            UINT_PTR    DnsAddrUser3Ptr1;
            UINT_PTR    DnsAddrUser3Ptr2;
        };
    };
}
DNS_ADDR, *PDNS_ADDR;
#endif

//
//  DNS_ADDR macros
//

#define SOCKADDR_IS_IP4( pSa )      ( (pSa)->sa_family == AF_INET )
#define SOCKADDR_IS_IP6( pSa )      ( (pSa)->sa_family == AF_INET6 )
#define SOCKADDR_IS_ATM( pSa )      ( (pSa)->sa_family == AF_ATM )

#define DNS_ADDR_IS_IP4( pA )       SOCKADDR_IS_IP4( &(pA)->Sockaddr )
#define DNS_ADDR_IS_IP6( pA )       SOCKADDR_IS_IP6( &(pA)->Sockaddr )

#define DNS_ADDR_IP4_STRING( p )    inet_ntoa( (p)->SockaddrIn.sin_addr )
#define DNS_ADDR_IP6_STRING( p )    IPADDR_STRING( (p)->SockaddrIn6.sin6_addr )

#define DNS_ADDR_IP_STRING_BUFFER_LENGTH     (64)
#define DNS_ADDR_STRING_BUFFER_LENGTH        (128)


//
//  DNS_ADDR_ARRAY
//
//  This is a flat array of DNS_ADDRs
//      - MaxCount is the memory size count of DNS_ADDRs
//      - AddrCount is the in-use count of DNS_ADDRs
//

#ifdef MIDL_PASS
typedef struct _DnsAddrArray
{
    DWORD           MaxCount;
    DWORD           AddrCount;
    DWORD           Tag;
    WORD            Family;
    WORD            WordReserved;
    DWORD           Flags;
    DWORD           MatchFlag;
    DWORD           Reserved1;
    DWORD           Reserved2;

    [size_is( AddrCount )]  DNS_ADDR    AddrArray[];
}
DNS_ADDR_ARRAY, *PDNS_ADDR_ARRAY;
#else
typedef struct _DnsAddrArray
{
    DWORD           MaxCount;
    DWORD           AddrCount;
    DWORD           Tag;
    WORD            Family;
    WORD            WordReserved;
    DWORD           Flags;
    DWORD           MatchFlag;
    DWORD           Reserved1;
    DWORD           Reserved2;

    DNS_ADDR        AddrArray[1];
}
DNS_ADDR_ARRAY, *PDNS_ADDR_ARRAY;
#endif




//
//  Non-wrapping seconds timer (timer.c)
//

DWORD
GetCurrentTimeInSeconds(
    VOID
    );


//
//  General DNS utilities (dnsutil.c)
//

PSTR 
_fastcall
DnsGetDomainName(
    IN  PSTR    pszName
    );

PSTR 
_fastcall
DnsStatusString(
    IN  DNS_STATUS  Status
    );

#define DnsStatusToErrorString_A(status)    DnsStatusString(status)

DNS_STATUS
_fastcall
DnsMapRcodeToStatus(
    IN  BYTE    ResponseCode
    );

BYTE
_fastcall
DnsIsStatusRcode(
    IN  DNS_STATUS  Status
    );



//
//  DNS network config structures
//

#define DNSINFO_FLAG_IS_WAN_ADAPTER             (0x00000002)
#define DNSINFO_FLAG_IS_AUTONET_ADAPTER         (0x00000004)
#define DNSINFO_FLAG_IS_DHCP_CFG_ADAPTER        (0x00000008)
#define DNSINFO_FLAG_REG_ADAPTER_DOMAIN_NAME    (0x00000010)
#define DNSINFO_FLAG_REG_ADAPTER_ADDRESSES      (0x00000020)


typedef struct
{
    PSTR                pszAdapterGuidName;
    PSTR                pszAdapterDomain;
    PDNS_ADDR_ARRAY     pIpAddrs;
    PDNS_ADDR_ARRAY     pDnsAddrs;
    DWORD               Flags;
    DWORD               InterfaceIndex;
}
DNS_ADAPTER_INFOA, *PDNS_ADAPTER_INFOA;

typedef struct
{
    PWSTR               pszAdapterGuidName;
    PWSTR               pszAdapterDomain;
    PDNS_ADDR_ARRAY     pIpAddrs;
    PDNS_ADDR_ARRAY     pDnsAddrs;
    DWORD               Flags;
    DWORD               InterfaceIndex;
}
DNS_ADAPTER_INFOW, *PDNS_ADAPTER_INFOW;


typedef struct
{
    PSTR            pszPrimaryDomainName;
    DWORD           NameCount;
    PSTR            SearchNameArray[1];
}
DNS_SEARCH_LISTA, *PDNS_SEARCH_LISTA;

typedef struct
{
    PWSTR           pszPrimaryDomainName;
    DWORD           NameCount;
    PWSTR           SearchNameArray[1];
}
DNS_SEARCH_LISTW, *PDNS_SEARCH_LISTW;


typedef struct
{
    PSTR                pszHostName;
    PSTR                pszPrimaryDomainName;
    PDNS_SEARCH_LISTA   pSearchList;
    DWORD               Flags;
    DWORD               AdapterCount;
    DNS_ADAPTER_INFOA   AdapterArray[1];
}
DNS_NETWORK_INFOA, *PDNS_NETWORK_INFOA;

typedef struct
{
    PWSTR               pszHostName;
    PWSTR               pszPrimaryDomainName;
    PDNS_SEARCH_LISTW   pSearchList;
    DWORD               Flags;
    DWORD               AdapterCount;
    DNS_ADAPTER_INFOW   AdapterArray[1];
}
DNS_NETWORK_INFOW, *PDNS_NETWORK_INFOW;


#ifdef UNICODE
typedef DNS_ADAPTER_INFOW   DNS_ADAPTER_INFO,   *PDNS_ADAPTER_INFO;
typedef DNS_SEARCH_LISTW    DNS_SEARCH_LIST,    *PDNS_SEARCH_LIST;
typedef DNS_NETWORK_INFOW   DNS_NETWORK_INFO,   *PDNS_NETWORK_INFO;
#else
typedef DNS_ADAPTER_INFOW   DNS_ADAPTER_INFO,   *PDNS_ADAPTER_INFO;
typedef DNS_SEARCH_LISTW    DNS_SEARCH_LIST,    *PDNS_SEARCH_LIST;
typedef DNS_NETWORK_INFOW   DNS_NETWORK_INFO,   *PDNS_NETWORK_INFO;
#endif


//
//  Limit fixed search list (for network config dialogs)
//

#define DNS_MAX_SEARCH_LIST_ENTRIES     (50)




//
//  Old public structures
//      DNS_NETWORK_INFORMATION
//      DNS_SEARCH_INFORMATION
//      DNS_ADAPTER_INFORMATION 
//  structures
//
//  Do NOT code to these
//

//#ifdef  DNSAPI_BACKCOMPAT
#if 0
#define NETINFO_FLAG_IS_WAN_ADAPTER             DNSINFO_FLAG_IS_WAN_ADAPTER         
#define NETINFO_FLAG_IS_AUTONET_ADAPTER         DNSINFO_FLAG_IS_AUTONET_ADAPTER     
#define NETINFO_FLAG_IS_DHCP_CFG_ADAPTER        DNSINFO_FLAG_IS_DHCP_CFG_ADAPTER    
#define NETINFO_FLAG_REG_ADAPTER_DOMAIN_NAME    DNSINFO_FLAG_REG_ADAPTER_DOMAIN_NAME
#define NETINFO_FLAG_REG_ADAPTER_ADDRESSES      DNSINFO_FLAG_REG_ADAPTER_ADDRESSES  
#endif


typedef struct
{
    IP4_ADDRESS     ipAddress;
    DWORD           Priority;
}
DNS_SERVER_INFORMATION, *PDNS_SERVER_INFORMATION;

typedef struct
{
    PSTR                    pszAdapterGuidName;
    PSTR                    pszDomain;
    PIP4_ARRAY              pIPAddresses;
    PIP4_ARRAY              pIPSubnetMasks;
    DWORD                   InfoFlags;
    DWORD                   cServerCount;
    DNS_SERVER_INFORMATION  aipServers[1];
}
DNS_ADAPTER_INFORMATION, *PDNS_ADAPTER_INFORMATION;

typedef struct
{
    PSTR                pszPrimaryDomainName;
    DWORD               cNameCount;
    PSTR                aSearchListNames[1];
}
DNS_SEARCH_INFORMATION, *PDNS_SEARCH_INFORMATION;

typedef struct
{
    PDNS_SEARCH_INFORMATION     pSearchInformation;
    DWORD                       cAdapterCount;
    PDNS_ADAPTER_INFORMATION    aAdapterInfoList[1];
}
DNS_NETWORK_INFORMATION, *PDNS_NETWORK_INFORMATION;


#ifdef  DNSAPI_BACKCOMPAT
#define NAME_SERVER_INFORMATION     DNS_SERVER_INFORMATION
#define PNAME_SERVER_INFORMATION    PDNS_SERVER_INFORMATION

#define ADAPTER_INFORMATION         DNS_ADAPTER_INFORMATION
#define PADAPTER_INFORMATION        PDNS_ADAPTER_INFORMATION

#define SEARCH_INFORMATION          DNS_SEARCH_INFORMATION
#define PSEARCH_INFORMATION         PDNS_SEARCH_INFORMATION

#define NETWORK_INFORMATION         DNS_NETWORK_INFORMATION
#define PNETWORK_INFORMATION        PDNS_NETWORK_INFORMATION
#endif




//
//  Resource record type utilities (record.c)
//

BOOL
_fastcall
DnsIsAMailboxType(
    IN  WORD    wType
    );

WORD
DnsRecordTypeForName(
    IN  PCHAR   pszName,
    IN  INT     cchNameLength
    );

PCHAR
DnsRecordStringForType(
    IN  WORD    wType
    );

PCHAR
DnsRecordStringForWritableType(
    IN  WORD    wType
    );

BOOL
DnsIsStringCountValidForTextType(
    IN  WORD    wType,
    IN  WORD    StringCount
    );

BOOL
DnsIpv6StringToAddress(
    OUT     PIP6_ADDRESS    pAddress,
    IN      PCHAR           pchString,
    IN      DWORD           dwStringLength
    );

VOID
DnsIpv6AddressToString(
    OUT     PCHAR           pchString,
    IN      PIP6_ADDRESS    pAddress
    );


//
//  Record building (rralloc.c)
//

PDNS_RECORD
WINAPI
DnsAllocateRecord(
    IN      WORD        wBufferLength
    );

PDNS_RECORD
DnsCreatePtrRecord(
    IN      IP4_ADDRESS     IpAddress,
    IN      LPTSTR          pszHostName,
    IN      BOOL            fUnicodeName
    );


//
//  Record build from data strings (rrbuild.c)
//

PDNS_RECORD
DnsRecordBuild_UTF8(
    IN OUT  PDNS_RRSET      pRRSet,
    IN      PSTR            pszOwner,
    IN      WORD            wType,
    IN      BOOL            fAdd,
    IN      UCHAR           Section,
    IN      INT             Argc,
    IN      PCHAR *         Argv
    );

PDNS_RECORD
DnsRecordBuild_W(
    IN OUT  PDNS_RRSET      pRRSet,
    IN      PWSTR           pszOwner,
    IN      WORD            wType,
    IN      BOOL            fAdd,
    IN      UCHAR           Section,
    IN      INT             Argc,
    IN      PWCHAR *        Argv
    );



//
//  Parsing
//

#ifdef PDNS_PARSED_MESSAGE
#undef PDNS_PARSED_MESSAGE
#endif

typedef struct _DnsParseMessage
{
    DNS_STATUS      Status;
    DNS_CHARSET     CharSet;

    DNS_HEADER      Header;

    WORD            QuestionType;
    WORD            QuestionClass;
    PTSTR           pQuestionName;

    PDNS_RECORD     pAnswerRecords;
    PDNS_RECORD     pAliasRecords;
    PDNS_RECORD     pAuthorityRecords;
    PDNS_RECORD     pAdditionalRecords;
    PDNS_RECORD     pSigRecords;
}
DNS_PARSED_MESSAGE, *PDNS_PARSED_MESSAGE;


#define DNS_PARSE_FLAG_NO_QUESTION      (0x00000001)
#define DNS_PARSE_FLAG_NO_ANSWER        (0x00000002)
#define DNS_PARSE_FLAG_NO_AUTHORITY     (0x00000004)
#define DNS_PARSE_FLAG_NO_ADDITIONAL    (0x00000008)
#define DNS_PARSE_FLAG_NO_SIG           (0x00000100)
#define DNS_PARSE_FLAG_NO_KEY           (0x00000200)

#define DNS_PARSE_FLAG_NO_DATA          (0x0000030f)
#define DNS_PARSE_FLAG_NO_RECORDS       (0x0000030e)
#define DNS_PARSE_FLAG_NO_DNSSEC        (0x00000300)

#define DNS_PARSE_FLAG_ONLY_QUESTION    (0x01000000)
#define DNS_PARSE_FLAG_RCODE_ALL        (0x02000000)



DNS_STATUS
Dns_ParseMessage(
    OUT     PDNS_PARSED_MESSAGE pParse,
    IN      PDNS_MESSAGE_BUFFER pDnsBuffer,
    IN      WORD                wMessageLength,
    IN      DWORD               Flags,
    IN      DNS_CHARSET         CharSet
    );



//
//  Extra info to query and update
//

//
//  Results in sockaddr format
//

#define DNS_MAX_ALIAS_COUNT     (8)

typedef struct _DnsSockaddrResults
{
    PWSTR               pName;
    PDNS_ADDR_ARRAY     pAddrArray;
    PVOID               pHostent;
    DWORD               AliasCount;
    DWORD               Reserved;
    PWSTR               AliasArray[ DNS_MAX_ALIAS_COUNT ];
}
DNS_SOCKADDR_RESULTS, *PDNS_SOCKADDR_RESULTS;


//
//  Basic results for logging\eventing
//

typedef struct _DnsBasicResults
{
    DNS_STATUS      Status;
    WORD            Rcode;
    DNS_ADDR        ServerAddr;
}
DNS_RESULTS_BASIC, *PDNS_RESULTS_BASIC;


//
//  Extra info format
//

#define DNS_MAX_PRIVATE_EXTRA_INFO_SIZE (72)

typedef struct _DnsExtraInfo
{
    PVOID           pNext;
    DWORD           Id;
                        
    union
    {
        CHAR        Flat[DNS_MAX_PRIVATE_EXTRA_INFO_SIZE];

        //
        //  results
        //

        struct
        {
            DNS_STATUS      Status;
            WORD            Rcode;
            IP4_ADDRESS     ServerIp4;
            IP6_ADDRESS     ServerIp6;
        }
        ResultsV1;

        DNS_RESULTS_BASIC       ResultsBasic;

        DNS_SOCKADDR_RESULTS    SaResults;

        //
        //  server info inputs
        //

        PDNS_ADDR_ARRAY     pServerList;
        PIP4_ARRAY          pServerList4;
    };
}
DNS_EXTRA_INFO, *PDNS_EXTRA_INFO;


#define DNS_EXINFO_ID_RESULTS_V1            (1)
#define DNS_EXINFO_ID_RESULTS_BASIC         (2)
#define DNS_EXINFO_ID_SOCKADDR_RESULTS      (3)

#define DNS_EXINFO_ID_SERVER_LIST           (10)
#define DNS_EXINFO_ID_SERVER_LIST_IP4       (11)



//
//  Query
//

//
//  Flags NOT in windns.h
//

#define DNS_QUERY_ACCEPT_PARTIAL_UDP        DNS_QUERY_ACCEPT_TRUNCATED_RESPONSE
#define DNS_QUERY_MULTICAST_ONLY            0x00040000
#define DNS_QUERY_USE_QUICK_TIMEOUTS        0x00080000

//  Exposed in Win2K SDK -- deprecated

#define DNS_QUERY_ALLOW_EMPTY_AUTH_RESP     0x00010000



//
//  Extended query
//

typedef struct _DnsQueryInfo
{
    DWORD               Size;
    DWORD               Version;
    LPTSTR              pName;
    WORD                Type;
    WORD                Rcode;
    DWORD               Flags;
    DNS_STATUS          Status;
    DNS_CHARSET         CharSet;

    PDNS_RECORD         pAnswerRecords;
    PDNS_RECORD         pAliasRecords;
    PDNS_RECORD         pAdditionalRecords;
    PDNS_RECORD         pAuthorityRecords;

    HANDLE              hEvent;
    PDNS_EXTRA_INFO     pExtraInfo;

    PVOID               pServerList;
    PIP4_ARRAY          pServerListIp4;

    PVOID               pMessage;
    PVOID               pReservedName;
}
DNS_QUERY_INFO, *PDNS_QUERY_INFO;


DNS_STATUS
WINAPI
DnsQueryExW(
    IN OUT  PDNS_QUERY_INFO pQueryInfo
    );
     
DNS_STATUS
WINAPI
DnsQueryExA(
    IN OUT  PDNS_QUERY_INFO pQueryInfo
    );

DNS_STATUS
WINAPI
DnsQueryExUTF8(
    IN OUT  PDNS_QUERY_INFO pQueryInfo
    );

#ifdef UNICODE
#define DnsQueryEx  DnsQueryExW
#else
#define DnsQueryEx  DnsQueryExA
#endif



//
// Options for DnsCheckNameCollision
//

#define DNS_CHECK_AGAINST_HOST_ANY              0x00000000
#define DNS_CHECK_AGAINST_HOST_ADDRESS          0x00000001
#define DNS_CHECK_AGAINST_HOST_DOMAIN_NAME      0x00000002


DNS_STATUS WINAPI
DnsCheckNameCollision_A(
    IN      PCSTR           pszName,
    IN      DWORD           fOptions
    );

DNS_STATUS WINAPI
DnsCheckNameCollision_UTF8(
    IN      PCSTR           pszName,
    IN      DWORD           fOptions
    );

DNS_STATUS WINAPI
DnsCheckNameCollision_W(
    IN      PCWSTR          pszName,
    IN      DWORD           fOptions
    );

#ifdef UNICODE
#define DnsDnsCheckNameCollision DnsCheckNameCollision_W
#else
#define DnsDnsCheckNameCollision DnsCheckNameCollision_A
#endif



//
//  DNS Update API
//

//
//  Update flags NOT in windns.h
//

#define DNS_UPDATE_SECURITY_CHOICE_MASK     0x000001ff


DNS_STATUS
WINAPI
DnsUpdateTest_A(
    IN      HANDLE          hContextHandle OPTIONAL,
    IN      PCSTR           pszName,
    IN      DWORD           fOptions,
    IN      PIP4_ARRAY      aipServers  OPTIONAL
    );

DNS_STATUS
WINAPI
DnsUpdateTest_UTF8(
    IN      HANDLE          hContextHandle OPTIONAL,
    IN      PCSTR           pszName,
    IN      DWORD           fOptions,
    IN      PIP4_ARRAY      aipServers  OPTIONAL
    );

DNS_STATUS
WINAPI
DnsUpdateTest_W(
    IN      HANDLE          hContextHandle OPTIONAL,
    IN      PCWSTR          pszName,
    IN      DWORD           fOptions,
    IN      PIP4_ARRAY      aipServers OPTIONAL
    );

#ifdef UNICODE
#define DnsUpdateTest DnsUpdateTest_W
#else
#define DnsUpdateTest DnsUpdateTest_A
#endif



//
//  DNS Update API for DHCP client
//

typedef struct  _REGISTER_HOST_ENTRY
{
     union
     {
         IP4_ADDRESS    ipAddr;
         IP6_ADDRESS    ipV6Addr;
     } Addr;
     DWORD       dwOptions;
}
REGISTER_HOST_ENTRY, *PREGISTER_HOST_ENTRY;

//
//  Options for above
//

#define REGISTER_HOST_A             0x00000001
#define REGISTER_HOST_PTR           0x00000002
#define REGISTER_HOST_AAAA          0x00000008
#define REGISTER_HOST_RESERVED      0x80000000  // Not used


//
// DNS DHCP Client registration flags
//

#define DYNDNS_REG_FWD      0x0
#define DYNDNS_REG_PTR      0x8
#define DYNDNS_REG_RAS      0x10
#define DYNDNS_DEL_ENTRY    0x20


typedef struct  _REGISTER_HOST_STATUS
{
     HANDLE      hDoneEvent;
     DWORD       dwStatus;
}
REGISTER_HOST_STATUS, *PREGISTER_HOST_STATUS;

DNS_STATUS
WINAPI
DnsDhcpRegisterInit(
    VOID
    );

DNS_STATUS
WINAPI
DnsDhcpRegisterTerm(
   VOID
   );

DNS_STATUS
WINAPI
DnsDhcpRemoveRegistrations(
   VOID
   );

DNS_STATUS
WINAPI
DnsDhcpRegisterHostAddrs(
    IN  PWSTR                   pwsAdapterName,
    IN  PWSTR                   pwsHostName,
    IN  PREGISTER_HOST_ENTRY    pHostAddrs,
    IN  DWORD                   dwHostAddrCount,
    IN  PIP4_ADDRESS            pipDnsServerList,
    IN  DWORD                   dwDnsServerCount,
    IN  PWSTR                   pwsDomainName,
    IN  PREGISTER_HOST_STATUS   pRegisterStatus,
    IN  DWORD                   dwTTL,
    IN  DWORD                   dwFlags
    );

#ifdef XP_BACKCOMPAT
#define DnsAsyncRegisterInit(p)     DnsDhcpRegisterInit()
#define DnsAsyncRegisterTerm()      DnsDhcpRegisterTerm()
#define DnsRemoveRegistrations()    DnsDhcpRemoveRegistrations()
#define DnsAsyncRegisterHostAddrs(a,b,c,d,e,f,g,h,i) \
        DnsDhcpRegisterHostAddrs(a,b,c,d,e,f,g,h,i)
#endif



//
//  DNS Update API for DHCP server.
//

//
//  Call back function. DHCP Server will pass a function to
//  DnsDhcpRegisterHostName and this will be called on successful
//  or unsuccessful completion of the task
//  If we have a condition like server down/try again later etc we
//  won't respond until we have an authoritative answer.
//

typedef VOID(*DHCP_CALLBACK_FN)(DWORD dwStatus, LPVOID pvData);

//
//  Callback return codes
//

#define     DNSDHCP_SUCCESS         0x0
#define     DNSDHCP_FWD_FAILED      0x1
#define     DNSDHCP_SUPERCEDED      0x2

#define     DNSDHCP_FAILURE         (DWORD)-1 //reverse failed


//
// DNS DHCP Server registration function flags
//

#define     DYNDNS_DELETE_ENTRY     0x1
#define     DYNDNS_ADD_ENTRY        0x2
#define     DYNDNS_REG_FORWARD      0x4


typedef struct _DnsCredentials
{
    PWSTR   pUserName;
    PWSTR   pDomain;
    PWSTR   pPassword;
}
DNS_CREDENTIALS, *PDNS_CREDENTIALS;
             

DNS_STATUS
WINAPI
DnsDhcpSrvRegisterInit(
    IN      PDNS_CREDENTIALS    pCredentials,
    IN      DWORD               MaxQueueSize
    );

DNS_STATUS
WINAPI
DnsDhcpSrvRegisterTerm(
    VOID
    );

DNS_STATUS
WINAPI
DnsDhcpSrvRegisterHostName(
    IN  REGISTER_HOST_ENTRY HostAddr,
    IN  PWSTR               pwsName,
    IN  DWORD               dwTTL,
    IN  DWORD               dwFlags,
    IN  DHCP_CALLBACK_FN    pfnDhcpCallBack,
    IN  PVOID               pvData,
    IN  PIP4_ADDRESS        pipDnsServerList OPTIONAL,
    IN  DWORD               dwDnsServerCount
    );

#define RETRY_TIME_SERVER_FAILURE        5*60  // 5 minutes
#define RETRY_TIME_TRY_AGAIN_LATER       5*60  // 5 minutes
#define RETRY_TIME_TIMEOUT               5*60  // 5 minutes

#define RETRY_TIME_MAX                   10*60 // back off to 10 mins if
                                               // repeated failures occur



//
//  Memory allocation
//
//  Many dnsapi.dll routines allocate memory.
//  This memory allocation defaults to routines that use:
//      - LocalAlloc,
//      - LocalReAlloc,
//      - LocalFree.
//  If you desire alternative memory allocation mechanisms, use this
//  function to override the DNS API defaults.  All memory returned by dnsapi.dll
//  can then be freed with the specified free function.
//

typedef PVOID (* DNS_ALLOC_FUNCTION)();
typedef PVOID (* DNS_REALLOC_FUNCTION)();
typedef VOID (* DNS_FREE_FUNCTION)();

VOID
DnsApiHeapReset(
    IN  DNS_ALLOC_FUNCTION      pAlloc,
    IN  DNS_REALLOC_FUNCTION    pRealloc,
    IN  DNS_FREE_FUNCTION       pFree
    );


//
//  Modules using DNSAPI memory should use these routines if
//  they are capable of being called by a process that resets
//  the dnsapi.dll heap.  (Example:  the DNS server.)
//

PVOID
DnsApiAlloc(
    IN      INT             iSize
    );

PVOID
DnsApiRealloc(
    IN OUT  PVOID           pMem,
    IN      INT             iSize
    );

VOID
DnsApiFree(
    IN OUT  PVOID           pMem
    );



//
//  String utilities (string.c)
//
//  Note some of these require memory allocation, see note
//  on memory allocation below.
//

PSTR 
DnsCreateStringCopy(
    IN      PCHAR       pchString,
    IN      DWORD       cchString
    );

DWORD
DnsGetBufferLengthForStringCopy(
    IN      PCHAR       pchString,
    IN      DWORD       cchString,
    IN      BOOL        fUnicodeIn,
    IN      BOOL        fUnicodeOut
    );

PVOID
DnsCopyStringEx(
    OUT     PBYTE       pBuffer,
    IN      PCHAR       pchString,
    IN      DWORD       cchString,
    IN      BOOL        fUnicodeIn,
    IN      BOOL        fUnicodeOut
    );

PVOID
DnsStringCopyAllocateEx(
    IN      PCHAR       pchString,
    IN      DWORD       cchString,
    IN      BOOL        fUnicodeIn,
    IN      BOOL        fUnicodeOut
    );

DWORD
DnsNameCopy(
    OUT     PBYTE           pBuffer,
    IN OUT  PDWORD          pdwBufLength,
    IN      PCHAR           pchString,
    IN      DWORD           cchString,
    IN      DNS_CHARSET     CharSetIn,
    IN      DNS_CHARSET     CharSetOut
    );

PVOID
DnsNameCopyAllocate(
    IN      PCHAR           pchString,
    IN      DWORD           cchString,
    IN      DNS_CHARSET     CharSetIn,
    IN      DNS_CHARSET     CharSetOut
    );

PCHAR
DnsWriteReverseNameStringForIpAddress(
    OUT     PCHAR           pBuffer,
    IN      IP4_ADDRESS     IpAddress
    );

PCHAR
DnsCreateReverseNameStringForIpAddress(
    IN      IP4_ADDRESS     IpAddress
    );



//
//  Name validation
//
//  Routines are in windns.h
//

//
//  Macro away old routines
//

#define DnsValidateDnsName_UTF8(pname)  \
        DnsValidateName_UTF8( (pname), DnsNameDomain )

#define DnsValidateDnsName_W(pname) \
        DnsValidateName_W( (pname), DnsNameDomain )


//
//  Name checking -- server name checking levels
//
//  DCR_CLEANUP:   server name checking levels move to dnsrpc.h?
//      but server will need to convert to some flag
//      ammenable to downcase\validate routine
//
//  DCR:  server name checking:  perhaps lay out additional detail now?
//      or limit to RFC, MS-extended, ALL-binary
//
//  DCR:  server name checking:  perhaps convert to enum type;
//      I don't think we should do bitfields here, rather
//      have enum type map to bitfields if that's the best
//      way to implement underlying check.
//

#define DNS_ALLOW_RFC_NAMES_ONLY    (0)
#define DNS_ALLOW_NONRFC_NAMES      (1)
#define DNS_ALLOW_MULTIBYTE_NAMES   (2)
#define DNS_ALLOW_ALL_NAMES         (3)



//
//  DNS Name compare
//
//  ANSI and unicode names compare routines are in windns.h.
//

BOOL
WINAPI
DnsNameCompare_UTF8(
    IN      PSTR        pName1,
    IN      PSTR        pName2
    );


//
//  Extended name compare
//  Includes determination of name heirarchy.
//
//  Note:  once sort out RelationalCompare issue,
//      better to make Equal == 0;
//      this simplifies macroing regular NameCompare
//      into a single function;
//

typedef enum _DnsNameCompareStatus
{
   DnsNameCompareNotEqual,
   DnsNameCompareEqual,
   DnsNameCompareLeftParent,
   DnsNameCompareRightParent,
   DnsNameCompareInvalid
}
DNS_NAME_COMPARE_STATUS, *PDNS_NAME_COMPARE_STATUS;

DNS_NAME_COMPARE_STATUS
DnsNameCompareEx_W(
    IN      LPCWSTR         pszLeftName,
    IN      LPCWSTR         pszRightName,
    IN      DWORD           dwReserved
    );

DNS_NAME_COMPARE_STATUS
DnsNameCompareEx_A(
    IN      LPCSTR          pszLeftName,
    IN      LPCSTR          pszRightName,
    IN      DWORD           dwReserved
    );

DNS_NAME_COMPARE_STATUS
DnsNameCompareEx_UTF8(
    IN      LPCSTR          pszLeftName,
    IN      LPCSTR          pszRightName,
    IN      DWORD           dwReserved
    );


//
//  Other string routines
//

DNS_STATUS
DnsValidateDnsString_UTF8(
    IN      LPCSTR      pszName
    );

DNS_STATUS
DnsValidateDnsString_W(
    IN      LPCWSTR     pszName
    );

PSTR 
DnsCreateStandardDnsNameCopy(
    IN      PCHAR       pchName,
    IN      DWORD       cchName,
    IN      DWORD       dwFlag
    );

DWORD
DnsDowncaseDnsNameLabel(
    OUT     PCHAR       pchResult,
    IN      PCHAR       pchLabel,
    IN      DWORD       cchLabel,
    IN      DWORD       dwFlags
    );

DWORD
_fastcall
DnsUnicodeToUtf8(
    IN      PWCHAR      pwUnicode,
    IN      DWORD       cchUnicode,
    OUT     PCHAR       pchResult,
    IN      DWORD       cchResult
    );

DWORD
_fastcall
DnsUtf8ToUnicode(
    IN      PCHAR       pchUtf8,
    IN      DWORD       cchUtf8,
    OUT     PWCHAR      pwResult,
    IN      DWORD       cwResult
    );

DNS_STATUS
DnsValidateUtf8Byte(
    IN      BYTE        chUtf8,
    IN OUT  PDWORD      pdwTrailCount
    );



//
//  Service control
//

//
//  DNS server startup service control event.
//
//  Services (ex. netlogon) that want notification of DNS server start
//  need to register to get notification of this user defined control code.
//

#define SERVICE_CONTROL_DNS_SERVER_START (200)


//
//  Resolver service
//
//  General "wake-up-something-has-changed" call.
//  This was put in for cluster team to alert us to plumbing new
//  addresses.  Later we will move to model of picking up
//  these changes ourselves.
//  

VOID
DnsNotifyResolver(
    IN      DWORD           Flag,
    IN      PVOID           pReserved
    );

VOID
DnsNotifyResolverEx(
    IN      DWORD           Id,
    IN      DWORD           Flag,
    IN      DWORD           Cookie,
    IN      PVOID           pReserved
    );

//
//  Cluster mappings
//

#define DNS_CLUSTER_ADD             (0)
#define DNS_CLUSTER_DELETE_NAME     (1)
#define DNS_CLUSTER_DELETE_IP       (2)

DNS_STATUS
DnsRegisterClusterAddress(
    IN      DWORD           Tag,
    IN      PWSTR           pwsName,
    IN      PSOCKADDR       pSockaddr,
    IN      DWORD           Flag
    );

//   Remove once cluster upgraded
VOID
DnsNotifyResolverClusterIp(
    IN      IP4_ADDRESS     ClusterIp,
    IN      BOOL            fAdd
    );


//
//  Routines to clear all cached entries in the DNS Resolver Cache, this is
//  called by ipconfig /flushdns, and add record sets to the cache.
//

BOOL WINAPI
DnsFlushResolverCache(
    VOID
    );

BOOL WINAPI
DnsFlushResolverCacheEntry_W(
    IN  PWSTR  pszName
    );

BOOL WINAPI
DnsFlushResolverCacheEntry_UTF8(
    IN  PSTR  pszName
    );

BOOL WINAPI
DnsFlushResolverCacheEntry_A(
    IN  PSTR  pszName
    );

#ifdef UNICODE
#define DnsFlushResolverCacheEntry DnsFlushResolverCacheEntry_W
#else
#define DnsFlushResolverCacheEntry DnsFlushResolverCacheEntry_A
#endif


DNS_STATUS WINAPI
DnsCacheRecordSet_W(
    IN     PWSTR       lpstrName,
    IN     WORD        wType,
    IN     DWORD       fOptions,
    IN OUT PDNS_RECORD pRRSet
    );


//
//  DO NOT USE!!! -- This is weak, i just haven't tested the replacement yet.
//
//  Routine to read the contents of the DNS Resolver Cache. The resulting
//  table contains a list of record names and types stored in the cache.
//  Each of these name/type records can be queried with DnsQuery with the
//  option DNS_QUERY_CACHE_ONLY.
//
//  Note: this is used in ipconfig for /displaydns.  Can not pull until fixed.
//

typedef struct _DNS_CACHE_TABLE_
{
    struct _DNS_CACHE_TABLE_ * pNext;
    PWSTR                      Name;
    WORD                       Type1;
    WORD                       Type2;
    WORD                       Type3;
}
DNS_CACHE_TABLE, *PDNS_CACHE_TABLE;

BOOL
WINAPI
DnsGetCacheDataTable(
    OUT PDNS_CACHE_TABLE * pTable
    );




//
//  Config info
//

//
//  Alloc flag types for DnsQueryConfig()
//
//  DCR:  move to windns.h if supported
//

#define DNS_CONFIG_FLAG_LOCAL_ALLOC     (DNS_CONFIG_FLAG_ALLOC)
#define DNS_CONFIG_FLAG_DNSAPI_ALLOC    (DNS_CONFIG_FLAG_ALLOC+1)

//
//  System public config -- not available in SDK
//  This is stuff for
//      - config UI
//      - ipconfig
//      - test code
//

//  These are simply hidden from public until ready

#define DnsConfigDnsServers             ((DNS_CONFIG_TYPE) 0x00001030)
#define DnsConfigDnsServersIp4          ((DNS_CONFIG_TYPE) 0x00001031)
#define DnsConfigDnsServersIp6          ((DNS_CONFIG_TYPE) 0x00001032)

//  Above SystemBase ID, they are unavailable to public routine

#define DnsConfigSystemBase             ((DNS_CONFIG_TYPE) 0x00010000)

#define DnsConfigNetworkInformation     ((DNS_CONFIG_TYPE) 0x00010001)
#define DnsConfigAdapterInformation     ((DNS_CONFIG_TYPE) 0x00010002)
#define DnsConfigSearchInformation      ((DNS_CONFIG_TYPE) 0x00010003)

#define DnsConfigRegistrationEnabled    ((DNS_CONFIG_TYPE) 0x00010010)
#define DnsConfigWaitForNameErrorOnAll  ((DNS_CONFIG_TYPE) 0x00010011)

#define DnsConfigLocalAddrs             ((DNS_CONFIG_TYPE) 0x00010020)
#define DnsConfigLocalAddrsIp4          ((DNS_CONFIG_TYPE) 0x00010021)
#define DnsConfigLocalAddrsIp6          ((DNS_CONFIG_TYPE) 0x00010022)

#define DnsConfigNetworkInfoA           ((DNS_CONFIG_TYPE) 0x00010031)
#define DnsConfigAdapterInfoA           ((DNS_CONFIG_TYPE) 0x00010032)
#define DnsConfigSearchListA            ((DNS_CONFIG_TYPE) 0x00010033)

#define DnsConfigNetworkInfoW           ((DNS_CONFIG_TYPE) 0x00010141)
#define DnsConfigAdapterInfoW           ((DNS_CONFIG_TYPE) 0x00010142)
#define DnsConfigSearchListW            ((DNS_CONFIG_TYPE) 0x00010143)

#define DnsConfigDwordGlobals           ((DNS_CONFIG_TYPE) 0x00010200)


//  backcompat

//  still get IP4_ARRAY in mswsock myhostent() routines

#define DnsConfigIp4AddressArray        ((DNS_CONFIG_TYPE) 0x00010004)

//  old network info definitions





PVOID
WINAPI
DnsQueryConfigAllocEx(
    IN      DNS_CONFIG_TYPE     Config,
    IN      PWSTR               pwsAdapterName,
    IN      BOOL                fLocalAlloc
    );

//  Desired routine has dnsapi.dll alloc

#define DnsQueryConfigAlloc( Id, pAN )  \
        DnsQueryConfigAllocEx( Id, pAN, FALSE )

VOID
WINAPI
DnsFreeConfigStructure(
    IN OUT  PVOID               pData,
    IN      DNS_CONFIG_TYPE     ConfigId
    );

//
//  DWORD config get\set
//

DWORD
WINAPI
DnsQueryConfigDword(
    IN      DNS_CONFIG_TYPE     Config,
    IN      PWSTR               pwsAdapterName
    );

DNS_STATUS
WINAPI
DnsSetConfigDword(
    IN      DNS_CONFIG_TYPE     Config,
    IN      PWSTR               pwsAdapterName,
    IN      DWORD               NewValue
    );


//
//  End dnsapi.h
//



//
//  Backward compatibility
//
//  This is all the crap we should be getting out of here, but
//  may still be called in the sytem somewhere.
//
//  DO NOT USE!!!!
//
//  These definitions are for backward compatibility only.  They can be pulled at
//  any time and if you use them you may break.
//

#ifdef  DNS_INTERNAL
#define NO_DNSAPI_BACKCOMPAT 1   
#endif

#ifndef NO_DNSAPI_BACKCOMPAT
#define DNSAPI_BACKCOMPAT 1
#endif

#ifdef  DNSAPI_BACKCOMPAT

//
//  IP Address
//

typedef IP4_ADDRESS         IP_ADDRESS, *PIP_ADDRESS;
typedef IP4_ARRAY           IP_ARRAY, *PIP_ARRAY;

#define IP_ADDRESS_STRING_LENGTH    IP4_ADDRESS_STRING_LENGTH
#define SIZEOF_IP_ADDRESS           SIZEOF_IP4_ADDRESS


//
//  Config stuff
//
//  Macro old routines
//      - system-public config allocator
//      - global free routine
//      - these were structure allocs so were not being freed with LocalFree
//

#define DnsGetNetworkInformation()      DnsQueryConfigAlloc( DnsConfigNetworkInformation, NULL )
#define DnsGetSearchInformation()       DnsQueryConfigAlloc( DnsConfigSearchInformation, NULL )
#define Dns_GetDnsNetworkInfo(f,g)      DnsQueryConfigAlloc( DnsConfigNetInfo, NULL )

#define DnsFreeNetworkInformation(p)    DnsFreeConfigStructure( p, DnsConfigNetworkInformation )
#define DnsFreeSearchInformation(p)     DnsFreeConfigStructure( p, DnsConfigSearchInformation )
#define DnsFreeAdapterInformation(p)    DnsFreeConfigStructure( p, DnsConfigAdapterInformation )
#define Dns_FreeNetworkInfo(p)          DnsFreeConfigStructure( p, DnsConfigNetInfo )

//
//  Macro old config string allocating routines
//      - no adapter name
//      - allocating from dnsapi heap as main caller -- RnR -- seems to be
//          using DnsApiFree
//

#define BackpatAlloc( Id )      DnsQueryConfigAllocEx( Id, NULL, FALSE )

//  Public structures

#define DnsGetHostName_A()      BackpatAlloc( DnsConfigHostName_A )
#define DnsGetHostName_UTF8()   BackpatAlloc( DnsConfigHostName_UTF8 )
#define DnsGetHostName_W()      ((PWSTR)BackpatAlloc( DnsConfigHostName_W ))

#ifdef UNICODE
#define DnsGetHostName DnsGetHostName_W
#else
#define DnsGetHostName DnsGetHostName_A
#endif

#define DnsGetPrimaryDomainName_A()      BackpatAlloc( DnsConfigPrimaryDomainName_A )
#define DnsGetPrimaryDomainName_UTF8()   BackpatAlloc( DnsConfigPrimaryDomainName_UTF8 )
#define DnsGetPrimaryDomainName_W()      ((PWSTR)BackpatAlloc( DnsConfigPrimaryDomainName_W ))

#ifdef UNICODE
#define DnsGetPrimaryDomainName DnsGetPrimaryDomainName_W
#else
#define DnsGetPrimaryDomainName DnsGetPrimaryDomainName_A
#endif

//
//  DWORD get\set backcompat
//

//
//  DCR:  there is a possible problem with these mappings handles generic\adapter
//      difference -- not sure the mapping is complete
//      may need switches -- see which are even in use with BACKCOMPAT off
//

#define DnsIsDynamicRegistrationEnabled(pA)     \
        (BOOL)DnsQueryConfigDword( DnsConfigRegistrationEnabled, (pA) )

#define DnsIsAdapterDomainNameRegistrationEnabled(pA)   \
        (BOOL)DnsQueryConfigDword( DnsConfigAdapterHostNameRegistrationEnabled, (pA) )

#define DnsGetMaxNumberOfAddressesToRegister(pA) \
        DnsQueryConfigDword( DnsConfigAddressRegistrationMaxCount, (pA) )

//  DWORD reg value set

#define DnsEnableDynamicRegistration(pA) \
        DnsSetConfigDword( DnsConfigRegistrationEnabled, pA, (DWORD)TRUE )

#define DnsDisableDynamicRegistration(pA) \
        DnsSetConfigDword( DnsConfigRegistrationEnabled, pA, (DWORD)FALSE )

#define DnsEnableAdapterDomainNameRegistration(pA) \
        DnsSetConfigDword( DnsConfigAdapterHostNameRegistrationEnabled, pA, (DWORD)TRUE )

#define DnsDisableAdapterDomainNameRegistration(pA) \
        DnsSetConfigDword( DnsConfigAdapterHostNameRegistrationEnabled, pA, (DWORD)FALSE )

#define DnsSetMaxNumberOfAddressesToRegister(pA, MaxCount) \
        (NO_ERROR == DnsSetConfigDword( DnsConfigAddressRegistrationMaxCount, pA, MaxCount ))



//
//  DNS server list backcompat
//

#define Dns_GetDnsServerList(flag)      ((PIP4_ARRAY)BackpatAlloc( DnsConfigDnsServerList ))

#ifndef MIDL_PASS
__inline
DWORD
inline_DnsGetDnsServerList(
    OUT     PIP4_ARRAY *    ppDnsArray
    )
{
    *ppDnsArray = Dns_GetDnsServerList( TRUE );

    return ( *ppDnsArray ? (*ppDnsArray)->AddrCount : 0 );
}
#endif  // MIDL

#define DnsGetDnsServerList(p)      inline_DnsGetDnsServerList(p)


//
//  IP list backcompat
//

//
//  Machines IP address list (iplist.c)
//
//  Routine to get the current IP addresses from all adapters
//  configured for the machine.
//

DWORD
DnsGetIpAddressList(
    OUT     PIP4_ARRAY *    ppIpAddresses
    );

//
//  Routine to get the current IP addresses and subnet masks
//  from all adapters configured for the machine.
//

typedef struct _DNS_ADDRESS_INFO_
{
    IP4_ADDRESS     ipAddress;
    IP4_ADDRESS     subnetMask;
}
DNS_ADDRESS_INFO, *PDNS_ADDRESS_INFO;

DWORD
DnsGetIpAddressInfoList(
    OUT     PDNS_ADDRESS_INFO * ppAddrInfo
    );

DWORD
Dns_GetIpAddresses(
    IN OUT  PDNS_ADDRESS_INFO IpAddressInfoList,
    IN      DWORD             ListCount
    );


#ifndef MIDL_PASS
__inline
DWORD
inline_DnsGetIpAddressList(
    OUT     PIP4_ARRAY *     ppIpArray
    )
{
    *ppIpArray = (PIP4_ARRAY) BackpatAlloc( DnsConfigIp4AddressArray );

    return( *ppIpArray ? (*ppIpArray)->AddrCount : 0 );
}
#endif  // MIDL

#define DnsGetIpAddressList(p)  inline_DnsGetIpAddressList(p)



//
//  I've switched the DCPromo stuff.  Need to verify with clean system
//  build that it's completely gone, then pull.
//

#define DNS_RELATE_NEQ      DnsNameCompareNotEqual
#define DNS_RELATE_EQL      DnsNameCompareEqual
#define DNS_RELATE_LGT      DnsNameCompareLeftParent
#define DNS_RELATE_RGT      DnsNameCompareRightParent
#define DNS_RELATE_INVALID  DnsNameCompareInvalid

typedef DNS_NAME_COMPARE_STATUS  DNS_RELATE_STATUS, *PDNS_RELATE_STATUS;


#define DNS_UPDATE_INFO_ID_RESULT_INFO      DNS_EXINFO_ID_RESULTS_V1

//
//  Update additional info
//

typedef struct _DnsUpdateExtraInfo
{
    PVOID           pNext;
    DWORD           Id;

    union
    {
        struct
        {
            DNS_STATUS      Status;
            WORD            Rcode;
            IP4_ADDRESS     ServerIp4;
            IP6_ADDRESS     ServerIp6;
        }
        Results;
    } U;
}
DNS_UPDATE_EXTRA_INFO, *PDNS_UPDATE_EXTRA_INFO;


//
//  Old failed update info
//

IP_ADDRESS
WINAPI
DnsGetLastServerUpdateIP(
    VOID
    );

typedef struct _DnsFailedUpdateInfo
{
    IP4_ADDRESS     Ip4Address;
    IP6_ADDRESS     Ip6Address;
    DNS_STATUS      Status;
    DWORD           Rcode;
}
DNS_FAILED_UPDATE_INFO, *PDNS_FAILED_UPDATE_INFO;
#define DEFINED_DNS_FAILED_UPDATE_INFO 1


VOID
DnsGetLastFailedUpdateInfo(
    OUT     PDNS_FAILED_UPDATE_INFO pInfo
    );

#endif  // DNSAPI_BACKCOMPAT


#ifdef __cplusplus
}
#endif  // __cplusplus

#endif // _DNSAPI_INCLUDED_
=== C:/Users/treeman/Desktop/windows nt source code\Source\Win2K3\NT\public\internal\ds\inc\dnslib.h ===
/*++

Copyright (c) 1996-2001  Microsoft Corporation

Module Name:

    dnslib.h

Abstract:

    Domain Name System (DNS) Library

    DNS Library Routines -- Main Header File

Author:

    Jim Gilroy (jamesg)     December 7, 1996

Revision History:

--*/


#ifndef _DNSLIB_INCLUDED_
#define _DNSLIB_INCLUDED_

#include <windns.h>
#include <dnsapi.h>
#ifndef  MIDL_PASS
#include <rpc.h>
#endif


#ifdef __cplusplus
extern "C"
{
#endif  // __cplusplus


//
//  Handy alignment and rounding macros
//

#define WORD_ALIGN(ptr)     ((PVOID) ((UINT_PTR)((PBYTE)ptr + 1) & ~(UINT_PTR)1))

#define DWORD_ALIGN(ptr)    ((PVOID) ((UINT_PTR)((PBYTE)ptr + 3) & ~(UINT_PTR)3))

#define QWORD_ALIGN(ptr)    ((PVOID) ((UINT_PTR)((PBYTE)ptr + 7) & ~(UINT_PTR)7))

#ifdef WIN64
#define POINTER_ALIGN(ptr)  QWORD_ALIGN(ptr)
#else
#define POINTER_ALIGN(ptr)  DWORD_ALIGN(ptr)
#endif

#define WORD_ALIGN_DWORD(dw)        (((DWORD)dw + 1) & ~(DWORD)1)
#define DWORD_ALIGN_DWORD(dw)       (((DWORD)dw + 3) & ~(DWORD)3)
#define QWORD_ALIGN_DWORD(dw)       (((DWORD)dw + 7) & ~(DWORD)7)

#ifdef WIN64
#define POINTER_ALIGN_DWORD(dw)     QWORD_ALIGN_DWORD(dw)
#else
#define POINTER_ALIGN_DWORD(dw)     DWORD_ALIGN_DWORD(dw)
#endif


//
//  Useful type defs
//

#define PGUID       LPGUID
#define PADDRINFO   LPADDRINFO



//
//  Until converted must define PDNS_NAME
//
//  Note:  PDNS_NAME is NOT really a LPTSTR.
//      Rather it's the definition of a field that can be
//      either an PWSTR or PSTR depending on some other field.
//

#ifdef UNICODE
typedef PWSTR   PDNS_NAME;
#else
typedef PSTR    PDNS_NAME;
#endif


//
//  Inline byte flipping
//

#ifndef MIDL_PASS

__inline
WORD
inline_word_flip(
    IN      WORD            Word
    )
{
    return ( (Word << 8) | (Word >> 8) );
}

#define inline_htons(w)     inline_word_flip(w)
#define inline_ntohs(w)     inline_word_flip(w)

__inline
DWORD
inline_dword_flip(
    IN      DWORD           Dword
    )
{
    return ( ((Dword << 8) & 0x00ff0000) |
             (Dword << 24)               |
             ((Dword >> 8) & 0x0000ff00) |
             (Dword >> 24) );
}

#define inline_htonl(d)     inline_dword_flip(d)
#define inline_ntohl(d)     inline_dword_flip(d)

#endif MIDL_PASS



//
//  Flat buffer definition
//
//  Note:  using INT for sizes so that we can push BytesLeft negative
//  and use routines to determine REQUIRED space, even when no
//  buffer or buf too small.
//

typedef struct _FLATBUF
{
    PBYTE   pBuffer;
    PBYTE   pEnd;
    PBYTE   pCurrent;
    INT     Size;
    INT     BytesLeft;
}
FLATBUF, *PFLATBUF;


//
//  Flat buffer routines -- argument versions
//
//  These versions have the actual code so that we can
//  easily use this stuff with existing code that has
//  independent pCurrent and BytesLeft variables.
//
//  FLATBUF structure versions just call these inline.
//

#ifndef MIDL_PASS

PBYTE
FlatBuf_Arg_Reserve(
    IN OUT  PBYTE *         ppCurrent,
    IN OUT  PINT            pBytesLeft,
    IN      DWORD           Size,
    IN      DWORD           Alignment
    );

PBYTE
FlatBuf_Arg_WriteString(
    IN OUT  PBYTE *         ppCurrent,
    IN OUT  PINT            pBytesLeft,
    IN      PSTR            pString,
    IN      BOOL            fUnicode
    );

PBYTE
FlatBuf_Arg_CopyMemory(
    IN OUT  PBYTE *         ppCurrent,
    IN OUT  PINT            pBytesLeft,
    IN      PVOID           pMemory,
    IN      DWORD           Length,
    IN      DWORD           Alignment
    );

__inline
PBYTE
FlatBuf_Arg_ReserveAlignPointer(
    IN OUT  PBYTE *         ppCurrent,
    IN OUT  PINT            pBytesLeft,
    IN      DWORD           Size
    )
{
    return FlatBuf_Arg_Reserve(
                ppCurrent,
                pBytesLeft,
                Size,
                sizeof(PVOID) );
}

__inline
PBYTE
FlatBuf_Arg_ReserveAlignQword(
    IN OUT  PBYTE *         ppCurrent,
    IN OUT  PINT            pBytesLeft,
    IN      DWORD           Size
    )
{
    return FlatBuf_Arg_Reserve(
                ppCurrent,
                pBytesLeft,
                Size,
                sizeof(QWORD) );
}

__inline
PBYTE
FlatBuf_Arg_ReserveAlignDword(
    IN OUT  PBYTE *         ppCurrent,
    IN OUT  PINT            pBytesLeft,
    IN      DWORD           Size
    )
{
    return FlatBuf_Arg_Reserve(
                ppCurrent,
                pBytesLeft,
                Size,
                sizeof(DWORD) );
}

__inline
PBYTE
FlatBuf_Arg_ReserveAlignWord(
    IN OUT  PBYTE *         ppCurrent,
    IN OUT  PINT            pBytesLeft,
    IN      DWORD           Size
    )
{
    return FlatBuf_Arg_Reserve(
                ppCurrent,
                pBytesLeft,
                Size,
                sizeof(WORD) );
}

__inline
PBYTE
FlatBuf_Arg_ReserveAlignByte(
    IN OUT  PBYTE *         ppCurrent,
    IN OUT  PINT            pBytesLeft,
    IN      DWORD           Size
    )
{
    return FlatBuf_Arg_Reserve(
                ppCurrent,
                pBytesLeft,
                Size,
                0 );
}

PBYTE
__inline
FlatBuf_Arg_WriteString_A(
    IN OUT  PBYTE *         ppCurrent,
    IN OUT  PINT            pBytesLeft,
    IN      PSTR            pString
    )
{
    return  FlatBuf_Arg_WriteString(
                ppCurrent,
                pBytesLeft,
                pString,
                FALSE       // not unicode
                );
}

PBYTE
__inline
FlatBuf_Arg_WriteString_W(
    IN OUT  PBYTE *         ppCurrent,
    IN OUT  PINT            pBytesLeft,
    IN      PWSTR           pString
    )
{
    return  FlatBuf_Arg_WriteString(
                ppCurrent,
                pBytesLeft,
                (PSTR) pString,
                TRUE        // unicode
                );
}

//
//  Flat buffer routines -- structure versions
//

VOID
FlatBuf_Init(
    IN OUT  PFLATBUF        pFlatBuf,
    IN      PBYTE           pBuffer,
    IN      INT             Size
    );


__inline
PBYTE
FlatBuf_Reserve(
    IN OUT  PFLATBUF        pBuf,
    IN      DWORD           Size,
    IN      DWORD           Alignment
    )
{
    return FlatBuf_Arg_Reserve(
                & pBuf->pCurrent,
                & pBuf->BytesLeft,
                Size,
                Alignment );
}

__inline
PBYTE
FlatBuf_ReserveAlignPointer(
    IN OUT  PFLATBUF        pBuf,
    IN      DWORD           Size
    )
{
    return FlatBuf_Arg_Reserve(
                & pBuf->pCurrent,
                & pBuf->BytesLeft,
                Size,
                sizeof(PVOID) );
}

__inline
PBYTE
FlatBuf_ReserveAlignQword(
    IN OUT  PFLATBUF        pBuf,
    IN      DWORD           Size
    )
{
    return FlatBuf_Arg_Reserve(
                & pBuf->pCurrent,
                & pBuf->BytesLeft,
                Size,
                sizeof(QWORD) );
}

__inline
PBYTE
FlatBuf_ReserveAlignDword(
    IN OUT  PFLATBUF        pBuf,
    IN      DWORD           Size
    )
{
    return FlatBuf_Arg_Reserve(
                & pBuf->pCurrent,
                & pBuf->BytesLeft,
                Size,
                sizeof(DWORD) );
}

__inline
PBYTE
FlatBuf_ReserveAlignWord(
    IN OUT  PFLATBUF        pBuf,
    IN      DWORD           Size
    )
{
    return FlatBuf_Arg_Reserve(
                & pBuf->pCurrent,
                & pBuf->BytesLeft,
                Size,
                sizeof(WORD) );
}

__inline
PBYTE
FlatBuf_ReserveAlignByte(
    IN OUT  PFLATBUF        pBuf,
    IN      DWORD           Size
    )
{
    return FlatBuf_Arg_Reserve(
                & pBuf->pCurrent,
                & pBuf->BytesLeft,
                Size,
                0 );
}

PBYTE
__inline
FlatBuf_WriteString(
    IN OUT  PFLATBUF        pBuf,
    IN      PSTR            pString,
    IN      BOOL            fUnicode
    )
{
    return  FlatBuf_Arg_WriteString(
                & pBuf->pCurrent,
                & pBuf->BytesLeft,
                pString,
                fUnicode
                );
}

PBYTE
__inline
FlatBuf_WriteString_A(
    IN OUT  PFLATBUF        pBuf,
    IN      PSTR            pString
    )
{
    return  FlatBuf_Arg_WriteString(
                & pBuf->pCurrent,
                & pBuf->BytesLeft,
                pString,
                FALSE       // not unicode
                );
}

PBYTE
__inline
FlatBuf_WriteString_W(
    IN OUT  PFLATBUF        pBuf,
    IN      PWSTR           pString
    )
{
    return  FlatBuf_Arg_WriteString(
                & pBuf->pCurrent,
                & pBuf->BytesLeft,
                (PSTR) pString,
                TRUE        // unicode
                );
}

PBYTE
__inline
FlatBuf_CopyMemory(
    IN OUT  PFLATBUF        pBuf,
    IN      PVOID           pMemory,
    IN      DWORD           Length,
    IN      DWORD           Alignment
    )
{
    return FlatBuf_Arg_CopyMemory(
                & pBuf->pCurrent,
                & pBuf->BytesLeft,
                pMemory,
                Length,
                Alignment );
}

#endif  // not MIDL_PASS


//
//  Read unaligned value from given position in packet
//

#define READ_PACKET_HOST_DWORD(pch)  \
            FlipUnalignedDword( pch )

#define READ_PACKET_NET_DWORD(pch)  \
            ( *(UNALIGNED DWORD *)(pch) )

#define READ_PACKET_HOST_WORD(pch)  \
            FlipUnalignedWord( pch )

#define READ_PACKET_NET_WORD(pch)  \
            ( *(UNALIGNED WORD *)(pch) )


//
//  Private DNS_RECORD Flag field structure definition and macros
//
//  Note:  don't add to this list -- private stuff in dnslibp.h
//

typedef struct _DnsRecordLibFlags
{
    DWORD   Section     : 2;
    DWORD   Delete      : 1;
    DWORD   CharSet     : 2;

    DWORD   Unused      : 6;
    DWORD   Matched     : 1;
    DWORD   FreeData    : 1;
    DWORD   FreeOwner   : 1;

    DWORD   Reserved    : 18;
}
DNSRECLIB_FLAGS, *PDNSRECLIB_FLAGS;


#define PFLAGS( pRecord )           ((PDNSRECLIB_FLAGS)&pRecord->Flags.DW)
#define FLAG_Section( pRecord )     (PFLAGS( pRecord )->Section)
#define FLAG_Delete( pRecord )      (PFLAGS( pRecord )->Delete)
#define FLAG_CharSet( pRecord )     (PFLAGS( pRecord )->CharSet)
#define FLAG_FreeData( pRecord )    (PFLAGS( pRecord )->FreeData)
#define FLAG_FreeOwner( pRecord )   (PFLAGS( pRecord )->FreeOwner)
#define FLAG_Matched( pRecord )     (PFLAGS( pRecord )->Matched)

#define SET_FREE_OWNER(pRR)         (FLAG_FreeOwner(pRR) = TRUE)
#define SET_FREE_DATA(pRR)          (FLAG_FreeData(pRR) = TRUE)
#define SET_RR_MATCHED(pRR)         (FLAG_Matched(pRR) = TRUE)

#define CLEAR_FREE_OWNER(pRR)       (FLAG_FreeOwner(pRR) = FALSE)
#define CLEAR_FREE_DATA(pRR)        (FLAG_FreeData(pRR) = FALSE)
#define CLEAR_RR_MATCHED(pRR)       (FLAG_Matched(pRR) = FALSE)

#define IS_FREE_OWNER(pRR)          (FLAG_FreeOwner(pRR))
#define IS_FREE_DATA(pRR)           (FLAG_FreeData(pRR))
#define IS_RR_MATCHED(pRR)          (FLAG_Matched(pRR))

#define IS_ANSWER_RR(pRR)           (FLAG_Section(pRR) == DNSREC_ANSWER)
#define IS_AUTHORITY_RR(pRR)        (FLAG_Section(pRR) == DNSREC_AUTHORITY)
#define IS_ADDITIONAL_RR(pRR)       (FLAG_Section(pRR) == DNSREC_ADDITIONAL)


//
//  Converting RCODEs to\from DNS errors.
//

#define DNS_ERROR_FROM_RCODE(rcode)     ((rcode)+DNS_ERROR_RESPONSE_CODES_BASE)

#define DNS_RCODE_FROM_ERROR(err)       ((err)-DNS_ERROR_RESPONSE_CODES_BASE)




//
//  Record character sets
//
//  Currently supports records in three character sets
//      - unicode
//      - ANSI
//      - UTF8
//
//  Unicode and ANSI are supported through external DNSAPI interfaces.
//  UTF8 is not (at least offcially).
//
//  However, internally unicode and UTF8 are used for caching, reading
//  to and writing from packet.
//
//  All DNS_RECORD structs created by our code, are tagged with a
//  character set type in the flags CharSet field.
//

//
//  A couple of handy macros:
//

#define RECORD_CHARSET(pRR) \
        ( (DNS_CHARSET) (pRR)->Flags.S.CharSet )

#define IS_UNICODE_RECORD(pRR) \
        ( (DNS_CHARSET) (pRR)->Flags.S.CharSet == DnsCharSetUnicode )

//
//  Quick buffer size determination
//
//  Strings are read from the wire into dotted UTF8 format.
//  Strings are in UTF8 in RPC buffers.
//
//  Goal here is to quickly determine adequate buffer size,
//  slight overallocation is not critical.
//
//  Currently supporting only UTF8 or Unicode, however, if later
//  support direct ANSI conversion that's ok too, as ANSI will
//  no (to my knowledge) use more space than UTF8.
//

#define STR_BUF_SIZE_GIVEN_UTF8_LEN( Utf8Length, CharSet ) \
        ( ((CharSet)==DnsCharSetUnicode) ? ((Utf8Length)+1)*2 : (Utf8Length)+1 )


//
//  Default locale for string comparison and case mappings
//
//  Sublang: US English (0x04)  Lang:  English (0x09)
//

#define DNS_DEFAULT_LOCALE      (0x0409)




//
//  IP4 array utilities (iparray.c)
//
//  Note some of these require memory allocation, see note
//  on memory allocation below.
//


#define DNS_NET_ORDER_LOOPBACK      (0x0100007f)

//  NT5-autonet is 169.254.x.y

#define AUTONET_MASK                (0x0000ffff)
#define AUTONET_NET                 (0x0000fea9)

#define DNS_IS_AUTONET_IP(ip)       ( ((ip) & AUTONET_MASK) == AUTONET_NET )

#define DNS_IPARRAY_CLEAN_ZERO      (0x00000001)
#define DNS_IPARRAY_CLEAN_LOOPBACK  (0x00000002)
#define DNS_IPARRAY_CLEAN_AUTONET   (0x00000010)

//
//  Simple IP address array routines
//

PIP4_ADDRESS
Dns_CreateIpAddressArrayCopy(
    IN      PIP4_ADDRESS    aipAddress,
    IN      DWORD           cipAddress
    );

BOOL
Dns_ValidateIpAddressArray(
    IN      PIP4_ADDRESS    aipAddress,
    IN      DWORD           cipAddress,
    IN      DWORD           dwFlag
    );


//
//  IP4_ARRAY datatype routines
//

PIP4_ARRAY
Dns_CreateIpArray(
    IN      DWORD           cAddrCount
    );

DWORD
Dns_SizeofIpArray(
    IN      PIP4_ARRAY      pIpArray
    );

PIP4_ARRAY
Dns_BuildIpArray(
    IN      DWORD           cAddrCount,
    IN      PIP4_ADDRESS    pipAddrs
    );

PIP4_ARRAY
Dns_CopyAndExpandIpArray(
    IN      PIP4_ARRAY      pIpArray,
    IN      DWORD           ExpandCount,
    IN      BOOL            fDeleteExisting
    );

PIP4_ARRAY
Dns_CreateIpArrayCopy(
    IN      PIP4_ARRAY      pIpArray
    );

BOOL
Dns_IsAddressInIpArray(
    IN      PIP4_ARRAY      pIpArray,
    IN      IP4_ADDRESS     IpAddress
    );

BOOL
Dns_AddIpToIpArray(
    IN OUT  PIP4_ARRAY      pIpArray,
    IN      IP4_ADDRESS     IpNew
    );

VOID
Dns_ClearIpArray(
    IN OUT  PIP4_ARRAY      pIpArray
    );

VOID
Dns_ReverseOrderOfIpArray(
    IN OUT  PIP4_ARRAY      pIpArray
    );

BOOL
Dns_CheckAndMakeIpArraySubset(
    IN OUT  PIP4_ARRAY      pIpArraySub,
    IN      PIP4_ARRAY      pIpArraySuper
    );

INT
WINAPI
Dns_ClearIpFromIpArray(
    IN OUT  PIP4_ARRAY      pIpArray,
    IN      IP4_ADDRESS     IpDelete
    );

INT
WINAPI
Dns_DeleteIpFromIpArray(
    IN OUT  PIP4_ARRAY      pIpArray,
    IN      IP4_ADDRESS     IpDelete
    );

#define Dns_RemoveZerosFromIpArray(pArray)   \
        Dns_DeleteIpFromIpArray( (pArray), 0 )

INT
WINAPI
Dns_CleanIpArray(
    IN OUT  PIP4_ARRAY      pIpArray,
    IN      DWORD           Flag
    );

BOOL
Dns_AreIpArraysEqual(
    IN      PIP4_ARRAY     pIpArray1,
    IN      PIP4_ARRAY     pIpArray2
    );

BOOL
Dns_AreIpArraysSimilar(
    IN      PIP4_ARRAY     pIpArray1,
    IN      PIP4_ARRAY     pIpArray2
    );

DNS_STATUS
WINAPI
Dns_DiffOfIpArrays(
    IN      PIP4_ARRAY      pIpArray1,
    IN      PIP4_ARRAY      pIpArray2,
    OUT     PIP4_ARRAY*     ppOnlyIn1,
    OUT     PIP4_ARRAY*     ppOnlyIn2,
    OUT     PIP4_ARRAY*     ppIntersect
    );

BOOL
WINAPI
Dns_IsIntersectionOfIpArrays(
    IN      PIP4_ARRAY     pIpArray1,
    IN      PIP4_ARRAY     pIpArray2
    );

DNS_STATUS
WINAPI
Dns_UnionOfIpArrays(
    IN      PIP4_ARRAY      pIpArray1,
    IN      PIP4_ARRAY      pIpArray2,
    OUT     PIP4_ARRAY*     ppUnion
    );

#define Dns_IntersectionOfIpArrays(p1, p2, ppInt)    \
        Dns_DiffOfIpArrays( (p1), (p2), NULL, NULL, (ppInt) )


DNS_STATUS
Dns_CreateIpArrayFromMultiIpString(
    IN      PSTR            pchMultiIpString,
    OUT     PIP4_ARRAY*     ppIpArray
    );

PSTR 
Dns_CreateMultiIpStringFromIpArray(
    IN      PIP4_ARRAY      pIpArray,
    IN      CHAR            chSeparator     OPTIONAL
    );


//
//  Type list array routines
//

DNS_STATUS
Dns_CreateTypeArrayFromMultiTypeString(
    IN      PSTR            pchMultiTypeString,
    OUT     INT *           piTypeCount,
    OUT     PWORD *         ppwTypeArray
    );

PSTR 
Dns_CreateMultiTypeStringFromTypeArray(
    IN      INT             iTypeCount,
    IN      PWORD           ppwTypeArray,
    IN      CHAR            chSeparator     OPTIONAL
    );


//
//  IP6 stuff
//

#ifndef DEFINED_IP6_ARRAY
typedef struct _Ip6Array
{
    DWORD           MaxCount;
    DWORD           AddrCount;
#ifdef MIDL_PASS
    [size_is(MaxCount)] IP6_ADDRESS AddrArray[];
#else
    IP6_ADDRESS     AddrArray[1];
#endif
}
IP6_ARRAY, *PIP6_ARRAY;
#define DEFINED_IP6_ARRAY   1
#endif



//
//  General utilities
//


//
//  Wrap free, multi-thread safe seconds timer (timer.c)
//

VOID
Dns_InitializeSecondsTimer(
    VOID
    );

DWORD
Dns_GetCurrentTimeInSeconds(
    VOID
    );

//
//  Tokenizer
//

DWORD
Dns_TokenizeStringA(
    IN OUT  PSTR            pBuffer,
    OUT     PCHAR *         Argv,
    IN      DWORD           MaxArgs
    );

DWORD
Dns_TokenizeStringW(
    IN OUT  PWSTR           pBuffer,
    OUT     PWCHAR *        Argv,
    IN      DWORD           MaxArgs
    );



//
//  IP interfaces on local machine (iplist.c)
//

#define DNS_MAX_NAME_SERVERS        (50)
#define DNS_MAX_IP_INTERFACE_COUNT  (10000)

PIP4_ARRAY
Dns_GetLocalIpAddressArray(
    VOID
    );



//
//  NetInfo structures
//
//  WARNING:  Do NOT use these!
//
//  These are internal dnsapi.dll structures.  They are only
//  included here for backward compatibility with previous
//  code (netdiag) which incorrectly used these.
//
//  If you code with them you will inevitably wake up broken
//  down the road.
//

#if 0
#ifndef MIDL_PASS

typedef struct
{
    DNS_STATUS      Status;
    DWORD           Priority;

    //  Address is now DNS_ADDR
    //  Preserve IP4 field by putting it in correct place
    union
    {
        struct
        {
            DWORD           Pad0;
            IP4_ADDRESS     IpAddress;
        };
        DNS_ADDR    Address;
    };
}
DNSLIB_SERVER_INFO, *PDNSLIB_SERVER_INFO;

typedef struct
{
    PWSTR               pszAdapterGuidName;
    PWSTR               pwsAdapterDomain;
    PWSTR               pszAdapterDomain;
    PVOID               pLocalAddrs;
    PVOID               pServerArray;

    DWORD               InterfaceIndex;
    DWORD               InterfaceIndex6;
    DWORD               InfoFlags;
    DWORD               Status;
    DWORD               ReturnFlags;
    DWORD               ServerIndex;
    DWORD               cServerCount;
    DWORD               cTotalListSize;
    //DNSLIB_SERVER_INFO  ServerArray[1];
}
DNSLIB_ADAPTER, *PDNSLIB_ADAPTER;

#define DNS_MAX_SEARCH_LIST_ENTRIES     (50)

typedef struct
{
    PWSTR           pszName;
    DWORD           Flags;
}
DNSLIB_SEARCH_NAME, *PDNSLIB_SEARCH_NAME;

typedef struct
{
    PWSTR           pszDomainOrZoneName;
    DWORD           cNameCount;         // Zero for FAZ result
    DWORD           cTotalListSize;     // Zero for FAZ result
    DWORD           CurrentName;        // 0 for pszDomainOrZoneName
                                        // 1 for first name in array below
                                        // 2 for second name in array below
                                        // ...
    DNSLIB_SEARCH_NAME  SearchNameArray[1];
}
DNSLIB_SEARCH_LIST, *PDNSLIB_SEARCH_LIST;

typedef struct
{
    PWSTR               pwsDomainName;
    PWSTR               pszDomainName;
    PWSTR               pszHostName;
    PDNSLIB_SEARCH_LIST pSearchList;
    DWORD               TimeStamp;
    DWORD               InfoFlags;
    DWORD               Tag;
    DWORD               ReturnFlags;
    DWORD               cAdapterCount;
    DWORD               cTotalListSize;

    DNSLIB_ADAPTER      AdapterArray[1];
}
DNSLIB_NETINFO, *PDNSLIB_NETINFO;

//
//  Do NOT use these defs internally
//

#ifdef USE_DNSLIB_NETINFO

typedef DNSLIB_SERVER_INFO      DNS_SERVER_INFO,    *PDNS_SERVER_INFO;
typedef DNSLIB_ADAPTER          DNS_ADAPTER,        *PDNS_ADAPTER;
typedef DNSLIB_SEARCH_NAME      SEARCH_NAME,        *PSEARCH_NAME;
typedef DNSLIB_SEARCH_LIST      SEARCH_LIST,        *PSEARCH_LIST;
typedef DNSLIB_NETINFO          DNS_NETINFO,        *PDNS_NETINFO;

#endif  // not USE_DNSLIB_NETINFO
#endif  // not MIDL_PASS
#endif  // ifdef'd out




//
//  General DNS utilities (dnsutil.c)
//

IP4_ADDRESS
Dns_GetNetworkMask(
    IN      IP4_ADDRESS     IpAddress
    );

PSTR 
_fastcall
Dns_StatusString(
    IN      DNS_STATUS      Status
    );

#define Dns_StatusToErrorString_A(status)    Dns_StatusString(status)

DNS_STATUS
_fastcall
Dns_MapRcodeToStatus(
    IN      BYTE            ResponseCode
    );

BYTE
_fastcall
Dns_IsStatusRcode(
    IN      DNS_STATUS      Status
    );

//
//  Name utilities (name.c)
//

PSTR 
_fastcall
Dns_GetDomainName(
    IN      PCSTR           pszName
    );

PWSTR
_fastcall
Dns_GetDomainName_W(
    IN      PCWSTR          pwsName
    );

PCHAR
_fastcall
Dns_GetTldForName(
    IN      PCSTR           pszName
    );

BOOL
_fastcall
Dns_IsNameShort(
    IN      PCSTR           pszName
    );

BOOL
_fastcall
Dns_IsNameFQDN(
    IN      PCSTR           pszName
    );

DNS_STATUS
Dns_ValidateAndCategorizeDnsNameEx(
    IN      PCHAR           pchName,
    IN      DWORD           cchNameLength,
    OUT     PDWORD          pLabelCount
    );

#define Dns_ValidateAndCategorizeDnsName(p,c)   \
        Dns_ValidateAndCategorizeDnsNameEx((p),(c),NULL)

DWORD
Dns_NameLabelCount(
    IN      PCSTR           pszName
    );

#define DNS_NAME_UNKNOWN        0x00000000
#define DNS_NAME_IS_FQDN        0x00000001
#define DNS_NAME_SINGLE_LABEL   0x00000010
#define DNS_NAME_MULTI_LABEL    0x00000100

DWORD
_fastcall
Dns_GetNameAttributes(
    IN      PCSTR           pszName
    );



//
//  Packet create\read\write (packet.c)
//

//
//  UDP packet buffer
//
//  1472 is the maximum ethernet IP\UDP payload size
//  without causing fragmentation, use as default buffer
//

#define DNS_MAX_UDP_PACKET_BUFFER_LENGTH    (1472)


//  parsing RR
//  convenient to get WIRE records into aligned\host order format

typedef struct _DNS_PARSED_RR
{
    PCHAR   pchName;
    PCHAR   pchRR;
    PCHAR   pchData;
    PCHAR   pchNextRR;

    //  note from here on down mimics wire record

    WORD    Type;
    WORD    Class;
    DWORD   Ttl;
    WORD    DataLength;
}
DNS_PARSED_RR, *PDNS_PARSED_RR;


//
//  DNS Server Message Info structure
//
//  This is structure in which requests are held while being
//  processed by the DNS server.
//


typedef struct _DnsMessageBuf
{
    LIST_ENTRY      ListEntry;          //  for queuing

    //
    //  Addressing
    //

    SOCKET          Socket4;
    SOCKET          Socket6;

    //16/32
    DNS_ADDR        RemoteAddress;

    //32/48
    SOCKET          Socket;

    //
    //  Basic packet info
    //

    DWORD           BufferLength;       //  total length of buffer
    PCHAR           pBufferEnd;         //  ptr to byte after buffer

    PBYTE           pCurrent;           //  current location in buffer
    PWORD           pCurrentCountField; //  current count field being written

    //
    //  Current lookup info
    //

    DWORD           Timeout;            //  recv timeout
    DWORD           QueryTime;          //  time of original query
    WORD            wTypeCurrent;       //  type of query being done
    WORD            wOffsetCurrent;

    //
    //  Queuing
    //

    WORD            wQueuingXid;        //  match XID to response
    DWORD           QueuingTime;        //  time queued
    DWORD           ExpireTime;         //  queue timeout

    //
    //  Basic packet flags
    //

    BOOLEAN         fTcp;
    BOOLEAN         fSwapped;           //  header in net order
    BOOLEAN         fMessageComplete;   //  complete message received
    BOOLEAN         fConvertUnicode;    //  convert to unicode
    BOOLEAN         fSocketKeepalive;   //  keep socket alive
    BOOLEAN         fLastSendOpt;       //  last send contained OPT

    //
    //  TCP message reception
    //

    PCHAR           pchRecv;            //  ptr to next pos in message

    //
    //  End of message before OPT addition
    //

    PCHAR           pPreOptEnd;

    //
    //  WARNING !
    //
    //  Message length MUST
    //      - be a WORD type
    //      - immediately preceed message itself
    //  for proper send/recv of TCP messages.
    //
    //  Use pointers above to DWORD (or QWORD) align, then recv bytes to push
    //  message length against MessageHead.  Note, that DNS_HEADER contains
    //  only WORDs as it's largest element and so should chummy up even on
    //  WORD boundary.  DWORD boundary should be very safe.
    //
                                                          
    WORD            BytesToReceive;
    WORD            MessageLength;

    //
    //  DNS Message itself
    //

    DNS_HEADER      MessageHead;

    //
    //  Question and RR section
    //
    //  This simply provides some coding simplicity in accessing
    //  this section given MESSAGE_INFO structure.
    //

    CHAR            MessageBody[1];

}
DNS_MSG_BUF, *PDNS_MSG_BUF;

#define SIZEOF_MSG_BUF_OVERHEAD (sizeof(DNS_MSG_BUF) - sizeof(DNS_HEADER) - 1)

#define DNS_MESSAGE_END(pMsg) \
                ((PCHAR)&(pMsg)->MessageHead + (pMsg)->MessageLength)

#define DNS_MESSAGE_OFFSET( pMsg, p ) \
                ((PCHAR)(p) - (PCHAR)(&(pMsg)->MessageHead))

#define DNS_MESSAGE_CURRENT_OFFSET( pMsg ) \
                DNS_MESSAGE_OFFSET( (pMsg), (pMsg)->pCurrent )


//  Sockaddr combined length

#define DNS_MESSAGE_REMOTE_ADDRESS_AND_LENGTH_


//
//  Handy for packet setup
//

#define CLEAR_DNS_HEADER_FLAGS_AND_XID( pHead )     ( *(PDWORD)(pHead) = 0 )


PDNS_MSG_BUF
Dns_AllocateMsgBuf(
    IN      WORD            wBufferLength   OPTIONAL
    );

VOID
Dns_InitializeMsgBuf(
    IN OUT  PDNS_MSG_BUF    pMsg
    );

PDNS_MSG_BUF
Dns_BuildPacket(
    IN      PDNS_HEADER     pHeader,
    IN      BOOL            fNoHeaderCounts,
    IN      PDNS_NAME       pszQuestionName,
    IN      WORD            wQuestionType,
    IN      PDNS_RECORD     pRecord,
    IN      DWORD           dwFlags,
    IN      BOOL            fUpdatePacket
    );

PCHAR
_fastcall
Dns_WriteDottedNameToPacket(
    IN OUT  PCHAR           pch,
    IN      PCHAR           pchStop,
    IN      PSTR            pszName,
    IN      PSTR            pszDomain,      OPTIONAL
    IN      WORD            wDomainOffset,  OPTIONAL
    IN      BOOL            fUnicodeName
    );

PCHAR
_fastcall
Dns_WriteStringToPacket(
    IN OUT  PCHAR           pch,
    IN      PCHAR           pchStop,
    IN      PSTR            pszString,
    IN      BOOL            fUnicodeString
    );

PCHAR
Dns_WriteQuestionToMessage(
    IN OUT  PDNS_MSG_BUF    pMsg,
    IN      PDNS_NAME       pszName,
    IN      WORD            wType,
    IN      BOOL            fUnicodeName
    );

DNS_STATUS
Dns_WriteRecordStructureToMessage(
    IN OUT  PDNS_MSG_BUF    pMsg,
    IN      WORD            wType,
    IN      WORD            wClass,
    IN      DWORD           dwTtl,
    IN      WORD            wDataLength
    );

PCHAR
Dns_WriteRecordStructureToPacketEx(
    IN OUT  PCHAR           pchBuf,
    IN      WORD            wType,
    IN      WORD            wClass,
    IN      DWORD           dwTtl,
    IN      WORD            wDataLength
    );

DNS_STATUS
Dns_WriteRecordStructureToPacket(
    IN OUT  PCHAR           pchBuf,
    IN      PDNS_RECORD     pRecord,
    IN      BOOL            fUpdatePacket
    );

VOID
Dns_SetRecordDatalength(
    IN OUT  PDNS_WIRE_RECORD    pRecord,
    IN      WORD                wDataLength
    );

DNS_STATUS
Dns_AddRecordsToMessage(
    IN OUT  PDNS_MSG_BUF    pMsg,
    IN      PDNS_RECORD     pRecord,
    IN      BOOL            fUpdateMessage
    );

PCHAR
_fastcall
Dns_SkipPacketName(
    IN      PCHAR           pch,
    IN      PCHAR           pchEnd
    );

BOOL
Dns_IsSamePacketQuestion(
    IN      PDNS_MSG_BUF    pMsg1,
    IN      PDNS_MSG_BUF    pMsg2
    );

PCHAR
_fastcall
Dns_SkipPacketRecord(
    IN      PCHAR           pchRecord,
    IN      PCHAR           pchMsgEnd
    );

PCHAR
Dns_SkipToRecord(
    IN      PDNS_HEADER     pMsgHead,
    IN      PCHAR           pMsgEnd,
    IN      INT             iCount
    );

PCHAR
Dns_ReadRecordStructureFromPacket(
    IN      PCHAR           pchPacket,
    IN      PCHAR           pchMsgEnd,
    IN OUT  PDNS_PARSED_RR  pParsedRR
    );

DNS_STATUS
Dns_ExtractRecordsFromMessage(
    IN      PDNS_MSG_BUF    pMsg,
    IN      BOOL            fUnicode,
    OUT     PDNS_RECORD *   ppRecord
    );

DNS_STATUS
Dns_ExtractRecordsFromBuffer(
    IN      PDNS_MESSAGE_BUFFER pDnsBuffer,
    IN      WORD                wMessageLength,
    IN      BOOL                fUnicode,
    OUT     PDNS_RECORD *       ppRecord
    );

void
Dns_NormalizeAllRecordTtls(
    IN      PDNS_RECORD         pRecord
    );

PCHAR
_fastcall
Dns_ReadPacketName(
    IN OUT  PCHAR           pchNameBuffer,
    OUT     PWORD           pwNameLength,
    IN OUT  PWORD           pwNameOffset,           OPTIONAL
    OUT     PBOOL           pfNameSameAsPrevious,   OPTIONAL
    IN      PCHAR           pchName,
    IN      PCHAR           pchStart,
    IN      PCHAR           pchEnd
    );

PCHAR
_fastcall
Dns_ReadPacketNameAllocate(
    IN OUT  PCHAR *         ppchName,
    OUT     PWORD           pwNameLength,
    IN OUT  PWORD           pwPrevNameOffset,       OPTIONAL
    OUT     PBOOL           pfNameSameAsPrevious,   OPTIONAL
    IN      PCHAR           pchPacketName,
    IN      PCHAR           pchStart,
    IN      PCHAR           pchEnd
    );

WORD
Dns_GetRandomXid(
    IN      PVOID           pSeed
    );


//
//  Socket setup (socket.c)
//

//
//  these two routines really don't belong here -- system stuff should be elsewhere
//

DNS_STATUS
Dns_InitializeWinsock(
    VOID
    );
VOID
Dns_CleanupWinsock(
    VOID
    );

SOCKET
Dns_CreateSocket(
    IN      INT             SockType,
    IN      IP4_ADDRESS     ipAddress,
    IN      USHORT          Port
    );

VOID
Dns_CloseSocket(
    IN      SOCKET          Socket
    );

VOID
Dns_CloseConnection(
    IN      SOCKET          Socket
    );

DNS_STATUS
Dns_SetupGlobalAsyncSocket(
    VOID
    );



//
//  Query (query.c)
//

//
//  Flags to DnsQuery
//
//  These are in addition to public flags in dnsapi.h
//  They must all be in the reserved section defined by
//  DNS_QUERY_RESERVED
//

//  Unicode i\o

#define  DNSQUERY_UNICODE_NAME          (0x01000000)
#define  DNSQUERY_UNICODE_OUT           (0x02000000)

#define  DNSQUERY_NO_SERVER_RECORDS     (0x04000000)
#define  DNSQUERY_NULL_LOCAL            (0x04000000)

//  DNS server query

#define  DNS_SERVER_QUERY_NAME          (L"..DnsServers")


//
//  Screen DNSAPI_INTERNAL use for everything with NETINFO
//  these must be defined (where used) internally using good def.
//

#ifdef DNSLIB_NETINFO


//
//  Raw packet send and recv (send.c)
//

DNS_STATUS
Dns_SendAndRecvUdp(
    IN OUT  PDNS_MSG_BUF    pMsgSend,
    OUT     PDNS_MSG_BUF    pMsgRecv,
    IN      DWORD           dwFlags,
    IN      PIP4_ARRAY      aipServers,
    IN OUT  PDNS_NETINFO    pAdapterInfo
    );

DNS_STATUS
Dns_SendAndRecvTcp(
    IN OUT  PDNS_MSG_BUF    pMsgSend,
    OUT     PDNS_MSG_BUF    pMsgRecv,
    IN      PIP4_ARRAY      aipServers,
    IN OUT  PDNS_NETINFO    pAdapterInfo
    );

DNS_STATUS
Dns_SendAndRecv(
    IN OUT  PDNS_MSG_BUF    pMsgSend,
    OUT     PDNS_MSG_BUF *  ppMsgRecv,
    OUT     PDNS_RECORD *   ppResponseRecords,
    IN      DWORD           dwFlags,
    IN      PIP4_ARRAY      aipServers,
    IN OUT  PDNS_NETINFO    pAdapterInfo
    );

//
//  End non-internal only DNS_NETINFO with external def
//

#endif  // not DNSLIB_NETINFO


DNS_STATUS
Dns_SendEx(
    IN OUT  PDNS_MSG_BUF    pMsg,
    IN      IP4_ADDRESS     SendIp,     OPTIONAL
    IN      BOOL            fNoOpt
    );

#define Dns_Send( pMsg )    Dns_SendEx( (pMsg), 0, 0 )

DNS_STATUS
Dns_Recv(
    IN OUT  PDNS_MSG_BUF    pMsg
    );

DNS_STATUS
Dns_RecvUdp(
    IN OUT  PDNS_MSG_BUF    pMsg
    );

DNS_STATUS
Dns_OpenTcpConnectionAndSend(
    IN OUT  PDNS_MSG_BUF    pMsg,
    IN      IP4_ADDRESS     ipServer,
    IN      BOOL            fBlocking
    );

DNS_STATUS
Dns_RecvTcp(
    IN OUT  PDNS_MSG_BUF    pMsg
    );

VOID
Dns_InitializeMsgRemoteSockaddr(
    IN OUT  PDNS_MSG_BUF    pMsg,
    IN      IP4_ADDRESS     IpAddress
    );

VOID
Dns_InitQueryTimeouts(
    VOID
    );



//
//  Dynamic update (update.c)
//

PCHAR
Dns_WriteNoDataUpdateRecordToMessage(
    IN      PCHAR           pch,
    IN      PCHAR           pchStop,
    IN      WORD            wClass,
    IN      WORD            wType
    );

PCHAR
Dns_WriteDataUpdateRecordToMessage(
    IN      PCHAR           pch,
    IN      PCHAR           pchStop,
    IN      WORD            wClass,
    IN      WORD            wType,
    IN      DWORD           dwTtl,
    IN      WORD            wDataLength
    );

PDNS_MSG_BUF
Dns_BuildHostUpdateMessage(
    IN OUT  PDNS_MSG_BUF    pMsg,
    IN      PSTR            pszZone,
    IN      PSTR            pszName,
    IN      PIP4_ARRAY      aipAddresses,
    IN      DWORD           dwTtl
    );

PDNS_RECORD
Dns_HostUpdateRRSet(
    IN      PSTR            pszHostName,
    IN      PIP4_ARRAY      aipAddrs,
    IN      DWORD           dwTtl
    );

DNS_STATUS
Dns_UpdateHostAddrs(
    IN      PSTR            pszName,
    IN      PIP4_ARRAY      aipAddresses,
    IN      PIP4_ARRAY      aipServers,
    IN      DWORD           dwTtl
    );

DNS_STATUS
Dns_UpdateHostAddrsOld(
    IN      PSTR            pszName,
    IN      PIP4_ARRAY      aipAddresses,
    IN      PIP4_ARRAY      aipServers,
    IN      DWORD           dwTtl
    );

DNS_STATUS
Dns_UpdateLibEx(
    IN      PDNS_RECORD     pRecord,
    IN      DWORD           dwFlags,
    IN      PDNS_NAME       pszZone,
    IN      PDNS_NAME       pszServerName,
    IN      PIP4_ARRAY      aipServers,
    IN      HANDLE          hCreds,         OPTIONAL
    OUT     PDNS_MSG_BUF *  ppMsgRecv       OPTIONAL
    );



//
//  RenDom stuff
//
//  Record verification table
//

typedef struct _DnsVerifyTable
{
    DWORD           RecordCount;
    PDNS_RECORD     pRecordList;
    PIP6_ARRAY      pServerArray;
    PBOOL           pVerifyArray;
}
DNS_VERIFY_TABLE, *PDNS_VERIFY_TABLE;

DNS_STATUS
Dns_VerifyRecords(
    IN OUT  PDNS_VERIFY_TABLE   pTable
    );


//
//  Record verification table for rendom
//
//  Implementation note:
//  Using pointers here for server\bool arrays here instead
//  of open array of server count.  The reason is to allow dynamic
//  allocation of the lists by the API if it FAZes to find to
//  zone\servers to target.
//  The server IPs and bools could be combined in another
//  structure, but that doesn't seem to add much and makes
//  use of the existing IP array stuff more difficult.
//

typedef struct _DnsRendomEntry
{
    PSTR                    pDcName;
    //  could have this in unicode
    //PWSTR                   pDcName;
    PDNS_RECORD             pRecord;
    PIP6_ARRAY              pServerArray;
    PBOOL                   pVerifyArray;
}
DNS_RENDOM_ENTRY, *PDNS_RENDOM_ENTRY;


#define DNS_RENDOM_VERIFY_WITH_FAZ          (0x00000001)
#define DNS_RENDOM_VERIFY_WITH_LIST         (0x00000002)


typedef struct _DnsZoneServerList
{
    PSTR            pZoneName;
    //  could have this in unicode
    //PWSTR           pZoneName;
    PIP6_ARRAY      pServerArray;
}
DNS_ZONE_SERVER_LIST, *PDNS_ZONE_SERVER_LIST;


DNS_STATUS
Dns_VerifyRendomDcRecords(
    IN OUT  PDNS_RENDOM_ENTRY       pTable,
    IN      PDNS_ZONE_SERVER_LIST   pZoneServList,  OPTIONAL
    IN      DWORD                   Flag
    );



//
//  List build
//
//  pFirst points to first element in list.
//  pLast points to last element in list.
//
//  This builds a list for element types which have a pNext field
//  as their first structure member.
//

typedef struct _Dns_List
{
    PVOID   pFirst;
    PVOID   pLast;
}
DNS_LIST, *PDNS_LIST;

//
//  To init pFirst is NULL.
//  But pLast points at the location of the pFirst pointer -- essentially
//  treating the DNS_LIST as an element and pFirst as its next ptr.
//
//  During an add, the address given in pLast, is set with the new element,
//  equivalent to setting pLast's pNext field.  Then pLast is reset to point
//  at a new element.
//
//  When the first element is added to the list, pLast is pointing at the
//  DNS_LIST structure itself, so pFirst (as a dummy pNext) is set with
//  the ptr to the first element.
//
//  This works ONLY for elements which have a pNext field as the first
//  structure member.
//

#define DNS_LIST_INIT( pList )              \
        {                                   \
            PDNS_LIST _plist = (pList);     \
            _plist->pFirst = NULL;          \
            _plist->pLast = (_plist);       \
        }

#define DNS_LIST_ADD( pList, pnew )         \
        {                                   \
            PDNS_LIST   _plist = (pList);   \
            PVOID       _pnew = (pnew);         \
            *(PVOID*)(_plist->pLast) = _pnew;   \
            _plist->pLast = _pnew;              \
        }

#define IS_DNS_LIST_EMPTY( pList )          \
            ( (pList)->pFirst == NULL )


//
//  DNS_LIST as structure macros
//
//  Faster when function contains DNS_LIST structure itself and
//  NO SIDE EFFECTS will be present in call.
//

#define DNS_LIST_STRUCT_INIT( List )    \
        {                               \
            List.pFirst = NULL;         \
            List.pLast = &List;         \
        }

#define DNS_LIST_STRUCT_ADD( List, pnew ) \
        {                                           \
            *(PVOID*)(List.pLast) = (PVOID)pnew;    \
            List.pLast = (PVOID)pnew;               \
        }

#define IS_DNS_LIST_STRUCT_EMPTY( List ) \
            ( List.pFirst == NULL )



//
//  Record building (rralloc.c)
//

PDNS_RECORD
WINAPI
Dns_AllocateRecord(
    IN      WORD            wBufferLength
    );

VOID
WINAPI
Dns_RecordFree(
    IN OUT  PDNS_RECORD     pRecord
    );

#if 1
//  Old BS with flag -- kill when all fixed up

VOID
WINAPI
Dns_RecordListFreeEx(
    IN OUT  PDNS_RECORD     pRRList,
    IN      BOOL            fFreeOwner
    );

#define Dns_RecordListFree(p, f)    Dns_RecordListFreeEx(p, f)

#else   // new version
VOID
WINAPI
Dns_RecordListFree(
    IN OUT  PDNS_RECORD     pRRList
    );

#endif



PDNS_RECORD
Dns_RecordSetDetach(
    IN OUT  PDNS_RECORD     pRRList
    );

PDNS_RECORD
WINAPI
Dns_RecordListAppend(
    IN OUT  PDNS_RECORD     pHeadList,
    IN      PDNS_RECORD     pTailList
    );

DWORD
Dns_RecordListCount(
    IN      PDNS_RECORD     pRRList,
    IN      WORD            wType
    );


//
//  Record build from data strings (rrbuild.c)
//

PDNS_RECORD
Dns_RecordBuild_A(
    IN OUT  PDNS_RRSET      pRRSet,
    IN      PSTR            pszOwner,
    IN      WORD            wType,
    IN      BOOL            fAdd,
    IN      UCHAR           Section,
    IN      INT             Argc,
    IN      PCHAR *         Argv
    );

PDNS_RECORD
Dns_RecordBuild_W(
    IN OUT  PDNS_RRSET      pRRSet,
    IN      PWSTR           pszOwner,
    IN      WORD            wType,
    IN      BOOL            fAdd,
    IN      UCHAR           Section,
    IN      INT             Argc,
    IN      PWCHAR *        Argv
    );

//
//  Record to\from string functions.
//

DNS_STATUS
Dns_WriteRecordToString(
    OUT     PCHAR           pBuffer,
    IN      DWORD           BufferLength,
    IN      PDNS_RECORD     pRecord,
    IN      DNS_CHARSET     CharSet,
    IN      DWORD           Flags
    );

PDNS_RECORD
Dns_CreateRecordFromString(
    IN      PSTR            pString,
    IN      DNS_CHARSET     CharSet,
    IN      DWORD           Flags
    );



//
//  Record set manipulation
//

//
//  Record Compare
//
//  Note:  these routines will NOT do proper unicode compare, unless
//          records have the fUnicode flag set.
//

BOOL
WINAPI
Dns_RecordCompare(
    IN      PDNS_RECORD     pRecord1,
    IN      PDNS_RECORD     pRecord2
    );

BOOL
WINAPI
Dns_RecordSetCompare(
    IN OUT  PDNS_RECORD     pRR1,
    IN OUT  PDNS_RECORD     pRR2,
    OUT     PDNS_RECORD *   ppDiff1,    OPTIONAL
    OUT     PDNS_RECORD *   ppDiff2     OPTIONAL
    );

typedef enum _DnsSetCompareResult
{
    DnsSetCompareError = (-1),
    DnsSetCompareIdentical,
    DnsSetCompareNoOverlap,
    DnsSetCompareOneSubsetOfTwo,
    DnsSetCompareTwoSubsetOfOne,
    DnsSetCompareIntersection
}
DNS_SET_COMPARE_RESULT;

DNS_SET_COMPARE_RESULT
WINAPI
Dns_RecordSetCompareEx(
    IN OUT  PDNS_RECORD     pRR1,
    IN OUT  PDNS_RECORD     pRR2,
    OUT     PDNS_RECORD *   ppDiff1,    OPTIONAL
    OUT     PDNS_RECORD *   ppDiff2     OPTIONAL
    );

BOOL
WINAPI
Dns_RecordSetCompareForIntersection(
    IN OUT  PDNS_RECORD     pRR1,
    IN OUT  PDNS_RECORD     pRR2
    );

//
//  Record set prioritization (rrsort.c)
//

BOOL
Dns_CompareIpAddresses(
    IN      IP4_ADDRESS     addr1,
    IN      IP4_ADDRESS     addr2,
    IN      IP4_ADDRESS     subnetMask
    );


//
//  DNS Name compare
//

BOOL
Dns_NameCompare_A(
    IN      PCSTR           pName1,
    IN      PCSTR           pName2
    );

BOOL
Dns_NameCompare_W(
    IN      PCWSTR          pName1,
    IN      PCWSTR          pName2
    );

BOOL
Dns_NameCompare_UTF8(
    IN      PCSTR           pName1,
    IN      PCSTR           pName2
    );

BOOL
Dns_NameComparePrivate(
    IN      PCSTR           pName1,
    IN      PCSTR           pName2,
    IN      DNS_CHARSET     CharSet
    );

//
//  Advanced name comparison
//  Includes hierarchial name relationship.
//

DNS_NAME_COMPARE_STATUS
Dns_NameCompareEx(
    IN      LPCSTR          pszNameLeft,
    IN      LPCSTR          pszNameRight,
    IN      DWORD           dwReserved,
    IN      DNS_CHARSET     CharSet
    );

//
//  Record Copy
//

PDNS_RECORD
WINAPI
Dns_RecordCopyEx(
    IN      PDNS_RECORD     pRecord,
    IN      DNS_CHARSET     CharSetIn,
    IN      DNS_CHARSET     CharSetOut
    );

//
//  RR Set copy
//

PDNS_RECORD
WINAPI
Dns_RecordSetCopyEx(
    IN      PDNS_RECORD     pRR,
    IN      DNS_CHARSET     CharSetIn,
    IN      DNS_CHARSET     CharSetOut
    );



//
//  Record \ type routines
//
//
//  Resource record type\name mapping table
//

typedef struct
{
    PCHAR   pszTypeName;    //  type string (used in database files)
    WORD    wType;          //  type in host byte order
}
TYPE_NAME_TABLE;

extern TYPE_NAME_TABLE TypeTable[];


//
//  Max record name length, allows upcasing of incoming labels
//  to optimize comparisons
//

#define MAX_RECORD_NAME_LENGTH  (8)

//
//  Record type specific sizes
//

#define WKS_MAX_PORT                (1024)  // max well known service port
#define WKS_MAX_BITMASK_LENGTH      (128)   // 1024bits / 8bits/byte

#define SIZEOF_A6_ADDRESS_SUFFIX_LENGTH 16

#define SIZEOF_SOA_FIXED_DATA       (5 * sizeof(DWORD))
#define SIZEOF_MX_FIXED_DATA        (sizeof(WORD))
#define SIZEOF_WKS_FIXED_DATA       (SIZEOF_IP4_ADDRESS+ sizeof(BYTE))
#define SIZEOF_KEY_FIXED_DATA       (sizeof(DWORD))
#define SIZEOF_SIG_FIXED_DATA       (4 * sizeof(DWORD) + sizeof(WORD))
#define SIZEOF_NXT_FIXED_DATA       (0)
#define SIZEOF_LOC_FIXED_DATA       (4 * sizeof(DWORD))
#define SIZEOF_SRV_FIXED_DATA       (3 * sizeof(WORD))
#define SIZEOF_A6_FIXED_DATA        (1 + SIZEOF_A6_ADDRESS_SUFFIX_LENGTH)

#define SIZEOF_TKEY_FIXED_DATA      (2 * sizeof(DWORD) + 4 * sizeof(WORD))

#define SIZEOF_TSIG_PRE_SIG_FIXED_DATA  (2 * sizeof(DWORD) + sizeof(WORD))
#define SIZEOF_TSIG_POST_SIG_FIXED_DATA (3 * sizeof(WORD))
#define SIZEOF_TSIG_FIXED_DATA          (2 * sizeof(DWORD) + 4 * sizeof(WORD))

#define SIZEOF_WINS_FIXED_DATA      (4 * sizeof(DWORD))
#define SIZEOF_NBSTAT_FIXED_DATA    (3 * sizeof(DWORD))

//
//  Record type routines
//  These ones are of possible public interest and exposed in dnsapi.dll
//

BOOL
_fastcall
Dns_IsAMailboxType(
    IN      WORD            wType
    );

WORD
Dns_RecordTypeForNameA(
    IN      PCHAR           pszName,
    IN      INT             cchNameLength
    );

WORD
Dns_RecordTypeForNameW(
    IN      PWCHAR          pchName,
    IN      INT             cchNameLength
    );

#define Dns_RecordTypeForName(p,c)  Dns_RecordTypeForNameA((p),(c))


BOOL
Dns_WriteStringForType_A(
    OUT     PCHAR           pBuffer,
    IN      WORD            wType
    );

BOOL
Dns_WriteStringForType_W(
    OUT     PWCHAR          pBuffer,
    IN      WORD            wType
    );

PCHAR
Dns_RecordStringForType(
    IN      WORD            wType
    );

PCHAR
Dns_RecordStringForWritableType(
    IN      WORD            wType
    );

//
//  Record type specific stuff
//

BOOL
Dns_IsStringCountValidForTextType(
    IN      WORD            wType,
    IN      WORD            StringCount
    );


//
//  ATMA conversions
//

DWORD
Dns_AtmaAddressLengthForAddressString(
    IN      PCHAR           pchString,
    IN      DWORD           dwStringLength
    );

DNS_STATUS
Dns_AtmaStringToAddress(
    OUT     PBYTE           pAddress,
    IN OUT  PDWORD          pdwAddrLength,
    IN      PCHAR           pchString,
    IN      DWORD           dwStringLength
    );

PCHAR
Dns_AtmaAddressToString(
    OUT     PCHAR           pchString,
    IN      UCHAR           AddrType,
    IN      PBYTE           pAddress,
    IN      DWORD           dwAddrLength
    );

//
//  DNSSEC SIG and KEY routines
//

//  Max key is 4096 bit giving 512 byte length.
//
//  Max string representation is actually 33% larger as each three byte (24bit)
//  block contains four base64 characters.

#define DNS_MAX_KEY_LENGTH              (512)

#define DNS_MAX_KEY_STRING_LENGTH       (685)


WORD
Dns_KeyRecordFlagForString(
    IN      PCHAR           pchName,
    IN      INT             cchNameLength
    );

PCHAR
Dns_KeyRecordFlagString(
    IN      DWORD           dwFlag,
    IN OUT  PCHAR           pchFlag
    );

UCHAR
Dns_KeyRecordProtocolForString(
    IN      PCHAR           pchName,
    IN      INT             cchNameLength
    );

PCHAR
Dns_GetKeyProtocolString(
    IN      UCHAR           uchProtocol
    );

UCHAR
Dns_SecurityAlgorithmForString(
    IN      PCHAR           pchName,
    IN      INT             cchNameLength
    );

PCHAR
Dns_GetDnssecAlgorithmString(
    IN      UCHAR           uchAlgorithm
    );

UCHAR
Dns_SecurityBase64CharToBits(
    IN      CHAR            ch64
    );

DNS_STATUS
Dns_SecurityBase64StringToKey(
    OUT     PBYTE           pKey,
    OUT     PDWORD          pKeyLength,
    IN      PCHAR           pchString,
    IN      DWORD           cchLength
    );

PCHAR
Dns_SecurityKeyToBase64String(
    IN      PBYTE           pKey,
    IN      DWORD           KeyLength,
    OUT     PCHAR           pchBuffer
    );

LONG
Dns_ParseSigTime(
    IN      PCHAR           pchString,
    IN      INT             cchLength
    );

PCHAR
Dns_SigTimeString(
    IN      LONG            SigTime,
    OUT     PCHAR           pchBuffer
    );


//
//  WINS \ WINS-R types detection
//

#define IS_WINS_TYPE(type)      (((type) & 0xfffc) == 0xff00)

//
//  MS WINS mapping flags
//

//  return on invalid WINS flag

#define DNS_WINS_FLAG_ERROR     (-1)

//  max length of WINS flags
//  pass buffer at least this big

#define WINS_FLAG_MAX_LENGTH    (80)


DWORD
Dns_WinsRecordFlagForString(
    IN      PCHAR           pchName,
    IN      INT             cchNameLength
    );

PCHAR
Dns_WinsRecordFlagString(
    IN      DWORD           dwFlag,
    IN OUT  PCHAR           pchFlag
    );

//
//  must sit here until PDNS_RECORD defined in public dns.h header
//

DNS_STATUS
Dns_RecordWriteFileString(
    IN      PDNS_RECORD     pRecord,
    IN      PSTR            pszZoneName,
    IN      DWORD           dwDefaultTtl    OPTIONAL
    );




//
//  IP Address to\from string utilities (straddr.c)
//

//
//  String to Address
//

BOOL
Dns_Ip4StringToAddress_W(
    OUT     PIP4_ADDRESS    pIp4Addr,
    IN      PCWSTR          pwString
    );

BOOL
Dns_Ip4StringToAddress_A(
    OUT     PIP4_ADDRESS    pIp4Addr,
    IN      PCSTR           pString
    );

BOOL
Dns_Ip6StringToAddress_A(
    OUT     PIP6_ADDRESS    pIp6Addr,
    IN      PCSTR           pString
    );

BOOL
Dns_Ip6StringToAddress_W(
    OUT     PIP6_ADDRESS    pIp6Addr,
    IN      PCWSTR          pwString
    );

//
//  Combined IP4\IP6 string to address
//

BOOL
Dns_StringToAddress_W(
    OUT     PCHAR           pAddrBuf,
    IN OUT  PDWORD          pBufLength,
    IN      PCWSTR          pString,
    IN OUT  PDWORD          pAddrFamily
    );

BOOL
Dns_StringToAddress_A(
    OUT     PCHAR           pAddrBuf,
    IN OUT  PDWORD          pBufLength,
    IN      PCSTR           pString,
    IN OUT  PDWORD          pAddrFamily
    );


//
//  Address to string 
//

PWCHAR
Dns_Ip6AddressToString_W(
    OUT     PWCHAR          pwString,
    IN      PIP6_ADDRESS    pIp6Addr
    );

PCHAR
Dns_Ip6AddressToString_A(
    OUT     PCHAR           pchString,
    IN      PIP6_ADDRESS    pIp6Addr
    );

PWCHAR
Dns_Ip4AddressToString_W(
    OUT     PWCHAR          pwString,
    IN      PIP4_ADDRESS    pIp4Addr
    );

PCHAR
Dns_Ip4AddressToString_A(
    OUT     PCHAR           pString,
    IN      PIP4_ADDRESS    pIp4Addr
    );

//
//  Address to string -- combined
//

PCHAR
Dns_AddressToString_A(
    OUT     PCHAR           pchString,
    IN OUT  PDWORD          pStringLength,
    IN      PBYTE           pAddr,
    IN      DWORD           AddrLength,
    IN      DWORD           AddrFamily
    );


//
//  Reverse lookup address-to-name IP4
//

PCHAR
Dns_Ip4AddressToReverseName_A(
    OUT     PCHAR           pBuffer,
    IN      IP4_ADDRESS     IpAddr
    );

PWCHAR
Dns_Ip4AddressToReverseName_W(
    OUT     PWCHAR          pBuffer,
    IN      IP4_ADDRESS     IpAddr
    );

PCHAR
Dns_Ip4AddressToReverseNameAlloc_A(
    IN      IP4_ADDRESS     IpAddr
    );

PWCHAR
Dns_Ip4AddressToReverseNameAlloc_W(
    IN      IP4_ADDRESS     IpAddr
    );

//
//  Reverse lookup address-to-name IP6
//

PCHAR
Dns_Ip6AddressToReverseName_A(
    OUT     PCHAR           pBuffer,
    IN      IP6_ADDRESS     Ip6Addr
    );

PWCHAR
Dns_Ip6AddressToReverseName_W(
    OUT     PWCHAR          pBuffer,
    IN      IP6_ADDRESS     Ip6Addr
    );

PCHAR
Dns_Ip6AddressToReverseNameAlloc_A(
    IN      IP6_ADDRESS     Ip6Addr
    );

PWCHAR
Dns_Ip6AddressToReverseNameAlloc_W(
    IN      IP6_ADDRESS     Ip6Addr
    );

//
//  Reverse lookup name-to-address
//

BOOL
Dns_Ip4ReverseNameToAddress_A(
    OUT     PIP4_ADDRESS    pIp4Addr,
    IN      PCSTR           pszName
    );

BOOL
Dns_Ip4ReverseNameToAddress_W(
    OUT     PIP4_ADDRESS    pIp4Addr,
    IN      PCWSTR          pwsName
    );

BOOL
Dns_Ip6ReverseNameToAddress_A(
    OUT     PIP6_ADDRESS    pIp6Addr,
    IN      PCSTR           pszName
    );

BOOL
Dns_Ip6ReverseNameToAddress_W(
    OUT     PIP6_ADDRESS    pIp6Addr,
    IN      PCWSTR          pwsName
    );

//
//  Combined IP4\IP6 reverse lookup name-to-address
//

BOOL
Dns_ReverseNameToAddress_W(
    OUT     PCHAR           pAddrBuf,
    IN OUT  PDWORD          pBufLength,
    IN      PCWSTR          pString,
    IN OUT  PDWORD          pAddrFamily
    );

BOOL
Dns_ReverseNameToAddress_A(
    OUT     PCHAR           pAddrBuf,
    IN OUT  PDWORD          pBufLength,
    IN      PCSTR           pString,
    IN OUT  PDWORD          pAddrFamily
    );



//
//  String utilities (string.c)
//
//  Note some of these require memory allocation, see note
//  on memory allocation below.
//
//  Flags are defined in dnsapi.h
//

//#define DNS_ALLOW_RFC_NAMES_ONLY    (0)
//#define DNS_ALLOW_NONRFC_NAMES      (0x00000001)
//#define DNS_ALLOW_MULTIBYTE_NAMES   (0x00000002)
//#define DNS_ALLOW_ALL_NAMES         (0x00000003)

//
//  Unicode name buffer length.
//  Non-type specific routines below take buffer counts in bytes.
//  Unicode buffers of max name length have twice the bytes.
//

#define DNS_MAX_NAME_BUFFER_LENGTH_UNICODE  (2 * DNS_MAX_NAME_BUFFER_LENGTH)


//
//  Macros to simplify UTF8 conversions
//
//  UTF8 is simply a representation of unicode that maps one-to-one
//  for the ASCII space.
//  Unicode                     UTF8
//  -------                     ----
//      < 0x80 (128)    ->      use low byte (one-to-one mapping)
//      < 0x07ff        ->      two chars
//      > 0x07ff        ->      three chars
//

#define UTF8_1ST_OF_2     0xc0      //  110x xxxx
#define UTF8_1ST_OF_3     0xe0      //  1110 xxxx
#define UTF8_TRAIL        0x80      //  10xx xxxx

#define UTF8_2_MAX        0x07ff    //  max unicode character representable in
                                    //  in two byte UTF8


//
//  Explicitly UTF8 string
//

typedef PSTR    PU8STR;


PSTR 
Dns_CreateStringCopy(
    IN      PCHAR           pchString,
    IN      DWORD           cchString
    );

DWORD
Dns_GetBufferLengthForStringCopy(
    IN      PCHAR           pchString,
    IN      DWORD           cchString,
    IN      DNS_CHARSET     CharSetIn,
    IN      DNS_CHARSET     CharSetOut
    );

DWORD
Dns_StringCopy(
    OUT     PBYTE           pBuffer,
    IN OUT  PDWORD          pdwBufLength,
    IN      PCHAR           pchString,
    IN      DWORD           cchString,
    IN      DNS_CHARSET     CharSetIn,
    IN      DNS_CHARSET     CharSetOut
    );

PVOID
Dns_StringCopyAllocate(
    IN      PCHAR           pchString,
    IN      DWORD           cchString,
    IN      DNS_CHARSET     CharSetIn,
    IN      DNS_CHARSET     CharSetOut
    );

#define Dns_StringCopyAllocate_W( p, c )  \
        ( (PWCHAR) Dns_StringCopyAllocate(  \
                    (PCHAR) (p),            \
                    (c),                    \
                    DnsCharSetUnicode,      \
                    DnsCharSetUnicode ) )

#define Dns_StringCopyAllocate_A( p, c )  \
        ( (PCHAR) Dns_StringCopyAllocate(   \
                    (p),                    \
                    (c),                    \
                    DnsCharSetUtf8,         \
                    DnsCharSetUtf8 ) )


PSTR
Dns_CreateStringCopy_A(
    IN      PCSTR           pwsString
    );

PWSTR
Dns_CreateStringCopy_W(
    IN      PCWSTR          pwsString
    );

PWSTR
Dns_CreateConcatenatedString_W(
    IN      PCWSTR *        pStringArray
    );

PWSTR 
Dns_GetResourceString(
    IN      DWORD           dwStringId,
    IN      PWSTR           pwszBuffer,
    IN      DWORD           cbBuffer
    );

INT
wcsicmp_ThatWorks(
    IN      PWSTR           pString1,
    IN      PWSTR           pString2
    );


//
//  Special DNS name string functions
//

#define Dns_GetBufferLengthForNameCopy(a,b,c,d)\
        Dns_GetBufferLengthForStringCopy((a),(b),(c),(d))

#define Dns_NameCopy(a,b,c,d,e,f) \
        Dns_StringCopy(a,b,c,d,e,f)

#define Dns_NameCopyAllocate(a,b,c,d) \
        Dns_StringCopyAllocate(a,b,c,d)



//
//  Name validation (string.c)
//

DNS_STATUS
Dns_ValidateName_UTF8(
    IN      LPCSTR          pszName,
    IN      DNS_NAME_FORMAT Format
    );

DNS_STATUS
Dns_ValidateName_W(
    IN      LPCWSTR         pwszName,
    IN      DNS_NAME_FORMAT Format
    );

DNS_STATUS
Dns_ValidateName_A(
    IN      LPCSTR          pszName,
    IN      DNS_NAME_FORMAT Format
    );


DNS_STATUS
Dns_ValidateDnsString_UTF8(
    IN      LPCSTR          pszName
    );

DNS_STATUS
Dns_ValidateDnsString_W(
    IN      LPCWSTR         pszName
    );

PSTR 
Dns_CreateStandardDnsNameCopy(
    IN      PCHAR           pchName,
    IN      DWORD           cchName,
    IN      DWORD           dwFlag
    );


//
//  UTF8 conversions (utf8.c)
//

DNS_STATUS
_fastcall
Dns_ValidateUtf8Byte(
    IN      BYTE            chUtf8,
    IN OUT  PDWORD          pdwTrailCount
    );

DWORD
_fastcall
Dns_UnicodeToUtf8(
    IN      PWCHAR          pwUnicode,
    IN      DWORD           cchUnicode,
    OUT     PCHAR           pchResult,
    IN      DWORD           cchResult
    );

DWORD
_fastcall
Dns_Utf8ToUnicode(
    IN      PCHAR           pchUtf8,
    IN      DWORD           cchUtf8,
    OUT     PWCHAR          pwResult,
    IN      DWORD           cwResult
    );

DWORD
Dns_Utf8ToOrFromAnsi(
    OUT     PCHAR           pchResult,
    IN      DWORD           cchResult,
    IN      PCHAR           pchIn,
    IN      DWORD           cchIn,
    IN      DNS_CHARSET     InCharSet,
    IN      DNS_CHARSET     OutCharSet
    );

DWORD
Dns_AnsiToUtf8(
    IN      PCHAR           pchAnsi,
    IN      DWORD           cchAnsi,
    OUT     PCHAR           pchResult,
    IN      DWORD           cchResult
    );

DWORD
Dns_Utf8ToAnsi(
    IN      PCHAR           pchUtf8,
    IN      DWORD           cchUtf8,
    OUT     PCHAR           pchResult,
    IN      DWORD           cchResult
    );

BOOL
_fastcall
Dns_IsStringAscii(
    IN      PSTR            pszString
    );

BOOL
_fastcall
Dns_IsStringAsciiEx(
    IN      PCHAR           pchString,
    IN      DWORD           cchString
    );

BOOL
_fastcall
Dns_IsWideStringAscii(
    IN      PWSTR           pwsString
    );




//
//  Resource record dispatch tables
//
//  Resource record tables are indexed by type for standard types
//  These define limits on tables.
//
//  Currently indexing out to RR 40, so that we'll handle any new RR types
//  out this far without interfering with WINS stuff.
//

#define MAX_SELF_INDEXED_TYPE   (48)

//
//  Mappings for non-self indexed types
//
//  Note:  these are presented here for information purposes only!
//
//  Always call Dns_RecordTableIndexForType(wType) to get correct index.
//

#define TKEY_TYPE_INDEX         (MAX_SELF_INDEXED_TYPE + 1)
#define TSIG_TYPE_INDEX         (MAX_SELF_INDEXED_TYPE + 2)

#define WINS_TYPE_INDEX         (MAX_SELF_INDEXED_TYPE + 3)
#define WINSR_TYPE_INDEX        (MAX_SELF_INDEXED_TYPE + 4)

//  End of actual record types.
//  Query type indexes may extend beyond this index.

#define MAX_RECORD_TYPE_INDEX   (MAX_SELF_INDEXED_TYPE + 4)

//
//  Generic indexer for both regular and extended (non-self-indexing) types
//

#define INDEX_FOR_TYPE(type)    Dns_RecordTableIndexForType(type)


//
//  Type to index mapping
//

WORD
Dns_RecordTableIndexForType(
    IN      WORD            wType
    );


//
//  Generic print routine
//
//  All our print routines will take the real print routine
//  as a parameter.  This routine must have "sprintf-like"
//  or "fprintf-like" semantics.  In other words a context,
//  format and variable number of arguments.
//
//  Note the context argument is effectively a PVOID --
//  different routines will have different contexts.  The
//  explicit definition is to enforce strong type checking
//  so a call without a context is caught on compile.
//  

typedef struct _DnsPrintContext
{
    PVOID   pvDummy;
    DWORD   Dummy;
}
PRINT_CONTEXT, *PPRINT_CONTEXT;

typedef VOID (* PRINT_ROUTINE)(
                    PPRINT_CONTEXT,
                    CHAR*,
                    ... );



//
//  RnR utilities
//

DWORD
Dns_RnrLupFlagForString(
    IN      PCHAR           pchName,
    IN      INT             cchNameLength
    );

PCHAR
Dns_GetRnrLupFlagString(
    IN      DWORD           dwFlag
    );

DWORD
Dns_RnrNameSpaceIdForString(
    IN      PCHAR           pchName,
    IN      INT             cchNameLength
    );

DWORD
Dns_RnrNameSpaceIdForStringW(
    IN      PWSTR           pwsName
    );

PCHAR
Dns_GetRnrNameSpaceIdString(
    IN      DWORD           dwFlag
    );


//
//  Hostent utilities
//

BOOL
Hostent_IsSupportedAddrType(
    IN      WORD            wType
    );

DWORD
Hostent_Size(
    IN      PHOSTENT        pHostent,
    IN      DNS_CHARSET     CharSetExisting,
    IN      DNS_CHARSET     CharSetTarget,
    IN      PDWORD          pAliasCount,
    IN      PDWORD          pAddrCount
    );

PHOSTENT
Hostent_Copy(
    IN OUT  PBYTE *         ppBuffer,
    IN OUT  PINT            pBufferSize,
    OUT     PINT            pHostentSize,
    IN      PHOSTENT        pHostent,
    IN      DNS_CHARSET     CharSetIn,
    IN      DNS_CHARSET     CharSetTarget,
    IN      BOOL            fOffsets,
    IN      BOOL            fAlloc
    );

DWORD
Hostent_WriteIp4Addrs(
    IN OUT  PHOSTENT        pHostent,
    OUT     PCHAR           pAddrBuf,
    IN      DWORD           MaxBufCount,
    IN      PIP4_ADDRESS    Ip4Array,
    IN      DWORD           ArrayCount,
    IN      BOOL            fScreenZero
    );

DWORD
Hostent_WriteLocalIp4Array(
    IN OUT  PHOSTENT        pHostent,
    OUT     PCHAR           pAddrBuf,
    IN      DWORD           MaxBufCount,
    IN      PIP4_ARRAY      pIpArray
    );

BOOL
Hostent_IsAddressInHostent(
    IN OUT  PHOSTENT        pHostent,
    IN      PCHAR           pAddr,
    IN      DWORD           AddrLength,
    IN      INT             Family          OPTIONAL
    );

BOOL
Hostent_IsIp4AddressInHostent(
    IN OUT  PHOSTENT        pHostent,
    IN      IP4_ADDRESS     Ip4Addr
    );


//
//  Hostent Object
//

typedef struct _HostentBlob
{
    PHOSTENT    pHostent;

    //  flags
    BOOL        fAllocatedBlob;
    BOOL        fAllocatedBuf;

    //  buffer allocated
    PCHAR       pBuffer;
    DWORD       BufferLength;

    DWORD       AvailLength;
    PCHAR       pAvailBuffer;

    //  buffer in build
    PCHAR       pCurrent;
    DWORD       BytesLeft;

    //  sizing info
    DWORD       MaxAliasCount;
    DWORD       MaxAddrCount;

    //  hostent building
    DWORD       AliasCount;
    DWORD       AddrCount;
    BOOL        fWroteName;
    DNS_CHARSET CharSet;
    BOOL        fUnicode;
}
HOSTENT_BLOB, *PHOSTENT_BLOB;


typedef struct _HostentInitRequest
{
    INT         AddrFamily;
    WORD        wType;
    DWORD       AddrCount;
    BOOL        fUnicode;
    DNS_CHARSET CharSet;
    DWORD       NameLength;
    PBYTE       pName;
    DWORD       AliasCount;
    DWORD       AliasNameLength;
}
HOSTENT_INIT, *PHOSTENT_INIT;



DNS_STATUS
HostentBlob_Create(
    IN OUT  PHOSTENT_BLOB * ppBlob,
    IN      PHOSTENT_INIT   pReq
    );

PHOSTENT_BLOB
HostentBlob_CreateAttachExisting(
    IN      PHOSTENT        pHostent,
    IN      BOOL            fUnicode
    );

VOID
HostentBlob_Free(
    IN OUT  PHOSTENT_BLOB   pBlob
    );

DNS_STATUS
HostentBlob_WriteAddress(
    IN OUT  PHOSTENT_BLOB   pBlob,
    IN      PVOID           pAddress,
    IN      DWORD           AddrSize,
    IN      DWORD           AddrType
    );

DNS_STATUS
HostentBlob_WriteAddressArray(
    IN OUT  PHOSTENT_BLOB   pBlob,
    IN      PVOID           pAddrArray,
    IN      DWORD           AddrCount,
    IN      DWORD           AddrSize,
    IN      DWORD           AddrType
    );

DNS_STATUS
HostentBlob_WriteNameOrAlias(
    IN OUT  PHOSTENT_BLOB   pBlob,
    IN      PSTR            pszName,
    IN      BOOL            fAlias,
    IN      BOOL            fUnicode
    );

DNS_STATUS
HostentBlob_WriteRecords(
    IN OUT  PHOSTENT_BLOB   pBlob,
    IN      PDNS_RECORD     pRecords,
    IN      BOOL            fWriteName
    );

//  Special hostents

PHOSTENT_BLOB
Hostent_Localhost(
    IN      INT             AddrFamily
    );

DNS_STATUS
HostentBlob_CreateFromIpArray(
    IN OUT  PHOSTENT_BLOB * ppBlob,
    IN      INT             AddrFamily,
    IN      INT             AddrSize,
    IN      INT             AddrCount,
    IN      PCHAR           pArray,
    IN      PSTR            pName,
    IN      BOOL            fUnicode
    );

DNS_STATUS
HostentBlob_CreateLocal(
    IN OUT  PHOSTENT_BLOB * ppBlob,
    IN      INT             AddrFamily,
    IN      BOOL            fLoopback,
    IN      BOOL            fZero,
    IN      BOOL            fHostnameOnly
    );

//  Query for hostent

PHOSTENT_BLOB
HostentBlob_Query(
    IN      PWSTR           pwsName,
    IN      WORD            wType,
    IN      DWORD           Flags,
    IN OUT  PVOID *         ppMsg,      OPTIONAL
    IN      INT             AddrFamily  OPTIONAL
    );



//
//  Sockaddr blob stuff (for RnR)
//

typedef DNS_SOCKADDR_RESULTS    SABLOB, *PSABLOB;


PSABLOB
SaBlob_Create(
    IN      DWORD           AddrCount
    );

VOID
SaBlob_Free(
    IN OUT  PSABLOB         pBlob
    );

DNS_STATUS
SaBlob_WriteNameOrAlias(
    IN OUT  PSABLOB         pBlob,
    IN      PWSTR           pszName,
    IN      BOOL            fAlias
    );

PSABLOB
SaBlob_CreateFromIp4(
    IN      PWSTR           pName,
    IN      DWORD           AddrCount,
    IN      PIP4_ADDRESS    pIpArray
    );

PSABLOB
SaBlob_Query(
    IN      PWSTR           pwsName,
    IN      WORD            wType,
    IN      DWORD           Flags,
    IN OUT  PVOID *         ppMsg,      OPTIONAL
    IN      INT             AddrFamily  OPTIONAL
    );

PHOSTENT
SaBlob_CreateHostent(
    IN OUT  PBYTE *         ppBuffer,
    IN OUT  PINT            pBufferSize,
    OUT     PINT            pHostentSize,
    IN      PSABLOB         pBlob,
    IN      DNS_CHARSET     CharSetTarget,
    IN      BOOL            fOffsets,
    IN      BOOL            fAlloc
    );


//
//  Memory allocation
//
//  Some DNS library functions -- including the IP array and string utils
//  -- allocate memory.  This memory allocation defaults to routines that
//  use LocalAlloc, LocalReAlloc, LocalFree.  If you desire alternative
//  memory allocation mechanisms, use this function to override the DNS
//  library defaults.  All memory allocated by the DNS library, should
//  then be freed by the corresponding function.
//

typedef PVOID   (* DNSLIB_ALLOC_FUNCTION)();
typedef PVOID   (* DNSLIB_REALLOC_FUNCTION)();
typedef VOID    (* DNSLIB_FREE_FUNCTION)();

VOID
Dns_LibHeapReset(
    IN      DNSLIB_ALLOC_FUNCTION   pAlloc,
    IN      DNSLIB_REALLOC_FUNCTION pRealloc,
    IN      DNSLIB_FREE_FUNCTION    pFree
    );

//
//  These routines call the currently registered allocation functions
//  whether default or reset through Dns_ApiHeapReset()
//

PVOID
Dns_Alloc(
    IN      INT             iSize
    );

PVOID
Dns_AllocZero(
    IN      INT             iSize
    );

PVOID
Dns_Realloc(
    IN OUT  PVOID           pMem,
    IN      INT             iSize
    );

VOID
Dns_Free(
    IN OUT  PVOID           pMem
    );

PVOID
Dns_AllocMemCopy(
    IN      PVOID           pMem,
    IN      INT             iSize
    );



//
//  DNS Test build
//
//  Allow imbedding of extra info in IP4 arrays to pass to DnsQuery routines.
//

#ifdef  DNSTEST_BUILD

typedef struct _DnsImbeddedExtra
{
    DWORD               Tag;
    PDNS_EXTRA_INFO     pExtraInfo;
}
DNS_IMBEDDED_EXTRA_INFO, *PDNS_IMBEDDED_EXTRA_INFO;

#define DNS_IMBEDDED_EXTRA_INFO_TAG     (0xfedc1234)

#endif



//
//  Print routines (print.c)
//
//  Print routines below use any printf() like function to print.
//  this is typedef that function must match.
//

//
//  Print Locking
//

VOID
DnsPrint_InitLocking(
    IN      PCRITICAL_SECTION   pLock
    );

VOID
DnsPrint_Lock(
    VOID
    );

VOID
DnsPrint_Unlock(
    VOID
    );

#define Dns_PrintInitLocking(a)     DnsPrint_InitLocking(a)
#define Dns_PrintLock()             DnsPrint_Lock()
#define Dns_PrintUnlock()           DnsPrint_Unlock()

//
//  Print routines for general types and structures
//

VOID
DnsPrint_String(
    IN      PRINT_ROUTINE   PrintRoutine,
    IN OUT  PPRINT_CONTEXT  pContext,
    IN      PSTR            pszHeader,      OPTIONAL
    IN      PSTR            pszString,
    IN      BOOL            fUnicode,
    IN      PSTR            pszTrailer      OPTIONAL
    );

VOID
DnsPrint_StringCharSet(
    IN      PRINT_ROUTINE   PrintRoutine,
    IN OUT  PPRINT_CONTEXT  pContext,
    IN      PSTR            pszHeader,      OPTIONAL
    IN      PSTR            pszString,
    IN      DNS_CHARSET     CharSet,
    IN      PSTR            pszTrailer      OPTIONAL
    );

VOID
DnsPrint_Utf8StringBytes(
    IN      PRINT_ROUTINE   PrintRoutine,
    IN OUT  PPRINT_CONTEXT  pContext,
    IN      PSTR            pszHeader,
    IN      PCHAR           pUtf8,
    IN      DWORD           Length
    );

VOID
DnsPrint_UnicodeStringBytes(
    IN      PRINT_ROUTINE   PrintRoutine,
    IN OUT  PPRINT_CONTEXT  pContext,
    IN      PSTR            pszHeader,
    IN      PWCHAR          pUnicode,
    IN      DWORD           Length
    );

VOID
DnsPrint_StringArray(
    IN      PRINT_ROUTINE   PrintRoutine,
    IN OUT  PPRINT_CONTEXT  pContext,
    IN      PSTR            pszHeader,
    IN      PSTR *          StringArray,
    IN      DWORD           Count,          OPTIONAL
    IN      BOOL            fUnicode
    );

VOID
DnsPrint_Argv(
    IN      PRINT_ROUTINE   PrintRoutine,
    IN OUT  PPRINT_CONTEXT  pContext,
    IN      PSTR            pszHeader,
    IN      CHAR **         Argv,
    IN      DWORD           Argc,            OPTIONAL
    IN      BOOL            fUnicode
    );

VOID
DnsPrint_DwordArray(
    IN      PRINT_ROUTINE   PrintRoutine,
    IN OUT  PPRINT_CONTEXT  pContext,
    IN      PSTR            pszHeader,
    IN      PSTR            pszName,
    IN      DWORD           dwCount,
    IN      PDWORD          adwArray
    );

VOID
DnsPrint_Ip4AddressArray(
    IN      PRINT_ROUTINE   PrintRoutine,
    IN OUT  PPRINT_CONTEXT  pContext,
    IN      PSTR            pszHeader,
    IN      PSTR            pszName,
    IN      DWORD           dwIpAddrCount,
    IN      PIP4_ADDRESS    pIpAddrs
    );

VOID
DnsPrint_Ip4Array(
    IN      PRINT_ROUTINE   PrintRoutine,
    IN OUT  PPRINT_CONTEXT  pContext,
    IN      PSTR            pszHeader,
    IN      PSTR            pszName,
    IN      PIP4_ARRAY      pIpArray
    );

VOID
DnsPrint_Ip6Address(
    IN      PRINT_ROUTINE   PrintRoutine,
    IN OUT  PPRINT_CONTEXT  pContext,
    IN      PSTR            pszHeader,
    IN      PIP6_ADDRESS    pIp6Address,
    IN      PSTR            pszTrailer
    );

VOID
DnsPrint_Ip6Array(
    IN      PRINT_ROUTINE   PrintRoutine,
    IN OUT  PPRINT_CONTEXT  pContext,
    IN      PSTR            pszHeader,
    IN      PSTR            pszName,
    IN      PIP6_ARRAY      pIpArray
    );

VOID
DnsPrint_Guid(
    IN      PRINT_ROUTINE   PrintRoutine,
    IN OUT  PPRINT_CONTEXT  pContext,
    IN      PSTR            pszHeader,
    IN      PGUID           pGuid
    );

//
//  Winsock \ RnR types and structures
//

VOID
DnsPrint_FdSet(
    IN      PRINT_ROUTINE   PrintRoutine,
    IN OUT  PPRINT_CONTEXT  pContext,
    IN      PSTR            pszHeader,
    IN      struct fd_set * pFdSet
    );

VOID
DnsPrint_Hostent(
    IN      PRINT_ROUTINE   PrintRoutine,
    IN OUT  PPRINT_CONTEXT  pContext,
    IN      PSTR            pszHeader,
    IN      PHOSTENT        pHostent,
    IN      BOOL            fUnicode
    );

VOID
DnsPrint_Sockaddr(
    IN      PRINT_ROUTINE   PrintRoutine,
    IN OUT  PPRINT_CONTEXT  pContext,
    IN      PSTR            pszHeader,
    IN      DWORD           Indent,
    IN      PSOCKADDR       pSockaddr,
    IN      INT             iSockaddrLength
    );

#ifdef  _WINSOCK2API_
VOID
DnsPrint_SocketAddress(
    IN      PRINT_ROUTINE   PrintRoutine,
    IN OUT  PPRINT_CONTEXT  pContext,
    IN      PSTR            pszHeader,
    IN      DWORD           Indent,
    IN      PSOCKET_ADDRESS pSocketAddress
    );

VOID
DnsPrint_CsAddr(
    IN      PRINT_ROUTINE   PrintRoutine,
    IN OUT  PPRINT_CONTEXT  pContext,
    IN      PSTR            pszHeader,
    IN      DWORD           Indent,
    IN      PCSADDR_INFO    pCsAddrInfo
    );

VOID
DnsPrint_AfProtocolsArray(
    IN      PRINT_ROUTINE   PrintRoutine,
    IN OUT  PPRINT_CONTEXT  pContext,
    IN      PSTR            pszHeader,
    IN      PAFPROTOCOLS    pProtocolArray,
    IN      DWORD           ProtocolCount
    );

VOID
DnsPrint_WsaQuerySet(
    IN      PRINT_ROUTINE   PrintRoutine,
    IN OUT  PPRINT_CONTEXT  pContext,
    IN      PSTR            pszHeader,
    IN      LPWSAQUERYSET   pQuerySet,
    IN      BOOL            fUnicode
    );

VOID
DnsPrint_WsaNsClassInfo(
    IN      PRINT_ROUTINE   PrintRoutine,
    IN OUT  PPRINT_CONTEXT  pContext,
    IN      PSTR            pszHeader,
    IN      PWSANSCLASSINFO pInfo,
    IN      BOOL            fUnicode
    );

VOID
DnsPrint_WsaServiceClassInfo(
    IN      PRINT_ROUTINE           PrintRoutine,
    IN OUT  PPRINT_CONTEXT          pContext,
    IN      PSTR                    pszHeader,
    IN      LPWSASERVICECLASSINFO   pInfo,
    IN      BOOL                    fUnicode
    );
#endif

#ifdef  _WS2TCPIP_H_
VOID
DnsPrint_AddrInfoEx(
    IN      PRINT_ROUTINE   PrintRoutine,
    IN OUT  PPRINT_CONTEXT  pContext,
    IN      PSTR            pszHeader,
    IN      DWORD           Indent,
    IN      PADDRINFO       pAddrInfo,
    IN      BOOL            fUnicode
    );
VOID
DnsPrint_AddrInfoListEx(
    IN      PRINT_ROUTINE   PrintRoutine,
    IN OUT  PPRINT_CONTEXT  pContext,
    IN      PSTR            pszHeader,
    IN      DWORD           Indent,
    IN      PADDRINFO       pAddrInfo,
    IN      BOOL            fUnicode
    );

//  ANSI ADDRINFO

#define DnsPrint_AddrInfo( pr, c, h, i, pa )    \
        DnsPrint_AddrInfoEx( pr, c, h, i, pa, FALSE )

#define DnsPrint_AddrInfoList( pr, c, h, i, pa )    \
        DnsPrint_AddrInfoListEx( pr, c, h, i, pa, FALSE )

//  Unicode ADDRINFOW

#define DnsPrint_AddrInfoW( pr, c, h, i, pa )    \
        DnsPrint_AddrInfoEx( pr, c, h, i, pa, TRUE )

#define DnsPrint_AddrInfoListW( pr, c, h, i, pa )    \
        DnsPrint_AddrInfoListEx( pr, c, h, i, pa, TRUE )
#endif


#ifdef  IP_TYPES_INCLUDED
VOID
DnsPrint_IpAdapterAddress(
    IN      PRINT_ROUTINE           PrintRoutine,
    IN OUT  PPRINT_CONTEXT          pContext,
    IN      PSTR                    pszHeader,
    IN      PVOID                   pAddr,
    IN      BOOL                    fUnicast,
    IN      BOOL                    fPrintList
    );

VOID
DnsPrint_IpAdapterList(
    IN      PRINT_ROUTINE           PrintRoutine,
    IN OUT  PPRINT_CONTEXT          pContext,
    IN      PSTR                    pszHeader,
    IN      PIP_ADAPTER_ADDRESSES   pAdapt,
    IN      BOOL                    fPrintAddressLists,
    IN      BOOL                    fPrintList
    );
#endif


//
//  Print routines for DNS types and structures
//

VOID
DnsPrint_DnsAddrLine(
    IN      PRINT_ROUTINE   PrintRoutine,
    IN OUT  PPRINT_CONTEXT  pContext,
    IN      PSTR            pszHeader,
    IN      PDNS_ADDR       pAddr,
    IN      PSTR            pszTrailer
    );

VOID
DnsPrint_DnsAddr(
    IN      PRINT_ROUTINE   PrintRoutine,
    IN OUT  PPRINT_CONTEXT  pContext,
    IN      PSTR            pszHeader,
    IN      DWORD           Indent,
    IN      PDNS_ADDR       pAddr
    );

VOID
DnsPrint_DnsAddrArray(
    IN      PRINT_ROUTINE   PrintRoutine,
    IN OUT  PPRINT_CONTEXT  pContext,
    IN      PSTR            pszHeader,
    IN      PSTR            pszName,
    IN      PDNS_ADDR_ARRAY pArray
    );

VOID
DnsPrint_Message(
    IN      PRINT_ROUTINE   PrintRoutine,
    IN OUT  PPRINT_CONTEXT  pContext,
    IN      PSTR            pszHeader,
    IN      PDNS_MSG_BUF    pMsg
    );

VOID
DnsPrint_MessageNoContext(
    IN      PRINT_ROUTINE   PrintRoutine,
    IN OUT  PPRINT_CONTEXT  pContext,
    IN      PSTR            pszHeader,
    IN      PDNS_HEADER     pMsgHead,
    IN      WORD            wLength
    );

INT
DnsPrint_PacketName(
    IN      PRINT_ROUTINE   PrintRoutine,
    IN OUT  PPRINT_CONTEXT  pContext,
    IN      PSTR            pszHeader,      OPTIONAL
    IN      PBYTE           pMsgName,
    IN      PDNS_HEADER     pMsgHead,       OPTIONAL
    IN      PBYTE           pMsgEnd,        OPTIONAL
    IN      PSTR            pszTrailer      OPTIONAL
    );

INT
DnsPrint_PacketRecord(
    IN      PRINT_ROUTINE       PrintRoutine,
    IN OUT  PPRINT_CONTEXT      pContext,
    IN      PSTR                pszHeader,
    IN      PDNS_WIRE_RECORD    pMsgRR,
    IN      PDNS_HEADER         pMsgHead,       OPTIONAL
    IN      PBYTE               pMsgEnd         OPTIONAL
    );

VOID
DnsPrint_ParsedRecord(
    IN      PRINT_ROUTINE   PrintRoutine,
    IN OUT  PPRINT_CONTEXT  pContext,
    IN      PSTR            pszHeader,
    IN      PDNS_PARSED_RR  pParsedRR
    );

VOID
DnsPrint_RawOctets(
    IN      PRINT_ROUTINE   PrintRoutine,
    IN OUT  PPRINT_CONTEXT  pContext,
    IN      PSTR            pszHeader,
    IN      PSTR            pszLineHeader,
    IN      PCHAR           pchData,
    IN      DWORD           dwLength
    );

VOID
DnsPrint_ParsedMessage(
    IN      PRINT_ROUTINE       PrintRoutine,
    IN OUT  PPRINT_CONTEXT      pContext,
    IN      PSTR                pszHeader,
    IN      PDNS_PARSED_MESSAGE pParsed
    );

VOID
DnsPrint_HostentBlob(
    IN      PRINT_ROUTINE   PrintRoutine,
    IN OUT  PPRINT_CONTEXT  pContext,
    IN      PSTR            pszHeader,
    IN      PHOSTENT_BLOB   pBlob
    );

VOID
DnsPrint_SaBlob(
    IN      PRINT_ROUTINE   PrintRoutine,
    IN OUT  PPRINT_CONTEXT  pContext,
    IN      PSTR            pszHeader,
    IN      PSABLOB         pBlob
    );


//
//  Print to string
//

#define GUID_STRING_BUFFER_LENGTH   (80)

DWORD
DnsStringPrint_Guid(
    OUT     PCHAR           pBuffer,
    IN      PGUID           pGuid
    );

DWORD
DnsStringPrint_RawOctets(
    OUT     PCHAR           pBuffer,
    IN      PCHAR           pchData,
    IN      DWORD           dwLength,
    IN      PSTR            pszLineHeader,
    IN      DWORD           dwLineLength
    );

//
//  Print related utilities
//

INT
Dns_WriteFormattedSystemTimeToBuffer(
    OUT     PCHAR           pBuffer,
    IN      PSYSTEMTIME     pSystemTime
    );

INT
Dns_WritePacketNameToBuffer(
    OUT     PCHAR           pBuffer,
    OUT     PCHAR *         ppBufferOut,
    IN      PBYTE           pMsgName,
    IN      PDNS_HEADER     pMsgHead,       OPTIONAL
    IN      PBYTE           pMsgEnd         OPTIONAL
    );

PCHAR
Dns_ResponseCodeString(
    IN      INT     ResponseCode
    );

PCHAR
Dns_ResponseCodeExplanationString(
    IN      INT     ResponseCode
    );

PCHAR
Dns_KeyFlagString(
    IN OUT      PCHAR   pszBuff,
    IN          WORD    flags
    );

PCHAR
Dns_OpcodeString(
    IN      INT     Opcode
    );

CHAR
Dns_OpcodeCharacter(
    IN      INT     Opcode
    );

PCHAR
Dns_SectionNameString(
    IN      INT     iSection,
    IN      INT     iOpcode
    );

//
//  Record printing (rrprint.c)
//

VOID
DnsPrint_Record(
    IN      PRINT_ROUTINE   PrintRoutine,
    IN OUT  PPRINT_CONTEXT  pContext,
    IN      PSTR            pszHeader,
    IN      PDNS_RECORD     pRecord,
    IN      PDNS_RECORD     pPreviousRecord     OPTIONAL
    );

VOID
DnsPrint_RecordSet(
    IN      PRINT_ROUTINE   PrintRoutine,
    IN OUT  PPRINT_CONTEXT  pContext,
    IN      PSTR            pszHeader,
    IN      PDNS_RECORD     pRecord
    );

//
//  Macros to get correct string type (utf8\unicode) for printing.
//

//  Empty string for simple switching of UTF-8/Unicode print

extern DWORD   DnsEmptyString;

#define pDnsEmptyString         ( (PSTR) &DnsEmptyString )
#define pDnsEmptyWideString     ( (PWSTR) &DnsEmptyString )


#define DNSSTRING_UTF8( fUnicode, String ) \
        ( (fUnicode) ? pDnsEmptyString : (PSTR)(String) )

#define DNSSTRING_ANSI( fUnicode, String ) \
        ( (fUnicode) ? pDnsEmptyString : (PSTR)(String) )

#define DNSSTRING_WIDE( fUnicode, String ) \
        ( (fUnicode) ? (PWSTR)(String) : pDnsEmptyWideString )

#define RECSTRING_UTF8( pRR, String ) \
        DNSSTRING_UTF8( IS_UNICODE_RECORD(pRR), (String) )

#define RECSTRING_WIDE( pRR, String ) \
        DNSSTRING_WIDE( IS_UNICODE_RECORD(pRR), (String) )


#define PRINT_STRING_WIDE_CHARSET( String, CharSet ) \
        ( ((CharSet)==DnsCharSetUnicode) ? (PWSTR)(String) : pDnsEmptyWideString )

#define PRINT_STRING_ANSI_CHARSET( String, CharSet ) \
        ( ((CharSet)==DnsCharSetUnicode) ? pDnsEmptyString : (PSTR)(String) )



//
//  Debugging
//
//  Debug routines.
//

VOID
Dns_StartDebugEx(
    IN      DWORD           DebugFlag,
    IN      PSTR            pszFlagFile,
    IN OUT  PDWORD          pdwExternalFlag,
    IN      PSTR            pszLogFile,
    IN      DWORD           WrapSize,
    IN      BOOL            fUseGlobalFile,
    IN      BOOL            fUseGlobalFlag,
    IN      BOOL            fSetGlobals
    );

VOID
Dns_StartDebug(
    IN      DWORD           DebugFlag,
    IN      PSTR            pszFlagFile,
    IN OUT  PDWORD          pdwExternalFlag,
    IN      PSTR            pszLogFile,
    IN      DWORD           WrapSize
    );

VOID
Dns_EndDebug(
    VOID
    );

VOID
Dns_Assert(
    IN      PSTR            pszFile,
    IN      INT             LineNo,
    IN      PSTR            pszExpr
    );

VOID
DnsDbg_PrintfToDebugger(
    IN      PSTR            Format,
    ...
    );

VOID
DnsDbg_Printf(
    IN      PSTR            Format,
    ...
    );

VOID
DnsDbg_PrintRoutine(
    IN OUT  PPRINT_CONTEXT  pContext,
    IN      PSTR            Format,
    ...
    );

VOID
DnsDbg_Flush(
    VOID
    );

VOID
DnsDbg_WrapLogFile(
    VOID
    );

VOID
DnsDbg_CSEnter(
    IN      PCRITICAL_SECTION   pLock,
    IN      PSTR                pszLockName,
    IN      PSTR                pszFile,
    IN      INT                 LineNo
    );

VOID
DnsDbg_CSLeave(
    IN      PCRITICAL_SECTION   pLock,
    IN      PSTR                pszLockName,
    IN      PSTR                pszFile,
    IN      INT                 LineNo
    );



//
//  Debug flag test
//
//  We make the test against a pointer here which allows library
//  client application to point at a flag that may be dynamically
//  reset.
//

extern  PDWORD  pDnsDebugFlag;
#define IS_DNSDBG_ON(flag)      (*pDnsDebugFlag & DNS_DBG_ ## flag)


//
//  Debugging Bit Flags
//
//  These flags control gross output and are the same for all users
//

#define DNS_DBG_BREAKPOINTS     0x00000001
#define DNS_DBG_DEBUGGER        0x00000002
#define DNS_DBG_FILE            0x00000004
#define DNS_DBG_EVENTLOG        0x00000008
#define DNS_DBG_EXCEPT          0x00000008

#define DNS_DBG_TIMESTAMP       0x10000000
#define DNS_DBG_CONSOLE         0x20000000
#define DNS_DBG_START_BREAK     0x40000000
#define DNS_DBG_FLUSH           0x80000000

#define DNS_DBG_ANY             0xffffffff
#define DNS_DBG_ALL             0xffffffff
#define DNS_DBG_OFF             (0x0)

//
//  Flags specific to library
//

#define DNS_DBG_IPARRAY         0x00000020
#define DNS_DBG_INIT            0x00000040
#define DNS_DBG_REGISTRY        0x00000040
#define DNS_DBG_SOCKET          0x00000040
#define DNS_DBG_WRITE           0x00000080
#define DNS_DBG_READ            0x00000080

#define DNS_DBG_RPC             0x00000100
#define DNS_DBG_STUB            0x00000100
#define DNS_DBG_RECV            0x00000200
#define DNS_DBG_SEND            0x00000400
#define DNS_DBG_TCP             0x00000800

#define DNS_DBG_TRACE           0x00001000
#define DNS_DBG_UPDATE          0x00002000
#define DNS_DBG_FAZ             0x00002000
#define DNS_DBG_SECURITY        0x00004000
#define DNS_DBG_QUERY           0x00008000

#define DNS_DBG_HEAP            0x00010000
#define DNS_DBG_HEAPDBG         0x00020000
#define DNS_DBG_NETINFO         0x00040000
#define DNS_DBG_RNR             0x00080000
#define DNS_DBG_HOSTENT         0x00080000
#define DNS_DBG_SABLOB          0x00080000

//
//  High output detail debugging
//

#define DNS_DBG_RECURSE2        0x00100000
#define DNS_DBG_UPDATE2         0x00200000
#define DNS_DBG_SECURITY2       0x00400000

#define DNS_DBG_RPC2            0x01000000
#define DNS_DBG_STUB2           0x01000000
#define DNS_DBG_INIT2           0x01000000
#define DNS_DBG_NETINFO2        0x01000000
#define DNS_DBG_PARSE2          0x01000000
#define DNS_DBG_LOOKUP2         0x02000000
#define DNS_DBG_WRITE2          0x04000000
#define DNS_DBG_READ2           0x04000000
#define DNS_DBG_LOCK            0x08000000
#define DNS_DBG_LOCKS           0x08000000
#define DNS_DBG_STRING          0x10000000

#define DNS_DBG_HEAP2           0x10000000
#define DNS_DBG_HEAP_CHECK      0x10000000




//
//  Debug macros
//
//  Macros that include debug code in debug versions only,
//  these macro are NULL for retail versions.
//

#if DBG

#define STATIC

#define DNS_PRINT(_a_)          ( DnsDbg_Printf _a_ )

#define DnsPrintfPtrToFunc      DnsDbg_PrintRoutine

#define IF_DNSDBG(flag)         if ( IS_DNSDBG_ON(flag) )
#define ELSE_IF_DNSDBG(flag)    else if ( IS_DNSDBG_ON(flag) )
#define ELSE                    else

#define DNSDBG(flag, _printlist_)   \
        IF_DNSDBG( flag )           \
        {                           \
            ( DnsDbg_Printf _printlist_ ); \
        }

//  protect debug prints with print lock

#define DnsDbg_Lock()           DnsPrint_Lock()
#define DnsDbg_Unlock()         DnsPrint_Unlock()


//
//  Probe
//

#define PROBE(p)    (*p)

//
//  Assert Macros
//

#define DNS_ASSERT( expr )  \
{                       \
    if ( !(expr) )      \
    {                   \
        Dns_Assert( __FILE__, __LINE__, # expr );    \
    }                   \
}

#define TEST_ASSERT( expr )     DNS_ASSERT( expr )

#define FAIL( msg )                         \
{                                           \
    DNS_PRINT(( "FAILURE:  %s\n", msg ));   \
    DNS_ASSERT( FALSE );                    \
}


//
//  Asserts on trailing else
//

#define ELSE_ASSERT( expr ) \
            else                \
            {                   \
                DNS_ASSERT( expr ); \
            }

#define ELSE_ASSERT_FALSE \
            else                \
            {                   \
                DNS_ASSERT( FALSE );\
            }

#define ELSE_FAIL( msg ) \
            else                \
            {                   \
                FAIL( msg );    \
            }

//
//  Assert and print message
//

#define DNS_MSG_ASSERT( pMsg, expr )  \
{                       \
    if ( !(expr) )      \
    {                   \
        debug_MessageBuffer( "FAILED MESSAGE:", (pMsg) ); \
        Dns_Assert( __FILE__, __LINE__, # expr );    \
    }                   \
}


//
//  Debug types and structures
//

#define DnsPR   DnsDbg_PrintRoutine

#define DnsDbg_String(a,b,c,d)              DnsPrint_String(DnsPR,NULL,a,b,c,d)
#define DnsDbg_UnicodeStringBytes(a,b,c)    DnsPrint_UnicodeStringBytes(DnsPR,NULL,a,b,c)
#define DnsDbg_Utf8StringBytes(a,b,c)       DnsPrint_Utf8StringBytes(DnsPR,NULL,a,b,c)
#define DnsDbg_StringArray(a,b,c,d)         DnsPrint_StringArray(DnsPR,NULL,a,b,c,d)
#define DnsDbg_Argv(a,b,c,d)                DnsPrint_Argv(DnsPR,NULL,a,b,c,d)
#define DnsDbg_DwordArray(a,b,c,d)          DnsPrint_DwordArray(DnsPR,NULL,a,b,c,d)
#define DnsDbg_Ip4AddressArray(a,b,c,d)     DnsPrint_Ip4AddressArray(DnsPR,NULL,a,b,c,d)
#define DnsDbg_Ip4Array(a,b,c)              DnsPrint_Ip4Array(DnsPR,NULL,a,b,c)
#define DnsDbg_Ip6Address(a,b,c)            DnsPrint_Ip6Address(DnsPR,NULL,a,b,c)
#define DnsDbg_Ip6Array(a,b,c)              DnsPrint_Ip6Array(DnsPR,NULL,a,b,c)
#define DnsDbg_Guid(a,b)                    DnsPrint_Guid(DnsPR,NULL,a,b)

#define DnsDbg_FdSet(a,b)                   DnsPrint_FdSet(DnsPR,NULL,a,b)
#define DnsDbg_Sockaddr(a,b,c)              DnsPrint_Sockaddr(DnsPR,NULL,a,0,b,c)
#define DnsDbg_SocketAddress(a,b)           DnsPrint_SocketAddress(DnsPR,NULL,a,0,b)
#define DnsDbg_CsAddr(a,b)                  DnsPrint_CsAddr(DnsPR,NULL,a,0,b)
#define DnsDbg_AfProtocolsArray(a,b,c)      DnsPrint_AfProtocolsArray(DnsPR,NULL,a,b,c)
#define DnsDbg_WsaQuerySet(a,b,c)           DnsPrint_WsaQuerySet(DnsPR,NULL,a,b,c)
#define DnsDbg_WsaNsClassInfo(a,b,c)        DnsPrint_WsaNsClassInfo(DnsPR,NULL,a,b,c)
#define DnsDbg_WsaServiceClassInfo(a,b,c)   DnsPrint_WsaServiceClassInfo(DnsPR,NULL,a,b,c)
#define DnsDbg_Hostent(a,b,c)               DnsPrint_Hostent(DnsPR,NULL,a,b,c)
#define DnsDbg_AddrInfo(a,b)                DnsPrint_AddrInfo(DnsPR,NULL,a,0,b)
#define DnsDbg_HostentBlob(a,b)             DnsPrint_HostentBlob(DnsPR,NULL,a,b)
#define DnsDbg_SaBlob(a,b)                  DnsPrint_SaBlob(DnsPR,NULL,a,b)
#define DnsDbg_IpAdapterAddress(a,b,c,d)    DnsPrint_IpAdapterAddress(DnsPR,NULL,a,b,c,d)
#define DnsDbg_IpAdapterList(a,b,c,d)       DnsPrint_IpAdapterList(DnsPR,NULL,a,b,c,d)

#define DnsDbg_DnsAddrLine(a,b,c)           DnsPrint_DnsAddrLine(DnsPR,NULL,a,b,c)
#define DnsDbg_DnsAddr(a,b)                 DnsPrint_DnsAddr(DnsPR,NULL,a,0,b)
#define DnsDbg_DnsAddrArray(a,b,c)          DnsPrint_DnsAddrArray(DnsPR,NULL,a,b,c)
#define DnsDbg_DnsMessage(a,b)              DnsPrint_DnsMessage(DnsPR,NULL,a,b)
#define DnsDbg_Message(a,b)                 DnsPrint_Message(DnsPR,NULL,a,b)
#define DnsDbg_MessageNoContext(a,b,c)      DnsPrint_MessageNoContext(DnsPR,NULL,a,b,c)
#define DnsDbg_Compression(a,b)             DnsPrint_Compression(DnsPR,NULL,a,b)
#define DnsDbg_PacketRecord(a,b,c,d)        DnsPrint_PacketRecord(DnsPR,NULL,a,b,c,d)
#define DnsDbg_PacketName(a,b,c,d,e)        DnsPrint_PacketName(DnsPR,NULL,a,b,c,d,e)
#define DnsDbg_ParsedMessage(a,b)           DnsPrint_ParsedMessage(DnsPR,NULL,(a),(b))

#define DnsDbg_RawOctets(a,b,c,d)           DnsPrint_RawOctets(DnsPR,NULL,a,b,c,d)
#define DnsDbg_Record(a,b)                  DnsPrint_Record(DnsPR,NULL,a,b,NULL)
#define DnsDbg_RecordSet(a,b)               DnsPrint_RecordSet(DnsPR,NULL,a,b)



//
//  Non-Debug
//

#else

#define STATIC static

//
//  Define away debugging operations
//

#define IF_DNSDBG(a)                if (0)
#define ELSE_IF_DNSDBG(a)           if (0)
#define ELSE                        if (0)
#define DNSDBG(flag, _printlist_)
#define DNS_PRINT(_printlist_)

#define DnsDbg_Lock()
#define DnsDbg_Unlock()

#define DnsDbg_CSEnter(a,b,c,d)
#define DnsDbg_CSLeave(a,b,c,d)

#define DnsDbg_String(a,b,c,d)          
#define DnsDbg_UnicodeStringBytes(a,b,c)
#define DnsDbg_Utf8StringBytes(a,b,c)   
#define DnsDbg_DwordArray(a,b,c,d)      
#define DnsDbg_StringArray(a,b,c,d)
#define DnsDbg_Argv(a,b,c,d)            
#define DnsDbg_Ip4AddressArray(a,b,c,d)
#define DnsDbg_Ip4Array(a,b,c)
#define DnsDbg_Ip6Address(a,b,c)
#define DnsDbg_Ip6Array(a,b,c)
#define DnsDbg_Guid(a,b)

#define DnsDbg_FdSet(a,b)               
#define DnsDbg_Sockaddr(a,b,c)          
#define DnsDbg_SocketAddress(a,b)       
#define DnsDbg_CsAddr(a,b)              
#define DnsDbg_AfProtocolsArray(a,b,c)
#define DnsDbg_WsaQuerySet(a,b,c)       
#define DnsDbg_WsaNsClassInfo(a,b,c)
#define DnsDbg_WsaServiceClassInfo(a,b,c)
#define DnsDbg_Hostent(a,b,c)       
#define DnsDbg_AddrInfo(a,b)
#define DnsDbg_HostentBlob(a,b)
#define DnsDbg_SaBlob(a,b)
#define DnsDbg_IpAdapterAddress(a,b,c,d)
#define DnsDbg_IpAdapterList(a,b,c,d)

#define DnsDbg_DnsAddrLine(a,b,c)
#define DnsDbg_DnsAddr(a,b)
#define DnsDbg_DnsAddrArray(a,b,c)
#define DnsDbg_DnsMessage(a,b)          
#define DnsDbg_Message(a,b)             
#define DnsDbg_MessageNoContext(a,b,c)  
#define DnsDbg_Compression(a,b)         
#define DnsDbg_PacketRecord(a,b,c,d)    
#define DnsDbg_PacketName(a,b,c,d,e)    
#define DnsDbg_ParsedMessage(a,b)

#define DnsDbg_RawOctets(a,b,c,d)       
#define DnsDbg_Record(a,b)              
#define DnsDbg_RecordSet(a,b)           


//  backcompat special on sockaddr

#define DnsDbg_SockaddrIn(a,b,c)        

//
//  Handle complilation of DnsPrintf used as passed parameter to
//  print routines
//

#define DnsPrintfPtrToFunc  printf

//
//  Eliminate ASSERTs in retail product
//

#define DNS_ASSERT( expr )
#define TEST_ASSERT( expr )
#define ELSE_ASSERT( expr )
#define ELSE_ASSERT_FALSE
#define DNS_MSG_ASSERT( expr, pMsg )

#define FAIL( msg )
#define ELSE_FAIL( msg )

#define PROBE(p)

#endif // non-DBG



#ifdef __cplusplus
}
#endif  // __cplusplus

#endif // _DNSLIB_INCLUDED_
=== C:/Users/treeman/Desktop/windows nt source code\Source\Win2K3\NT\public\internal\ds\inc\dnsrpc.h ===
/*++

Copyright (c) 1995-2000  Microsoft Corporation

Module Name:

    dnsrpc.h

Abstract:

    Domain Name System (DNS) Server

    DNS Server RPC API to support admin clients.

Author:

    Jim Gilroy (jamesg)     September 1997

Revision History:

    jamesg      April 1997  --  Major revision for NT5

--*/


#ifndef _DNSRPC_INCLUDED_
#define _DNSRPC_INCLUDED_

#include <windns.h>

//
//  Do NOT include dnsapi.h if doing MIDL pass
//

#ifndef  MIDL_PASS
#include <dnsapi.h>
#include <dnslib.h>
#endif


#ifdef __cplusplus
extern "C"
{
#endif  // _cplusplus


//
//  Addressing backcompat
//

#define IP_ADDRESS      IP4_ADDRESS
#define PIP_ADDRESS     PIP4_ADDRESS

#define IP_ARRAY        IP4_ARRAY
#define PIP_ARRAY       PIP4_ARRAY

#define IP_ADDRESS_STRING_LENGTH    IP4_ADDRESS_STRING_LENGTH
#define SIZEOF_IP_ADDRESS           SIZEOF_IP4_ADDRESS

typedef IP6_ADDRESS         IPV6_ADDRESS, *PIPV6_ADDRESS;


//
//  Versioning scheme
//  -----------------
//
//  Every RPC structure has an old (W2K, non-version-numbered) version and
//  at least one new (.NET and post .NET) version. We will be adding
//  completely new copies of each structure as needed with every release.
//  The structure version numbers start at 1 and are independent of between
//  structures. Increment each structure's current version number as
//  required. Structure version do not have to change at product release
//  so we will not tie their versions to release versions.
//
//  New to .NET, the client RPC APIs all take a version number. This is
//  the client version in terms of OS with a minor version number to identify
//  service packs or QFEs where necessary.
//

//
//  For each versioned RPC structure, define the structure's current version
//  and point the generic names of the structure at the current typedefs.
//

#define DNS_RPC_SERVER_INFO_VER         1
#define DNS_RPC_SERVER_INFO             DNS_RPC_SERVER_INFO_DOTNET
#define PDNS_RPC_SERVER_INFO            PDNS_RPC_SERVER_INFO_DOTNET

#define DNS_RPC_ZONE_VER                1
#define DNS_RPC_ZONE                    DNS_RPC_ZONE_DOTNET
#define PDNS_RPC_ZONE                   PDNS_RPC_ZONE_DOTNET

#define DNS_RPC_ZONE_LIST_VER           1
#define DNS_RPC_ZONE_LIST               DNS_RPC_ZONE_LIST_DOTNET
#define PDNS_RPC_ZONE_LIST              PDNS_RPC_ZONE_LIST_DOTNET

#define DNS_RPC_ZONE_INFO_VER           1
#define DNS_RPC_ZONE_INFO               DNS_RPC_ZONE_INFO_DOTNET
#define PDNS_RPC_ZONE_INFO              PDNS_RPC_ZONE_INFO_DOTNET

#define DNS_RPC_ZONE_CREATE_INFO_VER    1
#define DNS_RPC_ZONE_CREATE_INFO        DNS_RPC_ZONE_CREATE_INFO_DOTNET
#define PDNS_RPC_ZONE_CREATE_INFO       PDNS_RPC_ZONE_CREATE_INFO_DOTNET

#define DNS_RPC_FORWARDERS_VER          1
#define DNS_RPC_FORWARDERS              DNS_RPC_FORWARDERS_DOTNET
#define PDNS_RPC_FORWARDERS             PDNS_RPC_FORWARDERS_DOTNET

#define DNS_RPC_ZONE_SECONDARIES_VER    1
#define DNS_RPC_ZONE_SECONDARIES        DNS_RPC_ZONE_SECONDARIES_DOTNET
#define PDNS_RPC_ZONE_SECONDARIES       PDNS_RPC_ZONE_SECONDARIES_DOTNET

#define DNS_RPC_ZONE_DATABASE_VER       1
#define DNS_RPC_ZONE_DATABASE           DNS_RPC_ZONE_DATABASE_DOTNET
#define PDNS_RPC_ZONE_DATABASE          PDNS_RPC_ZONE_DATABASE_DOTNET

#define DNS_RPC_ZONE_TYPE_RESET_VER     1
#define DNS_RPC_ZONE_TYPE_RESET         DNS_RPC_ZONE_TYPE_RESET_DOTNET
#define PDNS_RPC_ZONE_TYPE_RESET        PDNS_RPC_ZONE_TYPE_RESET_DOTNET

#define DNS_RPC_ZONE_RENAME_INFO_VER    1

#define DNS_RPC_ZONE_EXPORT_INFO_VER    1

#define DNS_RPC_ENLIST_DP_VER           1

#define DNS_RPC_ZONE_CHANGE_DP_VER      1

#define DNS_RPC_ENUM_ZONES_FILTER_VER   1


//
//  Use stdcall for our API conventions
//
//  Explicitly state this as C++ compiler will otherwise
//      assume cdecl.
//

#define DNS_API_FUNCTION    __stdcall

//
//  RPC interface
//

#define DNS_INTERFACE_NAME          "DNSSERVER"

//
//  RPC interface version
//

#define DNS_RPC_VERSION             (50)    // NT5

//
//  RPC security
//

#define DNS_RPC_SECURITY            "DnsServerApp"
#define DNS_RPC_SECURITY_AUTH_ID    RPC_C_AUTHN_WINNT

//
//  RPC transports
//

#define DNS_RPC_NAMED_PIPE_W        ( L"\\PIPE\\DNSSERVER" )
#define DNS_RPC_SERVER_PORT_W       ( L"" )
#define DNS_RPC_LPC_EP_W            ( L"DNSSERVERLPC" )

#define DNS_RPC_NAMED_PIPE_A        ( "\\PIPE\\DNSSERVER" )
#define DNS_RPC_SERVER_PORT_A       ( "" )
#define DNS_RPC_LPC_EP_A            ( "DNSSERVERLPC" )

#define DNS_RPC_USE_TCPIP           0x1
#define DNS_RPC_USE_NAMED_PIPE      0x2
#define DNS_RPC_USE_LPC             0x4
#define DNS_RPC_USE_ALL_PROTOCOLS   0xffffffff


//
//  Windows types we define only for MIDL_PASS
//

#ifdef  MIDL_PASS
#define LPSTR [string] char *
#define LPCSTR [string] const char *
#define LPWSTR [string] wchar_t *
#endif


//
//  RPC buffer type for returned data
//

typedef struct _DnssrvRpcBuffer
{
    DWORD                       dwLength;
#ifdef MIDL_PASS
    [size_is(dwLength)] BYTE    Buffer[];
#else
    BYTE                        Buffer[1];      // buffer of dwLength
#endif
}
DNS_RPC_BUFFER, *PDNS_RPC_BUFFER;



//
//  Server data types
//

//
//  Server Information
//

typedef struct _DnsRpcServerInfoW2K
{
    //  version
    //  basic configuration flags

    DWORD       dwVersion;
    UCHAR       fBootMethod;
    BOOLEAN     fAdminConfigured;
    BOOLEAN     fAllowUpdate;
    BOOLEAN     fDsAvailable;

    //
    //  pointer section
    //

    LPSTR       pszServerName;

    //  DS container

    LPWSTR      pszDsContainer;

    //  IP interfaces

    PIP4_ARRAY  aipServerAddrs;
    PIP4_ARRAY  aipListenAddrs;

    //  forwarders

    PIP4_ARRAY  aipForwarders;

    //  future extensions

    PDWORD      pExtension1;
    PDWORD      pExtension2;
    PDWORD      pExtension3;
    PDWORD      pExtension4;
    PDWORD      pExtension5;

    //
    //  DWORD section
    //

    //  logging

    DWORD       dwLogLevel;
    DWORD       dwDebugLevel;

    //  configuration DWORDs

    DWORD       dwForwardTimeout;
    DWORD       dwRpcProtocol;
    DWORD       dwNameCheckFlag;
    DWORD       cAddressAnswerLimit;
    DWORD       dwRecursionRetry;
    DWORD       dwRecursionTimeout;
    DWORD       dwMaxCacheTtl;
    DWORD       dwDsPollingInterval;

    //  aging \ scavenging

    DWORD       dwScavengingInterval;
    DWORD       dwDefaultRefreshInterval;
    DWORD       dwDefaultNoRefreshInterval;

    DWORD       dwReserveArray[10];

    //
    //  BYTE section
    //
    //  configuration flags

    BOOLEAN     fAutoReverseZones;
    BOOLEAN     fAutoCacheUpdate;

    //  recursion control

    BOOLEAN     fSlave;
    BOOLEAN     fForwardDelegations;
    BOOLEAN     fNoRecursion;
    BOOLEAN     fSecureResponses;

    //  lookup control

    BOOLEAN     fRoundRobin;
    BOOLEAN     fLocalNetPriority;

    //  BIND compatibility and mimicing

    BOOLEAN     fBindSecondaries;
    BOOLEAN     fWriteAuthorityNs;

    //  Bells and whistles

    BOOLEAN     fStrictFileParsing;
    BOOLEAN     fLooseWildcarding;

    //  aging \ scavenging

    BOOLEAN     fDefaultAgingState;
    BOOLEAN     fReserveArray[15];
}
DNS_RPC_SERVER_INFO_W2K, *PDNS_RPC_SERVER_INFO_W2K;


typedef struct _DnsRpcServerInfoDotNet
{
    DWORD       dwRpcStructureVersion;
    DWORD       dwReserved0;

    //  basic configuration flags

    DWORD       dwVersion;
    UCHAR       fBootMethod;
    BOOLEAN     fAdminConfigured;
    BOOLEAN     fAllowUpdate;
    BOOLEAN     fDsAvailable;

    //
    //  pointer section
    //

    LPSTR       pszServerName;

    //  DS container

    LPWSTR      pszDsContainer;

    //  IP interfaces

    PIP4_ARRAY  aipServerAddrs;
    PIP4_ARRAY  aipListenAddrs;

    //  forwarders

    PIP4_ARRAY  aipForwarders;

    //  logging

    PIP4_ARRAY  aipLogFilter;
    LPWSTR      pwszLogFilePath;

    //  Server domain/forest

    LPSTR       pszDomainName;          //  UTF-8 FQDN 
    LPSTR       pszForestName;          //  UTF-8 FQDN 

    //  Built-in directory partitions

    LPSTR       pszDomainDirectoryPartition;    //  UTF-8 FQDN 
    LPSTR       pszForestDirectoryPartition;    //  UTF-8 FQDN 

    //  future extensions

    LPSTR       pExtensions[ 6 ];

    //
    //  DWORD section
    //

    //  logging

    DWORD       dwLogLevel;
    DWORD       dwDebugLevel;

    //  configuration DWORDs

    DWORD       dwForwardTimeout;
    DWORD       dwRpcProtocol;
    DWORD       dwNameCheckFlag;
    DWORD       cAddressAnswerLimit;
    DWORD       dwRecursionRetry;
    DWORD       dwRecursionTimeout;
    DWORD       dwMaxCacheTtl;
    DWORD       dwDsPollingInterval;
    DWORD       dwLocalNetPriorityNetMask;

    //  aging and scavenging

    DWORD       dwScavengingInterval;
    DWORD       dwDefaultRefreshInterval;
    DWORD       dwDefaultNoRefreshInterval;
    DWORD       dwLastScavengeTime;

    //  more logging

    DWORD       dwEventLogLevel;
    DWORD       dwLogFileMaxSize;

    //  Active Directory information

    DWORD       dwDsForestVersion;
    DWORD       dwDsDomainVersion;
    DWORD       dwDsDsaVersion;

    DWORD       dwReserveArray[ 4 ];

    //
    //  BYTE section
    //
    //  configuration flags

    BOOLEAN     fAutoReverseZones;
    BOOLEAN     fAutoCacheUpdate;

    //  recursion control

    BOOLEAN     fSlave;
    BOOLEAN     fForwardDelegations;
    BOOLEAN     fNoRecursion;
    BOOLEAN     fSecureResponses;

    //  lookup control

    BOOLEAN     fRoundRobin;
    BOOLEAN     fLocalNetPriority;

    //  BIND compatibility and mimicing

    BOOLEAN     fBindSecondaries;
    BOOLEAN     fWriteAuthorityNs;

    //  Bells and whistles

    BOOLEAN     fStrictFileParsing;
    BOOLEAN     fLooseWildcarding;

    //  aging \ scavenging

    BOOLEAN     fDefaultAgingState;

    BOOLEAN     fReserveArray[ 15 ];
}
DNS_RPC_SERVER_INFO_DOTNET, *PDNS_RPC_SERVER_INFO_DOTNET;


//  typedef IP4_ARRAY DNS_RPC_LISTEN_ADDRESSES, *PDNS_RPC_LISTEN_ADDRESSES;


typedef struct _DnssrvRpcForwardersW2K
{
    DWORD       fSlave;
    DWORD       dwForwardTimeout;
    PIP4_ARRAY  aipForwarders;
}
DNS_RPC_FORWARDERS_W2K, *PDNS_RPC_FORWARDERS_W2K;


typedef struct _DnssrvRpcForwardersDotNet
{
    DWORD       dwRpcStructureVersion;
    DWORD       dwReserved0;

    DWORD       fSlave;
    DWORD       dwForwardTimeout;
    PIP4_ARRAY  aipForwarders;
}
DNS_RPC_FORWARDERS_DOTNET, *PDNS_RPC_FORWARDERS_DOTNET;



//
//  Server API
//

DNS_STATUS
DNS_API_FUNCTION
DnssrvGetServerInfo(
    IN      LPCWSTR                 pwszServer,
    OUT     PDNS_RPC_SERVER_INFO *  ppServerInfo
    );

VOID
DNS_API_FUNCTION
DnssrvFreeServerInfo(
    IN OUT  PDNS_RPC_SERVER_INFO    pServerInfo
    );

DNS_STATUS
DNS_API_FUNCTION
DnssrvResetServerDwordProperty(
    IN      LPCWSTR             pwszServer,
    IN      LPCSTR              pszProperty,
    IN      DWORD               dwPropertyValue
    );

DNS_STATUS
DNS_API_FUNCTION
DnssrvResetServerListenAddresses(
    IN      LPCWSTR             pwszServer,
    IN      DWORD               cListenAddrs,
    IN      PIP4_ADDRESS        aipListenAddrs
    );

DNS_STATUS
DNS_API_FUNCTION
DnssrvResetForwarders(
    IN      LPCWSTR             pwszServer,
    IN      DWORD               cForwarders,
    IN      PIP4_ADDRESS        aipForwarders,
    IN      DWORD               dwForwardTimeout,
    IN      DWORD               fSlave
    );

DNS_STATUS
DNS_API_FUNCTION
DnssrvWriteDirtyZones(
    IN      LPCWSTR             pwszServer
    );

VOID
DNS_API_FUNCTION
DnssrvFreeRpcBuffer(
    IN OUT  PDNS_RPC_BUFFER pBuf
    );

//
//  Create DS\LDAP paths to objects
//

LPWSTR
DNS_API_FUNCTION
DnssrvCreateDsNodeName(
    IN      PDNS_RPC_SERVER_INFO    pServerInfo,
    IN      LPWSTR                  pszZone,
    IN      LPWSTR                  pszNode
    );

LPWSTR
DNS_API_FUNCTION
DnssrvCreateDsZoneName(
    IN      PDNS_RPC_SERVER_INFO    pServerInfo,
    IN      LPWSTR                  pszZone
    );

LPWSTR
DNS_API_FUNCTION
DnssrvCreateDsServerName(
    IN      PDNS_RPC_SERVER_INFO    pServerInfo
    );



//
//  DNS server statistics
//

typedef struct  _DnsSystemTime
{
    WORD    wYear;
    WORD    wMonth;
    WORD    wDayOfWeek;
    WORD    wDay;
    WORD    wHour;
    WORD    wMinute;
    WORD    wSecond;
    WORD    wMilliseconds;
}
DNS_SYSTEMTIME;

//
//  Server run time stats
//  Each stat has header followed by stat data.
//

//  Stat header

typedef struct _DnsStatHeader
{
    DWORD       StatId;
    WORD        wLength;
    BOOLEAN     fClear;
    UCHAR       fReserved;
}
DNSSRV_STAT_HEADER, *PDNSSRV_STAT_HEADER;

//  Generic stat buffer

typedef struct _DnsStat
{
    DNSSRV_STAT_HEADER  Header;
    BYTE                Buffer[1];
}
DNSSRV_STAT, *PDNSSRV_STAT;

//  DCR_CLEANUP:  remove when marco in ssync

typedef DNSSRV_STAT     DNSSRV_STATS;
typedef PDNSSRV_STAT    PDNSSRV_STATS;

#define DNSSRV_STATS_HEADER_LENGTH  (2*sizeof(DWORD))

//  Total length of stats buffer

#define TOTAL_STAT_LENGTH( pStat ) \
            ( (pStat)->Header.wLength + sizeof(DNSSRV_STAT_HEADER) )

//  Stat buffer traversal macro, no side effects in argument

#define GET_NEXT_STAT_IN_BUFFER( pStat ) \
            ((PDNSSRV_STAT)( (PCHAR)(pStat) + TOTAL_STAT_LENGTH(pStat) ))


//
//  Stats that record type data
//      - ATMA plus room to grow, so don't have to
//      rebuild for any change
//      - use some dead types for mixed and unknown
//      cases
//

#define STATS_TYPE_MAX          (DNS_TYPE_ATMA+5)

#define STATS_TYPE_MIXED        (DNS_TYPE_MD)
#define STATS_TYPE_UNKNOWN      (DNS_TYPE_MF)


//
//  Specific stat data types
//

//
//  Time info
//

typedef struct _DnsTimeStats
{
    DNSSRV_STAT_HEADER  Header;

    DWORD   ServerStartTimeSeconds;
    DWORD   LastClearTimeSeconds;
    DWORD   SecondsSinceServerStart;
    DWORD   SecondsSinceLastClear;

    DNS_SYSTEMTIME  ServerStartTime;
    DNS_SYSTEMTIME  LastClearTime;
}
DNSSRV_TIME_STATS, *PDNSSRV_TIME_STATS;

//
//  Basic query and response stats
//

typedef struct _DnsQueryStats
{
    DNSSRV_STAT_HEADER  Header;

    DWORD   UdpQueries;
    DWORD   UdpResponses;
    DWORD   UdpQueriesSent;
    DWORD   UdpResponsesReceived;
    DWORD   TcpClientConnections;
    DWORD   TcpQueries;
    DWORD   TcpResponses;
    DWORD   TcpQueriesSent;
    DWORD   TcpResponsesReceived;
}
DNSSRV_QUERY_STATS, *PDNSSRV_QUERY_STATS;

typedef struct _DnsQuery2Stats
{
    DNSSRV_STAT_HEADER  Header;

    DWORD   TotalQueries;
    DWORD   Standard;
    DWORD   Notify;
    DWORD   Update;
    DWORD   TKeyNego;

    //  NOTE: the breakout counts are for STANDARD QUERIES!
    DWORD   TypeA;
    DWORD   TypeNs;
    DWORD   TypeSoa;
    DWORD   TypeMx;
    DWORD   TypePtr;
    DWORD   TypeSrv;
    DWORD   TypeAll;
    DWORD   TypeIxfr;
    DWORD   TypeAxfr;
    DWORD   TypeOther;
}
DNSSRV_QUERY2_STATS, *PDNSSRV_QUERY2_STATS;


//
//  Recursion stats
//

typedef struct _DnsRecurseStats
{
    DNSSRV_STAT_HEADER  Header;

    DWORD   ReferralPasses;
    DWORD   QueriesRecursed;
    DWORD   OriginalQuestionRecursed;
    DWORD   AdditionalRecursed;
    DWORD   TotalQuestionsRecursed;
    DWORD   Retries;
    DWORD   LookupPasses;
    DWORD   Forwards;
    DWORD   Sends;

    DWORD   Responses;
    DWORD   ResponseUnmatched;
    DWORD   ResponseMismatched;
    DWORD   ResponseFromForwarder;
    DWORD   ResponseAuthoritative;
    DWORD   ResponseNotAuth;
    DWORD   ResponseAnswer;
    DWORD   ResponseNameError;
    DWORD   ResponseRcode;
    DWORD   ResponseEmpty;
    DWORD   ResponseDelegation;
    DWORD   ResponseNonZoneData;
    DWORD   ResponseUnsecure;
    DWORD   ResponseBadPacket;

    DWORD   SendResponseDirect;
    DWORD   ContinueCurrentRecursion;
    DWORD   ContinueCurrentLookup;
    DWORD   ContinueNextLookup;

    DWORD   RootNsQuery;
    DWORD   RootNsResponse;
    DWORD   CacheUpdateAlloc;
    DWORD   CacheUpdateResponse;
    DWORD   CacheUpdateFree;
    DWORD   CacheUpdateRetry;
    DWORD   SuspendedQuery;
    DWORD   ResumeSuspendedQuery;

    DWORD   PacketTimeout;
    DWORD   FinalTimeoutQueued;
    DWORD   FinalTimeoutExpired;

    DWORD   Failures;
    DWORD   RecursionFailure;
    DWORD   ServerFailure;
    DWORD   PartialFailure;
    DWORD   CacheUpdateFailure;

    DWORD   RecursePassFailure;
    DWORD   FailureReachAuthority;
    DWORD   FailureReachPreviousResponse;
    DWORD   FailureRetryCount;

    DWORD   TcpTry;
    DWORD   TcpConnectFailure;
    DWORD   TcpConnect;
    DWORD   TcpQuery;
    DWORD   TcpResponse;
    DWORD   TcpDisconnect;

    DWORD   DiscardedDuplicateQueries;
}
DNSSRV_RECURSE_STATS, *PDNSSRV_RECURSE_STATS;

//
//  Master stats
//
//  Masters stats changed post-NT5 for stub zones
//

typedef struct _DnsMasterStats
{
    DNSSRV_STAT_HEADER  Header;

    DWORD   NotifySent;

    DWORD   Request;
    DWORD   NameError;
    DWORD   FormError;
    DWORD   AxfrLimit;
    DWORD   Refused;
    DWORD   RefuseSecurity;
    DWORD   RefuseShutdown;
    DWORD   RefuseZoneLocked;
    DWORD   RefuseServerFailure;
    DWORD   Failure;

    DWORD   AxfrRequest;
    DWORD   AxfrSuccess;

    DWORD   StubAxfrRequest;

    DWORD   IxfrRequest;
    DWORD   IxfrNoVersion;
    DWORD   IxfrUpdateSuccess;
    DWORD   IxfrTcpRequest;
    DWORD   IxfrTcpSuccess;
    DWORD   IxfrAxfr;
    DWORD   IxfrUdpRequest;
    DWORD   IxfrUdpSuccess;
    DWORD   IxfrUdpForceTcp;
    DWORD   IxfrUdpForceAxfr;
}
DNSSRV_MASTER_STATS, *PDNSSRV_MASTER_STATS;

//
//  Secondary stats
//
//  Secondary stats changed post-NT5 for stub zones
//

typedef struct _DnsSecondaryStats
{
    DNSSRV_STAT_HEADER  Header;

    DWORD   NotifyReceived;
    DWORD   NotifyInvalid;
    DWORD   NotifyPrimary;
    DWORD   NotifyNonPrimary;
    DWORD   NotifyNoVersion;
    DWORD   NotifyNewVersion;
    DWORD   NotifyCurrentVersion;
    DWORD   NotifyOldVersion;
    DWORD   NotifyMasterUnknown;

    DWORD   SoaRequest;
    DWORD   SoaResponse;
    DWORD   SoaResponseInvalid;
    DWORD   SoaResponseNameError;

    DWORD   AxfrRequest;
    DWORD   AxfrResponse;
    DWORD   AxfrSuccess;
    DWORD   AxfrRefused;
    DWORD   AxfrInvalid;

    DWORD   StubAxfrRequest;
    DWORD   StubAxfrResponse;
    DWORD   StubAxfrSuccess;
    DWORD   StubAxfrRefused;
    DWORD   StubAxfrInvalid;

    DWORD   IxfrUdpRequest;
    DWORD   IxfrUdpResponse;
    DWORD   IxfrUdpSuccess;
    DWORD   IxfrUdpUseTcp;
    DWORD   IxfrUdpUseAxfr;
    DWORD   IxfrUdpWrongServer;
    DWORD   IxfrUdpNoUpdate;
    DWORD   IxfrUdpNewPrimary;
    DWORD   IxfrUdpFormerr;
    DWORD   IxfrUdpRefused;
    DWORD   IxfrUdpInvalid;

    DWORD   IxfrTcpRequest;
    DWORD   IxfrTcpResponse;
    DWORD   IxfrTcpSuccess;
    DWORD   IxfrTcpAxfr;
    DWORD   IxfrTcpFormerr;
    DWORD   IxfrTcpRefused;
    DWORD   IxfrTcpInvalid;
}
DNSSRV_SECONDARY_STATS, *PDNSSRV_SECONDARY_STATS;


//
//  WINS lookup
//

typedef struct _DnsWinsStats
{
    DNSSRV_STAT_HEADER  Header;

    DWORD   WinsLookups;
    DWORD   WinsResponses;
    DWORD   WinsReverseLookups;
    DWORD   WinsReverseResponses;
}
DNSSRV_WINS_STATS, *PDNSSRV_WINS_STATS;

//
//  Dynamic Update Stats
//

typedef struct _DnsUpdateStats
{
    DNSSRV_STAT_HEADER  Header;

    DWORD   Received;
    DWORD   Empty;
    DWORD   NoOps;
    DWORD   Completed;

    DWORD   Rejected;
    DWORD   FormErr;
    DWORD   NxDomain;
    DWORD   NotImpl;
    DWORD   Refused;
    DWORD   YxDomain;
    DWORD   YxRrset;
    DWORD   NxRrset;
    DWORD   NotAuth;
    DWORD   NotZone;

    DWORD   RefusedNonSecure;
    DWORD   RefusedAccessDenied;

    DWORD   SecureSuccess;
    DWORD   SecureContinue;
    DWORD   SecureFailure;
    DWORD   SecureDsWriteFailure;

    DWORD   DsSuccess;
    DWORD   DsWriteFailure;

    DWORD   unused_was_Collisions;
    DWORD   unused_was_CollisionsRead;
    DWORD   unused_was_CollisionsWrite;
    DWORD   unused_was_CollisionsDsWrite;

    DWORD   Queued;
    DWORD   Retry;
    DWORD   Timeout;
    DWORD   InQueue;

    DWORD   Forwards;
    DWORD   TcpForwards;
    DWORD   ForwardResponses;
    DWORD   ForwardTimeouts;
    DWORD   ForwardInQueue;

    DWORD   UpdateType[ STATS_TYPE_MAX+1 ];
}
DNSSRV_UPDATE_STATS, *PDNSSRV_UPDATE_STATS;


typedef struct _DnsSkwansecStats
{
    DNSSRV_STAT_HEADER  Header;

    DWORD   SecContextCreate;
    DWORD   SecContextFree;
    DWORD   SecContextQueue;
    DWORD   SecContextQueueInNego;
    DWORD   SecContextQueueNegoComplete;
    DWORD   SecContextQueueLength;
    DWORD   SecContextDequeue;
    DWORD   SecContextTimeout;

    DWORD   SecPackAlloc;
    DWORD   SecPackFree;

    DWORD   SecTkeyInvalid;
    DWORD   SecTkeyBadTime;
    DWORD   SecTsigFormerr;
    DWORD   SecTsigEcho;
    DWORD   SecTsigBadKey;
    DWORD   SecTsigVerifySuccess;
    DWORD   SecTsigVerifyFailed;
}
DNSSRV_SKWANSEC_STATS, *PDNSSRV_SKWANSEC_STATS;

//
//  DS Integration Stats
//

typedef struct _DnsDsStats
{
    DNSSRV_STAT_HEADER  Header;

    DWORD   DsTotalNodesRead;
    DWORD   DsTotalRecordsRead;
    DWORD   DsNodesLoaded;
    DWORD   DsRecordsLoaded;
    DWORD   DsTombstonesRead;

    DWORD   DsUpdateSearches;
    DWORD   DsUpdateNodesRead;
    DWORD   DsUpdateRecordsRead;

    //  Update writes

    DWORD   UpdateLists;
    DWORD   UpdateNodes;
    DWORD   UpdateSuppressed;
    DWORD   UpdateWrites;
    DWORD   UpdateTombstones;
    DWORD   UpdateRecordChange;
    DWORD   UpdateAgingRefresh;
    DWORD   UpdateAgingOn;
    DWORD   UpdateAgingOff;
    DWORD   UpdatePacket;
    DWORD   UpdatePacketPrecon;
    DWORD   UpdateAdmin;
    DWORD   UpdateAutoConfig;
    DWORD   UpdateScavenge;

    //  DS writes

    DWORD   DsNodesAdded;
    DWORD   DsNodesModified;
    DWORD   DsNodesTombstoned;
    DWORD   DsNodesDeleted;
    DWORD   DsRecordsAdded;
    DWORD   DsRecordsReplaced;
    DWORD   DsWriteSuppressed;
    DWORD   DsSerialWrites;

    //  Time stats in ldap calls

    DWORD   LdapTimedWrites;
    DWORD   LdapWriteTimeTotal;
    DWORD   LdapWriteAverage;
    DWORD   LdapWriteMax;
    DWORD   LdapWriteBucket0;
    DWORD   LdapWriteBucket1;
    DWORD   LdapWriteBucket2;
    DWORD   LdapWriteBucket3;
    DWORD   LdapWriteBucket4;
    DWORD   LdapWriteBucket5;

    DWORD   LdapSearchTime;

    //  Failures

    DWORD   FailedDeleteDsEntries;
    DWORD   FailedReadRecords;
    DWORD   FailedLdapModify;
    DWORD   FailedLdapAdd;

    //  Polling stats

    DWORD   PollingPassesWithDsErrors;

    //  LDAP stats

    DWORD   LdapReconnects;

    //  DS Write Stats

    DWORD   DsWriteType[ STATS_TYPE_MAX+1 ];
}
DNSSRV_DS_STATS, *PDNSSRV_DS_STATS;


//
//  Memory stats
//
//  Note, memory stats have been added since NT5 ship
//  so maintain NT5 and current memory stats with
//  separate IDs.  See next section for NT5 memory stats
//

//
//  Memory Tags -- post NT5 ordering
//

#define MEMTAG_CURRENT_VERSION      (5)

#define MEMTAG_NONE         0
#define MEMTAG_PACKET_UDP   1
#define MEMTAG_PACKET_TCP   2
#define MEMTAG_NAME         3
#define MEMTAG_ZONE         4
#define MEMTAG_UPDATE       5
#define MEMTAG_UPDATE_LIST  6
#define MEMTAG_TIMEOUT      7
#define MEMTAG_NODEHASH     8
#define MEMTAG_DS_DN        9
#define MEMTAG_DS_MOD       10
#define MEMTAG_DS_RECORD    11
#define MEMTAG_DS_OTHER     12
#define MEMTAG_THREAD       13
#define MEMTAG_NBSTAT       14
#define MEMTAG_DNSLIB       15
#define MEMTAG_TABLE        16
#define MEMTAG_SOCKET       17
#define MEMTAG_CONNECTION   18
#define MEMTAG_REGISTRY     19
#define MEMTAG_RPC          20
#define MEMTAG_STUFF        21
#define MEMTAG_FILEBUF      22
#define MEMTAG_REMOTE       23
#define MEMTAG_EVTCTRL      24
#define MEMTAG_SAFE         25

//
//  Record and Node sources
//

#define SRCTAG_UNKNOWN      (0)
#define SRCTAG_FILE         (1)
#define SRCTAG_DS           (2)
#define SRCTAG_AXFR         (3)
#define SRCTAG_IXFR         (4)
#define SRCTAG_DYNUP        (5)
#define SRCTAG_ADMIN        (6)
#define SRCTAG_AUTO         (7)
#define SRCTAG_CACHE        (8)
#define SRCTAG_NOEXIST      (9)
#define SRCTAG_WINS         (10)
#define SRCTAG_WINSPTR      (11)
#define SRCTAG_COPY         (12)

#define SRCTAG_MAX          (SRCTAG_COPY)       //  12

//
//  Record tags
//
//  Start after last memtag.
//  Use source tags to index off of MEMTAG_RECORD base.
//

#define MEMTAG_RECORD_BASE      (MEMTAG_SAFE+1)                     //  26
#define MEMTAG_RECORD           (MEMTAG_RECORD_BASE)                //  26
#define MEMTAG_RECORD_UNKNOWN   (MEMTAG_RECORD + SRCTAG_UNKNOWN )   //  26
#define MEMTAG_RECORD_FILE      (MEMTAG_RECORD + SRCTAG_FILE    )   //  27
#define MEMTAG_RECORD_DS        (MEMTAG_RECORD + SRCTAG_DS      )
#define MEMTAG_RECORD_AXFR      (MEMTAG_RECORD + SRCTAG_AXFR    )
#define MEMTAG_RECORD_IXFR      (MEMTAG_RECORD + SRCTAG_IXFR    )   //  30
#define MEMTAG_RECORD_DYNUP     (MEMTAG_RECORD + SRCTAG_DYNUP   )
#define MEMTAG_RECORD_ADMIN     (MEMTAG_RECORD + SRCTAG_ADMIN   )
#define MEMTAG_RECORD_AUTO      (MEMTAG_RECORD + SRCTAG_AUTO    )
#define MEMTAG_RECORD_CACHE     (MEMTAG_RECORD + SRCTAG_CACHE   )
#define MEMTAG_RECORD_NOEXIST   (MEMTAG_RECORD + SRCTAG_NOEXIST )   //  35
#define MEMTAG_RECORD_WINS      (MEMTAG_RECORD + SRCTAG_WINS    )
#define MEMTAG_RECORD_WINSPTR   (MEMTAG_RECORD + SRCTAG_WINSPTR )
#define MEMTAG_RECORD_COPY      (MEMTAG_RECORD + SRCTAG_COPY    )   //  38

#define MEMTAG_RECORD_MAX       MEMTAG_RECORD_COPY                  //  38

//
//  Node tags
//

#define MEMTAG_NODE             (MEMTAG_RECORD_MAX + 1)             //  39
#define MEMTAG_NODE_UNKNOWN     (MEMTAG_NODE + SRCTAG_UNKNOWN   )   //  39
#define MEMTAG_NODE_FILE        (MEMTAG_NODE + SRCTAG_FILE      )   //  40
#define MEMTAG_NODE_DS          (MEMTAG_NODE + SRCTAG_DS        )
#define MEMTAG_NODE_AXFR        (MEMTAG_NODE + SRCTAG_AXFR      )
#define MEMTAG_NODE_IXFR        (MEMTAG_NODE + SRCTAG_IXFR      )
#define MEMTAG_NODE_DYNUP       (MEMTAG_NODE + SRCTAG_DYNUP     )
#define MEMTAG_NODE_ADMIN       (MEMTAG_NODE + SRCTAG_ADMIN     )   //  45
#define MEMTAG_NODE_AUTO        (MEMTAG_NODE + SRCTAG_AUTO      )
#define MEMTAG_NODE_CACHE       (MEMTAG_NODE + SRCTAG_CACHE     )
#define MEMTAG_NODE_NOEXIST     (MEMTAG_NODE + SRCTAG_NOEXIST   )
#define MEMTAG_NODE_WINS        (MEMTAG_NODE + SRCTAG_WINS      )
#define MEMTAG_NODE_WINSPTR     (MEMTAG_NODE + SRCTAG_WINSPTR   )   //  50
#define MEMTAG_NODE_COPY        (MEMTAG_NODE + SRCTAG_COPY      )   //  51

#define MEMTAG_NODE_MAX         MEMTAG_NODE_COPY                    //  51

//  Final MemTag values

#define MEMTAG_MAX              MEMTAG_NODE_MAX                     //  51
#define MEMTAG_COUNT            (MEMTAG_MAX+1)                      //  52


//
//  Memory Tag Names
//
//  Note:  DNS client print module (print.c) keeps memtag name table
//      based on these #defines;  that table MUST be kept in same
//      order as actual memtag indexes for printing to be accurate
//

#define MEMTAG_NAME_NONE            ("None")
#define MEMTAG_NAME_PACKET_UDP      ("UDP Packet")
#define MEMTAG_NAME_PACKET_TCP      ("TCP Packet")
#define MEMTAG_NAME_NAME            ("Name")
#define MEMTAG_NAME_ZONE            ("Zone")
#define MEMTAG_NAME_UPDATE          ("Update")
#define MEMTAG_NAME_UPDATE_LIST     ("Update List")
#define MEMTAG_NAME_TIMEOUT         ("Timeout")
#define MEMTAG_NAME_NODEHASH        ("Node Hash")
#define MEMTAG_NAME_DS_DN           ("DS DN")
#define MEMTAG_NAME_DS_MOD          ("DS Mod")
#define MEMTAG_NAME_DS_RECORD       ("DS Record")
#define MEMTAG_NAME_DS_OTHER        ("DS Other")
#define MEMTAG_NAME_THREAD          ("Thread")
#define MEMTAG_NAME_NBSTAT          ("Nbstat")
#define MEMTAG_NAME_DNSLIB          ("DnsLib")
#define MEMTAG_NAME_TABLE           ("Table")
#define MEMTAG_NAME_SOCKET          ("Socket")
#define MEMTAG_NAME_CONNECTION      ("TCP Connection")
#define MEMTAG_NAME_REGISTRY        ("Registry")
#define MEMTAG_NAME_RPC             ("RPC")
#define MEMTAG_NAME_STUFF           ("Stuff")
#define MEMTAG_NAME_FILEBUF         ("File Buffer")
#define MEMTAG_NAME_REMOTE          ("Remote IP")
#define MEMTAG_NAME_EVTCTRL         ("Event Control")
#define MEMTAG_NAME_SAFE            ("Safe")

#define MEMTAG_NAME_RECORD          ("Record")
#define MEMTAG_NAME_RECORD_FILE     ("RR File")
#define MEMTAG_NAME_RECORD_DS       ("RR DS")
#define MEMTAG_NAME_RECORD_AXFR     ("RR AXFR")
#define MEMTAG_NAME_RECORD_IXFR     ("RR IXFR")
#define MEMTAG_NAME_RECORD_DYNUP    ("RR Update")
#define MEMTAG_NAME_RECORD_ADMIN    ("RR Admin")
#define MEMTAG_NAME_RECORD_AUTO     ("RR Auto")
#define MEMTAG_NAME_RECORD_CACHE    ("RR Cache")
#define MEMTAG_NAME_RECORD_NOEXIST  ("RR NoExist")
#define MEMTAG_NAME_RECORD_WINS     ("RR WINS")
#define MEMTAG_NAME_RECORD_WINSPTR  ("RR WINS-PTR")
#define MEMTAG_NAME_RECORD_COPY     ("RR Copy")

#define MEMTAG_NAME_NODE            ("Node")
#define MEMTAG_NAME_NODE_FILE       ("Node File")
#define MEMTAG_NAME_NODE_DS         ("Node DS")
#define MEMTAG_NAME_NODE_AXFR       ("Node AXFR")
#define MEMTAG_NAME_NODE_IXFR       ("Node IXFR")
#define MEMTAG_NAME_NODE_DYNUP      ("Node Update")
#define MEMTAG_NAME_NODE_ADMIN      ("Node Admin")
#define MEMTAG_NAME_NODE_AUTO       ("Node Auto")
#define MEMTAG_NAME_NODE_CACHE      ("Node Cache")
#define MEMTAG_NAME_NODE_NOEXIST    ("Node NoExist")
#define MEMTAG_NAME_NODE_WINS       ("Node WINS")
#define MEMTAG_NAME_NODE_WINSPTR    ("Node WINS-PTR")
#define MEMTAG_NAME_NODE_COPY       ("Node Copy")


//  Individual memory counter

typedef struct _DnsMemoryTagStats
{
    DWORD   Alloc;
    DWORD   Free;
    DWORD   Memory;
}
MEMTAG_STATS, *PMEMTAG_STATS;


//  Memory stat block

typedef struct _DnsMemoryStats
{
    DNSSRV_STAT_HEADER  Header;

    DWORD   Memory;
    DWORD   Alloc;
    DWORD   Free;

    DWORD   StdUsed;
    DWORD   StdReturn;
    DWORD   StdInUse;
    DWORD   StdMemory;

    DWORD   StdToHeapAlloc;
    DWORD   StdToHeapFree;
    DWORD   StdToHeapInUse;
    DWORD   StdToHeapMemory;

    DWORD   StdBlockAlloc;
    DWORD   StdBlockUsed;
    DWORD   StdBlockReturn;
    DWORD   StdBlockInUse;
    DWORD   StdBlockFreeList;
    DWORD   StdBlockFreeListMemory;
    DWORD   StdBlockMemory;

    MEMTAG_STATS    MemTags[ MEMTAG_COUNT ];
}
DNSSRV_MEMORY_STATS, *PDNSSRV_MEMORY_STATS;


//
//  Packet stats
//

typedef struct _DnsPacketStats
{
    DNSSRV_STAT_HEADER  Header;

    DWORD   UdpAlloc;
    DWORD   UdpFree;
    DWORD   UdpNetAllocs;
    DWORD   UdpMemory;

    DWORD   UdpUsed;
    DWORD   UdpReturn;
    DWORD   UdpResponseReturn;
    DWORD   UdpQueryReturn;
    DWORD   UdpInUse;
    DWORD   UdpInFreeList;

    DWORD   TcpAlloc;
    DWORD   TcpRealloc;
    DWORD   TcpFree;
    DWORD   TcpNetAllocs;
    DWORD   TcpMemory;

    DWORD   RecursePacketUsed;
    DWORD   RecursePacketReturn;

    DWORD   PacketsForNsListUsed;
    DWORD   PacketsForNsListReturned;
    DWORD   PacketsForNsListInUse;
}
DNSSRV_PACKET_STATS, *PDNSSRV_PACKET_STATS;

//
//  Timeout stats
//

typedef struct _DnsTimeoutStats
{
    DNSSRV_STAT_HEADER  Header;

    DWORD   SetTotal;
    DWORD   SetDirect;
    DWORD   SetFromDereference;
    DWORD   SetFromChildDelete;
    DWORD   AlreadyInSystem;

    DWORD   Checks;
    DWORD   RecentAccess;
    DWORD   ActiveRecord;
    DWORD   CanNotDelete;
    DWORD   Deleted;

    DWORD   ArrayBlocksCreated;
    DWORD   ArrayBlocksDeleted;

    DWORD   DelayedFreesQueued;
    DWORD   DelayedFreesQueuedWithFunction;
    DWORD   DelayedFreesExecuted;
    DWORD   DelayedFreesExecutedWithFunction;
}
DNSSRV_TIMEOUT_STATS, *PDNSSRV_TIMEOUT_STATS;

//
//  Database Stats
//

typedef struct _DnsDbaseStats
{
    DNSSRV_STAT_HEADER  Header;

    DWORD   NodeMemory;
    DWORD   NodeInUse;
    DWORD   NodeUsed;
    DWORD   NodeReturn;
}
DNSSRV_DBASE_STATS, *PDNSSRV_DBASE_STATS;

//
//  Record stats
//
//  DCR:  add type info (inc name error)
//

typedef struct _DnsRecordStats
{
    DNSSRV_STAT_HEADER  Header;

    DWORD   InUse;
    DWORD   Used;
    DWORD   Return;
    DWORD   Memory;

    DWORD   CacheTotal;
    DWORD   CacheCurrent;
    DWORD   CacheTimeouts;

    DWORD   SlowFreeQueued;
    DWORD   SlowFreeFinished;
}
DNSSRV_RECORD_STATS, *PDNSSRV_RECORD_STATS;

//
//  Nbstat memory stats
//

typedef struct _DnsNbstatStats
{
    DNSSRV_STAT_HEADER  Header;

    DWORD   NbstatAlloc;
    DWORD   NbstatFree;
    DWORD   NbstatNetAllocs;
    DWORD   NbstatMemory;

    DWORD   NbstatUsed;
    DWORD   NbstatReturn;
    DWORD   NbstatInUse;
    DWORD   NbstatInFreeList;
}
DNSSRV_NBSTAT_STATS, *PDNSSRV_NBSTAT_STATS;

//
//  Private stats
//

//
//  Private stats
//

typedef struct _DnsPrivateStats
{
    DNSSRV_STAT_HEADER  Header;

    DWORD   RecordFile;
    DWORD   RecordFileFree;
    DWORD   RecordDs;
    DWORD   RecordDsFree;
    DWORD   RecordAdmin;
    DWORD   RecordAdminFree;
    DWORD   RecordDynUp;
    DWORD   RecordDynUpFree;
    DWORD   RecordAxfr;
    DWORD   RecordAxfrFree;
    DWORD   RecordIxfr;
    DWORD   RecordIxfrFree;
    DWORD   RecordCopy;
    DWORD   RecordCopyFree;
    DWORD   RecordCache;
    DWORD   RecordCacheFree;

    DWORD   UdpSocketPnpDelete;
    DWORD   UdpRecvFailure;
    DWORD   UdpErrorMessageSize;
    DWORD   UdpConnResets;
    DWORD   UdpConnResetRetryOverflow;
    DWORD   UdpGQCSFailure;
    DWORD   UdpGQCSFailureWithContext;
    DWORD   UdpGQCSConnReset;

    DWORD   UdpIndicateRecvFailures;
    DWORD   UdpRestartRecvOnSockets;

    DWORD   TcpConnectAttempt;
    DWORD   TcpConnectFailure;
    DWORD   TcpConnect;
    DWORD   TcpQuery;
    DWORD   TcpDisconnect;

    DWORD   SecTsigVerifyOldSig;
    DWORD   SecTsigVerifyOldFailed;
    DWORD   SecBigTimeSkewBypass;

    DWORD   ZoneLoadInit;
    DWORD   ZoneLoadComplete;
    DWORD   ZoneDbaseDelete;
    DWORD   ZoneDbaseDelayedDelete;
}
DNSSRV_PRIVATE_STATS, *PDNSSRV_PRIVATE_STATS;


//
//  Private stats -- post NT5
//
//  We should dump a bunch of private stats and add
//  others -- but not there yet.
//

#if 0
typedef struct _DnsPrivateStats
{
    DNSSRV_STAT_HEADER  Header;

    DWORD   UdpSocketPnpDelete;
    DWORD   UdpRecvFailure;
    DWORD   UdpErrorMessageSize;
    DWORD   UdpConnResets;
    DWORD   UdpConnResetRetryOverflow;
    DWORD   UdpGQCSFailure;
    DWORD   UdpGQCSFailureWithContext;
    DWORD   UdpGQCSConnReset;

    DWORD   UdpIndicateRecvFailures;
    DWORD   UdpRestartRecvOnSockets;

    DWORD   TcpConnectAttempt;
    DWORD   TcpConnectFailure;
    DWORD   TcpConnect;
    DWORD   TcpQuery;
    DWORD   TcpDisconnect;

    DWORD   SecTsigVerifyOldSig;
    DWORD   SecTsigVerifyOldFailed;
    DWORD   SecBigTimeSkewBypass;

    DWORD   ZoneLoadInit;
    DWORD   ZoneLoadComplete;
    DWORD   ZoneDbaseDelete;
    DWORD   ZoneDbaseDelayedDelete;
}
DNSSRV_PRIVATE_STATS, *PDNSSRV_PRIVATE_STATS;
#endif


//
//  Discontinued
//

typedef struct _DnsXfrStats
{
    DNSSRV_STAT_HEADER  Header;

    DWORD   SecSoaQueries;
    DWORD   SecSoaResponses;
    DWORD   SecNotifyReceived;
    DWORD   SecAxfrRequested;
    DWORD   SecAxfrRejected;
    DWORD   SecAxfrFailed;
    DWORD   SecAxfrSuccessful;

    DWORD   MasterNotifySent;
    DWORD   MasterAxfrReceived;
    DWORD   MasterAxfrInvalid;
    DWORD   MasterAxfrRefused;
    DWORD   MasterAxfrDenied;
    DWORD   MasterAxfrFailed;
    DWORD   MasterAxfrSuccessful;
}
DNSSRV_XFR_STATS, *PDNSSRV_XFR_STATS;


typedef struct _ErrorStats
{
    DNSSRV_STAT_HEADER  Header;

    DWORD NoError;
    DWORD FormError;
    DWORD ServFail;
    DWORD NxDomain;
    DWORD NotImpl;
    DWORD Refused;
    DWORD YxDomain;
    DWORD YxRRSet;
    DWORD NxRRSet;
    DWORD NotAuth;
    DWORD NotZone;
    DWORD Max;
    DWORD BadSig;
    DWORD BadKey;
    DWORD BadTime;
    DWORD UnknownError;
}
DNSSRV_ERROR_STATS, *PDNSSRV_ERROR_STATS;


//
//  Cache stats - new for .NET
//

typedef struct _DnsCacheStats
{
    DNSSRV_STAT_HEADER  Header;

    DWORD   CacheExceededLimitChecks;
    DWORD   SuccessfulFreePasses;
    DWORD   FailedFreePasses;
    DWORD   PassesWithNoFrees;
    DWORD   PassesRequiringAggressiveFree;
}
DNSSRV_CACHE_STATS, *PDNSSRV_CACHE_STATS;


//
//  Stat IDs
//      - request all stats by sending (-1)
//
//  Stat Versioning
//  Policy on stat versioning will be to use the top byte
//  of the statid as a version field which rolls on individual
//  release.  In general we should probably try to keep this
//  in ssync across stats from a particular release to allow
//  at some point to make decisions based on the stat id.
//  May want to rejigger IDs -- compact ongoing ones at bottom.
//
//  Note:  obviously i'm abandoning the original idea of bit
//  field ids and allowing mask in stat request, as we'd quickly
//  exhaust stat store.  This change has already been made in
//  dnscmd.exe documentation.
//

#define DNSSRV_STATID_TIME              (0x00000001)
#define DNSSRV_STATID_QUERY             (0x00000002)
#define DNSSRV_STATID_QUERY2            (0x00000004)
#define DNSSRV_STATID_RECURSE           (0x00000008)
#define DNSSRV_STATID_MASTER            (0x00000010)
#define DNSSRV_STATID_SECONDARY         (0x00000020)
#define DNSSRV_STATID_WINS              (0x00000040)
#define DNSSRV_STATID_WIRE_UPDATE       (0x00000100)
#define DNSSRV_STATID_SKWANSEC          (0x00000200)
#define DNSSRV_STATID_DS                (0x00000400)
#define DNSSRV_STATID_NONWIRE_UPDATE    (0x00000800)
#define DNSSRV_STATID_MEMORY            (0x00010000)
#define DNSSRV_STATID_TIMEOUT           (0x00020000)
#define DNSSRV_STATID_DBASE             (0x00040000)
#define DNSSRV_STATID_RECORD            (0x00080000)
#define DNSSRV_STATID_PACKET            (0x00100000)
#define DNSSRV_STATID_NBSTAT            (0x00200000)
#define DNSSRV_STATID_ERRORS            (0x00400000)
#define DNSSRV_STATID_CACHE             (0x00800000)
#define DNSSRV_STATID_PRIVATE           (0x10000000)

#define DNSSRV_STATID_ALL               (0xffffffff)



//
//  Statistics API
//

DNS_STATUS
DNS_API_FUNCTION
DnssrvGetStatistics(
    IN      LPCWSTR             pwszServer,
    IN      DWORD               dwFilter,
    OUT     PDNS_RPC_BUFFER *   ppStatsBuffer
    );

DNS_STATUS
DNS_API_FUNCTION
DnssrvClearStatistics(
    IN      LPCWSTR             pwszServer
    );

PDNSSRV_STAT
DNS_API_FUNCTION
DnssrvFindStatisticsInBuffer(
    IN      PDNS_RPC_BUFFER     pBuffer,
    IN      DWORD               StatId
    );

#define DnssrvFreeStatisticsBuffer( pBuf ) \
        DnssrvFreeRpcBuffer( (PDNS_RPC_BUFFER)pBuf )

DNS_STATUS
DNS_API_FUNCTION
DnssrvValidityCheckStatistic(
    IN      PDNSSRV_STAT        pStat
    );



//
//  Server information
//

//  Auto create delegations (ACD) settings

#define DNS_ACD_DONT_CREATE                             0
#define DNS_ACD_ALWAYS_CREATE                           1
#define DNS_ACD_ONLY_IF_NO_DELEGATION_IN_PARENT         2

//  EnableDnsSec values

#define DNS_DNSSEC_DISABLED                 0
#define DNS_DNSSEC_ENABLED_IF_EDNS          1
#define DNS_DNSSEC_ENABLED_ALWAYS           2

//  LocalNetPriorityNetMask values
//  ZERO: sort by closest match down to the last bit
//  ALL ONES: sort by closest match down to the network class default subnet mask
//  OTHER: sort down to this netmask - e.g. 0xFF means sort down the class C

#define DNS_LOCNETPRI_MASK_BEST_MATCH       0
#define DNS_LOCNETPRI_MASK_CLASS_DEFAULT    0xFFFFFFFF



//
//  Zone information
//

//  Zone types

#define DNS_ZONE_TYPE_CACHE     (0)
#define DNS_ZONE_TYPE_PRIMARY   (1)
#define DNS_ZONE_TYPE_SECONDARY (2)
#define DNS_ZONE_TYPE_STUB      (3)     // specialized form of SECONDARY
#define DNS_ZONE_TYPE_FORWARDER (4)     // another specialized zone type

//  Zone request filters

#define ZONE_REQUEST_PRIMARY            0x00000001
#define ZONE_REQUEST_SECONDARY          0x00000002
#define ZONE_REQUEST_CACHE              0x00000004
#define ZONE_REQUEST_AUTO               0x00000008
#define ZONE_REQUEST_FORWARD            0x00000010
#define ZONE_REQUEST_REVERSE            0x00000020
#define ZONE_REQUEST_FORWARDER          0x00000040
#define ZONE_REQUEST_STUB               0x00000080
#define ZONE_REQUEST_DS                 0x00000100  //  all DS-integrated zones
#define ZONE_REQUEST_NON_DS             0x00000200
#define ZONE_REQUEST_DOMAIN_DP          0x00000400  //  only domain DP DS zones
#define ZONE_REQUEST_FOREST_DP          0x00000800  //  only forest DP DS zones
#define ZONE_REQUEST_CUSTOM_DP          0x00001000  //  zones in any custom DP
#define ZONE_REQUEST_LEGACY_DP          0x00002000  //  only System container zones

#define ZONE_REQUEST_ANY_TYPE               0x000000C7
#define ZONE_REQUEST_ANY_DIRECTION          0x00000030
#define ZONE_REQUEST_ANY_DATABASE           0x00000300
#define ZONE_REQUEST_ANY_DP                 0x00003C00

#define ZONE_REQUEST_ALL_ZONES              0xfffffff3      //  excludes auto-created zones
#define ZONE_REQUEST_ALL_ZONES_AND_CACHE    0xfffffff7      //  excludes auto-created zones

//  Zone update properties

#define ZONE_UPDATE_OFF         (0)
#define ZONE_UPDATE_UNSECURE    (1)
#define ZONE_UPDATE_SECURE      (2)
#define ZONE_UPDATE_SECURE_RFC  (3)

//  Zone notify levels

#define ZONE_NOTIFY_OFF                 (0)
#define ZONE_NOTIFY_ALL_SECONDARIES     (1)
#define ZONE_NOTIFY_LIST_ONLY           (2)
#define ZONE_NOTIFY_HIGHEST_VALUE       ZONE_NOTIFY_LIST_ONLY

#if 1
#define ZONE_NOTIFY_ALL                 ZONE_NOTIFY_ALL_SECONDARIES
#define ZONE_NOTIFY_LIST                ZONE_NOTIFY_LIST_ONLY
#endif

//  Zone secondary security

#define ZONE_SECSECURE_NO_SECURITY      (0)
#define ZONE_SECSECURE_NS_ONLY          (1)
#define ZONE_SECSECURE_LIST_ONLY        (2)
#define ZONE_SECSECURE_NO_XFR           (3)
#define ZONE_SECSECURE_HIGHEST_VALUE    ZONE_SECSECURE_NO_XFR

#if 1
#define ZONE_SECSECURE_OFF              ZONE_SECSECURE_NO_SECURITY
#define ZONE_SECSECURE_NS               ZONE_SECSECURE_NS_ONLY
#define ZONE_SECSECURE_LIST             ZONE_SECSECURE_LIST_ONLY
#define ZONE_SECSECURE_NONE             ZONE_SECSECURE_NO_XFR
#endif

//  No-Reset flag
//  Indicates a specific property is NOT being reset in a multi-property
//  reset call.

#define ZONE_PROPERTY_NORESET   (0xbbbbbbbb)

//
//  Selftest check flags
//

#define DNS_SELFTEST_OFF                0
#define DNS_SELFTEST_ZONE_SOA           0x00000001
#define DNS_SELFTEST_ALL                0xFFFFFFFF

#define DNS_SELFTEST_DEFAULT            DNS_SELFTEST_ALL

//
//  Special "zones" for Enum and Update
//

#define DNS_ZONE_ROOT_HINTS_A   ("..RootHints")
#define DNS_ZONE_ROOT_HINTS_W   (L"..RootHints")

#define DNS_ZONE_CACHE_A        ("..Cache")
#define DNS_ZONE_CACHE_W        (L"..Cache")

#define DNS_ZONE_ROOT_HINTS     DNS_ZONE_ROOT_HINTS_A
#define DNS_ZONE_CACHE          DNS_ZONE_CACHE_A


//
//  Special "multizones" for zone operations
//
//  These are provided for ease of use from dnscmd.exe.
//  However, recommended approach is to use
//      DNS_ZONE_ALL
//  and use specific ZONE_REQUEST_XYZ flags above to specify
//  matching zones.
//

#define DNS_ZONE_ALL                    ("..AllZones")
#define DNS_ZONE_ALL_AND_CACHE          ("..AllZonesAndCache")

#define DNS_ZONE_ALL_PRIMARY            ("..AllPrimaryZones")
#define DNS_ZONE_ALL_SECONDARY          ("..AllSecondaryZones")

#define DNS_ZONE_ALL_FORWARD            ("..AllForwardZones")
#define DNS_ZONE_ALL_REVERSE            ("..AllReverseZones")

#define DNS_ZONE_ALL_DS                 ("..AllDsZones")
#define DNS_ZONE_ALL_NON_DS             ("..AllNonDsZones")

//  useful combinations

#define DNS_ZONE_ALL_PRIMARY_REVERSE    ("..AllPrimaryReverseZones")
#define DNS_ZONE_ALL_PRIMARY_FORWARD    ("..AllPrimaryForwardZones")

#define DNS_ZONE_ALL_SECONDARY_REVERSE  ("..AllSecondaryReverseZones")
#define DNS_ZONE_ALL_SECONDARY_FORWARD  ("..AllSecondaryForwardZones")


//
//  Basic zone data
//      - provides what admin tool needs to show zone list
//

typedef struct _DnssrvRpcZoneFlags
{
    DWORD   Paused          : 1;
    DWORD   Shutdown        : 1;
    DWORD   Reverse         : 1;
    DWORD   AutoCreated     : 1;
    DWORD   DsIntegrated    : 1;
    DWORD   Aging           : 1;
    DWORD   Update          : 2;
    DWORD   UnUsed          : 24;
}
DNS_RPC_ZONE_FLAGS, *PDNS_RPC_ZONE_FLAGS;

typedef struct _DnssrvRpcZoneW2K
{
    LPWSTR                  pszZoneName;
#ifdef MIDL_PASS
    DWORD                   Flags;
#else
    DNS_RPC_ZONE_FLAGS      Flags;
#endif
    UCHAR                   ZoneType;
    UCHAR                   Version;
}
DNS_RPC_ZONE_W2K, *PDNS_RPC_ZONE_W2K;

typedef struct _DnssrvRpcZoneDotNet
{
    DWORD                   dwRpcStructureVersion;
    DWORD                   dwReserved0;

    LPWSTR                  pszZoneName;
#ifdef MIDL_PASS
    DWORD                   Flags;
#else
    DNS_RPC_ZONE_FLAGS      Flags;
#endif
    UCHAR                   ZoneType;
    UCHAR                   Version;

    //
    //  Directory partition where zone is stored
    //

    DWORD                   dwDpFlags;
    LPSTR                   pszDpFqdn;
}
DNS_RPC_ZONE_DOTNET, *PDNS_RPC_ZONE_DOTNET;


//
//  Zone enumeration
//

typedef struct _DnssrvRpcZoneListW2K
{
#ifdef MIDL_PASS
    [range(0,500000)]       DWORD               dwZoneCount;
    [size_is(dwZoneCount)]  PDNS_RPC_ZONE_W2K   ZoneArray[];
#else
    DWORD                   dwZoneCount;
    PDNS_RPC_ZONE_W2K       ZoneArray[ 1 ];     //  array of dwZoneCount zones
#endif
}
DNS_RPC_ZONE_LIST_W2K, *PDNS_RPC_ZONE_LIST_W2K;

typedef struct _DnssrvRpcZoneListDotNet
{
    DWORD                   dwRpcStructureVersion;
    DWORD                   dwReserved0;

#ifdef MIDL_PASS
    [range(0,500000)]       DWORD                   dwZoneCount;
    [size_is(dwZoneCount)]  PDNS_RPC_ZONE_DOTNET    ZoneArray[];
#else
    DWORD                   dwZoneCount;
    PDNS_RPC_ZONE_DOTNET    ZoneArray[ 1 ];     //  array of dwZoneCount zones
#endif
}
DNS_RPC_ZONE_LIST_DOTNET, *PDNS_RPC_ZONE_LIST_DOTNET;


//
//  Directory partition enumeration and info
//

#define DNS_DP_AUTOCREATED              0x00000001
#define DNS_DP_LEGACY                   0x00000002
#define DNS_DP_DOMAIN_DEFAULT           0x00000004
#define DNS_DP_FOREST_DEFAULT           0x00000008
#define DNS_DP_ENLISTED                 0x00000010
#define DNS_DP_DELETED                  0x00000020

#define DNS_DP_DOMAIN_STR       "..DomainPartition"
#define DNS_DP_FOREST_STR       "..ForestPartition"
#define DNS_DP_LEGACY_STR       "..LegacyPartition"

#define DNS_DP_STATE_OKAY           0   //  DP is up and ready for all operations
#define DNS_DP_STATE_REPL_INCOMING  1   //  DP is replicating in -> do not read or write
#define DNS_DP_STATE_REPL_OUTGOING  2   //  DP is being deleted -> do not read or write
#define DNS_DP_STATE_UNKNOWN        3   //  DP is unavailable for unknown reason

typedef struct _DnssrvRpcDirectoryPartitionEnum
{
    DWORD           dwRpcStructureVersion;
    DWORD           dwReserved0;

    LPSTR           pszDpFqdn;
    DWORD           dwFlags;
    DWORD           dwZoneCount;
}
DNS_RPC_DP_ENUM, *PDNS_RPC_DP_ENUM;

typedef struct _DnssrvRpcDirectoryPartitionList
{
    DWORD                   dwRpcStructureVersion;
    DWORD                   dwReserved0;

#ifdef MIDL_PASS
    [range(0,5000)]         DWORD               dwDpCount;
    [size_is(dwDpCount)]    PDNS_RPC_DP_ENUM    DpArray[];
#else
    DWORD                   dwDpCount;
    PDNS_RPC_DP_ENUM        DpArray[ 1 ];   // array of dwDpCount pointers
#endif
}
DNS_RPC_DP_LIST, *PDNS_RPC_DP_LIST;

typedef struct _DnssrvRpcDirectoryPartitionReplica
{
    LPWSTR          pszReplicaDn;
}
DNS_RPC_DP_REPLICA, *PDNS_RPC_DP_REPLICA;

typedef struct _DnssrvRpcDirectoryPartition
{
    DWORD           dwRpcStructureVersion;
    DWORD           dwReserved0;

    LPSTR           pszDpFqdn;
    LPWSTR          pszDpDn;        //  DP head DN
    LPWSTR          pszCrDn;        //  crossref DN
    DWORD           dwFlags;
    DWORD           dwZoneCount;
    DWORD           dwState;
    
    DWORD           dwReserved[ 3 ];
    LPWSTR          pwszReserved[ 3 ];

#ifdef MIDL_PASS
    [range(0,10000)]            DWORD                   dwReplicaCount;
    [size_is(dwReplicaCount)]   PDNS_RPC_DP_REPLICA     ReplicaArray[];
#else
    DWORD                   dwReplicaCount;
    PDNS_RPC_DP_REPLICA     ReplicaArray[ 1 ];   // array of dwReplicaCount pointers
#endif
}
DNS_RPC_DP_INFO, *PDNS_RPC_DP_INFO;

//
//  Enlist (or create) directory partition
//

#define DNS_DP_OP_MIN                   DNS_DP_OP_CREATE
#define DNS_DP_OP_CREATE                1   //  create a new DP
#define DNS_DP_OP_DELETE                2   //  delete an existing DP
#define DNS_DP_OP_ENLIST                3   //  enlist this DC in an existing DP
#define DNS_DP_OP_UNENLIST              4   //  unenlist this DC from a DP
#define DNS_DP_OP_CREATE_DOMAIN         5   //  built-in domain DP
#define DNS_DP_OP_CREATE_FOREST         6   //  built-in forest DP
#define DNS_DP_OP_CREATE_ALL_DOMAINS    7   //  all domain DPs for the forest
#define DNS_DP_OP_MAX                   DNS_DP_OP_CREATE_ALL_DOMAINS

typedef struct _DnssrvRpcEnlistDirPart
{
    DWORD       dwRpcStructureVersion;
    DWORD       dwReserved0;

    LPSTR       pszDpFqdn;      //  UTF8
    DWORD       dwOperation;
}
DNS_RPC_ENLIST_DP, *PDNS_RPC_ENLIST_DP;

//
//  Zone rename
//

typedef struct _DnssrvRpcZoneRename
{
    DWORD       dwRpcStructureVersion;
    DWORD       dwReserved0;

    LPSTR       pszNewZoneName;
    LPSTR       pszNewFileName;
}
DNS_RPC_ZONE_RENAME_INFO, *PDNS_RPC_ZONE_RENAME_INFO;

//
//  Zone export
//

typedef struct _DnssrvRpcZoneExport
{
    DWORD       dwRpcStructureVersion;
    DWORD       dwReserved0;

    LPSTR       pszZoneExportFile;
}
DNS_RPC_ZONE_EXPORT_INFO, *PDNS_RPC_ZONE_EXPORT_INFO;

//
//  Zone property data
//

typedef struct _DnssrvRpcZoneTypeResetW2K
{
    DWORD       dwZoneType;
    PIP4_ARRAY  aipMasters;
}
DNS_RPC_ZONE_TYPE_RESET_W2K, *PDNS_RPC_ZONE_TYPE_RESET_W2K;

typedef struct _DnssrvRpcZoneTypeResetDotNet
{
    DWORD       dwRpcStructureVersion;
    DWORD       dwReserved0;

    DWORD       dwZoneType;
    PIP4_ARRAY  aipMasters;
}
DNS_RPC_ZONE_TYPE_RESET_DOTNET, *PDNS_RPC_ZONE_TYPE_RESET_DOTNET;


//  typedef IP4_ARRAY DNS_RPC_ZONE_MASTERS, *PDNS_RPC_ZONE_MASTERS;


typedef struct _DnssrvRpcZoneSecondariesW2K
{
    DWORD       fSecureSecondaries;
    DWORD       fNotifyLevel;
    PIP4_ARRAY  aipSecondaries;
    PIP4_ARRAY  aipNotify;
}
DNS_RPC_ZONE_SECONDARIES_W2K, *PDNS_RPC_ZONE_SECONDARIES_W2K;

typedef struct _DnssrvRpcZoneSecondariesDotNet
{
    DWORD       dwRpcStructureVersion;
    DWORD       dwReserved0;

    DWORD       fSecureSecondaries;
    DWORD       fNotifyLevel;
    PIP4_ARRAY  aipSecondaries;
    PIP4_ARRAY  aipNotify;
}
DNS_RPC_ZONE_SECONDARIES_DOTNET, *PDNS_RPC_ZONE_SECONDARIES_DOTNET;


typedef struct _DnssrvRpcZoneDatabaseW2K
{
    DWORD       fDsIntegrated;
    LPSTR       pszFileName;
}
DNS_RPC_ZONE_DATABASE_W2K, *PDNS_RPC_ZONE_DATABASE_W2K;

typedef struct _DnssrvRpcZoneDatabaseDotNet
{
    DWORD       dwRpcStructureVersion;
    DWORD       dwReserved0;

    DWORD       fDsIntegrated;
    LPSTR       pszFileName;
}
DNS_RPC_ZONE_DATABASE_DOTNET, *PDNS_RPC_ZONE_DATABASE_DOTNET;


//
//  DNS_RPC_ZONE_CHANGE_DP - new for .NET
//
//  Used to move a zone from one directory parition (DP) to another.
//
//  To move the zone to a built-in DP, for pszDestPartition use one of:
//          DNS_DP_DOMAIN_STR
//          DNS_DP_ENTERPRISE_STR
//          DNS_DP_LEGACY_STR
//

typedef struct _DnssrvRpcZoneChangePartition
{
    DWORD       dwRpcStructureVersion;
    DWORD       dwReserved0;

    LPSTR       pszDestPartition;
}
DNS_RPC_ZONE_CHANGE_DP, *PDNS_RPC_ZONE_CHANGE_DP;


typedef struct _DnsRpcZoneInfoW2K
{
    LPSTR       pszZoneName;
    DWORD       dwZoneType;
    DWORD       fReverse;
    DWORD       fAllowUpdate;
    DWORD       fPaused;
    DWORD       fShutdown;
    DWORD       fAutoCreated;

    //  Database info

    DWORD       fUseDatabase;
    LPSTR       pszDataFile;

    //  Masters

    PIP4_ARRAY  aipMasters;

    //  Secondaries

    DWORD       fSecureSecondaries;
    DWORD       fNotifyLevel;
    PIP4_ARRAY  aipSecondaries;
    PIP4_ARRAY  aipNotify;

    //  WINS or Nbstat lookup

    DWORD       fUseWins;
    DWORD       fUseNbstat;

    //  Aging

    DWORD       fAging;
    DWORD       dwNoRefreshInterval;
    DWORD       dwRefreshInterval;
    DWORD       dwAvailForScavengeTime;
    PIP4_ARRAY  aipScavengeServers;

    //  save some space, just in case
    //      avoid versioning issues if possible

    DWORD       pvReserved1;
    DWORD       pvReserved2;
    DWORD       pvReserved3;
    DWORD       pvReserved4;
}
DNS_RPC_ZONE_INFO_W2K, *PDNS_RPC_ZONE_INFO_W2K;

typedef DNS_RPC_ZONE_INFO_W2K   DNS_ZONE_INFO_W2K, *PDNS_ZONE_INFO_W2K;

typedef struct _DnsRpcZoneInfoDotNet
{
    DWORD       dwRpcStructureVersion;
    DWORD       dwReserved0;

    LPSTR       pszZoneName;
    DWORD       dwZoneType;
    DWORD       fReverse;
    DWORD       fAllowUpdate;
    DWORD       fPaused;
    DWORD       fShutdown;
    DWORD       fAutoCreated;

    //  Database info

    DWORD       fUseDatabase;
    LPSTR       pszDataFile;

    //  Masters

    PIP4_ARRAY  aipMasters;

    //  Secondaries

    DWORD       fSecureSecondaries;
    DWORD       fNotifyLevel;
    PIP4_ARRAY  aipSecondaries;
    PIP4_ARRAY  aipNotify;

    //  WINS or Nbstat lookup

    DWORD       fUseWins;
    DWORD       fUseNbstat;

    //  Aging

    DWORD       fAging;
    DWORD       dwNoRefreshInterval;
    DWORD       dwRefreshInterval;
    DWORD       dwAvailForScavengeTime;
    PIP4_ARRAY  aipScavengeServers;

    //  Below this point is new for .NET

    //  Forwarder zones

    DWORD       dwForwarderTimeout;
    DWORD       fForwarderSlave;

    //  Stub zones

    PIP4_ARRAY  aipLocalMasters;

    //  Directory partition

    DWORD       dwDpFlags;
    LPSTR       pszDpFqdn;
    LPWSTR      pwszZoneDn;

    //  Xfr time information

    DWORD       dwLastSuccessfulSoaCheck;
    DWORD       dwLastSuccessfulXfr;
    
    //  save some space, just in case
    //      DWORDS: save for SP enhancements
    //      POINTERS: BEFORE SHIP!!!

    DWORD       dwReserved1;
    DWORD       dwReserved2;
    DWORD       dwReserved3;
    DWORD       dwReserved4;
    DWORD       dwReserved5;

    LPSTR       pReserved1;
    LPSTR       pReserved2;
    LPSTR       pReserved3;
    LPSTR       pReserved4;
}
DNS_RPC_ZONE_INFO_DOTNET, *PDNS_RPC_ZONE_INFO_DOTNET;

typedef DNS_RPC_ZONE_INFO_DOTNET      DNS_ZONE_INFO, *PDNS_ZONE_INFO;


//
//  Zone create data
//

typedef struct _DnsRpcZoneCreateInfo
{
    LPSTR       pszZoneName;
    DWORD       dwZoneType;
    DWORD       fAllowUpdate;
    DWORD       fAging;
    DWORD       dwFlags;

    //  Database info

    LPSTR       pszDataFile;
    DWORD       fDsIntegrated;
    DWORD       fLoadExisting;

    //  Admin name (if auto-create SOA)

    LPSTR       pszAdmin;

    //  Masters (if secondary)

    PIP4_ARRAY  aipMasters;

    //  Secondaries

    PIP4_ARRAY  aipSecondaries;
    DWORD       fSecureSecondaries;
    DWORD       fNotifyLevel;

    //  Reserve some space to avoid versioning issues

    LPSTR       pvReserved1;
    LPSTR       pvReserved2;
    LPSTR       pvReserved3;
    LPSTR       pvReserved4;
    LPSTR       pvReserved5;
    LPSTR       pvReserved6;
    LPSTR       pvReserved7;
    LPSTR       pvReserved8;

    DWORD       dwReserved1;
    DWORD       dwReserved2;
    DWORD       dwReserved3;
    DWORD       dwReserved4;
    DWORD       dwReserved5;
    DWORD       dwReserved6;
    DWORD       dwReserved7;
    DWORD       dwReserved8;
}
DNS_RPC_ZONE_CREATE_INFO_W2K, *PDNS_RPC_ZONE_CREATE_INFO_W2K;


typedef struct _DnsRpcZoneCreateInfoDotNet
{
    DWORD       dwRpcStructureVersion;
    DWORD       dwReserved0;

    LPSTR       pszZoneName;
    DWORD       dwZoneType;
    DWORD       fAllowUpdate;
    DWORD       fAging;
    DWORD       dwFlags;

    //  Database info

    LPSTR       pszDataFile;
    DWORD       fDsIntegrated;
    DWORD       fLoadExisting;

    //  Admin name (if auto-create SOA)

    LPSTR       pszAdmin;

    //  Masters (if secondary)

    PIP4_ARRAY  aipMasters;

    //  Secondaries

    PIP4_ARRAY  aipSecondaries;
    DWORD       fSecureSecondaries;
    DWORD       fNotifyLevel;

    //  Below this point is new for .NET.

    //  Forwarder zones

    DWORD       dwTimeout;
    DWORD       fSlave;

    //  Directory partition

    DWORD       dwDpFlags;      //  specify builtin DP or
    LPSTR       pszDpFqdn;      //      UTF8 FQDN of partition

    //  Reserve some space to avoid versioning issues - we have so much
    //  reserved because we don't want the .NET structure to be smaller
    //  than the W2K structure on IA64.

    DWORD       dwReserved[ 32 ];
}
DNS_RPC_ZONE_CREATE_INFO_DOTNET, *PDNS_RPC_ZONE_CREATE_INFO_DOTNET;


//
//  Autoconfigure operation flags
//

#define DNS_RPC_AUTOCONFIG_ALL              0xffffffff
#define DNS_RPC_AUTOCONFIG_ROOTHINTS        0x00000001
#define DNS_RPC_AUTOCONFIG_FORWARDERS       0x00000002
#define DNS_RPC_AUTOCONFIG_SELFPOINTCLIENT  0x00000004


//
//  EnumZones2 filter specification
//

typedef struct _DnsRpcEnumZonesFilter
{
    DWORD       dwRpcStructureVersion;
    DWORD       dwReserved0;

    DWORD       dwFilter;                   //  ZONE_REQUEST_XXX flags
    LPSTR       pszPartitionFqdn;           //  FQDN of directory partition
    LPSTR       pszQueryString;             //  future: some kind of query string

    LPSTR       pszReserved[ 6 ];
}
DNS_RPC_ENUM_ZONES_FILTER, *PDNS_RPC_ENUM_ZONES_FILTER;



//
//  Zone Query API
//

#define DnssrvEnumZones( pwszServer, dwFilter, pszLastZone, ppZoneList )    \
        DnssrvEnumZonesEx( pwszServer, dwFilter, NULL, NULL,                \
                           pszLastZone, ppZoneList )

DNS_STATUS
DNS_API_FUNCTION
DnssrvEnumZonesEx(
    IN      LPCWSTR                 pwszServer,
    IN      DWORD                   dwFilter,
    IN      LPCSTR                  pszDirectoryPartitionFqdn,
    IN      LPCSTR                  pszQueryString,
    IN      LPCSTR                  pszLastZone,
    OUT     PDNS_RPC_ZONE_LIST *    ppZoneList
    );

VOID
DNS_API_FUNCTION
DnssrvFreeZone(
    IN OUT  PDNS_RPC_ZONE       pZone
    );

VOID
DNS_API_FUNCTION
DnssrvFreeZoneList(
    IN OUT  PDNS_RPC_ZONE_LIST  pZoneList
    );

DNS_STATUS
DNS_API_FUNCTION
DnssrvQueryZoneDwordProperty(
    IN      LPCWSTR             pwszServer,
    IN      LPCSTR              pszZone,
    IN      LPCSTR              pszProperty,
    OUT     PDWORD              pdwResult
    );

DNS_STATUS
DNS_API_FUNCTION
DnssrvGetZoneInfo(
    IN      LPCWSTR                 pwszServer,
    IN      LPCSTR                  pszZone,
    OUT     PDNS_RPC_ZONE_INFO *    ppZoneInfo
    );

VOID
DNS_API_FUNCTION
DnssrvFreeZoneInfo(
    IN OUT  PDNS_RPC_ZONE_INFO      pZoneInfo
    );



//
//  Zone Operations API
//

#define DNS_ZONE_LOAD_OVERWRITE_MEMORY  (0x00000010)
#define DNS_ZONE_LOAD_OVERWRITE_DS      (0x00000020)
#define DNS_ZONE_LOAD_MERGE_EXISTING    (0x00000040)
#define DNS_ZONE_LOAD_MUST_FIND         (0x00000100)

#define DNS_ZONE_LOAD_EXISTING          DNS_ZONE_LOAD_OVERWRITE_MEMORY
#define DNS_ZONE_OVERWRITE_EXISTING     DNS_ZONE_LOAD_OVERWRITE_DS
#define DNS_ZONE_MERGE_WITH_EXISTING    DNS_ZONE_LOAD_MERGE_EXISTING

//
//  Zone create flags
//

#define DNS_ZONE_CREATE_FOR_DCPROMO             (0x00001000)
#define DNS_ZONE_CREATE_AGING                   (0x00002000)
#define DNS_ZONE_CREATE_FOR_DCPROMO_FOREST      (0x00004000)

#if 0
//  Currently these have direct parameter to CreateZone function
#define DNS_ZONE_CREATE_UPDATE          (0x00010000)
#define DNS_ZONE_CREATE_UPDATE_SECURE   (0x00020000)
#define DNS_ZONE_CREATE_DS_INTEGRATED   (0x10000000)
#endif

DNS_STATUS
DNS_API_FUNCTION
DnssrvCreateZone(
    IN      LPCWSTR         pwszServer,
    IN      LPCSTR          pszZoneName,
    IN      DWORD           dwZoneType,
    IN      LPCSTR          pszAdminEmailName,
    IN      DWORD           cMasters,
    IN      PIP4_ADDRESS    aipMasters,
    IN      DWORD           fLoadExisting,
    IN      DWORD           fDsIntegrated,
    IN      LPCSTR          pszDataFile,
    IN      DWORD           dwTimeout,
    IN      DWORD           fSlave
    );

DNS_STATUS
DNS_API_FUNCTION
DnssrvCreateZoneForDcPromo(
    IN      LPCWSTR         Server,
    IN      LPCSTR          pszZoneName,
    IN      LPCSTR          pszDataFile
    );

DNS_STATUS
DNS_API_FUNCTION
DnssrvCreateZoneForDcPromoEx(
    IN      LPCWSTR         Server,
    IN      LPCSTR          pszZoneName,
    IN      LPCSTR          pszDataFile,
    IN      DWORD           dwFlags
    );

DNS_STATUS
DNS_API_FUNCTION
DnssrvCreateZoneInDirectoryPartition(
    IN      LPCWSTR             pwszServer,
    IN      LPCSTR              pszZoneName,
    IN      DWORD               dwZoneType,
    IN      LPCSTR              pszAdminEmailName,
    IN      DWORD               cMasters,
    IN      PIP4_ADDRESS        aipMasters,
    IN      DWORD               fLoadExisting,
    IN      DWORD               dwTimeout,
    IN      DWORD               fSlave,
    IN      DWORD               dwDirPartFlags,
    IN      LPCSTR              pszDirPartFqdn
    );


DNS_STATUS
DNS_API_FUNCTION
DnssrvDelegateSubZone(
    IN      LPCWSTR         pwszServer,
    IN      LPCSTR          pszZoneName,
    IN      LPCSTR          pszSubZone,
    IN      LPCSTR          pszNewServer,
    IN      IP4_ADDRESS     ipNewServerAddr
    );

DNS_STATUS
DNS_API_FUNCTION
DnssrvIncrementZoneVersion(
    IN      LPCWSTR         pwszServer,
    IN      LPCSTR          pszZoneName
    );

DNS_STATUS
DNS_API_FUNCTION
DnssrvDeleteZone(
    IN      LPCWSTR         pwszServer,
    IN      LPCSTR          pszZoneName
    );

DNS_STATUS
DNS_API_FUNCTION
DnssrvPauseZone(
    IN      LPCWSTR         pwszServer,
    IN      LPCSTR          pszZoneName
    );

DNS_STATUS
DNS_API_FUNCTION
DnssrvResumeZone(
    IN      LPCWSTR         pwszServer,
    IN      LPCSTR          pszZoneName
    );


DNS_STATUS
DNS_API_FUNCTION
DnssrvResetZoneType(
    IN      LPCWSTR         pwszServer,
    IN      LPCSTR          pszZoneName,
    IN      DWORD           dwZoneType,
    IN      DWORD           cMasters,
    IN      PIP4_ADDRESS    aipMasters
    );

DNS_STATUS
DNS_API_FUNCTION
DnssrvResetZoneTypeEx(
    IN      LPCWSTR         pwszServer,
    IN      LPCSTR          pszZoneName,
    IN      DWORD           dwZoneType,
    IN      DWORD           cMasters,
    IN      PIP4_ADDRESS    aipMasters,
    IN      DWORD           dwLoadOptions,
    IN      DWORD           fDsIntegrated,
    IN      LPCSTR          pszDataFile,
    IN      DWORD           dwDpFlags,
    IN      LPCSTR          pszDpFqdn
    );

DNS_STATUS
DNS_API_FUNCTION
DnssrvChangeZoneDirectoryPartition(
    IN      LPCWSTR         pwszServer,
    IN      LPCSTR          pszZoneName,
    IN      LPCSTR          pszNewPartition
    );

DNS_STATUS
DNS_API_FUNCTION
DnssrvResetZoneDatabase(
    IN      LPCWSTR         pwszServer,
    IN      LPCSTR          pszZoneName,
    IN      DWORD           fUseDatabase,
    IN      LPCSTR          pszDataFile
    );

DNS_STATUS
DNS_API_FUNCTION
DnssrvResetZoneMasters(
    IN      LPCWSTR         pwszServer,
    IN      LPCSTR          pszZoneName,
    IN      DWORD           cMasters,
    IN      PIP4_ADDRESS    aipMasters
    );

DNS_STATUS
DNS_API_FUNCTION
DnssrvResetZoneMastersEx(
    IN      LPCWSTR         pwszServer,
    IN      LPCSTR          pszZoneName,
    IN      DWORD           cMasters,
    IN      PIP4_ADDRESS    aipMasters,
    IN      DWORD           fSetLocalMasters
    );

DNS_STATUS
DNS_API_FUNCTION
DnssrvResetZoneSecondaries(
    IN      LPCWSTR             Server,
    IN      LPCSTR              pszZone,
    IN      DWORD               fSecureSecondaries,
    IN      DWORD               cSecondaries,
    IN      PIP4_ADDRESS        aipSecondaries,
    IN      DWORD               fNotifyLevel,
    IN      DWORD               cNotify,
    IN      PIP4_ADDRESS        aipNotify
    );

DNS_STATUS
DNS_API_FUNCTION
DnssrvRenameZone(
    IN      LPCWSTR         Server,
    IN      LPCSTR          pszCurrentZoneName,
    IN      LPCSTR          pszNewZoneName,
    IN      LPCSTR          pszNewFileName
    );

DNS_STATUS
DNS_API_FUNCTION
DnssrvExportZone(
    IN      LPCWSTR         Server,
    IN      LPCSTR          pszZoneName,
    IN      LPCSTR          pszZoneExportFile
    );



//
//  Record \ Node viewing
//

//
//  Counted string format used for both node name and strings
//  in RPC buffer.
//

typedef struct  _DnssrvRpcName
{
    UCHAR   cchNameLength;
    CHAR    achName[1];         // name of cchNameLength characters
}
DNS_RPC_NAME, *PDNS_RPC_NAME, DNS_RPC_STRING, *PDNS_RPC_STRING;

//
//  Enumeration flags
//

#define DNS_RPC_FLAG_CACHE_DATA             0x80000000
#define DNS_RPC_FLAG_ZONE_ROOT              0x40000000
#define DNS_RPC_FLAG_AUTH_ZONE_ROOT         0x20000000
#define DNS_RPC_FLAG_ZONE_DELEGATION        0x10000000

//  update record flags

#define DNS_RPC_FLAG_RECORD_DEFAULT_TTL     0x08000000
#define DNS_RPC_FLAG_RECORD_TTL_CHANGE      0x04000000
#define DNS_RPC_FLAG_RECORD_CREATE_PTR      0x02000000

#define DNS_RPC_FLAG_NODE_STICKY            0x01000000
#define DNS_RPC_FLAG_NODE_COMPLETE          0x00800000

#define DNS_RPC_FLAG_SUPPRESS_NOTIFY        0x00010000

//  aging

#define DNS_RPC_FLAG_AGING_ON               0x00020000
#define DNS_RPC_FLAG_AGING_OFF              0x00040000

#define DNS_RPC_FLAG_OPEN_ACL               0x00080000

//  bottom byte of flag reserved for rank

#define DNS_RPC_FLAG_RANK                   0x000000ff


//  naming backward compatibility

#define DNS_RPC_NODE_FLAG_STICKY            DNS_RPC_FLAG_NODE_STICKY
#define DNS_RPC_NODE_FLAG_COMPLETE          DNS_RPC_FLAG_NODE_COMPLETE

#define DNS_RPC_RECORD_FLAG_ZONE_ROOT       DNS_RPC_FLAG_ZONE_ROOT
#define DNS_RPC_RECORD_FLAG_DEFAULT_TTL     DNS_RPC_FLAG_RECORD_DEFAULT_TTL
#define DNS_RPC_RECORD_FLAG_TTL_CHANGE      DNS_RPC_FLAG_RECORD_TTL_CHANGE
#define DNS_RPC_RECORD_FLAG_CREATE_PTR      DNS_RPC_FLAG_RECORD_CREATE_PTR
#define DNS_RPC_RECORD_FLAG_CACHE_DATA      DNS_RPC_FLAG_CACHE_DATA
#define DNS_RPC_RECORD_FLAG_AUTH_ZONE_ROOT  DNS_RPC_FLAG_AUTH_ZONE_ROOT
#define DNS_RPC_RECORD_FLAG_ZONE_ROOT       DNS_RPC_FLAG_ZONE_ROOT

//  DCR_CLEANUP:  remove backward compatibility flag

#define DNS_RPC_RECORD_FLAG_AGING_ON        DNS_RPC_FLAG_AGING_ON


//
//  DNS node structure for on the wire
//

typedef struct  _DnssrvRpcNode
{
    WORD            wLength;
    WORD            wRecordCount;
    DWORD           dwFlags;
    DWORD           dwChildCount;
    DNS_RPC_NAME    dnsNodeName;
}
DNS_RPC_NODE, *PDNS_RPC_NODE;

#define SIZEOF_DNS_RPC_NODE_HEADER   (3*sizeof(DWORD))



//
//  Resource record structure for passing records on the wire
//
//  For efficiency, all these fields are aligned.
//  When buffered for transmission, all RR should start on DWORD
//  aligned boundary.
//
//  Below we use NULL type to force default size of DNS_RPC_RECORD to
//  largest possible size of non-TXT record -- currently SOA:  two DNS names
//  and 20 bytes.  This is convenient for throwing these records on the stack
//  when doing simple creates.

#define DNS_RPC_DEFAULT_RECORD_DATA_LENGTH (2*DNS_MAX_NAME_LENGTH+20)


typedef union _DnsRpcRecordData
{
    struct
    {
        IP4_ADDRESS     ipAddress;
    }
    A;

    struct
    {
        DWORD           dwSerialNo;
        DWORD           dwRefresh;
        DWORD           dwRetry;
        DWORD           dwExpire;
        DWORD           dwMinimumTtl;
        DNS_RPC_NAME    namePrimaryServer;

        //  responsible party follows in buffer
    }
    SOA, Soa;

    struct
    {
        DNS_RPC_NAME    nameNode;
    }
    PTR, Ptr,
    NS, Ns,
    CNAME, Cname,
    MB, Mb,
    MD, Md,
    MF, Mf,
    MG, Mg,
    MR, Mr;

    struct
    {
        DNS_RPC_NAME    nameMailBox;

        //  errors to mailbox follows in buffer
    }
    MINFO, Minfo,
    RP, Rp;

    struct
    {
        WORD            wPreference;
        DNS_RPC_NAME    nameExchange;
    }
    MX, Mx,
    AFSDB, Afsdb,
    RT, Rt;

    struct
    {
        DNS_RPC_STRING  stringData;

        //  one or more strings may follow
    }
    HINFO, Hinfo,
    ISDN, Isdn,
    TXT, Txt,
    X25;

    struct
    {
        BYTE            bData[ DNS_RPC_DEFAULT_RECORD_DATA_LENGTH ];
    }
    Null;

    struct
    {
        IP4_ADDRESS     ipAddress;
        UCHAR           chProtocol;
        BYTE            bBitMask[1];
    }
    WKS, Wks;

    struct
    {
        IP6_ADDRESS     ipv6Address;
    }
    AAAA;

    struct
    {
        WORD            wPriority;
        WORD            wWeight;
        WORD            wPort;
        DNS_RPC_NAME    nameTarget;
    }
    SRV, Srv;

    struct
    {
        UCHAR           chFormat;
        BYTE            bAddress[1];
    }
    ATMA;

    //
    //  DNSSEC types
    //

    struct
    {
        WORD            wFlags;
        BYTE            chProtocol;
        BYTE            chAlgorithm;
        BYTE            bKey[1];
    }
    KEY, Key;

    struct
    {
        WORD            wTypeCovered;
        BYTE            chAlgorithm;
        BYTE            chLabelCount;
        DWORD           dwOriginalTtl;
        DWORD           dwSigExpiration;
        DWORD           dwSigInception;
        WORD            wKeyTag;
        DNS_RPC_STRING  nameSigner;
        //  binary signature data follows
    }
    SIG, Sig;

    struct
    {
        WORD            wNumTypeWords;      //  always at least 1
        WORD            wTypeWords[ 1 ];
        //  following the array of WORDs is the DNS_RPC_STRING for the next name
    }
    NXT, Nxt;

    //
    //  MS types
    //

    struct
    {
        DWORD           dwMappingFlag;
        DWORD           dwLookupTimeout;
        DWORD           dwCacheTimeout;
        DWORD           cWinsServerCount;
        IP4_ADDRESS     aipWinsServers[1];      //  array of cWinsServerCount IP
    }
    WINS, Wins;

    struct
    {
        DWORD           dwMappingFlag;
        DWORD           dwLookupTimeout;
        DWORD           dwCacheTimeout;
        DNS_RPC_NAME    nameResultDomain;
    }
    WINSR, WinsR, NBSTAT, Nbstat;

    struct
    {
        LONGLONG        EntombedTime;
    }
    Tombstone;

}
DNS_RPC_RECORD_DATA, *PDNS_RPC_RECORD_DATA,
DNS_FLAT_RECORD_DATA, *PDNS_FLAT_RECORD_DATA;


//
//  RPC record structure
//

typedef struct _DnssrvRpcRecord
{
    WORD        wDataLength;
    WORD        wType;
    DWORD       dwFlags;
    DWORD       dwSerial;
    DWORD       dwTtlSeconds;
    DWORD       dwTimeStamp;
    DWORD       dwReserved;

#ifdef MIDL_PASS
    [size_is(wDataLength)]  BYTE    Buffer[];
#else
    DNS_FLAT_RECORD_DATA            Data;
#endif
}
DNS_RPC_RECORD, *PDNS_RPC_RECORD,
DNS_FLAT_RECORD, *PDNS_FLAT_RECORD;


#define SIZEOF_DNS_RPC_RECORD_HEADER    (6*sizeof(DWORD))
#define SIZEOF_FLAT_RECORD_HEADER       (SIZEOF_DNS_RPC_RECORD_HEADER)

#define SIZEOF_DNS_RPC_RECORD_FIXED_FIELD2 \
                (sizeof(DNS_RPC_RECORD) - sizeof(struct _DnssrvRpcRecord.Data))

//  Max record is header + 64K of data

#define DNS_MAX_FLAT_RECORD_BUFFER_LENGTH  \
            (0x10004 + SIZEOF_DNS_RPC_RECORD_HEADER)


//
//  WINS + NBSTAT params
//      - default lookup timeout
//      - default cache timeout
//

#define DNS_WINS_DEFAULT_LOOKUP_TIMEOUT     (5)     // 5 secs
#define DNS_WINS_DEFAULT_CACHE_TIMEOUT      (600)   // 10 minutes


//
//  Note, for simplicity/efficiency ALL structures are DWORD aligned in
//  buffers on the wire.
//
//  This macro returns DWORD aligned ptr at given ptr our next DWORD
//  aligned postion.  Set ptr immediately after record or name structure
//  and this will return starting position of next structure.
//
//  Be careful that you do not DWORD align anything that contains a
//  pointer - you must use DNS_NEXT_ALIGNED_PTR for that so that we 
//  don't cause alignment faults on ia64.
//

#define DNS_NEXT_DWORD_PTR(ptr) ((PBYTE) ((DWORD_PTR)((PBYTE)ptr + 3) & ~(DWORD_PTR)3))

#define DNS_NEXT_DDWORD_PTR(ptr) ((PBYTE) ((DWORD_PTR)((PBYTE)ptr + 7) & ~(DWORD_PTR)7))

#ifdef IA64
    #define DNS_NEXT_ALIGNED_PTR(p) DNS_NEXT_DDWORD_PTR(p)
#else
    #define DNS_NEXT_ALIGNED_PTR(p) DNS_NEXT_DWORD_PTR(p)
#endif

#define DNS_IS_DWORD_ALIGNED(p) ( !((DWORD_PTR)(p) & (DWORD_PTR)3) )


//
//  Helpful record macros
//  - no side effects in arguments
//

#define DNS_GET_NEXT_NAME(pname) \
            (PDNS_RPC_NAME) ((pname)->achName + (pname)->cchNameLength)

#define DNS_IS_NAME_IN_RECORD(pRecord, pname) \
            ( DNS_GET_END_OF_RPC_RECORD_DATA(pRecord) >= \
                (PCHAR)DNS_GET_NEXT_NAME(pname) )

#define DNS_GET_END_OF_RPC_RECORD_DATA(pRecord) \
            ( (PCHAR)&(pRecord)->Data + (pRecord)->wDataLength )

#define DNS_IS_RPC_RECORD_WITHIN_BUFFER( pRecord, pStopByte ) \
            ( (PCHAR)&(pRecord)->Data <= (pStopByte)  && \
                DNS_GET_END_OF_RPC_RECORD_DATA(pRecord) <= (pStopByte) )

#define DNS_GET_NEXT_RPC_RECORD(pRecord) \
            ( (PDNS_RPC_RECORD) \
                DNS_NEXT_DWORD_PTR( DNS_GET_END_OF_RPC_RECORD_DATA(pRecord) ) )

//
//  These RPC structures have no version because they are simple
//  are they are explicitly defined by their names.
//

typedef struct _DnssrvRpcNameAndParam
{
    DWORD       dwParam;
    LPSTR       pszNodeName;
}
DNS_RPC_NAME_AND_PARAM, *PDNS_RPC_NAME_AND_PARAM;


typedef struct _DnssrvRpcNameAndString
{
    LPWSTR      pwszParam;
    LPSTR       pszNodeName;
    DWORD       dwFlags;
}
DNS_RPC_NAME_AND_STRING, *PDNS_RPC_NAME_AND_STRING;

typedef struct _DnssrvRpcNameAndIPList
{
    PIP4_ARRAY  aipList;
    LPSTR       pszNodeName;
    DWORD       dwFlags;
}
DNS_RPC_NAME_AND_IPLIST, *PDNS_RPC_NAME_AND_IPLIST;



//
//  Record viewing API
//

#define DNS_RPC_VIEW_AUTHORITY_DATA     0x00000001
#define DNS_RPC_VIEW_CACHE_DATA         0x00000002
#define DNS_RPC_VIEW_GLUE_DATA          0x00000004
#define DNS_RPC_VIEW_ROOT_HINT_DATA     0x00000008
#define DNS_RPC_VIEW_ALL_DATA           0x0000000f
#define DNS_RPC_VIEW_ADDITIONAL_DATA    0x00000010

#define DNS_RPC_VIEW_NO_CHILDREN        0x00010000
#define DNS_RPC_VIEW_ONLY_CHILDREN      0x00020000
#define DNS_RPC_VIEW_CHILDREN_MASK      0x000f0000

DNS_STATUS
DNS_API_FUNCTION
DnssrvEnumRecordsEx(
    IN      DWORD       dwClientVersion,
    IN      DWORD       dwSettingFlags,
    IN      LPCWSTR     Server,
    IN      LPCSTR      pszZoneName,
    IN      LPCSTR      pszNodeName,
    IN      LPCSTR      pszStartChild,
    IN      WORD        wRecordType,
    IN      DWORD       dwSelectFlag,
    IN      LPCSTR      pszFilterStart,
    IN      LPCSTR      pszFilterStop,
    IN OUT  PDWORD      pdwBufferLength,
    OUT     PBYTE *     ppBuffer
    );

#define DnssrvEnumRecords( s, z, n, sc, typ, sf, fstart, fstop, blen, p )   \
    DnssrvEnumRecordsEx( DNS_RPC_CURRENT_CLIENT_VER,                        \
        0, (s), (z), (n), (sc), (typ),                                      \
        (sf), (fstart), (fstop), (blen), (p) )

#define DnssrvFreeRecordsBuffer( pBuf ) \
        DnssrvFreeRpcBuffer( (PDNS_RPC_BUFFER)pBuf )


PCHAR
DnssrvGetWksServicesInRecord(
    IN      PDNS_FLAT_RECORD    pRR
    );


//
//  Record management API
//

DNS_STATUS
DNS_API_FUNCTION
DnssrvUpdateRecordEx(
    IN      DWORD               dwClientVersion,
    IN      DWORD               dwSettingFlags,
    IN      LPCWSTR             pwszServer,
    IN      LPCSTR              pszZoneName,
    IN      LPCSTR              pszNodeName,
    IN      PDNS_RPC_RECORD     pAddRecord,
    IN      PDNS_RPC_RECORD     pDeleteRecord
    );

#define DnssrvUpdateRecord( s, z, n, add, del )             \
    DnssrvUpdateRecordEx( DNS_RPC_CURRENT_CLIENT_VER,       \
        0, (s), (z), (n), (add), (del) )

DNS_STATUS
DNS_API_FUNCTION
DnssrvDeleteNode(
    IN      LPCWSTR         pwszServer,
    IN      LPCSTR          pszZoneName,
    IN      LPCSTR          pszNodeName,
    IN      BOOL            bDeleteSubtree
    );

DNS_STATUS
DNS_API_FUNCTION
DnssrvDeleteRecordSet(
    IN      LPCWSTR         pwszServer,
    IN      LPCSTR          pszZoneName,
    IN      LPCSTR          pszNodeName,
    IN      WORD            wType
    );

DNS_STATUS
DNS_API_FUNCTION
DnssrvForceAging(
    IN      LPCWSTR         pwszServer,
    IN      LPCSTR          pszZoneName,
    IN      LPCSTR          pszNodeName,
    IN      BOOL            fAgeSubtree
    );



//
//  Programmable record management API -- for Small Business Server (SBS)
//

VOID
DNS_API_FUNCTION
DnssrvFillRecordHeader(
    IN OUT  PDNS_RPC_RECORD     pRecord,
    IN      DWORD               dwTtl,
    IN      DWORD               dwTimeout,
    IN      BOOL                fSuppressNotify
    );

DWORD
DNS_API_FUNCTION
DnssrvWriteNameToFlatBuffer(
    IN OUT  PCHAR               pchWrite,
    IN      LPCSTR              pszName
    );

DNS_STATUS
DNS_API_FUNCTION
DnssrvFillOutSingleIndirectionRecord(
    IN OUT  PDNS_RPC_RECORD     pRecord,
    IN      WORD                wType,
    IN      LPCSTR              pszName
    );

DNS_STATUS
DNS_API_FUNCTION
DnssrvAddARecord(
    IN      LPCWSTR     pwszServer,
    IN      LPCSTR      pszNodeName,
    IN      IP4_ADDRESS ipAddress,
    IN      DWORD       dwTtl,
    IN      DWORD       dwTimeout,
    IN      BOOL        fSuppressNotify
    );

DNS_STATUS
DNS_API_FUNCTION
DnssrvAddCnameRecord(
    IN      LPCWSTR     pwszServer,
    IN      LPCSTR      pszNodeName,
    IN      LPCSTR      pszCannonicalName,
    IN      DWORD       dwTtl,
    IN      DWORD       dwTimeout,
    IN      BOOL        fSuppressNotify
    );

DNS_STATUS
DNS_API_FUNCTION
DnssrvAddMxRecord(
    IN      LPCWSTR     pwszServer,
    IN      LPCSTR      pszNodeName,
    IN      LPCSTR      pszMailExchangeHost,
    IN      WORD        wPreference,
    IN      DWORD       dwTtl,
    IN      DWORD       dwTimeout,
    IN      BOOL        fSuppressNotify
    );

DNS_STATUS
DNS_API_FUNCTION
DnssrvAddNsRecord(
    IN      LPCWSTR     pwszServer,
    IN      LPCSTR      pszNodeName,
    IN      LPCSTR      pszNsHostName,
    IN      DWORD       dwTtl,
    IN      DWORD       dwTimeout,
    IN      BOOL        fSuppressNotify
    );

DNS_STATUS
DNS_API_FUNCTION
DnssrvConcatDnsNames(
    OUT     PCHAR       pszResult,
    IN      LPCSTR      pszDomain,
    IN      LPCSTR      pszName
    );

DNS_STATUS
DNS_API_FUNCTION
DnssrvDeleteARecord(
    IN      LPCWSTR     pwszServer,
    IN      LPCSTR      pszName,
    IN      IP4_ADDRESS ipHost,
    IN      BOOL        fSuppressNotify
    );

DNS_STATUS
DNS_API_FUNCTION
DnssrvDeleteCnameRecord(
    IN      LPCWSTR     pwszServer,
    IN      LPCSTR      pszNodeName,
    IN      LPCSTR      pszCannonicalName,
    IN      BOOL        fSuppressNotify
    );

DNS_STATUS
DNS_API_FUNCTION
DnssrvDeleteMxRecord(
    IN      LPCWSTR     pwszServer,
    IN      LPCSTR      pszNodeName,
    IN      LPCSTR      pszMailExchangeHost,
    IN      WORD        wPreference,
    IN      BOOL        fSuppressNotify
    );

DNS_STATUS
DNS_API_FUNCTION
DnssrvDeleteNsRecord(
    IN      LPCWSTR     pwszServer,
    IN      LPCSTR      pszNodeName,
    IN      LPCSTR      pszNsHostName,
    IN      BOOL        fSuppressNotify
    );

DNS_STATUS
DNS_API_FUNCTION
DnssrvSbsAddClientToIspZone(
    IN      LPCWSTR     pwszServer,
    IN      LPCSTR      pszIspZone,
    IN      LPCSTR      pszClient,
    IN      LPCSTR      pszClientHost,
    IN      IP4_ADDRESS ipClientHost,
    IN      DWORD       dwTtl
    );

DNS_STATUS
DNS_API_FUNCTION
DnssrvSbsDeleteRecord(
    IN      LPCWSTR     pwszServer,
    IN      LPCSTR      pszZone,
    IN      LPCSTR      pszDomain,
    IN      LPCSTR      pszName,
    IN      WORD        wType,
    IN      LPCSTR      pszDataName,
    IN      IP4_ADDRESS ipHost
    );


//
//  DNS_RECORD compatible record API
//

//
//  No MIDL for DNS_NODE type (to avoid bringing in dnsapi.h)
//  or for local print routines
//

#ifndef MIDL_PASS

//
//  Node structure for Admin side
//

#include <dnsapi.h>

typedef struct _DnssrvNodeFlags
{
    BYTE    Domain      : 1;
    BYTE    ZoneRoot    : 1;
    BYTE    Unused      : 5;

    BYTE    Unused2     : 5;
    BYTE    FreeOwner   : 1;
    BYTE    Unicode     : 1;
    BYTE    Utf8        : 1;

    WORD    Reserved;
}
DNSNODE_FLAGS;

typedef struct _DnssrvNode
{
    struct _DnssrvNode *    pNext;
    PWSTR                   pName;
    PDNS_RECORD             pRecord;
    union
    {
        DWORD               W;  // flags as dword
        DNSNODE_FLAGS       S;  // flags as structure

    } Flags;
}
DNS_NODE, *PDNS_NODE;


//
//  Record "section" flags
//
//  Overload DNS_RECORD.Flag section fields with RPC data type info
//

#define     DNSREC_CACHE_DATA   (0x00000000)
#define     DNSREC_ZONE_DATA    (0x00000001)
#define     DNSREC_GLUE_DATA    (0x00000002)
#define     DNSREC_ROOT_HINT    (0x00000003)


DNS_STATUS
DNS_API_FUNCTION
DnssrvEnumRecordsAndConvertNodes(
    IN      LPCWSTR         pwszServer,
    IN      LPCSTR          pszZoneName,
    IN      LPCSTR          pszNodeName,
    IN      LPCSTR          pszStartChild,
    IN      WORD            wRecordType,
    IN      DWORD           dwSelectFlag,
    IN      LPCSTR          pszFilterStart,
    IN      LPCSTR          pszFilterStop,
    OUT     PDNS_NODE *     ppNodeFirst,
    OUT     PDNS_NODE *     ppNodeLast
    );

VOID
DNS_API_FUNCTION
DnssrvFreeNode(
    IN OUT  PDNS_NODE       pNode,
    IN      BOOLEAN         fFreeRecords
    );

VOID
DNS_API_FUNCTION
DnssrvFreeNodeList(
    IN OUT  PDNS_NODE       pNode,
    IN      BOOLEAN         fFreeRecords
    );

#endif  // not MIDL_PASS



//
//  Directory partition APIs
//

DNS_STATUS
DNS_API_FUNCTION
DnssrvSetupDefaultDirectoryPartitions(
    IN      LPCWSTR                         Server,
    IN      DWORD                           dwOperation
    );

#define DNS_ENUMDPS_CUSTOMONLY  0x0001

DNS_STATUS
DNS_API_FUNCTION
DnssrvEnumDirectoryPartitions(
    IN      LPCWSTR                         Server,
    IN      DWORD                           dwFilter,
    OUT     PDNS_RPC_DP_LIST *              ppDpList
    );

DNS_STATUS
DNS_API_FUNCTION
DnssrvDirectoryPartitionInfo(
    IN      LPCWSTR                 Server,
    IN      LPSTR                   pDpFqdn,
    OUT     PDNS_RPC_DP_INFO *      ppDpInfo
    );

DNS_STATUS
DNS_API_FUNCTION
DnssrvGetDpInfo(
    IN      LPCWSTR                 pwszServer,
    IN      LPCSTR                  pszDp,
    OUT     PDNS_RPC_DP_INFO *      ppDpInfo
    );

VOID
DNS_API_FUNCTION
DnssrvFreeDirectoryPartitionEnum(
    IN OUT  PDNS_RPC_DP_ENUM                pDp
    );

VOID
DNS_API_FUNCTION
DnssrvFreeDirectoryPartitionInfo(
    IN OUT  PDNS_RPC_DP_INFO                pDp
    );

VOID
DNS_API_FUNCTION
DnssrvFreeDirectoryPartitionList(
    IN OUT  PDNS_RPC_DP_LIST                pDpList
    );

DNS_STATUS
DNS_API_FUNCTION
DnssrvEnlistDirectoryPartition(
    IN      LPCWSTR                         pszServer,
    IN      DWORD                           dwOperation,
    IN      LPCSTR                          pszDirPartFqdn
    );

#define     DNS_VERBOSE_NONE        0
#define     DNS_VERBOSE_PROGRESS    1
#define     DNS_VERBOSE_WARNING     2
#define     DNS_VERBOSE_ERROR       3

DNS_STATUS
DNS_API_FUNCTION
DnssrvCreateAllDomainDirectoryPartitions(
    IN      LPCWSTR     pszServer,
    IN      DWORD       dwVerbose
    );



//
//  NT5+ General API
//
//  For NT5+ there is a very small set of actually remoteable API,
//  which are highly extensible.  The basic approach is to have
//  query and operation functions which can handle many different
//  operations by taking the operation and type as parameters.
//

//
//  DNS Server Properties
//
//  Properties may be queried.
//  Properties may and new data may be sent in as operation to
//  reset property.
//

#define DNS_REGKEY_BOOT_REGISTRY            "EnableRegistryBoot"
#define DNS_REGKEY_BOOT_METHOD              "BootMethod"
#define DNS_REGKEY_ADMIN_CONFIGURED         "AdminConfigured"

#define DNS_REGKEY_BOOT_FILENAME            "BootFile"
#define DNS_REGKEY_ROOT_HINTS_FILE          "RootHintsFile"
#define DNS_REGKEY_DATABASE_DIRECTORY       "DatabaseDirectory"
#define DNS_REGKEY_RPC_PROTOCOL             "RpcProtocol"
#define DNS_REGKEY_ENABLE_ADVDB_LOCKING     "EnableAdvancedDatabaseLocking"
#define DNS_REGKEY_LOG_LEVEL                "LogLevel"
#define DNS_REGKEY_OPS_LOG_LEVEL1           "OperationsLogLevel"
#define DNS_REGKEY_OPS_LOG_LEVEL2           "OperationsLogLevel2"
#define DNS_REGKEY_LOG_FILE_MAX_SIZE        "LogFileMaxSize"
#define DNS_REGKEY_LOG_FILE_PATH            "LogFilePath"
#define DNS_REGKEY_LOG_IP_FILTER_LIST       "LogIPFilterList"
#define DNS_REGKEY_EVENTLOG_LEVEL           "EventLogLevel"
#define DNS_REGKEY_USE_SYSTEM_EVENTLOG      "UseSystemEventLog"
#define DNS_REGKEY_DEBUG_LEVEL              "DebugLevel"
#define DNS_REGKEY_EVENT_CONTROL            "EventControlSuppression"

#define DNS_REGKEY_LISTEN_ADDRESSES         "ListenAddresses"
#define DNS_REGKEY_PUBLISH_ADDRESSES        "PublishAddresses"
#define DNS_REGKEY_DISJOINT_NETS            "DisjointNets"
#define DNS_REGKEY_SEND_PORT                "SendPort"
#define DNS_REGKEY_NO_TCP                   "NoTcp"
#define DNS_REGKEY_XFR_CONNECT_TIMEOUT      "XfrConnectTimeout"

#define DNS_REGKEY_NO_RECURSION             "NoRecursion"
#define DNS_REGKEY_RECURSE_SINGLE_LABEL     "RecurseSingleLabel"
#define DNS_REGKEY_MAX_CACHE_TTL            "MaxCacheTtl"
#define DNS_REGKEY_MAX_NEGATIVE_CACHE_TTL   "MaxNegativeCacheTtl"
#define DNS_REGKEY_LAME_DELEGATION_TTL      "LameDelegationTtl"
#define DNS_REGKEY_SECURE_RESPONSES         "SecureResponses"
#define DNS_REGKEY_RECURSION_RETRY          "RecursionRetry"
#define DNS_REGKEY_RECURSION_TIMEOUT        "RecursionTimeout"
#define DNS_REGKEY_ADDITIONAL_RECURSION_TIMEOUT     "AdditionalRecursionTimeout"
#define DNS_REGKEY_FORWARDERS               "Forwarders"
#define DNS_REGKEY_FORWARD_TIMEOUT          "ForwardingTimeout"
#define DNS_REGKEY_SLAVE                    "IsSlave"
#define DNS_REGKEY_FORWARD_DELEGATIONS      "ForwardDelegations"
#define DNS_REGKEY_INET_RECURSE_TO_ROOT_MASK    "RecurseToInternetRootMask"
#define DNS_REGKEY_AUTO_CREATE_DELEGATIONS  "AutoCreateDelegations"
#define DNS_REGKEY_ALLOW_CNAME_AT_NS        "AllowCNAMEAtNS"

#define DNS_REGKEY_NO_AUTO_REVERSE_ZONES    "DisableAutoReverseZones"
#define DNS_REGKEY_DS_POLLING_INTERVAL      "DsPollingInterval"
#define DNS_REGKEY_DS_TOMBSTONE_INTERVAL    "DsTombstoneInterval"
#define DNS_REGKEY_DS_LAZY_UPDATE_INTERVAL  "DsLazyUpdateInterval"

#define DNS_REGKEY_AUTO_CACHE_UPDATE            "AutoCacheUpdate"
#define DNS_REGKEY_ALLOW_UPDATE                 "AllowUpdate"
#define DNS_REGKEY_UPDATE_OPTIONS               "UpdateOptions"
#define DNS_REGKEY_NO_UPDATE_DELEGATIONS        "NoUpdateDelegations"
#define DNS_REGKEY_AUTO_CONFIG_FILE_ZONES       "AutoConfigFileZones"
#define DNS_REGKEY_SCAVENGING_INTERVAL          "ScavengingInterval"
#define DNS_REGKEY_SCAVENGING_STATE             "ScavengingState"
#define DNS_REGKEY_ENABLE_UPDATE_FORWARDING     "EnableUpdateForwarding"
#define DNS_REGKEY_MAX_RRS_IN_NONSECURE_UPDATE  "MaxResourceRecordsInNonSecureUpdate"

#define DNS_REGKEY_ENABLE_WINSR                 "EnableWinsR"
#define DNS_REGKEY_NAME_CHECK_FLAG              "NameCheckFlag"
#define DNS_REGKEY_ROUND_ROBIN                  "RoundRobin"
#define DNS_REGKEY_NO_ROUND_ROBIN               "DoNotRoundRobinTypes"
#define DNS_REGKEY_LOCAL_NET_PRIORITY           "LocalNetPriority"
#define DNS_REGKEY_LOCAL_NET_PRIORITY_NETMASK   "LocalNetPriorityNetMask"
#define DNS_REGKEY_ADDRESS_ANSWER_LIMIT         "AddressAnswerLimit"
#define DNS_REGKEY_BIND_SECONDARIES             "BindSecondaries"
#define DNS_REGKEY_WRITE_AUTHORITY_SOA          "WriteAuthoritySoa"
#define DNS_REGKEY_WRITE_AUTHORITY_NS           "WriteAuthorityNs"
#define DNS_REGKEY_STRICT_FILE_PARSING          "StrictFileParsing"
#define DNS_REGKEY_DELETE_OUTSIDE_GLUE          "DeleteOutsideGlue"
#define DNS_REGKEY_LOOSE_WILDCARDING            "LooseWildcarding"
#define DNS_REGKEY_WILDCARD_ALL_TYPES           "WildcardAllTypes"

#define DNS_REGKEY_APPEND_MS_XFR_TAG            "AppendMsZoneTransferTag"

#define DNS_REGKEY_DEFAULT_AGING_STATE          "DefaultAgingState"
#define DNS_REGKEY_DEFAULT_REFRESH_INTERVAL     "DefaultRefreshInterval"
#define DNS_REGKEY_DEFAULT_NOREFRESH_INTERVAL   "DefaultNoRefreshInterval"

#define DNS_REGKEY_MAX_CACHE_SIZE               "MaxCacheSize"      //  in kilobytes
#define DNS_REGKEY_CACHE_EMPTY_AUTH_RESPONSES   "CacheEmptyAuthResponses"

#define DNS_REGKEY_ENABLE_EDNS              "EnableEDnsProbes"
#define DNS_REGKEY_MAX_UDP_PACKET_SIZE      "MaximumUdpPacketSize"
#define DNS_REGKEY_TCP_RECV_PACKET_SIZE     "TcpReceivePacketSize"
#define DNS_REGKEY_EDNS_CACHE_TIMEOUT       "EDnsCacheTimeout"

#define DNS_REGKEY_ENABLE_DNSSEC            "EnableDnsSec"

#define DNS_REGKEY_ENABLE_SENDERR_SUPPRESSION   "EnableSendErrorSuppression"

#define DNS_REGKEY_SELFTEST                 "SelfTest"

#define DNS_REGKEY_ENABLEIPV6               "EnableIPv6"

#define DNS_REGKEY_XFR_THROTTLE_MULTIPLIER  "XfrThrottleMultiplier"

#define DNS_REGKEY_ENABLE_DP                "EnableDirectoryPartitions"
#define DNS_REGKEY_FOREST_DP_BASE_NAME      "ForestDirectoryPartitionBaseName"
#define DNS_REGKEY_DOMAIN_DP_BASE_NAME      "DomainDirectoryPartitionBaseName"
#define DNS_REGKEY_DP_ENLIST_INTERVAL       "DirectoryPartitionAutoEnlistInterval"      //  in seconds

#define DNS_REGKEY_DISABLE_AUTONS           "DisableNSRecordsAutoCreation" // 0/1 flag

#define DNS_REGKEY_SILENT_IGNORE_CNAME_UPDATE_CONFLICT  "SilentlyIgnoreCNameUpdateConflicts"

#define DNS_REGKEY_ENABLE_FAKEIQUERY        "EnableIQueryResponseGeneration"

#define DNS_REGKEY_SERVER_PLUGIN            "ServerLevelPluginDll"


//  Zone properties

#define DNS_REGKEY_ZONE_TYPE                "Type"
#define DNS_REGKEY_ZONE_FILE                "DatabaseFile"
#define DNS_REGKEY_ZONE_MASTERS             "MasterServers"
#define DNS_REGKEY_ZONE_LOCAL_MASTERS       "LocalMasterServers"
#define DNS_REGKEY_ZONE_SECURE_SECONDARIES  "SecureSecondaries"
#define DNS_REGKEY_ZONE_NOTIFY_LEVEL        "NotifyLevel"
#define DNS_REGKEY_ZONE_SECONDARIES         "SecondaryServers"
#define DNS_REGKEY_ZONE_NOTIFY_LIST         "NotifyServers"
#define DNS_REGKEY_ZONE_ALLOW_UPDATE        "AllowUpdate"
#define DNS_REGKEY_ZONE_DS_INTEGRATED       "DsIntegrated"
#define DNS_REGKEY_ZONE_DIRECTORY_PARTITION "DirectoryPartition"
#define DNS_REGKEY_ZONE_LOG_UPDATES         "LogUpdates"
#define DNS_REGKEY_ZONE_FWD_TIMEOUT         "ForwarderTimeout"
#define DNS_REGKEY_ZONE_FWD_SLAVE           "ForwarderSlave"

#define DNS_REGKEY_ZONE_AGING               "Aging"
#define DNS_REGKEY_ZONE_NOREFRESH_INTERVAL  "NoRefreshInterval"
#define DNS_REGKEY_ZONE_REFRESH_INTERVAL    "RefreshInterval"
#define DNS_REGKEY_ZONE_SCAVENGE_SERVERS    "ScavengeServers"

#define DNS_REGKEY_ZONE_ALLOW_AUTONS        "AllowNSRecordsAutoCreation" // IP list


//
//  Debugging aids
//

#define DNS_REGKEY_BREAK_ON_ASC_FAILURE         "BreakOnAscFailure"         //  0/1 - ASC=AcceptSecurityContext
#define DNS_REGKEY_BREAK_ON_UPDATE_FROM         "BreakOnUpdateFrom"         //  IP list
#define DNS_REGKEY_BREAK_ON_RECV_FROM           "BreakOnReceiveFrom"        //  IP list
#define DNS_REGKEY_ZONE_BREAK_ON_NAME_UPDATE    "BreakOnNameUpdate"         //  node name
#define DNS_REGKEY_IGNORE_RPC_ACCESS_FAILURES   "IgnoreRpcAccessFailures"   //  node name


//
//  Property defaults
//

//  DCR_CLEANUP:   remove PROP_BOOT_X flags
#define PROP_BOOT_REGISTRY                  (1)
#define PROP_BOOT_FILE                      (0)

#define DNS_DEFAULT_BOOT_REGISTRY           (PROP_BOOT_REGISTRY)

#define DNS_DEFAULT_BOOT_METHOD             (BOOT_METHOD_UNINITIALIZED)
#define DNS_DEFAULT_RPC_PROTOCOL            (0xffffffff)
#define DNS_DEFAULT_DB_LOCKING              (1)
#define DNS_DEFAULT_LOG_LEVEL               (0)
#define DNS_DEFAULT_LOG_FILE_MAX_SIZE       (500000000) //  500 MB
#define DNS_DEFAULT_EVENTLOG_LEVEL          (EVENTLOG_INFORMATION_TYPE)
#define DNS_DEFAULT_USE_SYSTEM_EVENTLOG     FALSE
#define DNS_DEFAULT_DEBUG_LEVEL             (0)

#define DNS_DEFAULT_SEND_PORT               (0)
#define DNS_DEFAULT_NO_TCP                  FALSE
#define DNS_DEFAULT_DISJOINT_NETS           FALSE
#define DNS_DEFAULT_SEND_ON_NON_DNS_PORT    FALSE
#define DNS_DEFAULT_XFR_CONNECT_TIMEOUT     (30)        // 30 seconds

#define DNS_DEFAULT_NO_RECURSION            FALSE
#define DNS_DEFAULT_RECURSE_SINGLE_LABEL    FALSE
#define DNS_DEFAULT_MAX_CACHE_TTL           (86400)     //  1 day
#define DNS_DEFAULT_MAX_NEGATIVE_CACHE_TTL  (900)       //  15 minutes
#define DNS_DEFAULT_LAME_DELEGATION_TTL     (24*60*60)  //  1 day
#define DNS_DEFAULT_SECURE_RESPONSES        TRUE        //  cache pollution protection
#define DNS_DEFAULT_RECURSION_RETRY         (3)         //  3 seconds
#define DNS_DEFAULT_RECURSION_TIMEOUT       (15)        //  15 seconds
#define DNS_DEFAULT_ADDITIONAL_RECURSION_TIMEOUT (15)   //  15 seconds
#define DNS_DEFAULT_FORWARD_TIMEOUT         (5)         //  5 seconds
#define DNS_DEFAULT_SLAVE                   FALSE
#define DNS_DEFAULT_FORWARD_DELEGATIONS     FALSE
#define DNS_DEFAULT_INET_RECURSE_TO_ROOT_MASK   0xFFFFFFFF  //  all ON by default

#define DNS_DEFAULT_NO_AUTO_REVERSE_ZONES       FALSE
#define DNS_DEFAULT_DS_POLLING_INTERVAL         (180)       //  3 minutes
#define DNS_DEFAULT_DS_TOMBSTONE_INTERVAL       (604800)    //  1 week
#define DNS_DEFAULT_DS_LAZY_UPDATE_INTERVAL     (3)         //  seconds
#define DNS_DEFAULT_AUTO_CACHE_UPDATE           FALSE
#define DNS_DEFAULT_ALLOW_UPDATE                ZONE_UPDATE_UNSECURE
#define DNS_DEFAULT_NO_UPDATE_DELEGATIONS       FALSE
#define DNS_DEFAULT_DISABLE_AUTO_NS_RECORDS     FALSE
#define DNS_DEFAULT_ENABLE_UPDATE_FORWARDING    FALSE
#define DNS_DEFAULT_MAX_RRS_IN_NONSECURE_UPDATE (30)
#define DNS_DEFAULT_ENABLE_WINSR                TRUE


#define DNS_DEFAULT_NAME_CHECK_FLAG         DNS_ALLOW_MULTIBYTE_NAMES
#define DNS_DEFAULT_ROUND_ROBIN             TRUE
#define DNS_DEFAULT_ADDRESS_ANSWER_LIMIT    (0)
#define DNS_DEFAULT_BIND_SECONDARIES        TRUE
#define DNS_DEFAULT_WRITE_AUTHORITY_NS      FALSE
#define DNS_DEFAULT_STRICT_FILE_PARSING     FALSE
#define DNS_DEFAULT_DELETE_OUTSIDE_GLUE     FALSE
#define DNS_DEFAULT_LOOSE_WILDCARDING       FALSE
#define DNS_DEFAULT_WILDCARD_ALL_TYPES      FALSE

#define DNS_DEFAULT_APPEND_MS_XFR_TAG       TRUE

#define DNS_DEFAULT_SCAVENGING_INTERVAL     (0)         // scavenging OFF
#define DNS_DEFAULT_SCAVENGING_INTERVAL_ON  (168)       // a week, 7*24 hours

#define DNS_DEFAULT_AGING_STATE             FALSE
#define DNS_DEFAULT_NOREFRESH_INTERVAL      (168)       // a week, 7*24 hours
#define DNS_DEFAULT_REFRESH_INTERVAL        (168)       // a week (7*24)

#define DNS_SERVER_UNLIMITED_CACHE_SIZE         ((DWORD)-1)     //  default: no limit

#define DNS_DEFAULT_LOCAL_NET_PRIORITY          TRUE
#define DNS_DEFAULT_LOCAL_NET_PRIORITY_NETMASK  0x000000FF      //  sort down to class C netmask

#define DNS_DEFAULT_FOREST_DP_BASE          "ForestDnsZones"
#define DNS_DEFAULT_DOMAIN_DP_BASE          "DomainDnsZones"
#define DNS_DEFAULT_DP_ENLIST_INTERVAL      (60*60*24)          //  one day


#define DNS_DEFAULT_AUTO_CREATION_DELEGATIONS   DNS_ACD_ONLY_IF_NO_DELEGATION_IN_PARENT

#define DNS_DEFAULT_ALLOW_CNAME_AT_NS           TRUE

#define DNS_DNSSEC_ENABLE_DEFAULT               DNS_DNSSEC_ENABLED_IF_EDNS

#define DNS_DEFAULT_XFR_THROTTLE_MULTIPLIER     10

#define DNS_DEFAULT_TCP_RECEIVE_PACKET_SIZE     0x10000         //  64 KB


//
//  Operations
//
//  In addition to resetting properties, the following operations
//  are available.
//

//  Server operations

#define DNSSRV_OP_RESET_DWORD_PROPERTY      "ResetDwordProperty"
#define DNSSRV_OP_RESTART                   "Restart"
#define DNSSRV_OP_DEBUG_BREAK               "DebugBreak"
#define DNSSRV_OP_CLEAR_DEBUG_LOG           "ClearDebugLog"
#define DNSSRV_OP_ROOT_BREAK                "RootBreak"
#define DNSSRV_OP_CLEAR_CACHE               "ClearCache"
#define DNSSRV_OP_WRITE_DIRTY_ZONES         "WriteDirtyZones"
#define DNSSRV_OP_ZONE_CREATE               "ZoneCreate"
#define DNSSRV_OP_CLEAR_STATISTICS          "ClearStatistics"
#define DNSSRV_OP_ENUM_ZONES                "EnumZones"
#define DNSSRV_OP_ENUM_ZONES2               "EnumZones2"    //  allows more filtering
#define DNSSRV_OP_ENUM_DPS                  "EnumDirectoryPartitions"
#define DNSSRV_OP_DP_INFO                   "DirectoryPartitionInfo"
#define DNSSRV_OP_ENLIST_DP                 "EnlistDirectoryPartition"
#define DNSSRV_OP_SETUP_DFLT_DPS            "SetupDefaultDirectoryPartitions"
#define DNSSRV_OP_ENUM_RECORDS              "EnumRecords"
#define DNSSRV_OP_START_SCAVENGING          "StartScavenging"
#define DNSSRV_OP_ABORT_SCAVENGING          "AbortScavenging"
#define DNSSRV_OP_AUTO_CONFIGURE            "AutoConfigure"

//  Zone operations

#define DNSSRV_OP_ZONE_TYPE_RESET           "ZoneTypeReset"
#define DNSSRV_OP_ZONE_PAUSE                "PauseZone"
#define DNSSRV_OP_ZONE_RESUME               "ResumeZone"
#define DNSSRV_OP_ZONE_LOCK                 "LockZone"
#define DNSSRV_OP_ZONE_DELETE               "DeleteZone"
#define DNSSRV_OP_ZONE_RELOAD               "ReloadZone"
#define DNSSRV_OP_ZONE_REFRESH              "RefreshZone"
#define DNSSRV_OP_ZONE_EXPIRE               "ExpireZone"
#define DNSSRV_OP_ZONE_INCREMENT_VERSION    "IncrementVersion"
#define DNSSRV_OP_ZONE_WRITE_BACK_FILE      "WriteBackFile"
#define DNSSRV_OP_ZONE_WRITE_ANSI_FILE      "WriteAnsiFile"
#define DNSSRV_OP_ZONE_DELETE_FROM_DS       "DeleteZoneFromDs"
#define DNSSRV_OP_ZONE_UPDATE_FROM_DS       "UpdateZoneFromDs"
#define DNSSRV_OP_ZONE_RENAME               "ZoneRename"
#define DNSSRV_OP_ZONE_EXPORT               "ZoneExport"
#define DNSSRV_OP_ZONE_CHANGE_DP            "ZoneChangeDirectoryPartition"

#define DNSSRV_OP_UPDATE_RECORD             "UpdateRecord"
#define DNSSRV_OP_DELETE_NODE               "DeleteNode"
#define DNSSRV_OP_ZONE_DELETE_NODE          DNSSRV_OP_DELETE_NODE
#define DNSSRV_OP_DELETE_RECORD_SET         "DeleteRecordSet"
#define DNSSRV_OP_FORCE_AGING_ON_NODE       "ForceAgingOnNode"

//
//  Special non-property queries
//

#define DNSSRV_QUERY_DWORD_PROPERTY         "QueryDwordProperty"
#define DNSSRV_QUERY_STRING_PROPERTY        "QueryStringProperty"
#define DNSSRV_QUERY_IPLIST_PROPERTY        "QueryIPListProperty"
#define DNSSRV_QUERY_SERVER_INFO            "ServerInfo"
#define DNSSRV_QUERY_STATISTICS             "Statistics"

#define DNSSRV_QUERY_ZONE_HANDLE            "ZoneHandle"
#define DNSSRV_QUERY_ZONE                   "Zone"
#define DNSSRV_QUERY_ZONE_INFO              "ZoneInfo"

//
// Values for DNS_RPC_NAME_AND_PARAM.dwParam
//
//
#define DNSSRV_OP_PARAM_APPLY_ALL_ZONES     0x10000000
#define REMOVE_APPLY_ALL_BIT(val)           ((LONG)val &=  (~DNSSRV_OP_PARAM_APPLY_ALL_ZONES) )


//
//  Log levels for setting LogLevel property
//

#define DNS_LOG_LEVEL_ALL_PACKETS   0x0000ffff

#define DNS_LOG_LEVEL_NON_QUERY     0x000000fe
#define DNS_LOG_LEVEL_QUERY         0x00000001
#define DNS_LOG_LEVEL_NOTIFY        0x00000010
#define DNS_LOG_LEVEL_UPDATE        0x00000020

#define DNS_LOG_LEVEL_QUESTIONS     0x00000100
#define DNS_LOG_LEVEL_ANSWERS       0x00000200

#define DNS_LOG_LEVEL_SEND          0x00001000
#define DNS_LOG_LEVEL_RECV          0x00002000

#define DNS_LOG_LEVEL_UDP           0x00004000
#define DNS_LOG_LEVEL_TCP           0x00008000

#define DNS_LOG_LEVEL_FULL_PACKETS  0x01000000
#define DNS_LOG_LEVEL_WRITE_THROUGH 0x80000000

//
//  Settings for BootMethod property
//

#define BOOT_METHOD_UNINITIALIZED   (0)
#define BOOT_METHOD_FILE            (1)
#define BOOT_METHOD_REGISTRY        (2)
#define BOOT_METHOD_DIRECTORY       (3)

#define BOOT_METHOD_DEFAULT         (BOOT_METHOD_DIRECTORY)

//  Server, default aging property

#define DNS_AGING_OFF               (0)
#define DNS_AGING_DS_ZONES          (0x0000001)
#define DNS_AGING_NON_DS_ZONES      (0x0000002)
#define DNS_AGING_ALL_ZONES         (0x0000003)



//
//  Union of RPC types
//
//  This allows us to write very general API taking UNION type
//  with is extensible simply by adding operationa and types.
//  RPC simply packs\unpacks the UNION type appropriately.
//
//  Note, that UNION is actually union of pointers to types, so
//  that data can be passed between the API and the RPC stubs (on the client)
//  or dispatched (on the server) efficiently.
//

typedef enum _DnssrvRpcTypeId
{
    DNSSRV_TYPEID_ANY = ( -1 ),
    DNSSRV_TYPEID_NULL = 0,
    DNSSRV_TYPEID_DWORD,
    DNSSRV_TYPEID_LPSTR,
    DNSSRV_TYPEID_LPWSTR,
    DNSSRV_TYPEID_IPARRAY,
    DNSSRV_TYPEID_BUFFER,                       //  5
    DNSSRV_TYPEID_SERVER_INFO_W2K,
    DNSSRV_TYPEID_STATS,
    DNSSRV_TYPEID_FORWARDERS_W2K,
    DNSSRV_TYPEID_ZONE_W2K,
    DNSSRV_TYPEID_ZONE_INFO_W2K,                //  10
    DNSSRV_TYPEID_ZONE_SECONDARIES_W2K,
    DNSSRV_TYPEID_ZONE_DATABASE_W2K,
    DNSSRV_TYPEID_ZONE_TYPE_RESET_W2K,
    DNSSRV_TYPEID_ZONE_CREATE_W2K,
    DNSSRV_TYPEID_NAME_AND_PARAM,               //  15
    DNSSRV_TYPEID_ZONE_LIST_W2K,

    //
    //  Below this point is .NET.
    //

    DNSSRV_TYPEID_ZONE_RENAME,
    DNSSRV_TYPEID_ZONE_EXPORT,
    DNSSRV_TYPEID_SERVER_INFO,
    DNSSRV_TYPEID_FORWARDERS,                   //  20
    DNSSRV_TYPEID_ZONE,
    DNSSRV_TYPEID_ZONE_INFO,
    DNSSRV_TYPEID_ZONE_SECONDARIES,
    DNSSRV_TYPEID_ZONE_DATABASE,
    DNSSRV_TYPEID_ZONE_TYPE_RESET,              //  25
    DNSSRV_TYPEID_ZONE_CREATE,
    DNSSRV_TYPEID_ZONE_LIST,
    DNSSRV_TYPEID_DP_ENUM,
    DNSSRV_TYPEID_DP_INFO,
    DNSSRV_TYPEID_DP_LIST,                      //  30
    DNSSRV_TYPEID_ENLIST_DP,
    DNSSRV_TYPEID_ZONE_CHANGE_DP,
    DNSSRV_TYPEID_ENUM_ZONES_FILTER
}
DNS_RPC_TYPEID, *PDNS_RPC_TYPEID;


#ifdef MIDL_PASS

typedef [switch_type(DWORD)] union _DnssrvSrvRpcUnion
{
    [case(DNSSRV_TYPEID_NULL)]      PBYTE       Null;

    [case(DNSSRV_TYPEID_DWORD)]     DWORD       Dword;

    [case(DNSSRV_TYPEID_LPSTR)]     LPSTR       String;

    [case(DNSSRV_TYPEID_LPWSTR)]    LPWSTR      WideString;

    [case(DNSSRV_TYPEID_IPARRAY)]   PIP4_ARRAY  IpArray;

    [case(DNSSRV_TYPEID_BUFFER)]
        PDNS_RPC_BUFFER                         Buffer;

    [case(DNSSRV_TYPEID_SERVER_INFO_W2K)]
        PDNS_RPC_SERVER_INFO_W2K                ServerInfoW2K;

    [case(DNSSRV_TYPEID_STATS)]
        PDNSSRV_STATS                           Stats;

    [case(DNSSRV_TYPEID_FORWARDERS_W2K)]
        PDNS_RPC_FORWARDERS_W2K                 ForwardersW2K;

    [case(DNSSRV_TYPEID_ZONE_W2K)]
        PDNS_RPC_ZONE_W2K                       ZoneW2K;

    [case(DNSSRV_TYPEID_ZONE_INFO_W2K)]
        PDNS_RPC_ZONE_INFO_W2K                  ZoneInfoW2K;

    [case(DNSSRV_TYPEID_ZONE_SECONDARIES_W2K)]
        PDNS_RPC_ZONE_SECONDARIES_W2K           SecondariesW2K;

    [case(DNSSRV_TYPEID_ZONE_DATABASE_W2K)]
        PDNS_RPC_ZONE_DATABASE_W2K              DatabaseW2K;

    [case(DNSSRV_TYPEID_ZONE_TYPE_RESET_W2K)]
        PDNS_RPC_ZONE_TYPE_RESET_W2K            TypeResetW2K;

    [case(DNSSRV_TYPEID_ZONE_CREATE_W2K)]
        PDNS_RPC_ZONE_CREATE_INFO_W2K           ZoneCreateW2K;

    [case(DNSSRV_TYPEID_NAME_AND_PARAM)]
        PDNS_RPC_NAME_AND_PARAM                 NameAndParam;

    [case(DNSSRV_TYPEID_ZONE_LIST_W2K)]
        PDNS_RPC_ZONE_LIST_W2K                  ZoneListW2K;

    //
    //  Below this point is .NET.
    //
    
    [case(DNSSRV_TYPEID_SERVER_INFO)]
        PDNS_RPC_SERVER_INFO                    ServerInfo;

    [case(DNSSRV_TYPEID_FORWARDERS)]
        PDNS_RPC_FORWARDERS                     Forwarders;

    [case(DNSSRV_TYPEID_ZONE)]
        PDNS_RPC_ZONE                           Zone;

    [case(DNSSRV_TYPEID_ZONE_INFO)]
        PDNS_RPC_ZONE_INFO                      ZoneInfo;

    [case(DNSSRV_TYPEID_ZONE_SECONDARIES)]
        PDNS_RPC_ZONE_SECONDARIES               Secondaries;

    [case(DNSSRV_TYPEID_ZONE_DATABASE)]
        PDNS_RPC_ZONE_DATABASE                  Database;

    [case(DNSSRV_TYPEID_ZONE_TYPE_RESET)]
        PDNS_RPC_ZONE_TYPE_RESET                TypeReset;

    [case(DNSSRV_TYPEID_ZONE_CREATE)]
        PDNS_RPC_ZONE_CREATE_INFO               ZoneCreate;

    [case(DNSSRV_TYPEID_ZONE_LIST)]
        PDNS_RPC_ZONE_LIST                      ZoneList;

    [case(DNSSRV_TYPEID_ZONE_RENAME)]
        PDNS_RPC_ZONE_RENAME_INFO               ZoneRename;

    [case(DNSSRV_TYPEID_ZONE_EXPORT)]
        PDNS_RPC_ZONE_EXPORT_INFO               ZoneExport;

    [case(DNSSRV_TYPEID_DP_INFO)]
        PDNS_RPC_DP_INFO                        DirectoryPartition;

    [case(DNSSRV_TYPEID_DP_ENUM)]
        PDNS_RPC_DP_ENUM                        DirectoryPartitionEnum;

    [case(DNSSRV_TYPEID_DP_LIST)]
        PDNS_RPC_DP_LIST                        DirectoryPartitionList;

    [case(DNSSRV_TYPEID_ENLIST_DP)]
        PDNS_RPC_ENLIST_DP                      EnlistDirectoryPartition;

    [case(DNSSRV_TYPEID_ZONE_CHANGE_DP)]
        PDNS_RPC_ZONE_CHANGE_DP                 ZoneChangeDirectoryPartition;

    [case(DNSSRV_TYPEID_ENUM_ZONES_FILTER)]
        PDNS_RPC_ENUM_ZONES_FILTER              EnumZonesFilter;
}
DNSSRV_RPC_UNION;

#else

typedef union _DnssrvSrvRpcUnion
{
    PBYTE                           Null;
    DWORD                           Dword;
    LPSTR                           String;
    LPWSTR                          WideString;
    PIP4_ARRAY                      IpArray;
    PDNS_RPC_BUFFER                 Buffer;
    PDNS_RPC_SERVER_INFO_W2K        ServerInfoW2K;
    PDNSSRV_STATS                   Stats;
    PDNS_RPC_FORWARDERS_W2K         ForwardersW2K;
    PDNS_RPC_ZONE_W2K               ZoneW2K;
    PDNS_RPC_ZONE_INFO_W2K          ZoneInfoW2K;
    PDNS_RPC_ZONE_SECONDARIES_W2K   SecondariesW2K;
    PDNS_RPC_ZONE_DATABASE_W2K      DatabaseW2K;
    PDNS_RPC_ZONE_TYPE_RESET_W2K    TypeResetW2K;
    PDNS_RPC_ZONE_CREATE_INFO_W2K   ZoneCreateW2K;
    PDNS_RPC_NAME_AND_PARAM         NameAndParam;
    PDNS_RPC_ZONE_LIST_W2K          ZoneListW2K;
    PDNS_RPC_SERVER_INFO            ServerInfo;
    PDNS_RPC_FORWARDERS             Forwarders;
    PDNS_RPC_ZONE                   Zone;
    PDNS_RPC_ZONE_INFO              ZoneInfo;
    PDNS_RPC_ZONE_SECONDARIES       Secondaries;
    PDNS_RPC_ZONE_DATABASE          Database;
    PDNS_RPC_ZONE_TYPE_RESET        TypeReset;
    PDNS_RPC_ZONE_CREATE_INFO       ZoneCreate;
    PDNS_RPC_ZONE_LIST              ZoneList;
    PDNS_RPC_ZONE_RENAME_INFO       ZoneRename;
    PDNS_RPC_ZONE_EXPORT_INFO       ZoneExport;
    PDNS_RPC_DP_INFO                DirectoryPartition;
    PDNS_RPC_DP_ENUM                DirectoryPartitionEnum;
    PDNS_RPC_DP_LIST                DirectoryPartitionList;
    PDNS_RPC_ENLIST_DP              EnlistDirectoryPartition;
    PDNS_RPC_ZONE_CHANGE_DP         ZoneResetDirectoryPartition;
    PDNS_RPC_ENUM_ZONES_FILTER      EnumZonesFilter;

    //
    //  should add DNS_RECORD and DNS_NODE
    //
}
DNSSRV_RPC_UNION;

#endif


//
//  General Query and Operation API
//
//  Many of the API above are not remoteable but rather use these
//  API to contact the server.  The data fields are actually the
//  DNSSRV_RPC_UNION of pointers given above.
//
//  Client version is a 32 bit private version number in the format:
//      HIGH WORD - major OS version
//      LOW WORD - minor private version to allow for service packs, etc.
//

#define MAKE_DNS_CLIENT_VERSION( hiWord, loWord ) \
    ( ( DWORD ) ( ( ( hiWord & 0xFFFF ) << 16 ) | ( loWord & 0xFFFF ) ) )

#define DNS_RPC_DOTNET_MAJOR_VER                6   //  6 for .NET
#define DNS_RPC_DOTNET_CURRENT_MINOR_VER        0   //  increment as required

#define DNS_RPC_W2K_CLIENT_VERSION              0   //  W2K does not send ver

#define DNS_RPC_CURRENT_CLIENT_VER              \
    MAKE_DNS_CLIENT_VERSION(                    \
        DNS_RPC_DOTNET_MAJOR_VER,               \
        DNS_RPC_DOTNET_CURRENT_MINOR_VER )

DNS_STATUS
DnssrvOperationEx(
    IN      DWORD           dwClientVersion,
    IN      DWORD           dwSettingFlags,
    IN      LPCWSTR         pwszServer,
    IN      LPCSTR          pszZone,
    IN      DWORD           dwContext,
    IN      LPCSTR          pszOperation,
    IN      DWORD           dwTypeId,
    IN      PVOID           Data
    );

#define DnssrvOperation( s, z, op, id, d )          \
    DnssrvOperationEx( DNS_RPC_CURRENT_CLIENT_VER,  \
        0, (s), (z), 0, (op), (id), (d) )

DNS_STATUS
DnssrvQueryEx(
    IN      DWORD           dwClientVersion,
    IN      DWORD           dwSettingFlags,
    IN      LPCWSTR         pwszServer,
    IN      LPCSTR          pszZone,
    IN      LPCSTR          pszOperation,
    OUT     PDWORD          pdwTypeId,
    OUT     PVOID *         pData
    );

#define DnssrvQuery( s, z, op, id, d )          \
    DnssrvQueryEx( DNS_RPC_CURRENT_CLIENT_VER,  \
        0, (s), (z), (op), (id), (d) )

DNS_STATUS
DNS_API_FUNCTION
DnssrvComplexOperationEx(
    IN      DWORD           dwClientVersion,
    IN      DWORD           dwSettingFlags,
    IN      LPCWSTR         pwszServer,
    IN      LPCSTR          pszZone,
    IN      LPCSTR          pszQuery,
    IN      DWORD           dwTypeIn,
    IN      PVOID           pDataIn,
    OUT     PDWORD          pdwTypeOut,
    OUT     PVOID *         ppDataOutOut
    );

#define DnssrvComplexOperation( s, z, q, typein, din, typeout, dout )   \
    DnssrvComplexOperationEx( DNS_RPC_CURRENT_CLIENT_VER,               \
        0, (s), (z), (q), (typein), (din), (typeout), (dout) )


//
//  DWORD properties query\reset are a common case
//

DNS_STATUS
DNS_API_FUNCTION
DnssrvQueryDwordPropertyEx(
    IN      DWORD           dwClientVersion,
    IN      DWORD           dwSettingFlags,
    IN      LPCWSTR         pwszServer,
    IN      LPCSTR          pszZone,
    IN      LPCSTR          pszProperty,
    OUT     PDWORD          pdwResult
    );

#define DnssrvQueryDwordProperty( s, z, p, r )                  \
    DnssrvQueryDwordPropertyEx( DNS_RPC_CURRENT_CLIENT_VER,     \
        0, (s), (z), (p), (r) )

DNS_STATUS
DNS_API_FUNCTION
DnssrvResetDwordPropertyEx(
    IN      DWORD           dwClientVersion,
    IN      DWORD           dwSettingFlags,
    IN      LPCWSTR         pwszServer,
    IN      LPCSTR          pszZone,
    IN      DWORD           dwContext,
    IN      LPCSTR          pszProperty,
    IN      DWORD           dwPropertyValue
    );

#define DnssrvResetDwordProperty( s, z, p, v )                  \
    DnssrvResetDwordPropertyEx( DNS_RPC_CURRENT_CLIENT_VER,     \
        0, (s), (z), 0, (p), (v) )

#define DnssrvResetDwordPropertyWithContext( s, z, c, p, v )    \
    DnssrvResetDwordPropertyEx( DNS_RPC_CURRENT_CLIENT_VER,     \
        0, (s), (z), (c), (p), (v) )


DNS_STATUS
DNS_API_FUNCTION
DnssrvResetStringPropertyEx(
    IN      DWORD           dwClientVersion,
    IN      DWORD           dwSettingFlags,
    IN      LPCWSTR         pwszServerName,
    IN      LPCSTR          pszZone,
    IN      DWORD           dwContext,
    IN      LPCSTR          pszProperty,
    IN      LPCWSTR         pswzPropertyValue,
    IN      DWORD           dwFlags
    );

#define DnssrvResetStringProperty( server, zone, prop, value, flags )   \
        DnssrvResetStringPropertyEx( DNS_RPC_CURRENT_CLIENT_VER,        \
            0, (server), (zone), 0, (prop), (value), (flags) )

DNS_STATUS
DNS_API_FUNCTION
DnssrvResetIPListPropertyEx(
    IN      DWORD           dwClientVersion,
    IN      DWORD           dwSettingFlags,
    IN      LPCWSTR         pwszServerName,
    IN      LPCSTR          pszZone,
    IN      DWORD           dwContext,
    IN      LPCSTR          pszProperty,
    IN      PIP4_ARRAY      pipArray,
    IN      DWORD           dwFlags
    );

#define DnssrvResetIPListProperty( server, zone, prop, value, flags )   \
        DnssrvResetIPListPropertyEx( DNS_RPC_CURRENT_CLIENT_VER,        \
            0, (server), (zone), 0, (prop), (value), (flags) )



//
//  RPC-related functions shared by client and server
//

#ifndef MIDL_PASS

//
//  Conversion from obsolete to current RPC structures.
//

DNS_STATUS
DNS_API_FUNCTION
DnsRpc_ConvertToCurrent(
    IN      PDWORD      pdwTypeId,          IN  OUT
    IN      PVOID *     ppData              IN  OUT
    );

//
//  Print any type in RPC Union
//

VOID
DnsPrint_RpcUnion(
    IN      PRINT_ROUTINE   PrintRoutine,
    IN OUT  PPRINT_CONTEXT  pPrintContext,
    IN      LPSTR           pszHeader,
    IN      DWORD           dwTypeId,
    IN      PVOID           pData
    );

//
//  Server info printing
//

VOID
DnsPrint_RpcServerInfo(
    IN      PRINT_ROUTINE           PrintRoutine,
    IN OUT  PPRINT_CONTEXT          pPrintContext,
    IN      LPSTR                   pszHeader,
    IN      PDNS_RPC_SERVER_INFO    pServerInfo
    );

VOID
DnsPrint_RpcServerInfo_W2K(
    IN      PRINT_ROUTINE               PrintRoutine,
    IN OUT  PPRINT_CONTEXT              pPrintContext,
    IN      LPSTR                       pszHeader,
    IN      PDNS_RPC_SERVER_INFO_W2K    pServerInfo
    );

VOID
DnsPrint_RpcSingleStat(
    IN      PRINT_ROUTINE   PrintRoutine,
    IN OUT  PPRINT_CONTEXT  pPrintContext,
    IN      LPSTR           pszHeader,
    IN      PDNSSRV_STAT    pStat
    );

VOID
DnsPrint_RpcStatsBuffer(
    IN      PRINT_ROUTINE       PrintRoutine,
    IN OUT  PPRINT_CONTEXT      pPrintContext,
    IN      LPSTR               pszHeader,
    IN      PDNS_RPC_BUFFER     pBuffer
    );

VOID
DnsPrint_RpcStatRaw(
    IN      PRINT_ROUTINE   PrintRoutine,
    IN OUT  PPRINT_CONTEXT  pPrintContext,
    IN      LPSTR           pszHeader,
    IN      PDNSSRV_STAT    pStat,
    IN      DNS_STATUS      Status
    );

//
//  Zone info printing
//

VOID
DnsPrint_RpcZone(
    IN      PRINT_ROUTINE   PrintRoutine,
    IN OUT  PPRINT_CONTEXT  pPrintContext,
    IN      LPSTR           pszHeader,
    IN      PDNS_RPC_ZONE   pZone
    );

VOID
DnsPrint_RpcZone_W2K(
    IN      PRINT_ROUTINE       PrintRoutine,
    IN OUT  PPRINT_CONTEXT      pPrintContext,
    IN      LPSTR               pszHeader,
    IN      PDNS_RPC_ZONE_W2K   pZone
    );

VOID
DnsPrint_RpcZoneList(
    IN      PRINT_ROUTINE       PrintRoutine,
    IN OUT  PPRINT_CONTEXT      pPrintContext,
    IN      LPSTR               pszHeader,
    IN      PDNS_RPC_ZONE_LIST  pZoneList
    );

VOID
DnsPrint_RpcZoneList_W2K(
    IN      PRINT_ROUTINE           PrintRoutine,
    IN OUT  PPRINT_CONTEXT          pPrintContext,
    IN      LPSTR                   pszHeader,
    IN      PDNS_RPC_ZONE_LIST_W2K  pZoneList
    );

VOID
DnsPrint_RpcZoneInfo(
    IN      PRINT_ROUTINE       PrintRoutine,
    IN OUT  PPRINT_CONTEXT      pPrintContext,
    IN      LPSTR               pszHeader,
    IN      PDNS_RPC_ZONE_INFO  pZoneInfo
    );

VOID
DnsPrint_RpcZoneInfo_W2K(
    IN      PRINT_ROUTINE           PrintRoutine,
    IN OUT  PPRINT_CONTEXT          pPrintContext,
    IN      LPSTR                   pszHeader,
    IN      PDNS_RPC_ZONE_INFO_W2K  pZoneInfo
    );

VOID
DnsPrint_RpcZoneInfoList(
    IN      PRINT_ROUTINE       PrintRoutine,
    IN OUT  PPRINT_CONTEXT      pPrintContext,
    IN      LPSTR               pszHeader,
    IN      DWORD               dwZoneCount,
    IN      PDNS_RPC_ZONE_INFO  apZoneInfo[]
    );

//
//  Directory partition printing
//

VOID
DnsPrint_RpcDpEnum(
    IN      PRINT_ROUTINE       PrintRoutine,
    IN OUT  PPRINT_CONTEXT      pPrintContext,
    IN      LPSTR               pszHeader,
    IN      PDNS_RPC_DP_ENUM    pDp
    );

VOID
DnsPrint_RpcDpInfo(
    IN      PRINT_ROUTINE       PrintRoutine,
    IN OUT  PPRINT_CONTEXT      pPrintContext,
    IN      LPSTR               pszHeader,
    IN      PDNS_RPC_DP_INFO    pDp,
    IN      BOOL                fTruncateLongStrings
    );

VOID
DNS_API_FUNCTION
DnsPrint_RpcDpList(
    IN      PRINT_ROUTINE       PrintRoutine,
    IN OUT  PPRINT_CONTEXT      pPrintContext,
    IN      LPSTR               pszHeader,
    IN      PDNS_RPC_DP_LIST    pDpList
    );


//
//  Node and record buffer printing
//

VOID
DnsPrint_RpcName(
    IN      PRINT_ROUTINE   PrintRoutine,
    IN OUT  PPRINT_CONTEXT  pPrintContext,
    IN      LPSTR           pszHeader,
    IN      PDNS_RPC_NAME   pName,
    IN      LPSTR           pszTrailer
    );

VOID
DnsPrint_RpcNode(
    IN      PRINT_ROUTINE   PrintRoutine,
    IN OUT  PPRINT_CONTEXT  pPrintContext,
    IN      LPSTR           pszHeader,
    IN      PDNS_RPC_NODE   pNode
    );

VOID
DnsPrint_RpcRecord(
    IN      PRINT_ROUTINE   PrintRoutine,
    IN OUT  PPRINT_CONTEXT  pPrintContext,
    IN      LPSTR           pszHeader,
    IN      BOOL            fDetail,
    IN      PDNS_RPC_RECORD pRecord
    );

PDNS_RPC_NAME
DnsPrint_RpcRecordsInBuffer(
    IN      PRINT_ROUTINE   PrintRoutine,
    IN OUT  PPRINT_CONTEXT  pPrintContext,
    IN      LPSTR           pszHeader,
    IN      BOOL            fDetail,
    IN      DWORD           dwBufferLength,
    IN      BYTE            abBuffer[]
    );

VOID
DNS_API_FUNCTION
DnsPrint_Node(
    IN      PRINT_ROUTINE   PrintRoutine,
    IN OUT  PPRINT_CONTEXT  pPrintContext,
    IN      LPSTR           pszHeader,
    IN      PDNS_NODE       pNode,
    IN      BOOLEAN         fPrintRecords
    );

VOID
DNS_API_FUNCTION
DnsPrint_NodeList(
    IN      PRINT_ROUTINE   PrintRoutine,
    IN OUT  PPRINT_CONTEXT  pPrintContext,
    IN      LPSTR           pszHeader,
    IN      PDNS_NODE       pNode,
    IN      BOOLEAN         fPrintRecords
    );


//
//  Miscellaneous print utility
//

#define Dns_SystemHrToSystemTime( t, p ) \
        ( Dns_SystemHourToSystemTime( (t),(p) ), TRUE )

VOID
Dns_SystemHourToSystemTime(
    IN      DWORD           dwHourTime,
    IN OUT  PSYSTEMTIME     pSystemTime
    );


//
//  Debug printing utils
//

VOID
DNS_API_FUNCTION
DnssrvInitializeDebug(
    VOID
    );


//  RPC debug print defs

#if DBG

#define DnsDbg_RpcUnion(a,b,c)              DnsPrint_RpcUnion(DnsPR,NULL,a,b,c)
#define DnsDbg_RpcServerInfo(a,b)           DnsPrint_RpcServerInfo(DnsPR,NULL,a,b)
#define DnsDbg_RpcServerInfo_W2K(a,b)       DnsPrint_RpcServerInfo_W2K(DnsPR,NULL,a,b)
#define DnsDbg_RpcSingleStat(a,b)           DnsPrint_RpcSingleStat(DnsPR,NULL,a,b)
#define DnsDbg_RpcStatRaw(a,b)              DnsPrint_RpcStatRaw(DnsPR,NULL,a,b,c)
#define DnsDbg_RpcStatsBuffer(a,b)          DnsPrint_RpcStatsBuffer(DnsPR,NULL,a,b)

#define DnsDbg_RpcZone(a,b)                 DnsPrint_RpcZone(DnsPR,NULL,a,b)
#define DnsDbg_RpcZone_W2K(a,b)             DnsPrint_RpcZone_W2K(DnsPR,NULL,a,b)
#define DnsDbg_RpcZoneList(a,b)             DnsPrint_RpcZoneList(DnsPR,NULL,a,b)
#define DnsDbg_RpcZoneList_W2K(a,b)         DnsPrint_RpcZoneList_W2K(DnsPR,NULL,a,b)
#define DnsDbg_RpcZoneHandleList(a,b,c)     DnsPrint_RpcZoneHandleList(DnsPR,NULL,a,b,c)
#define DnsDbg_RpcZoneInfo(a,b)             DnsPrint_RpcZoneInfo(DnsPR,NULL,a,b)
#define DnsDbg_RpcZoneInfo_W2K(a,b)         DnsPrint_RpcZoneInfo_W2K(DnsPR,NULL,a,b)
#define DnsDbg_RpcZoneInfoList(a,b,c)       DnsPrint_RpcZoneInfoList(DnsPR,NULL,a,b,c)
#define DnsDbg_RpcName(a,b,c)               DnsPrint_RpcName(DnsPR,NULL,a,b,c)
#define DnsDbg_RpcNode(a,b)                 DnsPrint_RpcNode(DnsPR,NULL,a,b)
#define DnsDbg_RpcRecord(a,b)               DnsPrint_RpcRecord(DnsPR,NULL,a,TRUE,b)
#define DnsDbg_RpcRecordsInBuffer(a,b,c)    DnsPrint_RpcRecordsInBuffer(DnsPR,NULL,a,TRUE,b,c)

#define DnsDbg_RpcDpEnum(psz,pDp)           DnsPrint_RpcDpEnum(DnsPR,NULL,psz,pDp)
#define DnsDbg_RpcDpInfo(psz,pDp,tr)        DnsPrint_RpcDpInfo(DnsPR,NULL,psz,pDp,tr)
#define DnsDbg_RpcDpList(psz,pDpList)       DnsPrint_RpcDpList(DnsPR,NULL,psz,pDpList)

#define DnsDbg_Node(a,b,c)                  DnsPrint_Node(DnsPR,NULL,a,b,c)
#define DnsDbg_NodeList(a,b,c)              DnsPrint_NodeList(DnsPR,NULL,a,b,c)

#else   // no debug

#define DnsDbg_RpcUnion(a,b,c)
#define DnsDbg_RpcServerInfo(a,b)
#define DnsDbg_RpcServerInfo_W2K(a,b)
#define DnsDbg_RpcSingleStat(a,b)
#define DnsDbg_RpcStatsBuffer(a,b)

#define DnsDbg_RpcZone(a,b)
#define DnsDbg_RpcZone_W2K(a,b)
#define DnsDbg_RpcZoneList(a,b)
#define DnsDbg_RpcZoneList_W2K(a,b)
#define DnsDbg_RpcZoneHandleList(a,b,c)
#define DnsDbg_RpcZoneInfo(a,b)
#define DnsDbg_RpcZoneInfo_W2K(a,b)
#define DnsDbg_RpcZoneInfoList(a,b,c)
#define DnsDbg_RpcName(a,b,c)
#define DnsDbg_RpcNode(a,b)
#define DnsDbg_RpcRecord(a,b)
#define DnsDbg_RpcRecordsInBuffer(a,b,c)

#define DnsDbg_RpcDpEnum(psz,pDp)
#define DnsDbg_RpcDpInfo(psz,pDp,tr)
#define DnsDbg_RpcDpList(psz,pDpList)

#define DnsDbg_Node(a,b,c)
#define DnsDbg_NodeList(a,b,c)

#endif  // debug

#endif  // no MIDL_PASS


#ifdef __cplusplus
}
#endif  // __cplusplus

#endif // _DNSRPC_INCLUDED_
=== C:/Users/treeman/Desktop/windows nt source code\Source\Win2K3\NT\public\internal\ds\inc\dsgetdcp.h ===
/*++

Copyright (c) 1997  Microsoft Corporation

Module Name:

    dsgetdcp.h

Abstract:

    Routines for processing SRV DNS records.

Author:

    Cliff Van Dyke (cliffv) 07-Mar-1997

Environment:

    User mode only.
    Contains NT-specific code.
    Requires ANSI C extensions: slash-slash comments, long external names.

Revision History:

--*/

#if !defined(DSGETDCAPI)
#if !defined(_DSGETDCAPI_)
#define DSGETDCAPI DECLSPEC_IMPORT
#else
#define DSGETDCAPI
#endif
#endif !defined(DSGETDCAPI)

//
// Externally visible procedures.
//

DSGETDCAPI
DWORD
WINAPI
DsGetDcNameWithAccountA(
    IN LPCSTR ComputerName OPTIONAL,
    IN LPCSTR AccountName OPTIONAL,
    IN ULONG AllowableAccountControlBits,
    IN LPCSTR DomainName OPTIONAL,
    IN GUID *DomainGuid OPTIONAL,
    IN LPCSTR SiteName OPTIONAL,
    IN ULONG Flags,
    OUT PDOMAIN_CONTROLLER_INFOA *DomainControllerInfo
);

DSGETDCAPI
DWORD
WINAPI
DsGetDcNameWithAccountW(
    IN LPCWSTR ComputerName OPTIONAL,
    IN LPCWSTR AccountName OPTIONAL,
    IN ULONG AllowableAccountControlBits,
    IN LPCWSTR DomainName OPTIONAL,
    IN GUID *DomainGuid OPTIONAL,
    IN LPCWSTR SiteName OPTIONAL,
    IN ULONG Flags,
    OUT PDOMAIN_CONTROLLER_INFOW *DomainControllerInfo
);


NET_API_STATUS
DCNameInitialize(
    VOID
    );

VOID
DCNameClose(
    VOID
    );

NET_API_STATUS
NetpDcBuildPing(
    IN BOOL PdcOnly,
    IN ULONG RequestCount,
    IN LPCWSTR UnicodeComputerName,
    IN LPCWSTR UnicodeUserName OPTIONAL,
    IN LPCSTR ResponseMailslotName,
    IN ULONG AllowableAccountControlBits,
    IN PSID RequestedDomainSid OPTIONAL,
    IN ULONG NtVersion,
    OUT PVOID *Message,
    OUT PULONG MessageSize
    );

DWORD
WINAPI
NettestDsGetDcNameW(
    IN LPCWSTR ComputerName OPTIONAL,
    IN LPCWSTR DomainName OPTIONAL,
    IN GUID *DomainGuid OPTIONAL,
    IN LPCWSTR SiteName OPTIONAL,
    IN ULONG Flags,
    OUT PDOMAIN_CONTROLLER_INFOW *DomainControllerInfo
);
=== C:/Users/treeman/Desktop/windows nt source code\Source\Win2K3\NT\public\internal\ds\inc\dosprint.h ===
/*++

Copyright (c) 1991-1992  Microsoft Corporation

Module Name:

    DosPrint.h

Abstract:

    This contains prototypes for the DosPrint routines

Author:

    Dave Snipp (DaveSn) 16-Apr-1991

Environment:


Revision History:

    22-Apr-1991 JohnRo
        Use constants from <lmcons.h>.
    18-Jun-1992 JohnRo
        RAID 10324: net print vs. UNICODE.

--*/

#ifndef _DosPRINT_
#define _DosPRINT_

#include "rxprint.h"

/****************************************************************
 *                                                              *
 *              Function prototypes                             *
 *                                                              *
 ****************************************************************/

SPLERR SPLENTRY DosPrintDestEnumA(
            LPSTR pszServer,
            WORD    uLevel,
            PBYTE   pbBuf,
            WORD    cbBuf,
            PUSHORT pcReturned,
            PUSHORT pcTotal
            );
SPLERR SPLENTRY DosPrintDestEnumW(
            LPWSTR pszServer,
            WORD    uLevel,
            PBYTE   pbBuf,
            WORD    cbBuf,
            PUSHORT pcReturned,
            PUSHORT pcTotal
            );
#ifdef UNICODE
#define DosPrintDestEnum  DosPrintDestEnumW
#else
#define DosPrintDestEnum  DosPrintDestEnumA
#endif // !UNICODE

SPLERR SPLENTRY DosPrintDestControlA(
            LPSTR pszServer,
            LPSTR pszDevName,
            WORD    uControl
            );
SPLERR SPLENTRY DosPrintDestControlW(
            LPWSTR pszServer,
            LPWSTR pszDevName,
            WORD    uControl
            );
#ifdef UNICODE
#define DosPrintDestControl  DosPrintDestControlW
#else
#define DosPrintDestControl  DosPrintDestControlA
#endif // !UNICODE

SPLERR SPLENTRY DosPrintDestGetInfoA(
            LPSTR pszServer,
            LPSTR pszName,
            WORD    uLevel,
            PBYTE   pbBuf,
            WORD    cbBuf,
            PUSHORT pcbNeeded
            );
SPLERR SPLENTRY DosPrintDestGetInfoW(
            LPWSTR pszServer,
            LPWSTR pszName,
            WORD    uLevel,
            PBYTE   pbBuf,
            WORD    cbBuf,
            PUSHORT pcbNeeded
            );
#ifdef UNICODE
#define DosPrintDestGetInfo  DosPrintDestGetInfoW
#else
#define DosPrintDestGetInfo  DosPrintDestGetInfoA
#endif // !UNICODE

SPLERR SPLENTRY DosPrintDestAddA(
            LPSTR pszServer,
            WORD    uLevel,
            PBYTE   pbBuf,
            WORD    cbBuf
            );
SPLERR SPLENTRY DosPrintDestAddW(
            LPWSTR pszServer,
            WORD    uLevel,
            PBYTE   pbBuf,
            WORD    cbBuf
            );
#ifdef UNICODE
#define DosPrintDestAdd  DosPrintDestAddW
#else
#define DosPrintDestAdd  DosPrintDestAddA
#endif // !UNICODE

SPLERR SPLENTRY DosPrintDestSetInfoA(
            LPSTR pszServer,
            LPSTR pszName,
            WORD    uLevel,
            PBYTE   pbBuf,
            WORD    cbBuf,
            WORD    uParmNum
            );
SPLERR SPLENTRY DosPrintDestSetInfoW(
            LPWSTR pszServer,
            LPWSTR pszName,
            WORD    uLevel,
            PBYTE   pbBuf,
            WORD    cbBuf,
            WORD    uParmNum
            );
#ifdef UNICODE
#define DosPrintDestSetInfo  DosPrintDestSetInfoW
#else
#define DosPrintDestSetInfo  DosPrintDestSetInfoA
#endif // !UNICODE

SPLERR SPLENTRY DosPrintDestDelA(
            LPSTR pszServer,
            LPSTR pszPrinterName
            );
SPLERR SPLENTRY DosPrintDestDelW(
            LPWSTR pszServer,
            LPWSTR pszPrinterName
            );
#ifdef UNICODE
#define DosPrintDestDel  DosPrintDestDelW
#else
#define DosPrintDestDel  DosPrintDestDelA
#endif // !UNICODE

SPLERR SPLENTRY DosPrintQEnumA(
            LPSTR pszServer,
            WORD    uLevel,
            PBYTE   pbBuf,
            WORD    cbBuf,
            PUSHORT pcReturned,
            PUSHORT pcTotal
            );
SPLERR SPLENTRY DosPrintQEnumW(
            LPWSTR pszServer,
            WORD    uLevel,
            PBYTE   pbBuf,
            WORD    cbBuf,
            PUSHORT pcReturned,
            PUSHORT pcTotal
            );
#ifdef UNICODE
#define DosPrintQEnum  DosPrintQEnumW
#else
#define DosPrintQEnum  DosPrintQEnumA
#endif // !UNICODE

SPLERR SPLENTRY DosPrintQGetInfoA(
            LPSTR pszServer,
            LPSTR pszQueueName,
            WORD    uLevel,
            PBYTE   pbBuf,
            WORD    cbBuf,
            PUSHORT pcbNeeded
            );
SPLERR SPLENTRY DosPrintQGetInfoW(
            LPWSTR pszServer,
            LPWSTR pszQueueName,
            WORD    uLevel,
            PBYTE   pbBuf,
            WORD    cbBuf,
            PUSHORT pcbNeeded
            );
#ifdef UNICODE
#define DosPrintQGetInfo  DosPrintQGetInfoW
#else
#define DosPrintQGetInfo  DosPrintQGetInfoA
#endif // !UNICODE

SPLERR SPLENTRY DosPrintQSetInfoA(
            LPSTR pszServer,
            LPSTR pszQueueName,
            WORD    uLevel,
            PBYTE   pbBuf,
            WORD    cbBuf,
            WORD    uParmNum
            );
SPLERR SPLENTRY DosPrintQSetInfoW(
            LPWSTR pszServer,
            LPWSTR pszQueueName,
            WORD    uLevel,
            PBYTE   pbBuf,
            WORD    cbBuf,
            WORD    uParmNum
            );
#ifdef UNICODE
#define DosPrintQSetInfo  DosPrintQSetInfoW
#else
#define DosPrintQSetInfo  DosPrintQSetInfoA
#endif // !UNICODE

SPLERR SPLENTRY DosPrintQPauseA(
            LPSTR pszServer,
            LPSTR pszQueueName
            );
SPLERR SPLENTRY DosPrintQPauseW(
            LPWSTR pszServer,
            LPWSTR pszQueueName
            );
#ifdef UNICODE
#define DosPrintQPause  DosPrintQPauseW
#else
#define DosPrintQPause  DosPrintQPauseA
#endif // !UNICODE

SPLERR SPLENTRY DosPrintQContinueA(
            LPSTR pszServer,
            LPSTR pszQueueName
            );
SPLERR SPLENTRY DosPrintQContinueW(
            LPWSTR pszServer,
            LPWSTR pszQueueName
            );
#ifdef UNICODE
#define DosPrintQContinue  DosPrintQContinueW
#else
#define DosPrintQContinue  DosPrintQContinueA
#endif // !UNICODE

SPLERR SPLENTRY DosPrintQPurgeA(
            LPSTR pszServer,
            LPSTR pszQueueName
            );
SPLERR SPLENTRY DosPrintQPurgeW(
            LPWSTR pszServer,
            LPWSTR pszQueueName
            );
#ifdef UNICODE
#define DosPrintQPurge  DosPrintQPurgeW
#else
#define DosPrintQPurge  DosPrintQPurgeA
#endif // !UNICODE

SPLERR SPLENTRY DosPrintQAddA(
            LPSTR pszServer,
            WORD    uLevel,
            PBYTE   pbBuf,
            WORD    cbBuf
            );
SPLERR SPLENTRY DosPrintQAddW(
            LPWSTR pszServer,
            WORD    uLevel,
            PBYTE   pbBuf,
            WORD    cbBuf
            );
#ifdef UNICODE
#define DosPrintQAdd  DosPrintQAddW
#else
#define DosPrintQAdd  DosPrintQAddA
#endif // !UNICODE

SPLERR SPLENTRY DosPrintQDelA(
            LPSTR pszServer,
            LPSTR pszQueueName
            );
SPLERR SPLENTRY DosPrintQDelW(
            LPWSTR pszServer,
            LPWSTR pszQueueName
            );
#ifdef UNICODE
#define DosPrintQDel  DosPrintQDelW
#else
#define DosPrintQDel  DosPrintQDelA
#endif // !UNICODE

SPLERR SPLENTRY DosPrintJobGetInfoA(
            LPSTR pszServer,
            BOOL    bRemote,
            WORD    uJobId,
            WORD    uLevel,
            PBYTE   pbBuf,
            WORD    cbBuf,
            PUSHORT pcbNeeded
            );
SPLERR SPLENTRY DosPrintJobGetInfoW(
            LPWSTR pszServer,
            BOOL    bRemote,
            WORD    uJobId,
            WORD    uLevel,
            PBYTE   pbBuf,
            WORD    cbBuf,
            PUSHORT pcbNeeded
            );
#ifdef UNICODE
#define DosPrintJobGetInfo  DosPrintJobGetInfoW
#else
#define DosPrintJobGetInfo  DosPrintJobGetInfoA
#endif // !UNICODE

SPLERR SPLENTRY DosPrintJobSetInfoA(
            LPSTR pszServer,
            BOOL    bRemote,
            WORD    uJobId,
            WORD    uLevel,
            PBYTE   pbBuf,
            WORD    cbBuf,
            WORD    uParmNum
            );
SPLERR SPLENTRY DosPrintJobSetInfoW(
            LPWSTR pszServer,
            BOOL    bRemote,
            WORD    uJobId,
            WORD    uLevel,
            PBYTE   pbBuf,
            WORD    cbBuf,
            WORD    uParmNum
            );
#ifdef UNICODE
#define DosPrintJobSetInfo  DosPrintJobSetInfoW
#else
#define DosPrintJobSetInfo  DosPrintJobSetInfoA
#endif // !UNICODE

SPLERR SPLENTRY DosPrintJobPauseA(
            LPSTR pszServer,
            BOOL    bRemote,
            WORD    uJobId
            );
SPLERR SPLENTRY DosPrintJobPauseW(
            LPWSTR pszServer,
            BOOL    bRemote,
            WORD    uJobId
            );
#ifdef UNICODE
#define DosPrintJobPause  DosPrintJobPauseW
#else
#define DosPrintJobPause  DosPrintJobPauseA
#endif // !UNICODE

SPLERR SPLENTRY DosPrintJobContinueA(
            LPSTR pszServer,
            BOOL    bRemote,
            WORD    uJobId
            );
SPLERR SPLENTRY DosPrintJobContinueW(
            LPWSTR pszServer,
            BOOL    bRemote,
            WORD    uJobId
            );
#ifdef UNICODE
#define DosPrintJobContinue  DosPrintJobContinueW
#else
#define DosPrintJobContinue  DosPrintJobContinueA
#endif // !UNICODE

SPLERR SPLENTRY DosPrintJobDelA(
            LPSTR pszServer,
            BOOL    bRemote,
            WORD    uJobId
            );
SPLERR SPLENTRY DosPrintJobDelW(
            LPWSTR pszServer,
            BOOL    bRemote,
            WORD    uJobId
            );
#ifdef UNICODE
#define DosPrintJobDel  DosPrintJobDelW
#else
#define DosPrintJobDel  DosPrintJobDelA
#endif // !UNICODE

SPLERR SPLENTRY DosPrintJobEnumA(
            LPSTR pszServer,
            LPSTR pszQueueName,
            WORD    uLevel,
            PBYTE   pbBuf,
            WORD    cbBuf,
            PWORD   pcReturned,
            PWORD   pcTotal
            );
SPLERR SPLENTRY DosPrintJobEnumW(
            LPWSTR pszServer,
            LPWSTR pszQueueName,
            WORD    uLevel,
            PBYTE   pbBuf,
            WORD    cbBuf,
            PWORD   pcReturned,
            PWORD   pcTotal
            );
#ifdef UNICODE
#define DosPrintJobEnum  DosPrintJobEnumW
#else
#define DosPrintJobEnum  DosPrintJobEnumA
#endif // !UNICODE

SPLERR SPLENTRY DosPrintJobGetIdA(
            HANDLE      hFile,
            PPRIDINFO   pInfo,
            WORD        cbInfo
            );
SPLERR SPLENTRY DosPrintJobGetIdW(
            HANDLE      hFile,
            PPRIDINFO   pInfo,
            WORD        cbInfo
            );
#ifdef UNICODE
#define DosPrintJobGetId  DosPrintJobGetIdW
#else
#define DosPrintJobGetId  DosPrintJobGetIdA
#endif // !UNICODE

#endif // ndef _DosPRINT_
=== C:/Users/treeman/Desktop/windows nt source code\Source\Win2K3\NT\public\internal\ds\inc\dsmnname.h ===
/*++

Copyright (c) 1993  Microsoft Corporation

Module Name:

    dsmnname.h

Abstract:

    Header for NetWare service names.

Author:

    Rita Wong      (ritaw)      26-Feb-1993

Revision History:

--*/

#ifndef _DSMN_NAMES_INCLUDED_
#define _DSMN_NAMES_INCLUDED_


//
// Name of service (not display name, but Key name)
//
#define NW_SYNCAGENT_SERVICE      L"MSSYNC"

//
// Directory where we store all the good stuff like the database.
//
#define NW_SYNCAGENT_DIRECTORY    L"SyncAgnt"
#define NW_SYNCAGENT_DIRECTORYA   "SyncAgnt"

//
// Name of secret used to store supervisor credentials between install
// and service starting. Deleted after that.
//
#define NW_SYNCAGENT_CRED_SECRET L"InitialCredential"

//
//
//
#define NW_SYNCAGENT_PASSWD_NOTIFY_DLL L"NwsLib"

#endif // _DSMN_NAMES_INCLUDED_
=== C:/Users/treeman/Desktop/windows nt source code\Source\Win2K3\NT\public\internal\ds\inc\fpnwapi.h ===
/****************************************************************************
*                                                                           *
* fpnwapi.h -- FPNW procedure declarations, constant definitions and macros *
*                                                                           *
* Copyright (c) 1994-1995, Microsoft Corp. All rights reserved.             *
*                                                                           *
****************************************************************************/

#ifndef _FPNWAPI_H_
#define _FPNWAPI_H_

#ifdef __cplusplus
extern "C" {
#endif /* __cplusplus */

//
// Definitions for LSA secrets
//
#define NCP_LSA_SECRET_KEY              L"G$MNSEncryptionKey"
#define NCP_LSA_SECRET_LENGTH           USER_SESSION_KEY_LENGTH // in <crypt.h>

#define NW_SERVER_SERVICE               L"FPNW"

//
//  Volume flags returned by VolumeGetInfo
//

#define FPNWVOL_TYPE_DISKTREE             0
#define FPNWVOL_TYPE_CDROM                104
#define FPNWVOL_TYPE_REMOVABLE            105

//
//  Permissions flags returned in structure FPNWFILEINFO
//

#define FPNWFILE_PERM_NONE                0
#define FPNWFILE_PERM_READ                0x01
#define FPNWFILE_PERM_WRITE               0x02
#define FPNWFILE_PERM_CREATE              0x04
#define FPNWFILE_PERM_EXEC                0x08
#define FPNWFILE_PERM_DELETE              0x10
#define FPNWFILE_PERM_ATRIB               0x20
#define FPNWFILE_PERM_PERM                0x40

typedef BYTE FPNWSERVERADDR[12];        // Network address, first 4 bytes is
                                        // the network number, and bytes
                                        // 5-10 is the physical node
                                        // address. The last two bytes are
                                        // reserved.

//
//  This is the level 1 structure for FpnwServerGetInfo & FpnwServerSetInfo.
//

typedef struct _FPNWServerInfo
{
    LPWSTR    lpServerName;           // Name of the server
    DWORD     dwNetwareMajorVersion;  // Netware compatible major version num
    DWORD     dwNetwareMinorVersion;  // Netware compatible minor version num
    DWORD     dwOSRevision;           // OS revision number
    DWORD     dwMaxConnections;       // Maximum number of connections
                                      // supported
    DWORD     dwVolumes;              // The current number of volumes on the
                                      // server
    DWORD     dwLoggedOnUsers;        // Number of current users logged on
    DWORD     dwConnectedWorkstations;// Number of workstations connected
    DWORD     dwOpenFiles;            // Number of open files
    DWORD     dwFileLocks;            // Number of file locks
    FPNWSERVERADDR NetworkAddress;    // Address consisting of network
                                      // number (first 4 bytes) and the
                                      // physical node address(bytes 5-10)
    BOOL      fEnableLogin;           // TRUE if users are allowed to logged
                                      // on, FALSE otherwise.
    LPWSTR    lpDescription;          // Description of the server
    LPWSTR    lpHomeDirectory;        // Path of the home directory

} FPNWSERVERINFO, *PFPNWSERVERINFO;


//
//  This is the level 1 structure for FpnwVolumeAdd, FpnwVolumeDel, FpnwVolumeEnum,
//  FpnwVolumeGetInfo, & FpnwVolumeSetInfo.
//

typedef struct _FPNWVolumeInfo
{
    LPWSTR    lpVolumeName;           // Name of the volume
    DWORD     dwType;                 // Specifics of the volume. FPNWVOL_TYPE_???
    DWORD     dwMaxUses;              // Maximum number of connections that are
                                      // allowed to the volume
    DWORD     dwCurrentUses;          // Current number of connections to the volume
    LPWSTR    lpPath;                 // Path of the volume

} FPNWVOLUMEINFO, *PFPNWVOLUMEINFO;


//
//  This is the level 2 structure for FpnwVolumeAdd, FpnwVolumeDel, FpnwVolumeEnum,
//  FpnwVolumeGetInfo, & FpnwVolumeSetInfo.
//  Note that this is not supported on the FPNW beta.
//

typedef struct _FPNWVolumeInfo_2
{
    LPWSTR    lpVolumeName;           // Name of the volume
    DWORD     dwType;                 // Specifics of the volume. FPNWVOL_TYPE_???
    DWORD     dwMaxUses;              // Maximum number of connections that are
                                      // allowed to the volume
    DWORD     dwCurrentUses;          // Current number of connections to the volume
    LPWSTR    lpPath;                 // Path of the volume

    DWORD     dwFileSecurityDescriptorLength; // reserved, this is calculated
    PSECURITY_DESCRIPTOR FileSecurityDescriptor;

} FPNWVOLUMEINFO_2, *PFPNWVOLUMEINFO_2;


//
//  This is the level 1 structure for FpnwConnectionEnum.
//

typedef  struct  _FPNWConnectionInfo
{
    DWORD     dwConnectionId;         // Identification number for this connection
    FPNWSERVERADDR WkstaAddress;      // The workstation address which established
                                      // the conn.
    DWORD     dwAddressType;          // Address type: IP, IPX ...
    LPWSTR    lpUserName;             // The name of the user which established
                                      // the conn.
    DWORD     dwOpens;                // Number of resources opened during this conn.
    DWORD     dwLogonTime;            // Time this connection has been active
    BOOL      fLoggedOn;              // TRUE if the user is logged on,FALSE otherwise
    DWORD     dwForcedLogoffTime;     // Time left before forcing logoff
    BOOL      fAdministrator;         // TRUE if the user is an administrator,
                                      // FALSE otherwise

} FPNWCONNECTIONINFO, *PFPNWCONNECTIONINFO;


//
//  This is the level 1 structure for FpnwVolumeConnEnum.
//

typedef struct _FPNWVolumeConnectionInfo
{
    USHORT    nDriveLetter;           // Driver letter mapped to the volume by user
    DWORD     dwConnectionId;         // Identification number for this connection
    DWORD     dwConnType;             // The type of connection: FPNWVOL_TYPE_DISK,
                                      //                         FPNWVOL_TYPE_PRINTER
    DWORD     dwOpens;                // The number of open files on this connection.
    DWORD     dwTime;                 // Time this connection is active (or connected)
    LPWSTR    lpUserName;             // The user who established the connection
    LPWSTR    lpConnectName;          // The workstation address OR volume name based
                                      // on  the qualifier to FpnwConnectionEnum

} FPNWVOLUMECONNINFO, *PFPNWVOLUMECONNINFO;


//
//  This is the level 1 structure for FpnwFileEnum.
//

typedef  struct _FPNWFileInfo
{
    DWORD     dwFileId;               // File identification number
    LPWSTR    lpPathName;             // Full path name of this file
    LPWSTR    lpVolumeName;           // Volume name this file is on
    DWORD     dwPermissions;          // Permission mask: FPNWFILE_PERM_READ,
                                      //                  FPNWFILE_PERM_WRITE,
                                      //                  FPNWFILE_PERM_CREATE...
    DWORD     dwLocks;                // Number of locks on this file
    LPWSTR    lpUserName;             // The name of the user that established the
                                      // connection and opened the file
    FPNWSERVERADDR WkstaAddress;      // The workstation address which opened the file
    DWORD     dwAddressType;          // Address type: IP, IPX

} FPNWFILEINFO, *PFPNWFILEINFO;


//
//  Below are the APIs available to manipulate FPNW servers, volumes, etc.
//

//
//  The FpnwApiBufferFree should be called for any buffer returned by the
//  other APIs.
//

DWORD
FpnwApiBufferFree(
    IN  LPVOID pBuffer
);

//
//  For Level 1, an FPNWSERVERINFO structure is returned in *ppServerInfo.
//

DWORD
FpnwServerGetInfo(
    IN  LPWSTR pServerName OPTIONAL,
    IN  DWORD  dwLevel,
    OUT LPBYTE *ppServerInfo
);


//
//  The following fields are modified by a call to FpnwServerSetInfo :
//
//  LPWSTR    lpDescription;          // Description of the server
//  BOOL      fEnableLogin;           // TRUE if users are allowed to logged
//  LPWSTR    lpHomeDirectory;        // Path of the home directory
//
//  All other fields in FPNWSERVERINFO structure are ignored.  Also note
//  that lpHomeDirectory and lpDescription require a restart for the server
//  to pick up the changes.
//

//
//  For Level 1, an FPNWSERVERINFO structure should be passed as pServerInfo.
//

DWORD
FpnwServerSetInfo(
    IN  LPWSTR pServerName OPTIONAL,
    IN  DWORD  dwLevel,
    IN  LPBYTE pServerInfo
);


//
//  For FpnwVolumeAdd, FpnwVolumeEnum, FpnwVolumeSetInfo, and
//      FpnwVolumeGetInfo, the following holds:
//  Level 1 -> an FPNWVOLUMEINFO structure should be passed as pVolumeInfo.
//  Level 2 -> an FPNWVOLUMEINFO_2 structure should be passed as pVolumeInfo.
//

DWORD
FpnwVolumeAdd(
    IN  LPWSTR pServerName OPTIONAL,
    IN  DWORD  dwLevel,
    IN  LPBYTE pVolumeInfo
);

DWORD
FpnwVolumeDel(
    IN  LPWSTR pServerName OPTIONAL,
    IN  LPWSTR pVolumeName
);

DWORD
FpnwVolumeEnum(
    IN  LPWSTR pServerName OPTIONAL,
    IN  DWORD  dwLevel,
    OUT LPBYTE *ppVolumeInfo,
    OUT PDWORD pEntriesRead,
    IN OUT PDWORD resumeHandle OPTIONAL
);

DWORD
FpnwVolumeGetInfo(
    IN  LPWSTR pServerName OPTIONAL,
    IN  LPWSTR pVolumeName,
    IN  DWORD  dwLevel,
    OUT LPBYTE *ppVolumeInfo
);


//
//  The following fields are modified by a call to FpnwVolumeSetInfo :
//
//  DWORD     dwMaxUses;              // Maximum number of connections that are
//  PSECURITY_DESCRIPTOR FileSecurityDescriptor;
//
//  All other fields in FPNWVOLUMEINFO structure are ignored.  You may send
//  in a pointer to an FPNWVOLUMEINFO_2 structure instead of FPNWVOLUMEINFO.
//

DWORD
FpnwVolumeSetInfo(
    IN  LPWSTR pServerName OPTIONAL,
    IN  LPWSTR pVolumeName,
    IN  DWORD  dwLevel,
    IN  LPBYTE pVolumeInfo
);

//
//  For Level 1, an FPNWCONNECTIONINFO structure is returned in *ppConnectionInfo.
//

DWORD
FpnwConnectionEnum(
    IN LPWSTR pServerName OPTIONAL,
    IN DWORD  dwLevel,
    OUT LPBYTE *ppConnectionInfo,
    OUT PDWORD pEntriesRead,
    IN OUT PDWORD resumeHandle OPTIONAL
);

DWORD FpnwConnectionDel(
    IN LPWSTR pServerName OPTIONAL,
    IN DWORD  dwConnectionId
);


//
//  For Level 1, an PFPNWVOLUMECONNINFO structure is returned in *ppVolumeConnInfo.
//

DWORD
FpnwVolumeConnEnum(
    IN LPWSTR pServerName OPTIONAL,
    IN DWORD dwLevel,
    IN LPWSTR pVolumeName,
    IN DWORD  dwConnectionId,
    OUT LPBYTE *ppVolumeConnInfo,
    OUT PDWORD pEntriesRead,
    IN OUT PDWORD resumeHandle OPTIONAL
);


//
//  For Level 1, an PFPNWFILEINFO structure is returned in *ppFileInfo.
//

DWORD
FpnwFileEnum(
    IN LPWSTR pServerName OPTIONAL,
    IN DWORD  dwLevel,
    IN LPWSTR pPathName OPTIONAL,
    OUT LPBYTE *ppFileInfo,
    OUT PDWORD pEntriesRead,
    IN OUT PDWORD resumeHandle OPTIONAL
);

DWORD
FpnwFileClose(
    IN LPWSTR pServerName OPTIONAL,
    IN DWORD  nFileId
);


DWORD FpnwMessageBufferSend(
    IN LPWSTR pServerName OPTIONAL,
    IN DWORD  dwConnectionId,
    IN DWORD  fConsoleBroadcast,
    IN LPBYTE pbBuffer,
    IN DWORD  cbBuffer
);

#ifdef __cplusplus
}
#endif  /* __cplusplus */

#endif
=== C:/Users/treeman/Desktop/windows nt source code\Source\Win2K3\NT\public\internal\ds\inc\dsrolep.h ===
/*++

Copyright (c) 1998  Microsoft Corporation

Module Name:

    dsrolep.h

Abstract:

    Private definitions for DsRole routines used for upgrading downlevel domains

Author:

    Mac McLain  (MacM)          24-January-1998

Environment:

Revision History:

--*/
#ifndef __DSROLEP_H__
#define __DSROLEP_H__

#ifdef __cplusplus
extern "C" {
#endif

//
// Data structures for configuring the role of a Dc in a domain
//

typedef PVOID DSROLE_SERVEROP_HANDLE;
typedef PVOID DSROLE_IFM_OPERATION_HANDLE;

//
// Type of display strings to query for
//
typedef enum {

    DsRoleOperationPromote = 1,
    DsRoleOperationReplicaPromote,
    DsRoleOperationDemote,
    DsRoleOperationUpgrade
    
} DSROLE_SERVEROP_OPERATION;

//
// Status of an existing operation
//
typedef struct _DSROLE_SERVEROP_STATUS {

    LPWSTR CurrentOperationDisplayString;
    ULONG OperationStatus;
    ULONG CurrentOperationDisplayStringIndex;

} DSROLE_SERVEROP_STATUS, *PDSROLE_SERVEROP_STATUS;

//
// where:
// CurrentOperationDisplayString is a displayable status of the current operation.  For example:
//       Locating a domain controller for the domain BRIDGE.NTDEV.MICROSOFT.COM
//       Replicating Ds Data from parent domain controller FRANK.BRIDGE.NTDEV.MICROSOFT.COM
//       Configuring KDC service to autostart
//

//
// Status returned from a GetOperationResults call
//
typedef struct _DSROLE_SERVEROP_RESULTS {

    ULONG OperationStatus;
    LPWSTR OperationStatusDisplayString;
    LPWSTR ServerInstalledSite;
    ULONG OperationResultsFlags;
    
} DSROLE_SERVEROP_RESULTS, *PDSROLE_SERVEROP_RESULTS;

//
// where:
// OperationStatus is the status code returned from the operation.
// OperationStatusDisplayString is a displayable status of the current operation.  For example:
//       Successfully installed a domain controller for the domain BRIDGE.NTDEV.MICROSOFT.COM
//       Failed to create the trust between BRIDGE.NTDEV.MICROSOFT.COM and
//          FRANK.BRIDGE.NTDEV.MICROSOFT.COM because the trust object already exists on the parent
// ServerInstalledSite is where the site the server was installed in is returned
// OperationResultsFlags is where any flags are returned determine any specifics about the results
//
//

typedef struct _IFM_SYSTEM_INFO {

    //               
    // The locally accessible directory of the "alternate location" 
    // restore.
    //
    // Also used by ntdsetup.dll:NtdspCopyDatabase()
    WCHAR * wszRestorePath;
    
    //
    // Some state from the registry of the above restore.
    //
    
    // For dcpromo.exe and ntdsa.dll:HandleKeys()
    ULONG   dwState;
    ULONG   dwSchemaVersion;
    LPWSTR  wszDnsDomainName;
    
    // For ntdsetup.dll:NtdspCopyDatabase()                        
    LPWSTR  wszOriginalDitPath;

    // For ntdsa.dll:HandleKeys()    
    DWORD   dwSysKeyStatus; // whether we got the syskey successfully.
    PVOID   pvSysKey;
    DWORD   cbSysKey; // size of syskey.
    
} IFM_SYSTEM_INFO, *PIFM_SYSTEM_INFO;

//
// Operation states
//

#define DSROLE_CRITICAL_OPERATIONS_COMPLETED    0x00000001

//
// Operation results flags
//
#define DSROLE_NON_FATAL_ERROR_OCCURRED          0x00000001
#define DSROLE_NON_CRITICAL_REPL_NOT_FINISHED    0x00000002
#define DSROLE_IFM_RESTORED_DATABASE_FILES_MOVED 0x00000004
#define DSROLE_IFM_GC_REQUEST_CANNOT_BE_SERVICED 0x00000008

//
// Determines the role of DC following a demotion
//
typedef enum _DSROLE_SERVEROP_DEMOTE_ROLE {

    DsRoleServerStandalone = 0,
    DsRoleServerMember

} DSROLE_SERVEROP_DEMOTE_ROLE, *PDSROLE_SERVEROP_DEMOTE_ROLE;

//
// Valid options for various DsRole apis
//
#define DSROLE_DC_PARENT_TRUST_EXISTS       0x00000001
#define DSROLE_DC_ROOT_TRUST_EXISTS         0x00000001
#define DSROLE_DC_DELETE_PARENT_TRUST       0x00000002
#define DSROLE_DC_DELETE_ROOT_TRUST         0x00000002
#define DSROLE_DC_ALLOW_DC_REINSTALL        0x00000004
#define DSROLE_DC_ALLOW_DOMAIN_REINSTALL    0x00000008
#define DSROLE_DC_TRUST_AS_ROOT             0x00000010
#define DSROLE_DC_DOWNLEVEL_UPGRADE         0x00000020
#define DSROLE_DC_FORCE_TIME_SYNC           0x00000040
#define DSROLE_DC_CREATE_TRUST_AS_REQUIRED  0x00000080
#define DSROLE_DC_DELETE_SYSVOL_PATH        0x00000100
#define DSROLE_DC_DONT_DELETE_DOMAIN        0x00000200
#define DSROLE_DC_CRITICAL_REPLICATION_ONLY 0x00000400
#define DSROLE_DC_ALLOW_ANONYMOUS_ACCESS    0x00000800
#define DSROLE_DC_NO_NET                    0x00001000
#define DSROLE_DC_REQUEST_GC                0x00002000
#define DSROLE_DC_DEFAULT_REPAIR_PWD        0x00004000
#define DSROLE_DC_SET_FOREST_CURRENT        0x00008000
#define DSROLE_DC_FORCE_DEMOTE              0x00010000


//
// Options to be used for fixing up a domain controller
//
#define DSROLE_DC_FIXUP_ACCOUNT             0x00000001
#define DSROLE_DC_FIXUP_ACCOUNT_PASSWORD    0x00000002
#define DSROLE_DC_FIXUP_ACCOUNT_TYPE        0x00000004
#define DSROLE_DC_FIXUP_TIME_SERVICE        0x00000008
#define DSROLE_DC_FIXUP_DC_SERVICES         0x00000010
#define DSROLE_DC_FIXUP_FORCE_SYNC          0x00000020
#define DSROLE_DC_FIXUP_SYNC_LSA_POLICY     0x00000040
#define DSROLE_DC_FIXUP_TIME_SYNC           0x00000080
#define DSROLE_DC_FIXUP_CLEAN_TRUST         0x00000100

//
// Returns from DsRoleGetDatabaseFacts
//
#define DSROLE_DC_IS_GC                     0x00000001
#define DSROLE_KEY_STORED                   0x00000002
#define DSROLE_KEY_DISK                     0x00000004
#define DSROLE_KEY_PROMPT                   0x00000008

//
// Flags returned by DsRoleDnsNameToFlatName
//
#define DSROLE_FLATNAME_DEFAULT     0x00000001
#define DSROLE_FLATNAME_UPGRADE     0x00000002

DWORD
WINAPI
DsRoleDnsNameToFlatName(
    IN  LPCWSTR lpServer OPTIONAL,
    IN  LPCWSTR lpDnsName,
    OUT LPWSTR *lpFlatName,
    OUT PULONG  lpStatusFlag
    );


DWORD
WINAPI
DsRoleDcAsDc(
    IN  LPCWSTR lpServer OPTIONAL,
    IN  LPCWSTR lpDnsDomainName,
    IN  LPCWSTR lpFlatDomainName,
    IN  LPCWSTR lpDomainAdminPassword OPTIONAL,
    IN  LPCWSTR lpSiteName, OPTIONAL
    IN  LPCWSTR lpDsDatabasePath,
    IN  LPCWSTR lpDsLogPath,
    IN  LPCWSTR lpSystemVolumeRootPath,
    IN  LPCWSTR lpParentDnsDomainName OPTIONAL,
    IN  LPCWSTR lpParentServer OPTIONAL,
    IN  LPCWSTR lpAccount OPTIONAL,
    IN  LPCWSTR lpPassword OPTIONAL,
    IN  LPCWSTR lpDsRepairPassword OPTIONAL,
    IN  ULONG Options,
    OUT DSROLE_SERVEROP_HANDLE *DsOperationHandle
    );

DWORD
WINAPI
DsRoleDcAsReplica(
    IN  LPCWSTR lpServer OPTIONAL,
    IN  LPCWSTR lpDnsDomainName,
    IN  LPCWSTR lpReplicaServer,
    IN  LPCWSTR lpSiteName, OPTIONAL
    IN  LPCWSTR lpDsDatabasePath,
    IN  LPCWSTR lpDsLogPath,
    IN  LPCWSTR lpRestorePath OPTIONAL,
    IN  LPCWSTR lpSystemVolumeRootPath,
    IN OUT LPWSTR lpBootkey OPTIONAL,
    IN  LPCWSTR lpAccount OPTIONAL,
    IN  LPCWSTR lpPassword OPTIONAL,
    IN  LPCWSTR lpDsRepairPassword OPTIONAL,
    IN  ULONG Options,
    OUT DSROLE_SERVEROP_HANDLE *DsOperationHandle
    );

DWORD
WINAPI
DsRoleDemoteDc(
    IN  LPCWSTR lpServer OPTIONAL,
    IN  LPCWSTR lpDnsDomainName OPTIONAL,
    IN  DSROLE_SERVEROP_DEMOTE_ROLE ServerRole,
    IN  LPCWSTR lpAccount OPTIONAL,
    IN  LPCWSTR lpPassword OPTIONAL,
    IN  ULONG Options,
    IN  BOOL fLastDcInDomain,
    IN  ULONG cRemoveNCs,
    IN  LPCWSTR * pszRemoveNCs OPTIONAL,
    IN  LPCWSTR lpDomainAdminPassword OPTIONAL,
    OUT DSROLE_SERVEROP_HANDLE *DsOperationHandle
    );

DWORD
WINAPI
DsRoleGetDcOperationProgress(
    IN  LPCWSTR lpServer OPTIONAL,
    IN  DSROLE_SERVEROP_HANDLE DsOperationHandle,
    OUT PDSROLE_SERVEROP_STATUS *ServerOperationStatus
    );

DWORD
WINAPI
DsRoleGetDcOperationResults(
    IN  LPCWSTR lpServer OPTIONAL,
    IN  DSROLE_SERVEROP_HANDLE DsOperationHandle,
    OUT PDSROLE_SERVEROP_RESULTS *ServerOperationResults
    );

DWORD
WINAPI
DsRoleCancel(
    IN  LPCWSTR lpServer OPTIONAL,
    IN  DSROLE_SERVEROP_HANDLE DsOperationHandle
    );

#define DSROLEP_ABORT_FOR_REPLICA_INSTALL   0x0000001

DWORD
WINAPI
DsRoleServerSaveStateForUpgrade(
    IN  LPCWSTR AnswerFile OPTIONAL
    );

DWORD
WINAPI
DsRoleUpgradeDownlevelServer(
    IN  LPCWSTR lpDnsDomainName,
    IN  LPCWSTR lpSiteName,
    IN  LPCWSTR lpDsDatabasePath,
    IN  LPCWSTR lpDsLogPath,
    IN  LPCWSTR lpSystemVolumeRootPath,
    IN  LPCWSTR lpParentDnsDomainName OPTIONAL,
    IN  LPCWSTR lpParentServer OPTIONAL,
    IN  LPCWSTR lpAccount OPTIONAL,
    IN  LPCWSTR lpPassword OPTIONAL,
    IN  LPCWSTR lpDsRepairPassword OPTIONAL,
    IN  ULONG Options,
    OUT DSROLE_SERVEROP_HANDLE *DsOperationHandle
    );

DWORD
WINAPI
DsRoleAbortDownlevelServerUpgrade(
    IN  LPCWSTR lpAdminPassword,
    IN  LPCWSTR lpAccount OPTIONAL,
    IN  LPCWSTR lpPassword OPTIONAL,
    IN  ULONG Options
    );
    
DWORD
WINAPI
DsRoleGetDatabaseFacts(
    IN  LPCWSTR lpServer OPTIONAL,
    IN  LPCWSTR lpRestorePath,
    OUT LPWSTR *lpDNSDomainName,
    OUT PULONG State,
    OUT DSROLE_IFM_OPERATION_HANDLE * pIfmHandle
    );

DWORD
WINAPI
DsRoleIfmHandleFree(
    IN  LPCWSTR lpServer OPTIONAL,
    IN  DSROLE_IFM_OPERATION_HANDLE * pIfmHandle
    );

#ifdef __cplusplus
}
#endif

#endif // __DSROLEP_H__
=== C:/Users/treeman/Desktop/windows nt source code\Source\Win2K3\NT\public\internal\ds\inc\dspropp.h ===
//+----------------------------------------------------------------------------
//
//  Windows NT Active Directory Service Property Pages
//
//  Microsoft Windows
//  Copyright (C) Microsoft Corporation, 1992-1999.
//
//  File:       dspropp.h
//
//  Contents:   Non-SDK functions and definitions used in the creation of AD
//              property sheets.
//
//  History:    24-Aug-99 EricB created.
//
//-----------------------------------------------------------------------------

#ifndef _DSPROPP_H_
#define _DSPROPP_H_

#if _MSC_VER > 1000
#pragma once
#endif
#ifdef __cplusplus
extern "C" {
#endif

typedef struct _PROPSHEETCFG {
    LONG_PTR lNotifyHandle;
    HWND hwndParentSheet;   // invoking parent if launched from another sheet.
    HWND hwndHidden;  // snapin hidden window handle
    WPARAM wParamSheetClose; // wParam to be used with WM_DSA_SHEET_CLOSE_NOTIFY message
} PROPSHEETCFG, * PPROPSHEETCFG;

// private message to send to property page to get the HWND of the notify object
#define WM_ADSPROP_PAGE_GET_NOTIFY    (WM_USER + 1109) 

//+----------------------------------------------------------------------------
//
//  Function:   PostADsPropSheet
//
//  Synopsis:   Creates a property sheet for the named object using MMC's
//              IPropertySheetProvider so that extension snapins can add pages.
//              This function is provided so that property pages can invoke
//              other propety sheets.
//
//  Arguments:  [pwzObjDN]   - the full LDAP DN of the DS object.
//              [pParentObj] - the invoking page's MMC data object pointer, can be NULL.
//              [hwndParent] - the invoking page's window handle.
//              [fReadOnly]  - defaults to FALSE.
//
//-----------------------------------------------------------------------------
HRESULT
PostADsPropSheet(PWSTR pwzObjDN, IDataObject * pParentObj, HWND hwndParent,
                 BOOL fReadOnly = FALSE);

#ifdef __cplusplus
}
#endif // __cplusplus

#endif // _DSPROPP_H_
=== C:/Users/treeman/Desktop/windows nt source code\Source\Win2K3\NT\public\internal\ds\inc\fipsapi.h ===
#ifndef __FIPSAPI_H__
#define __FIPSAPI_H__

#ifdef __cplusplus
extern "C" {
#endif

#include <windef.h>
#include <des.h>
#include <tripldes.h>
#include <sha.h>
#include <modes.h>
#include <md5.h>

#if DEBUG 
#define FipsDebug(LEVEL, STRING) \
        { \
          DbgPrint STRING; \
        }
#else
#define FipsDebug(LEVEL, STRING)
#endif

#define     FIPS_DEVICE_NAME            L"\\Device\\Fips"

#define FIPS_CTL_CODE(code)         CTL_CODE(FILE_DEVICE_FIPS, \
                                            (code), \
                                            METHOD_BUFFERED, \
                                            FILE_ANY_ACCESS)

#define IOCTL_FIPS_GET_FUNCTION_TABLE   FIPS_CTL_CODE( 1)

#define     FIPS_CBC_DES    0x1
#define     FIPS_CBC_3DES   0x2

//
// Defines for IPSEC HMAC use
//
#define     MAX_LEN_PAD     65
#define     MAX_KEYLEN_SHA  64
#define     MAX_KEYLEN_MD5  64   

//
//     Fill in the DESTable struct with the decrypt and encrypt
//     key expansions.
//
//     Assumes that the second parameter points to DES_BLOCKLEN
//     bytes of key.
//
//

VOID FipsDesKey(DESTable *DesTable, UCHAR *pbKey);

//
//     Encrypt or decrypt with the key in DESTable
//
//

VOID FipsDes(UCHAR *pbOut, UCHAR *pbIn, void *pKey, int iOp);

//
//   Fill in the DES3Table structs with the decrypt and encrypt
//   key expansions.
//
//   Assumes that the second parameter points to 2 * DES_BLOCKLEN
//   bytes of key.
//
//

VOID Fips3Des3Key(PDES3TABLE pDES3Table, UCHAR *pbKey);

//
//   Encrypt or decrypt with the key in pKey
//

VOID Fips3Des(UCHAR *pbIn, UCHAR *pbOut, void *pKey, int op);

//
//   Initialize the SHA context.
//

VOID FipsSHAInit(A_SHA_CTX *pShaCtx);

//
//   Hash data into the hash context.
//

VOID FipsSHAUpdate(A_SHA_CTX *pShaCtx, UCHAR *pb, unsigned int cb);

//
//   Finish the SHA hash and copy the final hash value into the pbHash out param.
//

VOID FipsSHAFinal(A_SHA_CTX *pShaCtx, UCHAR *pbHash);

//
// FipsCBC (cipher block chaining) performs a XOR of the feedback register
// with the plain text before calling the block cipher
//
// NOTE - Currently this function assumes that the block length is
// DES_BLOCKLEN (8 bytes).
//
// Return: Failure if FALSE is returned, TRUE if it succeeded.
//

BOOL FipsCBC(
    ULONG  EncryptionAlg,
    BYTE   *pbOutput,
    BYTE   *pbInput,
    void   *pKeyTable,
    int    Operation,
    BYTE   *pbFeedback
    );

//
// FipsBlockCBC (cipher block chaining) performs a XOR of the feedback register
// with the plain text before calling the block cipher
//
// NOTE - The Length must be multiple of DES_BLOCKLEN (8)
// All the input buffer must be aligned on LONGLONG for performane reason.
//
// Return: Failure if FALSE is returned, TRUE if it succeeded.
//

BOOL FipsBlockCBC(
    ULONG  EncryptionAlg,
    BYTE   *pbOutput,
    BYTE   *pbInput,
    ULONG  Length,
    void   *pKeyTable,
    int    Operation,
    BYTE   *pbFeedback
    );

//
// Function : FIPSGenRandom
//
// Description : FIPS 186 RNG, the seed is generated by calling NewGenRandom.
//

BOOL FIPSGenRandom(
    IN OUT UCHAR *pb,
    IN ULONG cb
    );

//
// Function: FipsHmacSHAInit
//
// Description: Initialize a SHA-HMAC context 
//

VOID FipsHmacSHAInit(
    OUT A_SHA_CTX *pShaCtx,
    IN UCHAR *pKey,
    IN unsigned int cbKey
    );

//
// Function: FipsHmacSHAUpdate
//
// Description: Add more data to a SHA-HMAC context
//

VOID FipsHmacSHAUpdate(
    IN OUT A_SHA_CTX *pShaCtx,
    IN UCHAR *pb,
    IN unsigned int cb
    );

//
// Function: FipsHmacSHAFinal
//
// Description: Return result of SHA-HMAC 
//

VOID FipsHmacSHAFinal(
    IN A_SHA_CTX *pShaCtx,
    IN UCHAR *pKey,
    IN unsigned int cbKey,
    OUT UCHAR *pHash
    );

//
// Function: HmacMD5Init
//
// Description: Initialize a MD5-HMAC context 
//

VOID HmacMD5Init(
    OUT MD5_CTX *pMD5Ctx,
    IN UCHAR *pKey,
    IN unsigned int cbKey
    );

//
// Function: HmacMD5Update
//
// Description: Add more data to a MD5-HMAC context
//

VOID HmacMD5Update(
    IN OUT MD5_CTX *pMD5Ctx,
    IN UCHAR *pb,
    IN unsigned int cb
    );

//
// Function: HmacMD5Final
//
// Description: Return result of MD5-HMAC 
//

VOID HmacMD5Final(
    IN MD5_CTX *pMD5Ctx,
    IN UCHAR *pKey,
    IN unsigned int cbKey,
    OUT UCHAR *pHash
    );

// 
// Current FIPS function table
// Includes HMAC entry points
//
typedef struct _FIPS_FUNCTION_TABLE {

    VOID (*FipsDesKey)(DESTable *DesTable, UCHAR *pbKey);
    VOID (*FipsDes)(UCHAR *pbOut, UCHAR *pbIn, void *pKey, int iOp);
    VOID (*Fips3Des3Key)(PDES3TABLE pDES3Table, UCHAR *pbKey);
    VOID (*Fips3Des)(UCHAR *pbIn, UCHAR *pbOut, void *pKey, int op);
    VOID (*FipsSHAInit)(A_SHA_CTX *pShaCtx);
    VOID (*FipsSHAUpdate)(A_SHA_CTX *pShaCtx, UCHAR *pb, unsigned int cb);
    VOID (*FipsSHAFinal)(A_SHA_CTX *pShaCtx, UCHAR *pbHash);
    BOOL (*FipsCBC)(
        ULONG  EncryptionAlg,
        BYTE   *pbOutput,
        BYTE   *pbInput,
        void   *pKeyTable,
        int    Operation,
        BYTE   *pbFeedback
        );
    BOOL (*FIPSGenRandom)(
        IN OUT UCHAR *pb,
        IN ULONG cb
        );
    BOOL (*FipsBlockCBC)(
        ULONG  EncryptionAlg,
        BYTE   *pbOutput,
        BYTE   *pbInput,
        ULONG  Length,
        void   *pKeyTable,
        int    Operation,
        BYTE   *pbFeedback
        );
    VOID (*FipsHmacSHAInit)(
        OUT A_SHA_CTX *pShaCtx,
        IN UCHAR *pKey,
        IN unsigned int cbKey
        );   
    VOID (*FipsHmacSHAUpdate)(
        IN OUT A_SHA_CTX *pShaCtx,
        IN UCHAR *pb,
        IN unsigned int cb
        );
    VOID (*FipsHmacSHAFinal)(
        IN A_SHA_CTX *pShaCtx,
        IN UCHAR *pKey,
        IN unsigned int cbKey,
        OUT UCHAR *pHash
        );
    VOID (*HmacMD5Init)(
        OUT MD5_CTX *pMD5Ctx,
        IN UCHAR *pKey,
        IN unsigned int cbKey
        );
    VOID (*HmacMD5Update)(
        IN OUT MD5_CTX *pMD5Ctx,
        IN UCHAR *pb,
        IN unsigned int cb
        );
    VOID (*HmacMD5Final)(
        IN MD5_CTX *pMD5Ctx,
        IN UCHAR *pKey,
        IN unsigned int cbKey,
        OUT UCHAR *pHash
        );

} FIPS_FUNCTION_TABLE, *PFIPS_FUNCTION_TABLE;

//
// Old FIPS function table - please don't use
//
typedef struct _FIPS_FUNCTION_TABLE_1 {

    VOID (*FipsDesKey)(DESTable *DesTable, UCHAR *pbKey);
    VOID (*FipsDes)(UCHAR *pbOut, UCHAR *pbIn, void *pKey, int iOp);
    VOID (*Fips3Des3Key)(PDES3TABLE pDES3Table, UCHAR *pbKey);
    VOID (*Fips3Des)(UCHAR *pbIn, UCHAR *pbOut, void *pKey, int op);
    VOID (*FipsSHAInit)(A_SHA_CTX *pShaCtx);
    VOID (*FipsSHAUpdate)(A_SHA_CTX *pShaCtx, UCHAR *pb, unsigned int cb);
    VOID (*FipsSHAFinal)(A_SHA_CTX *pShaCtx, UCHAR *pbHash);
    BOOL (*FipsCBC)(
        ULONG  EncryptionAlg,
        BYTE   *pbOutput,
        BYTE   *pbInput,
        void   *pKeyTable,
        int    Operation,
        BYTE   *pbFeedback
        );
    BOOL (*FIPSGenRandom)(
        IN OUT UCHAR *pb,
        IN ULONG cb
        );
    BOOL (*FipsBlockCBC)(
        ULONG  EncryptionAlg,
        BYTE   *pbOutput,
        BYTE   *pbInput,
        ULONG  Length,
        void   *pKeyTable,
        int    Operation,
        BYTE   *pbFeedback
        );

} FIPS_FUNCTION_TABLE_1, *PFIPS_FUNCTION_TABLE_1;


#ifdef __cplusplus
}
#endif

#endif // __FIPSAPI_H__
=== C:/Users/treeman/Desktop/windows nt source code\Source\Win2K3\NT\public\internal\ds\inc\fpnwcomm.h ===
/*++

Copyright (c) 1993-1995, Microsoft Corp. All rights reserved.

Module Name:

    nw\inc\ncmcomm.h

Abstract:

    This module contains common constants and types for the NCP server.

Author:

    Shawn Walker (vswalk) 06-17-1993
    Andy Herron  (andyhe)

Revision History:

--*/

#ifndef _NCPCOMM_
#define _NCPCOMM_

//
// signature for pserver
//
#define NCP_PSERVER_SIGNATURE   L"PS_"

//
// well known object IDs
//
#define NCP_WELL_KNOWN_SUPERVISOR_ID            (ULONG) 0x00000001
#define NCP_WELL_KNOWN_SUPERVISOR_ID_SWAPPED    (ULONG) 0x01000000
#define NCP_WELL_KNOWN_SUPERVISOR_ID_CHICAGO    (ULONG) 0x00010000
#define NCP_WELL_KNOWN_PSERVER_ID               (ULONG) 0x00000002

//
// misc macros that are useful
//
#define SWAPWORD(w)         ((WORD)((w & 0xFF) << 8)|(WORD)(w >> 8))
#define SWAPLONG(l)         MAKELONG(SWAPWORD(HIWORD(l)),SWAPWORD(LOWORD(l)))

#define SWAP_OBJECT_ID(id) (id == NCP_WELL_KNOWN_SUPERVISOR_ID) ?           \
                                NCP_WELL_KNOWN_SUPERVISOR_ID_SWAPPED :      \
                                MAKELONG(LOWORD(id),SWAPWORD(HIWORD(id)))

#define UNSWAP_OBJECT_ID(id) (id == NCP_WELL_KNOWN_SUPERVISOR_ID_SWAPPED || id == NCP_WELL_KNOWN_SUPERVISOR_ID_CHICAGO) ?\
                                NCP_WELL_KNOWN_SUPERVISOR_ID :              \
                                MAKELONG(LOWORD(id),SWAPWORD(HIWORD(id)))


//
// misc masks/bits for Object ID munging
//

#define BINDLIB_ID_MASK                         0xF0000000

#define BINDLIB_NCP_SAM                         0x00000000

//
//  This bit is set when the server is running on a NTAS machine or
//  the object is from a trusted domain.
//
//  !! Note that there are places where we check this bit to see if either
//  !! BINDLIB_REMOTE_DOMAIN_BIAS or BINDLIB_LOCAL_USER_BIAS is set.
//

#define BINDLIB_REMOTE_DOMAIN_BIAS              0x10000000

//
//  If the client is from the builtin domain, this bit will be set.  This
//  is opposed to the local domain, which is different.
//

#define BINDLIB_BUILTIN_BIAS                    0x20000000

//
//  If the client is from a trusted domain and the rid is from the
//  local domain and the client's rid is the same as the rid from the
//  sid, we will mark that the rid is the same as the local user's sid.
//
//  !! Note... this is a value, not a flag.  This will require special casing
//  !! everywhere but we can't spare any more bits.
//

#define BINDLIB_LOCAL_USER_BIAS                 0x70000000

//
//  User defined objects that is stored in the registry.
//

#define BINDLIB_NCP_USER_DEFINED                0x40000000

//
//  Print Queues and Print Servers that is stored in the registry.
//  The bindery keeps a list of print queues in a link list so that
//  the bindery does not have to go look in the registry all the time.
//

#define BINDLIB_NCP_REGISTRY                    0x80000000

//
//  The SAP Agent uses these bits.  The SAP Agent cannot go any higher
//  than the value below.
//

#define BINDLIB_NCP_SAP                         0xC0000000
#define BINDLIB_NCP_MAX_SAP                     0xCFFFFFFF

//
//  We have some reserved fields for unknown users that will go into the
//  following range....
//

#define NCP_UNKNOWN_USER                            0xD0000000
#define NCP_SAME_RID_AS_CLIENT_BUT_LOCAL            0xDFFFFFFF
#define NCP_USER_IS_CONNECTED_BUT_REMOTE(connid)    (0xD0000000 | (connid))
#define NCP_WELL_KNOWN_RID(rid)                     (0xD1000000 | (rid))

//
//  Chicago will use a range of object ids that start at the below value
//  and go to 0xFFFFFFFF.  We should never see these on our server when
//  a chicago server is passing through to us.
//

#define BINDLIB_CHICAGO                         0xE0000000

//
//  This is used to remove the domain bias from a object id.
//

#define BINDLIB_MASK_OUT_DOMAIN_BIAS            0x70000000


#define NCP_INITIAL_SEARCH                      (ULONG) 0xFFFFFFFF
#define NCP_ANY_TARGET_SERVER                   (ULONG) 0xFFFFFFFF

#define NCP_OBJECT_HAS_PROPERTIES               (UCHAR) 0xFF
#define NCP_OBJECT_HAS_NO_PROPERTIES            (UCHAR) 0

#define NCP_PROPERTY_HAS_VALUE                  (UCHAR) 0xFF
#define NCP_PROPERTY_HAS_NO_VALUE               (UCHAR) 0

#define NCP_MORE_PROPERTY                       (UCHAR) 0xFF
#define NCP_NO_MORE_PROPERTY                    (UCHAR) 0

#define NCP_MORE_SEGMENTS                       (UCHAR) 0xFF
#define NCP_NO_MORE_SEGMENTS                    (UCHAR) 0

#define NCP_DO_REMOVE_REMAINING_SEGMENTS        (UCHAR) 0
#define NCP_DO_NOT_REMOVE_REMAINING_SEGMENTS    (UCHAR) 0xFF


/*++
*******************************************************************
        Maximum length for the Bindery
*******************************************************************
--*/

#define NETWARE_OBJECTNAMELENGTH                47
#define NETWARE_PROPERTYNAMELENGTH              16
#define NETWARE_PROPERTYVALUELENGTH             128
#define NETWARE_TIME_RESTRICTION_LENGTH         42

#define NETWARE_PASSWORDLENGTH                  128
#define NCP_MAX_ENCRYPTED_PASSWORD_LENGTH       16

#define NETWARE_MAX_OBJECT_IDS_IN_SET           32

#define NETWARE_SERVERNAMELENGTH                48
#define NETWARE_VOLUMENAMELENGTH                16
#define NETWARE_MAX_PATH_LENGTH                 255


/*++
*******************************************************************
        Well known NetWare object types
*******************************************************************
--*/

#define NCP_OT_WILD                       0xFFFF
#define NCP_OT_UNKNOWN                    0x0000
#define NCP_OT_USER                       0x0001
#define NCP_OT_USER_GROUP                 0x0002
#define NCP_OT_PRINT_QUEUE                0x0003
#define NCP_OT_FILE_SERVER                0x0004
#define NCP_OT_JOB_SERVER                 0x0005
#define NCP_OT_GATEWAY                    0x0006
#define NCP_OT_PRINT_SERVER               0x0007
#define NCP_OT_ARCHIVE_QUEUE              0x0008
#define NCP_OT_ARCHIVE_SEVER              0x0009
#define NCP_OT_JOB_QUEUE                  0x000A
#define NCP_OT_ADMINISTRATION             0x000B
#define NCP_OT_SNA_GATEWAY                0x0021
#define NCP_OT_REMOTE_BRIDGE              0x0024
#define NCP_OT_REMOTE_BRIDGE_SERVER       0x0026
#define NCP_OT_ADVERTISING_PRINT_SERVER   0x0047


/*++
*******************************************************************
        Bindery flags
*******************************************************************
--*/

/** NetWare Bindery Flags **/

#define NCP_STATIC          0x00    /* Property or Object exists until it
                                       is deleted with Delete Property or
                                       Object */
#define NCP_DYNAMIC         0x01    /* Property or Object is deleted from
                                       bindery when file server is started */
#define NCP_ITEM            0x00    /* Values are defined and interpreted by
                                       applications or by APIs */
#define NCP_SET             0x02    /* Series of Object ID numbers, each 4
                                       bytes long */

/** NetWare Bindery Security Flags **/

#define NCP_ANY_READ        0x00    /* Readable by anyone */
#define NCP_LOGGED_READ     0x01    /* Must be logged in to read */
#define NCP_OBJECT_READ     0x02    /* Readable by same object or super */
#define NCP_BINDERY_READ    0x04    /* Readable only by the bindery */

#define NCP_SUPER_READ      NCP_LOGGED_READ | NCP_OBJECT_READ

#define NCP_ALL_READ        NCP_ANY_READ | NCP_LOGGED_READ | NCP_OBJECT_READ

#define NCP_ANY_WRITE       0x00    /* Writeable by anyone */
#define NCP_LOGGED_WRITE    0x10    /* Must be logged in to write */
#define NCP_OBJECT_WRITE    0x20    /* Writeable by same object or super */
#define NCP_BINDERY_WRITE   0x40    /* Writeable only by the bindery */

#define NCP_SUPER_WRITE     NCP_LOGGED_WRITE | NCP_OBJECT_WRITE

#define NCP_ALL_WRITE       NCP_ANY_WRITE | NCP_LOGGED_WRITE | NCP_OBJECT_WRITE

//  File Attributes

#define NW_ATTRIBUTE_SHARABLE       0x80
#define NW_ATTRIBUTE_ARCHIVE        0x20
#define NW_ATTRIBUTE_DIRECTORY      0x10
#define NW_ATTRIBUTE_EXECUTE_ONLY   0x08
#define NW_ATTRIBUTE_SYSTEM         0x04
#define NW_ATTRIBUTE_HIDDEN         0x02
#define NW_ATTRIBUTE_READ_ONLY      0x01

//  Open Flags

#define NW_OPEN_EXCLUSIVE           0x10
#define NW_DENY_WRITE               0x08
#define NW_DENY_READ                0x04
#define NW_OPEN_FOR_WRITE           0x02
#define NW_OPEN_FOR_READ            0x01

//
//  Connection status flags
//

#define NCP_STATUS_BAD_CONNECTION   0x01
#define NCP_STATUS_NO_CONNECTIONS   0x02
#define NCP_STATUS_SERVER_DOWN      0x04
#define NCP_STATUS_MSG_PENDING      0x08

//
//  Special values for SmallWorld PDC object and property name
//

#define MS_WINNT_NAME      "MS_WINNT"
#define MS_SYNC_PDC_NAME   "SYNCPDC"
#define MS_WINNT_OBJ_TYPE  0x06BB

//
//  User Property values (ie. User Parms stuff)
//

#define USER_PROPERTY_SIGNATURE     L'P'

#define NWPASSWORD                  L"NWPassword"
#define OLDNWPASSWORD               L"OldNWPassword"
#define MAXCONNECTIONS              L"MaxConnections"
#define NWTIMEPASSWORDSET           L"NWPasswordSet"
#define SZTRUE                      L"TRUE"
#define GRACELOGINALLOWED           L"GraceLoginAllowed"
#define GRACELOGINREMAINING         L"GraceLoginRemaining"
#define NWLOGONFROM                 L"NWLogonFrom"
#define NWHOMEDIR                   L"NWHomeDir"
#define NW_PRINT_SERVER_REF_COUNT   L"PSRefCount"

#define SUPERVISOR_USERID           NCP_WELL_KNOWN_SUPERVISOR_ID
#define SUPERVISOR_NAME_STRING      L"Supervisor"
#define SYSVOL_NAME_STRING          L"SYS"
#define NWENCRYPTEDPASSWORDLENGTH   8
#define NO_LIMIT                    0xffff

#define DEFAULT_MAXCONNECTIONS      NO_LIMIT
#define DEFAULT_NWPASSWORDEXPIRED   FALSE
#define DEFAULT_GRACELOGINALLOWED   6
#define DEFAULT_GRACELOGINREMAINING 6
#define DEFAULT_NWLOGONFROM         NULL
#define DEFAULT_NWHOMEDIR           NULL

#define USER_PROPERTY_TYPE_ITEM     1
#define USER_PROPERTY_TYPE_SET      2

#endif /* _NCPCOMM_ */
=== C:/Users/treeman/Desktop/windows nt source code\Source\Win2K3\NT\public\internal\ds\inc\fpnwname.h ===
/*++

Copyright (c) 1993  Microsoft Corporation

Module Name:

    fpnwname.h

Abstract:

    Header for NetWare service names.

Author:

    Rita Wong      (ritaw)      26-Feb-1993

Revision History:

--*/

#ifndef _FPNW_NAMES_INCLUDED_
#define _FPNW_NAMES_INCLUDED_


#define NCP_LSA_SECRET_KEY              L"G$MNSEncryptionKey"
#define NCP_LSA_SECRET_LENGTH           USER_SESSION_KEY_LENGTH // in <crypt.h>

#define NW_SERVER_SERVICE               L"FPNW"
#define NW_SAPAGENT_SERVICE             L"NwSapAgent"
#define CURRENT_DLL_NAME                L"fpnw.dll"
#define FPNW_PASSWD_NOTIFY_DLL_NAME     L"FPNWCLNT"
#define NW_SERVER_DISPLAY_NAME          TEXT("FPNW")

#define SERVER_REGISTRY_PATH            L"FPNW"
#define PARAMETERS_REGISTRY_PATH        L"FPNW\\Parameters"
#define AUTOTUNED_REGISTRY_PATH         L"FPNW\\AutotunedParameters"
#define SHARES_REGISTRY_PATH            L"FPNW\\Volumes"
#define SHARES_SECURITY_REGISTRY_PATH   L"FPNW\\Volumes\\Security"
#define LINKAGE_REGISTRY_PATH           L"FPNW\\Linkage"

#define SERVER_REGISTRY_PARAMETERS      TEXT("SYSTEM\\CurrentControlSet\\Services\\FPNW\\Parameters")
#define SERVER_REGISTRY_VOLUMES         TEXT("SYSTEM\\CurrentControlSet\\Services\\FPNW\\Volumes")
#define SERVER_REGISTRY_BINDERY         TEXT("SYSTEM\\CurrentControlSet\\Services\\FPNW\\Bindery")
#define SERVER_REGISTRY_PERFORMANCE     TEXT("SYSTEM\\CurrentControlSet\\Services\\FPNW\\Performance")

//
// Names of server service keys.
//

#define COMPUTERNAME_REGISTRY_KEY L"ComputerName\\ActiveComputerName\\"

//
// Value names under Parameters.
//

#define BIND_VALUE_NAME L"Bind"
#define SERVNAME_VALUE_NAME L"ComputerName"
#define SSDEBUG_VALUE_NAME L"SsDebug"
#define XSDEBUG_VALUE_NAME L"XsDebug"

#define LOGINDIR_VALUE_NAME L"LoginDirectory"
#define DESCRIPTION_VALUE_NAME L"Description"
#define HOME_BASE_DIRECTORY_NAME     L"HomeBaseDirectory"

#define SIZE_VALUE_NAME                 L"Size"
#define MAXNUMBERUSERS_NAME             L"MaxUsers"
#define MAXWORKCONTEXTS_NAME            L"MaxReceiveBuffers"
#define BLOCKINGWORKERTHREADS_NAME      L"BlockingWorkerThreads"
#define NONBLOCKINGWORKERTHREADS_NAME   L"NonblockingWorkerThreads"
#define INITIALWORKCONTEXTS_NAME        L"InitialReceiveBuffers"
#define MAXSEARCHES_NAME                L"MaxSearchesPerClient"
#define MAXRECEIVEPACKET_NAME           L"MaxReceivePacketSize"
#define DELAYFIRSTWDOG_NAME             L"WatchDogInitialDelay"
#define DELAYNEXTWDOG_NAME              L"WatchDogSecondaryDelay"
#define NUMBERWDOGPACKETS_NAME          L"NumberOfWatchDogPackets"
#define ENABLEFORCEDLOGOFF_NAME         L"EnableForcedLogoff"
#define DISKFULLALERTEVERYONE_NAME      L"AlertEveryoneOnDiskFull"
#define RESPONDTONEAREST_NAME           L"RespondToNearestServer"
#define ALLOWBURST_NAME                 L"EnableBurst"
#define ALLOWLIP_NAME                   L"EnableLip"
#define DISCONNECTATBADSEQ_NAME         L"DisconnectAtBadSeq"
#define LOWVOLUMETHRESHOLD_NAME         L"LowVolumeThreshold"
#define DISKFULLCRITERIA_NAME           L"DiskFullCriteria"
#define LOCKRETRYCOUNT_NAME             L"LockRetryCount"
#define OPLOCKBREAKWAIT                 L"OplockBreakWait"
#define CORECACHEBUFFERS                L"CoreCacheBuffers"
#define CORECACHEBUFFERSIZE             L"CoreCacheBufferSize"
#define ENABLEPASSTHROUGH               L"EnablePassthrough"
#define CLEARTEXTPASSWORDS              L"ClearTextPasswords"
#define DISABLEWRITECACHECRITERIA       L"DisableWriteCacheCriteria"
#define MAXCACHEDOPENFILES              L"MaxCachedOpenFiles"
#define QMSSYNCMODE                     L"QMSSyncMode"
#define SERIALNUMBER                    L"SerialNumber"
#define MAXWORKITEMIDLETIME             L"MaxWorkItemIdleTime"
#define BALANCECOUNT                    L"BalanceCount"
#define RETURNSHAREABLEFLAG             L"ReturnShareableFlag"
#define ALLOWABLEBADSEQUENCEPKTS        L"AllowableBadSequencePkts"
#define MINFREEWORKITEMS                L"MinFreeWorkItems"
#define MAXTHREADSPERQUEUE              L"MaxThreadsPerQueue"
#define MAXFREELFCBS                    L"MaxFreeLfcbs"
#define MAXFREERFCBS                    L"MaxFreeRfcbs"
#define MAXFREEMFCBS                    L"MaxFreeMfcbs"
#define MAXFREEPAGEDPOOLCHUNKS          L"MaxFreePagedPoolChunks"
#define MINPAGEDPOOLCHUNKSIZE           L"MinPagedPoolChunkSize"
#define MAXPAGEDPOOLCHUNKSIZE           L"MaxPagedPoolChunkSize"
#define EMULATESHAREABLEFLAG            L"EmulateShareableFlag"
#define MAXNUMBERBUSYPACKETS            L"MaxNumberBusyPackets"
#define CLIENTBUSYLIMIT                 L"ClientBusyLimit"
#define ENABLENTFSSHAREABLE             L"EnableNtfsShareable"
#define ENABLEOS2NAMESPACE              L"EnableOS2NameSpace"
#define MAXFILENAMECACHE                L"MaxFileNameCache"

#define MINOPENSFORCOMPATOPENLIMIT      L"MinOpensForCompatOpenLimit"
#define MINOPENSFORNORMALOPENLIMIT      L"MinOpensForNormalOpenLimit"
#define RESETTIMEFORCOMPATOPENLIMIT     L"ResetTimeForCompatOpenLimit"
#define RESETTIMEFORNORMALOPENLIMIT     L"ResetTimeForNormalOpenLimit"
#define LOWBOUNDFORCOMPATOPENCACHING    L"LowBoundForCompatOpenCaching"
#define LOWBOUNDFORNORMALOPENCACHING    L"LowBoundForNormalOpenCaching"
#define MINREADSFORCORECACHELIMIT       L"MinReadsForCoreCacheLimit"
#define MINWRITESFORCORECACHELIMIT      L"MinWritesForCoreCacheLimit"
#define RESETTIMEFORCORECACHELIMIT      L"ResetTimeForCoreCacheLimit"
#define LOWBOUNDFORCOREREADCACHING      L"LowBoundForCoreReadCaching"
#define LOWBOUNDFORCOREWRITECACHING     L"LowBoundForCoreWriteCaching"
#define MAXNCPMESSAGELENGTH             L"MaxNcpMessageLength"

//
// Names of share "environment variables".
//

#define MAXUSES_VARIABLE_NAME L"MaxUses"
#define PATH_VARIABLE_NAME L"Path"
#define PERMISSIONS_VARIABLE_NAME L"Permissions"
#define REMARK_VARIABLE_NAME L"Remark"
#define TYPE_VARIABLE_NAME L"Type"

//
//  Values for QMSLIB
//

#define CACHEENTRYTIMEOUT               L"CacheEntryTimeout"
#define ERRORNOTIFYINTERVAL             L"ErrorNotifyInterval"
#define MAXIMUMFREEJCBS                 L"MaximumFreeJCBs"
#define MAXIMUMFREESJES                 L"MaximumFreeSJEs"
#define MAXIMUMFREELPCWORKITEMS         L"MaximumFreeLPCWorkItems"
#define FORMSHASHTABLESIZE              L"FormsHashTableSize"
#define JOBINFOALLOWHINT                L"JobInfoAllocHint"
#define PRINTERINFOALLOCHINT            L"PrinterInfoAllocHint"
#define LOGFORMNAMECHANGES              L"LogFormNameChanges"
#define LOGPRINTERNAMECHANGES           L"LogPrinterNameChanges"
#define PRINTJOBNOTIFYFLAG              L"PrintJobNotifyFlag"
#define QUEUEERRORNOTIFYMASK            L"QueueErrorNotifyMask"
#define JOBERRORNOTIFYMASK              L"JobErrorNotifyMask"
#define SHOWPSERVERNAMEFLAG             L"ShowPServerNameFlag"
#define QMSSYNCMODE                     L"QMSSyncMode"
#define ENFORCENETWARESECURITY          L"EnforceNetWareSecurity"
#define OLDNTJOBSYNCINTERVAL            L"OldNtJobSyncInterval"
#define NWPRINTPROCESSOR                L"NWPrintProcessor"
#define DEFAULTQUEUENAME                L"DefaultQueueName"
#define DEFAULTBANNERFILENAME           L"DefaultBannerFileName"
#define PSERVERPORTS                    L"PServerPorts"

//
//  Values for LIBBIND
//

#define FILTERNWUSERS                   L"FilterNWUsers"
#define HOMEBASEDIRECTORY               L"HomeBaseDirectory"
#define DCNAMETIMEOUT                   L"DCNameTimeout"
#define ENUMERATEHINT                   L"EnumerateHint"
#define MAXIMUMFREESCBS                 L"MaximumFreeSCBs"
#define SCBHASHTABLESIZE                L"SCBHashTableSize"
#define SCBTIMEOUT                      L"SCBTimeout"
#define QUEUEDIRECTORY                  L"QueueDirectory"
#define MAXSCBPERCLIENT                 L"MaxSCBPerClient"
#define MAXIMUMFREECACHEDNAMES          L"MaximumFreeCachedNames"
#define CACHEDNAMETIMEOUT               L"CachedNameTimeout"
#define CACHEDNAMESCAVENGETIMEOUT       L"CachedNameScavengeTimeout"
#define USERGROUPSYNCINTERVAL           L"UserGroupSyncInterval"

#endif // _FPNW_NAMES_INCLUDED_
=== C:/Users/treeman/Desktop/windows nt source code\Source\Win2K3\NT\public\internal\ds\inc\ftnfoctx.h ===
/*++

Copyright (c) 1987-2001  Microsoft Corporation

Module Name:

    ftnfoctx.h

Abstract:

    Utility routines for manipulating the forest trust context

Author:

    27-Jul-00 (cliffv)

Environment:

    User mode only.
    Contains NT-specific code.
    Requires ANSI C extensions: slash-slash comments, long external names.

Revision History:

--*/


#ifndef __FTNFOCTX_H
#define __FTNFOCTX_H

//
// Context used to collect the individual FTinfo entries
//

typedef struct _NL_FTINFO_CONTEXT {

    //
    // List of all the FTinfo structures collected so far.
    //

    LIST_ENTRY FtinfoList;

    //
    // Size (in bytes) of the entries on FtinfoList.
    //

    ULONG FtinfoSize;

    //
    // Number of entries on FtinfoList
    //

    ULONG FtinfoCount;

} NL_FTINFO_CONTEXT, *PNL_FTINFO_CONTEXT;

//
// A single FTinfo entry
//

typedef struct _NL_FTINFO_ENTRY {

    //
    // Link off of NL_FITINFO_CONTEXT->FtinfoList
    //

    LIST_ENTRY Next;

    //
    // Size (in bytes) of just the 'Record' portion of this entry
    //

    ULONG Size;

    //
    // Pad the Record to start on an ALIGN_WORST boundary
    //

    ULONG Pad;

    //
    // The actual Ftinfo entry
    //

    LSA_FOREST_TRUST_RECORD Record;

} NL_FTINFO_ENTRY, *PNL_FTINFO_ENTRY;

#ifdef __cplusplus
extern "C" {
#endif


VOID
NetpInitFtinfoContext(
    OUT PNL_FTINFO_CONTEXT FtinfoContext
    );


PLSA_FOREST_TRUST_INFORMATION
NetpCopyFtinfoContext(
    IN PNL_FTINFO_CONTEXT FtinfoContext
    );


VOID
NetpCleanFtinfoContext(
    IN PNL_FTINFO_CONTEXT FtinfoContext
    );


BOOLEAN
NetpAllocFtinfoEntry (
    IN PNL_FTINFO_CONTEXT FtinfoContext,
    IN LSA_FOREST_TRUST_RECORD_TYPE ForestTrustType,
    IN PUNICODE_STRING Name,
    IN PSID Sid,
    IN PUNICODE_STRING NetbiosName
    );


BOOLEAN
NetpAddTlnFtinfoEntry (
    IN PNL_FTINFO_CONTEXT FtinfoContext,
    IN PUNICODE_STRING Name
    );


NTSTATUS
NetpMergeFtinfo(
    IN PUNICODE_STRING TrustedDomainName,
    IN PLSA_FOREST_TRUST_INFORMATION InNewForestTrustInfo,
    IN PLSA_FOREST_TRUST_INFORMATION InOldForestTrustInfo OPTIONAL,
    OUT PLSA_FOREST_TRUST_INFORMATION *MergedForestTrustInfo
    );

#ifdef __cplusplus
}
#endif

#endif
=== C:/Users/treeman/Desktop/windows nt source code\Source\Win2K3\NT\public\internal\ds\inc\iadsp.h ===
/* this ALWAYS GENERATED file contains the definitions for the interfaces */


 /* File created by MIDL compiler version 6.00.0361 */
/* Compiler settings for adsp.odl:
    Oicf, W1, Zp8, env=Win32 (32b run)
    protocol : dce , ms_ext, c_ext, robust
    error checks: allocation ref bounds_check enum stub_data 
    VC __declspec() decoration level: 
         __declspec(uuid()), __declspec(selectany), __declspec(novtable)
         DECLSPEC_UUID(), MIDL_INTERFACE()
*/
//@@MIDL_FILE_HEADING(  )

#pragma warning( disable: 4049 )  /* more than 64k source lines */


/* verify that the <rpcndr.h> version is high enough to compile this file*/
#ifndef __REQUIRED_RPCNDR_H_VERSION__
#define __REQUIRED_RPCNDR_H_VERSION__ 475
#endif

#include "rpc.h"
#include "rpcndr.h"

#ifndef __RPCNDR_H_VERSION__
#error this stub requires an updated version of <rpcndr.h>
#endif // __RPCNDR_H_VERSION__


#ifndef __iadsp_h__
#define __iadsp_h__

#if defined(_MSC_VER) && (_MSC_VER >= 1020)
#pragma once
#endif

/* Forward Declarations */ 

#ifndef __IADsValue_FWD_DEFINED__
#define __IADsValue_FWD_DEFINED__
typedef interface IADsValue IADsValue;
#endif 	/* __IADsValue_FWD_DEFINED__ */


#ifndef __IADsObjOptPrivate_FWD_DEFINED__
#define __IADsObjOptPrivate_FWD_DEFINED__
typedef interface IADsObjOptPrivate IADsObjOptPrivate;
#endif 	/* __IADsObjOptPrivate_FWD_DEFINED__ */


#ifndef __IADsUmiHelperPrivate_FWD_DEFINED__
#define __IADsUmiHelperPrivate_FWD_DEFINED__
typedef interface IADsUmiHelperPrivate IADsUmiHelperPrivate;
#endif 	/* __IADsUmiHelperPrivate_FWD_DEFINED__ */


#ifndef __IADsPathnameProvider_FWD_DEFINED__
#define __IADsPathnameProvider_FWD_DEFINED__
typedef interface IADsPathnameProvider IADsPathnameProvider;
#endif 	/* __IADsPathnameProvider_FWD_DEFINED__ */


#ifndef __IUmiADSIPrivate_FWD_DEFINED__
#define __IUmiADSIPrivate_FWD_DEFINED__
typedef interface IUmiADSIPrivate IUmiADSIPrivate;
#endif 	/* __IUmiADSIPrivate_FWD_DEFINED__ */


#ifndef __IADsAcePrivate_FWD_DEFINED__
#define __IADsAcePrivate_FWD_DEFINED__
typedef interface IADsAcePrivate IADsAcePrivate;
#endif 	/* __IADsAcePrivate_FWD_DEFINED__ */


#ifdef __cplusplus
extern "C"{
#endif 

void * __RPC_USER MIDL_user_allocate(size_t);
void __RPC_USER MIDL_user_free( void * ); 

/* interface __MIDL_itf_adsp_0000 */
/* [local] */ 

#define IID_IDirectoryAttrMgmt IID_IDirectorySchemaMgmt
#define IDirectoryAttrMgmt IDirectorySchemaMgmt


extern RPC_IF_HANDLE __MIDL_itf_adsp_0000_v0_0_c_ifspec;
extern RPC_IF_HANDLE __MIDL_itf_adsp_0000_v0_0_s_ifspec;


#ifndef __ActiveDsP_LIBRARY_DEFINED__
#define __ActiveDsP_LIBRARY_DEFINED__

/* library ActiveDsP */
/* [helpstring][version][uuid] */ 

typedef /* [public] */ 
enum __MIDL___MIDL_itf_adsp_0000_0001
    {	ADS_PRIVATE_OPTION_SPECIFIC_SERVER	= 101,
	ADS_PRIVATE_OPTION_KEEP_HANDLES	= 102
    } 	ADS_PRIVATE_OPTION_ENUM;

typedef struct _path_component
    {
    LPTSTR szComponent;
    LPTSTR szValue;
    } 	PATH_COMPONENT;

typedef struct _path_component *PPATH_COMPONENT;

typedef struct _path_objectinfo
    {
    LPTSTR ProviderName;
    LPTSTR ServerName;
    LPTSTR DisplayServerName;
    DWORD dwPathType;
    DWORD NumComponents;
    PATH_COMPONENT ComponentArray[ 64 ];
    PATH_COMPONENT DisplayComponentArray[ 64 ];
    PATH_COMPONENT ProvSpecComponentArray[ 64 ];
    } 	PATH_OBJECTINFO;

typedef struct _path_objectinfo *PPATH_OBJECTINFO;


enum __MIDL___MIDL_itf_adsp_0119_0001
    {	ADS_PARSE_FULL	= 1,
	ADS_PARSE_DN	= 2,
	ADS_PARSE_COMPONENT	= 3
    } ;

enum __MIDL___MIDL_itf_adsp_0119_0002
    {	ADS_PATHTYPE_ROOTFIRST	= 1,
	ADS_PATHTYPE_LEAFFIRST	= 2
    } ;

enum __MIDL___MIDL_itf_adsp_0119_0003
    {	ADS_CONSTRUCT_NAMINGATTRIBUTE	= 1
    } ;

EXTERN_C const IID LIBID_ActiveDsP;

#ifndef __IADsValue_INTERFACE_DEFINED__
#define __IADsValue_INTERFACE_DEFINED__

/* interface IADsValue */
/* [object][uuid] */ 


EXTERN_C const IID IID_IADsValue;

#if defined(__cplusplus) && !defined(CINTERFACE)
    
    MIDL_INTERFACE("1e3ef0aa-aef5-11d0-8537-00c04fd8d503")
    IADsValue : public IUnknown
    {
    public:
        virtual HRESULT STDMETHODCALLTYPE ConvertADsValueToPropertyValue( 
            PADSVALUE pADsValue) = 0;
        
        virtual HRESULT STDMETHODCALLTYPE ConvertPropertyValueToADsValue( 
            PADSVALUE pADsValue) = 0;
        
        virtual HRESULT STDMETHODCALLTYPE ConvertPropertyValueToADsValue2( 
            PADSVALUE pADsValue,
            BSTR pszServerName,
            BSTR userName,
            BSTR passWord,
            LONG flags,
            BOOL fNTDSType) = 0;
        
    };
    
#else 	/* C style interface */

    typedef struct IADsValueVtbl
    {
        BEGIN_INTERFACE
        
        HRESULT ( STDMETHODCALLTYPE *QueryInterface )( 
            IADsValue * This,
            /* [in] */ REFIID riid,
            /* [iid_is][out] */ void **ppvObject);
        
        ULONG ( STDMETHODCALLTYPE *AddRef )( 
            IADsValue * This);
        
        ULONG ( STDMETHODCALLTYPE *Release )( 
            IADsValue * This);
        
        HRESULT ( STDMETHODCALLTYPE *ConvertADsValueToPropertyValue )( 
            IADsValue * This,
            PADSVALUE pADsValue);
        
        HRESULT ( STDMETHODCALLTYPE *ConvertPropertyValueToADsValue )( 
            IADsValue * This,
            PADSVALUE pADsValue);
        
        HRESULT ( STDMETHODCALLTYPE *ConvertPropertyValueToADsValue2 )( 
            IADsValue * This,
            PADSVALUE pADsValue,
            BSTR pszServerName,
            BSTR userName,
            BSTR passWord,
            LONG flags,
            BOOL fNTDSType);
        
        END_INTERFACE
    } IADsValueVtbl;

    interface IADsValue
    {
        CONST_VTBL struct IADsValueVtbl *lpVtbl;
    };

    

#ifdef COBJMACROS


#define IADsValue_QueryInterface(This,riid,ppvObject)	\
    (This)->lpVtbl -> QueryInterface(This,riid,ppvObject)

#define IADsValue_AddRef(This)	\
    (This)->lpVtbl -> AddRef(This)

#define IADsValue_Release(This)	\
    (This)->lpVtbl -> Release(This)


#define IADsValue_ConvertADsValueToPropertyValue(This,pADsValue)	\
    (This)->lpVtbl -> ConvertADsValueToPropertyValue(This,pADsValue)

#define IADsValue_ConvertPropertyValueToADsValue(This,pADsValue)	\
    (This)->lpVtbl -> ConvertPropertyValueToADsValue(This,pADsValue)

#define IADsValue_ConvertPropertyValueToADsValue2(This,pADsValue,pszServerName,userName,passWord,flags,fNTDSType)	\
    (This)->lpVtbl -> ConvertPropertyValueToADsValue2(This,pADsValue,pszServerName,userName,passWord,flags,fNTDSType)

#endif /* COBJMACROS */


#endif 	/* C style interface */



HRESULT STDMETHODCALLTYPE IADsValue_ConvertADsValueToPropertyValue_Proxy( 
    IADsValue * This,
    PADSVALUE pADsValue);


void __RPC_STUB IADsValue_ConvertADsValueToPropertyValue_Stub(
    IRpcStubBuffer *This,
    IRpcChannelBuffer *_pRpcChannelBuffer,
    PRPC_MESSAGE _pRpcMessage,
    DWORD *_pdwStubPhase);


HRESULT STDMETHODCALLTYPE IADsValue_ConvertPropertyValueToADsValue_Proxy( 
    IADsValue * This,
    PADSVALUE pADsValue);


void __RPC_STUB IADsValue_ConvertPropertyValueToADsValue_Stub(
    IRpcStubBuffer *This,
    IRpcChannelBuffer *_pRpcChannelBuffer,
    PRPC_MESSAGE _pRpcMessage,
    DWORD *_pdwStubPhase);


HRESULT STDMETHODCALLTYPE IADsValue_ConvertPropertyValueToADsValue2_Proxy( 
    IADsValue * This,
    PADSVALUE pADsValue,
    BSTR pszServerName,
    BSTR userName,
    BSTR passWord,
    LONG flags,
    BOOL fNTDSType);


void __RPC_STUB IADsValue_ConvertPropertyValueToADsValue2_Stub(
    IRpcStubBuffer *This,
    IRpcChannelBuffer *_pRpcChannelBuffer,
    PRPC_MESSAGE _pRpcMessage,
    DWORD *_pdwStubPhase);



#endif 	/* __IADsValue_INTERFACE_DEFINED__ */


#ifndef __IADsObjOptPrivate_INTERFACE_DEFINED__
#define __IADsObjOptPrivate_INTERFACE_DEFINED__

/* interface IADsObjOptPrivate */
/* [object][uuid] */ 


EXTERN_C const IID IID_IADsObjOptPrivate;

#if defined(__cplusplus) && !defined(CINTERFACE)
    
    MIDL_INTERFACE("81cbb829-1867-11d2-9220-00c04fb6d0d1")
    IADsObjOptPrivate : public IUnknown
    {
    public:
        virtual HRESULT STDMETHODCALLTYPE GetOption( 
            DWORD dwOption,
            void *pValue) = 0;
        
        virtual HRESULT STDMETHODCALLTYPE SetOption( 
            DWORD dwOption,
            void *pValue) = 0;
        
    };
    
#else 	/* C style interface */

    typedef struct IADsObjOptPrivateVtbl
    {
        BEGIN_INTERFACE
        
        HRESULT ( STDMETHODCALLTYPE *QueryInterface )( 
            IADsObjOptPrivate * This,
            /* [in] */ REFIID riid,
            /* [iid_is][out] */ void **ppvObject);
        
        ULONG ( STDMETHODCALLTYPE *AddRef )( 
            IADsObjOptPrivate * This);
        
        ULONG ( STDMETHODCALLTYPE *Release )( 
            IADsObjOptPrivate * This);
        
        HRESULT ( STDMETHODCALLTYPE *GetOption )( 
            IADsObjOptPrivate * This,
            DWORD dwOption,
            void *pValue);
        
        HRESULT ( STDMETHODCALLTYPE *SetOption )( 
            IADsObjOptPrivate * This,
            DWORD dwOption,
            void *pValue);
        
        END_INTERFACE
    } IADsObjOptPrivateVtbl;

    interface IADsObjOptPrivate
    {
        CONST_VTBL struct IADsObjOptPrivateVtbl *lpVtbl;
    };

    

#ifdef COBJMACROS


#define IADsObjOptPrivate_QueryInterface(This,riid,ppvObject)	\
    (This)->lpVtbl -> QueryInterface(This,riid,ppvObject)

#define IADsObjOptPrivate_AddRef(This)	\
    (This)->lpVtbl -> AddRef(This)

#define IADsObjOptPrivate_Release(This)	\
    (This)->lpVtbl -> Release(This)


#define IADsObjOptPrivate_GetOption(This,dwOption,pValue)	\
    (This)->lpVtbl -> GetOption(This,dwOption,pValue)

#define IADsObjOptPrivate_SetOption(This,dwOption,pValue)	\
    (This)->lpVtbl -> SetOption(This,dwOption,pValue)

#endif /* COBJMACROS */


#endif 	/* C style interface */



HRESULT STDMETHODCALLTYPE IADsObjOptPrivate_GetOption_Proxy( 
    IADsObjOptPrivate * This,
    DWORD dwOption,
    void *pValue);


void __RPC_STUB IADsObjOptPrivate_GetOption_Stub(
    IRpcStubBuffer *This,
    IRpcChannelBuffer *_pRpcChannelBuffer,
    PRPC_MESSAGE _pRpcMessage,
    DWORD *_pdwStubPhase);


HRESULT STDMETHODCALLTYPE IADsObjOptPrivate_SetOption_Proxy( 
    IADsObjOptPrivate * This,
    DWORD dwOption,
    void *pValue);


void __RPC_STUB IADsObjOptPrivate_SetOption_Stub(
    IRpcStubBuffer *This,
    IRpcChannelBuffer *_pRpcChannelBuffer,
    PRPC_MESSAGE _pRpcMessage,
    DWORD *_pdwStubPhase);



#endif 	/* __IADsObjOptPrivate_INTERFACE_DEFINED__ */


#ifndef __IADsUmiHelperPrivate_INTERFACE_DEFINED__
#define __IADsUmiHelperPrivate_INTERFACE_DEFINED__

/* interface IADsUmiHelperPrivate */
/* [object][uuid] */ 


EXTERN_C const IID IID_IADsUmiHelperPrivate;

#if defined(__cplusplus) && !defined(CINTERFACE)
    
    MIDL_INTERFACE("4fe243f0-ad89-4cbc-9b14-486126446ae0")
    IADsUmiHelperPrivate : public IUnknown
    {
    public:
        virtual HRESULT STDMETHODCALLTYPE GetPropertiesHelper( 
            void **ppValue,
            DWORD *pdwPropCount) = 0;
        
        virtual HRESULT STDMETHODCALLTYPE GetOriginHelper( 
            LPCWSTR pszName,
            BSTR *pbstrOrigin) = 0;
        
    };
    
#else 	/* C style interface */

    typedef struct IADsUmiHelperPrivateVtbl
    {
        BEGIN_INTERFACE
        
        HRESULT ( STDMETHODCALLTYPE *QueryInterface )( 
            IADsUmiHelperPrivate * This,
            /* [in] */ REFIID riid,
            /* [iid_is][out] */ void **ppvObject);
        
        ULONG ( STDMETHODCALLTYPE *AddRef )( 
            IADsUmiHelperPrivate * This);
        
        ULONG ( STDMETHODCALLTYPE *Release )( 
            IADsUmiHelperPrivate * This);
        
        HRESULT ( STDMETHODCALLTYPE *GetPropertiesHelper )( 
            IADsUmiHelperPrivate * This,
            void **ppValue,
            DWORD *pdwPropCount);
        
        HRESULT ( STDMETHODCALLTYPE *GetOriginHelper )( 
            IADsUmiHelperPrivate * This,
            LPCWSTR pszName,
            BSTR *pbstrOrigin);
        
        END_INTERFACE
    } IADsUmiHelperPrivateVtbl;

    interface IADsUmiHelperPrivate
    {
        CONST_VTBL struct IADsUmiHelperPrivateVtbl *lpVtbl;
    };

    

#ifdef COBJMACROS


#define IADsUmiHelperPrivate_QueryInterface(This,riid,ppvObject)	\
    (This)->lpVtbl -> QueryInterface(This,riid,ppvObject)

#define IADsUmiHelperPrivate_AddRef(This)	\
    (This)->lpVtbl -> AddRef(This)

#define IADsUmiHelperPrivate_Release(This)	\
    (This)->lpVtbl -> Release(This)


#define IADsUmiHelperPrivate_GetPropertiesHelper(This,ppValue,pdwPropCount)	\
    (This)->lpVtbl -> GetPropertiesHelper(This,ppValue,pdwPropCount)

#define IADsUmiHelperPrivate_GetOriginHelper(This,pszName,pbstrOrigin)	\
    (This)->lpVtbl -> GetOriginHelper(This,pszName,pbstrOrigin)

#endif /* COBJMACROS */


#endif 	/* C style interface */



HRESULT STDMETHODCALLTYPE IADsUmiHelperPrivate_GetPropertiesHelper_Proxy( 
    IADsUmiHelperPrivate * This,
    void **ppValue,
    DWORD *pdwPropCount);


void __RPC_STUB IADsUmiHelperPrivate_GetPropertiesHelper_Stub(
    IRpcStubBuffer *This,
    IRpcChannelBuffer *_pRpcChannelBuffer,
    PRPC_MESSAGE _pRpcMessage,
    DWORD *_pdwStubPhase);


HRESULT STDMETHODCALLTYPE IADsUmiHelperPrivate_GetOriginHelper_Proxy( 
    IADsUmiHelperPrivate * This,
    LPCWSTR pszName,
    BSTR *pbstrOrigin);


void __RPC_STUB IADsUmiHelperPrivate_GetOriginHelper_Stub(
    IRpcStubBuffer *This,
    IRpcChannelBuffer *_pRpcChannelBuffer,
    PRPC_MESSAGE _pRpcMessage,
    DWORD *_pdwStubPhase);



#endif 	/* __IADsUmiHelperPrivate_INTERFACE_DEFINED__ */


#ifndef __IADsPathnameProvider_INTERFACE_DEFINED__
#define __IADsPathnameProvider_INTERFACE_DEFINED__

/* interface IADsPathnameProvider */
/* [object][uuid] */ 


EXTERN_C const IID IID_IADsPathnameProvider;

#if defined(__cplusplus) && !defined(CINTERFACE)
    
    MIDL_INTERFACE("aacd1d30-8bd0-11d2-92a9-00c04f79f834")
    IADsPathnameProvider : public IUnknown
    {
    public:
        virtual HRESULT STDMETHODCALLTYPE ParsePath( 
            /* [in] */ BSTR bstrPath,
            /* [in] */ DWORD dwType,
            /* [in] */ PPATH_OBJECTINFO pObjectInfo) = 0;
        
        virtual HRESULT STDMETHODCALLTYPE ConstructPath( 
            /* [in] */ PPATH_OBJECTINFO pObjectInfo,
            /* [in] */ DWORD dwType,
            /* [in] */ DWORD dwFlag,
            /* [in] */ DWORD dwEscapedMode,
            /* [out] */ BSTR *pbstrPath) = 0;
        
        virtual HRESULT STDMETHODCALLTYPE GetEscapedElement( 
            /* [in] */ LONG lnReserved,
            /* [in] */ BSTR bstrInStr,
            /* [out] */ BSTR *pbstrOutStr) = 0;
        
    };
    
#else 	/* C style interface */

    typedef struct IADsPathnameProviderVtbl
    {
        BEGIN_INTERFACE
        
        HRESULT ( STDMETHODCALLTYPE *QueryInterface )( 
            IADsPathnameProvider * This,
            /* [in] */ REFIID riid,
            /* [iid_is][out] */ void **ppvObject);
        
        ULONG ( STDMETHODCALLTYPE *AddRef )( 
            IADsPathnameProvider * This);
        
        ULONG ( STDMETHODCALLTYPE *Release )( 
            IADsPathnameProvider * This);
        
        HRESULT ( STDMETHODCALLTYPE *ParsePath )( 
            IADsPathnameProvider * This,
            /* [in] */ BSTR bstrPath,
            /* [in] */ DWORD dwType,
            /* [in] */ PPATH_OBJECTINFO pObjectInfo);
        
        HRESULT ( STDMETHODCALLTYPE *ConstructPath )( 
            IADsPathnameProvider * This,
            /* [in] */ PPATH_OBJECTINFO pObjectInfo,
            /* [in] */ DWORD dwType,
            /* [in] */ DWORD dwFlag,
            /* [in] */ DWORD dwEscapedMode,
            /* [out] */ BSTR *pbstrPath);
        
        HRESULT ( STDMETHODCALLTYPE *GetEscapedElement )( 
            IADsPathnameProvider * This,
            /* [in] */ LONG lnReserved,
            /* [in] */ BSTR bstrInStr,
            /* [out] */ BSTR *pbstrOutStr);
        
        END_INTERFACE
    } IADsPathnameProviderVtbl;

    interface IADsPathnameProvider
    {
        CONST_VTBL struct IADsPathnameProviderVtbl *lpVtbl;
    };

    

#ifdef COBJMACROS


#define IADsPathnameProvider_QueryInterface(This,riid,ppvObject)	\
    (This)->lpVtbl -> QueryInterface(This,riid,ppvObject)

#define IADsPathnameProvider_AddRef(This)	\
    (This)->lpVtbl -> AddRef(This)

#define IADsPathnameProvider_Release(This)	\
    (This)->lpVtbl -> Release(This)


#define IADsPathnameProvider_ParsePath(This,bstrPath,dwType,pObjectInfo)	\
    (This)->lpVtbl -> ParsePath(This,bstrPath,dwType,pObjectInfo)

#define IADsPathnameProvider_ConstructPath(This,pObjectInfo,dwType,dwFlag,dwEscapedMode,pbstrPath)	\
    (This)->lpVtbl -> ConstructPath(This,pObjectInfo,dwType,dwFlag,dwEscapedMode,pbstrPath)

#define IADsPathnameProvider_GetEscapedElement(This,lnReserved,bstrInStr,pbstrOutStr)	\
    (This)->lpVtbl -> GetEscapedElement(This,lnReserved,bstrInStr,pbstrOutStr)

#endif /* COBJMACROS */


#endif 	/* C style interface */



HRESULT STDMETHODCALLTYPE IADsPathnameProvider_ParsePath_Proxy( 
    IADsPathnameProvider * This,
    /* [in] */ BSTR bstrPath,
    /* [in] */ DWORD dwType,
    /* [in] */ PPATH_OBJECTINFO pObjectInfo);


void __RPC_STUB IADsPathnameProvider_ParsePath_Stub(
    IRpcStubBuffer *This,
    IRpcChannelBuffer *_pRpcChannelBuffer,
    PRPC_MESSAGE _pRpcMessage,
    DWORD *_pdwStubPhase);


HRESULT STDMETHODCALLTYPE IADsPathnameProvider_ConstructPath_Proxy( 
    IADsPathnameProvider * This,
    /* [in] */ PPATH_OBJECTINFO pObjectInfo,
    /* [in] */ DWORD dwType,
    /* [in] */ DWORD dwFlag,
    /* [in] */ DWORD dwEscapedMode,
    /* [out] */ BSTR *pbstrPath);


void __RPC_STUB IADsPathnameProvider_ConstructPath_Stub(
    IRpcStubBuffer *This,
    IRpcChannelBuffer *_pRpcChannelBuffer,
    PRPC_MESSAGE _pRpcMessage,
    DWORD *_pdwStubPhase);


HRESULT STDMETHODCALLTYPE IADsPathnameProvider_GetEscapedElement_Proxy( 
    IADsPathnameProvider * This,
    /* [in] */ LONG lnReserved,
    /* [in] */ BSTR bstrInStr,
    /* [out] */ BSTR *pbstrOutStr);


void __RPC_STUB IADsPathnameProvider_GetEscapedElement_Stub(
    IRpcStubBuffer *This,
    IRpcChannelBuffer *_pRpcChannelBuffer,
    PRPC_MESSAGE _pRpcMessage,
    DWORD *_pdwStubPhase);



#endif 	/* __IADsPathnameProvider_INTERFACE_DEFINED__ */


#ifndef __IUmiADSIPrivate_INTERFACE_DEFINED__
#define __IUmiADSIPrivate_INTERFACE_DEFINED__

/* interface IUmiADSIPrivate */
/* [object][uuid] */ 


EXTERN_C const IID IID_IUmiADSIPrivate;

#if defined(__cplusplus) && !defined(CINTERFACE)
    
    MIDL_INTERFACE("8f3bb40b-d4ad-4648-ae4a-6efa197a1656")
    IUmiADSIPrivate : public IUnknown
    {
    public:
        virtual HRESULT STDMETHODCALLTYPE GetContainer( 
            void **ppContainer) = 0;
        
        virtual HRESULT STDMETHODCALLTYPE GetCoreObject( 
            void **ppCoreObj) = 0;
        
        virtual void STDMETHODCALLTYPE SetUmiFlag( void) = 0;
        
        virtual void STDMETHODCALLTYPE ResetUmiFlag( void) = 0;
        
    };
    
#else 	/* C style interface */

    typedef struct IUmiADSIPrivateVtbl
    {
        BEGIN_INTERFACE
        
        HRESULT ( STDMETHODCALLTYPE *QueryInterface )( 
            IUmiADSIPrivate * This,
            /* [in] */ REFIID riid,
            /* [iid_is][out] */ void **ppvObject);
        
        ULONG ( STDMETHODCALLTYPE *AddRef )( 
            IUmiADSIPrivate * This);
        
        ULONG ( STDMETHODCALLTYPE *Release )( 
            IUmiADSIPrivate * This);
        
        HRESULT ( STDMETHODCALLTYPE *GetContainer )( 
            IUmiADSIPrivate * This,
            void **ppContainer);
        
        HRESULT ( STDMETHODCALLTYPE *GetCoreObject )( 
            IUmiADSIPrivate * This,
            void **ppCoreObj);
        
        void ( STDMETHODCALLTYPE *SetUmiFlag )( 
            IUmiADSIPrivate * This);
        
        void ( STDMETHODCALLTYPE *ResetUmiFlag )( 
            IUmiADSIPrivate * This);
        
        END_INTERFACE
    } IUmiADSIPrivateVtbl;

    interface IUmiADSIPrivate
    {
        CONST_VTBL struct IUmiADSIPrivateVtbl *lpVtbl;
    };

    

#ifdef COBJMACROS


#define IUmiADSIPrivate_QueryInterface(This,riid,ppvObject)	\
    (This)->lpVtbl -> QueryInterface(This,riid,ppvObject)

#define IUmiADSIPrivate_AddRef(This)	\
    (This)->lpVtbl -> AddRef(This)

#define IUmiADSIPrivate_Release(This)	\
    (This)->lpVtbl -> Release(This)


#define IUmiADSIPrivate_GetContainer(This,ppContainer)	\
    (This)->lpVtbl -> GetContainer(This,ppContainer)

#define IUmiADSIPrivate_GetCoreObject(This,ppCoreObj)	\
    (This)->lpVtbl -> GetCoreObject(This,ppCoreObj)

#define IUmiADSIPrivate_SetUmiFlag(This)	\
    (This)->lpVtbl -> SetUmiFlag(This)

#define IUmiADSIPrivate_ResetUmiFlag(This)	\
    (This)->lpVtbl -> ResetUmiFlag(This)

#endif /* COBJMACROS */


#endif 	/* C style interface */



HRESULT STDMETHODCALLTYPE IUmiADSIPrivate_GetContainer_Proxy( 
    IUmiADSIPrivate * This,
    void **ppContainer);


void __RPC_STUB IUmiADSIPrivate_GetContainer_Stub(
    IRpcStubBuffer *This,
    IRpcChannelBuffer *_pRpcChannelBuffer,
    PRPC_MESSAGE _pRpcMessage,
    DWORD *_pdwStubPhase);


HRESULT STDMETHODCALLTYPE IUmiADSIPrivate_GetCoreObject_Proxy( 
    IUmiADSIPrivate * This,
    void **ppCoreObj);


void __RPC_STUB IUmiADSIPrivate_GetCoreObject_Stub(
    IRpcStubBuffer *This,
    IRpcChannelBuffer *_pRpcChannelBuffer,
    PRPC_MESSAGE _pRpcMessage,
    DWORD *_pdwStubPhase);


void STDMETHODCALLTYPE IUmiADSIPrivate_SetUmiFlag_Proxy( 
    IUmiADSIPrivate * This);


void __RPC_STUB IUmiADSIPrivate_SetUmiFlag_Stub(
    IRpcStubBuffer *This,
    IRpcChannelBuffer *_pRpcChannelBuffer,
    PRPC_MESSAGE _pRpcMessage,
    DWORD *_pdwStubPhase);


void STDMETHODCALLTYPE IUmiADSIPrivate_ResetUmiFlag_Proxy( 
    IUmiADSIPrivate * This);


void __RPC_STUB IUmiADSIPrivate_ResetUmiFlag_Stub(
    IRpcStubBuffer *This,
    IRpcChannelBuffer *_pRpcChannelBuffer,
    PRPC_MESSAGE _pRpcMessage,
    DWORD *_pdwStubPhase);



#endif 	/* __IUmiADSIPrivate_INTERFACE_DEFINED__ */


#ifndef __IADsAcePrivate_INTERFACE_DEFINED__
#define __IADsAcePrivate_INTERFACE_DEFINED__

/* interface IADsAcePrivate */
/* [object][uuid] */ 


EXTERN_C const IID IID_IADsAcePrivate;

#if defined(__cplusplus) && !defined(CINTERFACE)
    
    MIDL_INTERFACE("fd145df2-fd96-4135-9b22-68ff0f6bf5bb")
    IADsAcePrivate : public IUnknown
    {
    public:
        virtual HRESULT STDMETHODCALLTYPE getSid( 
            /* [out] */ PSID *ppSid,
            /* [out] */ DWORD *pdwLength) = 0;
        
        virtual HRESULT STDMETHODCALLTYPE putSid( 
            /* [in] */ PSID pSid,
            /* [in] */ DWORD dwLength) = 0;
        
        virtual HRESULT STDMETHODCALLTYPE isSidValid( 
            /* [out] */ BOOL *pfSidValid) = 0;
        
    };
    
#else 	/* C style interface */

    typedef struct IADsAcePrivateVtbl
    {
        BEGIN_INTERFACE
        
        HRESULT ( STDMETHODCALLTYPE *QueryInterface )( 
            IADsAcePrivate * This,
            /* [in] */ REFIID riid,
            /* [iid_is][out] */ void **ppvObject);
        
        ULONG ( STDMETHODCALLTYPE *AddRef )( 
            IADsAcePrivate * This);
        
        ULONG ( STDMETHODCALLTYPE *Release )( 
            IADsAcePrivate * This);
        
        HRESULT ( STDMETHODCALLTYPE *getSid )( 
            IADsAcePrivate * This,
            /* [out] */ PSID *ppSid,
            /* [out] */ DWORD *pdwLength);
        
        HRESULT ( STDMETHODCALLTYPE *putSid )( 
            IADsAcePrivate * This,
            /* [in] */ PSID pSid,
            /* [in] */ DWORD dwLength);
        
        HRESULT ( STDMETHODCALLTYPE *isSidValid )( 
            IADsAcePrivate * This,
            /* [out] */ BOOL *pfSidValid);
        
        END_INTERFACE
    } IADsAcePrivateVtbl;

    interface IADsAcePrivate
    {
        CONST_VTBL struct IADsAcePrivateVtbl *lpVtbl;
    };

    

#ifdef COBJMACROS


#define IADsAcePrivate_QueryInterface(This,riid,ppvObject)	\
    (This)->lpVtbl -> QueryInterface(This,riid,ppvObject)

#define IADsAcePrivate_AddRef(This)	\
    (This)->lpVtbl -> AddRef(This)

#define IADsAcePrivate_Release(This)	\
    (This)->lpVtbl -> Release(This)


#define IADsAcePrivate_getSid(This,ppSid,pdwLength)	\
    (This)->lpVtbl -> getSid(This,ppSid,pdwLength)

#define IADsAcePrivate_putSid(This,pSid,dwLength)	\
    (This)->lpVtbl -> putSid(This,pSid,dwLength)

#define IADsAcePrivate_isSidValid(This,pfSidValid)	\
    (This)->lpVtbl -> isSidValid(This,pfSidValid)

#endif /* COBJMACROS */


#endif 	/* C style interface */



HRESULT STDMETHODCALLTYPE IADsAcePrivate_getSid_Proxy( 
    IADsAcePrivate * This,
    /* [out] */ PSID *ppSid,
    /* [out] */ DWORD *pdwLength);


void __RPC_STUB IADsAcePrivate_getSid_Stub(
    IRpcStubBuffer *This,
    IRpcChannelBuffer *_pRpcChannelBuffer,
    PRPC_MESSAGE _pRpcMessage,
    DWORD *_pdwStubPhase);


HRESULT STDMETHODCALLTYPE IADsAcePrivate_putSid_Proxy( 
    IADsAcePrivate * This,
    /* [in] */ PSID pSid,
    /* [in] */ DWORD dwLength);


void __RPC_STUB IADsAcePrivate_putSid_Stub(
    IRpcStubBuffer *This,
    IRpcChannelBuffer *_pRpcChannelBuffer,
    PRPC_MESSAGE _pRpcMessage,
    DWORD *_pdwStubPhase);


HRESULT STDMETHODCALLTYPE IADsAcePrivate_isSidValid_Proxy( 
    IADsAcePrivate * This,
    /* [out] */ BOOL *pfSidValid);


void __RPC_STUB IADsAcePrivate_isSidValid_Stub(
    IRpcStubBuffer *This,
    IRpcChannelBuffer *_pRpcChannelBuffer,
    PRPC_MESSAGE _pRpcMessage,
    DWORD *_pdwStubPhase);



#endif 	/* __IADsAcePrivate_INTERFACE_DEFINED__ */

#endif /* __ActiveDsP_LIBRARY_DEFINED__ */

/* Additional Prototypes for ALL interfaces */

/* end of Additional Prototypes */

#ifdef __cplusplus
}
#endif

#endif
=== C:/Users/treeman/Desktop/windows nt source code\Source\Win2K3\NT\public\internal\ds\inc\keylimit.h ===
/*++

Copyright (C) Microsoft Corporation, 2000

Module Name:

    keylimit

Abstract:

    This header file is tempory.  It should be incorporated into wincrypt.h

Author:

    Doug Barlow (dbarlow) 2/2/2000

Remarks:

    ?Remarks?

Notes:

    ?Notes?

--*/

#ifndef _KEYLIMIT_H_
#define _KEYLIMIT_H_
#ifdef __cplusplus
extern "C" {
#endif


//
// These definitions are private, to be shared between advapi32.dll and
// keylimit.dll.
//

typedef struct {
    ALG_ID algId;
    DWORD  dwMinKeyLength;
    DWORD  dwMaxKeyLength;
    DWORD  dwRequiredFlags;
    DWORD  dwDisallowedFlags;
} KEYLIMIT_LIMITS;

typedef struct {
    DWORD dwCountryValue;
    DWORD dwLanguageValue;
    KEYLIMIT_LIMITS *pLimits;
} KEYLIMIT_LOCALE;

#ifdef __cplusplus
}
#endif
#endif // _KEYLIMIT_H_
=== C:/Users/treeman/Desktop/windows nt source code\Source\Win2K3\NT\public\internal\ds\inc\gpmgmt.h ===
/* this ALWAYS GENERATED file contains the definitions for the interfaces */


 /* File created by MIDL compiler version 6.00.0361 */
/* Compiler settings for gpmgmt.idl:
    Oicf, W1, Zp8, env=Win32 (32b run)
    protocol : dce , ms_ext, c_ext, robust
    error checks: allocation ref bounds_check enum stub_data 
    VC __declspec() decoration level: 
         __declspec(uuid()), __declspec(selectany), __declspec(novtable)
         DECLSPEC_UUID(), MIDL_INTERFACE()
*/
//@@MIDL_FILE_HEADING(  )

#pragma warning( disable: 4049 )  /* more than 64k source lines */


/* verify that the <rpcndr.h> version is high enough to compile this file*/
#ifndef __REQUIRED_RPCNDR_H_VERSION__
#define __REQUIRED_RPCNDR_H_VERSION__ 475
#endif

#include "rpc.h"
#include "rpcndr.h"

#ifndef __RPCNDR_H_VERSION__
#error this stub requires an updated version of <rpcndr.h>
#endif // __RPCNDR_H_VERSION__

#ifndef COM_NO_WINDOWS_H
#include "windows.h"
#include "ole2.h"
#endif /*COM_NO_WINDOWS_H*/

#ifndef __gpmgmt_h__
#define __gpmgmt_h__

#if defined(_MSC_VER) && (_MSC_VER >= 1020)
#pragma once
#endif

/* Forward Declarations */ 

#ifndef __IGPM_FWD_DEFINED__
#define __IGPM_FWD_DEFINED__
typedef interface IGPM IGPM;
#endif 	/* __IGPM_FWD_DEFINED__ */


#ifndef __IGPMDomain_FWD_DEFINED__
#define __IGPMDomain_FWD_DEFINED__
typedef interface IGPMDomain IGPMDomain;
#endif 	/* __IGPMDomain_FWD_DEFINED__ */


#ifndef __IGPMBackupDir_FWD_DEFINED__
#define __IGPMBackupDir_FWD_DEFINED__
typedef interface IGPMBackupDir IGPMBackupDir;
#endif 	/* __IGPMBackupDir_FWD_DEFINED__ */


#ifndef __IGPMSitesContainer_FWD_DEFINED__
#define __IGPMSitesContainer_FWD_DEFINED__
typedef interface IGPMSitesContainer IGPMSitesContainer;
#endif 	/* __IGPMSitesContainer_FWD_DEFINED__ */


#ifndef __IGPMSearchCriteria_FWD_DEFINED__
#define __IGPMSearchCriteria_FWD_DEFINED__
typedef interface IGPMSearchCriteria IGPMSearchCriteria;
#endif 	/* __IGPMSearchCriteria_FWD_DEFINED__ */


#ifndef __IGPMTrustee_FWD_DEFINED__
#define __IGPMTrustee_FWD_DEFINED__
typedef interface IGPMTrustee IGPMTrustee;
#endif 	/* __IGPMTrustee_FWD_DEFINED__ */


#ifndef __IGPMPermission_FWD_DEFINED__
#define __IGPMPermission_FWD_DEFINED__
typedef interface IGPMPermission IGPMPermission;
#endif 	/* __IGPMPermission_FWD_DEFINED__ */


#ifndef __IGPMSecurityInfo_FWD_DEFINED__
#define __IGPMSecurityInfo_FWD_DEFINED__
typedef interface IGPMSecurityInfo IGPMSecurityInfo;
#endif 	/* __IGPMSecurityInfo_FWD_DEFINED__ */


#ifndef __IGPMBackup_FWD_DEFINED__
#define __IGPMBackup_FWD_DEFINED__
typedef interface IGPMBackup IGPMBackup;
#endif 	/* __IGPMBackup_FWD_DEFINED__ */


#ifndef __IGPMBackupCollection_FWD_DEFINED__
#define __IGPMBackupCollection_FWD_DEFINED__
typedef interface IGPMBackupCollection IGPMBackupCollection;
#endif 	/* __IGPMBackupCollection_FWD_DEFINED__ */


#ifndef __IGPMSOM_FWD_DEFINED__
#define __IGPMSOM_FWD_DEFINED__
typedef interface IGPMSOM IGPMSOM;
#endif 	/* __IGPMSOM_FWD_DEFINED__ */


#ifndef __IGPMSOMCollection_FWD_DEFINED__
#define __IGPMSOMCollection_FWD_DEFINED__
typedef interface IGPMSOMCollection IGPMSOMCollection;
#endif 	/* __IGPMSOMCollection_FWD_DEFINED__ */


#ifndef __IGPMWMIFilter_FWD_DEFINED__
#define __IGPMWMIFilter_FWD_DEFINED__
typedef interface IGPMWMIFilter IGPMWMIFilter;
#endif 	/* __IGPMWMIFilter_FWD_DEFINED__ */


#ifndef __IGPMWMIFilterCollection_FWD_DEFINED__
#define __IGPMWMIFilterCollection_FWD_DEFINED__
typedef interface IGPMWMIFilterCollection IGPMWMIFilterCollection;
#endif 	/* __IGPMWMIFilterCollection_FWD_DEFINED__ */


#ifndef __IGPMRSOP_FWD_DEFINED__
#define __IGPMRSOP_FWD_DEFINED__
typedef interface IGPMRSOP IGPMRSOP;
#endif 	/* __IGPMRSOP_FWD_DEFINED__ */


#ifndef __IGPMGPO_FWD_DEFINED__
#define __IGPMGPO_FWD_DEFINED__
typedef interface IGPMGPO IGPMGPO;
#endif 	/* __IGPMGPO_FWD_DEFINED__ */


#ifndef __IGPMGPOCollection_FWD_DEFINED__
#define __IGPMGPOCollection_FWD_DEFINED__
typedef interface IGPMGPOCollection IGPMGPOCollection;
#endif 	/* __IGPMGPOCollection_FWD_DEFINED__ */


#ifndef __IGPMGPOLink_FWD_DEFINED__
#define __IGPMGPOLink_FWD_DEFINED__
typedef interface IGPMGPOLink IGPMGPOLink;
#endif 	/* __IGPMGPOLink_FWD_DEFINED__ */


#ifndef __IGPMGPOLinksCollection_FWD_DEFINED__
#define __IGPMGPOLinksCollection_FWD_DEFINED__
typedef interface IGPMGPOLinksCollection IGPMGPOLinksCollection;
#endif 	/* __IGPMGPOLinksCollection_FWD_DEFINED__ */


#ifndef __IGPMCSECollection_FWD_DEFINED__
#define __IGPMCSECollection_FWD_DEFINED__
typedef interface IGPMCSECollection IGPMCSECollection;
#endif 	/* __IGPMCSECollection_FWD_DEFINED__ */


#ifndef __IGPMClientSideExtension_FWD_DEFINED__
#define __IGPMClientSideExtension_FWD_DEFINED__
typedef interface IGPMClientSideExtension IGPMClientSideExtension;
#endif 	/* __IGPMClientSideExtension_FWD_DEFINED__ */


#ifndef __IGPMAsyncCancel_FWD_DEFINED__
#define __IGPMAsyncCancel_FWD_DEFINED__
typedef interface IGPMAsyncCancel IGPMAsyncCancel;
#endif 	/* __IGPMAsyncCancel_FWD_DEFINED__ */


#ifndef __IGPMAsyncProgress_FWD_DEFINED__
#define __IGPMAsyncProgress_FWD_DEFINED__
typedef interface IGPMAsyncProgress IGPMAsyncProgress;
#endif 	/* __IGPMAsyncProgress_FWD_DEFINED__ */


#ifndef __IGPMStatusMsgCollection_FWD_DEFINED__
#define __IGPMStatusMsgCollection_FWD_DEFINED__
typedef interface IGPMStatusMsgCollection IGPMStatusMsgCollection;
#endif 	/* __IGPMStatusMsgCollection_FWD_DEFINED__ */


#ifndef __IGPMStatusMessage_FWD_DEFINED__
#define __IGPMStatusMessage_FWD_DEFINED__
typedef interface IGPMStatusMessage IGPMStatusMessage;
#endif 	/* __IGPMStatusMessage_FWD_DEFINED__ */


#ifndef __IGPMConstants_FWD_DEFINED__
#define __IGPMConstants_FWD_DEFINED__
typedef interface IGPMConstants IGPMConstants;
#endif 	/* __IGPMConstants_FWD_DEFINED__ */


#ifndef __IGPMResult_FWD_DEFINED__
#define __IGPMResult_FWD_DEFINED__
typedef interface IGPMResult IGPMResult;
#endif 	/* __IGPMResult_FWD_DEFINED__ */


#ifndef __GPM_FWD_DEFINED__
#define __GPM_FWD_DEFINED__

#ifdef __cplusplus
typedef class GPM GPM;
#else
typedef struct GPM GPM;
#endif /* __cplusplus */

#endif 	/* __GPM_FWD_DEFINED__ */


#ifndef __GPMDomain_FWD_DEFINED__
#define __GPMDomain_FWD_DEFINED__

#ifdef __cplusplus
typedef class GPMDomain GPMDomain;
#else
typedef struct GPMDomain GPMDomain;
#endif /* __cplusplus */

#endif 	/* __GPMDomain_FWD_DEFINED__ */


#ifndef __GPMSitesContainer_FWD_DEFINED__
#define __GPMSitesContainer_FWD_DEFINED__

#ifdef __cplusplus
typedef class GPMSitesContainer GPMSitesContainer;
#else
typedef struct GPMSitesContainer GPMSitesContainer;
#endif /* __cplusplus */

#endif 	/* __GPMSitesContainer_FWD_DEFINED__ */


#ifndef __GPMBackupDir_FWD_DEFINED__
#define __GPMBackupDir_FWD_DEFINED__

#ifdef __cplusplus
typedef class GPMBackupDir GPMBackupDir;
#else
typedef struct GPMBackupDir GPMBackupDir;
#endif /* __cplusplus */

#endif 	/* __GPMBackupDir_FWD_DEFINED__ */


#ifndef __GPMSOM_FWD_DEFINED__
#define __GPMSOM_FWD_DEFINED__

#ifdef __cplusplus
typedef class GPMSOM GPMSOM;
#else
typedef struct GPMSOM GPMSOM;
#endif /* __cplusplus */

#endif 	/* __GPMSOM_FWD_DEFINED__ */


#ifndef __GPMSearchCriteria_FWD_DEFINED__
#define __GPMSearchCriteria_FWD_DEFINED__

#ifdef __cplusplus
typedef class GPMSearchCriteria GPMSearchCriteria;
#else
typedef struct GPMSearchCriteria GPMSearchCriteria;
#endif /* __cplusplus */

#endif 	/* __GPMSearchCriteria_FWD_DEFINED__ */


#ifndef __GPMPermission_FWD_DEFINED__
#define __GPMPermission_FWD_DEFINED__

#ifdef __cplusplus
typedef class GPMPermission GPMPermission;
#else
typedef struct GPMPermission GPMPermission;
#endif /* __cplusplus */

#endif 	/* __GPMPermission_FWD_DEFINED__ */


#ifndef __GPMSecurityInfo_FWD_DEFINED__
#define __GPMSecurityInfo_FWD_DEFINED__

#ifdef __cplusplus
typedef class GPMSecurityInfo GPMSecurityInfo;
#else
typedef struct GPMSecurityInfo GPMSecurityInfo;
#endif /* __cplusplus */

#endif 	/* __GPMSecurityInfo_FWD_DEFINED__ */


#ifndef __GPMBackup_FWD_DEFINED__
#define __GPMBackup_FWD_DEFINED__

#ifdef __cplusplus
typedef class GPMBackup GPMBackup;
#else
typedef struct GPMBackup GPMBackup;
#endif /* __cplusplus */

#endif 	/* __GPMBackup_FWD_DEFINED__ */


#ifndef __GPMBackupCollection_FWD_DEFINED__
#define __GPMBackupCollection_FWD_DEFINED__

#ifdef __cplusplus
typedef class GPMBackupCollection GPMBackupCollection;
#else
typedef struct GPMBackupCollection GPMBackupCollection;
#endif /* __cplusplus */

#endif 	/* __GPMBackupCollection_FWD_DEFINED__ */


#ifndef __GPMSOMCollection_FWD_DEFINED__
#define __GPMSOMCollection_FWD_DEFINED__

#ifdef __cplusplus
typedef class GPMSOMCollection GPMSOMCollection;
#else
typedef struct GPMSOMCollection GPMSOMCollection;
#endif /* __cplusplus */

#endif 	/* __GPMSOMCollection_FWD_DEFINED__ */


#ifndef __GPMWMIFilter_FWD_DEFINED__
#define __GPMWMIFilter_FWD_DEFINED__

#ifdef __cplusplus
typedef class GPMWMIFilter GPMWMIFilter;
#else
typedef struct GPMWMIFilter GPMWMIFilter;
#endif /* __cplusplus */

#endif 	/* __GPMWMIFilter_FWD_DEFINED__ */


#ifndef __GPMWMIFilterCollection_FWD_DEFINED__
#define __GPMWMIFilterCollection_FWD_DEFINED__

#ifdef __cplusplus
typedef class GPMWMIFilterCollection GPMWMIFilterCollection;
#else
typedef struct GPMWMIFilterCollection GPMWMIFilterCollection;
#endif /* __cplusplus */

#endif 	/* __GPMWMIFilterCollection_FWD_DEFINED__ */


#ifndef __GPMRSOP_FWD_DEFINED__
#define __GPMRSOP_FWD_DEFINED__

#ifdef __cplusplus
typedef class GPMRSOP GPMRSOP;
#else
typedef struct GPMRSOP GPMRSOP;
#endif /* __cplusplus */

#endif 	/* __GPMRSOP_FWD_DEFINED__ */


#ifndef __GPMGPO_FWD_DEFINED__
#define __GPMGPO_FWD_DEFINED__

#ifdef __cplusplus
typedef class GPMGPO GPMGPO;
#else
typedef struct GPMGPO GPMGPO;
#endif /* __cplusplus */

#endif 	/* __GPMGPO_FWD_DEFINED__ */


#ifndef __GPMGPOCollection_FWD_DEFINED__
#define __GPMGPOCollection_FWD_DEFINED__

#ifdef __cplusplus
typedef class GPMGPOCollection GPMGPOCollection;
#else
typedef struct GPMGPOCollection GPMGPOCollection;
#endif /* __cplusplus */

#endif 	/* __GPMGPOCollection_FWD_DEFINED__ */


#ifndef __GPMGPOLink_FWD_DEFINED__
#define __GPMGPOLink_FWD_DEFINED__

#ifdef __cplusplus
typedef class GPMGPOLink GPMGPOLink;
#else
typedef struct GPMGPOLink GPMGPOLink;
#endif /* __cplusplus */

#endif 	/* __GPMGPOLink_FWD_DEFINED__ */


#ifndef __GPMGPOLinksCollection_FWD_DEFINED__
#define __GPMGPOLinksCollection_FWD_DEFINED__

#ifdef __cplusplus
typedef class GPMGPOLinksCollection GPMGPOLinksCollection;
#else
typedef struct GPMGPOLinksCollection GPMGPOLinksCollection;
#endif /* __cplusplus */

#endif 	/* __GPMGPOLinksCollection_FWD_DEFINED__ */


#ifndef __GPMAsyncCancel_FWD_DEFINED__
#define __GPMAsyncCancel_FWD_DEFINED__

#ifdef __cplusplus
typedef class GPMAsyncCancel GPMAsyncCancel;
#else
typedef struct GPMAsyncCancel GPMAsyncCancel;
#endif /* __cplusplus */

#endif 	/* __GPMAsyncCancel_FWD_DEFINED__ */


#ifndef __GPMStatusMsgCollection_FWD_DEFINED__
#define __GPMStatusMsgCollection_FWD_DEFINED__

#ifdef __cplusplus
typedef class GPMStatusMsgCollection GPMStatusMsgCollection;
#else
typedef struct GPMStatusMsgCollection GPMStatusMsgCollection;
#endif /* __cplusplus */

#endif 	/* __GPMStatusMsgCollection_FWD_DEFINED__ */


#ifndef __GPMStatusMessage_FWD_DEFINED__
#define __GPMStatusMessage_FWD_DEFINED__

#ifdef __cplusplus
typedef class GPMStatusMessage GPMStatusMessage;
#else
typedef struct GPMStatusMessage GPMStatusMessage;
#endif /* __cplusplus */

#endif 	/* __GPMStatusMessage_FWD_DEFINED__ */


#ifndef __GPMEnum_FWD_DEFINED__
#define __GPMEnum_FWD_DEFINED__

#ifdef __cplusplus
typedef class GPMEnum GPMEnum;
#else
typedef struct GPMEnum GPMEnum;
#endif /* __cplusplus */

#endif 	/* __GPMEnum_FWD_DEFINED__ */


#ifndef __GPMTrustee_FWD_DEFINED__
#define __GPMTrustee_FWD_DEFINED__

#ifdef __cplusplus
typedef class GPMTrustee GPMTrustee;
#else
typedef struct GPMTrustee GPMTrustee;
#endif /* __cplusplus */

#endif 	/* __GPMTrustee_FWD_DEFINED__ */


#ifndef __GPMClientSideExtension_FWD_DEFINED__
#define __GPMClientSideExtension_FWD_DEFINED__

#ifdef __cplusplus
typedef class GPMClientSideExtension GPMClientSideExtension;
#else
typedef struct GPMClientSideExtension GPMClientSideExtension;
#endif /* __cplusplus */

#endif 	/* __GPMClientSideExtension_FWD_DEFINED__ */


#ifndef __GPMCSECollection_FWD_DEFINED__
#define __GPMCSECollection_FWD_DEFINED__

#ifdef __cplusplus
typedef class GPMCSECollection GPMCSECollection;
#else
typedef struct GPMCSECollection GPMCSECollection;
#endif /* __cplusplus */

#endif 	/* __GPMCSECollection_FWD_DEFINED__ */


#ifndef __GPMConstants_FWD_DEFINED__
#define __GPMConstants_FWD_DEFINED__

#ifdef __cplusplus
typedef class GPMConstants GPMConstants;
#else
typedef struct GPMConstants GPMConstants;
#endif /* __cplusplus */

#endif 	/* __GPMConstants_FWD_DEFINED__ */


#ifndef __GPMResult_FWD_DEFINED__
#define __GPMResult_FWD_DEFINED__

#ifdef __cplusplus
typedef class GPMResult GPMResult;
#else
typedef struct GPMResult GPMResult;
#endif /* __cplusplus */

#endif 	/* __GPMResult_FWD_DEFINED__ */


#ifndef __GPOReportProvider_FWD_DEFINED__
#define __GPOReportProvider_FWD_DEFINED__

#ifdef __cplusplus
typedef class GPOReportProvider GPOReportProvider;
#else
typedef struct GPOReportProvider GPOReportProvider;
#endif /* __cplusplus */

#endif 	/* __GPOReportProvider_FWD_DEFINED__ */


/* header files for imported files */
#include "oaidl.h"
#include "ocidl.h"

#ifdef __cplusplus
extern "C"{
#endif 

void * __RPC_USER MIDL_user_allocate(size_t);
void __RPC_USER MIDL_user_free( void * ); 

/* interface __MIDL_itf_gpmgmt_0000 */
/* [local] */ 

typedef /* [public][public][public] */ 
enum __MIDL___MIDL_itf_gpmgmt_0000_0001
    {	rsopUnknown	= 0,
	rsopPlanning	= rsopUnknown + 1,
	rsopLogging	= rsopPlanning + 1
    } 	GPMRSOPMode;

typedef /* [public][public][public][public][public][public][public][public][public][public][public][public][public][public][public][public][public] */ 
enum __MIDL___MIDL_itf_gpmgmt_0000_0002
    {	permGPOApply	= 0x10000,
	permGPORead	= 0x10100,
	permGPOEdit	= 0x10101,
	permGPOEditSecurityAndDelete	= 0x10102,
	permGPOCustom	= 0x10103,
	permWMIFilterEdit	= 0x20000,
	permWMIFilterFullControl	= 0x20001,
	permWMIFilterCustom	= 0x20002,
	permSOMLink	= 0x1c0000,
	permSOMLogging	= 0x180100,
	permSOMPlanning	= 0x180200,
	permSOMWMICreate	= 0x100300,
	permSOMWMIFullControl	= 0x100301,
	permSOMGPOCreate	= 0x100400
    } 	GPMPermissionType;

typedef /* [public][public][public][public][public][public][public][public][public][public][public][public] */ 
enum __MIDL___MIDL_itf_gpmgmt_0000_0003
    {	gpoPermissions	= 0,
	gpoEffectivePermissions	= gpoPermissions + 1,
	gpoDisplayName	= gpoEffectivePermissions + 1,
	gpoWMIFilter	= gpoDisplayName + 1,
	gpoID	= gpoWMIFilter + 1,
	gpoComputerExtensions	= gpoID + 1,
	gpoUserExtensions	= gpoComputerExtensions + 1,
	somLinks	= gpoUserExtensions + 1,
	gpoDomain	= somLinks + 1,
	backupMostRecent	= gpoDomain + 1
    } 	GPMSearchProperty;

typedef /* [public][public][public][public][public][public] */ 
enum __MIDL___MIDL_itf_gpmgmt_0000_0004
    {	opEquals	= 0,
	opContains	= opEquals + 1,
	opNotContains	= opContains + 1,
	opNotEquals	= opNotContains + 1
    } 	GPMSearchOperation;

typedef /* [public][public][public][public][public][public] */ 
enum __MIDL___MIDL_itf_gpmgmt_0000_0005
    {	ropGroupsBySID	= 0,
	ropGroupsByName	= ropGroupsBySID + 1,
	ropTranslationTableOnly	= ropGroupsByName + 1
    } 	GPMResolveOption;

typedef /* [public][public][public][public][public][public][public][public][public] */ 
enum __MIDL___MIDL_itf_gpmgmt_0000_0006
    {	repXML	= 0,
	repHTML	= repXML + 1
    } 	GPMReportType;

#define	GPM_USE_PDC	( 0 )

#define	GPM_USE_ANYDC	( 1 )

#define	GPM_USE_ANYDOTNETDC	( 2 )

#define	GPM_DONOT_VALIDATEDC	( 1 )

#define	RSOP_NO_COMPUTER	( 0x10000 )

#define	RSOP_NO_USER	( 0x20000 )

#define	RSOP_PLANNING_ASSUME_SLOW_LINK	( 0x1 )

#define	RSOP_PLANNING_ASSUME_LOOPBACK_MERGE	( 0x2 )

#define	RSOP_PLANNING_ASSUME_LOOPBACK_REPLACE	( 0x4 )

#define	RSOP_PLANNING_ASSUME_USER_WQLFILTER_TRUE	( 0x8 )

#define	RSOP_PLANNING_ASSUME_COMP_WQLFILTER_TRUE	( 0x10 )






























extern RPC_IF_HANDLE __MIDL_itf_gpmgmt_0000_v0_0_c_ifspec;
extern RPC_IF_HANDLE __MIDL_itf_gpmgmt_0000_v0_0_s_ifspec;

#ifndef __IGPM_INTERFACE_DEFINED__
#define __IGPM_INTERFACE_DEFINED__

/* interface IGPM */
/* [unique][helpstring][dual][uuid][object] */ 


EXTERN_C const IID IID_IGPM;

#if defined(__cplusplus) && !defined(CINTERFACE)
    
    MIDL_INTERFACE("F5FAE809-3BD6-4DA9-A65E-17665B41D763")
    IGPM : public IDispatch
    {
    public:
        virtual /* [helpstring][id] */ HRESULT STDMETHODCALLTYPE GetDomain( 
            /* [in] */ BSTR bstrDomain,
            /* [in] */ BSTR bstrDomainController,
            /* [in] */ long lDCFlags,
            /* [retval][out] */ IGPMDomain **pIGPMDomain) = 0;
        
        virtual /* [helpstring][id] */ HRESULT STDMETHODCALLTYPE GetBackupDir( 
            /* [in] */ BSTR bstrBackupDir,
            /* [retval][out] */ IGPMBackupDir **pIGPMBackupDir) = 0;
        
        virtual /* [helpstring][id] */ HRESULT STDMETHODCALLTYPE GetSitesContainer( 
            /* [in] */ BSTR bstrForest,
            /* [in] */ BSTR bstrDomain,
            /* [in] */ BSTR bstrDomainController,
            /* [in] */ long lDCFlags,
            /* [retval][out] */ IGPMSitesContainer **ppIGPMSitesContainer) = 0;
        
        virtual /* [helpstring][id] */ HRESULT STDMETHODCALLTYPE GetRSOP( 
            /* [in] */ GPMRSOPMode gpmRSoPMode,
            /* [in] */ BSTR bstrNamespace,
            /* [in] */ long lFlags,
            /* [retval][out] */ IGPMRSOP **ppIGPMRSOP) = 0;
        
        virtual /* [helpstring][id] */ HRESULT STDMETHODCALLTYPE CreatePermission( 
            /* [in] */ BSTR bstrTrustee,
            /* [in] */ GPMPermissionType perm,
            /* [in] */ VARIANT_BOOL bInheritable,
            /* [retval][out] */ IGPMPermission **ppPerm) = 0;
        
        virtual /* [helpstring][id] */ HRESULT STDMETHODCALLTYPE CreateSearchCriteria( 
            /* [retval][out] */ IGPMSearchCriteria **ppIGPMSearchCriteria) = 0;
        
        virtual /* [helpstring][id] */ HRESULT STDMETHODCALLTYPE CreateTrustee( 
            /* [in] */ BSTR bstrTrustee,
            /* [retval][out] */ IGPMTrustee **ppIGPMTrustee) = 0;
        
        virtual /* [helpstring][id] */ HRESULT STDMETHODCALLTYPE GetClientSideExtensions( 
            /* [retval][out] */ IGPMCSECollection **ppIGPMCSECollection) = 0;
        
        virtual /* [helpstring][id] */ HRESULT STDMETHODCALLTYPE GetConstants( 
            /* [retval][out] */ IGPMConstants **ppIGPMConstants) = 0;
        
    };
    
#else 	/* C style interface */

    typedef struct IGPMVtbl
    {
        BEGIN_INTERFACE
        
        HRESULT ( STDMETHODCALLTYPE *QueryInterface )( 
            IGPM * This,
            /* [in] */ REFIID riid,
            /* [iid_is][out] */ void **ppvObject);
        
        ULONG ( STDMETHODCALLTYPE *AddRef )( 
            IGPM * This);
        
        ULONG ( STDMETHODCALLTYPE *Release )( 
            IGPM * This);
        
        HRESULT ( STDMETHODCALLTYPE *GetTypeInfoCount )( 
            IGPM * This,
            /* [out] */ UINT *pctinfo);
        
        HRESULT ( STDMETHODCALLTYPE *GetTypeInfo )( 
            IGPM * This,
            /* [in] */ UINT iTInfo,
            /* [in] */ LCID lcid,
            /* [out] */ ITypeInfo **ppTInfo);
        
        HRESULT ( STDMETHODCALLTYPE *GetIDsOfNames )( 
            IGPM * This,
            /* [in] */ REFIID riid,
            /* [size_is][in] */ LPOLESTR *rgszNames,
            /* [in] */ UINT cNames,
            /* [in] */ LCID lcid,
            /* [size_is][out] */ DISPID *rgDispId);
        
        /* [local] */ HRESULT ( STDMETHODCALLTYPE *Invoke )( 
            IGPM * This,
            /* [in] */ DISPID dispIdMember,
            /* [in] */ REFIID riid,
            /* [in] */ LCID lcid,
            /* [in] */ WORD wFlags,
            /* [out][in] */ DISPPARAMS *pDispParams,
            /* [out] */ VARIANT *pVarResult,
            /* [out] */ EXCEPINFO *pExcepInfo,
            /* [out] */ UINT *puArgErr);
        
        /* [helpstring][id] */ HRESULT ( STDMETHODCALLTYPE *GetDomain )( 
            IGPM * This,
            /* [in] */ BSTR bstrDomain,
            /* [in] */ BSTR bstrDomainController,
            /* [in] */ long lDCFlags,
            /* [retval][out] */ IGPMDomain **pIGPMDomain);
        
        /* [helpstring][id] */ HRESULT ( STDMETHODCALLTYPE *GetBackupDir )( 
            IGPM * This,
            /* [in] */ BSTR bstrBackupDir,
            /* [retval][out] */ IGPMBackupDir **pIGPMBackupDir);
        
        /* [helpstring][id] */ HRESULT ( STDMETHODCALLTYPE *GetSitesContainer )( 
            IGPM * This,
            /* [in] */ BSTR bstrForest,
            /* [in] */ BSTR bstrDomain,
            /* [in] */ BSTR bstrDomainController,
            /* [in] */ long lDCFlags,
            /* [retval][out] */ IGPMSitesContainer **ppIGPMSitesContainer);
        
        /* [helpstring][id] */ HRESULT ( STDMETHODCALLTYPE *GetRSOP )( 
            IGPM * This,
            /* [in] */ GPMRSOPMode gpmRSoPMode,
            /* [in] */ BSTR bstrNamespace,
            /* [in] */ long lFlags,
            /* [retval][out] */ IGPMRSOP **ppIGPMRSOP);
        
        /* [helpstring][id] */ HRESULT ( STDMETHODCALLTYPE *CreatePermission )( 
            IGPM * This,
            /* [in] */ BSTR bstrTrustee,
            /* [in] */ GPMPermissionType perm,
            /* [in] */ VARIANT_BOOL bInheritable,
            /* [retval][out] */ IGPMPermission **ppPerm);
        
        /* [helpstring][id] */ HRESULT ( STDMETHODCALLTYPE *CreateSearchCriteria )( 
            IGPM * This,
            /* [retval][out] */ IGPMSearchCriteria **ppIGPMSearchCriteria);
        
        /* [helpstring][id] */ HRESULT ( STDMETHODCALLTYPE *CreateTrustee )( 
            IGPM * This,
            /* [in] */ BSTR bstrTrustee,
            /* [retval][out] */ IGPMTrustee **ppIGPMTrustee);
        
        /* [helpstring][id] */ HRESULT ( STDMETHODCALLTYPE *GetClientSideExtensions )( 
            IGPM * This,
            /* [retval][out] */ IGPMCSECollection **ppIGPMCSECollection);
        
        /* [helpstring][id] */ HRESULT ( STDMETHODCALLTYPE *GetConstants )( 
            IGPM * This,
            /* [retval][out] */ IGPMConstants **ppIGPMConstants);
        
        END_INTERFACE
    } IGPMVtbl;

    interface IGPM
    {
        CONST_VTBL struct IGPMVtbl *lpVtbl;
    };

    

#ifdef COBJMACROS


#define IGPM_QueryInterface(This,riid,ppvObject)	\
    (This)->lpVtbl -> QueryInterface(This,riid,ppvObject)

#define IGPM_AddRef(This)	\
    (This)->lpVtbl -> AddRef(This)

#define IGPM_Release(This)	\
    (This)->lpVtbl -> Release(This)


#define IGPM_GetTypeInfoCount(This,pctinfo)	\
    (This)->lpVtbl -> GetTypeInfoCount(This,pctinfo)

#define IGPM_GetTypeInfo(This,iTInfo,lcid,ppTInfo)	\
    (This)->lpVtbl -> GetTypeInfo(This,iTInfo,lcid,ppTInfo)

#define IGPM_GetIDsOfNames(This,riid,rgszNames,cNames,lcid,rgDispId)	\
    (This)->lpVtbl -> GetIDsOfNames(This,riid,rgszNames,cNames,lcid,rgDispId)

#define IGPM_Invoke(This,dispIdMember,riid,lcid,wFlags,pDispParams,pVarResult,pExcepInfo,puArgErr)	\
    (This)->lpVtbl -> Invoke(This,dispIdMember,riid,lcid,wFlags,pDispParams,pVarResult,pExcepInfo,puArgErr)


#define IGPM_GetDomain(This,bstrDomain,bstrDomainController,lDCFlags,pIGPMDomain)	\
    (This)->lpVtbl -> GetDomain(This,bstrDomain,bstrDomainController,lDCFlags,pIGPMDomain)

#define IGPM_GetBackupDir(This,bstrBackupDir,pIGPMBackupDir)	\
    (This)->lpVtbl -> GetBackupDir(This,bstrBackupDir,pIGPMBackupDir)

#define IGPM_GetSitesContainer(This,bstrForest,bstrDomain,bstrDomainController,lDCFlags,ppIGPMSitesContainer)	\
    (This)->lpVtbl -> GetSitesContainer(This,bstrForest,bstrDomain,bstrDomainController,lDCFlags,ppIGPMSitesContainer)

#define IGPM_GetRSOP(This,gpmRSoPMode,bstrNamespace,lFlags,ppIGPMRSOP)	\
    (This)->lpVtbl -> GetRSOP(This,gpmRSoPMode,bstrNamespace,lFlags,ppIGPMRSOP)

#define IGPM_CreatePermission(This,bstrTrustee,perm,bInheritable,ppPerm)	\
    (This)->lpVtbl -> CreatePermission(This,bstrTrustee,perm,bInheritable,ppPerm)

#define IGPM_CreateSearchCriteria(This,ppIGPMSearchCriteria)	\
    (This)->lpVtbl -> CreateSearchCriteria(This,ppIGPMSearchCriteria)

#define IGPM_CreateTrustee(This,bstrTrustee,ppIGPMTrustee)	\
    (This)->lpVtbl -> CreateTrustee(This,bstrTrustee,ppIGPMTrustee)

#define IGPM_GetClientSideExtensions(This,ppIGPMCSECollection)	\
    (This)->lpVtbl -> GetClientSideExtensions(This,ppIGPMCSECollection)

#define IGPM_GetConstants(This,ppIGPMConstants)	\
    (This)->lpVtbl -> GetConstants(This,ppIGPMConstants)

#endif /* COBJMACROS */


#endif 	/* C style interface */



/* [helpstring][id] */ HRESULT STDMETHODCALLTYPE IGPM_GetDomain_Proxy( 
    IGPM * This,
    /* [in] */ BSTR bstrDomain,
    /* [in] */ BSTR bstrDomainController,
    /* [in] */ long lDCFlags,
    /* [retval][out] */ IGPMDomain **pIGPMDomain);


void __RPC_STUB IGPM_GetDomain_Stub(
    IRpcStubBuffer *This,
    IRpcChannelBuffer *_pRpcChannelBuffer,
    PRPC_MESSAGE _pRpcMessage,
    DWORD *_pdwStubPhase);


/* [helpstring][id] */ HRESULT STDMETHODCALLTYPE IGPM_GetBackupDir_Proxy( 
    IGPM * This,
    /* [in] */ BSTR bstrBackupDir,
    /* [retval][out] */ IGPMBackupDir **pIGPMBackupDir);


void __RPC_STUB IGPM_GetBackupDir_Stub(
    IRpcStubBuffer *This,
    IRpcChannelBuffer *_pRpcChannelBuffer,
    PRPC_MESSAGE _pRpcMessage,
    DWORD *_pdwStubPhase);


/* [helpstring][id] */ HRESULT STDMETHODCALLTYPE IGPM_GetSitesContainer_Proxy( 
    IGPM * This,
    /* [in] */ BSTR bstrForest,
    /* [in] */ BSTR bstrDomain,
    /* [in] */ BSTR bstrDomainController,
    /* [in] */ long lDCFlags,
    /* [retval][out] */ IGPMSitesContainer **ppIGPMSitesContainer);


void __RPC_STUB IGPM_GetSitesContainer_Stub(
    IRpcStubBuffer *This,
    IRpcChannelBuffer *_pRpcChannelBuffer,
    PRPC_MESSAGE _pRpcMessage,
    DWORD *_pdwStubPhase);


/* [helpstring][id] */ HRESULT STDMETHODCALLTYPE IGPM_GetRSOP_Proxy( 
    IGPM * This,
    /* [in] */ GPMRSOPMode gpmRSoPMode,
    /* [in] */ BSTR bstrNamespace,
    /* [in] */ long lFlags,
    /* [retval][out] */ IGPMRSOP **ppIGPMRSOP);


void __RPC_STUB IGPM_GetRSOP_Stub(
    IRpcStubBuffer *This,
    IRpcChannelBuffer *_pRpcChannelBuffer,
    PRPC_MESSAGE _pRpcMessage,
    DWORD *_pdwStubPhase);


/* [helpstring][id] */ HRESULT STDMETHODCALLTYPE IGPM_CreatePermission_Proxy( 
    IGPM * This,
    /* [in] */ BSTR bstrTrustee,
    /* [in] */ GPMPermissionType perm,
    /* [in] */ VARIANT_BOOL bInheritable,
    /* [retval][out] */ IGPMPermission **ppPerm);


void __RPC_STUB IGPM_CreatePermission_Stub(
    IRpcStubBuffer *This,
    IRpcChannelBuffer *_pRpcChannelBuffer,
    PRPC_MESSAGE _pRpcMessage,
    DWORD *_pdwStubPhase);


/* [helpstring][id] */ HRESULT STDMETHODCALLTYPE IGPM_CreateSearchCriteria_Proxy( 
    IGPM * This,
    /* [retval][out] */ IGPMSearchCriteria **ppIGPMSearchCriteria);


void __RPC_STUB IGPM_CreateSearchCriteria_Stub(
    IRpcStubBuffer *This,
    IRpcChannelBuffer *_pRpcChannelBuffer,
    PRPC_MESSAGE _pRpcMessage,
    DWORD *_pdwStubPhase);


/* [helpstring][id] */ HRESULT STDMETHODCALLTYPE IGPM_CreateTrustee_Proxy( 
    IGPM * This,
    /* [in] */ BSTR bstrTrustee,
    /* [retval][out] */ IGPMTrustee **ppIGPMTrustee);


void __RPC_STUB IGPM_CreateTrustee_Stub(
    IRpcStubBuffer *This,
    IRpcChannelBuffer *_pRpcChannelBuffer,
    PRPC_MESSAGE _pRpcMessage,
    DWORD *_pdwStubPhase);


/* [helpstring][id] */ HRESULT STDMETHODCALLTYPE IGPM_GetClientSideExtensions_Proxy( 
    IGPM * This,
    /* [retval][out] */ IGPMCSECollection **ppIGPMCSECollection);


void __RPC_STUB IGPM_GetClientSideExtensions_Stub(
    IRpcStubBuffer *This,
    IRpcChannelBuffer *_pRpcChannelBuffer,
    PRPC_MESSAGE _pRpcMessage,
    DWORD *_pdwStubPhase);


/* [helpstring][id] */ HRESULT STDMETHODCALLTYPE IGPM_GetConstants_Proxy( 
    IGPM * This,
    /* [retval][out] */ IGPMConstants **ppIGPMConstants);


void __RPC_STUB IGPM_GetConstants_Stub(
    IRpcStubBuffer *This,
    IRpcChannelBuffer *_pRpcChannelBuffer,
    PRPC_MESSAGE _pRpcMessage,
    DWORD *_pdwStubPhase);



#endif 	/* __IGPM_INTERFACE_DEFINED__ */


#ifndef __IGPMDomain_INTERFACE_DEFINED__
#define __IGPMDomain_INTERFACE_DEFINED__

/* interface IGPMDomain */
/* [unique][helpstring][dual][uuid][object] */ 


EXTERN_C const IID IID_IGPMDomain;

#if defined(__cplusplus) && !defined(CINTERFACE)
    
    MIDL_INTERFACE("6B21CC14-5A00-4F44-A738-FEEC8A94C7E3")
    IGPMDomain : public IDispatch
    {
    public:
        virtual /* [helpstring][id][propget] */ HRESULT STDMETHODCALLTYPE get_DomainController( 
            /* [retval][out] */ BSTR *pVal) = 0;
        
        virtual /* [helpstring][id][propget] */ HRESULT STDMETHODCALLTYPE get_Domain( 
            /* [retval][out] */ BSTR *pVal) = 0;
        
        virtual /* [helpstring][id] */ HRESULT STDMETHODCALLTYPE CreateGPO( 
            /* [retval][out] */ IGPMGPO **ppNewGPO) = 0;
        
        virtual /* [helpstring][id] */ HRESULT STDMETHODCALLTYPE GetGPO( 
            /* [in] */ BSTR bstrGuid,
            /* [retval][out] */ IGPMGPO **ppGPO) = 0;
        
        virtual /* [helpstring][id] */ HRESULT STDMETHODCALLTYPE SearchGPOs( 
            /* [in] */ IGPMSearchCriteria *pIGPMSearchCriteria,
            /* [retval][out] */ IGPMGPOCollection **ppIGPMGPOCollection) = 0;
        
        virtual /* [helpstring][id] */ HRESULT STDMETHODCALLTYPE RestoreGPO( 
            /* [in] */ IGPMBackup *pIGPMBackup,
            /* [in] */ long lDCFlags,
            /* [optional][in] */ VARIANT *pvarGPMProgress,
            /* [optional][out] */ VARIANT *pvarGPMCancel,
            /* [retval][out] */ IGPMResult **ppIGPMResult) = 0;
        
        virtual /* [helpstring][id] */ HRESULT STDMETHODCALLTYPE GetSOM( 
            /* [in] */ BSTR bstrPath,
            /* [retval][out] */ IGPMSOM **ppSOM) = 0;
        
        virtual /* [helpstring][id] */ HRESULT STDMETHODCALLTYPE SearchSOMs( 
            /* [in] */ IGPMSearchCriteria *pIGPMSearchCriteria,
            /* [retval][out] */ IGPMSOMCollection **ppIGPMSOMCollection) = 0;
        
        virtual /* [helpstring][id] */ HRESULT STDMETHODCALLTYPE GetWMIFilter( 
            /* [in] */ BSTR bstrPath,
            /* [retval][out] */ IGPMWMIFilter **ppWMIFilter) = 0;
        
        virtual /* [helpstring][id] */ HRESULT STDMETHODCALLTYPE SearchWMIFilters( 
            /* [in] */ IGPMSearchCriteria *pIGPMSearchCriteria,
            /* [retval][out] */ IGPMWMIFilterCollection **ppIGPMWMIFilterCollection) = 0;
        
    };
    
#else 	/* C style interface */

    typedef struct IGPMDomainVtbl
    {
        BEGIN_INTERFACE
        
        HRESULT ( STDMETHODCALLTYPE *QueryInterface )( 
            IGPMDomain * This,
            /* [in] */ REFIID riid,
            /* [iid_is][out] */ void **ppvObject);
        
        ULONG ( STDMETHODCALLTYPE *AddRef )( 
            IGPMDomain * This);
        
        ULONG ( STDMETHODCALLTYPE *Release )( 
            IGPMDomain * This);
        
        HRESULT ( STDMETHODCALLTYPE *GetTypeInfoCount )( 
            IGPMDomain * This,
            /* [out] */ UINT *pctinfo);
        
        HRESULT ( STDMETHODCALLTYPE *GetTypeInfo )( 
            IGPMDomain * This,
            /* [in] */ UINT iTInfo,
            /* [in] */ LCID lcid,
            /* [out] */ ITypeInfo **ppTInfo);
        
        HRESULT ( STDMETHODCALLTYPE *GetIDsOfNames )( 
            IGPMDomain * This,
            /* [in] */ REFIID riid,
            /* [size_is][in] */ LPOLESTR *rgszNames,
            /* [in] */ UINT cNames,
            /* [in] */ LCID lcid,
            /* [size_is][out] */ DISPID *rgDispId);
        
        /* [local] */ HRESULT ( STDMETHODCALLTYPE *Invoke )( 
            IGPMDomain * This,
            /* [in] */ DISPID dispIdMember,
            /* [in] */ REFIID riid,
            /* [in] */ LCID lcid,
            /* [in] */ WORD wFlags,
            /* [out][in] */ DISPPARAMS *pDispParams,
            /* [out] */ VARIANT *pVarResult,
            /* [out] */ EXCEPINFO *pExcepInfo,
            /* [out] */ UINT *puArgErr);
        
        /* [helpstring][id][propget] */ HRESULT ( STDMETHODCALLTYPE *get_DomainController )( 
            IGPMDomain * This,
            /* [retval][out] */ BSTR *pVal);
        
        /* [helpstring][id][propget] */ HRESULT ( STDMETHODCALLTYPE *get_Domain )( 
            IGPMDomain * This,
            /* [retval][out] */ BSTR *pVal);
        
        /* [helpstring][id] */ HRESULT ( STDMETHODCALLTYPE *CreateGPO )( 
            IGPMDomain * This,
            /* [retval][out] */ IGPMGPO **ppNewGPO);
        
        /* [helpstring][id] */ HRESULT ( STDMETHODCALLTYPE *GetGPO )( 
            IGPMDomain * This,
            /* [in] */ BSTR bstrGuid,
            /* [retval][out] */ IGPMGPO **ppGPO);
        
        /* [helpstring][id] */ HRESULT ( STDMETHODCALLTYPE *SearchGPOs )( 
            IGPMDomain * This,
            /* [in] */ IGPMSearchCriteria *pIGPMSearchCriteria,
            /* [retval][out] */ IGPMGPOCollection **ppIGPMGPOCollection);
        
        /* [helpstring][id] */ HRESULT ( STDMETHODCALLTYPE *RestoreGPO )( 
            IGPMDomain * This,
            /* [in] */ IGPMBackup *pIGPMBackup,
            /* [in] */ long lDCFlags,
            /* [optional][in] */ VARIANT *pvarGPMProgress,
            /* [optional][out] */ VARIANT *pvarGPMCancel,
            /* [retval][out] */ IGPMResult **ppIGPMResult);
        
        /* [helpstring][id] */ HRESULT ( STDMETHODCALLTYPE *GetSOM )( 
            IGPMDomain * This,
            /* [in] */ BSTR bstrPath,
            /* [retval][out] */ IGPMSOM **ppSOM);
        
        /* [helpstring][id] */ HRESULT ( STDMETHODCALLTYPE *SearchSOMs )( 
            IGPMDomain * This,
            /* [in] */ IGPMSearchCriteria *pIGPMSearchCriteria,
            /* [retval][out] */ IGPMSOMCollection **ppIGPMSOMCollection);
        
        /* [helpstring][id] */ HRESULT ( STDMETHODCALLTYPE *GetWMIFilter )( 
            IGPMDomain * This,
            /* [in] */ BSTR bstrPath,
            /* [retval][out] */ IGPMWMIFilter **ppWMIFilter);
        
        /* [helpstring][id] */ HRESULT ( STDMETHODCALLTYPE *SearchWMIFilters )( 
            IGPMDomain * This,
            /* [in] */ IGPMSearchCriteria *pIGPMSearchCriteria,
            /* [retval][out] */ IGPMWMIFilterCollection **ppIGPMWMIFilterCollection);
        
        END_INTERFACE
    } IGPMDomainVtbl;

    interface IGPMDomain
    {
        CONST_VTBL struct IGPMDomainVtbl *lpVtbl;
    };

    

#ifdef COBJMACROS


#define IGPMDomain_QueryInterface(This,riid,ppvObject)	\
    (This)->lpVtbl -> QueryInterface(This,riid,ppvObject)

#define IGPMDomain_AddRef(This)	\
    (This)->lpVtbl -> AddRef(This)

#define IGPMDomain_Release(This)	\
    (This)->lpVtbl -> Release(This)


#define IGPMDomain_GetTypeInfoCount(This,pctinfo)	\
    (This)->lpVtbl -> GetTypeInfoCount(This,pctinfo)

#define IGPMDomain_GetTypeInfo(This,iTInfo,lcid,ppTInfo)	\
    (This)->lpVtbl -> GetTypeInfo(This,iTInfo,lcid,ppTInfo)

#define IGPMDomain_GetIDsOfNames(This,riid,rgszNames,cNames,lcid,rgDispId)	\
    (This)->lpVtbl -> GetIDsOfNames(This,riid,rgszNames,cNames,lcid,rgDispId)

#define IGPMDomain_Invoke(This,dispIdMember,riid,lcid,wFlags,pDispParams,pVarResult,pExcepInfo,puArgErr)	\
    (This)->lpVtbl -> Invoke(This,dispIdMember,riid,lcid,wFlags,pDispParams,pVarResult,pExcepInfo,puArgErr)


#define IGPMDomain_get_DomainController(This,pVal)	\
    (This)->lpVtbl -> get_DomainController(This,pVal)

#define IGPMDomain_get_Domain(This,pVal)	\
    (This)->lpVtbl -> get_Domain(This,pVal)

#define IGPMDomain_CreateGPO(This,ppNewGPO)	\
    (This)->lpVtbl -> CreateGPO(This,ppNewGPO)

#define IGPMDomain_GetGPO(This,bstrGuid,ppGPO)	\
    (This)->lpVtbl -> GetGPO(This,bstrGuid,ppGPO)

#define IGPMDomain_SearchGPOs(This,pIGPMSearchCriteria,ppIGPMGPOCollection)	\
    (This)->lpVtbl -> SearchGPOs(This,pIGPMSearchCriteria,ppIGPMGPOCollection)

#define IGPMDomain_RestoreGPO(This,pIGPMBackup,lDCFlags,pvarGPMProgress,pvarGPMCancel,ppIGPMResult)	\
    (This)->lpVtbl -> RestoreGPO(This,pIGPMBackup,lDCFlags,pvarGPMProgress,pvarGPMCancel,ppIGPMResult)

#define IGPMDomain_GetSOM(This,bstrPath,ppSOM)	\
    (This)->lpVtbl -> GetSOM(This,bstrPath,ppSOM)

#define IGPMDomain_SearchSOMs(This,pIGPMSearchCriteria,ppIGPMSOMCollection)	\
    (This)->lpVtbl -> SearchSOMs(This,pIGPMSearchCriteria,ppIGPMSOMCollection)

#define IGPMDomain_GetWMIFilter(This,bstrPath,ppWMIFilter)	\
    (This)->lpVtbl -> GetWMIFilter(This,bstrPath,ppWMIFilter)

#define IGPMDomain_SearchWMIFilters(This,pIGPMSearchCriteria,ppIGPMWMIFilterCollection)	\
    (This)->lpVtbl -> SearchWMIFilters(This,pIGPMSearchCriteria,ppIGPMWMIFilterCollection)

#endif /* COBJMACROS */


#endif 	/* C style interface */



/* [helpstring][id][propget] */ HRESULT STDMETHODCALLTYPE IGPMDomain_get_DomainController_Proxy( 
    IGPMDomain * This,
    /* [retval][out] */ BSTR *pVal);


void __RPC_STUB IGPMDomain_get_DomainController_Stub(
    IRpcStubBuffer *This,
    IRpcChannelBuffer *_pRpcChannelBuffer,
    PRPC_MESSAGE _pRpcMessage,
    DWORD *_pdwStubPhase);


/* [helpstring][id][propget] */ HRESULT STDMETHODCALLTYPE IGPMDomain_get_Domain_Proxy( 
    IGPMDomain * This,
    /* [retval][out] */ BSTR *pVal);


void __RPC_STUB IGPMDomain_get_Domain_Stub(
    IRpcStubBuffer *This,
    IRpcChannelBuffer *_pRpcChannelBuffer,
    PRPC_MESSAGE _pRpcMessage,
    DWORD *_pdwStubPhase);


/* [helpstring][id] */ HRESULT STDMETHODCALLTYPE IGPMDomain_CreateGPO_Proxy( 
    IGPMDomain * This,
    /* [retval][out] */ IGPMGPO **ppNewGPO);


void __RPC_STUB IGPMDomain_CreateGPO_Stub(
    IRpcStubBuffer *This,
    IRpcChannelBuffer *_pRpcChannelBuffer,
    PRPC_MESSAGE _pRpcMessage,
    DWORD *_pdwStubPhase);


/* [helpstring][id] */ HRESULT STDMETHODCALLTYPE IGPMDomain_GetGPO_Proxy( 
    IGPMDomain * This,
    /* [in] */ BSTR bstrGuid,
    /* [retval][out] */ IGPMGPO **ppGPO);


void __RPC_STUB IGPMDomain_GetGPO_Stub(
    IRpcStubBuffer *This,
    IRpcChannelBuffer *_pRpcChannelBuffer,
    PRPC_MESSAGE _pRpcMessage,
    DWORD *_pdwStubPhase);


/* [helpstring][id] */ HRESULT STDMETHODCALLTYPE IGPMDomain_SearchGPOs_Proxy( 
    IGPMDomain * This,
    /* [in] */ IGPMSearchCriteria *pIGPMSearchCriteria,
    /* [retval][out] */ IGPMGPOCollection **ppIGPMGPOCollection);


void __RPC_STUB IGPMDomain_SearchGPOs_Stub(
    IRpcStubBuffer *This,
    IRpcChannelBuffer *_pRpcChannelBuffer,
    PRPC_MESSAGE _pRpcMessage,
    DWORD *_pdwStubPhase);


/* [helpstring][id] */ HRESULT STDMETHODCALLTYPE IGPMDomain_RestoreGPO_Proxy( 
    IGPMDomain * This,
    /* [in] */ IGPMBackup *pIGPMBackup,
    /* [in] */ long lDCFlags,
    /* [optional][in] */ VARIANT *pvarGPMProgress,
    /* [optional][out] */ VARIANT *pvarGPMCancel,
    /* [retval][out] */ IGPMResult **ppIGPMResult);


void __RPC_STUB IGPMDomain_RestoreGPO_Stub(
    IRpcStubBuffer *This,
    IRpcChannelBuffer *_pRpcChannelBuffer,
    PRPC_MESSAGE _pRpcMessage,
    DWORD *_pdwStubPhase);


/* [helpstring][id] */ HRESULT STDMETHODCALLTYPE IGPMDomain_GetSOM_Proxy( 
    IGPMDomain * This,
    /* [in] */ BSTR bstrPath,
    /* [retval][out] */ IGPMSOM **ppSOM);


void __RPC_STUB IGPMDomain_GetSOM_Stub(
    IRpcStubBuffer *This,
    IRpcChannelBuffer *_pRpcChannelBuffer,
    PRPC_MESSAGE _pRpcMessage,
    DWORD *_pdwStubPhase);


/* [helpstring][id] */ HRESULT STDMETHODCALLTYPE IGPMDomain_SearchSOMs_Proxy( 
    IGPMDomain * This,
    /* [in] */ IGPMSearchCriteria *pIGPMSearchCriteria,
    /* [retval][out] */ IGPMSOMCollection **ppIGPMSOMCollection);


void __RPC_STUB IGPMDomain_SearchSOMs_Stub(
    IRpcStubBuffer *This,
    IRpcChannelBuffer *_pRpcChannelBuffer,
    PRPC_MESSAGE _pRpcMessage,
    DWORD *_pdwStubPhase);


/* [helpstring][id] */ HRESULT STDMETHODCALLTYPE IGPMDomain_GetWMIFilter_Proxy( 
    IGPMDomain * This,
    /* [in] */ BSTR bstrPath,
    /* [retval][out] */ IGPMWMIFilter **ppWMIFilter);


void __RPC_STUB IGPMDomain_GetWMIFilter_Stub(
    IRpcStubBuffer *This,
    IRpcChannelBuffer *_pRpcChannelBuffer,
    PRPC_MESSAGE _pRpcMessage,
    DWORD *_pdwStubPhase);


/* [helpstring][id] */ HRESULT STDMETHODCALLTYPE IGPMDomain_SearchWMIFilters_Proxy( 
    IGPMDomain * This,
    /* [in] */ IGPMSearchCriteria *pIGPMSearchCriteria,
    /* [retval][out] */ IGPMWMIFilterCollection **ppIGPMWMIFilterCollection);


void __RPC_STUB IGPMDomain_SearchWMIFilters_Stub(
    IRpcStubBuffer *This,
    IRpcChannelBuffer *_pRpcChannelBuffer,
    PRPC_MESSAGE _pRpcMessage,
    DWORD *_pdwStubPhase);



#endif 	/* __IGPMDomain_INTERFACE_DEFINED__ */


#ifndef __IGPMBackupDir_INTERFACE_DEFINED__
#define __IGPMBackupDir_INTERFACE_DEFINED__

/* interface IGPMBackupDir */
/* [unique][helpstring][dual][uuid][object] */ 


EXTERN_C const IID IID_IGPMBackupDir;

#if defined(__cplusplus) && !defined(CINTERFACE)
    
    MIDL_INTERFACE("B1568BED-0A93-4ACC-810F-AFE7081019B9")
    IGPMBackupDir : public IDispatch
    {
    public:
        virtual /* [helpstring][id][propget] */ HRESULT STDMETHODCALLTYPE get_BackupDirectory( 
            /* [retval][out] */ BSTR *pVal) = 0;
        
        virtual /* [helpstring][id] */ HRESULT STDMETHODCALLTYPE GetBackup( 
            /* [in] */ BSTR bstrID,
            /* [retval][out] */ IGPMBackup **ppBackup) = 0;
        
        virtual /* [helpstring][id] */ HRESULT STDMETHODCALLTYPE SearchBackups( 
            /* [in] */ IGPMSearchCriteria *pIGPMSearchCriteria,
            /* [retval][out] */ IGPMBackupCollection **ppIGPMBackupCollection) = 0;
        
    };
    
#else 	/* C style interface */

    typedef struct IGPMBackupDirVtbl
    {
        BEGIN_INTERFACE
        
        HRESULT ( STDMETHODCALLTYPE *QueryInterface )( 
            IGPMBackupDir * This,
            /* [in] */ REFIID riid,
            /* [iid_is][out] */ void **ppvObject);
        
        ULONG ( STDMETHODCALLTYPE *AddRef )( 
            IGPMBackupDir * This);
        
        ULONG ( STDMETHODCALLTYPE *Release )( 
            IGPMBackupDir * This);
        
        HRESULT ( STDMETHODCALLTYPE *GetTypeInfoCount )( 
            IGPMBackupDir * This,
            /* [out] */ UINT *pctinfo);
        
        HRESULT ( STDMETHODCALLTYPE *GetTypeInfo )( 
            IGPMBackupDir * This,
            /* [in] */ UINT iTInfo,
            /* [in] */ LCID lcid,
            /* [out] */ ITypeInfo **ppTInfo);
        
        HRESULT ( STDMETHODCALLTYPE *GetIDsOfNames )( 
            IGPMBackupDir * This,
            /* [in] */ REFIID riid,
            /* [size_is][in] */ LPOLESTR *rgszNames,
            /* [in] */ UINT cNames,
            /* [in] */ LCID lcid,
            /* [size_is][out] */ DISPID *rgDispId);
        
        /* [local] */ HRESULT ( STDMETHODCALLTYPE *Invoke )( 
            IGPMBackupDir * This,
            /* [in] */ DISPID dispIdMember,
            /* [in] */ REFIID riid,
            /* [in] */ LCID lcid,
            /* [in] */ WORD wFlags,
            /* [out][in] */ DISPPARAMS *pDispParams,
            /* [out] */ VARIANT *pVarResult,
            /* [out] */ EXCEPINFO *pExcepInfo,
            /* [out] */ UINT *puArgErr);
        
        /* [helpstring][id][propget] */ HRESULT ( STDMETHODCALLTYPE *get_BackupDirectory )( 
            IGPMBackupDir * This,
            /* [retval][out] */ BSTR *pVal);
        
        /* [helpstring][id] */ HRESULT ( STDMETHODCALLTYPE *GetBackup )( 
            IGPMBackupDir * This,
            /* [in] */ BSTR bstrID,
            /* [retval][out] */ IGPMBackup **ppBackup);
        
        /* [helpstring][id] */ HRESULT ( STDMETHODCALLTYPE *SearchBackups )( 
            IGPMBackupDir * This,
            /* [in] */ IGPMSearchCriteria *pIGPMSearchCriteria,
            /* [retval][out] */ IGPMBackupCollection **ppIGPMBackupCollection);
        
        END_INTERFACE
    } IGPMBackupDirVtbl;

    interface IGPMBackupDir
    {
        CONST_VTBL struct IGPMBackupDirVtbl *lpVtbl;
    };

    

#ifdef COBJMACROS


#define IGPMBackupDir_QueryInterface(This,riid,ppvObject)	\
    (This)->lpVtbl -> QueryInterface(This,riid,ppvObject)

#define IGPMBackupDir_AddRef(This)	\
    (This)->lpVtbl -> AddRef(This)

#define IGPMBackupDir_Release(This)	\
    (This)->lpVtbl -> Release(This)


#define IGPMBackupDir_GetTypeInfoCount(This,pctinfo)	\
    (This)->lpVtbl -> GetTypeInfoCount(This,pctinfo)

#define IGPMBackupDir_GetTypeInfo(This,iTInfo,lcid,ppTInfo)	\
    (This)->lpVtbl -> GetTypeInfo(This,iTInfo,lcid,ppTInfo)

#define IGPMBackupDir_GetIDsOfNames(This,riid,rgszNames,cNames,lcid,rgDispId)	\
    (This)->lpVtbl -> GetIDsOfNames(This,riid,rgszNames,cNames,lcid,rgDispId)

#define IGPMBackupDir_Invoke(This,dispIdMember,riid,lcid,wFlags,pDispParams,pVarResult,pExcepInfo,puArgErr)	\
    (This)->lpVtbl -> Invoke(This,dispIdMember,riid,lcid,wFlags,pDispParams,pVarResult,pExcepInfo,puArgErr)


#define IGPMBackupDir_get_BackupDirectory(This,pVal)	\
    (This)->lpVtbl -> get_BackupDirectory(This,pVal)

#define IGPMBackupDir_GetBackup(This,bstrID,ppBackup)	\
    (This)->lpVtbl -> GetBackup(This,bstrID,ppBackup)

#define IGPMBackupDir_SearchBackups(This,pIGPMSearchCriteria,ppIGPMBackupCollection)	\
    (This)->lpVtbl -> SearchBackups(This,pIGPMSearchCriteria,ppIGPMBackupCollection)

#endif /* COBJMACROS */


#endif 	/* C style interface */



/* [helpstring][id][propget] */ HRESULT STDMETHODCALLTYPE IGPMBackupDir_get_BackupDirectory_Proxy( 
    IGPMBackupDir * This,
    /* [retval][out] */ BSTR *pVal);


void __RPC_STUB IGPMBackupDir_get_BackupDirectory_Stub(
    IRpcStubBuffer *This,
    IRpcChannelBuffer *_pRpcChannelBuffer,
    PRPC_MESSAGE _pRpcMessage,
    DWORD *_pdwStubPhase);


/* [helpstring][id] */ HRESULT STDMETHODCALLTYPE IGPMBackupDir_GetBackup_Proxy( 
    IGPMBackupDir * This,
    /* [in] */ BSTR bstrID,
    /* [retval][out] */ IGPMBackup **ppBackup);


void __RPC_STUB IGPMBackupDir_GetBackup_Stub(
    IRpcStubBuffer *This,
    IRpcChannelBuffer *_pRpcChannelBuffer,
    PRPC_MESSAGE _pRpcMessage,
    DWORD *_pdwStubPhase);


/* [helpstring][id] */ HRESULT STDMETHODCALLTYPE IGPMBackupDir_SearchBackups_Proxy( 
    IGPMBackupDir * This,
    /* [in] */ IGPMSearchCriteria *pIGPMSearchCriteria,
    /* [retval][out] */ IGPMBackupCollection **ppIGPMBackupCollection);


void __RPC_STUB IGPMBackupDir_SearchBackups_Stub(
    IRpcStubBuffer *This,
    IRpcChannelBuffer *_pRpcChannelBuffer,
    PRPC_MESSAGE _pRpcMessage,
    DWORD *_pdwStubPhase);



#endif 	/* __IGPMBackupDir_INTERFACE_DEFINED__ */


#ifndef __IGPMSitesContainer_INTERFACE_DEFINED__
#define __IGPMSitesContainer_INTERFACE_DEFINED__

/* interface IGPMSitesContainer */
/* [unique][helpstring][dual][uuid][object] */ 


EXTERN_C const IID IID_IGPMSitesContainer;

#if defined(__cplusplus) && !defined(CINTERFACE)
    
    MIDL_INTERFACE("4725A899-2782-4D27-A6BB-D499246FFD72")
    IGPMSitesContainer : public IDispatch
    {
    public:
        virtual /* [helpstring][id][propget] */ HRESULT STDMETHODCALLTYPE get_DomainController( 
            /* [retval][out] */ BSTR *pVal) = 0;
        
        virtual /* [helpstring][id][propget] */ HRESULT STDMETHODCALLTYPE get_Domain( 
            /* [retval][out] */ BSTR *pVal) = 0;
        
        virtual /* [helpstring][id][propget] */ HRESULT STDMETHODCALLTYPE get_Forest( 
            /* [retval][out] */ BSTR *pVal) = 0;
        
        virtual /* [helpstring][id] */ HRESULT STDMETHODCALLTYPE GetSite( 
            /* [in] */ BSTR bstrSiteName,
            /* [retval][out] */ IGPMSOM **ppSOM) = 0;
        
        virtual /* [helpstring][id] */ HRESULT STDMETHODCALLTYPE SearchSites( 
            /* [in] */ IGPMSearchCriteria *pIGPMSearchCriteria,
            /* [retval][out] */ IGPMSOMCollection **ppIGPMSOMCollection) = 0;
        
    };
    
#else 	/* C style interface */

    typedef struct IGPMSitesContainerVtbl
    {
        BEGIN_INTERFACE
        
        HRESULT ( STDMETHODCALLTYPE *QueryInterface )( 
            IGPMSitesContainer * This,
            /* [in] */ REFIID riid,
            /* [iid_is][out] */ void **ppvObject);
        
        ULONG ( STDMETHODCALLTYPE *AddRef )( 
            IGPMSitesContainer * This);
        
        ULONG ( STDMETHODCALLTYPE *Release )( 
            IGPMSitesContainer * This);
        
        HRESULT ( STDMETHODCALLTYPE *GetTypeInfoCount )( 
            IGPMSitesContainer * This,
            /* [out] */ UINT *pctinfo);
        
        HRESULT ( STDMETHODCALLTYPE *GetTypeInfo )( 
            IGPMSitesContainer * This,
            /* [in] */ UINT iTInfo,
            /* [in] */ LCID lcid,
            /* [out] */ ITypeInfo **ppTInfo);
        
        HRESULT ( STDMETHODCALLTYPE *GetIDsOfNames )( 
            IGPMSitesContainer * This,
            /* [in] */ REFIID riid,
            /* [size_is][in] */ LPOLESTR *rgszNames,
            /* [in] */ UINT cNames,
            /* [in] */ LCID lcid,
            /* [size_is][out] */ DISPID *rgDispId);
        
        /* [local] */ HRESULT ( STDMETHODCALLTYPE *Invoke )( 
            IGPMSitesContainer * This,
            /* [in] */ DISPID dispIdMember,
            /* [in] */ REFIID riid,
            /* [in] */ LCID lcid,
            /* [in] */ WORD wFlags,
            /* [out][in] */ DISPPARAMS *pDispParams,
            /* [out] */ VARIANT *pVarResult,
            /* [out] */ EXCEPINFO *pExcepInfo,
            /* [out] */ UINT *puArgErr);
        
        /* [helpstring][id][propget] */ HRESULT ( STDMETHODCALLTYPE *get_DomainController )( 
            IGPMSitesContainer * This,
            /* [retval][out] */ BSTR *pVal);
        
        /* [helpstring][id][propget] */ HRESULT ( STDMETHODCALLTYPE *get_Domain )( 
            IGPMSitesContainer * This,
            /* [retval][out] */ BSTR *pVal);
        
        /* [helpstring][id][propget] */ HRESULT ( STDMETHODCALLTYPE *get_Forest )( 
            IGPMSitesContainer * This,
            /* [retval][out] */ BSTR *pVal);
        
        /* [helpstring][id] */ HRESULT ( STDMETHODCALLTYPE *GetSite )( 
            IGPMSitesContainer * This,
            /* [in] */ BSTR bstrSiteName,
            /* [retval][out] */ IGPMSOM **ppSOM);
        
        /* [helpstring][id] */ HRESULT ( STDMETHODCALLTYPE *SearchSites )( 
            IGPMSitesContainer * This,
            /* [in] */ IGPMSearchCriteria *pIGPMSearchCriteria,
            /* [retval][out] */ IGPMSOMCollection **ppIGPMSOMCollection);
        
        END_INTERFACE
    } IGPMSitesContainerVtbl;

    interface IGPMSitesContainer
    {
        CONST_VTBL struct IGPMSitesContainerVtbl *lpVtbl;
    };

    

#ifdef COBJMACROS


#define IGPMSitesContainer_QueryInterface(This,riid,ppvObject)	\
    (This)->lpVtbl -> QueryInterface(This,riid,ppvObject)

#define IGPMSitesContainer_AddRef(This)	\
    (This)->lpVtbl -> AddRef(This)

#define IGPMSitesContainer_Release(This)	\
    (This)->lpVtbl -> Release(This)


#define IGPMSitesContainer_GetTypeInfoCount(This,pctinfo)	\
    (This)->lpVtbl -> GetTypeInfoCount(This,pctinfo)

#define IGPMSitesContainer_GetTypeInfo(This,iTInfo,lcid,ppTInfo)	\
    (This)->lpVtbl -> GetTypeInfo(This,iTInfo,lcid,ppTInfo)

#define IGPMSitesContainer_GetIDsOfNames(This,riid,rgszNames,cNames,lcid,rgDispId)	\
    (This)->lpVtbl -> GetIDsOfNames(This,riid,rgszNames,cNames,lcid,rgDispId)

#define IGPMSitesContainer_Invoke(This,dispIdMember,riid,lcid,wFlags,pDispParams,pVarResult,pExcepInfo,puArgErr)	\
    (This)->lpVtbl -> Invoke(This,dispIdMember,riid,lcid,wFlags,pDispParams,pVarResult,pExcepInfo,puArgErr)


#define IGPMSitesContainer_get_DomainController(This,pVal)	\
    (This)->lpVtbl -> get_DomainController(This,pVal)

#define IGPMSitesContainer_get_Domain(This,pVal)	\
    (This)->lpVtbl -> get_Domain(This,pVal)

#define IGPMSitesContainer_get_Forest(This,pVal)	\
    (This)->lpVtbl -> get_Forest(This,pVal)

#define IGPMSitesContainer_GetSite(This,bstrSiteName,ppSOM)	\
    (This)->lpVtbl -> GetSite(This,bstrSiteName,ppSOM)

#define IGPMSitesContainer_SearchSites(This,pIGPMSearchCriteria,ppIGPMSOMCollection)	\
    (This)->lpVtbl -> SearchSites(This,pIGPMSearchCriteria,ppIGPMSOMCollection)

#endif /* COBJMACROS */


#endif 	/* C style interface */



/* [helpstring][id][propget] */ HRESULT STDMETHODCALLTYPE IGPMSitesContainer_get_DomainController_Proxy( 
    IGPMSitesContainer * This,
    /* [retval][out] */ BSTR *pVal);


void __RPC_STUB IGPMSitesContainer_get_DomainController_Stub(
    IRpcStubBuffer *This,
    IRpcChannelBuffer *_pRpcChannelBuffer,
    PRPC_MESSAGE _pRpcMessage,
    DWORD *_pdwStubPhase);


/* [helpstring][id][propget] */ HRESULT STDMETHODCALLTYPE IGPMSitesContainer_get_Domain_Proxy( 
    IGPMSitesContainer * This,
    /* [retval][out] */ BSTR *pVal);


void __RPC_STUB IGPMSitesContainer_get_Domain_Stub(
    IRpcStubBuffer *This,
    IRpcChannelBuffer *_pRpcChannelBuffer,
    PRPC_MESSAGE _pRpcMessage,
    DWORD *_pdwStubPhase);


/* [helpstring][id][propget] */ HRESULT STDMETHODCALLTYPE IGPMSitesContainer_get_Forest_Proxy( 
    IGPMSitesContainer * This,
    /* [retval][out] */ BSTR *pVal);


void __RPC_STUB IGPMSitesContainer_get_Forest_Stub(
    IRpcStubBuffer *This,
    IRpcChannelBuffer *_pRpcChannelBuffer,
    PRPC_MESSAGE _pRpcMessage,
    DWORD *_pdwStubPhase);


/* [helpstring][id] */ HRESULT STDMETHODCALLTYPE IGPMSitesContainer_GetSite_Proxy( 
    IGPMSitesContainer * This,
    /* [in] */ BSTR bstrSiteName,
    /* [retval][out] */ IGPMSOM **ppSOM);


void __RPC_STUB IGPMSitesContainer_GetSite_Stub(
    IRpcStubBuffer *This,
    IRpcChannelBuffer *_pRpcChannelBuffer,
    PRPC_MESSAGE _pRpcMessage,
    DWORD *_pdwStubPhase);


/* [helpstring][id] */ HRESULT STDMETHODCALLTYPE IGPMSitesContainer_SearchSites_Proxy( 
    IGPMSitesContainer * This,
    /* [in] */ IGPMSearchCriteria *pIGPMSearchCriteria,
    /* [retval][out] */ IGPMSOMCollection **ppIGPMSOMCollection);


void __RPC_STUB IGPMSitesContainer_SearchSites_Stub(
    IRpcStubBuffer *This,
    IRpcChannelBuffer *_pRpcChannelBuffer,
    PRPC_MESSAGE _pRpcMessage,
    DWORD *_pdwStubPhase);



#endif 	/* __IGPMSitesContainer_INTERFACE_DEFINED__ */


#ifndef __IGPMSearchCriteria_INTERFACE_DEFINED__
#define __IGPMSearchCriteria_INTERFACE_DEFINED__

/* interface IGPMSearchCriteria */
/* [unique][helpstring][dual][uuid][object] */ 


EXTERN_C const IID IID_IGPMSearchCriteria;

#if defined(__cplusplus) && !defined(CINTERFACE)
    
    MIDL_INTERFACE("D6F11C42-829B-48D4-83F5-3615B67DFC22")
    IGPMSearchCriteria : public IDispatch
    {
    public:
        virtual /* [helpstring][id] */ HRESULT STDMETHODCALLTYPE Add( 
            /* [in] */ GPMSearchProperty searchProperty,
            /* [in] */ GPMSearchOperation searchOperation,
            /* [in] */ VARIANT varValue) = 0;
        
    };
    
#else 	/* C style interface */

    typedef struct IGPMSearchCriteriaVtbl
    {
        BEGIN_INTERFACE
        
        HRESULT ( STDMETHODCALLTYPE *QueryInterface )( 
            IGPMSearchCriteria * This,
            /* [in] */ REFIID riid,
            /* [iid_is][out] */ void **ppvObject);
        
        ULONG ( STDMETHODCALLTYPE *AddRef )( 
            IGPMSearchCriteria * This);
        
        ULONG ( STDMETHODCALLTYPE *Release )( 
            IGPMSearchCriteria * This);
        
        HRESULT ( STDMETHODCALLTYPE *GetTypeInfoCount )( 
            IGPMSearchCriteria * This,
            /* [out] */ UINT *pctinfo);
        
        HRESULT ( STDMETHODCALLTYPE *GetTypeInfo )( 
            IGPMSearchCriteria * This,
            /* [in] */ UINT iTInfo,
            /* [in] */ LCID lcid,
            /* [out] */ ITypeInfo **ppTInfo);
        
        HRESULT ( STDMETHODCALLTYPE *GetIDsOfNames )( 
            IGPMSearchCriteria * This,
            /* [in] */ REFIID riid,
            /* [size_is][in] */ LPOLESTR *rgszNames,
            /* [in] */ UINT cNames,
            /* [in] */ LCID lcid,
            /* [size_is][out] */ DISPID *rgDispId);
        
        /* [local] */ HRESULT ( STDMETHODCALLTYPE *Invoke )( 
            IGPMSearchCriteria * This,
            /* [in] */ DISPID dispIdMember,
            /* [in] */ REFIID riid,
            /* [in] */ LCID lcid,
            /* [in] */ WORD wFlags,
            /* [out][in] */ DISPPARAMS *pDispParams,
            /* [out] */ VARIANT *pVarResult,
            /* [out] */ EXCEPINFO *pExcepInfo,
            /* [out] */ UINT *puArgErr);
        
        /* [helpstring][id] */ HRESULT ( STDMETHODCALLTYPE *Add )( 
            IGPMSearchCriteria * This,
            /* [in] */ GPMSearchProperty searchProperty,
            /* [in] */ GPMSearchOperation searchOperation,
            /* [in] */ VARIANT varValue);
        
        END_INTERFACE
    } IGPMSearchCriteriaVtbl;

    interface IGPMSearchCriteria
    {
        CONST_VTBL struct IGPMSearchCriteriaVtbl *lpVtbl;
    };

    

#ifdef COBJMACROS


#define IGPMSearchCriteria_QueryInterface(This,riid,ppvObject)	\
    (This)->lpVtbl -> QueryInterface(This,riid,ppvObject)

#define IGPMSearchCriteria_AddRef(This)	\
    (This)->lpVtbl -> AddRef(This)

#define IGPMSearchCriteria_Release(This)	\
    (This)->lpVtbl -> Release(This)


#define IGPMSearchCriteria_GetTypeInfoCount(This,pctinfo)	\
    (This)->lpVtbl -> GetTypeInfoCount(This,pctinfo)

#define IGPMSearchCriteria_GetTypeInfo(This,iTInfo,lcid,ppTInfo)	\
    (This)->lpVtbl -> GetTypeInfo(This,iTInfo,lcid,ppTInfo)

#define IGPMSearchCriteria_GetIDsOfNames(This,riid,rgszNames,cNames,lcid,rgDispId)	\
    (This)->lpVtbl -> GetIDsOfNames(This,riid,rgszNames,cNames,lcid,rgDispId)

#define IGPMSearchCriteria_Invoke(This,dispIdMember,riid,lcid,wFlags,pDispParams,pVarResult,pExcepInfo,puArgErr)	\
    (This)->lpVtbl -> Invoke(This,dispIdMember,riid,lcid,wFlags,pDispParams,pVarResult,pExcepInfo,puArgErr)


#define IGPMSearchCriteria_Add(This,searchProperty,searchOperation,varValue)	\
    (This)->lpVtbl -> Add(This,searchProperty,searchOperation,varValue)

#endif /* COBJMACROS */


#endif 	/* C style interface */



/* [helpstring][id] */ HRESULT STDMETHODCALLTYPE IGPMSearchCriteria_Add_Proxy( 
    IGPMSearchCriteria * This,
    /* [in] */ GPMSearchProperty searchProperty,
    /* [in] */ GPMSearchOperation searchOperation,
    /* [in] */ VARIANT varValue);


void __RPC_STUB IGPMSearchCriteria_Add_Stub(
    IRpcStubBuffer *This,
    IRpcChannelBuffer *_pRpcChannelBuffer,
    PRPC_MESSAGE _pRpcMessage,
    DWORD *_pdwStubPhase);



#endif 	/* __IGPMSearchCriteria_INTERFACE_DEFINED__ */


#ifndef __IGPMTrustee_INTERFACE_DEFINED__
#define __IGPMTrustee_INTERFACE_DEFINED__

/* interface IGPMTrustee */
/* [unique][helpstring][dual][uuid][object] */ 


EXTERN_C const IID IID_IGPMTrustee;

#if defined(__cplusplus) && !defined(CINTERFACE)
    
    MIDL_INTERFACE("3B466DA8-C1A4-4B2A-999A-BEFCDD56CEFB")
    IGPMTrustee : public IDispatch
    {
    public:
        virtual /* [helpstring][id][propget] */ HRESULT STDMETHODCALLTYPE get_TrusteeSid( 
            /* [retval][out] */ BSTR *bstrVal) = 0;
        
        virtual /* [helpstring][id][propget] */ HRESULT STDMETHODCALLTYPE get_TrusteeName( 
            /* [retval][out] */ BSTR *bstrVal) = 0;
        
        virtual /* [helpstring][id][propget] */ HRESULT STDMETHODCALLTYPE get_TrusteeDomain( 
            /* [retval][out] */ BSTR *bstrVal) = 0;
        
        virtual /* [helpstring][id][propget] */ HRESULT STDMETHODCALLTYPE get_TrusteeDSPath( 
            /* [retval][out] */ BSTR *pVal) = 0;
        
        virtual /* [helpstring][id][propget] */ HRESULT STDMETHODCALLTYPE get_TrusteeType( 
            /* [retval][out] */ long *lVal) = 0;
        
    };
    
#else 	/* C style interface */

    typedef struct IGPMTrusteeVtbl
    {
        BEGIN_INTERFACE
        
        HRESULT ( STDMETHODCALLTYPE *QueryInterface )( 
            IGPMTrustee * This,
            /* [in] */ REFIID riid,
            /* [iid_is][out] */ void **ppvObject);
        
        ULONG ( STDMETHODCALLTYPE *AddRef )( 
            IGPMTrustee * This);
        
        ULONG ( STDMETHODCALLTYPE *Release )( 
            IGPMTrustee * This);
        
        HRESULT ( STDMETHODCALLTYPE *GetTypeInfoCount )( 
            IGPMTrustee * This,
            /* [out] */ UINT *pctinfo);
        
        HRESULT ( STDMETHODCALLTYPE *GetTypeInfo )( 
            IGPMTrustee * This,
            /* [in] */ UINT iTInfo,
            /* [in] */ LCID lcid,
            /* [out] */ ITypeInfo **ppTInfo);
        
        HRESULT ( STDMETHODCALLTYPE *GetIDsOfNames )( 
            IGPMTrustee * This,
            /* [in] */ REFIID riid,
            /* [size_is][in] */ LPOLESTR *rgszNames,
            /* [in] */ UINT cNames,
            /* [in] */ LCID lcid,
            /* [size_is][out] */ DISPID *rgDispId);
        
        /* [local] */ HRESULT ( STDMETHODCALLTYPE *Invoke )( 
            IGPMTrustee * This,
            /* [in] */ DISPID dispIdMember,
            /* [in] */ REFIID riid,
            /* [in] */ LCID lcid,
            /* [in] */ WORD wFlags,
            /* [out][in] */ DISPPARAMS *pDispParams,
            /* [out] */ VARIANT *pVarResult,
            /* [out] */ EXCEPINFO *pExcepInfo,
            /* [out] */ UINT *puArgErr);
        
        /* [helpstring][id][propget] */ HRESULT ( STDMETHODCALLTYPE *get_TrusteeSid )( 
            IGPMTrustee * This,
            /* [retval][out] */ BSTR *bstrVal);
        
        /* [helpstring][id][propget] */ HRESULT ( STDMETHODCALLTYPE *get_TrusteeName )( 
            IGPMTrustee * This,
            /* [retval][out] */ BSTR *bstrVal);
        
        /* [helpstring][id][propget] */ HRESULT ( STDMETHODCALLTYPE *get_TrusteeDomain )( 
            IGPMTrustee * This,
            /* [retval][out] */ BSTR *bstrVal);
        
        /* [helpstring][id][propget] */ HRESULT ( STDMETHODCALLTYPE *get_TrusteeDSPath )( 
            IGPMTrustee * This,
            /* [retval][out] */ BSTR *pVal);
        
        /* [helpstring][id][propget] */ HRESULT ( STDMETHODCALLTYPE *get_TrusteeType )( 
            IGPMTrustee * This,
            /* [retval][out] */ long *lVal);
        
        END_INTERFACE
    } IGPMTrusteeVtbl;

    interface IGPMTrustee
    {
        CONST_VTBL struct IGPMTrusteeVtbl *lpVtbl;
    };

    

#ifdef COBJMACROS


#define IGPMTrustee_QueryInterface(This,riid,ppvObject)	\
    (This)->lpVtbl -> QueryInterface(This,riid,ppvObject)

#define IGPMTrustee_AddRef(This)	\
    (This)->lpVtbl -> AddRef(This)

#define IGPMTrustee_Release(This)	\
    (This)->lpVtbl -> Release(This)


#define IGPMTrustee_GetTypeInfoCount(This,pctinfo)	\
    (This)->lpVtbl -> GetTypeInfoCount(This,pctinfo)

#define IGPMTrustee_GetTypeInfo(This,iTInfo,lcid,ppTInfo)	\
    (This)->lpVtbl -> GetTypeInfo(This,iTInfo,lcid,ppTInfo)

#define IGPMTrustee_GetIDsOfNames(This,riid,rgszNames,cNames,lcid,rgDispId)	\
    (This)->lpVtbl -> GetIDsOfNames(This,riid,rgszNames,cNames,lcid,rgDispId)

#define IGPMTrustee_Invoke(This,dispIdMember,riid,lcid,wFlags,pDispParams,pVarResult,pExcepInfo,puArgErr)	\
    (This)->lpVtbl -> Invoke(This,dispIdMember,riid,lcid,wFlags,pDispParams,pVarResult,pExcepInfo,puArgErr)


#define IGPMTrustee_get_TrusteeSid(This,bstrVal)	\
    (This)->lpVtbl -> get_TrusteeSid(This,bstrVal)

#define IGPMTrustee_get_TrusteeName(This,bstrVal)	\
    (This)->lpVtbl -> get_TrusteeName(This,bstrVal)

#define IGPMTrustee_get_TrusteeDomain(This,bstrVal)	\
    (This)->lpVtbl -> get_TrusteeDomain(This,bstrVal)

#define IGPMTrustee_get_TrusteeDSPath(This,pVal)	\
    (This)->lpVtbl -> get_TrusteeDSPath(This,pVal)

#define IGPMTrustee_get_TrusteeType(This,lVal)	\
    (This)->lpVtbl -> get_TrusteeType(This,lVal)

#endif /* COBJMACROS */


#endif 	/* C style interface */



/* [helpstring][id][propget] */ HRESULT STDMETHODCALLTYPE IGPMTrustee_get_TrusteeSid_Proxy( 
    IGPMTrustee * This,
    /* [retval][out] */ BSTR *bstrVal);


void __RPC_STUB IGPMTrustee_get_TrusteeSid_Stub(
    IRpcStubBuffer *This,
    IRpcChannelBuffer *_pRpcChannelBuffer,
    PRPC_MESSAGE _pRpcMessage,
    DWORD *_pdwStubPhase);


/* [helpstring][id][propget] */ HRESULT STDMETHODCALLTYPE IGPMTrustee_get_TrusteeName_Proxy( 
    IGPMTrustee * This,
    /* [retval][out] */ BSTR *bstrVal);


void __RPC_STUB IGPMTrustee_get_TrusteeName_Stub(
    IRpcStubBuffer *This,
    IRpcChannelBuffer *_pRpcChannelBuffer,
    PRPC_MESSAGE _pRpcMessage,
    DWORD *_pdwStubPhase);


/* [helpstring][id][propget] */ HRESULT STDMETHODCALLTYPE IGPMTrustee_get_TrusteeDomain_Proxy( 
    IGPMTrustee * This,
    /* [retval][out] */ BSTR *bstrVal);


void __RPC_STUB IGPMTrustee_get_TrusteeDomain_Stub(
    IRpcStubBuffer *This,
    IRpcChannelBuffer *_pRpcChannelBuffer,
    PRPC_MESSAGE _pRpcMessage,
    DWORD *_pdwStubPhase);


/* [helpstring][id][propget] */ HRESULT STDMETHODCALLTYPE IGPMTrustee_get_TrusteeDSPath_Proxy( 
    IGPMTrustee * This,
    /* [retval][out] */ BSTR *pVal);


void __RPC_STUB IGPMTrustee_get_TrusteeDSPath_Stub(
    IRpcStubBuffer *This,
    IRpcChannelBuffer *_pRpcChannelBuffer,
    PRPC_MESSAGE _pRpcMessage,
    DWORD *_pdwStubPhase);


/* [helpstring][id][propget] */ HRESULT STDMETHODCALLTYPE IGPMTrustee_get_TrusteeType_Proxy( 
    IGPMTrustee * This,
    /* [retval][out] */ long *lVal);


void __RPC_STUB IGPMTrustee_get_TrusteeType_Stub(
    IRpcStubBuffer *This,
    IRpcChannelBuffer *_pRpcChannelBuffer,
    PRPC_MESSAGE _pRpcMessage,
    DWORD *_pdwStubPhase);



#endif 	/* __IGPMTrustee_INTERFACE_DEFINED__ */


#ifndef __IGPMPermission_INTERFACE_DEFINED__
#define __IGPMPermission_INTERFACE_DEFINED__

/* interface IGPMPermission */
/* [unique][helpstring][dual][uuid][object] */ 


EXTERN_C const IID IID_IGPMPermission;

#if defined(__cplusplus) && !defined(CINTERFACE)
    
    MIDL_INTERFACE("35EBCA40-E1A1-4A02-8905-D79416FB464A")
    IGPMPermission : public IDispatch
    {
    public:
        virtual /* [helpstring][id][propget] */ HRESULT STDMETHODCALLTYPE get_TrusteeSid( 
            /* [retval][out] */ BSTR *pVal) = 0;
        
        virtual /* [helpstring][id][propget] */ HRESULT STDMETHODCALLTYPE get_TrusteeName( 
            /* [retval][out] */ BSTR *pVal) = 0;
        
        virtual /* [helpstring][id][propget] */ HRESULT STDMETHODCALLTYPE get_TrusteeDomain( 
            /* [retval][out] */ BSTR *pVal) = 0;
        
        virtual /* [helpstring][id][propget] */ HRESULT STDMETHODCALLTYPE get_TrusteeDSPath( 
            /* [retval][out] */ BSTR *pVal) = 0;
        
        virtual /* [helpstring][id][propget] */ HRESULT STDMETHODCALLTYPE get_TrusteeType( 
            /* [retval][out] */ long *lVal) = 0;
        
        virtual /* [helpstring][id][propget] */ HRESULT STDMETHODCALLTYPE get_Inherited( 
            /* [retval][out] */ VARIANT_BOOL *pVal) = 0;
        
        virtual /* [helpstring][id][propget] */ HRESULT STDMETHODCALLTYPE get_Inheritable( 
            /* [retval][out] */ VARIANT_BOOL *pVal) = 0;
        
        virtual /* [helpstring][id][propget] */ HRESULT STDMETHODCALLTYPE get_Denied( 
            /* [retval][out] */ VARIANT_BOOL *pVal) = 0;
        
        virtual /* [helpstring][id][propget] */ HRESULT STDMETHODCALLTYPE get_Permission( 
            /* [retval][out] */ GPMPermissionType *pVal) = 0;
        
    };
    
#else 	/* C style interface */

    typedef struct IGPMPermissionVtbl
    {
        BEGIN_INTERFACE
        
        HRESULT ( STDMETHODCALLTYPE *QueryInterface )( 
            IGPMPermission * This,
            /* [in] */ REFIID riid,
            /* [iid_is][out] */ void **ppvObject);
        
        ULONG ( STDMETHODCALLTYPE *AddRef )( 
            IGPMPermission * This);
        
        ULONG ( STDMETHODCALLTYPE *Release )( 
            IGPMPermission * This);
        
        HRESULT ( STDMETHODCALLTYPE *GetTypeInfoCount )( 
            IGPMPermission * This,
            /* [out] */ UINT *pctinfo);
        
        HRESULT ( STDMETHODCALLTYPE *GetTypeInfo )( 
            IGPMPermission * This,
            /* [in] */ UINT iTInfo,
            /* [in] */ LCID lcid,
            /* [out] */ ITypeInfo **ppTInfo);
        
        HRESULT ( STDMETHODCALLTYPE *GetIDsOfNames )( 
            IGPMPermission * This,
            /* [in] */ REFIID riid,
            /* [size_is][in] */ LPOLESTR *rgszNames,
            /* [in] */ UINT cNames,
            /* [in] */ LCID lcid,
            /* [size_is][out] */ DISPID *rgDispId);
        
        /* [local] */ HRESULT ( STDMETHODCALLTYPE *Invoke )( 
            IGPMPermission * This,
            /* [in] */ DISPID dispIdMember,
            /* [in] */ REFIID riid,
            /* [in] */ LCID lcid,
            /* [in] */ WORD wFlags,
            /* [out][in] */ DISPPARAMS *pDispParams,
            /* [out] */ VARIANT *pVarResult,
            /* [out] */ EXCEPINFO *pExcepInfo,
            /* [out] */ UINT *puArgErr);
        
        /* [helpstring][id][propget] */ HRESULT ( STDMETHODCALLTYPE *get_TrusteeSid )( 
            IGPMPermission * This,
            /* [retval][out] */ BSTR *pVal);
        
        /* [helpstring][id][propget] */ HRESULT ( STDMETHODCALLTYPE *get_TrusteeName )( 
            IGPMPermission * This,
            /* [retval][out] */ BSTR *pVal);
        
        /* [helpstring][id][propget] */ HRESULT ( STDMETHODCALLTYPE *get_TrusteeDomain )( 
            IGPMPermission * This,
            /* [retval][out] */ BSTR *pVal);
        
        /* [helpstring][id][propget] */ HRESULT ( STDMETHODCALLTYPE *get_TrusteeDSPath )( 
            IGPMPermission * This,
            /* [retval][out] */ BSTR *pVal);
        
        /* [helpstring][id][propget] */ HRESULT ( STDMETHODCALLTYPE *get_TrusteeType )( 
            IGPMPermission * This,
            /* [retval][out] */ long *lVal);
        
        /* [helpstring][id][propget] */ HRESULT ( STDMETHODCALLTYPE *get_Inherited )( 
            IGPMPermission * This,
            /* [retval][out] */ VARIANT_BOOL *pVal);
        
        /* [helpstring][id][propget] */ HRESULT ( STDMETHODCALLTYPE *get_Inheritable )( 
            IGPMPermission * This,
            /* [retval][out] */ VARIANT_BOOL *pVal);
        
        /* [helpstring][id][propget] */ HRESULT ( STDMETHODCALLTYPE *get_Denied )( 
            IGPMPermission * This,
            /* [retval][out] */ VARIANT_BOOL *pVal);
        
        /* [helpstring][id][propget] */ HRESULT ( STDMETHODCALLTYPE *get_Permission )( 
            IGPMPermission * This,
            /* [retval][out] */ GPMPermissionType *pVal);
        
        END_INTERFACE
    } IGPMPermissionVtbl;

    interface IGPMPermission
    {
        CONST_VTBL struct IGPMPermissionVtbl *lpVtbl;
    };

    

#ifdef COBJMACROS


#define IGPMPermission_QueryInterface(This,riid,ppvObject)	\
    (This)->lpVtbl -> QueryInterface(This,riid,ppvObject)

#define IGPMPermission_AddRef(This)	\
    (This)->lpVtbl -> AddRef(This)

#define IGPMPermission_Release(This)	\
    (This)->lpVtbl -> Release(This)


#define IGPMPermission_GetTypeInfoCount(This,pctinfo)	\
    (This)->lpVtbl -> GetTypeInfoCount(This,pctinfo)

#define IGPMPermission_GetTypeInfo(This,iTInfo,lcid,ppTInfo)	\
    (This)->lpVtbl -> GetTypeInfo(This,iTInfo,lcid,ppTInfo)

#define IGPMPermission_GetIDsOfNames(This,riid,rgszNames,cNames,lcid,rgDispId)	\
    (This)->lpVtbl -> GetIDsOfNames(This,riid,rgszNames,cNames,lcid,rgDispId)

#define IGPMPermission_Invoke(This,dispIdMember,riid,lcid,wFlags,pDispParams,pVarResult,pExcepInfo,puArgErr)	\
    (This)->lpVtbl -> Invoke(This,dispIdMember,riid,lcid,wFlags,pDispParams,pVarResult,pExcepInfo,puArgErr)


#define IGPMPermission_get_TrusteeSid(This,pVal)	\
    (This)->lpVtbl -> get_TrusteeSid(This,pVal)

#define IGPMPermission_get_TrusteeName(This,pVal)	\
    (This)->lpVtbl -> get_TrusteeName(This,pVal)

#define IGPMPermission_get_TrusteeDomain(This,pVal)	\
    (This)->lpVtbl -> get_TrusteeDomain(This,pVal)

#define IGPMPermission_get_TrusteeDSPath(This,pVal)	\
    (This)->lpVtbl -> get_TrusteeDSPath(This,pVal)

#define IGPMPermission_get_TrusteeType(This,lVal)	\
    (This)->lpVtbl -> get_TrusteeType(This,lVal)

#define IGPMPermission_get_Inherited(This,pVal)	\
    (This)->lpVtbl -> get_Inherited(This,pVal)

#define IGPMPermission_get_Inheritable(This,pVal)	\
    (This)->lpVtbl -> get_Inheritable(This,pVal)

#define IGPMPermission_get_Denied(This,pVal)	\
    (This)->lpVtbl -> get_Denied(This,pVal)

#define IGPMPermission_get_Permission(This,pVal)	\
    (This)->lpVtbl -> get_Permission(This,pVal)

#endif /* COBJMACROS */


#endif 	/* C style interface */



/* [helpstring][id][propget] */ HRESULT STDMETHODCALLTYPE IGPMPermission_get_TrusteeSid_Proxy( 
    IGPMPermission * This,
    /* [retval][out] */ BSTR *pVal);


void __RPC_STUB IGPMPermission_get_TrusteeSid_Stub(
    IRpcStubBuffer *This,
    IRpcChannelBuffer *_pRpcChannelBuffer,
    PRPC_MESSAGE _pRpcMessage,
    DWORD *_pdwStubPhase);


/* [helpstring][id][propget] */ HRESULT STDMETHODCALLTYPE IGPMPermission_get_TrusteeName_Proxy( 
    IGPMPermission * This,
    /* [retval][out] */ BSTR *pVal);


void __RPC_STUB IGPMPermission_get_TrusteeName_Stub(
    IRpcStubBuffer *This,
    IRpcChannelBuffer *_pRpcChannelBuffer,
    PRPC_MESSAGE _pRpcMessage,
    DWORD *_pdwStubPhase);


/* [helpstring][id][propget] */ HRESULT STDMETHODCALLTYPE IGPMPermission_get_TrusteeDomain_Proxy( 
    IGPMPermission * This,
    /* [retval][out] */ BSTR *pVal);


void __RPC_STUB IGPMPermission_get_TrusteeDomain_Stub(
    IRpcStubBuffer *This,
    IRpcChannelBuffer *_pRpcChannelBuffer,
    PRPC_MESSAGE _pRpcMessage,
    DWORD *_pdwStubPhase);


/* [helpstring][id][propget] */ HRESULT STDMETHODCALLTYPE IGPMPermission_get_TrusteeDSPath_Proxy( 
    IGPMPermission * This,
    /* [retval][out] */ BSTR *pVal);


void __RPC_STUB IGPMPermission_get_TrusteeDSPath_Stub(
    IRpcStubBuffer *This,
    IRpcChannelBuffer *_pRpcChannelBuffer,
    PRPC_MESSAGE _pRpcMessage,
    DWORD *_pdwStubPhase);


/* [helpstring][id][propget] */ HRESULT STDMETHODCALLTYPE IGPMPermission_get_TrusteeType_Proxy( 
    IGPMPermission * This,
    /* [retval][out] */ long *lVal);


void __RPC_STUB IGPMPermission_get_TrusteeType_Stub(
    IRpcStubBuffer *This,
    IRpcChannelBuffer *_pRpcChannelBuffer,
    PRPC_MESSAGE _pRpcMessage,
    DWORD *_pdwStubPhase);


/* [helpstring][id][propget] */ HRESULT STDMETHODCALLTYPE IGPMPermission_get_Inherited_Proxy( 
    IGPMPermission * This,
    /* [retval][out] */ VARIANT_BOOL *pVal);


void __RPC_STUB IGPMPermission_get_Inherited_Stub(
    IRpcStubBuffer *This,
    IRpcChannelBuffer *_pRpcChannelBuffer,
    PRPC_MESSAGE _pRpcMessage,
    DWORD *_pdwStubPhase);


/* [helpstring][id][propget] */ HRESULT STDMETHODCALLTYPE IGPMPermission_get_Inheritable_Proxy( 
    IGPMPermission * This,
    /* [retval][out] */ VARIANT_BOOL *pVal);


void __RPC_STUB IGPMPermission_get_Inheritable_Stub(
    IRpcStubBuffer *This,
    IRpcChannelBuffer *_pRpcChannelBuffer,
    PRPC_MESSAGE _pRpcMessage,
    DWORD *_pdwStubPhase);


/* [helpstring][id][propget] */ HRESULT STDMETHODCALLTYPE IGPMPermission_get_Denied_Proxy( 
    IGPMPermission * This,
    /* [retval][out] */ VARIANT_BOOL *pVal);


void __RPC_STUB IGPMPermission_get_Denied_Stub(
    IRpcStubBuffer *This,
    IRpcChannelBuffer *_pRpcChannelBuffer,
    PRPC_MESSAGE _pRpcMessage,
    DWORD *_pdwStubPhase);


/* [helpstring][id][propget] */ HRESULT STDMETHODCALLTYPE IGPMPermission_get_Permission_Proxy( 
    IGPMPermission * This,
    /* [retval][out] */ GPMPermissionType *pVal);


void __RPC_STUB IGPMPermission_get_Permission_Stub(
    IRpcStubBuffer *This,
    IRpcChannelBuffer *_pRpcChannelBuffer,
    PRPC_MESSAGE _pRpcMessage,
    DWORD *_pdwStubPhase);



#endif 	/* __IGPMPermission_INTERFACE_DEFINED__ */


#ifndef __IGPMSecurityInfo_INTERFACE_DEFINED__
#define __IGPMSecurityInfo_INTERFACE_DEFINED__

/* interface IGPMSecurityInfo */
/* [unique][helpstring][dual][uuid][object] */ 


EXTERN_C const IID IID_IGPMSecurityInfo;

#if defined(__cplusplus) && !defined(CINTERFACE)
    
    MIDL_INTERFACE("B6C31ED4-1C93-4D3E-AE84-EB6D61161B60")
    IGPMSecurityInfo : public IDispatch
    {
    public:
        virtual /* [helpstring][id][propget] */ HRESULT STDMETHODCALLTYPE get_Count( 
            /* [retval][out] */ long *pVal) = 0;
        
        virtual /* [helpstring][id][propget] */ HRESULT STDMETHODCALLTYPE get_Item( 
            long lIndex,
            /* [retval][out] */ VARIANT *pVal) = 0;
        
        virtual /* [helpstring][id][propget] */ HRESULT STDMETHODCALLTYPE get__NewEnum( 
            /* [retval][out] */ IEnumVARIANT **ppEnum) = 0;
        
        virtual /* [helpstring][id] */ HRESULT STDMETHODCALLTYPE Add( 
            /* [in] */ IGPMPermission *pPerm) = 0;
        
        virtual /* [helpstring][id] */ HRESULT STDMETHODCALLTYPE Remove( 
            /* [in] */ IGPMPermission *pPerm) = 0;
        
        virtual /* [helpstring][id] */ HRESULT STDMETHODCALLTYPE RemoveTrustee( 
            /* [in] */ BSTR bstrTrustee) = 0;
        
    };
    
#else 	/* C style interface */

    typedef struct IGPMSecurityInfoVtbl
    {
        BEGIN_INTERFACE
        
        HRESULT ( STDMETHODCALLTYPE *QueryInterface )( 
            IGPMSecurityInfo * This,
            /* [in] */ REFIID riid,
            /* [iid_is][out] */ void **ppvObject);
        
        ULONG ( STDMETHODCALLTYPE *AddRef )( 
            IGPMSecurityInfo * This);
        
        ULONG ( STDMETHODCALLTYPE *Release )( 
            IGPMSecurityInfo * This);
        
        HRESULT ( STDMETHODCALLTYPE *GetTypeInfoCount )( 
            IGPMSecurityInfo * This,
            /* [out] */ UINT *pctinfo);
        
        HRESULT ( STDMETHODCALLTYPE *GetTypeInfo )( 
            IGPMSecurityInfo * This,
            /* [in] */ UINT iTInfo,
            /* [in] */ LCID lcid,
            /* [out] */ ITypeInfo **ppTInfo);
        
        HRESULT ( STDMETHODCALLTYPE *GetIDsOfNames )( 
            IGPMSecurityInfo * This,
            /* [in] */ REFIID riid,
            /* [size_is][in] */ LPOLESTR *rgszNames,
            /* [in] */ UINT cNames,
            /* [in] */ LCID lcid,
            /* [size_is][out] */ DISPID *rgDispId);
        
        /* [local] */ HRESULT ( STDMETHODCALLTYPE *Invoke )( 
            IGPMSecurityInfo * This,
            /* [in] */ DISPID dispIdMember,
            /* [in] */ REFIID riid,
            /* [in] */ LCID lcid,
            /* [in] */ WORD wFlags,
            /* [out][in] */ DISPPARAMS *pDispParams,
            /* [out] */ VARIANT *pVarResult,
            /* [out] */ EXCEPINFO *pExcepInfo,
            /* [out] */ UINT *puArgErr);
        
        /* [helpstring][id][propget] */ HRESULT ( STDMETHODCALLTYPE *get_Count )( 
            IGPMSecurityInfo * This,
            /* [retval][out] */ long *pVal);
        
        /* [helpstring][id][propget] */ HRESULT ( STDMETHODCALLTYPE *get_Item )( 
            IGPMSecurityInfo * This,
            long lIndex,
            /* [retval][out] */ VARIANT *pVal);
        
        /* [helpstring][id][propget] */ HRESULT ( STDMETHODCALLTYPE *get__NewEnum )( 
            IGPMSecurityInfo * This,
            /* [retval][out] */ IEnumVARIANT **ppEnum);
        
        /* [helpstring][id] */ HRESULT ( STDMETHODCALLTYPE *Add )( 
            IGPMSecurityInfo * This,
            /* [in] */ IGPMPermission *pPerm);
        
        /* [helpstring][id] */ HRESULT ( STDMETHODCALLTYPE *Remove )( 
            IGPMSecurityInfo * This,
            /* [in] */ IGPMPermission *pPerm);
        
        /* [helpstring][id] */ HRESULT ( STDMETHODCALLTYPE *RemoveTrustee )( 
            IGPMSecurityInfo * This,
            /* [in] */ BSTR bstrTrustee);
        
        END_INTERFACE
    } IGPMSecurityInfoVtbl;

    interface IGPMSecurityInfo
    {
        CONST_VTBL struct IGPMSecurityInfoVtbl *lpVtbl;
    };

    

#ifdef COBJMACROS


#define IGPMSecurityInfo_QueryInterface(This,riid,ppvObject)	\
    (This)->lpVtbl -> QueryInterface(This,riid,ppvObject)

#define IGPMSecurityInfo_AddRef(This)	\
    (This)->lpVtbl -> AddRef(This)

#define IGPMSecurityInfo_Release(This)	\
    (This)->lpVtbl -> Release(This)


#define IGPMSecurityInfo_GetTypeInfoCount(This,pctinfo)	\
    (This)->lpVtbl -> GetTypeInfoCount(This,pctinfo)

#define IGPMSecurityInfo_GetTypeInfo(This,iTInfo,lcid,ppTInfo)	\
    (This)->lpVtbl -> GetTypeInfo(This,iTInfo,lcid,ppTInfo)

#define IGPMSecurityInfo_GetIDsOfNames(This,riid,rgszNames,cNames,lcid,rgDispId)	\
    (This)->lpVtbl -> GetIDsOfNames(This,riid,rgszNames,cNames,lcid,rgDispId)

#define IGPMSecurityInfo_Invoke(This,dispIdMember,riid,lcid,wFlags,pDispParams,pVarResult,pExcepInfo,puArgErr)	\
    (This)->lpVtbl -> Invoke(This,dispIdMember,riid,lcid,wFlags,pDispParams,pVarResult,pExcepInfo,puArgErr)


#define IGPMSecurityInfo_get_Count(This,pVal)	\
    (This)->lpVtbl -> get_Count(This,pVal)

#define IGPMSecurityInfo_get_Item(This,lIndex,pVal)	\
    (This)->lpVtbl -> get_Item(This,lIndex,pVal)

#define IGPMSecurityInfo_get__NewEnum(This,ppEnum)	\
    (This)->lpVtbl -> get__NewEnum(This,ppEnum)

#define IGPMSecurityInfo_Add(This,pPerm)	\
    (This)->lpVtbl -> Add(This,pPerm)

#define IGPMSecurityInfo_Remove(This,pPerm)	\
    (This)->lpVtbl -> Remove(This,pPerm)

#define IGPMSecurityInfo_RemoveTrustee(This,bstrTrustee)	\
    (This)->lpVtbl -> RemoveTrustee(This,bstrTrustee)

#endif /* COBJMACROS */


#endif 	/* C style interface */



/* [helpstring][id][propget] */ HRESULT STDMETHODCALLTYPE IGPMSecurityInfo_get_Count_Proxy( 
    IGPMSecurityInfo * This,
    /* [retval][out] */ long *pVal);


void __RPC_STUB IGPMSecurityInfo_get_Count_Stub(
    IRpcStubBuffer *This,
    IRpcChannelBuffer *_pRpcChannelBuffer,
    PRPC_MESSAGE _pRpcMessage,
    DWORD *_pdwStubPhase);


/* [helpstring][id][propget] */ HRESULT STDMETHODCALLTYPE IGPMSecurityInfo_get_Item_Proxy( 
    IGPMSecurityInfo * This,
    long lIndex,
    /* [retval][out] */ VARIANT *pVal);


void __RPC_STUB IGPMSecurityInfo_get_Item_Stub(
    IRpcStubBuffer *This,
    IRpcChannelBuffer *_pRpcChannelBuffer,
    PRPC_MESSAGE _pRpcMessage,
    DWORD *_pdwStubPhase);


/* [helpstring][id][propget] */ HRESULT STDMETHODCALLTYPE IGPMSecurityInfo_get__NewEnum_Proxy( 
    IGPMSecurityInfo * This,
    /* [retval][out] */ IEnumVARIANT **ppEnum);


void __RPC_STUB IGPMSecurityInfo_get__NewEnum_Stub(
    IRpcStubBuffer *This,
    IRpcChannelBuffer *_pRpcChannelBuffer,
    PRPC_MESSAGE _pRpcMessage,
    DWORD *_pdwStubPhase);


/* [helpstring][id] */ HRESULT STDMETHODCALLTYPE IGPMSecurityInfo_Add_Proxy( 
    IGPMSecurityInfo * This,
    /* [in] */ IGPMPermission *pPerm);


void __RPC_STUB IGPMSecurityInfo_Add_Stub(
    IRpcStubBuffer *This,
    IRpcChannelBuffer *_pRpcChannelBuffer,
    PRPC_MESSAGE _pRpcMessage,
    DWORD *_pdwStubPhase);


/* [helpstring][id] */ HRESULT STDMETHODCALLTYPE IGPMSecurityInfo_Remove_Proxy( 
    IGPMSecurityInfo * This,
    /* [in] */ IGPMPermission *pPerm);


void __RPC_STUB IGPMSecurityInfo_Remove_Stub(
    IRpcStubBuffer *This,
    IRpcChannelBuffer *_pRpcChannelBuffer,
    PRPC_MESSAGE _pRpcMessage,
    DWORD *_pdwStubPhase);


/* [helpstring][id] */ HRESULT STDMETHODCALLTYPE IGPMSecurityInfo_RemoveTrustee_Proxy( 
    IGPMSecurityInfo * This,
    /* [in] */ BSTR bstrTrustee);


void __RPC_STUB IGPMSecurityInfo_RemoveTrustee_Stub(
    IRpcStubBuffer *This,
    IRpcChannelBuffer *_pRpcChannelBuffer,
    PRPC_MESSAGE _pRpcMessage,
    DWORD *_pdwStubPhase);



#endif 	/* __IGPMSecurityInfo_INTERFACE_DEFINED__ */


#ifndef __IGPMBackup_INTERFACE_DEFINED__
#define __IGPMBackup_INTERFACE_DEFINED__

/* interface IGPMBackup */
/* [unique][helpstring][dual][uuid][object] */ 


EXTERN_C const IID IID_IGPMBackup;

#if defined(__cplusplus) && !defined(CINTERFACE)
    
    MIDL_INTERFACE("D8A16A35-3B0D-416B-8D02-4DF6F95A7119")
    IGPMBackup : public IDispatch
    {
    public:
        virtual /* [helpstring][id][propget] */ HRESULT STDMETHODCALLTYPE get_ID( 
            /* [retval][out] */ BSTR *pVal) = 0;
        
        virtual /* [helpstring][id][propget] */ HRESULT STDMETHODCALLTYPE get_GPOID( 
            /* [retval][out] */ BSTR *pVal) = 0;
        
        virtual /* [helpstring][id][propget] */ HRESULT STDMETHODCALLTYPE get_GPODomain( 
            /* [retval][out] */ BSTR *pVal) = 0;
        
        virtual /* [helpstring][id][propget] */ HRESULT STDMETHODCALLTYPE get_GPODisplayName( 
            /* [retval][out] */ BSTR *pVal) = 0;
        
        virtual /* [helpstring][id][propget] */ HRESULT STDMETHODCALLTYPE get_Timestamp( 
            /* [retval][out] */ DATE *pVal) = 0;
        
        virtual /* [helpstring][id][propget] */ HRESULT STDMETHODCALLTYPE get_Comment( 
            /* [retval][out] */ BSTR *pVal) = 0;
        
        virtual /* [helpstring][id][propget] */ HRESULT STDMETHODCALLTYPE get_BackupDir( 
            /* [retval][out] */ BSTR *pVal) = 0;
        
        virtual /* [helpstring][id] */ HRESULT STDMETHODCALLTYPE Delete( void) = 0;
        
        virtual /* [helpstring][id] */ HRESULT STDMETHODCALLTYPE GenerateReport( 
            /* [in] */ GPMReportType gpmReportType,
            /* [optional][in] */ VARIANT *pvarGPMProgress,
            /* [optional][out] */ VARIANT *pvarGPMCancel,
            /* [retval][out] */ IGPMResult **ppIGPMResult) = 0;
        
        virtual /* [helpstring][id] */ HRESULT STDMETHODCALLTYPE GenerateReportToFile( 
            /* [in] */ GPMReportType gpmReportType,
            /* [in] */ BSTR bstrTargetFilePath,
            /* [retval][out] */ IGPMResult **ppIGPMResult) = 0;
        
    };
    
#else 	/* C style interface */

    typedef struct IGPMBackupVtbl
    {
        BEGIN_INTERFACE
        
        HRESULT ( STDMETHODCALLTYPE *QueryInterface )( 
            IGPMBackup * This,
            /* [in] */ REFIID riid,
            /* [iid_is][out] */ void **ppvObject);
        
        ULONG ( STDMETHODCALLTYPE *AddRef )( 
            IGPMBackup * This);
        
        ULONG ( STDMETHODCALLTYPE *Release )( 
            IGPMBackup * This);
        
        HRESULT ( STDMETHODCALLTYPE *GetTypeInfoCount )( 
            IGPMBackup * This,
            /* [out] */ UINT *pctinfo);
        
        HRESULT ( STDMETHODCALLTYPE *GetTypeInfo )( 
            IGPMBackup * This,
            /* [in] */ UINT iTInfo,
            /* [in] */ LCID lcid,
            /* [out] */ ITypeInfo **ppTInfo);
        
        HRESULT ( STDMETHODCALLTYPE *GetIDsOfNames )( 
            IGPMBackup * This,
            /* [in] */ REFIID riid,
            /* [size_is][in] */ LPOLESTR *rgszNames,
            /* [in] */ UINT cNames,
            /* [in] */ LCID lcid,
            /* [size_is][out] */ DISPID *rgDispId);
        
        /* [local] */ HRESULT ( STDMETHODCALLTYPE *Invoke )( 
            IGPMBackup * This,
            /* [in] */ DISPID dispIdMember,
            /* [in] */ REFIID riid,
            /* [in] */ LCID lcid,
            /* [in] */ WORD wFlags,
            /* [out][in] */ DISPPARAMS *pDispParams,
            /* [out] */ VARIANT *pVarResult,
            /* [out] */ EXCEPINFO *pExcepInfo,
            /* [out] */ UINT *puArgErr);
        
        /* [helpstring][id][propget] */ HRESULT ( STDMETHODCALLTYPE *get_ID )( 
            IGPMBackup * This,
            /* [retval][out] */ BSTR *pVal);
        
        /* [helpstring][id][propget] */ HRESULT ( STDMETHODCALLTYPE *get_GPOID )( 
            IGPMBackup * This,
            /* [retval][out] */ BSTR *pVal);
        
        /* [helpstring][id][propget] */ HRESULT ( STDMETHODCALLTYPE *get_GPODomain )( 
            IGPMBackup * This,
            /* [retval][out] */ BSTR *pVal);
        
        /* [helpstring][id][propget] */ HRESULT ( STDMETHODCALLTYPE *get_GPODisplayName )( 
            IGPMBackup * This,
            /* [retval][out] */ BSTR *pVal);
        
        /* [helpstring][id][propget] */ HRESULT ( STDMETHODCALLTYPE *get_Timestamp )( 
            IGPMBackup * This,
            /* [retval][out] */ DATE *pVal);
        
        /* [helpstring][id][propget] */ HRESULT ( STDMETHODCALLTYPE *get_Comment )( 
            IGPMBackup * This,
            /* [retval][out] */ BSTR *pVal);
        
        /* [helpstring][id][propget] */ HRESULT ( STDMETHODCALLTYPE *get_BackupDir )( 
            IGPMBackup * This,
            /* [retval][out] */ BSTR *pVal);
        
        /* [helpstring][id] */ HRESULT ( STDMETHODCALLTYPE *Delete )( 
            IGPMBackup * This);
        
        /* [helpstring][id] */ HRESULT ( STDMETHODCALLTYPE *GenerateReport )( 
            IGPMBackup * This,
            /* [in] */ GPMReportType gpmReportType,
            /* [optional][in] */ VARIANT *pvarGPMProgress,
            /* [optional][out] */ VARIANT *pvarGPMCancel,
            /* [retval][out] */ IGPMResult **ppIGPMResult);
        
        /* [helpstring][id] */ HRESULT ( STDMETHODCALLTYPE *GenerateReportToFile )( 
            IGPMBackup * This,
            /* [in] */ GPMReportType gpmReportType,
            /* [in] */ BSTR bstrTargetFilePath,
            /* [retval][out] */ IGPMResult **ppIGPMResult);
        
        END_INTERFACE
    } IGPMBackupVtbl;

    interface IGPMBackup
    {
        CONST_VTBL struct IGPMBackupVtbl *lpVtbl;
    };

    

#ifdef COBJMACROS


#define IGPMBackup_QueryInterface(This,riid,ppvObject)	\
    (This)->lpVtbl -> QueryInterface(This,riid,ppvObject)

#define IGPMBackup_AddRef(This)	\
    (This)->lpVtbl -> AddRef(This)

#define IGPMBackup_Release(This)	\
    (This)->lpVtbl -> Release(This)


#define IGPMBackup_GetTypeInfoCount(This,pctinfo)	\
    (This)->lpVtbl -> GetTypeInfoCount(This,pctinfo)

#define IGPMBackup_GetTypeInfo(This,iTInfo,lcid,ppTInfo)	\
    (This)->lpVtbl -> GetTypeInfo(This,iTInfo,lcid,ppTInfo)

#define IGPMBackup_GetIDsOfNames(This,riid,rgszNames,cNames,lcid,rgDispId)	\
    (This)->lpVtbl -> GetIDsOfNames(This,riid,rgszNames,cNames,lcid,rgDispId)

#define IGPMBackup_Invoke(This,dispIdMember,riid,lcid,wFlags,pDispParams,pVarResult,pExcepInfo,puArgErr)	\
    (This)->lpVtbl -> Invoke(This,dispIdMember,riid,lcid,wFlags,pDispParams,pVarResult,pExcepInfo,puArgErr)


#define IGPMBackup_get_ID(This,pVal)	\
    (This)->lpVtbl -> get_ID(This,pVal)

#define IGPMBackup_get_GPOID(This,pVal)	\
    (This)->lpVtbl -> get_GPOID(This,pVal)

#define IGPMBackup_get_GPODomain(This,pVal)	\
    (This)->lpVtbl -> get_GPODomain(This,pVal)

#define IGPMBackup_get_GPODisplayName(This,pVal)	\
    (This)->lpVtbl -> get_GPODisplayName(This,pVal)

#define IGPMBackup_get_Timestamp(This,pVal)	\
    (This)->lpVtbl -> get_Timestamp(This,pVal)

#define IGPMBackup_get_Comment(This,pVal)	\
    (This)->lpVtbl -> get_Comment(This,pVal)

#define IGPMBackup_get_BackupDir(This,pVal)	\
    (This)->lpVtbl -> get_BackupDir(This,pVal)

#define IGPMBackup_Delete(This)	\
    (This)->lpVtbl -> Delete(This)

#define IGPMBackup_GenerateReport(This,gpmReportType,pvarGPMProgress,pvarGPMCancel,ppIGPMResult)	\
    (This)->lpVtbl -> GenerateReport(This,gpmReportType,pvarGPMProgress,pvarGPMCancel,ppIGPMResult)

#define IGPMBackup_GenerateReportToFile(This,gpmReportType,bstrTargetFilePath,ppIGPMResult)	\
    (This)->lpVtbl -> GenerateReportToFile(This,gpmReportType,bstrTargetFilePath,ppIGPMResult)

#endif /* COBJMACROS */


#endif 	/* C style interface */



/* [helpstring][id][propget] */ HRESULT STDMETHODCALLTYPE IGPMBackup_get_ID_Proxy( 
    IGPMBackup * This,
    /* [retval][out] */ BSTR *pVal);


void __RPC_STUB IGPMBackup_get_ID_Stub(
    IRpcStubBuffer *This,
    IRpcChannelBuffer *_pRpcChannelBuffer,
    PRPC_MESSAGE _pRpcMessage,
    DWORD *_pdwStubPhase);


/* [helpstring][id][propget] */ HRESULT STDMETHODCALLTYPE IGPMBackup_get_GPOID_Proxy( 
    IGPMBackup * This,
    /* [retval][out] */ BSTR *pVal);


void __RPC_STUB IGPMBackup_get_GPOID_Stub(
    IRpcStubBuffer *This,
    IRpcChannelBuffer *_pRpcChannelBuffer,
    PRPC_MESSAGE _pRpcMessage,
    DWORD *_pdwStubPhase);


/* [helpstring][id][propget] */ HRESULT STDMETHODCALLTYPE IGPMBackup_get_GPODomain_Proxy( 
    IGPMBackup * This,
    /* [retval][out] */ BSTR *pVal);


void __RPC_STUB IGPMBackup_get_GPODomain_Stub(
    IRpcStubBuffer *This,
    IRpcChannelBuffer *_pRpcChannelBuffer,
    PRPC_MESSAGE _pRpcMessage,
    DWORD *_pdwStubPhase);


/* [helpstring][id][propget] */ HRESULT STDMETHODCALLTYPE IGPMBackup_get_GPODisplayName_Proxy( 
    IGPMBackup * This,
    /* [retval][out] */ BSTR *pVal);


void __RPC_STUB IGPMBackup_get_GPODisplayName_Stub(
    IRpcStubBuffer *This,
    IRpcChannelBuffer *_pRpcChannelBuffer,
    PRPC_MESSAGE _pRpcMessage,
    DWORD *_pdwStubPhase);


/* [helpstring][id][propget] */ HRESULT STDMETHODCALLTYPE IGPMBackup_get_Timestamp_Proxy( 
    IGPMBackup * This,
    /* [retval][out] */ DATE *pVal);


void __RPC_STUB IGPMBackup_get_Timestamp_Stub(
    IRpcStubBuffer *This,
    IRpcChannelBuffer *_pRpcChannelBuffer,
    PRPC_MESSAGE _pRpcMessage,
    DWORD *_pdwStubPhase);


/* [helpstring][id][propget] */ HRESULT STDMETHODCALLTYPE IGPMBackup_get_Comment_Proxy( 
    IGPMBackup * This,
    /* [retval][out] */ BSTR *pVal);


void __RPC_STUB IGPMBackup_get_Comment_Stub(
    IRpcStubBuffer *This,
    IRpcChannelBuffer *_pRpcChannelBuffer,
    PRPC_MESSAGE _pRpcMessage,
    DWORD *_pdwStubPhase);


/* [helpstring][id][propget] */ HRESULT STDMETHODCALLTYPE IGPMBackup_get_BackupDir_Proxy( 
    IGPMBackup * This,
    /* [retval][out] */ BSTR *pVal);


void __RPC_STUB IGPMBackup_get_BackupDir_Stub(
    IRpcStubBuffer *This,
    IRpcChannelBuffer *_pRpcChannelBuffer,
    PRPC_MESSAGE _pRpcMessage,
    DWORD *_pdwStubPhase);


/* [helpstring][id] */ HRESULT STDMETHODCALLTYPE IGPMBackup_Delete_Proxy( 
    IGPMBackup * This);


void __RPC_STUB IGPMBackup_Delete_Stub(
    IRpcStubBuffer *This,
    IRpcChannelBuffer *_pRpcChannelBuffer,
    PRPC_MESSAGE _pRpcMessage,
    DWORD *_pdwStubPhase);


/* [helpstring][id] */ HRESULT STDMETHODCALLTYPE IGPMBackup_GenerateReport_Proxy( 
    IGPMBackup * This,
    /* [in] */ GPMReportType gpmReportType,
    /* [optional][in] */ VARIANT *pvarGPMProgress,
    /* [optional][out] */ VARIANT *pvarGPMCancel,
    /* [retval][out] */ IGPMResult **ppIGPMResult);


void __RPC_STUB IGPMBackup_GenerateReport_Stub(
    IRpcStubBuffer *This,
    IRpcChannelBuffer *_pRpcChannelBuffer,
    PRPC_MESSAGE _pRpcMessage,
    DWORD *_pdwStubPhase);


/* [helpstring][id] */ HRESULT STDMETHODCALLTYPE IGPMBackup_GenerateReportToFile_Proxy( 
    IGPMBackup * This,
    /* [in] */ GPMReportType gpmReportType,
    /* [in] */ BSTR bstrTargetFilePath,
    /* [retval][out] */ IGPMResult **ppIGPMResult);


void __RPC_STUB IGPMBackup_GenerateReportToFile_Stub(
    IRpcStubBuffer *This,
    IRpcChannelBuffer *_pRpcChannelBuffer,
    PRPC_MESSAGE _pRpcMessage,
    DWORD *_pdwStubPhase);



#endif 	/* __IGPMBackup_INTERFACE_DEFINED__ */


#ifndef __IGPMBackupCollection_INTERFACE_DEFINED__
#define __IGPMBackupCollection_INTERFACE_DEFINED__

/* interface IGPMBackupCollection */
/* [unique][helpstring][dual][uuid][object] */ 


EXTERN_C const IID IID_IGPMBackupCollection;

#if defined(__cplusplus) && !defined(CINTERFACE)
    
    MIDL_INTERFACE("C786FC0F-26D8-4BAB-A745-39CA7E800CAC")
    IGPMBackupCollection : public IDispatch
    {
    public:
        virtual /* [helpstring][id][propget] */ HRESULT STDMETHODCALLTYPE get_Count( 
            /* [retval][out] */ long *pVal) = 0;
        
        virtual /* [helpstring][id][propget] */ HRESULT STDMETHODCALLTYPE get_Item( 
            long lIndex,
            /* [retval][out] */ VARIANT *pVal) = 0;
        
        virtual /* [helpstring][id][propget] */ HRESULT STDMETHODCALLTYPE get__NewEnum( 
            /* [retval][out] */ IEnumVARIANT **ppIGPMBackup) = 0;
        
    };
    
#else 	/* C style interface */

    typedef struct IGPMBackupCollectionVtbl
    {
        BEGIN_INTERFACE
        
        HRESULT ( STDMETHODCALLTYPE *QueryInterface )( 
            IGPMBackupCollection * This,
            /* [in] */ REFIID riid,
            /* [iid_is][out] */ void **ppvObject);
        
        ULONG ( STDMETHODCALLTYPE *AddRef )( 
            IGPMBackupCollection * This);
        
        ULONG ( STDMETHODCALLTYPE *Release )( 
            IGPMBackupCollection * This);
        
        HRESULT ( STDMETHODCALLTYPE *GetTypeInfoCount )( 
            IGPMBackupCollection * This,
            /* [out] */ UINT *pctinfo);
        
        HRESULT ( STDMETHODCALLTYPE *GetTypeInfo )( 
            IGPMBackupCollection * This,
            /* [in] */ UINT iTInfo,
            /* [in] */ LCID lcid,
            /* [out] */ ITypeInfo **ppTInfo);
        
        HRESULT ( STDMETHODCALLTYPE *GetIDsOfNames )( 
            IGPMBackupCollection * This,
            /* [in] */ REFIID riid,
            /* [size_is][in] */ LPOLESTR *rgszNames,
            /* [in] */ UINT cNames,
            /* [in] */ LCID lcid,
            /* [size_is][out] */ DISPID *rgDispId);
        
        /* [local] */ HRESULT ( STDMETHODCALLTYPE *Invoke )( 
            IGPMBackupCollection * This,
            /* [in] */ DISPID dispIdMember,
            /* [in] */ REFIID riid,
            /* [in] */ LCID lcid,
            /* [in] */ WORD wFlags,
            /* [out][in] */ DISPPARAMS *pDispParams,
            /* [out] */ VARIANT *pVarResult,
            /* [out] */ EXCEPINFO *pExcepInfo,
            /* [out] */ UINT *puArgErr);
        
        /* [helpstring][id][propget] */ HRESULT ( STDMETHODCALLTYPE *get_Count )( 
            IGPMBackupCollection * This,
            /* [retval][out] */ long *pVal);
        
        /* [helpstring][id][propget] */ HRESULT ( STDMETHODCALLTYPE *get_Item )( 
            IGPMBackupCollection * This,
            long lIndex,
            /* [retval][out] */ VARIANT *pVal);
        
        /* [helpstring][id][propget] */ HRESULT ( STDMETHODCALLTYPE *get__NewEnum )( 
            IGPMBackupCollection * This,
            /* [retval][out] */ IEnumVARIANT **ppIGPMBackup);
        
        END_INTERFACE
    } IGPMBackupCollectionVtbl;

    interface IGPMBackupCollection
    {
        CONST_VTBL struct IGPMBackupCollectionVtbl *lpVtbl;
    };

    

#ifdef COBJMACROS


#define IGPMBackupCollection_QueryInterface(This,riid,ppvObject)	\
    (This)->lpVtbl -> QueryInterface(This,riid,ppvObject)

#define IGPMBackupCollection_AddRef(This)	\
    (This)->lpVtbl -> AddRef(This)

#define IGPMBackupCollection_Release(This)	\
    (This)->lpVtbl -> Release(This)


#define IGPMBackupCollection_GetTypeInfoCount(This,pctinfo)	\
    (This)->lpVtbl -> GetTypeInfoCount(This,pctinfo)

#define IGPMBackupCollection_GetTypeInfo(This,iTInfo,lcid,ppTInfo)	\
    (This)->lpVtbl -> GetTypeInfo(This,iTInfo,lcid,ppTInfo)

#define IGPMBackupCollection_GetIDsOfNames(This,riid,rgszNames,cNames,lcid,rgDispId)	\
    (This)->lpVtbl -> GetIDsOfNames(This,riid,rgszNames,cNames,lcid,rgDispId)

#define IGPMBackupCollection_Invoke(This,dispIdMember,riid,lcid,wFlags,pDispParams,pVarResult,pExcepInfo,puArgErr)	\
    (This)->lpVtbl -> Invoke(This,dispIdMember,riid,lcid,wFlags,pDispParams,pVarResult,pExcepInfo,puArgErr)


#define IGPMBackupCollection_get_Count(This,pVal)	\
    (This)->lpVtbl -> get_Count(This,pVal)

#define IGPMBackupCollection_get_Item(This,lIndex,pVal)	\
    (This)->lpVtbl -> get_Item(This,lIndex,pVal)

#define IGPMBackupCollection_get__NewEnum(This,ppIGPMBackup)	\
    (This)->lpVtbl -> get__NewEnum(This,ppIGPMBackup)

#endif /* COBJMACROS */


#endif 	/* C style interface */



/* [helpstring][id][propget] */ HRESULT STDMETHODCALLTYPE IGPMBackupCollection_get_Count_Proxy( 
    IGPMBackupCollection * This,
    /* [retval][out] */ long *pVal);


void __RPC_STUB IGPMBackupCollection_get_Count_Stub(
    IRpcStubBuffer *This,
    IRpcChannelBuffer *_pRpcChannelBuffer,
    PRPC_MESSAGE _pRpcMessage,
    DWORD *_pdwStubPhase);


/* [helpstring][id][propget] */ HRESULT STDMETHODCALLTYPE IGPMBackupCollection_get_Item_Proxy( 
    IGPMBackupCollection * This,
    long lIndex,
    /* [retval][out] */ VARIANT *pVal);


void __RPC_STUB IGPMBackupCollection_get_Item_Stub(
    IRpcStubBuffer *This,
    IRpcChannelBuffer *_pRpcChannelBuffer,
    PRPC_MESSAGE _pRpcMessage,
    DWORD *_pdwStubPhase);


/* [helpstring][id][propget] */ HRESULT STDMETHODCALLTYPE IGPMBackupCollection_get__NewEnum_Proxy( 
    IGPMBackupCollection * This,
    /* [retval][out] */ IEnumVARIANT **ppIGPMBackup);


void __RPC_STUB IGPMBackupCollection_get__NewEnum_Stub(
    IRpcStubBuffer *This,
    IRpcChannelBuffer *_pRpcChannelBuffer,
    PRPC_MESSAGE _pRpcMessage,
    DWORD *_pdwStubPhase);



#endif 	/* __IGPMBackupCollection_INTERFACE_DEFINED__ */


#ifndef __IGPMSOM_INTERFACE_DEFINED__
#define __IGPMSOM_INTERFACE_DEFINED__

/* interface IGPMSOM */
/* [unique][helpstring][dual][uuid][object] */ 

typedef /* [public][public][public][public][public] */ 
enum __MIDL_IGPMSOM_0001
    {	somSite	= 0,
	somDomain	= somSite + 1,
	somOU	= somDomain + 1
    } 	GPMSOMType;


EXTERN_C const IID IID_IGPMSOM;

#if defined(__cplusplus) && !defined(CINTERFACE)
    
    MIDL_INTERFACE("C0A7F09E-05A1-4F0C-8158-9E5C33684F6B")
    IGPMSOM : public IDispatch
    {
    public:
        virtual /* [helpstring][id][propget] */ HRESULT STDMETHODCALLTYPE get_GPOInheritanceBlocked( 
            /* [retval][out] */ VARIANT_BOOL *pVal) = 0;
        
        virtual /* [helpstring][id][propput] */ HRESULT STDMETHODCALLTYPE put_GPOInheritanceBlocked( 
            /* [in] */ VARIANT_BOOL newVal) = 0;
        
        virtual /* [helpstring][id][propget] */ HRESULT STDMETHODCALLTYPE get_Name( 
            /* [retval][out] */ BSTR *pVal) = 0;
        
        virtual /* [helpstring][id][propget] */ HRESULT STDMETHODCALLTYPE get_Path( 
            /* [retval][out] */ BSTR *pVal) = 0;
        
        virtual /* [helpstring][id] */ HRESULT STDMETHODCALLTYPE CreateGPOLink( 
            /* [in] */ long lLinkPos,
            /* [in] */ IGPMGPO *pGPO,
            /* [retval][out] */ IGPMGPOLink **ppNewGPOLink) = 0;
        
        virtual /* [helpstring][id][propget] */ HRESULT STDMETHODCALLTYPE get_Type( 
            /* [retval][out] */ GPMSOMType *pVal) = 0;
        
        virtual /* [helpstring][id] */ HRESULT STDMETHODCALLTYPE GetGPOLinks( 
            /* [retval][out] */ IGPMGPOLinksCollection **ppGPOLinks) = 0;
        
        virtual /* [helpstring][id] */ HRESULT STDMETHODCALLTYPE GetInheritedGPOLinks( 
            /* [retval][out] */ IGPMGPOLinksCollection **ppGPOLinks) = 0;
        
        virtual /* [helpstring][id] */ HRESULT STDMETHODCALLTYPE GetSecurityInfo( 
            /* [retval][out] */ IGPMSecurityInfo **ppSecurityInfo) = 0;
        
        virtual /* [helpstring][id] */ HRESULT STDMETHODCALLTYPE SetSecurityInfo( 
            /* [in] */ IGPMSecurityInfo *pSecurityInfo) = 0;
        
    };
    
#else 	/* C style interface */

    typedef struct IGPMSOMVtbl
    {
        BEGIN_INTERFACE
        
        HRESULT ( STDMETHODCALLTYPE *QueryInterface )( 
            IGPMSOM * This,
            /* [in] */ REFIID riid,
            /* [iid_is][out] */ void **ppvObject);
        
        ULONG ( STDMETHODCALLTYPE *AddRef )( 
            IGPMSOM * This);
        
        ULONG ( STDMETHODCALLTYPE *Release )( 
            IGPMSOM * This);
        
        HRESULT ( STDMETHODCALLTYPE *GetTypeInfoCount )( 
            IGPMSOM * This,
            /* [out] */ UINT *pctinfo);
        
        HRESULT ( STDMETHODCALLTYPE *GetTypeInfo )( 
            IGPMSOM * This,
            /* [in] */ UINT iTInfo,
            /* [in] */ LCID lcid,
            /* [out] */ ITypeInfo **ppTInfo);
        
        HRESULT ( STDMETHODCALLTYPE *GetIDsOfNames )( 
            IGPMSOM * This,
            /* [in] */ REFIID riid,
            /* [size_is][in] */ LPOLESTR *rgszNames,
            /* [in] */ UINT cNames,
            /* [in] */ LCID lcid,
            /* [size_is][out] */ DISPID *rgDispId);
        
        /* [local] */ HRESULT ( STDMETHODCALLTYPE *Invoke )( 
            IGPMSOM * This,
            /* [in] */ DISPID dispIdMember,
            /* [in] */ REFIID riid,
            /* [in] */ LCID lcid,
            /* [in] */ WORD wFlags,
            /* [out][in] */ DISPPARAMS *pDispParams,
            /* [out] */ VARIANT *pVarResult,
            /* [out] */ EXCEPINFO *pExcepInfo,
            /* [out] */ UINT *puArgErr);
        
        /* [helpstring][id][propget] */ HRESULT ( STDMETHODCALLTYPE *get_GPOInheritanceBlocked )( 
            IGPMSOM * This,
            /* [retval][out] */ VARIANT_BOOL *pVal);
        
        /* [helpstring][id][propput] */ HRESULT ( STDMETHODCALLTYPE *put_GPOInheritanceBlocked )( 
            IGPMSOM * This,
            /* [in] */ VARIANT_BOOL newVal);
        
        /* [helpstring][id][propget] */ HRESULT ( STDMETHODCALLTYPE *get_Name )( 
            IGPMSOM * This,
            /* [retval][out] */ BSTR *pVal);
        
        /* [helpstring][id][propget] */ HRESULT ( STDMETHODCALLTYPE *get_Path )( 
            IGPMSOM * This,
            /* [retval][out] */ BSTR *pVal);
        
        /* [helpstring][id] */ HRESULT ( STDMETHODCALLTYPE *CreateGPOLink )( 
            IGPMSOM * This,
            /* [in] */ long lLinkPos,
            /* [in] */ IGPMGPO *pGPO,
            /* [retval][out] */ IGPMGPOLink **ppNewGPOLink);
        
        /* [helpstring][id][propget] */ HRESULT ( STDMETHODCALLTYPE *get_Type )( 
            IGPMSOM * This,
            /* [retval][out] */ GPMSOMType *pVal);
        
        /* [helpstring][id] */ HRESULT ( STDMETHODCALLTYPE *GetGPOLinks )( 
            IGPMSOM * This,
            /* [retval][out] */ IGPMGPOLinksCollection **ppGPOLinks);
        
        /* [helpstring][id] */ HRESULT ( STDMETHODCALLTYPE *GetInheritedGPOLinks )( 
            IGPMSOM * This,
            /* [retval][out] */ IGPMGPOLinksCollection **ppGPOLinks);
        
        /* [helpstring][id] */ HRESULT ( STDMETHODCALLTYPE *GetSecurityInfo )( 
            IGPMSOM * This,
            /* [retval][out] */ IGPMSecurityInfo **ppSecurityInfo);
        
        /* [helpstring][id] */ HRESULT ( STDMETHODCALLTYPE *SetSecurityInfo )( 
            IGPMSOM * This,
            /* [in] */ IGPMSecurityInfo *pSecurityInfo);
        
        END_INTERFACE
    } IGPMSOMVtbl;

    interface IGPMSOM
    {
        CONST_VTBL struct IGPMSOMVtbl *lpVtbl;
    };

    

#ifdef COBJMACROS


#define IGPMSOM_QueryInterface(This,riid,ppvObject)	\
    (This)->lpVtbl -> QueryInterface(This,riid,ppvObject)

#define IGPMSOM_AddRef(This)	\
    (This)->lpVtbl -> AddRef(This)

#define IGPMSOM_Release(This)	\
    (This)->lpVtbl -> Release(This)


#define IGPMSOM_GetTypeInfoCount(This,pctinfo)	\
    (This)->lpVtbl -> GetTypeInfoCount(This,pctinfo)

#define IGPMSOM_GetTypeInfo(This,iTInfo,lcid,ppTInfo)	\
    (This)->lpVtbl -> GetTypeInfo(This,iTInfo,lcid,ppTInfo)

#define IGPMSOM_GetIDsOfNames(This,riid,rgszNames,cNames,lcid,rgDispId)	\
    (This)->lpVtbl -> GetIDsOfNames(This,riid,rgszNames,cNames,lcid,rgDispId)

#define IGPMSOM_Invoke(This,dispIdMember,riid,lcid,wFlags,pDispParams,pVarResult,pExcepInfo,puArgErr)	\
    (This)->lpVtbl -> Invoke(This,dispIdMember,riid,lcid,wFlags,pDispParams,pVarResult,pExcepInfo,puArgErr)


#define IGPMSOM_get_GPOInheritanceBlocked(This,pVal)	\
    (This)->lpVtbl -> get_GPOInheritanceBlocked(This,pVal)

#define IGPMSOM_put_GPOInheritanceBlocked(This,newVal)	\
    (This)->lpVtbl -> put_GPOInheritanceBlocked(This,newVal)

#define IGPMSOM_get_Name(This,pVal)	\
    (This)->lpVtbl -> get_Name(This,pVal)

#define IGPMSOM_get_Path(This,pVal)	\
    (This)->lpVtbl -> get_Path(This,pVal)

#define IGPMSOM_CreateGPOLink(This,lLinkPos,pGPO,ppNewGPOLink)	\
    (This)->lpVtbl -> CreateGPOLink(This,lLinkPos,pGPO,ppNewGPOLink)

#define IGPMSOM_get_Type(This,pVal)	\
    (This)->lpVtbl -> get_Type(This,pVal)

#define IGPMSOM_GetGPOLinks(This,ppGPOLinks)	\
    (This)->lpVtbl -> GetGPOLinks(This,ppGPOLinks)

#define IGPMSOM_GetInheritedGPOLinks(This,ppGPOLinks)	\
    (This)->lpVtbl -> GetInheritedGPOLinks(This,ppGPOLinks)

#define IGPMSOM_GetSecurityInfo(This,ppSecurityInfo)	\
    (This)->lpVtbl -> GetSecurityInfo(This,ppSecurityInfo)

#define IGPMSOM_SetSecurityInfo(This,pSecurityInfo)	\
    (This)->lpVtbl -> SetSecurityInfo(This,pSecurityInfo)

#endif /* COBJMACROS */


#endif 	/* C style interface */



/* [helpstring][id][propget] */ HRESULT STDMETHODCALLTYPE IGPMSOM_get_GPOInheritanceBlocked_Proxy( 
    IGPMSOM * This,
    /* [retval][out] */ VARIANT_BOOL *pVal);


void __RPC_STUB IGPMSOM_get_GPOInheritanceBlocked_Stub(
    IRpcStubBuffer *This,
    IRpcChannelBuffer *_pRpcChannelBuffer,
    PRPC_MESSAGE _pRpcMessage,
    DWORD *_pdwStubPhase);


/* [helpstring][id][propput] */ HRESULT STDMETHODCALLTYPE IGPMSOM_put_GPOInheritanceBlocked_Proxy( 
    IGPMSOM * This,
    /* [in] */ VARIANT_BOOL newVal);


void __RPC_STUB IGPMSOM_put_GPOInheritanceBlocked_Stub(
    IRpcStubBuffer *This,
    IRpcChannelBuffer *_pRpcChannelBuffer,
    PRPC_MESSAGE _pRpcMessage,
    DWORD *_pdwStubPhase);


/* [helpstring][id][propget] */ HRESULT STDMETHODCALLTYPE IGPMSOM_get_Name_Proxy( 
    IGPMSOM * This,
    /* [retval][out] */ BSTR *pVal);


void __RPC_STUB IGPMSOM_get_Name_Stub(
    IRpcStubBuffer *This,
    IRpcChannelBuffer *_pRpcChannelBuffer,
    PRPC_MESSAGE _pRpcMessage,
    DWORD *_pdwStubPhase);


/* [helpstring][id][propget] */ HRESULT STDMETHODCALLTYPE IGPMSOM_get_Path_Proxy( 
    IGPMSOM * This,
    /* [retval][out] */ BSTR *pVal);


void __RPC_STUB IGPMSOM_get_Path_Stub(
    IRpcStubBuffer *This,
    IRpcChannelBuffer *_pRpcChannelBuffer,
    PRPC_MESSAGE _pRpcMessage,
    DWORD *_pdwStubPhase);


/* [helpstring][id] */ HRESULT STDMETHODCALLTYPE IGPMSOM_CreateGPOLink_Proxy( 
    IGPMSOM * This,
    /* [in] */ long lLinkPos,
    /* [in] */ IGPMGPO *pGPO,
    /* [retval][out] */ IGPMGPOLink **ppNewGPOLink);


void __RPC_STUB IGPMSOM_CreateGPOLink_Stub(
    IRpcStubBuffer *This,
    IRpcChannelBuffer *_pRpcChannelBuffer,
    PRPC_MESSAGE _pRpcMessage,
    DWORD *_pdwStubPhase);


/* [helpstring][id][propget] */ HRESULT STDMETHODCALLTYPE IGPMSOM_get_Type_Proxy( 
    IGPMSOM * This,
    /* [retval][out] */ GPMSOMType *pVal);


void __RPC_STUB IGPMSOM_get_Type_Stub(
    IRpcStubBuffer *This,
    IRpcChannelBuffer *_pRpcChannelBuffer,
    PRPC_MESSAGE _pRpcMessage,
    DWORD *_pdwStubPhase);


/* [helpstring][id] */ HRESULT STDMETHODCALLTYPE IGPMSOM_GetGPOLinks_Proxy( 
    IGPMSOM * This,
    /* [retval][out] */ IGPMGPOLinksCollection **ppGPOLinks);


void __RPC_STUB IGPMSOM_GetGPOLinks_Stub(
    IRpcStubBuffer *This,
    IRpcChannelBuffer *_pRpcChannelBuffer,
    PRPC_MESSAGE _pRpcMessage,
    DWORD *_pdwStubPhase);


/* [helpstring][id] */ HRESULT STDMETHODCALLTYPE IGPMSOM_GetInheritedGPOLinks_Proxy( 
    IGPMSOM * This,
    /* [retval][out] */ IGPMGPOLinksCollection **ppGPOLinks);


void __RPC_STUB IGPMSOM_GetInheritedGPOLinks_Stub(
    IRpcStubBuffer *This,
    IRpcChannelBuffer *_pRpcChannelBuffer,
    PRPC_MESSAGE _pRpcMessage,
    DWORD *_pdwStubPhase);


/* [helpstring][id] */ HRESULT STDMETHODCALLTYPE IGPMSOM_GetSecurityInfo_Proxy( 
    IGPMSOM * This,
    /* [retval][out] */ IGPMSecurityInfo **ppSecurityInfo);


void __RPC_STUB IGPMSOM_GetSecurityInfo_Stub(
    IRpcStubBuffer *This,
    IRpcChannelBuffer *_pRpcChannelBuffer,
    PRPC_MESSAGE _pRpcMessage,
    DWORD *_pdwStubPhase);


/* [helpstring][id] */ HRESULT STDMETHODCALLTYPE IGPMSOM_SetSecurityInfo_Proxy( 
    IGPMSOM * This,
    /* [in] */ IGPMSecurityInfo *pSecurityInfo);


void __RPC_STUB IGPMSOM_SetSecurityInfo_Stub(
    IRpcStubBuffer *This,
    IRpcChannelBuffer *_pRpcChannelBuffer,
    PRPC_MESSAGE _pRpcMessage,
    DWORD *_pdwStubPhase);



#endif 	/* __IGPMSOM_INTERFACE_DEFINED__ */


#ifndef __IGPMSOMCollection_INTERFACE_DEFINED__
#define __IGPMSOMCollection_INTERFACE_DEFINED__

/* interface IGPMSOMCollection */
/* [unique][helpstring][dual][uuid][object] */ 


EXTERN_C const IID IID_IGPMSOMCollection;

#if defined(__cplusplus) && !defined(CINTERFACE)
    
    MIDL_INTERFACE("ADC1688E-00E4-4495-ABBA-BED200DF0CAB")
    IGPMSOMCollection : public IDispatch
    {
    public:
        virtual /* [helpstring][id][propget] */ HRESULT STDMETHODCALLTYPE get_Count( 
            /* [retval][out] */ long *pVal) = 0;
        
        virtual /* [helpstring][id][propget] */ HRESULT STDMETHODCALLTYPE get_Item( 
            long lIndex,
            /* [retval][out] */ VARIANT *pVal) = 0;
        
        virtual /* [helpstring][id][propget] */ HRESULT STDMETHODCALLTYPE get__NewEnum( 
            /* [retval][out] */ IEnumVARIANT **ppIGPMSOM) = 0;
        
    };
    
#else 	/* C style interface */

    typedef struct IGPMSOMCollectionVtbl
    {
        BEGIN_INTERFACE
        
        HRESULT ( STDMETHODCALLTYPE *QueryInterface )( 
            IGPMSOMCollection * This,
            /* [in] */ REFIID riid,
            /* [iid_is][out] */ void **ppvObject);
        
        ULONG ( STDMETHODCALLTYPE *AddRef )( 
            IGPMSOMCollection * This);
        
        ULONG ( STDMETHODCALLTYPE *Release )( 
            IGPMSOMCollection * This);
        
        HRESULT ( STDMETHODCALLTYPE *GetTypeInfoCount )( 
            IGPMSOMCollection * This,
            /* [out] */ UINT *pctinfo);
        
        HRESULT ( STDMETHODCALLTYPE *GetTypeInfo )( 
            IGPMSOMCollection * This,
            /* [in] */ UINT iTInfo,
            /* [in] */ LCID lcid,
            /* [out] */ ITypeInfo **ppTInfo);
        
        HRESULT ( STDMETHODCALLTYPE *GetIDsOfNames )( 
            IGPMSOMCollection * This,
            /* [in] */ REFIID riid,
            /* [size_is][in] */ LPOLESTR *rgszNames,
            /* [in] */ UINT cNames,
            /* [in] */ LCID lcid,
            /* [size_is][out] */ DISPID *rgDispId);
        
        /* [local] */ HRESULT ( STDMETHODCALLTYPE *Invoke )( 
            IGPMSOMCollection * This,
            /* [in] */ DISPID dispIdMember,
            /* [in] */ REFIID riid,
            /* [in] */ LCID lcid,
            /* [in] */ WORD wFlags,
            /* [out][in] */ DISPPARAMS *pDispParams,
            /* [out] */ VARIANT *pVarResult,
            /* [out] */ EXCEPINFO *pExcepInfo,
            /* [out] */ UINT *puArgErr);
        
        /* [helpstring][id][propget] */ HRESULT ( STDMETHODCALLTYPE *get_Count )( 
            IGPMSOMCollection * This,
            /* [retval][out] */ long *pVal);
        
        /* [helpstring][id][propget] */ HRESULT ( STDMETHODCALLTYPE *get_Item )( 
            IGPMSOMCollection * This,
            long lIndex,
            /* [retval][out] */ VARIANT *pVal);
        
        /* [helpstring][id][propget] */ HRESULT ( STDMETHODCALLTYPE *get__NewEnum )( 
            IGPMSOMCollection * This,
            /* [retval][out] */ IEnumVARIANT **ppIGPMSOM);
        
        END_INTERFACE
    } IGPMSOMCollectionVtbl;

    interface IGPMSOMCollection
    {
        CONST_VTBL struct IGPMSOMCollectionVtbl *lpVtbl;
    };

    

#ifdef COBJMACROS


#define IGPMSOMCollection_QueryInterface(This,riid,ppvObject)	\
    (This)->lpVtbl -> QueryInterface(This,riid,ppvObject)

#define IGPMSOMCollection_AddRef(This)	\
    (This)->lpVtbl -> AddRef(This)

#define IGPMSOMCollection_Release(This)	\
    (This)->lpVtbl -> Release(This)


#define IGPMSOMCollection_GetTypeInfoCount(This,pctinfo)	\
    (This)->lpVtbl -> GetTypeInfoCount(This,pctinfo)

#define IGPMSOMCollection_GetTypeInfo(This,iTInfo,lcid,ppTInfo)	\
    (This)->lpVtbl -> GetTypeInfo(This,iTInfo,lcid,ppTInfo)

#define IGPMSOMCollection_GetIDsOfNames(This,riid,rgszNames,cNames,lcid,rgDispId)	\
    (This)->lpVtbl -> GetIDsOfNames(This,riid,rgszNames,cNames,lcid,rgDispId)

#define IGPMSOMCollection_Invoke(This,dispIdMember,riid,lcid,wFlags,pDispParams,pVarResult,pExcepInfo,puArgErr)	\
    (This)->lpVtbl -> Invoke(This,dispIdMember,riid,lcid,wFlags,pDispParams,pVarResult,pExcepInfo,puArgErr)


#define IGPMSOMCollection_get_Count(This,pVal)	\
    (This)->lpVtbl -> get_Count(This,pVal)

#define IGPMSOMCollection_get_Item(This,lIndex,pVal)	\
    (This)->lpVtbl -> get_Item(This,lIndex,pVal)

#define IGPMSOMCollection_get__NewEnum(This,ppIGPMSOM)	\
    (This)->lpVtbl -> get__NewEnum(This,ppIGPMSOM)

#endif /* COBJMACROS */


#endif 	/* C style interface */



/* [helpstring][id][propget] */ HRESULT STDMETHODCALLTYPE IGPMSOMCollection_get_Count_Proxy( 
    IGPMSOMCollection * This,
    /* [retval][out] */ long *pVal);


void __RPC_STUB IGPMSOMCollection_get_Count_Stub(
    IRpcStubBuffer *This,
    IRpcChannelBuffer *_pRpcChannelBuffer,
    PRPC_MESSAGE _pRpcMessage,
    DWORD *_pdwStubPhase);


/* [helpstring][id][propget] */ HRESULT STDMETHODCALLTYPE IGPMSOMCollection_get_Item_Proxy( 
    IGPMSOMCollection * This,
    long lIndex,
    /* [retval][out] */ VARIANT *pVal);


void __RPC_STUB IGPMSOMCollection_get_Item_Stub(
    IRpcStubBuffer *This,
    IRpcChannelBuffer *_pRpcChannelBuffer,
    PRPC_MESSAGE _pRpcMessage,
    DWORD *_pdwStubPhase);


/* [helpstring][id][propget] */ HRESULT STDMETHODCALLTYPE IGPMSOMCollection_get__NewEnum_Proxy( 
    IGPMSOMCollection * This,
    /* [retval][out] */ IEnumVARIANT **ppIGPMSOM);


void __RPC_STUB IGPMSOMCollection_get__NewEnum_Stub(
    IRpcStubBuffer *This,
    IRpcChannelBuffer *_pRpcChannelBuffer,
    PRPC_MESSAGE _pRpcMessage,
    DWORD *_pdwStubPhase);



#endif 	/* __IGPMSOMCollection_INTERFACE_DEFINED__ */


#ifndef __IGPMWMIFilter_INTERFACE_DEFINED__
#define __IGPMWMIFilter_INTERFACE_DEFINED__

/* interface IGPMWMIFilter */
/* [unique][helpstring][dual][uuid][object] */ 


EXTERN_C const IID IID_IGPMWMIFilter;

#if defined(__cplusplus) && !defined(CINTERFACE)
    
    MIDL_INTERFACE("EF2FF9B4-3C27-459A-B979-038305CEC75D")
    IGPMWMIFilter : public IDispatch
    {
    public:
        virtual /* [helpstring][id][propget] */ HRESULT STDMETHODCALLTYPE get_Path( 
            /* [retval][out] */ BSTR *pVal) = 0;
        
        virtual /* [helpstring][id][propput] */ HRESULT STDMETHODCALLTYPE put_Name( 
            /* [in] */ BSTR newVal) = 0;
        
        virtual /* [helpstring][id][propget] */ HRESULT STDMETHODCALLTYPE get_Name( 
            /* [retval][out] */ BSTR *pVal) = 0;
        
        virtual /* [helpstring][id][propput] */ HRESULT STDMETHODCALLTYPE put_Description( 
            /* [in] */ BSTR newVal) = 0;
        
        virtual /* [helpstring][id][propget] */ HRESULT STDMETHODCALLTYPE get_Description( 
            /* [retval][out] */ BSTR *pVal) = 0;
        
        virtual /* [helpstring][id] */ HRESULT STDMETHODCALLTYPE GetQueryList( 
            /* [retval][out] */ VARIANT *pQryList) = 0;
        
        virtual /* [helpstring][id] */ HRESULT STDMETHODCALLTYPE GetSecurityInfo( 
            /* [retval][out] */ IGPMSecurityInfo **ppSecurityInfo) = 0;
        
        virtual /* [helpstring][id] */ HRESULT STDMETHODCALLTYPE SetSecurityInfo( 
            /* [in] */ IGPMSecurityInfo *pSecurityInfo) = 0;
        
    };
    
#else 	/* C style interface */

    typedef struct IGPMWMIFilterVtbl
    {
        BEGIN_INTERFACE
        
        HRESULT ( STDMETHODCALLTYPE *QueryInterface )( 
            IGPMWMIFilter * This,
            /* [in] */ REFIID riid,
            /* [iid_is][out] */ void **ppvObject);
        
        ULONG ( STDMETHODCALLTYPE *AddRef )( 
            IGPMWMIFilter * This);
        
        ULONG ( STDMETHODCALLTYPE *Release )( 
            IGPMWMIFilter * This);
        
        HRESULT ( STDMETHODCALLTYPE *GetTypeInfoCount )( 
            IGPMWMIFilter * This,
            /* [out] */ UINT *pctinfo);
        
        HRESULT ( STDMETHODCALLTYPE *GetTypeInfo )( 
            IGPMWMIFilter * This,
            /* [in] */ UINT iTInfo,
            /* [in] */ LCID lcid,
            /* [out] */ ITypeInfo **ppTInfo);
        
        HRESULT ( STDMETHODCALLTYPE *GetIDsOfNames )( 
            IGPMWMIFilter * This,
            /* [in] */ REFIID riid,
            /* [size_is][in] */ LPOLESTR *rgszNames,
            /* [in] */ UINT cNames,
            /* [in] */ LCID lcid,
            /* [size_is][out] */ DISPID *rgDispId);
        
        /* [local] */ HRESULT ( STDMETHODCALLTYPE *Invoke )( 
            IGPMWMIFilter * This,
            /* [in] */ DISPID dispIdMember,
            /* [in] */ REFIID riid,
            /* [in] */ LCID lcid,
            /* [in] */ WORD wFlags,
            /* [out][in] */ DISPPARAMS *pDispParams,
            /* [out] */ VARIANT *pVarResult,
            /* [out] */ EXCEPINFO *pExcepInfo,
            /* [out] */ UINT *puArgErr);
        
        /* [helpstring][id][propget] */ HRESULT ( STDMETHODCALLTYPE *get_Path )( 
            IGPMWMIFilter * This,
            /* [retval][out] */ BSTR *pVal);
        
        /* [helpstring][id][propput] */ HRESULT ( STDMETHODCALLTYPE *put_Name )( 
            IGPMWMIFilter * This,
            /* [in] */ BSTR newVal);
        
        /* [helpstring][id][propget] */ HRESULT ( STDMETHODCALLTYPE *get_Name )( 
            IGPMWMIFilter * This,
            /* [retval][out] */ BSTR *pVal);
        
        /* [helpstring][id][propput] */ HRESULT ( STDMETHODCALLTYPE *put_Description )( 
            IGPMWMIFilter * This,
            /* [in] */ BSTR newVal);
        
        /* [helpstring][id][propget] */ HRESULT ( STDMETHODCALLTYPE *get_Description )( 
            IGPMWMIFilter * This,
            /* [retval][out] */ BSTR *pVal);
        
        /* [helpstring][id] */ HRESULT ( STDMETHODCALLTYPE *GetQueryList )( 
            IGPMWMIFilter * This,
            /* [retval][out] */ VARIANT *pQryList);
        
        /* [helpstring][id] */ HRESULT ( STDMETHODCALLTYPE *GetSecurityInfo )( 
            IGPMWMIFilter * This,
            /* [retval][out] */ IGPMSecurityInfo **ppSecurityInfo);
        
        /* [helpstring][id] */ HRESULT ( STDMETHODCALLTYPE *SetSecurityInfo )( 
            IGPMWMIFilter * This,
            /* [in] */ IGPMSecurityInfo *pSecurityInfo);
        
        END_INTERFACE
    } IGPMWMIFilterVtbl;

    interface IGPMWMIFilter
    {
        CONST_VTBL struct IGPMWMIFilterVtbl *lpVtbl;
    };

    

#ifdef COBJMACROS


#define IGPMWMIFilter_QueryInterface(This,riid,ppvObject)	\
    (This)->lpVtbl -> QueryInterface(This,riid,ppvObject)

#define IGPMWMIFilter_AddRef(This)	\
    (This)->lpVtbl -> AddRef(This)

#define IGPMWMIFilter_Release(This)	\
    (This)->lpVtbl -> Release(This)


#define IGPMWMIFilter_GetTypeInfoCount(This,pctinfo)	\
    (This)->lpVtbl -> GetTypeInfoCount(This,pctinfo)

#define IGPMWMIFilter_GetTypeInfo(This,iTInfo,lcid,ppTInfo)	\
    (This)->lpVtbl -> GetTypeInfo(This,iTInfo,lcid,ppTInfo)

#define IGPMWMIFilter_GetIDsOfNames(This,riid,rgszNames,cNames,lcid,rgDispId)	\
    (This)->lpVtbl -> GetIDsOfNames(This,riid,rgszNames,cNames,lcid,rgDispId)

#define IGPMWMIFilter_Invoke(This,dispIdMember,riid,lcid,wFlags,pDispParams,pVarResult,pExcepInfo,puArgErr)	\
    (This)->lpVtbl -> Invoke(This,dispIdMember,riid,lcid,wFlags,pDispParams,pVarResult,pExcepInfo,puArgErr)


#define IGPMWMIFilter_get_Path(This,pVal)	\
    (This)->lpVtbl -> get_Path(This,pVal)

#define IGPMWMIFilter_put_Name(This,newVal)	\
    (This)->lpVtbl -> put_Name(This,newVal)

#define IGPMWMIFilter_get_Name(This,pVal)	\
    (This)->lpVtbl -> get_Name(This,pVal)

#define IGPMWMIFilter_put_Description(This,newVal)	\
    (This)->lpVtbl -> put_Description(This,newVal)

#define IGPMWMIFilter_get_Description(This,pVal)	\
    (This)->lpVtbl -> get_Description(This,pVal)

#define IGPMWMIFilter_GetQueryList(This,pQryList)	\
    (This)->lpVtbl -> GetQueryList(This,pQryList)

#define IGPMWMIFilter_GetSecurityInfo(This,ppSecurityInfo)	\
    (This)->lpVtbl -> GetSecurityInfo(This,ppSecurityInfo)

#define IGPMWMIFilter_SetSecurityInfo(This,pSecurityInfo)	\
    (This)->lpVtbl -> SetSecurityInfo(This,pSecurityInfo)

#endif /* COBJMACROS */


#endif 	/* C style interface */



/* [helpstring][id][propget] */ HRESULT STDMETHODCALLTYPE IGPMWMIFilter_get_Path_Proxy( 
    IGPMWMIFilter * This,
    /* [retval][out] */ BSTR *pVal);


void __RPC_STUB IGPMWMIFilter_get_Path_Stub(
    IRpcStubBuffer *This,
    IRpcChannelBuffer *_pRpcChannelBuffer,
    PRPC_MESSAGE _pRpcMessage,
    DWORD *_pdwStubPhase);


/* [helpstring][id][propput] */ HRESULT STDMETHODCALLTYPE IGPMWMIFilter_put_Name_Proxy( 
    IGPMWMIFilter * This,
    /* [in] */ BSTR newVal);


void __RPC_STUB IGPMWMIFilter_put_Name_Stub(
    IRpcStubBuffer *This,
    IRpcChannelBuffer *_pRpcChannelBuffer,
    PRPC_MESSAGE _pRpcMessage,
    DWORD *_pdwStubPhase);


/* [helpstring][id][propget] */ HRESULT STDMETHODCALLTYPE IGPMWMIFilter_get_Name_Proxy( 
    IGPMWMIFilter * This,
    /* [retval][out] */ BSTR *pVal);


void __RPC_STUB IGPMWMIFilter_get_Name_Stub(
    IRpcStubBuffer *This,
    IRpcChannelBuffer *_pRpcChannelBuffer,
    PRPC_MESSAGE _pRpcMessage,
    DWORD *_pdwStubPhase);


/* [helpstring][id][propput] */ HRESULT STDMETHODCALLTYPE IGPMWMIFilter_put_Description_Proxy( 
    IGPMWMIFilter * This,
    /* [in] */ BSTR newVal);


void __RPC_STUB IGPMWMIFilter_put_Description_Stub(
    IRpcStubBuffer *This,
    IRpcChannelBuffer *_pRpcChannelBuffer,
    PRPC_MESSAGE _pRpcMessage,
    DWORD *_pdwStubPhase);


/* [helpstring][id][propget] */ HRESULT STDMETHODCALLTYPE IGPMWMIFilter_get_Description_Proxy( 
    IGPMWMIFilter * This,
    /* [retval][out] */ BSTR *pVal);


void __RPC_STUB IGPMWMIFilter_get_Description_Stub(
    IRpcStubBuffer *This,
    IRpcChannelBuffer *_pRpcChannelBuffer,
    PRPC_MESSAGE _pRpcMessage,
    DWORD *_pdwStubPhase);


/* [helpstring][id] */ HRESULT STDMETHODCALLTYPE IGPMWMIFilter_GetQueryList_Proxy( 
    IGPMWMIFilter * This,
    /* [retval][out] */ VARIANT *pQryList);


void __RPC_STUB IGPMWMIFilter_GetQueryList_Stub(
    IRpcStubBuffer *This,
    IRpcChannelBuffer *_pRpcChannelBuffer,
    PRPC_MESSAGE _pRpcMessage,
    DWORD *_pdwStubPhase);


/* [helpstring][id] */ HRESULT STDMETHODCALLTYPE IGPMWMIFilter_GetSecurityInfo_Proxy( 
    IGPMWMIFilter * This,
    /* [retval][out] */ IGPMSecurityInfo **ppSecurityInfo);


void __RPC_STUB IGPMWMIFilter_GetSecurityInfo_Stub(
    IRpcStubBuffer *This,
    IRpcChannelBuffer *_pRpcChannelBuffer,
    PRPC_MESSAGE _pRpcMessage,
    DWORD *_pdwStubPhase);


/* [helpstring][id] */ HRESULT STDMETHODCALLTYPE IGPMWMIFilter_SetSecurityInfo_Proxy( 
    IGPMWMIFilter * This,
    /* [in] */ IGPMSecurityInfo *pSecurityInfo);


void __RPC_STUB IGPMWMIFilter_SetSecurityInfo_Stub(
    IRpcStubBuffer *This,
    IRpcChannelBuffer *_pRpcChannelBuffer,
    PRPC_MESSAGE _pRpcMessage,
    DWORD *_pdwStubPhase);



#endif 	/* __IGPMWMIFilter_INTERFACE_DEFINED__ */


#ifndef __IGPMWMIFilterCollection_INTERFACE_DEFINED__
#define __IGPMWMIFilterCollection_INTERFACE_DEFINED__

/* interface IGPMWMIFilterCollection */
/* [unique][helpstring][dual][uuid][object] */ 


EXTERN_C const IID IID_IGPMWMIFilterCollection;

#if defined(__cplusplus) && !defined(CINTERFACE)
    
    MIDL_INTERFACE("5782D582-1A36-4661-8A94-C3C32551945B")
    IGPMWMIFilterCollection : public IDispatch
    {
    public:
        virtual /* [helpstring][id][propget] */ HRESULT STDMETHODCALLTYPE get_Count( 
            /* [retval][out] */ long *pVal) = 0;
        
        virtual /* [helpstring][id][propget] */ HRESULT STDMETHODCALLTYPE get_Item( 
            long lIndex,
            /* [retval][out] */ VARIANT *pVal) = 0;
        
        virtual /* [helpstring][id][propget] */ HRESULT STDMETHODCALLTYPE get__NewEnum( 
            /* [retval][out] */ IEnumVARIANT **pVal) = 0;
        
    };
    
#else 	/* C style interface */

    typedef struct IGPMWMIFilterCollectionVtbl
    {
        BEGIN_INTERFACE
        
        HRESULT ( STDMETHODCALLTYPE *QueryInterface )( 
            IGPMWMIFilterCollection * This,
            /* [in] */ REFIID riid,
            /* [iid_is][out] */ void **ppvObject);
        
        ULONG ( STDMETHODCALLTYPE *AddRef )( 
            IGPMWMIFilterCollection * This);
        
        ULONG ( STDMETHODCALLTYPE *Release )( 
            IGPMWMIFilterCollection * This);
        
        HRESULT ( STDMETHODCALLTYPE *GetTypeInfoCount )( 
            IGPMWMIFilterCollection * This,
            /* [out] */ UINT *pctinfo);
        
        HRESULT ( STDMETHODCALLTYPE *GetTypeInfo )( 
            IGPMWMIFilterCollection * This,
            /* [in] */ UINT iTInfo,
            /* [in] */ LCID lcid,
            /* [out] */ ITypeInfo **ppTInfo);
        
        HRESULT ( STDMETHODCALLTYPE *GetIDsOfNames )( 
            IGPMWMIFilterCollection * This,
            /* [in] */ REFIID riid,
            /* [size_is][in] */ LPOLESTR *rgszNames,
            /* [in] */ UINT cNames,
            /* [in] */ LCID lcid,
            /* [size_is][out] */ DISPID *rgDispId);
        
        /* [local] */ HRESULT ( STDMETHODCALLTYPE *Invoke )( 
            IGPMWMIFilterCollection * This,
            /* [in] */ DISPID dispIdMember,
            /* [in] */ REFIID riid,
            /* [in] */ LCID lcid,
            /* [in] */ WORD wFlags,
            /* [out][in] */ DISPPARAMS *pDispParams,
            /* [out] */ VARIANT *pVarResult,
            /* [out] */ EXCEPINFO *pExcepInfo,
            /* [out] */ UINT *puArgErr);
        
        /* [helpstring][id][propget] */ HRESULT ( STDMETHODCALLTYPE *get_Count )( 
            IGPMWMIFilterCollection * This,
            /* [retval][out] */ long *pVal);
        
        /* [helpstring][id][propget] */ HRESULT ( STDMETHODCALLTYPE *get_Item )( 
            IGPMWMIFilterCollection * This,
            long lIndex,
            /* [retval][out] */ VARIANT *pVal);
        
        /* [helpstring][id][propget] */ HRESULT ( STDMETHODCALLTYPE *get__NewEnum )( 
            IGPMWMIFilterCollection * This,
            /* [retval][out] */ IEnumVARIANT **pVal);
        
        END_INTERFACE
    } IGPMWMIFilterCollectionVtbl;

    interface IGPMWMIFilterCollection
    {
        CONST_VTBL struct IGPMWMIFilterCollectionVtbl *lpVtbl;
    };

    

#ifdef COBJMACROS


#define IGPMWMIFilterCollection_QueryInterface(This,riid,ppvObject)	\
    (This)->lpVtbl -> QueryInterface(This,riid,ppvObject)

#define IGPMWMIFilterCollection_AddRef(This)	\
    (This)->lpVtbl -> AddRef(This)

#define IGPMWMIFilterCollection_Release(This)	\
    (This)->lpVtbl -> Release(This)


#define IGPMWMIFilterCollection_GetTypeInfoCount(This,pctinfo)	\
    (This)->lpVtbl -> GetTypeInfoCount(This,pctinfo)

#define IGPMWMIFilterCollection_GetTypeInfo(This,iTInfo,lcid,ppTInfo)	\
    (This)->lpVtbl -> GetTypeInfo(This,iTInfo,lcid,ppTInfo)

#define IGPMWMIFilterCollection_GetIDsOfNames(This,riid,rgszNames,cNames,lcid,rgDispId)	\
    (This)->lpVtbl -> GetIDsOfNames(This,riid,rgszNames,cNames,lcid,rgDispId)

#define IGPMWMIFilterCollection_Invoke(This,dispIdMember,riid,lcid,wFlags,pDispParams,pVarResult,pExcepInfo,puArgErr)	\
    (This)->lpVtbl -> Invoke(This,dispIdMember,riid,lcid,wFlags,pDispParams,pVarResult,pExcepInfo,puArgErr)


#define IGPMWMIFilterCollection_get_Count(This,pVal)	\
    (This)->lpVtbl -> get_Count(This,pVal)

#define IGPMWMIFilterCollection_get_Item(This,lIndex,pVal)	\
    (This)->lpVtbl -> get_Item(This,lIndex,pVal)

#define IGPMWMIFilterCollection_get__NewEnum(This,pVal)	\
    (This)->lpVtbl -> get__NewEnum(This,pVal)

#endif /* COBJMACROS */


#endif 	/* C style interface */



/* [helpstring][id][propget] */ HRESULT STDMETHODCALLTYPE IGPMWMIFilterCollection_get_Count_Proxy( 
    IGPMWMIFilterCollection * This,
    /* [retval][out] */ long *pVal);


void __RPC_STUB IGPMWMIFilterCollection_get_Count_Stub(
    IRpcStubBuffer *This,
    IRpcChannelBuffer *_pRpcChannelBuffer,
    PRPC_MESSAGE _pRpcMessage,
    DWORD *_pdwStubPhase);


/* [helpstring][id][propget] */ HRESULT STDMETHODCALLTYPE IGPMWMIFilterCollection_get_Item_Proxy( 
    IGPMWMIFilterCollection * This,
    long lIndex,
    /* [retval][out] */ VARIANT *pVal);


void __RPC_STUB IGPMWMIFilterCollection_get_Item_Stub(
    IRpcStubBuffer *This,
    IRpcChannelBuffer *_pRpcChannelBuffer,
    PRPC_MESSAGE _pRpcMessage,
    DWORD *_pdwStubPhase);


/* [helpstring][id][propget] */ HRESULT STDMETHODCALLTYPE IGPMWMIFilterCollection_get__NewEnum_Proxy( 
    IGPMWMIFilterCollection * This,
    /* [retval][out] */ IEnumVARIANT **pVal);


void __RPC_STUB IGPMWMIFilterCollection_get__NewEnum_Stub(
    IRpcStubBuffer *This,
    IRpcChannelBuffer *_pRpcChannelBuffer,
    PRPC_MESSAGE _pRpcMessage,
    DWORD *_pdwStubPhase);



#endif 	/* __IGPMWMIFilterCollection_INTERFACE_DEFINED__ */


#ifndef __IGPMRSOP_INTERFACE_DEFINED__
#define __IGPMRSOP_INTERFACE_DEFINED__

/* interface IGPMRSOP */
/* [unique][helpstring][dual][uuid][object] */ 


EXTERN_C const IID IID_IGPMRSOP;

#if defined(__cplusplus) && !defined(CINTERFACE)
    
    MIDL_INTERFACE("49ED785A-3237-4FF2-B1F0-FDF5A8D5A1EE")
    IGPMRSOP : public IDispatch
    {
    public:
        virtual /* [helpstring][id][propget] */ HRESULT STDMETHODCALLTYPE get_Mode( 
            /* [retval][out] */ GPMRSOPMode *pVal) = 0;
        
        virtual /* [helpstring][id][propget] */ HRESULT STDMETHODCALLTYPE get_Namespace( 
            /* [retval][out] */ BSTR *bstrVal) = 0;
        
        virtual /* [helpstring][id][propput] */ HRESULT STDMETHODCALLTYPE put_LoggingComputer( 
            /* [in] */ BSTR bstrVal) = 0;
        
        virtual /* [helpstring][id][propget] */ HRESULT STDMETHODCALLTYPE get_LoggingComputer( 
            /* [retval][out] */ BSTR *bstrVal) = 0;
        
        virtual /* [helpstring][id][propput] */ HRESULT STDMETHODCALLTYPE put_LoggingUser( 
            /* [in] */ BSTR bstrVal) = 0;
        
        virtual /* [helpstring][id][propget] */ HRESULT STDMETHODCALLTYPE get_LoggingUser( 
            /* [retval][out] */ BSTR *bstrVal) = 0;
        
        virtual /* [helpstring][id][propput] */ HRESULT STDMETHODCALLTYPE put_LoggingFlags( 
            /* [in] */ long lVal) = 0;
        
        virtual /* [helpstring][id][propget] */ HRESULT STDMETHODCALLTYPE get_LoggingFlags( 
            /* [retval][out] */ long *lVal) = 0;
        
        virtual /* [helpstring][id][propput] */ HRESULT STDMETHODCALLTYPE put_PlanningFlags( 
            /* [in] */ long lVal) = 0;
        
        virtual /* [helpstring][id][propget] */ HRESULT STDMETHODCALLTYPE get_PlanningFlags( 
            /* [retval][out] */ long *lVal) = 0;
        
        virtual /* [helpstring][id][propput] */ HRESULT STDMETHODCALLTYPE put_PlanningDomainController( 
            /* [in] */ BSTR bstrVal) = 0;
        
        virtual /* [helpstring][id][propget] */ HRESULT STDMETHODCALLTYPE get_PlanningDomainController( 
            /* [retval][out] */ BSTR *bstrVal) = 0;
        
        virtual /* [helpstring][id][propput] */ HRESULT STDMETHODCALLTYPE put_PlanningSiteName( 
            /* [in] */ BSTR bstrVal) = 0;
        
        virtual /* [helpstring][id][propget] */ HRESULT STDMETHODCALLTYPE get_PlanningSiteName( 
            /* [retval][out] */ BSTR *bstrVal) = 0;
        
        virtual /* [helpstring][id][propput] */ HRESULT STDMETHODCALLTYPE put_PlanningUser( 
            /* [in] */ BSTR bstrVal) = 0;
        
        virtual /* [helpstring][id][propget] */ HRESULT STDMETHODCALLTYPE get_PlanningUser( 
            /* [retval][out] */ BSTR *bstrVal) = 0;
        
        virtual /* [helpstring][id][propput] */ HRESULT STDMETHODCALLTYPE put_PlanningUserSOM( 
            /* [in] */ BSTR bstrVal) = 0;
        
        virtual /* [helpstring][id][propget] */ HRESULT STDMETHODCALLTYPE get_PlanningUserSOM( 
            /* [retval][out] */ BSTR *bstrVal) = 0;
        
        virtual /* [helpstring][id][propput] */ HRESULT STDMETHODCALLTYPE put_PlanningUserWMIFilters( 
            /* [in] */ VARIANT varVal) = 0;
        
        virtual /* [helpstring][id][propget] */ HRESULT STDMETHODCALLTYPE get_PlanningUserWMIFilters( 
            /* [retval][out] */ VARIANT *varVal) = 0;
        
        virtual /* [helpstring][id][propput] */ HRESULT STDMETHODCALLTYPE put_PlanningUserSecurityGroups( 
            /* [in] */ VARIANT varVal) = 0;
        
        virtual /* [helpstring][id][propget] */ HRESULT STDMETHODCALLTYPE get_PlanningUserSecurityGroups( 
            /* [retval][out] */ VARIANT *varVal) = 0;
        
        virtual /* [helpstring][id][propput] */ HRESULT STDMETHODCALLTYPE put_PlanningComputer( 
            /* [in] */ BSTR bstrVal) = 0;
        
        virtual /* [helpstring][id][propget] */ HRESULT STDMETHODCALLTYPE get_PlanningComputer( 
            /* [retval][out] */ BSTR *bstrVal) = 0;
        
        virtual /* [helpstring][id][propput] */ HRESULT STDMETHODCALLTYPE put_PlanningComputerSOM( 
            /* [in] */ BSTR bstrVal) = 0;
        
        virtual /* [helpstring][id][propget] */ HRESULT STDMETHODCALLTYPE get_PlanningComputerSOM( 
            /* [retval][out] */ BSTR *bstrVal) = 0;
        
        virtual /* [helpstring][id][propput] */ HRESULT STDMETHODCALLTYPE put_PlanningComputerWMIFilters( 
            /* [in] */ VARIANT varVal) = 0;
        
        virtual /* [helpstring][id][propget] */ HRESULT STDMETHODCALLTYPE get_PlanningComputerWMIFilters( 
            /* [retval][out] */ VARIANT *varVal) = 0;
        
        virtual /* [helpstring][id][propput] */ HRESULT STDMETHODCALLTYPE put_PlanningComputerSecurityGroups( 
            /* [in] */ VARIANT varVal) = 0;
        
        virtual /* [helpstring][id][propget] */ HRESULT STDMETHODCALLTYPE get_PlanningComputerSecurityGroups( 
            /* [retval][out] */ VARIANT *varVal) = 0;
        
        virtual /* [helpstring][id] */ HRESULT STDMETHODCALLTYPE LoggingEnumerateUsers( 
            /* [retval][out] */ VARIANT *varVal) = 0;
        
        virtual /* [helpstring][id] */ HRESULT STDMETHODCALLTYPE CreateQueryResults( void) = 0;
        
        virtual /* [helpstring][id] */ HRESULT STDMETHODCALLTYPE ReleaseQueryResults( void) = 0;
        
        virtual /* [helpstring][id] */ HRESULT STDMETHODCALLTYPE Diff( 
            /* [in] */ IGPMRSOP *pIGPMSource2,
            /* [in] */ BSTR bstrTransform,
            /* [in] */ BSTR bstrTargetFile,
            /* [in] */ IGPMAsyncProgress *pIGPMProgress,
            /* [out] */ IGPMAsyncCancel **ppIGPMCancel,
            /* [out] */ VARIANT *pData,
            /* [out] */ IGPMStatusMsgCollection **ppIGPMStatusMsgCollection) = 0;
        
        virtual /* [helpstring][id] */ HRESULT STDMETHODCALLTYPE GenerateReport( 
            /* [in] */ GPMReportType gpmReportType,
            /* [optional][in] */ VARIANT *pvarGPMProgress,
            /* [optional][out] */ VARIANT *pvarGPMCancel,
            /* [retval][out] */ IGPMResult **ppIGPMResult) = 0;
        
        virtual /* [helpstring][id] */ HRESULT STDMETHODCALLTYPE GenerateReportToFile( 
            /* [in] */ GPMReportType gpmReportType,
            /* [in] */ BSTR bstrTargetFilePath,
            /* [retval][out] */ IGPMResult **ppIGPMResult) = 0;
        
    };
    
#else 	/* C style interface */

    typedef struct IGPMRSOPVtbl
    {
        BEGIN_INTERFACE
        
        HRESULT ( STDMETHODCALLTYPE *QueryInterface )( 
            IGPMRSOP * This,
            /* [in] */ REFIID riid,
            /* [iid_is][out] */ void **ppvObject);
        
        ULONG ( STDMETHODCALLTYPE *AddRef )( 
            IGPMRSOP * This);
        
        ULONG ( STDMETHODCALLTYPE *Release )( 
            IGPMRSOP * This);
        
        HRESULT ( STDMETHODCALLTYPE *GetTypeInfoCount )( 
            IGPMRSOP * This,
            /* [out] */ UINT *pctinfo);
        
        HRESULT ( STDMETHODCALLTYPE *GetTypeInfo )( 
            IGPMRSOP * This,
            /* [in] */ UINT iTInfo,
            /* [in] */ LCID lcid,
            /* [out] */ ITypeInfo **ppTInfo);
        
        HRESULT ( STDMETHODCALLTYPE *GetIDsOfNames )( 
            IGPMRSOP * This,
            /* [in] */ REFIID riid,
            /* [size_is][in] */ LPOLESTR *rgszNames,
            /* [in] */ UINT cNames,
            /* [in] */ LCID lcid,
            /* [size_is][out] */ DISPID *rgDispId);
        
        /* [local] */ HRESULT ( STDMETHODCALLTYPE *Invoke )( 
            IGPMRSOP * This,
            /* [in] */ DISPID dispIdMember,
            /* [in] */ REFIID riid,
            /* [in] */ LCID lcid,
            /* [in] */ WORD wFlags,
            /* [out][in] */ DISPPARAMS *pDispParams,
            /* [out] */ VARIANT *pVarResult,
            /* [out] */ EXCEPINFO *pExcepInfo,
            /* [out] */ UINT *puArgErr);
        
        /* [helpstring][id][propget] */ HRESULT ( STDMETHODCALLTYPE *get_Mode )( 
            IGPMRSOP * This,
            /* [retval][out] */ GPMRSOPMode *pVal);
        
        /* [helpstring][id][propget] */ HRESULT ( STDMETHODCALLTYPE *get_Namespace )( 
            IGPMRSOP * This,
            /* [retval][out] */ BSTR *bstrVal);
        
        /* [helpstring][id][propput] */ HRESULT ( STDMETHODCALLTYPE *put_LoggingComputer )( 
            IGPMRSOP * This,
            /* [in] */ BSTR bstrVal);
        
        /* [helpstring][id][propget] */ HRESULT ( STDMETHODCALLTYPE *get_LoggingComputer )( 
            IGPMRSOP * This,
            /* [retval][out] */ BSTR *bstrVal);
        
        /* [helpstring][id][propput] */ HRESULT ( STDMETHODCALLTYPE *put_LoggingUser )( 
            IGPMRSOP * This,
            /* [in] */ BSTR bstrVal);
        
        /* [helpstring][id][propget] */ HRESULT ( STDMETHODCALLTYPE *get_LoggingUser )( 
            IGPMRSOP * This,
            /* [retval][out] */ BSTR *bstrVal);
        
        /* [helpstring][id][propput] */ HRESULT ( STDMETHODCALLTYPE *put_LoggingFlags )( 
            IGPMRSOP * This,
            /* [in] */ long lVal);
        
        /* [helpstring][id][propget] */ HRESULT ( STDMETHODCALLTYPE *get_LoggingFlags )( 
            IGPMRSOP * This,
            /* [retval][out] */ long *lVal);
        
        /* [helpstring][id][propput] */ HRESULT ( STDMETHODCALLTYPE *put_PlanningFlags )( 
            IGPMRSOP * This,
            /* [in] */ long lVal);
        
        /* [helpstring][id][propget] */ HRESULT ( STDMETHODCALLTYPE *get_PlanningFlags )( 
            IGPMRSOP * This,
            /* [retval][out] */ long *lVal);
        
        /* [helpstring][id][propput] */ HRESULT ( STDMETHODCALLTYPE *put_PlanningDomainController )( 
            IGPMRSOP * This,
            /* [in] */ BSTR bstrVal);
        
        /* [helpstring][id][propget] */ HRESULT ( STDMETHODCALLTYPE *get_PlanningDomainController )( 
            IGPMRSOP * This,
            /* [retval][out] */ BSTR *bstrVal);
        
        /* [helpstring][id][propput] */ HRESULT ( STDMETHODCALLTYPE *put_PlanningSiteName )( 
            IGPMRSOP * This,
            /* [in] */ BSTR bstrVal);
        
        /* [helpstring][id][propget] */ HRESULT ( STDMETHODCALLTYPE *get_PlanningSiteName )( 
            IGPMRSOP * This,
            /* [retval][out] */ BSTR *bstrVal);
        
        /* [helpstring][id][propput] */ HRESULT ( STDMETHODCALLTYPE *put_PlanningUser )( 
            IGPMRSOP * This,
            /* [in] */ BSTR bstrVal);
        
        /* [helpstring][id][propget] */ HRESULT ( STDMETHODCALLTYPE *get_PlanningUser )( 
            IGPMRSOP * This,
            /* [retval][out] */ BSTR *bstrVal);
        
        /* [helpstring][id][propput] */ HRESULT ( STDMETHODCALLTYPE *put_PlanningUserSOM )( 
            IGPMRSOP * This,
            /* [in] */ BSTR bstrVal);
        
        /* [helpstring][id][propget] */ HRESULT ( STDMETHODCALLTYPE *get_PlanningUserSOM )( 
            IGPMRSOP * This,
            /* [retval][out] */ BSTR *bstrVal);
        
        /* [helpstring][id][propput] */ HRESULT ( STDMETHODCALLTYPE *put_PlanningUserWMIFilters )( 
            IGPMRSOP * This,
            /* [in] */ VARIANT varVal);
        
        /* [helpstring][id][propget] */ HRESULT ( STDMETHODCALLTYPE *get_PlanningUserWMIFilters )( 
            IGPMRSOP * This,
            /* [retval][out] */ VARIANT *varVal);
        
        /* [helpstring][id][propput] */ HRESULT ( STDMETHODCALLTYPE *put_PlanningUserSecurityGroups )( 
            IGPMRSOP * This,
            /* [in] */ VARIANT varVal);
        
        /* [helpstring][id][propget] */ HRESULT ( STDMETHODCALLTYPE *get_PlanningUserSecurityGroups )( 
            IGPMRSOP * This,
            /* [retval][out] */ VARIANT *varVal);
        
        /* [helpstring][id][propput] */ HRESULT ( STDMETHODCALLTYPE *put_PlanningComputer )( 
            IGPMRSOP * This,
            /* [in] */ BSTR bstrVal);
        
        /* [helpstring][id][propget] */ HRESULT ( STDMETHODCALLTYPE *get_PlanningComputer )( 
            IGPMRSOP * This,
            /* [retval][out] */ BSTR *bstrVal);
        
        /* [helpstring][id][propput] */ HRESULT ( STDMETHODCALLTYPE *put_PlanningComputerSOM )( 
            IGPMRSOP * This,
            /* [in] */ BSTR bstrVal);
        
        /* [helpstring][id][propget] */ HRESULT ( STDMETHODCALLTYPE *get_PlanningComputerSOM )( 
            IGPMRSOP * This,
            /* [retval][out] */ BSTR *bstrVal);
        
        /* [helpstring][id][propput] */ HRESULT ( STDMETHODCALLTYPE *put_PlanningComputerWMIFilters )( 
            IGPMRSOP * This,
            /* [in] */ VARIANT varVal);
        
        /* [helpstring][id][propget] */ HRESULT ( STDMETHODCALLTYPE *get_PlanningComputerWMIFilters )( 
            IGPMRSOP * This,
            /* [retval][out] */ VARIANT *varVal);
        
        /* [helpstring][id][propput] */ HRESULT ( STDMETHODCALLTYPE *put_PlanningComputerSecurityGroups )( 
            IGPMRSOP * This,
            /* [in] */ VARIANT varVal);
        
        /* [helpstring][id][propget] */ HRESULT ( STDMETHODCALLTYPE *get_PlanningComputerSecurityGroups )( 
            IGPMRSOP * This,
            /* [retval][out] */ VARIANT *varVal);
        
        /* [helpstring][id] */ HRESULT ( STDMETHODCALLTYPE *LoggingEnumerateUsers )( 
            IGPMRSOP * This,
            /* [retval][out] */ VARIANT *varVal);
        
        /* [helpstring][id] */ HRESULT ( STDMETHODCALLTYPE *CreateQueryResults )( 
            IGPMRSOP * This);
        
        /* [helpstring][id] */ HRESULT ( STDMETHODCALLTYPE *ReleaseQueryResults )( 
            IGPMRSOP * This);
        
        /* [helpstring][id] */ HRESULT ( STDMETHODCALLTYPE *Diff )( 
            IGPMRSOP * This,
            /* [in] */ IGPMRSOP *pIGPMSource2,
            /* [in] */ BSTR bstrTransform,
            /* [in] */ BSTR bstrTargetFile,
            /* [in] */ IGPMAsyncProgress *pIGPMProgress,
            /* [out] */ IGPMAsyncCancel **ppIGPMCancel,
            /* [out] */ VARIANT *pData,
            /* [out] */ IGPMStatusMsgCollection **ppIGPMStatusMsgCollection);
        
        /* [helpstring][id] */ HRESULT ( STDMETHODCALLTYPE *GenerateReport )( 
            IGPMRSOP * This,
            /* [in] */ GPMReportType gpmReportType,
            /* [optional][in] */ VARIANT *pvarGPMProgress,
            /* [optional][out] */ VARIANT *pvarGPMCancel,
            /* [retval][out] */ IGPMResult **ppIGPMResult);
        
        /* [helpstring][id] */ HRESULT ( STDMETHODCALLTYPE *GenerateReportToFile )( 
            IGPMRSOP * This,
            /* [in] */ GPMReportType gpmReportType,
            /* [in] */ BSTR bstrTargetFilePath,
            /* [retval][out] */ IGPMResult **ppIGPMResult);
        
        END_INTERFACE
    } IGPMRSOPVtbl;

    interface IGPMRSOP
    {
        CONST_VTBL struct IGPMRSOPVtbl *lpVtbl;
    };

    

#ifdef COBJMACROS


#define IGPMRSOP_QueryInterface(This,riid,ppvObject)	\
    (This)->lpVtbl -> QueryInterface(This,riid,ppvObject)

#define IGPMRSOP_AddRef(This)	\
    (This)->lpVtbl -> AddRef(This)

#define IGPMRSOP_Release(This)	\
    (This)->lpVtbl -> Release(This)


#define IGPMRSOP_GetTypeInfoCount(This,pctinfo)	\
    (This)->lpVtbl -> GetTypeInfoCount(This,pctinfo)

#define IGPMRSOP_GetTypeInfo(This,iTInfo,lcid,ppTInfo)	\
    (This)->lpVtbl -> GetTypeInfo(This,iTInfo,lcid,ppTInfo)

#define IGPMRSOP_GetIDsOfNames(This,riid,rgszNames,cNames,lcid,rgDispId)	\
    (This)->lpVtbl -> GetIDsOfNames(This,riid,rgszNames,cNames,lcid,rgDispId)

#define IGPMRSOP_Invoke(This,dispIdMember,riid,lcid,wFlags,pDispParams,pVarResult,pExcepInfo,puArgErr)	\
    (This)->lpVtbl -> Invoke(This,dispIdMember,riid,lcid,wFlags,pDispParams,pVarResult,pExcepInfo,puArgErr)


#define IGPMRSOP_get_Mode(This,pVal)	\
    (This)->lpVtbl -> get_Mode(This,pVal)

#define IGPMRSOP_get_Namespace(This,bstrVal)	\
    (This)->lpVtbl -> get_Namespace(This,bstrVal)

#define IGPMRSOP_put_LoggingComputer(This,bstrVal)	\
    (This)->lpVtbl -> put_LoggingComputer(This,bstrVal)

#define IGPMRSOP_get_LoggingComputer(This,bstrVal)	\
    (This)->lpVtbl -> get_LoggingComputer(This,bstrVal)

#define IGPMRSOP_put_LoggingUser(This,bstrVal)	\
    (This)->lpVtbl -> put_LoggingUser(This,bstrVal)

#define IGPMRSOP_get_LoggingUser(This,bstrVal)	\
    (This)->lpVtbl -> get_LoggingUser(This,bstrVal)

#define IGPMRSOP_put_LoggingFlags(This,lVal)	\
    (This)->lpVtbl -> put_LoggingFlags(This,lVal)

#define IGPMRSOP_get_LoggingFlags(This,lVal)	\
    (This)->lpVtbl -> get_LoggingFlags(This,lVal)

#define IGPMRSOP_put_PlanningFlags(This,lVal)	\
    (This)->lpVtbl -> put_PlanningFlags(This,lVal)

#define IGPMRSOP_get_PlanningFlags(This,lVal)	\
    (This)->lpVtbl -> get_PlanningFlags(This,lVal)

#define IGPMRSOP_put_PlanningDomainController(This,bstrVal)	\
    (This)->lpVtbl -> put_PlanningDomainController(This,bstrVal)

#define IGPMRSOP_get_PlanningDomainController(This,bstrVal)	\
    (This)->lpVtbl -> get_PlanningDomainController(This,bstrVal)

#define IGPMRSOP_put_PlanningSiteName(This,bstrVal)	\
    (This)->lpVtbl -> put_PlanningSiteName(This,bstrVal)

#define IGPMRSOP_get_PlanningSiteName(This,bstrVal)	\
    (This)->lpVtbl -> get_PlanningSiteName(This,bstrVal)

#define IGPMRSOP_put_PlanningUser(This,bstrVal)	\
    (This)->lpVtbl -> put_PlanningUser(This,bstrVal)

#define IGPMRSOP_get_PlanningUser(This,bstrVal)	\
    (This)->lpVtbl -> get_PlanningUser(This,bstrVal)

#define IGPMRSOP_put_PlanningUserSOM(This,bstrVal)	\
    (This)->lpVtbl -> put_PlanningUserSOM(This,bstrVal)

#define IGPMRSOP_get_PlanningUserSOM(This,bstrVal)	\
    (This)->lpVtbl -> get_PlanningUserSOM(This,bstrVal)

#define IGPMRSOP_put_PlanningUserWMIFilters(This,varVal)	\
    (This)->lpVtbl -> put_PlanningUserWMIFilters(This,varVal)

#define IGPMRSOP_get_PlanningUserWMIFilters(This,varVal)	\
    (This)->lpVtbl -> get_PlanningUserWMIFilters(This,varVal)

#define IGPMRSOP_put_PlanningUserSecurityGroups(This,varVal)	\
    (This)->lpVtbl -> put_PlanningUserSecurityGroups(This,varVal)

#define IGPMRSOP_get_PlanningUserSecurityGroups(This,varVal)	\
    (This)->lpVtbl -> get_PlanningUserSecurityGroups(This,varVal)

#define IGPMRSOP_put_PlanningComputer(This,bstrVal)	\
    (This)->lpVtbl -> put_PlanningComputer(This,bstrVal)

#define IGPMRSOP_get_PlanningComputer(This,bstrVal)	\
    (This)->lpVtbl -> get_PlanningComputer(This,bstrVal)

#define IGPMRSOP_put_PlanningComputerSOM(This,bstrVal)	\
    (This)->lpVtbl -> put_PlanningComputerSOM(This,bstrVal)

#define IGPMRSOP_get_PlanningComputerSOM(This,bstrVal)	\
    (This)->lpVtbl -> get_PlanningComputerSOM(This,bstrVal)

#define IGPMRSOP_put_PlanningComputerWMIFilters(This,varVal)	\
    (This)->lpVtbl -> put_PlanningComputerWMIFilters(This,varVal)

#define IGPMRSOP_get_PlanningComputerWMIFilters(This,varVal)	\
    (This)->lpVtbl -> get_PlanningComputerWMIFilters(This,varVal)

#define IGPMRSOP_put_PlanningComputerSecurityGroups(This,varVal)	\
    (This)->lpVtbl -> put_PlanningComputerSecurityGroups(This,varVal)

#define IGPMRSOP_get_PlanningComputerSecurityGroups(This,varVal)	\
    (This)->lpVtbl -> get_PlanningComputerSecurityGroups(This,varVal)

#define IGPMRSOP_LoggingEnumerateUsers(This,varVal)	\
    (This)->lpVtbl -> LoggingEnumerateUsers(This,varVal)

#define IGPMRSOP_CreateQueryResults(This)	\
    (This)->lpVtbl -> CreateQueryResults(This)

#define IGPMRSOP_ReleaseQueryResults(This)	\
    (This)->lpVtbl -> ReleaseQueryResults(This)

#define IGPMRSOP_Diff(This,pIGPMSource2,bstrTransform,bstrTargetFile,pIGPMProgress,ppIGPMCancel,pData,ppIGPMStatusMsgCollection)	\
    (This)->lpVtbl -> Diff(This,pIGPMSource2,bstrTransform,bstrTargetFile,pIGPMProgress,ppIGPMCancel,pData,ppIGPMStatusMsgCollection)

#define IGPMRSOP_GenerateReport(This,gpmReportType,pvarGPMProgress,pvarGPMCancel,ppIGPMResult)	\
    (This)->lpVtbl -> GenerateReport(This,gpmReportType,pvarGPMProgress,pvarGPMCancel,ppIGPMResult)

#define IGPMRSOP_GenerateReportToFile(This,gpmReportType,bstrTargetFilePath,ppIGPMResult)	\
    (This)->lpVtbl -> GenerateReportToFile(This,gpmReportType,bstrTargetFilePath,ppIGPMResult)

#endif /* COBJMACROS */


#endif 	/* C style interface */



/* [helpstring][id][propget] */ HRESULT STDMETHODCALLTYPE IGPMRSOP_get_Mode_Proxy( 
    IGPMRSOP * This,
    /* [retval][out] */ GPMRSOPMode *pVal);


void __RPC_STUB IGPMRSOP_get_Mode_Stub(
    IRpcStubBuffer *This,
    IRpcChannelBuffer *_pRpcChannelBuffer,
    PRPC_MESSAGE _pRpcMessage,
    DWORD *_pdwStubPhase);


/* [helpstring][id][propget] */ HRESULT STDMETHODCALLTYPE IGPMRSOP_get_Namespace_Proxy( 
    IGPMRSOP * This,
    /* [retval][out] */ BSTR *bstrVal);


void __RPC_STUB IGPMRSOP_get_Namespace_Stub(
    IRpcStubBuffer *This,
    IRpcChannelBuffer *_pRpcChannelBuffer,
    PRPC_MESSAGE _pRpcMessage,
    DWORD *_pdwStubPhase);


/* [helpstring][id][propput] */ HRESULT STDMETHODCALLTYPE IGPMRSOP_put_LoggingComputer_Proxy( 
    IGPMRSOP * This,
    /* [in] */ BSTR bstrVal);


void __RPC_STUB IGPMRSOP_put_LoggingComputer_Stub(
    IRpcStubBuffer *This,
    IRpcChannelBuffer *_pRpcChannelBuffer,
    PRPC_MESSAGE _pRpcMessage,
    DWORD *_pdwStubPhase);


/* [helpstring][id][propget] */ HRESULT STDMETHODCALLTYPE IGPMRSOP_get_LoggingComputer_Proxy( 
    IGPMRSOP * This,
    /* [retval][out] */ BSTR *bstrVal);


void __RPC_STUB IGPMRSOP_get_LoggingComputer_Stub(
    IRpcStubBuffer *This,
    IRpcChannelBuffer *_pRpcChannelBuffer,
    PRPC_MESSAGE _pRpcMessage,
    DWORD *_pdwStubPhase);


/* [helpstring][id][propput] */ HRESULT STDMETHODCALLTYPE IGPMRSOP_put_LoggingUser_Proxy( 
    IGPMRSOP * This,
    /* [in] */ BSTR bstrVal);


void __RPC_STUB IGPMRSOP_put_LoggingUser_Stub(
    IRpcStubBuffer *This,
    IRpcChannelBuffer *_pRpcChannelBuffer,
    PRPC_MESSAGE _pRpcMessage,
    DWORD *_pdwStubPhase);


/* [helpstring][id][propget] */ HRESULT STDMETHODCALLTYPE IGPMRSOP_get_LoggingUser_Proxy( 
    IGPMRSOP * This,
    /* [retval][out] */ BSTR *bstrVal);


void __RPC_STUB IGPMRSOP_get_LoggingUser_Stub(
    IRpcStubBuffer *This,
    IRpcChannelBuffer *_pRpcChannelBuffer,
    PRPC_MESSAGE _pRpcMessage,
    DWORD *_pdwStubPhase);


/* [helpstring][id][propput] */ HRESULT STDMETHODCALLTYPE IGPMRSOP_put_LoggingFlags_Proxy( 
    IGPMRSOP * This,
    /* [in] */ long lVal);


void __RPC_STUB IGPMRSOP_put_LoggingFlags_Stub(
    IRpcStubBuffer *This,
    IRpcChannelBuffer *_pRpcChannelBuffer,
    PRPC_MESSAGE _pRpcMessage,
    DWORD *_pdwStubPhase);


/* [helpstring][id][propget] */ HRESULT STDMETHODCALLTYPE IGPMRSOP_get_LoggingFlags_Proxy( 
    IGPMRSOP * This,
    /* [retval][out] */ long *lVal);


void __RPC_STUB IGPMRSOP_get_LoggingFlags_Stub(
    IRpcStubBuffer *This,
    IRpcChannelBuffer *_pRpcChannelBuffer,
    PRPC_MESSAGE _pRpcMessage,
    DWORD *_pdwStubPhase);


/* [helpstring][id][propput] */ HRESULT STDMETHODCALLTYPE IGPMRSOP_put_PlanningFlags_Proxy( 
    IGPMRSOP * This,
    /* [in] */ long lVal);


void __RPC_STUB IGPMRSOP_put_PlanningFlags_Stub(
    IRpcStubBuffer *This,
    IRpcChannelBuffer *_pRpcChannelBuffer,
    PRPC_MESSAGE _pRpcMessage,
    DWORD *_pdwStubPhase);


/* [helpstring][id][propget] */ HRESULT STDMETHODCALLTYPE IGPMRSOP_get_PlanningFlags_Proxy( 
    IGPMRSOP * This,
    /* [retval][out] */ long *lVal);


void __RPC_STUB IGPMRSOP_get_PlanningFlags_Stub(
    IRpcStubBuffer *This,
    IRpcChannelBuffer *_pRpcChannelBuffer,
    PRPC_MESSAGE _pRpcMessage,
    DWORD *_pdwStubPhase);


/* [helpstring][id][propput] */ HRESULT STDMETHODCALLTYPE IGPMRSOP_put_PlanningDomainController_Proxy( 
    IGPMRSOP * This,
    /* [in] */ BSTR bstrVal);


void __RPC_STUB IGPMRSOP_put_PlanningDomainController_Stub(
    IRpcStubBuffer *This,
    IRpcChannelBuffer *_pRpcChannelBuffer,
    PRPC_MESSAGE _pRpcMessage,
    DWORD *_pdwStubPhase);


/* [helpstring][id][propget] */ HRESULT STDMETHODCALLTYPE IGPMRSOP_get_PlanningDomainController_Proxy( 
    IGPMRSOP * This,
    /* [retval][out] */ BSTR *bstrVal);


void __RPC_STUB IGPMRSOP_get_PlanningDomainController_Stub(
    IRpcStubBuffer *This,
    IRpcChannelBuffer *_pRpcChannelBuffer,
    PRPC_MESSAGE _pRpcMessage,
    DWORD *_pdwStubPhase);


/* [helpstring][id][propput] */ HRESULT STDMETHODCALLTYPE IGPMRSOP_put_PlanningSiteName_Proxy( 
    IGPMRSOP * This,
    /* [in] */ BSTR bstrVal);


void __RPC_STUB IGPMRSOP_put_PlanningSiteName_Stub(
    IRpcStubBuffer *This,
    IRpcChannelBuffer *_pRpcChannelBuffer,
    PRPC_MESSAGE _pRpcMessage,
    DWORD *_pdwStubPhase);


/* [helpstring][id][propget] */ HRESULT STDMETHODCALLTYPE IGPMRSOP_get_PlanningSiteName_Proxy( 
    IGPMRSOP * This,
    /* [retval][out] */ BSTR *bstrVal);


void __RPC_STUB IGPMRSOP_get_PlanningSiteName_Stub(
    IRpcStubBuffer *This,
    IRpcChannelBuffer *_pRpcChannelBuffer,
    PRPC_MESSAGE _pRpcMessage,
    DWORD *_pdwStubPhase);


/* [helpstring][id][propput] */ HRESULT STDMETHODCALLTYPE IGPMRSOP_put_PlanningUser_Proxy( 
    IGPMRSOP * This,
    /* [in] */ BSTR bstrVal);


void __RPC_STUB IGPMRSOP_put_PlanningUser_Stub(
    IRpcStubBuffer *This,
    IRpcChannelBuffer *_pRpcChannelBuffer,
    PRPC_MESSAGE _pRpcMessage,
    DWORD *_pdwStubPhase);


/* [helpstring][id][propget] */ HRESULT STDMETHODCALLTYPE IGPMRSOP_get_PlanningUser_Proxy( 
    IGPMRSOP * This,
    /* [retval][out] */ BSTR *bstrVal);


void __RPC_STUB IGPMRSOP_get_PlanningUser_Stub(
    IRpcStubBuffer *This,
    IRpcChannelBuffer *_pRpcChannelBuffer,
    PRPC_MESSAGE _pRpcMessage,
    DWORD *_pdwStubPhase);


/* [helpstring][id][propput] */ HRESULT STDMETHODCALLTYPE IGPMRSOP_put_PlanningUserSOM_Proxy( 
    IGPMRSOP * This,
    /* [in] */ BSTR bstrVal);


void __RPC_STUB IGPMRSOP_put_PlanningUserSOM_Stub(
    IRpcStubBuffer *This,
    IRpcChannelBuffer *_pRpcChannelBuffer,
    PRPC_MESSAGE _pRpcMessage,
    DWORD *_pdwStubPhase);


/* [helpstring][id][propget] */ HRESULT STDMETHODCALLTYPE IGPMRSOP_get_PlanningUserSOM_Proxy( 
    IGPMRSOP * This,
    /* [retval][out] */ BSTR *bstrVal);


void __RPC_STUB IGPMRSOP_get_PlanningUserSOM_Stub(
    IRpcStubBuffer *This,
    IRpcChannelBuffer *_pRpcChannelBuffer,
    PRPC_MESSAGE _pRpcMessage,
    DWORD *_pdwStubPhase);


/* [helpstring][id][propput] */ HRESULT STDMETHODCALLTYPE IGPMRSOP_put_PlanningUserWMIFilters_Proxy( 
    IGPMRSOP * This,
    /* [in] */ VARIANT varVal);


void __RPC_STUB IGPMRSOP_put_PlanningUserWMIFilters_Stub(
    IRpcStubBuffer *This,
    IRpcChannelBuffer *_pRpcChannelBuffer,
    PRPC_MESSAGE _pRpcMessage,
    DWORD *_pdwStubPhase);


/* [helpstring][id][propget] */ HRESULT STDMETHODCALLTYPE IGPMRSOP_get_PlanningUserWMIFilters_Proxy( 
    IGPMRSOP * This,
    /* [retval][out] */ VARIANT *varVal);


void __RPC_STUB IGPMRSOP_get_PlanningUserWMIFilters_Stub(
    IRpcStubBuffer *This,
    IRpcChannelBuffer *_pRpcChannelBuffer,
    PRPC_MESSAGE _pRpcMessage,
    DWORD *_pdwStubPhase);


/* [helpstring][id][propput] */ HRESULT STDMETHODCALLTYPE IGPMRSOP_put_PlanningUserSecurityGroups_Proxy( 
    IGPMRSOP * This,
    /* [in] */ VARIANT varVal);


void __RPC_STUB IGPMRSOP_put_PlanningUserSecurityGroups_Stub(
    IRpcStubBuffer *This,
    IRpcChannelBuffer *_pRpcChannelBuffer,
    PRPC_MESSAGE _pRpcMessage,
    DWORD *_pdwStubPhase);


/* [helpstring][id][propget] */ HRESULT STDMETHODCALLTYPE IGPMRSOP_get_PlanningUserSecurityGroups_Proxy( 
    IGPMRSOP * This,
    /* [retval][out] */ VARIANT *varVal);


void __RPC_STUB IGPMRSOP_get_PlanningUserSecurityGroups_Stub(
    IRpcStubBuffer *This,
    IRpcChannelBuffer *_pRpcChannelBuffer,
    PRPC_MESSAGE _pRpcMessage,
    DWORD *_pdwStubPhase);


/* [helpstring][id][propput] */ HRESULT STDMETHODCALLTYPE IGPMRSOP_put_PlanningComputer_Proxy( 
    IGPMRSOP * This,
    /* [in] */ BSTR bstrVal);


void __RPC_STUB IGPMRSOP_put_PlanningComputer_Stub(
    IRpcStubBuffer *This,
    IRpcChannelBuffer *_pRpcChannelBuffer,
    PRPC_MESSAGE _pRpcMessage,
    DWORD *_pdwStubPhase);


/* [helpstring][id][propget] */ HRESULT STDMETHODCALLTYPE IGPMRSOP_get_PlanningComputer_Proxy( 
    IGPMRSOP * This,
    /* [retval][out] */ BSTR *bstrVal);


void __RPC_STUB IGPMRSOP_get_PlanningComputer_Stub(
    IRpcStubBuffer *This,
    IRpcChannelBuffer *_pRpcChannelBuffer,
    PRPC_MESSAGE _pRpcMessage,
    DWORD *_pdwStubPhase);


/* [helpstring][id][propput] */ HRESULT STDMETHODCALLTYPE IGPMRSOP_put_PlanningComputerSOM_Proxy( 
    IGPMRSOP * This,
    /* [in] */ BSTR bstrVal);


void __RPC_STUB IGPMRSOP_put_PlanningComputerSOM_Stub(
    IRpcStubBuffer *This,
    IRpcChannelBuffer *_pRpcChannelBuffer,
    PRPC_MESSAGE _pRpcMessage,
    DWORD *_pdwStubPhase);


/* [helpstring][id][propget] */ HRESULT STDMETHODCALLTYPE IGPMRSOP_get_PlanningComputerSOM_Proxy( 
    IGPMRSOP * This,
    /* [retval][out] */ BSTR *bstrVal);


void __RPC_STUB IGPMRSOP_get_PlanningComputerSOM_Stub(
    IRpcStubBuffer *This,
    IRpcChannelBuffer *_pRpcChannelBuffer,
    PRPC_MESSAGE _pRpcMessage,
    DWORD *_pdwStubPhase);


/* [helpstring][id][propput] */ HRESULT STDMETHODCALLTYPE IGPMRSOP_put_PlanningComputerWMIFilters_Proxy( 
    IGPMRSOP * This,
    /* [in] */ VARIANT varVal);


void __RPC_STUB IGPMRSOP_put_PlanningComputerWMIFilters_Stub(
    IRpcStubBuffer *This,
    IRpcChannelBuffer *_pRpcChannelBuffer,
    PRPC_MESSAGE _pRpcMessage,
    DWORD *_pdwStubPhase);


/* [helpstring][id][propget] */ HRESULT STDMETHODCALLTYPE IGPMRSOP_get_PlanningComputerWMIFilters_Proxy( 
    IGPMRSOP * This,
    /* [retval][out] */ VARIANT *varVal);


void __RPC_STUB IGPMRSOP_get_PlanningComputerWMIFilters_Stub(
    IRpcStubBuffer *This,
    IRpcChannelBuffer *_pRpcChannelBuffer,
    PRPC_MESSAGE _pRpcMessage,
    DWORD *_pdwStubPhase);


/* [helpstring][id][propput] */ HRESULT STDMETHODCALLTYPE IGPMRSOP_put_PlanningComputerSecurityGroups_Proxy( 
    IGPMRSOP * This,
    /* [in] */ VARIANT varVal);


void __RPC_STUB IGPMRSOP_put_PlanningComputerSecurityGroups_Stub(
    IRpcStubBuffer *This,
    IRpcChannelBuffer *_pRpcChannelBuffer,
    PRPC_MESSAGE _pRpcMessage,
    DWORD *_pdwStubPhase);


/* [helpstring][id][propget] */ HRESULT STDMETHODCALLTYPE IGPMRSOP_get_PlanningComputerSecurityGroups_Proxy( 
    IGPMRSOP * This,
    /* [retval][out] */ VARIANT *varVal);


void __RPC_STUB IGPMRSOP_get_PlanningComputerSecurityGroups_Stub(
    IRpcStubBuffer *This,
    IRpcChannelBuffer *_pRpcChannelBuffer,
    PRPC_MESSAGE _pRpcMessage,
    DWORD *_pdwStubPhase);


/* [helpstring][id] */ HRESULT STDMETHODCALLTYPE IGPMRSOP_LoggingEnumerateUsers_Proxy( 
    IGPMRSOP * This,
    /* [retval][out] */ VARIANT *varVal);


void __RPC_STUB IGPMRSOP_LoggingEnumerateUsers_Stub(
    IRpcStubBuffer *This,
    IRpcChannelBuffer *_pRpcChannelBuffer,
    PRPC_MESSAGE _pRpcMessage,
    DWORD *_pdwStubPhase);


/* [helpstring][id] */ HRESULT STDMETHODCALLTYPE IGPMRSOP_CreateQueryResults_Proxy( 
    IGPMRSOP * This);


void __RPC_STUB IGPMRSOP_CreateQueryResults_Stub(
    IRpcStubBuffer *This,
    IRpcChannelBuffer *_pRpcChannelBuffer,
    PRPC_MESSAGE _pRpcMessage,
    DWORD *_pdwStubPhase);


/* [helpstring][id] */ HRESULT STDMETHODCALLTYPE IGPMRSOP_ReleaseQueryResults_Proxy( 
    IGPMRSOP * This);


void __RPC_STUB IGPMRSOP_ReleaseQueryResults_Stub(
    IRpcStubBuffer *This,
    IRpcChannelBuffer *_pRpcChannelBuffer,
    PRPC_MESSAGE _pRpcMessage,
    DWORD *_pdwStubPhase);


/* [helpstring][id] */ HRESULT STDMETHODCALLTYPE IGPMRSOP_Diff_Proxy( 
    IGPMRSOP * This,
    /* [in] */ IGPMRSOP *pIGPMSource2,
    /* [in] */ BSTR bstrTransform,
    /* [in] */ BSTR bstrTargetFile,
    /* [in] */ IGPMAsyncProgress *pIGPMProgress,
    /* [out] */ IGPMAsyncCancel **ppIGPMCancel,
    /* [out] */ VARIANT *pData,
    /* [out] */ IGPMStatusMsgCollection **ppIGPMStatusMsgCollection);


void __RPC_STUB IGPMRSOP_Diff_Stub(
    IRpcStubBuffer *This,
    IRpcChannelBuffer *_pRpcChannelBuffer,
    PRPC_MESSAGE _pRpcMessage,
    DWORD *_pdwStubPhase);


/* [helpstring][id] */ HRESULT STDMETHODCALLTYPE IGPMRSOP_GenerateReport_Proxy( 
    IGPMRSOP * This,
    /* [in] */ GPMReportType gpmReportType,
    /* [optional][in] */ VARIANT *pvarGPMProgress,
    /* [optional][out] */ VARIANT *pvarGPMCancel,
    /* [retval][out] */ IGPMResult **ppIGPMResult);


void __RPC_STUB IGPMRSOP_GenerateReport_Stub(
    IRpcStubBuffer *This,
    IRpcChannelBuffer *_pRpcChannelBuffer,
    PRPC_MESSAGE _pRpcMessage,
    DWORD *_pdwStubPhase);


/* [helpstring][id] */ HRESULT STDMETHODCALLTYPE IGPMRSOP_GenerateReportToFile_Proxy( 
    IGPMRSOP * This,
    /* [in] */ GPMReportType gpmReportType,
    /* [in] */ BSTR bstrTargetFilePath,
    /* [retval][out] */ IGPMResult **ppIGPMResult);


void __RPC_STUB IGPMRSOP_GenerateReportToFile_Stub(
    IRpcStubBuffer *This,
    IRpcChannelBuffer *_pRpcChannelBuffer,
    PRPC_MESSAGE _pRpcMessage,
    DWORD *_pdwStubPhase);



#endif 	/* __IGPMRSOP_INTERFACE_DEFINED__ */


#ifndef __IGPMGPO_INTERFACE_DEFINED__
#define __IGPMGPO_INTERFACE_DEFINED__

/* interface IGPMGPO */
/* [unique][helpstring][dual][uuid][object] */ 


EXTERN_C const IID IID_IGPMGPO;

#if defined(__cplusplus) && !defined(CINTERFACE)
    
    MIDL_INTERFACE("58CC4352-1CA3-48E5-9864-1DA4D6E0D60F")
    IGPMGPO : public IDispatch
    {
    public:
        virtual /* [helpstring][id][propget] */ HRESULT STDMETHODCALLTYPE get_DisplayName( 
            /* [retval][out] */ BSTR *pVal) = 0;
        
        virtual /* [helpstring][id][propput] */ HRESULT STDMETHODCALLTYPE put_DisplayName( 
            /* [in] */ BSTR newVal) = 0;
        
        virtual /* [helpstring][id][propget] */ HRESULT STDMETHODCALLTYPE get_Path( 
            /* [retval][out] */ BSTR *pVal) = 0;
        
        virtual /* [helpstring][id][propget] */ HRESULT STDMETHODCALLTYPE get_ID( 
            /* [retval][out] */ BSTR *pVal) = 0;
        
        virtual /* [helpstring][id][propget] */ HRESULT STDMETHODCALLTYPE get_DomainName( 
            /* [retval][out] */ BSTR *pVal) = 0;
        
        virtual /* [helpstring][id][propget] */ HRESULT STDMETHODCALLTYPE get_CreationTime( 
            /* [retval][out] */ DATE *pDate) = 0;
        
        virtual /* [helpstring][id][propget] */ HRESULT STDMETHODCALLTYPE get_ModificationTime( 
            /* [retval][out] */ DATE *pDate) = 0;
        
        virtual /* [helpstring][id][propget] */ HRESULT STDMETHODCALLTYPE get_UserDSVersionNumber( 
            /* [retval][out] */ ULONG *pVal) = 0;
        
        virtual /* [helpstring][id][propget] */ HRESULT STDMETHODCALLTYPE get_ComputerDSVersionNumber( 
            /* [retval][out] */ ULONG *pVal) = 0;
        
        virtual /* [helpstring][id][propget] */ HRESULT STDMETHODCALLTYPE get_UserSysvolVersionNumber( 
            /* [retval][out] */ ULONG *pVal) = 0;
        
        virtual /* [helpstring][id][propget] */ HRESULT STDMETHODCALLTYPE get_ComputerSysvolVersionNumber( 
            /* [retval][out] */ ULONG *pVal) = 0;
        
        virtual /* [helpstring][id] */ HRESULT STDMETHODCALLTYPE GetWMIFilter( 
            /* [retval][out] */ IGPMWMIFilter **ppIGPMWMIFilter) = 0;
        
        virtual /* [helpstring][id] */ HRESULT STDMETHODCALLTYPE SetWMIFilter( 
            /* [in] */ IGPMWMIFilter *pIGPMWMIFilter) = 0;
        
        virtual /* [helpstring][id] */ HRESULT STDMETHODCALLTYPE SetUserEnabled( 
            /* [in] */ VARIANT_BOOL vbEnabled) = 0;
        
        virtual /* [helpstring][id] */ HRESULT STDMETHODCALLTYPE SetComputerEnabled( 
            /* [in] */ VARIANT_BOOL vbEnabled) = 0;
        
        virtual /* [helpstring][id] */ HRESULT STDMETHODCALLTYPE IsUserEnabled( 
            /* [retval][out] */ VARIANT_BOOL *pvbEnabled) = 0;
        
        virtual /* [helpstring][id] */ HRESULT STDMETHODCALLTYPE IsComputerEnabled( 
            /* [retval][out] */ VARIANT_BOOL *pvbEnabled) = 0;
        
        virtual /* [helpstring][id] */ HRESULT STDMETHODCALLTYPE GetSecurityInfo( 
            /* [retval][out] */ IGPMSecurityInfo **ppSecurityInfo) = 0;
        
        virtual /* [helpstring][id] */ HRESULT STDMETHODCALLTYPE SetSecurityInfo( 
            /* [in] */ IGPMSecurityInfo *pSecurityInfo) = 0;
        
        virtual /* [helpstring][id] */ HRESULT STDMETHODCALLTYPE Delete( void) = 0;
        
        virtual /* [helpstring][id] */ HRESULT STDMETHODCALLTYPE Backup( 
            /* [in] */ BSTR bstrBackupDir,
            /* [in] */ BSTR bstrComment,
            /* [optional][in] */ VARIANT *pvarGPMProgress,
            /* [optional][out] */ VARIANT *pvarGPMCancel,
            /* [retval][out] */ IGPMResult **ppIGPMResult) = 0;
        
        virtual /* [helpstring][id] */ HRESULT STDMETHODCALLTYPE Import( 
            /* [in] */ GPMResolveOption gpmResolveGroupsOptions,
            /* [in] */ IGPMBackup *pIGPMBackup,
            /* [optional][in] */ VARIANT *pvarTranslationTablePath,
            /* [optional][in] */ VARIANT *pvarGPMProgress,
            /* [optional][out] */ VARIANT *pvarGPMCancel,
            /* [retval][out] */ IGPMResult **ppIGPMResult) = 0;
        
        virtual /* [helpstring][id] */ HRESULT STDMETHODCALLTYPE GenerateReport( 
            /* [in] */ GPMReportType gpmReportType,
            /* [optional][in] */ VARIANT *pvarGPMProgress,
            /* [optional][out] */ VARIANT *pvarGPMCancel,
            /* [retval][out] */ IGPMResult **ppIGPMResult) = 0;
        
        virtual /* [helpstring][id] */ HRESULT STDMETHODCALLTYPE GenerateReportToFile( 
            /* [in] */ GPMReportType gpmReportType,
            /* [in] */ BSTR bstrTargetFilePath,
            /* [retval][out] */ IGPMResult **ppIGPMResult) = 0;
        
        virtual /* [helpstring][id] */ HRESULT STDMETHODCALLTYPE CopyTo( 
            /* [in] */ GPMResolveOption gpmResolveGroupsOptions,
            /* [in] */ IGPMDomain *pIGPMDomain,
            /* [optional][in] */ VARIANT *pvarTranslationTablePath,
            /* [optional][in] */ VARIANT *pvarGPMProgress,
            /* [optional][out] */ VARIANT *pvarGPMCancel,
            /* [retval][out] */ IGPMResult **ppIGPMResult) = 0;
        
        virtual /* [helpstring][id] */ HRESULT STDMETHODCALLTYPE SetSecurityDescriptor( 
            /* [in] */ ULONG ulFlags,
            /* [in] */ IDispatch *pSD) = 0;
        
        virtual /* [helpstring][id] */ HRESULT STDMETHODCALLTYPE GetSecurityDescriptor( 
            /* [in] */ ULONG ulFlags,
            /* [retval][out] */ IDispatch **ppSD) = 0;
        
        virtual /* [helpstring][id] */ HRESULT STDMETHODCALLTYPE IsACLConsistent( 
            /* [retval][out] */ VARIANT_BOOL *pvbConsistent) = 0;
        
        virtual /* [helpstring][id] */ HRESULT STDMETHODCALLTYPE Diff( 
            /* [in] */ IGPMGPO *pIGPMSource2,
            /* [in] */ BSTR bstrTransform,
            /* [in] */ BSTR bstrTargetFile,
            /* [in] */ IGPMAsyncProgress *pIGPMProgress,
            /* [out] */ IGPMAsyncCancel **ppIGPMCancel,
            /* [out] */ VARIANT *pData,
            /* [out] */ IGPMStatusMsgCollection **ppIGPMStatusMsgCollection) = 0;
        
    };
    
#else 	/* C style interface */

    typedef struct IGPMGPOVtbl
    {
        BEGIN_INTERFACE
        
        HRESULT ( STDMETHODCALLTYPE *QueryInterface )( 
            IGPMGPO * This,
            /* [in] */ REFIID riid,
            /* [iid_is][out] */ void **ppvObject);
        
        ULONG ( STDMETHODCALLTYPE *AddRef )( 
            IGPMGPO * This);
        
        ULONG ( STDMETHODCALLTYPE *Release )( 
            IGPMGPO * This);
        
        HRESULT ( STDMETHODCALLTYPE *GetTypeInfoCount )( 
            IGPMGPO * This,
            /* [out] */ UINT *pctinfo);
        
        HRESULT ( STDMETHODCALLTYPE *GetTypeInfo )( 
            IGPMGPO * This,
            /* [in] */ UINT iTInfo,
            /* [in] */ LCID lcid,
            /* [out] */ ITypeInfo **ppTInfo);
        
        HRESULT ( STDMETHODCALLTYPE *GetIDsOfNames )( 
            IGPMGPO * This,
            /* [in] */ REFIID riid,
            /* [size_is][in] */ LPOLESTR *rgszNames,
            /* [in] */ UINT cNames,
            /* [in] */ LCID lcid,
            /* [size_is][out] */ DISPID *rgDispId);
        
        /* [local] */ HRESULT ( STDMETHODCALLTYPE *Invoke )( 
            IGPMGPO * This,
            /* [in] */ DISPID dispIdMember,
            /* [in] */ REFIID riid,
            /* [in] */ LCID lcid,
            /* [in] */ WORD wFlags,
            /* [out][in] */ DISPPARAMS *pDispParams,
            /* [out] */ VARIANT *pVarResult,
            /* [out] */ EXCEPINFO *pExcepInfo,
            /* [out] */ UINT *puArgErr);
        
        /* [helpstring][id][propget] */ HRESULT ( STDMETHODCALLTYPE *get_DisplayName )( 
            IGPMGPO * This,
            /* [retval][out] */ BSTR *pVal);
        
        /* [helpstring][id][propput] */ HRESULT ( STDMETHODCALLTYPE *put_DisplayName )( 
            IGPMGPO * This,
            /* [in] */ BSTR newVal);
        
        /* [helpstring][id][propget] */ HRESULT ( STDMETHODCALLTYPE *get_Path )( 
            IGPMGPO * This,
            /* [retval][out] */ BSTR *pVal);
        
        /* [helpstring][id][propget] */ HRESULT ( STDMETHODCALLTYPE *get_ID )( 
            IGPMGPO * This,
            /* [retval][out] */ BSTR *pVal);
        
        /* [helpstring][id][propget] */ HRESULT ( STDMETHODCALLTYPE *get_DomainName )( 
            IGPMGPO * This,
            /* [retval][out] */ BSTR *pVal);
        
        /* [helpstring][id][propget] */ HRESULT ( STDMETHODCALLTYPE *get_CreationTime )( 
            IGPMGPO * This,
            /* [retval][out] */ DATE *pDate);
        
        /* [helpstring][id][propget] */ HRESULT ( STDMETHODCALLTYPE *get_ModificationTime )( 
            IGPMGPO * This,
            /* [retval][out] */ DATE *pDate);
        
        /* [helpstring][id][propget] */ HRESULT ( STDMETHODCALLTYPE *get_UserDSVersionNumber )( 
            IGPMGPO * This,
            /* [retval][out] */ ULONG *pVal);
        
        /* [helpstring][id][propget] */ HRESULT ( STDMETHODCALLTYPE *get_ComputerDSVersionNumber )( 
            IGPMGPO * This,
            /* [retval][out] */ ULONG *pVal);
        
        /* [helpstring][id][propget] */ HRESULT ( STDMETHODCALLTYPE *get_UserSysvolVersionNumber )( 
            IGPMGPO * This,
            /* [retval][out] */ ULONG *pVal);
        
        /* [helpstring][id][propget] */ HRESULT ( STDMETHODCALLTYPE *get_ComputerSysvolVersionNumber )( 
            IGPMGPO * This,
            /* [retval][out] */ ULONG *pVal);
        
        /* [helpstring][id] */ HRESULT ( STDMETHODCALLTYPE *GetWMIFilter )( 
            IGPMGPO * This,
            /* [retval][out] */ IGPMWMIFilter **ppIGPMWMIFilter);
        
        /* [helpstring][id] */ HRESULT ( STDMETHODCALLTYPE *SetWMIFilter )( 
            IGPMGPO * This,
            /* [in] */ IGPMWMIFilter *pIGPMWMIFilter);
        
        /* [helpstring][id] */ HRESULT ( STDMETHODCALLTYPE *SetUserEnabled )( 
            IGPMGPO * This,
            /* [in] */ VARIANT_BOOL vbEnabled);
        
        /* [helpstring][id] */ HRESULT ( STDMETHODCALLTYPE *SetComputerEnabled )( 
            IGPMGPO * This,
            /* [in] */ VARIANT_BOOL vbEnabled);
        
        /* [helpstring][id] */ HRESULT ( STDMETHODCALLTYPE *IsUserEnabled )( 
            IGPMGPO * This,
            /* [retval][out] */ VARIANT_BOOL *pvbEnabled);
        
        /* [helpstring][id] */ HRESULT ( STDMETHODCALLTYPE *IsComputerEnabled )( 
            IGPMGPO * This,
            /* [retval][out] */ VARIANT_BOOL *pvbEnabled);
        
        /* [helpstring][id] */ HRESULT ( STDMETHODCALLTYPE *GetSecurityInfo )( 
            IGPMGPO * This,
            /* [retval][out] */ IGPMSecurityInfo **ppSecurityInfo);
        
        /* [helpstring][id] */ HRESULT ( STDMETHODCALLTYPE *SetSecurityInfo )( 
            IGPMGPO * This,
            /* [in] */ IGPMSecurityInfo *pSecurityInfo);
        
        /* [helpstring][id] */ HRESULT ( STDMETHODCALLTYPE *Delete )( 
            IGPMGPO * This);
        
        /* [helpstring][id] */ HRESULT ( STDMETHODCALLTYPE *Backup )( 
            IGPMGPO * This,
            /* [in] */ BSTR bstrBackupDir,
            /* [in] */ BSTR bstrComment,
            /* [optional][in] */ VARIANT *pvarGPMProgress,
            /* [optional][out] */ VARIANT *pvarGPMCancel,
            /* [retval][out] */ IGPMResult **ppIGPMResult);
        
        /* [helpstring][id] */ HRESULT ( STDMETHODCALLTYPE *Import )( 
            IGPMGPO * This,
            /* [in] */ GPMResolveOption gpmResolveGroupsOptions,
            /* [in] */ IGPMBackup *pIGPMBackup,
            /* [optional][in] */ VARIANT *pvarTranslationTablePath,
            /* [optional][in] */ VARIANT *pvarGPMProgress,
            /* [optional][out] */ VARIANT *pvarGPMCancel,
            /* [retval][out] */ IGPMResult **ppIGPMResult);
        
        /* [helpstring][id] */ HRESULT ( STDMETHODCALLTYPE *GenerateReport )( 
            IGPMGPO * This,
            /* [in] */ GPMReportType gpmReportType,
            /* [optional][in] */ VARIANT *pvarGPMProgress,
            /* [optional][out] */ VARIANT *pvarGPMCancel,
            /* [retval][out] */ IGPMResult **ppIGPMResult);
        
        /* [helpstring][id] */ HRESULT ( STDMETHODCALLTYPE *GenerateReportToFile )( 
            IGPMGPO * This,
            /* [in] */ GPMReportType gpmReportType,
            /* [in] */ BSTR bstrTargetFilePath,
            /* [retval][out] */ IGPMResult **ppIGPMResult);
        
        /* [helpstring][id] */ HRESULT ( STDMETHODCALLTYPE *CopyTo )( 
            IGPMGPO * This,
            /* [in] */ GPMResolveOption gpmResolveGroupsOptions,
            /* [in] */ IGPMDomain *pIGPMDomain,
            /* [optional][in] */ VARIANT *pvarTranslationTablePath,
            /* [optional][in] */ VARIANT *pvarGPMProgress,
            /* [optional][out] */ VARIANT *pvarGPMCancel,
            /* [retval][out] */ IGPMResult **ppIGPMResult);
        
        /* [helpstring][id] */ HRESULT ( STDMETHODCALLTYPE *SetSecurityDescriptor )( 
            IGPMGPO * This,
            /* [in] */ ULONG ulFlags,
            /* [in] */ IDispatch *pSD);
        
        /* [helpstring][id] */ HRESULT ( STDMETHODCALLTYPE *GetSecurityDescriptor )( 
            IGPMGPO * This,
            /* [in] */ ULONG ulFlags,
            /* [retval][out] */ IDispatch **ppSD);
        
        /* [helpstring][id] */ HRESULT ( STDMETHODCALLTYPE *IsACLConsistent )( 
            IGPMGPO * This,
            /* [retval][out] */ VARIANT_BOOL *pvbConsistent);
        
        /* [helpstring][id] */ HRESULT ( STDMETHODCALLTYPE *Diff )( 
            IGPMGPO * This,
            /* [in] */ IGPMGPO *pIGPMSource2,
            /* [in] */ BSTR bstrTransform,
            /* [in] */ BSTR bstrTargetFile,
            /* [in] */ IGPMAsyncProgress *pIGPMProgress,
            /* [out] */ IGPMAsyncCancel **ppIGPMCancel,
            /* [out] */ VARIANT *pData,
            /* [out] */ IGPMStatusMsgCollection **ppIGPMStatusMsgCollection);
        
        END_INTERFACE
    } IGPMGPOVtbl;

    interface IGPMGPO
    {
        CONST_VTBL struct IGPMGPOVtbl *lpVtbl;
    };

    

#ifdef COBJMACROS


#define IGPMGPO_QueryInterface(This,riid,ppvObject)	\
    (This)->lpVtbl -> QueryInterface(This,riid,ppvObject)

#define IGPMGPO_AddRef(This)	\
    (This)->lpVtbl -> AddRef(This)

#define IGPMGPO_Release(This)	\
    (This)->lpVtbl -> Release(This)


#define IGPMGPO_GetTypeInfoCount(This,pctinfo)	\
    (This)->lpVtbl -> GetTypeInfoCount(This,pctinfo)

#define IGPMGPO_GetTypeInfo(This,iTInfo,lcid,ppTInfo)	\
    (This)->lpVtbl -> GetTypeInfo(This,iTInfo,lcid,ppTInfo)

#define IGPMGPO_GetIDsOfNames(This,riid,rgszNames,cNames,lcid,rgDispId)	\
    (This)->lpVtbl -> GetIDsOfNames(This,riid,rgszNames,cNames,lcid,rgDispId)

#define IGPMGPO_Invoke(This,dispIdMember,riid,lcid,wFlags,pDispParams,pVarResult,pExcepInfo,puArgErr)	\
    (This)->lpVtbl -> Invoke(This,dispIdMember,riid,lcid,wFlags,pDispParams,pVarResult,pExcepInfo,puArgErr)


#define IGPMGPO_get_DisplayName(This,pVal)	\
    (This)->lpVtbl -> get_DisplayName(This,pVal)

#define IGPMGPO_put_DisplayName(This,newVal)	\
    (This)->lpVtbl -> put_DisplayName(This,newVal)

#define IGPMGPO_get_Path(This,pVal)	\
    (This)->lpVtbl -> get_Path(This,pVal)

#define IGPMGPO_get_ID(This,pVal)	\
    (This)->lpVtbl -> get_ID(This,pVal)

#define IGPMGPO_get_DomainName(This,pVal)	\
    (This)->lpVtbl -> get_DomainName(This,pVal)

#define IGPMGPO_get_CreationTime(This,pDate)	\
    (This)->lpVtbl -> get_CreationTime(This,pDate)

#define IGPMGPO_get_ModificationTime(This,pDate)	\
    (This)->lpVtbl -> get_ModificationTime(This,pDate)

#define IGPMGPO_get_UserDSVersionNumber(This,pVal)	\
    (This)->lpVtbl -> get_UserDSVersionNumber(This,pVal)

#define IGPMGPO_get_ComputerDSVersionNumber(This,pVal)	\
    (This)->lpVtbl -> get_ComputerDSVersionNumber(This,pVal)

#define IGPMGPO_get_UserSysvolVersionNumber(This,pVal)	\
    (This)->lpVtbl -> get_UserSysvolVersionNumber(This,pVal)

#define IGPMGPO_get_ComputerSysvolVersionNumber(This,pVal)	\
    (This)->lpVtbl -> get_ComputerSysvolVersionNumber(This,pVal)

#define IGPMGPO_GetWMIFilter(This,ppIGPMWMIFilter)	\
    (This)->lpVtbl -> GetWMIFilter(This,ppIGPMWMIFilter)

#define IGPMGPO_SetWMIFilter(This,pIGPMWMIFilter)	\
    (This)->lpVtbl -> SetWMIFilter(This,pIGPMWMIFilter)

#define IGPMGPO_SetUserEnabled(This,vbEnabled)	\
    (This)->lpVtbl -> SetUserEnabled(This,vbEnabled)

#define IGPMGPO_SetComputerEnabled(This,vbEnabled)	\
    (This)->lpVtbl -> SetComputerEnabled(This,vbEnabled)

#define IGPMGPO_IsUserEnabled(This,pvbEnabled)	\
    (This)->lpVtbl -> IsUserEnabled(This,pvbEnabled)

#define IGPMGPO_IsComputerEnabled(This,pvbEnabled)	\
    (This)->lpVtbl -> IsComputerEnabled(This,pvbEnabled)

#define IGPMGPO_GetSecurityInfo(This,ppSecurityInfo)	\
    (This)->lpVtbl -> GetSecurityInfo(This,ppSecurityInfo)

#define IGPMGPO_SetSecurityInfo(This,pSecurityInfo)	\
    (This)->lpVtbl -> SetSecurityInfo(This,pSecurityInfo)

#define IGPMGPO_Delete(This)	\
    (This)->lpVtbl -> Delete(This)

#define IGPMGPO_Backup(This,bstrBackupDir,bstrComment,pvarGPMProgress,pvarGPMCancel,ppIGPMResult)	\
    (This)->lpVtbl -> Backup(This,bstrBackupDir,bstrComment,pvarGPMProgress,pvarGPMCancel,ppIGPMResult)

#define IGPMGPO_Import(This,gpmResolveGroupsOptions,pIGPMBackup,pvarTranslationTablePath,pvarGPMProgress,pvarGPMCancel,ppIGPMResult)	\
    (This)->lpVtbl -> Import(This,gpmResolveGroupsOptions,pIGPMBackup,pvarTranslationTablePath,pvarGPMProgress,pvarGPMCancel,ppIGPMResult)

#define IGPMGPO_GenerateReport(This,gpmReportType,pvarGPMProgress,pvarGPMCancel,ppIGPMResult)	\
    (This)->lpVtbl -> GenerateReport(This,gpmReportType,pvarGPMProgress,pvarGPMCancel,ppIGPMResult)

#define IGPMGPO_GenerateReportToFile(This,gpmReportType,bstrTargetFilePath,ppIGPMResult)	\
    (This)->lpVtbl -> GenerateReportToFile(This,gpmReportType,bstrTargetFilePath,ppIGPMResult)

#define IGPMGPO_CopyTo(This,gpmResolveGroupsOptions,pIGPMDomain,pvarTranslationTablePath,pvarGPMProgress,pvarGPMCancel,ppIGPMResult)	\
    (This)->lpVtbl -> CopyTo(This,gpmResolveGroupsOptions,pIGPMDomain,pvarTranslationTablePath,pvarGPMProgress,pvarGPMCancel,ppIGPMResult)

#define IGPMGPO_SetSecurityDescriptor(This,ulFlags,pSD)	\
    (This)->lpVtbl -> SetSecurityDescriptor(This,ulFlags,pSD)

#define IGPMGPO_GetSecurityDescriptor(This,ulFlags,ppSD)	\
    (This)->lpVtbl -> GetSecurityDescriptor(This,ulFlags,ppSD)

#define IGPMGPO_IsACLConsistent(This,pvbConsistent)	\
    (This)->lpVtbl -> IsACLConsistent(This,pvbConsistent)

#define IGPMGPO_Diff(This,pIGPMSource2,bstrTransform,bstrTargetFile,pIGPMProgress,ppIGPMCancel,pData,ppIGPMStatusMsgCollection)	\
    (This)->lpVtbl -> Diff(This,pIGPMSource2,bstrTransform,bstrTargetFile,pIGPMProgress,ppIGPMCancel,pData,ppIGPMStatusMsgCollection)

#endif /* COBJMACROS */


#endif 	/* C style interface */



/* [helpstring][id][propget] */ HRESULT STDMETHODCALLTYPE IGPMGPO_get_DisplayName_Proxy( 
    IGPMGPO * This,
    /* [retval][out] */ BSTR *pVal);


void __RPC_STUB IGPMGPO_get_DisplayName_Stub(
    IRpcStubBuffer *This,
    IRpcChannelBuffer *_pRpcChannelBuffer,
    PRPC_MESSAGE _pRpcMessage,
    DWORD *_pdwStubPhase);


/* [helpstring][id][propput] */ HRESULT STDMETHODCALLTYPE IGPMGPO_put_DisplayName_Proxy( 
    IGPMGPO * This,
    /* [in] */ BSTR newVal);


void __RPC_STUB IGPMGPO_put_DisplayName_Stub(
    IRpcStubBuffer *This,
    IRpcChannelBuffer *_pRpcChannelBuffer,
    PRPC_MESSAGE _pRpcMessage,
    DWORD *_pdwStubPhase);


/* [helpstring][id][propget] */ HRESULT STDMETHODCALLTYPE IGPMGPO_get_Path_Proxy( 
    IGPMGPO * This,
    /* [retval][out] */ BSTR *pVal);


void __RPC_STUB IGPMGPO_get_Path_Stub(
    IRpcStubBuffer *This,
    IRpcChannelBuffer *_pRpcChannelBuffer,
    PRPC_MESSAGE _pRpcMessage,
    DWORD *_pdwStubPhase);


/* [helpstring][id][propget] */ HRESULT STDMETHODCALLTYPE IGPMGPO_get_ID_Proxy( 
    IGPMGPO * This,
    /* [retval][out] */ BSTR *pVal);


void __RPC_STUB IGPMGPO_get_ID_Stub(
    IRpcStubBuffer *This,
    IRpcChannelBuffer *_pRpcChannelBuffer,
    PRPC_MESSAGE _pRpcMessage,
    DWORD *_pdwStubPhase);


/* [helpstring][id][propget] */ HRESULT STDMETHODCALLTYPE IGPMGPO_get_DomainName_Proxy( 
    IGPMGPO * This,
    /* [retval][out] */ BSTR *pVal);


void __RPC_STUB IGPMGPO_get_DomainName_Stub(
    IRpcStubBuffer *This,
    IRpcChannelBuffer *_pRpcChannelBuffer,
    PRPC_MESSAGE _pRpcMessage,
    DWORD *_pdwStubPhase);


/* [helpstring][id][propget] */ HRESULT STDMETHODCALLTYPE IGPMGPO_get_CreationTime_Proxy( 
    IGPMGPO * This,
    /* [retval][out] */ DATE *pDate);


void __RPC_STUB IGPMGPO_get_CreationTime_Stub(
    IRpcStubBuffer *This,
    IRpcChannelBuffer *_pRpcChannelBuffer,
    PRPC_MESSAGE _pRpcMessage,
    DWORD *_pdwStubPhase);


/* [helpstring][id][propget] */ HRESULT STDMETHODCALLTYPE IGPMGPO_get_ModificationTime_Proxy( 
    IGPMGPO * This,
    /* [retval][out] */ DATE *pDate);


void __RPC_STUB IGPMGPO_get_ModificationTime_Stub(
    IRpcStubBuffer *This,
    IRpcChannelBuffer *_pRpcChannelBuffer,
    PRPC_MESSAGE _pRpcMessage,
    DWORD *_pdwStubPhase);


/* [helpstring][id][propget] */ HRESULT STDMETHODCALLTYPE IGPMGPO_get_UserDSVersionNumber_Proxy( 
    IGPMGPO * This,
    /* [retval][out] */ ULONG *pVal);


void __RPC_STUB IGPMGPO_get_UserDSVersionNumber_Stub(
    IRpcStubBuffer *This,
    IRpcChannelBuffer *_pRpcChannelBuffer,
    PRPC_MESSAGE _pRpcMessage,
    DWORD *_pdwStubPhase);


/* [helpstring][id][propget] */ HRESULT STDMETHODCALLTYPE IGPMGPO_get_ComputerDSVersionNumber_Proxy( 
    IGPMGPO * This,
    /* [retval][out] */ ULONG *pVal);


void __RPC_STUB IGPMGPO_get_ComputerDSVersionNumber_Stub(
    IRpcStubBuffer *This,
    IRpcChannelBuffer *_pRpcChannelBuffer,
    PRPC_MESSAGE _pRpcMessage,
    DWORD *_pdwStubPhase);


/* [helpstring][id][propget] */ HRESULT STDMETHODCALLTYPE IGPMGPO_get_UserSysvolVersionNumber_Proxy( 
    IGPMGPO * This,
    /* [retval][out] */ ULONG *pVal);


void __RPC_STUB IGPMGPO_get_UserSysvolVersionNumber_Stub(
    IRpcStubBuffer *This,
    IRpcChannelBuffer *_pRpcChannelBuffer,
    PRPC_MESSAGE _pRpcMessage,
    DWORD *_pdwStubPhase);


/* [helpstring][id][propget] */ HRESULT STDMETHODCALLTYPE IGPMGPO_get_ComputerSysvolVersionNumber_Proxy( 
    IGPMGPO * This,
    /* [retval][out] */ ULONG *pVal);


void __RPC_STUB IGPMGPO_get_ComputerSysvolVersionNumber_Stub(
    IRpcStubBuffer *This,
    IRpcChannelBuffer *_pRpcChannelBuffer,
    PRPC_MESSAGE _pRpcMessage,
    DWORD *_pdwStubPhase);


/* [helpstring][id] */ HRESULT STDMETHODCALLTYPE IGPMGPO_GetWMIFilter_Proxy( 
    IGPMGPO * This,
    /* [retval][out] */ IGPMWMIFilter **ppIGPMWMIFilter);


void __RPC_STUB IGPMGPO_GetWMIFilter_Stub(
    IRpcStubBuffer *This,
    IRpcChannelBuffer *_pRpcChannelBuffer,
    PRPC_MESSAGE _pRpcMessage,
    DWORD *_pdwStubPhase);


/* [helpstring][id] */ HRESULT STDMETHODCALLTYPE IGPMGPO_SetWMIFilter_Proxy( 
    IGPMGPO * This,
    /* [in] */ IGPMWMIFilter *pIGPMWMIFilter);


void __RPC_STUB IGPMGPO_SetWMIFilter_Stub(
    IRpcStubBuffer *This,
    IRpcChannelBuffer *_pRpcChannelBuffer,
    PRPC_MESSAGE _pRpcMessage,
    DWORD *_pdwStubPhase);


/* [helpstring][id] */ HRESULT STDMETHODCALLTYPE IGPMGPO_SetUserEnabled_Proxy( 
    IGPMGPO * This,
    /* [in] */ VARIANT_BOOL vbEnabled);


void __RPC_STUB IGPMGPO_SetUserEnabled_Stub(
    IRpcStubBuffer *This,
    IRpcChannelBuffer *_pRpcChannelBuffer,
    PRPC_MESSAGE _pRpcMessage,
    DWORD *_pdwStubPhase);


/* [helpstring][id] */ HRESULT STDMETHODCALLTYPE IGPMGPO_SetComputerEnabled_Proxy( 
    IGPMGPO * This,
    /* [in] */ VARIANT_BOOL vbEnabled);


void __RPC_STUB IGPMGPO_SetComputerEnabled_Stub(
    IRpcStubBuffer *This,
    IRpcChannelBuffer *_pRpcChannelBuffer,
    PRPC_MESSAGE _pRpcMessage,
    DWORD *_pdwStubPhase);


/* [helpstring][id] */ HRESULT STDMETHODCALLTYPE IGPMGPO_IsUserEnabled_Proxy( 
    IGPMGPO * This,
    /* [retval][out] */ VARIANT_BOOL *pvbEnabled);


void __RPC_STUB IGPMGPO_IsUserEnabled_Stub(
    IRpcStubBuffer *This,
    IRpcChannelBuffer *_pRpcChannelBuffer,
    PRPC_MESSAGE _pRpcMessage,
    DWORD *_pdwStubPhase);


/* [helpstring][id] */ HRESULT STDMETHODCALLTYPE IGPMGPO_IsComputerEnabled_Proxy( 
    IGPMGPO * This,
    /* [retval][out] */ VARIANT_BOOL *pvbEnabled);


void __RPC_STUB IGPMGPO_IsComputerEnabled_Stub(
    IRpcStubBuffer *This,
    IRpcChannelBuffer *_pRpcChannelBuffer,
    PRPC_MESSAGE _pRpcMessage,
    DWORD *_pdwStubPhase);


/* [helpstring][id] */ HRESULT STDMETHODCALLTYPE IGPMGPO_GetSecurityInfo_Proxy( 
    IGPMGPO * This,
    /* [retval][out] */ IGPMSecurityInfo **ppSecurityInfo);


void __RPC_STUB IGPMGPO_GetSecurityInfo_Stub(
    IRpcStubBuffer *This,
    IRpcChannelBuffer *_pRpcChannelBuffer,
    PRPC_MESSAGE _pRpcMessage,
    DWORD *_pdwStubPhase);


/* [helpstring][id] */ HRESULT STDMETHODCALLTYPE IGPMGPO_SetSecurityInfo_Proxy( 
    IGPMGPO * This,
    /* [in] */ IGPMSecurityInfo *pSecurityInfo);


void __RPC_STUB IGPMGPO_SetSecurityInfo_Stub(
    IRpcStubBuffer *This,
    IRpcChannelBuffer *_pRpcChannelBuffer,
    PRPC_MESSAGE _pRpcMessage,
    DWORD *_pdwStubPhase);


/* [helpstring][id] */ HRESULT STDMETHODCALLTYPE IGPMGPO_Delete_Proxy( 
    IGPMGPO * This);


void __RPC_STUB IGPMGPO_Delete_Stub(
    IRpcStubBuffer *This,
    IRpcChannelBuffer *_pRpcChannelBuffer,
    PRPC_MESSAGE _pRpcMessage,
    DWORD *_pdwStubPhase);


/* [helpstring][id] */ HRESULT STDMETHODCALLTYPE IGPMGPO_Backup_Proxy( 
    IGPMGPO * This,
    /* [in] */ BSTR bstrBackupDir,
    /* [in] */ BSTR bstrComment,
    /* [optional][in] */ VARIANT *pvarGPMProgress,
    /* [optional][out] */ VARIANT *pvarGPMCancel,
    /* [retval][out] */ IGPMResult **ppIGPMResult);


void __RPC_STUB IGPMGPO_Backup_Stub(
    IRpcStubBuffer *This,
    IRpcChannelBuffer *_pRpcChannelBuffer,
    PRPC_MESSAGE _pRpcMessage,
    DWORD *_pdwStubPhase);


/* [helpstring][id] */ HRESULT STDMETHODCALLTYPE IGPMGPO_Import_Proxy( 
    IGPMGPO * This,
    /* [in] */ GPMResolveOption gpmResolveGroupsOptions,
    /* [in] */ IGPMBackup *pIGPMBackup,
    /* [optional][in] */ VARIANT *pvarTranslationTablePath,
    /* [optional][in] */ VARIANT *pvarGPMProgress,
    /* [optional][out] */ VARIANT *pvarGPMCancel,
    /* [retval][out] */ IGPMResult **ppIGPMResult);


void __RPC_STUB IGPMGPO_Import_Stub(
    IRpcStubBuffer *This,
    IRpcChannelBuffer *_pRpcChannelBuffer,
    PRPC_MESSAGE _pRpcMessage,
    DWORD *_pdwStubPhase);


/* [helpstring][id] */ HRESULT STDMETHODCALLTYPE IGPMGPO_GenerateReport_Proxy( 
    IGPMGPO * This,
    /* [in] */ GPMReportType gpmReportType,
    /* [optional][in] */ VARIANT *pvarGPMProgress,
    /* [optional][out] */ VARIANT *pvarGPMCancel,
    /* [retval][out] */ IGPMResult **ppIGPMResult);


void __RPC_STUB IGPMGPO_GenerateReport_Stub(
    IRpcStubBuffer *This,
    IRpcChannelBuffer *_pRpcChannelBuffer,
    PRPC_MESSAGE _pRpcMessage,
    DWORD *_pdwStubPhase);


/* [helpstring][id] */ HRESULT STDMETHODCALLTYPE IGPMGPO_GenerateReportToFile_Proxy( 
    IGPMGPO * This,
    /* [in] */ GPMReportType gpmReportType,
    /* [in] */ BSTR bstrTargetFilePath,
    /* [retval][out] */ IGPMResult **ppIGPMResult);


void __RPC_STUB IGPMGPO_GenerateReportToFile_Stub(
    IRpcStubBuffer *This,
    IRpcChannelBuffer *_pRpcChannelBuffer,
    PRPC_MESSAGE _pRpcMessage,
    DWORD *_pdwStubPhase);


/* [helpstring][id] */ HRESULT STDMETHODCALLTYPE IGPMGPO_CopyTo_Proxy( 
    IGPMGPO * This,
    /* [in] */ GPMResolveOption gpmResolveGroupsOptions,
    /* [in] */ IGPMDomain *pIGPMDomain,
    /* [optional][in] */ VARIANT *pvarTranslationTablePath,
    /* [optional][in] */ VARIANT *pvarGPMProgress,
    /* [optional][out] */ VARIANT *pvarGPMCancel,
    /* [retval][out] */ IGPMResult **ppIGPMResult);


void __RPC_STUB IGPMGPO_CopyTo_Stub(
    IRpcStubBuffer *This,
    IRpcChannelBuffer *_pRpcChannelBuffer,
    PRPC_MESSAGE _pRpcMessage,
    DWORD *_pdwStubPhase);


/* [helpstring][id] */ HRESULT STDMETHODCALLTYPE IGPMGPO_SetSecurityDescriptor_Proxy( 
    IGPMGPO * This,
    /* [in] */ ULONG ulFlags,
    /* [in] */ IDispatch *pSD);


void __RPC_STUB IGPMGPO_SetSecurityDescriptor_Stub(
    IRpcStubBuffer *This,
    IRpcChannelBuffer *_pRpcChannelBuffer,
    PRPC_MESSAGE _pRpcMessage,
    DWORD *_pdwStubPhase);


/* [helpstring][id] */ HRESULT STDMETHODCALLTYPE IGPMGPO_GetSecurityDescriptor_Proxy( 
    IGPMGPO * This,
    /* [in] */ ULONG ulFlags,
    /* [retval][out] */ IDispatch **ppSD);


void __RPC_STUB IGPMGPO_GetSecurityDescriptor_Stub(
    IRpcStubBuffer *This,
    IRpcChannelBuffer *_pRpcChannelBuffer,
    PRPC_MESSAGE _pRpcMessage,
    DWORD *_pdwStubPhase);


/* [helpstring][id] */ HRESULT STDMETHODCALLTYPE IGPMGPO_IsACLConsistent_Proxy( 
    IGPMGPO * This,
    /* [retval][out] */ VARIANT_BOOL *pvbConsistent);


void __RPC_STUB IGPMGPO_IsACLConsistent_Stub(
    IRpcStubBuffer *This,
    IRpcChannelBuffer *_pRpcChannelBuffer,
    PRPC_MESSAGE _pRpcMessage,
    DWORD *_pdwStubPhase);


/* [helpstring][id] */ HRESULT STDMETHODCALLTYPE IGPMGPO_Diff_Proxy( 
    IGPMGPO * This,
    /* [in] */ IGPMGPO *pIGPMSource2,
    /* [in] */ BSTR bstrTransform,
    /* [in] */ BSTR bstrTargetFile,
    /* [in] */ IGPMAsyncProgress *pIGPMProgress,
    /* [out] */ IGPMAsyncCancel **ppIGPMCancel,
    /* [out] */ VARIANT *pData,
    /* [out] */ IGPMStatusMsgCollection **ppIGPMStatusMsgCollection);


void __RPC_STUB IGPMGPO_Diff_Stub(
    IRpcStubBuffer *This,
    IRpcChannelBuffer *_pRpcChannelBuffer,
    PRPC_MESSAGE _pRpcMessage,
    DWORD *_pdwStubPhase);



#endif 	/* __IGPMGPO_INTERFACE_DEFINED__ */


#ifndef __IGPMGPOCollection_INTERFACE_DEFINED__
#define __IGPMGPOCollection_INTERFACE_DEFINED__

/* interface IGPMGPOCollection */
/* [unique][helpstring][dual][uuid][object] */ 


EXTERN_C const IID IID_IGPMGPOCollection;

#if defined(__cplusplus) && !defined(CINTERFACE)
    
    MIDL_INTERFACE("F0F0D5CF-70CA-4C39-9E29-B642F8726C01")
    IGPMGPOCollection : public IDispatch
    {
    public:
        virtual /* [helpstring][id][propget] */ HRESULT STDMETHODCALLTYPE get_Count( 
            /* [retval][out] */ long *pVal) = 0;
        
        virtual /* [helpstring][id][propget] */ HRESULT STDMETHODCALLTYPE get_Item( 
            /* [in] */ long lIndex,
            /* [retval][out] */ VARIANT *pVal) = 0;
        
        virtual /* [helpstring][id][propget] */ HRESULT STDMETHODCALLTYPE get__NewEnum( 
            /* [retval][out] */ IEnumVARIANT **ppIGPMGPOs) = 0;
        
    };
    
#else 	/* C style interface */

    typedef struct IGPMGPOCollectionVtbl
    {
        BEGIN_INTERFACE
        
        HRESULT ( STDMETHODCALLTYPE *QueryInterface )( 
            IGPMGPOCollection * This,
            /* [in] */ REFIID riid,
            /* [iid_is][out] */ void **ppvObject);
        
        ULONG ( STDMETHODCALLTYPE *AddRef )( 
            IGPMGPOCollection * This);
        
        ULONG ( STDMETHODCALLTYPE *Release )( 
            IGPMGPOCollection * This);
        
        HRESULT ( STDMETHODCALLTYPE *GetTypeInfoCount )( 
            IGPMGPOCollection * This,
            /* [out] */ UINT *pctinfo);
        
        HRESULT ( STDMETHODCALLTYPE *GetTypeInfo )( 
            IGPMGPOCollection * This,
            /* [in] */ UINT iTInfo,
            /* [in] */ LCID lcid,
            /* [out] */ ITypeInfo **ppTInfo);
        
        HRESULT ( STDMETHODCALLTYPE *GetIDsOfNames )( 
            IGPMGPOCollection * This,
            /* [in] */ REFIID riid,
            /* [size_is][in] */ LPOLESTR *rgszNames,
            /* [in] */ UINT cNames,
            /* [in] */ LCID lcid,
            /* [size_is][out] */ DISPID *rgDispId);
        
        /* [local] */ HRESULT ( STDMETHODCALLTYPE *Invoke )( 
            IGPMGPOCollection * This,
            /* [in] */ DISPID dispIdMember,
            /* [in] */ REFIID riid,
            /* [in] */ LCID lcid,
            /* [in] */ WORD wFlags,
            /* [out][in] */ DISPPARAMS *pDispParams,
            /* [out] */ VARIANT *pVarResult,
            /* [out] */ EXCEPINFO *pExcepInfo,
            /* [out] */ UINT *puArgErr);
        
        /* [helpstring][id][propget] */ HRESULT ( STDMETHODCALLTYPE *get_Count )( 
            IGPMGPOCollection * This,
            /* [retval][out] */ long *pVal);
        
        /* [helpstring][id][propget] */ HRESULT ( STDMETHODCALLTYPE *get_Item )( 
            IGPMGPOCollection * This,
            /* [in] */ long lIndex,
            /* [retval][out] */ VARIANT *pVal);
        
        /* [helpstring][id][propget] */ HRESULT ( STDMETHODCALLTYPE *get__NewEnum )( 
            IGPMGPOCollection * This,
            /* [retval][out] */ IEnumVARIANT **ppIGPMGPOs);
        
        END_INTERFACE
    } IGPMGPOCollectionVtbl;

    interface IGPMGPOCollection
    {
        CONST_VTBL struct IGPMGPOCollectionVtbl *lpVtbl;
    };

    

#ifdef COBJMACROS


#define IGPMGPOCollection_QueryInterface(This,riid,ppvObject)	\
    (This)->lpVtbl -> QueryInterface(This,riid,ppvObject)

#define IGPMGPOCollection_AddRef(This)	\
    (This)->lpVtbl -> AddRef(This)

#define IGPMGPOCollection_Release(This)	\
    (This)->lpVtbl -> Release(This)


#define IGPMGPOCollection_GetTypeInfoCount(This,pctinfo)	\
    (This)->lpVtbl -> GetTypeInfoCount(This,pctinfo)

#define IGPMGPOCollection_GetTypeInfo(This,iTInfo,lcid,ppTInfo)	\
    (This)->lpVtbl -> GetTypeInfo(This,iTInfo,lcid,ppTInfo)

#define IGPMGPOCollection_GetIDsOfNames(This,riid,rgszNames,cNames,lcid,rgDispId)	\
    (This)->lpVtbl -> GetIDsOfNames(This,riid,rgszNames,cNames,lcid,rgDispId)

#define IGPMGPOCollection_Invoke(This,dispIdMember,riid,lcid,wFlags,pDispParams,pVarResult,pExcepInfo,puArgErr)	\
    (This)->lpVtbl -> Invoke(This,dispIdMember,riid,lcid,wFlags,pDispParams,pVarResult,pExcepInfo,puArgErr)


#define IGPMGPOCollection_get_Count(This,pVal)	\
    (This)->lpVtbl -> get_Count(This,pVal)

#define IGPMGPOCollection_get_Item(This,lIndex,pVal)	\
    (This)->lpVtbl -> get_Item(This,lIndex,pVal)

#define IGPMGPOCollection_get__NewEnum(This,ppIGPMGPOs)	\
    (This)->lpVtbl -> get__NewEnum(This,ppIGPMGPOs)

#endif /* COBJMACROS */


#endif 	/* C style interface */



/* [helpstring][id][propget] */ HRESULT STDMETHODCALLTYPE IGPMGPOCollection_get_Count_Proxy( 
    IGPMGPOCollection * This,
    /* [retval][out] */ long *pVal);


void __RPC_STUB IGPMGPOCollection_get_Count_Stub(
    IRpcStubBuffer *This,
    IRpcChannelBuffer *_pRpcChannelBuffer,
    PRPC_MESSAGE _pRpcMessage,
    DWORD *_pdwStubPhase);


/* [helpstring][id][propget] */ HRESULT STDMETHODCALLTYPE IGPMGPOCollection_get_Item_Proxy( 
    IGPMGPOCollection * This,
    /* [in] */ long lIndex,
    /* [retval][out] */ VARIANT *pVal);


void __RPC_STUB IGPMGPOCollection_get_Item_Stub(
    IRpcStubBuffer *This,
    IRpcChannelBuffer *_pRpcChannelBuffer,
    PRPC_MESSAGE _pRpcMessage,
    DWORD *_pdwStubPhase);


/* [helpstring][id][propget] */ HRESULT STDMETHODCALLTYPE IGPMGPOCollection_get__NewEnum_Proxy( 
    IGPMGPOCollection * This,
    /* [retval][out] */ IEnumVARIANT **ppIGPMGPOs);


void __RPC_STUB IGPMGPOCollection_get__NewEnum_Stub(
    IRpcStubBuffer *This,
    IRpcChannelBuffer *_pRpcChannelBuffer,
    PRPC_MESSAGE _pRpcMessage,
    DWORD *_pdwStubPhase);



#endif 	/* __IGPMGPOCollection_INTERFACE_DEFINED__ */


#ifndef __IGPMGPOLink_INTERFACE_DEFINED__
#define __IGPMGPOLink_INTERFACE_DEFINED__

/* interface IGPMGPOLink */
/* [unique][helpstring][dual][uuid][object] */ 


EXTERN_C const IID IID_IGPMGPOLink;

#if defined(__cplusplus) && !defined(CINTERFACE)
    
    MIDL_INTERFACE("434B99BD-5DE7-478A-809C-C251721DF70C")
    IGPMGPOLink : public IDispatch
    {
    public:
        virtual /* [helpstring][id][propget] */ HRESULT STDMETHODCALLTYPE get_GPOID( 
            /* [retval][out] */ BSTR *pVal) = 0;
        
        virtual /* [helpstring][id][propget] */ HRESULT STDMETHODCALLTYPE get_GPODomain( 
            /* [retval][out] */ BSTR *pVal) = 0;
        
        virtual /* [helpstring][id][propget] */ HRESULT STDMETHODCALLTYPE get_Enabled( 
            /* [retval][out] */ VARIANT_BOOL *pVal) = 0;
        
        virtual /* [helpstring][id][propput] */ HRESULT STDMETHODCALLTYPE put_Enabled( 
            /* [in] */ VARIANT_BOOL newVal) = 0;
        
        virtual /* [helpstring][id][propget] */ HRESULT STDMETHODCALLTYPE get_Enforced( 
            /* [retval][out] */ VARIANT_BOOL *pVal) = 0;
        
        virtual /* [helpstring][id][propput] */ HRESULT STDMETHODCALLTYPE put_Enforced( 
            /* [in] */ VARIANT_BOOL newVal) = 0;
        
        virtual /* [helpstring][id][propget] */ HRESULT STDMETHODCALLTYPE get_SOMLinkOrder( 
            /* [retval][out] */ long *lVal) = 0;
        
        virtual /* [helpstring][id][propget] */ HRESULT STDMETHODCALLTYPE get_SOM( 
            /* [retval][out] */ IGPMSOM **ppIGPMSOM) = 0;
        
        virtual /* [helpstring][id] */ HRESULT STDMETHODCALLTYPE Delete( void) = 0;
        
    };
    
#else 	/* C style interface */

    typedef struct IGPMGPOLinkVtbl
    {
        BEGIN_INTERFACE
        
        HRESULT ( STDMETHODCALLTYPE *QueryInterface )( 
            IGPMGPOLink * This,
            /* [in] */ REFIID riid,
            /* [iid_is][out] */ void **ppvObject);
        
        ULONG ( STDMETHODCALLTYPE *AddRef )( 
            IGPMGPOLink * This);
        
        ULONG ( STDMETHODCALLTYPE *Release )( 
            IGPMGPOLink * This);
        
        HRESULT ( STDMETHODCALLTYPE *GetTypeInfoCount )( 
            IGPMGPOLink * This,
            /* [out] */ UINT *pctinfo);
        
        HRESULT ( STDMETHODCALLTYPE *GetTypeInfo )( 
            IGPMGPOLink * This,
            /* [in] */ UINT iTInfo,
            /* [in] */ LCID lcid,
            /* [out] */ ITypeInfo **ppTInfo);
        
        HRESULT ( STDMETHODCALLTYPE *GetIDsOfNames )( 
            IGPMGPOLink * This,
            /* [in] */ REFIID riid,
            /* [size_is][in] */ LPOLESTR *rgszNames,
            /* [in] */ UINT cNames,
            /* [in] */ LCID lcid,
            /* [size_is][out] */ DISPID *rgDispId);
        
        /* [local] */ HRESULT ( STDMETHODCALLTYPE *Invoke )( 
            IGPMGPOLink * This,
            /* [in] */ DISPID dispIdMember,
            /* [in] */ REFIID riid,
            /* [in] */ LCID lcid,
            /* [in] */ WORD wFlags,
            /* [out][in] */ DISPPARAMS *pDispParams,
            /* [out] */ VARIANT *pVarResult,
            /* [out] */ EXCEPINFO *pExcepInfo,
            /* [out] */ UINT *puArgErr);
        
        /* [helpstring][id][propget] */ HRESULT ( STDMETHODCALLTYPE *get_GPOID )( 
            IGPMGPOLink * This,
            /* [retval][out] */ BSTR *pVal);
        
        /* [helpstring][id][propget] */ HRESULT ( STDMETHODCALLTYPE *get_GPODomain )( 
            IGPMGPOLink * This,
            /* [retval][out] */ BSTR *pVal);
        
        /* [helpstring][id][propget] */ HRESULT ( STDMETHODCALLTYPE *get_Enabled )( 
            IGPMGPOLink * This,
            /* [retval][out] */ VARIANT_BOOL *pVal);
        
        /* [helpstring][id][propput] */ HRESULT ( STDMETHODCALLTYPE *put_Enabled )( 
            IGPMGPOLink * This,
            /* [in] */ VARIANT_BOOL newVal);
        
        /* [helpstring][id][propget] */ HRESULT ( STDMETHODCALLTYPE *get_Enforced )( 
            IGPMGPOLink * This,
            /* [retval][out] */ VARIANT_BOOL *pVal);
        
        /* [helpstring][id][propput] */ HRESULT ( STDMETHODCALLTYPE *put_Enforced )( 
            IGPMGPOLink * This,
            /* [in] */ VARIANT_BOOL newVal);
        
        /* [helpstring][id][propget] */ HRESULT ( STDMETHODCALLTYPE *get_SOMLinkOrder )( 
            IGPMGPOLink * This,
            /* [retval][out] */ long *lVal);
        
        /* [helpstring][id][propget] */ HRESULT ( STDMETHODCALLTYPE *get_SOM )( 
            IGPMGPOLink * This,
            /* [retval][out] */ IGPMSOM **ppIGPMSOM);
        
        /* [helpstring][id] */ HRESULT ( STDMETHODCALLTYPE *Delete )( 
            IGPMGPOLink * This);
        
        END_INTERFACE
    } IGPMGPOLinkVtbl;

    interface IGPMGPOLink
    {
        CONST_VTBL struct IGPMGPOLinkVtbl *lpVtbl;
    };

    

#ifdef COBJMACROS


#define IGPMGPOLink_QueryInterface(This,riid,ppvObject)	\
    (This)->lpVtbl -> QueryInterface(This,riid,ppvObject)

#define IGPMGPOLink_AddRef(This)	\
    (This)->lpVtbl -> AddRef(This)

#define IGPMGPOLink_Release(This)	\
    (This)->lpVtbl -> Release(This)


#define IGPMGPOLink_GetTypeInfoCount(This,pctinfo)	\
    (This)->lpVtbl -> GetTypeInfoCount(This,pctinfo)

#define IGPMGPOLink_GetTypeInfo(This,iTInfo,lcid,ppTInfo)	\
    (This)->lpVtbl -> GetTypeInfo(This,iTInfo,lcid,ppTInfo)

#define IGPMGPOLink_GetIDsOfNames(This,riid,rgszNames,cNames,lcid,rgDispId)	\
    (This)->lpVtbl -> GetIDsOfNames(This,riid,rgszNames,cNames,lcid,rgDispId)

#define IGPMGPOLink_Invoke(This,dispIdMember,riid,lcid,wFlags,pDispParams,pVarResult,pExcepInfo,puArgErr)	\
    (This)->lpVtbl -> Invoke(This,dispIdMember,riid,lcid,wFlags,pDispParams,pVarResult,pExcepInfo,puArgErr)


#define IGPMGPOLink_get_GPOID(This,pVal)	\
    (This)->lpVtbl -> get_GPOID(This,pVal)

#define IGPMGPOLink_get_GPODomain(This,pVal)	\
    (This)->lpVtbl -> get_GPODomain(This,pVal)

#define IGPMGPOLink_get_Enabled(This,pVal)	\
    (This)->lpVtbl -> get_Enabled(This,pVal)

#define IGPMGPOLink_put_Enabled(This,newVal)	\
    (This)->lpVtbl -> put_Enabled(This,newVal)

#define IGPMGPOLink_get_Enforced(This,pVal)	\
    (This)->lpVtbl -> get_Enforced(This,pVal)

#define IGPMGPOLink_put_Enforced(This,newVal)	\
    (This)->lpVtbl -> put_Enforced(This,newVal)

#define IGPMGPOLink_get_SOMLinkOrder(This,lVal)	\
    (This)->lpVtbl -> get_SOMLinkOrder(This,lVal)

#define IGPMGPOLink_get_SOM(This,ppIGPMSOM)	\
    (This)->lpVtbl -> get_SOM(This,ppIGPMSOM)

#define IGPMGPOLink_Delete(This)	\
    (This)->lpVtbl -> Delete(This)

#endif /* COBJMACROS */


#endif 	/* C style interface */



/* [helpstring][id][propget] */ HRESULT STDMETHODCALLTYPE IGPMGPOLink_get_GPOID_Proxy( 
    IGPMGPOLink * This,
    /* [retval][out] */ BSTR *pVal);


void __RPC_STUB IGPMGPOLink_get_GPOID_Stub(
    IRpcStubBuffer *This,
    IRpcChannelBuffer *_pRpcChannelBuffer,
    PRPC_MESSAGE _pRpcMessage,
    DWORD *_pdwStubPhase);


/* [helpstring][id][propget] */ HRESULT STDMETHODCALLTYPE IGPMGPOLink_get_GPODomain_Proxy( 
    IGPMGPOLink * This,
    /* [retval][out] */ BSTR *pVal);


void __RPC_STUB IGPMGPOLink_get_GPODomain_Stub(
    IRpcStubBuffer *This,
    IRpcChannelBuffer *_pRpcChannelBuffer,
    PRPC_MESSAGE _pRpcMessage,
    DWORD *_pdwStubPhase);


/* [helpstring][id][propget] */ HRESULT STDMETHODCALLTYPE IGPMGPOLink_get_Enabled_Proxy( 
    IGPMGPOLink * This,
    /* [retval][out] */ VARIANT_BOOL *pVal);


void __RPC_STUB IGPMGPOLink_get_Enabled_Stub(
    IRpcStubBuffer *This,
    IRpcChannelBuffer *_pRpcChannelBuffer,
    PRPC_MESSAGE _pRpcMessage,
    DWORD *_pdwStubPhase);


/* [helpstring][id][propput] */ HRESULT STDMETHODCALLTYPE IGPMGPOLink_put_Enabled_Proxy( 
    IGPMGPOLink * This,
    /* [in] */ VARIANT_BOOL newVal);


void __RPC_STUB IGPMGPOLink_put_Enabled_Stub(
    IRpcStubBuffer *This,
    IRpcChannelBuffer *_pRpcChannelBuffer,
    PRPC_MESSAGE _pRpcMessage,
    DWORD *_pdwStubPhase);


/* [helpstring][id][propget] */ HRESULT STDMETHODCALLTYPE IGPMGPOLink_get_Enforced_Proxy( 
    IGPMGPOLink * This,
    /* [retval][out] */ VARIANT_BOOL *pVal);


void __RPC_STUB IGPMGPOLink_get_Enforced_Stub(
    IRpcStubBuffer *This,
    IRpcChannelBuffer *_pRpcChannelBuffer,
    PRPC_MESSAGE _pRpcMessage,
    DWORD *_pdwStubPhase);


/* [helpstring][id][propput] */ HRESULT STDMETHODCALLTYPE IGPMGPOLink_put_Enforced_Proxy( 
    IGPMGPOLink * This,
    /* [in] */ VARIANT_BOOL newVal);


void __RPC_STUB IGPMGPOLink_put_Enforced_Stub(
    IRpcStubBuffer *This,
    IRpcChannelBuffer *_pRpcChannelBuffer,
    PRPC_MESSAGE _pRpcMessage,
    DWORD *_pdwStubPhase);


/* [helpstring][id][propget] */ HRESULT STDMETHODCALLTYPE IGPMGPOLink_get_SOMLinkOrder_Proxy( 
    IGPMGPOLink * This,
    /* [retval][out] */ long *lVal);


void __RPC_STUB IGPMGPOLink_get_SOMLinkOrder_Stub(
    IRpcStubBuffer *This,
    IRpcChannelBuffer *_pRpcChannelBuffer,
    PRPC_MESSAGE _pRpcMessage,
    DWORD *_pdwStubPhase);


/* [helpstring][id][propget] */ HRESULT STDMETHODCALLTYPE IGPMGPOLink_get_SOM_Proxy( 
    IGPMGPOLink * This,
    /* [retval][out] */ IGPMSOM **ppIGPMSOM);


void __RPC_STUB IGPMGPOLink_get_SOM_Stub(
    IRpcStubBuffer *This,
    IRpcChannelBuffer *_pRpcChannelBuffer,
    PRPC_MESSAGE _pRpcMessage,
    DWORD *_pdwStubPhase);


/* [helpstring][id] */ HRESULT STDMETHODCALLTYPE IGPMGPOLink_Delete_Proxy( 
    IGPMGPOLink * This);


void __RPC_STUB IGPMGPOLink_Delete_Stub(
    IRpcStubBuffer *This,
    IRpcChannelBuffer *_pRpcChannelBuffer,
    PRPC_MESSAGE _pRpcMessage,
    DWORD *_pdwStubPhase);



#endif 	/* __IGPMGPOLink_INTERFACE_DEFINED__ */


#ifndef __IGPMGPOLinksCollection_INTERFACE_DEFINED__
#define __IGPMGPOLinksCollection_INTERFACE_DEFINED__

/* interface IGPMGPOLinksCollection */
/* [unique][helpstring][dual][uuid][object] */ 


EXTERN_C const IID IID_IGPMGPOLinksCollection;

#if defined(__cplusplus) && !defined(CINTERFACE)
    
    MIDL_INTERFACE("189D7B68-16BD-4D0D-A2EC-2E6AA2288C7F")
    IGPMGPOLinksCollection : public IDispatch
    {
    public:
        virtual /* [helpstring][id][propget] */ HRESULT STDMETHODCALLTYPE get_Count( 
            /* [retval][out] */ long *pVal) = 0;
        
        virtual /* [helpstring][id][propget] */ HRESULT STDMETHODCALLTYPE get_Item( 
            /* [in] */ long lIndex,
            /* [retval][out] */ VARIANT *pVal) = 0;
        
        virtual /* [helpstring][id][propget] */ HRESULT STDMETHODCALLTYPE get__NewEnum( 
            /* [retval][out] */ IEnumVARIANT **ppIGPMLinks) = 0;
        
    };
    
#else 	/* C style interface */

    typedef struct IGPMGPOLinksCollectionVtbl
    {
        BEGIN_INTERFACE
        
        HRESULT ( STDMETHODCALLTYPE *QueryInterface )( 
            IGPMGPOLinksCollection * This,
            /* [in] */ REFIID riid,
            /* [iid_is][out] */ void **ppvObject);
        
        ULONG ( STDMETHODCALLTYPE *AddRef )( 
            IGPMGPOLinksCollection * This);
        
        ULONG ( STDMETHODCALLTYPE *Release )( 
            IGPMGPOLinksCollection * This);
        
        HRESULT ( STDMETHODCALLTYPE *GetTypeInfoCount )( 
            IGPMGPOLinksCollection * This,
            /* [out] */ UINT *pctinfo);
        
        HRESULT ( STDMETHODCALLTYPE *GetTypeInfo )( 
            IGPMGPOLinksCollection * This,
            /* [in] */ UINT iTInfo,
            /* [in] */ LCID lcid,
            /* [out] */ ITypeInfo **ppTInfo);
        
        HRESULT ( STDMETHODCALLTYPE *GetIDsOfNames )( 
            IGPMGPOLinksCollection * This,
            /* [in] */ REFIID riid,
            /* [size_is][in] */ LPOLESTR *rgszNames,
            /* [in] */ UINT cNames,
            /* [in] */ LCID lcid,
            /* [size_is][out] */ DISPID *rgDispId);
        
        /* [local] */ HRESULT ( STDMETHODCALLTYPE *Invoke )( 
            IGPMGPOLinksCollection * This,
            /* [in] */ DISPID dispIdMember,
            /* [in] */ REFIID riid,
            /* [in] */ LCID lcid,
            /* [in] */ WORD wFlags,
            /* [out][in] */ DISPPARAMS *pDispParams,
            /* [out] */ VARIANT *pVarResult,
            /* [out] */ EXCEPINFO *pExcepInfo,
            /* [out] */ UINT *puArgErr);
        
        /* [helpstring][id][propget] */ HRESULT ( STDMETHODCALLTYPE *get_Count )( 
            IGPMGPOLinksCollection * This,
            /* [retval][out] */ long *pVal);
        
        /* [helpstring][id][propget] */ HRESULT ( STDMETHODCALLTYPE *get_Item )( 
            IGPMGPOLinksCollection * This,
            /* [in] */ long lIndex,
            /* [retval][out] */ VARIANT *pVal);
        
        /* [helpstring][id][propget] */ HRESULT ( STDMETHODCALLTYPE *get__NewEnum )( 
            IGPMGPOLinksCollection * This,
            /* [retval][out] */ IEnumVARIANT **ppIGPMLinks);
        
        END_INTERFACE
    } IGPMGPOLinksCollectionVtbl;

    interface IGPMGPOLinksCollection
    {
        CONST_VTBL struct IGPMGPOLinksCollectionVtbl *lpVtbl;
    };

    

#ifdef COBJMACROS


#define IGPMGPOLinksCollection_QueryInterface(This,riid,ppvObject)	\
    (This)->lpVtbl -> QueryInterface(This,riid,ppvObject)

#define IGPMGPOLinksCollection_AddRef(This)	\
    (This)->lpVtbl -> AddRef(This)

#define IGPMGPOLinksCollection_Release(This)	\
    (This)->lpVtbl -> Release(This)


#define IGPMGPOLinksCollection_GetTypeInfoCount(This,pctinfo)	\
    (This)->lpVtbl -> GetTypeInfoCount(This,pctinfo)

#define IGPMGPOLinksCollection_GetTypeInfo(This,iTInfo,lcid,ppTInfo)	\
    (This)->lpVtbl -> GetTypeInfo(This,iTInfo,lcid,ppTInfo)

#define IGPMGPOLinksCollection_GetIDsOfNames(This,riid,rgszNames,cNames,lcid,rgDispId)	\
    (This)->lpVtbl -> GetIDsOfNames(This,riid,rgszNames,cNames,lcid,rgDispId)

#define IGPMGPOLinksCollection_Invoke(This,dispIdMember,riid,lcid,wFlags,pDispParams,pVarResult,pExcepInfo,puArgErr)	\
    (This)->lpVtbl -> Invoke(This,dispIdMember,riid,lcid,wFlags,pDispParams,pVarResult,pExcepInfo,puArgErr)


#define IGPMGPOLinksCollection_get_Count(This,pVal)	\
    (This)->lpVtbl -> get_Count(This,pVal)

#define IGPMGPOLinksCollection_get_Item(This,lIndex,pVal)	\
    (This)->lpVtbl -> get_Item(This,lIndex,pVal)

#define IGPMGPOLinksCollection_get__NewEnum(This,ppIGPMLinks)	\
    (This)->lpVtbl -> get__NewEnum(This,ppIGPMLinks)

#endif /* COBJMACROS */


#endif 	/* C style interface */



/* [helpstring][id][propget] */ HRESULT STDMETHODCALLTYPE IGPMGPOLinksCollection_get_Count_Proxy( 
    IGPMGPOLinksCollection * This,
    /* [retval][out] */ long *pVal);


void __RPC_STUB IGPMGPOLinksCollection_get_Count_Stub(
    IRpcStubBuffer *This,
    IRpcChannelBuffer *_pRpcChannelBuffer,
    PRPC_MESSAGE _pRpcMessage,
    DWORD *_pdwStubPhase);


/* [helpstring][id][propget] */ HRESULT STDMETHODCALLTYPE IGPMGPOLinksCollection_get_Item_Proxy( 
    IGPMGPOLinksCollection * This,
    /* [in] */ long lIndex,
    /* [retval][out] */ VARIANT *pVal);


void __RPC_STUB IGPMGPOLinksCollection_get_Item_Stub(
    IRpcStubBuffer *This,
    IRpcChannelBuffer *_pRpcChannelBuffer,
    PRPC_MESSAGE _pRpcMessage,
    DWORD *_pdwStubPhase);


/* [helpstring][id][propget] */ HRESULT STDMETHODCALLTYPE IGPMGPOLinksCollection_get__NewEnum_Proxy( 
    IGPMGPOLinksCollection * This,
    /* [retval][out] */ IEnumVARIANT **ppIGPMLinks);


void __RPC_STUB IGPMGPOLinksCollection_get__NewEnum_Stub(
    IRpcStubBuffer *This,
    IRpcChannelBuffer *_pRpcChannelBuffer,
    PRPC_MESSAGE _pRpcMessage,
    DWORD *_pdwStubPhase);



#endif 	/* __IGPMGPOLinksCollection_INTERFACE_DEFINED__ */


#ifndef __IGPMCSECollection_INTERFACE_DEFINED__
#define __IGPMCSECollection_INTERFACE_DEFINED__

/* interface IGPMCSECollection */
/* [unique][helpstring][dual][uuid][object] */ 


EXTERN_C const IID IID_IGPMCSECollection;

#if defined(__cplusplus) && !defined(CINTERFACE)
    
    MIDL_INTERFACE("2E52A97D-0A4A-4A6F-85DB-201622455DA0")
    IGPMCSECollection : public IDispatch
    {
    public:
        virtual /* [helpstring][id][propget] */ HRESULT STDMETHODCALLTYPE get_Count( 
            /* [retval][out] */ long *pVal) = 0;
        
        virtual /* [helpstring][id][propget] */ HRESULT STDMETHODCALLTYPE get_Item( 
            /* [in] */ long lIndex,
            /* [retval][out] */ VARIANT *pVal) = 0;
        
        virtual /* [helpstring][id][propget] */ HRESULT STDMETHODCALLTYPE get__NewEnum( 
            /* [retval][out] */ IEnumVARIANT **ppIGPMCSEs) = 0;
        
    };
    
#else 	/* C style interface */

    typedef struct IGPMCSECollectionVtbl
    {
        BEGIN_INTERFACE
        
        HRESULT ( STDMETHODCALLTYPE *QueryInterface )( 
            IGPMCSECollection * This,
            /* [in] */ REFIID riid,
            /* [iid_is][out] */ void **ppvObject);
        
        ULONG ( STDMETHODCALLTYPE *AddRef )( 
            IGPMCSECollection * This);
        
        ULONG ( STDMETHODCALLTYPE *Release )( 
            IGPMCSECollection * This);
        
        HRESULT ( STDMETHODCALLTYPE *GetTypeInfoCount )( 
            IGPMCSECollection * This,
            /* [out] */ UINT *pctinfo);
        
        HRESULT ( STDMETHODCALLTYPE *GetTypeInfo )( 
            IGPMCSECollection * This,
            /* [in] */ UINT iTInfo,
            /* [in] */ LCID lcid,
            /* [out] */ ITypeInfo **ppTInfo);
        
        HRESULT ( STDMETHODCALLTYPE *GetIDsOfNames )( 
            IGPMCSECollection * This,
            /* [in] */ REFIID riid,
            /* [size_is][in] */ LPOLESTR *rgszNames,
            /* [in] */ UINT cNames,
            /* [in] */ LCID lcid,
            /* [size_is][out] */ DISPID *rgDispId);
        
        /* [local] */ HRESULT ( STDMETHODCALLTYPE *Invoke )( 
            IGPMCSECollection * This,
            /* [in] */ DISPID dispIdMember,
            /* [in] */ REFIID riid,
            /* [in] */ LCID lcid,
            /* [in] */ WORD wFlags,
            /* [out][in] */ DISPPARAMS *pDispParams,
            /* [out] */ VARIANT *pVarResult,
            /* [out] */ EXCEPINFO *pExcepInfo,
            /* [out] */ UINT *puArgErr);
        
        /* [helpstring][id][propget] */ HRESULT ( STDMETHODCALLTYPE *get_Count )( 
            IGPMCSECollection * This,
            /* [retval][out] */ long *pVal);
        
        /* [helpstring][id][propget] */ HRESULT ( STDMETHODCALLTYPE *get_Item )( 
            IGPMCSECollection * This,
            /* [in] */ long lIndex,
            /* [retval][out] */ VARIANT *pVal);
        
        /* [helpstring][id][propget] */ HRESULT ( STDMETHODCALLTYPE *get__NewEnum )( 
            IGPMCSECollection * This,
            /* [retval][out] */ IEnumVARIANT **ppIGPMCSEs);
        
        END_INTERFACE
    } IGPMCSECollectionVtbl;

    interface IGPMCSECollection
    {
        CONST_VTBL struct IGPMCSECollectionVtbl *lpVtbl;
    };

    

#ifdef COBJMACROS


#define IGPMCSECollection_QueryInterface(This,riid,ppvObject)	\
    (This)->lpVtbl -> QueryInterface(This,riid,ppvObject)

#define IGPMCSECollection_AddRef(This)	\
    (This)->lpVtbl -> AddRef(This)

#define IGPMCSECollection_Release(This)	\
    (This)->lpVtbl -> Release(This)


#define IGPMCSECollection_GetTypeInfoCount(This,pctinfo)	\
    (This)->lpVtbl -> GetTypeInfoCount(This,pctinfo)

#define IGPMCSECollection_GetTypeInfo(This,iTInfo,lcid,ppTInfo)	\
    (This)->lpVtbl -> GetTypeInfo(This,iTInfo,lcid,ppTInfo)

#define IGPMCSECollection_GetIDsOfNames(This,riid,rgszNames,cNames,lcid,rgDispId)	\
    (This)->lpVtbl -> GetIDsOfNames(This,riid,rgszNames,cNames,lcid,rgDispId)

#define IGPMCSECollection_Invoke(This,dispIdMember,riid,lcid,wFlags,pDispParams,pVarResult,pExcepInfo,puArgErr)	\
    (This)->lpVtbl -> Invoke(This,dispIdMember,riid,lcid,wFlags,pDispParams,pVarResult,pExcepInfo,puArgErr)


#define IGPMCSECollection_get_Count(This,pVal)	\
    (This)->lpVtbl -> get_Count(This,pVal)

#define IGPMCSECollection_get_Item(This,lIndex,pVal)	\
    (This)->lpVtbl -> get_Item(This,lIndex,pVal)

#define IGPMCSECollection_get__NewEnum(This,ppIGPMCSEs)	\
    (This)->lpVtbl -> get__NewEnum(This,ppIGPMCSEs)

#endif /* COBJMACROS */


#endif 	/* C style interface */



/* [helpstring][id][propget] */ HRESULT STDMETHODCALLTYPE IGPMCSECollection_get_Count_Proxy( 
    IGPMCSECollection * This,
    /* [retval][out] */ long *pVal);


void __RPC_STUB IGPMCSECollection_get_Count_Stub(
    IRpcStubBuffer *This,
    IRpcChannelBuffer *_pRpcChannelBuffer,
    PRPC_MESSAGE _pRpcMessage,
    DWORD *_pdwStubPhase);


/* [helpstring][id][propget] */ HRESULT STDMETHODCALLTYPE IGPMCSECollection_get_Item_Proxy( 
    IGPMCSECollection * This,
    /* [in] */ long lIndex,
    /* [retval][out] */ VARIANT *pVal);


void __RPC_STUB IGPMCSECollection_get_Item_Stub(
    IRpcStubBuffer *This,
    IRpcChannelBuffer *_pRpcChannelBuffer,
    PRPC_MESSAGE _pRpcMessage,
    DWORD *_pdwStubPhase);


/* [helpstring][id][propget] */ HRESULT STDMETHODCALLTYPE IGPMCSECollection_get__NewEnum_Proxy( 
    IGPMCSECollection * This,
    /* [retval][out] */ IEnumVARIANT **ppIGPMCSEs);


void __RPC_STUB IGPMCSECollection_get__NewEnum_Stub(
    IRpcStubBuffer *This,
    IRpcChannelBuffer *_pRpcChannelBuffer,
    PRPC_MESSAGE _pRpcMessage,
    DWORD *_pdwStubPhase);



#endif 	/* __IGPMCSECollection_INTERFACE_DEFINED__ */


#ifndef __IGPMClientSideExtension_INTERFACE_DEFINED__
#define __IGPMClientSideExtension_INTERFACE_DEFINED__

/* interface IGPMClientSideExtension */
/* [unique][helpstring][dual][uuid][object] */ 


EXTERN_C const IID IID_IGPMClientSideExtension;

#if defined(__cplusplus) && !defined(CINTERFACE)
    
    MIDL_INTERFACE("69DA7488-B8DB-415E-9266-901BE4D49928")
    IGPMClientSideExtension : public IDispatch
    {
    public:
        virtual /* [helpstring][id][propget] */ HRESULT STDMETHODCALLTYPE get_ID( 
            /* [retval][out] */ BSTR *pVal) = 0;
        
        virtual /* [helpstring][id][propget] */ HRESULT STDMETHODCALLTYPE get_DisplayName( 
            /* [retval][out] */ BSTR *pVal) = 0;
        
        virtual /* [helpstring][id] */ HRESULT STDMETHODCALLTYPE IsUserEnabled( 
            /* [retval][out] */ VARIANT_BOOL *pvbEnabled) = 0;
        
        virtual /* [helpstring][id] */ HRESULT STDMETHODCALLTYPE IsComputerEnabled( 
            /* [retval][out] */ VARIANT_BOOL *pvbEnabled) = 0;
        
    };
    
#else 	/* C style interface */

    typedef struct IGPMClientSideExtensionVtbl
    {
        BEGIN_INTERFACE
        
        HRESULT ( STDMETHODCALLTYPE *QueryInterface )( 
            IGPMClientSideExtension * This,
            /* [in] */ REFIID riid,
            /* [iid_is][out] */ void **ppvObject);
        
        ULONG ( STDMETHODCALLTYPE *AddRef )( 
            IGPMClientSideExtension * This);
        
        ULONG ( STDMETHODCALLTYPE *Release )( 
            IGPMClientSideExtension * This);
        
        HRESULT ( STDMETHODCALLTYPE *GetTypeInfoCount )( 
            IGPMClientSideExtension * This,
            /* [out] */ UINT *pctinfo);
        
        HRESULT ( STDMETHODCALLTYPE *GetTypeInfo )( 
            IGPMClientSideExtension * This,
            /* [in] */ UINT iTInfo,
            /* [in] */ LCID lcid,
            /* [out] */ ITypeInfo **ppTInfo);
        
        HRESULT ( STDMETHODCALLTYPE *GetIDsOfNames )( 
            IGPMClientSideExtension * This,
            /* [in] */ REFIID riid,
            /* [size_is][in] */ LPOLESTR *rgszNames,
            /* [in] */ UINT cNames,
            /* [in] */ LCID lcid,
            /* [size_is][out] */ DISPID *rgDispId);
        
        /* [local] */ HRESULT ( STDMETHODCALLTYPE *Invoke )( 
            IGPMClientSideExtension * This,
            /* [in] */ DISPID dispIdMember,
            /* [in] */ REFIID riid,
            /* [in] */ LCID lcid,
            /* [in] */ WORD wFlags,
            /* [out][in] */ DISPPARAMS *pDispParams,
            /* [out] */ VARIANT *pVarResult,
            /* [out] */ EXCEPINFO *pExcepInfo,
            /* [out] */ UINT *puArgErr);
        
        /* [helpstring][id][propget] */ HRESULT ( STDMETHODCALLTYPE *get_ID )( 
            IGPMClientSideExtension * This,
            /* [retval][out] */ BSTR *pVal);
        
        /* [helpstring][id][propget] */ HRESULT ( STDMETHODCALLTYPE *get_DisplayName )( 
            IGPMClientSideExtension * This,
            /* [retval][out] */ BSTR *pVal);
        
        /* [helpstring][id] */ HRESULT ( STDMETHODCALLTYPE *IsUserEnabled )( 
            IGPMClientSideExtension * This,
            /* [retval][out] */ VARIANT_BOOL *pvbEnabled);
        
        /* [helpstring][id] */ HRESULT ( STDMETHODCALLTYPE *IsComputerEnabled )( 
            IGPMClientSideExtension * This,
            /* [retval][out] */ VARIANT_BOOL *pvbEnabled);
        
        END_INTERFACE
    } IGPMClientSideExtensionVtbl;

    interface IGPMClientSideExtension
    {
        CONST_VTBL struct IGPMClientSideExtensionVtbl *lpVtbl;
    };

    

#ifdef COBJMACROS


#define IGPMClientSideExtension_QueryInterface(This,riid,ppvObject)	\
    (This)->lpVtbl -> QueryInterface(This,riid,ppvObject)

#define IGPMClientSideExtension_AddRef(This)	\
    (This)->lpVtbl -> AddRef(This)

#define IGPMClientSideExtension_Release(This)	\
    (This)->lpVtbl -> Release(This)


#define IGPMClientSideExtension_GetTypeInfoCount(This,pctinfo)	\
    (This)->lpVtbl -> GetTypeInfoCount(This,pctinfo)

#define IGPMClientSideExtension_GetTypeInfo(This,iTInfo,lcid,ppTInfo)	\
    (This)->lpVtbl -> GetTypeInfo(This,iTInfo,lcid,ppTInfo)

#define IGPMClientSideExtension_GetIDsOfNames(This,riid,rgszNames,cNames,lcid,rgDispId)	\
    (This)->lpVtbl -> GetIDsOfNames(This,riid,rgszNames,cNames,lcid,rgDispId)

#define IGPMClientSideExtension_Invoke(This,dispIdMember,riid,lcid,wFlags,pDispParams,pVarResult,pExcepInfo,puArgErr)	\
    (This)->lpVtbl -> Invoke(This,dispIdMember,riid,lcid,wFlags,pDispParams,pVarResult,pExcepInfo,puArgErr)


#define IGPMClientSideExtension_get_ID(This,pVal)	\
    (This)->lpVtbl -> get_ID(This,pVal)

#define IGPMClientSideExtension_get_DisplayName(This,pVal)	\
    (This)->lpVtbl -> get_DisplayName(This,pVal)

#define IGPMClientSideExtension_IsUserEnabled(This,pvbEnabled)	\
    (This)->lpVtbl -> IsUserEnabled(This,pvbEnabled)

#define IGPMClientSideExtension_IsComputerEnabled(This,pvbEnabled)	\
    (This)->lpVtbl -> IsComputerEnabled(This,pvbEnabled)

#endif /* COBJMACROS */


#endif 	/* C style interface */



/* [helpstring][id][propget] */ HRESULT STDMETHODCALLTYPE IGPMClientSideExtension_get_ID_Proxy( 
    IGPMClientSideExtension * This,
    /* [retval][out] */ BSTR *pVal);


void __RPC_STUB IGPMClientSideExtension_get_ID_Stub(
    IRpcStubBuffer *This,
    IRpcChannelBuffer *_pRpcChannelBuffer,
    PRPC_MESSAGE _pRpcMessage,
    DWORD *_pdwStubPhase);


/* [helpstring][id][propget] */ HRESULT STDMETHODCALLTYPE IGPMClientSideExtension_get_DisplayName_Proxy( 
    IGPMClientSideExtension * This,
    /* [retval][out] */ BSTR *pVal);


void __RPC_STUB IGPMClientSideExtension_get_DisplayName_Stub(
    IRpcStubBuffer *This,
    IRpcChannelBuffer *_pRpcChannelBuffer,
    PRPC_MESSAGE _pRpcMessage,
    DWORD *_pdwStubPhase);


/* [helpstring][id] */ HRESULT STDMETHODCALLTYPE IGPMClientSideExtension_IsUserEnabled_Proxy( 
    IGPMClientSideExtension * This,
    /* [retval][out] */ VARIANT_BOOL *pvbEnabled);


void __RPC_STUB IGPMClientSideExtension_IsUserEnabled_Stub(
    IRpcStubBuffer *This,
    IRpcChannelBuffer *_pRpcChannelBuffer,
    PRPC_MESSAGE _pRpcMessage,
    DWORD *_pdwStubPhase);


/* [helpstring][id] */ HRESULT STDMETHODCALLTYPE IGPMClientSideExtension_IsComputerEnabled_Proxy( 
    IGPMClientSideExtension * This,
    /* [retval][out] */ VARIANT_BOOL *pvbEnabled);


void __RPC_STUB IGPMClientSideExtension_IsComputerEnabled_Stub(
    IRpcStubBuffer *This,
    IRpcChannelBuffer *_pRpcChannelBuffer,
    PRPC_MESSAGE _pRpcMessage,
    DWORD *_pdwStubPhase);



#endif 	/* __IGPMClientSideExtension_INTERFACE_DEFINED__ */


#ifndef __IGPMAsyncCancel_INTERFACE_DEFINED__
#define __IGPMAsyncCancel_INTERFACE_DEFINED__

/* interface IGPMAsyncCancel */
/* [unique][helpstring][dual][uuid][object] */ 


EXTERN_C const IID IID_IGPMAsyncCancel;

#if defined(__cplusplus) && !defined(CINTERFACE)
    
    MIDL_INTERFACE("DDC67754-BE67-4541-8166-F48166868C9C")
    IGPMAsyncCancel : public IDispatch
    {
    public:
        virtual /* [helpstring][id] */ HRESULT STDMETHODCALLTYPE Cancel( void) = 0;
        
    };
    
#else 	/* C style interface */

    typedef struct IGPMAsyncCancelVtbl
    {
        BEGIN_INTERFACE
        
        HRESULT ( STDMETHODCALLTYPE *QueryInterface )( 
            IGPMAsyncCancel * This,
            /* [in] */ REFIID riid,
            /* [iid_is][out] */ void **ppvObject);
        
        ULONG ( STDMETHODCALLTYPE *AddRef )( 
            IGPMAsyncCancel * This);
        
        ULONG ( STDMETHODCALLTYPE *Release )( 
            IGPMAsyncCancel * This);
        
        HRESULT ( STDMETHODCALLTYPE *GetTypeInfoCount )( 
            IGPMAsyncCancel * This,
            /* [out] */ UINT *pctinfo);
        
        HRESULT ( STDMETHODCALLTYPE *GetTypeInfo )( 
            IGPMAsyncCancel * This,
            /* [in] */ UINT iTInfo,
            /* [in] */ LCID lcid,
            /* [out] */ ITypeInfo **ppTInfo);
        
        HRESULT ( STDMETHODCALLTYPE *GetIDsOfNames )( 
            IGPMAsyncCancel * This,
            /* [in] */ REFIID riid,
            /* [size_is][in] */ LPOLESTR *rgszNames,
            /* [in] */ UINT cNames,
            /* [in] */ LCID lcid,
            /* [size_is][out] */ DISPID *rgDispId);
        
        /* [local] */ HRESULT ( STDMETHODCALLTYPE *Invoke )( 
            IGPMAsyncCancel * This,
            /* [in] */ DISPID dispIdMember,
            /* [in] */ REFIID riid,
            /* [in] */ LCID lcid,
            /* [in] */ WORD wFlags,
            /* [out][in] */ DISPPARAMS *pDispParams,
            /* [out] */ VARIANT *pVarResult,
            /* [out] */ EXCEPINFO *pExcepInfo,
            /* [out] */ UINT *puArgErr);
        
        /* [helpstring][id] */ HRESULT ( STDMETHODCALLTYPE *Cancel )( 
            IGPMAsyncCancel * This);
        
        END_INTERFACE
    } IGPMAsyncCancelVtbl;

    interface IGPMAsyncCancel
    {
        CONST_VTBL struct IGPMAsyncCancelVtbl *lpVtbl;
    };

    

#ifdef COBJMACROS


#define IGPMAsyncCancel_QueryInterface(This,riid,ppvObject)	\
    (This)->lpVtbl -> QueryInterface(This,riid,ppvObject)

#define IGPMAsyncCancel_AddRef(This)	\
    (This)->lpVtbl -> AddRef(This)

#define IGPMAsyncCancel_Release(This)	\
    (This)->lpVtbl -> Release(This)


#define IGPMAsyncCancel_GetTypeInfoCount(This,pctinfo)	\
    (This)->lpVtbl -> GetTypeInfoCount(This,pctinfo)

#define IGPMAsyncCancel_GetTypeInfo(This,iTInfo,lcid,ppTInfo)	\
    (This)->lpVtbl -> GetTypeInfo(This,iTInfo,lcid,ppTInfo)

#define IGPMAsyncCancel_GetIDsOfNames(This,riid,rgszNames,cNames,lcid,rgDispId)	\
    (This)->lpVtbl -> GetIDsOfNames(This,riid,rgszNames,cNames,lcid,rgDispId)

#define IGPMAsyncCancel_Invoke(This,dispIdMember,riid,lcid,wFlags,pDispParams,pVarResult,pExcepInfo,puArgErr)	\
    (This)->lpVtbl -> Invoke(This,dispIdMember,riid,lcid,wFlags,pDispParams,pVarResult,pExcepInfo,puArgErr)


#define IGPMAsyncCancel_Cancel(This)	\
    (This)->lpVtbl -> Cancel(This)

#endif /* COBJMACROS */


#endif 	/* C style interface */



/* [helpstring][id] */ HRESULT STDMETHODCALLTYPE IGPMAsyncCancel_Cancel_Proxy( 
    IGPMAsyncCancel * This);


void __RPC_STUB IGPMAsyncCancel_Cancel_Stub(
    IRpcStubBuffer *This,
    IRpcChannelBuffer *_pRpcChannelBuffer,
    PRPC_MESSAGE _pRpcMessage,
    DWORD *_pdwStubPhase);



#endif 	/* __IGPMAsyncCancel_INTERFACE_DEFINED__ */


#ifndef __IGPMAsyncProgress_INTERFACE_DEFINED__
#define __IGPMAsyncProgress_INTERFACE_DEFINED__

/* interface IGPMAsyncProgress */
/* [unique][helpstring][dual][uuid][object] */ 


EXTERN_C const IID IID_IGPMAsyncProgress;

#if defined(__cplusplus) && !defined(CINTERFACE)
    
    MIDL_INTERFACE("6AAC29F8-5948-4324-BF70-423818942DBC")
    IGPMAsyncProgress : public IDispatch
    {
    public:
        virtual /* [helpstring][id] */ HRESULT STDMETHODCALLTYPE Status( 
            /* [in] */ long lProgressNumerator,
            /* [in] */ long lProgressDenominator,
            /* [in] */ HRESULT hrStatus,
            /* [in] */ VARIANT *pResult,
            /* [in] */ IGPMStatusMsgCollection *ppIGPMStatusMsgCollection) = 0;
        
    };
    
#else 	/* C style interface */

    typedef struct IGPMAsyncProgressVtbl
    {
        BEGIN_INTERFACE
        
        HRESULT ( STDMETHODCALLTYPE *QueryInterface )( 
            IGPMAsyncProgress * This,
            /* [in] */ REFIID riid,
            /* [iid_is][out] */ void **ppvObject);
        
        ULONG ( STDMETHODCALLTYPE *AddRef )( 
            IGPMAsyncProgress * This);
        
        ULONG ( STDMETHODCALLTYPE *Release )( 
            IGPMAsyncProgress * This);
        
        HRESULT ( STDMETHODCALLTYPE *GetTypeInfoCount )( 
            IGPMAsyncProgress * This,
            /* [out] */ UINT *pctinfo);
        
        HRESULT ( STDMETHODCALLTYPE *GetTypeInfo )( 
            IGPMAsyncProgress * This,
            /* [in] */ UINT iTInfo,
            /* [in] */ LCID lcid,
            /* [out] */ ITypeInfo **ppTInfo);
        
        HRESULT ( STDMETHODCALLTYPE *GetIDsOfNames )( 
            IGPMAsyncProgress * This,
            /* [in] */ REFIID riid,
            /* [size_is][in] */ LPOLESTR *rgszNames,
            /* [in] */ UINT cNames,
            /* [in] */ LCID lcid,
            /* [size_is][out] */ DISPID *rgDispId);
        
        /* [local] */ HRESULT ( STDMETHODCALLTYPE *Invoke )( 
            IGPMAsyncProgress * This,
            /* [in] */ DISPID dispIdMember,
            /* [in] */ REFIID riid,
            /* [in] */ LCID lcid,
            /* [in] */ WORD wFlags,
            /* [out][in] */ DISPPARAMS *pDispParams,
            /* [out] */ VARIANT *pVarResult,
            /* [out] */ EXCEPINFO *pExcepInfo,
            /* [out] */ UINT *puArgErr);
        
        /* [helpstring][id] */ HRESULT ( STDMETHODCALLTYPE *Status )( 
            IGPMAsyncProgress * This,
            /* [in] */ long lProgressNumerator,
            /* [in] */ long lProgressDenominator,
            /* [in] */ HRESULT hrStatus,
            /* [in] */ VARIANT *pResult,
            /* [in] */ IGPMStatusMsgCollection *ppIGPMStatusMsgCollection);
        
        END_INTERFACE
    } IGPMAsyncProgressVtbl;

    interface IGPMAsyncProgress
    {
        CONST_VTBL struct IGPMAsyncProgressVtbl *lpVtbl;
    };

    

#ifdef COBJMACROS


#define IGPMAsyncProgress_QueryInterface(This,riid,ppvObject)	\
    (This)->lpVtbl -> QueryInterface(This,riid,ppvObject)

#define IGPMAsyncProgress_AddRef(This)	\
    (This)->lpVtbl -> AddRef(This)

#define IGPMAsyncProgress_Release(This)	\
    (This)->lpVtbl -> Release(This)


#define IGPMAsyncProgress_GetTypeInfoCount(This,pctinfo)	\
    (This)->lpVtbl -> GetTypeInfoCount(This,pctinfo)

#define IGPMAsyncProgress_GetTypeInfo(This,iTInfo,lcid,ppTInfo)	\
    (This)->lpVtbl -> GetTypeInfo(This,iTInfo,lcid,ppTInfo)

#define IGPMAsyncProgress_GetIDsOfNames(This,riid,rgszNames,cNames,lcid,rgDispId)	\
    (This)->lpVtbl -> GetIDsOfNames(This,riid,rgszNames,cNames,lcid,rgDispId)

#define IGPMAsyncProgress_Invoke(This,dispIdMember,riid,lcid,wFlags,pDispParams,pVarResult,pExcepInfo,puArgErr)	\
    (This)->lpVtbl -> Invoke(This,dispIdMember,riid,lcid,wFlags,pDispParams,pVarResult,pExcepInfo,puArgErr)


#define IGPMAsyncProgress_Status(This,lProgressNumerator,lProgressDenominator,hrStatus,pResult,ppIGPMStatusMsgCollection)	\
    (This)->lpVtbl -> Status(This,lProgressNumerator,lProgressDenominator,hrStatus,pResult,ppIGPMStatusMsgCollection)

#endif /* COBJMACROS */


#endif 	/* C style interface */



/* [helpstring][id] */ HRESULT STDMETHODCALLTYPE IGPMAsyncProgress_Status_Proxy( 
    IGPMAsyncProgress * This,
    /* [in] */ long lProgressNumerator,
    /* [in] */ long lProgressDenominator,
    /* [in] */ HRESULT hrStatus,
    /* [in] */ VARIANT *pResult,
    /* [in] */ IGPMStatusMsgCollection *ppIGPMStatusMsgCollection);


void __RPC_STUB IGPMAsyncProgress_Status_Stub(
    IRpcStubBuffer *This,
    IRpcChannelBuffer *_pRpcChannelBuffer,
    PRPC_MESSAGE _pRpcMessage,
    DWORD *_pdwStubPhase);



#endif 	/* __IGPMAsyncProgress_INTERFACE_DEFINED__ */


#ifndef __IGPMStatusMsgCollection_INTERFACE_DEFINED__
#define __IGPMStatusMsgCollection_INTERFACE_DEFINED__

/* interface IGPMStatusMsgCollection */
/* [unique][helpstring][dual][uuid][object] */ 


EXTERN_C const IID IID_IGPMStatusMsgCollection;

#if defined(__cplusplus) && !defined(CINTERFACE)
    
    MIDL_INTERFACE("9B6E1AF0-1A92-40F3-A59D-F36AC1F728B7")
    IGPMStatusMsgCollection : public IDispatch
    {
    public:
        virtual /* [helpstring][id][propget] */ HRESULT STDMETHODCALLTYPE get_Count( 
            /* [retval][out] */ long *pVal) = 0;
        
        virtual /* [helpstring][id][propget] */ HRESULT STDMETHODCALLTYPE get_Item( 
            /* [in] */ long lIndex,
            /* [retval][out] */ VARIANT *pVal) = 0;
        
        virtual /* [helpstring][id][propget] */ HRESULT STDMETHODCALLTYPE get__NewEnum( 
            /* [retval][out] */ IEnumVARIANT **pVal) = 0;
        
    };
    
#else 	/* C style interface */

    typedef struct IGPMStatusMsgCollectionVtbl
    {
        BEGIN_INTERFACE
        
        HRESULT ( STDMETHODCALLTYPE *QueryInterface )( 
            IGPMStatusMsgCollection * This,
            /* [in] */ REFIID riid,
            /* [iid_is][out] */ void **ppvObject);
        
        ULONG ( STDMETHODCALLTYPE *AddRef )( 
            IGPMStatusMsgCollection * This);
        
        ULONG ( STDMETHODCALLTYPE *Release )( 
            IGPMStatusMsgCollection * This);
        
        HRESULT ( STDMETHODCALLTYPE *GetTypeInfoCount )( 
            IGPMStatusMsgCollection * This,
            /* [out] */ UINT *pctinfo);
        
        HRESULT ( STDMETHODCALLTYPE *GetTypeInfo )( 
            IGPMStatusMsgCollection * This,
            /* [in] */ UINT iTInfo,
            /* [in] */ LCID lcid,
            /* [out] */ ITypeInfo **ppTInfo);
        
        HRESULT ( STDMETHODCALLTYPE *GetIDsOfNames )( 
            IGPMStatusMsgCollection * This,
            /* [in] */ REFIID riid,
            /* [size_is][in] */ LPOLESTR *rgszNames,
            /* [in] */ UINT cNames,
            /* [in] */ LCID lcid,
            /* [size_is][out] */ DISPID *rgDispId);
        
        /* [local] */ HRESULT ( STDMETHODCALLTYPE *Invoke )( 
            IGPMStatusMsgCollection * This,
            /* [in] */ DISPID dispIdMember,
            /* [in] */ REFIID riid,
            /* [in] */ LCID lcid,
            /* [in] */ WORD wFlags,
            /* [out][in] */ DISPPARAMS *pDispParams,
            /* [out] */ VARIANT *pVarResult,
            /* [out] */ EXCEPINFO *pExcepInfo,
            /* [out] */ UINT *puArgErr);
        
        /* [helpstring][id][propget] */ HRESULT ( STDMETHODCALLTYPE *get_Count )( 
            IGPMStatusMsgCollection * This,
            /* [retval][out] */ long *pVal);
        
        /* [helpstring][id][propget] */ HRESULT ( STDMETHODCALLTYPE *get_Item )( 
            IGPMStatusMsgCollection * This,
            /* [in] */ long lIndex,
            /* [retval][out] */ VARIANT *pVal);
        
        /* [helpstring][id][propget] */ HRESULT ( STDMETHODCALLTYPE *get__NewEnum )( 
            IGPMStatusMsgCollection * This,
            /* [retval][out] */ IEnumVARIANT **pVal);
        
        END_INTERFACE
    } IGPMStatusMsgCollectionVtbl;

    interface IGPMStatusMsgCollection
    {
        CONST_VTBL struct IGPMStatusMsgCollectionVtbl *lpVtbl;
    };

    

#ifdef COBJMACROS


#define IGPMStatusMsgCollection_QueryInterface(This,riid,ppvObject)	\
    (This)->lpVtbl -> QueryInterface(This,riid,ppvObject)

#define IGPMStatusMsgCollection_AddRef(This)	\
    (This)->lpVtbl -> AddRef(This)

#define IGPMStatusMsgCollection_Release(This)	\
    (This)->lpVtbl -> Release(This)


#define IGPMStatusMsgCollection_GetTypeInfoCount(This,pctinfo)	\
    (This)->lpVtbl -> GetTypeInfoCount(This,pctinfo)

#define IGPMStatusMsgCollection_GetTypeInfo(This,iTInfo,lcid,ppTInfo)	\
    (This)->lpVtbl -> GetTypeInfo(This,iTInfo,lcid,ppTInfo)

#define IGPMStatusMsgCollection_GetIDsOfNames(This,riid,rgszNames,cNames,lcid,rgDispId)	\
    (This)->lpVtbl -> GetIDsOfNames(This,riid,rgszNames,cNames,lcid,rgDispId)

#define IGPMStatusMsgCollection_Invoke(This,dispIdMember,riid,lcid,wFlags,pDispParams,pVarResult,pExcepInfo,puArgErr)	\
    (This)->lpVtbl -> Invoke(This,dispIdMember,riid,lcid,wFlags,pDispParams,pVarResult,pExcepInfo,puArgErr)


#define IGPMStatusMsgCollection_get_Count(This,pVal)	\
    (This)->lpVtbl -> get_Count(This,pVal)

#define IGPMStatusMsgCollection_get_Item(This,lIndex,pVal)	\
    (This)->lpVtbl -> get_Item(This,lIndex,pVal)

#define IGPMStatusMsgCollection_get__NewEnum(This,pVal)	\
    (This)->lpVtbl -> get__NewEnum(This,pVal)

#endif /* COBJMACROS */


#endif 	/* C style interface */



/* [helpstring][id][propget] */ HRESULT STDMETHODCALLTYPE IGPMStatusMsgCollection_get_Count_Proxy( 
    IGPMStatusMsgCollection * This,
    /* [retval][out] */ long *pVal);


void __RPC_STUB IGPMStatusMsgCollection_get_Count_Stub(
    IRpcStubBuffer *This,
    IRpcChannelBuffer *_pRpcChannelBuffer,
    PRPC_MESSAGE _pRpcMessage,
    DWORD *_pdwStubPhase);


/* [helpstring][id][propget] */ HRESULT STDMETHODCALLTYPE IGPMStatusMsgCollection_get_Item_Proxy( 
    IGPMStatusMsgCollection * This,
    /* [in] */ long lIndex,
    /* [retval][out] */ VARIANT *pVal);


void __RPC_STUB IGPMStatusMsgCollection_get_Item_Stub(
    IRpcStubBuffer *This,
    IRpcChannelBuffer *_pRpcChannelBuffer,
    PRPC_MESSAGE _pRpcMessage,
    DWORD *_pdwStubPhase);


/* [helpstring][id][propget] */ HRESULT STDMETHODCALLTYPE IGPMStatusMsgCollection_get__NewEnum_Proxy( 
    IGPMStatusMsgCollection * This,
    /* [retval][out] */ IEnumVARIANT **pVal);


void __RPC_STUB IGPMStatusMsgCollection_get__NewEnum_Stub(
    IRpcStubBuffer *This,
    IRpcChannelBuffer *_pRpcChannelBuffer,
    PRPC_MESSAGE _pRpcMessage,
    DWORD *_pdwStubPhase);



#endif 	/* __IGPMStatusMsgCollection_INTERFACE_DEFINED__ */


#ifndef __IGPMStatusMessage_INTERFACE_DEFINED__
#define __IGPMStatusMessage_INTERFACE_DEFINED__

/* interface IGPMStatusMessage */
/* [unique][helpstring][dual][uuid][object] */ 


EXTERN_C const IID IID_IGPMStatusMessage;

#if defined(__cplusplus) && !defined(CINTERFACE)
    
    MIDL_INTERFACE("8496C22F-F3DE-4A1F-8F58-603CAAA93D7B")
    IGPMStatusMessage : public IDispatch
    {
    public:
        virtual /* [helpstring][id][propget] */ HRESULT STDMETHODCALLTYPE get_ObjectPath( 
            /* [retval][out] */ BSTR *pVal) = 0;
        
        virtual /* [helpstring][id] */ HRESULT STDMETHODCALLTYPE ErrorCode( void) = 0;
        
        virtual /* [helpstring][id][propget] */ HRESULT STDMETHODCALLTYPE get_ExtensionName( 
            /* [retval][out] */ BSTR *pVal) = 0;
        
        virtual /* [helpstring][id][propget] */ HRESULT STDMETHODCALLTYPE get_SettingsName( 
            /* [retval][out] */ BSTR *pVal) = 0;
        
        virtual /* [helpstring][id] */ HRESULT STDMETHODCALLTYPE OperationCode( void) = 0;
        
        virtual /* [helpstring][id][propget] */ HRESULT STDMETHODCALLTYPE get_Message( 
            /* [retval][out] */ BSTR *pVal) = 0;
        
    };
    
#else 	/* C style interface */

    typedef struct IGPMStatusMessageVtbl
    {
        BEGIN_INTERFACE
        
        HRESULT ( STDMETHODCALLTYPE *QueryInterface )( 
            IGPMStatusMessage * This,
            /* [in] */ REFIID riid,
            /* [iid_is][out] */ void **ppvObject);
        
        ULONG ( STDMETHODCALLTYPE *AddRef )( 
            IGPMStatusMessage * This);
        
        ULONG ( STDMETHODCALLTYPE *Release )( 
            IGPMStatusMessage * This);
        
        HRESULT ( STDMETHODCALLTYPE *GetTypeInfoCount )( 
            IGPMStatusMessage * This,
            /* [out] */ UINT *pctinfo);
        
        HRESULT ( STDMETHODCALLTYPE *GetTypeInfo )( 
            IGPMStatusMessage * This,
            /* [in] */ UINT iTInfo,
            /* [in] */ LCID lcid,
            /* [out] */ ITypeInfo **ppTInfo);
        
        HRESULT ( STDMETHODCALLTYPE *GetIDsOfNames )( 
            IGPMStatusMessage * This,
            /* [in] */ REFIID riid,
            /* [size_is][in] */ LPOLESTR *rgszNames,
            /* [in] */ UINT cNames,
            /* [in] */ LCID lcid,
            /* [size_is][out] */ DISPID *rgDispId);
        
        /* [local] */ HRESULT ( STDMETHODCALLTYPE *Invoke )( 
            IGPMStatusMessage * This,
            /* [in] */ DISPID dispIdMember,
            /* [in] */ REFIID riid,
            /* [in] */ LCID lcid,
            /* [in] */ WORD wFlags,
            /* [out][in] */ DISPPARAMS *pDispParams,
            /* [out] */ VARIANT *pVarResult,
            /* [out] */ EXCEPINFO *pExcepInfo,
            /* [out] */ UINT *puArgErr);
        
        /* [helpstring][id][propget] */ HRESULT ( STDMETHODCALLTYPE *get_ObjectPath )( 
            IGPMStatusMessage * This,
            /* [retval][out] */ BSTR *pVal);
        
        /* [helpstring][id] */ HRESULT ( STDMETHODCALLTYPE *ErrorCode )( 
            IGPMStatusMessage * This);
        
        /* [helpstring][id][propget] */ HRESULT ( STDMETHODCALLTYPE *get_ExtensionName )( 
            IGPMStatusMessage * This,
            /* [retval][out] */ BSTR *pVal);
        
        /* [helpstring][id][propget] */ HRESULT ( STDMETHODCALLTYPE *get_SettingsName )( 
            IGPMStatusMessage * This,
            /* [retval][out] */ BSTR *pVal);
        
        /* [helpstring][id] */ HRESULT ( STDMETHODCALLTYPE *OperationCode )( 
            IGPMStatusMessage * This);
        
        /* [helpstring][id][propget] */ HRESULT ( STDMETHODCALLTYPE *get_Message )( 
            IGPMStatusMessage * This,
            /* [retval][out] */ BSTR *pVal);
        
        END_INTERFACE
    } IGPMStatusMessageVtbl;

    interface IGPMStatusMessage
    {
        CONST_VTBL struct IGPMStatusMessageVtbl *lpVtbl;
    };

    

#ifdef COBJMACROS


#define IGPMStatusMessage_QueryInterface(This,riid,ppvObject)	\
    (This)->lpVtbl -> QueryInterface(This,riid,ppvObject)

#define IGPMStatusMessage_AddRef(This)	\
    (This)->lpVtbl -> AddRef(This)

#define IGPMStatusMessage_Release(This)	\
    (This)->lpVtbl -> Release(This)


#define IGPMStatusMessage_GetTypeInfoCount(This,pctinfo)	\
    (This)->lpVtbl -> GetTypeInfoCount(This,pctinfo)

#define IGPMStatusMessage_GetTypeInfo(This,iTInfo,lcid,ppTInfo)	\
    (This)->lpVtbl -> GetTypeInfo(This,iTInfo,lcid,ppTInfo)

#define IGPMStatusMessage_GetIDsOfNames(This,riid,rgszNames,cNames,lcid,rgDispId)	\
    (This)->lpVtbl -> GetIDsOfNames(This,riid,rgszNames,cNames,lcid,rgDispId)

#define IGPMStatusMessage_Invoke(This,dispIdMember,riid,lcid,wFlags,pDispParams,pVarResult,pExcepInfo,puArgErr)	\
    (This)->lpVtbl -> Invoke(This,dispIdMember,riid,lcid,wFlags,pDispParams,pVarResult,pExcepInfo,puArgErr)


#define IGPMStatusMessage_get_ObjectPath(This,pVal)	\
    (This)->lpVtbl -> get_ObjectPath(This,pVal)

#define IGPMStatusMessage_ErrorCode(This)	\
    (This)->lpVtbl -> ErrorCode(This)

#define IGPMStatusMessage_get_ExtensionName(This,pVal)	\
    (This)->lpVtbl -> get_ExtensionName(This,pVal)

#define IGPMStatusMessage_get_SettingsName(This,pVal)	\
    (This)->lpVtbl -> get_SettingsName(This,pVal)

#define IGPMStatusMessage_OperationCode(This)	\
    (This)->lpVtbl -> OperationCode(This)

#define IGPMStatusMessage_get_Message(This,pVal)	\
    (This)->lpVtbl -> get_Message(This,pVal)

#endif /* COBJMACROS */


#endif 	/* C style interface */



/* [helpstring][id][propget] */ HRESULT STDMETHODCALLTYPE IGPMStatusMessage_get_ObjectPath_Proxy( 
    IGPMStatusMessage * This,
    /* [retval][out] */ BSTR *pVal);


void __RPC_STUB IGPMStatusMessage_get_ObjectPath_Stub(
    IRpcStubBuffer *This,
    IRpcChannelBuffer *_pRpcChannelBuffer,
    PRPC_MESSAGE _pRpcMessage,
    DWORD *_pdwStubPhase);


/* [helpstring][id] */ HRESULT STDMETHODCALLTYPE IGPMStatusMessage_ErrorCode_Proxy( 
    IGPMStatusMessage * This);


void __RPC_STUB IGPMStatusMessage_ErrorCode_Stub(
    IRpcStubBuffer *This,
    IRpcChannelBuffer *_pRpcChannelBuffer,
    PRPC_MESSAGE _pRpcMessage,
    DWORD *_pdwStubPhase);


/* [helpstring][id][propget] */ HRESULT STDMETHODCALLTYPE IGPMStatusMessage_get_ExtensionName_Proxy( 
    IGPMStatusMessage * This,
    /* [retval][out] */ BSTR *pVal);


void __RPC_STUB IGPMStatusMessage_get_ExtensionName_Stub(
    IRpcStubBuffer *This,
    IRpcChannelBuffer *_pRpcChannelBuffer,
    PRPC_MESSAGE _pRpcMessage,
    DWORD *_pdwStubPhase);


/* [helpstring][id][propget] */ HRESULT STDMETHODCALLTYPE IGPMStatusMessage_get_SettingsName_Proxy( 
    IGPMStatusMessage * This,
    /* [retval][out] */ BSTR *pVal);


void __RPC_STUB IGPMStatusMessage_get_SettingsName_Stub(
    IRpcStubBuffer *This,
    IRpcChannelBuffer *_pRpcChannelBuffer,
    PRPC_MESSAGE _pRpcMessage,
    DWORD *_pdwStubPhase);


/* [helpstring][id] */ HRESULT STDMETHODCALLTYPE IGPMStatusMessage_OperationCode_Proxy( 
    IGPMStatusMessage * This);


void __RPC_STUB IGPMStatusMessage_OperationCode_Stub(
    IRpcStubBuffer *This,
    IRpcChannelBuffer *_pRpcChannelBuffer,
    PRPC_MESSAGE _pRpcMessage,
    DWORD *_pdwStubPhase);


/* [helpstring][id][propget] */ HRESULT STDMETHODCALLTYPE IGPMStatusMessage_get_Message_Proxy( 
    IGPMStatusMessage * This,
    /* [retval][out] */ BSTR *pVal);


void __RPC_STUB IGPMStatusMessage_get_Message_Stub(
    IRpcStubBuffer *This,
    IRpcChannelBuffer *_pRpcChannelBuffer,
    PRPC_MESSAGE _pRpcMessage,
    DWORD *_pdwStubPhase);



#endif 	/* __IGPMStatusMessage_INTERFACE_DEFINED__ */


#ifndef __IGPMConstants_INTERFACE_DEFINED__
#define __IGPMConstants_INTERFACE_DEFINED__

/* interface IGPMConstants */
/* [unique][helpstring][dual][uuid][object] */ 


EXTERN_C const IID IID_IGPMConstants;

#if defined(__cplusplus) && !defined(CINTERFACE)
    
    MIDL_INTERFACE("50EF73E6-D35C-4C8D-BE63-7EA5D2AAC5C4")
    IGPMConstants : public IDispatch
    {
    public:
        virtual /* [helpstring][id][propget] */ HRESULT STDMETHODCALLTYPE get_PermGPOApply( 
            /* [retval][out] */ GPMPermissionType *pVal) = 0;
        
        virtual /* [helpstring][id][propget] */ HRESULT STDMETHODCALLTYPE get_PermGPORead( 
            /* [retval][out] */ GPMPermissionType *pVal) = 0;
        
        virtual /* [helpstring][id][propget] */ HRESULT STDMETHODCALLTYPE get_PermGPOEdit( 
            /* [retval][out] */ GPMPermissionType *pVal) = 0;
        
        virtual /* [helpstring][id][propget] */ HRESULT STDMETHODCALLTYPE get_PermGPOEditSecurityAndDelete( 
            /* [retval][out] */ GPMPermissionType *pVal) = 0;
        
        virtual /* [helpstring][id][propget] */ HRESULT STDMETHODCALLTYPE get_PermGPOCustom( 
            /* [retval][out] */ GPMPermissionType *pVal) = 0;
        
        virtual /* [helpstring][id][propget] */ HRESULT STDMETHODCALLTYPE get_PermWMIFilterEdit( 
            /* [retval][out] */ GPMPermissionType *pVal) = 0;
        
        virtual /* [helpstring][id][propget] */ HRESULT STDMETHODCALLTYPE get_PermWMIFilterFullControl( 
            /* [retval][out] */ GPMPermissionType *pVal) = 0;
        
        virtual /* [helpstring][id][propget] */ HRESULT STDMETHODCALLTYPE get_PermWMIFilterCustom( 
            /* [retval][out] */ GPMPermissionType *pVal) = 0;
        
        virtual /* [helpstring][id][propget] */ HRESULT STDMETHODCALLTYPE get_PermSOMLink( 
            /* [retval][out] */ GPMPermissionType *pVal) = 0;
        
        virtual /* [helpstring][id][propget] */ HRESULT STDMETHODCALLTYPE get_PermSOMLogging( 
            /* [retval][out] */ GPMPermissionType *pVal) = 0;
        
        virtual /* [helpstring][id][propget] */ HRESULT STDMETHODCALLTYPE get_PermSOMPlanning( 
            /* [retval][out] */ GPMPermissionType *pVal) = 0;
        
        virtual /* [helpstring][id][propget] */ HRESULT STDMETHODCALLTYPE get_PermSOMGPOCreate( 
            /* [retval][out] */ GPMPermissionType *pVal) = 0;
        
        virtual /* [helpstring][id][propget] */ HRESULT STDMETHODCALLTYPE get_PermSOMWMICreate( 
            /* [retval][out] */ GPMPermissionType *pVal) = 0;
        
        virtual /* [helpstring][id][propget] */ HRESULT STDMETHODCALLTYPE get_PermSOMWMIFullControl( 
            /* [retval][out] */ GPMPermissionType *pVal) = 0;
        
        virtual /* [helpstring][id][propget] */ HRESULT STDMETHODCALLTYPE get_SearchPropertyGPOPermissions( 
            /* [retval][out] */ GPMSearchProperty *pVal) = 0;
        
        virtual /* [helpstring][id][propget] */ HRESULT STDMETHODCALLTYPE get_SearchPropertyGPOEffectivePermissions( 
            /* [retval][out] */ GPMSearchProperty *pVal) = 0;
        
        virtual /* [helpstring][id][propget] */ HRESULT STDMETHODCALLTYPE get_SearchPropertyGPODisplayName( 
            /* [retval][out] */ GPMSearchProperty *pVal) = 0;
        
        virtual /* [helpstring][id][propget] */ HRESULT STDMETHODCALLTYPE get_SearchPropertyGPOWMIFilter( 
            /* [retval][out] */ GPMSearchProperty *pVal) = 0;
        
        virtual /* [helpstring][id][propget] */ HRESULT STDMETHODCALLTYPE get_SearchPropertyGPOID( 
            /* [retval][out] */ GPMSearchProperty *pVal) = 0;
        
        virtual /* [helpstring][id][propget] */ HRESULT STDMETHODCALLTYPE get_SearchPropertyGPOComputerExtensions( 
            /* [retval][out] */ GPMSearchProperty *pVal) = 0;
        
        virtual /* [helpstring][id][propget] */ HRESULT STDMETHODCALLTYPE get_SearchPropertyGPOUserExtensions( 
            /* [retval][out] */ GPMSearchProperty *pVal) = 0;
        
        virtual /* [helpstring][id][propget] */ HRESULT STDMETHODCALLTYPE get_SearchPropertySOMLinks( 
            /* [retval][out] */ GPMSearchProperty *pVal) = 0;
        
        virtual /* [helpstring][id][propget] */ HRESULT STDMETHODCALLTYPE get_SearchPropertyGPODomain( 
            /* [retval][out] */ GPMSearchProperty *pVal) = 0;
        
        virtual /* [helpstring][id][propget] */ HRESULT STDMETHODCALLTYPE get_SearchPropertyBackupMostRecent( 
            /* [retval][out] */ GPMSearchProperty *pVal) = 0;
        
        virtual /* [helpstring][id][propget] */ HRESULT STDMETHODCALLTYPE get_SearchOpEquals( 
            /* [retval][out] */ GPMSearchOperation *pVal) = 0;
        
        virtual /* [helpstring][id][propget] */ HRESULT STDMETHODCALLTYPE get_SearchOpContains( 
            /* [retval][out] */ GPMSearchOperation *pVal) = 0;
        
        virtual /* [helpstring][id][propget] */ HRESULT STDMETHODCALLTYPE get_SearchOpNotContains( 
            /* [retval][out] */ GPMSearchOperation *pVal) = 0;
        
        virtual /* [helpstring][id][propget] */ HRESULT STDMETHODCALLTYPE get_SearchOpNotEquals( 
            /* [retval][out] */ GPMSearchOperation *pVal) = 0;
        
        virtual /* [helpstring][id][propget] */ HRESULT STDMETHODCALLTYPE get_UsePDC( 
            /* [retval][out] */ ULONG *pVal) = 0;
        
        virtual /* [helpstring][id][propget] */ HRESULT STDMETHODCALLTYPE get_UseAnyDC( 
            /* [retval][out] */ ULONG *pVal) = 0;
        
        virtual /* [helpstring][id][propget] */ HRESULT STDMETHODCALLTYPE get_UseAnyDotNetDC( 
            /* [retval][out] */ ULONG *pVal) = 0;
        
        virtual /* [helpstring][id][propget] */ HRESULT STDMETHODCALLTYPE get_SOMSite( 
            /* [retval][out] */ GPMSOMType *pVal) = 0;
        
        virtual /* [helpstring][id][propget] */ HRESULT STDMETHODCALLTYPE get_SOMDomain( 
            /* [retval][out] */ GPMSOMType *pVal) = 0;
        
        virtual /* [helpstring][id][propget] */ HRESULT STDMETHODCALLTYPE get_SOMOU( 
            /* [retval][out] */ GPMSOMType *pVal) = 0;
        
        virtual /* [helpstring][id][propget] */ HRESULT STDMETHODCALLTYPE get_SecurityFlags( 
            /* [in] */ VARIANT_BOOL vbOwner,
            /* [in] */ VARIANT_BOOL vbGroup,
            /* [in] */ VARIANT_BOOL vbDACL,
            /* [in] */ VARIANT_BOOL vbSACL,
            /* [retval][out] */ ULONG *pVal) = 0;
        
        virtual /* [helpstring][id][propget] */ HRESULT STDMETHODCALLTYPE get_ResolveOptionGroupsBySID( 
            /* [retval][out] */ GPMResolveOption *pVal) = 0;
        
        virtual /* [helpstring][id][propget] */ HRESULT STDMETHODCALLTYPE get_ResolveOptionGroupsByName( 
            /* [retval][out] */ GPMResolveOption *pVal) = 0;
        
        virtual /* [helpstring][id][propget] */ HRESULT STDMETHODCALLTYPE get_ResolveOptionTranslationTableOnly( 
            /* [retval][out] */ GPMResolveOption *pVal) = 0;
        
        virtual /* [helpstring][id][propget] */ HRESULT STDMETHODCALLTYPE get_DoNotValidateDC( 
            /* [retval][out] */ ULONG *pVal) = 0;
        
        virtual /* [helpstring][id][propget] */ HRESULT STDMETHODCALLTYPE get_ReportHTML( 
            /* [retval][out] */ GPMReportType *pVal) = 0;
        
        virtual /* [helpstring][id][propget] */ HRESULT STDMETHODCALLTYPE get_ReportXML( 
            /* [retval][out] */ GPMReportType *pVal) = 0;
        
    };
    
#else 	/* C style interface */

    typedef struct IGPMConstantsVtbl
    {
        BEGIN_INTERFACE
        
        HRESULT ( STDMETHODCALLTYPE *QueryInterface )( 
            IGPMConstants * This,
            /* [in] */ REFIID riid,
            /* [iid_is][out] */ void **ppvObject);
        
        ULONG ( STDMETHODCALLTYPE *AddRef )( 
            IGPMConstants * This);
        
        ULONG ( STDMETHODCALLTYPE *Release )( 
            IGPMConstants * This);
        
        HRESULT ( STDMETHODCALLTYPE *GetTypeInfoCount )( 
            IGPMConstants * This,
            /* [out] */ UINT *pctinfo);
        
        HRESULT ( STDMETHODCALLTYPE *GetTypeInfo )( 
            IGPMConstants * This,
            /* [in] */ UINT iTInfo,
            /* [in] */ LCID lcid,
            /* [out] */ ITypeInfo **ppTInfo);
        
        HRESULT ( STDMETHODCALLTYPE *GetIDsOfNames )( 
            IGPMConstants * This,
            /* [in] */ REFIID riid,
            /* [size_is][in] */ LPOLESTR *rgszNames,
            /* [in] */ UINT cNames,
            /* [in] */ LCID lcid,
            /* [size_is][out] */ DISPID *rgDispId);
        
        /* [local] */ HRESULT ( STDMETHODCALLTYPE *Invoke )( 
            IGPMConstants * This,
            /* [in] */ DISPID dispIdMember,
            /* [in] */ REFIID riid,
            /* [in] */ LCID lcid,
            /* [in] */ WORD wFlags,
            /* [out][in] */ DISPPARAMS *pDispParams,
            /* [out] */ VARIANT *pVarResult,
            /* [out] */ EXCEPINFO *pExcepInfo,
            /* [out] */ UINT *puArgErr);
        
        /* [helpstring][id][propget] */ HRESULT ( STDMETHODCALLTYPE *get_PermGPOApply )( 
            IGPMConstants * This,
            /* [retval][out] */ GPMPermissionType *pVal);
        
        /* [helpstring][id][propget] */ HRESULT ( STDMETHODCALLTYPE *get_PermGPORead )( 
            IGPMConstants * This,
            /* [retval][out] */ GPMPermissionType *pVal);
        
        /* [helpstring][id][propget] */ HRESULT ( STDMETHODCALLTYPE *get_PermGPOEdit )( 
            IGPMConstants * This,
            /* [retval][out] */ GPMPermissionType *pVal);
        
        /* [helpstring][id][propget] */ HRESULT ( STDMETHODCALLTYPE *get_PermGPOEditSecurityAndDelete )( 
            IGPMConstants * This,
            /* [retval][out] */ GPMPermissionType *pVal);
        
        /* [helpstring][id][propget] */ HRESULT ( STDMETHODCALLTYPE *get_PermGPOCustom )( 
            IGPMConstants * This,
            /* [retval][out] */ GPMPermissionType *pVal);
        
        /* [helpstring][id][propget] */ HRESULT ( STDMETHODCALLTYPE *get_PermWMIFilterEdit )( 
            IGPMConstants * This,
            /* [retval][out] */ GPMPermissionType *pVal);
        
        /* [helpstring][id][propget] */ HRESULT ( STDMETHODCALLTYPE *get_PermWMIFilterFullControl )( 
            IGPMConstants * This,
            /* [retval][out] */ GPMPermissionType *pVal);
        
        /* [helpstring][id][propget] */ HRESULT ( STDMETHODCALLTYPE *get_PermWMIFilterCustom )( 
            IGPMConstants * This,
            /* [retval][out] */ GPMPermissionType *pVal);
        
        /* [helpstring][id][propget] */ HRESULT ( STDMETHODCALLTYPE *get_PermSOMLink )( 
            IGPMConstants * This,
            /* [retval][out] */ GPMPermissionType *pVal);
        
        /* [helpstring][id][propget] */ HRESULT ( STDMETHODCALLTYPE *get_PermSOMLogging )( 
            IGPMConstants * This,
            /* [retval][out] */ GPMPermissionType *pVal);
        
        /* [helpstring][id][propget] */ HRESULT ( STDMETHODCALLTYPE *get_PermSOMPlanning )( 
            IGPMConstants * This,
            /* [retval][out] */ GPMPermissionType *pVal);
        
        /* [helpstring][id][propget] */ HRESULT ( STDMETHODCALLTYPE *get_PermSOMGPOCreate )( 
            IGPMConstants * This,
            /* [retval][out] */ GPMPermissionType *pVal);
        
        /* [helpstring][id][propget] */ HRESULT ( STDMETHODCALLTYPE *get_PermSOMWMICreate )( 
            IGPMConstants * This,
            /* [retval][out] */ GPMPermissionType *pVal);
        
        /* [helpstring][id][propget] */ HRESULT ( STDMETHODCALLTYPE *get_PermSOMWMIFullControl )( 
            IGPMConstants * This,
            /* [retval][out] */ GPMPermissionType *pVal);
        
        /* [helpstring][id][propget] */ HRESULT ( STDMETHODCALLTYPE *get_SearchPropertyGPOPermissions )( 
            IGPMConstants * This,
            /* [retval][out] */ GPMSearchProperty *pVal);
        
        /* [helpstring][id][propget] */ HRESULT ( STDMETHODCALLTYPE *get_SearchPropertyGPOEffectivePermissions )( 
            IGPMConstants * This,
            /* [retval][out] */ GPMSearchProperty *pVal);
        
        /* [helpstring][id][propget] */ HRESULT ( STDMETHODCALLTYPE *get_SearchPropertyGPODisplayName )( 
            IGPMConstants * This,
            /* [retval][out] */ GPMSearchProperty *pVal);
        
        /* [helpstring][id][propget] */ HRESULT ( STDMETHODCALLTYPE *get_SearchPropertyGPOWMIFilter )( 
            IGPMConstants * This,
            /* [retval][out] */ GPMSearchProperty *pVal);
        
        /* [helpstring][id][propget] */ HRESULT ( STDMETHODCALLTYPE *get_SearchPropertyGPOID )( 
            IGPMConstants * This,
            /* [retval][out] */ GPMSearchProperty *pVal);
        
        /* [helpstring][id][propget] */ HRESULT ( STDMETHODCALLTYPE *get_SearchPropertyGPOComputerExtensions )( 
            IGPMConstants * This,
            /* [retval][out] */ GPMSearchProperty *pVal);
        
        /* [helpstring][id][propget] */ HRESULT ( STDMETHODCALLTYPE *get_SearchPropertyGPOUserExtensions )( 
            IGPMConstants * This,
            /* [retval][out] */ GPMSearchProperty *pVal);
        
        /* [helpstring][id][propget] */ HRESULT ( STDMETHODCALLTYPE *get_SearchPropertySOMLinks )( 
            IGPMConstants * This,
            /* [retval][out] */ GPMSearchProperty *pVal);
        
        /* [helpstring][id][propget] */ HRESULT ( STDMETHODCALLTYPE *get_SearchPropertyGPODomain )( 
            IGPMConstants * This,
            /* [retval][out] */ GPMSearchProperty *pVal);
        
        /* [helpstring][id][propget] */ HRESULT ( STDMETHODCALLTYPE *get_SearchPropertyBackupMostRecent )( 
            IGPMConstants * This,
            /* [retval][out] */ GPMSearchProperty *pVal);
        
        /* [helpstring][id][propget] */ HRESULT ( STDMETHODCALLTYPE *get_SearchOpEquals )( 
            IGPMConstants * This,
            /* [retval][out] */ GPMSearchOperation *pVal);
        
        /* [helpstring][id][propget] */ HRESULT ( STDMETHODCALLTYPE *get_SearchOpContains )( 
            IGPMConstants * This,
            /* [retval][out] */ GPMSearchOperation *pVal);
        
        /* [helpstring][id][propget] */ HRESULT ( STDMETHODCALLTYPE *get_SearchOpNotContains )( 
            IGPMConstants * This,
            /* [retval][out] */ GPMSearchOperation *pVal);
        
        /* [helpstring][id][propget] */ HRESULT ( STDMETHODCALLTYPE *get_SearchOpNotEquals )( 
            IGPMConstants * This,
            /* [retval][out] */ GPMSearchOperation *pVal);
        
        /* [helpstring][id][propget] */ HRESULT ( STDMETHODCALLTYPE *get_UsePDC )( 
            IGPMConstants * This,
            /* [retval][out] */ ULONG *pVal);
        
        /* [helpstring][id][propget] */ HRESULT ( STDMETHODCALLTYPE *get_UseAnyDC )( 
            IGPMConstants * This,
            /* [retval][out] */ ULONG *pVal);
        
        /* [helpstring][id][propget] */ HRESULT ( STDMETHODCALLTYPE *get_UseAnyDotNetDC )( 
            IGPMConstants * This,
            /* [retval][out] */ ULONG *pVal);
        
        /* [helpstring][id][propget] */ HRESULT ( STDMETHODCALLTYPE *get_SOMSite )( 
            IGPMConstants * This,
            /* [retval][out] */ GPMSOMType *pVal);
        
        /* [helpstring][id][propget] */ HRESULT ( STDMETHODCALLTYPE *get_SOMDomain )( 
            IGPMConstants * This,
            /* [retval][out] */ GPMSOMType *pVal);
        
        /* [helpstring][id][propget] */ HRESULT ( STDMETHODCALLTYPE *get_SOMOU )( 
            IGPMConstants * This,
            /* [retval][out] */ GPMSOMType *pVal);
        
        /* [helpstring][id][propget] */ HRESULT ( STDMETHODCALLTYPE *get_SecurityFlags )( 
            IGPMConstants * This,
            /* [in] */ VARIANT_BOOL vbOwner,
            /* [in] */ VARIANT_BOOL vbGroup,
            /* [in] */ VARIANT_BOOL vbDACL,
            /* [in] */ VARIANT_BOOL vbSACL,
            /* [retval][out] */ ULONG *pVal);
        
        /* [helpstring][id][propget] */ HRESULT ( STDMETHODCALLTYPE *get_ResolveOptionGroupsBySID )( 
            IGPMConstants * This,
            /* [retval][out] */ GPMResolveOption *pVal);
        
        /* [helpstring][id][propget] */ HRESULT ( STDMETHODCALLTYPE *get_ResolveOptionGroupsByName )( 
            IGPMConstants * This,
            /* [retval][out] */ GPMResolveOption *pVal);
        
        /* [helpstring][id][propget] */ HRESULT ( STDMETHODCALLTYPE *get_ResolveOptionTranslationTableOnly )( 
            IGPMConstants * This,
            /* [retval][out] */ GPMResolveOption *pVal);
        
        /* [helpstring][id][propget] */ HRESULT ( STDMETHODCALLTYPE *get_DoNotValidateDC )( 
            IGPMConstants * This,
            /* [retval][out] */ ULONG *pVal);
        
        /* [helpstring][id][propget] */ HRESULT ( STDMETHODCALLTYPE *get_ReportHTML )( 
            IGPMConstants * This,
            /* [retval][out] */ GPMReportType *pVal);
        
        /* [helpstring][id][propget] */ HRESULT ( STDMETHODCALLTYPE *get_ReportXML )( 
            IGPMConstants * This,
            /* [retval][out] */ GPMReportType *pVal);
        
        END_INTERFACE
    } IGPMConstantsVtbl;

    interface IGPMConstants
    {
        CONST_VTBL struct IGPMConstantsVtbl *lpVtbl;
    };

    

#ifdef COBJMACROS


#define IGPMConstants_QueryInterface(This,riid,ppvObject)	\
    (This)->lpVtbl -> QueryInterface(This,riid,ppvObject)

#define IGPMConstants_AddRef(This)	\
    (This)->lpVtbl -> AddRef(This)

#define IGPMConstants_Release(This)	\
    (This)->lpVtbl -> Release(This)


#define IGPMConstants_GetTypeInfoCount(This,pctinfo)	\
    (This)->lpVtbl -> GetTypeInfoCount(This,pctinfo)

#define IGPMConstants_GetTypeInfo(This,iTInfo,lcid,ppTInfo)	\
    (This)->lpVtbl -> GetTypeInfo(This,iTInfo,lcid,ppTInfo)

#define IGPMConstants_GetIDsOfNames(This,riid,rgszNames,cNames,lcid,rgDispId)	\
    (This)->lpVtbl -> GetIDsOfNames(This,riid,rgszNames,cNames,lcid,rgDispId)

#define IGPMConstants_Invoke(This,dispIdMember,riid,lcid,wFlags,pDispParams,pVarResult,pExcepInfo,puArgErr)	\
    (This)->lpVtbl -> Invoke(This,dispIdMember,riid,lcid,wFlags,pDispParams,pVarResult,pExcepInfo,puArgErr)


#define IGPMConstants_get_PermGPOApply(This,pVal)	\
    (This)->lpVtbl -> get_PermGPOApply(This,pVal)

#define IGPMConstants_get_PermGPORead(This,pVal)	\
    (This)->lpVtbl -> get_PermGPORead(This,pVal)

#define IGPMConstants_get_PermGPOEdit(This,pVal)	\
    (This)->lpVtbl -> get_PermGPOEdit(This,pVal)

#define IGPMConstants_get_PermGPOEditSecurityAndDelete(This,pVal)	\
    (This)->lpVtbl -> get_PermGPOEditSecurityAndDelete(This,pVal)

#define IGPMConstants_get_PermGPOCustom(This,pVal)	\
    (This)->lpVtbl -> get_PermGPOCustom(This,pVal)

#define IGPMConstants_get_PermWMIFilterEdit(This,pVal)	\
    (This)->lpVtbl -> get_PermWMIFilterEdit(This,pVal)

#define IGPMConstants_get_PermWMIFilterFullControl(This,pVal)	\
    (This)->lpVtbl -> get_PermWMIFilterFullControl(This,pVal)

#define IGPMConstants_get_PermWMIFilterCustom(This,pVal)	\
    (This)->lpVtbl -> get_PermWMIFilterCustom(This,pVal)

#define IGPMConstants_get_PermSOMLink(This,pVal)	\
    (This)->lpVtbl -> get_PermSOMLink(This,pVal)

#define IGPMConstants_get_PermSOMLogging(This,pVal)	\
    (This)->lpVtbl -> get_PermSOMLogging(This,pVal)

#define IGPMConstants_get_PermSOMPlanning(This,pVal)	\
    (This)->lpVtbl -> get_PermSOMPlanning(This,pVal)

#define IGPMConstants_get_PermSOMGPOCreate(This,pVal)	\
    (This)->lpVtbl -> get_PermSOMGPOCreate(This,pVal)

#define IGPMConstants_get_PermSOMWMICreate(This,pVal)	\
    (This)->lpVtbl -> get_PermSOMWMICreate(This,pVal)

#define IGPMConstants_get_PermSOMWMIFullControl(This,pVal)	\
    (This)->lpVtbl -> get_PermSOMWMIFullControl(This,pVal)

#define IGPMConstants_get_SearchPropertyGPOPermissions(This,pVal)	\
    (This)->lpVtbl -> get_SearchPropertyGPOPermissions(This,pVal)

#define IGPMConstants_get_SearchPropertyGPOEffectivePermissions(This,pVal)	\
    (This)->lpVtbl -> get_SearchPropertyGPOEffectivePermissions(This,pVal)

#define IGPMConstants_get_SearchPropertyGPODisplayName(This,pVal)	\
    (This)->lpVtbl -> get_SearchPropertyGPODisplayName(This,pVal)

#define IGPMConstants_get_SearchPropertyGPOWMIFilter(This,pVal)	\
    (This)->lpVtbl -> get_SearchPropertyGPOWMIFilter(This,pVal)

#define IGPMConstants_get_SearchPropertyGPOID(This,pVal)	\
    (This)->lpVtbl -> get_SearchPropertyGPOID(This,pVal)

#define IGPMConstants_get_SearchPropertyGPOComputerExtensions(This,pVal)	\
    (This)->lpVtbl -> get_SearchPropertyGPOComputerExtensions(This,pVal)

#define IGPMConstants_get_SearchPropertyGPOUserExtensions(This,pVal)	\
    (This)->lpVtbl -> get_SearchPropertyGPOUserExtensions(This,pVal)

#define IGPMConstants_get_SearchPropertySOMLinks(This,pVal)	\
    (This)->lpVtbl -> get_SearchPropertySOMLinks(This,pVal)

#define IGPMConstants_get_SearchPropertyGPODomain(This,pVal)	\
    (This)->lpVtbl -> get_SearchPropertyGPODomain(This,pVal)

#define IGPMConstants_get_SearchPropertyBackupMostRecent(This,pVal)	\
    (This)->lpVtbl -> get_SearchPropertyBackupMostRecent(This,pVal)

#define IGPMConstants_get_SearchOpEquals(This,pVal)	\
    (This)->lpVtbl -> get_SearchOpEquals(This,pVal)

#define IGPMConstants_get_SearchOpContains(This,pVal)	\
    (This)->lpVtbl -> get_SearchOpContains(This,pVal)

#define IGPMConstants_get_SearchOpNotContains(This,pVal)	\
    (This)->lpVtbl -> get_SearchOpNotContains(This,pVal)

#define IGPMConstants_get_SearchOpNotEquals(This,pVal)	\
    (This)->lpVtbl -> get_SearchOpNotEquals(This,pVal)

#define IGPMConstants_get_UsePDC(This,pVal)	\
    (This)->lpVtbl -> get_UsePDC(This,pVal)

#define IGPMConstants_get_UseAnyDC(This,pVal)	\
    (This)->lpVtbl -> get_UseAnyDC(This,pVal)

#define IGPMConstants_get_UseAnyDotNetDC(This,pVal)	\
    (This)->lpVtbl -> get_UseAnyDotNetDC(This,pVal)

#define IGPMConstants_get_SOMSite(This,pVal)	\
    (This)->lpVtbl -> get_SOMSite(This,pVal)

#define IGPMConstants_get_SOMDomain(This,pVal)	\
    (This)->lpVtbl -> get_SOMDomain(This,pVal)

#define IGPMConstants_get_SOMOU(This,pVal)	\
    (This)->lpVtbl -> get_SOMOU(This,pVal)

#define IGPMConstants_get_SecurityFlags(This,vbOwner,vbGroup,vbDACL,vbSACL,pVal)	\
    (This)->lpVtbl -> get_SecurityFlags(This,vbOwner,vbGroup,vbDACL,vbSACL,pVal)

#define IGPMConstants_get_ResolveOptionGroupsBySID(This,pVal)	\
    (This)->lpVtbl -> get_ResolveOptionGroupsBySID(This,pVal)

#define IGPMConstants_get_ResolveOptionGroupsByName(This,pVal)	\
    (This)->lpVtbl -> get_ResolveOptionGroupsByName(This,pVal)

#define IGPMConstants_get_ResolveOptionTranslationTableOnly(This,pVal)	\
    (This)->lpVtbl -> get_ResolveOptionTranslationTableOnly(This,pVal)

#define IGPMConstants_get_DoNotValidateDC(This,pVal)	\
    (This)->lpVtbl -> get_DoNotValidateDC(This,pVal)

#define IGPMConstants_get_ReportHTML(This,pVal)	\
    (This)->lpVtbl -> get_ReportHTML(This,pVal)

#define IGPMConstants_get_ReportXML(This,pVal)	\
    (This)->lpVtbl -> get_ReportXML(This,pVal)

#endif /* COBJMACROS */


#endif 	/* C style interface */



/* [helpstring][id][propget] */ HRESULT STDMETHODCALLTYPE IGPMConstants_get_PermGPOApply_Proxy( 
    IGPMConstants * This,
    /* [retval][out] */ GPMPermissionType *pVal);


void __RPC_STUB IGPMConstants_get_PermGPOApply_Stub(
    IRpcStubBuffer *This,
    IRpcChannelBuffer *_pRpcChannelBuffer,
    PRPC_MESSAGE _pRpcMessage,
    DWORD *_pdwStubPhase);


/* [helpstring][id][propget] */ HRESULT STDMETHODCALLTYPE IGPMConstants_get_PermGPORead_Proxy( 
    IGPMConstants * This,
    /* [retval][out] */ GPMPermissionType *pVal);


void __RPC_STUB IGPMConstants_get_PermGPORead_Stub(
    IRpcStubBuffer *This,
    IRpcChannelBuffer *_pRpcChannelBuffer,
    PRPC_MESSAGE _pRpcMessage,
    DWORD *_pdwStubPhase);


/* [helpstring][id][propget] */ HRESULT STDMETHODCALLTYPE IGPMConstants_get_PermGPOEdit_Proxy( 
    IGPMConstants * This,
    /* [retval][out] */ GPMPermissionType *pVal);


void __RPC_STUB IGPMConstants_get_PermGPOEdit_Stub(
    IRpcStubBuffer *This,
    IRpcChannelBuffer *_pRpcChannelBuffer,
    PRPC_MESSAGE _pRpcMessage,
    DWORD *_pdwStubPhase);


/* [helpstring][id][propget] */ HRESULT STDMETHODCALLTYPE IGPMConstants_get_PermGPOEditSecurityAndDelete_Proxy( 
    IGPMConstants * This,
    /* [retval][out] */ GPMPermissionType *pVal);


void __RPC_STUB IGPMConstants_get_PermGPOEditSecurityAndDelete_Stub(
    IRpcStubBuffer *This,
    IRpcChannelBuffer *_pRpcChannelBuffer,
    PRPC_MESSAGE _pRpcMessage,
    DWORD *_pdwStubPhase);


/* [helpstring][id][propget] */ HRESULT STDMETHODCALLTYPE IGPMConstants_get_PermGPOCustom_Proxy( 
    IGPMConstants * This,
    /* [retval][out] */ GPMPermissionType *pVal);


void __RPC_STUB IGPMConstants_get_PermGPOCustom_Stub(
    IRpcStubBuffer *This,
    IRpcChannelBuffer *_pRpcChannelBuffer,
    PRPC_MESSAGE _pRpcMessage,
    DWORD *_pdwStubPhase);


/* [helpstring][id][propget] */ HRESULT STDMETHODCALLTYPE IGPMConstants_get_PermWMIFilterEdit_Proxy( 
    IGPMConstants * This,
    /* [retval][out] */ GPMPermissionType *pVal);


void __RPC_STUB IGPMConstants_get_PermWMIFilterEdit_Stub(
    IRpcStubBuffer *This,
    IRpcChannelBuffer *_pRpcChannelBuffer,
    PRPC_MESSAGE _pRpcMessage,
    DWORD *_pdwStubPhase);


/* [helpstring][id][propget] */ HRESULT STDMETHODCALLTYPE IGPMConstants_get_PermWMIFilterFullControl_Proxy( 
    IGPMConstants * This,
    /* [retval][out] */ GPMPermissionType *pVal);


void __RPC_STUB IGPMConstants_get_PermWMIFilterFullControl_Stub(
    IRpcStubBuffer *This,
    IRpcChannelBuffer *_pRpcChannelBuffer,
    PRPC_MESSAGE _pRpcMessage,
    DWORD *_pdwStubPhase);


/* [helpstring][id][propget] */ HRESULT STDMETHODCALLTYPE IGPMConstants_get_PermWMIFilterCustom_Proxy( 
    IGPMConstants * This,
    /* [retval][out] */ GPMPermissionType *pVal);


void __RPC_STUB IGPMConstants_get_PermWMIFilterCustom_Stub(
    IRpcStubBuffer *This,
    IRpcChannelBuffer *_pRpcChannelBuffer,
    PRPC_MESSAGE _pRpcMessage,
    DWORD *_pdwStubPhase);


/* [helpstring][id][propget] */ HRESULT STDMETHODCALLTYPE IGPMConstants_get_PermSOMLink_Proxy( 
    IGPMConstants * This,
    /* [retval][out] */ GPMPermissionType *pVal);


void __RPC_STUB IGPMConstants_get_PermSOMLink_Stub(
    IRpcStubBuffer *This,
    IRpcChannelBuffer *_pRpcChannelBuffer,
    PRPC_MESSAGE _pRpcMessage,
    DWORD *_pdwStubPhase);


/* [helpstring][id][propget] */ HRESULT STDMETHODCALLTYPE IGPMConstants_get_PermSOMLogging_Proxy( 
    IGPMConstants * This,
    /* [retval][out] */ GPMPermissionType *pVal);


void __RPC_STUB IGPMConstants_get_PermSOMLogging_Stub(
    IRpcStubBuffer *This,
    IRpcChannelBuffer *_pRpcChannelBuffer,
    PRPC_MESSAGE _pRpcMessage,
    DWORD *_pdwStubPhase);


/* [helpstring][id][propget] */ HRESULT STDMETHODCALLTYPE IGPMConstants_get_PermSOMPlanning_Proxy( 
    IGPMConstants * This,
    /* [retval][out] */ GPMPermissionType *pVal);


void __RPC_STUB IGPMConstants_get_PermSOMPlanning_Stub(
    IRpcStubBuffer *This,
    IRpcChannelBuffer *_pRpcChannelBuffer,
    PRPC_MESSAGE _pRpcMessage,
    DWORD *_pdwStubPhase);


/* [helpstring][id][propget] */ HRESULT STDMETHODCALLTYPE IGPMConstants_get_PermSOMGPOCreate_Proxy( 
    IGPMConstants * This,
    /* [retval][out] */ GPMPermissionType *pVal);


void __RPC_STUB IGPMConstants_get_PermSOMGPOCreate_Stub(
    IRpcStubBuffer *This,
    IRpcChannelBuffer *_pRpcChannelBuffer,
    PRPC_MESSAGE _pRpcMessage,
    DWORD *_pdwStubPhase);


/* [helpstring][id][propget] */ HRESULT STDMETHODCALLTYPE IGPMConstants_get_PermSOMWMICreate_Proxy( 
    IGPMConstants * This,
    /* [retval][out] */ GPMPermissionType *pVal);


void __RPC_STUB IGPMConstants_get_PermSOMWMICreate_Stub(
    IRpcStubBuffer *This,
    IRpcChannelBuffer *_pRpcChannelBuffer,
    PRPC_MESSAGE _pRpcMessage,
    DWORD *_pdwStubPhase);


/* [helpstring][id][propget] */ HRESULT STDMETHODCALLTYPE IGPMConstants_get_PermSOMWMIFullControl_Proxy( 
    IGPMConstants * This,
    /* [retval][out] */ GPMPermissionType *pVal);


void __RPC_STUB IGPMConstants_get_PermSOMWMIFullControl_Stub(
    IRpcStubBuffer *This,
    IRpcChannelBuffer *_pRpcChannelBuffer,
    PRPC_MESSAGE _pRpcMessage,
    DWORD *_pdwStubPhase);


/* [helpstring][id][propget] */ HRESULT STDMETHODCALLTYPE IGPMConstants_get_SearchPropertyGPOPermissions_Proxy( 
    IGPMConstants * This,
    /* [retval][out] */ GPMSearchProperty *pVal);


void __RPC_STUB IGPMConstants_get_SearchPropertyGPOPermissions_Stub(
    IRpcStubBuffer *This,
    IRpcChannelBuffer *_pRpcChannelBuffer,
    PRPC_MESSAGE _pRpcMessage,
    DWORD *_pdwStubPhase);


/* [helpstring][id][propget] */ HRESULT STDMETHODCALLTYPE IGPMConstants_get_SearchPropertyGPOEffectivePermissions_Proxy( 
    IGPMConstants * This,
    /* [retval][out] */ GPMSearchProperty *pVal);


void __RPC_STUB IGPMConstants_get_SearchPropertyGPOEffectivePermissions_Stub(
    IRpcStubBuffer *This,
    IRpcChannelBuffer *_pRpcChannelBuffer,
    PRPC_MESSAGE _pRpcMessage,
    DWORD *_pdwStubPhase);


/* [helpstring][id][propget] */ HRESULT STDMETHODCALLTYPE IGPMConstants_get_SearchPropertyGPODisplayName_Proxy( 
    IGPMConstants * This,
    /* [retval][out] */ GPMSearchProperty *pVal);


void __RPC_STUB IGPMConstants_get_SearchPropertyGPODisplayName_Stub(
    IRpcStubBuffer *This,
    IRpcChannelBuffer *_pRpcChannelBuffer,
    PRPC_MESSAGE _pRpcMessage,
    DWORD *_pdwStubPhase);


/* [helpstring][id][propget] */ HRESULT STDMETHODCALLTYPE IGPMConstants_get_SearchPropertyGPOWMIFilter_Proxy( 
    IGPMConstants * This,
    /* [retval][out] */ GPMSearchProperty *pVal);


void __RPC_STUB IGPMConstants_get_SearchPropertyGPOWMIFilter_Stub(
    IRpcStubBuffer *This,
    IRpcChannelBuffer *_pRpcChannelBuffer,
    PRPC_MESSAGE _pRpcMessage,
    DWORD *_pdwStubPhase);


/* [helpstring][id][propget] */ HRESULT STDMETHODCALLTYPE IGPMConstants_get_SearchPropertyGPOID_Proxy( 
    IGPMConstants * This,
    /* [retval][out] */ GPMSearchProperty *pVal);


void __RPC_STUB IGPMConstants_get_SearchPropertyGPOID_Stub(
    IRpcStubBuffer *This,
    IRpcChannelBuffer *_pRpcChannelBuffer,
    PRPC_MESSAGE _pRpcMessage,
    DWORD *_pdwStubPhase);


/* [helpstring][id][propget] */ HRESULT STDMETHODCALLTYPE IGPMConstants_get_SearchPropertyGPOComputerExtensions_Proxy( 
    IGPMConstants * This,
    /* [retval][out] */ GPMSearchProperty *pVal);


void __RPC_STUB IGPMConstants_get_SearchPropertyGPOComputerExtensions_Stub(
    IRpcStubBuffer *This,
    IRpcChannelBuffer *_pRpcChannelBuffer,
    PRPC_MESSAGE _pRpcMessage,
    DWORD *_pdwStubPhase);


/* [helpstring][id][propget] */ HRESULT STDMETHODCALLTYPE IGPMConstants_get_SearchPropertyGPOUserExtensions_Proxy( 
    IGPMConstants * This,
    /* [retval][out] */ GPMSearchProperty *pVal);


void __RPC_STUB IGPMConstants_get_SearchPropertyGPOUserExtensions_Stub(
    IRpcStubBuffer *This,
    IRpcChannelBuffer *_pRpcChannelBuffer,
    PRPC_MESSAGE _pRpcMessage,
    DWORD *_pdwStubPhase);


/* [helpstring][id][propget] */ HRESULT STDMETHODCALLTYPE IGPMConstants_get_SearchPropertySOMLinks_Proxy( 
    IGPMConstants * This,
    /* [retval][out] */ GPMSearchProperty *pVal);


void __RPC_STUB IGPMConstants_get_SearchPropertySOMLinks_Stub(
    IRpcStubBuffer *This,
    IRpcChannelBuffer *_pRpcChannelBuffer,
    PRPC_MESSAGE _pRpcMessage,
    DWORD *_pdwStubPhase);


/* [helpstring][id][propget] */ HRESULT STDMETHODCALLTYPE IGPMConstants_get_SearchPropertyGPODomain_Proxy( 
    IGPMConstants * This,
    /* [retval][out] */ GPMSearchProperty *pVal);


void __RPC_STUB IGPMConstants_get_SearchPropertyGPODomain_Stub(
    IRpcStubBuffer *This,
    IRpcChannelBuffer *_pRpcChannelBuffer,
    PRPC_MESSAGE _pRpcMessage,
    DWORD *_pdwStubPhase);


/* [helpstring][id][propget] */ HRESULT STDMETHODCALLTYPE IGPMConstants_get_SearchPropertyBackupMostRecent_Proxy( 
    IGPMConstants * This,
    /* [retval][out] */ GPMSearchProperty *pVal);


void __RPC_STUB IGPMConstants_get_SearchPropertyBackupMostRecent_Stub(
    IRpcStubBuffer *This,
    IRpcChannelBuffer *_pRpcChannelBuffer,
    PRPC_MESSAGE _pRpcMessage,
    DWORD *_pdwStubPhase);


/* [helpstring][id][propget] */ HRESULT STDMETHODCALLTYPE IGPMConstants_get_SearchOpEquals_Proxy( 
    IGPMConstants * This,
    /* [retval][out] */ GPMSearchOperation *pVal);


void __RPC_STUB IGPMConstants_get_SearchOpEquals_Stub(
    IRpcStubBuffer *This,
    IRpcChannelBuffer *_pRpcChannelBuffer,
    PRPC_MESSAGE _pRpcMessage,
    DWORD *_pdwStubPhase);


/* [helpstring][id][propget] */ HRESULT STDMETHODCALLTYPE IGPMConstants_get_SearchOpContains_Proxy( 
    IGPMConstants * This,
    /* [retval][out] */ GPMSearchOperation *pVal);


void __RPC_STUB IGPMConstants_get_SearchOpContains_Stub(
    IRpcStubBuffer *This,
    IRpcChannelBuffer *_pRpcChannelBuffer,
    PRPC_MESSAGE _pRpcMessage,
    DWORD *_pdwStubPhase);


/* [helpstring][id][propget] */ HRESULT STDMETHODCALLTYPE IGPMConstants_get_SearchOpNotContains_Proxy( 
    IGPMConstants * This,
    /* [retval][out] */ GPMSearchOperation *pVal);


void __RPC_STUB IGPMConstants_get_SearchOpNotContains_Stub(
    IRpcStubBuffer *This,
    IRpcChannelBuffer *_pRpcChannelBuffer,
    PRPC_MESSAGE _pRpcMessage,
    DWORD *_pdwStubPhase);


/* [helpstring][id][propget] */ HRESULT STDMETHODCALLTYPE IGPMConstants_get_SearchOpNotEquals_Proxy( 
    IGPMConstants * This,
    /* [retval][out] */ GPMSearchOperation *pVal);


void __RPC_STUB IGPMConstants_get_SearchOpNotEquals_Stub(
    IRpcStubBuffer *This,
    IRpcChannelBuffer *_pRpcChannelBuffer,
    PRPC_MESSAGE _pRpcMessage,
    DWORD *_pdwStubPhase);


/* [helpstring][id][propget] */ HRESULT STDMETHODCALLTYPE IGPMConstants_get_UsePDC_Proxy( 
    IGPMConstants * This,
    /* [retval][out] */ ULONG *pVal);


void __RPC_STUB IGPMConstants_get_UsePDC_Stub(
    IRpcStubBuffer *This,
    IRpcChannelBuffer *_pRpcChannelBuffer,
    PRPC_MESSAGE _pRpcMessage,
    DWORD *_pdwStubPhase);


/* [helpstring][id][propget] */ HRESULT STDMETHODCALLTYPE IGPMConstants_get_UseAnyDC_Proxy( 
    IGPMConstants * This,
    /* [retval][out] */ ULONG *pVal);


void __RPC_STUB IGPMConstants_get_UseAnyDC_Stub(
    IRpcStubBuffer *This,
    IRpcChannelBuffer *_pRpcChannelBuffer,
    PRPC_MESSAGE _pRpcMessage,
    DWORD *_pdwStubPhase);


/* [helpstring][id][propget] */ HRESULT STDMETHODCALLTYPE IGPMConstants_get_UseAnyDotNetDC_Proxy( 
    IGPMConstants * This,
    /* [retval][out] */ ULONG *pVal);


void __RPC_STUB IGPMConstants_get_UseAnyDotNetDC_Stub(
    IRpcStubBuffer *This,
    IRpcChannelBuffer *_pRpcChannelBuffer,
    PRPC_MESSAGE _pRpcMessage,
    DWORD *_pdwStubPhase);


/* [helpstring][id][propget] */ HRESULT STDMETHODCALLTYPE IGPMConstants_get_SOMSite_Proxy( 
    IGPMConstants * This,
    /* [retval][out] */ GPMSOMType *pVal);


void __RPC_STUB IGPMConstants_get_SOMSite_Stub(
    IRpcStubBuffer *This,
    IRpcChannelBuffer *_pRpcChannelBuffer,
    PRPC_MESSAGE _pRpcMessage,
    DWORD *_pdwStubPhase);


/* [helpstring][id][propget] */ HRESULT STDMETHODCALLTYPE IGPMConstants_get_SOMDomain_Proxy( 
    IGPMConstants * This,
    /* [retval][out] */ GPMSOMType *pVal);


void __RPC_STUB IGPMConstants_get_SOMDomain_Stub(
    IRpcStubBuffer *This,
    IRpcChannelBuffer *_pRpcChannelBuffer,
    PRPC_MESSAGE _pRpcMessage,
    DWORD *_pdwStubPhase);


/* [helpstring][id][propget] */ HRESULT STDMETHODCALLTYPE IGPMConstants_get_SOMOU_Proxy( 
    IGPMConstants * This,
    /* [retval][out] */ GPMSOMType *pVal);


void __RPC_STUB IGPMConstants_get_SOMOU_Stub(
    IRpcStubBuffer *This,
    IRpcChannelBuffer *_pRpcChannelBuffer,
    PRPC_MESSAGE _pRpcMessage,
    DWORD *_pdwStubPhase);


/* [helpstring][id][propget] */ HRESULT STDMETHODCALLTYPE IGPMConstants_get_SecurityFlags_Proxy( 
    IGPMConstants * This,
    /* [in] */ VARIANT_BOOL vbOwner,
    /* [in] */ VARIANT_BOOL vbGroup,
    /* [in] */ VARIANT_BOOL vbDACL,
    /* [in] */ VARIANT_BOOL vbSACL,
    /* [retval][out] */ ULONG *pVal);


void __RPC_STUB IGPMConstants_get_SecurityFlags_Stub(
    IRpcStubBuffer *This,
    IRpcChannelBuffer *_pRpcChannelBuffer,
    PRPC_MESSAGE _pRpcMessage,
    DWORD *_pdwStubPhase);


/* [helpstring][id][propget] */ HRESULT STDMETHODCALLTYPE IGPMConstants_get_ResolveOptionGroupsBySID_Proxy( 
    IGPMConstants * This,
    /* [retval][out] */ GPMResolveOption *pVal);


void __RPC_STUB IGPMConstants_get_ResolveOptionGroupsBySID_Stub(
    IRpcStubBuffer *This,
    IRpcChannelBuffer *_pRpcChannelBuffer,
    PRPC_MESSAGE _pRpcMessage,
    DWORD *_pdwStubPhase);


/* [helpstring][id][propget] */ HRESULT STDMETHODCALLTYPE IGPMConstants_get_ResolveOptionGroupsByName_Proxy( 
    IGPMConstants * This,
    /* [retval][out] */ GPMResolveOption *pVal);


void __RPC_STUB IGPMConstants_get_ResolveOptionGroupsByName_Stub(
    IRpcStubBuffer *This,
    IRpcChannelBuffer *_pRpcChannelBuffer,
    PRPC_MESSAGE _pRpcMessage,
    DWORD *_pdwStubPhase);


/* [helpstring][id][propget] */ HRESULT STDMETHODCALLTYPE IGPMConstants_get_ResolveOptionTranslationTableOnly_Proxy( 
    IGPMConstants * This,
    /* [retval][out] */ GPMResolveOption *pVal);


void __RPC_STUB IGPMConstants_get_ResolveOptionTranslationTableOnly_Stub(
    IRpcStubBuffer *This,
    IRpcChannelBuffer *_pRpcChannelBuffer,
    PRPC_MESSAGE _pRpcMessage,
    DWORD *_pdwStubPhase);


/* [helpstring][id][propget] */ HRESULT STDMETHODCALLTYPE IGPMConstants_get_DoNotValidateDC_Proxy( 
    IGPMConstants * This,
    /* [retval][out] */ ULONG *pVal);


void __RPC_STUB IGPMConstants_get_DoNotValidateDC_Stub(
    IRpcStubBuffer *This,
    IRpcChannelBuffer *_pRpcChannelBuffer,
    PRPC_MESSAGE _pRpcMessage,
    DWORD *_pdwStubPhase);


/* [helpstring][id][propget] */ HRESULT STDMETHODCALLTYPE IGPMConstants_get_ReportHTML_Proxy( 
    IGPMConstants * This,
    /* [retval][out] */ GPMReportType *pVal);


void __RPC_STUB IGPMConstants_get_ReportHTML_Stub(
    IRpcStubBuffer *This,
    IRpcChannelBuffer *_pRpcChannelBuffer,
    PRPC_MESSAGE _pRpcMessage,
    DWORD *_pdwStubPhase);


/* [helpstring][id][propget] */ HRESULT STDMETHODCALLTYPE IGPMConstants_get_ReportXML_Proxy( 
    IGPMConstants * This,
    /* [retval][out] */ GPMReportType *pVal);


void __RPC_STUB IGPMConstants_get_ReportXML_Stub(
    IRpcStubBuffer *This,
    IRpcChannelBuffer *_pRpcChannelBuffer,
    PRPC_MESSAGE _pRpcMessage,
    DWORD *_pdwStubPhase);



#endif 	/* __IGPMConstants_INTERFACE_DEFINED__ */


#ifndef __IGPMResult_INTERFACE_DEFINED__
#define __IGPMResult_INTERFACE_DEFINED__

/* interface IGPMResult */
/* [unique][helpstring][dual][uuid][object] */ 


EXTERN_C const IID IID_IGPMResult;

#if defined(__cplusplus) && !defined(CINTERFACE)
    
    MIDL_INTERFACE("86DFF7E9-F76F-42AB-9570-CEBC6BE8A52D")
    IGPMResult : public IDispatch
    {
    public:
        virtual /* [helpstring][id][propget] */ HRESULT STDMETHODCALLTYPE get_Status( 
            /* [retval][out] */ IGPMStatusMsgCollection **ppIGPMStatusMsgCollection) = 0;
        
        virtual /* [helpstring][id][propget] */ HRESULT STDMETHODCALLTYPE get_Result( 
            /* [retval][out] */ VARIANT *pvarResult) = 0;
        
        virtual /* [helpstring][id] */ HRESULT STDMETHODCALLTYPE OverallStatus( void) = 0;
        
    };
    
#else 	/* C style interface */

    typedef struct IGPMResultVtbl
    {
        BEGIN_INTERFACE
        
        HRESULT ( STDMETHODCALLTYPE *QueryInterface )( 
            IGPMResult * This,
            /* [in] */ REFIID riid,
            /* [iid_is][out] */ void **ppvObject);
        
        ULONG ( STDMETHODCALLTYPE *AddRef )( 
            IGPMResult * This);
        
        ULONG ( STDMETHODCALLTYPE *Release )( 
            IGPMResult * This);
        
        HRESULT ( STDMETHODCALLTYPE *GetTypeInfoCount )( 
            IGPMResult * This,
            /* [out] */ UINT *pctinfo);
        
        HRESULT ( STDMETHODCALLTYPE *GetTypeInfo )( 
            IGPMResult * This,
            /* [in] */ UINT iTInfo,
            /* [in] */ LCID lcid,
            /* [out] */ ITypeInfo **ppTInfo);
        
        HRESULT ( STDMETHODCALLTYPE *GetIDsOfNames )( 
            IGPMResult * This,
            /* [in] */ REFIID riid,
            /* [size_is][in] */ LPOLESTR *rgszNames,
            /* [in] */ UINT cNames,
            /* [in] */ LCID lcid,
            /* [size_is][out] */ DISPID *rgDispId);
        
        /* [local] */ HRESULT ( STDMETHODCALLTYPE *Invoke )( 
            IGPMResult * This,
            /* [in] */ DISPID dispIdMember,
            /* [in] */ REFIID riid,
            /* [in] */ LCID lcid,
            /* [in] */ WORD wFlags,
            /* [out][in] */ DISPPARAMS *pDispParams,
            /* [out] */ VARIANT *pVarResult,
            /* [out] */ EXCEPINFO *pExcepInfo,
            /* [out] */ UINT *puArgErr);
        
        /* [helpstring][id][propget] */ HRESULT ( STDMETHODCALLTYPE *get_Status )( 
            IGPMResult * This,
            /* [retval][out] */ IGPMStatusMsgCollection **ppIGPMStatusMsgCollection);
        
        /* [helpstring][id][propget] */ HRESULT ( STDMETHODCALLTYPE *get_Result )( 
            IGPMResult * This,
            /* [retval][out] */ VARIANT *pvarResult);
        
        /* [helpstring][id] */ HRESULT ( STDMETHODCALLTYPE *OverallStatus )( 
            IGPMResult * This);
        
        END_INTERFACE
    } IGPMResultVtbl;

    interface IGPMResult
    {
        CONST_VTBL struct IGPMResultVtbl *lpVtbl;
    };

    

#ifdef COBJMACROS


#define IGPMResult_QueryInterface(This,riid,ppvObject)	\
    (This)->lpVtbl -> QueryInterface(This,riid,ppvObject)

#define IGPMResult_AddRef(This)	\
    (This)->lpVtbl -> AddRef(This)

#define IGPMResult_Release(This)	\
    (This)->lpVtbl -> Release(This)


#define IGPMResult_GetTypeInfoCount(This,pctinfo)	\
    (This)->lpVtbl -> GetTypeInfoCount(This,pctinfo)

#define IGPMResult_GetTypeInfo(This,iTInfo,lcid,ppTInfo)	\
    (This)->lpVtbl -> GetTypeInfo(This,iTInfo,lcid,ppTInfo)

#define IGPMResult_GetIDsOfNames(This,riid,rgszNames,cNames,lcid,rgDispId)	\
    (This)->lpVtbl -> GetIDsOfNames(This,riid,rgszNames,cNames,lcid,rgDispId)

#define IGPMResult_Invoke(This,dispIdMember,riid,lcid,wFlags,pDispParams,pVarResult,pExcepInfo,puArgErr)	\
    (This)->lpVtbl -> Invoke(This,dispIdMember,riid,lcid,wFlags,pDispParams,pVarResult,pExcepInfo,puArgErr)


#define IGPMResult_get_Status(This,ppIGPMStatusMsgCollection)	\
    (This)->lpVtbl -> get_Status(This,ppIGPMStatusMsgCollection)

#define IGPMResult_get_Result(This,pvarResult)	\
    (This)->lpVtbl -> get_Result(This,pvarResult)

#define IGPMResult_OverallStatus(This)	\
    (This)->lpVtbl -> OverallStatus(This)

#endif /* COBJMACROS */


#endif 	/* C style interface */



/* [helpstring][id][propget] */ HRESULT STDMETHODCALLTYPE IGPMResult_get_Status_Proxy( 
    IGPMResult * This,
    /* [retval][out] */ IGPMStatusMsgCollection **ppIGPMStatusMsgCollection);


void __RPC_STUB IGPMResult_get_Status_Stub(
    IRpcStubBuffer *This,
    IRpcChannelBuffer *_pRpcChannelBuffer,
    PRPC_MESSAGE _pRpcMessage,
    DWORD *_pdwStubPhase);


/* [helpstring][id][propget] */ HRESULT STDMETHODCALLTYPE IGPMResult_get_Result_Proxy( 
    IGPMResult * This,
    /* [retval][out] */ VARIANT *pvarResult);


void __RPC_STUB IGPMResult_get_Result_Stub(
    IRpcStubBuffer *This,
    IRpcChannelBuffer *_pRpcChannelBuffer,
    PRPC_MESSAGE _pRpcMessage,
    DWORD *_pdwStubPhase);


/* [helpstring][id] */ HRESULT STDMETHODCALLTYPE IGPMResult_OverallStatus_Proxy( 
    IGPMResult * This);


void __RPC_STUB IGPMResult_OverallStatus_Stub(
    IRpcStubBuffer *This,
    IRpcChannelBuffer *_pRpcChannelBuffer,
    PRPC_MESSAGE _pRpcMessage,
    DWORD *_pdwStubPhase);



#endif 	/* __IGPMResult_INTERFACE_DEFINED__ */



#ifndef __GPMGMTLib_LIBRARY_DEFINED__
#define __GPMGMTLib_LIBRARY_DEFINED__

/* library GPMGMTLib */
/* [helpstring][version][uuid] */ 


EXTERN_C const IID LIBID_GPMGMTLib;

EXTERN_C const CLSID CLSID_GPM;

#ifdef __cplusplus

class DECLSPEC_UUID("F5694708-88FE-4B35-BABF-E56162D5FBC8")
GPM;
#endif

EXTERN_C const CLSID CLSID_GPMDomain;

#ifdef __cplusplus

class DECLSPEC_UUID("710901BE-1050-4CB1-838A-C5CFF259E183")
GPMDomain;
#endif

EXTERN_C const CLSID CLSID_GPMSitesContainer;

#ifdef __cplusplus

class DECLSPEC_UUID("229F5C42-852C-4B30-945F-C522BE9BD386")
GPMSitesContainer;
#endif

EXTERN_C const CLSID CLSID_GPMBackupDir;

#ifdef __cplusplus

class DECLSPEC_UUID("FCE4A59D-0F21-4AFA-B859-E6D0C62CD10C")
GPMBackupDir;
#endif

EXTERN_C const CLSID CLSID_GPMSOM;

#ifdef __cplusplus

class DECLSPEC_UUID("32D93FAC-450E-44CF-829C-8B22FF6BDAE1")
GPMSOM;
#endif

EXTERN_C const CLSID CLSID_GPMSearchCriteria;

#ifdef __cplusplus

class DECLSPEC_UUID("17AACA26-5CE0-44FA-8CC0-5259E6483566")
GPMSearchCriteria;
#endif

EXTERN_C const CLSID CLSID_GPMPermission;

#ifdef __cplusplus

class DECLSPEC_UUID("5871A40A-E9C0-46EC-913E-944EF9225A94")
GPMPermission;
#endif

EXTERN_C const CLSID CLSID_GPMSecurityInfo;

#ifdef __cplusplus

class DECLSPEC_UUID("547A5E8F-9162-4516-A4DF-9DDB9686D846")
GPMSecurityInfo;
#endif

EXTERN_C const CLSID CLSID_GPMBackup;

#ifdef __cplusplus

class DECLSPEC_UUID("ED1A54B8-5EFA-482A-93C0-8AD86F0D68C3")
GPMBackup;
#endif

EXTERN_C const CLSID CLSID_GPMBackupCollection;

#ifdef __cplusplus

class DECLSPEC_UUID("EB8F035B-70DB-4A9F-9676-37C25994E9DC")
GPMBackupCollection;
#endif

EXTERN_C const CLSID CLSID_GPMSOMCollection;

#ifdef __cplusplus

class DECLSPEC_UUID("24C1F147-3720-4F5B-A9C3-06B4E4F931D2")
GPMSOMCollection;
#endif

EXTERN_C const CLSID CLSID_GPMWMIFilter;

#ifdef __cplusplus

class DECLSPEC_UUID("626745D8-0DEA-4062-BF60-CFC5B1CA1286")
GPMWMIFilter;
#endif

EXTERN_C const CLSID CLSID_GPMWMIFilterCollection;

#ifdef __cplusplus

class DECLSPEC_UUID("74DC6D28-E820-47D6-A0B8-F08D93D7FA33")
GPMWMIFilterCollection;
#endif

EXTERN_C const CLSID CLSID_GPMRSOP;

#ifdef __cplusplus

class DECLSPEC_UUID("489B0CAF-9EC2-4EB7-91F5-B6F71D43DA8C")
GPMRSOP;
#endif

EXTERN_C const CLSID CLSID_GPMGPO;

#ifdef __cplusplus

class DECLSPEC_UUID("D2CE2994-59B5-4064-B581-4D68486A16C4")
GPMGPO;
#endif

EXTERN_C const CLSID CLSID_GPMGPOCollection;

#ifdef __cplusplus

class DECLSPEC_UUID("7A057325-832D-4DE3-A41F-C780436A4E09")
GPMGPOCollection;
#endif

EXTERN_C const CLSID CLSID_GPMGPOLink;

#ifdef __cplusplus

class DECLSPEC_UUID("C1DF9880-5303-42C6-8A3C-0488E1BF7364")
GPMGPOLink;
#endif

EXTERN_C const CLSID CLSID_GPMGPOLinksCollection;

#ifdef __cplusplus

class DECLSPEC_UUID("F6ED581A-49A5-47E2-B771-FD8DC02B6259")
GPMGPOLinksCollection;
#endif

EXTERN_C const CLSID CLSID_GPMAsyncCancel;

#ifdef __cplusplus

class DECLSPEC_UUID("372796A9-76EC-479D-AD6C-556318ED5F9D")
GPMAsyncCancel;
#endif

EXTERN_C const CLSID CLSID_GPMStatusMsgCollection;

#ifdef __cplusplus

class DECLSPEC_UUID("2824E4BE-4BCC-4CAC-9E60-0E3ED7F12496")
GPMStatusMsgCollection;
#endif

EXTERN_C const CLSID CLSID_GPMStatusMessage;

#ifdef __cplusplus

class DECLSPEC_UUID("4B77CC94-D255-409B-BC62-370881715A19")
GPMStatusMessage;
#endif

EXTERN_C const CLSID CLSID_GPMEnum;

#ifdef __cplusplus

class DECLSPEC_UUID("36ED64E5-7266-4545-8E14-1645EEBA2A90")
GPMEnum;
#endif

EXTERN_C const CLSID CLSID_GPMTrustee;

#ifdef __cplusplus

class DECLSPEC_UUID("C54A700D-19B6-4211-BCB0-E8E2475E471E")
GPMTrustee;
#endif

EXTERN_C const CLSID CLSID_GPMClientSideExtension;

#ifdef __cplusplus

class DECLSPEC_UUID("C1A2E70E-659C-4B1A-940B-F88B0AF9C8A4")
GPMClientSideExtension;
#endif

EXTERN_C const CLSID CLSID_GPMCSECollection;

#ifdef __cplusplus

class DECLSPEC_UUID("CF92B828-2D44-4B61-B10A-B327AFD42DA8")
GPMCSECollection;
#endif

EXTERN_C const CLSID CLSID_GPMConstants;

#ifdef __cplusplus

class DECLSPEC_UUID("3855E880-CD9E-4D0C-9EAF-1579283A1888")
GPMConstants;
#endif

EXTERN_C const CLSID CLSID_GPMResult;

#ifdef __cplusplus

class DECLSPEC_UUID("92101AC0-9287-4206-A3B2-4BDB73D225F6")
GPMResult;
#endif

EXTERN_C const CLSID CLSID_GPOReportProvider;

#ifdef __cplusplus

class DECLSPEC_UUID("18CBB703-4F47-4DCE-A5DD-3817DDBF8169")
GPOReportProvider;
#endif
#endif /* __GPMGMTLib_LIBRARY_DEFINED__ */

/* Additional Prototypes for ALL interfaces */

unsigned long             __RPC_USER  BSTR_UserSize(     unsigned long *, unsigned long            , BSTR * ); 
unsigned char * __RPC_USER  BSTR_UserMarshal(  unsigned long *, unsigned char *, BSTR * ); 
unsigned char * __RPC_USER  BSTR_UserUnmarshal(unsigned long *, unsigned char *, BSTR * ); 
void                      __RPC_USER  BSTR_UserFree(     unsigned long *, BSTR * ); 

unsigned long             __RPC_USER  VARIANT_UserSize(     unsigned long *, unsigned long            , VARIANT * ); 
unsigned char * __RPC_USER  VARIANT_UserMarshal(  unsigned long *, unsigned char *, VARIANT * ); 
unsigned char * __RPC_USER  VARIANT_UserUnmarshal(unsigned long *, unsigned char *, VARIANT * ); 
void                      __RPC_USER  VARIANT_UserFree(     unsigned long *, VARIANT * ); 

/* end of Additional Prototypes */

#ifdef __cplusplus
}
#endif

#endif
=== C:/Users/treeman/Desktop/windows nt source code\Source\Win2K3\NT\public\internal\ds\inc\jet500.h ===
#if !defined(_JET_INCLUDED)
#define _JET_INCLUDED

#ifdef	__cplusplus
extern "C" {
#endif

#if defined(_M_ALPHA)
#pragma pack(8)
#else
#pragma pack(4)
#endif

#define JET_API     __stdcall
#define JET_NODSAPI __stdcall

typedef long JET_ERR;

typedef unsigned long JET_INSTANCE;	/* Instance Identifier */
typedef ULONG_PTR JET_SESID;        /* Session Identifier */
typedef ULONG_PTR JET_TABLEID;  	/* Table Identifier */
typedef unsigned long JET_COLUMNID;	/* Column Identifier */

typedef ULONG_PTR JET_DBID;        	/* Database Identifier */
typedef unsigned long JET_OBJTYP;	/* Object Type */
typedef unsigned long JET_COLTYP;	/* Column Type */
typedef unsigned long JET_GRBIT;  	/* Group of Bits */
typedef unsigned long JET_ACM;		/* Access Mask */
typedef unsigned long JET_RNT;		/* Repair Notification Type */

typedef unsigned long JET_SNP;		/* Status Notification Process */
typedef unsigned long JET_SNT;		/* Status Notification Type */
typedef unsigned long JET_SNC;		/* Status Notification Code */
typedef double JET_DATESERIAL;		/* JET_coltypDateTime format */
typedef unsigned long JET_HANDLE;	/* backup file handle */

typedef JET_ERR (__stdcall *JET_PFNSTATUS)(JET_SESID sesid, JET_SNP snp, JET_SNT snt, void *pv);

typedef struct tagCONVERT
	{
	char			*szOldDll;
	char			*szOldSysDb;
	unsigned long	fDbAttached;		// Return value indicating if Db was attached
	} JET_CONVERT;


typedef enum
	{
	opDBUTILConsistency,
	opDBUTILDumpData,
	opDBUTILDumpMetaData,
	opDBUTILDumpSpace,
	opDBUTILSetHeaderState,
	opDBUTILDumpHeader,
	opDBUTILDumpLogfile,
	opDBUTILDumpCheckpoint
	} DBUTIL_OP;

typedef struct tagDBUTIL
	{
	unsigned long	cbStruct;
	char			*szDatabase;
	char			*szTable;
	char			*szIndex;
	DBUTIL_OP		op;
	JET_GRBIT		grbitOptions;
	} JET_DBUTIL;	

#define JET_bitDBUtilOptionAllNodes				0x00000001
#define JET_bitDBUtilOptionKeyStats				0x00000002
#define JET_bitDBUtilOptionPageDump				0x00000004
#define JET_bitDBUtilOptionDumpVerbose			0x10000000	// DEBUG only
#define JET_bitDBUtilOptionCheckBTree			0x20000000	// DEBUG only


	/*	Session information bits */

#define JET_bitCIMCommitted					 	0x00000001
#define JET_bitCIMDirty	 					 	0x00000002
#define JET_bitAggregateTransaction		  		0x00000008

	/* JetGetLastErrorInfo structure */

typedef struct
	{
	unsigned long	cbStruct;		/* Size of this structure */
	JET_ERR 	   	err;			/* Extended error code (if any) */
	unsigned long	ul1;			/* First general purpose integer */
	unsigned long	ul2;			/* Second general purpose integer */
	unsigned long	ul3;			/* Third general purpose integer */
	} JET_EXTERR;

	/* Status Notification Structures */

typedef struct				/* Status Notification Progress */
	{
	unsigned long	cbStruct;	/* Size of this structure */
	unsigned long	cunitDone;	/* Number of units of work completed */
	unsigned long	cunitTotal;	/* Total number of units of work */
	} JET_SNPROG;

	/* ErrCount Notification Structures */

typedef struct						/* Status Notification Progress */
	{
	unsigned long	cbStruct;	/* Size of this structure */
	unsigned long	cRecUniqueKeyViolation;
	unsigned long	cRecTypeConversionFail;
	unsigned long	cRecRecordLocked;
	unsigned long	cRecTotal;	/* Total number of units of work */
	} JET_SNERRCNT;


typedef struct				/* Status Notification Message */
	{
	unsigned long	cbStruct;	/* Size of this structure */
	JET_SNC  		snc;	  	/* Status Notification Code */
	unsigned long	ul;			/* Numeric identifier */
	char	 		sz[256];  	/* Identifier */
	} JET_SNMSG;


typedef struct
	{
	unsigned long		cbStruct;
	JET_OBJTYP			objtyp;
	JET_DATESERIAL		dtCreate;
	JET_DATESERIAL		dtUpdate;
	JET_GRBIT			grbit;
	unsigned long		flags;
	unsigned long		cRecord;
	unsigned long		cPage;
	} JET_OBJECTINFO;


/*	required for Exchange to make RSTMAP RPC capable
/**/
#ifdef	MIDL_PASS
#define	xRPC_STRING [string]
#else
#define	xRPC_STRING
#if !defined(_NATIVE_WCHAR_T_DEFINED)
typedef unsigned short WCHAR;
#else
typedef wchar_t WCHAR;
#endif
#endif

typedef struct
	{
	xRPC_STRING char		*szDatabaseName;
	xRPC_STRING char		*szNewDatabaseName;
	} JET_RSTMAP;			/* restore map */

/*	required for Exchange unicode support
/**/
#define	UNICODE_RSTMAP

typedef struct tagJET_RSTMAPW {
	xRPC_STRING WCHAR *wszDatabaseName;
	
	xRPC_STRING WCHAR *wszNewDatabaseName;
	} JET_RSTMAPW, *PJET_RSTMAPW;

	/* The following flags appear in the grbit field above */

#define JET_bitTableInfoUpdatable	0x00000001
#define JET_bitTableInfoBookmark	0x00000002
#define JET_bitTableInfoRollback	0x00000004
#define JET_bitTableInfoRestartable	0x00000008
#define JET_bitTableInfoNoInserts	0x00000010

	/* The following flags occur in the flags field above */

#define JET_bitSaveUIDnPWD		0x20000000	/* this bit is only 		 */
											/* appropriate for rmt links */
#define JET_bitObjectExclusive	0x40000000	/* Open link exclusively */
#define JET_bitObjectSystem		0x80000000


typedef struct
	{
	unsigned long	cbStruct;
	JET_TABLEID		tableid;
	unsigned long	cRecord;
	JET_COLUMNID	columnidcontainername;
	JET_COLUMNID	columnidobjectname;
	JET_COLUMNID	columnidobjtyp;
	JET_COLUMNID	columniddtCreate;
	JET_COLUMNID	columniddtUpdate;
	JET_COLUMNID	columnidgrbit;
	JET_COLUMNID	columnidflags;
	JET_COLUMNID	columnidcRecord;	/* Level 2 info */
	JET_COLUMNID	columnidcPage;		/* Level 2 info */
	} JET_OBJECTLIST;

#define cObjectInfoCols 9

typedef struct
	{
	unsigned long	cbStruct;
	JET_TABLEID		tableid;
	unsigned long	cRecord;
	JET_COLUMNID	columnidSid;
	JET_COLUMNID	columnidACM;
	JET_COLUMNID	columnidgrbit; /* grbit from JetSetAccess */
	} JET_OBJECTACMLIST;

#define cObjectAcmCols 3


typedef struct
	{
	unsigned long	cbStruct;
	JET_TABLEID		tableid;
	unsigned long	cRecord;
	JET_COLUMNID	columnidPresentationOrder;
	JET_COLUMNID	columnidcolumnname;
	JET_COLUMNID	columnidcolumnid;
	JET_COLUMNID	columnidcoltyp;
	JET_COLUMNID	columnidCountry;
	JET_COLUMNID	columnidLangid;
	JET_COLUMNID	columnidCp;
	JET_COLUMNID	columnidCollate;
	JET_COLUMNID	columnidcbMax;
	JET_COLUMNID	columnidgrbit;
	JET_COLUMNID	columnidDefault;
	JET_COLUMNID	columnidBaseTableName;
	JET_COLUMNID	columnidBaseColumnName;
	JET_COLUMNID	columnidDefinitionName;
	} JET_COLUMNLIST;

#define cColumnInfoCols 14

typedef struct
	{
	unsigned long	cbStruct;
	JET_COLUMNID	columnid;
	JET_COLTYP		coltyp;
	unsigned short	wCountry;
	unsigned short	langid;
	unsigned short	cp;
	unsigned short	wCollate;       /* Must be 0 */
	unsigned long	cbMax;
	JET_GRBIT		grbit;
	} JET_COLUMNDEF;


typedef struct
	{
	unsigned long	cbStruct;
	JET_COLUMNID	columnid;
	JET_COLTYP		coltyp;
	unsigned short	wCountry;
	unsigned short	langid;
	unsigned short	cp;
	unsigned short	wFiller;       /* Must be 0 */
	unsigned long	cbMax;
	JET_GRBIT		grbit;
	char			szBaseTableName[256];
	char			szBaseColumnName[256];
	} JET_COLUMNBASE;

typedef struct
	{
	unsigned long	cbStruct;
	JET_TABLEID		tableid;
	unsigned long	cRecord;
	JET_COLUMNID	columnidindexname;
	JET_COLUMNID	columnidgrbitIndex;
	JET_COLUMNID	columnidcKey;
	JET_COLUMNID	columnidcEntry;
	JET_COLUMNID	columnidcPage;
	JET_COLUMNID	columnidcColumn;
	JET_COLUMNID	columnidiColumn;
	JET_COLUMNID	columnidcolumnid;
	JET_COLUMNID	columnidcoltyp;
	JET_COLUMNID	columnidCountry;
	JET_COLUMNID	columnidLangid;
	JET_COLUMNID	columnidCp;
	JET_COLUMNID	columnidCollate;
	JET_COLUMNID	columnidgrbitColumn;
	JET_COLUMNID	columnidcolumnname;
	} JET_INDEXLIST;



typedef struct tag_JET_COLUMNCREATE
	{
	unsigned long	cbStruct;				// size of this structure (for future expansion)
	char			*szColumnName;			// column name
	JET_COLTYP		coltyp;					// column type
	unsigned long	cbMax;					// the maximum length of this column (only relevant for binary and text columns)
	JET_GRBIT		grbit;					// column options
	void			*pvDefault;				// default value (NULL if none)
	unsigned long	cbDefault;				// length of default value
	unsigned long	cp;						// code page (for text columns only)
	JET_COLUMNID	columnid;				// returned column id
	JET_ERR			err;					// returned error code
	} JET_COLUMNCREATE;


typedef struct tagJET_INDEXCREATE
	{
	unsigned long	cbStruct;				// size of this structure (for future expansion)
	char			*szIndexName;			// index name
	char			*szKey;					// index key
	unsigned long	cbKey;					// length of key
	JET_GRBIT		grbit;					// index options
	unsigned long	ulDensity;				// index density
	JET_ERR			err;					// returned error code
	} JET_INDEXCREATE;


typedef struct tagJET_TABLECREATE
	{
	unsigned long		cbStruct;				// size of this structure (for future expansion)
	char				*szTableName;			// name of table to create.
	unsigned long		ulPages;				// initial pages to allocate for table.
	unsigned long		ulDensity;				// table density.
	JET_COLUMNCREATE	*rgcolumncreate;		// array of column creation info
	unsigned long		cColumns;				// number of columns to create
	JET_INDEXCREATE		*rgindexcreate;			// array of index creation info
	unsigned long		cIndexes;				// number of indexes to create
	JET_GRBIT			grbit;					// Abort column/index creation on error?
	JET_TABLEID			tableid;				// returned tableid.
	unsigned long		cCreated;				// count of objects created (columns+table+indexes).
	} JET_TABLECREATE;


#define cIndexInfoCols 15

typedef struct
	{
	unsigned long	cbStruct;
	JET_TABLEID		tableid;
	unsigned long	cRecord;
	JET_COLUMNID	columnidReferenceName;
	JET_COLUMNID	columnidgrbit;
	JET_COLUMNID	columnidcColumn;
	JET_COLUMNID	columnidiColumn;
	JET_COLUMNID	columnidReferencingTableName;
	JET_COLUMNID	columnidReferencingColumnName;
	JET_COLUMNID	columnidReferencedTableName;
	JET_COLUMNID	columnidReferencedColumnName;
	} JET_RELATIONSHIPLIST;

/* for backward compatibility */
typedef JET_RELATIONSHIPLIST JET_REFERENCELIST;

#define cReferenceInfoCols 8

typedef struct
	{
	unsigned long	cbStruct;
	unsigned long	ibLongValue;
	unsigned long	itagSequence;
	JET_COLUMNID	columnidNextTagged;
	} JET_RETINFO;

typedef struct
	{
	unsigned long	cbStruct;
	unsigned long	ibLongValue;
	unsigned long	itagSequence;
	} JET_SETINFO;

typedef struct
	{
	unsigned long	cbStruct;
	unsigned long	centriesLT;
	unsigned long	centriesInRange;
	unsigned long	centriesTotal;
	} JET_RECPOS;

typedef struct
	{
	unsigned long	cDiscont;
	unsigned long	cUnfixedMessyPage;
	unsigned long	centriesLT;
	unsigned long	centriesTotal;
	unsigned long	cpgCompactFreed;
	} JET_OLCSTAT;

typedef struct
	{
	unsigned long	ctableid;
	JET_TABLEID		rgtableid[1];
	} JET_MGBLIST;

/*** Property Manager Structure ***/
typedef struct
	{
	unsigned long	cbStruct;
	JET_TABLEID 	tableid;
	JET_COLUMNID 	columnidColumnName;
	JET_COLUMNID 	columnidPropertyName;
	JET_COLUMNID	columnidGrbit;
	JET_COLUMNID	columnidPropertyValue;
	JET_COLUMNID	columnidColtyp;
	} JET_PROPERTYLIST;


/************************************************************************/
/*************************     JET CONSTANTS	 ************************/
/************************************************************************/

#define JET_tableidNil			((JET_TABLEID) 	0xFFFFFFFF)

#define	JET_sesidNil			((JET_SESID) 	0xFFFFFFFF)

	/* Max size of a bookmark */

#define JET_cbBookmarkMost		4

	/* Max length of a object/column/index/property name */

#define JET_cbNameMost			64

	/* Max length of a "name.name.name..." construct */

#define JET_cbFullNameMost		255

	/* Max size of long-value column chunk */

#define JET_cbColumnLVChunkMost		4035

	/* Max size of non-long-value column data */

#define JET_cbColumnMost		255

	/* Max size of a sort/index key */

#define JET_cbKeyMost			255

	/* Max number of components in a sort/index key */

#define JET_ccolKeyMost			12

	/* Max number of columns in a table/query */

#define JET_ccolTableMost		255

	/* Max Length of a property in the property manager */
#define JET_cbPropertyMost 2048

	/* Largest initial substring of a long value used in an expression */

#define JET_cbExprLVMost		0x8000L	/*** 32 K ***/

	/* Max size of returned (from SQLDriverConnect) conn string */

#define JET_cbConnectMost		255

	/* Max number of levels in an MGB */

#define JET_wGroupLevelMax		12

	/* Size restrictions for Pins */
#define JET_cchPINMax			20
#define JET_cchPINMin			4

	/* System parameter codes for JetSetSystemParameter */

/* not supported */
#define JET_paramPfnStatus				2	/* Status callback function */
#define JET_paramPfnError				3	/* Error callback function */
#define JET_paramHwndODBC				4	/* Window handle for ODBC use */
#define JET_paramIniPath				5	/* Path to the ini file */
#define JET_paramPageTimeout			6	/* Red ISAM page timeout value */
#define JET_paramODBCQueryTimeout		7	/* ODBC async query timeout value */
#define JET_paramODBCLoginTimeout		25	/* ODBC connection attempt timeout value */
#define JET_paramExprObject				26  /* Expression Evaluation callback */
#define JET_paramGetTypeComp			27	/* Expression Evaluation callback */
#define JET_paramHostVersion			28	/* Host Version callback */
#define JET_paramSQLTraceMode			29	/* Enable/disable SQL tracing */
#define JET_paramEventId				46	/* NT event id */
#define JET_paramEventCategory			47	/* NT event category */
#define JET_paramRmtXactIsolation		39	/* Do not share connections with other sessions */
#define JET_paramJetInternal			35	/* Whether internal to JET; if set, allows ISAM to do things which are prevented in general */
#define JET_paramFullQJet				38	/* Allow full QJet functionality */

#define JET_paramLogFlushThreshold		18	/* log buffer flush threshold in 512 bytes [10] */
#define JET_paramLogFlushPeriod			22	/* log flush period in miliseconds [45] */

#define JET_paramOnLineCompact			37	/*	Options for compact pages on-line */
#define JET_paramRecovery				30	/* Switch for log on/off */

/* debug only not supported */
#define JET_paramTransactionLevel		32	/* Transaction level of session */
#define JET_paramAssertAction			44	/*	debug only determines action on assert */
#define	JET_paramPrintFunction			49	/* debug only. synched print function */
#define JET_paramRFS2IOsPermitted		54  /* # IOs permitted to succeed (-1 = all) */
#define JET_paramRFS2AllocsPermitted	55  /* # allocs permitted to success (-1 = all) */

/*	fully supported parameters */
/*	Note that one page = 4kBytes.
/**/
#define JET_paramSysDbPath				0	/* path to the system database (defunct) ["<base name>.<base ext>"] */
#define JET_paramSystemPath				0	/* path to check point file ["."] */
#define JET_paramTempPath				1	/* path to the temporary database ["."] */
#define JET_paramMaxBuffers				8	/* maximum page cache size in pages [512] */
#define JET_paramMaxSessions			9	/* maximum number of sessions [128] */
#define JET_paramMaxOpenTables			10	/* maximum number of open tables [300] */
#define JET_paramPreferredMaxOpenTables 	59	/* prefered maximum number of open tables [300] */
#define JET_paramMaxVerPages			11	/* maximum version store size in 16KB buckets [64] */
#define JET_paramMaxCursors				12	/* maximum number of open cursors [1024] */
#define JET_paramLogFilePath			13	/* path to the log file directory ["."] */
#define JET_paramMaxOpenTableIndexes 	14	/* maximum open table indexes [300] */
#define JET_paramMaxTemporaryTables		15	/* maximum concurrent JetCreateIndex [20] */
#define JET_paramLogBuffers				16	/* maximum log buffers in 512 bytes [21] */
#define JET_paramLogFileSize			17	/* maximum log file size in kBytes [5120] */
#define JET_paramBfThrshldLowPrcnt		19	/* low percentage clean buffer flush start [20] */
#define JET_paramBfThrshldHighPrcnt		20	/* high percentage clean buffer flush stop [80] */
#define JET_paramWaitLogFlush			21	/* log flush wait time in milliseconds [15] */
#define JET_paramLogCheckpointPeriod	23	/* checkpoint period in 512 bytes [1024] */
#define JET_paramLogWaitingUserMax		24	/* maximum sessions waiting log flush [3] */
#define JET_paramSessionInfo			33	/* per session information [0] */
#define JET_paramPageFragment			34	/* maximum disk extent considered fragment in pages [8] */
#define JET_paramMaxOpenDatabases		36	/* maximum number of open databases [100] */
#define JET_paramBufBatchIOMax			41	/* maximum batch IO in pages [64] */
#define JET_paramPageReadAheadMax		42	/* maximum read-ahead IO in pages [20] */
#define JET_paramAsynchIOMax			43	/* maximum asynchronous IO in pages [64] */
#define JET_paramEventSource			45	/* language independant process descriptor string [""] */
#define JET_paramDbExtensionSize		48	/* database extension size in pages [16] */
#define JET_paramCommitDefault			50	/* default grbit for JetCommitTransaction [0] */
#define	JET_paramBufLogGenAgeThreshold	51	/* age threshold in log files [2] */
#define	JET_paramCircularLog			52	/* boolean flag for circular logging [0] */
#define JET_paramPageTempDBMin			53  /* minimum size temporary database in pages [0] */
#define JET_paramBaseName				56  /* base name for all DBMS object names ["edb"] */
#define JET_paramBaseExtension	  		57  /* base extension for all DBMS object names ["edb"] */
#define JET_paramTableClassName			58  /* table stats class name (class #, string) */

	/* Flags for JetTerm2 */

#define JET_bitTermComplete				0x00000001
#define JET_bitTermAbrupt				0x00000002

	/* Flags for JetIdle */

#define JET_bitIdleRemoveReadLocks		0x00000001
#define JET_bitIdleFlushBuffers			0x00000002
#define JET_bitIdleCompact				0x00000004
#define JET_bitIdleStatus				0x80000000

	/* Flags for JetEndSession */
								   	
#define JET_bitForceSessionClosed		0x00000001

	/* Flags for JetOpenDatabase */

#define JET_bitDbReadOnly				0x00000001
#define JET_bitDbExclusive				0x00000002 /* multiple opens allowed */
#define JET_bitDbRemoteSilent			0x00000004
#define JET_bitDbSingleExclusive		0x00000008 /* opened exactly once */

	/* Flags for JetCloseDatabase */
										
#define JET_bitDbForceClose				0x00000001
							   	
	/* Flags for JetCreateDatabase */

#define JET_bitDbVersion10				0x00000002 /* INTERNAL USE ONLY */
#define JET_bitDbVersion1x				0x00000004
#define JET_bitDbRecoveryOff 			0x00000008 /* disable logging/recovery for this database */
#define JET_bitDbNoLogging	 			JET_bitDbRecoveryOff
#define JET_bitDbCompleteConnstr		0x00000020
#define JET_bitDbVersioningOff			0x00000040

	/* Flags for JetBackup */

#define JET_bitBackupIncremental		0x00000001
#define JET_bitKeepOldLogs				0x00000002
#define JET_bitBackupAtomic				0x00000004

	/* Database types */

#define JET_dbidNil			((JET_DBID) 0xFFFFFFFF)
#define JET_dbidNoValid		((JET_DBID) 0xFFFFFFFE) /* used as a flag to indicate that there is no valid dbid */

	/* Flags for JetCreateLink */

/* Can use JET_bitObjectExclusive to cause linked to database to be opened */
/* exclusively.															   */



	/* Flags for JetCreateTableColumnIndex */
#define JET_bitTableCreateCheckColumnNames	0x00000001	/* Ensures that each column
														/* specified in the JET_COLUMNCREATE
														/* array has a unique name
														/* (for performance reasons,
														/* the default is to NOT perform
														/* this check and rely on the
														/* function caller to ensure
														/* column name uniqueness).
														/**/
#define JET_bitTableCreateCompaction		0x40000000	/* Internal grbit used when
														/* creating a table during
														/* off-line compact.
														/**/
#define JET_bitTableCreateSystemTable		0x80000000	/* Internal grbit used when
														/* creating system tables.
														/**/


	/* Flags for JetAddColumn, JetGetColumnInfo, JetOpenTempTable */

#define JET_bitColumnFixed				0x00000001
#define JET_bitColumnTagged				0x00000002
#define JET_bitColumnNotNULL			0x00000004
#define JET_bitColumnVersion			0x00000008
#define JET_bitColumnAutoincrement		0x00000010
#define JET_bitColumnUpdatable			0x00000020 /* JetGetColumnInfo only */
#define JET_bitColumnTTKey				0x00000040 /* JetOpenTempTable only */
#define JET_bitColumnTTDescending		0x00000080 /* JetOpenTempTable only */
#define JET_bitColumnNotLast			0x00000100 /* Installable ISAM option */
#define JET_bitColumnRmtGraphic			0x00000200 /* JetGetColumnInfo */
#define JET_bitColumnMultiValued		0x00000400
#define JET_bitColumnColumnGUID			0x00000800
#define JET_bitColumnMostMany			0x00001000
#define JET_bitColumnPreventDelete		0x00002000

	/* Flags for JetSetCurrentIndex */

#define JET_bitMoveFirst				0x00000000
#define JET_bitMoveBeforeFirst 			0x00000001
#define JET_bitNoMove					0x00000002

	/* Flags for JetMakeKey */

#define JET_bitNewKey					0x00000001
#define JET_bitStrLimit 				0x00000002
#define JET_bitSubStrLimit				0x00000004
#define JET_bitNormalizedKey 			0x00000008
#define JET_bitKeyDataZeroLength		0x00000010

#ifdef DBCS /* johnta: LIKE "ABC" not converted to ="ABC" for Japanese */
#define JET_bitLikeExtra1				0x00000020
#endif /* DBCS */

	/* Flags for ErrDispSetIndexRange */

#define JET_bitRangeInclusive			0x00000001
#define JET_bitRangeUpperLimit			0x00000002
#define JET_bitRangeInstantDuration		0x00000004
#define JET_bitRangeRemove				0x00000008

	/* Constants for JetMove */

#define JET_MoveFirst					(0x80000000)
#define JET_MovePrevious				(-1)
#define JET_MoveNext					(+1)
#define JET_MoveLast					(0x7fffffff)

	/* Flags for JetMove */

#define JET_bitMoveKeyNE				0x00000001
#define JET_bitMoveCheckTS				0x00000002
#define JET_bitMoveInPage				0x00000004

	/* Flags for JetSeek */

#define JET_bitSeekEQ					0x00000001
#define JET_bitSeekLT					0x00000002
#define JET_bitSeekLE					0x00000004
#define JET_bitSeekGE					0x00000008
#define JET_bitSeekGT		 			0x00000010
#define JET_bitSetIndexRange			0x00000020

	/* Flags for JetFastFind */

#define JET_bitFFindBackwards			0x00000001
#define JET_bitFFindFromCursor			0x00000004

	/* Flags for JetCreateIndex */

#define JET_bitIndexUnique				0x00000001
#define JET_bitIndexPrimary				0x00000002
#define JET_bitIndexDisallowNull		0x00000004
#define JET_bitIndexIgnoreNull			0x00000008
#define JET_bitIndexClustered			0x00000010
#define JET_bitIndexIgnoreAnyNull		0x00000020
#define JET_bitIndexIgnoreFirstNull		0x00000040
#define JET_bitIndexLazyFlush			0x00000080
#define JET_bitIndexEmptyTable			0x40000000	// Internal use only
#define JET_bitIndexReference			0x80000000    /* IndexInfo only */

	/* Flags for index key definition */

#define JET_bitKeyAscending				0x00000000
#define JET_bitKeyDescending			0x00000001


	/* Flags for JetCreateRelationship */

#define JET_bitRelationUnique			0x00000001
#define JET_bitRelationDontEnforce		0x00000002
#define JET_bitRelationInherited		0x00000004
#define JET_bitRelationTestLegal		0x00000008	/* don't create relationship */

#define JET_bitRelationshipMatchMask	0x000000F0
#define JET_bitRelationMatchDefault		0x00000000
#define JET_bitRelationMatchFull		0x00000010

#define JET_bitRelationUpdateActionMask	0x00000F00
#define JET_bitRelationUpdateDisallow	0x00000000
#define JET_bitRelationUpdateCascade	0x00000100
#define JET_bitRelationUpdateSetNull	0x00000200
#define JET_bitRelationUpdateSetDefault	0x00000300

#define JET_bitRelationDeleteActionMask	0x0000F000
#define JET_bitRelationDeleteDisallow	0x00000000
#define JET_bitRelationDeleteCascade	0x00001000
#define JET_bitRelationDeleteSetNull	0x00002000
#define JET_bitRelationDeleteSetDefault	0x00003000

#define JET_bitRelationUserMask			0xFF000000	/* non-enforced values */
#define JET_bitRelationJoinMask			0x03000000
#define JET_bitRelationInner			0x00000000
#define JET_bitRelationLeft				0x01000000
#define JET_bitRelationRight			0x02000000


	/* Flags for JetCreateReference/JetCreateRelationship */
	/* NOTE: use the bitRelationship flags instead! */

#define JET_ReferenceUnique				JET_bitRelationUnique
#define JET_ReferenceDontEnforce		JET_bitRelationDontEnforce
#define JET_ReferenceMatchTypeMask		JET_bitRelationMatchMask
#define JET_ReferenceMatchDefault		JET_bitRelationMatchDefault
#define JET_ReferenceMatchFull			JET_bitRelationMatchFull
#define JET_ReferenceUpdateActionMask	JET_bitRelationUpdateActionMask
#define JET_ReferenceUpdateDisallow		JET_bitRelationUpdateDisallow
#define JET_ReferenceUpdateCascade		JET_bitRelationUpdateCascade
#define JET_ReferenceUpdateSetNull		JET_bitRelationUpdateSetNull
#define JET_ReferenceUpdateSetDefault	JET_bitRelationUpdateSetDefault
#define JET_ReferenceDeleteActionMask	JET_bitRelationDeleteActionMask
#define JET_ReferenceDeleteDisallow		JET_bitRelationDeleteDisallow
#define JET_ReferenceDeleteCascade		JET_bitRelationDeleteCascade
#define JET_ReferenceDeleteSetNull		JET_bitRelationDeleteSetNull
#define JET_ReferenceDeleteSetDefault	JET_bitRelationDeleteSetDefault


	/* Flags for JetOpenTable */

#define JET_bitTableDenyWrite		0x00000001
#define JET_bitTableDenyRead		0x00000002
#define JET_bitTableReadOnly		0x00000004
#define JET_bitTableAppendOnly		0x00000008
#define JET_bitTableUpdatable		0x00000010
#define JET_bitTableScrollable		0x00000020
#define JET_bitTableFixedSet		0x00000040	/* Fixed working set */
#define JET_bitTableInconsistent	0x00000080
#define JET_bitTableBulk			0x00000100
#define JET_bitTableUsePrimaryIndex	0x00000200	/* Use with FixedSet */
#define JET_bitTableSampleData		0x00000400
#define JET_bitTableQuickBrowse		0x00000800	/* Bias optimizer toward index usage */
#define JET_bitTableDDL				0x00001000	/* similar to JET_bitTableBulk, for DDL */
#define JET_bitTablePassThrough		0x00002000  /* Remote DBs Only */
#define JET_bitTableRowReturning	0x00004000
#define JET_bitTableSequential		0x00008000	/* Intend to access table sequentially */

#define JET_bitTableClassMask		0x000F0000	/*  table stats class mask  */
#define JET_bitTableClassNone		0x00000000  /*  table belongs to no stats class (default)  */
#define JET_bitTableClass1			0x00010000  /*  table belongs to stats class 1  */
#define JET_bitTableClass2			0x00020000  /*  table belongs to stats class 2  */
#define JET_bitTableClass3			0x00030000  /*  table belongs to stats class 3  */
#define JET_bitTableClass4			0x00040000  /*  table belongs to stats class 4  */
#define JET_bitTableClass5			0x00050000  /*  table belongs to stats class 5  */
#define JET_bitTableClass6			0x00060000  /*  table belongs to stats class 6  */
#define JET_bitTableClass7			0x00070000  /*  table belongs to stats class 7  */
#define JET_bitTableClass8			0x00080000  /*  table belongs to stats class 8  */
#define JET_bitTableClass9			0x00090000  /*  table belongs to stats class 9  */
#define JET_bitTableClass10			0x000A0000  /*  table belongs to stats class 10  */
#define JET_bitTableClass11			0x000B0000  /*  table belongs to stats class 11  */
#define JET_bitTableClass12			0x000C0000  /*  table belongs to stats class 12  */
#define JET_bitTableClass13			0x000D0000  /*  table belongs to stats class 13  */
#define JET_bitTableClass14			0x000E0000  /*  table belongs to stats class 14  */
#define JET_bitTableClass15			0x000F0000  /*  table belongs to stats class 15  */

	/* Flags for JetSetQoSql/JetRetrieveQoSql */
#define JET_bitSqlPassThrough		0x00000001	/* Pass through Query returning records */
#define JET_bitSqlSPTBulkOp			0x00000002  /* SPT query returning no table */
	
	/* Flags for JetOpenVtQbe */

#define JET_bitQBEAddBrackets		0x00000001
#define JET_bitQBERemoveEquals		0x00000002

	/* Flags for JetOpenTempTable and ErrIsamOpenTempTable */

#define JET_bitTTIndexed		0x00000001	/* Allow seek */
#define JET_bitTTUnique 		0x00000002	/* Remove duplicates */
#define JET_bitTTUpdatable		0x00000004	/* Allow updates */
#define JET_bitTTScrollable		0x00000008	/* Allow backwards scrolling */

	/* Flags for JetSetColumn */

#define JET_bitSetAppendLV			0x00000001
#define JET_bitSetValidate			0x00000002
#define JET_bitSetOverwriteLV		0x00000004 /* overwrite JET_coltypLong* byte range */
#define JET_bitSetSizeLV			0x00000008 /* set JET_coltypLong* size */
#define JET_bitSetValidateColumn	0x00000010
#define JET_bitSetZeroLength		0x00000020
#define JET_bitSetSeparateLV 		0x00000040 /* force LV separation */
#define JET_bitSetNoVersion 		0x00000080 /* INTERNAL USE ONLY */

	/*	Set column parameter structure for JetSetColumns */

typedef struct {
	JET_COLUMNID			columnid;
	const void 				*pvData;
	unsigned long 			cbData;
	JET_GRBIT				grbit;
	unsigned long			ibLongValue;
	unsigned long			itagSequence;
	JET_ERR					err;
} JET_SETCOLUMN;

	/* Options for JetPrepareUpdate */

#define JET_prepInsert					0
#define JET_prepInsertBeforeCurrent		1
#define JET_prepReplace 				2
#define JET_prepCancel					3
#define JET_prepReplaceNoLock			4
#define JET_prepInsertCopy				5

	/* Flags for JetRetrieveColumn */

#define JET_bitRetrieveCopy				0x00000001
#define JET_bitRetrieveFromIndex		0x00000002
#define JET_bitRetrieveCase				0x00000004
#define JET_bitRetrieveTag				0x00000008
#define JET_bitRetrieveNull				0x00000010	/*	for columnid 0 only */
#define JET_bitRetrieveIgnoreDefault	0x00000020	/*	for columnid 0 only */
#define JET_bitRetrieveLongId			0x00000040
#define JET_bitRetrieveRecord			0x80000000
#define JET_bitRetrieveFDB				0x40000000
#define JET_bitRetrieveBookmarks		0x20000000

	/* Retrieve column parameter structure for JetRetrieveColumns */

typedef struct {
	JET_COLUMNID		columnid;
	void 			*pvData;
	unsigned long 		cbData;
	unsigned long 		cbActual;
	JET_GRBIT			grbit;
	unsigned long		ibLongValue;
	unsigned long		itagSequence;
	JET_COLUMNID		columnidNextTagged;
	JET_ERR				err;
} JET_RETRIEVECOLUMN;

	/* Flags for JetFillFatCursor */

#define JET_bitFCFillRange			0x00000001
#define JET_bitFCRefreshRange		0x00000002
#define JET_bitFCFillMemos			0x00000004

	/* Flags for JetCommitTransaction */

#define JET_bitCommitFlush			0x00000001	/* commit and flush page buffers. */
#define	JET_bitCommitLazyFlush		0x00000004	/* lazy flush log buffers. */
#define JET_bitWaitLastLevel0Commit	0x00000010	/* wait for last level 0 commit record flushed */

	/* Flags for JetRollback */

#define JET_bitRollbackAll			0x00000001

	/* Flags for JetSetAccess and JetGetAccess */

#define JET_bitACEInheritable		0x00000001

	/* Flags for JetCreateSystemDatabase */

#define JET_bitSysDbOverwrite		0x00000001

	/* Flags for Jet Property Management */
#define JET_bitPropDDL				0x00000001		/* also used for setting */
#define JET_bitPropInherited		0x00000002		/* not used for setting */

	/* JPM Flags that are only used for setting properties */
#define JET_bitPropReplaceOnly		0x00000010
#define JET_bitPropInsertOnly		0x00000020
#define JET_bitPropDeleteOnly		0x00000040
	
	/* InfoLevels for Jet Property Management */
#define JET_PropertyValue				0
#define JET_PropertyCount				1
#define JET_PropertySingleCollection 	2
#define JET_PropertyAllCollections		3

	/* Collate values for JetGetColumnInfo and JetGetIndexInfo */

#define JET_sortBinary			0x0000
#define JET_sortEFGPI			0x0100
#define JET_sortSNIFD			0x0101
#define JET_sortSpanish 		0x0102
#define JET_sortDutch			0x0103
#define JET_sortSweFin			0x0104
#define JET_sortNorDan			0x0105
#define JET_sortIcelandic		0x0106
#define JET_sortCyrillic		0x0107
#define JET_sortCzech			0x0108
#define JET_sortHungarian		0x0109
#define JET_sortPolish			0x010A
#define JET_sortArabic			0x010B
#define JET_sortHebrew			0x010C
#define JET_sortMax				0x010C		/* Max for nonDBCS sort orders */

#ifdef DBCS	/* johnta: Add the new Japanese sorting order */
#define JET_sortJapanese		0x010D
#endif /* DBCS */

#define JET_sortUnknown 		0xFFFF

	/* Paradox ISAM specific collate values */

#define JET_sortPdxIntl 		0x1000
#define JET_sortPdxSwedFin		0x1001
#define JET_sortPdxNorDan		0x1002

	/* Info parameter for JetGetDatabaseInfo */

#define JET_DbInfoFilename			0
#define JET_DbInfoConnect			1
#define JET_DbInfoCountry			2
#define JET_DbInfoLangid			3
#define JET_DbInfoCp				4
#define JET_DbInfoCollate			5
#define JET_DbInfoOptions			6
#define JET_DbInfoTransactions		7
#define JET_DbInfoVersion			8
#define JET_DbInfoIsam				9
#define JET_DbInfoFilesize			10
#define JET_DbInfoSpaceOwned		11
#define JET_DbInfoSpaceAvailable	12

	/* Database versions returned by JetGetDatabaseInfo */

#define JET_DbVersion10			0x00010000
#define JET_DbVersion11			0x00010001
#define JET_DbVersion20			0x00020000


	/* Isam specific info returned by JetGetDatabaseInfo */

#define JET_IsamInvalid			0
#define JET_IsamBuiltinRed		1
#define JET_IsamBuiltinBlue		2

#define	JET_IsamInstRed			21
#define JET_IsamInstBlue		22
#define	JET_IsamInstFox			23
#define JET_IsamInstParadox		24
#define JET_IsamInstDbase		25
#define	JET_IsamInstBtrieve		26

#define JET_IsamBuilinMost		JET_BuiltinBlue
#define JET_IsamInstMin			JET_IsamInstRed
#define	JET_IsamInstMost		JET_IsamInstBtrieve

	/* Link specific info for link identification */
#define JET_bitLinkInvalid		0x00000000
#define JET_bitLinkRemote		0x00100000
#define JET_bitLinkBuiltinRed	0x00200000
#define JET_bitLinkBuiltinBlue	0x00300000
#define JET_bitLinkInstRed		0x00400000
#define JET_bitLinkInstBlue		0x00500000
#define JET_bitLinkInstFox		0x00600000
#define JET_bitLinkInstParadox	0x00700000
#define JET_bitLinkInstDbase	0x00800000
#define JET_bitLinkInstBtrieve	0x00900000

#define JET_bitFourByteBookmark		0x00000001
#define	JET_bitContiguousBookmarks	0x00000002

	/* Column data types */

#define JET_coltypNil				0
#define JET_coltypBit				1      /* True or False, Never NULL */
#define JET_coltypUnsignedByte		2      /* 1-byte integer, unsigned */
#define JET_coltypShort 			3      /* 2-byte integer, signed */
#define JET_coltypLong				4      /* 4-byte integer, signed */
#define JET_coltypCurrency			5      /* 8 byte integer, signed */
#define JET_coltypIEEESingle		6      /* 4-byte IEEE single precision */
#define JET_coltypIEEEDouble		7      /* 8-byte IEEE double precision */
#define JET_coltypDateTime			8      /* Integral date, fractional time */
#define JET_coltypBinary			9      /* Binary data, < 255 bytes */
#define JET_coltypText				10     /* ANSI text, case insensitive, < 255 bytes */
#define JET_coltypLongBinary		11     /* Binary data, long value */
#define JET_coltypLongText			12     /* ANSI text, long value */
#define JET_coltypDatabase			13		/* Database name parameter */
#define JET_coltypTableid			14		/* Tableid parameter */
#define JET_coltypOLE				15		/* OLE blob */
#define JET_coltypGUID				15
#define JET_coltypMax				16		/* the number of column types  */
											/* used for validity tests and */
											/* array declarations.		   */

	/* Info levels for JetGetObjectInfo */

#define JET_ObjInfo					0U
#define JET_ObjInfoListNoStats		1U
#define JET_ObjInfoList 			2U
#define JET_ObjInfoSysTabCursor 	3U
#define JET_ObjInfoListACM			4U /* Blocked by JetGetObjectInfo */
#define JET_ObjInfoNoStats			5U
#define JET_ObjInfoSysTabReadOnly	6U
#define JET_ObjInfoRulesLoaded		7U
#define JET_ObjInfoMax				8U

	/* Info levels for JetGetTableInfo */

#define JET_TblInfo				0U
#define JET_TblInfoName			1U
#define JET_TblInfoDbid			2U
#define JET_TblInfoMostMany  	3U
#define JET_TblInfoRvt			4U
#define JET_TblInfoOLC			5U
#define JET_TblInfoResetOLC 	6U
#define JET_TblInfoSpaceUsage	7U
#define JET_TblInfoDumpTable	8U
#define JET_TblInfoSpaceAlloc	9U
#define JET_TblInfoSpaceOwned	10U				// OwnExt
#define JET_TblInfoSpaceAvailable	11U			// AvailExt

	/* Info levels for JetGetIndexInfo and JetGetTableIndexInfo */

#define JET_IdxInfo					0U
#define JET_IdxInfoList 			1U
#define JET_IdxInfoSysTabCursor 	2U
#define JET_IdxInfoOLC				3U
#define JET_IdxInfoResetOLC			4U
#define JET_IdxInfoSpaceAlloc		5U
#define JET_IdxInfoLangid			6U
#define JET_IdxInfoCount			7U

	/* Info levels for JetGetReferenceInfo and JetGetTableReferenceInfo */

#define JET_ReferenceInfo				0U
#define JET_ReferenceInfoReferencing	1U
#define JET_ReferenceInfoReferenced		2U
#define JET_ReferenceInfoAll			3U
#define JET_ReferenceInfoCursor 		4U

	/* Info levels for JetGetColumnInfo and JetGetTableColumnInfo */

#define JET_ColInfo					0U
#define JET_ColInfoList 			1U
	/* CONSIDER: Info level 2 is valid */
#define JET_ColInfoSysTabCursor 	3U
#define JET_ColInfoBase 			4U
#define JET_ColInfoListCompact 		5U


	/* Attribute types for query definitions */

#define JET_qoaBeginDef 		0
#define JET_qoaOperation		1
#define JET_qoaParameter		2
#define JET_qoaOptions			3
#define JET_qoaDatabase 		4
#define JET_qoaInputTable		5
#define JET_qoaOutput			6
#define JET_qoaJoin				7
#define JET_qoaRestriction		8
#define JET_qoaGroup			9
#define JET_qoaGroupRstr		10
#define JET_qoaOrdering 		11
#define JET_qoaEndDef			255
#define JET_qoaValidLeast		JET_qoaOperation
#define JET_qoaValidMost		JET_qoaOrdering


	/* Query object options */

#define JET_bitFqoOutputAllCols 	0x0001
#define JET_bitFqoRemoveDups		0x0002
#define JET_bitFqoOwnerAccess		0x0004
#define JET_bitFqoDistinctRow		0x0008
#define JET_bitFqoTop				0x0010
#define JET_bitFqoPercent			0x0020
#define JET_bitFqoCorresponding		0x0040 /* JET_qopSetOperation */

	/* Query object join type */

#define JET_fjoinInner			1
#define JET_fjoinLeftOuter		2
#define JET_fjoinRightOuter		3

	/* Query object operations */

#define JET_qopSelect			1
#define JET_qopSelectInto		2
#define JET_qopInsertSelection	3
#define JET_qopUpdate			4
#define JET_qopDelete			5
#define JET_qopTransform		6
#define JET_qopDDL				7
#define JET_qopSqlPassThrough	8
#define JET_qopSetOperation		9
#define JET_qopSPTBulk			10

#define JET_bitqopSelect			0x0000
#define JET_bitqopTransform			0x0010
#define JET_bitqopDelete			0x0020
#define JET_bitqopUpdate			0x0030
#define JET_bitqopInsertSelection	0x0040
#define JET_bitqopSelectInto		0x0050
#define JET_bitqopDDL				0x0060
#define JET_bitqopSqlPassThrough	0x0070
#define JET_bitqopSetOperation		0x0080
#define JET_bitqopSPTBulk			0x0090

	/* Engine Object Types */

#define JET_objtypNil				0
#define JET_objtypTable 			1
#define JET_objtypDb				2
#define JET_objtypContainer			3
#define JET_objtypSQLLink			4
#define JET_objtypQuery 			5
#define JET_objtypLink				6
#define JET_objtypTemplate			7
#define JET_objtypRelationship		8

	/* All types less than JET_objtypClientMin are reserved by JET */

#define JET_objtypClientMin			0x8000

	/* Security Constant Values */

#define JET_cchUserNameMax		20
#define JET_cchPasswordMax		14

	/* Security Access Masks */

#define JET_acmNoAccess 		0x00000000L
#define JET_acmFullAccess		0x000FFFFFL

#define JET_acmSpecificMask		0x0000FFFFL
#define JET_acmSpecific_1		0x00000001L
#define JET_acmSpecific_2		0x00000002L
#define JET_acmSpecific_3		0x00000004L
#define JET_acmSpecific_4		0x00000008L
#define JET_acmSpecific_5		0x00000010L
#define JET_acmSpecific_6		0x00000020L
#define JET_acmSpecific_7		0x00000040L
#define JET_acmSpecific_8		0x00000080L
#define JET_acmSpecific_9		0x00000100L
#define JET_acmSpecific_10		0x00000200L
#define JET_acmSpecific_11		0x00000400L
#define JET_acmSpecific_12		0x00000800L
#define JET_acmSpecific_13		0x00001000L
#define JET_acmSpecific_14		0x00002000L
#define JET_acmSpecific_15		0x00004000L
#define JET_acmSpecific_16		0x00008000L

#define JET_acmStandardMask		0x00FF0000L
#define JET_acmDelete			0x00010000L
#define JET_acmReadControl		0x00020000L
#define JET_acmWriteDac 		0x00040000L
#define JET_acmWriteOwner		0x00080000L

#define JET_acmTblCreate			(JET_acmSpecific_1)
#define JET_acmTblAccessRcols		(JET_acmSpecific_2)
#define JET_acmTblReadDef			(JET_acmSpecific_3)
#define JET_acmTblWriteDef			(JET_acmSpecific_4)
#define JET_acmTblRetrieveData		(JET_acmSpecific_5)
#define JET_acmTblInsertData		(JET_acmSpecific_6)
#define JET_acmTblReplaceData		(JET_acmSpecific_7)
#define JET_acmTblDeleteData		(JET_acmSpecific_8)

#define JET_acmDbCreate 			(JET_acmSpecific_1)
#define JET_acmDbOpen				(JET_acmSpecific_2)

	/* Compact Options */

#define JET_bitCompactDontCopyLocale	0x00000004	/* Don't copy locale from source to dest */
#define JET_bitCompactVersion10			0x00000008	/* Destination is version 1.0 format */
#define JET_bitCompactVersion1x			0x00000010	/* Destination is version 1.x format */
#define JET_bitCompactStats				0x00000020	/* Dump off-line compaction stats (only when progress meter also specified) */

	/* On-line Compact Options */

#define JET_bitCompactOn	 			0x00000001	/* enable on-line compaction */

	/* Repair Notification Types */

#define JET_rntSelfContained		0
#define JET_rntDeletedIndex			1
#define JET_rntDeletedRec			2
#define JET_rntDeletedLv			3
#define JET_rntTruncated			4

	/* Status Notification Processes */

#define JET_snpIndex				0
#define JET_snpQuery				1
#define JET_snpRepair				2
#define JET_snpImex					3
#define JET_snpCompact				4
#define JET_snpFastFind 			5
#define JET_snpODBCNotReady			6
#define JET_snpQuerySort	   		7
#define JET_snpRestore				8
#define JET_snpBackup				9
#define JET_snpUpgrade				10

	/* Status Notification Types */

#define JET_sntProgress 		0	/* callback for progress */
#define JET_sntMessage			1
#define JET_sntBulkRecords		2	/* callback for # rec for bulk op */
#define JET_sntFail				3	/* callback for failure during progress */
#define JET_sntErrCount 		4	/* callback for err count */
#define JET_sntBegin			5	/* callback for beginning of operation */
#define JET_sntComplete 		6	/* callback for completion of operation */
#define JET_sntCantRollback		7	/* callback for no rollback */
#define JET_sntRestoreMap		8	/* callback for restore map */

	/* Message codes for JET_snpCompact */

#define JET_sncCopyObject		0	/* Starting to copy object */
#define JET_sncCopyFailed		1	/* Copy of this object failed */
#define JET_sncYield			2	/* Client can yield/check for user interrupt */
#define JET_sncTransactionFull	3	/* Client can yield/check for user interrupt */
#define JET_sncAboutToWrap		4	/* Find find is about to wrap */

	/* Message codes for JET_snpODBCNotReady */

#define JET_sncODBCNotReady		0	/* Waiting for results from ODBC */


	/* Constants for the [ODBC] section of JET.INI */

#define JET_SQLTraceCanonical	0x0001	/* Output ODBC Generic SQL */

	/* Constants for the [Debug] section of JET.INI */

	/* APITrace */

#define JET_APITraceEnter		0x0001
#define JET_APITraceExit		0x0002
#define JET_APITraceExitError	0x0004
#define JET_APIBreakOnError		0x0008
#define JET_APITraceCount		0x0010
#define JET_APITraceNoIdle		0x0020
#define JET_APITraceParameters	0x0040

	/* IdleTrace */

#define JET_IdleTraceCursor		0x0001
#define JET_IdleTraceBuffer		0x0002
#define JET_IdleTraceFlush		0x0004

	/* AssertAction */

#define JET_AssertExit			0x0000		/* Exit the application */
#define JET_AssertBreak 		0x0001		/* Break to debugger */
#define JET_AssertMsgBox		0x0002		/* Display message box */
#define JET_AssertStop			0x0004		/* Alert and stop */

	/* IOTrace */

#define JET_IOTraceAlloc		0x0001		/* DB Page Allocation */
#define JET_IOTraceFree 		0x0002		/* DB Page Free */
#define JET_IOTraceRead 		0x0004		/* DB Page Read */
#define JET_IOTraceWrite		0x0008		/* DB Page Write */
#define JET_IOTraceError		0x0010		/* DB Page I/O Error */

	/* MemTrace */

#define JET_MemTraceAlloc		0x0001		/* Memory allocation */
#define JET_MemTraceRealloc		0x0002		/* Memory reallocation */
#define JET_MemTraceFree		0x0004		/* Memory free */

	/* RmtTrace */

#define JET_RmtTraceError		0x0001	/* Remote server error message */
#define JET_RmtTraceSql			0x0002	/* Remote SQL Prepares & Exec's */
#define JET_RmtTraceAPI			0x0004	/* Remote ODBC API calls */
#define JET_RmtTraceODBC		0x0008
#define JET_RmtSyncODBC			0x0010	/* Turn on ODBC Sync mode */
	
/**********************************************************************/
/***********************     ERROR CODES     **************************/
/**********************************************************************/

/* SUCCESS */

#define JET_errSuccess						 0    /* Successful Operation */

/* ERRORS */

#define JET_wrnNyi							-1    /* Function Not Yet Implemented */

/*	SYSTEM errors
/**/
#define JET_errRfsFailure			   		-100  /* JET_errRfsFailure */
#define JET_errRfsNotArmed					-101  /* JET_errRfsFailure */
#define JET_errFileClose					-102  /* Could not close DOS file */
#define JET_errOutOfThreads					-103  /* Could not start thread */
#define JET_errTooManyIO		  			-105  /* System busy due to too many IOs */
#define JET_errDatabase200Format			-106  /* 200 format database */
#define JET_errDatabase400Format			-107  /* 400 format database */

/*	BUFFER MANAGER errors
/**/
#define wrnBFNotSynchronous					200	  /* Buffer page evicted */
#define wrnBFPageNotFound		  			201	  /* Page not found */
#define errBFInUse				  			-202  /* Cannot abandon buffer */
#define wrnBFNewIO							203	  /* Buffer access caused a new IO (cache miss) */
#define wrnBFCacheMiss						204	  /* Buffer access was a cache miss but didn't cause a new IO */
#define	wrnBFNoBufAvailable					205	  /* Need to allocate new buffer for read (used in Async IO ) */

/*	DIRECTORY MANAGER errors
/**/
#define errPMOutOfPageSpace					-300  /* Out of page space */
#define errPMItagTooBig 		  			-301  /* Itag too big */
#define errPMRecDeleted 		  			-302  /* Record deleted */
#define errPMTagsUsedUp 		  			-303  /* Tags used up */
#define wrnBMConflict			  			304   /* conflict in BM Clean up */
#define errDIRNoShortCircuit	  			-305  /* No Short Circuit Avail */
#define errDIRCannotSplit		  			-306  /* Cannot horizontally split FDP */
#define errDIRTop				  			-307  /* Cannot go up */
#define errDIRFDP							308	  /* On an FDP Node */
#define errDIRNotSynchronous				-309  /* May have left critical section */
#define wrnDIREmptyPage						310	  /* Moved through empty page */
#define errSPConflict						-311  /* Device extent being extended */
#define wrnNDFoundLess						312	  /* Found Less */
#define wrnNDFoundGreater					313	  /* Found Greater */
#define errNDOutSonRange					-314  /* Son out of range */
#define errNDOutItemRange					-315  /* Item out of range */
#define errNDGreaterThanAllItems 			-316  /* Greater than all items */
#define errNDLastItemNode					-317  /* Last node of item list */
#define errNDFirstItemNode					-318  /* First node of item list */
#define wrnNDDuplicateItem					319	  /* Duplicated Item */
#define errNDNoItem							-320  /* Item not there */
#define JET_wrnRemainingVersions 			321	  /* Some versions couldn't be cleaned */
#define JET_wrnPreviousVersion				322	  /* Version already existed */
#define JET_errPageBoundary					-323  /* Reached Page Boundary */
#define JET_errKeyBoundary		  			-324  /* Reached Key Boundary */
#define errDIRInPageFather  				-325  /* sridFather in page to free */
#define	errBMMaxKeyInPage					-326  /* used by OLC to avoid cleanup of parent pages */
#define	JET_errBadPageLink					-327  /* next/previous page link page does not point back to source */
#define	JET_errBadBookmark					-328  /* bookmark has no corresponding address in database */
#define wrnBMCleanNullOp					329	  /* BMClean returns this on encountering a page
												  /* deleted MaxKeyInPage [but there was no conflict]
												
/*	RECORD MANAGER errors
/**/
#define wrnFLDKeyTooBig 					400	  /* Key too big (truncated it) */
#define errFLDTooManySegments				-401  /* Too many key segments */
#define wrnFLDNullKey						402	  /* Key is entirely NULL */
#define wrnFLDOutOfKeys 					403	  /* No more keys to extract */
#define wrnFLDNullSeg						404	  /* Null segment in key */
#define wrnRECLongField 					405	  /* Separated long value */
#define JET_wrnSeparateLongValue			406	  /* Separated long value */
#define JET_wrnRecordFoundGreater			JET_wrnSeekNotEqual
#define JET_wrnRecordFoundLess    			JET_wrnSeekNotEqual
#define JET_errColumnIllegalNull  			JET_errNullInvalid
#define wrnFLDNullFirstSeg		   			407	  /* Null first segment in key */
#define JET_errKeyTooBig					-408  /* Key with column truncation still truncated */

/*	LOGGING/RECOVERY errors
/**/
#define JET_errInvalidLoggedOperation		-500  /* Logged operation cannot be redone */
#define JET_errLogFileCorrupt		  		-501  /* Log file is corrupt */
#define errLGNoMoreRecords					-502  /* Last log record read */
#define JET_errNoBackupDirectory 			-503  /* No backup directory given */
#define JET_errBackupDirectoryNotEmpty 		-504  /* The backup directory is not emtpy */
#define JET_errBackupInProgress 			-505  /* Backup is active already */
#define JET_errMissingPreviousLogFile		-509  /* Missing the log file for check point */
#define JET_errLogWriteFail					-510  /* Fail when writing to log file */
#define JET_errBadLogVersion  	  			-514  /* Version of log file is not compatible with Jet version */
#define JET_errInvalidLogSequence  			-515  /* Timestamp in next log does not match expected */
#define JET_errLoggingDisabled 				-516  /* Log is not active */
#define JET_errLogBufferTooSmall			-517  /* Log buffer is too small for recovery */
#define errLGNotSynchronous					-518  /* retry to LGLogRec */
#define JET_errLogSequenceEnd				-519  /* Exceed maximum log file number */
#define JET_errNoBackup						-520  /* No backup in progress */
#define	JET_errInvalidBackupSequence		-521  /* Backup call out of sequence */
#define JET_errBackupNotAllowedYet			-523  /* Can not do backup now */
#define JET_errDeleteBackupFileFail	   		-524  /* Could not delete backup file */
#define JET_errMakeBackupDirectoryFail 		-525  /* Could not make backup temp directory */
#define JET_errInvalidBackup		 		-526  /* Cannot incremental backup when circular logging enabled */
#define JET_errRecoveredWithErrors			-527  /* For repair, restored with errors */
#define JET_errMissingLogFile				-528  /* current log file missing */
#define JET_errLogDiskFull					-529  /* log disk full */
#define JET_errBadLogSignature				-530  /* bad signature for a log file */
#define JET_errBadDbSignature				-531  /* bad signature for a db file */
#define JET_errBadCheckpointSignature		-532  /* bad signature for a checkpoint file */
#define	JET_errCheckpointCorrupt			-533  /* checkpoint file not found or corrupt */
#define	JET_errMissingPatchPage				-534  /* patch file page not found during recovery */


#define JET_errDatabaseInconsistent			-550  /* database is in inconsistent state */
#define JET_errConsistentTimeMismatch		-551  /* database last consistent time unmatched */
#define JET_errDatabasePatchFileMismatch	-552  /* patch file is not generated from this backup */
#define JET_errEndingRestoreLogTooLow		-553  /* the starting log number too low for the restore */
#define JET_errStartingRestoreLogTooHigh	-554  /* the starting log number too high for the restore */
#define JET_errGivenLogFileHasBadSignature	-555  /* Restore log file has bad signature */
#define JET_errGivenLogFileIsNotContiguous	-556  /* Restore log file is not contiguous */
#define JET_errMissingRestoreLogFiles		-557  /* Some restore log files are missing */
#define JET_wrnExistingLogFileHasBadSignature	558  /* Existing log file has bad signature */
#define JET_wrnExistingLogFileIsNotContiguous	559  /* Existing log file is not contiguous */
#define JET_errMissingFullBackup			-560  /* The database miss a previous full backup befor incremental backup */
#define JET_errBadBackupDatabaseSize		-561  /* The backup database size is not in 4k */
#define JET_errDatabaseAlreadyUpgraded		-562  /* Attempted to upgrade a database that is already current */

#define JET_errTermInProgress		  		-1000 /* Termination in progress */
#define JET_errFeatureNotAvailable			-1001 /* API not supported */
#define JET_errInvalidName					-1002 /* Invalid name */
#define JET_errInvalidParameter 			-1003 /* Invalid API parameter */
#define JET_wrnColumnNull					 1004 /* Column is NULL-valued */
#define JET_wrnBufferTruncated				 1006 /* Buffer too small for data */
#define JET_wrnDatabaseAttached 			 1007 /* Database is already attached */
#define JET_errDatabaseFileReadOnly			-1008 /* Attach a readonly database file for read/write operations */
#define JET_wrnSortOverflow					 1009 /* Sort does not fit in memory */
#define JET_errInvalidDatabaseId			-1010 /* Invalid database id */
#define JET_errOutOfMemory					-1011 /* Out of Memory */
#define JET_errOutOfDatabaseSpace 			-1012 /* Maximum database size reached */
#define JET_errOutOfCursors					-1013 /* Out of table cursors */
#define JET_errOutOfBuffers					-1014 /* Out of database page buffers */
#define JET_errTooManyIndexes				-1015 /* Too many indexes */
#define JET_errTooManyKeys					-1016 /* Too many columns in an index */
#define JET_errRecordDeleted				-1017 /* Record has been deleted */
#define JET_errReadVerifyFailure			-1018 /* Read verification error */
#define JET_errOutOfFileHandles	 			-1020 /* Out of file handles */
#define JET_errDiskIO						-1022 /* Disk IO error */
#define JET_errInvalidPath					-1023 /* Invalid file path */
#define JET_errRecordTooBig					-1026 /* Record larger than maximum size */
#define JET_errTooManyOpenDatabases			-1027 /* Too many open databases */
#define JET_errInvalidDatabase				-1028 /* Not a database file */
#define JET_errNotInitialized				-1029 /* JetInit not yet called */
#define JET_errAlreadyInitialized			-1030 /* JetInit already called */
#define JET_errFileAccessDenied 			-1032 /* Cannot access file */
#define JET_errQueryNotSupported			-1034 /* Query support unavailable */
#define JET_errSQLLinkNotSupported			-1035 /* SQL Link support unavailable */
#define JET_errBufferTooSmall				-1038 /* Buffer is too small */
#define JET_wrnSeekNotEqual					 1039 /* SeekLE or SeekGE didn't find exact match */
#define JET_errTooManyColumns				-1040 /* Too many columns defined */
#define JET_errContainerNotEmpty			-1043 /* Container is not empty */
#define JET_errInvalidFilename				-1044 /* Filename is invalid */
#define JET_errInvalidBookmark				-1045 /* Invalid bookmark */
#define JET_errColumnInUse					-1046 /* Column used in an index */
#define JET_errInvalidBufferSize			-1047 /* Data buffer doesn't match column size */
#define JET_errColumnNotUpdatable			-1048 /* Cannot set column value */
#define JET_errIndexInUse					-1051 /* Index is in use */
#define JET_errLinkNotSupported 			-1052 /* Link support unavailable */
#define JET_errNullKeyDisallowed			-1053 /* Null keys are disallowed on index */
#define JET_errNotInTransaction 			-1054 /* Operation must be within a transaction */
#define JET_wrnNoErrorInfo					1055  /* No extended error information */
#define JET_wrnNoIdleActivity		 		1058  /* No idle activity occured */
#define JET_errTooManyActiveUsers			-1059 /* Too many active database users */
#define JET_errInvalidAppend				-1060 /* Cannot append long value */
#define JET_errInvalidCountry				-1061 /* Invalid or unknown country code */
#define JET_errInvalidLanguageId			-1062 /* Invalid or unknown language id */
#define JET_errInvalidCodePage				-1063 /* Invalid or unknown code page */
#define JET_wrnNoWriteLock					1067  /* No write lock at transaction level 0 */
#define JET_wrnColumnSetNull		   		 1068 /* Column set to NULL-value */
#define JET_errVersionStoreOutOfMemory		-1069 /* lMaxVerPages exceeded (XJET only) */
#define JET_errCurrencyStackOutOfMemory		-1070 /* lCSRPerfFUCB * lMaxCursors exceeded (XJET only) */
#define JET_errOutOfSessions  				-1101 /* Out of sessions */
#define JET_errWriteConflict				-1102 /* Write lock failed due to outstanding write lock */
#define JET_errTransTooDeep					-1103 /* Xactions nested too deeply */
#define JET_errInvalidSesid					-1104 /* Invalid session handle */
#define JET_errSessionWriteConflict			-1107 /* Another session has private version of page */
#define JET_errInTransaction				-1108 /* Operation not allowed within a transaction */
#define JET_errDatabaseDuplicate			-1201 /* Database already exists */
#define JET_errDatabaseInUse				-1202 /* Database in use */
#define JET_errDatabaseNotFound 			-1203 /* No such database */
#define JET_errDatabaseInvalidName			-1204 /* Invalid database name */
#define JET_errDatabaseInvalidPages			-1205 /* Invalid number of pages */
#define JET_errDatabaseCorrupted			-1206 /* non-db file or corrupted db */
#define JET_errDatabaseLocked				-1207 /* Database exclusively locked */
#define	JET_errCannotDisableVersioning		-1208 /* Cannot disable versioning for this database */
#define JET_wrnTableEmpty			 		1301  /* Open an empty table */
#define JET_errTableLocked					-1302 /* Table is exclusively locked */
#define JET_errTableDuplicate				-1303 /* Table already exists */
#define JET_errTableInUse					-1304 /* Table is in use, cannot lock */
#define JET_errObjectNotFound				-1305 /* No such table or object */
#define JET_errDensityInvalid				-1307 /* Bad file/index density */
#define JET_errTableNotEmpty				-1308 /* Cannot define clustered index */
#define JET_errInvalidTableId				-1310 /* Invalid table id */
#define JET_errTooManyOpenTables			-1311 /* Cannot open any more tables */
#define JET_errIllegalOperation 			-1312 /* Oper. not supported on table */
#define JET_errObjectDuplicate				-1314 /* Table or object name in use */
#define JET_errInvalidObject				-1316 /* object is invalid for operation */
#define JET_errIndexCantBuild				-1401 /* Cannot build clustered index */
#define JET_errIndexHasPrimary				-1402 /* Primary index already defined */
#define JET_errIndexDuplicate				-1403 /* Index is already defined */
#define JET_errIndexNotFound				-1404 /* No such index */
#define JET_errIndexMustStay				-1405 /* Cannot delete clustered index */
#define JET_errIndexInvalidDef				-1406 /* Illegal index definition */
#define JET_errIndexHasClustered			-1408 /* Clustered index already defined */
#define JET_errInvalidCreateIndex	 		-1409 /* Invali create index description */
#define JET_errTooManyOpenIndexes			-1410 /* Out of index description blocks */
#define JET_errColumnLong					-1501 /* Column value is long */
#define JET_errColumnNoChunk				-1502 /* no such chunk in long value */
#define JET_errColumnDoesNotFit 			-1503 /* Field will not fit in record */
#define JET_errNullInvalid					-1504 /* Null not valid */
#define JET_errColumnIndexed				-1505 /* Column indexed, cannot delete */
#define JET_errColumnTooBig					-1506 /* Field length is > maximum */
#define JET_errColumnNotFound				-1507 /* No such column */
#define JET_errColumnDuplicate				-1508 /* Field is already defined */
#define JET_errColumn2ndSysMaint			-1510 /* Second autoinc or version column */
#define JET_errInvalidColumnType			-1511 /* Invalid column data type */
#define JET_wrnColumnMaxTruncated	 		1512  /* Max length too big, truncated */
#define JET_errColumnCannotIndex			-1513 /* Cannot index Bit,LongText,LongBinary */
#define JET_errTaggedNotNULL				-1514 /* No non-NULL tagged columns */
#define JET_errNoCurrentIndex				-1515 /* Invalid w/o a current index */
#define JET_errKeyIsMade					-1516 /* The key is completely made */
#define JET_errBadColumnId					-1517 /* Column Id Incorrect */
#define JET_errBadItagSequence				-1518 /* Bad itagSequence for tagged column */
#define JET_errColumnInRelationship			-1519 /* Cannot delete, column participates in relationship */
#define JET_wrnCopyLongValue				1520  /* Single instance column bursted */
#define JET_errCannotBeTagged				-1521 /* AutoIncrement and Version cannot be tagged */
#define JET_errRecordNotFound				-1601 /* The key was not found */
#define JET_errRecordNoCopy					-1602 /* No working buffer */
#define JET_errNoCurrentRecord				-1603 /* Currency not on a record */
#define JET_errRecordClusteredChanged		-1604 /* Clustered key may not change */
#define JET_errKeyDuplicate					-1605 /* Illegal duplicate key */
#define JET_errAlreadyPrepared				-1607 /* Already copy/clear current */
#define JET_errKeyNotMade					-1608 /* No call to JetMakeKey */
#define JET_errUpdateNotPrepared			-1609 /* No call to JetPrepareUpdate */
#define JET_wrnDataHasChanged		 		1610  /* Data has changed */
#define JET_errDataHasChanged				-1611 /* Data has changed, operation aborted */
#define JET_wrnKeyChanged			 		1618  /* Moved to new key */
#define JET_errTooManySorts					-1701 /* Too many sort processes */
#define JET_errInvalidOnSort				-1702 /* Invalid operation on Sort */
#define JET_errTempFileOpenError			-1803 /* Temp file could not be opened */
#define JET_errTooManyAttachedDatabases 	-1805 /* Too many open databases */
#define JET_errDiskFull 					-1808 /* No space left on disk */
#define JET_errPermissionDenied 			-1809 /* Permission denied */
#define JET_errFileNotFound					-1811 /* File not found */
#define JET_wrnFileOpenReadOnly				1813  /* Database file is read only */
#define JET_errAfterInitialization			-1850 /* Cannot Restore after init. */
#define JET_errLogCorrupted					-1852 /* Logs could not be interpreted */
#define JET_errInvalidOperation 			-1906 /* invalid operation */
#define JET_errAccessDenied					-1907 /* access denied */
#define JET_wrnIdleFull						 1908 /* ilde registry full */


/**********************************************************************/
/***********************     PROTOTYPES      **************************/
/**********************************************************************/

#if !defined(_JET_NOPROTOTYPES)

JET_ERR JET_API JetInit(JET_INSTANCE *pinstance);

JET_ERR JET_API JetTerm(JET_INSTANCE instance);

JET_ERR JET_API JetTerm2( JET_INSTANCE instance, JET_GRBIT grbit );

JET_ERR JET_API JetSetSystemParameter(JET_INSTANCE *pinstance, JET_SESID sesid, unsigned long paramid,
	ULONG_PTR lParam, const char *sz);

JET_ERR JET_API JetGetSystemParameter(JET_INSTANCE instance, JET_SESID sesid, unsigned long paramid,
	ULONG_PTR *plParam, char *sz, unsigned long cbMax);

#define ctAccessPage			1
#define ctLatchConflict			2
#define ctSplitRetry			3
#define ctNeighborPageScanned	4
#define ctSplits				5
JET_ERR JET_API JetResetCounter( JET_SESID sesid, long CounterType );
JET_ERR JET_API JetGetCounter( JET_SESID sesid, long CounterType, long *plValue );

JET_ERR JET_API JetBeginSession(JET_INSTANCE instance, JET_SESID *psesid,
	const char *szUserName, const char *szPassword);

JET_ERR JET_API JetDupSession(JET_SESID sesid, JET_SESID *psesid);

JET_ERR JET_API JetEndSession(JET_SESID sesid, JET_GRBIT grbit);

JET_ERR JET_API JetGetVersion(JET_SESID sesid, unsigned long *pwVersion);

JET_ERR JET_API JetIdle(JET_SESID sesid, JET_GRBIT grbit);

JET_ERR JET_API JetCreateDatabase(JET_SESID sesid,
	const char *szFilename, const char *szConnect,
	JET_DBID *pdbid, JET_GRBIT grbit);

JET_ERR JET_API JetAttachDatabase(JET_SESID sesid, const char *szFilename, JET_GRBIT grbit );

JET_ERR JET_API JetDetachDatabase(JET_SESID sesid, const char *szFilename);

JET_ERR JET_API JetCreateTable(JET_SESID sesid, JET_DBID dbid,
	const char *szTableName, unsigned long lPages, unsigned long lDensity,
	JET_TABLEID *ptableid);

JET_ERR JET_API JetCreateTableColumnIndex( JET_SESID sesid, JET_DBID dbid,
	JET_TABLECREATE *ptablecreate );

JET_ERR JET_API JetDeleteTable(JET_SESID sesid, JET_DBID dbid,
	const char *szTableName);

JET_ERR JET_API JetGetTableColumnInfo(JET_SESID sesid, JET_TABLEID tableid,
	const char *szColumnName, void *pvResult, unsigned long cbMax,
	unsigned long InfoLevel);

JET_ERR JET_API JetGetColumnInfo(JET_SESID sesid, JET_DBID dbid,
	const char *szTableName, const char *szColumnName,
	void *pvResult, unsigned long cbMax, unsigned long InfoLevel);

JET_ERR JET_API JetAddColumn(JET_SESID sesid, JET_TABLEID tableid,
	const char *szColumn, const JET_COLUMNDEF *pcolumndef,
	const void *pvDefault, unsigned long cbDefault,
	JET_COLUMNID *pcolumnid);

JET_ERR JET_API JetDeleteColumn(JET_SESID sesid, JET_TABLEID tableid,
	const char *szColumn);

JET_ERR JET_API JetGetTableIndexInfo(JET_SESID sesid, JET_TABLEID tableid,
	const char *szIndexName, void *pvResult, unsigned long cbResult,
	unsigned long InfoLevel);

JET_ERR JET_API JetGetTableInfo(JET_SESID sesid, JET_TABLEID tableid,
	void *pvResult, unsigned long cbMax, unsigned long InfoLevel);

JET_ERR JET_API JetGetIndexInfo(JET_SESID sesid, JET_DBID dbid,
	const char *szTableName, const char *szIndexName,
	void *pvResult, unsigned long cbResult, unsigned long InfoLevel);

JET_ERR JET_API JetCreateIndex(JET_SESID sesid, JET_TABLEID tableid,
	const char *szIndexName, JET_GRBIT grbit,
	const char *szKey, unsigned long cbKey, unsigned long lDensity);

JET_ERR JET_API JetDeleteIndex(JET_SESID sesid, JET_TABLEID tableid,
	const char *szIndexName);

JET_ERR JET_API JetGetObjectInfo(JET_SESID sesid, JET_DBID dbid,
	JET_OBJTYP objtyp, const char *szContainerName,
	const char *szObjectName, void *pvResult, unsigned long cbMax,
	unsigned long InfoLevel);

JET_ERR JET_API JetBeginTransaction(JET_SESID sesid);

JET_ERR JET_API JetCommitTransaction(JET_SESID sesid, JET_GRBIT grbit);

JET_ERR JET_API JetRollback(JET_SESID sesid, JET_GRBIT grbit);

JET_ERR JET_API JetGetDatabaseInfo(JET_SESID sesid, JET_DBID dbid,
	void *pvResult, unsigned long cbMax, unsigned long InfoLevel);

JET_ERR JET_API JetCloseDatabase(JET_SESID sesid, JET_DBID dbid,
	JET_GRBIT grbit);

JET_ERR JET_API JetCloseTable(JET_SESID sesid, JET_TABLEID tableid);

JET_ERR JET_API JetOpenDatabase(JET_SESID sesid, const char *szFilename,
	const char *szConnect, JET_DBID *pdbid, JET_GRBIT grbit);

JET_ERR JET_API JetOpenTable(JET_SESID sesid, JET_DBID dbid,
	const char *szTableName, const void *pvParameters,
	unsigned long cbParameters, JET_GRBIT grbit, JET_TABLEID *ptableid);

JET_ERR JET_API JetDelete(JET_SESID sesid, JET_TABLEID tableid);

JET_ERR JET_API JetUpdate(JET_SESID sesid, JET_TABLEID tableid,
	void *pvBookmark, unsigned long cbBookmark,
	unsigned long *pcbActual);

JET_ERR JET_API JetRetrieveColumn(JET_SESID sesid, JET_TABLEID tableid,
	JET_COLUMNID columnid, void *pvData, unsigned long cbData,
	unsigned long *pcbActual, JET_GRBIT grbit, JET_RETINFO *pretinfo);

JET_ERR JET_API JetRetrieveColumns( JET_SESID sesid, JET_TABLEID tableid,
	JET_RETRIEVECOLUMN *pretrievecolumn, unsigned long cretrievecolumn );

JET_ERR JET_API JetSetColumn(JET_SESID sesid, JET_TABLEID tableid,
	JET_COLUMNID columnid, const void *pvData, unsigned long cbData,
	JET_GRBIT grbit, JET_SETINFO *psetinfo);

JET_ERR JET_API JetSetColumns(JET_SESID sesid, JET_TABLEID tableid,
	JET_SETCOLUMN *psetcolumn, unsigned long csetcolumn );

JET_ERR JET_API JetPrepareUpdate(JET_SESID sesid, JET_TABLEID tableid,
	unsigned long prep);

JET_ERR JET_API JetGetRecordPosition(JET_SESID sesid, JET_TABLEID tableid,
	JET_RECPOS *precpos, unsigned long cbRecpos);

JET_ERR JET_API JetGotoPosition(JET_SESID sesid, JET_TABLEID tableid,
	JET_RECPOS *precpos );

JET_ERR JET_API JetGetCursorInfo(JET_SESID sesid, JET_TABLEID tableid,
	void *pvResult, unsigned long cbMax, unsigned long InfoLevel);

JET_ERR JET_API JetDupCursor(JET_SESID sesid, JET_TABLEID tableid,
	JET_TABLEID *ptableid, JET_GRBIT grbit);

JET_ERR JET_API JetGetCurrentIndex(JET_SESID sesid, JET_TABLEID tableid,
	char *szIndexName, unsigned long cchIndexName);

JET_ERR JET_API JetSetCurrentIndex(JET_SESID sesid, JET_TABLEID tableid,
	const char *szIndexName);

JET_ERR JET_API JetSetCurrentIndex2(JET_SESID sesid, JET_TABLEID tableid,
	const char *szIndexName, JET_GRBIT grbit );

JET_ERR JET_API JetMove(JET_SESID sesid, JET_TABLEID tableid,
	long cRow, JET_GRBIT grbit);

JET_ERR JET_API JetMakeKey(JET_SESID sesid, JET_TABLEID tableid,
	const void *pvData, unsigned long cbData, JET_GRBIT grbit);

JET_ERR JET_API JetSeek(JET_SESID sesid, JET_TABLEID tableid,
	JET_GRBIT grbit);

JET_ERR JET_API JetGetBookmark(JET_SESID sesid, JET_TABLEID tableid,
	void *pvBookmark, unsigned long cbMax,
	unsigned long *pcbActual);
	
JET_ERR JET_API JetCompact(JET_SESID sesid, const char *szDatabaseSrc,
	const char *szDatabaseDest, JET_PFNSTATUS pfnStatus, JET_CONVERT *pconvert,
	JET_GRBIT grbit);

JET_ERR JET_API JetDBUtilities( JET_DBUTIL *pdbutil );	

JET_ERR JET_API JetGotoBookmark(JET_SESID sesid, JET_TABLEID tableid,
	void *pvBookmark, unsigned long cbBookmark);

JET_ERR JET_API JetComputeStats(JET_SESID sesid, JET_TABLEID tableid);

typedef ULONG_PTR JET_VSESID;          /* Received from dispatcher */

struct tagVDBFNDEF;

typedef ULONG_PTR JET_VDBID;           /* Received from dispatcher */

struct tagVTFNDEF;

typedef ULONG_PTR JET_VTID;            /* Received from dispatcher */

JET_ERR JET_API JetOpenTempTable(JET_SESID sesid,
	const JET_COLUMNDEF *prgcolumndef, unsigned long ccolumn,
	JET_GRBIT grbit, JET_TABLEID *ptableid,
	JET_COLUMNID *prgcolumnid);

JET_ERR JET_API JetOpenTempTable2( JET_SESID sesid,
	const JET_COLUMNDEF *prgcolumndef,
	unsigned long ccolumn,
	unsigned long langid,
	JET_GRBIT grbit,
	JET_TABLEID *ptableid,
	JET_COLUMNID *prgcolumnid );

JET_ERR JET_API JetBackup( const char *szBackupPath, JET_GRBIT grbit, JET_PFNSTATUS pfnStatus );

JET_ERR JET_API JetRestore(const char *sz, JET_PFNSTATUS pfn );
JET_ERR JET_API JetRestore2(const char *sz, const char *szDest, JET_PFNSTATUS pfn );

JET_ERR JET_API JetSetIndexRange(JET_SESID sesid,
	JET_TABLEID tableidSrc, JET_GRBIT grbit);

JET_ERR JET_API JetIndexRecordCount(JET_SESID sesid,
	JET_TABLEID tableid, unsigned long *pcrec, unsigned long crecMax );

JET_ERR JET_API JetRetrieveKey(JET_SESID sesid,
	JET_TABLEID tableid, void *pvData, unsigned long cbMax,
	unsigned long *pcbActual, JET_GRBIT grbit );

JET_ERR JET_API JetBeginExternalBackup( JET_GRBIT grbit );

JET_ERR JET_API JetGetAttachInfo( void *pv,
	unsigned long cbMax,
	unsigned long *pcbActual );

JET_ERR JET_API JetOpenFile( const char *szFileName,
	JET_HANDLE	*phfFile,
	unsigned long *pulFileSizeLow,
	unsigned long *pulFileSizeHigh );

JET_ERR JET_API JetReadFile( JET_HANDLE hfFile,
	void *pv,
	unsigned long cb,
	unsigned long *pcb );

JET_ERR JET_API JetCloseFile( JET_HANDLE hfFile );

JET_ERR JET_API JetGetLogInfo( void *pv,
	unsigned long cbMax,
	unsigned long *pcbActual );

JET_ERR JET_API JetTruncateLog( void );

JET_ERR JET_API JetEndExternalBackup( void );

JET_ERR JET_API JetExternalRestore( char *szCheckpointFilePath, char *szLogPath, JET_RSTMAP *rgstmap, long crstfilemap, char *szBackupLogPath, long genLow, long genHigh, JET_PFNSTATUS pfn );

#endif	/* _JET_NOPROTOTYPES */

#pragma pack()

#ifdef	__cplusplus
}
#endif

#endif	/* _JET_INCLUDED */




=== C:/Users/treeman/Desktop/windows nt source code\Source\Win2K3\NT\public\internal\ds\inc\llsapi.h ===
/*++

Copyright (c) 1994-95  Microsoft Corporation

Module Name:

   llsapi.h

Abstract:

   License logging server's RPC API's.

Author:

   Arthur Hanson (arth) 21-Mar-1995

Environment:

   User Mode - Win32

Revision History:

   Jeff Parham (jeffparh) 04-Dec-1995
      o  Added type definitions, macros, and prototypes for extended RPC APIs
         and license certificate APIs (available only post-3.51).
      o  Corrected prototypes for LlsServerEnumW(), LlsServerEnumA(),
         LlsLocalProductInfoGetW(), and LlsLocalProductInfoGetA().

--*/

#ifndef _LLSAPI_H
#define _LLSAPI_H

#ifdef __cplusplus
extern "C" {
#endif


#define LLS_FLAG_LICENSED           0x0001
#define LLS_FLAG_UPDATE             0x0002
#define LLS_FLAG_SUITE_USE          0x0004
#define LLS_FLAG_SUITE_AUTO         0x0008

#define LLS_FLAG_PRODUCT_PERSEAT    0x0010
#define LLS_FLAG_PRODUCT_SWITCH     0x0020

#define LLS_FLAG_DELETED            0x1000


typedef PVOID LLS_HANDLE, *PLLS_HANDLE;
typedef PVOID LLS_REPL_HANDLE, *PLLS_REPL_HANDLE;

#define LLS_INVALID_LICENSE_HANDLE  ( 0xFFFFFFFF )

#define LLS_NUM_SECRETS             ( 4 )

typedef struct _LLS_LICENSE_INFO_0 {
   LPTSTR Product;
   LONG   Quantity;
   DWORD  Date;
   LPTSTR Admin;
   LPTSTR Comment;
} LLS_LICENSE_INFO_0, *PLLS_LICENSE_INFO_0;

typedef struct _LLS_LICENSE_INFO_1 {
   LPTSTR Product;
   LPTSTR Vendor;
   LONG   Quantity;
   DWORD  MaxQuantity;
   DWORD  Date;
   LPTSTR Admin;
   LPTSTR Comment;
   DWORD  AllowedModes;
   DWORD  CertificateID;
   LPTSTR Source;
   DWORD  ExpirationDate;
   DWORD  Secrets[ LLS_NUM_SECRETS ];
} LLS_LICENSE_INFO_1, *PLLS_LICENSE_INFO_1;

typedef struct _LLS_PRODUCT_INFO_0 {
   LPTSTR Product;
} LLS_PRODUCT_INFO_0, *PLLS_PRODUCT_INFO_0;

typedef struct _LLS_PRODUCT_INFO_1 {
   LPTSTR Product;
   ULONG  Purchased;
   ULONG  InUse;
   ULONG  ConcurrentTotal;
   ULONG  HighMark;
} LLS_PRODUCT_INFO_1, *PLLS_PRODUCT_INFO_1;

typedef struct _LLS_PRODUCT_USER_INFO_0 {
   LPTSTR User;
} LLS_PRODUCT_USER_INFO_0, *PLLS_PRODUCT_USER_INFO_0;

typedef struct _LLS_PRODUCT_USER_INFO_1 {
   LPTSTR User;
   DWORD  Flags;
   DWORD  LastUsed;
   ULONG  UsageCount;
} LLS_PRODUCT_USER_INFO_1, *PLLS_PRODUCT_USER_INFO_1;


typedef struct _LLS_PRODUCT_LICENSE_INFO_0 {
   LONG   Quantity;
   DWORD  Date;
   LPTSTR Admin;
   LPTSTR Comment;
} LLS_PRODUCT_LICENSE_INFO_0, *PLLS_PRODUCT_LICENSE_INFO_0;

typedef struct _LLS_PRODUCT_LICENSE_INFO_1 {
   LONG   Quantity;
   DWORD  MaxQuantity;
   DWORD  Date;
   LPTSTR Admin;
   LPTSTR Comment;
   DWORD  AllowedModes;
   DWORD  CertificateID;
   LPTSTR Source;
   DWORD  ExpirationDate;
   DWORD  Secrets[ LLS_NUM_SECRETS ];
} LLS_PRODUCT_LICENSE_INFO_1, *PLLS_PRODUCT_LICENSE_INFO_1;

typedef struct _LLS_USER_INFO_0 {
   LPTSTR Name;
} LLS_USER_INFO_0, *PLLS_USER_INFO_0;

typedef struct _LLS_USER_INFO_1 {
   LPTSTR Name;
   DWORD  Flags;
   LPTSTR Group;
   ULONG  Licensed;
   ULONG  UnLicensed;
} LLS_USER_INFO_1, *PLLS_USER_INFO_1;

typedef struct _LLS_USER_INFO_2 {
   LPTSTR Name;
   DWORD  Flags;
   LPTSTR Group;
   ULONG  Licensed;
   ULONG  UnLicensed;
   LPTSTR Products;
} LLS_USER_INFO_2, *PLLS_USER_INFO_2;

typedef struct _LLS_USER_PRODUCT_INFO_0 {
   LPTSTR Product;
} LLS_USER_PRODUCT_INFO_0, *PLLS_USER_PRODUCT_INFO_0;

typedef struct _LLS_USER_PRODUCT_INFO_1 {
   LPTSTR Product;
   DWORD  Flags;
   DWORD  LastUsed;
   ULONG  UsageCount;
} LLS_USER_PRODUCT_INFO_1, *PLLS_USER_PRODUCT_INFO_1;

typedef struct _LLS_GROUP_INFO_0 {
   LPTSTR Name;
} LLS_GROUP_INFO_0, *PLLS_GROUP_INFO_0;

typedef struct _LLS_GROUP_INFO_1 {
   LPTSTR Name;
   LPTSTR Comment;
   ULONG  Licenses;
} LLS_GROUP_INFO_1, *PLLS_GROUP_INFO_1;


#define LLS_REPLICATION_TYPE_DELTA  0
#define LLS_REPLICATION_TYPE_TIME   1

#define LLS_MODE_LICENSE_SERVER     0
#define LLS_MODE_PDC                1
#define LLS_MODE_ENTERPRISE_SERVER  2

typedef struct _LLS_SERVICE_INFO_0 {
   DWORD Version;
   DWORD TimeStarted;
   DWORD Mode;
   LPTSTR ReplicateTo;
   LPTSTR EnterpriseServer;
   DWORD ReplicationType;
   DWORD ReplicationTime;
   DWORD UseEnterprise;
   DWORD LastReplicated;
} LLS_SERVICE_INFO_0, *PLLS_SERVICE_INFO_0;

typedef struct _LLS_CONNECT_INFO_0 {
   LPTSTR Domain;
   LPTSTR EnterpriseServer;
} LLS_CONNECT_INFO_0, *PLLS_CONNECT_INFO_0;


typedef struct _LLS_SERVER_PRODUCT_INFO_0 {
   LPTSTR Name;
} LLS_SERVER_PRODUCT_INFO_0, *PLLS_SERVER_PRODUCT_INFO_0;

typedef struct _LLS_SERVER_PRODUCT_INFO_1 {
   LPTSTR Name;
   DWORD Flags;
   ULONG MaxUses;
   ULONG MaxSetUses;
   ULONG HighMark;
} LLS_SERVER_PRODUCT_INFO_1, *PLLS_SERVER_PRODUCT_INFO_1;


typedef struct _LLS_SERVER_INFO_0 {
   LPTSTR Name;
} LLS_SERVER_INFO_0, *PLLS_SERVER_INFO_0;

typedef struct _LLS_CERTIFICATE_CLAIM_INFO_0
{
   TCHAR    ServerName[ 1 + MAX_COMPUTERNAME_LENGTH ];
   LONG     Quantity;
} LLS_CERTIFICATE_CLAIM_INFO_0, *PLLS_CERTIFICATE_CLAIM_INFO_0;

typedef struct _LLS_LOCAL_SERVICE_INFO_0
{
   LPTSTR   KeyName;
   LPTSTR   DisplayName;
   LPTSTR   FamilyDisplayName;
   DWORD    Mode;
   DWORD    FlipAllow;
   DWORD    ConcurrentLimit;
   DWORD    HighMark;
} LLS_LOCAL_SERVICE_INFO_0, *PLLS_LOCAL_SERVICE_INFO_0;

#define LLS_LICENSE_MODE_PER_SEAT            ( 0 )
#define LLS_LICENSE_MODE_PER_SERVER          ( 1 )

#define LLS_LICENSE_MODE_ALLOW_PER_SEAT      ( 1 )
#define LLS_LICENSE_MODE_ALLOW_PER_SERVER    ( 2 )

#define LLS_LICENSE_FLIP_ALLOW_PER_SEAT      ( 1 )
#define LLS_LICENSE_FLIP_ALLOW_PER_SERVER    ( 2 )


// capability flags; query with LlsCapabilityIsSupported
#define LLS_CAPABILITY_SECURE_CERTIFICATES         (  0 )
#define LLS_CAPABILITY_REPLICATE_CERT_DB           (  1 )
#define LLS_CAPABILITY_REPLICATE_PRODUCT_SECURITY  (  2 )
#define LLS_CAPABILITY_REPLICATE_USERS_EX          (  3 )
#define LLS_CAPABILITY_SERVICE_INFO_GETW           (  4 )
#define LLS_CAPABILITY_LOCAL_SERVICE_API           (  5 )
#define LLS_CAPABILITY_MAX                         ( 32 )


//***************************************************
//* Nt LS API data constants
//* (for use with LlsLicenseRequest() API)
//***************************************************

#define NT_LS_USER_NAME               ((ULONG) 0)  // username only
#define NT_LS_USER_SID                ((ULONG) 1)  // SID only


#ifndef NO_LLS_APIS
//
// Connection control API's
//

NTSTATUS
NTAPI
LlsConnectW(
   IN  LPWSTR Server,
   OUT PLLS_HANDLE Handle
   );

NTSTATUS
NTAPI
LlsConnectA(
   IN  LPSTR Server,
   OUT PLLS_HANDLE Handle
   );
#ifdef UNICODE
#  define LlsConnect LlsConnectW
#else
#  define LlsConnect LlsConnectA
#endif

typedef NTSTATUS (NTAPI *PLLS_CONNECT_W)( LPWSTR, PLLS_HANDLE );
typedef NTSTATUS (NTAPI *PLLS_CONNECT_A)( LPSTR,  PLLS_HANDLE );

NTSTATUS
NTAPI
LlsConnectEnterpriseW(
   IN  LPWSTR Focus,
   OUT PLLS_HANDLE Handle,
   IN  DWORD Level,
   OUT LPBYTE *bufptr
   );

NTSTATUS
NTAPI
LlsConnectEnterpriseA(
   IN  LPSTR Focus,
   OUT PLLS_HANDLE Handle,
   IN  DWORD Level,
   OUT LPBYTE *bufptr
   );
#ifdef UNICODE
#define LlsConnectEnterprise LlsConnectEnterpriseW
#else
#define LlsConnectEnterprise LlsConnectEnterpriseA
#endif

typedef NTSTATUS (NTAPI *PLLS_CONNECT_ENTERPRISE_W)( LPWSTR, PLLS_HANDLE, DWORD, LPBYTE * );
typedef NTSTATUS (NTAPI *PLLS_CONNECT_ENTERPRISE_A)( LPSTR,  PLLS_HANDLE, DWORD, LPBYTE * );

NTSTATUS 
NTAPI
LlsClose(        
   IN LLS_HANDLE Handle
   );

typedef NTSTATUS (NTAPI *PLLS_CLOSE)( LLS_HANDLE );

NTSTATUS 
NTAPI
LlsFreeMemory(
    IN PVOID bufptr
    );

typedef NTSTATUS (NTAPI *PLLS_FREE_MEMORY)( PVOID );

NTSTATUS
NTAPI
LlsEnterpriseServerFindW(
   IN  LPWSTR Focus,
   IN  DWORD Level,
   OUT LPBYTE *bufptr
   );

NTSTATUS
NTAPI
LlsEnterpriseServerFindA(
   IN  LPSTR Focus,
   IN  DWORD Level,
   OUT LPBYTE *bufptr
   );
#ifdef UNICODE
#define LlsEnterpriseServerFind LlsEnterpriseServerFindW
#else
#define LlsEnterpriseServerFind LlsEnterpriseServerFindA
#endif

//
// License control API's
//

// Enum purchase history of licenses for all products.
NTSTATUS
NTAPI
LlsLicenseEnumW(
   IN     LLS_HANDLE Handle,
   IN     DWORD      Level,     // Level 0 supported
   OUT    LPBYTE*    bufptr,    
   IN     DWORD      prefmaxlen,
   OUT    LPDWORD    EntriesRead,
   OUT    LPDWORD    TotalEntries,
   IN OUT LPDWORD    ResumeHandle
   );

NTSTATUS
NTAPI
LlsLicenseEnumA(
   IN     LLS_HANDLE Handle,
   IN     DWORD      Level,     // Level 0 supported
   OUT    LPBYTE*    bufptr,    
   IN     DWORD      prefmaxlen,
   OUT    LPDWORD    EntriesRead,
   OUT    LPDWORD    TotalEntries,
   IN OUT LPDWORD    ResumeHandle
   );
#ifdef UNICODE
#define LlsLicenseEnum LlsLicenseEnumW
#else
#define LlsLicenseEnum LlsLicenseEnumA
#endif

// Add purchase of license for a product.
NTSTATUS
NTAPI
LlsLicenseAddW(
   IN LLS_HANDLE Handle,
   IN DWORD      Level,         // Level 0 supported
   IN LPBYTE     bufptr
   );

NTSTATUS
NTAPI
LlsLicenseAddA(
   IN LLS_HANDLE Handle,
   IN DWORD      Level,         // Level 0 supported
   IN LPBYTE     bufptr
   );
#ifdef UNICODE
#define LlsLicenseAdd LlsLicenseAddW
#else
#define LlsLicenseAdd LlsLicenseAddA
#endif

typedef NTSTATUS (NTAPI *PLLS_LICENSE_ADD_W)( LLS_HANDLE, DWORD, LPBYTE );
typedef NTSTATUS (NTAPI *PLLS_LICENSE_ADD_A)( LLS_HANDLE, DWORD, LPBYTE );

//
// Product control API's
//
// Product is SQL, BackOffice, Exchange, Etc. (Even though BackOffice isn't
// a product - we count it like one to keep things simplistic.
//

// Enum all products with purchase and InUse info.
NTSTATUS
NTAPI
LlsProductEnumW(
   IN     LLS_HANDLE Handle,
   IN     DWORD      Level,     // Levels 0,1 supported
   OUT    LPBYTE*    bufptr,
   IN     DWORD      prefmaxlen,
   OUT    LPDWORD    EntriesRead,
   OUT    LPDWORD    TotalEntries,
   IN OUT LPDWORD    ResumeHandle
   );

NTSTATUS
NTAPI
LlsProductEnumA(
   IN     LLS_HANDLE Handle,
   IN     DWORD      Level,     // Levels 0,1 supported
   OUT    LPBYTE*    bufptr,
   IN     DWORD      prefmaxlen,
   OUT    LPDWORD    EntriesRead,
   OUT    LPDWORD    TotalEntries,
   IN OUT LPDWORD    ResumeHandle
   );
#ifdef UNICODE
#define LlsProductEnum LlsProductEnumW
#else
#define LlsProductEnum LlsProductEnumA
#endif

// Add purchase of license for a product.
NTSTATUS
NTAPI
LlsProductAddW(
   IN LLS_HANDLE Handle,
   IN LPWSTR ProductFamily,
   IN LPWSTR Product,
   IN LPWSTR Version
   );

NTSTATUS
NTAPI
LlsProductAddA(
   IN LLS_HANDLE Handle,
   IN LPSTR ProductFamily,
   IN LPSTR Product,
   IN LPSTR Version
   );
#ifdef UNICODE
#define LlsProductAdd LlsProductAddW
#else
#define LlsProductAdd LlsProductAddA
#endif

// For a particular product enum all users.
NTSTATUS
NTAPI
LlsProductUserEnumW(
   IN     LLS_HANDLE Handle,
   IN     LPWSTR     Product,
   IN     DWORD      Level,     // Levels 0,1 supported
   OUT    LPBYTE*    bufptr,
   IN     DWORD      prefmaxlen,
   OUT    LPDWORD    EntriesRead,
   OUT    LPDWORD    TotalEntries,
   IN OUT LPDWORD    ResumeHandle
   );

NTSTATUS
NTAPI
LlsProductUserEnumA(
   IN     LLS_HANDLE Handle,
   IN     LPSTR      Product,
   IN     DWORD      Level,     // Levels 0,1 supported
   OUT    LPBYTE*    bufptr,
   IN     DWORD      prefmaxlen,
   OUT    LPDWORD    EntriesRead,
   OUT    LPDWORD    TotalEntries,
   IN OUT LPDWORD    ResumeHandle
   );
#ifdef UNICODE
#define LlsProductUserEnum LlsProductUserEnumW
#else
#define LlsProductUserEnum LlsProductUserEnumA
#endif

// For a particular product enum all license purchases.
NTSTATUS
NTAPI
LlsProductLicenseEnumW(
   IN     LLS_HANDLE Handle,
   IN     LPWSTR     Product,
   IN     DWORD      Level,     // Level 0 supported
   OUT    LPBYTE*    bufptr,   
   IN     DWORD      prefmaxlen, 
   OUT    LPDWORD    EntriesRead,
   OUT    LPDWORD    TotalEntries,
   IN OUT LPDWORD    ResumeHandle
   );

NTSTATUS
NTAPI
LlsProductLicenseEnumA(
   IN     LLS_HANDLE Handle,
   IN     LPSTR      Product,
   IN     DWORD      Level,     // Level 0 supported
   OUT    LPBYTE*    bufptr,   
   IN     DWORD      prefmaxlen, 
   OUT    LPDWORD    EntriesRead,
   OUT    LPDWORD    TotalEntries,
   IN OUT LPDWORD    ResumeHandle
   );

#ifdef UNICODE
#define LlsProductLicenseEnum LlsProductLicenseEnumW
#else
#define LlsProductLicenseEnum LlsProductLicenseEnumA
#endif


// For given product enum all servers with concurrent limits
NTSTATUS
NTAPI
LlsProductServerEnumW(
   IN     LLS_HANDLE Handle,
   IN     LPWSTR     Product,
   IN     DWORD      Level,     // Levels 0,1 supported
   OUT    LPBYTE*    bufptr,      
   IN     DWORD      prefmaxlen,  
   OUT    LPDWORD    EntriesRead,
   OUT    LPDWORD    TotalEntries,
   IN OUT LPDWORD    ResumeHandle
   );

NTSTATUS
NTAPI
LlsProductServerEnumA(
   IN     LLS_HANDLE Handle,
   IN     LPSTR      Product,
   IN     DWORD      Level,     // Levels 0,1 supported
   OUT    LPBYTE*    bufptr,      
   IN     DWORD      prefmaxlen,  
   OUT    LPDWORD    EntriesRead,
   OUT    LPDWORD    TotalEntries,
   IN OUT LPDWORD    ResumeHandle
   );


#ifdef UNICODE
#define LlsProductServerEnum LlsProductServerEnumW
#else
#define LlsProductServerEnum LlsProductServerEnumA
#endif

//
//  User control API's
//  A user can be a mapped user or a normal user
//

// Enums all users
NTSTATUS
NTAPI
LlsUserEnumW(
   IN     LLS_HANDLE Handle,
   IN     DWORD      Level,     // Levels 0,1 supported
   OUT    LPBYTE*    bufptr,
   IN     DWORD      prefmaxlen,
   OUT    LPDWORD    EntriesRead,
   OUT    LPDWORD    TotalEntries,
   IN OUT LPDWORD    ResumeHandle
   );

NTSTATUS
NTAPI
LlsUserEnumA(
   IN     LLS_HANDLE Handle,
   IN     DWORD      Level,     // Levels 0,1 supported
   OUT    LPBYTE*    bufptr,
   IN     DWORD      prefmaxlen,
   OUT    LPDWORD    EntriesRead,
   OUT    LPDWORD    TotalEntries,
   IN OUT LPDWORD    ResumeHandle
   );
#ifdef UNICODE
#define LlsUserEnum LlsUserEnumW
#else
#define LlsUserEnum LlsUserEnumA
#endif

// Info is Group and whether to force back-office license
NTSTATUS
NTAPI
LlsUserInfoGetW(
   IN  LLS_HANDLE Handle,
   IN  LPWSTR     User,
   IN  DWORD      Level,    // Level 1 supported
   OUT LPBYTE*    bufptr
   );

NTSTATUS
NTAPI
LlsUserInfoGetA(
   IN  LLS_HANDLE Handle,
   IN  LPSTR      User,
   IN  DWORD      Level,    // Level 1 supported
   OUT LPBYTE*    bufptr
   );
#ifdef UNICODE
#define LlsUserInfoGet LlsUserInfoGetW
#else
#define LlsUserInfoGet LlsUserInfoGetA
#endif

NTSTATUS
NTAPI
LlsUserInfoSetW(
   IN LLS_HANDLE Handle,
   IN LPWSTR     User,
   IN DWORD      Level,
   IN LPBYTE     bufptr     // Level 1 supported
   );

NTSTATUS
NTAPI
LlsUserInfoSetA(
   IN LLS_HANDLE Handle,
   IN LPSTR      User,
   IN DWORD      Level,
   IN LPBYTE     bufptr     // Level 1 supported
   );
#ifdef UNICODE
#define LlsUserInfoSet LlsUserInfoSetW
#else
#define LlsUserInfoSet LlsUserInfoSetA
#endif

NTSTATUS
NTAPI
LlsUserDeleteW(
   IN LLS_HANDLE Handle,
   IN LPWSTR     User
   );

NTSTATUS
NTAPI
LlsUserDeleteA(
   IN LLS_HANDLE Handle,
   IN LPSTR     User
   );
#ifdef UNICODE
#define LlsUserDelete LlsUserDeleteW
#else
#define LlsUserDelete LlsUserDeleteA
#endif

// For a given user enums all license useages
NTSTATUS
NTAPI
LlsUserProductEnumW(
   IN     LLS_HANDLE Handle,
   IN     LPWSTR     User,
   IN     DWORD      Level,     // Levels 0,1 supported
   OUT    LPBYTE*    bufptr,
   IN     DWORD      prefmaxlen,
   OUT    LPDWORD    EntriesRead,
   OUT    LPDWORD    TotalEntries,
   IN OUT LPDWORD    ResumeHandle
   );

NTSTATUS
NTAPI
LlsUserProductEnumA(
   IN     LLS_HANDLE Handle,
   IN     LPSTR      User,
   IN     DWORD      Level,     // Levels 0,1 supported
   OUT    LPBYTE*    bufptr,
   IN     DWORD      prefmaxlen,
   OUT    LPDWORD    EntriesRead,
   OUT    LPDWORD    TotalEntries,
   IN OUT LPDWORD    ResumeHandle
   );
#ifdef UNICODE
#define LlsUserProductEnum LlsUserProductEnumW
#else
#define LlsUserProductEnum LlsUserProductEnumA
#endif

// For a given user deletes a license useage
NTSTATUS
NTAPI
LlsUserProductDeleteW(
   IN LLS_HANDLE Handle,
   IN LPWSTR     User,
   IN LPWSTR     Product
   );

NTSTATUS
NTAPI
LlsUserProductDeleteA(
   IN LLS_HANDLE Handle,
   IN LPSTR      User,
   IN LPSTR      Product
   );
#ifdef UNICODE
#define LlsUserProductDelete LlsUserProductDeleteW
#else
#define LlsUserProductDelete LlsUserProductDeleteA
#endif

//
// Group control API's
//

// Enums all user Groups
NTSTATUS
NTAPI
LlsGroupEnumW(
   IN     LLS_HANDLE Handle,
   IN     DWORD      Level,     // Levels 0,1 supported
   OUT    LPBYTE*    bufptr,
   IN     DWORD      prefmaxlen,
   OUT    LPDWORD    EntriesRead,
   OUT    LPDWORD    TotalEntries,
   IN OUT LPDWORD    ResumeHandle
   );

NTSTATUS
NTAPI
LlsGroupEnumA(
   IN     LLS_HANDLE Handle,
   IN     DWORD      Level,     // Levels 0,1 supported
   OUT    LPBYTE*    bufptr,
   IN     DWORD      prefmaxlen,
   OUT    LPDWORD    EntriesRead,
   OUT    LPDWORD    TotalEntries,
   IN OUT LPDWORD    ResumeHandle
   );
#ifdef UNICODE
#define LlsGroupEnum LlsGroupEnumW
#else
#define LlsGroupEnum LlsGroupEnumA
#endif

// For given Group gets info, info is name, comment and # licenses used
NTSTATUS
NTAPI
LlsGroupInfoGetW(
   IN  LLS_HANDLE Handle,
   IN  LPWSTR     Group,
   IN  DWORD      Level,    // Level 1 supported
   OUT LPBYTE*    bufptr
   );

NTSTATUS
NTAPI
LlsGroupInfoGetA(
   IN  LLS_HANDLE Handle,
   IN  LPSTR      Group,
   IN  DWORD      Level,    // Level 1 supported
   OUT LPBYTE*    bufptr
   );
#ifdef UNICODE
#define LlsGroupInfoGet LlsGroupInfoGetW
#else
#define LlsGroupInfoGet LlsGroupInfoGetA
#endif

NTSTATUS
NTAPI
LlsGroupInfoSetW(
   IN LLS_HANDLE Handle,
   IN LPWSTR     Group,
   IN DWORD      Level,     // Level 1 supported
   IN LPBYTE     bufptr
   );

NTSTATUS
NTAPI
LlsGroupInfoSetA(
   IN LLS_HANDLE Handle,
   IN LPSTR      Group,
   IN DWORD      Level,     // Level 1 supported
   IN LPBYTE     bufptr
   );
#ifdef UNICODE
#define LlsGroupInfoSet LlsGroupInfoSetW
#else
#define LlsGroupInfoSet LlsGroupInfoSetA
#endif

// For given Group enum all users
NTSTATUS
NTAPI
LlsGroupUserEnumW(
   IN     LLS_HANDLE Handle,
   IN     LPWSTR     Group,
   IN     DWORD      Level,     // Levels 0,1 supported
   OUT    LPBYTE*    bufptr,      
   IN     DWORD      prefmaxlen,  
   OUT    LPDWORD    EntriesRead,
   OUT    LPDWORD    TotalEntries,
   IN OUT LPDWORD    ResumeHandle
   );

NTSTATUS
NTAPI
LlsGroupUserEnumA(
   IN     LLS_HANDLE Handle,
   IN     LPSTR      Group,
   IN     DWORD      Level,     // Levels 0,1 supported
   OUT    LPBYTE*    bufptr,      
   IN     DWORD      prefmaxlen,  
   OUT    LPDWORD    EntriesRead,
   OUT    LPDWORD    TotalEntries,
   IN OUT LPDWORD    ResumeHandle
   );
#ifdef UNICODE
#define LlsGroupUserEnum LlsGroupUserEnumW
#else
#define LlsGroupUserEnum LlsGroupUserEnumA
#endif

// Add user to given Group
NTSTATUS
NTAPI
LlsGroupUserAddW(
   IN LLS_HANDLE Handle,
   IN LPWSTR     Group,
   IN LPWSTR     User
   );

NTSTATUS
NTAPI
LlsGroupUserAddA(
   IN LLS_HANDLE Handle,
   IN LPSTR      Group,
   IN LPSTR      User
   );
#ifdef UNICODE
#define LlsGroupUserAdd LlsGroupUserAddW
#else
#define LlsGroupUserAdd LlsGroupUserAddA
#endif

// Delete user from given Group
NTSTATUS
NTAPI
LlsGroupUserDeleteW(
   IN LLS_HANDLE Handle,
   IN LPWSTR     Group,
   IN LPWSTR     User
   );

NTSTATUS
NTAPI
LlsGroupUserDeleteA(
   IN LLS_HANDLE Handle,
   IN LPSTR      Group,
   IN LPSTR      User
   );
#ifdef UNICODE
#define LlsGroupUserDelete LlsGroupUserDeleteW
#else
#define LlsGroupUserDelete LlsGroupUserDeleteA
#endif

// Add a given Group
NTSTATUS
NTAPI
LlsGroupAddW(
   IN LLS_HANDLE Handle,
   IN DWORD      Level,    // Level 1 supported
   IN LPBYTE     bufptr
   );

NTSTATUS
NTAPI
LlsGroupAddA(
   IN LLS_HANDLE Handle,
   IN DWORD      Level,    // Level 1 supported
   IN LPBYTE     bufptr
   );
#ifdef UNICODE
#define LlsGroupAdd LlsGroupAddW
#else
#define LlsGroupAdd LlsGroupAddA
#endif

NTSTATUS
NTAPI
LlsGroupDeleteW(
   IN LLS_HANDLE Handle,
   IN LPWSTR     Group
   );

NTSTATUS
NTAPI
LlsGroupDeleteA(
   IN LLS_HANDLE Handle,
   IN LPSTR      Group
   );
#ifdef UNICODE
#define LlsGroupDelete LlsGroupDeleteW
#else
#define LlsGroupDelete LlsGroupDeleteA
#endif


//
// Service control API's
//

NTSTATUS
NTAPI
LlsServiceInfoGetW(
   IN  LLS_HANDLE Handle,
   IN  DWORD      Level,
   OUT LPBYTE*    bufptr
   );

NTSTATUS
NTAPI
LlsServiceInfoGetA(
   IN  LLS_HANDLE Handle,
   IN  DWORD      Level,
   OUT LPBYTE*    bufptr
   );
#ifdef UNICODE
#define LlsServiceInfoGet LlsServiceInfoGetW
#else
#define LlsServiceInfoGet LlsServiceInfoGetA
#endif

NTSTATUS
NTAPI
LlsServiceInfoSetW(
   IN LLS_HANDLE Handle,
   IN DWORD      Level,
   IN LPBYTE     bufptr
   );

NTSTATUS
NTAPI
LlsServiceInfoSetA(
   IN LLS_HANDLE Handle,
   IN DWORD      Level,
   IN LPBYTE     bufptr
   );
#ifdef UNICODE
#define LlsServiceInfoSet LlsServiceInfoSetW
#else
#define LlsServiceInfoSet LlsServiceInfoSetA
#endif


//
// Server Table Stuff (Replicated Server / Product Tree)
//
NTSTATUS
NTAPI
LlsServerEnumW(
   IN     LLS_HANDLE Handle,
   IN     LPWSTR     Server,
   IN     DWORD      Level,     // Levels 0,1 supported
   OUT    LPBYTE*    bufptr,      
   IN     DWORD      prefmaxlen,  
   OUT    LPDWORD    EntriesRead,
   OUT    LPDWORD    TotalEntries,
   IN OUT LPDWORD    ResumeHandle
   );

NTSTATUS
NTAPI
LlsServerEnumA(
   IN     LLS_HANDLE Handle,
   IN     LPSTR      Server,
   IN     DWORD      Level,     // Levels 0,1 supported
   OUT    LPBYTE*    bufptr,      
   IN     DWORD      prefmaxlen,  
   OUT    LPDWORD    EntriesRead,
   OUT    LPDWORD    TotalEntries,
   IN OUT LPDWORD    ResumeHandle
   );

#ifdef UNICODE
#define LlsServerEnum LlsServerEnumW
#else
#define LlsServerEnum LlsServerEnumA
#endif


#ifdef OBSOLETE

NTSTATUS
NTAPI
LlsServerProductEnumW(
   IN     LLS_HANDLE Handle,
   IN     LPWSTR     Server,
   IN     DWORD      Level,     // Levels 0,1 supported
   OUT    LPBYTE*    bufptr,      
   IN     DWORD      prefmaxlen,  
   OUT    LPDWORD    EntriesRead,
   OUT    LPDWORD    TotalEntries,
   IN OUT LPDWORD    ResumeHandle
   );

NTSTATUS
NTAPI
LlsServerProductEnumA(
   IN     LLS_HANDLE Handle,
   IN     LPSTR      Server,
   IN     DWORD      Level,     // Levels 0,1 supported
   OUT    LPBYTE*    bufptr,      
   IN     DWORD      prefmaxlen,  
   OUT    LPDWORD    EntriesRead,
   OUT    LPDWORD    TotalEntries,
   IN OUT LPDWORD    ResumeHandle
   );

#endif // OBSOLETE

#ifdef UNICODE
#define LlsServerUserEnum LlsServerUserEnumW
#else
#define LlsServerUserEnum LlsServerUserEnumA
#endif


#ifdef OBSOLETE

//
// Concurrent (Per-Server) mode API's (these will interact with the registry
// on the remote system).
//
NTSTATUS
NTAPI
LlsLocalProductEnumW(
   IN     LLS_HANDLE Handle,
   IN     DWORD      Level,     // Levels 0,1 supported
   OUT    LPBYTE*    bufptr,      
   IN     DWORD      prefmaxlen,  
   OUT    LPDWORD    EntriesRead,
   OUT    LPDWORD    TotalEntries,
   IN OUT LPDWORD    ResumeHandle
   );

NTSTATUS
NTAPI
LlsLocalProductEnumA(
   IN     LLS_HANDLE Handle,
   IN     DWORD      Level,     // Levels 0,1 supported
   OUT    LPBYTE*    bufptr,      
   IN     DWORD      prefmaxlen,  
   OUT    LPDWORD    EntriesRead,
   OUT    LPDWORD    TotalEntries,
   IN OUT LPDWORD    ResumeHandle
   );
#ifdef UNICODE
#define LlsLocalProductEnum LlsLocalProductEnumW
#else
#define LlsLocalProductEnum LlsLocalProductEnumA
#endif

NTSTATUS
NTAPI
LlsLocalProductInfoGetW(
   IN LLS_HANDLE Handle,
   IN LPWSTR     Product,
   IN DWORD      Level,
   OUT LPBYTE*   bufptr
   );

NTSTATUS
NTAPI
LlsLocalProductInfoGetA(
   IN LLS_HANDLE Handle,
   IN LPSTR      Product,
   IN DWORD      Level,
   OUT LPBYTE*   bufptr
   );
#ifdef UNICODE
#define LlsLocalProductInfoGet LlsLocalProductInfoGetW
#else
#define LlsLocalProductInfoGet LlsLocalProductInfoGetA
#endif

NTSTATUS
NTAPI
LlsLocalProductInfoSetW(
   IN LLS_HANDLE Handle,
   IN LPWSTR     Product,
   IN DWORD      Level,
   IN LPBYTE     bufptr
   );

NTSTATUS
NTAPI
LlsLocalProductInfoSetA(
   IN LLS_HANDLE Handle,
   IN LPSTR      Product,
   IN DWORD      Level,
   IN LPBYTE     bufptr
   );
#ifdef UNICODE
#define LlsLocalProductInfoSet LlsLocalProductInfoSetW
#else
#define LlsLocalProductInfoSet LlsLocalProductInfoSetA
#endif

#endif // OBSOLETE

//////////////////////////////////////////////////////////////////////////////
//  LLS EXTENDED API  //
////////////////////////

BOOL
NTAPI
LlsCapabilityIsSupported(
   LLS_HANDLE  Handle,
   DWORD       Capability );

typedef BOOL (NTAPI *PLLS_CAPABILITY_IS_SUPPORTED)( LLS_HANDLE, DWORD );

NTSTATUS
NTAPI
LlsProductSecurityGetW(
   IN LLS_HANDLE  Handle,
   IN LPWSTR      Product,
   OUT LPBOOL     pSecurity
   );

NTSTATUS
NTAPI
LlsProductSecurityGetA(
   IN LLS_HANDLE  Handle,
   IN LPSTR       Product,
   OUT LPBOOL     pSecurity
   );

typedef NTSTATUS (NTAPI *PLLS_PRODUCT_SECURITY_GET_W)( LLS_HANDLE, LPWSTR, LPBOOL );
typedef NTSTATUS (NTAPI *PLLS_PRODUCT_SECURITY_GET_A)( LLS_HANDLE, LPSTR,  LPBOOL );

#ifdef UNICODE
#  define LlsProductSecurityGet LlsProductSecurityGetW
#else
#  define LlsProductSecurityGet LlsProductSecurityGetA
#endif

NTSTATUS
NTAPI
LlsProductSecuritySetW(
   IN LLS_HANDLE  Handle,
   IN LPWSTR      Product
   );

NTSTATUS
NTAPI
LlsProductSecuritySetA(
   IN LLS_HANDLE  Handle,
   IN LPSTR       Product
   );

typedef NTSTATUS (NTAPI *PLLS_PRODUCT_SECURITY_SET_W)( LLS_HANDLE, LPWSTR );
typedef NTSTATUS (NTAPI *PLLS_PRODUCT_SECURITY_SET_A)( LLS_HANDLE, LPSTR  );

#ifdef UNICODE
#  define LlsProductSecuritySet LlsProductSecuritySetW
#else
#  define LlsProductSecuritySet LlsProductSecuritySetA
#endif

NTSTATUS
NTAPI
LlsProductLicensesGetW(
   IN LLS_HANDLE         Handle,
   IN LPWSTR             DisplayName,
   IN DWORD              Mode,
   OUT LPDWORD           pQuantity );

NTSTATUS
NTAPI
LlsProductLicensesGetA(
   IN LLS_HANDLE         Handle,
   IN LPSTR              DisplayName,
   IN DWORD              Mode,
   OUT LPDWORD           pQuantity );

typedef NTSTATUS (NTAPI *PLLS_PRODUCT_LICENSES_GET_W)( LLS_HANDLE, LPWSTR, DWORD, LPDWORD );
typedef NTSTATUS (NTAPI *PLLS_PRODUCT_LICENSES_GET_A)( LLS_HANDLE, LPSTR,  DWORD, LPDWORD );

#ifdef UNICODE
#  define LlsProductLicensesGet LlsProductLicensesGetW
#else
#  define LlsProductLicensesGet LlsProductLicensesGetA
#endif

#ifdef OBSOLETE

NTSTATUS
NTAPI
LlsCertificateClaimEnumW(
   IN LLS_HANDLE        Handle,
   IN DWORD             LicenseLevel,
   IN LPBYTE            pLicenseInfo,
   IN DWORD             TargetLevel,
   OUT LPBYTE *         ppTargets,
   OUT LPDWORD          pNumTargets );

NTSTATUS
NTAPI
LlsCertificateClaimEnumA(
   IN LLS_HANDLE        Handle,
   IN DWORD             LicenseLevel,
   IN LPBYTE            pLicenseInfo,
   IN DWORD             TargetLevel,
   OUT LPBYTE *         ppTargets,
   OUT LPDWORD          pNumTargets );

typedef NTSTATUS (NTAPI *PLLS_CERTIFICATE_CLAIM_ENUM_W)( LLS_HANDLE, DWORD, LPBYTE, DWORD, LPBYTE *, LPDWORD );
typedef NTSTATUS (NTAPI *PLLS_CERTIFICATE_CLAIM_ENUM_A)( LLS_HANDLE, DWORD, LPBYTE, DWORD, LPBYTE *, LPDWORD );

#ifdef UNICODE
#  define LlsCertificateClaimEnum LlsCertificateClaimEnumW
#else
#  define LlsCertificateClaimEnum LlsCertificateClaimEnumA
#endif

#endif // OBSOLETE

NTSTATUS
NTAPI
LlsCertificateClaimAddCheckW(
   IN LLS_HANDLE        Handle,
   IN DWORD             LicenseLevel,
   IN LPBYTE            pLicenseInfo,
   OUT LPBOOL           pMayInstall );

NTSTATUS
NTAPI
LlsCertificateClaimAddCheckA(
   IN LLS_HANDLE        Handle,
   IN DWORD             LicenseLevel,
   IN LPBYTE            pLicenseInfo,
   OUT LPBOOL           pMayInstall );

typedef NTSTATUS (NTAPI *PLLS_CERTIFICATE_CLAIM_ADD_CHECK_W)( LLS_HANDLE, DWORD, LPBYTE, LPBOOL );
typedef NTSTATUS (NTAPI *PLLS_CERTIFICATE_CLAIM_ADD_CHECK_A)( LLS_HANDLE, DWORD, LPBYTE, LPBOOL );

#ifdef UNICODE
#  define LlsCertificateClaimAddCheck LlsCertificateClaimAddCheckW
#else
#  define LlsCertificateClaimAddCheck LlsCertificateClaimAddCheckA
#endif

NTSTATUS
NTAPI
LlsCertificateClaimAddW(
   IN LLS_HANDLE        Handle,
   IN LPWSTR            ServerName,
   IN DWORD             LicenseLevel,
   IN LPBYTE            pLicenseInfo );

NTSTATUS
NTAPI
LlsCertificateClaimAddA(
   IN LLS_HANDLE        Handle,
   IN LPSTR             ServerName,
   IN DWORD             LicenseLevel,
   IN LPBYTE            pLicenseInfo );

typedef NTSTATUS (NTAPI *PLLS_CERTIFICATE_CLAIM_ADD_W)( LLS_HANDLE, LPWSTR, DWORD, LPBYTE );
typedef NTSTATUS (NTAPI *PLLS_CERTIFICATE_CLAIM_ADD_A)( LLS_HANDLE, LPSTR,  DWORD, LPBYTE );

#ifdef UNICODE
#  define LlsCertificateClaimAdd LlsCertificateClaimAddW
#else
#  define LlsCertificateClaimAdd LlsCertificateClaimAddA
#endif

typedef NTSTATUS (NTAPI *PLLS_REPL_CONNECT_W)( LPWSTR, LLS_REPL_HANDLE * );
typedef NTSTATUS (NTAPI *PLLS_REPL_CONNECT_A)( LPSTR, LLS_REPL_HANDLE * );

typedef NTSTATUS (NTAPI *PLLS_REPL_CLOSE)( PLLS_REPL_HANDLE );

typedef NTSTATUS (NTAPI *PLLS_FREE_MEMORY)( PVOID );

typedef NTSTATUS (NTAPI *PLLS_REPLICATION_REQUEST_W)( LLS_REPL_HANDLE, DWORD, LPVOID );

typedef NTSTATUS (NTAPI *PLLS_REPLICATION_SERVER_ADD_W)( LLS_REPL_HANDLE, ULONG, LPVOID );

typedef NTSTATUS (NTAPI *PLLS_REPLICATION_SERVER_SERVICE_ADD_W)( LLS_REPL_HANDLE, ULONG, LPVOID );

typedef NTSTATUS (NTAPI *PLLS_REPLICATION_SERVICE_ADD_W)( LLS_REPL_HANDLE, ULONG, LPVOID );

typedef NTSTATUS (NTAPI *PLLS_REPLICATION_USER_ADD_W)( LLS_REPL_HANDLE, ULONG, LPVOID );

NTSTATUS
NTAPI
LlsReplicationCertDbAddW(
   LLS_REPL_HANDLE            ReplHandle,
   DWORD                      Level,
   LPVOID                     Certificates );

typedef NTSTATUS (NTAPI *PLLS_REPLICATION_CERT_DB_ADD_W)( LLS_REPL_HANDLE, DWORD, LPVOID );


NTSTATUS
NTAPI
LlsReplicationProductSecurityAddW(
   LLS_REPL_HANDLE            ReplHandle,
   DWORD                      Level,
   LPVOID                     SecureProducts );

typedef NTSTATUS (NTAPI *PLLS_REPLICATION_PRODUCT_SECURITY_ADD_W)( LLS_REPL_HANDLE, DWORD, LPVOID );


NTSTATUS
NTAPI
LlsReplicationUserAddExW(
   LLS_REPL_HANDLE            ReplHandle,
   DWORD                      Level,
   LPVOID                     Users );

typedef NTSTATUS (NTAPI *PLLS_REPLICATION_USER_ADD_EX_W)( LLS_REPL_HANDLE, DWORD, LPVOID );


NTSTATUS
NTAPI
LlsLocalServiceEnumW(
   LLS_HANDLE Handle,
   DWORD      Level,
   LPBYTE*    bufptr,
   DWORD      PrefMaxLen,
   LPDWORD    EntriesRead,
   LPDWORD    TotalEntries,
   LPDWORD    ResumeHandle );

NTSTATUS
NTAPI
LlsLocalServiceEnumA(
   LLS_HANDLE Handle,
   DWORD      Level,
   LPBYTE*    bufptr,
   DWORD      PrefMaxLen,
   LPDWORD    EntriesRead,
   LPDWORD    TotalEntries,
   LPDWORD    ResumeHandle );

#ifdef UNICODE
#  define LlsLocalServiceEnum LlsLocalServiceEnumW
#else
#  define LlsLocalServiceEnum LlsLocalServiceEnumA
#endif

#ifdef OBSOLETE

NTSTATUS
NTAPI
LlsLocalServiceAddW(
   LLS_HANDLE  Handle,
   DWORD       Level,
   LPBYTE      bufptr );

NTSTATUS
NTAPI
LlsLocalServiceAddA(
   LLS_HANDLE  Handle,
   DWORD       Level,
   LPBYTE      bufptr );

#ifdef UNICODE
#  define LlsLocalServiceAdd LlsLocalServiceAddW
#else
#  define LlsLocalServiceAdd LlsLocalServiceAddA
#endif

#endif // OBSOLETE

NTSTATUS
NTAPI
LlsLocalServiceInfoSetW(
   LLS_HANDLE Handle,
   LPWSTR     KeyName,
   DWORD      Level,
   LPBYTE     bufptr );

NTSTATUS
NTAPI
LlsLocalServiceInfoSetA(
   LLS_HANDLE  Handle,
   LPSTR       KeyName,
   DWORD       Level,
   LPBYTE      bufptr );

#ifdef UNICODE
#  define LlsLocalServiceInfoSet LlsLocalServiceInfoSetW
#else
#  define LlsLocalServiceInfoSet LlsLocalServiceInfoSetA
#endif

NTSTATUS
NTAPI
LlsLocalServiceInfoGetW(
   LLS_HANDLE  Handle,
   LPWSTR      KeyName,
   DWORD       Level,
   LPBYTE *    pbufptr );

NTSTATUS
NTAPI
LlsLocalServiceInfoGetA(
   LLS_HANDLE  Handle,
   DWORD       Level,
   LPSTR       KeyName,
   LPBYTE *    pbufptr );

#ifdef UNICODE
#  define LlsLocalServiceInfoGet LlsLocalServiceInfoGetW
#else
#  define LlsLocalServiceInfoGet LlsLocalServiceInfoGetA
#endif

NTSTATUS
NTAPI
LlsLicenseRequestW(
   LLS_HANDLE  Handle,
   LPWSTR      Product,
   ULONG       VersionIndex,
   BOOLEAN     IsAdmin,
   ULONG       DataType,
   ULONG       DataSize,
   PBYTE       Data,
   LPDWORD     pLicenseHandle );

NTSTATUS
NTAPI
LlsLicenseRequestA(
   LLS_HANDLE  Handle,
   LPSTR       Product,
   ULONG       VersionIndex,
   BOOLEAN     IsAdmin,
   ULONG       DataType,
   ULONG       DataSize,
   PBYTE       Data,
   LPDWORD     pLicenseHandle );

#ifdef UNICODE
#  define LlsLicenseRequest LlsLicenseRequestW
#else
#  define LlsLicenseRequest LlsLicenseRequestA
#endif

NTSTATUS
NTAPI
LlsLicenseFree(
   LLS_HANDLE  Handle,
   DWORD       LicenseHandle );

NTSTATUS
NTAPI
LlsLicenseRequest2W(
   LLS_HANDLE  Handle,
   LPWSTR      Product,
   ULONG       VersionIndex,
   BOOLEAN     IsAdmin,
   ULONG       DataType,
   ULONG       DataSize,
   PBYTE       Data,
   PHANDLE     pLicenseHandle );

NTSTATUS
NTAPI
LlsLicenseRequest2A(
   LLS_HANDLE  Handle,
   LPSTR       Product,
   ULONG       VersionIndex,
   BOOLEAN     IsAdmin,
   ULONG       DataType,
   ULONG       DataSize,
   PBYTE       Data,
   PHANDLE     pLicenseHandle );

#ifdef UNICODE
#  define LlsLicenseRequest2 LlsLicenseRequest2W
#else
#  define LlsLicenseRequest2 LlsLicenseRequest2A
#endif

NTSTATUS
NTAPI
LlsLicenseFree2(
   LLS_HANDLE  Handle,
   HANDLE      LicenseHandle );

//////////////////////////////////////////////////////////////////////////////
//  CCF API  //
///////////////

#define CCF_ENTER_FLAG_PER_SEAT_ONLY         ( 1 )
#define CCF_ENTER_FLAG_PER_SERVER_ONLY       ( 2 )
#define CCF_ENTER_FLAG_SERVER_IS_ES          ( 4 )

// prototype for certificate source enter API
typedef DWORD (APIENTRY *PCCF_ENTER_API)(    HWND     hWndParent,
                                             LPCSTR   pszServerName,
                                             LPCSTR   pszProductName,
                                             LPCSTR   pszVendor,
                                             DWORD    dwFlags );

DWORD APIENTRY CCFCertificateEnterUI(        HWND     hWndParent,
                                             LPCSTR   pszServerName,
                                             LPCSTR   pszProductName,
                                             LPCSTR   pszVendor,
                                             DWORD    dwFlags,
                                             LPCSTR   pszSourceToUse );

// prototype for certificate source remove API
typedef DWORD (APIENTRY *PCCF_REMOVE_API)(   HWND     hWndParent,
                                             LPCSTR   pszServerName,
                                             DWORD    dwFlags,
                                             DWORD    dwLicenseLevel,
                                             LPVOID   lpvLicenseInfo );

DWORD APIENTRY CCFCertificateRemoveUI(       HWND     hWndParent,
                                             LPCSTR   pszServerName,
                                             LPCSTR   pszProductName,
                                             LPCSTR   pszVendor,
                                             DWORD    dwFlags,
                                             LPCSTR   pszSourceToUse );

#endif

//
// Registry values
//

#define REG_KEY_LICENSE  TEXT("SYSTEM\\CurrentControlSet\\Services\\LicenseInfo")
#define REG_KEY_CONFIG   TEXT("SYSTEM\\CurrentControlSet\\Services\\LicenseService\\Parameters")

#define REG_VALUE_NAME     TEXT("DisplayName")
#define REG_VALUE_FAMILY   TEXT("FamilyDisplayName")
#define REG_VALUE_MODE     TEXT("Mode")
#define REG_VALUE_FLIP     TEXT("FlipAllow")
#define REG_VALUE_LIMIT    TEXT("ConcurrentLimit")
#define REG_VALUE_HIGHMARK TEXT("LocalKey")

#ifdef __cplusplus
}
#endif

#endif
=== C:/Users/treeman/Desktop/windows nt source code\Source\Win2K3\NT\public\internal\ds\inc\ginaipc.h ===
//  --------------------------------------------------------------------------
//  Module Name: GinaIPC.h
//
//  Copyright (c) 1999-2000, Microsoft Corporation
//
//  Private structures that allow the CLogonIPC class hosted in an external
//  process to communicate with GINA which provides the logon service within
//  the Winlogon process.
//
//  History:    1999-08-20  vtan        created
//              2000-01-31  vtan        moved from Neptune to Whistler
//              2000-05-05  vtan        added GINA -> UI communications
//              2000-06-16  vtan        moved to ds\published\inc
//  --------------------------------------------------------------------------

#ifndef     _GinaIPC_
#define     _GinaIPC_

#include <lmcons.h>

//  These are enumerations of valid requested functionality.

static  const UINT  WM_LOGONSERVICEREQUEST                  =   WM_USER + 8517;
static  const UINT  WM_UISERVICEREQUEST                     =   WM_USER + 7647;

//  These are messages for UI -> GINA communications.

static  const int   LOGON_QUERY_LOGGED_ON                   =   1;
static  const int   LOGON_LOGON_USER                        =   2;
static  const int   LOGON_LOGOFF_USER                       =   3;
static  const int   LOGON_TEST_BLANK_PASSWORD               =   4;
static  const int   LOGON_TEST_INTERACTIVE_LOGON_ALLOWED    =   5;
static  const int   LOGON_TEST_EJECT_ALLOWED                =   6;
static  const int   LOGON_TEST_SHUTDOWN_ALLOWED             =   7;
static  const int   LOGON_TURN_OFF_COMPUTER                 =   10;
static  const int   LOGON_EJECT_COMPUTER                    =   11;
static  const int   LOGON_SIGNAL_UIHOST_FAILURE             =   20;
static  const int   LOGON_ALLOW_EXTERNAL_CREDENTIALS        =   30;
static  const int   LOGON_REQUEST_EXTERNAL_CREDENTIALS      =   31;

//  These are messages for GINA -> UI communications.

static  const int   UI_STATE_NONE                           =   0;
static  const int   UI_TERMINATE                            =   1;
static  const int   UI_STATE_STATUS                         =   2;
static  const int   UI_STATE_LOGON                          =   3;
static  const int   UI_STATE_LOGGEDON                       =   4;
static  const int   UI_STATE_HIDE                           =   5;
static  const int   UI_STATE_END                            =   6;
static  const int   UI_DISPLAY_STATUS                       =   10;
static  const int   UI_NOTIFY_WAIT                          =   20;
static  const int   UI_SELECT_USER                          =   21;
static  const int   UI_SET_ANIMATIONS                       =   22;
static  const int   UI_INTERACTIVE_LOGON                    =   30;

//  These are start methods of the UI host

static  const int   HOST_START_NORMAL                       =   0;
static  const int   HOST_START_SHUTDOWN                     =   1;
static  const int   HOST_START_WAIT                         =   2;

//  These are end methods of the UI host

static  const int   HOST_END_HIDE                           =   0;
static  const int   HOST_END_TERMINATE                      =   1;
static  const int   HOST_END_FAILURE                        =   2;

//  This is generic to all request types.

typedef struct
{
    BOOL            fResult;
} LOGONIPC;

//  This represents user identification.

typedef struct
{
    LOGONIPC        logonIPC;
    WCHAR           wszUsername[UNLEN + sizeof('\0')],
                    wszDomain[DNLEN + sizeof('\0')];
} LOGONIPC_USERID;

//  This represents user credentials (identification + password).
//  The password is run encoded when stored in memory.

typedef struct
{
    LOGONIPC_USERID     userID;
    WCHAR               wszPassword[PWLEN + sizeof('\0')];
    int                 iPasswordLength;
    unsigned char       ucPasswordSeed;
} LOGONIPC_CREDENTIALS;

//  This structure is used to return users from msgina to shgina.

typedef struct
{
    LPWSTR  pszName;
    LPWSTR  pszDomain;
    LPWSTR  pszFullName;
    DWORD   dwFlags;
} GINA_USER_INFORMATION;

//  This is the status window class shared between msgina and shgina.

#define     STATUS_WINDOW_CLASS_NAME    (TEXT("StatusWindowClass"))

#endif  /*  _GinaIPC_   */
=== C:/Users/treeman/Desktop/windows nt source code\Source\Win2K3\NT\public\internal\ds\inc\keymgr.h ===
#ifndef _KEYMGR_H_
#define _KEYMGR_H_

/*++

Copyright (c) 2000  Microsoft Corporation

Module Name:

    KEYMGR.H

Abstract:

    KeyMgr application public API definitions
     
Author:

    990917  johnhaw Created. 
    georgema        000310  updated

Environment:
    Win98, Win2000

Revision History:

--*/
#ifdef __cplusplus
extern "C" {
#endif
BOOL WINAPI DllMain(HINSTANCE,DWORD,LPVOID);
LONG WINAPI CPlApplet(HWND hwndCPl,UINT uMsg,LPARAM lParam1,LPARAM lParam2);
void APIENTRY KRShowKeyMgr(HWND hwParent,HINSTANCE hInstance,LPWSTR pszCmdLine,int nCmdShow);
void APIENTRY PRShowSaveWizardW(HWND hwndOwner,HINSTANCE hInstance,LPWSTR pszCmdLine,int nCmdShow);
void APIENTRY PRShowSaveWizardExW(HWND hwParent,HINSTANCE hInstance,LPWSTR pszCmdLine,int nCmdShow);
void APIENTRY PRShowSaveFromMsginaW(HWND hwParent,HINSTANCE hInstance,LPWSTR pszCmdLine,int nCmdShow);
void APIENTRY PRShowRestoreWizardW(HWND hwndOwner,HINSTANCE hInstance,LPWSTR pszCmdLine,int nCmdShow);
void APIENTRY PRShowRestoreWizardExW(HWND hwndOwner,HINSTANCE hInstance,LPWSTR pszCmdLine,int nCmdShow);
void APIENTRY PRShowRestoreFromMsginaW(HWND hwndOwner,HINSTANCE hInstance,LPWSTR pszCmdLine,int nCmdShow);
#ifdef __cplusplus
}
#endif
#endif  //  _KEYMGR_H_

//
///// End of file: KeyMgr.h ////////////////////////////////////////////////
=== C:/Users/treeman/Desktop/windows nt source code\Source\Win2K3\NT\public\internal\ds\inc\jet.h ===
/***********************************************************************
* Microsoft Jet
*
* Microsoft Confidential.  Copyright 1991-1993 Microsoft Corporation.
*
* Component:
*
* File: jet.h
*
* File Comments:
*
*     Public header file with JET API definition.
*
* Revision History:
*
*    [0]  04-Jan-92  richards	Added this header
*
***********************************************************************/

//
// This __JET500 essentially creates two version of this file in this
// same file. All the jet500 stuff is in __JET500 macro
//
#if __JET500
#include "jet500.h"
//
// End of 500 series jet.h
#else
//
// Original jet.h starts here. i.e jet.h of 200 series db.
//

#if !defined(_JET_INCLUDED)
#define _JET_INCLUDED

#ifdef	__cplusplus
extern "C" {
#endif

#pragma pack(4)

#if defined(_M_ALPHA)				/* 0:32 Flat Model (Alpha AXP) */

#define _far
#define JET_API   __stdcall
#define JET_NODSAPI __stdcall

#elif	defined(M_MRX000)				/* 0:32 Flat Model (MIPS Rx000) */

#define _far
#define JET_API   __stdcall
#define JET_NODSAPI  __stdcall

#else										/*	0:32 flat model (Intel 32-bit ) */

#define _far
#define JET_API     __stdcall		/* CONSIDER: Switch to __stdcall */
#define JET_NODSAPI __stdcall		/* CONSIDER: Switch to __stdcall */

#endif

typedef long JET_ERR;

typedef unsigned long JET_INSTANCE;	/* Instance Identifier */
typedef ULONG_PTR JET_SESID;		/* Session Identifier */
typedef ULONG_PTR JET_TABLEID;	    /* Table Identifier */
typedef unsigned long JET_COLUMNID;	/* Column Identifier */

typedef ULONG_PTR JET_DBID; 		/* Database Identifier */
typedef unsigned long JET_OBJTYP;	/* Object Type */
typedef unsigned long JET_COLTYP;	/* Column Type */
typedef unsigned long JET_GRBIT;		/* Group of Bits */
typedef unsigned long JET_ACM;		/* Access Mask */
typedef unsigned long JET_RNT;		/* Repair Notification Type */

typedef unsigned long JET_SNP;		/* Status Notification Process */
typedef unsigned long JET_SNT;		/* Status Notification Type */
typedef unsigned long JET_SNC;		/* Status Notification Code */

typedef double JET_DATESERIAL;		/* JET_coltypDateTime format */

#if defined(_M_ALPHA)				/* 0:32 Flat Model (Intel 80x86) */

typedef JET_ERR (__stdcall *JET_PFNSTATUS)(JET_SESID sesid, JET_SNP snp, JET_SNT snt, void _far *pv);

#elif	defined(M_MRX000)				/* 0:32 Flat Model (MIPS Rx000) */

typedef JET_ERR (__stdcall *JET_PFNSTATUS)(JET_SESID sesid, JET_SNP snp, JET_SNT snt, void _far *pv);

#else										/*	0:32 flat model (Alpha AXP ) */

typedef JET_ERR (__stdcall *JET_PFNSTATUS)(JET_SESID sesid, JET_SNP snp, JET_SNT snt, void _far *pv);

#endif


	/*	Session information bits */

#define JET_bitCIMCommitted					 	0x00000001
#define JET_bitCIMDirty							 	0x00000002
#define JET_bitAggregateTransaction		  		0x00000008

	/* JetGetLastErrorInfo structure */

typedef struct
	{
	unsigned long	cbStruct;	/* Size of this structure */
	JET_ERR 			err;			/* Extended error code (if any) */
	unsigned long	ul1;			/* First general purpose integer */
	unsigned long	ul2;			/* Second general purpose integer */
	unsigned long	ul3;			/* Third general purpose integer */
	} JET_EXTERR;

	/* Status Notification Structures */

typedef struct				/* Status Notification Progress */
	{
	unsigned long	cbStruct;	/* Size of this structure */
	unsigned long	cunitDone;	/* Number of units of work completed */
	unsigned long	cunitTotal;	/* Total number of units of work */
	} JET_SNPROG;

	/* ErrCount Notification Structures */

typedef struct						/* Status Notification Progress */
	{
	unsigned long	cbStruct;	/* Size of this structure */
	unsigned long	cRecUniqueKeyViolation;
	unsigned long	cRecTypeConversionFail;
	unsigned long	cRecRecordLocked;
	unsigned long	cRecTotal;	/* Total number of units of work */
	} JET_SNERRCNT;


typedef struct				/* Status Notification Message */
	{
	unsigned long	cbStruct;	/* Size of this structure */
	JET_SNC 	snc;					/* Status Notification Code */
	unsigned long	ul;			/* Numeric identifier */
	char		sz[256];				/* Identifier */
	} JET_SNMSG;


typedef struct
	{
	unsigned long	cbStruct;
	JET_OBJTYP	objtyp;
	JET_DATESERIAL	dtCreate;
	JET_DATESERIAL	dtUpdate;
	JET_GRBIT	grbit;
	unsigned long	flags;
	unsigned long	cRecord;
	unsigned long	cPage;
	} JET_OBJECTINFO;
	
typedef struct
	{
	unsigned	int dbid;
	char		szDatabaseName[256];
	char		szNewDatabaseName[256];
	} JET_RSTMAP;			/* restore map */

	/* The following flags appear in the grbit field above */

#define JET_bitTableInfoUpdatable	0x00000001
#define JET_bitTableInfoBookmark	0x00000002
#define JET_bitTableInfoRollback	0x00000004
#define JET_bitTableInfoRestartable	0x00000008
#define JET_bitTableInfoNoInserts	0x00000010

	/* The following flags occur in the flags field above */

#define JET_bitSaveUIDnPWD		0x20000000	/* this bit is only 		 */
											/* appropriate for rmt links */
#define JET_bitObjectExclusive	0x40000000	/* Open link exclusively */
#define JET_bitObjectSystem		0x80000000


typedef struct
	{
	unsigned long	cbStruct;
	JET_TABLEID		tableid;
	unsigned long	cRecord;
	JET_COLUMNID	columnidcontainername;
	JET_COLUMNID	columnidobjectname;
	JET_COLUMNID	columnidobjtyp;
	JET_COLUMNID	columniddtCreate;
	JET_COLUMNID	columniddtUpdate;
	JET_COLUMNID	columnidgrbit;
	JET_COLUMNID	columnidflags;
	JET_COLUMNID	columnidcRecord;	/* Level 2 info */
	JET_COLUMNID	columnidcPage;		/* Level 2 info */
	} JET_OBJECTLIST;

#define cObjectInfoCols 9	       /* CONSIDER: Internal */

typedef struct
	{
	unsigned long	cbStruct;
	JET_TABLEID		tableid;
	unsigned long	cRecord;
	JET_COLUMNID	columnidSid;
	JET_COLUMNID	columnidACM;
	JET_COLUMNID	columnidgrbit; /* grbit from JetSetAccess */
	} JET_OBJECTACMLIST;

#define cObjectAcmCols 3	       /* CONSIDER: Internal */


typedef struct
	{
	unsigned long	cbStruct;
	JET_TABLEID		tableid;
	unsigned long	cRecord;
	JET_COLUMNID	columnidPresentationOrder;
	JET_COLUMNID	columnidcolumnname;
	JET_COLUMNID	columnidcolumnid;
	JET_COLUMNID	columnidcoltyp;
	JET_COLUMNID	columnidCountry;
	JET_COLUMNID	columnidLangid;
	JET_COLUMNID	columnidCp;
	JET_COLUMNID	columnidCollate;
	JET_COLUMNID	columnidcbMax;
	JET_COLUMNID	columnidgrbit;
	JET_COLUMNID	columnidDefault;
	JET_COLUMNID	columnidBaseTableName;
	JET_COLUMNID	columnidBaseColumnName;
	JET_COLUMNID	columnidDefinitionName;
	} JET_COLUMNLIST;

#define cColumnInfoCols 14	       /* CONSIDER: Internal */

typedef struct
	{
	unsigned long	cbStruct;
	JET_COLUMNID	columnid;
	JET_COLTYP	coltyp;
	unsigned short	wCountry;
	unsigned short	langid;
	unsigned short	cp;
	unsigned short	wCollate;       /* Must be 0 */
	unsigned long	cbMax;
	JET_GRBIT	grbit;
	} JET_COLUMNDEF;


typedef struct
	{
	unsigned long	cbStruct;
	JET_COLUMNID	columnid;
	JET_COLTYP	coltyp;
	unsigned short	wCountry;
	unsigned short	langid;
	unsigned short	cp;
	unsigned short	wFiller;       /* Must be 0 */
	unsigned long	cbMax;
	JET_GRBIT	grbit;
	char		szBaseTableName[256];	/* CONSIDER: Too large? */
	char		szBaseColumnName[256];	/* CONSIDER: Too large? */
	} JET_COLUMNBASE;

typedef struct
	{
	unsigned long	cbStruct;
	JET_TABLEID	tableid;
	unsigned long	cRecord;
	JET_COLUMNID	columnidindexname;
	JET_COLUMNID	columnidgrbitIndex;
	JET_COLUMNID	columnidcKey;
	JET_COLUMNID	columnidcEntry;
	JET_COLUMNID	columnidcPage;
	JET_COLUMNID	columnidcColumn;
	JET_COLUMNID	columnidiColumn;
	JET_COLUMNID	columnidcolumnid;
	JET_COLUMNID	columnidcoltyp;
	JET_COLUMNID	columnidCountry;
	JET_COLUMNID	columnidLangid;
	JET_COLUMNID	columnidCp;
	JET_COLUMNID	columnidCollate;
	JET_COLUMNID	columnidgrbitColumn;
	JET_COLUMNID	columnidcolumnname;
	} JET_INDEXLIST;

#define cIndexInfoCols 15	       /* CONSIDER: Internal */

typedef struct
	{
	unsigned long	cbStruct;
	JET_TABLEID	tableid;
	unsigned long	cRecord;
	JET_COLUMNID	columnidReferenceName;
	JET_COLUMNID	columnidgrbit;
	JET_COLUMNID	columnidcColumn;
	JET_COLUMNID	columnidiColumn;
	JET_COLUMNID	columnidReferencingTableName;
	JET_COLUMNID	columnidReferencingColumnName;
	JET_COLUMNID	columnidReferencedTableName;
	JET_COLUMNID	columnidReferencedColumnName;
	} JET_RELATIONSHIPLIST;

/* for backward compatibility */
typedef JET_RELATIONSHIPLIST JET_REFERENCELIST;

#define cReferenceInfoCols 8	       /* CONSIDER: Internal */

typedef struct
	{
	unsigned long	cbStruct;
	unsigned long	ibLongValue;
	unsigned long	itagSequence;
	JET_COLUMNID	columnidNextTagged;
	} JET_RETINFO;

typedef struct
	{
	unsigned long	cbStruct;
	unsigned long	ibLongValue;
	unsigned long	itagSequence;
	} JET_SETINFO;

typedef struct
	{
	unsigned long	cbStruct;
	unsigned long	centriesLT;
	unsigned long	centriesInRange;
	unsigned long	centriesTotal;
	} JET_RECPOS;

typedef struct
	{
	unsigned long	cDiscont;
	unsigned long	cUnfixedMessyPage;
	unsigned long	centriesLT;
	unsigned long	centriesTotal;
	} PERS_OLCSTAT;
	
typedef struct
	{
	unsigned long	cDiscont;
	unsigned long	cUnfixedMessyPage;
	unsigned long	centriesLT;
	unsigned long	centriesTotal;
	unsigned long	cpgCompactFreed;
	} JET_OLCSTAT;

typedef struct
	{
	unsigned long	ctableid;
	JET_TABLEID	rgtableid[1];
	} JET_MGBLIST;

/*** Property Manager Structure ***/
typedef struct
	{
	unsigned long	cbStruct;
	JET_TABLEID 	tableid;
	JET_COLUMNID 	columnidColumnName;
	JET_COLUMNID 	columnidPropertyName;
	JET_COLUMNID	columnidGrbit;
	JET_COLUMNID	columnidPropertyValue;
	JET_COLUMNID	columnidColtyp;
	} JET_PROPERTYLIST;


/************************************************************************/
/*************************     JET CONSTANTS	 ************************/
/************************************************************************/

#define JET_tableidNil			((JET_TABLEID) 	0xFFFFFFFF)

#define	JET_sesidNil			((JET_SESID) 	0xFFFFFFFF)

	/* Max size of a bookmark */

#define JET_cbBookmarkMost		256

	/* Max length of a object/column/index/property name */

#define JET_cbNameMost			64

	/* Max length of a "name.name.name..." construct */

#define JET_cbFullNameMost		255

	/* Max size of non-long-value column data */

#define JET_cbColumnMost		255

	/* Max size of a sort/index key */

#define JET_cbKeyMost			255

	/* Max number of components in a sort/index key */

#define JET_ccolKeyMost			10

	/* Max number of columns in a table/query */

#define JET_ccolTableMost		255

	/* Max Length of a property in the property manager */
#define JET_cbPropertyMost 2048

	/* Largest initial substring of a long value used in an expression */

#define JET_cbExprLVMost		0x8000L	/*** 32 K ***/

	/* Max size of returned (from SQLDriverConnect) conn string */

#define JET_cbConnectMost		255

	/* Max number of levels in an MGB */

#define JET_wGroupLevelMax		12

	/* Size restrictions for Pins */
#define JET_cchPINMax			20
#define JET_cchPINMin			4


	/* System parameter codes for JetSetSystemParameter */

#define JET_paramSysDbPath			0	/* Path to the system database */
#define JET_paramTempPath			1	/* Path to the temporary file directory */
#define JET_paramPfnStatus			2	/* Status callback function */
#define JET_paramPfnError			3	/* Error callback function */
#define JET_paramHwndODBC			4	/* Window handle for ODBC use */
#define JET_paramIniPath			5	/* Path to the ini file */
#define JET_paramPageTimeout		6	/* Red ISAM page timeout value */
#define JET_paramODBCQueryTimeout	7	/* ODBC async query timeout value */
#define JET_paramMaxBuffers			8	/* Bytes to use for page buffers */
#define JET_paramMaxSessions		9	/* Maximum number of sessions */
#define JET_paramMaxOpenTables		10	/* Maximum number of open tables */
#define JET_paramMaxVerPages		11	/* Maximum number of modified pages */
#define JET_paramMaxCursors			12	/* Maximum number of open cursors */
#define JET_paramLogFilePath		13	/* Path to the log file directory */
#define JET_paramMaxOpenTableIndexes 14	/* Maximum open table indexes */
#define JET_paramMaxTemporaryTables	15	/* Maximum concurrent JetCreateIndex */
#define JET_paramLogBuffers			16	/* Maximum log buffers */
#define JET_paramLogFileSectors		17	/* Maximum log sectors per log file */
#define JET_paramLogFlushThreshold	18	/* Log buffer flush threshold */
#define JET_paramBfThrshldLowPrcnt	19	/* Low threshold ( % ) for buffers */
#define JET_paramBfThrshldHighPrcnt	20	/* High threshold ( % ) for buffers */
#define JET_paramWaitLogFlush		21	/* msec for waiting log flush */
#define JET_paramLogFlushPeriod		22	/* msec for waiting log flush */
#define JET_paramLogCheckpointPeriod 23	/* msec for waiting log flush */
#define JET_paramLogWaitingUserMax	24	/* Maximum # user waiting log flush */
#define JET_paramODBCLoginTimeout	25	/* ODBC connection attempt timeout value */
#define JET_paramExprObject			26  /* Expression Evaluation callback */
#define JET_paramGetTypeComp			27	/* Expression Evaluation callback */
#define JET_paramHostVersion			28	/* Host Version callback */
#define JET_paramSQLTraceMode			29	/* Enable/disable SQL tracing */
#define JET_paramRecovery				30	/* Switch for log on/off */
#define JET_paramRestorePath			31	/* Path to restoring directory */
#define JET_paramTransactionLevel	32	/* Transaction level of session */
#define JET_paramSessionInfo			33	/* Session info */
#define JET_paramPageFragment			34	/* Largest page extent considered fragment */
#define JET_paramJetInternal			35	/* Whether internal to JET; if set, allows ISAM to do things which are prevented in general */
#define JET_paramMaxOpenDatabases	36	/*	Maximum number of open databases */
#define JET_paramOnLineCompact		37 /*	Options for compact pages on-line */
#define JET_paramFullQJet		38	/* Allow full QJet functionality */
#define JET_paramRmtXactIsolation	39	/* Do not share connections with other sessions */
#define JET_paramBufLRUKCorrInterval 40
#define JET_paramBufBatchIOMax		41
#define JET_paramPageReadAheadMax	42
#define JET_paramAsynchIOMax		43

#define JET_paramAssertAction		44 /*	debug only determines action on assert */

#define JET_paramEventSource		45	/* NT event log */
#define JET_paramEventId			46	/* NT event id */
#define JET_paramEventCategory		47	/* NT event category */


	/* Flags for JetIdle */

#define JET_bitIdleRemoveReadLocks	0x00000001
#define JET_bitIdleFlushBuffers		0x00000002
#define JET_bitIdleCompact				0x00000004

	/* Flags for JetEndSession */

#define JET_bitForceSessionClosed	0x00000001

	/* Flags for JetOpenDatabase */

#define JET_bitDbReadOnly			0x00000001
#define JET_bitDbExclusive			0x00000002 /* multiple opens allowed */
#define JET_bitDbRemoteSilent		0x00000004
#define JET_bitDbSingleExclusive	0x00000008 /* opened exactly once */

	/* Flags for JetCloseDatabase */

#define JET_bitDbForceClose		0x00000001

	/* Flags for JetCreateDatabase */

#define JET_bitDbEncrypt			0x00000001
#define JET_bitDbVersion10			0x00000002
#define JET_bitDbVersion1x			0x00000004
#define JET_bitDbRecoveryOff 		0x00000008 /* disable logging/recovery */
#define JET_bitDbNoLogging	 		0x00000010 /* no logging */
#define JET_bitDbCompleteConnstr	0x00000020

	/* Flags for JetBackup */

#define JET_bitBackupIncremental		0x00000001
#define JET_bitKeepOldLogs				0x00000002
#define JET_bitOverwriteExisting		0x00000004

	/* Database types */

#define JET_dbidNil			((JET_DBID) 0xFFFFFFFF)
#define JET_dbidNoValid		((JET_DBID) 0xFFFFFFFE) /* used as a flag to indicate that there is no valid dbid */

	/* Flags for JetCreateLink */

/* Can use JET_bitObjectExclusive to cause linked to database to be opened */
/* exclusively.															   */

	/* Flags for JetAddColumn, JetGetColumnInfo, JetOpenTempTable */

#define JET_bitColumnFixed				0x00000001
#define JET_bitColumnTagged			0x00000002
#define JET_bitColumnNotNULL			0x00000004
#define JET_bitColumnVersion			0x00000008
#define JET_bitColumnAutoincrement	0x00000010
#define JET_bitColumnUpdatable		0x00000020 /* JetGetColumnInfo only */
#define JET_bitColumnTTKey				0x00000040 /* JetOpenTempTable only */
#define JET_bitColumnTTDescending	0x00000080 /* JetOpenTempTable only */
#define JET_bitColumnNotLast			0x00000100 /* Installable ISAM option */
#define JET_bitColumnRmtGraphic		0x00000200 /* JetGetColumnInfo */
#define JET_bitColumnMultiValued		0x00000400

	/* Flags for JetMakeKey */

#define JET_bitNewKey				0x00000001
#define JET_bitStrLimit 			0x00000002
#define JET_bitSubStrLimit			0x00000004
#define JET_bitNormalizedKey 		0x00000008
#define JET_bitKeyDataZeroLength	0x00000010

#ifdef DBCS /* johnta: LIKE "ABC" not converted to ="ABC" for Japanese */
#define JET_bitLikeExtra1			0x00000020
#endif /* DBCS */

	/* Flags for ErrDispSetIndexRange */

#define JET_bitRangeInclusive		0x00000001    /* CONSIDER: Internal */
#define JET_bitRangeUpperLimit		0x00000002    /* CONSIDER: Internal */

	/* Constants for JetMove */

#define JET_MoveFirst			(0x80000000)
#define JET_MovePrevious		(-1)
#define JET_MoveNext				(+1)
#define JET_MoveLast				(0x7fffffff)

	/* Flags for JetMove */

#define JET_bitMoveKeyNE		0x00000001
#define JET_bitMoveCheckTS		0x00000002
#define JET_bitMoveInPage		0x00000004

	/* Flags for JetSeek */

#define JET_bitSeekEQ			0x00000001
#define JET_bitSeekLT			0x00000002
#define JET_bitSeekLE			0x00000004
#define JET_bitSeekGE			0x00000008
#define JET_bitSeekGT		 	0x00000010
#define JET_bitSetIndexRange	0x00000020

	/* Flags for JetFastFind */

#define JET_bitFFindBackwards		0x00000001
#define JET_bitFFindFromCursor		0x00000004

	/* Flags for JetCreateIndex */

#define JET_bitIndexUnique		0x00000001
#define JET_bitIndexPrimary		0x00000002
#define JET_bitIndexDisallowNull	0x00000004
#define JET_bitIndexIgnoreNull		0x00000008
#define JET_bitIndexClustered		0x00000010
#define JET_bitIndexIgnoreAnyNull	0x00000020
#define JET_bitIndexReference		0x80000000    /* IndexInfo only */

	/* Flags for index key definition */

#define JET_bitKeyAscending		0x00000000
#define JET_bitKeyDescending		0x00000001


	/* Flags for JetCreateRelationship */

#define JET_bitRelationUnique			0x00000001
#define JET_bitRelationDontEnforce		0x00000002
#define JET_bitRelationInherited		0x00000004
#define JET_bitRelationTestLegal		0x00000008	/* don't create relationship */

#define JET_bitRelationshipMatchMask	0x000000F0
#define JET_bitRelationMatchDefault		0x00000000
#define JET_bitRelationMatchFull		0x00000010

#define JET_bitRelationUpdateActionMask	0x00000F00
#define JET_bitRelationUpdateDisallow	0x00000000
#define JET_bitRelationUpdateCascade	0x00000100
#define JET_bitRelationUpdateSetNull	0x00000200
#define JET_bitRelationUpdateSetDefault	0x00000300

#define JET_bitRelationDeleteActionMask	0x0000F000
#define JET_bitRelationDeleteDisallow	0x00000000
#define JET_bitRelationDeleteCascade	0x00001000
#define JET_bitRelationDeleteSetNull	0x00002000
#define JET_bitRelationDeleteSetDefault	0x00003000

#define JET_bitRelationUserMask			0xFF000000	/* non-enforced values */
#define JET_bitRelationJoinMask			0x03000000
#define JET_bitRelationInner			0x00000000
#define JET_bitRelationLeft				0x01000000
#define JET_bitRelationRight			0x02000000


	/* Flags for JetCreateReference/JetCreateRelationship */
	/* NOTE: use the bitRelationship flags instead! */

#define JET_ReferenceUnique				JET_bitRelationUnique
#define JET_ReferenceDontEnforce		JET_bitRelationDontEnforce
#define JET_ReferenceMatchTypeMask		JET_bitRelationMatchMask
#define JET_ReferenceMatchDefault		JET_bitRelationMatchDefault
#define JET_ReferenceMatchFull			JET_bitRelationMatchFull
#define JET_ReferenceUpdateActionMask	JET_bitRelationUpdateActionMask
#define JET_ReferenceUpdateDisallow		JET_bitRelationUpdateDisallow
#define JET_ReferenceUpdateCascade		JET_bitRelationUpdateCascade
#define JET_ReferenceUpdateSetNull		JET_bitRelationUpdateSetNull
#define JET_ReferenceUpdateSetDefault	JET_bitRelationUpdateSetDefault
#define JET_ReferenceDeleteActionMask	JET_bitRelationDeleteActionMask
#define JET_ReferenceDeleteDisallow		JET_bitRelationDeleteDisallow
#define JET_ReferenceDeleteCascade		JET_bitRelationDeleteCascade
#define JET_ReferenceDeleteSetNull		JET_bitRelationDeleteSetNull
#define JET_ReferenceDeleteSetDefault	JET_bitRelationDeleteSetDefault


	/* Flags for JetOpenTable */

#define JET_bitTableDenyWrite		0x00000001
#define JET_bitTableDenyRead		0x00000002
#define JET_bitTableReadOnly		0x00000004
#define JET_bitTableAppendOnly		0x00000008
#define JET_bitTableUpdatable		0x00000010
#define JET_bitTableScrollable		0x00000020
#define JET_bitTableFixedSet		0x00000040	/* Fixed working set */
#define JET_bitTableInconsistent	0x00000080
#define JET_bitTableBulk			0x00000100
#define JET_bitTableUsePrimaryIndex	0x00000200	/* Use with FixedSet */
#define JET_bitTableSampleData		0x00000400
#define JET_bitTableQuickBrowse		0x00000800	/* Bias optimizer toward index usage */
#define JET_bitTableDDL				0x00001000	/* similar to JET_bitTableBulk, for DDL */
#define JET_bitTablePassThrough		0x00002000  /* Remote DBs Only */
#define JET_bitTableRowReturning	0x00004000

	/* Flags for JetSetQoSql/JetRetrieveQoSql */
#define JET_bitSqlPassThrough		0x00000001	/* Pass through Query returning records */
#define JET_bitSqlSPTBulkOp			0x00000002  /* SPT query returning no table */
	
	/* Flags for JetOpenVtQbe */

#define JET_bitQBEAddBrackets		0x00000001
#define JET_bitQBERemoveEquals		0x00000002

	/* Flags for JetOpenTempTable and ErrIsamOpenTempTable */

#define JET_bitTTIndexed		0x00000001	/* Allow seek */
#define JET_bitTTUnique 		0x00000002	/* Remove duplicates */
#define JET_bitTTUpdatable		0x00000004	/* Allow updates */
#define JET_bitTTScrollable		0x00000008	/* Allow backwards scrolling */

	/* Flags for JetSetColumn */

#define JET_bitSetAppendLV			0x00000001
#define JET_bitSetValidate			0x00000002
#define JET_bitSetOverwriteLV		0x00000004
#define JET_bitSetSizeLV			0x00000008
#define JET_bitSetValidateColumn	0x00000010
#define JET_bitSetZeroLength		0x00000020

	/*	Set column parameter structure for JetSetColumns */

typedef struct {
	JET_COLUMNID			columnid;
	const void _far 		*pvData;
	unsigned long 			cbData;
	JET_GRBIT				grbit;
	unsigned long			ibLongValue;
	unsigned long			itagSequence;
	JET_ERR					err;
} JET_SETCOLUMN;

	/* Options for JetPrepareUpdate */

#define JET_prepInsert			0
#define JET_prepInsertBeforeCurrent	1
#define JET_prepReplace 		2
#define JET_prepCancel			3
#define JET_prepReplaceNoLock		4
#define JET_prepInsertCopy			5

	/* Flags for JetRetrieveColumn */

#define JET_bitRetrieveCopy			0x00000001
#define JET_bitRetrieveFromIndex		0x00000002
#define JET_bitRetrieveCase			0x00000004
#define JET_bitRetrieveTag				0x00000008
#define JET_bitRetrieveRecord			0x80000000
#define JET_bitRetrieveFDB				0x40000000
#define JET_bitRetrieveBookmarks		0x20000000

	/* Retrieve column parameter structure for JetRetrieveColumns */

typedef struct {
	JET_COLUMNID		columnid;
	void _far 			*pvData;
	unsigned long 		cbData;
	unsigned long 		cbActual;
	JET_GRBIT			grbit;
	unsigned long		ibLongValue;
	unsigned long		itagSequence;
	JET_COLUMNID		columnidNextTagged;
	JET_ERR				err;
} JET_RETRIEVECOLUMN;

	/* Flags for JetFillFatCursor */

#define JET_bitFCFillRange		0x00000001
#define JET_bitFCRefreshRange		0x00000002
#define JET_bitFCFillMemos		0x00000004

	/* Flags for JetCommitTransaction */

#define JET_bitCommitFlush		0x00000001

	/* Flags for JetRollback */

#define JET_bitRollbackAll		0x00000001

	/* Flags for JetSetAccess and JetGetAccess */

#define JET_bitACEInheritable		0x00000001

	/* Flags for JetCreateSystemDatabase */

#define JET_bitSysDbOverwrite	0x00000001

	/* Flags for Jet Property Management */
#define JET_bitPropDDL				0x00000001		/* also used for setting */
#define JET_bitPropInherited		0x00000002		/* not used for setting */

	/* JPM Flags that are only used for setting properties */
#define JET_bitPropReplaceOnly		0x00000010
#define JET_bitPropInsertOnly		0x00000020
#define JET_bitPropDeleteOnly		0x00000040
	
	/* InfoLevels for Jet Property Management */
#define JET_PropertyValue				0
#define JET_PropertyCount				1
#define JET_PropertySingleCollection 	2
#define JET_PropertyAllCollections		3

	/* Collate values for JetGetColumnInfo and JetGetIndexInfo */

#define JET_sortBinary			0x0000
#define JET_sortEFGPI			0x0100
#define JET_sortSNIFD			0x0101
#define JET_sortSpanish 		0x0102
#define JET_sortDutch			0x0103
#define JET_sortSweFin			0x0104
#define JET_sortNorDan			0x0105
#define JET_sortIcelandic		0x0106
#define JET_sortCyrillic		0x0107
#define JET_sortCzech			0x0108
#define JET_sortHungarian		0x0109
#define JET_sortPolish			0x010A
#define JET_sortArabic			0x010B
#define JET_sortHebrew			0x010C
#define JET_sortMax				0x010C		/* Max for nonDBCS sort orders */

#ifdef DBCS	/* johnta: Add the new Japanese sorting order */
#define JET_sortJapanese		0x010D
#endif /* DBCS */

#define JET_sortUnknown 		0xFFFF

	/* Paradox ISAM specific collate values */

#define JET_sortPdxIntl 		0x1000
#define JET_sortPdxSwedFin		0x1001
#define JET_sortPdxNorDan		0x1002

	/* Info parameter for JetGetDatabaseInfo */

#define JET_DbInfoFilename		0
#define JET_DbInfoConnect		1
#define JET_DbInfoCountry		2
#define JET_DbInfoLangid		3
#define JET_DbInfoCp			4
#define JET_DbInfoCollate		5
#define JET_DbInfoOptions		6
#define JET_DbInfoTransactions	7
#define JET_DbInfoVersion		8
#define JET_DbInfoIsam			9

	/* Database versions returned by JetGetDatabaseInfo */

#define JET_DbVersion10			0x00010000
#define JET_DbVersion11			0x00010001
#define JET_DbVersion20			0x00020000


	/* Isam specific info returned by JetGetDatabaseInfo */

#define JET_IsamInvalid			0
#define JET_IsamBuiltinRed		1
#define JET_IsamBuiltinBlue		2

#define	JET_IsamInstRed			21
#define JET_IsamInstBlue		22
#define	JET_IsamInstFox			23
#define JET_IsamInstParadox		24
#define JET_IsamInstDbase		25
#define	JET_IsamInstBtrieve		26

#define JET_IsamBuilinMost		JET_BuiltinBlue
#define JET_IsamInstMin			JET_IsamInstRed
#define	JET_IsamInstMost		JET_IsamInstBtrieve

	/* Link specific info for link identification */
#define JET_bitLinkInvalid		0x00000000
#define JET_bitLinkRemote		0x00100000
#define JET_bitLinkBuiltinRed	0x00200000
#define JET_bitLinkBuiltinBlue	0x00300000
#define JET_bitLinkInstRed		0x00400000
#define JET_bitLinkInstBlue		0x00500000
#define JET_bitLinkInstFox		0x00600000
#define JET_bitLinkInstParadox	0x00700000
#define JET_bitLinkInstDbase	0x00800000
#define JET_bitLinkInstBtrieve	0x00900000

#define JET_bitFourByteBookmark		0x00000001
#define	JET_bitContiguousBookmarks	0x00000002

	/* Column data types */

	/* the column types are represented with 4 bits */
	/* make sure the choices below fit!				*/
	/* NOTE:  all comb of the 4 bits are now used! */
	/* CONSIDER:  to allow more datatypes, either 				 */
	/* CONSIDER:  JET_coltypDatabase and JET_coltypTableid	must */
	/* CONSIDER:  change or the 4 bit dependancy must be removed */

#define JET_coltypNil				0
#define JET_coltypBit				1      /* True or False, Never NULL */
#define JET_coltypUnsignedByte		2      /* 1-byte integer, unsigned */
#define JET_coltypShort 			3      /* 2-byte integer, signed */
#define JET_coltypLong				4      /* 4-byte integer, signed */
#define JET_coltypCurrency			5      /* 8 byte integer, signed */
#define JET_coltypIEEESingle		6      /* 4-byte IEEE single precision */
#define JET_coltypIEEEDouble		7      /* 8-byte IEEE double precision */
#define JET_coltypDateTime			8      /* Integral date, fractional time */
#define JET_coltypBinary			9      /* Binary data, < 255 bytes */
#define JET_coltypText				10     /* ANSI text, case insensitive, < 255 bytes */
#define JET_coltypLongBinary		11     /* Binary data, long value */
#define JET_coltypLongText			12     /* ANSI text, long value */

	/* The following are additional types used for query parameters */
	/* NOTE:  Code depends on these being contiguous with the normal coltyps */
	/* CONSIDER:  Remove the above dependency on contiguous coltyps in QJET */

#define JET_coltypDatabase			13		/* Database name parameter */
#define JET_coltypTableid			14		/* Tableid parameter */

#define JET_coltypOLE				15		/* OLE blob */

#define JET_coltypMax				16		/* the number of column types  */
											/* used for validity tests and */
											/* array declarations.		   */

	/* Info levels for JetGetObjectInfo */

#define JET_ObjInfo					0U
#define JET_ObjInfoListNoStats		1U
#define JET_ObjInfoList 			2U
#define JET_ObjInfoSysTabCursor 	3U
#define JET_ObjInfoListACM			4U /* Blocked by JetGetObjectInfo */
#define JET_ObjInfoNoStats			5U
#define JET_ObjInfoSysTabReadOnly	6U
#define JET_ObjInfoRulesLoaded		7U
#define JET_ObjInfoMax				8U

	/* Info levels for JetGetTableInfo */

#define JET_TblInfo				0U
#define JET_TblInfoName			1U
#define JET_TblInfoDbid			2U
#define JET_TblInfoMostMany  	3U
#define JET_TblInfoRvt			4U
#define JET_TblInfoOLC			5U
#define JET_TblInfoResetOLC 	6U
#define JET_TblInfoSpaceUsage	7U
#define JET_TblInfoDumpTable	8U

	/* Info levels for JetGetIndexInfo and JetGetTableIndexInfo */

#define JET_IdxInfo					0U
#define JET_IdxInfoList 			1U
#define JET_IdxInfoSysTabCursor 	2U
#define JET_IdxInfoOLC				3U
#define JET_IdxInfoResetOLC			4U

	/* Info levels for JetGetReferenceInfo and JetGetTableReferenceInfo */

#define JET_ReferenceInfo		0U
#define JET_ReferenceInfoReferencing	1U
#define JET_ReferenceInfoReferenced	2U
#define JET_ReferenceInfoAll		3U
#define JET_ReferenceInfoCursor 	4U

	/* Info levels for JetGetColumnInfo and JetGetTableColumnInfo */

#define JET_ColInfo			0U
#define JET_ColInfoList 		1U

	/* CONSIDER: Info level 2 is valid */

#define JET_ColInfoSysTabCursor 	3U
#define JET_ColInfoBase 		4U


	/* Attribute types for query definitions */

#define JET_qoaBeginDef 		0
#define JET_qoaOperation		1
#define JET_qoaParameter		2
#define JET_qoaOptions			3
#define JET_qoaDatabase 		4
#define JET_qoaInputTable		5
#define JET_qoaOutput			6
#define JET_qoaJoin			7
#define JET_qoaRestriction		8
#define JET_qoaGroup			9
#define JET_qoaGroupRstr		10
#define JET_qoaOrdering 		11
#define JET_qoaEndDef			255
#define JET_qoaValidLeast		JET_qoaOperation
#define JET_qoaValidMost		JET_qoaOrdering


	/* Query object options */

#define JET_bitFqoOutputAllCols 	0x0001
#define JET_bitFqoRemoveDups		0x0002
#define JET_bitFqoOwnerAccess		0x0004
#define JET_bitFqoDistinctRow		0x0008
#define JET_bitFqoTop				0x0010
#define JET_bitFqoPercent			0x0020
#define JET_bitFqoCorresponding		0x0040 /* JET_qopSetOperation */

	/* Query object join type */

#define JET_fjoinInner			1
#define JET_fjoinLeftOuter		2
#define JET_fjoinRightOuter		3

	/* Query object operations */

#define JET_qopSelect			1
#define JET_qopSelectInto		2
#define JET_qopInsertSelection	3
#define JET_qopUpdate			4
#define JET_qopDelete			5
#define JET_qopTransform		6
#define JET_qopDDL				7
#define JET_qopSqlPassThrough	8
#define JET_qopSetOperation		9
#define JET_qopSPTBulk			10

#define JET_bitqopSelect			0x0000
#define JET_bitqopTransform			0x0010
#define JET_bitqopDelete			0x0020
#define JET_bitqopUpdate			0x0030
#define JET_bitqopInsertSelection	0x0040
#define JET_bitqopSelectInto		0x0050
#define JET_bitqopDDL				0x0060
#define JET_bitqopSqlPassThrough	0x0070
#define JET_bitqopSetOperation		0x0080
#define JET_bitqopSPTBulk			0x0090

	/* Engine Object Types */

#define JET_objtypNil			0
#define JET_objtypTable 		1
#define JET_objtypDb			2
#define JET_objtypContainer		3
#define JET_objtypSQLLink		4
#define JET_objtypQuery 		5
#define JET_objtypLink			6
#define JET_objtypTemplate		7
#define JET_objtypRelationship		8

	/* All types less than JET_objtypClientMin are reserved by JET */

#define JET_objtypClientMin		0x8000

	/* Security Constant Values */

#define JET_cchUserNameMax		20
#define JET_cchPasswordMax		14

	/* Security Access Masks */

#define JET_acmNoAccess 		0x00000000L
#define JET_acmFullAccess		0x000FFFFFL

#define JET_acmSpecificMask		0x0000FFFFL
#define JET_acmSpecific_1		0x00000001L
#define JET_acmSpecific_2		0x00000002L
#define JET_acmSpecific_3		0x00000004L
#define JET_acmSpecific_4		0x00000008L
#define JET_acmSpecific_5		0x00000010L
#define JET_acmSpecific_6		0x00000020L
#define JET_acmSpecific_7		0x00000040L
#define JET_acmSpecific_8		0x00000080L
#define JET_acmSpecific_9		0x00000100L
#define JET_acmSpecific_10		0x00000200L
#define JET_acmSpecific_11		0x00000400L
#define JET_acmSpecific_12		0x00000800L
#define JET_acmSpecific_13		0x00001000L
#define JET_acmSpecific_14		0x00002000L
#define JET_acmSpecific_15		0x00004000L
#define JET_acmSpecific_16		0x00008000L

#define JET_acmStandardMask		0x00FF0000L
#define JET_acmDelete			0x00010000L
#define JET_acmReadControl		0x00020000L
#define JET_acmWriteDac 		0x00040000L
#define JET_acmWriteOwner		0x00080000L

#define JET_acmTblCreate		(JET_acmSpecific_1)
#define JET_acmTblAccessRcols		(JET_acmSpecific_2)
#define JET_acmTblReadDef		(JET_acmSpecific_3)
#define JET_acmTblWriteDef		(JET_acmSpecific_4)
#define JET_acmTblRetrieveData		(JET_acmSpecific_5)
#define JET_acmTblInsertData		(JET_acmSpecific_6)
#define JET_acmTblReplaceData		(JET_acmSpecific_7)
#define JET_acmTblDeleteData		(JET_acmSpecific_8)

#define JET_acmDbCreate 		(JET_acmSpecific_1)
#define JET_acmDbOpen			(JET_acmSpecific_2)

	/* Compact Options */

#define JET_bitCompactEncrypt		0x00000001	/* Dest is encrypted */
#define JET_bitCompactDecrypt		0x00000002	/* Dest is not encrypted */
#define JET_bitCompactDontCopyLocale	0x00000004	/* Don't copy locale from source to dest */
#define JET_bitCompactVersion10		0x00000008	/* Destination is version 1.0 format */
#define JET_bitCompactVersion1x		0x00000010	/* Destination is version 1.x format */

	/* On-line Compact Options */

#define JET_bitCompactOn	 		0x00000001	/* enable on-line compaction */

	/* Repair Notification Types */

#define JET_rntSelfContained		0	/* CONSIDER: These are SNCs */
#define JET_rntDeletedIndex		1
#define JET_rntDeletedRec		2
#define JET_rntDeletedLv		3
#define JET_rntTruncated		4

	/* Status Notification Processes */

#define JET_snpIndex			0
#define JET_snpQuery			1
#define JET_snpRepair			2
#define JET_snpImex				3
#define JET_snpCompact			4
#define JET_snpFastFind 		5
#define JET_snpODBCNotReady		6
#define JET_snpQuerySort		7
#define JET_snpRestore			8

	/* Status Notification Types */

#define JET_sntProgress 		0	/* callback for progress */
#define JET_sntMessage			1
#define JET_sntBulkRecords		2	/* callback for # rec for bulk op */
#define JET_sntFail				3	/* callback for failure during progress */
#define JET_sntErrCount 		4	/* callback for err count */
#define JET_sntBegin			5	/* callback for beginning of operation */
#define JET_sntComplete 		6	/* callback for completion of operation */
#define JET_sntCantRollback		7	/* callback for no rollback */
#define JET_sntRestoreMap		8	/* callback for restore map */

	/* Message codes for JET_snpCompact */

#define JET_sncCopyObject		0	/* Starting to copy object */
#define JET_sncCopyFailed		1	/* Copy of this object failed */
#define JET_sncYield			2	/* Client can yield/check for user interrupt */
#define JET_sncTransactionFull		3	/* Client can yield/check for user interrupt */
#define JET_sncAboutToWrap		4	/* Find find is about to wrap */

	/* Message codes for JET_snpODBCNotReady */
#define JET_sncODBCNotReady		0	/* Waiting for results from ODBC */


	/* Constants for the [ODBC] section of JET.INI */

#define JET_SQLTraceCanonical	0x0001	/* Output ODBC Generic SQL */

	/* Constants for the [Debug] section of JET.INI */

	/* APITrace */

#define JET_APITraceEnter	0x0001
#define JET_APITraceExit	0x0002
#define JET_APITraceExitError	0x0004
#define JET_APIBreakOnError	0x0008
#define JET_APITraceCount	0x0010
#define JET_APITraceNoIdle	0x0020
#define JET_APITraceParameters	0x0040

	/* IdleTrace */

#define JET_IdleTraceCursor	0x0001
#define JET_IdleTraceBuffer	0x0002
#define JET_IdleTraceFlush	0x0004

	/* AssertAction */

#define JET_AssertExit		0x0000		/* Exit the application */
#define JET_AssertBreak 	0x0001		/* Break to debugger */
#define JET_AssertMsgBox	0x0002		/* Display message box */
#define JET_AssertStop		0x0004		/* Alert and stop */

	/* IOTrace */

#define JET_IOTraceAlloc	0x0001		/* DB Page Allocation */
#define JET_IOTraceFree 	0x0002		/* DB Page Free */
#define JET_IOTraceRead 	0x0004		/* DB Page Read */
#define JET_IOTraceWrite	0x0008		/* DB Page Write */
#define JET_IOTraceError	0x0010		/* DB Page I/O Error */

	/* MemTrace */

#define JET_MemTraceAlloc	0x0001		/* Memory allocation */
#define JET_MemTraceRealloc	0x0002		/* Memory reallocation */
#define JET_MemTraceFree	0x0004		/* Memory free */

	/* RmtTrace */

#define JET_RmtTraceError	0x0001	/* Remote server error message */
#define JET_RmtTraceSql		0x0002	/* Remote SQL Prepares & Exec's */
#define JET_RmtTraceAPI		0x0004	/* Remote ODBC API calls */
#define JET_RmtTraceODBC	0x0008
#define JET_RmtSyncODBC		0x0010	/* Turn on ODBC Sync mode */

/**********************************************************************/
/***********************     ERROR CODES     **************************/
/**********************************************************************/

/* SUCCESS */

#define JET_errSuccess			 0    /* Successful Operation */

/* ERRORS */

#define JET_wrnNyi							-1    /* Function Not Yet Implemented */

/*	SYSTEM errors
/**/
#define JET_errRfsFailure			   		-100	/* JET_errRfsFailure */
#define JET_errRfsNotArmed					-101	/* JET_errRfsFailure */
#define JET_errFileClose					-102	/* Could not close DOS file */
#define JET_errNoMoreThreads				-103	/* Could not start thread */
#define JET_errNoComputerName	  			-104	/* fail to get computername */
#define JET_errTooManyIO		  			-105	/* System busy due to too many IOs */

/*	BUFFER MANAGER errors
/**/
#define wrnBFNotSynchronous					200			/* Buffer page evicted */
#define wrnBFPageNotFound		  			201			/* Page not found */
#define errBFInUse				  			-202		/* Cannot abandon buffer */

/*	DIRECTORY MANAGER errors
/**/
#define errPMOutOfPageSpace					-300		/* Out of page space */
#define errPMItagTooBig 		  			-301		/* Itag too big */
#define errPMRecDeleted 		  			-302		/* Record deleted */
#define errPMTagsUsedUp 		  			-303		/* Tags used up */
#define wrnBMConflict			  			304     	/* conflict in BM Clean up */
#define errDIRNoShortCircuit	  			-305		/* No Short Circuit Avail */
#define errDIRCannotSplit		  			-306		/* Cannot horizontally split FDP */
#define errDIRTop				  			-307		/* Cannot go up */
#define errDIRFDP							308			/* On an FDP Node */
#define errDIRNotSynchronous				-309		/* May have left critical section */
#define wrnDIREmptyPage						310			/* Moved through empty page */
#define errSPConflict						-311		/* Device extent being extended */
#define wrnNDFoundLess						312			/* Found Less */
#define wrnNDFoundGreater					313			/* Found Greater */
#define errNDOutSonRange					-314		/* Son out of range */
#define errNDOutItemRange					-315		/* Item out of range */
#define errNDGreaterThanAllItems 			-316		/* Greater than all items */
#define errNDLastItemNode					-317		/* Last node of item list */
#define errNDFirstItemNode					-318		/* First node of item list */
#define wrnNDDuplicateItem					319			/* Duplicated Item */
#define errNDNoItem							-320		/* Item not there */
#define JET_wrnRemainingVersions 			321			/* Some versions couldn't be cleaned */
#define JET_wrnPreviousVersion				322			/* Version already existed */
#define JET_errPageBoundary					-323		/* Reached Page Boundary */
#define JET_errKeyBoundary		  			-324		/* Reached Key Boundary */
#define errDIRInPageFather  				-325		/* sridFather in page to free

/*	RECORD MANAGER errors
/**/
#define wrnFLDKeyTooBig 					400			/* Key too big (truncated it) */
#define errFLDTooManySegments				-401		/* Too many key segments */
#define wrnFLDNullKey						402			/* Key is entirely NULL */
#define wrnFLDOutOfKeys 					403			/* No more keys to extract */
#define wrnFLDNullSeg						404			/* Null segment in key */
#define wrnRECLongField 					405			/* Separated long field */
#define JET_wrnRecordFoundGreater			JET_wrnSeekNotEqual
#define JET_wrnRecordFoundLess    			JET_wrnSeekNotEqual
#define JET_errColumnIllegalNull  			JET_errNullInvalid

/*	LOGGING/RECOVERY errors
/**/
#define JET_errRestoreFailed   				-500		/* Restore failed */
#define JET_errLogFileCorrupt		  		-501		/* Log file is corrupt */
#define errLGNoMoreRecords					-502		/* Last log record read */
#define JET_errNoBackupDirectory 			-503		/* No backup directory given */
#define JET_errBackupDirectoryNotEmpty 		-504		/* The backup directory is not emtpy */
#define JET_errBackupInProgress 			-505		/* Backup is active already */
#define JET_errFailRestoreDatabase 			-506		/* Fail to restore (copy) database */
#define JET_errNoDatabasesForRestore 		-507		/* No databases for restor found */
#define JET_errMissingLogFile	   			-508		/* jet.log for restore is missing */
#define JET_errMissingPreviousLogFile		-509		/* Missing the log file for check point */
#define JET_errLogWriteFail					-510		/* Fail when writing to log file */
#define JET_errLogNotContigous	 			-511		/* Fail to incremental backup for non-contiguous generation number */
#define JET_errFailToMakeTempDirectory		-512		/* Fail to make a temp directory */
#define JET_errFailToCleanTempDirectory		-513		/* Fail to clean up temp directory */
#define JET_errBadLogVersion  	  			-514		/* Version of log file is not compatible with Jet version */
#define JET_errBadNextLogVersion   			-515		/* Version of next log file is not compatible with current one */
#define JET_errLoggingDisabled 				-516		/* Log is not active */
#define JET_errLogBufferTooSmall			-517		/* Log buffer is too small for recovery */
#define errLGNotSynchronous					-518		/* retry to LGLogRec */

#define JET_errFeatureNotAvailable	-1001 /* API not supported */
#define JET_errInvalidName		-1002 /* Invalid name */
#define JET_errInvalidParameter 	-1003 /* Invalid API parameter */
#define JET_wrnColumnNull		 1004 /* Column is NULL-valued */
#define JET_errReferenceNotFound	-1005 /* No such reference */
#define JET_wrnBufferTruncated		 1006 /* Buf too short, data truncated */
#define JET_wrnDatabaseAttached 	 1007 /* Database is already attached */
#define JET_wrnOnEndPoint		 1008 /* On end point */
#define JET_wrnSortOverflow		 1009 /* Sort does not fit in memory */
#define JET_errInvalidDatabaseId	-1010 /* Invalid database id */
#define JET_errOutOfMemory		-1011 /* Out of Memory */
#define JET_errCantAllocatePage 	-1012 /* Couldn't allocate a page */
#define JET_errNoMoreCursors		-1013 /* Max # of cursors allocated */
#define JET_errOutOfBuffers		-1014 /* JET_errOutOfBuffers */
#define JET_errTooManyIndexes		-1015 /* Too many indexes */
#define JET_errTooManyKeys		-1016 /* Too many columns in an index */
#define JET_errRecordDeleted		-1017 /* Record has been deleted */
#define JET_errReadVerifyFailure	-1018 /* Read verification error */
#define JET_errFilesysVersion		-1019 /* Obsolete database format */
#define JET_errNoMoreFiles		-1020 /* No more file handles */
#define JET_errDiskNotReady		-1021 /* Disk not ready */
#define JET_errDiskIO			-1022 /* JET_errDiskIO */
#define JET_errInvalidPath		-1023 /* JET_errInvalidPath */
#define JET_errFileShareViolation	-1024 /* JET_errFileShareViolation */
#define JET_errFileLockViolation	-1025 /* JET_errFileLockViolation */
#define JET_errRecordTooBig		-1026 /* JET_errRecordTooBig */
#define JET_errTooManyOpenDatabases	-1027 /* Database limit reached */
#define JET_errInvalidDatabase		-1028 /* This isn't a database */
#define JET_errNotInitialized		-1029 /* JetInit not yet called */
#define JET_errAlreadyInitialized	-1030 /* JetInit already called */
#define JET_errFileLockingUnavailable	-1031 /* JET_errFileLockingUnavailable */
#define JET_errFileAccessDenied 	-1032 /* JET_errFileAccessDenied */
#define JET_errSharingBufferExceeded	-1033 /* OS sharing buffer exceeded */
#define JET_errQueryNotSupported	-1034 /* Query support unavailable */
#define JET_errSQLLinkNotSupported	-1035 /* SQL Link support unavailable */
#define JET_errTaskLimitExceeded	-1036 /* Too many client tasks */
#define JET_errUnsupportedOSVersion	-1037 /* Unsupported OS version */
#define JET_errBufferTooSmall		-1038 /* Buffer is too small */
#define JET_wrnSeekNotEqual		 1039 /* SeekLE or SeekGE didn't find exact match */
#define JET_errTooManyColumns		-1040 /* Too many columns defined */
#define JET_errTooManyFixedColumns	-1041 /* Too many fixed columns defined */
#define JET_errTooManyVariableColumns	-1042 /* Too many variable columns defined */
#define JET_errContainerNotEmpty	-1043 /* Container is not empty */
#define JET_errInvalidFilename		-1044 /* Filename is invalid */
#define JET_errInvalidBookmark		-1045 /* Invalid bookmark */
#define JET_errColumnInUse		-1046 /* Column used in an index */
#define JET_errInvalidBufferSize	-1047 /* Data buffer doesn't match column size */
#define JET_errColumnNotUpdatable	-1048 /* Can't set column value */
#define JET_wrnCommitNotFlushed 	 1049 /* Commit did not flush to disk */
#define JET_errAbortSalvage		-1050 /* Forced Salvager abort */
#define JET_errIndexInUse		-1051 /* Index is in use */
#define JET_errLinkNotSupported 	-1052 /* Link support unavailable */
#define JET_errNullKeyDisallowed	-1053 /* Null keys are disallowed on index */
#define JET_errNotInTransaction 	-1054 /* JET_errNotInTransaction */
#define JET_wrnNoErrorInfo		 1055 /* No extended error information */
#define JET_errInstallableIsamNotFound	-1056 /* Installable ISAM not found */
#define JET_errOperationCancelled	-1057 /* Operation canceled by client */
#define JET_wrnNoIdleActivity		 1058 /* No idle activity occured */
#define JET_errTooManyActiveUsers	-1059 /* Too many active database users */
#define JET_errInvalidAppend		-1060 /* Cannot append long value */
#define JET_errInvalidCountry		-1061 /* Invalid or unknown country code */
#define JET_errInvalidLanguageId	-1062 /* Invalid or unknown language id */
#define JET_errInvalidCodePage		-1063 /* Invalid or unknown code page */
#define JET_errCantBuildKey		-1064 /* Can't build key for this sort order. */
#define JET_errIllegalReentrancy	-1065 /* Re-entrancy on same cursor family */
#define JET_errIllegalRelationship	-1066 /* Can't create relationship */
#define JET_wrnNoWriteLock					1067	/* No write lock at transaction level 0 */
#define JET_errDBVerFeatureNotAvailable	-1067 /* API not supported using old database format*/

#define JET_errCantBegin		-1101 /* Cannot BeginSession */
#define JET_errWriteConflict		-1102 /* Write lock failed due to outstanding write lock */
#define JET_errTransTooDeep		-1103 /* Xactions nested too deeply */
#define JET_errInvalidSesid		-1104 /* Invalid session handle */
#define JET_errReadConflict		-1105 /* Commit lock failed due to outstanding read lock */
#define JET_errCommitConflict		-1106 /* Read lock failed due to outstanding commit lock */
#define JET_errSessionWriteConflict	-1107 /* Another session has private version of page */
#define JET_errInTransaction		-1108 /* Operation not allowed within a transaction */

#define JET_errDatabaseDuplicate	-1201 /* Database already exists */
#define JET_errDatabaseInUse		-1202 /* Database in use */
#define JET_errDatabaseNotFound 	-1203 /* No such database */
#define JET_errDatabaseInvalidName	-1204 /* Invalid database name */
#define JET_errDatabaseInvalidPages	-1205 /* Invalid number of pages */
#define JET_errDatabaseCorrupted	-1206 /* non-db file or corrupted db */
#define JET_errDatabaseLocked		-1207 /* Database exclusively locked */
#define JET_wrnDatabaseEncrypted	 1208 /* Database is encrypted */

#define JET_wrnTableEmpty			 1301 /* Open an empty table */
#define JET_errTableLocked			-1302 /* Table is exclusively locked */
#define JET_errTableDuplicate		-1303 /* Table already exists */
#define JET_errTableInUse			-1304 /* Table is in use, cannot lock */
#define JET_errObjectNotFound		-1305 /* No such table or object */
#define JET_errCannotRename			-1306 /* Cannot rename temporary file */
#define JET_errDensityInvalid		-1307 /* Bad file/index density */
#define JET_errTableNotEmpty		-1308 /* Cannot define clustered index */
#define JET_errTableNotLocked		-1309 /* No DDLs w/o exclusive lock */
#define JET_errInvalidTableId		-1310 /* Invalid table id */
#define JET_errTooManyOpenTables	-1311 /* Cannot open any more tables */
#define JET_errIllegalOperation 	-1312 /* Oper. not supported on table */
#define JET_wrnExecSegReleased		 1313 /* Query Execution segment is released */
#define JET_errObjectDuplicate		-1314 /* Table or object name in use */
#define JET_errRulesLoaded			-1315 /* Rules loaded, can't define more */
#define JET_errInvalidObject		-1316 /* object is invalid for operation */

#define JET_errIndexCantBuild		-1401 /* Cannot build clustered index */
#define JET_errIndexHasPrimary		-1402 /* Primary index already defined */
#define JET_errIndexDuplicate		-1403 /* Index is already defined */
#define JET_errIndexNotFound		-1404 /* No such index */
#define JET_errIndexMustStay		-1405 /* Cannot delete clustered index */
#define JET_errIndexInvalidDef		-1406 /* Illegal index definition */
#define JET_errSelfReference		-1407 /* Referencing/Referenced index is the same */
#define JET_errIndexHasClustered	-1408 /* Clustered index already defined */

#define JET_errColumnLong			-1501 /* column value is long */
#define JET_errColumnNoChunk		-1502 /* no such chunk in field */
#define JET_errColumnDoesNotFit 	-1503 /* Field will not fit in record */
#define JET_errNullInvalid			-1504 /* Null not valid */
#define JET_errColumnIndexed		-1505 /* Column indexed, cannot delete */
#define JET_errColumnTooBig			-1506 /* Field length is > maximum */
#define JET_errColumnNotFound		-1507 /* No such column */
#define JET_errColumnDuplicate		-1508 /* Field is already defined */
#define JET_errTaggedDefault		-1509 /* No defaults on tagged fields */
#define JET_errColumn2ndSysMaint	-1510 /* Second autoinc or version column */
#define JET_errInvalidColumnType	-1511 /* Invalid column data type */
#define JET_wrnColumnMaxTruncated	 1512 /* Max length too big, truncated */
#define JET_errColumnCannotIndex	-1513 /* Cannot index Bit,LongText,LongBinary */
#define JET_errTaggedNotNULL		-1514 /* No non-NULL tagged fields */
#define JET_errNoCurrentIndex		-1515 /* Invalid w/o a current index */
#define JET_errKeyIsMade			-1516 /* The key is completely made */
#define JET_errBadColumnId			-1517 /* Column Id Incorrect */
#define JET_errBadItagSequence		-1518 /* Bad itagSequence for tagged column */
#define JET_errColumnInRelationship	-1519 /* Cannot delete, column participates in relationship */
#define JET_wrnCopyLongValue		1520	/*	Single instance column bursted */
#define JET_errCannotBeTagged		-1521 /* AutoIncrement and Version cannot be tagged */

#define JET_errRecordNotFound		-1601 /* The key was not found */
#define JET_errRecordNoCopy			-1602 /* No working buffer */
#define JET_errNoCurrentRecord		-1603 /* Currency not on a record */
#define JET_errRecordClusteredChanged	-1604 /* Primary key may not change */
#define JET_errKeyDuplicate			-1605 /* Illegal duplicate key */
#define JET_errCannotInsertBefore	-1606 /* Cannot insert before current */
#define JET_errAlreadyPrepared		-1607 /* Already copy/clear current */
#define JET_errKeyNotMade			-1608 /* No call to JetMakeKey */
#define JET_errUpdateNotPrepared	-1609 /* No call to JetPrepareUpdate */
#define JET_wrnDataHasChanged		 1610 /* Data has changed */
#define JET_errDataHasChanged		-1611 /* Data has changed; operation aborted */
#define JET_errIntegrityViolationMaster -1612 /* References to key exist */
#define JET_errIntegrityViolationSlave	-1613 /* No referenced key exists */
#define JET_wrnMuchDataChanged		 1614 /* Repaint whole datasheet */
#define JET_errIncorrectJoinKey		-1615 /* Master key does not match lookup key */
#define JET_wrnKeyChanged			 1618 /* Moved to new key */
#define JET_wrnSyncedToDelRec		 1699 /* CONSIDER: QJET INTERNAL */
#define JET_errRedoPrepUpdate		 1698 /* CONSIDER: QJET INTERNAL(jpbulk.c)*/

#define JET_errTooManySorts			-1701 /* Too many sort processes */
#define JET_errInvalidOnSort		-1702 /* Invalid operation on Sort */

#define JET_errConfigOpenError		-1801 /* Config. file can't be opened */
#define JET_errSysDatabaseOpenError	-1802 /* System db could not be opened */
#define JET_errTempFileOpenError	-1803 /* Temp file could not be opened */
#define JET_errDatabaseOpenError	-1804 /* Database file can't be opened */
#define JET_errTooManyAttachedDatabases -1805 /* Too many open databases */
#define JET_errDatabaseCloseError	-1806 /* Db file could not be closed */
#define JET_errTooManyOpenFiles 	-1807 /* Too many files open */
#define JET_errDiskFull 			-1808 /* No space left on disk */
#define JET_errPermissionDenied 	-1809 /* Permission denied */
#define JET_errSortFileOpenError	-1810 /* Could not open sort file */
#define JET_errFileNotFound			-1811 /* File not found */
#define JET_errTempDiskFull			-1812 /* No space left on disk */
#define JET_wrnFileOpenReadOnly		1813 /* Database file is read only */

#define JET_errAfterInitialization	-1850 /* Cannot Restore after init. */
#define JET_errSeriesTooLong		-1851 /* New log generation id too big */
#define JET_errLogCorrupted			-1852 /* Logs could not be interpreted */

#define JET_errCannotOpenSystemDb	-1901 /* failed sysdb on beginsession */
#define JET_errInvalidLogon			-1902 /* invalid logon at beginsession */
#define JET_errInvalidAccountName	-1903 /* invalid account name */
#define JET_errInvalidSid			-1904 /* invalid SID */
#define JET_errInvalidPassword		-1905 /* invalid password */
#define JET_errInvalidOperation 	-1906 /* invalid operation */
#define JET_errAccessDenied			-1907 /* access denied */
#define JET_errNoMSysAccounts		-1908 /* Can't open MSysAccounts */
#define JET_errNoMSysGroups			-1909 /* Can't open MSysGroups */
#define JET_errInvalidPin			-1910	/* invalid pin */

#define JET_errRmtSqlError			-2001 /* RMT: ODBC call failed */
#define JET_errRmtMissingOdbcDll	-2006 /* RMT: Can't load ODBC DLL */
#define JET_errRmtInsertFailed		-2007 /* RMT: Insert statement failed */
#define JET_errRmtDeleteFailed		-2008 /* RMT: Delete statement failed */
#define JET_errRmtUpdateFailed		-2009 /* RMT: Update statement failed */
#define JET_errRmtColDataTruncated	-2010 /* RMT: data truncated */
#define JET_errRmtTypeIncompat		-2011 /* RMT: Can't create JET type on server */
#define JET_errRmtCreateTableFailed	-2012 /* RMT: Create table stmt failed */
#define JET_errRmtNotSupported		-2014 /* RMT: Function not legal for rdb */
#define JET_errRmtValueOutOfRange	-2020 /* RMT: Data value out of range */
#define JET_errRmtStillExec		-2021 /* RMT INTERNAL: SQL_STILL_EXECUTING */
#define JET_errRmtQueryTimeout		-2022 /* RMT: Server Not Responding */
#define JET_wrnRmtNeedLvData		 2023 /* RMT: Internal only - need Lv data */
#define JET_wrnFatCursorUseless		 2024 /* Fat cursor has no effect ***/
#define JET_errRmtWrongSPVer		-2025 /* RMT: INTERNAL: wrong SProc ver ***/
#define JET_errRmtLinkOutOfSync		-2026 /* RMT: the def for the rmt tbl has changed */
#define JET_errRmtDenyWriteIsInvalid	-2027 /* RMT: Can't open DenyWrite */
#define JET_errRmtDriverCantConv	-2029 /* RMT: INTERNAL: driver cannot convert */
#define JET_errRmtTableAmbiguous	-2030 /* RMT: Table ambiguous: must specifier owner */
#define JET_errRmtBogusConnStr		-2031 /* RMT: SPT: Bad connect string */

#define JET_errQueryInvalidAttribute	-3001 /* Invalid query attribute */
#define JET_errQueryOnlyOneRow		-3002 /* Only 1 such row allowed */
#define JET_errQueryIncompleteRow	-3003 /* Missing value in row */
#define JET_errQueryInvalidFlag 	-3004 /* Invalid value in Flag field */
#define JET_errQueryCycle		-3005 /* Cycle in query definition */
#define JET_errQueryInvalidJoinTable	-3006 /* Invalid table in join */
#define JET_errQueryAmbigRef		-3007 /* Ambiguous column reference */
#define JET_errQueryUnboundRef		-3008 /* Cannot bind name */
#define JET_errQueryParmRedef		-3009 /* Parm redefined with different type */
#define JET_errQueryMissingParms	-3010 /* Too few parameters supplied */
#define JET_errQueryInvalidOutput	-3011 /* Invalid query output */
#define JET_errQueryInvalidHaving	-3012 /* HAVING clause without aggregation */
#define JET_errQueryDuplicateAlias	-3013 /* Duplicate output alias */
#define JET_errQueryInvalidMGBInput	-3014 /* Cannot input from MGB */
#define JET_errQueryInvalidOrder	-3015 /* Invalid ORDER BY expression */
#define JET_errQueryTooManyLevels	-3016 /* Too many levels on MGB */
#define JET_errQueryMissingLevel	-3017 /* Missing intermediate MGB level */
#define JET_errQueryIllegalAggregate	-3018 /* Aggregates not allowed */
#define JET_errQueryDuplicateOutput	-3019 /* Duplicate destination output */
#define JET_errQueryIsBulkOp		-3020 /* Grbit should be set for Bulk Operation */
#define JET_errQueryIsNotBulkOp 	-3021 /* Query is not a Bulk Operation */
#define JET_errQueryIllegalOuterJoin	-3022 /* No inconsistent updates on outer joins */
#define JET_errQueryNullRequired	-3023 /* Column must be NULL */
#define JET_errQueryNoOutputs		-3024 /* Query must have an output */
#define JET_errQueryNoInputTables	-3025 /* Query must have an input */
#define JET_wrnQueryNonUpdatableRvt	 3026 /* Query is not updatable (but IS RVT) */
#define JET_errQueryInvalidAlias	-3027 /* Bogus character in alias name */
#define JET_errQueryInvalidBulkInput	-3028 /* Cannot input from bulk operation */
#define JET_errQueryNotDirectChild	-3029 /* T.* must use direct child */
#define JET_errQueryExprEvaluation	-3030 /* Expression evaluation error */
#define JET_errQueryIsNotRowReturning	-3031 /* Query does not return rows */
#define JET_wrnQueryNonRvt		 3032 /* Can't create RVT, query is static */
#define JET_errQueryParmTypeMismatch	-3033 /* Wrong parameter type given */
#define JET_errQueryChanging		-3034 /* Query Objects are being updated */
#define JET_errQueryNotUpdatable	-3035 /* Operation must use an updatable query */
#define JET_errQueryMissingColumnName	-3036 /* Missing destination column */
#define JET_errQueryTableDuplicate	-3037 /* Repeated table name in FROM list */
#define JET_errQueryIsMGB		-3038 /* Query is an MGB */
#define JET_errQueryInsIntoBulkMGB	-3039 /* Cannot insert into Bulk/MGB */
#define JET_errQueryDistinctNotAllowed	-3040 /* DISTINCT not allowed for MGB */
#define JET_errQueryDistinctRowNotAllow -3041 /* DISTINCTROW not allowed for MGB */
#define JET_errQueryNoDbForParmDestTbl	-3045 /* Dest DB for VT parm not allowed */
#define JET_errQueryDuplicatedFixedSet	-3047 /* Duplicated Fixed Value */
#define JET_errQueryNoDeleteTables	-3048 /* Must specify tables to delete from */
#define JET_errQueryCannotDelete	-3049 /* Cannot delete from specified tables */
#define JET_errQueryTooManyGroupExprs	-3050 /* Too many GROUP BY expressions */
#define JET_errQueryTooManyOrderExprs	-3051 /* Too many ORDER BY expressions */
#define JET_errQueryTooManyDistExprs	-3052 /* Too many DISTINCT output expressions */
#define JET_errQueryBadValueList	-3053 /* Malformed value list in Transform */
#define JET_errConnStrTooLong		-3054 /* Connect string too long */
#define JET_errQueryInvalidParm		-3055 /* Invalid Parmeter Name (>64 char) */
#define JET_errQueryContainsDbParm	-3056 /* Can't get parameters with Db Parm */
#define JET_errQueryBadUpwardRefed	-3057 /* Illegally Upward ref'ed */
#define JET_errQueryAmbiguousJoins	-3058 /* Joins in a QO are ambiguous */
#define JET_errQueryIsNotDDL		-3059 /* Not a DDL Operation */
#define JET_errNoDbInConnStr		-3060 /* No database in connect string */
#define JET_wrnQueryIsNotRowReturning	 3061 /* Not row returning */
#define JET_errTooManyFindSessions	-3062 /* RVT already has a find session open  */
#define JET_errSingleValueExpected	-3063 /* At most one record with one column can be returned from a scalar subquery */
#define JET_errColumnCountMismatch	-3064 /* Union Query: number of columns in children dont match */
#define JET_errQueryTopNotAllowed	-3065 /* Top not allowed for MGB */
#define JET_errQueryIsDDL			-3066 /* Must set JET_bitTableDDL */
#define JET_errQueryIsCorrupt		-3067 /* Query is Corrupt */
#define JET_errQuerySPTBulkSucceeded -3068 /* INTERNAL only */
#define JET_errSPTReturnedNoRecords -3069 /* SPT marked as RowReturning did not return a table */

#define JET_errExprSyntax		-3100 /* Syntax error in expression */
#define JET_errExprIllegalType		-3101 /* Illegal type in expression */
#define JET_errExprUnknownFunction	-3102 /* Unknown function in expression */

#define JET_errSQLSyntax		-3500 /* Bogus SQL statement type */
#define JET_errSQLParameterSyntax	-3501 /* Parameter clause syntax error */
#define JET_errSQLInsertSyntax		-3502 /* INSERT clause syntax error */
#define JET_errSQLUpdateSyntax		-3503 /* UPDATE clause syntax error */
#define JET_errSQLSelectSyntax		-3504 /* SELECT clause syntax error */
#define JET_errSQLDeleteSyntax		-3505 /* Expected 'FROM' after 'DELETE' */
#define JET_errSQLFromSyntax		-3506 /* FROM clause syntax error */
#define JET_errSQLGroupBySyntax 	-3507 /* GROUP BY clause syntax error */
#define JET_errSQLOrderBySyntax 	-3508 /* ORDER BY clause syntax error */
#define JET_errSQLLevelSyntax		-3509 /* LEVEL syntax error */
#define JET_errSQLJoinSyntax		-3510 /* JOIN syntax error */
#define JET_errSQLTransformSyntax	-3511 /* TRANSFORM syntax error */
#define JET_errSQLHavingSyntax		-3512 /* HAVING clause syntax error */
#define JET_errSQLWhereSyntax		-3513 /* WHERE clause syntax error */
#define JET_errSQLProcedureSyntax	-3514 /* Expected query name after 'PROCEDURE' */
#define JET_errSQLNotEnoughBuf		-3515 /* Buffer too small for SQL string */
#define JET_errSQLMissingSemicolon	-3516 /* Missing ; at end of SQL statement */
#define JET_errSQLTooManyTokens 	-3517 /* Characters after end of SQL statement */
#define JET_errSQLOwnerAccessSyntax -3518 /* OWNERACCESS OPTION syntax error */

#define	JET_errV11NotSupported		-3519 /* not supported in V11 */
#define JET_errV10Format			-3520 /* can be present in V10 format only */
#define JET_errSQLUnionSyntax		-3521 /* UNION query syntax error */
#define JET_errSqlPassThrough		-3523 /* Pass Through query Disallowed */
#define JET_wrnSqlPassThrough		 3524 /* Pass Through query involved */

#define JET_errDDLConstraintSyntax	-3550 /* constraint syntax error */
#define JET_errDDLCreateTableSyntax	-3551 /* create table syntax error */
#define JET_errDDLCreateIndexSyntax	-3552 /* create index syntax error */
#define JET_errDDLColumnDefSyntax	-3553 /* column def syntax error */
#define JET_errDDLAlterTableSyntax	-3554 /* alter table syntax error */
#define JET_errDDLDropIndexSyntax	-3555 /* drop index syntax error */
#define JET_errDDLDropSyntax		-3556 /* drop view/procedure syntax error */
#define JET_errDDLCreateViewSyntax	-3557 /* create view syntax error */

#define JET_errNoSuchProperty	-3600 /* Property was not found */
#define JET_errPropertyTooLarge -3601 /* Small Property larger than 2K */
#define JET_errJPMInvalidForV1x -3602 /* No JPM for V1.x databases */
#define JET_errPropertyExists	-3603 /* Property already exists */
#define JET_errInvalidDelete	-3604 /* DeleteOnly called with non-zero cbData */

#define JET_wrnFindWrapped		 3700 /* Cursor wrapped during fast find */

#define JET_errTLVNativeUserTablesOnly -3700 /* TLVs can only be placed on native user tables/columns */
#define JET_errTLVNoNull		  	   -3701 /* This field cannot be null */
#define JET_errTLVNoBlank			   -3702 /* This column cannot be blank */
#define	JET_errTLVRuleViolation 	   -3703 /* This validation rule must be met */
#define	JET_errTLVInvalidColumn	   	   -3704 /* This TLV property cannot be placed on this column */
#define JET_errTLVExprEvaluation	   -3705 /* Expression evaluation error */
#define JET_errTLVExprUnknownFunc	   -3706 /* Unknown function in TLV expression */
#define JET_errTLVExprSyntax		   -3707 /* Syntax error in TLV expression */

	/* CONSIDER: Remove the following error. */

#define JET_errGeneral			-5001 /* I-ISAM: assert failure */
#define JET_errRecordLocked		-5002 /* I-ISAM: record locked */
#define JET_wrnColumnDataTruncated	 5003 /* I-ISAM: data truncated */
#define JET_errTableNotOpen		-5004 /* I-ISAM: table is not open */
#define JET_errDecryptFail		-5005 /* I-ISAM: incorrect password */
#define JET_wrnCurrencyLost		 5007 /* I-ISAM: currency lost - must first/last */
#define JET_errDateOutOfRange		-5008 /* I-ISAM: invalid date */
#define JET_wrnOptionsIgnored		 5011 /* I-ISAM: options were ignored */
#define JET_errTableNotComplete		-5012 /* I-ISAM: incomplete table definition */
#define JET_errIllegalNetworkOption	-5013 /* I-ISAM: illegal network option */
#define JET_errIllegalTimeoutOption	-5014 /* I-ISAM: illegal timeout option */
#define JET_errNotExternalFormat	-5015 /* I-ISAM: invalid file format */
#define JET_errUnexpectedEngineReturn	-5016 /* I-ISAM: unexpected engine error code */
#define JET_errNumericFieldOverflow     -5017 /* I-ISAM: can't convert to native type */

#define JET_errIndexHasNoPrimary	-5020 /* Paradox: no primary index */
#define JET_errTableSortOrderMismatch	-5021 /* Paradox: sort order mismatch */
#define JET_errNoConfigParameters	-5023 /* Paradox: net path or user name missing */
#define JET_errCantAccessParadoxNetDir	-5024 /* Paradox: bad Paradox net path */
#define JET_errObsoleteLockFile 	-5025 /* Paradox: obsolete lock file */
#define JET_errIllegalCollatingSequence -5026 /* Paradox: invalid sort sequence */
#define JET_errWrongCollatingSequence	-5027 /* Paradox: wrong sort sequence */
#define JET_errCantUseUnkeyedTable	-5028 /* Paradox: can't open unkeyed table */

#define JET_errINFFileError		-5101 /* dBase: invalid .INF file */
#define JET_errCantMakeINFFile		-5102 /* dBase: can't open .INF file */
#define JET_wrnCantMaintainIndex	 5103 /* dBase: unmaintainable index */
#define JET_errMissingMemoFile		-5104 /* dBase: missing memo file */
#define JET_errIllegalCenturyOption	-5105 /* dBase: Illegal century option */
#define JET_errIllegalDeletedOption	-5106 /* dBase: Illegal deleted option */
#define JET_errIllegalStatsOption	-5107 /* dBase: Illegal statistics option */
#define JET_errIllegalDateOption	-5108 /* dBase: Illegal date option */
#define JET_errIllegalMarkOption	-5109 /* dBase: Illegal mark option */
#define JET_wrnDuplicateIndexes		 5110 /* dBase: duplicate indexes in INF file */
#define JET_errINFIndexNotFound		-5111 /* dBase: missing index in INF file */
#define JET_errWrongMemoFileType	-5112 /* dBase: wrong memo file type */
#define JET_errIllegalExactOption       -5113 /* dBase: Illegal exact option */

#define JET_errTooManyLongFields	-5200 /* Btrieve: more than one memo field */
#define JET_errCantStartBtrieve 	-5201 /* Btrieve: wbtrcall.dll missing */
#define JET_errBadConfigParameters	-5202 /* Btrieve: win.ini [btrieve] options wrong */
#define JET_errIndexesChanged		-5203 /* Btrieve: need to GetIndexInfo */
#define JET_errNonModifiableKey 	-5204 /* Btrieve: can't modify record column */
#define JET_errOutOfBVResources 	-5205 /* Btrieve: out of resources */
#define JET_errBtrieveDeadlock		-5206 /* Btrieve: locking deadlock */
#define JET_errBtrieveFailure		-5207 /* Btrieve: Btrieve DLL failure */
#define JET_errBtrieveDDCorrupted	-5208 /* Btrieve: data dictionary corrupted */
#define JET_errBtrieveTooManyTasks	-5209 /* Btrieve: too many tasks */
#define JET_errIllegalIndexDDFOption    -5210 /* Btrieve: Illegal IndexDDF option */
#define JET_errIllegalDataCodePage      -5211 /* Btrieve: Illeagl DataCodePage option */
#define JET_errXtrieveEnvironmentError  -5212 /* Btrieve: Xtrieve INI options bad */
#define JET_errMissingDDFFile           -5213 /* Btrieve: Missing field.ddf */
#define JET_errIlleaglIndexNumberOption -5214 /* Btrieve: Illeagl IndexRenumber option */

	/* Extended error codes must be in the following range. */
	/* Major error codes may not be in this range. */

#define JET_errMinorLeast		-8000
#define JET_errMinorMost		-8999

#define JET_errFindExprSyntax		-8001 /* Syntax error in FastFind expression */
#define JET_errQbeExprSyntax		-8002 /* Syntax error in QBE expression */
#define JET_errInputTableNotFound	-8003 /* Non-existant object in FROM list */
#define JET_errQueryExprSyntax		-8004 /* Syntax error in some query expression */
#define JET_errQodefExprSyntax		-8005 /* Syntax error in expression column */
#define JET_errExpAliasAfterAS		-8006 /* Expected alias after 'AS' in FROM list */
#define JET_errExpBYAfterGROUP		-8007 /* Expected 'BY' after 'GROUP' */
#define JET_errExpBYAfterORDER		-8008 /* Expected 'BY' after 'ORDER' */
#define JET_errExpClsParenAfterColList	-8009 /* Expected ')' after column list */
#define JET_errExpColNameAfterPIVOT	-8010 /* Expected column name after 'PIVOT' */
#define JET_errExpDatabaseAfterIN	-8011 /* Expected database name after 'IN' */
#define JET_errExpDatatypeAfterParmName -8012 /* Expected datatype after parameter name */
#define JET_errExpEqualAfterUpdColName	-8013 /* Expected '=' after update column name */
#define JET_errExpExprAfterON		-8014 /* Expected join expression after 'ON' */
#define JET_errExpExprAfterTRANSFORM	-8015 /* Expected expression after 'TRANSFORM' */
#define JET_errExpExprAfterWHERE	-8016 /* Expected expression after 'WHERE' */
#define JET_errExpGroupClauseInXform	-8017 /* Transform expects GROUP BY clause */
#define JET_errExpGroupingExpr		-8018 /* Expected grouping expression */
#define JET_errExpHavingExpr		-8019 /* Expected HAVING expression */
#define JET_errExpINTOAfterINSERT	-8020 /* Expected 'INTO' after 'INSERT' */
#define JET_errExpJOINAfterJoinType	-8021 /* Expected 'JOIN' after INNER/LEFT/RIGHT */
#define JET_errExpLEVELAfterSelectList	-8022 /* Expected LEVEL after select list */
#define JET_errExpNumberAfterLEVEL	-8023 /* Expected number after 'LEVEL' */
#define JET_errExpONAfterRightTable	-8024 /* Expected 'ON' after right join table */
#define JET_errExpOrderExpr		-8025 /* Expected ordering expression */
#define JET_errExpOutputAliasAfterAS	-8026 /* Expected output alias after 'AS' */
#define JET_errExpOutputExpr		-8027 /* Expected output expression */
#define JET_errExpPIVOTAfterSelectStmt	-8028 /* Expected 'PIVOT' after SELECT statement */
#define JET_errExpRightJoinTable	-8029 /* Expected right join table after 'JOIN' */
#define JET_errExpSELECTAfterInsClause	-8030 /* Expected 'SELECT' after INSERT clause */
#define JET_errExpSELECTAfterXformExpr	-8031 /* Expected 'SELECT' after Transform fact */
#define JET_errExpSETAfterTableName	-8032 /* Expected 'SET' after table name */
#define JET_errExpSemiAfterLevelNumber	-8033 /* Expected ';' after level number */
#define JET_errExpSemiAfterParmList	-8034 /* Expected ';' after parmeter list */
#define JET_errExpSemiAfterPivotClause	-8035 /* Expected ';' after PIVOT clause */
#define JET_errExpSemiAtEndOfSQL	-8036 /* Expected ';' at end of SQL statement */
#define JET_errExpTableName		-8037 /* Expected table name */
#define JET_errExpTableNameAfterINTO	-8038 /* Expected table name after 'INTO' */
#define JET_errExpUpdExprAfterEqual	-8039 /* Expected update expression after '=' */
#define JET_errExpUpdateColName 	-8040 /* Expected update column name */
#define JET_errInvTokenAfterFromList	-8041 /* Bogus token after FROM list */
#define JET_errInvTokenAfterGroupList	-8042 /* Bogus token after GROUP BY list */
#define JET_errInvTokenAfterHavingCls	-8043 /* Bogus token after HAVING clause */
#define JET_errInvTokenAfterOrderClause -8044 /* Bogus token after ORDER BY clause */
#define JET_errInvTokenAfterSelectCls	-8045 /* Bogus token after SELECT clause */
#define JET_errInvTokenAfterWhereClause -8046 /* Bogus token after WHERE clause */
#define JET_errLevelNumberTooBig	-8047 /* Number after 'LEVEL' too big */
#define JET_errLevelOnNonMGB		-8048 /* LEVEL allowed only in MGB */
#define JET_errIllegalDetailReference	-8049 /* Not group key or agg, but not MGB detail */
#define JET_errAggOverMixedLevels	-8050 /* Agg. arg. uses outputs from > 1 level */
#define JET_errAggregatingHigherLevel	-8051 /* Agg. over output of same/higher level */
#define JET_errNullInJoinKey		-8052 /* Cannot set column in join key to NULL */
#define JET_errValueBreaksJoin		-8053 /* Join is broken by column value(s) */
#define JET_errInsertIntoUnknownColumn	-8054 /* INSERT INTO unknown column name */
#define JET_errNoSelectIntoColumnName	-8055 /* No dest. col. name in SELECT INTO stmt */
#define JET_errNoInsertColumnName	-8056 /* No dest. col. name in INSERT stmt */
#define JET_errColumnNotInJoinTable	-8057 /* Join expr refers to non-join table */
#define JET_errAggregateInJoin		-8058 /* Aggregate in JOIN clause */
#define JET_errAggregateInWhere 	-8059 /* Aggregate in WHERE clause */
#define JET_errAggregateInOrderBy	-8060 /* Aggregate in ORDER BY clause */
#define JET_errAggregateInGroupBy	-8061 /* Aggregate in GROUP BY clause */
#define JET_errAggregateInArgument	-8062 /* Aggregate in argument expression */
#define JET_errHavingOnTransform	-8063 /* HAVING clause on TRANSFORM query */
#define JET_errHavingWithoutGrouping	-8064 /* HAVING clause w/o grouping/aggregation */
#define JET_errHavingOnMGB		-8065 /* HAVING clause on MGB query */
#define JET_errOutputAliasCycle 	-8066 /* Cycle in SELECT list (via aliases) */
#define JET_errDotStarWithGrouping	-8067 /* 'T.*' with grouping, but not MGB level 0 */
#define JET_errStarWithGrouping 	-8068 /* '*' with grouping, but not MGB detail */
#define JET_errQueryTreeCycle		-8069 /* Cycle in tree of query objects */
#define JET_errTableRepeatInFromList	-8072 /* Table appears twice in FROM list */
#define JET_errTooManyXformLevels	-8073 /* Level > 2 in TRANSFORM query */
#define JET_errTooManyMGBLevels 	-8074 /* Too many levels in MGB */
#define JET_errNoUpdateColumnName	-8075 /* No dest. column name in UPDATE stmt */
#define JET_errJoinTableNotInput	-8076 /* Join table not in FROM list */
#define JET_errUnaliasedSelfJoin	-8077 /* Join tables have same name */
#define JET_errOutputLevelTooBig	-8078 /* Output w/ level > 1+max group level */
#define JET_errOrderVsGroup		-8079 /* ORDER BY conflicts with GROUP BY */
#define JET_errOrderVsDistinct		-8080 /* ORDER BY conflicts with DISTINCT */
#define JET_errExpLeftParenthesis	-8082 /* Expected '(' */
#define JET_errExpRightParenthesis	-8083 /* Expected ')' */
#define JET_errEvalEBESErr		-8084 /* EB/ES error evaluating expression */
#define JET_errQueryExpCloseQuote	-8085 /* Unmatched quote for database name */
#define JET_errQueryParmNotDatabase	-8086 /* Parameter type should be database */
#define JET_errQueryParmNotTableid	-8087 /* Parameter type should be tableid */
#define JET_errExpIdentifierM		-8088 /* Expected identifier */
#define JET_errExpQueryName		-8089 /* Expected query name after PROCEDURE */
#define JET_errExprUnknownFunctionM	-8090 /* Unknown function in expression */
#define JET_errQueryAmbigRefM		-8091 /* Ambiguous column reference */
#define JET_errQueryBadBracketing	-8092 /* Bad bracketing of identifier */
#define JET_errQueryBadQodefName	-8093 /* Invalid name in QODEF row */
#define JET_errQueryBulkColNotUpd	-8094 /* Column not updatable (bulk op) */
#define JET_errQueryDistinctNotAllowedM	-8095 /* DISTINCT not allowed for MGB */
#define JET_errQueryDuplicateAliasM	-8096 /* Duplicate output alias */
#define JET_errQueryDuplicateOutputM	-8097 /* Duplicate destination output */
#define JET_errQueryDuplicatedFixedSetM	-8098 /* Duplicated Fixed Value */
#define JET_errQueryIllegalOuterJoinM	-8099 /* No inconsistent updates on outer joins */
#define JET_errQueryIncompleteRowM	-8100 /* Missing value in row */
#define JET_errQueryInvalidAttributeM	-8101 /* Invalid query attribute */
#define JET_errQueryInvalidBulkInputM	-8102 /* Cannot input from bulk operation */
#define JET_errQueryInvalidFlagM	-8103 /* Invalid value in Flag field */
#define JET_errQueryInvalidMGBInputM	-8104 /* Cannot input from MGB */
#define JET_errQueryLVInAggregate	-8105 /* Illegal long value in aggregate */
#define JET_errQueryLVInDistinct	-8106 /* Illegal long value in DISTINCT */
#define JET_errQueryLVInGroupBy		-8107 /* Illegal long value in GROUP BY */
#define JET_errQueryLVInHaving		-8108 /* Illegal long value in HAVING */
#define JET_errQueryLVInJoin		-8109 /* Illegal long value in JOIN */
#define JET_errQueryLVInOrderBy		-8110 /* Illegal long value in ORDER BY */
#define JET_errQueryMissingLevelM	-8111 /* Missing intermediate MGB level */
#define JET_errQueryMissingParmsM	-8112 /* Too few parameters supplied */
#define JET_errQueryNoDbForParmDestTblM	-8113 /* Dest DB for VT parm not allowed */
#define JET_errQueryNoDeletePerm	-8114 /* No delete permission on table/query */
#define JET_errQueryNoInputTablesM	-8115 /* Query must have an input */
#define JET_errQueryNoInsertPerm	-8116 /* No insert permission on table/query */
#define JET_errQueryNoOutputsM		-8117 /* Query must have an output */
#define JET_errQueryNoReadDefPerm	-8118 /* No permission to read query definition */
#define JET_errQueryNoReadPerm		-8119 /* No read permission on table/query */
#define JET_errQueryNoReplacePerm	-8120 /* No replace permission on table/query */
#define JET_errQueryNoTblCrtPerm	-8121 /* No CreateTable permission (bulk op) */
#define JET_errQueryNotDirectChildM	-8122 /* T.* must use direct child */
#define JET_errQueryNullRequiredM	-8123 /* Column must be NULL */
#define JET_errQueryOnlyOneRowM		-8124 /* Only 1 such row allowed */
#define JET_errQueryOutputColNotUpd	-8125 /* Query output column not updatable */
#define JET_errQueryParmRedefM		-8126 /* Parm redefined with different type */
#define JET_errQueryParmTypeMismatchM	-8127 /* Wrong parameter type given */
#define JET_errQueryUnboundRefM		-8128 /* Cannot bind name */
#define JET_errRmtConnectFailedM	-8129 /* RMT: Connection attempt failed */
#define JET_errRmtDeleteFailedM		-8130 /* RMT: Delete statement failed */
#define JET_errRmtInsertFailedM		-8131 /* RMT: Insert statement failed */
#define JET_errRmtMissingOdbcDllM	-8132 /* RMT: Can't load ODBC DLL */
#define JET_errRmtSqlErrorM		-8133 /* RMT: ODBC call failed */
#define JET_errRmtUpdateFailedM		-8134 /* RMT: Update statement failed */
#define JET_errSQLDeleteSyntaxM		-8135 /* Expected 'FROM' after 'DELETE' */
#define JET_errSQLSyntaxM		-8136 /* Bogus SQL statement type */
#define JET_errSQLTooManyTokensM	-8137 /* Characters after end of SQL statement */
#define JET_errStarNotAtLevel0		-8138 /* '*' illegal above level 0 */
#define JET_errQueryParmTypeNotAllowed	-8139 /* Parameter type not allowed for expression */
#define JET_errQueryTooManyDestColumn	-8142 /* Too many destination column sepcified */
#define JET_errSQLNoInsertColumnName	-8143 /* No dest. col. name in INSERT stmt */
#define JET_errRmtLinkNotFound		-8144 /* RMT: link not found */
#define JET_errRmtTooManyColumns	-8145 /* RMT: Too many columns on Select Into */
#define JET_errWriteConflictM		-8146 /* Write lock failed due to outstanding write lock */
#define JET_errReadConflictM		-8147 /* Commit lock failed due to outstanding read lock */
#define JET_errCommitConflictM		-8148 /* Read lock failed due to outstanding commit lock */
#define JET_errTableLockedM		-8149 /* Table is exclusively locked */
#define JET_errTableInUseM		-8150 /* Table is in use, cannot lock */
#define JET_errQueryTooManyXvtColumn	-8151 /* Too many cross table column headers */
#define JET_errOutputTableNotFound	-8152 /* Non-existent table in Insert Into */
#define JET_errTableLockedQM		-8153 /* Table is exclusively locked */
#define JET_errTableInUseQM		-8154 /* Table is in use, cannot lock */
#define JET_errTableLockedMUQM		-8155 /* Table is exclusively locked */
#define JET_errTableInUseMUQM		-8156 /* Table is in use, cannot lock */
#define JET_errQueryInvalidParmM	-8157 /* Invalid Parmeter Name (>64 char) */
#define JET_errFileNotFoundM		-8158 /* File not found */
#define JET_errFileShareViolationM	-8159 /* File sharing violation */
#define JET_errFileAccessDeniedM	-8160 /* Access denied */
#define JET_errInvalidPathM		-8161 /* Invalid Path */
#define JET_errTableDuplicateM		-8162 /* Table already exists */
#define JET_errQueryBadUpwardRefedM	-8163 /* Illegally Upward ref'ed */
#define JET_errIntegrityViolMasterM	-8164 /* References to key exist */
#define JET_errIntegrityViolSlaveM	-8165 /* No referenced key exists */
#define JET_errSQLUnexpectedWithM	-8166 /* Unexpected 'with' in this place */
#define JET_errSQLOwnerAccessM		-8167 /* Owner Access Option is defined Twice */
#define	JET_errSQLOwnerAccessSyntaxM 	-8168 /* Owner Access Option Syntax Error */
#define	JET_errSQLOwnerAccessDef 	-8169 /* Owner Access Option is defined more than once */
#define JET_errAccessDeniedM     	-8170 /* Generic Access Denied */
#define JET_errUnexpectedEngineReturnM	-8171 /* I-ISAM: unexpected engine error code */
#define JET_errQueryTopNotAllowedM	-8172 /* Top not allowed for MGB */
#define JET_errInvTokenAfterTableCls -8173 /* Bogus token after table clause */
#define JET_errInvTokenAfterRParen  -8174 /* Unexpected tokens after a closing paren */
#define JET_errQueryBadValueListM	-8175 /* Malformed value list in Transform */
#define JET_errQueryIsCorruptM		-8176 /* Query is Corrupt */
#define	JET_errInvalidTopArgumentM	-8177 /* Select Top argument is invalid */
#define JET_errQueryIsSnapshot		-8178 /* Query is a snapshot */
#define JET_errQueryExprOutput		-8179 /* Output is a calculated column */
#define JET_errQueryTableRO		-8180 /* Column comes from read-only table */
#define JET_errQueryRowDeleted		-8181 /* Column comes from deleted row */
#define JET_errQueryRowLocked		-8182 /* Column comes from locked row */
#define JET_errQueryFixupChanged	-8183 /* Would row-fixup away from pending changes */
#define JET_errQueryCantFillIn		-8184 /* Fill-in-the-blank only on most-many */
#define JET_errQueryWouldOrphan		-8185 /* Would orphan joined records */
#define JET_errIncorrectJoinKeyM	-8186 /* Must match join key in lookup table */
#define JET_errQueryLVInSubqueryM	-8187 /* Illegal long value in subquery */
#define JET_errInvalidDatabaseM		-8188 /* Unrecognized database format */
#define JET_errOrderVsUnion 		-8189 /* You can only order by an outputted column in a union */
#define JET_errTLVCouldNotBindRef 	-8190 /* Unknown token in TLV expression */
#define JET_errCouldNotBindRef		-8191 /* Unknown token in FastFind expression */
#define JET_errQueryPKeyNotOutput	-8192 /* Primary key not output */
#define JET_errQueryJKeyNotOutput	-8193 /* Join key not output */
#define JET_errExclusiveDBConflict	-8194 /* Conflict with exclusive user */
#define JET_errQueryNoJoinedRecord	-8195 /* No F.I.T.B. insert if no joined record */
#define JET_errQueryLVInSetOp		-8196 /* Illegal long value in set operation */
#define JET_errTLVExprUnknownFunctionM	-8197 /* Unknown function in TLV expression */
#define JET_errInvalidNameM		-8198 /* Invalid name */

#define JET_errDDLExpColName		-8200 /* expect column name */
#define JET_errDDLExpLP			-8201 /* expect '(' */
#define JET_errDDLExpRP			-8202 /* expect ')' */
#define JET_errDDLExpIndex		-8203 /* expect INDEX */
#define JET_errDDLExpIndexName		-8204 /* expect index name */
#define JET_errDDLExpOn			-8205 /* expect ON */
#define JET_errDDLExpKey		-8206 /* expect KEY */
#define JET_errDDLExpReferences		-8207 /* expect REFERENCES */
#define JET_errDDLExpTableName		-8208 /* expect table name */
#define JET_errDDLExpFullOrPartial	-8209 /* expect FULL or PARTIAL */
#define JET_errDDLExpCascadeOrSet	-8210 /* expect CASCADE or SET */
#define JET_errDDLExpNull		-8211 /* expect NULL */
#define JET_errDDLExpUpdateOrDelete	-8212 /* expect UPDATE or DELETE */
#define JET_errDDLExpConstraintName	-8213 /* expect constraint name */
#define JET_errDDLExpForeign		-8214 /* expect FOREIGN */
#define JET_errDDLExpDatatype		-8215 /* expect data type */
#define JET_errDDLExpIndexOpt		-8216 /* expect index options */
#define JET_errDDLExpWith		-8217 /* expect WITH */
#define JET_errDDLExpTable		-8218 /* expect TABLE */
#define JET_errDDLExpEos		-8219 /* expect End Of String */
#define JET_errDDLExpAddOrDrop		-8220 /* expect ADD or Drop */
#define JET_errDDLCreateView		-8221 /* Create view not supported */
#define JET_errDDLCreateProc		-8222 /* Create proc not supported */
#define JET_errDDLExpObjectName		-8223 /* expect object name */
#define JET_errDDLExpColumn		-8224 /* expect COLUMN */

#define	JET_errV11TableNameNotInScope 	-8250 /* referenced table not in join clause */
#define JET_errV11OnlyTwoTables		-8251 /* exactly two tables should be referenced in join */
#define JET_errV11OneSided		-8252 /* all tables come from one side of input */
#define JET_errV11Ambiguous		-8253 /* Join clause is ambiguous when stored in V1 format */

#define JET_errTLVExprSyntaxM		-8260 /* Syntax error in TLV expression */
#define JET_errTLVNoNullM			-8261 /* This field cannot be null */
#define JET_errTLVNoBlankM			-8262 /* This column cannot be blank */
#define	JET_errTLVRuleViolationM 	-8263 /* This validation rule must be met */
#define JET_errDDLCreateViewSyntaxM	-8264 /* create view syntax error */

/***********************
 The following error code ranges are reserved for external use.
 As is true for Jet error codes, these ranges cover the negative
 as well as positive form of the numbers in the range.

 30000 through 30999 for use by Vt Object as defined in jeteb.h
 32000 through 32767 for use by Import/Export as defined in jetutil.h

 ***********************/



/**********************************************************************/
/***********************     PROTOTYPES      **************************/
/**********************************************************************/

#if !defined(_JET_NOPROTOTYPES)

/****************************************************************************

	ISAM API

*****************************************************************************/

JET_ERR JET_API JetInit(JET_INSTANCE _far *pinstance);

JET_ERR JET_API JetTerm(JET_INSTANCE instance);

JET_ERR JET_API JetSetSystemParameter(JET_INSTANCE _far *pinstance, JET_SESID sesid, unsigned long paramid,
	ULONG_PTR lParam, const char _far *sz);

JET_ERR JET_API JetGetSystemParameter(JET_INSTANCE instance, JET_SESID sesid, unsigned long paramid,
	ULONG_PTR _far *plParam, char _far *sz, unsigned long cbMax);

JET_ERR JET_API JetGetLastErrorInfo(JET_SESID sesid,
	JET_EXTERR _far *pexterr, unsigned long cbexterrMax,
	char _far *sz1, unsigned long cch1Max,
	char _far *sz2, unsigned long cch2Max,
	char _far *sz3, unsigned long cch3Max,
	unsigned long _far *pcch3Actual);

JET_ERR JET_API JetBeginSession(JET_INSTANCE instance, JET_SESID _far *psesid,
	const char _far *szUserName, const char _far *szPassword);

JET_ERR JET_API JetDupSession(JET_SESID sesid, JET_SESID _far *psesid);

JET_ERR JET_API JetEndSession(JET_SESID sesid, JET_GRBIT grbit);

JET_ERR JET_API JetGetVersion(JET_SESID sesid, unsigned long _far *pwVersion);

JET_ERR JET_API JetIdle(JET_SESID sesid, JET_GRBIT grbit);

JET_ERR JET_API JetCapability(JET_SESID sesid, JET_DBID dbid,
	unsigned long lArea, unsigned long lFunction, JET_GRBIT _far *pgrbit);

JET_ERR JET_API JetCreateDatabase(JET_SESID sesid,
	const char _far *szFilename, const char _far *szConnect,
	JET_DBID _far *pdbid, JET_GRBIT grbit);

JET_ERR JET_API JetAttachDatabase(JET_SESID sesid, const char _far *szFilename, JET_GRBIT grbit );

JET_ERR JET_API JetDetachDatabase(JET_SESID sesid, const char _far *szFilename);

JET_ERR JET_API JetCreateTable(JET_SESID sesid, JET_DBID dbid,
	const char _far *szTableName, unsigned long lPages, unsigned long lDensity,
	JET_TABLEID _far *ptableid);

JET_ERR JET_API JetRenameTable(JET_SESID sesid, JET_DBID dbid,
	const char _far *szTableName, const char _far *szTableNew);

JET_ERR JET_API JetDeleteTable(JET_SESID sesid, JET_DBID dbid,
	const char _far *szTableName);

JET_ERR JET_API JetGetTableColumnInfo(JET_SESID sesid, JET_TABLEID tableid,
	const char _far *szColumnName, void _far *pvResult, unsigned long cbMax,
	unsigned long InfoLevel);

JET_ERR JET_API JetGetColumnInfo(JET_SESID sesid, JET_DBID dbid,
	const char _far *szTableName, const char _far *szColumnName,
	void _far *pvResult, unsigned long cbMax, unsigned long InfoLevel);

JET_ERR JET_API JetAddColumn(JET_SESID sesid, JET_TABLEID tableid,
	const char _far *szColumn, const JET_COLUMNDEF _far *pcolumndef,
	const void _far *pvDefault, unsigned long cbDefault,
	JET_COLUMNID _far *pcolumnid);

JET_ERR JET_API JetRenameColumn(JET_SESID sesid, JET_TABLEID tableid,
	const char _far *szColumn, const char _far *szColumnNew);

JET_ERR JET_API JetDeleteColumn(JET_SESID sesid, JET_TABLEID tableid,
	const char _far *szColumn);

JET_ERR JET_API JetGetTableIndexInfo(JET_SESID sesid, JET_TABLEID tableid,
	const char _far *szIndexName, void _far *pvResult, unsigned long cbResult,
	unsigned long InfoLevel);

JET_ERR JET_API JetGetTableReferenceInfo(JET_SESID sesid, JET_TABLEID tableid,
	const char _far *szReferenceName, void _far *pvResult,
	unsigned long cbResult, unsigned long InfoLevel);

JET_ERR JET_API JetGetTableInfo(JET_SESID sesid, JET_TABLEID tableid,
	void _far *pvResult, unsigned long cbMax, unsigned long InfoLevel);

JET_ERR JET_API JetGetIndexInfo(JET_SESID sesid, JET_DBID dbid,
	const char _far *szTableName, const char _far *szIndexName,
	void _far *pvResult, unsigned long cbResult, unsigned long InfoLevel);

JET_ERR JET_API JetGetReferenceInfo(JET_SESID sesid, JET_DBID dbid,
	const char _far *szTableName, const char _far *szReference,
	void _far *pvResult, unsigned long cbResult, unsigned long InfoLevel);

JET_ERR JET_API JetCreateIndex(JET_SESID sesid, JET_TABLEID tableid,
	const char _far *szIndexName, JET_GRBIT grbit,
	const char _far *szKey, unsigned long cbKey, unsigned long lDensity);

JET_ERR JET_API JetRenameIndex(JET_SESID sesid, JET_TABLEID tableid,
	const char _far *szIndex, const char _far *szIndexNew);

JET_ERR JET_API JetDeleteIndex(JET_SESID sesid, JET_TABLEID tableid,
	const char _far *szIndexName);

JET_ERR JET_API JetCreateReference(JET_SESID sesid, JET_TABLEID tableid,
	const char _far *szReferenceName, const char _far *szColumns,
	const char _far *szReferencedTable,
	const char _far *szReferencedColumns, JET_GRBIT grbit);

JET_ERR JET_API JetRenameReference(JET_SESID sesid, JET_TABLEID tableid,
	const char _far *szReference, const char _far *szReferenceNew);

JET_ERR JET_API JetDeleteReference(JET_SESID sesid, JET_TABLEID tableid,
	const char _far *szReferenceName);

JET_ERR JET_API JetGetObjectInfo(JET_SESID sesid, JET_DBID dbid,
	JET_OBJTYP objtyp, const char _far *szContainerName,
	const char _far *szObjectName, void _far *pvResult, unsigned long cbMax,
	unsigned long InfoLevel);

JET_ERR JET_API JetCreateObject(JET_SESID sesid, JET_DBID dbid,
	const char _far *szContainerName, const char _far *szObjectName,
	JET_OBJTYP objtyp);

JET_ERR JET_API JetDeleteObject(JET_SESID sesid, JET_DBID dbid,
	const char _far *szContainerName, const char _far *szObjectName);

JET_ERR JET_API JetRenameObject(JET_SESID sesid, JET_DBID dbid,
	const char _far *szContainerName, const char _far *szObjectName,
	const char _far *szObjectNew);

JET_ERR JET_API JetBeginTransaction(JET_SESID sesid);

JET_ERR JET_API JetCommitTransaction(JET_SESID sesid, JET_GRBIT grbit);

JET_ERR JET_API JetRollback(JET_SESID sesid, JET_GRBIT grbit);

JET_ERR JET_API JetUpdateUserFunctions(JET_SESID sesid);

JET_ERR JET_API JetGetDatabaseInfo(JET_SESID sesid, JET_DBID dbid,
	void _far *pvResult, unsigned long cbMax, unsigned long InfoLevel);

JET_ERR JET_API JetCloseDatabase(JET_SESID sesid, JET_DBID dbid,
	JET_GRBIT grbit);

JET_ERR JET_API JetCloseTable(JET_SESID sesid, JET_TABLEID tableid);

JET_ERR JET_API JetOpenDatabase(JET_SESID sesid, const char _far *szFilename,
	const char _far *szConnect, JET_DBID _far *pdbid, JET_GRBIT grbit);

JET_ERR JET_API JetOpenTable(JET_SESID sesid, JET_DBID dbid,
	const char _far *szTableName, const void _far *pvParameters,
	unsigned long cbParameters, JET_GRBIT grbit, JET_TABLEID _far *ptableid);

JET_ERR JET_API JetDelete(JET_SESID sesid, JET_TABLEID tableid);

JET_ERR JET_API JetUpdate(JET_SESID sesid, JET_TABLEID tableid,
	void _far *pvBookmark, unsigned long cbBookmark,
	unsigned long _far *pcbActual);

JET_ERR JET_API JetRetrieveColumn(JET_SESID sesid, JET_TABLEID tableid,
	JET_COLUMNID columnid, void _far *pvData, unsigned long cbData,
	unsigned long _far *pcbActual, JET_GRBIT grbit, JET_RETINFO _far *pretinfo);

JET_ERR JET_API JetRetrieveColumns( JET_SESID sesid, JET_TABLEID tableid,
	JET_RETRIEVECOLUMN *pretrievecolumn, unsigned long cretrievecolumn );

JET_ERR JET_API JetSetColumn(JET_SESID sesid, JET_TABLEID tableid,
	JET_COLUMNID columnid, const void _far *pvData, unsigned long cbData,
	JET_GRBIT grbit, JET_SETINFO _far *psetinfo);

JET_ERR JET_API JetSetColumns(JET_SESID sesid, JET_TABLEID tableid,
	JET_SETCOLUMN *psetcolumn, unsigned long csetcolumn );

JET_ERR JET_API JetPrepareUpdate(JET_SESID sesid, JET_TABLEID tableid,
	unsigned long prep);

JET_ERR JET_API JetGetRecordPosition(JET_SESID sesid, JET_TABLEID tableid,
	JET_RECPOS _far *precpos, unsigned long cbRecpos);

JET_ERR JET_API JetGotoPosition(JET_SESID sesid, JET_TABLEID tableid,
	JET_RECPOS *precpos );

JET_ERR JET_API JetGetCursorInfo(JET_SESID sesid, JET_TABLEID tableid,
	void _far *pvResult, unsigned long cbMax, unsigned long InfoLevel);

JET_ERR JET_API JetDupCursor(JET_SESID sesid, JET_TABLEID tableid,
	JET_TABLEID _far *ptableid, JET_GRBIT grbit);

JET_ERR JET_API JetGetCurrentIndex(JET_SESID sesid, JET_TABLEID tableid,
	char _far *szIndexName, unsigned long cchIndexName);

JET_ERR JET_API JetSetCurrentIndex(JET_SESID sesid, JET_TABLEID tableid,
	const char _far *szIndexName);

JET_ERR JET_API JetMove(JET_SESID sesid, JET_TABLEID tableid,
	long cRow, JET_GRBIT grbit);

JET_ERR JET_API JetMakeKey(JET_SESID sesid, JET_TABLEID tableid,
	const void _far *pvData, unsigned long cbData, JET_GRBIT grbit);

JET_ERR JET_API JetSeek(JET_SESID sesid, JET_TABLEID tableid,
	JET_GRBIT grbit);

JET_ERR JET_API JetFastFind(JET_SESID sesid, JET_DBID dbid,
	JET_TABLEID tableid, const char _far *szExpr, JET_GRBIT grbit,
	signed long _far *pcrow);

JET_ERR JET_API JetFastFindBegin(JET_SESID sesid, JET_DBID dbid,
	JET_TABLEID tableid, const char _far *szExpr, JET_GRBIT grbit);

JET_ERR JET_API JetFastFindEnd(JET_SESID sesid, JET_TABLEID tableid);

JET_ERR JET_API JetGetBookmark(JET_SESID sesid, JET_TABLEID tableid,
	void _far *pvBookmark, unsigned long cbMax,
	unsigned long _far *pcbActual);
	
JET_ERR JET_API JetRefreshLink(JET_SESID sesid, JET_DBID dbid,
	const char _far *szLinkName, const char _far *szConnect,
	const char _far *szDatabase);

#ifdef	_MSC_VER		       /* CONSIDER: CSL doesn't like this */

JET_ERR JET_API JetRepairDatabase(JET_SESID sesid, const char _far *lszDbFile,
	JET_PFNSTATUS pfnstatus);

#endif	/* _MSC_VER */

JET_ERR JET_API JetCompact(JET_SESID sesid, const char _far *szDatabaseSrc,
	const char _far *szConnectSrc, const char _far *szDatabaseDest,
	const char _far *szConnectDest, JET_PFNSTATUS pfnStatus,
	JET_GRBIT grbit);

JET_ERR JET_API JetGotoBookmark(JET_SESID sesid, JET_TABLEID tableid,
	void _far *pvBookmark, unsigned long cbBookmark);

JET_ERR JET_API JetComputeStats(JET_SESID sesid, JET_TABLEID tableid);

JET_ERR JET_API JetCreateRelationship(JET_SESID sesid,JET_DBID dbidIn,
	const char _far *szRelationshipName, const char _far *szObjectName,
	const char _far *szColumns, const char _far *szReferencedObject,
	const char _far *szReferncedColumns, char _far *szLongName,
	unsigned long cbMax, unsigned long _far *pcbActual, JET_GRBIT grbit);

JET_ERR JET_API JetDeleteRelationship(JET_SESID sesid, JET_DBID dbidIn,
	const char _far *szName);

JET_ERR JET_API JetGetRelationshipInfo(JET_SESID sesid, JET_DBID dbid,
	const char _far *szTableName, const char _far *szRelationship,
	void _far *pvResult, unsigned long cbResult);

/*****************************************************************************

	SEC API

*****************************************************************************/

JET_ERR JET_API JetGetSidFromName(JET_SESID sesid, const char _far *szName,
	void _far *pvSid, unsigned long cbMax, unsigned long _far *pcbActual,
	long _far *pfGroup);

JET_ERR JET_API JetGetNameFromSid(JET_SESID sesid,
	const void _far *pvSid, unsigned long cbSid,
	char _far *szName, unsigned long cchName, long _far *pfGroup);

JET_ERR JET_API JetCreateUser(JET_SESID sesid, const char _far *szUser,
	const char _far *szPassword, const char _far *szPin);

JET_ERR JET_API JetChangeUserPassword(JET_SESID sesid,
	const char _far *szUser, const char _far *szOldPassword,
	const char _far *szNewPassword);

JET_ERR JET_API JetDeleteUser(JET_SESID sesid, const char _far *szUser);

JET_ERR JET_API JetCreateGroup(JET_SESID sesid, const char _far *szGroup,
	const char _far *szPin);

JET_ERR JET_API JetAddMember(JET_SESID sesid,
	const char _far *szGroup, const char _far *szUser);

JET_ERR JET_API JetRemoveMember(JET_SESID sesid,
	const char _far *szGroup, const char _far *szUser);

JET_ERR JET_API JetDeleteGroup(JET_SESID sesid, const char _far *szGroup);

JET_ERR JET_API JetSetAccess(JET_SESID sesid, JET_DBID dbid,
	const char _far *szContainerName, const char _far *szObjectName,
	const char _far *szName, JET_ACM acm, JET_GRBIT grbit);

JET_ERR JET_API JetGetAccess(JET_SESID sesid, JET_DBID dbid,
	const char _far *szContainerName, const char _far *szObjectName,
	const char _far *szName, long fIndividual,
	JET_ACM _far *pacm, JET_GRBIT _far *pgrbit);

JET_ERR JET_API JetValidateAccess(JET_SESID sesid, JET_DBID dbid,
	const char _far *szContainerName, const char _far *szObjectName,
	JET_ACM acmRequired);

JET_ERR JET_API JetSetOwner(JET_SESID sesid, JET_DBID dbid,
	const char _far *szContainerName, const char _far *szObjectName,
	const char _far *szName);

JET_ERR JET_API JetGetOwner(JET_SESID sesid, JET_DBID dbid,
	const char _far *szContainerName, const char _far *szObjectName,
	char _far *szName, unsigned long cchMax);

/*****************************************************************************

	Property Management API

*****************************************************************************/
JET_ERR JET_API JetSetProperty(JET_SESID sesid, JET_DBID dbid,
	const char _far *szContainerName, const char _far *szObjectName,
	const char _far *szSubObjectName, const char _far *szPropertyName,
	void _far *pvData, unsigned long cbData, JET_COLTYP coltyp,
	JET_GRBIT grbit);

JET_ERR JET_API JetRetrieveProperty(JET_SESID sesid, JET_DBID dbid,
	const char _far *szContainerName, const char _far *szObjectName,
	const char _far *szSubObjectName, const char _far *szPropertyName,
	void _far *pvData, unsigned long cbData, unsigned long _far *pcbActual,
	JET_COLTYP _far *pcoltyp, JET_GRBIT grbit, unsigned long InfoLevel);

JET_ERR JET_API JetSetTableProperty(JET_SESID sesid, JET_TABLEID tableid,
	const char _far *szSubObjectName, const char _far *szPropertyName,
	void _far *pvData, unsigned long cbData, JET_COLTYP coltyp,
	JET_GRBIT grbit);

JET_ERR JET_API JetRetrieveTableProperty(JET_SESID sesid, JET_TABLEID tableid,
	const char _far *szSubObjectName, const char _far *szPropertyName,
	void _far *pvData, unsigned long cbData, unsigned long _far *pcbActual,
	JET_COLTYP _far *pcoltyp, JET_GRBIT grbit, unsigned long InfoLevel);

/*****************************************************************************

	LINK API

*****************************************************************************/

JET_ERR JET_API JetCreateLink(JET_SESID sesid, JET_DBID dbid,
	const char _far *szLink, JET_DBID dbidFrom, const char _far *szFrom,
	JET_GRBIT grbit);

JET_ERR JET_API JetExecuteSql(JET_SESID sesid, JET_DBID dbid,
	const char _far *szSql);

/***************************************************************************

	Query API

*****************************************************************************/

JET_ERR JET_API JetOpenVtQbe(JET_SESID sesid, const char _far *szExpn,
	long _far *plCols, JET_TABLEID _far *ptableid, JET_GRBIT grbit);

JET_ERR JET_API JetCreateQuery(JET_SESID sesid, JET_DBID dbid,
	const char _far *szQuery, JET_TABLEID _far *ptableid);

JET_ERR JET_API JetOpenQueryDef(JET_SESID sesid, JET_DBID dbid,
	const char _far *szQuery, JET_TABLEID _far *ptableid);

/* CONSIDER: Is rgchSql a zero-terminated string?  Maybe it should be for
 *		   consistency.
 */

JET_ERR JET_API JetSetQoSql(JET_SESID sesid, JET_TABLEID tableid,
	char _far *rgchSql, unsigned long cchSql, const char _far *szConnect,
	JET_GRBIT grbit);

JET_ERR JET_API JetRetrieveQoSql(JET_SESID sesid, JET_TABLEID tableid,
	char _far *rgchSql, unsigned long cchMax,
	unsigned long _far *pcchActual, void _far *pvConnect,
	unsigned long cbConnectMax, unsigned long _far *pcbConnectActual,
	JET_GRBIT _far *pgrbit);

JET_ERR JET_API JetCopyQuery(JET_SESID sesid, JET_TABLEID tableidSrc,
	JET_DBID dbidDest, const char _far *szQueryDest,
	JET_TABLEID _far *ptableidDest);

JET_ERR JET_API JetOpenSVT(JET_SESID sesid, JET_DBID dbid,
	const char _far *szQuery, const void _far *pvParameters,
	unsigned long cbParameters, unsigned long crowSample, JET_GRBIT grbit,
	void _far *pmgblist, unsigned long cbMax, unsigned long _far *pcbActual);

JET_ERR JET_API JetGetQueryParameterInfo(JET_SESID sesid, JET_DBID dbid,
	const char _far *szQuery, void _far *pvResult, unsigned long cbMax,
	unsigned long _far *pcbActual);

JET_ERR JET_API JetRestartQuery(JET_SESID sesid, JET_TABLEID tableid,
	const void _far *pvParameters, unsigned long cbParameters);

JET_ERR JET_API JetSetFatCursor(JET_SESID sesid, JET_TABLEID tableid,
	void _far *pvBookmark, unsigned long cbBookmark, unsigned long crowSize);

JET_ERR JET_API JetFillFatCursor(JET_SESID sesid, JET_TABLEID tableid,
	void _far *pvBookmark, unsigned long cbBookmark, unsigned long crow,
	unsigned long _far *pcrow, JET_GRBIT grbit);

JET_ERR JET_API JetExecuteTempQuery(JET_SESID sesid, JET_DBID dbid,
	JET_TABLEID tableid, const void _far *pvParameters,
	unsigned long cbParameters, JET_GRBIT grbit, JET_TABLEID _far *ptableid);

JET_ERR JET_API JetExecuteTempSVT(JET_SESID sesid, JET_DBID dbid,
	JET_TABLEID tableid, const void _far *pvParameters,
	unsigned long cbParameters, unsigned long crowSample, JET_GRBIT grbit,
	void _far *pmgblist, unsigned long cbMax, unsigned long _far *pcbActual);

JET_ERR JET_API JetGetTempQueryColumnInfo(JET_SESID sesid, JET_DBID dbid,
	JET_TABLEID tableid, const char _far *szColumnName,
	void _far *pvResult, unsigned long cbMax, unsigned long InfoLevel);

JET_ERR JET_API JetGetTempQueryParameterInfo(JET_SESID sesid, JET_DBID dbid,
	JET_TABLEID tableid, void _far *pvResult, unsigned long cbMax,
	unsigned long _far *pcbActual);

JET_ERR JET_API JetValidateData(JET_SESID sesid, JET_TABLEID tableidBase,
		JET_TABLEID _far *ptableid );

/***************************************************************************

	API for Installable ISAMs

****************************************************************************/

typedef ULONG_PTR JET_VSESID;         /* Received from dispatcher */

struct tagVDBFNDEF;

typedef ULONG_PTR JET_VDBID;          /* Received from dispatcher */

JET_ERR JET_API JetAllocateDbid(JET_SESID sesid, JET_DBID _far *pdbid, JET_VDBID vdbid, const struct tagVDBFNDEF _far *pvdbfndef, JET_VSESID vsesid);

JET_ERR JET_API JetUpdateDbid(JET_SESID sesid, JET_DBID dbid, JET_VDBID vdbid, const struct tagVDBFNDEF _far *pvdbfndef);

JET_ERR JET_API JetReleaseDbid(JET_SESID sesid, JET_DBID dbid);

struct tagVTFNDEF;

typedef ULONG_PTR JET_VTID;            /* Received from dispatcher */

JET_ERR JET_API JetAllocateTableid(JET_SESID sesid, JET_TABLEID _far *ptableid, JET_VTID vtid, const struct tagVTFNDEF _far *pvtfndef, JET_VSESID vsesid);

JET_ERR JET_API JetUpdateTableid(JET_SESID sesid, JET_TABLEID tableid, JET_VTID vtid, const struct tagVTFNDEF _far *pvtfndef);

JET_ERR JET_API JetReleaseTableid(JET_SESID sesid, JET_TABLEID tableid);

JET_ERR JET_API JetOpenTempTable(JET_SESID sesid,
	const JET_COLUMNDEF _far *prgcolumndef, unsigned long ccolumn,
	JET_GRBIT grbit, JET_TABLEID _far *ptableid,
	JET_COLUMNID _far *prgcolumnid);


/***************************************************************************

	MISC JET API

****************************************************************************/

JET_ERR JET_API JetStringCompare(char _far *pb1, unsigned long cb1,
	char _far *pb2, unsigned long cb2, unsigned long sort,
	long _far *plResult);

/***************************************************************************

	ADDITIONAL JET BLUE API

****************************************************************************/
JET_ERR JET_API JetBackup( const char _far *szBackupPath, JET_GRBIT grbit );
JET_ERR JET_API JetRestore(const char _far *sz, int crstmap, JET_RSTMAP *rgrstmap, JET_PFNSTATUS pfn );
JET_ERR JET_API JetSetIndexRange(JET_SESID sesid,
	JET_TABLEID tableidSrc, JET_GRBIT grbit);
JET_ERR JET_API JetIndexRecordCount(JET_SESID sesid,
	JET_TABLEID tableid, unsigned long _far *pcrec, unsigned long crecMax );
JET_ERR JET_API JetRetrieveKey(JET_SESID sesid,
	JET_TABLEID tableid, void _far *pvData, unsigned long cbMax,
	unsigned long _far *pcbActual, JET_GRBIT grbit );

#ifdef JETSER
JET_ERR JET_API JetGetChecksum( JET_SESID sesid,
	JET_TABLEID tableid, unsigned long _far *pulChecksum );
JET_ERR JET_API JetGetObjidFromName(JET_SESID sesid,
	JET_DBID dbid, const char _far *szContainerName,
	const char _far *szObjectName,
	unsigned long _far *pulObjectId );
#endif

#endif	/* _JET_NOPROTOTYPES */

#undef	_far

#pragma pack()

#ifdef	__cplusplus
}
#endif


#endif	/* _JET_INCLUDED */

#endif  __JET500
=== C:/Users/treeman/Desktop/windows nt source code\Source\Win2K3\NT\public\internal\ds\inc\loghours.h ===
/*++

Copyright (c) 1987-1993  Microsoft Corporation

Module Name:

    loghours.h

Abstract:

    Private routines to support rotation of logon hours between local time
    and GMT time.

Author:

    Cliff Van Dyke (cliffv) 16-Mar-93

Environment:

    User mode only.
    Contains NT-specific code.
    Requires ANSI C extensions: slash-slash comments, long external names.

Revision History:

--*/



//
// Procedure forwards from loghours.c
//

BOOLEAN
NetpRotateLogonHoursPhase1(
    IN BOOL  ConvertToGmt,
    OUT PULONG RotateCount
    );

BOOLEAN
NetpRotateLogonHoursPhase2(
    IN PBYTE LogonHours,
    IN DWORD UnitsPerWeek,
    IN LONG  RotateCount
    );

BOOLEAN
NetpRotateLogonHours(
    IN PBYTE LogonHours,
    IN DWORD UnitsPerWeek,
    IN BOOL  ConvertToGmt
    );
=== C:/Users/treeman/Desktop/windows nt source code\Source\Win2K3\NT\public\internal\ds\inc\logonmsv.h ===
/*++

Copyright (c) 1987-1991  Microsoft Corporation

Module Name:

    logonmsv.h

Abstract:

    Definition of API's to the Netlogon service which are callable
    by the MSV1_0 authentication package.

Author:

    Cliff Van Dyke (cliffv) 23-Jun-1991

Environment:

    User mode only.
    Contains NT-specific code.
    Requires ANSI C extensions: slash-slash comments, long external names.

Revision History:

--*/

#ifndef __LOGONMSV_H__
#define __LOGONMSV_H__
#include <lsass.h>  // OLD_LARGE_INTEGER

//
// Name of secret in LSA secret storage where account passwords are kept.
//

#define SSI_SECRET_PREFIX L"$"
#define SSI_SECRET_PREFIX_LENGTH 1
#define SSI_SECRET_POSTFIX L"MACHINE.ACC"
#define SSI_SECRET_NAME L"$MACHINE.ACC"

//
// Name of the event used to synchronize between the security process and
// the service controller.
//

#define SECURITY_SERVICES_STARTED L"SECURITY_SERVICES_STARTED"


//
// The structures supporting remote logon APIs
//

typedef CYPHER_BLOCK NETLOGON_CREDENTIAL, *PNETLOGON_CREDENTIAL ;

typedef struct _NETLOGON_AUTHENTICATOR {
    NETLOGON_CREDENTIAL Credential;
    DWORD timestamp;
} NETLOGON_AUTHENTICATOR, *PNETLOGON_AUTHENTICATOR ;

typedef struct _NETLOGON_SESSION_KEY {
    BYTE Key[CRYPT_TXT_LEN * 2];
} NETLOGON_SESSION_KEY, *PNETLOGON_SESSION_KEY;

typedef enum _NETLOGON_SECURE_CHANNEL_TYPE {
    NullSecureChannel = 0,
    MsvApSecureChannel,
    WorkstationSecureChannel,
    TrustedDnsDomainSecureChannel,
    TrustedDomainSecureChannel,
    UasServerSecureChannel,
    ServerSecureChannel
} NETLOGON_SECURE_CHANNEL_TYPE;

#define IsDomainSecureChannelType( _T ) \
        ( (_T) == TrustedDnsDomainSecureChannel || \
          (_T) == TrustedDomainSecureChannel )


//
// Input information to NetLogonSamLogon.
//
// begin_ntsubauth

typedef enum _NETLOGON_LOGON_INFO_CLASS {
    NetlogonInteractiveInformation = 1,
    NetlogonNetworkInformation,
    NetlogonServiceInformation,
    NetlogonGenericInformation,
    NetlogonInteractiveTransitiveInformation,
    NetlogonNetworkTransitiveInformation,
    NetlogonServiceTransitiveInformation
} NETLOGON_LOGON_INFO_CLASS;

typedef struct _NETLOGON_LOGON_IDENTITY_INFO {
    UNICODE_STRING LogonDomainName;
    ULONG ParameterControl;
    OLD_LARGE_INTEGER  LogonId;
    UNICODE_STRING UserName;
    UNICODE_STRING Workstation;
} NETLOGON_LOGON_IDENTITY_INFO,
 *PNETLOGON_LOGON_IDENTITY_INFO;

typedef struct _NETLOGON_INTERACTIVE_INFO {
    NETLOGON_LOGON_IDENTITY_INFO Identity;
    LM_OWF_PASSWORD LmOwfPassword;
    NT_OWF_PASSWORD NtOwfPassword;
} NETLOGON_INTERACTIVE_INFO,
 *PNETLOGON_INTERACTIVE_INFO;

typedef struct _NETLOGON_SERVICE_INFO {
    NETLOGON_LOGON_IDENTITY_INFO Identity;
    LM_OWF_PASSWORD LmOwfPassword;
    NT_OWF_PASSWORD NtOwfPassword;
} NETLOGON_SERVICE_INFO, *PNETLOGON_SERVICE_INFO;

typedef struct _NETLOGON_NETWORK_INFO {
    NETLOGON_LOGON_IDENTITY_INFO Identity;
    LM_CHALLENGE LmChallenge;
    STRING NtChallengeResponse;
    STRING LmChallengeResponse;
} NETLOGON_NETWORK_INFO, *PNETLOGON_NETWORK_INFO;

typedef struct _NETLOGON_GENERIC_INFO {
    NETLOGON_LOGON_IDENTITY_INFO Identity;
    UNICODE_STRING PackageName;
    ULONG DataLength;
#ifdef MIDL_PASS
    [size_is(DataLength)]
#endif
    PUCHAR LogonData;
} NETLOGON_GENERIC_INFO, *PNETLOGON_GENERIC_INFO;

// end_ntsubauth

//
// Structure to pass a SID_AND_ATTRIBUTES over the network.
//

typedef struct _NETLOGON_SID_AND_ATTRIBUTES {
#if defined(MIDL_PASS) || defined(RPC_SERVER)
    PISID Sid;
#else
    PSID Sid;
#endif
    ULONG Attributes;
} NETLOGON_SID_AND_ATTRIBUTES, *PNETLOGON_SID_AND_ATTRIBUTES;

//
// Values of ParameterControl
//
// (Obsolete: Use the ParameterControl values from ntmsv1_0.h)

#define CLEARTEXT_PASSWORD_ALLOWED 0x02     // Challenge response fields may
                                            // actually be clear text passwords.


//
// Output information to NetLogonSamLogon.
//

typedef enum _NETLOGON_VALIDATION_INFO_CLASS {
     NetlogonValidationUasInfo = 1,
     NetlogonValidationSamInfo,
     NetlogonValidationSamInfo2,
     NetlogonValidationGenericInfo,
     NetlogonValidationGenericInfo2,
     NetlogonValidationSamInfo4
} NETLOGON_VALIDATION_INFO_CLASS;

typedef struct _NETLOGON_VALIDATION_SAM_INFO {
    //
    // Information retrieved from SAM.
    //
    OLD_LARGE_INTEGER LogonTime;            // 0 for Network logon
    OLD_LARGE_INTEGER LogoffTime;
    OLD_LARGE_INTEGER KickOffTime;
    OLD_LARGE_INTEGER PasswordLastSet;      // 0 for Network logon
    OLD_LARGE_INTEGER PasswordCanChange;    // 0 for Network logon
    OLD_LARGE_INTEGER PasswordMustChange;   // 0 for Network logon
    UNICODE_STRING EffectiveName;       // 0 for Network logon
    UNICODE_STRING FullName;            // 0 for Network logon
    UNICODE_STRING LogonScript;         // 0 for Network logon
    UNICODE_STRING ProfilePath;         // 0 for Network logon
    UNICODE_STRING HomeDirectory;       // 0 for Network logon
    UNICODE_STRING HomeDirectoryDrive;  // 0 for Network logon
    USHORT LogonCount;                  // 0 for Network logon
    USHORT BadPasswordCount;            // 0 for Network logon
    ULONG UserId;
    ULONG PrimaryGroupId;
    ULONG GroupCount;
#ifdef MIDL_PASS
    [size_is(GroupCount)]
#endif // MIDL_PASS
    PGROUP_MEMBERSHIP GroupIds;

    //
    // Information supplied by the MSV AP/Netlogon service.
    //
    ULONG UserFlags;
    USER_SESSION_KEY UserSessionKey;
    UNICODE_STRING LogonServer;
    UNICODE_STRING LogonDomainName;
#if defined(MIDL_PASS) || defined(RPC_SERVER)
    PISID LogonDomainId;
#else
    PSID LogonDomainId;
#endif

    ULONG    ExpansionRoom[10];        // Put new fields here
} NETLOGON_VALIDATION_SAM_INFO, *PNETLOGON_VALIDATION_SAM_INFO ;

//
// New output information for NetLogonSamLogon. This structure is identical
// to the above structure with some new fields added at the end.
//

typedef struct _NETLOGON_VALIDATION_SAM_INFO2 {
    //
    // Information retrieved from SAM.
    //
    OLD_LARGE_INTEGER LogonTime;            // 0 for Network logon
    OLD_LARGE_INTEGER LogoffTime;
    OLD_LARGE_INTEGER KickOffTime;
    OLD_LARGE_INTEGER PasswordLastSet;      // 0 for Network logon
    OLD_LARGE_INTEGER PasswordCanChange;    // 0 for Network logon
    OLD_LARGE_INTEGER PasswordMustChange;   // 0 for Network logon
    UNICODE_STRING EffectiveName;       // 0 for Network logon
    UNICODE_STRING FullName;            // 0 for Network logon
    UNICODE_STRING LogonScript;         // 0 for Network logon
    UNICODE_STRING ProfilePath;         // 0 for Network logon
    UNICODE_STRING HomeDirectory;       // 0 for Network logon
    UNICODE_STRING HomeDirectoryDrive;  // 0 for Network logon
    USHORT LogonCount;                  // 0 for Network logon
    USHORT BadPasswordCount;            // 0 for Network logon
    ULONG UserId;
    ULONG PrimaryGroupId;
    ULONG GroupCount;
#ifdef MIDL_PASS
    [size_is(GroupCount)]
#endif // MIDL_PASS
    PGROUP_MEMBERSHIP GroupIds;

    //
    // Information supplied by the MSV AP/Netlogon service.
    //
    ULONG UserFlags;
    USER_SESSION_KEY UserSessionKey;
    UNICODE_STRING LogonServer;
    UNICODE_STRING LogonDomainName;
#if defined(MIDL_PASS) || defined(RPC_SERVER)
    PISID LogonDomainId;
#else
    PSID LogonDomainId;
#endif

    ULONG    ExpansionRoom[10];        // Put new fields here

    //
    // The new fields in this structure are a count and a pointer to
    // an array of SIDs and attributes.
    //

    ULONG SidCount;

#ifdef MIDL_PASS
    [size_is(SidCount)]
#endif // MIDL_PASS
    PNETLOGON_SID_AND_ATTRIBUTES ExtraSids;

} NETLOGON_VALIDATION_SAM_INFO2, *PNETLOGON_VALIDATION_SAM_INFO2 ;


//
// Info level 3 is a version used internally by kerberos.  It never appears on the wire.
//
typedef struct _NETLOGON_VALIDATION_SAM_INFO3 {
    //
    // Information retrieved from SAM.
    //
    OLD_LARGE_INTEGER LogonTime;            // 0 for Network logon
    OLD_LARGE_INTEGER LogoffTime;
    OLD_LARGE_INTEGER KickOffTime;
    OLD_LARGE_INTEGER PasswordLastSet;      // 0 for Network logon
    OLD_LARGE_INTEGER PasswordCanChange;    // 0 for Network logon
    OLD_LARGE_INTEGER PasswordMustChange;   // 0 for Network logon
    UNICODE_STRING EffectiveName;       // 0 for Network logon
    UNICODE_STRING FullName;            // 0 for Network logon
    UNICODE_STRING LogonScript;         // 0 for Network logon
    UNICODE_STRING ProfilePath;         // 0 for Network logon
    UNICODE_STRING HomeDirectory;       // 0 for Network logon
    UNICODE_STRING HomeDirectoryDrive;  // 0 for Network logon
    USHORT LogonCount;                  // 0 for Network logon
    USHORT BadPasswordCount;            // 0 for Network logon
    ULONG UserId;
    ULONG PrimaryGroupId;
    ULONG GroupCount;
#ifdef MIDL_PASS
    [size_is(GroupCount)]
#endif // MIDL_PASS
    PGROUP_MEMBERSHIP GroupIds;

    //
    // Information supplied by the MSV AP/Netlogon service.
    //
    ULONG UserFlags;
    USER_SESSION_KEY UserSessionKey;
    UNICODE_STRING LogonServer;
    UNICODE_STRING LogonDomainName;
#if defined(MIDL_PASS) || defined(RPC_SERVER)
    PISID LogonDomainId;
#else
    PSID LogonDomainId;
#endif

    ULONG    ExpansionRoom[10];        // Put new fields here

    //
    // The new fields in this structure are a count and a pointer to
    // an array of SIDs and attributes.
    //

    ULONG SidCount;

#ifdef MIDL_PASS
    [size_is(SidCount)]
#endif // MIDL_PASS

    PNETLOGON_SID_AND_ATTRIBUTES ExtraSids;

    //
    // Resource groups. These are present if LOGON_RESOURCE_GROUPS bit is
    // set in the user flags
    //

#if defined(MIDL_PASS) || defined(RPC_SERVER)
    PISID ResourceGroupDomainSid;
#else
    PSID ResourceGroupDomainSid;
#endif
    ULONG ResourceGroupCount;
#ifdef MIDL_PASS
    [size_is(ResourceGroupCount)]
#endif // MIDL_PASS
    PGROUP_MEMBERSHIP ResourceGroupIds;

} NETLOGON_VALIDATION_SAM_INFO3, *PNETLOGON_VALIDATION_SAM_INFO3 ;

//
// New output information for NetLogonSamLogon. This structure is identical
// to the NETLOGON_VALIDATION_SAM_INFO2 with some new fields added at the end.
//
// This version was introduced in Whistler.
//

typedef struct _NETLOGON_VALIDATION_SAM_INFO4 {
    //
    // Information retrieved from SAM.
    //
    OLD_LARGE_INTEGER LogonTime;            // 0 for Network logon
    OLD_LARGE_INTEGER LogoffTime;
    OLD_LARGE_INTEGER KickOffTime;
    OLD_LARGE_INTEGER PasswordLastSet;      // 0 for Network logon
    OLD_LARGE_INTEGER PasswordCanChange;    // 0 for Network logon
    OLD_LARGE_INTEGER PasswordMustChange;   // 0 for Network logon
    UNICODE_STRING EffectiveName;       // 0 for Network logon
    UNICODE_STRING FullName;            // 0 for Network logon
    UNICODE_STRING LogonScript;         // 0 for Network logon
    UNICODE_STRING ProfilePath;         // 0 for Network logon
    UNICODE_STRING HomeDirectory;       // 0 for Network logon
    UNICODE_STRING HomeDirectoryDrive;  // 0 for Network logon
    USHORT LogonCount;                  // 0 for Network logon
    USHORT BadPasswordCount;            // 0 for Network logon
    ULONG UserId;
    ULONG PrimaryGroupId;
    ULONG GroupCount;
#ifdef MIDL_PASS
    [size_is(GroupCount)]
#endif // MIDL_PASS
    PGROUP_MEMBERSHIP GroupIds;

    //
    // Information supplied by the MSV AP/Netlogon service.
    //
    ULONG UserFlags;
    USER_SESSION_KEY UserSessionKey;
    UNICODE_STRING LogonServer;
    UNICODE_STRING LogonDomainName;
#if defined(MIDL_PASS) || defined(RPC_SERVER)
    PISID LogonDomainId;
#else
    PSID LogonDomainId;
#endif
    //
    // The First two longwords (8 bytes) of ExpansionRoom are reserved for the
    // LanManSession Key.
    //
#define SAMINFO_LM_SESSION_KEY 0
#define SAMINFO_LM_SESSION_KEY_EXT 1
#define SAMINFO_LM_SESSION_KEY_SIZE (2*sizeof(ULONG))

    //
    // The third longword (4 bytes) of ExpansionRoom is the user account
    // control flag from the account.
    //

#define SAMINFO_USER_ACCOUNT_CONTROL 2
#define SAMINFO_USER_ACCOUNT_CONTROL_SIZE sizeof(ULONG)

    //
    // The fourth longword (4 bytes) of ExpansionRoom is for the status
    // returned for subauth users, not from subauth packages (NT5 onwards)
    //

#define SAMINFO_SUBAUTH_STATUS 3
#define SAMINFO_SUBAUTH_STATUS_SIZE sizeof(ULONG)

    ULONG    ExpansionRoom[10];        // Put new fields here

    //
    // The new fields in this structure are a count and a pointer to
    // an array of SIDs and attributes.
    //

    ULONG SidCount;

#ifdef MIDL_PASS
    [size_is(SidCount)]
#endif // MIDL_PASS
    PNETLOGON_SID_AND_ATTRIBUTES ExtraSids;

    //
    // New fields added for version 4 of the structure
    //

    UNICODE_STRING DnsLogonDomainName;  // Dns version of LogonDomainName

    UNICODE_STRING Upn;                 // UPN of the user account

    UNICODE_STRING ExpansionString1;    // Put new strings here
    UNICODE_STRING ExpansionString2;    // Put new strings here
    UNICODE_STRING ExpansionString3;    // Put new strings here
    UNICODE_STRING ExpansionString4;    // Put new strings here
    UNICODE_STRING ExpansionString5;    // Put new strings here
    UNICODE_STRING ExpansionString6;    // Put new strings here
    UNICODE_STRING ExpansionString7;    // Put new strings here
    UNICODE_STRING ExpansionString8;    // Put new strings here
    UNICODE_STRING ExpansionString9;    // Put new strings here
    UNICODE_STRING ExpansionString10;   // Put new strings here

} NETLOGON_VALIDATION_SAM_INFO4, *PNETLOGON_VALIDATION_SAM_INFO4 ;

// This structure is bogus since it doesn't have a size_is
// Everyone should use the generic info2 structure
typedef struct _NETLOGON_VALIDATION_GENERIC_INFO {
    ULONG DataLength;
    PUCHAR ValidationData;
} NETLOGON_VALIDATION_GENERIC_INFO, *PNETLOGON_VALIDATION_GENERIC_INFO;

typedef struct _NETLOGON_VALIDATION_GENERIC_INFO2 {
    ULONG DataLength;
#ifdef MIDL_PASS
    [size_is(DataLength)]
#endif // MIDL_PASS
    PUCHAR ValidationData;
} NETLOGON_VALIDATION_GENERIC_INFO2, *PNETLOGON_VALIDATION_GENERIC_INFO2;


//
// S4U Delegation Info
//

typedef struct _S4U_DELEGATION_INFO {
    UNICODE_STRING S4U2proxyTarget;
    ULONG TransitedListSize;
#ifdef MIDL_PASS
    [size_is(TransitedListSize)]
#endif // MIDL_PASS
    PUNICODE_STRING S4UTransitedServices;
} S4U_DELEGATION_INFO, * PS4U_DELEGATION_INFO;


//
// Status codes that indicate the password is bad and the call should
// be passed through to the PDC of the domain.
//

#define BAD_PASSWORD( _x ) \
    ((_x) == STATUS_WRONG_PASSWORD || \
     (_x) == STATUS_PASSWORD_EXPIRED || \
     (_x) == STATUS_PASSWORD_MUST_CHANGE || \
     (_x) == STATUS_ACCOUNT_LOCKED_OUT )

//
// Error status codes from the PDC that indicate that the bad password
// count should be zeroed locally on the BDC.
//

#define ZERO_BAD_PWD_COUNT( _x ) \
    ((_x) == STATUS_PASSWORD_EXPIRED || \
     (_x) == STATUS_PASSWORD_MUST_CHANGE )

//
// The actual logon and logoff routines.
//

// The following 2 procedure definitions must match
NTSTATUS
I_NetLogonSamLogon(
    IN LPWSTR LogonServer OPTIONAL,
    IN LPWSTR ComputerName OPTIONAL,
    IN PNETLOGON_AUTHENTICATOR Authenticator OPTIONAL,
    OUT PNETLOGON_AUTHENTICATOR ReturnAuthenticator OPTIONAL,
    IN NETLOGON_LOGON_INFO_CLASS LogonLevel,
    IN LPBYTE LogonInformation,
    IN NETLOGON_VALIDATION_INFO_CLASS ValidationLevel,
    OUT LPBYTE * ValidationInformation,
    OUT PBOOLEAN Authoritative
    );

typedef NTSTATUS
(*PNETLOGON_SAM_LOGON_PROCEDURE)(
    IN LPWSTR LogonServer OPTIONAL,
    IN LPWSTR ComputerName OPTIONAL,
    IN PNETLOGON_AUTHENTICATOR Authenticator OPTIONAL,
    OUT PNETLOGON_AUTHENTICATOR ReturnAuthenticator OPTIONAL,
    IN NETLOGON_LOGON_INFO_CLASS LogonLevel,
    IN LPBYTE LogonInformation,
    IN NETLOGON_VALIDATION_INFO_CLASS ValidationLevel,
    OUT LPBYTE * ValidationInformation,
    OUT PBOOLEAN Authoritative
    );

//
// Values of ExtraFlags
//
// For OS earlier that WIN 2K.  This field didn't exist.
//
// A WIN 2K client always passes zero and ignores the return.
// A WIN 2K server always returns what it is passed.
//
// A whistler client can pass the NETLOGON_SUPPORTS_CROSS_FOREST bits and ignores the return.
// A whistler server always returns what it is passed.
//
// In all cases, the flags correspond to the hop at hand.  Each hop computes which flags it
//      want to pass to the next hop.  It will only set bits that it understands.
//

// Flags introduced with NETLOGON_SUPPORTS_CROSS_FOREST
#define NL_EXFLAGS_EXPEDITE_TO_ROOT 0x0001      // Pass this request to DC at root of forest
#define NL_EXFLAGS_CROSS_FOREST_HOP 0x0002      // Request is first hop over cross forest trust TDO

NTSTATUS
I_NetLogonSamLogonEx (
    IN PVOID ContextHandle,
    IN LPWSTR LogonServer OPTIONAL,
    IN LPWSTR ComputerName OPTIONAL,
    IN NETLOGON_LOGON_INFO_CLASS LogonLevel,
    IN LPBYTE LogonInformation,
    IN NETLOGON_VALIDATION_INFO_CLASS ValidationLevel,
    OUT LPBYTE * ValidationInformation,
    OUT PBOOLEAN Authoritative,
    IN OUT PULONG ExtraFlags,
    OUT PBOOLEAN RpcFailed
    );

NTSTATUS
I_NetLogonSamLogonWithFlags (
    IN LPWSTR LogonServer OPTIONAL,
    IN LPWSTR ComputerName OPTIONAL,
    IN PNETLOGON_AUTHENTICATOR Authenticator OPTIONAL,
    OUT PNETLOGON_AUTHENTICATOR ReturnAuthenticator OPTIONAL,
    IN NETLOGON_LOGON_INFO_CLASS LogonLevel,
    IN LPBYTE LogonInformation,
    IN NETLOGON_VALIDATION_INFO_CLASS ValidationLevel,
    OUT LPBYTE * ValidationInformation,
    OUT PBOOLEAN Authoritative,
    IN OUT PULONG ExtraFlags
    );


// The following 2 procedure definitions must match
NTSTATUS
I_NetLogonSamLogoff (
    IN LPWSTR LogonServer OPTIONAL,
    IN LPWSTR ComputerName OPTIONAL,
    IN PNETLOGON_AUTHENTICATOR Authenticator OPTIONAL,
    OUT PNETLOGON_AUTHENTICATOR ReturnAuthenticator OPTIONAL,
    IN NETLOGON_LOGON_INFO_CLASS LogonLevel,
    IN LPBYTE LogonInformation
);

typedef NTSTATUS
(*PNETLOGON_SAM_LOGOFF_PROCEDURE) (
    IN LPWSTR LogonServer OPTIONAL,
    IN LPWSTR ComputerName OPTIONAL,
    IN PNETLOGON_AUTHENTICATOR Authenticator OPTIONAL,
    OUT PNETLOGON_AUTHENTICATOR ReturnAuthenticator OPTIONAL,
    IN NETLOGON_LOGON_INFO_CLASS LogonLevel,
    IN LPBYTE LogonInformation
);

//
// Actual logon/logoff routines for Cairo
//

NET_API_STATUS
NetlogonInitialize(
    PVOID Context
    );

NTSTATUS
NetlogonSamLogon (
    IN NETLOGON_LOGON_INFO_CLASS LogonLevel,
    IN LPBYTE LogonInformation,
    IN NETLOGON_VALIDATION_INFO_CLASS ValidationLevel,
    OUT LPBYTE *ValidationInformation,
    OUT PBOOLEAN Authoritative
    );

//
// Routine to get a list of NT DC's in the specified domain.
//
NET_API_STATUS NET_API_FUNCTION
I_NetGetDCList (
    IN  LPWSTR ServerName OPTIONAL,
    IN  LPWSTR TrustedDomainName,
    OUT PULONG DCCount,
    OUT PUNICODE_STRING * DCNames
    );

//
// Validation routine which lives in msv1_0.dll
//
NTSTATUS
MsvSamValidate (
    IN SAM_HANDLE DomainHandle,
    IN BOOLEAN UasCompatibilityRequired,
    IN NETLOGON_SECURE_CHANNEL_TYPE SecureChannelType,
    IN PUNICODE_STRING LogonServer,
    IN PUNICODE_STRING LogonDomainName,
    IN PSID LogonDomainId,
    IN NETLOGON_LOGON_INFO_CLASS LogonLevel,
    IN PVOID LogonInformation,
    IN NETLOGON_VALIDATION_INFO_CLASS ValidationLevel,
    OUT PVOID * ValidationInformation,
    OUT PBOOLEAN Authoritative,
    OUT PBOOLEAN BadPasswordCountZeroed,
    IN DWORD AccountsToTry
);

//
// Routine to get running number of logon attempts which lives in msv1_0.dll
//
ULONG
MsvGetLogonAttemptCount (
    VOID
);

// Values for AccountsToTry
#define MSVSAM_SPECIFIED 0x01        // Try specified account
#define MSVSAM_GUEST     0x02        // Try guest account

NTSTATUS
MsvSamLogoff (
    IN SAM_HANDLE DomainHandle,
    IN NETLOGON_LOGON_INFO_CLASS LogonLevel,
    IN PVOID LogonInformation
);

// begin_ntsubauth

// Values for Flags
#define MSV1_0_PASSTHRU     0x01
#define MSV1_0_GUEST_LOGON  0x02

NTSTATUS NTAPI
Msv1_0SubAuthenticationRoutine(
    IN NETLOGON_LOGON_INFO_CLASS LogonLevel,
    IN PVOID LogonInformation,
    IN ULONG Flags,
    IN PUSER_ALL_INFORMATION UserAll,
    OUT PULONG WhichFields,
    OUT PULONG UserFlags,
    OUT PBOOLEAN Authoritative,
    OUT PLARGE_INTEGER LogoffTime,
    OUT PLARGE_INTEGER KickoffTime
);

typedef struct _MSV1_0_VALIDATION_INFO {
    LARGE_INTEGER LogoffTime;
    LARGE_INTEGER KickoffTime;
    UNICODE_STRING LogonServer;
    UNICODE_STRING LogonDomainName;
    USER_SESSION_KEY SessionKey;
    BOOLEAN Authoritative;
    ULONG UserFlags;
    ULONG WhichFields;
    ULONG UserId;
} MSV1_0_VALIDATION_INFO, *PMSV1_0_VALIDATION_INFO;

// values for WhichFields

#define MSV1_0_VALIDATION_LOGOFF_TIME          0x00000001
#define MSV1_0_VALIDATION_KICKOFF_TIME         0x00000002
#define MSV1_0_VALIDATION_LOGON_SERVER         0x00000004
#define MSV1_0_VALIDATION_LOGON_DOMAIN         0x00000008
#define MSV1_0_VALIDATION_SESSION_KEY          0x00000010
#define MSV1_0_VALIDATION_USER_FLAGS           0x00000020
#define MSV1_0_VALIDATION_USER_ID              0x00000040

// legal values for ActionsPerformed
#define MSV1_0_SUBAUTH_ACCOUNT_DISABLED        0x00000001
#define MSV1_0_SUBAUTH_PASSWORD                0x00000002
#define MSV1_0_SUBAUTH_WORKSTATIONS            0x00000004
#define MSV1_0_SUBAUTH_LOGON_HOURS             0x00000008
#define MSV1_0_SUBAUTH_ACCOUNT_EXPIRY          0x00000010
#define MSV1_0_SUBAUTH_PASSWORD_EXPIRY         0x00000020
#define MSV1_0_SUBAUTH_ACCOUNT_TYPE            0x00000040
#define MSV1_0_SUBAUTH_LOCKOUT                 0x00000080

NTSTATUS NTAPI
Msv1_0SubAuthenticationRoutineEx(
    IN NETLOGON_LOGON_INFO_CLASS LogonLevel,
    IN PVOID LogonInformation,
    IN ULONG Flags,
    IN PUSER_ALL_INFORMATION UserAll,
    IN SAM_HANDLE UserHandle,
    IN OUT PMSV1_0_VALIDATION_INFO ValidationInfo,
    OUT PULONG ActionsPerformed
);

NTSTATUS NTAPI
Msv1_0SubAuthenticationRoutineGeneric(
    IN PVOID SubmitBuffer,
    IN ULONG SubmitBufferLength,
    OUT PULONG ReturnBufferLength,
    OUT PVOID *ReturnBuffer
);

NTSTATUS NTAPI
Msv1_0SubAuthenticationFilter(
    IN NETLOGON_LOGON_INFO_CLASS LogonLevel,
    IN PVOID LogonInformation,
    IN ULONG Flags,
    IN PUSER_ALL_INFORMATION UserAll,
    OUT PULONG WhichFields,
    OUT PULONG UserFlags,
    OUT PBOOLEAN Authoritative,
    OUT PLARGE_INTEGER LogoffTime,
    OUT PLARGE_INTEGER KickoffTime
);

// end_ntsubauth

#endif // __LOGONMSV_H__
=== C:/Users/treeman/Desktop/windows nt source code\Source\Win2K3\NT\public\internal\ds\inc\lsass.h ===
/*++

Copyright (c) 1987-1991  Microsoft Corporation

Module Name:

    lsass.h

Abstract:

    This is a common header file for all codes that go in lsass.exe (ie
    in security process).

Author:

    Madan Appiah (madana) 23-Mar-1993

Environment:

    User mode only.
    Contains NT-specific code.
    Requires ANSI C extensions: slash-slash comments, long external names.

Revision History:

--*/

#ifndef _LSASS_
#define _LSASS_

//
// DON'T USE the following LARGE_INTEGER definitions. These definitions
// are used only by few old RPC code for compatibilty reason.
//

typedef struct _OLD_LARGE_INTEGER {
    ULONG LowPart;
    LONG HighPart;
} OLD_LARGE_INTEGER, *POLD_LARGE_INTEGER;

#define OLD_TO_NEW_LARGE_INTEGER(Old, New) { \
    (New).LowPart = (Old).LowPart; \
    (New).HighPart = (Old).HighPart; \
    }

#define NEW_TO_OLD_LARGE_INTEGER(New, Old) { \
    (Old).LowPart = (New).LowPart; \
    (Old).HighPart = (New).HighPart; \
    }

#endif // _LSASS
=== C:/Users/treeman/Desktop/windows nt source code\Source\Win2K3\NT\public\internal\ds\inc\lsaisrv.h ===
/*++ BUILD Version: 0001    // Increment this if a change has global effects

Copyright (c) 1992  Microsoft Corporation

Module Name:

    lsaisrv.h

Abstract:

    This file contains interfaces to internal routines in the Lsa
    Server that provide additional functionality not contained in
    the Lsar routines.  These routines are only used by LSA clients which
    live in the same process as the LSA server.


Author:

    Scott Birrell (ScottBi) April 8, 1992

Environment:

    User Mode - Win32

Revision History:


--*/

#ifndef _LSAISRV_
#define _LSAISRV_

#ifdef __cplusplus
extern "C" {
#endif

//
// The following constants are defined for callers of the LsaIHealthCheckRoutine
//
// 1. LSAI_SAM_STATE_SESS_KEY is used to convey the syskey by SAM to LSA.
//    This is used in upgrade cases from NT4 and win2k B3 and RC1.
//    SAM in these cases knows the syskey
//
// 2. LSAI_SAM_STATE_UNROLL_SP4_ENCRYPTION is used to convey SAM's password
//    encryption key to LSA. This is used to unroll encryption used in NT4 SP4
//    ( incorrectly ) using SAM's password encryption key
//
// 3. LSAI_SAM_STATE_RETRIEVE_SESS_KEY is used by SAM/DS to retrieve the
//    from LSA to decrypt their respective password encryption keys
//
// 4. LSAI_SAM_GENERATE_SESS_KEY is used by SAM to tell the LSA to generate
//     a new Password Encryption key in the case where we are upgrading
//    from a NT4 or Win2k B3 or RC1 Machine and the machine is not syskey'd
//
// 5. LSAI_SAM_STATE_CLEAR_SESS_KEY is used by SAM or DS to clear the syskey
//    after it has been used for decrypting their respective password
//    encryption keys.
//
// 6. LSAI_SAM_STATE_OLD_SESS_KEY This is used to retrieve the old syskey in
//    to implement error recovery during syskey change cases.
//


#define LSAI_SAM_STATE_SESS_KEY              0x1
#define LSAI_SAM_STATE_UNROLL_SP4_ENCRYPTION 0x2
#define LSAI_SAM_STATE_RETRIEVE_SESS_KEY     0x3
#define LSAI_SAM_STATE_CLEAR_SESS_KEY        0x4
#define LSAI_SAM_GENERATE_SESS_KEY           0x5
#define LSAI_SAM_STATE_OLD_SESS_KEY          0x6

//
// Internal limit on the number of SIDs that can be assigned to a single
// security context.  If, for some reason, someone logs on to an account
// and is assigned more than this number of SIDs, the logon will fail.
// An error should be logged in this case.
//

#define LSAI_CONTEXT_SID_LIMIT 1024

///////////////////////////////////////////////////////////////////////////////
//                                                                           //
// The following prototypes are usable throughout the process that the       //
// LSA server resides in.                                                    //
//                                                                           //
///////////////////////////////////////////////////////////////////////////////

NTSTATUS NTAPI
LsaIHealthCheck(
    IN LSAPR_HANDLE DomainHandle OPTIONAL,
    IN ULONG StateChange,
    IN OUT PVOID StateChangeData,
    IN OUT PULONG StateChangeDataLength
    );

NTSTATUS NTAPI
LsaIOpenPolicyTrusted(
    OUT PLSAPR_HANDLE PolicyHandle
    );

NTSTATUS NTAPI
LsaIQueryInformationPolicyTrusted(
    IN POLICY_INFORMATION_CLASS InformationClass,
    OUT PLSAPR_POLICY_INFORMATION *Buffer
    );

NTSTATUS NTAPI
LsaIGetSerialNumberPolicy(
    IN LSAPR_HANDLE PolicyHandle,
    OUT PLARGE_INTEGER ModifiedCount,
    OUT PLARGE_INTEGER CreationTime
    );

NTSTATUS NTAPI
LsaISetSerialNumberPolicy(
    IN LSAPR_HANDLE PolicyHandle,
    IN PLARGE_INTEGER ModifiedCount,
    IN PLARGE_INTEGER CreationTime,
    IN BOOLEAN StartOfFullSync
    );

NTSTATUS NTAPI
LsaIEnumerateSecrets(
    IN LSAPR_HANDLE PolicyHandle,
    IN OUT PLSA_ENUMERATION_HANDLE EnumerationContext,
    OUT PVOID *Buffer,
    IN ULONG PreferedMaximumLength,
    OUT PULONG CountReturned
    );

NTSTATUS NTAPI
LsaISetTimesSecret(
    IN LSAPR_HANDLE SecretHandle,
    IN PLARGE_INTEGER CurrentValueSetTime,
    IN PLARGE_INTEGER OldValueSetTime
    );

#ifdef __LOGONMSV_H__ // This API is only of interest to users of logonmsv.h

NTSTATUS NTAPI
LsaIFilterSids(
    IN PUNICODE_STRING TrustedDomainName,
    IN ULONG TrustDirection,
    IN ULONG TrustType,
    IN ULONG TrustAttributes,
    IN OPTIONAL PSID Sid,
    IN NETLOGON_VALIDATION_INFO_CLASS InfoClass,
    IN OUT PVOID SamInfo,
    IN OPTIONAL PSID ResourceGroupDomainSid,
    IN OUT OPTIONAL PULONG ResourceGroupCount,
    IN OUT OPTIONAL PGROUP_MEMBERSHIP ResourceGroupIds
    );

NTSTATUS NTAPI
LsaIFilterNamespace(
    IN PUNICODE_STRING TrustedDomainName,
    IN ULONG TrustDirection,
    IN ULONG TrustType,
    IN ULONG TrustAttributes,
    IN PUNICODE_STRING Namespace
    );

#endif

typedef enum {

    RoutingMatchDomainSid,
    RoutingMatchDomainName,
    RoutingMatchUpn,
    RoutingMatchSpn,
    RoutingMatchNamespace

} LSA_ROUTING_MATCH_TYPE;

NTSTATUS NTAPI
LsaIForestTrustFindMatch(
    IN LSA_ROUTING_MATCH_TYPE Type,
    IN PVOID Data,
    OUT PLSA_UNICODE_STRING Match
    );

VOID
LsaIFree_LSA_FOREST_TRUST_INFORMATION(
    IN PLSA_FOREST_TRUST_INFORMATION * ForestTrustInfo
    );

VOID
LsaIFree_LSA_FOREST_TRUST_COLLISION_INFORMATION(
    IN PLSA_FOREST_TRUST_COLLISION_INFORMATION * CollisionInfo
    );

BOOLEAN NTAPI
LsaISetupWasRun(
    );

BOOLEAN NTAPI
LsaISafeMode(
    VOID
    );

BOOLEAN NTAPI
LsaILookupWellKnownName(
    IN PUNICODE_STRING WellKnownName
    );

VOID NTAPI
LsaIFree_LSAPR_ACCOUNT_ENUM_BUFFER (
    IN PLSAPR_ACCOUNT_ENUM_BUFFER EnumerationBuffer
    );

VOID NTAPI
LsaIFree_LSAPR_TRANSLATED_SIDS (
    IN PLSAPR_TRANSLATED_SIDS TranslatedSids
    );

VOID NTAPI
LsaIFree_LSAPR_TRANSLATED_NAMES (
    IN PLSAPR_TRANSLATED_NAMES TranslatedNames
    );

VOID NTAPI
LsaIFree_LSAPR_POLICY_INFORMATION (
    IN POLICY_INFORMATION_CLASS InformationClass,
    IN PLSAPR_POLICY_INFORMATION PolicyInformation
    );

VOID NTAPI
LsaIFree_LSAPR_POLICY_DOMAIN_INFORMATION (
    IN POLICY_DOMAIN_INFORMATION_CLASS DomainInformationClass,
    IN PLSAPR_POLICY_DOMAIN_INFORMATION PolicyDomainInformation
    );

VOID NTAPI
LsaIFree_LSAPR_TRUSTED_DOMAIN_INFO (
    IN TRUSTED_INFORMATION_CLASS InformationClass,
    IN PLSAPR_TRUSTED_DOMAIN_INFO TrustedDomainInformation
    );

VOID NTAPI
LsaIFree_LSAPR_REFERENCED_DOMAIN_LIST (
    IN PLSAPR_REFERENCED_DOMAIN_LIST ReferencedDomains
    );

VOID NTAPI
LsaIFree_LSAPR_TRUSTED_ENUM_BUFFER (
    IN PLSAPR_TRUSTED_ENUM_BUFFER EnumerationBuffer
    );

VOID NTAPI
LsaIFree_LSAPR_TRUSTED_ENUM_BUFFER_EX (
    PLSAPR_TRUSTED_ENUM_BUFFER_EX EnumerationBuffer
    );

VOID NTAPI
LsaIFree_LSAPR_TRUST_INFORMATION (
    IN PLSAPR_TRUST_INFORMATION TrustInformation
    );

VOID NTAPI
LsaIFree_LSAP_SECRET_ENUM_BUFFER (
    IN PVOID Buffer,
    IN ULONG Count
    );

VOID NTAPI
LsaIFree_LSAPR_PRIVILEGE_ENUM_BUFFER (
    PLSAPR_PRIVILEGE_ENUM_BUFFER EnumerationBuffer
    );

VOID NTAPI
LsaIFree_LSAPR_SR_SECURITY_DESCRIPTOR (
    IN PLSAPR_SR_SECURITY_DESCRIPTOR SecurityDescriptor
    );

VOID
LsaIFree_LSAI_SECRET_ENUM_BUFFER (
    IN PVOID Buffer,
    IN ULONG Count
    );

VOID NTAPI
LsaIFree_LSAI_PRIVATE_DATA (
    IN PVOID Data
    );

VOID NTAPI
LsaIFree_LSAPR_UNICODE_STRING (
    IN PLSAPR_UNICODE_STRING UnicodeName
    );

VOID NTAPI
LsaIFree_LSAPR_UNICODE_STRING_BUFFER (
    IN PLSAPR_UNICODE_STRING UnicodeName
    );

VOID NTAPI
LsaIFree_LSAPR_PRIVILEGE_SET (
    IN PLSAPR_PRIVILEGE_SET PrivilegeSet
    );

VOID NTAPI
LsaIFree_LSAPR_CR_CIPHER_VALUE (
    IN PLSAPR_CR_CIPHER_VALUE CipherValue
    );


//
// Enumeration to describe the attribute value data
//
typedef enum _LSAP_AUDIT_SAM_ATTR_DELTA_TYPE
{
    LsapAuditSamAttrUnchanged = 0,
    LsapAuditSamAttrNewValue,
    LsapAuditSamAttrNoValue,
    LsapAuditSamAttrSecret
    
} LSAP_SAM_AUDIT_ATTR_DELTA_TYPE, *PLSAP_SAM_AUDIT_ATTR_DELTA_TYPE;


//
// Macro to compute the UINT_PTR offset of a field in a structure type
//
#define LSAP_FIELD_PTR(Type, Field) \
    ((FIELD_OFFSET(Type, Field)) / sizeof(UINT_PTR))


//
// Macro to compute the index into AttrDeltaType given the containing
// structure's base address and the address of the associated field whos
// delta type is desired.
//
// Base  - pointer to the structure
// Field - pointer to attribute field whos deltatype is being indexed
//
#define LSAP_INDEX_ATTR_DELTA_TYPE(Base, Field) \
    ((((UINT_PTR)(Field)) - ((UINT_PTR)(Base))) / sizeof(UINT_PTR))


//
// Attribute change information for auditing domain objects
//
#define LSAP_DOMAIN_ATTR_COUNT 13
//
// The above count must match the number of attribute pointers in the
// associated structure as it determines how many attributes we 
// maintain LSAI_SAM_AUDIT_ATTR_DELTA_TYPEs for.
//

typedef struct _LSAP_AUDIT_DOMAIN_ATTR_VALUES
{   
    PLARGE_INTEGER          MinPasswordAge;
    PLARGE_INTEGER          MaxPasswordAge;
    PLARGE_INTEGER          ForceLogoff;
    PUSHORT                 LockoutThreshold;
    PLARGE_INTEGER          LockoutObservationWindow;
    PLARGE_INTEGER          LockoutDuration;
    PULONG                  PasswordProperties;
    PUSHORT                 MinPasswordLength;
    PUSHORT                 PasswordHistoryLength;
    PULONG                  MachineAccountQuota;  
    PULONG                  MixedDomainMode;
    PULONG                  DomainBehaviorVersion;
    PUNICODE_STRING         OemInformation;
    
    LSAP_SAM_AUDIT_ATTR_DELTA_TYPE AttrDeltaType[LSAP_DOMAIN_ATTR_COUNT];

} LSAP_AUDIT_DOMAIN_ATTR_VALUES, *PLSAP_AUDIT_DOMAIN_ATTR_VALUES;


//
// Attribute change information for auditing user/computer objects
//

#define LSAP_USER_ATTR_COUNT 18


//
// The above count must match the number of attribute pointers in the
// associated structure as it determines how many attributes we 
// maintain LSAI_SAM_AUDIT_ATTR_DELTA_TYPEs for.
//

typedef struct _LSAP_AUDIT_USER_ATTR_VALUES
{
    PUNICODE_STRING         SamAccountName;
    PUNICODE_STRING         DisplayName;
    PUNICODE_STRING         UserPrincipalName;
    PUNICODE_STRING         HomeDirectory;
    PUNICODE_STRING         HomeDrive;
    PUNICODE_STRING         ScriptPath;
    PUNICODE_STRING         ProfilePath;
    PUNICODE_STRING         UserWorkStations;
    PFILETIME               PasswordLastSet;
    PFILETIME               AccountExpires;
    PULONG                  PrimaryGroupId;
    PLSA_ADT_STRING_LIST    AllowedToDelegateTo;
    PULONG                  UserAccountControl;
    PUNICODE_STRING         UserParameters;
    PLSA_ADT_SID_LIST       SidHistory;
    PLOGON_HOURS            LogonHours;
    
    // Computers only
    PUNICODE_STRING         DnsHostName;
    PLSA_ADT_STRING_LIST    ServicePrincipalNames; 

    // Metadata indicating how each of the above were changed
    LSAP_SAM_AUDIT_ATTR_DELTA_TYPE AttrDeltaType[LSAP_USER_ATTR_COUNT];
    
    // Valid only if UserAccountControl is non-NULL
    PULONG                  PrevUserAccountControl;
    
} LSAP_AUDIT_USER_ATTR_VALUES, *PLSAP_AUDIT_USER_ATTR_VALUES;


//
// Attribute change information for auditing group/alias objects
//

#define LSAP_GROUP_ATTR_COUNT 2


//
// The above count must match the number of attribute pointers in the
// associated structure as it determines how many attributes we 
// maintain LSAI_SAM_AUDIT_ATTR_DELTA_TYPEs for.
//

typedef struct _LSAP_AUDIT_GROUP_ATTR_VALUES
{   
    PUNICODE_STRING         SamAccountName;
    PLSA_ADT_SID_LIST       SidHistory;
    
    LSAP_SAM_AUDIT_ATTR_DELTA_TYPE AttrDeltaType[LSAP_GROUP_ATTR_COUNT];

} LSAP_AUDIT_GROUP_ATTR_VALUES, *PLSAP_AUDIT_GROUP_ATTR_VALUES;


NTSTATUS NTAPI
LsaIAuditSamEvent(
    IN NTSTATUS             Status,
    IN ULONG                AuditId,
    IN PSID                 DomainSid,
    IN PUNICODE_STRING      AdditionalInfo    OPTIONAL,
    IN PULONG               MemberRid         OPTIONAL,
    IN PSID                 MemberSid         OPTIONAL,
    IN PUNICODE_STRING      AccountName       OPTIONAL,
    IN PUNICODE_STRING      DomainName,
    IN PULONG               AccountRid        OPTIONAL,
    IN PPRIVILEGE_SET       Privileges        OPTIONAL,
    IN PVOID                ExtendedInfo      OPTIONAL
    );

NTSTATUS NTAPI
LsaIAuditNotifyPackageLoad(
    PUNICODE_STRING PackageFileName
    );

NTSTATUS NTAPI
LsaIAuditKdcEvent(
    IN ULONG                 AuditId,
    IN PUNICODE_STRING       ClientName,
    IN PUNICODE_STRING       ClientDomain,
    IN PSID                  ClientSid,
    IN PUNICODE_STRING       ServiceName,
    IN PSID                  ServiceSid,
    IN PULONG                KdcOptions,
    IN PULONG                KerbStatus,
    IN PULONG                EncryptionType,
    IN PULONG                PreAuthType,
    IN PBYTE                 ClientAddress,
    IN LPGUID                LogonGuid           OPTIONAL,
    IN PLSA_ADT_STRING_LIST  TransittedServices  OPTIONAL,
    IN PUNICODE_STRING       CertIssuerName      OPTIONAL,
    IN PUNICODE_STRING       CertSerialNumber    OPTIONAL,
    IN PUNICODE_STRING       CertThumbprint      OPTIONAL
    );

NTSTATUS
LsaIGetLogonGuid(
    IN PUNICODE_STRING pUserName,
    IN PUNICODE_STRING pUserDomain,
    IN PBYTE pBuffer,
    IN UINT BufferSize,
    OUT LPGUID pLogonGuid
    );

NTSTATUS
LsaISetLogonGuidInLogonSession(
    IN  PLUID           LogonId,
    IN  LPGUID          LogonGuid           OPTIONAL
    );

VOID
LsaIAuditKerberosLogon(
    IN NTSTATUS LogonStatus,
    IN NTSTATUS LogonSubStatus,
    IN PUNICODE_STRING AccountName,
    IN PUNICODE_STRING AuthenticatingAuthority,
    IN PUNICODE_STRING WorkstationName,
    IN PSID UserSid,                            OPTIONAL
    IN SECURITY_LOGON_TYPE LogonType,
    IN PTOKEN_SOURCE TokenSource,
    IN PLUID LogonId,
    IN LPGUID LogonGuid,
    IN PLSA_ADT_STRING_LIST TransittedServices
    );

NTSTATUS
LsaIAuditLogonUsingExplicitCreds(
    IN USHORT          AuditEventType,
    IN PLUID           pUser1LogonId,          
    IN LPGUID          pUser1LogonGuid,         OPTIONAL
    IN HANDLE          User1ProcessId,
    IN PUNICODE_STRING pUser2Name,
    IN PUNICODE_STRING pUser2Domain,
    IN LPGUID          pUser2LogonGuid,
    IN PUNICODE_STRING pTargetName,
    IN PUNICODE_STRING pTargetInfo
    );

NTSTATUS
LsaIAdtAuditingEnabledByCategory(
    IN  POLICY_AUDIT_EVENT_TYPE Category,
    IN  USHORT                  AuditEventType,
    IN  PSID                    pUserSid        OPTIONAL,
    IN  PLUID                   pLogonId        OPTIONAL,
    OUT PBOOLEAN                pbAudit
    );

NTSTATUS
LsaIAuditAccountLogon(
    IN ULONG                AuditId,
    IN BOOLEAN              Successful,
    IN PUNICODE_STRING      Source, 
    IN PUNICODE_STRING      ClientName,
    IN PUNICODE_STRING      MappedName,
    IN NTSTATUS             Status          OPTIONAL
    );

NTSTATUS
LsaIAuditAccountLogonEx(
    IN ULONG                AuditId,
    IN BOOLEAN              Successful,
    IN PUNICODE_STRING      Source, 
    IN PUNICODE_STRING      ClientName,
    IN PUNICODE_STRING      MappedName,
    IN NTSTATUS             Status,          OPTIONAL
    IN PSID                 ClientSid
    );

NTSTATUS NTAPI
LsaIAuditDPAPIEvent(
    IN ULONG                AuditId,
    IN PSID                 UserSid,
    IN PUNICODE_STRING      MasterKeyID,
    IN PUNICODE_STRING      RecoveryServer,
    IN PULONG               Reason,
    IN PUNICODE_STRING      RecoverykeyID,
    IN PULONG               FailureReason
    );

#define LSA_AUDIT_PARAMETERS_ABSOLUTE 1

NTSTATUS NTAPI
LsaIWriteAuditEvent(
    IN PSE_ADT_PARAMETER_ARRAY AuditParameters,
    IN ULONG Options
    );


NTSTATUS
LsaIAuditPasswordAccessEvent(
    IN USHORT EventType,
    IN PCWSTR pszTargetUserName,
    IN PCWSTR pszTargetUserDomain
    );
    
VOID
LsaIAuditFailed(
    NTSTATUS AuditStatus
    );

NTSTATUS NTAPI
LsaICallPackage(
    IN PUNICODE_STRING AuthenticationPackage,
    IN PVOID ProtocolSubmitBuffer,
    IN ULONG SubmitBufferLength,
    OUT PVOID *ProtocolReturnBuffer,
    OUT PULONG ReturnBufferLength,
    OUT PNTSTATUS ProtocolStatus
    );

VOID NTAPI
LsaIFreeReturnBuffer(
    IN PVOID Buffer
    );

//
// NT5 routines for using the Ds for Lsa store
//

#define LSAI_FOREST_ROOT_TRUST              0x00000001
#define LSAI_FOREST_DOMAIN_GUID_PRESENT     0x00000002

//
// These structures correspond to the private interface Kerberos uses
// to build a tree of the domains in an organization.
//

typedef struct _LSAPR_TREE_TRUST_INFO {

    UNICODE_STRING DnsDomainName;
    UNICODE_STRING FlatName;
    GUID DomainGuid;
    PSID DomainSid;
    ULONG Flags;
    ULONG Children;
    struct _LSAPR_TREE_TRUST_INFO *ChildDomains;
} LSAPR_TREE_TRUST_INFO, *PLSAPR_TREE_TRUST_INFO;

typedef struct _LSAPR_FOREST_TRUST_INFO {

    LSAPR_TREE_TRUST_INFO RootTrust;
    PLSAPR_TREE_TRUST_INFO ParentDomainReference;

} LSAPR_FOREST_TRUST_INFO, *PLSAPR_FOREST_TRUST_INFO;

VOID
LsaIFreeForestTrustInfo(
    IN PLSAPR_FOREST_TRUST_INFO ForestTrustInfo
    );

NTSTATUS
NTAPI
LsaIQueryForestTrustInfo(
    IN LSAPR_HANDLE PolicyHandle,
    OUT PLSAPR_FOREST_TRUST_INFO *ForestTrustInfo
    );

NTSTATUS NTAPI
LsaISetTrustedDomainAuthInfoBlobs(
    IN LSAPR_HANDLE PolicyHandle,
    IN PLSAPR_UNICODE_STRING TrustedDomainName,
    IN PLSAPR_TRUSTED_DOMAIN_AUTH_BLOB IncomingBlob,
    IN PLSAPR_TRUSTED_DOMAIN_AUTH_BLOB OutgoingBlob);

NTSTATUS NTAPI
LsaIUpgradeRegistryToDs(
    IN BOOLEAN DeleteOnly
    );

NTSTATUS NTAPI
LsaIGetTrustedDomainAuthInfoBlobs(
    IN  LSAPR_HANDLE PolicyHandle,
    IN  PLSAPR_UNICODE_STRING TrustedDomainName,
    OUT PLSAPR_TRUSTED_DOMAIN_AUTH_BLOB IncomingBlob,
    OUT PLSAPR_TRUSTED_DOMAIN_AUTH_BLOB OutgoingBlob
    );

NTSTATUS NTAPI
LsaIDsNotifiedObjectChange(
    IN ULONG Class,
    IN PVOID ObjectPath,   // This is a DSNAME
    IN SECURITY_DB_DELTA_TYPE DeltaType,
    IN PSID UserSid,
    IN LUID AuthenticationId,
    IN BOOLEAN fReplicatedIn,
    IN BOOLEAN ChangeOriginatedInLSA
    );

typedef NTSTATUS (NTAPI *pfLsaIDsNotifiedObjectChange )(
        ULONG, PVOID, SECURITY_DB_DELTA_TYPE, PSID, LUID, BOOLEAN, BOOLEAN );

//
// NT5 routines for moving some SAM domain object properties to the Lsa Ds objects
//

NTSTATUS NTAPI
LsaISamIndicatedDsStarted(
    IN BOOLEAN PerformDomainRenameCheck
    );

//
// Netlogon routines for enumerating subnets
//

typedef struct _LSAP_SUBNET_INFO_ENTRY {
    UNICODE_STRING SubnetName;
    UNICODE_STRING SiteName;
} LSAP_SUBNET_INFO_ENTRY, *PLSAP_SUBNET_INFO_ENTRY;

typedef struct _LSAP_SUBNET_INFO {
    ULONG SiteCount;
    ULONG SubnetCount;
    LSAP_SUBNET_INFO_ENTRY Subnets[1];
} LSAP_SUBNET_INFO, *PLSAP_SUBNET_INFO;

NTSTATUS NTAPI
LsaIQuerySubnetInfo(
    OUT PLSAP_SUBNET_INFO *SubnetInformation
    );

VOID NTAPI
LsaIFree_LSAP_SUBNET_INFO(
    IN PLSAP_SUBNET_INFO SubnetInfo
    );

//
// Netlogon routines for UPN/SPN suffixes
//

typedef struct _LSAP_UPN_SUFFIXES {
    ULONG SuffixCount;
    UNICODE_STRING Suffixes[1];
} LSAP_UPN_SUFFIXES, *PLSAP_UPN_SUFFIXES;

NTSTATUS
LsaIQueryUpnSuffixes(
    OUT PLSAP_UPN_SUFFIXES *UpnSuffixes
    );

VOID
LsaIFree_LSAP_UPN_SUFFIXES(
    IN PLSAP_UPN_SUFFIXES UpnSuffixes
    );

NTSTATUS
LsaIGetForestTrustInformation(
    OUT PLSA_FOREST_TRUST_INFORMATION *ForestTrustInfo
    );

NTSTATUS
LsaIUpdateForestTrustInformation(
    IN LSAPR_HANDLE PolicyHandle,
    IN UNICODE_STRING * TrustedDomainName,
    IN PLSA_FOREST_TRUST_INFORMATION NewForestTrustInfo
    );

//
// Netlogon routines for enumerating sites
//

typedef struct _LSAP_SITE_INFO_ENTRY {
    UNICODE_STRING SiteName;
} LSAP_SITE_INFO_ENTRY, *PLSAP_SITE_INFO_ENTRY;

typedef struct _LSAP_SITE_INFO {
    ULONG SiteCount;
    LSAP_SITE_INFO_ENTRY Sites[1];
} LSAP_SITE_INFO, *PLSAP_SITE_INFO;

NTSTATUS NTAPI
LsaIQuerySiteInfo(
    OUT PLSAP_SITE_INFO *SiteInformation
    );

VOID NTAPI
LsaIFree_LSAP_SITE_INFO(
    IN PLSAP_SITE_INFO SubnetInfo
    );

//
// Netlogon routines for getting the name of the site we're in.
//

typedef struct _LSAP_SITENAME_INFO {
    UNICODE_STRING SiteName;
    GUID DsaGuid;
    ULONG DsaOptions;
} LSAP_SITENAME_INFO, *PLSAP_SITENAME_INFO;

NTSTATUS NTAPI
LsaIGetSiteName(
    OUT PLSAP_SITENAME_INFO *SiteNameInformation
    );

VOID NTAPI
LsaIFree_LSAP_SITENAME_INFO(
    IN PLSAP_SITENAME_INFO SiteNameInfo
    );

BOOLEAN NTAPI
LsaIIsDsPaused(
    VOID
    );

//
// Lsa notification routine definitions
//

//
// Notification callback routine prototype
//
typedef VOID ( NTAPI fLsaPolicyChangeNotificationCallback) (
    IN POLICY_NOTIFICATION_INFORMATION_CLASS ChangedInfoClass
    );

typedef fLsaPolicyChangeNotificationCallback *pfLsaPolicyChangeNotificationCallback;

NTSTATUS NTAPI
LsaIRegisterPolicyChangeNotificationCallback(
    IN pfLsaPolicyChangeNotificationCallback Callback,
    IN POLICY_NOTIFICATION_INFORMATION_CLASS MonitorInfoClass
    );

NTSTATUS NTAPI
LsaIUnregisterPolicyChangeNotificationCallback(
    IN pfLsaPolicyChangeNotificationCallback Callback,
    IN POLICY_NOTIFICATION_INFORMATION_CLASS MonitorInfoClass
    );

NTSTATUS NTAPI
LsaIUnregisterAllPolicyChangeNotificationCallback(
    IN pfLsaPolicyChangeNotificationCallback Callback
    );

HANDLE NTAPI
LsaIRegisterNotification(
    IN PTHREAD_START_ROUTINE StartFunction,
    IN PVOID Parameter,
    IN ULONG NotificationType,
    IN ULONG NotificationClass,
    IN ULONG NotificationFlags,
    IN ULONG IntervalMinutes,
    IN OPTIONAL HANDLE WaitEvent
    );

NTSTATUS NTAPI
LsaICancelNotification(
    IN HANDLE NotifyHandle
    );

//
// This is the notification Kerberos registers to receive updates on changing trusts
//

typedef VOID (fLsaTrustChangeNotificationCallback) (
    IN SECURITY_DB_DELTA_TYPE DeltaType
    );

typedef fLsaTrustChangeNotificationCallback *pfLsaTrustChangeNotificationCallback;

typedef enum LSAP_REGISTER {

    LsaRegister = 0,
    LsaUnregister

} LSAP_REGISTER, *PLSAP_REGISTER;

NTSTATUS NTAPI
LsaIKerberosRegisterTrustNotification(
    IN pfLsaTrustChangeNotificationCallback Callback,
    IN LSAP_REGISTER Register
    );

//
// See secpkg.h : LsaGetCallInfo and SECPKG_CALL_INFO
//

BOOLEAN
NTAPI
LsaIGetCallInfo(
    PVOID
    );

NTSTATUS
LsaISetTokenDacl(
    IN HANDLE Token
    );

NTSTATUS
LsaISetClientDnsHostName(
    IN PWSTR ClientName,
    IN PWSTR ClientDnsHostName OPTIONAL,
    IN POSVERSIONINFOEXW OsVersionInfo OPTIONAL,
    IN PWSTR OsName OPTIONAL,
    OUT PWSTR *OldDnsHostName OPTIONAL
    );

NTSTATUS
LsaICallPackageEx(
    IN PUNICODE_STRING AuthenticationPackage,
    IN PVOID ClientBufferBase,
    IN PVOID ProtocolSubmitBuffer,
    IN ULONG SubmitBufferLength,
    OUT PVOID * ProtocolReturnBuffer,
    OUT PULONG ReturnBufferLength,
    OUT PNTSTATUS ProtocolStatus
    );

NTSTATUS
LsaICallPackagePassthrough(
    IN PUNICODE_STRING AuthenticationPackage,
    IN PVOID ClientBufferBase,
    IN PVOID ProtocolSubmitBuffer,
    IN ULONG SubmitBufferLength,
    OUT PVOID * ProtocolReturnBuffer,
    OUT PULONG ReturnBufferLength,
    OUT PNTSTATUS ProtocolStatus
    );

NTSTATUS
LsaISetBootOption(
   IN ULONG BootOption,
   IN PVOID OldKey,
   IN ULONG OldKeyLength,
   IN PVOID NewKey,
   IN ULONG NewKeyLength
    );

NTSTATUS
LsaIGetBootOption(
   OUT PULONG BootOption
   );

VOID
LsaINotifyPasswordChanged(
    IN PUNICODE_STRING NetbiosDomainName OPTIONAL,
    IN PUNICODE_STRING UserName,
    IN PUNICODE_STRING DnsDomainName OPTIONAL,
    IN PUNICODE_STRING Upn OPTIONAL,
    IN PUNICODE_STRING OldPassword,
    IN PUNICODE_STRING NewPassword,
    IN BOOLEAN Impersonating
    );

NTSTATUS
LsaINotifyChangeNotification(
    IN POLICY_NOTIFICATION_INFORMATION_CLASS InfoClass
    );

NTSTATUS
LsaIGetNbAndDnsDomainNames(
    IN PUNICODE_STRING DomainName,
    OUT PUNICODE_STRING DnsDomainName,
    OUT PUNICODE_STRING NetbiosDomainName
    );

//
// This flag indicates the the protected blob is a system blob, and cannot
// be decrypted by the user-space.
//

#define CRYPTPROTECT_SYSTEM  0x20000000

//
// Local Free should be used to free the returned buffer
//

BOOLEAN
LsaICryptProtectData(
        IN PVOID          DataIn,
        IN ULONG         DataInLength,
        IN PUNICODE_STRING        szDataDescr,
        IN PVOID          OptionalEntropy,
        IN ULONG          OptionalEntropyLength,
        IN PVOID          Reserved,
        IN PVOID          Reserved2,
        IN ULONG          Flags,
        OUT PVOID  *      DataOut,
        OUT PULONG        DataOutLength);

//
// Local Free should be used to free the returned buffer
//

BOOLEAN
LsaICryptUnprotectData(
        IN PVOID          DataIn,
        IN ULONG          DataInLength,
        IN PVOID          OptionalEntropy,
        IN ULONG          OptionalEntropyLength,
        IN PVOID          Reserved,
        IN PVOID          Reserved2,
        IN ULONG          Flags,
        OUT PUNICODE_STRING        szDataDescr,
        OUT PVOID  *      DataOut,
        OUT PULONG        DataOutLength);

//
// Heap allocator for the LSA process
//

PVOID
NTAPI
LsaIAllocateHeap(
    IN SIZE_T cbMemory
    );

VOID
NTAPI
LsaIFreeHeap(
    IN PVOID Base
    );

typedef enum LSAP_NETLOGON_PARAMETER {

   LsaEmulateNT4,

} LSAP_NETLOGON_PARAMETER;

VOID
NTAPI
LsaINotifyNetlogonParametersChangeW(
    IN LSAP_NETLOGON_PARAMETER Parameter,
    IN DWORD dwType,
    IN PWSTR lpData,
    IN DWORD cbData
    );

NTSTATUS
NTAPI
LsaIChangeSecretCipherKey(
    IN PVOID NewSysKey
    );

BOOLEAN
LsaINoMoreWin2KDomain();

void
LsaINotifyGCStatusChange(
    IN BOOLEAN PromotingToGC
    );

NTSTATUS
LsaIIsDomainWithinForest(
    IN UNICODE_STRING * TrustedDomainName,
    OUT BOOL * WithinForest,
    OUT OPTIONAL BOOL * ThisDomain,
    OUT OPTIONAL PSID * TrustedDomainSid,
    OUT OPTIONAL ULONG * TrustDirection,
    OUT OPTIONAL ULONG * TrustType,
    OUT OPTIONAL ULONG * TrustAttributes
    );

#ifdef __cplusplus
}
#endif

#endif // _LSAISRV_
=== C:/Users/treeman/Desktop/windows nt source code\Source\Win2K3\NT\public\internal\ds\inc\lsaimp.h ===
/*++

Copyright (c) 1991  Microsoft Corporation

Module Name:

    lsaimp.h

Abstract:

    Local Security Authority Protected Subsystem - Private Includes

Author:

    Scott Birrell       (ScottBi)       April 24, 1991

Environment:

Revision History:

--*/

#include <nt.h>
#include <ntrtl.h>
#include <nturtl.h>
#include <ntlsa.h>
#include <windef.h>
#include <winbase.h>
#include <lsass.h>
#include <lsaicli.h>
#include <wincred.h>
#include <credp.h>
#include <adtgen.h>
=== C:/Users/treeman/Desktop/windows nt source code\Source\Win2K3\NT\public\internal\ds\inc\marta.h ===
//+-------------------------------------------------------------------
//
//  Microsoft Windows
//  Copyright (C) Microsoft Corporation, 1996 - 1996.
//
//  File:       MARTA.H
//
//  Contents:   Private definitions and function prototypes used by the
//              access control APIs to handle the provider independence
//
//  History:    19-Jun-96       MacM        Created
//
//--------------------------------------------------------------------
#ifndef __MARTA_H__
#define __MARTA_H__

#include <accprov.h>

//
// List of entry points for the provider DLL functions
//
#define ACC_PROV_GET_CAPS       "AccProvGetCapabilities"
#define ACC_PROV_OBJ_ACCESS     "AccProvIsObjectAccessible"
#define ACC_PROV_GRANT_ACCESS   "AccProvGrantAccessRights"
#define ACC_PROV_SET_ACCESS     "AccProvSetAccessRights"
#define ACC_PROV_REVOKE_ACCESS  "AccProvRevokeAccessRights"
#define ACC_PROV_REVOKE_AUDIT   "AccProvRevokeAuditRights"
#define ACC_PROV_GET_ALL        "AccProvGetAllRights"
#define ACC_PROV_ACCESS         "AccProvGetTrusteesAccess"
#define ACC_PROV_AUDIT          "AccProvIsAccessAudited"
#define ACC_PROV_OBJ_INFO       "AccProvGetAccessInfoPerObjectType"
#define ACC_PROV_CANCEL         "AccProvCancelOperation"
#define ACC_PROV_GET_RESULTS    "AccProvGetOperationResults"

#define ACC_PROV_HOBJ_ACCESS    "AccProvHandleIsObjectAccessible"
#define ACC_PROV_HGRANT_ACCESS  "AccProvHandleGrantAccessRights"
#define ACC_PROV_HSET_ACCESS    "AccProvHandleSetAccessRights"
#define ACC_PROV_HREVOKE_ACCESS "AccProvHandleRevokeAccessRights"
#define ACC_PROV_HREVOKE_AUDIT  "AccProvHandleRevokeAuditRights"
#define ACC_PROV_HGET_ALL       "AccProvHandleGetAllRights"
#define ACC_PROV_HACCESS        "AccProvHandleGetTrusteesAccess"
#define ACC_PROV_HAUDIT         "AccProvHandleIsAccessAudited"
#define ACC_PROV_HOBJ_INFO      "AccProvHandleGetAccessInfoPerObjectType"


//
// Registry keys that hold the provider information
//
#define ACC_PROV_REG_ROOT                                                   \
                L"System\\CurrentControlSet\\Control\\LSA\\AccessProviders"
#define ACC_PROV_REG_ORDER  L"ProviderOrder"
#define ACC_PROV_REG_UNIQUE L"RequireUniqueAccessibility"
#define ACC_PROV_REG_PATH   L"ProviderPath"


//
// Flags used to control the provider state
//
#define ACC_PROV_PROV_OK        0x00000001
#define ACC_PROV_PROV_FAILED    0x00000000

//
// Indicates that the RequireUniqueAccessibility flag was present
//
#define ACC_PROV_REQ_UNIQUE         0x00000001

//
// Indicates that the providers have been loaded
//
#define ACC_PROV_PROVIDERS_LOADED   0x00000002

//
// This structure is what contains all of the required information about
// each of the providers
//
typedef struct _ACCPROV_PROV_INFO
{
    PWSTR               pwszProviderName;   // "Friendly" name of the provider
    PWSTR               pwszProviderPath;   // DLL path name.  Null after
                                            // module loaded
    HMODULE             hDll;               // Module handle of the DLL
                                            // after being loaded
    ULONG               fProviderCaps;      // Provider capabilities
    ULONG               fProviderState;     // Current state of the provider

    //
    // The following is the function table used to call the provider
    // functions
    //

    //
    // General functions
    //
    pfAccProvObjAccess          pfObjAccess;    // AccProvIsObjectAccessible
    pfAccProvHandleObjAccess    pfhObjAccess;   // AccProvHandleIsObjectAccessible
    pfAccProvCancelOp           pfCancel;       // AccProvCancelOperation
    pfAccProvGetResults         pfResults;      // AccProvGetOperationResults

    //
    // Required path based functions
    //
    pfAccProvAddRights      pfGrantAccess;  // AccProvGrantAccessRights
    pfAccProvSetRights      pfSetAccess;    // AccProvSetAccessRights
    pfAccProvRevoke         pfRevokeAccess; // AccProvRevokeAccessRights
    pfAccProvRevoke         pfRevokeAudit;  // AccProvRevokeAuditRights
    pfAccProvGetRights      pfGetRights;    // AccProvGetAllRights
    pfAccProvTrusteeAccess  pfTrusteeAccess;// AccProvGetTrusteesAccess
    pfAccProvAccessAudit    pfAudit;        // AccProvIsAccessAudited
    pfAccProvGetObjTypeInfo pfObjInfo;      // AccProvGetAccessInfoPerObjectType

    //
    // Optional, handle based functions
    //
    pfAccProvHandleAddRights      pfhGrantAccess;  // AccProvHandleGrantAccessRights
    pfAccProvHandleSetRights      pfhSetAccess;    // AccProvHandleSetAccessRights
    pfAccProvHandleRevoke         pfhRevokeAccess; // AccProvHandleRevokeAccessRights
    pfAccProvHandleRevoke         pfhRevokeAudit;  // AccProvHandleRevokeAuditRights
    pfAccProvHandleGetRights      pfhGetRights;    // AccProvHandleGetAllRights
    pfAccProvHandleTrusteeAccess  pfhTrusteeAccess;// AccProvHandleGetTrusteesAccess
    pfAccProvHandleAccessAudit    pfhAudit;        // AccProvHandleIsAccessAudited
    pfAccProvHandleGetObjTypeInfo pfhObjInfo;      // AccProvHandleGetAccessInfoPerObjectType
} ACCPROV_PROV_INFO, *PACCPROV_PROV_INFO;


//
// This structure contains all of the information about the availible security
// providers
//
typedef struct _ACCPROV_PROVIDERS
{
    CRITICAL_SECTION    ProviderLoadLock;   // Lock the provider list during load time
    ULONG               fOptions;           // Various provider options
    ULONG               cProviders;         // Number of providers;
    PACCPROV_PROV_INFO  pProvList;          // Actual list of providers
} ACCPROV_PROVIDERS, *PACCPROV_PROVIDERS;


extern ACCPROV_PROVIDERS gAccProviders;

//
// Allocates the provider list
//
DWORD
AccProvpAllocateProviderList(IN OUT PACCPROV_PROVIDERS  pProviders);

//
// Frees a provider list
//
VOID
AccProvpFreeProviderList(IN  PACCPROV_PROVIDERS  pProviders);

//
// Gets the capabilities of the given provider
//
DWORD
AccProvpGetProviderCapabilities(IN  PACCPROV_PROV_INFO  pProvInfo);

//
// Loads a provider definition from the registry
//
DWORD
AccProvpLoadProviderDef(IN  HKEY                hkReg,
                        IN  PWSTR               pwszNextProv,
                        OUT PACCPROV_PROV_INFO  pProvInfo);

//
// Initializes the list of providers
//
DWORD
AccProvpInitProviders(IN OUT PACCPROV_PROVIDERS  pProviders);

//
// Loads the NTMARTA.DLL functions
//
DWORD
AccProvpLoadMartaFunctions();

BOOL
MartaInitialize();

BOOL
MartaDllInitialize(IN   HINSTANCE   hMod,
                   IN   DWORD       dwReason,
                   IN   PVOID       pvReserved);

//
// Unloads any loaded DLLs
//
VOID
AccProvUnload();

//
// Determines the provider for an object
//
DWORD
AccProvpProbeProviderForObject(IN   PWSTR               pwszObject,
                               IN   HANDLE              hObject,
                               IN   SE_OBJECT_TYPE      ObjectType,
                               IN   PACCPROV_PROVIDERS  pProviders,
                               OUT  PACCPROV_PROV_INFO *ppProvider);

//
// Determines which provider should handle a request...
//
DWORD
AccProvpGetProviderForPath(IN  PCWSTR              pcwszObject,
                           IN  SE_OBJECT_TYPE      ObjectType,
                           IN  PCWSTR              pcwszProvider,
                           IN  PACCPROV_PROVIDERS  pProviders,
                           OUT PACCPROV_PROV_INFO *ppProvider);

DWORD
AccProvpGetProviderForHandle(IN  HANDLE              hObject,
                             IN  SE_OBJECT_TYPE      ObjectType,
                             IN  PCWSTR              pcwszProvider,
                             IN  PACCPROV_PROVIDERS  pProviders,
                             OUT PACCPROV_PROV_INFO *ppProvider);


//
// Macro to load a function pointer from a DLL
//
#define LOAD_ENTRYPT(ptr, typ, dll, str)            \
ptr = (typ)GetProcAddress(dll, str);                \
if(ptr == NULL)                                     \
{                                                   \
    goto Error;                                     \
}



#endif // ifndef __MARTA_H__
=== C:/Users/treeman/Desktop/windows nt source code\Source\Win2K3\NT\public\internal\ds\inc\lsarpc.h ===
/* this ALWAYS GENERATED file contains the definitions for the interfaces */


 /* File created by MIDL compiler version 6.00.0361 */
/* Compiler settings for lsarpc.idl, lsasrv.acf:
    Oicf, W1, Zp8, env=Win32 (32b run)
    protocol : dce , ms_ext, c_ext, oldnames, robust
    error checks: allocation ref bounds_check enum stub_data , no_format_optimization
    VC __declspec() decoration level: 
         __declspec(uuid()), __declspec(selectany), __declspec(novtable)
         DECLSPEC_UUID(), MIDL_INTERFACE()
*/
//@@MIDL_FILE_HEADING(  )

#pragma warning( disable: 4049 )  /* more than 64k source lines */


/* verify that the <rpcndr.h> version is high enough to compile this file*/
#ifndef __REQUIRED_RPCNDR_H_VERSION__
#define __REQUIRED_RPCNDR_H_VERSION__ 475
#endif

#include "rpc.h"
#include "rpcndr.h"

#ifndef __RPCNDR_H_VERSION__
#error this stub requires an updated version of <rpcndr.h>
#endif // __RPCNDR_H_VERSION__


#ifndef __lsarpc_h__
#define __lsarpc_h__

#if defined(_MSC_VER) && (_MSC_VER >= 1020)
#pragma once
#endif

/* Forward Declarations */ 

/* header files for imported files */
#include "lsaimp.h"

#ifdef __cplusplus
extern "C"{
#endif 

void * __RPC_USER MIDL_user_allocate(size_t);
void __RPC_USER MIDL_user_free( void * ); 

#ifndef __lsarpc_INTERFACE_DEFINED__
#define __lsarpc_INTERFACE_DEFINED__

/* interface lsarpc */
/* [implicit_handle][strict_context_handle][unique][ms_union][version][uuid] */ 

#define LSA_LOOKUP_REVISION_1 0x1
#define LSA_LOOKUP_REVISION_2 0x2
#define LSA_LOOKUP_REVISION_LATEST  LSA_LOOKUP_REVISION_2
#define LSA_CLIENT_PRE_NT5 0x1
#define LSA_CLIENT_NT5     0x2
#define LSA_CLIENT_LATEST  0x2
typedef /* [handle] */ LPWSTR PLSAPR_SERVER_NAME;

typedef /* [handle] */ LPWSTR *PPLSAPR_SERVER_NAME;

typedef /* [context_handle] */ PVOID LSAPR_HANDLE;

typedef LSAPR_HANDLE *PLSAPR_HANDLE;

#pragma warning(disable:4200)
typedef struct _LSAPR_SID
    {
    UCHAR Revision;
    UCHAR SubAuthorityCount;
    SID_IDENTIFIER_AUTHORITY IdentifierAuthority;
    /* [size_is] */ ULONG SubAuthority[ 1 ];
    } 	LSAPR_SID;

typedef struct _LSAPR_SID *PLSAPR_SID;

typedef struct _LSAPR_SID **PPLSAPR_SID;

#pragma warning(default:4200)
typedef struct _LSAPR_SID_INFORMATION
    {
    PLSAPR_SID Sid;
    } 	LSAPR_SID_INFORMATION;

typedef struct _LSAPR_SID_INFORMATION *PLSAPR_SID_INFORMATION;

#define LSA_MAXIMUM_LOOKUP_SIDS_COUNT 0x5000
typedef struct _LSAPR_SID_ENUM_BUFFER
    {
    /* [range] */ ULONG Entries;
    /* [size_is] */ PLSAPR_SID_INFORMATION SidInfo;
    } 	LSAPR_SID_ENUM_BUFFER;

typedef struct _LSAPR_SID_ENUM_BUFFER *PLSAPR_SID_ENUM_BUFFER;

typedef struct _LSAPR_ACCOUNT_INFORMATION
    {
    PLSAPR_SID Sid;
    } 	LSAPR_ACCOUNT_INFORMATION;

typedef struct _LSAPR_ACCOUNT_INFORMATION *PLSAPR_ACCOUNT_INFORMATION;

typedef struct _LSAPR_ACCOUNT_ENUM_BUFFER
    {
    ULONG EntriesRead;
    /* [size_is] */ PLSAPR_ACCOUNT_INFORMATION Information;
    } 	LSAPR_ACCOUNT_ENUM_BUFFER;

typedef struct _LSAPR_ACCOUNT_ENUM_BUFFER *PLSAPR_ACCOUNT_ENUM_BUFFER;

typedef struct _LSAPR_UNICODE_STRING
    {
    USHORT Length;
    USHORT MaximumLength;
    /* [length_is][size_is] */ PWSTR Buffer;
    } 	LSAPR_UNICODE_STRING;

typedef struct _LSAPR_UNICODE_STRING *PLSAPR_UNICODE_STRING;

typedef struct _LSAPR_STRING
    {
    USHORT Length;
    USHORT MaximumLength;
    /* [size_is] */ PCHAR Buffer;
    } 	LSAPR_STRING;

typedef struct _LSAPR_STRING *PLSAPR_STRING;

typedef struct _LSAPR_STRING LSAPR_ANSI_STRING;

typedef struct _LSAPR_STRING *PLSAPR_ANSI_STRING;

#pragma warning(disable:4200)
typedef struct _LSAPR_ACL
    {
    UCHAR AclRevision;
    UCHAR Sbz1;
    USHORT AclSize;
    /* [size_is] */ UCHAR Dummy1[ 1 ];
    } 	LSAPR_ACL;

typedef struct _LSAPR_ACL *PLSAPR_ACL;

#pragma warning(default:4200)
typedef struct _LSAPR_SECURITY_DESCRIPTOR
    {
    UCHAR Revision;
    UCHAR Sbz1;
    SECURITY_DESCRIPTOR_CONTROL Control;
    PLSAPR_SID Owner;
    PLSAPR_SID Group;
    PLSAPR_ACL Sacl;
    PLSAPR_ACL Dacl;
    } 	LSAPR_SECURITY_DESCRIPTOR;

typedef struct _LSAPR_SECURITY_DESCRIPTOR *PLSAPR_SECURITY_DESCRIPTOR;

typedef struct _LSAPR_SR_SECURITY_DESCRIPTOR
    {
    /* [range] */ ULONG Length;
    /* [size_is] */ PUCHAR SecurityDescriptor;
    } 	LSAPR_SR_SECURITY_DESCRIPTOR;

typedef struct _LSAPR_SR_SECURITY_DESCRIPTOR *PLSAPR_SR_SECURITY_DESCRIPTOR;

typedef struct _LSAPR_LUID_AND_ATTRIBUTES
    {
    OLD_LARGE_INTEGER Luid;
    ULONG Attributes;
    } 	LSAPR_LUID_AND_ATTRIBUTES;

typedef struct _LSAPR_LUID_AND_ATTRIBUTES *PLSAPR_LUID_AND_ATTRIBUTES;

#pragma warning(disable:4200)
typedef struct _LSAPR_PRIVILEGE_SET
    {
    /* [range] */ ULONG PrivilegeCount;
    ULONG Control;
    /* [size_is] */ LSAPR_LUID_AND_ATTRIBUTES Privilege[ 1 ];
    } 	LSAPR_PRIVILEGE_SET;

typedef struct _LSAPR_PRIVILEGE_SET *PLSAPR_PRIVILEGE_SET;

typedef struct _LSAPR_PRIVILEGE_SET **PPLSAPR_PRIVILEGE_SET;

#pragma warning(default:4200)
typedef struct _LSAPR_POLICY_PRIVILEGE_DEF
    {
    LSAPR_UNICODE_STRING Name;
    LUID LocalValue;
    } 	LSAPR_POLICY_PRIVILEGE_DEF;

typedef struct _LSAPR_POLICY_PRIVILEGE_DEF *PLSAPR_POLICY_PRIVILEGE_DEF;

typedef struct _LSAPR_PRIVILEGE_ENUM_BUFFER
    {
    ULONG Entries;
    /* [size_is] */ PLSAPR_POLICY_PRIVILEGE_DEF Privileges;
    } 	LSAPR_PRIVILEGE_ENUM_BUFFER;

typedef struct _LSAPR_PRIVILEGE_ENUM_BUFFER *PLSAPR_PRIVILEGE_ENUM_BUFFER;

typedef struct _LSAPR_OBJECT_ATTRIBUTES
    {
    ULONG Length;
    PUCHAR RootDirectory;
    PSTRING ObjectName;
    ULONG Attributes;
    PLSAPR_SECURITY_DESCRIPTOR SecurityDescriptor;
    PSECURITY_QUALITY_OF_SERVICE SecurityQualityOfService;
    } 	LSAPR_OBJECT_ATTRIBUTES;

typedef struct _LSAPR_OBJECT_ATTRIBUTES *PLSAPR_OBJECT_ATTRIBUTES;

typedef struct _LSAPR_CR_CLEAR_VALUE
    {
    ULONG Length;
    ULONG MaximumLength;
    /* [length_is][size_is] */ PUCHAR Buffer;
    } 	LSAPR_CR_CLEAR_VALUE;

typedef struct _LSAPR_CR_CLEAR_VALUE *PLSAPR_CR_CLEAR_VALUE;

typedef struct _LSAPR_CR_CIPHER_VALUE
    {
    /* [range] */ ULONG Length;
    /* [range] */ ULONG MaximumLength;
    /* [length_is][size_is] */ PUCHAR Buffer;
    } 	LSAPR_CR_CIPHER_VALUE;

typedef /* [allocate] */ struct _LSAPR_CR_CIPHER_VALUE *PLSAPR_CR_CIPHER_VALUE;

typedef struct _LSAPR_TRUST_INFORMATION
    {
    LSAPR_UNICODE_STRING Name;
    PLSAPR_SID Sid;
    } 	LSAPR_TRUST_INFORMATION;

typedef struct _LSAPR_TRUST_INFORMATION *PLSAPR_TRUST_INFORMATION;

typedef struct _LSAPR_TRUST_INFORMATION_EX
    {
    LSAPR_UNICODE_STRING DomainName;
    LSAPR_UNICODE_STRING FlatName;
    PLSAPR_SID Sid;
    BOOLEAN DomainNamesDiffer;
    ULONG TrustAttributes;
    } 	LSAPR_TRUST_INFORMATION_EX;

typedef struct _LSAPR_TRUST_INFORMATION_EX *PLSAPR_TRUST_INFORMATION_EX;

typedef struct _LSAPR_TRUSTED_ENUM_BUFFER
    {
    ULONG EntriesRead;
    /* [size_is] */ PLSAPR_TRUST_INFORMATION Information;
    } 	LSAPR_TRUSTED_ENUM_BUFFER;

typedef struct _LSAPR_TRUSTED_ENUM_BUFFER *PLSAPR_TRUSTED_ENUM_BUFFER;

typedef struct _LSAPR_REFERENCED_DOMAIN_LIST
    {
    ULONG Entries;
    /* [size_is] */ PLSAPR_TRUST_INFORMATION Domains;
    ULONG MaxEntries;
    } 	LSAPR_REFERENCED_DOMAIN_LIST;

typedef struct _LSAPR_REFERENCED_DOMAIN_LIST *PLSAPR_REFERENCED_DOMAIN_LIST;

#define LSA_LOOKUP_SID_FOUND_BY_HISTORY 0x00000001
#define LSA_LOOKUP_SID_XFOREST_REF      0x00000002
typedef struct _LSAPR_TRANSLATED_SID_EX
    {
    SID_NAME_USE Use;
    ULONG RelativeId;
    LONG DomainIndex;
    ULONG Flags;
    } 	LSAPR_TRANSLATED_SID_EX;

typedef struct _LSAPR_TRANSLATED_SID_EX *PLSAPR_TRANSLATED_SID_EX;

typedef struct _LSAPR_TRANSLATED_SID_EX2
    {
    SID_NAME_USE Use;
    PLSAPR_SID Sid;
    LONG DomainIndex;
    ULONG Flags;
    } 	LSAPR_TRANSLATED_SID_EX2;

typedef struct _LSAPR_TRANSLATED_SID_EX2 *PLSAPR_TRANSLATED_SID_EX2;

#define LSA_MAXIMUM_LOOKUP_NAMES_COUNT 1000
typedef struct _LSAPR_TRANSLATED_SIDS
    {
    /* [range] */ ULONG Entries;
    /* [size_is] */ PLSA_TRANSLATED_SID Sids;
    } 	LSAPR_TRANSLATED_SIDS;

typedef struct _LSAPR_TRANSLATED_SIDS *PLSAPR_TRANSLATED_SIDS;

typedef struct _LSAPR_TRANSLATED_SIDS_EX
    {
    /* [range] */ ULONG Entries;
    /* [size_is] */ PLSAPR_TRANSLATED_SID_EX Sids;
    } 	LSAPR_TRANSLATED_SIDS_EX;

typedef struct _LSAPR_TRANSLATED_SIDS_EX *PLSAPR_TRANSLATED_SIDS_EX;

typedef struct _LSAPR_TRANSLATED_SIDS_EX2
    {
    /* [range] */ ULONG Entries;
    /* [size_is] */ PLSAPR_TRANSLATED_SID_EX2 Sids;
    } 	LSAPR_TRANSLATED_SIDS_EX2;

typedef struct _LSAPR_TRANSLATED_SIDS_EX2 *PLSAPR_TRANSLATED_SIDS_EX2;

typedef struct _LSAPR_TRANSLATED_NAME
    {
    SID_NAME_USE Use;
    LSAPR_UNICODE_STRING Name;
    LONG DomainIndex;
    } 	LSAPR_TRANSLATED_NAME;

typedef struct _LSAPR_TRANSLATED_NAME *PLSAPR_TRANSLATED_NAME;

#define LSA_LOOKUP_NAME_NOT_SAM_ACCOUNT_NAME  0x00000001
#define LSA_LOOKUP_NAME_XFOREST_REF  0x00000002
typedef struct _LSAPR_TRANSLATED_NAME_EX
    {
    SID_NAME_USE Use;
    LSAPR_UNICODE_STRING Name;
    LONG DomainIndex;
    ULONG Flags;
    } 	LSAPR_TRANSLATED_NAME_EX;

typedef struct _LSAPR_TRANSLATED_NAME_EX *PLSAPR_TRANSLATED_NAME_EX;

typedef struct _LSAPR_TRANSLATED_NAMES
    {
    /* [range] */ ULONG Entries;
    /* [size_is] */ PLSAPR_TRANSLATED_NAME Names;
    } 	LSAPR_TRANSLATED_NAMES;

typedef struct _LSAPR_TRANSLATED_NAMES *PLSAPR_TRANSLATED_NAMES;

typedef struct _LSAPR_TRANSLATED_NAMES_EX
    {
    /* [range] */ ULONG Entries;
    /* [size_is] */ PLSAPR_TRANSLATED_NAME_EX Names;
    } 	LSAPR_TRANSLATED_NAMES_EX;

typedef struct _LSAPR_TRANSLATED_NAMES_EX *PLSAPR_TRANSLATED_NAMES_EX;

typedef struct _LSAPR_POLICY_ACCOUNT_DOM_INFO
    {
    LSAPR_UNICODE_STRING DomainName;
    PLSAPR_SID DomainSid;
    } 	LSAPR_POLICY_ACCOUNT_DOM_INFO;

typedef struct _LSAPR_POLICY_ACCOUNT_DOM_INFO *PLSAPR_POLICY_ACCOUNT_DOM_INFO;

typedef struct _LSAPR_POLICY_PRIMARY_DOM_INFO
    {
    LSAPR_UNICODE_STRING Name;
    PLSAPR_SID Sid;
    } 	LSAPR_POLICY_PRIMARY_DOM_INFO;

typedef struct _LSAPR_POLICY_PRIMARY_DOM_INFO *PLSAPR_POLICY_PRIMARY_DOM_INFO;

typedef struct _LSAPR_POLICY_DNS_DOMAIN_INFO
    {
    LSAPR_UNICODE_STRING Name;
    LSAPR_UNICODE_STRING DnsDomainName;
    LSAPR_UNICODE_STRING DnsForestName;
    GUID DomainGuid;
    PLSAPR_SID Sid;
    } 	LSAPR_POLICY_DNS_DOMAIN_INFO;

typedef struct _LSAPR_POLICY_DNS_DOMAIN_INFO *PLSAPR_POLICY_DNS_DOMAIN_INFO;

typedef struct _LSAPR_POLICY_PD_ACCOUNT_INFO
    {
    LSAPR_UNICODE_STRING Name;
    } 	LSAPR_POLICY_PD_ACCOUNT_INFO;

typedef struct _LSAPR_POLICY_PD_ACCOUNT_INFO *PLSAPR_POLICY_PD_ACCOUNT_INFO;

typedef struct _LSAPR_POLICY_REPLICA_SRCE_INFO
    {
    LSAPR_UNICODE_STRING ReplicaSource;
    LSAPR_UNICODE_STRING ReplicaAccountName;
    } 	LSAPR_POLICY_REPLICA_SRCE_INFO;

typedef struct _LSAPR_POLICY_REPLICA_SRCE_INFO *PLSAPR_POLICY_REPLICA_SRCE_INFO;

typedef struct _LSAPR_POLICY_AUDIT_EVENTS_INFO
    {
    BOOLEAN AuditingMode;
    /* [size_is] */ PPOLICY_AUDIT_EVENT_OPTIONS EventAuditingOptions;
    /* [range] */ ULONG MaximumAuditEventCount;
    } 	LSAPR_POLICY_AUDIT_EVENTS_INFO;

typedef struct _LSAPR_POLICY_AUDIT_EVENTS_INFO *PLSAPR_POLICY_AUDIT_EVENTS_INFO;

typedef /* [switch_type] */ union _LSAPR_POLICY_INFORMATION
    {
    /* [case()] */ POLICY_AUDIT_LOG_INFO PolicyAuditLogInfo;
    /* [case()] */ LSAPR_POLICY_AUDIT_EVENTS_INFO PolicyAuditEventsInfo;
    /* [case()] */ LSAPR_POLICY_PRIMARY_DOM_INFO PolicyPrimaryDomainInfo;
    /* [case()] */ LSAPR_POLICY_ACCOUNT_DOM_INFO PolicyAccountDomainInfo;
    /* [case()] */ LSAPR_POLICY_PD_ACCOUNT_INFO PolicyPdAccountInfo;
    /* [case()] */ POLICY_LSA_SERVER_ROLE_INFO PolicyServerRoleInfo;
    /* [case()] */ LSAPR_POLICY_REPLICA_SRCE_INFO PolicyReplicaSourceInfo;
    /* [case()] */ POLICY_DEFAULT_QUOTA_INFO PolicyDefaultQuotaInfo;
    /* [case()] */ POLICY_MODIFICATION_INFO PolicyModificationInfo;
    /* [case()] */ POLICY_AUDIT_FULL_SET_INFO PolicyAuditFullSetInfo;
    /* [case()] */ POLICY_AUDIT_FULL_QUERY_INFO PolicyAuditFullQueryInfo;
    /* [case()] */ LSAPR_POLICY_DNS_DOMAIN_INFO PolicyDnsDomainInfo;
    /* [case()] */ LSAPR_POLICY_DNS_DOMAIN_INFO PolicyDnsDomainInfoInt;
    } 	LSAPR_POLICY_INFORMATION;

typedef LSAPR_POLICY_INFORMATION *PLSAPR_POLICY_INFORMATION;

typedef struct _LSAPR_POLICY_DOMAIN_EFS_INFO
    {
    ULONG InfoLength;
    /* [size_is] */ PUCHAR EfsBlob;
    } 	LSAPR_POLICY_DOMAIN_EFS_INFO;

typedef struct _LSAPR_POLICY_DOMAIN_EFS_INFO *PLSAPR_POLICY_DOMAIN_EFS_INFO;

typedef /* [switch_type] */ union _LSAPR_POLICY_DOMAIN_INFORMATION
    {
    /* [case()] */ LSAPR_POLICY_DOMAIN_EFS_INFO PolicyDomainEfsInfo;
    /* [case()] */ POLICY_DOMAIN_KERBEROS_TICKET_INFO PolicyDomainKerbTicketInfo;
    } 	LSAPR_POLICY_DOMAIN_INFORMATION;

typedef LSAPR_POLICY_DOMAIN_INFORMATION *PLSAPR_POLICY_DOMAIN_INFORMATION;

typedef struct _LSAPR_TRUSTED_DOMAIN_NAME_INFO
    {
    LSAPR_UNICODE_STRING Name;
    } 	LSAPR_TRUSTED_DOMAIN_NAME_INFO;

typedef struct _LSAPR_TRUSTED_DOMAIN_NAME_INFO *PLSAPR_TRUSTED_DOMAIN_NAME_INFO;

typedef struct _LSAPR_TRUSTED_CONTROLLERS_INFO
    {
    /* [range] */ ULONG Entries;
    /* [size_is] */ PLSAPR_UNICODE_STRING Names;
    } 	LSAPR_TRUSTED_CONTROLLERS_INFO;

typedef struct _LSAPR_TRUSTED_CONTROLLERS_INFO *PLSAPR_TRUSTED_CONTROLLERS_INFO;

typedef struct _LSAPR_TRUSTED_PASSWORD_INFO
    {
    PLSAPR_CR_CIPHER_VALUE Password;
    PLSAPR_CR_CIPHER_VALUE OldPassword;
    } 	LSAPR_TRUSTED_PASSWORD_INFO;

typedef struct _LSAPR_TRUSTED_PASSWORD_INFO *PLSAPR_TRUSTED_PASSWORD_INFO;

typedef struct _LSAPR_TRUSTED_DOMAIN_INFORMATION_EX
    {
    LSAPR_UNICODE_STRING Name;
    LSAPR_UNICODE_STRING FlatName;
    PLSAPR_SID Sid;
    ULONG TrustDirection;
    ULONG TrustType;
    ULONG TrustAttributes;
    } 	LSAPR_TRUSTED_DOMAIN_INFORMATION_EX;

typedef struct _LSAPR_TRUSTED_DOMAIN_INFORMATION_EX *PLSAPR_TRUSTED_DOMAIN_INFORMATION_EX;

typedef struct _LSAPR_AUTH_INFORMATION
    {
    LARGE_INTEGER LastUpdateTime;
    ULONG AuthType;
    /* [range] */ ULONG AuthInfoLength;
    /* [size_is] */ PUCHAR AuthInfo;
    } 	LSAPR_AUTH_INFORMATION;

typedef struct _LSAPR_AUTH_INFORMATION *PLSAPR_AUTH_INFORMATION;

typedef struct _LSAPR_TRUSTED_DOMAIN_AUTH_INFORMATION
    {
    ULONG IncomingAuthInfos;
    PLSAPR_AUTH_INFORMATION IncomingAuthenticationInformation;
    PLSAPR_AUTH_INFORMATION IncomingPreviousAuthenticationInformation;
    ULONG OutgoingAuthInfos;
    PLSAPR_AUTH_INFORMATION OutgoingAuthenticationInformation;
    PLSAPR_AUTH_INFORMATION OutgoingPreviousAuthenticationInformation;
    } 	LSAPR_TRUSTED_DOMAIN_AUTH_INFORMATION;

typedef struct _LSAPR_TRUSTED_DOMAIN_AUTH_INFORMATION *PLSAPR_TRUSTED_DOMAIN_AUTH_INFORMATION;

typedef struct _LSAPR_TRUSTED_DOMAIN_FULL_INFORMATION
    {
    LSAPR_TRUSTED_DOMAIN_INFORMATION_EX Information;
    TRUSTED_POSIX_OFFSET_INFO PosixOffset;
    LSAPR_TRUSTED_DOMAIN_AUTH_INFORMATION AuthInformation;
    } 	LSAPR_TRUSTED_DOMAIN_FULL_INFORMATION;

typedef struct _LSAPR_TRUSTED_DOMAIN_FULL_INFORMATION *PLSAPR_TRUSTED_DOMAIN_FULL_INFORMATION;

typedef LSAPR_TRUST_INFORMATION LSAPR_TRUSTED_DOMAIN_INFORMATION_BASIC;

typedef PLSAPR_TRUST_INFORMATION PLSAPR_TRUSTED_DOMAIN_INFORMATION_BASIC;

typedef struct _LSAPR_TRUSTED_DOMAIN_AUTH_BLOB
    {
    /* [range] */ ULONG AuthSize;
    /* [size_is] */ PUCHAR AuthBlob;
    } 	LSAPR_TRUSTED_DOMAIN_AUTH_BLOB;

typedef struct _LSAPR_TRUSTED_DOMAIN_AUTH_BLOB *PLSAPR_TRUSTED_DOMAIN_AUTH_BLOB;

typedef struct _LSAPR_TRUSTED_DOMAIN_AUTH_INFORMATION_INTERNAL
    {
    LSAPR_TRUSTED_DOMAIN_AUTH_BLOB AuthBlob;
    } 	LSAPR_TRUSTED_DOMAIN_AUTH_INFORMATION_INTERNAL;

typedef struct _LSAPR_TRUSTED_DOMAIN_AUTH_INFORMATION_INTERNAL *PLSAPR_TRUSTED_DOMAIN_AUTH_INFORMATION_INTERNAL;

typedef struct _LSAPR_TRUSTED_DOMAIN_FULL_INFORMATION_INTERNAL
    {
    LSAPR_TRUSTED_DOMAIN_INFORMATION_EX Information;
    TRUSTED_POSIX_OFFSET_INFO PosixOffset;
    LSAPR_TRUSTED_DOMAIN_AUTH_INFORMATION_INTERNAL AuthInformation;
    } 	LSAPR_TRUSTED_DOMAIN_FULL_INFORMATION_INTERNAL;

typedef struct _LSAPR_TRUSTED_DOMAIN_FULL_INFORMATION_INTERNAL *PLSAPR_TRUSTED_DOMAIN_FULL_INFORMATION_INTERNAL;

typedef struct _LSAPR_TRUSTED_DOMAIN_INFORMATION_EX2
    {
    LSAPR_UNICODE_STRING Name;
    LSAPR_UNICODE_STRING FlatName;
    PLSAPR_SID Sid;
    ULONG TrustDirection;
    ULONG TrustType;
    ULONG TrustAttributes;
    ULONG ForestTrustLength;
    /* [size_is] */ PUCHAR ForestTrustInfo;
    } 	LSAPR_TRUSTED_DOMAIN_INFORMATION_EX2;

typedef struct _LSAPR_TRUSTED_DOMAIN_INFORMATION_EX2 *PLSAPR_TRUSTED_DOMAIN_INFORMATION_EX2;

typedef struct _LSAPR_TRUSTED_DOMAIN_FULL_INFORMATION2
    {
    LSAPR_TRUSTED_DOMAIN_INFORMATION_EX2 Information;
    TRUSTED_POSIX_OFFSET_INFO PosixOffset;
    LSAPR_TRUSTED_DOMAIN_AUTH_INFORMATION AuthInformation;
    } 	LSAPR_TRUSTED_DOMAIN_FULL_INFORMATION2;

typedef struct _LSAPR_TRUSTED_DOMAIN_FULL_INFORMATION2 *PLSAPR_TRUSTED_DOMAIN_FULL_INFORMATION2;

typedef /* [switch_type] */ union _LSAPR_TRUSTED_DOMAIN_INFO
    {
    /* [case()] */ LSAPR_TRUSTED_DOMAIN_NAME_INFO TrustedDomainNameInfo;
    /* [case()] */ LSAPR_TRUSTED_CONTROLLERS_INFO TrustedControllersInfo;
    /* [case()] */ TRUSTED_POSIX_OFFSET_INFO TrustedPosixOffsetInfo;
    /* [case()] */ LSAPR_TRUSTED_PASSWORD_INFO TrustedPasswordInfo;
    /* [case()] */ LSAPR_TRUSTED_DOMAIN_INFORMATION_BASIC TrustedDomainInfoBasic;
    /* [case()] */ LSAPR_TRUSTED_DOMAIN_INFORMATION_EX TrustedDomainInfoEx;
    /* [case()] */ LSAPR_TRUSTED_DOMAIN_AUTH_INFORMATION TrustedAuthInfo;
    /* [case()] */ LSAPR_TRUSTED_DOMAIN_FULL_INFORMATION TrustedFullInfo;
    /* [case()] */ LSAPR_TRUSTED_DOMAIN_AUTH_INFORMATION_INTERNAL TrustedAuthInfoInternal;
    /* [case()] */ LSAPR_TRUSTED_DOMAIN_FULL_INFORMATION_INTERNAL TrustedFullInfoInternal;
    /* [case()] */ LSAPR_TRUSTED_DOMAIN_INFORMATION_EX2 TrustedDomainInfoEx2;
    /* [case()] */ LSAPR_TRUSTED_DOMAIN_FULL_INFORMATION2 TrustedFullInfo2;
    } 	LSAPR_TRUSTED_DOMAIN_INFO;

typedef LSAPR_TRUSTED_DOMAIN_INFO *PLSAPR_TRUSTED_DOMAIN_INFO;

typedef PLSAPR_UNICODE_STRING PLSAPR_UNICODE_STRING_ARRAY;

typedef struct _LSAPR_USER_RIGHT_SET
    {
    /* [range] */ ULONG Entries;
    /* [size_is] */ PLSAPR_UNICODE_STRING_ARRAY UserRights;
    } 	LSAPR_USER_RIGHT_SET;

typedef struct _LSAPR_USER_RIGHT_SET *PLSAPR_USER_RIGHT_SET;

typedef struct _LSAPR_TRUSTED_ENUM_BUFFER_EX
    {
    ULONG EntriesRead;
    /* [size_is] */ PLSAPR_TRUSTED_DOMAIN_INFORMATION_EX EnumerationBuffer;
    } 	LSAPR_TRUSTED_ENUM_BUFFER_EX;

typedef struct _LSAPR_TRUSTED_ENUM_BUFFER_EX *PLSAPR_TRUSTED_ENUM_BUFFER_EX;

typedef struct _LSAPR_TEST_INTERNAL_PARAMETER_BLOB
    {
    /* [range] */ ULONG Size;
    /* [size_is] */ PUCHAR Argument;
    } 	LSAPR_TEST_INTERNAL_PARAMETER_BLOB;

typedef struct _LSAPR_TEST_INTERNAL_PARAMETER_BLOB *PLSAPR_TEST_INTERNAL_PARAMETER_BLOB;

typedef struct _LSAPR_TEST_INTERNAL_ARG_LIST
    {
    /* [range] */ ULONG Items;
    /* [size_is] */ PLSAPR_TEST_INTERNAL_PARAMETER_BLOB Arg;
    } 	LSAPR_TEST_INTERNAL_ARG_LIST;

typedef struct _LSAPR_TEST_INTERNAL_ARG_LIST *PLSAPR_TEST_INTERNAL_ARG_LIST;

typedef 
enum _LSAPR_TEST_INTERNAL_ROUTINES
    {	LsaTest_IEnumerateSecrets	= 0,
	LsaTest_IQueryDomainOrgInfo	= LsaTest_IEnumerateSecrets + 1,
	LsaTest_ISetTrustedDomainAuthBlobs	= LsaTest_IQueryDomainOrgInfo + 1,
	LsaTest_IUpgradeRegistryToDs	= LsaTest_ISetTrustedDomainAuthBlobs + 1,
	LsaTest_ISamSetDomainObjectProperties	= LsaTest_IUpgradeRegistryToDs + 1,
	LsaTest_ISamSetDomainBuiltinGroupMembership	= LsaTest_ISamSetDomainObjectProperties + 1,
	LsaTest_ISamSetInterdomainTrustPassword	= LsaTest_ISamSetDomainBuiltinGroupMembership + 1,
	LsaTest_IRegisterPolicyChangeNotificationCallback	= LsaTest_ISamSetInterdomainTrustPassword + 1,
	LsaTest_IUnregisterPolicyChangeNotificationCallback	= LsaTest_IRegisterPolicyChangeNotificationCallback + 1,
	LsaTest_IUnregisterAllPolicyChangeNotificationCallback	= LsaTest_IUnregisterPolicyChangeNotificationCallback + 1,
	LsaTest_IStartTransaction	= LsaTest_IUnregisterAllPolicyChangeNotificationCallback + 1,
	LsaTest_IApplyTransaction	= LsaTest_IStartTransaction + 1,
	LsaTest_ITrustDomFixup	= LsaTest_IApplyTransaction + 1,
	LsaTest_ISetServerRoleForBoot	= LsaTest_ITrustDomFixup + 1,
	LsaTest_IQueryForestTrustInfo	= LsaTest_ISetServerRoleForBoot + 1,
	LsaTest_IBreak	= LsaTest_IQueryForestTrustInfo + 1,
	LsaTest_IQueryTrustedDomainAuthBlobs	= LsaTest_IBreak + 1,
	LsaTest_IQueryNt4Owf	= LsaTest_IQueryTrustedDomainAuthBlobs + 1
    } 	LSAPR_TEST_INTERNAL_ROUTINES;

/* [notify] */ NTSTATUS LsarClose( 
    /* [out][in] */ LSAPR_HANDLE *ObjectHandle);

/* [notify] */ NTSTATUS LsarDelete( 
    /* [in] */ LSAPR_HANDLE ObjectHandle);

/* [notify] */ NTSTATUS LsarEnumeratePrivileges( 
    /* [in] */ LSAPR_HANDLE PolicyHandle,
    /* [out][in] */ PLSA_ENUMERATION_HANDLE EnumerationContext,
    /* [out] */ PLSAPR_PRIVILEGE_ENUM_BUFFER EnumerationBuffer,
    /* [in] */ ULONG PreferedMaximumLength);

/* [notify] */ NTSTATUS LsarQuerySecurityObject( 
    /* [in] */ LSAPR_HANDLE ObjectHandle,
    /* [in] */ SECURITY_INFORMATION SecurityInformation,
    /* [out] */ PLSAPR_SR_SECURITY_DESCRIPTOR *SecurityDescriptor);

/* [notify] */ NTSTATUS LsarSetSecurityObject( 
    /* [in] */ LSAPR_HANDLE ObjectHandle,
    /* [in] */ SECURITY_INFORMATION SecurityInformation,
    /* [in] */ PLSAPR_SR_SECURITY_DESCRIPTOR SecurityDescriptor);

/* [notify] */ NTSTATUS LsarChangePassword( 
    /* [in] */ PLSAPR_UNICODE_STRING ServerName,
    /* [in] */ PLSAPR_UNICODE_STRING DomainName,
    /* [in] */ PLSAPR_UNICODE_STRING AccountName,
    /* [in] */ PLSAPR_UNICODE_STRING OldPassword,
    /* [in] */ PLSAPR_UNICODE_STRING NewPassword);

/* [notify] */ NTSTATUS LsarOpenPolicy( 
    /* [unique][in] */ PLSAPR_SERVER_NAME SystemName,
    /* [in] */ PLSAPR_OBJECT_ATTRIBUTES ObjectAttributes,
    /* [in] */ ACCESS_MASK DesiredAccess,
    /* [out] */ LSAPR_HANDLE *PolicyHandle);

/* [notify] */ NTSTATUS LsarQueryInformationPolicy( 
    /* [in] */ LSAPR_HANDLE PolicyHandle,
    /* [in] */ POLICY_INFORMATION_CLASS InformationClass,
    /* [switch_is][out] */ PLSAPR_POLICY_INFORMATION *PolicyInformation);

/* [notify] */ NTSTATUS LsarSetInformationPolicy( 
    /* [in] */ LSAPR_HANDLE PolicyHandle,
    /* [in] */ POLICY_INFORMATION_CLASS InformationClass,
    /* [switch_is][in] */ PLSAPR_POLICY_INFORMATION PolicyInformation);

/* [notify] */ NTSTATUS LsarClearAuditLog( 
    /* [in] */ LSAPR_HANDLE PolicyHandle);

/* [notify] */ NTSTATUS LsarCreateAccount( 
    /* [in] */ LSAPR_HANDLE PolicyHandle,
    /* [in] */ PLSAPR_SID AccountSid,
    /* [in] */ ACCESS_MASK DesiredAccess,
    /* [out] */ LSAPR_HANDLE *AccountHandle);

/* [notify] */ NTSTATUS LsarEnumerateAccounts( 
    /* [in] */ LSAPR_HANDLE PolicyHandle,
    /* [out][in] */ PLSA_ENUMERATION_HANDLE EnumerationContext,
    /* [out] */ PLSAPR_ACCOUNT_ENUM_BUFFER EnumerationBuffer,
    /* [in] */ ULONG PreferedMaximumLength);

/* [notify] */ NTSTATUS LsarCreateTrustedDomain( 
    /* [in] */ LSAPR_HANDLE PolicyHandle,
    /* [in] */ PLSAPR_TRUST_INFORMATION TrustedDomainInformation,
    /* [in] */ ACCESS_MASK DesiredAccess,
    /* [out] */ LSAPR_HANDLE *TrustedDomainHandle);

/* [notify] */ NTSTATUS LsarEnumerateTrustedDomains( 
    /* [in] */ LSAPR_HANDLE PolicyHandle,
    /* [out][in] */ PLSA_ENUMERATION_HANDLE EnumerationContext,
    /* [out] */ PLSAPR_TRUSTED_ENUM_BUFFER EnumerationBuffer,
    /* [in] */ ULONG PreferedMaximumLength);

/* [notify] */ NTSTATUS LsarLookupNames( 
    /* [in] */ LSAPR_HANDLE PolicyHandle,
    /* [range][in] */ ULONG Count,
    /* [size_is][in] */ PLSAPR_UNICODE_STRING Names,
    /* [out] */ PLSAPR_REFERENCED_DOMAIN_LIST *ReferencedDomains,
    /* [out][in] */ PLSAPR_TRANSLATED_SIDS TranslatedSids,
    /* [in] */ LSAP_LOOKUP_LEVEL LookupLevel,
    /* [out][in] */ PULONG MappedCount);

/* [notify] */ NTSTATUS LsarLookupSids( 
    /* [in] */ LSAPR_HANDLE PolicyHandle,
    /* [in] */ PLSAPR_SID_ENUM_BUFFER SidEnumBuffer,
    /* [out] */ PLSAPR_REFERENCED_DOMAIN_LIST *ReferencedDomains,
    /* [out][in] */ PLSAPR_TRANSLATED_NAMES TranslatedNames,
    /* [in] */ LSAP_LOOKUP_LEVEL LookupLevel,
    /* [out][in] */ PULONG MappedCount);

/* [notify] */ NTSTATUS LsarCreateSecret( 
    /* [in] */ LSAPR_HANDLE PolicyHandle,
    /* [in] */ PLSAPR_UNICODE_STRING SecretName,
    /* [in] */ ACCESS_MASK DesiredAccess,
    /* [out] */ LSAPR_HANDLE *SecretHandle);

/* [notify] */ NTSTATUS LsarOpenAccount( 
    /* [in] */ LSAPR_HANDLE PolicyHandle,
    /* [in] */ PLSAPR_SID AccountSid,
    /* [in] */ ACCESS_MASK DesiredAccess,
    /* [out] */ LSAPR_HANDLE *AccountHandle);

/* [notify] */ NTSTATUS LsarEnumeratePrivilegesAccount( 
    /* [in] */ LSAPR_HANDLE AccountHandle,
    /* [out] */ PLSAPR_PRIVILEGE_SET *Privileges);

/* [notify] */ NTSTATUS LsarAddPrivilegesToAccount( 
    /* [in] */ LSAPR_HANDLE AccountHandle,
    /* [in] */ PLSAPR_PRIVILEGE_SET Privileges);

/* [notify] */ NTSTATUS LsarRemovePrivilegesFromAccount( 
    /* [in] */ LSAPR_HANDLE AccountHandle,
    /* [in] */ BOOLEAN AllPrivileges,
    /* [unique][in] */ PLSAPR_PRIVILEGE_SET Privileges);

/* [notify] */ NTSTATUS LsarGetQuotasForAccount( 
    /* [in] */ LSAPR_HANDLE AccountHandle,
    /* [out] */ PQUOTA_LIMITS QuotaLimits);

/* [notify] */ NTSTATUS LsarSetQuotasForAccount( 
    /* [in] */ LSAPR_HANDLE AccountHandle,
    /* [in] */ PQUOTA_LIMITS QuotaLimits);

/* [notify] */ NTSTATUS LsarGetSystemAccessAccount( 
    /* [in] */ LSAPR_HANDLE AccountHandle,
    /* [out] */ PULONG SystemAccess);

/* [notify] */ NTSTATUS LsarSetSystemAccessAccount( 
    /* [in] */ LSAPR_HANDLE AccountHandle,
    /* [in] */ ULONG SystemAccess);

/* [notify] */ NTSTATUS LsarOpenTrustedDomain( 
    /* [in] */ LSAPR_HANDLE PolicyHandle,
    /* [in] */ PLSAPR_SID TrustedDomainSid,
    /* [in] */ ACCESS_MASK DesiredAccess,
    /* [out] */ LSAPR_HANDLE *TrustedDomainHandle);

/* [notify] */ NTSTATUS LsarQueryInfoTrustedDomain( 
    /* [in] */ LSAPR_HANDLE TrustedDomainHandle,
    /* [in] */ TRUSTED_INFORMATION_CLASS InformationClass,
    /* [switch_is][out] */ PLSAPR_TRUSTED_DOMAIN_INFO *TrustedDomainInformation);

/* [notify] */ NTSTATUS LsarSetInformationTrustedDomain( 
    /* [in] */ LSAPR_HANDLE TrustedDomainHandle,
    /* [in] */ TRUSTED_INFORMATION_CLASS InformationClass,
    /* [switch_is][in] */ PLSAPR_TRUSTED_DOMAIN_INFO TrustedDomainInformation);

/* [notify] */ NTSTATUS LsarOpenSecret( 
    /* [in] */ LSAPR_HANDLE PolicyHandle,
    /* [in] */ PLSAPR_UNICODE_STRING SecretName,
    /* [in] */ ACCESS_MASK DesiredAccess,
    /* [out] */ LSAPR_HANDLE *SecretHandle);

/* [notify] */ NTSTATUS LsarSetSecret( 
    /* [in] */ LSAPR_HANDLE SecretHandle,
    /* [unique][in] */ PLSAPR_CR_CIPHER_VALUE EncryptedCurrentValue,
    /* [unique][in] */ PLSAPR_CR_CIPHER_VALUE EncryptedOldValue);

/* [notify] */ NTSTATUS LsarQuerySecret( 
    /* [in] */ LSAPR_HANDLE SecretHandle,
    /* [unique][out][in] */ PLSAPR_CR_CIPHER_VALUE *EncryptedCurrentValue,
    /* [unique][out][in] */ PLARGE_INTEGER CurrentValueSetTime,
    /* [unique][out][in] */ PLSAPR_CR_CIPHER_VALUE *EncryptedOldValue,
    /* [unique][out][in] */ PLARGE_INTEGER OldValueSetTime);

/* [notify] */ NTSTATUS LsarLookupPrivilegeValue( 
    /* [in] */ LSAPR_HANDLE PolicyHandle,
    /* [in] */ PLSAPR_UNICODE_STRING Name,
    /* [out] */ PLUID Value);

/* [notify] */ NTSTATUS LsarLookupPrivilegeName( 
    /* [in] */ LSAPR_HANDLE PolicyHandle,
    /* [in] */ PLUID Value,
    /* [out] */ PLSAPR_UNICODE_STRING *Name);

/* [notify] */ NTSTATUS LsarLookupPrivilegeDisplayName( 
    /* [in] */ LSAPR_HANDLE PolicyHandle,
    /* [in] */ PLSAPR_UNICODE_STRING Name,
    /* [in] */ SHORT ClientLanguage,
    /* [in] */ SHORT ClientSystemDefaultLanguage,
    /* [out] */ PLSAPR_UNICODE_STRING *DisplayName,
    /* [out] */ PWORD LanguageReturned);

/* [notify] */ NTSTATUS LsarDeleteObject( 
    /* [out][in] */ LSAPR_HANDLE *ObjectHandle);

/* [notify] */ NTSTATUS LsarEnumerateAccountsWithUserRight( 
    /* [in] */ LSAPR_HANDLE PolicyHandle,
    /* [unique][in] */ PLSAPR_UNICODE_STRING UserRight,
    /* [out] */ PLSAPR_ACCOUNT_ENUM_BUFFER EnumerationBuffer);

/* [notify] */ NTSTATUS LsarEnumerateAccountRights( 
    /* [in] */ LSAPR_HANDLE PolicyHandle,
    /* [in] */ PLSAPR_SID AccountSid,
    /* [out] */ PLSAPR_USER_RIGHT_SET UserRights);

/* [notify] */ NTSTATUS LsarAddAccountRights( 
    /* [in] */ LSAPR_HANDLE PolicyHandle,
    /* [in] */ PLSAPR_SID AccountSid,
    /* [in] */ PLSAPR_USER_RIGHT_SET UserRights);

/* [notify] */ NTSTATUS LsarRemoveAccountRights( 
    /* [in] */ LSAPR_HANDLE PolicyHandle,
    /* [in] */ PLSAPR_SID AccountSid,
    /* [in] */ BOOLEAN AllRights,
    /* [in] */ PLSAPR_USER_RIGHT_SET UserRights);

/* [notify] */ NTSTATUS LsarQueryTrustedDomainInfo( 
    /* [in] */ LSAPR_HANDLE PolicyHandle,
    /* [in] */ PLSAPR_SID TrustedDomainSid,
    /* [in] */ TRUSTED_INFORMATION_CLASS InformationClass,
    /* [switch_is][out] */ PLSAPR_TRUSTED_DOMAIN_INFO *TrustedDomainInformation);

/* [notify] */ NTSTATUS LsarSetTrustedDomainInfo( 
    /* [in] */ LSAPR_HANDLE PolicyHandle,
    /* [in] */ PLSAPR_SID TrustedDomainSid,
    /* [in] */ TRUSTED_INFORMATION_CLASS InformationClass,
    /* [switch_is][in] */ PLSAPR_TRUSTED_DOMAIN_INFO TrustedDomainInformation);

/* [notify] */ NTSTATUS LsarDeleteTrustedDomain( 
    /* [in] */ LSAPR_HANDLE PolicyHandle,
    /* [in] */ PLSAPR_SID TrustedDomainSid);

/* [notify] */ NTSTATUS LsarStorePrivateData( 
    /* [in] */ LSAPR_HANDLE PolicyHandle,
    /* [in] */ PLSAPR_UNICODE_STRING KeyName,
    /* [unique][in] */ PLSAPR_CR_CIPHER_VALUE EncryptedData);

/* [notify] */ NTSTATUS LsarRetrievePrivateData( 
    /* [in] */ LSAPR_HANDLE PolicyHandle,
    /* [in] */ PLSAPR_UNICODE_STRING KeyName,
    /* [out][in] */ PLSAPR_CR_CIPHER_VALUE *EncryptedData);

/* [notify] */ NTSTATUS LsarOpenPolicy2( 
    /* [string][unique][in] */ PLSAPR_SERVER_NAME SystemName,
    /* [in] */ PLSAPR_OBJECT_ATTRIBUTES ObjectAttributes,
    /* [in] */ ACCESS_MASK DesiredAccess,
    /* [out] */ LSAPR_HANDLE *PolicyHandle);

/* [notify] */ NTSTATUS LsarGetUserName( 
    /* [string][unique][in] */ PLSAPR_SERVER_NAME SystemName,
    /* [out][in] */ PLSAPR_UNICODE_STRING *UserName,
    /* [unique][out][in] */ PLSAPR_UNICODE_STRING *DomainName);

/* [notify] */ NTSTATUS LsarQueryInformationPolicy2( 
    /* [in] */ LSAPR_HANDLE PolicyHandle,
    /* [in] */ POLICY_INFORMATION_CLASS InformationClass,
    /* [switch_is][out] */ PLSAPR_POLICY_INFORMATION *PolicyInformation);

/* [notify] */ NTSTATUS LsarSetInformationPolicy2( 
    /* [in] */ LSAPR_HANDLE PolicyHandle,
    /* [in] */ POLICY_INFORMATION_CLASS InformationClass,
    /* [switch_is][in] */ PLSAPR_POLICY_INFORMATION PolicyInformation);

/* [notify] */ NTSTATUS LsarQueryTrustedDomainInfoByName( 
    /* [in] */ LSAPR_HANDLE PolicyHandle,
    /* [in] */ PLSAPR_UNICODE_STRING TrustedDomainName,
    /* [in] */ TRUSTED_INFORMATION_CLASS InformationClass,
    /* [switch_is][out] */ PLSAPR_TRUSTED_DOMAIN_INFO *TrustedDomainInformation);

/* [notify] */ NTSTATUS LsarSetTrustedDomainInfoByName( 
    /* [in] */ LSAPR_HANDLE PolicyHandle,
    /* [in] */ PLSAPR_UNICODE_STRING TrustedDomainName,
    /* [in] */ TRUSTED_INFORMATION_CLASS InformationClass,
    /* [switch_is][in] */ PLSAPR_TRUSTED_DOMAIN_INFO TrustedDomainInformation);

/* [notify] */ NTSTATUS LsarEnumerateTrustedDomainsEx( 
    /* [in] */ LSAPR_HANDLE PolicyHandle,
    /* [out][in] */ PLSA_ENUMERATION_HANDLE EnumerationContext,
    /* [out] */ PLSAPR_TRUSTED_ENUM_BUFFER_EX EnumerationBuffer,
    /* [in] */ ULONG PreferedMaximumLength);

/* [notify] */ NTSTATUS LsarCreateTrustedDomainEx( 
    /* [in] */ LSAPR_HANDLE PolicyHandle,
    /* [in] */ PLSAPR_TRUSTED_DOMAIN_INFORMATION_EX TrustedDomainInformation,
    /* [in] */ PLSAPR_TRUSTED_DOMAIN_AUTH_INFORMATION AuthenticationInformation,
    /* [in] */ ACCESS_MASK DesiredAccess,
    /* [out] */ LSAPR_HANDLE *TrustedDomainHandle);

/* [notify] */ NTSTATUS LsarSetPolicyReplicationHandle( 
    /* [out][in] */ PLSAPR_HANDLE PolicyHandle);

/* [notify] */ NTSTATUS LsarQueryDomainInformationPolicy( 
    /* [in] */ LSAPR_HANDLE PolicyHandle,
    /* [in] */ POLICY_DOMAIN_INFORMATION_CLASS InformationClass,
    /* [switch_is][out] */ PLSAPR_POLICY_DOMAIN_INFORMATION *PolicyDomainInformation);

/* [notify] */ NTSTATUS LsarSetDomainInformationPolicy( 
    /* [in] */ LSAPR_HANDLE PolicyHandle,
    /* [in] */ POLICY_DOMAIN_INFORMATION_CLASS InformationClass,
    /* [switch_is][unique][in] */ PLSAPR_POLICY_DOMAIN_INFORMATION PolicyDomainInformation);

/* [notify] */ NTSTATUS LsarOpenTrustedDomainByName( 
    /* [in] */ LSAPR_HANDLE PolicyHandle,
    /* [in] */ PLSAPR_UNICODE_STRING TrustedDomainName,
    /* [in] */ ACCESS_MASK DesiredAccess,
    /* [out] */ LSAPR_HANDLE *TrustedDomainHandle);

NTSTATUS LsaITestCall( 
    /* [in] */ LSAPR_HANDLE PolicyHandle,
    /* [in] */ LSAPR_TEST_INTERNAL_ROUTINES Call,
    /* [in] */ PLSAPR_TEST_INTERNAL_ARG_LIST InputArgs,
    /* [out] */ PLSAPR_TEST_INTERNAL_ARG_LIST *OuputArgs);

NTSTATUS LsarLookupSids2( 
    /* [in] */ LSAPR_HANDLE PolicyHandle,
    /* [in] */ PLSAPR_SID_ENUM_BUFFER SidEnumBuffer,
    /* [out] */ PLSAPR_REFERENCED_DOMAIN_LIST *ReferencedDomains,
    /* [out][in] */ PLSAPR_TRANSLATED_NAMES_EX TranslatedNames,
    /* [in] */ LSAP_LOOKUP_LEVEL LookupLevel,
    /* [out][in] */ PULONG MappedCount,
    /* [in] */ ULONG LookupOptions,
    /* [in] */ ULONG ClientRevision);

NTSTATUS LsarLookupNames2( 
    /* [in] */ LSAPR_HANDLE PolicyHandle,
    /* [range][in] */ ULONG Count,
    /* [size_is][in] */ PLSAPR_UNICODE_STRING Names,
    /* [out] */ PLSAPR_REFERENCED_DOMAIN_LIST *ReferencedDomains,
    /* [out][in] */ PLSAPR_TRANSLATED_SIDS_EX TranslatedSids,
    /* [in] */ LSAP_LOOKUP_LEVEL LookupLevel,
    /* [out][in] */ PULONG MappedCount,
    /* [in] */ ULONG LookupOptions,
    /* [in] */ ULONG ClientRevision);

NTSTATUS LsarCreateTrustedDomainEx2( 
    /* [in] */ LSAPR_HANDLE PolicyHandle,
    /* [in] */ PLSAPR_TRUSTED_DOMAIN_INFORMATION_EX TrustedDomainInformation,
    /* [in] */ PLSAPR_TRUSTED_DOMAIN_AUTH_INFORMATION_INTERNAL AuthenticationInformation,
    /* [in] */ ACCESS_MASK DesiredAccess,
    /* [out] */ LSAPR_HANDLE *TrustedDomainHandle);

NTSTATUS CredrWrite( 
    /* [string][unique][in] */ PLSAPR_SERVER_NAME ServerName,
    /* [in] */ PENCRYPTED_CREDENTIALW Credential,
    /* [in] */ ULONG Flags);

NTSTATUS CredrRead( 
    /* [string][unique][in] */ PLSAPR_SERVER_NAME ServerName,
    /* [string][in] */ wchar_t *TargetName,
    /* [in] */ ULONG Type,
    /* [in] */ ULONG Flags,
    /* [out] */ PENCRYPTED_CREDENTIALW *Credential);

typedef PENCRYPTED_CREDENTIALW *PPENCRYPTED_CREDENTIALW;

typedef struct _CREDENTIAL_ARRAY
    {
    ULONG CredentialCount;
    /* [size_is][unique] */ PPENCRYPTED_CREDENTIALW Credentials;
    } 	CREDENTIAL_ARRAY;

typedef struct _CREDENTIAL_ARRAY *PCREDENTIAL_ARRAY;

NTSTATUS CredrEnumerate( 
    /* [string][unique][in] */ PLSAPR_SERVER_NAME ServerName,
    /* [string][unique][in] */ wchar_t *Filter,
    /* [in] */ ULONG Flags,
    /* [out] */ PCREDENTIAL_ARRAY CredentialArray);

NTSTATUS CredrWriteDomainCredentials( 
    /* [string][unique][in] */ PLSAPR_SERVER_NAME ServerName,
    /* [in] */ PCREDENTIAL_TARGET_INFORMATIONW TargetInfo,
    /* [in] */ PENCRYPTED_CREDENTIALW Credential,
    /* [in] */ ULONG Flags);

NTSTATUS CredrReadDomainCredentials( 
    /* [string][unique][in] */ PLSAPR_SERVER_NAME ServerName,
    /* [in] */ PCREDENTIAL_TARGET_INFORMATIONW TargetInfo,
    /* [in] */ ULONG Flags,
    /* [out] */ PCREDENTIAL_ARRAY CredentialArray);

NTSTATUS CredrDelete( 
    /* [string][unique][in] */ PLSAPR_SERVER_NAME ServerName,
    /* [string][in] */ wchar_t *TargetName,
    /* [in] */ ULONG Type,
    /* [in] */ ULONG Flags);

NTSTATUS CredrGetTargetInfo( 
    /* [string][unique][in] */ PLSAPR_SERVER_NAME ServerName,
    /* [string][in] */ wchar_t *TargetName,
    /* [in] */ ULONG Flags,
    /* [out] */ PCREDENTIAL_TARGET_INFORMATIONW *TargetInfo);

NTSTATUS CredrProfileLoaded( 
    /* [string][unique][in] */ PLSAPR_SERVER_NAME ServerName);

NTSTATUS LsarLookupNames3( 
    /* [in] */ LSAPR_HANDLE PolicyHandle,
    /* [range][in] */ ULONG Count,
    /* [size_is][in] */ PLSAPR_UNICODE_STRING Names,
    /* [out] */ PLSAPR_REFERENCED_DOMAIN_LIST *ReferencedDomains,
    /* [out][in] */ PLSAPR_TRANSLATED_SIDS_EX2 TranslatedSids,
    /* [in] */ LSAP_LOOKUP_LEVEL LookupLevel,
    /* [out][in] */ PULONG MappedCount,
    /* [in] */ ULONG LookupOptions,
    /* [in] */ ULONG ClientRevision);

NTSTATUS CredrGetSessionTypes( 
    /* [string][unique][in] */ PLSAPR_SERVER_NAME ServerName,
    /* [range][in] */ ULONG MaximumPersistCount,
    /* [size_is][out] */ ULONG *MaximumPersist);

NTSTATUS LsarRegisterAuditEvent( 
    /* [in] */ PAUTHZ_AUDIT_EVENT_TYPE_OLD pAuditEventType,
    /* [out] */ AUDIT_HANDLE *phAuditContext);

NTSTATUS LsarGenAuditEvent( 
    /* [in] */ AUDIT_HANDLE hAuditContext,
    /* [in] */ DWORD Flags,
    /* [in] */ AUDIT_PARAMS *pAuditParams);

NTSTATUS LsarUnregisterAuditEvent( 
    /* [out][in] */ AUDIT_HANDLE *phAuditContext);

NTSTATUS LsarQueryForestTrustInformation( 
    /* [in] */ LSAPR_HANDLE PolicyHandle,
    /* [in] */ PLSA_UNICODE_STRING TrustedDomainName,
    /* [in] */ LSA_FOREST_TRUST_RECORD_TYPE HighestRecordType,
    /* [out] */ PLSA_FOREST_TRUST_INFORMATION *ForestTrustInfo);

NTSTATUS LsarSetForestTrustInformation( 
    /* [in] */ LSAPR_HANDLE PolicyHandle,
    /* [in] */ PLSA_UNICODE_STRING TrustedDomainName,
    /* [in] */ LSA_FOREST_TRUST_RECORD_TYPE HighestRecordType,
    /* [in] */ PLSA_FOREST_TRUST_INFORMATION ForestTrustInfo,
    /* [in] */ BOOLEAN CheckOnly,
    /* [out] */ PLSA_FOREST_TRUST_COLLISION_INFORMATION *CollisionInfo);

NTSTATUS CredrRename( 
    /* [string][unique][in] */ PLSAPR_SERVER_NAME ServerName,
    /* [string][in] */ wchar_t *OldTargetName,
    /* [string][in] */ wchar_t *NewTargetName,
    /* [in] */ ULONG Type,
    /* [in] */ ULONG Flags);

NTSTATUS LsarLookupSids3( 
    /* [in] */ handle_t RpcHandle,
    /* [in] */ PLSAPR_SID_ENUM_BUFFER SidEnumBuffer,
    /* [out] */ PLSAPR_REFERENCED_DOMAIN_LIST *ReferencedDomains,
    /* [out][in] */ PLSAPR_TRANSLATED_NAMES_EX TranslatedNames,
    /* [in] */ LSAP_LOOKUP_LEVEL LookupLevel,
    /* [out][in] */ PULONG MappedCount,
    /* [in] */ ULONG LookupOptions,
    /* [in] */ ULONG ClientRevision);

NTSTATUS LsarLookupNames4( 
    /* [in] */ handle_t RpcHandle,
    /* [range][in] */ ULONG Count,
    /* [size_is][in] */ PLSAPR_UNICODE_STRING Names,
    /* [out] */ PLSAPR_REFERENCED_DOMAIN_LIST *ReferencedDomains,
    /* [out][in] */ PLSAPR_TRANSLATED_SIDS_EX2 TranslatedSids,
    /* [in] */ LSAP_LOOKUP_LEVEL LookupLevel,
    /* [out][in] */ PULONG MappedCount,
    /* [in] */ ULONG LookupOptions,
    /* [in] */ ULONG ClientRevision);

NTSTATUS LsarOpenPolicySce( 
    /* [unique][in] */ PLSAPR_SERVER_NAME SystemName,
    /* [in] */ PLSAPR_OBJECT_ATTRIBUTES ObjectAttributes,
    /* [in] */ ACCESS_MASK DesiredAccess,
    /* [out] */ LSAPR_HANDLE *PolicyHandle);

typedef struct _LSA_SECURITY_EVENT
    {
    DWORD dwFlags;
    DWORD dwCategoryId;
    DWORD dwAuditId;
    PAUDIT_PARAMS pAuditParams;
    } 	LSA_SECURITY_EVENT;

typedef struct _LSA_SECURITY_EVENT *PLSA_SECURITY_EVENT;

typedef /* [context_handle] */ PVOID SECURITY_SOURCE_HANDLE;

typedef /* [context_handle] */ PVOID *PSECURITY_SOURCE_HANDLE;

typedef /* [handle] */ LPCWSTR PSECURITY_SOURCE_NAME;

typedef /* [handle] */ LPCWSTR *PPSECURITY_SOURCE_NAME;

NTSTATUS LsarAdtRegisterSecurityEventSource( 
    /* [in] */ DWORD dwFlags,
    /* [string][unique][in] */ PSECURITY_SOURCE_NAME szEventSourceName,
    /* [out] */ SECURITY_SOURCE_HANDLE *phSecuritySource);

NTSTATUS LsarAdtUnregisterSecurityEventSource( 
    /* [in] */ DWORD dwFlags,
    /* [out][in] */ SECURITY_SOURCE_HANDLE *phSecuritySource);

NTSTATUS LsarAdtReportSecurityEvent( 
    /* [in] */ DWORD dwFlags,
    /* [in] */ SECURITY_SOURCE_HANDLE hSource,
    /* [in] */ DWORD dwAuditId,
    /* [in] */ SID *pSid,
    /* [in] */ PAUDIT_PARAMS pParams);


extern handle_t IgnoreThisHandle;


extern RPC_IF_HANDLE lsarpc_ClientIfHandle;
extern RPC_IF_HANDLE lsarpc_ServerIfHandle;
#endif /* __lsarpc_INTERFACE_DEFINED__ */

/* Additional Prototypes for ALL interfaces */

handle_t __RPC_USER PAUTHZ_AUDIT_EVENT_TYPE_OLD_bind  ( PAUTHZ_AUDIT_EVENT_TYPE_OLD );
void     __RPC_USER PAUTHZ_AUDIT_EVENT_TYPE_OLD_unbind( PAUTHZ_AUDIT_EVENT_TYPE_OLD, handle_t );
handle_t __RPC_USER PLSAPR_SERVER_NAME_bind  ( PLSAPR_SERVER_NAME );
void     __RPC_USER PLSAPR_SERVER_NAME_unbind( PLSAPR_SERVER_NAME, handle_t );
handle_t __RPC_USER PSECURITY_SOURCE_NAME_bind  ( PSECURITY_SOURCE_NAME );
void     __RPC_USER PSECURITY_SOURCE_NAME_unbind( PSECURITY_SOURCE_NAME, handle_t );

void __RPC_USER AUDIT_HANDLE_rundown( AUDIT_HANDLE );
void __RPC_USER LSAPR_HANDLE_rundown( LSAPR_HANDLE );
void __RPC_USER SECURITY_SOURCE_HANDLE_rundown( SECURITY_SOURCE_HANDLE );

void LsarClose_notify( void);

void LsarDelete_notify( void);

void LsarEnumeratePrivileges_notify( void);

void LsarQuerySecurityObject_notify( void);

void LsarSetSecurityObject_notify( void);

void LsarChangePassword_notify( void);

void LsarOpenPolicy_notify( void);

void LsarQueryInformationPolicy_notify( void);

void LsarSetInformationPolicy_notify( void);

void LsarClearAuditLog_notify( void);

void LsarCreateAccount_notify( void);

void LsarEnumerateAccounts_notify( void);

void LsarCreateTrustedDomain_notify( void);

void LsarEnumerateTrustedDomains_notify( void);

void LsarLookupNames_notify( void);

void LsarLookupSids_notify( void);

void LsarCreateSecret_notify( void);

void LsarOpenAccount_notify( void);

void LsarEnumeratePrivilegesAccount_notify( void);

void LsarAddPrivilegesToAccount_notify( void);

void LsarRemovePrivilegesFromAccount_notify( void);

void LsarGetQuotasForAccount_notify( void);

void LsarSetQuotasForAccount_notify( void);

void LsarGetSystemAccessAccount_notify( void);

void LsarSetSystemAccessAccount_notify( void);

void LsarOpenTrustedDomain_notify( void);

void LsarQueryInfoTrustedDomain_notify( void);

void LsarSetInformationTrustedDomain_notify( void);

void LsarOpenSecret_notify( void);

void LsarSetSecret_notify( void);

void LsarQuerySecret_notify( void);

void LsarLookupPrivilegeValue_notify( void);

void LsarLookupPrivilegeName_notify( void);

void LsarLookupPrivilegeDisplayName_notify( void);

void LsarDeleteObject_notify( void);

void LsarEnumerateAccountsWithUserRight_notify( void);

void LsarEnumerateAccountRights_notify( void);

void LsarAddAccountRights_notify( void);

void LsarRemoveAccountRights_notify( void);

void LsarQueryTrustedDomainInfo_notify( void);

void LsarSetTrustedDomainInfo_notify( void);

void LsarDeleteTrustedDomain_notify( void);

void LsarStorePrivateData_notify( void);

void LsarRetrievePrivateData_notify( void);

void LsarOpenPolicy2_notify( void);

void LsarGetUserName_notify( void);

void LsarQueryInformationPolicy2_notify( void);

void LsarSetInformationPolicy2_notify( void);

void LsarQueryTrustedDomainInfoByName_notify( void);

void LsarSetTrustedDomainInfoByName_notify( void);

void LsarEnumerateTrustedDomainsEx_notify( void);

void LsarCreateTrustedDomainEx_notify( void);

void LsarSetPolicyReplicationHandle_notify( void);

void LsarQueryDomainInformationPolicy_notify( void);

void LsarSetDomainInformationPolicy_notify( void);

void LsarOpenTrustedDomainByName_notify( void);


/* end of Additional Prototypes */

#ifdef __cplusplus
}
#endif

#endif
=== C:/Users/treeman/Desktop/windows nt source code\Source\Win2K3\NT\public\internal\ds\inc\lsaicli.h ===
/*++

Copyright (c) 1991  Microsoft Corporation

Module Name:

    lsaicli.h

Abstract:

    Local Security Authority - Definitions for internal LSA Clients.

    NOTE:  This file is included via lsaclip.h or lsasrvp.h.  It should
           not be included directly.

    This module contains definitions used only when callouts are made
    from one LSA to another, i.e. where the server side of one LSA
    communicates with the client side of another LSA.

Author:

    Scott Birrell       (ScottBi)      April 9, 1992

Environment:

Revision History:

--*/

#ifndef _LSAICLI_
#define _LSAICLI_

//
// The following datatype specifies the Call Level for Sid and Name
// Lookup operations.
//

typedef enum _LSAP_LOOKUP_LEVEL {

    LsapLookupWksta = 1,
    LsapLookupPDC,
    LsapLookupTDL,
    LsapLookupGC,              // valid only on NT5   domain controllers
    LsapLookupXForestReferral, // valid only on NT5.1 domain controllers
    LsapLookupXForestResolve   // valid only on NT5.1 domain controllers

} LSAP_LOOKUP_LEVEL, *PLSAP_LOOKUP_LEVEL;

//
// where the entries have the following meaning:
//
// LsapLookupWksta - First Level Lookup performed on a workstation
//     normally configured for Windows-Nt.   The lookup searches the
//     Well-Known Sids/Names, and the Built-in Domain and Account Domain
//     in the local SAM Database.  If not all Sids or Names are
//     identified, performs a "handoff" of a Second level Lookup to the
//     LSA running on a Controller for the workstation's Primary Domain
//     (if any).
//
// LsapLookupPDC - Second Level Lookup performed on a Primary Domain
//     Controller.  The lookup searches the Account Domain of the
//     SAM Database on the controller.  If not all Sids or Names are
//     found, the Trusted Domain List (TDL) is obtained from the
//     LSA's Policy Database and Third Level lookups are performed
//     via "handoff" to each Trusted Domain in the List.
//
// LsapLookupTDL - Third Level Lookup performed on a controller
//     for a Trusted Domain.  The lookup searches the Account Domain of
//     the SAM Database on the controller only.
//
// LsapLookupGC - This is used by a workstation to perform a lookup at a GC
//     This resolves UPN's, samaccountname's with NetBios and DNS domain names,
//     Sid's and Sid Histories for transitivly trusted domains (within a 
//     forest).  This lookup level is only used when a NT5+ client is in 
//     a mixed domain and its secure channel DC is NT4
//
// LsapLookupXForestReferral -- This is used to pass entries (names and Sids)
//     to the root of the forest via the trust chain.  After a set of entries,
//     comes back from the GC, some may be marked as belonging to a cross
//     forest.  These entries are then passed on to the DC's parent domain until
//     the root of the domain is reached.  The root will then issue a 
//     LsapLookupXForestResolve directed at a DC in the external forest.
//
// LpsaLookupXForestResolve -- This level is used by the root of one forest
//     lookup entries from the DC in another forest.
//

typedef struct _LSA_TRANSLATED_NAME_EX
{
    SID_NAME_USE Use;
    LSA_UNICODE_STRING Name;
    LONG DomainIndex;
    ULONG Flags;

} LSA_TRANSLATED_NAME_EX;

typedef struct _LSA_TRANSLATED_NAME_EX *PLSA_TRANSLATED_NAME_EX;

typedef struct _LSA_TRANSLATED_NAMES
{
    ULONG Entries;
    PLSA_TRANSLATED_NAME_EX Names;

} LSA_TRANSLATED_NAMES_EX;

typedef struct _LSA_TRANSLATED_NAMES *PLSA_TRANSLATED_NAMES_EX;


typedef struct _LSA_TRANSLATED_SID_EX
{
    SID_NAME_USE Use;
    ULONG        RelativeId;
    LONG DomainIndex;
    ULONG Flags;

} LSA_TRANSLATED_SID_EX;

typedef struct _LSA_TRANSLATED_SID_EX *PLSA_TRANSLATED_SID_EX;

typedef struct _LSA_TRANSLATED_SIDS_EX
{
    ULONG Entries;
    PLSA_TRANSLATED_SID_EX Names;

} LSA_TRANSLATED_SIDS_EX;

typedef struct _LSA_TRANSLATED_SIDS_EX *PLSA_TRANSLATED_SIDS_EX;

typedef struct _LSA_TRANSLATED_SID_EX2
{
    SID_NAME_USE Use;
    PSID         Sid;
    LONG         DomainIndex;
    ULONG        Flags;

} LSA_TRANSLATED_SID_EX2;

typedef struct _LSA_TRANSLATED_SID_EX2 *PLSA_TRANSLATED_SID_EX2;

typedef struct _LSA_TRANSLATED_SIDS_EX2
{
    ULONG Entries;
    PLSA_TRANSLATED_SID_EX2 Names;

} LSA_TRANSLATED_SIDS_EX2;

typedef struct _LSA_TRANSLATED_SIDS_EX2 *PLSA_TRANSLATED_SIDS_EX2;

#define LSAIC_NO_LARGE_SID    0x00000001
#define LSAIC_NT4_TARGET      0x00000002
#define LSAIC_WIN2K_TARGET    0x00000004

NTSTATUS
LsaICLookupNames(
    IN LSA_HANDLE PolicyHandle,
    IN ULONG LookupOptions,    
    IN ULONG Count,
    IN PUNICODE_STRING Names,
    OUT PLSA_REFERENCED_DOMAIN_LIST *ReferencedDomains,
    OUT PLSA_TRANSLATED_SID_EX2 *Sids,
    IN LSAP_LOOKUP_LEVEL LookupLevel,
    IN ULONG      Flags,
    IN OUT PULONG MappedCount,
    IN OUT PULONG ServerRevision
    );

/*++

Routine Description:

    This function is the internal client side version of the LsaLookupNames
    API.  It is called both from the client side (as an internal routine)
    and the server side of the LSA.  The function is identical to the
    LsaLookupNames API except that there is an additional parameter, the
    LookupLevel parameter.

    The LsaLookupNames API attempts to translate names of domains, users,
    groups or aliases to Sids.  The caller must have POLICY_LOOKUP_NAMES
    access to the Policy object.

    Names may be either isolated (e.g. JohnH) or composite names containing
    both the domain name and account name.  Composite names must include a
    backslash character separating the domain name from the account name
    (e.g. Acctg\JohnH).  An isolated name may be either an account name
    (user, group, or alias) or a domain name.

    Translation of isolated names introduces the possibility of name
    collisions (since the same name may be used in multiple domains).  An
    isolated name will be translated using the following algorithm:

    If the name is a well-known name (e.g. Local or Interactive), then the
    corresponding well-known Sid is returned.

    If the name is the Built-in Domain's name, then that domain's Sid
    will be returned.

    If the name is the Account Domain's name, then that domain's Sid
    will be returned.

    If the name is the Primary Domain's name, then that domain's Sid will
    be returned.

    If the name is a user, group, or alias in the Built-in Domain, then the
    Sid of that account is returned.

    If the name is a user, group, or alias in the Primary Domain, then the
    Sid of that account is returned.

    Otherwise, the name is not translated.

    NOTE: Proxy, Machine, and Trust user accounts are not referenced
    for name translation.  Only normal user accounts are used for ID
    translation.  If translation of other account types is needed, then
    SAM services should be used directly.

Arguments:

    This function is the LSA server RPC worker routine for the
    LsaLookupNamesInLsa API.

    PolicyHandle -  Handle from an LsaOpenPolicy call.
    
    LookupOptions - values to pass through to LsarLookupNames2 and above.

    Count - Specifies the number of names to be translated.

    Names - Pointer to an array of Count Unicode String structures
        specifying the names to be looked up and mapped to Sids.
        The strings may be names of User, Group or Alias accounts or
        domains.

    ReferencedDomains - receives a pointer to a structure describing the
        domains used for the translation.  The entries in this structure
        are referenced by the structure returned via the Sids parameter.
        Unlike the Sids parameter, which contains an array entry for
        each translated name, this structure will only contain one
        component for each domain utilized in the translation.

        When this information is no longer needed, it must be released
        by passing the returned pointer to LsaFreeMemory().

    Sids - Receives a pointer to an array of records describing each
        translated Sid.  The nth entry in this array provides a translation
        for (the nth element in the Names parameter.

        When this information is no longer needed, it must be released
        by passing the returned pointer to LsaFreeMemory().

    LookupLevel - Specifies the Level of Lookup to be performed on this
        machine.  Values of this field are are follows:

        LsapLookupWksta - First Level Lookup performed on a workstation
            normally configured for Windows-Nt.   The lookup searches the
            Well-Known Sids/Names, and the Built-in Domain and Account Domain
            in the local SAM Database.  If not all Sids or Names are
            identified, performs a "handoff" of a Second level Lookup to the
            LSA running on a Controller for the workstation's Primary Domain
            (if any).

        LsapLookupPDC - Second Level Lookup performed on a Primary Domain
            Controller.  The lookup searches the Account Domain of the
            SAM Database on the controller.  If not all Sids or Names are
            found, the Trusted Domain List (TDL) is obtained from the
            LSA's Policy Database and Third Level lookups are performed
            via "handoff" to each Trusted Domain in the List.

        LsapLookupTDL - Third Level Lookup performed on a controller
            for a Trusted Domain.  The lookup searches the Account Domain of
            the SAM Database on the controller only.
    Flags - flags to control the operation of the function.  Currently defined:
    
            LSAIC_NO_LARGE_SID -- implies only call interfaces that will return
                                  the old style format SID (no more than 
                                  28 bytes)
                        
            LSAIC_NT4_TARGET -- target server is known to be NT4
            
            LSAIC_WIN2K_TARGET -- target server is known to be Win2k
    
Return Values:

    NTSTATUS - Standard Nt Result Code

        STATUS_ACCESS_DENIED - Caller does not have the appropriate access
            to complete the operation.

        STATUS_SOME_NOT_MAPPED - Some or all of the names provided could
            not be mapped.  This is an informational status only.

        STATUS_INSUFFICIENT_RESOURCES - Insufficient system resources
            to complete the call.
--*/



NTSTATUS
LsaICLookupSids(
    IN LSA_HANDLE PolicyHandle,
    IN ULONG Count,
    IN PSID *Sids,
    OUT PLSA_REFERENCED_DOMAIN_LIST *ReferencedDomains,
    OUT PLSA_TRANSLATED_NAME_EX *Names,
    IN LSAP_LOOKUP_LEVEL LookupLevel,
    IN ULONG Flags,    
    IN OUT PULONG MappedCount,
    OUT ULONG *ServerRevision OPTIONAL
    );

/*++

Routine Description:

    WARNING! THIS FUNCTION IS NOT COMPLETELY IMPLEMENTED.  ONLY SIDS
    MAPPABLE AT THE LOCAL SYSTEM WILL BE TRANSLATED.

    The LsaLookupSids API attempts to find names corresponding to Sids.
    If a name can not be mapped to a Sid, the Sid is converted to character
    form.  The caller must have POLICY_LOOKUP_NAMES access to the Policy
    object.

    WARNING:  This routine allocates memory for its output.  The caller is
    responsible for freeing this memory after use.  See description of the
    Names parameter.

Arguments:

    PolicyHandle -  Handle from an LsaOpenPolicy call.

    Count - Specifies the number of Sids to be translated.

    Sids - Pointer to an array of Count pointers to Sids to be mapped
        to names.  The Sids may be well_known SIDs, SIDs of User accounts
        Group Accounts, Alias accounts, or Domains.

    ReferencedDomains - Receives a pointer to a structure describing the
        domains used for the translation.  The entries in this structure
        are referenced by the strutcure returned via the Names parameter.
        Unlike the Names paraemeter, which contains an array entry
        for (each translated name, this strutcure will only contain
        component for each domain utilized in the translation.

        When this information is no longer needed, it must be released
        by passing the returned pointer to LsaFreeMemory().

    Names - Receives a pointer to array records describing each translated
        name.  The nth entry in this array provides a translation for
        the nth entry in the Sids parameter.

        All of the retruned names will be isolated names or NULL strings
        (domain names are returned as NULL strings).  If the caller needs
        composite names, they can be generated by prepending the
        isolated name with the domain name and a backslash.  For example,
        if (the name Sally is returned, and it is from the domain Manufact,
        then the composite name would be "Manufact" + "\" + "Sally" or
        "Manufact\Sally".

        When this information is no longer needed, it must be released
        by passing the returned pointer to LsaFreeMemory().

        If a Sid is not translatable, then the following will occur:

        1) If the SID's domain is known, then a reference domain record
           will be generated with the domain's name.  In this case, the
           name returned via the Names parameter is a Unicode representation
           of the relative ID of the account, such as "(314)" or the null
           string, if the Sid is that of a domain.  So, you might end up
           with a resultant name of "Manufact\(314) for the example with
           Sally above, if Sally's relative id is 314.

        2) If not even the SID's domain could be located, then a full
           Unicode representation of the SID is generated and no domain
           record is referenced.  In this case, the returned string might
           be something like: "(S-1-672194-21-314)".

        When this information is no longer needed, it must be released
        by passing the returned pointer to LsaFreeMemory().

    LookupLevel - Specifies the Level of Lookup to be performed on this
        machine.  Values of this field are are follows:

        LsapLookupWksta - First Level Lookup performed on a workstation
            normally configured for Windows-Nt.   The lookup searches the
            Well-Known Sids/Names, and the Built-in Domain and Account Domain
            in the local SAM Database.  If not all Sids or Names are
            identified, performs a "handoff" of a Second level Lookup to the
            LSA running on a Controller for the workstation's Primary Domain
            (if any).

        LsapLookupPDC - Second Level Lookup performed on a Primary Domain
            Controller.  The lookup searches the Account Domain of the
            SAM Database on the controller.  If not all Sids or Names are
            found, the Trusted Domain List (TDL) is obtained from the
            LSA's Policy Database and Third Level lookups are performed
            via "handoff" to each Trusted Domain in the List.

        LsapLookupTDL - Third Level Lookup performed on a controller
            for a Trusted Domain.  The lookup searches the Account Domain of
            the SAM Database on the controller only.
            
    Flags:

            LSAIC_NT4_TARGET -- target server is known to be NT4
            
            LSAIC_WIN2K_TARGET -- target server is known to be Win2k
            
    ServerRevision : the revision of the server that is called            
    
Return Values:

    NTSTATUS - Standard Nt Result Code

        STATUS_ACCESS_DENIED - Caller does not have the appropriate access
            to complete the operation.

        STATUS_SOME_NOT_MAPPED - Some or all of the names provided could not be
            mapped.  This is a warning only.

        Rest TBS
--*/

#endif // _LSAICLI_
=== C:/Users/treeman/Desktop/windows nt source code\Source\Win2K3\NT\public\internal\ds\inc\martaexp.h ===
//+-------------------------------------------------------------------
//
//  Microsoft Windows
//  Copyright (C) Microsoft Corporation, 1996 - 1996.
//
//  File:        MARTAEXP.HXX
//
//  Contents:    Function definitions for exported helper functions
//
//  History:     06-Sep-96      MacM        Created
//
//--------------------------------------------------------------------
#ifndef __MARTAEXP_HXX__
#define __MARTAEXP_HXX__

extern "C"
{
    #include <nt.h>
    #include <ntrtl.h>
    #include <nturtl.h>
}

typedef enum _MARTA_KERNEL_TYPE
{
    MARTA_UNKNOWN = 0,
    MARTA_EVENT,
    MARTA_EVENT_PAIR,
    MARTA_MUTANT,
    MARTA_PROCESS,
    MARTA_SECTION,
    MARTA_SEMAPHORE,
    MARTA_SYMBOLIC_LINK,
    MARTA_THREAD,
    MARTA_TIMER,
    MARTA_JOB,
    MARTA_WMI_GUID

} MARTA_KERNEL_TYPE, *PMARTA_KERNEL_TYPE;


//
// Determines whether a bit flag is turned on or not
//
#define FLAG_ON(flags,bit)        ((flags) & (bit))

//
// This macro will return the size, in bytes, of a buffer needed to hold
// the given string
//
#define SIZE_PWSTR(wsz) (wsz == NULL ? 0 : (wcslen(wsz) + 1) * sizeof(WCHAR))

//
// This macro will copy the specified string to the new destination, after
// allocating a buffer of sufficient size
//
#define ACC_ALLOC_AND_COPY_STRINGW(OldString, NewString, err)           \
NewString = (PWSTR)AccAlloc(SIZE_PWSTR(OldString));                     \
if(NewString == NULL)                                                   \
{                                                                       \
    err = ERROR_NOT_ENOUGH_MEMORY;                                      \
}                                                                       \
else                                                                    \
{                                                                       \
    wcscpy((PWSTR)NewString,                                            \
           OldString);                                                  \
}

//
// Flags to pass in to AccConvertAccessToSD
//
#define ACCCONVERT_SELF_RELATIVE        0x00000001
#define ACCCONVERT_DS_FORMAT            0x00000002


//+-------------------------------------------------------------------------
// helper.cxx
//+-------------------------------------------------------------------------
ULONG
TrusteeAllocationSize(IN PTRUSTEE_W pTrustee);

ULONG
TrusteeAllocationSizeWToA(IN PTRUSTEE_W pTrustee);

ULONG
TrusteeAllocationSizeAToW(IN PTRUSTEE_A pTrustee);

VOID
SpecialCopyTrustee(VOID **pStuffPtr, PTRUSTEE pToTrustee, PTRUSTEE pFromTrustee);

DWORD
CopyTrusteeAToTrusteeW( IN OUT VOID     ** ppStuffPtr,
                        IN     PTRUSTEE_A  pFromTrusteeA,
                        OUT    PTRUSTEE_W  pToTrusteeW );

DWORD
CopyTrusteeWToTrusteeA( IN OUT VOID    ** ppStuffPtr,
                        IN     PTRUSTEE_W pFromTrusteeW,
                        OUT    PTRUSTEE_A pToTrusteeA );

DWORD
ExplicitAccessAToExplicitAccessW( IN  ULONG                cCountAccesses,
                                  IN  PEXPLICIT_ACCESS_A   paAccess,
                                  OUT PEXPLICIT_ACCESS_W * ppwAccess );

DWORD
ExplicitAccessWToExplicitAccessA( IN  ULONG                cCountAccesses,
                                  IN  PEXPLICIT_ACCESS_W   pwAccess,
                                  OUT PEXPLICIT_ACCESS_A * ppaAccess );


DWORD
DoTrusteesMatch(PWSTR       pwszServer,
                PTRUSTEE    pTrustee1,
                PTRUSTEE    pTrustee2,
                PBOOL       pfMatch);


//+-------------------------------------------------------------------------
// aclutil.cxx
//+-------------------------------------------------------------------------
extern "C"
{
DWORD
AccGetSidFromToken(PWSTR                    pwszServer,
                   HANDLE                   hToken,
                   TOKEN_INFORMATION_CLASS  TIC,
                   PSID                    *ppSidFromToken);

DWORD
AccLookupAccountSid(IN  PWSTR          pwszServer,
                    IN  PTRUSTEE        pName,
                    OUT PSID           *ppsid,
                    OUT SID_NAME_USE   *pSidType);

DWORD
AccLookupAccountTrustee(IN  PWSTR          pwszServer,
                        IN  PSID        psid,
                        OUT PTRUSTEE   *ppTrustee);

DWORD
AccLookupAccountName(IN  PWSTR          pwszServer,
                     IN  PSID           pSid,
                     OUT LPWSTR        *ppwszName,
                     OUT LPWSTR        *ppwszDomain,
                     OUT SID_NAME_USE  *pSidType);

DWORD
AccSetEntriesInAList(IN  ULONG                 cEntries,
                     IN  PACTRL_ACCESS_ENTRYW  pAccessEntryList,
                     IN  ACCESS_MODE           AccessMode,
                     IN  SECURITY_INFORMATION  SeInfo,
                     IN  LPCWSTR               lpProperty,
                     IN  BOOL                  fDoOldStyleMerge,
                     IN  PACTRL_AUDITW         pOldList,
                     OUT PACTRL_AUDITW        *ppNewList);

DWORD
AccConvertAccessToSecurityDescriptor(IN  PACTRL_ACCESSW        pAccessList,
                                     IN  PACTRL_AUDITW         pAuditList,
                                     IN  LPCWSTR               lpOwner,
                                     IN  LPCWSTR               lpGroup,
                                     OUT PSECURITY_DESCRIPTOR *ppSecDescriptor);

DWORD
AccConvertSDToAccess(IN  SE_OBJECT_TYPE       ObjectType,
                     IN  PSECURITY_DESCRIPTOR pSecDescriptor,
                     OUT PACTRL_ACCESSW      *ppAccessList,
                     OUT PACTRL_AUDITW       *ppAuditList,
                     OUT LPWSTR              *lppOwner,
                     OUT LPWSTR              *lppGroup);

DWORD
AccConvertAccessToSD(IN  SE_OBJECT_TYPE         ObjectType,
                     IN  SECURITY_INFORMATION   SeInfo,
                     IN  PACTRL_ACCESSW         pAccessList,
                     IN  PACTRL_AUDITW          pAuditList,
                     IN  LPWSTR                 lpOwner,
                     IN  LPWSTR                 lpGroup,
                     IN  ULONG                  fOpts,
                     OUT PSECURITY_DESCRIPTOR  *ppSD,
                     OUT PULONG                 pcSDSize);


DWORD
AccGetAccessForTrustee(IN  PTRUSTEE                 pTrustee,
                       IN  PACL                     pAcl,
                       IN  SECURITY_INFORMATION     SeInfo,
                       IN  PWSTR                    pwszProperty,
                       OUT PACCESS_RIGHTS           pAllowed,
                       OUT PACCESS_RIGHTS           pDenied);

DWORD
AccConvertAclToAccess(IN  SE_OBJECT_TYPE       ObjectType,
                      IN  PACL                 pAcl,
                      OUT PACTRL_ACCESSW      *ppAccessList);

DWORD
AccGetExplicitEntries(IN  PTRUSTEE              pTrustee,
                      IN  SE_OBJECT_TYPE        ObjectType,
                      IN  PACL                  pAcl,
                      IN  PWSTR                 pwszProperty,
                      OUT PULONG                pcEntries,
                      OUT PACTRL_ACCESS_ENTRYW *ppAEList);

VOID
AccConvertAccessMaskToActrlAccess(IN  ACCESS_MASK          Access,
                                  IN  SE_OBJECT_TYPE       ObjType,
                                  IN  MARTA_KERNEL_TYPE    KernelObjectType,
                                  IN  PACTRL_ACCESS_ENTRY  pAE);
}


typedef struct _CSLIST_NODE
{
    PVOID       pvData;
    struct _CSLIST_NODE *pNext;
} CSLIST_NODE, *PCSLIST_NODE;

#define LIST_INLINE
#ifdef LIST_INLINE
#define LINLINE inline
#else
#define LINLINE
#endif

//
// Free function callback typedef.  This function will delete the memory saved
// as the data in a list node on list destruction
//
typedef VOID (*FreeFunc)(PVOID);

//
// This function returns TRUE if the two items are the same, or FALSE if they
// are not
//
typedef BOOL (*CompFunc)(PVOID, PVOID);

//+---------------------------------------------------------------------------
//
// Class:       CSList
//
// Synopsis:    Singly linked list class, single threaded
//
// Methods:     Insert
//              InsertIfUnique
//              Find
//              Reset
//              NextData
//              Remove
//              QueryCount
//
//----------------------------------------------------------------------------
class CSList
{
public:
                    CSList(FreeFunc pfnFree = NULL) :  _pfnFree (pfnFree),
                                                       _pCurrent (NULL),
                                                       _cItems (0)
                    {
                        _pHead = NULL;
                        _pTail = NULL;
                    };

    LINLINE        ~CSList();

    DWORD           QueryCount(void)         { return(_cItems);};

    VOID            Init(FreeFunc pfnFree = NULL)
                    {
                        if(_pHead == NULL)
                        {
                            _pfnFree = pfnFree;
                            _pCurrent = NULL;
                            _cItems = 0;
                        }
                    };

    LINLINE DWORD   Insert(PVOID    pvData);

    LINLINE DWORD   InsertIfUnique(PVOID    pvData,
                                   CompFunc pfnComp);

    LINLINE PVOID   Find(PVOID      pvData,
                         CompFunc   pfnComp);

    LINLINE PVOID   NextData();

    VOID            Reset() {_pCurrent = _pHead;};

    LINLINE DWORD   Remove(PVOID    pData);

    LINLINE VOID    FreeList(FreeFunc pfnFree);
protected:
    PCSLIST_NODE    _pHead;
    PCSLIST_NODE    _pCurrent;
    PCSLIST_NODE    _pTail;
    DWORD           _cItems;
    FreeFunc        _pfnFree;

    LINLINE PCSLIST_NODE FindNode(PVOID      pvData,
                                  CompFunc   pfnComp);

};



//+------------------------------------------------------------------
//
//  Member:     CSList::~CSList
//
//  Synopsis:   Destructor for the CSList class
//
//  Arguments:  None
//
//  Returns:    void
//
//+------------------------------------------------------------------
CSList::~CSList()
{
    while(_pHead != NULL)
    {
        PCSLIST_NODE pNext = _pHead->pNext;

        if(_pfnFree != NULL)
        {
            (*_pfnFree)(_pHead->pvData);
        }

        LocalFree(_pHead);

        _pHead = pNext;

    }
}




//+------------------------------------------------------------------
//
//  Member:     CSList::Insert
//
//  Synopsis:   Creates a new node at the begining of the list and
//              inserts it into the list
//
//
//  Arguments:  [IN pvData]         --      Data to insert
//
//  Returns:    ERROR_SUCCESS       --      Everything worked
//              ERROR_NOT_ENOUGH_MEMORY     A memory allocation failed
//
//+------------------------------------------------------------------
DWORD   CSList::Insert(PVOID    pvData)
{
    DWORD dwErr = ERROR_SUCCESS;

    PCSLIST_NODE    pNew = (PCSLIST_NODE)LocalAlloc(LMEM_FIXED, sizeof(CSLIST_NODE));
    if(pNew == NULL)
    {
        dwErr = ERROR_NOT_ENOUGH_MEMORY;
    }
    else
    {
        pNew->pvData = pvData;

        pNew->pNext = NULL;

        if ( _pHead == NULL ) {

            _pHead = _pTail = pNew;

        } else {

            _pTail->pNext = pNew;
            _pTail = pNew;
        }

        _cItems++;
    }

    return(dwErr);
}




//+------------------------------------------------------------------
//
//  Member:     CSList::InsertIfUnique
//
//  Synopsis:   Creates a new node at the begining of the list and
//              inserts it into the list if the data does not already
//              exist in the list.  If the data does exist, nothing
//              is done, but SUCCESS is returned
//
//
//  Arguments:  [IN pvData]         --      Data to insert
//
//  Returns:    ERROR_SUCCESS       --      Everything worked
//              ERROR_NOT_ENOUGH_MEMORY     A memory allocation failed
//
//+------------------------------------------------------------------
DWORD   CSList::InsertIfUnique(PVOID    pvData,
                               CompFunc pfnComp)
{
    DWORD   dwErr = ERROR_SUCCESS;

    if(FindNode(pvData, pfnComp) == NULL)
    {
        dwErr = Insert(pvData);
    }

    return(dwErr);
}




//+------------------------------------------------------------------
//
//  Member:     CSList::FindNode
//
//  Synopsis:   Locates the node for the given data in the list, if it exists
//
//  Arguments:  [IN pvData]         --      Data to find
//              [IN pfnComp]        --      Pointer to a comparrison function
//
//  Returns:    ERROR_SUCCESS       --      Everything worked
//              ERROR_NOT_ENOUGH_MEMORY     A memory allocation failed
//
//+------------------------------------------------------------------
PCSLIST_NODE   CSList::FindNode(PVOID      pvData,
                                CompFunc   pfnComp)
{
    PCSLIST_NODE pRet = _pHead;

    // for(ULONG i = 0; i < _cItems; i++)
    while (pRet != NULL)
    {
        if((pfnComp)(pvData, pRet->pvData) == TRUE)
        {
            break;
        }

        pRet = pRet->pNext;
    }

    return(pRet);
}



//+------------------------------------------------------------------
//
//  Member:     CSList::Find
//
//  Synopsis:   Locates the given data in the list, if it exists
//
//  Arguments:  [IN pvData]         --      Data to insert
//
//  Returns:    ERROR_SUCCESS       --      Everything worked
//              ERROR_NOT_ENOUGH_MEMORY     A memory allocation failed
//
//+------------------------------------------------------------------
PVOID   CSList::Find(PVOID      pvData,
                     CompFunc   pfnComp)
{
    PCSLIST_NODE pNode = FindNode(pvData, pfnComp);

    return(pNode == NULL ? NULL : pNode->pvData);
}





//+------------------------------------------------------------------
//
//  Member:     CSList::NextData
//
//  Synopsis:   Returns the next data in the list
//
//
//  Arguments:  None
//
//  Returns:    NULL            --      No more items
//              Pointer to next data in list on success
//
//+------------------------------------------------------------------
PVOID   CSList::NextData()
{
    PVOID   pvRet = NULL;
    if(_pCurrent != NULL)
    {
        pvRet = _pCurrent->pvData;
        _pCurrent = _pCurrent->pNext;
    }

    return(pvRet);
}




//+------------------------------------------------------------------
//
//  Member:     CSList::Remove
//
//  Synopsis:   Removes the node that references the indicated data
//
//  Arguments:  pData           --      The data in the node to remove
//
//  Returns:    ERROR_SUCCESS   --      Success
//              ERROR_INVALID_PARAMETER Node not found
//
//+------------------------------------------------------------------
DWORD   CSList::Remove(PVOID    pData)
{
    DWORD        dwErr = ERROR_INVALID_PARAMETER;
    PCSLIST_NODE pNode = _pHead, pPrev = NULL;

    for(ULONG i = 0; i  < _cItems; i++)
    {
        if(pNode->pvData == pData)
        {
            //
            // We've got a match...
            //
            if(pPrev == NULL)
            {
                _pHead = _pHead->pNext;
            }
            else
            {
                pPrev->pNext = pNode->pNext;
            }

            if (NULL == pNode->pNext)
            {
                _pTail = pPrev;
            }

            LocalFree(pNode);
            _cItems--;
            break;

        }

        pPrev = pNode;
        pNode = pNode->pNext;

    }

    return(dwErr);
}


//+------------------------------------------------------------------
//
//  Member:     CSList::FreeList
//
//  Synopsis:   Frees the list
//
//  Arguments:  pfnFree -- Optional deletion routine to use for freeing
//              any allocated memory
//
//  Returns:    void
//
//+------------------------------------------------------------------
VOID CSList::FreeList(FreeFunc pfnFree)
{
    while(_pHead != NULL)
    {
        PCSLIST_NODE pNext = _pHead->pNext;

        if(pfnFree != NULL)
        {
            (*pfnFree)(_pHead->pvData);
        }

        LocalFree(_pHead);

        _pHead = pNext;

    }
}



//
// Exported functions pointer definitions
//
typedef DWORD   (*pfNTMartaLookupTrustee) (PWSTR          pwszServer,
                                           PSID        pSid,
                                           PTRUSTEE   *ppTrustee);

typedef DWORD   (*pfNTMartaLookupName)     (PWSTR          pwszServer,
                                            PSID           pSid,
                                            LPWSTR        *ppwszName,
                                            LPWSTR        *ppwszDomain,
                                            SID_NAME_USE  *pSidType);

typedef DWORD   (*pfNTMartaLookupSid)  (PWSTR          pwszServer,
                                        PTRUSTEE        pName,
                                        PSID           *ppsid,
                                        SID_NAME_USE   *pSidType);

typedef DWORD   (*pfNTMartaSetAList) (ULONG                 cEntries,
                                      PACTRL_ACCESS_ENTRYW  pAccessEntryList,
                                      ACCESS_MODE           AccessMode,
                                      SECURITY_INFORMATION  SeInfo,
                                      LPCWSTR               lpProperty,
                                      BOOL                  fDoOldStyleMerge,
                                      PACTRL_AUDITW         pOldList,
                                      PACTRL_AUDITW        *ppNewList);

typedef DWORD   (*pfNTMartaAToSD) (PACTRL_ACCESSW        pAccessList,
                                   PACTRL_AUDITW         pAuditList,
                                   LPCWSTR               lpOwner,
                                   LPCWSTR               lpGroup,
                                   PSECURITY_DESCRIPTOR *ppSecDescriptor);


typedef DWORD   (*pfNTMartaSDToA) (SE_OBJECT_TYPE       ObjectType,
                                   PSECURITY_DESCRIPTOR pSecDescriptor,
                                   PACTRL_ACCESSW      *ppAccessList,
                                   PACTRL_AUDITW       *ppAuditList,
                                   LPWSTR              *lppOwner,
                                   LPWSTR              *lppGroup);

typedef DWORD   (*pfNTMartaAclToA)(SE_OBJECT_TYPE       ObjectType,
                                   PACL                 pAcl,
                                   PACTRL_ACCESSW      *ppAccessList);


typedef DWORD   (*pfNTMartaGetAccess) (PTRUSTEE                 pTrustee,
                                       PACL                     pAcl,
                                       SECURITY_INFORMATION     SeInfo,
                                       PWSTR                    pwszProperty,
                                       PACCESS_RIGHTS           pAllowed,
                                       PACCESS_RIGHTS           pDenied);

typedef DWORD   (*pfNTMartaGetExplicit)(PTRUSTEE              pTrustee,
                                        SE_OBJECT_TYPE        ObjectType,
                                        PACL                  pAcl,
                                        PWSTR                 pwszProperty,
                                        PULONG                pcEntries,
                                        PACTRL_ACCESS_ENTRYW *ppAEList);
typedef VOID (*FN_PROGRESS) (
    IN LPWSTR                   pObjectName,    // name of object just processed
    IN DWORD                    Status,         // status of operation on object
    IN OUT PPROG_INVOKE_SETTING pInvokeSetting, // Never, always,
    IN PVOID                    Args,           // Caller specific data
    IN BOOL                     SecuritySet     // Whether security was set
    );

typedef DWORD   (*pfNTMartaTreeResetNamedSecurityInfo) (
    IN LPWSTR               pObjectName,
    IN SE_OBJECT_TYPE       ObjectType,
    IN SECURITY_INFORMATION SecurityInfo,
    IN PSID                 pOwner,
    IN PSID                 pGroup,
    IN PACL                 pDacl,
    IN PACL                 pSacl,
    IN BOOL                 KeepExplicit,
    IN FN_PROGRESS          fnProgress,
    IN PROG_INVOKE_SETTING  ProgressInvokeSetting,
    IN PVOID                Args
    );

// typedef PVOID PFN_OBJECT_MGR_FUNCTS;

typedef DWORD   (*pfNTMartaGetInheritanceSource) (
    IN  LPWSTR                   pObjectName,
    IN  SE_OBJECT_TYPE           ObjectType,
    IN  SECURITY_INFORMATION     SecurityInfo,
    IN  BOOL                     Container,
    IN  GUID                  ** pObjectClassGuids OPTIONAL,
    IN  DWORD                    GuidCount,
    IN  PACL                     pAcl,
    IN  PGENERIC_MAPPING         pGenericMapping,
    IN  PFN_OBJECT_MGR_FUNCTS    pfnArray OPTIONAL,
    OUT PINHERITED_FROMW         pInheritArray
    );

typedef DWORD (*PFN_FREE) (IN PVOID Mem);

typedef DWORD   (*pfNTMartaFreeIndexArray) (
    IN OUT PINHERITED_FROMW pInheritArray,
    IN USHORT AceCnt,
    IN PFN_FREE pfnFree OPTIONAL
    );
    
typedef DWORD   (*pfNTMartaGetNamedRights) (
    IN  LPWSTR                 pObjectName,
    IN  SE_OBJECT_TYPE         ObjectType,
    IN  SECURITY_INFORMATION   SecurityInfo,
    OUT PSID                 * ppSidOwner,
    OUT PSID                 * ppSidGroup,
    OUT PACL                 * ppDacl,
    OUT PACL                 * ppSacl,
    OUT PSECURITY_DESCRIPTOR * ppSecurityDescriptor);

typedef DWORD   (*pfNTMartaSetNamedRights) (
    IN LPWSTR               pObjectName,
    IN SE_OBJECT_TYPE       ObjectType,
    IN SECURITY_INFORMATION SecurityInfo,
    IN PSECURITY_DESCRIPTOR pSecurityDescriptor,
    IN BOOL                 bSkipInheritanceComputation
    );

typedef DWORD   (*pfNTMartaGetHandleRights) (
    IN  HANDLE                 Handle,
    IN  SE_OBJECT_TYPE         ObjectType,
    IN  SECURITY_INFORMATION   SecurityInfo,
    OUT PSID                 * ppSidOwner,
    OUT PSID                 * ppSidGroup,
    OUT PACL                 * ppDacl,
    OUT PACL                 * ppSacl,
    OUT PSECURITY_DESCRIPTOR * ppSecurityDescriptor);

typedef DWORD   (*pfNTMartaSetHandleRights) (
    IN HANDLE               Handle,
    IN SE_OBJECT_TYPE       ObjectType,
    IN SECURITY_INFORMATION SecurityInfo,
    IN PSECURITY_DESCRIPTOR pSecurityDescriptor
    );

typedef DWORD   (*pfNTMartaSetEntriesInAcl) (
    IN  ULONG                cCountOfExplicitEntries,
    IN  PEXPLICIT_ACCESS_W   pListOfExplicitEntries,
    IN  PACL                 OldAcl,
    OUT PACL               * pNewAcl
    );

typedef DWORD   (*pfNTMartaGetExplicitEntriesFromAcl) (
    IN  PACL                  pacl,
    OUT PULONG                pcCountOfExplicitEntries,
    OUT PEXPLICIT_ACCESS_W  * pListOfExplicitEntries
    );

#endif // ifdef __MARTAEXP_HXX__
=== C:/Users/treeman/Desktop/windows nt source code\Source\Win2K3\NT\public\internal\ds\inc\netdebug.h ===
/*++

Copyright (c) 1991-1993  Microsoft Corporation

Module Name:

    NetDebug.h

Abstract:

    This header file declares various debug routines for use in the
    networking code.

Author:

    John Rogers (JohnRo) 11-Mar-1991

Environment:

    ifdef'ed for NT, any ANSI C environment, or none of the above (which
    implies nondebug).  The interface is portable (Win/32).
    Requires ANSI C extensions: slash-slash comments, long external names.

Revision History:

    11-Mar-1991 JohnRo
        Created.
    25-Mar-1991 JohnRo
        Added more FORMAT_ strings.  Got rid of tabs in file.
    28-Mar-1991 JohnRo
        Added FORMAT_HEX_ strings.
    08-Apr-1991 JohnRo
        Added temporary versions of wide char stuff (FORMAT_LPTSTR, etc).
    16-Apr-1991 JohnRo
        Added PC-LINT version of NetpAssert(), to avoid occasional constant
        Boolean value messages.  Added wrappers for NT debug code, to avoid
        recompile hits from <nt.h> all over the place.
    25-Apr-1991 JohnRo
        Created procedure version of NetpDbgHexDump().
    13-May-1991 JohnRo
        Added FORMAT_LPVOID to replace FORMAT_POINTER.  Changed nondebug
        definition of NetpDbgHexDump() to avoid evaluating parameters.
    15-May-1991 JohnRo
        FORMAT_HEX_WORD was wrong.
    19-May-1991 JohnRo
        Improve LINT handling of assertions.
    21-May-1991 JohnRo
        Added NetpDbgReasonable() for partial hex dumps.
    13-Jun-1991 JohnRo
        Added NetpDbgDisplay routines.
        Moved DBGSTATIC here from <Rxp.h>.
    02-Jul-1991 JohnRo
        Added display routines for print job, print queue, and print dest.
    05-Jul-1991 JohnRo
        Avoid FORMAT_WORD name (used by MIPS header files).
    22-Jul-1991 JohnRo
        Implement downlevel NetConnectionEnum.
    25-Jul-1991 JohnRo
        Wksta debug support.
    03-Aug-1991 JohnRo
        Rename wksta display routine for consistency.
    20-Aug-1991 JohnRo
        Allow use in nondebug builds.
    20-Aug-1991 JohnRo
        Downlevel NetFile APIs.
    11-Sep-1991 JohnRo
        Downlevel NetService APIs.  Added UNICODE versions of some FORMAT_
        equates.  Added FORMAT_ULONG for NT use.
    13-Sep-1991 JohnRo
        Change "reasonable" debug amount to be an even number of lines.
        Create an equate for it.  Added LPDEBUG_STRING and a FORMAT_ for that.
    15-Oct-1991 JohnRo
        Implement remote NetSession APIs.
    11-Nov-1991 JohnRo
        Implement remote NetWkstaUserEnum().  Added FORMAT_RPC_STATUS.
    26-Dec-1991 JohnRo
        Added stuff for replicator APIs.
    07-Jan-1992 JohnRo
        Added NetpDbgDisplayWStr() for UNICODE strings.
        Added NetpDbgDisplayTStr() to be consistent.
    26-Feb-1992 JohnRo
        Added NetpDbgDisplayTimestamp() (seconds since 1970).
    15-Apr-1992 JohnRo
        Moved FORMAT_ equates into /nt/private/inc/debugfmt.h (so they
        can be used by the service controller as well).
    13-Jun-1992 JohnRo
        RAID 10324: net print vs. UNICODE.
    16-Aug-1992 JohnRo
        RAID 2920: Support UTC timezone in net code.
    24-Aug-1992 JohnRo
        Fixed free build again (misnamed repl import/export display macros).
    02-Oct-1992 JohnRo
        RAID 3556: DosPrintQGetInfo (from downlevel) level=3 rc=124.
        (Added NetpDbgDisplayPrintQArray.)
    05-Jan-1993 JohnRo
        Repl WAN support (get rid of repl name list limits).
        Made changes suggested by PC-LINT 5.0
    04-Mar-1993 JohnRo
        RAID 12237: replicator tree depth exceeded (add display of FILETIME
        and LARGE_INTEGER time).
    31-Mar-1993 JohnRo
        Allow others to display replicator state too.

--*/

#ifndef _NETDEBUG_
#define _NETDEBUG_

// These must be included first:
#include <windef.h>             // BOOL, DWORD, FALSE, LPBYTE, etc.

// These may be included in any order:
#include <debugfmt.h>           // Most FORMAT_ equates.
#include <stdarg.h>

#if DBG

// Normal netlib debug version.  No extra includes.

#else // not DBG

#ifdef CDEBUG

// ANSI C debug version.
#include <assert.h>             // assert().
#include <stdio.h>              // printf().

#else // ndef CDEBUG

// Nondebug version.

#endif // ndef CDEBUG

#endif // not DBG


#if !DBG || defined(lint) || defined(_lint)
#define DBGSTATIC static        // hidden function
#else
#define DBGSTATIC               // visible for use in debugger.
#endif


//
// printf-style format strings for some possibly nonportable stuff...
// These are passed to NetpDbgPrint(); use with other routines at your
// own risk.
//
// Most FORMAT_ equates now reside in /nt/private/inc/debugfmt.h.
//

typedef LPSTR LPDEBUG_STRING;

#define FORMAT_API_STATUS       "%lu"
#define FORMAT_LPDEBUG_STRING   "%s"

#ifdef __cplusplus
extern "C" {
#endif


// NetpAssert: continue if Predicate is true; otherwise print debug message
// (if possible) and hit a breakpoint (if possible).  Do nothing at all if
// this is a nondebug build.
//
// VOID
// NetpAssert(
//     IN BOOL Predicate
//     );
//

#if DBG

VOID
NetpAssertFailed(
    IN LPDEBUG_STRING FailedAssertion,
    IN LPDEBUG_STRING FileName,
    IN DWORD LineNumber,
    IN LPDEBUG_STRING Message OPTIONAL
    );

// Normal networking debug version.
#define NetpAssert(Predicate) \
    { \
        /*lint -save -e506 */  /* don't complain about constant values here */ \
        if (!(Predicate)) \
            NetpAssertFailed( #Predicate, __FILE__, __LINE__, NULL ); \
        /*lint -restore */ \
    }

#else // not DBG

#ifdef CDEBUG

// ANSI C debug version.
#define NetpAssert(Predicate)   assert(Predicate)

#else // ndef CDEBUG

// Nondebug version.
#define NetpAssert(Predicate)   /* no output; ignore arguments */

#endif // ndef CDEBUG

#endif // not DBG


// NetpBreakPoint: if this is a debug version of some sort, cause a breakpoint
// somehow.  (This may just be an assertion failure in ANSI C.)  Do nothing at
// all in nondebug builds.
//
// VOID
// NetpBreakPoint(
//     VOID
//     );
//

#if DBG

// NT debug version.  Calls DbgBreakPoint.
VOID
NetpBreakPoint(
    VOID
    );

#else // not DBG

#ifdef CDEBUG

// ANSI C debug version.
#define NetpBreakPoint          NetpAssert(FALSE)

#else // ndef CDEBUG

// Nondebug version.
#define NetpBreakPoint()          /* no effect. */

#endif // ndef CDEBUG

#endif // not DBG


#if DBG
VOID
NetpDbgDisplayDword(
    IN LPDEBUG_STRING Tag,
    IN DWORD Value
    );

VOID
NetpDbgDisplayLong(
    IN LPDEBUG_STRING Tag,
    IN LONG Value
    );

VOID
NetpDbgDisplayString(
    IN LPDEBUG_STRING Tag,
    IN LPTSTR Value
    );

VOID
NetpDbgDisplayTag(
    IN LPDEBUG_STRING Tag
    );

VOID
NetpDbgDisplayTimestamp(
    IN LPDEBUG_STRING Tag,
    IN DWORD Time               // Seconds since 1970.
    );

VOID
NetpDbgDisplayTod(
    IN LPDEBUG_STRING Tag,
    IN LPVOID TimePtr           // LPTIME_OF_DAY_INFO.
    );

#else // not DBG

#define NetpDbgDisplayDword(Tag,Value)        /* nothing */
#define NetpDbgDisplayLong(Tag,Value)         /* nothing */
#define NetpDbgDisplayString(Tag,Value)       /* nothing */
#define NetpDbgDisplayTimestamp(Tag,Time)     /* nothing */
#define NetpDbgDisplayTag(Tag)                /* nothing */
#define NetpDbgDisplayTod(Tag,Tod)            /* nothing */

#endif // not DBG

//
//  NetpKdPrint() & NetpDbgPrint() are net equivalents of
//  KdPrint()     & DbgPrint().  Suggested usage:
//
//  NetpKdPrint() & KdPrint()   -   OK
//  NetpDbgPrint()              -   so,so; produces warnings in the free build
//  DbgPrint                    -   bad
//

#if DBG

#define NetpKdPrint(_x_) NetpDbgPrint _x_

VOID
NetpDbgPrint(
    IN LPDEBUG_STRING FORMATSTRING,     // PRINTF()-STYLE FORMAT STRING.
    ...                                 // OTHER ARGUMENTS ARE POSSIBLE.
    );

VOID
NetpHexDump(
    LPBYTE Buffer,
    DWORD BufferSize
    );

#else // not DBG

#ifdef CDEBUG

//  ANSI C debug version.

#define NetpKdPrint(_x_)        NetpDbgPrint _x_
#define NetpDbgPrint            (void) printf

#else // ndef CDEBUG

//  Nondebug version.  Note that NetpKdPrint() eliminates all its
//  arguments.

#define NetpKdPrint(_x_)

#endif // ndef CDEBUG
#endif // not DBG


// NetpDbgHexDump: do a hex dump of some number of bytes to the debug
// terminal or whatever.  This is a no-op in a nondebug build.

#if DBG || defined(CDEBUG)

VOID
NetpDbgHexDump(
    IN LPBYTE StartAddr,
    IN DWORD Length
    );

#else

#define NetpDbgHexDump(StartAddr,Length)     // no output; ignore arguments

#endif

//
// Define a number of bytes to dump for partial dumps.  Each line dumps
// 16 bytes, so do an even number of lines.
//
#define REASONABLE_DUMP_SIZE  (6*16)

// NetpDbgReasonable: pick a number for partial hex dumps.
//
// DWORD
// NetpDbgReasonable(
//     IN DWORD MaxSize
//     );
#define NetpDbgReasonable(MaxSize) \
    /*lint -save -e506 */  /* don't complain about constant values here */ \
    ( ((MaxSize) < REASONABLE_DUMP_SIZE) ? (MaxSize) : REASONABLE_DUMP_SIZE ) \
    /*lint -restore */

#ifdef __cplusplus
}
#endif

//
// Generic log managment funtions.  Present in debug and free builds.
// All logs are relative to %WINDIR%\\debug\\.  DebugLog will automatically
// have a .LOG appended
//

VOID
NetpInitializeLogFile(
    VOID
    );

VOID
NetpShutdownLogFile(
    VOID
    );

HANDLE
NetpOpenDebugFile(
    IN LPWSTR DebugLog
    );

VOID
NetpCloseDebugFile(
    IN HANDLE LogHandle
    );

//
// The following functions are used by NetJoin
//  to facilitate the logging per tasks it performs.
//

void
NetSetuppOpenLog();

void
NetSetuppCloseLog();

void
NetpLogPrintHelper(
    IN LPCSTR Format,
    ...);

#endif // ndef _NETDEBUG_
=== C:/Users/treeman/Desktop/windows nt source code\Source\Win2K3\NT\public\internal\ds\inc\netlibnt.h ===
/*++

Copyright (c) 1991-92  Microsoft Corporation

Module Name:

    NetLibNT.h

Abstract:

    This header file declares various common routines for use in the
    NT networking code.

Author:

    John Rogers (JohnRo) 02-Apr-1991

Environment:

    Only runs under NT; has an NT-specific interface (with Win32 types).
    Requires ANSI C extensions: slash-slash comments, long external names.

Notes:

    You must include <nt.h> and <lmcons.h> before this file.

Revision History:

    02-Apr-1991 JohnRo
        Created.
    16-Apr-1991 JohnRo
        Avoid conflicts with MIDL-generated files.
    06-May-1991 JohnRo
        Implement UNICODE.  Avoid NET_API_FUNCTION for non-APIs.
    06-Sep-1991 CliffV
        Added NetpApiStatusToNtStatus.
    27-Nov-1991 JohnRo
        Added NetpAllocTStrFromString() for local NetConfig APIs.
    03-Jan-1992 JohnRo
        Added NetpCopyStringToTStr() for FAKE_PER_PROCESS_RW_CONFIG handling.
    13-Mar-1992 JohnRo
        Added NetpAllocStringFromTStr() for NetpGetDomainId().
    22-Sep-1992 JohnRo
        RAID 6739: Browser too slow when not logged into browsed domain.
    01-Dec-1992 JohnRo
        RAID 3844: remote NetReplSetInfo uses local machine type.  (Added
        NetpGetProductType and NetpIsProductTypeValid.)
    13-Feb-1995 FloydR
        Deleted NetpAllocStringFromTStr() - unused

--*/

#ifndef _NETLIBNT_
#define _NETLIBNT_

#ifdef __cplusplus
extern "C" {
#endif

NET_API_STATUS
NetpNtStatusToApiStatus(
    IN NTSTATUS NtStatus
    );

NTSTATUS
NetpApiStatusToNtStatus(
    NET_API_STATUS NetStatus
    );

NET_API_STATUS
NetpRdrFsControlTree(
    IN LPTSTR TreeName,
    IN LPTSTR TransportName OPTIONAL,
    IN ULONG ConnectionType,
    IN DWORD FsControlCode,
    IN LPVOID SecurityDescriptor OPTIONAL,
    IN LPVOID InputBuffer OPTIONAL,
    IN DWORD InputBufferSize,
    OUT LPVOID OutputBuffer OPTIONAL,
    IN DWORD OutputBufferSize,
    IN BOOL NoPermissionRequired
    );

#ifdef __cplusplus
}
#endif

#endif // ndef _NETLIBNT_
=== C:/Users/treeman/Desktop/windows nt source code\Source\Win2K3\NT\public\internal\ds\inc\netlogon.h ===
/*++

Copyright (c) 1987-1991  Microsoft Corporation

Module Name:

    netlogon.h

Abstract:

    Definition of mailslot messages and Internal APIs to the Netlogon service.

    This file is shared by the Netlogon service, the Workstation service,
    the XACT server, and the MSV1_0 authentication package.

Author:

    Cliff Van Dyke (cliffv) 16-May-1991

Environment:

    User mode only.
    Contains NT-specific code.
    Requires ANSI C extensions: slash-slash comments, long external names.

Revision History:

    16-May-1991 (cliffv)
        Ported from LanMan 2.1.

    02-Jan-1992 (madana)
        added support for builtin/multidomain replication.

--*/

#ifndef _NETLOGON_H_
#define _NETLOGON_H_

#include <smbtypes.h>    // need by smbgtpt.h
#include <smbgtpt.h>    // SmbPutUlong

//
// define version bit
//
// All netlogon messages that are compatible to NT VERSION 1 will
// have the following bit set in the version field of the message
// otherwise the message will not be processed by this version
// of software. In addition to this the message should carry NT
// token in it.
//

#define NETLOGON_NT_VERSION_1   0x00000001

//
// Starting in NT 5.0, some messages became more DS/DNS aware.  Those
//  messages additionally have the following bits set to indicate the
//  presence of the additional fields.

#define NETLOGON_NT_VERSION_5   0x00000002

//
// Starting in NT 5.0, some client can handle the _EX version of
// logon responses.

#define NETLOGON_NT_VERSION_5EX 0x00000004

//
// 5EX responses in mailslot messages will also include the IP address of
//  the responding DC.
//

#define NETLOGON_NT_VERSION_5EX_WITH_IP 0x00000008

//
// Set on Logon requests to indicate caller is querying for a PDC.
#define NETLOGON_NT_VERSION_PDC     0x10000000

//
// Set on Logon requests to indicate caller is querying for a DC running IP
#define NETLOGON_NT_VERSION_IP      0x20000000

//
// Set on Logon requests to indicate caller is local machine
#define NETLOGON_NT_VERSION_LOCAL   0x40000000

//
// Set on Logon requests to indicate caller is querying for a GC.
#define NETLOGON_NT_VERSION_GC      0x80000000

//
// Set on Logon requests to indicate caller wants to avoid NT4.0 emulation.
#define NETLOGON_NT_VERSION_AVOID_NT4EMUL  0x01000000

//
//

//
// Name of the mailslot the Netlogon service listens to.
//

#define NETLOGON_LM_MAILSLOT_W      L"\\MAILSLOT\\NET\\NETLOGON"
#define NETLOGON_LM_MAILSLOT_A      "\\MAILSLOT\\NET\\NETLOGON"
#define NETLOGON_LM_MAILSLOT_LEN    22  // Length in characters (w/o NULL)

#define NETLOGON_NT_MAILSLOT_W      L"\\MAILSLOT\\NET\\NTLOGON"
#define NETLOGON_NT_MAILSLOT_A      "\\MAILSLOT\\NET\\NTLOGON"
#define NETLOGON_NT_MAILSLOT_LEN    21 // Length in characters (w/o NULL)

//
// Opcodes for netlogon mailslot data
//

#define LOGON_REQUEST               0   // LM1.0/2.0 LOGON Request from client
#define LOGON_RESPONSE              1   // LM1.0 Response to LOGON_REQUEST
#define LOGON_CENTRAL_QUERY         2   // LM1.0 QUERY for centralized init
#define LOGON_DISTRIB_QUERY         3   // LM1.0 QUERY for non-centralized init
#define LOGON_CENTRAL_RESPONSE      4   // LM1.0 response to LOGON_CENTRAL_QUERY
#define LOGON_DISTRIB_RESPONSE      5   // LM1.0 resp to LOGON_DISTRIB_QUERY
#define LOGON_RESPONSE2             6   // LM2.0 Response to LOGON_REQUEST
#define LOGON_PRIMARY_QUERY         7   // QUERY for Primary DC
#define LOGON_START_PRIMARY         8   // announce startup of Primary DC
#define LOGON_FAIL_PRIMARY          9   // announce failed  Primary DC
#define LOGON_UAS_CHANGE            10  // announce change to UAS or SAM
#define LOGON_NO_USER               11  // announce no user on machine
#define LOGON_PRIMARY_RESPONSE      12  // response to LOGON_PRIMARY_QUERY
#define LOGON_RELOGON_RESPONSE      13  // LM1.0/2.0 resp to relogn request
#define LOGON_WKSTINFO_RESPONSE     14  // LM1.0/2.0 resp to interrogate request
#define LOGON_PAUSE_RESPONSE        15  // LM2.0 resp when NETLOGON is paused
#define LOGON_USER_UNKNOWN          16  // LM2.0 response when user is unknown
#define LOGON_UPDATE_ACCOUNT        17  // LM2.1 announce account updates

#define LOGON_SAM_LOGON_REQUEST     18  // SAM LOGON request from client
#define LOGON_SAM_LOGON_RESPONSE    19  // SAM Response to SAM logon request
#define LOGON_SAM_PAUSE_RESPONSE    20  // SAM response when NETLOGON is paused
#define LOGON_SAM_USER_UNKNOWN      21  // SAM response when user is unknown

#define LOGON_SAM_LOGON_RESPONSE_EX 23  // SAM Response to SAM logon request
#define LOGON_SAM_PAUSE_RESPONSE_EX 24  // SAM response when NETLOGON is paused
#define LOGON_SAM_USER_UNKNOWN_EX   25  // SAM response when user is unknown


//
// These structures are defined for their maximum case.  In many instances,
// the strings are packed immediately following one another.  In that case
// the comments below indicate that the offset of certain fields should
// not be used.
//

//
// NETLOGON_LOGON_QUERY:
//
// This structure is used for the following Opcodes:
//      LOGON_PRIMARY_QUERY,    (all LanMan versions)
//      LOGON_CENTRAL_QUERY,        (LM 1.0 only)
//      LOGON_CENTRAL_RESPONSE,     (LM 1.0 only)
//      LOGON_DISTRIB_QUERY,        (LM 1.0 only)
//      LOGON_DISTRIB_RESPONSE.     (LM 1.0 only)
//
//

typedef struct _NETLOGON_LOGON_QUERY {
    USHORT Opcode;
    CHAR ComputerName[LM20_CNLEN+1];        // This field is always ASCII.

    CHAR MailslotName[LM20_PATHLEN];        // Do not use offset of this field

                                            //
                                            // This field is always ASCII.
                                            //

    CHAR Pad;                               // Possible pad to WCHAR boundary
    WCHAR UnicodeComputerName[CNLEN+1];     // Do not use offset of this field

                                            //
                                            // This field is only present if
                                            // this is a LOGON_PRIMARY_QUERY
                                            // from an NT system.
                                            //


    _ULONG (NtVersion);                     // Do not use offset of this field
    _USHORT (LmNtToken);                    // Do not use offset of this field
    _USHORT (Lm20Token);                    // Do not use offset of this field
} NETLOGON_LOGON_QUERY, * PNETLOGON_LOGON_QUERY;



//
// NETLOGON_LOGON_REQUEST
//
// This structure is used for the following Opcodes:
//      LOGON_REQUEST    (LM 1.0 and LM 2.0 Only)
//

typedef struct _NETLOGON_LOGON_REQUEST {
    USHORT Opcode;
    CHAR ComputerName[LM20_CNLEN+1];
    CHAR UserName[LM20_UNLEN+1];            // Do not use offset of this field

    CHAR MailslotName[LM20_PATHLEN+1];      // Do not use offset of this field

                                            //
                                            // This field is always ASCII.
                                            //

    _USHORT (RequestCount);                 // Do not use offset of this field
    _USHORT (Lm20Token);                    // Do not use offset of this field
} NETLOGON_LOGON_REQUEST, * PNETLOGON_LOGON_REQUEST;



//
// NETLOGON_LOGON_RESPONSE:
//
// This structure is used for the following Opcodes:
//      LOGON_RESPONSE (To LM 1.0 clients only).
//

typedef struct _NETLOGON_LOGON_RESPONSE {
    USHORT Opcode;
    CHAR UseName[2 + LM20_CNLEN + 1 + LM20_NNLEN +1];
    CHAR ScriptName[(2*LM20_PATHLEN) + LM20_UNLEN + LM20_CNLEN + LM20_NNLEN + 8];       // Do not use offset of this field
} NETLOGON_LOGON_RESPONSE, *PNETLOGON_LOGON_RESPONSE;


//
// NETLOGON_PRIMARY
//
// This structure is used for the following Opcodes:
//      LOGON_START_PRIMARY
//      LOGON_PRIMARY_RESPONSE
//

typedef struct _NETLOGON_PRIMARY {
    USHORT Opcode;
    CHAR PrimaryDCName[LM20_CNLEN + 1];     // This field is always ASCII.

    //
    // The following fields are only present if this message is from
    // an NT system.
    //

    CHAR Pad;                               // Possible pad to WCHAR boundary
    WCHAR UnicodePrimaryDCName[CNLEN+1];    // Do not use offset of this field
    WCHAR UnicodeDomainName[DNLEN+1];       // Do not use offset of this field

    _ULONG (NtVersion);                     // Do not use offset of this field
    _USHORT (LmNtToken);                    // Do not use offset of this field
    _USHORT (Lm20Token);                    // Do not use offset of this field
} NETLOGON_PRIMARY, * PNETLOGON_PRIMARY;


//
// NETLOGON_FAIL_PRIMARY
//
// This structure is used for the following Opcodes:
//      LOGON_FAIL_PRIMARY       (All LanMan versions)
//

typedef struct _NETLOGON_FAIL_PRIMARY {
    USHORT  Opcode;

    _ULONG (NtVersion);                     // Do not use offset of this field
    _USHORT (LmNtToken);                    // Do not use offset of this field
    _USHORT (Lm20Token);                    // Do not use offset of this field
} NETLOGON_FAIL_PRIMARY, *PNETLOGON_FAIL_PRIMARY;


//
// NETLOGON_LOGON_RESPONSE2
//
// This structure is used for the following Opcodes:
//      LOGON_RESPONSE2         (LM 2.0 only)
//      LOGON_USER_UNKNOWN      (LM 2.0 only)
//      LOGON_PAUSE_RESPONSE    (LM 2.0 only)
//

typedef struct _NETLOGON_LOGON_RESPONSE2 {
    USHORT Opcode;
    CHAR LogonServer[LM20_UNCLEN+1];
    _USHORT (Lm20Token);                    // Do not use offset of this field
} NETLOGON_LOGON_RESPONSE2, *PNETLOGON_LOGON_RESPONSE2;


//
// The following structures are densely packed to be compatible with LM2.0.
//  Poorly aligned fields should only be accessed using the SmbPut and SmbGet
//  family of macros.
//

//
// Force misalignment of the following structures
//

#ifndef NO_PACKING
#include <packon.h>
#endif // ndef NO_PACKING

//
// NETLOGON_UAS_CHANGE
//
// This structure is used for the following Opcodes:
//      LOGON_UAS_CHANGE
//

//
// DB_CHANGE_INFO structure contains per database change info.
//

typedef struct _DB_CHANGE_INFO {
    DWORD           DBIndex;
    LARGE_INTEGER   LargeSerialNumber;
    LARGE_INTEGER   NtDateAndTime;
} DB_CHANGE_INFO, *PDB_CHANGE_INFO;


//
// NETLOGON_DB_STRUCTURE contains common change info for all databases and
//  array of per database change info. First half of this structure is
//  identical to downlevel NETLOGON_UAS_CHANGE message and contains SAM
//  database change info.
//

typedef struct _NETLOGON_DB_CHANGE {
    USHORT  Opcode;
    _ULONG  (LowSerialNumber);
    _ULONG  (DateAndTime);
    _ULONG  (Pulse);
    _ULONG  (Random);
    CHAR    PrimaryDCName[LM20_CNLEN + 1];
    CHAR    DomainName[LM20_DNLEN + 1];     // Do not use offset of this field

    //
    // The following fields are only present if this message is from
    // an NT system.
    //

    CHAR Pad;                               // Possible pad to WCHAR boundary
    WCHAR   UnicodePrimaryDCName[CNLEN+1];  // Do not use offset of this field
    WCHAR   UnicodeDomainName[DNLEN+1];     // Do not use offset of this field
    DWORD   DBCount;                        // Do not use offset of this field
    DB_CHANGE_INFO DBChangeInfo[1];         // Do not use offset of this field
    DWORD   DomainSidSize;                  // Do not use offset of this field
    CHAR    DomainSid[1];                   // Do not use offset of this field
    _ULONG (NtVersion);                     // Do not use offset of this field
    _USHORT (LmNtToken);                    // Do not use offset of this field
    _USHORT (Lm20Token);                    // Do not use offset of this field
} NETLOGON_DB_CHANGE, *PNETLOGON_DB_CHANGE;



//
// Turn structure packing back off
//

#ifndef NO_PACKING
#include <packoff.h>
#endif // ndef NO_PACKING



//
// NETLOGON_SAM_LOGON_REQUEST
//
// This structure is used for the following Opcodes:
//      LOGON_SAM_LOGON_REQUEST  (SAM Only)
//
// This message exceeds the maximum size for broadcast mailslot messages.  In
// practice, this will only be a problem if the UnicodeUserName is over 100
// characters long.
//

typedef struct _NETLOGON_SAM_LOGON_REQUEST {
    USHORT Opcode;
    USHORT RequestCount;

    WCHAR UnicodeComputerName[CNLEN+1];
    WCHAR UnicodeUserName[((64>LM20_UNLEN)?64:LM20_UNLEN)+1]; // Do not use offset of this field
                                            // Note: UNLEN is way too large since
                                            // it makes the message larger than
                                            // 512 bytes.

    CHAR MailslotName[LM20_PATHLEN+1];      // Do not use offset of this field
                                            // This field is always ASCII.
    _ULONG (AllowableAccountControlBits);   // Do not use offset of this field
    DWORD   DomainSidSize;                  // Do not use offset of this field
    CHAR DomainSid[1];                      // Do not use offset of this field


    _ULONG (NtVersion);                     // Do not use offset of this field
    _USHORT (LmNtToken);                    // Do not use offset of this field

    _USHORT (Lm20Token);                    // Do not use offset of this field
} NETLOGON_SAM_LOGON_REQUEST, * PNETLOGON_SAM_LOGON_REQUEST;



//
// NETLOGON_SAM_LOGON_RESPONSE
//
// This structure is used for the following Opcodes:
//      LOGON_SAM_LOGON_RESPONSE    (SAM only)
//      LOGON_SAM_USER_UNKNOWN      (SAM only)
//      LOGON_SAM_PAUSE_RESPONSE    (SAM only)
//

typedef struct _NETLOGON_SAM_LOGON_RESPONSE {
    USHORT Opcode;
    WCHAR UnicodeLogonServer[UNCLEN+1];
    WCHAR UnicodeUserName[((64>LM20_UNLEN)?64:LM20_UNLEN)+1];         // Do not use offset of this field
                                            // Note: UNLEN is way too large since
                                            // it makes the message larger than
                                            // 512 bytes.
    WCHAR UnicodeDomainName[DNLEN+1];       // Do not use offset of this field

    // The following fields are only present for NETLOGON_NT_VERSION_5
    GUID DomainGuid;                        // Do not use offset of this field
    GUID SiteGuid;                          // Do not use offset of this field

    CHAR DnsForestName[256];                  // Do not use offset of this field
                                            // This field counted UTF-8

    CHAR DnsDomainName[sizeof(WORD)];       // Do not use offset of this field
                                            // This field counted UTF-8
                                            // This field compressed ala RFC 1035

    CHAR DnsHostName[sizeof(WORD)];         // Do not use offset of this field
                                            // This field counted UTF-8
                                            // This field compressed ala RFC 1035

    _ULONG (DcIpAddress);                   // Do not use offset of this field
                                            // Host byte order
    _ULONG (Flags);                         // Do not use offset of this field
    // The previous fields are only present for NETLOGON_NT_VERSION_5

    _ULONG (NtVersion);                     // Do not use offset of this field
    _USHORT (LmNtToken);                    // Do not use offset of this field
    _USHORT (Lm20Token);                    // Do not use offset of this field
} NETLOGON_SAM_LOGON_RESPONSE, *PNETLOGON_SAM_LOGON_RESPONSE;



//
// NETLOGON_SAM_LOGON_RESPONSE_EX
//
// This structure is used for the following Opcodes:
//      LOGON_SAM_LOGON_RESPONSE_EX    (SAM only)
//      LOGON_SAM_USER_UNKNOWN_EX      (SAM only)
//      LOGON_SAM_PAUSE_RESPONSE_EX    (SAM only)
//
// All character fields are UTF-8 and are compressed ala RFC 1035

typedef struct _NETLOGON_SAM_LOGON_RESPONSE_EX {
    USHORT Opcode;
    USHORT Sbz;
    ULONG Flags;
    GUID DomainGuid;

    CHAR DnsForestName[256];                  // Do not use offset of this field

    CHAR DnsDomainName[sizeof(WORD)];       // Do not use offset of this field

    CHAR DnsHostName[sizeof(WORD)];         // Do not use offset of this field

    CHAR NetbiosDomainName[DNLEN+1];        // Do not use offset of this field

    CHAR NetbiosComputerName[UNCLEN+1];     // Do not use offset of this field

    CHAR UserName[64];                      // Do not use offset of this field
                                            // Note: UNLEN is way too large since
                                            // it makes the message larger than
                                            // 512 bytes.

    CHAR DcSiteName[64];                    // Do not use offset of this field

    CHAR ClientSiteName[64];                // Do not use offset of this field

    // The DcSockAddrSize field is only present for NETLOGON_NT_VERSION_5EX_WITH_IP
    CHAR(DcSockAddrSize);                   // Do not use offset of this field
                                            // The next DcSockAddrSize byte are a
                                            // SOCKADDR structure representing the
                                            // IP address of the DC

    _ULONG (NtVersion);                     // Do not use offset of this field
    _USHORT (LmNtToken);                    // Do not use offset of this field
    _USHORT (Lm20Token);                    // Do not use offset of this field

} NETLOGON_SAM_LOGON_RESPONSE_EX, *PNETLOGON_SAM_LOGON_RESPONSE_EX;

#endif // _NETLOGON_H_
=== C:/Users/treeman/Desktop/windows nt source code\Source\Win2K3\NT\public\internal\ds\inc\mincrypt.h ===
//+-------------------------------------------------------------------------
//  Microsoft Windows
//
//  Copyright (C) Microsoft Corporation, 2001 - 2001
//
//  File:       mincrypt.h
//
//  Contents:   Minimal Cryptographic API Prototypes and Definitions
//
//              Contains cryptographic functions to verify PKCS #7 Signed Data
//              messages, X.509 certificate chains, Authenticode signed
//              files and file hashes in system catalogs.
//
//              These APIs rely on the APIs defined in minasn1.h for doing
//              the low level ASN.1 parsing.
//
//              These APIs are implemented to be self contained and to
//              allow for code obfuscation. These APIs will be included
//              in such applications as, DRM or licensing verification.
//
//              If the file name or file handle option is selected,
//              the following APIs will need to call the kernel32.dll APIs
//              to open, map and unmap files:
//                  MinCryptHashFile
//                  MinCryptVerifySignedFile
//              The following API will need to call kernel32.dll and
//              wintrust.dll APIs to find, open, map and unmap files:
//                  MinCryptVerifyHashInSystemCatalogs
//              Except for the calls in the above APIs,
//              no calls to APIs in other DLLs.
//
//              Additionally, since these APIs have been pared down
//              from their wincrypt.h and crypt32.dll counterparts they are
//              a good candidate for applications with minimal memory and CPU
//              resources.
//
//  APIs: 
//              MinCryptDecodeHashAlgorithmIdentifier
//              MinCryptHashMemory
//              MinCryptVerifySignedHash
//              MinCryptVerifyCertificate
//              MinCryptVerifySignedData
//              MinCryptHashFile
//              MinCryptVerifySignedFile
//              MinCryptVerifyHashInSystemCatalogs
//
//----------------------------------------------------------------------------

#ifndef __MINCRYPT_H__
#define __MINCRYPT_H__


#if defined (_MSC_VER)

#if ( _MSC_VER >= 800 )
#if _MSC_VER >= 1200
#pragma warning(push)
#endif
#pragma warning(disable:4201)    /* Nameless struct/union */
#endif

#if (_MSC_VER > 1020)
#pragma once
#endif

#endif


#include <wincrypt.h>
#include <minasn1.h>

#ifdef __cplusplus
extern "C" {
#endif



#define MINCRYPT_MAX_HASH_LEN               20
#define MINCRYPT_SHA1_HASH_LEN              20
#define MINCRYPT_MD5_HASH_LEN               16
#define MINCRYPT_MD2_HASH_LEN               16


//+-------------------------------------------------------------------------
//  Release any global resources consumed by the mincrypt
//  library.  This should be called during DLL_PROCESS_DETACH
//  since a critical section has possibly been created.
//
//  Currently, the global state (and its critical section) is 
//  initialized only on-demand for systems that make use of the
//  Microsoft Test Root Certificate.  
//--------------------------------------------------------------------------
/*
DWORD
WINAPI
MinCryptUninitialize(void);
*/


//+-------------------------------------------------------------------------
//  Decodes an ASN.1 encoded Algorithm Identifier and converts to
//  a CAPI Hash AlgID, such as, CALG_SHA1 or CALG_MD5.
//
//  Returns 0 if there isn't a CAPI AlgId corresponding to the Algorithm
//  Identifier.
//
//  Only CALG_SHA1, CALG_MD5 and CALG_MD2 are supported.
//--------------------------------------------------------------------------
ALG_ID
WINAPI
MinCryptDecodeHashAlgorithmIdentifier(
    IN PCRYPT_DER_BLOB pAlgIdValueBlob
    );

//+-------------------------------------------------------------------------
//  Hashes one or more memory blobs according to the Hash ALG_ID.
//
//  rgbHash is updated with the resultant hash. *pcbHash is updated with
//  the length associated with the hash algorithm.
//
//  If the function succeeds, the return value is ERROR_SUCCESS. Otherwise,
//  a nonzero error code is returned.
//
//  Only CALG_SHA1, CALG_MD5 and CALG_MD2 are supported.
//--------------------------------------------------------------------------
LONG
WINAPI
MinCryptHashMemory(
    IN ALG_ID HashAlgId,
    IN DWORD cBlob,
    IN PCRYPT_DER_BLOB rgBlob,
    OUT BYTE rgbHash[MINCRYPT_MAX_HASH_LEN],
    OUT DWORD *pcbHash
    );


//+-------------------------------------------------------------------------
//  Verifies a signed hash.
//
//  The ASN.1 encoded Public Key Info is parsed and used to decrypt the
//  signed hash. The decrypted signed hash is compared with the input
//  hash.
//
//  If the signed hash was successfully verified, ERROR_SUCCESS is returned.
//  Otherwise, a nonzero error code is returned.
//
//  Only RSA signatures are supported.
//
//  Only MD2, MD5 and SHA1 hashes are supported.
//--------------------------------------------------------------------------
LONG
WINAPI
MinCryptVerifySignedHash(
    IN ALG_ID HashAlgId,
    IN BYTE *pbHash,
    IN DWORD cbHash,
    IN PCRYPT_DER_BLOB pSignedHashContentBlob,
    IN PCRYPT_DER_BLOB pPubKeyInfoValueBlob
    );



//+-------------------------------------------------------------------------
//  Verifies a previously parsed X.509 Certificate.
//
//  Assumes the ASN.1 encoded X.509 certificate was parsed via
//  MinAsn1ParseCertificate() and the set of potential issuer certificates
//  were parsed via one or more of:
//   - MinAsn1ParseCertificate()
//   - MinAsn1ParseSignedDataCertificates()
//   - MinAsn1ExtractParsedCertificatesFromSignedData()
//
//  Iteratively finds the issuer certificate via its encoded name. The
//  public key in the issuer certificate is used to verify the subject
//  certificate's signature. This is repeated until finding a self signed
//  certificate or a baked in root identified by its encoded name.
//  For a self signed certificate, compares against the baked in root
//  public keys.
//
//  If the certificate and its issuers were successfully verified to a
//  baked in root, ERROR_SUCCESS is returned.  Otherwise, a nonzero error
//  code is returned.
//--------------------------------------------------------------------------
LONG
WINAPI
MinCryptVerifyCertificate(
    IN CRYPT_DER_BLOB rgSubjectCertBlob[MINASN1_CERT_BLOB_CNT],
    IN DWORD cIssuerCert,
    IN CRYPT_DER_BLOB rgrgIssuerCertBlob[][MINASN1_CERT_BLOB_CNT]
    );



//+-------------------------------------------------------------------------
//  Function: MinCryptVerifySignedData
//
//  Verifies an ASN.1 encoded PKCS #7 Signed Data Message.
//
//  Assumes the PKCS #7 message is definite length encoded.
//  Assumes PKCS #7 version 1.5, ie, not the newer CMS version.
//  We only look at the first signer.
//
//  The Signed Data message is parsed. Its signature is verified. Its
//  signer certificate chain is verified to a baked in root public key.
//
//  If the Signed Data was successfully verified, ERROR_SUCCESS is returned.
//  Otherwise, a nonzero error code is returned.
//
//  Here are some interesting errors that can be returned:
//      CRYPT_E_BAD_MSG     - unable to ASN1 parse as a signed data message
//      ERROR_NO_DATA       - the content is empty
//      CRYPT_E_NO_SIGNER   - not signed or unable to find signer cert
//      CRYPT_E_UNKNOWN_ALGO- unknown MD5 or SHA1 ASN.1 algorithm identifier
//      CERT_E_UNTRUSTEDROOT- the signer chain's root wasn't baked in
//      CERT_E_CHAINING     - unable to build signer chain to a root
//      CRYPT_E_AUTH_ATTR_MISSING - missing digest authenticated attribute
//      CRYPT_E_HASH_VALUE  - content hash != authenticated digest attribute
//      NTE_BAD_ALGID       - unsupported hash or public key algorithm
//      NTE_BAD_PUBLIC_KEY  - not a valid RSA public key
//      NTE_BAD_SIGNATURE   - bad PKCS #7 or signer chain signature 
//
//  The rgVerSignedDataBlob[] is updated with pointer to and length of the
//  following fields in the encoded PKCS #7 message.
//--------------------------------------------------------------------------

// Content Object Identifier content bytes (OID)
#define MINCRYPT_VER_SIGNED_DATA_CONTENT_OID_IDX                    0

// Content data content bytes excluding "[0] EXPLICIT" tag
// (OPTIONAL MinAsn1ParseCTL, MinAsn1ParseIndirectData)
#define MINCRYPT_VER_SIGNED_DATA_CONTENT_DATA_IDX                   1

// Signer certificate's encoded bytes (MinAsn1ParseCertificate)
#define MINCRYPT_VER_SIGNED_DATA_SIGNER_CERT_IDX                    2

// Authenticated attributes value bytes including "[0] IMPLICIT" tag
// (OPTIONAL, MinAsn1ParseAttributes)
#define MINCRYPT_VER_SIGNED_DATA_AUTH_ATTRS_IDX                     3

// Unauthenticated attributes value bytes including "[1] IMPLICIT" tag
// (OPTIONAL, MinAsn1ParseAttributes)
#define MINCRYPT_VER_SIGNED_DATA_UNAUTH_ATTRS_IDX                   4

#define MINCRYPT_VER_SIGNED_DATA_BLOB_CNT                           5

LONG
WINAPI
MinCryptVerifySignedData(
    IN const BYTE *pbEncoded,
    IN DWORD cbEncoded,
    OUT CRYPT_DER_BLOB rgVerSignedDataBlob[MINCRYPT_VER_SIGNED_DATA_BLOB_CNT]
    );



//+-------------------------------------------------------------------------
//  File Type Definitions
//
//  Specifies the type of the "const VOID *pvFile" parameter
//--------------------------------------------------------------------------

// pvFile - LPCWSTR pwszFilename
#define MINCRYPT_FILE_NAME          1

// pvFile - HANDLE hFile
#define MINCRYPT_FILE_HANDLE        2

// pvFile - PCRYPT_DATA_BLOB pFileBlob
#define MINCRYPT_FILE_BLOB          3


//+-------------------------------------------------------------------------
//  Hashes the file according to the Hash ALG_ID.
//
//  According to dwFileType, pvFile can be a pwszFilename, hFile or pFileBlob.
//  Only requires READ access.
//
//  dwFileType:
//      MINCRYPT_FILE_NAME      : pvFile - LPCWSTR pwszFilename
//      MINCRYPT_FILE_HANDLE    : pvFile - HANDLE hFile
//      MINCRYPT_FILE_BLOB      : pvFile - PCRYPT_DATA_BLOB pFileBlob
//
//  rgbHash is updated with the resultant hash. *pcbHash is updated with
//  the length associated with the hash algorithm.
//
//  If the function succeeds, the return value is ERROR_SUCCESS. Otherwise,
//  a nonzero error code is returned.
//
//  Only CALG_SHA1 and CALG_MD5 are supported.
//
//  If a NT PE 32 bit file format, hashed according to imagehlp rules, ie, skip
//  section containing potential signature, ... . Otherwise, the entire file
//  is hashed.
//--------------------------------------------------------------------------
LONG
WINAPI
MinCryptHashFile(
    IN DWORD dwFileType,
    IN const VOID *pvFile,
    IN ALG_ID HashAlgId,
    OUT BYTE rgbHash[MINCRYPT_MAX_HASH_LEN],
    OUT DWORD *pcbHash
    );


//+-------------------------------------------------------------------------
//  Verifies a previously signed file.
//
//  According to dwFileType, pvFile can be a pwszFilename, hFile or pFileBlob.
//  Only requires READ access.
//
//  dwFileType:
//      MINCRYPT_FILE_NAME      : pvFile - LPCWSTR pwszFilename
//      MINCRYPT_FILE_HANDLE    : pvFile - HANDLE hFile
//      MINCRYPT_FILE_BLOB      : pvFile - PCRYPT_DATA_BLOB pFileBlob
//
//  Checks if the file has an embedded PKCS #7 Signed Data message containing
//  Indirect Data. The PKCS #7 is verified via MinCryptVerifySignedData().
//  The Indirect Data is parsed via MinAsn1ParseIndirectData() to get the
//  HashAlgId and the file hash.  MinCryptHashFile() is called to hash the
//  file. The returned hash is compared against the Indirect Data's hash.
//
//  The caller can request one or more signer authenticated attribute values
//  to be returned. The still encoded values are returned in the
//  caller allocated memory. The beginning of this returned memory will
//  be set to an array of attribute value blobs pointing to these
//  encoded values (CRYPT_DER_BLOB rgAttrBlob[cAttrOID]).
//  For performance reasons, the caller should make every attempt to allow
//  for a single pass call. The necessary memory size is:
//      (cAttrOID * sizeof(CRYPT_DER_BLOB)) +
//          total length of encoded attribute values.
//
//  *pcbAttr will be updated with the number of bytes required to contain
//  the attribute blobs and values. If the input memory is insufficient,
//  ERROR_INSUFFICIENT_BUFFER will be returned if no other error.
//
//  For a multi-valued attribute, only the first value is returned.
//
//  If the function succeeds, the return value is ERROR_SUCCESS. Otherwise,
//  a nonzero error code is returned.
//
//  Only NT, PE 32 bit file formats are supported.
//--------------------------------------------------------------------------
LONG
WINAPI
MinCryptVerifySignedFile(
    IN DWORD dwFileType,
    IN const VOID *pvFile,

    IN OPTIONAL DWORD cAttrOID,
    IN OPTIONAL CRYPT_DER_BLOB rgAttrEncodedOIDBlob[],
    // CRYPT_DER_BLOB rgAttrBlob[cAttrOID] header is at beginning
    // with the bytes pointed to immediately following
    OUT OPTIONAL CRYPT_DER_BLOB *rgAttrValueBlob,
    IN OUT OPTIONAL DWORD *pcbAttr
    );

//+-------------------------------------------------------------------------
//  Verifies the hashes in the system catalogs.
//
//  Iterates through the hashes and attempts to find the system catalog
//  containing it. If found, the system catalog file is verified as a
//  PKCS #7 Signed Data message with its signer cert verified up to a baked
//  in root.
//
//  The following mscat32.dll APIs are called to find the system catalog file:
//      CryptCATAdminAcquireContext
//      CryptCATAdminReleaseContext
//      CryptCATAdminEnumCatalogFromHash
//      CryptCATAdminReleaseCatalogContext
//      CryptCATCatalogInfoFromContext
//
//  If the hash was successfully verified, rglErr[] is set to ERROR_SUCCESS.
//  Otherwise, rglErr[] is set to a nonzero error code.
//
//  The caller can request one or more catalog subject attribute,
//  extension or signer authenticated attribute values to be returned for
//  each hash.  The still encoded values are returned in the
//  caller allocated memory. The beginning of this returned memory will
//  be set to a 2 dimensional array of attribute value blobs pointing to these
//  encoded values (CRYPT_DER_BLOB rgrgAttrValueBlob[cHash][cAttrOID]).
//  For performance reasons, the caller should make every attempt to allow
//  for a single pass call. The necessary memory size is:
//      (cHash * cAttrOID * sizeof(CRYPT_DER_BLOB)) +
//          total length of encoded attribute values.
//
//  *pcbAttr will be updated with the number of bytes required to contain
//  the attribute blobs and values. If the input memory is insufficient,
//  ERROR_INSUFFICIENT_BUFFER will be returned if no other error.
//
//  For a multi-valued attribute, only the first value is returned.
//
//  If the function succeeds, the return value is ERROR_SUCCESS. This may
//  be returned for unsuccessful rglErr[] values. Otherwise,
//  a nonzero error code is returned.
//--------------------------------------------------------------------------
LONG
WINAPI
MinCryptVerifyHashInSystemCatalogs(
    IN ALG_ID HashAlgId,
    IN DWORD cHash,
    IN CRYPT_HASH_BLOB rgHashBlob[],
    OUT LONG rglErr[],

    IN OPTIONAL DWORD cAttrOID,
    IN OPTIONAL CRYPT_DER_BLOB rgAttrEncodedOIDBlob[],
    // CRYPT_DER_BLOB rgrgAttrValueBlob[cHash][cAttrOID] header is at beginning
    // with the bytes pointed to immediately following
    OUT OPTIONAL CRYPT_DER_BLOB *rgrgAttrValueBlob,
    IN OUT OPTIONAL DWORD *pcbAttr
    );
    



#ifdef __cplusplus
}       // Balance extern "C" above
#endif

#if defined (_MSC_VER)
#if ( _MSC_VER >= 800 )

#if _MSC_VER >= 1200
#pragma warning(pop)
#else
#pragma warning(default:4201)
#endif

#endif
#endif

#endif // __MINCRYPT_H__
=== C:/Users/treeman/Desktop/windows nt source code\Source\Win2K3\NT\public\internal\ds\inc\minasn1.h ===
//+-------------------------------------------------------------------------
//  Microsoft Windows
//
//  Copyright (C) Microsoft Corporation, 2001 - 2001
//
//  File:       minasn1.h
//
//  Contents:   Minimal ASN.1 Utility and Parsing API Prototypes
//              and Definitions
//
//              Contains functions to parse X.509 certificates, PKCS #7
//              Signed Data messages, Certificate Trusts Lists (CTLs),
//              hash catalogs, Authenticode Indirect Data and
//              RSA public keys.
//
//              These APIs are implemented to be self contained and to
//              allow for code obfuscation. These APIs will be included
//              in such applications as, DRM or licensing verification.
//
//              Additionally, since these APIs have been pared down
//              from their wincrypt.h and crypt32.dll counterparts they are
//              a good candidate for applications with minimal memory and CPU
//              resources.
//
//              These parsing functions don't depend on more heavy wait
//              ASN.1 runtimes, such as, msoss.dll or msasn1.dll.
//
//              These functions will only use stack memory. No heap
//              allocations. No calls to APIs in other DLLs.
//
//  APIs: 
//              MinAsn1DecodeLength
//              MinAsn1ExtractContent
//              MinAsn1ExtractValues
//
//              MinAsn1ParseCertificate
//              MinAsn1ParseAlgorithmIdentifier
//              MinAsn1ParsePublicKeyInfo
//              MinAsn1ParseRSAPublicKey
//              MinAsn1ParseExtensions
//              MinAsn1ParseSignedData
//              MinAsn1ParseSignedDataCertificates
//              MinAsn1ParseAttributes
//              MinAsn1ParseCTL
//              MinAsn1ParseCTLSubject
//              MinAsn1ParseIndirectData
//
//              MinAsn1FindExtension
//              MinAsn1FindAttribute
//              MinAsn1ExtractParsedCertificatesFromSignedData
//
//----------------------------------------------------------------------------

#ifndef __MINASN1_H__
#define __MINASN1_H__


#if defined (_MSC_VER)

#if ( _MSC_VER >= 800 )
#if _MSC_VER >= 1200
#pragma warning(push)
#endif
#pragma warning(disable:4201)    /* Nameless struct/union */
#endif

#if (_MSC_VER > 1020)
#pragma once
#endif

#endif


#include <wincrypt.h>

#ifdef __cplusplus
extern "C" {
#endif


//+-------------------------------------------------------------------------
//  ASN.1 Tag Defines
//--------------------------------------------------------------------------
#define MINASN1_TAG_NULL                    0x00
#define MINASN1_TAG_BOOLEAN                 0x01
#define MINASN1_TAG_INTEGER                 0x02
#define MINASN1_TAG_BITSTRING               0x03
#define MINASN1_TAG_OCTETSTRING             0x04
#define MINASN1_TAG_OID                     0x06
#define MINASN1_TAG_UTC_TIME                0x17
#define MINASN1_TAG_GENERALIZED_TIME        0x18
#define MINASN1_TAG_CONSTRUCTED             0x20
#define MINASN1_TAG_SEQ                     0x30
#define MINASN1_TAG_SET                     0x31
#define MINASN1_TAG_CONTEXT_0               0x80
#define MINASN1_TAG_CONTEXT_1               0x81
#define MINASN1_TAG_CONTEXT_2               0x82
#define MINASN1_TAG_CONTEXT_3               0x83

#define MINASN1_TAG_CONSTRUCTED_CONTEXT_0   \
                        (MINASN1_TAG_CONSTRUCTED | MINASN1_TAG_CONTEXT_0)
#define MINASN1_TAG_CONSTRUCTED_CONTEXT_1   \
                        (MINASN1_TAG_CONSTRUCTED | MINASN1_TAG_CONTEXT_1)
#define MINASN1_TAG_CONSTRUCTED_CONTEXT_3   \
                        (MINASN1_TAG_CONSTRUCTED | MINASN1_TAG_CONTEXT_3)

//+-------------------------------------------------------------------------
//  ASN.1 Length Defines for indefinite length encooding
//--------------------------------------------------------------------------
#define MINASN1_LENGTH_INDEFINITE               0x80
#define MINASN1_LENGTH_NULL                     0x00

#define MINASN1_LENGTH_TOO_LARGE                -1
#define MINASN1_INSUFFICIENT_DATA               -2
#define MINASN1_UNSUPPORTED_INDEFINITE_LENGTH   -3

//+-------------------------------------------------------------------------
//  Get the number of contents octets in a definite-length BER-encoding.
//
//  Parameters:
//          pcbContent - receives the number of contents octets
//          pbLength   - points to the first length octet
//          cbBER      - number of bytes remaining in the BER encoding
//
//  Returns:
//          success - the number of bytes in the length field, > 0
//          failure - < 0
//
//          One of the following failure values can be returned:
//              MINASN1_LENGTH_TOO_LARGE
//              MINASN1_INSUFFICIENT_DATA
//              MINASN1_UNSUPPORTED_INDEFINITE_LENGTH
//--------------------------------------------------------------------------
LONG
WINAPI
MinAsn1DecodeLength(
    OUT DWORD *pcbContent,
    IN const BYTE *pbLength,
    IN  DWORD cbBER
    );

//+-------------------------------------------------------------------------
//  Point to the content octets in a definite-length BER-encoded blob.
//
//  Returns:
//          success - the number of bytes skipped, > 0
//          failure - < 0
//
//          One of the following failure values can be returned:
//              MINASN1_LENGTH_TOO_LARGE
//              MINASN1_INSUFFICIENT_DATA
//              MINASN1_UNSUPPORTED_INDEFINITE_LENGTH
//
// Assumption: pbData points to a definite-length BER-encoded blob.
//             If *pcbContent isn't within cbBER, MINASN1_INSUFFICIENT_DATA
//             is returned.
//--------------------------------------------------------------------------
LONG
WINAPI
MinAsn1ExtractContent(
    IN const BYTE *pbBER,
    IN DWORD cbBER,
    OUT DWORD *pcbContent,
    OUT const BYTE **ppbContent
    );


typedef struct _MINASN1_EXTRACT_VALUE_PARA {
    // See below for list of operations and optional return blobs.
    DWORD           dwFlags;

    // Index into rgValueBlob of the returned value. Ignored if none of
    // the ASN1_PARSE_RETURN_*_BLOB_FLAG's is set in the above dwFlags.
    DWORD           dwIndex;

    // The following 0 terminated array of tags is optional. If ommited, the
    // value may contain any tag.
    const BYTE      *rgbTag;
} MINASN1_EXTRACT_VALUE_PARA, *PMINASN1_EXTRACT_VALUE_PARA;

// The lower 8 bits of dwFlags is set to one of the following operations
#define MINASN1_MASK_VALUE_OP                   0xFF
#define MINASN1_STEP_OVER_VALUE_OP              1
#define MINASN1_OPTIONAL_STEP_OVER_VALUE_OP     2
#define MINASN1_STEP_INTO_VALUE_OP              3
#define MINASN1_OPTIONAL_STEP_INTO_VALUE_OP     4
#define MINASN1_STEP_OUT_VALUE_OP               5

#define MINASN1_RETURN_VALUE_BLOB_FLAG          0x80000000
#define MINASN1_RETURN_CONTENT_BLOB_FLAG        0x40000000


//+-------------------------------------------------------------------------
//  Extract one or more tagged values from the ASN.1 encoded byte array.
//
//  Either steps into the value's content octets (MINASN1_STEP_INTO_VALUE_OP or
//  MINASN1_OPTIONAL_STEP_INTO_VALUE_OP) or steps over the value's tag,
//  length and content octets (MINASN1_STEP_OVER_VALUE_OP or
//  MINASN1_OPTIONAL_STEP_OVER_VALUE_OP).
//
//  You can step out of a stepped into sequence via MINASN1_STEP_OUT_VALUE_OP.
//
//  For tag matching, only supports single byte tags.
//
//  Only definite-length ASN.1 is supported.
//
//  *pcValue is updated with the number of values successfully extracted.
//
//  Returns:
//      success - >= 0 => length of all bytes consumed through the last value
//                        extracted. For STEP_INTO, only the tag and length
//                        octets.
//      failure -  < 0 => negative (offset + 1) of first bad tagged value
//
//  A non-NULL rgValueBlob[] is updated with the pointer to and length of the
//  tagged value or its content octets. The rgValuePara[].dwIndex is used to
//  index into rgValueBlob[].  For OPTIONAL_STEP_OVER or
//  OPTIONAL_STEP_INTO, if no more bytes in the outer SEQUENCE or if the tag
//  isn't found, pbData and cbData are set to 0. Additioanlly, for
//  OPTIONAL_STEP_INTO, all subsequent values are skipped and their
//  rgValueBlob[] entries zeroed until a STEP_OUT is encountered.
//
//  If MINASN1_RETURN_VALUE_BLOB_FLAG is set, pbData points to
//  the tag. cbData includes the tag, length and content octets.
//
//  If MINASN1_RETURN_CONTENT_BLOB_FLAG is set, pbData points to the content
//  octets. cbData includes only the content octets.
//
//  If neither BLOB_FLAG is set, rgValueBlob[] isn't updated.
//
//  For MINASN1_RETURN_CONTENT_BLOB_FLAG of a BITSTRING, pbData is
//  advanced past the first contents octet containing the number of
//  unused bits and cbData has been decremented by 1. If cbData > 0, then,
//  *(pbData - 1) will contain the number of unused bits.
//--------------------------------------------------------------------------
LONG
WINAPI
MinAsn1ExtractValues(
    IN const BYTE *pbEncoded,
    IN DWORD cbEncoded,
    IN OUT DWORD *pcValuePara,
    IN const MINASN1_EXTRACT_VALUE_PARA *rgValuePara,
    IN DWORD cValueBlob,
    OUT OPTIONAL PCRYPT_DER_BLOB rgValueBlob
    );


//+-------------------------------------------------------------------------
//  Function: MinAsn1ParseCertificate
//
//  Parses an ASN.1 encoded X.509 certificate.
//
//  Returns:
//      success -  > 0 => bytes skipped, length of the encoded certificate
//      failure -  < 0 => negative (offset + 1) of first bad tagged value
//
//  The rgCertBlob[] is updated with pointer to and length of the following
//  fields in the encoded X.509 certificate.
//
//  All BITSTRING fields have been advanced past the unused count octet.
//--------------------------------------------------------------------------

// Encoded bytes including To Be Signed and Signature
#define MINASN1_CERT_ENCODED_IDX                1

// To Be Signed bytes
#define MINASN1_CERT_TO_BE_SIGNED_IDX           2

// Signature Algorithm value bytes (MinAsn1ParseAlgorithmIdentifier)
#define MINASN1_CERT_SIGN_ALGID_IDX             3

// Signature content bytes (BITSTRING)
#define MINASN1_CERT_SIGNATURE_IDX              4

// Version content bytes (OPTIONAL INTEGER)
#define MINASN1_CERT_VERSION_IDX                5

// Serial Number content bytes (INTEGER)
#define MINASN1_CERT_SERIAL_NUMBER_IDX          6

// Issuer Name value bytes (ANY)
#define MINASN1_CERT_ISSUER_IDX                 7

// Not Before value bytes (UTC_TIME or GENERALIZED_TIME)
#define MINASN1_CERT_NOT_BEFORE_IDX             8

// Not After value bytes (UTC_TIME or GENERALIZED_TIME)
#define MINASN1_CERT_NOT_AFTER_IDX              9

// Subject Name value bytes (ANY)
#define MINASN1_CERT_SUBJECT_IDX                10

// Public Key Info value bytes (MinAsn1ParsePublicKeyInfo)
#define MINASN1_CERT_PUBKEY_INFO_IDX            11

// Issuer Unique Id content bytes (OPTIONAL BITSTRING)
#define MINASN1_CERT_ISSUER_UNIQUE_ID_IDX       12

// Subject Unique Id content bytes (OPTIONAL BITSTRING)
#define MINASN1_CERT_SUBJECT_UNIQUE_ID_IDX      13

// Extensions value bytes skipping "[3] EXPLICIT" tag
// (OPTIONAL MinAsn1ParseExtensions)
#define MINASN1_CERT_EXTS_IDX                   14

#define MINASN1_CERT_BLOB_CNT                   15

LONG
WINAPI
MinAsn1ParseCertificate(
    IN const BYTE *pbEncoded,
    IN DWORD cbEncoded,
    OUT CRYPT_DER_BLOB rgCertBlob[MINASN1_CERT_BLOB_CNT]
    );


//+-------------------------------------------------------------------------
//  Function: MinAsn1ParseAlgorithmIdentifier
//
//  Parses an ASN.1 encoded Algorithm Identifier contained in numerous
//  other ASN.1 structures, such as, X.509 certificate and PKCS #7 Signed Data
//  message.
//
//  Returns:
//      success -  > 0 => bytes skipped, length of the encoded algorithm
//                        identifier
//      failure -  < 0 => negative (offset + 1) of first bad tagged value
//
//  The rgAlgIdBlob[] is updated with pointer to and length of the following
//  fields in the encoded Algorithm Identifier
//--------------------------------------------------------------------------

// Encoded bytes including outer SEQUENCE tag and length octets
#define MINASN1_ALGID_ENCODED_IDX               1

// Object Identifier content bytes (OID)
#define MINASN1_ALGID_OID_IDX                   2

// Encoded parameters value bytes (OPTIONAL ANY)
#define MINASN1_ALGID_PARA_IDX                  3

#define MINASN1_ALGID_BLOB_CNT                  4


LONG
WINAPI
MinAsn1ParseAlgorithmIdentifier(
    IN PCRYPT_DER_BLOB pAlgIdValueBlob,
    OUT CRYPT_DER_BLOB rgAlgIdBlob[MINASN1_ALGID_BLOB_CNT]
    );



//+-------------------------------------------------------------------------
//  Function: MinAsn1ParsePublicKeyInfo
//
//  Parses an ASN.1 encoded Public Key Info structure contained in an
//  X.509 certificate
//
//  Returns:
//      success -  > 0 => bytes skipped, length of the encoded public key
//                        info
//      failure -  < 0 => negative (offset + 1) of first bad tagged value
//
//  The rgPubKeyInfoBlob[] is updated with pointer to and length of the
//  following fields in the encoded Public Key Info.
//
//  All BITSTRING fields have been advanced past the unused count octet.
//--------------------------------------------------------------------------

// Encoded bytes including outer SEQUENCE tag and length octets
#define MINASN1_PUBKEY_INFO_ENCODED_IDX         1

// Algorithm Identifier value bytes (MinAsn1ParseAlgorithmIdentifier)
#define MINASN1_PUBKEY_INFO_ALGID_IDX           2

// Public Key content bytes (BITSTRING, MinAsn1ParseRSAPublicKey)
#define MINASN1_PUBKEY_INFO_PUBKEY_IDX          3

#define MINASN1_PUBKEY_INFO_BLOB_CNT            4


LONG
WINAPI
MinAsn1ParsePublicKeyInfo(
    IN PCRYPT_DER_BLOB pPubKeyInfoValueBlob,
    CRYPT_DER_BLOB rgPubKeyInfoBlob[MINASN1_PUBKEY_INFO_BLOB_CNT]
    );


//+-------------------------------------------------------------------------
//  Function: MinAsn1ParseRSAPublicKey
//
//  Parses an ASN.1 encoded RSA PKCS #1 Public Key contained in the contents of
//  Public Key BITSTRING in a X.509 certificate.
//
//  Returns:
//      success -  > 0 => bytes skipped, length of the encoded RSA public key
//      failure -  < 0 => negative (offset + 1) of first bad tagged value
//
//  The rgRSAPubKeyBlob[] is updated with pointer to and length of the
//  following fields in the encoded RSA Public Key.
//--------------------------------------------------------------------------

// Encoded bytes including outer SEQUENCE tag and length octets
#define MINASN1_RSA_PUBKEY_ENCODED_IDX          1

// Modulus content bytes (INTEGER)
#define MINASN1_RSA_PUBKEY_MODULUS_IDX          2

// Exponent content bytes (INTEGER)
#define MINASN1_RSA_PUBKEY_EXPONENT_IDX         3

#define MINASN1_RSA_PUBKEY_BLOB_CNT             4

LONG
WINAPI
MinAsn1ParseRSAPublicKey(
    IN PCRYPT_DER_BLOB pPubKeyContentBlob,
    CRYPT_DER_BLOB rgRSAPubKeyBlob[MINASN1_RSA_PUBKEY_BLOB_CNT]
    );


//+-------------------------------------------------------------------------
//  Function: MinAsn1ParseExtensions
//
//  Parses an ASN.1 encoded sequence of extensions contained in 
//  other ASN.1 structures, such as, X.509 certificate and CTL.
//
//  Upon input, *pcExt contains the maximum number of parsed extensions
//  that can be returned. Updated with the number of extensions processed.
//
//  Returns:
//      success - >= 0 => bytes skipped, length of the encoded extensions
//                        processed. If all extensions were processed,
//                        bytes skipped = pExtsValueBlob->cbData.
//      failure -  < 0 => negative (offset + 1) of first bad tagged value
//
//  The rgrgExtBlob[][] is updated with pointer to and length of the
//  following fields in the encoded extension.
//--------------------------------------------------------------------------

// Encoded bytes including outer SEQUENCE tag and length octets
#define MINASN1_EXT_ENCODED_IDX                 1

// Object Identifier content bytes (OID)
#define MINASN1_EXT_OID_IDX                     2

// Critical content bytes (OPTIONAL BOOLEAN, DEFAULT FALSE)
#define MINASN1_EXT_CRITICAL_IDX                3

// Value content bytes (OCTETSTRING)
#define MINASN1_EXT_VALUE_IDX                   4

#define MINASN1_EXT_BLOB_CNT                    5

LONG
WINAPI
MinAsn1ParseExtensions(
    IN PCRYPT_DER_BLOB pExtsValueBlob,  // Extensions ::= SEQUENCE OF Extension
    IN OUT DWORD *pcExt,
    OUT CRYPT_DER_BLOB rgrgExtBlob[][MINASN1_EXT_BLOB_CNT]
    );



//+-------------------------------------------------------------------------
//  Function: MinAsn1ParseSignedData
//
//  Parses an ASN.1 encoded PKCS #7 Signed Data Message. Assumes the
//  PKCS #7 message is definite length encoded. Assumes PKCS #7 version
//  1.5, ie, not the newer CMS version.
//
//  Returns:
//      success -  > 0 => bytes skipped, length of the encoded message
//      failure -  < 0 => negative (offset + 1) of first bad tagged value
//
//  The rgSignedDataBlob[] is updated with pointer to and length of the
//  following fields in the encoded PKCS #7 message.
//--------------------------------------------------------------------------

// Encoded bytes including outer SEQUENCE tag and length octets
#define MINASN1_SIGNED_DATA_ENCODED_IDX                             1

// Outer Object Identfier content bytes (OID, should be "1.2.840.113549.1.7.2")
#define MINASN1_SIGNED_DATA_OUTER_OID_IDX                           2

// Version content bytes (INTEGER)
#define MINASN1_SIGNED_DATA_VERSION_IDX                             3

// Set of Digest Algorithms value bytes (SET OF)
#define MINASN1_SIGNED_DATA_DIGEST_ALGIDS_IDX                       4

// Inner Object Identifier content bytes (OID)
#define MINASN1_SIGNED_DATA_CONTENT_OID_IDX                         5

// Signed content data content bytes excluding "[0] EXPLICIT" tag
// (OPTIONAL ANY, MinAsn1ParseCTL, MinAsn1ParseIndirectData)
#define MINASN1_SIGNED_DATA_CONTENT_DATA_IDX                        6

// Certificates value bytes including "[1] IMPLICIT" tag
// (OPTIONAL, MinAsn1ParseSignedDataCertificates)
#define MINASN1_SIGNED_DATA_CERTS_IDX                               7

// CRL value bytes including "[2] IMPLICIT" tag (OPTIONAL)
#define MINASN1_SIGNED_DATA_CRLS_IDX                                8

// Encoded bytes including outer SET tag and length octets
#define MINASN1_SIGNED_DATA_SIGNER_INFOS_IDX                        9

// The following point to the first Signer Info fields (OPTIONAL)

// Encoded bytes including outer SEQUENCE tag and length octets
#define MINASN1_SIGNED_DATA_SIGNER_INFO_ENCODED_IDX                 10

// Version content bytes (INTEGER)
#define MINASN1_SIGNED_DATA_SIGNER_INFO_VERSION_IDX                 11

// Issuer Name value bytes (ANY)
#define MINASN1_SIGNED_DATA_SIGNER_INFO_ISSUER_IDX                  12

// Serial Number content bytes (INTEGER)
#define MINASN1_SIGNED_DATA_SIGNER_INFO_SERIAL_NUMBER_IDX           13

// Digest Algorithm value bytes (MinAsn1ParseAlgorithmIdentifier)
#define MINASN1_SIGNED_DATA_SIGNER_INFO_DIGEST_ALGID_IDX            14

// Authenticated attributes value bytes including "[0] IMPLICIT" tag
// (OPTIONAL, MinAsn1ParseAttributes)
#define MINASN1_SIGNED_DATA_SIGNER_INFO_AUTH_ATTRS_IDX              15

// Encrypted Digest Algorithm value bytes (MinAsn1ParseAlgorithmIdentifier)
#define MINASN1_SIGNED_DATA_SIGNER_INFO_ENCRYPT_DIGEST_ALGID_IDX    16

// Encrypted digest content bytes (OCTET STRING)
#define MINASN1_SIGNED_DATA_SIGNER_INFO_ENCYRPT_DIGEST_IDX          17

// Unauthenticated attributes value bytes including "[1] IMPLICIT" tag
// (OPTIONAL, MinAsn1ParseAttributes)
#define MINASN1_SIGNED_DATA_SIGNER_INFO_UNAUTH_ATTRS_IDX            18

#define MINASN1_SIGNED_DATA_BLOB_CNT                                19

LONG
WINAPI
MinAsn1ParseSignedData(
    IN const BYTE *pbEncoded,
    IN DWORD cbEncoded,
    OUT CRYPT_DER_BLOB rgSignedDataBlob[MINASN1_SIGNED_DATA_BLOB_CNT]
    );



//+-------------------------------------------------------------------------
//  Function: MinAsn1ParseSignedDataCertificates
//
//  Parses an ASN.1 encoded set of certificates contained in 
//  a Signed Data message.
//
//  Upon input, *pcCert contains the maximum number of parsed certificates
//  that can be returned. Updated with the number of certificates processed.
//
//  Returns:
//      success - >= 0 => bytes skipped, length of the encoded certificates
//                        processed. If all certificates were processed,
//                        bytes skipped = pCertsValueBlob->cbData.
//      failure -  < 0 => negative (offset + 1) of first bad tagged value
//
//  The rgrgCertBlob[][] is updated with pointer to and length of the
//  fields in the encoded certificate. See MinAsn1ParseCertificate for the
//  field definitions.
//--------------------------------------------------------------------------

LONG
WINAPI
MinAsn1ParseSignedDataCertificates(
    IN PCRYPT_DER_BLOB pCertsValueBlob,
    IN OUT DWORD *pcCert,
    OUT CRYPT_DER_BLOB rgrgCertBlob[][MINASN1_CERT_BLOB_CNT]
    );


//+-------------------------------------------------------------------------
//  Function: MinAsn1ParseAttributes
//
//  Parses an ASN.1 encoded sequence of attributes contained in 
//  other ASN.1 structures, such as, Signer Info authenticated or
//  unauthenticated attributes.
//
//  The outer tag is ignored. It can be a SET, [0] IMPLICIT, or [1] IMPLICIT.
//
//  Upon input, *pcAttr contains the maximum number of parsed attributes
//  that can be returned. Updated with the number of attributes processed.
//
//  Returns:
//      success - >= 0 => bytes skipped, length of the encoded attributes
//                        processed. If all attributes were processed,
//                        bytes skipped = pAttrsValueBlob->cbData.
//      failure -  < 0 => negative (offset + 1) of first bad tagged value
//
//  The rgrgAttrBlob[][] is updated with pointer to and length of the
//  following fields in the encoded attribute.
//--------------------------------------------------------------------------

// Encoded bytes including outer SEQUENCE tag and length octets
#define MINASN1_ATTR_ENCODED_IDX                1

// Object Identifier content bytes (OID)
#define MINASN1_ATTR_OID_IDX                    2

// Values value bytes (SET OF)
#define MINASN1_ATTR_VALUES_IDX                 3

// First Value's value bytes (OPTIONAL ANY)
#define MINASN1_ATTR_VALUE_IDX                  4

#define MINASN1_ATTR_BLOB_CNT                   5

LONG
WINAPI
MinAsn1ParseAttributes(
    IN PCRYPT_DER_BLOB pAttrsValueBlob,
    IN OUT DWORD *pcAttr,
    OUT CRYPT_DER_BLOB rgrgAttrBlob[][MINASN1_ATTR_BLOB_CNT]
    );




//+-------------------------------------------------------------------------
//  Function: MinAsn1ParseCTL
//
//  Parses an ASN.1 encoded Certificate Trust List (CTL). A CTL is always
//  contained as the inner content data in a PKCS #7 Signed Data. A CTL has
//  the following OID: "1.3.6.1.4.1.311.10.1".
//
//  A catalog file is formatted as a PKCS #7 Signed CTL.
//
//  Returns:
//      success -  > 0 => bytes skipped, length of the encoded CTL
//      failure -  < 0 => negative (offset + 1) of first bad tagged value
//
//  The rgCTLBlob[] is updated with pointer to and length of the following
//  fields in the encoded CTL.
//
//--------------------------------------------------------------------------

// Encoded bytes including outer SEQUENCE tag and length octets
#define MINASN1_CTL_ENCODED_IDX                 1

// Version content bytes (OPTIONAL INTEGER)
#define MINASN1_CTL_VERSION_IDX                 2

// Subject usage value bytes (SEQUENCE OF OID)
#define MINASN1_CTL_SUBJECT_USAGE_IDX           3

// List Identifier content bytes (OPTIONAL OCTETSTRING)
#define MINASN1_CTL_LIST_ID_IDX                 4

// Sequence number content bytes (OPTIONAL INTEGER)
#define MINASN1_CTL_SEQUENCE_NUMBER_IDX         5

// This Update value bytes (UTC_TIME or GENERALIZED_TIME)
#define MINASN1_CTL_THIS_UPDATE_IDX             6

// Next Update value bytes (OPTIONAL UTC_TIME or GENERALIZED_TIME)
#define MINASN1_CTL_NEXT_UPDATE_IDX             7

// Subject Algorithm Identifier value bytes (MinAsn1ParseAlgorithmIdentifier)
#define MINASN1_CTL_SUBJECT_ALGID_IDX           8

// Subjects value bytes (OPTIONAL, iterative MinAsn1ParseCTLSubject)
#define MINASN1_CTL_SUBJECTS_IDX                9

// Extensions value bytes skipping "[0] EXPLICIT" tag
// (OPTIONAL, MinAsn1ParseExtensions)
#define MINASN1_CTL_EXTS_IDX                    10

#define MINASN1_CTL_BLOB_CNT                    11

LONG
WINAPI
MinAsn1ParseCTL(
    IN PCRYPT_DER_BLOB pEncodedContentBlob,
    OUT CRYPT_DER_BLOB rgCTLBlob[MINASN1_CTL_BLOB_CNT]
    );



//+-------------------------------------------------------------------------
//  Function: MinAsn1ParseCTLSubject
//
//  Parses an ASN.1 encoded CTL Subject contained within a CTL's SEQUENCE OF
//  Subjects.
//
//  Returns:
//      success -  > 0 => bytes skipped, length of the encoded subject.
//      failure -  < 0 => negative (offset + 1) of first bad tagged value
//
//  The rgCTLSubjectBlob[][] is updated with pointer to and length of the
//  following fields in the encoded subject.
//--------------------------------------------------------------------------

// Encoded bytes including outer SEQUENCE tag and length octets
#define MINASN1_CTL_SUBJECT_ENCODED_IDX         1

// Subject Identifier content bytes (OCTETSTRING)
#define MINASN1_CTL_SUBJECT_ID_IDX              2

// Attributes value bytes (OPTIONAL, MinAsn1ParseAttributes)
#define MINASN1_CTL_SUBJECT_ATTRS_IDX           3

#define MINASN1_CTL_SUBJECT_BLOB_CNT            4

LONG
WINAPI
MinAsn1ParseCTLSubject(
    IN const BYTE *pbEncoded,
    IN DWORD cbEncoded,
    OUT CRYPT_DER_BLOB rgCTLSubjectBlob[MINASN1_CTL_SUBJECT_BLOB_CNT]
    );



//+-------------------------------------------------------------------------
//  Function: MinAsn1ParseIndirectData
//
//  Parses an ASN.1 encoded Indirect Data. Indirect Data is always
//  contained as the inner content data in a PKCS #7 Signed Data. It has
//  the following OID: "1.3.6.1.4.1.311.2.1.4"
//
//  An Authenticode signed file contains a PKCS #7 Signed Indirect Data.
//
//  Returns:
//      success -  > 0 => bytes skipped, length of the encoded Indirect Data
//      failure -  < 0 => negative (offset + 1) of first bad tagged value
//
//  The rgIndirectDataBlob[] is updated with pointer to and length of the
//  following fields in the encoded Indirect Data.
//
//--------------------------------------------------------------------------

// Encoded bytes including outer SEQUENCE tag and length octets
#define MINASN1_INDIRECT_DATA_ENCODED_IDX       1

// Attribute Object Identifier content bytes (OID)
#define MINASN1_INDIRECT_DATA_ATTR_OID_IDX      2

// Attribute value bytes (OPTIONAL ANY)
#define MINASN1_INDIRECT_DATA_ATTR_VALUE_IDX    3

// Digest Algorithm Identifier (MinAsn1ParseAlgorithmIdentifier)
#define MINASN1_INDIRECT_DATA_DIGEST_ALGID_IDX  4

// Digest content bytes (OCTETSTRING)
#define MINASN1_INDIRECT_DATA_DIGEST_IDX        5

#define MINASN1_INDIRECT_DATA_BLOB_CNT          6

LONG
WINAPI
MinAsn1ParseIndirectData(
    IN PCRYPT_DER_BLOB pEncodedContentBlob,
    OUT CRYPT_DER_BLOB rgIndirectDataBlob[MINASN1_INDIRECT_DATA_BLOB_CNT]
    );




//+-------------------------------------------------------------------------
//  Find an extension identified by its Encoded Object Identifier.
//
//  Searches the list of parsed extensions returned by
//  MinAsn1ParseExtensions().
//
//  If found, returns pointer to the rgExtBlob[MINASN1_EXT_BLOB_CNT].
//  Otherwise, returns NULL.
//--------------------------------------------------------------------------
PCRYPT_DER_BLOB
WINAPI
MinAsn1FindExtension(
    IN PCRYPT_DER_BLOB pEncodedOIDBlob,
    IN DWORD cExt,
    IN CRYPT_DER_BLOB rgrgExtBlob[][MINASN1_EXT_BLOB_CNT]
    );


//+-------------------------------------------------------------------------
//  Find the first attribute identified by its Encoded Object Identifier.
//
//  Searches the list of parsed attributes returned by
//  MinAsn1ParseAttributes().
//
//  If found, returns pointer to the rgAttrBlob[MINASN1_ATTR_BLOB_CNT].
//  Otherwise, returns NULL.
//--------------------------------------------------------------------------
PCRYPT_DER_BLOB
WINAPI
MinAsn1FindAttribute(
    IN PCRYPT_DER_BLOB pEncodedOIDBlob,
    IN DWORD cAttr,
    IN CRYPT_DER_BLOB rgrgAttrBlob[][MINASN1_ATTR_BLOB_CNT]
    );

//+-------------------------------------------------------------------------
//  Parses an ASN.1 encoded PKCS #7 Signed Data Message to extract and
//  parse the X.509 certificates it contains.
//
//  Assumes the PKCS #7 message is definite length encoded.
//  Assumes PKCS #7 version 1.5, ie, not the newer CMS version.
//
//  Upon input, *pcCert contains the maximum number of parsed certificates
//  that can be returned. Updated with the number of certificates processed.
//
//  If the encoded message was successfully parsed, TRUE is returned
//  with *pcCert updated with the number of parsed certificates. Otherwise,
//  FALSE is returned for a parse error.
//  Returns:
//      success - >= 0 => bytes skipped, length of the encoded certificates
//                        processed.
//      failure -  < 0 => negative (offset + 1) of first bad tagged value
//                        from beginning of message.
//
//  The rgrgCertBlob[][] is updated with pointer to and length of the
//  fields in the encoded certificate. See MinAsn1ParseCertificate for the
//  field definitions.
//--------------------------------------------------------------------------
LONG
WINAPI
MinAsn1ExtractParsedCertificatesFromSignedData(
    IN const BYTE *pbEncoded,
    IN DWORD cbEncoded,
    IN OUT DWORD *pcCert,
    OUT CRYPT_DER_BLOB rgrgCertBlob[][MINASN1_CERT_BLOB_CNT]
    );



#ifdef __cplusplus
}       // Balance extern "C" above
#endif

#if defined (_MSC_VER)
#if ( _MSC_VER >= 800 )

#if _MSC_VER >= 1200
#pragma warning(pop)
#else
#pragma warning(default:4201)
#endif

#endif
#endif

#endif // __MINASN1_H__
=== C:/Users/treeman/Desktop/windows nt source code\Source\Win2K3\NT\public\internal\ds\inc\msginaexports.h ===
//  --------------------------------------------------------------------------
//  Module Name: MSGinaExports.h
//
//  Copyright (c) 2000, Microsoft Corporation
//
//  Private exported functions (by ordinal) from msgina for personal SKU
//  functionality.
//
//  History:    2000-02-04  vtan        created
//              2000-02-28  vtan        added ShellIsFriendlyUIActive
//              2000-02-29  vtan        added ShellIsSingleUserNoPassword
//              2000-03-02  vtan        added ShellIsMultipleUsersEnabled
//              2000-04-27  vtan        added ShellTurnOffDialog
//              2000-04-27  vtan        added ShellACPIPowerButtonPressed
//              2000-05-03  vtan        added ShellStatusHostBegin
//              2000-05-03  vtan        added ShellStatusHostEnd
//              2000-05-04  vtan        added ShellSwitchWhenInteractiveReady
//              2000-05-18  vtan        added ShellDimScreen
//              2000-06-02  vtan        added ShellInstallAccountFilterData
//              2000-07-14  vtan        added ShellStatusHostShuttingDown
//              2000-07-27  vtan        added ShellIsSuspendAllowed
//              2000-07-31  vtan        added ShellEnableMultipleUsers
//              2000-07-31  vtan        added ShellEnableRemoteConnections
//              2000-08-01  vtan        added ShellEnableFriendlyUI
//              2000-08-01  vtan        added ShellIsRemoteConnectionsEnabled
//              2000-08-03  vtan        added ShellSwitchUser
//              2000-08-09  vtan        added ShellNotifyThemeUserChange
//              2000-08-14  vtan        added ShellIsUserInteractiveLogonAllowed
//              2000-08-15  vtan        moved to internally published header
//              2000-10-13  vtan        added ShellStartThemeServer
//              2000-10-17  vtan        added ShellStopThemeServer
//              2000-11-30  vtan        removed ShellStartThemeServer
//              2000-11-30  vtan        removed ShellStopThemeServer
//              2001-01-11  vtan        added stub functions for imp library
//              2001-01-11  vtan        added ShellReturnToWelcome
//              2001-01-31  vtan        added ShellStatusHostPowerEvent
//              2001-04-03  vtan        added ShellStartCredentialServer
//              2001-04-04  vtan        added ShellAcquireLogonMutex
//              2001-04-04  vtan        added ShellReleaseLogonMutex
//              2001-04-06  vtan        added ShellSignalShutdown
//              2001-04-12  vtan        added ShellStatusHostHide
//              2001-04-12  vtan        added ShellStatusHostShow
//  --------------------------------------------------------------------------

#ifndef     _MSGinaExports_
#define     _MSGinaExports_

#if !defined(_MSGINA_)
#define MSGINAAPI             DECLSPEC_IMPORT
#define GINASTDAPI_(type)     EXTERN_C DECLSPEC_IMPORT type STDAPICALLTYPE
#define GINASTDAPI            EXTERN_C DECLSPEC_IMPORT HRESULT STDAPICALLTYPE
#else
#define MSGINAAPI             
#define GINASTDAPI_(type)     STDAPI_(type)
#define GINASTDAPI            STDAPI
#endif

#include <unknwn.h>

typedef enum _USERLOGTYPE
{
    ULT_LOGON,              //  User log on 
    ULT_LOGOFF,             //  User log off
    ULT_TSRECONNECT,        //  Terminal server reconnect
    ULT_STARTSHELL,         //  About to start the Shell
} USERLOGTYPE;

typedef enum _SWITCHTYPE
{
    SWITCHTYPE_CREATE,      //  Create the switch event and sync event
    SWITCHTYPE_REGISTER,    //  Check the switch event and register wait
    SWITCHTYPE_CANCEL,      //  Cancel the wait and clean up
} SWITCHTYPE;

#define SZ_INTERACTIVE_LOGON_MUTEX_NAME             TEXT("Global\\msgina: InteractiveLogonMutex")
#define SZ_INTERACTIVE_LOGON_REQUEST_MUTEX_NAME     TEXT("Global\\msgina: InteractiveLogonRequestMutex")
#define SZ_INTERACTIVE_LOGON_REPLY_EVENT_NAME       TEXT("Global\\msgina: InteractiveLogonReplyEvent")
#define SZ_SHUT_DOWN_EVENT_NAME                     TEXT("Global\\msgina: ShutdownEvent")

#ifdef      _MSGINA_

//  --------------------------------------------------------------------------
//  This section contains declarations in the DS component of msgina used by
//  the shell component of msgina.
//  --------------------------------------------------------------------------

//  These are GINA internal dialog return codes.

#define MSGINA_DLG_FAILURE                  IDCANCEL
#define MSGINA_DLG_SUCCESS                  IDOK

#define MSGINA_DLG_INTERRUPTED              0x10000000

//  Our own return codes. These should *Not* conflict with the
//  GINA defined ones.

#define MSGINA_DLG_LOCK_WORKSTATION         110
#define MSGINA_DLG_INPUT_TIMEOUT            111
#define MSGINA_DLG_SCREEN_SAVER_TIMEOUT     112
#define MSGINA_DLG_USER_LOGOFF              113
#define MSGINA_DLG_TASKLIST                 114
#define MSGINA_DLG_SHUTDOWN                 115
#define MSGINA_DLG_FORCE_LOGOFF             116
#define MSGINA_DLG_DISCONNECT               117
#define MSGINA_DLG_SWITCH_CONSOLE           118
#define MSGINA_DLG_SWITCH_FAILURE           119
#define MSGINA_DLG_SMARTCARD_INSERTED       120
#define MSGINA_DLG_SMARTCARD_REMOVED        121

//  Additional flags that can be added to the
//  MSGINA_DLG_USER_LOGOFF return code.

#define MSGINA_DLG_SHUTDOWN_FLAG            0x8000
#define MSGINA_DLG_REBOOT_FLAG              0x4000
#define MSGINA_DLG_SYSTEM_FLAG              0x2000  //  System process was initiator
#define MSGINA_DLG_POWEROFF_FLAG            0x1000  //  Poweroff after shutdown
#define MSGINA_DLG_SLEEP_FLAG               0x0800
#define MSGINA_DLG_SLEEP2_FLAG              0x0400
#define MSGINA_DLG_HIBERNATE_FLAG           0x0200
#define MSGINA_DLG_FLAG_MASK                (MSGINA_DLG_SHUTDOWN_FLAG | MSGINA_DLG_REBOOT_FLAG | MSGINA_DLG_SYSTEM_FLAG | MSGINA_DLG_POWEROFF_FLAG | MSGINA_DLG_SLEEP_FLAG | MSGINA_DLG_SLEEP2_FLAG | MSGINA_DLG_HIBERNATE_FLAG)

//  Define the input timeout delay for logon dialogs (seconds)

#define LOGON_TIMEOUT                       120

//  Define an external reference to the HINSTANCE of msgina.dll

EXTERN_C    HINSTANCE       hDllInstance;

//  Functions used (must declare as C and be transparent in functionality).

EXTERN_C    void            _Gina_SasNotify (void *pWlxContext, DWORD dwSASType);
EXTERN_C    BOOL            _Gina_SetTimeout (void *pWlxContext, DWORD dwTimeout);
EXTERN_C    INT_PTR         _Gina_DialogBoxParam (void *pWlxContext, HINSTANCE hInstance, LPCWSTR pszTemplate, HWND hwndParent, DLGPROC pfnDlgProc, LPARAM lParam);
EXTERN_C    INT_PTR         _Gina_MessageBox (void *pWlxContext, HWND hwnd, LPCWSTR pszText, LPCWSTR pszCaption, UINT uiType);
EXTERN_C    int             _Gina_SwitchDesktopToUser (void *pWlxContext);
EXTERN_C    INT_PTR         _Gina_ShutdownDialog (void *pWlxContext, HWND hwndParent, DWORD dwExcludeItems);
EXTERN_C    HANDLE          _Gina_GetUserToken (void *pWlxContext);
EXTERN_C    const WCHAR*    _Gina_GetUsername (void *pWlxContext);
EXTERN_C    const WCHAR*    _Gina_GetDomain (void *pWlxContext);
EXTERN_C    void            _Gina_SetTextFields (HWND hwndDialog, const WCHAR *pwszUsername, const WCHAR *pwszDomain, const WCHAR *pwszPassword);
EXTERN_C    BOOL            _Gina_SetPasswordFocus (HWND hwndDialog);

//  --------------------------------------------------------------------------
//  This section contains declarations in the shell component of msgina used
//  by the DS component of msgina.
//  --------------------------------------------------------------------------

//  These are return results from CW_LogonDialog_Init that inform the caller
//  whether auto logon with no password should be performed, whether the regular
//  Windows 2000 logon dialog should be displayed or whether the consumer windows
//  external UI host will handle the logon information gathering.

#define SHELL_LOGONDIALOG_NONE                      0
#define SHELL_LOGONDIALOG_LOGON                     1
#define SHELL_LOGONDIALOG_EXTERNALHOST              2

#define SHELL_LOGONDIALOG_LOGGEDOFF                 0
#define SHELL_LOGONDIALOG_RETURNTOWELCOME           1
#define SHELL_LOGONDIALOG_RETURNTOWELCOME_UNLOCK    2

#define SHELL_LOGONSTATUS_LOCK_MAGIC_NUMBER         48517

//  Functions used (must declare as C and be transparent in functionality).

EXTERN_C    NTSTATUS    _Shell_DllMain (HINSTANCE hInstance, DWORD dwReason);
EXTERN_C    NTSTATUS    _Shell_Initialize (void *pWlxContext);
EXTERN_C    NTSTATUS    _Shell_Terminate (void);
EXTERN_C    NTSTATUS    _Shell_Reconnect (void);
EXTERN_C    NTSTATUS    _Shell_Disconnect (void);

EXTERN_C    NTSTATUS    _Shell_LogonDialog_StaticInitialize (void);
EXTERN_C    NTSTATUS    _Shell_LogonDialog_StaticTerminate (void);
EXTERN_C    int         _Shell_LogonDialog_Init (HWND hwndDialog, int iDialogType);
EXTERN_C    void        _Shell_LogonDialog_Destroy (void);
EXTERN_C    BOOL        _Shell_LogonDialog_UIHostActive (void);
EXTERN_C    BOOL        _Shell_LogonDialog_Cancel (void);
EXTERN_C    BOOL        _Shell_LogonDialog_LogonDisplayError (NTSTATUS status, NTSTATUS subStatus);
EXTERN_C    void        _Shell_LogonDialog_LogonCompleted (INT_PTR iDialogResult, const WCHAR *pszUsername, const WCHAR *pszDomain);
EXTERN_C    void        _Shell_LogonDialog_ShuttingDown (void);
EXTERN_C    BOOL        _Shell_LogonDialog_DlgProc (HWND hwndDialog, UINT uiMessage, WPARAM wParam, LPARAM lParam);
EXTERN_C    void        _Shell_LogonDialog_ShowUIHost (void);
EXTERN_C    void        _Shell_LogonDialog_HideUIHost (void);

EXTERN_C    NTSTATUS    _Shell_LogonStatus_StaticInitialize (void);
EXTERN_C    NTSTATUS    _Shell_LogonStatus_StaticTerminate (void);
EXTERN_C    void        _Shell_LogonStatus_Init (UINT uiStartType);
EXTERN_C    void        _Shell_LogonStatus_Destroy (UINT uiEndType);
EXTERN_C    BOOL        _Shell_LogonStatus_Exists (void);
EXTERN_C    BOOL        _Shell_LogonStatus_IsStatusWindow (HWND hwnd);
EXTERN_C    BOOL        _Shell_LogonStatus_IsSuspendAllowed (void);
EXTERN_C    BOOL        _Shell_LogonStatus_WaitForUIHost (void);
EXTERN_C    void        _Shell_LogonStatus_ShowStatusMessage (const WCHAR *pszMessage);
EXTERN_C    void        _Shell_LogonStatus_SetStateStatus (int iCode);
EXTERN_C    void        _Shell_LogonStatus_SetStateLogon (int iCode);
EXTERN_C    void        _Shell_LogonStatus_SetStateLoggedOn (void);
EXTERN_C    void        _Shell_LogonStatus_SetStateEnd (void);
EXTERN_C    void        _Shell_LogonStatus_NotifyWait (void);
EXTERN_C    void        _Shell_LogonStatus_NotifyNoAnimations (void);
EXTERN_C    void        _Shell_LogonStatus_SelectUser (const WCHAR *pszUsername, const WCHAR *pszDomain);
EXTERN_C    void        _Shell_LogonStatus_InteractiveLogon (const WCHAR *pszUsername, const WCHAR *pszDomain, WCHAR *pszPassword);
EXTERN_C    void*       _Shell_LogonStatus_GetUIHost (void);
EXTERN_C    HANDLE      _Shell_LogonStatus_ResetReadyEvent (void);
EXTERN_C    void        _Shell_LogonStatus_Show (void);
EXTERN_C    void        _Shell_LogonStatus_Hide (void);
EXTERN_C    BOOL        _Shell_LogonStatus_IsHidden (void);

//  These are functions that implement exports. Stubs are declared
//  in the DS depot to allow the import lib to built without dependency.

EXTERN_C    LONG        _ShellGetUserList (BOOL fRemoveGuest, DWORD *pdwUserCount, void* *pUserList);
EXTERN_C    BOOL        _ShellIsSingleUserNoPassword (WCHAR *pwszUsername, WCHAR *pwszDomain);
EXTERN_C    BOOL        _ShellIsFriendlyUIActive (void);
EXTERN_C    BOOL        _ShellIsMultipleUsersEnabled (void);
EXTERN_C    BOOL        _ShellIsRemoteConnectionsEnabled (void);
EXTERN_C    BOOL        _ShellEnableFriendlyUI (BOOL fEnable);
EXTERN_C    BOOL        _ShellEnableMultipleUsers (BOOL fEnable);
EXTERN_C    BOOL        _ShellEnableRemoteConnections (BOOL fEnable);
EXTERN_C    DWORD       _ShellTurnOffDialog (HWND hwndParent);
EXTERN_C    int         _ShellACPIPowerButtonPressed (void *pWlxContext, UINT uiEventType, BOOL fLocked);
EXTERN_C    BOOL        _ShellIsSuspendAllowed (void);
EXTERN_C    void        _ShellStatusHostBegin (UINT uiStartType);
EXTERN_C    void        _ShellStatusHostEnd (UINT uiEndType);
EXTERN_C    void        _ShellStatusHostShuttingDown (void);
EXTERN_C    void        _ShellStatusHostPowerEvent (void);
EXTERN_C    BOOL        _ShellSwitchWhenInteractiveReady (SWITCHTYPE eSwitchType, void *pWlxContext);
EXTERN_C    HRESULT     _ShellDimScreen (IUnknown* *ppIUnknown, HWND* phwndDimmed);
EXTERN_C    void        _ShellInstallAccountFilterData (void);
EXTERN_C    DWORD       _ShellSwitchUser (BOOL fWait);
EXTERN_C    int         _ShellIsUserInteractiveLogonAllowed (const WCHAR *pwszUsername);
EXTERN_C    void        _ShellNotifyThemeUserChange (USERLOGTYPE eUserLogType, HANDLE hToken);
EXTERN_C    DWORD       _ShellReturnToWelcome (BOOL fUnlock);
EXTERN_C    DWORD       _ShellStartCredentialServer (const WCHAR *pwszUsername, const WCHAR *pwszDomain, WCHAR *pwszPassword, DWORD dwTimeout);
EXTERN_C    void        _ShellAcquireLogonMutex (void);
EXTERN_C    void        _ShellReleaseLogonMutex (BOOL fSignalEvent);
EXTERN_C    void        _ShellSignalShutdown (void);
EXTERN_C    void        _ShellStatusHostHide (void);
EXTERN_C    void        _ShellStatusHostShow (void);

#endif  /*  _MSGINA_    */

//  --------------------------------------------------------------------------
//  This section contains functions exported by ordinal from the shell
//  component of msgina.
//  --------------------------------------------------------------------------

GINASTDAPI_(LONG)       ShellGetUserList (BOOL fRemoveGuest, DWORD *pdwUserCount, void* *pUserList);
GINASTDAPI_(BOOL)       ShellIsSingleUserNoPassword (WCHAR *pwszUsername, WCHAR *pwszDomain);
GINASTDAPI_(BOOL)       ShellIsFriendlyUIActive (void);
GINASTDAPI_(BOOL)       ShellIsMultipleUsersEnabled (void);
GINASTDAPI_(BOOL)       ShellIsRemoteConnectionsEnabled (void);
GINASTDAPI_(BOOL)       ShellEnableFriendlyUI (BOOL fEnable);
GINASTDAPI_(BOOL)       ShellEnableMultipleUsers (BOOL fEnable);
GINASTDAPI_(BOOL)       ShellEnableRemoteConnections (BOOL fEnable);
GINASTDAPI_(DWORD)      ShellTurnOffDialog (HWND hwndParent);
GINASTDAPI_(int)        ShellACPIPowerButtonPressed (void *pWlxContext, UINT uiEventType, BOOL fLocked);
GINASTDAPI_(BOOL)       ShellIsSuspendAllowed (void);
GINASTDAPI_(void)       ShellStatusHostBegin (UINT uiStartType);
GINASTDAPI_(void)       ShellStatusHostEnd (UINT uiEndType);
GINASTDAPI_(void)       ShellStatusHostShuttingDown (void);
GINASTDAPI_(void)       ShellStatusHostPowerEvent (void);
GINASTDAPI_(BOOL)       ShellSwitchWhenInteractiveReady (SWITCHTYPE eSwitchType, void *pWlxContext);
GINASTDAPI              ShellDimScreen (IUnknown* *ppIUnknown, HWND* phwndDimmed);
GINASTDAPI_(void)       ShellInstallAccountFilterData (void);
GINASTDAPI_(DWORD)      ShellSwitchUser (BOOL fWait);
GINASTDAPI_(int)        ShellIsUserInteractiveLogonAllowed (const WCHAR *pwszUsername);
GINASTDAPI_(void)       ShellNotifyThemeUserChange (USERLOGTYPE eUserLogType, HANDLE hToken);
GINASTDAPI_(DWORD)      ShellReturnToWelcome (BOOL fUnlock);
GINASTDAPI_(DWORD)      ShellStartCredentialServer (const WCHAR *pwszUsername, const WCHAR *pwszDomain, WCHAR *pwszPassword, DWORD dwTimeout);
GINASTDAPI_(void)       ShellAcquireLogonMutex (void);
GINASTDAPI_(void)       ShellReleaseLogonMutex (BOOL fSignalEvent);
GINASTDAPI_(void)       ShellSignalShutdown (void);
GINASTDAPI_(void)       ShellStatusHostHide (void);
GINASTDAPI_(void)       ShellStatusHostShow (void);

#endif  /*  _MSGinaExports_     */
=== C:/Users/treeman/Desktop/windows nt source code\Source\Win2K3\NT\public\internal\ds\inc\netlib.h ===
/*++

Copyright (c) 1991-1993  Microsoft Corporation

Module Name:

    NetLib.h

Abstract:

    This header file declares various common routines for use in the
    networking code.

Author:

    John Rogers (JohnRo) 14-Mar-1991

Environment:

    Portable to any flat, 32-bit environment.  (Uses Win32 typedefs.)
    Requires ANSI C extensions: slash-slash comments, long external names.

Notes:

    You must include <windows.h> and <lmcons.h> before this file.

Revision History:

    14-Mar-1991 JohnRo
        Created.
    20-Mar-1991 JohnRo
        Moved NetpPackString here (was NetapipPackString).  Removed tabs.
    21-Mar-1991 RitaW
        Added NetpCopyStringToBuffer.
    02-Apr-1991 JohnRo
        Moved NetpRdrFsControlTree to <netlibnt.h>.
    03-Apr-1991 JohnRo
        Fixed types for NetpCopyStringToBuffer.
    08-Apr-1991 CliffV
        Added NetpCopyDataToBuffer
    10-Apr-1991 JohnRo
        Added NetpSetParmError (descended from CliffV's SetParmError).
    10-Apr-1991 Danl
        Added NetpGetComputerName
    24-Apr-1991 JohnRo
        Avoid conflicts with MIDL-generated files.
        Added NetpAdjustPreferedMaximum().
        NetpCopyStringToBuffer's input string ptr is optional.
    26-Apr-1991 CliffV
        Added NetpAllocateEnumBuffer.
        Added typedefs PTRDIFF_T and BUFFER_DESCRIPTOR.
    16-Apr-1991 JohnRo
        Clarify UNICODE handling of pack and copy routines.
    24-Jul-1991 JohnRo
        Provide NetpIsServiceStarted() for use by <netrpc.h> macros.
    29-Oct-1991 JohnRo
        Added NetpChangeNullCharToNullPtr() macro.
    29-Oct-1991 Danhi
        Add function prototypes for DosxxxMessage Api's
    20-Nov-1991 JohnRo
        Removed NT dependencies to reduce recompiles.
    09-Jan-1992 JohnRo
        Added NetpGetDomainName().
    23-Jan-1992 JohnRo
        Added IN_RANGE() macro based on MadanA's RANGECHECK().
    25-Mar-1992 RitaW
        Added SET_SERVICE_EXITCODE() macro for setting Win32 vs
        service specific exitcode.
    06-May-1992 JohnRo
        Added NetpGetLocalDomainId() for PortUAS.
        Added NetpTranslateServiceName() for service controller APIs.
    27-Jul-1992 Madana
        Added NetpWriteEventlog function proto type.
    05-Aug-1992 JohnRo
        RAID 3021: NetService APIs don't always translate svc names.
    09-Sep-1992 JohnRo
        RAID 1090: net start/stop "" causes assertion.
    14-Oct-1992 JohnRo
        RAID 9020: setup: PortUas fails ("prompt on conflicts" version).
    02-Nov-1992 JohnRo
        Added NetpIsRemoteServiceStarted().
    15-Feb-1993 JohnRo
        RAID 10685: user name not in repl event log.
    24-Mar-1993 JohnRo
        Repl svc shuold use DBFlag in registry.
    05-Aug-1993 JohnRo
        RAID 17010: Implement per-first-level-directory change notify.
    19-Aug-1993 JohnRo
        RAID 2822: PortUAS maps chars funny.  (Workaround FormatMessageA bug.)
        RAID 3094: PortUAS displays chars incorrectly.

--*/

#ifndef _NETLIB_
#define _NETLIB_

// These may be included in any order:

#include <string.h>             // memcpy().

// Don't complain about "unneeded" includes of this file:
/*lint -efile(764,wchar.h) */
/*lint -efile(766,wchar.h) */
#include <wchar.h>      // iswdigit().

#ifdef CDEBUG                   // Debug in ANSI C environment?

#include <netdebug.h>           // NetpAssert().

#endif // ndef CDEBUG


#ifdef __cplusplus
extern "C" {
#endif

//
// IN_RANGE(): Make sure SomeValue is between SomeMin and SomeMax.
// Beware side-effects (SomeValue is evaluated twice).
// Created by JohnRo from MadanA's RANGECHECK().
//
// BOOL
// IN_RANGE(
//     IN DWORD SomeValue,
//     IN DWORD SomeMin,
//     IN DWORD SomeMax
//     );
//
#define IN_RANGE(SomeValue, SomeMin, SomeMax) \
    ( ((SomeValue) >= (SomeMin)) && ((SomeValue) <= (SomeMax)) )


//
// SET_SERVICE_EXITCODE() sets the SomeApiStatus to NetCodeVariable
// if it is within the NERR_BASE and NERR_MAX range.  Otherwise,
// Win32CodeVariable is set.  This original code came from JohnRo.
//
#define SET_SERVICE_EXITCODE(SomeApiStatus, Win32CodeVariable, NetCodeVariable) \
    {                                                                  \
        if ((SomeApiStatus) == NERR_Success) {                         \
            (Win32CodeVariable) = NO_ERROR;                            \
            (NetCodeVariable) = NERR_Success;                          \
        } else if (! IN_RANGE((SomeApiStatus), MIN_LANMAN_MESSAGE_ID, MAX_LANMAN_MESSAGE_ID)) { \
            (Win32CodeVariable) = (DWORD) (SomeApiStatus);             \
            (NetCodeVariable) = (DWORD) (SomeApiStatus);               \
        } else {                                                       \
            (Win32CodeVariable) = ERROR_SERVICE_SPECIFIC_ERROR;        \
            (NetCodeVariable) = (DWORD) (SomeApiStatus);               \
        }                                                              \
    }


VOID
NetpAdjustPreferedMaximum (
    IN DWORD PreferedMaximum,
    IN DWORD EntrySize,
    IN DWORD Overhead,
    OUT LPDWORD BytesToAllocate OPTIONAL,
    OUT LPDWORD EntriesToAllocate OPTIONAL
    );

// Portable memory move/copy routine:  This is intended to have exactly
// the semantics of ANSI C's memcpy() routine, except that the byte count
// is 32 bits long.
//
// VOID
// NetpMoveMemory(
//     OUT LPBYTE Dest,         // Destination (must not be NULL).
//     IN LPBYTE Src,           // Source
//     IN DWORD Size            // Byte count
//     );

#ifdef CDEBUG

// Note that C6 version doesn't allow 32-bit Size, hence the
// assertion.  Replace this macro with another if this is a problem.

#define NetpMoveMemory(Dest,Src,Size)                                   \
                {                                                       \
                    NetpAssert( (Size) == (DWORD) (size_t) (Size));     \
                    (void) memcpy( (Dest), (Src), (size_t) (Size) );    \
                }

#else // ndef CDEBUG

#define NetpMoveMemory(Dest,Src,Size)                                   \
                (void) memcpy( (Dest), (Src), (size_t) (Size) )

#endif // ndef CDEBUG

DWORD
NetpPackString(
    IN OUT LPWSTR * string,     // pointer by reference: string to be copied.
    IN LPBYTE dataend,          // pointer to end of fixed size data.
    IN OUT LPWSTR * laststring  // pointer by reference: top of string data.
    );

//
// This routine is like NetpPackString, except that it does not expect the
// caller to assign the pointer of the source string to the variable in the
// fixed size structure before the call.  It also takes a string character
// count parameter instead of calling strlen on String.
//

BOOL
NetpCopyStringToBuffer (
    IN LPWSTR String OPTIONAL,
    IN DWORD CharacterCount,
    IN LPBYTE FixedDataEnd,
    IN OUT LPWSTR *EndOfVariableData,
    OUT LPWSTR *VariableDataPointer
    );

//
// This routine is like NetpCopyStringToBuffer except it copies any data
// (not just strings), it does not put a zero byte at the end of the
// data, and it allows the alignment of the resultant copied data to be
// specified.
//

BOOL
NetpCopyDataToBuffer (
    IN LPBYTE Data,
    IN DWORD ByteCount,
    IN LPBYTE FixedDataEnd,
    IN OUT LPBYTE *EndOfVariableData,
    OUT LPBYTE *VariableDataPointer,
    IN DWORD Alignment
    );

//
// Declare a type for the difference between two pointers.
//
// This must be at least as long as a ptrdiff_t but we don't want to
// add a dependency on <stddef.h> here.
//

typedef DWORD_PTR PTRDIFF_T;


//
// Declare a description of an enumeration buffer.
//

typedef struct _BUFFER_DESCRIPTOR {
    LPBYTE Buffer;        // Pointer to the allocated buffer.
    DWORD AllocSize;      // Current size of the allocated buffer.
    DWORD AllocIncrement; // Amount to increment size by on each reallocate.

    LPBYTE EndOfVariableData;// Pointer past last avaliable byte of string space
    LPBYTE FixedDataEnd;  // Pointer past last used byte of fixed data space

} BUFFER_DESCRIPTOR, *PBUFFER_DESCRIPTOR;

//
// This routine handles all the details of allocating and growing a
// buffer returned from an enumeration function.  It takes the users
// prefered maximum size into consideration.
//

#define NETP_ENUM_GUESS 16384 // Initial guess for enumeration buffer size

NET_API_STATUS
NetpAllocateEnumBuffer(
    IN OUT PBUFFER_DESCRIPTOR BufferDescriptor,
        // Caller must deallocate BD->Buffer using MIDL_user_free.

    IN BOOL IsGet,
    IN DWORD PrefMaxSize,
    IN DWORD NeededSize,
    IN VOID (*RelocationRoutine)( IN DWORD RelocationParameter,
                                  IN OUT PBUFFER_DESCRIPTOR BufferDescriptor,
                                  IN PTRDIFF_T Offset ),
    IN DWORD RelocationParameter
    );

NET_API_STATUS
NetpAllocateEnumBufferEx(
    IN OUT PBUFFER_DESCRIPTOR BufferDescriptor,
    IN BOOL IsGet,
    IN DWORD PrefMaxSize,
    IN DWORD NeededSize,
    IN VOID (*RelocationRoutine)( IN DWORD RelocationParameter,
                                  IN OUT PBUFFER_DESCRIPTOR BufferDescriptor,
                                  IN PTRDIFF_T Offset ),
    IN DWORD RelocationParameter,
    IN DWORD IncrementalSize
    );

BOOL
NetpIsServiceStarted(
    IN LPWSTR ServiceName
    );

//
// Portable memory allocation routines.  Memory is per-process only.
//

// Allocate memory, or return NULL if not available.

LPVOID
NetpMemoryAllocate(
    IN DWORD Size
    );

// Free memory at Address (must have been gotten from NetpMemoryAllocate or
// NetpMemoryReallocate).  (Address may be NULL.)

VOID
NetpMemoryFree(
    IN LPVOID Address OPTIONAL
    );

// Reallocate block (now at OldAddress) to NewSize.  OldAddress may be NULL.
// Contents of block are copied if necessary.  Returns NULL if unable to
// allocate additional storage.

LPVOID
NetpMemoryReallocate(
    IN LPVOID OldAddress OPTIONAL,
    IN DWORD NewSize
    );

//
// Random handy macros:
//
#define NetpPointerPlusSomeBytes(p,n)                                   \
                (LPBYTE)  ( ( (LPBYTE) (p)) + (n) )

#define NetpSetOptionalArg(arg, value) \
    {                         \
        if ((arg) != NULL) {  \
            *(arg) = (value); \
        }                     \
    }

//
// Set the optional ParmError parameter
//

#define NetpSetParmError( _ParmNumValue ) \
    if ( ParmError != NULL ) { \
        *ParmError = (_ParmNumValue); \
    }

#if defined(lint) || defined(_lint)
#define UNUSED(x)               { (x) = (x); }
#else
#define UNUSED(x)               { (void) (x); }
#endif

//
// NetpGetComputerName retrieves the local computername from the local
// configuration database.
//

NET_API_STATUS
NetpGetComputerName (
    IN  LPWSTR   *ComputerNamePtr);

NET_API_STATUS
NetpGetComputerNameEx (
    IN  LPWSTR   *ComputerNamePtr,
    IN  BOOL PhysicalNetbiosName
    );

NET_API_STATUS
NetpGetDomainName (
    OUT LPWSTR *DomainNamePtr  // alloc and set ptr (free with NetApiBufferFree)
    );

NET_API_STATUS
NetpGetDomainNameEx (
    OUT LPWSTR *DomainNamePtr, // alloc and set ptr (free with NetApiBufferFree)
    OUT PBOOLEAN IsWorkgroupName
    );

NET_API_STATUS
NetpGetDomainNameExEx (
    OUT LPWSTR *DomainNamePtr,
    OUT LPWSTR *DnsDomainNamePtr OPTIONAL,
    OUT PBOOLEAN IsWorkgroupName
    );

#ifndef GUID_DEFINED
#define GUID_DEFINED
typedef struct  _GUID
    {
    DWORD Data1;
    WORD Data2;
    WORD Data3;
    BYTE Data4[ 8 ];
    } GUID;

#endif // !GUID_DEFINED

NET_API_STATUS
NetpGetDomainNameExExEx (
    OUT LPTSTR *DomainNamePtr,
    OUT LPTSTR *DnsDomainNamePtr OPTIONAL,
    OUT LPTSTR *DnsForestNamePtr OPTIONAL,
    OUT GUID **DomainGuidPtr OPTIONAL,
    OUT PBOOLEAN IsWorkgroupName
    );

typedef enum _LOCAL_DOMAIN_TYPE {
    LOCAL_DOMAIN_TYPE_ACCOUNTS,
    LOCAL_DOMAIN_TYPE_BUILTIN,
    LOCAL_DOMAIN_TYPE_PRIMARY
} LOCAL_DOMAIN_TYPE, *PLOCAL_DOMAIN_TYPE, *LPLOCAL_DOMAIN_TYPE;

NET_API_STATUS
NetpGetLocalDomainId (
    IN LOCAL_DOMAIN_TYPE TypeWanted,
    OUT PSID *RetDomainId     // alloc and set ptr (free with LocalFree)
    );

//
// NetService API helpers
//

// BOOL
// NetpIsServiceLevelValid(
//     IN DWORD Level
//     );
//
#define NetpIsServiceLevelValid( Level ) \
     ( ((Level)==0) || ((Level)==1) || ((Level)==2) )

NET_API_STATUS
NetpTranslateNamesInServiceArray(
    IN DWORD Level,
    IN LPVOID ArrayBase,
    IN DWORD EntryCount,
    IN BOOL PreferNewStyle,
    OUT LPVOID * NewArrayBase
    );

NET_API_STATUS
NetpTranslateServiceName(
    IN LPWSTR GivenServiceName,
    IN BOOL PreferNewStyle,
    OUT LPWSTR * TranslatedName
    );

//
// Mapping routines to map DosxxxMessage API's to FormatMessage
//


WORD
DosGetMessage(
    IN LPSTR * InsertionStrings,
    IN WORD NumberofStrings,
    OUT LPBYTE Buffer,
    IN WORD BufferLength,
    IN WORD MessageId,
    IN LPWSTR FileName,
    OUT PWORD pMessageLength
    );

DWORD
NetpGetPrivilege(
    IN  DWORD       numPrivileges,
    IN  PULONG      pulPrivileges
    );

DWORD
NetpReleasePrivilege(
    VOID
    );

DWORD
NetpWriteEventlog(
    LPWSTR Source,
    DWORD EventID,
    DWORD EventType,
    DWORD NumStrings,
    LPWSTR *Strings,
    DWORD DataLength,
    LPVOID Data
    );

DWORD
NetpRaiseAlert(
    IN LPWSTR ServiceName,
    IN DWORD alert_no,
    IN LPWSTR *string_array
    );

//
// Special flags to NetpEventlogWrite
//

#define NETP_LAST_MESSAGE_IS_NTSTATUS  0x80000000
#define NETP_LAST_MESSAGE_IS_NETSTATUS 0x40000000
#define NETP_ALLOW_DUPLICATE_EVENTS    0x20000000
#define NETP_RAISE_ALERT_TOO           0x10000000
#define NETP_STRING_COUNT_MASK         0x000FFFFF

HANDLE
NetpEventlogOpen (
    IN LPWSTR Source,
    IN ULONG DuplicateEventlogTimeout
    );

DWORD
NetpEventlogWrite (
    IN HANDLE NetpEventHandle,
    IN DWORD EventId,
    IN DWORD EventType,
    IN LPBYTE RawDataBuffer OPTIONAL,
    IN DWORD RawDataSize,
    IN LPWSTR *StringArray,
    IN DWORD StringCount
    );

//
// extended version with re-arranged parameters + category, to be more
// compatible with ReportEvent().
//

DWORD
NetpEventlogWriteEx (
    IN HANDLE NetpEventHandle,
    IN DWORD EventType,
    IN DWORD EventCategory,
    IN DWORD EventId,
    IN DWORD StringCount,
    IN DWORD RawDataSize,
    IN LPWSTR *StringArray,
    IN LPVOID RawDataBuffer OPTIONAL
    );

//
// even more extended version to allow specifying
// arbitrary message index for the status code
//

DWORD
NetpEventlogWriteEx2 (
    IN HANDLE NetpEventHandle,
    IN DWORD EventType,
    IN DWORD EventCategory,
    IN DWORD EventId,
    IN DWORD StringCount,
    IN DWORD StatusMessageIndex,
    IN DWORD RawDataSize,
    IN LPWSTR *StringArray,
    IN LPVOID pvRawDataBuffer OPTIONAL
    );

VOID
NetpEventlogClearList (
    IN HANDLE NetpEventHandle
    );

VOID
NetpEventlogSetTimeout (
    IN HANDLE NetpEventHandle,
    IN ULONG DuplicateEventlogTimeout
    );

VOID
NetpEventlogClose (
    IN HANDLE NetpEventHandle
    );

#ifdef __cplusplus
}
#endif

#endif // ndef _NETLIB_
=== C:/Users/treeman/Desktop/windows nt source code\Source\Win2K3\NT\public\internal\ds\inc\nlmon.h ===
/*--

Copyright (c) 1993  Microsoft Corporation

Module Name:

    nlmon.h

Abstract:

    Trusted Domain monitor program.

Author:

    10-May-1993 (madana)

Environment:

    User mode only.
    Contains NT-specific code.
    Requires ANSI C extensions: slash-slash comments, long external names.

Revision History:

--*/

#include <nt.h>
#include <ntlsa.h>
#include <ntsam.h>
#include <ntrtl.h>
#include <nturtl.h>

#include <windef.h>
#include <winbase.h>

#include <stdio.h>
#include <conio.h>
#include <string.h>
#include <stdlib.h>

#include <lmcons.h>
#include <lmerr.h>
#include <lmwksta.h>
#include <lmserver.h>
#include <lmaccess.h>
#include <lmapibuf.h>

#include <netlib.h>
#include <netlibnt.h>
#include <icanon.h>
#include <netlogon.h>
#include <netdebug.h>
#include <logonp.h>

#ifdef GLOBAL_DEF
#define EXTERN
#else
#define EXTERN extern
#endif

#ifdef DBG
#define NlMonDbgPrint(_x_) printf _x_
#else
#define NlMonDbgPrint(_x_)
#endif

#define DOMAIN_PARAM    "/DOMAINLIST:"
#define MONTRUST_PARAM  "/MONTRUST:"
#define UPDATE_PARAM    "/UPDATE:"
#define DEBUG_PARAM     "/DEBUG:"

#define YES_PARAM       "YES"
#define NO_PARAM        "NO"

#define DEBUG_MONITOR   0x00000001
#define DEBUG_INIT      0x00000002
#define DEBUG_UPDATE    0x00000004
#define DEBUG_TRUST     0x00000008
#define DEBUG_VERBOSE   0x80000000

#define IF_DEBUG(Function) if (GlobalTrace & DEBUG_ ## Function)

#define INIT_OBJ_ATTR(Obj) \
    InitializeObjectAttributes( &(Obj), NULL, 0, NULL, NULL )

#define SERVERS_GROUP       L"SERVERS"

#define DCSTATE_ONLINE      L"DCOnline"
#define DCSTATE_OFFLINE     L"DCOffLine"
#define TYPE_NTPDC          L"NTPDC"
#define TYPE_NTBDC          L"NTBDC"
#define TYPE_LMBDC          L"LMBDC"
#define REPL_STATE_SYNC     L"InSync"
#define REPL_STATE_REQ      L"ReplRequired"
#define REPL_STATE_PROGRESS L"InProgress"
#define UNKNOWN             L"Unknown"

#define CONST_GLOBALTRACE           0x00000000
#define CONST_GLOBALMONITORTRUST    FALSE
#define CONST_GLOBALUPDATETIME      15

#define RETRY_COUNT                 5
#define UNKNOWN_REPLICATION_STATE   0x80000000

//
// update flags.
//

#define UPDATE_DCS_FROM_SERVER_ENUM         0x00000001
#define UPDATE_DCS_FROM_DATABASE            0x00000002
#define UPDATE_TRUST_DOMAINS_FROM_DATABASE  0x00000004
#define UPDATE_TRUST_DCS_FROM_SERVER_ENUM   0x00000008
#define UPDATE_TRUST_DCS_FROM_DATABASE      0x00000010
#define VALIDATE_DCS                        0x00000020
#define VALIDATE_TRUST_DCS                  0x00000040
#define VALIDATE_TRUST_CONNECTIONS          0x00000080

#define STANDARD_UPDATE \
            UPDATE_DCS_FROM_SERVER_ENUM | \
            VALIDATE_DCS | \
            UPDATE_TRUST_DCS_FROM_SERVER_ENUM | \
            VALIDATE_TRUST_DCS \

#define UPDATE_FROM_DATABASE \
            STANDARD_UPDATE | \
            UPDATE_DCS_FROM_DATABASE | \
            UPDATE_TRUST_DCS_FROM_DATABASE

#define UPDATE_TRUST_CONNECTIONS_STATUS \
            STANDARD_UPDATE | \
            VALIDATE_TRUST_CONNECTIONS

#define UPDATE_ALL \
            STANDARD_UPDATE | \
            UPDATE_FROM_DATABASE | \
            UPDATE_TRUST_CONNECTIONS_STATUS | \
            UPDATE_TRUST_DOMAINS_FROM_DATABASE

#define DOMAINLINE "............................................................................"
#define SESSLINE "****************************************************************************"

#define THREAD_STACKSIZE            1024 * 16   // 16K.
#define MACHINES_PER_PASS           250 // SAM machine acct. query size.

#define THREAD_WAIT_TIME            1 * 60 * 1000 // 1 min.

typedef enum _DC_STATE {
    DCOnLine,               // DC currently on running.
    DCOffLine               // DC currently down.
} DC_STATE;

typedef enum _DC_TYPE {
    NTPDC,                  // NT Primary DC.
    NTBDC,                  // NT Backup DC.
    LMBDC,                  // Downlevel Backup DC.
} DC_TYPE;

typedef enum _DOMAIN_STATE {
    DomainSuccess,
    DomainProblem,
    DomainSick,
    DomainDown,
    DomainUnknown,
} DOMAIN_STATE;

//
// generic entry
//

typedef struct _ENTRY {
    LIST_ENTRY NextEntry;
    UNICODE_STRING Name;
} ENTRY, *PENTRY;

//
// DC entry.
//

typedef struct _DC_ENTRY {
    LIST_ENTRY NextEntry;       // don't move this field
    UNICODE_STRING DCName;      // don't move this field
    DC_STATE State;
    DC_TYPE Type;
    DWORD DCStatus;             // DC Status
    DWORD ReplicationStatus;    // boolean flag bit array.
    DWORD PDCLinkStatus;        // To its PDC link status.
    LIST_ENTRY TrustedDCs;
    BOOL TDCLinkState;          // health of the trust connections.
    DWORD RetryCount;
    BOOL DeleteFlag;
} DC_ENTRY, *PDC_ENTRY;

//
// Trust Link entry.
//

typedef struct _TD_LINK {
    LIST_ENTRY NextEntry;       // don't move this field
    UNICODE_STRING TDName;      // don't move this field
    UNICODE_STRING DCName;
    DWORD SecureChannelStatus;
    BOOL DeleteFlag;
} TD_LINK, *PTD_LINK;

typedef struct _DOMAIN_ENTRY {
    LIST_ENTRY NextEntry;       // don't move this field
    UNICODE_STRING Name;        // don't move this field
    LIST_ENTRY DCList;
    LIST_ENTRY TrustedDomainList;
    DOMAIN_STATE DomainState;
    LONG ReferenceCount;
    BOOL IsMonitoredDomain;
    DWORD UpdateFlags;
    HANDLE ThreadHandle;
    BOOL ThreadTerminateFlag;
    DWORD LastUpdateTime;
} DOMAIN_ENTRY, *PDOMAIN_ENTRY;

typedef struct _DOMAIN_PRIVATE_ENTRY{
    LIST_ENTRY NextEntry;       // don't move this field
    UNICODE_STRING Name;        // don't move this field
    PDOMAIN_ENTRY DomainEntry;
    BOOL DeleteFlag;
} MONITORED_DOMAIN_ENTRY, *PMONITORED_DOMAIN_ENTRY,
  TRUSTED_DOMAIN_ENTRY, *PTRUSTED_DOMAIN_ENTRY;


//
// Global variables
//

EXTERN DWORD GlobalTrace;

EXTERN BOOL GlobalMonitorTrust;
EXTERN DWORD GlobalUpdateTimeMSec;  // UpdateTime in micro secs.

EXTERN LIST_ENTRY GlobalDomains;
EXTERN LIST_ENTRY GlobalDomainsMonitored;

EXTERN CRITICAL_SECTION GlobalListCritSect;
EXTERN CRITICAL_SECTION GlobalDomainUpdateThreadCritSect;
EXTERN HANDLE GlobalWorkerThreadHandle;
EXTERN HANDLE GlobalCmdProcessThreadHandle;
EXTERN HANDLE GlobalTerminateEvent;
EXTERN BOOL GlobalTerminateFlag;

EXTERN HANDLE GlobalUpdateEvent;
EXTERN BOOL GlobalInitialized;

EXTERN HANDLE GlobalRefreshEvent;
EXTERN HANDLE GlobalRefreshDoneEvent;

//
// This lock is a very simple lock. The list is updated (ie,
// add/delete/update an entry) after locking it using this lock.
// The reader of the list may lock the list if they don't want it
// updated while reading.
//

#define LOCK_LISTS()   EnterCriticalSection( &GlobalListCritSect )
#define UNLOCK_LISTS() LeaveCriticalSection( &GlobalListCritSect )


//
// proto types.
//

VOID
DomainUpdateThread(
    PDOMAIN_ENTRY DomainEntry
    );

BOOL
StartDomainUpdateThread(
    PDOMAIN_ENTRY DomainEntry,
    DWORD UpdateFlags
    );

BOOL
IsDomainUpdateThreadRunning(
    HANDLE *ThreadHandle
    );

VOID
StopDomainUpdateThread(
    HANDLE *ThreadHandle,
    BOOL *ThreadTerminateFlag
    );

PMONITORED_DOMAIN_ENTRY
AddToMonitoredDomainList(
    PUNICODE_STRING DomainName
    );

PTRUSTED_DOMAIN_ENTRY
AddToTrustedDomainList(
    PLIST_ENTRY List,
    PUNICODE_STRING DomainName
    );

NTSTATUS
QueryLsaInfo(
    PUNICODE_STRING ServerName,
    ACCESS_MASK DesiredAccess,
    POLICY_INFORMATION_CLASS InformationClass,
    PVOID *Info,
    PLSA_HANDLE ReturnHandle //optional
    );

VOID
CleanupLists(
    VOID
    );

DWORD
InitGlobals(
    VOID
    );

VOID
UpdateAndValidateDomain(
    PDOMAIN_ENTRY DomainEntry,
    DWORD UpdateFlags
    );

VOID
UpdateAndValidateLists(
    DWORD UpdateFlags,
    BOOL ForceFlag
    );

VOID
WorkerThread(
    VOID
    );

DWORD
StartMonitor(
    LPWSTR DomainList,
    DWORD interval,
    BOOL MonitorTD
    );

DOMAIN_STATE
QueryHealth(
    const LPWSTR DomainName
    );

VOID
StopMonitor(
    VOID
    );

LPWSTR
QueryPDC(
    const LPWSTR DomainName
    );

PLIST_ENTRY
QueryTrustedDomain(
    const LPWSTR DomainName
    );

PLIST_ENTRY
QueryDCList(
    const LPWSTR DomainName
    );

PLIST_ENTRY
QueryTDLink(
    const LPWSTR DomainName,
    const LPWSTR DCName
    );

PLIST_ENTRY
QueryTDCList(
    const LPWSTR DomainName,
    const LPWSTR TrustedDomainName);

DWORD
DisConnect(
    const LPWSTR DomainName,
    const LPWSTR DCName,
    const LPWSTR TrustedDomainName
    );

VOID
AddDomainToList(
    const LPWSTR DomainName
    );

VOID
RemoveDomainFromList(
    const LPWSTR DomainName
    );

BOOL
InitDomainListW(
    LPWSTR DomainList
    );

PLIST_ENTRY
FindNamedEntry(
    PLIST_ENTRY List,
    PUNICODE_STRING Name
    );

VOID
CleanupDomainEntry(
    PDOMAIN_ENTRY DomainEntry
    );

VOID
UpdateDomainState(
    PDOMAIN_ENTRY DomainEntry
    );

NET_API_STATUS
IsValidNTDC(
    PUNICODE_STRING ServerName,
    PUNICODE_STRING DomainName
    );
=== C:/Users/treeman/Desktop/windows nt source code\Source\Win2K3\NT\public\internal\ds\inc\ntdsadef.h ===
/* Definitions from the NTDSA that are exposed to the rest of NT, but not
 * to the public at large.
 */

#define MAX_RDN_SIZE          255   /* The max size of an relative name value,
                                     * in Unicode characters */
#define MAX_RDN_KEY_SIZE      256    /* The max size of a RDN Key eg: "CN=" */
                                     /* or "OID.1.2...=" */
//
// This named event is set when the delayed start up thread is finished 
// successfully or otherwise.  In-proc clients can use 
// DsWaitUntilDelayedStartupIsDone() wait and recieve the ntstatus of the
// delayed thread.  Out of proc clients can wait on this event; there is 
// no mechanism to retrieve the return code.
//
#define NTDS_DELAYED_STARTUP_COMPLETED_EVENT TEXT("NtdsDelayedStartupCompletedEvent")


/*
 * Bit flags for the (read-only) system-Flags attribute.  Note that low order
 * bits are object class specific, and hence can have different meanings on
 * objects of different classes, the high order bits have constant meaning
 * across all object classes.
 */

/* Object Class independent bits */
// NOTE: These flags MAY have different behaviour in different NCs.
// For example, the FLAG_CONFIG_foo flags only have meaning inside the
// configuration NC.  the FLAG_DOMAIN_foo flags have meaning only outside the
// configuration NC.  
#define FLAG_DISALLOW_DELETE           0x80000000
#define FLAG_CONFIG_ALLOW_RENAME       0x40000000 
#define FLAG_CONFIG_ALLOW_MOVE         0x20000000 
#define FLAG_CONFIG_ALLOW_LIMITED_MOVE 0x10000000 
#define FLAG_DOMAIN_DISALLOW_RENAME    0x08000000
#define FLAG_DOMAIN_DISALLOW_MOVE      0x04000000
#define FLAG_DISALLOW_MOVE_ON_DELETE   0x02000000

/* Object Class specific bits, by object class */

/* CrossReference objects */
#define FLAG_CR_NTDS_NC       0x00000001 // NC is in NTDS (not VC or foreign)
#define FLAG_CR_NTDS_DOMAIN   0x00000002 // NC is a domain (not non-domain NC)
#define FLAG_CR_NTDS_NOT_GC_REPLICATED 0x00000004 // NC is not to be replicated to GCs as a read only replica.

/* Attribute-Schema objects */
#define FLAG_ATTR_NOT_REPLICATED         (0x00000001) // Attribute is not replicated
#define FLAG_ATTR_REQ_PARTIAL_SET_MEMBER (0x00000002) // Attribute is required to be
                                                      //   member of the partial set
#define FLAG_ATTR_IS_CONSTRUCTED         (0x00000004) // Attribute is a constructed att
#define FLAG_ATTR_IS_OPERATIONAL         (0x00000008) // Attribute is an operational att

/* Attribute-Schema or Class-Schema objects */
#define FLAG_SCHEMA_BASE_OBJECT          (0x00000010) // Base schema object

/* Attribute-Schema objects */
// A user may set, but not reset, FLAG_ATTR_IS_RDN in attributeSchema
// objects in the SchemaNC. The user sets FLAG_ATTR_IS_RDN to identify
// which of several attributes with the same attributeId should be
// used as the rdnattid of a new class. Once set, the attribute is
// treated as if it were used as the rdnattid of some class; meaning it
// cannot be reused.
#define FLAG_ATTR_IS_RDN                 (0x00000020) // can be used as key in rdn (key=rdn)
=== C:/Users/treeman/Desktop/windows nt source code\Source\Win2K3\NT\public\internal\ds\inc\ntdsapip.h ===
#ifndef _NTDSAPIP_H_
#define _NTDSAPIP_H_

// Private definitions related to sdk\inc\ntdsapi.h.

// The following are DS_NAME_FORMATs which we don't want to publish
// in ntdsapi.h.  Although DS_NAME_FORMAT is an enumerated type, we 
// pass vanilla DWORDs on the wire such that RPC doesn't complain about
// enumerated type values out of range or unknown.  These should be
// defined at the high end of the range so we can extend DS_NAME_FORMAT
// in future versions w/o holes which will leave people wondering and
// experimenting what those "unused" values are used for.

#define DS_LIST_SITES                           0xffffffff
#define DS_LIST_SERVERS_IN_SITE                 0xfffffffe
#define DS_LIST_DOMAINS_IN_SITE                 0xfffffffd
#define DS_LIST_SERVERS_FOR_DOMAIN_IN_SITE      0xfffffffc
#define DS_LIST_INFO_FOR_SERVER                 0xfffffffb
#define DS_LIST_ROLES                           0xfffffffa
#define DS_NT4_ACCOUNT_NAME_SANS_DOMAIN         0xfffffff9
#define DS_MAP_SCHEMA_GUID                      0xfffffff8
#define DS_LIST_DOMAINS                         0xfffffff7
#define DS_LIST_NCS                             0xfffffff6
#define DS_ALT_SECURITY_IDENTITIES_NAME         0xfffffff5
#define DS_STRING_SID_NAME                      0xfffffff4
#define DS_LIST_SERVERS_WITH_DCS_IN_SITE        0xfffffff3
#define DS_USER_PRINCIPAL_NAME_FOR_LOGON        0xfffffff2
#define DS_LIST_GLOBAL_CATALOG_SERVERS          0xfffffff1
#define DS_NT4_ACCOUNT_NAME_SANS_DOMAIN_EX      0xfffffff0
#define DS_USER_PRINCIPAL_NAME_AND_ALTSECID     0xffffffef

// following should always be equal to lowest private #define
#define DS_NAME_FORMAT_PRIVATE_BEGIN            0xffffffef

// The following are DS_NAME_ERRORs which we don't want to publish
// in ntdsapi.h.  Same reasoning as above.

#define DS_NAME_ERROR_IS_FPO                    0xffffffff
#define DS_NAME_ERROR_SCHEMA_GUID_NOT_FOUND     0xfffffffe
#define DS_NAME_ERROR_SCHEMA_GUID_ATTR          0xfffffffd
#define DS_NAME_ERROR_SCHEMA_GUID_ATTR_SET      0xfffffffc
#define DS_NAME_ERROR_SCHEMA_GUID_CLASS         0xfffffffb
#define DS_NAME_ERROR_SCHEMA_GUID_CONTROL_RIGHT 0xfffffffa
#define DS_NAME_ERROR_IS_SID_USER               0xfffffff9
#define DS_NAME_ERROR_IS_SID_GROUP              0xfffffff8
#define DS_NAME_ERROR_IS_SID_ALIAS              0xfffffff7
#define DS_NAME_ERROR_IS_SID_UNKNOWN            0xfffffff6
#define DS_NAME_ERROR_IS_SID_HISTORY_USER       0xfffffff5
#define DS_NAME_ERROR_IS_SID_HISTORY_GROUP      0xfffffff4
#define DS_NAME_ERROR_IS_SID_HISTORY_ALIAS      0xfffffff3
#define DS_NAME_ERROR_IS_SID_HISTORY_UNKNOWN    0xfffffff2

// following should always be equal to lowest private #define
#define DS_NAME_ERROR_PRIVATE_BEGIN             0xfffffff2

// The following are DS_NAME_FLAGs which we don't want to publish
// in ntdsapi.h.  Same reasoning as above.  Remember that the flags
// field is a bit map, not an enumeration.

#define DS_NAME_FLAG_PRIVATE_PURE_SYNTACTIC     0x40000000
#define DS_NAME_FLAG_PRIVATE_RESOLVE_FPOS       0x80000000
// following should always be equal to lowest private #define
#define DS_NAME_FLAG_PRIVATE_BEGIN              0x80000000

// The following are DS_ADDSID_FLAGs which we don't want to publish
// in ntdsapi.h.  Same reasoning as above.  Remember that the flags
// field is a bit map, not an enumeration.

#define DS_ADDSID_FLAG_PRIVATE_DEL_SRC_OBJ      0x80000000
#define DS_ADDSID_FLAG_PRIVATE_CHK_SECURE       0x40000000
// following should always be equal to lowest private #define
#define DS_ADDSID_FLAG_PRIVATE_BEGIN            0x40000000

// The following are dc info infolevels that we don't want to publish.
// While the published APIs are used to get information from the set of
// DCs published in a domain, some of these private infolevels are used
// to get information from a single domain controller. These private
// infolevels are intended mostly for debugging and monitoring.

#define DS_DCINFO_LEVEL_FFFFFFFF                0xffffffff

// following should always be equal to lowest private #define
#define DS_DCINFO_LEVEL_PRIVATE_BEGIN           0xffffffff

// For DS_DOMAIN_CONTROLLER_INFO_FFFFFFFF. This retrieves the ldap 
// connection list from a single domain controller.

typedef struct _DS_DOMAIN_CONTROLLER_INFO_FFFFFFFFW {

    DWORD   IPAddress;          // IP Address of client
    DWORD   NotificationCount;  // number of outstanding notifications
    DWORD   secTimeConnected;   // total time in seconds connected
    DWORD   Flags;              // Connection properties. defined below.
    DWORD   TotalRequests;      // Total number of requests made
    DWORD   Reserved1;          // Unused
#ifdef MIDL_PASS
    [string,unique] WCHAR   *UserName;
#else
    LPWSTR  UserName;           // the security principal used to bind
#endif

} DS_DOMAIN_CONTROLLER_INFO_FFFFFFFFW, *PDS_DOMAIN_CONTROLLER_INFO_FFFFFFFFW;

typedef struct _DS_DOMAIN_CONTROLLER_INFO_FFFFFFFFA {

    DWORD   IPAddress;          // IP Address of client
    DWORD   NotificationCount;  // number of outstanding notifications
    DWORD   secTimeConnected;   // total time in seconds connected
    DWORD   Flags;              // Connection properties. defined below.
    DWORD   TotalRequests;      // Total number of requests made
    DWORD   Reserved1;          // Unused
#ifdef MIDL_PASS
    [string,unique] CHAR    *UserName;
#else
    LPSTR   UserName;           // the security principal used to bind
#endif

} DS_DOMAIN_CONTROLLER_INFO_FFFFFFFFA, *PDS_DOMAIN_CONTROLLER_INFO_FFFFFFFFA;

//
// connection flags
//

#define LDAP_CONN_FLAG_BOUND    0x00000001      // bound connection
#define LDAP_CONN_FLAG_SSL      0x00000002      // connect using SSL
#define LDAP_CONN_FLAG_UDP      0x00000004      // UDP connection
#define LDAP_CONN_FLAG_GC       0x00000008      // came through the GC port
#define LDAP_CONN_FLAG_GSSAPI   0x00000010      // used gssapi
#define LDAP_CONN_FLAG_SPNEGO   0x00000020      // used spnego
#define LDAP_CONN_FLAG_SIMPLE   0x00000040      // used simple
#define LDAP_CONN_FLAG_DIGEST   0x00000080      // used Digest-MD5
#define LDAP_CONN_FLAG_SIGN     0x00000100      // signing on
#define LDAP_CONN_FLAG_SEAL     0x00000200      // sealing on

#ifdef UNICODE
#define DS_DOMAIN_CONTROLLER_INFO_FFFFFFFF  DS_DOMAIN_CONTROLLER_INFO_FFFFFFFFW
#define PDS_DOMAIN_CONTROLLER_INFO_FFFFFFFF  PDS_DOMAIN_CONTROLLER_INFO_FFFFFFFFW
#else
#define DS_DOMAIN_CONTROLLER_INFO_FFFFFFFF  DS_DOMAIN_CONTROLLER_INFO_FFFFFFFFA
#define PDS_DOMAIN_CONTROLLER_INFO_FFFFFFFF  PDS_DOMAIN_CONTROLLER_INFO_FFFFFFFFA
#endif

// ==========================================================
// DsCrackSpn2() -- parse a counted-length SPN into the ServiceClass,
// ServiceName, and InstanceName (and InstancePort) pieces.
// An SPN is passed in, along with a pointer to the maximum length
// for each piece and a pointer to a buffer where each piece should go.
// On exit, the maximum lengths are updated to the actual length for each piece
// and the buffer contain the appropriate piece. The InstancePort is 0 if not
// present.
//
// DWORD DsCrackSpn(
//      IN LPTSTR pszSPN,               // the SPN to parse
//      IN DWORD cSpn,                // length of pszSPN
//      IN OUT PUSHORT pcServiceClass,  // input -- max length of ServiceClass;
//                                         output -- actual length
//      OUT LPCTSTR ServiceClass,       // the ServiceClass part of the SPN
//      IN OUT PUSHORT pcServiceName,   // input -- max length of ServiceName;
//                                         output -- actual length
//      OUT LPCTSTR ServiceName,        // the ServiceName part of the SPN
//      IN OUT PUSHORT pcInstance,      // input -- max length of ServiceClass;
//                                         output -- actual length
//      OUT LPCTSTR InstanceName,  // the InstanceName part of the SPN
//      OUT PUSHORT InstancePort          // instance port
//
// Note: lengths are in characters; all string lengths include terminators
// All arguments except pszSpn are optional.
//

NTDSAPI
DWORD
WINAPI
DsCrackSpn2A(
    IN LPCSTR pszSpn,
    IN DWORD cSpn,
    IN OUT LPDWORD pcServiceClass,
    OUT LPSTR ServiceClass,
    IN OUT LPDWORD pcServiceName,
    OUT LPSTR ServiceName,
    IN OUT LPDWORD pcInstanceName,
    OUT LPSTR InstanceName,
    OUT USHORT *pInstancePort
    );

NTDSAPI
DWORD
WINAPI
DsCrackSpn2W(
    IN LPCWSTR pszSpn,
    IN DWORD cSpn,
    IN OUT DWORD *pcServiceClass,
    OUT LPWSTR ServiceClass,
    IN OUT DWORD *pcServiceName,
    OUT LPWSTR ServiceName,
    IN OUT DWORD *pcInstanceName,
    OUT LPWSTR InstanceName,
    OUT USHORT *pInstancePort
    );

NTDSAPI
DWORD
WINAPI
DsCrackSpn3W(
    IN LPCWSTR pszSpn,
    IN DWORD cSpn,
    IN OUT DWORD *pcHostName,
    OUT LPWSTR HostName,
    IN OUT DWORD *pcInstanceName,
    OUT LPWSTR InstanceName,
    OUT USHORT *pPortNumber,
    IN OUT DWORD *pcDomainName,
    OUT LPWSTR DomainName,
    IN OUT DWORD *pcRealmName,
    OUT LPWSTR RealmName
    );

#ifdef UNICODE
#define DsCrackSpn2 DsCrackSpn2W
#else
#define DsCrackSpn2 DsCrackSpn2A
#endif

#ifndef MIDL_PASS

DWORD
DsaopExecuteScript (
    IN  PVOID                  phAsync,
    IN  RPC_BINDING_HANDLE     hRpc,
    IN  DWORD                  cbPassword,
    IN  BYTE                  *pbPassword,
    OUT DWORD                 *dwOutVersion,
    OUT PVOID                  reply
    );

DWORD
DsaopPrepareScript ( 
    IN  PVOID                        phAsync,
    IN  RPC_BINDING_HANDLE           hRpc,
    OUT DWORD                        *dwOutVersion,
    OUT PVOID                        reply
    );
    
DWORD
DsaopBind(
    IN  LPCWSTR DomainControllerName,
    IN  LPCWSTR DnsDomainName,
    IN  ULONG AuthnSvc,
    IN  ULONG AuthnLevel,
    OUT RPC_BINDING_HANDLE  *phRpc
    );

DWORD
DsaopBindWithCred(
    IN  LPCWSTR DomainControllerName,
    IN  LPCWSTR DnsDomainName,
    IN  RPC_AUTH_IDENTITY_HANDLE AuthIdentity,
    IN  ULONG AuthnSvc,
    IN  ULONG AuthnLevel,
    OUT RPC_BINDING_HANDLE  *phRpc
    );

DWORD
DsaopBindWithSpn(
    IN  LPCWSTR DomainControllerName,
    IN  LPCWSTR DnsDomainName,
    IN  RPC_AUTH_IDENTITY_HANDLE AuthIdentity,
    IN  ULONG AuthnSvc,
    IN  ULONG AuthnLevel,
    IN  LPCWSTR ServicePrincipalName,
    OUT RPC_BINDING_HANDLE  *phRpc
    );

DWORD
DsaopUnBind(
    RPC_BINDING_HANDLE  *phRpc
    );
    
#endif 

#endif // _NTDSAPIP_H_
=== C:/Users/treeman/Desktop/windows nt source code\Source\Win2K3\NT\public\internal\ds\inc\ntfrsipi.h ===
/*++ BUILD Version: 0001    Increment if a change has global effects

Copyright (c) 1998  Microsoft Corporation

Module Name:

    ntfrsipi.h

Abstract:

    Header file for the internal programmer's interfaces
    to the File Replication Service (NtFrs).

    Functions are in ntfrsapi.dll.

Environment:

    User Mode - Win32

Notes:

--*/
#ifndef _NTFRSIPI_H_
#define _NTFRSIPI_H_

#ifdef __cplusplus
extern "C" {
#endif

DWORD
WINAPI
NtFrsApi_PrepareForPromotionW(
    IN DWORD    ErrorCallBack(IN PWCHAR, IN ULONG)     OPTIONAL
    );
/*++
Routine Description:

    The NtFrs service seeds the system volume during the promotion
    of a server to a Domain Controller (DC). The files and directories
    for the system volume come from the same machine that is supplying
    the initial Directory Service (DS).

    This function prepares the NtFrs service on this machine for
    promotion by stopping the service, deleting old promotion
    state in the registry, and restarting the service.

    This function is not idempotent and isn't MT safe.

Arguments:

    None.

Return Value:

    Win32 Status
--*/

DWORD
WINAPI
NtFrsApi_PrepareForDemotionW(
    IN DWORD    ErrorCallBack(IN PWCHAR, IN ULONG)     OPTIONAL
    );
/*++
Routine Description:

    The NtFrs service replicates the enterprise system volume to all
    Domain Controllers (DCs) and replicates the domain system volume
    to the DCs in a domain until the DC is demoted to a member server.
    Replication is stopped by tombstoning the system volume's replica
    set.

    This function prepares the NtFrs service on this machine for
    demotion by stopping the service, deleting old demotion
    state in the registry, and restarting the service.

    This function is not idempotent and isn't MT safe.

Arguments:

    None.

Return Value:

    Win32 Status
--*/

//
// Replica set types for parameter ReplicaSetType below
//
#define NTFRSAPI_REPLICA_SET_TYPE_ENTERPRISE    L"Enterprise"
#define NTFRSAPI_REPLICA_SET_TYPE_DOMAIN        L"Domain"
#define NTFRSAPI_REPLICA_SET_TYPE_DFS           L"DFS"
#define NTFRSAPI_REPLICA_SET_TYPE_OTHER         L"Other"

#define NTFRSAPI_SERVICE_STATE_IS_UNKNOWN   (00)
#define NTFRSAPI_SERVICE_PROMOTING          (10)
#define NTFRSAPI_SERVICE_DEMOTING           (20)
#define NTFRSAPI_SERVICE_DONE               (99)
DWORD
WINAPI
NtFrsApi_StartPromotionW(
    IN PWCHAR   ParentComputer,                         OPTIONAL
    IN PWCHAR   ParentAccount,                          OPTIONAL
    IN PWCHAR   ParentPassword,                         OPTIONAL
    IN DWORD    DisplayCallBack(IN PWCHAR Display),     OPTIONAL
    IN DWORD    ErrorCallBack(IN PWCHAR, IN ULONG),     OPTIONAL
    IN PWCHAR   ReplicaSetName,
    IN PWCHAR   ReplicaSetType,
    IN DWORD    ReplicaSetPrimary,
    IN PWCHAR   ReplicaSetStage,
    IN PWCHAR   ReplicaSetRoot
    );
/*++
Routine Description:

    The NtFrs service seeds the system volume during the promotion
    of a server to a Domain Controller (DC). The files and directories
    for the system volume come from the same machine that is supplying
    the initial Directory Service (DS).

    This function kicks off a thread that updates the sysvol information
    in the registry and initiates the seeding process. The thread tracks
    the progress of the seeding and periodically informs the caller.

    The threads started by NtFrsApi_StartPromotionW can be forcefully
    terminated with NtFrsApi_AbortPromotionW.

    The threads started by NtFrsApi_StartPromotionW can be waited on
    with NtFrsApi_WaitForPromotionW.

Arguments:

    ParentComputer      - An RPC-bindable name of the computer that is
                          supplying the Directory Service (DS) with its
                          initial state. The files and directories for
                          the system volume are replicated from this
                          parent computer.
    ParentAccount       - A logon account on ParentComputer.
    ParentPassword      - The logon account's password on ParentComputer.
    DisplayCallBack     - Called periodically with a progress display.
    ReplicaSetName      - Name of the replica set.
    ReplicaSetType      - Type of replica set (enterprise or domain)
    ReplicaSetPrimary   - Is this the primary member of the replica set?
                        - 1 = primary; 0 = not.
    ReplicaSetStage     - Staging path.
    ReplicaSetRoot      - Root path.

Return Value:

    Win32 Status
--*/

DWORD
WINAPI
NtFrsApi_StartDemotionW(
    IN PWCHAR   ReplicaSetName,
    IN DWORD    ErrorCallBack(IN PWCHAR, IN ULONG)     OPTIONAL
    );
/*++
Routine Description:

    The NtFrs service replicates the enterprise system volume to all
    Domain Controllers (DCs) and replicates the domain system volume
    to the DCs in a domain until the DC is demoted to a member server.
    Replication is stopped by tombstoning the system volume's replica
    set.

    This function kicks off a thread that stops replication of the
    system volume on this machine by telling the NtFrs service on
    this machine to tombstone the system volume's replica set.

    The threads started by NtFrsApi_StartDemotionW can be forcefully
    terminated with NtFrsApi_AbortDemotionW.

    The threads started by NtFrsApi_StartDemotionW can be waited on
    with NtFrsApi_WaitForDemotionW.

Arguments:

    ReplicaSetName      - Name of the replica set.

Return Value:

    Win32 Status
--*/

DWORD
WINAPI
NtFrsApi_WaitForPromotionW(
    IN DWORD    TimeoutInMilliSeconds,
    IN DWORD    ErrorCallBack(IN PWCHAR, IN ULONG)     OPTIONAL
    );
/*++
Routine Description:

    The NtFrs service seeds the system volume during the promotion
    of a server to a Domain Controller (DC). The files and directories
    for the system volume come from the same machine that is supplying
    the initial Directory Service (DS).

    This function waits for the seeding to finish or to stop w/error.

Arguments:

    TimeoutInMilliSeconds    - Timeout in milliseconds for waiting for
                               seeding to finish. INFINITE if no timeout.

Return Value:

    Win32 Status
--*/

DWORD
WINAPI
NtFrsApi_WaitForDemotionW(
    IN DWORD    TimeoutInMilliSeconds,
    IN DWORD    ErrorCallBack(IN PWCHAR, IN ULONG)     OPTIONAL
    );
/*++
Routine Description:

    The NtFrs service replicates the enterprise system volume to all
    Domain Controllers (DCs) and replicates the domain system volume
    to the DCs in a domain until the DC is demoted to a member server.
    Replication is stopped by tombstoning the system volume's replica
    set.

    This function waits for the tombstoning to finish or to stop w/error.

Arguments:

    TimeoutInMilliSeconds    - Timeout in milliseconds for waiting for
                               seeding to finish. INFINITE if no timeout.

Return Value:

    Win32 Status
--*/

DWORD
WINAPI
NtFrsApi_CommitPromotionW(
    IN DWORD    TimeoutInMilliSeconds,
    IN DWORD    ErrorCallBack(IN PWCHAR, IN ULONG)     OPTIONAL
    );
/*++
Routine Description:

    WARNING - This function assumes the caller will reboot the system
    soon after this call!

    The NtFrs service seeds the system volume during the promotion
    of a server to a Domain Controller (DC). The files and directories
    for the system volume come from the same machine that is supplying
    the initial Directory Service (DS).

    This function waits for the seeding to finish, stops the service,
    and commits the state in the registry. On reboot, the NtFrs Service
    updates the DS on this machine with the information in the registry.

Arguments:

    TimeoutInMilliSeconds    - Timeout in milliseconds for waiting for
                               seeding to finish. INFINITE if no timeout.

Return Value:

    Win32 Status
--*/

DWORD
WINAPI
NtFrsApi_CommitDemotionW(
    IN DWORD    TimeoutInMilliSeconds,
    IN DWORD    ErrorCallBack(IN PWCHAR, IN ULONG)     OPTIONAL
    );
/*++
Routine Description:

    WARNING - This function assumes the caller will reboot the system
    soon after this call!

    The NtFrs service replicates the enterprise system volume to all
    Domain Controllers (DCs) and replicates the domain system volume
    to the DCs in a domain until the DC is demoted to a member server.
    Replication is stopped by tombstoning the system volume's replica
    set.

    This function waits for the tombstoning to finish, tells the service
    to forcibly delete the system volumes' replica sets, stops the service,
    and commits the state in the registry. On reboot, the NtFrs Service
    updates the DS on this machine with the information in the registry.

Arguments:

    TimeoutInMilliSeconds    - Timeout in milliseconds for waiting for
                               tombstoning to finish. INFINITE if no timeout.

Return Value:

    Win32 Status
--*/

DWORD
WINAPI
NtFrsApi_AbortPromotionW(
    VOID
    );
/*++
Routine Description:

    The NtFrs service seeds the system volume during the promotion
    of a server to a Domain Controller (DC). The files and directories
    for the system volume come from the same machine that is supplying
    the initial Directory Service (DS).

    This function aborts the seeding process by stopping the service,
    deleting the promotion state out of the registry, cleaning up
    the active threads and the active RPC calls, and finally resetting
    the service to its pre-seeding state.

Arguments:

    None.

Return Value:

    Win32 Status
--*/

DWORD
WINAPI
NtFrsApi_AbortDemotionW(
    VOID
    );
/*++
Routine Description:

    The NtFrs service replicates the enterprise system volume to all
    Domain Controllers (DCs) and replicates the domain system volume
    to the DCs in a domain until the DC is demoted to a member server.

    During demotion, NtFrsApi_StartDemotionW stops replication of
    the system volume on this machine by telling the NtFrs service
    on this machine to tombstone the system volume's replica set.

    This function aborts the tombstoning process by stopping the service,
    deleting the demotion state out of the registry, cleaning up
    the active threads and the active RPC calls, and finally resetting
    the service to its pre-tombstoning state.

Arguments:

    None.

Return Value:

    Win32 Status
--*/

#define NTFRSAPI_MAX_INTERVAL           ((((ULONG)0x7FFFFFFF) / 1000) / 60)
#define NTFRSAPI_MIN_INTERVAL           (1)
#define NTFRSAPI_DEFAULT_LONG_INTERVAL  (1 * 60)    // 1 hour
#define NTFRSAPI_DEFAULT_SHORT_INTERVAL (5)         // 5 minutes

DWORD
WINAPI
NtFrsApi_Set_DsPollingIntervalW(
    IN PWCHAR   ComputerName,       OPTIONAL
    IN ULONG    UseShortInterval,
    IN ULONG    LongInterval,
    IN ULONG    ShortInterval
    );
/*++
Routine Description:

    The NtFrs service polls the DS occasionally for configuration changes.
    This API alters the polling interval and, if the service is not
    in the middle of a polling cycle, forces the service to begin a
    polling cycle.

    The service uses the long interval by default. The short interval
    is used after the ds configuration has been successfully
    retrieved and the service is now verifying that the configuration
    is not in flux. This API can be used to force the service to use
    the short interval until a stable configuration has been retrieved.
    After which, the service reverts back to the long interval.

    The default values for ShortInterval and LongInterval can be
    changed by setting the parameters to a non-zero value. If zero,
    the current values remain unchanged and a polling cycle is initiated.

Arguments:

    ComputerName     - Poke the service on this computer. The computer
                       name can be any RPC-bindable name. Usually, the
                       NetBIOS or DNS name works just fine. The NetBIOS
                       name can be found with GetComputerName() or
                       hostname. The DNS name can be found with
                       gethostbyname() or ipconfig /all. If NULL, the
                       service on this computer is contacted. The service
                       is contacted using Secure RPC.

    UseShortInterval - If non-zero, the service switches to the short
                       interval until a stable configuration is retrieved
                       from the DS or another call to this API is made.
                       Otherwise, the service uses the long interval.

    LongInterval     - Minutes between polls of the DS. The value must fall
                       between NTFRSAPI_MIN_INTERVAL and NTFRSAPI_MAX_INTERVAL,
                       inclusive. If 0, the interval is unchanged.

    ShortInterval    - Minutes between polls of the DS. The value must fall
                       between NTFRSAPI_MIN_INTERVAL and NTFRSAPI_MAX_INTERVAL,
                       inclusive. If 0, the interval is unchanged.

Return Value:

    Win32 Status
--*/

DWORD
WINAPI
NtFrsApi_Get_DsPollingIntervalW(
    IN  PWCHAR  ComputerName,       OPTIONAL
    OUT ULONG   *Interval,
    OUT ULONG   *LongInterval,
    OUT ULONG   *ShortInterval
    );
/*++
Routine Description:

    The NtFrs service polls the DS occasionally for configuration changes.
    This API returns the values the service uses for polling intervals.

    The service uses the long interval by default. The short interval
    is used after the ds configuration has been successfully
    retrieved and the service is now verifying that the configuration
    is not in flux. The short interval is also used if the
    NtFrsApi_Set_DsPollingIntervalW() is used to force usage of the short
    interval until a stable configuration has been retrieved. After which,
    the service reverts back to the long interval.

    The value returned in Interval is the polling interval currently in
    use.

Arguments:

    ComputerName     - Poke the service on this computer. The computer
                       name can be any RPC-bindable name. Usually, the
                       NetBIOS or DNS name works just fine. The NetBIOS
                       name can be found with GetComputerName() or
                       hostname. The DNS name can be found with
                       gethostbyname() or ipconfig /all. If NULL, the
                       service on this computer is contacted. The service
                       is contacted using Secure RPC.

    Interval         - The current polling interval in minutes.

    LongInterval     - The long interval in minutes.

    ShortInterval    - The short interval in minutes.

Return Value:

    Win32 Status
--*/

//
// Type of internal information returned by NtFrsApi_InfoW()
//
#define NTFRSAPI_INFO_TYPE_MIN       (0)
#define NTFRSAPI_INFO_TYPE_VERSION   (0)
#define NTFRSAPI_INFO_TYPE_SETS      (1)
#define NTFRSAPI_INFO_TYPE_DS        (2)
#define NTFRSAPI_INFO_TYPE_MEMORY    (3)
#define NTFRSAPI_INFO_TYPE_IDTABLE   (4)
#define NTFRSAPI_INFO_TYPE_OUTLOG    (5)
#define NTFRSAPI_INFO_TYPE_INLOG     (6)
#define NTFRSAPI_INFO_TYPE_MAX       (6)

//
// Internal constants
//
#define NTFRSAPI_DEFAULT_INFO_SIZE  (32 * 1024)
#define NTFRSAPI_MINIMUM_INFO_SIZE  ( 1 * 1024)

//
// Opaque information from NtFrs.
// Parse with NtFrsApi_InfoLineW().
// Free with NtFrsApi_InfoFreeW();
//
typedef struct _NTFRSAPI_INFO {
    ULONG   Major;
    ULONG   Minor;
    ULONG   NtFrsMajor;
    ULONG   NtFrsMinor;
    ULONG   SizeInChars;
    ULONG   Flags;
    ULONG   TypeOfInfo;
    ULONG   TotalChars;
    ULONG   CharsToSkip;
    ULONG   OffsetToLines;
    ULONG   OffsetToFree;
    CHAR    Lines[1];
} NTFRSAPI_INFO, *PNTFRSAPI_INFO;
//
// RPC Blob must be at least this size
//
#define NTFRSAPI_INFO_HEADER_SIZE   (5 * sizeof(ULONG))

//
// NtFrsApi Information Flags
//
#define NTFRSAPI_INFO_FLAGS_VERSION (0x00000001)
#define NTFRSAPI_INFO_FLAGS_FULL    (0x00000002)

DWORD
WINAPI
NtFrsApi_InfoW(
    IN     PWCHAR  ComputerName,       OPTIONAL
    IN     ULONG   TypeOfInfo,
    IN     ULONG   SizeInChars,
    IN OUT PVOID   *NtFrsApiInfo
    );
/*++
Routine Description:
    Return a buffer full of the requested information. The information
    can be extracted from the buffer with NtFrsApi_InfoLineW().

    *NtFrsApiInfo should be NULL on the first call. On subsequent calls,
    *NtFrsApiInfo will be filled in with more data if any is present.
    Otherwise, *NtFrsApiInfo is set to NULL and the memory is freed.

    The SizeInChars is a suggested size; the actual memory usage
    may be different. The function chooses the memory usage if
    SizeInChars is 0.

    The format of the returned information can change without notice.

Arguments:
    ComputerName     - Poke the service on this computer. The computer
                       name can be any RPC-bindable name. Usually, the
                       NetBIOS or DNS name works just fine. The NetBIOS
                       name can be found with GetComputerName() or
                       hostname. The DNS name can be found with
                       gethostbyname() or ipconfig /all. If NULL, the
                       service on this computer is contacted. The service
                       is contacted using Secure RPC.

    TypeOfInfo      - See the constants beginning with NTFRSAPI_INFO_
                      in ntfrsapi.h.

    SizeInChars     - Suggested memory usage; actual may be different.
                      0 == Function chooses memory usage

    NtFrsApiInfo    - Opaque. Parse with NtFrsApi_InfoLineW().
                      Free with NtFrsApi_InfoFreeW();

Return Value:
    Win32 Status
--*/

DWORD
WINAPI
NtFrsApi_InfoLineW(
    IN      PNTFRSAPI_INFO  NtFrsApiInfo,
    IN OUT  PVOID           *InOutLine
    );
/*++
Routine Description:
    Extract the wchar lines of information from NtFrsApiInformation.

    Returns the address of the next L'\0' terminated line of information.
    NULL if none.

Arguments:
    NtFrsApiInfo    - Opaque. Returned by NtFrsApi_InfoW().
                      Parse with NtFrsApi_InfoLineW().
                      Free with NtFrsApi_InfoFreeW().

Return Value:
    Win32 Status
--*/

BOOL
WINAPI
NtFrsApi_InfoMoreW(
    IN  PNTFRSAPI_INFO  NtFrsApiInfo
    );
/*++
Routine Description:
    All of the information may not have fit in the buffer. The additional
    information can be fetched by calling NtFrsApi_InfoW() again with the
    same NtFrsApiInfo struct. NtFrsApi_InfoW() will return NULL in
    NtFrsApiInfo if there is no more information.

    However, the information returned in subsequent calls to _InfoW() may be
    out of sync with the previous information. If the user requires a
    coherent information set, then the information buffer should be freed
    with NtFrsApi_InfoFreeW() and another call made to NtFrsApi_InfoW()
    with an increased SizeInChars. Repeat the procedure until
    NtFrsApi_InfoMoreW() returns FALSE.

Arguments:
    NtFrsApiInfo - Opaque. Returned by NtFrsApi_InfoW().
                   Parse with NtFrsApi_InfoLineW().
                   Free with NtFrsApi_InfoFreeW().

Return Value:
    TRUE    - The information buffer does *NOT* contain all of the info.
    FALSE   - The information buffer does contain all of the info.
--*/

DWORD
WINAPI
NtFrsApi_InfoFreeW(
    IN  PVOID   *NtFrsApiInfo
    );
/*++
Routine Description:
    Free the information buffer allocated by NtFrsApi_InfoW();

Arguments:
    NtFrsApiInfo - Opaque. Returned by NtFrsApi_InfoW().
                   Parse with NtFrsApi_InfoLineW().
                   Free with NtFrsApi_InfoFreeW().

Return Value:
    Win32 Status
--*/

//
// BACKUP/RESTORE API
//
#define NTFRSAPI_BUR_FLAGS_NONE                         (0x00000000)
#define NTFRSAPI_BUR_FLAGS_AUTHORITATIVE                (0x00000001)
#define NTFRSAPI_BUR_FLAGS_NON_AUTHORITATIVE            (0x00000002)
#define NTFRSAPI_BUR_FLAGS_PRIMARY                      (0x00000004)
#define NTFRSAPI_BUR_FLAGS_SYSTEM                       (0x00000008)
#define NTFRSAPI_BUR_FLAGS_ACTIVE_DIRECTORY             (0x00000010)
#define NTFRSAPI_BUR_FLAGS_NORMAL                       (0x00000020)
#define NTFRSAPI_BUR_FLAGS_ALL_DIRECTORIES_AND_VOLUMES  (0x00000040)
#define NTFRSAPI_BUR_FLAGS_RESTORE                      (0x00000080)
#define NTFRSAPI_BUR_FLAGS_BACKUP                       (0x00000100)
#define NTFRSAPI_BUR_FLAGS_RESTART                      (0x00000200)

#define NTFRSAPI_BUR_FLAGS_TYPES_OF_RESTORE \
                    (NTFRSAPI_BUR_FLAGS_AUTHORITATIVE       | \
                     NTFRSAPI_BUR_FLAGS_NON_AUTHORITATIVE   | \
                     NTFRSAPI_BUR_FLAGS_PRIMARY)

#define NTFRSAPI_BUR_FLAGS_MODES_OF_RESTORE \
                    (NTFRSAPI_BUR_FLAGS_SYSTEM           | \
                     NTFRSAPI_BUR_FLAGS_ACTIVE_DIRECTORY | \
                     NTFRSAPI_BUR_FLAGS_NORMAL)

#define NTFRSAPI_BUR_FLAGS_SUPPORTED_RESTORE \
                    (NTFRSAPI_BUR_FLAGS_AUTHORITATIVE        | \
                     NTFRSAPI_BUR_FLAGS_NON_AUTHORITATIVE    | \
                     NTFRSAPI_BUR_FLAGS_PRIMARY              | \
                     NTFRSAPI_BUR_FLAGS_SYSTEM               | \
                     NTFRSAPI_BUR_FLAGS_ACTIVE_DIRECTORY     | \
                     NTFRSAPI_BUR_FLAGS_NORMAL               | \
                     NTFRSAPI_BUR_FLAGS_RESTORE              | \
                     NTFRSAPI_BUR_FLAGS_ALL_DIRECTORIES_AND_VOLUMES)

#define NTFRSAPI_BUR_FLAGS_SUPPORTED_BACKUP \
                    (NTFRSAPI_BUR_FLAGS_NORMAL | \
                     NTFRSAPI_BUR_FLAGS_BACKUP)
DWORD
WINAPI
NtFrsApiInitializeBackupRestore(
    IN  DWORD   ErrorCallBack(IN PWCHAR, IN ULONG), OPTIONAL
    IN  DWORD   BurFlags,
    OUT PVOID   *BurContext
    );
/*++
Routine Description:
    Called once in the lifetime of a backup/restore process. Must be
    matched with a subsequent call to NtFrsApiDestroyBackupRestore().

    Prepare the system for the backup or restore specified by BurFlags.
    Currently, the following combinations are supported:
    ASR - Automated System Recovery
        NTFRSAPI_BUR_FLAGS_RESTORE |
        NTFRSAPI_BUR_FLAGS_SYSTEM |
        NTFRSAPI_BUR_FLAGS_ALL_DIRECTORIES_AND_VOLUMES |
        NTFRSAPI_BUR_FLAGS_PRIMARY or NTFRSAPI_BUR_FLAGS_NON_AUTHORITATIVE

    DSR - Distributed Services Restore (all sets)
        NTFRSAPI_BUR_FLAGS_RESTORE |
        NTFRSAPI_BUR_FLAGS_ACTIVE_DIRECTORY |
        NTFRSAPI_BUR_FLAGS_ALL_DIRECTORIES_AND_VOLUMES |
        NTFRSAPI_BUR_FLAGS_PRIMARY or NTFRSAPI_BUR_FLAGS_NON_AUTHORITATIVE

    DSR - Distributed Services Restore (just the sysvol)
        NTFRSAPI_BUR_FLAGS_RESTORE |
        NTFRSAPI_BUR_FLAGS_ACTIVE_DIRECTORY
        (may be followed by subsequent calls to NtFrsApiRestoringDirectory())

    Normal Restore - System is up and running; just restoring files
        NTFRSAPI_BUR_FLAGS_RESTORE |
        NTFRSAPI_BUR_FLAGS_NORMAL |
        NTFRSAPI_BUR_FLAGS_ALL_DIRECTORIES_AND_VOLUMES |
        NTFRSAPI_BUR_FLAGS_AUTHORITATIVE

    Normal Backup
        NTFRSAPI_BUR_FLAGS_BACKUP |
        NTFRSAPI_BUR_FLAGS_NORMAL

Arguments:
    ErrorCallBack   - Ignored if NULL.
                      Address of function provided by the caller. If
                      not NULL, this function calls back with a formatted
                      error message and the error code that caused the
                      error.
    BurFlags        - See above for the supported combinations
    BurContext      - Opaque context for this process

Return Value:

    Win32 Status

--*/

DWORD
WINAPI
NtFrsApiDestroyBackupRestore(
    IN     PVOID    *BurContext,
    IN     DWORD    BurFlags,
    OUT    HKEY     *HKey,
    IN OUT DWORD    *KeyPathSizeInBytes,
    OUT    PWCHAR   KeyPath
    );
/*++
Routine Description:
    Called once in the lifetime of a backup/restore process. Must be
    matched with a previous call to NtFrsApiInitializeBackupRestore().

    If NtFrsApiInitializeBackupRestore() was called with:
        NTFRSAPI_BUR_FLAGS_RESTORE |
        NTFRSAPI_BUR_FLAGS_SYSTEM or NTFRSAPI_BUR_FLAGS_ACTIVE_DIRECTORY
    then BurFlags may be set to one of:
        NTFRSAPI_BUR_FLAGS_NONE - Do not restart the service. The key
            specified by (HKey, KeyPath) must be moved into the final
            registry.
        NTFRSAPI_BUR_FLAGS_RESTART - Restart the service. HKey,
            KeyPathSizeInBytes, and KeyPath must be NULL.

    If NtFrsApiInitializeBackupRestore() was not called the above flags,
    then BurFlags must be NTFRSAPI_BUR_FLAGS_NONE and HKey, KeyPathSizeInBytes,
    and KeyPath must be NULL.

Arguments:
    BurContext          - Returned by previous call to
                          NtFrsApiInitializeBackupRestore().

    BurFlags            - Backup/Restore Flags. See Routine Description.

    HKey                - Address of a HKEY for that will be set to
                          HKEY_LOCAL_MACHINE, ...
                          NULL if BurContext is not for a System or
                          Active Directory restore or Restart is set.

    KeyPathSizeInBytes  - Address of of a DWORD specifying the size of
                          KeyPath. Set to the actual number of bytes
                          needed by KeyPath. ERROR_INSUFFICIENT_BUFFER
                          is returned if the size of KeyPath is too small.
                          NULL if BurContext is not for a System or
                          Active Directory restore or Restart is set.

    KeyPath             - Buffer to receive the path of the registry key.
                          NULL if BurContext is not for a System or
                          Active Directory restore or Restart is set.

Return Value:

    Win32 Status

--*/

DWORD
WINAPI
NtFrsApiGetBackupRestoreSets(
    IN PVOID BurContext
    );
/*++
Routine Description:
    Cannot be called if BurContext is for a System restore.

    Retrieves information about the current replicated directories
    (AKA replica sets).

Arguments:
    BurContext  - From NtFrsApiInitializeBackupRestore()

Return Value:

    Win32 Status

--*/

DWORD
WINAPI
NtFrsApiEnumBackupRestoreSets(
    IN  PVOID   BurContext,
    IN  DWORD   BurSetIndex,
    OUT PVOID   *BurSet
    );
/*++
Routine Description:
    Returns ERROR_NO_MORE_ITEMS if BurSetIndex exceeds the number of
    sets returned by NtFrsApiGetBackupRestoreSets().

Arguments:
    BurContext  - From NtFrsApiInitializeBackupRestore()
    BurSetIndex - Index of set. Starts at 0.
    BurSet      - Opaque struct representing a replicating directory.

Return Value:

    Win32 Status
--*/

DWORD
WINAPI
NtFrsApiIsBackupRestoreSetASysvol(
    IN PVOID    BurContext,
    IN PVOID    BurSet,
    IN BOOL     *IsSysvol
    );
/*++
Routine Description:
    Does the specified BurSet represent a replicating SYSVOL share?

Arguments:
    BurContext  - From NtFrsApiInitializeBackupRestore()
    BurSet      - Opaque struct representing a replicating directory.
                  Returned by NtFrsApiEnumBackupRestoreSets(). Not
                  valid across calls to NtFrsApiGetBackupRestoreSets().
    IsSysvol    - TRUE : set is a system volume (AKA SYSVOL).
                  FALSE: set is a not a system volume (AKA SYSVOL).

Return Value:

    Win32 Status
--*/

DWORD
WINAPI
NtFrsApiGetBackupRestoreSetDirectory(
    IN     PVOID    BurContext,
    IN     PVOID    BurSet,
    IN OUT DWORD    *DirectoryPathSizeInBytes,
    OUT    PWCHAR   DirectoryPath
    );
/*++
Routine Description:
    Return the path of the replicating directory represented by BurSet.

Arguments:
    BurContext  - From NtFrsApiInitializeBackupRestore()
    BurSet      - Opaque struct representing a replicating directory.
                  Returned by NtFrsApiEnumBackupRestoreSets(). Not
                  valid across calls to NtFrsApiGetBackupRestoreSets().
    DirectoryPathSizeInBytes    - Address of DWORD giving size of
                                  DirectoryPath. Cannot be NULL.
                                  Set to the number of bytes needed
                                  to return DirectoryPath.
                                  ERROR_INSUFFICIENT_BUFFER is returned if
                                  DirectoryPath is too small.
    DirectoryPath               - Buffer that is *DirectoryPathSizeInBytes
                                  bytes in length. Contains path of replicating
                                  directory.
Return Value:

    Win32 Status
--*/

DWORD
WINAPI
NtFrsApiRestoringDirectory(
    IN  PVOID   BurContext,
    IN  PVOID   BurSet,
    IN  DWORD   BurFlags
    );
/*++
Routine Description:
    The backup/restore application is about to restore the directory
    specified by BurSet (See NtFrsApiEnumBackupRestoreSets()). Matched
    with a later call to NtFrsApiFinishedRestoringDirectory().

    This call is supported only if NtFrsApiInitializeBackupRestore()
    were called with the flags:
        NTFRSAPI_BUR_FLAGS_RESTORE |
        NTFRSAPI_BUR_FLAGS_ACTIVE_DIRECTORY

    BurFlags can be NTFRSAPI_BUR_FLAGS_PRIMARY or
    NTFRSAPI_BUR_FLAGS_NON_AUTHORITATIVE and overrides any value
    specified in the call to NtFrsApiInitializeBackupRestore().

Arguments:
    BurContext      - Opaque context from NtFrsApiInitializeBackupRestore()
    BurSet          - Opaque set from NtFrsApiEnumBackupRestoreSets();
    BurFlags        - See above for the supported combinations

Return Value:

    Win32 Status

--*/

DWORD
WINAPI
NtFrsApiFinishedRestoringDirectory(
    IN  PVOID   BurContext,
    IN  PVOID   BurSet,
    IN  DWORD   BurFlags
    );
/*++
Routine Description:
    Finished restoring directory for BurSet. Matched by a previous call
    to NtFrsApiRestoringDirectory().

    This call is supported only if NtFrsApiInitializeBackupRestore()
    were called with the flags:
        NTFRSAPI_BUR_FLAGS_RESTORE |
        NTFRSAPI_BUR_FLAGS_ACTIVE_DIRECTORY

    BurFlags must be NTFRSAPI_BUR_FLAGS_NONE.

Arguments:
    BurContext      - Opaque context from NtFrsApiInitializeBackupRestore()
    BurSet          - Opaque set from NtFrsApiEnumBackupRestoreSets();
    BurFlags        - See above for the supported combinations

Return Value:

    Win32 Status

--*/

#ifdef __cplusplus
}
#endif

#endif  _NTFRSIPI_H_
=== C:/Users/treeman/Desktop/windows nt source code\Source\Win2K3\NT\public\internal\ds\inc\ntsamp.h ===
/*++

Copyright (c) 1992  Microsoft Corporation

Module Name:

    ntsamp.h

Abstract:

    This file contains structures that would normally be part of ntsam.h
    but are intended for system use only.

Author:

    David Chalmers (Davidc) 27-Mar-1992

Environment:

    User Mode - Win32

Revision History:


--*/


#ifndef _NTSAMPRIVATE_
#define _NTSAMPRIVATE_



#include <crypt.h>
#include <lsass.h>




//
// Structures usable in SetUserInformation and QueryUserInformation API calls
// by trusted clients only
//


typedef struct _USER_INTERNAL1_INFORMATION {
    NT_OWF_PASSWORD             NtOwfPassword;
    LM_OWF_PASSWORD             LmOwfPassword;
    BOOLEAN                     NtPasswordPresent;
    BOOLEAN                     LmPasswordPresent;
    BOOLEAN                     PasswordExpired; // A 'write-only' flag
} USER_INTERNAL1_INFORMATION, *PUSER_INTERNAL1_INFORMATION;


typedef struct _USER_INTERNAL2_INFORMATION {
    ULONG StatisticsToApply;
    OLD_LARGE_INTEGER LastLogon;
    OLD_LARGE_INTEGER LastLogoff;
    USHORT BadPasswordCount;
    USHORT LogonCount;
} USER_INTERNAL2_INFORMATION;

typedef struct _USER_INTERNAL2A_INFORMATION {
    ULONG StatisticsToApply;
    OLD_LARGE_INTEGER LastLogon;
    OLD_LARGE_INTEGER LastLogoff;
    USHORT BadPasswordCount;
    USHORT LogonCount;
    UNICODE_STRING Workstation;
} USER_INTERNAL2A_INFORMATION, *PUSER_INTERNAL2A_INFORMATION;

//
//
//
// The following flags may be used in the StatisticsToApply field.
//
//   USER_LOGON_STAT_LAST_LOGOFF - Replace the LastLogoff time in the
//      user record.
//
//  USER_LOGON_STATUS_LAST_LOGON - Replace the LastLogon time in the
//      user record.
//
//  USER_LOGON_STATUS_BAD_PWD_COUNT  - Replace the BadPasswordCount
//      field in the user record.
//
//  USER_LOGON_STATUS_LOGON_COUNT - Replace the LogonCount field in the
//      user record.
//
//  USER_LOGON_SUCCESSFUL_LOGON - Change user field values to indicate
//      that a successful logon has occurred.
//
//  USER_LOGON_SUCCESSFUL_LOGOFF - Change user field values to indicate
//      that a successful logoff has occurred.
//
//  USER_LOGON_BAD_PASSWORD - Change user field values to indicate that
//      an attempt was made to logon to the account with a bad password.
//
//  USER_LOGON_BAD_PASSWORD_WKSTA - Change user field values to indicate that
//      an attempt was made to logon to the account with a bad password.
//      The client workstation name is being supplied in the INTERNAL2A
//      structure.
//
//  USER_LOGON_TYPE_KERBEROS - Indicates the authentication type was
//                             KERBEROS.
//
//  USER_LOGON_TYPE_NTLM - Indicates the authentication type was NTLM.
//
//  USER_LOGON_NO_LOGON_SERVERS -- Indicates that no logon servers could be
//                                 found (specifically no GC's could be found)
//                                 (this is a failure case).
//
//  USER_LOGON_NO_WRITE -- Indicates to SAM not to update the logon statistics
//                         This can be useful to notify SAM that a logon 
//                         has completed, but not have the penalty of writing
//                         to the disk
//
//  USER_LOGON_INTER_FAILURE -- this indicates that it was an interactive
//                              logon that failed
//
//  USER_LOGON_PDC_RETRY_SUCCESS -- this indicates that the authentication
//                                  had previously failed locally but
//                                  succeeded at the PDC
//
// NOTE:
//          USER_LOGON_INTER_SUCCESS_LOGOFF
//          USER_LOGON_NET_SUCCESS_LOGOFF
//
// may not be used in conjunction with ANY other flags (including
// each other).  That is, when one of these flags is used, there
// may be NO other flags set in StatisticsToApply.
//
// NOTE2:
//
//          USER_LOGON_BAD_PASSWORD
//          USER_LOGON_INTER_SUCCESS_LOGON
//          USER_LOGON_NET_SUCCESS_LOGON
//
// may be used in conjunction ONLY with ONE of USER_LOGON_TYPE_KERBEROS or
// USER_LOGON_TYPE_NTLM.

#define USER_LOGON_STAT_LAST_LOGOFF      (0x00000001L)
#define USER_LOGON_STAT_LAST_LOGON       (0x00000002L)
#define USER_LOGON_STAT_BAD_PWD_COUNT    (0x00000004L)
#define USER_LOGON_STAT_LOGON_COUNT      (0x00000008L)

#define USER_LOGON_PDC_RETRY_SUCCESS     (0x00100000L)
#define USER_LOGON_INTER_FAILURE         (0x00200000L)
#define USER_LOGON_NO_WRITE              (0x00400000L)
#define USER_LOGON_NO_LOGON_SERVERS      (0x00800000L)
#define USER_LOGON_INTER_SUCCESS_LOGON   (0x01000000L)
#define USER_LOGON_TYPE_NTLM             (0x02000000L)
#define USER_LOGON_TYPE_KERBEROS         (0x04000000L)
#define USER_LOGON_BAD_PASSWORD          (0x08000000L)
#define USER_LOGON_BAD_PASSWORD_WKSTA    (0x10000000L)
#define USER_LOGON_INTER_SUCCESS_LOGOFF  (0x20000000L)
#define USER_LOGON_NET_SUCCESS_LOGON     (0x40000000L)
#define USER_LOGON_NET_SUCCESS_LOGOFF    (0x80000000L)


typedef struct _USER_INTERNAL3_INFORMATION {
    USER_ALL_INFORMATION I1;
    LARGE_INTEGER       LastBadPasswordTime;
} USER_INTERNAL3_INFORMATION,  *PUSER_INTERNAL3_INFORMATION;


typedef struct _USER_ALLOWED_TO_DELEGATE_TO_LIST {
    ULONG       Size;
    ULONG       NumSPNs;
    UNICODE_STRING SPNList[ANYSIZE_ARRAY];
} USER_ALLOWED_TO_DELEGATE_TO_LIST, *PUSER_ALLOWED_TO_DELEGATE_TO_LIST;

typedef USER_ALLOWED_TO_DELEGATE_TO_LIST USER_SPN_LIST, *PUSER_SPN_LIST;
 

typedef struct _USER_INTERNAL6_INFORMATION {
    USER_ALL_INFORMATION I1;
    LARGE_INTEGER       LastBadPasswordTime;
    ULONG               ExtendedFields;
    BOOLEAN             UPNDefaulted;
    UNICODE_STRING      UPN;
    PUSER_ALLOWED_TO_DELEGATE_TO_LIST A2D2List;
        PUSER_SPN_LIST      RegisteredSPNs;
        ULONG               KeyVersionNumber;
        ULONG               LockoutThreshold;
} USER_INTERNAL6_INFORMATION, *PUSER_INTERNAL6_INFORMATION;

//
// The following fields are to be used in the extended fields
// member of USER_INTERNAL6_INFORMATION
//


#define USER_EXTENDED_FIELD_UPN                 (0x00000001L)
#define USER_EXTENDED_FIELD_A2D2                (0x00000002L)
#define USER_EXTENDED_FIELD_SPN                 (0x00000004L)
#define USER_EXTENDED_FIELD_KVNO                (0x00000008L)
#define USER_EXTENDED_FIELD_LOCKOUT_THRESHOLD   (0x00000010L)

// Reserved for internal use
#define USER_EXTENDED_FIELD_RESERVED    (0xFF000000L)

//
// The following is for SamrGetUserDomainPasswordInformation(), which is
// only used in wrappers.c.
//

typedef struct _USER_DOMAIN_PASSWORD_INFORMATION {
    USHORT MinPasswordLength;
    ULONG PasswordProperties;
} USER_DOMAIN_PASSWORD_INFORMATION, *PUSER_DOMAIN_PASSWORD_INFORMATION;


//
// This flag may be or'd with the length field of SAMP_USER_PASSWORD to
// indicate that the password is not case sensitive.
//

#define SAM_PASSWORD_CASE_INSENSITIVE 0x80000000

//
// Structure to pass an encrypted password over the wire.  The Length is the
// length of the password, which should be placed at the end of the buffer.
// The size of the buffer (256) should be kept in sync with
// SAM_MAX_PASSWORD_LENGTH, which is defined in ntsam.h.  Unfortunately,
// MIDL does not let #define'd constants be imported, so we have to
// use 256 instead of the constant here.
//

typedef struct _SAMPR_USER_PASSWORD {
    WCHAR Buffer[SAM_MAX_PASSWORD_LENGTH];
    ULONG Length;
} SAMPR_USER_PASSWORD, *PSAMPR_USER_PASSWORD;

typedef struct _SAMPR_USER_PASSWORD_NEW {
    WCHAR Buffer[SAM_MAX_PASSWORD_LENGTH];
    ULONG Length;
    UCHAR ClearSalt[SAM_PASSWORD_ENCRYPTION_SALT_LEN];
} SAMPR_USER_PASSWORD_NEW, *PSAMPR_USER_PASSWORD_NEW;


//
// Buffer - contains random fill with the password filling up the end
//          of the buffer (the last Length bytes).
// Length - Length, in bytes, of the buffer.
//

//
// This is the encrypted version of the above structure, and is passed
// on the wire.
//

typedef struct _SAMPR_ENCRYPTED_USER_PASSWORD {
    UCHAR Buffer[ (SAM_MAX_PASSWORD_LENGTH * 2) + 4 ];
} SAMPR_ENCRYPTED_USER_PASSWORD, *PSAMPR_ENCRYPTED_USER_PASSWORD;


typedef struct _SAMPR_ENCRYPTED_USER_PASSWORD_NEW {
    UCHAR Buffer[ (SAM_MAX_PASSWORD_LENGTH * 2) + 4 + 16];
} SAMPR_ENCRYPTED_USER_PASSWORD_NEW, *PSAMPR_ENCRYPTED_USER_PASSWORD_NEW;


typedef enum _SAMPR_BOOT_TYPE {
    SamBootKeyNone = 0,
    SamBootKeyStored,
    SamBootKeyPassword,
    SamBootKeyDisk,
    SamBootChangePasswordEncryptionKey
} SAMPR_BOOT_TYPE, *PSAMPR_BOOT_TYPE;


//
// ChangePassword API for One-Way-Function-aware clients
//

NTSTATUS
SamiChangePasswordUser(
    IN SAM_HANDLE UserHandle,
    IN BOOLEAN LmOldPresent,
    IN PLM_OWF_PASSWORD LmOldOwfPassword,
    IN PLM_OWF_PASSWORD LmNewOwfPassword,
    IN BOOLEAN NtPresent,
    IN PNT_OWF_PASSWORD NtOldOwfPassword,
    IN PNT_OWF_PASSWORD NtNewOwfPassword
    );


NTSTATUS
SamiLmChangePasswordUser(
    IN SAM_HANDLE UserHandle,
    IN PENCRYPTED_LM_OWF_PASSWORD LmOldEncryptedWithLmNew,
    IN PENCRYPTED_LM_OWF_PASSWORD LmNewEncryptedWithLmOld
    );

NTSTATUS
SamiEncryptPasswords(
    IN PUNICODE_STRING OldPassword,
    IN PUNICODE_STRING NewPassword,
    OUT PSAMPR_ENCRYPTED_USER_PASSWORD NewEncryptedWithOldNt,
    OUT PENCRYPTED_NT_OWF_PASSWORD OldNtOwfEncryptedWithNewNt,
    OUT PBOOLEAN LmPresent,
    OUT PSAMPR_ENCRYPTED_USER_PASSWORD NewEncryptedWithOldLm,
    OUT PENCRYPTED_NT_OWF_PASSWORD OldLmOwfEncryptedWithNewNt
);

NTSTATUS
SamiChangePasswordUser2(
    PUNICODE_STRING ServerName,
    PUNICODE_STRING UserName,
    PSAMPR_ENCRYPTED_USER_PASSWORD NewPasswordEncryptedWithOldNt,
    PENCRYPTED_NT_OWF_PASSWORD OldNtOwfPasswordEncryptedWithNewNt,
    BOOLEAN LmPresent,
    PSAMPR_ENCRYPTED_USER_PASSWORD NewPasswordEncryptedWithOldLm,
    PENCRYPTED_LM_OWF_PASSWORD OldLmOwfPasswordEncryptedWithNewLmOrNt
    );

NTSTATUS
SamiOemChangePasswordUser2(
    PSTRING ServerName,
    PSTRING UserName,
    PSAMPR_ENCRYPTED_USER_PASSWORD NewPasswordEncryptedWithOldLm,
    PENCRYPTED_LM_OWF_PASSWORD OldLmOwfPasswordEncryptedWithNewLm
    );

NTSTATUS
SamiGetBootKeyInformation(
    IN SAM_HANDLE DomainHandle,
    OUT PSAMPR_BOOT_TYPE BootOptions
    );

NTSTATUS
SamiSetBootKeyInformation(
    IN SAM_HANDLE DomainHandle,
    IN SAMPR_BOOT_TYPE BootOptions,
    IN PUNICODE_STRING OldBootKey, OPTIONAL
    IN PUNICODE_STRING NewBootKey OPTIONAL
    );

NTSTATUS
SamiSetDSRMPassword(
    IN PUNICODE_STRING  ServerName,
    IN ULONG            UserId,
    IN PUNICODE_STRING  ClearPassword
    );

NTSTATUS
SamiSetDSRMPasswordOWF(
    IN PUNICODE_STRING  ServerName,
    IN ULONG            UserId,
    IN PNT_OWF_PASSWORD NtPassword
    );

NTSTATUS
SamiChangeKeys();

#endif  // _NTSAMPRIVATE_
=== C:/Users/treeman/Desktop/windows nt source code\Source\Win2K3\NT\public\internal\ds\inc\ntrmlsa.h ===
/*++

Copyright (c) 1991  Microsoft Corporation

Module Name:

    ntrmlsa.h

Abstract:

    Local Security Authority - Reference Monitor Communication Types

Author:

    Scott Birrell       (ScottBi)       March 18, 1991

Environment:

Revision History:

--*/


#include <ntlsa.h>

#ifndef _NTRMLSA_
#define _NTRMLSA_


//
// Memory type.  This defines the type of memory used for a record
// passed between the RM and LSA.
//
// SepRmLsaPortMemory - Memory allocated via RtlAllocateHeap()
//     from the shared memory section associated with the
//     Lsa command Port.
//
// SepRmLsaVirtualMemory - Memory allocated via ZwAllocateVirtualMemory()
//
// SepRmLsaUnreadableMemory - Memory not readable by the LSA.  This
//                            memory must be copied to another format
//                            before passage over the link.
//
// SepRmLsaLPCBufferMemory - Memory contained within the LPC buffer
// itself
//



typedef enum _SEP_RM_LSA_MEMORY_TYPE {

    SepRmNoMemory = 0,
    SepRmImmediateMemory,
    SepRmLsaCommandPortSharedMemory,
    SepRmLsaCustomSharedMemory,
    SepRmPagedPoolMemory,
    SepRmUnspecifiedMemory

} SEP_RM_LSA_MEMORY_TYPE, *PSEP_RM_LSA_MEMORY_TYPE;

//
// Reference Monitor Command Message Structure.  This structure is used
// by the Local Security Authority to send commands to the Reference Monitor
// via the Reference Monitor Server Command LPC Port.
//

#define RmMinimumCommand RmAuditSetCommand
#define RmMaximumCommand RmDeleteLogonSession

//
// Keep this in sync with SEP_RM_COMMAND_WORKER in se\rmmain.c
//

typedef enum _RM_COMMAND_NUMBER {

    RmDummyCommand = 0,
    RmAuditSetCommand,
    RmCreateLogonSession,
    RmDeleteLogonSession

} RM_COMMAND_NUMBER;

#define RM_MAXIMUM_COMMAND_PARAM_SIZE                                \
    ((ULONG) PORT_MAXIMUM_MESSAGE_LENGTH - sizeof(PORT_MESSAGE) -      \
    sizeof(RM_COMMAND_NUMBER))

typedef struct _RM_COMMAND_MESSAGE {

    PORT_MESSAGE MessageHeader;
    RM_COMMAND_NUMBER CommandNumber;
    UCHAR CommandParams[RM_MAXIMUM_COMMAND_PARAM_SIZE];

} RM_COMMAND_MESSAGE, *PRM_COMMAND_MESSAGE;

//
// Reference Monitor Command Reply Message Structure.
//

#define RM_MAXIMUM_REPLY_BUFFER_SIZE                                 \
    ((ULONG) PORT_MAXIMUM_MESSAGE_LENGTH - sizeof(PORT_MESSAGE) -      \
    sizeof(RM_COMMAND_NUMBER))


typedef struct _RM_REPLY_MESSAGE {

    PORT_MESSAGE MessageHeader;
    NTSTATUS ReturnedStatus;
    UCHAR ReplyBuffer[RM_MAXIMUM_REPLY_BUFFER_SIZE];

} RM_REPLY_MESSAGE, *PRM_REPLY_MESSAGE;

#define RM_COMMAND_MESSAGE_HEADER_SIZE                  \
    (sizeof(PORT_MESSAGE) + sizeof(NTSTATUS) + sizeof(RM_COMMAND_NUMBER))

//
// Local Security Authority Command Message Structure.  This structure is
// used by the Reference Monitor to send commands to the Local Security
// Authority via the LSA Server Command LPC Port.
//

#define LsapMinimumCommand LsapWriteAuditMessageCommand
#define LsapMaximumCommand LsapLogonSessionDeletedCommand

typedef enum _LSA_COMMAND_NUMBER {
    LsapDummyCommand = 0,
    LsapWriteAuditMessageCommand,
    LsapComponentTestCommand,
    LsapLogonSessionDeletedCommand
} LSA_COMMAND_NUMBER;

#define LSA_MAXIMUM_COMMAND_PARAM_SIZE                                \
    ((ULONG) PORT_MAXIMUM_MESSAGE_LENGTH - sizeof(PORT_MESSAGE) -     \
    sizeof(LSA_COMMAND_NUMBER) - sizeof(SEP_RM_LSA_MEMORY_TYPE))

typedef struct _LSA_COMMAND_MESSAGE {
    PORT_MESSAGE MessageHeader;
    LSA_COMMAND_NUMBER CommandNumber;
    SEP_RM_LSA_MEMORY_TYPE CommandParamsMemoryType;
    UCHAR CommandParams[LSA_MAXIMUM_COMMAND_PARAM_SIZE];
} LSA_COMMAND_MESSAGE, *PLSA_COMMAND_MESSAGE;

//
// LSA Command Reply Message Structure.
//

#define LSA_MAXIMUM_REPLY_BUFFER_SIZE                                 \
    ((ULONG) PORT_MAXIMUM_MESSAGE_LENGTH - sizeof(PORT_MESSAGE) -      \
    sizeof(LSA_COMMAND_NUMBER))

typedef struct _LSA_REPLY_MESSAGE {
    PORT_MESSAGE MessageHeader;
    NTSTATUS ReturnedStatus;
    UCHAR ReplyBuffer[LSA_MAXIMUM_REPLY_BUFFER_SIZE];
} LSA_REPLY_MESSAGE, *PLSA_REPLY_MESSAGE;

//
// Command Parameter format for the special RmSendCommandToLsaCommand
//

typedef struct _RM_SEND_COMMAND_TO_LSA_PARAMS {
    LSA_COMMAND_NUMBER LsaCommandNumber;
    ULONG LsaCommandParamsLength;
    UCHAR LsaCommandParams[LSA_MAXIMUM_COMMAND_PARAM_SIZE];
} RM_SEND_COMMAND_TO_LSA_PARAMS, *PRM_SEND_COMMAND_TO_LSA_PARAMS;

//
// Command Values for the LSA and RM Component Test Commands
//

#define LSA_CT_COMMAND_PARAM_VALUE 0x00823543
#define RM_CT_COMMAND_PARAM_VALUE 0x33554432


//
// Audit Record Pointer Field Type
//

typedef enum _SE_ADT_POINTER_FIELD_TYPE {

    NullFieldType,
    UnicodeStringType,
    SidType,
    PrivilegeSetType,
    MiscFieldType

} SE_ADT_POINTER_FIELD_TYPE, *PSE_ADT_POINTER_FIELD_TYPE;


//
// Hardwired Audit Event Type counts
//

#define AuditEventMinType   (AuditCategorySystem)
#define AuditEventMaxType   (AuditCategoryAccountLogon)

#define POLICY_AUDIT_EVENT_TYPE_COUNT                                 \
    ((ULONG) AuditEventMaxType - AuditEventMinType + 1)

#define LSARM_AUDIT_EVENT_OPTIONS_SIZE                                    \
    (((ULONG)(POLICY_AUDIT_EVENT_TYPE_COUNT) * sizeof (POLICY_AUDIT_EVENT_OPTIONS)))

//
// Self-Relative form of POLICY_AUDIT_EVENTS_INFO
//

typedef struct _LSARM_POLICY_AUDIT_EVENTS_INFO {

    BOOLEAN AuditingMode;
    POLICY_AUDIT_EVENT_OPTIONS EventAuditingOptions[POLICY_AUDIT_EVENT_TYPE_COUNT];
    ULONG MaximumAuditEventCount;

} LSARM_POLICY_AUDIT_EVENTS_INFO, *PLSARM_POLICY_AUDIT_EVENTS_INFO;

//
// The following symbol defines the value containing whether or not we're supposed
// to crash when an audit fails.  It is used in the se and lsasrv directories.
//

#define CRASH_ON_AUDIT_FAIL_VALUE   L"CrashOnAuditFail"

//
// These are the possible values for the CrashOnAuditFail flag.
//

#define LSAP_CRASH_ON_AUDIT_FAIL 1
#define LSAP_ALLOW_ADIMIN_LOGONS_ONLY 2



#endif // _NTRMLSA_
=== C:/Users/treeman/Desktop/windows nt source code\Source\Win2K3\NT\public\internal\ds\inc\notifyev.h ===
/*************************************************************************
*
* notifyev.h        !!!! DO NOT EDIT THIS FILE !!!!
*
* Winlogon notification DLL error codes
*
* NOTE: generated from: \nt\private\dllmerge\wlnotify\notifyev.mc
*
*
* Copyright Microsoft Corporation, 1998
*
*************************************************************************/




/*************************************************************************
*
 TSNOTIFY Events:
*
*************************************************************************/


#define CATEGORY_NOTIFY_EVENTS 1
//
//  Values are 32 bit values layed out as follows:
//
//   3 3 2 2 2 2 2 2 2 2 2 2 1 1 1 1 1 1 1 1 1 1
//   1 0 9 8 7 6 5 4 3 2 1 0 9 8 7 6 5 4 3 2 1 0 9 8 7 6 5 4 3 2 1 0
//  +---+-+-+-----------------------+-------------------------------+
//  |Sev|C|R|     Facility          |               Code            |
//  +---+-+-+-----------------------+-------------------------------+
//
//  where
//
//      Sev - is the severity code
//
//          00 - Success
//          01 - Informational
//          10 - Warning
//          11 - Error
//
//      C - is the Customer code flag
//
//      R - is a reserved bit
//
//      Facility - is the facility code
//
//      Code - is the facility's status code
//
//
// Define the facility codes
//


//
// Define the severity codes
//


//
// MessageId: 0x00000001L (No symbolic name defined)
//
// MessageText:
//
//  Terminal Server Notify Events
//


//
// MessageId: EVENT_NOTIFY_INIT_FAILED
//
// MessageText:
//
//  TS RDPDR Device Redirection failed to initialize for a single user session %1.  Serial, Parallel, Printer, and File System Redirection will be disabled.  Look in the System event log for other related errors.
//
#define EVENT_NOTIFY_INIT_FAILED         0x0000044CL

//
// MessageId: EVENT_NOTIFY_RDPDR_FAILED
//
// MessageText:
//
//  The RDPDR device manager component could not be opened.  Check the status of the Terminal Service Device Redirector in the Device Manager.
//
#define EVENT_NOTIFY_RDPDR_FAILED        0x0000044DL

//
// MessageId: EVENT_NOTIFY_DRIVER_NOT_FOUND
//
// MessageText:
//
//  Driver %1 required for printer %2 is not installed on the server. Contact the administrator to install the driver before you log in again.
//
#define EVENT_NOTIFY_DRIVER_NOT_FOUND    0x0000044EL

//
// MessageId: EVENT_NOTIFY_PRINTER_REDIRECTION_FAILED
//
// MessageText:
//
//  An internal communication error occurred.  Redirected printing will no longer function for a single user session.  Check the status of the Terminal Services Device Redirector in the System folder of Device Manager.
//
#define EVENT_NOTIFY_PRINTER_REDIRECTION_FAILED 0x0000044FL

//
// MessageId: EVENT_NOTIFY_OPENPRINTER_FAILED
//
// MessageText:
//
//  The printer %1 could not be opened.
//
#define EVENT_NOTIFY_OPENPRINTER_FAILED  0x00000450L

//
// MessageId: EVENT_NOTIFY_SET_PRINTER_ACL_FAILED
//
// MessageText:
//
//  Printer security information for the printer %1 could not be set.
//
#define EVENT_NOTIFY_SET_PRINTER_ACL_FAILED 0x00000451L

//
// MessageId: EVENT_NOTIFY_INSTALL_PRINTER_FAILED
//
// MessageText:
//
//  The printer could not be installed.
//
#define EVENT_NOTIFY_INSTALL_PRINTER_FAILED 0x00000452L

//
// MessageId: EVENT_NOTIFY_DELETE_PRINTER_FAILED
//
// MessageText:
//
//  The printer %1 could not be deleted.
//
#define EVENT_NOTIFY_DELETE_PRINTER_FAILED 0x00000453L

//
// MessageId: EVENT_NOTIFY_RESTORE_PRINTER_CONFIG_FAILED
//
// MessageText:
//
//  Configuration information for the %1 printer could not be restored. 
//
#define EVENT_NOTIFY_RESTORE_PRINTER_CONFIG_FAILED 0x00000454L

//
// MessageId: EVENT_NOTIFY_SETDEFAULTPRINTER_FAILED
//
// MessageText:
//
//  The %1 printer could not be set as the default printer.
//
#define EVENT_NOTIFY_SETDEFAULTPRINTER_FAILED 0x00000455L

//
// MessageId: EVENT_NOTIFY_ERRORPARSINGINF
//
// MessageText:
//
//  An error occurred during processing of %1. The file might be corrupted. Run Setup again to reinstall the file. 
//
#define EVENT_NOTIFY_ERRORPARSINGINF     0x00000456L

//
// MessageId: EVENT_NOTIFY_UNKNOWN_PRINTER_DRIVER
//
// MessageText:
//
//  Driver %1 required for printer %2 is unknown. Contact the administrator to install the driver before you log in again.
//
#define EVENT_NOTIFY_UNKNOWN_PRINTER_DRIVER 0x00000457L

//
// MessageId: EVENT_NOTIFY_FAILEDTOREGFOR_SETTING_NOTIFY
//
// MessageText:
//
//  Failed to register for user printing preferences change notification.  Open the Services snap-in and confirm that the Printer Spooler service is running 
//
#define EVENT_NOTIFY_FAILEDTOREGFOR_SETTING_NOTIFY 0x00000458L

//
// MessageId: EVENT_NOTIFY_INSUFFICIENTRESOURCES
//
// MessageText:
//
//  There is not enough memory to complete the operation. Save your work, close other programs, and then try again.
//
#define EVENT_NOTIFY_INSUFFICIENTRESOURCES 0x00000459L

//
// MessageId: EVENT_NOTIFY_SPOOLERERROR
//
// MessageText:
//
//  Error communicating with the Spooler system service.  Open the Services snap-in and confirm that the Print Spooler service is running.
//
#define EVENT_NOTIFY_SPOOLERERROR        0x0000045AL

//
// MessageId: EVENT_NOTIFY_INTERNALERROR
//
// MessageText:
//
//  Unexpected internal error in TS RDP device redirection.  Contact technical support.
//
#define EVENT_NOTIFY_INTERNALERROR       0x0000045BL
=== C:/Users/treeman/Desktop/windows nt source code\Source\Win2K3\NT\public\internal\ds\inc\nwapi32.h ===
//////////////////////////////////////////////////////////////////////////////
//
//  Copyright (C) 1993 Microsoft Corporation
//
//  Module Name:
//
//      nwapi32.h
//
//  Abstract:
//
//      This module contains the support for calls into CSNW.
//
//  Author:
//
//      Chris Sandys    (a-chrisa)  09-Sep-1993
//
//  Revision History:
//      Chuck Y Chan    Feb 3, 1994    Make it NT like
//      Chuck Y Chan    Feb 4, 1996    Merged in calls used by DSMN (from
//                                     nwcapi32.h)
//
//////////////////////////////////////////////////////////////////////////////


#ifndef _NWAPI32_H_
#define _NWAPI32_H_

#ifdef __cplusplus
extern "C" {
#endif /* __cplusplus */


//
// Order of Funtions
//
//    NWAddTrusteeToDirectory
//    NWAllocTemporaryDirectoryHandle
//    NWAllocPermanentDirectoryHandle
//    NWAttachToFileServer
//    NWCheckConsolePrivileges
//    NWDeallocateDirectoryHandle
//    NWDetachFromFileServer
//    NWGetFileServerVersionInfo
//    NWGetInternetAddress
//    NWGetObjectName
//    NWGetVolumeInfoWithHandle
//    NWGetVolumeInfoWithNumber
//    NWGetVolumeName
//    NWIsObjectInSet
//    NWLoginToFileServer
//    NWLogoutFromFileServer
//    NWReadPropertyValue
//    NWScanObject
//    NWScanProperty


///////////////////////////////////////////////////////////////////////////////
//                                                                           //
// Manifests and structures                                                  //
//                                                                           //
///////////////////////////////////////////////////////////////////////////////

//
// Version Structure
//
#include <packon.h>

typedef struct _VERSION_INFO {
    BYTE szName[48];
    BYTE Version;
    BYTE SubVersion;
    WORD ConnsSupported;
    WORD connsInUse;
    WORD maxVolumes;
    BYTE OSRev;
    BYTE SFTLevel;
    BYTE TTSLevel;
    WORD PeakConns;
    BYTE AcctVer;
    BYTE VAPVer;
    BYTE QueueVer;
    BYTE PrintVer;
    BYTE VirtualConsoleVer;
    BYTE SecurityResLevel;
    BYTE InternetworkBVer;
    BYTE Reserved[60];
} VERSION_INFO;

#include <packoff.h>

//
// DLL Defination
//
#define DLLEXPORT

//
// Misc type definitions
//
#define NWCCODE              USHORT
#define NWLOCAL_SCOPE        USHORT
#define NWCONN_HANDLE        HANDLE
#define NWFAR
#define NWAPI                WINAPI
#define NWOBJ_TYPE           USHORT
#define NWOBJ_ID             DWORD
#define NWFLAGS              UCHAR
#define NWVOL_NUM            UCHAR
#define NWDIR_HANDLE         UCHAR
#define NWACCESS_RIGHTS      BYTE
#define NWCONN_NUM           USHORT
#define NWNET_ADDR           UCHAR
#define NWNUMBER             WORD
#define NWVOL_FLAGS          WORD
#define NWSEGMENT_NUM        UCHAR
#define NWSEGMENT_DATA       BYTE
#define NWRIGHTS_MASK        WORD
#define NWSEQUENCE           BYTE
#define NWINDEX_TYPE         USHORT
#define NWDATE_TIME          DWORD
#define NWDIR_TRUSTEE_RIGHTS WORD
#define NWSEQUENCE           BYTE

typedef struct {
   NWOBJ_ID             objectID;
   NWDIR_TRUSTEE_RIGHTS objectRights;
} TRUSTEE_INFO;

//
// Object Types (already in HI-LO format)
//
#define OT_WILD                  0xFFFF
#define OT_UNKNOWN               0x0000
#define OT_USER                  0x0100
#define OT_USER_GROUP            0x0200
#define OT_PRINT_QUEUE           0x0300
#define OT_FILE_SERVER           0x0400
#define OT_JOB_SERVER            0x0500
#define OT_GATEWAY               0x0600
#define OT_PRINT_SERVER          0x0700
#define OT_ARCHIVE_QUEUE         0x0800
#define OT_ARCHIVE_SERVER        0x0900
#define OT_JOB_QUEUE             0x0A00
#define OT_ADMINISTRATION        0x0B00
#define OT_NAS_SNA_GATEWAY       0x2100
#define OT_REMOTE_BRIDGE_SERVER  0x2600
#define OT_TCPIP_GATEWAY         0x2700
#define OT_DIRSERVER             0x7802

//
// Bindery object property flag
//
#define BF_STATIC                0x00
#define BF_DYNAMIC               0x01
#define BF_ITEM                  0x00
#define BF_SET                   0x02

//
// Bindery object security flag
//
#define BS_ANY_READ              0x00
#define BS_LOGGED_READ           0x01
#define BS_OBJECT_READ           0x02
#define BS_SUPER_READ            0x03
#define BS_BINDERY_READ          0x04
#define BS_ANY_WRITE             0x00
#define BS_LOGGED_WRITE          0x10
#define BS_OBJECT_WRITE          0x20
#define BS_SUPER_WRITE           0x30
#define BS_BINDERY_WRITE         0x40

//
// Size Of Things
//
#define OBJ_NAME_SIZE            48            // ScanObject name size
#define VOL_NAME_SIZE            16            // Get Volume Name Size
#define NW_USER_SIZE             50
#define NW_GROUP_SIZE            50
#define NW_PROP_SIZE             50
#define NW_DATA_SIZE             128
#define NW_PROP_SET              0x02

//
// Return Codes
//
#define UNSUCCESSFUL                  -1
#define SUCCESSFUL                    0x0000
#define REQUESTER_ERROR               0x8800

#define ALREADY_ATTACHED              0x8800
#define INVALID_CONNECTION            0x8801
#define NO_CONSOLE_RIGHTS             0x89C6
#define SERVER_OUT_OF_MEMORY          0x8996
#define VOLUME_DOES_NOT_EXIST         0x8998
#define BAD_DIRECTORY_HANDLE          0x899B
#define INVALID_PATH                  0x899C
#define OBJECT_ALREADY_EXISTS         0x89EE
#define NO_OBJECT_READ_PRIVILEGE      0x89FB
#define NO_SUCH_PROPERTY              0x89FB
#define UNKNOWN_FILE_SERVER           0x89FC
#define NO_SUCH_OBJECT                0x89FC
#define NO_FILES_FOUND_ERROR          0x89FF

//
// Swap MACROS
//
#define wSWAP(x) (USHORT)(((((USHORT)x)<<8)&0xFF00) | ((((USHORT)x)>>8)&0x00FF))
#define dwSWAP(x) (DWORD)( ((((DWORD)x)<<24)&0xFF000000) | ((((DWORD)x)<<8)&0x00FF0000) | ((((DWORD)x)>>8)&0x0000FF00) | ((((DWORD)x)>>24)&0x000000FF) )

#define DW_SIZE 4               // used for placing RAW bytes
#define W_SIZE  2


///////////////////////////////////////////////////////////////////////////////
//                                                                           //
// Original functions from Chris Sandys. Keep for compatibility.             //
//                                                                           //
///////////////////////////////////////////////////////////////////////////////

NWCCODE NWAPI DLLEXPORT
NWAddTrusteeToDirectory(
    NWCONN_HANDLE           hConn,
    NWDIR_HANDLE            dirHandle,
    const char      NWFAR   *pszPath,
    NWOBJ_ID                dwTrusteeID,
    NWACCESS_RIGHTS         rightsMask
    );

NWCCODE NWAPI DLLEXPORT
NWAllocPermanentDirectoryHandle(
    NWCONN_HANDLE           hConn,
    NWDIR_HANDLE            dirHandle,
    char            NWFAR   *pszDirPath,
    NWDIR_HANDLE    NWFAR   *pbNewDirHandle,
    NWACCESS_RIGHTS NWFAR   *pbRightsMask
    );

NWCCODE NWAPI DLLEXPORT
NWAllocTemporaryDirectoryHandle(
    NWCONN_HANDLE           hConn,
    NWDIR_HANDLE            dirHandle,
    char            NWFAR   *pszDirPath,
    NWDIR_HANDLE    NWFAR   *pbNewDirHandle,
    NWACCESS_RIGHTS NWFAR   *pbRightsMask
    );

NWCCODE NWAPI DLLEXPORT
NWAttachToFileServer(
    const char      NWFAR   *pszServerName,
    NWLOCAL_SCOPE           ScopeFlag,
    NWCONN_HANDLE   NWFAR   *phNewConn
    );

NWCCODE NWAPI DLLEXPORT
NWAttachToFileServerW(
    const WCHAR     NWFAR   *pszServerName,
    NWLOCAL_SCOPE           ScopeFlag,
    NWCONN_HANDLE   NWFAR   *phNewConn
    );

NWCCODE NWAPI DLLEXPORT
NWCheckConsolePrivileges(
    NWCONN_HANDLE           hConn
    );

NWCCODE NWAPI DLLEXPORT
NWDeallocateDirectoryHandle(
    NWCONN_HANDLE           hConn,
    NWDIR_HANDLE            dirHandle
    );

NWCCODE NWAPI DLLEXPORT
NWDetachFromFileServer(
    NWCONN_HANDLE           hConn
    );

NWCCODE NWAPI DLLEXPORT
NWGetFileServerVersionInfo(
    NWCONN_HANDLE           hConn,
    VERSION_INFO    NWFAR   *lpVerInfo
    );

NWCCODE NWAPI DLLEXPORT
NWGetInternetAddress(
    NWCONN_HANDLE           hConn,
    NWCONN_NUM              nConnNum,
    NWNET_ADDR      NWFAR   *pIntAddr
    );

NWCCODE NWAPI DLLEXPORT
NWGetObjectName(
    NWCONN_HANDLE           hConn,
    NWOBJ_ID                dwObjectID,
    char            NWFAR   *pszObjName,
    NWOBJ_TYPE      NWFAR   *pwObjType
    );

NWCCODE NWAPI DLLEXPORT
NWGetVolumeInfoWithHandle(
    NWCONN_HANDLE           hConn,
    NWDIR_HANDLE            nDirHand,
    char        NWFAR       *pszVolName,
    NWNUMBER    NWFAR       *pwTotalBlocks,
    NWNUMBER    NWFAR       *pwSectors,
    NWNUMBER    NWFAR       *pwAvailBlocks,
    NWNUMBER    NWFAR       *pwTotalDir,
    NWNUMBER    NWFAR       *pwAvailDir,
    NWVOL_FLAGS NWFAR       *pfVolRemovable
    );

NWCCODE NWAPI DLLEXPORT
NWGetVolumeInfoWithNumber(
    NWCONN_HANDLE           hConn,
    NWVOL_NUM               nVolNum,
    char        NWFAR       *pszVolName,
    NWNUMBER    NWFAR       *pwTotalBlocks,
    NWNUMBER    NWFAR       *pwSectors,
    NWNUMBER    NWFAR       *pwAvailBlocks,
    NWNUMBER    NWFAR       *pwTotalDir,
    NWNUMBER    NWFAR       *pwAvailDir,
    NWVOL_FLAGS NWFAR       *pfVolRemovable
    );

NWCCODE NWAPI DLLEXPORT
NWGetVolumeName(
    NWCONN_HANDLE           hConn,
    NWVOL_NUM               bVolNum,
    char            NWFAR   *pszVolName
    );

NWCCODE NWAPI DLLEXPORT                       /* ??? */
NWLoginToFileServer(
    NWCONN_HANDLE           hConn,
    const char      NWFAR   *pszUserName,
    NWOBJ_TYPE              wObType,
    const char      NWFAR   *pszPassword
    );

NWCCODE NWAPI DLLEXPORT                       /* ??? */
NWLogoutFromFileServer(
    NWCONN_HANDLE           hConn
    );

NWCCODE NWAPI DLLEXPORT                       /* ??? */
NWReadPropertyValue(
    NWCONN_HANDLE           hConn,
    const char      NWFAR   *pszObjName,
    NWOBJ_TYPE              wObjType,
    char            NWFAR   *pszPropName,
    unsigned char           ucSegment,
    char            NWFAR   *pValue,
    NWFLAGS         NWFAR   *pucMoreFlag,
    NWFLAGS         NWFAR   *pucPropFlag
    );


NWCCODE NWAPI DLLEXPORT
NWScanObject(
    NWCONN_HANDLE           hConn,
    const char      NWFAR   *pszSearchName,
    NWOBJ_TYPE              wObjSearchType,
    NWOBJ_ID        NWFAR   *pdwObjectID,
    char            NWFAR   *pszObjectName,
    NWOBJ_TYPE      NWFAR   *pwObjType,
    NWFLAGS         NWFAR   *pucHasProperties,
    NWFLAGS         NWFAR   *pucObjectFlags,
    NWFLAGS         NWFAR   *pucObjSecurity
    );

NWCCODE NWAPI DLLEXPORT
NWScanProperty(
    NWCONN_HANDLE           hConn,
    const char      NWFAR   *pszObjectName,
    NWOBJ_TYPE              wObjType,
    char            NWFAR   *pszSearchName,
    NWOBJ_ID        NWFAR   *pdwSequence,
    char            NWFAR   *pszPropName,
    NWFLAGS         NWFAR   *pucPropFlags,
    NWFLAGS         NWFAR   *pucPropSecurity,
    NWFLAGS         NWFAR   *pucHasValue,
    NWFLAGS         NWFAR   *pucMore
    );

NWCCODE NWAPI DLLEXPORT
NWIsObjectInSet(
    NWCONN_HANDLE           hConn,
    const char      NWFAR   *lpszObjectName,
    NWOBJ_TYPE              wObjType,
    const char      NWFAR   *lpszPropertyName,
	const char 		NWFAR	*lpszMemberName,
	NWOBJ_TYPE				wMemberType
    );

NWCCODE NWAPI DLLEXPORT
NWGetFileServerDateAndTime(
    NWCONN_HANDLE           hConn,
    BYTE            NWFAR   *year,
    BYTE            NWFAR   *month,
    BYTE            NWFAR   *day,
    BYTE            NWFAR   *hour,
    BYTE            NWFAR   *minute,
    BYTE            NWFAR   *second,
    BYTE            NWFAR   *dayofweek
    );

NWCCODE NWAPI DLLEXPORT
NWCreateQueue(
    NWCONN_HANDLE           hConn,
    NWDIR_HANDLE            dirHandle,
    const char    NWFAR     *pszQueueName,
    NWOBJ_TYPE              wQueueType,
    const char    NWFAR     *pszPathName,
    NWOBJ_ID      NWFAR     *pdwQueueId
    );

NWCCODE NWAPI DLLEXPORT
NWChangePropertySecurity(
    NWCONN_HANDLE           hConn,
    const char      NWFAR   *pszObjName,
    NWOBJ_TYPE              wObjType,
    const char      NWFAR   *pszPropertyName,
    NWFLAGS                 ucObjSecurity
    );

NWCCODE NWAPI DLLEXPORT
NWDestroyQueue(
    NWCONN_HANDLE hConn,
    NWOBJ_ID      dwQueueId
    );

///////////////////////////////////////////////////////////////////////////////
//                                                                           //
// Newer and more complete NWC functions.                                    //
//                                                                           //
// These functions return NetWare compatible error codes. Win32 error may    //
// be obtained by calling GetLastError().                                    //
//                                                                           //
///////////////////////////////////////////////////////////////////////////////


NWCCODE
NWCAddTrusteeToDirectory(
    NWCONN_HANDLE           hConn,
    NWDIR_HANDLE            dirHandle,
    const char              *pszPath,
    NWOBJ_ID                dwTrusteeID,
    NWACCESS_RIGHTS         rightsMask
    );

NWCCODE
NWCAllocPermanentDirectoryHandle(
    NWCONN_HANDLE           hConn,
    NWDIR_HANDLE            dirHandle,
    char                    *pszDirPath,
    NWDIR_HANDLE            *pbNewDirHandle,
    NWACCESS_RIGHTS         *pbRightsMask
    );

NWCCODE
NWCAllocTemporaryDirectoryHandle(
    NWCONN_HANDLE           hConn,
    NWDIR_HANDLE            dirHandle,
    char                    *pszDirPath,
    NWDIR_HANDLE            *pbNewDirHandle,
    NWACCESS_RIGHTS         *pbRightsMask
    );

NWCCODE
NWCAttachToFileServer(
    const char              *pszServerName,
    NWLOCAL_SCOPE           ScopeFlag,
    NWCONN_HANDLE           *phNewConn
    );

NWCCODE
NWCAttachToFileServerW(
    const WCHAR             *pszServerName,
    NWLOCAL_SCOPE           ScopeFlag,
    NWCONN_HANDLE           *phNewConn
    );

NWCCODE
NWCCheckConsolePrivileges(
    NWCONN_HANDLE           hConn
    );

NWCCODE
NWCDeallocateDirectoryHandle(
    NWCONN_HANDLE           hConn,
    NWDIR_HANDLE            dirHandle
    );

NWCCODE
NWCDetachFromFileServer(
    NWCONN_HANDLE           hConn
    );

NWCCODE
NWCGetFileServerVersionInfo(
    NWCONN_HANDLE           hConn,
    VERSION_INFO            *lpVerInfo
    );

NWCCODE
NWCGetInternetAddress(
    NWCONN_HANDLE           hConn,
    NWCONN_NUM              nConnNum,
    NWNET_ADDR              *pIntAddr
    );

NWCCODE
NWCGetObjectName(
    NWCONN_HANDLE           hConn,
    NWOBJ_ID                dwObjectID,
    char                    *pszObjName,
    NWOBJ_TYPE              *pwObjType
    );

NWCCODE
NWCGetVolumeInfoWithHandle(
    NWCONN_HANDLE           hConn,
    NWDIR_HANDLE            nDirHand,
    char                    *pszVolName,
    NWNUMBER                *pwTotalBlocks,
    NWNUMBER                *pwSectors,
    NWNUMBER                *pwAvailBlocks,
    NWNUMBER                *pwTotalDir,
    NWNUMBER                *pwAvailDir,
    NWVOL_FLAGS             *pfVolRemovable
    );

NWCCODE
NWCGetVolumeInfoWithNumber(
    NWCONN_HANDLE           hConn,
    NWVOL_NUM               nVolNum,
    char                    *pszVolName,
    NWNUMBER                *pwTotalBlocks,
    NWNUMBER                *pwSectors,
    NWNUMBER                *pwAvailBlocks,
    NWNUMBER                *pwTotalDir,
    NWNUMBER                *pwAvailDir,
    NWVOL_FLAGS             *pfVolRemovable
    );

NWCCODE
NWCGetVolumeName(
    NWCONN_HANDLE           hConn,
    NWVOL_NUM               bVolNum,
    char                    *pszVolName
    );

NWCCODE
NWCLoginToFileServer(
    NWCONN_HANDLE           hConn,
    const char              *pszUserName,
    NWOBJ_TYPE              wObType,
    const char              *pszPassword
    );

NWCCODE
NWCLogoutFromFileServer(
    NWCONN_HANDLE           hConn
    );

NWCCODE
NWCReadPropertyValue(
    NWCONN_HANDLE           hConn,
    const char              *pszObjName,
    NWOBJ_TYPE              wObjType,
    char                    *pszPropName,
    unsigned char           ucSegment,
    char                    *pValue,
    NWFLAGS                 *pucMoreFlag,
    NWFLAGS                 *pucPropFlag
    );


NWCCODE
NWCScanObject(
    NWCONN_HANDLE           hConn,
    const char              *pszSearchName,
    NWOBJ_TYPE              wObjSearchType,
    NWOBJ_ID                *pdwObjectID,
    char                    *pszObjectName,
    NWOBJ_TYPE              *pwObjType,
    NWFLAGS                 *pucHasProperties,
    NWFLAGS                 *pucObjectFlags,
    NWFLAGS                 *pucObjSecurity
    );

NWCCODE
NWCScanProperty(
    NWCONN_HANDLE           hConn,
    const char              *pszObjectName,
    NWOBJ_TYPE              wObjType,
    char                    *pszSearchName,
    NWOBJ_ID                *pdwSequence,
    char                    *pszPropName,
    NWFLAGS                 *pucPropFlags,
    NWFLAGS                 *pucPropSecurity,
    NWFLAGS                 *pucHasValue,
    NWFLAGS                 *pucMore
    );

NWCCODE
NWCIsObjectInSet(
    NWCONN_HANDLE           hConn,
    const char              *lpszObjectName,
    NWOBJ_TYPE              wObjType,
    const char              *lpszPropertyName,
    const char 		    *lpszMemberName,
    NWOBJ_TYPE              wMemberType
    );

NWCCODE
NWCGetFileServerDateAndTime(
    NWCONN_HANDLE           hConn,
    BYTE                    *year,
    BYTE                    *month,
    BYTE                    *day,
    BYTE                    *hour,
    BYTE                    *minute,
    BYTE                    *second,
    BYTE                    *dayofweek
    );

NWCCODE
NWCAddTrustee(
    NWCONN_HANDLE           hConn,
    NWDIR_HANDLE            dirHandle,
    const char              *pszPath,
    NWOBJ_ID                dwTrusteeID,
    NWRIGHTS_MASK           rightsMask
    );

NWCCODE
NWCDeleteObject(
    NWCONN_HANDLE           hConn,
    const char              *pszObjectName,
    NWOBJ_TYPE              wObjType
    );

NWCCODE
NWCCreateObject(
    NWCONN_HANDLE           hConn,
    const char              *pszObjectName,
    NWOBJ_TYPE              wObjType,
    NWFLAGS                 ucObjectFlags,
    NWFLAGS                 ucObjSecurity
    );

NWCCODE
NWCCreateProperty(
    NWCONN_HANDLE           hConn,
    const char              *pszObjectName,
    NWOBJ_TYPE              wObjType,
    const char              *pszPropertyName,
    NWFLAGS                 ucObjectFlags,
    NWFLAGS                 ucObjSecurity
    );

NWCCODE
NWCDeleteProperty(
    NWCONN_HANDLE           hConn,
    const char              *pszObjectName,
    NWOBJ_TYPE              wObjType,
    const char              *pszPropertyName
    );

NWCCODE
NWCWritePropertyValue(
    NWCONN_HANDLE           hConn,
    const char              *pszObjectName,
    NWOBJ_TYPE              wObjType,
    const char              *pszPropertyName,
    NWSEGMENT_NUM           segmentNumber,
    NWSEGMENT_DATA          *segmentData,
    NWFLAGS                 moreSegments
    );

NWCCODE
NWCGetObjectID(
    NWCONN_HANDLE           hConn,
    const char              *pszObjectName,
    NWOBJ_TYPE              wObjType,
    NWOBJ_ID                *objectID
    );

NWCCODE
NWCRenameBinderyObject(
    NWCONN_HANDLE           hConn,
    const char              *pszObjectName,
    const char              *pszNewObjectName,
    NWOBJ_TYPE              wObjType
    );

NWCCODE
NWCAddObjectToSet(
    NWCONN_HANDLE           hConn,
    const char              *pszObjectName,
    NWOBJ_TYPE              wObjType,
    const char              *pszPropertyName,
    const char              *pszMemberName,
    NWOBJ_TYPE              memberType
    );

NWCCODE
NWCDeleteObjectFromSet(
    NWCONN_HANDLE           hConn,
    const char              *pszObjectName,
    NWOBJ_TYPE              wObjType,
    const char              *pszPropertyName,
    const char              *pszMemberName,
    NWOBJ_TYPE              memberType
    );

NWCCODE
NWCCreateDirectory(
    NWCONN_HANDLE           hConn,
    NWDIR_HANDLE            dirHandle,
    const char              *pszPath,
    NWACCESS_RIGHTS         accessMask
    );

NWCCODE
NWCScanForTrustees(
    NWCONN_HANDLE           hConn,
    NWDIR_HANDLE            dirHandle,
    char                    *pszsearchDirPath,
    NWSEQUENCE              *pucsequenceNumber,
    BYTE                    *numberOfEntries,
    TRUSTEE_INFO            *tl
    );

NWCCODE
NWCScanDirectoryForTrustees2(
    NWCONN_HANDLE           hConn,
    NWDIR_HANDLE            dirHandle,
    char                    *pszsearchDirPath,
    NWSEQUENCE              *pucsequenceNumber,
    char                    *pszdirName,
    NWDATE_TIME             *dirDateTime,
    NWOBJ_ID                *ownerID,
    TRUSTEE_INFO            *trusteeList
    );

NWCCODE
NWCGetBinderyAccessLevel(
    NWCONN_HANDLE           hConn,
    NWFLAGS                 *accessLevel,
    NWOBJ_ID                *objectID
    );

NWCCODE
NWCGetFileServerDescription(
    NWCONN_HANDLE           hConn,
    char                    *pszCompany,
    char                    *pszVersion,
    char                    *pszRevision
);

NWCCODE
NWCGetVolumeNumber(
    NWCONN_HANDLE           hConn,
    char                    *pszVolume,
    NWVOL_NUM               *VolumeNumber
);

NWCCODE
NWCGetVolumeUsage(
    NWCONN_HANDLE           hConn,
    NWVOL_NUM               VolumeNumber,
    DWORD                   *TotalBlocks,
    DWORD                   *FreeBlocks,
    DWORD                   *PurgeableBlocks,
    DWORD                   *NotYetPurgeableBlocks,
    DWORD                   *TotalDirectoryEntries,
    DWORD                   *AvailableDirectoryEntries,
    BYTE                    *SectorsPerBlock
);

NWCCODE
NWCCreateQueue(
    NWCONN_HANDLE           hConn,
    NWDIR_HANDLE            dirHandle,
    const char    NWFAR     *pszQueueName,
    NWOBJ_TYPE              wQueueType,
    const char    NWFAR     *pszPathName,
    NWOBJ_ID      NWFAR     *pdwQueueId
    );

NWCCODE
NWCChangePropertySecurity(
    NWCONN_HANDLE           hConn,
    const char      NWFAR   *pszObjName,
    NWOBJ_TYPE              wObjType,
    const char      NWFAR   *pszPropertyName,
    NWFLAGS                 ucObjSecurity
    );

NWCCODE
NWCDestroyQueue(
    NWCONN_HANDLE hConn,
    NWOBJ_ID      dwQueueId
    );

#ifdef __cplusplus
}
#endif  /* __cplusplus */

#endif //_NWAPI32_H_

=== C:/Users/treeman/Desktop/windows nt source code\Source\Win2K3\NT\public\internal\ds\inc\nwapi.h ===
/*++

Copyright (c) 1993  Microsoft Corporation

Module Name:

    api.h

Abstract:

    This module contains exposed APIs that is used by the
    NetWare Control Panel Applet.

Author:

    Yi-Hsin Sung   15-Jul-1993

Revision History:

--*/

#ifndef _NWAPI_INCLUDED_
#define _NWAPI_INCLUDED_

#include <nwcons.h>

//
// Bitmask for print options
//

#define NW_PRINT_SUPPRESS_FORMFEED    0x08
#define NW_PRINT_PRINT_BANNER         0x80
#define NW_PRINT_PRINT_NOTIFY         0x10

//
// Flags for logon script support.
//

#define NW_LOGONSCRIPT_DISABLED       0x00000000
#define NW_LOGONSCRIPT_ENABLED        0x00000001
#define NW_LOGONSCRIPT_4X_ENABLED     0x00000002
#define NW_LOGONSCRIPT_DEFAULT        NW_LOGONSCRIPT_DISABLED
#define NW_LOGONSCRIPT_DEBUG          0x00000800

//
// Values for turning on Sync login script flags.
//

#define SYNC_LOGONSCRIPT             0x1
#define RESET_SYNC_LOGONSCRIPT       0x2

//
// Bitmask for gateway redirections
//
#define NW_GW_UPDATE_REGISTRY         0x01
#define NW_GW_CLEANUP_DELETED         0x02

#ifdef __cplusplus
extern "C" {
#endif

DWORD
NwQueryInfo(
    OUT PDWORD pnPrintOption,
    OUT LPWSTR *ppszPreferredSrv
    );

DWORD
NwSetInfoInRegistry(
    IN DWORD  nPrintOption,
    IN LPWSTR pszPreferredSrv
    );

DWORD
NwSetLogonOptionsInRegistry(
    IN DWORD  nLogonScriptOptions
    );

DWORD
NwQueryLogonOptions(
    OUT PDWORD  pnLogonScriptOptions
    );

DWORD
NwSetInfoInWksta(
    IN DWORD  nPrintOption,
    IN LPWSTR pszPreferredSrv
    );

DWORD
NwSetLogonScript(
    IN DWORD  ScriptOptions
    );

DWORD
NwValidateUser(
    IN LPWSTR pszPreferredSrv
);

DWORD
NwEnumGWDevices(
    LPDWORD Index,
    LPBYTE Buffer,
    DWORD BufferSize,
    LPDWORD BytesNeeded,
    LPDWORD EntriesRead
    ) ;

DWORD
NwAddGWDevice(
    LPWSTR DeviceName,
    LPWSTR RemoteName,
    LPWSTR AccountName,
    LPWSTR Password,
    DWORD  Flags
    ) ;

DWORD
NwDeleteGWDevice(
    LPWSTR DeviceName,
    DWORD  Flags
    ) ;

DWORD
NwEnumConnections(
    HANDLE  hEnum,
    LPDWORD lpcCount,
    LPVOID  lpBuffer,
    LPDWORD lpBufferSize,
    BOOL    fImplicitConnections
    );

DWORD
NwLibSetEverybodyPermission(
    HKEY   hKey,
    DWORD  dwAccessPermission
    );

DWORD
NwQueryGatewayAccount(
    LPWSTR   AccountName,
    DWORD    AccountNameLen,
    LPDWORD  AccountCharsNeeded,
    LPWSTR   Password,
    DWORD    PasswordLen,
    LPDWORD  PasswordCharsNeeded
    );

DWORD
NwSetGatewayAccount(
    LPWSTR AccountName,
    LPWSTR Password
    );

DWORD
NwLogonGatewayAccount(
    LPWSTR AccountName,
    LPWSTR Password,
    LPWSTR Server
    );

DWORD
NwRegisterGatewayShare(
    IN LPWSTR ShareName,
    IN LPWSTR DriveName
    );

DWORD
NwClearGatewayShare(
    IN LPWSTR ShareName
    );

DWORD
NwCleanupGatewayShares(
    VOID
    );


VOID
MapSpecialJapaneseChars(
    LPSTR       lpszA,
    WORD        length
    );

VOID
UnmapSpecialJapaneseChars(
    LPSTR       lpszA,
    WORD        length
    );

LPSTR
NwDupStringA(
    const LPSTR lpszA,
    WORD        length
    );

#ifdef __cplusplus
} // extern "C"
#endif

#define NwFreeStringA(lp) if((lp) != NULL) { (void)LocalFree((lp)); }

#endif
=== C:/Users/treeman/Desktop/windows nt source code\Source\Win2K3\NT\public\internal\ds\inc\nwevent.h ===
/*++ BUILD Version: 0001    // Increment this if a change has global effects

Copyright (c) 1992  Microsoft Corporation

Module Name:

    nwevent.h

Abstract:

    Definitions for NetWare network events.

Author:

    Portable Systems Group 12/22/1992

Revision History:

Notes:

    This file is generated by the MC tool from the netevent.mc file.

--*/

#ifndef _NWEVENT_
#define _NWEVENT_


/////////////////////////////////////////////////////////////////////////
//
// NetWare Redirector Events
//
//
/////////////////////////////////////////////////////////////////////////



// Issued from kernel mode.  Don't use %1 for
// server-supplied insertion strings -- the I/O system provides the
// first string.

//
//  Values are 32 bit values layed out as follows:
//
//   3 3 2 2 2 2 2 2 2 2 2 2 1 1 1 1 1 1 1 1 1 1
//   1 0 9 8 7 6 5 4 3 2 1 0 9 8 7 6 5 4 3 2 1 0 9 8 7 6 5 4 3 2 1 0
//  +---+-+-+-----------------------+-------------------------------+
//  |Sev|C|R|     Facility          |               Code            |
//  +---+-+-+-----------------------+-------------------------------+
//
//  where
//
//      Sev - is the severity code
//
//          00 - Success
//          01 - Informational
//          10 - Warning
//          11 - Error
//
//      C - is the Customer code flag
//
//      R - is a reserved bit
//
//      Facility - is the facility code
//
//      Code - is the facility's status code
//
//
// Define the facility codes
//


//
// Define the severity codes
//
#define STATUS_SEVERITY_WARNING          0x2
#define STATUS_SEVERITY_SUCCESS          0x0
#define STATUS_SEVERITY_INFORMATIONAL    0x1
#define STATUS_SEVERITY_ERROR            0x3


//
// MessageId: EVENT_NWRDR_RESOURCE_SHORTAGE
//
// MessageText:
//
//  The Microsoft Client Service for NetWare redirector was unable to allocate memory.
//
#define EVENT_NWRDR_RESOURCE_SHORTAGE    0xC0001F41L

//
// MessageId: EVENT_NWRDR_CANT_CREATE_DEVICE
//
// MessageText:
//
//  The Microsoft Client Service for NetWare redirector could not create its device.  The redirector could not be started.
//
#define EVENT_NWRDR_CANT_CREATE_DEVICE   0xC0001F42L

//
// MessageId: EVENT_NWRDR_INVALID_REPLY
//
// MessageText:
//
//  The Microsoft Client Service for NetWare redirector received an incorrectly formatted response from %2.
//
#define EVENT_NWRDR_INVALID_REPLY        0xC0001F43L

//
// MessageId: EVENT_NWRDR_FAILED_UNLOCK
//
// MessageText:
//
//  The Microsoft Client Service for NetWare redirector failed to unlock part of a file on server %2.
//
#define EVENT_NWRDR_FAILED_UNLOCK        0xC0001F44L

//
// MessageId: EVENT_NWRDR_NETWORK_ERROR
//
// MessageText:
//
//  The Microsoft Client Service for NetWare redirector has encountered a network error.
//
#define EVENT_NWRDR_NETWORK_ERROR        0xC0001F45L

//
// MessageId: EVENT_NWRDR_UNEXPECTED_ERROR
//
// MessageText:
//
//  An unexpected network error has occurred on the connection to %2.
//
#define EVENT_NWRDR_UNEXPECTED_ERROR     0xC0001F46L

//
// MessageId: EVENT_NWRDR_TIMEOUT
//
// MessageText:
//
//  The Microsoft Client Service for NetWare redirector has timed out one or more requests to %2.
//
#define EVENT_NWRDR_TIMEOUT              0x80001F47L

//
// MessageId: EVENT_NWRDR_NO_SERVER_ON_NETWORK
//
// MessageText:
//
//  No NetWare or compatible server exists on this network.
//
#define EVENT_NWRDR_NO_SERVER_ON_NETWORK 0xC0001F48L

/////////////////////////////////////////////////////////////////////////
//
// NetWare Workstation Events
//
//
/////////////////////////////////////////////////////////////////////////
//
// MessageId: EVENT_NWWKSTA_NO_TRANSPORTS
//
// MessageText:
//
//  The Microsoft Client Service for NetWare could not start because it did not bind to any transports.
//
#define EVENT_NWWKSTA_NO_TRANSPORTS      0xC0002329L

//
// MessageId: EVENT_NWWKSTA_CANT_BIND_TO_TRANSPORT
//
// MessageText:
//
//  The Microsoft Client Service for NetWare could not bind to the transport %1.
//
#define EVENT_NWWKSTA_CANT_BIND_TO_TRANSPORT 0xC000232AL

//
// MessageId: EVENT_NWWKSTA_INVALID_REGISTRY_VALUE
//
// MessageText:
//
//  The value named %1 in the Microsoft Client Service for NetWare registry key %2 was invalid.  The value was
//  ignored, and processing continued.
//
#define EVENT_NWWKSTA_INVALID_REGISTRY_VALUE 0x8000232BL

//
// MessageId: EVENT_NWWKSTA_CANT_CREATE_REDIRECTOR
//
// MessageText:
//
//  The Microsoft Client Service for NetWare redirector (%1) could not be started.
//
#define EVENT_NWWKSTA_CANT_CREATE_REDIRECTOR 0xC000232CL

//
// MessageId: EVENT_NWWKSTA_GATEWAY_LOGON_FAILED
//
// MessageText:
//
//  The Gateway Account could not be logged on. The error %1 occurred.
//
#define EVENT_NWWKSTA_GATEWAY_LOGON_FAILED 0xC000232DL

//
// MessageId: EVENT_NWWKSTA_CANNOT_REDIRECT_DEVICES
//
// MessageText:
//
//  Device %1 could not be reconnected to %2. Error %3 occurred.
//
#define EVENT_NWWKSTA_CANNOT_REDIRECT_DEVICES 0xC000232EL

//
// MessageId: EVENT_NWWKSTA_WRONG_NWLINK_VERSION
//
// MessageText:
//
//  The version of the NWLINK transport present does not support all the capabilities required to use the Microsoft Client Service for NetWare properly.
//
#define EVENT_NWWKSTA_WRONG_NWLINK_VERSION 0xC000232FL

/////////////////////////////////////////////////////////////////////////
//
// NetWare Credential Manager Events
//
//
/////////////////////////////////////////////////////////////////////////
//
// MessageId: NW_MESSAGE_TITLE
//
// MessageText:
//
//  Client Service for NetWare%0
//
#define NW_MESSAGE_TITLE                 0x40002711L

//
// MessageId: NW_MESSAGE_FROM_SERVER
//
// MessageText:
//
//  Message from server %1. %n
//
#define NW_MESSAGE_FROM_SERVER           0x40002712L

//
// MessageId: NW_PASSWORD_HAS_EXPIRED
//
// MessageText:
//
//  The password for %1 on %2 has expired, with %3 grace logins left.%n
//
#define NW_PASSWORD_HAS_EXPIRED          0x80002713L

//
// MessageId: NW_LOGIN_DISABLED
//
// MessageText:
//
//  Logins to the server has been disabled.%n
//
#define NW_LOGIN_DISABLED                0xC0002714L

//
// MessageId: NW_PASSWORD_HAS_EXPIRED1
//
// MessageText:
//
//  The password for %1 on %2 has expired.%n
//
#define NW_PASSWORD_HAS_EXPIRED1         0xC0002715L

//
// MessageId: NW_MESSAGE_TITLE_NTAS
//
// MessageText:
//
//  Gateway Service for NetWare%0
//
#define NW_MESSAGE_TITLE_NTAS            0x40002716L


#endif // _NWEVENT
=== C:/Users/treeman/Desktop/windows nt source code\Source\Win2K3\NT\public\internal\ds\inc\nwrnames.h ===
/*++

Copyright (c) 1992-1993  Microsoft Corporation

Module Name:

    nwreg.h

Abstract:

    Header which specifies the registry location and value names
    of the logon credential information written by the provider and
    read by the workstation service.

    Also contains helper routine prototypes.

Author:

    Rita Wong      (ritaw)      22-Mar-1993

Revision History:

--*/

#ifndef _NWRNAMES_INCLUDED_
#define _NWRNAMES_INCLUDED_


#define NW_WORKSTATION_REGKEY              L"System\\CurrentControlSet\\Services\\NWCWorkstation\\Parameters"
#define NW_WORKSTATION_OPTION_REGKEY       L"System\\CurrentControlSet\\Services\\NWCWorkstation\\Parameters\\Option"
#define NW_INTERACTIVE_LOGON_REGKEY        L"System\\CurrentControlSet\\Services\\NWCWorkstation\\Parameters\\InteractiveLogon" //Terminal Server Addition
#define NW_SERVICE_LOGON_REGKEY            L"System\\CurrentControlSet\\Services\\NWCWorkstation\\Parameters\\ServiceLogon"
#define NW_WORKSTATION_GATEWAY_DRIVES      L"System\\CurrentControlSet\\Services\\NWCWorkstation\\Drives"
#define NW_WORKSTATION_GATEWAY_SHARES      L"System\\CurrentControlSet\\Services\\NWCWorkstation\\Shares"
#define NW_WORKSTATION_PROVIDER_PATH       L"System\\CurrentControlSet\\Services\\NWCWorkstation\\networkprovider"

#define NW_PROVIDER_VALUENAME              L"Name"

#define NW_CURRENTUSER_VALUENAME           L"CurrentUser"
#define NW_GATEWAYACCOUNT_VALUENAME        L"GatewayAccount"
#define NW_GATEWAY_ENABLE                  L"GatewayEnabled"

#define NW_SERVER_VALUENAME                L"PreferredServer"
#define NW_NDS_SERVER_VALUENAME            L"NdsPreferredServer"
#define NW_LOGONSCRIPT_VALUENAME           L"LogonScript"
#define NW_WINSTATION_VALUENAME            L"WinStation"          //Terminal Server 
#define NW_SID_VALUENAME                   L"User"                //Terminal Server 
#define NW_LOGONID_VALUENAME               L"LogonID"
#define NW_PRINTOPTION_VALUENAME           L"PrintOption"
#define NW_SYNCLOGONSCRIPT_VALUENAME       L"ResetScriptFlag"
#define NW_DEFAULTSERVER_VALUENAME         L"DefaultLocation"
#define NW_DEFAULTSCRIPTOPTIONS_VALUENAME  L"DefaultScriptOptions"

#define WINLOGON_REGKEY              L"Software\\Microsoft\\Windows NT\\CurrentVersion\\WinLogon"
#define SYNCLOGONSCRIPT_VALUENAME    L"RunLogonScriptSync"


#endif // _NWRNAMES_INCLUDED_
=== C:/Users/treeman/Desktop/windows nt source code\Source\Win2K3\NT\public\internal\ds\inc\nwcons.h ===
/*++

Copyright (c) 1993  Microsoft Corporation

Module Name:

    nwcons.h

Abstract:

    This module contains various Netware constants

Author:

    Chuck Y Chan.  Split out from NWAPI.H

Revision History:

--*/

#ifndef _NWCONS_INCLUDED_
#define _NWCONS_INCLUDED_

//
// Maximum length of server, password, username
//

#define NW_MAX_TREE_LEN        32
#define NW_MAX_SERVER_LEN      48
#define NW_MAX_PASSWORD_LEN    256
#define NW_MAX_USERNAME_LEN    256

//
// special char to distinguish nds context: eg. *tree\ou.o (as opposed to
// server\volume.
//
#define TREE_CHAR           L'*'             

#endif
=== C:/Users/treeman/Desktop/windows nt source code\Source\Win2K3\NT\public\internal\ds\inc\nwsnames.h ===
/*++

Copyright (c) 1993  Microsoft Corporation

Module Name:

    nwsnames.h

Abstract:

    Header for NetWare service names.

Author:

    Rita Wong      (ritaw)      26-Feb-1993

Revision History:

--*/

#ifndef _NW_SNAMES_INCLUDED_
#define _NW_SNAMES_INCLUDED_


#define NW_WORKSTATION_SERVICE     L"NWCWorkstation"

#endif // _NW_SNAMES_INCLUDED_
=== C:/Users/treeman/Desktop/windows nt source code\Source\Win2K3\NT\public\internal\ds\inc\nwsap.h ===
/*++

Copyright (c) 1994  Microsoft Corporation
Copyright (c) 1993  Micro Computer Systems, Inc.

Module Name:

    net\inc\nwsap.h

Abstract:

    This is the public include file for the Nw Sap Agent API.

Author:

    Brian Walker (MCS) 06-30-1993

Revision History:

--*/

#ifndef _NWSAP_
#define _NWSAP_

#ifdef __cplusplus
extern "C" {
#endif

/** Return codes for Advertise API and BindLib API **/

#define SAPRETURN_SUCCESS	    0
#define SAPRETURN_NOMEMORY      1
#define SAPRETURN_EXISTS	    2
#define SAPRETURN_NOTEXIST      3
#define SAPRETURN_NOTINIT       4
#define SAPRETURN_INVALIDNAME   5
#define SAPRETURN_DUPLICATE     6

/** Function Prototypes **/

INT
SapAddAdvertise(
    IN PUCHAR ServerName,
    IN USHORT ServerType,
	IN PUCHAR ServerAddr,
    IN BOOL   RespondNearest);

INT
SapRemoveAdvertise(
    IN PUCHAR ServerName,
    IN USHORT ServerType);

DWORD
SapLibInit(
    VOID);

DWORD
SapLibShutdown(
    VOID);

INT
SapGetObjectID(
    IN PUCHAR ObjectName,
    IN USHORT ObjectType,
	IN PULONG ObjectID);

INT
SapGetObjectName(
    IN ULONG   ObjectID,
    IN PUCHAR  ObjectName,
    IN PUSHORT ObjectType,
    IN PUCHAR  ObjectAddr);

INT
SapScanObject(
    IN PULONG   ObjectID,
    IN PUCHAR   ObjectName,
    IN PUSHORT  ObjectType,
    IN USHORT   ScanType);

#ifdef __cplusplus
}   /* extern "C" */
#endif
#endif
=== C:/Users/treeman/Desktop/windows nt source code\Source\Win2K3\NT\public\internal\ds\inc\passrec.h ===
/*++

Copyright (c) 2000 Microsoft Corporation

Module Name:

    passrec.h

Abstract:

    This module contains prototypes to support local account password recovery.

Author:

    Pete Skelly (petesk)    09-May-00

--*/

#ifndef __PASSREC_H__
#define __PASSREC_H__

#ifdef __cplusplus
extern "C" {
#endif


DWORD 
PRRecoverPassword(
                IN  LPWSTR pszUsername,
                IN  PBYTE pbRecoveryPrivate,
                IN  DWORD cbRecoveryPrivate,
                IN  LPWSTR pszNewPassword);

#define RECOVERY_STATUS_OK                          0
#define RECOVERY_STATUS_NO_PUBLIC_EXISTS            1
#define RECOVERY_STATUS_FILE_NOT_FOUND              2
#define RECOVERY_STATUS_USER_NOT_FOUND              3
#define RECOVERY_STATUS_PUBLIC_SIGNATURE_INVALID    4

DWORD
PRQueryStatus(
                IN OPTIONAL LPWSTR pszDomain,
                IN OPTIONAL LPWSTR pszUsername,
                OUT DWORD *pdwStatus);

DWORD
PRGenerateRecoveryKey(
                IN  LPWSTR pszUsername,
                IN  LPWSTR pszCurrentPassword,
                OUT PBYTE *ppbRecoveryPrivate,
                OUT DWORD *pcbRecoveryPrivate);

DWORD
WINAPI
CryptResetMachineCredentials(
    DWORD dwFlags);

#ifdef __cplusplus
}
#endif

#endif // __PASSREC_H__
=== C:/Users/treeman/Desktop/windows nt source code\Source\Win2K3\NT\public\internal\ds\inc\recovery.h ===
/*++

Copyright (C) Microsoft Corporation, 1998.
              Microsoft Windows

Module Name:

    RECOVERY.H

Abstract:


Author:

    09-Jan-99 ShaoYin

Environment:

    Kernel Mode - Win32

Revision History:

    09-Jan-99 ShaoYin Created Initial File.

    07-July-2000 ShaoYin Add API to retrieve next available RID from registry

--*/


//////////////////////////////////////////////////////////////////////////
//                                                                      //
//     Global Variables and Private Routines                            //
//                                                                      //
//////////////////////////////////////////////////////////////////////////


#ifndef _RECOVERY_
#define _RECOVERY_




//
// Exported API 
// 

#define REGISTRY_KEY_NAME_LENGTH_MAX    512


//
// The following API is exported to System Recovery Tool and Restore Utility. 
// 
// 1. will run in Kernel Mode if used by System Recovery Tool.
//         run in User Mode if used by Restore Utility
//
// 2. Parameters:
//  
//    Rid - Logon User's Relative ID
//
//    hSecurityRootKey - Handle of the Root of SECURITY hive
//
//    hSamRootKey - Handle of the Root of SAM hive
// 
//    hSystemRootKey - Handle of the root of system hive 
//
//          caller should Load the SAM hive and System hive, 
//                 and Unload them after this API returns.
//
//
//    BootKey -- OPTIONAL. During the first call of this API, should provide
//               NULL. Then SAM will query registry, check how the machine is
//               syskey'd. 
//
//               If the BootKey is stored in registry or the local machine is
//               not syskey'd yet, no further caller's side work.
//
//               If the BootKey is stored in floppy disk, this API will fail
//               with error code STATUS_SAM_NEED_BOOTKEY_FLOPPY, the caller 
//               should handle it by reading the syskey from floppy disk, the
//               try this API with the BootKey parameter filled correctly.
//               The syskey (the data) read from the floppy disk should be copy
//               to the BootKey->Buffer, and BootKey->Length indicate the 
//               length of the data.
//               
//               If the BootKey is derived from Boot Password, this API will 
//               fail with error code STATUS_SAM_NEED_BOOTKEY_PASSWORD, then
//               the caller should prompt the logon user to enter Boot Password, 
//               then try this API with the BootPassword again.  
//               In this case BootKey should be the entered password. 
//               BootKey->Buffer should be the WCHAR password, 
//               BootKey->Length should be the length of password in byte. 
//  
//    BootKeyType -- OPTIONAL. Accociated with BootKey, only used when 
//               BootKey is Not NULL. 
//               Valid Values:
//
//               SamBootKeyDisk - means BootKey->Buffer contains the actual
//                                syskey read from floppy disk, 
//                                BootKey->Length should be the length of 
//                                syskey in byte
//
//               SamBootKeyPassword - means BootKey contains the UNICODE_STRING
//                                format boot password.
//
//               
//    NtOwfPassword -- when SUCCEED, it will be filled with the logon user's 
//               Clear NT OWF Password. If the logon user's password is blank.
//               NtOwfPassword will be filled with NULL NT OWF Password.
//               no meaning when this API fails.
//               
//    NtPasswordPresent -- Meaningful only when the API succeeds. Indicate whether
//               the logon user's NT OWF Password present in registry or not.
//               TRUE - present in registry
//               
//               
//    NtPasswordNonNull -- When this API succeeds, indicates whether the clear
//               NT OWF Password is Null or not.
//               TRUE -- not NULL password.               
//
// 3. more information (including the algorithm and implementaion), 
//              please reference 
//              $(BASEDIR)\private\ds\src\newsam2\recovery\recovery.c
//
// 4. Return Values:
//
//      STATUS_SUCCESS
//      STATUS_SAM_NEED_BOOTKEY_PASSWORD
//      STATUS_SAM_NEED_BOOTKEY_FLOPPY
//      STATUS_NO_MEMORY
//      STATUS_INTERNAL_ERROR
//      STATUS_INVALID_PARAMETER
//      STATUS_INVALID_HANDLE
//      STATUS_NO_SUCH_USER
//      ...
//



NTSTATUS
SamRetrieveOwfPasswordUser(
    IN ULONG   Rid, 
    IN HANDLE  hSecurityRootKey,
    IN HANDLE  hSamRootKey, 
    IN HANDLE  hSystemRootKey, 
    IN PUNICODE_STRING BootKey OPTIONAL, 
    IN USHORT  BootKeyType OPTIONAL, 
    OUT PNT_OWF_PASSWORD NtOwfPassword, 
    OUT PBOOLEAN NtPasswordPresent, 
    OUT PBOOLEAN NtPasswordNonNull    
    );





// 
// Routine Description:
// 
//     This routine reads the SAM Account Domain infomation from SAM hive, passed
//     in through hSamRootKey, and returns the value of next available RID of 
//     this account domain.  
// 
// Parameters:
//
//     hSamRootKey - Handle of the Root of SAM hive
//
//             SAM hive is located in %windir%\system32\config, name is SAM
// 
//     pNextRid - Return the value of next available Rid if success. 
// 
// Return Values:
// 
//     STATUS_SUCCESS
//     or other error status code
// 
NTSTATUS
SamGetNextAvailableRid(
    IN HANDLE  hSamRootKey,
    OUT PULONG pNextRid
    );



//
// Routine Description:
// 
//     This routine queries the Account Domain's Fixed Length Attribute stored
//     in registry. Update it with the passed in NextRid value.
// 
// Parameters:
// 
//     hSamRootKey - Handle of the Root of the hive
//
//     NextRid - Set the domain next available rid to the passed in value
//
// Return Values:
//
NTSTATUS
SamSetNextAvailableRid(
    IN HANDLE  hSamRootKey,
    IN ULONG   NextRid
    );


                                        
#endif  // _RECOVERY_
=== C:/Users/treeman/Desktop/windows nt source code\Source\Win2K3\NT\public\internal\ds\inc\samimp.h ===
#include <nt.h>
//#include <ntrpcnew.h>
#include <lsass.h>
#include <ntsam.h>
#include <ntsamp.h>


#ifdef MIDL_PASS
// put any typedef redefinitions in here...
#endif
=== C:/Users/treeman/Desktop/windows nt source code\Source\Win2K3\NT\public\internal\ds\inc\rnraddrs.h ===
/***********************************************************************
* Microsoft RnR Transport location definitions
*
* Microsoft Confidential.  Copyright 1991-1994 Microsoft Corporation.
*
* Component:
*
* File: rnraddrs.h
*
*
* Revision History:
*
*    26-10-94        Created           Arnoldm
*
***********************************************************************/

#ifndef __RNRADDRS_H__
#define __RNRADDRS_H__

//
// Define the IP multicast address and TTL values
//

#define IP_S_MEMBERSHIP  "224.0.1.24"     // the address

//
// Macro to render the string form into an inet_addr form
//

#define INET_ADDR_MEMBERSHIP (inet_addr(IP_S_MEMBERSHIP))

//
// The port we use for locating naming information
//

#define IPMEMBERWKP    445

//
// TTL definitions used for locating names
//

#define TTL_SUBNET_ONLY 1         // no routing
#define TTL_REASONABLE_REACH 2    // across one router
#define TTL_MAX_REACH  6          // Default max diameter. This may
                                  // be overriden via the Registry.

#define TIMEOUT_MAX_MAX  15000    // max wait time for responses. As with
                                  // TTL_MAX_REACH, the registry can supply
                                  // a different value

//
// Definitions for IPX SAP IDs
//

#define RNRCLASSSAPTYPE  0x64F   // official SAP ID
#endif
=== C:/Users/treeman/Desktop/windows nt source code\Source\Win2K3\NT\public\internal\ds\inc\passport.h ===
/* this ALWAYS GENERATED file contains the definitions for the interfaces */


 /* File created by MIDL compiler version 6.00.0361 */
/* Compiler settings for passport.idl:
    Oicf, W1, Zp8, env=Win32 (32b run)
    protocol : dce , ms_ext, c_ext, robust
    error checks: allocation ref bounds_check enum stub_data 
    VC __declspec() decoration level: 
         __declspec(uuid()), __declspec(selectany), __declspec(novtable)
         DECLSPEC_UUID(), MIDL_INTERFACE()
*/
//@@MIDL_FILE_HEADING(  )

#pragma warning( disable: 4049 )  /* more than 64k source lines */


/* verify that the <rpcndr.h> version is high enough to compile this file*/
#ifndef __REQUIRED_RPCNDR_H_VERSION__
#define __REQUIRED_RPCNDR_H_VERSION__ 475
#endif

#include "rpc.h"
#include "rpcndr.h"

#ifndef __RPCNDR_H_VERSION__
#error this stub requires an updated version of <rpcndr.h>
#endif // __RPCNDR_H_VERSION__

#ifndef COM_NO_WINDOWS_H
#include "windows.h"
#include "ole2.h"
#endif /*COM_NO_WINDOWS_H*/

#ifndef __passport_h__
#define __passport_h__

#if defined(_MSC_VER) && (_MSC_VER >= 1020)
#pragma once
#endif

/* Forward Declarations */ 

#ifndef __IDomainMap_FWD_DEFINED__
#define __IDomainMap_FWD_DEFINED__
typedef interface IDomainMap IDomainMap;
#endif 	/* __IDomainMap_FWD_DEFINED__ */


#ifndef __IPassportTicket_FWD_DEFINED__
#define __IPassportTicket_FWD_DEFINED__
typedef interface IPassportTicket IPassportTicket;
#endif 	/* __IPassportTicket_FWD_DEFINED__ */


#ifndef __IPassportTicket2_FWD_DEFINED__
#define __IPassportTicket2_FWD_DEFINED__
typedef interface IPassportTicket2 IPassportTicket2;
#endif 	/* __IPassportTicket2_FWD_DEFINED__ */


#ifndef __IPassportProfile_FWD_DEFINED__
#define __IPassportProfile_FWD_DEFINED__
typedef interface IPassportProfile IPassportProfile;
#endif 	/* __IPassportProfile_FWD_DEFINED__ */


#ifndef __IPassportManager_FWD_DEFINED__
#define __IPassportManager_FWD_DEFINED__
typedef interface IPassportManager IPassportManager;
#endif 	/* __IPassportManager_FWD_DEFINED__ */


#ifndef __IPassportManager2_FWD_DEFINED__
#define __IPassportManager2_FWD_DEFINED__
typedef interface IPassportManager2 IPassportManager2;
#endif 	/* __IPassportManager2_FWD_DEFINED__ */


#ifndef __IPassportManager3_FWD_DEFINED__
#define __IPassportManager3_FWD_DEFINED__
typedef interface IPassportManager3 IPassportManager3;
#endif 	/* __IPassportManager3_FWD_DEFINED__ */


#ifndef __IPassportCrypt_FWD_DEFINED__
#define __IPassportCrypt_FWD_DEFINED__
typedef interface IPassportCrypt IPassportCrypt;
#endif 	/* __IPassportCrypt_FWD_DEFINED__ */


#ifndef __IPassportAdmin_FWD_DEFINED__
#define __IPassportAdmin_FWD_DEFINED__
typedef interface IPassportAdmin IPassportAdmin;
#endif 	/* __IPassportAdmin_FWD_DEFINED__ */


#ifndef __IPassportAdminEx_FWD_DEFINED__
#define __IPassportAdminEx_FWD_DEFINED__
typedef interface IPassportAdminEx IPassportAdminEx;
#endif 	/* __IPassportAdminEx_FWD_DEFINED__ */


#ifndef __IPassportFastAuth_FWD_DEFINED__
#define __IPassportFastAuth_FWD_DEFINED__
typedef interface IPassportFastAuth IPassportFastAuth;
#endif 	/* __IPassportFastAuth_FWD_DEFINED__ */


#ifndef __IPassportFastAuth2_FWD_DEFINED__
#define __IPassportFastAuth2_FWD_DEFINED__
typedef interface IPassportFastAuth2 IPassportFastAuth2;
#endif 	/* __IPassportFastAuth2_FWD_DEFINED__ */


#ifndef __IPassportFactory_FWD_DEFINED__
#define __IPassportFactory_FWD_DEFINED__
typedef interface IPassportFactory IPassportFactory;
#endif 	/* __IPassportFactory_FWD_DEFINED__ */


#ifndef __Manager_FWD_DEFINED__
#define __Manager_FWD_DEFINED__

#ifdef __cplusplus
typedef class Manager Manager;
#else
typedef struct Manager Manager;
#endif /* __cplusplus */

#endif 	/* __Manager_FWD_DEFINED__ */


#ifndef __Ticket_FWD_DEFINED__
#define __Ticket_FWD_DEFINED__

#ifdef __cplusplus
typedef class Ticket Ticket;
#else
typedef struct Ticket Ticket;
#endif /* __cplusplus */

#endif 	/* __Ticket_FWD_DEFINED__ */


#ifndef __Profile_FWD_DEFINED__
#define __Profile_FWD_DEFINED__

#ifdef __cplusplus
typedef class Profile Profile;
#else
typedef struct Profile Profile;
#endif /* __cplusplus */

#endif 	/* __Profile_FWD_DEFINED__ */


#ifndef __Crypt_FWD_DEFINED__
#define __Crypt_FWD_DEFINED__

#ifdef __cplusplus
typedef class Crypt Crypt;
#else
typedef struct Crypt Crypt;
#endif /* __cplusplus */

#endif 	/* __Crypt_FWD_DEFINED__ */


#ifndef __Admin_FWD_DEFINED__
#define __Admin_FWD_DEFINED__

#ifdef __cplusplus
typedef class Admin Admin;
#else
typedef struct Admin Admin;
#endif /* __cplusplus */

#endif 	/* __Admin_FWD_DEFINED__ */


#ifndef __FastAuth_FWD_DEFINED__
#define __FastAuth_FWD_DEFINED__

#ifdef __cplusplus
typedef class FastAuth FastAuth;
#else
typedef struct FastAuth FastAuth;
#endif /* __cplusplus */

#endif 	/* __FastAuth_FWD_DEFINED__ */


#ifndef __PassportFactory_FWD_DEFINED__
#define __PassportFactory_FWD_DEFINED__

#ifdef __cplusplus
typedef class PassportFactory PassportFactory;
#else
typedef struct PassportFactory PassportFactory;
#endif /* __cplusplus */

#endif 	/* __PassportFactory_FWD_DEFINED__ */


/* header files for imported files */
#include "oaidl.h"
#include "ocidl.h"

#ifdef __cplusplus
extern "C"{
#endif 

void * __RPC_USER MIDL_user_allocate(size_t);
void __RPC_USER MIDL_user_free( void * ); 

/* interface __MIDL_itf_passport_0000 */
/* [local] */ 

//  Size definitions
#define	PASSPORT_COOKIES_MAXLEN	( 512 )

#define	PASSPORT_COOKIES_BUFSIZE	( PASSPORT_COOKIES_MAXLEN + 1 )

#define	PASSPORT_EMAIL_MAXLEN	( 64 + 1 + 64 )

#define	PASSPORT_EMAIL_BUFSIZE	( PASSPORT_EMAIL_MAXLEN + 1 )

#define	PASSPORT_NICKNAME_MAXLEN	( 30 )

#define	PASSPORT_NICKNAME_BUFSIZE	( PASSPORT_NICKNAME_MAXLEN + 1 )

#define	PASSPORT_HEADER_FLAGS_HTTPS	( 0x1 )

#define	ENC_MAX_SIZE	( 2045 )

#define	DEC_MAX_SIZE	( 5498 )

#define	MSPP_PROF_MEMBER_NAME	( "membername" )

#define	MSPP_PROF_HI_UID	( "memberidhigh" )

#define	MSPP_PROF_LO_UID	( "memberidlow" )

#define	MSPP_PROF_VERSION	( "profileVersion" )

#define	MSPP_PROF_COUNTRY	( "country" )

#define	MSPP_PROF_POSTALCODE	( "postalCode" )

#define	MSPP_PROF_REGION	( "region" )

#define	MSPP_PROF_CITY	( "city" )

#define	MSPP_PROF_LANGPREF	( "lang_preference" )

#define	MSPP_PROF_BDAYPREC	( "bday_precision" )

#define	MSPP_PROF_BDATE	( "birthdate" )

#define	MSPP_PROF_GENDER	( "gender" )

#define	MSPP_PROF_PREF_EMAIL	( "preferredEmail" )

#define	MSPP_PROF_NICKNAME	( "nickname" )

#define	MSPP_PROF_ACCESS	( "accessibility" )

#define	MSPP_PROF_WALLET	( "wallet" )

#define	MSPP_PROF_DIRECTORY	( "directory" )

#define	MSPP_PROF_MSNIA	( "inetaccess" )

#define	MSPP_PROF_FLAGS	( "flags" )



extern RPC_IF_HANDLE __MIDL_itf_passport_0000_v0_0_c_ifspec;
extern RPC_IF_HANDLE __MIDL_itf_passport_0000_v0_0_s_ifspec;

#ifndef __IDomainMap_INTERFACE_DEFINED__
#define __IDomainMap_INTERFACE_DEFINED__

/* interface IDomainMap */
/* [unique][helpstring][dual][uuid][object] */ 


EXTERN_C const IID IID_IDomainMap;

#if defined(__cplusplus) && !defined(CINTERFACE)
    
    MIDL_INTERFACE("ACE1AC86-E14F-4f7b-B89A-805A69959680")
    IDomainMap : public IUnknown
    {
    public:
        virtual /* [helpstring] */ HRESULT STDMETHODCALLTYPE GetDomainAttribute( 
            /* [in] */ BSTR attributeName,
            /* [optional][in] */ VARIANT lcid,
            /* [optional][in] */ VARIANT domain,
            /* [retval][out] */ BSTR *pAttrVal) = 0;
        
        virtual /* [helpstring][propget] */ HRESULT STDMETHODCALLTYPE get_Domains( 
            /* [retval][out] */ VARIANT *pArrayVal) = 0;
        
        virtual /* [helpstring] */ HRESULT STDMETHODCALLTYPE DomainExists( 
            /* [in] */ BSTR domainName,
            /* [retval][out] */ VARIANT_BOOL *pbExists) = 0;
        
    };
    
#else 	/* C style interface */

    typedef struct IDomainMapVtbl
    {
        BEGIN_INTERFACE
        
        HRESULT ( STDMETHODCALLTYPE *QueryInterface )( 
            IDomainMap * This,
            /* [in] */ REFIID riid,
            /* [iid_is][out] */ void **ppvObject);
        
        ULONG ( STDMETHODCALLTYPE *AddRef )( 
            IDomainMap * This);
        
        ULONG ( STDMETHODCALLTYPE *Release )( 
            IDomainMap * This);
        
        /* [helpstring] */ HRESULT ( STDMETHODCALLTYPE *GetDomainAttribute )( 
            IDomainMap * This,
            /* [in] */ BSTR attributeName,
            /* [optional][in] */ VARIANT lcid,
            /* [optional][in] */ VARIANT domain,
            /* [retval][out] */ BSTR *pAttrVal);
        
        /* [helpstring][propget] */ HRESULT ( STDMETHODCALLTYPE *get_Domains )( 
            IDomainMap * This,
            /* [retval][out] */ VARIANT *pArrayVal);
        
        /* [helpstring] */ HRESULT ( STDMETHODCALLTYPE *DomainExists )( 
            IDomainMap * This,
            /* [in] */ BSTR domainName,
            /* [retval][out] */ VARIANT_BOOL *pbExists);
        
        END_INTERFACE
    } IDomainMapVtbl;

    interface IDomainMap
    {
        CONST_VTBL struct IDomainMapVtbl *lpVtbl;
    };

    

#ifdef COBJMACROS


#define IDomainMap_QueryInterface(This,riid,ppvObject)	\
    (This)->lpVtbl -> QueryInterface(This,riid,ppvObject)

#define IDomainMap_AddRef(This)	\
    (This)->lpVtbl -> AddRef(This)

#define IDomainMap_Release(This)	\
    (This)->lpVtbl -> Release(This)


#define IDomainMap_GetDomainAttribute(This,attributeName,lcid,domain,pAttrVal)	\
    (This)->lpVtbl -> GetDomainAttribute(This,attributeName,lcid,domain,pAttrVal)

#define IDomainMap_get_Domains(This,pArrayVal)	\
    (This)->lpVtbl -> get_Domains(This,pArrayVal)

#define IDomainMap_DomainExists(This,domainName,pbExists)	\
    (This)->lpVtbl -> DomainExists(This,domainName,pbExists)

#endif /* COBJMACROS */


#endif 	/* C style interface */



/* [helpstring] */ HRESULT STDMETHODCALLTYPE IDomainMap_GetDomainAttribute_Proxy( 
    IDomainMap * This,
    /* [in] */ BSTR attributeName,
    /* [optional][in] */ VARIANT lcid,
    /* [optional][in] */ VARIANT domain,
    /* [retval][out] */ BSTR *pAttrVal);


void __RPC_STUB IDomainMap_GetDomainAttribute_Stub(
    IRpcStubBuffer *This,
    IRpcChannelBuffer *_pRpcChannelBuffer,
    PRPC_MESSAGE _pRpcMessage,
    DWORD *_pdwStubPhase);


/* [helpstring][propget] */ HRESULT STDMETHODCALLTYPE IDomainMap_get_Domains_Proxy( 
    IDomainMap * This,
    /* [retval][out] */ VARIANT *pArrayVal);


void __RPC_STUB IDomainMap_get_Domains_Stub(
    IRpcStubBuffer *This,
    IRpcChannelBuffer *_pRpcChannelBuffer,
    PRPC_MESSAGE _pRpcMessage,
    DWORD *_pdwStubPhase);


/* [helpstring] */ HRESULT STDMETHODCALLTYPE IDomainMap_DomainExists_Proxy( 
    IDomainMap * This,
    /* [in] */ BSTR domainName,
    /* [retval][out] */ VARIANT_BOOL *pbExists);


void __RPC_STUB IDomainMap_DomainExists_Stub(
    IRpcStubBuffer *This,
    IRpcChannelBuffer *_pRpcChannelBuffer,
    PRPC_MESSAGE _pRpcMessage,
    DWORD *_pdwStubPhase);



#endif 	/* __IDomainMap_INTERFACE_DEFINED__ */


#ifndef __IPassportTicket_INTERFACE_DEFINED__
#define __IPassportTicket_INTERFACE_DEFINED__

/* interface IPassportTicket */
/* [unique][helpstring][dual][uuid][object] */ 


EXTERN_C const IID IID_IPassportTicket;

#if defined(__cplusplus) && !defined(CINTERFACE)
    
    MIDL_INTERFACE("41651BF1-A5C8-11D2-95DF-00C04F8E7A70")
    IPassportTicket : public IDispatch
    {
    public:
        virtual /* [helpstring][id][propget] */ HRESULT STDMETHODCALLTYPE get_unencryptedTicket( 
            /* [retval][out] */ BSTR *pVal) = 0;
        
        virtual /* [helpstring][id][propput] */ HRESULT STDMETHODCALLTYPE put_unencryptedTicket( 
            /* [in] */ BSTR newVal) = 0;
        
        virtual /* [helpstring][id][propget] */ HRESULT STDMETHODCALLTYPE get_IsAuthenticated( 
            /* [in] */ ULONG TimeWindow,
            /* [in] */ VARIANT_BOOL ForceLogin,
            /* [optional][in] */ VARIANT SecureLevel,
            /* [retval][out] */ VARIANT_BOOL *pVal) = 0;
        
        virtual /* [helpstring][id][propget] */ HRESULT STDMETHODCALLTYPE get_TicketAge( 
            /* [retval][out] */ int *pVal) = 0;
        
        virtual /* [helpstring][id][propget] */ HRESULT STDMETHODCALLTYPE get_TimeSinceSignIn( 
            /* [retval][out] */ int *pVal) = 0;
        
        virtual /* [helpstring][id][propget] */ HRESULT STDMETHODCALLTYPE get_MemberId( 
            /* [retval][out] */ BSTR *pVal) = 0;
        
        virtual /* [helpstring][id][propget] */ HRESULT STDMETHODCALLTYPE get_MemberIdLow( 
            /* [retval][out] */ int *pVal) = 0;
        
        virtual /* [helpstring][id][propget] */ HRESULT STDMETHODCALLTYPE get_MemberIdHigh( 
            /* [retval][out] */ int *pVal) = 0;
        
        virtual /* [helpstring][id][propget] */ HRESULT STDMETHODCALLTYPE get_HasSavedPassword( 
            /* [retval][out] */ VARIANT_BOOL *pVal) = 0;
        
        virtual /* [helpstring][id][propget] */ HRESULT STDMETHODCALLTYPE get_SignInServer( 
            /* [retval][out] */ BSTR *pVal) = 0;
        
        virtual /* [helpstring][id][propget] */ HRESULT STDMETHODCALLTYPE get_TicketTime( 
            /* [retval][out] */ long *pVal) = 0;
        
        virtual /* [helpstring][id][propget] */ HRESULT STDMETHODCALLTYPE get_SignInTime( 
            /* [retval][out] */ long *pVal) = 0;
        
        virtual /* [helpstring][id][propget] */ HRESULT STDMETHODCALLTYPE get_Error( 
            /* [retval][out] */ long *pVal) = 0;
        
        virtual /* [helpstring][id] */ HRESULT STDMETHODCALLTYPE DoSecureCheck( 
            /* [in] */ BSTR bstrSec) = 0;
        
        virtual /* [helpstring][id] */ HRESULT STDMETHODCALLTYPE DoSecureCheckInTicket( 
            /* [in] */ BOOL fSecureTransported) = 0;
        
    };
    
#else 	/* C style interface */

    typedef struct IPassportTicketVtbl
    {
        BEGIN_INTERFACE
        
        HRESULT ( STDMETHODCALLTYPE *QueryInterface )( 
            IPassportTicket * This,
            /* [in] */ REFIID riid,
            /* [iid_is][out] */ void **ppvObject);
        
        ULONG ( STDMETHODCALLTYPE *AddRef )( 
            IPassportTicket * This);
        
        ULONG ( STDMETHODCALLTYPE *Release )( 
            IPassportTicket * This);
        
        HRESULT ( STDMETHODCALLTYPE *GetTypeInfoCount )( 
            IPassportTicket * This,
            /* [out] */ UINT *pctinfo);
        
        HRESULT ( STDMETHODCALLTYPE *GetTypeInfo )( 
            IPassportTicket * This,
            /* [in] */ UINT iTInfo,
            /* [in] */ LCID lcid,
            /* [out] */ ITypeInfo **ppTInfo);
        
        HRESULT ( STDMETHODCALLTYPE *GetIDsOfNames )( 
            IPassportTicket * This,
            /* [in] */ REFIID riid,
            /* [size_is][in] */ LPOLESTR *rgszNames,
            /* [in] */ UINT cNames,
            /* [in] */ LCID lcid,
            /* [size_is][out] */ DISPID *rgDispId);
        
        /* [local] */ HRESULT ( STDMETHODCALLTYPE *Invoke )( 
            IPassportTicket * This,
            /* [in] */ DISPID dispIdMember,
            /* [in] */ REFIID riid,
            /* [in] */ LCID lcid,
            /* [in] */ WORD wFlags,
            /* [out][in] */ DISPPARAMS *pDispParams,
            /* [out] */ VARIANT *pVarResult,
            /* [out] */ EXCEPINFO *pExcepInfo,
            /* [out] */ UINT *puArgErr);
        
        /* [helpstring][id][propget] */ HRESULT ( STDMETHODCALLTYPE *get_unencryptedTicket )( 
            IPassportTicket * This,
            /* [retval][out] */ BSTR *pVal);
        
        /* [helpstring][id][propput] */ HRESULT ( STDMETHODCALLTYPE *put_unencryptedTicket )( 
            IPassportTicket * This,
            /* [in] */ BSTR newVal);
        
        /* [helpstring][id][propget] */ HRESULT ( STDMETHODCALLTYPE *get_IsAuthenticated )( 
            IPassportTicket * This,
            /* [in] */ ULONG TimeWindow,
            /* [in] */ VARIANT_BOOL ForceLogin,
            /* [optional][in] */ VARIANT SecureLevel,
            /* [retval][out] */ VARIANT_BOOL *pVal);
        
        /* [helpstring][id][propget] */ HRESULT ( STDMETHODCALLTYPE *get_TicketAge )( 
            IPassportTicket * This,
            /* [retval][out] */ int *pVal);
        
        /* [helpstring][id][propget] */ HRESULT ( STDMETHODCALLTYPE *get_TimeSinceSignIn )( 
            IPassportTicket * This,
            /* [retval][out] */ int *pVal);
        
        /* [helpstring][id][propget] */ HRESULT ( STDMETHODCALLTYPE *get_MemberId )( 
            IPassportTicket * This,
            /* [retval][out] */ BSTR *pVal);
        
        /* [helpstring][id][propget] */ HRESULT ( STDMETHODCALLTYPE *get_MemberIdLow )( 
            IPassportTicket * This,
            /* [retval][out] */ int *pVal);
        
        /* [helpstring][id][propget] */ HRESULT ( STDMETHODCALLTYPE *get_MemberIdHigh )( 
            IPassportTicket * This,
            /* [retval][out] */ int *pVal);
        
        /* [helpstring][id][propget] */ HRESULT ( STDMETHODCALLTYPE *get_HasSavedPassword )( 
            IPassportTicket * This,
            /* [retval][out] */ VARIANT_BOOL *pVal);
        
        /* [helpstring][id][propget] */ HRESULT ( STDMETHODCALLTYPE *get_SignInServer )( 
            IPassportTicket * This,
            /* [retval][out] */ BSTR *pVal);
        
        /* [helpstring][id][propget] */ HRESULT ( STDMETHODCALLTYPE *get_TicketTime )( 
            IPassportTicket * This,
            /* [retval][out] */ long *pVal);
        
        /* [helpstring][id][propget] */ HRESULT ( STDMETHODCALLTYPE *get_SignInTime )( 
            IPassportTicket * This,
            /* [retval][out] */ long *pVal);
        
        /* [helpstring][id][propget] */ HRESULT ( STDMETHODCALLTYPE *get_Error )( 
            IPassportTicket * This,
            /* [retval][out] */ long *pVal);
        
        /* [helpstring][id] */ HRESULT ( STDMETHODCALLTYPE *DoSecureCheck )( 
            IPassportTicket * This,
            /* [in] */ BSTR bstrSec);
        
        /* [helpstring][id] */ HRESULT ( STDMETHODCALLTYPE *DoSecureCheckInTicket )( 
            IPassportTicket * This,
            /* [in] */ BOOL fSecureTransported);
        
        END_INTERFACE
    } IPassportTicketVtbl;

    interface IPassportTicket
    {
        CONST_VTBL struct IPassportTicketVtbl *lpVtbl;
    };

    

#ifdef COBJMACROS


#define IPassportTicket_QueryInterface(This,riid,ppvObject)	\
    (This)->lpVtbl -> QueryInterface(This,riid,ppvObject)

#define IPassportTicket_AddRef(This)	\
    (This)->lpVtbl -> AddRef(This)

#define IPassportTicket_Release(This)	\
    (This)->lpVtbl -> Release(This)


#define IPassportTicket_GetTypeInfoCount(This,pctinfo)	\
    (This)->lpVtbl -> GetTypeInfoCount(This,pctinfo)

#define IPassportTicket_GetTypeInfo(This,iTInfo,lcid,ppTInfo)	\
    (This)->lpVtbl -> GetTypeInfo(This,iTInfo,lcid,ppTInfo)

#define IPassportTicket_GetIDsOfNames(This,riid,rgszNames,cNames,lcid,rgDispId)	\
    (This)->lpVtbl -> GetIDsOfNames(This,riid,rgszNames,cNames,lcid,rgDispId)

#define IPassportTicket_Invoke(This,dispIdMember,riid,lcid,wFlags,pDispParams,pVarResult,pExcepInfo,puArgErr)	\
    (This)->lpVtbl -> Invoke(This,dispIdMember,riid,lcid,wFlags,pDispParams,pVarResult,pExcepInfo,puArgErr)


#define IPassportTicket_get_unencryptedTicket(This,pVal)	\
    (This)->lpVtbl -> get_unencryptedTicket(This,pVal)

#define IPassportTicket_put_unencryptedTicket(This,newVal)	\
    (This)->lpVtbl -> put_unencryptedTicket(This,newVal)

#define IPassportTicket_get_IsAuthenticated(This,TimeWindow,ForceLogin,SecureLevel,pVal)	\
    (This)->lpVtbl -> get_IsAuthenticated(This,TimeWindow,ForceLogin,SecureLevel,pVal)

#define IPassportTicket_get_TicketAge(This,pVal)	\
    (This)->lpVtbl -> get_TicketAge(This,pVal)

#define IPassportTicket_get_TimeSinceSignIn(This,pVal)	\
    (This)->lpVtbl -> get_TimeSinceSignIn(This,pVal)

#define IPassportTicket_get_MemberId(This,pVal)	\
    (This)->lpVtbl -> get_MemberId(This,pVal)

#define IPassportTicket_get_MemberIdLow(This,pVal)	\
    (This)->lpVtbl -> get_MemberIdLow(This,pVal)

#define IPassportTicket_get_MemberIdHigh(This,pVal)	\
    (This)->lpVtbl -> get_MemberIdHigh(This,pVal)

#define IPassportTicket_get_HasSavedPassword(This,pVal)	\
    (This)->lpVtbl -> get_HasSavedPassword(This,pVal)

#define IPassportTicket_get_SignInServer(This,pVal)	\
    (This)->lpVtbl -> get_SignInServer(This,pVal)

#define IPassportTicket_get_TicketTime(This,pVal)	\
    (This)->lpVtbl -> get_TicketTime(This,pVal)

#define IPassportTicket_get_SignInTime(This,pVal)	\
    (This)->lpVtbl -> get_SignInTime(This,pVal)

#define IPassportTicket_get_Error(This,pVal)	\
    (This)->lpVtbl -> get_Error(This,pVal)

#define IPassportTicket_DoSecureCheck(This,bstrSec)	\
    (This)->lpVtbl -> DoSecureCheck(This,bstrSec)

#define IPassportTicket_DoSecureCheckInTicket(This,fSecureTransported)	\
    (This)->lpVtbl -> DoSecureCheckInTicket(This,fSecureTransported)

#endif /* COBJMACROS */


#endif 	/* C style interface */



/* [helpstring][id][propget] */ HRESULT STDMETHODCALLTYPE IPassportTicket_get_unencryptedTicket_Proxy( 
    IPassportTicket * This,
    /* [retval][out] */ BSTR *pVal);


void __RPC_STUB IPassportTicket_get_unencryptedTicket_Stub(
    IRpcStubBuffer *This,
    IRpcChannelBuffer *_pRpcChannelBuffer,
    PRPC_MESSAGE _pRpcMessage,
    DWORD *_pdwStubPhase);


/* [helpstring][id][propput] */ HRESULT STDMETHODCALLTYPE IPassportTicket_put_unencryptedTicket_Proxy( 
    IPassportTicket * This,
    /* [in] */ BSTR newVal);


void __RPC_STUB IPassportTicket_put_unencryptedTicket_Stub(
    IRpcStubBuffer *This,
    IRpcChannelBuffer *_pRpcChannelBuffer,
    PRPC_MESSAGE _pRpcMessage,
    DWORD *_pdwStubPhase);


/* [helpstring][id][propget] */ HRESULT STDMETHODCALLTYPE IPassportTicket_get_IsAuthenticated_Proxy( 
    IPassportTicket * This,
    /* [in] */ ULONG TimeWindow,
    /* [in] */ VARIANT_BOOL ForceLogin,
    /* [optional][in] */ VARIANT SecureLevel,
    /* [retval][out] */ VARIANT_BOOL *pVal);


void __RPC_STUB IPassportTicket_get_IsAuthenticated_Stub(
    IRpcStubBuffer *This,
    IRpcChannelBuffer *_pRpcChannelBuffer,
    PRPC_MESSAGE _pRpcMessage,
    DWORD *_pdwStubPhase);


/* [helpstring][id][propget] */ HRESULT STDMETHODCALLTYPE IPassportTicket_get_TicketAge_Proxy( 
    IPassportTicket * This,
    /* [retval][out] */ int *pVal);


void __RPC_STUB IPassportTicket_get_TicketAge_Stub(
    IRpcStubBuffer *This,
    IRpcChannelBuffer *_pRpcChannelBuffer,
    PRPC_MESSAGE _pRpcMessage,
    DWORD *_pdwStubPhase);


/* [helpstring][id][propget] */ HRESULT STDMETHODCALLTYPE IPassportTicket_get_TimeSinceSignIn_Proxy( 
    IPassportTicket * This,
    /* [retval][out] */ int *pVal);


void __RPC_STUB IPassportTicket_get_TimeSinceSignIn_Stub(
    IRpcStubBuffer *This,
    IRpcChannelBuffer *_pRpcChannelBuffer,
    PRPC_MESSAGE _pRpcMessage,
    DWORD *_pdwStubPhase);


/* [helpstring][id][propget] */ HRESULT STDMETHODCALLTYPE IPassportTicket_get_MemberId_Proxy( 
    IPassportTicket * This,
    /* [retval][out] */ BSTR *pVal);


void __RPC_STUB IPassportTicket_get_MemberId_Stub(
    IRpcStubBuffer *This,
    IRpcChannelBuffer *_pRpcChannelBuffer,
    PRPC_MESSAGE _pRpcMessage,
    DWORD *_pdwStubPhase);


/* [helpstring][id][propget] */ HRESULT STDMETHODCALLTYPE IPassportTicket_get_MemberIdLow_Proxy( 
    IPassportTicket * This,
    /* [retval][out] */ int *pVal);


void __RPC_STUB IPassportTicket_get_MemberIdLow_Stub(
    IRpcStubBuffer *This,
    IRpcChannelBuffer *_pRpcChannelBuffer,
    PRPC_MESSAGE _pRpcMessage,
    DWORD *_pdwStubPhase);


/* [helpstring][id][propget] */ HRESULT STDMETHODCALLTYPE IPassportTicket_get_MemberIdHigh_Proxy( 
    IPassportTicket * This,
    /* [retval][out] */ int *pVal);


void __RPC_STUB IPassportTicket_get_MemberIdHigh_Stub(
    IRpcStubBuffer *This,
    IRpcChannelBuffer *_pRpcChannelBuffer,
    PRPC_MESSAGE _pRpcMessage,
    DWORD *_pdwStubPhase);


/* [helpstring][id][propget] */ HRESULT STDMETHODCALLTYPE IPassportTicket_get_HasSavedPassword_Proxy( 
    IPassportTicket * This,
    /* [retval][out] */ VARIANT_BOOL *pVal);


void __RPC_STUB IPassportTicket_get_HasSavedPassword_Stub(
    IRpcStubBuffer *This,
    IRpcChannelBuffer *_pRpcChannelBuffer,
    PRPC_MESSAGE _pRpcMessage,
    DWORD *_pdwStubPhase);


/* [helpstring][id][propget] */ HRESULT STDMETHODCALLTYPE IPassportTicket_get_SignInServer_Proxy( 
    IPassportTicket * This,
    /* [retval][out] */ BSTR *pVal);


void __RPC_STUB IPassportTicket_get_SignInServer_Stub(
    IRpcStubBuffer *This,
    IRpcChannelBuffer *_pRpcChannelBuffer,
    PRPC_MESSAGE _pRpcMessage,
    DWORD *_pdwStubPhase);


/* [helpstring][id][propget] */ HRESULT STDMETHODCALLTYPE IPassportTicket_get_TicketTime_Proxy( 
    IPassportTicket * This,
    /* [retval][out] */ long *pVal);


void __RPC_STUB IPassportTicket_get_TicketTime_Stub(
    IRpcStubBuffer *This,
    IRpcChannelBuffer *_pRpcChannelBuffer,
    PRPC_MESSAGE _pRpcMessage,
    DWORD *_pdwStubPhase);


/* [helpstring][id][propget] */ HRESULT STDMETHODCALLTYPE IPassportTicket_get_SignInTime_Proxy( 
    IPassportTicket * This,
    /* [retval][out] */ long *pVal);


void __RPC_STUB IPassportTicket_get_SignInTime_Stub(
    IRpcStubBuffer *This,
    IRpcChannelBuffer *_pRpcChannelBuffer,
    PRPC_MESSAGE _pRpcMessage,
    DWORD *_pdwStubPhase);


/* [helpstring][id][propget] */ HRESULT STDMETHODCALLTYPE IPassportTicket_get_Error_Proxy( 
    IPassportTicket * This,
    /* [retval][out] */ long *pVal);


void __RPC_STUB IPassportTicket_get_Error_Stub(
    IRpcStubBuffer *This,
    IRpcChannelBuffer *_pRpcChannelBuffer,
    PRPC_MESSAGE _pRpcMessage,
    DWORD *_pdwStubPhase);


/* [helpstring][id] */ HRESULT STDMETHODCALLTYPE IPassportTicket_DoSecureCheck_Proxy( 
    IPassportTicket * This,
    /* [in] */ BSTR bstrSec);


void __RPC_STUB IPassportTicket_DoSecureCheck_Stub(
    IRpcStubBuffer *This,
    IRpcChannelBuffer *_pRpcChannelBuffer,
    PRPC_MESSAGE _pRpcMessage,
    DWORD *_pdwStubPhase);


/* [helpstring][id] */ HRESULT STDMETHODCALLTYPE IPassportTicket_DoSecureCheckInTicket_Proxy( 
    IPassportTicket * This,
    /* [in] */ BOOL fSecureTransported);


void __RPC_STUB IPassportTicket_DoSecureCheckInTicket_Stub(
    IRpcStubBuffer *This,
    IRpcChannelBuffer *_pRpcChannelBuffer,
    PRPC_MESSAGE _pRpcMessage,
    DWORD *_pdwStubPhase);



#endif 	/* __IPassportTicket_INTERFACE_DEFINED__ */


#ifndef __IPassportTicket2_INTERFACE_DEFINED__
#define __IPassportTicket2_INTERFACE_DEFINED__

/* interface IPassportTicket2 */
/* [unique][helpstring][dual][uuid][object] */ 

typedef /* [public][public] */ 
enum __MIDL_IPassportTicket2_0001
    {	ConsentStatus_Unknown	= 0,
	ConsentStatus_Known	= ConsentStatus_Unknown + 1,
	ConsentStatus_NotDefinedInTicket	= ConsentStatus_Known + 1,
	ConsentStatus_DoNotNeed	= ConsentStatus_NotDefinedInTicket + 1
    } 	ConsentStatusEnum;


EXTERN_C const IID IID_IPassportTicket2;

#if defined(__cplusplus) && !defined(CINTERFACE)
    
    MIDL_INTERFACE("5992F4F4-05CB-4944-A426-1E1870266F85")
    IPassportTicket2 : public IPassportTicket
    {
    public:
        virtual /* [helpstring][id] */ HRESULT STDMETHODCALLTYPE GetProperty( 
            /* [in] */ BSTR propName,
            /* [retval][out] */ VARIANT *pVal) = 0;
        
        virtual /* [helpstring][id] */ HRESULT STDMETHODCALLTYPE SetTertiaryConsent( 
            /* [in] */ BSTR consentCookie) = 0;
        
        virtual /* [helpstring][id] */ HRESULT STDMETHODCALLTYPE ConsentStatus( 
            /* [in] */ VARIANT_BOOL RequireConsentStatus,
            /* [out] */ ULONG *consentFlags,
            /* [retval][out] */ ConsentStatusEnum *pConsentCode) = 0;
        
    };
    
#else 	/* C style interface */

    typedef struct IPassportTicket2Vtbl
    {
        BEGIN_INTERFACE
        
        HRESULT ( STDMETHODCALLTYPE *QueryInterface )( 
            IPassportTicket2 * This,
            /* [in] */ REFIID riid,
            /* [iid_is][out] */ void **ppvObject);
        
        ULONG ( STDMETHODCALLTYPE *AddRef )( 
            IPassportTicket2 * This);
        
        ULONG ( STDMETHODCALLTYPE *Release )( 
            IPassportTicket2 * This);
        
        HRESULT ( STDMETHODCALLTYPE *GetTypeInfoCount )( 
            IPassportTicket2 * This,
            /* [out] */ UINT *pctinfo);
        
        HRESULT ( STDMETHODCALLTYPE *GetTypeInfo )( 
            IPassportTicket2 * This,
            /* [in] */ UINT iTInfo,
            /* [in] */ LCID lcid,
            /* [out] */ ITypeInfo **ppTInfo);
        
        HRESULT ( STDMETHODCALLTYPE *GetIDsOfNames )( 
            IPassportTicket2 * This,
            /* [in] */ REFIID riid,
            /* [size_is][in] */ LPOLESTR *rgszNames,
            /* [in] */ UINT cNames,
            /* [in] */ LCID lcid,
            /* [size_is][out] */ DISPID *rgDispId);
        
        /* [local] */ HRESULT ( STDMETHODCALLTYPE *Invoke )( 
            IPassportTicket2 * This,
            /* [in] */ DISPID dispIdMember,
            /* [in] */ REFIID riid,
            /* [in] */ LCID lcid,
            /* [in] */ WORD wFlags,
            /* [out][in] */ DISPPARAMS *pDispParams,
            /* [out] */ VARIANT *pVarResult,
            /* [out] */ EXCEPINFO *pExcepInfo,
            /* [out] */ UINT *puArgErr);
        
        /* [helpstring][id][propget] */ HRESULT ( STDMETHODCALLTYPE *get_unencryptedTicket )( 
            IPassportTicket2 * This,
            /* [retval][out] */ BSTR *pVal);
        
        /* [helpstring][id][propput] */ HRESULT ( STDMETHODCALLTYPE *put_unencryptedTicket )( 
            IPassportTicket2 * This,
            /* [in] */ BSTR newVal);
        
        /* [helpstring][id][propget] */ HRESULT ( STDMETHODCALLTYPE *get_IsAuthenticated )( 
            IPassportTicket2 * This,
            /* [in] */ ULONG TimeWindow,
            /* [in] */ VARIANT_BOOL ForceLogin,
            /* [optional][in] */ VARIANT SecureLevel,
            /* [retval][out] */ VARIANT_BOOL *pVal);
        
        /* [helpstring][id][propget] */ HRESULT ( STDMETHODCALLTYPE *get_TicketAge )( 
            IPassportTicket2 * This,
            /* [retval][out] */ int *pVal);
        
        /* [helpstring][id][propget] */ HRESULT ( STDMETHODCALLTYPE *get_TimeSinceSignIn )( 
            IPassportTicket2 * This,
            /* [retval][out] */ int *pVal);
        
        /* [helpstring][id][propget] */ HRESULT ( STDMETHODCALLTYPE *get_MemberId )( 
            IPassportTicket2 * This,
            /* [retval][out] */ BSTR *pVal);
        
        /* [helpstring][id][propget] */ HRESULT ( STDMETHODCALLTYPE *get_MemberIdLow )( 
            IPassportTicket2 * This,
            /* [retval][out] */ int *pVal);
        
        /* [helpstring][id][propget] */ HRESULT ( STDMETHODCALLTYPE *get_MemberIdHigh )( 
            IPassportTicket2 * This,
            /* [retval][out] */ int *pVal);
        
        /* [helpstring][id][propget] */ HRESULT ( STDMETHODCALLTYPE *get_HasSavedPassword )( 
            IPassportTicket2 * This,
            /* [retval][out] */ VARIANT_BOOL *pVal);
        
        /* [helpstring][id][propget] */ HRESULT ( STDMETHODCALLTYPE *get_SignInServer )( 
            IPassportTicket2 * This,
            /* [retval][out] */ BSTR *pVal);
        
        /* [helpstring][id][propget] */ HRESULT ( STDMETHODCALLTYPE *get_TicketTime )( 
            IPassportTicket2 * This,
            /* [retval][out] */ long *pVal);
        
        /* [helpstring][id][propget] */ HRESULT ( STDMETHODCALLTYPE *get_SignInTime )( 
            IPassportTicket2 * This,
            /* [retval][out] */ long *pVal);
        
        /* [helpstring][id][propget] */ HRESULT ( STDMETHODCALLTYPE *get_Error )( 
            IPassportTicket2 * This,
            /* [retval][out] */ long *pVal);
        
        /* [helpstring][id] */ HRESULT ( STDMETHODCALLTYPE *DoSecureCheck )( 
            IPassportTicket2 * This,
            /* [in] */ BSTR bstrSec);
        
        /* [helpstring][id] */ HRESULT ( STDMETHODCALLTYPE *DoSecureCheckInTicket )( 
            IPassportTicket2 * This,
            /* [in] */ BOOL fSecureTransported);
        
        /* [helpstring][id] */ HRESULT ( STDMETHODCALLTYPE *GetProperty )( 
            IPassportTicket2 * This,
            /* [in] */ BSTR propName,
            /* [retval][out] */ VARIANT *pVal);
        
        /* [helpstring][id] */ HRESULT ( STDMETHODCALLTYPE *SetTertiaryConsent )( 
            IPassportTicket2 * This,
            /* [in] */ BSTR consentCookie);
        
        /* [helpstring][id] */ HRESULT ( STDMETHODCALLTYPE *ConsentStatus )( 
            IPassportTicket2 * This,
            /* [in] */ VARIANT_BOOL RequireConsentStatus,
            /* [out] */ ULONG *consentFlags,
            /* [retval][out] */ ConsentStatusEnum *pConsentCode);
        
        END_INTERFACE
    } IPassportTicket2Vtbl;

    interface IPassportTicket2
    {
        CONST_VTBL struct IPassportTicket2Vtbl *lpVtbl;
    };

    

#ifdef COBJMACROS


#define IPassportTicket2_QueryInterface(This,riid,ppvObject)	\
    (This)->lpVtbl -> QueryInterface(This,riid,ppvObject)

#define IPassportTicket2_AddRef(This)	\
    (This)->lpVtbl -> AddRef(This)

#define IPassportTicket2_Release(This)	\
    (This)->lpVtbl -> Release(This)


#define IPassportTicket2_GetTypeInfoCount(This,pctinfo)	\
    (This)->lpVtbl -> GetTypeInfoCount(This,pctinfo)

#define IPassportTicket2_GetTypeInfo(This,iTInfo,lcid,ppTInfo)	\
    (This)->lpVtbl -> GetTypeInfo(This,iTInfo,lcid,ppTInfo)

#define IPassportTicket2_GetIDsOfNames(This,riid,rgszNames,cNames,lcid,rgDispId)	\
    (This)->lpVtbl -> GetIDsOfNames(This,riid,rgszNames,cNames,lcid,rgDispId)

#define IPassportTicket2_Invoke(This,dispIdMember,riid,lcid,wFlags,pDispParams,pVarResult,pExcepInfo,puArgErr)	\
    (This)->lpVtbl -> Invoke(This,dispIdMember,riid,lcid,wFlags,pDispParams,pVarResult,pExcepInfo,puArgErr)


#define IPassportTicket2_get_unencryptedTicket(This,pVal)	\
    (This)->lpVtbl -> get_unencryptedTicket(This,pVal)

#define IPassportTicket2_put_unencryptedTicket(This,newVal)	\
    (This)->lpVtbl -> put_unencryptedTicket(This,newVal)

#define IPassportTicket2_get_IsAuthenticated(This,TimeWindow,ForceLogin,SecureLevel,pVal)	\
    (This)->lpVtbl -> get_IsAuthenticated(This,TimeWindow,ForceLogin,SecureLevel,pVal)

#define IPassportTicket2_get_TicketAge(This,pVal)	\
    (This)->lpVtbl -> get_TicketAge(This,pVal)

#define IPassportTicket2_get_TimeSinceSignIn(This,pVal)	\
    (This)->lpVtbl -> get_TimeSinceSignIn(This,pVal)

#define IPassportTicket2_get_MemberId(This,pVal)	\
    (This)->lpVtbl -> get_MemberId(This,pVal)

#define IPassportTicket2_get_MemberIdLow(This,pVal)	\
    (This)->lpVtbl -> get_MemberIdLow(This,pVal)

#define IPassportTicket2_get_MemberIdHigh(This,pVal)	\
    (This)->lpVtbl -> get_MemberIdHigh(This,pVal)

#define IPassportTicket2_get_HasSavedPassword(This,pVal)	\
    (This)->lpVtbl -> get_HasSavedPassword(This,pVal)

#define IPassportTicket2_get_SignInServer(This,pVal)	\
    (This)->lpVtbl -> get_SignInServer(This,pVal)

#define IPassportTicket2_get_TicketTime(This,pVal)	\
    (This)->lpVtbl -> get_TicketTime(This,pVal)

#define IPassportTicket2_get_SignInTime(This,pVal)	\
    (This)->lpVtbl -> get_SignInTime(This,pVal)

#define IPassportTicket2_get_Error(This,pVal)	\
    (This)->lpVtbl -> get_Error(This,pVal)

#define IPassportTicket2_DoSecureCheck(This,bstrSec)	\
    (This)->lpVtbl -> DoSecureCheck(This,bstrSec)

#define IPassportTicket2_DoSecureCheckInTicket(This,fSecureTransported)	\
    (This)->lpVtbl -> DoSecureCheckInTicket(This,fSecureTransported)


#define IPassportTicket2_GetProperty(This,propName,pVal)	\
    (This)->lpVtbl -> GetProperty(This,propName,pVal)

#define IPassportTicket2_SetTertiaryConsent(This,consentCookie)	\
    (This)->lpVtbl -> SetTertiaryConsent(This,consentCookie)

#define IPassportTicket2_ConsentStatus(This,RequireConsentStatus,consentFlags,pConsentCode)	\
    (This)->lpVtbl -> ConsentStatus(This,RequireConsentStatus,consentFlags,pConsentCode)

#endif /* COBJMACROS */


#endif 	/* C style interface */



/* [helpstring][id] */ HRESULT STDMETHODCALLTYPE IPassportTicket2_GetProperty_Proxy( 
    IPassportTicket2 * This,
    /* [in] */ BSTR propName,
    /* [retval][out] */ VARIANT *pVal);


void __RPC_STUB IPassportTicket2_GetProperty_Stub(
    IRpcStubBuffer *This,
    IRpcChannelBuffer *_pRpcChannelBuffer,
    PRPC_MESSAGE _pRpcMessage,
    DWORD *_pdwStubPhase);


/* [helpstring][id] */ HRESULT STDMETHODCALLTYPE IPassportTicket2_SetTertiaryConsent_Proxy( 
    IPassportTicket2 * This,
    /* [in] */ BSTR consentCookie);


void __RPC_STUB IPassportTicket2_SetTertiaryConsent_Stub(
    IRpcStubBuffer *This,
    IRpcChannelBuffer *_pRpcChannelBuffer,
    PRPC_MESSAGE _pRpcMessage,
    DWORD *_pdwStubPhase);


/* [helpstring][id] */ HRESULT STDMETHODCALLTYPE IPassportTicket2_ConsentStatus_Proxy( 
    IPassportTicket2 * This,
    /* [in] */ VARIANT_BOOL RequireConsentStatus,
    /* [out] */ ULONG *consentFlags,
    /* [retval][out] */ ConsentStatusEnum *pConsentCode);


void __RPC_STUB IPassportTicket2_ConsentStatus_Stub(
    IRpcStubBuffer *This,
    IRpcChannelBuffer *_pRpcChannelBuffer,
    PRPC_MESSAGE _pRpcMessage,
    DWORD *_pdwStubPhase);



#endif 	/* __IPassportTicket2_INTERFACE_DEFINED__ */


#ifndef __IPassportProfile_INTERFACE_DEFINED__
#define __IPassportProfile_INTERFACE_DEFINED__

/* interface IPassportProfile */
/* [unique][helpstring][dual][uuid][object] */ 


EXTERN_C const IID IID_IPassportProfile;

#if defined(__cplusplus) && !defined(CINTERFACE)
    
    MIDL_INTERFACE("41651BF3-A5C8-11D2-95DF-00C04F8E7A70")
    IPassportProfile : public IDispatch
    {
    public:
        virtual /* [helpstring][id][propget] */ HRESULT STDMETHODCALLTYPE get_Attribute( 
            /* [in] */ BSTR name,
            /* [retval][out] */ VARIANT *pVal) = 0;
        
        virtual /* [helpstring][id][propput] */ HRESULT STDMETHODCALLTYPE put_Attribute( 
            /* [in] */ BSTR name,
            /* [in] */ VARIANT newVal) = 0;
        
        virtual /* [helpstring][id][propget] */ HRESULT STDMETHODCALLTYPE get_ByIndex( 
            /* [in] */ int index,
            /* [retval][out] */ VARIANT *pVal) = 0;
        
        virtual /* [helpstring][id][propput] */ HRESULT STDMETHODCALLTYPE put_ByIndex( 
            /* [in] */ int index,
            /* [in] */ VARIANT newVal) = 0;
        
        virtual /* [helpstring][id][propget] */ HRESULT STDMETHODCALLTYPE get_IsValid( 
            /* [retval][out] */ VARIANT_BOOL *pVal) = 0;
        
        virtual /* [helpstring][id][propget] */ HRESULT STDMETHODCALLTYPE get_SchemaName( 
            /* [retval][out] */ BSTR *pVal) = 0;
        
        virtual /* [helpstring][id][propput] */ HRESULT STDMETHODCALLTYPE put_SchemaName( 
            /* [in] */ BSTR newVal) = 0;
        
        virtual /* [helpstring][id][propget] */ HRESULT STDMETHODCALLTYPE get_unencryptedProfile( 
            /* [retval][out] */ BSTR *pVal) = 0;
        
        virtual /* [helpstring][id][propput] */ HRESULT STDMETHODCALLTYPE put_unencryptedProfile( 
            /* [in] */ BSTR newVal) = 0;
        
        virtual /* [helpstring][id][propget] */ HRESULT STDMETHODCALLTYPE get_updateString( 
            /* [retval][out] */ BSTR *pVal) = 0;
        
    };
    
#else 	/* C style interface */

    typedef struct IPassportProfileVtbl
    {
        BEGIN_INTERFACE
        
        HRESULT ( STDMETHODCALLTYPE *QueryInterface )( 
            IPassportProfile * This,
            /* [in] */ REFIID riid,
            /* [iid_is][out] */ void **ppvObject);
        
        ULONG ( STDMETHODCALLTYPE *AddRef )( 
            IPassportProfile * This);
        
        ULONG ( STDMETHODCALLTYPE *Release )( 
            IPassportProfile * This);
        
        HRESULT ( STDMETHODCALLTYPE *GetTypeInfoCount )( 
            IPassportProfile * This,
            /* [out] */ UINT *pctinfo);
        
        HRESULT ( STDMETHODCALLTYPE *GetTypeInfo )( 
            IPassportProfile * This,
            /* [in] */ UINT iTInfo,
            /* [in] */ LCID lcid,
            /* [out] */ ITypeInfo **ppTInfo);
        
        HRESULT ( STDMETHODCALLTYPE *GetIDsOfNames )( 
            IPassportProfile * This,
            /* [in] */ REFIID riid,
            /* [size_is][in] */ LPOLESTR *rgszNames,
            /* [in] */ UINT cNames,
            /* [in] */ LCID lcid,
            /* [size_is][out] */ DISPID *rgDispId);
        
        /* [local] */ HRESULT ( STDMETHODCALLTYPE *Invoke )( 
            IPassportProfile * This,
            /* [in] */ DISPID dispIdMember,
            /* [in] */ REFIID riid,
            /* [in] */ LCID lcid,
            /* [in] */ WORD wFlags,
            /* [out][in] */ DISPPARAMS *pDispParams,
            /* [out] */ VARIANT *pVarResult,
            /* [out] */ EXCEPINFO *pExcepInfo,
            /* [out] */ UINT *puArgErr);
        
        /* [helpstring][id][propget] */ HRESULT ( STDMETHODCALLTYPE *get_Attribute )( 
            IPassportProfile * This,
            /* [in] */ BSTR name,
            /* [retval][out] */ VARIANT *pVal);
        
        /* [helpstring][id][propput] */ HRESULT ( STDMETHODCALLTYPE *put_Attribute )( 
            IPassportProfile * This,
            /* [in] */ BSTR name,
            /* [in] */ VARIANT newVal);
        
        /* [helpstring][id][propget] */ HRESULT ( STDMETHODCALLTYPE *get_ByIndex )( 
            IPassportProfile * This,
            /* [in] */ int index,
            /* [retval][out] */ VARIANT *pVal);
        
        /* [helpstring][id][propput] */ HRESULT ( STDMETHODCALLTYPE *put_ByIndex )( 
            IPassportProfile * This,
            /* [in] */ int index,
            /* [in] */ VARIANT newVal);
        
        /* [helpstring][id][propget] */ HRESULT ( STDMETHODCALLTYPE *get_IsValid )( 
            IPassportProfile * This,
            /* [retval][out] */ VARIANT_BOOL *pVal);
        
        /* [helpstring][id][propget] */ HRESULT ( STDMETHODCALLTYPE *get_SchemaName )( 
            IPassportProfile * This,
            /* [retval][out] */ BSTR *pVal);
        
        /* [helpstring][id][propput] */ HRESULT ( STDMETHODCALLTYPE *put_SchemaName )( 
            IPassportProfile * This,
            /* [in] */ BSTR newVal);
        
        /* [helpstring][id][propget] */ HRESULT ( STDMETHODCALLTYPE *get_unencryptedProfile )( 
            IPassportProfile * This,
            /* [retval][out] */ BSTR *pVal);
        
        /* [helpstring][id][propput] */ HRESULT ( STDMETHODCALLTYPE *put_unencryptedProfile )( 
            IPassportProfile * This,
            /* [in] */ BSTR newVal);
        
        /* [helpstring][id][propget] */ HRESULT ( STDMETHODCALLTYPE *get_updateString )( 
            IPassportProfile * This,
            /* [retval][out] */ BSTR *pVal);
        
        END_INTERFACE
    } IPassportProfileVtbl;

    interface IPassportProfile
    {
        CONST_VTBL struct IPassportProfileVtbl *lpVtbl;
    };

    

#ifdef COBJMACROS


#define IPassportProfile_QueryInterface(This,riid,ppvObject)	\
    (This)->lpVtbl -> QueryInterface(This,riid,ppvObject)

#define IPassportProfile_AddRef(This)	\
    (This)->lpVtbl -> AddRef(This)

#define IPassportProfile_Release(This)	\
    (This)->lpVtbl -> Release(This)


#define IPassportProfile_GetTypeInfoCount(This,pctinfo)	\
    (This)->lpVtbl -> GetTypeInfoCount(This,pctinfo)

#define IPassportProfile_GetTypeInfo(This,iTInfo,lcid,ppTInfo)	\
    (This)->lpVtbl -> GetTypeInfo(This,iTInfo,lcid,ppTInfo)

#define IPassportProfile_GetIDsOfNames(This,riid,rgszNames,cNames,lcid,rgDispId)	\
    (This)->lpVtbl -> GetIDsOfNames(This,riid,rgszNames,cNames,lcid,rgDispId)

#define IPassportProfile_Invoke(This,dispIdMember,riid,lcid,wFlags,pDispParams,pVarResult,pExcepInfo,puArgErr)	\
    (This)->lpVtbl -> Invoke(This,dispIdMember,riid,lcid,wFlags,pDispParams,pVarResult,pExcepInfo,puArgErr)


#define IPassportProfile_get_Attribute(This,name,pVal)	\
    (This)->lpVtbl -> get_Attribute(This,name,pVal)

#define IPassportProfile_put_Attribute(This,name,newVal)	\
    (This)->lpVtbl -> put_Attribute(This,name,newVal)

#define IPassportProfile_get_ByIndex(This,index,pVal)	\
    (This)->lpVtbl -> get_ByIndex(This,index,pVal)

#define IPassportProfile_put_ByIndex(This,index,newVal)	\
    (This)->lpVtbl -> put_ByIndex(This,index,newVal)

#define IPassportProfile_get_IsValid(This,pVal)	\
    (This)->lpVtbl -> get_IsValid(This,pVal)

#define IPassportProfile_get_SchemaName(This,pVal)	\
    (This)->lpVtbl -> get_SchemaName(This,pVal)

#define IPassportProfile_put_SchemaName(This,newVal)	\
    (This)->lpVtbl -> put_SchemaName(This,newVal)

#define IPassportProfile_get_unencryptedProfile(This,pVal)	\
    (This)->lpVtbl -> get_unencryptedProfile(This,pVal)

#define IPassportProfile_put_unencryptedProfile(This,newVal)	\
    (This)->lpVtbl -> put_unencryptedProfile(This,newVal)

#define IPassportProfile_get_updateString(This,pVal)	\
    (This)->lpVtbl -> get_updateString(This,pVal)

#endif /* COBJMACROS */


#endif 	/* C style interface */



/* [helpstring][id][propget] */ HRESULT STDMETHODCALLTYPE IPassportProfile_get_Attribute_Proxy( 
    IPassportProfile * This,
    /* [in] */ BSTR name,
    /* [retval][out] */ VARIANT *pVal);


void __RPC_STUB IPassportProfile_get_Attribute_Stub(
    IRpcStubBuffer *This,
    IRpcChannelBuffer *_pRpcChannelBuffer,
    PRPC_MESSAGE _pRpcMessage,
    DWORD *_pdwStubPhase);


/* [helpstring][id][propput] */ HRESULT STDMETHODCALLTYPE IPassportProfile_put_Attribute_Proxy( 
    IPassportProfile * This,
    /* [in] */ BSTR name,
    /* [in] */ VARIANT newVal);


void __RPC_STUB IPassportProfile_put_Attribute_Stub(
    IRpcStubBuffer *This,
    IRpcChannelBuffer *_pRpcChannelBuffer,
    PRPC_MESSAGE _pRpcMessage,
    DWORD *_pdwStubPhase);


/* [helpstring][id][propget] */ HRESULT STDMETHODCALLTYPE IPassportProfile_get_ByIndex_Proxy( 
    IPassportProfile * This,
    /* [in] */ int index,
    /* [retval][out] */ VARIANT *pVal);


void __RPC_STUB IPassportProfile_get_ByIndex_Stub(
    IRpcStubBuffer *This,
    IRpcChannelBuffer *_pRpcChannelBuffer,
    PRPC_MESSAGE _pRpcMessage,
    DWORD *_pdwStubPhase);


/* [helpstring][id][propput] */ HRESULT STDMETHODCALLTYPE IPassportProfile_put_ByIndex_Proxy( 
    IPassportProfile * This,
    /* [in] */ int index,
    /* [in] */ VARIANT newVal);


void __RPC_STUB IPassportProfile_put_ByIndex_Stub(
    IRpcStubBuffer *This,
    IRpcChannelBuffer *_pRpcChannelBuffer,
    PRPC_MESSAGE _pRpcMessage,
    DWORD *_pdwStubPhase);


/* [helpstring][id][propget] */ HRESULT STDMETHODCALLTYPE IPassportProfile_get_IsValid_Proxy( 
    IPassportProfile * This,
    /* [retval][out] */ VARIANT_BOOL *pVal);


void __RPC_STUB IPassportProfile_get_IsValid_Stub(
    IRpcStubBuffer *This,
    IRpcChannelBuffer *_pRpcChannelBuffer,
    PRPC_MESSAGE _pRpcMessage,
    DWORD *_pdwStubPhase);


/* [helpstring][id][propget] */ HRESULT STDMETHODCALLTYPE IPassportProfile_get_SchemaName_Proxy( 
    IPassportProfile * This,
    /* [retval][out] */ BSTR *pVal);


void __RPC_STUB IPassportProfile_get_SchemaName_Stub(
    IRpcStubBuffer *This,
    IRpcChannelBuffer *_pRpcChannelBuffer,
    PRPC_MESSAGE _pRpcMessage,
    DWORD *_pdwStubPhase);


/* [helpstring][id][propput] */ HRESULT STDMETHODCALLTYPE IPassportProfile_put_SchemaName_Proxy( 
    IPassportProfile * This,
    /* [in] */ BSTR newVal);


void __RPC_STUB IPassportProfile_put_SchemaName_Stub(
    IRpcStubBuffer *This,
    IRpcChannelBuffer *_pRpcChannelBuffer,
    PRPC_MESSAGE _pRpcMessage,
    DWORD *_pdwStubPhase);


/* [helpstring][id][propget] */ HRESULT STDMETHODCALLTYPE IPassportProfile_get_unencryptedProfile_Proxy( 
    IPassportProfile * This,
    /* [retval][out] */ BSTR *pVal);


void __RPC_STUB IPassportProfile_get_unencryptedProfile_Stub(
    IRpcStubBuffer *This,
    IRpcChannelBuffer *_pRpcChannelBuffer,
    PRPC_MESSAGE _pRpcMessage,
    DWORD *_pdwStubPhase);


/* [helpstring][id][propput] */ HRESULT STDMETHODCALLTYPE IPassportProfile_put_unencryptedProfile_Proxy( 
    IPassportProfile * This,
    /* [in] */ BSTR newVal);


void __RPC_STUB IPassportProfile_put_unencryptedProfile_Stub(
    IRpcStubBuffer *This,
    IRpcChannelBuffer *_pRpcChannelBuffer,
    PRPC_MESSAGE _pRpcMessage,
    DWORD *_pdwStubPhase);


/* [helpstring][id][propget] */ HRESULT STDMETHODCALLTYPE IPassportProfile_get_updateString_Proxy( 
    IPassportProfile * This,
    /* [retval][out] */ BSTR *pVal);


void __RPC_STUB IPassportProfile_get_updateString_Stub(
    IRpcStubBuffer *This,
    IRpcChannelBuffer *_pRpcChannelBuffer,
    PRPC_MESSAGE _pRpcMessage,
    DWORD *_pdwStubPhase);



#endif 	/* __IPassportProfile_INTERFACE_DEFINED__ */


#ifndef __IPassportManager_INTERFACE_DEFINED__
#define __IPassportManager_INTERFACE_DEFINED__

/* interface IPassportManager */
/* [unique][helpstring][dual][uuid][object] */ 


EXTERN_C const IID IID_IPassportManager;

#if defined(__cplusplus) && !defined(CINTERFACE)
    
    MIDL_INTERFACE("41651BEF-A5C8-11D2-95DF-00C04F8E7A70")
    IPassportManager : public IDispatch
    {
    public:
        virtual HRESULT STDMETHODCALLTYPE OnStartPage( 
            /* [in] */ IUnknown *piUnk) = 0;
        
        virtual HRESULT STDMETHODCALLTYPE OnEndPage( void) = 0;
        
        virtual HRESULT STDMETHODCALLTYPE OnStartPageECB( 
            /* [in] */ BYTE *pECB,
            /* [out][in] */ DWORD *pBufSize,
            /* [size_is][out] */ LPSTR pCookieHeader) = 0;
        
        virtual /* [hidden] */ HRESULT STDMETHODCALLTYPE _Ticket( 
            /* [out] */ IPassportTicket **piTicket) = 0;
        
        virtual /* [hidden] */ HRESULT STDMETHODCALLTYPE _Profile( 
            /* [out] */ IPassportProfile **piProfile) = 0;
        
        virtual /* [helpstring][id] */ HRESULT STDMETHODCALLTYPE AuthURL( 
            /* [optional][in] */ VARIANT returnUrl,
            /* [optional][in] */ VARIANT TimeWindow,
            /* [optional][in] */ VARIANT ForceLogin,
            /* [optional][in] */ VARIANT coBrandArgs,
            /* [optional][in] */ VARIANT lang_id,
            /* [optional][in] */ VARIANT NameSpace,
            /* [optional][in] */ VARIANT KPP,
            /* [optional][in] */ VARIANT SecureLevel,
            /* [retval][out] */ BSTR *pAuthVal) = 0;
        
        virtual /* [helpstring][id] */ HRESULT STDMETHODCALLTYPE IsAuthenticated( 
            /* [optional][in] */ VARIANT TimeWindow,
            /* [optional][in] */ VARIANT ForceLogin,
            /* [optional][in] */ VARIANT SecureLevel,
            /* [retval][out] */ VARIANT_BOOL *pVal) = 0;
        
        virtual /* [helpstring][id] */ HRESULT STDMETHODCALLTYPE LogoTag( 
            /* [optional][in] */ VARIANT returnUrl,
            /* [optional][in] */ VARIANT TimeWindow,
            /* [optional][in] */ VARIANT ForceLogin,
            /* [optional][in] */ VARIANT coBrandArgs,
            /* [optional][in] */ VARIANT lang_id,
            /* [optional][in] */ VARIANT bSecure,
            /* [optional][in] */ VARIANT NameSpace,
            /* [optional][in] */ VARIANT KPP,
            /* [optional][in] */ VARIANT SecureLevel,
            /* [retval][out] */ BSTR *pVal) = 0;
        
        virtual /* [helpstring][id] */ HRESULT STDMETHODCALLTYPE HasProfile( 
            /* [optional][in] */ VARIANT ProfileName,
            /* [retval][out] */ VARIANT_BOOL *pVal) = 0;
        
        virtual /* [helpstring][id][propget] */ HRESULT STDMETHODCALLTYPE get_HasTicket( 
            /* [retval][out] */ VARIANT_BOOL *pVal) = 0;
        
        virtual /* [helpstring][id][propget] */ HRESULT STDMETHODCALLTYPE get_FromNetworkServer( 
            /* [retval][out] */ VARIANT_BOOL *pVal) = 0;
        
        virtual /* [helpstring][id] */ HRESULT STDMETHODCALLTYPE HasFlag( 
            /* [optional][in] */ VARIANT flagMask,
            /* [retval][out] */ VARIANT_BOOL *pVal) = 0;
        
        virtual /* [helpstring][id][propget] */ HRESULT STDMETHODCALLTYPE get_TicketAge( 
            /* [retval][out] */ int *pVal) = 0;
        
        virtual /* [helpstring][id][propget] */ HRESULT STDMETHODCALLTYPE get_TimeSinceSignIn( 
            /* [retval][out] */ int *pVal) = 0;
        
        virtual /* [helpstring][id] */ HRESULT STDMETHODCALLTYPE GetDomainAttribute( 
            /* [in] */ BSTR attributeName,
            /* [optional][in] */ VARIANT lcid,
            /* [optional][in] */ VARIANT domain,
            /* [retval][out] */ BSTR *pAttrVal) = 0;
        
        virtual /* [helpstring][id] */ HRESULT STDMETHODCALLTYPE DomainFromMemberName( 
            /* [optional][in] */ VARIANT memberName,
            /* [retval][out] */ BSTR *pDomainName) = 0;
        
        virtual /* [helpstring][id][propget] */ HRESULT STDMETHODCALLTYPE get_ProfileByIndex( 
            /* [in] */ int index,
            /* [retval][out] */ VARIANT *pVal) = 0;
        
        virtual /* [helpstring][id][propput] */ HRESULT STDMETHODCALLTYPE put_ProfileByIndex( 
            /* [in] */ int index,
            /* [in] */ VARIANT newVal) = 0;
        
        virtual /* [helpstring][id] */ HRESULT STDMETHODCALLTYPE OnStartPageManual( 
            /* [in] */ BSTR queryStringT,
            /* [in] */ BSTR queryStringP,
            /* [in] */ BSTR MSPAuthCookie,
            /* [in] */ BSTR MSPProfCookie,
            /* [in] */ BSTR MSPConsentCookie,
            /* [optional][in] */ VARIANT vMSPSecCookie,
            /* [retval][out] */ VARIANT *pSetCookieArray) = 0;
        
        virtual /* [helpstring][id][propget] */ HRESULT STDMETHODCALLTYPE get_HasSavedPassword( 
            /* [retval][out] */ VARIANT_BOOL *pVal) = 0;
        
        virtual /* [helpstring][id] */ HRESULT STDMETHODCALLTYPE Commit( 
            /* [retval][out] */ BSTR *pNewProfileCookieHeader) = 0;
        
        virtual /* [helpstring][id][propget] */ HRESULT STDMETHODCALLTYPE get_Profile( 
            /* [in] */ BSTR attributeName,
            /* [retval][out] */ VARIANT *pVal) = 0;
        
        virtual /* [helpstring][id][propput] */ HRESULT STDMETHODCALLTYPE put_Profile( 
            /* [in] */ BSTR attributeName,
            /* [in] */ VARIANT newVal) = 0;
        
        virtual /* [helpstring][id][propget][hidden] */ HRESULT STDMETHODCALLTYPE get_TicketTime( 
            /* [retval][out] */ long *pVal) = 0;
        
        virtual /* [helpstring][id][propget][hidden] */ HRESULT STDMETHODCALLTYPE get_SignInTime( 
            /* [retval][out] */ long *pVal) = 0;
        
        virtual /* [helpstring][id][propget][hidden] */ HRESULT STDMETHODCALLTYPE get_Domains( 
            /* [retval][out] */ VARIANT *pArrayVal) = 0;
        
        virtual /* [helpstring][id][propget] */ HRESULT STDMETHODCALLTYPE get_Error( 
            /* [retval][out] */ long *pErrorVal) = 0;
        
        virtual /* [helpstring][hidden] */ HRESULT STDMETHODCALLTYPE OnStartPageFilter( 
            /* [in] */ BYTE *pPFC,
            /* [out][in] */ DWORD *pBufSize,
            /* [size_is][out] */ LPSTR pCookieHeader) = 0;
        
        virtual /* [helpstring][id] */ HRESULT STDMETHODCALLTYPE OnStartPageASP( 
            /* [in] */ IDispatch *pdispRequest,
            /* [in] */ IDispatch *pdispResponse) = 0;
        
        virtual /* [helpstring][id][hidden] */ HRESULT STDMETHODCALLTYPE GetServerInfo( 
            /* [retval][out] */ BSTR *pbstrOut) = 0;
        
        virtual /* [helpstring][id] */ HRESULT STDMETHODCALLTYPE HaveConsent( 
            /* [in] */ VARIANT_BOOL bNeedFullConsent,
            /* [in] */ VARIANT_BOOL bNeedBirthdate,
            /* [retval][out] */ VARIANT_BOOL *pbHaveConsent) = 0;
        
    };
    
#else 	/* C style interface */

    typedef struct IPassportManagerVtbl
    {
        BEGIN_INTERFACE
        
        HRESULT ( STDMETHODCALLTYPE *QueryInterface )( 
            IPassportManager * This,
            /* [in] */ REFIID riid,
            /* [iid_is][out] */ void **ppvObject);
        
        ULONG ( STDMETHODCALLTYPE *AddRef )( 
            IPassportManager * This);
        
        ULONG ( STDMETHODCALLTYPE *Release )( 
            IPassportManager * This);
        
        HRESULT ( STDMETHODCALLTYPE *GetTypeInfoCount )( 
            IPassportManager * This,
            /* [out] */ UINT *pctinfo);
        
        HRESULT ( STDMETHODCALLTYPE *GetTypeInfo )( 
            IPassportManager * This,
            /* [in] */ UINT iTInfo,
            /* [in] */ LCID lcid,
            /* [out] */ ITypeInfo **ppTInfo);
        
        HRESULT ( STDMETHODCALLTYPE *GetIDsOfNames )( 
            IPassportManager * This,
            /* [in] */ REFIID riid,
            /* [size_is][in] */ LPOLESTR *rgszNames,
            /* [in] */ UINT cNames,
            /* [in] */ LCID lcid,
            /* [size_is][out] */ DISPID *rgDispId);
        
        /* [local] */ HRESULT ( STDMETHODCALLTYPE *Invoke )( 
            IPassportManager * This,
            /* [in] */ DISPID dispIdMember,
            /* [in] */ REFIID riid,
            /* [in] */ LCID lcid,
            /* [in] */ WORD wFlags,
            /* [out][in] */ DISPPARAMS *pDispParams,
            /* [out] */ VARIANT *pVarResult,
            /* [out] */ EXCEPINFO *pExcepInfo,
            /* [out] */ UINT *puArgErr);
        
        HRESULT ( STDMETHODCALLTYPE *OnStartPage )( 
            IPassportManager * This,
            /* [in] */ IUnknown *piUnk);
        
        HRESULT ( STDMETHODCALLTYPE *OnEndPage )( 
            IPassportManager * This);
        
        HRESULT ( STDMETHODCALLTYPE *OnStartPageECB )( 
            IPassportManager * This,
            /* [in] */ BYTE *pECB,
            /* [out][in] */ DWORD *pBufSize,
            /* [size_is][out] */ LPSTR pCookieHeader);
        
        /* [hidden] */ HRESULT ( STDMETHODCALLTYPE *_Ticket )( 
            IPassportManager * This,
            /* [out] */ IPassportTicket **piTicket);
        
        /* [hidden] */ HRESULT ( STDMETHODCALLTYPE *_Profile )( 
            IPassportManager * This,
            /* [out] */ IPassportProfile **piProfile);
        
        /* [helpstring][id] */ HRESULT ( STDMETHODCALLTYPE *AuthURL )( 
            IPassportManager * This,
            /* [optional][in] */ VARIANT returnUrl,
            /* [optional][in] */ VARIANT TimeWindow,
            /* [optional][in] */ VARIANT ForceLogin,
            /* [optional][in] */ VARIANT coBrandArgs,
            /* [optional][in] */ VARIANT lang_id,
            /* [optional][in] */ VARIANT NameSpace,
            /* [optional][in] */ VARIANT KPP,
            /* [optional][in] */ VARIANT SecureLevel,
            /* [retval][out] */ BSTR *pAuthVal);
        
        /* [helpstring][id] */ HRESULT ( STDMETHODCALLTYPE *IsAuthenticated )( 
            IPassportManager * This,
            /* [optional][in] */ VARIANT TimeWindow,
            /* [optional][in] */ VARIANT ForceLogin,
            /* [optional][in] */ VARIANT SecureLevel,
            /* [retval][out] */ VARIANT_BOOL *pVal);
        
        /* [helpstring][id] */ HRESULT ( STDMETHODCALLTYPE *LogoTag )( 
            IPassportManager * This,
            /* [optional][in] */ VARIANT returnUrl,
            /* [optional][in] */ VARIANT TimeWindow,
            /* [optional][in] */ VARIANT ForceLogin,
            /* [optional][in] */ VARIANT coBrandArgs,
            /* [optional][in] */ VARIANT lang_id,
            /* [optional][in] */ VARIANT bSecure,
            /* [optional][in] */ VARIANT NameSpace,
            /* [optional][in] */ VARIANT KPP,
            /* [optional][in] */ VARIANT SecureLevel,
            /* [retval][out] */ BSTR *pVal);
        
        /* [helpstring][id] */ HRESULT ( STDMETHODCALLTYPE *HasProfile )( 
            IPassportManager * This,
            /* [optional][in] */ VARIANT ProfileName,
            /* [retval][out] */ VARIANT_BOOL *pVal);
        
        /* [helpstring][id][propget] */ HRESULT ( STDMETHODCALLTYPE *get_HasTicket )( 
            IPassportManager * This,
            /* [retval][out] */ VARIANT_BOOL *pVal);
        
        /* [helpstring][id][propget] */ HRESULT ( STDMETHODCALLTYPE *get_FromNetworkServer )( 
            IPassportManager * This,
            /* [retval][out] */ VARIANT_BOOL *pVal);
        
        /* [helpstring][id] */ HRESULT ( STDMETHODCALLTYPE *HasFlag )( 
            IPassportManager * This,
            /* [optional][in] */ VARIANT flagMask,
            /* [retval][out] */ VARIANT_BOOL *pVal);
        
        /* [helpstring][id][propget] */ HRESULT ( STDMETHODCALLTYPE *get_TicketAge )( 
            IPassportManager * This,
            /* [retval][out] */ int *pVal);
        
        /* [helpstring][id][propget] */ HRESULT ( STDMETHODCALLTYPE *get_TimeSinceSignIn )( 
            IPassportManager * This,
            /* [retval][out] */ int *pVal);
        
        /* [helpstring][id] */ HRESULT ( STDMETHODCALLTYPE *GetDomainAttribute )( 
            IPassportManager * This,
            /* [in] */ BSTR attributeName,
            /* [optional][in] */ VARIANT lcid,
            /* [optional][in] */ VARIANT domain,
            /* [retval][out] */ BSTR *pAttrVal);
        
        /* [helpstring][id] */ HRESULT ( STDMETHODCALLTYPE *DomainFromMemberName )( 
            IPassportManager * This,
            /* [optional][in] */ VARIANT memberName,
            /* [retval][out] */ BSTR *pDomainName);
        
        /* [helpstring][id][propget] */ HRESULT ( STDMETHODCALLTYPE *get_ProfileByIndex )( 
            IPassportManager * This,
            /* [in] */ int index,
            /* [retval][out] */ VARIANT *pVal);
        
        /* [helpstring][id][propput] */ HRESULT ( STDMETHODCALLTYPE *put_ProfileByIndex )( 
            IPassportManager * This,
            /* [in] */ int index,
            /* [in] */ VARIANT newVal);
        
        /* [helpstring][id] */ HRESULT ( STDMETHODCALLTYPE *OnStartPageManual )( 
            IPassportManager * This,
            /* [in] */ BSTR queryStringT,
            /* [in] */ BSTR queryStringP,
            /* [in] */ BSTR MSPAuthCookie,
            /* [in] */ BSTR MSPProfCookie,
            /* [in] */ BSTR MSPConsentCookie,
            /* [optional][in] */ VARIANT vMSPSecCookie,
            /* [retval][out] */ VARIANT *pSetCookieArray);
        
        /* [helpstring][id][propget] */ HRESULT ( STDMETHODCALLTYPE *get_HasSavedPassword )( 
            IPassportManager * This,
            /* [retval][out] */ VARIANT_BOOL *pVal);
        
        /* [helpstring][id] */ HRESULT ( STDMETHODCALLTYPE *Commit )( 
            IPassportManager * This,
            /* [retval][out] */ BSTR *pNewProfileCookieHeader);
        
        /* [helpstring][id][propget] */ HRESULT ( STDMETHODCALLTYPE *get_Profile )( 
            IPassportManager * This,
            /* [in] */ BSTR attributeName,
            /* [retval][out] */ VARIANT *pVal);
        
        /* [helpstring][id][propput] */ HRESULT ( STDMETHODCALLTYPE *put_Profile )( 
            IPassportManager * This,
            /* [in] */ BSTR attributeName,
            /* [in] */ VARIANT newVal);
        
        /* [helpstring][id][propget][hidden] */ HRESULT ( STDMETHODCALLTYPE *get_TicketTime )( 
            IPassportManager * This,
            /* [retval][out] */ long *pVal);
        
        /* [helpstring][id][propget][hidden] */ HRESULT ( STDMETHODCALLTYPE *get_SignInTime )( 
            IPassportManager * This,
            /* [retval][out] */ long *pVal);
        
        /* [helpstring][id][propget][hidden] */ HRESULT ( STDMETHODCALLTYPE *get_Domains )( 
            IPassportManager * This,
            /* [retval][out] */ VARIANT *pArrayVal);
        
        /* [helpstring][id][propget] */ HRESULT ( STDMETHODCALLTYPE *get_Error )( 
            IPassportManager * This,
            /* [retval][out] */ long *pErrorVal);
        
        /* [helpstring][hidden] */ HRESULT ( STDMETHODCALLTYPE *OnStartPageFilter )( 
            IPassportManager * This,
            /* [in] */ BYTE *pPFC,
            /* [out][in] */ DWORD *pBufSize,
            /* [size_is][out] */ LPSTR pCookieHeader);
        
        /* [helpstring][id] */ HRESULT ( STDMETHODCALLTYPE *OnStartPageASP )( 
            IPassportManager * This,
            /* [in] */ IDispatch *pdispRequest,
            /* [in] */ IDispatch *pdispResponse);
        
        /* [helpstring][id][hidden] */ HRESULT ( STDMETHODCALLTYPE *GetServerInfo )( 
            IPassportManager * This,
            /* [retval][out] */ BSTR *pbstrOut);
        
        /* [helpstring][id] */ HRESULT ( STDMETHODCALLTYPE *HaveConsent )( 
            IPassportManager * This,
            /* [in] */ VARIANT_BOOL bNeedFullConsent,
            /* [in] */ VARIANT_BOOL bNeedBirthdate,
            /* [retval][out] */ VARIANT_BOOL *pbHaveConsent);
        
        END_INTERFACE
    } IPassportManagerVtbl;

    interface IPassportManager
    {
        CONST_VTBL struct IPassportManagerVtbl *lpVtbl;
    };

    

#ifdef COBJMACROS


#define IPassportManager_QueryInterface(This,riid,ppvObject)	\
    (This)->lpVtbl -> QueryInterface(This,riid,ppvObject)

#define IPassportManager_AddRef(This)	\
    (This)->lpVtbl -> AddRef(This)

#define IPassportManager_Release(This)	\
    (This)->lpVtbl -> Release(This)


#define IPassportManager_GetTypeInfoCount(This,pctinfo)	\
    (This)->lpVtbl -> GetTypeInfoCount(This,pctinfo)

#define IPassportManager_GetTypeInfo(This,iTInfo,lcid,ppTInfo)	\
    (This)->lpVtbl -> GetTypeInfo(This,iTInfo,lcid,ppTInfo)

#define IPassportManager_GetIDsOfNames(This,riid,rgszNames,cNames,lcid,rgDispId)	\
    (This)->lpVtbl -> GetIDsOfNames(This,riid,rgszNames,cNames,lcid,rgDispId)

#define IPassportManager_Invoke(This,dispIdMember,riid,lcid,wFlags,pDispParams,pVarResult,pExcepInfo,puArgErr)	\
    (This)->lpVtbl -> Invoke(This,dispIdMember,riid,lcid,wFlags,pDispParams,pVarResult,pExcepInfo,puArgErr)


#define IPassportManager_OnStartPage(This,piUnk)	\
    (This)->lpVtbl -> OnStartPage(This,piUnk)

#define IPassportManager_OnEndPage(This)	\
    (This)->lpVtbl -> OnEndPage(This)

#define IPassportManager_OnStartPageECB(This,pECB,pBufSize,pCookieHeader)	\
    (This)->lpVtbl -> OnStartPageECB(This,pECB,pBufSize,pCookieHeader)

#define IPassportManager__Ticket(This,piTicket)	\
    (This)->lpVtbl -> _Ticket(This,piTicket)

#define IPassportManager__Profile(This,piProfile)	\
    (This)->lpVtbl -> _Profile(This,piProfile)

#define IPassportManager_AuthURL(This,returnUrl,TimeWindow,ForceLogin,coBrandArgs,lang_id,NameSpace,KPP,SecureLevel,pAuthVal)	\
    (This)->lpVtbl -> AuthURL(This,returnUrl,TimeWindow,ForceLogin,coBrandArgs,lang_id,NameSpace,KPP,SecureLevel,pAuthVal)

#define IPassportManager_IsAuthenticated(This,TimeWindow,ForceLogin,SecureLevel,pVal)	\
    (This)->lpVtbl -> IsAuthenticated(This,TimeWindow,ForceLogin,SecureLevel,pVal)

#define IPassportManager_LogoTag(This,returnUrl,TimeWindow,ForceLogin,coBrandArgs,lang_id,bSecure,NameSpace,KPP,SecureLevel,pVal)	\
    (This)->lpVtbl -> LogoTag(This,returnUrl,TimeWindow,ForceLogin,coBrandArgs,lang_id,bSecure,NameSpace,KPP,SecureLevel,pVal)

#define IPassportManager_HasProfile(This,ProfileName,pVal)	\
    (This)->lpVtbl -> HasProfile(This,ProfileName,pVal)

#define IPassportManager_get_HasTicket(This,pVal)	\
    (This)->lpVtbl -> get_HasTicket(This,pVal)

#define IPassportManager_get_FromNetworkServer(This,pVal)	\
    (This)->lpVtbl -> get_FromNetworkServer(This,pVal)

#define IPassportManager_HasFlag(This,flagMask,pVal)	\
    (This)->lpVtbl -> HasFlag(This,flagMask,pVal)

#define IPassportManager_get_TicketAge(This,pVal)	\
    (This)->lpVtbl -> get_TicketAge(This,pVal)

#define IPassportManager_get_TimeSinceSignIn(This,pVal)	\
    (This)->lpVtbl -> get_TimeSinceSignIn(This,pVal)

#define IPassportManager_GetDomainAttribute(This,attributeName,lcid,domain,pAttrVal)	\
    (This)->lpVtbl -> GetDomainAttribute(This,attributeName,lcid,domain,pAttrVal)

#define IPassportManager_DomainFromMemberName(This,memberName,pDomainName)	\
    (This)->lpVtbl -> DomainFromMemberName(This,memberName,pDomainName)

#define IPassportManager_get_ProfileByIndex(This,index,pVal)	\
    (This)->lpVtbl -> get_ProfileByIndex(This,index,pVal)

#define IPassportManager_put_ProfileByIndex(This,index,newVal)	\
    (This)->lpVtbl -> put_ProfileByIndex(This,index,newVal)

#define IPassportManager_OnStartPageManual(This,queryStringT,queryStringP,MSPAuthCookie,MSPProfCookie,MSPConsentCookie,vMSPSecCookie,pSetCookieArray)	\
    (This)->lpVtbl -> OnStartPageManual(This,queryStringT,queryStringP,MSPAuthCookie,MSPProfCookie,MSPConsentCookie,vMSPSecCookie,pSetCookieArray)

#define IPassportManager_get_HasSavedPassword(This,pVal)	\
    (This)->lpVtbl -> get_HasSavedPassword(This,pVal)

#define IPassportManager_Commit(This,pNewProfileCookieHeader)	\
    (This)->lpVtbl -> Commit(This,pNewProfileCookieHeader)

#define IPassportManager_get_Profile(This,attributeName,pVal)	\
    (This)->lpVtbl -> get_Profile(This,attributeName,pVal)

#define IPassportManager_put_Profile(This,attributeName,newVal)	\
    (This)->lpVtbl -> put_Profile(This,attributeName,newVal)

#define IPassportManager_get_TicketTime(This,pVal)	\
    (This)->lpVtbl -> get_TicketTime(This,pVal)

#define IPassportManager_get_SignInTime(This,pVal)	\
    (This)->lpVtbl -> get_SignInTime(This,pVal)

#define IPassportManager_get_Domains(This,pArrayVal)	\
    (This)->lpVtbl -> get_Domains(This,pArrayVal)

#define IPassportManager_get_Error(This,pErrorVal)	\
    (This)->lpVtbl -> get_Error(This,pErrorVal)

#define IPassportManager_OnStartPageFilter(This,pPFC,pBufSize,pCookieHeader)	\
    (This)->lpVtbl -> OnStartPageFilter(This,pPFC,pBufSize,pCookieHeader)

#define IPassportManager_OnStartPageASP(This,pdispRequest,pdispResponse)	\
    (This)->lpVtbl -> OnStartPageASP(This,pdispRequest,pdispResponse)

#define IPassportManager_GetServerInfo(This,pbstrOut)	\
    (This)->lpVtbl -> GetServerInfo(This,pbstrOut)

#define IPassportManager_HaveConsent(This,bNeedFullConsent,bNeedBirthdate,pbHaveConsent)	\
    (This)->lpVtbl -> HaveConsent(This,bNeedFullConsent,bNeedBirthdate,pbHaveConsent)

#endif /* COBJMACROS */


#endif 	/* C style interface */



HRESULT STDMETHODCALLTYPE IPassportManager_OnStartPage_Proxy( 
    IPassportManager * This,
    /* [in] */ IUnknown *piUnk);


void __RPC_STUB IPassportManager_OnStartPage_Stub(
    IRpcStubBuffer *This,
    IRpcChannelBuffer *_pRpcChannelBuffer,
    PRPC_MESSAGE _pRpcMessage,
    DWORD *_pdwStubPhase);


HRESULT STDMETHODCALLTYPE IPassportManager_OnEndPage_Proxy( 
    IPassportManager * This);


void __RPC_STUB IPassportManager_OnEndPage_Stub(
    IRpcStubBuffer *This,
    IRpcChannelBuffer *_pRpcChannelBuffer,
    PRPC_MESSAGE _pRpcMessage,
    DWORD *_pdwStubPhase);


HRESULT STDMETHODCALLTYPE IPassportManager_OnStartPageECB_Proxy( 
    IPassportManager * This,
    /* [in] */ BYTE *pECB,
    /* [out][in] */ DWORD *pBufSize,
    /* [size_is][out] */ LPSTR pCookieHeader);


void __RPC_STUB IPassportManager_OnStartPageECB_Stub(
    IRpcStubBuffer *This,
    IRpcChannelBuffer *_pRpcChannelBuffer,
    PRPC_MESSAGE _pRpcMessage,
    DWORD *_pdwStubPhase);


/* [hidden] */ HRESULT STDMETHODCALLTYPE IPassportManager__Ticket_Proxy( 
    IPassportManager * This,
    /* [out] */ IPassportTicket **piTicket);


void __RPC_STUB IPassportManager__Ticket_Stub(
    IRpcStubBuffer *This,
    IRpcChannelBuffer *_pRpcChannelBuffer,
    PRPC_MESSAGE _pRpcMessage,
    DWORD *_pdwStubPhase);


/* [hidden] */ HRESULT STDMETHODCALLTYPE IPassportManager__Profile_Proxy( 
    IPassportManager * This,
    /* [out] */ IPassportProfile **piProfile);


void __RPC_STUB IPassportManager__Profile_Stub(
    IRpcStubBuffer *This,
    IRpcChannelBuffer *_pRpcChannelBuffer,
    PRPC_MESSAGE _pRpcMessage,
    DWORD *_pdwStubPhase);


/* [helpstring][id] */ HRESULT STDMETHODCALLTYPE IPassportManager_AuthURL_Proxy( 
    IPassportManager * This,
    /* [optional][in] */ VARIANT returnUrl,
    /* [optional][in] */ VARIANT TimeWindow,
    /* [optional][in] */ VARIANT ForceLogin,
    /* [optional][in] */ VARIANT coBrandArgs,
    /* [optional][in] */ VARIANT lang_id,
    /* [optional][in] */ VARIANT NameSpace,
    /* [optional][in] */ VARIANT KPP,
    /* [optional][in] */ VARIANT SecureLevel,
    /* [retval][out] */ BSTR *pAuthVal);


void __RPC_STUB IPassportManager_AuthURL_Stub(
    IRpcStubBuffer *This,
    IRpcChannelBuffer *_pRpcChannelBuffer,
    PRPC_MESSAGE _pRpcMessage,
    DWORD *_pdwStubPhase);


/* [helpstring][id] */ HRESULT STDMETHODCALLTYPE IPassportManager_IsAuthenticated_Proxy( 
    IPassportManager * This,
    /* [optional][in] */ VARIANT TimeWindow,
    /* [optional][in] */ VARIANT ForceLogin,
    /* [optional][in] */ VARIANT SecureLevel,
    /* [retval][out] */ VARIANT_BOOL *pVal);


void __RPC_STUB IPassportManager_IsAuthenticated_Stub(
    IRpcStubBuffer *This,
    IRpcChannelBuffer *_pRpcChannelBuffer,
    PRPC_MESSAGE _pRpcMessage,
    DWORD *_pdwStubPhase);


/* [helpstring][id] */ HRESULT STDMETHODCALLTYPE IPassportManager_LogoTag_Proxy( 
    IPassportManager * This,
    /* [optional][in] */ VARIANT returnUrl,
    /* [optional][in] */ VARIANT TimeWindow,
    /* [optional][in] */ VARIANT ForceLogin,
    /* [optional][in] */ VARIANT coBrandArgs,
    /* [optional][in] */ VARIANT lang_id,
    /* [optional][in] */ VARIANT bSecure,
    /* [optional][in] */ VARIANT NameSpace,
    /* [optional][in] */ VARIANT KPP,
    /* [optional][in] */ VARIANT SecureLevel,
    /* [retval][out] */ BSTR *pVal);


void __RPC_STUB IPassportManager_LogoTag_Stub(
    IRpcStubBuffer *This,
    IRpcChannelBuffer *_pRpcChannelBuffer,
    PRPC_MESSAGE _pRpcMessage,
    DWORD *_pdwStubPhase);


/* [helpstring][id] */ HRESULT STDMETHODCALLTYPE IPassportManager_HasProfile_Proxy( 
    IPassportManager * This,
    /* [optional][in] */ VARIANT ProfileName,
    /* [retval][out] */ VARIANT_BOOL *pVal);


void __RPC_STUB IPassportManager_HasProfile_Stub(
    IRpcStubBuffer *This,
    IRpcChannelBuffer *_pRpcChannelBuffer,
    PRPC_MESSAGE _pRpcMessage,
    DWORD *_pdwStubPhase);


/* [helpstring][id][propget] */ HRESULT STDMETHODCALLTYPE IPassportManager_get_HasTicket_Proxy( 
    IPassportManager * This,
    /* [retval][out] */ VARIANT_BOOL *pVal);


void __RPC_STUB IPassportManager_get_HasTicket_Stub(
    IRpcStubBuffer *This,
    IRpcChannelBuffer *_pRpcChannelBuffer,
    PRPC_MESSAGE _pRpcMessage,
    DWORD *_pdwStubPhase);


/* [helpstring][id][propget] */ HRESULT STDMETHODCALLTYPE IPassportManager_get_FromNetworkServer_Proxy( 
    IPassportManager * This,
    /* [retval][out] */ VARIANT_BOOL *pVal);


void __RPC_STUB IPassportManager_get_FromNetworkServer_Stub(
    IRpcStubBuffer *This,
    IRpcChannelBuffer *_pRpcChannelBuffer,
    PRPC_MESSAGE _pRpcMessage,
    DWORD *_pdwStubPhase);


/* [helpstring][id] */ HRESULT STDMETHODCALLTYPE IPassportManager_HasFlag_Proxy( 
    IPassportManager * This,
    /* [optional][in] */ VARIANT flagMask,
    /* [retval][out] */ VARIANT_BOOL *pVal);


void __RPC_STUB IPassportManager_HasFlag_Stub(
    IRpcStubBuffer *This,
    IRpcChannelBuffer *_pRpcChannelBuffer,
    PRPC_MESSAGE _pRpcMessage,
    DWORD *_pdwStubPhase);


/* [helpstring][id][propget] */ HRESULT STDMETHODCALLTYPE IPassportManager_get_TicketAge_Proxy( 
    IPassportManager * This,
    /* [retval][out] */ int *pVal);


void __RPC_STUB IPassportManager_get_TicketAge_Stub(
    IRpcStubBuffer *This,
    IRpcChannelBuffer *_pRpcChannelBuffer,
    PRPC_MESSAGE _pRpcMessage,
    DWORD *_pdwStubPhase);


/* [helpstring][id][propget] */ HRESULT STDMETHODCALLTYPE IPassportManager_get_TimeSinceSignIn_Proxy( 
    IPassportManager * This,
    /* [retval][out] */ int *pVal);


void __RPC_STUB IPassportManager_get_TimeSinceSignIn_Stub(
    IRpcStubBuffer *This,
    IRpcChannelBuffer *_pRpcChannelBuffer,
    PRPC_MESSAGE _pRpcMessage,
    DWORD *_pdwStubPhase);


/* [helpstring][id] */ HRESULT STDMETHODCALLTYPE IPassportManager_GetDomainAttribute_Proxy( 
    IPassportManager * This,
    /* [in] */ BSTR attributeName,
    /* [optional][in] */ VARIANT lcid,
    /* [optional][in] */ VARIANT domain,
    /* [retval][out] */ BSTR *pAttrVal);


void __RPC_STUB IPassportManager_GetDomainAttribute_Stub(
    IRpcStubBuffer *This,
    IRpcChannelBuffer *_pRpcChannelBuffer,
    PRPC_MESSAGE _pRpcMessage,
    DWORD *_pdwStubPhase);


/* [helpstring][id] */ HRESULT STDMETHODCALLTYPE IPassportManager_DomainFromMemberName_Proxy( 
    IPassportManager * This,
    /* [optional][in] */ VARIANT memberName,
    /* [retval][out] */ BSTR *pDomainName);


void __RPC_STUB IPassportManager_DomainFromMemberName_Stub(
    IRpcStubBuffer *This,
    IRpcChannelBuffer *_pRpcChannelBuffer,
    PRPC_MESSAGE _pRpcMessage,
    DWORD *_pdwStubPhase);


/* [helpstring][id][propget] */ HRESULT STDMETHODCALLTYPE IPassportManager_get_ProfileByIndex_Proxy( 
    IPassportManager * This,
    /* [in] */ int index,
    /* [retval][out] */ VARIANT *pVal);


void __RPC_STUB IPassportManager_get_ProfileByIndex_Stub(
    IRpcStubBuffer *This,
    IRpcChannelBuffer *_pRpcChannelBuffer,
    PRPC_MESSAGE _pRpcMessage,
    DWORD *_pdwStubPhase);


/* [helpstring][id][propput] */ HRESULT STDMETHODCALLTYPE IPassportManager_put_ProfileByIndex_Proxy( 
    IPassportManager * This,
    /* [in] */ int index,
    /* [in] */ VARIANT newVal);


void __RPC_STUB IPassportManager_put_ProfileByIndex_Stub(
    IRpcStubBuffer *This,
    IRpcChannelBuffer *_pRpcChannelBuffer,
    PRPC_MESSAGE _pRpcMessage,
    DWORD *_pdwStubPhase);


/* [helpstring][id] */ HRESULT STDMETHODCALLTYPE IPassportManager_OnStartPageManual_Proxy( 
    IPassportManager * This,
    /* [in] */ BSTR queryStringT,
    /* [in] */ BSTR queryStringP,
    /* [in] */ BSTR MSPAuthCookie,
    /* [in] */ BSTR MSPProfCookie,
    /* [in] */ BSTR MSPConsentCookie,
    /* [optional][in] */ VARIANT vMSPSecCookie,
    /* [retval][out] */ VARIANT *pSetCookieArray);


void __RPC_STUB IPassportManager_OnStartPageManual_Stub(
    IRpcStubBuffer *This,
    IRpcChannelBuffer *_pRpcChannelBuffer,
    PRPC_MESSAGE _pRpcMessage,
    DWORD *_pdwStubPhase);


/* [helpstring][id][propget] */ HRESULT STDMETHODCALLTYPE IPassportManager_get_HasSavedPassword_Proxy( 
    IPassportManager * This,
    /* [retval][out] */ VARIANT_BOOL *pVal);


void __RPC_STUB IPassportManager_get_HasSavedPassword_Stub(
    IRpcStubBuffer *This,
    IRpcChannelBuffer *_pRpcChannelBuffer,
    PRPC_MESSAGE _pRpcMessage,
    DWORD *_pdwStubPhase);


/* [helpstring][id] */ HRESULT STDMETHODCALLTYPE IPassportManager_Commit_Proxy( 
    IPassportManager * This,
    /* [retval][out] */ BSTR *pNewProfileCookieHeader);


void __RPC_STUB IPassportManager_Commit_Stub(
    IRpcStubBuffer *This,
    IRpcChannelBuffer *_pRpcChannelBuffer,
    PRPC_MESSAGE _pRpcMessage,
    DWORD *_pdwStubPhase);


/* [helpstring][id][propget] */ HRESULT STDMETHODCALLTYPE IPassportManager_get_Profile_Proxy( 
    IPassportManager * This,
    /* [in] */ BSTR attributeName,
    /* [retval][out] */ VARIANT *pVal);


void __RPC_STUB IPassportManager_get_Profile_Stub(
    IRpcStubBuffer *This,
    IRpcChannelBuffer *_pRpcChannelBuffer,
    PRPC_MESSAGE _pRpcMessage,
    DWORD *_pdwStubPhase);


/* [helpstring][id][propput] */ HRESULT STDMETHODCALLTYPE IPassportManager_put_Profile_Proxy( 
    IPassportManager * This,
    /* [in] */ BSTR attributeName,
    /* [in] */ VARIANT newVal);


void __RPC_STUB IPassportManager_put_Profile_Stub(
    IRpcStubBuffer *This,
    IRpcChannelBuffer *_pRpcChannelBuffer,
    PRPC_MESSAGE _pRpcMessage,
    DWORD *_pdwStubPhase);


/* [helpstring][id][propget][hidden] */ HRESULT STDMETHODCALLTYPE IPassportManager_get_TicketTime_Proxy( 
    IPassportManager * This,
    /* [retval][out] */ long *pVal);


void __RPC_STUB IPassportManager_get_TicketTime_Stub(
    IRpcStubBuffer *This,
    IRpcChannelBuffer *_pRpcChannelBuffer,
    PRPC_MESSAGE _pRpcMessage,
    DWORD *_pdwStubPhase);


/* [helpstring][id][propget][hidden] */ HRESULT STDMETHODCALLTYPE IPassportManager_get_SignInTime_Proxy( 
    IPassportManager * This,
    /* [retval][out] */ long *pVal);


void __RPC_STUB IPassportManager_get_SignInTime_Stub(
    IRpcStubBuffer *This,
    IRpcChannelBuffer *_pRpcChannelBuffer,
    PRPC_MESSAGE _pRpcMessage,
    DWORD *_pdwStubPhase);


/* [helpstring][id][propget][hidden] */ HRESULT STDMETHODCALLTYPE IPassportManager_get_Domains_Proxy( 
    IPassportManager * This,
    /* [retval][out] */ VARIANT *pArrayVal);


void __RPC_STUB IPassportManager_get_Domains_Stub(
    IRpcStubBuffer *This,
    IRpcChannelBuffer *_pRpcChannelBuffer,
    PRPC_MESSAGE _pRpcMessage,
    DWORD *_pdwStubPhase);


/* [helpstring][id][propget] */ HRESULT STDMETHODCALLTYPE IPassportManager_get_Error_Proxy( 
    IPassportManager * This,
    /* [retval][out] */ long *pErrorVal);


void __RPC_STUB IPassportManager_get_Error_Stub(
    IRpcStubBuffer *This,
    IRpcChannelBuffer *_pRpcChannelBuffer,
    PRPC_MESSAGE _pRpcMessage,
    DWORD *_pdwStubPhase);


/* [helpstring][hidden] */ HRESULT STDMETHODCALLTYPE IPassportManager_OnStartPageFilter_Proxy( 
    IPassportManager * This,
    /* [in] */ BYTE *pPFC,
    /* [out][in] */ DWORD *pBufSize,
    /* [size_is][out] */ LPSTR pCookieHeader);


void __RPC_STUB IPassportManager_OnStartPageFilter_Stub(
    IRpcStubBuffer *This,
    IRpcChannelBuffer *_pRpcChannelBuffer,
    PRPC_MESSAGE _pRpcMessage,
    DWORD *_pdwStubPhase);


/* [helpstring][id] */ HRESULT STDMETHODCALLTYPE IPassportManager_OnStartPageASP_Proxy( 
    IPassportManager * This,
    /* [in] */ IDispatch *pdispRequest,
    /* [in] */ IDispatch *pdispResponse);


void __RPC_STUB IPassportManager_OnStartPageASP_Stub(
    IRpcStubBuffer *This,
    IRpcChannelBuffer *_pRpcChannelBuffer,
    PRPC_MESSAGE _pRpcMessage,
    DWORD *_pdwStubPhase);


/* [helpstring][id][hidden] */ HRESULT STDMETHODCALLTYPE IPassportManager_GetServerInfo_Proxy( 
    IPassportManager * This,
    /* [retval][out] */ BSTR *pbstrOut);


void __RPC_STUB IPassportManager_GetServerInfo_Stub(
    IRpcStubBuffer *This,
    IRpcChannelBuffer *_pRpcChannelBuffer,
    PRPC_MESSAGE _pRpcMessage,
    DWORD *_pdwStubPhase);


/* [helpstring][id] */ HRESULT STDMETHODCALLTYPE IPassportManager_HaveConsent_Proxy( 
    IPassportManager * This,
    /* [in] */ VARIANT_BOOL bNeedFullConsent,
    /* [in] */ VARIANT_BOOL bNeedBirthdate,
    /* [retval][out] */ VARIANT_BOOL *pbHaveConsent);


void __RPC_STUB IPassportManager_HaveConsent_Stub(
    IRpcStubBuffer *This,
    IRpcChannelBuffer *_pRpcChannelBuffer,
    PRPC_MESSAGE _pRpcMessage,
    DWORD *_pdwStubPhase);



#endif 	/* __IPassportManager_INTERFACE_DEFINED__ */


#ifndef __IPassportManager2_INTERFACE_DEFINED__
#define __IPassportManager2_INTERFACE_DEFINED__

/* interface IPassportManager2 */
/* [unique][helpstring][dual][uuid][object] */ 


EXTERN_C const IID IID_IPassportManager2;

#if defined(__cplusplus) && !defined(CINTERFACE)
    
    MIDL_INTERFACE("8ca48d6a-0b51-4f7a-9475-b0a8b59c3999")
    IPassportManager2 : public IPassportManager
    {
    public:
        virtual /* [helpstring][id] */ HRESULT STDMETHODCALLTYPE LoginUser( 
            /* [optional][in] */ VARIANT returnUrl,
            /* [optional][in] */ VARIANT TimeWindow,
            /* [optional][in] */ VARIANT ForceLogin,
            /* [optional][in] */ VARIANT coBrandTemplate,
            /* [optional][in] */ VARIANT lang_id,
            /* [optional][in] */ VARIANT NameSpace,
            /* [optional][in] */ VARIANT KPP,
            /* [optional][in] */ VARIANT SecureLevel,
            /* [optional][in] */ VARIANT ExtraParams) = 0;
        
        virtual /* [helpstring][id] */ HRESULT STDMETHODCALLTYPE AuthURL2( 
            /* [optional][in] */ VARIANT returnUrl,
            /* [optional][in] */ VARIANT TimeWindow,
            /* [optional][in] */ VARIANT ForceLogin,
            /* [optional][in] */ VARIANT coBrandArgs,
            /* [optional][in] */ VARIANT lang_id,
            /* [optional][in] */ VARIANT NameSpace,
            /* [optional][in] */ VARIANT KPP,
            /* [optional][in] */ VARIANT SecureLevel,
            /* [retval][out] */ BSTR *pAuthVal) = 0;
        
        virtual /* [helpstring][id] */ HRESULT STDMETHODCALLTYPE LogoTag2( 
            /* [optional][in] */ VARIANT returnUrl,
            /* [optional][in] */ VARIANT TimeWindow,
            /* [optional][in] */ VARIANT ForceLogin,
            /* [optional][in] */ VARIANT coBrandArgs,
            /* [optional][in] */ VARIANT lang_id,
            /* [optional][in] */ VARIANT bSecure,
            /* [optional][in] */ VARIANT NameSpace,
            /* [optional][in] */ VARIANT KPP,
            /* [optional][in] */ VARIANT SecureLevel,
            /* [retval][out] */ BSTR *pVal) = 0;
        
    };
    
#else 	/* C style interface */

    typedef struct IPassportManager2Vtbl
    {
        BEGIN_INTERFACE
        
        HRESULT ( STDMETHODCALLTYPE *QueryInterface )( 
            IPassportManager2 * This,
            /* [in] */ REFIID riid,
            /* [iid_is][out] */ void **ppvObject);
        
        ULONG ( STDMETHODCALLTYPE *AddRef )( 
            IPassportManager2 * This);
        
        ULONG ( STDMETHODCALLTYPE *Release )( 
            IPassportManager2 * This);
        
        HRESULT ( STDMETHODCALLTYPE *GetTypeInfoCount )( 
            IPassportManager2 * This,
            /* [out] */ UINT *pctinfo);
        
        HRESULT ( STDMETHODCALLTYPE *GetTypeInfo )( 
            IPassportManager2 * This,
            /* [in] */ UINT iTInfo,
            /* [in] */ LCID lcid,
            /* [out] */ ITypeInfo **ppTInfo);
        
        HRESULT ( STDMETHODCALLTYPE *GetIDsOfNames )( 
            IPassportManager2 * This,
            /* [in] */ REFIID riid,
            /* [size_is][in] */ LPOLESTR *rgszNames,
            /* [in] */ UINT cNames,
            /* [in] */ LCID lcid,
            /* [size_is][out] */ DISPID *rgDispId);
        
        /* [local] */ HRESULT ( STDMETHODCALLTYPE *Invoke )( 
            IPassportManager2 * This,
            /* [in] */ DISPID dispIdMember,
            /* [in] */ REFIID riid,
            /* [in] */ LCID lcid,
            /* [in] */ WORD wFlags,
            /* [out][in] */ DISPPARAMS *pDispParams,
            /* [out] */ VARIANT *pVarResult,
            /* [out] */ EXCEPINFO *pExcepInfo,
            /* [out] */ UINT *puArgErr);
        
        HRESULT ( STDMETHODCALLTYPE *OnStartPage )( 
            IPassportManager2 * This,
            /* [in] */ IUnknown *piUnk);
        
        HRESULT ( STDMETHODCALLTYPE *OnEndPage )( 
            IPassportManager2 * This);
        
        HRESULT ( STDMETHODCALLTYPE *OnStartPageECB )( 
            IPassportManager2 * This,
            /* [in] */ BYTE *pECB,
            /* [out][in] */ DWORD *pBufSize,
            /* [size_is][out] */ LPSTR pCookieHeader);
        
        /* [hidden] */ HRESULT ( STDMETHODCALLTYPE *_Ticket )( 
            IPassportManager2 * This,
            /* [out] */ IPassportTicket **piTicket);
        
        /* [hidden] */ HRESULT ( STDMETHODCALLTYPE *_Profile )( 
            IPassportManager2 * This,
            /* [out] */ IPassportProfile **piProfile);
        
        /* [helpstring][id] */ HRESULT ( STDMETHODCALLTYPE *AuthURL )( 
            IPassportManager2 * This,
            /* [optional][in] */ VARIANT returnUrl,
            /* [optional][in] */ VARIANT TimeWindow,
            /* [optional][in] */ VARIANT ForceLogin,
            /* [optional][in] */ VARIANT coBrandArgs,
            /* [optional][in] */ VARIANT lang_id,
            /* [optional][in] */ VARIANT NameSpace,
            /* [optional][in] */ VARIANT KPP,
            /* [optional][in] */ VARIANT SecureLevel,
            /* [retval][out] */ BSTR *pAuthVal);
        
        /* [helpstring][id] */ HRESULT ( STDMETHODCALLTYPE *IsAuthenticated )( 
            IPassportManager2 * This,
            /* [optional][in] */ VARIANT TimeWindow,
            /* [optional][in] */ VARIANT ForceLogin,
            /* [optional][in] */ VARIANT SecureLevel,
            /* [retval][out] */ VARIANT_BOOL *pVal);
        
        /* [helpstring][id] */ HRESULT ( STDMETHODCALLTYPE *LogoTag )( 
            IPassportManager2 * This,
            /* [optional][in] */ VARIANT returnUrl,
            /* [optional][in] */ VARIANT TimeWindow,
            /* [optional][in] */ VARIANT ForceLogin,
            /* [optional][in] */ VARIANT coBrandArgs,
            /* [optional][in] */ VARIANT lang_id,
            /* [optional][in] */ VARIANT bSecure,
            /* [optional][in] */ VARIANT NameSpace,
            /* [optional][in] */ VARIANT KPP,
            /* [optional][in] */ VARIANT SecureLevel,
            /* [retval][out] */ BSTR *pVal);
        
        /* [helpstring][id] */ HRESULT ( STDMETHODCALLTYPE *HasProfile )( 
            IPassportManager2 * This,
            /* [optional][in] */ VARIANT ProfileName,
            /* [retval][out] */ VARIANT_BOOL *pVal);
        
        /* [helpstring][id][propget] */ HRESULT ( STDMETHODCALLTYPE *get_HasTicket )( 
            IPassportManager2 * This,
            /* [retval][out] */ VARIANT_BOOL *pVal);
        
        /* [helpstring][id][propget] */ HRESULT ( STDMETHODCALLTYPE *get_FromNetworkServer )( 
            IPassportManager2 * This,
            /* [retval][out] */ VARIANT_BOOL *pVal);
        
        /* [helpstring][id] */ HRESULT ( STDMETHODCALLTYPE *HasFlag )( 
            IPassportManager2 * This,
            /* [optional][in] */ VARIANT flagMask,
            /* [retval][out] */ VARIANT_BOOL *pVal);
        
        /* [helpstring][id][propget] */ HRESULT ( STDMETHODCALLTYPE *get_TicketAge )( 
            IPassportManager2 * This,
            /* [retval][out] */ int *pVal);
        
        /* [helpstring][id][propget] */ HRESULT ( STDMETHODCALLTYPE *get_TimeSinceSignIn )( 
            IPassportManager2 * This,
            /* [retval][out] */ int *pVal);
        
        /* [helpstring][id] */ HRESULT ( STDMETHODCALLTYPE *GetDomainAttribute )( 
            IPassportManager2 * This,
            /* [in] */ BSTR attributeName,
            /* [optional][in] */ VARIANT lcid,
            /* [optional][in] */ VARIANT domain,
            /* [retval][out] */ BSTR *pAttrVal);
        
        /* [helpstring][id] */ HRESULT ( STDMETHODCALLTYPE *DomainFromMemberName )( 
            IPassportManager2 * This,
            /* [optional][in] */ VARIANT memberName,
            /* [retval][out] */ BSTR *pDomainName);
        
        /* [helpstring][id][propget] */ HRESULT ( STDMETHODCALLTYPE *get_ProfileByIndex )( 
            IPassportManager2 * This,
            /* [in] */ int index,
            /* [retval][out] */ VARIANT *pVal);
        
        /* [helpstring][id][propput] */ HRESULT ( STDMETHODCALLTYPE *put_ProfileByIndex )( 
            IPassportManager2 * This,
            /* [in] */ int index,
            /* [in] */ VARIANT newVal);
        
        /* [helpstring][id] */ HRESULT ( STDMETHODCALLTYPE *OnStartPageManual )( 
            IPassportManager2 * This,
            /* [in] */ BSTR queryStringT,
            /* [in] */ BSTR queryStringP,
            /* [in] */ BSTR MSPAuthCookie,
            /* [in] */ BSTR MSPProfCookie,
            /* [in] */ BSTR MSPConsentCookie,
            /* [optional][in] */ VARIANT vMSPSecCookie,
            /* [retval][out] */ VARIANT *pSetCookieArray);
        
        /* [helpstring][id][propget] */ HRESULT ( STDMETHODCALLTYPE *get_HasSavedPassword )( 
            IPassportManager2 * This,
            /* [retval][out] */ VARIANT_BOOL *pVal);
        
        /* [helpstring][id] */ HRESULT ( STDMETHODCALLTYPE *Commit )( 
            IPassportManager2 * This,
            /* [retval][out] */ BSTR *pNewProfileCookieHeader);
        
        /* [helpstring][id][propget] */ HRESULT ( STDMETHODCALLTYPE *get_Profile )( 
            IPassportManager2 * This,
            /* [in] */ BSTR attributeName,
            /* [retval][out] */ VARIANT *pVal);
        
        /* [helpstring][id][propput] */ HRESULT ( STDMETHODCALLTYPE *put_Profile )( 
            IPassportManager2 * This,
            /* [in] */ BSTR attributeName,
            /* [in] */ VARIANT newVal);
        
        /* [helpstring][id][propget][hidden] */ HRESULT ( STDMETHODCALLTYPE *get_TicketTime )( 
            IPassportManager2 * This,
            /* [retval][out] */ long *pVal);
        
        /* [helpstring][id][propget][hidden] */ HRESULT ( STDMETHODCALLTYPE *get_SignInTime )( 
            IPassportManager2 * This,
            /* [retval][out] */ long *pVal);
        
        /* [helpstring][id][propget][hidden] */ HRESULT ( STDMETHODCALLTYPE *get_Domains )( 
            IPassportManager2 * This,
            /* [retval][out] */ VARIANT *pArrayVal);
        
        /* [helpstring][id][propget] */ HRESULT ( STDMETHODCALLTYPE *get_Error )( 
            IPassportManager2 * This,
            /* [retval][out] */ long *pErrorVal);
        
        /* [helpstring][hidden] */ HRESULT ( STDMETHODCALLTYPE *OnStartPageFilter )( 
            IPassportManager2 * This,
            /* [in] */ BYTE *pPFC,
            /* [out][in] */ DWORD *pBufSize,
            /* [size_is][out] */ LPSTR pCookieHeader);
        
        /* [helpstring][id] */ HRESULT ( STDMETHODCALLTYPE *OnStartPageASP )( 
            IPassportManager2 * This,
            /* [in] */ IDispatch *pdispRequest,
            /* [in] */ IDispatch *pdispResponse);
        
        /* [helpstring][id][hidden] */ HRESULT ( STDMETHODCALLTYPE *GetServerInfo )( 
            IPassportManager2 * This,
            /* [retval][out] */ BSTR *pbstrOut);
        
        /* [helpstring][id] */ HRESULT ( STDMETHODCALLTYPE *HaveConsent )( 
            IPassportManager2 * This,
            /* [in] */ VARIANT_BOOL bNeedFullConsent,
            /* [in] */ VARIANT_BOOL bNeedBirthdate,
            /* [retval][out] */ VARIANT_BOOL *pbHaveConsent);
        
        /* [helpstring][id] */ HRESULT ( STDMETHODCALLTYPE *LoginUser )( 
            IPassportManager2 * This,
            /* [optional][in] */ VARIANT returnUrl,
            /* [optional][in] */ VARIANT TimeWindow,
            /* [optional][in] */ VARIANT ForceLogin,
            /* [optional][in] */ VARIANT coBrandTemplate,
            /* [optional][in] */ VARIANT lang_id,
            /* [optional][in] */ VARIANT NameSpace,
            /* [optional][in] */ VARIANT KPP,
            /* [optional][in] */ VARIANT SecureLevel,
            /* [optional][in] */ VARIANT ExtraParams);
        
        /* [helpstring][id] */ HRESULT ( STDMETHODCALLTYPE *AuthURL2 )( 
            IPassportManager2 * This,
            /* [optional][in] */ VARIANT returnUrl,
            /* [optional][in] */ VARIANT TimeWindow,
            /* [optional][in] */ VARIANT ForceLogin,
            /* [optional][in] */ VARIANT coBrandArgs,
            /* [optional][in] */ VARIANT lang_id,
            /* [optional][in] */ VARIANT NameSpace,
            /* [optional][in] */ VARIANT KPP,
            /* [optional][in] */ VARIANT SecureLevel,
            /* [retval][out] */ BSTR *pAuthVal);
        
        /* [helpstring][id] */ HRESULT ( STDMETHODCALLTYPE *LogoTag2 )( 
            IPassportManager2 * This,
            /* [optional][in] */ VARIANT returnUrl,
            /* [optional][in] */ VARIANT TimeWindow,
            /* [optional][in] */ VARIANT ForceLogin,
            /* [optional][in] */ VARIANT coBrandArgs,
            /* [optional][in] */ VARIANT lang_id,
            /* [optional][in] */ VARIANT bSecure,
            /* [optional][in] */ VARIANT NameSpace,
            /* [optional][in] */ VARIANT KPP,
            /* [optional][in] */ VARIANT SecureLevel,
            /* [retval][out] */ BSTR *pVal);
        
        END_INTERFACE
    } IPassportManager2Vtbl;

    interface IPassportManager2
    {
        CONST_VTBL struct IPassportManager2Vtbl *lpVtbl;
    };

    

#ifdef COBJMACROS


#define IPassportManager2_QueryInterface(This,riid,ppvObject)	\
    (This)->lpVtbl -> QueryInterface(This,riid,ppvObject)

#define IPassportManager2_AddRef(This)	\
    (This)->lpVtbl -> AddRef(This)

#define IPassportManager2_Release(This)	\
    (This)->lpVtbl -> Release(This)


#define IPassportManager2_GetTypeInfoCount(This,pctinfo)	\
    (This)->lpVtbl -> GetTypeInfoCount(This,pctinfo)

#define IPassportManager2_GetTypeInfo(This,iTInfo,lcid,ppTInfo)	\
    (This)->lpVtbl -> GetTypeInfo(This,iTInfo,lcid,ppTInfo)

#define IPassportManager2_GetIDsOfNames(This,riid,rgszNames,cNames,lcid,rgDispId)	\
    (This)->lpVtbl -> GetIDsOfNames(This,riid,rgszNames,cNames,lcid,rgDispId)

#define IPassportManager2_Invoke(This,dispIdMember,riid,lcid,wFlags,pDispParams,pVarResult,pExcepInfo,puArgErr)	\
    (This)->lpVtbl -> Invoke(This,dispIdMember,riid,lcid,wFlags,pDispParams,pVarResult,pExcepInfo,puArgErr)


#define IPassportManager2_OnStartPage(This,piUnk)	\
    (This)->lpVtbl -> OnStartPage(This,piUnk)

#define IPassportManager2_OnEndPage(This)	\
    (This)->lpVtbl -> OnEndPage(This)

#define IPassportManager2_OnStartPageECB(This,pECB,pBufSize,pCookieHeader)	\
    (This)->lpVtbl -> OnStartPageECB(This,pECB,pBufSize,pCookieHeader)

#define IPassportManager2__Ticket(This,piTicket)	\
    (This)->lpVtbl -> _Ticket(This,piTicket)

#define IPassportManager2__Profile(This,piProfile)	\
    (This)->lpVtbl -> _Profile(This,piProfile)

#define IPassportManager2_AuthURL(This,returnUrl,TimeWindow,ForceLogin,coBrandArgs,lang_id,NameSpace,KPP,SecureLevel,pAuthVal)	\
    (This)->lpVtbl -> AuthURL(This,returnUrl,TimeWindow,ForceLogin,coBrandArgs,lang_id,NameSpace,KPP,SecureLevel,pAuthVal)

#define IPassportManager2_IsAuthenticated(This,TimeWindow,ForceLogin,SecureLevel,pVal)	\
    (This)->lpVtbl -> IsAuthenticated(This,TimeWindow,ForceLogin,SecureLevel,pVal)

#define IPassportManager2_LogoTag(This,returnUrl,TimeWindow,ForceLogin,coBrandArgs,lang_id,bSecure,NameSpace,KPP,SecureLevel,pVal)	\
    (This)->lpVtbl -> LogoTag(This,returnUrl,TimeWindow,ForceLogin,coBrandArgs,lang_id,bSecure,NameSpace,KPP,SecureLevel,pVal)

#define IPassportManager2_HasProfile(This,ProfileName,pVal)	\
    (This)->lpVtbl -> HasProfile(This,ProfileName,pVal)

#define IPassportManager2_get_HasTicket(This,pVal)	\
    (This)->lpVtbl -> get_HasTicket(This,pVal)

#define IPassportManager2_get_FromNetworkServer(This,pVal)	\
    (This)->lpVtbl -> get_FromNetworkServer(This,pVal)

#define IPassportManager2_HasFlag(This,flagMask,pVal)	\
    (This)->lpVtbl -> HasFlag(This,flagMask,pVal)

#define IPassportManager2_get_TicketAge(This,pVal)	\
    (This)->lpVtbl -> get_TicketAge(This,pVal)

#define IPassportManager2_get_TimeSinceSignIn(This,pVal)	\
    (This)->lpVtbl -> get_TimeSinceSignIn(This,pVal)

#define IPassportManager2_GetDomainAttribute(This,attributeName,lcid,domain,pAttrVal)	\
    (This)->lpVtbl -> GetDomainAttribute(This,attributeName,lcid,domain,pAttrVal)

#define IPassportManager2_DomainFromMemberName(This,memberName,pDomainName)	\
    (This)->lpVtbl -> DomainFromMemberName(This,memberName,pDomainName)

#define IPassportManager2_get_ProfileByIndex(This,index,pVal)	\
    (This)->lpVtbl -> get_ProfileByIndex(This,index,pVal)

#define IPassportManager2_put_ProfileByIndex(This,index,newVal)	\
    (This)->lpVtbl -> put_ProfileByIndex(This,index,newVal)

#define IPassportManager2_OnStartPageManual(This,queryStringT,queryStringP,MSPAuthCookie,MSPProfCookie,MSPConsentCookie,vMSPSecCookie,pSetCookieArray)	\
    (This)->lpVtbl -> OnStartPageManual(This,queryStringT,queryStringP,MSPAuthCookie,MSPProfCookie,MSPConsentCookie,vMSPSecCookie,pSetCookieArray)

#define IPassportManager2_get_HasSavedPassword(This,pVal)	\
    (This)->lpVtbl -> get_HasSavedPassword(This,pVal)

#define IPassportManager2_Commit(This,pNewProfileCookieHeader)	\
    (This)->lpVtbl -> Commit(This,pNewProfileCookieHeader)

#define IPassportManager2_get_Profile(This,attributeName,pVal)	\
    (This)->lpVtbl -> get_Profile(This,attributeName,pVal)

#define IPassportManager2_put_Profile(This,attributeName,newVal)	\
    (This)->lpVtbl -> put_Profile(This,attributeName,newVal)

#define IPassportManager2_get_TicketTime(This,pVal)	\
    (This)->lpVtbl -> get_TicketTime(This,pVal)

#define IPassportManager2_get_SignInTime(This,pVal)	\
    (This)->lpVtbl -> get_SignInTime(This,pVal)

#define IPassportManager2_get_Domains(This,pArrayVal)	\
    (This)->lpVtbl -> get_Domains(This,pArrayVal)

#define IPassportManager2_get_Error(This,pErrorVal)	\
    (This)->lpVtbl -> get_Error(This,pErrorVal)

#define IPassportManager2_OnStartPageFilter(This,pPFC,pBufSize,pCookieHeader)	\
    (This)->lpVtbl -> OnStartPageFilter(This,pPFC,pBufSize,pCookieHeader)

#define IPassportManager2_OnStartPageASP(This,pdispRequest,pdispResponse)	\
    (This)->lpVtbl -> OnStartPageASP(This,pdispRequest,pdispResponse)

#define IPassportManager2_GetServerInfo(This,pbstrOut)	\
    (This)->lpVtbl -> GetServerInfo(This,pbstrOut)

#define IPassportManager2_HaveConsent(This,bNeedFullConsent,bNeedBirthdate,pbHaveConsent)	\
    (This)->lpVtbl -> HaveConsent(This,bNeedFullConsent,bNeedBirthdate,pbHaveConsent)


#define IPassportManager2_LoginUser(This,returnUrl,TimeWindow,ForceLogin,coBrandTemplate,lang_id,NameSpace,KPP,SecureLevel,ExtraParams)	\
    (This)->lpVtbl -> LoginUser(This,returnUrl,TimeWindow,ForceLogin,coBrandTemplate,lang_id,NameSpace,KPP,SecureLevel,ExtraParams)

#define IPassportManager2_AuthURL2(This,returnUrl,TimeWindow,ForceLogin,coBrandArgs,lang_id,NameSpace,KPP,SecureLevel,pAuthVal)	\
    (This)->lpVtbl -> AuthURL2(This,returnUrl,TimeWindow,ForceLogin,coBrandArgs,lang_id,NameSpace,KPP,SecureLevel,pAuthVal)

#define IPassportManager2_LogoTag2(This,returnUrl,TimeWindow,ForceLogin,coBrandArgs,lang_id,bSecure,NameSpace,KPP,SecureLevel,pVal)	\
    (This)->lpVtbl -> LogoTag2(This,returnUrl,TimeWindow,ForceLogin,coBrandArgs,lang_id,bSecure,NameSpace,KPP,SecureLevel,pVal)

#endif /* COBJMACROS */


#endif 	/* C style interface */



/* [helpstring][id] */ HRESULT STDMETHODCALLTYPE IPassportManager2_LoginUser_Proxy( 
    IPassportManager2 * This,
    /* [optional][in] */ VARIANT returnUrl,
    /* [optional][in] */ VARIANT TimeWindow,
    /* [optional][in] */ VARIANT ForceLogin,
    /* [optional][in] */ VARIANT coBrandTemplate,
    /* [optional][in] */ VARIANT lang_id,
    /* [optional][in] */ VARIANT NameSpace,
    /* [optional][in] */ VARIANT KPP,
    /* [optional][in] */ VARIANT SecureLevel,
    /* [optional][in] */ VARIANT ExtraParams);


void __RPC_STUB IPassportManager2_LoginUser_Stub(
    IRpcStubBuffer *This,
    IRpcChannelBuffer *_pRpcChannelBuffer,
    PRPC_MESSAGE _pRpcMessage,
    DWORD *_pdwStubPhase);


/* [helpstring][id] */ HRESULT STDMETHODCALLTYPE IPassportManager2_AuthURL2_Proxy( 
    IPassportManager2 * This,
    /* [optional][in] */ VARIANT returnUrl,
    /* [optional][in] */ VARIANT TimeWindow,
    /* [optional][in] */ VARIANT ForceLogin,
    /* [optional][in] */ VARIANT coBrandArgs,
    /* [optional][in] */ VARIANT lang_id,
    /* [optional][in] */ VARIANT NameSpace,
    /* [optional][in] */ VARIANT KPP,
    /* [optional][in] */ VARIANT SecureLevel,
    /* [retval][out] */ BSTR *pAuthVal);


void __RPC_STUB IPassportManager2_AuthURL2_Stub(
    IRpcStubBuffer *This,
    IRpcChannelBuffer *_pRpcChannelBuffer,
    PRPC_MESSAGE _pRpcMessage,
    DWORD *_pdwStubPhase);


/* [helpstring][id] */ HRESULT STDMETHODCALLTYPE IPassportManager2_LogoTag2_Proxy( 
    IPassportManager2 * This,
    /* [optional][in] */ VARIANT returnUrl,
    /* [optional][in] */ VARIANT TimeWindow,
    /* [optional][in] */ VARIANT ForceLogin,
    /* [optional][in] */ VARIANT coBrandArgs,
    /* [optional][in] */ VARIANT lang_id,
    /* [optional][in] */ VARIANT bSecure,
    /* [optional][in] */ VARIANT NameSpace,
    /* [optional][in] */ VARIANT KPP,
    /* [optional][in] */ VARIANT SecureLevel,
    /* [retval][out] */ BSTR *pVal);


void __RPC_STUB IPassportManager2_LogoTag2_Stub(
    IRpcStubBuffer *This,
    IRpcChannelBuffer *_pRpcChannelBuffer,
    PRPC_MESSAGE _pRpcMessage,
    DWORD *_pdwStubPhase);



#endif 	/* __IPassportManager2_INTERFACE_DEFINED__ */


#ifndef __IPassportManager3_INTERFACE_DEFINED__
#define __IPassportManager3_INTERFACE_DEFINED__

/* interface IPassportManager3 */
/* [unique][helpstring][dual][uuid][object] */ 


EXTERN_C const IID IID_IPassportManager3;

#if defined(__cplusplus) && !defined(CINTERFACE)
    
    MIDL_INTERFACE("1451151f-90a0-491b-b8e1-81a13767ed98")
    IPassportManager3 : public IPassportManager2
    {
    public:
        virtual /* [helpstring][id][propget] */ HRESULT STDMETHODCALLTYPE get_Ticket( 
            /* [in] */ BSTR attributeName,
            /* [retval][out] */ VARIANT *pVal) = 0;
        
        virtual /* [helpstring][id] */ HRESULT STDMETHODCALLTYPE GetCurrentConfig( 
            /* [in] */ BSTR name,
            /* [retval][out] */ VARIANT *pVal) = 0;
        
        virtual /* [helpstring][id] */ HRESULT STDMETHODCALLTYPE LogoutURL( 
            /* [optional][in] */ VARIANT returnUrl,
            /* [optional][in] */ VARIANT coBrandArgs,
            /* [optional][in] */ VARIANT lang_id,
            /* [optional][in] */ VARIANT domain,
            /* [optional][in] */ VARIANT bSecure,
            /* [retval][out] */ BSTR *pVal) = 0;
        
        virtual /* [helpstring][id] */ HRESULT STDMETHODCALLTYPE GetLoginChallenge( 
            /* [optional][in] */ VARIANT returnUrl,
            /* [optional][in] */ VARIANT TimeWindow,
            /* [optional][in] */ VARIANT ForceLogin,
            /* [optional][in] */ VARIANT coBrandTemplate,
            /* [optional][in] */ VARIANT lang_id,
            /* [optional][in] */ VARIANT NameSpace,
            /* [optional][in] */ VARIANT KPP,
            /* [optional][in] */ VARIANT SecureLevel,
            /* [optional][in] */ VARIANT ExtraParams,
            /* [retval][out] */ BSTR *pAuthHeader) = 0;
        
        virtual /* [helpstring][id][propget] */ HRESULT STDMETHODCALLTYPE get_HexPUID( 
            /* [retval][out] */ BSTR *pVal) = 0;
        
        virtual /* [helpstring][id] */ HRESULT STDMETHODCALLTYPE OnStartPageHTTPRaw( 
            /* [string][in] */ LPCSTR request_line,
            /* [string][in] */ LPCSTR headers,
            /* [in] */ DWORD flags,
            /* [out][in] */ DWORD *pRespHeadersSize,
            /* [size_is][out] */ LPSTR pRespHeaders) = 0;
        
        virtual /* [helpstring][id] */ HRESULT STDMETHODCALLTYPE ContinueStartPageHTTPRaw( 
            /* [in] */ DWORD bodyLen,
            /* [size_is][in] */ byte *body,
            /* [out][in] */ DWORD *pBufSize,
            /* [size_is][out] */ LPSTR pRespHeadersSize,
            /* [out][in] */ DWORD *pRespBodyLen,
            /* [size_is][out] */ byte *pRespBody) = 0;
        
        virtual /* [helpstring][id][propget] */ HRESULT STDMETHODCALLTYPE get_Option( 
            /* [in] */ BSTR name,
            /* [retval][out] */ VARIANT *pVal) = 0;
        
        virtual /* [helpstring][id][propput] */ HRESULT STDMETHODCALLTYPE put_Option( 
            /* [in] */ BSTR name,
            /* [in] */ VARIANT newVal) = 0;
        
    };
    
#else 	/* C style interface */

    typedef struct IPassportManager3Vtbl
    {
        BEGIN_INTERFACE
        
        HRESULT ( STDMETHODCALLTYPE *QueryInterface )( 
            IPassportManager3 * This,
            /* [in] */ REFIID riid,
            /* [iid_is][out] */ void **ppvObject);
        
        ULONG ( STDMETHODCALLTYPE *AddRef )( 
            IPassportManager3 * This);
        
        ULONG ( STDMETHODCALLTYPE *Release )( 
            IPassportManager3 * This);
        
        HRESULT ( STDMETHODCALLTYPE *GetTypeInfoCount )( 
            IPassportManager3 * This,
            /* [out] */ UINT *pctinfo);
        
        HRESULT ( STDMETHODCALLTYPE *GetTypeInfo )( 
            IPassportManager3 * This,
            /* [in] */ UINT iTInfo,
            /* [in] */ LCID lcid,
            /* [out] */ ITypeInfo **ppTInfo);
        
        HRESULT ( STDMETHODCALLTYPE *GetIDsOfNames )( 
            IPassportManager3 * This,
            /* [in] */ REFIID riid,
            /* [size_is][in] */ LPOLESTR *rgszNames,
            /* [in] */ UINT cNames,
            /* [in] */ LCID lcid,
            /* [size_is][out] */ DISPID *rgDispId);
        
        /* [local] */ HRESULT ( STDMETHODCALLTYPE *Invoke )( 
            IPassportManager3 * This,
            /* [in] */ DISPID dispIdMember,
            /* [in] */ REFIID riid,
            /* [in] */ LCID lcid,
            /* [in] */ WORD wFlags,
            /* [out][in] */ DISPPARAMS *pDispParams,
            /* [out] */ VARIANT *pVarResult,
            /* [out] */ EXCEPINFO *pExcepInfo,
            /* [out] */ UINT *puArgErr);
        
        HRESULT ( STDMETHODCALLTYPE *OnStartPage )( 
            IPassportManager3 * This,
            /* [in] */ IUnknown *piUnk);
        
        HRESULT ( STDMETHODCALLTYPE *OnEndPage )( 
            IPassportManager3 * This);
        
        HRESULT ( STDMETHODCALLTYPE *OnStartPageECB )( 
            IPassportManager3 * This,
            /* [in] */ BYTE *pECB,
            /* [out][in] */ DWORD *pBufSize,
            /* [size_is][out] */ LPSTR pCookieHeader);
        
        /* [hidden] */ HRESULT ( STDMETHODCALLTYPE *_Ticket )( 
            IPassportManager3 * This,
            /* [out] */ IPassportTicket **piTicket);
        
        /* [hidden] */ HRESULT ( STDMETHODCALLTYPE *_Profile )( 
            IPassportManager3 * This,
            /* [out] */ IPassportProfile **piProfile);
        
        /* [helpstring][id] */ HRESULT ( STDMETHODCALLTYPE *AuthURL )( 
            IPassportManager3 * This,
            /* [optional][in] */ VARIANT returnUrl,
            /* [optional][in] */ VARIANT TimeWindow,
            /* [optional][in] */ VARIANT ForceLogin,
            /* [optional][in] */ VARIANT coBrandArgs,
            /* [optional][in] */ VARIANT lang_id,
            /* [optional][in] */ VARIANT NameSpace,
            /* [optional][in] */ VARIANT KPP,
            /* [optional][in] */ VARIANT SecureLevel,
            /* [retval][out] */ BSTR *pAuthVal);
        
        /* [helpstring][id] */ HRESULT ( STDMETHODCALLTYPE *IsAuthenticated )( 
            IPassportManager3 * This,
            /* [optional][in] */ VARIANT TimeWindow,
            /* [optional][in] */ VARIANT ForceLogin,
            /* [optional][in] */ VARIANT SecureLevel,
            /* [retval][out] */ VARIANT_BOOL *pVal);
        
        /* [helpstring][id] */ HRESULT ( STDMETHODCALLTYPE *LogoTag )( 
            IPassportManager3 * This,
            /* [optional][in] */ VARIANT returnUrl,
            /* [optional][in] */ VARIANT TimeWindow,
            /* [optional][in] */ VARIANT ForceLogin,
            /* [optional][in] */ VARIANT coBrandArgs,
            /* [optional][in] */ VARIANT lang_id,
            /* [optional][in] */ VARIANT bSecure,
            /* [optional][in] */ VARIANT NameSpace,
            /* [optional][in] */ VARIANT KPP,
            /* [optional][in] */ VARIANT SecureLevel,
            /* [retval][out] */ BSTR *pVal);
        
        /* [helpstring][id] */ HRESULT ( STDMETHODCALLTYPE *HasProfile )( 
            IPassportManager3 * This,
            /* [optional][in] */ VARIANT ProfileName,
            /* [retval][out] */ VARIANT_BOOL *pVal);
        
        /* [helpstring][id][propget] */ HRESULT ( STDMETHODCALLTYPE *get_HasTicket )( 
            IPassportManager3 * This,
            /* [retval][out] */ VARIANT_BOOL *pVal);
        
        /* [helpstring][id][propget] */ HRESULT ( STDMETHODCALLTYPE *get_FromNetworkServer )( 
            IPassportManager3 * This,
            /* [retval][out] */ VARIANT_BOOL *pVal);
        
        /* [helpstring][id] */ HRESULT ( STDMETHODCALLTYPE *HasFlag )( 
            IPassportManager3 * This,
            /* [optional][in] */ VARIANT flagMask,
            /* [retval][out] */ VARIANT_BOOL *pVal);
        
        /* [helpstring][id][propget] */ HRESULT ( STDMETHODCALLTYPE *get_TicketAge )( 
            IPassportManager3 * This,
            /* [retval][out] */ int *pVal);
        
        /* [helpstring][id][propget] */ HRESULT ( STDMETHODCALLTYPE *get_TimeSinceSignIn )( 
            IPassportManager3 * This,
            /* [retval][out] */ int *pVal);
        
        /* [helpstring][id] */ HRESULT ( STDMETHODCALLTYPE *GetDomainAttribute )( 
            IPassportManager3 * This,
            /* [in] */ BSTR attributeName,
            /* [optional][in] */ VARIANT lcid,
            /* [optional][in] */ VARIANT domain,
            /* [retval][out] */ BSTR *pAttrVal);
        
        /* [helpstring][id] */ HRESULT ( STDMETHODCALLTYPE *DomainFromMemberName )( 
            IPassportManager3 * This,
            /* [optional][in] */ VARIANT memberName,
            /* [retval][out] */ BSTR *pDomainName);
        
        /* [helpstring][id][propget] */ HRESULT ( STDMETHODCALLTYPE *get_ProfileByIndex )( 
            IPassportManager3 * This,
            /* [in] */ int index,
            /* [retval][out] */ VARIANT *pVal);
        
        /* [helpstring][id][propput] */ HRESULT ( STDMETHODCALLTYPE *put_ProfileByIndex )( 
            IPassportManager3 * This,
            /* [in] */ int index,
            /* [in] */ VARIANT newVal);
        
        /* [helpstring][id] */ HRESULT ( STDMETHODCALLTYPE *OnStartPageManual )( 
            IPassportManager3 * This,
            /* [in] */ BSTR queryStringT,
            /* [in] */ BSTR queryStringP,
            /* [in] */ BSTR MSPAuthCookie,
            /* [in] */ BSTR MSPProfCookie,
            /* [in] */ BSTR MSPConsentCookie,
            /* [optional][in] */ VARIANT vMSPSecCookie,
            /* [retval][out] */ VARIANT *pSetCookieArray);
        
        /* [helpstring][id][propget] */ HRESULT ( STDMETHODCALLTYPE *get_HasSavedPassword )( 
            IPassportManager3 * This,
            /* [retval][out] */ VARIANT_BOOL *pVal);
        
        /* [helpstring][id] */ HRESULT ( STDMETHODCALLTYPE *Commit )( 
            IPassportManager3 * This,
            /* [retval][out] */ BSTR *pNewProfileCookieHeader);
        
        /* [helpstring][id][propget] */ HRESULT ( STDMETHODCALLTYPE *get_Profile )( 
            IPassportManager3 * This,
            /* [in] */ BSTR attributeName,
            /* [retval][out] */ VARIANT *pVal);
        
        /* [helpstring][id][propput] */ HRESULT ( STDMETHODCALLTYPE *put_Profile )( 
            IPassportManager3 * This,
            /* [in] */ BSTR attributeName,
            /* [in] */ VARIANT newVal);
        
        /* [helpstring][id][propget][hidden] */ HRESULT ( STDMETHODCALLTYPE *get_TicketTime )( 
            IPassportManager3 * This,
            /* [retval][out] */ long *pVal);
        
        /* [helpstring][id][propget][hidden] */ HRESULT ( STDMETHODCALLTYPE *get_SignInTime )( 
            IPassportManager3 * This,
            /* [retval][out] */ long *pVal);
        
        /* [helpstring][id][propget][hidden] */ HRESULT ( STDMETHODCALLTYPE *get_Domains )( 
            IPassportManager3 * This,
            /* [retval][out] */ VARIANT *pArrayVal);
        
        /* [helpstring][id][propget] */ HRESULT ( STDMETHODCALLTYPE *get_Error )( 
            IPassportManager3 * This,
            /* [retval][out] */ long *pErrorVal);
        
        /* [helpstring][hidden] */ HRESULT ( STDMETHODCALLTYPE *OnStartPageFilter )( 
            IPassportManager3 * This,
            /* [in] */ BYTE *pPFC,
            /* [out][in] */ DWORD *pBufSize,
            /* [size_is][out] */ LPSTR pCookieHeader);
        
        /* [helpstring][id] */ HRESULT ( STDMETHODCALLTYPE *OnStartPageASP )( 
            IPassportManager3 * This,
            /* [in] */ IDispatch *pdispRequest,
            /* [in] */ IDispatch *pdispResponse);
        
        /* [helpstring][id][hidden] */ HRESULT ( STDMETHODCALLTYPE *GetServerInfo )( 
            IPassportManager3 * This,
            /* [retval][out] */ BSTR *pbstrOut);
        
        /* [helpstring][id] */ HRESULT ( STDMETHODCALLTYPE *HaveConsent )( 
            IPassportManager3 * This,
            /* [in] */ VARIANT_BOOL bNeedFullConsent,
            /* [in] */ VARIANT_BOOL bNeedBirthdate,
            /* [retval][out] */ VARIANT_BOOL *pbHaveConsent);
        
        /* [helpstring][id] */ HRESULT ( STDMETHODCALLTYPE *LoginUser )( 
            IPassportManager3 * This,
            /* [optional][in] */ VARIANT returnUrl,
            /* [optional][in] */ VARIANT TimeWindow,
            /* [optional][in] */ VARIANT ForceLogin,
            /* [optional][in] */ VARIANT coBrandTemplate,
            /* [optional][in] */ VARIANT lang_id,
            /* [optional][in] */ VARIANT NameSpace,
            /* [optional][in] */ VARIANT KPP,
            /* [optional][in] */ VARIANT SecureLevel,
            /* [optional][in] */ VARIANT ExtraParams);
        
        /* [helpstring][id] */ HRESULT ( STDMETHODCALLTYPE *AuthURL2 )( 
            IPassportManager3 * This,
            /* [optional][in] */ VARIANT returnUrl,
            /* [optional][in] */ VARIANT TimeWindow,
            /* [optional][in] */ VARIANT ForceLogin,
            /* [optional][in] */ VARIANT coBrandArgs,
            /* [optional][in] */ VARIANT lang_id,
            /* [optional][in] */ VARIANT NameSpace,
            /* [optional][in] */ VARIANT KPP,
            /* [optional][in] */ VARIANT SecureLevel,
            /* [retval][out] */ BSTR *pAuthVal);
        
        /* [helpstring][id] */ HRESULT ( STDMETHODCALLTYPE *LogoTag2 )( 
            IPassportManager3 * This,
            /* [optional][in] */ VARIANT returnUrl,
            /* [optional][in] */ VARIANT TimeWindow,
            /* [optional][in] */ VARIANT ForceLogin,
            /* [optional][in] */ VARIANT coBrandArgs,
            /* [optional][in] */ VARIANT lang_id,
            /* [optional][in] */ VARIANT bSecure,
            /* [optional][in] */ VARIANT NameSpace,
            /* [optional][in] */ VARIANT KPP,
            /* [optional][in] */ VARIANT SecureLevel,
            /* [retval][out] */ BSTR *pVal);
        
        /* [helpstring][id][propget] */ HRESULT ( STDMETHODCALLTYPE *get_Ticket )( 
            IPassportManager3 * This,
            /* [in] */ BSTR attributeName,
            /* [retval][out] */ VARIANT *pVal);
        
        /* [helpstring][id] */ HRESULT ( STDMETHODCALLTYPE *GetCurrentConfig )( 
            IPassportManager3 * This,
            /* [in] */ BSTR name,
            /* [retval][out] */ VARIANT *pVal);
        
        /* [helpstring][id] */ HRESULT ( STDMETHODCALLTYPE *LogoutURL )( 
            IPassportManager3 * This,
            /* [optional][in] */ VARIANT returnUrl,
            /* [optional][in] */ VARIANT coBrandArgs,
            /* [optional][in] */ VARIANT lang_id,
            /* [optional][in] */ VARIANT domain,
            /* [optional][in] */ VARIANT bSecure,
            /* [retval][out] */ BSTR *pVal);
        
        /* [helpstring][id] */ HRESULT ( STDMETHODCALLTYPE *GetLoginChallenge )( 
            IPassportManager3 * This,
            /* [optional][in] */ VARIANT returnUrl,
            /* [optional][in] */ VARIANT TimeWindow,
            /* [optional][in] */ VARIANT ForceLogin,
            /* [optional][in] */ VARIANT coBrandTemplate,
            /* [optional][in] */ VARIANT lang_id,
            /* [optional][in] */ VARIANT NameSpace,
            /* [optional][in] */ VARIANT KPP,
            /* [optional][in] */ VARIANT SecureLevel,
            /* [optional][in] */ VARIANT ExtraParams,
            /* [retval][out] */ BSTR *pAuthHeader);
        
        /* [helpstring][id][propget] */ HRESULT ( STDMETHODCALLTYPE *get_HexPUID )( 
            IPassportManager3 * This,
            /* [retval][out] */ BSTR *pVal);
        
        /* [helpstring][id] */ HRESULT ( STDMETHODCALLTYPE *OnStartPageHTTPRaw )( 
            IPassportManager3 * This,
            /* [string][in] */ LPCSTR request_line,
            /* [string][in] */ LPCSTR headers,
            /* [in] */ DWORD flags,
            /* [out][in] */ DWORD *pRespHeadersSize,
            /* [size_is][out] */ LPSTR pRespHeaders);
        
        /* [helpstring][id] */ HRESULT ( STDMETHODCALLTYPE *ContinueStartPageHTTPRaw )( 
            IPassportManager3 * This,
            /* [in] */ DWORD bodyLen,
            /* [size_is][in] */ byte *body,
            /* [out][in] */ DWORD *pBufSize,
            /* [size_is][out] */ LPSTR pRespHeadersSize,
            /* [out][in] */ DWORD *pRespBodyLen,
            /* [size_is][out] */ byte *pRespBody);
        
        /* [helpstring][id][propget] */ HRESULT ( STDMETHODCALLTYPE *get_Option )( 
            IPassportManager3 * This,
            /* [in] */ BSTR name,
            /* [retval][out] */ VARIANT *pVal);
        
        /* [helpstring][id][propput] */ HRESULT ( STDMETHODCALLTYPE *put_Option )( 
            IPassportManager3 * This,
            /* [in] */ BSTR name,
            /* [in] */ VARIANT newVal);
        
        END_INTERFACE
    } IPassportManager3Vtbl;

    interface IPassportManager3
    {
        CONST_VTBL struct IPassportManager3Vtbl *lpVtbl;
    };

    

#ifdef COBJMACROS


#define IPassportManager3_QueryInterface(This,riid,ppvObject)	\
    (This)->lpVtbl -> QueryInterface(This,riid,ppvObject)

#define IPassportManager3_AddRef(This)	\
    (This)->lpVtbl -> AddRef(This)

#define IPassportManager3_Release(This)	\
    (This)->lpVtbl -> Release(This)


#define IPassportManager3_GetTypeInfoCount(This,pctinfo)	\
    (This)->lpVtbl -> GetTypeInfoCount(This,pctinfo)

#define IPassportManager3_GetTypeInfo(This,iTInfo,lcid,ppTInfo)	\
    (This)->lpVtbl -> GetTypeInfo(This,iTInfo,lcid,ppTInfo)

#define IPassportManager3_GetIDsOfNames(This,riid,rgszNames,cNames,lcid,rgDispId)	\
    (This)->lpVtbl -> GetIDsOfNames(This,riid,rgszNames,cNames,lcid,rgDispId)

#define IPassportManager3_Invoke(This,dispIdMember,riid,lcid,wFlags,pDispParams,pVarResult,pExcepInfo,puArgErr)	\
    (This)->lpVtbl -> Invoke(This,dispIdMember,riid,lcid,wFlags,pDispParams,pVarResult,pExcepInfo,puArgErr)


#define IPassportManager3_OnStartPage(This,piUnk)	\
    (This)->lpVtbl -> OnStartPage(This,piUnk)

#define IPassportManager3_OnEndPage(This)	\
    (This)->lpVtbl -> OnEndPage(This)

#define IPassportManager3_OnStartPageECB(This,pECB,pBufSize,pCookieHeader)	\
    (This)->lpVtbl -> OnStartPageECB(This,pECB,pBufSize,pCookieHeader)

#define IPassportManager3__Ticket(This,piTicket)	\
    (This)->lpVtbl -> _Ticket(This,piTicket)

#define IPassportManager3__Profile(This,piProfile)	\
    (This)->lpVtbl -> _Profile(This,piProfile)

#define IPassportManager3_AuthURL(This,returnUrl,TimeWindow,ForceLogin,coBrandArgs,lang_id,NameSpace,KPP,SecureLevel,pAuthVal)	\
    (This)->lpVtbl -> AuthURL(This,returnUrl,TimeWindow,ForceLogin,coBrandArgs,lang_id,NameSpace,KPP,SecureLevel,pAuthVal)

#define IPassportManager3_IsAuthenticated(This,TimeWindow,ForceLogin,SecureLevel,pVal)	\
    (This)->lpVtbl -> IsAuthenticated(This,TimeWindow,ForceLogin,SecureLevel,pVal)

#define IPassportManager3_LogoTag(This,returnUrl,TimeWindow,ForceLogin,coBrandArgs,lang_id,bSecure,NameSpace,KPP,SecureLevel,pVal)	\
    (This)->lpVtbl -> LogoTag(This,returnUrl,TimeWindow,ForceLogin,coBrandArgs,lang_id,bSecure,NameSpace,KPP,SecureLevel,pVal)

#define IPassportManager3_HasProfile(This,ProfileName,pVal)	\
    (This)->lpVtbl -> HasProfile(This,ProfileName,pVal)

#define IPassportManager3_get_HasTicket(This,pVal)	\
    (This)->lpVtbl -> get_HasTicket(This,pVal)

#define IPassportManager3_get_FromNetworkServer(This,pVal)	\
    (This)->lpVtbl -> get_FromNetworkServer(This,pVal)

#define IPassportManager3_HasFlag(This,flagMask,pVal)	\
    (This)->lpVtbl -> HasFlag(This,flagMask,pVal)

#define IPassportManager3_get_TicketAge(This,pVal)	\
    (This)->lpVtbl -> get_TicketAge(This,pVal)

#define IPassportManager3_get_TimeSinceSignIn(This,pVal)	\
    (This)->lpVtbl -> get_TimeSinceSignIn(This,pVal)

#define IPassportManager3_GetDomainAttribute(This,attributeName,lcid,domain,pAttrVal)	\
    (This)->lpVtbl -> GetDomainAttribute(This,attributeName,lcid,domain,pAttrVal)

#define IPassportManager3_DomainFromMemberName(This,memberName,pDomainName)	\
    (This)->lpVtbl -> DomainFromMemberName(This,memberName,pDomainName)

#define IPassportManager3_get_ProfileByIndex(This,index,pVal)	\
    (This)->lpVtbl -> get_ProfileByIndex(This,index,pVal)

#define IPassportManager3_put_ProfileByIndex(This,index,newVal)	\
    (This)->lpVtbl -> put_ProfileByIndex(This,index,newVal)

#define IPassportManager3_OnStartPageManual(This,queryStringT,queryStringP,MSPAuthCookie,MSPProfCookie,MSPConsentCookie,vMSPSecCookie,pSetCookieArray)	\
    (This)->lpVtbl -> OnStartPageManual(This,queryStringT,queryStringP,MSPAuthCookie,MSPProfCookie,MSPConsentCookie,vMSPSecCookie,pSetCookieArray)

#define IPassportManager3_get_HasSavedPassword(This,pVal)	\
    (This)->lpVtbl -> get_HasSavedPassword(This,pVal)

#define IPassportManager3_Commit(This,pNewProfileCookieHeader)	\
    (This)->lpVtbl -> Commit(This,pNewProfileCookieHeader)

#define IPassportManager3_get_Profile(This,attributeName,pVal)	\
    (This)->lpVtbl -> get_Profile(This,attributeName,pVal)

#define IPassportManager3_put_Profile(This,attributeName,newVal)	\
    (This)->lpVtbl -> put_Profile(This,attributeName,newVal)

#define IPassportManager3_get_TicketTime(This,pVal)	\
    (This)->lpVtbl -> get_TicketTime(This,pVal)

#define IPassportManager3_get_SignInTime(This,pVal)	\
    (This)->lpVtbl -> get_SignInTime(This,pVal)

#define IPassportManager3_get_Domains(This,pArrayVal)	\
    (This)->lpVtbl -> get_Domains(This,pArrayVal)

#define IPassportManager3_get_Error(This,pErrorVal)	\
    (This)->lpVtbl -> get_Error(This,pErrorVal)

#define IPassportManager3_OnStartPageFilter(This,pPFC,pBufSize,pCookieHeader)	\
    (This)->lpVtbl -> OnStartPageFilter(This,pPFC,pBufSize,pCookieHeader)

#define IPassportManager3_OnStartPageASP(This,pdispRequest,pdispResponse)	\
    (This)->lpVtbl -> OnStartPageASP(This,pdispRequest,pdispResponse)

#define IPassportManager3_GetServerInfo(This,pbstrOut)	\
    (This)->lpVtbl -> GetServerInfo(This,pbstrOut)

#define IPassportManager3_HaveConsent(This,bNeedFullConsent,bNeedBirthdate,pbHaveConsent)	\
    (This)->lpVtbl -> HaveConsent(This,bNeedFullConsent,bNeedBirthdate,pbHaveConsent)


#define IPassportManager3_LoginUser(This,returnUrl,TimeWindow,ForceLogin,coBrandTemplate,lang_id,NameSpace,KPP,SecureLevel,ExtraParams)	\
    (This)->lpVtbl -> LoginUser(This,returnUrl,TimeWindow,ForceLogin,coBrandTemplate,lang_id,NameSpace,KPP,SecureLevel,ExtraParams)

#define IPassportManager3_AuthURL2(This,returnUrl,TimeWindow,ForceLogin,coBrandArgs,lang_id,NameSpace,KPP,SecureLevel,pAuthVal)	\
    (This)->lpVtbl -> AuthURL2(This,returnUrl,TimeWindow,ForceLogin,coBrandArgs,lang_id,NameSpace,KPP,SecureLevel,pAuthVal)

#define IPassportManager3_LogoTag2(This,returnUrl,TimeWindow,ForceLogin,coBrandArgs,lang_id,bSecure,NameSpace,KPP,SecureLevel,pVal)	\
    (This)->lpVtbl -> LogoTag2(This,returnUrl,TimeWindow,ForceLogin,coBrandArgs,lang_id,bSecure,NameSpace,KPP,SecureLevel,pVal)


#define IPassportManager3_get_Ticket(This,attributeName,pVal)	\
    (This)->lpVtbl -> get_Ticket(This,attributeName,pVal)

#define IPassportManager3_GetCurrentConfig(This,name,pVal)	\
    (This)->lpVtbl -> GetCurrentConfig(This,name,pVal)

#define IPassportManager3_LogoutURL(This,returnUrl,coBrandArgs,lang_id,domain,bSecure,pVal)	\
    (This)->lpVtbl -> LogoutURL(This,returnUrl,coBrandArgs,lang_id,domain,bSecure,pVal)

#define IPassportManager3_GetLoginChallenge(This,returnUrl,TimeWindow,ForceLogin,coBrandTemplate,lang_id,NameSpace,KPP,SecureLevel,ExtraParams,pAuthHeader)	\
    (This)->lpVtbl -> GetLoginChallenge(This,returnUrl,TimeWindow,ForceLogin,coBrandTemplate,lang_id,NameSpace,KPP,SecureLevel,ExtraParams,pAuthHeader)

#define IPassportManager3_get_HexPUID(This,pVal)	\
    (This)->lpVtbl -> get_HexPUID(This,pVal)

#define IPassportManager3_OnStartPageHTTPRaw(This,request_line,headers,flags,pRespHeadersSize,pRespHeaders)	\
    (This)->lpVtbl -> OnStartPageHTTPRaw(This,request_line,headers,flags,pRespHeadersSize,pRespHeaders)

#define IPassportManager3_ContinueStartPageHTTPRaw(This,bodyLen,body,pBufSize,pRespHeadersSize,pRespBodyLen,pRespBody)	\
    (This)->lpVtbl -> ContinueStartPageHTTPRaw(This,bodyLen,body,pBufSize,pRespHeadersSize,pRespBodyLen,pRespBody)

#define IPassportManager3_get_Option(This,name,pVal)	\
    (This)->lpVtbl -> get_Option(This,name,pVal)

#define IPassportManager3_put_Option(This,name,newVal)	\
    (This)->lpVtbl -> put_Option(This,name,newVal)

#endif /* COBJMACROS */


#endif 	/* C style interface */



/* [helpstring][id][propget] */ HRESULT STDMETHODCALLTYPE IPassportManager3_get_Ticket_Proxy( 
    IPassportManager3 * This,
    /* [in] */ BSTR attributeName,
    /* [retval][out] */ VARIANT *pVal);


void __RPC_STUB IPassportManager3_get_Ticket_Stub(
    IRpcStubBuffer *This,
    IRpcChannelBuffer *_pRpcChannelBuffer,
    PRPC_MESSAGE _pRpcMessage,
    DWORD *_pdwStubPhase);


/* [helpstring][id] */ HRESULT STDMETHODCALLTYPE IPassportManager3_GetCurrentConfig_Proxy( 
    IPassportManager3 * This,
    /* [in] */ BSTR name,
    /* [retval][out] */ VARIANT *pVal);


void __RPC_STUB IPassportManager3_GetCurrentConfig_Stub(
    IRpcStubBuffer *This,
    IRpcChannelBuffer *_pRpcChannelBuffer,
    PRPC_MESSAGE _pRpcMessage,
    DWORD *_pdwStubPhase);


/* [helpstring][id] */ HRESULT STDMETHODCALLTYPE IPassportManager3_LogoutURL_Proxy( 
    IPassportManager3 * This,
    /* [optional][in] */ VARIANT returnUrl,
    /* [optional][in] */ VARIANT coBrandArgs,
    /* [optional][in] */ VARIANT lang_id,
    /* [optional][in] */ VARIANT domain,
    /* [optional][in] */ VARIANT bSecure,
    /* [retval][out] */ BSTR *pVal);


void __RPC_STUB IPassportManager3_LogoutURL_Stub(
    IRpcStubBuffer *This,
    IRpcChannelBuffer *_pRpcChannelBuffer,
    PRPC_MESSAGE _pRpcMessage,
    DWORD *_pdwStubPhase);


/* [helpstring][id] */ HRESULT STDMETHODCALLTYPE IPassportManager3_GetLoginChallenge_Proxy( 
    IPassportManager3 * This,
    /* [optional][in] */ VARIANT returnUrl,
    /* [optional][in] */ VARIANT TimeWindow,
    /* [optional][in] */ VARIANT ForceLogin,
    /* [optional][in] */ VARIANT coBrandTemplate,
    /* [optional][in] */ VARIANT lang_id,
    /* [optional][in] */ VARIANT NameSpace,
    /* [optional][in] */ VARIANT KPP,
    /* [optional][in] */ VARIANT SecureLevel,
    /* [optional][in] */ VARIANT ExtraParams,
    /* [retval][out] */ BSTR *pAuthHeader);


void __RPC_STUB IPassportManager3_GetLoginChallenge_Stub(
    IRpcStubBuffer *This,
    IRpcChannelBuffer *_pRpcChannelBuffer,
    PRPC_MESSAGE _pRpcMessage,
    DWORD *_pdwStubPhase);


/* [helpstring][id][propget] */ HRESULT STDMETHODCALLTYPE IPassportManager3_get_HexPUID_Proxy( 
    IPassportManager3 * This,
    /* [retval][out] */ BSTR *pVal);


void __RPC_STUB IPassportManager3_get_HexPUID_Stub(
    IRpcStubBuffer *This,
    IRpcChannelBuffer *_pRpcChannelBuffer,
    PRPC_MESSAGE _pRpcMessage,
    DWORD *_pdwStubPhase);


/* [helpstring][id] */ HRESULT STDMETHODCALLTYPE IPassportManager3_OnStartPageHTTPRaw_Proxy( 
    IPassportManager3 * This,
    /* [string][in] */ LPCSTR request_line,
    /* [string][in] */ LPCSTR headers,
    /* [in] */ DWORD flags,
    /* [out][in] */ DWORD *pRespHeadersSize,
    /* [size_is][out] */ LPSTR pRespHeaders);


void __RPC_STUB IPassportManager3_OnStartPageHTTPRaw_Stub(
    IRpcStubBuffer *This,
    IRpcChannelBuffer *_pRpcChannelBuffer,
    PRPC_MESSAGE _pRpcMessage,
    DWORD *_pdwStubPhase);


/* [helpstring][id] */ HRESULT STDMETHODCALLTYPE IPassportManager3_ContinueStartPageHTTPRaw_Proxy( 
    IPassportManager3 * This,
    /* [in] */ DWORD bodyLen,
    /* [size_is][in] */ byte *body,
    /* [out][in] */ DWORD *pBufSize,
    /* [size_is][out] */ LPSTR pRespHeadersSize,
    /* [out][in] */ DWORD *pRespBodyLen,
    /* [size_is][out] */ byte *pRespBody);


void __RPC_STUB IPassportManager3_ContinueStartPageHTTPRaw_Stub(
    IRpcStubBuffer *This,
    IRpcChannelBuffer *_pRpcChannelBuffer,
    PRPC_MESSAGE _pRpcMessage,
    DWORD *_pdwStubPhase);


/* [helpstring][id][propget] */ HRESULT STDMETHODCALLTYPE IPassportManager3_get_Option_Proxy( 
    IPassportManager3 * This,
    /* [in] */ BSTR name,
    /* [retval][out] */ VARIANT *pVal);


void __RPC_STUB IPassportManager3_get_Option_Stub(
    IRpcStubBuffer *This,
    IRpcChannelBuffer *_pRpcChannelBuffer,
    PRPC_MESSAGE _pRpcMessage,
    DWORD *_pdwStubPhase);


/* [helpstring][id][propput] */ HRESULT STDMETHODCALLTYPE IPassportManager3_put_Option_Proxy( 
    IPassportManager3 * This,
    /* [in] */ BSTR name,
    /* [in] */ VARIANT newVal);


void __RPC_STUB IPassportManager3_put_Option_Stub(
    IRpcStubBuffer *This,
    IRpcChannelBuffer *_pRpcChannelBuffer,
    PRPC_MESSAGE _pRpcMessage,
    DWORD *_pdwStubPhase);



#endif 	/* __IPassportManager3_INTERFACE_DEFINED__ */


#ifndef __IPassportCrypt_INTERFACE_DEFINED__
#define __IPassportCrypt_INTERFACE_DEFINED__

/* interface IPassportCrypt */
/* [unique][helpstring][dual][uuid][object] */ 


EXTERN_C const IID IID_IPassportCrypt;

#if defined(__cplusplus) && !defined(CINTERFACE)
    
    MIDL_INTERFACE("41651BF9-A5C8-11D2-95DF-00C04F8E7A70")
    IPassportCrypt : public IDispatch
    {
    public:
        virtual /* [helpstring][id] */ HRESULT STDMETHODCALLTYPE Encrypt( 
            /* [in] */ BSTR rawData,
            /* [retval][out] */ BSTR *pEncrypted) = 0;
        
        virtual /* [helpstring][id] */ HRESULT STDMETHODCALLTYPE Decrypt( 
            /* [in] */ BSTR rawData,
            /* [retval][out] */ BSTR *pUnencrypted) = 0;
        
        virtual /* [helpstring][id][propget][hidden] */ HRESULT STDMETHODCALLTYPE get_keyVersion( 
            /* [retval][out] */ int *pVal) = 0;
        
        virtual /* [helpstring][id][propput][hidden] */ HRESULT STDMETHODCALLTYPE put_keyVersion( 
            /* [in] */ int newVal) = 0;
        
        virtual /* [helpstring][id][propget] */ HRESULT STDMETHODCALLTYPE get_IsValid( 
            /* [retval][out] */ VARIANT_BOOL *pVal) = 0;
        
        virtual /* [helpstring][id][propput][hidden] */ HRESULT STDMETHODCALLTYPE put_keyMaterial( 
            /* [in] */ BSTR newVal) = 0;
        
        virtual /* [helpstring][id] */ HRESULT STDMETHODCALLTYPE Compress( 
            /* [in] */ BSTR bstrIn,
            /* [retval][out] */ BSTR *pbstrOut) = 0;
        
        virtual /* [helpstring][id] */ HRESULT STDMETHODCALLTYPE Decompress( 
            /* [in] */ BSTR bstrIn,
            /* [retval][out] */ BSTR *pbstrOut) = 0;
        
        virtual /* [helpstring][propput][id] */ HRESULT STDMETHODCALLTYPE put_site( 
            /* [in] */ BSTR bstrSiteName) = 0;
        
        virtual /* [helpstring][id] */ HRESULT STDMETHODCALLTYPE OnStartPage( 
            /* [in] */ IUnknown *piUnk) = 0;
        
        virtual /* [helpstring][propput][id] */ HRESULT STDMETHODCALLTYPE put_host( 
            /* [in] */ BSTR bstrHostName) = 0;
        
    };
    
#else 	/* C style interface */

    typedef struct IPassportCryptVtbl
    {
        BEGIN_INTERFACE
        
        HRESULT ( STDMETHODCALLTYPE *QueryInterface )( 
            IPassportCrypt * This,
            /* [in] */ REFIID riid,
            /* [iid_is][out] */ void **ppvObject);
        
        ULONG ( STDMETHODCALLTYPE *AddRef )( 
            IPassportCrypt * This);
        
        ULONG ( STDMETHODCALLTYPE *Release )( 
            IPassportCrypt * This);
        
        HRESULT ( STDMETHODCALLTYPE *GetTypeInfoCount )( 
            IPassportCrypt * This,
            /* [out] */ UINT *pctinfo);
        
        HRESULT ( STDMETHODCALLTYPE *GetTypeInfo )( 
            IPassportCrypt * This,
            /* [in] */ UINT iTInfo,
            /* [in] */ LCID lcid,
            /* [out] */ ITypeInfo **ppTInfo);
        
        HRESULT ( STDMETHODCALLTYPE *GetIDsOfNames )( 
            IPassportCrypt * This,
            /* [in] */ REFIID riid,
            /* [size_is][in] */ LPOLESTR *rgszNames,
            /* [in] */ UINT cNames,
            /* [in] */ LCID lcid,
            /* [size_is][out] */ DISPID *rgDispId);
        
        /* [local] */ HRESULT ( STDMETHODCALLTYPE *Invoke )( 
            IPassportCrypt * This,
            /* [in] */ DISPID dispIdMember,
            /* [in] */ REFIID riid,
            /* [in] */ LCID lcid,
            /* [in] */ WORD wFlags,
            /* [out][in] */ DISPPARAMS *pDispParams,
            /* [out] */ VARIANT *pVarResult,
            /* [out] */ EXCEPINFO *pExcepInfo,
            /* [out] */ UINT *puArgErr);
        
        /* [helpstring][id] */ HRESULT ( STDMETHODCALLTYPE *Encrypt )( 
            IPassportCrypt * This,
            /* [in] */ BSTR rawData,
            /* [retval][out] */ BSTR *pEncrypted);
        
        /* [helpstring][id] */ HRESULT ( STDMETHODCALLTYPE *Decrypt )( 
            IPassportCrypt * This,
            /* [in] */ BSTR rawData,
            /* [retval][out] */ BSTR *pUnencrypted);
        
        /* [helpstring][id][propget][hidden] */ HRESULT ( STDMETHODCALLTYPE *get_keyVersion )( 
            IPassportCrypt * This,
            /* [retval][out] */ int *pVal);
        
        /* [helpstring][id][propput][hidden] */ HRESULT ( STDMETHODCALLTYPE *put_keyVersion )( 
            IPassportCrypt * This,
            /* [in] */ int newVal);
        
        /* [helpstring][id][propget] */ HRESULT ( STDMETHODCALLTYPE *get_IsValid )( 
            IPassportCrypt * This,
            /* [retval][out] */ VARIANT_BOOL *pVal);
        
        /* [helpstring][id][propput][hidden] */ HRESULT ( STDMETHODCALLTYPE *put_keyMaterial )( 
            IPassportCrypt * This,
            /* [in] */ BSTR newVal);
        
        /* [helpstring][id] */ HRESULT ( STDMETHODCALLTYPE *Compress )( 
            IPassportCrypt * This,
            /* [in] */ BSTR bstrIn,
            /* [retval][out] */ BSTR *pbstrOut);
        
        /* [helpstring][id] */ HRESULT ( STDMETHODCALLTYPE *Decompress )( 
            IPassportCrypt * This,
            /* [in] */ BSTR bstrIn,
            /* [retval][out] */ BSTR *pbstrOut);
        
        /* [helpstring][propput][id] */ HRESULT ( STDMETHODCALLTYPE *put_site )( 
            IPassportCrypt * This,
            /* [in] */ BSTR bstrSiteName);
        
        /* [helpstring][id] */ HRESULT ( STDMETHODCALLTYPE *OnStartPage )( 
            IPassportCrypt * This,
            /* [in] */ IUnknown *piUnk);
        
        /* [helpstring][propput][id] */ HRESULT ( STDMETHODCALLTYPE *put_host )( 
            IPassportCrypt * This,
            /* [in] */ BSTR bstrHostName);
        
        END_INTERFACE
    } IPassportCryptVtbl;

    interface IPassportCrypt
    {
        CONST_VTBL struct IPassportCryptVtbl *lpVtbl;
    };

    

#ifdef COBJMACROS


#define IPassportCrypt_QueryInterface(This,riid,ppvObject)	\
    (This)->lpVtbl -> QueryInterface(This,riid,ppvObject)

#define IPassportCrypt_AddRef(This)	\
    (This)->lpVtbl -> AddRef(This)

#define IPassportCrypt_Release(This)	\
    (This)->lpVtbl -> Release(This)


#define IPassportCrypt_GetTypeInfoCount(This,pctinfo)	\
    (This)->lpVtbl -> GetTypeInfoCount(This,pctinfo)

#define IPassportCrypt_GetTypeInfo(This,iTInfo,lcid,ppTInfo)	\
    (This)->lpVtbl -> GetTypeInfo(This,iTInfo,lcid,ppTInfo)

#define IPassportCrypt_GetIDsOfNames(This,riid,rgszNames,cNames,lcid,rgDispId)	\
    (This)->lpVtbl -> GetIDsOfNames(This,riid,rgszNames,cNames,lcid,rgDispId)

#define IPassportCrypt_Invoke(This,dispIdMember,riid,lcid,wFlags,pDispParams,pVarResult,pExcepInfo,puArgErr)	\
    (This)->lpVtbl -> Invoke(This,dispIdMember,riid,lcid,wFlags,pDispParams,pVarResult,pExcepInfo,puArgErr)


#define IPassportCrypt_Encrypt(This,rawData,pEncrypted)	\
    (This)->lpVtbl -> Encrypt(This,rawData,pEncrypted)

#define IPassportCrypt_Decrypt(This,rawData,pUnencrypted)	\
    (This)->lpVtbl -> Decrypt(This,rawData,pUnencrypted)

#define IPassportCrypt_get_keyVersion(This,pVal)	\
    (This)->lpVtbl -> get_keyVersion(This,pVal)

#define IPassportCrypt_put_keyVersion(This,newVal)	\
    (This)->lpVtbl -> put_keyVersion(This,newVal)

#define IPassportCrypt_get_IsValid(This,pVal)	\
    (This)->lpVtbl -> get_IsValid(This,pVal)

#define IPassportCrypt_put_keyMaterial(This,newVal)	\
    (This)->lpVtbl -> put_keyMaterial(This,newVal)

#define IPassportCrypt_Compress(This,bstrIn,pbstrOut)	\
    (This)->lpVtbl -> Compress(This,bstrIn,pbstrOut)

#define IPassportCrypt_Decompress(This,bstrIn,pbstrOut)	\
    (This)->lpVtbl -> Decompress(This,bstrIn,pbstrOut)

#define IPassportCrypt_put_site(This,bstrSiteName)	\
    (This)->lpVtbl -> put_site(This,bstrSiteName)

#define IPassportCrypt_OnStartPage(This,piUnk)	\
    (This)->lpVtbl -> OnStartPage(This,piUnk)

#define IPassportCrypt_put_host(This,bstrHostName)	\
    (This)->lpVtbl -> put_host(This,bstrHostName)

#endif /* COBJMACROS */


#endif 	/* C style interface */



/* [helpstring][id] */ HRESULT STDMETHODCALLTYPE IPassportCrypt_Encrypt_Proxy( 
    IPassportCrypt * This,
    /* [in] */ BSTR rawData,
    /* [retval][out] */ BSTR *pEncrypted);


void __RPC_STUB IPassportCrypt_Encrypt_Stub(
    IRpcStubBuffer *This,
    IRpcChannelBuffer *_pRpcChannelBuffer,
    PRPC_MESSAGE _pRpcMessage,
    DWORD *_pdwStubPhase);


/* [helpstring][id] */ HRESULT STDMETHODCALLTYPE IPassportCrypt_Decrypt_Proxy( 
    IPassportCrypt * This,
    /* [in] */ BSTR rawData,
    /* [retval][out] */ BSTR *pUnencrypted);


void __RPC_STUB IPassportCrypt_Decrypt_Stub(
    IRpcStubBuffer *This,
    IRpcChannelBuffer *_pRpcChannelBuffer,
    PRPC_MESSAGE _pRpcMessage,
    DWORD *_pdwStubPhase);


/* [helpstring][id][propget][hidden] */ HRESULT STDMETHODCALLTYPE IPassportCrypt_get_keyVersion_Proxy( 
    IPassportCrypt * This,
    /* [retval][out] */ int *pVal);


void __RPC_STUB IPassportCrypt_get_keyVersion_Stub(
    IRpcStubBuffer *This,
    IRpcChannelBuffer *_pRpcChannelBuffer,
    PRPC_MESSAGE _pRpcMessage,
    DWORD *_pdwStubPhase);


/* [helpstring][id][propput][hidden] */ HRESULT STDMETHODCALLTYPE IPassportCrypt_put_keyVersion_Proxy( 
    IPassportCrypt * This,
    /* [in] */ int newVal);


void __RPC_STUB IPassportCrypt_put_keyVersion_Stub(
    IRpcStubBuffer *This,
    IRpcChannelBuffer *_pRpcChannelBuffer,
    PRPC_MESSAGE _pRpcMessage,
    DWORD *_pdwStubPhase);


/* [helpstring][id][propget] */ HRESULT STDMETHODCALLTYPE IPassportCrypt_get_IsValid_Proxy( 
    IPassportCrypt * This,
    /* [retval][out] */ VARIANT_BOOL *pVal);


void __RPC_STUB IPassportCrypt_get_IsValid_Stub(
    IRpcStubBuffer *This,
    IRpcChannelBuffer *_pRpcChannelBuffer,
    PRPC_MESSAGE _pRpcMessage,
    DWORD *_pdwStubPhase);


/* [helpstring][id][propput][hidden] */ HRESULT STDMETHODCALLTYPE IPassportCrypt_put_keyMaterial_Proxy( 
    IPassportCrypt * This,
    /* [in] */ BSTR newVal);


void __RPC_STUB IPassportCrypt_put_keyMaterial_Stub(
    IRpcStubBuffer *This,
    IRpcChannelBuffer *_pRpcChannelBuffer,
    PRPC_MESSAGE _pRpcMessage,
    DWORD *_pdwStubPhase);


/* [helpstring][id] */ HRESULT STDMETHODCALLTYPE IPassportCrypt_Compress_Proxy( 
    IPassportCrypt * This,
    /* [in] */ BSTR bstrIn,
    /* [retval][out] */ BSTR *pbstrOut);


void __RPC_STUB IPassportCrypt_Compress_Stub(
    IRpcStubBuffer *This,
    IRpcChannelBuffer *_pRpcChannelBuffer,
    PRPC_MESSAGE _pRpcMessage,
    DWORD *_pdwStubPhase);


/* [helpstring][id] */ HRESULT STDMETHODCALLTYPE IPassportCrypt_Decompress_Proxy( 
    IPassportCrypt * This,
    /* [in] */ BSTR bstrIn,
    /* [retval][out] */ BSTR *pbstrOut);


void __RPC_STUB IPassportCrypt_Decompress_Stub(
    IRpcStubBuffer *This,
    IRpcChannelBuffer *_pRpcChannelBuffer,
    PRPC_MESSAGE _pRpcMessage,
    DWORD *_pdwStubPhase);


/* [helpstring][propput][id] */ HRESULT STDMETHODCALLTYPE IPassportCrypt_put_site_Proxy( 
    IPassportCrypt * This,
    /* [in] */ BSTR bstrSiteName);


void __RPC_STUB IPassportCrypt_put_site_Stub(
    IRpcStubBuffer *This,
    IRpcChannelBuffer *_pRpcChannelBuffer,
    PRPC_MESSAGE _pRpcMessage,
    DWORD *_pdwStubPhase);


/* [helpstring][id] */ HRESULT STDMETHODCALLTYPE IPassportCrypt_OnStartPage_Proxy( 
    IPassportCrypt * This,
    /* [in] */ IUnknown *piUnk);


void __RPC_STUB IPassportCrypt_OnStartPage_Stub(
    IRpcStubBuffer *This,
    IRpcChannelBuffer *_pRpcChannelBuffer,
    PRPC_MESSAGE _pRpcMessage,
    DWORD *_pdwStubPhase);


/* [helpstring][propput][id] */ HRESULT STDMETHODCALLTYPE IPassportCrypt_put_host_Proxy( 
    IPassportCrypt * This,
    /* [in] */ BSTR bstrHostName);


void __RPC_STUB IPassportCrypt_put_host_Stub(
    IRpcStubBuffer *This,
    IRpcChannelBuffer *_pRpcChannelBuffer,
    PRPC_MESSAGE _pRpcMessage,
    DWORD *_pdwStubPhase);



#endif 	/* __IPassportCrypt_INTERFACE_DEFINED__ */


#ifndef __IPassportAdmin_INTERFACE_DEFINED__
#define __IPassportAdmin_INTERFACE_DEFINED__

/* interface IPassportAdmin */
/* [unique][helpstring][dual][uuid][object] */ 


EXTERN_C const IID IID_IPassportAdmin;

#if defined(__cplusplus) && !defined(CINTERFACE)
    
    MIDL_INTERFACE("A0082CF5-AFF5-11D2-95E3-00C04F8E7A70")
    IPassportAdmin : public IDispatch
    {
    public:
        virtual /* [helpstring][id][propget] */ HRESULT STDMETHODCALLTYPE get_IsValid( 
            /* [retval][out] */ VARIANT_BOOL *pVal) = 0;
        
        virtual /* [helpstring][id][propget] */ HRESULT STDMETHODCALLTYPE get_ErrorDescription( 
            /* [retval][out] */ BSTR *pVal) = 0;
        
        virtual /* [helpstring][id] */ HRESULT STDMETHODCALLTYPE addKey( 
            /* [in] */ BSTR keyMaterial,
            /* [in] */ int version,
            /* [in] */ long expires,
            /* [retval][out] */ VARIANT_BOOL *ok) = 0;
        
        virtual /* [helpstring][id] */ HRESULT STDMETHODCALLTYPE deleteKey( 
            /* [in] */ int version) = 0;
        
        virtual /* [helpstring][id] */ HRESULT STDMETHODCALLTYPE setKeyTime( 
            /* [in] */ int version,
            /* [in] */ int fromNow) = 0;
        
        virtual /* [helpstring][id][propget] */ HRESULT STDMETHODCALLTYPE get_currentKeyVersion( 
            /* [retval][out] */ int *pCur) = 0;
        
        virtual /* [helpstring][id][propput] */ HRESULT STDMETHODCALLTYPE put_currentKeyVersion( 
            /* [in] */ int cur) = 0;
        
        virtual /* [helpstring][id][hidden] */ HRESULT STDMETHODCALLTYPE Refresh( 
            /* [in] */ VARIANT_BOOL bWait,
            /* [retval][out] */ VARIANT_BOOL *pbSuccess) = 0;
        
    };
    
#else 	/* C style interface */

    typedef struct IPassportAdminVtbl
    {
        BEGIN_INTERFACE
        
        HRESULT ( STDMETHODCALLTYPE *QueryInterface )( 
            IPassportAdmin * This,
            /* [in] */ REFIID riid,
            /* [iid_is][out] */ void **ppvObject);
        
        ULONG ( STDMETHODCALLTYPE *AddRef )( 
            IPassportAdmin * This);
        
        ULONG ( STDMETHODCALLTYPE *Release )( 
            IPassportAdmin * This);
        
        HRESULT ( STDMETHODCALLTYPE *GetTypeInfoCount )( 
            IPassportAdmin * This,
            /* [out] */ UINT *pctinfo);
        
        HRESULT ( STDMETHODCALLTYPE *GetTypeInfo )( 
            IPassportAdmin * This,
            /* [in] */ UINT iTInfo,
            /* [in] */ LCID lcid,
            /* [out] */ ITypeInfo **ppTInfo);
        
        HRESULT ( STDMETHODCALLTYPE *GetIDsOfNames )( 
            IPassportAdmin * This,
            /* [in] */ REFIID riid,
            /* [size_is][in] */ LPOLESTR *rgszNames,
            /* [in] */ UINT cNames,
            /* [in] */ LCID lcid,
            /* [size_is][out] */ DISPID *rgDispId);
        
        /* [local] */ HRESULT ( STDMETHODCALLTYPE *Invoke )( 
            IPassportAdmin * This,
            /* [in] */ DISPID dispIdMember,
            /* [in] */ REFIID riid,
            /* [in] */ LCID lcid,
            /* [in] */ WORD wFlags,
            /* [out][in] */ DISPPARAMS *pDispParams,
            /* [out] */ VARIANT *pVarResult,
            /* [out] */ EXCEPINFO *pExcepInfo,
            /* [out] */ UINT *puArgErr);
        
        /* [helpstring][id][propget] */ HRESULT ( STDMETHODCALLTYPE *get_IsValid )( 
            IPassportAdmin * This,
            /* [retval][out] */ VARIANT_BOOL *pVal);
        
        /* [helpstring][id][propget] */ HRESULT ( STDMETHODCALLTYPE *get_ErrorDescription )( 
            IPassportAdmin * This,
            /* [retval][out] */ BSTR *pVal);
        
        /* [helpstring][id] */ HRESULT ( STDMETHODCALLTYPE *addKey )( 
            IPassportAdmin * This,
            /* [in] */ BSTR keyMaterial,
            /* [in] */ int version,
            /* [in] */ long expires,
            /* [retval][out] */ VARIANT_BOOL *ok);
        
        /* [helpstring][id] */ HRESULT ( STDMETHODCALLTYPE *deleteKey )( 
            IPassportAdmin * This,
            /* [in] */ int version);
        
        /* [helpstring][id] */ HRESULT ( STDMETHODCALLTYPE *setKeyTime )( 
            IPassportAdmin * This,
            /* [in] */ int version,
            /* [in] */ int fromNow);
        
        /* [helpstring][id][propget] */ HRESULT ( STDMETHODCALLTYPE *get_currentKeyVersion )( 
            IPassportAdmin * This,
            /* [retval][out] */ int *pCur);
        
        /* [helpstring][id][propput] */ HRESULT ( STDMETHODCALLTYPE *put_currentKeyVersion )( 
            IPassportAdmin * This,
            /* [in] */ int cur);
        
        /* [helpstring][id][hidden] */ HRESULT ( STDMETHODCALLTYPE *Refresh )( 
            IPassportAdmin * This,
            /* [in] */ VARIANT_BOOL bWait,
            /* [retval][out] */ VARIANT_BOOL *pbSuccess);
        
        END_INTERFACE
    } IPassportAdminVtbl;

    interface IPassportAdmin
    {
        CONST_VTBL struct IPassportAdminVtbl *lpVtbl;
    };

    

#ifdef COBJMACROS


#define IPassportAdmin_QueryInterface(This,riid,ppvObject)	\
    (This)->lpVtbl -> QueryInterface(This,riid,ppvObject)

#define IPassportAdmin_AddRef(This)	\
    (This)->lpVtbl -> AddRef(This)

#define IPassportAdmin_Release(This)	\
    (This)->lpVtbl -> Release(This)


#define IPassportAdmin_GetTypeInfoCount(This,pctinfo)	\
    (This)->lpVtbl -> GetTypeInfoCount(This,pctinfo)

#define IPassportAdmin_GetTypeInfo(This,iTInfo,lcid,ppTInfo)	\
    (This)->lpVtbl -> GetTypeInfo(This,iTInfo,lcid,ppTInfo)

#define IPassportAdmin_GetIDsOfNames(This,riid,rgszNames,cNames,lcid,rgDispId)	\
    (This)->lpVtbl -> GetIDsOfNames(This,riid,rgszNames,cNames,lcid,rgDispId)

#define IPassportAdmin_Invoke(This,dispIdMember,riid,lcid,wFlags,pDispParams,pVarResult,pExcepInfo,puArgErr)	\
    (This)->lpVtbl -> Invoke(This,dispIdMember,riid,lcid,wFlags,pDispParams,pVarResult,pExcepInfo,puArgErr)


#define IPassportAdmin_get_IsValid(This,pVal)	\
    (This)->lpVtbl -> get_IsValid(This,pVal)

#define IPassportAdmin_get_ErrorDescription(This,pVal)	\
    (This)->lpVtbl -> get_ErrorDescription(This,pVal)

#define IPassportAdmin_addKey(This,keyMaterial,version,expires,ok)	\
    (This)->lpVtbl -> addKey(This,keyMaterial,version,expires,ok)

#define IPassportAdmin_deleteKey(This,version)	\
    (This)->lpVtbl -> deleteKey(This,version)

#define IPassportAdmin_setKeyTime(This,version,fromNow)	\
    (This)->lpVtbl -> setKeyTime(This,version,fromNow)

#define IPassportAdmin_get_currentKeyVersion(This,pCur)	\
    (This)->lpVtbl -> get_currentKeyVersion(This,pCur)

#define IPassportAdmin_put_currentKeyVersion(This,cur)	\
    (This)->lpVtbl -> put_currentKeyVersion(This,cur)

#define IPassportAdmin_Refresh(This,bWait,pbSuccess)	\
    (This)->lpVtbl -> Refresh(This,bWait,pbSuccess)

#endif /* COBJMACROS */


#endif 	/* C style interface */



/* [helpstring][id][propget] */ HRESULT STDMETHODCALLTYPE IPassportAdmin_get_IsValid_Proxy( 
    IPassportAdmin * This,
    /* [retval][out] */ VARIANT_BOOL *pVal);


void __RPC_STUB IPassportAdmin_get_IsValid_Stub(
    IRpcStubBuffer *This,
    IRpcChannelBuffer *_pRpcChannelBuffer,
    PRPC_MESSAGE _pRpcMessage,
    DWORD *_pdwStubPhase);


/* [helpstring][id][propget] */ HRESULT STDMETHODCALLTYPE IPassportAdmin_get_ErrorDescription_Proxy( 
    IPassportAdmin * This,
    /* [retval][out] */ BSTR *pVal);


void __RPC_STUB IPassportAdmin_get_ErrorDescription_Stub(
    IRpcStubBuffer *This,
    IRpcChannelBuffer *_pRpcChannelBuffer,
    PRPC_MESSAGE _pRpcMessage,
    DWORD *_pdwStubPhase);


/* [helpstring][id] */ HRESULT STDMETHODCALLTYPE IPassportAdmin_addKey_Proxy( 
    IPassportAdmin * This,
    /* [in] */ BSTR keyMaterial,
    /* [in] */ int version,
    /* [in] */ long expires,
    /* [retval][out] */ VARIANT_BOOL *ok);


void __RPC_STUB IPassportAdmin_addKey_Stub(
    IRpcStubBuffer *This,
    IRpcChannelBuffer *_pRpcChannelBuffer,
    PRPC_MESSAGE _pRpcMessage,
    DWORD *_pdwStubPhase);


/* [helpstring][id] */ HRESULT STDMETHODCALLTYPE IPassportAdmin_deleteKey_Proxy( 
    IPassportAdmin * This,
    /* [in] */ int version);


void __RPC_STUB IPassportAdmin_deleteKey_Stub(
    IRpcStubBuffer *This,
    IRpcChannelBuffer *_pRpcChannelBuffer,
    PRPC_MESSAGE _pRpcMessage,
    DWORD *_pdwStubPhase);


/* [helpstring][id] */ HRESULT STDMETHODCALLTYPE IPassportAdmin_setKeyTime_Proxy( 
    IPassportAdmin * This,
    /* [in] */ int version,
    /* [in] */ int fromNow);


void __RPC_STUB IPassportAdmin_setKeyTime_Stub(
    IRpcStubBuffer *This,
    IRpcChannelBuffer *_pRpcChannelBuffer,
    PRPC_MESSAGE _pRpcMessage,
    DWORD *_pdwStubPhase);


/* [helpstring][id][propget] */ HRESULT STDMETHODCALLTYPE IPassportAdmin_get_currentKeyVersion_Proxy( 
    IPassportAdmin * This,
    /* [retval][out] */ int *pCur);


void __RPC_STUB IPassportAdmin_get_currentKeyVersion_Stub(
    IRpcStubBuffer *This,
    IRpcChannelBuffer *_pRpcChannelBuffer,
    PRPC_MESSAGE _pRpcMessage,
    DWORD *_pdwStubPhase);


/* [helpstring][id][propput] */ HRESULT STDMETHODCALLTYPE IPassportAdmin_put_currentKeyVersion_Proxy( 
    IPassportAdmin * This,
    /* [in] */ int cur);


void __RPC_STUB IPassportAdmin_put_currentKeyVersion_Stub(
    IRpcStubBuffer *This,
    IRpcChannelBuffer *_pRpcChannelBuffer,
    PRPC_MESSAGE _pRpcMessage,
    DWORD *_pdwStubPhase);


/* [helpstring][id][hidden] */ HRESULT STDMETHODCALLTYPE IPassportAdmin_Refresh_Proxy( 
    IPassportAdmin * This,
    /* [in] */ VARIANT_BOOL bWait,
    /* [retval][out] */ VARIANT_BOOL *pbSuccess);


void __RPC_STUB IPassportAdmin_Refresh_Stub(
    IRpcStubBuffer *This,
    IRpcChannelBuffer *_pRpcChannelBuffer,
    PRPC_MESSAGE _pRpcMessage,
    DWORD *_pdwStubPhase);



#endif 	/* __IPassportAdmin_INTERFACE_DEFINED__ */


#ifndef __IPassportAdminEx_INTERFACE_DEFINED__
#define __IPassportAdminEx_INTERFACE_DEFINED__

/* interface IPassportAdminEx */
/* [unique][helpstring][dual][uuid][object] */ 


EXTERN_C const IID IID_IPassportAdminEx;

#if defined(__cplusplus) && !defined(CINTERFACE)
    
    MIDL_INTERFACE("876181A0-3B05-11d3-9ACD-0080C712D19C")
    IPassportAdminEx : public IPassportAdmin
    {
    public:
        virtual /* [helpstring][id] */ HRESULT STDMETHODCALLTYPE addKeyEx( 
            /* [in] */ BSTR keyMaterial,
            /* [in] */ int nVersion,
            /* [in] */ long expires,
            /* [optional][in] */ VARIANT vSiteName,
            /* [retval][out] */ VARIANT_BOOL *ok) = 0;
        
        virtual /* [helpstring][id] */ HRESULT STDMETHODCALLTYPE deleteKeyEx( 
            /* [in] */ int nVersion,
            /* [optional][in] */ VARIANT vSiteName) = 0;
        
        virtual /* [helpstring][id] */ HRESULT STDMETHODCALLTYPE setKeyTimeEx( 
            /* [in] */ int nVersion,
            /* [in] */ int fromNow,
            /* [optional][in] */ VARIANT vSiteName) = 0;
        
        virtual /* [helpstring][id] */ HRESULT STDMETHODCALLTYPE getCurrentKeyVersionEx( 
            /* [optional][in] */ VARIANT vSiteName,
            /* [retval][out] */ int *pCur) = 0;
        
        virtual /* [helpstring][id] */ HRESULT STDMETHODCALLTYPE putCurrentKeyVersionEx( 
            /* [in] */ int cur,
            /* [optional][in] */ VARIANT vSiteName) = 0;
        
        virtual /* [helpstring][id] */ HRESULT STDMETHODCALLTYPE setNexusPassword( 
            /* [in] */ BSTR bstrPwd) = 0;
        
    };
    
#else 	/* C style interface */

    typedef struct IPassportAdminExVtbl
    {
        BEGIN_INTERFACE
        
        HRESULT ( STDMETHODCALLTYPE *QueryInterface )( 
            IPassportAdminEx * This,
            /* [in] */ REFIID riid,
            /* [iid_is][out] */ void **ppvObject);
        
        ULONG ( STDMETHODCALLTYPE *AddRef )( 
            IPassportAdminEx * This);
        
        ULONG ( STDMETHODCALLTYPE *Release )( 
            IPassportAdminEx * This);
        
        HRESULT ( STDMETHODCALLTYPE *GetTypeInfoCount )( 
            IPassportAdminEx * This,
            /* [out] */ UINT *pctinfo);
        
        HRESULT ( STDMETHODCALLTYPE *GetTypeInfo )( 
            IPassportAdminEx * This,
            /* [in] */ UINT iTInfo,
            /* [in] */ LCID lcid,
            /* [out] */ ITypeInfo **ppTInfo);
        
        HRESULT ( STDMETHODCALLTYPE *GetIDsOfNames )( 
            IPassportAdminEx * This,
            /* [in] */ REFIID riid,
            /* [size_is][in] */ LPOLESTR *rgszNames,
            /* [in] */ UINT cNames,
            /* [in] */ LCID lcid,
            /* [size_is][out] */ DISPID *rgDispId);
        
        /* [local] */ HRESULT ( STDMETHODCALLTYPE *Invoke )( 
            IPassportAdminEx * This,
            /* [in] */ DISPID dispIdMember,
            /* [in] */ REFIID riid,
            /* [in] */ LCID lcid,
            /* [in] */ WORD wFlags,
            /* [out][in] */ DISPPARAMS *pDispParams,
            /* [out] */ VARIANT *pVarResult,
            /* [out] */ EXCEPINFO *pExcepInfo,
            /* [out] */ UINT *puArgErr);
        
        /* [helpstring][id][propget] */ HRESULT ( STDMETHODCALLTYPE *get_IsValid )( 
            IPassportAdminEx * This,
            /* [retval][out] */ VARIANT_BOOL *pVal);
        
        /* [helpstring][id][propget] */ HRESULT ( STDMETHODCALLTYPE *get_ErrorDescription )( 
            IPassportAdminEx * This,
            /* [retval][out] */ BSTR *pVal);
        
        /* [helpstring][id] */ HRESULT ( STDMETHODCALLTYPE *addKey )( 
            IPassportAdminEx * This,
            /* [in] */ BSTR keyMaterial,
            /* [in] */ int version,
            /* [in] */ long expires,
            /* [retval][out] */ VARIANT_BOOL *ok);
        
        /* [helpstring][id] */ HRESULT ( STDMETHODCALLTYPE *deleteKey )( 
            IPassportAdminEx * This,
            /* [in] */ int version);
        
        /* [helpstring][id] */ HRESULT ( STDMETHODCALLTYPE *setKeyTime )( 
            IPassportAdminEx * This,
            /* [in] */ int version,
            /* [in] */ int fromNow);
        
        /* [helpstring][id][propget] */ HRESULT ( STDMETHODCALLTYPE *get_currentKeyVersion )( 
            IPassportAdminEx * This,
            /* [retval][out] */ int *pCur);
        
        /* [helpstring][id][propput] */ HRESULT ( STDMETHODCALLTYPE *put_currentKeyVersion )( 
            IPassportAdminEx * This,
            /* [in] */ int cur);
        
        /* [helpstring][id][hidden] */ HRESULT ( STDMETHODCALLTYPE *Refresh )( 
            IPassportAdminEx * This,
            /* [in] */ VARIANT_BOOL bWait,
            /* [retval][out] */ VARIANT_BOOL *pbSuccess);
        
        /* [helpstring][id] */ HRESULT ( STDMETHODCALLTYPE *addKeyEx )( 
            IPassportAdminEx * This,
            /* [in] */ BSTR keyMaterial,
            /* [in] */ int nVersion,
            /* [in] */ long expires,
            /* [optional][in] */ VARIANT vSiteName,
            /* [retval][out] */ VARIANT_BOOL *ok);
        
        /* [helpstring][id] */ HRESULT ( STDMETHODCALLTYPE *deleteKeyEx )( 
            IPassportAdminEx * This,
            /* [in] */ int nVersion,
            /* [optional][in] */ VARIANT vSiteName);
        
        /* [helpstring][id] */ HRESULT ( STDMETHODCALLTYPE *setKeyTimeEx )( 
            IPassportAdminEx * This,
            /* [in] */ int nVersion,
            /* [in] */ int fromNow,
            /* [optional][in] */ VARIANT vSiteName);
        
        /* [helpstring][id] */ HRESULT ( STDMETHODCALLTYPE *getCurrentKeyVersionEx )( 
            IPassportAdminEx * This,
            /* [optional][in] */ VARIANT vSiteName,
            /* [retval][out] */ int *pCur);
        
        /* [helpstring][id] */ HRESULT ( STDMETHODCALLTYPE *putCurrentKeyVersionEx )( 
            IPassportAdminEx * This,
            /* [in] */ int cur,
            /* [optional][in] */ VARIANT vSiteName);
        
        /* [helpstring][id] */ HRESULT ( STDMETHODCALLTYPE *setNexusPassword )( 
            IPassportAdminEx * This,
            /* [in] */ BSTR bstrPwd);
        
        END_INTERFACE
    } IPassportAdminExVtbl;

    interface IPassportAdminEx
    {
        CONST_VTBL struct IPassportAdminExVtbl *lpVtbl;
    };

    

#ifdef COBJMACROS


#define IPassportAdminEx_QueryInterface(This,riid,ppvObject)	\
    (This)->lpVtbl -> QueryInterface(This,riid,ppvObject)

#define IPassportAdminEx_AddRef(This)	\
    (This)->lpVtbl -> AddRef(This)

#define IPassportAdminEx_Release(This)	\
    (This)->lpVtbl -> Release(This)


#define IPassportAdminEx_GetTypeInfoCount(This,pctinfo)	\
    (This)->lpVtbl -> GetTypeInfoCount(This,pctinfo)

#define IPassportAdminEx_GetTypeInfo(This,iTInfo,lcid,ppTInfo)	\
    (This)->lpVtbl -> GetTypeInfo(This,iTInfo,lcid,ppTInfo)

#define IPassportAdminEx_GetIDsOfNames(This,riid,rgszNames,cNames,lcid,rgDispId)	\
    (This)->lpVtbl -> GetIDsOfNames(This,riid,rgszNames,cNames,lcid,rgDispId)

#define IPassportAdminEx_Invoke(This,dispIdMember,riid,lcid,wFlags,pDispParams,pVarResult,pExcepInfo,puArgErr)	\
    (This)->lpVtbl -> Invoke(This,dispIdMember,riid,lcid,wFlags,pDispParams,pVarResult,pExcepInfo,puArgErr)


#define IPassportAdminEx_get_IsValid(This,pVal)	\
    (This)->lpVtbl -> get_IsValid(This,pVal)

#define IPassportAdminEx_get_ErrorDescription(This,pVal)	\
    (This)->lpVtbl -> get_ErrorDescription(This,pVal)

#define IPassportAdminEx_addKey(This,keyMaterial,version,expires,ok)	\
    (This)->lpVtbl -> addKey(This,keyMaterial,version,expires,ok)

#define IPassportAdminEx_deleteKey(This,version)	\
    (This)->lpVtbl -> deleteKey(This,version)

#define IPassportAdminEx_setKeyTime(This,version,fromNow)	\
    (This)->lpVtbl -> setKeyTime(This,version,fromNow)

#define IPassportAdminEx_get_currentKeyVersion(This,pCur)	\
    (This)->lpVtbl -> get_currentKeyVersion(This,pCur)

#define IPassportAdminEx_put_currentKeyVersion(This,cur)	\
    (This)->lpVtbl -> put_currentKeyVersion(This,cur)

#define IPassportAdminEx_Refresh(This,bWait,pbSuccess)	\
    (This)->lpVtbl -> Refresh(This,bWait,pbSuccess)


#define IPassportAdminEx_addKeyEx(This,keyMaterial,nVersion,expires,vSiteName,ok)	\
    (This)->lpVtbl -> addKeyEx(This,keyMaterial,nVersion,expires,vSiteName,ok)

#define IPassportAdminEx_deleteKeyEx(This,nVersion,vSiteName)	\
    (This)->lpVtbl -> deleteKeyEx(This,nVersion,vSiteName)

#define IPassportAdminEx_setKeyTimeEx(This,nVersion,fromNow,vSiteName)	\
    (This)->lpVtbl -> setKeyTimeEx(This,nVersion,fromNow,vSiteName)

#define IPassportAdminEx_getCurrentKeyVersionEx(This,vSiteName,pCur)	\
    (This)->lpVtbl -> getCurrentKeyVersionEx(This,vSiteName,pCur)

#define IPassportAdminEx_putCurrentKeyVersionEx(This,cur,vSiteName)	\
    (This)->lpVtbl -> putCurrentKeyVersionEx(This,cur,vSiteName)

#define IPassportAdminEx_setNexusPassword(This,bstrPwd)	\
    (This)->lpVtbl -> setNexusPassword(This,bstrPwd)

#endif /* COBJMACROS */


#endif 	/* C style interface */



/* [helpstring][id] */ HRESULT STDMETHODCALLTYPE IPassportAdminEx_addKeyEx_Proxy( 
    IPassportAdminEx * This,
    /* [in] */ BSTR keyMaterial,
    /* [in] */ int nVersion,
    /* [in] */ long expires,
    /* [optional][in] */ VARIANT vSiteName,
    /* [retval][out] */ VARIANT_BOOL *ok);


void __RPC_STUB IPassportAdminEx_addKeyEx_Stub(
    IRpcStubBuffer *This,
    IRpcChannelBuffer *_pRpcChannelBuffer,
    PRPC_MESSAGE _pRpcMessage,
    DWORD *_pdwStubPhase);


/* [helpstring][id] */ HRESULT STDMETHODCALLTYPE IPassportAdminEx_deleteKeyEx_Proxy( 
    IPassportAdminEx * This,
    /* [in] */ int nVersion,
    /* [optional][in] */ VARIANT vSiteName);


void __RPC_STUB IPassportAdminEx_deleteKeyEx_Stub(
    IRpcStubBuffer *This,
    IRpcChannelBuffer *_pRpcChannelBuffer,
    PRPC_MESSAGE _pRpcMessage,
    DWORD *_pdwStubPhase);


/* [helpstring][id] */ HRESULT STDMETHODCALLTYPE IPassportAdminEx_setKeyTimeEx_Proxy( 
    IPassportAdminEx * This,
    /* [in] */ int nVersion,
    /* [in] */ int fromNow,
    /* [optional][in] */ VARIANT vSiteName);


void __RPC_STUB IPassportAdminEx_setKeyTimeEx_Stub(
    IRpcStubBuffer *This,
    IRpcChannelBuffer *_pRpcChannelBuffer,
    PRPC_MESSAGE _pRpcMessage,
    DWORD *_pdwStubPhase);


/* [helpstring][id] */ HRESULT STDMETHODCALLTYPE IPassportAdminEx_getCurrentKeyVersionEx_Proxy( 
    IPassportAdminEx * This,
    /* [optional][in] */ VARIANT vSiteName,
    /* [retval][out] */ int *pCur);


void __RPC_STUB IPassportAdminEx_getCurrentKeyVersionEx_Stub(
    IRpcStubBuffer *This,
    IRpcChannelBuffer *_pRpcChannelBuffer,
    PRPC_MESSAGE _pRpcMessage,
    DWORD *_pdwStubPhase);


/* [helpstring][id] */ HRESULT STDMETHODCALLTYPE IPassportAdminEx_putCurrentKeyVersionEx_Proxy( 
    IPassportAdminEx * This,
    /* [in] */ int cur,
    /* [optional][in] */ VARIANT vSiteName);


void __RPC_STUB IPassportAdminEx_putCurrentKeyVersionEx_Stub(
    IRpcStubBuffer *This,
    IRpcChannelBuffer *_pRpcChannelBuffer,
    PRPC_MESSAGE _pRpcMessage,
    DWORD *_pdwStubPhase);


/* [helpstring][id] */ HRESULT STDMETHODCALLTYPE IPassportAdminEx_setNexusPassword_Proxy( 
    IPassportAdminEx * This,
    /* [in] */ BSTR bstrPwd);


void __RPC_STUB IPassportAdminEx_setNexusPassword_Stub(
    IRpcStubBuffer *This,
    IRpcChannelBuffer *_pRpcChannelBuffer,
    PRPC_MESSAGE _pRpcMessage,
    DWORD *_pdwStubPhase);



#endif 	/* __IPassportAdminEx_INTERFACE_DEFINED__ */


#ifndef __IPassportFastAuth_INTERFACE_DEFINED__
#define __IPassportFastAuth_INTERFACE_DEFINED__

/* interface IPassportFastAuth */
/* [unique][helpstring][dual][uuid][object] */ 


EXTERN_C const IID IID_IPassportFastAuth;

#if defined(__cplusplus) && !defined(CINTERFACE)
    
    MIDL_INTERFACE("74EB2513-E239-11D2-95E9-00C04F8E7A70")
    IPassportFastAuth : public IDispatch
    {
    public:
        virtual /* [helpstring][id] */ HRESULT STDMETHODCALLTYPE IsAuthenticated( 
            /* [in] */ BSTR bstrTicket,
            /* [in] */ BSTR bstrProfile,
            /* [optional][in] */ VARIANT vSecure,
            /* [optional][in] */ VARIANT vTimeWindow,
            /* [optional][in] */ VARIANT vForceLogin,
            /* [optional][in] */ VARIANT vSiteName,
            /* [optional][in] */ VARIANT vDoSecureCheck,
            /* [retval][out] */ VARIANT_BOOL *pbIsAuthenticated) = 0;
        
        virtual /* [helpstring][id] */ HRESULT STDMETHODCALLTYPE LogoTag( 
            /* [in] */ BSTR bstrTicket,
            /* [in] */ BSTR bstrProfile,
            /* [optional][in] */ VARIANT vRU,
            /* [optional][in] */ VARIANT vTimeWindow,
            /* [optional][in] */ VARIANT vForceLogin,
            /* [optional][in] */ VARIANT vCoBrand,
            /* [optional][in] */ VARIANT vLangId,
            /* [optional][in] */ VARIANT vSecure,
            /* [optional][in] */ VARIANT vLogoutURL,
            /* [optional][in] */ VARIANT vSiteName,
            /* [optional][in] */ VARIANT NameSpace,
            /* [optional][in] */ VARIANT vKPP,
            /* [optional][in] */ VARIANT SecureLevel,
            /* [retval][out] */ BSTR *pbstrLogoTag) = 0;
        
        virtual /* [helpstring][id] */ HRESULT STDMETHODCALLTYPE AuthURL( 
            /* [optional][in] */ VARIANT vTicket,
            /* [optional][in] */ VARIANT vProfile,
            /* [optional][in] */ VARIANT vRU,
            /* [optional][in] */ VARIANT vTimeWindow,
            /* [optional][in] */ VARIANT vForceLogin,
            /* [optional][in] */ VARIANT vCoBrand,
            /* [optional][in] */ VARIANT vLangId,
            /* [optional][in] */ VARIANT vSecure,
            /* [optional][in] */ VARIANT vLogoutURL,
            /* [optional][in] */ VARIANT vReserved1,
            /* [optional][in] */ VARIANT vSiteName,
            /* [optional][in] */ VARIANT NameSpace,
            /* [optional][in] */ VARIANT vKPP,
            /* [optional][in] */ VARIANT SecureLevel,
            /* [retval][out] */ BSTR *pbstrAuthURL) = 0;
        
        virtual /* [hidden][helpstring][id] */ HRESULT STDMETHODCALLTYPE GetTicketAndProfilePFC( 
            /* [in] */ BYTE *pbPFC,
            /* [in] */ BYTE *pbPPH,
            /* [out] */ BSTR *pbstrTicket,
            /* [out] */ BSTR *pbstrProfile,
            /* [out] */ BSTR *pbstrSecure,
            /* [out] */ BSTR *pbstrSiteName) = 0;
        
        virtual /* [hidden][helpstring][id] */ HRESULT STDMETHODCALLTYPE GetTicketAndProfileECB( 
            /* [in] */ BYTE *pbECB,
            /* [out] */ BSTR *pbstrTicket,
            /* [out] */ BSTR *pbstrProfile,
            /* [out] */ BSTR *pbstrSecure,
            /* [out] */ BSTR *pbstrSiteName) = 0;
        
    };
    
#else 	/* C style interface */

    typedef struct IPassportFastAuthVtbl
    {
        BEGIN_INTERFACE
        
        HRESULT ( STDMETHODCALLTYPE *QueryInterface )( 
            IPassportFastAuth * This,
            /* [in] */ REFIID riid,
            /* [iid_is][out] */ void **ppvObject);
        
        ULONG ( STDMETHODCALLTYPE *AddRef )( 
            IPassportFastAuth * This);
        
        ULONG ( STDMETHODCALLTYPE *Release )( 
            IPassportFastAuth * This);
        
        HRESULT ( STDMETHODCALLTYPE *GetTypeInfoCount )( 
            IPassportFastAuth * This,
            /* [out] */ UINT *pctinfo);
        
        HRESULT ( STDMETHODCALLTYPE *GetTypeInfo )( 
            IPassportFastAuth * This,
            /* [in] */ UINT iTInfo,
            /* [in] */ LCID lcid,
            /* [out] */ ITypeInfo **ppTInfo);
        
        HRESULT ( STDMETHODCALLTYPE *GetIDsOfNames )( 
            IPassportFastAuth * This,
            /* [in] */ REFIID riid,
            /* [size_is][in] */ LPOLESTR *rgszNames,
            /* [in] */ UINT cNames,
            /* [in] */ LCID lcid,
            /* [size_is][out] */ DISPID *rgDispId);
        
        /* [local] */ HRESULT ( STDMETHODCALLTYPE *Invoke )( 
            IPassportFastAuth * This,
            /* [in] */ DISPID dispIdMember,
            /* [in] */ REFIID riid,
            /* [in] */ LCID lcid,
            /* [in] */ WORD wFlags,
            /* [out][in] */ DISPPARAMS *pDispParams,
            /* [out] */ VARIANT *pVarResult,
            /* [out] */ EXCEPINFO *pExcepInfo,
            /* [out] */ UINT *puArgErr);
        
        /* [helpstring][id] */ HRESULT ( STDMETHODCALLTYPE *IsAuthenticated )( 
            IPassportFastAuth * This,
            /* [in] */ BSTR bstrTicket,
            /* [in] */ BSTR bstrProfile,
            /* [optional][in] */ VARIANT vSecure,
            /* [optional][in] */ VARIANT vTimeWindow,
            /* [optional][in] */ VARIANT vForceLogin,
            /* [optional][in] */ VARIANT vSiteName,
            /* [optional][in] */ VARIANT vDoSecureCheck,
            /* [retval][out] */ VARIANT_BOOL *pbIsAuthenticated);
        
        /* [helpstring][id] */ HRESULT ( STDMETHODCALLTYPE *LogoTag )( 
            IPassportFastAuth * This,
            /* [in] */ BSTR bstrTicket,
            /* [in] */ BSTR bstrProfile,
            /* [optional][in] */ VARIANT vRU,
            /* [optional][in] */ VARIANT vTimeWindow,
            /* [optional][in] */ VARIANT vForceLogin,
            /* [optional][in] */ VARIANT vCoBrand,
            /* [optional][in] */ VARIANT vLangId,
            /* [optional][in] */ VARIANT vSecure,
            /* [optional][in] */ VARIANT vLogoutURL,
            /* [optional][in] */ VARIANT vSiteName,
            /* [optional][in] */ VARIANT NameSpace,
            /* [optional][in] */ VARIANT vKPP,
            /* [optional][in] */ VARIANT SecureLevel,
            /* [retval][out] */ BSTR *pbstrLogoTag);
        
        /* [helpstring][id] */ HRESULT ( STDMETHODCALLTYPE *AuthURL )( 
            IPassportFastAuth * This,
            /* [optional][in] */ VARIANT vTicket,
            /* [optional][in] */ VARIANT vProfile,
            /* [optional][in] */ VARIANT vRU,
            /* [optional][in] */ VARIANT vTimeWindow,
            /* [optional][in] */ VARIANT vForceLogin,
            /* [optional][in] */ VARIANT vCoBrand,
            /* [optional][in] */ VARIANT vLangId,
            /* [optional][in] */ VARIANT vSecure,
            /* [optional][in] */ VARIANT vLogoutURL,
            /* [optional][in] */ VARIANT vReserved1,
            /* [optional][in] */ VARIANT vSiteName,
            /* [optional][in] */ VARIANT NameSpace,
            /* [optional][in] */ VARIANT vKPP,
            /* [optional][in] */ VARIANT SecureLevel,
            /* [retval][out] */ BSTR *pbstrAuthURL);
        
        /* [hidden][helpstring][id] */ HRESULT ( STDMETHODCALLTYPE *GetTicketAndProfilePFC )( 
            IPassportFastAuth * This,
            /* [in] */ BYTE *pbPFC,
            /* [in] */ BYTE *pbPPH,
            /* [out] */ BSTR *pbstrTicket,
            /* [out] */ BSTR *pbstrProfile,
            /* [out] */ BSTR *pbstrSecure,
            /* [out] */ BSTR *pbstrSiteName);
        
        /* [hidden][helpstring][id] */ HRESULT ( STDMETHODCALLTYPE *GetTicketAndProfileECB )( 
            IPassportFastAuth * This,
            /* [in] */ BYTE *pbECB,
            /* [out] */ BSTR *pbstrTicket,
            /* [out] */ BSTR *pbstrProfile,
            /* [out] */ BSTR *pbstrSecure,
            /* [out] */ BSTR *pbstrSiteName);
        
        END_INTERFACE
    } IPassportFastAuthVtbl;

    interface IPassportFastAuth
    {
        CONST_VTBL struct IPassportFastAuthVtbl *lpVtbl;
    };

    

#ifdef COBJMACROS


#define IPassportFastAuth_QueryInterface(This,riid,ppvObject)	\
    (This)->lpVtbl -> QueryInterface(This,riid,ppvObject)

#define IPassportFastAuth_AddRef(This)	\
    (This)->lpVtbl -> AddRef(This)

#define IPassportFastAuth_Release(This)	\
    (This)->lpVtbl -> Release(This)


#define IPassportFastAuth_GetTypeInfoCount(This,pctinfo)	\
    (This)->lpVtbl -> GetTypeInfoCount(This,pctinfo)

#define IPassportFastAuth_GetTypeInfo(This,iTInfo,lcid,ppTInfo)	\
    (This)->lpVtbl -> GetTypeInfo(This,iTInfo,lcid,ppTInfo)

#define IPassportFastAuth_GetIDsOfNames(This,riid,rgszNames,cNames,lcid,rgDispId)	\
    (This)->lpVtbl -> GetIDsOfNames(This,riid,rgszNames,cNames,lcid,rgDispId)

#define IPassportFastAuth_Invoke(This,dispIdMember,riid,lcid,wFlags,pDispParams,pVarResult,pExcepInfo,puArgErr)	\
    (This)->lpVtbl -> Invoke(This,dispIdMember,riid,lcid,wFlags,pDispParams,pVarResult,pExcepInfo,puArgErr)


#define IPassportFastAuth_IsAuthenticated(This,bstrTicket,bstrProfile,vSecure,vTimeWindow,vForceLogin,vSiteName,vDoSecureCheck,pbIsAuthenticated)	\
    (This)->lpVtbl -> IsAuthenticated(This,bstrTicket,bstrProfile,vSecure,vTimeWindow,vForceLogin,vSiteName,vDoSecureCheck,pbIsAuthenticated)

#define IPassportFastAuth_LogoTag(This,bstrTicket,bstrProfile,vRU,vTimeWindow,vForceLogin,vCoBrand,vLangId,vSecure,vLogoutURL,vSiteName,NameSpace,vKPP,SecureLevel,pbstrLogoTag)	\
    (This)->lpVtbl -> LogoTag(This,bstrTicket,bstrProfile,vRU,vTimeWindow,vForceLogin,vCoBrand,vLangId,vSecure,vLogoutURL,vSiteName,NameSpace,vKPP,SecureLevel,pbstrLogoTag)

#define IPassportFastAuth_AuthURL(This,vTicket,vProfile,vRU,vTimeWindow,vForceLogin,vCoBrand,vLangId,vSecure,vLogoutURL,vReserved1,vSiteName,NameSpace,vKPP,SecureLevel,pbstrAuthURL)	\
    (This)->lpVtbl -> AuthURL(This,vTicket,vProfile,vRU,vTimeWindow,vForceLogin,vCoBrand,vLangId,vSecure,vLogoutURL,vReserved1,vSiteName,NameSpace,vKPP,SecureLevel,pbstrAuthURL)

#define IPassportFastAuth_GetTicketAndProfilePFC(This,pbPFC,pbPPH,pbstrTicket,pbstrProfile,pbstrSecure,pbstrSiteName)	\
    (This)->lpVtbl -> GetTicketAndProfilePFC(This,pbPFC,pbPPH,pbstrTicket,pbstrProfile,pbstrSecure,pbstrSiteName)

#define IPassportFastAuth_GetTicketAndProfileECB(This,pbECB,pbstrTicket,pbstrProfile,pbstrSecure,pbstrSiteName)	\
    (This)->lpVtbl -> GetTicketAndProfileECB(This,pbECB,pbstrTicket,pbstrProfile,pbstrSecure,pbstrSiteName)

#endif /* COBJMACROS */


#endif 	/* C style interface */



/* [helpstring][id] */ HRESULT STDMETHODCALLTYPE IPassportFastAuth_IsAuthenticated_Proxy( 
    IPassportFastAuth * This,
    /* [in] */ BSTR bstrTicket,
    /* [in] */ BSTR bstrProfile,
    /* [optional][in] */ VARIANT vSecure,
    /* [optional][in] */ VARIANT vTimeWindow,
    /* [optional][in] */ VARIANT vForceLogin,
    /* [optional][in] */ VARIANT vSiteName,
    /* [optional][in] */ VARIANT vDoSecureCheck,
    /* [retval][out] */ VARIANT_BOOL *pbIsAuthenticated);


void __RPC_STUB IPassportFastAuth_IsAuthenticated_Stub(
    IRpcStubBuffer *This,
    IRpcChannelBuffer *_pRpcChannelBuffer,
    PRPC_MESSAGE _pRpcMessage,
    DWORD *_pdwStubPhase);


/* [helpstring][id] */ HRESULT STDMETHODCALLTYPE IPassportFastAuth_LogoTag_Proxy( 
    IPassportFastAuth * This,
    /* [in] */ BSTR bstrTicket,
    /* [in] */ BSTR bstrProfile,
    /* [optional][in] */ VARIANT vRU,
    /* [optional][in] */ VARIANT vTimeWindow,
    /* [optional][in] */ VARIANT vForceLogin,
    /* [optional][in] */ VARIANT vCoBrand,
    /* [optional][in] */ VARIANT vLangId,
    /* [optional][in] */ VARIANT vSecure,
    /* [optional][in] */ VARIANT vLogoutURL,
    /* [optional][in] */ VARIANT vSiteName,
    /* [optional][in] */ VARIANT NameSpace,
    /* [optional][in] */ VARIANT vKPP,
    /* [optional][in] */ VARIANT SecureLevel,
    /* [retval][out] */ BSTR *pbstrLogoTag);


void __RPC_STUB IPassportFastAuth_LogoTag_Stub(
    IRpcStubBuffer *This,
    IRpcChannelBuffer *_pRpcChannelBuffer,
    PRPC_MESSAGE _pRpcMessage,
    DWORD *_pdwStubPhase);


/* [helpstring][id] */ HRESULT STDMETHODCALLTYPE IPassportFastAuth_AuthURL_Proxy( 
    IPassportFastAuth * This,
    /* [optional][in] */ VARIANT vTicket,
    /* [optional][in] */ VARIANT vProfile,
    /* [optional][in] */ VARIANT vRU,
    /* [optional][in] */ VARIANT vTimeWindow,
    /* [optional][in] */ VARIANT vForceLogin,
    /* [optional][in] */ VARIANT vCoBrand,
    /* [optional][in] */ VARIANT vLangId,
    /* [optional][in] */ VARIANT vSecure,
    /* [optional][in] */ VARIANT vLogoutURL,
    /* [optional][in] */ VARIANT vReserved1,
    /* [optional][in] */ VARIANT vSiteName,
    /* [optional][in] */ VARIANT NameSpace,
    /* [optional][in] */ VARIANT vKPP,
    /* [optional][in] */ VARIANT SecureLevel,
    /* [retval][out] */ BSTR *pbstrAuthURL);


void __RPC_STUB IPassportFastAuth_AuthURL_Stub(
    IRpcStubBuffer *This,
    IRpcChannelBuffer *_pRpcChannelBuffer,
    PRPC_MESSAGE _pRpcMessage,
    DWORD *_pdwStubPhase);


/* [hidden][helpstring][id] */ HRESULT STDMETHODCALLTYPE IPassportFastAuth_GetTicketAndProfilePFC_Proxy( 
    IPassportFastAuth * This,
    /* [in] */ BYTE *pbPFC,
    /* [in] */ BYTE *pbPPH,
    /* [out] */ BSTR *pbstrTicket,
    /* [out] */ BSTR *pbstrProfile,
    /* [out] */ BSTR *pbstrSecure,
    /* [out] */ BSTR *pbstrSiteName);


void __RPC_STUB IPassportFastAuth_GetTicketAndProfilePFC_Stub(
    IRpcStubBuffer *This,
    IRpcChannelBuffer *_pRpcChannelBuffer,
    PRPC_MESSAGE _pRpcMessage,
    DWORD *_pdwStubPhase);


/* [hidden][helpstring][id] */ HRESULT STDMETHODCALLTYPE IPassportFastAuth_GetTicketAndProfileECB_Proxy( 
    IPassportFastAuth * This,
    /* [in] */ BYTE *pbECB,
    /* [out] */ BSTR *pbstrTicket,
    /* [out] */ BSTR *pbstrProfile,
    /* [out] */ BSTR *pbstrSecure,
    /* [out] */ BSTR *pbstrSiteName);


void __RPC_STUB IPassportFastAuth_GetTicketAndProfileECB_Stub(
    IRpcStubBuffer *This,
    IRpcChannelBuffer *_pRpcChannelBuffer,
    PRPC_MESSAGE _pRpcMessage,
    DWORD *_pdwStubPhase);



#endif 	/* __IPassportFastAuth_INTERFACE_DEFINED__ */


#ifndef __IPassportFastAuth2_INTERFACE_DEFINED__
#define __IPassportFastAuth2_INTERFACE_DEFINED__

/* interface IPassportFastAuth2 */
/* [unique][helpstring][dual][uuid][object] */ 


EXTERN_C const IID IID_IPassportFastAuth2;

#if defined(__cplusplus) && !defined(CINTERFACE)
    
    MIDL_INTERFACE("fb41a7d8-3739-4468-bdf1-e5b4b2eaeb4b")
    IPassportFastAuth2 : public IPassportFastAuth
    {
    public:
        virtual /* [helpstring][id] */ HRESULT STDMETHODCALLTYPE LogoTag2( 
            /* [in] */ BSTR bstrTicket,
            /* [in] */ BSTR bstrProfile,
            /* [optional][in] */ VARIANT vRU,
            /* [optional][in] */ VARIANT vTimeWindow,
            /* [optional][in] */ VARIANT vForceLogin,
            /* [optional][in] */ VARIANT vCoBrand,
            /* [optional][in] */ VARIANT vLangId,
            /* [optional][in] */ VARIANT vSecure,
            /* [optional][in] */ VARIANT vLogoutURL,
            /* [optional][in] */ VARIANT vSiteName,
            /* [optional][in] */ VARIANT NameSpace,
            /* [optional][in] */ VARIANT vKPP,
            /* [optional][in] */ VARIANT SecureLevel,
            /* [retval][out] */ BSTR *pbstrLogoTag) = 0;
        
        virtual /* [helpstring][id] */ HRESULT STDMETHODCALLTYPE AuthURL2( 
            /* [optional][in] */ VARIANT vTicket,
            /* [optional][in] */ VARIANT vProfile,
            /* [optional][in] */ VARIANT vRU,
            /* [optional][in] */ VARIANT vTimeWindow,
            /* [optional][in] */ VARIANT vForceLogin,
            /* [optional][in] */ VARIANT vCoBrand,
            /* [optional][in] */ VARIANT vLangId,
            /* [optional][in] */ VARIANT vSecure,
            /* [optional][in] */ VARIANT vLogoutURL,
            /* [optional][in] */ VARIANT vReserved1,
            /* [optional][in] */ VARIANT vSiteName,
            /* [optional][in] */ VARIANT NameSpace,
            /* [optional][in] */ VARIANT vKPP,
            /* [optional][in] */ VARIANT SecureLevel,
            /* [retval][out] */ BSTR *pbstrAuthURL) = 0;
        
    };
    
#else 	/* C style interface */

    typedef struct IPassportFastAuth2Vtbl
    {
        BEGIN_INTERFACE
        
        HRESULT ( STDMETHODCALLTYPE *QueryInterface )( 
            IPassportFastAuth2 * This,
            /* [in] */ REFIID riid,
            /* [iid_is][out] */ void **ppvObject);
        
        ULONG ( STDMETHODCALLTYPE *AddRef )( 
            IPassportFastAuth2 * This);
        
        ULONG ( STDMETHODCALLTYPE *Release )( 
            IPassportFastAuth2 * This);
        
        HRESULT ( STDMETHODCALLTYPE *GetTypeInfoCount )( 
            IPassportFastAuth2 * This,
            /* [out] */ UINT *pctinfo);
        
        HRESULT ( STDMETHODCALLTYPE *GetTypeInfo )( 
            IPassportFastAuth2 * This,
            /* [in] */ UINT iTInfo,
            /* [in] */ LCID lcid,
            /* [out] */ ITypeInfo **ppTInfo);
        
        HRESULT ( STDMETHODCALLTYPE *GetIDsOfNames )( 
            IPassportFastAuth2 * This,
            /* [in] */ REFIID riid,
            /* [size_is][in] */ LPOLESTR *rgszNames,
            /* [in] */ UINT cNames,
            /* [in] */ LCID lcid,
            /* [size_is][out] */ DISPID *rgDispId);
        
        /* [local] */ HRESULT ( STDMETHODCALLTYPE *Invoke )( 
            IPassportFastAuth2 * This,
            /* [in] */ DISPID dispIdMember,
            /* [in] */ REFIID riid,
            /* [in] */ LCID lcid,
            /* [in] */ WORD wFlags,
            /* [out][in] */ DISPPARAMS *pDispParams,
            /* [out] */ VARIANT *pVarResult,
            /* [out] */ EXCEPINFO *pExcepInfo,
            /* [out] */ UINT *puArgErr);
        
        /* [helpstring][id] */ HRESULT ( STDMETHODCALLTYPE *IsAuthenticated )( 
            IPassportFastAuth2 * This,
            /* [in] */ BSTR bstrTicket,
            /* [in] */ BSTR bstrProfile,
            /* [optional][in] */ VARIANT vSecure,
            /* [optional][in] */ VARIANT vTimeWindow,
            /* [optional][in] */ VARIANT vForceLogin,
            /* [optional][in] */ VARIANT vSiteName,
            /* [optional][in] */ VARIANT vDoSecureCheck,
            /* [retval][out] */ VARIANT_BOOL *pbIsAuthenticated);
        
        /* [helpstring][id] */ HRESULT ( STDMETHODCALLTYPE *LogoTag )( 
            IPassportFastAuth2 * This,
            /* [in] */ BSTR bstrTicket,
            /* [in] */ BSTR bstrProfile,
            /* [optional][in] */ VARIANT vRU,
            /* [optional][in] */ VARIANT vTimeWindow,
            /* [optional][in] */ VARIANT vForceLogin,
            /* [optional][in] */ VARIANT vCoBrand,
            /* [optional][in] */ VARIANT vLangId,
            /* [optional][in] */ VARIANT vSecure,
            /* [optional][in] */ VARIANT vLogoutURL,
            /* [optional][in] */ VARIANT vSiteName,
            /* [optional][in] */ VARIANT NameSpace,
            /* [optional][in] */ VARIANT vKPP,
            /* [optional][in] */ VARIANT SecureLevel,
            /* [retval][out] */ BSTR *pbstrLogoTag);
        
        /* [helpstring][id] */ HRESULT ( STDMETHODCALLTYPE *AuthURL )( 
            IPassportFastAuth2 * This,
            /* [optional][in] */ VARIANT vTicket,
            /* [optional][in] */ VARIANT vProfile,
            /* [optional][in] */ VARIANT vRU,
            /* [optional][in] */ VARIANT vTimeWindow,
            /* [optional][in] */ VARIANT vForceLogin,
            /* [optional][in] */ VARIANT vCoBrand,
            /* [optional][in] */ VARIANT vLangId,
            /* [optional][in] */ VARIANT vSecure,
            /* [optional][in] */ VARIANT vLogoutURL,
            /* [optional][in] */ VARIANT vReserved1,
            /* [optional][in] */ VARIANT vSiteName,
            /* [optional][in] */ VARIANT NameSpace,
            /* [optional][in] */ VARIANT vKPP,
            /* [optional][in] */ VARIANT SecureLevel,
            /* [retval][out] */ BSTR *pbstrAuthURL);
        
        /* [hidden][helpstring][id] */ HRESULT ( STDMETHODCALLTYPE *GetTicketAndProfilePFC )( 
            IPassportFastAuth2 * This,
            /* [in] */ BYTE *pbPFC,
            /* [in] */ BYTE *pbPPH,
            /* [out] */ BSTR *pbstrTicket,
            /* [out] */ BSTR *pbstrProfile,
            /* [out] */ BSTR *pbstrSecure,
            /* [out] */ BSTR *pbstrSiteName);
        
        /* [hidden][helpstring][id] */ HRESULT ( STDMETHODCALLTYPE *GetTicketAndProfileECB )( 
            IPassportFastAuth2 * This,
            /* [in] */ BYTE *pbECB,
            /* [out] */ BSTR *pbstrTicket,
            /* [out] */ BSTR *pbstrProfile,
            /* [out] */ BSTR *pbstrSecure,
            /* [out] */ BSTR *pbstrSiteName);
        
        /* [helpstring][id] */ HRESULT ( STDMETHODCALLTYPE *LogoTag2 )( 
            IPassportFastAuth2 * This,
            /* [in] */ BSTR bstrTicket,
            /* [in] */ BSTR bstrProfile,
            /* [optional][in] */ VARIANT vRU,
            /* [optional][in] */ VARIANT vTimeWindow,
            /* [optional][in] */ VARIANT vForceLogin,
            /* [optional][in] */ VARIANT vCoBrand,
            /* [optional][in] */ VARIANT vLangId,
            /* [optional][in] */ VARIANT vSecure,
            /* [optional][in] */ VARIANT vLogoutURL,
            /* [optional][in] */ VARIANT vSiteName,
            /* [optional][in] */ VARIANT NameSpace,
            /* [optional][in] */ VARIANT vKPP,
            /* [optional][in] */ VARIANT SecureLevel,
            /* [retval][out] */ BSTR *pbstrLogoTag);
        
        /* [helpstring][id] */ HRESULT ( STDMETHODCALLTYPE *AuthURL2 )( 
            IPassportFastAuth2 * This,
            /* [optional][in] */ VARIANT vTicket,
            /* [optional][in] */ VARIANT vProfile,
            /* [optional][in] */ VARIANT vRU,
            /* [optional][in] */ VARIANT vTimeWindow,
            /* [optional][in] */ VARIANT vForceLogin,
            /* [optional][in] */ VARIANT vCoBrand,
            /* [optional][in] */ VARIANT vLangId,
            /* [optional][in] */ VARIANT vSecure,
            /* [optional][in] */ VARIANT vLogoutURL,
            /* [optional][in] */ VARIANT vReserved1,
            /* [optional][in] */ VARIANT vSiteName,
            /* [optional][in] */ VARIANT NameSpace,
            /* [optional][in] */ VARIANT vKPP,
            /* [optional][in] */ VARIANT SecureLevel,
            /* [retval][out] */ BSTR *pbstrAuthURL);
        
        END_INTERFACE
    } IPassportFastAuth2Vtbl;

    interface IPassportFastAuth2
    {
        CONST_VTBL struct IPassportFastAuth2Vtbl *lpVtbl;
    };

    

#ifdef COBJMACROS


#define IPassportFastAuth2_QueryInterface(This,riid,ppvObject)	\
    (This)->lpVtbl -> QueryInterface(This,riid,ppvObject)

#define IPassportFastAuth2_AddRef(This)	\
    (This)->lpVtbl -> AddRef(This)

#define IPassportFastAuth2_Release(This)	\
    (This)->lpVtbl -> Release(This)


#define IPassportFastAuth2_GetTypeInfoCount(This,pctinfo)	\
    (This)->lpVtbl -> GetTypeInfoCount(This,pctinfo)

#define IPassportFastAuth2_GetTypeInfo(This,iTInfo,lcid,ppTInfo)	\
    (This)->lpVtbl -> GetTypeInfo(This,iTInfo,lcid,ppTInfo)

#define IPassportFastAuth2_GetIDsOfNames(This,riid,rgszNames,cNames,lcid,rgDispId)	\
    (This)->lpVtbl -> GetIDsOfNames(This,riid,rgszNames,cNames,lcid,rgDispId)

#define IPassportFastAuth2_Invoke(This,dispIdMember,riid,lcid,wFlags,pDispParams,pVarResult,pExcepInfo,puArgErr)	\
    (This)->lpVtbl -> Invoke(This,dispIdMember,riid,lcid,wFlags,pDispParams,pVarResult,pExcepInfo,puArgErr)


#define IPassportFastAuth2_IsAuthenticated(This,bstrTicket,bstrProfile,vSecure,vTimeWindow,vForceLogin,vSiteName,vDoSecureCheck,pbIsAuthenticated)	\
    (This)->lpVtbl -> IsAuthenticated(This,bstrTicket,bstrProfile,vSecure,vTimeWindow,vForceLogin,vSiteName,vDoSecureCheck,pbIsAuthenticated)

#define IPassportFastAuth2_LogoTag(This,bstrTicket,bstrProfile,vRU,vTimeWindow,vForceLogin,vCoBrand,vLangId,vSecure,vLogoutURL,vSiteName,NameSpace,vKPP,SecureLevel,pbstrLogoTag)	\
    (This)->lpVtbl -> LogoTag(This,bstrTicket,bstrProfile,vRU,vTimeWindow,vForceLogin,vCoBrand,vLangId,vSecure,vLogoutURL,vSiteName,NameSpace,vKPP,SecureLevel,pbstrLogoTag)

#define IPassportFastAuth2_AuthURL(This,vTicket,vProfile,vRU,vTimeWindow,vForceLogin,vCoBrand,vLangId,vSecure,vLogoutURL,vReserved1,vSiteName,NameSpace,vKPP,SecureLevel,pbstrAuthURL)	\
    (This)->lpVtbl -> AuthURL(This,vTicket,vProfile,vRU,vTimeWindow,vForceLogin,vCoBrand,vLangId,vSecure,vLogoutURL,vReserved1,vSiteName,NameSpace,vKPP,SecureLevel,pbstrAuthURL)

#define IPassportFastAuth2_GetTicketAndProfilePFC(This,pbPFC,pbPPH,pbstrTicket,pbstrProfile,pbstrSecure,pbstrSiteName)	\
    (This)->lpVtbl -> GetTicketAndProfilePFC(This,pbPFC,pbPPH,pbstrTicket,pbstrProfile,pbstrSecure,pbstrSiteName)

#define IPassportFastAuth2_GetTicketAndProfileECB(This,pbECB,pbstrTicket,pbstrProfile,pbstrSecure,pbstrSiteName)	\
    (This)->lpVtbl -> GetTicketAndProfileECB(This,pbECB,pbstrTicket,pbstrProfile,pbstrSecure,pbstrSiteName)


#define IPassportFastAuth2_LogoTag2(This,bstrTicket,bstrProfile,vRU,vTimeWindow,vForceLogin,vCoBrand,vLangId,vSecure,vLogoutURL,vSiteName,NameSpace,vKPP,SecureLevel,pbstrLogoTag)	\
    (This)->lpVtbl -> LogoTag2(This,bstrTicket,bstrProfile,vRU,vTimeWindow,vForceLogin,vCoBrand,vLangId,vSecure,vLogoutURL,vSiteName,NameSpace,vKPP,SecureLevel,pbstrLogoTag)

#define IPassportFastAuth2_AuthURL2(This,vTicket,vProfile,vRU,vTimeWindow,vForceLogin,vCoBrand,vLangId,vSecure,vLogoutURL,vReserved1,vSiteName,NameSpace,vKPP,SecureLevel,pbstrAuthURL)	\
    (This)->lpVtbl -> AuthURL2(This,vTicket,vProfile,vRU,vTimeWindow,vForceLogin,vCoBrand,vLangId,vSecure,vLogoutURL,vReserved1,vSiteName,NameSpace,vKPP,SecureLevel,pbstrAuthURL)

#endif /* COBJMACROS */


#endif 	/* C style interface */



/* [helpstring][id] */ HRESULT STDMETHODCALLTYPE IPassportFastAuth2_LogoTag2_Proxy( 
    IPassportFastAuth2 * This,
    /* [in] */ BSTR bstrTicket,
    /* [in] */ BSTR bstrProfile,
    /* [optional][in] */ VARIANT vRU,
    /* [optional][in] */ VARIANT vTimeWindow,
    /* [optional][in] */ VARIANT vForceLogin,
    /* [optional][in] */ VARIANT vCoBrand,
    /* [optional][in] */ VARIANT vLangId,
    /* [optional][in] */ VARIANT vSecure,
    /* [optional][in] */ VARIANT vLogoutURL,
    /* [optional][in] */ VARIANT vSiteName,
    /* [optional][in] */ VARIANT NameSpace,
    /* [optional][in] */ VARIANT vKPP,
    /* [optional][in] */ VARIANT SecureLevel,
    /* [retval][out] */ BSTR *pbstrLogoTag);


void __RPC_STUB IPassportFastAuth2_LogoTag2_Stub(
    IRpcStubBuffer *This,
    IRpcChannelBuffer *_pRpcChannelBuffer,
    PRPC_MESSAGE _pRpcMessage,
    DWORD *_pdwStubPhase);


/* [helpstring][id] */ HRESULT STDMETHODCALLTYPE IPassportFastAuth2_AuthURL2_Proxy( 
    IPassportFastAuth2 * This,
    /* [optional][in] */ VARIANT vTicket,
    /* [optional][in] */ VARIANT vProfile,
    /* [optional][in] */ VARIANT vRU,
    /* [optional][in] */ VARIANT vTimeWindow,
    /* [optional][in] */ VARIANT vForceLogin,
    /* [optional][in] */ VARIANT vCoBrand,
    /* [optional][in] */ VARIANT vLangId,
    /* [optional][in] */ VARIANT vSecure,
    /* [optional][in] */ VARIANT vLogoutURL,
    /* [optional][in] */ VARIANT vReserved1,
    /* [optional][in] */ VARIANT vSiteName,
    /* [optional][in] */ VARIANT NameSpace,
    /* [optional][in] */ VARIANT vKPP,
    /* [optional][in] */ VARIANT SecureLevel,
    /* [retval][out] */ BSTR *pbstrAuthURL);


void __RPC_STUB IPassportFastAuth2_AuthURL2_Stub(
    IRpcStubBuffer *This,
    IRpcChannelBuffer *_pRpcChannelBuffer,
    PRPC_MESSAGE _pRpcMessage,
    DWORD *_pdwStubPhase);



#endif 	/* __IPassportFastAuth2_INTERFACE_DEFINED__ */


#ifndef __IPassportFactory_INTERFACE_DEFINED__
#define __IPassportFactory_INTERFACE_DEFINED__

/* interface IPassportFactory */
/* [unique][helpstring][dual][uuid][object] */ 


EXTERN_C const IID IID_IPassportFactory;

#if defined(__cplusplus) && !defined(CINTERFACE)
    
    MIDL_INTERFACE("5602E147-27F6-11d3-94DD-00C04F72DC08")
    IPassportFactory : public IDispatch
    {
    public:
        virtual HRESULT STDMETHODCALLTYPE CreatePassportManager( 
            /* [retval][out] */ IDispatch **ppdispPassportManager) = 0;
        
    };
    
#else 	/* C style interface */

    typedef struct IPassportFactoryVtbl
    {
        BEGIN_INTERFACE
        
        HRESULT ( STDMETHODCALLTYPE *QueryInterface )( 
            IPassportFactory * This,
            /* [in] */ REFIID riid,
            /* [iid_is][out] */ void **ppvObject);
        
        ULONG ( STDMETHODCALLTYPE *AddRef )( 
            IPassportFactory * This);
        
        ULONG ( STDMETHODCALLTYPE *Release )( 
            IPassportFactory * This);
        
        HRESULT ( STDMETHODCALLTYPE *GetTypeInfoCount )( 
            IPassportFactory * This,
            /* [out] */ UINT *pctinfo);
        
        HRESULT ( STDMETHODCALLTYPE *GetTypeInfo )( 
            IPassportFactory * This,
            /* [in] */ UINT iTInfo,
            /* [in] */ LCID lcid,
            /* [out] */ ITypeInfo **ppTInfo);
        
        HRESULT ( STDMETHODCALLTYPE *GetIDsOfNames )( 
            IPassportFactory * This,
            /* [in] */ REFIID riid,
            /* [size_is][in] */ LPOLESTR *rgszNames,
            /* [in] */ UINT cNames,
            /* [in] */ LCID lcid,
            /* [size_is][out] */ DISPID *rgDispId);
        
        /* [local] */ HRESULT ( STDMETHODCALLTYPE *Invoke )( 
            IPassportFactory * This,
            /* [in] */ DISPID dispIdMember,
            /* [in] */ REFIID riid,
            /* [in] */ LCID lcid,
            /* [in] */ WORD wFlags,
            /* [out][in] */ DISPPARAMS *pDispParams,
            /* [out] */ VARIANT *pVarResult,
            /* [out] */ EXCEPINFO *pExcepInfo,
            /* [out] */ UINT *puArgErr);
        
        HRESULT ( STDMETHODCALLTYPE *CreatePassportManager )( 
            IPassportFactory * This,
            /* [retval][out] */ IDispatch **ppdispPassportManager);
        
        END_INTERFACE
    } IPassportFactoryVtbl;

    interface IPassportFactory
    {
        CONST_VTBL struct IPassportFactoryVtbl *lpVtbl;
    };

    

#ifdef COBJMACROS


#define IPassportFactory_QueryInterface(This,riid,ppvObject)	\
    (This)->lpVtbl -> QueryInterface(This,riid,ppvObject)

#define IPassportFactory_AddRef(This)	\
    (This)->lpVtbl -> AddRef(This)

#define IPassportFactory_Release(This)	\
    (This)->lpVtbl -> Release(This)


#define IPassportFactory_GetTypeInfoCount(This,pctinfo)	\
    (This)->lpVtbl -> GetTypeInfoCount(This,pctinfo)

#define IPassportFactory_GetTypeInfo(This,iTInfo,lcid,ppTInfo)	\
    (This)->lpVtbl -> GetTypeInfo(This,iTInfo,lcid,ppTInfo)

#define IPassportFactory_GetIDsOfNames(This,riid,rgszNames,cNames,lcid,rgDispId)	\
    (This)->lpVtbl -> GetIDsOfNames(This,riid,rgszNames,cNames,lcid,rgDispId)

#define IPassportFactory_Invoke(This,dispIdMember,riid,lcid,wFlags,pDispParams,pVarResult,pExcepInfo,puArgErr)	\
    (This)->lpVtbl -> Invoke(This,dispIdMember,riid,lcid,wFlags,pDispParams,pVarResult,pExcepInfo,puArgErr)


#define IPassportFactory_CreatePassportManager(This,ppdispPassportManager)	\
    (This)->lpVtbl -> CreatePassportManager(This,ppdispPassportManager)

#endif /* COBJMACROS */


#endif 	/* C style interface */



HRESULT STDMETHODCALLTYPE IPassportFactory_CreatePassportManager_Proxy( 
    IPassportFactory * This,
    /* [retval][out] */ IDispatch **ppdispPassportManager);


void __RPC_STUB IPassportFactory_CreatePassportManager_Stub(
    IRpcStubBuffer *This,
    IRpcChannelBuffer *_pRpcChannelBuffer,
    PRPC_MESSAGE _pRpcMessage,
    DWORD *_pdwStubPhase);



#endif 	/* __IPassportFactory_INTERFACE_DEFINED__ */



#ifndef __PASSPORTLib_LIBRARY_DEFINED__
#define __PASSPORTLib_LIBRARY_DEFINED__

/* library PASSPORTLib */
/* [helpstring][version][uuid] */ 


EXTERN_C const IID LIBID_PASSPORTLib;

EXTERN_C const CLSID CLSID_Manager;

#ifdef __cplusplus

class DECLSPEC_UUID("41651BF0-A5C8-11D2-95DF-00C04F8E7A70")
Manager;
#endif

EXTERN_C const CLSID CLSID_Ticket;

#ifdef __cplusplus

class DECLSPEC_UUID("41651BF2-A5C8-11D2-95DF-00C04F8E7A70")
Ticket;
#endif

EXTERN_C const CLSID CLSID_Profile;

#ifdef __cplusplus

class DECLSPEC_UUID("41651BF4-A5C8-11D2-95DF-00C04F8E7A70")
Profile;
#endif

EXTERN_C const CLSID CLSID_Crypt;

#ifdef __cplusplus

class DECLSPEC_UUID("41651BFA-A5C8-11D2-95DF-00C04F8E7A70")
Crypt;
#endif

EXTERN_C const CLSID CLSID_Admin;

#ifdef __cplusplus

class DECLSPEC_UUID("A0082CF6-AFF5-11D2-95E3-00C04F8E7A70")
Admin;
#endif

EXTERN_C const CLSID CLSID_FastAuth;

#ifdef __cplusplus

class DECLSPEC_UUID("5602E146-27F6-11d3-94DD-00C04F72DC08")
FastAuth;
#endif

EXTERN_C const CLSID CLSID_PassportFactory;

#ifdef __cplusplus

class DECLSPEC_UUID("74EB2514-E239-11D2-95E9-00C04F8E7A70")
PassportFactory;
#endif
#endif /* __PASSPORTLib_LIBRARY_DEFINED__ */

/* Additional Prototypes for ALL interfaces */

unsigned long             __RPC_USER  BSTR_UserSize(     unsigned long *, unsigned long            , BSTR * ); 
unsigned char * __RPC_USER  BSTR_UserMarshal(  unsigned long *, unsigned char *, BSTR * ); 
unsigned char * __RPC_USER  BSTR_UserUnmarshal(unsigned long *, unsigned char *, BSTR * ); 
void                      __RPC_USER  BSTR_UserFree(     unsigned long *, BSTR * ); 

unsigned long             __RPC_USER  VARIANT_UserSize(     unsigned long *, unsigned long            , VARIANT * ); 
unsigned char * __RPC_USER  VARIANT_UserMarshal(  unsigned long *, unsigned char *, VARIANT * ); 
unsigned char * __RPC_USER  VARIANT_UserUnmarshal(unsigned long *, unsigned char *, VARIANT * ); 
void                      __RPC_USER  VARIANT_UserFree(     unsigned long *, VARIANT * ); 

/* end of Additional Prototypes */

#ifdef __cplusplus
}
#endif

#endif
=== C:/Users/treeman/Desktop/windows nt source code\Source\Win2K3\NT\public\internal\ds\inc\samisrv.h ===
/*++

Copyright (c) 1992  Microsoft Corporation

Module Name:

    samisrv.h

Abstract:

    This file contain private routines for use by Trusted SAM clients
    which live in the same process as the SAM server.

    Included in these routines are services for freeing buffers returned
    by RPC server stub routines (SamrXxx() routines).

Author:

    Cliff Van Dyke (CliffV) 26-Feb-1992

Environment:

    User Mode - Win32

Revision History:


--*/

#ifndef _SAMISRV_
#define _SAMISRV_


#define SAMP_SAM_COMPONENT_NAME L"Security Account Manager"

/////////////////////////////////////////////////////////////////////////////
//                                                                         //
// Data types used by SAM and Netlogon for database replication            //
//                                                                         //
/////////////////////////////////////////////////////////////////////////////

typedef enum _SECURITY_DB_TYPE {
    SecurityDbSam = 1,
    SecurityDbLsa
} SECURITY_DB_TYPE, *PSECURITY_DB_TYPE;

//
// These structures are used to get and set private data.  Note that
// DataType must be the first field of every such structure.
//

typedef enum _SAMI_PRIVATE_DATA_TYPE {
    SamPrivateDataNextRid = 1,
    SamPrivateDataPassword
} SAMI_PRIVATE_DATA_TYPE, *PSAMI_PRIVATE_DATA_TYPE;


typedef struct _SAMI_PRIVATE_DATA_NEXTRID_TYPE {
    SAMI_PRIVATE_DATA_TYPE DataType;
    ULONG NextRid;
} SAMI_PRIVATE_DATA_NEXTRID_TYPE, *PSAMI_PRIVATE_DATA_NEXTRID_TYPE;

typedef struct _SAMI_PRIVATE_DATA_PASSWORD_TYPE {
    SAMI_PRIVATE_DATA_TYPE DataType;
    UNICODE_STRING CaseInsensitiveDbcs;
    ENCRYPTED_LM_OWF_PASSWORD CaseInsensitiveDbcsBuffer;
    UNICODE_STRING CaseSensitiveUnicode;
    ENCRYPTED_NT_OWF_PASSWORD CaseSensitiveUnicodeBuffer;
    UNICODE_STRING LmPasswordHistory;
    UNICODE_STRING NtPasswordHistory;
} SAMI_PRIVATE_DATA_PASSWORD_TYPE, *PSAMI_PRIVATE_DATA_PASSWORD_TYPE;


typedef struct _SAMP_UNICODE_STRING_RELATIVE {
    USHORT Length;
    USHORT MaximumLength;
    ULONG  Buffer; // note buffer is really an offset
} SAMP_UNICODE_STRING_RELATIVE , *PSAMP_UNICODE_STRING_RELATIVE;

typedef struct _SAMI_PRIVATE_DATA_PASSWORD_TYPE_RELATIVE {
    SAMI_PRIVATE_DATA_TYPE DataType;
    SAMP_UNICODE_STRING_RELATIVE CaseInsensitiveDbcs;
    ENCRYPTED_LM_OWF_PASSWORD    CaseInsensitiveDbcsBuffer;
    SAMP_UNICODE_STRING_RELATIVE CaseSensitiveUnicode;
    ENCRYPTED_NT_OWF_PASSWORD    CaseSensitiveUnicodeBuffer;
    SAMP_UNICODE_STRING_RELATIVE LmPasswordHistory;
    SAMP_UNICODE_STRING_RELATIVE NtPasswordHistory;
} SAMI_PRIVATE_DATA_PASSWORD_RELATIVE_TYPE, *PSAMI_PRIVATE_DATA_PASSWORD_RELATIVE_TYPE;

#define SAM_CLEARTEXT_CREDENTIAL_NAME L"CLEARTEXT"


NTSTATUS
SamISetPasswordInfoOnPdc(
    IN SAMPR_HANDLE SamDomainHandle,
    IN PUCHAR       OpaqueBuffer,
    IN ULONG        BufferLength
    );

NTSTATUS
SamIResetBadPwdCountOnPdc(
    IN SAMPR_HANDLE SamUserHandle
    );


//////////////////////////////////////////////////////////////////////////////
//                                                                          //
//                                                                          //
//       Flag Definitions for SamIGetUserLogonInformation                   //
//                                                                          //
//                                                                          //
//////////////////////////////////////////////////////////////////////////////

#define SAM_GET_MEMBERSHIPS_NO_GC        ((ULONG)0x00000001)
#define SAM_GET_MEMBERSHIPS_TWO_PHASE    ((ULONG)0x00000002)
#define SAM_GET_MEMBERSHIPS_MIXED_DOMAIN ((ULONG)0x00000004)
#define SAM_NO_MEMBERSHIPS               ((ULONG)0x00000008)
#define SAM_OPEN_BY_ALTERNATE_ID         ((ULONG)0x00000010)
#define SAM_OPEN_BY_UPN                  ((ULONG)0x00000020)
#define SAM_OPEN_BY_SPN                  ((ULONG)0x00000040)
#define SAM_OPEN_BY_SID                  ((ULONG)0x00000080)
#define SAM_OPEN_BY_GUID                 ((ULONG)0x00000100)
#define SAM_OPEN_BY_UPN_OR_ACCOUNTNAME   ((ULONG)0x00000200)
#define SAM_PRESERVE_DBPOS               ((ULONG)0x00000400)
#define SAM_OPEN_BY_DN                   ((ULONG)0x00000800)


//////////////////////////////////////////////////////////////////////////////
//                                                                          //
//                                                                          //
//       Flag Definitions for SamIGetResourceGroupMemberships               //
//                                                                          //
//                                                                          //
//////////////////////////////////////////////////////////////////////////////

#define SAM_SERVICE_TARGET_IS_DC         ((ULONG)0x00000001)


///////////////////////////////////////////////////////////////////////////////
//                                                                           //
//   Data types used by SamIUpdateLogonStatistics                            //
//                                                                           //
///////////////////////////////////////////////////////////////////////////////
typedef enum _SAM_CLIENT_INFO_ENUM
{   
    SamClientNoInformation = 0,
    SamClientIpAddr        = 1

} SAM_CLIENT_INFO_TYPE, *PSAM_CLIENT_INFO_TYPE; 

typedef struct _SAM_CLIENT_INFO
{
    SAM_CLIENT_INFO_TYPE Type;
    union {
        ULONG IpAddr;  // corresponds to type SamClientIpAddr
    } Data;
} SAM_CLIENT_INFO, *PSAM_CLIENT_INFO;

typedef struct _SAM_LOGON_STATISTICS
{
    ULONG StatisticsToApply;
    USHORT BadPasswordCount;
    USHORT LogonCount;
    LARGE_INTEGER LastLogon;
    LARGE_INTEGER LastLogoff;
    UNICODE_STRING Workstation;
    SAM_CLIENT_INFO ClientInfo;

} SAM_LOGON_STATISTICS, *PSAM_LOGON_STATISTICS;

///////////////////////////////////////////////////////////////////////////////
//                                                                           //
//   Data types used by Reverse Membership Query Routines                    //
//                                                                           //
///////////////////////////////////////////////////////////////////////////////

typedef struct _SID_AND_ATTRIBUTES_LIST {
    ULONG   Count;
    PSID_AND_ATTRIBUTES SidAndAttributes;
} SID_AND_ATTRIBUTES_LIST , *PSID_AND_ATTRIBUTES_LIST;


///////////////////////////////////////////////////////////////////////////////
//                                                                           //
//   Data types used by Promotion/Demotion operations                        //
//                                                                           //
///////////////////////////////////////////////////////////////////////////////


//
//  These flags indicate what type of install
//
#define SAMP_PROMOTE_ENTERPRISE    ((ULONG)0x00000001)
#define SAMP_PROMOTE_DOMAIN        ((ULONG)0x00000002)
#define SAMP_PROMOTE_REPLICA       ((ULONG)0x00000004)

//
// When a new domain, these flags indicate how to seed the
// initial security pricipals in the domain
//
#define SAMP_PROMOTE_UPGRADE         ((ULONG)0x00000008)
#define SAMP_PROMOTE_MIGRATE         ((ULONG)0x00000010)
#define SAMP_PROMOTE_CREATE          ((ULONG)0x00000020)
#define SAMP_PROMOTE_ALLOW_ANON      ((ULONG)0x00000040)
#define SAMP_PROMOTE_DFLT_REPAIR_PWD ((ULONG)0x00000080)


//
// Flags for demote
//
#define SAMP_DEMOTE_STANDALONE     ((ULONG)0x00000040)
#define SAMP_DEMOTE_MEMBER         ((ULONG)0x00000080)

// unused
#define SAMP_DEMOTE_LAST_DOMAIN    ((ULONG)0x00000100)

#define SAMP_TEMP_UPGRADE          ((ULONG)0x00000200)

//
// This flag is not passed into SamIPromote; rather it is used
// to trigger new NT5 account creations on gui mode setup
// of NT5 to NT5 upgrades
//
#define SAMP_PROMOTE_INTERNAL_UPGRADE ((ULONG)0x00000400)


//
// Defines the maximum number of well-known (restricted) accounts
// in the SAM database. Restricted accounts have rids less than this
// value. User-defined accounts have rids >= this value.
//

#define SAMI_RESTRICTED_ACCOUNT_COUNT    1000


///////////////////////////////////////////////////////////////////////////////
//                                                                           //
// The following prototypes are usable throughout the process that SAM       //
// resides in.  This may include calls by LAN Manager code that is not       //
// part of SAM but is in the same process as SAM.                            //
//                                                                           //
///////////////////////////////////////////////////////////////////////////////

NTSTATUS
SamIConnect(
    IN PSAMPR_SERVER_NAME ServerName,
    OUT SAMPR_HANDLE *ServerHandle,
    IN ACCESS_MASK DesiredAccess,
    IN BOOLEAN TrustedClient
    );

NTSTATUS
SamIAccountRestrictions(
    IN SAM_HANDLE UserHandle,
    IN PUNICODE_STRING LogonWorkstation,
    IN PUNICODE_STRING Workstations,
    IN PLOGON_HOURS LogonHours,
    OUT PLARGE_INTEGER LogoffTime,
    OUT PLARGE_INTEGER KickoffTime
    );

NTSTATUS
SamIUpdateLogonStatistics(
    IN SAM_HANDLE UserHandle,
    IN PSAM_LOGON_STATISTICS LogonStats
    );

NTSTATUS
SamICreateAccountByRid(
    IN SAMPR_HANDLE DomainHandle,
    IN SAM_ACCOUNT_TYPE AccountType,
    IN ULONG RelativeId,
    IN PRPC_UNICODE_STRING AccountName,
    IN ACCESS_MASK DesiredAccess,
    OUT SAMPR_HANDLE *AccountHandle,
    OUT ULONG *ConflictingAccountRid
    );

NTSTATUS
SamIGetSerialNumberDomain(
    IN SAMPR_HANDLE DomainHandle,
    OUT PLARGE_INTEGER ModifiedCount,
    OUT PLARGE_INTEGER CreationTime
    );

NTSTATUS
SamISetSerialNumberDomain(
    IN SAMPR_HANDLE DomainHandle,
    IN PLARGE_INTEGER ModifiedCount,
    IN PLARGE_INTEGER CreationTime,
    IN BOOLEAN StartOfFullSync
    );


NTSTATUS
SamIGetPrivateData(
    IN SAMPR_HANDLE SamHandle,
    IN PSAMI_PRIVATE_DATA_TYPE PrivateDataType,
    OUT PBOOLEAN SensitiveData,
    OUT PULONG DataLength,
    OUT PVOID *Data
    );

NTSTATUS
SamISetPrivateData(
    IN SAMPR_HANDLE SamHandle,
    IN ULONG DataLength,
    IN PVOID Data
    );

NTSTATUS
SamISetAuditingInformation(
    IN PPOLICY_AUDIT_EVENTS_INFO PolicyAuditEventsInfo
    );

NTSTATUS
SamINotifyDelta (
    IN SAMPR_HANDLE DomainHandle,
    IN SECURITY_DB_DELTA_TYPE DeltaType,
    IN SECURITY_DB_OBJECT_TYPE ObjectType,
    IN ULONG ObjectRid,
    IN PUNICODE_STRING ObjectName,
    IN ULONG ReplicateImmediately,
    IN PSAM_DELTA_DATA DeltaData OPTIONAL
    );

NTSTATUS
SamIEnumerateAccountRids(
    IN  SAMPR_HANDLE DomainHandle,
    IN  ULONG AccountTypesMask,
    IN  ULONG StartingRid,
    IN  ULONG PreferedMaximumLength,
    OUT PULONG ReturnCount,
    OUT PULONG *AccountRids
    );

NTSTATUS
SamIGetUserLogonInformation(
    IN  SAMPR_HANDLE DomainHandle,
    IN  ULONG   Flags,
    IN  PUNICODE_STRING AccountName,
    OUT PSAMPR_USER_INFO_BUFFER * Buffer,
    OUT PSID_AND_ATTRIBUTES_LIST ReverseMembership,
    OUT OPTIONAL SAMPR_HANDLE * UserHandle
    );

NTSTATUS
SamIGetUserLogonInformationEx(
    IN  SAMPR_HANDLE DomainHandle,
    IN  ULONG   Flags,
    IN  PUNICODE_STRING AccountName,
    IN  ULONG           WhichFields,
    OUT PSAMPR_USER_INFO_BUFFER * Buffer,
    OUT PSID_AND_ATTRIBUTES_LIST ReverseMembership,
    OUT OPTIONAL SAMPR_HANDLE * UserHandle
    );

NTSTATUS
SamIGetUserLogonInformation2(
    IN  SAMPR_HANDLE DomainHandle,
    IN  ULONG   Flags,
    IN  PUNICODE_STRING AccountName,
    IN  ULONG           WhichFields,
    IN  ULONG           ExtendedFields,
    OUT PUSER_INTERNAL6_INFORMATION * Buffer,
    OUT PSID_AND_ATTRIBUTES_LIST ReverseMembership,
    OUT OPTIONAL SAMPR_HANDLE * UserHandle
    );

NTSTATUS
SamIGetResourceGroupMembershipsTransitive(
    IN SAMPR_HANDLE         DomainHandle,
    IN PSAMPR_PSID_ARRAY    SidArray,
    IN ULONG                Flags,
    OUT PSAMPR_PSID_ARRAY * Membership
    );


NTSTATUS
SamIGetAliasMembership(
    IN SAMPR_HANDLE DomainHandle,
    IN PSAMPR_PSID_ARRAY SidArray,
    OUT PSAMPR_ULONG_ARRAY Membership
    );


NTSTATUS
SamIOpenUserByAlternateId(
    IN SAMPR_HANDLE DomainHandle,
    IN ACCESS_MASK DesiredAccess,
    IN PUNICODE_STRING AlternateId,
    OUT SAMPR_HANDLE *UserHandle
    );

NTSTATUS
SamIOpenAccount(
    IN SAMPR_HANDLE         DomainHandle,
    IN ULONG                AccountRid,
    IN SECURITY_DB_OBJECT_TYPE ObjectType,
    OUT SAMPR_HANDLE        *AccountHandle
    );

NTSTATUS
SamIChangePasswordForeignUser(
    IN PUNICODE_STRING UserName,
    IN PUNICODE_STRING NewPassword,
    IN OPTIONAL HANDLE ClientToken,
    IN ACCESS_MASK DesiredAccess
    );

NTSTATUS
SamIChangePasswordForeignUser2(
    IN PSAM_CLIENT_INFO ClientInfo, OPTIONAL
    IN PUNICODE_STRING UserName,
    IN PUNICODE_STRING NewPassword,
    IN OPTIONAL HANDLE ClientToken,
    IN ACCESS_MASK DesiredAccess
    );

NTSTATUS
SamISetPasswordForeignUser(
    IN PUNICODE_STRING UserName,
    IN PUNICODE_STRING NewPassword,
    IN HANDLE ClientToken
    );

NTSTATUS
SamISetPasswordForeignUser2(
    IN PSAM_CLIENT_INFO ClientInfo, OPTIONAL
    IN PUNICODE_STRING UserName,
    IN PUNICODE_STRING NewPassword,
    IN HANDLE ClientToken
    );

NTSTATUS
SamIGetDefaultComputersContainer(
    OUT PVOID *DefaultComputersContainer
    );

NTSTATUS
SamIPromote(
    IN  ULONG                        PromoteFlags,
    IN  PPOLICY_PRIMARY_DOMAIN_INFO  NewPrimaryDomainInfo  OPTIONAL,
    IN  PUNICODE_STRING              AdminPassword         OPTIONAL,
    IN  PUNICODE_STRING              SafeModeAdminPassword OPTIONAL
    );

NTSTATUS
SamIPromoteUndo(
    VOID
    );

NTSTATUS
SamIDemote(
    IN ULONG                        DemoteFlags,
    IN PPOLICY_ACCOUNT_DOMAIN_INFO  NewAccountDomainInfo,
    IN LPWSTR                       AdminPassword  OPTIONAL
    );

NTSTATUS
SamIDemoteUndo(
    VOID
    );

NTSTATUS
SamIReplaceDownlevelDatabase(
    IN PPOLICY_ACCOUNT_DOMAIN_INFO  NewAccountDomainInfo,
    IN LPWSTR                       NewAdminPassword,
    OUT ULONG                      *ExtendedWinError OPTIONAL
    );

NTSTATUS
SamILoadDownlevelDatabase(
    OUT ULONG *ExtendedWinError  OPTIONAL
    );

NTSTATUS
SamIUnLoadDownlevelDatabase(
    OUT ULONG *ExtendedWinError  OPTIONAL
    );

BOOLEAN
SamIMixedDomain(
  IN SAMPR_HANDLE DomainHandle
  );

NTSTATUS
SamIMixedDomain2(
  IN PSID DomainSid,
  OUT BOOLEAN * MixedDomain
  );

NTSTATUS
SamIDoFSMORoleChange(
  IN SAMPR_HANDLE DomainHandle
  );

NTSTATUS
SamINotifyRoleChange(
  IN PSID  DomainSid,
  IN DOMAIN_SERVER_ROLE NewRole
  );

NTSTATUS
SamIQueryServerRole(
  IN SAMPR_HANDLE DomainHandle,
  OUT DOMAIN_SERVER_ROLE *ServerRole
  );


NTSTATUS
SamIQueryServerRole2(
    IN PSID DomainSid,
    OUT DOMAIN_SERVER_ROLE *ServerRole
    );

NTSTATUS
SamISameSite(
  OUT BOOLEAN * result
  );

//
// Routines called by the NTDSA
//
typedef enum
{
    SampNotifySiteChanged = 0

} SAMP_NOTIFY_SERVER_CHANGE;

VOID
SamINotifyServerDelta(
    IN SAMP_NOTIFY_SERVER_CHANGE Change
    );


///////////////////////////////////////////////////////////////
//                                                           //
// The following functions are used to support in process    //
// client operations for upgrades from NT4.                  //
//                                                           //
///////////////////////////////////////////////////////////////

BOOLEAN
SamINT4UpgradeInProgress(
    VOID
    );

NTSTATUS
SamIEnumerateInterdomainTrustAccountsForUpgrade(
    IN OUT PULONG   EnumerationContext,
    OUT PSAMPR_ENUMERATION_BUFFER *Buffer,
    IN ULONG       PreferredMaximumLength,
    OUT PULONG     CountReturned
    );

NTSTATUS
SamIGetInterdomainTrustAccountPasswordsForUpgrade(
   IN ULONG AccountRid,
   OUT PUCHAR NtOwfPassword,
   OUT BOOLEAN *NtPasswordPresent,
   OUT PUCHAR LmOwfPassword,
   OUT BOOLEAN *LmPasswordPresent
   );

//
// Values to pass in as Options SamIGCLookup*
//

//
// Indicates to lookup by sid history as well
//
#define SAMP_LOOKUP_BY_SID_HISTORY     0x00000001

//
// Indicates to lookp by UPN as well
//
#define SAMP_LOOKUP_BY_UPN             0x00000002

//
// Values to be returned in Flags
//

//
// Indicates the Sid was resolved by Sid History
//
#define SAMP_FOUND_BY_SID_HISTORY      0x00000001

//
// Indicates the name passed in was the sam account name (UPN)
//
#define SAMP_FOUND_BY_SAM_ACCOUNT_NAME 0x00000002

//
// Indicates that entry was not resolved but does belong to an externally
// trusted forest
//
#define SAMP_FOUND_XFOREST_REF         0x00000004

NTSTATUS
SamIGCLookupSids(
    IN ULONG            cSids,
    IN PSID            *SidArray,
    IN ULONG            Options,
    OUT ULONG           *Flags,
    OUT SID_NAME_USE    *SidNameUse,
    OUT PSAMPR_RETURNED_USTRING_ARRAY Names
    );

NTSTATUS
SamIGCLookupNames(
    IN ULONG           cNames,
    IN PUNICODE_STRING Names,
    IN ULONG           Options,
    OUT ULONG           *Flags,
    OUT SID_NAME_USE  *SidNameUse,
    OUT PSAMPR_PSID_ARRAY *SidArray
    );

#ifdef __SECPKG_H__


NTSTATUS
SamIStorePrimaryCredentials(
    IN SAMPR_HANDLE UserHandle,
    IN PSECPKG_SUPPLEMENTAL_CRED Credentials
    );

NTSTATUS
SamIRetrievePrimaryCredentials(
    IN SAMPR_HANDLE UserHandle,
    IN PUNICODE_STRING PackageName,
    OUT PVOID * Credentials,
    OUT PULONG CredentialSize
    );

NTSTATUS
SamIStoreSupplementalCredentials(
    IN SAMPR_HANDLE UserHandle,
    IN PSECPKG_SUPPLEMENTAL_CRED Credentials
    );

NTSTATUS
SamIRetriveSupplementalCredentials(
    IN SAMPR_HANDLE UserHandle,
    IN PUNICODE_STRING PackageName,
    OUT PVOID * Credentials,
    OUT PULONG CredentialSize
    );

NTSTATUS
SamIRetriveAllSupplementalCredentials(
    IN SAMPR_HANDLE UserHandle,
    OUT PSECPKG_SUPPLEMENTAL_CRED * Credentials,
    OUT PULONG CredentialCount
    );
#endif

VOID
SamIFree_SAMPR_SR_SECURITY_DESCRIPTOR (
    PSAMPR_SR_SECURITY_DESCRIPTOR Source
    );

VOID
SamIFree_SAMPR_DOMAIN_INFO_BUFFER (
    PSAMPR_DOMAIN_INFO_BUFFER Source,
    DOMAIN_INFORMATION_CLASS Branch
    );

VOID
SamIFree_SAMPR_ENUMERATION_BUFFER (
    PSAMPR_ENUMERATION_BUFFER Source
    );

VOID
SamIFree_SAMPR_PSID_ARRAY (
    PSAMPR_PSID_ARRAY Source
    );

VOID
SamIFree_SAMPR_ULONG_ARRAY (
    PSAMPR_ULONG_ARRAY Source
    );

VOID
SamIFree_SAMPR_RETURNED_USTRING_ARRAY (
    PSAMPR_RETURNED_USTRING_ARRAY Source
    );

VOID
SamIFree_SAMPR_GROUP_INFO_BUFFER (
    PSAMPR_GROUP_INFO_BUFFER Source,
    GROUP_INFORMATION_CLASS Branch
    );

VOID
SamIFree_SAMPR_ALIAS_INFO_BUFFER (
    PSAMPR_ALIAS_INFO_BUFFER Source,
    ALIAS_INFORMATION_CLASS Branch
    );

VOID
SamIFree_SAMPR_GET_MEMBERS_BUFFER (
    PSAMPR_GET_MEMBERS_BUFFER Source
    );

VOID
SamIFree_SAMPR_USER_INFO_BUFFER (
    PSAMPR_USER_INFO_BUFFER Source,
    USER_INFORMATION_CLASS Branch
    );

VOID
SamIFree_SAMPR_GET_GROUPS_BUFFER (
    PSAMPR_GET_GROUPS_BUFFER Source
    );

VOID
SamIFree_SAMPR_DISPLAY_INFO_BUFFER (
    PSAMPR_DISPLAY_INFO_BUFFER Source,
    DOMAIN_DISPLAY_INFORMATION Branch
    );

VOID
SamIFree_UserInternal6Information (
   PUSER_INTERNAL6_INFORMATION  Source
   );

VOID
SamIFreeSidAndAttributesList(
    IN  PSID_AND_ATTRIBUTES_LIST List
    );

VOID
SamIFreeSidArray(
    IN  PSAMPR_PSID_ARRAY List
    );

VOID
SamIFreeVoid(
    IN  PVOID ptr
    );


BOOLEAN
SampUsingDsData();

BOOLEAN
SamIAmIGC();

typedef enum _SAM_PERF_COUNTER_TYPE {
    MsvLogonCounter,
    KerbServerContextCounter,
    KdcAsReqCounter,
    KdcTgsReqCounter
} SAM_PERF_COUNTER_TYPE, *PSAM_PERF_COUNTER_TYPE;

VOID
SamIIncrementPerformanceCounter(
    IN SAM_PERF_COUNTER_TYPE CounterType
    );
    

BOOLEAN SamIIsSetupInProgress(
          OUT BOOLEAN * fUpgrade
          );

BOOLEAN SamIIsDownlevelDcUpgrade();

NTSTATUS
SamIGetBootKeyInformation(
    IN SAMPR_HANDLE DomainHandle,
    OUT PSAMPR_BOOT_TYPE BootOptions
    );

NTSTATUS
SamIGetDefaultAdministratorName(
    OUT LPWSTR Name,  OPTIONAL
    IN OUT ULONG  *NameLength
    );

BOOLEAN
SamIIsExtendedSidMode(
    IN SAMPR_HANDLE DomainHandle
    );
    
NTSTATUS
SamINetLogonPing(
    IN  SAMPR_HANDLE    DomainHandle,
    IN  PUNICODE_STRING AccountName,
    OUT BOOLEAN         *AccountExists,
    OUT PULONG          UserAccountControl
    );

NTSTATUS
SamIUPNFromUserHandle(
    IN SAMPR_HANDLE UserHandle,
    OUT BOOLEAN     *UPNDefaulted,
    OUT PUNICODE_STRING UPN
    );

BOOLEAN
SamIIsRebootAfterPromotion(
    );
    
BOOLEAN
SamIIsAttributeProtected(
    IN GUID *Attribute
    );
    


#endif // _SAMISRV_
=== C:/Users/treeman/Desktop/windows nt source code\Source\Win2K3\NT\public\internal\ds\inc\rxserver.h ===
/*++

Copyright (c) 1991  Microsoft Corporation

Module Name:

    RxServer.h

Abstract:

    This is the public header file for the NT version of RpcXlate.
    This contains prototypes for the RxNetServer APIs and old info level
    structures (in 32-bit format).

Author:

    John Rogers (JohnRo) 01-May-1991

Environment:

    Portable to any flat, 32-bit environment.  (Uses Win32 typedefs.)
    Requires ANSI C extensions: slash-slash comments, long external names.

Notes:

    You must include <windef.h>, <lmcons.h>, and <rap.h> before this file.

Revision History:

    01-May-1991 JohnRo
        Created.
    26-May-1991 JohnRo
        Added incomplete output parm to RxGetServerInfoLevelEquivalent.
    04-Dec-1991 JohnRo
        Change RxNetServerSetInfo() to new-style interface.

--*/

#ifndef _RXSERVER_
#define _RXSERVER_


//
// Handlers for individual APIs:
// (Add prototypes for other APIs here, in alphabetical order.)
//

NET_API_STATUS
RxNetServerDiskEnum (
    IN LPTSTR UncServerName,
    IN DWORD Level,
    OUT LPBYTE *BufPtr,
    IN DWORD PrefMaxSize,
    OUT LPDWORD EntriesRead,
    OUT LPDWORD TotalEntries,
    IN OUT LPDWORD Resume_Handle OPTIONAL
    );

NET_API_STATUS
RxNetServerEnum (
    IN LPCWSTR UncServerName,
    IN LPCWSTR TransportName,
    IN DWORD Level,
    OUT LPBYTE *BufPtr,
    IN DWORD PrefMaxSize,
    OUT LPDWORD EntriesRead,
    OUT LPDWORD TotalEntries,
    IN DWORD ServerType,
    IN LPCWSTR Domain OPTIONAL,
    IN LPCWSTR FirstNameToReturn OPTIONAL
    );

NET_API_STATUS
RxNetServerGetInfo (
    IN LPTSTR UncServerName,
    IN DWORD Level,             // May be old or new info level.
    OUT LPBYTE *BufPtr
    );

NET_API_STATUS
RxNetServerSetInfo (
    IN LPTSTR UncServerName,
    IN DWORD Level,             // Level and/or ParmNum
    IN LPBYTE Buf,
    OUT LPDWORD ParmError OPTIONAL
    );

//
// Equates for set-info handling.
//
#define NEW_SERVER_SUPERSET_LEVEL       102
#define OLD_SERVER_SUPERSET_LEVEL       3


//
// Server-specific common routines:
//

NET_API_STATUS
RxGetServerInfoLevelEquivalent (
    IN DWORD FromLevel,
    IN BOOL FromNative,
    IN BOOL ToNative,
    OUT LPDWORD ToLevel,
    OUT LPDESC * ToDataDesc16 OPTIONAL,
    OUT LPDESC * ToDataDesc32 OPTIONAL,
    OUT LPDESC * ToDataDescSmb OPTIONAL,
    OUT LPDWORD FromMaxSize OPTIONAL,
    OUT LPDWORD FromFixedSize OPTIONAL,
    OUT LPDWORD FromStringSize OPTIONAL,
    OUT LPDWORD ToMaxSize OPTIONAL,
    OUT LPDWORD ToFixedSize OPTIONAL,
    OUT LPDWORD ToStringSize OPTIONAL,
    OUT LPBOOL IncompleteOutput OPTIONAL
    );

#endif // ndef _RXSERVER_
=== C:/Users/treeman/Desktop/windows nt source code\Source\Win2K3\NT\public\internal\ds\inc\rxprint.h ===
/*++

Copyright (c) 1991-1993  Microsoft Corporation

Module Name:

    RxPrint.h

Abstract:

    This contains prototypes for the RxPrint routines.

Author:

    Dave Snipp (DaveSn) 16-Apr-1991

Environment:

Notes:

    All of the RxPrint APIs are wide-character APIs, regardless of
    whether or not UNICODE is defined.  This allows the net/dosprint/dosprint.c
    code to use the winspool APIs (which are currently ANSI APIs, despite their
    prototypes using LPTSTR in some places).

Revision History:

    22-Apr-1991 JohnRo
        Use constants from <lmcons.h>.
    14-May-1991 JohnRo
        Change WORD to DWORD in all parameter lists.  Similarly, change
        PWORD to LPDWORD and PUSHORT to LPDWORD.
    18-May-1991 JohnRo
        Changed SPLERR to be defined as NET_API_STATUS.
    22-May-1991 CliffV
        Added local definitions of PDLEN and DTLEN since they are no longer
        in lmcons.h.
    26-May-1991 JohnRo
        Use IN, OUT, OPTIONAL, LPVOID, LPTSTR, etc.
    18-Jun-1991 JohnRo
        Deleted RxPrintJobGetId, as it will be an IOCTL rather than a remoted
        API.
    26-Jun-1991 CliffV
        Used LM2.0 versions of CNLEN, UNLEN, and QNLEN.
    16-Jul-1991 JohnRo
        Estimate bytes needed for print APIs.
    16-Jun-1992 JohnRo
        RAID 10324: net print vs. UNICODE.
    08-Feb-1993 JohnRo
        RAID 10164: Data misalignment error during XsDosPrintQGetInfo().
    07-Apr-1993 JohnRo
        RAID 5670: "NET PRINT \\server\share" gives err 124 (bad level) on NT.

--*/

#ifndef _RXPRINT_
#define _RXPRINT_

#include <windef.h>     // DWORD, LPVOID, LPTSTR, TCHAR, etc.
#include <lmcons.h>     // LM20_CNLEN, IN, NET_API_STATUS, etc.

#define SPLENTRY pascal far

/* length for character arrays in structures (excluding zero terminator) */
#define PDLEN               8                  /* Print destination length  */
#define DTLEN               9                  /* Spool file data type      */
//                                             /* e.g. PM_Q_STD,PM_Q_RAW    */
#define QP_DATATYPE_SIZE 15                 /* returned by SplQpQueryDt  */
#define DRIV_DEVICENAME_SIZE 31             /* see DRIVDATA struc        */
#define DRIV_NAME_SIZE 8                    /* name of device driver     */
#define PRINTERNAME_SIZE 32                 /* max printer name length   */
#define FORMNAME_SIZE 31                    /* max form name length      */
// #define MAXCOMMENTSZ    48                  /* queue comment length      */

/**INTERNAL_ONLY**/
/* IOctl for RxPrintJobGetId */
#define SPOOL_LMCAT                     83
#define SPOOL_LMGetPrintId              0x60

// Used in remdef.h for structure definition to marshall data
#define MAX_DEPENDENT_FILES             64
/**END_INTERNAL**/


typedef NET_API_STATUS SPLERR;    /* err */


typedef struct _PRJINFOA {   /* prj1 */
    WORD    uJobId;
    CHAR    szUserName[LM20_UNLEN+1];
    CHAR    pad_1;
    CHAR    szNotifyName[LM20_CNLEN+1];
    CHAR    szDataType[DTLEN+1];
    LPSTR   pszParms;
    WORD    uPosition;
    WORD    fsStatus;
    LPSTR   pszStatus;
    DWORD   ulSubmitted;
    DWORD   ulSize;
    LPSTR   pszComment;
} PRJINFOA;
typedef struct _PRJINFOW {   /* prj1 */
    WORD    uJobId;
    WCHAR   szUserName[LM20_UNLEN+1];
    WCHAR   pad_1;
    WCHAR   szNotifyName[LM20_CNLEN+1];
    WCHAR   szDataType[DTLEN+1];
    LPWSTR  pszParms;
    WORD    uPosition;
    WORD    fsStatus;
    LPWSTR  pszStatus;
    DWORD   ulSubmitted;
    DWORD   ulSize;
    LPWSTR  pszComment;
} PRJINFOW;
#ifdef UNICODE
typedef PRJINFOW PRJINFO;
#else
typedef PRJINFOA PRJINFO;
#endif // UNICODE
typedef PRJINFOA far *PPRJINFOA;
typedef PRJINFOW far *PPRJINFOW;
#ifdef UNICODE
typedef PPRJINFOW PPRJINFO;
#else
typedef PPRJINFOA PPRJINFO;
#endif // UNICODE
typedef PRJINFOA near *NPPRJINFOA;
typedef PRJINFOW near *NPPRJINFOW;
#ifdef UNICODE
typedef NPPRJINFOW NPPRJINFO;
#else
typedef NPPRJINFOA NPPRJINFO;
#endif // UNICODE

typedef struct _PRJINFO2A {   /* prj2 */
    WORD    uJobId;
    WORD    uPriority;
    LPSTR   pszUserName;
    WORD    uPosition;
    WORD    fsStatus;
    DWORD   ulSubmitted;
    DWORD   ulSize;
    LPSTR   pszComment;
    LPSTR   pszDocument;
} PRJINFO2A;
typedef struct _PRJINFO2W {   /* prj2 */
    WORD    uJobId;
    WORD    uPriority;
    LPWSTR  pszUserName;
    WORD    uPosition;
    WORD    fsStatus;
    DWORD   ulSubmitted;
    DWORD   ulSize;
    LPWSTR  pszComment;
    LPWSTR  pszDocument;
} PRJINFO2W;
#ifdef UNICODE
typedef PRJINFO2W PRJINFO2;
#else
typedef PRJINFO2A PRJINFO2;
#endif // UNICODE
typedef PRJINFO2A far *PPRJINFO2A;
typedef PRJINFO2W far *PPRJINFO2W;
#ifdef UNICODE
typedef PPRJINFO2W PPRJINFO2;
#else
typedef PPRJINFO2A PPRJINFO2;
#endif // UNICODE
typedef PRJINFO2A near *NPPRJINFO2A;
typedef PRJINFO2W near *NPPRJINFO2W;
#ifdef UNICODE
typedef NPPRJINFO2W NPPRJINFO2;
#else
typedef NPPRJINFO2A NPPRJINFO2;
#endif // UNICODE

typedef struct _PRJINFO3A {   /* prj */
    WORD    uJobId;
    WORD    uPriority;
    LPSTR   pszUserName;
    WORD    uPosition;
    WORD    fsStatus;
    DWORD   ulSubmitted;
    DWORD   ulSize;
    LPSTR   pszComment;
    LPSTR   pszDocument;
    LPSTR   pszNotifyName;
    LPSTR   pszDataType;
    LPSTR   pszParms;
    LPSTR   pszStatus;
    LPSTR   pszQueue;
    LPSTR   pszQProcName;
    LPSTR   pszQProcParms;
    LPSTR   pszDriverName;
    LPVOID  pDriverData;
    LPSTR   pszPrinterName;
} PRJINFO3A;
typedef struct _PRJINFO3W {   /* prj */
    WORD    uJobId;
    WORD    uPriority;
    LPWSTR  pszUserName;
    WORD    uPosition;
    WORD    fsStatus;
    DWORD   ulSubmitted;
    DWORD   ulSize;
    LPWSTR  pszComment;
    LPWSTR  pszDocument;
    LPWSTR  pszNotifyName;
    LPWSTR  pszDataType;
    LPWSTR  pszParms;
    LPWSTR  pszStatus;
    LPWSTR  pszQueue;
    LPWSTR  pszQProcName;
    LPWSTR  pszQProcParms;
    LPWSTR  pszDriverName;
    LPVOID  pDriverData;
    LPWSTR  pszPrinterName;
} PRJINFO3W;
#ifdef UNICODE
typedef PRJINFO3W PRJINFO3;
#else
typedef PRJINFO3A PRJINFO3;
#endif // UNICODE
typedef PRJINFO3A far *PPRJINFO3A;
typedef PRJINFO3W far *PPRJINFO3W;
#ifdef UNICODE
typedef PPRJINFO3W PPRJINFO3;
#else
typedef PPRJINFO3A PPRJINFO3;
#endif // UNICODE
typedef PRJINFO3A near *NPPRJINFO3A;
typedef PRJINFO3W near *NPPRJINFO3W;
#ifdef UNICODE
typedef NPPRJINFO3W NPPRJINFO3;
#else
typedef NPPRJINFO3A NPPRJINFO3;
#endif // UNICODE


typedef struct _PRDINFOA {    /* prd1 */
    CHAR    szName[PDLEN+1];
    CHAR    szUserName[LM20_UNLEN+1];
    WORD    uJobId;
    WORD    fsStatus;
    LPSTR   pszStatus;
    WORD    time;
} PRDINFOA;
typedef struct _PRDINFOW {    /* prd1 */
    WCHAR   szName[PDLEN+1];
    WCHAR   szUserName[LM20_UNLEN+1];
    WORD    uJobId;
    WORD    fsStatus;
    LPWSTR  pszStatus;
    WORD    time;
} PRDINFOW;
#ifdef UNICODE
typedef PRDINFOW PRDINFO;
#else
typedef PRDINFOA PRDINFO;
#endif // UNICODE
typedef PRDINFOA far *PPRDINFOA;
typedef PRDINFOW far *PPRDINFOW;
#ifdef UNICODE
typedef PPRDINFOW PPRDINFO;
#else
typedef PPRDINFOA PPRDINFO;
#endif // UNICODE
typedef PRDINFOA near *NPPRDINFOA;
typedef PRDINFOW near *NPPRDINFOW;
#ifdef UNICODE
typedef NPPRDINFOW NPPRDINFO;
#else
typedef NPPRDINFOA NPPRDINFO;
#endif // UNICODE


typedef struct _PRDINFO3A {   /* prd */
    LPSTR   pszPrinterName;
    LPSTR   pszUserName;
    LPSTR   pszLogAddr;
    WORD    uJobId;
    WORD    fsStatus;
    LPSTR   pszStatus;
    LPSTR   pszComment;
    LPSTR   pszDrivers;
    WORD    time;
    WORD    pad1;
} PRDINFO3A;
typedef struct _PRDINFO3W {   /* prd */
    LPWSTR  pszPrinterName;
    LPWSTR  pszUserName;
    LPWSTR  pszLogAddr;
    WORD    uJobId;
    WORD    fsStatus;
    LPWSTR  pszStatus;
    LPWSTR  pszComment;
    LPWSTR  pszDrivers;
    WORD    time;
    WORD    pad1;
} PRDINFO3W;
#ifdef UNICODE
typedef PRDINFO3W PRDINFO3;
#else
typedef PRDINFO3A PRDINFO3;
#endif // UNICODE
typedef PRDINFO3A far *PPRDINFO3A;
typedef PRDINFO3W far *PPRDINFO3W;
#ifdef UNICODE
typedef PPRDINFO3W PPRDINFO3;
#else
typedef PPRDINFO3A PPRDINFO3;
#endif // UNICODE
typedef PRDINFO3A near *NPPRDINFO3A;
typedef PRDINFO3W near *NPPRDINFO3W;
#ifdef UNICODE
typedef NPPRDINFO3W NPPRDINFO3;
#else
typedef NPPRDINFO3A NPPRDINFO3;
#endif // UNICODE


typedef struct _PRQINFOA {   /* prq1 */
    CHAR    szName[LM20_QNLEN+1];
    CHAR    pad_1;
    WORD    uPriority;
    WORD    uStartTime;
    WORD    uUntilTime;
    LPSTR   pszSepFile;
    LPSTR   pszPrProc;
    LPSTR   pszDestinations;
    LPSTR   pszParms;
    LPSTR   pszComment;
    WORD    fsStatus;
    WORD    cJobs;
} PRQINFOA;
typedef struct _PRQINFOW {   /* prq1 */
    WCHAR   szName[LM20_QNLEN+1];
    WCHAR   pad_1;
    WORD    uPriority;
    WORD    uStartTime;
    WORD    uUntilTime;
    LPWSTR  pszSepFile;
    LPWSTR  pszPrProc;
    LPWSTR  pszDestinations;
    LPWSTR  pszParms;
    LPWSTR  pszComment;
    WORD    fsStatus;
    WORD    cJobs;
} PRQINFOW;
#ifdef UNICODE
typedef PRQINFOW PRQINFO;
#else
typedef PRQINFOA PRQINFO;
#endif // UNICODE
typedef PRQINFOA far *PPRQINFOA;
typedef PRQINFOW far *PPRQINFOW;
#ifdef UNICODE
typedef PPRQINFOW PPRQINFO;
#else
typedef PPRQINFOA PPRQINFO;
#endif // UNICODE
typedef PRQINFOA near *NPPRQINFOA;
typedef PRQINFOW near *NPPRQINFOW;
#ifdef UNICODE
typedef NPPRQINFOW NPPRQINFO;
#else
typedef NPPRQINFOA NPPRQINFO;
#endif // UNICODE


typedef struct _PRQINFO3A {  /* prq */
    LPSTR   pszName;
    WORD    uPriority;
    WORD    uStartTime;
    WORD    uUntilTime;
    WORD    pad1;
    LPSTR   pszSepFile;
    LPSTR   pszPrProc;
    LPSTR   pszParms;
    LPSTR   pszComment;
    WORD    fsStatus;
    WORD    cJobs;
    LPSTR   pszPrinters;
    LPSTR   pszDriverName;
    LPVOID  pDriverData;
} PRQINFO3A;
typedef struct _PRQINFO3W {  /* prq */
    LPWSTR  pszName;
    WORD    uPriority;
    WORD    uStartTime;
    WORD    uUntilTime;
    WORD    pad1;
    LPWSTR  pszSepFile;
    LPWSTR  pszPrProc;
    LPWSTR  pszParms;
    LPWSTR  pszComment;
    WORD    fsStatus;
    WORD    cJobs;
    LPWSTR  pszPrinters;
    LPWSTR  pszDriverName;
    LPVOID  pDriverData;
} PRQINFO3W;
#ifdef UNICODE
typedef PRQINFO3W PRQINFO3;
#else
typedef PRQINFO3A PRQINFO3;
#endif // UNICODE
typedef PRQINFO3A far *PPRQINFO3A;
typedef PRQINFO3W far *PPRQINFO3W;
#ifdef UNICODE
typedef PPRQINFO3W PPRQINFO3;
#else
typedef PPRQINFO3A PPRQINFO3;
#endif // UNICODE
typedef PRQINFO3A near *NPPRQINFO3A;
typedef PRQINFO3W near *NPPRQINFO3W;
#ifdef UNICODE
typedef NPPRQINFO3W NPPRQINFO3;
#else
typedef NPPRQINFO3A NPPRQINFO3;
#endif // UNICODE


typedef struct _PRQINFO52A {  /* prq */
    WORD        uVersion;
    LPSTR       pszModelName;
    LPSTR       pszDriverName;
    LPSTR       pszDataFileName;
    LPSTR       pszMonitorName;
    LPSTR       pszDriverPath;
    LPSTR       pszDefaultDataType;
    LPSTR       pszHelpFile;
    LPSTR       pszConfigFile;
    WORD        cDependentNames;
    LPSTR       pszDependentNames[MAX_DEPENDENT_FILES];
} PRQINFO52A;
typedef struct _PRQINFO52W {  /* prq */
    WORD        uVersion;
    LPWSTR      pszModelName;
    LPWSTR      pszDriverName;
    LPWSTR      pszDataFileName;
    LPWSTR      pszMonitorName;
    LPWSTR      pszDriverPath;
    LPWSTR      pszDefaultDataType;
    LPWSTR      pszHelpFile;
    LPWSTR      pszConfigFile;
    WORD        cDependentNames;
    LPWSTR      pszDependentNames[MAX_DEPENDENT_FILES];
} PRQINFO52W;
#ifdef UNICODE
typedef PRQINFO52W PRQINFO52;
#else
typedef PRQINFO52A PRQINFO52;
#endif // UNICODE
typedef PRQINFO52A far *PPRQINFO52A;
typedef PRQINFO52W far *PPRQINFO52W;
#ifdef UNICODE
typedef PPRQINFO52W PPRQINFO52;
#else
typedef PPRQINFO52A PPRQINFO52;
#endif // UNICODE
typedef PRQINFO52A near *NPPRQINFO52A;
typedef PRQINFO52W near *NPPRQINFO52W;
#ifdef UNICODE
typedef NPPRQINFO52W NPPRQINFO52;
#else
typedef NPPRQINFO52A NPPRQINFO52;
#endif // UNICODE


/*
 * structure for RxPrintJobGetId
 */
typedef struct _PRIDINFOA {  /* prjid */
    WORD    uJobId;
    CHAR    szServer[LM20_CNLEN + 1];
    CHAR    szQName[LM20_QNLEN+1];
    CHAR    pad_1;
} PRIDINFOA;
/*
 * structure for RxPrintJobGetId
 */
typedef struct _PRIDINFOW {  /* prjid */
    WORD    uJobId;
    WCHAR   szServer[LM20_CNLEN + 1];
    WCHAR   szQName[LM20_QNLEN+1];
    CHAR    pad_1;
} PRIDINFOW;
#ifdef UNICODE
typedef PRIDINFOW PRIDINFO;
#else
typedef PRIDINFOA PRIDINFO;
#endif // UNICODE
typedef PRIDINFOA far *PPRIDINFOA;
typedef PRIDINFOW far *PPRIDINFOW;
#ifdef UNICODE
typedef PPRIDINFOW PPRIDINFO;
#else
typedef PPRIDINFOA PPRIDINFO;
#endif // UNICODE
typedef PRIDINFOA near *NPPRIDINFOA;
typedef PRIDINFOW near *NPPRIDINFOW;
#ifdef UNICODE
typedef NPPRIDINFOW NPPRIDINFO;
#else
typedef NPPRIDINFOA NPPRIDINFO;
#endif // UNICODE


/****************************************************************
 *                                                              *
 *              Function prototypes                             *
 *                                                              *
 ****************************************************************/

SPLERR SPLENTRY RxPrintDestEnum(
            IN LPTSTR pszServer,
            IN DWORD uLevel,
            OUT LPBYTE pbBuf,
            IN DWORD cbBuf,
            IN LPDWORD pcReturned,
            OUT LPDWORD pcTotal
            );

SPLERR SPLENTRY RxPrintDestControl(
            IN LPTSTR pszServer,
            IN LPTSTR pszDevName,
            IN DWORD uControl
            );

SPLERR SPLENTRY RxPrintDestGetInfo(
            IN LPTSTR pszServer,
            IN LPTSTR pszName,
            IN DWORD uLevel,
            OUT LPBYTE pbBuf,
            IN DWORD cbBuf,
            OUT LPDWORD pcbNeeded   // estimated (probably too large).
            );

SPLERR SPLENTRY RxPrintDestAdd(
            IN LPTSTR pszServer,
            IN DWORD uLevel,
            IN LPBYTE pbBuf,
            IN DWORD cbBuf
            );

SPLERR SPLENTRY RxPrintDestSetInfo(
            IN LPTSTR pszServer,
            IN LPTSTR pszName,
            IN DWORD uLevel,
            IN LPBYTE pbBuf,
            IN DWORD cbBuf,
            IN DWORD uParmNum
            );

SPLERR SPLENTRY RxPrintDestDel(
            IN LPTSTR pszServer,
            IN LPTSTR pszPrinterName
            );

SPLERR SPLENTRY RxPrintQEnum(
            IN LPTSTR pszServer,
            IN DWORD uLevel,
            OUT LPBYTE pbBuf,
            IN DWORD cbBuf,
            OUT LPDWORD pcReturned,
            OUT LPDWORD pcTotal
            );

SPLERR SPLENTRY RxPrintQGetInfo(
            IN LPTSTR pszServer,
            IN LPTSTR pszQueueName,
            IN DWORD uLevel,
            OUT LPBYTE pbBuf,
            IN DWORD cbBuf,
            OUT LPDWORD pcbNeeded   // estimated (probably too large).
            );

SPLERR SPLENTRY RxPrintQSetInfo(
            IN LPTSTR pszServer,
            IN LPTSTR pszQueueName,
            IN DWORD uLevel,
            IN LPBYTE pbBuf,
            IN DWORD cbBuf,
            IN DWORD uParmNum
            );

SPLERR SPLENTRY RxPrintQPause(
            IN LPTSTR pszServer,
            IN LPTSTR pszQueueName
            );

SPLERR SPLENTRY RxPrintQContinue(
            IN LPTSTR pszServer,
            IN LPTSTR pszQueueName
            );

SPLERR SPLENTRY RxPrintQPurge(
            IN LPTSTR pszServer,
            IN LPTSTR pszQueueName
            );

SPLERR SPLENTRY RxPrintQAdd(
            IN LPTSTR pszServer,
            IN DWORD uLevel,
            IN LPBYTE pbBuf,
            IN DWORD cbBuf
            );

SPLERR SPLENTRY RxPrintQDel(
            IN LPTSTR pszServer,
            IN LPTSTR pszQueueName
            );

SPLERR SPLENTRY RxPrintJobGetInfo(
            IN LPTSTR pszServer,
            IN DWORD uJobId,
            IN DWORD uLevel,
            OUT LPBYTE pbBuf,
            IN DWORD cbBuf,
            OUT LPDWORD pcbNeeded   // estimated (probably too large).
            );

SPLERR SPLENTRY RxPrintJobSetInfo(
            IN LPTSTR pszServer,
            IN DWORD uJobId,
            IN DWORD uLevel,
            IN LPBYTE pbBuf,
            IN DWORD cbBuf,
            IN DWORD uParmNum
            );

SPLERR SPLENTRY RxPrintJobPause(
            IN LPTSTR pszServer,
            IN DWORD uJobId
            );

SPLERR SPLENTRY RxPrintJobContinue(
            IN LPTSTR pszServer,
            IN DWORD uJobId
            );

SPLERR SPLENTRY RxPrintJobDel(
            IN LPTSTR pszServer,
            IN DWORD uJobId
            );

SPLERR SPLENTRY RxPrintJobEnum(
            IN LPTSTR pszServer,
            IN LPTSTR pszQueueName,
            IN DWORD uLevel,
            OUT LPBYTE pbBuf,
            IN DWORD cbBuf,
            OUT LPDWORD pcReturned,
            OUT LPDWORD pcTotal
            );


/*
 *      Values for parmnum in RxPrintQSetInfo.
 */

#define PRQ_PRIORITY_PARMNUM            2
#define PRQ_STARTTIME_PARMNUM           3
#define PRQ_UNTILTIME_PARMNUM           4
#define PRQ_SEPARATOR_PARMNUM           5
#define PRQ_PROCESSOR_PARMNUM           6
#define PRQ_DESTINATIONS_PARMNUM        7
#define PRQ_PARMS_PARMNUM               8
#define PRQ_COMMENT_PARMNUM             9
#define PRQ_PRINTERS_PARMNUM           12
#define PRQ_DRIVERNAME_PARMNUM         13
#define PRQ_DRIVERDATA_PARMNUM         14
#define PRQ_MAXPARMNUM                 14

/*
 *      Print Queue Priority
 */

#define PRQ_MAX_PRIORITY                1           /* highest priority */
#define PRQ_DEF_PRIORITY                5
#define PRQ_MIN_PRIORITY                9           /* lowest priority */
#define PRQ_NO_PRIORITY                 0

/*
 *      Print queue status bitmask and values.
 */

#define PRQ_STATUS_MASK                 3
#define PRQ_ACTIVE                      0
#define PRQ_PAUSED                      1
#define PRQ_ERROR                       2
#define PRQ_PENDING                     3

/*
 *      Print queue status bits for level 3
 */

#define PRQ3_PAUSED                   0x1
#define PRQ3_PENDING                  0x2
/*
 *      Values for parmnum in RxPrintJobSetInfo.
 */

#define PRJ_NOTIFYNAME_PARMNUM        3
#define PRJ_DATATYPE_PARMNUM          4
#define PRJ_PARMS_PARMNUM             5
#define PRJ_POSITION_PARMNUM          6
#define PRJ_COMMENT_PARMNUM          11
#define PRJ_DOCUMENT_PARMNUM         12
#define PRJ_PRIORITY_PARMNUM         14
#define PRJ_PROCPARMS_PARMNUM        16
#define PRJ_DRIVERDATA_PARMNUM       18
#define PRJ_MAXPARMNUM               18

/*
 *      Bitmap masks for status field of PRJINFO.
 */

/* 2-7 bits also used in device status */

#define PRJ_QSTATUS      0x0003      /* Bits 0,1 */
#define PRJ_DEVSTATUS    0x0ffc      /* 2-11 bits */
#define PRJ_COMPLETE     0x0004      /*  Bit 2   */
#define PRJ_INTERV       0x0008      /*  Bit 3   */
#define PRJ_ERROR        0x0010      /*  Bit 4   */
#define PRJ_DESTOFFLINE  0x0020      /*  Bit 5   */
#define PRJ_DESTPAUSED   0x0040      /*  Bit 6   */
#define PRJ_NOTIFY       0x0080      /*  Bit 7   */
#define PRJ_DESTNOPAPER  0x0100      /*  Bit 8   */
#define PRJ_DESTFORMCHG  0x0200      /* BIT 9 */
#define PRJ_DESTCRTCHG   0x0400      /* BIT 10 */
#define PRJ_DESTPENCHG   0x0800      /* BIT 11 */
#define PRJ_DELETED      0x8000      /* Bit 15   */

/*
 *      Values of PRJ_QSTATUS bits in fsStatus field of PRJINFO.
 */

#define PRJ_QS_QUEUED                 0
#define PRJ_QS_PAUSED                 1
#define PRJ_QS_SPOOLING               2
#define PRJ_QS_PRINTING               3

/*
 *      Print Job Priority
 */

#define PRJ_MAX_PRIORITY                99          /* lowest priority */
#define PRJ_MIN_PRIORITY                 1          /* highest priority */
#define PRJ_NO_PRIORITY                  0


/*
 *      Bitmap masks for status field of PRDINFO.
 *      see PRJ_... for bits 2-11
 */

#define PRD_STATUS_MASK       0x0003      /* Bits 0,1 */
#define PRD_DEVSTATUS         0x0ffc      /* 2-11 bits */

/*
 *      Values of PRD_STATUS_MASK bits in fsStatus field of PRDINFO.
 */

#define PRD_ACTIVE                 0
#define PRD_PAUSED                 1

/*
 *      Control codes used in RxPrintDestControl.
 */

#define PRD_DELETE                    0
#define PRD_PAUSE                     1
#define PRD_CONT                      2
#define PRD_RESTART                   3

/*
 *      Values for parmnum in RxPrintDestSetInfo.
 */

#define PRD_LOGADDR_PARMNUM      3
#define PRD_COMMENT_PARMNUM      7
#define PRD_DRIVERS_PARMNUM      8
#endif // ndef _RXPRINT_
=== C:/Users/treeman/Desktop/windows nt source code\Source\Win2K3\NT\public\internal\ds\inc\samrpc.h ===
/* this ALWAYS GENERATED file contains the definitions for the interfaces */


 /* File created by MIDL compiler version 6.00.0361 */
/* Compiler settings for samrpc.idl, samsrv.acf:
    Oicf, W1, Zp8, env=Win32 (32b run)
    protocol : dce , ms_ext, c_ext, oldnames, robust
    error checks: allocation ref bounds_check enum stub_data , no_format_optimization
    VC __declspec() decoration level: 
         __declspec(uuid()), __declspec(selectany), __declspec(novtable)
         DECLSPEC_UUID(), MIDL_INTERFACE()
*/
//@@MIDL_FILE_HEADING(  )

#pragma warning( disable: 4049 )  /* more than 64k source lines */


/* verify that the <rpcndr.h> version is high enough to compile this file*/
#ifndef __REQUIRED_RPCNDR_H_VERSION__
#define __REQUIRED_RPCNDR_H_VERSION__ 475
#endif

#include "rpc.h"
#include "rpcndr.h"

#ifndef __RPCNDR_H_VERSION__
#error this stub requires an updated version of <rpcndr.h>
#endif // __RPCNDR_H_VERSION__


#ifndef __samrpc_h__
#define __samrpc_h__

#if defined(_MSC_VER) && (_MSC_VER >= 1020)
#pragma once
#endif

/* Forward Declarations */ 

/* header files for imported files */
#include "samimp.h"

#ifdef __cplusplus
extern "C"{
#endif 

void * __RPC_USER MIDL_user_allocate(size_t);
void __RPC_USER MIDL_user_free( void * ); 

#ifndef __samr_INTERFACE_DEFINED__
#define __samr_INTERFACE_DEFINED__

/* interface samr */
/* [strict_context_handle][implicit_handle][unique][ms_union][version][uuid] */ 

typedef struct _RPC_UNICODE_STRING
    {
    USHORT Length;
    USHORT MaximumLength;
    /* [length_is][size_is] */ PWCH Buffer;
    } 	RPC_UNICODE_STRING;

typedef struct _RPC_UNICODE_STRING *PRPC_UNICODE_STRING;

typedef struct _RPC_STRING
    {
    USHORT Length;
    USHORT MaximumLength;
    /* [length_is][size_is] */ PCHAR Buffer;
    } 	RPC_STRING;

typedef struct _RPC_STRING *PRPC_STRING;

typedef struct _RPC_STRING RPC_ANSI_STRING;

typedef struct _RPC_STRING *PRPC_ANSI_STRING;

typedef struct _RPC_SID
    {
    UCHAR Revision;
    UCHAR SubAuthorityCount;
    SID_IDENTIFIER_AUTHORITY IdentifierAuthority;
    /* [size_is] */ ULONG SubAuthority[ 1 ];
    } 	RPC_SID;

typedef struct _RPC_SID *PRPC_SID;

typedef struct _RPC_SID **PPRPC_SID;

typedef /* [handle] */ LPWSTR PSAMPR_SERVER_NAME;

typedef /* [context_handle] */ PVOID SAMPR_HANDLE;

#define SAM_NETWORK_REVISION_1      (1)
#define SAM_NETWORK_REVISION_2      (2)
#define SAM_NETWORK_REVISION_3      (3)
#define SAM_NETWORK_REVISION_LATEST SAM_NETWORK_REVISION_3
#define SAM_CLIENT_PRE_NT5 SAM_NETWORK_REVISION_1
#define SAM_CLIENT_NT5     SAM_NETWORK_REVISION_2
#define SAM_CLIENT_LATEST  SAM_NETWORK_REVISION_LATEST
#define SAM_EXTENDED_SID_DOMAIN          0x00000001
#define SAM_EXTENDED_SID_DOMAIN_COMPAT_1 0x00000002
#define SAM_EXTENDED_SID_DOMAIN_COMPAT_2 0x00000004
typedef struct _SAMPR_RID_ENUMERATION
    {
    ULONG RelativeId;
    RPC_UNICODE_STRING Name;
    } 	SAMPR_RID_ENUMERATION;

typedef struct _SAMPR_RID_ENUMERATION *PSAMPR_RID_ENUMERATION;

typedef struct _SAMPR_SID_ENUMERATION
    {
    PSID Sid;
    RPC_UNICODE_STRING Name;
    } 	SAMPR_SID_ENUMERATION;

typedef struct _SAMPR_SID_ENUMERATION *PSAMPR_SID_ENUMERATION;

typedef struct _SAMPR_ENUMERATION_BUFFER
    {
    ULONG EntriesRead;
    /* [size_is] */ PSAMPR_RID_ENUMERATION Buffer;
    } 	SAMPR_ENUMERATION_BUFFER;

typedef struct _SAMPR_ENUMERATION_BUFFER *PSAMPR_ENUMERATION_BUFFER;

typedef struct _SAMPR_SR_SECURITY_DESCRIPTOR
    {
    /* [range] */ ULONG Length;
    /* [size_is] */ PUCHAR SecurityDescriptor;
    } 	SAMPR_SR_SECURITY_DESCRIPTOR;

typedef struct _SAMPR_SR_SECURITY_DESCRIPTOR *PSAMPR_SR_SECURITY_DESCRIPTOR;

typedef struct _SAMPR_GET_GROUPS_BUFFER
    {
    ULONG MembershipCount;
    /* [size_is] */ PGROUP_MEMBERSHIP Groups;
    } 	SAMPR_GET_GROUPS_BUFFER;

typedef struct _SAMPR_GET_GROUPS_BUFFER *PSAMPR_GET_GROUPS_BUFFER;

typedef struct _SAMPR_GET_MEMBERS_BUFFER
    {
    ULONG MemberCount;
    /* [size_is] */ PULONG Members;
    /* [size_is] */ PULONG Attributes;
    } 	SAMPR_GET_MEMBERS_BUFFER;

typedef struct _SAMPR_GET_MEMBERS_BUFFER *PSAMPR_GET_MEMBERS_BUFFER;

typedef struct _SAMPR_LOGON_HOURS
    {
    USHORT UnitsPerWeek;
    /* [length_is][size_is] */ PUCHAR LogonHours;
    } 	SAMPR_LOGON_HOURS;

typedef struct _SAMPR_LOGON_HOURS *PSAMPR_LOGON_HOURS;

typedef struct _SAMPR_ULONG_ARRAY
    {
    ULONG Count;
    /* [size_is] */ ULONG *Element;
    } 	SAMPR_ULONG_ARRAY;

typedef struct _SAMPR_ULONG_ARRAY *PSAMPR_ULONG_ARRAY;

typedef struct _SAMPR_SID_INFORMATION
    {
    PRPC_SID SidPointer;
    } 	SAMPR_SID_INFORMATION;

typedef /* [allocate] */ struct _SAMPR_SID_INFORMATION *PSAMPR_SID_INFORMATION;

typedef struct _SAMPR_PSID_ARRAY
    {
    /* [range] */ ULONG Count;
    /* [size_is] */ PSAMPR_SID_INFORMATION Sids;
    } 	SAMPR_PSID_ARRAY;

typedef struct _SAMPR_PSID_ARRAY *PSAMPR_PSID_ARRAY;

typedef struct _SAMPR_PSID_ARRAY_OUT
    {
    ULONG Count;
    /* [size_is] */ PSAMPR_SID_INFORMATION Sids;
    } 	SAMPR_PSID_ARRAY_OUT;

typedef struct _SAMPR_PSID_ARRAY_OUT *PSAMPR_PSID_ARRAY_OUT;

typedef struct _SAMPR_UNICODE_STRING_ARRAY
    {
    ULONG Count;
    /* [size_is] */ RPC_UNICODE_STRING *Element;
    } 	SAMPR_UNICODE_STRING_ARRAY;

typedef struct _SAMPR_UNICODE_STRING_ARRAY *PSAMPR_UNICODE_STRING_ARRAY;

typedef RPC_UNICODE_STRING SAMPR_RETURNED_STRING;

typedef RPC_UNICODE_STRING *PSAMPR_RETURNED_STRING;

typedef STRING SAMPR_RETURNED_NORMAL_STRING;

typedef STRING *PSAMPR_RETURNED_NORMAL_STRING;

typedef struct _SAMPR_RETURNED_USTRING_ARRAY
    {
    ULONG Count;
    /* [size_is] */ PSAMPR_RETURNED_STRING Element;
    } 	SAMPR_RETURNED_USTRING_ARRAY;

typedef struct _SAMPR_RETURNED_USTRING_ARRAY *PSAMPR_RETURNED_USTRING_ARRAY;

typedef struct _SAMPR_REVISION_INFO_V1
    {
    ULONG Revision;
    ULONG SupportedFeatures;
    } 	SAMPR_REVISION_INFO_V1;

typedef struct _SAMPR_REVISION_INFO_V1 *PSAMPR_REVISION_INFO_V1;

typedef /* [public][public][public][switch_type] */ union __MIDL_samr_0001
    {
    /* [case()] */ SAMPR_REVISION_INFO_V1 V1;
    } 	SAMPR_REVISION_INFO;

typedef /* [switch_type] */ union __MIDL_samr_0001 *PSAMPR_REVISION_INFO;


#pragma pack(4)
typedef struct _SAMPR_DOMAIN_GENERAL_INFORMATION
    {
    OLD_LARGE_INTEGER ForceLogoff;
    RPC_UNICODE_STRING OemInformation;
    RPC_UNICODE_STRING DomainName;
    RPC_UNICODE_STRING ReplicaSourceNodeName;
    OLD_LARGE_INTEGER DomainModifiedCount;
    ULONG DomainServerState;
    ULONG DomainServerRole;
    BOOLEAN UasCompatibilityRequired;
    ULONG UserCount;
    ULONG GroupCount;
    ULONG AliasCount;
    } 	SAMPR_DOMAIN_GENERAL_INFORMATION;

typedef struct _SAMPR_DOMAIN_GENERAL_INFORMATION *PSAMPR_DOMAIN_GENERAL_INFORMATION;


#pragma pack()

#pragma pack(4)
typedef struct _SAMPR_DOMAIN_GENERAL_INFORMATION2
    {
    SAMPR_DOMAIN_GENERAL_INFORMATION I1;
    LARGE_INTEGER LockoutDuration;
    LARGE_INTEGER LockoutObservationWindow;
    USHORT LockoutThreshold;
    } 	SAMPR_DOMAIN_GENERAL_INFORMATION2;

typedef struct _SAMPR_DOMAIN_GENERAL_INFORMATION2 *PSAMPR_DOMAIN_GENERAL_INFORMATION2;


#pragma pack()
typedef struct _SAMPR_DOMAIN_OEM_INFORMATION
    {
    RPC_UNICODE_STRING OemInformation;
    } 	SAMPR_DOMAIN_OEM_INFORMATION;

typedef struct _SAMPR_DOMAIN_OEM_INFORMATION *PSAMPR_DOMAIN_OEM_INFORMATION;

typedef struct _SAMPR_DOMAIN_NAME_INFORMATION
    {
    RPC_UNICODE_STRING DomainName;
    } 	SAMPR_DOMAIN_NAME_INFORMATION;

typedef struct _SAMPR_DOMAIN_NAME_INFORMATION *PSAMPR_DOMAIN_NAME_INFORMATION;

typedef struct SAMPR_DOMAIN_REPLICATION_INFORMATION
    {
    RPC_UNICODE_STRING ReplicaSourceNodeName;
    } 	SAMPR_DOMAIN_REPLICATION_INFORMATION;

typedef struct SAMPR_DOMAIN_REPLICATION_INFORMATION *PSAMPR_DOMAIN_REPLICATION_INFORMATION;

typedef struct _SAMPR_DOMAIN_LOCKOUT_INFORMATION
    {
    LARGE_INTEGER LockoutDuration;
    LARGE_INTEGER LockoutObservationWindow;
    USHORT LockoutThreshold;
    } 	SAMPR_DOMAIN_LOCKOUT_INFORMATION;

typedef struct _SAMPR_DOMAIN_LOCKOUT_INFORMATION *PSAMPR_DOMAIN_LOCKOUT_INFORMATION;

typedef /* [switch_type] */ union _SAMPR_DOMAIN_INFO_BUFFER
    {
    /* [case()] */ DOMAIN_PASSWORD_INFORMATION Password;
    /* [case()] */ SAMPR_DOMAIN_GENERAL_INFORMATION General;
    /* [case()] */ DOMAIN_LOGOFF_INFORMATION Logoff;
    /* [case()] */ SAMPR_DOMAIN_OEM_INFORMATION Oem;
    /* [case()] */ SAMPR_DOMAIN_NAME_INFORMATION Name;
    /* [case()] */ DOMAIN_SERVER_ROLE_INFORMATION Role;
    /* [case()] */ SAMPR_DOMAIN_REPLICATION_INFORMATION Replication;
    /* [case()] */ DOMAIN_MODIFIED_INFORMATION Modified;
    /* [case()] */ DOMAIN_STATE_INFORMATION State;
    /* [case()] */ SAMPR_DOMAIN_GENERAL_INFORMATION2 General2;
    /* [case()] */ SAMPR_DOMAIN_LOCKOUT_INFORMATION Lockout;
    /* [case()] */ DOMAIN_MODIFIED_INFORMATION2 Modified2;
    } 	SAMPR_DOMAIN_INFO_BUFFER;

typedef /* [switch_type] */ union _SAMPR_DOMAIN_INFO_BUFFER *PSAMPR_DOMAIN_INFO_BUFFER;

typedef struct _SAMPR_GROUP_GENERAL_INFORMATION
    {
    RPC_UNICODE_STRING Name;
    ULONG Attributes;
    ULONG MemberCount;
    RPC_UNICODE_STRING AdminComment;
    } 	SAMPR_GROUP_GENERAL_INFORMATION;

typedef struct _SAMPR_GROUP_GENERAL_INFORMATION *PSAMPR_GROUP_GENERAL_INFORMATION;

typedef struct _SAMPR_GROUP_NAME_INFORMATION
    {
    RPC_UNICODE_STRING Name;
    } 	SAMPR_GROUP_NAME_INFORMATION;

typedef struct _SAMPR_GROUP_NAME_INFORMATION *PSAMPR_GROUP_NAME_INFORMATION;

typedef struct _SAMPR_GROUP_ADM_COMMENT_INFORMATION
    {
    RPC_UNICODE_STRING AdminComment;
    } 	SAMPR_GROUP_ADM_COMMENT_INFORMATION;

typedef struct _SAMPR_GROUP_ADM_COMMENT_INFORMATION *PSAMPR_GROUP_ADM_COMMENT_INFORMATION;

typedef /* [switch_type] */ union _SAMPR_GROUP_INFO_BUFFER
    {
    /* [case()] */ SAMPR_GROUP_GENERAL_INFORMATION General;
    /* [case()] */ SAMPR_GROUP_NAME_INFORMATION Name;
    /* [case()] */ GROUP_ATTRIBUTE_INFORMATION Attribute;
    /* [case()] */ SAMPR_GROUP_ADM_COMMENT_INFORMATION AdminComment;
    /* [case()] */ SAMPR_GROUP_GENERAL_INFORMATION DoNotUse;
    } 	SAMPR_GROUP_INFO_BUFFER;

typedef /* [switch_type] */ union _SAMPR_GROUP_INFO_BUFFER *PSAMPR_GROUP_INFO_BUFFER;

typedef struct _SAMPR_ALIAS_GENERAL_INFORMATION
    {
    RPC_UNICODE_STRING Name;
    ULONG MemberCount;
    RPC_UNICODE_STRING AdminComment;
    } 	SAMPR_ALIAS_GENERAL_INFORMATION;

typedef struct _SAMPR_ALIAS_GENERAL_INFORMATION *PSAMPR_ALIAS_GENERAL_INFORMATION;

typedef struct _SAMPR_ALIAS_NAME_INFORMATION
    {
    RPC_UNICODE_STRING Name;
    } 	SAMPR_ALIAS_NAME_INFORMATION;

typedef struct _SAMPR_ALIAS_NAME_INFORMATION *PSAMPR_ALIAS_NAME_INFORMATION;

typedef struct _SAMPR_ALIAS_ADM_COMMENT_INFORMATION
    {
    RPC_UNICODE_STRING AdminComment;
    } 	SAMPR_ALIAS_ADM_COMMENT_INFORMATION;

typedef struct _SAMPR_ALIAS_ADM_COMMENT_INFORMATION *PSAMPR_ALIAS_ADM_COMMENT_INFORMATION;

typedef /* [switch_type] */ union _SAMPR_ALIAS_INFO_BUFFER
    {
    /* [case()] */ SAMPR_ALIAS_GENERAL_INFORMATION General;
    /* [case()] */ SAMPR_ALIAS_NAME_INFORMATION Name;
    /* [case()] */ SAMPR_ALIAS_ADM_COMMENT_INFORMATION AdminComment;
    } 	SAMPR_ALIAS_INFO_BUFFER;

typedef /* [switch_type] */ union _SAMPR_ALIAS_INFO_BUFFER *PSAMPR_ALIAS_INFO_BUFFER;


#pragma pack(4)
typedef struct _SAMPR_USER_ALL_INFORMATION
    {
    OLD_LARGE_INTEGER LastLogon;
    OLD_LARGE_INTEGER LastLogoff;
    OLD_LARGE_INTEGER PasswordLastSet;
    OLD_LARGE_INTEGER AccountExpires;
    OLD_LARGE_INTEGER PasswordCanChange;
    OLD_LARGE_INTEGER PasswordMustChange;
    RPC_UNICODE_STRING UserName;
    RPC_UNICODE_STRING FullName;
    RPC_UNICODE_STRING HomeDirectory;
    RPC_UNICODE_STRING HomeDirectoryDrive;
    RPC_UNICODE_STRING ScriptPath;
    RPC_UNICODE_STRING ProfilePath;
    RPC_UNICODE_STRING AdminComment;
    RPC_UNICODE_STRING WorkStations;
    RPC_UNICODE_STRING UserComment;
    RPC_UNICODE_STRING Parameters;
    RPC_UNICODE_STRING LmOwfPassword;
    RPC_UNICODE_STRING NtOwfPassword;
    RPC_UNICODE_STRING PrivateData;
    SAMPR_SR_SECURITY_DESCRIPTOR SecurityDescriptor;
    ULONG UserId;
    ULONG PrimaryGroupId;
    ULONG UserAccountControl;
    ULONG WhichFields;
    SAMPR_LOGON_HOURS LogonHours;
    USHORT BadPasswordCount;
    USHORT LogonCount;
    USHORT CountryCode;
    USHORT CodePage;
    BOOLEAN LmPasswordPresent;
    BOOLEAN NtPasswordPresent;
    BOOLEAN PasswordExpired;
    BOOLEAN PrivateDataSensitive;
    } 	SAMPR_USER_ALL_INFORMATION;

typedef struct _SAMPR_USER_ALL_INFORMATION *PSAMPR_USER_ALL_INFORMATION;


#pragma pack()

#pragma pack(4)
typedef struct _SAMPR_USER_INTERNAL3_INFORMATION
    {
    SAMPR_USER_ALL_INFORMATION I1;
    LARGE_INTEGER LastBadPasswordTime;
    } 	SAMPR_USER_INTERNAL3_INFORMATION;

typedef struct _SAMPR_USER_INTERNAL3_INFORMATION *PSAMPR_USER_INTERNAL3_INFORMATION;


#pragma pack()
typedef struct _SAMPR_USER_GENERAL_INFORMATION
    {
    RPC_UNICODE_STRING UserName;
    RPC_UNICODE_STRING FullName;
    ULONG PrimaryGroupId;
    RPC_UNICODE_STRING AdminComment;
    RPC_UNICODE_STRING UserComment;
    } 	SAMPR_USER_GENERAL_INFORMATION;

typedef struct _SAMPR_USER_GENERAL_INFORMATION *PSAMPR_USER_GENERAL_INFORMATION;

typedef struct _SAMPR_USER_PREFERENCES_INFORMATION
    {
    RPC_UNICODE_STRING UserComment;
    RPC_UNICODE_STRING Reserved1;
    USHORT CountryCode;
    USHORT CodePage;
    } 	SAMPR_USER_PREFERENCES_INFORMATION;

typedef struct _SAMPR_USER_PREFERENCES_INFORMATION *PSAMPR_USER_PREFERENCES_INFORMATION;

typedef struct _SAMPR_USER_PARAMETERS_INFORMATION
    {
    RPC_UNICODE_STRING Parameters;
    } 	SAMPR_USER_PARAMETERS_INFORMATION;

typedef struct _SAMPR_USER_PARAMETERS_INFORMATION *PSAMPR_USER_PARAMETERS_INFORMATION;


#pragma pack(4)
typedef struct _SAMPR_USER_LOGON_INFORMATION
    {
    RPC_UNICODE_STRING UserName;
    RPC_UNICODE_STRING FullName;
    ULONG UserId;
    ULONG PrimaryGroupId;
    RPC_UNICODE_STRING HomeDirectory;
    RPC_UNICODE_STRING HomeDirectoryDrive;
    RPC_UNICODE_STRING ScriptPath;
    RPC_UNICODE_STRING ProfilePath;
    RPC_UNICODE_STRING WorkStations;
    OLD_LARGE_INTEGER LastLogon;
    OLD_LARGE_INTEGER LastLogoff;
    OLD_LARGE_INTEGER PasswordLastSet;
    OLD_LARGE_INTEGER PasswordCanChange;
    OLD_LARGE_INTEGER PasswordMustChange;
    SAMPR_LOGON_HOURS LogonHours;
    USHORT BadPasswordCount;
    USHORT LogonCount;
    ULONG UserAccountControl;
    } 	SAMPR_USER_LOGON_INFORMATION;

typedef struct _SAMPR_USER_LOGON_INFORMATION *PSAMPR_USER_LOGON_INFORMATION;


#pragma pack()

#pragma pack(4)
typedef struct _SAMPR_USER_ACCOUNT_INFORMATION
    {
    RPC_UNICODE_STRING UserName;
    RPC_UNICODE_STRING FullName;
    ULONG UserId;
    ULONG PrimaryGroupId;
    RPC_UNICODE_STRING HomeDirectory;
    RPC_UNICODE_STRING HomeDirectoryDrive;
    RPC_UNICODE_STRING ScriptPath;
    RPC_UNICODE_STRING ProfilePath;
    RPC_UNICODE_STRING AdminComment;
    RPC_UNICODE_STRING WorkStations;
    OLD_LARGE_INTEGER LastLogon;
    OLD_LARGE_INTEGER LastLogoff;
    SAMPR_LOGON_HOURS LogonHours;
    USHORT BadPasswordCount;
    USHORT LogonCount;
    OLD_LARGE_INTEGER PasswordLastSet;
    OLD_LARGE_INTEGER AccountExpires;
    ULONG UserAccountControl;
    } 	SAMPR_USER_ACCOUNT_INFORMATION;

typedef struct _SAMPR_USER_ACCOUNT_INFORMATION *PSAMPR_USER_ACCOUNT_INFORMATION;


#pragma pack()
typedef struct _SAMPR_USER_A_NAME_INFORMATION
    {
    RPC_UNICODE_STRING UserName;
    } 	SAMPR_USER_A_NAME_INFORMATION;

typedef struct _SAMPR_USER_A_NAME_INFORMATION *PSAMPR_USER_A_NAME_INFORMATION;

typedef struct _SAMPR_USER_F_NAME_INFORMATION
    {
    RPC_UNICODE_STRING FullName;
    } 	SAMPR_USER_F_NAME_INFORMATION;

typedef struct _SAMPR_USER_F_NAME_INFORMATION *PSAMPR_USER_F_NAME_INFORMATION;

typedef struct _SAMPR_USER_NAME_INFORMATION
    {
    RPC_UNICODE_STRING UserName;
    RPC_UNICODE_STRING FullName;
    } 	SAMPR_USER_NAME_INFORMATION;

typedef struct _SAMPR_USER_NAME_INFORMATION *PSAMPR_USER_NAME_INFORMATION;

typedef struct _SAMPR_USER_HOME_INFORMATION
    {
    RPC_UNICODE_STRING HomeDirectory;
    RPC_UNICODE_STRING HomeDirectoryDrive;
    } 	SAMPR_USER_HOME_INFORMATION;

typedef struct _SAMPR_USER_HOME_INFORMATION *PSAMPR_USER_HOME_INFORMATION;

typedef struct _SAMPR_USER_SCRIPT_INFORMATION
    {
    RPC_UNICODE_STRING ScriptPath;
    } 	SAMPR_USER_SCRIPT_INFORMATION;

typedef struct _SAMPR_USER_SCRIPT_INFORMATION *PSAMPR_USER_SCRIPT_INFORMATION;

typedef struct _SAMPR_USER_PROFILE_INFORMATION
    {
    RPC_UNICODE_STRING ProfilePath;
    } 	SAMPR_USER_PROFILE_INFORMATION;

typedef struct _SAMPR_USER_PROFILE_INFORMATION *PSAMPR_USER_PROFILE_INFORMATION;

typedef struct _SAMPR_USER_ADMIN_COMMENT_INFORMATION
    {
    RPC_UNICODE_STRING AdminComment;
    } 	SAMPR_USER_ADMIN_COMMENT_INFORMATION;

typedef struct _SAMPR_USER_ADMIN_COMMENT_INFORMATION *PSAMPR_USER_ADMIN_COMMENT_INFORMATION;

typedef struct _SAMPR_USER_WORKSTATIONS_INFORMATION
    {
    RPC_UNICODE_STRING WorkStations;
    } 	SAMPR_USER_WORKSTATIONS_INFORMATION;

typedef struct _SAMPR_USER_WORKSTATIONS_INFORMATION *PSAMPR_USER_WORKSTATIONS_INFORMATION;

typedef struct _SAMPR_USER_LOGON_HOURS_INFORMATION
    {
    SAMPR_LOGON_HOURS LogonHours;
    } 	SAMPR_USER_LOGON_HOURS_INFORMATION;

typedef struct _SAMPR_USER_LOGON_HOURS_INFORMATION *PSAMPR_USER_LOGON_HOURS_INFORMATION;

typedef struct _SAMPR_USER_INTERNAL1_INFORMATION
    {
    ENCRYPTED_NT_OWF_PASSWORD EncryptedNtOwfPassword;
    ENCRYPTED_LM_OWF_PASSWORD EncryptedLmOwfPassword;
    BOOLEAN NtPasswordPresent;
    BOOLEAN LmPasswordPresent;
    BOOLEAN PasswordExpired;
    } 	SAMPR_USER_INTERNAL1_INFORMATION;

typedef struct _SAMPR_USER_INTERNAL1_INFORMATION *PSAMPR_USER_INTERNAL1_INFORMATION;

typedef struct _SAMPR_USER_INTERNAL4_INFORMATION
    {
    SAMPR_USER_ALL_INFORMATION I1;
    SAMPR_ENCRYPTED_USER_PASSWORD UserPassword;
    } 	SAMPR_USER_INTERNAL4_INFORMATION;

typedef struct _SAMPR_USER_INTERNAL4_INFORMATION *PSAMPR_USER_INTERNAL4_INFORMATION;

typedef struct _SAMPR_USER_INTERNAL4_INFORMATION_NEW
    {
    SAMPR_USER_ALL_INFORMATION I1;
    SAMPR_ENCRYPTED_USER_PASSWORD_NEW UserPassword;
    } 	SAMPR_USER_INTERNAL4_INFORMATION_NEW;

typedef struct _SAMPR_USER_INTERNAL4_INFORMATION_NEW *PSAMPR_USER_INTERNAL4_INFORMATION_NEW;

typedef struct _SAMPR_USER_INTERNAL5_INFORMATION
    {
    SAMPR_ENCRYPTED_USER_PASSWORD UserPassword;
    BOOLEAN PasswordExpired;
    } 	SAMPR_USER_INTERNAL5_INFORMATION;

typedef struct _SAMPR_USER_INTERNAL5_INFORMATION *PSAMPR_USER_INTERNAL5_INFORMATION;

typedef struct _SAMPR_USER_INTERNAL5_INFORMATION_NEW
    {
    SAMPR_ENCRYPTED_USER_PASSWORD_NEW UserPassword;
    BOOLEAN PasswordExpired;
    } 	SAMPR_USER_INTERNAL5_INFORMATION_NEW;

typedef struct _SAMPR_USER_INTERNAL5_INFORMATION_NEW *PSAMPR_USER_INTERNAL5_INFORMATION_NEW;

typedef /* [switch_type] */ union _SAMPR_USER_INFO_BUFFER
    {
    /* [case()] */ SAMPR_USER_GENERAL_INFORMATION General;
    /* [case()] */ SAMPR_USER_PREFERENCES_INFORMATION Preferences;
    /* [case()] */ SAMPR_USER_LOGON_INFORMATION Logon;
    /* [case()] */ SAMPR_USER_LOGON_HOURS_INFORMATION LogonHours;
    /* [case()] */ SAMPR_USER_ACCOUNT_INFORMATION Account;
    /* [case()] */ SAMPR_USER_NAME_INFORMATION Name;
    /* [case()] */ SAMPR_USER_A_NAME_INFORMATION AccountName;
    /* [case()] */ SAMPR_USER_F_NAME_INFORMATION FullName;
    /* [case()] */ USER_PRIMARY_GROUP_INFORMATION PrimaryGroup;
    /* [case()] */ SAMPR_USER_HOME_INFORMATION Home;
    /* [case()] */ SAMPR_USER_SCRIPT_INFORMATION Script;
    /* [case()] */ SAMPR_USER_PROFILE_INFORMATION Profile;
    /* [case()] */ SAMPR_USER_ADMIN_COMMENT_INFORMATION AdminComment;
    /* [case()] */ SAMPR_USER_WORKSTATIONS_INFORMATION WorkStations;
    /* [case()] */ USER_CONTROL_INFORMATION Control;
    /* [case()] */ USER_EXPIRES_INFORMATION Expires;
    /* [case()] */ SAMPR_USER_INTERNAL1_INFORMATION Internal1;
    /* [case()] */ USER_INTERNAL2_INFORMATION Internal2;
    /* [case()] */ SAMPR_USER_PARAMETERS_INFORMATION Parameters;
    /* [case()] */ SAMPR_USER_ALL_INFORMATION All;
    /* [case()] */ SAMPR_USER_INTERNAL3_INFORMATION Internal3;
    /* [case()] */ SAMPR_USER_INTERNAL4_INFORMATION Internal4;
    /* [case()] */ SAMPR_USER_INTERNAL5_INFORMATION Internal5;
    /* [case()] */ SAMPR_USER_INTERNAL4_INFORMATION_NEW Internal4New;
    /* [case()] */ SAMPR_USER_INTERNAL5_INFORMATION_NEW Internal5New;
    } 	SAMPR_USER_INFO_BUFFER;

typedef /* [switch_type] */ union _SAMPR_USER_INFO_BUFFER *PSAMPR_USER_INFO_BUFFER;

typedef struct _SAMPR_DOMAIN_DISPLAY_USER
    {
    ULONG Index;
    ULONG Rid;
    ULONG AccountControl;
    SAMPR_RETURNED_STRING LogonName;
    SAMPR_RETURNED_STRING AdminComment;
    SAMPR_RETURNED_STRING FullName;
    } 	SAMPR_DOMAIN_DISPLAY_USER;

typedef struct _SAMPR_DOMAIN_DISPLAY_USER *PSAMPR_DOMAIN_DISPLAY_USER;

typedef struct _SAMPR_DOMAIN_DISPLAY_MACHINE
    {
    ULONG Index;
    ULONG Rid;
    ULONG AccountControl;
    SAMPR_RETURNED_STRING Machine;
    SAMPR_RETURNED_STRING Comment;
    } 	SAMPR_DOMAIN_DISPLAY_MACHINE;

typedef struct _SAMPR_DOMAIN_DISPLAY_MACHINE *PSAMPR_DOMAIN_DISPLAY_MACHINE;

typedef struct _SAMPR_DOMAIN_DISPLAY_GROUP
    {
    ULONG Index;
    ULONG Rid;
    ULONG Attributes;
    SAMPR_RETURNED_STRING Group;
    SAMPR_RETURNED_STRING Comment;
    } 	SAMPR_DOMAIN_DISPLAY_GROUP;

typedef struct _SAMPR_DOMAIN_DISPLAY_GROUP *PSAMPR_DOMAIN_DISPLAY_GROUP;

typedef struct _SAMPR_DOMAIN_DISPLAY_OEM_USER
    {
    ULONG Index;
    SAMPR_RETURNED_NORMAL_STRING OemUser;
    } 	SAMPR_DOMAIN_DISPLAY_OEM_USER;

typedef struct _SAMPR_DOMAIN_DISPLAY_OEM_USER *PSAMPR_DOMAIN_DISPLAY_OEM_USER;

typedef struct _SAMPR_DOMAIN_DISPLAY_OEM_GROUP
    {
    ULONG Index;
    SAMPR_RETURNED_NORMAL_STRING OemGroup;
    } 	SAMPR_DOMAIN_DISPLAY_OEM_GROUP;

typedef struct _SAMPR_DOMAIN_DISPLAY_OEM_GROUP *PSAMPR_DOMAIN_DISPLAY_OEM_GROUP;

typedef struct _SAMPR_DOMAIN_DISPLAY_USER_BUFFER
    {
    ULONG EntriesRead;
    /* [size_is] */ PSAMPR_DOMAIN_DISPLAY_USER Buffer;
    } 	SAMPR_DOMAIN_DISPLAY_USER_BUFFER;

typedef struct _SAMPR_DOMAIN_DISPLAY_USER_BUFFER *PSAMPR_DOMAIN_DISPLAY_USER_BUFFER;

typedef struct _SAMPR_DOMAIN_DISPLAY_MACHINE_BUFFER
    {
    ULONG EntriesRead;
    /* [size_is] */ PSAMPR_DOMAIN_DISPLAY_MACHINE Buffer;
    } 	SAMPR_DOMAIN_DISPLAY_MACHINE_BUFFER;

typedef struct _SAMPR_DOMAIN_DISPLAY_MACHINE_BUFFER *PSAMPR_DOMAIN_DISPLAY_MACHINE_BUFFER;

typedef struct _SAMPR_DOMAIN_DISPLAY_GROUP_BUFFER
    {
    ULONG EntriesRead;
    /* [size_is] */ PSAMPR_DOMAIN_DISPLAY_GROUP Buffer;
    } 	SAMPR_DOMAIN_DISPLAY_GROUP_BUFFER;

typedef struct _SAMPR_DOMAIN_DISPLAY_GROUP_BUFFER *PSAMPR_DOMAIN_DISPLAY_GROUP_BUFFER;

typedef struct _SAMPR_DOMAIN_DISPLAY_OEM_USER_BUFFER
    {
    ULONG EntriesRead;
    /* [size_is] */ PSAMPR_DOMAIN_DISPLAY_OEM_USER Buffer;
    } 	SAMPR_DOMAIN_DISPLAY_OEM_USER_BUFFER;

typedef struct _SAMPR_DOMAIN_DISPLAY_OEM_USER_BUFFER *PSAMPR_DOMAIN_DISPLAY_OEM_USER_BUFFER;

typedef struct _SAMPR_DOMAIN_DISPLAY_OEM_GROUP_BUFFER
    {
    ULONG EntriesRead;
    /* [size_is] */ PSAMPR_DOMAIN_DISPLAY_OEM_GROUP Buffer;
    } 	SAMPR_DOMAIN_DISPLAY_OEM_GROUP_BUFFER;

typedef struct _SAMPR_DOMAIN_DISPLAY_OEM_GROUP_BUFFER *PSAMPR_DOMAIN_DISPLAY_OEM_GROUP_BUFFER;

typedef /* [switch_type] */ union _SAMPR_DISPLAY_INFO_BUFFER
    {
    /* [case()] */ SAMPR_DOMAIN_DISPLAY_USER_BUFFER UserInformation;
    /* [case()] */ SAMPR_DOMAIN_DISPLAY_MACHINE_BUFFER MachineInformation;
    /* [case()] */ SAMPR_DOMAIN_DISPLAY_GROUP_BUFFER GroupInformation;
    /* [case()] */ SAMPR_DOMAIN_DISPLAY_OEM_USER_BUFFER OemUserInformation;
    /* [case()] */ SAMPR_DOMAIN_DISPLAY_OEM_GROUP_BUFFER OemGroupInformation;
    } 	SAMPR_DISPLAY_INFO_BUFFER;

typedef /* [switch_type] */ union _SAMPR_DISPLAY_INFO_BUFFER *PSAMPR_DISPLAY_INFO_BUFFER;

NTSTATUS SamrConnect( 
    /* [unique][in] */ PSAMPR_SERVER_NAME ServerName,
    /* [out] */ SAMPR_HANDLE *ServerHandle,
    /* [in] */ ACCESS_MASK DesiredAccess);

NTSTATUS SamrCloseHandle( 
    /* [out][in] */ SAMPR_HANDLE *SamHandle);

NTSTATUS SamrSetSecurityObject( 
    /* [in] */ SAMPR_HANDLE ObjectHandle,
    /* [in] */ SECURITY_INFORMATION SecurityInformation,
    /* [in] */ PSAMPR_SR_SECURITY_DESCRIPTOR SecurityDescriptor);

NTSTATUS SamrQuerySecurityObject( 
    /* [in] */ SAMPR_HANDLE ObjectHandle,
    /* [in] */ SECURITY_INFORMATION SecurityInformation,
    /* [out] */ PSAMPR_SR_SECURITY_DESCRIPTOR *SecurityDescriptor);

NTSTATUS SamrShutdownSamServer( 
    /* [in] */ SAMPR_HANDLE ServerHandle);

NTSTATUS SamrLookupDomainInSamServer( 
    /* [in] */ SAMPR_HANDLE ServerHandle,
    /* [in] */ PRPC_UNICODE_STRING Name,
    /* [out] */ PRPC_SID *DomainId);

NTSTATUS SamrEnumerateDomainsInSamServer( 
    /* [in] */ SAMPR_HANDLE ServerHandle,
    /* [out][in] */ PSAM_ENUMERATE_HANDLE EnumerationContext,
    /* [out] */ PSAMPR_ENUMERATION_BUFFER *Buffer,
    /* [in] */ ULONG PreferedMaximumLength,
    /* [out] */ PULONG CountReturned);

NTSTATUS SamrOpenDomain( 
    /* [in] */ SAMPR_HANDLE ServerHandle,
    /* [in] */ ACCESS_MASK DesiredAccess,
    /* [in] */ PRPC_SID DomainId,
    /* [out] */ SAMPR_HANDLE *DomainHandle);

NTSTATUS SamrQueryInformationDomain( 
    /* [in] */ SAMPR_HANDLE DomainHandle,
    /* [in] */ DOMAIN_INFORMATION_CLASS DomainInformationClass,
    /* [switch_is][out] */ PSAMPR_DOMAIN_INFO_BUFFER *Buffer);

NTSTATUS SamrSetInformationDomain( 
    /* [in] */ SAMPR_HANDLE DomainHandle,
    /* [in] */ DOMAIN_INFORMATION_CLASS DomainInformationClass,
    /* [switch_is][in] */ PSAMPR_DOMAIN_INFO_BUFFER DomainInformation);

NTSTATUS SamrCreateGroupInDomain( 
    /* [in] */ SAMPR_HANDLE DomainHandle,
    /* [in] */ PRPC_UNICODE_STRING Name,
    /* [in] */ ACCESS_MASK DesiredAccess,
    /* [out] */ SAMPR_HANDLE *GroupHandle,
    /* [out] */ PULONG RelativeId);

NTSTATUS SamrEnumerateGroupsInDomain( 
    /* [in] */ SAMPR_HANDLE DomainHandle,
    /* [out][in] */ PSAM_ENUMERATE_HANDLE EnumerationContext,
    /* [out] */ PSAMPR_ENUMERATION_BUFFER *Buffer,
    /* [in] */ ULONG PreferedMaximumLength,
    /* [out] */ PULONG CountReturned);

NTSTATUS SamrCreateUserInDomain( 
    /* [in] */ SAMPR_HANDLE DomainHandle,
    /* [in] */ PRPC_UNICODE_STRING Name,
    /* [in] */ ACCESS_MASK DesiredAccess,
    /* [out] */ SAMPR_HANDLE *UserHandle,
    /* [out] */ PULONG RelativeId);

NTSTATUS SamrEnumerateUsersInDomain( 
    /* [in] */ SAMPR_HANDLE DomainHandle,
    /* [out][in] */ PSAM_ENUMERATE_HANDLE EnumerationContext,
    /* [in] */ ULONG UserAccountControl,
    /* [out] */ PSAMPR_ENUMERATION_BUFFER *Buffer,
    /* [in] */ ULONG PreferedMaximumLength,
    /* [out] */ PULONG CountReturned);

NTSTATUS SamrCreateAliasInDomain( 
    /* [in] */ SAMPR_HANDLE DomainHandle,
    /* [in] */ PRPC_UNICODE_STRING AccountName,
    /* [in] */ ACCESS_MASK DesiredAccess,
    /* [out] */ SAMPR_HANDLE *AliasHandle,
    /* [out] */ PULONG RelativeId);

NTSTATUS SamrEnumerateAliasesInDomain( 
    /* [in] */ SAMPR_HANDLE DomainHandle,
    /* [out][in] */ PSAM_ENUMERATE_HANDLE EnumerationContext,
    /* [out] */ PSAMPR_ENUMERATION_BUFFER *Buffer,
    /* [in] */ ULONG PreferedMaximumLength,
    /* [out] */ PULONG CountReturned);

NTSTATUS SamrGetAliasMembership( 
    /* [in] */ SAMPR_HANDLE DomainHandle,
    /* [in] */ PSAMPR_PSID_ARRAY SidArray,
    /* [out] */ PSAMPR_ULONG_ARRAY Membership);

NTSTATUS SamrLookupNamesInDomain( 
    /* [in] */ SAMPR_HANDLE DomainHandle,
    /* [range][in] */ ULONG Count,
    /* [length_is][size_is][in] */ RPC_UNICODE_STRING Names[  ],
    /* [out] */ PSAMPR_ULONG_ARRAY RelativeIds,
    /* [out] */ PSAMPR_ULONG_ARRAY Use);

NTSTATUS SamrLookupIdsInDomain( 
    /* [in] */ SAMPR_HANDLE DomainHandle,
    /* [range][in] */ ULONG Count,
    /* [length_is][size_is][in] */ PULONG RelativeIds,
    /* [out] */ PSAMPR_RETURNED_USTRING_ARRAY Names,
    /* [out] */ PSAMPR_ULONG_ARRAY Use);

NTSTATUS SamrOpenGroup( 
    /* [in] */ SAMPR_HANDLE DomainHandle,
    /* [in] */ ACCESS_MASK DesiredAccess,
    /* [in] */ ULONG GroupId,
    /* [out] */ SAMPR_HANDLE *GroupHandle);

NTSTATUS SamrQueryInformationGroup( 
    /* [in] */ SAMPR_HANDLE GroupHandle,
    /* [in] */ GROUP_INFORMATION_CLASS GroupInformationClass,
    /* [switch_is][out] */ PSAMPR_GROUP_INFO_BUFFER *Buffer);

NTSTATUS SamrSetInformationGroup( 
    /* [in] */ SAMPR_HANDLE GroupHandle,
    /* [in] */ GROUP_INFORMATION_CLASS GroupInformationClass,
    /* [switch_is][in] */ PSAMPR_GROUP_INFO_BUFFER Buffer);

NTSTATUS SamrAddMemberToGroup( 
    /* [in] */ SAMPR_HANDLE GroupHandle,
    /* [in] */ ULONG MemberId,
    /* [in] */ ULONG Attributes);

NTSTATUS SamrDeleteGroup( 
    /* [out][in] */ SAMPR_HANDLE *GroupHandle);

NTSTATUS SamrRemoveMemberFromGroup( 
    /* [in] */ SAMPR_HANDLE GroupHandle,
    /* [in] */ ULONG MemberId);

NTSTATUS SamrGetMembersInGroup( 
    /* [in] */ SAMPR_HANDLE GroupHandle,
    /* [out] */ PSAMPR_GET_MEMBERS_BUFFER *Members);

NTSTATUS SamrSetMemberAttributesOfGroup( 
    /* [in] */ SAMPR_HANDLE GroupHandle,
    /* [in] */ ULONG MemberId,
    /* [in] */ ULONG Attributes);

NTSTATUS SamrOpenAlias( 
    /* [in] */ SAMPR_HANDLE DomainHandle,
    /* [in] */ ACCESS_MASK DesiredAccess,
    /* [in] */ ULONG AliasId,
    /* [out] */ SAMPR_HANDLE *AliasHandle);

NTSTATUS SamrQueryInformationAlias( 
    /* [in] */ SAMPR_HANDLE AliasHandle,
    /* [in] */ ALIAS_INFORMATION_CLASS AliasInformationClass,
    /* [switch_is][out] */ PSAMPR_ALIAS_INFO_BUFFER *Buffer);

NTSTATUS SamrSetInformationAlias( 
    /* [in] */ SAMPR_HANDLE AliasHandle,
    /* [in] */ ALIAS_INFORMATION_CLASS AliasInformationClass,
    /* [switch_is][in] */ PSAMPR_ALIAS_INFO_BUFFER Buffer);

NTSTATUS SamrDeleteAlias( 
    /* [out][in] */ SAMPR_HANDLE *AliasHandle);

NTSTATUS SamrAddMemberToAlias( 
    /* [in] */ SAMPR_HANDLE AliasHandle,
    /* [in] */ PRPC_SID MemberId);

NTSTATUS SamrRemoveMemberFromAlias( 
    /* [in] */ SAMPR_HANDLE AliasHandle,
    /* [in] */ PRPC_SID MemberId);

NTSTATUS SamrGetMembersInAlias( 
    /* [in] */ SAMPR_HANDLE AliasHandle,
    /* [out] */ PSAMPR_PSID_ARRAY_OUT Members);

NTSTATUS SamrOpenUser( 
    /* [in] */ SAMPR_HANDLE DomainHandle,
    /* [in] */ ACCESS_MASK DesiredAccess,
    /* [in] */ ULONG UserId,
    /* [out] */ SAMPR_HANDLE *UserHandle);

NTSTATUS SamrDeleteUser( 
    /* [out][in] */ SAMPR_HANDLE *UserHandle);

NTSTATUS SamrQueryInformationUser( 
    /* [in] */ SAMPR_HANDLE UserHandle,
    /* [in] */ USER_INFORMATION_CLASS UserInformationClass,
    /* [switch_is][out] */ PSAMPR_USER_INFO_BUFFER *Buffer);

NTSTATUS SamrSetInformationUser( 
    /* [in] */ SAMPR_HANDLE UserHandle,
    /* [in] */ USER_INFORMATION_CLASS UserInformationClass,
    /* [switch_is][in] */ PSAMPR_USER_INFO_BUFFER Buffer);

NTSTATUS SamrChangePasswordUser( 
    /* [in] */ SAMPR_HANDLE UserHandle,
    /* [in] */ BOOLEAN LmPresent,
    /* [unique][in] */ PENCRYPTED_LM_OWF_PASSWORD LmOldEncryptedWithLmNew,
    /* [unique][in] */ PENCRYPTED_LM_OWF_PASSWORD LmNewEncryptedWithLmOld,
    /* [in] */ BOOLEAN NtPresent,
    /* [unique][in] */ PENCRYPTED_NT_OWF_PASSWORD NtOldEncryptedWithNtNew,
    /* [unique][in] */ PENCRYPTED_NT_OWF_PASSWORD NtNewEncryptedWithNtOld,
    /* [in] */ BOOLEAN NtCrossEncryptionPresent,
    /* [unique][in] */ PENCRYPTED_NT_OWF_PASSWORD NtNewEncryptedWithLmNew,
    /* [in] */ BOOLEAN LmCrossEncryptionPresent,
    /* [unique][in] */ PENCRYPTED_LM_OWF_PASSWORD LmNtNewEncryptedWithNtNew);

NTSTATUS SamrGetGroupsForUser( 
    /* [in] */ SAMPR_HANDLE UserHandle,
    /* [out] */ PSAMPR_GET_GROUPS_BUFFER *Groups);

NTSTATUS SamrQueryDisplayInformation( 
    /* [in] */ SAMPR_HANDLE DomainHandle,
    /* [in] */ DOMAIN_DISPLAY_INFORMATION DisplayInformationClass,
    /* [in] */ ULONG Index,
    /* [in] */ ULONG EntryCount,
    /* [in] */ ULONG PreferredMaximumLength,
    /* [out] */ PULONG TotalAvailable,
    /* [out] */ PULONG TotalReturned,
    /* [switch_is][out] */ PSAMPR_DISPLAY_INFO_BUFFER Buffer);

NTSTATUS SamrGetDisplayEnumerationIndex( 
    /* [in] */ SAMPR_HANDLE DomainHandle,
    /* [in] */ DOMAIN_DISPLAY_INFORMATION DisplayInformationClass,
    /* [in] */ PRPC_UNICODE_STRING Prefix,
    /* [out] */ PULONG Index);

NTSTATUS SamrTestPrivateFunctionsDomain( 
    /* [in] */ SAMPR_HANDLE DomainHandle);

NTSTATUS SamrTestPrivateFunctionsUser( 
    /* [in] */ SAMPR_HANDLE UserHandle);

NTSTATUS SamrGetUserDomainPasswordInformation( 
    /* [in] */ SAMPR_HANDLE UserHandle,
    /* [out] */ PUSER_DOMAIN_PASSWORD_INFORMATION PasswordInformation);

NTSTATUS SamrRemoveMemberFromForeignDomain( 
    /* [in] */ SAMPR_HANDLE DomainHandle,
    /* [in] */ PRPC_SID MemberSid);

NTSTATUS SamrQueryInformationDomain2( 
    /* [in] */ SAMPR_HANDLE DomainHandle,
    /* [in] */ DOMAIN_INFORMATION_CLASS DomainInformationClass,
    /* [switch_is][out] */ PSAMPR_DOMAIN_INFO_BUFFER *Buffer);

NTSTATUS SamrQueryInformationUser2( 
    /* [in] */ SAMPR_HANDLE UserHandle,
    /* [in] */ USER_INFORMATION_CLASS UserInformationClass,
    /* [switch_is][out] */ PSAMPR_USER_INFO_BUFFER *Buffer);

NTSTATUS SamrQueryDisplayInformation2( 
    /* [in] */ SAMPR_HANDLE DomainHandle,
    /* [in] */ DOMAIN_DISPLAY_INFORMATION DisplayInformationClass,
    /* [in] */ ULONG Index,
    /* [in] */ ULONG EntryCount,
    /* [in] */ ULONG PreferredMaximumLength,
    /* [out] */ PULONG TotalAvailable,
    /* [out] */ PULONG TotalReturned,
    /* [switch_is][out] */ PSAMPR_DISPLAY_INFO_BUFFER Buffer);

NTSTATUS SamrGetDisplayEnumerationIndex2( 
    /* [in] */ SAMPR_HANDLE DomainHandle,
    /* [in] */ DOMAIN_DISPLAY_INFORMATION DisplayInformationClass,
    /* [in] */ PRPC_UNICODE_STRING Prefix,
    /* [out] */ PULONG Index);

NTSTATUS SamrCreateUser2InDomain( 
    /* [in] */ SAMPR_HANDLE DomainHandle,
    /* [in] */ PRPC_UNICODE_STRING Name,
    /* [in] */ ULONG AccountType,
    /* [in] */ ACCESS_MASK DesiredAccess,
    /* [out] */ SAMPR_HANDLE *UserHandle,
    /* [out] */ PULONG GrantedAccess,
    /* [out] */ PULONG RelativeId);

NTSTATUS SamrQueryDisplayInformation3( 
    /* [in] */ SAMPR_HANDLE DomainHandle,
    /* [in] */ DOMAIN_DISPLAY_INFORMATION DisplayInformationClass,
    /* [in] */ ULONG Index,
    /* [in] */ ULONG EntryCount,
    /* [in] */ ULONG PreferredMaximumLength,
    /* [out] */ PULONG TotalAvailable,
    /* [out] */ PULONG TotalReturned,
    /* [switch_is][out] */ PSAMPR_DISPLAY_INFO_BUFFER Buffer);

NTSTATUS SamrAddMultipleMembersToAlias( 
    /* [in] */ SAMPR_HANDLE AliasHandle,
    /* [in] */ PSAMPR_PSID_ARRAY MembersBuffer);

NTSTATUS SamrRemoveMultipleMembersFromAlias( 
    /* [in] */ SAMPR_HANDLE AliasHandle,
    /* [in] */ PSAMPR_PSID_ARRAY MembersBuffer);

NTSTATUS SamrOemChangePasswordUser2( 
    /* [in] */ handle_t BindingHandle,
    /* [unique][in] */ PRPC_STRING ServerName,
    /* [in] */ PRPC_STRING UserName,
    /* [unique][in] */ PSAMPR_ENCRYPTED_USER_PASSWORD NewPasswordEncryptedWithOldLm,
    /* [unique][in] */ PENCRYPTED_LM_OWF_PASSWORD OldLmOwfPassswordEncryptedWithNewLm);

NTSTATUS SamrUnicodeChangePasswordUser2( 
    /* [in] */ handle_t BindingHandle,
    /* [unique][in] */ PRPC_UNICODE_STRING ServerName,
    /* [in] */ PRPC_UNICODE_STRING UserName,
    /* [unique][in] */ PSAMPR_ENCRYPTED_USER_PASSWORD NewPasswordEncryptedWithOldNt,
    /* [unique][in] */ PENCRYPTED_NT_OWF_PASSWORD OldNtOwfPasswordEncryptedWithNewNt,
    /* [in] */ BOOLEAN LmPresent,
    /* [unique][in] */ PSAMPR_ENCRYPTED_USER_PASSWORD NewPasswordEncryptedWithOldLm,
    /* [unique][in] */ PENCRYPTED_LM_OWF_PASSWORD OldLmOwfPassswordEncryptedWithNewLmOrNt);

NTSTATUS SamrGetDomainPasswordInformation( 
    /* [in] */ handle_t BindingHandle,
    /* [unique][in] */ PRPC_UNICODE_STRING ServerName,
    /* [out] */ PUSER_DOMAIN_PASSWORD_INFORMATION PasswordInformation);

NTSTATUS SamrConnect2( 
    /* [string][unique][in] */ PSAMPR_SERVER_NAME ServerName,
    /* [out] */ SAMPR_HANDLE *ServerHandle,
    /* [in] */ ACCESS_MASK DesiredAccess);

NTSTATUS SamrSetInformationUser2( 
    /* [in] */ SAMPR_HANDLE UserHandle,
    /* [in] */ USER_INFORMATION_CLASS UserInformationClass,
    /* [switch_is][in] */ PSAMPR_USER_INFO_BUFFER Buffer);

NTSTATUS SamrSetBootKeyInformation( 
    /* [in] */ SAMPR_HANDLE DomainHandle,
    /* [in] */ SAMPR_BOOT_TYPE BootOptions,
    /* [unique][in] */ PRPC_UNICODE_STRING OldBootKey,
    /* [unique][in] */ PRPC_UNICODE_STRING NewBootKey);

NTSTATUS SamrGetBootKeyInformation( 
    /* [in] */ SAMPR_HANDLE DomainHandle,
    /* [out] */ PSAMPR_BOOT_TYPE BootOptions);

NTSTATUS SamrConnect3( 
    /* [string][unique][in] */ PSAMPR_SERVER_NAME ServerName,
    /* [out] */ SAMPR_HANDLE *ServerHandle,
    /* [in] */ ULONG ClientRevision,
    /* [in] */ ACCESS_MASK DesiredAccess);

NTSTATUS SamrConnect4( 
    /* [string][unique][in] */ PSAMPR_SERVER_NAME ServerName,
    /* [out] */ SAMPR_HANDLE *ServerHandle,
    /* [in] */ ULONG ClientRevision,
    /* [in] */ ACCESS_MASK DesiredAccess);

NTSTATUS SamrUnicodeChangePasswordUser3( 
    /* [in] */ handle_t BindingHandle,
    /* [unique][in] */ PRPC_UNICODE_STRING ServerName,
    /* [in] */ PRPC_UNICODE_STRING UserName,
    /* [unique][in] */ PSAMPR_ENCRYPTED_USER_PASSWORD NewPasswordEncryptedWithOldNt,
    /* [unique][in] */ PENCRYPTED_NT_OWF_PASSWORD OldNtOwfPasswordEncryptedWithNewNt,
    /* [in] */ BOOLEAN LmPresent,
    /* [unique][in] */ PSAMPR_ENCRYPTED_USER_PASSWORD NewPasswordEncryptedWithOldLm,
    /* [unique][in] */ PENCRYPTED_LM_OWF_PASSWORD OldLmOwfPassswordEncryptedWithNewLmOrNt,
    /* [unique][in] */ PSAMPR_ENCRYPTED_USER_PASSWORD AdditionalData,
    /* [out] */ PDOMAIN_PASSWORD_INFORMATION *EffectivePasswordPolicy,
    /* [out] */ PUSER_PWD_CHANGE_FAILURE_INFORMATION *PasswordChangeInfo);

NTSTATUS SamrConnect5( 
    /* [string][unique][in] */ PSAMPR_SERVER_NAME ServerName,
    /* [in] */ ACCESS_MASK DesiredAccess,
    /* [in] */ ULONG InVersion,
    /* [switch_is][in] */ SAMPR_REVISION_INFO *InRevisionInfo,
    /* [out] */ ULONG *OutVersion,
    /* [switch_is][out] */ SAMPR_REVISION_INFO *OutRevisionInfo,
    /* [out] */ SAMPR_HANDLE *ServerHandle);

NTSTATUS SamrRidToSid( 
    /* [in] */ SAMPR_HANDLE ObjectHandle,
    /* [in] */ ULONG Rid,
    /* [out] */ PRPC_SID *Sid);

NTSTATUS SamrSetDSRMPassword( 
    /* [in] */ handle_t BindingHandle,
    /* [unique][in] */ PRPC_UNICODE_STRING ServerName,
    /* [in] */ ULONG UserId,
    /* [unique][in] */ PENCRYPTED_NT_OWF_PASSWORD EncryptedNtOwfPassword);

NTSTATUS SamrValidatePassword( 
    /* [in] */ handle_t Handle,
    /* [in] */ PASSWORD_POLICY_VALIDATION_TYPE ValidationType,
    /* [switch_is][in] */ PSAM_VALIDATE_INPUT_ARG InputArg,
    /* [switch_is][out] */ PSAM_VALIDATE_OUTPUT_ARG *OutputArg);


extern handle_t samsrv_handle;


extern RPC_IF_HANDLE samr_ClientIfHandle;
extern RPC_IF_HANDLE samr_ServerIfHandle;
#endif /* __samr_INTERFACE_DEFINED__ */

/* Additional Prototypes for ALL interfaces */

handle_t __RPC_USER PSAMPR_SERVER_NAME_bind  ( PSAMPR_SERVER_NAME );
void     __RPC_USER PSAMPR_SERVER_NAME_unbind( PSAMPR_SERVER_NAME, handle_t );

void __RPC_USER SAMPR_HANDLE_rundown( SAMPR_HANDLE );

/* end of Additional Prototypes */

#ifdef __cplusplus
}
#endif

#endif
=== C:/Users/treeman/Desktop/windows nt source code\Source\Win2K3\NT\public\internal\ds\inc\samsrv.h ===
/*++

Copyright (c) 1990  Microsoft Corporation

Module Name:

    samsrv.h

Abstract:

    This file contains SAM server definitions that are used both
    internally within the SAM server and by other components
    in the security server.


    NOTE:  NetLogon calls SAM's RPC server stubs directly.
           The interface definitions for those routines are
           defined in MIDL generated include files.


Author:

    Jim Kelly    (JimK)  1-Feb-199

Environment:

    User Mode - Win32

Revision History:


--*/

#ifndef _SAMSRV_
#define _SAMSRV_



///////////////////////////////////////////////////////////////////////////////
//                                                                           //
// Includes                                                                  //
//                                                                           //
///////////////////////////////////////////////////////////////////////////////

#include <nt.h>
#include <ntsam.h>




///////////////////////////////////////////////////////////////////////////////
//                                                                           //
// The following prototypes are usable throughout the process that SAM       //
// resides in.  This may include calls by LAN Manager code that is not       //
// part of SAM but is in the same process as SAM.                            //
//                                                                           //
// Many private services, defined in samisrv.h, are also available           //
// to NetLogon through a special arrangement.                                //
//                                                                           //
//                                                                           //
///////////////////////////////////////////////////////////////////////////////


NTSTATUS
SamIInitialize( VOID );




#endif  // _SAMSRV_
=== C:/Users/treeman/Desktop/windows nt source code\Source\Win2K3\NT\public\internal\ds\inc\scesrv.h ===
#include <svcs.h>

extern "C" {

DWORD
WINAPI
ScesrvInitializeServer(
    IN PSVCS_START_RPC_SERVER pStartRpcServer
    );

DWORD
WINAPI
ScesrvTerminateServer(
    IN PSVCS_STOP_RPC_SERVER pStopRpcServer
    );

}
=== C:/Users/treeman/Desktop/windows nt source code\Source\Win2K3\NT\public\internal\ds\inc\sbslicensing.h ===
/* this ALWAYS GENERATED file contains the definitions for the interfaces */


 /* File created by MIDL compiler version 6.00.0361 */
/* Compiler settings for sbslicensing.idl:
    Oicf, W1, Zp8, env=Win32 (32b run)
    protocol : dce , ms_ext, c_ext, robust
    error checks: allocation ref bounds_check enum stub_data 
    VC __declspec() decoration level: 
         __declspec(uuid()), __declspec(selectany), __declspec(novtable)
         DECLSPEC_UUID(), MIDL_INTERFACE()
*/
//@@MIDL_FILE_HEADING(  )

#pragma warning( disable: 4049 )  /* more than 64k source lines */


/* verify that the <rpcndr.h> version is high enough to compile this file*/
#ifndef __REQUIRED_RPCNDR_H_VERSION__
#define __REQUIRED_RPCNDR_H_VERSION__ 475
#endif

#include "rpc.h"
#include "rpcndr.h"

#ifndef __RPCNDR_H_VERSION__
#error this stub requires an updated version of <rpcndr.h>
#endif // __RPCNDR_H_VERSION__

#ifndef COM_NO_WINDOWS_H
#include "windows.h"
#include "ole2.h"
#endif /*COM_NO_WINDOWS_H*/

#ifndef __sbslicensing_h__
#define __sbslicensing_h__

#if defined(_MSC_VER) && (_MSC_VER >= 1020)
#pragma once
#endif

/* Forward Declarations */ 

#ifndef __ISBSLicensing_FWD_DEFINED__
#define __ISBSLicensing_FWD_DEFINED__
typedef interface ISBSLicensing ISBSLicensing;
#endif 	/* __ISBSLicensing_FWD_DEFINED__ */


#ifndef __SBSLicensing_FWD_DEFINED__
#define __SBSLicensing_FWD_DEFINED__

#ifdef __cplusplus
typedef class SBSLicensing SBSLicensing;
#else
typedef struct SBSLicensing SBSLicensing;
#endif /* __cplusplus */

#endif 	/* __SBSLicensing_FWD_DEFINED__ */


/* header files for imported files */
#include "oaidl.h"
#include "ocidl.h"

#ifdef __cplusplus
extern "C"{
#endif 

void * __RPC_USER MIDL_user_allocate(size_t);
void __RPC_USER MIDL_user_free( void * ); 

#ifndef __ISBSLicensing_INTERFACE_DEFINED__
#define __ISBSLicensing_INTERFACE_DEFINED__

/* interface ISBSLicensing */
/* [unique][helpstring][dual][uuid][object] */ 


EXTERN_C const IID IID_ISBSLicensing;

#if defined(__cplusplus) && !defined(CINTERFACE)
    
    MIDL_INTERFACE("B7BC7D15-0B67-4E85-8717-131AE71E90DC")
    ISBSLicensing : public IDispatch
    {
    public:
        virtual /* [helpstring][id] */ HRESULT STDMETHODCALLTYPE GetNumLicenseCodes( 
            INT *pNumLicenseCodes) = 0;
        
        virtual /* [helpstring][id] */ HRESULT STDMETHODCALLTYPE GetNumLicenses( 
            INT *pNumLicenses) = 0;
        
        virtual /* [helpstring][id] */ HRESULT STDMETHODCALLTYPE InBypassMode( void) = 0;
        
        virtual /* [helpstring][id] */ HRESULT STDMETHODCALLTYPE ValidateProductKey( 
            BSTR bszProductKey,
            INT *piNumLicenses) = 0;
        
        virtual /* [helpstring][id] */ HRESULT STDMETHODCALLTYPE GetSingleLicenseHistory( 
            UINT uiIndex,
            BSTR *pbszProductKey,
            INT *piNumLicenses,
            SYSTEMTIME *pstActivationDate) = 0;
        
        virtual /* [helpstring][id] */ HRESULT STDMETHODCALLTYPE GetMaxLicenseUsage( 
            UINT *puiMaxLicenseUsage) = 0;
        
        virtual /* [helpstring][id] */ HRESULT STDMETHODCALLTYPE ActivateUsingInternet( 
            WCHAR *wszPid) = 0;
        
        virtual /* [helpstring][id] */ HRESULT STDMETHODCALLTYPE GenerateInstallationId( 
            BSTR bszProductKey,
            BSTR *pbszInstallationId) = 0;
        
        virtual /* [helpstring][id] */ HRESULT STDMETHODCALLTYPE DepositConfirmationId( 
            BSTR bszProductKey,
            BSTR bszConfirmationId) = 0;
        
        virtual /* [helpstring][id] */ HRESULT STDMETHODCALLTYPE BackupLicenseStore( 
            WCHAR *wszFilename) = 0;
        
        virtual /* [helpstring][id] */ HRESULT STDMETHODCALLTYPE RestoreLicenseStore( 
            WCHAR *wszFilename) = 0;
        
        virtual /* [helpstring][id] */ HRESULT STDMETHODCALLTYPE IsLicenseStoreValid( void) = 0;
        
        virtual /* [helpstring][id] */ HRESULT STDMETHODCALLTYPE OverwriteLicenseStore( void) = 0;
        
        virtual /* [helpstring][id] */ HRESULT STDMETHODCALLTYPE RestoreRegKeys( 
            INT iNumLicenses) = 0;
        
        virtual /* [helpstring][id] */ HRESULT STDMETHODCALLTYPE SetCustomData( 
            INT iField,
            BSTR bszData) = 0;
        
        virtual /* [helpstring][id] */ HRESULT STDMETHODCALLTYPE GetCustomData( 
            INT iField,
            BSTR *pbszData) = 0;
        
    };
    
#else 	/* C style interface */

    typedef struct ISBSLicensingVtbl
    {
        BEGIN_INTERFACE
        
        HRESULT ( STDMETHODCALLTYPE *QueryInterface )( 
            ISBSLicensing * This,
            /* [in] */ REFIID riid,
            /* [iid_is][out] */ void **ppvObject);
        
        ULONG ( STDMETHODCALLTYPE *AddRef )( 
            ISBSLicensing * This);
        
        ULONG ( STDMETHODCALLTYPE *Release )( 
            ISBSLicensing * This);
        
        HRESULT ( STDMETHODCALLTYPE *GetTypeInfoCount )( 
            ISBSLicensing * This,
            /* [out] */ UINT *pctinfo);
        
        HRESULT ( STDMETHODCALLTYPE *GetTypeInfo )( 
            ISBSLicensing * This,
            /* [in] */ UINT iTInfo,
            /* [in] */ LCID lcid,
            /* [out] */ ITypeInfo **ppTInfo);
        
        HRESULT ( STDMETHODCALLTYPE *GetIDsOfNames )( 
            ISBSLicensing * This,
            /* [in] */ REFIID riid,
            /* [size_is][in] */ LPOLESTR *rgszNames,
            /* [in] */ UINT cNames,
            /* [in] */ LCID lcid,
            /* [size_is][out] */ DISPID *rgDispId);
        
        /* [local] */ HRESULT ( STDMETHODCALLTYPE *Invoke )( 
            ISBSLicensing * This,
            /* [in] */ DISPID dispIdMember,
            /* [in] */ REFIID riid,
            /* [in] */ LCID lcid,
            /* [in] */ WORD wFlags,
            /* [out][in] */ DISPPARAMS *pDispParams,
            /* [out] */ VARIANT *pVarResult,
            /* [out] */ EXCEPIN