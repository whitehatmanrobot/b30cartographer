 COLOR_3DFACE                15
#define COLOR_3DSHADOW              16
#define COLOR_GRAYTEXT              17
#define COLOR_BTNTEXT               18
#if (WINVER >= 0x030a)
#define COLOR_INACTIVECAPTIONTEXT   19
#define COLOR_3DHILIGHT             20
#if (WINVER >= 0x0400)
#define COLOR_3DDKSHADOW            21
#define COLOR_3DLIGHT               22
#define COLOR_INFOTEXT              23
#define COLOR_INFOBK                24
#endif /* WINVER >= 0x0400 */
#endif  /* WINVER >= 0x030a */

#define COLOR_BACKGROUND            COLOR_DESKTOP
#define COLOR_BTNFACE               COLOR_3DFACE
#define COLOR_BTNSHADOW             COLOR_3DSHADOW
#define COLOR_BTNHIGHLIGHT          COLOR_3DHILIGHT

#endif  /* NOCOLOR */

/****** GDI Object Support **************************************************/

#ifndef NOGDIOBJ

HGDIOBJ WINAPI GetStockObject(int);

BOOL    WINAPI IsGDIObject(HGDIOBJ);

BOOL    WINAPI DeleteObject(HGDIOBJ);
HGDIOBJ WINAPI SelectObject(HDC, HGDIOBJ);
int     WINAPI GetObject(HGDIOBJ, int, void FAR*);
BOOL    WINAPI UnrealizeObject(HGDIOBJ);

#ifdef STRICT
typedef (CALLBACK* GOBJENUMPROC)(void FAR*, LPARAM);
#else
typedef FARPROC GOBJENUMPROC;
#endif

#ifdef STRICT
int     WINAPI EnumObjects(HDC, int, GOBJENUMPROC, LPARAM);
#else
int     WINAPI EnumObjects(HDC, int, GOBJENUMPROC, LPSTR);
#endif

/* Object types for EnumObjects() */
#define OBJ_PEN         1
#define OBJ_BRUSH       2

#if (WINVER >= 0x0400)

HANDLE WINAPI SetObjectOwner(HGDIOBJ, HANDLE);

#endif

/****** Pen support *********************************************************/

/* Logical Pen */
typedef struct tagLOGPEN
{
    UINT    lopnStyle;
    POINT   lopnWidth;
    COLORREF lopnColor;
} LOGPEN;
typedef LOGPEN*       PLOGPEN;
typedef LOGPEN NEAR* NPLOGPEN;
typedef LOGPEN FAR*  LPLOGPEN;

/* Pen Styles */
#define PS_SOLID        0
#define PS_DASH         1
#define PS_DOT          2
#define PS_DASHDOT      3
#define PS_DASHDOTDOT   4
#define PS_NULL         5
#define PS_INSIDEFRAME  6

HPEN    WINAPI CreatePen(int, int, COLORREF);
HPEN    WINAPI CreatePenIndirect(LOGPEN FAR*);

/* Stock pens for use with GetStockObject(); */
#define WHITE_PEN       6
#define BLACK_PEN       7
#define NULL_PEN        8

/****** Brush support *******************************************************/

/* Brush Styles */
#define BS_SOLID        0
#define BS_NULL         1
#define BS_HOLLOW       BS_NULL
#define BS_HATCHED      2
#define BS_PATTERN      3
#define BS_INDEXED      4
#define BS_DIBPATTERN   5

/* Hatch Styles */
#define HS_HORIZONTAL   0
#define HS_VERTICAL     1
#define HS_FDIAGONAL    2
#define HS_BDIAGONAL    3
#define HS_CROSS        4
#define HS_DIAGCROSS    5
#define HS_API_MAX      6

/* Logical Brush (or Pattern) */
typedef struct tagLOGBRUSH
{
    UINT     lbStyle;
    COLORREF lbColor;
    int      lbHatch;
} LOGBRUSH;
typedef LOGBRUSH*       PLOGBRUSH;
typedef LOGBRUSH NEAR* NPLOGBRUSH;
typedef LOGBRUSH FAR*  LPLOGBRUSH;

typedef LOGBRUSH        PATTERN;
typedef PATTERN*       PPATTERN;
typedef PATTERN NEAR* NPPATTERN;
typedef PATTERN FAR*  LPPATTERN;

HBRUSH  WINAPI CreateSolidBrush(COLORREF);
HBRUSH  WINAPI CreateHatchBrush(int, COLORREF);
HBRUSH  WINAPI CreatePatternBrush(HBITMAP);
HBRUSH  WINAPI CreateDIBPatternBrush(HGLOBAL, UINT);
HBRUSH  WINAPI CreateBrushIndirect(LOGBRUSH FAR*);

/* Stock brushes for use with GetStockObject() */
#define WHITE_BRUSH    0
#define LTGRAY_BRUSH   1
#define GRAY_BRUSH     2
#define DKGRAY_BRUSH   3
#define BLACK_BRUSH    4
#define NULL_BRUSH     5
#define HOLLOW_BRUSH   NULL_BRUSH

DWORD   WINAPI SetBrushOrg(HDC, int, int);
DWORD   WINAPI GetBrushOrg(HDC);

#if (WINVER >= 0x030a)
BOOL    WINAPI GetBrushOrgEx(HDC, POINT FAR*);
#endif  /* WINVER >= 0x030a */
#endif /* NOGDIOBJ */

/****** Region support ******************************************************/

HRGN    WINAPI CreateRectRgn(int, int, int, int);
HRGN    WINAPI CreateRectRgnIndirect(LPCRECT);
HRGN    WINAPI CreateEllipticRgnIndirect(LPCRECT);
HRGN    WINAPI CreateEllipticRgn(int, int, int, int);
HRGN    WINAPI CreatePolygonRgn(LPCPOINT, int, int);
HRGN    WINAPI CreatePolyPolygonRgn(LPCPOINT, const int FAR*, int, int);
HRGN    WINAPI CreateRoundRectRgn(int, int, int, int, int, int);

/* Region type flags */
#define ERROR           0
#define NULLREGION      1
#define SIMPLEREGION    2
#define COMPLEXREGION   3

void    WINAPI SetRectRgn(HRGN, int, int, int, int);

int     WINAPI CombineRgn(HRGN, HRGN, HRGN, int);

/* CombineRgn() command values */
#define RGN_AND         1
#define RGN_OR          2
#define RGN_XOR         3
#define RGN_DIFF        4
#define RGN_COPY        5

BOOL    WINAPI EqualRgn(HRGN, HRGN);
int     WINAPI OffsetRgn(HRGN, int, int);

int     WINAPI GetRgnBox(HRGN, LPRECT);

BOOL    WINAPI RectInRegion(HRGN, LPCRECT);
BOOL    WINAPI PtInRegion(HRGN, int, int);

/****** Color palette Support ************************************************/

#define PALETTERGB(r,g,b)   (0x02000000L | RGB(r,g,b))
#define PALETTEINDEX(i)     ((COLORREF)(0x01000000L | (DWORD)(WORD)(i)))

typedef struct tagPALETTEENTRY
{
    BYTE    peRed;
    BYTE    peGreen;
    BYTE    peBlue;
    BYTE    peFlags;
} PALETTEENTRY;
typedef PALETTEENTRY FAR* LPPALETTEENTRY;

/* Palette entry flags */
#define PC_RESERVED 0x01 /* palette index used for animation */
#define PC_EXPLICIT 0x02 /* palette index is explicit to device */
#define PC_NOCOLLAPSE 0x04 /* do not match color to system palette */

/* Logical Palette */
typedef struct tagLOGPALETTE
{
    WORD    palVersion;
    WORD    palNumEntries;
    PALETTEENTRY palPalEntry[1];
} LOGPALETTE;
typedef LOGPALETTE*       PLOGPALETTE;
typedef LOGPALETTE NEAR* NPLOGPALETTE;
typedef LOGPALETTE FAR*  LPLOGPALETTE;

HPALETTE WINAPI CreatePalette(const LOGPALETTE FAR*);

HPALETTE WINAPI SelectPalette(HDC, HPALETTE, BOOL);

UINT    WINAPI RealizePalette(HDC);

int     WINAPI UpdateColors(HDC);
void    WINAPI AnimatePalette(HPALETTE, UINT, UINT, const PALETTEENTRY FAR*);

UINT    WINAPI SetPaletteEntries(HPALETTE, UINT, UINT, const PALETTEENTRY FAR*);
UINT    WINAPI GetPaletteEntries(HPALETTE, UINT, UINT, PALETTEENTRY FAR*);

UINT    WINAPI GetNearestPaletteIndex(HPALETTE, COLORREF);

BOOL    WINAPI ResizePalette(HPALETTE, UINT);

UINT    WINAPI GetSystemPaletteEntries(HDC, UINT, UINT, PALETTEENTRY FAR*);

UINT    WINAPI GetSystemPaletteUse(HDC);
UINT    WINAPI SetSystemPaletteUse(HDC, UINT);

/* Get/SetSystemPaletteUse() values */
#define SYSPAL_STATIC   1
#define SYSPAL_NOSTATIC 2

/****** Clipping support *****************************************************/

int     WINAPI SelectClipRgn(HDC, HRGN);
int     WINAPI GetClipBox(HDC, LPRECT);

int     WINAPI IntersectClipRect(HDC, int, int, int, int);
int     WINAPI OffsetClipRgn(HDC, int, int);
int     WINAPI ExcludeClipRect(HDC, int, int, int, int);

BOOL    WINAPI PtVisible(HDC, int, int);
BOOL    WINAPI RectVisible(HDC, LPCRECT);

/****** General drawing support ********************************************/

DWORD   WINAPI MoveTo(HDC, int, int);
DWORD   WINAPI GetCurrentPosition(HDC);

#if (WINVER >= 0x030a)
BOOL    WINAPI MoveToEx(HDC, int, int, POINT FAR*);
BOOL    WINAPI GetCurrentPositionEx(HDC, POINT FAR*);
#endif  /* WINVER >= 0x030a */

BOOL    WINAPI LineTo(HDC, int, int);
BOOL    WINAPI Polyline(HDC, LPCPOINT, int);

#ifdef STRICT
typedef void (CALLBACK* LINEDDAPROC)(int, int, LPARAM);
#else
typedef FARPROC LINEDDAPROC;
#endif

void    WINAPI LineDDA(int, int, int, int, LINEDDAPROC, LPARAM);

BOOL    WINAPI Rectangle(HDC, int, int, int, int);
BOOL    WINAPI RoundRect(HDC, int, int, int, int, int, int);

BOOL    WINAPI Ellipse(HDC, int, int, int, int);
BOOL    WINAPI Arc(HDC, int, int, int, int, int, int, int, int);
BOOL    WINAPI Chord(HDC, int, int, int, int, int, int, int, int);
BOOL    WINAPI Pie(HDC, int, int, int, int, int, int, int, int);

BOOL    WINAPI Polygon(HDC, LPCPOINT, int);
BOOL    WINAPI PolyPolygon(HDC, LPCPOINT, int FAR*, int);

/* PolyFill Modes */
#define ALTERNATE   1
#define WINDING     2

int     WINAPI SetPolyFillMode(HDC, int);
int     WINAPI GetPolyFillMode(HDC);

BOOL    WINAPI FloodFill(HDC, int, int, COLORREF);
BOOL    WINAPI ExtFloodFill(HDC, int, int, COLORREF, UINT);

/* ExtFloodFill style flags */
#define  FLOODFILLBORDER   0
#define  FLOODFILLSURFACE  1

BOOL    WINAPI FillRgn(HDC, HRGN, HBRUSH);
BOOL    WINAPI FrameRgn(HDC, HRGN, HBRUSH, int, int);
BOOL    WINAPI InvertRgn(HDC, HRGN);
BOOL    WINAPI PaintRgn(HDC, HRGN);

/* Rectangle output routines */
int     WINAPI FillRect(HDC, LPCRECT, HBRUSH);
int     WINAPI FrameRect(HDC, LPCRECT, HBRUSH);
BOOL    WINAPI InvertRect(HDC, LPCRECT);

void    WINAPI DrawFocusRect(HDC, LPCRECT);

/****** Text support ********************************************************/

BOOL    WINAPI TextOut(HDC, int, int, LPCSTR, int);
LONG    WINAPI TabbedTextOut(HDC, int, int, LPCSTR, int, int, int FAR*, int);
BOOL    WINAPI ExtTextOut(HDC, int, int, UINT, LPCRECT, LPCSTR, UINT, int FAR*);

#define ETO_GRAYED      0x0001
#define ETO_OPAQUE      0x0002
#define ETO_CLIPPED     0x0004
#define ETO_GLYPH_INDEX 0x0010
#define ETO_RTLREADING	0x0080

DWORD   WINAPI GetTextExtent(HDC, LPCSTR, int);
DWORD   WINAPI GetTabbedTextExtent(HDC, LPCSTR, int, int, int FAR*);

#if (WINVER >= 0x030a)
BOOL    WINAPI GetTextExtentPoint(HDC, LPCSTR, int, SIZE FAR*);
#endif  /* WINVER >= 0x030a */

/* DrawText() Format Flags */
#ifndef NODRAWTEXT
#define DT_LEFT             0x0000
#define DT_CENTER           0x0001
#define DT_RIGHT            0x0002
#define DT_TOP              0x0000
#define DT_VCENTER          0x0004
#define DT_BOTTOM           0x0008
#define DT_WORDBREAK        0x0010
#define DT_SINGLELINE       0x0020
#define DT_EXPANDTABS       0x0040
#define DT_TABSTOP          0x0080
#define DT_NOCLIP           0x0100
#define DT_EXTERNALLEADING  0x0200
#define DT_CALCRECT         0x0400
#define DT_NOPREFIX         0x0800
#define DT_INTERNAL         0x1000
#define DT_EDITCONTROL      0x00002000

int     WINAPI DrawText(HDC, LPCSTR, int, LPRECT, UINT);

#if (WINVER >= 0x0400)
typedef struct tagDRAWTEXTPARAMS
{
    DWORD   cbSize;
    int     iTabLength;
    int     iLeftMargin;
    int     iRightMargin;
    UINT    uiLengthDrawn;
}   DRAWTEXTPARAMS, FAR *LPDRAWTEXTPARAMS;

int     WINAPI DrawTextEx(HDC, LPSTR, int, LPRECT, DWORD, LPDRAWTEXTPARAMS);
#endif /* WINVER >= 0x0400 */

#endif  /* NODRAWTEXT */

#ifdef STRICT
typedef BOOL (CALLBACK* GRAYSTRINGPROC)(HDC, LPARAM, int);
#else
typedef FARPROC GRAYSTRINGPROC;
#endif

BOOL    WINAPI GrayString(HDC, HBRUSH, GRAYSTRINGPROC, LPARAM, int, int, int, int, int);

/* Monolithic state-drawing routine */

#if (WINVER >= 0x0400)
/* Image type */
#define DST_COMPLEX     0x0000
#define DST_TEXT        0x0001
#define DST_PREFIXTEXT  0x0002
#define DST_ICON        0x0003
#define DST_BITMAP      0x0004

/* State type */
#define DSS_NORMAL      0x0000
#define DSS_UNION       0x0010  /* Old gray string appearance */
#define DSS_DISABLED    0x0020
#define DSS_MONO        0x0080
#define DSS_RIGHT 		0x8000

#ifdef STRICT
typedef BOOL (CALLBACK* DRAWSTATEPROC)(HDC, LPARAM, WPARAM, int, int);
#else
typedef FARPROC DRAWSTATEPROC;
#endif
BOOL    WINAPI DrawState(HDC, HBRUSH, DRAWSTATEPROC, LPARAM, WPARAM, int, int, int, int, UINT);
#endif /* WINVER >= 0x0400 */

BOOL    WINAPI GetCharWidth(HDC, UINT, UINT, int FAR*);

COLORREF WINAPI SetTextColor(HDC, COLORREF);
COLORREF WINAPI GetTextColor(HDC);

COLORREF WINAPI SetBkColor(HDC, COLORREF);
COLORREF WINAPI GetBkColor(HDC);

int     WINAPI SetBkMode(HDC, int);
int     WINAPI GetBkMode(HDC);

/* Background Modes */
#define TRANSPARENT     1
#define OPAQUE          2

UINT    WINAPI SetTextAlign(HDC, UINT);
UINT    WINAPI GetTextAlign(HDC);

/* Text Alignment Options */
#define TA_NOUPDATECP   0x0000
#define TA_UPDATECP     0x0001
#define TA_LEFT         0x0000
#define TA_RIGHT        0x0002
#define TA_CENTER       0x0006
#define TA_TOP          0x0000
#define TA_BOTTOM       0x0008
#define TA_BASELINE     0x0018
#define TA_RTLREADING   0x0100

int     WINAPI SetTextCharacterExtra(HDC, int);
int     WINAPI GetTextCharacterExtra(HDC);

int     WINAPI SetTextJustification(HDC, int, int);

/****** Font support ********************************************************/

/* Logical Font */
#define LF_FACESIZE     32

#ifndef NOGDIOBJ
typedef struct tagLOGFONT
{
    int     lfHeight;
    int     lfWidth;
    int     lfEscapement;
    int     lfOrientation;
    int     lfWeight;
    BYTE    lfItalic;
    BYTE    lfUnderline;
    BYTE    lfStrikeOut;
    BYTE    lfCharSet;
    BYTE    lfOutPrecision;
    BYTE    lfClipPrecision;
    BYTE    lfQuality;
    BYTE    lfPitchAndFamily;
    char    lfFaceName[LF_FACESIZE];
} LOGFONT;
typedef LOGFONT*       PLOGFONT;
typedef LOGFONT NEAR* NPLOGFONT;
typedef LOGFONT FAR*  LPLOGFONT;

/* weight values */
#define FW_DONTCARE     0
#define FW_THIN         100
#define FW_EXTRALIGHT   200
#define FW_LIGHT        300
#define FW_NORMAL       400
#define FW_MEDIUM       500
#define FW_SEMIBOLD     600
#define FW_BOLD         700
#define FW_EXTRABOLD    800
#define FW_HEAVY        900

#define FW_ULTRALIGHT   FW_EXTRALIGHT
#define FW_REGULAR      FW_NORMAL
#define FW_DEMIBOLD     FW_SEMIBOLD
#define FW_ULTRABOLD    FW_EXTRABOLD
#define FW_BLACK        FW_HEAVY

/* CharSet values */
#define ANSI_CHARSET        0
#define DEFAULT_CHARSET     1
#define SYMBOL_CHARSET      2
#if (WINVER >= 0x0400)
#define	MAC_CHARSET         77
#endif /* WINVER >= 0x0400 */
#define SHIFTJIS_CHARSET    128
#define HANGEUL_CHARSET     129
#define JOHAB_CHARSET       130
#define GB2312_CHARSET      134
#define CHINESEBIG5_CHARSET 136
#define GREEK_CHARSET		 161
#define TURKISH_CHARSET		 162
#define HEBREW_CHARSET		 177
#define ARABIC_CHARSET		 178
#define BALTIC_CHARSET      186
#define RUSSIAN_CHARSET		 204
#define THAI_CHARSET			 222
#define EASTEUROPE_CHARSET	 238
#define OEM_CHARSET         255

/* OutPrecision values */
#define OUT_DEFAULT_PRECIS      0
#define OUT_STRING_PRECIS       1
#define OUT_CHARACTER_PRECIS    2
#define OUT_STROKE_PRECIS       3
#if (WINVER >= 0x030a)
#define OUT_TT_PRECIS           4
#define OUT_DEVICE_PRECIS       5
#define OUT_RASTER_PRECIS       6
#define OUT_TT_ONLY_PRECIS      7
#endif  /* WINVER >= 0x030a */

/* ClipPrecision values */
#define CLIP_DEFAULT_PRECIS     0x00
#define CLIP_CHARACTER_PRECIS   0x01
#define CLIP_STROKE_PRECIS      0x02
#define CLIP_MASK               0x0F
#if (WINVER >= 0x030a)
#define CLIP_LH_ANGLES          0x10
#define CLIP_TT_ALWAYS          0x20
#define CLIP_EMBEDDED           0x80
#endif  /* WINVER >= 0x030a */

/* Quality values */
#define DEFAULT_QUALITY     0
#define DRAFT_QUALITY       1
#define PROOF_QUALITY       2
#if (WINVER >= 0x400)
#define NONANTIALIASED_QUALITY  3
#define ANTIALIASED_QUALITY     4
#endif  /* WINVER >= 0x400 */

/* PitchAndFamily pitch values (low 4 bits) */
#define DEFAULT_PITCH       0x00
#define FIXED_PITCH         0x01
#define VARIABLE_PITCH      0x02
#if (WINVER >= 0x400)
#define MONO_FONT           0x08
#endif

/* PitchAndFamily family values (high 4 bits) */
#define FF_DONTCARE         0x00
#define FF_ROMAN            0x10
#define FF_SWISS            0x20
#define FF_MODERN           0x30
#define FF_SCRIPT           0x40
#define FF_DECORATIVE       0x50

HFONT   WINAPI CreateFont(int, int, int, int, int, BYTE, BYTE, BYTE, BYTE, BYTE, BYTE, BYTE, BYTE, LPCSTR);
HFONT   WINAPI CreateFontIndirect(const LOGFONT FAR*);

/* Stock fonts for use with GetStockObject() */
#define OEM_FIXED_FONT      10
#define ANSI_FIXED_FONT     11
#define ANSI_VAR_FONT       12
#define SYSTEM_FONT         13
#define DEVICE_DEFAULT_FONT 14
#define DEFAULT_PALETTE     15
#define SYSTEM_FIXED_FONT   16
#define DEFAULT_GUI_FONT    17

DWORD   WINAPI SetMapperFlags(HDC, DWORD);
#define ASPECT_FILTERING    0x00000001L

int     WINAPI AddFontResource(LPCSTR);
BOOL    WINAPI RemoveFontResource(LPCSTR);

#define GCP_DBCS           0x0001
#define GCP_REORDER        0x0002
#define GCP_USEKERNING     0x0008
#define GCP_GLYPHSHAPE     0x0010
#define GCP_LIGATE         0x0020
///#define GCP_GLYPHINDEXING  0x0080
#define GCP_DIACRITIC      0x0100
#define GCP_KASHIDA        0x0400
#define GCP_ERROR          0x8000
#define FLI_MASK           0x103B

#define GCP_JUSTIFY        0x00010000L
//#define GCP_NODIACRITICS   0x00020000L
#define FLI_GLYPHS         0x00040000L
#define GCP_CLASSIN        0x00080000L	
#define GCP_MAXEXTENT      0x00100000L
#define GCP_JUSTIFYIN		 0x00200000L
#define GCP_DISPLAYZWG      0x00400000L
#define GCP_SYMSWAPOFF      0x00800000L
#define GCP_NUMERICOVERRIDE 0x01000000L
#define GCP_NEUTRALOVERRIDE 0x02000000L
#define GCP_NUMERICSLATIN   0x04000000L
#define GCP_NUMERICSLOCAL   0x08000000L

#define GCPCLASS_LATIN                  1
#define GCPCLASS_HEBREW                 2
#define GCPCLASS_ARABIC                 2
#define GCPCLASS_NEUTRAL                3
#define GCPCLASS_LOCALNUMBER            4
#define GCPCLASS_LATINNUMBER            5
#define GCPCLASS_LATINNUMERICTERMINATOR 6
#define GCPCLASS_LATINNUMERICSEPARATOR  7
#define GCPCLASS_NUMERICSEPARATOR       8

#define GCPCLASS_PREBOUNDLTR		0x80
#define GCPCLASS_PREBOUNDRTL		0x40
#define GCPCLASS_POSTBOUNDLTR		0x20
#define GCPCLASS_POSTBOUNDRTL		0x10

#define GCPGLYPH_LINKBEFORE		0x8000
#define GCPGLYPH_LINKAFTER			0x4000

typedef struct 
	{
	DWORD 	lStructSize;
	LPSTR 	lpOutString;
	UINT FAR *lpOrder;
	int FAR  *lpDx;
	int FAR  *lpCaretPos; 
    LPSTR     lpClass;
	UINT FAR *lpGlyphs;
	UINT   	nGlyphs;    
	int		nMaxFit;
	} GCP_RESULTS, FAR* LPGCP_RESULTS;

DWORD WINAPI GetFontLanguageInfo( HDC );
DWORD WINAPI GetCharacterPlacement(HDC, LPCSTR, int, int, LPGCP_RESULTS, DWORD);
int     WINAPI GetTextFace(HDC, int, LPSTR);

DWORD   WINAPI GetAspectRatioFilter(HDC);
#if (WINVER >= 0x030a)
BOOL    WINAPI GetAspectRatioFilterEx(HDC, SIZE FAR*);
#endif  /* WINVER >= 0x030a */

#endif /* NOGDIOBJ */

typedef struct tagPANOSE
{
    BYTE    bFamilyType;
    BYTE    bSerifStyle;
    BYTE    bWeight;
    BYTE    bProportion;
    BYTE    bContrast;
    BYTE    bStrokeVariation;
    BYTE    bArmStyle;
    BYTE    bLetterform;
    BYTE    bMidline;
    BYTE    bXHeight;
} PANOSE, FAR* LPPANOSE;

#ifndef NOTEXTMETRIC

typedef struct tagTEXTMETRIC
{
    int     tmHeight;
    int     tmAscent;
    int     tmDescent;
    int     tmInternalLeading;
    int     tmExternalLeading;
    int     tmAveCharWidth;
    int     tmMaxCharWidth;
    int     tmWeight;
    BYTE    tmItalic;
    BYTE    tmUnderlined;
    BYTE    tmStruckOut;
    BYTE    tmFirstChar;
    BYTE    tmLastChar;
    BYTE    tmDefaultChar;
    BYTE    tmBreakChar;
    BYTE    tmPitchAndFamily;
    BYTE    tmCharSet;
    int     tmOverhang;
    int     tmDigitizedAspectX;
    int     tmDigitizedAspectY;
} TEXTMETRIC;
typedef TEXTMETRIC*       PTEXTMETRIC;
typedef TEXTMETRIC NEAR* NPTEXTMETRIC;
typedef TEXTMETRIC FAR*  LPTEXTMETRIC;

/* tmPitchAndFamily values */
#define TMPF_VARIABLE_PITCH 0x01
#define TMPF_VECTOR         0x02
#define TMPF_DEVICE         0x08

/*
 * Yes, this looks bogus.  But it's because we got confused and named the
 * flag wrong.  LOGFONTs have an lfPitchAndFamily field, where FIXED_PITCH
 * is 0x01.  But TEXTMETRICs have a tmPitchAndFamily field, where
 * VARIABLE_PITCH is 0x01.  It's easy to confuse the two.  We're sorry.
*/
#define TMPF_FIXED_PITCH    TMPF_VARIABLE_PITCH

#if (WINVER >= 0x030a)
#define TMPF_TRUETYPE       0x04
#endif  /* WINVER >= 0x030a */

BOOL    WINAPI GetTextMetrics(HDC, TEXTMETRIC FAR*);

#if (WINVER >= 0x030a)

#ifndef NOSCALABLEFONT
#if (WINVER >= 0x0400)

#define PANOSE_COUNT               10
#define PAN_FAMILYTYPE_INDEX        0
#define PAN_SERIFSTYLE_INDEX        1
#define PAN_WEIGHT_INDEX            2
#define PAN_PROPORTION_INDEX        3
#define PAN_CONTRAST_INDEX          4
#define PAN_STROKEVARIATION_INDEX   5
#define PAN_ARMSTYLE_INDEX          6
#define PAN_LETTERFORM_INDEX        7
#define PAN_MIDLINE_INDEX           8
#define PAN_XHEIGHT_INDEX           9

#define PAN_CULTURE_LATIN           0

#define PAN_ANY                         0 /* Any                            */
#define PAN_NO_FIT                      1 /* No Fit                         */

#define PAN_FAMILY_TEXT_DISPLAY         2 /* Text and Display               */
#define PAN_FAMILY_SCRIPT               3 /* Script                         */
#define PAN_FAMILY_DECORATIVE           4 /* Decorative                     */
#define PAN_FAMILY_PICTORIAL            5 /* Pictorial                      */

#define PAN_SERIF_COVE                  2 /* Cove                           */
#define PAN_SERIF_OBTUSE_COVE           3 /* Obtuse Cove                    */
#define PAN_SERIF_SQUARE_COVE           4 /* Square Cove                    */
#define PAN_SERIF_OBTUSE_SQUARE_COVE    5 /* Obtuse Square Cove             */
#define PAN_SERIF_SQUARE                6 /* Square                         */
#define PAN_SERIF_THIN                  7 /* Thin                           */
#define PAN_SERIF_BONE                  8 /* Bone                           */
#define PAN_SERIF_EXAGGERATED           9 /* Exaggerated                    */
#define PAN_SERIF_TRIANGLE             10 /* Triangle                       */
#define PAN_SERIF_NORMAL_SANS          11 /* Normal Sans                    */
#define PAN_SERIF_OBTUSE_SANS          12 /* Obtuse Sans                    */
#define PAN_SERIF_PERP_SANS            13 /* Prep Sans                      */
#define PAN_SERIF_FLARED               14 /* Flared                         */
#define PAN_SERIF_ROUNDED              15 /* Rounded                        */

#define PAN_WEIGHT_VERY_LIGHT           2 /* Very Light                     */
#define PAN_WEIGHT_LIGHT                3 /* Light                          */
#define PAN_WEIGHT_THIN                 4 /* Thin                           */
#define PAN_WEIGHT_BOOK                 5 /* Book                           */
#define PAN_WEIGHT_MEDIUM               6 /* Medium                         */
#define PAN_WEIGHT_DEMI                 7 /* Demi                           */
#define PAN_WEIGHT_BOLD                 8 /* Bold                           */
#define PAN_WEIGHT_HEAVY                9 /* Heavy                          */
#define PAN_WEIGHT_BLACK               10 /* Black                          */
#define PAN_WEIGHT_NORD                11 /* Nord                           */

#define PAN_PROP_OLD_STYLE              2 /* Old Style                      */
#define PAN_PROP_MODERN                 3 /* Modern                         */
#define PAN_PROP_EVEN_WIDTH             4 /* Even Width                     */
#define PAN_PROP_EXPANDED               5 /* Expanded                       */
#define PAN_PROP_CONDENSED              6 /* Condensed                      */
#define PAN_PROP_VERY_EXPANDED          7 /* Very Expanded                  */
#define PAN_PROP_VERY_CONDENSED         8 /* Very Condensed                 */
#define PAN_PROP_MONOSPACED             9 /* Monospaced                     */

#define PAN_CONTRAST_NONE               2 /* None                           */
#define PAN_CONTRAST_VERY_LOW           3 /* Very Low                       */
#define PAN_CONTRAST_LOW                4 /* Low                            */
#define PAN_CONTRAST_MEDIUM_LOW         5 /* Medium Low                     */
#define PAN_CONTRAST_MEDIUM             6 /* Medium                         */
#define PAN_CONTRAST_MEDIUM_HIGH        7 /* Mediim High                    */
#define PAN_CONTRAST_HIGH               8 /* High                           */
#define PAN_CONTRAST_VERY_HIGH          9 /* Very High                      */

#define PAN_STROKE_GRADUAL_DIAG         2 /* Gradual/Diagonal               */
#define PAN_STROKE_GRADUAL_TRAN         3 /* Gradual/Transitional           */
#define PAN_STROKE_GRADUAL_VERT         4 /* Gradual/Vertical               */
#define PAN_STROKE_GRADUAL_HORZ         5 /* Gradual/Horizontal             */
#define PAN_STROKE_RAPID_VERT           6 /* Rapid/Vertical                 */
#define PAN_STROKE_RAPID_HORZ           7 /* Rapid/Horizontal               */
#define PAN_STROKE_INSTANT_VERT         8 /* Instant/Vertical               */

#define PAN_STRAIGHT_ARMS_HORZ          2 /* Straight Arms/Horizontal       */
#define PAN_STRAIGHT_ARMS_WEDGE         3 /* Straight Arms/Wedge            */
#define PAN_STRAIGHT_ARMS_VERT          4 /* Straight Arms/Vertical         */
#define PAN_STRAIGHT_ARMS_SINGLE_SERIF  5 /* Straight Arms/Single-Serif     */
#define PAN_STRAIGHT_ARMS_DOUBLE_SERIF  6 /* Straight Arms/Double-Serif     */
#define PAN_BENT_ARMS_HORZ              7 /* Non-Straight Arms/Horizontal   */
#define PAN_BENT_ARMS_WEDGE             8 /* Non-Straight Arms/Wedge        */
#define PAN_BENT_ARMS_VERT              9 /* Non-Straight Arms/Vertical     */
#define PAN_BENT_ARMS_SINGLE_SERIF     10 /* Non-Straight Arms/Single-Serif */
#define PAN_BENT_ARMS_DOUBLE_SERIF     11 /* Non-Straight Arms/Double-Serif */

#define PAN_LETT_NORMAL_CONTACT         2 /* Normal/Contact                 */
#define PAN_LETT_NORMAL_WEIGHTED        3 /* Normal/Weighted                */
#define PAN_LETT_NORMAL_BOXED           4 /* Normal/Boxed                   */
#define PAN_LETT_NORMAL_FLATTENED       5 /* Normal/Flattened               */
#define PAN_LETT_NORMAL_ROUNDED         6 /* Normal/Rounded                 */
#define PAN_LETT_NORMAL_OFF_CENTER      7 /* Normal/Off Center              */
#define PAN_LETT_NORMAL_SQUARE          8 /* Normal/Square                  */
#define PAN_LETT_OBLIQUE_CONTACT        9 /* Oblique/Contact                */
#define PAN_LETT_OBLIQUE_WEIGHTED      10 /* Oblique/Weighted               */
#define PAN_LETT_OBLIQUE_BOXED         11 /* Oblique/Boxed                  */
#define PAN_LETT_OBLIQUE_FLATTENED     12 /* Oblique/Flattened              */
#define PAN_LETT_OBLIQUE_ROUNDED       13 /* Oblique/Rounded                */
#define PAN_LETT_OBLIQUE_OFF_CENTER    14 /* Oblique/Off Center             */
#define PAN_LETT_OBLIQUE_SQUARE        15 /* Oblique/Square                 */

#define PAN_MIDLINE_STANDARD_TRIMMED    2 /* Standard/Trimmed               */
#define PAN_MIDLINE_STANDARD_POINTED    3 /* Standard/Pointed               */
#define PAN_MIDLINE_STANDARD_SERIFED    4 /* Standard/Serifed               */
#define PAN_MIDLINE_HIGH_TRIMMED        5 /* High/Trimmed                   */
#define PAN_MIDLINE_HIGH_POINTED        6 /* High/Pointed                   */
#define PAN_MIDLINE_HIGH_SERIFED        7 /* High/Serifed                   */
#define PAN_MIDLINE_CONSTANT_TRIMMED    8 /* Constant/Trimmed               */
#define PAN_MIDLINE_CONSTANT_POINTED    9 /* Constant/Pointed               */
#define PAN_MIDLINE_CONSTANT_SERIFED   10 /* Constant/Serifed               */
#define PAN_MIDLINE_LOW_TRIMMED        11 /* Low/Trimmed                    */
#define PAN_MIDLINE_LOW_POINTED        12 /* Low/Pointed                    */
#define PAN_MIDLINE_LOW_SERIFED        13 /* Low/Serifed                    */

#define PAN_XHEIGHT_CONSTANT_SMALL      2 /* Constant/Small                 */
#define PAN_XHEIGHT_CONSTANT_STD        3 /* Constant/Standard              */
#define PAN_XHEIGHT_CONSTANT_LARGE      4 /* Constant/Large                 */
#define PAN_XHEIGHT_DUCKING_SMALL       5 /* Ducking/Small                  */
#define PAN_XHEIGHT_DUCKING_STD         6 /* Ducking/Standard               */
#define PAN_XHEIGHT_DUCKING_LARGE       7 /* Ducking/Large                  */

#endif   /* WINVER >= 0x0400 */

typedef struct tagOUTLINETEXTMETRIC
{
    UINT    otmSize;
    TEXTMETRIC otmTextMetrics;
    BYTE    otmFiller;
    PANOSE  otmPanoseNumber;
    UINT    otmfsSelection;
    UINT    otmfsType;
    int     otmsCharSlopeRise;
    int     otmsCharSlopeRun;
    int     otmItalicAngle;
    UINT    otmEMSquare;
    int     otmAscent;
    int     otmDescent;
    UINT    otmLineGap;
    UINT    otmsCapEmHeight;
    UINT    otmsXHeight;
    RECT    otmrcFontBox;
    int     otmMacAscent;
    int     otmMacDescent;
    UINT    otmMacLineGap;
    UINT    otmusMinimumPPEM;
    POINT   otmptSubscriptSize;
    POINT   otmptSubscriptOffset;
    POINT   otmptSuperscriptSize;
    POINT   otmptSuperscriptOffset;
    UINT    otmsStrikeoutSize;
    int     otmsStrikeoutPosition;
    int     otmsUnderscorePosition;
    int     otmsUnderscoreSize;
    PSTR    otmpFamilyName;
    PSTR    otmpFaceName;
    PSTR    otmpStyleName;
    PSTR    otmpFullName;
} OUTLINETEXTMETRIC, FAR* LPOUTLINETEXTMETRIC;

WORD    WINAPI GetOutlineTextMetrics(HDC, UINT, OUTLINETEXTMETRIC FAR*);

#endif  /* NOSCALABLEFONT */
#endif  /* WINVER >= 0x030a */

#ifndef NOGDIOBJ
#if (WINVER >= 0x030a)

/* Structure passed to FONTENUMPROC */
/* NOTE: NEWTEXTMETRIC is the same as TEXTMETRIC plus 4 new fields */
typedef struct tagNEWTEXTMETRIC
{
    int     tmHeight;
    int     tmAscent;
    int     tmDescent;
    int     tmInternalLeading;
    int     tmExternalLeading;
    int     tmAveCharWidth;
    int     tmMaxCharWidth;
    int     tmWeight;
    BYTE    tmItalic;
    BYTE    tmUnderlined;
    BYTE    tmStruckOut;
    BYTE    tmFirstChar;
    BYTE    tmLastChar;
    BYTE    tmDefaultChar;
    BYTE    tmBreakChar;
    BYTE    tmPitchAndFamily;
    BYTE    tmCharSet;
    int     tmOverhang;
    int     tmDigitizedAspectX;
    int     tmDigitizedAspectY;
    DWORD   ntmFlags;
    UINT    ntmSizeEM;
    UINT    ntmCellHeight;
    UINT    ntmAvgWidth;
} NEWTEXTMETRIC;
typedef NEWTEXTMETRIC*       PNEWTEXTMETRIC;
typedef NEWTEXTMETRIC NEAR* NPNEWTEXTMETRIC;
typedef NEWTEXTMETRIC FAR*  LPNEWTEXTMETRIC;

/* ntmFlags field flags */
#define NTM_REGULAR 0x00000040L
#define NTM_BOLD 0x00000020L
#define NTM_ITALIC 0x00000001L

#define LF_FULLFACESIZE     64

/* Structure passed to FONTENUMPROC */
typedef struct tagENUMLOGFONT
{
    LOGFONT elfLogFont;
    char    elfFullName[LF_FULLFACESIZE];
    char    elfStyle[LF_FACESIZE];
#if (WINVER >= 0x0400)
    char    elfScript[LF_FACESIZE];
#endif
} ENUMLOGFONT, FAR* LPENUMLOGFONT;

#endif  /* WINVER >= 0x030a */
#endif  /* NOGDIOBJ */

#ifdef STRICT
#ifndef NOGDIOBJ

typedef int (CALLBACK* OLDFONTENUMPROC)(const LOGFONT FAR*, const TEXTMETRIC FAR*, int, LPARAM);

#if (WINVER >= 0x030a)
typedef int (CALLBACK* FONTENUMPROC)(const ENUMLOGFONT FAR*, const NEWTEXTMETRIC FAR*, int, LPARAM);

int     WINAPI EnumFontFamilies(HDC, LPCSTR, FONTENUMPROC, LPARAM);
int     WINAPI EnumFontFamiliesEx(HDC, LPLOGFONT, FONTENUMPROC, LPARAM,DWORD);

#else   /* WINVER >= 0x030a */
typedef OLDFONTENUMPROC FONTENUMPROC;
#endif  /* WINVER >= 0x030a) */

int     WINAPI EnumFonts(HDC, LPCSTR, OLDFONTENUMPROC, LPARAM);
#endif  /* NOGDIOBJ */

#else   /* STRICT */

typedef FARPROC OLDFONTENUMPROC;
typedef FARPROC FONTENUMPROC;

int     WINAPI EnumFonts(HDC, LPCSTR, OLDFONTENUMPROC, LPSTR);

#if (WINVER >= 0x030a)
int     WINAPI EnumFontFamilies(HDC, LPCSTR, FONTENUMPROC, LPSTR);
#endif  /* WINVER >= 0x030a */

#endif  /* !STRICT */

/* EnumFonts font type values */
#define RASTER_FONTTYPE     0x0001
#define DEVICE_FONTTYPE     0X0002
#if (WINVER >= 0x030a)
#define TRUETYPE_FONTTYPE   0x0004
#endif  /* WINVER >= 0x030a */

#endif  /* NOTEXTMETRIC */

#ifndef NOSCALABLEFONT
#if (WINVER >= 0x030a)

DWORD   WINAPI GetFontData(HDC, DWORD, DWORD, void FAR*, DWORD);
BOOL WINAPI CreateScalableFontResource(UINT, LPCSTR, LPCSTR, LPCSTR);

typedef struct tagGLYPHMETRICS
{
    UINT    gmBlackBoxX;
    UINT    gmBlackBoxY;
    POINT   gmptGlyphOrigin;
    int     gmCellIncX;
    int     gmCellIncY;
} GLYPHMETRICS, FAR* LPGLYPHMETRICS;

typedef struct tagFIXED
{
    UINT    fract;
    int     value;
} FIXED, FAR* LPFIXED;

typedef struct tagMAT2
{
    FIXED  eM11;
    FIXED  eM12;
    FIXED  eM21;
    FIXED  eM22;
} MAT2, FAR* LPMAT2;

DWORD   WINAPI GetGlyphOutline(HDC, UINT, UINT, GLYPHMETRICS FAR*, DWORD, void FAR*, const MAT2 FAR*);

/* GetGlyphOutline constants */
#define GGO_METRICS        0
#define GGO_BITMAP         1
#define GGO_NATIVE         2
#if (WINVER >= 0x0400)
#define	GGO_GRAY2_BITMAP   4
#define	GGO_GRAY4_BITMAP   5
#define	GGO_GRAY8_BITMAP   6
#endif /* WINVER >= 0x0400 */

#define TT_POLYGON_TYPE   24

#define TT_PRIM_LINE       1
#define TT_PRIM_QSPLINE    2

typedef struct tagPOINTFX
{
    FIXED x;
    FIXED y;
} POINTFX, FAR* LPPOINTFX;

typedef struct tagTTPOLYCURVE
{
    UINT    wType;
    UINT    cpfx;
    POINTFX apfx[1];
} TTPOLYCURVE, FAR* LPTTPOLYCURVE;

typedef struct tagTTPOLYGONHEADER
{
    DWORD   cb;
    DWORD   dwType;
    POINTFX pfxStart;
} TTPOLYGONHEADER, FAR* LPTTPOLYGONHEADER;

typedef struct tagABC
{
    int   abcA;
    UINT  abcB;
    int   abcC;
} ABC;
typedef ABC FAR* LPABC;

BOOL    WINAPI GetCharABCWidths(HDC, UINT, UINT, ABC FAR*);

typedef struct tagKERNINGPAIR
{
    WORD wFirst;
    WORD wSecond;
    int  iKernAmount;
} KERNINGPAIR, FAR* LPKERNINGPAIR;

int     WINAPI GetKerningPairs(HDC, int, KERNINGPAIR FAR*);

typedef struct tagRASTERIZER_STATUS
{
    int   nSize;
    int   wFlags;
    int   nLanguageID;
} RASTERIZER_STATUS;
typedef RASTERIZER_STATUS FAR* LPRASTERIZER_STATUS;

/* bits defined in wFlags of RASTERIZER_STATUS */
#define TT_AVAILABLE 0x0001
#define TT_ENABLED 0x0002

BOOL    WINAPI GetRasterizerCaps(RASTERIZER_STATUS FAR*, int);

#endif  /* WINVER >= 0x030a */
#endif  /* NOSCALABLEFONT */

/****** Bitmap support ******************************************************/

#ifndef NOBITMAP
typedef struct tagBITMAP
{
    int     bmType;
    int     bmWidth;
    int     bmHeight;
    int     bmWidthBytes;
    BYTE    bmPlanes;
    BYTE    bmBitsPixel;
    void FAR* bmBits;
} BITMAP;
typedef BITMAP*       PBITMAP;
typedef BITMAP NEAR* NPBITMAP;
typedef BITMAP FAR*  LPBITMAP;

/* Bitmap Header structures */
typedef struct tagRGBTRIPLE
{
    BYTE    rgbtBlue;
    BYTE    rgbtGreen;
    BYTE    rgbtRed;
} RGBTRIPLE;
typedef RGBTRIPLE FAR* LPRGBTRIPLE;

typedef struct tagRGBQUAD
{
    BYTE    rgbBlue;
    BYTE    rgbGreen;
    BYTE    rgbRed;
    BYTE    rgbReserved;
} RGBQUAD;
typedef RGBQUAD FAR* LPRGBQUAD;

/* structures for defining DIBs */
typedef struct tagBITMAPCOREHEADER
{
    DWORD   bcSize;
    short   bcWidth;
    short   bcHeight;
    WORD    bcPlanes;
    WORD    bcBitCount;
} BITMAPCOREHEADER;
typedef BITMAPCOREHEADER*      PBITMAPCOREHEADER;
typedef BITMAPCOREHEADER FAR* LPBITMAPCOREHEADER;

typedef struct tagBITMAPINFOHEADER
{
    DWORD   biSize;
    LONG    biWidth;
    LONG    biHeight;
    WORD    biPlanes;
    WORD    biBitCount;
    DWORD   biCompression;
    DWORD   biSizeImage;
    LONG    biXPelsPerMeter;
    LONG    biYPelsPerMeter;
    DWORD   biClrUsed;
    DWORD   biClrImportant;
} BITMAPINFOHEADER;
typedef BITMAPINFOHEADER*      PBITMAPINFOHEADER;
typedef BITMAPINFOHEADER FAR* LPBITMAPINFOHEADER;

/* constants for the biCompression field */
#define BI_RGB       0L
#define BI_RLE8      1L
#define BI_RLE4      2L
#define BI_BITFIELDS 3L

typedef struct tagBITMAPINFO
{
    BITMAPINFOHEADER bmiHeader;
    RGBQUAD      bmiColors[1];
} BITMAPINFO;
typedef BITMAPINFO*     PBITMAPINFO;
typedef BITMAPINFO FAR* LPBITMAPINFO;

typedef struct tagBITMAPCOREINFO
{
    BITMAPCOREHEADER bmciHeader;
    RGBTRIPLE      bmciColors[1];
} BITMAPCOREINFO;
typedef BITMAPCOREINFO*      PBITMAPCOREINFO;
typedef BITMAPCOREINFO FAR* LPBITMAPCOREINFO;

typedef struct tagBITMAPFILEHEADER
{
    UINT    bfType;
    DWORD   bfSize;
    UINT    bfReserved1;
    UINT    bfReserved2;
    DWORD   bfOffBits;
} BITMAPFILEHEADER;
typedef BITMAPFILEHEADER*      PBITMAPFILEHEADER;
typedef BITMAPFILEHEADER FAR* LPBITMAPFILEHEADER;

HBITMAP WINAPI CreateBitmap(int, int, UINT, UINT, const void FAR*);
HBITMAP WINAPI CreateBitmapIndirect(BITMAP FAR* );
HBITMAP WINAPI CreateCompatibleBitmap(HDC, int, int);
HBITMAP WINAPI CreateDiscardableBitmap(HDC, int, int);
HBITMAP WINAPI CreateDIBitmap(HDC, BITMAPINFOHEADER FAR*, DWORD, const void FAR*, BITMAPINFO FAR*, UINT);

HBITMAP WINAPI LoadBitmap(HINSTANCE, LPCSTR);

/* DIB color table identifiers */
#define DIB_RGB_COLORS  0
#define DIB_PAL_COLORS  1

/* constants for CreateDIBitmap */
#define CBM_INIT        0x00000004L
#endif /* NOBITMAP */

#ifndef NORASTEROPS

/* Binary raster ops */
#define R2_BLACK            1
#define R2_NOTMERGEPEN      2
#define R2_MASKNOTPEN       3
#define R2_NOTCOPYPEN       4
#define R2_MASKPENNOT       5
#define R2_NOT              6
#define R2_XORPEN           7
#define R2_NOTMASKPEN       8
#define R2_MASKPEN          9
#define R2_NOTXORPEN        10
#define R2_NOP              11
#define R2_MERGENOTPEN      12
#define R2_COPYPEN          13
#define R2_MERGEPENNOT      14
#define R2_MERGEPEN         15
#define R2_WHITE            16

/* Ternary raster operations */
#define SRCCOPY             0x00CC0020L
#define SRCPAINT            0x00EE0086L
#define SRCAND              0x008800C6L
#define SRCINVERT           0x00660046L
#define SRCERASE            0x00440328L
#define NOTSRCCOPY          0x00330008L
#define NOTSRCERASE         0x001100A6L
#define MERGECOPY           0x00C000CAL
#define MERGEPAINT          0x00BB0226L
#define PATCOPY             0x00F00021L
#define PATOR               0x00FA0089L
#define PATPAINT            0x00FB0A09L
#define PATINVERT           0x005A0049L
#define DSTINVERT           0x00550009L
#define BLACKNESS           0x00000042L
#define WHITENESS           0x00FF0062L
#define SRCSTENCIL          0x00B8074AL
#define SRCINVSTENCIL       0x00E20746L

#endif  /* NORASTEROPS */

#ifndef NOBITMAP
BOOL    WINAPI BitBlt(HDC, int, int, int, int, HDC, int, int, DWORD);

BOOL    WINAPI PatBlt(HDC, int, int, int, int, DWORD);

BOOL    WINAPI StretchBlt(HDC, int, int, int, int, HDC, int, int, int, int, DWORD);
int     WINAPI StretchDIBits(HDC, int, int, int, int, int,
                        int, int, int, const void FAR*, LPBITMAPINFO, UINT, DWORD);

COLORREF WINAPI SetPixel(HDC, int, int, COLORREF);
COLORREF WINAPI GetPixel(HDC, int, int);

/* StretchBlt() Modes */
#define BLACKONWHITE 1
#define WHITEONBLACK 2
#define COLORONCOLOR 3

/* new StretchBlt() Modes (simpler names) */
#define STRETCH_ANDSCANS        1
#define STRETCH_ORSCANS         2
#define STRETCH_DELETESCANS     3

int     WINAPI SetStretchBltMode(HDC, int);
int     WINAPI GetStretchBltMode(HDC);

DWORD   WINAPI SetBitmapDimension(HBITMAP, int, int);
DWORD   WINAPI GetBitmapDimension(HBITMAP);
#if (WINVER >= 0x030a)
BOOL    WINAPI SetBitmapDimensionEx(HBITMAP, int, int, SIZE FAR*);
BOOL    WINAPI GetBitmapDimensionEx(HBITMAP, SIZE FAR*);
#endif  /* WINVER >= 0x030a */
int     WINAPI SetROP2(HDC, int);
int     WINAPI GetROP2(HDC);

LONG    WINAPI SetBitmapBits(HBITMAP, DWORD, const void FAR*);
LONG    WINAPI GetBitmapBits(HBITMAP, LONG, void FAR*);

int     WINAPI SetDIBits(HDC, HBITMAP, UINT, UINT, const void FAR*, BITMAPINFO FAR*, UINT);
int     WINAPI GetDIBits(HDC, HBITMAP, UINT, UINT, void FAR*, BITMAPINFO FAR*, UINT);

int     WINAPI SetDIBitsToDevice(HDC, int, int, int, int, int, int, UINT, UINT,
                    void FAR*, BITMAPINFO FAR*, UINT);
#endif /* NOBITMAP */

/****** Metafile support ****************************************************/

#ifndef NOMETAFILE

DECLARE_HANDLE(HMETAFILE);

HDC     WINAPI CreateMetaFile(LPCSTR);
HMETAFILE WINAPI CloseMetaFile(HDC);

HMETAFILE WINAPI GetMetaFile(LPCSTR);
BOOL      WINAPI DeleteMetaFile(HMETAFILE);
HMETAFILE WINAPI CopyMetaFile(HMETAFILE, LPCSTR);

BOOL    WINAPI PlayMetaFile(HDC, HMETAFILE);

HGLOBAL WINAPI GetMetaFileBits(HMETAFILE);
HMETAFILE WINAPI SetMetaFileBits(HGLOBAL);
#if (WINVER >= 0x030a)
HMETAFILE WINAPI SetMetaFileBitsBetter(HGLOBAL);
#endif  /* WINVER >= 0x030a */

/* Clipboard Metafile Picture Structure */
typedef struct tagMETAFILEPICT
{
    int     mm;
    int     xExt;
    int     yExt;
    HMETAFILE hMF;
} METAFILEPICT;
typedef METAFILEPICT FAR* LPMETAFILEPICT;

typedef struct tagMETAHEADER
{
    UINT    mtType;
    UINT    mtHeaderSize;
    UINT    mtVersion;
    DWORD   mtSize;
    UINT    mtNoObjects;
    DWORD   mtMaxRecord;
    UINT    mtNoParameters;
} METAHEADER;

typedef struct tagHANDLETABLE
{
    HGDIOBJ objectHandle[1];
} HANDLETABLE;
typedef HANDLETABLE*      PHANDLETABLE;
typedef HANDLETABLE FAR* LPHANDLETABLE;

typedef struct tagMETARECORD
{
    DWORD   rdSize;
    UINT    rdFunction;
    UINT    rdParm[1];
} METARECORD;
typedef METARECORD*      PMETARECORD;
typedef METARECORD FAR* LPMETARECORD;

/* Metafile Functions */
#define META_SETBKCOLOR             0x0201
#define META_SETBKMODE              0x0102
#define META_SETMAPMODE             0x0103
#define META_SETROP2                0x0104
#define META_SETRELABS              0x0105
#define META_SETPOLYFILLMODE        0x0106
#define META_SETSTRETCHBLTMODE      0x0107
#define META_SETTEXTCHAREXTRA       0x0108
#define META_SETTEXTCOLOR           0x0209
#define META_SETTEXTJUSTIFICATION   0x020A
#define META_SETWINDOWORG           0x020B
#define META_SETWINDOWEXT           0x020C
#define META_SETVIEWPORTORG         0x020D
#define META_SETVIEWPORTEXT         0x020E
#define META_OFFSETWINDOWORG        0x020F
#define META_SCALEWINDOWEXT         0x0410
#define META_OFFSETVIEWPORTORG      0x0211
#define META_SCALEVIEWPORTEXT       0x0412
#define META_LINETO                 0x0213
#define META_MOVETO                 0x0214
#define META_EXCLUDECLIPRECT        0x0415
#define META_INTERSECTCLIPRECT      0x0416
#define META_ARC                    0x0817
#define META_ELLIPSE                0x0418
#define META_FLOODFILL              0x0419
#define META_PIE                    0x081A
#define META_RECTANGLE              0x041B
#define META_ROUNDRECT              0x061C
#define META_PATBLT                 0x061D
#define META_SAVEDC                 0x001E
#define META_SETPIXEL               0x041F
#define META_OFFSETCLIPRGN          0x0220
#define META_TEXTOUT                0x0521
#define META_BITBLT                 0x0922
#define META_STRETCHBLT             0x0B23
#define META_POLYGON                0x0324
#define META_POLYLINE               0x0325
#define META_ESCAPE                 0x0626
#define META_RESTOREDC              0x0127
#define META_FILLREGION             0x0228
#define META_FRAMEREGION            0x0429
#define META_INVERTREGION           0x012A
#define META_PAINTREGION            0x012B
#define META_SELECTCLIPREGION       0x012C
#define META_SELECTOBJECT           0x012D
#define META_SETTEXTALIGN           0x012E
#define META_DRAWTEXT               0x062F

#define META_CHORD                  0x0830
#define META_SETMAPPERFLAGS         0x0231
#define META_EXTTEXTOUT             0x0a32
#define META_SETDIBTODEV            0x0d33
#define META_SELECTPALETTE          0x0234
#define META_REALIZEPALETTE         0x0035
#define META_ANIMATEPALETTE         0x0436
#define META_SETPALENTRIES          0x0037
#define META_POLYPOLYGON            0x0538
#define META_RESIZEPALETTE          0x0139

#define META_DIBBITBLT              0x0940
#define META_DIBSTRETCHBLT          0x0b41
#define META_DIBCREATEPATTERNBRUSH  0x0142
#define META_STRETCHDIB             0x0f43

#define META_EXTFLOODFILL           0x0548

#define META_RESETDC                0x014C
#define META_STARTDOC               0x014D
#define META_STARTPAGE              0x004F
#define META_ENDPAGE                0x0050
#define META_ABORTDOC               0x0052
#define META_ENDDOC                 0x005E

#define META_DELETEOBJECT           0x01f0

#define META_CREATEPALETTE          0x00f7
#define META_CREATEBRUSH            0x00F8
#define META_CREATEPATTERNBRUSH     0x01F9
#define META_CREATEPENINDIRECT      0x02FA
#define META_CREATEFONTINDIRECT     0x02FB
#define META_CREATEBRUSHINDIRECT    0x02FC
#define META_CREATEBITMAPINDIRECT   0x02FD
#define META_CREATEBITMAP           0x06FE
#define META_CREATEREGION           0x06FF

void    WINAPI PlayMetaFileRecord(HDC, HANDLETABLE FAR*, METARECORD FAR*, UINT);

#ifdef STRICT
typedef int (CALLBACK* MFENUMPROC)(HDC, HANDLETABLE FAR*, METARECORD FAR*, int, LPARAM);
#else
typedef FARPROC MFENUMPROC;
#endif

BOOL    WINAPI EnumMetaFile(HDC, HMETAFILE, MFENUMPROC, LPARAM);

#endif  /* NOMETAFILE */

/****** Printing support ****************************************************/

#ifdef STRICT
typedef BOOL (CALLBACK* ABORTPROC)(HDC, int);
#else
typedef FARPROC ABORTPROC;
#endif

#if (WINVER >= 0x030a)

int WINAPI SetAbortProc(HDC, ABORTPROC);

HANDLE  WINAPI SpoolFile(LPSTR, LPSTR, LPSTR, LPSTR);

#endif  /* WINVER >= 0x030a */

typedef struct {
    short   cbSize;
    LPSTR   lpszDocName;
    LPSTR   lpszOutput;
    LPSTR   lpszDatatype;
    DWORD   fwType;
    }   DOCINFO, FAR * LPDOCINFO;

/* bit flags for DOCINFO.fwType */
#define DI_APPBANDING       0x0001
#define DI_ROPS_READ_DESTINATION   0x0002  // ;will use rops that read destination 
                                           // ;pixel values to print the doc. 
                                           // ;Ex: R2_XORPEN, PATINVERT (DPx).

int     WINAPI StartDoc(HDC, DOCINFO FAR*);
int     WINAPI StartPage(HDC);
int     WINAPI EndPage(HDC);
int     WINAPI EndDoc(HDC);
int     WINAPI AbortDoc(HDC);
BOOL    WINAPI QueryAbort(HDC, int);

/* Spooler Error Codes */
#define SP_NOTREPORTED      0x4000
#define SP_ERROR            (-1)
#define SP_APPABORT         (-2)
#define SP_USERABORT        (-3)
#define SP_OUTOFDISK        (-4)
#define SP_OUTOFMEMORY      (-5)

#define PR_JOBSTATUS        0x0000

#endif  /* NOGDI  */

#ifndef NOGDI

/******* GDI Escape support *************************************************/

int     WINAPI Escape(HDC, int, int, LPCSTR, void FAR*);

/* GDI Escapes */
#define NEWFRAME                1
#define ABORTDOC                2
#define NEXTBAND                3
#define SETCOLORTABLE           4
#define GETCOLORTABLE           5
#define FLUSHOUTPUT             6
#define DRAFTMODE               7
#define QUERYESCSUPPORT         8
#define SETABORTPROC            9
#define STARTDOC                10
#define ENDDOC                  11
#define GETPHYSPAGESIZE         12
#define GETPRINTINGOFFSET       13
#define GETSCALINGFACTOR        14
#define MFCOMMENT               15
#define GETPENWIDTH             16
#define SETCOPYCOUNT            17
#define SELECTPAPERSOURCE       18
#define DEVICEDATA              19
#define PASSTHROUGH             19
#define GETTECHNOLGY            20
#define GETTECHNOLOGY           20
#define SETLINECAP              21
#define SETLINEJOIN             22
#define SETMITERLIMIT           23
#define BANDINFO                24
#define DRAWPATTERNRECT         25
#define GETVECTORPENSIZE        26
#define GETVECTORBRUSHSIZE      27
#define ENABLEDUPLEX            28
#define GETSETPAPERBINS         29
#define GETSETPRINTORIENT       30
#define ENUMPAPERBINS           31
#define SETDIBSCALING           32
#define EPSPRINTING             33
#define ENUMPAPERMETRICS        34
#define GETSETPAPERMETRICS      35
#define POSTSCRIPT_DATA         37
#define POSTSCRIPT_IGNORE       38
#define MOUSETRAILS             39

#define GETEXTENDEDTEXTMETRICS  256
#define GETEXTENTTABLE          257
#define GETPAIRKERNTABLE        258
#define GETTRACKKERNTABLE       259
#define EXTTEXTOUT              512
#define GETFACENAME             513
#define ENABLERELATIVEWIDTHS    768
#define ENABLEPAIRKERNING       769
#define SETKERNTRACK            770
#define SETALLJUSTVALUES        771
#define SETCHARSET              772

#define STRETCHBLT              2048
#define GETSETSCREENPARAMS      3072
#define QUERYDIBSUPPORT         3073
#define QDI_SETDIBITS           0x0001
#define QDI_GETDIBITS           0x0002
#define QDI_DIBTOSCREEN         0x0004
#define QDI_STRETCHDIB          0x0008

#define BEGIN_PATH              4096
#define CLIP_TO_PATH            4097
#define END_PATH                4098
#define EXT_DEVICE_CAPS         4099
#define RESTORE_CTM             4100
#define SAVE_CTM                4101
#define SET_ARC_DIRECTION       4102
#define SET_BACKGROUND_COLOR    4103
#define SET_POLY_MODE           4104
#define SET_SCREEN_ANGLE        4105
#define SET_SPREAD              4106
#define TRANSFORM_CTM           4107
#define SET_CLIP_BOX            4108
#define SET_BOUNDS              4109

#endif  /* NOGDI */

/****** USER typedefs, structures, and functions *****************************/

DECLARE_HANDLE(HWND);

#ifndef NOUSER

DECLARE_HANDLE(HMENU);

DECLARE_HANDLE(HICON);
typedef HICON HCURSOR;     /* HICONs & HCURSORs are polymorphic */

/****** System Metrics *******************************************************/

#ifndef NOSYSMETRICS

int WINAPI GetSystemMetrics(int);

/* GetSystemMetrics() codes */
#define SM_CXSCREEN             0
#define SM_CYSCREEN             1
#define SM_CXVSCROLL            2
#define SM_CYHSCROLL            3
#define SM_CYCAPTION            4
#define SM_CXBORDER             5
#define SM_CYBORDER             6
#define SM_CXFIXEDFRAME         7
#define SM_CYFIXEDFRAME         8
#define SM_CYVTHUMB             9
#define SM_CXHTHUMB             10
#define SM_CXICON               11
#define SM_CYICON               12
#define SM_CXCURSOR             13
#define SM_CYCURSOR             14
#define SM_CYMENU               15
#define SM_CXFULLSCREEN         16
#define SM_CYFULLSCREEN         17
#define SM_CYKANJIWINDOW        18
#define SM_MOUSEPRESENT         19
#define SM_CYVSCROLL            20
#define SM_CXHSCROLL            21
#define SM_DEBUG                22
#define SM_SWAPBUTTON           23
#define SM_RESERVED1            24
#define SM_RESERVED2            25
#define SM_RESERVED3            26
#define SM_RESERVED4            27
#define SM_CXMIN                28
#define SM_CYMIN                29
#define SM_CXSIZE               30
#define SM_CYSIZE               31
#define SM_CXSIZEFRAME          32
#define SM_CYSIZEFRAME          33
#define SM_CXMINTRACK           34
#define SM_CYMINTRACK           35

#if (WINVER >= 0x030a)
#define SM_CXDOUBLECLK          36
#define SM_CYDOUBLECLK          37
#define SM_CXICONSPACING        38
#define SM_CYICONSPACING        39
#define SM_MENUDROPALIGNMENT    40
#define SM_PENWINDOWS           41
#define SM_DBCSENABLED          42
#define SM_CMOUSEBUTTONS        43
#define SM_SECURE               44
#endif  /* WINVER >= 0x030a */

#define SM_CXDLGFRAME           SM_CXFIXEDFRAME
#define SM_CYDLGFRAME           SM_CYFIXEDFRAME
#define SM_CXFRAME              SM_CXSIZEFRAME
#define SM_CYFRAME              SM_CYSIZEFRAME

#define SM_CMETRICS             75
#endif  /* NOSYSMETRICS */

UINT    WINAPI GetDoubleClickTime(void);
void    WINAPI SetDoubleClickTime(UINT);

/****** System Parameters support ********************************************/

#if (WINVER >= 0x030a)

#ifndef NOSYSTEMPARAMSINFO

BOOL    WINAPI SystemParametersInfo(UINT, UINT, VOID FAR*, UINT);

#define SPI_GETBEEP                 1
#define SPI_SETBEEP                 2
#define SPI_GETMOUSE                3
#define SPI_SETMOUSE                4
#define SPI_GETBORDER               5
#define SPI_SETBORDER               6
#define SPI_GETKEYBOARDSPEED        10
#define SPI_SETKEYBOARDSPEED        11
#define SPI_LANGDRIVER              12
#define SPI_ICONHORIZONTALSPACING   13
#define SPI_GETSCREENSAVETIMEOUT    14
#define SPI_SETSCREENSAVETIMEOUT    15
#define SPI_GETSCREENSAVEACTIVE     16
#define SPI_SETSCREENSAVEACTIVE     17
#define SPI_GETGRIDGRANULARITY      18
#define SPI_SETGRIDGRANULARITY      19
#define SPI_SETDESKWALLPAPER        20
#define SPI_SETDESKPATTERN          21
#define SPI_GETKEYBOARDDELAY        22
#define SPI_SETKEYBOARDDELAY        23
#define SPI_ICONVERTICALSPACING     24
#define SPI_GETICONTITLEWRAP        25
#define SPI_SETICONTITLEWRAP        26
#define SPI_GETMENUDROPALIGNMENT    27
#define SPI_SETMENUDROPALIGNMENT    28
#define SPI_SETDOUBLECLKWIDTH       29
#define SPI_SETDOUBLECLKHEIGHT      30
#define SPI_GETICONTITLELOGFONT     31
#define SPI_SETDOUBLECLICKTIME      32
#define SPI_SETMOUSEBUTTONSWAP      33
#define SPI_SETICONTITLELOGFONT     34
#define SPI_GETFASTTASKSWITCH       35
#define SPI_SETFASTTASKSWITCH       36

/* SystemParametersInfo flags */
#define SPIF_UPDATEINIFILE          0x0001
#define SPIF_SENDCHANGE             0x0002
#define SPIF_SENDWININICHANGE       SPIF_SENDCHANGE

#endif  /* NOSYSTEMPARAMSINFO  */
#endif  /* WINVER >= 0x030a */

#if (WINVER >= 0x0400)

/* Flags for ChangeDisplaySettings */
#define CDS_UPDATEREGISTRY  0x00000001
#define CDS_TEST            0x00000002
#define CDS_FULLSCREEN      0x00000004

/* Return values for ChangeDisplaySettings */
#define DISP_CHANGE_SUCCESSFUL       0
#define DISP_CHANGE_RESTART          1
#define DISP_CHANGE_FAILED          -1
#define DISP_CHANGE_BADMODE         -2
#define DISP_CHANGE_NOTUPDATED      -3
#define DISP_CHANGE_BADFLAGS        -4

typedef struct tagDEVMODE FAR*LPDEVMODE;
LONG WINAPI ChangeDisplaySettings(LPDEVMODE, DWORD);
BOOL WINAPI EnumDisplaySettings(LPCSTR lpszDeviceName,DWORD iModeNum, LPDEVMODE lpDevMode);

#endif  /* WINVER >=0x0400 */

/****** Rectangle support ****************************************************/

void    WINAPI SetRect(LPRECT, int, int, int, int);
void    WINAPI SetRectEmpty(LPRECT);

void    WINAPI CopyRect(LPRECT, LPCRECT);

BOOL    WINAPI IsRectEmpty(LPCRECT);

BOOL    WINAPI EqualRect(LPCRECT, LPCRECT);

BOOL    WINAPI IntersectRect(LPRECT, LPCRECT, LPCRECT);
BOOL    WINAPI UnionRect(LPRECT, LPCRECT, LPCRECT);
BOOL    WINAPI SubtractRect(LPRECT, LPCRECT, LPCRECT);

void    WINAPI OffsetRect(LPRECT, int, int);
void    WINAPI InflateRect(LPRECT, int, int);

BOOL    WINAPI PtInRect(LPCRECT, POINT);

/****** Window message support ***********************************************/

UINT WINAPI RegisterWindowMessage(LPCSTR);

#ifndef NOMSG

/* Queued message structure */
typedef struct tagMSG
{
    HWND    hwnd;
    UINT    message;
    WPARAM  wParam;
    LPARAM  lParam;
    DWORD   time;
    POINT   pt;
} MSG, * PMSG, NEAR* NPMSG, FAR* LPMSG;

BOOL    WINAPI GetMessage(LPMSG, HWND, UINT, UINT);
BOOL    WINAPI PeekMessage(LPMSG, HWND, UINT, UINT, UINT);

/* PeekMessage() options */
#define PM_NOREMOVE     0x0000
#define PM_REMOVE       0x0001
#define PM_NOYIELD      0x0002

void    WINAPI WaitMessage(void);

DWORD   WINAPI GetMessagePos(void);
LONG    WINAPI GetMessageTime(void);
#if (WINVER >= 0x030a)
LPARAM  WINAPI GetMessageExtraInfo(void);
#endif  /* WINVER >= 0x030a */

BOOL    WINAPI TranslateMessage(const MSG FAR*);
LONG    WINAPI DispatchMessage(const MSG FAR*);

BOOL    WINAPI SetMessageQueue(int);

BOOL    WINAPI GetInputState(void);

#if (WINVER >= 0x030a)
DWORD   WINAPI GetQueueStatus(UINT flags);

/* GetQueueStatus flags */
#define QS_KEY          0x0001
#define QS_MOUSEMOVE    0x0002
#define QS_MOUSEBUTTON  0x0004
#define QS_MOUSE        (QS_MOUSEMOVE | QS_MOUSEBUTTON)
#define QS_POSTMESSAGE  0x0008
#define QS_TIMER        0x0010
#define QS_PAINT        0x0020
#define QS_SENDMESSAGE  0x0040
#define QS_ALLINPUT     0x007f
#endif  /* WINVER >= 0x030a */

#endif  /* NOMSG */

BOOL    WINAPI PostMessage(HWND, UINT, WPARAM, LPARAM);

LRESULT WINAPI SendMessage(HWND, UINT, WPARAM, LPARAM);

#define BROADCAST_QUERY_DENY	0x424D5144	    // Return this value to deny a query.
#ifndef NOMSG

BOOL    WINAPI PostAppMessage(HTASK, UINT, WPARAM, LPARAM);

void    WINAPI ReplyMessage(LRESULT);
BOOL    WINAPI InSendMessage(void);

/* Special HWND value for use with PostMessage() and SendMessage() */
#define HWND_BROADCAST ((HWND)-1)

BOOL WINAPI CallMsgFilter(LPMSG, int);

#define WH_GETMESSAGE           3

#define WH_CALLWNDPROC          4

#define WH_MSGFILTER            (-1)
#define WH_SYSMSGFILTER         6

/* CallMsgFilter() and WH_SYS/MSGFILTER context codes */
#define MSGF_DIALOGBOX          0
#define MSGF_MENU               2
#define MSGF_MOVE               3
#define MSGF_SIZE               4
#define MSGF_SCROLLBAR          5
#define MSGF_NEXTWINDOW         6
#define MSGF_MAINLOOP           8
#define MSGF_USER               4096
#endif  /* NOMSG */

/* Standard window messages */
/* NOTE: All messages below 0x0400 are RESERVED by Windows */
#define WM_NULL                 0x0000
#define WM_CREATE               0x0001
#define WM_DESTROY              0x0002
#define WM_MOVE                 0x0003
#define WM_SIZE                 0x0005
#define WM_ACTIVATE             0x0006
#define WM_SETFOCUS             0x0007
#define WM_KILLFOCUS            0x0008
#define WM_ENABLE               0x000A
#define WM_SETREDRAW            0x000B
#define WM_SETTEXT              0x000C
#define WM_GETTEXT              0x000D
#define WM_GETTEXTLENGTH        0x000E
#define WM_PAINT                0x000F

#define WM_CLOSE                0x0010
#define WM_QUERYENDSESSION      0x0011
#define WM_QUIT                 0x0012
#define WM_QUERYOPEN            0x0013
#define WM_ERASEBKGND           0x0014
#define WM_SYSCOLORCHANGE       0x0015
#define WM_ENDSESSION           0x0016
#define WM_SHOWWINDOW           0x0018
#define WM_CTLCOLOR             0x0019
#define WM_SETTINGCHANGE        0x001A
#define WM_WININICHANGE         WM_SETTINGCHANGE
#define WM_DEVMODECHANGE        0x001B
#define WM_ACTIVATEAPP          0x001C
#define WM_FONTCHANGE           0x001D
#define WM_TIMECHANGE           0x001E
#define WM_CANCELMODE           0x001F

#define WM_SETCURSOR            0x0020
#define WM_MOUSEACTIVATE        0x0021
#define WM_CHILDACTIVATE        0x0022
#define WM_QUEUESYNC            0x0023
#define WM_GETMINMAXINFO        0x0024
#define WM_ICONERASEBKGND       0x0027
#define WM_NEXTDLGCTL           0x0028
#define WM_SPOOLERSTATUS        0x002A
#define WM_DRAWITEM             0x002B
#define WM_MEASUREITEM          0x002C
#define WM_DELETEITEM           0x002D
#define WM_VKEYTOITEM           0x002E
#define WM_CHARTOITEM           0x002F

#define WM_SETFONT              0x0030
#define WM_GETFONT              0x0031
#define WM_QUERYDRAGICON        0x0037
#define WM_COMPAREITEM          0x0039

#define WM_COMPACTING           0x0041
#define WM_COMMNOTIFY           0x0044
#define WM_WINDOWPOSCHANGING    0x0046
#define WM_WINDOWPOSCHANGED     0x0047
#define WM_POWER                0x0048
#define WM_NOTIFY               0x004E

#define WM_TCARD		        0x0052
#define WM_HELP                 0x0053
#define WM_USERCHANGED		    0x0054

#define WM_CONTEXTMENU          0x007B

#define WM_NCCREATE             0x0081
#define WM_NCDESTROY            0x0082
#define WM_NCCALCSIZE           0x0083
#define WM_NCHITTEST            0x0084
#define WM_NCPAINT              0x0085
#define WM_NCACTIVATE           0x0086
#define WM_GETDLGCODE           0x0087

#define WM_NCMOUSEMOVE          0x00A0
#define WM_NCLBUTTONDOWN        0x00A1
#define WM_NCLBUTTONUP          0x00A2
#define WM_NCLBUTTONDBLCLK      0x00A3
#define WM_NCRBUTTONDOWN        0x00A4
#define WM_NCRBUTTONUP          0x00A5
#define WM_NCRBUTTONDBLCLK      0x00A6
#define WM_NCMBUTTONDOWN        0x00A7
#define WM_NCMBUTTONUP          0x00A8
#define WM_NCMBUTTONDBLCLK      0x00A9

#define WM_KEYFIRST             0x0100
#define WM_KEYDOWN              0x0100
#define WM_KEYUP                0x0101
#define WM_CHAR                 0x0102
#define WM_DEADCHAR             0x0103
#define WM_SYSKEYDOWN           0x0104
#define WM_SYSKEYUP             0x0105
#define WM_SYSCHAR              0x0106
#define WM_SYSDEADCHAR          0x0107
#define WM_KEYLAST              0x0108

#define WM_INITDIALOG           0x0110
#define WM_COMMAND              0x0111
#define WM_SYSCOMMAND           0x0112
#define WM_TIMER                0x0113
#define WM_HSCROLL              0x0114
#define WM_VSCROLL              0x0115
#define WM_INITMENU             0x0116
#define WM_INITMENUPOPUP        0x0117
#define WM_MENUSELECT           0x011F
#define WM_MENUCHAR             0x0120

#define WM_ENTERIDLE            0x0121

#define WM_MOUSEFIRST           0x0200
#define WM_MOUSEMOVE            0x0200
#define WM_LBUTTONDOWN          0x0201
#define WM_LBUTTONUP            0x0202
#define WM_LBUTTONDBLCLK        0x0203
#define WM_RBUTTONDOWN          0x0204
#define WM_RBUTTONUP            0x0205
#define WM_RBUTTONDBLCLK        0x0206
#define WM_MBUTTONDOWN          0x0207
#define WM_MBUTTONUP            0x0208
#define WM_MBUTTONDBLCLK        0x0209
#define WM_MOUSELAST            0x0209

#define WM_PARENTNOTIFY         0x0210

#define WM_MDICREATE            0x0220
#define WM_MDIDESTROY           0x0221
#define WM_MDIACTIVATE          0x0222
#define WM_MDIRESTORE           0x0223
#define WM_MDINEXT              0x0224
#define WM_MDIMAXIMIZE          0x0225
#define WM_MDITILE              0x0226
#define WM_MDICASCADE           0x0227
#define WM_MDIICONARRANGE       0x0228
#define WM_MDIGETACTIVE         0x0229

#define WM_MDISETMENU           0x0230
#define WM_ENTERSIZEMOVE        0x0231      
#define WM_EXITSIZEMOVE         0x0232      
#define WM_DROPFILES            0x0233

#define WM_CUT                  0x0300
#define WM_COPY                 0x0301
#define WM_PASTE                0x0302
#define WM_CLEAR                0x0303
#define WM_UNDO                 0x0304
#define WM_RENDERFORMAT         0x0305
#define WM_RENDERALLFORMATS     0x0306
#define WM_DESTROYCLIPBOARD     0x0307
#define WM_DRAWCLIPBOARD        0x0308
#define WM_PAINTCLIPBOARD       0x0309
#define WM_SIZECLIPBOARD        0x030B
#define WM_VSCROLLCLIPBOARD     0x030A
#define WM_ASKCBFORMATNAME      0x030C
#define WM_CHANGECBCHAIN        0x030D
#define WM_HSCROLLCLIPBOARD     0x030E
#define WM_QUERYNEWPALETTE      0x030F

#define WM_PALETTEISCHANGING    0x0310
#define WM_PALETTECHANGED       0x0311
#define WM_PRINT                0x0317
#define WM_PRINTCLIENT          0x0318

/* WinPad specific messages */
#define WM_HANDHELDFIRST        0x0358
#define WM_HANDHELDLAST         0x035F

/* PenWindows specific messages */
#define WM_PENWINFIRST          0x0380
#define WM_PENWINLAST           0x038F

/* Coalescing messages */
#define WM_COALESCE_FIRST           0x0390
#define WM_COALESCE_LAST            0x039F

#define WM_USER                 0x0400

/* NOTE: All messages between WM_APP and 0xBFFF are for exclusive use by apps */
#define WM_APP                  0x8000

#if (WINVER >= 0x030a)
/****** Power management ****************************************************/

/* wParam for WM_POWER window message and DRV_POWER driver notification */
#define PWR_OK              1
#define PWR_FAIL            (-1)
#define PWR_SUSPENDREQUEST  1
#define PWR_SUSPENDRESUME   2
#define PWR_CRITICALRESUME  3
#endif  /* WINVER >= 0x030a */

#if (WINVER >= 0x0400)
/*  wParam for WM_SIZING message  */
#define WMSZ_LEFT           1
#define WMSZ_RIGHT          2
#define WMSZ_TOP            3
#define WMSZ_TOPLEFT        4
#define WMSZ_TOPRIGHT       5
#define WMSZ_BOTTOM         6
#define WMSZ_BOTTOMLEFT     7
#define WMSZ_BOTTOMRIGHT    8

#endif  /* WINVER >= 0x400 */

/****** Application termination *********************************************/

void    WINAPI PostQuitMessage(int);

/****** Window class management *********************************************/

typedef LRESULT (CALLBACK* WNDPROC)(HWND, UINT, WPARAM, LPARAM);

typedef struct tagWNDCLASS
{
    UINT        style;
    WNDPROC     lpfnWndProc;
    int         cbClsExtra;
    int         cbWndExtra;
    HINSTANCE   hInstance;
    HICON       hIcon;
    HCURSOR     hCursor;
    HBRUSH      hbrBackground;
    LPCSTR      lpszMenuName;
    LPCSTR      lpszClassName;
} WNDCLASS;
typedef WNDCLASS* PWNDCLASS;
typedef WNDCLASS NEAR* NPWNDCLASS;
typedef WNDCLASS FAR* LPWNDCLASS;

ATOM    WINAPI RegisterClass(const WNDCLASS FAR*);
BOOL    WINAPI UnregisterClass(LPCSTR, HINSTANCE);

BOOL    WINAPI GetClassInfo(HINSTANCE, LPCSTR, LPWNDCLASS);
int     WINAPI GetClassName(HWND, LPSTR, int);

#ifndef NOWINSTYLES

/* Class styles */
#define CS_VREDRAW          0x0001
#define CS_HREDRAW          0x0002
#define CS_KEYCVTWINDOW     0x0004
#define CS_DBLCLKS          0x0008

#define CS_OWNDC            0x0020
#define CS_CLASSDC          0x0040
#define CS_PARENTDC         0x0080

#define CS_NOKEYCVT         0x0100
#define CS_NOCLOSE          0x0200
#define CS_SAVEBITS         0x0800

#define CS_BYTEALIGNCLIENT  0x1000
#define CS_BYTEALIGNWINDOW  0x2000
#define CS_GLOBALCLASS      0x4000

#endif /* NOWINSTYLES */

#ifndef NOWINOFFSETS

WORD    WINAPI GetClassWord(HWND, int);
WORD    WINAPI SetClassWord(HWND, int, WORD);
LONG    WINAPI GetClassLong(HWND, int);
LONG    WINAPI SetClassLong(HWND, int, LONG);

/* Class field offsets for GetClassLong() and GetClassWord() */
#define GCL_MENUNAME        (-8)
#define GCW_HBRBACKGROUND   (-10)
#define GCW_HCURSOR         (-12)
#define GCW_HICON           (-14)
#define GCW_HMODULE         (-16)
#define GCW_CBWNDEXTRA      (-18)
#define GCW_CBCLSEXTRA      (-20)
#define GCL_WNDPROC         (-24)
#define GCW_STYLE           (-26)

#if (WINVER >= 0x030a)
#define GCW_ATOM            (-32)
#endif  /* WINVER >= 0x030a */
#endif /* NOWINOFFSETS */

/****** Window creation/destroy *********************************************/

/* Window Styles */
#ifndef NOWINSTYLES

/* Basic window types */
#define WS_OVERLAPPED           0x00000000L
#define WS_POPUP                0x80000000L
#define WS_CHILD                0x40000000L

/* Clipping styles */
#define WS_CLIPSIBLINGS         0x04000000L
#define WS_CLIPCHILDREN         0x02000000L

/* Generic window states */
#define WS_VISIBLE              0x10000000L
#define WS_DISABLED             0x08000000L

/* Main window states */
#define WS_MINIMIZE             0x20000000L
#define WS_MAXIMIZE             0x01000000L

/* Main window styles */
#define WS_CAPTION              0x00C00000L     /* WS_BORDER | WS_DLGFRAME */
#define WS_BORDER               0x00800000L
#define WS_DLGFRAME             0x00400000L
#define WS_VSCROLL              0x00200000L
#define WS_HSCROLL              0x00100000L
#define WS_SYSMENU              0x00080000L
#define WS_THICKFRAME           0x00040000L
#define WS_MINIMIZEBOX          0x00020000L
#define WS_MAXIMIZEBOX          0x00010000L

/* Control window styles */
#define WS_GROUP                0x00020000L
#define WS_TABSTOP              0x00010000L

/* Common Window Styles */
#define WS_OVERLAPPEDWINDOW     (WS_OVERLAPPED | WS_CAPTION | WS_SYSMENU | WS_THICKFRAME | WS_MINIMIZEBOX | WS_MAXIMIZEBOX)
#define WS_POPUPWINDOW          (WS_POPUP | WS_BORDER | WS_SYSMENU)
#define WS_CHILDWINDOW          (WS_CHILD)

/* Extended Window Styles */
#define WS_EX_DLGMODALFRAME     0x00000001L
#define WS_EX_NOPARENTNOTIFY    0x00000004L

#if (WINVER >= 0x030a)
#define WS_EX_TOPMOST           0x00000008L
#define WS_EX_ACCEPTFILES       0x00000010L
#define WS_EX_TRANSPARENT       0x00000020L
#endif  /* WINVER >= 0x030a */

/* Obsolete style names */
#define WS_TILED                WS_OVERLAPPED
#define WS_ICONIC               WS_MINIMIZE
#define WS_SIZEBOX              WS_THICKFRAME
#define WS_TILEDWINDOW          WS_OVERLAPPEDWINDOW

#endif  /* NOWINSTYLES */

/* Special value for CreateWindow, et al. */
#define HWND_DESKTOP        ((HWND)0)

BOOL    WINAPI IsWindow(HWND);

HWND    WINAPI CreateWindow(LPCSTR, LPCSTR, DWORD, int, int, int, int, HWND, HMENU, HINSTANCE, void FAR*);
HWND    WINAPI CreateWindowEx(DWORD, LPCSTR, LPCSTR, DWORD, int, int, int, int, HWND, HMENU, HINSTANCE, void FAR*);

/* WM_CREATE/WM_NCCREATE lParam struct */
typedef struct tagCREATESTRUCT
{
    void FAR* lpCreateParams;
    HINSTANCE hInstance;
    HMENU     hMenu;
    HWND      hwndParent;
    int       cy;
    int       cx;
    int       y;
    int       x;
    LONG      style;
    LPCSTR    lpszName;
    LPCSTR    lpszClass;
    DWORD     dwExStyle;
} CREATESTRUCT, FAR * LPCREATESTRUCT;

BOOL    WINAPI DestroyWindow(HWND);

/* Basic window attributes */

HTASK   WINAPI GetWindowTask(HWND);

BOOL    WINAPI IsChild(HWND, HWND);

HWND    WINAPI GetParent(HWND);
HWND    WINAPI SetParent(HWND, HWND);

BOOL    WINAPI IsWindowVisible(HWND);

BOOL    WINAPI ShowWindow(HWND, int);

#ifndef NOSHOWWINDOW

#define SW_HIDE             0
#define SW_SHOWNORMAL       1
#define SW_NORMAL           SW_SHOWNORMAL
#define SW_SHOWMINIMIZED    2
#define SW_SHOWMAXIMIZED    3
#define SW_MAXIMIZE         SW_SHOWMAXIMIZED
#define SW_SHOWNOACTIVATE   4
#define SW_SHOW             5
#define SW_MINIMIZE         6
#define SW_SHOWMINNOACTIVE  7
#define SW_SHOWNA           8
#define SW_RESTORE          9

/* Obsolete ShowWindow() command names */
#define HIDE_WINDOW         SW_HIDE
#define SHOW_OPENWINDOW     SW_SHOWNORMAL
#define SHOW_ICONWINDOW     SW_SHOWMINIMIZED
#define SHOW_FULLSCREEN     SW_SHOWMAXIMIZED
#define SHOW_OPENNOACTIVATE SW_SHOWNOACTIVATE

/* WM_SHOWWINDOW wParam codes */
#define SW_PARENTCLOSING    1
#define SW_OTHERMAXIMIZED   2
#define SW_PARENTOPENING    3
#define SW_OTHERRESTORED    4

/* Obsolete constant names */
#define SW_OTHERZOOM        SW_OTHERMAXIMIZED
#define SW_OTHERUNZOOM      SW_OTHERRESTORED
#endif /* NOSHOWWINDOW */

/* Enabled state */
BOOL    WINAPI EnableWindow(HWND,BOOL);
BOOL    WINAPI IsWindowEnabled(HWND);

/* Window text */
void    WINAPI SetWindowText(HWND, LPCSTR);
int     WINAPI GetWindowTextLength(HWND);
int     WINAPI GetWindowText(HWND, LPSTR, int);

/* Window words */
WORD    WINAPI GetWindowWord(HWND, int);
WORD    WINAPI SetWindowWord(HWND, int, WORD);
LONG    WINAPI GetWindowLong(HWND, int);
LONG    WINAPI SetWindowLong(HWND, int, LONG);

/* Window field offsets for GetWindowLong() and GetWindowWord() */
#ifndef NOWINOFFSETS
#define GWL_WNDPROC     (-4)
#define GWW_HINSTANCE   (-6)
#define GWW_HWNDPARENT  (-8)
#define GWW_ID          (-12)
#define GWL_STYLE       (-16)
#define GWL_EXSTYLE     (-20)
#endif  /* NOWINOFFSETS */

/****** Window size, position, Z-order, and visibility **********************/

#define CW_USEDEFAULT     ((int)0x8000)

void    WINAPI GetClientRect(HWND, LPRECT);
void    WINAPI GetWindowRect(HWND, LPRECT);

#if (WINVER >= 0x030a)
typedef struct tagWINDOWPLACEMENT
{
    UINT  length;
    UINT  flags;
    UINT  showCmd;
    POINT ptMinPosition;
    POINT ptMaxPosition;
    RECT  rcNormalPosition;
} WINDOWPLACEMENT;
typedef WINDOWPLACEMENT     *PWINDOWPLACEMENT;
typedef WINDOWPLACEMENT FAR* LPWINDOWPLACEMENT;

#define WPF_SETMINPOSITION      0x0001
#define WPF_RESTORETOMAXIMIZED  0x0002

BOOL    WINAPI GetWindowPlacement(HWND, WINDOWPLACEMENT FAR*);
BOOL    WINAPI SetWindowPlacement(HWND, const WINDOWPLACEMENT FAR*);
#endif  /* WINVER >= 0x030a */

BOOL    WINAPI SetWindowPos(HWND, HWND, int, int, int, int, UINT);
/* SetWindowPos() and WINDOWPOS flags */
#define SWP_NOSIZE          0x0001
#define SWP_NOMOVE          0x0002
#define SWP_NOZORDER        0x0004
#define SWP_NOREDRAW        0x0008
#define SWP_NOACTIVATE      0x0010
#define SWP_FRAMECHANGED    0x0020  /* The frame changed: send WM_NCCALCSIZE */
#define SWP_SHOWWINDOW      0x0040
#define SWP_HIDEWINDOW      0x0080
#define SWP_NOCOPYBITS      0x0100
#define SWP_NOOWNERZORDER   0x0200  /* Don't do owner Z ordering */

#define SWP_DRAWFRAME       SWP_FRAMECHANGED
#define SWP_NOREPOSITION    SWP_NOOWNERZORDER

#define SWP_NOSENDCHANGING  0x0400
#define SWP_DEFERERASE      0x2000

/* SetWindowPos() hwndInsertAfter field values */
#define HWND_TOP            ((HWND)0)
#define HWND_BOTTOM         ((HWND)1)
#define HWND_TOPMOST        ((HWND)-1)
#define HWND_NOTOPMOST      ((HWND)-2)

#ifndef NODEFERWINDOWPOS

DECLARE_HANDLE(HDWP);

HDWP    WINAPI BeginDeferWindowPos(int);
HDWP    WINAPI DeferWindowPos(HDWP, HWND, HWND, int, int, int, int, UINT);
BOOL    WINAPI EndDeferWindowPos(HDWP);

#endif  /* NODEFERWINDOWPOS */

BOOL    WINAPI MoveWindow(HWND, int, int, int, int, BOOL);
BOOL    WINAPI BringWindowToTop(HWND);

#if (WINVER >= 0x030a)

/* WM_WINDOWPOSCHANGING/CHANGED struct pointed to by lParam */
typedef struct tagWINDOWPOS
{
    HWND    hwnd;
    HWND    hwndInsertAfter;
    int     x;
    int     y;
    int     cx;
    int     cy;
    UINT    flags;
} WINDOWPOS;
typedef WINDOWPOS FAR* LPWINDOWPOS;
#endif  /* WINVER >= 0x030a */

/* WM_SIZE message wParam values */
#define SIZE_RESTORED       0
#define SIZE_MINIMIZED      1
#define SIZE_MAXIMIZED      2
#define SIZE_MAXSHOW        3
#define SIZE_MAXHIDE        4

/* Obsolete constant names */
#define SIZENORMAL          SIZE_RESTORED
#define SIZEICONIC          SIZE_MINIMIZED
#define SIZEFULLSCREEN      SIZE_MAXIMIZED
#define SIZEZOOMSHOW        SIZE_MAXSHOW
#define SIZEZOOMHIDE        SIZE_MAXHIDE

/****** Window proc implementation & subclassing support *********************/

LRESULT WINAPI DefWindowProc(HWND, UINT, WPARAM, LPARAM);

#ifdef STRICT
LRESULT WINAPI CallWindowProc(WNDPROC, HWND, UINT, WPARAM, LPARAM);
#else
LRESULT WINAPI CallWindowProc(FARPROC, HWND, UINT, WPARAM, LPARAM);
#endif

/****** Main window support **************************************************/

void    WINAPI AdjustWindowRect(LPRECT, DWORD, BOOL);
void    WINAPI AdjustWindowRectEx(LPRECT, DWORD, BOOL, DWORD);

/* Struct pointed to by WM_GETMINMAXINFO lParam */
typedef struct tagMINMAXINFO
{
    POINT ptReserved;
    POINT ptMaxSize;
    POINT ptMaxPosition;
    POINT ptMinTrackSize;
    POINT ptMaxTrackSize;
} MINMAXINFO;

BOOL    WINAPI FlashWindow(HWND, BOOL);

void    WINAPI ShowOwnedPopups(HWND, BOOL);

/* Obsolete functions */
BOOL    WINAPI OpenIcon(HWND);
void    WINAPI CloseWindow(HWND);
BOOL    WINAPI AnyPopup(void);
BOOL    WINAPI IsIconic(HWND);
BOOL    WINAPI IsZoomed(HWND);

/****** Window coordinate mapping and hit-testing ***************************/

void    WINAPI ClientToScreen(HWND, LPPOINT);
void    WINAPI ScreenToClient(HWND, LPPOINT);

#if (WINVER >= 0x030a)
void    WINAPI MapWindowPoints(HWND hwndFrom, HWND hwndTo, POINT FAR* lppt, UINT cpt);
#endif  /* WINVER >= 0x030a */

HWND    WINAPI WindowFromPoint(POINT);
HWND    WINAPI ChildWindowFromPoint(HWND, POINT);

/****** Window query and enumeration ****************************************/

HWND    WINAPI GetDesktopWindow(void);
HWND    WINAPI FindWindow(LPCSTR, LPCSTR);

#ifdef STRICT
typedef BOOL (CALLBACK* WNDENUMPROC)(HWND, LPARAM);
#else
typedef FARPROC WNDENUMPROC;
#endif

BOOL    WINAPI EnumWindows(WNDENUMPROC, LPARAM);
BOOL    WINAPI EnumChildWindows(HWND, WNDENUMPROC, LPARAM);
BOOL    WINAPI EnumTaskWindows(HTASK, WNDENUMPROC, LPARAM);

HWND    WINAPI GetTopWindow(HWND);
HWND    WINAPI GetWindow(HWND, UINT);
HWND    WINAPI GetNextWindow(HWND, UINT);

/* GetWindow() constants */
#define GW_HWNDFIRST        0
#define GW_HWNDLAST         1
#define GW_HWNDNEXT         2
#define GW_HWNDPREV         3
#define GW_OWNER            4
#define GW_CHILD            5

/****** Window property support *********************************************/

BOOL    WINAPI SetProp(HWND, LPCSTR, HANDLE);
HANDLE  WINAPI GetProp(HWND, LPCSTR);
HANDLE  WINAPI RemoveProp(HWND, LPCSTR);

#ifdef STRICT
typedef BOOL (CALLBACK* PROPENUMPROC)(HWND, LPCSTR, HANDLE);
#else
typedef FARPROC PROPENUMPROC;
#endif

int     WINAPI EnumProps(HWND, PROPENUMPROC);

/****** Window drawing support **********************************************/

HDC     WINAPI GetDC(HWND);
int     WINAPI ReleaseDC(HWND, HDC);

HDC     WINAPI GetWindowDC(HWND);

#if (WINVER >= 0x030a)
HDC     WINAPI GetDCEx(register HWND hwnd, HRGN hrgnClip, DWORD flags);

#define DCX_WINDOW          0x00000001L
#define DCX_CACHE           0x00000002L
#define DCX_CLIPCHILDREN    0x00000008L
#define DCX_CLIPSIBLINGS    0x00000010L
#define DCX_PARENTCLIP      0x00000020L
#define DCX_EXCLUDERGN      0x00000040L
#define DCX_INTERSECTRGN    0x00000080L
#define DCX_LOCKWINDOWUPDATE 0x00000400L
#define DCX_USESTYLE        0x00010000L
#endif  /* WINVER >= 0x030a */

/****** Window repainting ***************************************************/

/* BeginPaint() return structure */
typedef struct tagPAINTSTRUCT
{
    HDC  hdc;
    BOOL fErase;
    RECT rcPaint;
    BOOL fRestore;
    BOOL fIncUpdate;
    BYTE rgbReserved[16];
} PAINTSTRUCT;
typedef PAINTSTRUCT* PPAINTSTRUCT;
typedef PAINTSTRUCT NEAR* NPPAINTSTRUCT;
typedef PAINTSTRUCT FAR* LPPAINTSTRUCT;

HDC     WINAPI  BeginPaint(HWND, LPPAINTSTRUCT);
void    WINAPI  EndPaint(HWND, const PAINTSTRUCT FAR*);

void    WINAPI  UpdateWindow(HWND);

int     WINAPI  ExcludeUpdateRgn(HDC, HWND);

#if (WINVER >= 0x030a)
BOOL    WINAPI LockWindowUpdate(HWND hwndLock);
#endif  /* WINVER >= 0x030a */

BOOL    WINAPI GetUpdateRect(HWND, LPRECT, BOOL);
int     WINAPI GetUpdateRgn(HWND, HRGN, BOOL);

void    WINAPI InvalidateRect(HWND, LPCRECT, BOOL);
void    WINAPI ValidateRect(HWND, LPCRECT);
void    WINAPI InvalidateRgn(HWND, HRGN, BOOL);
void    WINAPI ValidateRgn(HWND, HRGN);

#if (WINVER >= 0x030a)
BOOL    WINAPI RedrawWindow(HWND hwnd, LPCRECT lprcUpdate, HRGN hrgnUpdate, UINT flags);

#define RDW_INVALIDATE      0x0001
#define RDW_INTERNALPAINT   0x0002
#define RDW_ERASE           0x0004
#define RDW_VALIDATE        0x0008

#define RDW_NOINTERNALPAINT 0x0010
#define RDW_NOERASE         0x0020
#define RDW_NOCHILDREN      0x0040
#define RDW_ALLCHILDREN     0x0080

#define RDW_UPDATENOW       0x0100
#define RDW_ERASENOW        0x0200
#define RDW_FRAME           0x0400
#define RDW_NOFRAME         0x0800

#endif  /* WINVER >= 0x030a */

/****** Window scrolling ****************************************************/

void    WINAPI ScrollWindow(HWND, int, int, LPCRECT, LPCRECT);
BOOL    WINAPI ScrollDC(HDC, int, int, LPCRECT, LPCRECT, HRGN, LPRECT);

#if (WINVER >= 0x030a)
int WINAPI ScrollWindowEx(HWND, int, int, LPCRECT, LPCRECT, HRGN, LPRECT, UINT);

#define SW_SCROLLCHILDREN       0x0001
#define SW_INVALIDATE           0x0002
#define SW_ERASE                0x0004
#endif  /* WINVER >= 0x030a */

/****** Non-client window area management ************************************/

#if (WINVER >= 0x030a)
/* WM_NCCALCSIZE return flags */
#define WVR_ALIGNTOP        0x0010
#define WVR_ALIGNLEFT       0x0020
#define WVR_ALIGNBOTTOM     0x0040
#define WVR_ALIGNRIGHT      0x0080
#define WVR_HREDRAW         0x0100
#define WVR_VREDRAW         0x0200
#define WVR_REDRAW          (WVR_HREDRAW | WVR_VREDRAW)
#define WVR_VALIDRECTS      0x0400

/* WM_NCCALCSIZE parameter structure */
typedef struct tagNCCALCSIZE_PARAMS
{
    RECT    rgrc[3];
    WINDOWPOS FAR* lppos;
} NCCALCSIZE_PARAMS;
#else   /* WINVER >= 0x030a */
typedef struct tagNCCALCSIZE_PARAMS
{
    RECT    rgrc[2];
} NCCALCSIZE_PARAMS;
#endif  /* WINVER >= 0x030a */
typedef NCCALCSIZE_PARAMS FAR* LPNCCALCSIZE_PARAMS;

/* WM_NCHITTEST return codes */
#define HTERROR             (-2)
#define HTTRANSPARENT       (-1)
#define HTNOWHERE           0
#define HTCLIENT            1
#define HTCAPTION           2
#define HTSYSMENU           3
#define HTSIZE              4
#define HTMENU              5
#define HTHSCROLL           6
#define HTVSCROLL           7
#define HTMINBUTTON         8
#define HTMAXBUTTON         9
#define HTLEFT              10
#define HTRIGHT             11
#define HTTOP               12
#define HTTOPLEFT           13
#define HTTOPRIGHT          14
#define HTBOTTOM            15
#define HTBOTTOMLEFT        16
#define HTBOTTOMRIGHT       17
#define HTBORDER            18
#define HTGROWBOX           HTSIZE
#define HTREDUCE            HTMINBUTTON
#define HTZOOM              HTMAXBUTTON

/****** Window activation ***************************************************/

HWND    WINAPI SetActiveWindow(HWND);
HWND    WINAPI GetActiveWindow(void);
HWND    WINAPI GetLastActivePopup(HWND);

/* WM_ACTIVATE state values */
#define WA_INACTIVE         0
#define WA_ACTIVE           1
#define WA_CLICKACTIVE      2

/****** Keyboard input support **********************************************/

HWND    WINAPI SetFocus(HWND);
HWND    WINAPI GetFocus(void);

int     WINAPI GetKeyState(int);
int     WINAPI GetAsyncKeyState(int);

void    WINAPI GetKeyboardState(LPBYTE);
void    WINAPI SetKeyboardState(LPBYTE);

/* WM_KEYUP/DOWN/CHAR HIWORD(lParam) flags */
#define KF_EXTENDED     0x0100
#define KF_DLGMODE      0x0800
#define KF_MENUMODE     0x1000
#define KF_ALTDOWN      0x2000
#define KF_REPEAT       0x4000
#define KF_UP           0x8000

/* Virtual key codes */
#ifndef NOVIRTUALKEYCODES
#define VK_LBUTTON      0x01
#define VK_RBUTTON      0x02
#define VK_CANCEL       0x03
#define VK_MBUTTON      0x04
#define VK_BACK         0x08
#define VK_TAB          0x09
#define VK_CLEAR        0x0C
#define VK_RETURN       0x0D
#define VK_SHIFT        0x10
#define VK_CONTROL      0x11
#define VK_MENU         0x12
#define VK_PAUSE        0x13
#define VK_CAPITAL      0x14
#define VK_ESCAPE       0x1B
#define VK_SPACE        0x20
#define VK_PRIOR        0x21
#define VK_NEXT         0x22
#define VK_END          0x23
#define VK_HOME         0x24
#define VK_LEFT         0x25
#define VK_UP           0x26
#define VK_RIGHT        0x27
#define VK_DOWN         0x28
#define VK_SELECT       0x29
#define VK_PRINT        0x2A
#define VK_EXECUTE      0x2B
#define VK_SNAPSHOT     0x2C
#define VK_INSERT       0x2D
#define VK_DELETE       0x2E
#define VK_HELP         0x2F
#define VK_LWIN         0x5B
#define VK_RWIN         0x5C
#define VK_APPS         0x5D
#define VK_NUMPAD0      0x60
#define VK_NUMPAD1      0x61
#define VK_NUMPAD2      0x62
#define VK_NUMPAD3      0x63
#define VK_NUMPAD4      0x64
#define VK_NUMPAD5      0x65
#define VK_NUMPAD6      0x66
#define VK_NUMPAD7      0x67
#define VK_NUMPAD8      0x68
#define VK_NUMPAD9      0x69
#define VK_MULTIPLY     0x6A
#define VK_ADD          0x6B
#define VK_SEPARATOR    0x6C
#define VK_SUBTRACT     0x6D
#define VK_DECIMAL      0x6E
#define VK_DIVIDE       0x6F
#define VK_F1           0x70
#define VK_F2           0x71
#define VK_F3           0x72
#define VK_F4           0x73
#define VK_F5           0x74
#define VK_F6           0x75
#define VK_F7           0x76
#define VK_F8           0x77
#define VK_F9           0x78
#define VK_F10          0x79
#define VK_F11          0x7A
#define VK_F12          0x7B
#define VK_F13          0x7C
#define VK_F14          0x7D
#define VK_F15          0x7E
#define VK_F16          0x7F
#define VK_F17          0x80
#define VK_F18          0x81
#define VK_F19          0x82
#define VK_F20          0x83
#define VK_F21          0x84
#define VK_F22          0x85
#define VK_F23          0x86
#define VK_F24          0x87
#define VK_NUMLOCK      0x90
#define VK_SCROLL       0x91

/* VK_A thru VK_Z are the same as their ASCII equivalents: 'A' thru 'Z' */
/* VK_0 thru VK_9 are the same as their ASCII equivalents: '0' thru '9' */

#endif  /* NOVIRTUALKEYCODES */

/* SetWindowsHook() keyboard hook */
#define WH_KEYBOARD     2

/****** Mouse input support *************************************************/

HWND    WINAPI SetCapture(HWND);
HWND    WINAPI GetCapture(void);
void    WINAPI ReleaseCapture(void);

BOOL    WINAPI SwapMouseButton(BOOL);

/* Mouse message wParam key states */
#ifndef NOKEYSTATES
#define MK_LBUTTON      0x0001
#define MK_RBUTTON      0x0002
#define MK_SHIFT        0x0004
#define MK_CONTROL      0x0008
#define MK_MBUTTON      0x0010
#endif  /* NOKEYSTATES */

/* WM_MOUSEACTIVATE return codes */
#define MA_ACTIVATE         1
#define MA_ACTIVATEANDEAT   2
#define MA_NOACTIVATE       3
#if (WINVER >= 0x030a)
#define MA_NOACTIVATEANDEAT 4
#endif  /* WINVER >= 0x030a */

/* SetWindowsHook() mouse hook */
#ifndef NOWH
#define WH_MOUSE            7

typedef struct tagMOUSEHOOKSTRUCT
{
    POINT   pt;
    HWND    hwnd;
    UINT    wHitTestCode;
    DWORD   dwExtraInfo;
} MOUSEHOOKSTRUCT;
typedef MOUSEHOOKSTRUCT  FAR* LPMOUSEHOOKSTRUCT;
#endif /* NOWH */

/****** Mode control ********************************************************/

HWND    WINAPI GetSysModalWindow(void);
HWND    WINAPI SetSysModalWindow(HWND);

/****** Timer support *******************************************************/

#ifdef STRICT
typedef void (CALLBACK* TIMERPROC)(HWND, UINT, UINT, DWORD);
#else
typedef FARPROC TIMERPROC;
#endif

UINT    WINAPI SetTimer(HWND, UINT, UINT, TIMERPROC);

BOOL    WINAPI KillTimer(HWND, UINT);

/****** Accelerator support *************************************************/

DECLARE_HANDLE(HACCEL);

HACCEL  WINAPI LoadAccelerators(HINSTANCE, LPCSTR);

#ifndef NOMSG
int     WINAPI TranslateAccelerator(HWND, HACCEL, LPMSG);
#endif

/****** Menu support ********************************************************/

#ifndef NOMENUS

/* Menu template header */
typedef struct tagMENUITEMTEMPLATEHEADER
{
    UINT    versionNumber;
    UINT    offset;
} MENUITEMTEMPLATEHEADER;

/* Menu template item struct */
typedef struct tagMENUITEMTEMPLATE
{
    UINT    mtOption;
    UINT    mtID;
    char    mtString[1];
} MENUITEMTEMPLATE;

BOOL    WINAPI IsMenu(HMENU);

HMENU   WINAPI CreateMenu(void);
HMENU   WINAPI CreatePopupMenu(void);
HMENU   WINAPI LoadMenu(HINSTANCE, LPCSTR);
HMENU   WINAPI LoadMenuIndirect(const void FAR*);

HMENU   WINAPI GetMenu(HWND);
HMENU   WINAPI GetSystemMenu(HWND, BOOL);
HMENU   WINAPI GetSubMenu(HMENU, UINT);
BOOL    WINAPI InsertMenu(HMENU, UINT, UINT, UINT, LPCSTR);
BOOL    WINAPI AppendMenu(HMENU, UINT, UINT, LPCSTR);
BOOL    WINAPI ModifyMenu(HMENU, UINT, UINT, UINT, LPCSTR);
BOOL    WINAPI ChangeMenu(HMENU, UINT, LPCSTR, UINT, UINT);
BOOL    WINAPI SetMenuItemBitmaps(HMENU, UINT, UINT, HBITMAP, HBITMAP);
int     WINAPI GetMenuString(HMENU, UINT, LPSTR, int, UINT);

BOOL    WINAPI DestroyMenu(HMENU);
BOOL    WINAPI SetMenu(HWND, HMENU);
void    WINAPI DrawMenuBar(HWND);
BOOL    WINAPI HiliteMenuItem(HWND, HMENU, UINT, UINT);
BOOL    WINAPI RemoveMenu(HMENU, UINT, UINT);
BOOL    WINAPI DeleteMenu(HMENU, UINT, UINT);

#define MF_INSERT           0x0000  /* Obsolete -- only used by ChangeMenu */
#define MF_CHANGE           0x0080  /* Obsolete -- only used by ChangeMenu */
#define MF_APPEND           0x0100  /* Obsolete -- only used by ChangeMenu */
#define MF_DELETE           0x0200  /* Obsolete -- only used by ChangeMenu */
#define MF_REMOVE           0x1000  /* Obsolete -- only used by ChangeMenu */

#define MF_BYCOMMAND        0x0000  /* Obsolete -- only old APIs use these */
#define MF_BYPOSITION       0x0400  /* Obsolete -- only old APIs use these */
#define MF_USECHECKBITMAPS  0x0200  /* Obsolete -- replaced by MF_RADIOCHECK */
#define MF_HELP             0x4000  /* Obsolete -- use MF_RIGHTJUSTIFY */

#define MF_POPUP            0x0010  /* Obsolete -- replace by hSubMenu field */
#define MF_END              0x0080  /* Obsolete -- only used by old RES files */
#define MF_SYSMENU          0x2000  /* Passed back during WM_MENUSELECT */
#define MF_MOUSESELECT      0x8000  /* Passed back during WM_MENUSELECT */

#define MFT_STRING          0x0000
#define MFT_BITMAP          0x0004
#define MFT_MENUBARBREAK    0x0020
#define MFT_MENUBREAK       0x0040
#define MFT_OWNERDRAW       0x0100
#define MFT_RADIOCHECK      0x0200
#define MFT_SEPARATOR       0x0800
#define MFT_RIGHTORDER 	    0x2000
#define MFT_RIGHTJUSTIFY    0x4000

#define MFS_GRAYED          0x0003
#define MFS_DISABLED        MFS_GRAYED
#define MFS_CHECKED         0x0008
#define MFS_HILITE          0x0080
#define MFS_ENABLED         0x0000
#define MFS_UNCHECKED       0x0000
#define MFS_UNHILITE        0x0000
#define MFS_DEFAULT         0x1000

#define MFR_POPUP           0x01
#define MFR_END             0x80

/* old names for menu types & states */
#define MF_SEPARATOR        MFT_SEPARATOR

#define MF_GRAYED           0x0001
#define MF_DISABLED         0x0002

#define MF_CHECKED          MFS_CHECKED
#define MF_ENABLED          MFS_ENABLED
#define MF_UNCHECKED        MFS_UNCHECKED
#define MF_UNHILITE         MFS_UNHILITE

#define MF_STRING           MFT_STRING
#define MF_BITMAP           MFT_BITMAP
#define MF_OWNERDRAW        MFT_OWNERDRAW

#define MF_MENUBARBREAK     MFT_MENUBARBREAK
#define MF_MENUBREAK        MFT_MENUBREAK

#define MF_HILITE           MFS_HILITE

#define MF_DEFAULT          MFS_DEFAULT
#define MF_RIGHTJUSTIFY     MFT_RIGHTJUSTIFY

UINT    WINAPI EnableMenuItem(HMENU, UINT, UINT);
UINT    WINAPI CheckMenuItem(HMENU, UINT, UINT);

int     WINAPI GetMenuItemCount(HMENU);
UINT    WINAPI GetMenuItemID(HMENU, UINT);
UINT    WINAPI GetMenuState(HMENU, UINT, UINT);

DWORD   WINAPI GetMenuCheckMarkDimensions(void);

BOOL    WINAPI TrackPopupMenu(HMENU, UINT, int, int, int, HWND, LPCRECT);

/* Flags for TrackPopupMenu */
#define TPM_LEFTBUTTON      0x0000

#if (WINVER >= 0x030a)
#define TPM_RIGHTBUTTON     0x0002
#define TPM_LEFTALIGN       0x0000
#define TPM_CENTERALIGN     0x0004
#define TPM_RIGHTALIGN      0x0008
#endif  /* WINVER >= 0x030a */

#endif  /* NOMENUS */

/****** Scroll bar support **************************************************/

#ifndef NOSCROLL

/* WM_H/VSCROLL commands */
#define SB_LINEUP           0
#define SB_LINELEFT         0
#define SB_LINEDOWN         1
#define SB_LINERIGHT        1
#define SB_PAGEUP           2
#define SB_PAGELEFT         2
#define SB_PAGEDOWN         3
#define SB_PAGERIGHT        3
#define SB_THUMBPOSITION    4
#define SB_THUMBTRACK       5
#define SB_TOP              6
#define SB_LEFT             6
#define SB_BOTTOM           7
#define SB_RIGHT            7
#define SB_ENDSCROLL        8

/* Scroll bar selection constants */
#define SB_HORZ             0
#define SB_VERT             1
#define SB_CTL              2
#define SB_BOTH             3

int     WINAPI SetScrollPos(HWND, int, int, BOOL);
int     WINAPI GetScrollPos(HWND, int);    
void    WINAPI GetScrollRange(HWND, int, LPINT, LPINT); 
void    WINAPI SetScrollRange(HWND, int, int, int, BOOL);
void    WINAPI ShowScrollBar(HWND, int, BOOL);
BOOL    WINAPI EnableScrollBar(HWND, int, UINT);

/* EnableScrollBar() flags */
#define ESB_ENABLE_BOTH     0x0000
#define ESB_DISABLE_BOTH    0x0003

#define ESB_DISABLE_LEFT    0x0001
#define ESB_DISABLE_RIGHT   0x0002

#define ESB_DISABLE_UP      0x0001
#define ESB_DISABLE_DOWN    0x0002

#define ESB_DISABLE_LTUP    ESB_DISABLE_LEFT
#define ESB_DISABLE_RTDN    ESB_DISABLE_RIGHT

#endif  /* NOSCROLL */

/******* Clipboard manager **************************************************/

#ifndef NOCLIPBOARD

/* Predefined Clipboard Formats */
#define CF_FIRST            1
#define CF_TEXT             1
#define CF_BITMAP           2
#define CF_METAFILEPICT     3
#define CF_SYLK             4
#define CF_DIF              5
#define CF_TIFF             6
#define CF_OEMTEXT          7
#define CF_DIB              8
#define CF_PALETTE          9
#define CF_PENDATA          10
#define CF_RIFF             11
#define CF_WAVE             12

#define CF_OWNERDISPLAY     0x0080
#define CF_DSPTEXT          0x0081
#define CF_DSPBITMAP        0x0082
#define CF_DSPMETAFILEPICT  0x0083

/* "Private" formats don't get GlobalFree()'d */
#define CF_PRIVATEFIRST     0x0200
#define CF_PRIVATELAST      0x02FF

/* "GDIOBJ" formats do get DeleteObject()'d */
#define CF_GDIOBJFIRST      0x0300
#define CF_GDIOBJLAST       0x03FF

/* Clipboard Manager Functions */
BOOL    WINAPI OpenClipboard(HWND);
BOOL    WINAPI CloseClipboard(void);
BOOL    WINAPI EmptyClipboard(void);

#if (WINVER >= 0x030a)
HWND    WINAPI GetOpenClipboardWindow(void);
#endif  /* WINVER >= 0x030a */

HWND    WINAPI GetClipboardOwner(void);

HWND    WINAPI SetClipboardViewer(HWND);
HWND    WINAPI GetClipboardViewer(void);

HANDLE  WINAPI SetClipboardData(UINT, HANDLE);
HANDLE  WINAPI GetClipboardData(UINT);

BOOL    WINAPI IsClipboardFormatAvailable(UINT);
int     WINAPI GetPriorityClipboardFormat(UINT FAR*, int);

UINT    WINAPI RegisterClipboardFormat(LPCSTR);
int     WINAPI CountClipboardFormats(void);
UINT    WINAPI EnumClipboardFormats(UINT);
int     WINAPI GetClipboardFormatName(UINT, LPSTR, int);

BOOL    WINAPI ChangeClipboardChain(HWND, HWND);

#endif  /* NOCLIPBOARD */

/****** Mouse cursor support *************************************************/

HCURSOR WINAPI LoadCursor(HINSTANCE, LPCSTR);
HCURSOR WINAPI CreateCursor(HINSTANCE, int, int, int, int, const void FAR*, const void FAR*);
BOOL    WINAPI DestroyCursor(HCURSOR);

#if (WINVER >= 0x030a)
HCURSOR WINAPI CopyCursor(HINSTANCE, HCURSOR);
#endif /* WINVER >= 0x030a */

int     WINAPI ShowCursor(BOOL);
void    WINAPI ClipCursor(LPCRECT);
void    WINAPI SetCursorPos(int, int);
void    WINAPI GetCursorPos(LPPOINT);

HCURSOR WINAPI SetCursor(HCURSOR);

#if (WINVER >= 0x030a)
HCURSOR WINAPI GetCursor(void);
void    WINAPI GetClipCursor(LPRECT);
#endif  /* WINVER >= 0x030a */

/* Standard cursor resource IDs */
#define IDC_ARROW               MAKEINTRESOURCE(32512)
#define IDC_IBEAM               MAKEINTRESOURCE(32513)
#define IDC_WAIT                MAKEINTRESOURCE(32514)
#define IDC_CROSS               MAKEINTRESOURCE(32515)
#define IDC_UPARROW             MAKEINTRESOURCE(32516)
#define IDC_SIZE                MAKEINTRESOURCE(32640)  /* OBSOLETE: use IDC_SIZEALL */
#define IDC_ICON                MAKEINTRESOURCE(32641)  /* OBSOLETE: use IDC_ARROW */
#define IDC_SIZENWSE            MAKEINTRESOURCE(32642)
#define IDC_SIZENESW            MAKEINTRESOURCE(32643)
#define IDC_SIZEWE              MAKEINTRESOURCE(32644)
#define IDC_SIZENS              MAKEINTRESOURCE(32645)
#define IDC_SIZEALL             MAKEINTRESOURCE(32646)
#define IDC_NO                  MAKEINTRESOURCE(32648)

/****** Icon support *********************************************************/

HICON   WINAPI LoadIcon(HINSTANCE, LPCSTR);
HICON   WINAPI CreateIcon(HINSTANCE, int, int, BYTE, BYTE, const void FAR*, const void FAR*);
BOOL    WINAPI DestroyIcon(HICON);

#if (WINVER >= 0x030a)
HICON   WINAPI CopyIcon(HINSTANCE, HICON);

typedef struct tagNEWHEADER
{
    WORD    Reserved;
    WORD    ResType;        /* RES_ICON or RES_CURSOR */
    WORD    ResCount;
} NEWHEADER, FAR *LPNEWHEADER;

#if (WINVER >= 0x0400)
/* Icon/Cursor header */
typedef struct tagCURSORSHAPE
{
    int     xHotSpot;
    int     yHotSpot;
    int     cx;
    int     cy;
    int     cbWidth;
    BYTE    Planes;
    BYTE    BitsPixel;
} CURSORSHAPE, FAR *LPCURSORSHAPE;
                                  
#endif /* WINVER >= 0x0400 */
#endif  /* WINVER >= 0x030a */

BOOL    WINAPI DrawIcon(HDC, int, int, HICON);

#ifndef NOICONS

/* Standard icon resource IDs */
#ifdef RC_INVOKED
#define IDI_APPLICATION     32512
#define IDI_ERROR           32513   /* ;win40: Name changed from IDI_HAND */
#define IDI_QUESTION        32514
#define IDI_WARNING         32515   /* ;win40: Name changed from IDI_EXCLAMATION */
#define IDI_INFORMATION     32516   /* ;win40: Name changed from IDI_ASTERISK */
#else
#define IDI_APPLICATION     MAKEINTRESOURCE(32512)
#define IDI_ERROR           MAKEINTRESOURCE(32513)  /* ;win40: Name changed from IDI_HAND */
#define IDI_QUESTION        MAKEINTRESOURCE(32514)
#define IDI_WARNING         MAKEINTRESOURCE(32515)  /* ;win40: Name changed from IDI_EXCLAMATION */
#define IDI_INFORMATION     MAKEINTRESOURCE(32516)  /* ;win40: Name changed from IDI_ASTERISK */
#endif /* RC_INVOKED */

#define IDI_HAND            IDI_ERROR
#define IDI_EXCLAMATION     IDI_WARNING
#define IDI_ASTERISK        IDI_INFORMATION

#endif  /* NOICONS */

/****** Caret support ********************************************************/

void    WINAPI CreateCaret(HWND, HBITMAP, int, int);
void    WINAPI DestroyCaret(void);
void    WINAPI ShowCaret(HWND);
void    WINAPI HideCaret(HWND);
void    WINAPI SetCaretPos(int, int);
void    WINAPI SetCaretBlinkTime(UINT);
void    WINAPI GetCaretPos(LPPOINT);
UINT    WINAPI GetCaretBlinkTime(void);

/****** WM_SYSCOMMAND support ***********************************************/

#ifndef NOSYSCOMMANDS

/* System Menu Command Values */
#define SC_SIZE         0xF000
#define SC_MOVE         0xF010
#define SC_MINIMIZE     0xF020
#define SC_MAXIMIZE     0xF030
#define SC_NEXTWINDOW   0xF040
#define SC_PREVWINDOW   0xF050
#define SC_CLOSE        0xF060
#define SC_VSCROLL      0xF070
#define SC_HSCROLL      0xF080
#define SC_MOUSEMENU    0xF090
#define SC_KEYMENU      0xF100
#define SC_ARRANGE      0xF110
#define SC_RESTORE      0xF120
#define SC_TASKLIST     0xF130
#define SC_SCREENSAVE   0xF140
#define SC_HOTKEY       0xF150

/* Obsolete names */
#define SC_ICON         SC_MINIMIZE
#define SC_ZOOM         SC_MAXIMIZE

#endif  /* NOSYSCOMMANDS */

/****** MDI Support *********************************************************/

#ifndef NOMDI

/* CreateWindow lpParams structure for creating MDI client */
typedef struct tagCLIENTCREATESTRUCT
{
    HMENU  hWindowMenu;
    UINT   idFirstChild;
} CLIENTCREATESTRUCT;

typedef CLIENTCREATESTRUCT FAR* LPCLIENTCREATESTRUCT;

/* MDI client style bits */
#if (WINVER >= 0x030a)
#define MDIS_ALLCHILDSTYLES 0x0001
#endif  /* WINVER >= 0x030a */

/* WM_MDICREATE message structure */
typedef struct tagMDICREATESTRUCT
{
    LPCSTR  szClass;
    LPCSTR  szTitle;
    HINSTANCE hOwner;
    int     x;
    int     y;
    int     cx;
    int     cy;
    DWORD   style;
    LPARAM  lParam;
} MDICREATESTRUCT;
typedef MDICREATESTRUCT FAR*  LPMDICREATESTRUCT;

#if (WINVER >= 0x030a)
/* wParam values for WM_MDITILE and WM_MDICASCADE messages. */
#define MDITILE_VERTICAL        0x0000
#define MDITILE_HORIZONTAL      0x0001
#define MDITILE_SKIPDISABLED    0x0002
#endif  /* WINVER >= 0x030a */

LRESULT WINAPI DefFrameProc(HWND, HWND, UINT, WPARAM, LPARAM);

LRESULT WINAPI DefMDIChildProc(HWND, UINT, WPARAM, LPARAM);

#ifndef NOMSG
BOOL    WINAPI TranslateMDISysAccel(HWND, LPMSG);
#endif

UINT    WINAPI ArrangeIconicWindows(HWND);
BOOL    WINAPI TileChildWindows(HWND, UINT);
BOOL    WINAPI CascadeChildWindows(HWND, UINT);
#endif  /* NOMDI */

/****** Dialog and Control Management ***************************************/

#ifndef NOCTLMGR

/* Dialog window class */
#define WC_DIALOG (MAKEINTATOM(0x8002))

/* cbWndExtra bytes needed by dialog manager for dialog classes */
#define DLGWINDOWEXTRA 30

/* Dialog styles */
#define DS_ABSALIGN         0x0001L
#define DS_SYSMODAL         0x0002L
#define DS_LOCALEDIT        0x0020L
#define DS_SETFONT          0x0040L     
#define DS_MODALFRAME       0x0080L
#define DS_NOIDLEMSG        0x0100L

/* Dialog messages */
#define DM_GETDEFID         (WM_USER+0)
#define DM_SETDEFID         (WM_USER+1)

/* Returned in HIWORD() of DM_GETDEFID result if msg is supported */
#define DC_HASDEFID         0x534B

#ifdef STRICT
typedef BOOL (CALLBACK* DLGPROC)(HWND, UINT, WPARAM, LPARAM);
#else
typedef FARPROC DLGPROC;
#endif

/* Get/SetWindowWord/Long offsets for use with WC_DIALOG windows */
#define DWL_MSGRESULT       0
#define DWL_DLGPROC         4
#define DWL_USER            8

#ifndef NOMSG
BOOL    WINAPI IsDialogMessage(HWND, LPMSG);
#endif

LRESULT WINAPI DefDlgProc(HWND, UINT, WPARAM, LPARAM);

HWND    WINAPI CreateDialog(HINSTANCE, LPCSTR, HWND, DLGPROC);
HWND    WINAPI CreateDialogIndirect(HINSTANCE, const void FAR*, HWND, DLGPROC);
HWND    WINAPI CreateDialogParam(HINSTANCE, LPCSTR, HWND, DLGPROC, LPARAM);
HWND    WINAPI CreateDialogIndirectParam(HINSTANCE, const void FAR*, HWND, DLGPROC, LPARAM);

int     WINAPI DialogBox(HINSTANCE, LPCSTR, HWND, DLGPROC);
int     WINAPI DialogBoxIndirect(HINSTANCE, HGLOBAL, HWND, DLGPROC);
int     WINAPI DialogBoxParam(HINSTANCE, LPCSTR, HWND, DLGPROC, LPARAM);
int     WINAPI DialogBoxIndirectParam(HINSTANCE, HGLOBAL, HWND, DLGPROC, LPARAM);

void    WINAPI EndDialog(HWND, int);

int     WINAPI GetDlgCtrlID(HWND);
HWND    WINAPI GetDlgItem(HWND, int);
LRESULT WINAPI SendDlgItemMessage(HWND, int, UINT, WPARAM, LPARAM);

void    WINAPI SetDlgItemInt(HWND, int, UINT, BOOL);
UINT    WINAPI GetDlgItemInt(HWND, int, BOOL FAR *, BOOL);

void    WINAPI SetDlgItemText(HWND, int, LPCSTR);
int     WINAPI GetDlgItemText(HWND, int, LPSTR, int);

void    WINAPI CheckDlgButton(HWND, int, UINT);
void    WINAPI CheckRadioButton(HWND, int, int, int);
UINT    WINAPI IsDlgButtonChecked(HWND, int);

HWND    WINAPI GetNextDlgGroupItem(HWND, HWND, BOOL);
HWND    WINAPI GetNextDlgTabItem(HWND, HWND, BOOL);

void    WINAPI MapDialogRect(HWND, LPRECT);
DWORD   WINAPI GetDialogBaseUnits(void);

/* dialog codes */
#define DLGC_WANTARROWS         0x0001
#define DLGC_WANTTAB            0x0002
#define DLGC_WANTALLKEYS        0x0004
#define DLGC_WANTMESSAGE        0x0004
#define DLGC_HASSETSEL          0x0008
#define DLGC_DEFPUSHBUTTON      0x0010
#define DLGC_UNDEFPUSHBUTTON    0x0020
#define DLGC_RADIOBUTTON        0x0040
#define DLGC_WANTCHARS          0x0080
#define DLGC_STATIC             0x0100
#define DLGC_BUTTON             0x2000

/* WM_CTLCOLOR control IDs */
#define CTLCOLOR_MSGBOX         0
#define CTLCOLOR_EDIT           1
#define CTLCOLOR_LISTBOX        2
#define CTLCOLOR_BTN            3
#define CTLCOLOR_DLG            4
#define CTLCOLOR_SCROLLBAR      5
#define CTLCOLOR_STATIC         6

#endif  /* NOCTLMGR */

/* Standard dialog button IDs */
#define IDOK            1
#define IDCANCEL        2
#define IDABORT         3
#define IDRETRY         4
#define IDIGNORE        5
#define IDYES           6
#define IDNO            7

typedef struct tagNMHDR
{
#ifdef tagWND
    HWND_16 hwndFrom;
#else
    HWND  hwndFrom;
#endif
    WORD  _wDummy1;						
    UINT  idFrom;
    WORD  _wDummy2;
    UINT  code;
    WORD  _wDummy3;
}   NMHDR;
typedef NMHDR FAR * LPNMHDR;

/****** Owner draw control support ******************************************/

/* Owner draw control types */
#define ODT_MENU            1
#define ODT_LISTBOX         2
#define ODT_COMBOBOX        3
#define ODT_BUTTON          4

/* Owner draw actions */
#define ODA_DRAWENTIRE      0x0001
#define ODA_SELECT          0x0002
#define ODA_FOCUS           0x0004

/* Owner draw state */
#define ODS_SELECTED        0x0001
#define ODS_GRAYED          0x0002
#define ODS_DISABLED        0x0004
#define ODS_CHECKED         0x0008
#define ODS_FOCUS           0x0010

/* LPARAM of WM_DRAWITEM is LPDRAWITEMSTRUCT */
typedef struct tagDRAWITEMSTRUCT
{
    UINT        CtlType;
    UINT        CtlID;
    UINT        itemID;
    UINT        itemAction;
    UINT        itemState;
    HWND        hwndItem;
    HDC         hDC;
    RECT        rcItem;
    DWORD       itemData;
} DRAWITEMSTRUCT;
typedef DRAWITEMSTRUCT NEAR* PDRAWITEMSTRUCT;
typedef DRAWITEMSTRUCT FAR* LPDRAWITEMSTRUCT;

/* LPARAM of WM_MEASUREITEM is LPMEASUREITEMSTRUCT */
typedef struct tagMEASUREITEMSTRUCT
{
    UINT        CtlType;
    UINT        CtlID;
    UINT        itemID;
    UINT        itemWidth;
    UINT        itemHeight;
    DWORD       itemData;
} MEASUREITEMSTRUCT;
typedef MEASUREITEMSTRUCT NEAR* PMEASUREITEMSTRUCT;
typedef MEASUREITEMSTRUCT FAR* LPMEASUREITEMSTRUCT;

/* LPARAM of WM_DELETEITEM is LPDELETEITEMSTRUCT */
typedef struct tagDELETEITEMSTRUCT
{
    UINT        CtlType;
    UINT        CtlID;
    UINT        itemID;
    HWND        hwndItem;
    DWORD       itemData;
} DELETEITEMSTRUCT;
typedef DELETEITEMSTRUCT NEAR* PDELETEITEMSTRUCT;
typedef DELETEITEMSTRUCT FAR* LPDELETEITEMSTRUCT;

/* LPARAM of WM_COMPAREITEM is LPCOMPAREITEMSTRUCT */
typedef struct tagCOMPAREITEMSTRUCT
{
    UINT        CtlType;
    UINT        CtlID;
    HWND hwndItem;
    UINT        itemID1;
    DWORD       itemData1;
    UINT        itemID2;
    DWORD       itemData2;
} COMPAREITEMSTRUCT;
typedef COMPAREITEMSTRUCT NEAR* PCOMPAREITEMSTRUCT;
typedef COMPAREITEMSTRUCT FAR* LPCOMPAREITEMSTRUCT;

/****** Static control ******************************************************/

#ifndef NOCTLMGR

/* Static Control Styles */
#define SS_LEFT             0x00000000L
#define SS_CENTER           0x00000001L
#define SS_RIGHT            0x00000002L
#define SS_ICON             0x00000003L
#define SS_BLACKRECT        0x00000004L
#define SS_GRAYRECT         0x00000005L
#define SS_WHITERECT        0x00000006L
#define SS_BLACKFRAME       0x00000007L
#define SS_GRAYFRAME        0x00000008L
#define SS_WHITEFRAME       0x00000009L
#define SS_SIMPLE           0x0000000BL
#define SS_LEFTNOWORDWRAP   0x0000000CL

#define SS_NOPREFIX         0x00000080L

#if (WINVER >= 0x030a)
#ifndef NOWINMESSAGES
/* Static Control Mesages */
#define STM_SETICON         (WM_USER+0)
#define STM_GETICON         (WM_USER+1)
#endif  /* NOWINMESSAGES */
#endif  /* WINVER >= 0x030a */

#endif  /* NOCTLMGR */

/****** Button control *****************************************************/

#ifndef NOCTLMGR

/* Button Control Styles */
#define BS_PUSHBUTTON       0x00000000L
#define BS_DEFPUSHBUTTON    0x00000001L
#define BS_CHECKBOX         0x00000002L
#define BS_AUTOCHECKBOX     0x00000003L
#define BS_RADIOBUTTON      0x00000004L
#define BS_3STATE           0x00000005L
#define BS_AUTO3STATE       0x00000006L
#define BS_GROUPBOX         0x00000007L
#define BS_USERBUTTON       0x00000008L
#define BS_AUTORADIOBUTTON  0x00000009L
#define BS_OWNERDRAW        0x0000000BL

#define BS_RIGHTBUTTON      0x00000020L

#define BS_LEFTTEXT         BS_RIGHTBUTTON

#ifndef NOWINMESSAGES
/* Button Control Messages  */
#define BM_GETCHECK         (WM_USER+0)
#define BM_SETCHECK         (WM_USER+1)
#define BM_GETSTATE         (WM_USER+2)
#define BM_SETSTATE         (WM_USER+3)
#define BM_SETSTYLE         (WM_USER+4)
#define BM_CLICK            (WM_USER+5)

#define BST_UNCHECKED       0x0000
#define BST_CHECKED         0x0001
#define BST_INDETERMINATE   0x0002
#define BST_PUSHED          0x0004
#define BST_FOCUS           0x0008

/* User Button Notification Codes */
#define BN_CLICKED          0
#define BN_PAINT            1
#define BN_PUSHED           2
#define BN_HILITE           BN_PUSHED
#define BN_UNPUSHED         3
#define BN_UNHILITE         BN_UNPUSHED
#define BN_DISABLE          4
#define BN_DBLCLK           5
#define BN_DOUBLECLICKED    BN_DBLCLK
#endif /* NOWINMESSAGES */

#endif  /* NOCTLMGR */

/****** Edit control *******************************************************/

#ifndef NOCTLMGR

/* Edit control styles */
#ifndef NOWINSTYLES
#define ES_LEFT                 0x0000L
#define ES_CENTER               0x0001L
#define ES_RIGHT                0x0002L
#define ES_MULTILINE            0x0004L
#define ES_UPPERCASE            0x0008L
#define ES_LOWERCASE            0x0010L
#define ES_PASSWORD             0x0020L
#define ES_AUTOVSCROLL          0x0040L
#define ES_AUTOHSCROLL          0x0080L
#define ES_NOHIDESEL            0x0100L
#define ES_OEMCONVERT           0x0400L
#if (WINVER >= 0x030a)
#define ES_READONLY             0x0800L
#define ES_WANTRETURN           0x1000L
#endif  /* WINVER >= 0x030a */
#if (WINVER >= 0x0400)
#define ES_NUMBER               0x2000L
#endif  /* WINVER >= 0x0400 */
#endif  /* NOWINSTYLES */

/* Edit control messages */
#ifndef NOWINMESSAGES
#define EM_GETSEL               (WM_USER+0)
#define EM_SETSEL               (WM_USER+1)
#define EM_GETRECT              (WM_USER+2)
#define EM_SETRECT              (WM_USER+3)
#define EM_SETRECTNP            (WM_USER+4)
#define EM_LINESCROLL           (WM_USER+6)
#define EM_SCROLLCARET          (WM_USER+7)
#define EM_GETMODIFY            (WM_USER+8)
#define EM_SETMODIFY            (WM_USER+9)
#define EM_GETLINECOUNT         (WM_USER+10)
#define EM_LINEINDEX            (WM_USER+11)
#define EM_SETHANDLE            (WM_USER+12)
#define EM_GETHANDLE            (WM_USER+13)
#define EM_LINELENGTH           (WM_USER+17)
#define EM_REPLACESEL           (WM_USER+18)
#define EM_SETFONT              (WM_USER+19)    /* NOT IMPLEMENTED: use WM_SETFONT */
#define EM_GETLINE              (WM_USER+20)
#define EM_SETLIMITTEXT         (WM_USER+21)
#define EM_CANUNDO              (WM_USER+22)
#define EM_UNDO                 (WM_USER+23)
#define EM_FMTLINES             (WM_USER+24)
#define EM_LINEFROMCHAR         (WM_USER+25)
#define EM_SETWORDBREAK         (WM_USER+26)    /* NOT IMPLEMENTED: use EM_SETWORDBREAK */
#define EM_SETTABSTOPS          (WM_USER+27)
#define EM_SETPASSWORDCHAR      (WM_USER+28)
#define EM_EMPTYUNDOBUFFER      (WM_USER+29)

#if (WINVER >= 0x030a)
#define EM_GETFIRSTVISIBLELINE  (WM_USER+30)
#define EM_SETREADONLY          (WM_USER+31)
#define EM_SETWORDBREAKPROC     (WM_USER+32)
#define EM_GETWORDBREAKPROC     (WM_USER+33)
#define EM_GETPASSWORDCHAR      (WM_USER+34)
#endif  /* WINVER >= 0x030a */
#define EM_LIMITTEXT            EM_SETLIMITTEXT

#endif  /* NOWINMESSAGES */

#if (WINVER >= 0x030a)
typedef int   (CALLBACK* EDITWORDBREAKPROC)(LPSTR lpch, int ichCurrent, int cch, int code);

/* EDITWORDBREAKPROC code values */
#define WB_LEFT                 0
#define WB_RIGHT                1
#define WB_ISDELIMITER          2
#endif  /* WINVER >= 0x030a */

/* Edit control notification codes */
#define EN_SETFOCUS             0x0100
#define EN_KILLFOCUS            0x0200
#define EN_CHANGE               0x0300
#define EN_UPDATE               0x0400
#define EN_ERRSPACE             0x0500
#define EN_MAXTEXT              0x0501
#define EN_HSCROLL              0x0601
#define EN_VSCROLL              0x0602

#if (WINVER >= 0x0400)
#define  EN_ALIGN_LTR      (0x700)
#define  EN_ALIGN_RTL      (0x701)
#endif
#endif  /* NOCTLMGR */

/****** Scroll bar control *************************************************/
/* Also see scrolling support */

#ifndef NOCTLMGR

#ifndef NOWINSTYLES

/* Scroll bar styles */
#define SBS_HORZ                0x0000L /* Type of scrollbar */
#define SBS_VERT                0x0001L /* Type of scrollbar */
#define SBS_TOPALIGN            0x0002L
#define SBS_LEFTALIGN           0x0002L
#define SBS_BOTTOMALIGN         0x0004L
#define SBS_RIGHTALIGN          0x0004L
#define SBS_SIZEBOXTOPLEFTALIGN 0x0002L
#define SBS_SIZEBOXBOTTOMRIGHTALIGN 0x0004L
#define SBS_SIZEBOX             0x0008L /* Type of scrollbar */
#define SBS_SIZEGRIP            0x0010L /* Type of scrollbar */

#endif  /* NOWINSTYLES */

#endif  /* NOCTLMGR */

/****** Listbox control ****************************************************/

#ifndef NOCTLMGR

/* Listbox styles */
#ifndef NOWINSTYLES
#define LBS_NOTIFY              0x0001L
#define LBS_SORT                0x0002L
#define LBS_NOREDRAW            0x0004L
#define LBS_MULTIPLESEL         0x0008L
#define LBS_OWNERDRAWFIXED      0x0010L
#define LBS_OWNERDRAWVARIABLE   0x0020L
#define LBS_HASSTRINGS          0x0040L
#define LBS_USETABSTOPS         0x0080L
#define LBS_NOINTEGRALHEIGHT    0x0100L
#define LBS_MULTICOLUMN         0x0200L
#define LBS_WANTKEYBOARDINPUT   0x0400L
#define LBS_EXTENDEDSEL         0x0800L
#if (WINVER >= 0x030a)
#define LBS_DISABLENOSCROLL     0x1000L
#define LBS_NODATA              0x2000L
#if (WINVER >= 0x0400)
#define LBS_NOSEL               0x4000L
#endif  /* WINVER >= 0x0400 */
#endif  /* WINVER >= 0x030a */
#define LBS_STANDARD            (LBS_NOTIFY | LBS_SORT | WS_VSCROLL | WS_BORDER)
#endif  /* NOWINSTYLES */

/* Listbox messages */
#ifndef NOWINMESSAGES
#define LB_ADDSTRING            (WM_USER+1)
#define LB_INSERTSTRING         (WM_USER+2)
#define LB_DELETESTRING         (WM_USER+3)
#define LB_RESETCONTENT         (WM_USER+5)
#define LB_SETSEL               (WM_USER+6)
#define LB_SETCURSEL            (WM_USER+7)
#define LB_GETSEL               (WM_USER+8)
#define LB_GETCURSEL            (WM_USER+9)
#define LB_GETTEXT              (WM_USER+10)
#define LB_GETTEXTLEN           (WM_USER+11)
#define LB_GETCOUNT             (WM_USER+12)
#define LB_SELECTSTRING         (WM_USER+13)
#define LB_DIR                  (WM_USER+14)
#define LB_GETTOPINDEX          (WM_USER+15)
#define LB_FINDSTRING           (WM_USER+16)
#define LB_GETSELCOUNT          (WM_USER+17)
#define LB_GETSELITEMS          (WM_USER+18)
#define LB_SETTABSTOPS          (WM_USER+19)
#define LB_GETHORIZONTALEXTENT  (WM_USER+20)
#define LB_SETHORIZONTALEXTENT  (WM_USER+21)
#define LB_SETCOLUMNWIDTH       (WM_USER+22)
#define LB_SETTOPINDEX          (WM_USER+24)
#define LB_GETITEMRECT          (WM_USER+25)
#define LB_GETITEMDATA          (WM_USER+26)
#define LB_SETITEMDATA          (WM_USER+27)
#define LB_SELITEMRANGE         (WM_USER+28)
#define LB_SETANCHORINDEX       (WM_USER+29)
#define LB_GETANCHORINDEX       (WM_USER+30)
#define LB_SETCARETINDEX        (WM_USER+31)
#define LB_GETCARETINDEX        (WM_USER+32)

#if (WINVER >= 0x030a)
#define LB_SETITEMHEIGHT        (WM_USER+33)
#define LB_GETITEMHEIGHT        (WM_USER+34)
#define LB_FINDSTRINGEXACT      (WM_USER+35)
#endif  /* WINVER >= 0x030a */

#endif  /* NOWINMESSAGES */

/* Listbox notification codes */
#define LBN_ERRSPACE            (-2)
#define LBN_SELCHANGE           1
#define LBN_DBLCLK              2
#define LBN_SELCANCEL           3
#define LBN_SETFOCUS            4
#define LBN_KILLFOCUS           5

/* Listbox message return values */
#define LB_OKAY                 0
#define LB_ERR                  (-1)
#define LB_ERRSPACE             (-2)

#define LB_CTLCODE              0L

/****** Dialog directory support ********************************************/

int     WINAPI DlgDirList(HWND, LPSTR, int, int, UINT);
BOOL    WINAPI DlgDirSelect(HWND, LPSTR, int);

int     WINAPI DlgDirListComboBox(HWND, LPSTR, int, int, UINT);
BOOL    WINAPI DlgDirSelectComboBox(HWND, LPSTR, int);

#if (WINVER >= 0x030a)
BOOL    WINAPI DlgDirSelectEx(HWND, LPSTR, int, int);
BOOL    WINAPI DlgDirSelectComboBoxEx(HWND, LPSTR, int, int);
#endif  /* WINVER >= 0x030a */

/* DlgDirList, DlgDirListComboBox flags values */
#define DDL_READWRITE           0x0000
#define DDL_READONLY            0x0001
#define DDL_HIDDEN              0x0002
#define DDL_SYSTEM              0x0004
#define DDL_DIRECTORY           0x0010
#define DDL_ARCHIVE             0x0020

#define DDL_POSTMSGS            0x2000
#define DDL_DRIVES              0x4000
#define DDL_EXCLUSIVE           0x8000

#endif  /* NOCTLMGR */

/****** Combo box control **************************************************/

#ifndef NOCTLMGR

/* Combo box styles */
#ifndef NOWINSTYLES
#define CBS_SIMPLE              0x0001L
#define CBS_DROPDOWN            0x0002L
#define CBS_DROPDOWNLIST        0x0003L
#define CBS_OWNERDRAWFIXED      0x0010L
#define CBS_OWNERDRAWVARIABLE   0x0020L
#define CBS_AUTOHSCROLL         0x0040L
#define CBS_OEMCONVERT          0x0080L
#define CBS_SORT                0x0100L
#define CBS_HASSTRINGS          0x0200L
#define CBS_NOINTEGRALHEIGHT    0x0400L
#if (WINVER >= 0x030a)
#define CBS_DISABLENOSCROLL     0x0800L
#endif  /* WINVER >= 0x030a */
#endif  /* NOWINSTYLES */

/* Combo box messages */
#ifndef NOWINMESSAGES
#define CB_GETEDITSEL           (WM_USER+0)
#define CB_LIMITTEXT            (WM_USER+1)
#define CB_SETEDITSEL           (WM_USER+2)
#define CB_ADDSTRING            (WM_USER+3)
#define CB_DELETESTRING         (WM_USER+4)
#define CB_DIR                  (WM_USER+5)
#define CB_GETCOUNT             (WM_USER+6)
#define CB_GETCURSEL            (WM_USER+7)
#define CB_GETLBTEXT            (WM_USER+8)
#define CB_GETLBTEXTLEN         (WM_USER+9)
#define CB_INSERTSTRING         (WM_USER+10)
#define CB_RESETCONTENT         (WM_USER+11)
#define CB_FINDSTRING           (WM_USER+12)
#define CB_SELECTSTRING         (WM_USER+13)
#define CB_SETCURSEL            (WM_USER+14)
#define CB_SHOWDROPDOWN         (WM_USER+15)
#define CB_GETITEMDATA          (WM_USER+16)
#define CB_SETITEMDATA          (WM_USER+17)
#if (WINVER >= 0x030a)
#define CB_GETDROPPEDCONTROLRECT (WM_USER+18)
#define CB_SETITEMHEIGHT        (WM_USER+19)
#define CB_GETITEMHEIGHT        (WM_USER+20)
#define CB_SETEXTENDEDUI        (WM_USER+21)
#define CB_GETEXTENDEDUI        (WM_USER+22)
#define CB_GETDROPPEDSTATE      (WM_USER+23)
#define CB_FINDSTRINGEXACT      (WM_USER+24)
#endif  /* WINVER >= 0x030a */

#endif  /* NOWINMESSAGES */

/* Combo box notification codes */
#define CBN_ERRSPACE            (-1)
#define CBN_SELCHANGE           1
#define CBN_DBLCLK              2
#define CBN_SETFOCUS            3
#define CBN_KILLFOCUS           4
#define CBN_EDITCHANGE          5
#define CBN_EDITUPDATE          6
#define CBN_DROPDOWN            7
#if (WINVER >= 0x030a)
#define CBN_CLOSEUP             8
#define CBN_SELENDOK            9
#define CBN_SELENDCANCEL        10
#endif  /* WINVER >= 0x030a */

/* Combo box message return values */
#define CB_OKAY                 0
#define CB_ERR                  (-1)
#define CB_ERRSPACE             (-2)

#endif /* NOCTLMGR */

/******* Windows hook support **********************************************/

#ifndef NOWH

DECLARE_HANDLE32(HHOOK);

#ifdef STRICT
typedef LRESULT (CALLBACK* HOOKPROC)(int code, WPARAM wParam, LPARAM lParam);
#else
typedef FARPROC HOOKPROC;
#endif

#ifdef STRICT
HHOOK   WINAPI SetWindowsHook(int, HOOKPROC);
LRESULT WINAPI DefHookProc(int, WPARAM, LPARAM, HHOOK FAR*);
#else
HOOKPROC WINAPI SetWindowsHook(int, HOOKPROC);
LRESULT WINAPI DefHookProc(int, WPARAM, LPARAM, HOOKPROC FAR*);
#endif
BOOL    WINAPI UnhookWindowsHook(int, HOOKPROC);

#if (WINVER >= 0x030a)

HHOOK   WINAPI SetWindowsHookEx(int idHook, HOOKPROC lpfn, HINSTANCE hInstance, HTASK hTask);
BOOL    WINAPI UnhookWindowsHookEx(HHOOK hHook);
LRESULT WINAPI CallNextHookEx(HHOOK hHook, int code, WPARAM wParam, LPARAM lParam);

#endif  /* WINVER >= 0x030a */

/* Standard hook code */
#define HC_ACTION               0

/* Obsolete hook codes (NO LONGER SUPPORTED) */
#define HC_GETLPLPFN            (-3)
#define HC_LPLPFNNEXT           (-2)
#define HC_LPFNNEXT             (-1)

#endif /* NOWH */

/****** Computer-based-training (CBT) support *******************************/

#ifndef NOWH

/* SetWindowsHook() code */
#define WH_CBT              5

#define HCBT_MOVESIZE        0
#define HCBT_MINMAX          1
#define HCBT_QS              2
#define HCBT_CREATEWND       3
#define HCBT_DESTROYWND      4
#define HCBT_ACTIVATE        5
#define HCBT_CLICKSKIPPED    6
#define HCBT_KEYSKIPPED      7
#define HCBT_SYSCOMMAND      8
#define HCBT_SETFOCUS        9
#define HCBT_SETWINDOWTEXT  10

#if (WINVER >= 0x030a)
/* HCBT_CREATEWND parameters pointed to by lParam */
typedef struct tagCBT_CREATEWND
{
    LPCREATESTRUCT lpcs;
    HWND    hwndInsertAfter;
} CBT_CREATEWND;
typedef CBT_CREATEWND FAR* LPCBT_CREATEWND;

/* HCBT_ACTIVATE structure pointed to by lParam */
typedef struct tagCBTACTIVATESTRUCT
{
    BOOL    fMouse;
    HWND    hWndActive;
} CBTACTIVATESTRUCT;

#endif  /* WINVER >= 0x030a */
#endif /* NOWH */

/****** Hardware hook support ***********************************************/

#ifndef NOWH
#if (WINVER >= 0x030a)
#define WH_HARDWARE         8

typedef struct tagHARDWAREHOOKSTRUCT
{
    HWND    hWnd;
    UINT    wMessage;
    WPARAM  wParam;
    LPARAM  lParam;
} HARDWAREHOOKSTRUCT;
#endif  /* WINVER >= 0x030a */
#endif  /* NOWH */

/****** Shell support *******************************************************/

#ifndef NOWH
#if (WINVER >= 0x030a)
/* SetWindowsHook() Shell hook code */
#define WH_SHELL           10

#define HSHELL_WINDOWCREATED       1
#define HSHELL_WINDOWDESTROYED     2
#define HSHELL_ACTIVATESHELLWINDOW 3
#if (WINVER >= 0x0400)
#define HSHELL_WINDOWACTIVATED     4
#define HSHELL_GETMINRECT          5
#define HSHELL_REDRAW              6
#define HSHELL_TASKMAN             7
#define HSHELL_LANGUAGE            8 
#endif  /* WINVER >= 0x0400 */
#endif  /* WINVER >= 0x030a */
#endif  /* NOWH */

/****** Journalling support *************************************************/

#ifndef NOWH
#define WH_JOURNALRECORD    0
#define WH_JOURNALPLAYBACK  1

/* Journalling hook codes */
#define HC_GETNEXT          1
#define HC_SKIP             2
#define HC_NOREMOVE         3
#define HC_NOREM            HC_NOREMOVE
#define HC_SYSMODALON       4
#define HC_SYSMODALOFF      5

/* Journalling message structure */
typedef struct tagEVENTMSG
{
    UINT    message;
    UINT    paramL;
    UINT    paramH;
    DWORD   time;
} EVENTMSG;
typedef EVENTMSG *PEVENTMSG;
typedef EVENTMSG NEAR* NPEVENTMSG;
typedef EVENTMSG FAR* LPEVENTMSG;

BOOL    WINAPI EnableHardwareInput(BOOL);

#endif /* NOWH */

/****** Debugger support ****************************************************/

#if (WINVER >= 0x030a)
/* SetWindowsHook debug hook support */
#define WH_DEBUG        9

typedef struct tagDEBUGHOOKINFO
{
    HMODULE     hModuleHook;
    LPARAM      reserved;
    LPARAM      lParam;
    WPARAM      wParam;
    int         code;
} DEBUGHOOKINFO;
typedef DEBUGHOOKINFO FAR* LPDEBUGHOOKINFO;

#ifndef NOMSG
BOOL WINAPI QuerySendMessage(HANDLE h1, HANDLE h2, HANDLE h3, LPMSG lpmsg);
#endif  /* NOMSG */

BOOL WINAPI LockInput(HANDLE h1, HWND hwndInput, BOOL fLock);

LONG WINAPI GetSystemDebugState(void);
/* Flags returned by GetSystemDebugState.
 */
#define SDS_MENU        0x0001
#define SDS_SYSMODAL    0x0002
#define SDS_NOTASKQUEUE 0x0004
#define SDS_DIALOG      0x0008
#define SDS_TASKLOCKED  0x0010
#endif  /* WINVER >= 0x030a */

/****** Help support ********************************************************/

#ifndef NOHELP

BOOL WINAPI WinHelp(HWND hwndMain, LPCSTR lpszHelp, UINT usCommand, DWORD ulData);

/* WinHelp() commands */
#define HELP_CONTEXT        0x0001
#define HELP_QUIT           0x0002
#define HELP_INDEX          0x0003
#define HELP_CONTENTS       0x0003
#define HELP_HELPONHELP     0x0004
#define HELP_SETINDEX       0x0005
#define HELP_SETCONTENTS    0x0005
#define HELP_CONTEXTPOPUP   0x0008
#define HELP_FORCEFILE      0x0009
#define HELP_KEY            0x0101
#define HELP_COMMAND        0x0102
#define HELP_PARTIALKEY     0x0105
#define HELP_MULTIKEY       0x0201
#define HELP_SETWINPOS      0x0203

#if (WINVER >= 0x0400)

#define HELP_CONTEXTMENU    0x000a
#define HELP_FINDER         0x000b
#define HELP_WM_HELP        0x000c
#define HELP_SETPOPUP_POS   0x000d

#define HELP_TCARD          0x8000
#define HELP_TCARD_DATA     0x0010
#define HELP_TCARD_NEXT     0x0011
#define HELP_TCARD_OTHER_CALLER 0x0011

#endif  /* WINVER >= 0x0400 */

typedef struct tagMULTIKEYHELP
{
    UINT    mkSize;
    BYTE    mkKeylist;
    BYTE    szKeyphrase[1];
} MULTIKEYHELP;

typedef struct
{
    int  wStructSize;
    int  x;
    int  y;
    int  dx;
    int  dy;
    int  wMax;
    char rgchMember[2];
} HELPWININFO;
typedef HELPWININFO NEAR* PHELPWININFO;
typedef HELPWININFO FAR* LPHELPWININFO;

#endif  /* NOHELP */

#if (WINVER >= 0x0400)
#define HELPINFO_WINDOW    0x0001
#define HELPINFO_MENUITEM  0x0002
typedef  struct  tagHELPINFO
{
    DWORD   cbSize;
    int     iContextType;
    int     iCtrlId;
    HANDLE  hItemHandle;
    DWORD   dwContextId;
    POINT   MousePos;
}
HELPINFO, FAR* LPHELPINFO;
#endif /* WINVER >= 0x0400 */

/****** Message Box support *************************************************/

#ifndef NOMB

int     WINAPI MessageBox(HWND, LPCSTR, LPCSTR, UINT);
void    WINAPI MessageBeep(UINT);

#define MB_OK               0x0000
#define MB_OKCANCEL         0x0001
#define MB_ABORTRETRYIGNORE 0x0002
#define MB_YESNOCANCEL      0x0003
#define MB_YESNO            0x0004
#define MB_RETRYCANCEL      0x0005
#define MB_TYPEMASK         0x000F

#define MB_ICONERROR        0x0010      /* ;win40: Name changed from MB_ICONHAND */
#define MB_ICONQUESTION     0x0020
#define MB_ICONWARNING      0x0030      /* ;win40: Name changed from MB_ICONEXCLAMATION */
#define MB_ICONINFORMATION  0x0040      /* ;win40: Name changed from MB_ICONASTERISK */
#define MB_ICONMASK         0x00F0

#define MB_ICONHAND         MB_ICONERROR
#define MB_ICONSTOP         MB_ICONERROR
#define MB_ICONEXCLAMATION  MB_ICONWARNING
#define MB_ICONASTERISK     MB_ICONINFORMATION

#define MB_DEFBUTTON1       0x0000
#define MB_DEFBUTTON2       0x0100
#define MB_DEFBUTTON3       0x0200
#if (WINVER >= 0x0400)
#define MB_DEFBUTTON4       0x0300
#endif
#define MB_DEFMASK          0x0F00

#define MB_APPLMODAL        0x0000
#define MB_SYSTEMMODAL      0x1000
#define MB_TASKMODAL        0x2000
#define MB_RIGHT			0x00080000
#define MB_RTLREADING		0x00100000
#define MB_NOFOCUS          0x8000
#endif  /* NOMB */

/****** Sound support ******************************************************/

#ifndef NOSOUND

int     WINAPI OpenSound(void);
void    WINAPI CloseSound(void);

int     WINAPI StartSound(void);
int     WINAPI StopSound(void);

int     WINAPI SetVoiceQueueSize(int, int);
int     WINAPI SetVoiceNote(int, int, int, int);
int     WINAPI SetVoiceAccent(int, int, int, int, int);
int     WINAPI SetVoiceEnvelope(int, int, int);
int     WINAPI SetVoiceSound(int, DWORD, int);

int     WINAPI SetVoiceThreshold(int, int);
LPINT   WINAPI GetThresholdEvent(void);
int     WINAPI GetThresholdStatus(void);

int     WINAPI SetSoundNoise(int, int);

/* SetSoundNoise() Sources */
#define S_PERIOD512     0
#define S_PERIOD1024    1
#define S_PERIOD2048    2
#define S_PERIODVOICE   3
#define S_WHITE512      4
#define S_WHITE1024     5
#define S_WHITE2048     6
#define S_WHITEVOICE    7

int     WINAPI WaitSoundState(int);

/* WaitSoundState() constants */
#define S_QUEUEEMPTY    0
#define S_THRESHOLD     1
#define S_ALLTHRESHOLD  2

int     WINAPI SyncAllVoices(void);
int     WINAPI CountVoiceNotes(int);

/* Accent Modes */
#define S_NORMAL        0
#define S_LEGATO        1
#define S_STACCATO      2

/* Error return values */
#define S_SERDVNA       (-1)
#define S_SEROFM        (-2)
#define S_SERMACT       (-3)
#define S_SERQFUL       (-4)
#define S_SERBDNT       (-5)
#define S_SERDLN        (-6)
#define S_SERDCC        (-7)
#define S_SERDTP        (-8)
#define S_SERDVL        (-9)
#define S_SERDMD        (-10)
#define S_SERDSH        (-11)
#define S_SERDPT        (-12)
#define S_SERDFQ        (-13)
#define S_SERDDR        (-14)
#define S_SERDSR        (-15)
#define S_SERDST        (-16)

#endif  /* NOSOUND */

/****** Comm support ******************************************************/

#ifndef NOCOMM

#define NOPARITY        0
#define ODDPARITY       1
#define EVENPARITY      2
#define MARKPARITY      3
#define SPACEPARITY     4

#define ONESTOPBIT      0
#define ONE5STOPBITS    1
#define TWOSTOPBITS     2

#define IGNORE          0
#define INFINITE        0xFFFF

/* Error Flags */
#define CE_RXOVER       0x0001
#define CE_OVERRUN      0x0002
#define CE_RXPARITY     0x0004
#define CE_FRAME        0x0008
#define CE_BREAK        0x0010
#define CE_CTSTO        0x0020
#define CE_DSRTO        0x0040
#define CE_RLSDTO       0x0080
#define CE_TXFULL       0x0100
#define CE_PTO          0x0200
#define CE_IOE          0x0400
#define CE_DNS          0x0800
#define CE_OOP          0x1000
#define CE_MODE         0x8000

#define IE_BADID        (-1)
#define IE_OPEN         (-2)
#define IE_NOPEN        (-3)
#define IE_MEMORY       (-4)
#define IE_DEFAULT      (-5)
#define IE_HARDWARE     (-10)
#define IE_BYTESIZE     (-11)
#define IE_BAUDRATE     (-12)

/* Events */
#define EV_RXCHAR       0x0001
#define EV_RXFLAG       0x0002
#define EV_TXEMPTY      0x0004
#define EV_CTS          0x0008
#define EV_DSR          0x0010
#define EV_RLSD         0x0020
#define EV_BREAK        0x0040
#define EV_ERR          0x0080
#define EV_RING         0x0100
#define EV_PERR         0x0200
#define EV_CTSS         0x0400
#define EV_DSRS         0x0800
#define EV_RLSDS        0x1000
#define EV_RingTe       0x2000
#define EV_RINGTE       EV_RingTe

/* Escape Functions */
#define SETXOFF         1
#define SETXON          2
#define SETRTS          3
#define CLRRTS          4
#define SETDTR          5
#define CLRDTR          6
#define RESETDEV        7

#define LPTx            0x80

#if (WINVER >= 0x030a)

/* new escape functions */
#define GETMAXLPT       8
#define GETMAXCOM       9
#define GETBASEIRQ      10

/* Comm Baud Rate indices */
#define CBR_110         0xFF10
#define CBR_300         0xFF11
#define CBR_600         0xFF12
#define CBR_1200        0xFF13
#define CBR_2400        0xFF14
#define CBR_4800        0xFF15
#define CBR_9600        0xFF16
#define CBR_14400       0xFF17
#define CBR_19200       0xFF18
#define CBR_38400       0xFF1B
#define CBR_56000       0xFF1F
#define CBR_128000      0xFF23
#define CBR_256000      0xFF27

/* notifications passed in low word of lParam on WM_COMMNOTIFY messages */
#define CN_RECEIVE      0x0001
#define CN_TRANSMIT     0x0002
#define CN_EVENT        0x0004

#endif  /* WINVER >= 0x030a */

typedef struct tagDCB
{
    BYTE Id;
    UINT BaudRate;
    BYTE ByteSize;
    BYTE Parity;
    BYTE StopBits;
    UINT RlsTimeout;
    UINT CtsTimeout;
    UINT DsrTimeout;

    UINT fBinary        :1;
    UINT fRtsDisable    :1;
    UINT fParity        :1;
    UINT fOutxCtsFlow   :1;
    UINT fOutxDsrFlow   :1;
    UINT fDummy         :2;
    UINT fDtrDisable    :1;

    UINT fOutX          :1;
    UINT fInX           :1;
    UINT fPeChar        :1;
    UINT fNull          :1;
    UINT fChEvt         :1;
    UINT fDtrflow       :1;
    UINT fRtsflow       :1;
    UINT fDummy2        :1;

    char XonChar;
    char XoffChar;
    UINT XonLim;
    UINT XoffLim;
    char PeChar;
    char EofChar;
    char EvtChar;
    UINT TxDelay;
} DCB;
typedef DCB FAR* LPDCB;

#if (defined(STRICT) | (WINVER >= 0x030a))

typedef struct tagCOMSTAT
{
    BYTE status;
    UINT cbInQue;
    UINT cbOutQue;
} COMSTAT;

#define CSTF_CTSHOLD    0x01
#define CSTF_DSRHOLD    0x02
#define CSTF_RLSDHOLD   0x04
#define CSTF_XOFFHOLD   0x08
#define CSTF_XOFFSENT   0x10
#define CSTF_EOF        0x20
#define CSTF_TXIM       0x40

#else   /* (STRICT | WINVER >= 0x030a) */

/* NOTE: This structure declaration is not ANSI compatible! */
typedef struct tagCOMSTAT
{
    BYTE fCtsHold  :1;
    BYTE fDsrHold  :1;
    BYTE fRlsdHold :1;
    BYTE fXoffHold :1;
    BYTE fXoffSent :1;
    BYTE fEof      :1;
    BYTE fTxim     :1;
    UINT cbInQue;
    UINT cbOutQue;
} COMSTAT;

#endif  /* !(STRICT | WINVER >= 0x030a */

int     WINAPI BuildCommDCB(LPCSTR, DCB FAR*);

int     WINAPI OpenComm(LPCSTR, UINT, UINT);
int     WINAPI CloseComm(int);

int     WINAPI ReadComm(int, void FAR*, int);
int     WINAPI WriteComm(int, const void FAR*, int);
int     WINAPI UngetCommChar(int, char);
int     WINAPI FlushComm(int, int);
int     WINAPI TransmitCommChar(int, char);

int     WINAPI SetCommState(const DCB FAR*);
int     WINAPI GetCommState(int, DCB FAR*);
int     WINAPI GetCommError(int, COMSTAT FAR* );

int     WINAPI SetCommBreak(int);
int     WINAPI ClearCommBreak(int);

UINT FAR* WINAPI SetCommEventMask(int, UINT);
UINT    WINAPI GetCommEventMask(int, int);

LONG    WINAPI EscapeCommFunction(int, int);

#if (WINVER >= 0x030a)
BOOL    WINAPI EnableCommNotification(int, HWND, int, int);

#endif  /* WINVER >= 0x030a */

#endif  /* NOCOMM */

/****** String formatting support *******************************************/

int     WINAPI wvsprintf(LPSTR lpszOut, LPCSTR lpszFmt, const void FAR* lpParams);

int FAR CDECL wsprintf(LPSTR lpszOut, LPCSTR lpszFmt, ...);

/****** Driver support ******************************************************/

#if (WINVER >= 0x030a)

#ifndef NODRIVERS

DECLARE_HANDLE(HDRVR);

typedef LRESULT (CALLBACK* DRIVERPROC)(DWORD, HDRVR, UINT, LPARAM, LPARAM);

/* Driver messages */
#define DRV_LOAD            0x0001
#define DRV_ENABLE          0x0002
#define DRV_OPEN            0x0003
#define DRV_CLOSE           0x0004
#define DRV_DISABLE         0x0005
#define DRV_FREE            0x0006
#define DRV_CONFIGURE       0x0007
#define DRV_QUERYCONFIGURE  0x0008
#define DRV_INSTALL         0x0009
#define DRV_REMOVE          0x000A
#define DRV_EXITSESSION     0x000B
#define DRV_EXITAPPLICATION 0x000C
#define DRV_POWER           0x000F
#define DRV_NOTIFYMSG	      0x0010
/*#define DRV_QUERYENDSESSION 0x0010      */
/*#define DRV_EXITSESSIONCANCELLED 0x0011 */

#define DRV_RESERVED        0x0800
#define DRV_USER            0x4000

/* LPARAM of DRV_CONFIGURE message */
typedef struct tagDRVCONFIGINFO
{
    DWORD   dwDCISize;
    LPCSTR  lpszDCISectionName;
    LPCSTR  lpszDCIAliasName;
} DRVCONFIGINFO;
typedef DRVCONFIGINFO NEAR* PDRVCONFIGINFO;
typedef DRVCONFIGINFO FAR* LPDRVCONFIGINFO;

/* Supported return values for DRV_CONFIGURE message */
#define DRVCNF_CANCEL       0x0000
#define DRVCNF_OK           0x0001
#define DRVCNF_RESTART      0x0002

/* Supported lParam1 of DRV_EXITAPPLICATION notification */
#define DRVEA_NORMALEXIT    0x0001
#define DRVEA_ABNORMALEXIT  0x0002

LRESULT WINAPI DefDriverProc(DWORD dwDriverIdentifier, HDRVR driverID, UINT message, LPARAM lParam1, LPARAM lParam2);

HDRVR   WINAPI OpenDriver(LPCSTR szDriverName, LPCSTR szSectionName, LPARAM lParam2);
LRESULT WINAPI CloseDriver(HDRVR hDriver, LPARAM lParam1, LPARAM lParam2);

LRESULT WINAPI SendDriverMessage(HDRVR hDriver, UINT message, LPARAM lParam1, LPARAM lParam2);

HINSTANCE WINAPI GetDriverModuleHandle(HDRVR hDriver);

HDRVR   WINAPI GetNextDriver(HDRVR, DWORD);

/* GetNextDriver flags */
#define GND_FIRSTINSTANCEONLY   0x00000001

#define GND_FORWARD             0x00000000
#define GND_REVERSE             0x00000002

typedef struct tagDRIVERINFOSTRUCT
{
    UINT    length;
    HDRVR   hDriver;
    HINSTANCE hModule;
    char    szAliasName[128];
} DRIVERINFOSTRUCT;
typedef DRIVERINFOSTRUCT FAR* LPDRIVERINFOSTRUCT;

BOOL    WINAPI GetDriverInfo(HDRVR, DRIVERINFOSTRUCT FAR*);

#endif  /* !NODRIVERS */
#endif  /* WINVER >= 0x030a */

/****** Installable Message Thunk support ***********************************/

#if (WINVER > 0x030a)
#ifndef NOIMT

/* wReason codes */
#define IMT_REASON_ASYNC    0x00001
#define IMT_REASON_LS       0x00002
#define IMT_REASON_AFTER    0x00004

typedef struct tagIMTMSG
{
    HWND    hwnd;
    UINT    message;
    DWORD   wParam;
    LPARAM  lParam;
} IMTMSG, FAR* LPIMTMSG;

typedef struct tagIMTBUFFER
{
    DWORD   dwT1;
    DWORD   dwT2;
} IMTBUFFER, FAR* LPIMTBUFFER;

typedef BOOL (CALLBACK *IMTDISP)(WORD wReason, LPDWORD lpRetVal,
                                 LPIMTMSG lpMsg, LPIMTBUFFER lpBuffer);
BOOL WINAPI InstallIMT(LPSTR lpszClassName, IMTDISP pfnDispatcher,
                       WORD msgLo, WORD msgHi);
BOOL WINAPI UnInstallIMT(LPSTR lpszClassName, IMTDISP pfnDispatcher,
                         WORD msgLo, WORD msgHi);

#endif  /* !NOIMT */
#endif  /* WINVER > 0x030a */

#endif  /* NOUSER */

DWORD WINAPI RegisterServiceProcess(DWORD dwProcessId, DWORD dwServiceType);
#define RSP_UNREGISTER_SERVICE	0x00000000
#define RSP_SIMPLE_SERVICE	0x00000001

VOID WINAPI RegisterNetworkCapabilities(DWORD dwBitsToSet, DWORD dwValues);
#define RNC_NETWORKS  		0x00000001

#ifndef RC_INVOKED
#pragma pack()          /* Revert to default packing */
#endif  /* RC_INVOKED */

#ifdef __cplusplus
}                       /* End of extern "C" { */
#endif /* __cplusplus */

#endif  /* _INC_WINDOWS */
=== C:/Users/treeman/Desktop/windows nt source code\Source\Win2K3\NT\printscan\faxsrv\print\faxprint\faxdrv\win9x\ddk\printer\inc\minidriv.h ===
/****************************************************************************
*                                                                           *
* THIS CODE AND INFORMATION IS PROVIDED "AS IS" WITHOUT WARRANTY OF ANY     *
* KIND, EITHER EXPRESSED OR IMPLIED, INCLUDING BUT NOT LIMITED TO THE       *
* IMPLIED WARRANTIES OF MERCHANTABILITY AND/OR FITNESS FOR A PARTICULAR     *
* PURPOSE.                                                                  *
*                                                                           *
* Copyright (C) 1993-95  Microsoft Corporation.  All Rights Reserved.       *
*                                                                           *
****************************************************************************/

//-----------------------------------------------------------------------------
// Filename:    minidriv.h
//
// This file contains definitions for tables contained in the resource file
// of the Mini Drivers. It should be shared by both UNITOOL and UNIDRV.
//
//-----------------------------------------------------------------------------

//-----------------------------------------------------------------------------
// Mindrvrc.h contains resource type values for minidrivers
//-----------------------------------------------------------------------------
#include <mindrvrc.h>

//*****************************************************************************
// DATAHDR is at the beginning of each Mini Driver, describes where the rest
// of the strcutures are, their size, count, etc.
//*****************************************************************************


typedef struct
{
  short sOffset;     // offset from the beginning of this resource
                     // to obtain a table entry
  short sLength;     // length of each element in the table
  short sCount;      // number of elements in the table.
} HEADERENTRY;

//-----------------------------------------------------------------------------
// index into array of header entry in DATAHDR
//-----------------------------------------------------------------------------

#define HE_MODELDATA        0
#define HE_RESOLUTION       1
#define HE_PAPERSIZE        2
#define HE_PAPERQUALITY     3
#define HE_PAPERSOURCE      4
#define HE_PAPERDEST        5
#define HE_TEXTQUAL         6
#define HE_COMPRESSION      7
#define HE_FONTCART         8
#define HE_PAGECONTROL      9
#define HE_CURSORMOVE      10
#define HE_FONTSIM         11
#define HE_DEVCOLOR        12
#define HE_RECTFILL        13
#define HE_DOWNLOADINFO    14
#define HE_VECTPAGE        15
#define HE_CAROUSEL        16
#define HE_PENINFO         17
#define HE_LINEINFO        18
#define HE_BRUSHINFO       19
#define HE_VECTOUTPUT      20
#define HE_POLYVECTOUTPUT  21
#define HE_VECTSUPPORT     22
#define HE_IMAGECONTROL    23
#define HE_PRINTDENSITY    24
#define HE_COLORTRC	   25
#define HE_RESERVED1	   26
#define HE_RESERVED2	   27
#define HE_RESERVED3	   28
#define HE_RESERVED4	   29
#define MAXHE              30

#define MAXHE_GPC2         15

typedef struct                    // size is 180 bytes
{
  short       sMagic;             // reserved, must be 0x7F00
  WORD        wVersion;           // GPC file version #
  POINT       ptMaster;           // Horizontal & Vertical Master Units
  DWORD       loHeap;             // offset from beginning of file to HEAP data
  DWORD       dwFileSize;         // size of file in bytes
  WORD        fTechnology;        // flags for special technologies
  WORD        fGeneral;           // misc flags
  char        rgchRes[10];        // 10 bytes reserved
  short       sMaxHE;             // header entry count
  HEADERENTRY rghe[MAXHE];
} DATAHDR, *PDH, far *LPDH;

#define GPC_VERSION3          0x0300    // GPC file version 3
#define GPC_VERSION2          0x0200    // GPC file version 2
#define GPC_VERSION           0x0300    // current GPC file version #

//-------------------------------------------
// fTechnology--used as an ID, not a bitfield
//-------------------------------------------
#define GPC_TECH_DEFAULT       0   // Default technology
#define GPC_TECH_PCL4          1   // Uses PCL level 4 or above
#define GPC_TECH_CAPSL         2   // Uses CaPSL level 3 or above
#define GPC_TECH_PPDS          3   // Uses PPDS
#define GPC_TECH_TTY           4   // TTY printer--user configurable
#define GPC_TECH_DBCS          5   // Uses DBCS PDL printer

//--------------------
// fGeneral
//--------------------
#define GPC_GEN_PRIVATE_HELP    0x0001    // this driver has a private help
                                          // file named <driver>.hlp
#define GPC_GEN_DRAFT_SINGLE    0x0002    // Only 1 font in draft mode

//-----------------------------------------------------------------------------
// OCD are offsets into the heap to obtain a CD structure
//-----------------------------------------------------------------------------

typedef WORD       OCD;
typedef OCD far *  LPOCD;       // far ptr to OCD
typedef DWORD      LOCD;        // double word offset to a CD
typedef WORD       OOCD;        // offset to table of OCD's.

//*****************************************************************************
//
// MODELDATA contains information describing the attributes and capabilities
// of a single printer model.
//
//*****************************************************************************

//-----------------------------------------------------------------------------
// MODELDATA.rgoi[] index values
//-----------------------------------------------------------------------------

#define MD_OI_FIRST           MD_OI_PORT_FONTS
#define MD_OI_PORT_FONTS                     0
#define MD_OI_LAND_FONTS                     1
#define MD_OI_RESOLUTION                     2
#define MD_OI_PAPERSIZE                      3
#define MD_OI_PAPERQUALITY                   4
#define MD_OI_PAPERSOURCE                    5
#define MD_OI_PAPERDEST                      6
#define MD_OI_TEXTQUAL                       7
#define MD_OI_COMPRESSION                    8
#define MD_OI_FONTCART                       9
#define MD_OI_COLOR                         10
#define MD_OI_MEMCONFIG                     11
#define MD_OI_MAX                           12

//
// MODELDATA.rgoi2[] index values
//

#define MD_OI2_PENINFO      0
#define MD_OI2_IMAGECONTROL 1
#define MD_OI2_PRINTDENSITY 2
#define MD_OI2_COLORTRC     3
#define MD_OI2_RESERVED1    4
#define MD_OI2_MAX          5

//-----------------------------------------------------------------------------
// MODELDATA.rgi[] index values
//-----------------------------------------------------------------------------

#define MD_I_PAGECONTROL      0
#define MD_I_CURSORMOVE       1
#define MD_I_FONTSIM          2
#define MD_I_RECTFILL         3
#define MD_I_DOWNLOADINFO     4
#define MD_I_VECTPAGE         5
#define MD_I_CAROUSEL         6
#define MD_I_LINEINFO         7
#define MD_I_BRUSHINFO        8
#define MD_I_VECTOUTPUT       9
#define MD_I_POLYVECTOUTPUT  10
#define MD_I_VECTSUPPORT     11
#define MD_I_RESERVED1       12
#define MD_I_RESERVED2       13
#define MD_I_RESERVED3       14
#define MD_I_RESERVED4       15
#define MD_I_MAX             16

// 9/20/93 ZhanW
// define some constants help uniform access of rgoi and rgoi2 arrays.
// When more indices are used in rgoi2 array, make sure to add new define's.
#define  MD_OI_OI2                 (MD_OI_MAX + MD_I_MAX)
#define  MD_OI_PENINFO             (MD_OI_OI2 + MD_OI2_PENINFO)
#define  MD_OI_IMAGECONTROL        (MD_OI_OI2 + MD_OI2_IMAGECONTROL)
#define  MD_OI_PRINTDENSITY        (MD_OI_OI2 + MD_OI2_PRINTDENSITY)
#define  MD_OI_COLORTRC            (MD_OI_OI2 + MD_OI2_COLORTRC)
#define  MD_OI_RESERVED            (MD_OI_OI2 + MD_OI2_RESERVED)
#define  MD_OI_TOTALMAX            (MD_OI_OI2 + MD_OI2_MAX)

typedef struct
{
  short cbSize;           // size of MODELDATA, 152 bytes
  short sIDS;             // stringtable ID for model name
  WORD  fGeneral;         // General printer capabilities
  WORD  fCurves;          // Curve Capabilities
  WORD  fLines;           // Line Capabilities
  WORD  fPolygonals;      // Polygonal Capabilities
  WORD  fText;            // Text Capabilities
  WORD  fClip;            // Clipping Capabilities
  WORD  fRaster;          // Raster Capabilities
  WORD  fLText;           // Text Capabilities in landscape mode
  short sLeftMargin;      // Unprintable minimum left margin.
  short sMaxPhysWidth;    // Maximum physical page width
  POINT ptMax;            // Maximum X & Y printable dimensions in master units
  POINT ptMin;            // Minimum X & Y page dimensions in master units
  short sDefaultFontID;   // Default font resource ID
  short sLookAhead;       // Size of Lookahead region
  short sMaxFontsPage;    // Max number of fonts printer can place on single page
                          // -1 if no limit
  short sCartSlots;       // Number of cartridge slots on printer
  short sDefaultCTT;
  short rgoi[MD_OI_MAX];  // list of offsets to index lists
  short rgi[MD_I_MAX];    // list of indices.

// The following fields are added in GPC 3.0
  short rgoi2[MD_OI2_MAX];// Orphans from rgoi (here due to compatibility)
  short orgoiDefaults;    // Offset to list of defaults for RGOI & RGOI2
  WORD  wReserved;        // Needed for alignment
  DWORD dwICMManufacturer; // id to match ICC profiles against
  DWORD dwICMModel;       // id to match ICC profiles against
  DWORD rgdwReserved[8];  // 32 bytes reserved for future use
} MODELDATA, *PMODELDATA, FAR * LPMODELDATA;


//-----------------------------------------------------------------------------
// MODELDATA.fGeneral flag values
//-----------------------------------------------------------------------------

#define MD_SERIAL             0x0001  // must output text serially such
                                      // as dotmatrix printers
//#define MD_PARAMETERIZE       0x0002  // supports parameterized escape codes
#define MD_RESERVED           0x0002  // MD_PARAMETERIZE is Never used 1/4/93
#define MD_ROTATE_FONT_ABLE   0x0004  // can rotate hardware fonts
#define MD_COPIES             0x0008  // supports multiple copies
#define MD_DUPLEX             0x0010  // supports duplexing
#define MD_NO_ADJACENT        0x0020  // old model, cannot print adjacent pins
#define MD_LANDSCAPE_GRX_ABLE 0x0040  // can rotate raster graphics
#define MD_ALIGN_BASELINE     0x0080  // text output are algned on the
                                      // baseline, not top of char
#define MD_FONT_MEMCFG        0x0100  // Mem ref'd @ rgoi[MD_OI_MEMCONFIG]
                                      // used for download fonts only.
#define MD_LANDSCAPE_RT90     0x0200  // landscape is portrait rotated
        // 90 degress counter-clockwise, i.e. the end of a page is printed
        // first. The default is 270 degrees, i.e. the beginning of a
        // page is printed first. !!!For printers which do not have the
        // set-orientation command (i.e. only have portrait mode), this
        // bit should NOT be set. UNIDRV will rotate the graphics and
        // the beginning of a page will come out first.

#define MD_USE_CURSOR_ORIG    0x0400  // use cursor origins in
        // PAPERSIZE to calculate the print origin. The default
        // cursor origin is the upper left corner of the printable area.
#define MD_WHITE_TEXT         0x0800  // can print white text on black
                                      // bkgrd. Cmds from DEVCOLOR struct.
#define MD_PCL_PAGEPROTECT    0x1000  // provide PCL5-style page protection
#define MD_MARGINS            0x2000  // allow the user to set paper
        // unprintable area. On some printers (such
        // as Epson, the user could manipulate the
        // printer to have different margins than
        // the default. Add this bit for Win3.0
        // driver compatibility.
#define MD_CMD_CALLBACK       0x4000  // Model requires fnOEMGetCmd callback
#define MD_MEMRES             0x8000  // User may reserve printer memory

//*****************************************************************************
//
// RESOLUTION contains information needed to compose bitmap images on the printer.
// There is one RESOLUTION structure defined for each supported printer resolution.
// RESOLUTION array should be arranged from the highest resolution to the lowest
// resolution. It is also the order that will be displayed in the dialog box.
// This strucuture becomes part of the physical device block.
//
//*****************************************************************************

//-----------------------------------------------------------------------------
// RESOLUTION.rgocd[] index values
//-----------------------------------------------------------------------------

#define RES_OCD_SELECTRES              0
#define RES_OCD_BEGINGRAPHICS          1
#define RES_OCD_ENDGRAPHICS            2
#define RES_OCD_SENDBLOCK              3
#define RES_OCD_ENDBLOCK               4
#define RES_OCD_MAX                    5

typedef struct
{
  short cbSize;             // size of RESOLUTION, 40 bytes
  short sIDS;               // String ID for displaying resolution
  WORD  fDump;              // Dump method flags.
  WORD  fBlockOut;          // Block out method flags.
  WORD  fCursor;            // Cursor position flags.
  short iDitherBrush;       // selected brush for dithering
  POINT ptTextScale;        // relationship between master units and text units.
  POINT ptScaleFac;         // relationship between graphics and text
                            // scale factors. expressed in powers of 2.
  short sNPins;             // Minimum height of the image to be rendered
                            // together.
  short sPinsPerPass;       // Physical number of pins fired in one pass.
  short sTextYOffset;       // offset from top of graphics output that of text
                            // output
  short sMinBlankSkip;      // Min. # of bytes of null data that must occur before
                            // compression (strip null data only) will occur
  short sSpotDiameter;      // size of dot at this resolution
  OCD   rgocd[RES_OCD_MAX];
} RESOLUTION, *PRESOLUTION, FAR * LPRESOLUTION;

//-----------------------------------------------------------------------------
// RESOLUTION.fDump values (low byte: graphics-specific; high byte: general)
//-----------------------------------------------------------------------------

#define RES_DM_GDI             0x0040    // GDI bitmap format
#define RES_DM_LEFT_BOUND      0x0080    // Optimize by bounding rect

#define RES_DM_COLOR              0x0100 // Color support available this resolution
#define RES_DM_DOWNLOAD_OUTLINE   0x0200 // outline support avail in this resolution

//-----------------------------------------------------------------------------
// RESOLUTION.fBlockOut values
//-----------------------------------------------------------------------------

#define RES_BO_LEADING_BLNKS  0x0001   // Strip leading blanks if sMinBlankSkip
                                       // or more bytes of null data occur
#define RES_BO_TRAILING_BLNKS 0x0002   // Strip trailing blanks if sMinBlankSkip
                                       // or more bytes of null data occur
#define RES_BO_ENCLOSED_BLNKS 0x0004   // Strip enclosed blanks if sMinBlankSkip
                                       // or more bytes of null data occur
#define RES_BO_RESET_FONT     0x0008   // Must reselect font after
                                       // blockout command

// Removed ... LinS 3/08/91
// #define RES_BO_3BYTESIN4     0x0010    // each pixel is expressed in 4 bytes

#define RES_BO_UNIDIR         0x0020   // send unidir
#define RES_BO_NO_ADJACENT    0x0040   // no adjacent pins can be fired
                                       // block out command
#define RES_BO_RESET_CMP      0x0080   // must reset compression when entering
                                       // graphics mode
#define RES_BO_OEMGRXFILTER   0x4000   // use oem supplied graphics filter
#define RES_BO_MULTIPLE_ROWS  0x8000   // Multiple lines of data can be sent
                                       // with the RES_OCD_SENDBLOCK command.

//-----------------------------------------------------------------------------
// RESOLUTION.fCursor values
//-----------------------------------------------------------------------------

#define RES_CUR_X_POS_ORG     0x0001   // X Position is at X start point
                                       // of graphic data after rendering data
#define RES_CUR_X_POS_AT_0    0x0002   // X position at leftmost place
                                       // on page after rendering data
#define RES_CUR_Y_POS_AUTO    0x0004   // Y position automatically moves
                                       // to next Y row
#define RES_CUR_CR_GRX_ORG    0x0008   // CR moves X pos to X start point of
                                       // of graphic data
//-----------------------------------------------------------------------------
// RESOLUTION.iDitherBrush flag values
//-----------------------------------------------------------------------------

#define RES_DB_NONE                   0
#define RES_DB_COARSE                 1
#define RES_DB_FINE                   2
#define RES_DB_LINEART                3
#define RES_DB_ERRORDIFFUSION         4
#define RES_DB_MAX       RES_DB_ERRORDIFFUSION   // last defined ditherbrush


//*****************************************************************************
//
// PAPERSIZE contains physical paper sizes and unprintable margins
//
//*****************************************************************************

//-----------------------------------------------------------------------------
// PAPERSIZE.rgocd[] index values
//-----------------------------------------------------------------------------
#define PSZ_OCD_SELECTPORTRAIT      0
#define PSZ_OCD_SELECTLANDSCAPE     1
#define PSZ_OCD_PAGEPROTECT_ON      2
#define PSZ_OCD_PAGEPROTECT_OFF     3
#define PSZ_OCD_RESERVED1           4
#define PSZ_OCD_RESERVED2           5
#define PSZ_OCD_MAX                 6

typedef struct
{
  short cbSize;         // size of PAPERSIZE, 60 bytes.
  short sPaperSizeID;   // If sPaperSizeID is < 256 then it's predefined.
                        // If it's = 256, allow user defined sizes.
                        // If it's >= 257, it's driver-defined & is the
                        // string ID to name this driver-defined PAPERSIZE
  WORD  fGeneral;       // General flag to describe info about this size
  WORD  fPaperType;     // Bit field to describe this size, used by PAPERSRC
  POINT ptSize;         // X & Y paper size dimension in master units.
  RECT  rcMargins;      // Specifies the unprintable margins in master units.
                        // (Portrait mode in new spec)
  POINT ptCursorOrig;   // Cursor origin relative to physical page origin.
  POINT ptLCursorOrig;  // Cursor origin relative to physical page origin
                        // in landscape.
  OCD   rgocd[PSZ_OCD_MAX];   // Command Descriptors
  RECT  rcLMargins;     // Specifies the unprintable margins in master units
                        // when printing in landscape mode.
  POINT ptVectOffset;   // Offset (in master units) from vector 0,0 to
                        // UL corner of page in portrait mode
  POINT ptLVectOffset;  // Offset (in master units) from vector 0,0 to
                        // UL corner of page in landscape mode
  WORD  wYSizeUnit;     // Base unit for custom paper size dimensions
  WORD  wPageProtMem;   // Amount of mem (in KBs) PAGEPROTECT_ON uses
} PAPERSIZE, * PPAPERSIZE, FAR * LPPAPERSIZE;

//-----------------------------------------------------------------------------
// PAPERSIZE.fGeneral flag values
//-----------------------------------------------------------------------------

#define PS_CENTER           0x0001 // center the printable area along the paper path
#define PS_ROTATE           0x0002 // rotate X & Y dimensions
#define PS_SUGGEST_LNDSCP   0x0004 // suggest landscape mode
#define PS_EJECTFF          0x0008 // eject page via CURSORMOVE.rgocd[CM_OCD_FF]

//-----------------------------------------------------------------------------
// PAPERSIZE.fPaperType flag values
//-----------------------------------------------------------------------------

#define PS_T_STD            0x0001
#define PS_T_LARGE          0x0002
#define PS_T_ENV            0x0004
#define PS_T_LRGENV         0x0008
#define PS_T_ROLL           0x0010
#define PS_T_OEM1           0x0400
#define PS_T_OEM2           0x0800
#define PS_T_OEM3           0x1000
#define PS_T_OEM4           0x2000
#define PS_T_OEM5           0x4000
#define PS_T_OEM6           0x8000

//*****************************************************************************
//
// PAPERQUALITY contains an ID & OCD
//
//*****************************************************************************

typedef struct
{
  short cbSize;         // size of PAPERQUALITY, 12 bytes.
  short sPaperQualID;   //
  DWORD dwReserved;     // reserved for future use
  WORD  wReserved;      // "                     "
  OCD   ocdSelect;      // Command Descriptor to select this Paper Quality.
} PAPERQUALITY, * PPAPERQUALITY, FAR * LPPAPERQUALITY;

//*****************************************************************************
//
// PAPERSOURCE contains information needed to select a feed methods and
// the margin that might be introduced by the feed method.
//
//*****************************************************************************

typedef struct
{
  short cbSize;         // size of PAPERSOURCE, 16 bytes
  short sPaperSourceID; // If sPaperSourceID <= 256 then it's predefined
                        // by genlib, otherwise, it is the string ID.
  WORD  fGeneral;
  WORD  fPaperType;     // Bit field to describe this size, used by PAPERSRC
  short sTopMargin;     // Top margin introduced by the feed method.
  short sBottomMargin;  // Bottom margin introduced by the feed method.
  short sBinAdjust;     // Describes adjustments supported by bin
  OCD   ocdSelect;      // Command Descriptor to select this Paper source.
} PAPERSOURCE, * PPAPERSOURCE, FAR * LPPAPERSOURCE;

//-----------------------------------------------------------------------------
// PAPERSOURCE.fGeneral flag values
//-----------------------------------------------------------------------------

#define PSRC_EJECTFF        0x0001
#define PSRC_MAN_PROMPT     0x0002

//*****************************************************************************
//
// PAPERDEST contains information needed to select a paper out bin/tray
//
//*****************************************************************************

typedef struct
{
  short cbSize;         // size of PAPERDEST, 8 bytes
  short sID;            // If sID <= 256 then it's predefined
                        // otherwise, it is the stringtable ID.
  short fGeneral;       // General purpose Bit field
  OCD   ocdSelect;      // Command Descriptor to select this attribute.
} PAPERDEST, * PPAPERDEST, FAR * LPPAPERDEST;

//-----------------------------------------------------------------------------
// PAPERDEST.fGeneral flag values
//-----------------------------------------------------------------------------

#define PDST_JOBSEPARATION  0x0001

//*****************************************************************************
//
// TEXTQUALITY contains information needed to select a text quality attribute
//
//*****************************************************************************

typedef struct
{
  short cbSize;         // size of TEXTQUALITY, 8 bytes
  short sID;            // If sID <= 256 then it's predefined
                        // otherwise, it is the string ID.
  short fGeneral;       // General purpose Bit field
  OCD   ocdSelect;      // Command Descriptor to select this text quality.
} TEXTQUALITY, * PTEXTQUALITY, FAR * LPTEXTQUALITY;

//*****************************************************************************
//
//  COMPRESSMODE
//
//*****************************************************************************

//-----------------------------------------------------------------------------
//  COMPRESSMODE.rgocd[] index values
//-----------------------------------------------------------------------------
#define CMP_OCD_BEGIN   0
#define CMP_OCD_END     1
#define CMP_OCD_MAX     2

typedef struct
{
  short cbSize;              // size of COMPRESSMODE, 8 bytes
  WORD  iMode;               // ID for type of commpression mode
  OCD   rgocd[CMP_OCD_MAX];  // Offset to commands
} COMPRESSMODE, *PCOMPRESSMODE, FAR * LPCOMPRESSMODE;

//-----------------------------------------------------------------------------
//  COMPRESSMODE.wModeID flags
//-----------------------------------------------------------------------------
#define CMP_ID_FIRST                  CMP_ID_RLE
#define CMP_ID_RLE                             1
#define CMP_ID_TIFF40                          2
#define CMP_ID_DELTAROW                        3
#define CMP_ID_BITREPEAT                       4
#define CMP_ID_FE_RLE                          5
#define CMP_ID_LAST              CMP_ID_FE_RLE

//*****************************************************************************
//
//  FONTCART
//
//*****************************************************************************

#define FC_ORGW_PORT    0
#define FC_ORGW_LAND    1
#define FC_ORGW_MAX     2

typedef struct
{
  short cbSize;              // size of FONTCART, 12 bytes
  WORD  sCartNameID;         // stringtable ID for cartridge name
  WORD  orgwPFM[FC_ORGW_MAX];// array of offsets to array of indices
                             // of PFM resources
  WORD  fGeneral;            // General bit flags
  WORD  wReserved;           // for DWORD alignment
} FONTCART, * PFONTCART, FAR * LPFONTCART;

//#define FC_GEN_RESIDENT           0x0001 // resident font cart

//*****************************************************************************
//
//  PAGECONTROL
//
//*****************************************************************************

//-----------------------------------------------------------------------------
//  PAGECONTROL.rgocd[] index values
//-----------------------------------------------------------------------------

#define PC_OCD_BEGIN_DOC       0
#define PC_OCD_BEGIN_PAGE      1
#define PC_OCD_DUPLEX_ON       2
#define PC_OCD_ENDDOC          3
#define PC_OCD_ENDPAGE         4
#define PC_OCD_DUPLEX_OFF      5
#define PC_OCD_ABORT           6
#define PC_OCD_PORTRAIT        7
#define PC_OCD_LANDSCAPE       8
#define PC_OCD_MULT_COPIES     9
#define PC_OCD_DUPLEX_VERT    10
#define PC_OCD_DUPLEX_HORZ    11
#define PC_OCD_PRN_DIRECTION  12
#define PC_OCD_JOB_SEPARATION 13
#define PC_OCD_MAX            14

typedef struct
{
  short cbSize;            // size of PAGECONTROL, 36 bytes
  short sMaxCopyCount;     // max # of copies w/ PC_OCD_MULT_COPIES
  WORD  fGeneral;          // General bit flags
  WORD  orgwOrder;
  OCD   rgocd[PC_OCD_MAX];
} PAGECONTROL, * PPAGECONTROL, FAR * LPPAGECONTROL;

//-----------------------------------------------------------------------------
//  PAGECONTROL.owOrder index values
//-----------------------------------------------------------------------------

#define PC_ORD_BEGINDOC                           1
#define PC_ORD_ORIENTATION                        2
#define PC_ORD_MULT_COPIES                        3
#define PC_ORD_DUPLEX                             4
#define PC_ORD_DUPLEX_TYPE                        5
#define PC_ORD_TEXTQUALITY                        6
#define PC_ORD_PAPER_SOURCE                       7
#define PC_ORD_PAPER_SIZE                         8
#define PC_ORD_PAPER_DEST                         9
#define PC_ORD_RESOLUTION                        10
#define PC_ORD_BEGINPAGE                         11
#define PC_ORD_SETCOLORMODE                      12
#define PC_ORD_PAPER_QUALITY                     13
#define PC_ORD_PAGEPROTECT                       14
#define PC_ORD_IMAGECONTROL                      15
#define PC_ORD_PRINTDENSITY                      16
#define PC_ORD_MAX              PC_ORD_PRINTDENSITY
#define PC_ORD_LAST             PC_ORD_PRINTDENSITY

//*****************************************************************************
//
//  CURSORMOVE
//
//*****************************************************************************

//-----------------------------------------------------------------------------
//  CURSORMOVE.rgocd[] index values
//-----------------------------------------------------------------------------

#define CM_OCD_XM_ABS          0
#define CM_OCD_XM_REL          1
#define CM_OCD_XM_RELLEFT      2
#define CM_OCD_YM_ABS          3
#define CM_OCD_YM_REL          4
#define CM_OCD_YM_RELUP        5
#define CM_OCD_YM_LINESPACING  6
#define CM_OCD_XY_REL          7
#define CM_OCD_XY_ABS          8
#define CM_OCD_CR              9
#define CM_OCD_LF             10
#define CM_OCD_FF             11
#define CM_OCD_BS             12
#define CM_OCD_UNI_DIR        13
#define CM_OCD_UNI_DIR_OFF    14
#define CM_OCD_PUSH_POS       15
#define CM_OCD_POP_POS        16
#define CM_OCD_MAX            17

typedef struct
{
  short cbSize;             // size of CURSORMOVE, 44 bytes
  WORD  wReserved;
  WORD  fGeneral;
  WORD  fXMove;
  WORD  fYMove;
  OCD   rgocd[CM_OCD_MAX];  // Array of offsets to commands
} CURSORMOVE, *PCURSORMOVE, FAR * LPCURSORMOVE;

//-----------------------------------------------------------------------------
//  CURSORMOVE.fGeneral flag values
//-----------------------------------------------------------------------------
#define CM_GEN_FAV_XY     0x0002  // CM_OCD_XY_ABS and CM_OCD_XY_REL
                                  // move vector CAP to new position

//-----------------------------------------------------------------------------
//  CURSORMOVE.fXmove flag values
//-----------------------------------------------------------------------------
#define CM_XM_NO_POR_GRX    0x0004  // no x movemnt while in graphics mode, portrait
#define CM_XM_NO_LAN_GRX    0x0008  // no x movemnt while in graphics mode, landscape
#define CM_XM_RESET_FONT    0x0010  // Font is reset after x movement command
#define CM_XM_FAVOR_ABS     0x0080  // favor absolute x command
#define CM_XM_REL_LEFT      0x0200  // has relative x to the left
#define CM_XM_ABS_NO_LEFT   0x0400  // No left X movement command
#define CM_XM_RES_DEPENDENT 0x0800  // X movement in resolution unit, not mu

//-----------------------------------------------------------------------------
//  CURSORMOVE.fYmove flag values
//-----------------------------------------------------------------------------

#define CM_YM_FAV_ABS       0x0001
#define CM_YM_REL_UP        0x0002
#define CM_YM_NO_POR_GRX    0x0004  // no y movemnt while in graphics mode, portrait
#define CM_YM_NO_LAN_GRX    0x0008  // no y movemnt while in graphics mode, landscape
#define CM_YM_CR            0x0040
#define CM_YM_LINESPACING   0x0080
#define CM_YM_TRUNCATE      0x0100  // don't compensate for ymovement error
#define CM_YM_RES_DEPENDENT 0x0200  // X movement in resolution unit, not mu

//*****************************************************************************
//
// FONTSIMULATION describes various printer commands to enable and disable
// various character attributes such as bold, italic, etc.
//
//*****************************************************************************

//-----------------------------------------------------------------------------
// FONTSIMULATION.rgocStd[] index values
//-----------------------------------------------------------------------------

#define FS_OCD_BOLD_ON                   0
#define FS_OCD_BOLD_OFF                  1
#define FS_OCD_ITALIC_ON                 2
#define FS_OCD_ITALIC_OFF                3
#define FS_OCD_UNDERLINE_ON              4
#define FS_OCD_UNDERLINE_OFF             5
#define FS_OCD_DOUBLEUNDERLINE_ON        6
#define FS_OCD_DOUBLEUNDERLINE_OFF       7
#define FS_OCD_STRIKETHRU_ON             8
#define FS_OCD_STRIKETHRU_OFF            9
#define FS_OCD_WHITE_TEXT_ON            10
#define FS_OCD_WHITE_TEXT_OFF           11
#define FS_OCD_SINGLE_BYTE              12
#define FS_OCD_DOUBLE_BYTE              13
#define FS_OCD_VERT_ON                  14
#define FS_OCD_VERT_OFF                 15
#define FS_OCD_MAX                      16

typedef struct
{
  short cbSize;            // size of FONTSIMULATION, 44 bytes
  WORD  wReserved;         // so DW aligned
  WORD  fGeneral;
  short sBoldExtra;
  short sItalicExtra;
  short sBoldItalicExtra;
  OCD   rgocd[FS_OCD_MAX];
} FONTSIMULATION, * PFONTSIMULATION, FAR * LPFONTSIMULATION;


//*****************************************************************************
//
// DEVCOLOR is the physical color info which describes the device color
// capabilities and how to compose colors based on available device colors.
//
//*****************************************************************************

//-----------------------------------------------------------------------------
// DEVCOLOR.fGeneral bit flags:
//-----------------------------------------------------------------------------
#define DC_PRIMARY_RGB      0x0001   // use RGB as 3 primary colors.
                                     // Default: use CMY instead.
#define DC_EXTRACT_BLK      0x0002   // Separate black ink/ribbon is available.
                                     // Default: compose black using CMY.
                                     // It is ignored if DC_PRIMARY_RGB is set
#define DC_CF_SEND_CR       0x0004   // send CR before selecting graphics
                                     // color. Due to limited printer buffer
#define DC_SEND_ALL_PLANES  0x0008   // All color plane data must be sent
#define DC_SEND_PAGE_PLANE  0x0010   // Color separation required
#define DC_EXPLICIT_COLOR   0x0020   // Color must be set before sending
                                     // the RES_OCD_SENDBLOCK command.
#define DC_SEND_PALETTE     0x0040   // Color palette must be downloaded

//-----------------------------------------------------------------------------
// One and only one of DEVCOLOR.sPlanes or DEVCOLOR.sBitsPixel must be 1.
//
// Example:
//
// DEVCOLOR.sPlanes:
//    Valid values are:
//        1:         use the pixel color model.
//        n (n > 1): use the plane color model.
//               Ex. for Brother M-1924, n = 4; for PaintJet, n = 3.
//
// DEVCOLOR.sBitsPixel:
//    Valid values are:
//        1:      use the plane color model.
//        4, 8, 16, 24:  use the pixel color model.
//-----------------------------------------------------------------------------

//-----------------------------------------------------------------------------
// DEVCOLOR.rgocd array values
//-----------------------------------------------------------------------------
#define DC_OCD_TC_BLACK        0
#define DC_OCD_TC_RED          1
#define DC_OCD_TC_GREEN        2
#define DC_OCD_TC_YELLOW       3
#define DC_OCD_TC_BLUE         4
#define DC_OCD_TC_MAGENTA      5
#define DC_OCD_TC_CYAN         6
#define DC_OCD_TC_WHITE        7
#define DC_OCD_SETCOLORMODE    8
#define DC_OCD_PC_START        9
#define DC_OCD_PC_ENTRY       10
#define DC_OCD_PC_END         11
#define DC_OCD_PC_SELECTINDEX 12
#define DC_OCD_RESERVED       13
#define DC_OCD_MAX            14

//-----------------------------------------------------------------------------
// DEVCOLOR.rgbOrder array values
//-----------------------------------------------------------------------------

#define DC_PLANE_NONE    0
#define DC_PLANE_RED     1
#define DC_PLANE_GREEN   2
#define DC_PLANE_BLUE    3
#define DC_PLANE_CYAN    4
#define DC_PLANE_MAGENTA 5
#define DC_PLANE_YELLOW  6
#define DC_PLANE_BLACK   7

#define DC_MAX_PLANES    4

typedef struct
{
  short cbSize;               // size of DEVCOLOR, 44 bytes
  WORD  fGeneral;             // general flag bit field
  short sPlanes;              // # of color planes required
  short sBitsPixel;           // # of bits per pixel (per plane). At least
                              // one of 'sPlanes' and 'sBitsPixel' is 1.
  WORD  orgocdPlanes;         // offset to a list of OCD's for sending data
                              // planes. The # of OCD's is equal to 'sPlanes'.
                              // This field is not used in case of pixel
                              // color models. The first command will be
                              // used to send data of the first plane,
                              // and so on.
  OCD   rgocd[DC_OCD_MAX];    // array of Offsets to commands.
  BYTE  rgbOrder[DC_MAX_PLANES]; // order in which color planes are sent
  WORD  wReserved;            // For alignment
} DEVCOLOR, * PDEVCOLOR, FAR * LPDEVCOLOR;


//*****************************************************************************
//
//  RECTFILL
//
//*****************************************************************************

//-----------------------------------------------------------------------------
//  RECTFILL.rgocd[] index values
//-----------------------------------------------------------------------------
#define RF_OCD_X_SIZE         0
#define RF_OCD_Y_SIZE         1
#define RF_OCD_GRAY_FILL      2
#define RF_OCD_WHITE_FILL     3
#define RF_OCD_HATCH_FILL     4
#define RF_OCD_MAX            5

typedef struct
{
  short cbSize;                // size of RECTFILL, 20 bytes
  WORD  fGeneral;
  WORD  wMinGray;
  WORD  wMaxGray;
  OCD   rgocd[RF_OCD_MAX];     // Offset to Command Descriptor
  WORD  wReserved;
} RECTFILL, *PRECTFILL, FAR * LPRECTFILL;

//-----------------------------------------------------------------------------
//  RECTFILL.fGeneral flag values
//-----------------------------------------------------------------------------

#define RF_WHITE_ABLE     0x0001        // White rule exists
#define RF_MIN_IS_WHITE   0x0002        // min. graylevel = white rule

#define RF_CUR_X_END      0x0100        // X Position is at X end point
                                        // of fill area after rendering
#define RF_CUR_Y_END      0x0200        // Y position is at Y end point
                                        // of fill area after rendering
                                        // default is no chg of position

//*****************************************************************************
//
// DOWNLOADINFO describes that way in which unidrv should instruct the font
// installer to handle downloading soft fonts.  It contains OCDs for all
// appropriate codes.
//
//*****************************************************************************

//-----------------------------------------------------------------------------
// DOWNLOADINFO.rgocd[] index values
//-----------------------------------------------------------------------------

#define DLI_OCD_RESERVED                0
#define DLI_OCD_BEGIN_DL_JOB            1
#define DLI_OCD_BEGIN_FONT_DL           2
#define DLI_OCD_SET_FONT_ID             3
#define DLI_OCD_SEND_FONT_DESCRIPTOR    4
#define DLI_OCD_SELECT_FONT_ID          5
#define DLI_OCD_SET_CHAR_CODE           6
#define DLI_OCD_SEND_CHAR_DESCRIPTOR    7
#define DLI_OCD_END_FONT_DL             8
#define DLI_OCD_MAKE_PERM               9
#define DLI_OCD_MAKE_TEMP              10
#define DLI_OCD_END_DL_JOB             11
#define DLI_OCD_DEL_FONT               12
#define DLI_OCD_DEL_ALL_FONTS          13
#define DLI_OCD_SET_SECOND_FONT_ID     14
#define DLI_OCD_SELECT_SECOND_FONT_ID  15
#define DLI_OCD_MAX                    16

typedef struct
{
  short cbSize;            // size of DOWNLOADINFO, 56 bytes
  WORD  wReserved;         // for DWORD alignment
  WORD  fGeneral;          // general bit flags
  WORD  fFormat;           // describes download font format
  WORD  wIDMin;
  WORD  wIDMax;
  short cbBitmapFontDsc;
  WORD  wReserved1;        // Formerly: short cbScaleFontDsc;
  short cbBitmapCharDsc;
  WORD  wReserved2;        // Formerly: short cbScaleCharDsc;
  short sMaxFontCount;
  WORD  wReserved3;
  OCD   rgocd[DLI_OCD_MAX];
} DOWNLOADINFO, * PDOWNLOADINFO, FAR * LPDOWNLOADINFO;

//-----------------------------------------------------------------------------
// DOWNLOADINFO.fGeneral flag values
//-----------------------------------------------------------------------------

#define DLI_GEN_RESERVED1       0x0001  // No longer used--reserved
#define DLI_GEN_MEMORY          0x0002  // printer limits # DL fonts by memory
#define DLI_GEN_DLJOB           0x0004  // printer can only DL fonts on per
                                        // job basis
#define DLI_GEN_DLPAGE          0x0008  // printer can DL fonts on per page
                                        // basis

// NOTE: if neither of the above 2 flags
// are ste, assume DL can happen any time

#define DLI_GEN_PT_IDS          0x0010  // use OCD_SET_FONT_ID for specifiy
                                        // perm/temp
#define DLI_GEN_RESERVED2       0x0020  // No longer used--reserved
#define DLI_GEN_RESERVED3       0x0040  // No longer used--reserved
#define DLI_GEN_FNTDEL_ANYWHERE 0x0080  // if set, fonts can be deleted at
                                        // any point. Default is at page
                                        // boundary only
#define DLI_GEN_7BIT_CHARSET    0x0100  // printer supports only 7-bit charset


//-----------------------------------------------------------------------------
// DOWNLOADINFO.fFormat flag values
//-----------------------------------------------------------------------------

#define DLI_FMT_PCL           0x0001 // PCL printer
#define DLI_FMT_INCREMENT     0x0002 // incremental download recommended
#define DLI_FMT_PCL_RESSPEC   0x0004 // allow resolution specified bitmap
                                     // font download. The X & Y resolutions
                                     // are attached to the end of the
                                     // regular PCL bitmap font descriptor.
#define DLI_FMT_OUTLINE       0x0008 // printer supports outline downloading
#define DLI_FMT_PCLETTO       0x0008 // alias for outline downloading (remove later)
#define DLI_FMT_CAPSL         0x0010 // Use CaPSL download header
#define DLI_FMT_PPDS          0x0020 // Use PPDS download header
#define DLI_FMT_CALLBACK      0x0040 // minidriver provide callbacks for
                                     // for downloading bitmap fonts.


//*****************************************************************************
//
//  VECTPAGE describes information about the vector page and miscellaneous
//  vector capabilities and commands
//
//*****************************************************************************

//-----------------------------------------------------------------------------
// VECTPAGE.rgocd[] index values
//-----------------------------------------------------------------------------
#define VP_OCD_INIT_VECT       0
#define VP_OCD_ENTER_VECT      1
#define VP_OCD_EXIT_VECT       2
#define VP_OCD_TRANSPARENT     3
#define VP_OCD_OPAQUE          4
#define VP_OCD_ANCHOR          5
#define VP_OCD_SET_CLIPRECT    6
#define VP_OCD_CLEAR_CLIPRECT  7
#define VP_OCD_ENDCAP_FLAT     8
#define VP_OCD_ENDCAP_ROUND    9
#define VP_OCD_ENDCAP_SQUARE  10
#define VP_OCD_JOIN_BEVEL     11
#define VP_OCD_JOIN_MITER     12
#define VP_OCD_JOIN_ROUND     13
#define VP_OCD_RESERVED1      14
#define VP_OCD_RESERVED2      15
#define VP_OCD_RESERVED3      16
#define VP_OCD_RESERVED4      17
#define VP_OCD_MAX            18

typedef struct
{
  WORD  cbSize;            // Size of VECTPAGE, 44 bytes
  WORD  fGeneral;          // General use bitfield
  POINT ptVectDPI;         // Vector units per inch
  OCD   rgocd[VP_OCD_MAX]; // Offsets to commands
} VECTPAGE, *PVECTPAGE, FAR *LPVECTPAGE;

//-----------------------------------------------------------------------------
// VECTPAGE.fGeneral flags
//-----------------------------------------------------------------------------
#define VP_GEN_X_AXIS_LEFT 0x0001 // Set if plotter's X axis (horizontal)
                                  // extends left. Default is to the right
#define VP_GEN_Y_AXIS_UP   0x0002 // Sef if plotter's Y axis (vertical)
                                  // extends upward. Default is downward.

//******************************************************************************
//
//  CAROUSEL describes carousel characteristics. If the pens are fixed,
//  this also specifies the colors of each pen.
//
//******************************************************************************

//------------------------------------------------------------------------------
// CAROUSEL.rgocd[] index values
//------------------------------------------------------------------------------
#define CAR_OCD_SELECT_PEN_COLOR   0
#define CAR_OCD_SET_PEN_WIDTH      1
#define CAR_OCD_RETURN_PEN         2
#define CAR_OCD_RESERVED           3
#define CAR_OCD_MAX                4

typedef struct
{
  WORD  cbSize;               // Size of CAROUSEL, 16 bytes
  WORD  fGeneral;             // General purpose bitfield
  WORD  wNumPens;             // # of pens in carousel
  short oiRGBColors;          // colors of pens in carousel
  OCD   rgocd[CAR_OCD_MAX];   // commands associated with carousel
} CAROUSEL, *PCAROUSEL, FAR *LPCAROUSEL;

//------------------------------------------------------------------------------
// CAROUSEL.fGeneral flags
//------------------------------------------------------------------------------
#define CAR_GEN_CAROUSEL_LEFT      0x0001 // Set if pen moves to the left of
                                          // page when returned to carousel
#define CAR_GEN_CAROUSEL_RIGHT     0x0002 // Set if pen moves to the right of
                                          // page when returned to carousel
#define CAR_GEN_CAROUSEL_TOP       0x0004 // Set if pen moves to the top of
                                          // page when returned to carousel
#define CAR_GEN_CAROUSEL_BOTTOM    0x0008 // Set if pen moves to the bottom of
                                          // page when returned to carousel
#define CAR_GEN_CAROUSEL_FIXED     0x0010 // Carousel has fixed set of pens
#define CAR_GEN_RETURN_PEN         0x0020 // Pen must be explicitly returned
                                          // to the carousel before selecting
                                          // a new pen.
#define CAR_GEN_VARIABLE_PEN_WIDTH 0x0040 // Set if SET_PEN_WIDTH changes
                                          // the width of the (logical) pen
                                          // as opposed to informing the
                                          // plotter of the physical width.


//******************************************************************************
//
//  PENINFO describes the characteristics of an available pen
//
//******************************************************************************

//------------------------------------------------------------------------------
// PENINFO.rgocd[] index values
//------------------------------------------------------------------------------

typedef struct
{
  WORD  cbSize;              // Size of PENINFO, 16 bytes
  WORD  fGeneral;            // General purpose bitfield
  DWORD fType;               // Surfaces on which pen can draw
  DWORD dwColor;             // RGB color of the pen
  WORD  fThick;              // Thickness in which pen is available
  WORD  wIDS;                // Stringtable resource for this color's name
} PENINFO, *PPENINFO, FAR *LPPENINFO;

//------------------------------------------------------------------------------
// PENINFO.fThick values
//------------------------------------------------------------------------------
#define PI_FTHICK_18     0x0001   // Pen comes in 0.18mm
#define PI_FTHICK_25     0x0002   // Pen comes in 0.25mm
#define PI_FTHICK_30     0x0004   // Pen comes in 0.30mm
#define PI_FTHICK_35     0x0008   // Pen comes in 0.35mm
#define PI_FTHICK_50     0x0010   // Pen comes in 0.50mm
#define PI_FTHICK_70     0x0020   // Pen comes in 0.70mm
#define PI_FTHICK_100    0x0040   // Pen comes in 1.00mm

//------------------------------------------------------------------------------
// PENINFO.fType values depend on the defined paper sources, but reserve
// the high bit to indicate that any paper source is valid.
//------------------------------------------------------------------------------
#define PI_FTYPE_ANY     0x80000000

//******************************************************************************
//
//  LINEINFO describes the line style creation and selection commands
//
//******************************************************************************

//------------------------------------------------------------------------------
// LINEINFO.rgocd[] index values
//------------------------------------------------------------------------------
#define LI_OCD_DELETE_LINESTYLE    0
#define LI_OCD_SELECT_NULL         1
#define LI_OCD_SELECT_SOLID        2
#define LI_OCD_CREATE_DASH         3
#define LI_OCD_SELECT_DASH         4
#define LI_OCD_CREATE_DOT          5
#define LI_OCD_SELECT_DOT          6
#define LI_OCD_CREATE_DASHDOT      7
#define LI_OCD_SELECT_DASHDOT      8
#define LI_OCD_CREATE_DASHDOTDOT   9
#define LI_OCD_SELECT_DASHDOTDOT  10
#define LI_OCD_RESERVED1          11
#define LI_OCD_RESERVED2          12
#define LI_OCD_RESERVED3          13
#define LI_OCD_RESERVED4          14
#define LI_OCD_RESERVED5          15
#define LI_OCD_MAX                16

typedef struct
{
  WORD  cbSize;             // Size of LINEINFO, 40 bytes
  WORD  fGeneral;           // General purpose bitfield
  short sMaxUserDefined;    // Max # of line styles that can be defined at once
  WORD  wReserved;          // Maintain DWORD alignment
  OCD   rgocd[LI_OCD_MAX];  // Offsets to commands
} LINEINFO, *PLINEINFO, FAR *LPLINEINFO;


//******************************************************************************
//
//  BRUSHINFO describes the brush style creation and selection commands
//
//******************************************************************************

//------------------------------------------------------------------------------
// BRUSHINFO.rgocd[] index values
//------------------------------------------------------------------------------
#define BI_OCD_SELECT_NULL             0
#define BI_OCD_SELECT_SOLID            1
#define BI_OCD_SELECT_HS_HORIZONTAL    2
#define BI_OCD_SELECT_HS_VERTICAL      3
#define BI_OCD_SELECT_HS_FDIAGONAL     4
#define BI_OCD_SELECT_HS_BDIAGONAL     5
#define BI_OCD_SELECT_HS_CROSS         6
#define BI_OCD_SELECT_HS_DIAGCROSS     7
#define BI_OCD_CREATE_BRUSHSTYLE_1     8
#define BI_OCD_CREATE_BIT_1            9
#define BI_OCD_CREATE_SEPARATOR_1     10
#define BI_OCD_CREATE_BRUSHSTYLE_2    11
#define BI_OCD_CREATE_BYTE_2          12
#define BI_OCD_SELECT_BRUSHSTYLE      13
#define BI_OCD_DELETE_BRUSHSTYLE      14
#define BI_OCD_CREATE_END_1           15
#define BI_OCD_RESERVED2              16
#define BI_OCD_RESERVED3              17
#define BI_OCD_MAX                    18

typedef struct
{
  WORD  cbSize;             // Size of BRUSHINFO, 40 bytes
  WORD  fGeneral;           // General purpose bitfield
  short sMaxUserDefined;    // Max # of user-defined brushes allowed at once
  WORD  wReserved;          // Maintain DWORD alignment
  OCD   rgocd[BI_OCD_MAX];  // Offsets to commands
} BRUSHINFO, *PBRUSHINFO, FAR *LPBRUSHINFO;

//------------------------------------------------------------------------------
// BRUSHINFO.fGeneral flags
//------------------------------------------------------------------------------
#define BI_GEN_BRUSHSTYLE1     0x0001  // BRUSHSTYLE1 supported
#define BI_GEN_BRUSHSTYLE2     0x0002  // BRUSHSTYLE2 supported
#define BI_GEN_BRUSH32x32      0x0004  // Brush size of 32x32 pixels ONLY


//******************************************************************************
//
//  VECTOUTPUT describes the graphic output drawing commands & ordering
//
//******************************************************************************

//------------------------------------------------------------------------------
// VECTOUTPUT.rgocd[] index values
//------------------------------------------------------------------------------
#define VO_OCD_RECTANGLE         0
#define VO_OCD_CIRCLE            1
#define VO_OCD_ELLIPSE           2
#define VO_OCD_C_PIE             3
#define VO_OCD_E_PIE             4
#define VO_OCD_C_ARC             5
#define VO_OCD_E_ARC             6
#define VO_OCD_C_CHORD           7
#define VO_OCD_E_CHORD           8
#define VO_OCD_RESERVED1         9
#define VO_OCD_RESERVED2        10
#define VO_OCD_RESERVED3        11
#define VO_OCD_RESERVED4        12
#define VO_OCD_RESERVED5        13
#define VO_OCD_RESERVED6        14
#define VO_OCD_RESERVED7        15
#define VO_OCD_MAX              16
#define VO_OCD_NUM               9  // # non-reserved VOs

typedef struct
{
  WORD  cbSize;             // Size of VECTOUTPUT, 40 bytes
  WORD  fGeneral;           // General purpose bitfield
  WORD  wReserved;          // Maintain DWORD alignment
  short rgoi[VO_OCD_MAX];   // Offsets to arrays of VECTSUPPORT
  OCD   rgocd[VO_OCD_MAX];  // Offsets to commands
} VECTOUTPUT, *PVECTOUTPUT, FAR *LPVECTOUTPUT;


//******************************************************************************
//
//  POLYVECTOUTPUT describes the polygon/polyline drawing commands & ordering
//
//******************************************************************************

//------------------------------------------------------------------------------
// POLYVECTOUTPUT.rgocd[] index values
//------------------------------------------------------------------------------
#define PVO_OCD_POLYLINE       0
#define PVO_OCD_ALTPOLYGON     1
#define PVO_OCD_WINDPOLYGON    2
#define PVO_OCD_POLYBEZIER     3
#define PVO_OCD_RESERVED1      4
#define PVO_OCD_RESERVED2      5
#define PVO_OCD_RESERVED3      6
#define PVO_OCD_RESERVED4      7
#define PVO_OCD_MAX            8
#define PVO_OCD_NUM            4    // # non-reserved PVOs

//-----------------------------------------------------------------------------
// Indices into 2-dimensional array rgocd
//-----------------------------------------------------------------------------
#define OCD_BEGIN              0
#define OCD_CONTINUE           1
#define OCD_SEPARATOR          2
#define OCD_END                3
#define OCD_MAX                4

typedef struct
{
  WORD   cbSize;                      // sizeof POLYVECTOUTPUT, 88 bytes
  WORD   fGeneral;                    // General purpose bitfield
  WORD   wPointLimit;                 // Polygon Point Number Limit
  WORD   wReserved;                   // Reserved for future use
  short  rgoi[PVO_OCD_MAX];           // Describes which VECTSUPPORTs are used
  OCD    rgocd[PVO_OCD_MAX][OCD_MAX]; // offsets to commands
} POLYVECTOUTPUT, *PPOLYVECTOUTPUT, FAR *LPPOLYVECTOUTPUT;


//******************************************************************************
//
//  VECTSUPPORT describes methods used by VECTOUTPUT and POLYVECTOUTPUT
//
//******************************************************************************

//------------------------------------------------------------------------------
// VECTSUPPORT.rgocd[] index values
//------------------------------------------------------------------------------
#define VS_OCD_BEGIN_POLYDEF    0
#define VS_OCD_END_POLYDEF      1
#define VS_OCD_WIND_FILL        2
#define VS_OCD_ALT_FILL         3
#define VS_OCD_STROKE           4
#define VS_OCD_PEN_UP           5
#define VS_OCD_PEN_DOWN         6
#define VS_OCD_RESERVED1        7
#define VS_OCD_RESERVED2        8
#define VS_OCD_RESERVED3        9
#define VS_OCD_MAX             10


// These are used by VECTOUTPUT and POLYVECTOUTPUT to represent their ordering
// of pen and brush selection, as well as their OCD or Begin OCD, Continue
// OCD, and End OCD combination
#define VS_SELECT_PEN    -1
#define VS_SELECT_BRUSH  -2
#define VS_OCD           -3
#define VS_OCD_BEGIN     -4
#define VS_OCD_CONTINUE  -5
#define VS_OCD_END       -6

typedef struct
{
  WORD  cbSize;               // Size of VECTSUPPORT, 24 bytes
  WORD  fGeneral;             // General purpose bitfield
  short rgocd[VS_OCD_MAX];    // Offsets to commands
} VECTSUPPORT, *PVECTSUPPORT, FAR *LPVECTSUPPORT;

//*****************************************************************************
//
// IMAGECONTROL contains information needed to select an image control
//
//*****************************************************************************

typedef struct
{
  short cbSize;         // size of IMAGECONTROL, 8 bytes
  short sID;            // If sID <= 256 then it's predefined
                        // otherwise, it is the stringtable ID.
  short fGeneral;       // General purpose Bit field
  OCD   ocdSelect;      // Command Descriptor to select this attribute.
} IMAGECONTROL, * PIMAGECONTROL, FAR * LPIMAGECONTROL;

//-----------------------------------------------------------------------------
// IMAGECONTROL.fGeneral flag values
//-----------------------------------------------------------------------------
// None defined

//*****************************************************************************
//
// PRINTDENSITY contains information needed to select an image control
//
//*****************************************************************************

typedef struct
{
  short cbSize;         // size of PRINTDENSITY, 8 bytes
  short sID;            // If sID <= 256 then it's predefined
                        // otherwise, it is the stringtable ID.
  OCD   ocdSelect;      // Command Descriptor to select this attribute.
  WORD  wReserved;      // make the structure DWORD aligned.
} PRINTDENSITY, * PPRINTDENSITY, FAR * LPPRINTDENSITY;


//*****************************************************************************
//
// COLORTRC contains rgb transfer curves on PAPERQUALITY and RESOLUTION basis
//
//*****************************************************************************

typedef struct tagColorTRC
{
  short cbSize;                   // size of COLORTRC, 116 bytes
  WORD  wReserved;                // keep everything DWORD aligned
  WORD  fGeneral;
  WORD  wIndexPaperQuality;
  WORD  wIndexResolution;
  WORD  wDitherType;              // reserved for dither, set to zero
  WORD  wReserved1;               // always a good idea
  WORD  wReserved2;
  BYTE  RGBOrdinates[3][17];
  BYTE  padding0;                 // keep everything DWORD aligned
  BYTE  DarkRGBOrdinates[3][17];
  BYTE  padding1;                 // keep everything DWORD aligned
} COLORTRC, * PCOLORTRC, FAR * LPCOLORTRC;

// flags for COLORTRC

#define  CTRC_NO_CHECKER_BOARD    0x0001
#define  CTRC_NO_BLACK_PEN        0x0002

// Offsets into arrays of ORDINATELIST
#define TRC_RED         0
#define TRC_GREEN       1
#define TRC_BLUE        2


//*****************************************************************************
//*****************************************************************************
//
//  CD - Command Descriptor is used in many of the following structures to
//  reference a particular set of printer command/escape codes
//  used to select paper sizes, graphics resolutions, character attributes,
//  etc. The actual command string (cd.wLength bytes) follows immediately
//  after the CD. which is immediately followed by cd.wCount EXTCD
//  structures. In earliser versions of this specification, the EXTCD
//  structures were not WORD aligned if the command string was an odd
//  number of bytes. Beginning with GPC version 3, the EXTCD structures
//  will be WORD-aligned. This is done by adding an additional NULL after
//  the end of an odd-length command string. cd.wCount does not include
//  this additional NULL.
//
//*****************************************************************************
//*****************************************************************************

typedef struct
{
  BYTE  fGeneral;       // General purpose bitfield
  BYTE  bCmdCbId;       // Callback ID; 0 iff no callback
  WORD  wCount;         // # of EXTCD structures following
  WORD  wLength;        // length of the command
} CD, *PCD, FAR * LPCD;

//------------------------------------------------------------------------------
// CD.fGeneral flags
//------------------------------------------------------------------------------
#define CMD_GEN_MAY_REPEAT 0x0001 // Command may be sent multiple times if
                                  // the parameter exceeds sMax

#define CMD_MARKER        '%'

//-----------------------------------------------------------------------------
//  EXTCD - Extended portion of the  Command Descriptor. cd.sCount of these
//  structures follow any CD.
//
//  valueOut=(((valueIn+sPreAdd)*sUnitMult) $ sUnitDiv)+sUnitAdd
//
//  where $ is either division or modulo, depending on XCD_GEN_MODULO
//
//  Values that are 0 are ignored.
//-----------------------------------------------------------------------------

typedef struct
{
  WORD  fGeneral;     // General purpose flags
  short sUnitDiv;
  short sUnitMult;
  short sUnitAdd;
  short sPreAdd;
  short sMax;
  short sMin;
  WORD  wParam;       // Parameter ordinal for multiple parameters
} EXTCD, *PEXTCD, FAR * LPEXTCD;

#define XCD_GEN_RESERVED   0x0001   // Previously defined, now unused
#define XCD_GEN_NO_MAX     0x0002   // Set iff there is no max (sMax ignored)
#define XCD_GEN_NO_MIN     0x0004   // Set iff there is no min (sMin ignored)
#define XCD_GEN_MODULO     0x0008   // Set if divide should be modulo

//-----------------------------------------------------------------------------
// pre-defined text qualities
//-----------------------------------------------------------------------------

#define DMTEXT_FIRST     DMTEXT_LQ
#define DMTEXT_LQ                1
#define DMTEXT_NLQ               2
#define DMTEXT_MEMO              3
#define DMTEXT_DRAFT             4
#define DMTEXT_TEXT              5
#define DMTEXT_LAST    DMTEXT_TEXT

#define DMTEXT_USER            256 // lower bound for user-defined text
                                   // quality id

//-----------------------------------------------------------------------------
// misc
//-----------------------------------------------------------------------------

// someday make NOOCD ((OCD)NOT_USED)

#define NOT_USED  -1         // the value should not be used.
#define NOOCD     NOT_USED   // command does not exist
=== C:/Users/treeman/Desktop/windows nt source code\Source\Win2K3\NT\printscan\faxsrv\print\faxprint\faxdrv\win9x\ddk\printer\inc\pfm.h ===
/****************************************************************************
*                                                                           *
* THIS CODE AND INFORMATION IS PROVIDED "AS IS" WITHOUT WARRANTY OF ANY     *
* KIND, EITHER EXPRESSED OR IMPLIED, INCLUDING BUT NOT LIMITED TO THE       *
* IMPLIED WARRANTIES OF MERCHANTABILITY AND/OR FITNESS FOR A PARTICULAR     *
* PURPOSE.                                                                  *
*                                                                           *
* Copyright (C) 1993-95  Microsoft Corporation.  All Rights Reserved.       *
*                                                                           *
****************************************************************************/

//-----------------------------------------------------------------------------
// pfm.h
//-----------------------------------------------------------------------------

//	DRIVERINFO version number (i.e., current version of the structure).

#define DRIVERINFO_VERSION2 0x0200
#define DRIVERINFO_VERSION	0x0200

//-----------------------------------------------------------------------------
// DRIVERINFO contains extra font information needed by genlib to output text
//-----------------------------------------------------------------------------

typedef struct
    {
    short   sSize;	    // size of this structure
    short   sVersion;	    // version number
    WORD    fCaps;	    // Capabilties Flags
    short   sFontID;	    // unique font id defined by unidrv
    short   sYAdjust;	    // adjust y position before output character
			    // used by double height characters
    short   sYMoved;	    // cursor has moved after printing this font
    short   sTransTab;	    // ID value for CTT
    short   sUnderLinePos;
    short   sDoubleUnderlinePos;
    short   sStrikeThruPos;
    LOCD    locdSelect;            // long offset to command descriptor
    LOCD    locdUnSelect;          // long offset to command descriptor to
                                   // unselect.  NOOCD is none
    WORD    wPrivateData;
    short   sShift;	    // # of pixels shifted from the center of the
			    // char center-line. Used for Z1 cartidge.
			    // Use a negative value representing left shift.
    WORD    wFontType;             // Type of font
    }	DRIVERINFO, * PDRIVERINFO, far * LPDRIVERINFO;

// flags defined for DRIVERINFO.fCaps

#define DF_NOITALIC	0x0001	// Cannot italicize via FONTSIMULATION
#define DF_NOUNDER	0x0002	// Cannot underline via FONTSIMULATION
#define DF_XM_CR	0x0004	// send CR after using this font
#define DF_NO_BOLD	0x0008	// Cannot bold via FONTSIMULATION
#define DF_NO_DOUBLE_UNDERLINE	0x0010	// Cannot double underline via FONTSIMULATION
#define DF_NO_STRIKETHRU	0x0020	// Cannot strikethru via FONTSIMULATION
#define DF_BKSP_OK	0x0040	// Can use backspace char, see spec foe details

// Types for DRIVERINFO.wFontType

#define DF_TYPE_HPINTELLIFONT         0     // HP's Intellifont
#define DF_TYPE_TRUETYPE              1     // HP's PCLETTO fonts on LJ4
#define DF_TYPE_PST1                  2     // Lexmark PPDS scalable fonts
#define DF_TYPE_CAPSL                 3     // Canon CAPSL scalable fonts
#define DF_TYPE_OEM1                  4     // OEM scalable font type 1
#define DF_TYPE_OEM2                  5     // OEM scalable font type 2


 typedef struct  {
    short	dfType;
    short	dfPoints;
    short	dfVertRes;
    short	dfHorizRes;
    short	dfAscent;
    short	dfInternalLeading;
    short	dfExternalLeading;
    BYTE	dfItalic;
    BYTE	dfUnderline;
    BYTE	dfStrikeOut;
    short	dfWeight;
    BYTE	dfCharSet;
    short	dfPixWidth;
    short	dfPixHeight;
    BYTE	dfPitchAndFamily;
    short	dfAvgWidth;
    short	dfMaxWidth;
    BYTE	dfFirstChar;
    BYTE	dfLastChar;
    BYTE	dfDefaultChar;
    BYTE	dfBreakChar;
    short	dfWidthBytes;
    DWORD	dfDevice;
    DWORD	dfFace;
    DWORD	dfBitsPointer;
    DWORD	dfBitsOffset;
    BYTE	dfReservedByte;
 } PFMHEADER, * PPFMHEADER, far * LPPFMHEADER;

// The low nibble of PFMHEADER.dfPitchAndFamily differs from the low
// nibble of LOGFONT.lfPitchAndFamily. Instead of DONTKNOW=0,
// FIXED_PITCH=1, and VARIABLE_PITCH=2 (as in LOGFONT), we have
// FIXED_PITCH=0 and VARIABLE_PITCH=1. Dumb, but we can't change it now.
#define PFM_FIXED_PITCH     0
#define PFM_VARIABLE_PITCH  1

typedef struct
    {
    WORD    dfSizeFields;
    DWORD   dfExtMetricsOffset;
    DWORD   dfExtentTable;
    DWORD   dfOriginTable;
    DWORD   dfPairKernTable;
    DWORD   dfTrackKernTable;
    DWORD   dfDriverInfo;
    DWORD   dfReserved;
    } PFMEXTENSION, * PPFMEXTENSION, far * LPPFMEXTENSION;

// PFM structure used by all hardware fonts

typedef struct
    {
    PFMHEADER    pfm;
    PFMEXTENSION pfme;
    } PFM, * PPFM, far * LPPFM;

// bitmap font extension

typedef struct
    {
    DWORD   flags;		// Bit Blags
    WORD    Aspace;		// Global A space, if any
    WORD    Bspace;		// Global B space, if any
    WORD    Cspace;		// Global C space, if any
    DWORD   oColor;		// offset to color table, if any
    DWORD   reserve;		//
    DWORD   reserve1;
    WORD    reserve2;
    WORD    dfCharOffset[1];	// Area for storing the character offsets
    } BMFEXTENSION;

// bitmap font structure used by 3.0 bitmap fonts

typedef struct
    {
    PFMHEADER	    pfm;
    BMFEXTENSION    bmfe;
    } BMF, FAR * LPBMF;

typedef struct
	{
	short	emSize;
	short	emPointSize;
	short	emOrientation;
	short	emMasterHeight;
	short	emMinScale;
	short	emMaxScale;
	short	emMasterUnits;
	short	emCapHeight;
	short	emXHeight;
	short	emLowerCaseAscent;
	short	emLowerCaseDescent;
	short	emSlant;
	short	emSuperScript;
	short	emSubScript;
	short	emSuperScriptSize;
	short	emSubScriptSize;
	short	emUnderlineOffset;
	short	emUnderlineWidth;
	short	emDoubleUpperUnderlineOffset;
	short	emDoubleLowerUnderlineOffset;
	short	emDoubleUpperUnderlineWidth;
	short	emDoubleLowerUnderlineWidth;
	short	emStrikeOutOffset;
	short	emStrikeOutWidth;
	WORD	emKernPairs;
	WORD	emKernTracks;
	} EXTTEXTMETRIC, * PEXTTEXTMETRIC, far * LPEXTTEXTMETRIC;

typedef struct
	{
	union {
		BYTE each[2];
		WORD both;
	} kpPair;
	short kpKernAmount;
	} KERNPAIR, * PKERNPAIR, far * LPKERNPAIR;

typedef struct
	{
	short ktDegree;
	short ktMinSize;
	short ktMinAmount;
	short ktMaxSize;
	short ktMaxAmount;
	} KERNTRACK, * PKERNTRACK, far * LPKERNTRACK;


//--------------------------------------------------
// PCM stuff from old pfm.h in hppcl driver
//--------------------------------------------------
#define PCM_MAGIC	0xCAC
#define PCM_VERSION 0x310

#define PCE_MAGIC   0xB0B

typedef struct _pcmheader {
	WORD  pcmMagic;
	WORD  pcmVersion;
	DWORD pcmSize;
	DWORD pcmTitle;
	DWORD pcmPFMList;
	} PCMHEADER, FAR * LPPCMHEADER;

//---------------------------------------------------------
// TRANSTAB is used to do ANSI to OEM code page
// character translation tables.
//---------------------------------------------------------

typedef struct
    {
    WORD    wType;		    // tells what type of translation table
    BYTE    chFirstChar;
    BYTE    chLastChar;
    union
	{
	short	psCode[1];
	BYTE	bCode[1];
	BYTE	bPairs[1][2];
	} uCode;
    } TRANSTAB, FAR * LPTRANSTAB;

// Defined indices for wType

#define CTT_WTYPE_COMPOSE   0	// uCode is an array of 16-bit offsets from the
                              // beginning of the file pointing to the strings to
                              // use for translation.  The length of the translated
                              // string is the difference between the next offset
                              // and the current offset.

#define CTT_WTYPE_DIRECT    1	// uCode is a byte array of one-to-one translation
                              // table from bFirstChar to bLastChar

#define CTT_WTYPE_PAIRED    2	// uCode contains an array of paired unsigned
                              // bytes.  If only one character is needed to do
                              // the translation then the second byte is zero,
                              // otherewise the second byte is struct over the
                              // first byte.

#ifdef DBCS
#define CTT_WTYPE_JIS78     256     // Default ShiftJIS to JIS78 translation
                                    // apply to NEC printers, JAPAN. uCode
                                    // doesn't contain any valid data

#define CTT_WTYPE_NS86      257     // Default Big-5 to National Standstand
                                    // conversion for Taiwan. uCode contains
                                    // private data, its format and lenght are
                                    // implement dependent.

#define CTT_WTYPE_ISC       258     //  Default KSC5601 to Industrial Standard
                                    //  Code conversion. uCode contains private
                                    //  data, its format and length are
                                    //  implement dependent
#define CTT_WTYPE_JIS83     259     // Default ShiftJIS to JIS83 translation
                                    // apply to EPSON/P printers, JAPAN. uCode
                                    // doesn't contain any valid data

#define CTT_WTYPE_TCA       260     // Default Big-5 to Taipei Computer
                                    // Association code conversion. uCode
                                    // contains private data, its format and
                                    // length are implement dependent.

#define CTT_WTYPE_BIG5      261     // Default Big-5 to Big-5 conversion
                                    // Association code conversion. uCode
                                    // doesn't contain any valid data.
                                    // Don't need any code to implement it,
                                    // because the default one without
                                    // resource will do no translation.
#define CTT_WTYPE_JIS78_ANK 262     // Default ShiftJIS to JIS78 translation
                                    // Only translate DBCS range code to JIS83

#define CTT_WTYPE_JIS83_ANK 263     // Default ShiftJIS to JIS83 translation
                                    // Only translate DBCS range code to JIS83


#endif
=== C:/Users/treeman/Desktop/windows nt source code\Source\Win2K3\NT\printscan\faxsrv\print\faxprint\faxdrv\win9x\faxdrv32\faxdrv32.h ===
/////////////////////////////////////////////////////////////////////////////
//  FILE          : faxdrv32.h                                             //
//                                                                         //
//  DESCRIPTION   : API decleration for the 32 bit size of the fax driver. //
//                  This file is used also as a source file for the thunk- //
//                  compiler for creating the 16 and 32 bit thunks.        //
//                  When _THUNK is defined before including this file, the //
//                  preprocessor result is a thunk script suitable for -   //
//                  creating the thunks.                                   //
//                  Thunk calls failure results in negative value returned //
//                  from the thunk call.                                   //
//                                                                         //
//  AUTHOR        : DanL.                                                  //
//                                                                         //
//  HISTORY       :                                                        //
//      Oct 19 1999 DannyL  Creation.                                      //
//                                                                         //
//  Copyright (C) 1999 Microsoft Corporation   All Rights Reserved         //
/////////////////////////////////////////////////////////////////////////////

#ifndef __FAXDRV32__FAXDRV32_H
#define __FAXDRV32__FAXDRV32_H

#include "..\utils\thunks.h"

#ifndef _THUNK

#endif //_THUNK

BOOL WINAPI
FaxStartDoc(DWORD dwPtr, LPDOCINFO lpdi)
BEGIN_ARGS_DECLARATION
    FAULT_ERROR_CODE(-1);
END_ARGS_DECLARATION


BOOL WINAPI
FaxAddPage(DWORD  dwPtr,
           LPBYTE lpBitmapData,
           DWORD  dwPxlsWidth,
           DWORD  dwPxlsHeight)
BEGIN_ARGS_DECLARATION
    FAULT_ERROR_CODE(-1);
END_ARGS_DECLARATION


BOOL WINAPI
FaxEndDoc(DWORD dwPtr,
          BOOL  bAbort)
BEGIN_ARGS_DECLARATION
    FAULT_ERROR_CODE(-1);
END_ARGS_DECLARATION

BOOL WINAPI
FaxResetDC(LPDWORD pdwOldPtr,
           LPDWORD pdwNewPtr)
BEGIN_ARGS_DECLARATION
    FAULT_ERROR_CODE(-1);
END_ARGS_DECLARATION


BOOL WINAPI
FaxDevInstall(LPSTR lpDevName,
              LPSTR lpOldPort,
              LPSTR lpNewPort)
BEGIN_ARGS_DECLARATION
    FAULT_ERROR_CODE(-1);
END_ARGS_DECLARATION


BOOL WINAPI
FaxCreateDriverContext(LPSTR      lpDeviceName,
                       LPSTR      lpPort,
                       LPDEVMODE  lpDevMode,
                       LPDWORD    lpDrvContext)
BEGIN_ARGS_DECLARATION
    FAULT_ERROR_CODE(-1);
END_ARGS_DECLARATION

BOOL WINAPI
FaxDisable(DWORD dwPtr)
BEGIN_ARGS_DECLARATION
    FAULT_ERROR_CODE(-1);
END_ARGS_DECLARATION

#endif //__FAXDRV32__FAXDRV32_H
=== C:/Users/treeman/Desktop/windows nt source code\Source\Win2K3\NT\printscan\faxsrv\print\faxprint\faxdrv\win9x\faxdrv32\faxtiff_ref.c ===
#include "stdhdr.h"
#include \
/*******************************************************************************
 *                                                                             *
 *	This source file is merely a reference to the file included in it, in order*
 *	to overcome razzle inability to specify files in an ancestral directory    *
 *	rather than the parent directory. For complete documentation of            *
 *  functionality refer to */ "..\..\..\faxtiff.c"                            /*
 *                                                                             *
 *******************************************************************************/

//
// Statically override implementaion of WritePrinter to redirect output to a 
// file rather then to a printer.
// 
static BOOL _inline WINAPI 
WritePrinter(
    IN HANDLE  hPrinter,
    IN LPVOID  pBuf,
    IN DWORD   cbBuf,
    OUT LPDWORD pcWritten
)
{
    return WriteFile(hPrinter,pBuf,cbBuf,pcWritten,NULL);
}
=== C:/Users/treeman/Desktop/windows nt source code\Source\Win2K3\NT\printscan\faxsrv\print\faxprint\faxdrv\win9x\ddk\printer\inc\unidrv.h ===
/****************************************************************************
*                                                                           *
* THIS CODE AND INFORMATION IS PROVIDED "AS IS" WITHOUT WARRANTY OF ANY     *
* KIND, EITHER EXPRESSED OR IMPLIED, INCLUDING BUT NOT LIMITED TO THE       *
* IMPLIED WARRANTIES OF MERCHANTABILITY AND/OR FITNESS FOR A PARTICULAR     *
* PURPOSE.                                                                  *
*                                                                           *
* Copyright (C) 1993-95  Microsoft Corporation.  All Rights Reserved.       *
*                                                                           *
****************************************************************************/

//--------------------------------------------------------------------------//
// This file contains function declarations
//--------------------------------------------------------------------------//

//--------------------------------------------------------------------------//
// common minidriv unidrv structures used by interface routines prototyped
// in this file.  minidriv specific structures are in minidriv\mdevice.h.
// unidrv specific structures are in unidrv\device.h.
//--------------------------------------------------------------------------//

//--------------------------------------------------------------------------//
// function typedefs
//--------------------------------------------------------------------------//

#ifdef STRICT
typedef WORD (CALLBACK* EDFPROC)(LPLOGFONT, LPTEXTMETRIC, WORD, LPVOID);
#else
typedef int (CALLBACK*  EDFPROC)();
#endif

//--------------------------------------------------------------------------//
// structures minidrivers use to communicate with unidrv
//--------------------------------------------------------------------------//

// This structure is the last parameter to GlEnable.
typedef struct
{
    short             cbSize;           // size of this structure
    HANDLE            hMd;              // handle to mini-driver
    LPFNOEMDUMP       fnOEMDump;        // NULL or pointer to OEMDump()
    LPFNOEMOUTPUTCHAR fnOEMOutputChar;  // NULL or pointer to OEMOutputChar()
} CUSTOMDATA, FAR * LPCUSTOMDATA;
// flags defined for the last parameter (WORD) of DUMP call-back
#define CB_LANDSCAPE        0x0001      // indicate the current orientation

//--------------------------------------------------------------------------//
// Exported routines to mini driver
//--------------------------------------------------------------------------//

LONG  WINAPI UniAdvancedSetUpDialog(HWND, HANDLE, LPDM, LPDM);
BOOL  WINAPI UniBitBlt(LPDV, short, short, LPBITMAP, short, short,
                       WORD, WORD, long, LPPBRUSH, LPDRAWMODE);
WORD  WINAPI UniStretchBlt(LPDV, WORD, WORD, WORD, WORD,
                                   LPBITMAP, WORD, WORD, WORD, WORD, 
                                   long, LPPBRUSH, LPDRAWMODE, LPRECT);
BOOL  WINAPI UniBitmapBits(LPDV, DWORD, DWORD, LPSTR);
DWORD WINAPI UniColorInfo(LPDV, DWORD, LPDWORD);
short WINAPI UniControl(LPDV, WORD, LPSTR, LPSTR);
short WINAPI UniCreateDIBitmap(VOID);
DWORD WINAPI UniDeviceCapabilities(LPSTR, LPSTR, WORD, LPSTR, LPDM, HANDLE);
short WINAPI UniDeviceMode(HWND, HANDLE, LPSTR, LPSTR);
BOOL  WINAPI UniDeviceSelectBitmap(LPDV, LPBITMAP, LPBITMAP, DWORD);
int   WINAPI UniDevInstall(HWND, LPSTR, LPSTR, LPSTR);
short WINAPI UniDIBBlt(LPBITMAP, WORD, WORD, WORD, LPSTR,
                       LPBITMAPINFO, LPDRAWMODE, LPSTR);
void  WINAPI UniDisable(LPDV);
short WINAPI UniEnable(LPDV, WORD, LPSTR, LPSTR, LPDM, LPCUSTOMDATA);
short WINAPI UniEnumDFonts(LPDV, LPSTR, EDFPROC, LPVOID);
short WINAPI UniEnumObj(LPDV, WORD, FARPROC, LPVOID);
int   WINAPI UniExtDeviceMode(HWND, HANDLE, LPDM, LPSTR, LPSTR, LPDM,
                              LPSTR, WORD);
int   WINAPI UniExtDeviceModePropSheet(HWND,HINSTANCE,LPSTR,LPSTR,
                            DWORD,LPFNADDPROPSHEETPAGE,LPARAM);
DWORD WINAPI UniExtTextOut(LPDV, short, short, LPRECT, LPSTR, int,
                           LPFONTINFO, LPDRAWMODE, LPTEXTXFORM, LPSHORT,
                           LPRECT, WORD);
short WINAPI UniGetCharWidth(LPDV, LPSHORT, WORD, WORD, LPFONTINFO,
                             LPDRAWMODE, LPTEXTXFORM);
short WINAPI UniOutput(LPDV, WORD, WORD, LPPOINT, LPPPEN, LPPBRUSH, LPDRAWMODE, LPRECT);
DWORD WINAPI UniPixel(LPDV, short, short, DWORD, LPDRAWMODE);
DWORD WINAPI UniRealizeObject(LPDV, short, LPSTR, LPSTR, LPTEXTXFORM);
short WINAPI UniScanLR(LPDV, short, short, DWORD, WORD);
short WINAPI UniSetDIBitsToDevice(LPDV, WORD, WORD, WORD, WORD, LPRECT,
                                  LPDRAWMODE, LPSTR, LPBITMAPINFOHEADER, LPSTR);
DWORD WINAPI UniStrBlt(LPDV, short, short, LPRECT, LPSTR, int,
                       LPFONTINFO, LPDRAWMODE, LPTEXTXFORM);
short WINAPI UniStretchDIB(LPDV, WORD, short, short, short, short,
                           short, short, short, short, LPSTR,
                           LPBITMAPINFOHEADER, LPSTR, DWORD, LPPBRUSH,
                           LPDRAWMODE, LPRECT);
//LONG WINAPI UniQueryDeviceNames(HANDLE, LPSTR);


short WINAPI WriteSpoolBuf(LPDV, LPSTR, WORD);

typedef short WINAPI WriteSpoolBuf_decl(LPDV,LPSTR,WORD);
typedef WriteSpoolBuf_decl FAR * LPWRITESPOOLBUF;
=== C:/Users/treeman/Desktop/windows nt source code\Source\Win2K3\NT\printscan\faxsrv\print\faxprint\faxdrv\win9x\faxdrv32\faxdrv32.c ===
/////////////////////////////////////////////////////////////////////////////
//  FILE          : faxdrv32.c                                             //
//                                                                         //
//  DESCRIPTION   :                                                        //
//                                                                         //
//  AUTHOR        : DanL.                                                  //
//                                                                         //
//  HISTORY       :                                                        //
//      Oct 19 1999 DannyL  Creation.                                      //
//                                                                         //
//  Copyright (C) 1999 Microsoft Corporation   All Rights Reserved         //
/////////////////////////////////////////////////////////////////////////////

#include "stdhdr.h"
#include <shellapi.h>
#include "faxdrv32.h"
#include "..\..\faxtiff.h"
#include "tifflib.h"
#include "covpg.h"
#include "faxreg.h"

DBG_DECLARE_MODULE("fxsdrv32");


//
// Defenitions and Macros
//
#define SZ_CONT             TEXT("...")
#define SZ_CONT_SIZE        (sizeof(SZ_CONT) / sizeof(TCHAR))
#define MAX_TITLE_LEN       128
#define MAX_MESSAGE_LEN     512


//
// Type defenitions
//

typedef struct tagDRIVER_CONTEXT
{
    CHAR    szPrinterName[MAX_PATH];
    CHAR    szDocName[MAX_DOC_NAME];
    CHAR    szTiffName[MAX_PATH];
    BOOL     bPrintToFile;
    CHAR    szPrintFile[MAX_PATH];
    CHAR    szPort[MAX_PORT_NAME];
    DEVDATA  dvdt;
    BOOL     bAttachment;
} DRIVER_CONTEXT, *PDRIVER_CONTEXT;


//
// Globals
//

int _debugLevel = 5;
HINSTANCE g_hInstance = NULL;


//
// Prototypes
//

BOOL WINAPI
thunk1632_ThunkConnect32(LPSTR      pszDll16,
                         LPSTR      pszDll32,
                         HINSTANCE  hInst,
                         DWORD      dwReason);


/*
 -  GetServerNameFromPort
 -
 *  Purpose:
 *      Extract the server name from port name formatted: "\\server\port".
 *
 *  Arguments:
 *      [in] lpcszPort - Port name.
 *      [out] lpsz - Server name.
 *
 *  Returns:
 *      LPTSTR - Server name.
 *
 *  Remarks:
 *      [N/A].
 */
_inline LPSTR GetServerNameFromPort(LPCSTR lpcszPort,LPSTR lpsz)
{
    if(!lpsz || !lpcszPort || !_tcscpy(lpsz,lpcszPort+2)) return NULL;
    return strtok(lpsz,TEXT("\\"));
}

/*
 -  CreateTempFaxFile
 -
 *  Purpose:
 *      Create a temporary file in the system temp directory. The file name is prefixed
 *      With the specified prefix.
 *
 *  Arguments:
 *      [in] szPrefix - Prefix for the tmp file.
 *      [out] szBuffer - Generated tmp file name.
 *
 *  Returns:
 *      BOOL - TRUE: success , FALSE: failure.
 *
 *  Remarks:
 *      [N/A]
 */
BOOL
CreateTempFaxFile(LPCSTR szPrefix,
                  CHAR   szBuffer[MAX_PATH])
{
    CHAR   szTempDir[MAX_PATH];

    DBG_PROC_ENTRY("CreateTempFaxFile");
    //
    // Allocate a memory buffer for holding the temporary filename
    //
    if (!GetTempPath(sizeof(szTempDir),szTempDir)||
        !GetTempFileName(szTempDir, szPrefix, 0, szBuffer))
    {
        RETURN FALSE;
    }
    RETURN TRUE;
}

/*
 -  FaxStartDoc
 -
 *  Purpose:
 *      Start a tiff document for hosting pages.
 *
 *  Arguments:
 *      [in] dwPtr - Contains a pointer to the driver context
 *      [in] lpdi  - Address of DOCINFO struct given by user in StartDoc.
 *
 *  Returns:
 *      short - START_DOC_FAIL: Operation failed
 *              START_DOC_OK: Operation succeded.
 *              START_DOC_ABORT: User aborted.
 *
 *  Remarks:
 *      TRUE / FALSE
 */
BOOL WINAPI
FaxStartDoc(DWORD dwPtr, LPDOCINFO lpdi)
{
    PDRIVER_CONTEXT pdrvctx ;
    DWORD           dwEnvSize;

    DBG_PROC_ENTRY("FaxStartDoc");

    //
    // Get the pointer to the driver context
    //
    pdrvctx = (PDRIVER_CONTEXT) dwPtr;
    ASSERT(pdrvctx);

    SafeStringCopy(pdrvctx->szDocName, !IsBadStringPtr(lpdi->lpszDocName, MAX_DOC_NAME) ? lpdi->lpszDocName : "");
    DBG_TRACE1("DocName: %s",pdrvctx->szDocName);
    DBG_TRACE1("lpdi->lpszOutput: %s", lpdi->lpszOutput);
    DBG_TRACE1("pdrvctx->szPort: %s", pdrvctx->szPort);

    //
    // Check if printing an attachment
    //
    dwEnvSize = GetEnvironmentVariable( FAX_ENVVAR_PRINT_FILE, NULL, 0 );
    if (dwEnvSize)
    {
        ASSERT (dwEnvSize < ARR_SIZE(pdrvctx->szPrintFile));
        if (0 == GetEnvironmentVariable( FAX_ENVVAR_PRINT_FILE,
                                         pdrvctx->szPrintFile,
                                         ARR_SIZE(pdrvctx->szPrintFile)))
        {
            DBG_CALL_FAIL("GetEnvironmentVariable",0)
            RETURN FALSE;
        }
        lpdi->lpszOutput = pdrvctx->szPrintFile;
        pdrvctx->bAttachment = TRUE;
    }
    else
    {
        HANDLE hMutex;
        BOOL bSuccess = FALSE;
        //
        // Check if the printing application is using DDE and did not create new process for printing
        // If it so, the environment variable FAX_ENVVAR_PRINT_FILE was not found
        //
        hMutex = OpenMutex(MUTEX_ALL_ACCESS, FALSE, FAXXP_MEM_MUTEX_NAME);
        if (hMutex)
        {
            if (WaitForSingleObject( hMutex, 1000 * 60 * 5) == WAIT_OBJECT_0)
            {
                HANDLE hSharedMem;
                //
                // we own the mutex...make sure we can open the shared memory region.
                //
                hSharedMem = OpenFileMapping(FILE_MAP_READ, FALSE, FAXXP_MEM_NAME);
                if (NULL == hSharedMem)
                {
                    DBG_CALL_FAIL("OpenFileMapping",GetLastError());
                }
                else
                {
                    //
                    // we own the mutex and we have the shared memory region open.
                    //

                    // check if we are printing to a file.
                    //
                    LPTSTR filename;

                    filename = (LPTSTR)MapViewOfFile(
                                             hSharedMem,
                                             FILE_MAP_READ,
                                             0,
                                             0,
                                             0
                                             );

                    if (!filename)
                    {
                        DBG_CALL_FAIL("MapViewOfFile",GetLastError());
                    }
                    else
                    {
                        //
                        // check if this is really the filename we want to print to.
                        //
                        if (lpdi->lpszDocName)
                        {
                            LPTSTR      lptstrSubStr = NULL;
                            LPTSTR lptstrTmpInputFile = _tcschr(filename, TEXT('\0'));
                            ASSERT (lptstrTmpInputFile);
                            lptstrTmpInputFile = _tcsinc(lptstrTmpInputFile);
                            Assert (_tcsclen(lptstrTmpInputFile));

                            lptstrSubStr = _tcsstr(lpdi->lpszDocName, lptstrTmpInputFile);
                            if (lptstrSubStr)
                            {
                                //
                                // We assume the shared memory was pointed to us
                                //
                                SafeStringCopy(pdrvctx->szPrintFile ,filename);
                                lpdi->lpszOutput = pdrvctx->szPrintFile;
                                pdrvctx->bAttachment = TRUE;
                                bSuccess = TRUE;
                            }
                        }
                        else
                        {
                            //
                            // To handle the race conditions between two diffrent instances of the printer driver over the shared memory created by PrintRandomDocument().
                            // We are using now two mechanisms for detecting printing of an attachment using PrintRandomDocument().
                            //     First we check if an environment variable is set (Set by PrintRandomDocument()). If it is set the driver knows it is an attachment printing.
                            //     If it is not set, the driver looks for a mutex controlling a shred memory created by PrintRandomDocument(). If it does not exist it is a printing to the fax server.
                            //     If the shared memory exists, the driver compares the document name in the DOCINFO provided by StartDoc, and the input file name in the shared memory.
                            //     If there is a match, it is printing of an attachment, else it is a printing to the fax server
                            // There is still a hole  in this implementation, if there is an open instance of the printing application, and the ShellExecuteEx does not create new process for printing, and the printing application does not set the lpszDocName in StartDoc to contain the input file name.

                              DBG_TRACE("No lpszDocName in DOCINFO - Could not verify the input file name in shared memory");
                        }
                        UnmapViewOfFile( filename );
                    }

                    if (!CloseHandle( hSharedMem ))
                    {
                        DBG_CALL_FAIL("CloseHandle",GetLastError());
                        // Try to continue...
                    }
                }
                ReleaseMutex( hMutex );
            }
            else
            {
                //
                //  Something went wrong with WaitForSingleObject
                //
                DBG_CALL_FAIL("WaitForSingleObject", GetLastError());
            }

            if (!CloseHandle( hMutex ))
            {
                DBG_CALL_FAIL("CloseHandle", GetLastError());
                // Try to continue...
            }

            if (FALSE == bSuccess)
            {
                RETURN FALSE;
            }
        }
    }

    //
    // Check if we need to output the job into a file (and not into our -
    // printer port).
    //
    if (lpdi->lpszOutput != NULL &&
        (_tcscmp(lpdi->lpszOutput,pdrvctx->szPort) != 0))
    {
        pdrvctx->bPrintToFile = TRUE;
        SafeStringCopy(pdrvctx->szTiffName,lpdi->lpszOutput);
        DBG_TRACE("Printing to file ...");
    }
    else
    {
        //
        // User wants to send the document to the fax.
        //
        DBG_TRACE("Printing to Fax Server ...");
        pdrvctx->bPrintToFile = FALSE;

        //
        //  client 'point and print' setup
        //
        if (FaxPointAndPrintSetup(pdrvctx->szPort,FALSE, g_hInstance))
        {
            DBG_TRACE("FaxPointAndPrintSetup succeeded");
        }
        else
        {
			DBG_CALL_FAIL("FaxPointAndPrintSetup",GetLastError());
        }


        if (!CreateTempFaxFile("fax",pdrvctx->szTiffName))
        {
            DBG_CALL_FAIL("CreateTempFaxFile",GetLastError());
            RETURN FALSE;
        }
    }
    pdrvctx->dvdt.hPrinter =CreateFileA(pdrvctx->szTiffName,   // pointer to name of the file
                                 GENERIC_WRITE,  // access (read-write) mode
                                 FILE_SHARE_READ,// share mode
                                 NULL,           // pointer to security attributes
                                 CREATE_ALWAYS,  // how to create
                                 FILE_ATTRIBUTE_NORMAL,   // file attributes
                                 NULL);// handle to file with attributes to copy

    if (pdrvctx->dvdt.hPrinter == INVALID_HANDLE_VALUE)
    {
        DBG_CALL_FAIL("CreateFileA",GetLastError());
        RETURN FALSE;
    }
    DBG_TRACE1("Fax temporary file name: %s",pdrvctx->szTiffName);

    pdrvctx->dvdt.endDevData =
    pdrvctx->dvdt.startDevData = &pdrvctx->dvdt;
    pdrvctx->dvdt.pageCount = 0;

    RETURN TRUE;
}


/*
 -  FaxAddPage
 -
 *  Purpose:
 *      Add a page to the tiff document.
 *
 *  Arguments:
 *      [in] dwPtr        - Contains a pointer to the driver context
 *      [in] lpBitmapData - Buffer of page bitmap.
 *      [in] dwPxlsWidth  - Width of bitmap (units: pixels)
 *      [in] dwPxlsHeight - Height of bitmap (units: pixels)
 *
 *  Returns:
 *      BOOL - TRUE: success , FALSE: failure.
 *
 *  Remarks:
 *      This function uses OutputPageBitmap call from faxdrv\faxtiff.
 *      In order to reuse the implementation OutputPageBitmap was altered in
 *      the build context of 95 to redirect the resulted tiff into a file whos
 *      handle if given in dvdt.hPrinter.
 */
BOOL WINAPI
FaxAddPage(DWORD dwPtr,
           LPBYTE lpBitmapData,
           DWORD dwPxlsWidth,
           DWORD dwPxlsHeight)
{
    BOOL br = TRUE;
    PDRIVER_CONTEXT pdrvctx;

    DBG_PROC_ENTRY("FaxAddPage");
    DBG_TRACE2("Proportions: %dx%d",dwPxlsWidth,dwPxlsHeight);

    //
    // Get the pointer to the driver context
    //
    pdrvctx = (PDRIVER_CONTEXT) dwPtr;
    ASSERT(pdrvctx);

    //
    // Initialize the structure needed by OutputPageBitmap
    //
    pdrvctx->dvdt.pageCount++;
    pdrvctx->dvdt.imageSize.cx = dwPxlsWidth;
    pdrvctx->dvdt.imageSize.cy = dwPxlsHeight;
    pdrvctx->dvdt.lineOffset = PadBitsToBytes(pdrvctx->dvdt.imageSize.cx, sizeof(DWORD));
    //
    // Add the bitmap into the tiff document created in FaxStartDoc.
    //
    if (!OutputPageBitmap(&pdrvctx->dvdt,(PBYTE)lpBitmapData))
    {
        DBG_CALL_FAIL("OutputPageBitmap",0);
        RETURN FALSE;
    }
    DBG_TRACE1("Page %d added successfully.",pdrvctx->dvdt.pageCount);

    RETURN TRUE;
}

/*
 -  FaxEndDoc
 -
 *  Purpose:
 *      Finalize creating the tiff document and optionally send it to the
 *      fax server.
 *
 *  Arguments:
 *      [in] dwPtr  - Contains a pointer to the driver context
 *      [in] bAbort - Specifies wheather job was finally aborted.
 *
 *  Returns:
 *      BOOL - TRUE: success , FALSE: failure.
 *
 *  Remarks:
 *      [N/A]
 */
BOOL WINAPI
FaxEndDoc(DWORD dwPtr, BOOL bAbort)
{
    BOOL bRc = TRUE;
    PDRIVER_CONTEXT pdrvctx;
    FAX_SEND_WIZARD_DATA  InitialWizardData = {0};
    FAX_SEND_WIZARD_DATA  WizardDataOutput = {0};
    DBG_PROC_ENTRY("FaxEndDoc");

    //
    // Get the pointer to the driver context
    //
    pdrvctx = (PDRIVER_CONTEXT) dwPtr;
    ASSERT(pdrvctx);

    if (pdrvctx->dvdt.hPrinter)
    {
        //
        // Output the tailing IFD.
        //
        if (!OutputDocTrailer(&pdrvctx->dvdt))
        {
            DBG_CALL_FAIL("OutputDocTrailer",GetLastError());
            bRc = FALSE;
        }
        //
        // Close the tiff file handle.
        //
        CloseHandle(pdrvctx->dvdt.hPrinter);
        pdrvctx->dvdt.hPrinter = NULL;
        if (FALSE == bRc)
        {
            goto Cleanup;
        }
    }

    if (!bAbort && !pdrvctx->bPrintToFile)
    {
        DWORDLONG dwlParentJobId;
        DWORDLONG* pdwlRecipientIds = NULL;
        FAX_JOB_PARAM_EX fjp;
        CHAR    szServerName[MAX_PORT_NAME]="";
        HANDLE  hFaxServer;
        HRESULT hRc;
        CHAR    lpszServerName[MAX_PORT_NAME]="";
        CHAR    szCoverPageTiffFile[MAX_PATH] = "";
        DWORD   dwFlags = FSW_PRINT_PREVIEW_OPTION;

        //
        // Convert to valid server name.
        //
        GetServerNameFromPort(pdrvctx->szPort,lpszServerName);

        // prepare structures and parameters
        WizardDataOutput.dwSizeOfStruct = sizeof(FAX_SEND_WIZARD_DATA);

        InitialWizardData.dwSizeOfStruct = sizeof(FAX_SEND_WIZARD_DATA);
        InitialWizardData.dwPageCount = pdrvctx->dvdt.pageCount;
        InitialWizardData.lptstrPreviewFile = StringDup(pdrvctx->szTiffName);
        if (!InitialWizardData.lptstrPreviewFile)
        {
            DBG_CALL_FAIL("Allocation error",GetLastError());
            bRc = FALSE;
            goto Cleanup;
        }

        if (GetEnvironmentVariable(TEXT("NTFaxSendNote"), NULL, 0))
        {
            dwFlags |=  FSW_USE_SEND_WIZARD | FSW_FORCE_COVERPAGE;
        }

        // If the file mapping succeeded enable the preview option
        //
        // Launch the FaxSendWizard
        //
        hRc = FaxSendWizard( (DWORD) NULL,
                             dwFlags,
                             lpszServerName,
                             pdrvctx->szPrinterName,
                             &InitialWizardData,
                             szCoverPageTiffFile,
                             ARR_SIZE(szCoverPageTiffFile),
                             &WizardDataOutput);
        if ( S_FALSE == hRc)
        {
            bAbort = TRUE;
            goto Cleanup;
        }
        if (FAILED(hRc))
        {
            DBG_CALL_FAIL("FaxSendWizard", (DWORD)hRc);
            bRc = FALSE;
            goto Cleanup;
        }

        //
        // Send the tiff ducument to the fax server.
        //

        //
        // Convert to valid server name.
        //
        GetServerNameFromPort(pdrvctx->szPort,szServerName);
        if (!FaxConnectFaxServer(szServerName,  // fax server name
                                 &hFaxServer))
        {
            DBG_CALL_FAIL("FaxConnectFaxServer",GetLastError());
            DBG_TRACE1("arg1: %s",NO_NULL_STR(szServerName));
            bRc = FALSE;
            goto Cleanup;
        }

        //
        // Allocate a buffer for recipient IDs
        //
        ASSERT(WizardDataOutput.dwNumberOfRecipients);
        if (!(pdwlRecipientIds = (DWORDLONG*)MemAlloc(WizardDataOutput.dwNumberOfRecipients * sizeof(DWORDLONG))))
        {
            DBG_CALL_FAIL("MemAlloc", GetLastError());
            FaxClose(hFaxServer);
            bRc = FALSE;
            goto Cleanup;
        }

        //
        // Initialize a FAX_JOB_PARAM_EX for fax sending from the wizard output.
        //
        fjp.dwSizeOfStruct = sizeof(fjp);
        fjp.dwScheduleAction = WizardDataOutput.dwScheduleAction;
        fjp.tmSchedule = WizardDataOutput.tmSchedule;
        fjp.dwReceiptDeliveryType = WizardDataOutput.dwReceiptDeliveryType;
        fjp.lptstrReceiptDeliveryAddress = WizardDataOutput.szReceiptDeliveryAddress;
        fjp.hCall = (HCALL)NULL;
        fjp.lptstrDocumentName = pdrvctx->szDocName;
        fjp.Priority = WizardDataOutput.Priority;
        // setting PageCount=0 means the server will count the number of pages in the job
        fjp.dwPageCount = 0;

		if (JSA_SPECIFIC_TIME == fjp.dwScheduleAction)
		{
			//
			// Calculate the scheduled time
			//
			DWORDLONG FileTime;
            SYSTEMTIME LocalTime;
            INT Minutes;
            INT SendMinutes;            
            //
            // Calculate the number of minutes from now to send and add that to the current time.
            //
            GetLocalTime( &LocalTime );
			if (!SystemTimeToFileTime( &LocalTime, (LPFILETIME) &FileTime ))
			{
				DBG_CALL_FAIL("SystemTimeToFileTime", GetLastError());
				FaxClose(hFaxServer);
				bRc = FALSE;
				goto Cleanup;
			}

            SendMinutes = (min(23,fjp.tmSchedule.wHour))*60 + min(59,fjp.tmSchedule.wMinute);
            Minutes = LocalTime.wHour * 60 + LocalTime.wMinute;
            Minutes = SendMinutes - Minutes;
            //
            // Account for passing midnight
            //
            if (Minutes < 0) 
            {
                Minutes += 24 * 60;
            }
            FileTime += (DWORDLONG)(Minutes * 60I64 * 1000I64 * 1000I64 * 10I64);
			if (!FileTimeToSystemTime((LPFILETIME) &FileTime, &fjp.tmSchedule ))
			{
				DBG_CALL_FAIL("FileTimeToSystemTime", GetLastError());
				FaxClose(hFaxServer);
				bRc = FALSE;
				goto Cleanup;
			}
		}

        if(!FaxSendDocumentEx(hFaxServer,
              (pdrvctx->dvdt.pageCount > 0)? pdrvctx->szTiffName : NULL,
              (WizardDataOutput.lpCoverPageInfo->lptstrCoverPageFileName == NULL)?
                  NULL:WizardDataOutput.lpCoverPageInfo,
              WizardDataOutput.lpSenderInfo,
              WizardDataOutput.dwNumberOfRecipients,
              WizardDataOutput.lpRecipientsInfo,
              &fjp,
              &dwlParentJobId,
              pdwlRecipientIds))
        {
            DBG_CALL_FAIL("FaxSendDocumentEx",GetLastError());
            bRc = FALSE;
        }
        FaxClose(hFaxServer);
        MemFree (pdwlRecipientIds);
    }

    //
    // Signal the printing application (PrintRandomDocument) that printing is completed or aborted
    //
    if (TRUE == pdrvctx->bAttachment)
    {
        HANDLE hEvent;
        TCHAR szEventName[FAXXP_ATTACH_EVENT_NAME_LEN] = {0};
        LPTSTR lptstrEventName = NULL;

        ASSERT(pdrvctx->szPrintFile);
        if (TRUE == bAbort)
        {
            //
            // Create the Abort event name
            //
            _tcscpy (szEventName, pdrvctx->szPrintFile);
            _tcscat (szEventName, FAXXP_ATTACH_ABORT_EVENT);
        }
        else
        {
            //
            // Create the EndDoc event name
            //
            _tcscpy (szEventName, pdrvctx->szPrintFile);
            _tcscat (szEventName, FAXXP_ATTACH_END_DOC_EVENT);
        }
        lptstrEventName = _tcsrchr(szEventName, TEXT('\\'));
        ASSERT (lptstrEventName);
        lptstrEventName = _tcsinc(lptstrEventName);

        hEvent = OpenEvent(EVENT_MODIFY_STATE, FALSE, lptstrEventName);
        if (NULL == hEvent)
        {
            DBG_CALL_FAIL("OpenEvent", GetLastError());
            DBG_TRACE1("Event name: %s",lptstrEventName);
            bRc = FALSE;
        }
        else
        {
            if (!SetEvent( hEvent ))
            {
                DBG_CALL_FAIL("SetEvent", GetLastError());
                bRc = FALSE;
            }

            if (!CloseHandle(hEvent))
            {
                DBG_CALL_FAIL("CloseHandle", GetLastError());
                // Try to continue...
            }
        }
    }

Cleanup:
    if (!pdrvctx->bPrintToFile || bAbort)
    {
#ifdef DEBUG
        if (bAbort)
        {
            DBG_TRACE("User aborted ...");
        }
#endif //DEBUG

        //
        // Delete temporary file.
        //
        if (!DeleteFile(pdrvctx->szTiffName))
        {
            DBG_TRACE1  ("File Name:[%s] not deleted!",pdrvctx->szTiffName);
        }
    }
    *pdrvctx->szTiffName = 0;
    MemFree (InitialWizardData.lptstrPreviewFile);
    FaxFreeSendWizardData(&WizardDataOutput);
    RETURN bRc;
}

/*
 -  FaxDevInstall
 -
 *  Purpose:
 *      Complete installation of all client components.
 *
 *  Arguments:
 *      [in] lpDevName - Device name.
 *      [in] lpOldPort - Old port name..
 *      [in] lpNewPort - New port name..
 *
 *  Returns:
 *      BOOL - TRUE: success , FALSE: failure.
 *
 *  Remarks:
 *      TBD
 */
BOOL WINAPI
FaxDevInstall(LPSTR lpDevName,LPSTR lpOldPort,LPSTR  lpNewPort)
{
    SDBG_PROC_ENTRY("FaxDevInstall");
    // TBD insert install code here
    RETURN TRUE;
}



/*
 -  FaxCreateDriverContext
 -
 *  Purpose:
 *      Create a new device context, initialize it and return it's pointer
 *
 *  Arguments:
 *      [in] lpDeviceName - Our device name.
 *      [in] lpPort - Out device port.
 *      [in]
 *      [out] lpDrvContext - Points to the buffer to recieve our 32 bit pointer
 *
 *  Returns:
 *      BOOL - TRUE: success , FALSE: failure.
 *
 *  Remarks:
 *      Data which is normally saved and maintained in the uni-driver is kept
 *      here for the tiff generation and fax sending.
 */
BOOL WINAPI
FaxCreateDriverContext(
                LPSTR      lpDeviceName,
                LPSTR      lpPort,
                LPDEVMODE  lpDevMode,
                LPDWORD    lpDrvContext)
{
    PDRIVER_CONTEXT pdrvctx;

    DBG_PROC_ENTRY("FaxCreateDriverContext");
    DBG_TRACE2("lpDeviceName:%s ,lpPort:%s",lpDeviceName,lpPort);
    DBG_TRACE1("lpDevMode: 0x%lx",(ULONG)lpDevMode);

    ASSERT(lpDeviceName && lpPort);

    //
    // Allocate a new driver context structure
    //
    if (!(pdrvctx = (PDRIVER_CONTEXT)malloc(sizeof(DRIVER_CONTEXT))))
    {
        DBG_CALL_FAIL("malloc",GetLastError());
        RETURN FALSE;
    }
    DBG_TRACE1("pdrvctx: 0x%lx",(ULONG)pdrvctx);
    memset(pdrvctx,0,sizeof(DRIVER_CONTEXT));

    //
    // Initialize the following fields:
    // - szPrinterName: Holds the driver name ('BOSFax')
    // - szPort: Holds the port ('\\<Machine Name>\BOSFAX')
    //
    SafeStringCopy(pdrvctx->szPrinterName, lpDeviceName);
    SafeStringCopy(pdrvctx->szPort, lpPort);
    if (NULL != lpDevMode)
    {
        //
        // Save the DEVMODE for the use of OutputPageBitmap
        //
        memcpy(&(pdrvctx->dvdt.dm.dmPublic), lpDevMode, sizeof(pdrvctx->dvdt.dm.dmPublic));
    }

    DBG_TRACE2("szPrinterName:[%s] szPort:[%s]",NO_NULL_STR(pdrvctx->szPrinterName),NO_NULL_STR(pdrvctx->szPort));
    //
    // Save our pointer
    //
    *lpDrvContext = (DWORD) pdrvctx;

    RETURN TRUE;
}

/*
 -  FaxResetDC
 -
 *  Purpose:
 *      Copies the essential context information from the old DC to the new one.
 *
 *  Arguments:
 *      [in] pdwOldPtr - Contains the address of a pointer to the old driver context.
 *      [in] pdwNewPtr - Contains the address of a pointer to the new driver context.
 *
 *  Returns:
 *      BOOL - TRUE: success , FALSE: failure.
 *
 *  Remarks:
 *      [N/A]
 */
BOOL WINAPI
FaxResetDC(LPDWORD pdwOldPtr, LPDWORD pdwNewPtr)
{
    PDRIVER_CONTEXT pOlddrvctx;
    PDRIVER_CONTEXT pNewdrvctx;
    DWORD dwTemp;


    DBG_PROC_ENTRY("FaxResetDC");

    //
    // Get the pointers to the driver context
    //
    pOlddrvctx = (PDRIVER_CONTEXT) *pdwOldPtr;
    pNewdrvctx = (PDRIVER_CONTEXT) *pdwNewPtr;
    ASSERT(pOlddrvctx && pNewdrvctx);

    //
    // ResetDC is interpreted by GDI to Enable (Create a new DC), Control with RESETDEVICE, and Disable (Delete the old DC).
    // We simply copy the new DEVMODE to the old driver context, and switch the driver context pointer.
    //
    memcpy(&(pOlddrvctx->dvdt.dm.dmPublic), &(pNewdrvctx->dvdt.dm.dmPublic), sizeof(pOlddrvctx->dvdt.dm.dmPublic));

    dwTemp = *pdwOldPtr;
    *pdwOldPtr = *pdwNewPtr;
    *pdwNewPtr = dwTemp;

    RETURN TRUE;
}// FaxResetDC


/*
 -  FaxDisable
 -
 *  Purpose:
 *      Clean out any leftovers once driver is disabled.
 *
 *  Arguments:
 *      [in] dwPtr     - Contains a pointer to the driver context
 *
 *  Returns:
 *      BOOL - TRUE: success , FALSE: failure.
 *
 *  Remarks:
 *      [N/A]
 */
BOOL WINAPI
FaxDisable(DWORD dwPtr)
{
    PDRIVER_CONTEXT pdrvctx = (PDRIVER_CONTEXT) dwPtr;

    DBG_PROC_ENTRY("FaxDisable");
    DBG_TRACE1("pdrvctx: 0x%lx", (ULONG)pdrvctx);
    ASSERT(pdrvctx);

    //
    // Check to see if there are any remmenants of an output file
    // not fully created
    //
    if (pdrvctx->dvdt.hPrinter)
    {
        CloseHandle(pdrvctx->dvdt.hPrinter);
        pdrvctx->dvdt.hPrinter = NULL;
        DeleteFile(pdrvctx->szTiffName);
    }

    //
    // Free the driver context
    //
    free(pdrvctx);
    RETURN TRUE;
}

//
// REMARK: when returning FALSE, implicitly loaded dlls are not freed !
//
BOOL WINAPI
DllMain(HINSTANCE hInst,
        DWORD dwReason,
        LPVOID lpvReserved)
{
    SDBG_PROC_ENTRY("DllMain");

#ifdef DBG_DEBUG
    {
		CHAR szModuleName[MAX_PATH]={0};
        GetModuleFileName(NULL,szModuleName,ARR_SIZE(szModuleName)-1);
        DBG_TRACE2("Module: %s dwReason=%ld",szModuleName,dwReason);
    }
#endif //DBG_DEBUG

    if( !(thunk1632_ThunkConnect32("fxsdrv",  // name of 16-bit DLL
                                   "fxsdrv32",// name of 32-bit DLL
                                   hInst,
                                   dwReason)) )
    {
        DBG_CALL_FAIL("thunk1632_ThunkConnect32",GetLastError());
        goto Error;
    }

    switch (dwReason)
    {
        case DLL_PROCESS_ATTACH:
            g_hInstance = hInst;
            break;

        case DLL_THREAD_ATTACH:
            break;

        case DLL_THREAD_DETACH:
            break;

        case DLL_PROCESS_DETACH:
            HeapCleanup();
            break;

    }
    RETURN TRUE;

Error:
    {
        // Hack to free implicitly loaded fxsapi.dll in case of failure.
        HMODULE hm = GetModuleHandle("FXSAPI.DLL");
        if (hm) FreeLibrary(hm);
        return FALSE;
    }
}
=== C:/Users/treeman/Desktop/windows nt source code\Source\Win2K3\NT\printscan\faxsrv\print\faxprint\faxdrv\win9x\ddk\printer\inc\winspool.h ===
/*++

Copyright (c) 1990-1995  Microsoft Corporation

Module Name:

    WinSpool.h

Abstract:

    Header file for Print APIs

Revision History:

--*/

#ifndef _WINSPOOL_
#define _WINSPOOL_


#ifdef __cplusplus
extern "C" {
#endif

#if(WINVER >= 0x0400)
#ifndef _PRSHT_H_
#include <prsht.h>
#endif
#endif /* WINVER >= 0x0400 */

#ifndef UNICODE_ONLY
typedef struct _PRINTER_INFO_1A {
    DWORD   Flags;
    LPSTR   pDescription;
    LPSTR   pName;
    LPSTR   pComment;
} PRINTER_INFO_1A, *PPRINTER_INFO_1A, *LPPRINTER_INFO_1A;
#endif //!UNICODE_ONLY
#ifndef ANSI_ONLY
typedef struct _PRINTER_INFO_1W {
    DWORD   Flags;
    LPWSTR  pDescription;
    LPWSTR  pName;
    LPWSTR  pComment;
} PRINTER_INFO_1W, *PPRINTER_INFO_1W, *LPPRINTER_INFO_1W;
#endif //!ANSI_ONLY
#ifdef UNICODE
typedef PRINTER_INFO_1W PRINTER_INFO_1;
typedef PPRINTER_INFO_1W PPRINTER_INFO_1;
typedef LPPRINTER_INFO_1W LPPRINTER_INFO_1;
#else
typedef PRINTER_INFO_1A PRINTER_INFO_1;
typedef PPRINTER_INFO_1A PPRINTER_INFO_1;
typedef LPPRINTER_INFO_1A LPPRINTER_INFO_1;
#endif // UNICODE

#ifndef UNICODE_ONLY
typedef struct _PRINTER_INFO_2A {
    LPSTR     pServerName;
    LPSTR     pPrinterName;
    LPSTR     pShareName;
    LPSTR     pPortName;
    LPSTR     pDriverName;
    LPSTR     pComment;
    LPSTR     pLocation;
    LPDEVMODEA pDevMode;
    LPSTR     pSepFile;
    LPSTR     pPrintProcessor;
    LPSTR     pDatatype;
    LPSTR     pParameters;
    PSECURITY_DESCRIPTOR pSecurityDescriptor;
    DWORD   Attributes;
    DWORD   Priority;
    DWORD   DefaultPriority;
    DWORD   StartTime;
    DWORD   UntilTime;
    DWORD   Status;
    DWORD   cJobs;
    DWORD   AveragePPM;
} PRINTER_INFO_2A, *PPRINTER_INFO_2A, *LPPRINTER_INFO_2A;
#endif //!UNICODE_ONLY
#ifndef ANSI_ONLY
typedef struct _PRINTER_INFO_2W {
    LPWSTR    pServerName;
    LPWSTR    pPrinterName;
    LPWSTR    pShareName;
    LPWSTR    pPortName;
    LPWSTR    pDriverName;
    LPWSTR    pComment;
    LPWSTR    pLocation;
    LPDEVMODEW pDevMode;
    LPWSTR    pSepFile;
    LPWSTR    pPrintProcessor;
    LPWSTR    pDatatype;
    LPWSTR    pParameters;
    PSECURITY_DESCRIPTOR pSecurityDescriptor;
    DWORD   Attributes;
    DWORD   Priority;
    DWORD   DefaultPriority;
    DWORD   StartTime;
    DWORD   UntilTime;
    DWORD   Status;
    DWORD   cJobs;
    DWORD   AveragePPM;
} PRINTER_INFO_2W, *PPRINTER_INFO_2W, *LPPRINTER_INFO_2W;
#endif //!ANSI_ONLY
#ifdef UNICODE
typedef PRINTER_INFO_2W PRINTER_INFO_2;
typedef PPRINTER_INFO_2W PPRINTER_INFO_2;
typedef LPPRINTER_INFO_2W LPPRINTER_INFO_2;
#else
typedef PRINTER_INFO_2A PRINTER_INFO_2;
typedef PPRINTER_INFO_2A PPRINTER_INFO_2;
typedef LPPRINTER_INFO_2A LPPRINTER_INFO_2;
#endif // UNICODE

typedef struct _PRINTER_INFO_3 {
    PSECURITY_DESCRIPTOR pSecurityDescriptor;
} PRINTER_INFO_3, *PPRINTER_INFO_3, *LPPRINTER_INFO_3;

#ifndef UNICODE_ONLY
typedef struct _PRINTER_INFO_4A {
    LPSTR   pPrinterName;
    LPSTR   pServerName;
    DWORD   Attributes;
} PRINTER_INFO_4A, *PPRINTER_INFO_4A, *LPPRINTER_INFO_4A;
#endif //!UNICODE_ONLY
#ifndef ANSI_ONLY
typedef struct _PRINTER_INFO_4W {
    LPWSTR  pPrinterName;
    LPWSTR  pServerName;
    DWORD   Attributes;
} PRINTER_INFO_4W, *PPRINTER_INFO_4W, *LPPRINTER_INFO_4W;
#endif //!ANSI_ONLY
#ifdef UNICODE
typedef PRINTER_INFO_4W PRINTER_INFO_4;
typedef PPRINTER_INFO_4W PPRINTER_INFO_4;
typedef LPPRINTER_INFO_4W LPPRINTER_INFO_4;
#else
typedef PRINTER_INFO_4A PRINTER_INFO_4;
typedef PPRINTER_INFO_4A PPRINTER_INFO_4;
typedef LPPRINTER_INFO_4A LPPRINTER_INFO_4;
#endif // UNICODE

#if(WINVER >= 0x0400)
#ifndef UNICODE_ONLY
typedef struct _PRINTER_INFO_5A {
    LPSTR   pPrinterName;
    LPSTR   pPortName;
    DWORD   Attributes;
    DWORD   DeviceNotSelectedTimeout;
    DWORD   TransmissionRetryTimeout;
} PRINTER_INFO_5A, *PPRINTER_INFO_5A, *LPPRINTER_INFO_5A;
#endif //!UNICODE_ONLY
#ifndef ANSI_ONLY
typedef struct _PRINTER_INFO_5W {
    LPWSTR  pPrinterName;
    LPWSTR  pPortName;
    DWORD   Attributes;
    DWORD   DeviceNotSelectedTimeout;
    DWORD   TransmissionRetryTimeout;
} PRINTER_INFO_5W, *PPRINTER_INFO_5W, *LPPRINTER_INFO_5W;
#endif //!ANSI_ONLY
#ifdef UNICODE
typedef PRINTER_INFO_5W PRINTER_INFO_5;
typedef PPRINTER_INFO_5W PPRINTER_INFO_5;
typedef LPPRINTER_INFO_5W LPPRINTER_INFO_5;
#else
typedef PRINTER_INFO_5A PRINTER_INFO_5;
typedef PPRINTER_INFO_5A PPRINTER_INFO_5;
typedef LPPRINTER_INFO_5A LPPRINTER_INFO_5;
#endif // UNICODE
#endif /* WINVER >= 0x0400 */

#define PRINTER_CONTROL_PAUSE            1
#define PRINTER_CONTROL_RESUME           2
#define PRINTER_CONTROL_PURGE            3
#if(WINVER >= 0x0400)
#define PRINTER_CONTROL_SET_STATUS       4
#endif /* WINVER >= 0x0400 */

#define PRINTER_STATUS_PAUSED            0x00000001
#define PRINTER_STATUS_ERROR             0x00000002
#define PRINTER_STATUS_PENDING_DELETION  0x00000004
#define PRINTER_STATUS_PAPER_JAM         0x00000008
#define PRINTER_STATUS_PAPER_OUT         0x00000010
#define PRINTER_STATUS_MANUAL_FEED       0x00000020
#define PRINTER_STATUS_PAPER_PROBLEM     0x00000040
#define PRINTER_STATUS_OFFLINE           0x00000080
#define PRINTER_STATUS_IO_ACTIVE         0x00000100
#define PRINTER_STATUS_BUSY              0x00000200
#define PRINTER_STATUS_PRINTING          0x00000400
#define PRINTER_STATUS_OUTPUT_BIN_FULL   0x00000800
#define PRINTER_STATUS_NOT_AVAILABLE     0x00001000
#define PRINTER_STATUS_WAITING           0x00002000
#define PRINTER_STATUS_PROCESSING        0x00004000
#define PRINTER_STATUS_INITIALIZING      0x00008000
#define PRINTER_STATUS_WARMING_UP        0x00010000
#define PRINTER_STATUS_TONER_LOW         0x00020000
#define PRINTER_STATUS_NO_TONER          0x00040000
#define PRINTER_STATUS_PAGE_PUNT         0x00080000
#define PRINTER_STATUS_USER_INTERVENTION 0x00100000
#define PRINTER_STATUS_OUT_OF_MEMORY     0x00200000
#define PRINTER_STATUS_DOOR_OPEN         0x00400000
#define PRINTER_STATUS_SERVER_UNKNOWN    0x00800000
#if(WINVER >= 0x0400)
#define PRINTER_STATUS_POWER_SAVE        0x01000000
#endif /* WINVER >= 0x0400 */


#define PRINTER_ATTRIBUTE_QUEUED         0x00000001
#define PRINTER_ATTRIBUTE_DIRECT         0x00000002
#define PRINTER_ATTRIBUTE_DEFAULT        0x00000004
#define PRINTER_ATTRIBUTE_SHARED         0x00000008
#define PRINTER_ATTRIBUTE_NETWORK        0x00000010
#define PRINTER_ATTRIBUTE_HIDDEN         0x00000020
#define PRINTER_ATTRIBUTE_LOCAL          0x00000040

#define PRINTER_ATTRIBUTE_ENABLE_DEVQ       0x00000080
#define PRINTER_ATTRIBUTE_KEEPPRINTEDJOBS   0x00000100
#define PRINTER_ATTRIBUTE_DO_COMPLETE_FIRST 0x00000200

#if(WINVER >= 0x0400)
#define PRINTER_ATTRIBUTE_WORK_OFFLINE   0x00000400
#define PRINTER_ATTRIBUTE_ENABLE_BIDI    0x00000800
#endif /* WINVER >= 0x0400 */



#define NO_PRIORITY   0
#define MAX_PRIORITY 99
#define MIN_PRIORITY  1
#define DEF_PRIORITY  1

#ifndef UNICODE_ONLY
typedef struct _JOB_INFO_1A {
   DWORD    JobId;
   LPSTR      pPrinterName;
   LPSTR      pMachineName;
   LPSTR      pUserName;
   LPSTR      pDocument;
   LPSTR      pDatatype;
   LPSTR      pStatus;
   DWORD    Status;
   DWORD    Priority;
   DWORD    Position;
   DWORD    TotalPages;
   DWORD    PagesPrinted;
   SYSTEMTIME Submitted;
} JOB_INFO_1A, *PJOB_INFO_1A, *LPJOB_INFO_1A;
#endif //!UNICODE_ONLY
#ifndef ANSI_ONLY
typedef struct _JOB_INFO_1W {
   DWORD    JobId;
   LPWSTR     pPrinterName;
   LPWSTR     pMachineName;
   LPWSTR     pUserName;
   LPWSTR     pDocument;
   LPWSTR     pDatatype;
   LPWSTR     pStatus;
   DWORD    Status;
   DWORD    Priority;
   DWORD    Position;
   DWORD    TotalPages;
   DWORD    PagesPrinted;
   SYSTEMTIME Submitted;
} JOB_INFO_1W, *PJOB_INFO_1W, *LPJOB_INFO_1W;
#endif //!ANSI_ONLY
#ifdef UNICODE
typedef JOB_INFO_1W JOB_INFO_1;
typedef PJOB_INFO_1W PJOB_INFO_1;
typedef LPJOB_INFO_1W LPJOB_INFO_1;
#else
typedef JOB_INFO_1A JOB_INFO_1;
typedef PJOB_INFO_1A PJOB_INFO_1;
typedef LPJOB_INFO_1A LPJOB_INFO_1;
#endif // UNICODE

#ifndef UNICODE_ONLY
typedef struct _JOB_INFO_2A {
   DWORD    JobId;
   LPSTR      pPrinterName;
   LPSTR      pMachineName;
   LPSTR      pUserName;
   LPSTR      pDocument;
   LPSTR      pNotifyName;
   LPSTR      pDatatype;
   LPSTR      pPrintProcessor;
   LPSTR      pParameters;
   LPSTR      pDriverName;
   LPDEVMODEA pDevMode;
   LPSTR      pStatus;
   PSECURITY_DESCRIPTOR pSecurityDescriptor;
   DWORD    Status;
   DWORD    Priority;
   DWORD    Position;
   DWORD    StartTime;
   DWORD    UntilTime;
   DWORD    TotalPages;
   DWORD    Size;
   SYSTEMTIME Submitted;    // Time the job was spooled
   DWORD    Time;           // How many seconds the job has been printing
   DWORD    PagesPrinted;
} JOB_INFO_2A, *PJOB_INFO_2A, *LPJOB_INFO_2A;
#endif //!UNICODE_ONLY
#ifndef ANSI_ONLY
typedef struct _JOB_INFO_2W {
   DWORD    JobId;
   LPWSTR     pPrinterName;
   LPWSTR     pMachineName;
   LPWSTR     pUserName;
   LPWSTR     pDocument;
   LPWSTR     pNotifyName;
   LPWSTR     pDatatype;
   LPWSTR     pPrintProcessor;
   LPWSTR     pParameters;
   LPWSTR     pDriverName;
   LPDEVMODEW pDevMode;
   LPWSTR     pStatus;
   PSECURITY_DESCRIPTOR pSecurityDescriptor;
   DWORD    Status;
   DWORD    Priority;
   DWORD    Position;
   DWORD    StartTime;
   DWORD    UntilTime;
   DWORD    TotalPages;
   DWORD    Size;
   SYSTEMTIME Submitted;    // Time the job was spooled
   DWORD    Time;           // How many seconds the job has been printing
   DWORD    PagesPrinted;
} JOB_INFO_2W, *PJOB_INFO_2W, *LPJOB_INFO_2W;
#endif //!ANSI_ONLY
#ifdef UNICODE
typedef JOB_INFO_2W JOB_INFO_2;
typedef PJOB_INFO_2W PJOB_INFO_2;
typedef LPJOB_INFO_2W LPJOB_INFO_2;
#else
typedef JOB_INFO_2A JOB_INFO_2;
typedef PJOB_INFO_2A PJOB_INFO_2;
typedef LPJOB_INFO_2A LPJOB_INFO_2;
#endif // UNICODE

#define JOB_CONTROL_PAUSE              1
#define JOB_CONTROL_RESUME             2
#define JOB_CONTROL_CANCEL             3
#define JOB_CONTROL_RESTART            4
#if(WINVER >= 0x0400)
#define JOB_CONTROL_DELETE             5
#endif /* WINVER >= 0x0400 */

#define JOB_STATUS_PAUSED       0x00000001
#define JOB_STATUS_ERROR        0x00000002
#define JOB_STATUS_DELETING     0x00000004
#define JOB_STATUS_SPOOLING     0x00000008
#define JOB_STATUS_PRINTING     0x00000010
#define JOB_STATUS_OFFLINE      0x00000020
#define JOB_STATUS_PAPEROUT     0x00000040
#define JOB_STATUS_PRINTED      0x00000080
#define JOB_STATUS_DELETED      0x00000100
#define JOB_STATUS_BLOCKED_DEVQ 0x00000200
#if(WINVER >= 0x0400)
#define JOB_STATUS_USER_INTERVENTION   0x00000400
#endif /* WINVER >= 0x0400 */

#define JOB_POSITION_UNSPECIFIED       0

#ifndef UNICODE_ONLY
typedef struct _ADDJOB_INFO_1A {
    LPSTR     Path;
    DWORD   JobId;
} ADDJOB_INFO_1A, *PADDJOB_INFO_1A, *LPADDJOB_INFO_1A;
#endif //!UNICODE_ONLY
#ifndef ANSI_ONLY
typedef struct _ADDJOB_INFO_1W {
    LPWSTR    Path;
    DWORD   JobId;
} ADDJOB_INFO_1W, *PADDJOB_INFO_1W, *LPADDJOB_INFO_1W;
#endif //!ANSI_ONLY
#ifdef UNICODE
typedef ADDJOB_INFO_1W ADDJOB_INFO_1;
typedef PADDJOB_INFO_1W PADDJOB_INFO_1;
typedef LPADDJOB_INFO_1W LPADDJOB_INFO_1;
#else
typedef ADDJOB_INFO_1A ADDJOB_INFO_1;
typedef PADDJOB_INFO_1A PADDJOB_INFO_1;
typedef LPADDJOB_INFO_1A LPADDJOB_INFO_1;
#endif // UNICODE

#ifndef UNICODE_ONLY
typedef struct _DRIVER_INFO_1A {
    LPSTR     pName;              // QMS 810
} DRIVER_INFO_1A, *PDRIVER_INFO_1A, *LPDRIVER_INFO_1A;
#endif //!UNICODE_ONLY
#ifndef ANSI_ONLY
typedef struct _DRIVER_INFO_1W {
    LPWSTR    pName;              // QMS 810
} DRIVER_INFO_1W, *PDRIVER_INFO_1W, *LPDRIVER_INFO_1W;
#endif //!ANSI_ONLY
#ifdef UNICODE
typedef DRIVER_INFO_1W DRIVER_INFO_1;
typedef PDRIVER_INFO_1W PDRIVER_INFO_1;
typedef LPDRIVER_INFO_1W LPDRIVER_INFO_1;
#else
typedef DRIVER_INFO_1A DRIVER_INFO_1;
typedef PDRIVER_INFO_1A PDRIVER_INFO_1;
typedef LPDRIVER_INFO_1A LPDRIVER_INFO_1;
#endif // UNICODE

#ifndef UNICODE_ONLY
typedef struct _DRIVER_INFO_2A {
    DWORD   cVersion;
    LPSTR     pName;              // QMS 810
    LPSTR     pEnvironment;       // Win32 x86
    LPSTR     pDriverPath;        // c:\drivers\pscript.dll
    LPSTR     pDataFile;          // c:\drivers\QMS810.PPD
    LPSTR     pConfigFile;        // c:\drivers\PSCRPTUI.DLL
} DRIVER_INFO_2A, *PDRIVER_INFO_2A, *LPDRIVER_INFO_2A;
#endif //!UNICODE_ONLY
#ifndef ANSI_ONLY
typedef struct _DRIVER_INFO_2W {
    DWORD   cVersion;
    LPWSTR    pName;              // QMS 810
    LPWSTR    pEnvironment;       // Win32 x86
    LPWSTR    pDriverPath;        // c:\drivers\pscript.dll
    LPWSTR    pDataFile;          // c:\drivers\QMS810.PPD
    LPWSTR    pConfigFile;        // c:\drivers\PSCRPTUI.DLL
} DRIVER_INFO_2W, *PDRIVER_INFO_2W, *LPDRIVER_INFO_2W;
#endif //!ANSI_ONLY
#ifdef UNICODE
typedef DRIVER_INFO_2W DRIVER_INFO_2;
typedef PDRIVER_INFO_2W PDRIVER_INFO_2;
typedef LPDRIVER_INFO_2W LPDRIVER_INFO_2;
#else
typedef DRIVER_INFO_2A DRIVER_INFO_2;
typedef PDRIVER_INFO_2A PDRIVER_INFO_2;
typedef LPDRIVER_INFO_2A LPDRIVER_INFO_2;
#endif // UNICODE

#if(WINVER >= 0x0400)
#ifndef UNICODE_ONLY
typedef struct _DRIVER_INFO_3A {
    DWORD   cVersion;
    LPSTR     pName;                    // QMS 810
    LPSTR     pEnvironment;             // Win32 x86
    LPSTR     pDriverPath;              // c:\drivers\pscript.dll
    LPSTR     pDataFile;                // c:\drivers\QMS810.PPD
    LPSTR     pConfigFile;              // c:\drivers\PSCRPTUI.DLL
    LPSTR     pHelpFile;                // c:\drivers\PSCRPTUI.HLP
    LPSTR     pDependentFiles;          // PSCRIPT.DLL\0QMS810.PPD\0PSCRIPTUI.DLL\0PSCRIPTUI.HLP\0PSTEST.TXT\0\0
    LPSTR     pMonitorName;             // "PJL monitor"
    LPSTR     pDefaultDataType;         // "EMF"
} DRIVER_INFO_3A, *PDRIVER_INFO_3A, *LPDRIVER_INFO_3A;
#endif //!UNICODE_ONLY
#ifndef ANSI_ONLY
typedef struct _DRIVER_INFO_3W {
    DWORD   cVersion;
    LPWSTR    pName;                    // QMS 810
    LPWSTR    pEnvironment;             // Win32 x86
    LPWSTR    pDriverPath;              // c:\drivers\pscript.dll
    LPWSTR    pDataFile;                // c:\drivers\QMS810.PPD
    LPWSTR    pConfigFile;              // c:\drivers\PSCRPTUI.DLL
    LPWSTR    pHelpFile;                // c:\drivers\PSCRPTUI.HLP
    LPWSTR    pDependentFiles;          // PSCRIPT.DLL\0QMS810.PPD\0PSCRIPTUI.DLL\0PSCRIPTUI.HLP\0PSTEST.TXT\0\0
    LPWSTR    pMonitorName;             // "PJL monitor"
    LPWSTR    pDefaultDataType;         // "EMF"
} DRIVER_INFO_3W, *PDRIVER_INFO_3W, *LPDRIVER_INFO_3W;
#endif //!ANSI_ONLY
#ifdef UNICODE
typedef DRIVER_INFO_3W DRIVER_INFO_3;
typedef PDRIVER_INFO_3W PDRIVER_INFO_3;
typedef LPDRIVER_INFO_3W LPDRIVER_INFO_3;
#else
typedef DRIVER_INFO_3A DRIVER_INFO_3;
typedef PDRIVER_INFO_3A PDRIVER_INFO_3;
typedef LPDRIVER_INFO_3A LPDRIVER_INFO_3;
#endif // UNICODE
#endif /* WINVER >= 0x0400 */

#ifndef UNICODE_ONLY
typedef struct _DOC_INFO_1A {
    LPSTR     pDocName;
    LPSTR     pOutputFile;
    LPSTR     pDatatype;
} DOC_INFO_1A, *PDOC_INFO_1A, *LPDOC_INFO_1A;
#endif //!UNICODE_ONLY
#ifndef ANSI_ONLY
typedef struct _DOC_INFO_1W {
    LPWSTR    pDocName;
    LPWSTR    pOutputFile;
    LPWSTR    pDatatype;
} DOC_INFO_1W, *PDOC_INFO_1W, *LPDOC_INFO_1W;
#endif //!ANSI_ONLY
#ifdef UNICODE
typedef DOC_INFO_1W DOC_INFO_1;
typedef PDOC_INFO_1W PDOC_INFO_1;
typedef LPDOC_INFO_1W LPDOC_INFO_1;
#else
typedef DOC_INFO_1A DOC_INFO_1;
typedef PDOC_INFO_1A PDOC_INFO_1;
typedef LPDOC_INFO_1A LPDOC_INFO_1;
#endif // UNICODE

#ifndef UNICODE_ONLY
typedef struct _FORM_INFO_1A {
    DWORD   Flags;
    LPSTR     pName;
    SIZEL   Size;
    RECTL   ImageableArea;
} FORM_INFO_1A, *PFORM_INFO_1A, *LPFORM_INFO_1A;
#endif //!UNICODE_ONLY
#ifndef ANSI_ONLY
typedef struct _FORM_INFO_1W {
    DWORD   Flags;
    LPWSTR    pName;
    SIZEL   Size;
    RECTL   ImageableArea;
} FORM_INFO_1W, *PFORM_INFO_1W, *LPFORM_INFO_1W;
#endif //!ANSI_ONLY
#ifdef UNICODE
typedef FORM_INFO_1W FORM_INFO_1;
typedef PFORM_INFO_1W PFORM_INFO_1;
typedef LPFORM_INFO_1W LPFORM_INFO_1;
#else
typedef FORM_INFO_1A FORM_INFO_1;
typedef PFORM_INFO_1A PFORM_INFO_1;
typedef LPFORM_INFO_1A LPFORM_INFO_1;
#endif // UNICODE

#if(WINVER >= 0x0400)
#ifndef UNICODE_ONLY
typedef struct _DOC_INFO_2A {
    LPSTR     pDocName;
    LPSTR     pOutputFile;
    LPSTR     pDatatype;
    DWORD   dwMode;
    DWORD   JobId;
} DOC_INFO_2A, *PDOC_INFO_2A, *LPDOC_INFO_2A;
#endif //!UNICODE_ONLY
#ifndef ANSI_ONLY
typedef struct _DOC_INFO_2W {
    LPWSTR    pDocName;
    LPWSTR    pOutputFile;
    LPWSTR    pDatatype;
    DWORD   dwMode;
    DWORD   JobId;
} DOC_INFO_2W, *PDOC_INFO_2W, *LPDOC_INFO_2W;
#endif //!ANSI_ONLY
#ifdef UNICODE
typedef DOC_INFO_2W DOC_INFO_2;
typedef PDOC_INFO_2W PDOC_INFO_2;
typedef LPDOC_INFO_2W LPDOC_INFO_2;
#else
typedef DOC_INFO_2A DOC_INFO_2;
typedef PDOC_INFO_2A PDOC_INFO_2;
typedef LPDOC_INFO_2A LPDOC_INFO_2;
#endif // UNICODE

#define DI_CHANNEL              1    // start direct read/write channel,
#define DI_CHANNEL_WRITE        2    // Direct write only - background read thread ok
#define DI_READ_SPOOL_JOB       3

#endif /* WINVER >= 0x0400 */

#define FORM_BUILTIN    0x00000001


#ifndef UNICODE_ONLY
typedef struct _PRINTPROCESSOR_INFO_1A {
    LPSTR     pName;
} PRINTPROCESSOR_INFO_1A, *PPRINTPROCESSOR_INFO_1A, *LPPRINTPROCESSOR_INFO_1A;
#endif //!UNICODE_ONLY
#ifndef ANSI_ONLY
typedef struct _PRINTPROCESSOR_INFO_1W {
    LPWSTR    pName;
} PRINTPROCESSOR_INFO_1W, *PPRINTPROCESSOR_INFO_1W, *LPPRINTPROCESSOR_INFO_1W;
#endif //!ANSI_ONLY
#ifdef UNICODE
typedef PRINTPROCESSOR_INFO_1W PRINTPROCESSOR_INFO_1;
typedef PPRINTPROCESSOR_INFO_1W PPRINTPROCESSOR_INFO_1;
typedef LPPRINTPROCESSOR_INFO_1W LPPRINTPROCESSOR_INFO_1;
#else
typedef PRINTPROCESSOR_INFO_1A PRINTPROCESSOR_INFO_1;
typedef PPRINTPROCESSOR_INFO_1A PPRINTPROCESSOR_INFO_1;
typedef LPPRINTPROCESSOR_INFO_1A LPPRINTPROCESSOR_INFO_1;
#endif // UNICODE

#ifndef UNICODE_ONLY
typedef struct _PORT_INFO_1A {
    LPSTR     pName;
} PORT_INFO_1A, *PPORT_INFO_1A, *LPPORT_INFO_1A;
#endif //!UNICODE_ONLY
#ifndef ANSI_ONLY
typedef struct _PORT_INFO_1W {
    LPWSTR    pName;
} PORT_INFO_1W, *PPORT_INFO_1W, *LPPORT_INFO_1W;
#endif //!ANSI_ONLY
#ifdef UNICODE
typedef PORT_INFO_1W PORT_INFO_1;
typedef PPORT_INFO_1W PPORT_INFO_1;
typedef LPPORT_INFO_1W LPPORT_INFO_1;
#else
typedef PORT_INFO_1A PORT_INFO_1;
typedef PPORT_INFO_1A PPORT_INFO_1;
typedef LPPORT_INFO_1A LPPORT_INFO_1;
#endif // UNICODE

#if(WINVER >= 0x0400)
#ifndef UNICODE_ONLY
typedef struct _PORT_INFO_2A {
    LPSTR     pPortName;
    LPSTR     pMonitorName;
    LPSTR     pDescription;
    DWORD     fPortType;
    DWORD     Reserved;
} PORT_INFO_2A, *PPORT_INFO_2A, *LPPORT_INFO_2A;
#endif //!UNICODE_ONLY
#ifndef ANSI_ONLY
typedef struct _PORT_INFO_2W {
    LPWSTR    pPortName;
    LPWSTR    pMonitorName;
    LPWSTR    pDescription;
    DWORD     fPortType;
    DWORD     Reserved;
} PORT_INFO_2W, *PPORT_INFO_2W, *LPPORT_INFO_2W;
#endif //!ANSI_ONLY
#ifdef UNICODE
typedef PORT_INFO_2W PORT_INFO_2;
typedef PPORT_INFO_2W PPORT_INFO_2;
typedef LPPORT_INFO_2W LPPORT_INFO_2;
#else
typedef PORT_INFO_2A PORT_INFO_2;
typedef PPORT_INFO_2A PPORT_INFO_2;
typedef LPPORT_INFO_2A LPPORT_INFO_2;
#endif // UNICODE

#define PORT_TYPE_WRITE         0x0001
#define PORT_TYPE_READ          0x0002
#define PORT_TYPE_REDIRECTED    0x0004
#define PORT_TYPE_NET_ATTACHED  0x0008
#endif /* WINVER >= 0x0400 */

#ifndef UNICODE_ONLY
typedef struct _MONITOR_INFO_1A{
    LPSTR     pName;
} MONITOR_INFO_1A, *PMONITOR_INFO_1A, *LPMONITOR_INFO_1A;
#endif //!UNICODE_ONLY
#ifndef ANSI_ONLY
typedef struct _MONITOR_INFO_1W{
    LPWSTR    pName;
} MONITOR_INFO_1W, *PMONITOR_INFO_1W, *LPMONITOR_INFO_1W;
#endif //!ANSI_ONLY
#ifdef UNICODE
typedef MONITOR_INFO_1W MONITOR_INFO_1;
typedef PMONITOR_INFO_1W PMONITOR_INFO_1;
typedef LPMONITOR_INFO_1W LPMONITOR_INFO_1;
#else
typedef MONITOR_INFO_1A MONITOR_INFO_1;
typedef PMONITOR_INFO_1A PMONITOR_INFO_1;
typedef LPMONITOR_INFO_1A LPMONITOR_INFO_1;
#endif // UNICODE

#ifndef UNICODE_ONLY
typedef struct _MONITOR_INFO_2A{
    LPSTR     pName;
    LPSTR     pEnvironment;
    LPSTR     pDLLName;
} MONITOR_INFO_2A, *PMONITOR_INFO_2A, *LPMONITOR_INFO_2A;
#endif //!UNICODE_ONLY
#ifndef ANSI_ONLY
typedef struct _MONITOR_INFO_2W{
    LPWSTR    pName;
    LPWSTR    pEnvironment;
    LPWSTR    pDLLName;
} MONITOR_INFO_2W, *PMONITOR_INFO_2W, *LPMONITOR_INFO_2W;
#endif //!ANSI_ONLY
#ifdef UNICODE
typedef MONITOR_INFO_2W MONITOR_INFO_2;
typedef PMONITOR_INFO_2W PMONITOR_INFO_2;
typedef LPMONITOR_INFO_2W LPMONITOR_INFO_2;
#else
typedef MONITOR_INFO_2A MONITOR_INFO_2;
typedef PMONITOR_INFO_2A PMONITOR_INFO_2;
typedef LPMONITOR_INFO_2A LPMONITOR_INFO_2;
#endif // UNICODE

#ifndef UNICODE_ONLY
typedef struct _DATATYPES_INFO_1A{
    LPSTR     pName;
} DATATYPES_INFO_1A, *PDATATYPES_INFO_1A, *LPDATATYPES_INFO_1A;
#endif //!UNICODE_ONLY
#ifndef ANSI_ONLY
typedef struct _DATATYPES_INFO_1W{
    LPWSTR    pName;
} DATATYPES_INFO_1W, *PDATATYPES_INFO_1W, *LPDATATYPES_INFO_1W;
#endif //!ANSI_ONLY
#ifdef UNICODE
typedef DATATYPES_INFO_1W DATATYPES_INFO_1;
typedef PDATATYPES_INFO_1W PDATATYPES_INFO_1;
typedef LPDATATYPES_INFO_1W LPDATATYPES_INFO_1;
#else
typedef DATATYPES_INFO_1A DATATYPES_INFO_1;
typedef PDATATYPES_INFO_1A PDATATYPES_INFO_1;
typedef LPDATATYPES_INFO_1A LPDATATYPES_INFO_1;
#endif // UNICODE

#ifndef UNICODE_ONLY
typedef struct _PRINTER_DEFAULTSA{
    LPSTR         pDatatype;
    LPDEVMODEA pDevMode;
    ACCESS_MASK DesiredAccess;
} PRINTER_DEFAULTSA, *PPRINTER_DEFAULTSA, *LPPRINTER_DEFAULTSA;
#endif //!UNICODE_ONLY
#ifndef ANSI_ONLY
typedef struct _PRINTER_DEFAULTSW{
    LPWSTR        pDatatype;
    LPDEVMODEW pDevMode;
    ACCESS_MASK DesiredAccess;
} PRINTER_DEFAULTSW, *PPRINTER_DEFAULTSW, *LPPRINTER_DEFAULTSW;
#endif //!ANSI_ONLY
#ifdef UNICODE
typedef PRINTER_DEFAULTSW PRINTER_DEFAULTS;
typedef PPRINTER_DEFAULTSW PPRINTER_DEFAULTS;
typedef LPPRINTER_DEFAULTSW LPPRINTER_DEFAULTS;
#else
typedef PRINTER_DEFAULTSA PRINTER_DEFAULTS;
typedef PPRINTER_DEFAULTSA PPRINTER_DEFAULTS;
typedef LPPRINTER_DEFAULTSA LPPRINTER_DEFAULTS;
#endif // UNICODE

#ifndef UNICODE_ONLY
BOOL
WINAPI
EnumPrintersA(
    DWORD   Flags,
    LPSTR   Name,
    DWORD   Level,
    LPBYTE  pPrinterEnum,
    DWORD   cbBuf,
    LPDWORD pcbNeeded,
    LPDWORD pcReturned
);
#endif //!UNICODE_ONLY
#ifndef ANSI_ONLY
BOOL
WINAPI
EnumPrintersW(
    DWORD   Flags,
    LPWSTR   Name,
    DWORD   Level,
    LPBYTE  pPrinterEnum,
    DWORD   cbBuf,
    LPDWORD pcbNeeded,
    LPDWORD pcReturned
);
#endif //!ANSI_ONLY
#ifdef UNICODE
#define EnumPrinters  EnumPrintersW
#else
#define EnumPrinters  EnumPrintersA
#endif // !UNICODE

#define PRINTER_ENUM_DEFAULT     0x00000001
#define PRINTER_ENUM_LOCAL       0x00000002
#define PRINTER_ENUM_CONNECTIONS 0x00000004
#define PRINTER_ENUM_FAVORITE    0x00000004
#define PRINTER_ENUM_NAME        0x00000008
#define PRINTER_ENUM_REMOTE      0x00000010
#define PRINTER_ENUM_SHARED      0x00000020
#define PRINTER_ENUM_NETWORK     0x00000040

#define PRINTER_ENUM_EXPAND      0x00004000
#define PRINTER_ENUM_CONTAINER   0x00008000

#define PRINTER_ENUM_ICONMASK    0x00ff0000
#define PRINTER_ENUM_ICON1       0x00010000
#define PRINTER_ENUM_ICON2       0x00020000
#define PRINTER_ENUM_ICON3       0x00040000
#define PRINTER_ENUM_ICON4       0x00080000
#define PRINTER_ENUM_ICON5       0x00100000
#define PRINTER_ENUM_ICON6       0x00200000
#define PRINTER_ENUM_ICON7       0x00400000
#define PRINTER_ENUM_ICON8       0x00800000

#ifndef UNICODE_ONLY
BOOL
WINAPI
OpenPrinterA(
   LPSTR    pPrinterName,
   LPHANDLE phPrinter,
   LPPRINTER_DEFAULTSA pDefault
);
#endif //!UNICODE_ONLY
#ifndef ANSI_ONLY
BOOL
WINAPI
OpenPrinterW(
   LPWSTR    pPrinterName,
   LPHANDLE phPrinter,
   LPPRINTER_DEFAULTSW pDefault
);
#endif //!ANSI_ONLY
#ifdef UNICODE
#define OpenPrinter  OpenPrinterW
#else
#define OpenPrinter  OpenPrinterA
#endif // !UNICODE

#ifndef UNICODE_ONLY
BOOL
WINAPI
ResetPrinterA(
   HANDLE   hPrinter,
   LPPRINTER_DEFAULTSA pDefault
);
#endif //!UNICODE_ONLY
#ifndef ANSI_ONLY
BOOL
WINAPI
ResetPrinterW(
   HANDLE   hPrinter,
   LPPRINTER_DEFAULTSW pDefault
);
#endif //!ANSI_ONLY
#ifdef UNICODE
#define ResetPrinter  ResetPrinterW
#else
#define ResetPrinter  ResetPrinterA
#endif // !UNICODE

#ifndef UNICODE_ONLY
BOOL
WINAPI
SetJobA(
    HANDLE  hPrinter,
    DWORD   JobId,
    DWORD   Level,
    LPBYTE  pJob,
    DWORD   Command
);
#endif //!UNICODE_ONLY
#ifndef ANSI_ONLY
BOOL
WINAPI
SetJobW(
    HANDLE  hPrinter,
    DWORD   JobId,
    DWORD   Level,
    LPBYTE  pJob,
    DWORD   Command
);
#endif //!ANSI_ONLY
#ifdef UNICODE
#define SetJob  SetJobW
#else
#define SetJob  SetJobA
#endif // !UNICODE

#ifndef UNICODE_ONLY
BOOL
WINAPI
GetJobA(
   HANDLE   hPrinter,
   DWORD    JobId,
   DWORD    Level,
   LPBYTE   pJob,
   DWORD    cbBuf,
   LPDWORD  pcbNeeded
);
#endif //!UNICODE_ONLY
#ifndef ANSI_ONLY
BOOL
WINAPI
GetJobW(
   HANDLE   hPrinter,
   DWORD    JobId,
   DWORD    Level,
   LPBYTE   pJob,
   DWORD    cbBuf,
   LPDWORD  pcbNeeded
);
#endif //!ANSI_ONLY
#ifdef UNICODE
#define GetJob  GetJobW
#else
#define GetJob  GetJobA
#endif // !UNICODE

#ifndef UNICODE_ONLY
BOOL
WINAPI
EnumJobsA(
    HANDLE  hPrinter,
    DWORD   FirstJob,
    DWORD   NoJobs,
    DWORD   Level,
    LPBYTE  pJob,
    DWORD   cbBuf,
    LPDWORD pcbNeeded,
    LPDWORD pcReturned
);
#endif //!UNICODE_ONLY
#ifndef ANSI_ONLY
BOOL
WINAPI
EnumJobsW(
    HANDLE  hPrinter,
    DWORD   FirstJob,
    DWORD   NoJobs,
    DWORD   Level,
    LPBYTE  pJob,
    DWORD   cbBuf,
    LPDWORD pcbNeeded,
    LPDWORD pcReturned
);
#endif //!ANSI_ONLY
#ifdef UNICODE
#define EnumJobs  EnumJobsW
#else
#define EnumJobs  EnumJobsA
#endif // !UNICODE

#ifndef UNICODE_ONLY
HANDLE
WINAPI
AddPrinterA(
    LPSTR   pName,
    DWORD   Level,
    LPBYTE  pPrinter
);
#endif //!UNICODE_ONLY
#ifndef ANSI_ONLY
HANDLE
WINAPI
AddPrinterW(
    LPWSTR   pName,
    DWORD   Level,
    LPBYTE  pPrinter
);
#endif //!ANSI_ONLY
#ifdef UNICODE
#define AddPrinter  AddPrinterW
#else
#define AddPrinter  AddPrinterA
#endif // !UNICODE

BOOL
WINAPI
DeletePrinter(
   HANDLE   hPrinter
);

#ifndef UNICODE_ONLY
BOOL
WINAPI
SetPrinterA(
    HANDLE  hPrinter,
    DWORD   Level,
    LPBYTE  pPrinter,
    DWORD   Command
);
#endif //!UNICODE_ONLY
#ifndef ANSI_ONLY
BOOL
WINAPI
SetPrinterW(
    HANDLE  hPrinter,
    DWORD   Level,
    LPBYTE  pPrinter,
    DWORD   Command
);
#endif //!ANSI_ONLY
#ifdef UNICODE
#define SetPrinter  SetPrinterW
#else
#define SetPrinter  SetPrinterA
#endif // !UNICODE

#ifndef UNICODE_ONLY
BOOL
WINAPI
GetPrinterA(
    HANDLE  hPrinter,
    DWORD   Level,
    LPBYTE  pPrinter,
    DWORD   cbBuf,
    LPDWORD pcbNeeded
);
#endif //!UNICODE_ONLY
#ifndef ANSI_ONLY
BOOL
WINAPI
GetPrinterW(
    HANDLE  hPrinter,
    DWORD   Level,
    LPBYTE  pPrinter,
    DWORD   cbBuf,
    LPDWORD pcbNeeded
);
#endif //!ANSI_ONLY
#ifdef UNICODE
#define GetPrinter  GetPrinterW
#else
#define GetPrinter  GetPrinterA
#endif // !UNICODE

#ifndef UNICODE_ONLY
BOOL
WINAPI
AddPrinterDriverA(
    LPSTR   pName,
    DWORD   Level,
    LPBYTE  pDriverInfo
);
#endif //!UNICODE_ONLY
#ifndef ANSI_ONLY
BOOL
WINAPI
AddPrinterDriverW(
    LPWSTR   pName,
    DWORD   Level,
    LPBYTE  pDriverInfo
);
#endif //!ANSI_ONLY
#ifdef UNICODE
#define AddPrinterDriver  AddPrinterDriverW
#else
#define AddPrinterDriver  AddPrinterDriverA
#endif // !UNICODE

#ifndef UNICODE_ONLY
BOOL
WINAPI
EnumPrinterDriversA(
    LPSTR   pName,
    LPSTR   pEnvironment,
    DWORD   Level,
    LPBYTE  pDriverInfo,
    DWORD   cbBuf,
    LPDWORD pcbNeeded,
    LPDWORD pcReturned
);
#endif //!UNICODE_ONLY
#ifndef ANSI_ONLY
BOOL
WINAPI
EnumPrinterDriversW(
    LPWSTR   pName,
    LPWSTR   pEnvironment,
    DWORD   Level,
    LPBYTE  pDriverInfo,
    DWORD   cbBuf,
    LPDWORD pcbNeeded,
    LPDWORD pcReturned
);
#endif //!ANSI_ONLY
#ifdef UNICODE
#define EnumPrinterDrivers  EnumPrinterDriversW
#else
#define EnumPrinterDrivers  EnumPrinterDriversA
#endif // !UNICODE

#ifndef UNICODE_ONLY
BOOL
WINAPI
GetPrinterDriverA(
    HANDLE  hPrinter,
    LPSTR   pEnvironment,
    DWORD   Level,
    LPBYTE  pDriverInfo,
    DWORD   cbBuf,
    LPDWORD pcbNeeded
);
#endif //!UNICODE_ONLY
#ifndef ANSI_ONLY
BOOL
WINAPI
GetPrinterDriverW(
    HANDLE  hPrinter,
    LPWSTR   pEnvironment,
    DWORD   Level,
    LPBYTE  pDriverInfo,
    DWORD   cbBuf,
    LPDWORD pcbNeeded
);
#endif //!ANSI_ONLY
#ifdef UNICODE
#define GetPrinterDriver  GetPrinterDriverW
#else
#define GetPrinterDriver  GetPrinterDriverA
#endif // !UNICODE

#ifndef UNICODE_ONLY
BOOL
WINAPI
GetPrinterDriverDirectoryA(
    LPSTR   pName,
    LPSTR   pEnvironment,
    DWORD   Level,
    LPBYTE  pDriverDirectory,
    DWORD   cbBuf,
    LPDWORD pcbNeeded
);
#endif //!UNICODE_ONLY
#ifndef ANSI_ONLY
BOOL
WINAPI
GetPrinterDriverDirectoryW(
    LPWSTR   pName,
    LPWSTR   pEnvironment,
    DWORD   Level,
    LPBYTE  pDriverDirectory,
    DWORD   cbBuf,
    LPDWORD pcbNeeded
);
#endif //!ANSI_ONLY
#ifdef UNICODE
#define GetPrinterDriverDirectory  GetPrinterDriverDirectoryW
#else
#define GetPrinterDriverDirectory  GetPrinterDriverDirectoryA
#endif // !UNICODE

#ifndef UNICODE_ONLY
BOOL
WINAPI
DeletePrinterDriverA(
   LPSTR    pName,
   LPSTR    pEnvironment,
   LPSTR    pDriverName
);
#endif //!UNICODE_ONLY
#ifndef ANSI_ONLY
BOOL
WINAPI
DeletePrinterDriverW(
   LPWSTR    pName,
   LPWSTR    pEnvironment,
   LPWSTR    pDriverName
);
#endif //!ANSI_ONLY
#ifdef UNICODE
#define DeletePrinterDriver  DeletePrinterDriverW
#else
#define DeletePrinterDriver  DeletePrinterDriverA
#endif // !UNICODE

#ifndef UNICODE_ONLY
BOOL
WINAPI
AddPrintProcessorA(
    LPSTR   pName,
    LPSTR   pEnvironment,
    LPSTR   pPathName,
    LPSTR   pPrintProcessorName
);
#endif //!UNICODE_ONLY
#ifndef ANSI_ONLY
BOOL
WINAPI
AddPrintProcessorW(
    LPWSTR   pName,
    LPWSTR   pEnvironment,
    LPWSTR   pPathName,
    LPWSTR   pPrintProcessorName
);
#endif //!ANSI_ONLY
#ifdef UNICODE
#define AddPrintProcessor  AddPrintProcessorW
#else
#define AddPrintProcessor  AddPrintProcessorA
#endif // !UNICODE

#ifndef UNICODE_ONLY
BOOL
WINAPI
EnumPrintProcessorsA(
    LPSTR   pName,
    LPSTR   pEnvironment,
    DWORD   Level,
    LPBYTE  pPrintProcessorInfo,
    DWORD   cbBuf,
    LPDWORD pcbNeeded,
    LPDWORD pcReturned
);
#endif //!UNICODE_ONLY
#ifndef ANSI_ONLY
BOOL
WINAPI
EnumPrintProcessorsW(
    LPWSTR   pName,
    LPWSTR   pEnvironment,
    DWORD   Level,
    LPBYTE  pPrintProcessorInfo,
    DWORD   cbBuf,
    LPDWORD pcbNeeded,
    LPDWORD pcReturned
);
#endif //!ANSI_ONLY
#ifdef UNICODE
#define EnumPrintProcessors  EnumPrintProcessorsW
#else
#define EnumPrintProcessors  EnumPrintProcessorsA
#endif // !UNICODE



#ifndef UNICODE_ONLY
BOOL
WINAPI
GetPrintProcessorDirectoryA(
    LPSTR   pName,
    LPSTR   pEnvironment,
    DWORD   Level,
    LPBYTE  pPrintProcessorInfo,
    DWORD   cbBuf,
    LPDWORD pcbNeeded
);
#endif //!UNICODE_ONLY
#ifndef ANSI_ONLY
BOOL
WINAPI
GetPrintProcessorDirectoryW(
    LPWSTR   pName,
    LPWSTR   pEnvironment,
    DWORD   Level,
    LPBYTE  pPrintProcessorInfo,
    DWORD   cbBuf,
    LPDWORD pcbNeeded
);
#endif //!ANSI_ONLY
#ifdef UNICODE
#define GetPrintProcessorDirectory  GetPrintProcessorDirectoryW
#else
#define GetPrintProcessorDirectory  GetPrintProcessorDirectoryA
#endif // !UNICODE

#ifndef UNICODE_ONLY
BOOL
WINAPI
EnumPrintProcessorDatatypesA(
    LPSTR   pName,
    LPSTR   pPrintProcessorName,
    DWORD   Level,
    LPBYTE  pDatatypes,
    DWORD   cbBuf,
    LPDWORD pcbNeeded,
    LPDWORD pcReturned
);
#endif //!UNICODE_ONLY
#ifndef ANSI_ONLY
BOOL
WINAPI
EnumPrintProcessorDatatypesW(
    LPWSTR   pName,
    LPWSTR   pPrintProcessorName,
    DWORD   Level,
    LPBYTE  pDatatypes,
    DWORD   cbBuf,
    LPDWORD pcbNeeded,
    LPDWORD pcReturned
);
#endif //!ANSI_ONLY
#ifdef UNICODE
#define EnumPrintProcessorDatatypes  EnumPrintProcessorDatatypesW
#else
#define EnumPrintProcessorDatatypes  EnumPrintProcessorDatatypesA
#endif // !UNICODE

#ifndef UNICODE_ONLY
BOOL
WINAPI
DeletePrintProcessorA(
    LPSTR   pName,
    LPSTR   pEnvironment,
    LPSTR   pPrintProcessorName
);
#endif //!UNICODE_ONLY
#ifndef ANSI_ONLY
BOOL
WINAPI
DeletePrintProcessorW(
    LPWSTR   pName,
    LPWSTR   pEnvironment,
    LPWSTR   pPrintProcessorName
);
#endif //!ANSI_ONLY
#ifdef UNICODE
#define DeletePrintProcessor  DeletePrintProcessorW
#else
#define DeletePrintProcessor  DeletePrintProcessorA
#endif // !UNICODE

#ifndef UNICODE_ONLY
DWORD
WINAPI
StartDocPrinterA(
    HANDLE  hPrinter,
    DWORD   Level,
    LPBYTE  pDocInfo
);
#endif //!UNICODE_ONLY
#ifndef ANSI_ONLY
DWORD
WINAPI
StartDocPrinterW(
    HANDLE  hPrinter,
    DWORD   Level,
    LPBYTE  pDocInfo
);
#endif //!ANSI_ONLY
#ifdef UNICODE
#define StartDocPrinter  StartDocPrinterW
#else
#define StartDocPrinter  StartDocPrinterA
#endif // !UNICODE

BOOL
WINAPI
StartPagePrinter(
    HANDLE  hPrinter
);

BOOL
WINAPI
WritePrinter(
    HANDLE  hPrinter,
    LPVOID  pBuf,
    DWORD   cbBuf,
    LPDWORD pcWritten
);

BOOL
WINAPI
EndPagePrinter(
   HANDLE   hPrinter
);

BOOL
WINAPI
AbortPrinter(
   HANDLE   hPrinter
);

BOOL
WINAPI
ReadPrinter(
    HANDLE  hPrinter,
    LPVOID  pBuf,
    DWORD   cbBuf,
    LPDWORD pNoBytesRead
);

BOOL
WINAPI
EndDocPrinter(
   HANDLE   hPrinter
);

#ifndef UNICODE_ONLY
BOOL
WINAPI
AddJobA(
    HANDLE  hPrinter,
    DWORD   Level,
    LPBYTE  pData,
    DWORD   cbBuf,
    LPDWORD pcbNeeded
);
#endif //!UNICODE_ONLY
#ifndef ANSI_ONLY
BOOL
WINAPI
AddJobW(
    HANDLE  hPrinter,
    DWORD   Level,
    LPBYTE  pData,
    DWORD   cbBuf,
    LPDWORD pcbNeeded
);
#endif //!ANSI_ONLY
#ifdef UNICODE
#define AddJob  AddJobW
#else
#define AddJob  AddJobA
#endif // !UNICODE

BOOL
WINAPI
ScheduleJob(
    HANDLE  hPrinter,
    DWORD   JobId
);

BOOL
WINAPI
PrinterProperties(
    HWND    hWnd,
    HANDLE  hPrinter
);

#ifndef UNICODE_ONLY
LONG
WINAPI
DocumentPropertiesA(
    HWND      hWnd,
    HANDLE    hPrinter,
    LPSTR   pDeviceName,
    PDEVMODEA pDevModeOutput,
    PDEVMODEA pDevModeInput,
    DWORD     fMode
);
#endif //!UNICODE_ONLY
#ifndef ANSI_ONLY
LONG
WINAPI
DocumentPropertiesW(
    HWND      hWnd,
    HANDLE    hPrinter,
    LPWSTR   pDeviceName,
    PDEVMODEW pDevModeOutput,
    PDEVMODEW pDevModeInput,
    DWORD     fMode
);
#endif //!ANSI_ONLY
#ifdef UNICODE
#define DocumentProperties  DocumentPropertiesW
#else
#define DocumentProperties  DocumentPropertiesA
#endif // !UNICODE

#ifndef UNICODE_ONLY
LONG
WINAPI
AdvancedDocumentPropertiesA(
    HWND    hWnd,
    HANDLE  hPrinter,
    LPSTR   pDeviceName,
    PDEVMODEA pDevModeOutput,
    PDEVMODEA pDevModeInput
);
#endif //!UNICODE_ONLY
#ifndef ANSI_ONLY
LONG
WINAPI
AdvancedDocumentPropertiesW(
    HWND    hWnd,
    HANDLE  hPrinter,
    LPWSTR   pDeviceName,
    PDEVMODEW pDevModeOutput,
    PDEVMODEW pDevModeInput
);
#endif //!ANSI_ONLY
#ifdef UNICODE
#define AdvancedDocumentProperties  AdvancedDocumentPropertiesW
#else
#define AdvancedDocumentProperties  AdvancedDocumentPropertiesA
#endif // !UNICODE



#ifndef UNICODE_ONLY
DWORD
WINAPI
GetPrinterDataA(
    HANDLE   hPrinter,
    LPSTR    pValueName,
    LPDWORD  pType,
    LPBYTE   pData,
    DWORD    nSize,
    LPDWORD  pcbNeeded
);
#endif //!UNICODE_ONLY
#ifndef ANSI_ONLY
DWORD
WINAPI
GetPrinterDataW(
    HANDLE   hPrinter,
    LPWSTR    pValueName,
    LPDWORD  pType,
    LPBYTE   pData,
    DWORD    nSize,
    LPDWORD  pcbNeeded
);
#endif //!ANSI_ONLY
#ifdef UNICODE
#define GetPrinterData  GetPrinterDataW
#else
#define GetPrinterData  GetPrinterDataA
#endif // !UNICODE



#ifndef UNICODE_ONLY
DWORD
WINAPI
SetPrinterDataA(
    HANDLE  hPrinter,
    LPSTR   pValueName,
    DWORD   Type,
    LPBYTE  pData,
    DWORD   cbData
);
#endif //!UNICODE_ONLY
#ifndef ANSI_ONLY
DWORD
WINAPI
SetPrinterDataW(
    HANDLE  hPrinter,
    LPWSTR   pValueName,
    DWORD   Type,
    LPBYTE  pData,
    DWORD   cbData
);
#endif //!ANSI_ONLY
#ifdef UNICODE
#define SetPrinterData  SetPrinterDataW
#else
#define SetPrinterData  SetPrinterDataA
#endif // !UNICODE

#define PRINTER_NOTIFY_TYPE 0x00
#define JOB_NOTIFY_TYPE     0x01

#define PRINTER_NOTIFY_FIELD_SERVER_NAME             0x00
#define PRINTER_NOTIFY_FIELD_PRINTER_NAME            0x01
#define PRINTER_NOTIFY_FIELD_SHARE_NAME              0x02
#define PRINTER_NOTIFY_FIELD_PORT_NAME               0x03
#define PRINTER_NOTIFY_FIELD_DRIVER_NAME             0x04
#define PRINTER_NOTIFY_FIELD_COMMENT                 0x05
#define PRINTER_NOTIFY_FIELD_LOCATION                0x06
#define PRINTER_NOTIFY_FIELD_DEVMODE                 0x07
#define PRINTER_NOTIFY_FIELD_SEPFILE                 0x08
#define PRINTER_NOTIFY_FIELD_PRINT_PROCESSOR         0x09
#define PRINTER_NOTIFY_FIELD_PARAMETERS              0x0A
#define PRINTER_NOTIFY_FIELD_DATATYPE                0x0B
#define PRINTER_NOTIFY_FIELD_SECURITY_DESCRIPTOR     0x0C
#define PRINTER_NOTIFY_FIELD_ATTRIBUTES              0x0D
#define PRINTER_NOTIFY_FIELD_PRIORITY                0x0E
#define PRINTER_NOTIFY_FIELD_DEFAULT_PRIORITY        0x0F
#define PRINTER_NOTIFY_FIELD_START_TIME              0x10
#define PRINTER_NOTIFY_FIELD_UNTIL_TIME              0x11
#define PRINTER_NOTIFY_FIELD_STATUS                  0x12
#define PRINTER_NOTIFY_FIELD_STATUS_STRING           0x13
#define PRINTER_NOTIFY_FIELD_CJOBS                   0x14
#define PRINTER_NOTIFY_FIELD_AVERAGE_PPM             0x15
#define PRINTER_NOTIFY_FIELD_TOTAL_PAGES             0x16
#define PRINTER_NOTIFY_FIELD_PAGES_PRINTED           0x17
#define PRINTER_NOTIFY_FIELD_TOTAL_BYTES             0x18
#define PRINTER_NOTIFY_FIELD_BYTES_PRINTED           0x19

#define JOB_NOTIFY_FIELD_PRINTER_NAME                0x00
#define JOB_NOTIFY_FIELD_MACHINE_NAME                0x01
#define JOB_NOTIFY_FIELD_PORT_NAME                   0x02
#define JOB_NOTIFY_FIELD_USER_NAME                   0x03
#define JOB_NOTIFY_FIELD_NOTIFY_NAME                 0x04
#define JOB_NOTIFY_FIELD_DATATYPE                    0x05
#define JOB_NOTIFY_FIELD_PRINT_PROCESSOR             0x06
#define JOB_NOTIFY_FIELD_PARAMETERS                  0x07
#define JOB_NOTIFY_FIELD_DRIVER_NAME                 0x08
#define JOB_NOTIFY_FIELD_DEVMODE                     0x09
#define JOB_NOTIFY_FIELD_STATUS                      0x0A
#define JOB_NOTIFY_FIELD_STATUS_STRING               0x0B
#define JOB_NOTIFY_FIELD_SECURITY_DESCRIPTOR         0x0C
#define JOB_NOTIFY_FIELD_DOCUMENT                    0x0D
#define JOB_NOTIFY_FIELD_PRIORITY                    0x0E
#define JOB_NOTIFY_FIELD_POSITION                    0x0F
#define JOB_NOTIFY_FIELD_SUBMITTED                   0x10
#define JOB_NOTIFY_FIELD_START_TIME                  0x11
#define JOB_NOTIFY_FIELD_UNTIL_TIME                  0x12
#define JOB_NOTIFY_FIELD_TIME                        0x13
#define JOB_NOTIFY_FIELD_TOTAL_PAGES                 0x14
#define JOB_NOTIFY_FIELD_PAGES_PRINTED               0x15
#define JOB_NOTIFY_FIELD_TOTAL_BYTES                 0x16
#define JOB_NOTIFY_FIELD_BYTES_PRINTED               0x17


typedef struct _PRINTER_NOTIFY_OPTIONS_TYPE {
    WORD Type;
    WORD Reserved0;
    DWORD Reserved1;
    DWORD Reserved2;
    DWORD Count;
    PWORD pFields;
} PRINTER_NOTIFY_OPTIONS_TYPE, *PPRINTER_NOTIFY_OPTIONS_TYPE, *LPPRINTER_NOTIFY_OPTIONS_TYPE;


#define PRINTER_NOTIFY_OPTIONS_REFRESH  0x01

typedef struct _PRINTER_NOTIFY_OPTIONS {
    DWORD Version;
    DWORD Flags;
    DWORD Count;
    PPRINTER_NOTIFY_OPTIONS_TYPE pTypes;
} PRINTER_NOTIFY_OPTIONS, *PPRINTER_NOTIFY_OPTIONS, *LPPRINTER_NOTIFY_OPTIONS;



#define PRINTER_NOTIFY_INFO_DISCARDED       0x01

typedef struct _PRINTER_NOTIFY_INFO_DATA {
    WORD Type;
    WORD Field;
    DWORD Reserved;
    DWORD Id;
    union {
        DWORD adwData[2];
        struct {
            DWORD  cbBuf;
            LPVOID pBuf;
        } Data;
    } NotifyData;
} PRINTER_NOTIFY_INFO_DATA, *PPRINTER_NOTIFY_INFO_DATA, *LPPRINTER_NOTIFY_INFO_DATA;

typedef struct _PRINTER_NOTIFY_INFO {
    DWORD Version;
    DWORD Flags;
    DWORD Count;
    PRINTER_NOTIFY_INFO_DATA aData[1];
} PRINTER_NOTIFY_INFO, *PPRINTER_NOTIFY_INFO, *LPPRINTER_NOTIFY_INFO;

DWORD
WINAPI
WaitForPrinterChange(
    HANDLE  hPrinter,
    DWORD   Flags
);

HANDLE
WINAPI
FindFirstPrinterChangeNotification(
    HANDLE  hPrinter,
    DWORD   fdwFlags,
    DWORD   fdwOptions,
    LPVOID  pPrinterNotifyOptions
);


BOOL
WINAPI
FindNextPrinterChangeNotification(
    HANDLE hChange,
    PDWORD pdwChange,
    LPVOID pvReserved,
    LPVOID *ppPrinterNotifyInfo
);

BOOL
WINAPI
FreePrinterNotifyInfo(
    PPRINTER_NOTIFY_INFO pPrinterNotifyInfo
);

BOOL
WINAPI
FindClosePrinterChangeNotification(
    HANDLE hChange
);

#define PRINTER_CHANGE_ADD_PRINTER              0x00000001
#define PRINTER_CHANGE_SET_PRINTER              0x00000002
#define PRINTER_CHANGE_DELETE_PRINTER           0x00000004
#define PRINTER_CHANGE_FAILED_CONNECTION_PRINTER    0x00000008
#define PRINTER_CHANGE_PRINTER                  0x000000FF
#define PRINTER_CHANGE_ADD_JOB                  0x00000100
#define PRINTER_CHANGE_SET_JOB                  0x00000200
#define PRINTER_CHANGE_DELETE_JOB               0x00000400
#define PRINTER_CHANGE_WRITE_JOB                0x00000800
#define PRINTER_CHANGE_JOB                      0x0000FF00
#define PRINTER_CHANGE_ADD_FORM                 0x00010000
#define PRINTER_CHANGE_SET_FORM                 0x00020000
#define PRINTER_CHANGE_DELETE_FORM              0x00040000
#define PRINTER_CHANGE_FORM                     0x00070000
#define PRINTER_CHANGE_ADD_PORT                 0x00100000
#define PRINTER_CHANGE_CONFIGURE_PORT           0x00200000
#define PRINTER_CHANGE_DELETE_PORT              0x00400000
#define PRINTER_CHANGE_PORT                     0x00700000
#define PRINTER_CHANGE_ADD_PRINT_PROCESSOR      0x01000000
#define PRINTER_CHANGE_DELETE_PRINT_PROCESSOR   0x04000000
#define PRINTER_CHANGE_PRINT_PROCESSOR          0x07000000
#define PRINTER_CHANGE_ADD_PRINTER_DRIVER       0x10000000
#define PRINTER_CHANGE_SET_PRINTER_DRIVER       0x20000000
#define PRINTER_CHANGE_DELETE_PRINTER_DRIVER    0x40000000
#define PRINTER_CHANGE_PRINTER_DRIVER           0x70000000
#define PRINTER_CHANGE_TIMEOUT                  0x80000000
#define PRINTER_CHANGE_ALL                      0x7777FFFF

#ifndef UNICODE_ONLY
DWORD
WINAPI
PrinterMessageBoxA(
    HANDLE  hPrinter,
    DWORD   Error,
    HWND    hWnd,
    LPSTR   pText,
    LPSTR   pCaption,
    DWORD   dwType
);
#endif //!UNICODE_ONLY
#ifndef ANSI_ONLY
DWORD
WINAPI
PrinterMessageBoxW(
    HANDLE  hPrinter,
    DWORD   Error,
    HWND    hWnd,
    LPWSTR   pText,
    LPWSTR   pCaption,
    DWORD   dwType
);
#endif //!ANSI_ONLY
#ifdef UNICODE
#define PrinterMessageBox  PrinterMessageBoxW
#else
#define PrinterMessageBox  PrinterMessageBoxA
#endif // !UNICODE



#define PRINTER_ERROR_INFORMATION   0x80000000
#define PRINTER_ERROR_WARNING       0x40000000
#define PRINTER_ERROR_SEVERE        0x20000000

#define PRINTER_ERROR_OUTOFPAPER    0x00000001
#define PRINTER_ERROR_JAM           0x00000002
#define PRINTER_ERROR_OUTOFTONER    0x00000004

BOOL
WINAPI
ClosePrinter(
    HANDLE hPrinter
);

#ifndef UNICODE_ONLY
BOOL
WINAPI
AddFormA(
    HANDLE  hPrinter,
    DWORD   Level,
    LPBYTE  pForm
);
#endif //!UNICODE_ONLY
#ifndef ANSI_ONLY
BOOL
WINAPI
AddFormW(
    HANDLE  hPrinter,
    DWORD   Level,
    LPBYTE  pForm
);
#endif //!ANSI_ONLY
#ifdef UNICODE
#define AddForm  AddFormW
#else
#define AddForm  AddFormA
#endif // !UNICODE



#ifndef UNICODE_ONLY
BOOL
WINAPI
DeleteFormA(
    HANDLE  hPrinter,
    LPSTR   pFormName
);
#endif //!UNICODE_ONLY
#ifndef ANSI_ONLY
BOOL
WINAPI
DeleteFormW(
    HANDLE  hPrinter,
    LPWSTR   pFormName
);
#endif //!ANSI_ONLY
#ifdef UNICODE
#define DeleteForm  DeleteFormW
#else
#define DeleteForm  DeleteFormA
#endif // !UNICODE



#ifndef UNICODE_ONLY
BOOL
WINAPI
GetFormA(
    HANDLE  hPrinter,
    LPSTR   pFormName,
    DWORD   Level,
    LPBYTE  pForm,
    DWORD   cbBuf,
    LPDWORD pcbNeeded
);
#endif //!UNICODE_ONLY
#ifndef ANSI_ONLY
BOOL
WINAPI
GetFormW(
    HANDLE  hPrinter,
    LPWSTR   pFormName,
    DWORD   Level,
    LPBYTE  pForm,
    DWORD   cbBuf,
    LPDWORD pcbNeeded
);
#endif //!ANSI_ONLY
#ifdef UNICODE
#define GetForm  GetFormW
#else
#define GetForm  GetFormA
#endif // !UNICODE



#ifndef UNICODE_ONLY
BOOL
WINAPI
SetFormA(
    HANDLE  hPrinter,
    LPSTR   pFormName,
    DWORD   Level,
    LPBYTE  pForm
);
#endif //!UNICODE_ONLY
#ifndef ANSI_ONLY
BOOL
WINAPI
SetFormW(
    HANDLE  hPrinter,
    LPWSTR   pFormName,
    DWORD   Level,
    LPBYTE  pForm
);
#endif //!ANSI_ONLY
#ifdef UNICODE
#define SetForm  SetFormW
#else
#define SetForm  SetFormA
#endif // !UNICODE



#ifndef UNICODE_ONLY
BOOL
WINAPI
EnumFormsA(
    HANDLE  hPrinter,
    DWORD   Level,
    LPBYTE  pForm,
    DWORD   cbBuf,
    LPDWORD pcbNeeded,
    LPDWORD pcReturned
);
#endif //!UNICODE_ONLY
#ifndef ANSI_ONLY
BOOL
WINAPI
EnumFormsW(
    HANDLE  hPrinter,
    DWORD   Level,
    LPBYTE  pForm,
    DWORD   cbBuf,
    LPDWORD pcbNeeded,
    LPDWORD pcReturned
);
#endif //!ANSI_ONLY
#ifdef UNICODE
#define EnumForms  EnumFormsW
#else
#define EnumForms  EnumFormsA
#endif // !UNICODE



#ifndef UNICODE_ONLY
BOOL
WINAPI
EnumMonitorsA(
    LPSTR   pName,
    DWORD   Level,
    LPBYTE  pMonitors,
    DWORD   cbBuf,
    LPDWORD pcbNeeded,
    LPDWORD pcReturned
);
#endif //!UNICODE_ONLY
#ifndef ANSI_ONLY
BOOL
WINAPI
EnumMonitorsW(
    LPWSTR   pName,
    DWORD   Level,
    LPBYTE  pMonitors,
    DWORD   cbBuf,
    LPDWORD pcbNeeded,
    LPDWORD pcReturned
);
#endif //!ANSI_ONLY
#ifdef UNICODE
#define EnumMonitors  EnumMonitorsW
#else
#define EnumMonitors  EnumMonitorsA
#endif // !UNICODE



#ifndef UNICODE_ONLY
BOOL
WINAPI
AddMonitorA(
    LPSTR   pName,
    DWORD   Level,
    LPBYTE  pMonitors
);
#endif //!UNICODE_ONLY
#ifndef ANSI_ONLY
BOOL
WINAPI
AddMonitorW(
    LPWSTR   pName,
    DWORD   Level,
    LPBYTE  pMonitors
);
#endif //!ANSI_ONLY
#ifdef UNICODE
#define AddMonitor  AddMonitorW
#else
#define AddMonitor  AddMonitorA
#endif // !UNICODE



#ifndef UNICODE_ONLY
BOOL
WINAPI
DeleteMonitorA(
    LPSTR   pName,
    LPSTR   pEnvironment,
    LPSTR   pMonitorName
);
#endif //!UNICODE_ONLY
#ifndef ANSI_ONLY
BOOL
WINAPI
DeleteMonitorW(
    LPWSTR   pName,
    LPWSTR   pEnvironment,
    LPWSTR   pMonitorName
);
#endif //!ANSI_ONLY
#ifdef UNICODE
#define DeleteMonitor  DeleteMonitorW
#else
#define DeleteMonitor  DeleteMonitorA
#endif // !UNICODE



#ifndef UNICODE_ONLY
BOOL
WINAPI
EnumPortsA(
    LPSTR   pName,
    DWORD   Level,
    LPBYTE  pPorts,
    DWORD   cbBuf,
    LPDWORD pcbNeeded,
    LPDWORD pcReturned
);
#endif //!UNICODE_ONLY
#ifndef ANSI_ONLY
BOOL
WINAPI
EnumPortsW(
    LPWSTR   pName,
    DWORD   Level,
    LPBYTE  pPorts,
    DWORD   cbBuf,
    LPDWORD pcbNeeded,
    LPDWORD pcReturned
);
#endif //!ANSI_ONLY
#ifdef UNICODE
#define EnumPorts  EnumPortsW
#else
#define EnumPorts  EnumPortsA
#endif // !UNICODE



#ifndef UNICODE_ONLY
BOOL
WINAPI
AddPortA(
    LPSTR   pName,
    HWND    hWnd,
    LPSTR   pMonitorName
);
#endif //!UNICODE_ONLY
#ifndef ANSI_ONLY
BOOL
WINAPI
AddPortW(
    LPWSTR   pName,
    HWND    hWnd,
    LPWSTR   pMonitorName
);
#endif //!ANSI_ONLY
#ifdef UNICODE
#define AddPort  AddPortW
#else
#define AddPort  AddPortA
#endif // !UNICODE



#ifndef UNICODE_ONLY
BOOL
WINAPI
ConfigurePortA(
    LPSTR   pName,
    HWND    hWnd,
    LPSTR   pPortName
);
#endif //!UNICODE_ONLY
#ifndef ANSI_ONLY
BOOL
WINAPI
ConfigurePortW(
    LPWSTR   pName,
    HWND    hWnd,
    LPWSTR   pPortName
);
#endif //!ANSI_ONLY
#ifdef UNICODE
#define ConfigurePort  ConfigurePortW
#else
#define ConfigurePort  ConfigurePortA
#endif // !UNICODE



#ifndef UNICODE_ONLY
BOOL
WINAPI
DeletePortA(
    LPSTR   pName,
    HWND    hWnd,
    LPSTR   pPortName
);
#endif //!UNICODE_ONLY
#ifndef ANSI_ONLY
BOOL
WINAPI
DeletePortW(
    LPWSTR   pName,
    HWND    hWnd,
    LPWSTR   pPortName
);
#endif //!ANSI_ONLY
#ifdef UNICODE
#define DeletePort  DeletePortW
#else
#define DeletePort  DeletePortA
#endif // !UNICODE



#ifndef UNICODE_ONLY
BOOL
WINAPI
AddPrinterConnectionA(
    LPSTR   pName
);
#endif //!UNICODE_ONLY
#ifndef ANSI_ONLY
BOOL
WINAPI
AddPrinterConnectionW(
    LPWSTR   pName
);
#endif //!ANSI_ONLY
#ifdef UNICODE
#define AddPrinterConnection  AddPrinterConnectionW
#else
#define AddPrinterConnection  AddPrinterConnectionA
#endif // !UNICODE



#ifndef UNICODE_ONLY
BOOL
WINAPI
DeletePrinterConnectionA(
    LPSTR   pName
);
#endif //!UNICODE_ONLY
#ifndef ANSI_ONLY
BOOL
WINAPI
DeletePrinterConnectionW(
    LPWSTR   pName
);
#endif //!ANSI_ONLY
#ifdef UNICODE
#define DeletePrinterConnection  DeletePrinterConnectionW
#else
#define DeletePrinterConnection  DeletePrinterConnectionA
#endif // !UNICODE



HANDLE
WINAPI
ConnectToPrinterDlg(
    HWND    hwnd,
    DWORD   Flags
);

#ifndef UNICODE_ONLY
typedef struct _PROVIDOR_INFO_1A{
    LPSTR     pName;
    LPSTR     pEnvironment;
    LPSTR     pDLLName;
} PROVIDOR_INFO_1A, *PPROVIDOR_INFO_1A, *LPPROVIDOR_INFO_1A;
#endif //!UNICODE_ONLY
#ifndef ANSI_ONLY
typedef struct _PROVIDOR_INFO_1W{
    LPWSTR    pName;
    LPWSTR    pEnvironment;
    LPWSTR    pDLLName;
} PROVIDOR_INFO_1W, *PPROVIDOR_INFO_1W, *LPPROVIDOR_INFO_1W;
#endif //!ANSI_ONLY
#ifdef UNICODE
typedef PROVIDOR_INFO_1W PROVIDOR_INFO_1;
typedef PPROVIDOR_INFO_1W PPROVIDOR_INFO_1;
typedef LPPROVIDOR_INFO_1W LPPROVIDOR_INFO_1;
#else
typedef PROVIDOR_INFO_1A PROVIDOR_INFO_1;
typedef PPROVIDOR_INFO_1A PPROVIDOR_INFO_1;
typedef LPPROVIDOR_INFO_1A LPPROVIDOR_INFO_1;
#endif // UNICODE



#ifndef UNICODE_ONLY
BOOL
WINAPI
AddPrintProvidorA(
    LPSTR  pName,
    DWORD    level,
    LPBYTE   pProvidorInfo
);
#endif //!UNICODE_ONLY
#ifndef ANSI_ONLY
BOOL
WINAPI
AddPrintProvidorW(
    LPWSTR  pName,
    DWORD    level,
    LPBYTE   pProvidorInfo
);
#endif //!ANSI_ONLY
#ifdef UNICODE
#define AddPrintProvidor  AddPrintProvidorW
#else
#define AddPrintProvidor  AddPrintProvidorA
#endif // !UNICODE

#ifndef UNICODE_ONLY
BOOL
WINAPI
DeletePrintProvidorA(
    LPSTR   pName,
    LPSTR   pEnvironment,
    LPSTR   pPrintProvidorName
);
#endif //!UNICODE_ONLY
#ifndef ANSI_ONLY
BOOL
WINAPI
DeletePrintProvidorW(
    LPWSTR   pName,
    LPWSTR   pEnvironment,
    LPWSTR   pPrintProvidorName
);
#endif //!ANSI_ONLY
#ifdef UNICODE
#define DeletePrintProvidor  DeletePrintProvidorW
#else
#define DeletePrintProvidor  DeletePrintProvidorA
#endif // !UNICODE



#define SERVER_ACCESS_ADMINISTER    0x00000001
#define SERVER_ACCESS_ENUMERATE     0x00000002

#define PRINTER_ACCESS_ADMINISTER   0x00000004
#define PRINTER_ACCESS_USE          0x00000008

#define JOB_ACCESS_ADMINISTER       0x00000010


/*
 * Access rights for print servers
 */

#define SERVER_ALL_ACCESS    (STANDARD_RIGHTS_REQUIRED      |\
                              SERVER_ACCESS_ADMINISTER      |\
                              SERVER_ACCESS_ENUMERATE)

#define SERVER_READ          (STANDARD_RIGHTS_READ          |\
                              SERVER_ACCESS_ENUMERATE)

#define SERVER_WRITE         (STANDARD_RIGHTS_WRITE         |\
                              SERVER_ACCESS_ADMINISTER      |\
                              SERVER_ACCESS_ENUMERATE)

#define SERVER_EXECUTE       (STANDARD_RIGHTS_EXECUTE       |\
                              SERVER_ACCESS_ENUMERATE)

/*
 * Access rights for printers
 */

#define PRINTER_ALL_ACCESS    (STANDARD_RIGHTS_REQUIRED     |\
                               PRINTER_ACCESS_ADMINISTER    |\
                               PRINTER_ACCESS_USE)

#define PRINTER_READ          (STANDARD_RIGHTS_READ         |\
                               PRINTER_ACCESS_USE)

#define PRINTER_WRITE         (STANDARD_RIGHTS_WRITE        |\
                               PRINTER_ACCESS_USE)

#define PRINTER_EXECUTE       (STANDARD_RIGHTS_EXECUTE      |\
                               PRINTER_ACCESS_USE)

/*
 * Access rights for jobs
 */

#define JOB_ALL_ACCESS         (STANDARD_RIGHTS_REQUIRED    |\
                                JOB_ACCESS_ADMINISTER)

#define JOB_READ               (STANDARD_RIGHTS_READ        |\
                                JOB_ACCESS_ADMINISTER)

#define JOB_WRITE              (STANDARD_RIGHTS_WRITE       |\
                                JOB_ACCESS_ADMINISTER)

#define JOB_EXECUTE            (STANDARD_RIGHTS_EXECUTE     |\
                                JOB_ACCESS_ADMINISTER)


#ifdef __cplusplus
}
#endif

#endif // _WINSPOOL_
=== C:/Users/treeman/Desktop/windows nt source code\Source\Win2K3\NT\printscan\faxsrv\print\faxprint\faxdrv\win9x\faxdrv32\makefile.inc ===
!IF 0

Copyright (c) 1989-1995 Microsoft Corporation

!ENDIF

$O\thk16.obj $O\thk32.obj: thunk1632.c faxdrv32.h
!ifdef PASS0ONLY
    if exist thunk1632.asm del thunk1632.asm
    cl /EP thunk1632.c > thunk1632.thk
!else
    thunk.exe thunk1632.thk 
	ml /omf /DIS_16 /c /W3 /nologo /Fo$O\thk16.obj thunk1632.asm 
	ml /coff /DIS_32 /c /W3 /nologo /Fo$O\thk32.obj thunk1632.asm 
!endif

clean:
    del thunk1632.asm
    del thunk1632.thk
    del $O\thk16.obj
    del $O\thk32.obj
=== C:/Users/treeman/Desktop/windows nt source code\Source\Win2K3\NT\printscan\faxsrv\print\faxprint\faxdrv\win9x\faxdrv32\runtime_ref.c ===
#include "stdhdr.h"
#include \
/*******************************************************************************
 *                                                                             *
 *	This source file is merely a reference to the file included in it, in order*
 *	to overcome razzle inability to specify files in an ancestral directory    *
 *	rather than the parent directory. For complete documentation of            *
 *  functionality refer to */ "..\..\..\lib\runtime.c"                        /*
 *                                                                             *
 *******************************************************************************/
=== C:/Users/treeman/Desktop/windows nt source code\Source\Win2K3\NT\printscan\faxsrv\print\faxprint\faxdrv\win9x\utils\thunks.h ===
#ifndef UTILS_THUNKS_H__INCLUDED
#define UTILS_THUNKS_H__INCLUDED

#ifdef _THUNK
    #define BEGIN_ARGS_DECLARATION {
    #define END_ARGS_DECLARATION }
    #define ARG_IN(par) par = input
    #define ARG_OUT(par) par = output
    #define ARG_INOUT(par) par = inout
    #define FAULT_ERROR_CODE(val) faulterrorcode = val
#else
    #define BEGIN_ARGS_DECLARATION ;
    #define END_ARGS_DECLARATION
    #define ARG_IN(par)
    #define ARG_OUT(par)
    #define ARG_INOUT(par)
    #define FAULT_ERROR_CODE(val)
#endif //_THUNK


#ifdef _THUNK
    #define WINAPI
    #define FAR
    #define BOOL bool
#endif //_THUNK

#endif //UTILS_THUNKS_H__INCLUDED
=== C:/Users/treeman/Desktop/windows nt source code\Source\Win2K3\NT\printscan\faxsrv\print\faxprint\faxdrv\win9x\sdk\include\winver.h ===
/*****************************************************************************\
*                                                                             *
* winver.h -    Version management functions, types, and definitions          *
*                                                                             *
*               Include file for VER.DLL.  This library is                    *
*               designed to allow version stamping of Windows executable files*
*               and of special .VER files for DOS executable files.           *
*                                                                             *
*          Copyright (c) 1993-1996, Microsoft Corp.  All rights reserved      *
*                                                                             *
\*****************************************************************************/

#ifndef VER_H
#define VER_H

#ifdef __cplusplus
extern "C" {
#endif

/* ----- Symbols ----- */
#define VS_FILE_INFO            RT_VERSION
#define VS_VERSION_INFO         1
#define VS_USER_DEFINED         100

/* ----- VS_VERSION.dwFileFlags ----- */
#define VS_FFI_SIGNATURE        0xFEEF04BDL
#define VS_FFI_STRUCVERSION     0x00010000L
#define VS_FFI_FILEFLAGSMASK    0x0000003FL

/* ----- VS_VERSION.dwFileFlags ----- */
#define VS_FF_DEBUG             0x00000001L
#define VS_FF_PRERELEASE        0x00000002L
#define VS_FF_PATCHED           0x00000004L
#define VS_FF_PRIVATEBUILD      0x00000008L
#define VS_FF_INFOINFERRED      0x00000010L
#define VS_FF_SPECIALBUILD      0x00000020L

/* ----- VS_VERSION.dwFileOS ----- */
#define VOS_UNKNOWN             0x00000000L
#define VOS_DOS                 0x00010000L
#define VOS_OS216               0x00020000L
#define VOS_OS232               0x00030000L
#define VOS_NT                  0x00040000L

#define VOS__BASE               0x00000000L
#define VOS__WINDOWS16          0x00000001L
#define VOS__PM16               0x00000002L
#define VOS__PM32               0x00000003L
#define VOS__WINDOWS32          0x00000004L

#define VOS_DOS_WINDOWS16       0x00010001L
#define VOS_DOS_WINDOWS32       0x00010004L
#define VOS_OS216_PM16          0x00020002L
#define VOS_OS232_PM32          0x00030003L
#define VOS_NT_WINDOWS32        0x00040004L

/* ----- VS_VERSION.dwFileType ----- */
#define VFT_UNKNOWN             0x00000000L
#define VFT_APP                 0x00000001L
#define VFT_DLL                 0x00000002L
#define VFT_DRV                 0x00000003L
#define VFT_FONT                0x00000004L
#define VFT_VXD                 0x00000005L
#define VFT_STATIC_LIB          0x00000007L

/* ----- VS_VERSION.dwFileSubtype for VFT_WINDOWS_DRV ----- */
#define VFT2_UNKNOWN            0x00000000L
#define VFT2_DRV_PRINTER        0x00000001L
#define VFT2_DRV_KEYBOARD       0x00000002L
#define VFT2_DRV_LANGUAGE       0x00000003L
#define VFT2_DRV_DISPLAY        0x00000004L
#define VFT2_DRV_MOUSE          0x00000005L
#define VFT2_DRV_NETWORK        0x00000006L
#define VFT2_DRV_SYSTEM         0x00000007L
#define VFT2_DRV_INSTALLABLE    0x00000008L
#define VFT2_DRV_SOUND          0x00000009L
#define VFT2_DRV_COMM           0x0000000AL
#define VFT2_DRV_INPUTMETHOD    0x0000000BL

/* ----- VS_VERSION.dwFileSubtype for VFT_WINDOWS_FONT ----- */
#define VFT2_FONT_RASTER        0x00000001L
#define VFT2_FONT_VECTOR        0x00000002L
#define VFT2_FONT_TRUETYPE      0x00000003L

/* ----- VerFindFile() flags ----- */
#define VFFF_ISSHAREDFILE       0x0001

#define VFF_CURNEDEST           0x0001
#define VFF_FILEINUSE           0x0002
#define VFF_BUFFTOOSMALL        0x0004

/* ----- VerInstallFile() flags ----- */
#define VIFF_FORCEINSTALL       0x0001
#define VIFF_DONTDELETEOLD      0x0002

#define VIF_TEMPFILE            0x00000001L
#define VIF_MISMATCH            0x00000002L
#define VIF_SRCOLD              0x00000004L

#define VIF_DIFFLANG            0x00000008L
#define VIF_DIFFCODEPG          0x00000010L
#define VIF_DIFFTYPE            0x00000020L

#define VIF_WRITEPROT           0x00000040L
#define VIF_FILEINUSE           0x00000080L
#define VIF_OUTOFSPACE          0x00000100L
#define VIF_ACCESSVIOLATION     0x00000200L
#define VIF_SHARINGVIOLATION    0x00000400L
#define VIF_CANNOTCREATE        0x00000800L
#define VIF_CANNOTDELETE        0x00001000L
#define VIF_CANNOTRENAME        0x00002000L
#define VIF_CANNOTDELETECUR     0x00004000L
#define VIF_OUTOFMEMORY         0x00008000L

#define VIF_CANNOTREADSRC       0x00010000L
#define VIF_CANNOTREADDST       0x00020000L

#define VIF_BUFFTOOSMALL        0x00040000L

#ifndef RC_INVOKED              /* RC doesn't need to see the rest of this */

/* ----- Types and structures ----- */

typedef struct tagVS_FIXEDFILEINFO
{
    DWORD   dwSignature;            /* e.g. 0xfeef04bd */
    DWORD   dwStrucVersion;         /* e.g. 0x00000042 = "0.42" */
    DWORD   dwFileVersionMS;        /* e.g. 0x00030075 = "3.75" */
    DWORD   dwFileVersionLS;        /* e.g. 0x00000031 = "0.31" */
    DWORD   dwProductVersionMS;     /* e.g. 0x00030010 = "3.10" */
    DWORD   dwProductVersionLS;     /* e.g. 0x00000031 = "0.31" */
    DWORD   dwFileFlagsMask;        /* = 0x3F for version "0.42" */
    DWORD   dwFileFlags;            /* e.g. VFF_DEBUG | VFF_PRERELEASE */
    DWORD   dwFileOS;               /* e.g. VOS_DOS_WINDOWS16 */
    DWORD   dwFileType;             /* e.g. VFT_DRIVER */
    DWORD   dwFileSubtype;          /* e.g. VFT2_DRV_KEYBOARD */
    DWORD   dwFileDateMS;           /* e.g. 0 */
    DWORD   dwFileDateLS;           /* e.g. 0 */
} VS_FIXEDFILEINFO;

/* ----- Function prototypes ----- */

DWORD
APIENTRY
VerFindFileA(
        DWORD uFlags,
        LPSTR szFileName,
        LPSTR szWinDir,
        LPSTR szAppDir,
        LPSTR szCurDir,
        PUINT lpuCurDirLen,
        LPSTR szDestDir,
        PUINT lpuDestDirLen
        );
DWORD
APIENTRY
VerFindFileW(
        DWORD uFlags,
        LPWSTR szFileName,
        LPWSTR szWinDir,
        LPWSTR szAppDir,
        LPWSTR szCurDir,
        PUINT lpuCurDirLen,
        LPWSTR szDestDir,
        PUINT lpuDestDirLen
        );
#ifdef UNICODE
#define VerFindFile  VerFindFileW
#else
#define VerFindFile  VerFindFileA
#endif // !UNICODE

DWORD
APIENTRY
VerInstallFileA(
        DWORD uFlags,
        LPSTR szSrcFileName,
        LPSTR szDestFileName,
        LPSTR szSrcDir,
        LPSTR szDestDir,
        LPSTR szCurDir,
        LPSTR szTmpFile,
        PUINT lpuTmpFileLen
        );
DWORD
APIENTRY
VerInstallFileW(
        DWORD uFlags,
        LPWSTR szSrcFileName,
        LPWSTR szDestFileName,
        LPWSTR szSrcDir,
        LPWSTR szDestDir,
        LPWSTR szCurDir,
        LPWSTR szTmpFile,
        PUINT lpuTmpFileLen
        );
#ifdef UNICODE
#define VerInstallFile  VerInstallFileW
#else
#define VerInstallFile  VerInstallFileA
#endif // !UNICODE

/* Returns size of version info in bytes */
DWORD
APIENTRY
GetFileVersionInfoSizeA(
        LPSTR lptstrFilename, /* Filename of version stamped file */
        LPDWORD lpdwHandle
        );                      /* Information for use by GetFileVersionInfo */
/* Returns size of version info in bytes */
DWORD
APIENTRY
GetFileVersionInfoSizeW(
        LPWSTR lptstrFilename, /* Filename of version stamped file */
        LPDWORD lpdwHandle
        );                      /* Information for use by GetFileVersionInfo */
#ifdef UNICODE
#define GetFileVersionInfoSize  GetFileVersionInfoSizeW
#else
#define GetFileVersionInfoSize  GetFileVersionInfoSizeA
#endif // !UNICODE

/* Read version info into buffer */
BOOL
APIENTRY
GetFileVersionInfoA(
        LPSTR lptstrFilename, /* Filename of version stamped file */
        DWORD dwHandle,         /* Information from GetFileVersionSize */
        DWORD dwLen,            /* Length of buffer for info */
        LPVOID lpData
        );                      /* Buffer to place the data structure */
/* Read version info into buffer */
BOOL
APIENTRY
GetFileVersionInfoW(
        LPWSTR lptstrFilename, /* Filename of version stamped file */
        DWORD dwHandle,         /* Information from GetFileVersionSize */
        DWORD dwLen,            /* Length of buffer for info */
        LPVOID lpData
        );                      /* Buffer to place the data structure */
#ifdef UNICODE
#define GetFileVersionInfo  GetFileVersionInfoW
#else
#define GetFileVersionInfo  GetFileVersionInfoA
#endif // !UNICODE

DWORD
APIENTRY
VerLanguageNameA(
        DWORD wLang,
        LPSTR szLang,
        DWORD nSize
        );
DWORD
APIENTRY
VerLanguageNameW(
        DWORD wLang,
        LPWSTR szLang,
        DWORD nSize
        );
#ifdef UNICODE
#define VerLanguageName  VerLanguageNameW
#else
#define VerLanguageName  VerLanguageNameA
#endif // !UNICODE

BOOL
APIENTRY
VerQueryValueA(
        const LPVOID pBlock,
        LPSTR lpSubBlock,
        LPVOID * lplpBuffer,
        PUINT puLen
        );
BOOL
APIENTRY
VerQueryValueW(
        const LPVOID pBlock,
        LPWSTR lpSubBlock,
        LPVOID * lplpBuffer,
        PUINT puLen
        );
#ifdef UNICODE
#define VerQueryValue  VerQueryValueW
#else
#define VerQueryValue  VerQueryValueA
#endif // !UNICODE

#endif  /* !RC_INVOKED */

#ifdef __cplusplus
}
#endif

#endif  /* !VER_H */
=== C:/Users/treeman/Desktop/windows nt source code\Source\Win2K3\NT\printscan\faxsrv\print\faxprint\faxdrv\win9x\faxdrv32\stdhdr.h ===
#ifndef __FAXDRV32__STDHDR_H
#define __FAXDRV32__STDHDR_H

#define WIN__95
#define STRICT

#include "windows.h"
#include "..\..\..\inc\infowzrd.h"
#include "..\..\..\inc\faxlib.h"
#include "..\..\..\..\..\inc\faxsendw.h"
#include "..\..\faxdrv.h"
#include "..\..\..\..\..\inc\fxsapip.h"
#include "..\utils\dbgtrace.h"
#include "..\utils\utils.h"

#define MAX_CAPTION 30
#define MAX_PORT_NAME 256
#define MAX_DOC_NAME MAX_PATH

#endif //__FAXDRV32__STDHDR_H
=== C:/Users/treeman/Desktop/windows nt source code\Source\Win2K3\NT\printscan\faxsrv\print\faxprint\faxdrv\win9x\faxdrv32\thunk1632.c ===
/////////////////////////////////////////////////////////////////////////////
//  FILE          : thunk1632.c                                            //
//                                                                         //
//  DESCRIPTION   : Thunk script for 16 to 32 thunk calls                  //
//                  This file declares all the types used in the thunk -   //                                                                         //
//                  prototypes included by it.                             //
//                  This file is preprocessed and its output is the thunk  //
//                  script compiled by the thunk compiler.                 //
//                                                                         //
//  AUTHOR        : DanL.                                                  //
//                                                                         //
//  HISTORY       :                                                        //
//      Oct 19 1999 DannyL  Creation.                                      //
//                                                                         //
//  Copyright (C) 1999 Microsoft Corporation   All Rights Reserved         //
/////////////////////////////////////////////////////////////////////////////

#define _THUNK

enablemapdirect1632 = true;     // Creates 16->32 thunks. 
win31compat = true;

///////////////////////////////////////////////////////////////////////////////////////
// windows.h
typedef unsigned char   BYTE,*PBYTE,*LPBYTE;
typedef char            *LPSTR,*LPCSTR,CHAR;
typedef unsigned long   *LPDWORD,DWORD;
typedef unsigned short  WORD,*LPWORD;
typedef void            VOID,*PVOID,*LPVOID;
typedef WORD            HWND;

///////////////////////////////////////////////////////////////////////////////////////
// wingdi.h
#define CCHDEVICENAME 32
#define CCHFORMNAME 32

typedef struct _devicemode 
{
    BYTE dmDeviceName[CCHDEVICENAME];
    WORD dmSpecVersion;
    WORD dmDriverVersion;
    WORD dmSize;
    WORD dmDriverExtra;
    DWORD dmFields;
    short dmOrientation;
    short dmPaperSize;
    short dmPaperLength;
    short dmPaperWidth;
    short dmScale;
    short dmCopies;
    short dmDefaultSource;
    short dmPrintQuality;
    short dmColor;
    short dmDuplex;
    short dmYResolution;
    short dmTTOption;
    short dmCollate;
    BYTE   dmFormName[CCHFORMNAME];
    WORD   dmLogPixels;
    DWORD  dmBitsPerPel;
    DWORD  dmPelsWidth;
    DWORD  dmPelsHeight;
    DWORD  dmDisplayFlags;
    DWORD  dmDisplayFrequency;
    DWORD  dmICMMethod;
    DWORD  dmICMIntent;
    DWORD  dmMediaType;
    DWORD  dmDitherType;
    DWORD  dmReserved1;
    DWORD  dmReserved2;
} DEVMODE, *PDEVMODE, *LPDEVMODE;

typedef struct _DOCINFOA {
    short    cbSize;
    LPCSTR   lpszDocName;
    LPCSTR   lpszOutput;
    LPCSTR   lpszDatatype;
    DWORD    fwType;
} DOCINFO, *LPDOCINFO;

/////////////////////////////////////////////////////////////////////////////////////////
// faxdrv32 thunks
#include "faxdrv32.h"
=== C:/Users/treeman/Desktop/windows nt source code\Source\Win2K3\NT\printscan\faxsrv\print\faxprint\faxdrv\win9x\utils\dbgtrace.h ===
////////////////////////////////////////////////////////////////////////////
//  FILE          : dbgtrace.h                                             //
//                                                                         //
//  DESCRIPTION   : Define some macros and inline functions for debugging. //
//                                                                         //
//  AUTHOR        : DanL.                                                  //
//                                                                         //
//  HISTORY       :                                                        //
//      Oct 19 1999 DannyL  Creation.                                      //
//                                                                         //
//  Copyright (C) 1999 Microsoft Corporation   All Rights Reserved         //
/////////////////////////////////////////////////////////////////////////////

#ifndef __UTILS__DBGTRACE_H
#define __UTILS__DBGTRACE_H

#include <stdio.h>
#include <stdarg.h>
#include <winerror.h>

#define MAX_PROC_NAME 30
#define MAX_TRACE_LINE 200
//
// The following key is the parent of the Log key which containes the
// log path in the default value.
//       
#define HKEY_DBG "SOFTWARE\\Microsoft\\SharedFax\\9XDrvDbg"

#ifdef DBG
    #define POPUPS
    #define DBG_DEBUG
#endif //DEBUG

#define NO_NULL_STR(_str) ((LPSTR)( (_str)? _str: "<NULL>" ))
#define BOOL_VALUE(_f) ((LPSTR)( (_f)? _T("TRUE") : _T("FALSE") ))

#ifndef WIN32
    #define wsprintfA wsprintf
    #define OutputDebugStringA OutputDebugString
    #define MessageBoxA MessageBox
#endif //WIN32

typedef struct tagDBG_CONTEXT_INFO
{
    char    szProcName[MAX_TRACE_LINE];
    BOOL    fSilent;
    int     iNumEntries;
} DBG_CONTEXT_INFO;
        
#ifdef DBG_DEBUG
#define DBG_MESSAGE_BOX3(str,arg1,arg2,arg3)\
    {\
        char sz[MAX_TRACE_LINE];\
        wsprintfA(sz,"%s(): "str"\r\n",(LPSTR)__dbgContextInfo.szProcName,arg1,arg2,arg3);\
        MessageBoxA(NULL,(LPSTR)sz,(LPSTR)__dbgGlobalInfo.szModuleName,MB_OK);\
    }

#define DBG_MESSAGE_BOX(str) DBG_MESSAGE_BOX3(str "%c%c%c",(' '),(' '),(' '))

#define DBG_MESSAGE_BOX1(str,arg) DBG_MESSAGE_BOX3(str "%c%c",arg,(' '),(' '))

#define DBG_MESSAGE_BOX2(str,arg1,arg2) DBG_MESSAGE_BOX3(str "%c",arg1,arg2,(' '));

typedef struct tagDBG_GLOBAL_INFO
{
    char szLogName[MAX_PATH];
    char szModuleName[MAX_PATH];
    BOOL bUseLog;
    BOOL bInitialized;
} DBG_GLOBAL_INFO;

extern DBG_GLOBAL_INFO __dbgGlobalInfo;

#define OUTPUT_DEBUG_STRING(str) __dbgOutputDebugString(str,__dbgContextInfo)

void __inline 
__dbgOutputDebugString(const PSTR str,DBG_CONTEXT_INFO __dbgContextInfo)
{
    FILE* pfLog;
    OutputDebugStringA(str);
    if (!__dbgGlobalInfo.bInitialized)
    {
        HKEY hkey;
        LONG cbData = sizeof(__dbgGlobalInfo.szLogName);
        if ((ERROR_SUCCESS != RegCreateKey(HKEY_LOCAL_MACHINE, HKEY_DBG,&hkey)) ||
            (ERROR_SUCCESS != RegQueryValue(hkey, "Log", __dbgGlobalInfo.szLogName, &cbData)))
        {
            __dbgGlobalInfo.bUseLog = FALSE;
        }
    }
    if (__dbgGlobalInfo.bUseLog != FALSE)
    {
        if ( !(pfLog = fopen(__dbgGlobalInfo.szLogName,"a")))
        {
            DBG_MESSAGE_BOX2("DEBUG: Error: 0x%lx Failed to open Log file: %s",GetLastError(),(LPSTR)__dbgGlobalInfo.szLogName);
            __dbgGlobalInfo.bUseLog = FALSE;
        } 
        else 
        {
            fputs(str,pfLog);
            fclose(pfLog);
        }
    }
}

#define DBG_TRACE3(format,arg1,arg2,arg3)\
        {\
            static char sz[MAX_TRACE_LINE];\
            wsprintfA(sz,"[%s] %s(): "format"\r\n",(LPSTR)__dbgGlobalInfo.szModuleName,(LPSTR)__dbgContextInfo.szProcName,arg1,arg2,arg3);\
            OUTPUT_DEBUG_STRING(sz);\
        }


#define DBG_TRACE(str) DBG_TRACE3(str "%c%c%c",(' '),(' '),(' '))

#define DBG_TRACE1(format,arg) DBG_TRACE3(format "%c%c",arg,(' '),(' '))

#define DBG_TRACE2(format,arg1,arg2) DBG_TRACE3(format "%c",arg1,arg2,(' '))

#ifdef ASSERT_ON_REENTRANCY
#define CHECK_REENTRANCY()\
        if (++ __dbgContextInfo.iNumEntries > 1)\
        {\
            DBG_TRACE1("WARNING: reentrancy occured",__dbgContextInfo.iNumEntries);\
            DBG_MESSAGE_BOX1("WARNING: reentrancy occured",__dbgContextInfo.iNumEntries);\
        }
#else //ASSERT_ON_REENTRANCY
#define CHECK_REENTRANCY()
#endif //ASSERT_ON_REENTRANCY

#define DBG_PROC_ENTRY(pname)   static DBG_CONTEXT_INFO __dbgContextInfo = { pname , FALSE,0};\
                                OUTPUT_DEBUG_STRING("> ");\
                                DBG_TRACE("Enter");\
                                CHECK_REENTRANCY();

#define SDBG_PROC_ENTRY(pname)  static DBG_CONTEXT_INFO __dbgContextInfo = { pname , TRUE,0 };\
                                CHECK_REENTRANCY();


#define RETURN  for(__dbgProcExit(__dbgContextInfo),--__dbgContextInfo.iNumEntries;TRUE;) return 

#ifdef POPUPS

#define DBG_CALL_FAIL(fname,rc)\
        {\
            DWORD dwRc = rc;\
            if(rc)\
            {\
                DBG_TRACE2(__FILE__ "(%d) : Error 0x%lx: "fname" failed",__LINE__,dwRc);\
                DBG_MESSAGE_BOX1("Error 0x%lx:"fname" failed",dwRc);\
            }\
            else\
            {\
                DBG_TRACE1(__FILE__ "(%d) : "fname" failed",__LINE__);\
                DBG_MESSAGE_BOX(fname" failed");\
            }\
        }



#else //POPUPS
#define DBG_CALL_FAIL(fname,rc)\
        {\
            if(rc)\
            {\
                DBG_TRACE1(__FILE__ "(" __LINE__ ") : Error 0x%lx: "fname" failed",rc);\
            }\
            else\
            {\
                DBG_TRACE(__FILE__ "(" __LINE__ ") : "fname" failed");\
            }\
        }
#endif //POPUPS

#define ASSERT(boolexp)\
        {\
            if ((boolexp) == FALSE) \
            {\
                DBG_MESSAGE_BOX("ASSERT FAILED: "#boolexp);\
            }\
        } 
    
#define DBG_DECLARE_MODULE(modulename)\
            DBG_GLOBAL_INFO __dbgGlobalInfo = {"",modulename,TRUE,FALSE}

void __inline FAR pascal 
__dbgProcExit(DBG_CONTEXT_INFO __dbgContextInfo)
{
    if (__dbgContextInfo.fSilent == TRUE)
        return;
    OUTPUT_DEBUG_STRING("< ");
    DBG_TRACE("Exit");
}

ULONG __inline __cdecl 
DbgPrint(char *format, ...)
{
    va_list va;
	char sz[MAX_TRACE_LINE]={0};
    
    SDBG_PROC_ENTRY("DEBUG-MESSAGE");

    va_start(va, format);
    _vsnprintf(sz,ARR_SIZE(sz)-1,format,va);
    va_end(va);

    OUTPUT_DEBUG_STRING(sz);
    return 0;
}

void __inline 
DbgBreakPoint()
{
    SDBG_PROC_ENTRY("DEBUG-ASSERT");
    ASSERT(FALSE);
    return;
}

#else // DBG_DEBUG
#define DBG_MESSAGE_BOX
#define DBG_MESSAGE_BOX1(a,b)
#define DBG_MESSAGE_BOX2(a,b,c)
#define DBG_MESSAGE_BOX3(a,b,c,d)
#define OUTPUT_DEBUG_STRING(a)
#define DBG_TRACE(a)
#define DBG_TRACE1(a,b)
#define DBG_TRACE2(a,b,c)
#define DBG_TRACE3(a,b,c,d)
#define DBG_PROC_ENTRY(a)
#define SDBG_PROC_ENTRY(a)
#define RETURN return
#define DBG_CALL_FAIL(a,b)
#define DBG_DECLARE_MODULE(a)
#define ASSERT(a)

#endif// DBG_DEBUG

#endif //__UTILS__DBGTRACE_H
=== C:/Users/treeman/Desktop/windows nt source code\Source\Win2K3\NT\printscan\faxsrv\print\faxprint\faxdrv\win9x\sdk\include\winerror.h ===
/************************************************************************
*                                                                       *
*   winerror.h --  error code definitions for the Win32 API functions   *
*                                                                       *
*   Copyright (c) 1991-1996, Microsoft Corp. All rights reserved.       *
*                                                                       *
************************************************************************/

#ifndef _WINERROR_
#define _WINERROR_


//
//  Values are 32 bit values layed out as follows:
//
//   3 3 2 2 2 2 2 2 2 2 2 2 1 1 1 1 1 1 1 1 1 1
//   1 0 9 8 7 6 5 4 3 2 1 0 9 8 7 6 5 4 3 2 1 0 9 8 7 6 5 4 3 2 1 0
//  +---+-+-+-----------------------+-------------------------------+
//  |Sev|C|R|     Facility          |               Code            |
//  +---+-+-+-----------------------+-------------------------------+
//
//  where
//
//      Sev - is the severity code
//
//          00 - Success
//          01 - Informational
//          10 - Warning
//          11 - Error
//
//      C - is the Customer code flag
//
//      R - is a reserved bit
//
//      Facility - is the facility code
//
//      Code - is the facility's status code
//
//
// Define the facility codes
//
#define FACILITY_WINDOWS                 8
#define FACILITY_STORAGE                 3
#define FACILITY_RPC                     1
#define FACILITY_SSPI                    9
#define FACILITY_WIN32                   7
#define FACILITY_CONTROL                 10
#define FACILITY_NULL                    0
#define FACILITY_INTERNET                12
#define FACILITY_ITF                     4
#define FACILITY_DISPATCH                2
#define FACILITY_CERT                    11


//
// Define the severity codes
//


//
// MessageId: ERROR_SUCCESS
//
// MessageText:
//
//  The operation completed successfully.
//
#define ERROR_SUCCESS                    0L

#define NO_ERROR 0L                                                 // dderror

//
// MessageId: ERROR_INVALID_FUNCTION
//
// MessageText:
//
//  Incorrect function.
//
#define ERROR_INVALID_FUNCTION           1L    // dderror

//
// MessageId: ERROR_FILE_NOT_FOUND
//
// MessageText:
//
//  The system cannot find the file specified.
//
#define ERROR_FILE_NOT_FOUND             2L

//
// MessageId: ERROR_PATH_NOT_FOUND
//
// MessageText:
//
//  The system cannot find the path specified.
//
#define ERROR_PATH_NOT_FOUND             3L

//
// MessageId: ERROR_TOO_MANY_OPEN_FILES
//
// MessageText:
//
//  The system cannot open the file.
//
#define ERROR_TOO_MANY_OPEN_FILES        4L

//
// MessageId: ERROR_ACCESS_DENIED
//
// MessageText:
//
//  Access is denied.
//
#define ERROR_ACCESS_DENIED              5L

//
// MessageId: ERROR_INVALID_HANDLE
//
// MessageText:
//
//  The handle is invalid.
//
#define ERROR_INVALID_HANDLE             6L

//
// MessageId: ERROR_ARENA_TRASHED
//
// MessageText:
//
//  The storage control blocks were destroyed.
//
#define ERROR_ARENA_TRASHED              7L

//
// MessageId: ERROR_NOT_ENOUGH_MEMORY
//
// MessageText:
//
//  Not enough storage is available to process this command.
//
#define ERROR_NOT_ENOUGH_MEMORY          8L    // dderror

//
// MessageId: ERROR_INVALID_BLOCK
//
// MessageText:
//
//  The storage control block address is invalid.
//
#define ERROR_INVALID_BLOCK              9L

//
// MessageId: ERROR_BAD_ENVIRONMENT
//
// MessageText:
//
//  The environment is incorrect.
//
#define ERROR_BAD_ENVIRONMENT            10L

//
// MessageId: ERROR_BAD_FORMAT
//
// MessageText:
//
//  An attempt was made to load a program with an
//  incorrect format.
//
#define ERROR_BAD_FORMAT                 11L

//
// MessageId: ERROR_INVALID_ACCESS
//
// MessageText:
//
//  The access code is invalid.
//
#define ERROR_INVALID_ACCESS             12L

//
// MessageId: ERROR_INVALID_DATA
//
// MessageText:
//
//  The data is invalid.
//
#define ERROR_INVALID_DATA               13L

//
// MessageId: ERROR_OUTOFMEMORY
//
// MessageText:
//
//  Not enough storage is available to complete this operation.
//
#define ERROR_OUTOFMEMORY                14L

//
// MessageId: ERROR_INVALID_DRIVE
//
// MessageText:
//
//  The system cannot find the drive specified.
//
#define ERROR_INVALID_DRIVE              15L

//
// MessageId: ERROR_CURRENT_DIRECTORY
//
// MessageText:
//
//  The directory cannot be removed.
//
#define ERROR_CURRENT_DIRECTORY          16L

//
// MessageId: ERROR_NOT_SAME_DEVICE
//
// MessageText:
//
//  The system cannot move the file
//  to a different disk drive.
//
#define ERROR_NOT_SAME_DEVICE            17L

//
// MessageId: ERROR_NO_MORE_FILES
//
// MessageText:
//
//  There are no more files.
//
#define ERROR_NO_MORE_FILES              18L

//
// MessageId: ERROR_WRITE_PROTECT
//
// MessageText:
//
//  The media is write protected.
//
#define ERROR_WRITE_PROTECT              19L

//
// MessageId: ERROR_BAD_UNIT
//
// MessageText:
//
//  The system cannot find the device specified.
//
#define ERROR_BAD_UNIT                   20L

//
// MessageId: ERROR_NOT_READY
//
// MessageText:
//
//  The device is not ready.
//
#define ERROR_NOT_READY                  21L

//
// MessageId: ERROR_BAD_COMMAND
//
// MessageText:
//
//  The device does not recognize the command.
//
#define ERROR_BAD_COMMAND                22L

//
// MessageId: ERROR_CRC
//
// MessageText:
//
//  Data error (cyclic redundancy check)
//
#define ERROR_CRC                        23L

//
// MessageId: ERROR_BAD_LENGTH
//
// MessageText:
//
//  The program issued a command but the
//  command length is incorrect.
//
#define ERROR_BAD_LENGTH                 24L

//
// MessageId: ERROR_SEEK
//
// MessageText:
//
//  The drive cannot locate a specific
//  area or track on the disk.
//
#define ERROR_SEEK                       25L

//
// MessageId: ERROR_NOT_DOS_DISK
//
// MessageText:
//
//  The specified disk or diskette cannot be accessed.
//
#define ERROR_NOT_DOS_DISK               26L

//
// MessageId: ERROR_SECTOR_NOT_FOUND
//
// MessageText:
//
//  The drive cannot find the sector requested.
//
#define ERROR_SECTOR_NOT_FOUND           27L

//
// MessageId: ERROR_OUT_OF_PAPER
//
// MessageText:
//
//  The printer is out of paper.
//
#define ERROR_OUT_OF_PAPER               28L

//
// MessageId: ERROR_WRITE_FAULT
//
// MessageText:
//
//  The system cannot write to the specified device.
//
#define ERROR_WRITE_FAULT                29L

//
// MessageId: ERROR_READ_FAULT
//
// MessageText:
//
//  The system cannot read from the specified device.
//
#define ERROR_READ_FAULT                 30L

//
// MessageId: ERROR_GEN_FAILURE
//
// MessageText:
//
//  A device attached to the system is not functioning.
//
#define ERROR_GEN_FAILURE                31L

//
// MessageId: ERROR_SHARING_VIOLATION
//
// MessageText:
//
//  The process cannot access the file because
//  it is being used by another process.
//
#define ERROR_SHARING_VIOLATION          32L

//
// MessageId: ERROR_LOCK_VIOLATION
//
// MessageText:
//
//  The process cannot access the file because
//  another process has locked a portion of the file.
//
#define ERROR_LOCK_VIOLATION             33L

//
// MessageId: ERROR_WRONG_DISK
//
// MessageText:
//
//  The wrong diskette is in the drive.
//  Insert %2 (Volume Serial Number: %3)
//  into drive %1.
//
#define ERROR_WRONG_DISK                 34L

//
// MessageId: ERROR_SHARING_BUFFER_EXCEEDED
//
// MessageText:
//
//  Too many files opened for sharing.
//
#define ERROR_SHARING_BUFFER_EXCEEDED    36L

//
// MessageId: ERROR_HANDLE_EOF
//
// MessageText:
//
//  Reached end of file.
//
#define ERROR_HANDLE_EOF                 38L

//
// MessageId: ERROR_HANDLE_DISK_FULL
//
// MessageText:
//
//  The disk is full.
//
#define ERROR_HANDLE_DISK_FULL           39L

//
// MessageId: ERROR_NOT_SUPPORTED
//
// MessageText:
//
//  The network request is not supported.
//
#define ERROR_NOT_SUPPORTED              50L

//
// MessageId: ERROR_REM_NOT_LIST
//
// MessageText:
//
//  The remote computer is not available.
//
#define ERROR_REM_NOT_LIST               51L

//
// MessageId: ERROR_DUP_NAME
//
// MessageText:
//
//  A duplicate name exists on the network.
//
#define ERROR_DUP_NAME                   52L

//
// MessageId: ERROR_BAD_NETPATH
//
// MessageText:
//
//  The network path was not found.
//
#define ERROR_BAD_NETPATH                53L

//
// MessageId: ERROR_NETWORK_BUSY
//
// MessageText:
//
//  The network is busy.
//
#define ERROR_NETWORK_BUSY               54L

//
// MessageId: ERROR_DEV_NOT_EXIST
//
// MessageText:
//
//  The specified network resource or device is no longer
//  available.
//
#define ERROR_DEV_NOT_EXIST              55L    // dderror

//
// MessageId: ERROR_TOO_MANY_CMDS
//
// MessageText:
//
//  The network BIOS command limit has been reached.
//
#define ERROR_TOO_MANY_CMDS              56L

//
// MessageId: ERROR_ADAP_HDW_ERR
//
// MessageText:
//
//  A network adapter hardware error occurred.
//
#define ERROR_ADAP_HDW_ERR               57L

//
// MessageId: ERROR_BAD_NET_RESP
//
// MessageText:
//
//  The specified server cannot perform the requested
//  operation.
//
#define ERROR_BAD_NET_RESP               58L

//
// MessageId: ERROR_UNEXP_NET_ERR
//
// MessageText:
//
//  An unexpected network error occurred.
//
#define ERROR_UNEXP_NET_ERR              59L

//
// MessageId: ERROR_BAD_REM_ADAP
//
// MessageText:
//
//  The remote adapter is not compatible.
//
#define ERROR_BAD_REM_ADAP               60L

//
// MessageId: ERROR_PRINTQ_FULL
//
// MessageText:
//
//  The printer queue is full.
//
#define ERROR_PRINTQ_FULL                61L

//
// MessageId: ERROR_NO_SPOOL_SPACE
//
// MessageText:
//
//  Space to store the file waiting to be printed is
//  not available on the server.
//
#define ERROR_NO_SPOOL_SPACE             62L

//
// MessageId: ERROR_PRINT_CANCELLED
//
// MessageText:
//
//  Your file waiting to be printed was deleted.
//
#define ERROR_PRINT_CANCELLED            63L

//
// MessageId: ERROR_NETNAME_DELETED
//
// MessageText:
//
//  The specified network name is no longer available.
//
#define ERROR_NETNAME_DELETED            64L

//
// MessageId: ERROR_NETWORK_ACCESS_DENIED
//
// MessageText:
//
//  Network access is denied.
//
#define ERROR_NETWORK_ACCESS_DENIED      65L

//
// MessageId: ERROR_BAD_DEV_TYPE
//
// MessageText:
//
//  The network resource type is not correct.
//
#define ERROR_BAD_DEV_TYPE               66L

//
// MessageId: ERROR_BAD_NET_NAME
//
// MessageText:
//
//  The network name cannot be found.
//
#define ERROR_BAD_NET_NAME               67L

//
// MessageId: ERROR_TOO_MANY_NAMES
//
// MessageText:
//
//  The name limit for the local computer network
//  adapter card was exceeded.
//
#define ERROR_TOO_MANY_NAMES             68L

//
// MessageId: ERROR_TOO_MANY_SESS
//
// MessageText:
//
//  The network BIOS session limit was exceeded.
//
#define ERROR_TOO_MANY_SESS              69L

//
// MessageId: ERROR_SHARING_PAUSED
//
// MessageText:
//
//  The remote server has been paused or is in the
//  process of being started.
//
#define ERROR_SHARING_PAUSED             70L

//
// MessageId: ERROR_REQ_NOT_ACCEP
//
// MessageText:
//
//  No more connections can be made to this remote computer at this time
//  because there are already as many connections as the computer can accept.
//
#define ERROR_REQ_NOT_ACCEP              71L

//
// MessageId: ERROR_REDIR_PAUSED
//
// MessageText:
//
//  The specified printer or disk device has been paused.
//
#define ERROR_REDIR_PAUSED               72L

//
// MessageId: ERROR_FILE_EXISTS
//
// MessageText:
//
//  The file exists.
//
#define ERROR_FILE_EXISTS                80L

//
// MessageId: ERROR_CANNOT_MAKE
//
// MessageText:
//
//  The directory or file cannot be created.
//
#define ERROR_CANNOT_MAKE                82L

//
// MessageId: ERROR_FAIL_I24
//
// MessageText:
//
//  Fail on INT 24
//
#define ERROR_FAIL_I24                   83L

//
// MessageId: ERROR_OUT_OF_STRUCTURES
//
// MessageText:
//
//  Storage to process this request is not available.
//
#define ERROR_OUT_OF_STRUCTURES          84L

//
// MessageId: ERROR_ALREADY_ASSIGNED
//
// MessageText:
//
//  The local device name is already in use.
//
#define ERROR_ALREADY_ASSIGNED           85L

//
// MessageId: ERROR_INVALID_PASSWORD
//
// MessageText:
//
//  The specified network password is not correct.
//
#define ERROR_INVALID_PASSWORD           86L

//
// MessageId: ERROR_INVALID_PARAMETER
//
// MessageText:
//
//  The parameter is incorrect.
//
#define ERROR_INVALID_PARAMETER          87L    // dderror

//
// MessageId: ERROR_NET_WRITE_FAULT
//
// MessageText:
//
//  A write fault occurred on the network.
//
#define ERROR_NET_WRITE_FAULT            88L

//
// MessageId: ERROR_NO_PROC_SLOTS
//
// MessageText:
//
//  The system cannot start another process at
//  this time.
//
#define ERROR_NO_PROC_SLOTS              89L

//
// MessageId: ERROR_TOO_MANY_SEMAPHORES
//
// MessageText:
//
//  Cannot create another system semaphore.
//
#define ERROR_TOO_MANY_SEMAPHORES        100L

//
// MessageId: ERROR_EXCL_SEM_ALREADY_OWNED
//
// MessageText:
//
//  The exclusive semaphore is owned by another process.
//
#define ERROR_EXCL_SEM_ALREADY_OWNED     101L

//
// MessageId: ERROR_SEM_IS_SET
//
// MessageText:
//
//  The semaphore is set and cannot be closed.
//
#define ERROR_SEM_IS_SET                 102L

//
// MessageId: ERROR_TOO_MANY_SEM_REQUESTS
//
// MessageText:
//
//  The semaphore cannot be set again.
//
#define ERROR_TOO_MANY_SEM_REQUESTS      103L

//
// MessageId: ERROR_INVALID_AT_INTERRUPT_TIME
//
// MessageText:
//
//  Cannot request exclusive semaphores at interrupt time.
//
#define ERROR_INVALID_AT_INTERRUPT_TIME  104L

//
// MessageId: ERROR_SEM_OWNER_DIED
//
// MessageText:
//
//  The previous ownership of this semaphore has ended.
//
#define ERROR_SEM_OWNER_DIED             105L

//
// MessageId: ERROR_SEM_USER_LIMIT
//
// MessageText:
//
//  Insert the diskette for drive %1.
//
#define ERROR_SEM_USER_LIMIT             106L

//
// MessageId: ERROR_DISK_CHANGE
//
// MessageText:
//
//  Program stopped because alternate diskette was not inserted.
//
#define ERROR_DISK_CHANGE                107L

//
// MessageId: ERROR_DRIVE_LOCKED
//
// MessageText:
//
//  The disk is in use or locked by
//  another process.
//
#define ERROR_DRIVE_LOCKED               108L

//
// MessageId: ERROR_BROKEN_PIPE
//
// MessageText:
//
//  The pipe has been ended.
//
#define ERROR_BROKEN_PIPE                109L

//
// MessageId: ERROR_OPEN_FAILED
//
// MessageText:
//
//  The system cannot open the
//  device or file specified.
//
#define ERROR_OPEN_FAILED                110L

//
// MessageId: ERROR_BUFFER_OVERFLOW
//
// MessageText:
//
//  The file name is too long.
//
#define ERROR_BUFFER_OVERFLOW            111L

//
// MessageId: ERROR_DISK_FULL
//
// MessageText:
//
//  There is not enough space on the disk.
//
#define ERROR_DISK_FULL                  112L

//
// MessageId: ERROR_NO_MORE_SEARCH_HANDLES
//
// MessageText:
//
//  No more internal file identifiers available.
//
#define ERROR_NO_MORE_SEARCH_HANDLES     113L

//
// MessageId: ERROR_INVALID_TARGET_HANDLE
//
// MessageText:
//
//  The target internal file identifier is incorrect.
//
#define ERROR_INVALID_TARGET_HANDLE      114L

//
// MessageId: ERROR_INVALID_CATEGORY
//
// MessageText:
//
//  The IOCTL call made by the application program is
//  not correct.
//
#define ERROR_INVALID_CATEGORY           117L

//
// MessageId: ERROR_INVALID_VERIFY_SWITCH
//
// MessageText:
//
//  The verify-on-write switch parameter value is not
//  correct.
//
#define ERROR_INVALID_VERIFY_SWITCH      118L

//
// MessageId: ERROR_BAD_DRIVER_LEVEL
//
// MessageText:
//
//  The system does not support the command requested.
//
#define ERROR_BAD_DRIVER_LEVEL           119L

//
// MessageId: ERROR_CALL_NOT_IMPLEMENTED
//
// MessageText:
//
//  This function is only valid in Windows NT mode.
//
#define ERROR_CALL_NOT_IMPLEMENTED       120L

//
// MessageId: ERROR_SEM_TIMEOUT
//
// MessageText:
//
//  The semaphore timeout period has expired.
//
#define ERROR_SEM_TIMEOUT                121L

//
// MessageId: ERROR_INSUFFICIENT_BUFFER
//
// MessageText:
//
//  The data area passed to a system call is too
//  small.
//
#define ERROR_INSUFFICIENT_BUFFER        122L    // dderror

//
// MessageId: ERROR_INVALID_NAME
//
// MessageText:
//
//  The filename, directory name, or volume label syntax is incorrect.
//
#define ERROR_INVALID_NAME               123L

//
// MessageId: ERROR_INVALID_LEVEL
//
// MessageText:
//
//  The system call level is not correct.
//
#define ERROR_INVALID_LEVEL              124L

//
// MessageId: ERROR_NO_VOLUME_LABEL
//
// MessageText:
//
//  The disk has no volume label.
//
#define ERROR_NO_VOLUME_LABEL            125L

//
// MessageId: ERROR_MOD_NOT_FOUND
//
// MessageText:
//
//  The specified module could not be found.
//
#define ERROR_MOD_NOT_FOUND              126L

//
// MessageId: ERROR_PROC_NOT_FOUND
//
// MessageText:
//
//  The specified procedure could not be found.
//
#define ERROR_PROC_NOT_FOUND             127L

//
// MessageId: ERROR_WAIT_NO_CHILDREN
//
// MessageText:
//
//  There are no child processes to wait for.
//
#define ERROR_WAIT_NO_CHILDREN           128L

//
// MessageId: ERROR_CHILD_NOT_COMPLETE
//
// MessageText:
//
//  The %1 application cannot be run in Windows NT mode.
//
#define ERROR_CHILD_NOT_COMPLETE         129L

//
// MessageId: ERROR_DIRECT_ACCESS_HANDLE
//
// MessageText:
//
//  Attempt to use a file handle to an open disk partition for an
//  operation other than raw disk I/O.
//
#define ERROR_DIRECT_ACCESS_HANDLE       130L

//
// MessageId: ERROR_NEGATIVE_SEEK
//
// MessageText:
//
//  An attempt was made to move the file pointer before the beginning of the file.
//
#define ERROR_NEGATIVE_SEEK              131L

//
// MessageId: ERROR_SEEK_ON_DEVICE
//
// MessageText:
//
//  The file pointer cannot be set on the specified device or file.
//
#define ERROR_SEEK_ON_DEVICE             132L

//
// MessageId: ERROR_IS_JOIN_TARGET
//
// MessageText:
//
//  A JOIN or SUBST command
//  cannot be used for a drive that
//  contains previously joined drives.
//
#define ERROR_IS_JOIN_TARGET             133L

//
// MessageId: ERROR_IS_JOINED
//
// MessageText:
//
//  An attempt was made to use a
//  JOIN or SUBST command on a drive that has
//  already been joined.
//
#define ERROR_IS_JOINED                  134L

//
// MessageId: ERROR_IS_SUBSTED
//
// MessageText:
//
//  An attempt was made to use a
//  JOIN or SUBST command on a drive that has
//  already been substituted.
//
#define ERROR_IS_SUBSTED                 135L

//
// MessageId: ERROR_NOT_JOINED
//
// MessageText:
//
//  The system tried to delete
//  the JOIN of a drive that is not joined.
//
#define ERROR_NOT_JOINED                 136L

//
// MessageId: ERROR_NOT_SUBSTED
//
// MessageText:
//
//  The system tried to delete the
//  substitution of a drive that is not substituted.
//
#define ERROR_NOT_SUBSTED                137L

//
// MessageId: ERROR_JOIN_TO_JOIN
//
// MessageText:
//
//  The system tried to join a drive
//  to a directory on a joined drive.
//
#define ERROR_JOIN_TO_JOIN               138L

//
// MessageId: ERROR_SUBST_TO_SUBST
//
// MessageText:
//
//  The system tried to substitute a
//  drive to a directory on a substituted drive.
//
#define ERROR_SUBST_TO_SUBST             139L

//
// MessageId: ERROR_JOIN_TO_SUBST
//
// MessageText:
//
//  The system tried to join a drive to
//  a directory on a substituted drive.
//
#define ERROR_JOIN_TO_SUBST              140L

//
// MessageId: ERROR_SUBST_TO_JOIN
//
// MessageText:
//
//  The system tried to SUBST a drive
//  to a directory on a joined drive.
//
#define ERROR_SUBST_TO_JOIN              141L

//
// MessageId: ERROR_BUSY_DRIVE
//
// MessageText:
//
//  The system cannot perform a JOIN or SUBST at this time.
//
#define ERROR_BUSY_DRIVE                 142L

//
// MessageId: ERROR_SAME_DRIVE
//
// MessageText:
//
//  The system cannot join or substitute a
//  drive to or for a directory on the same drive.
//
#define ERROR_SAME_DRIVE                 143L

//
// MessageId: ERROR_DIR_NOT_ROOT
//
// MessageText:
//
//  The directory is not a subdirectory of the root directory.
//
#define ERROR_DIR_NOT_ROOT               144L

//
// MessageId: ERROR_DIR_NOT_EMPTY
//
// MessageText:
//
//  The directory is not empty.
//
#define ERROR_DIR_NOT_EMPTY              145L

//
// MessageId: ERROR_IS_SUBST_PATH
//
// MessageText:
//
//  The path specified is being used in
//  a substitute.
//
#define ERROR_IS_SUBST_PATH              146L

//
// MessageId: ERROR_IS_JOIN_PATH
//
// MessageText:
//
//  Not enough resources are available to
//  process this command.
//
#define ERROR_IS_JOIN_PATH               147L

//
// MessageId: ERROR_PATH_BUSY
//
// MessageText:
//
//  The path specified cannot be used at this time.
//
#define ERROR_PATH_BUSY                  148L

//
// MessageId: ERROR_IS_SUBST_TARGET
//
// MessageText:
//
//  An attempt was made to join
//  or substitute a drive for which a directory
//  on the drive is the target of a previous
//  substitute.
//
#define ERROR_IS_SUBST_TARGET            149L

//
// MessageId: ERROR_SYSTEM_TRACE
//
// MessageText:
//
//  System trace information was not specified in your
//  CONFIG.SYS file, or tracing is disallowed.
//
#define ERROR_SYSTEM_TRACE               150L

//
// MessageId: ERROR_INVALID_EVENT_COUNT
//
// MessageText:
//
//  The number of specified semaphore events for
//  DosMuxSemWait is not correct.
//
#define ERROR_INVALID_EVENT_COUNT        151L

//
// MessageId: ERROR_TOO_MANY_MUXWAITERS
//
// MessageText:
//
//  DosMuxSemWait did not execute; too many semaphores
//  are already set.
//
#define ERROR_TOO_MANY_MUXWAITERS        152L

//
// MessageId: ERROR_INVALID_LIST_FORMAT
//
// MessageText:
//
//  The DosMuxSemWait list is not correct.
//
#define ERROR_INVALID_LIST_FORMAT        153L

//
// MessageId: ERROR_LABEL_TOO_LONG
//
// MessageText:
//
//  The volume label you entered exceeds the label character
//  limit of the target file system.
//
#define ERROR_LABEL_TOO_LONG             154L

//
// MessageId: ERROR_TOO_MANY_TCBS
//
// MessageText:
//
//  Cannot create another thread.
//
#define ERROR_TOO_MANY_TCBS              155L

//
// MessageId: ERROR_SIGNAL_REFUSED
//
// MessageText:
//
//  The recipient process has refused the signal.
//
#define ERROR_SIGNAL_REFUSED             156L

//
// MessageId: ERROR_DISCARDED
//
// MessageText:
//
//  The segment is already discarded and cannot be locked.
//
#define ERROR_DISCARDED                  157L

//
// MessageId: ERROR_NOT_LOCKED
//
// MessageText:
//
//  The segment is already unlocked.
//
#define ERROR_NOT_LOCKED                 158L

//
// MessageId: ERROR_BAD_THREADID_ADDR
//
// MessageText:
//
//  The address for the thread ID is not correct.
//
#define ERROR_BAD_THREADID_ADDR          159L

//
// MessageId: ERROR_BAD_ARGUMENTS
//
// MessageText:
//
//  The argument string passed to DosExecPgm is not correct.
//
#define ERROR_BAD_ARGUMENTS              160L

//
// MessageId: ERROR_BAD_PATHNAME
//
// MessageText:
//
//  The specified path is invalid.
//
#define ERROR_BAD_PATHNAME               161L

//
// MessageId: ERROR_SIGNAL_PENDING
//
// MessageText:
//
//  A signal is already pending.
//
#define ERROR_SIGNAL_PENDING             162L

//
// MessageId: ERROR_MAX_THRDS_REACHED
//
// MessageText:
//
//  No more threads can be created in the system.
//
#define ERROR_MAX_THRDS_REACHED          164L

//
// MessageId: ERROR_LOCK_FAILED
//
// MessageText:
//
//  Unable to lock a region of a file.
//
#define ERROR_LOCK_FAILED                167L

//
// MessageId: ERROR_BUSY
//
// MessageText:
//
//  The requested resource is in use.
//
#define ERROR_BUSY                       170L

//
// MessageId: ERROR_CANCEL_VIOLATION
//
// MessageText:
//
//  A lock request was not outstanding for the supplied cancel region.
//
#define ERROR_CANCEL_VIOLATION           173L

//
// MessageId: ERROR_ATOMIC_LOCKS_NOT_SUPPORTED
//
// MessageText:
//
//  The file system does not support atomic changes to the lock type.
//
#define ERROR_ATOMIC_LOCKS_NOT_SUPPORTED 174L

//
// MessageId: ERROR_INVALID_SEGMENT_NUMBER
//
// MessageText:
//
//  The system detected a segment number that was not correct.
//
#define ERROR_INVALID_SEGMENT_NUMBER     180L

//
// MessageId: ERROR_INVALID_ORDINAL
//
// MessageText:
//
//  The operating system cannot run %1.
//
#define ERROR_INVALID_ORDINAL            182L

//
// MessageId: ERROR_ALREADY_EXISTS
//
// MessageText:
//
//  Cannot create a file when that file already exists.
//
#define ERROR_ALREADY_EXISTS             183L

//
// MessageId: ERROR_INVALID_FLAG_NUMBER
//
// MessageText:
//
//  The flag passed is not correct.
//
#define ERROR_INVALID_FLAG_NUMBER        186L

//
// MessageId: ERROR_SEM_NOT_FOUND
//
// MessageText:
//
//  The specified system semaphore name was not found.
//
#define ERROR_SEM_NOT_FOUND              187L

//
// MessageId: ERROR_INVALID_STARTING_CODESEG
//
// MessageText:
//
//  The operating system cannot run %1.
//
#define ERROR_INVALID_STARTING_CODESEG   188L

//
// MessageId: ERROR_INVALID_STACKSEG
//
// MessageText:
//
//  The operating system cannot run %1.
//
#define ERROR_INVALID_STACKSEG           189L

//
// MessageId: ERROR_INVALID_MODULETYPE
//
// MessageText:
//
//  The operating system cannot run %1.
//
#define ERROR_INVALID_MODULETYPE         190L

//
// MessageId: ERROR_INVALID_EXE_SIGNATURE
//
// MessageText:
//
//  Cannot run %1 in Windows NT mode.
//
#define ERROR_INVALID_EXE_SIGNATURE      191L

//
// MessageId: ERROR_EXE_MARKED_INVALID
//
// MessageText:
//
//  The operating system cannot run %1.
//
#define ERROR_EXE_MARKED_INVALID         192L

//
// MessageId: ERROR_BAD_EXE_FORMAT
//
// MessageText:
//
//  %1 is not a valid Windows NT application.
//
#define ERROR_BAD_EXE_FORMAT             193L

//
// MessageId: ERROR_ITERATED_DATA_EXCEEDS_64k
//
// MessageText:
//
//  The operating system cannot run %1.
//
#define ERROR_ITERATED_DATA_EXCEEDS_64k  194L

//
// MessageId: ERROR_INVALID_MINALLOCSIZE
//
// MessageText:
//
//  The operating system cannot run %1.
//
#define ERROR_INVALID_MINALLOCSIZE       195L

//
// MessageId: ERROR_DYNLINK_FROM_INVALID_RING
//
// MessageText:
//
//  The operating system cannot run this
//  application program.
//
#define ERROR_DYNLINK_FROM_INVALID_RING  196L

//
// MessageId: ERROR_IOPL_NOT_ENABLED
//
// MessageText:
//
//  The operating system is not presently
//  configured to run this application.
//
#define ERROR_IOPL_NOT_ENABLED           197L

//
// MessageId: ERROR_INVALID_SEGDPL
//
// MessageText:
//
//  The operating system cannot run %1.
//
#define ERROR_INVALID_SEGDPL             198L

//
// MessageId: ERROR_AUTODATASEG_EXCEEDS_64k
//
// MessageText:
//
//  The operating system cannot run this
//  application program.
//
#define ERROR_AUTODATASEG_EXCEEDS_64k    199L

//
// MessageId: ERROR_RING2SEG_MUST_BE_MOVABLE
//
// MessageText:
//
//  The code segment cannot be greater than or equal to 64KB.
//
#define ERROR_RING2SEG_MUST_BE_MOVABLE   200L

//
// MessageId: ERROR_RELOC_CHAIN_XEEDS_SEGLIM
//
// MessageText:
//
//  The operating system cannot run %1.
//
#define ERROR_RELOC_CHAIN_XEEDS_SEGLIM   201L

//
// MessageId: ERROR_INFLOOP_IN_RELOC_CHAIN
//
// MessageText:
//
//  The operating system cannot run %1.
//
#define ERROR_INFLOOP_IN_RELOC_CHAIN     202L

//
// MessageId: ERROR_ENVVAR_NOT_FOUND
//
// MessageText:
//
//  The system could not find the environment
//  option that was entered.
//
#define ERROR_ENVVAR_NOT_FOUND           203L

//
// MessageId: ERROR_NO_SIGNAL_SENT
//
// MessageText:
//
//  No process in the command subtree has a
//  signal handler.
//
#define ERROR_NO_SIGNAL_SENT             205L

//
// MessageId: ERROR_FILENAME_EXCED_RANGE
//
// MessageText:
//
//  The filename or extension is too long.
//
#define ERROR_FILENAME_EXCED_RANGE       206L

//
// MessageId: ERROR_RING2_STACK_IN_USE
//
// MessageText:
//
//  The ring 2 stack is in use.
//
#define ERROR_RING2_STACK_IN_USE         207L

//
// MessageId: ERROR_META_EXPANSION_TOO_LONG
//
// MessageText:
//
//  The global filename characters, * or ?, are entered
//  incorrectly or too many global filename characters are specified.
//
#define ERROR_META_EXPANSION_TOO_LONG    208L

//
// MessageId: ERROR_INVALID_SIGNAL_NUMBER
//
// MessageText:
//
//  The signal being posted is not correct.
//
#define ERROR_INVALID_SIGNAL_NUMBER      209L

//
// MessageId: ERROR_THREAD_1_INACTIVE
//
// MessageText:
//
//  The signal handler cannot be set.
//
#define ERROR_THREAD_1_INACTIVE          210L

//
// MessageId: ERROR_LOCKED
//
// MessageText:
//
//  The segment is locked and cannot be reallocated.
//
#define ERROR_LOCKED                     212L

//
// MessageId: ERROR_TOO_MANY_MODULES
//
// MessageText:
//
//  Too many dynamic link modules are attached to this
//  program or dynamic link module.
//
#define ERROR_TOO_MANY_MODULES           214L

//
// MessageId: ERROR_NESTING_NOT_ALLOWED
//
// MessageText:
//
//  Can't nest calls to LoadModule.
//
#define ERROR_NESTING_NOT_ALLOWED        215L

//
// MessageId: ERROR_EXE_MACHINE_TYPE_MISMATCH
//
// MessageText:
//
//  The image file %1 is valid, but is for a machine type other
//  than the current machine.
//
#define ERROR_EXE_MACHINE_TYPE_MISMATCH  216L

//
// MessageId: ERROR_BAD_PIPE
//
// MessageText:
//
//  The pipe state is invalid.
//
#define ERROR_BAD_PIPE                   230L

//
// MessageId: ERROR_PIPE_BUSY
//
// MessageText:
//
//  All pipe instances are busy.
//
#define ERROR_PIPE_BUSY                  231L

//
// MessageId: ERROR_NO_DATA
//
// MessageText:
//
//  The pipe is being closed.
//
#define ERROR_NO_DATA                    232L

//
// MessageId: ERROR_PIPE_NOT_CONNECTED
//
// MessageText:
//
//  No process is on the other end of the pipe.
//
#define ERROR_PIPE_NOT_CONNECTED         233L

//
// MessageId: ERROR_MORE_DATA
//
// MessageText:
//
//  More data is available.
//
#define ERROR_MORE_DATA                  234L    // dderror

//
// MessageId: ERROR_VC_DISCONNECTED
//
// MessageText:
//
//  The session was cancelled.
//
#define ERROR_VC_DISCONNECTED            240L

//
// MessageId: ERROR_INVALID_EA_NAME
//
// MessageText:
//
//  The specified extended attribute name was invalid.
//
#define ERROR_INVALID_EA_NAME            254L

//
// MessageId: ERROR_EA_LIST_INCONSISTENT
//
// MessageText:
//
//  The extended attributes are inconsistent.
//
#define ERROR_EA_LIST_INCONSISTENT       255L

//
// MessageId: ERROR_NO_MORE_ITEMS
//
// MessageText:
//
//  No more data is available.
//
#define ERROR_NO_MORE_ITEMS              259L

//
// MessageId: ERROR_CANNOT_COPY
//
// MessageText:
//
//  The Copy API cannot be used.
//
#define ERROR_CANNOT_COPY                266L

//
// MessageId: ERROR_DIRECTORY
//
// MessageText:
//
//  The directory name is invalid.
//
#define ERROR_DIRECTORY                  267L

//
// MessageId: ERROR_EAS_DIDNT_FIT
//
// MessageText:
//
//  The extended attributes did not fit in the buffer.
//
#define ERROR_EAS_DIDNT_FIT              275L

//
// MessageId: ERROR_EA_FILE_CORRUPT
//
// MessageText:
//
//  The extended attribute file on the mounted file system is corrupt.
//
#define ERROR_EA_FILE_CORRUPT            276L

//
// MessageId: ERROR_EA_TABLE_FULL
//
// MessageText:
//
//  The extended attribute table file is full.
//
#define ERROR_EA_TABLE_FULL              277L

//
// MessageId: ERROR_INVALID_EA_HANDLE
//
// MessageText:
//
//  The specified extended attribute handle is invalid.
//
#define ERROR_INVALID_EA_HANDLE          278L

//
// MessageId: ERROR_EAS_NOT_SUPPORTED
//
// MessageText:
//
//  The mounted file system does not support extended attributes.
//
#define ERROR_EAS_NOT_SUPPORTED          282L

//
// MessageId: ERROR_NOT_OWNER
//
// MessageText:
//
//  Attempt to release mutex not owned by caller.
//
#define ERROR_NOT_OWNER                  288L

//
// MessageId: ERROR_TOO_MANY_POSTS
//
// MessageText:
//
//  Too many posts were made to a semaphore.
//
#define ERROR_TOO_MANY_POSTS             298L

//
// MessageId: ERROR_PARTIAL_COPY
//
// MessageText:
//
//  Only part of a Read/WriteProcessMemory request was completed.
//
#define ERROR_PARTIAL_COPY               299L

//
// MessageId: ERROR_MR_MID_NOT_FOUND
//
// MessageText:
//
//  The system cannot find message for message number 0x%1
//  in message file for %2.
//
#define ERROR_MR_MID_NOT_FOUND           317L

//
// MessageId: ERROR_INVALID_ADDRESS
//
// MessageText:
//
//  Attempt to access invalid address.
//
#define ERROR_INVALID_ADDRESS            487L

//
// MessageId: ERROR_ARITHMETIC_OVERFLOW
//
// MessageText:
//
//  Arithmetic result exceeded 32 bits.
//
#define ERROR_ARITHMETIC_OVERFLOW        534L

//
// MessageId: ERROR_PIPE_CONNECTED
//
// MessageText:
//
//  There is a process on other end of the pipe.
//
#define ERROR_PIPE_CONNECTED             535L

//
// MessageId: ERROR_PIPE_LISTENING
//
// MessageText:
//
//  Waiting for a process to open the other end of the pipe.
//
#define ERROR_PIPE_LISTENING             536L

//
// MessageId: ERROR_EA_ACCESS_DENIED
//
// MessageText:
//
//  Access to the extended attribute was denied.
//
#define ERROR_EA_ACCESS_DENIED           994L

//
// MessageId: ERROR_OPERATION_ABORTED
//
// MessageText:
//
//  The I/O operation has been aborted because of either a thread exit
//  or an application request.
//
#define ERROR_OPERATION_ABORTED          995L

//
// MessageId: ERROR_IO_INCOMPLETE
//
// MessageText:
//
//  Overlapped I/O event is not in a signalled state.
//
#define ERROR_IO_INCOMPLETE              996L

//
// MessageId: ERROR_IO_PENDING
//
// MessageText:
//
//  Overlapped I/O operation is in progress.
//
#define ERROR_IO_PENDING                 997L    // dderror

//
// MessageId: ERROR_NOACCESS
//
// MessageText:
//
//  Invalid access to memory location.
//
#define ERROR_NOACCESS                   998L

//
// MessageId: ERROR_SWAPERROR
//
// MessageText:
//
//  Error performing inpage operation.
//
#define ERROR_SWAPERROR                  999L

//
// MessageId: ERROR_STACK_OVERFLOW
//
// MessageText:
//
//  Recursion too deep, stack overflowed.
//
#define ERROR_STACK_OVERFLOW             1001L

//
// MessageId: ERROR_INVALID_MESSAGE
//
// MessageText:
//
//  The window cannot act on the sent message.
//
#define ERROR_INVALID_MESSAGE            1002L

//
// MessageId: ERROR_CAN_NOT_COMPLETE
//
// MessageText:
//
//  Cannot complete this function.
//
#define ERROR_CAN_NOT_COMPLETE           1003L

//
// MessageId: ERROR_INVALID_FLAGS
//
// MessageText:
//
//  Invalid flags.
//
#define ERROR_INVALID_FLAGS              1004L

//
// MessageId: ERROR_UNRECOGNIZED_VOLUME
//
// MessageText:
//
//  The volume does not contain a recognized file system.
//  Please make sure that all required file system drivers are loaded and that the
//  volume is not corrupt.
//
#define ERROR_UNRECOGNIZED_VOLUME        1005L

//
// MessageId: ERROR_FILE_INVALID
//
// MessageText:
//
//  The volume for a file has been externally altered such that the
//  opened file is no longer valid.
//
#define ERROR_FILE_INVALID               1006L

//
// MessageId: ERROR_FULLSCREEN_MODE
//
// MessageText:
//
//  The requested operation cannot be performed in full-screen mode.
//
#define ERROR_FULLSCREEN_MODE            1007L

//
// MessageId: ERROR_NO_TOKEN
//
// MessageText:
//
//  An attempt was made to reference a token that does not exist.
//
#define ERROR_NO_TOKEN                   1008L

//
// MessageId: ERROR_BADDB
//
// MessageText:
//
//  The configuration registry database is corrupt.
//
#define ERROR_BADDB                      1009L

//
// MessageId: ERROR_BADKEY
//
// MessageText:
//
//  The configuration registry key is invalid.
//
#define ERROR_BADKEY                     1010L

//
// MessageId: ERROR_CANTOPEN
//
// MessageText:
//
//  The configuration registry key could not be opened.
//
#define ERROR_CANTOPEN                   1011L

//
// MessageId: ERROR_CANTREAD
//
// MessageText:
//
//  The configuration registry key could not be read.
//
#define ERROR_CANTREAD                   1012L

//
// MessageId: ERROR_CANTWRITE
//
// MessageText:
//
//  The configuration registry key could not be written.
//
#define ERROR_CANTWRITE                  1013L

//
// MessageId: ERROR_REGISTRY_RECOVERED
//
// MessageText:
//
//  One of the files in the Registry database had to be recovered
//  by use of a log or alternate copy.  The recovery was successful.
//
#define ERROR_REGISTRY_RECOVERED         1014L

//
// MessageId: ERROR_REGISTRY_CORRUPT
//
// MessageText:
//
//  The Registry is corrupt. The structure of one of the files that contains
//  Registry data is corrupt, or the system's image of the file in memory
//  is corrupt, or the file could not be recovered because the alternate
//  copy or log was absent or corrupt.
//
#define ERROR_REGISTRY_CORRUPT           1015L

//
// MessageId: ERROR_REGISTRY_IO_FAILED
//
// MessageText:
//
//  An I/O operation initiated by the Registry failed unrecoverably.
//  The Registry could not read in, or write out, or flush, one of the files
//  that contain the system's image of the Registry.
//
#define ERROR_REGISTRY_IO_FAILED         1016L

//
// MessageId: ERROR_NOT_REGISTRY_FILE
//
// MessageText:
//
//  The system has attempted to load or restore a file into the Registry, but the
//  specified file is not in a Registry file format.
//
#define ERROR_NOT_REGISTRY_FILE          1017L

//
// MessageId: ERROR_KEY_DELETED
//
// MessageText:
//
//  Illegal operation attempted on a Registry key which has been marked for deletion.
//
#define ERROR_KEY_DELETED                1018L

//
// MessageId: ERROR_NO_LOG_SPACE
//
// MessageText:
//
//  System could not allocate the required space in a Registry log.
//
#define ERROR_NO_LOG_SPACE               1019L

//
// MessageId: ERROR_KEY_HAS_CHILDREN
//
// MessageText:
//
//  Cannot create a symbolic link in a Registry key that already
//  has subkeys or values.
//
#define ERROR_KEY_HAS_CHILDREN           1020L

//
// MessageId: ERROR_CHILD_MUST_BE_VOLATILE
//
// MessageText:
//
//  Cannot create a stable subkey under a volatile parent key.
//
#define ERROR_CHILD_MUST_BE_VOLATILE     1021L

//
// MessageId: ERROR_NOTIFY_ENUM_DIR
//
// MessageText:
//
//  A notify change request is being completed and the information
//  is not being returned in the caller's buffer. The caller now
//  needs to enumerate the files to find the changes.
//
#define ERROR_NOTIFY_ENUM_DIR            1022L

//
// MessageId: ERROR_DEPENDENT_SERVICES_RUNNING
//
// MessageText:
//
//  A stop control has been sent to a service which other running services
//  are dependent on.
//
#define ERROR_DEPENDENT_SERVICES_RUNNING 1051L

//
// MessageId: ERROR_INVALID_SERVICE_CONTROL
//
// MessageText:
//
//  The requested control is not valid for this service
//
#define ERROR_INVALID_SERVICE_CONTROL    1052L

//
// MessageId: ERROR_SERVICE_REQUEST_TIMEOUT
//
// MessageText:
//
//  The service did not respond to the start or control request in a timely
//  fashion.
//
#define ERROR_SERVICE_REQUEST_TIMEOUT    1053L

//
// MessageId: ERROR_SERVICE_NO_THREAD
//
// MessageText:
//
//  A thread could not be created for the service.
//
#define ERROR_SERVICE_NO_THREAD          1054L

//
// MessageId: ERROR_SERVICE_DATABASE_LOCKED
//
// MessageText:
//
//  The service database is locked.
//
#define ERROR_SERVICE_DATABASE_LOCKED    1055L

//
// MessageId: ERROR_SERVICE_ALREADY_RUNNING
//
// MessageText:
//
//  An instance of the service is already running.
//
#define ERROR_SERVICE_ALREADY_RUNNING    1056L

//
// MessageId: ERROR_INVALID_SERVICE_ACCOUNT
//
// MessageText:
//
//  The account name is invalid or does not exist.
//
#define ERROR_INVALID_SERVICE_ACCOUNT    1057L

//
// MessageId: ERROR_SERVICE_DISABLED
//
// MessageText:
//
//  The specified service is disabled and cannot be started.
//
#define ERROR_SERVICE_DISABLED           1058L

//
// MessageId: ERROR_CIRCULAR_DEPENDENCY
//
// MessageText:
//
//  Circular service dependency was specified.
//
#define ERROR_CIRCULAR_DEPENDENCY        1059L

//
// MessageId: ERROR_SERVICE_DOES_NOT_EXIST
//
// MessageText:
//
//  The specified service does not exist as an installed service.
//
#define ERROR_SERVICE_DOES_NOT_EXIST     1060L

//
// MessageId: ERROR_SERVICE_CANNOT_ACCEPT_CTRL
//
// MessageText:
//
//  The service cannot accept control messages at this time.
//
#define ERROR_SERVICE_CANNOT_ACCEPT_CTRL 1061L

//
// MessageId: ERROR_SERVICE_NOT_ACTIVE
//
// MessageText:
//
//  The service has not been started.
//
#define ERROR_SERVICE_NOT_ACTIVE         1062L

//
// MessageId: ERROR_FAILED_SERVICE_CONTROLLER_CONNECT
//
// MessageText:
//
//  The service process could not connect to the service controller.
//
#define ERROR_FAILED_SERVICE_CONTROLLER_CONNECT 1063L

//
// MessageId: ERROR_EXCEPTION_IN_SERVICE
//
// MessageText:
//
//  An exception occurred in the service when handling the control request.
//
#define ERROR_EXCEPTION_IN_SERVICE       1064L

//
// MessageId: ERROR_DATABASE_DOES_NOT_EXIST
//
// MessageText:
//
//  The database specified does not exist.
//
#define ERROR_DATABASE_DOES_NOT_EXIST    1065L

//
// MessageId: ERROR_SERVICE_SPECIFIC_ERROR
//
// MessageText:
//
//  The service has returned a service-specific error code.
//
#define ERROR_SERVICE_SPECIFIC_ERROR     1066L

//
// MessageId: ERROR_PROCESS_ABORTED
//
// MessageText:
//
//  The process terminated unexpectedly.
//
#define ERROR_PROCESS_ABORTED            1067L

//
// MessageId: ERROR_SERVICE_DEPENDENCY_FAIL
//
// MessageText:
//
//  The dependency service or group failed to start.
//
#define ERROR_SERVICE_DEPENDENCY_FAIL    1068L

//
// MessageId: ERROR_SERVICE_LOGON_FAILED
//
// MessageText:
//
//  The service did not start due to a logon failure.
//
#define ERROR_SERVICE_LOGON_FAILED       1069L

//
// MessageId: ERROR_SERVICE_START_HANG
//
// MessageText:
//
//  After starting, the service hung in a start-pending state.
//
#define ERROR_SERVICE_START_HANG         1070L

//
// MessageId: ERROR_INVALID_SERVICE_LOCK
//
// MessageText:
//
//  The specified service database lock is invalid.
//
#define ERROR_INVALID_SERVICE_LOCK       1071L

//
// MessageId: ERROR_SERVICE_MARKED_FOR_DELETE
//
// MessageText:
//
//  The specified service has been marked for deletion.
//
#define ERROR_SERVICE_MARKED_FOR_DELETE  1072L

//
// MessageId: ERROR_SERVICE_EXISTS
//
// MessageText:
//
//  The specified service already exists.
//
#define ERROR_SERVICE_EXISTS             1073L

//
// MessageId: ERROR_ALREADY_RUNNING_LKG
//
// MessageText:
//
//  The system is currently running with the last-known-good configuration.
//
#define ERROR_ALREADY_RUNNING_LKG        1074L

//
// MessageId: ERROR_SERVICE_DEPENDENCY_DELETED
//
// MessageText:
//
//  The dependency service does not exist or has been marked for
//  deletion.
//
#define ERROR_SERVICE_DEPENDENCY_DELETED 1075L

//
// MessageId: ERROR_BOOT_ALREADY_ACCEPTED
//
// MessageText:
//
//  The current boot has already been accepted for use as the
//  last-known-good control set.
//
#define ERROR_BOOT_ALREADY_ACCEPTED      1076L

//
// MessageId: ERROR_SERVICE_NEVER_STARTED
//
// MessageText:
//
//  No attempts to start the service have been made since the last boot.
//
#define ERROR_SERVICE_NEVER_STARTED      1077L

//
// MessageId: ERROR_DUPLICATE_SERVICE_NAME
//
// MessageText:
//
//  The name is already in use as either a service name or a service display
//  name.
//
#define ERROR_DUPLICATE_SERVICE_NAME     1078L

//
// MessageId: ERROR_DIFFERENT_SERVICE_ACCOUNT
//
// MessageText:
//
//  The account specified for this service is different from the account
//  specified for other services running in the same process.
//
#define ERROR_DIFFERENT_SERVICE_ACCOUNT  1079L

//
// MessageId: ERROR_END_OF_MEDIA
//
// MessageText:
//
//  The physical end of the tape has been reached.
//
#define ERROR_END_OF_MEDIA               1100L

//
// MessageId: ERROR_FILEMARK_DETECTED
//
// MessageText:
//
//  A tape access reached a filemark.
//
#define ERROR_FILEMARK_DETECTED          1101L

//
// MessageId: ERROR_BEGINNING_OF_MEDIA
//
// MessageText:
//
//  Beginning of tape or partition was encountered.
//
#define ERROR_BEGINNING_OF_MEDIA         1102L

//
// MessageId: ERROR_SETMARK_DETECTED
//
// MessageText:
//
//  A tape access reached the end of a set of files.
//
#define ERROR_SETMARK_DETECTED           1103L

//
// MessageId: ERROR_NO_DATA_DETECTED
//
// MessageText:
//
//  No more data is on the tape.
//
#define ERROR_NO_DATA_DETECTED           1104L

//
// MessageId: ERROR_PARTITION_FAILURE
//
// MessageText:
//
//  Tape could not be partitioned.
//
#define ERROR_PARTITION_FAILURE          1105L

//
// MessageId: ERROR_INVALID_BLOCK_LENGTH
//
// MessageText:
//
//  When accessing a new tape of a multivolume partition, the current
//  blocksize is incorrect.
//
#define ERROR_INVALID_BLOCK_LENGTH       1106L

//
// MessageId: ERROR_DEVICE_NOT_PARTITIONED
//
// MessageText:
//
//  Tape partition information could not be found when loading a tape.
//
#define ERROR_DEVICE_NOT_PARTITIONED     1107L

//
// MessageId: ERROR_UNABLE_TO_LOCK_MEDIA
//
// MessageText:
//
//  Unable to lock the media eject mechanism.
//
#define ERROR_UNABLE_TO_LOCK_MEDIA       1108L

//
// MessageId: ERROR_UNABLE_TO_UNLOAD_MEDIA
//
// MessageText:
//
//  Unable to unload the media.
//
#define ERROR_UNABLE_TO_UNLOAD_MEDIA     1109L

//
// MessageId: ERROR_MEDIA_CHANGED
//
// MessageText:
//
//  Media in drive may have changed.
//
#define ERROR_MEDIA_CHANGED              1110L

//
// MessageId: ERROR_BUS_RESET
//
// MessageText:
//
//  The I/O bus was reset.
//
#define ERROR_BUS_RESET                  1111L

//
// MessageId: ERROR_NO_MEDIA_IN_DRIVE
//
// MessageText:
//
//  No media in drive.
//
#define ERROR_NO_MEDIA_IN_DRIVE          1112L

//
// MessageId: ERROR_NO_UNICODE_TRANSLATION
//
// MessageText:
//
//  No mapping for the Unicode character exists in the target multi-byte code page.
//
#define ERROR_NO_UNICODE_TRANSLATION     1113L

//
// MessageId: ERROR_DLL_INIT_FAILED
//
// MessageText:
//
//  A dynamic link library (DLL) initialization routine failed.
//
#define ERROR_DLL_INIT_FAILED            1114L

//
// MessageId: ERROR_SHUTDOWN_IN_PROGRESS
//
// MessageText:
//
//  A system shutdown is in progress.
//
#define ERROR_SHUTDOWN_IN_PROGRESS       1115L

//
// MessageId: ERROR_NO_SHUTDOWN_IN_PROGRESS
//
// MessageText:
//
//  Unable to abort the system shutdown because no shutdown was in progress.
//
#define ERROR_NO_SHUTDOWN_IN_PROGRESS    1116L

//
// MessageId: ERROR_IO_DEVICE
//
// MessageText:
//
//  The request could not be performed because of an I/O device error.
//
#define ERROR_IO_DEVICE                  1117L

//
// MessageId: ERROR_SERIAL_NO_DEVICE
//
// MessageText:
//
//  No serial device was successfully initialized.  The serial driver will unload.
//
#define ERROR_SERIAL_NO_DEVICE           1118L

//
// MessageId: ERROR_IRQ_BUSY
//
// MessageText:
//
//  Unable to open a device that was sharing an interrupt request (IRQ)
//  with other devices. At least one other device that uses that IRQ
//  was already opened.
//
#define ERROR_IRQ_BUSY                   1119L

//
// MessageId: ERROR_MORE_WRITES
//
// MessageText:
//
//  A serial I/O operation was completed by another write to the serial port.
//  (The IOCTL_SERIAL_XOFF_COUNTER reached zero.)
//
#define ERROR_MORE_WRITES                1120L

//
// MessageId: ERROR_COUNTER_TIMEOUT
//
// MessageText:
//
//  A serial I/O operation completed because the time-out period expired.
//  (The IOCTL_SERIAL_XOFF_COUNTER did not reach zero.)
//
#define ERROR_COUNTER_TIMEOUT            1121L

//
// MessageId: ERROR_FLOPPY_ID_MARK_NOT_FOUND
//
// MessageText:
//
//  No ID address mark was found on the floppy disk.
//
#define ERROR_FLOPPY_ID_MARK_NOT_FOUND   1122L

//
// MessageId: ERROR_FLOPPY_WRONG_CYLINDER
//
// MessageText:
//
//  Mismatch between the floppy disk sector ID field and the floppy disk
//  controller track address.
//
#define ERROR_FLOPPY_WRONG_CYLINDER      1123L

//
// MessageId: ERROR_FLOPPY_UNKNOWN_ERROR
//
// MessageText:
//
//  The floppy disk controller reported an error that is not recognized
//  by the floppy disk driver.
//
#define ERROR_FLOPPY_UNKNOWN_ERROR       1124L

//
// MessageId: ERROR_FLOPPY_BAD_REGISTERS
//
// MessageText:
//
//  The floppy disk controller returned inconsistent results in its registers.
//
#define ERROR_FLOPPY_BAD_REGISTERS       1125L

//
// MessageId: ERROR_DISK_RECALIBRATE_FAILED
//
// MessageText:
//
//  While accessing the hard disk, a recalibrate operation failed, even after retries.
//
#define ERROR_DISK_RECALIBRATE_FAILED    1126L

//
// MessageId: ERROR_DISK_OPERATION_FAILED
//
// MessageText:
//
//  While accessing the hard disk, a disk operation failed even after retries.
//
#define ERROR_DISK_OPERATION_FAILED      1127L

//
// MessageId: ERROR_DISK_RESET_FAILED
//
// MessageText:
//
//  While accessing the hard disk, a disk controller reset was needed, but
//  even that failed.
//
#define ERROR_DISK_RESET_FAILED          1128L

//
// MessageId: ERROR_EOM_OVERFLOW
//
// MessageText:
//
//  Physical end of tape encountered.
//
#define ERROR_EOM_OVERFLOW               1129L

//
// MessageId: ERROR_NOT_ENOUGH_SERVER_MEMORY
//
// MessageText:
//
//  Not enough server storage is available to process this command.
//
#define ERROR_NOT_ENOUGH_SERVER_MEMORY   1130L

//
// MessageId: ERROR_POSSIBLE_DEADLOCK
//
// MessageText:
//
//  A potential deadlock condition has been detected.
//
#define ERROR_POSSIBLE_DEADLOCK          1131L

//
// MessageId: ERROR_MAPPED_ALIGNMENT
//
// MessageText:
//
//  The base address or the file offset specified does not have the proper
//  alignment.
//
#define ERROR_MAPPED_ALIGNMENT           1132L

//
// MessageId: ERROR_SET_POWER_STATE_VETOED
//
// MessageText:
//
//  An attempt to change the system power state was vetoed by another
//  application or driver.
//
#define ERROR_SET_POWER_STATE_VETOED     1140L

//
// MessageId: ERROR_SET_POWER_STATE_FAILED
//
// MessageText:
//
//  The system BIOS failed an attempt to change the system power state.
//
#define ERROR_SET_POWER_STATE_FAILED     1141L

//
// MessageId: ERROR_TOO_MANY_LINKS
//
// MessageText:
//
//  An attempt was made to create more links on a file than
//  the file system supports.
//
#define ERROR_TOO_MANY_LINKS             1142L

//
// MessageId: ERROR_OLD_WIN_VERSION
//
// MessageText:
//
//  The specified program requires a newer version of Windows.
//
#define ERROR_OLD_WIN_VERSION            1150L

//
// MessageId: ERROR_APP_WRONG_OS
//
// MessageText:
//
//  The specified program is not a Windows or MS-DOS program.
//
#define ERROR_APP_WRONG_OS               1151L

//
// MessageId: ERROR_SINGLE_INSTANCE_APP
//
// MessageText:
//
//  Cannot start more than one instance of the specified program.
//
#define ERROR_SINGLE_INSTANCE_APP        1152L

//
// MessageId: ERROR_RMODE_APP
//
// MessageText:
//
//  The specified program was written for an older version of Windows.
//
#define ERROR_RMODE_APP                  1153L

//
// MessageId: ERROR_INVALID_DLL
//
// MessageText:
//
//  One of the library files needed to run this application is damaged.
//
#define ERROR_INVALID_DLL                1154L

//
// MessageId: ERROR_NO_ASSOCIATION
//
// MessageText:
//
//  No application is associated with the specified file for this operation.
//
#define ERROR_NO_ASSOCIATION             1155L

//
// MessageId: ERROR_DDE_FAIL
//
// MessageText:
//
//  An error occurred in sending the command to the application.
//
#define ERROR_DDE_FAIL                   1156L

//
// MessageId: ERROR_DLL_NOT_FOUND
//
// MessageText:
//
//  One of the library files needed to run this application cannot be found.
//
#define ERROR_DLL_NOT_FOUND              1157L




///////////////////////////
//                       //
// Winnet32 Status Codes //
//                       //
///////////////////////////


//
// MessageId: ERROR_BAD_USERNAME
//
// MessageText:
//
//  The specified username is invalid.
//
#define ERROR_BAD_USERNAME               2202L

//
// MessageId: ERROR_NOT_CONNECTED
//
// MessageText:
//
//  This network connection does not exist.
//
#define ERROR_NOT_CONNECTED              2250L

//
// MessageId: ERROR_OPEN_FILES
//
// MessageText:
//
//  This network connection has files open or requests pending.
//
#define ERROR_OPEN_FILES                 2401L

//
// MessageId: ERROR_ACTIVE_CONNECTIONS
//
// MessageText:
//
//  Active connections still exist.
//
#define ERROR_ACTIVE_CONNECTIONS         2402L

//
// MessageId: ERROR_DEVICE_IN_USE
//
// MessageText:
//
//  The device is in use by an active process and cannot be disconnected.
//
#define ERROR_DEVICE_IN_USE              2404L

//
// MessageId: ERROR_BAD_DEVICE
//
// MessageText:
//
//  The specified device name is invalid.
//
#define ERROR_BAD_DEVICE                 1200L

//
// MessageId: ERROR_CONNECTION_UNAVAIL
//
// MessageText:
//
//  The device is not currently connected but it is a remembered connection.
//
#define ERROR_CONNECTION_UNAVAIL         1201L

//
// MessageId: ERROR_DEVICE_ALREADY_REMEMBERED
//
// MessageText:
//
//  An attempt was made to remember a device that had previously been remembered.
//
#define ERROR_DEVICE_ALREADY_REMEMBERED  1202L

//
// MessageId: ERROR_NO_NET_OR_BAD_PATH
//
// MessageText:
//
//  No network provider accepted the given network path.
//
#define ERROR_NO_NET_OR_BAD_PATH         1203L

//
// MessageId: ERROR_BAD_PROVIDER
//
// MessageText:
//
//  The specified network provider name is invalid.
//
#define ERROR_BAD_PROVIDER               1204L

//
// MessageId: ERROR_CANNOT_OPEN_PROFILE
//
// MessageText:
//
//  Unable to open the network connection profile.
//
#define ERROR_CANNOT_OPEN_PROFILE        1205L

//
// MessageId: ERROR_BAD_PROFILE
//
// MessageText:
//
//  The network connection profile is corrupt.
//
#define ERROR_BAD_PROFILE                1206L

//
// MessageId: ERROR_NOT_CONTAINER
//
// MessageText:
//
//  Cannot enumerate a non-container.
//
#define ERROR_NOT_CONTAINER              1207L

//
// MessageId: ERROR_EXTENDED_ERROR
//
// MessageText:
//
//  An extended error has occurred.
//
#define ERROR_EXTENDED_ERROR             1208L

//
// MessageId: ERROR_INVALID_GROUPNAME
//
// MessageText:
//
//  The format of the specified group name is invalid.
//
#define ERROR_INVALID_GROUPNAME          1209L

//
// MessageId: ERROR_INVALID_COMPUTERNAME
//
// MessageText:
//
//  The format of the specified computer name is invalid.
//
#define ERROR_INVALID_COMPUTERNAME       1210L

//
// MessageId: ERROR_INVALID_EVENTNAME
//
// MessageText:
//
//  The format of the specified event name is invalid.
//
#define ERROR_INVALID_EVENTNAME          1211L

//
// MessageId: ERROR_INVALID_DOMAINNAME
//
// MessageText:
//
//  The format of the specified domain name is invalid.
//
#define ERROR_INVALID_DOMAINNAME         1212L

//
// MessageId: ERROR_INVALID_SERVICENAME
//
// MessageText:
//
//  The format of the specified service name is invalid.
//
#define ERROR_INVALID_SERVICENAME        1213L

//
// MessageId: ERROR_INVALID_NETNAME
//
// MessageText:
//
//  The format of the specified network name is invalid.
//
#define ERROR_INVALID_NETNAME            1214L

//
// MessageId: ERROR_INVALID_SHARENAME
//
// MessageText:
//
//  The format of the specified share name is invalid.
//
#define ERROR_INVALID_SHARENAME          1215L

//
// MessageId: ERROR_INVALID_PASSWORDNAME
//
// MessageText:
//
//  The format of the specified password is invalid.
//
#define ERROR_INVALID_PASSWORDNAME       1216L

//
// MessageId: ERROR_INVALID_MESSAGENAME
//
// MessageText:
//
//  The format of the specified message name is invalid.
//
#define ERROR_INVALID_MESSAGENAME        1217L

//
// MessageId: ERROR_INVALID_MESSAGEDEST
//
// MessageText:
//
//  The format of the specified message destination is invalid.
//
#define ERROR_INVALID_MESSAGEDEST        1218L

//
// MessageId: ERROR_SESSION_CREDENTIAL_CONFLICT
//
// MessageText:
//
//  The credentials supplied conflict with an existing set of credentials.
//
#define ERROR_SESSION_CREDENTIAL_CONFLICT 1219L

//
// MessageId: ERROR_REMOTE_SESSION_LIMIT_EXCEEDED
//
// MessageText:
//
//  An attempt was made to establish a session to a network server, but there
//  are already too many sessions established to that server.
//
#define ERROR_REMOTE_SESSION_LIMIT_EXCEEDED 1220L

//
// MessageId: ERROR_DUP_DOMAINNAME
//
// MessageText:
//
//  The workgroup or domain name is already in use by another computer on the
//  network.
//
#define ERROR_DUP_DOMAINNAME             1221L

//
// MessageId: ERROR_NO_NETWORK
//
// MessageText:
//
//  The network is not present or not started.
//
#define ERROR_NO_NETWORK                 1222L

//
// MessageId: ERROR_CANCELLED
//
// MessageText:
//
//  The operation was cancelled by the user.
//
#define ERROR_CANCELLED                  1223L

//
// MessageId: ERROR_USER_MAPPED_FILE
//
// MessageText:
//
//  The requested operation cannot be performed on a file with a user mapped section open.
//
#define ERROR_USER_MAPPED_FILE           1224L

//
// MessageId: ERROR_CONNECTION_REFUSED
//
// MessageText:
//
//  The remote system refused the network connection.
//
#define ERROR_CONNECTION_REFUSED         1225L

//
// MessageId: ERROR_GRACEFUL_DISCONNECT
//
// MessageText:
//
//  The network connection was gracefully closed.
//
#define ERROR_GRACEFUL_DISCONNECT        1226L

//
// MessageId: ERROR_ADDRESS_ALREADY_ASSOCIATED
//
// MessageText:
//
//  The network transport endpoint already has an address associated with it.
//
#define ERROR_ADDRESS_ALREADY_ASSOCIATED 1227L

//
// MessageId: ERROR_ADDRESS_NOT_ASSOCIATED
//
// MessageText:
//
//  An address has not yet been associated with the network endpoint.
//
#define ERROR_ADDRESS_NOT_ASSOCIATED     1228L

//
// MessageId: ERROR_CONNECTION_INVALID
//
// MessageText:
//
//  An operation was attempted on a non-existent network connection.
//
#define ERROR_CONNECTION_INVALID         1229L

//
// MessageId: ERROR_CONNECTION_ACTIVE
//
// MessageText:
//
//  An invalid operation was attempted on an active network connection.
//
#define ERROR_CONNECTION_ACTIVE          1230L

//
// MessageId: ERROR_NETWORK_UNREACHABLE
//
// MessageText:
//
//  The remote network is not reachable by the transport.
//
#define ERROR_NETWORK_UNREACHABLE        1231L

//
// MessageId: ERROR_HOST_UNREACHABLE
//
// MessageText:
//
//  The remote system is not reachable by the transport.
//
#define ERROR_HOST_UNREACHABLE           1232L

//
// MessageId: ERROR_PROTOCOL_UNREACHABLE
//
// MessageText:
//
//  The remote system does not support the transport protocol.
//
#define ERROR_PROTOCOL_UNREACHABLE       1233L

//
// MessageId: ERROR_PORT_UNREACHABLE
//
// MessageText:
//
//  No service is operating at the destination network endpoint
//  on the remote system.
//
#define ERROR_PORT_UNREACHABLE           1234L

//
// MessageId: ERROR_REQUEST_ABORTED
//
// MessageText:
//
//  The request was aborted.
//
#define ERROR_REQUEST_ABORTED            1235L

//
// MessageId: ERROR_CONNECTION_ABORTED
//
// MessageText:
//
//  The network connection was aborted by the local system.
//
#define ERROR_CONNECTION_ABORTED         1236L

//
// MessageId: ERROR_RETRY
//
// MessageText:
//
//  The operation could not be completed.  A retry should be performed.
//
#define ERROR_RETRY                      1237L

//
// MessageId: ERROR_CONNECTION_COUNT_LIMIT
//
// MessageText:
//
//  A connection to the server could not be made because the limit on the number of
//  concurrent connections for this account has been reached.
//
#define ERROR_CONNECTION_COUNT_LIMIT     1238L

//
// MessageId: ERROR_LOGIN_TIME_RESTRICTION
//
// MessageText:
//
//  Attempting to login during an unauthorized time of day for this account.
//
#define ERROR_LOGIN_TIME_RESTRICTION     1239L

//
// MessageId: ERROR_LOGIN_WKSTA_RESTRICTION
//
// MessageText:
//
//  The account is not authorized to login from this station.
//
#define ERROR_LOGIN_WKSTA_RESTRICTION    1240L

//
// MessageId: ERROR_INCORRECT_ADDRESS
//
// MessageText:
//
//  The network address could not be used for the operation requested.
//
#define ERROR_INCORRECT_ADDRESS          1241L

//
// MessageId: ERROR_ALREADY_REGISTERED
//
// MessageText:
//
//  The service is already registered.
//
#define ERROR_ALREADY_REGISTERED         1242L

//
// MessageId: ERROR_SERVICE_NOT_FOUND
//
// MessageText:
//
//  The specified service does not exist.
//
#define ERROR_SERVICE_NOT_FOUND          1243L

//
// MessageId: ERROR_NOT_AUTHENTICATED
//
// MessageText:
//
//  The operation being requested was not performed because the user
//  has not been authenticated.
//
#define ERROR_NOT_AUTHENTICATED          1244L

//
// MessageId: ERROR_NOT_LOGGED_ON
//
// MessageText:
//
//  The operation being requested was not performed because the user
//  has not logged on to the network.
//  The specified service does not exist.
//
#define ERROR_NOT_LOGGED_ON              1245L

//
// MessageId: ERROR_CONTINUE
//
// MessageText:
//
//  Return that wants caller to continue with work in progress.
//
#define ERROR_CONTINUE                   1246L

//
// MessageId: ERROR_ALREADY_INITIALIZED
//
// MessageText:
//
//  An attempt was made to perform an initialization operation when
//  initialization has already been completed.
//
#define ERROR_ALREADY_INITIALIZED        1247L

//
// MessageId: ERROR_NO_MORE_DEVICES
//
// MessageText:
//
//  No more local devices.
//
#define ERROR_NO_MORE_DEVICES            1248L




///////////////////////////
//                       //
// Security Status Codes //
//                       //
///////////////////////////


//
// MessageId: ERROR_NOT_ALL_ASSIGNED
//
// MessageText:
//
//  Not all privileges referenced are assigned to the caller.
//
#define ERROR_NOT_ALL_ASSIGNED           1300L

//
// MessageId: ERROR_SOME_NOT_MAPPED
//
// MessageText:
//
//  Some mapping between account names and security IDs was not done.
//
#define ERROR_SOME_NOT_MAPPED            1301L

//
// MessageId: ERROR_NO_QUOTAS_FOR_ACCOUNT
//
// MessageText:
//
//  No system quota limits are specifically set for this account.
//
#define ERROR_NO_QUOTAS_FOR_ACCOUNT      1302L

//
// MessageId: ERROR_LOCAL_USER_SESSION_KEY
//
// MessageText:
//
//  No encryption key is available.  A well-known encryption key was returned.
//
#define ERROR_LOCAL_USER_SESSION_KEY     1303L

//
// MessageId: ERROR_NULL_LM_PASSWORD
//
// MessageText:
//
//  The NT password is too complex to be converted to a LAN Manager
//  password.  The LAN Manager password returned is a NULL string.
//
#define ERROR_NULL_LM_PASSWORD           1304L

//
// MessageId: ERROR_UNKNOWN_REVISION
//
// MessageText:
//
//  The revision level is unknown.
//
#define ERROR_UNKNOWN_REVISION           1305L

//
// MessageId: ERROR_REVISION_MISMATCH
//
// MessageText:
//
//  Indicates two revision levels are incompatible.
//
#define ERROR_REVISION_MISMATCH          1306L

//
// MessageId: ERROR_INVALID_OWNER
//
// MessageText:
//
//  This security ID may not be assigned as the owner of this object.
//
#define ERROR_INVALID_OWNER              1307L

//
// MessageId: ERROR_INVALID_PRIMARY_GROUP
//
// MessageText:
//
//  This security ID may not be assigned as the primary group of an object.
//
#define ERROR_INVALID_PRIMARY_GROUP      1308L

//
// MessageId: ERROR_NO_IMPERSONATION_TOKEN
//
// MessageText:
//
//  An attempt has been made to operate on an impersonation token
//  by a thread that is not currently impersonating a client.
//
#define ERROR_NO_IMPERSONATION_TOKEN     1309L

//
// MessageId: ERROR_CANT_DISABLE_MANDATORY
//
// MessageText:
//
//  The group may not be disabled.
//
#define ERROR_CANT_DISABLE_MANDATORY     1310L

//
// MessageId: ERROR_NO_LOGON_SERVERS
//
// MessageText:
//
//  There are currently no logon servers available to service the logon
//  request.
//
#define ERROR_NO_LOGON_SERVERS           1311L

//
// MessageId: ERROR_NO_SUCH_LOGON_SESSION
//
// MessageText:
//
//   A specified logon session does not exist.  It may already have
//   been terminated.
//
#define ERROR_NO_SUCH_LOGON_SESSION      1312L

//
// MessageId: ERROR_NO_SUCH_PRIVILEGE
//
// MessageText:
//
//   A specified privilege does not exist.
//
#define ERROR_NO_SUCH_PRIVILEGE          1313L

//
// MessageId: ERROR_PRIVILEGE_NOT_HELD
//
// MessageText:
//
//   A required privilege is not held by the client.
//
#define ERROR_PRIVILEGE_NOT_HELD         1314L

//
// MessageId: ERROR_INVALID_ACCOUNT_NAME
//
// MessageText:
//
//  The name provided is not a properly formed account name.
//
#define ERROR_INVALID_ACCOUNT_NAME       1315L

//
// MessageId: ERROR_USER_EXISTS
//
// MessageText:
//
//  The specified user already exists.
//
#define ERROR_USER_EXISTS                1316L

//
// MessageId: ERROR_NO_SUCH_USER
//
// MessageText:
//
//  The specified user does not exist.
//
#define ERROR_NO_SUCH_USER               1317L

//
// MessageId: ERROR_GROUP_EXISTS
//
// MessageText:
//
//  The specified group already exists.
//
#define ERROR_GROUP_EXISTS               1318L

//
// MessageId: ERROR_NO_SUCH_GROUP
//
// MessageText:
//
//  The specified group does not exist.
//
#define ERROR_NO_SUCH_GROUP              1319L

//
// MessageId: ERROR_MEMBER_IN_GROUP
//
// MessageText:
//
//  Either the specified user account is already a member of the specified
//  group, or the specified group cannot be deleted because it contains
//  a member.
//
#define ERROR_MEMBER_IN_GROUP            1320L

//
// MessageId: ERROR_MEMBER_NOT_IN_GROUP
//
// MessageText:
//
//  The specified user account is not a member of the specified group account.
//
#define ERROR_MEMBER_NOT_IN_GROUP        1321L

//
// MessageId: ERROR_LAST_ADMIN
//
// MessageText:
//
//  The last remaining administration account cannot be disabled
//  or deleted.
//
#define ERROR_LAST_ADMIN                 1322L

//
// MessageId: ERROR_WRONG_PASSWORD
//
// MessageText:
//
//  Unable to update the password.  The value provided as the current
//  password is incorrect.
//
#define ERROR_WRONG_PASSWORD             1323L

//
// MessageId: ERROR_ILL_FORMED_PASSWORD
//
// MessageText:
//
//  Unable to update the password.  The value provided for the new password
//  contains values that are not allowed in passwords.
//
#define ERROR_ILL_FORMED_PASSWORD        1324L

//
// MessageId: ERROR_PASSWORD_RESTRICTION
//
// MessageText:
//
//  Unable to update the password because a password update rule has been
//  violated.
//
#define ERROR_PASSWORD_RESTRICTION       1325L

//
// MessageId: ERROR_LOGON_FAILURE
//
// MessageText:
//
//  Logon failure: unknown user name or bad password.
//
#define ERROR_LOGON_FAILURE              1326L

//
// MessageId: ERROR_ACCOUNT_RESTRICTION
//
// MessageText:
//
//  Logon failure: user account restriction.
//
#define ERROR_ACCOUNT_RESTRICTION        1327L

//
// MessageId: ERROR_INVALID_LOGON_HOURS
//
// MessageText:
//
//  Logon failure: account logon time restriction violation.
//
#define ERROR_INVALID_LOGON_HOURS        1328L

//
// MessageId: ERROR_INVALID_WORKSTATION
//
// MessageText:
//
//  Logon failure: user not allowed to log on to this computer.
//
#define ERROR_INVALID_WORKSTATION        1329L

//
// MessageId: ERROR_PASSWORD_EXPIRED
//
// MessageText:
//
//  Logon failure: the specified account password has expired.
//
#define ERROR_PASSWORD_EXPIRED           1330L

//
// MessageId: ERROR_ACCOUNT_DISABLED
//
// MessageText:
//
//  Logon failure: account currently disabled.
//
#define ERROR_ACCOUNT_DISABLED           1331L

//
// MessageId: ERROR_NONE_MAPPED
//
// MessageText:
//
//  No mapping between account names and security IDs was done.
//
#define ERROR_NONE_MAPPED                1332L

//
// MessageId: ERROR_TOO_MANY_LUIDS_REQUESTED
//
// MessageText:
//
//  Too many local user identifiers (LUIDs) were requested at one time.
//
#define ERROR_TOO_MANY_LUIDS_REQUESTED   1333L

//
// MessageId: ERROR_LUIDS_EXHAUSTED
//
// MessageText:
//
//  No more local user identifiers (LUIDs) are available.
//
#define ERROR_LUIDS_EXHAUSTED            1334L

//
// MessageId: ERROR_INVALID_SUB_AUTHORITY
//
// MessageText:
//
//  The subauthority part of a security ID is invalid for this particular use.
//
#define ERROR_INVALID_SUB_AUTHORITY      1335L

//
// MessageId: ERROR_INVALID_ACL
//
// MessageText:
//
//  The access control list (ACL) structure is invalid.
//
#define ERROR_INVALID_ACL                1336L

//
// MessageId: ERROR_INVALID_SID
//
// MessageText:
//
//  The security ID structure is invalid.
//
#define ERROR_INVALID_SID                1337L

//
// MessageId: ERROR_INVALID_SECURITY_DESCR
//
// MessageText:
//
//  The security descriptor structure is invalid.
//
#define ERROR_INVALID_SECURITY_DESCR     1338L

//
// MessageId: ERROR_BAD_INHERITANCE_ACL
//
// MessageText:
//
//  The inherited access control list (ACL) or access control entry (ACE)
//  could not be built.
//
#define ERROR_BAD_INHERITANCE_ACL        1340L

//
// MessageId: ERROR_SERVER_DISABLED
//
// MessageText:
//
//  The server is currently disabled.
//
#define ERROR_SERVER_DISABLED            1341L

//
// MessageId: ERROR_SERVER_NOT_DISABLED
//
// MessageText:
//
//  The server is currently enabled.
//
#define ERROR_SERVER_NOT_DISABLED        1342L

//
// MessageId: ERROR_INVALID_ID_AUTHORITY
//
// MessageText:
//
//  The value provided was an invalid value for an identifier authority.
//
#define ERROR_INVALID_ID_AUTHORITY       1343L

//
// MessageId: ERROR_ALLOTTED_SPACE_EXCEEDED
//
// MessageText:
//
//  No more memory is available for security information updates.
//
#define ERROR_ALLOTTED_SPACE_EXCEEDED    1344L

//
// MessageId: ERROR_INVALID_GROUP_ATTRIBUTES
//
// MessageText:
//
//  The specified attributes are invalid, or incompatible with the
//  attributes for the group as a whole.
//
#define ERROR_INVALID_GROUP_ATTRIBUTES   1345L

//
// MessageId: ERROR_BAD_IMPERSONATION_LEVEL
//
// MessageText:
//
//  Either a required impersonation level was not provided, or the
//  provided impersonation level is invalid.
//
#define ERROR_BAD_IMPERSONATION_LEVEL    1346L

//
// MessageId: ERROR_CANT_OPEN_ANONYMOUS
//
// MessageText:
//
//  Cannot open an anonymous level security token.
//
#define ERROR_CANT_OPEN_ANONYMOUS        1347L

//
// MessageId: ERROR_BAD_VALIDATION_CLASS
//
// MessageText:
//
//  The validation information class requested was invalid.
//
#define ERROR_BAD_VALIDATION_CLASS       1348L

//
// MessageId: ERROR_BAD_TOKEN_TYPE
//
// MessageText:
//
//  The type of the token is inappropriate for its attempted use.
//
#define ERROR_BAD_TOKEN_TYPE             1349L

//
// MessageId: ERROR_NO_SECURITY_ON_OBJECT
//
// MessageText:
//
//  Unable to perform a security operation on an object
//  which has no associated security.
//
#define ERROR_NO_SECURITY_ON_OBJECT      1350L

//
// MessageId: ERROR_CANT_ACCESS_DOMAIN_INFO
//
// MessageText:
//
//  Indicates a Windows NT Server could not be contacted or that
//  objects within the domain are protected such that necessary
//  information could not be retrieved.
//
#define ERROR_CANT_ACCESS_DOMAIN_INFO    1351L

//
// MessageId: ERROR_INVALID_SERVER_STATE
//
// MessageText:
//
//  The security account manager (SAM) or local security
//  authority (LSA) server was in the wrong state to perform
//  the security operation.
//
#define ERROR_INVALID_SERVER_STATE       1352L

//
// MessageId: ERROR_INVALID_DOMAIN_STATE
//
// MessageText:
//
//  The domain was in the wrong state to perform the security operation.
//
#define ERROR_INVALID_DOMAIN_STATE       1353L

//
// MessageId: ERROR_INVALID_DOMAIN_ROLE
//
// MessageText:
//
//  This operation is only allowed for the Primary Domain Controller of the domain.
//
#define ERROR_INVALID_DOMAIN_ROLE        1354L

//
// MessageId: ERROR_NO_SUCH_DOMAIN
//
// MessageText:
//
//  The specified domain did not exist.
//
#define ERROR_NO_SUCH_DOMAIN             1355L

//
// MessageId: ERROR_DOMAIN_EXISTS
//
// MessageText:
//
//  The specified domain already exists.
//
#define ERROR_DOMAIN_EXISTS              1356L

//
// MessageId: ERROR_DOMAIN_LIMIT_EXCEEDED
//
// MessageText:
//
//  An attempt was made to exceed the limit on the number of domains per server.
//
#define ERROR_DOMAIN_LIMIT_EXCEEDED      1357L

//
// MessageId: ERROR_INTERNAL_DB_CORRUPTION
//
// MessageText:
//
//  Unable to complete the requested operation because of either a
//  catastrophic media failure or a data structure corruption on the disk.
//
#define ERROR_INTERNAL_DB_CORRUPTION     1358L

//
// MessageId: ERROR_INTERNAL_ERROR
//
// MessageText:
//
//  The security account database contains an internal inconsistency.
//
#define ERROR_INTERNAL_ERROR             1359L

//
// MessageId: ERROR_GENERIC_NOT_MAPPED
//
// MessageText:
//
//  Generic access types were contained in an access mask which should
//  already be mapped to non-generic types.
//
#define ERROR_GENERIC_NOT_MAPPED         1360L

//
// MessageId: ERROR_BAD_DESCRIPTOR_FORMAT
//
// MessageText:
//
//  A security descriptor is not in the right format (absolute or self-relative).
//
#define ERROR_BAD_DESCRIPTOR_FORMAT      1361L

//
// MessageId: ERROR_NOT_LOGON_PROCESS
//
// MessageText:
//
//  The requested action is restricted for use by logon processes
//  only.  The calling process has not registered as a logon process.
//
#define ERROR_NOT_LOGON_PROCESS          1362L

//
// MessageId: ERROR_LOGON_SESSION_EXISTS
//
// MessageText:
//
//  Cannot start a new logon session with an ID that is already in use.
//
#define ERROR_LOGON_SESSION_EXISTS       1363L

//
// MessageId: ERROR_NO_SUCH_PACKAGE
//
// MessageText:
//
//  A specified authentication package is unknown.
//
#define ERROR_NO_SUCH_PACKAGE            1364L

//
// MessageId: ERROR_BAD_LOGON_SESSION_STATE
//
// MessageText:
//
//  The logon session is not in a state that is consistent with the
//  requested operation.
//
#define ERROR_BAD_LOGON_SESSION_STATE    1365L

//
// MessageId: ERROR_LOGON_SESSION_COLLISION
//
// MessageText:
//
//  The logon session ID is already in use.
//
#define ERROR_LOGON_SESSION_COLLISION    1366L

//
// MessageId: ERROR_INVALID_LOGON_TYPE
//
// MessageText:
//
//  A logon request contained an invalid logon type value.
//
#define ERROR_INVALID_LOGON_TYPE         1367L

//
// MessageId: ERROR_CANNOT_IMPERSONATE
//
// MessageText:
//
//  Unable to impersonate via a named pipe until data has been read
//  from that pipe.
//
#define ERROR_CANNOT_IMPERSONATE         1368L

//
// MessageId: ERROR_RXACT_INVALID_STATE
//
// MessageText:
//
//  The transaction state of a Registry subtree is incompatible with the
//  requested operation.
//
#define ERROR_RXACT_INVALID_STATE        1369L

//
// MessageId: ERROR_RXACT_COMMIT_FAILURE
//
// MessageText:
//
//  An internal security database corruption has been encountered.
//
#define ERROR_RXACT_COMMIT_FAILURE       1370L

//
// MessageId: ERROR_SPECIAL_ACCOUNT
//
// MessageText:
//
//  Cannot perform this operation on built-in accounts.
//
#define ERROR_SPECIAL_ACCOUNT            1371L

//
// MessageId: ERROR_SPECIAL_GROUP
//
// MessageText:
//
//  Cannot perform this operation on this built-in special group.
//
#define ERROR_SPECIAL_GROUP              1372L

//
// MessageId: ERROR_SPECIAL_USER
//
// MessageText:
//
//  Cannot perform this operation on this built-in special user.
//
#define ERROR_SPECIAL_USER               1373L

//
// MessageId: ERROR_MEMBERS_PRIMARY_GROUP
//
// MessageText:
//
//  The user cannot be removed from a group because the group
//  is currently the user's primary group.
//
#define ERROR_MEMBERS_PRIMARY_GROUP      1374L

//
// MessageId: ERROR_TOKEN_ALREADY_IN_USE
//
// MessageText:
//
//  The token is already in use as a primary token.
//
#define ERROR_TOKEN_ALREADY_IN_USE       1375L

//
// MessageId: ERROR_NO_SUCH_ALIAS
//
// MessageText:
//
//  The specified local group does not exist.
//
#define ERROR_NO_SUCH_ALIAS              1376L

//
// MessageId: ERROR_MEMBER_NOT_IN_ALIAS
//
// MessageText:
//
//  The specified account name is not a member of the local group.
//
#define ERROR_MEMBER_NOT_IN_ALIAS        1377L

//
// MessageId: ERROR_MEMBER_IN_ALIAS
//
// MessageText:
//
//  The specified account name is already a member of the local group.
//
#define ERROR_MEMBER_IN_ALIAS            1378L

//
// MessageId: ERROR_ALIAS_EXISTS
//
// MessageText:
//
//  The specified local group already exists.
//
#define ERROR_ALIAS_EXISTS               1379L

//
// MessageId: ERROR_LOGON_NOT_GRANTED
//
// MessageText:
//
//  Logon failure: the user has not been granted the requested
//  logon type at this computer.
//
#define ERROR_LOGON_NOT_GRANTED          1380L

//
// MessageId: ERROR_TOO_MANY_SECRETS
//
// MessageText:
//
//  The maximum number of secrets that may be stored in a single system has been
//  exceeded.
//
#define ERROR_TOO_MANY_SECRETS           1381L

//
// MessageId: ERROR_SECRET_TOO_LONG
//
// MessageText:
//
//  The length of a secret exceeds the maximum length allowed.
//
#define ERROR_SECRET_TOO_LONG            1382L

//
// MessageId: ERROR_INTERNAL_DB_ERROR
//
// MessageText:
//
//  The local security authority database contains an internal inconsistency.
//
#define ERROR_INTERNAL_DB_ERROR          1383L

//
// MessageId: ERROR_TOO_MANY_CONTEXT_IDS
//
// MessageText:
//
//  During a logon attempt, the user's security context accumulated too many
//  security IDs.
//
#define ERROR_TOO_MANY_CONTEXT_IDS       1384L

//
// MessageId: ERROR_LOGON_TYPE_NOT_GRANTED
//
// MessageText:
//
//  Logon failure: the user has not been granted the requested logon type
//  at this computer.
//
#define ERROR_LOGON_TYPE_NOT_GRANTED     1385L

//
// MessageId: ERROR_NT_CROSS_ENCRYPTION_REQUIRED
//
// MessageText:
//
//  A cross-encrypted password is necessary to change a user password.
//
#define ERROR_NT_CROSS_ENCRYPTION_REQUIRED 1386L

//
// MessageId: ERROR_NO_SUCH_MEMBER
//
// MessageText:
//
//  A new member could not be added to a local group because the member does
//  not exist.
//
#define ERROR_NO_SUCH_MEMBER             1387L

//
// MessageId: ERROR_INVALID_MEMBER
//
// MessageText:
//
//  A new member could not be added to a local group because the member has the
//  wrong account type.
//
#define ERROR_INVALID_MEMBER             1388L

//
// MessageId: ERROR_TOO_MANY_SIDS
//
// MessageText:
//
//  Too many security IDs have been specified.
//
#define ERROR_TOO_MANY_SIDS              1389L

//
// MessageId: ERROR_LM_CROSS_ENCRYPTION_REQUIRED
//
// MessageText:
//
//  A cross-encrypted password is necessary to change this user password.
//
#define ERROR_LM_CROSS_ENCRYPTION_REQUIRED 1390L

//
// MessageId: ERROR_NO_INHERITANCE
//
// MessageText:
//
//  Indicates an ACL contains no inheritable components
//
#define ERROR_NO_INHERITANCE             1391L

//
// MessageId: ERROR_FILE_CORRUPT
//
// MessageText:
//
//  The file or directory is corrupt and non-readable.
//
#define ERROR_FILE_CORRUPT               1392L

//
// MessageId: ERROR_DISK_CORRUPT
//
// MessageText:
//
//  The disk structure is corrupt and non-readable.
//
#define ERROR_DISK_CORRUPT               1393L

//
// MessageId: ERROR_NO_USER_SESSION_KEY
//
// MessageText:
//
//  There is no user session key for the specified logon session.
//
#define ERROR_NO_USER_SESSION_KEY        1394L

//
// MessageId: ERROR_LICENSE_QUOTA_EXCEEDED
//
// MessageText:
//
//  The service being accessed is licensed for a particular number of connections.
//  No more connections can be made to the service at this time
//  because there are already as many connections as the service can accept.
//
#define ERROR_LICENSE_QUOTA_EXCEEDED     1395L

// End of security error codes



///////////////////////////
//                       //
// WinUser Error Codes   //
//                       //
///////////////////////////


//
// MessageId: ERROR_INVALID_WINDOW_HANDLE
//
// MessageText:
//
//  Invalid window handle.
//
#define ERROR_INVALID_WINDOW_HANDLE      1400L

//
// MessageId: ERROR_INVALID_MENU_HANDLE
//
// MessageText:
//
//  Invalid menu handle.
//
#define ERROR_INVALID_MENU_HANDLE        1401L

//
// MessageId: ERROR_INVALID_CURSOR_HANDLE
//
// MessageText:
//
//  Invalid cursor handle.
//
#define ERROR_INVALID_CURSOR_HANDLE      1402L

//
// MessageId: ERROR_INVALID_ACCEL_HANDLE
//
// MessageText:
//
//  Invalid accelerator table handle.
//
#define ERROR_INVALID_ACCEL_HANDLE       1403L

//
// MessageId: ERROR_INVALID_HOOK_HANDLE
//
// MessageText:
//
//  Invalid hook handle.
//
#define ERROR_INVALID_HOOK_HANDLE        1404L

//
// MessageId: ERROR_INVALID_DWP_HANDLE
//
// MessageText:
//
//  Invalid handle to a multiple-window position structure.
//
#define ERROR_INVALID_DWP_HANDLE         1405L

//
// MessageId: ERROR_TLW_WITH_WSCHILD
//
// MessageText:
//
//  Cannot create a top-level child window.
//
#define ERROR_TLW_WITH_WSCHILD           1406L

//
// MessageId: ERROR_CANNOT_FIND_WND_CLASS
//
// MessageText:
//
//  Cannot find window class.
//
#define ERROR_CANNOT_FIND_WND_CLASS      1407L

//
// MessageId: ERROR_WINDOW_OF_OTHER_THREAD
//
// MessageText:
//
//  Invalid window, belongs to other thread.
//
#define ERROR_WINDOW_OF_OTHER_THREAD     1408L

//
// MessageId: ERROR_HOTKEY_ALREADY_REGISTERED
//
// MessageText:
//
//  Hot key is already registered.
//
#define ERROR_HOTKEY_ALREADY_REGISTERED  1409L

//
// MessageId: ERROR_CLASS_ALREADY_EXISTS
//
// MessageText:
//
//  Class already exists.
//
#define ERROR_CLASS_ALREADY_EXISTS       1410L

//
// MessageId: ERROR_CLASS_DOES_NOT_EXIST
//
// MessageText:
//
//  Class does not exist.
//
#define ERROR_CLASS_DOES_NOT_EXIST       1411L

//
// MessageId: ERROR_CLASS_HAS_WINDOWS
//
// MessageText:
//
//  Class still has open windows.
//
#define ERROR_CLASS_HAS_WINDOWS          1412L

//
// MessageId: ERROR_INVALID_INDEX
//
// MessageText:
//
//  Invalid index.
//
#define ERROR_INVALID_INDEX              1413L

//
// MessageId: ERROR_INVALID_ICON_HANDLE
//
// MessageText:
//
//  Invalid icon handle.
//
#define ERROR_INVALID_ICON_HANDLE        1414L

//
// MessageId: ERROR_PRIVATE_DIALOG_INDEX
//
// MessageText:
//
//  Using private DIALOG window words.
//
#define ERROR_PRIVATE_DIALOG_INDEX       1415L

//
// MessageId: ERROR_LISTBOX_ID_NOT_FOUND
//
// MessageText:
//
//  The listbox identifier was not found.
//
#define ERROR_LISTBOX_ID_NOT_FOUND       1416L

//
// MessageId: ERROR_NO_WILDCARD_CHARACTERS
//
// MessageText:
//
//  No wildcards were found.
//
#define ERROR_NO_WILDCARD_CHARACTERS     1417L

//
// MessageId: ERROR_CLIPBOARD_NOT_OPEN
//
// MessageText:
//
//  Thread does not have a clipboard open.
//
#define ERROR_CLIPBOARD_NOT_OPEN         1418L

//
// MessageId: ERROR_HOTKEY_NOT_REGISTERED
//
// MessageText:
//
//  Hot key is not registered.
//
#define ERROR_HOTKEY_NOT_REGISTERED      1419L

//
// MessageId: ERROR_WINDOW_NOT_DIALOG
//
// MessageText:
//
//  The window is not a valid dialog window.
//
#define ERROR_WINDOW_NOT_DIALOG          1420L

//
// MessageId: ERROR_CONTROL_ID_NOT_FOUND
//
// MessageText:
//
//  Control ID not found.
//
#define ERROR_CONTROL_ID_NOT_FOUND       1421L

//
// MessageId: ERROR_INVALID_COMBOBOX_MESSAGE
//
// MessageText:
//
//  Invalid message for a combo box because it does not have an edit control.
//
#define ERROR_INVALID_COMBOBOX_MESSAGE   1422L

//
// MessageId: ERROR_WINDOW_NOT_COMBOBOX
//
// MessageText:
//
//  The window is not a combo box.
//
#define ERROR_WINDOW_NOT_COMBOBOX        1423L

//
// MessageId: ERROR_INVALID_EDIT_HEIGHT
//
// MessageText:
//
//  Height must be less than 256.
//
#define ERROR_INVALID_EDIT_HEIGHT        1424L

//
// MessageId: ERROR_DC_NOT_FOUND
//
// MessageText:
//
//  Invalid device context (DC) handle.
//
#define ERROR_DC_NOT_FOUND               1425L

//
// MessageId: ERROR_INVALID_HOOK_FILTER
//
// MessageText:
//
//  Invalid hook procedure type.
//
#define ERROR_INVALID_HOOK_FILTER        1426L

//
// MessageId: ERROR_INVALID_FILTER_PROC
//
// MessageText:
//
//  Invalid hook procedure.
//
#define ERROR_INVALID_FILTER_PROC        1427L

//
// MessageId: ERROR_HOOK_NEEDS_HMOD
//
// MessageText:
//
//  Cannot set non-local hook without a module handle.
//
#define ERROR_HOOK_NEEDS_HMOD            1428L

//
// MessageId: ERROR_GLOBAL_ONLY_HOOK
//
// MessageText:
//
//  This hook procedure can only be set globally.
//
#define ERROR_GLOBAL_ONLY_HOOK           1429L

//
// MessageId: ERROR_JOURNAL_HOOK_SET
//
// MessageText:
//
//  The journal hook procedure is already installed.
//
#define ERROR_JOURNAL_HOOK_SET           1430L

//
// MessageId: ERROR_HOOK_NOT_INSTALLED
//
// MessageText:
//
//  The hook procedure is not installed.
//
#define ERROR_HOOK_NOT_INSTALLED         1431L

//
// MessageId: ERROR_INVALID_LB_MESSAGE
//
// MessageText:
//
//  Invalid message for single-selection listbox.
//
#define ERROR_INVALID_LB_MESSAGE         1432L

//
// MessageId: ERROR_SETCOUNT_ON_BAD_LB
//
// MessageText:
//
//  LB_SETCOUNT sent to non-lazy listbox.
//
#define ERROR_SETCOUNT_ON_BAD_LB         1433L

//
// MessageId: ERROR_LB_WITHOUT_TABSTOPS
//
// MessageText:
//
//  This list box does not support tab stops.
//
#define ERROR_LB_WITHOUT_TABSTOPS        1434L

//
// MessageId: ERROR_DESTROY_OBJECT_OF_OTHER_THREAD
//
// MessageText:
//
//  Cannot destroy object created by another thread.
//
#define ERROR_DESTROY_OBJECT_OF_OTHER_THREAD 1435L

//
// MessageId: ERROR_CHILD_WINDOW_MENU
//
// MessageText:
//
//  Child windows cannot have menus.
//
#define ERROR_CHILD_WINDOW_MENU          1436L

//
// MessageId: ERROR_NO_SYSTEM_MENU
//
// MessageText:
//
//  The window does not have a system menu.
//
#define ERROR_NO_SYSTEM_MENU             1437L

//
// MessageId: ERROR_INVALID_MSGBOX_STYLE
//
// MessageText:
//
//  Invalid message box style.
//
#define ERROR_INVALID_MSGBOX_STYLE       1438L

//
// MessageId: ERROR_INVALID_SPI_VALUE
//
// MessageText:
//
//  Invalid system-wide (SPI_*) parameter.
//
#define ERROR_INVALID_SPI_VALUE          1439L

//
// MessageId: ERROR_SCREEN_ALREADY_LOCKED
//
// MessageText:
//
//  Screen already locked.
//
#define ERROR_SCREEN_ALREADY_LOCKED      1440L

//
// MessageId: ERROR_HWNDS_HAVE_DIFF_PARENT
//
// MessageText:
//
//  All handles to windows in a multiple-window position structure must
//  have the same parent.
//
#define ERROR_HWNDS_HAVE_DIFF_PARENT     1441L

//
// MessageId: ERROR_NOT_CHILD_WINDOW
//
// MessageText:
//
//  The window is not a child window.
//
#define ERROR_NOT_CHILD_WINDOW           1442L

//
// MessageId: ERROR_INVALID_GW_COMMAND
//
// MessageText:
//
//  Invalid GW_* command.
//
#define ERROR_INVALID_GW_COMMAND         1443L

//
// MessageId: ERROR_INVALID_THREAD_ID
//
// MessageText:
//
//  Invalid thread identifier.
//
#define ERROR_INVALID_THREAD_ID          1444L

//
// MessageId: ERROR_NON_MDICHILD_WINDOW
//
// MessageText:
//
//  Cannot process a message from a window that is not a multiple document
//  interface (MDI) window.
//
#define ERROR_NON_MDICHILD_WINDOW        1445L

//
// MessageId: ERROR_POPUP_ALREADY_ACTIVE
//
// MessageText:
//
//  Popup menu already active.
//
#define ERROR_POPUP_ALREADY_ACTIVE       1446L

//
// MessageId: ERROR_NO_SCROLLBARS
//
// MessageText:
//
//  The window does not have scroll bars.
//
#define ERROR_NO_SCROLLBARS              1447L

//
// MessageId: ERROR_INVALID_SCROLLBAR_RANGE
//
// MessageText:
//
//  Scroll bar range cannot be greater than 0x7FFF.
//
#define ERROR_INVALID_SCROLLBAR_RANGE    1448L

//
// MessageId: ERROR_INVALID_SHOWWIN_COMMAND
//
// MessageText:
//
//  Cannot show or remove the window in the way specified.
//
#define ERROR_INVALID_SHOWWIN_COMMAND    1449L

//
// MessageId: ERROR_NO_SYSTEM_RESOURCES
//
// MessageText:
//
//  Insufficient system resources exist to complete the requested service.
//
#define ERROR_NO_SYSTEM_RESOURCES        1450L

//
// MessageId: ERROR_NONPAGED_SYSTEM_RESOURCES
//
// MessageText:
//
//  Insufficient system resources exist to complete the requested service.
//
#define ERROR_NONPAGED_SYSTEM_RESOURCES  1451L

//
// MessageId: ERROR_PAGED_SYSTEM_RESOURCES
//
// MessageText:
//
//  Insufficient system resources exist to complete the requested service.
//
#define ERROR_PAGED_SYSTEM_RESOURCES     1452L

//
// MessageId: ERROR_WORKING_SET_QUOTA
//
// MessageText:
//
//  Insufficient quota to complete the requested service.
//
#define ERROR_WORKING_SET_QUOTA          1453L

//
// MessageId: ERROR_PAGEFILE_QUOTA
//
// MessageText:
//
//  Insufficient quota to complete the requested service.
//
#define ERROR_PAGEFILE_QUOTA             1454L

//
// MessageId: ERROR_COMMITMENT_LIMIT
//
// MessageText:
//
//  The paging file is too small for this operation to complete.
//
#define ERROR_COMMITMENT_LIMIT           1455L

//
// MessageId: ERROR_MENU_ITEM_NOT_FOUND
//
// MessageText:
//
//  A menu item was not found.
//
#define ERROR_MENU_ITEM_NOT_FOUND        1456L

//
// MessageId: ERROR_INVALID_KEYBOARD_HANDLE
//
// MessageText:
//
//  Invalid keyboard layout handle.
//
#define ERROR_INVALID_KEYBOARD_HANDLE    1457L

//
// MessageId: ERROR_HOOK_TYPE_NOT_ALLOWED
//
// MessageText:
//
//  Hook type not allowed.
//
#define ERROR_HOOK_TYPE_NOT_ALLOWED      1458L

//
// MessageId: ERROR_REQUIRES_INTERACTIVE_WINDOWSTATION
//
// MessageText:
//
//  This operation requires an interactive windowstation.
//
#define ERROR_REQUIRES_INTERACTIVE_WINDOWSTATION 1459L

//
// MessageId: ERROR_TIMEOUT
//
// MessageText:
//
//  This operation returned because the timeout period expired.
//
#define ERROR_TIMEOUT                    1460L

// End of WinUser error codes



///////////////////////////
//                       //
// Eventlog Status Codes //
//                       //
///////////////////////////


//
// MessageId: ERROR_EVENTLOG_FILE_CORRUPT
//
// MessageText:
//
//  The event log file is corrupt.
//
#define ERROR_EVENTLOG_FILE_CORRUPT      1500L

//
// MessageId: ERROR_EVENTLOG_CANT_START
//
// MessageText:
//
//  No event log file could be opened, so the event logging service did not start.
//
#define ERROR_EVENTLOG_CANT_START        1501L

//
// MessageId: ERROR_LOG_FILE_FULL
//
// MessageText:
//
//  The event log file is full.
//
#define ERROR_LOG_FILE_FULL              1502L

//
// MessageId: ERROR_EVENTLOG_FILE_CHANGED
//
// MessageText:
//
//  The event log file has changed between reads.
//
#define ERROR_EVENTLOG_FILE_CHANGED      1503L

// End of eventlog error codes



///////////////////////////
//                       //
//   RPC Status Codes    //
//                       //
///////////////////////////


//
// MessageId: RPC_S_INVALID_STRING_BINDING
//
// MessageText:
//
//  The string binding is invalid.
//
#define RPC_S_INVALID_STRING_BINDING     1700L

//
// MessageId: RPC_S_WRONG_KIND_OF_BINDING
//
// MessageText:
//
//  The binding handle is not the correct type.
//
#define RPC_S_WRONG_KIND_OF_BINDING      1701L

//
// MessageId: RPC_S_INVALID_BINDING
//
// MessageText:
//
//  The binding handle is invalid.
//
#define RPC_S_INVALID_BINDING            1702L

//
// MessageId: RPC_S_PROTSEQ_NOT_SUPPORTED
//
// MessageText:
//
//  The RPC protocol sequence is not supported.
//
#define RPC_S_PROTSEQ_NOT_SUPPORTED      1703L

//
// MessageId: RPC_S_INVALID_RPC_PROTSEQ
//
// MessageText:
//
//  The RPC protocol sequence is invalid.
//
#define RPC_S_INVALID_RPC_PROTSEQ        1704L

//
// MessageId: RPC_S_INVALID_STRING_UUID
//
// MessageText:
//
//  The string universal unique identifier (UUID) is invalid.
//
#define RPC_S_INVALID_STRING_UUID        1705L

//
// MessageId: RPC_S_INVALID_ENDPOINT_FORMAT
//
// MessageText:
//
//  The endpoint format is invalid.
//
#define RPC_S_INVALID_ENDPOINT_FORMAT    1706L

//
// MessageId: RPC_S_INVALID_NET_ADDR
//
// MessageText:
//
//  The network address is invalid.
//
#define RPC_S_INVALID_NET_ADDR           1707L

//
// MessageId: RPC_S_NO_ENDPOINT_FOUND
//
// MessageText:
//
//  No endpoint was found.
//
#define RPC_S_NO_ENDPOINT_FOUND          1708L

//
// MessageId: RPC_S_INVALID_TIMEOUT
//
// MessageText:
//
//  The timeout value is invalid.
//
#define RPC_S_INVALID_TIMEOUT            1709L

//
// MessageId: RPC_S_OBJECT_NOT_FOUND
//
// MessageText:
//
//  The object universal unique identifier (UUID) was not found.
//
#define RPC_S_OBJECT_NOT_FOUND           1710L

//
// MessageId: RPC_S_ALREADY_REGISTERED
//
// MessageText:
//
//  The object universal unique identifier (UUID) has already been registered.
//
#define RPC_S_ALREADY_REGISTERED         1711L

//
// MessageId: RPC_S_TYPE_ALREADY_REGISTERED
//
// MessageText:
//
//  The type universal unique identifier (UUID) has already been registered.
//
#define RPC_S_TYPE_ALREADY_REGISTERED    1712L

//
// MessageId: RPC_S_ALREADY_LISTENING
//
// MessageText:
//
//  The RPC server is already listening.
//
#define RPC_S_ALREADY_LISTENING          1713L

//
// MessageId: RPC_S_NO_PROTSEQS_REGISTERED
//
// MessageText:
//
//  No protocol sequences have been registered.
//
#define RPC_S_NO_PROTSEQS_REGISTERED     1714L

//
// MessageId: RPC_S_NOT_LISTENING
//
// MessageText:
//
//  The RPC server is not listening.
//
#define RPC_S_NOT_LISTENING              1715L

//
// MessageId: RPC_S_UNKNOWN_MGR_TYPE
//
// MessageText:
//
//  The manager type is unknown.
//
#define RPC_S_UNKNOWN_MGR_TYPE           1716L

//
// MessageId: RPC_S_UNKNOWN_IF
//
// MessageText:
//
//  The interface is unknown.
//
#define RPC_S_UNKNOWN_IF                 1717L

//
// MessageId: RPC_S_NO_BINDINGS
//
// MessageText:
//
//  There are no bindings.
//
#define RPC_S_NO_BINDINGS                1718L

//
// MessageId: RPC_S_NO_PROTSEQS
//
// MessageText:
//
//  There are no protocol sequences.
//
#define RPC_S_NO_PROTSEQS                1719L

//
// MessageId: RPC_S_CANT_CREATE_ENDPOINT
//
// MessageText:
//
//  The endpoint cannot be created.
//
#define RPC_S_CANT_CREATE_ENDPOINT       1720L

//
// MessageId: RPC_S_OUT_OF_RESOURCES
//
// MessageText:
//
//  Not enough resources are available to complete this operation.
//
#define RPC_S_OUT_OF_RESOURCES           1721L

//
// MessageId: RPC_S_SERVER_UNAVAILABLE
//
// MessageText:
//
//  The RPC server is unavailable.
//
#define RPC_S_SERVER_UNAVAILABLE         1722L

//
// MessageId: RPC_S_SERVER_TOO_BUSY
//
// MessageText:
//
//  The RPC server is too busy to complete this operation.
//
#define RPC_S_SERVER_TOO_BUSY            1723L

//
// MessageId: RPC_S_INVALID_NETWORK_OPTIONS
//
// MessageText:
//
//  The network options are invalid.
//
#define RPC_S_INVALID_NETWORK_OPTIONS    1724L

//
// MessageId: RPC_S_NO_CALL_ACTIVE
//
// MessageText:
//
//  There is not a remote procedure call active in this thread.
//
#define RPC_S_NO_CALL_ACTIVE             1725L

//
// MessageId: RPC_S_CALL_FAILED
//
// MessageText:
//
//  The remote procedure call failed.
//
#define RPC_S_CALL_FAILED                1726L

//
// MessageId: RPC_S_CALL_FAILED_DNE
//
// MessageText:
//
//  The remote procedure call failed and did not execute.
//
#define RPC_S_CALL_FAILED_DNE            1727L

//
// MessageId: RPC_S_PROTOCOL_ERROR
//
// MessageText:
//
//  A remote procedure call (RPC) protocol error occurred.
//
#define RPC_S_PROTOCOL_ERROR             1728L

//
// MessageId: RPC_S_UNSUPPORTED_TRANS_SYN
//
// MessageText:
//
//  The transfer syntax is not supported by the RPC server.
//
#define RPC_S_UNSUPPORTED_TRANS_SYN      1730L

//
// MessageId: RPC_S_UNSUPPORTED_TYPE
//
// MessageText:
//
//  The universal unique identifier (UUID) type is not supported.
//
#define RPC_S_UNSUPPORTED_TYPE           1732L

//
// MessageId: RPC_S_INVALID_TAG
//
// MessageText:
//
//  The tag is invalid.
//
#define RPC_S_INVALID_TAG                1733L

//
// MessageId: RPC_S_INVALID_BOUND
//
// MessageText:
//
//  The array bounds are invalid.
//
#define RPC_S_INVALID_BOUND              1734L

//
// MessageId: RPC_S_NO_ENTRY_NAME
//
// MessageText:
//
//  The binding does not contain an entry name.
//
#define RPC_S_NO_ENTRY_NAME              1735L

//
// MessageId: RPC_S_INVALID_NAME_SYNTAX
//
// MessageText:
//
//  The name syntax is invalid.
//
#define RPC_S_INVALID_NAME_SYNTAX        1736L

//
// MessageId: RPC_S_UNSUPPORTED_NAME_SYNTAX
//
// MessageText:
//
//  The name syntax is not supported.
//
#define RPC_S_UNSUPPORTED_NAME_SYNTAX    1737L

//
// MessageId: RPC_S_UUID_NO_ADDRESS
//
// MessageText:
//
//  No network address is available to use to construct a universal
//  unique identifier (UUID).
//
#define RPC_S_UUID_NO_ADDRESS            1739L

//
// MessageId: RPC_S_DUPLICATE_ENDPOINT
//
// MessageText:
//
//  The endpoint is a duplicate.
//
#define RPC_S_DUPLICATE_ENDPOINT         1740L

//
// MessageId: RPC_S_UNKNOWN_AUTHN_TYPE
//
// MessageText:
//
//  The authentication type is unknown.
//
#define RPC_S_UNKNOWN_AUTHN_TYPE         1741L

//
// MessageId: RPC_S_MAX_CALLS_TOO_SMALL
//
// MessageText:
//
//  The maximum number of calls is too small.
//
#define RPC_S_MAX_CALLS_TOO_SMALL        1742L

//
// MessageId: RPC_S_STRING_TOO_LONG
//
// MessageText:
//
//  The string is too long.
//
#define RPC_S_STRING_TOO_LONG            1743L

//
// MessageId: RPC_S_PROTSEQ_NOT_FOUND
//
// MessageText:
//
//  The RPC protocol sequence was not found.
//
#define RPC_S_PROTSEQ_NOT_FOUND          1744L

//
// MessageId: RPC_S_PROCNUM_OUT_OF_RANGE
//
// MessageText:
//
//  The procedure number is out of range.
//
#define RPC_S_PROCNUM_OUT_OF_RANGE       1745L

//
// MessageId: RPC_S_BINDING_HAS_NO_AUTH
//
// MessageText:
//
//  The binding does not contain any authentication information.
//
#define RPC_S_BINDING_HAS_NO_AUTH        1746L

//
// MessageId: RPC_S_UNKNOWN_AUTHN_SERVICE
//
// MessageText:
//
//  The authentication service is unknown.
//
#define RPC_S_UNKNOWN_AUTHN_SERVICE      1747L

//
// MessageId: RPC_S_UNKNOWN_AUTHN_LEVEL
//
// MessageText:
//
//  The authentication level is unknown.
//
#define RPC_S_UNKNOWN_AUTHN_LEVEL        1748L

//
// MessageId: RPC_S_INVALID_AUTH_IDENTITY
//
// MessageText:
//
//  The security context is invalid.
//
#define RPC_S_INVALID_AUTH_IDENTITY      1749L

//
// MessageId: RPC_S_UNKNOWN_AUTHZ_SERVICE
//
// MessageText:
//
//  The authorization service is unknown.
//
#define RPC_S_UNKNOWN_AUTHZ_SERVICE      1750L

//
// MessageId: EPT_S_INVALID_ENTRY
//
// MessageText:
//
//  The entry is invalid.
//
#define EPT_S_INVALID_ENTRY              1751L

//
// MessageId: EPT_S_CANT_PERFORM_OP
//
// MessageText:
//
//  The server endpoint cannot perform the operation.
//
#define EPT_S_CANT_PERFORM_OP            1752L

//
// MessageId: EPT_S_NOT_REGISTERED
//
// MessageText:
//
//  There are no more endpoints available from the endpoint mapper.
//
#define EPT_S_NOT_REGISTERED             1753L

//
// MessageId: RPC_S_NOTHING_TO_EXPORT
//
// MessageText:
//
//  No interfaces have been exported.
//
#define RPC_S_NOTHING_TO_EXPORT          1754L

//
// MessageId: RPC_S_INCOMPLETE_NAME
//
// MessageText:
//
//  The entry name is incomplete.
//
#define RPC_S_INCOMPLETE_NAME            1755L

//
// MessageId: RPC_S_INVALID_VERS_OPTION
//
// MessageText:
//
//  The version option is invalid.
//
#define RPC_S_INVALID_VERS_OPTION        1756L

//
// MessageId: RPC_S_NO_MORE_MEMBERS
//
// MessageText:
//
//  There are no more members.
//
#define RPC_S_NO_MORE_MEMBERS            1757L

//
// MessageId: RPC_S_NOT_ALL_OBJS_UNEXPORTED
//
// MessageText:
//
//  There is nothing to unexport.
//
#define RPC_S_NOT_ALL_OBJS_UNEXPORTED    1758L

//
// MessageId: RPC_S_INTERFACE_NOT_FOUND
//
// MessageText:
//
//  The interface was not found.
//
#define RPC_S_INTERFACE_NOT_FOUND        1759L

//
// MessageId: RPC_S_ENTRY_ALREADY_EXISTS
//
// MessageText:
//
//  The entry already exists.
//
#define RPC_S_ENTRY_ALREADY_EXISTS       1760L

//
// MessageId: RPC_S_ENTRY_NOT_FOUND
//
// MessageText:
//
//  The entry is not found.
//
#define RPC_S_ENTRY_NOT_FOUND            1761L

//
// MessageId: RPC_S_NAME_SERVICE_UNAVAILABLE
//
// MessageText:
//
//  The name service is unavailable.
//
#define RPC_S_NAME_SERVICE_UNAVAILABLE   1762L

//
// MessageId: RPC_S_INVALID_NAF_ID
//
// MessageText:
//
//  The network address family is invalid.
//
#define RPC_S_INVALID_NAF_ID             1763L

//
// MessageId: RPC_S_CANNOT_SUPPORT
//
// MessageText:
//
//  The requested operation is not supported.
//
#define RPC_S_CANNOT_SUPPORT             1764L

//
// MessageId: RPC_S_NO_CONTEXT_AVAILABLE
//
// MessageText:
//
//  No security context is available to allow impersonation.
//
#define RPC_S_NO_CONTEXT_AVAILABLE       1765L

//
// MessageId: RPC_S_INTERNAL_ERROR
//
// MessageText:
//
//  An internal error occurred in a remote procedure call (RPC).
//
#define RPC_S_INTERNAL_ERROR             1766L

//
// MessageId: RPC_S_ZERO_DIVIDE
//
// MessageText:
//
//  The RPC server attempted an integer division by zero.
//
#define RPC_S_ZERO_DIVIDE                1767L

//
// MessageId: RPC_S_ADDRESS_ERROR
//
// MessageText:
//
//  An addressing error occurred in the RPC server.
//
#define RPC_S_ADDRESS_ERROR              1768L

//
// MessageId: RPC_S_FP_DIV_ZERO
//
// MessageText:
//
//  A floating-point operation at the RPC server caused a division by zero.
//
#define RPC_S_FP_DIV_ZERO                1769L

//
// MessageId: RPC_S_FP_UNDERFLOW
//
// MessageText:
//
//  A floating-point underflow occurred at the RPC server.
//
#define RPC_S_FP_UNDERFLOW               1770L

//
// MessageId: RPC_S_FP_OVERFLOW
//
// MessageText:
//
//  A floating-point overflow occurred at the RPC server.
//
#define RPC_S_FP_OVERFLOW                1771L

//
// MessageId: RPC_X_NO_MORE_ENTRIES
//
// MessageText:
//
//  The list of RPC servers available for the binding of auto handles
//  has been exhausted.
//
#define RPC_X_NO_MORE_ENTRIES            1772L

//
// MessageId: RPC_X_SS_CHAR_TRANS_OPEN_FAIL
//
// MessageText:
//
//  Unable to open the character translation table file.
//
#define RPC_X_SS_CHAR_TRANS_OPEN_FAIL    1773L

//
// MessageId: RPC_X_SS_CHAR_TRANS_SHORT_FILE
//
// MessageText:
//
//  The file containing the character translation table has fewer than
//  512 bytes.
//
#define RPC_X_SS_CHAR_TRANS_SHORT_FILE   1774L

//
// MessageId: RPC_X_SS_IN_NULL_CONTEXT
//
// MessageText:
//
//  A null context handle was passed from the client to the host during
//  a remote procedure call.
//
#define RPC_X_SS_IN_NULL_CONTEXT         1775L

//
// MessageId: RPC_X_SS_CONTEXT_DAMAGED
//
// MessageText:
//
//  The context handle changed during a remote procedure call.
//
#define RPC_X_SS_CONTEXT_DAMAGED         1777L

//
// MessageId: RPC_X_SS_HANDLES_MISMATCH
//
// MessageText:
//
//  The binding handles passed to a remote procedure call do not match.
//
#define RPC_X_SS_HANDLES_MISMATCH        1778L

//
// MessageId: RPC_X_SS_CANNOT_GET_CALL_HANDLE
//
// MessageText:
//
//  The stub is unable to get the remote procedure call handle.
//
#define RPC_X_SS_CANNOT_GET_CALL_HANDLE  1779L

//
// MessageId: RPC_X_NULL_REF_POINTER
//
// MessageText:
//
//  A null reference pointer was passed to the stub.
//
#define RPC_X_NULL_REF_POINTER           1780L

//
// MessageId: RPC_X_ENUM_VALUE_OUT_OF_RANGE
//
// MessageText:
//
//  The enumeration value is out of range.
//
#define RPC_X_ENUM_VALUE_OUT_OF_RANGE    1781L

//
// MessageId: RPC_X_BYTE_COUNT_TOO_SMALL
//
// MessageText:
//
//  The byte count is too small.
//
#define RPC_X_BYTE_COUNT_TOO_SMALL       1782L

//
// MessageId: RPC_X_BAD_STUB_DATA
//
// MessageText:
//
//  The stub received bad data.
//
#define RPC_X_BAD_STUB_DATA              1783L

//
// MessageId: ERROR_INVALID_USER_BUFFER
//
// MessageText:
//
//  The supplied user buffer is not valid for the requested operation.
//
#define ERROR_INVALID_USER_BUFFER        1784L

//
// MessageId: ERROR_UNRECOGNIZED_MEDIA
//
// MessageText:
//
//  The disk media is not recognized.  It may not be formatted.
//
#define ERROR_UNRECOGNIZED_MEDIA         1785L

//
// MessageId: ERROR_NO_TRUST_LSA_SECRET
//
// MessageText:
//
//  The workstation does not have a trust secret.
//
#define ERROR_NO_TRUST_LSA_SECRET        1786L

//
// MessageId: ERROR_NO_TRUST_SAM_ACCOUNT
//
// MessageText:
//
//  The SAM database on the Windows NT Server does not have a computer
//  account for this workstation trust relationship.
//
#define ERROR_NO_TRUST_SAM_ACCOUNT       1787L

//
// MessageId: ERROR_TRUSTED_DOMAIN_FAILURE
//
// MessageText:
//
//  The trust relationship between the primary domain and the trusted
//  domain failed.
//
#define ERROR_TRUSTED_DOMAIN_FAILURE     1788L

//
// MessageId: ERROR_TRUSTED_RELATIONSHIP_FAILURE
//
// MessageText:
//
//  The trust relationship between this workstation and the primary
//  domain failed.
//
#define ERROR_TRUSTED_RELATIONSHIP_FAILURE 1789L

//
// MessageId: ERROR_TRUST_FAILURE
//
// MessageText:
//
//  The network logon failed.
//
#define ERROR_TRUST_FAILURE              1790L

//
// MessageId: RPC_S_CALL_IN_PROGRESS
//
// MessageText:
//
//  A remote procedure call is already in progress for this thread.
//
#define RPC_S_CALL_IN_PROGRESS           1791L

//
// MessageId: ERROR_NETLOGON_NOT_STARTED
//
// MessageText:
//
//  An attempt was made to logon, but the network logon service was not started.
//
#define ERROR_NETLOGON_NOT_STARTED       1792L

//
// MessageId: ERROR_ACCOUNT_EXPIRED
//
// MessageText:
//
//  The user's account has expired.
//
#define ERROR_ACCOUNT_EXPIRED            1793L

//
// MessageId: ERROR_REDIRECTOR_HAS_OPEN_HANDLES
//
// MessageText:
//
//  The redirector is in use and cannot be unloaded.
//
#define ERROR_REDIRECTOR_HAS_OPEN_HANDLES 1794L

//
// MessageId: ERROR_PRINTER_DRIVER_ALREADY_INSTALLED
//
// MessageText:
//
//  The specified printer driver is already installed.
//
#define ERROR_PRINTER_DRIVER_ALREADY_INSTALLED 1795L

//
// MessageId: ERROR_UNKNOWN_PORT
//
// MessageText:
//
//  The specified port is unknown.
//
#define ERROR_UNKNOWN_PORT               1796L

//
// MessageId: ERROR_UNKNOWN_PRINTER_DRIVER
//
// MessageText:
//
//  The printer driver is unknown.
//
#define ERROR_UNKNOWN_PRINTER_DRIVER     1797L

//
// MessageId: ERROR_UNKNOWN_PRINTPROCESSOR
//
// MessageText:
//
//  The print processor is unknown.
//
#define ERROR_UNKNOWN_PRINTPROCESSOR     1798L

//
// MessageId: ERROR_INVALID_SEPARATOR_FILE
//
// MessageText:
//
//  The specified separator file is invalid.
//
#define ERROR_INVALID_SEPARATOR_FILE     1799L

//
// MessageId: ERROR_INVALID_PRIORITY
//
// MessageText:
//
//  The specified priority is invalid.
//
#define ERROR_INVALID_PRIORITY           1800L

//
// MessageId: ERROR_INVALID_PRINTER_NAME
//
// MessageText:
//
//  The printer name is invalid.
//
#define ERROR_INVALID_PRINTER_NAME       1801L

//
// MessageId: ERROR_PRINTER_ALREADY_EXISTS
//
// MessageText:
//
//  The printer already exists.
//
#define ERROR_PRINTER_ALREADY_EXISTS     1802L

//
// MessageId: ERROR_INVALID_PRINTER_COMMAND
//
// MessageText:
//
//  The printer command is invalid.
//
#define ERROR_INVALID_PRINTER_COMMAND    1803L

//
// MessageId: ERROR_INVALID_DATATYPE
//
// MessageText:
//
//  The specified datatype is invalid.
//
#define ERROR_INVALID_DATATYPE           1804L

//
// MessageId: ERROR_INVALID_ENVIRONMENT
//
// MessageText:
//
//  The Environment specified is invalid.
//
#define ERROR_INVALID_ENVIRONMENT        1805L

//
// MessageId: RPC_S_NO_MORE_BINDINGS
//
// MessageText:
//
//  There are no more bindings.
//
#define RPC_S_NO_MORE_BINDINGS           1806L

//
// MessageId: ERROR_NOLOGON_INTERDOMAIN_TRUST_ACCOUNT
//
// MessageText:
//
//  The account used is an interdomain trust account.  Use your global user account or local user account to access this server.
//
#define ERROR_NOLOGON_INTERDOMAIN_TRUST_ACCOUNT 1807L

//
// MessageId: ERROR_NOLOGON_WORKSTATION_TRUST_ACCOUNT
//
// MessageText:
//
//  The account used is a Computer Account.  Use your global user account or local user account to access this server.
//
#define ERROR_NOLOGON_WORKSTATION_TRUST_ACCOUNT 1808L

//
// MessageId: ERROR_NOLOGON_SERVER_TRUST_ACCOUNT
//
// MessageText:
//
//  The account used is an server trust account.  Use your global user account or local user account to access this server.
//
#define ERROR_NOLOGON_SERVER_TRUST_ACCOUNT 1809L

//
// MessageId: ERROR_DOMAIN_TRUST_INCONSISTENT
//
// MessageText:
//
//  The name or security ID (SID) of the domain specified is inconsistent
//  with the trust information for that domain.
//
#define ERROR_DOMAIN_TRUST_INCONSISTENT  1810L

//
// MessageId: ERROR_SERVER_HAS_OPEN_HANDLES
//
// MessageText:
//
//  The server is in use and cannot be unloaded.
//
#define ERROR_SERVER_HAS_OPEN_HANDLES    1811L

//
// MessageId: ERROR_RESOURCE_DATA_NOT_FOUND
//
// MessageText:
//
//  The specified image file did not contain a resource section.
//
#define ERROR_RESOURCE_DATA_NOT_FOUND    1812L

//
// MessageId: ERROR_RESOURCE_TYPE_NOT_FOUND
//
// MessageText:
//
//  The specified resource type can not be found in the image file.
//
#define ERROR_RESOURCE_TYPE_NOT_FOUND    1813L

//
// MessageId: ERROR_RESOURCE_NAME_NOT_FOUND
//
// MessageText:
//
//  The specified resource name can not be found in the image file.
//
#define ERROR_RESOURCE_NAME_NOT_FOUND    1814L

//
// MessageId: ERROR_RESOURCE_LANG_NOT_FOUND
//
// MessageText:
//
//  The specified resource language ID cannot be found in the image file.
//
#define ERROR_RESOURCE_LANG_NOT_FOUND    1815L

//
// MessageId: ERROR_NOT_ENOUGH_QUOTA
//
// MessageText:
//
//  Not enough quota is available to process this command.
//
#define ERROR_NOT_ENOUGH_QUOTA           1816L

//
// MessageId: RPC_S_NO_INTERFACES
//
// MessageText:
//
//  No interfaces have been registered.
//
#define RPC_S_NO_INTERFACES              1817L

//
// MessageId: RPC_S_CALL_CANCELLED
//
// MessageText:
//
//  The server was altered while processing this call.
//
#define RPC_S_CALL_CANCELLED             1818L

//
// MessageId: RPC_S_BINDING_INCOMPLETE
//
// MessageText:
//
//  The binding handle does not contain all required information.
//
#define RPC_S_BINDING_INCOMPLETE         1819L

//
// MessageId: RPC_S_COMM_FAILURE
//
// MessageText:
//
//  Communications failure.
//
#define RPC_S_COMM_FAILURE               1820L

//
// MessageId: RPC_S_UNSUPPORTED_AUTHN_LEVEL
//
// MessageText:
//
//  The requested authentication level is not supported.
//
#define RPC_S_UNSUPPORTED_AUTHN_LEVEL    1821L

//
// MessageId: RPC_S_NO_PRINC_NAME
//
// MessageText:
//
//  No principal name registered.
//
#define RPC_S_NO_PRINC_NAME              1822L

//
// MessageId: RPC_S_NOT_RPC_ERROR
//
// MessageText:
//
//  The error specified is not a valid Windows NT RPC error code.
//
#define RPC_S_NOT_RPC_ERROR              1823L

//
// MessageId: RPC_S_UUID_LOCAL_ONLY
//
// MessageText:
//
//  A UUID that is valid only on this computer has been allocated.
//
#define RPC_S_UUID_LOCAL_ONLY            1824L

//
// MessageId: RPC_S_SEC_PKG_ERROR
//
// MessageText:
//
//  A security package specific error occurred.
//
#define RPC_S_SEC_PKG_ERROR              1825L

//
// MessageId: RPC_S_NOT_CANCELLED
//
// MessageText:
//
//  Thread is not cancelled.
//
#define RPC_S_NOT_CANCELLED              1826L

//
// MessageId: RPC_X_INVALID_ES_ACTION
//
// MessageText:
//
//  Invalid operation on the encoding/decoding handle.
//
#define RPC_X_INVALID_ES_ACTION          1827L

//
// MessageId: RPC_X_WRONG_ES_VERSION
//
// MessageText:
//
//  Incompatible version of the serializing package.
//
#define RPC_X_WRONG_ES_VERSION           1828L

//
// MessageId: RPC_X_WRONG_STUB_VERSION
//
// MessageText:
//
//  Incompatible version of the RPC stub.
//
#define RPC_X_WRONG_STUB_VERSION         1829L

//
// MessageId: RPC_X_INVALID_PIPE_OBJECT
//
// MessageText:
//
//  The idl pipe object is invalid or corrupted.
//
#define RPC_X_INVALID_PIPE_OBJECT        1830L

//
// MessageId: RPC_X_INVALID_PIPE_OPERATION
//
// MessageText:
//
//  The operation is invalid for a given idl pipe object.
//
#define RPC_X_INVALID_PIPE_OPERATION     1831L

//
// MessageId: RPC_X_WRONG_PIPE_VERSION
//
// MessageText:
//
//  The idl pipe version is not supported.
//
#define RPC_X_WRONG_PIPE_VERSION         1832L

//
// MessageId: RPC_S_GROUP_MEMBER_NOT_FOUND
//
// MessageText:
//
//  The group member was not found.
//
#define RPC_S_GROUP_MEMBER_NOT_FOUND     1898L

//
// MessageId: EPT_S_CANT_CREATE
//
// MessageText:
//
//  The endpoint mapper database could not be created.
//
#define EPT_S_CANT_CREATE                1899L

//
// MessageId: RPC_S_INVALID_OBJECT
//
// MessageText:
//
//  The object universal unique identifier (UUID) is the nil UUID.
//
#define RPC_S_INVALID_OBJECT             1900L

//
// MessageId: ERROR_INVALID_TIME
//
// MessageText:
//
//  The specified time is invalid.
//
#define ERROR_INVALID_TIME               1901L

//
// MessageId: ERROR_INVALID_FORM_NAME
//
// MessageText:
//
//  The specified Form name is invalid.
//
#define ERROR_INVALID_FORM_NAME          1902L

//
// MessageId: ERROR_INVALID_FORM_SIZE
//
// MessageText:
//
//  The specified Form size is invalid
//
#define ERROR_INVALID_FORM_SIZE          1903L

//
// MessageId: ERROR_ALREADY_WAITING
//
// MessageText:
//
//  The specified Printer handle is already being waited on
//
#define ERROR_ALREADY_WAITING            1904L

//
// MessageId: ERROR_PRINTER_DELETED
//
// MessageText:
//
//  The specified Printer has been deleted
//
#define ERROR_PRINTER_DELETED            1905L

//
// MessageId: ERROR_INVALID_PRINTER_STATE
//
// MessageText:
//
//  The state of the Printer is invalid
//
#define ERROR_INVALID_PRINTER_STATE      1906L

//
// MessageId: ERROR_PASSWORD_MUST_CHANGE
//
// MessageText:
//
//  The user must change his password before he logs on the first time.
//
#define ERROR_PASSWORD_MUST_CHANGE       1907L

//
// MessageId: ERROR_DOMAIN_CONTROLLER_NOT_FOUND
//
// MessageText:
//
//  Could not find the domain controller for this domain.
//
#define ERROR_DOMAIN_CONTROLLER_NOT_FOUND 1908L

//
// MessageId: ERROR_ACCOUNT_LOCKED_OUT
//
// MessageText:
//
//  The referenced account is currently locked out and may not be logged on to.
//
#define ERROR_ACCOUNT_LOCKED_OUT         1909L

//
// MessageId: OR_INVALID_OXID
//
// MessageText:
//
//  The object exporter specified was not found.
//
#define OR_INVALID_OXID                  1910L

//
// MessageId: OR_INVALID_OID
//
// MessageText:
//
//  The object specified was not found.
//
#define OR_INVALID_OID                   1911L

//
// MessageId: OR_INVALID_SET
//
// MessageText:
//
//  The object resolver set specified was not found.
//
#define OR_INVALID_SET                   1912L

//
// MessageId: RPC_S_SEND_INCOMPLETE
//
// MessageText:
//
//  Some data remains to be sent in the request buffer.
//
#define RPC_S_SEND_INCOMPLETE            1913L

//
// MessageId: ERROR_NO_BROWSER_SERVERS_FOUND
//
// MessageText:
//
//  The list of servers for this workgroup is not currently available
//
#define ERROR_NO_BROWSER_SERVERS_FOUND   6118L




///////////////////////////
//                       //
//   OpenGL Error Code   //
//                       //
///////////////////////////


//
// MessageId: ERROR_INVALID_PIXEL_FORMAT
//
// MessageText:
//
//  The pixel format is invalid.
//
#define ERROR_INVALID_PIXEL_FORMAT       2000L

//
// MessageId: ERROR_BAD_DRIVER
//
// MessageText:
//
//  The specified driver is invalid.
//
#define ERROR_BAD_DRIVER                 2001L

//
// MessageId: ERROR_INVALID_WINDOW_STYLE
//
// MessageText:
//
//  The window style or class attribute is invalid for this operation.
//
#define ERROR_INVALID_WINDOW_STYLE       2002L

//
// MessageId: ERROR_METAFILE_NOT_SUPPORTED
//
// MessageText:
//
//  The requested metafile operation is not supported.
//
#define ERROR_METAFILE_NOT_SUPPORTED     2003L

//
// MessageId: ERROR_TRANSFORM_NOT_SUPPORTED
//
// MessageText:
//
//  The requested transformation operation is not supported.
//
#define ERROR_TRANSFORM_NOT_SUPPORTED    2004L

//
// MessageId: ERROR_CLIPPING_NOT_SUPPORTED
//
// MessageText:
//
//  The requested clipping operation is not supported.
//
#define ERROR_CLIPPING_NOT_SUPPORTED     2005L

// End of OpenGL error codes



////////////////////////////////////
//                                //
//     Win32 Spooler Error Codes  //
//                                //
////////////////////////////////////
//
// MessageId: ERROR_UNKNOWN_PRINT_MONITOR
//
// MessageText:
//
//  The specified print monitor is unknown.
//
#define ERROR_UNKNOWN_PRINT_MONITOR      3000L

//
// MessageId: ERROR_PRINTER_DRIVER_IN_USE
//
// MessageText:
//
//  The specified printer driver is currently in use.
//
#define ERROR_PRINTER_DRIVER_IN_USE      3001L

//
// MessageId: ERROR_SPOOL_FILE_NOT_FOUND
//
// MessageText:
//
//  The spool file was not found.
//
#define ERROR_SPOOL_FILE_NOT_FOUND       3002L

//
// MessageId: ERROR_SPL_NO_STARTDOC
//
// MessageText:
//
//  A StartDocPrinter call was not issued.
//
#define ERROR_SPL_NO_STARTDOC            3003L

//
// MessageId: ERROR_SPL_NO_ADDJOB
//
// MessageText:
//
//  An AddJob call was not issued.
//
#define ERROR_SPL_NO_ADDJOB              3004L

//
// MessageId: ERROR_PRINT_PROCESSOR_ALREADY_INSTALLED
//
// MessageText:
//
//  The specified print processor has already been installed.
//
#define ERROR_PRINT_PROCESSOR_ALREADY_INSTALLED 3005L

//
// MessageId: ERROR_PRINT_MONITOR_ALREADY_INSTALLED
//
// MessageText:
//
//  The specified print monitor has already been installed.
//
#define ERROR_PRINT_MONITOR_ALREADY_INSTALLED 3006L

//
// MessageId: ERROR_INVALID_PRINT_MONITOR
//
// MessageText:
//
//  The specified print monitor does not have the required functions.
//
#define ERROR_INVALID_PRINT_MONITOR      3007L

//
// MessageId: ERROR_PRINT_MONITOR_IN_USE
//
// MessageText:
//
//  The specified print monitor is currently in use.
//
#define ERROR_PRINT_MONITOR_IN_USE       3008L

//
// MessageId: ERROR_PRINTER_HAS_JOBS_QUEUED
//
// MessageText:
//
//  The requested operation is not allowed when there are jobs queued to the printer.
//
#define ERROR_PRINTER_HAS_JOBS_QUEUED    3009L

//
// MessageId: ERROR_SUCCESS_REBOOT_REQUIRED
//
// MessageText:
//
//  The requested operation is successful.  Changes will not be effective until the system is rebooted.
//
#define ERROR_SUCCESS_REBOOT_REQUIRED    3010L

//
// MessageId: ERROR_SUCCESS_RESTART_REQUIRED
//
// MessageText:
//
//  The requested operation is successful.  Changes will not be effective until the service is restarted.
//
#define ERROR_SUCCESS_RESTART_REQUIRED   3011L

////////////////////////////////////
//                                //
//     Wins Error Codes           //
//                                //
////////////////////////////////////
//
// MessageId: ERROR_WINS_INTERNAL
//
// MessageText:
//
//  WINS encountered an error while processing the command.
//
#define ERROR_WINS_INTERNAL              4000L

//
// MessageId: ERROR_CAN_NOT_DEL_LOCAL_WINS
//
// MessageText:
//
//  The local WINS can not be deleted.
//
#define ERROR_CAN_NOT_DEL_LOCAL_WINS     4001L

//
// MessageId: ERROR_STATIC_INIT
//
// MessageText:
//
//  The importation from the file failed.
//
#define ERROR_STATIC_INIT                4002L

//
// MessageId: ERROR_INC_BACKUP
//
// MessageText:
//
//  The backup Failed.  Was a full backup done before ?
//
#define ERROR_INC_BACKUP                 4003L

//
// MessageId: ERROR_FULL_BACKUP
//
// MessageText:
//
//  The backup Failed.  Check the directory that you are backing the database to.
//
#define ERROR_FULL_BACKUP                4004L

//
// MessageId: ERROR_REC_NON_EXISTENT
//
// MessageText:
//
//  The name does not exist in the WINS database.
//
#define ERROR_REC_NON_EXISTENT           4005L

//
// MessageId: ERROR_RPL_NOT_ALLOWED
//
// MessageText:
//
//  Replication with a non-configured partner is not allowed.
//
#define ERROR_RPL_NOT_ALLOWED            4006L

////////////////////////////////////
//                                //
//     OLE Error Codes            //
//                                //
////////////////////////////////////

//
// OLE error definitions and values
//
// The return value of OLE APIs and methods is an HRESULT.
// This is not a handle to anything, but is merely a 32-bit value
// with several fields encoded in the value.  The parts of an
// HRESULT are shown below.
//
// Many of the macros and functions below were orginally defined to
// operate on SCODEs.  SCODEs are no longer used.  The macros are
// still present for compatibility and easy porting of Win16 code.
// Newly written code should use the HRESULT macros and functions.
//

//
//  HRESULTs are 32 bit values layed out as follows:
//
//   3 3 2 2 2 2 2 2 2 2 2 2 1 1 1 1 1 1 1 1 1 1
//   1 0 9 8 7 6 5 4 3 2 1 0 9 8 7 6 5 4 3 2 1 0 9 8 7 6 5 4 3 2 1 0
//  +-+-+-+-+-+---------------------+-------------------------------+
//  |S|R|C|N|r|    Facility         |               Code            |
//  +-+-+-+-+-+---------------------+-------------------------------+
//
//  where
//
//      S - Severity - indicates success/fail
//
//          0 - Success
//          1 - Fail (COERROR)
//
//      R - reserved portion of the facility code, corresponds to NT's
//              second severity bit.
//
//      C - reserved portion of the facility code, corresponds to NT's
//              C field.
//
//      N - reserved portion of the facility code. Used to indicate a
//              mapped NT status value.
//
//      r - reserved portion of the facility code. Reserved for internal
//              use. Used to indicate HRESULT values that are not status
//              values, but are instead message ids for display strings.
//
//      Facility - is the facility code
//
//      Code - is the facility's status code
//

//
// Severity values
//

#define SEVERITY_SUCCESS    0
#define SEVERITY_ERROR      1


//
// Generic test for success on any status value (non-negative numbers
// indicate success).
//

#define SUCCEEDED(Status) ((HRESULT)(Status) >= 0)

//
// and the inverse
//

#define FAILED(Status) ((HRESULT)(Status)<0)


//
// Generic test for error on any status value.
//

#define IS_ERROR(Status) ((unsigned long)(Status) >> 31 == SEVERITY_ERROR)

//
// Return the code
//

#define HRESULT_CODE(hr)    ((hr) & 0xFFFF)
#define SCODE_CODE(sc)      ((sc) & 0xFFFF)

//
//  Return the facility
//

#define HRESULT_FACILITY(hr)  (((hr) >> 16) & 0x1fff)
#define SCODE_FACILITY(sc)    (((sc) >> 16) & 0x1fff)

//
//  Return the severity
//

#define HRESULT_SEVERITY(hr)  (((hr) >> 31) & 0x1)
#define SCODE_SEVERITY(sc)    (((sc) >> 31) & 0x1)

//
// Create an HRESULT value from component pieces
//

#define MAKE_HRESULT(sev,fac,code) \
    ((HRESULT) (((unsigned long)(sev)<<31) | ((unsigned long)(fac)<<16) | ((unsigned long)(code))) )
#define MAKE_SCODE(sev,fac,code) \
    ((SCODE) (((unsigned long)(sev)<<31) | ((unsigned long)(fac)<<16) | ((unsigned long)(code))) )


//
// Map a WIN32 error value into a HRESULT
// Note: This assumes that WIN32 errors fall in the range -32k to 32k.
//
// Define bits here so macros are guaranteed to work

#define FACILITY_NT_BIT                 0x10000000
#define HRESULT_FROM_WIN32(x)   (x ? ((HRESULT) (((x) & 0x0000FFFF) | (FACILITY_WIN32 << 16) | 0x80000000)) : 0 )

//
// Map an NT status value into a HRESULT
//

#define HRESULT_FROM_NT(x)      ((HRESULT) ((x) | FACILITY_NT_BIT))


// ****** OBSOLETE functions

// HRESULT functions
// As noted above, these functions are obsolete and should not be used.


// Extract the SCODE from a HRESULT

#define GetScode(hr) ((SCODE) (hr))

// Convert an SCODE into an HRESULT.

#define ResultFromScode(sc) ((HRESULT) (sc))


// PropagateResult is a noop
#define PropagateResult(hrPrevious, scBase) ((HRESULT) scBase)


// ****** End of OBSOLETE functions.


// ---------------------- HRESULT value definitions -----------------
//
// HRESULT definitions
//

#ifdef RC_INVOKED
#define _HRESULT_TYPEDEF_(_sc) _sc
#else // RC_INVOKED
#define _HRESULT_TYPEDEF_(_sc) ((HRESULT)_sc)
#endif // RC_INVOKED

#define NOERROR             0

//
// Error definitions follow
//

//
// Codes 0x4000-0x40ff are reserved for OLE
//
//
// Error codes
//
//
// MessageId: E_UNEXPECTED
//
// MessageText:
//
//  Catastrophic failure
//
#define E_UNEXPECTED                     _HRESULT_TYPEDEF_(0x8000FFFFL)

#if defined(_WIN32) && !defined(_MAC)
//
// MessageId: E_NOTIMPL
//
// MessageText:
//
//  Not implemented
//
#define E_NOTIMPL                        _HRESULT_TYPEDEF_(0x80004001L)

//
// MessageId: E_OUTOFMEMORY
//
// MessageText:
//
//  Ran out of memory
//
#define E_OUTOFMEMORY                    _HRESULT_TYPEDEF_(0x8007000EL)

//
// MessageId: E_INVALIDARG
//
// MessageText:
//
//  One or more arguments are invalid
//
#define E_INVALIDARG                     _HRESULT_TYPEDEF_(0x80070057L)

//
// MessageId: E_NOINTERFACE
//
// MessageText:
//
//  No such interface supported
//
#define E_NOINTERFACE                    _HRESULT_TYPEDEF_(0x80004002L)

//
// MessageId: E_POINTER
//
// MessageText:
//
//  Invalid pointer
//
#define E_POINTER                        _HRESULT_TYPEDEF_(0x80004003L)

//
// MessageId: E_HANDLE
//
// MessageText:
//
//  Invalid handle
//
#define E_HANDLE                         _HRESULT_TYPEDEF_(0x80070006L)

//
// MessageId: E_ABORT
//
// MessageText:
//
//  Operation aborted
//
#define E_ABORT                          _HRESULT_TYPEDEF_(0x80004004L)

//
// MessageId: E_FAIL
//
// MessageText:
//
//  Unspecified error
//
#define E_FAIL                           _HRESULT_TYPEDEF_(0x80004005L)

//
// MessageId: E_ACCESSDENIED
//
// MessageText:
//
//  General access denied error
//
#define E_ACCESSDENIED                   _HRESULT_TYPEDEF_(0x80070005L)

#else
//
// MessageId: E_NOTIMPL
//
// MessageText:
//
//  Not implemented
//
#define E_NOTIMPL                        _HRESULT_TYPEDEF_(0x80000001L)

//
// MessageId: E_OUTOFMEMORY
//
// MessageText:
//
//  Ran out of memory
//
#define E_OUTOFMEMORY                    _HRESULT_TYPEDEF_(0x80000002L)

//
// MessageId: E_INVALIDARG
//
// MessageText:
//
//  One or more arguments are invalid
//
#define E_INVALIDARG                     _HRESULT_TYPEDEF_(0x80000003L)

//
// MessageId: E_NOINTERFACE
//
// MessageText:
//
//  No such interface supported
//
#define E_NOINTERFACE                    _HRESULT_TYPEDEF_(0x80000004L)

//
// MessageId: E_POINTER
//
// MessageText:
//
//  Invalid pointer
//
#define E_POINTER                        _HRESULT_TYPEDEF_(0x80000005L)

//
// MessageId: E_HANDLE
//
// MessageText:
//
//  Invalid handle
//
#define E_HANDLE                         _HRESULT_TYPEDEF_(0x80000006L)

//
// MessageId: E_ABORT
//
// MessageText:
//
//  Operation aborted
//
#define E_ABORT                          _HRESULT_TYPEDEF_(0x80000007L)

//
// MessageId: E_FAIL
//
// MessageText:
//
//  Unspecified error
//
#define E_FAIL                           _HRESULT_TYPEDEF_(0x80000008L)

//
// MessageId: E_ACCESSDENIED
//
// MessageText:
//
//  General access denied error
//
#define E_ACCESSDENIED                   _HRESULT_TYPEDEF_(0x80000009L)

#endif //WIN32
//
// MessageId: E_PENDING
//
// MessageText:
//
//  The data necessary to complete this operation is not yet available.
//
#define E_PENDING                        _HRESULT_TYPEDEF_(0x8000000AL)

//
// MessageId: CO_E_INIT_TLS
//
// MessageText:
//
//  Thread local storage failure
//
#define CO_E_INIT_TLS                    _HRESULT_TYPEDEF_(0x80004006L)

//
// MessageId: CO_E_INIT_SHARED_ALLOCATOR
//
// MessageText:
//
//  Get shared memory allocator failure
//
#define CO_E_INIT_SHARED_ALLOCATOR       _HRESULT_TYPEDEF_(0x80004007L)

//
// MessageId: CO_E_INIT_MEMORY_ALLOCATOR
//
// MessageText:
//
//  Get memory allocator failure
//
#define CO_E_INIT_MEMORY_ALLOCATOR       _HRESULT_TYPEDEF_(0x80004008L)

//
// MessageId: CO_E_INIT_CLASS_CACHE
//
// MessageText:
//
//  Unable to initialize class cache
//
#define CO_E_INIT_CLASS_CACHE            _HRESULT_TYPEDEF_(0x80004009L)

//
// MessageId: CO_E_INIT_RPC_CHANNEL
//
// MessageText:
//
//  Unable to initialize RPC services
//
#define CO_E_INIT_RPC_CHANNEL            _HRESULT_TYPEDEF_(0x8000400AL)

//
// MessageId: CO_E_INIT_TLS_SET_CHANNEL_CONTROL
//
// MessageText:
//
//  Cannot set thread local storage channel control
//
#define CO_E_INIT_TLS_SET_CHANNEL_CONTROL _HRESULT_TYPEDEF_(0x8000400BL)

//
// MessageId: CO_E_INIT_TLS_CHANNEL_CONTROL
//
// MessageText:
//
//  Could not allocate thread local storage channel control
//
#define CO_E_INIT_TLS_CHANNEL_CONTROL    _HRESULT_TYPEDEF_(0x8000400CL)

//
// MessageId: CO_E_INIT_UNACCEPTED_USER_ALLOCATOR
//
// MessageText:
//
//  The user supplied memory allocator is unacceptable
//
#define CO_E_INIT_UNACCEPTED_USER_ALLOCATOR _HRESULT_TYPEDEF_(0x8000400DL)

//
// MessageId: CO_E_INIT_SCM_MUTEX_EXISTS
//
// MessageText:
//
//  The OLE service mutex already exists
//
#define CO_E_INIT_SCM_MUTEX_EXISTS       _HRESULT_TYPEDEF_(0x8000400EL)

//
// MessageId: CO_E_INIT_SCM_FILE_MAPPING_EXISTS
//
// MessageText:
//
//  The OLE service file mapping already exists
//
#define CO_E_INIT_SCM_FILE_MAPPING_EXISTS _HRESULT_TYPEDEF_(0x8000400FL)

//
// MessageId: CO_E_INIT_SCM_MAP_VIEW_OF_FILE
//
// MessageText:
//
//  Unable to map view of file for OLE service
//
#define CO_E_INIT_SCM_MAP_VIEW_OF_FILE   _HRESULT_TYPEDEF_(0x80004010L)

//
// MessageId: CO_E_INIT_SCM_EXEC_FAILURE
//
// MessageText:
//
//  Failure attempting to launch OLE service
//
#define CO_E_INIT_SCM_EXEC_FAILURE       _HRESULT_TYPEDEF_(0x80004011L)

//
// MessageId: CO_E_INIT_ONLY_SINGLE_THREADED
//
// MessageText:
//
//  There was an attempt to call CoInitialize a second time while single threaded
//
#define CO_E_INIT_ONLY_SINGLE_THREADED   _HRESULT_TYPEDEF_(0x80004012L)

//
// MessageId: CO_E_CANT_REMOTE
//
// MessageText:
//
//  A Remote activation was necessary but was not allowed
//
#define CO_E_CANT_REMOTE                 _HRESULT_TYPEDEF_(0x80004013L)

//
// MessageId: CO_E_BAD_SERVER_NAME
//
// MessageText:
//
//  A Remote activation was necessary but the server name provided was invalid
//
#define CO_E_BAD_SERVER_NAME             _HRESULT_TYPEDEF_(0x80004014L)

//
// MessageId: CO_E_WRONG_SERVER_IDENTITY
//
// MessageText:
//
//  The class is configured to run as a security id different from the caller
//
#define CO_E_WRONG_SERVER_IDENTITY       _HRESULT_TYPEDEF_(0x80004015L)

//
// MessageId: CO_E_OLE1DDE_DISABLED
//
// MessageText:
//
//  Use of Ole1 services requiring DDE windows is disabled
//
#define CO_E_OLE1DDE_DISABLED            _HRESULT_TYPEDEF_(0x80004016L)

//
// MessageId: CO_E_RUNAS_SYNTAX
//
// MessageText:
//
//  A RunAs specification must be <domain name>\<user name> or simply <user name>
//
#define CO_E_RUNAS_SYNTAX                _HRESULT_TYPEDEF_(0x80004017L)

//
// MessageId: CO_E_CREATEPROCESS_FAILURE
//
// MessageText:
//
//  The server process could not be started.  The pathname may be incorrect.
//
#define CO_E_CREATEPROCESS_FAILURE       _HRESULT_TYPEDEF_(0x80004018L)

//
// MessageId: CO_E_RUNAS_CREATEPROCESS_FAILURE
//
// MessageText:
//
//  The server process could not be started as the configured identity.  The pathname may be incorrect or unavailable.
//
#define CO_E_RUNAS_CREATEPROCESS_FAILURE _HRESULT_TYPEDEF_(0x80004019L)

//
// MessageId: CO_E_RUNAS_LOGON_FAILURE
//
// MessageText:
//
//  The server process could not be started because the configured identity is incorrect.  Check the username and password.
//
#define CO_E_RUNAS_LOGON_FAILURE         _HRESULT_TYPEDEF_(0x8000401AL)

//
// MessageId: CO_E_LAUNCH_PERMSSION_DENIED
//
// MessageText:
//
//  The client is not allowed to launch this server.
//
#define CO_E_LAUNCH_PERMSSION_DENIED     _HRESULT_TYPEDEF_(0x8000401BL)

//
// MessageId: CO_E_START_SERVICE_FAILURE
//
// MessageText:
//
//  The service providing this server could not be started.
//
#define CO_E_START_SERVICE_FAILURE       _HRESULT_TYPEDEF_(0x8000401CL)

//
// MessageId: CO_E_REMOTE_COMMUNICATION_FAILURE
//
// MessageText:
//
//  This computer was unable to communicate with the computer providing the server.
//
#define CO_E_REMOTE_COMMUNICATION_FAILURE _HRESULT_TYPEDEF_(0x8000401DL)

//
// MessageId: CO_E_SERVER_START_TIMEOUT
//
// MessageText:
//
//  The server did not respond after being launched.
//
#define CO_E_SERVER_START_TIMEOUT        _HRESULT_TYPEDEF_(0x8000401EL)

//
// MessageId: CO_E_CLSREG_INCONSISTENT
//
// MessageText:
//
//  The registration information for this server is inconsistent or incomplete.
//
#define CO_E_CLSREG_INCONSISTENT         _HRESULT_TYPEDEF_(0x8000401FL)

//
// MessageId: CO_E_IIDREG_INCONSISTENT
//
// MessageText:
//
//  The registration information for this interface is inconsistent or incomplete.
//
#define CO_E_IIDREG_INCONSISTENT         _HRESULT_TYPEDEF_(0x80004020L)

//
// MessageId: CO_E_NOT_SUPPORTED
//
// MessageText:
//
//  The operation attempted is not supported.
//
#define CO_E_NOT_SUPPORTED               _HRESULT_TYPEDEF_(0x80004021L)


//
// Success codes
//
#define S_OK                                   ((HRESULT)0x00000000L)
#define S_FALSE                                ((HRESULT)0x00000001L)

// ******************
// FACILITY_ITF
// ******************

//
// Codes 0x0-0x01ff are reserved for the OLE group of
// interfaces.
//


//
// Generic OLE errors that may be returned by many inerfaces
//

#define OLE_E_FIRST ((HRESULT)0x80040000L)
#define OLE_E_LAST  ((HRESULT)0x800400FFL)
#define OLE_S_FIRST ((HRESULT)0x00040000L)
#define OLE_S_LAST  ((HRESULT)0x000400FFL)

//
// Old OLE errors
//
//
// MessageId: OLE_E_OLEVERB
//
// MessageText:
//
//  Invalid OLEVERB structure
//
#define OLE_E_OLEVERB                    _HRESULT_TYPEDEF_(0x80040000L)

//
// MessageId: OLE_E_ADVF
//
// MessageText:
//
//  Invalid advise flags
//
#define OLE_E_ADVF                       _HRESULT_TYPEDEF_(0x80040001L)

//
// MessageId: OLE_E_ENUM_NOMORE
//
// MessageText:
//
//  Can't enumerate any more, because the associated data is missing
//
#define OLE_E_ENUM_NOMORE                _HRESULT_TYPEDEF_(0x80040002L)

//
// MessageId: OLE_E_ADVISENOTSUPPORTED
//
// MessageText:
//
//  This implementation doesn't take advises
//
#define OLE_E_ADVISENOTSUPPORTED         _HRESULT_TYPEDEF_(0x80040003L)

//
// MessageId: OLE_E_NOCONNECTION
//
// MessageText:
//
//  There is no connection for this connection ID
//
#define OLE_E_NOCONNECTION               _HRESULT_TYPEDEF_(0x80040004L)

//
// MessageId: OLE_E_NOTRUNNING
//
// MessageText:
//
//  Need to run the object to perform this operation
//
#define OLE_E_NOTRUNNING                 _HRESULT_TYPEDEF_(0x80040005L)

//
// MessageId: OLE_E_NOCACHE
//
// MessageText:
//
//  There is no cache to operate on
//
#define OLE_E_NOCACHE                    _HRESULT_TYPEDEF_(0x80040006L)

//
// MessageId: OLE_E_BLANK
//
// MessageText:
//
//  Uninitialized object
//
#define OLE_E_BLANK                      _HRESULT_TYPEDEF_(0x80040007L)

//
// MessageId: OLE_E_CLASSDIFF
//
// MessageText:
//
//  Linked object's source class has changed
//
#define OLE_E_CLASSDIFF                  _HRESULT_TYPEDEF_(0x80040008L)

//
// MessageId: OLE_E_CANT_GETMONIKER
//
// MessageText:
//
//  Not able to get the moniker of the object
//
#define OLE_E_CANT_GETMONIKER            _HRESULT_TYPEDEF_(0x80040009L)

//
// MessageId: OLE_E_CANT_BINDTOSOURCE
//
// MessageText:
//
//  Not able to bind to the source
//
#define OLE_E_CANT_BINDTOSOURCE          _HRESULT_TYPEDEF_(0x8004000AL)

//
// MessageId: OLE_E_STATIC
//
// MessageText:
//
//  Object is static; operation not allowed
//
#define OLE_E_STATIC                     _HRESULT_TYPEDEF_(0x8004000BL)

//
// MessageId: OLE_E_PROMPTSAVECANCELLED
//
// MessageText:
//
//  User cancelled out of save dialog
//
#define OLE_E_PROMPTSAVECANCELLED        _HRESULT_TYPEDEF_(0x8004000CL)

//
// MessageId: OLE_E_INVALIDRECT
//
// MessageText:
//
//  Invalid rectangle
//
#define OLE_E_INVALIDRECT                _HRESULT_TYPEDEF_(0x8004000DL)

//
// MessageId: OLE_E_WRONGCOMPOBJ
//
// MessageText:
//
//  compobj.dll is too old for the ole2.dll initialized
//
#define OLE_E_WRONGCOMPOBJ               _HRESULT_TYPEDEF_(0x8004000EL)

//
// MessageId: OLE_E_INVALIDHWND
//
// MessageText:
//
//  Invalid window handle
//
#define OLE_E_INVALIDHWND                _HRESULT_TYPEDEF_(0x8004000FL)

//
// MessageId: OLE_E_NOT_INPLACEACTIVE
//
// MessageText:
//
//  Object is not in any of the inplace active states
//
#define OLE_E_NOT_INPLACEACTIVE          _HRESULT_TYPEDEF_(0x80040010L)

//
// MessageId: OLE_E_CANTCONVERT
//
// MessageText:
//
//  Not able to convert object
//
#define OLE_E_CANTCONVERT                _HRESULT_TYPEDEF_(0x80040011L)

//
// MessageId: OLE_E_NOSTORAGE
//
// MessageText:
//
//  Not able to perform the operation because object is not given storage yet
//  
//
#define OLE_E_NOSTORAGE                  _HRESULT_TYPEDEF_(0x80040012L)

//
// MessageId: DV_E_FORMATETC
//
// MessageText:
//
//  Invalid FORMATETC structure
//
#define DV_E_FORMATETC                   _HRESULT_TYPEDEF_(0x80040064L)

//
// MessageId: DV_E_DVTARGETDEVICE
//
// MessageText:
//
//  Invalid DVTARGETDEVICE structure
//
#define DV_E_DVTARGETDEVICE              _HRESULT_TYPEDEF_(0x80040065L)

//
// MessageId: DV_E_STGMEDIUM
//
// MessageText:
//
//  Invalid STDGMEDIUM structure
//
#define DV_E_STGMEDIUM                   _HRESULT_TYPEDEF_(0x80040066L)

//
// MessageId: DV_E_STATDATA
//
// MessageText:
//
//  Invalid STATDATA structure
//
#define DV_E_STATDATA                    _HRESULT_TYPEDEF_(0x80040067L)

//
// MessageId: DV_E_LINDEX
//
// MessageText:
//
//  Invalid lindex
//
#define DV_E_LINDEX                      _HRESULT_TYPEDEF_(0x80040068L)

//
// MessageId: DV_E_TYMED
//
// MessageText:
//
//  Invalid tymed
//
#define DV_E_TYMED                       _HRESULT_TYPEDEF_(0x80040069L)

//
// MessageId: DV_E_CLIPFORMAT
//
// MessageText:
//
//  Invalid clipboard format
//
#define DV_E_CLIPFORMAT                  _HRESULT_TYPEDEF_(0x8004006AL)

//
// MessageId: DV_E_DVASPECT
//
// MessageText:
//
//  Invalid aspect(s)
//
#define DV_E_DVASPECT                    _HRESULT_TYPEDEF_(0x8004006BL)

//
// MessageId: DV_E_DVTARGETDEVICE_SIZE
//
// MessageText:
//
//  tdSize parameter of the DVTARGETDEVICE structure is invalid
//
#define DV_E_DVTARGETDEVICE_SIZE         _HRESULT_TYPEDEF_(0x8004006CL)

//
// MessageId: DV_E_NOIVIEWOBJECT
//
// MessageText:
//
//  Object doesn't support IViewObject interface
//
#define DV_E_NOIVIEWOBJECT               _HRESULT_TYPEDEF_(0x8004006DL)

#define DRAGDROP_E_FIRST 0x80040100L
#define DRAGDROP_E_LAST  0x8004010FL
#define DRAGDROP_S_FIRST 0x00040100L
#define DRAGDROP_S_LAST  0x0004010FL
//
// MessageId: DRAGDROP_E_NOTREGISTERED
//
// MessageText:
//
//  Trying to revoke a drop target that has not been registered
//
#define DRAGDROP_E_NOTREGISTERED         _HRESULT_TYPEDEF_(0x80040100L)

//
// MessageId: DRAGDROP_E_ALREADYREGISTERED
//
// MessageText:
//
//  This window has already been registered as a drop target
//
#define DRAGDROP_E_ALREADYREGISTERED     _HRESULT_TYPEDEF_(0x80040101L)

//
// MessageId: DRAGDROP_E_INVALIDHWND
//
// MessageText:
//
//  Invalid window handle
//
#define DRAGDROP_E_INVALIDHWND           _HRESULT_TYPEDEF_(0x80040102L)

#define CLASSFACTORY_E_FIRST  0x80040110L
#define CLASSFACTORY_E_LAST   0x8004011FL
#define CLASSFACTORY_S_FIRST  0x00040110L
#define CLASSFACTORY_S_LAST   0x0004011FL
//
// MessageId: CLASS_E_NOAGGREGATION
//
// MessageText:
//
//  Class does not support aggregation (or class object is remote)
//
#define CLASS_E_NOAGGREGATION            _HRESULT_TYPEDEF_(0x80040110L)

//
// MessageId: CLASS_E_CLASSNOTAVAILABLE
//
// MessageText:
//
//  ClassFactory cannot supply requested class
//
#define CLASS_E_CLASSNOTAVAILABLE        _HRESULT_TYPEDEF_(0x80040111L)

#define MARSHAL_E_FIRST  0x80040120L
#define MARSHAL_E_LAST   0x8004012FL
#define MARSHAL_S_FIRST  0x00040120L
#define MARSHAL_S_LAST   0x0004012FL
#define DATA_E_FIRST     0x80040130L
#define DATA_E_LAST      0x8004013FL
#define DATA_S_FIRST     0x00040130L
#define DATA_S_LAST      0x0004013FL
#define VIEW_E_FIRST     0x80040140L
#define VIEW_E_LAST      0x8004014FL
#define VIEW_S_FIRST     0x00040140L
#define VIEW_S_LAST      0x0004014FL
//
// MessageId: VIEW_E_DRAW
//
// MessageText:
//
//  Error drawing view
//
#define VIEW_E_DRAW                      _HRESULT_TYPEDEF_(0x80040140L)

#define REGDB_E_FIRST     0x80040150L
#define REGDB_E_LAST      0x8004015FL
#define REGDB_S_FIRST     0x00040150L
#define REGDB_S_LAST      0x0004015FL
//
// MessageId: REGDB_E_READREGDB
//
// MessageText:
//
//  Could not read key from registry
//
#define REGDB_E_READREGDB                _HRESULT_TYPEDEF_(0x80040150L)

//
// MessageId: REGDB_E_WRITEREGDB
//
// MessageText:
//
//  Could not write key to registry
//
#define REGDB_E_WRITEREGDB               _HRESULT_TYPEDEF_(0x80040151L)

//
// MessageId: REGDB_E_KEYMISSING
//
// MessageText:
//
//  Could not find the key in the registry
//
#define REGDB_E_KEYMISSING               _HRESULT_TYPEDEF_(0x80040152L)

//
// MessageId: REGDB_E_INVALIDVALUE
//
// MessageText:
//
//  Invalid value for registry
//
#define REGDB_E_INVALIDVALUE             _HRESULT_TYPEDEF_(0x80040153L)

//
// MessageId: REGDB_E_CLASSNOTREG
//
// MessageText:
//
//  Class not registered
//
#define REGDB_E_CLASSNOTREG              _HRESULT_TYPEDEF_(0x80040154L)

//
// MessageId: REGDB_E_IIDNOTREG
//
// MessageText:
//
//  Interface not registered
//
#define REGDB_E_IIDNOTREG                _HRESULT_TYPEDEF_(0x80040155L)

#define CACHE_E_FIRST     0x80040170L
#define CACHE_E_LAST      0x8004017FL
#define CACHE_S_FIRST     0x00040170L
#define CACHE_S_LAST      0x0004017FL
//
// MessageId: CACHE_E_NOCACHE_UPDATED
//
// MessageText:
//
//  Cache not updated
//
#define CACHE_E_NOCACHE_UPDATED          _HRESULT_TYPEDEF_(0x80040170L)

#define OLEOBJ_E_FIRST     0x80040180L
#define OLEOBJ_E_LAST      0x8004018FL
#define OLEOBJ_S_FIRST     0x00040180L
#define OLEOBJ_S_LAST      0x0004018FL
//
// MessageId: OLEOBJ_E_NOVERBS
//
// MessageText:
//
//  No verbs for OLE object
//
#define OLEOBJ_E_NOVERBS                 _HRESULT_TYPEDEF_(0x80040180L)

//
// MessageId: OLEOBJ_E_INVALIDVERB
//
// MessageText:
//
//  Invalid verb for OLE object
//
#define OLEOBJ_E_INVALIDVERB             _HRESULT_TYPEDEF_(0x80040181L)

#define CLIENTSITE_E_FIRST     0x80040190L
#define CLIENTSITE_E_LAST      0x8004019FL
#define CLIENTSITE_S_FIRST     0x00040190L
#define CLIENTSITE_S_LAST      0x0004019FL
//
// MessageId: INPLACE_E_NOTUNDOABLE
//
// MessageText:
//
//  Undo is not available
//
#define INPLACE_E_NOTUNDOABLE            _HRESULT_TYPEDEF_(0x800401A0L)

//
// MessageId: INPLACE_E_NOTOOLSPACE
//
// MessageText:
//
//  Space for tools is not available
//
#define INPLACE_E_NOTOOLSPACE            _HRESULT_TYPEDEF_(0x800401A1L)

#define INPLACE_E_FIRST     0x800401A0L
#define INPLACE_E_LAST      0x800401AFL
#define INPLACE_S_FIRST     0x000401A0L
#define INPLACE_S_LAST      0x000401AFL
#define ENUM_E_FIRST        0x800401B0L
#define ENUM_E_LAST         0x800401BFL
#define ENUM_S_FIRST        0x000401B0L
#define ENUM_S_LAST         0x000401BFL
#define CONVERT10_E_FIRST        0x800401C0L
#define CONVERT10_E_LAST         0x800401CFL
#define CONVERT10_S_FIRST        0x000401C0L
#define CONVERT10_S_LAST         0x000401CFL
//
// MessageId: CONVERT10_E_OLESTREAM_GET
//
// MessageText:
//
//  OLESTREAM Get method failed
//
#define CONVERT10_E_OLESTREAM_GET        _HRESULT_TYPEDEF_(0x800401C0L)

//
// MessageId: CONVERT10_E_OLESTREAM_PUT
//
// MessageText:
//
//  OLESTREAM Put method failed
//
#define CONVERT10_E_OLESTREAM_PUT        _HRESULT_TYPEDEF_(0x800401C1L)

//
// MessageId: CONVERT10_E_OLESTREAM_FMT
//
// MessageText:
//
//  Contents of the OLESTREAM not in correct format
//
#define CONVERT10_E_OLESTREAM_FMT        _HRESULT_TYPEDEF_(0x800401C2L)

//
// MessageId: CONVERT10_E_OLESTREAM_BITMAP_TO_DIB
//
// MessageText:
//
//  There was an error in a Windows GDI call while converting the bitmap to a DIB
//
#define CONVERT10_E_OLESTREAM_BITMAP_TO_DIB _HRESULT_TYPEDEF_(0x800401C3L)

//
// MessageId: CONVERT10_E_STG_FMT
//
// MessageText:
//
//  Contents of the IStorage not in correct format
//
#define CONVERT10_E_STG_FMT              _HRESULT_TYPEDEF_(0x800401C4L)

//
// MessageId: CONVERT10_E_STG_NO_STD_STREAM
//
// MessageText:
//
//  Contents of IStorage is missing one of the standard streams
//
#define CONVERT10_E_STG_NO_STD_STREAM    _HRESULT_TYPEDEF_(0x800401C5L)

//
// MessageId: CONVERT10_E_STG_DIB_TO_BITMAP
//
// MessageText:
//
//  There was an error in a Windows GDI call while converting the DIB to a bitmap.
//  
//
#define CONVERT10_E_STG_DIB_TO_BITMAP    _HRESULT_TYPEDEF_(0x800401C6L)

#define CLIPBRD_E_FIRST        0x800401D0L
#define CLIPBRD_E_LAST         0x800401DFL
#define CLIPBRD_S_FIRST        0x000401D0L
#define CLIPBRD_S_LAST         0x000401DFL
//
// MessageId: CLIPBRD_E_CANT_OPEN
//
// MessageText:
//
//  OpenClipboard Failed
//
#define CLIPBRD_E_CANT_OPEN              _HRESULT_TYPEDEF_(0x800401D0L)

//
// MessageId: CLIPBRD_E_CANT_EMPTY
//
// MessageText:
//
//  EmptyClipboard Failed
//
#define CLIPBRD_E_CANT_EMPTY             _HRESULT_TYPEDEF_(0x800401D1L)

//
// MessageId: CLIPBRD_E_CANT_SET
//
// MessageText:
//
//  SetClipboard Failed
//
#define CLIPBRD_E_CANT_SET               _HRESULT_TYPEDEF_(0x800401D2L)

//
// MessageId: CLIPBRD_E_BAD_DATA
//
// MessageText:
//
//  Data on clipboard is invalid
//
#define CLIPBRD_E_BAD_DATA               _HRESULT_TYPEDEF_(0x800401D3L)

//
// MessageId: CLIPBRD_E_CANT_CLOSE
//
// MessageText:
//
//  CloseClipboard Failed
//
#define CLIPBRD_E_CANT_CLOSE             _HRESULT_TYPEDEF_(0x800401D4L)

#define MK_E_FIRST        0x800401E0L
#define MK_E_LAST         0x800401EFL
#define MK_S_FIRST        0x000401E0L
#define MK_S_LAST         0x000401EFL
//
// MessageId: MK_E_CONNECTMANUALLY
//
// MessageText:
//
//  Moniker needs to be connected manually
//
#define MK_E_CONNECTMANUALLY             _HRESULT_TYPEDEF_(0x800401E0L)

//
// MessageId: MK_E_EXCEEDEDDEADLINE
//
// MessageText:
//
//  Operation exceeded deadline
//
#define MK_E_EXCEEDEDDEADLINE            _HRESULT_TYPEDEF_(0x800401E1L)

//
// MessageId: MK_E_NEEDGENERIC
//
// MessageText:
//
//  Moniker needs to be generic
//
#define MK_E_NEEDGENERIC                 _HRESULT_TYPEDEF_(0x800401E2L)

//
// MessageId: MK_E_UNAVAILABLE
//
// MessageText:
//
//  Operation unavailable
//
#define MK_E_UNAVAILABLE                 _HRESULT_TYPEDEF_(0x800401E3L)

//
// MessageId: MK_E_SYNTAX
//
// MessageText:
//
//  Invalid syntax
//
#define MK_E_SYNTAX                      _HRESULT_TYPEDEF_(0x800401E4L)

//
// MessageId: MK_E_NOOBJECT
//
// MessageText:
//
//  No object for moniker
//
#define MK_E_NOOBJECT                    _HRESULT_TYPEDEF_(0x800401E5L)

//
// MessageId: MK_E_INVALIDEXTENSION
//
// MessageText:
//
//  Bad extension for file
//
#define MK_E_INVALIDEXTENSION            _HRESULT_TYPEDEF_(0x800401E6L)

//
// MessageId: MK_E_INTERMEDIATEINTERFACENOTSUPPORTED
//
// MessageText:
//
//  Intermediate operation failed
//
#define MK_E_INTERMEDIATEINTERFACENOTSUPPORTED _HRESULT_TYPEDEF_(0x800401E7L)

//
// MessageId: MK_E_NOTBINDABLE
//
// MessageText:
//
//  Moniker is not bindable
//
#define MK_E_NOTBINDABLE                 _HRESULT_TYPEDEF_(0x800401E8L)

//
// MessageId: MK_E_NOTBOUND
//
// MessageText:
//
//  Moniker is not bound
//
#define MK_E_NOTBOUND                    _HRESULT_TYPEDEF_(0x800401E9L)

//
// MessageId: MK_E_CANTOPENFILE
//
// MessageText:
//
//  Moniker cannot open file
//
#define MK_E_CANTOPENFILE                _HRESULT_TYPEDEF_(0x800401EAL)

//
// MessageId: MK_E_MUSTBOTHERUSER
//
// MessageText:
//
//  User input required for operation to succeed
//
#define MK_E_MUSTBOTHERUSER              _HRESULT_TYPEDEF_(0x800401EBL)

//
// MessageId: MK_E_NOINVERSE
//
// MessageText:
//
//  Moniker class has no inverse
//
#define MK_E_NOINVERSE                   _HRESULT_TYPEDEF_(0x800401ECL)

//
// MessageId: MK_E_NOSTORAGE
//
// MessageText:
//
//  Moniker does not refer to storage
//
#define MK_E_NOSTORAGE                   _HRESULT_TYPEDEF_(0x800401EDL)

//
// MessageId: MK_E_NOPREFIX
//
// MessageText:
//
//  No common prefix
//
#define MK_E_NOPREFIX                    _HRESULT_TYPEDEF_(0x800401EEL)

//
// MessageId: MK_E_ENUMERATION_FAILED
//
// MessageText:
//
//  Moniker could not be enumerated
//
#define MK_E_ENUMERATION_FAILED          _HRESULT_TYPEDEF_(0x800401EFL)

#define CO_E_FIRST        0x800401F0L
#define CO_E_LAST         0x800401FFL
#define CO_S_FIRST        0x000401F0L
#define CO_S_LAST         0x000401FFL
//
// MessageId: CO_E_NOTINITIALIZED
//
// MessageText:
//
//  CoInitialize has not been called.
//
#define CO_E_NOTINITIALIZED              _HRESULT_TYPEDEF_(0x800401F0L)

//
// MessageId: CO_E_ALREADYINITIALIZED
//
// MessageText:
//
//  CoInitialize has already been called.
//
#define CO_E_ALREADYINITIALIZED          _HRESULT_TYPEDEF_(0x800401F1L)

//
// MessageId: CO_E_CANTDETERMINECLASS
//
// MessageText:
//
//  Class of object cannot be determined
//
#define CO_E_CANTDETERMINECLASS          _HRESULT_TYPEDEF_(0x800401F2L)

//
// MessageId: CO_E_CLASSSTRING
//
// MessageText:
//
//  Invalid class string
//
#define CO_E_CLASSSTRING                 _HRESULT_TYPEDEF_(0x800401F3L)

//
// MessageId: CO_E_IIDSTRING
//
// MessageText:
//
//  Invalid interface string
//
#define CO_E_IIDSTRING                   _HRESULT_TYPEDEF_(0x800401F4L)

//
// MessageId: CO_E_APPNOTFOUND
//
// MessageText:
//
//  Application not found
//
#define CO_E_APPNOTFOUND                 _HRESULT_TYPEDEF_(0x800401F5L)

//
// MessageId: CO_E_APPSINGLEUSE
//
// MessageText:
//
//  Application cannot be run more than once
//
#define CO_E_APPSINGLEUSE                _HRESULT_TYPEDEF_(0x800401F6L)

//
// MessageId: CO_E_ERRORINAPP
//
// MessageText:
//
//  Some error in application program
//
#define CO_E_ERRORINAPP                  _HRESULT_TYPEDEF_(0x800401F7L)

//
// MessageId: CO_E_DLLNOTFOUND
//
// MessageText:
//
//  DLL for class not found
//
#define CO_E_DLLNOTFOUND                 _HRESULT_TYPEDEF_(0x800401F8L)

//
// MessageId: CO_E_ERRORINDLL
//
// MessageText:
//
//  Error in the DLL
//
#define CO_E_ERRORINDLL                  _HRESULT_TYPEDEF_(0x800401F9L)

//
// MessageId: CO_E_WRONGOSFORAPP
//
// MessageText:
//
//  Wrong OS or OS version for application
//
#define CO_E_WRONGOSFORAPP               _HRESULT_TYPEDEF_(0x800401FAL)

//
// MessageId: CO_E_OBJNOTREG
//
// MessageText:
//
//  Object is not registered
//
#define CO_E_OBJNOTREG                   _HRESULT_TYPEDEF_(0x800401FBL)

//
// MessageId: CO_E_OBJISREG
//
// MessageText:
//
//  Object is already registered
//
#define CO_E_OBJISREG                    _HRESULT_TYPEDEF_(0x800401FCL)

//
// MessageId: CO_E_OBJNOTCONNECTED
//
// MessageText:
//
//  Object is not connected to server
//
#define CO_E_OBJNOTCONNECTED             _HRESULT_TYPEDEF_(0x800401FDL)

//
// MessageId: CO_E_APPDIDNTREG
//
// MessageText:
//
//  Application was launched but it didn't register a class factory
//
#define CO_E_APPDIDNTREG                 _HRESULT_TYPEDEF_(0x800401FEL)

//
// MessageId: CO_E_RELEASED
//
// MessageText:
//
//  Object has been released
//
#define CO_E_RELEASED                    _HRESULT_TYPEDEF_(0x800401FFL)

//
// Old OLE Success Codes
//
//
// MessageId: OLE_S_USEREG
//
// MessageText:
//
//  Use the registry database to provide the requested information
//
#define OLE_S_USEREG                     _HRESULT_TYPEDEF_(0x00040000L)

//
// MessageId: OLE_S_STATIC
//
// MessageText:
//
//  Success, but static
//
#define OLE_S_STATIC                     _HRESULT_TYPEDEF_(0x00040001L)

//
// MessageId: OLE_S_MAC_CLIPFORMAT
//
// MessageText:
//
//  Macintosh clipboard format
//
#define OLE_S_MAC_CLIPFORMAT             _HRESULT_TYPEDEF_(0x00040002L)

//
// MessageId: DRAGDROP_S_DROP
//
// MessageText:
//
//  Successful drop took place
//
#define DRAGDROP_S_DROP                  _HRESULT_TYPEDEF_(0x00040100L)

//
// MessageId: DRAGDROP_S_CANCEL
//
// MessageText:
//
//  Drag-drop operation canceled
//
#define DRAGDROP_S_CANCEL                _HRESULT_TYPEDEF_(0x00040101L)

//
// MessageId: DRAGDROP_S_USEDEFAULTCURSORS
//
// MessageText:
//
//  Use the default cursor
//
#define DRAGDROP_S_USEDEFAULTCURSORS     _HRESULT_TYPEDEF_(0x00040102L)

//
// MessageId: DATA_S_SAMEFORMATETC
//
// MessageText:
//
//  Data has same FORMATETC
//
#define DATA_S_SAMEFORMATETC             _HRESULT_TYPEDEF_(0x00040130L)

//
// MessageId: VIEW_S_ALREADY_FROZEN
//
// MessageText:
//
//  View is already frozen
//
#define VIEW_S_ALREADY_FROZEN            _HRESULT_TYPEDEF_(0x00040140L)

//
// MessageId: CACHE_S_FORMATETC_NOTSUPPORTED
//
// MessageText:
//
//  FORMATETC not supported
//
#define CACHE_S_FORMATETC_NOTSUPPORTED   _HRESULT_TYPEDEF_(0x00040170L)

//
// MessageId: CACHE_S_SAMECACHE
//
// MessageText:
//
//  Same cache
//
#define CACHE_S_SAMECACHE                _HRESULT_TYPEDEF_(0x00040171L)

//
// MessageId: CACHE_S_SOMECACHES_NOTUPDATED
//
// MessageText:
//
//  Some cache(s) not updated
//
#define CACHE_S_SOMECACHES_NOTUPDATED    _HRESULT_TYPEDEF_(0x00040172L)

//
// MessageId: OLEOBJ_S_INVALIDVERB
//
// MessageText:
//
//  Invalid verb for OLE object
//
#define OLEOBJ_S_INVALIDVERB             _HRESULT_TYPEDEF_(0x00040180L)

//
// MessageId: OLEOBJ_S_CANNOT_DOVERB_NOW
//
// MessageText:
//
//  Verb number is valid but verb cannot be done now
//
#define OLEOBJ_S_CANNOT_DOVERB_NOW       _HRESULT_TYPEDEF_(0x00040181L)

//
// MessageId: OLEOBJ_S_INVALIDHWND
//
// MessageText:
//
//  Invalid window handle passed
//
#define OLEOBJ_S_INVALIDHWND             _HRESULT_TYPEDEF_(0x00040182L)

//
// MessageId: INPLACE_S_TRUNCATED
//
// MessageText:
//
//  Message is too long; some of it had to be truncated before displaying
//
#define INPLACE_S_TRUNCATED              _HRESULT_TYPEDEF_(0x000401A0L)

//
// MessageId: CONVERT10_S_NO_PRESENTATION
//
// MessageText:
//
//  Unable to convert OLESTREAM to IStorage
//
#define CONVERT10_S_NO_PRESENTATION      _HRESULT_TYPEDEF_(0x000401C0L)

//
// MessageId: MK_S_REDUCED_TO_SELF
//
// MessageText:
//
//  Moniker reduced to itself
//
#define MK_S_REDUCED_TO_SELF             _HRESULT_TYPEDEF_(0x000401E2L)

//
// MessageId: MK_S_ME
//
// MessageText:
//
//  Common prefix is this moniker
//
#define MK_S_ME                          _HRESULT_TYPEDEF_(0x000401E4L)

//
// MessageId: MK_S_HIM
//
// MessageText:
//
//  Common prefix is input moniker
//
#define MK_S_HIM                         _HRESULT_TYPEDEF_(0x000401E5L)

//
// MessageId: MK_S_US
//
// MessageText:
//
//  Common prefix is both monikers
//
#define MK_S_US                          _HRESULT_TYPEDEF_(0x000401E6L)

//
// MessageId: MK_S_MONIKERALREADYREGISTERED
//
// MessageText:
//
//  Moniker is already registered in running object table
//
#define MK_S_MONIKERALREADYREGISTERED    _HRESULT_TYPEDEF_(0x000401E7L)

// ******************
// FACILITY_WINDOWS
// ******************
//
// Codes 0x0-0x01ff are reserved for the OLE group of
// interfaces.
//
//
// MessageId: CO_E_CLASS_CREATE_FAILED
//
// MessageText:
//
//  Attempt to create a class object failed
//
#define CO_E_CLASS_CREATE_FAILED         _HRESULT_TYPEDEF_(0x80080001L)

//
// MessageId: CO_E_SCM_ERROR
//
// MessageText:
//
//  OLE service could not bind object
//
#define CO_E_SCM_ERROR                   _HRESULT_TYPEDEF_(0x80080002L)

//
// MessageId: CO_E_SCM_RPC_FAILURE
//
// MessageText:
//
//  RPC communication failed with OLE service
//
#define CO_E_SCM_RPC_FAILURE             _HRESULT_TYPEDEF_(0x80080003L)

//
// MessageId: CO_E_BAD_PATH
//
// MessageText:
//
//  Bad path to object
//
#define CO_E_BAD_PATH                    _HRESULT_TYPEDEF_(0x80080004L)

//
// MessageId: CO_E_SERVER_EXEC_FAILURE
//
// MessageText:
//
//  Server execution failed
//
#define CO_E_SERVER_EXEC_FAILURE         _HRESULT_TYPEDEF_(0x80080005L)

//
// MessageId: CO_E_OBJSRV_RPC_FAILURE
//
// MessageText:
//
//  OLE service could not communicate with the object server
//
#define CO_E_OBJSRV_RPC_FAILURE          _HRESULT_TYPEDEF_(0x80080006L)

//
// MessageId: MK_E_NO_NORMALIZED
//
// MessageText:
//
//  Moniker path could not be normalized
//
#define MK_E_NO_NORMALIZED               _HRESULT_TYPEDEF_(0x80080007L)

//
// MessageId: CO_E_SERVER_STOPPING
//
// MessageText:
//
//  Object server is stopping when OLE service contacts it
//
#define CO_E_SERVER_STOPPING             _HRESULT_TYPEDEF_(0x80080008L)

//
// MessageId: MEM_E_INVALID_ROOT
//
// MessageText:
//
//  An invalid root block pointer was specified
//
#define MEM_E_INVALID_ROOT               _HRESULT_TYPEDEF_(0x80080009L)

//
// MessageId: MEM_E_INVALID_LINK
//
// MessageText:
//
//  An allocation chain contained an invalid link pointer
//
#define MEM_E_INVALID_LINK               _HRESULT_TYPEDEF_(0x80080010L)

//
// MessageId: MEM_E_INVALID_SIZE
//
// MessageText:
//
//  The requested allocation size was too large
//
#define MEM_E_INVALID_SIZE               _HRESULT_TYPEDEF_(0x80080011L)

//
// MessageId: CO_S_NOTALLINTERFACES
//
// MessageText:
//
//  Not all the requested interfaces were available
//
#define CO_S_NOTALLINTERFACES            _HRESULT_TYPEDEF_(0x00080012L)

// ******************
// FACILITY_DISPATCH
// ******************
//
// MessageId: DISP_E_UNKNOWNINTERFACE
//
// MessageText:
//
//  Unknown interface.
//
#define DISP_E_UNKNOWNINTERFACE          _HRESULT_TYPEDEF_(0x80020001L)

//
// MessageId: DISP_E_MEMBERNOTFOUND
//
// MessageText:
//
//  Member not found.
//
#define DISP_E_MEMBERNOTFOUND            _HRESULT_TYPEDEF_(0x80020003L)

//
// MessageId: DISP_E_PARAMNOTFOUND
//
// MessageText:
//
//  Parameter not found.
//
#define DISP_E_PARAMNOTFOUND             _HRESULT_TYPEDEF_(0x80020004L)

//
// MessageId: DISP_E_TYPEMISMATCH
//
// MessageText:
//
//  Type mismatch.
//
#define DISP_E_TYPEMISMATCH              _HRESULT_TYPEDEF_(0x80020005L)

//
// MessageId: DISP_E_UNKNOWNNAME
//
// MessageText:
//
//  Unknown name.
//
#define DISP_E_UNKNOWNNAME               _HRESULT_TYPEDEF_(0x80020006L)

//
// MessageId: DISP_E_NONAMEDARGS
//
// MessageText:
//
//  No named arguments.
//
#define DISP_E_NONAMEDARGS               _HRESULT_TYPEDEF_(0x80020007L)

//
// MessageId: DISP_E_BADVARTYPE
//
// MessageText:
//
//  Bad variable type.
//
#define DISP_E_BADVARTYPE                _HRESULT_TYPEDEF_(0x80020008L)

//
// MessageId: DISP_E_EXCEPTION
//
// MessageText:
//
//  Exception occurred.
//
#define DISP_E_EXCEPTION                 _HRESULT_TYPEDEF_(0x80020009L)

//
// MessageId: DISP_E_OVERFLOW
//
// MessageText:
//
//  Out of present range.
//
#define DISP_E_OVERFLOW                  _HRESULT_TYPEDEF_(0x8002000AL)

//
// MessageId: DISP_E_BADINDEX
//
// MessageText:
//
//  Invalid index.
//
#define DISP_E_BADINDEX                  _HRESULT_TYPEDEF_(0x8002000BL)

//
// MessageId: DISP_E_UNKNOWNLCID
//
// MessageText:
//
//  Unknown language.
//
#define DISP_E_UNKNOWNLCID               _HRESULT_TYPEDEF_(0x8002000CL)

//
// MessageId: DISP_E_ARRAYISLOCKED
//
// MessageText:
//
//  Memory is locked.
//
#define DISP_E_ARRAYISLOCKED             _HRESULT_TYPEDEF_(0x8002000DL)

//
// MessageId: DISP_E_BADPARAMCOUNT
//
// MessageText:
//
//  Invalid number of parameters.
//
#define DISP_E_BADPARAMCOUNT             _HRESULT_TYPEDEF_(0x8002000EL)

//
// MessageId: DISP_E_PARAMNOTOPTIONAL
//
// MessageText:
//
//  Parameter not optional.
//
#define DISP_E_PARAMNOTOPTIONAL          _HRESULT_TYPEDEF_(0x8002000FL)

//
// MessageId: DISP_E_BADCALLEE
//
// MessageText:
//
//  Invalid callee.
//
#define DISP_E_BADCALLEE                 _HRESULT_TYPEDEF_(0x80020010L)

//
// MessageId: DISP_E_NOTACOLLECTION
//
// MessageText:
//
//  Does not support a collection.
//
#define DISP_E_NOTACOLLECTION            _HRESULT_TYPEDEF_(0x80020011L)

//
// MessageId: TYPE_E_BUFFERTOOSMALL
//
// MessageText:
//
//  Buffer too small.
//
#define TYPE_E_BUFFERTOOSMALL            _HRESULT_TYPEDEF_(0x80028016L)

//
// MessageId: TYPE_E_INVDATAREAD
//
// MessageText:
//
//  Old format or invalid type library.
//
#define TYPE_E_INVDATAREAD               _HRESULT_TYPEDEF_(0x80028018L)

//
// MessageId: TYPE_E_UNSUPFORMAT
//
// MessageText:
//
//  Old format or invalid type library.
//
#define TYPE_E_UNSUPFORMAT               _HRESULT_TYPEDEF_(0x80028019L)

//
// MessageId: TYPE_E_REGISTRYACCESS
//
// MessageText:
//
//  Error accessing the OLE registry.
//
#define TYPE_E_REGISTRYACCESS            _HRESULT_TYPEDEF_(0x8002801CL)

//
// MessageId: TYPE_E_LIBNOTREGISTERED
//
// MessageText:
//
//  Library not registered.
//
#define TYPE_E_LIBNOTREGISTERED          _HRESULT_TYPEDEF_(0x8002801DL)

//
// MessageId: TYPE_E_UNDEFINEDTYPE
//
// MessageText:
//
//  Bound to unknown type.
//
#define TYPE_E_UNDEFINEDTYPE             _HRESULT_TYPEDEF_(0x80028027L)

//
// MessageId: TYPE_E_QUALIFIEDNAMEDISALLOWED
//
// MessageText:
//
//  Qualified name disallowed.
//
#define TYPE_E_QUALIFIEDNAMEDISALLOWED   _HRESULT_TYPEDEF_(0x80028028L)

//
// MessageId: TYPE_E_INVALIDSTATE
//
// MessageText:
//
//  Invalid forward reference, or reference to uncompiled type.
//
#define TYPE_E_INVALIDSTATE              _HRESULT_TYPEDEF_(0x80028029L)

//
// MessageId: TYPE_E_WRONGTYPEKIND
//
// MessageText:
//
//  Type mismatch.
//
#define TYPE_E_WRONGTYPEKIND             _HRESULT_TYPEDEF_(0x8002802AL)

//
// MessageId: TYPE_E_ELEMENTNOTFOUND
//
// MessageText:
//
//  Element not found.
//
#define TYPE_E_ELEMENTNOTFOUND           _HRESULT_TYPEDEF_(0x8002802BL)

//
// MessageId: TYPE_E_AMBIGUOUSNAME
//
// MessageText:
//
//  Ambiguous name.
//
#define TYPE_E_AMBIGUOUSNAME             _HRESULT_TYPEDEF_(0x8002802CL)

//
// MessageId: TYPE_E_NAMECONFLICT
//
// MessageText:
//
//  Name already exists in the library.
//
#define TYPE_E_NAMECONFLICT              _HRESULT_TYPEDEF_(0x8002802DL)

//
// MessageId: TYPE_E_UNKNOWNLCID
//
// MessageText:
//
//  Unknown LCID.
//
#define TYPE_E_UNKNOWNLCID               _HRESULT_TYPEDEF_(0x8002802EL)

//
// MessageId: TYPE_E_DLLFUNCTIONNOTFOUND
//
// MessageText:
//
//  Function not defined in specified DLL.
//
#define TYPE_E_DLLFUNCTIONNOTFOUND       _HRESULT_TYPEDEF_(0x8002802FL)

//
// MessageId: TYPE_E_BADMODULEKIND
//
// MessageText:
//
//  Wrong module kind for the operation.
//
#define TYPE_E_BADMODULEKIND             _HRESULT_TYPEDEF_(0x800288BDL)

//
// MessageId: TYPE_E_SIZETOOBIG
//
// MessageText:
//
//  Size may not exceed 64K.
//
#define TYPE_E_SIZETOOBIG                _HRESULT_TYPEDEF_(0x800288C5L)

//
// MessageId: TYPE_E_DUPLICATEID
//
// MessageText:
//
//  Duplicate ID in inheritance hierarchy.
//
#define TYPE_E_DUPLICATEID               _HRESULT_TYPEDEF_(0x800288C6L)

//
// MessageId: TYPE_E_INVALIDID
//
// MessageText:
//
//  Incorrect inheritance depth in standard OLE hmember.
//
#define TYPE_E_INVALIDID                 _HRESULT_TYPEDEF_(0x800288CFL)

//
// MessageId: TYPE_E_TYPEMISMATCH
//
// MessageText:
//
//  Type mismatch.
//
#define TYPE_E_TYPEMISMATCH              _HRESULT_TYPEDEF_(0x80028CA0L)

//
// MessageId: TYPE_E_OUTOFBOUNDS
//
// MessageText:
//
//  Invalid number of arguments.
//
#define TYPE_E_OUTOFBOUNDS               _HRESULT_TYPEDEF_(0x80028CA1L)

//
// MessageId: TYPE_E_IOERROR
//
// MessageText:
//
//  I/O Error.
//
#define TYPE_E_IOERROR                   _HRESULT_TYPEDEF_(0x80028CA2L)

//
// MessageId: TYPE_E_CANTCREATETMPFILE
//
// MessageText:
//
//  Error creating unique tmp file.
//
#define TYPE_E_CANTCREATETMPFILE         _HRESULT_TYPEDEF_(0x80028CA3L)

//
// MessageId: TYPE_E_CANTLOADLIBRARY
//
// MessageText:
//
//  Error loading type library/DLL.
//
#define TYPE_E_CANTLOADLIBRARY           _HRESULT_TYPEDEF_(0x80029C4AL)

//
// MessageId: TYPE_E_INCONSISTENTPROPFUNCS
//
// MessageText:
//
//  Inconsistent property functions.
//
#define TYPE_E_INCONSISTENTPROPFUNCS     _HRESULT_TYPEDEF_(0x80029C83L)

//
// MessageId: TYPE_E_CIRCULARTYPE
//
// MessageText:
//
//  Circular dependency between types/modules.
//
#define TYPE_E_CIRCULARTYPE              _HRESULT_TYPEDEF_(0x80029C84L)

// ******************
// FACILITY_STORAGE
// ******************
//
// MessageId: STG_E_INVALIDFUNCTION
//
// MessageText:
//
//  Unable to perform requested operation.
//
#define STG_E_INVALIDFUNCTION            _HRESULT_TYPEDEF_(0x80030001L)

//
// MessageId: STG_E_FILENOTFOUND
//
// MessageText:
//
//  %1 could not be found.
//
#define STG_E_FILENOTFOUND               _HRESULT_TYPEDEF_(0x80030002L)

//
// MessageId: STG_E_PATHNOTFOUND
//
// MessageText:
//
//  The path %1 could not be found.
//
#define STG_E_PATHNOTFOUND               _HRESULT_TYPEDEF_(0x80030003L)

//
// MessageId: STG_E_TOOMANYOPENFILES
//
// MessageText:
//
//  There are insufficient resources to open another file.
//
#define STG_E_TOOMANYOPENFILES           _HRESULT_TYPEDEF_(0x80030004L)

//
// MessageId: STG_E_ACCESSDENIED
//
// MessageText:
//
//  Access Denied.
//
#define STG_E_ACCESSDENIED               _HRESULT_TYPEDEF_(0x80030005L)

//
// MessageId: STG_E_INVALIDHANDLE
//
// MessageText:
//
//  Attempted an operation on an invalid object.
//
#define STG_E_INVALIDHANDLE              _HRESULT_TYPEDEF_(0x80030006L)

//
// MessageId: STG_E_INSUFFICIENTMEMORY
//
// MessageText:
//
//  There is insufficient memory available to complete operation.
//
#define STG_E_INSUFFICIENTMEMORY         _HRESULT_TYPEDEF_(0x80030008L)

//
// MessageId: STG_E_INVALIDPOINTER
//
// MessageText:
//
//  Invalid pointer error.
//
#define STG_E_INVALIDPOINTER             _HRESULT_TYPEDEF_(0x80030009L)

//
// MessageId: STG_E_NOMOREFILES
//
// MessageText:
//
//  There are no more entries to return.
//
#define STG_E_NOMOREFILES                _HRESULT_TYPEDEF_(0x80030012L)

//
// MessageId: STG_E_DISKISWRITEPROTECTED
//
// MessageText:
//
//  Disk is write-protected.
//
#define STG_E_DISKISWRITEPROTECTED       _HRESULT_TYPEDEF_(0x80030013L)

//
// MessageId: STG_E_SEEKERROR
//
// MessageText:
//
//  An error occurred during a seek operation.
//
#define STG_E_SEEKERROR                  _HRESULT_TYPEDEF_(0x80030019L)

//
// MessageId: STG_E_WRITEFAULT
//
// MessageText:
//
//  A disk error occurred during a write operation.
//
#define STG_E_WRITEFAULT                 _HRESULT_TYPEDEF_(0x8003001DL)

//
// MessageId: STG_E_READFAULT
//
// MessageText:
//
//  A disk error occurred during a read operation.
//
#define STG_E_READFAULT                  _HRESULT_TYPEDEF_(0x8003001EL)

//
// MessageId: STG_E_SHAREVIOLATION
//
// MessageText:
//
//  A share violation has occurred.
//
#define STG_E_SHAREVIOLATION             _HRESULT_TYPEDEF_(0x80030020L)

//
// MessageId: STG_E_LOCKVIOLATION
//
// MessageText:
//
//  A lock violation has occurred.
//
#define STG_E_LOCKVIOLATION              _HRESULT_TYPEDEF_(0x80030021L)

//
// MessageId: STG_E_FILEALREADYEXISTS
//
// MessageText:
//
//  %1 already exists.
//
#define STG_E_FILEALREADYEXISTS          _HRESULT_TYPEDEF_(0x80030050L)

//
// MessageId: STG_E_INVALIDPARAMETER
//
// MessageText:
//
//  Invalid parameter error.
//
#define STG_E_INVALIDPARAMETER           _HRESULT_TYPEDEF_(0x80030057L)

//
// MessageId: STG_E_MEDIUMFULL
//
// MessageText:
//
//  There is insufficient disk space to complete operation.
//
#define STG_E_MEDIUMFULL                 _HRESULT_TYPEDEF_(0x80030070L)

//
// MessageId: STG_E_PROPSETMISMATCHED
//
// MessageText:
//
//  Illegal write of non-simple property to simple property set.
//
#define STG_E_PROPSETMISMATCHED          _HRESULT_TYPEDEF_(0x800300F0L)

//
// MessageId: STG_E_ABNORMALAPIEXIT
//
// MessageText:
//
//  An API call exited abnormally.
//
#define STG_E_ABNORMALAPIEXIT            _HRESULT_TYPEDEF_(0x800300FAL)

//
// MessageId: STG_E_INVALIDHEADER
//
// MessageText:
//
//  The file %1 is not a valid compound file.
//
#define STG_E_INVALIDHEADER              _HRESULT_TYPEDEF_(0x800300FBL)

//
// MessageId: STG_E_INVALIDNAME
//
// MessageText:
//
//  The name %1 is not valid.
//
#define STG_E_INVALIDNAME                _HRESULT_TYPEDEF_(0x800300FCL)

//
// MessageId: STG_E_UNKNOWN
//
// MessageText:
//
//  An unexpected error occurred.
//
#define STG_E_UNKNOWN                    _HRESULT_TYPEDEF_(0x800300FDL)

//
// MessageId: STG_E_UNIMPLEMENTEDFUNCTION
//
// MessageText:
//
//  That function is not implemented.
//
#define STG_E_UNIMPLEMENTEDFUNCTION      _HRESULT_TYPEDEF_(0x800300FEL)

//
// MessageId: STG_E_INVALIDFLAG
//
// MessageText:
//
//  Invalid flag error.
//
#define STG_E_INVALIDFLAG                _HRESULT_TYPEDEF_(0x800300FFL)

//
// MessageId: STG_E_INUSE
//
// MessageText:
//
//  Attempted to use an object that is busy.
//
#define STG_E_INUSE                      _HRESULT_TYPEDEF_(0x80030100L)

//
// MessageId: STG_E_NOTCURRENT
//
// MessageText:
//
//  The storage has been changed since the last commit.
//
#define STG_E_NOTCURRENT                 _HRESULT_TYPEDEF_(0x80030101L)

//
// MessageId: STG_E_REVERTED
//
// MessageText:
//
//  Attempted to use an object that has ceased to exist.
//
#define STG_E_REVERTED                   _HRESULT_TYPEDEF_(0x80030102L)

//
// MessageId: STG_E_CANTSAVE
//
// MessageText:
//
//  Can't save.
//
#define STG_E_CANTSAVE                   _HRESULT_TYPEDEF_(0x80030103L)

//
// MessageId: STG_E_OLDFORMAT
//
// MessageText:
//
//  The compound file %1 was produced with an incompatible version of storage.
//
#define STG_E_OLDFORMAT                  _HRESULT_TYPEDEF_(0x80030104L)

//
// MessageId: STG_E_OLDDLL
//
// MessageText:
//
//  The compound file %1 was produced with a newer version of storage.
//
#define STG_E_OLDDLL                     _HRESULT_TYPEDEF_(0x80030105L)

//
// MessageId: STG_E_SHAREREQUIRED
//
// MessageText:
//
//  Share.exe or equivalent is required for operation.
//
#define STG_E_SHAREREQUIRED              _HRESULT_TYPEDEF_(0x80030106L)

//
// MessageId: STG_E_NOTFILEBASEDSTORAGE
//
// MessageText:
//
//  Illegal operation called on non-file based storage.
//
#define STG_E_NOTFILEBASEDSTORAGE        _HRESULT_TYPEDEF_(0x80030107L)

//
// MessageId: STG_E_EXTANTMARSHALLINGS
//
// MessageText:
//
//  Illegal operation called on object with extant marshallings.
//
#define STG_E_EXTANTMARSHALLINGS         _HRESULT_TYPEDEF_(0x80030108L)

//
// MessageId: STG_E_DOCFILECORRUPT
//
// MessageText:
//
//  The docfile has been corrupted.
//
#define STG_E_DOCFILECORRUPT             _HRESULT_TYPEDEF_(0x80030109L)

//
// MessageId: STG_E_BADBASEADDRESS
//
// MessageText:
//
//  OLE32.DLL has been loaded at the wrong address.
//
#define STG_E_BADBASEADDRESS             _HRESULT_TYPEDEF_(0x80030110L)

//
// MessageId: STG_E_INCOMPLETE
//
// MessageText:
//
//  The file download was aborted abnormally.  The file is incomplete.
//
#define STG_E_INCOMPLETE                 _HRESULT_TYPEDEF_(0x80030201L)

//
// MessageId: STG_E_TERMINATED
//
// MessageText:
//
//  The file download has been terminated.
//
#define STG_E_TERMINATED                 _HRESULT_TYPEDEF_(0x80030202L)

//
// MessageId: STG_S_CONVERTED
//
// MessageText:
//
//  The underlying file was converted to compound file format.
//
#define STG_S_CONVERTED                  _HRESULT_TYPEDEF_(0x00030200L)

//
// MessageId: STG_S_BLOCK
//
// MessageText:
//
//  The storage operation should block until more data is available.
//
#define STG_S_BLOCK                      _HRESULT_TYPEDEF_(0x00030201L)

//
// MessageId: STG_S_RETRYNOW
//
// MessageText:
//
//  The storage operation should retry immediately.
//
#define STG_S_RETRYNOW                   _HRESULT_TYPEDEF_(0x00030202L)

//
// MessageId: STG_S_MONITORING
//
// MessageText:
//
//  The notified event sink will not influence the storage operation.
//
#define STG_S_MONITORING                 _HRESULT_TYPEDEF_(0x00030203L)

// ******************
// FACILITY_RPC
// ******************
//
// Codes 0x0-0x11 are propogated from 16 bit OLE.
//
//
// MessageId: RPC_E_CALL_REJECTED
//
// MessageText:
//
//  Call was rejected by callee.
//
#define RPC_E_CALL_REJECTED              _HRESULT_TYPEDEF_(0x80010001L)

//
// MessageId: RPC_E_CALL_CANCELED
//
// MessageText:
//
//  Call was canceled by the message filter.
//
#define RPC_E_CALL_CANCELED              _HRESULT_TYPEDEF_(0x80010002L)

//
// MessageId: RPC_E_CANTPOST_INSENDCALL
//
// MessageText:
//
//  The caller is dispatching an intertask SendMessage call and
//  cannot call out via PostMessage.
//
#define RPC_E_CANTPOST_INSENDCALL        _HRESULT_TYPEDEF_(0x80010003L)

//
// MessageId: RPC_E_CANTCALLOUT_INASYNCCALL
//
// MessageText:
//
//  The caller is dispatching an asynchronous call and cannot
//  make an outgoing call on behalf of this call.
//
#define RPC_E_CANTCALLOUT_INASYNCCALL    _HRESULT_TYPEDEF_(0x80010004L)

//
// MessageId: RPC_E_CANTCALLOUT_INEXTERNALCALL
//
// MessageText:
//
//  It is illegal to call out while inside message filter.
//
#define RPC_E_CANTCALLOUT_INEXTERNALCALL _HRESULT_TYPEDEF_(0x80010005L)

//
// MessageId: RPC_E_CONNECTION_TERMINATED
//
// MessageText:
//
//  The connection terminated or is in a bogus state
//  and cannot be used any more. Other connections
//  are still valid.
//
#define RPC_E_CONNECTION_TERMINATED      _HRESULT_TYPEDEF_(0x80010006L)

//
// MessageId: RPC_E_SERVER_DIED
//
// MessageText:
//
//  The callee (server [not server application]) is not available
//  and disappeared; all connections are invalid.  The call may
//  have executed.
//
#define RPC_E_SERVER_DIED                _HRESULT_TYPEDEF_(0x80010007L)

//
// MessageId: RPC_E_CLIENT_DIED
//
// MessageText:
//
//  The caller (client) disappeared while the callee (server) was
//  processing a call.
//
#define RPC_E_CLIENT_DIED                _HRESULT_TYPEDEF_(0x80010008L)

//
// MessageId: RPC_E_INVALID_DATAPACKET
//
// MessageText:
//
//  The data packet with the marshalled parameter data is incorrect.
//
#define RPC_E_INVALID_DATAPACKET         _HRESULT_TYPEDEF_(0x80010009L)

//
// MessageId: RPC_E_CANTTRANSMIT_CALL
//
// MessageText:
//
//  The call was not transmitted properly; the message queue
//  was full and was not emptied after yielding.
//
#define RPC_E_CANTTRANSMIT_CALL          _HRESULT_TYPEDEF_(0x8001000AL)

//
// MessageId: RPC_E_CLIENT_CANTMARSHAL_DATA
//
// MessageText:
//
//  The client (caller) cannot marshall the parameter data - low memory, etc.
//
#define RPC_E_CLIENT_CANTMARSHAL_DATA    _HRESULT_TYPEDEF_(0x8001000BL)

//
// MessageId: RPC_E_CLIENT_CANTUNMARSHAL_DATA
//
// MessageText:
//
//  The client (caller) cannot unmarshall the return data - low memory, etc.
//
#define RPC_E_CLIENT_CANTUNMARSHAL_DATA  _HRESULT_TYPEDEF_(0x8001000CL)

//
// MessageId: RPC_E_SERVER_CANTMARSHAL_DATA
//
// MessageText:
//
//  The server (callee) cannot marshall the return data - low memory, etc.
//
#define RPC_E_SERVER_CANTMARSHAL_DATA    _HRESULT_TYPEDEF_(0x8001000DL)

//
// MessageId: RPC_E_SERVER_CANTUNMARSHAL_DATA
//
// MessageText:
//
//  The server (callee) cannot unmarshall the parameter data - low memory, etc.
//
#define RPC_E_SERVER_CANTUNMARSHAL_DATA  _HRESULT_TYPEDEF_(0x8001000EL)

//
// MessageId: RPC_E_INVALID_DATA
//
// MessageText:
//
//  Received data is invalid; could be server or client data.
//
#define RPC_E_INVALID_DATA               _HRESULT_TYPEDEF_(0x8001000FL)

//
// MessageId: RPC_E_INVALID_PARAMETER
//
// MessageText:
//
//  A particular parameter is invalid and cannot be (un)marshalled.
//
#define RPC_E_INVALID_PARAMETER          _HRESULT_TYPEDEF_(0x80010010L)

//
// MessageId: RPC_E_CANTCALLOUT_AGAIN
//
// MessageText:
//
//  There is no second outgoing call on same channel in DDE conversation.
//
#define RPC_E_CANTCALLOUT_AGAIN          _HRESULT_TYPEDEF_(0x80010011L)

//
// MessageId: RPC_E_SERVER_DIED_DNE
//
// MessageText:
//
//  The callee (server [not server application]) is not available
//  and disappeared; all connections are invalid.  The call did not execute.
//
#define RPC_E_SERVER_DIED_DNE            _HRESULT_TYPEDEF_(0x80010012L)

//
// MessageId: RPC_E_SYS_CALL_FAILED
//
// MessageText:
//
//  System call failed.
//
#define RPC_E_SYS_CALL_FAILED            _HRESULT_TYPEDEF_(0x80010100L)

//
// MessageId: RPC_E_OUT_OF_RESOURCES
//
// MessageText:
//
//  Could not allocate some required resource (memory, events, ...)
//
#define RPC_E_OUT_OF_RESOURCES           _HRESULT_TYPEDEF_(0x80010101L)

//
// MessageId: RPC_E_ATTEMPTED_MULTITHREAD
//
// MessageText:
//
//  Attempted to make calls on more than one thread in single threaded mode.
//
#define RPC_E_ATTEMPTED_MULTITHREAD      _HRESULT_TYPEDEF_(0x80010102L)

//
// MessageId: RPC_E_NOT_REGISTERED
//
// MessageText:
//
//  The requested interface is not registered on the server object.
//
#define RPC_E_NOT_REGISTERED             _HRESULT_TYPEDEF_(0x80010103L)

//
// MessageId: RPC_E_FAULT
//
// MessageText:
//
//  RPC could not call the server or could not return the results of calling the server.
//
#define RPC_E_FAULT                      _HRESULT_TYPEDEF_(0x80010104L)

//
// MessageId: RPC_E_SERVERFAULT
//
// MessageText:
//
//  The server threw an exception.
//
#define RPC_E_SERVERFAULT                _HRESULT_TYPEDEF_(0x80010105L)

//
// MessageId: RPC_E_CHANGED_MODE
//
// MessageText:
//
//  Cannot change thread mode after it is set.
//
#define RPC_E_CHANGED_MODE               _HRESULT_TYPEDEF_(0x80010106L)

//
// MessageId: RPC_E_INVALIDMETHOD
//
// MessageText:
//
//  The method called does not exist on the server.
//
#define RPC_E_INVALIDMETHOD              _HRESULT_TYPEDEF_(0x80010107L)

//
// MessageId: RPC_E_DISCONNECTED
//
// MessageText:
//
//  The object invoked has disconnected from its clients.
//
#define RPC_E_DISCONNECTED               _HRESULT_TYPEDEF_(0x80010108L)

//
// MessageId: RPC_E_RETRY
//
// MessageText:
//
//  The object invoked chose not to process the call now.  Try again later.
//
#define RPC_E_RETRY                      _HRESULT_TYPEDEF_(0x80010109L)

//
// MessageId: RPC_E_SERVERCALL_RETRYLATER
//
// MessageText:
//
//  The message filter indicated that the application is busy.
//
#define RPC_E_SERVERCALL_RETRYLATER      _HRESULT_TYPEDEF_(0x8001010AL)

//
// MessageId: RPC_E_SERVERCALL_REJECTED
//
// MessageText:
//
//  The message filter rejected the call.
//
#define RPC_E_SERVERCALL_REJECTED        _HRESULT_TYPEDEF_(0x8001010BL)

//
// MessageId: RPC_E_INVALID_CALLDATA
//
// MessageText:
//
//  A call control interfaces was called with invalid data.
//
#define RPC_E_INVALID_CALLDATA           _HRESULT_TYPEDEF_(0x8001010CL)

//
// MessageId: RPC_E_CANTCALLOUT_ININPUTSYNCCALL
//
// MessageText:
//
//  An outgoing call cannot be made since the application is dispatching an input-synchronous call.
//
#define RPC_E_CANTCALLOUT_ININPUTSYNCCALL _HRESULT_TYPEDEF_(0x8001010DL)

//
// MessageId: RPC_E_WRONG_THREAD
//
// MessageText:
//
//  The application called an interface that was marshalled for a different thread.
//
#define RPC_E_WRONG_THREAD               _HRESULT_TYPEDEF_(0x8001010EL)

//
// MessageId: RPC_E_THREAD_NOT_INIT
//
// MessageText:
//
//  CoInitialize has not been called on the current thread.
//
#define RPC_E_THREAD_NOT_INIT            _HRESULT_TYPEDEF_(0x8001010FL)

//
// MessageId: RPC_E_VERSION_MISMATCH
//
// MessageText:
//
//  The version of OLE on the client and server machines does not match.
//
#define RPC_E_VERSION_MISMATCH           _HRESULT_TYPEDEF_(0x80010110L)

//
// MessageId: RPC_E_INVALID_HEADER
//
// MessageText:
//
//  OLE received a packet with an invalid header.
//
#define RPC_E_INVALID_HEADER             _HRESULT_TYPEDEF_(0x80010111L)

//
// MessageId: RPC_E_INVALID_EXTENSION
//
// MessageText:
//
//  OLE received a packet with an invalid extension.
//
#define RPC_E_INVALID_EXTENSION          _HRESULT_TYPEDEF_(0x80010112L)

//
// MessageId: RPC_E_INVALID_IPID
//
// MessageText:
//
//  The requested object or interface does not exist.
//
#define RPC_E_INVALID_IPID               _HRESULT_TYPEDEF_(0x80010113L)

//
// MessageId: RPC_E_INVALID_OBJECT
//
// MessageText:
//
//  The requested object does not exist.
//
#define RPC_E_INVALID_OBJECT             _HRESULT_TYPEDEF_(0x80010114L)

//
// MessageId: RPC_S_CALLPENDING
//
// MessageText:
//
//  OLE has sent a request and is waiting for a reply.
//
#define RPC_S_CALLPENDING                _HRESULT_TYPEDEF_(0x80010115L)

//
// MessageId: RPC_S_WAITONTIMER
//
// MessageText:
//
//  OLE is waiting before retrying a request.
//
#define RPC_S_WAITONTIMER                _HRESULT_TYPEDEF_(0x80010116L)

//
// MessageId: RPC_E_CALL_COMPLETE
//
// MessageText:
//
//  Call context cannot be accessed after call completed.
//
#define RPC_E_CALL_COMPLETE              _HRESULT_TYPEDEF_(0x80010117L)

//
// MessageId: RPC_E_UNSECURE_CALL
//
// MessageText:
//
//  Impersonate on unsecure calls is not supported.
//
#define RPC_E_UNSECURE_CALL              _HRESULT_TYPEDEF_(0x80010118L)

//
// MessageId: RPC_E_TOO_LATE
//
// MessageText:
//
//  Security must be initialized before any interfaces are marshalled or
//  unmarshalled.  It cannot be changed once initialized.
//
#define RPC_E_TOO_LATE                   _HRESULT_TYPEDEF_(0x80010119L)

//
// MessageId: RPC_E_NO_GOOD_SECURITY_PACKAGES
//
// MessageText:
//
//  No security packages are installed on this machine or the user is not logged
//  on or there are no compatible security packages between the client and server.
//
#define RPC_E_NO_GOOD_SECURITY_PACKAGES  _HRESULT_TYPEDEF_(0x8001011AL)

//
// MessageId: RPC_E_ACCESS_DENIED
//
// MessageText:
//
//  Access is denied.
//
#define RPC_E_ACCESS_DENIED              _HRESULT_TYPEDEF_(0x8001011BL)

//
// MessageId: RPC_E_REMOTE_DISABLED
//
// MessageText:
//
//  Remote calls are not allowed for this process.
//
#define RPC_E_REMOTE_DISABLED            _HRESULT_TYPEDEF_(0x8001011CL)

//
// MessageId: RPC_E_INVALID_OBJREF
//
// MessageText:
//
//  The marshaled interface data packet (OBJREF) has an invalid or unknown format.
//
#define RPC_E_INVALID_OBJREF             _HRESULT_TYPEDEF_(0x8001011DL)

//
// MessageId: RPC_E_UNEXPECTED
//
// MessageText:
//
//  An internal error occurred.
//
#define RPC_E_UNEXPECTED                 _HRESULT_TYPEDEF_(0x8001FFFFL)


 /////////////////
 //
 //  FACILITY_SSPI
 //
 /////////////////

//
// MessageId: NTE_BAD_UID
//
// MessageText:
//
//  Bad UID.
//
#define NTE_BAD_UID                      _HRESULT_TYPEDEF_(0x80090001L)

//
// MessageId: NTE_BAD_HASH
//
// MessageText:
//
//  Bad Hash.
//
#define NTE_BAD_HASH                     _HRESULT_TYPEDEF_(0x80090002L)

//
// MessageId: NTE_BAD_KEY
//
// MessageText:
//
//  Bad Key.
//
#define NTE_BAD_KEY                      _HRESULT_TYPEDEF_(0x80090003L)

//
// MessageId: NTE_BAD_LEN
//
// MessageText:
//
//  Bad Length.
//
#define NTE_BAD_LEN                      _HRESULT_TYPEDEF_(0x80090004L)

//
// MessageId: NTE_BAD_DATA
//
// MessageText:
//
//  Bad Data.
//
#define NTE_BAD_DATA                     _HRESULT_TYPEDEF_(0x80090005L)

//
// MessageId: NTE_BAD_SIGNATURE
//
// MessageText:
//
//  Invalid Signature.
//
#define NTE_BAD_SIGNATURE                _HRESULT_TYPEDEF_(0x80090006L)

//
// MessageId: NTE_BAD_VER
//
// MessageText:
//
//  Bad Version of provider.
//
#define NTE_BAD_VER                      _HRESULT_TYPEDEF_(0x80090007L)

//
// MessageId: NTE_BAD_ALGID
//
// MessageText:
//
//  Invalid algorithm specified.
//
#define NTE_BAD_ALGID                    _HRESULT_TYPEDEF_(0x80090008L)

//
// MessageId: NTE_BAD_FLAGS
//
// MessageText:
//
//  Invalid flags specified.
//
#define NTE_BAD_FLAGS                    _HRESULT_TYPEDEF_(0x80090009L)

//
// MessageId: NTE_BAD_TYPE
//
// MessageText:
//
//  Invalid type specified.
//
#define NTE_BAD_TYPE                     _HRESULT_TYPEDEF_(0x8009000AL)

//
// MessageId: NTE_BAD_KEY_STATE
//
// MessageText:
//
//  Key not valid for use in specified state.
//
#define NTE_BAD_KEY_STATE                _HRESULT_TYPEDEF_(0x8009000BL)

//
// MessageId: NTE_BAD_HASH_STATE
//
// MessageText:
//
//  Hash not valid for use in specified state.
//
#define NTE_BAD_HASH_STATE               _HRESULT_TYPEDEF_(0x8009000CL)

//
// MessageId: NTE_NO_KEY
//
// MessageText:
//
//  Key does not exist.
//
#define NTE_NO_KEY                       _HRESULT_TYPEDEF_(0x8009000DL)

//
// MessageId: NTE_NO_MEMORY
//
// MessageText:
//
//  Insufficient memory available for the operation.
//
#define NTE_NO_MEMORY                    _HRESULT_TYPEDEF_(0x8009000EL)

//
// MessageId: NTE_EXISTS
//
// MessageText:
//
//  Object already exists.
//
#define NTE_EXISTS                       _HRESULT_TYPEDEF_(0x8009000FL)

//
// MessageId: NTE_PERM
//
// MessageText:
//
//  Access denied.
//
#define NTE_PERM                         _HRESULT_TYPEDEF_(0x80090010L)

//
// MessageId: NTE_NOT_FOUND
//
// MessageText:
//
//  Object was not found.
//
#define NTE_NOT_FOUND                    _HRESULT_TYPEDEF_(0x80090011L)

//
// MessageId: NTE_DOUBLE_ENCRYPT
//
// MessageText:
//
//  Data already encrypted.
//
#define NTE_DOUBLE_ENCRYPT               _HRESULT_TYPEDEF_(0x80090012L)

//
// MessageId: NTE_BAD_PROVIDER
//
// MessageText:
//
//  Invalid provider specified.
//
#define NTE_BAD_PROVIDER                 _HRESULT_TYPEDEF_(0x80090013L)

//
// MessageId: NTE_BAD_PROV_TYPE
//
// MessageText:
//
//  Invalid provider type specified.
//
#define NTE_BAD_PROV_TYPE                _HRESULT_TYPEDEF_(0x80090014L)

//
// MessageId: NTE_BAD_PUBLIC_KEY
//
// MessageText:
//
//  Provider's public key is invalid.
//
#define NTE_BAD_PUBLIC_KEY               _HRESULT_TYPEDEF_(0x80090015L)

//
// MessageId: NTE_BAD_KEYSET
//
// MessageText:
//
//  Keyset does not exist
//
#define NTE_BAD_KEYSET                   _HRESULT_TYPEDEF_(0x80090016L)

//
// MessageId: NTE_PROV_TYPE_NOT_DEF
//
// MessageText:
//
//  Provider type not defined.
//
#define NTE_PROV_TYPE_NOT_DEF            _HRESULT_TYPEDEF_(0x80090017L)

//
// MessageId: NTE_PROV_TYPE_ENTRY_BAD
//
// MessageText:
//
//  Provider type as registered is invalid.
//
#define NTE_PROV_TYPE_ENTRY_BAD          _HRESULT_TYPEDEF_(0x80090018L)

//
// MessageId: NTE_KEYSET_NOT_DEF
//
// MessageText:
//
//  The keyset is not defined.
//
#define NTE_KEYSET_NOT_DEF               _HRESULT_TYPEDEF_(0x80090019L)

//
// MessageId: NTE_KEYSET_ENTRY_BAD
//
// MessageText:
//
//  Keyset as registered is invalid.
//
#define NTE_KEYSET_ENTRY_BAD             _HRESULT_TYPEDEF_(0x8009001AL)

//
// MessageId: NTE_PROV_TYPE_NO_MATCH
//
// MessageText:
//
//  Provider type does not match registered value.
//
#define NTE_PROV_TYPE_NO_MATCH           _HRESULT_TYPEDEF_(0x8009001BL)

//
// MessageId: NTE_SIGNATURE_FILE_BAD
//
// MessageText:
//
//  The digital signature file is corrupt.
//
#define NTE_SIGNATURE_FILE_BAD           _HRESULT_TYPEDEF_(0x8009001CL)

//
// MessageId: NTE_PROVIDER_DLL_FAIL
//
// MessageText:
//
//  Provider DLL failed to initialize correctly.
//
#define NTE_PROVIDER_DLL_FAIL            _HRESULT_TYPEDEF_(0x8009001DL)

//
// MessageId: NTE_PROV_DLL_NOT_FOUND
//
// MessageText:
//
//  Provider DLL could not be found.
//
#define NTE_PROV_DLL_NOT_FOUND           _HRESULT_TYPEDEF_(0x8009001EL)

//
// MessageId: NTE_BAD_KEYSET_PARAM
//
// MessageText:
//
//  The Keyset parameter is invalid.
//
#define NTE_BAD_KEYSET_PARAM             _HRESULT_TYPEDEF_(0x8009001FL)

//
// MessageId: NTE_FAIL
//
// MessageText:
//
//  An internal error occurred.
//
#define NTE_FAIL                         _HRESULT_TYPEDEF_(0x80090020L)

//
// MessageId: NTE_SYS_ERR
//
// MessageText:
//
//  A base error occurred.
//
#define NTE_SYS_ERR                      _HRESULT_TYPEDEF_(0x80090021L)

#define NTE_OP_OK 0

//
// Note that additional FACILITY_SSPI errors are in issperr.h
//
// ******************
// FACILITY_CERT
// ******************
//
// MessageId: TRUST_E_PROVIDER_UNKNOWN
//
// MessageText:
//
//  The specified trust provider is not known on this system.
//
#define TRUST_E_PROVIDER_UNKNOWN         _HRESULT_TYPEDEF_(0x800B0001L)

//
// MessageId: TRUST_E_ACTION_UNKNOWN
//
// MessageText:
//
//  The trust verification action specified is not supported by the specified trust provider.
//
#define TRUST_E_ACTION_UNKNOWN           _HRESULT_TYPEDEF_(0x800B0002L)

//
// MessageId: TRUST_E_SUBJECT_FORM_UNKNOWN
//
// MessageText:
//
//  The form specified for the subject is not one supported or known by the specified trust provider.
//
#define TRUST_E_SUBJECT_FORM_UNKNOWN     _HRESULT_TYPEDEF_(0x800B0003L)

//
// MessageId: TRUST_E_SUBJECT_NOT_TRUSTED
//
// MessageText:
//
//  The subject is not trusted for the specified action.
//
#define TRUST_E_SUBJECT_NOT_TRUSTED      _HRESULT_TYPEDEF_(0x800B0004L)

//
// MessageId: DIGSIG_E_ENCODE
//
// MessageText:
//
//  Error due to problem in ASN.1 encoding process.
//
#define DIGSIG_E_ENCODE                  _HRESULT_TYPEDEF_(0x800B0005L)

//
// MessageId: DIGSIG_E_DECODE
//
// MessageText:
//
//  Error due to problem in ASN.1 decoding process.
//
#define DIGSIG_E_DECODE                  _HRESULT_TYPEDEF_(0x800B0006L)

//
// MessageId: DIGSIG_E_EXTENSIBILITY
//
// MessageText:
//
//  Reading / writing Extensions where Attributes are appropriate, and visa versa.
//
#define DIGSIG_E_EXTENSIBILITY           _HRESULT_TYPEDEF_(0x800B0007L)

//
// MessageId: DIGSIG_E_CRYPTO
//
// MessageText:
//
//  Unspecified cryptographic failure.
//
#define DIGSIG_E_CRYPTO                  _HRESULT_TYPEDEF_(0x800B0008L)

//
// MessageId: PERSIST_E_SIZEDEFINITE
//
// MessageText:
//
//  The size of the data could not be determined.
//
#define PERSIST_E_SIZEDEFINITE           _HRESULT_TYPEDEF_(0x800B0009L)

//
// MessageId: PERSIST_E_SIZEINDEFINITE
//
// MessageText:
//
//  The size of the indefinite-sized data could not be determined.
//
#define PERSIST_E_SIZEINDEFINITE         _HRESULT_TYPEDEF_(0x800B000AL)

//
// MessageId: PERSIST_E_NOTSELFSIZING
//
// MessageText:
//
//  This object does not read and write self-sizing data.
//
#define PERSIST_E_NOTSELFSIZING          _HRESULT_TYPEDEF_(0x800B000BL)

//
// MessageId: TRUST_E_NOSIGNATURE
//
// MessageText:
//
//  No signature was present in the subject.
//
#define TRUST_E_NOSIGNATURE              _HRESULT_TYPEDEF_(0x800B0100L)

//
// MessageId: CERT_E_EXPIRED
//
// MessageText:
//
//  A required certificate is not within its validity period.
//
#define CERT_E_EXPIRED                   _HRESULT_TYPEDEF_(0x800B0101L)

//
// MessageId: CERT_E_VALIDIYPERIODNESTING
//
// MessageText:
//
//  The validity periods of the certification chain do not nest correctly.
//
#define CERT_E_VALIDIYPERIODNESTING      _HRESULT_TYPEDEF_(0x800B0102L)

//
// MessageId: CERT_E_ROLE
//
// MessageText:
//
//  A certificate that can only be used as an end-entity is being used as a CA or visa versa.
//
#define CERT_E_ROLE                      _HRESULT_TYPEDEF_(0x800B0103L)

//
// MessageId: CERT_E_PATHLENCONST
//
// MessageText:
//
//  A path length constraint in the certification chain has been violated.
//
#define CERT_E_PATHLENCONST              _HRESULT_TYPEDEF_(0x800B0104L)

//
// MessageId: CERT_E_CRITICAL
//
// MessageText:
//
//  An extension of unknown type that is labeled 'critical' is present in a certificate.
//
#define CERT_E_CRITICAL                  _HRESULT_TYPEDEF_(0x800B0105L)

//
// MessageId: CERT_E_PURPOSE
//
// MessageText:
//
//  A certificate is being used for a purpose other than that for which it is permitted.
//
#define CERT_E_PURPOSE                   _HRESULT_TYPEDEF_(0x800B0106L)

//
// MessageId: CERT_E_ISSUERCHAINING
//
// MessageText:
//
//  A parent of a given certificate in fact did not issue that child certificate.
//
#define CERT_E_ISSUERCHAINING            _HRESULT_TYPEDEF_(0x800B0107L)

//
// MessageId: CERT_E_MALFORMED
//
// MessageText:
//
//  A certificate is missing or has an empty value for an important field, such as a subject or issuer name.
//
#define CERT_E_MALFORMED                 _HRESULT_TYPEDEF_(0x800B0108L)

//
// MessageId: CERT_E_UNTRUSTEDROOT
//
// MessageText:
//
//  A certification chain processed correctly, but terminated in a root certificate which isn't trusted by the trust provider.
//
#define CERT_E_UNTRUSTEDROOT             _HRESULT_TYPEDEF_(0x800B0109L)

//
// MessageId: CERT_E_CHAINING
//
// MessageText:
//
//  A chain of certs didn't chain as they should in a certain application of chaining.
//
#define CERT_E_CHAINING                  _HRESULT_TYPEDEF_(0x800B010AL)

#endif // _WINERROR_
=== C:/Users/treeman/Desktop/windows nt source code\Source\Win2K3\NT\printscan\faxsrv\print\faxprint\faxdrv\win9x\utils\utils.h ===
/////////////////////////////////////////////////////////////////////////////
//  FILE          : utils.h                                                //
//                                                                         //
//  DESCRIPTION   : Define some common utilities.                          //
//                                                                         //
//  AUTHOR        : DanL.                                                  //
//                                                                         //
//  HISTORY       :                                                        //
//      Oct 19 1999 DannyL  Creation.                                      //
//                                                                         //
//  Copyright (C) 1999 Microsoft Corporation   All Rights Reserved         //
/////////////////////////////////////////////////////////////////////////////

#ifndef __UTILS__UTILS_H
#define __UTILS__UTILS_H

#include "string.h"

/*
 -  macro: SafeStringCopy
 -
 *  Purpose:
 *      Safely copy a source string to a fixed size destination buffer.
 *
 *  Arguments:
 *      dstStr - Destination string.
 *      srcStr - Source string.
 *
 *  Remarks:
 *      This macro calculates the size of a fixed size destination buffer,
 *      and ensures that it will not overflow when copying to it.
 *      An attempt to use this macro on a heap allocated buffer will result 
 *      in an assertion failure. In the latter case it is recommended to use
 *      StringCopy.
 */
#define SafeStringCopy(dstStr,srcStr) \
     StringCopy(dstStr,srcStr,dstStr?(sizeof(dstStr)/sizeof(dstStr[0]) - 1):0);

/*
 -  StringCopy
 -
 *  Purpose:
 *      Copy counted number of characters to a destination string.
 *
 *  Arguments:
 *      [in] dstStr - Destination buffer.
 *      [in] srcStr - Source buffer.
 *      [in] iSize - Number of chars to copy.
 *
 *  Returns:
 *      [N/A]
 *
 *  Remarks:
 *      [N/A]
 */
void _inline StringCopy(char* dstStr,const char* srcStr,int iSize)
{
    SDBG_PROC_ENTRY("StringCopy");
    ASSERT(dstStr && iSize > 0);
    *dstStr = 0;
    strncat(dstStr,srcStr,iSize);
    RETURN;
}

//////////////////////////////////////////////////////////////////////////////////////////
// Localization macros

/*
 -  macro: PROMPT
 -
 *  Purpose:
 *      Pop a message box with localized text.
 *
 *  Arguments:
 *      hwnd - Handle to parent window.
 *      idtext - Message box text resource id.
 *      idcapt - Message box caption resource id
 *      type - Message box type. (i.e. MB_ICONINFORMATION)
 *
 *  Remarks:
 *      This macro loads the resource strings, which id name's are of the form
 *      IDS_MB_XXX and IDS_MB_CAPTION_XXX where XXX represents the idtext and 
 *      idcapt respectively.
 */
#define PROMPT(hwnd,idtext,idcapt,type)\
        {\
            char szText[MAX_PATH]="";\
            char szCapt[MAX_PATH]="";\
            LoadString(g_hModule,IDS_MB_##idtext,szText,sizeof(szText));\
            LoadString(g_hModule,IDS_MB_CAPTION_##idcapt,szCapt,sizeof(szCapt));\
            MessageBox(hwnd,szText,szCapt,type);\
        }

/*
 -  macro: ERROR_PROMPT
 -
 *  Purpose:
 *      Pop a message box for unexpected error.
 *
 *  Arguments:
 *      hwnd - Handle to parent window.
 *      idtext - Message box text resource id.
 *
 *  Remarks:
 *      This macro is merely a simplified version of PROMPT for the sake of
 *      error notifications.
 */
#define ERROR_PROMPT(hwnd,idtext)    PROMPT(hwnd,idtext,ERROR,MB_ICONEXCLAMATION)

#endif //__UTILS__UTILS_H
=== C:/Users/treeman/Desktop/windows nt source code\Source\Win2K3\NT\printscan\faxsrv\print\faxprint\faxui\configprop.c ===
/*++

Copyright (c) 2001  Microsoft Corporation

Module Name:

    configprop.c

Abstract:

    Property sheet handler for "Configuration" page

Environment:

    Fax driver user interface

Revision History:

    30/08/01 -Ishai Nadler-
        Created it.

    mm/dd/yy -author-
        description

--*/

#include <stdio.h>
#include "faxui.h"
#include "resource.h" 


INT_PTR 
CALLBACK 
ConfigOptionDlgProc(
    HWND hDlg,  
    UINT uMsg,     
    WPARAM wParam, 
    LPARAM lParam  
)

/*++

Routine Description:

    Procedure for handling the "Fax Configuration option" tab

Arguments:

    hDlg - Identifies the property sheet page
    uMsg - Specifies the message
    wParam - Specifies additional message-specific information
    lParam - Specifies additional message-specific information

Return Value:

    Depends on the value of message parameter

--*/

{
    switch (uMsg)
    {
    case WM_INITDIALOG :
        return TRUE;
	case WM_NOTIFY :
		{
        LPNMHDR lpnm = (LPNMHDR) lParam;
        switch (lpnm->code)
		{
		case NM_CLICK:
		case NM_RETURN:
			if( IDC_CONFIG_FAX_LINK == lpnm->idFrom )
			{
				InvokeServiceManager(hDlg, g_hResource, IDS_ADMIN_CONSOLE_TITLE);
            }
            break;
		default:
			break;
		}//end of switch(lpnm->code)

		}
	}//end of switch(uMsg)

    return FALSE;
} // ConfigOptionDlgProc
=== C:/Users/treeman/Desktop/windows nt source code\Source\Win2K3\NT\printscan\faxsrv\print\faxprint\faxui\devcaps.c ===
/*++

Copyright (c) 1996  Microsoft Corporation

Module Name:

    devcaps.c

Abstract:

    Implementation of DrvDeviceCapabilities

Environment:

    Fax driver user interface

Revision History:

    01/09/96 -davidx-
        Created it.

    mm/dd/yy -author-
        description

--*/

#include "faxui.h"
#include "forms.h"

//
// Forward declaration for local functions
//

DWORD
CalcMinMaxExtent(
    PPOINTS      pOutput,
    FORM_INFO_1 *pFormsDB,
    DWORD       cForms,
    INT         wCapability
    );

DWORD
EnumResolutions(
    PLONG       pResolutions
    );


DWORD
DrvDeviceCapabilities(
    HANDLE      hPrinter,
    LPTSTR      pDeviceName,
    WORD        wCapability,
    PVOID       pOutput,
    PDEVMODE    pdm
    )

/*++

Routine Description:

    Provides information about the specified device and its capabilities

Arguments:

    hPrinter - Identifies a printer object
    pDeviceName - Points to a null-terminated device name string
    wCapability - Specifies the interested device capability
    pOutput - Points to the output buffer
    pdm - Points to the source devmode structure

Return Value:

    The return value depends on wCapability.

Note:

    Please refer for DDK documentation for more details.

--*/

{
    FORM_INFO_1 *pFormsDB=NULL;
    DWORD       cForms;
    DWORD       result = 0;
    DRVDEVMODE  dmCombinedDevMode;

    Verbose(("Entering DrvDeviceCapabilities: %d %x...\n", wCapability, pOutput));

    //
    // Do not execute any code before this initialization
    //
    if(!InitializeDll())
    {
        return GDI_ERROR;
    }

    //
    // Validate input devmode and combine it with driver default
    //
    ZeroMemory(&dmCombinedDevMode,sizeof(dmCombinedDevMode));
    GetCombinedDevmode(&dmCombinedDevMode, pdm, hPrinter, NULL, FALSE);

    result = 0;

    //
    // Return appropriate information depending upon wCapability
    //

    switch (wCapability) {

    case DC_VERSION:

        result = dmCombinedDevMode.dmPublic.dmSpecVersion;
        break;

    case DC_DRIVER:

        result = dmCombinedDevMode.dmPublic.dmDriverVersion;
        break;

    case DC_SIZE:

        result = dmCombinedDevMode.dmPublic.dmSize;
        break;

    case DC_EXTRA:

        result = dmCombinedDevMode.dmPublic.dmDriverExtra;
        break;

    case DC_FIELDS:

        result = dmCombinedDevMode.dmPublic.dmFields;
        break;

    case DC_COPIES:

        result = 1;
        break;

    case DC_ORIENTATION:

        //
        // Landscape rotates counterclockwise
        //

        result = 90;
        break;

    case DC_PAPERNAMES:
    case DC_PAPERS:
    case DC_PAPERSIZE:
    case DC_MINEXTENT:
    case DC_MAXEXTENT:

        //
        // Get a list of forms in the forms database
        //

        pFormsDB = GetFormsDatabase(hPrinter, &cForms);

        if (pFormsDB == NULL || cForms == 0) {

            Error(("Cannot get system forms\n"));
            return GDI_ERROR;
        }

		if (DC_MINEXTENT == wCapability ||
			DC_MAXEXTENT == wCapability)
		{			
			DWORD dwCount = CalcMinMaxExtent((PPOINTS)&result, pFormsDB, cForms, wCapability);
			if (0 == dwCount)
			{
				result = GDI_ERROR;
			}			
		}
		else
		{
			result = EnumPaperSizes(pOutput, pFormsDB, cForms, wCapability);
		}       

        MemFree(pFormsDB);
        break;

    case DC_BINNAMES:

        //
        // Simulate a single input slot
        //

        if (pOutput)
            LoadString(g_hResource, IDS_SLOT_ONLYONE, pOutput, CCHBINNAME);
        result = 1;
        break;

    case DC_BINS:

        if (pOutput)
            *((PWORD) pOutput) = DMBIN_ONLYONE;
        result = 1;
        break;

    case DC_ENUMRESOLUTIONS:

        result = EnumResolutions(pOutput);
        break;

    default:

        Error(("Unknown device capability: %d\n", wCapability));
        result = GDI_ERROR;
        break;
    }

    return result;
}



DWORD
EnumPaperSizes(
    PVOID       pOutput,
    FORM_INFO_1 *pFormsDB,
    DWORD       cForms,
    INT         wCapability
    )

/*++

Routine Description:

    Retrieves a list of supported paper sizes

Arguments:

    pOutput - Specifies a buffer for storing requested information
    pFormsDB - Pointer to an array of forms from the forms database
    cForms - Number of forms in the array
    wCapability - Specifies what the caller is interested in

Return Value:

    Number of paper sizes supported

--*/

{
    DWORD   index, count = 0;
    LPTSTR  pPaperNames = NULL;
    PWORD   pPapers = NULL;
    PPOINT  pPaperSizes = NULL;

    //
    // Figure out what the caller is interested in
    //

    switch (wCapability) {

    case DC_PAPERNAMES:
        pPaperNames = pOutput;
        break;

    case DC_PAPERSIZE:
        pPaperSizes = pOutput;
        break;

    case DC_PAPERS:
        pPapers = pOutput;
        break;

    default:
        Assert(FALSE);
    }

    //
    // Go through each form in the forms database
    //

    for (index=0; index < cForms; index++, pFormsDB++) {

        //
        // If the form is supported on the printer, then increment the count
        // and collect requested information
        //

        if (! IsSupportedForm(pFormsDB))
            continue;

        count++;

        //
        // Return the size of the form in 0.1mm units.
        // The unit used in FORM_INFO_1 is 0.001mm.
        //

        if (pPaperSizes) {

            pPaperSizes->x = pFormsDB->Size.cx / 100;
            pPaperSizes->y = pFormsDB->Size.cy / 100;
            pPaperSizes++;
        }

        //
        // Return the formname.
        //

        if (pPaperNames) {

            CopyString(pPaperNames, pFormsDB->pName, CCHPAPERNAME);
            pPaperNames += CCHPAPERNAME;
        }

        //
        // Return one-based index of the form.
        //

        if (pPapers)
            *pPapers++ = (WORD) index + DMPAPER_FIRST;
    }

    return count;
}



DWORD
CalcMinMaxExtent(
    PPOINTS      pOutput,
    FORM_INFO_1 *pFormsDB,
    DWORD       cForms,
    INT         wCapability
    )

/*++

Routine Description:

    Retrieves the minimum or maximum paper size extent

Arguments:

    pOutput - pointer to a POINTS structure
    pFormsDB - Pointer to an array of forms from the forms database
    cForms - Number of forms in the array
    wCapability - What the caller is interested in: DC_MAXEXTENT or DC_MINEXTENT

Return Value:

    Number of paper sizes supported

--*/

{
    DWORD   index, count = 0;
    LONG    minX, minY, maxX, maxY;
	Assert (pOutput);

    //
    // Go through each form in the forms database
    //

    minX = minY = MAX_LONG;
    maxX = maxY = 0;

    for (index=0; index < cForms; index++, pFormsDB++) {

        //
        // If the form is supported on the printer, then increment the count
        // and collect the requested information
        //

        if (! IsSupportedForm(pFormsDB))
		{
            continue;
		}

        count++;      

        if (minX > pFormsDB->Size.cx)
		{
            minX = pFormsDB->Size.cx;
		}

        if (minY > pFormsDB->Size.cy)
		{
            minY = pFormsDB->Size.cy;
		}

        if (maxX < pFormsDB->Size.cx)
		{
            maxX = pFormsDB->Size.cx;
		}

        if (maxY < pFormsDB->Size.cy)
		{
			maxY = pFormsDB->Size.cy;
		}
    }  

    //
    // NOTE: What unit does the caller expect?! The documentation
    // doesn't mention anything about this. I assume this should
    // be in the same unit as DEVMODE.dmPaperLength, which is 0.1mm.
    //
    if (wCapability == DC_MINEXTENT)
	{
        pOutput->x = (SHORT)(minX / 100);
        pOutput->y = (SHORT)(minY / 100);
    }
	else
	{
        pOutput->x = (SHORT)(maxX / 100);
        pOutput->y = (SHORT)(maxY / 100);
    }  
    return count;
}



DWORD
EnumResolutions(
    PLONG       pResolutions
    )

/*++

Routine Description:

    Retrieves a list of supported resolutions

Arguments:

    pResolutions - Specifies a buffer for storing resolution information

Return Value:

    Number of resolutions supported

Note:

    Each resolution is represented by two LONGs representing
    horizontal and vertical resolutions (in dpi) respectively.

--*/

{
    if (pResolutions != NULL) {

        //
        // We support the following resolution settings:
        //  Normal = 200x200 dpi
        //  Draft = 200x100 dpi
        //

        *pResolutions++ = FAXRES_HORIZONTAL;
        *pResolutions++ = FAXRES_VERTICAL;

        *pResolutions++ = FAXRES_HORIZONTAL;
        *pResolutions++ = FAXRES_VERTDRAFT;
    }

    return 2;
}
=== C:/Users/treeman/Desktop/windows nt source code\Source\Win2K3\NT\printscan\faxsrv\print\faxprint\faxui\devprop.c ===
/*++

Copyright (c) 1996  Microsoft Corporation

Module Name:

    devinfo.c

Abstract:

    Property sheet handler for "Device" page 

Environment:

    Fax driver user interface

Revision History:

    04/09/00 -taoyuan-
        Created it.

    mm/dd/yy -author-
        description

--*/

#include <stdio.h>
#include "faxui.h"
#include "resource.h"
#include "faxuiconstants.h"

//
// List of controls displayes for desktop SKUs only
//
DWORD 
g_dwDesktopControls[] =
{
    IDC_BRANDING_CHECK,         
    IDC_RETRIES_STATIC,         
    IDC_RETRIES_EDIT,           
    IDC_RETRIES_SPIN,           
    IDC_OUTB_RETRYDELAY_STATIC, 
    IDC_RETRYDELAY_EDIT,        
    IDC_RETRYDELAY_SPIN,           
    IDC_OUTB_MINUTES_STATIC,       
    IDC_OUTB_DIS_START_STATIC,     
    IDC_DISCOUNT_START_TIME,       
    IDC_OUTB_DIS_STOP_STATIC,      
    IDC_DISCOUNT_STOP_TIME,
    0
};

static BOOL
SaveSendChanges(IN HWND hDlg);

PPRINTER_NAMES      g_pPrinterNames = NULL;
DWORD               g_dwNumPrinters = 0;


BOOL
ValidateSend(
    HWND  hDlg
)
/*++

Routine Description:

    Validate the check box and controls for send

Arguments:

    hDlg - Handle to the property sheet page

Return Value:

    TRUE -- if no error
    FALSE -- if error

--*/

{
    BOOL bEnabled;

    if(g_bUserCanChangeSettings) 
    {
        bEnabled = IsDlgButtonChecked(hDlg, IDC_DEVICE_PROP_SEND) == BST_CHECKED;

        //
        // Enable/disable controls according to "Enable Send" check box
        //
        PageEnable(hDlg, bEnabled);

        if(!bEnabled)
        {
            //
            // Enable "Enable Send" check box
            //
            EnableWindow(GetDlgItem(hDlg, IDC_DEVICE_PROP_SEND),    TRUE);
            SetFocus(GetDlgItem(hDlg, IDC_DEVICE_PROP_SEND));

            EnableWindow(GetDlgItem(hDlg, IDC_STATIC_SEND_ICON),    TRUE);
            EnableWindow(GetDlgItem(hDlg, IDC_STATIC_SEND_OPTIONS), TRUE);
            ShowWindow (GetDlgItem(hDlg, IDC_ICON_STORE_IN_FOLDER), SW_HIDE);
            ShowWindow (GetDlgItem(hDlg, IDC_STATIC_STORE_IN_FOLDER), SW_HIDE);
        }
        else
        {
            ShowWindow (GetDlgItem(hDlg, IDC_ICON_STORE_IN_FOLDER), SW_SHOW);
            ShowWindow (GetDlgItem(hDlg, IDC_STATIC_STORE_IN_FOLDER), SW_SHOW);
        }
    }
    else
    {
        PageEnable(hDlg, FALSE);
        ShowWindow (GetDlgItem(hDlg, IDC_ICON_STORE_IN_FOLDER), SW_HIDE);
        ShowWindow (GetDlgItem(hDlg, IDC_STATIC_STORE_IN_FOLDER), SW_HIDE);
    }

    return TRUE;
}

INT_PTR 
CALLBACK
DevSendDlgProc(
    IN HWND hDlg,
    IN UINT message,
    IN WPARAM wParam,
    IN LPARAM lParam 
    )
/*++

Routine Description:

    Dialog procedure for send settings

Arguments:

    hDlg - Identifies the property sheet page
    message - Specifies the message
    wParam - Specifies additional message-specific information
    lParam - Specifies additional message-specific information

Return Value:

    Depending on specific message

--*/
{
    BOOL                fRet = FALSE;
    PFAX_PORT_INFO_EX   pFaxPortInfo = NULL;    // receive port information 
    DWORD               dwDeviceId;

    switch( message ) 
    {
        case WM_INITDIALOG:
        {
            SYSTEMTIME  sTime = {0};
            PFAX_OUTBOX_CONFIG  pOutboxConfig = NULL;
            TCHAR       tszSecondsFreeTimeFormat[MAX_PATH];
            //
            //Get the shared data from PROPSHEETPAGE lParam value
            //and load it into GWL_USERDATA
            //
            dwDeviceId = (DWORD)((LPPROPSHEETPAGE)lParam)->lParam; 

            SetWindowLongPtr(hDlg, GWLP_USERDATA, (LONG_PTR)dwDeviceId);

            SendDlgItemMessage(hDlg, IDC_DEVICE_PROP_TSID, EM_SETLIMITTEXT, TSID_LIMIT, 0);

            pFaxPortInfo = FindPortInfo(dwDeviceId);
            if(!pFaxPortInfo)
            {
                Error(("FindPortInfo() failed.\n"));
                Assert(FALSE);
                fRet = TRUE;
                break;
            }

            CheckDlgButton(hDlg, IDC_DEVICE_PROP_SEND, pFaxPortInfo->bSend ? BST_CHECKED : BST_UNCHECKED);

            SetDlgItemText(hDlg, IDC_DEVICE_PROP_TSID, pFaxPortInfo->lptstrTsid);

            if(!IsDesktopSKU())
            {
                //
                // Hide desktop controls for non desktop platform
                //
                DWORD dw;
                for(dw=0; g_dwDesktopControls[dw] != 0; ++dw)
                {
                    ShowWindow(GetDlgItem(hDlg, g_dwDesktopControls[dw]), SW_HIDE);
                }
                goto InitDlgExit;
            }
            
            //
            // Update desktop controls
            //
            if(!Connect(hDlg, TRUE))
            {
                goto InitDlgExit;
            }

            if(!FaxGetOutboxConfiguration(g_hFaxSvcHandle, &pOutboxConfig))
            {
                Error(( "FaxGetOutboxConfiguration() failed with %d.\n", GetLastError()));
                goto InitDlgExit;
            }

            //
            // Branding
            //            
            CheckDlgButton(hDlg, IDC_BRANDING_CHECK, pOutboxConfig->bBranding ? BST_CHECKED : BST_UNCHECKED);
            //
            // Retries
            //
            SendDlgItemMessage(hDlg, IDC_RETRIES_EDIT, EM_SETLIMITTEXT, FXS_RETRIES_LENGTH, 0);

#if FXS_RETRIES_LOWER > 0
            if (pOutboxConfig->dwRetries < FXS_RETRIES_LOWER)
            {
                pOutboxConfig->dwRetries = FXS_RETRIES_LOWER;
            }
#endif
            if (pOutboxConfig->dwRetries > FXS_RETRIES_UPPER)
            {
                pOutboxConfig->dwRetries = FXS_RETRIES_UPPER;
            }
            SendDlgItemMessage(hDlg, IDC_RETRIES_SPIN, UDM_SETRANGE32, FXS_RETRIES_LOWER, FXS_RETRIES_UPPER);
            SendDlgItemMessage(hDlg, IDC_RETRIES_SPIN, UDM_SETPOS32, 0, (LPARAM)pOutboxConfig->dwRetries);

            SetDlgItemInt(hDlg, IDC_RETRIES_EDIT, pOutboxConfig->dwRetries, FALSE);
            //
            // Retry Delay
            //
            SendDlgItemMessage(hDlg, IDC_RETRYDELAY_EDIT, EM_SETLIMITTEXT, FXS_RETRYDELAY_LENGTH, 0);

#if FXS_RETRYDELAY_LOWER > 0
            if (pOutboxConfig->dwRetryDelay < FXS_RETRYDELAY_LOWER)
            {
                pOutboxConfig->dwRetryDelay = FXS_RETRYDELAY_LOWER;
            }
#endif
            if (pOutboxConfig->dwRetryDelay > FXS_RETRYDELAY_UPPER)
            {
                pOutboxConfig->dwRetryDelay = FXS_RETRYDELAY_UPPER;
            }
            SendDlgItemMessage(hDlg, IDC_RETRYDELAY_SPIN, UDM_SETRANGE32, FXS_RETRYDELAY_LOWER, FXS_RETRYDELAY_UPPER);
            SendDlgItemMessage(hDlg, IDC_RETRYDELAY_SPIN, UDM_SETPOS32, 0, (LPARAM)pOutboxConfig->dwRetryDelay);

            SetDlgItemInt(hDlg, IDC_RETRYDELAY_EDIT, pOutboxConfig->dwRetryDelay, FALSE);

            //
            // Discount rate start time
            //
            GetSecondsFreeTimeFormat(tszSecondsFreeTimeFormat, MAX_PATH);

            GetLocalTime(&sTime);

            sTime.wHour   = pOutboxConfig->dtDiscountStart.Hour;
            sTime.wMinute = pOutboxConfig->dtDiscountStart.Minute;

            SendDlgItemMessage(hDlg, IDC_DISCOUNT_START_TIME, DTM_SETFORMAT, 0, (LPARAM)tszSecondsFreeTimeFormat);
            SendDlgItemMessage(hDlg, IDC_DISCOUNT_START_TIME, DTM_SETSYSTEMTIME, (WPARAM)GDT_VALID, (LPARAM)&sTime);

            //
            // Discount rate stop time
            //
            sTime.wHour   = pOutboxConfig->dtDiscountEnd.Hour;
            sTime.wMinute = pOutboxConfig->dtDiscountEnd.Minute;

            SendDlgItemMessage(hDlg, IDC_DISCOUNT_STOP_TIME, DTM_SETFORMAT, 0, (LPARAM)tszSecondsFreeTimeFormat);
            SendDlgItemMessage(hDlg, IDC_DISCOUNT_STOP_TIME, DTM_SETSYSTEMTIME, (WPARAM)GDT_VALID, (LPARAM)&sTime);

            FaxFreeBuffer(pOutboxConfig);

InitDlgExit:
            ValidateSend(hDlg);
            fRet = TRUE;
            break;
        }

        case WM_COMMAND:
            {
                // activate apply button        

                WORD wID = LOWORD( wParam );

                switch( wID ) 
                {
                    case IDC_DEVICE_PROP_TSID:
                    case IDC_RETRIES_EDIT:
                    case IDC_RETRYDELAY_EDIT:
                    case IDC_DISCOUNT_START_TIME:
                    case IDC_DISCOUNT_STOP_TIME:
                        if( HIWORD(wParam) == EN_CHANGE ) 
                        {     // notification code 
                            Notify_Change(hDlg);
                        }

                        fRet = TRUE;
                        break;                    

                    case IDC_DEVICE_PROP_SEND:                    

                        if ( HIWORD(wParam) == BN_CLICKED ) 
                        {   
                            if(IsDlgButtonChecked(hDlg, IDC_DEVICE_PROP_SEND) == BST_CHECKED)
                            {
                                dwDeviceId = (DWORD)GetWindowLongPtr(hDlg, GWLP_USERDATA);
                                if(!IsDeviceInUse(dwDeviceId) &&
                                   GetDeviceLimit() == CountUsedFaxDevices())
                                {
                                    CheckDlgButton(hDlg, IDC_DEVICE_PROP_SEND, BST_UNCHECKED);

                                    DisplayErrorMessage(hDlg, 
                                        MB_OK | MB_ICONSTOP,
                                        FAXUI_ERROR_DEVICE_LIMIT,
                                        GetDeviceLimit());
                                    fRet = TRUE;
                                    break;
                                }
                            }

                            // notification code
                            ValidateSend(hDlg);
                            Notify_Change(hDlg);
                        }
                        
                        fRet = TRUE;
                        break;

                    default:
                        break;
                } // switch

                break;
            }

        case WM_NOTIFY:
        {
            switch( ((LPNMHDR) lParam)->code ) 
            {
                case PSN_APPLY:
                    SaveSendChanges(hDlg);
                    fRet = TRUE;
                    break;

                case DTN_DATETIMECHANGE:    // Date/time picker has changed
                    Notify_Change(hDlg);
                    fRet = TRUE;
                    break;

                default:
                    break;
            }
            break;
        }

    case WM_HELP:
        WinHelpContextPopup(((LPHELPINFO)lParam)->dwContextId, hDlg);
        return TRUE;

    } // switch

    return fRet;
}

BOOL
ValidateReceive(
    HWND   hDlg
)
/*++

Routine Description:

    Validate the check box and controls for receive

Arguments:

    hDlg - Handle to the property sheet page

Return Value:

    TRUE -- if no error
    FALSE -- if error

--*/

{
    BOOL    bEnabled; // enable/disable controls
    BOOL    bManualAnswer;
    BOOL    bVirtual;   // Is the device virtual?

    // if g_bUserCanChangeSettings is FALSE, controls are disabled by default.
    if(g_bUserCanChangeSettings) 
    {
        DWORD dwDeviceId;
        DWORD dwRes;

        dwDeviceId = (DWORD)GetWindowLongPtr(hDlg, GWLP_USERDATA);
        Assert (dwDeviceId);

        if(!Connect(hDlg, TRUE))
        {
            return FALSE;
        }

        dwRes = IsDeviceVirtual (g_hFaxSvcHandle, dwDeviceId, &bVirtual);
        if (ERROR_SUCCESS != dwRes)
        {
            return FALSE;
        }
        DisConnect ();
        bEnabled = IsDlgButtonChecked(hDlg, IDC_DEVICE_PROP_RECEIVE) == BST_CHECKED;

        if(bEnabled && 
           IsDlgButtonChecked(hDlg, IDC_DEVICE_PROP_AUTO_ANSWER)   != BST_CHECKED &&
           IsDlgButtonChecked(hDlg, IDC_DEVICE_PROP_MANUAL_ANSWER) != BST_CHECKED)
        {
            //
            // Set default to auto answer
            //
            CheckDlgButton(hDlg, IDC_DEVICE_PROP_AUTO_ANSWER, BST_CHECKED);
        }

        EnableWindow(GetDlgItem(hDlg, IDC_DEVICE_PROP_CSID),          bEnabled);
        EnableWindow(GetDlgItem(hDlg, IDC_DEVICE_PROP_MANUAL_ANSWER), bEnabled && !bVirtual);
        EnableWindow(GetDlgItem(hDlg, IDC_DEVICE_PROP_AUTO_ANSWER),   bEnabled);
        EnableWindow(GetDlgItem(hDlg, IDC_STATIC_RINGS1),             bEnabled);

        EnableWindow(GetDlgItem(hDlg, IDC_STATIC_CSID1),      bEnabled);
        EnableWindow(GetDlgItem(hDlg, IDC_STATIC_CSID),       bEnabled);
        EnableWindow(GetDlgItem(hDlg, IDCSTATIC_ANSWER_MODE), bEnabled);
        EnableWindow(GetDlgItem(hDlg, IDC_STATIC_ROUTE),      bEnabled);

        EnableWindow(GetDlgItem(hDlg, IDCSTATIC_AUTO_ANSWER), bEnabled);

        bManualAnswer = IsDlgButtonChecked(hDlg, IDC_DEVICE_PROP_MANUAL_ANSWER);
        Assert (!(bVirtual && bManualAnswer));

        EnableWindow(GetDlgItem(hDlg, IDC_DEVICE_PROP_RINGS),      bEnabled && !bManualAnswer && !bVirtual);
        EnableWindow(GetDlgItem(hDlg, IDC_DEVICE_PROP_SPIN_RINGS), bEnabled && !bManualAnswer && !bVirtual);
        if (bVirtual)
        {
            //
            // Virtual devices always answer after one ring
            //
            SetDlgItemInt (hDlg, IDC_DEVICE_PROP_RINGS, 1, FALSE);
        }

        EnableWindow(GetDlgItem(hDlg, IDC_DEVICE_PROP_PRINT),    bEnabled);

        EnableWindow(GetDlgItem(hDlg, IDC_DEVICE_PROP_PRINT_TO), bEnabled
                                   && IsDlgButtonChecked(hDlg, IDC_DEVICE_PROP_PRINT));

        EnableWindow(GetDlgItem(hDlg, IDC_DEVICE_PROP_SAVE),        bEnabled);

        EnableWindow(GetDlgItem(hDlg, IDC_DEVICE_PROP_DEST_FOLDER), bEnabled 
                                   && IsDlgButtonChecked(hDlg, IDC_DEVICE_PROP_SAVE));

        EnableWindow(GetDlgItem(hDlg, IDC_DEVICE_PROP_DEST_FOLDER_BR), bEnabled
                                   && IsDlgButtonChecked(hDlg, IDC_DEVICE_PROP_SAVE));

        EnableWindow(GetDlgItem(hDlg, IDC_ICON_STORE_IN_FOLDER),   bEnabled);
        EnableWindow(GetDlgItem(hDlg, IDC_STATIC_STORE_IN_FOLDER), bEnabled);
        ShowWindow (GetDlgItem(hDlg, IDC_ICON_STORE_IN_FOLDER), bEnabled ? SW_SHOW : SW_HIDE);
        ShowWindow (GetDlgItem(hDlg, IDC_STATIC_STORE_IN_FOLDER), bEnabled ? SW_SHOW : SW_HIDE);
    }
    else
    {
        PageEnable(hDlg, FALSE);
        ShowWindow (GetDlgItem(hDlg, IDC_ICON_STORE_IN_FOLDER), SW_HIDE);
        ShowWindow (GetDlgItem(hDlg, IDC_STATIC_STORE_IN_FOLDER), SW_HIDE);
    }

    return TRUE;
}

BOOL
InitReceiveInfo(
    HWND    hDlg
    )
/*++

Routine Description:

    Initialize the routing information for specific device

Arguments:

    hDlg - the dialog handle of the dialog

Return Value:

    TRUE if success, FALSE otherwise

--*/
{
    DWORD               dwDeviceId;
    HWND                hControl;
    PFAX_PORT_INFO_EX   pFaxPortInfo;
    LPBYTE              pRoutingInfoBuffer;
    DWORD               dwRoutingInfoBufferSize;
    DWORD               dwCurrentRM;
    BOOL                bSuccessed = TRUE;

    Verbose(("Entering InitReceiveInfo...\n"));

    //
    // Get device id from dialog page
    //

    dwDeviceId = (DWORD)GetWindowLongPtr(hDlg, GWLP_USERDATA);

    pFaxPortInfo = FindPortInfo(dwDeviceId);
    if(!pFaxPortInfo)
    {
        Error(("FindPortInfo() failed.\n"));
        Assert(FALSE);
        return FALSE;
    }

    // set up the check box
    EnableWindow(GetDlgItem(hDlg, IDC_DEVICE_PROP_RECEIVE), g_bUserCanChangeSettings);

    CheckDlgButton(hDlg, IDC_DEVICE_PROP_RECEIVE, pFaxPortInfo->ReceiveMode != FAX_DEVICE_RECEIVE_MODE_OFF);

    // set up the CSID control
    SetDlgItemText(hDlg, IDC_DEVICE_PROP_CSID, pFaxPortInfo->lptstrCsid);

    // setup the ring count spinner control
    hControl = GetDlgItem(hDlg, IDC_DEVICE_PROP_SPIN_RINGS); 

    if(MIN_RING_COUNT <= pFaxPortInfo->dwRings && pFaxPortInfo->dwRings <= MAX_RING_COUNT)
    {
        SetDlgItemInt(hDlg, IDC_DEVICE_PROP_RINGS, pFaxPortInfo->dwRings, FALSE);
        SendMessage( hControl, UDM_SETPOS32, 0, (LPARAM) MAKELONG(pFaxPortInfo->dwRings, 0) );        
    }
    else
    {
        SetDlgItemInt(hDlg, IDC_DEVICE_PROP_RINGS, DEFAULT_RING_COUNT, FALSE);
        SendMessage( hControl, UDM_SETPOS32, 0, (LPARAM) MAKELONG(DEFAULT_RING_COUNT, 0) );        
    }

    //
    // Answer mode
    //
    if (FAX_DEVICE_RECEIVE_MODE_MANUAL == pFaxPortInfo->ReceiveMode)
    {
        CheckDlgButton(hDlg, IDC_DEVICE_PROP_MANUAL_ANSWER, TRUE);
    }
    else if (FAX_DEVICE_RECEIVE_MODE_AUTO == pFaxPortInfo->ReceiveMode)
    {
        CheckDlgButton(hDlg, IDC_DEVICE_PROP_AUTO_ANSWER, TRUE);
    }

    //
    // Get the routing info
    //
    if(!Connect(hDlg, TRUE))
    {
        return FALSE;
    }

    for (dwCurrentRM = 0; dwCurrentRM < RM_COUNT; dwCurrentRM++) 
    {
        BOOL Enabled;

        Enabled = FaxDeviceEnableRoutingMethod( g_hFaxSvcHandle, 
                                                dwDeviceId, 
                                                RoutingGuids[dwCurrentRM], 
                                                QUERY_STATUS );
        //
        // Show routing extension data 
        //
        pRoutingInfoBuffer = NULL;
        if(!FaxGetExtensionData(g_hFaxSvcHandle, 
                                dwDeviceId, 
                                RoutingGuids[dwCurrentRM], 
                                &pRoutingInfoBuffer, 
                                &dwRoutingInfoBufferSize))
        {
            Error(("FaxGetExtensionData failed with %ld.\n", GetLastError()));
            pRoutingInfoBuffer = NULL;
        }

        switch (dwCurrentRM) 
        {
            case RM_FOLDER:

                CheckDlgButton( hDlg, IDC_DEVICE_PROP_SAVE, Enabled ? BST_CHECKED : BST_UNCHECKED );

                // enable controls if the user has "modify" permission
                if(g_bUserCanChangeSettings)
                {
                    EnableWindow( GetDlgItem( hDlg, IDC_DEVICE_PROP_DEST_FOLDER ), Enabled );
                    EnableWindow( GetDlgItem( hDlg, IDC_DEVICE_PROP_DEST_FOLDER_BR ), Enabled );
                }
                if (pRoutingInfoBuffer && *pRoutingInfoBuffer)
                {
                    SetDlgItemText( hDlg, IDC_DEVICE_PROP_DEST_FOLDER, (LPCTSTR)pRoutingInfoBuffer );
                }
                break;

            case RM_PRINT:

                hControl = GetDlgItem( hDlg, IDC_DEVICE_PROP_PRINT_TO );

                //
                // Now find out if we match the data the server has
                //
                if (pRoutingInfoBuffer && lstrlen((LPWSTR)pRoutingInfoBuffer))
                {
                    //
                    // Server has some name for printer
                    //
                    LPCWSTR lpcwstrMatchingText = FindPrinterNameFromPath (g_pPrinterNames, g_dwNumPrinters, (LPWSTR)pRoutingInfoBuffer);
                    if (!lpcwstrMatchingText)
                    {
                        //
                        // No match, just fill in the text we got from the server
                        //
                        SendMessage(hControl, CB_SETCURSEL, -1, 0);
                        SetWindowText(hControl, (LPWSTR)pRoutingInfoBuffer);
                    }
                    else
                    {
                        SendMessage(hControl, CB_SELECTSTRING, -1, (LPARAM) lpcwstrMatchingText);
                    }
                }
                else
                {
                    //
                    // No server configuation - Select nothing
                    //
                }

                CheckDlgButton( hDlg, IDC_DEVICE_PROP_PRINT, Enabled ? BST_CHECKED : BST_UNCHECKED );                
                //
                // Enable controls if the user has "modify" permission
                //
                if(g_bUserCanChangeSettings)
                {
                    EnableWindow(GetDlgItem(hDlg, IDC_DEVICE_PROP_PRINT), TRUE);
                    EnableWindow(hControl, Enabled);
                }
                break;
        }
        if (pRoutingInfoBuffer)
        {
            FaxFreeBuffer(pRoutingInfoBuffer);
        }
    }

    DisConnect();

    return bSuccessed;
}

BOOL
SaveReceiveInfo(
    HWND    hDlg
)

/*++

Routine Description:

    Save the receive routing info to the system

Arguments:

    hDlg - Identifies the property sheet page

Return Value:

    TRUE if successful, FALSE if failed 

--*/

{
    DWORD               dwDeviceId;
    PFAX_PORT_INFO_EX   pFaxPortInfo = NULL;
    DWORD               dwCurrentRM;
    BOOL                bSuccessed = TRUE;
    HWND                hControl;
    TCHAR               szCsid[CSID_LIMIT + 1] = {0};
    BYTE                pRouteInfo[RM_COUNT][INFO_SIZE] = {0};
    LPTSTR              lpCurSel; 
    LPDWORD             Enabled; 
    DWORD               dwRingCount = 0; // default value is an invalid value
    DWORD               dwRes = 0;

    Verbose(("Entering SaveReceiveInfo...\n"));

    // 
    // check the validity of ring count
    //
    dwRingCount = GetDlgItemInt(hDlg, IDC_DEVICE_PROP_RINGS, &bSuccessed, FALSE);
    if( dwRingCount < MIN_RING_COUNT || dwRingCount > MAX_RING_COUNT )
    {
        hControl = GetDlgItem(hDlg, IDC_DEVICE_PROP_RINGS);
        DisplayErrorMessage(hDlg, 0, FAXUI_ERROR_INVALID_RING_COUNT, MIN_RING_COUNT, MAX_RING_COUNT);
        SendMessage(hControl, EM_SETSEL, 0, -1);
        SetFocus(hControl);
        SetActiveWindow(hControl);
        bSuccessed = FALSE;
        goto Exit;
    }

    // 
    // Check the validity first in the loop, 
    // then save the routing info
    //
    for (dwCurrentRM = 0; dwCurrentRM < RM_COUNT; dwCurrentRM++) 
    {
        // initialize
        lpCurSel = (LPTSTR)(pRouteInfo[dwCurrentRM] + sizeof(DWORD));
        Enabled = (LPDWORD) pRouteInfo[dwCurrentRM];
        *Enabled = 0;

        switch (dwCurrentRM) 
        {
            case RM_PRINT:

                *Enabled = (IsDlgButtonChecked( hDlg, IDC_DEVICE_PROP_PRINT ) == BST_CHECKED);
                lpCurSel[0] = TEXT('\0');
                //
                // Just read-in the selected printer display name
                //
                GetDlgItemText (hDlg, IDC_DEVICE_PROP_PRINT_TO, lpCurSel, MAX_PATH);
                hControl = GetDlgItem(hDlg, IDC_DEVICE_PROP_PRINT_TO);
                //
                // we will check the validity only when this routing method is enabled
                // but we will save the select change anyway.
                //
                if (*Enabled) 
                {
                    if (lpCurSel[0] == 0) 
                    {
                        DisplayErrorMessage(hDlg, 0, FAXUI_ERROR_SELECT_PRINTER);
                        SetFocus(hControl);
                        SetActiveWindow(hControl);
                        bSuccessed = FALSE;
                        goto Exit;
                    }
                }
                break;

            case RM_FOLDER:

                *Enabled = (IsDlgButtonChecked( hDlg, IDC_DEVICE_PROP_SAVE ) == BST_CHECKED);
                hControl = GetDlgItem(hDlg, IDC_DEVICE_PROP_DEST_FOLDER);

                //
                // we will check the validity only when this routing method is enabled
                // but we will save the text change anyway.
                //
                GetWindowText( hControl, lpCurSel, MAX_PATH - 1 );

                if (*Enabled) 
                {
                    if((g_pPathIsRelativeW && g_pPathIsRelativeW (lpCurSel)) || !DirectoryExists(lpCurSel))
                    {
                        DisplayErrorMessage(hDlg, 0, ERROR_PATH_NOT_FOUND);
                        SetFocus(hControl);
                        SetActiveWindow(hControl);
                        bSuccessed = FALSE;
                        goto Exit;
                    }
                }
        }
    }
    // 
    // Now save the device and routing info
    // Get device id from dialog page
    //
    dwDeviceId = (DWORD)GetWindowLongPtr(hDlg, GWLP_USERDATA);
    // 
    // Save routing methods info
    //
    if(!Connect(hDlg, TRUE))
    {
        bSuccessed = FALSE;
        goto Exit;
    }

    if(!FaxGetPortEx(g_hFaxSvcHandle, dwDeviceId, &pFaxPortInfo))
    {
        bSuccessed = FALSE;
        dwRes = GetLastError();
        Error(("Can't save routing information.\n"));
        goto Exit;
    }
    //
    // Save receive settings
    //
    if(IsDlgButtonChecked(hDlg, IDC_DEVICE_PROP_RECEIVE) == BST_CHECKED)
    {
        //
        // Collect and verify TSID
        //
        GetDlgItemText(hDlg, IDC_DEVICE_PROP_CSID, szCsid, CSID_LIMIT + 1);
        pFaxPortInfo->lptstrCsid = szCsid;
        if(IsDlgButtonChecked(hDlg, IDC_DEVICE_PROP_AUTO_ANSWER) == BST_CHECKED)
        {
            pFaxPortInfo->ReceiveMode = FAX_DEVICE_RECEIVE_MODE_AUTO;
            //
            // save ring count info
            //
            pFaxPortInfo->dwRings = dwRingCount;
        }
        else if(IsDlgButtonChecked(hDlg, IDC_DEVICE_PROP_MANUAL_ANSWER) == BST_CHECKED)
        {
            //
            // Turn off manual-answer for ALL devices.
            //
            DWORD dw;
            for (dw = 0; dw < g_dwPortsNum; dw++)
            {
                if (FAX_DEVICE_RECEIVE_MODE_MANUAL == g_pFaxPortInfo[dw].ReceiveMode)
                {
                    g_pFaxPortInfo[dw].ReceiveMode = FAX_DEVICE_RECEIVE_MODE_OFF;
                }
            }
            //
            // Turn on manual-answer for selected device only.
            //
            pFaxPortInfo->ReceiveMode = FAX_DEVICE_RECEIVE_MODE_MANUAL;
        }
    }
    else
    {
        pFaxPortInfo->ReceiveMode = FAX_DEVICE_RECEIVE_MODE_OFF;
    }
    
    if(!FaxSetPortEx(g_hFaxSvcHandle, dwDeviceId, pFaxPortInfo))
    {
        bSuccessed = FALSE;
        dwRes = GetLastError();
        Error(( "Set port information error in DoSaveDeviceList(), ec = %d.\n", dwRes));
        goto Exit;
    }
    //
    // save routing methods
    //
    for (dwCurrentRM = 0; dwCurrentRM < RM_COUNT; dwCurrentRM++) 
    {
        lpCurSel = (LPTSTR)(pRouteInfo[dwCurrentRM] + sizeof(DWORD));
        Enabled  = (LPDWORD)pRouteInfo[dwCurrentRM];

        if ((RM_PRINT == dwCurrentRM) && *Enabled)
        {
            //
            // Attempt to convert printer display name to printer path before we pass it on to the server
            //
            LPCWSTR lpcwstrPrinterPath = FindPrinterPathFromName (g_pPrinterNames, g_dwNumPrinters, lpCurSel);
            if (lpcwstrPrinterPath)
            {
                //
                // We have a matching path - replace name with path.
                //
                lstrcpyn (lpCurSel, lpcwstrPrinterPath, MAX_PATH);
            }
        }

        if(!FaxSetExtensionData(g_hFaxSvcHandle, 
            dwDeviceId, 
            RoutingGuids[dwCurrentRM], 
            (LPBYTE)lpCurSel, 
            sizeof(TCHAR) * MAX_PATH))
        {
            bSuccessed = FALSE;
            dwRes = GetLastError();
            Error(("FaxSetExtensionData() failed with %d.\n", dwRes));
            goto Exit;
        }

        if(!FaxDeviceEnableRoutingMethod(g_hFaxSvcHandle, 
            dwDeviceId, 
            RoutingGuids[dwCurrentRM], 
            *Enabled ? STATUS_ENABLE : STATUS_DISABLE ))
        {
            bSuccessed = FALSE;
            dwRes = GetLastError();
            Error(("FaxDeviceEnableRoutingMethod() failed with %d.\n", dwRes));
            goto Exit;
        }
    }

    bSuccessed = TRUE;

Exit:
    FaxFreeBuffer(pFaxPortInfo);
    DisConnect();

    switch (dwRes)
    {
        case ERROR_SUCCESS:
            //
            // Don't do nothing
            //
            break;

        case FAXUI_ERROR_DEVICE_LIMIT:
        case FAX_ERR_DEVICE_NUM_LIMIT_EXCEEDED:
            //
            // Some additional parameters are needed
            //
            DisplayErrorMessage(hDlg, 0, dwRes, GetDeviceLimit());
            break;

        default:
            DisplayErrorMessage(hDlg, 0, dwRes);
            break;
    }
    return bSuccessed;
}

INT_PTR 
CALLBACK 
DevRecvDlgProc(
    IN HWND hDlg,
    IN UINT message,
    IN WPARAM wParam,
    IN LPARAM lParam 
    )
/*++

Routine Description:

    Dialog procedure for the receive settings

Arguments:

    hDlg - Identifies the property sheet page
    message - Specifies the message
    wParam - Specifies additional message-specific information
    lParam - Specifies additional message-specific information

Return Value:

    Depending on specific message

--*/
{
    BOOL    fRet = FALSE;
    HWND    hControl;
    DWORD   dwDeviceId;

    switch( message ) 
    {
        case WM_DESTROY:
            if (g_pPrinterNames)
            {
                ReleasePrinterNames (g_pPrinterNames, g_dwNumPrinters);
                g_pPrinterNames = NULL;
            }
            break;

        case WM_INITDIALOG:
        {
            //
            //Get the shared data from PROPSHEETPAGE lParam value
            //and load it into GWL_USERDATA
            //
            dwDeviceId = (DWORD)((LPPROPSHEETPAGE)lParam)->lParam; 
            SetWindowLongPtr(hDlg, GWLP_USERDATA, (LONG_PTR)dwDeviceId);

            //
            // Initialize the list of destination printers
            //
            hControl = GetDlgItem(hDlg, IDC_DEVICE_PROP_PRINT_TO);

            SetLTRComboBox(hDlg, IDC_DEVICE_PROP_PRINT_TO);

            if (g_pPrinterNames)
            {
                ReleasePrinterNames (g_pPrinterNames, g_dwNumPrinters);
                g_pPrinterNames = NULL;
            }
            g_pPrinterNames = CollectPrinterNames (&g_dwNumPrinters, TRUE);
            if (!g_pPrinterNames)
            {
                if (ERROR_PRINTER_NOT_FOUND == GetLastError ())
                {
                    //
                    // No printers
                    //
                }
                else
                {
                    //
                    // Real error
                    //
                }
            }
            else
            {
                //
                // Success - fill in the combo-box
                //
                DWORD dw;
                for (dw = 0; dw < g_dwNumPrinters; dw++)
                {
                    SendMessage(hControl, CB_ADDSTRING, 0, (LPARAM) g_pPrinterNames[dw].lpcwstrDisplayName);
                }
            }        
            //
            // We only allow two-digit phone ring answer
            //
            SendDlgItemMessage(hDlg, IDC_DEVICE_PROP_RINGS, EM_SETLIMITTEXT, 2, 0);
            SendDlgItemMessage(hDlg, IDC_DEVICE_PROP_CSID, EM_SETLIMITTEXT, CSID_LIMIT, 0);
            SendDlgItemMessage(hDlg, IDC_DEVICE_PROP_DEST_FOLDER, EM_SETLIMITTEXT, MAX_ARCHIVE_DIR - 1, 0);
            //
            // Initiate the spin control. 
            //
            SendMessage( GetDlgItem(hDlg, IDC_DEVICE_PROP_SPIN_RINGS), 
                         UDM_SETRANGE32, MIN_RING_COUNT, MAX_RING_COUNT );

            SetLTREditDirection(hDlg, IDC_DEVICE_PROP_DEST_FOLDER);
            if (g_pSHAutoComplete)
            {
                g_pSHAutoComplete (GetDlgItem(hDlg, IDC_DEVICE_PROP_DEST_FOLDER), SHACF_FILESYSTEM);
            }
            InitReceiveInfo(hDlg);
            ValidateReceive(hDlg);
            return TRUE;
        }

        case WM_COMMAND:
        {
            // activate apply button        

            WORD wID = LOWORD( wParam );

            switch( wID ) 
            {
                case IDC_DEVICE_PROP_RECEIVE:

                    if ( HIWORD(wParam) == BN_CLICKED ) // notification code
                    {
                        if(IsDlgButtonChecked(hDlg, IDC_DEVICE_PROP_RECEIVE) == BST_CHECKED)
                        {
                            dwDeviceId = (DWORD)GetWindowLongPtr(hDlg, GWLP_USERDATA);
                            if(!IsDeviceInUse(dwDeviceId) &&
                               GetDeviceLimit() <= CountUsedFaxDevices())
                            {
                                CheckDlgButton(hDlg, IDC_DEVICE_PROP_RECEIVE, BST_UNCHECKED);

                                DisplayErrorMessage(hDlg, 
                                    MB_OK | MB_ICONSTOP,
                                    FAXUI_ERROR_DEVICE_LIMIT,
                                    GetDeviceLimit());
                                fRet = TRUE;
                                break;
                            }
                        }

                        ValidateReceive(hDlg);
                        Notify_Change(hDlg);
                    }
                    break;

                case IDC_DEVICE_PROP_CSID:
                case IDC_DEVICE_PROP_DEST_FOLDER:
                    if( HIWORD(wParam) == EN_CHANGE ) // notification code
                    {      
                        Notify_Change(hDlg);
                    }

                    if (IDC_DEVICE_PROP_DEST_FOLDER == wID && HIWORD(wParam) == EN_KILLFOCUS) 
                    {
                        TCHAR szFolder[MAX_PATH * 2];
                        TCHAR szResult[MAX_PATH * 2];
                        //
                        // Edit control lost its focus
                        //
                        GetDlgItemText (hDlg, wID, szFolder, ARR_SIZE(szFolder));
                        if (lstrlen (szFolder))
                        {
                            if (GetFullPathName(szFolder, ARR_SIZE(szResult), szResult, NULL))
                            {
                                if (g_pPathMakePrettyW)
                                {
                                    g_pPathMakePrettyW (szResult);
                                }
                                SetDlgItemText (hDlg, wID, szResult);
                            }
                        }
                    }
                    break;                    

                case IDC_DEVICE_PROP_MANUAL_ANSWER:
                case IDC_DEVICE_PROP_AUTO_ANSWER:

                    if ( HIWORD(wParam) == BN_CLICKED ) // notification code
                    {
                        BOOL bEnabled = IsDlgButtonChecked( hDlg, IDC_DEVICE_PROP_AUTO_ANSWER );

                        EnableWindow( GetDlgItem( hDlg, IDC_DEVICE_PROP_RINGS ),      bEnabled );
                        EnableWindow( GetDlgItem( hDlg, IDC_DEVICE_PROP_SPIN_RINGS ), bEnabled );

                        Notify_Change(hDlg);
                    }

                    break;

                case IDC_DEVICE_PROP_PRINT:

                    if ( HIWORD(wParam) == BN_CLICKED )  // notification code
                    {
                        EnableWindow( GetDlgItem( hDlg, IDC_DEVICE_PROP_PRINT_TO ), IsDlgButtonChecked( hDlg, IDC_DEVICE_PROP_PRINT ) );
                        Notify_Change(hDlg);
                    }

                    break;

                case IDC_DEVICE_PROP_SAVE:

                    if ( HIWORD(wParam) == BN_CLICKED ) // notification code
                    {     
                        EnableWindow( GetDlgItem( hDlg, IDC_DEVICE_PROP_DEST_FOLDER ), IsDlgButtonChecked( hDlg, IDC_DEVICE_PROP_SAVE ) );
                        EnableWindow( GetDlgItem( hDlg, IDC_DEVICE_PROP_DEST_FOLDER_BR ), IsDlgButtonChecked( hDlg, IDC_DEVICE_PROP_SAVE ) );

                        Notify_Change(hDlg);
                    }

                    break;

                case IDC_DEVICE_PROP_DEST_FOLDER_BR:
                {
                    TCHAR   szTitle[MAX_TITLE_LEN];

                    if(!LoadString(g_hResource, IDS_BROWSE_FOLDER, szTitle, MAX_TITLE_LEN))
                    {
                        lstrcpy(szTitle, TEXT("Select a folder"));
                    }

                    if(BrowseForDirectory(hDlg, IDC_DEVICE_PROP_DEST_FOLDER, MAX_ARCHIVE_DIR, szTitle))
                    {
                        Notify_Change(hDlg);
                    }   

                    break;
                }

                case IDC_DEVICE_PROP_PRINT_TO:

                    if ((HIWORD(wParam) == CBN_SELCHANGE) || // notification code
                        (HIWORD(wParam) == CBN_EDITCHANGE))
                    {      
                        Notify_Change(hDlg);
                    }
                    break;

                default:
                    break;
            } // switch

            fRet = TRUE;
            break;
        }

        case WM_NOTIFY:
        {
            switch( ((LPNMHDR) lParam)->code ) 
            {
                case PSN_APPLY:
                {
                    // if the user only has read permission, return immediately
                    if(!g_bUserCanChangeSettings)
                    {
                        return TRUE;
                    }

                    if(!SaveReceiveInfo(hDlg))
                    {
                        SetWindowLongPtr(hDlg, DWLP_MSGRESULT, PSNRET_INVALID);
                    }
                    else
                    {
                        Notify_UnChange(hDlg);
                        g_bPortInfoChanged = TRUE;
                    }

                    return TRUE;
                }

            } // switch

            break;
        }

    case WM_HELP:
        WinHelpContextPopup(((LPHELPINFO)lParam)->dwContextId, hDlg);
        return TRUE;

    } // switch

    return fRet;
}   // DevRecvDlgProc


BOOL
InitCleanupInfo(
    HWND hDlg
)
/*++

Routine Description:

    Initialize the auto-cleanup information for a specific device

Arguments:

    hDlg - the dialog handle of the dialog

Return Value:

    TRUE if success, FALSE otherwise

--*/
{
    PFAX_OUTBOX_CONFIG  pOutboxConfig = NULL;

    Verbose(("Entering InitCleanupInfo...\n"));
    if(!Connect(hDlg, TRUE))
    {
        return FALSE;
    }

    if(!FaxGetOutboxConfiguration(g_hFaxSvcHandle, &pOutboxConfig))
    {
        Error(( "FaxGetOutboxConfiguration() failed with %d.\n", GetLastError()));
        return FALSE;
    }

    if (pOutboxConfig->dwAgeLimit)
    {
        if (pOutboxConfig->dwAgeLimit < FXS_DIRTYDAYS_LOWER)
        {
            pOutboxConfig->dwAgeLimit = FXS_DIRTYDAYS_LOWER;
        }
        if (pOutboxConfig->dwAgeLimit > FXS_DIRTYDAYS_UPPER)
        {
            pOutboxConfig->dwAgeLimit = FXS_DIRTYDAYS_UPPER;
        }
        //
        // Age limit is active
        //
        CheckDlgButton(hDlg, IDC_DELETE_CHECK, BST_CHECKED);
        SetDlgItemInt (hDlg, IDC_DAYS_EDIT, pOutboxConfig->dwAgeLimit, FALSE);
    }
    else
    {
        //
        // Age limit is inactive
        //
        CheckDlgButton(hDlg, IDC_DELETE_CHECK, BST_UNCHECKED);
        SetDlgItemInt (hDlg, IDC_DAYS_EDIT, FXS_DIRTYDAYS_LOWER, FALSE);
    }
    DisConnect();
    return TRUE;
}   // InitCleanupInfo

BOOL
ValidateCleanup(
    HWND  hDlg
)
/*++

Routine Description:

    Validate the check box and controls for cleanup

Arguments:

    hDlg - Handle to the property sheet page

Return Value:

    TRUE -- if no error
    FALSE -- if error

--*/

{
    BOOL bEnabled;

    if(g_bUserCanChangeSettings) 
    {
        bEnabled = IsDlgButtonChecked(hDlg, IDC_DELETE_CHECK) == BST_CHECKED;
    }
    else
    {
        bEnabled = FALSE;
        EnableWindow (GetDlgItem(hDlg, IDC_DELETE_CHECK), bEnabled);
        EnableWindow (GetDlgItem(hDlg, IDC_STATIC_CLEANUP_ICON), bEnabled);
        EnableWindow (GetDlgItem(hDlg, IDC_STATIC_CLEANUP_OPTIONS), bEnabled);
    }        
    //
    // Enable/disable controls according to "Enable Send" check box
    //
    EnableWindow (GetDlgItem(hDlg, IDC_DAYS_EDIT), bEnabled);
    EnableWindow (GetDlgItem(hDlg, IDC_DAYS_SPIN), bEnabled);
    EnableWindow (GetDlgItem(hDlg, IDC_DAYS_STATIC), bEnabled);
    return TRUE;
}   // ValidateCleanup

BOOL
SaveCleanupInfo(
    IN HWND hDlg)
/*++

Routine name : SaveCleanupInfo

Routine description:

    Process Apply Button

Author:

    Eran Yraiv (EranY), April, 2001

Arguments:

    hDlg                          [IN]    - Handle to the Window

Return Value:

    TRUE if Apply is succeeded, FALSE otherwise.

--*/
{
    DWORD   dwRes = 0;
    BOOL    bErrorDisplayed = FALSE;

    PFAX_OUTBOX_CONFIG  pOutboxConfig = NULL;

    //
    //  if the user only has read permission, return immediately
    //
    if(!g_bUserCanChangeSettings)
    {
        return TRUE;
    }

    if(!Connect(hDlg, TRUE))
    {
        //
        //  Failed to connect to the Fax Service. Connect() showed the Error Message.
        //
        SetWindowLongPtr(hDlg, DWLP_MSGRESULT, PSNRET_INVALID);
        return FALSE;
    }

    if(!FaxGetOutboxConfiguration(g_hFaxSvcHandle, &pOutboxConfig))
    {
        //
        //  Show Error Message and return FALSE
        //
        dwRes = GetLastError();
        Error(( "FaxGetOutboxConfiguration() failed with %d.\n", dwRes));
        return FALSE;
    }
    Assert(pOutboxConfig);
    if (BST_CHECKED == IsDlgButtonChecked(hDlg, IDC_DELETE_CHECK))
    {
        BOOL bRes;
        int iAgeLimit = GetDlgItemInt (hDlg, IDC_DAYS_EDIT, &bRes, FALSE);

        if (!bRes || (iAgeLimit > FXS_DIRTYDAYS_UPPER) || (iAgeLimit < FXS_DIRTYDAYS_LOWER))
        {
            //
            // Bad data or out of range
            //
            HWND hControl = GetDlgItem(hDlg, IDC_DAYS_EDIT);
            dwRes = ERROR_INVALID_DATA;
            SetLastError (ERROR_INVALID_DATA);
            DisplayErrorMessage(hDlg, 0, FAXUI_ERROR_INVALID_DIRTY_DAYS, FXS_DIRTYDAYS_LOWER, FXS_DIRTYDAYS_UPPER);
            SendMessage(hControl, EM_SETSEL, 0, -1);
            SetFocus(hControl);
            SetActiveWindow(hControl);
            bErrorDisplayed = TRUE;
            goto ClearData;
        }
        pOutboxConfig->dwAgeLimit = iAgeLimit;
    }
    else
    {
        //
        // Age limit is disabled
        //
        pOutboxConfig->dwAgeLimit = 0;
    }
    if(!FaxSetOutboxConfiguration(g_hFaxSvcHandle, pOutboxConfig))
    {
        //
        //  Show Error Message and return FALSE
        //
        dwRes = GetLastError();
        Error(("FaxSetOutboxConfiguration() failed with %d.\n", dwRes));
        goto ClearData;
    }

ClearData:
    FaxFreeBuffer(pOutboxConfig);
    DisConnect();

    switch (dwRes)
    {
        case ERROR_SUCCESS:
            //
            // Don't do nothing
            //
            break;

        case FAXUI_ERROR_DEVICE_LIMIT:
        case FAX_ERR_DEVICE_NUM_LIMIT_EXCEEDED:
            //
            // Some additional parameters are needed
            //
            DisplayErrorMessage(hDlg, 0, dwRes, GetDeviceLimit());
            SetWindowLongPtr(hDlg, DWLP_MSGRESULT, PSNRET_INVALID);
            break;

        default:
            DisplayErrorMessage(hDlg, 0, dwRes);
            SetWindowLongPtr(hDlg, DWLP_MSGRESULT, PSNRET_INVALID);
            break;
    }
    return (dwRes == 0);
}   // SaveCleanupInfo

INT_PTR 
CALLBACK 
DevCleanupDlgProc(
    IN HWND hDlg,
    IN UINT message,
    IN WPARAM wParam,
    IN LPARAM lParam 
    )
/*++

Routine Description:

    Dialog procedure for the cleanup settings

Arguments:

    hDlg - Identifies the property sheet page
    message - Specifies the message
    wParam - Specifies additional message-specific information
    lParam - Specifies additional message-specific information

Return Value:

    Depending on specific message

--*/
{
    BOOL    fRet = FALSE;

    switch( message ) 
    {
        case WM_INITDIALOG:
            //
            // we only allow two-digit days
            //
            SendDlgItemMessage(hDlg, 
                               IDC_DAYS_EDIT, 
                               EM_SETLIMITTEXT, 
                               FXS_DIRTYDAYS_LENGTH, 
                               0);
            //
            // Initiate the spin control. 
            //
            SendDlgItemMessage(hDlg, 
                               IDC_DAYS_SPIN,
                               UDM_SETRANGE32, 
                               FXS_DIRTYDAYS_LOWER, 
                               FXS_DIRTYDAYS_UPPER);

            InitCleanupInfo(hDlg);
            ValidateCleanup(hDlg);
            return TRUE;

        case WM_COMMAND:
        {
            WORD wID = LOWORD( wParam );
            switch( wID ) 
            {
                case IDC_DELETE_CHECK:

                    if (BN_CLICKED == HIWORD(wParam)) // notification code
                    {
                        //
                        // User checked / unchecked the checkbox
                        //
                        ValidateCleanup(hDlg);
                        Notify_Change(hDlg);
                    }
                    break;

                case IDC_DAYS_EDIT:
                    if(EN_CHANGE == HIWORD(wParam)) // notification code
                    {      
                        //
                        // User changed something in the edit control
                        //
                        Notify_Change(hDlg);
                    }
                    break;                    

                default:
                    break;
            } // switch
            fRet = TRUE;
            break;
        }

        case WM_NOTIFY:
        {
            switch( ((LPNMHDR) lParam)->code ) 
            {
                case PSN_APPLY:
                {
                    // if the user only has read permission, return immediately
                    if(!g_bUserCanChangeSettings)
                    {
                        return TRUE;
                    }

                    if(!SaveCleanupInfo(hDlg))
                    {
                        SetWindowLongPtr(hDlg, DWLP_MSGRESULT, PSNRET_INVALID);
                    }
                    else
                    {
                        Notify_UnChange(hDlg);
                        g_bPortInfoChanged = TRUE;
                    }
                    return TRUE;
                }
            } // switch
            break;
        }

        case WM_HELP:
            WinHelpContextPopup(((LPHELPINFO)lParam)->dwContextId, hDlg);
            return TRUE;
    } // switch
    return fRet;
}   // DevCleanupDlgProc


BOOL
SaveSendChanges(
    IN HWND hDlg)
/*++

Routine name : SaveSendChanges

Routine description:

    Process Apply Button

Author:

    Iv Garber (IvG),    Feb, 2001

Arguments:

    hDlg                          [TBD]    - Handle to the Window

Return Value:

    TRUE if Apply is succeeded, FALSE otherwise.

--*/
{
    DWORD   dwDeviceId = 0;
    DWORD   dwRes = 0;
    DWORD   dwData;
    TCHAR   szTsid[TSID_LIMIT + 1] = {0};
    BOOL    bRes;
    BOOL    bErrorDisplayed = FALSE;

    SYSTEMTIME  sTime = {0};

    PFAX_PORT_INFO_EX   pFaxPortInfo = NULL;    // receive port information 
    PFAX_OUTBOX_CONFIG  pOutboxConfig = NULL;

    //
    //  if the user only has read permission, return immediately
    //
    if(!g_bUserCanChangeSettings)
    {
        return TRUE;
    }

    //
    //  apply changes here!!
    //
    dwDeviceId = (DWORD)GetWindowLongPtr(hDlg, GWLP_USERDATA);


    if(!Connect(hDlg, TRUE))
    {
        //
        //  Failed to connect to the Fax Service. Connect() showed the Error Message.
        //
        SetWindowLongPtr(hDlg, DWLP_MSGRESULT, PSNRET_INVALID);
        return FALSE;
    }


    if(!FaxGetPortEx(g_hFaxSvcHandle, dwDeviceId, &pFaxPortInfo))
    {
        //
        //  Show the Error Message and return with FALSE
        //  
        dwRes = GetLastError();
        Error(( "FaxGetPortEx() failed with %d.\n", dwRes));
        goto ClearData;
    }

    Assert(pFaxPortInfo);

    //
    //  save settings
    //
    pFaxPortInfo->bSend = IsDlgButtonChecked(hDlg, IDC_DEVICE_PROP_SEND) == BST_CHECKED ? TRUE : FALSE;
    if (pFaxPortInfo->bSend)
    {
        //
        // Collect and verify TSID
        //
        GetDlgItemText(hDlg, IDC_DEVICE_PROP_TSID, szTsid, TSID_LIMIT);
        pFaxPortInfo->lptstrTsid = szTsid;
    }
    if(!FaxSetPortEx(g_hFaxSvcHandle, dwDeviceId, pFaxPortInfo))
    {
        //
        //  Show the Error Message and return with FALSE
        //
        dwRes = GetLastError();
        Error(( "FaxSetPortEx() failed with %d.\n", dwRes));
        goto ClearData;
    }
    else
    {
        Notify_UnChange(hDlg);
        g_bPortInfoChanged = TRUE;
    }

    if(!IsDesktopSKU())
    {
        goto ClearData;
    }

    //
    // save desktop controls
    //
    if(!FaxGetOutboxConfiguration(g_hFaxSvcHandle, &pOutboxConfig))
    {
        //
        //  Show Error Message and return FALSE
        //
        dwRes = GetLastError();
        Error(( "FaxGetOutboxConfiguration() failed with %d.\n", dwRes));
        goto ClearData;
    }

    Assert(pOutboxConfig);

    //
    // Branding
    //            
    pOutboxConfig->bBranding = (IsDlgButtonChecked(hDlg, IDC_BRANDING_CHECK) == BST_CHECKED);

    //
    // Retries
    //
    dwData = GetDlgItemInt(hDlg, IDC_RETRIES_EDIT, &bRes, FALSE);
    if (!bRes || 
#if FXS_RETRIES_LOWER > 0 
        (dwData < FXS_RETRIES_LOWER) || 
#endif
        (dwData > FXS_RETRIES_UPPER))
    {
        //
        // Bad data or out of range
        //
        HWND hControl = GetDlgItem(hDlg, IDC_RETRIES_EDIT);

        dwRes = ERROR_INVALID_DATA;
        SetLastError (ERROR_INVALID_DATA);
        DisplayErrorMessage(hDlg, 0, FAXUI_ERROR_INVALID_RETRIES, FXS_RETRIES_LOWER, FXS_RETRIES_UPPER);
        SendMessage(hControl, EM_SETSEL, 0, -1);
        SetFocus(hControl);
        SetActiveWindow(hControl);
        bErrorDisplayed = TRUE;
        goto ClearData;
    }
    pOutboxConfig->dwRetries = dwData;
    //
    // Retry Delay
    //
    dwData = GetDlgItemInt(hDlg, IDC_RETRYDELAY_EDIT, &bRes, FALSE);
    if (!bRes || 
#if FXS_RETRYDELAY_LOWER > 0
        (dwData < FXS_RETRYDELAY_LOWER) || 
#endif
        (dwData > FXS_RETRYDELAY_UPPER))
    {
        //
        // Bad data or out of range
        //
        HWND hControl = GetDlgItem(hDlg, IDC_RETRYDELAY_EDIT);

        dwRes = ERROR_INVALID_DATA;
        SetLastError (ERROR_INVALID_DATA);
        DisplayErrorMessage(hDlg, 0, FAXUI_ERROR_INVALID_RETRY_DELAY, FXS_RETRYDELAY_LOWER, FXS_RETRYDELAY_UPPER);
        SendMessage(hControl, EM_SETSEL, 0, -1);
        SetFocus(hControl);
        SetActiveWindow(hControl);
        bErrorDisplayed = TRUE;
        goto ClearData;
    }
    pOutboxConfig->dwRetryDelay = dwData;
    //
    // Discount rate start time
    //
    SendDlgItemMessage(hDlg, IDC_DISCOUNT_START_TIME, DTM_GETSYSTEMTIME, 0, (LPARAM)&sTime);
    pOutboxConfig->dtDiscountStart.Hour   = sTime.wHour;
    pOutboxConfig->dtDiscountStart.Minute = sTime.wMinute;
    //
    // Discount rate stop time
    //
    SendDlgItemMessage(hDlg, IDC_DISCOUNT_STOP_TIME, DTM_GETSYSTEMTIME, 0, (LPARAM)&sTime);
    pOutboxConfig->dtDiscountEnd.Hour   = sTime.wHour;
    pOutboxConfig->dtDiscountEnd.Minute = sTime.wMinute;

    if(!FaxSetOutboxConfiguration(g_hFaxSvcHandle, pOutboxConfig))
    {
        //
        //  Show Error Message and return FALSE
        //
        dwRes = GetLastError();
        Error(("FaxSetOutboxConfiguration() failed with %d.\n", dwRes));
        goto ClearData;
    }

ClearData:
    FaxFreeBuffer(pOutboxConfig);
    FaxFreeBuffer(pFaxPortInfo);
    DisConnect();


    switch (dwRes)
    {
        case ERROR_SUCCESS:
            //
            // Don't do nothing
            //
            break;

        case FAXUI_ERROR_DEVICE_LIMIT:
        case FAX_ERR_DEVICE_NUM_LIMIT_EXCEEDED:
            //
            // Some additional parameters are needed
            //
            if (!bErrorDisplayed)
            {
                DisplayErrorMessage(hDlg, 0, dwRes, GetDeviceLimit());
            }
            SetWindowLongPtr(hDlg, DWLP_MSGRESULT, PSNRET_INVALID);
            break;

        default:
            if (!bErrorDisplayed)
            {
                DisplayErrorMessage(hDlg, 0, dwRes);
            }
            SetWindowLongPtr(hDlg, DWLP_MSGRESULT, PSNRET_INVALID);
            break;
    }
    return (dwRes == 0);
}   // SaveSendChanges
=== C:/Users/treeman/Desktop/windows nt source code\Source\Win2K3\NT\printscan\faxsrv\print\faxprint\faxui\archfldr.c ===
/*++

Copyright (c) 1996  Microsoft Corporation

Module Name:

    archfldr.c

Abstract:

    Property sheet handler for "Archive folder" page and "Remote" page

Environment:

    Fax driver user interface

Revision History:

    04/09/00 -taoyuan-
        Created it.

    mm/dd/yy -author-
        description

--*/

#include <stdio.h>
#include "faxui.h"
#include "resource.h"

INT_PTR 
CALLBACK 
ArchiveInfoDlgProc(
    HWND hDlg,  
    UINT uMsg,     
    WPARAM wParam, 
    LPARAM lParam  
)

/*++

Routine Description:

    Procedure for handling the archive folder tab

Arguments:

    hDlg - Identifies the property sheet page
    uMsg - Specifies the message
    wParam - Specifies additional message-specific information
    lParam - Specifies additional message-specific information

Return Value:

    Depends on the value of message parameter

--*/

{
    DWORD   dwRes = 0;

    switch (uMsg)
    {
    case WM_INITDIALOG :
        { 
            PFAX_ARCHIVE_CONFIG     pFaxArchiveConfig;

            SetLTREditDirection(hDlg, IDC_OUTGOING_FOLDER);
            SetLTREditDirection(hDlg, IDC_INCOMING_FOLDER);

            // set edit box text limit
            SendDlgItemMessage(hDlg, IDC_INCOMING_FOLDER, EM_SETLIMITTEXT, MAX_ARCHIVE_FOLDER_PATH, 0);
            SendDlgItemMessage(hDlg, IDC_OUTGOING_FOLDER, EM_SETLIMITTEXT, MAX_ARCHIVE_FOLDER_PATH, 0);

            if(!Connect(hDlg, TRUE))
            {
                return TRUE;
            }

            // load incoming archive folder info
            if(FaxGetArchiveConfiguration(g_hFaxSvcHandle, FAX_MESSAGE_FOLDER_INBOX, &pFaxArchiveConfig))
            {
                CheckDlgButton(hDlg, IDC_INCOMING, pFaxArchiveConfig->bUseArchive ? BST_CHECKED : BST_UNCHECKED);
                SetDlgItemText(hDlg, IDC_INCOMING_FOLDER, pFaxArchiveConfig->lpcstrFolder);
                if(g_bUserCanChangeSettings)
                {
                    EnableWindow(GetDlgItem(hDlg, IDC_INCOMING), TRUE);
                    EnableWindow(GetDlgItem(hDlg, IDC_INCOMING_FOLDER), IsDlgButtonChecked(hDlg, IDC_INCOMING));
                    EnableWindow(GetDlgItem(hDlg, IDC_INCOMING_FOLDER_BR), IsDlgButtonChecked(hDlg, IDC_INCOMING));
                }
                FaxFreeBuffer(pFaxArchiveConfig);
            }
            else
            {
                dwRes = GetLastError();
                Error(("FaxGetArchiveConfiguration(FAX_MESSAGE_FOLDER_INBOX) failed. Error code is %d.\n", dwRes));
                goto Exit;
            }

            // load incoming archive folder info
            if(FaxGetArchiveConfiguration(g_hFaxSvcHandle, FAX_MESSAGE_FOLDER_SENTITEMS, &pFaxArchiveConfig))
            {
                CheckDlgButton(hDlg, IDC_OUTGOING, pFaxArchiveConfig->bUseArchive ? BST_CHECKED : BST_UNCHECKED);
                SetDlgItemText(hDlg, IDC_OUTGOING_FOLDER, pFaxArchiveConfig->lpcstrFolder);
                if(g_bUserCanChangeSettings)
                {
                    EnableWindow(GetDlgItem(hDlg, IDC_OUTGOING), TRUE);
                    EnableWindow(GetDlgItem(hDlg, IDC_OUTGOING_FOLDER), IsDlgButtonChecked(hDlg, IDC_OUTGOING));
                    EnableWindow(GetDlgItem(hDlg, IDC_OUTGOING_FOLDER_BR), IsDlgButtonChecked(hDlg, IDC_OUTGOING));
                }
                FaxFreeBuffer(pFaxArchiveConfig);
            }
            else
            {
                dwRes = GetLastError();
                Error(( "FaxGetArchiveConfiguration(FAX_MESSAGE_FOLDER_SENTITEMS) failed. Error code is %d.\n", dwRes));
                goto Exit;
            }
            if (g_pSHAutoComplete)
            {
                g_pSHAutoComplete (GetDlgItem(hDlg, IDC_OUTGOING_FOLDER), SHACF_FILESYSTEM);
                g_pSHAutoComplete (GetDlgItem(hDlg, IDC_INCOMING_FOLDER), SHACF_FILESYSTEM);
            }

Exit:
            DisConnect();

            if (dwRes != 0)
            {
                DisplayErrorMessage(hDlg, 0, dwRes);
                return TRUE;
            }

            if(!g_bUserCanChangeSettings)
            {
                PageEnable(hDlg, FALSE);
            }

            return TRUE;
        }

    case WM_COMMAND:

        switch(LOWORD(wParam)) 
        {
            case IDC_INCOMING_FOLDER:
            case IDC_OUTGOING_FOLDER:
            
                if(HIWORD(wParam) == EN_CHANGE) // notification code
                {      
                    Notify_Change(hDlg);
                }

                if (HIWORD(wParam) == EN_KILLFOCUS) 
                {
                    TCHAR szFolder[MAX_PATH * 2];
                    TCHAR szResult[MAX_PATH * 2];
                    //
                    // Edit control lost its focus
                    //
                    GetDlgItemText (hDlg, LOWORD(wParam), szFolder, ARR_SIZE(szFolder));
                    if (lstrlen (szFolder))
                    {
                        if (GetFullPathName(szFolder, ARR_SIZE(szResult), szResult, NULL))
                        {
                            if (g_pPathMakePrettyW)
                            {
                                g_pPathMakePrettyW (szResult);
                            }
                            SetDlgItemText (hDlg, LOWORD(wParam), szResult);
                        }
                    }
                }
                break;                    

            case IDC_INCOMING:
            case IDC_OUTGOING:

                if( HIWORD(wParam) == BN_CLICKED ) // notification code
                {
                    BOOL    bEnabled;

                    if(LOWORD(wParam) == IDC_INCOMING)
                    {
                        bEnabled = IsDlgButtonChecked(hDlg, IDC_INCOMING);
                        EnableWindow(GetDlgItem(hDlg, IDC_INCOMING_FOLDER), bEnabled);
                        EnableWindow(GetDlgItem(hDlg, IDC_INCOMING_FOLDER_BR), bEnabled);
                    }
                    else
                    {
                        bEnabled = IsDlgButtonChecked(hDlg, IDC_OUTGOING);
                        EnableWindow(GetDlgItem(hDlg, IDC_OUTGOING_FOLDER), bEnabled);
                        EnableWindow(GetDlgItem(hDlg, IDC_OUTGOING_FOLDER_BR), bEnabled);
                    }

                    Notify_Change(hDlg);
                }

                break;                    

            case IDC_INCOMING_FOLDER_BR:
            case IDC_OUTGOING_FOLDER_BR:
            {
                TCHAR   szTitle[MAX_TITLE_LEN];
                BOOL    bResult;

                if(!LoadString(g_hResource, IDS_BROWSE_FOLDER, szTitle, MAX_TITLE_LEN))
                {
                    Error(( "LoadString failed, string ID is %d.\n", IDS_BROWSE_FOLDER ));
                }

                if( LOWORD(wParam) == IDC_INCOMING_FOLDER_BR )
                {
                    bResult = BrowseForDirectory(hDlg, IDC_INCOMING_FOLDER, MAX_ARCHIVE_FOLDER_PATH, szTitle);
                }
                else
                {
                    bResult = BrowseForDirectory(hDlg, IDC_OUTGOING_FOLDER, MAX_ARCHIVE_FOLDER_PATH, szTitle);
                }

                if(bResult) 
                {
                    Notify_Change(hDlg);
                }

                break;
            }

            default:
                break;
        }

        break;

    case WM_NOTIFY:
    {

        LPNMHDR lpnm = (LPNMHDR) lParam;

        switch (lpnm->code)
        {
            case PSN_APPLY:
            {
                PFAX_ARCHIVE_CONFIG     pFaxArchiveConfig = NULL;
                BOOL                    bEnabled;
                TCHAR                   szArchiveFolder[MAX_PATH] = {0};
                HWND                    hControl;

                // if the user only has read permission, return immediately
                if(!g_bUserCanChangeSettings)
                {
                    return TRUE;
                }

                // check the validaty of edit box if they are enabled.
                if(IsDlgButtonChecked(hDlg, IDC_INCOMING))
                {
                    hControl = GetDlgItem(hDlg, IDC_INCOMING_FOLDER);
                    GetWindowText(hControl, szArchiveFolder, MAX_PATH);

                    if ((g_pPathIsRelativeW && g_pPathIsRelativeW(szArchiveFolder)) ||
                        !DirectoryExists(szArchiveFolder))
                    {
                        DisplayErrorMessage(hDlg, 0, ERROR_PATH_NOT_FOUND);
                        SendMessage(hControl, EM_SETSEL, 0, -1);
                        SetFocus(hControl);
                        SetActiveWindow(hControl);
                        SetWindowLongPtr(hDlg, DWLP_MSGRESULT, PSNRET_INVALID);
                        return TRUE;
                    }
                    szArchiveFolder[0] = 0; // set string to empty string
                }

                if(IsDlgButtonChecked(hDlg, IDC_OUTGOING))
                {
                    hControl = GetDlgItem(hDlg, IDC_OUTGOING_FOLDER);
                    GetWindowText(hControl, szArchiveFolder, MAX_PATH);

                    // if(lstrlen(szArchiveFolder) == 0)
                    if( !DirectoryExists(szArchiveFolder) )
                    {
                        DisplayErrorMessage(hDlg, 0, ERROR_PATH_NOT_FOUND);
                        SendMessage(hControl, EM_SETSEL, 0, -1);
                        SetFocus(hControl);
                        SetActiveWindow(hControl);
                        SetWindowLongPtr(hDlg, DWLP_MSGRESULT, PSNRET_INVALID);
                        return TRUE;
                    }
                    szArchiveFolder[0] = 0; // set string to empty string
                }

                if(!Connect(hDlg, TRUE))
                {
                    SetWindowLongPtr(hDlg, DWLP_MSGRESULT, PSNRET_INVALID);
                    return TRUE;
                }

                //
                // save incoming archive folder info
                //
                if(!FaxGetArchiveConfiguration(g_hFaxSvcHandle, FAX_MESSAGE_FOLDER_INBOX, &pFaxArchiveConfig))
                {
                    dwRes = GetLastError();
                    Error(( "FaxGetArchiveConfiguration(FAX_MESSAGE_FOLDER_INBOX) failed. Error code is %d.\n", dwRes));
                    goto ApplyExit;
                }

                bEnabled = (IsDlgButtonChecked(hDlg, IDC_INCOMING) == BST_CHECKED);
                GetDlgItemText(hDlg, IDC_INCOMING_FOLDER, szArchiveFolder, MAX_PATH);
                ValidatePath(szArchiveFolder);

                pFaxArchiveConfig->bUseArchive = bEnabled;
                pFaxArchiveConfig->lpcstrFolder = szArchiveFolder;

                if (!FaxSetArchiveConfiguration(g_hFaxSvcHandle, FAX_MESSAGE_FOLDER_INBOX, pFaxArchiveConfig))
                {
                    dwRes = GetLastError();
                    Error(("FaxSetArchiveConfiguration(FAX_MESSAGE_FOLDER_INBOX) failed. Error code is %d.\n", dwRes));
                    goto ApplyExit;
                }

                FaxFreeBuffer(pFaxArchiveConfig);
                pFaxArchiveConfig = NULL;

                //
                // save outgoing archive folder info
                //

                if(!FaxGetArchiveConfiguration(g_hFaxSvcHandle, FAX_MESSAGE_FOLDER_SENTITEMS, &pFaxArchiveConfig))
                {
                    dwRes = GetLastError();
                    Error(("FaxGetArchiveConfiguration(FAX_MESSAGE_FOLDER_SENTITEMS) failed. Error code is %d.\n", dwRes));
                    goto ApplyExit;
                }

                bEnabled = (IsDlgButtonChecked(hDlg, IDC_OUTGOING) == BST_CHECKED);
                GetDlgItemText(hDlg, IDC_OUTGOING_FOLDER, szArchiveFolder, MAX_PATH);
                ValidatePath(szArchiveFolder);
                
                pFaxArchiveConfig->bUseArchive = bEnabled;
                pFaxArchiveConfig->lpcstrFolder = szArchiveFolder;
                
                if(!FaxSetArchiveConfiguration(g_hFaxSvcHandle, FAX_MESSAGE_FOLDER_SENTITEMS, pFaxArchiveConfig))
                {
                    dwRes = GetLastError();
                    Error(("FaxSetArchiveConfiguration(FAX_MESSAGE_FOLDER_SENTITEMS) failed. Error code is %d.\n", dwRes));
                    goto ApplyExit;
                }

                Notify_UnChange(hDlg);

ApplyExit:
                DisConnect();

                if (pFaxArchiveConfig)
                {
                    FaxFreeBuffer(pFaxArchiveConfig);
                }

                if (dwRes != 0)
                {
                    DisplayErrorMessage(hDlg, 0, dwRes);
                    SetWindowLongPtr(hDlg, DWLP_MSGRESULT, PSNRET_INVALID);
                }

                return TRUE;
            }

            default :
                break;
        } // switch

        break;
    }

    case WM_HELP:
        WinHelpContextPopup(((LPHELPINFO)lParam)->dwContextId, hDlg);
        return TRUE;

    default:
        break;
    }

    return FALSE;
}

INT_PTR  
CALLBACK 
RemoteInfoDlgProc(
    HWND hDlg,  
    UINT uMsg,     
    WPARAM wParam, 
    LPARAM lParam  
)

/*++

Routine Description:

    Procedure for handling the archive folder tab

Arguments:

    hDlg - Identifies the property sheet page
    uMsg - Specifies the message
    wParam - Specifies additional message-specific information
    lParam - Specifies additional message-specific information

Return Value:

    Depends on the value of message parameter

--*/

{
    return FALSE;
}
=== C:/Users/treeman/Desktop/windows nt source code\Source\Win2K3\NT\printscan\faxsrv\print\faxprint\faxui\devinfo.c ===
/*++

Copyright (c) 1996  Microsoft Corporation

Module Name:

    devinfo.c

Abstract:

    Property sheet handler for "Device" page 

Environment:

    Fax driver user interface

Revision History:

    04/09/00 -taoyuan-
        Created it.

    mm/dd/yy -author-
        description

--*/

#include <stdio.h>
#include "faxui.h"
#include "resource.h"

const static COLUMN_HEADER ColumnHeader[] = 
{
    { IDS_DEVICE_NAME,  190 },
    { IDS_SEND,         60  },
    { IDS_RECEIVE,      60  }
};

#define ColumnHeaderCount sizeof(ColumnHeader)/sizeof(COLUMN_HEADER)

PFAX_PORT_INFO_EX
GetSelectedPortInfo(
    HWND    hDlg
)
/*++

Routine Description:

  Find port info of the selected device

Arguments:

    hDlg - Identifies the property sheet page

Return Value:

    FAX_PORT_INFO_EX if successful, 
    NULL if failed or no device is selected

--*/
{
    HWND    hwndLv;
    INT     iItem;
    LVITEM  lvi = {0};

    PFAX_PORT_INFO_EX   pFaxPortInfo = NULL;

    hwndLv = GetDlgItem(hDlg, IDC_DEVICE_LIST);
    if(!hwndLv)
    {
        Assert(FALSE);
        return NULL;                
    }

    iItem = ListView_GetNextItem(hwndLv, -1, LVNI_ALL | LVNI_SELECTED);
    if(iItem == -1)
    {
        return NULL;
    }

    lvi.iItem = iItem;
    lvi.mask  = LVIF_PARAM;
    ListView_GetItem(hwndLv, &lvi);

    pFaxPortInfo = FindPortInfo((DWORD)lvi.lParam);
    if(!pFaxPortInfo)
    {
        Error(("FindPortInfo() failed\n"));
        Assert(FALSE);
        return NULL;                
    }

    return pFaxPortInfo;
}

BOOL
FillInDeviceInfo(
    HWND    hDlg
    )

/*++

Routine Description:

    Fill in device information for currently selected device, if no
    device is selected, all text windows are empty

Arguments:

    hDlg - Identifies the property sheet page

Return Value:

    TRUE if successful, FALSE if failed or no device is selected

--*/

{
    PFAX_PORT_INFO_EX   pFaxPortInfo;   // receive the fax port info
    TCHAR               szBuffer[MAX_TITLE_LEN];

    Verbose(("Entering FillInDeviceInfo...\n"));

    pFaxPortInfo = GetSelectedPortInfo(hDlg);
    if(!pFaxPortInfo)
    {
        Error(("GetSelectedPortInfo() failed\n"));
        goto error;
    }

    SetDlgItemText(hDlg, IDC_DEVICE_INFO_GRP, pFaxPortInfo->lpctstrDeviceName);

    SetDlgItemText(hDlg, IDC_TSID, pFaxPortInfo->bSend ? pFaxPortInfo->lptstrTsid : TEXT(""));
    EnableWindow(GetDlgItem(hDlg, IDC_STATIC_TSID), pFaxPortInfo->bSend);

    if(pFaxPortInfo->ReceiveMode != FAX_DEVICE_RECEIVE_MODE_OFF)
    {
        SetDlgItemText(hDlg, IDC_CSID,  pFaxPortInfo->lptstrCsid);

        if(FAX_DEVICE_RECEIVE_MODE_AUTO == pFaxPortInfo->ReceiveMode)
        {
            DWORD               dwRes;
            BOOL                bVirtual;

            if(!Connect(hDlg, TRUE))
            {
                return FALSE;
            }

            dwRes = IsDeviceVirtual (g_hFaxSvcHandle, pFaxPortInfo->dwDeviceID, &bVirtual);
            if (ERROR_SUCCESS != dwRes)
            {
                return FALSE;
            }
            SetDlgItemInt (hDlg, IDC_RINGS, bVirtual? 1 : pFaxPortInfo->dwRings, FALSE);
        }
        else
        {
            SetDlgItemText(hDlg, IDC_RINGS, TEXT(""));
        }
    }
    else // receive off
    {
        SetDlgItemText(hDlg, IDC_RINGS, TEXT(""));
        SetDlgItemText(hDlg, IDC_CSID,  TEXT(""));        
    }

    EnableWindow(GetDlgItem(hDlg, IDC_STATIC_CSID),  (pFaxPortInfo->ReceiveMode != FAX_DEVICE_RECEIVE_MODE_OFF));
    EnableWindow(GetDlgItem(hDlg, IDC_STATIC_RINGS), (pFaxPortInfo->ReceiveMode == FAX_DEVICE_RECEIVE_MODE_AUTO));

    return TRUE;

error:
    //
    // make all info fields empty
    //
    if(!LoadString(g_hResource, IDS_NO_DEVICE_SELECTED, szBuffer, MAX_TITLE_LEN))
    {
        Error(( "LoadString failed, string ID is %d.\n", IDS_NO_DEVICE_SELECTED ));
        lstrcpy(szBuffer, TEXT(""));
    }

    SetDlgItemText(hDlg, IDC_DEVICE_INFO_GRP, szBuffer);
    SetDlgItemText(hDlg, IDC_TSID, TEXT(""));
    SetDlgItemText(hDlg, IDC_CSID, TEXT(""));
    SetDlgItemText(hDlg, IDC_RINGS, TEXT(""));

    EnableWindow(GetDlgItem(hDlg, IDC_STATIC_TSID),  FALSE);
    EnableWindow(GetDlgItem(hDlg, IDC_STATIC_CSID),  FALSE);
    EnableWindow(GetDlgItem(hDlg, IDC_STATIC_RINGS), FALSE);

    return FALSE;
}

BOOL
UpdateDeviceInfo(
    HWND    hDlg
)

/*++

Routine Description:

    Display the send and receive information in the list view

Arguments:

    hDlg - Identifies the property sheet page

Return Value:

    TRUE if successful, FALSE if failed 

--*/

{
    HWND                hwndLv;
    INT                 iItem;
    INT                 iDeviceCount;
    LVITEM              lvi = {0};
    PFAX_PORT_INFO_EX   pFaxPortInfo;
    DWORD               dwResId;

    Verbose(("Entering UpdateDeviceInfo...\n"));

    hwndLv = GetDlgItem(hDlg, IDC_DEVICE_LIST);

    iDeviceCount = ListView_GetItemCount(hwndLv);
    for(iItem = 0; iItem < iDeviceCount; ++iItem)
    {
        lvi.iItem = iItem;
        lvi.mask  = LVIF_PARAM;
        ListView_GetItem(hwndLv, &lvi);

        pFaxPortInfo = FindPortInfo((DWORD)lvi.lParam);
        if(!pFaxPortInfo)
        {
            Error(("FindPortInfo() failed\n"));
            Assert(FALSE);
            continue;
        }
   
        //
        // Send
        //
        dwResId = pFaxPortInfo->bSend ? IDS_DEVICE_ENABLED : IDS_DEVICE_DISABLED;
        ListView_SetItemText(hwndLv, iItem, 1, GetString(dwResId));

        //
        // Receive
        //
        switch (pFaxPortInfo->ReceiveMode)
        {
            case FAX_DEVICE_RECEIVE_MODE_OFF:
                dwResId = IDS_DEVICE_DISABLED;
                break;
            case FAX_DEVICE_RECEIVE_MODE_AUTO:
                dwResId = IDS_DEVICE_AUTO_ANSWER;
                break;
            case FAX_DEVICE_RECEIVE_MODE_MANUAL:
                dwResId = IDS_DEVICE_MANUAL_ANSWER;
                break;
            default:
                Assert (FALSE);
                dwResId = IDS_DEVICE_DISABLED;
                break;
        }
        ListView_SetItemText(hwndLv, iItem, 2, GetString(dwResId));
    }

    return TRUE;
}

BOOL
DoInitDeviceList(
    HWND hDlg // window handle of the device info page
    )

/*++

Routine Description:

    Initialize the list view and fill in device info of the first device in the list

Arguments:

    hDlg - Identifies the property sheet page

Return Value:

    TRUE if successful, FALSE if failed 

--*/

{
    HWND      hwndLv;  // list view window
    LVITEM    lv = {0};
    DWORD     dwDeviceIndex;
    DWORD     dwResId;

    PFAX_OUTBOUND_ROUTING_GROUP pFaxRoutingGroup = NULL;
    DWORD                       dwGroups;       // group number
    DWORD                       dwGroupIndex;
    DWORD                       dwDeviceCount;  // the return device number from FaxEnumOutboundGroups
    LPDWORD                     lpdwDevices = NULL; // temporary pointer to save group device info
    PFAX_PORT_INFO_EX           pFaxPortInfo;

    Verbose(("Entering DoInitDeviceList...\n"));

    hwndLv = GetDlgItem(hDlg, IDC_DEVICE_LIST);


    if (!IsDesktopSKU())
    {
        if(!Connect(hDlg, TRUE))
        {
            return FALSE;
        }
        //
        // FaxEnumPortsEx doesn't provide device list under send device order
        // so we need to use FaxEnumOutboundGroups to do that.
        //
        if(!FaxEnumOutboundGroups(g_hFaxSvcHandle, &pFaxRoutingGroup, &dwGroups))
        {
            dwResId = GetLastError();
            Error(( "FaxEnumOutboundGroups() failed with %d.\n", dwResId));
            DisplayErrorMessage(hDlg, 0, dwResId);
            DisConnect();
            return FALSE;
        }
        DisConnect();
    

        for(dwGroupIndex = 0; dwGroupIndex < dwGroups; dwGroupIndex++)
        {
            if(!lstrcmp(pFaxRoutingGroup[dwGroupIndex].lpctstrGroupName, ROUTING_GROUP_ALL_DEVICES))
            {
                dwDeviceCount = pFaxRoutingGroup[dwGroupIndex].dwNumDevices;            
                lpdwDevices   = pFaxRoutingGroup[dwGroupIndex].lpdwDevices;

                Verbose(( "Total device number is %d.\n", dwDeviceCount ));
                Verbose(( "Group status is %d.\n", pFaxRoutingGroup[dwGroupIndex].Status ));
                break;
            }
        }

        // the device number from FaxEnumPortsEx and in the <All Devices> group should be the same.
        Assert(g_dwPortsNum == dwDeviceCount);
    }
    else
    {
        //
        // In desktop SKU
        // Fax outbound routing groups do not exist.
        // Fake the <All Devices> group now.
        //
        lpdwDevices = MemAlloc (sizeof (DWORD) * g_dwPortsNum);
        if (!lpdwDevices)
        {
            dwResId = GetLastError();
            Error(( "MemAlloc() failed with %d.\n", dwResId));
            DisplayErrorMessage(hDlg, 0, dwResId);
            DisConnect();
            return FALSE;
        }
        dwDeviceCount = g_dwPortsNum;
        for (dwDeviceIndex = 0; dwDeviceIndex < g_dwPortsNum; dwDeviceIndex++)
        {
            lpdwDevices[dwDeviceIndex] = g_pFaxPortInfo[dwDeviceIndex].dwDeviceID;
        }
    }
    lv.mask = LVIF_TEXT | LVIF_PARAM;

    for(dwDeviceIndex = 0; dwDeviceIndex < dwDeviceCount; dwDeviceIndex++)
    {
        pFaxPortInfo = FindPortInfo(lpdwDevices[dwDeviceIndex]);
        if(!pFaxPortInfo)
        {
            Error(("FindPortInfo() failed\n"));
            Assert(FALSE);
            continue;
        }
        lv.iItem   = dwDeviceIndex;
        lv.pszText = (LPTSTR)pFaxPortInfo->lpctstrDeviceName;
        lv.lParam  = (LPARAM)pFaxPortInfo->dwDeviceID;
        ListView_InsertItem(hwndLv, &lv);

        //
        // Send column
        //
        dwResId = pFaxPortInfo->bSend ? IDS_DEVICE_ENABLED : IDS_DEVICE_DISABLED;
        ListView_SetItemText(hwndLv, dwDeviceIndex, 1, GetString(dwResId));

        //
        // Receive column
        //
        switch (pFaxPortInfo->ReceiveMode)
        {
            case FAX_DEVICE_RECEIVE_MODE_OFF:
                dwResId = IDS_DEVICE_DISABLED;
                break;
            case FAX_DEVICE_RECEIVE_MODE_AUTO:
                dwResId = IDS_DEVICE_AUTO_ANSWER;
                break;
            case FAX_DEVICE_RECEIVE_MODE_MANUAL:
                dwResId = IDS_DEVICE_MANUAL_ANSWER;
                break;
            default:
                Assert (FALSE);
                dwResId = IDS_DEVICE_DISABLED;
                break;
        }
        ListView_SetItemText(hwndLv, dwDeviceIndex, 2, GetString(dwResId));
    }

    if (!IsDesktopSKU())
    {
        //
        // Server SKU
        //
        FaxFreeBuffer(pFaxRoutingGroup);
        pFaxRoutingGroup = NULL;
    }
    else
    {
        //
        // Desktop SKU
        //
        MemFree (lpdwDevices);
        lpdwDevices = NULL;
        //
        // Hide the label that talks about device priorities
        //
        ShowWindow(GetDlgItem(hDlg, IDC_STATIC_DEVICE), SW_HIDE);
        //
        // Hide the priority arrows
        //
        ShowWindow(GetDlgItem(hDlg, IDC_PRI_UP), SW_HIDE);
        ShowWindow(GetDlgItem(hDlg, IDC_PRI_DOWN), SW_HIDE);
    }
    //
    // Select the first device and show its information
    //
    if(dwDeviceCount >= 1)
    {
        ListView_SetItemState(hwndLv, 0, LVIS_SELECTED, LVIS_SELECTED);
        ValidateControl(hDlg, 0);
    }
    else
    {
        ValidateControl(hDlg, -1);
    }
    if (dwDeviceCount < 2)
    {
        //
        // Less than 2 devices - hide the label which talks about priorities
        //
        ShowWindow(GetDlgItem(hDlg, IDC_STATIC_DEVICE), SW_HIDE);
    }
    
    FillInDeviceInfo(hDlg);
    return TRUE;
}
    
BOOL
ValidateControl(
    HWND            hDlg,
    INT             iItem
    )
/*++

Routine Description:

    Validate the up and down button in the property page

Arguments:

    hDlg - Handle to the property sheet page
    iItem - index of the item being selected

Return Value:

    TRUE -- if no error
    FALSE -- if error

--*/

{
    INT     iDeviceCount;
    HWND    hwndLv;

    hwndLv = GetDlgItem(hDlg, IDC_DEVICE_LIST);

    iDeviceCount = ListView_GetItemCount(hwndLv);

    if(!g_bUserCanChangeSettings)
    {
        PageEnable(hDlg, FALSE);

        EnableWindow(hwndLv, TRUE);
    }

    EnableWindow(GetDlgItem(hDlg, IDC_DEVICE_PROP), (iItem != -1));

    //
    // if there is only one device or we don't click on any item
    // up and down buttons are disabled
    //
    if(iDeviceCount < 2 || iItem == -1)
    {
        EnableWindow(GetDlgItem(hDlg, IDC_PRI_UP), FALSE);
        EnableWindow(GetDlgItem(hDlg, IDC_PRI_DOWN), FALSE);

        return TRUE;
    }

    if(g_bUserCanChangeSettings)
    {
        EnableWindow(GetDlgItem(hDlg, IDC_PRI_UP), iItem > 0); // not the top one
        EnableWindow(GetDlgItem(hDlg, IDC_PRI_DOWN), iItem < iDeviceCount - 1); // not the last one
    }
    if (!IsWindowEnabled (GetFocus()))
    {
        //
        // The currently selected control turned disabled - select the list control
        //
        SetFocus (GetDlgItem (hDlg, IDC_DEVICE_LIST));
    }

    return TRUE;
}

BOOL
ChangePriority(
    HWND            hDlg,
    BOOL            bMoveUp
    )
/*++

Routine Description:

    Validate the up and down button in the fax property page

Arguments:

    hDlg - Handle to the fax property sheet page
    bMoveUp -- TRUE for moving up, FALSE for moving down

Return Value:

    TRUE -- if no error
    FALSE -- if error

--*/

{
    INT             iItem;
    BOOL            rslt;
    LVITEM          lv = {0};
    TCHAR           pszText[MAX_DEVICE_NAME];
    TCHAR           szEnableSend[64];           // for enable/disable send text
    TCHAR           szEnableReceive[64];        // for enable/disable receive text
    INT             iDeviceCount;
    HWND            hwndLv;

    hwndLv = GetDlgItem(hDlg, IDC_DEVICE_LIST);

    iDeviceCount = ListView_GetItemCount(hwndLv);

    // 
    // find the current selected Item
    //
    iItem = ListView_GetNextItem(hwndLv, -1, LVNI_ALL | LVNI_SELECTED);

    if(iItem == -1)
    {
        Error(("No device is selected. Can't change priority.\n"));
        return FALSE;
    }

    // 
    // get selected item information and then remove it
    //
    lv.iItem      = iItem;
    lv.iSubItem   = 0;
    lv.mask       = LVIF_TEXT | LVIF_PARAM;
    lv.pszText    = pszText;
    lv.cchTextMax = ARRAYSIZE(pszText);
    ListView_GetItem(hwndLv, &lv);

    ListView_GetItemText(hwndLv, iItem, 1, szEnableSend,    ARRAYSIZE(szEnableSend)); // for send
    ListView_GetItemText(hwndLv, iItem, 2, szEnableReceive, ARRAYSIZE(szEnableReceive)); // for receive

    rslt = ListView_DeleteItem(hwndLv, iItem);

    //
    // recalculate the item index;
    //
    if(bMoveUp)
    {
        lv.iItem--;
    }
    else
    {
        lv.iItem++;
    }

    //
    // reinsert the item and validate button state
    //
    iItem = ListView_InsertItem(hwndLv, &lv);
    ListView_SetItemText(hwndLv, iItem, 1, szEnableSend);
    ListView_SetItemText(hwndLv, iItem, 2, szEnableReceive);

    ListView_SetItemState(hwndLv, iItem, LVIS_SELECTED, LVIS_SELECTED);
    ValidateControl(hDlg, iItem);

    return TRUE;
}

BOOL
DoSaveDeviceList(
    HWND hDlg // window handle of the device info page
    )

/*++

Routine Description:

    Save the list view info to the system

Arguments:

    hDlg - Identifies the property sheet page

Return Value:

    TRUE if successful, FALSE if failed 

--*/

{
    PFAX_PORT_INFO_EX   pFaxPortInfo = NULL;    // receive port information 
    INT                 iItem;
    INT                 iDeviceCount;
    HWND                hwndLv;                 // list view window
    LVITEM              lv;
    DWORD               dwDeviceId;
    DWORD               dwRes = 0;

    Verbose(("Entering DoSaveDeviceList...\n"));
    //
    // Get the list view window handle
    //
    hwndLv = GetDlgItem(hDlg, IDC_DEVICE_LIST);

    if(!Connect(hDlg, TRUE))
    {
        return FALSE;
    }
    //
    // Get total number of fax devices
    //
    iDeviceCount = ListView_GetItemCount(hwndLv);
    //
    // 1st iteration - disabled receive and send devices only
    //
    for(iItem = 0; iItem < iDeviceCount; ++iItem)
    {
        // Get device ID first, then save the changes.
        ZeroMemory(&lv, sizeof(lv));
        lv.iItem = iItem;
        lv.mask  = LVIF_PARAM;
        ListView_GetItem(hwndLv, &lv);

        dwDeviceId = (DWORD)lv.lParam;

        pFaxPortInfo = FindPortInfo(dwDeviceId);
        if(!pFaxPortInfo)
        {
            Error(("FindPortInfo() failed\n"));
            Assert(FALSE);
            continue;
        }
        if (pFaxPortInfo->bSend || (FAX_DEVICE_RECEIVE_MODE_OFF != pFaxPortInfo->ReceiveMode))
        {
            //
            // Fax device is active - skip it for now
            //
            continue;
        }
        if(!FaxSetPortEx(g_hFaxSvcHandle, dwDeviceId, pFaxPortInfo))
        {
            dwRes = GetLastError();
            Error(("FaxSetPortEx() failed with %d.\n", dwRes));
            break;
        }
    }
    //
    // 2nd iteration - enabled receive or send devices only
    //
    for(iItem = 0; iItem < iDeviceCount; ++iItem)
    {
        // Get device ID first, then save the changes.
        ZeroMemory(&lv, sizeof(lv));
        lv.iItem = iItem;
        lv.mask  = LVIF_PARAM;
        ListView_GetItem(hwndLv, &lv);

        dwDeviceId = (DWORD)lv.lParam;

        pFaxPortInfo = FindPortInfo(dwDeviceId);
        if(!pFaxPortInfo)
        {
            Error(("FindPortInfo() failed\n"));
            Assert(FALSE);
            continue;
        }
        if (!pFaxPortInfo->bSend && (FAX_DEVICE_RECEIVE_MODE_OFF == pFaxPortInfo->ReceiveMode))
        {
            //
            // Fax device is inactive - skip it.
            // It was already set in the 1st iteration.
            //
            continue;
        }
        if(!FaxSetPortEx(g_hFaxSvcHandle, dwDeviceId, pFaxPortInfo))
        {
            dwRes = GetLastError();
            Error(("FaxSetPortEx() failed with %d.\n", dwRes));
            break;
        }
    }
    if (!IsDesktopSKU())
    {
        //
        // 3rd iteration.
        // Save send priority, FAX_PORT_INFO_EX doesn't have Priority field, so use FaxSetDeviceOrderInGroup
        // Send priority is only relevant to server SKUs.
        //
        for(iItem = 0; iItem < iDeviceCount; ++iItem)
        {
            // Get device ID first, then save the changes.
            ZeroMemory(&lv, sizeof(lv));
            lv.iItem = iItem;
            lv.mask  = LVIF_PARAM;
            ListView_GetItem(hwndLv, &lv);

            dwDeviceId = (DWORD)lv.lParam;

            pFaxPortInfo = FindPortInfo(dwDeviceId);
            if(!pFaxPortInfo)
            {
                Error(("FindPortInfo() failed\n"));
                Assert(FALSE);
                continue;
            }
            if(!FaxSetDeviceOrderInGroup(g_hFaxSvcHandle, ROUTING_GROUP_ALL_DEVICES, dwDeviceId, iItem + 1))
            {
                dwRes = GetLastError();
                Error(("FaxSetDeviceOrderInGroup() failed with %d.\n", dwRes));
                break;
            }
        }
    }
    DisConnect();

    switch (dwRes)
    {
        case ERROR_SUCCESS:
            //
            // Don't do nothing
            //
            break;

        case FAXUI_ERROR_DEVICE_LIMIT:
        case FAX_ERR_DEVICE_NUM_LIMIT_EXCEEDED:
            //
            // Some additional parameters are needed
            //
            DisplayErrorMessage(hDlg, 0, dwRes, GetDeviceLimit());
            break;

        default:
            DisplayErrorMessage(hDlg, 0, dwRes);
            break;
    }
    return (dwRes == 0);
}   // DoSaveDeviceList

void
DisplayDeviceProperty(
    HWND    hDlg
)

/*++

Routine Description:

    Open a property sheet for a specific device

Arguments:

    hDlg - Identifies the property sheet page

Return Value:

    none

--*/

{
    HWND            hwndLv;
    INT             iDeviceCount;
    INT             iItem;
    TCHAR           szDeviceName[MAX_PATH] = {0};
    PROPSHEETHEADER psh = {0};
    PROPSHEETPAGE   psp[3] = {0};                   // property sheet pages info for device info
    HPROPSHEETPAGE  hPropSheetPages[3];
    LVITEM          lvi = {0};
    DWORD           dw;

    PFAX_PORT_INFO_EX  pFaxPortInfo = NULL; 
    DWORD              dwPortsNum;  

    Verbose(("Entering DisplayDeviceProperty...\n"));

    hwndLv = GetDlgItem(hDlg, IDC_DEVICE_LIST);

    iDeviceCount = ListView_GetItemCount(hwndLv);

    // 
    // find the current selected Item
    //
    iItem = ListView_GetNextItem(hwndLv, -1, LVNI_ALL | LVNI_SELECTED);

    if(iItem == -1)
    {
        Verbose(("No device is selected. Can't display properties.\n"));
        return;
    }

    lvi.iItem      = iItem;
    lvi.mask       = LVIF_PARAM | LVIF_TEXT;
    lvi.pszText    = szDeviceName;
    lvi.cchTextMax = MAX_PATH;

    ListView_GetItem(hwndLv, &lvi);

    //
    // Get an array of property sheet page handles
    //
    psp[0].dwSize      = sizeof(PROPSHEETPAGE);
    psp[0].hInstance   = g_hResource;
    psp[0].pszTemplate = MAKEINTRESOURCE(IDD_SEND_PROP);
    psp[0].pfnDlgProc  = DevSendDlgProc;
    psp[0].lParam      = lvi.lParam;

    psp[1].dwSize      = sizeof(PROPSHEETPAGE);
    psp[1].hInstance   = g_hResource;
    psp[1].pszTemplate = MAKEINTRESOURCE(IDD_RECEIVE_PROP);
    psp[1].pfnDlgProc  = DevRecvDlgProc;
    psp[1].lParam      = lvi.lParam;

    psp[2].dwSize      = sizeof(PROPSHEETPAGE);
    psp[2].hInstance   = g_hResource;
    psp[2].pszTemplate = MAKEINTRESOURCE(IDD_CLEANUP_PROP);
    psp[2].pfnDlgProc  = DevCleanupDlgProc;
    psp[2].lParam      = lvi.lParam;

    hPropSheetPages[0] = CreatePropertySheetPage( &psp[0] );
    hPropSheetPages[1] = CreatePropertySheetPage( &psp[1] );
    if (IsDesktopSKU())
    {
        hPropSheetPages[2] = CreatePropertySheetPage( &psp[2] );
    }

    Assert(hPropSheetPages[0]);
    Assert(hPropSheetPages[1]);
    if (IsDesktopSKU())
    {
        Assert(hPropSheetPages[2]);
    }

    //
    // Fill out PROPSHEETHEADER structure
    //
    psh.dwSize     = sizeof(PROPSHEETHEADER);
    psh.dwFlags    = PSH_USEICONID;
    psh.hwndParent = hDlg;
    psh.hInstance  = g_hResource;
    psh.pszIcon    = MAKEINTRESOURCE(IDI_DEVICE_INFO);
    psh.pszCaption = szDeviceName;
    psh.nPages     = IsDesktopSKU() ? 3 : 2;
    psh.nStartPage = 0;
    psh.phpage     = hPropSheetPages;

    //
    // Display the property sheet
    //
    if(PropertySheet(&psh) == -1)
    {
        Error(( "PropertySheet() failed with %d\n", GetLastError() ));
        return;
    }

    if(!g_bPortInfoChanged)
    {
        return;
    }

    //
    // merge the changes into the g_pFaxPortInfo
    //
    if(Connect(NULL, FALSE))
    {
        if(!FaxEnumPortsEx(g_hFaxSvcHandle, &pFaxPortInfo, &dwPortsNum))
        {
            Error(( "FaxEnumPortsEx failed with %d\n", GetLastError()));
        }

        DisConnect();
    }

    if(!pFaxPortInfo || !dwPortsNum)
    {
        FaxFreeBuffer(pFaxPortInfo);
        return;
    }

    for(dw = 0; dw < dwPortsNum; ++dw)
    {
        PFAX_PORT_INFO_EX  pPortInfo; 

        if(pFaxPortInfo[dw].dwDeviceID == (DWORD)lvi.lParam)
        {
            //
            // Selected device already updated
            //
            continue;
        }

        pPortInfo = FindPortInfo(pFaxPortInfo[dw].dwDeviceID);
        if(!pPortInfo)
        {
            continue;
        }

        pFaxPortInfo[dw].bSend    = pPortInfo->bSend;
        pFaxPortInfo[dw].ReceiveMode = pPortInfo->ReceiveMode;
    }

    FaxFreeBuffer(g_pFaxPortInfo);
    g_pFaxPortInfo = pFaxPortInfo;
    g_dwPortsNum   = dwPortsNum;
    NotifyDeviceUsageChanged ();
    g_bPortInfoChanged = FALSE;
}


BOOL
ShowContextMenu(
    HWND                hDlg
    )

/*++

Routine Description:

    Display the context menu in the device list

Arguments:

    hDlg - Identifies the property sheet page

Return Value:

    TRUE if successful, FALSE if failed 

--*/
{
    DWORD               dwMessagePos;
    DWORD               dwRes;
    BOOL                bVirtual;
    PFAX_PORT_INFO_EX   pFaxPortInfo;

    HMENU hMenu;
    HMENU hSubMenu;
    HMENU hSubSubMenu;

    Verbose(("Entering ShowContextMenu...\n"));

    pFaxPortInfo = GetSelectedPortInfo(hDlg);
    if(!pFaxPortInfo)
    {
        Error(("GetSelectedPortInfo() failed\n"));
        return FALSE;              
    }
    //
    // Load context-sensitive menu
    //
    hMenu = LoadMenu(g_hResource, MAKEINTRESOURCE(IDR_SEND_RECEIVE));
    if(!hMenu)
    {
        Assert(FALSE);
        return FALSE;
    }
    hSubMenu = GetSubMenu(hMenu, 0);
    if(!hSubMenu)
    {
        Assert(FALSE);
        DestroyMenu (hMenu);
        return FALSE;
    }
    //
    // Send
    //
    hSubSubMenu = GetSubMenu(hSubMenu, 0);
    if(!hSubSubMenu)
    {
        Assert(FALSE);
        DestroyMenu (hMenu);
        return FALSE;
    }

    CheckMenuItem(hSubSubMenu, 
                  IDM_SEND_ENABLE,  
                  pFaxPortInfo->bSend ? MF_BYCOMMAND | MF_CHECKED : MF_BYCOMMAND | MF_UNCHECKED);

    CheckMenuItem(hSubSubMenu, 
                  IDM_SEND_DISABLE, 
                  !pFaxPortInfo->bSend ? MF_BYCOMMAND | MF_CHECKED : MF_BYCOMMAND | MF_UNCHECKED);


    //
    // Receive
    //
    hSubSubMenu = GetSubMenu(hSubMenu, 1);
    if(!hMenu)
    {
        Assert(FALSE);
        DestroyMenu (hMenu);
        return FALSE;
    }

    CheckMenuItem(hSubSubMenu, 
                  IDM_RECEIVE_AUTO,  
                  (FAX_DEVICE_RECEIVE_MODE_AUTO == pFaxPortInfo->ReceiveMode) ? 
                    MF_BYCOMMAND | MF_CHECKED : 
                    MF_BYCOMMAND | MF_UNCHECKED);

    CheckMenuItem(hSubSubMenu, 
                  IDM_RECEIVE_MANUAL, 
                  (FAX_DEVICE_RECEIVE_MODE_MANUAL == pFaxPortInfo->ReceiveMode) ? 
                    MF_BYCOMMAND | MF_CHECKED : 
                    MF_BYCOMMAND | MF_UNCHECKED);

    CheckMenuItem(hSubSubMenu, 
                  IDM_RECEIVE_DISABLE, 
                  (FAX_DEVICE_RECEIVE_MODE_OFF == pFaxPortInfo->ReceiveMode) ? 
                    MF_BYCOMMAND | MF_CHECKED : 
                    MF_BYCOMMAND | MF_UNCHECKED);



    if(!Connect(hDlg, TRUE))
    {
        DestroyMenu (hMenu);
        return FALSE;
    }

    dwRes = IsDeviceVirtual (g_hFaxSvcHandle, pFaxPortInfo->dwDeviceID, &bVirtual);
    if (ERROR_SUCCESS != dwRes)
    {
        DestroyMenu (hMenu);
        return FALSE;
    }

    if (bVirtual)
    {
        //
        // If the device is virtual, can't set to to manual answer mode
        //
        Assert (FAX_DEVICE_RECEIVE_MODE_MANUAL != pFaxPortInfo->ReceiveMode);
        EnableMenuItem (hSubSubMenu, IDM_RECEIVE_MANUAL, MF_BYCOMMAND | MF_GRAYED);
    }

    SetMenuDefaultItem(hSubMenu, IDM_PROPERTY, FALSE);

    // Get the cursor position
    dwMessagePos = GetMessagePos();

    // Display the context menu
    TrackPopupMenu(hSubMenu, 
                   TPM_LEFTALIGN | TPM_RIGHTBUTTON, 
                   LOWORD(dwMessagePos), 
                   HIWORD(dwMessagePos), 0, hDlg, NULL);

    DestroyMenu (hMenu);
    DisConnect();
    return TRUE;
}   // ShowContextMenu

INT_PTR 
CALLBACK 
DeviceInfoDlgProc(
    HWND hDlg,  
    UINT uMsg,     
    WPARAM wParam, 
    LPARAM lParam  
)

/*++

Routine Description:

    Procedure for handling the device info tab

Arguments:

    hDlg - Identifies the property sheet page
    uMsg - Specifies the message
    wParam - Specifies additional message-specific information
    lParam - Specifies additional message-specific information

Return Value:

    Depends on the value of message parameter

--*/

{
    switch (uMsg)
    {
    case WM_INITDIALOG :
        { 
            HICON       hIconUp, hIconDown;
            LV_COLUMN   lvc = {0};
            DWORD       dwIndex;
            TCHAR       szBuffer[RESOURCE_STRING_LEN];
            HWND        hwndLv;

            //
            // Load icons.
            //
            hIconUp = LoadIcon(g_hResource, MAKEINTRESOURCE(IDI_UP));
            hIconDown = LoadIcon(g_hResource, MAKEINTRESOURCE(IDI_DOWN));

            // icon handles for up and down arrows.
            SendDlgItemMessage(hDlg, IDC_PRI_UP, BM_SETIMAGE, (WPARAM)IMAGE_ICON, (LPARAM)hIconUp);
            SendDlgItemMessage(hDlg, IDC_PRI_DOWN, BM_SETIMAGE, (WPARAM)IMAGE_ICON, (LPARAM)hIconDown);

            SendDlgItemMessage(hDlg, IDC_TSID, EM_SETLIMITTEXT, TSID_LIMIT, 0);
            SendDlgItemMessage(hDlg, IDC_CSID, EM_SETLIMITTEXT, CSID_LIMIT, 0);

            //
            // Set list view style and columns
            //
            hwndLv = GetDlgItem(hDlg, IDC_DEVICE_LIST);
            ListView_SetExtendedListViewStyle(hwndLv, LVS_EX_FULLROWSELECT);

            lvc.mask    = LVCF_FMT | LVCF_WIDTH | LVCF_TEXT | LVCF_SUBITEM;
            lvc.fmt     = LVCFMT_LEFT;
            lvc.pszText = szBuffer;

            for(dwIndex = 0; dwIndex < ColumnHeaderCount; dwIndex++)
            {
                if(!LoadString(g_hResource, ColumnHeader[dwIndex].uResourceId ,szBuffer, RESOURCE_STRING_LEN))
                {
                    Error(( "LoadString failed, string ID is %d.\n", ColumnHeader[dwIndex].uResourceId ));
                    lstrcpy(szBuffer, TEXT(""));
                }

                lvc.cx       = ColumnHeader[dwIndex].ColumnWidth;
                lvc.iSubItem = (INT)dwIndex;

                ListView_InsertColumn( hwndLv, dwIndex, &lvc );
            }

            DoInitDeviceList(hDlg);
            return TRUE;
            break;
        }

    case WM_COMMAND:

        switch(LOWORD(wParam)) 
        {
            case IDC_PRI_UP:
            case IDC_PRI_DOWN:

                ChangePriority(hDlg, (LOWORD(wParam) == IDC_PRI_UP) ? TRUE : FALSE);
                Notify_Change(hDlg);
                break;

            case IDM_PROPERTY:
            case IDC_DEVICE_PROP:
            {
                HWND    hwndLv;     // handle of the list view window
                INT     iItem = -1; // default value for non client area

                //
                // Get current selected item
                //
                hwndLv = GetDlgItem(hDlg, IDC_DEVICE_LIST);
                iItem  = ListView_GetNextItem(hwndLv, -1, LVNI_ALL | LVNI_SELECTED);

                if(iItem == -1)
                {
                    Verbose(("No device is selected. Can't display device info.\n"));
                    break;
                }

                DisplayDeviceProperty(hDlg);

                // refresh the list view
                UpdateDeviceInfo(hDlg);
                FillInDeviceInfo(hDlg);
                break;
            }


            case IDM_SEND_ENABLE:
            case IDM_SEND_DISABLE:
            case IDM_RECEIVE_AUTO:
            case IDM_RECEIVE_MANUAL:
            case IDM_RECEIVE_DISABLE:
            {
                PFAX_PORT_INFO_EX   pFaxPortInfo;

                pFaxPortInfo = GetSelectedPortInfo(hDlg);
                if(!pFaxPortInfo)
                {
                    Error(("GetSelectedPortInfo() failed\n"));
                    break;                
                }

                if(IDM_SEND_ENABLE    == LOWORD(wParam) ||
                   IDM_RECEIVE_AUTO   == LOWORD(wParam) ||
                   IDM_RECEIVE_MANUAL == LOWORD(wParam))
                {
                    if(!IsDeviceInUse(pFaxPortInfo->dwDeviceID) && 
                       GetDeviceLimit() == CountUsedFaxDevices())
                    {
                        //
                        // Device is *NOT* in use and we're about to make it used and
                        // we're at the limit point.
                        //
                        BOOL bLimitExceeded = TRUE;

                        if (IDM_RECEIVE_MANUAL == LOWORD(wParam))
                        {
                            //
                            // Do one more check: if we make the device manual-answer, let's make sure the 
                            // previous manual-answer device will turn to inactive. If that's the case, we don't exceed
                            // the device limit.
                            //
                            DWORD dw;

                            for (dw = 0; dw < g_dwPortsNum; dw++)
                            {
                                if (FAX_DEVICE_RECEIVE_MODE_MANUAL == g_pFaxPortInfo[dw].ReceiveMode)
                                {
                                    //
                                    // We found the other device who's about to loose its manual-answer mode
                                    //
                                    if (!g_pFaxPortInfo[dw].bSend)
                                    {
                                        //
                                        // This is the special case we were looking for
                                        //
                                        bLimitExceeded = FALSE;
                                    }
                                    break;
                                }
                            }
                        }
                        if (bLimitExceeded)
                        {
                            DisplayErrorMessage(hDlg, 
                                MB_OK | MB_ICONSTOP, 
                                FAXUI_ERROR_DEVICE_LIMIT, 
                                GetDeviceLimit());
                            break;
                        }
                    }
                }

                if(IDM_RECEIVE_MANUAL == LOWORD(wParam))
                {
                    //
                    // Turn off manual-answer for ALL devices.
                    //
                    DWORD dw;

                    for (dw = 0; dw < g_dwPortsNum; dw++)
                    {
                        if (FAX_DEVICE_RECEIVE_MODE_MANUAL == g_pFaxPortInfo[dw].ReceiveMode)
                        {
                            g_pFaxPortInfo[dw].ReceiveMode = FAX_DEVICE_RECEIVE_MODE_OFF;
                        }
                    }
                    //
                    // Turn on manual-answer for selected device only.
                    //
                    pFaxPortInfo->ReceiveMode = FAX_DEVICE_RECEIVE_MODE_MANUAL;
                }
                else if(IDM_RECEIVE_AUTO == LOWORD(wParam))
                {
                    pFaxPortInfo->ReceiveMode = FAX_DEVICE_RECEIVE_MODE_AUTO;
                }
                else if(IDM_RECEIVE_DISABLE == LOWORD(wParam))
                {
                    pFaxPortInfo->ReceiveMode = FAX_DEVICE_RECEIVE_MODE_OFF;
                }
                else if(IDM_SEND_ENABLE  == LOWORD(wParam) ||
                        IDM_SEND_DISABLE == LOWORD(wParam))
                {
                    pFaxPortInfo->bSend = (IDM_SEND_ENABLE == LOWORD(wParam)) ? TRUE : FALSE;
                }
                UpdateDeviceInfo(hDlg);
                FillInDeviceInfo(hDlg);

                Notify_Change(hDlg);
                NotifyDeviceUsageChanged ();
                break;
            }

            default:
                break;
        }

        break;

    case WM_CONTEXTMENU:
        //
        // Also handle keyboard-originated context menu (<Shift>+F10 or VK_APP)
        //
        if (!g_bUserCanChangeSettings)
        {
            //
            // User has no rights to change the device settings - show no menu
            //
            break;
        }
        if (GetDlgItem(hDlg, IDC_DEVICE_LIST) != GetFocus())
        {
            //
            // Only show context sensitive menu if the focus is on the list control
            //
            break;
        }
        if(ListView_GetItemCount(GetDlgItem(hDlg, IDC_DEVICE_LIST)) == 0)
        {
            //
            // If there aren't item in the list, return immediately.
            //
            break;
        }
        //
        // Popup context menu near mouse cursor
        //
        ShowContextMenu(hDlg);
        break;

    case WM_NOTIFY:
    {

        LPNMHDR lpnm = (LPNMHDR) lParam;

        switch (lpnm->code)
        {

            case NM_CLICK:
            case NM_RCLICK:
            {
                //
                // Handle a Click event
                //
                LPNMITEMACTIVATE lpnmitem;

                lpnmitem = (LPNMITEMACTIVATE)lParam;

                if (IDC_DEVICE_LIST != lpnmitem->hdr.idFrom)
                {
                    //
                    // Not our list view control
                    //
                    break;
                }
                //
                // If there aren't item in the list, return immediately.
                //
                if(ListView_GetItemCount(GetDlgItem(hDlg, IDC_DEVICE_LIST)) == 0)
                {
                    break;
                }
                if(lpnmitem->iItem == -1)
                {
                    //
                    // User just un-selected the selected item from the list.
                    // Update the other controls on the dialog
                    //
                    ValidateControl(hDlg, lpnmitem->iItem);
                    FillInDeviceInfo(hDlg);
                }

                break;
            }

            case NM_DBLCLK:
            {
                // do the same thing as clicking the "Properties" button
                SendMessage(hDlg, WM_COMMAND, MAKELONG(IDC_DEVICE_PROP, BN_CLICKED), 0L);
                break;
            }

            case LVN_ITEMCHANGED:
            {
                //
                // need to validate the control after changing selection by keyboard
                // 
                LPNMLISTVIEW pnmv; 

                pnmv = (LPNMLISTVIEW) lParam; 
                if(pnmv->uNewState & LVIS_SELECTED)
                {
                    ValidateControl(hDlg, pnmv->iItem);
                    FillInDeviceInfo(hDlg);
                }

                break;
            }

            case PSN_APPLY:

                if(g_bUserCanChangeSettings)
                {
                    if (DoSaveDeviceList(hDlg))
                    {
                        FillInDeviceInfo(hDlg);
                        Notify_UnChange(hDlg);
                    }
                    else
                    {
                        SetWindowLongPtr(hDlg, DWLP_MSGRESULT, PSNRET_INVALID);
                    }
                }

                return TRUE;

            default :
                break;

        } // switch

        break;
    }

    case WM_HELP:
        WinHelpContextPopup(((LPHELPINFO)lParam)->dwContextId, hDlg);
        return TRUE;

    default:
        break;
    }

    return FALSE;
}
=== C:/Users/treeman/Desktop/windows nt source code\Source\Win2K3\NT\printscan\faxsrv\print\faxprint\faxui\docevent.c ===
/*++

Copyright (c) 1996  Microsoft Corporation

Module Name:

    docevent.c

Abstract:

    Implementation of DrvDocumentEvent

Environment:

    Fax driver user interface

Revision History:

    01/13/96 -davidx-
        Created it.

    mm/dd/yy -author-
        description

--*/


#include "faxui.h"
#include "prtcovpg.h"
#include "jobtag.h"
#include "faxreg.h"
#include "faxsendw.h"
#include "InfoWzrd.h"
#include "tifflib.h"
#include "faxutil.h"
#include "covpg.h"


//
// Defenitions
//
#define SZ_CONT                             TEXT("...")
#define SZ_CONT_SIZE                        (sizeof(SZ_CONT) / sizeof(TCHAR))


//
//	Defined in FaxUI.c 
//	Used to block the reentrancy of FxsWzrd.dll
//
extern	BOOL				g_bRunningWizard;
extern	CRITICAL_SECTION	g_csRunningWizard;
extern	BOOL				g_bInitRunningWizardCS;

//
// Data structure passed in during CREATEDCPRE document event
//


typedef struct 
{
    LPTSTR      pDriverName;    // driver name
    LPTSTR      pPrinterName;   // printer name
    PDEVMODE    pdmInput;       // input devmode
    ULONG       fromCreateIC;   // whether called from CreateIC

} CREATEDCDATA, *PCREATEDCDATA;

//
// Data structure passed in during ESCAPE document event
//

typedef struct 
{
    ULONG       iEscape;        // nEscape parameter passed to ExtEscape
    ULONG       cbInput;        // cbInput parameter passed to ExtEscape
    LPCSTR      pInput;         // pszInData parameter passed to ExtEscape

} ESCAPEDATA, *PESCAPEDATA;

//
// Check if a document event requires a device context
//

#define DocEventRequiresDC(iEsc) \
        ((iEsc) >= DOCUMENTEVENT_RESETDCPRE && (iEsc) <= DOCUMENTEVENT_LAST)

static DWORD LaunchFaxWizard(PDOCEVENTUSERMEM    pDocEventUserMem);
static DWORD ShowReentrancyMessage(void);


static void
ComposeRecipientJobParam(
                LPTSTR lpParamBuf,
                LPDWORD lpdwParamSize,
                const COVERPAGEFIELDS *   pCPFields
                );

static void
ComposeSenderJobParam(
    LPTSTR lpParamBuf,
    LPDWORD lpdwParamSize,
    PDOCEVENTUSERMEM    pDocEventUserMem,
    const COVERPAGEFIELDS *    pCPFields
    );

static BOOL
ComposeFaxJobParameter(
    PDOCEVENTUSERMEM    pDocEventUserMem,
    PCOVERPAGEFIELDS    pCPFields,
    LPTSTR  *           lppParamBuf
    );

static void
CloseMappingHandles(
    PDOCEVENTUSERMEM pDocEventUserMem
    );


PDOCEVENTUSERMEM
GetPDEVUserMem(
    HDC     hdc
    )

/*++

Routine Description:

    Retrieve a pointer to the user mode memory structure associated with a PDEV

Arguments:

    hdc - Specifies the printer device context

Return Value:

    Pointer to user mode memory structure, NULL if there is an error

--*/

{
    PDOCEVENTUSERMEM pDocEventUserMem;

    //
    // Get a pointer to the user mode memory structure associated
    // with the specified device context
    //

    EnterDrvSem();

    pDocEventUserMem = gDocEventUserMemList;

    while (pDocEventUserMem && hdc != pDocEventUserMem->hdc)
        pDocEventUserMem = pDocEventUserMem->pNext;

    LeaveDrvSem();

    //
    // Make sure the user memory structure is valid
    //
    if (pDocEventUserMem) 
    {
        if (! ValidPDEVUserMem(pDocEventUserMem)) 
        {
            Error(("Corrupted user mode memory structure\n"));
            pDocEventUserMem = NULL;
        }
    } 
    else
    {
        Error(("DC has no associated user mode memory structure\n"));
    }
    return pDocEventUserMem;
}


static LRESULT
FaxFreePersonalProfileInformation(
        PFAX_PERSONAL_PROFILE   lpPersonalProfileInfo
    )
{
    if (lpPersonalProfileInfo) 
    {
        MemFree(lpPersonalProfileInfo->lptstrName);
        MemFree(lpPersonalProfileInfo->lptstrFaxNumber);
        MemFree(lpPersonalProfileInfo->lptstrCompany);
        MemFree(lpPersonalProfileInfo->lptstrStreetAddress);
        MemFree(lpPersonalProfileInfo->lptstrCity);
        MemFree(lpPersonalProfileInfo->lptstrState);
        MemFree(lpPersonalProfileInfo->lptstrZip);
        MemFree(lpPersonalProfileInfo->lptstrCountry);
        MemFree(lpPersonalProfileInfo->lptstrTitle);
        MemFree(lpPersonalProfileInfo->lptstrDepartment);
        MemFree(lpPersonalProfileInfo->lptstrOfficeLocation);
        MemFree(lpPersonalProfileInfo->lptstrHomePhone);
        MemFree(lpPersonalProfileInfo->lptstrOfficePhone);
        MemFree(lpPersonalProfileInfo->lptstrEmail);
        MemFree(lpPersonalProfileInfo->lptstrBillingCode);
        MemFree(lpPersonalProfileInfo->lptstrTSID);
    }
    return ERROR_SUCCESS;
}
static LRESULT
FreeRecipientInfo(DWORD * pdwNumberOfRecipients,  PFAX_PERSONAL_PROFILE lpRecipientsInfo)
{
    LRESULT lResult;
    DWORD i;

    Assert(pdwNumberOfRecipients);

    if (*pdwNumberOfRecipients==0)
        return ERROR_SUCCESS;

    Assert(lpRecipientsInfo);

	for(i=0;i<*pdwNumberOfRecipients;i++)
    {
        if (lResult = FaxFreePersonalProfileInformation(&lpRecipientsInfo[i]) != ERROR_SUCCESS)
            return lResult;
    }

    MemFree(lpRecipientsInfo);
	
    *pdwNumberOfRecipients = 0;

    return ERROR_SUCCESS;
}

static DWORD
CopyRecipientInfo(DWORD dwNumberOfRecipients,
                  PFAX_PERSONAL_PROFILE   pfppDestination,
                  PFAX_PERSONAL_PROFILE   pfppSource)
{
    DWORD   dwIndex;

    Assert(pfppDestination);
    Assert(pfppSource);

    for(dwIndex=0;dwIndex<dwNumberOfRecipients;dwIndex++)
    {
        if ((pfppDestination[dwIndex].lptstrName = DuplicateString(pfppSource[dwIndex].lptstrName)) == NULL)
        {
            Error(("Memory allocation failed\n"));
            return ERROR_NOT_ENOUGH_MEMORY;
        }

        if ((pfppDestination[dwIndex].lptstrFaxNumber = DuplicateString(pfppSource[dwIndex].lptstrFaxNumber)) == NULL)
        {
            Error(("Memory allocation failed\n"));
            return ERROR_NOT_ENOUGH_MEMORY;
        }

        Verbose(("Copied %ws from %ws\n", pfppSource[dwIndex].lptstrName,pfppSource[dwIndex].lptstrFaxNumber));
    }
    return ERROR_SUCCESS;
}

static DWORD
CopyPersonalProfileInfo( PFAX_PERSONAL_PROFILE   pfppDestination,
                        PFAX_PERSONAL_PROFILE   pfppSource)
{
/*++

Routine Description:

    Duplicates FAX_PERSONAL_PROFILE structures

Arguments:

    pfppDestination - points to destination structure
    pfppSource - points to source structure

Comments:
    Set pfppDestination->dwSizeOfStruct before call to this function

Return Value:

    ERROR_SUCCESS
    ERROR_INVALID_PARAMETER
    ERROR_NOT_ENOUGH_MEMORY

--*/
    DWORD dwResult = ERROR_SUCCESS;

    Assert(pfppDestination);
    Assert(pfppSource);

    if (!pfppSource || !pfppDestination || (pfppSource->dwSizeOfStruct != sizeof(FAX_PERSONAL_PROFILE))
        || (pfppDestination->dwSizeOfStruct != sizeof(FAX_PERSONAL_PROFILE)))
        return ERROR_INVALID_PARAMETER;

    ZeroMemory(pfppDestination, sizeof(FAX_PERSONAL_PROFILE));

    pfppDestination->dwSizeOfStruct = sizeof(FAX_PERSONAL_PROFILE);

    if (pfppSource->lptstrName && !(pfppDestination->lptstrName = StringDup(pfppSource->lptstrName)))
    {
        dwResult = ERROR_NOT_ENOUGH_MEMORY;
        goto error;
    }
    if (pfppSource->lptstrFaxNumber && !(pfppDestination->lptstrFaxNumber = StringDup(pfppSource->lptstrFaxNumber)))
    {
        dwResult = ERROR_NOT_ENOUGH_MEMORY;
        goto error;
    }
    if (pfppSource->lptstrCompany && !(pfppDestination->lptstrCompany = StringDup(pfppSource->lptstrCompany)))
    {
        dwResult = ERROR_NOT_ENOUGH_MEMORY;
        goto error;
    }
    if (pfppSource->lptstrStreetAddress && !(pfppDestination->lptstrStreetAddress = StringDup(pfppSource->lptstrStreetAddress)))
    {
        dwResult = ERROR_NOT_ENOUGH_MEMORY;
        goto error;
    }
    if (pfppSource->lptstrCity && !(pfppDestination->lptstrCity = StringDup(pfppSource->lptstrCity)))
    {
        dwResult = ERROR_NOT_ENOUGH_MEMORY;
        goto error;
    }
    if (pfppSource->lptstrState && !(pfppDestination->lptstrState = StringDup(pfppSource->lptstrState)))
    {
        dwResult = ERROR_NOT_ENOUGH_MEMORY;
        goto error;
    }
    if (pfppSource->lptstrZip && !(pfppDestination->lptstrZip = StringDup(pfppSource->lptstrZip)))
    {
        dwResult = ERROR_NOT_ENOUGH_MEMORY;
        goto error;
    }
    if (pfppSource->lptstrCountry && !(pfppDestination->lptstrCountry = StringDup(pfppSource->lptstrCountry)))
    {
        dwResult = ERROR_NOT_ENOUGH_MEMORY;
        goto error;
    }
    if (pfppSource->lptstrTitle && !(pfppDestination->lptstrTitle = StringDup(pfppSource->lptstrTitle)))
    {
        dwResult = ERROR_NOT_ENOUGH_MEMORY;
        goto error;
    }
    if (pfppSource->lptstrDepartment && !(pfppDestination->lptstrDepartment = StringDup(pfppSource->lptstrDepartment)))
    {
        dwResult = ERROR_NOT_ENOUGH_MEMORY;
        goto error;
    }
    if (pfppSource->lptstrOfficeLocation && !(pfppDestination->lptstrOfficeLocation = StringDup(pfppSource->lptstrOfficeLocation)))
    {
        dwResult = ERROR_NOT_ENOUGH_MEMORY;
        goto error;
    }
    if (pfppSource->lptstrHomePhone && !(pfppDestination->lptstrHomePhone = StringDup(pfppSource->lptstrHomePhone)))
    {
        dwResult = ERROR_NOT_ENOUGH_MEMORY;
        goto error;
    }
    if (pfppSource->lptstrOfficePhone && !(pfppDestination->lptstrOfficePhone = StringDup(pfppSource->lptstrOfficePhone)))
    {
        dwResult = ERROR_NOT_ENOUGH_MEMORY;
        goto error;
    }
    if (pfppSource->lptstrEmail && !(pfppDestination->lptstrEmail = StringDup(pfppSource->lptstrEmail)))
    {
        dwResult = ERROR_NOT_ENOUGH_MEMORY;
        goto error;
    }
    if (pfppSource->lptstrBillingCode && !(pfppDestination->lptstrBillingCode = StringDup(pfppSource->lptstrBillingCode)))
    {
        dwResult = ERROR_NOT_ENOUGH_MEMORY;
        goto error;
    }
    if (pfppSource->lptstrTSID && !(pfppDestination->lptstrTSID = StringDup(pfppSource->lptstrTSID)))
    {
        dwResult = ERROR_NOT_ENOUGH_MEMORY;
        goto error;
    }

    goto exit;

error:
    MemFree(pfppDestination->lptstrName);
    MemFree(pfppDestination->lptstrFaxNumber);
    MemFree(pfppDestination->lptstrCompany);
    MemFree(pfppDestination->lptstrStreetAddress);
    MemFree(pfppDestination->lptstrCity);
    MemFree(pfppDestination->lptstrState);
    MemFree(pfppDestination->lptstrZip);
    MemFree(pfppDestination->lptstrCountry);
    MemFree(pfppDestination->lptstrTitle);
    MemFree(pfppDestination->lptstrDepartment);
    MemFree(pfppDestination->lptstrOfficeLocation);
    MemFree(pfppDestination->lptstrHomePhone);
    MemFree(pfppDestination->lptstrOfficePhone);
    MemFree(pfppDestination->lptstrEmail);
    MemFree(pfppDestination->lptstrBillingCode);
    MemFree(pfppDestination->lptstrTSID);

exit:
    return dwResult;
}

VOID
FreePDEVUserMem(
    PDOCEVENTUSERMEM    pDocEventUserMem
    )

/*++

Routine Description:

    Free up the user mode memory associated with each PDEV and delete preview file if created.

Arguments:

    pDocEventUserMem - Points to the user mode memory structure

Return Value:

    NONE

--*/

{
    if (pDocEventUserMem) {

        FreeRecipientInfo(&pDocEventUserMem->dwNumberOfRecipients,pDocEventUserMem->lpRecipientsInfo);
        FaxFreePersonalProfileInformation(pDocEventUserMem->lpSenderInfo);

        //
        // Free our mapping file resources (if allocated)
        //
        CloseMappingHandles(pDocEventUserMem);

        //
        // If we created a preview file, and for some reason it wasn't deleted than delete it.
        //
        if (pDocEventUserMem->szPreviewFile[0] != TEXT('\0'))
        {
            if (!DeleteFile(pDocEventUserMem->szPreviewFile))
            {
                Error(("DeleteFile() failed. Error code: %d.\n", GetLastError()));
            }
        }

        MemFree(pDocEventUserMem->lpSenderInfo);
        MemFree(pDocEventUserMem->lptstrServerName);
        MemFree(pDocEventUserMem->lptstrPrinterName);
        MemFree(pDocEventUserMem->pSubject);
        MemFree(pDocEventUserMem->pNoteMessage);
        MemFree(pDocEventUserMem->pPrintFile);
        MemFree(pDocEventUserMem->pReceiptAddress);
        MemFree(pDocEventUserMem->pPriority);
        MemFree(pDocEventUserMem->pReceiptFlags);
        MemFree(pDocEventUserMem);
    }
}


void
CloseMappingHandles(PDOCEVENTUSERMEM pDocEventUserMem)

/*++

Routine Description:

    Free any resources that were used for the preview mapping

Arguments:

    pDocEventUserMem - Points to the user mode memory structure

Return Value: --

--*/

{
    if (pDocEventUserMem->pPreviewTiffPage)
    {
        UnmapViewOfFile(pDocEventUserMem->pPreviewTiffPage);
        pDocEventUserMem->pPreviewTiffPage = NULL;
    }
    if (pDocEventUserMem->hMapping)
    {
        if (!CloseHandle(pDocEventUserMem->hMapping))
        {
            Error(("CloseHandle() failed: %d.\n", GetLastError()));
            // Try to continue...
        }
        pDocEventUserMem->hMapping = NULL;
    }
    if (INVALID_HANDLE_VALUE != pDocEventUserMem->hMappingFile)
    {
        if (!CloseHandle(pDocEventUserMem->hMappingFile))
        {
            Error(("CloseHandle() failed: %d.\n", GetLastError()));
            // Try to continue...
        }
        pDocEventUserMem->hMappingFile = INVALID_HANDLE_VALUE;
    }
}


DWORD
CreateTiffPageMapping(PDOCEVENTUSERMEM pDocEventUserMem)

/*++

Routine Description:

    Creates a temperary file of size MAX_TIFF_PAGE_SIZE, and maps a view to it. This mapping serves
    as a communication channel between the UI and Graphics driver parts to transfer preview pages.

    The page starts with a MAP_TIFF_PAGE_HEADER structure that has the following fields:
        cb         - The structure size
        dwDataSize - The number of bytes of the raw TIFF data constructing the next page
        iPageCount - The page number currently printed
        bPreview   - TRUE if everything until now is OK. FALSE if print preview is disabled or
                     aborted (by either driver parts).

    The cb and iPageCount fields are used to validate the mapping: cb should always be the structure
    size and iPageCount should be the same as our internal page count (pDocEventUserMem->pageCount)
    when a new page is retrieved.
    The bPreview field is used to abort the print preview operation by either driver parts.

    This function sets the hMappingFile, hMapping, pPreviewTiffPage and devmode.dmPrivate.szMappingFile
    fields of the user memory structure according to success / failure.

Arguments:

    pDocEventUserMem - Points to the user mode memory structure

Return Value:

    Win32 Error codes

--*/

{
    TCHAR szTmpPath[MAX_PATH];
    DWORD dwRet = ERROR_SUCCESS;
    LPTSTR pszMappingFile = pDocEventUserMem->devmode.dmPrivate.szMappingFile;
    UINT uRet;

    //
    // Invalidate all mapping handles
    //
    pDocEventUserMem->hMappingFile = INVALID_HANDLE_VALUE;
    pDocEventUserMem->hMapping = NULL;
    pDocEventUserMem->pPreviewTiffPage = NULL;

    //
    // Create the path for our mapping file. This path HAS to be under the system32
    // directory or the kernel driver (NT4) won't be able to map the file. My choice is:
    // '%WinDir%\system32\'
    //
    uRet = GetSystemDirectory(szTmpPath, MAX_PATH);
    if (!uRet)
    {
        dwRet = GetLastError();
        goto ErrExit;
    }

    //    
    // Look for %windir%\system32\FxsTmp folder that is created by Setup.
    //
    if (wcslen(szTmpPath) +
        wcslen(FAX_PREVIEW_TMP_DIR) >= MAX_PATH)
    {
        dwRet = ERROR_BUFFER_OVERFLOW;
        goto ErrExit;
    }
    wcscat(szTmpPath, FAX_PREVIEW_TMP_DIR);

    //
    // Create a NEW file
    //
    if (!GetTempFileName(szTmpPath, FAX_PREFIX, 0, pszMappingFile))
    {
        dwRet = GetLastError();
        Error(("GetTempFileName() failed:%d\n", dwRet));
        goto ErrExit;
    }    
    
    //
    // Open the new file with shared read / write / delete privileges and FILE_FLAG_DELETE_ON_CLOSE
    // attribute
    //
    if ( INVALID_HANDLE_VALUE == (pDocEventUserMem->hMappingFile = SafeCreateTempFile(
                pszMappingFile,
                GENERIC_READ | GENERIC_WRITE,
                FILE_SHARE_READ | FILE_SHARE_WRITE,
                NULL,
                OPEN_EXISTING,
                FILE_ATTRIBUTE_TEMPORARY | FILE_FLAG_DELETE_ON_CLOSE,
                NULL)))
    {
        dwRet = GetLastError();
        Error(("CreateFile() failed: %d.\n", dwRet));
        if (!DeleteFile(pszMappingFile))
        {
            Error(("DeleteFile() failed: %d.\n", GetLastError()));
        }       
        goto ErrExit;
    }

    //
    // Extend the file size to MAX_TIFF_PAGE_SIZE
    //
    dwRet = SetFilePointer(
                    pDocEventUserMem->hMappingFile,
                    MAX_TIFF_PAGE_SIZE,
                    NULL,
                    FILE_BEGIN);
    if (INVALID_SET_FILE_POINTER == dwRet)
    {
        dwRet = GetLastError();
        Error(("SetFilePointer() failed:%d\n", dwRet));
        goto ErrExit;
    }
    if (!SetEndOfFile(pDocEventUserMem->hMappingFile))
    {
        dwRet = GetLastError();
        Error(("SetEndOfFile() failed:%d\n", dwRet));
        goto ErrExit;
    }

    //
    // Create a file mapping of the whole file
    //
    pDocEventUserMem->hMapping = CreateFileMapping(
        pDocEventUserMem->hMappingFile,         // handle to file
        NULL,                                   // security
        PAGE_READWRITE,                         // protection
        0,                                      // high-order DWORD of size
        0,                                      // low-order DWORD of size
        NULL                                    // object name
        );
    if (pDocEventUserMem->hMapping == NULL)
    {
        dwRet = GetLastError();
        Error(("File mapping failed:%d\n", dwRet));
        goto ErrExit;
    }

    //
    // Open a view
    //
    pDocEventUserMem->pPreviewTiffPage = (PMAP_TIFF_PAGE_HEADER) MapViewOfFile(
        pDocEventUserMem->hMapping,         // handle to file-mapping object
        FILE_MAP_WRITE,                     // access mode
        0,                                  // high-order DWORD of offset
        0,                                  // low-order DWORD of offset
        0                                   // number of bytes to map
        );
    if (NULL == pDocEventUserMem->pPreviewTiffPage)
    {
        dwRet = GetLastError();
        Error(("MapViewOfFile() failed:%d\n", dwRet));
        goto ErrExit;
    }

    //
    // Success - set initial header information
    //
    pDocEventUserMem->pPreviewTiffPage->bPreview = FALSE;
    pDocEventUserMem->pPreviewTiffPage->cb = sizeof(MAP_TIFF_PAGE_HEADER);
    pDocEventUserMem->pPreviewTiffPage->dwDataSize = 0;
    pDocEventUserMem->pPreviewTiffPage->iPageCount = 0;
    return ERROR_SUCCESS;

ErrExit:

    //
    // Cleanup
    //
    // IMPORTANT: Set mapping file name to empty string. This signals the graphics dll that
    // there is no mapping file.
    //
    CloseMappingHandles(pDocEventUserMem);
    pszMappingFile[0] = TEXT('\0');
    return dwRet;
}


INT
DocEventCreateDCPre(
    HANDLE        hPrinter,
    HDC           hdc,
    PCREATEDCDATA pCreateDCData,
    PDEVMODE     *ppdmOutput
    )

/*++

Routine Description:

    Handle CREATEDCPRE document event

Arguments:

    hPrinter - Handle to the printer object
    hdc - Specifies the printer device context
    pCreateDCData - Pointer to CREATEDCDATA structure passed in from GDI
    ppdmOutput - Buffer for returning a devmode pointer

Return Value:

    Return value for DrvDocumentEvent

--*/
{
    PDOCEVENTUSERMEM    pDocEventUserMem = NULL;
    PPRINTER_INFO_2     pPrinterInfo2 = NULL;
    DWORD               dwRes;
    DWORD               dwEnvSize;

    Assert(pCreateDCData);
    Assert(ppdmOutput);

    Verbose(("Document event: CREATEDCPRE%s\n", pCreateDCData->fromCreateIC ? "*" : ""));
    *ppdmOutput = NULL;

    //
    // Allocate space for user mode memory data structure
    //

    if (((pDocEventUserMem = MemAllocZ(sizeof(DOCEVENTUSERMEM))) == NULL))
    {
        Error(("Memory allocation failed\n"));
        goto Error;
    }

    ZeroMemory(pDocEventUserMem, sizeof(DOCEVENTUSERMEM));

    if ((pPrinterInfo2 = MyGetPrinter(hPrinter, 2)) == NULL ||
        (pDocEventUserMem->lptstrPrinterName = DuplicateString(pPrinterInfo2->pPrinterName)) == NULL)
    {
        Error(("Memory allocation failed\n"));
        goto Error;
    }

    if (pPrinterInfo2->pServerName==NULL)
    {
        pDocEventUserMem->lptstrServerName = NULL;
    }
    else
    {
        LPTSTR pServerName = pPrinterInfo2->pServerName;

        //
        // Truncate prefix backslashes
        //
        while (*pServerName == TEXT('\\'))
        {
            pServerName++;
        }
        //
        // Save the server name
        //
        if ((pDocEventUserMem->lptstrServerName = DuplicateString(pServerName)) == NULL)
        {
            Error(("Memory allocation failed\n"));
            goto Error;
        }
    }

    //
    // Merge the input devmode with the driver and system defaults
    //

    pDocEventUserMem->hPrinter = hPrinter;

    GetCombinedDevmode(&pDocEventUserMem->devmode,
                        pCreateDCData->pdmInput, hPrinter, pPrinterInfo2, FALSE);
    Verbose(("Document event: CREATEDCPRE %x\n", pDocEventUserMem));
    MemFree(pPrinterInfo2);
    pPrinterInfo2 = NULL;

    //
    // Special code path for EFC server printing - if FAXDM_EFC_SERVER bit is
    // set in DMPRIVATE.flags, then we'll bypass the fax wizard and let the
    // job through without any intervention.
    //
    //
    // The above comment is not accurate. The flag that turns off the wizard is
    // FAXMDM_NO_WIZARD.
    // This flag is set in the private DEVMODE area (flags field) by FaxStartPrintJob.
    // FaxStartPrintJob already has all the information that the wizard usually provides and it
    // wishes the wizard to not show up. To do that it sets this field and passes the
    // job parameters in the JOB_INFO_2.pParameters string as a tagged string.
    // Note that this is not the same case as when StartDoc is called with a output file name specified.
    // In this case the wizard is not brought up as well.
    //
    if (pDocEventUserMem->devmode.dmPrivate.flags & FAXDM_NO_WIZARD) 
    {
        pDocEventUserMem->directPrinting = TRUE;
    }
    //
    // if printing a fax attachment then enable direct printing
    //
    dwEnvSize = GetEnvironmentVariable( FAX_ENVVAR_PRINT_FILE, NULL, 0 );
    if (dwEnvSize)
    {
        pDocEventUserMem->pPrintFile = (LPTSTR) MemAllocZ( dwEnvSize * sizeof(TCHAR) );
        if (NULL == pDocEventUserMem->pPrintFile)
        {
            Error(("Memory allocation failed\n"));
            goto Error;
        }

        if (0 == GetEnvironmentVariable( FAX_ENVVAR_PRINT_FILE, pDocEventUserMem->pPrintFile, dwEnvSize ))
        {
            Error(("GetEnvironmentVariable failed\n"));
            MemFree (pDocEventUserMem->pPrintFile);
            pDocEventUserMem->pPrintFile = NULL;
            goto Error;
        }
        pDocEventUserMem->bAttachment = TRUE;
        pDocEventUserMem->directPrinting = TRUE;
    }

    //
    // Create a memory mapped file that will serve as a commincation chanel between both
    // driver parts. This file will provide means of transfering rendered TIFF pages for
    // print preview if it was required by the user
    //
    dwRes = CreateTiffPageMapping(pDocEventUserMem);
    if (ERROR_SUCCESS != dwRes)
    {
        Error(("CreateTiffPageMapping() failed: %d\n", dwRes));
        //
        // We can still continue, but print preview won't be available...
        //
        pDocEventUserMem->bShowPrintPreview = FALSE;
        pDocEventUserMem->bPreviewAborted = TRUE;
    }
    else
    {
        pDocEventUserMem->bShowPrintPreview = TRUE;
        pDocEventUserMem->bPreviewAborted = FALSE;
    }
    //
    // Initialize the TIFF preview file fields
    //
    pDocEventUserMem->szPreviewFile[0] = TEXT('\0');
    pDocEventUserMem->hPreviewFile = INVALID_HANDLE_VALUE;
    //
    // Mark the private fields of our devmode
    //
    //@
    //@ DocEventUserMem.Siganture is allways &DocEventUserMem
    //@ DocEventUserMem.Signature.DocEventUserMem.Signature is allways &DocEventUserMem
    //@ ValidPDEVUserMem checks for this.
    //@
    MarkPDEVUserMem(pDocEventUserMem);
    //@
    //@ This make the driver use the devmode we merged instaed of the
    //@ devmode specified by the caller to CreateDC.
    //@ This way we make sure the driver gets a DEVMODE with per user
    //@ default (W2K) or just hard-code defaults (NT4) for all the fields
    //@ that were not speicified or invalid in the input devmode.
    //@ Note that the system passes to the driver a COPY of the devmode structure
    //@ we return and NOT a pointer to it.
    //@
    *ppdmOutput = (PDEVMODE) &pDocEventUserMem->devmode;
    return DOCUMENTEVENT_SUCCESS;

Error:
    MemFree(pPrinterInfo2);
    if (pDocEventUserMem)
    {
        MemFree(pDocEventUserMem->lptstrPrinterName);
        MemFree(pDocEventUserMem->lptstrServerName);
        MemFree(pDocEventUserMem);
    }
    return DOCUMENTEVENT_FAILURE;
}


INT
DocEventResetDCPre(
    HDC         hdc,
    PDOCEVENTUSERMEM    pDocEventUserMem,
    PDEVMODE    pdmInput,
    PDEVMODE   *ppdmOutput
    )

/*++

Routine Description:

    Handle RESETDCPRE document event

Arguments:

    hdc - Specifies the printer device context
    pDocEventUserMem - Points to the user mode memory of DocEvent structure
    pdmInput - Points to the input devmode passed to ResetDC
    ppdmOutput - Buffer for returning a devmode pointer

Return Value:

    Return value for DrvDocumentEvent

--*/

{
    if (pdmInput == (PDEVMODE) &pDocEventUserMem->devmode) 
    {

        //
        // ResetDC was called by ourselves - assume the devmode is already valid
        //
    } 
    else 
    {
        //
        // Merge the input devmode with driver and system default
        //
        GetCombinedDevmode(&pDocEventUserMem->devmode,
            pdmInput, pDocEventUserMem->hPrinter, NULL, TRUE);
        //
        // Mark the private fields of our devmode
        //
        MarkPDEVUserMem(pDocEventUserMem);
    }
    *ppdmOutput = (PDEVMODE) &pDocEventUserMem->devmode;
    return DOCUMENTEVENT_SUCCESS;
}


BOOL
IsPrintingToFile(
    LPCTSTR     pDestStr
    )

/*++

Routine Description:

    Check if the destination of a print job is a file.

Arguments:

    pDestStr - Job destination specified in DOCINFO.lpszOutput

Return Value:

    TRUE if the destination is a disk file, FALSE otherwise

--*/

{
    DWORD   fileAttrs;
    HANDLE  hFile;

    //
    // If the destination is NULL, then we're not printing to file
    //
    // Otherwise, attempt to use the destination string as the name of a file.
    // If we failed to get file attributes or the name refers to a directory,
    // then we're not printing to file.
    //

    if (pDestStr == NULL)
    {
        return FALSE;
    }
    //
    //  make sure it's not a directory
    //
    fileAttrs = GetFileAttributes(pDestStr);
    if (fileAttrs != 0xffffffff)
    {
        if (fileAttrs & FILE_ATTRIBUTE_DIRECTORY)
        {
            return FALSE;
        }
    }
    //
    // check if file exists...if it doesn't try to create it.
    //
    hFile = SafeCreateFile(pDestStr, 0, 0, NULL, OPEN_EXISTING, 0, NULL);
    if (hFile == INVALID_HANDLE_VALUE)
    {
        hFile = SafeCreateFile(pDestStr, 0, 0, NULL, CREATE_NEW, 0, NULL);
        if (hFile == INVALID_HANDLE_VALUE)
        {
            return FALSE;
        }
    }
    //
    // Verifiy that we did not opened a port handle
    //
    fileAttrs = GetFileAttributes(pDestStr);
    if (!CloseHandle(hFile))
    {
        Error(("CloseHandle() failed: %d.\n", GetLastError()));
        // Try to continue...
    }
    if (0xffffffff == fileAttrs)
    {
        //
        // pDestStr does not point to a valid file
        //
        return FALSE;
    }
    //
    // it must be a file
    //
    return TRUE;
}

DWORD LaunchFaxWizard(PDOCEVENTUSERMEM    pDocEventUserMem)
{
    DWORD                   hWndOwner = 0;
    DWORD                   dwFlags  = 0;
    LPFAX_SEND_WIZARD_DATA  lpInitialData = NULL;
    LPFAX_SEND_WIZARD_DATA  lpFaxSendWizardData = NULL;
    INT                     iResult;
	TCHAR                   tszNumericData[10]={0};
    DWORD                   ec = ERROR_SUCCESS;
    HRESULT                 hRc;

    if ( !(lpFaxSendWizardData = MemAllocZ(sizeof(FAX_SEND_WIZARD_DATA))) ||
            !(lpInitialData = MemAllocZ(sizeof(FAX_SEND_WIZARD_DATA))) )
    {
        ec = GetLastError();
        Error(("Memory allocation failed\n"));
        goto Error;
    }

    ZeroMemory(lpInitialData, sizeof(FAX_SEND_WIZARD_DATA));
    lpInitialData->dwSizeOfStruct = sizeof(FAX_SEND_WIZARD_DATA);
    lpInitialData->dwPageCount =  pDocEventUserMem->pageCount;

    ZeroMemory(lpFaxSendWizardData, sizeof(FAX_SEND_WIZARD_DATA));
    lpFaxSendWizardData->dwSizeOfStruct = sizeof(FAX_SEND_WIZARD_DATA);


    // prepare structures and parameters
    lpInitialData->tmSchedule.wHour = pDocEventUserMem->devmode.dmPrivate.sendAtTime.Hour;
    lpInitialData->tmSchedule.wMinute = pDocEventUserMem->devmode.dmPrivate.sendAtTime.Minute;
    lpInitialData->lptstrPreviewFile = StringDup(pDocEventUserMem->szPreviewFile);
    if (!lpInitialData->lptstrPreviewFile)
    {
        ec = GetLastError();
        Error(("StringDup() failed (ec: %ld)",ec));
        goto Error;
    }


    if (GetEnvironmentVariable(TEXT("NTFaxSendNote"), NULL, 0))
    {
        dwFlags |=  FSW_USE_SEND_WIZARD | FSW_FORCE_COVERPAGE;
    }

    // If the file mapping succeeded enable the preview option
    if (pDocEventUserMem->pPreviewTiffPage &&
        FALSE == pDocEventUserMem->bPreviewAborted)
    {
        dwFlags |= FSW_PRINT_PREVIEW_OPTION;
    }

    iResult = DOCUMENTEVENT_SUCCESS;

    hRc = FaxSendWizard( hWndOwner,
                         dwFlags,
                         pDocEventUserMem->lptstrServerName,
                         pDocEventUserMem->lptstrPrinterName,
                         lpInitialData,
                         pDocEventUserMem->tstrTifName,
                         ARR_SIZE(pDocEventUserMem->tstrTifName),
                         lpFaxSendWizardData );
    {
            }

    if (S_FALSE == hRc)
    {
        ec = ERROR_CANCELLED;
        goto Error; // This is not really an error
    }

    if (S_OK != hRc)
    {
        Error(("FaxSendWizard() failed (hRc: %ld)",hRc));
        ec = ERROR_GEN_FAILURE;
        goto Error;
    }

    //
    // Unpack result structures:
    //

    pDocEventUserMem->devmode.dmPrivate.sendAtTime.Hour = lpFaxSendWizardData->tmSchedule.wHour ;
    pDocEventUserMem->devmode.dmPrivate.sendAtTime.Minute = lpFaxSendWizardData->tmSchedule.wMinute ;
    pDocEventUserMem->devmode.dmPrivate.whenToSend = lpFaxSendWizardData->dwScheduleAction;


    Assert ((lpFaxSendWizardData->Priority >= FAX_PRIORITY_TYPE_LOW) &&
                (lpFaxSendWizardData->Priority <= FAX_PRIORITY_TYPE_HIGH));
        if (0 > _snwprintf (tszNumericData,
                            sizeof (tszNumericData) / sizeof (tszNumericData[0]) - 1,
                            TEXT("%d"),
                            lpFaxSendWizardData->Priority))
        {
            ec = ERROR_BUFFER_OVERFLOW;
            goto Error;
        }

        pDocEventUserMem->pPriority = DuplicateString(tszNumericData);
        if (!pDocEventUserMem->pPriority)
        {
            ec = GetLastError();
            goto Error;
        }

        if (0 > _snwprintf (tszNumericData,
                            sizeof (tszNumericData) / sizeof (tszNumericData[0]) - 1,
                            TEXT("%d"),
                            lpFaxSendWizardData->dwReceiptDeliveryType))
        {
            ec = ERROR_BUFFER_OVERFLOW;
            goto Error;
        }

        pDocEventUserMem->pReceiptFlags = DuplicateString(tszNumericData);
        if (!pDocEventUserMem->pReceiptFlags)
        {
            ec = GetLastError();
            goto Error;
        }

        if (lpFaxSendWizardData->szReceiptDeliveryAddress)
        {
            if (!(pDocEventUserMem->pReceiptAddress
                    = DuplicateString(lpFaxSendWizardData->szReceiptDeliveryAddress)))
            {
                ec = GetLastError();
                Error(("DuplicateString() failed (ec: %ld)",ec));
                goto Error;
            }
        }
    if (lpFaxSendWizardData->lpSenderInfo->lptstrBillingCode)
        _tcscpy(pDocEventUserMem->devmode.dmPrivate.billingCode,
            lpFaxSendWizardData->lpSenderInfo->lptstrBillingCode);

    if (lpFaxSendWizardData->lpCoverPageInfo->lptstrCoverPageFileName)
        _tcscpy(pDocEventUserMem->coverPage,
            lpFaxSendWizardData->lpCoverPageInfo->lptstrCoverPageFileName );
    pDocEventUserMem->bServerCoverPage =
        lpFaxSendWizardData->lpCoverPageInfo->bServerBased;

    if (lpFaxSendWizardData->lpCoverPageInfo->lptstrSubject)
    {
        if (!(pDocEventUserMem->pSubject
                = DuplicateString(lpFaxSendWizardData->lpCoverPageInfo->lptstrSubject)))
        {
            ec = GetLastError();
            Error(("DuplicateString() failed (ec: %ld)",ec));
            goto Error;
        }
    }
    if (lpFaxSendWizardData->lpCoverPageInfo->lptstrNote)
    {
        if (!(pDocEventUserMem->pNoteMessage
                = DuplicateString(lpFaxSendWizardData->lpCoverPageInfo->lptstrNote)))
        {
            ec = GetLastError();
            Error(("DuplicateString() failed (ec: %ld)",ec));
            goto Error;
        }
    }

    Assert(lpFaxSendWizardData->dwNumberOfRecipients);
    pDocEventUserMem->dwNumberOfRecipients = lpFaxSendWizardData->dwNumberOfRecipients;

    if (!SetEnvironmentVariable( _T("ScanTifName"), pDocEventUserMem->tstrTifName ))
    {
        Error(("SetEnvironmentVariable failed. ec = 0x%X",GetLastError()));
    }

    // copy recipients
    if ( pDocEventUserMem->dwNumberOfRecipients && (pDocEventUserMem->lpRecipientsInfo =
        MemAllocZ(sizeof(FAX_PERSONAL_PROFILE)*pDocEventUserMem->dwNumberOfRecipients)) == NULL)
    {
        ec = GetLastError();
        Error(("Memory allocation failed (ec: %ld)",ec));
        goto Error;
    }

    if ((ec = CopyRecipientInfo(pDocEventUserMem->dwNumberOfRecipients,
                                     pDocEventUserMem->lpRecipientsInfo,
                                     lpFaxSendWizardData->lpRecipientsInfo)) != ERROR_SUCCESS)
    {

        Error(("CopyRecipientInfo failed (ec: %ld)",ec));
        goto Error;
    }

    if (lpFaxSendWizardData->lpSenderInfo)
    {
        if ((pDocEventUserMem->lpSenderInfo = MemAllocZ(sizeof(FAX_PERSONAL_PROFILE))) == NULL)
        {

            ec = GetLastError();
            Error(("MemAlloc() failed (ec: %ld)",ec));
            goto Error;
        }
        pDocEventUserMem->lpSenderInfo->dwSizeOfStruct = sizeof(FAX_PERSONAL_PROFILE);
        if ((ec = CopyPersonalProfileInfo(   pDocEventUserMem->lpSenderInfo,
                                             lpFaxSendWizardData->lpSenderInfo)) != ERROR_SUCCESS)
        {
            Error(("CopyRecipientInfo failed (ec: %ld)", ec));
            goto Error;
        }

    }

    Assert(pDocEventUserMem->lpRecipientsInfo);
    pDocEventUserMem->jobType = JOBTYPE_NORMAL;
    Assert(ERROR_SUCCESS == ec);
    goto Exit;
Error:
    Assert(ERROR_SUCCESS != ec);
    FreeRecipientInfo(&pDocEventUserMem->dwNumberOfRecipients,pDocEventUserMem->lpRecipientsInfo);
	pDocEventUserMem->lpRecipientsInfo = NULL;
    FaxFreePersonalProfileInformation(pDocEventUserMem->lpSenderInfo);
    MemFree(pDocEventUserMem->lpSenderInfo);
	pDocEventUserMem->lpSenderInfo = NULL;
    MemFree(pDocEventUserMem->pSubject);
	pDocEventUserMem->pSubject = NULL;
    MemFree(pDocEventUserMem->pNoteMessage);
	pDocEventUserMem->pNoteMessage = NULL;
    MemFree(pDocEventUserMem->pPrintFile);
	pDocEventUserMem->pPrintFile = NULL;
    MemFree(pDocEventUserMem->pReceiptAddress);
	pDocEventUserMem->pReceiptAddress = NULL;
    MemFree(pDocEventUserMem->pPriority);
	pDocEventUserMem->pPriority = NULL;
    MemFree(pDocEventUserMem->pReceiptFlags);
	pDocEventUserMem->pReceiptFlags = NULL;

Exit:
    if (lpInitialData) 
    {
         //
         // Note: One should NOT call FaxFreeSendWizardData on lpInitialData.
         //       The reason is that FaxSendWizard used a different allocator
         //       then we do. Thus we just free the individual fields we
         //       allocated.
         MemFree(lpInitialData->lptstrPreviewFile);
    }
    FaxFreeSendWizardData(lpFaxSendWizardData);
    MemFree (lpInitialData);
    MemFree (lpFaxSendWizardData);
    return ec;
}


INT
DocEventStartDocPre(
    HDC         hdc,
    PDOCEVENTUSERMEM    pDocEventUserMem,
    LPDOCINFO   pDocInfo
    )

/*++

Routine Description:

    Handle STARTDOCPRE document event.

    This events occurs when StartDoc is called. GDI will call this event just before calling kernel mode GDI.

    If the printing is to a file:
        set the job type to JOBTYPE_DIRECT (pDocEventUserMem->JobType)
        and return successfully with DOCUMENTEVENT_SUCCESS.
    If the printing is not to a file:
        Bring up the send fax wizard.
        The send fax wizard will update the relevant pUserMem members for recipient list, subject, note , etc.
        Indicate that this is a normal job be setting
        pDocEventUserMem->jobType = JOBTYPE_NORMAL;


Arguments:

    hdc - Specifies the printer device context
    pDocEventUserMem - Points to the user mode memory structure
    pDocInfo - Points to DOCINFO structure that was passed in from GDI

Return Value:

    Return value for DrvDocumentEvent

--*/

{
    //
    // Initialize user mode memory structure
    //

    DWORD                   hWndOwner = 0;
    DWORD                   dwFlags  = 0;

    pDocEventUserMem->pageCount = 0;
    FreeRecipientInfo(&pDocEventUserMem->dwNumberOfRecipients,pDocEventUserMem->lpRecipientsInfo);

    //
    // Present the fax wizard here if necessary
    //
    //
    //If DOCINFO has a file name specified and this is indeed a file name
    //(not a directory or something like LPT1:) then we need to print directly to the
    //file and we do not bring up the send wizard.
    //

    if (pDocInfo && IsPrintingToFile(pDocInfo->lpszOutput))
    {

        //
        // Printing to file case: don't get involved
        //

        Warning(("Printing direct: %ws\n", pDocInfo->lpszOutput));
        pDocEventUserMem->jobType = JOBTYPE_DIRECT;
        pDocEventUserMem->directPrinting = TRUE;

    }
    else
    {
        //
        // Normal fax print job. Present the send fax wizard.
        // If the user selected cancel, then return -2 to GDI.
        //
        //
        // The wizard will update information in pUserMem.
        // This includes the recipient list , selected cover page, subject text , note text
        // and when to print the fax.
        //

        //
        // Make sure we don't leave any open files
        //
        if (INVALID_HANDLE_VALUE != pDocEventUserMem->hPreviewFile)
        {
            //
            // We should never get here with an open file handle. But if so, close the handle
            // (TODO: This file will be opened with delete on close).
            //
            Assert(FALSE);
            CloseHandle(pDocEventUserMem->hPreviewFile);
            pDocEventUserMem->hPreviewFile = INVALID_HANDLE_VALUE;
        }

        //
        // Create a temporary TIFF file for preview
        //
        if (FALSE == pDocEventUserMem->bPreviewAborted)
        {
            if (GenerateUniqueFileName(
                                NULL,   // Create in the system temporary directory
                                FAX_TIF_FILE_EXT,
                                pDocEventUserMem->szPreviewFile,
                                MAX_PATH))
            {
                pDocEventUserMem->hPreviewFile = CreateFile(
                                                    pDocEventUserMem->szPreviewFile,
                                                    GENERIC_WRITE,
                                                    0,
                                                    NULL,
                                                    OPEN_EXISTING,
                                                    FILE_ATTRIBUTE_TEMPORARY,
                                                    NULL);
                if (INVALID_HANDLE_VALUE != pDocEventUserMem->hPreviewFile)
                {
                    //
                    // Success. Signal the graphics driver we want print preview
                    //

                    // If we enabled the preview option to the user it means everything is OK
                    Assert(pDocEventUserMem->pPreviewTiffPage);
                    pDocEventUserMem->pPreviewTiffPage->bPreview = TRUE;
                    pDocEventUserMem->bShowPrintPreview = TRUE;
                }
                else
                {
                    Error(("Failed opening file.Error: %d.\n", GetLastError()));
                    if (!DeleteFile(pDocEventUserMem->szPreviewFile))
                    {
                        Error(("DeleteFile() failed: %d.\n", GetLastError()));
                    }
                }
            }
            else
            {
                Error(("Failed creating temporary preview file\n"));
            }

            //
            // If we failed creating the file abort preview operation
            //
            if (INVALID_HANDLE_VALUE == pDocEventUserMem->hPreviewFile)
            {
                //
                // Set file name to empty string so we won't try to delete the file twice when
                // the DC is deleted
                //
                pDocEventUserMem->szPreviewFile[0] = TEXT('\0');

                //
                // Abort preview (note that the preview is still disabled in the mapping).
                //
                pDocEventUserMem->bPreviewAborted = TRUE;
            }
        }

        pDocEventUserMem->jobType = JOBTYPE_NORMAL;
    }

    return DOCUMENTEVENT_SUCCESS;
}


DWORD
FaxTimeToJobTime(
    DWORD   faxTime
    )

/*++

Routine Description:

    Convert fax time to spooler job time:
        Fax time is a DWORD whose low-order WORD represents hour value and
        high-order WORD represents minute value. Spooler job time is a DWORD
        value expressing minutes elapsed since 12:00 AM GMT.

Arguments:

    faxTime - Specifies the fax time to be converted

Return Value:

    Spooler job time corresponding to the input fax time

--*/

{
    TIME_ZONE_INFORMATION   timeZoneInfo;
    LONG                    jobTime;

    //
    // Convert fax time to minutes pass midnight
    //

    jobTime = LOWORD(faxTime) * 60 + HIWORD(faxTime);

    //
    // Take time zone information in account - Add one full
    // day to take care of the case where the bias is negative.
    //

    switch (GetTimeZoneInformation(&timeZoneInfo)) {

    case TIME_ZONE_ID_DAYLIGHT:

        jobTime += timeZoneInfo.DaylightBias;

    case TIME_ZONE_ID_STANDARD:
    case TIME_ZONE_ID_UNKNOWN:

        jobTime += timeZoneInfo.Bias + MINUTES_PER_DAY;
        break;

    default:

        Error(("GetTimeZoneInformation failed: %d\n", GetLastError()));
        break;
    }

    //
    // Make sure the time value is less than one day
    //

    return jobTime % MINUTES_PER_DAY;
}

PVOID
MyGetJob(
    HANDLE  hPrinter,
    DWORD   level,
    DWORD   jobId
    )

/*++

Routine Description:

    Wrapper function for spooler API GetJob

Arguments:

    hPrinter - Handle to the printer object
    level - Level of JOB_INFO structure interested
    jobId - Specifies the job ID

Return Value:

    Pointer to a JOB_INFO structure, NULL if there is an error

--*/

{
    PBYTE   pJobInfo = NULL;
    DWORD   cbNeeded;

    if (!GetJob(hPrinter, jobId, level, NULL, 0, &cbNeeded) &&
        GetLastError() == ERROR_INSUFFICIENT_BUFFER &&
        (pJobInfo = MemAlloc(cbNeeded)) &&
        GetJob(hPrinter, jobId, level, pJobInfo, cbNeeded, &cbNeeded))
    {
        return pJobInfo;
    }

    Error(("GetJob failed: %d\n", GetLastError()));
    MemFree(pJobInfo);
    return NULL;
}


BOOL
SetJobInfoAndTime(
    HANDLE      hPrinter,
    DWORD       jobId,
    LPTSTR      pJobParam,
    PDMPRIVATE  pdmPrivate
    )

/*++

Routine Description:

    Change the devmode and start/stop times associated with a cover page job

    Sets JOB_INFO_2:pParameters to the provided pJobParam string that contains the fax job parameters
    to be convyed to the fax print monitor.

Arguments:

    hPrinter - Specifies the printer object
    jobId - Specifies the job ID
    pJobParam - Specifies the fax job parameters
    pdmPrivate - Specifies private devmode information

Return Value:

    TRUE if successful, FALSE if there is an error

--*/

{
    JOB_INFO_2 *pJobInfo2;
    BOOL        result = FALSE;

    //
    // Get the current job information
    //

    if (pJobInfo2 = MyGetJob(hPrinter, 2, jobId)) {

        //
        // set the time to send to be now, always
        //

        Warning(("Fax job parameters: %ws\n", pJobParam));

        //
        // Set the pParameters field of JOB_INFO_2 to the tagged string with the job
        // information. This mechanism is used to pass the fax related job information
        // to the fax monitor.
        //
        pJobInfo2->pParameters = pJobParam;
        pJobInfo2->Position = JOB_POSITION_UNSPECIFIED;
        pJobInfo2->pDevMode = NULL;
        pJobInfo2->UntilTime = pJobInfo2->StartTime;

        if (! (result = SetJob(hPrinter, jobId, 2, (PBYTE) pJobInfo2, 0))) {
            Error(("SetJob failed: %d\n", GetLastError()));
        }

        MemFree(pJobInfo2);
    }

    return result;
}


BOOL
ChainFaxJobs(
    HANDLE  hPrinter,
    DWORD   parentJobId,
    DWORD   childJobId
    )

/*++

Routine Description:

    Tell the spooler to chain up two print jobs

Arguments:

    hPrinter - Specifies the printer object
    parentJobId - Specifies the job to chain from
    childJobId - Specifies the job to chain to

Return Value:

    TRUE if successful, FALSE if there is an error

--*/

{
    JOB_INFO_3 jobInfo3 = { parentJobId, childJobId };

    Warning(("Chaining cover page job to body job: %d => %d\n", parentJobId, childJobId));

    return SetJob(hPrinter, parentJobId, 3, (PBYTE) &jobInfo3, 0);
}


LPTSTR
GetJobName(
    HANDLE  hPrinter,
    DWORD   jobId
    )

/*++

Routine Description:

    Return the name of the specified print job

Arguments:

    hPrinter - Specifies the printer object
    jobId - Specifies the fax body job

Return Value:

    Pointer to the job name string, NULL if there is an error

--*/

{
    JOB_INFO_1 *pJobInfo1;
    LPTSTR      pJobName = NULL;

    //
    // Get the information about the specified job and
    // return a copy of the job name string
    //

    if (pJobInfo1 = MyGetJob(hPrinter, 1, jobId))
    {
        if ( (pJobInfo1->pDocument) &&
             ((pJobName = DuplicateString(pJobInfo1->pDocument)) == NULL) )
        {
            Error(("DuplicateString(%s) failed.", pJobInfo1->pDocument));
            SetLastError(ERROR_NOT_ENOUGH_MEMORY);
        }

        MemFree(pJobInfo1);
    }

    return pJobName;
}




//*********************************************************************************
//* Name:   ComposeFaxJobName()
//* Author: Ronen Barenboim
//* Date:   April 22, 1999
//*********************************************************************************
//* DESCRIPTION:
//*     Creates the document name for a print job by composing the document
//*     body  name with the recipient name (in case of a single recipient) or
//*     the word "Broadcast" in case of a multiple recipient job.
//*     The job name has the format <Recipient Name> - <Body Name> where
//*     <Recipient Name> is "Broadcast" in the case a multiple recipient
//*     tranmission.
//*
//* PARAMETERS:
//*     [IN]    PDOCEVENTUSERMEM pDocEventUserMem
//*         A pointer to a USERMEM structure that contains information on the recipients.
//*         Note that USERMEM.nRecipientCount must be valid (calculated) before calling
//*         this function.
//*
//*     [IN]    LPTSTR  pBodyDocName
//*         The name of the document.
//*
//* RETURN VALUE:
//*     Pointer to a newly allocated string that contains the composed name.
//*     The caller must free the memory occupied by the string by calling
//*     MemFree().
//*     If the function fails the return value is NULL.
//*********************************************************************************
LPTSTR
ComposeFaxJobName(
    PDOCEVENTUSERMEM pDocEventUserMem,
    LPTSTR  pBodyDocName
    )

#define DOCNAME_FORMAT_STRING   TEXT("%s - %s")

{

    LPTSTR  pCoverJobName;
    LPTSTR pRecipientName;
    #define MAX_BROADCAST_STRING_LEN 256
    TCHAR szBroadcast[MAX_BROADCAST_STRING_LEN];

    Assert(pDocEventUserMem);

    if (pDocEventUserMem->dwNumberOfRecipients > 1) {
        if (!LoadString(g_hResource,
                        IDS_BROADCAST_RECIPIENT,
                        szBroadcast,
                        sizeof(szBroadcast)/sizeof(TCHAR)))
        {
            Error(("Failed to load broadcast recipient string. (ec: %lc)",GetLastError()));
            return NULL;
        }
        else {
            pRecipientName = szBroadcast;
        }
    } else {
        Assert(pDocEventUserMem->lpRecipientsInfo);
        Assert(pDocEventUserMem->lpRecipientsInfo[0].lptstrName);
        pRecipientName = pDocEventUserMem->lpRecipientsInfo[0].lptstrName;
    }


    if (pBodyDocName == NULL) {
        //
        // No body. job name is just the recipient name.
        //
        if ((pCoverJobName = DuplicateString(pRecipientName)) == NULL)
        {
            Error(("DuplicateString(%s) failed", pRecipientName));
        }


    }
    else
    {
        DWORD dwSize;

        dwSize = SizeOfString(DOCNAME_FORMAT_STRING) +
                 SizeOfString(pBodyDocName) +
                 SizeOfString(pRecipientName);
        pCoverJobName = MemAlloc(dwSize);
        if (pCoverJobName)
        {
            //
            // Body name specified. The cover page job name is generated by
            // concatenating the recipient's name with the body job name.
            //
            wsprintf(pCoverJobName, DOCNAME_FORMAT_STRING, pRecipientName, pBodyDocName);
        }
        else
        {
            Error((
                "Failed to allocate %ld bytes for pCoverJobName (ec: %ld)",
                dwSize,
                GetLastError()));

        }

    }
    return pCoverJobName;
}


LPTSTR
GetBaseNoteFilename(
    VOID
    )

/*++

Routine Description:

    Get the name of base cover page file in system32 directory

Arguments:

    argument-name - description of argument

Return Value:

    Pointer to name of base cover page file
    NULL if there is an error

--*/

#define BASENOTE_FILENAME   TEXT("\\basenote.cov")

{
    TCHAR       systemDir[MAX_PATH];
    LPTSTR      pBaseNoteName = NULL;
    COVDOCINFO  covDocInfo;

    if (GetSystemDirectory(systemDir, MAX_PATH) &&
        (pBaseNoteName = MemAlloc(SizeOfString(systemDir) + SizeOfString(BASENOTE_FILENAME))))
    {
        _tcscpy(pBaseNoteName, systemDir);
        _tcscat(pBaseNoteName, BASENOTE_FILENAME);
        Verbose(("Base cover page filename: %ws\n", pBaseNoteName));

        if (PrintCoverPage(NULL, NULL, pBaseNoteName, &covDocInfo) ||
            ! (covDocInfo.Flags & COVFP_NOTE) ||
            ! (covDocInfo.Flags & COVFP_SUBJECT))
        {
            Error(("Invalid base cover page file: %ws\n", pBaseNoteName));
            MemFree(pBaseNoteName);
            pBaseNoteName = NULL;
        }
    }

    return pBaseNoteName;
}


//*********************************************************************************
//* Name:   ComposeFaxJobParameter()
//* Author: Ronen Barenboim
//* Date:   March 23, 1999
//*********************************************************************************
//* DESCRIPTION:
//*     Generates the tagged parameter string that carries the job parameters
//*     (sender information, cover page information ,recipient information)
//*     to the fax monitor on the fax server (using JOB_INFO_2.pParameters).
//* PARAMETERS:
//*     pDocEventUserMem
//*         A pointer to a USERMEM structure from which some of the information
//*         is collected.
//*     pCPFields
//*         A pointer to a COVERPAGEFIELS structure from which sender and cover
//*         page information is collected.
//*     lppParamBuf
//*         The address of a pointer varialbe that will accept the address of the
//*         buffer this function will allocated for the resulting tagged string.
//*         The caller of this function must free this buffer using MemFree().
//* RETURN VALUE:
//*     TRUE
//*         If successful.
//*     FALSE
//*         If failed.
//*********************************************************************************
BOOL
ComposeFaxJobParameter(
    PDOCEVENTUSERMEM    pDocEventUserMem,
    PCOVERPAGEFIELDS    pCPFields,
    LPTSTR  *           lppParamBuf
    )
{
    DWORD   dwBufSize;
    DWORD   dwPartialBufSize;
    DWORD   dwLeftBufferSize;
    LPTSTR  lptstrBuf;
    UINT    i;

    Assert(pDocEventUserMem);
    Assert(pCPFields);
    Assert(lppParamBuf);

    //
    // Calculate the parameter buffer we need to allocated
    //
    dwBufSize=0;

    //
    // Calcualte non recipient params string size
    //
    ComposeSenderJobParam(NULL, &dwPartialBufSize, pDocEventUserMem, pCPFields); // void return value
    dwBufSize=dwBufSize+dwPartialBufSize;

    //
    // Go over each recipient and calculate the total required buffer size
    //
    for (i=0;i<pDocEventUserMem->dwNumberOfRecipients;i++)
    {
        //
        // Get recipient's name and fax number
        //
        Assert(pDocEventUserMem->lpRecipientsInfo[i].lptstrName);
        pCPFields->RecName = pDocEventUserMem->lpRecipientsInfo[i].lptstrName;
        Assert(pDocEventUserMem->lpRecipientsInfo[i].lptstrFaxNumber);
        pCPFields->RecFaxNumber = pDocEventUserMem->lpRecipientsInfo[i].lptstrFaxNumber;
        ComposeRecipientJobParam(NULL, &dwPartialBufSize, pCPFields);
        dwBufSize=dwBufSize+dwPartialBufSize; //keep space for the seperating NULL
    }
    //
    // Don't forget the space for the terminating NULL (the ComposeX functions do not include
    // it in the size they report).
    //
    dwBufSize=dwBufSize+sizeof(TCHAR); // dwBufSize is size in BYTES so we must calc the byte size of a TCHAR
    //
    // Allocate the required buffer
    //
    lptstrBuf=MemAlloc(dwBufSize);
    if (!lptstrBuf) {
        Error(("Failed to allocate buffer of size %ld for parameter buffer (ec: 0x%0X)",dwBufSize,GetLastError()));
        return FALSE;
    }

    //
    // Write the parameters into the buffer
    //
    dwLeftBufferSize = dwBufSize;
    dwPartialBufSize = dwBufSize;
    *lppParamBuf=lptstrBuf;
    ComposeSenderJobParam(lptstrBuf, &dwPartialBufSize, pDocEventUserMem, pCPFields);
    lptstrBuf+=(dwPartialBufSize/sizeof(TCHAR));  // The reported size is in bytes !!!
    Assert (dwLeftBufferSize >= dwPartialBufSize);
    dwLeftBufferSize -= dwPartialBufSize;
    for (i=0;i<pDocEventUserMem->dwNumberOfRecipients;i++)
    {
        //
        // Get recipient's name and fax number
        //
        pCPFields->RecName = pDocEventUserMem->lpRecipientsInfo[i].lptstrName;
        pCPFields->RecFaxNumber = pDocEventUserMem->lpRecipientsInfo[i].lptstrFaxNumber;
        dwPartialBufSize = dwLeftBufferSize;
        ComposeRecipientJobParam(lptstrBuf, &dwPartialBufSize, pCPFields);
        lptstrBuf+=(dwPartialBufSize/sizeof(TCHAR)); // The reported size is in bytes !!!
        Assert (dwLeftBufferSize >= dwPartialBufSize);
        dwLeftBufferSize -= dwPartialBufSize;
    }
    //
    // No need to add a terminating NULL since ParamTagsToString allways appends a NULL terminated string
    // to the existing string (it uses _tcscpy).
    //
    return TRUE;
}

//*********************************************************************************
//* Name:   ComposeRecipientJobParam()
//* Author: Ronen Barenboim
//* Date:   March 23, 1999
//*********************************************************************************
//* DESCRIPTION:
//*     Creates a taged parameter string containing recipient information.
//*
//* PARAMETERS:
//*     lpParamBuf
//*         Pointer to the string buffer where the tagged string is written.
//*     lpdwParamSize
//*         Pointer to a DWORD where the function reports the size of the parameter
//*         string in BYTES.
//*         If this parameter is NULL then the function does not generate
//*         the string but only reports its size.
//*         The size does NOT include the terminating NULL char.
//*     pCPFields
//*         Pointer to a COVERPAGEFIELDS structure from which the recipient
//*         information is collected.
//* RETURN VALUE:
//*     None.
//*********************************************************************************
void
ComposeRecipientJobParam(
    LPTSTR lpParamBuf,
    LPDWORD lpdwParamSize,
    const COVERPAGEFIELDS *   pCPFields
    )

{


    FAX_TAG_MAP_ENTRY tagMap[] =
    {

        //
        // Recipient info
        //
        { FAXTAG_NEW_RECORD,                FAXTAG_NEW_RECORD_VALUE}, // Parameters record start indication
        { FAXTAG_RECIPIENT_NAME,            pCPFields->RecName },
        { FAXTAG_RECIPIENT_NUMBER,          pCPFields->RecFaxNumber },
        { FAXTAG_RECIPIENT_COMPANY,         pCPFields->RecCompany },
        { FAXTAG_RECIPIENT_STREET,          pCPFields->RecStreetAddress },
        { FAXTAG_RECIPIENT_CITY,            pCPFields->RecCity },
        { FAXTAG_RECIPIENT_STATE,           pCPFields->RecState },
        { FAXTAG_RECIPIENT_ZIP,             pCPFields->RecZip },
        { FAXTAG_RECIPIENT_COUNTRY,         pCPFields->RecCountry },
        { FAXTAG_RECIPIENT_TITLE,           pCPFields->RecTitle },
        { FAXTAG_RECIPIENT_DEPT,            pCPFields->RecDepartment },
        { FAXTAG_RECIPIENT_OFFICE_LOCATION, pCPFields->RecOfficeLocation },
        { FAXTAG_RECIPIENT_HOME_PHONE,      pCPFields->RecHomePhone },
        { FAXTAG_RECIPIENT_OFFICE_PHONE,    pCPFields->RecOfficePhone },

    };


    DWORD dwTagCount;

    Assert(pCPFields);
    Assert(lpdwParamSize);

    dwTagCount=sizeof(tagMap)/sizeof(FAX_TAG_MAP_ENTRY);

    ParamTagsToString(tagMap, dwTagCount, lpParamBuf, lpdwParamSize );
}




//*********************************************************************************
//* Name:   ComposeSenderJobParam()
//* Author: Ronen Barenboim
//* Date:   March 23, 1999
//*********************************************************************************
//* DESCRIPTION:
//*     Creates a taged parameter string containing cover page information, sender
//*     information and the number of recipients in the tranmission.
//*
//* PARAMETERS:
//*     lpParamBuf
//*         Pointer to the string buffer where the tagged string is written.
//*     lpdwParamSize
//*         Pointer to a DWORD where the function reports the size of the parameter
//*         string in BYTES.
//*         If this parameter is NULL then the function does not generate
//*         the string but only reports its size.
//*         The size does NOT include the terminating NULL char.
//*     pDocEventUserMem
//*         Pointer to a USERMEM structure from which some of information
//*         is collected.
//*     pCPFields
//*         Pointer to a COVERPAGEFIELDS structure from which the cover page
//*         and sender information is collected.
//*
//* RETURN VALUE:
//*     None.
//*********************************************************************************
void
ComposeSenderJobParam(
    LPTSTR lpParamBuf,
    LPDWORD lpdwParamSize,
    PDOCEVENTUSERMEM  pDocEventUserMem,
    const COVERPAGEFIELDS *    pCPFields)
{

    #define FAXTAG_SERVER_COVERPAGE_IDX 9 
    #define FAXTAG_TSID_IDX             3 

    TCHAR lptstrRecipientCount[11];


    FAX_TAG_MAP_ENTRY tagMap[] =
    {
        { FAXTAG_NEW_RECORD,                FAXTAG_NEW_RECORD_VALUE},
        { FAXTAG_WHEN_TO_SEND,              NULL },
        { FAXTAG_SEND_AT_TIME,              NULL },
        { FAXTAG_TSID,                      pCPFields->SdrFaxNumber },
        { FAXTAG_BILLING_CODE,              pDocEventUserMem->devmode.dmPrivate.billingCode },
        { FAXTAG_RECEIPT_TYPE,              pDocEventUserMem->pReceiptFlags },
        { FAXTAG_RECEIPT_ADDR,              pDocEventUserMem->pReceiptAddress },
        { FAXTAG_PRIORITY,                  pDocEventUserMem->pPriority },
        { FAXTAG_COVERPAGE_NAME,            pDocEventUserMem->coverPage },
        { FAXTAG_SERVER_COVERPAGE,          NULL },
        { FAXTAG_PAGE_COUNT,                pCPFields->NumberOfPages},
        { FAXTAG_SENDER_NAME,               pCPFields->SdrName },
        { FAXTAG_SENDER_NUMBER,             pCPFields->SdrFaxNumber},
        { FAXTAG_SENDER_COMPANY,            pCPFields->SdrCompany },
        { FAXTAG_SENDER_TITLE,              pCPFields->SdrTitle },
        { FAXTAG_SENDER_DEPT,               pCPFields->SdrDepartment },
        { FAXTAG_SENDER_OFFICE_LOCATION ,   pCPFields->SdrOfficeLocation },
        { FAXTAG_SENDER_HOME_PHONE,         pCPFields->SdrHomePhone },
        { FAXTAG_SENDER_OFFICE_PHONE,       pCPFields->SdrOfficePhone },
        { FAXTAG_SENDER_STREET,             pDocEventUserMem->lpSenderInfo->lptstrStreetAddress },
        { FAXTAG_SENDER_CITY,               pDocEventUserMem->lpSenderInfo->lptstrCity },
        { FAXTAG_SENDER_STATE,              pDocEventUserMem->lpSenderInfo->lptstrState },
        { FAXTAG_SENDER_ZIP,                pDocEventUserMem->lpSenderInfo->lptstrZip },
        { FAXTAG_SENDER_COUNTRY,            pDocEventUserMem->lpSenderInfo->lptstrCountry },
        { FAXTAG_SENDER_EMAIL,              pDocEventUserMem->lpSenderInfo->lptstrEmail },
        { FAXTAG_NOTE,                      pDocEventUserMem->pNoteMessage },
        { FAXTAG_SUBJECT,                   pDocEventUserMem->pSubject},
        { FAXTAG_RECIPIENT_COUNT,           lptstrRecipientCount}
    };



    TCHAR   SendAtTime[16];
    DWORD  dwTagCount;


    if (pDocEventUserMem->bServerCoverPage)
    {
        tagMap[FAXTAG_SERVER_COVERPAGE_IDX].lptstrValue=TEXT("1");
    } else
    {
        tagMap[FAXTAG_SERVER_COVERPAGE_IDX].lptstrValue=NULL;
    }

    //
    // create the sendattime string
    //

    if (pDocEventUserMem->devmode.dmPrivate.whenToSend == JSA_DISCOUNT_PERIOD) {
        tagMap[1].lptstrValue=TEXT("cheap");
    }

    if (pDocEventUserMem->devmode.dmPrivate.whenToSend == JSA_SPECIFIC_TIME) {

        wsprintf( SendAtTime, TEXT("%02d:%02d"),
            pDocEventUserMem->devmode.dmPrivate.sendAtTime.Hour,
            pDocEventUserMem->devmode.dmPrivate.sendAtTime.Minute
            );

        tagMap[1].lptstrValue= TEXT("at");
        tagMap[2].lptstrValue= SendAtTime;
    }

    wsprintf( lptstrRecipientCount, TEXT("%10d"),pDocEventUserMem->dwNumberOfRecipients);
    //
    // Figure out the total length of the tagged string
    //
    dwTagCount=sizeof(tagMap)/sizeof(FAX_TAG_MAP_ENTRY);

    ParamTagsToString(tagMap, dwTagCount, lpParamBuf, lpdwParamSize );

}


//*****************************************************************************
//* Name:   WriteCoverPageToPrintJob
//* Author: Ronen Barenboim (Feb-99)
//*****************************************************************************
//* DESCRIPTION:
//*     Reads the content of the specified cover page template and writes it
//*     to the specified printer.
//*     The user should call StartDocPrinter() and StartPagePrinter()
//*     before calling this function.
//* PARAMETERS:
//*     [IN]    HANDLE hPrinter:
//*                 A handle to the printer to which the cover page template
//*                 should be written.
//*     [IN]    LPCTSTR lpctstrCoverPageFile:
//*                 The full path to the cover page file whose content is to be
//*                 written to the printer.
//* RETURN VALUE:
//*     FALSE: If the function failed.
//*     TRUE: Otherwise.
//*****************************************************************************
BOOL WriteCoverPageToPrintJob(HANDLE hPrinter, LPCTSTR lpctstrCoverPageFile)
{
    #define BUF_SIZE 64*1024  // Buffer size for read operation
    PCHAR   chBuf=NULL;       // Read operation buffer
    BOOL bRes;                // The result of the function
    HANDLE hCoverFile;        // Handle to the cover page file
    DWORD dwBytesRead;        // The number of bytes actually read at each cycle

    Assert(hPrinter);
    Assert(lpctstrCoverPageFile);

    bRes=FALSE;
    hCoverFile=INVALID_HANDLE_VALUE;

    //
    // Open the cover page template file for reading
    //
    hCoverFile=CreateFile(
            lpctstrCoverPageFile,
            GENERIC_READ,
            0,
            NULL,
            OPEN_EXISTING,
            0,
            0);
    if (INVALID_HANDLE_VALUE == hCoverFile )
    {
        goto Exit;
    }

    chBuf = MemAlloc(BUF_SIZE);
    if (NULL == chBuf)
    {
        Error(("Failed to allocate read operation buffer"));
        goto Exit;
    }
    
    //
    //Read the file and write it into the print job
    //
    do {
        bRes=ReadFile(hCoverFile,chBuf,sizeof(CHAR)*BUF_SIZE,&dwBytesRead,NULL) ;
        if (!bRes) {
            Error(("Failed to read cover page file into print job (cover page file: %s ec: %d\n)",
                lpctstrCoverPageFile,
                GetLastError())
             );
            break;

        } else {
            Verbose(("Success reading cover page file %s. %d bytes read.\n",lpctstrCoverPageFile,dwBytesRead));
        }

        if (dwBytesRead) {
            //
            // If dwBytesRead != 0 we are NOT at the enf of the file.
            //
            DWORD dwWritten;

            bRes=WritePrinter(hPrinter,(LPVOID)chBuf,dwBytesRead,&dwWritten);
            if (!bRes) {
                Error(("Failed to write to printer (ec = %d)", GetLastError()));
            } else
            {
                Verbose(("Success writing to printer. %d bytes written.\n",dwWritten));
            }
        }
    } while (dwBytesRead); // While not EOF

Exit:
    //
    //Close the cover page file
    //
    if (INVALID_HANDLE_VALUE!=hCoverFile)
    {
        if (!CloseHandle(hCoverFile))
        {
            Error(("CloseHandle() failed: %d.\n", GetLastError()));
        }
    }

    if (NULL != chBuf)
    {
        MemFree(chBuf);
    }
    return bRes;
}



//*****************************************************************************
//* Name:   DoCoverPageRendering
//* Author: Ronen Barenboim (Feb-99)
//*****************************************************************************
//* DESCRIPTION:
//*  Creates the cover page print job and attaches it to the body print job.
//*  The cover page job is created even when a cover page is NOT specified.
//*  It contains all the job parameters for the job as a tagged string
//*  placed in JOB_INFO_2.pParameters. This contains the information for the
//*  sender, cover page, job parameters and ALL recipients.
//*
//*  The content of the job is empty if no cover page is specified or
//*  The cover page is server based.
//*  For personal cover pages the content of the cover page template is written
//*  into the job as "RAW" data. The print monitor on the server will extract this
//*  data to reconstruct the cover page file on the server.
//*
//* PARAMETERS:
//*     [IN]    PDOCEVENTUSERMEM pDocEventUserMem:
//*                 A pointer to a USERMEM structure containing the context information
//*                 for the print job.
//* RETURN VALUE:
//*     FALSE: If the function failed.
//*     TRUE: Otherwise.
//*****************************************************************************
BOOL
DoCoverPageRendering(
    PDOCEVENTUSERMEM    pDocEventUserMem
    )
{
    PCOVERPAGEFIELDS    pCPFields=NULL;
    DOC_INFO_1          docinfo;
    INT                 newJobId=0;
    INT                 lastJobId=0;
    INT                 cCoverPagesSent=0;
    PDMPRIVATE          pdmPrivate = &pDocEventUserMem->devmode.dmPrivate;
    HANDLE              hPrinter = pDocEventUserMem->hPrinter;
    DWORD               bodyJobId = pDocEventUserMem->jobId;
    LPTSTR              pBodyDocName=NULL;
    LPTSTR              pJobParam=NULL;
    BOOL                sendCoverPage;
    DWORD               pageCount;

    
    //
    // Fill out a DOCINFO structure which is passed to StartDoc
    //

    memset(&docinfo, 0, sizeof(docinfo));
    //docinfo.cbSize = sizeof(docinfo);
    
    
    //
    // Determine if we need a cover page or not
    //

    if ( (sendCoverPage = pdmPrivate->sendCoverPage) && IsEmptyString(pDocEventUserMem->coverPage)) {

        Warning(("Missing cover page file\n"));
        sendCoverPage = FALSE;
    }

    pageCount = pDocEventUserMem->pageCount;

    //
    // Collect cover page information into a newly allocated pCPFields. pCPFields will be
    // passed to ComposeFaxJobParameters() to provide the values for the job tags.
    //

    if ((pCPFields = CollectCoverPageFields(pDocEventUserMem->lpSenderInfo,pageCount)) == NULL) {

        Error(("Couldn't collect cover page information\n"));
        goto Exit;
    }

    

    pBodyDocName = GetJobName(hPrinter, bodyJobId);
    if (!pBodyDocName) {
        Error(("GetJobName failed (ec: %ld)", GetLastError()));
        Assert(FALSE);
        //
        // We continue inspite of the error. We can handle a NULL body doc name.
        //
    }

    //
    // We assume the fax body job has already been paused
    // Use a separate cover page for each recipient
    //

    newJobId = 0;
    docinfo.pDocName = NULL;
    pJobParam = NULL;
    //
    // Start a cover page job
    //

    //
    // The cover page job document name is "<BODY_NAME> - COVERPAGE"
    //

    docinfo.pOutputFile=NULL;
    docinfo.pDatatype=TEXT("RAW"); // Since we write the template into the job we want to bypass the driver.

    //
    // Create the tagged string of job parameters to be placed into JOB_INFO_2:pParameters.
    // The parameters include the parameters found at the FAX_JOB_PARAM client API structure.
    // pJobParam is ALLOCATED.
    //
    if (!ComposeFaxJobParameter(pDocEventUserMem, pCPFields,&pJobParam)) {
        Error(("ComposeFaxJobParameter failed. (ec: 0x%X)",GetLastError()));
        goto Error;
    }
    Assert(pJobParam); // Should be allocated now.

    docinfo.pDocName = ComposeFaxJobName(pDocEventUserMem,pBodyDocName);//pBodyDocName, TEXT("COVERPAGE"));

    if (!docinfo.pDocName) {
        Error(("ComposeFaxJobName failed. Body: %s (ec: %ld)",pBodyDocName,GetLastError()));
        //
        // we can do with no document name.
        //
    }


    if ((newJobId = StartDocPrinter(hPrinter,1, (LPBYTE)&docinfo)) !=0) {
        BOOL        rendered = FALSE;
        //
        // Pass fax job parameters using JOB_INFO_2.pParameters field.
        //

        //
        // Pause the new cover page job.
        //

        if (!SetJob(hPrinter, newJobId, 0, NULL, JOB_CONTROL_PAUSE)) {
             Error(("Failed to pause job id: %d (ec: %ld)",newJobId,GetLastError()));
             Assert(FALSE);
             goto Error;
        }

        if (!SetJobInfoAndTime(hPrinter,
                               newJobId,
                               pJobParam,
                               pdmPrivate)) {
            Error(("SetJobInfoAndTime failed. Job id : %d.",newJobId));
            Assert(FALSE);
            goto Error;
        }

        if (! sendCoverPage || pDocEventUserMem->bServerCoverPage) {
            //
            // If the user chose not to include cover page or a server side cover page was specified
            // the cover page job will be empty
            // Note that even if there is no cover page to send we still create a cover page print job
            // and link it to the body.
            // The cover print job is used to convery sender/recipient information. The fax print monitor will
            // use the job parameters string placed in JOB_INFO_2:pParameters to get this information at the server.
            //
            rendered = TRUE;

        } else {
            if (StartPagePrinter(hPrinter)) {
                //
                // Write the content of the cover page template into the print job.
                // The print monitor on the server will extract this information to get
                // the cover page template and render the cover page on the server.
                //
                rendered=WriteCoverPageToPrintJob(hPrinter,pDocEventUserMem->coverPage);

                if (!rendered) {
                    Error(("WriteCoverPageToPrintJob failed: %d\n", rendered ));
                    //
                    // Must call EndPagePrinter if error was encounterd or not.
                    //
                }

                if (!EndPagePrinter(hPrinter)) {
                    Error(("EndPagePrinter failed. (ec: %ld)",GetLastError()));
                    goto Error;
                }

                if (!rendered) {
                    goto Error;
                }


            } else {
                Error(("StartPagePrinter failed. (ec: %ld)",GetLastError()));
                rendered=FALSE;
                goto Error;
            }
        }


        //
        // Chain the cover page job to the fax body job if no error occured.
        //
        // Chain the cover page job to the BODY job.
        // The cover page job is the parent job. The body is the child job.
        // Note that multiple cover page
        // Jobs will be chained to the same BODY job.
        // also note the cover page jobs are not chained to each other. Just to the body.
        //

        if (rendered) {
            if (ChainFaxJobs(hPrinter, newJobId, bodyJobId)) {
                if (lastJobId != 0) {
                    if (!SetJob(hPrinter, lastJobId, 0, NULL, JOB_CONTROL_RESUME)) {
                        Error(("Failed to resume job with id: %d",lastJobId));
                        Assert(FALSE);
                        goto Error;
                    }
                }
                lastJobId = newJobId;
                if (!EndDocPrinter(hPrinter)) {
                    Error(("EndPagePrinter failed. (ec: %ld)",GetLastError()));
                    Assert(FALSE);
                    goto Error;
                }
                cCoverPagesSent++;
            } else {
                Error(("ChainFaxJobs for CoverJobId=%d BodyJobId=%d has failed. Aborting job.",newJobId, bodyJobId));
                goto Error;
            }

        } else {
            Error(("Cover page template not written into job (rendered=FALSE). Aborting job."));
            goto Error;
        }
    } else {
        Error(("StartDocPrinter failed. (ec: %ld)",GetLastError()));
        goto Error;
    }
    goto Exit;


Error:
    Error(("Cover page job failed"));
    if (0!=newJobId) {
        //
        // This means that an error was detected after we created the job.
        // Note that if StartDocPrinter failed this code is not executed.
        //
        Error(("Aborting cover page job. JobId = %d",newJobId));
        if (!AbortPrinter(hPrinter)) {
            Error(("AbortPrinter failed (ec: %ld)",GetLastError()));
        }
    }


Exit:

    if (docinfo.pDocName) {
        MemFree((PVOID)docinfo.pDocName);
    }

    if (pJobParam) {
        MemFree((PVOID)pJobParam);
    }

    if (pBodyDocName) {
        MemFree(pBodyDocName);
    }
    if (pCPFields) {
        FreeCoverPageFields(pCPFields);
    }


    //
    // Resume the last cover page job if it's paused and
    // delete the fax body job if no cover page jobs were sent
    //

    if (lastJobId != 0) {

        if (!SetJob(hPrinter, lastJobId, 0, NULL, JOB_CONTROL_RESUME)) {
            Error(("Failed to resume last job id : %d",lastJobId));
            Assert(FALSE);
        }

    }

    if (cCoverPagesSent > 0) {
        if (!SetJob(hPrinter, bodyJobId, 0, NULL, JOB_CONTROL_RESUME)) {
            Error(("Failed to resume body job with id: %d",bodyJobId));
            Assert(FALSE);
        }

    } else {
        Error(("No recipient jobs created. Fax job deleted due to an error.\n"));
        if (!SetJob(hPrinter, bodyJobId, 0, NULL, JOB_CONTROL_DELETE)) {
            Error(("Failed to delete body job with id: %d",bodyJobId));
            Assert(FALSE);
        }

    }

    return cCoverPagesSent > 0;
}
INT
DocEventEndDocPost(
    HDC                 hdc,
    PDOCEVENTUSERMEM    pDocEventUserMem
    )

/*++

Routine Description:

    Handle ENDDOCPOST document event

Arguments:

    hdc - Specifies the printer device context
    pDocEventUserMem - Points to the user mode memory structure

Return Value:

    Return value for DrvDocumentEvent

--*/

{
    INT result = DOCUMENTEVENT_SUCCESS;

    switch (pDocEventUserMem->jobType) 
    {
        case JOBTYPE_NORMAL:

            Warning(("Number of pages printed: %d\n", pDocEventUserMem->pageCount));

            if (! pDocEventUserMem->directPrinting) 
            {
                LRESULT ec;
				BOOL bAllowed = FALSE;

				//
				//	check if there is already running instance of Fax Wizard
				//

				if(!g_bInitRunningWizardCS)
				{
					Assert(FALSE);
                    result = DOCUMENTEVENT_FAILURE;
					break;
				}

				EnterCriticalSection(&g_csRunningWizard);
				if (!g_bRunningWizard)
				{
					//
					//	no running instance of Fax Wizard 
					//
					g_bRunningWizard = TRUE;
					bAllowed = TRUE;
				}
				LeaveCriticalSection(&g_csRunningWizard);

				if (!bAllowed)
				{
					//
					//	there is running instance of Fax Wizard
					//	show popup to user and stop processing
					//
					ShowReentrancyMessage();
                    result = DOCUMENTEVENT_FAILURE;
					break;
				}

                ec = LaunchFaxWizard(pDocEventUserMem);

				//
				//	Let other threads to launch Fax Wizard
				//
				EnterCriticalSection(&g_csRunningWizard);
				g_bRunningWizard = FALSE;
				LeaveCriticalSection(&g_csRunningWizard);

                if (ERROR_SUCCESS == ec)
                {
                    //
                    // Generate a cover page for each recipient and associate
                    // the cover page job with the main body.
                    // The job will contain the cover page template data and the
                    // recipient parameters.
                    if (! DoCoverPageRendering(pDocEventUserMem)) 
                    {
                        Error(("DoCoverPageRendering failed."));
                        result = DOCUMENTEVENT_FAILURE;
                    }
                }
                else
                {
                    result = DOCUMENTEVENT_FAILURE;
                }

                //
                // Free up the list of recipients
                //
                FreeRecipientInfo(&pDocEventUserMem->dwNumberOfRecipients, pDocEventUserMem->lpRecipientsInfo);

            }
            break;
    }

    if (DOCUMENTEVENT_SUCCESS != result)
    {
        //
        // Cancel the job ignoring errors
        //
        if (!SetJob(
                pDocEventUserMem->hPrinter,
                pDocEventUserMem->jobId,
                0,
                NULL,
                JOB_CONTROL_DELETE))
        {
            Error(("Failed to cancel job. JobId: %ld (ec: %ld)",
                    pDocEventUserMem->jobId,
                    GetLastError()));
        }
    }
    return result;
}


BOOL
AppendPreviewPage(PDOCEVENTUSERMEM pDocEventUserMem)

/*++

Routine Description:

    Append the next document page to the temporary preview file

Arguments:

    pDocEventUserMem

Return Value:

    TRUE on success

Note:

    If this routine is called for page 0, it just checks that the graphics driver hasn't
    cancled the print preview option and validates the mapping structures.

--*/

{
    DWORD dwWritten;

    // If we get here print preview should be enabled an all preview handles valid
    Assert(FALSE == pDocEventUserMem->bPreviewAborted);
    Assert(INVALID_HANDLE_VALUE != pDocEventUserMem->hPreviewFile);
    Assert(NULL != pDocEventUserMem->pPreviewTiffPage);

    //
    // Validate preview mapping
    //

    // The size of the header should be correct
    if (sizeof(MAP_TIFF_PAGE_HEADER) != pDocEventUserMem->pPreviewTiffPage->cb)
    {
        Error(("Preview mapping corrupted\n"));
        pDocEventUserMem->bPreviewAborted = TRUE;
        return FALSE;
    }

    // Check if the preview operation hasn't beed cancled by the graphics driver
    if (FALSE == pDocEventUserMem->pPreviewTiffPage->bPreview)
    {
        Error(("Preview aborted by graphics driver\n"));
        pDocEventUserMem->bPreviewAborted = TRUE;
        return FALSE;
    }

    //
    // If we are called prior to the first sent page just return
    //
    if (!pDocEventUserMem->pageCount)
    {
        return TRUE;
    }

    //
    // Validate correct page number:
    //
    // The graphics driver increments the page count on the call to DrvStartPage(), while we
    // increment the page count on the ENDPAGE event.
    //
    // As this function is called by the STARTPAGE event handler (before 'DrvStartPage' is called
    // again in the graphics driver) or by the ENDDOCPOST event handler, the page number set by
    // the graphics driver in the mapping should be equal to our page count in this stage.
    //
    if (pDocEventUserMem->pageCount != pDocEventUserMem->pPreviewTiffPage->iPageCount)
    {
        Error(("Wrong preview page: %d. Page expected: %d.\n",
                    pDocEventUserMem->pPreviewTiffPage->iPageCount,
                    pDocEventUserMem->pageCount));
        pDocEventUserMem->bPreviewAborted = TRUE;
        pDocEventUserMem->pPreviewTiffPage->bPreview = FALSE;
        return FALSE;
    }

    //
    // Append new page to temporary preview file
    //

    if (0 == pDocEventUserMem->pPreviewTiffPage->dwDataSize)
    {
        //
        // Nothing to add (?!). It is impossible to get an empty TIFF page
        //
        Error(("Recieved empty preview page: %d.\n", pDocEventUserMem->pageCount));
        Assert(FALSE);
        return TRUE;
    }

    if (!WriteFile(
        pDocEventUserMem->hPreviewFile,
        pDocEventUserMem->pPreviewTiffPage + 1,
        pDocEventUserMem->pPreviewTiffPage->dwDataSize,
        &dwWritten,
        NULL) || dwWritten != pDocEventUserMem->pPreviewTiffPage->dwDataSize)
    {
        Error(("Failed appending preview page: %d. Error: %d\n",
                    pDocEventUserMem->pageCount,
                    GetLastError()));
        pDocEventUserMem->bPreviewAborted = TRUE;
        pDocEventUserMem->pPreviewTiffPage->bPreview = FALSE;
        return FALSE;
    }

    return TRUE;
}



INT
DrvDocumentEvent(
    HANDLE  hPrinter,
    HDC     hdc,
    INT     iEsc,
    ULONG   cbIn,
    PULONG  pjIn,
    ULONG   cbOut,
    PULONG  pjOut
    )

/*++

Routine Description:

    Hook into GDI at various points during the output process

Arguments:

    hPrinter - Specifies the printer object
    hdc - Handle to the printer DC
    iEsc - Why this function is called (see notes below)
    cbIn - Size of the input buffer
    pjIn - Pointer to the input buffer
    cbOut - Size of the output buffer
    pjOut - Pointer to the output buffer

Return Value:

    DOCUMENTEVENT_SUCCESS - success
    DOCUMENTEVENT_UNSUPPORTED - iEsc is not supported
    DOCUMENTEVENT_FAILURE - an error occured

NOTE:

    DOCUMENTEVENT_CREATEDCPRE
        input - pointer to a CREATEDCDATA structure
        output - pointer to a devmode that's passed to DrvEnablePDEV
        return value -
            DOCUMENTEVENT_FAILURE causes CreateDC to fail and nothing else is called

    DOCUMENTEVENT_CREATEDCPOST
        hdc - NULL if if something failed since CREATEDCPRE
        input - pointer to the devmode pointer returned by CREATEDCPRE
        return value - ignored

    DOCUMENTEVENT_RESETDCPRE
        input - pointer to the input devmode passed to ResetDC
        output - pointer to a devmode that's passed to the kernel driver
        return value -
            DOCUMENTEVENT_FAILURE causes ResetDC to fail
            and CREATEDCPOST will not be called in that case

    DOCUMENTEVENT_RESETDCPOST
        return value - ignored

    DOCUMENTEVENT_STARTDOCPRE
        input - pointer to a DOCINFOW structure
        return value -
            DOCUMENTEVENT_FAILURE causes StartDoc to fail
            and DrvStartDoc will not be called in this case

    DOCUMENTEVENT_STARTDOCPOST
        return value - ignored

    DOCUMENTEVENT_STARTPAGE
        return value -
            DOCUMENTEVENT_FAILURE causes StartPage to fail
            and DrvStartPage will not be called in this case

    DOCUMENTEVENT_ENDPAGE
        return value - ignored and DrvEndPage always called

    DOCUMENTEVENT_ENDDOCPRE
        return value - ignored and DrvEndDoc always called

    DOCUMENTEVENT_ENDDOCPOST
        return value - ignored

    DOCUMENTEVENT_ABORTDOC
        return value - ignored

    DOCUMENTEVENT_DELETEDC
        return value - ignored

    DOCUMENTEVENT_ESCAPE
        input - pointer to a ESCAPEDATA structure
        cbOut, pjOut - cbOutput and lpszOutData parameters passed to ExtEscape
        return value - ignored

    DOCUMENTEVENT_SPOOLED
        This flag bit is ORed with other iEsc values if the document is
        spooled as metafile rather than printed directly to port.

--*/

{
    PDOCEVENTUSERMEM    pDocEventUserMem = NULL;
    PDEVMODE            pDevmode;
    INT                 result = DOCUMENTEVENT_SUCCESS;
    HANDLE              hMutex;

    Verbose(("Entering DrvDocumentEvent: %d...\n", iEsc));

    //
    // Metafile spooling on fax jobs is not currently supported
    //
    Assert((iEsc & DOCUMENTEVENT_SPOOLED) == 0);
    //
    // Check if the document event requires a device context
    //

    //
    // Do not execute any code before this initialization
    //
    if(!InitializeDll())
    {
        return DOCUMENTEVENT_FAILURE;
    }


    if (DocEventRequiresDC(iEsc)) 
    {
        if (!hdc || !(pDocEventUserMem = GetPDEVUserMem(hdc))) 
        {
            Error(("Invalid device context: hdc = %x, iEsc = %d\n", hdc, iEsc));
            return DOCUMENTEVENT_FAILURE;
        }
    }

    switch (iEsc) 
    {
        case DOCUMENTEVENT_CREATEDCPRE:

            Assert(cbIn >= sizeof(CREATEDCDATA) && pjIn && cbOut >= sizeof(PDEVMODE) && pjOut);
            result = DocEventCreateDCPre(hPrinter, hdc, (PCREATEDCDATA) pjIn, (PDEVMODE *) pjOut);
            break;

        case DOCUMENTEVENT_CREATEDCPOST:
            //
            // Handle CREATEDCPOST document event:
            //  If CreateDC succeeded, then associate the user mode memory structure
            //  with the device context. Otherwise, free the user mode memory structure.
            //
            Assert(cbIn >= sizeof(PVOID) && pjIn);
            pDevmode = *((PDEVMODE *) pjIn);
            Assert(CurrentVersionDevmode(pDevmode));

            pDocEventUserMem = ((PDRVDEVMODE) pDevmode)->dmPrivate.pUserMem;

            Assert(ValidPDEVUserMem(pDocEventUserMem));

            if (hdc) 
            {
                pDocEventUserMem->hdc = hdc;
                EnterDrvSem();
                pDocEventUserMem->pNext = gDocEventUserMemList;
                gDocEventUserMemList = pDocEventUserMem;
                LeaveDrvSem();

            } 
            else
            {
                FreePDEVUserMem(pDocEventUserMem);
            }
            break;

        case DOCUMENTEVENT_RESETDCPRE:

            Verbose(("Document event: RESETDCPRE\n"));
            Assert(cbIn >= sizeof(PVOID) && pjIn && cbOut >= sizeof(PDEVMODE) && pjOut);
            result = DocEventResetDCPre(hdc, pDocEventUserMem, *((PDEVMODE *) pjIn), (PDEVMODE *) pjOut);
            break;

        case DOCUMENTEVENT_STARTDOCPRE:
            //
            // normal case if we're bringing up the send wizard
            //
            //
            // When direct printing is requested we don't even call DocEventStartDocPre().
            // When direct printing is requested all the information required to print
            // the job will be provided by the application. For example FaxStartPrintJob()
            // uses direct printing. It provides the fax job parameters directly into
            // JOB_INFO_2.pParameters on its own.
            //

            if (!pDocEventUserMem->directPrinting)
            {
                Assert(cbIn >= sizeof(PVOID) && pjIn);
                //
                // Check if the printing application is using DDE and did not create new process for printing
                // If it so, the environment variable FAX_ENVVAR_PRINT_FILE was not found
                //
                hMutex = OpenMutex(MUTEX_ALL_ACCESS, FALSE, FAXXP_MEM_MUTEX_NAME);
                if (hMutex)
                {
                    if (WaitForSingleObject( hMutex, 1000 * 60 * 5) == WAIT_OBJECT_0)
                    {
                        HANDLE hSharedMem;
                        //
                        // we own the mutex...make sure we can open the shared memory region.
                        //
                        hSharedMem = OpenFileMapping(FILE_MAP_READ, FALSE, FAXXP_MEM_NAME);
                        if (NULL == hSharedMem)
                        {
                            Error(("OpenFileMapping failed error: %d\n", GetLastError()));
                            result = DOCUMENTEVENT_FAILURE;
                        }
                        else
                        {
                            //
                            // we own the mutex and we have the shared memory region open.
                            //

                            // check if we are printing to a file.
                            //
                            LPTSTR filename;

                            filename = (LPTSTR)MapViewOfFile(
                                                     hSharedMem,
                                                     FILE_MAP_READ,
                                                     0,
                                                     0,
                                                     0
                                                     );

                            if (!filename || IsBadStringPtr(filename, MAX_PATH * 2))
                            {
                                //
                                // Never trust the shared memory region. It might get corrupted by a malicious user.
                                //
                                Error(("Failed to map a view of the file or pointer is bad: %d\n", hSharedMem));
                                result = DOCUMENTEVENT_FAILURE;
                            }
                            else
                            {
                                //
                                // check if this is really the filename we want to print to.
                                //
                                LPDOCINFO   lpDocInfo = *((LPDOCINFO *)pjIn);
                                if (lpDocInfo->lpszDocName)
                                {
                                    LPTSTR      lptstrSubStr = NULL;
                                    LPTSTR lptstrTmpInputFile = _tcschr(filename, TEXT('\0'));
                                    Assert (lptstrTmpInputFile);
                                    lptstrTmpInputFile = _tcsinc(lptstrTmpInputFile);
                                    if (IsBadStringPtr(lptstrTmpInputFile, MAX_PATH * 2))
                                    {
                                        Error(("Corrupted shared memory buffer\n"));
                                        result = DOCUMENTEVENT_FAILURE;
                                    }
                                    else
                                    {
                                        Assert (_tcsclen(lptstrTmpInputFile));

                                        lptstrSubStr = _tcsstr(lpDocInfo->lpszDocName, lptstrTmpInputFile);
                                        if (lptstrSubStr)
                                        {
                                            //
                                            // We assume the shared memory was pointed to us
                                            //
                                            pDocEventUserMem->pPrintFile = DuplicateString(filename);
                                            if (!pDocEventUserMem->pPrintFile)
                                            {
                                                Error(("Memory allocation failed\n"));
                                                result = DOCUMENTEVENT_FAILURE;
                                            }
                                            else
                                            {
                                                //
                                                // At last - every thing is OK, this is a direct printing from PrintRandomDocument
                                                // to a application that is using DDE and an instance was already open.
                                                //
                                                pDocEventUserMem->directPrinting = TRUE;
                                                pDocEventUserMem->bAttachment = TRUE;
                                            }
                                        }
                                    }
                                }
                                else
                                {     
                                    //
                                    // To handle the race conditions between two diffrent instances of the printer driver over the shared memory created by PrintRandomDocument().
                                    // We are using now two mechanisms for detecting printing of an attachment using PrintRandomDocument().
                                    //     First we check if an environment variable is set (Set by PrintRandomDocument()). If it is set the driver knows it is an attachment printing.
                                    //     If it is not set, the driver looks for a mutex controlling a shred memory created by PrintRandomDocument(). If it does not exist it is a printing to the fax server.
                                    //     If the shared memory exists, the driver compares the document name in the DOCINFO provided by StartDoc, and the input file name in the shared memory.
                                    //     If there is a match, it is printing of an attachment, else it is a printing to the fax server
                                    // There is still a hole  in this implementation, if there is an open instance of the printing application, and the ShellExecuteEx does not create new process for printing, and the printing application does not set the lpszDocName in StartDoc to contain the input file name.
                                    Warning (("No lpszDocName in DOCINFO - Could not verify the input file name in shared memory\n"));
                                }
                                UnmapViewOfFile( filename );
                            }

                            if (!CloseHandle( hSharedMem ))
                            {
                                Error(("CloseHandle() failed: %d.\n", GetLastError()));
                                // Try to continue...
                            }
                        }
                        ReleaseMutex( hMutex );
                    }
                    else
                    {
                        //
                        //  Something went wrong with WaitForSingleObject
                        //
                        result = DOCUMENTEVENT_FAILURE;
                    }

                    if (!CloseHandle( hMutex ))
                    {
                        Error(("CloseHandle() failed: %d.\n", GetLastError()));
                        // Try to continue...
                    }
                }
            }

            //
            // Check again for direct printing
            //
            if (!pDocEventUserMem->directPrinting)
            {
                //
                //  client 'point and print' setup
                //
                if (FaxPointAndPrintSetup(pDocEventUserMem->lptstrPrinterName,FALSE, g_hModule))
                {
                    Verbose(("FaxPointAndPrintSetup succeeded\n"));
                }
                else
                {
                    Error(("FaxPointAndPrintSetup failed: %d\n", GetLastError()));
                }

                result = DocEventStartDocPre(hdc, pDocEventUserMem, *((LPDOCINFO *) pjIn));
            }
            else
            {
                //
                // we're doing direct printing -- check if this is an attachment
                //
                pDocEventUserMem->jobType = JOBTYPE_DIRECT;
                if (TRUE == pDocEventUserMem->bAttachment)
                {
                    (*((LPDOCINFO *) pjIn))->lpszOutput = pDocEventUserMem->pPrintFile;
                }
            }
            break;

        case DOCUMENTEVENT_STARTDOCPOST:

            if (!pDocEventUserMem->directPrinting && pDocEventUserMem->jobType == JOBTYPE_NORMAL)
            {
                //
                // Job ID is passed in from GDI
                //
                //
                // Save the job id returned from StartDoc. This is the job id of the body.
                // Pause the body job so we can attach cover page jobs to it before it starts
                // executing.
                //

                Assert(cbIn >= sizeof(DWORD) && pjIn);
                pDocEventUserMem->jobId = *((LPDWORD) pjIn);

                //
                // Tell spooler to pause the fax body job so that
                // we can associate cover pages with it later
                //

                if (! SetJob(pDocEventUserMem->hPrinter, pDocEventUserMem->jobId, 0, NULL, JOB_CONTROL_PAUSE))
                {
                    Error(("Couldn't pause fax body job: %d\n", pDocEventUserMem->jobId));
                    return DOCUMENTEVENT_FAILURE;
                }
            }
            break;

        case DOCUMENTEVENT_STARTPAGE:
            if (! pDocEventUserMem->directPrinting) 
            {
                //
                // Get PREVIOUS preview page (this event is called BEFORE the graphics dll recieved
                // the DrvSendPage() call for this page, so we actually get the previous page).
                //
                // NOTE: This event is recieved before the graphics dll recieves its DrvStartPage()
                // call where it increments the page count and resets the mapping surface. The first
                // time we get this event there is no actual page but we perform validity checking.
                //
                if (pDocEventUserMem->bShowPrintPreview && !pDocEventUserMem->bPreviewAborted)
                {
                    if (!AppendPreviewPage(pDocEventUserMem))
                    {
                        Error(("AppendPreviewPage() failed.\n"));
                        Assert(pDocEventUserMem->bPreviewAborted);
                        // We can continue with no print preview...
                    }
                }
            }
            break;

        case DOCUMENTEVENT_ENDPAGE:
            if (! pDocEventUserMem->directPrinting) 
            {
                pDocEventUserMem->pageCount++;
            }
            break;

        case DOCUMENTEVENT_ENDDOCPOST:
            if (!pDocEventUserMem->directPrinting)
            {
                //
                // Get the last preview page
                //
                if (pDocEventUserMem->bShowPrintPreview && !pDocEventUserMem->bPreviewAborted)
                {
                    if (!AppendPreviewPage(pDocEventUserMem))
                    {
                        Error(("AppendPreviewPage() failed.\n"));
                        Assert(pDocEventUserMem->bPreviewAborted);
                        // We can continue with no print preview...
                    }
                }
                //
                // Close the preview file
                //
                if (INVALID_HANDLE_VALUE != pDocEventUserMem->hPreviewFile)
                {
                    if (!CloseHandle(pDocEventUserMem->hPreviewFile))
                    {
                        Error(("CloseHandle() failed: %d.\n", GetLastError()));
                        // Try to continue...
                    }
                    pDocEventUserMem->hPreviewFile = INVALID_HANDLE_VALUE;
                }
                //
                // Call the handler
                //
                result = DocEventEndDocPost(hdc, pDocEventUserMem);
                //
                // If we created a preview file, delete it.
                //
                if (pDocEventUserMem->szPreviewFile[0] != TEXT('\0'))
                {
                    if (!DeleteFile(pDocEventUserMem->szPreviewFile))
                    {
                        Error(("DeleteFile() failed. Error code: %d.\n", GetLastError()));
                    }
                    pDocEventUserMem->szPreviewFile[0] = TEXT('\0');
                }
            }

            if (TRUE == pDocEventUserMem->bAttachment)
            {
                HANDLE              hEndDocEvent;
                LPTSTR szEndDocEventName= NULL;
                LPTSTR lptstrEventName = NULL;

                Assert (pDocEventUserMem->pPrintFile);
                //
                // Create the EndDoc event name
                //
                szEndDocEventName = (LPTSTR) MemAlloc( SizeOfString(pDocEventUserMem->pPrintFile) + SizeOfString(FAXXP_ATTACH_END_DOC_EVENT) );
            
                if (szEndDocEventName)
                {
                    _tcscpy (szEndDocEventName, pDocEventUserMem->pPrintFile);
                    _tcscat (szEndDocEventName, FAXXP_ATTACH_END_DOC_EVENT);

                    lptstrEventName = _tcsrchr(szEndDocEventName, TEXT('\\'));
                    Assert (lptstrEventName);
                    lptstrEventName = _tcsinc(lptstrEventName);
                    //
                    // Send event to the printing application (PrintRandomDocument() that file is ready)
                    //
                    hEndDocEvent = OpenEvent(EVENT_MODIFY_STATE, FALSE, lptstrEventName);
                    if (NULL == hEndDocEvent)
                    {
                        Error(("OpenEvent() failed. Error code: %d.\n", GetLastError()));
                        result = DOCUMENTEVENT_FAILURE;
                    }
                    else
                    {
                        if (!SetEvent( hEndDocEvent ))
                        {
                            Error(("SetEvent() failed. Error code: %d.\n", GetLastError()));
                            result = DOCUMENTEVENT_FAILURE;
                        }

                        if (!CloseHandle(hEndDocEvent))
                        {
                            Error(("CloseHandle() failed: %d.\n", GetLastError()));
                            // Try to continue...
                        }
                    }

                    MemFree(szEndDocEventName);
                }
                else
                {
                    Error(("Memory allocation for szEndDocEventName failed.\n"));
                    result = DOCUMENTEVENT_FAILURE;
                }

            }
            break;

        case DOCUMENTEVENT_DELETEDC:

            EnterDrvSem();

            if (pDocEventUserMem == gDocEventUserMemList)
            {
                gDocEventUserMemList = gDocEventUserMemList->pNext;
            }
            else 
            {
                PDOCEVENTUSERMEM p;

                if (p = gDocEventUserMemList) 
                {
                    while (p->pNext && p->pNext != pDocEventUserMem)
                    {
                        p = p->pNext;
                    }
                    if (p->pNext != NULL)
                    {
                        p->pNext = pDocEventUserMem->pNext;
                    }
                    else
                    {
                        Error(("Orphaned user mode memory structure!!!\n"));
                    }
                } 
                else
                {
                    Error(("gDocEventUserMemList shouldn't be NULL!!!\n"));
                }
            }
            LeaveDrvSem();
            FreePDEVUserMem(pDocEventUserMem);
            break;

        case DOCUMENTEVENT_ABORTDOC:
            if (TRUE == pDocEventUserMem->bAttachment)
            {
                //
                // Send event to the printing application (PrintRandomDocument() that printing was aborted)
                //
                HANDLE              hAbortEvent;
                TCHAR szAbortEventName[FAXXP_ATTACH_EVENT_NAME_LEN] = {0};
                LPTSTR lptstrEventName = NULL;

                Assert (pDocEventUserMem->pPrintFile);
                //
                // Create the Abort event name
                //
                _tcscpy (szAbortEventName, pDocEventUserMem->pPrintFile);
                _tcscat (szAbortEventName, FAXXP_ATTACH_ABORT_EVENT);
                lptstrEventName = _tcsrchr(szAbortEventName, TEXT('\\'));
                Assert (lptstrEventName);
                lptstrEventName = _tcsinc(lptstrEventName);

                hAbortEvent = OpenEvent(EVENT_MODIFY_STATE, FALSE, lptstrEventName);
                if (NULL == hAbortEvent)
                {
                    Error(("OpenEvent() failed. Error code: %d.\n", GetLastError()));
                    result = DOCUMENTEVENT_FAILURE;
                }
                else
                {
                    if (!SetEvent( hAbortEvent ))
                    {
                        Error(("SetEvent() failed. Error code: %d.\n", GetLastError()));
                        result = DOCUMENTEVENT_FAILURE;
                    }

                    if (!CloseHandle(hAbortEvent))
                    {
                        Error(("CloseHandle() failed: %d.\n", GetLastError()));
                        // Try to continue...
                    }
                }
            }
            break;

        case DOCUMENTEVENT_RESETDCPOST:
        case DOCUMENTEVENT_ENDDOCPRE:
            break;

        case DOCUMENTEVENT_ESCAPE:
        default:
            Verbose(("Unsupported DrvDocumentEvent escape: %d\n", iEsc));
            result = DOCUMENTEVENT_UNSUPPORTED;
            break;
    }
    return result;
}   // DrvDocumentEvent


/*
	Function:
				ShowReentrancyMessage
	Purpose:
				The code of FxsWzrd.dll is not re-entrant.
				We prevent its running from different threads inside one process.
				We want to notify user about this.

	Return Value:
				ERROR_SUCCESS		--	success
				Win32 Error Code	--	failure

	Author:
				Iv Vakaluk (IvG) 2-Sept-2002
*/
DWORD ShowReentrancyMessage(void)
{
    DWORD	dwRes				= ERROR_SUCCESS;
    TCHAR   szTitle[MAX_PATH]   = {0};
    TCHAR   szText[MAX_PATH]	= {0};

    Verbose(("Entering ShowReentrancyMessage()\n"));

	//
    // Load Title
	//
    if (!LoadString(g_hResource, IDS_REENTRANCY_TITLE, szTitle, sizeof(szTitle)/sizeof(TCHAR)))
    {
        dwRes = GetLastError();
		Error(("LoadString(IDS_REENTRANCY_TITLE) failed: %d.\n", dwRes));
        return dwRes;
    }

	//
    // Load Message title
	//
    if (!LoadString(g_hResource, IDS_REENTRANCY_TEXT, szText, sizeof(szText)/sizeof(TCHAR)))
    {
        dwRes = GetLastError();
		Error(("LoadString(IDS_REENTRANCY_TEXT) failed: %d.\n", dwRes));
        return dwRes;
    }

    if (!AlignedMessageBox(NULL, szText, szTitle, MB_OK))
	{
		dwRes = GetLastError();
		Error(("MessageBox() failed: %d.\n", dwRes));
		return dwRes;
	}

	return dwRes;
}
=== C:/Users/treeman/Desktop/windows nt source code\Source\Win2K3\NT\printscan\faxsrv\print\faxprint\faxui\faxopts.c ===
/*++

Copyright (c) 1996  Microsoft Corporation

Module Name:

    faxopts.c

Abstract:

    Functions for handling the Fax Options property sheet page

Environment:

    Fax driver user interface

Revision History:

    01/16/96 -davidx-
        Created it.

    mm/dd/yy -author-
        description

--*/

#include "faxui.h"
#include "faxhelp.h"

//
// Table for mapping control IDs to help indices
//

static ULONG_PTR faxOptionsHelpIDs[] = {

    IDC_PAPER_SIZE,                 IDH_FAXDEFAULT_PAPER_SIZE,
    IDC_IMAGE_QUALITY,              IDH_FAXDEFAULT_IMAGE_QUALITY,
    IDC_PORTRAIT,                   IDH_FAXDEFAULT_PORTRAIT,
    IDC_LANDSCAPE,                  IDH_FAXDEFAULT_LANDSCAPE,
    IDI_FAX_OPTIONS,                (DWORD) -1,
    IDC_TITLE,                      (DWORD) -1,
    IDC_DEFAULT_PRINT_SETUP_GRP,    IDH_FAXDEFAULT_DEFAULT_PRINT_SETUP_GRP,
    IDC_ORIENTATION,                IDH_FAXDEFAULT_ORIENTATION,
    0,                              0
};



VOID
DoInitializeFaxOptions(
    HWND    hDlg,
    PUIDATA pUiData
    )

/*++

Routine Description:

    Initializes the Fax Options property sheet page with information from the registry

Arguments:

    hDlg - Handle to the Fax Options property sheet page
    pUiData - Points to our UIDATA structure

Return Value:

    NONE

--*/

{
    PDEVMODE        pdmPublic = &pUiData->devmode.dmPublic;
    PDMPRIVATE      pdmPrivate = &pUiData->devmode.dmPrivate;
    TCHAR           buffer[MAX_STRING_LEN];
    HWND            hwndList;
    INT             itemId;

    //
    // Initialize the print setup controls:
    //  paper size
    //  image quality
    //  orientation
    //  billing code
    //

    if (hwndList = GetDlgItem(hDlg, IDC_PAPER_SIZE)) {

        LPTSTR  pFormName = pUiData->pFormNames;
        INT     listIdx;

        for (itemId=0; itemId < pUiData->cForms; itemId++, pFormName += CCHPAPERNAME) {

            if ((listIdx = (INT)SendMessage(hwndList, CB_ADDSTRING, 0, (LPARAM) pFormName)) != CB_ERR) {

                SendMessage(hwndList, CB_SETITEMDATA, listIdx, itemId);

                if (_tcscmp(pFormName, pdmPublic->dmFormName) == EQUAL_STRING)
                    SendMessage(hwndList, CB_SETCURSEL, listIdx, 0);
            }
        }
    }

    if (hwndList = GetDlgItem(hDlg, IDC_IMAGE_QUALITY)) {

        LoadString(g_hResource, IDS_QUALITY_NORMAL, buffer, MAX_STRING_LEN);
        SendMessage(hwndList, CB_ADDSTRING, 0, (LPARAM) buffer);

        LoadString(g_hResource, IDS_QUALITY_DRAFT, buffer, MAX_STRING_LEN);
        SendMessage(hwndList, CB_ADDSTRING, 0, (LPARAM) buffer);

        itemId = (pdmPublic->dmYResolution == FAXRES_VERTDRAFT) ? 1 : 0;
        SendMessage(hwndList, CB_SETCURSEL, itemId, 0);
    }

    itemId = (pdmPublic->dmOrientation == DMORIENT_LANDSCAPE) ?
                IDC_LANDSCAPE : IDC_PORTRAIT;

    CheckDlgButton(hDlg, itemId, TRUE);


    //
    // Disable all controls if the user has no permission
    //

    if (! pUiData->hasPermission) {
        EnableWindow(GetDlgItem(hDlg, IDC_PAPER_SIZE), FALSE);
        EnableWindow(GetDlgItem(hDlg, IDC_IMAGE_QUALITY), FALSE);
        EnableWindow(GetDlgItem(hDlg, IDC_PORTRAIT), FALSE);
        EnableWindow(GetDlgItem(hDlg, IDC_LANDSCAPE), FALSE);
    }
}



VOID
DoSaveFaxOptions(
    HWND    hDlg,
    PUIDATA pUiData
    )

/*++

Routine Description:

    Save the information on the Fax Options property sheet page to registry

Arguments:

    hDlg - Handle to the Fax Options property sheet page
    pUiData - Points to our UIDATA structure

Return Value:

    NONE

--*/

{
    PDEVMODE    pdmPublic = &pUiData->devmode.dmPublic;
    PDMPRIVATE  pdmPrivate = &pUiData->devmode.dmPrivate;
    HWND        hwndList;
    INT         listIdx;

    //
    // Time to send
    //

    //
    // Retrieve the current settings of print setup controls:
    //  paper size
    //  image quality
    //  orientation
    //  billing code
    //

    if ((hwndList = GetDlgItem(hDlg, IDC_PAPER_SIZE)) &&
        (listIdx = (INT)SendMessage(hwndList, CB_GETCURSEL, 0, 0)) != CB_ERR)
    {
        listIdx = (INT)SendMessage(hwndList, CB_GETITEMDATA, listIdx, 0);

        if (listIdx >= 0 && listIdx < pUiData->cForms) {

            pdmPublic->dmFields &= ~(DM_PAPERLENGTH|DM_PAPERWIDTH);
            pdmPublic->dmFields |= DM_FORMNAME;
            pdmPublic->dmPaperSize = pUiData->pPapers[listIdx];

            CopyString(pdmPublic->dmFormName,
                        pUiData->pFormNames + listIdx * CCHPAPERNAME,
                        CCHFORMNAME);
        }
    }

    pdmPublic->dmPrintQuality = FAXRES_HORIZONTAL;

    pdmPublic->dmYResolution =
        (SendDlgItemMessage(hDlg, IDC_IMAGE_QUALITY, CB_GETCURSEL, 0, 0) == 1) ?
            FAXRES_VERTDRAFT :
            FAXRES_VERTICAL;

    pdmPublic->dmOrientation =
         IsDlgButtonChecked(hDlg, IDC_LANDSCAPE) ? DMORIENT_LANDSCAPE : DMORIENT_PORTRAIT;
}


INT_PTR
FaxOptionsProc(
    HWND hDlg,
    UINT message,
    WPARAM wParam,
    LPARAM lParam
    )

/*++

Routine Description:

    Procedure for handling Fax Options property sheet page

Arguments:

    hDlg - Identifies the property sheet page
    message - Specifies the message
    wParam - Specifies additional message-specific information
    lParam - Specifies additional message-specific information

Return Value:

    Depends on the value of message parameter

--*/

{
    PUIDATA pUiData;
    static BOOL bPortrait;

    switch (message) {

    case WM_INITDIALOG:

        //
        // Remember the pointer to our UIDATA structure
        //

        lParam = ((PROPSHEETPAGE *) lParam)->lParam;
        pUiData = (PUIDATA) lParam;
        Assert(ValidUiData(pUiData));
        SetWindowLongPtr(hDlg, DWLP_USER, lParam);

        //
        // Intitialize the controls with information from the registry
        //

        DoInitializeFaxOptions(hDlg, pUiData);
        bPortrait = IsDlgButtonChecked(hDlg,IDC_PORTRAIT);
        return TRUE;

    case WM_COMMAND:

        if (HIWORD(wParam) == CBN_SELCHANGE) {
            if (GetDlgCtrlID((HWND)lParam) == IDC_IMAGE_QUALITY ||
                GetDlgCtrlID((HWND)lParam) == IDC_PAPER_SIZE ) {
                PropSheet_Changed(GetParent(hDlg),hDlg);
            }
        }

        if (HIWORD(wParam) == BN_CLICKED) {
            if ((LOWORD(wParam) == IDC_PORTRAIT && !bPortrait) ||
                (LOWORD(wParam) == IDC_LANDSCAPE && bPortrait)) {
                PropSheet_Changed(GetParent(hDlg),hDlg);
            }
        }

        break;

    case WM_NOTIFY:

        if (((NMHDR *) lParam)->code == PSN_APPLY) {
            pUiData = (PUIDATA) GetWindowLongPtr(hDlg, DWLP_USER);
            Assert(ValidUiData(pUiData));

            //
            // User pressed OK or Apply - validate inputs and save changes
            //

            DoSaveFaxOptions(hDlg, pUiData);


            //
            // HACK: Inform common UI library that user has pressed OK
            //

            pUiData->pfnComPropSheet(pUiData->hComPropSheet,
                                     CPSFUNC_SET_RESULT,
                                     (LPARAM) pUiData->hFaxOptsPage,
                                     CPSUI_OK);

            return TRUE;
        } else if (((NMHDR *) lParam)->code == DTN_DATETIMECHANGE) {
           PropSheet_Changed(GetParent(hDlg),hDlg);
        }
        break;

    case WM_HELP:
        WinHelpContextPopup(((LPHELPINFO)lParam)->dwContextId, hDlg);
        return TRUE;
    }

    return FALSE;
}
=== C:/Users/treeman/Desktop/windows nt source code\Source\Win2K3\NT\printscan\faxsrv\print\faxprint\faxui\docprop.c ===
/*++

Copyright (c) 1996  Microsoft Corporation

Module Name:

    docprop.c

Abstract:

    Implemetation of DDI entry points:
        DrvDocumentPropertySheets
        DrvDocumentProperties
        DrvAdvancedDocumentProperties
        DrvConvertDevMode

Environment:

    Fax driver user interface

Revision History:

    01/09/96 -davidx-
        Created it.

    mm/dd/yy -author-
        description

--*/

#include "faxui.h"
#include "forms.h"
#include "libproto.h"
#include "faxhelp.h"


INT_PTR FaxOptionsProc(HWND, UINT, WPARAM, LPARAM);
LONG SimpleDocumentProperties(PDOCUMENTPROPERTYHEADER);
BOOL GenerateFormsList(PUIDATA);
BOOL AddDocPropPages(PUIDATA, LPTSTR);
LPTSTR GetHelpFilename(PUIDATA);
BOOL SaveUserInfo(PDRVDEVMODE);

BOOL
SaveUserInfo(PDRVDEVMODE pDM) {
    HKEY hKey;
    
    if ((hKey = GetUserInfoRegKey(REGKEY_FAX_USERINFO,FALSE))) {
        SetRegistryString( hKey, REGVAL_BILLING_CODE, pDM->dmPrivate.billingCode  );
        SetRegistryString( hKey, REGVAL_MAILBOX     , pDM->dmPrivate.emailAddress );

        RegCloseKey(hKey);
        return TRUE;
    }

    return FALSE;
}


LONG
DrvDocumentPropertySheets(
    PPROPSHEETUI_INFO   pPSUIInfo,
    LPARAM              lParam
    )

/*++

Routine Description:

    Display "Document Properties" property sheets

Arguments:

    pPSUIInfo - Pointer to a PROPSHEETUI_INFO structure
    lParam - Pointer to a DOCUMENTPROPERTYHEADER structure

Return Value:

    > 0 if successful, <= 0 if failed

[Note:]

    Please refer to WinNT DDK/SDK documentation for more details.

--*/

{
    PDOCUMENTPROPERTYHEADER pDPHdr;
    PUIDATA                 pUiData;
    int                     iRet = -1;

    //
    // Do not execute any code before this initialization
    //
    if(!InitializeDll())
    {
        return iRet;
    }

    //
    // Validate input parameters
    // pPSUIInfo = NULL is a special case: don't need to display the dialog
    //

    if (! (pDPHdr = (PDOCUMENTPROPERTYHEADER) (pPSUIInfo ? pPSUIInfo->lParamInit : lParam))) {

        Assert(FALSE);
        return -1;
    }

    if (pPSUIInfo == NULL)
    {
        return SimpleDocumentProperties(pDPHdr);
    }

    Verbose(("DrvDocumentPropertySheets: %d\n", pPSUIInfo->Reason));

    //
    // Create a UIDATA structure if necessary
    //
    pUiData = (pPSUIInfo->Reason == PROPSHEETUI_REASON_INIT) ?
                    FillUiData(pDPHdr->hPrinter, pDPHdr->pdmIn) :
                    (PUIDATA) pPSUIInfo->UserData;

    if (!ValidUiData(pUiData))
    {
        goto exit;
    }
    //
    // Handle various cases for which this function might be called
    //
    switch (pPSUIInfo->Reason) 
    {
        case PROPSHEETUI_REASON_INIT:

            pUiData->hasPermission = ((pDPHdr->fMode & DM_NOPERMISSION) == 0);
            pUiData->pfnComPropSheet = pPSUIInfo->pfnComPropSheet;
            pUiData->hComPropSheet = pPSUIInfo->hComPropSheet;

            if (pDPHdr->fMode & DM_USER_DEFAULT)
            {
                pUiData->configDefault = TRUE;
            }
            //
            // Find online help filename
            //
            GetHelpFilename(pUiData);
            //
            // Add our pages to the property sheet
            //
            if (GenerateFormsList(pUiData) && AddDocPropPages(pUiData, pDPHdr->pszPrinterName)) 
            {
                pPSUIInfo->UserData = (DWORD_PTR) pUiData;
                pPSUIInfo->Result = CPSUI_CANCEL;
                iRet = 1;
                goto exit;
            }
            //
            // Clean up properly in case of an error
            //
            HeapDestroy(pUiData->hheap);
            break;

        case PROPSHEETUI_REASON_GET_INFO_HEADER:
            {
                PPROPSHEETUI_INFO_HEADER   pPSUIHdr;

                pPSUIHdr = (PPROPSHEETUI_INFO_HEADER) lParam;
                pPSUIHdr->Flags = PSUIHDRF_PROPTITLE | PSUIHDRF_NOAPPLYNOW;
                pPSUIHdr->pTitle = pDPHdr->pszPrinterName;
                pPSUIHdr->hInst = g_hResource;
                pPSUIHdr->IconID = IDI_CPSUI_PRINTER2;
            }
            iRet = 1;
            goto exit;

        case PROPSHEETUI_REASON_SET_RESULT:
            //
            // Copy the new devmode back into the output buffer provided by the caller
            // Always return the smaller of current and input devmode
            //
            {
                PSETRESULT_INFO pSRInfo = (PSETRESULT_INFO) lParam;

                Verbose(("Set result: %d\n", pSRInfo->Result));

                if (pSRInfo->Result == CPSUI_OK && (pDPHdr->fMode & (DM_COPY|DM_UPDATE))) 
                {
                    if (!ConvertDevmodeOut(
						(PDEVMODE) &pUiData->devmode,
						pDPHdr->pdmIn,
						pDPHdr->pdmOut,
						pDPHdr->cbOut))
					{
						goto exit;
					}
					
                    SaveUserInfo(&pUiData->devmode);
                }

                pPSUIInfo->Result = pSRInfo->Result;
            }
            iRet = 1;
            goto exit;

        case PROPSHEETUI_REASON_DESTROY:
            //
            // Cleanup properly before exiting
            //
            HeapDestroy(pUiData->hheap);
            iRet = 1;
            goto exit;
    }

exit:
    return iRet;
}   // DrvDocumentPropertySheets


LONG
DoDocumentProperties(
    HWND        hwnd,
    HANDLE      hPrinter,
    LPTSTR      pPrinterName,
    PDEVMODE    pdmOutput,
    PDEVMODE    pdmInput,
    DWORD       fMode
    )

/*++

Arguments:

    hwnd - Handle to the parent window of the document properties dialog box.

    hPrinter - Handle to a printer object.

    pPrinterName - Points to a null-terminated string that specifies
        the name of the device for which the document properties dialog
        box should be displayed.

    pdmOutput - Points to a DEVMODE structure that receives the document
        properties data specified by the user.

    pdmInput - Points to a DEVMODE structure that initializes the dialog
        box controls. This parameter can be NULL.

    fmode - Specifies a mask of flags that determine which operations
        the function performs.

Return Value:

    > 0 if successful
    = 0 if canceled
    < 0 if error

--*/

{
    DOCUMENTPROPERTYHEADER  docPropHdr;
    DWORD                   result;

    //
    // Initialize a DOCUMENTPROPERTYHEADER structure
    //

    memset(&docPropHdr, 0, sizeof(docPropHdr));
    docPropHdr.cbSize = sizeof(docPropHdr);
    docPropHdr.hPrinter = hPrinter;
    docPropHdr.pszPrinterName = pPrinterName;
    docPropHdr.pdmIn = pdmInput;
    docPropHdr.pdmOut = pdmOutput;
    docPropHdr.fMode = fMode;

    //
    // Don't need to get compstui involved when the dialog is not displayed
    //

    if ((fMode & DM_PROMPT) == 0)
        return SimpleDocumentProperties(&docPropHdr);

    CallCompstui(hwnd, DrvDocumentPropertySheets, (LPARAM) &docPropHdr, &result);
    return result;
}


LONG
DrvDocumentProperties(
    HWND        hwnd,
    HANDLE      hPrinter,
    LPTSTR      pPrinterName,
    PDEVMODE    pdmOutput,
    PDEVMODE    pdmInput,
    DWORD       fMode
    )

/*++

Routine Description:

    Set the public members of a DEVMODE structure for a print document

[Note:]

    Please refer to WinNT DDK/SDK documentation for more details.

    This is the old entry point for the spooler. Even though
    no one should be using this, do it for compatibility.

--*/

{
    LONG result;

    Verbose(("Entering DrvDocumentProperties: fMode = %x...\n", fMode));

    //
    // Do not execute any code before this initialization
    //
    if(!InitializeDll())
    {
        return IDCANCEL;
    }

    //
    // Check if caller is asking querying for size
    //

    if (fMode == 0 || pdmOutput == NULL)
        return sizeof(DRVDEVMODE);

    //
    // Call the common routine shared with DrvAdvancedDocumentProperties
    //

    result = DoDocumentProperties(hwnd, hPrinter, pPrinterName, pdmOutput, pdmInput, fMode);

    return (result > 0) ? IDOK : (result == 0) ? IDCANCEL : result;
}


LONG
DrvAdvancedDocumentProperties(
    HWND        hwnd,
    HANDLE      hPrinter,
    LPTSTR      pPrinterName,
    PDEVMODE    pdmOutput,
    PDEVMODE    pdmInput
    )

/*++

Routine Description:

    Set the private members of a DEVMODE structure.
    In this release, this function is almost identical to
    DrvDocumentProperties above with a few minor exceptions

[Note:]

    Please refer to WinNT DDK/SDK documentation for more details.

    This is the old entry point for the spooler. Even though
    no one should be using this, do it for compatibility.

--*/

{
    Verbose(("Entering DrvAdvancedDocumentProperties...\n"));

    //
    // Do not execute any code before this initialization
    //
    if(!InitializeDll())
    {
        return -1;
    }

    //
    // Return the number of bytes required if pdmOutput is NULL
    //
    if (pdmOutput == NULL)
        return sizeof(DRVDEVMODE);

    //
    // Otherwise, call the common routine shared with DrvDocumentProperties
    //

    return DoDocumentProperties(hwnd,
                                hPrinter,
                                pPrinterName,
                                pdmOutput,
                                pdmInput,
                                DM_COPY|DM_PROMPT|DM_ADVANCED) > 0;
}



BOOL
DrvConvertDevMode(
    LPTSTR      pPrinterName,
    PDEVMODE    pdmIn,
    PDEVMODE    pdmOut,
    PLONG       pcbNeeded,
    DWORD       fMode
    )

/*++

Routine Description:

    Use by SetPrinter and GetPrinter to convert devmodes

Arguments:

    pPrinterName - Points to printer name string
    pdmIn - Points to the input devmode
    pdmOut - Points to the output devmode buffer
    pcbNeeded - Specifies the size of output buffer on input
        On output, this is the size of output devmode
    fMode - Specifies what function to perform

Return Value:

    TRUE if successful
    FALSE otherwise and an error code is logged

--*/

{
    static DRIVER_VERSION_INFO versionInfo = {

        // Current driver version number and private devmode size

        DRIVER_VERSION, sizeof(DMPRIVATE),

        // 3.51 driver version number and private devmode size
        // NOTE: We don't have a 3.51 driver - use current version number and devmode size.

        DRIVER_VERSION, sizeof(DMPRIVATE)
    };

    INT     result;
    HANDLE  hPrinter;

    Verbose(("Entering DrvConvertDevMode: %x...\n", fMode));

    //
    // Do not execute any code before this initialization
    //
    if(!InitializeDll())
    {
        return FALSE;
    }

    //
    // Call a library routine to handle the common cases
    //

    result = CommonDrvConvertDevmode(pPrinterName, pdmIn, pdmOut, pcbNeeded, fMode, &versionInfo);

    //
    // If not handled by the library routine, we only need to worry
    // about the case when fMode is CDM_DRIVER_DEFAULT
    //

    if (result == CDM_RESULT_NOT_HANDLED && fMode == CDM_DRIVER_DEFAULT) {

        //
        // Return driver default devmode
        //

        if (OpenPrinter(pPrinterName, &hPrinter, NULL)) {

            PDRVDEVMODE pdmDefault = (PDRVDEVMODE) pdmOut;

            DriverDefaultDevmode(pdmDefault, pPrinterName, hPrinter);
            pdmDefault->dmPrivate.flags |= FAXDM_DRIVER_DEFAULT;

            result = CDM_RESULT_TRUE;
            ClosePrinter(hPrinter);

        } else
            Error(("OpenPrinter failed: %d\n", GetLastError()));
    }

    return (result == CDM_RESULT_TRUE);
}



LONG
SimpleDocumentProperties(
    PDOCUMENTPROPERTYHEADER pDPHdr
    )

/*++

Routine Description:

    Handle simple "Document Properties" where we don't need to display
    a dialog and therefore don't have to have common UI library involved

Arguments:

    pDPHdr - Points to a DOCUMENTPROPERTYHEADER structure

Return Value:

    > 0 if successful, <= 0 otherwise

--*/

{
    PUIDATA pUiData;
	int iRet = -1;

    //
    // Check if the caller is interested in the size only
    //

    pDPHdr->cbOut = sizeof(DRVDEVMODE);

    if (pDPHdr->fMode == 0 || pDPHdr->pdmOut == NULL)
	{
        return pDPHdr->cbOut;
	}

    //
    // Create a UIDATA structure
    //

    if (! (pUiData = FillUiData(pDPHdr->hPrinter, pDPHdr->pdmIn)))
	{
        return iRet;
	}

    //
    // Copy the devmode back into the output buffer provided by the caller
    // Always return the smaller of current and input devmode
    //
    if (pDPHdr->fMode & (DM_COPY | DM_UPDATE))
	{
        if (ConvertDevmodeOut((PDEVMODE) &pUiData->devmode, pDPHdr->pdmIn, pDPHdr->pdmOut, pDPHdr->cbOut))
		{
			iRet = 1;
		}
	}

    HeapDestroy(pUiData->hheap);
    return iRet;
}



BOOL
AddDocPropPages(
    PUIDATA pUiData,
    LPTSTR  pPrinterName
    )

/*++

Routine Description:

    Add our "Document Properties" pages to the property sheet

Arguments:

    pUiData - Points to our UIDATA structure
    pPrinterName - Specifies the printer name

Return Value:

    TRUE if successful, FALSE otherwise

--*/

{
    PROPSHEETPAGE   psp = {0};
    HANDLE          hActCtx;
    //
    // "Document Properties" dialog only has one tab - "Fax Options"
    //
    psp.dwSize = sizeof(PROPSHEETPAGE);
    psp.dwFlags = 0;
    psp.hInstance = g_hResource;

    psp.lParam = (LPARAM) pUiData;
    psp.pszTemplate = MAKEINTRESOURCE(IDD_DOCPROP);
    psp.pfnDlgProc = FaxOptionsProc;
    //
    // Need to add a Activation Context so that Compstui will create the property page using
    // ComCtl v6 (i.e. so it will / can be Themed).
    //
    hActCtx = GetFaxActivationContext();
    if (INVALID_HANDLE_VALUE != hActCtx)
    {
        pUiData->pfnComPropSheet(pUiData->hComPropSheet, 
                                 CPSFUNC_SET_FUSION_CONTEXT, 
                                 (LPARAM)hActCtx, 
                                 0);
    }

    pUiData->hFaxOptsPage = (HANDLE)
        pUiData->pfnComPropSheet(pUiData->hComPropSheet,
                                 CPSFUNC_ADD_PROPSHEETPAGE,
                                 (LPARAM) &psp,
                                 0);

    return (pUiData->hFaxOptsPage != NULL);
}



BOOL
GenerateFormsList(
    PUIDATA pUiData
    )

/*++

Routine Description:

    Generate the list of forms supported by the fax driver

Arguments:

    pUiData - Points to our UIDATA structure

Return Value:

    TRUE if successful, FALSE if there is an error

--*/

{
    PFORM_INFO_1    pFormsDB;
    DWORD           cForms, count;

    //
    // Get a list of forms in the forms database
    //

    pFormsDB = GetFormsDatabase(pUiData->hPrinter, &cForms);

    if (pFormsDB == NULL || cForms == 0) {

        Error(("Couldn't get system forms\n"));
        return FALSE;
    }

    //
    // Enumerate the list of supported forms
    //

    pUiData->cForms = count = EnumPaperSizes(NULL, pFormsDB, cForms, DC_PAPERS);
    Assert(count != GDI_ERROR);

    pUiData->pFormNames = HeapAlloc(pUiData->hheap, 0, sizeof(TCHAR) * count * CCHPAPERNAME);
    pUiData->pPapers = HeapAlloc(pUiData->hheap, 0, sizeof(WORD) * count);

    if (!pUiData->pFormNames || !pUiData->pPapers) 
    {
        if(pUiData->pFormNames)
        {
            HeapFree(pUiData->hheap, 0, pUiData->pFormNames);
        }

        if(pUiData->pPapers)
        {
            HeapFree(pUiData->hheap, 0, pUiData->pPapers);
        }

        MemFree(pFormsDB);
        return FALSE;
    }

    EnumPaperSizes(pUiData->pFormNames, pFormsDB, cForms, DC_PAPERNAMES);
    EnumPaperSizes(pUiData->pPapers, pFormsDB, cForms, DC_PAPERS);

    MemFree(pFormsDB);
    return TRUE;
}



LPTSTR
GetHelpFilename(
    PUIDATA pUiData
    )

/*++

Routine Description:

    Return the driver's help filename string

Arguments:

    pUiData - Points to our UIDATA structure

Return Value:

    Pointer to the driver help filename, NULL if error

--*/

{
    PDRIVER_INFO_3  pDriverInfo3 = NULL;
    PVOID           pHelpFile = NULL;

    //
    // Attempt to get help file name using the new DRIVER_INFO_3
    //

    if (pDriverInfo3 = MyGetPrinterDriver(pUiData->hPrinter, 3)) {

        if ((pDriverInfo3->pHelpFile != NULL) &&
            (pHelpFile = HeapAlloc(pUiData->hheap, 0, SizeOfString(pDriverInfo3->pHelpFile))))
        {
            _tcscpy(pHelpFile, pDriverInfo3->pHelpFile);
        }

        MemFree(pDriverInfo3);
    }

    //
    // If DRIVER_INFO_3 isn't supported, get help file name the old fashion way
    //

    if (pHelpFile == NULL) {
        if (!(pHelpFile = HeapAlloc(pUiData->hheap, 0, SizeOfString(FAXCFG_HELP_FILENAME))) )
        {
            pHelpFile = NULL;

        } else {

            _tcscpy(pHelpFile, FAXCFG_HELP_FILENAME);
        }
    }

    Verbose(("Driver help filename: %ws\n", pHelpFile));
    return (pUiData->pHelpFile = pHelpFile);
}
=== C:/Users/treeman/Desktop/windows nt source code\Source\Win2K3\NT\printscan\faxsrv\print\faxprint\faxui\faxui.c ===
/*++

Copyright (c) 1996  Microsoft Corporation

Module Name:

    faxui.c

Abstract:

    Common routines for fax driver user interface

Environment:

    Fax driver user interface

Revision History:

    01/09/96 -davidx-
        Created it.

    mm/dd/yy -author-
        description

--*/

#include "faxui.h"
#include "forms.h"
#include <delayimp.h>


CRITICAL_SECTION    faxuiSemaphore;                 // Semaphore for protecting critical sections
HANDLE              g_hModule;                      // DLL instance handle
HANDLE              g_hResource;                    // Resource DLL instance handle 
HANDLE				g_hFxsApiModule = NULL;			// FXSAPI.DLL instance handle
PDOCEVENTUSERMEM    gDocEventUserMemList = NULL;    // Global list of user mode memory structures
INT                 _debugLevel = 1;                // for debuggping purposes
static BOOL         gs_bfaxuiSemaphoreInit = FALSE; // Flag for faxuiSemaphore CS initialization

BOOL                g_bSHFusionInitialized = FALSE; // Fusion initialized flag

CRITICAL_SECTION    g_csInitializeDll;              // DLL initialization critical sections
BOOL                g_bInitDllCritSection = FALSE;  // Critical sections initialization flag
BOOL                g_bDllInitialied = FALSE;       // TRUE if the DLL successfuly initialized

char                g_szDelayLoadFxsApiName[64] = {0};  // Case sensitive name of FxsApi.dll for delay load mechanism 

static HMODULE      gs_hShlwapi = NULL;             // Shlwapi.dll handle
PPATHISRELATIVEW    g_pPathIsRelativeW = NULL;
PPATHMAKEPRETTYW    g_pPathMakePrettyW = NULL;
PSHAUTOCOMPLETE     g_pSHAutoComplete = NULL;

//
//	Blocks the re-entrancy of FxsWzrd.dll 
//		TRUE when there is running Fax Send Wizard instance
//		FALSE otherwise
//
BOOL				g_bRunningWizard = FALSE;		

//
//	Protects the g_bRunningWizard global variable from being accessed by multiple threads simultaneously
//
CRITICAL_SECTION	g_csRunningWizard;
BOOL				g_bInitRunningWizardCS = FALSE;

PVOID
PrMemAlloc(
    SIZE_T size
    )
{
    return (PVOID)LocalAlloc(LPTR, size);
}

PVOID
PrMemReAlloc(
	HLOCAL hMem,
	SIZE_T size
    )
{
    return (PVOID)LocalReAlloc(hMem, size, LMEM_ZEROINIT);
}

VOID
PrMemFree(
    PVOID ptr
    )
{
    if (ptr)
	{
        LocalFree((HLOCAL) ptr);
    }
}

FARPROC WINAPI DelayLoadHandler(unsigned dliNotify,PDelayLoadInfo pdli)
{
	switch (dliNotify)
	{
	case dliNotePreLoadLibrary:
        if (_strnicmp(pdli->szDll, FAX_API_MODULE_NAME_A, strlen(FAX_API_MODULE_NAME_A))==0)
        {
            //
            // Save the sensitive name DLL name for later use
            //
            strncpy(g_szDelayLoadFxsApiName, pdli->szDll, ARR_SIZE(g_szDelayLoadFxsApiName)-1);

            // trying to load FXSAPI.DLL
            if(!g_hFxsApiModule)
            {
                Assert(FALSE);
            }
            return g_hFxsApiModule;
        }
	}
    return 0;
}

PfnDliHook __pfnDliNotifyHook = DelayLoadHandler;

BOOL
DllMain(
    HANDLE      hModule,
    ULONG       ulReason,
    PCONTEXT    pContext
    )

/*++

Routine Description:

    DLL initialization procedure.

Arguments:

    hModule - DLL instance handle
    ulReason - Reason for the call
    pContext - Pointer to context (not used by us)

Return Value:

    TRUE if DLL is initialized successfully, FALSE otherwise.

--*/

{    
    switch (ulReason) 
    {
        case DLL_PROCESS_ATTACH:
            {
				DWORD dwVersion = GetVersion();

				if(4 == (LOBYTE(LOWORD(dwVersion))) && 0 == (HIBYTE(LOWORD(dwVersion))))
                {
                    //
                    // The current OS is NT4
                    //
                    // Keep our driver UI dll always loaded in memory
                    // We need this for NT4 clients
                    //
                    TCHAR  szDllName[MAX_PATH+1] = {0};
                    if (!GetModuleFileName(hModule, szDllName, ARR_SIZE(szDllName)-1))
                    {
                        Error(("GetModuleFileName() failed with %d\n", GetLastError()));
                        return FALSE;
                    }

                    if(!LoadLibrary(szDllName))
                    {
                        Error(("LoadLibrary() failed with %d\n", GetLastError()));
                        return FALSE;
                    }
                } // NT4

                if (!InitializeCriticalSectionAndSpinCount (&faxuiSemaphore, (DWORD)0x80000000))
                {            
                    return FALSE;
                }
                gs_bfaxuiSemaphoreInit = TRUE;
 
                if (!InitializeCriticalSectionAndSpinCount (&g_csInitializeDll, (DWORD)0x80000000))
                {            
                    return FALSE;
                }
                g_bInitDllCritSection = TRUE;
                
                if (!InitializeCriticalSectionAndSpinCount(&g_csRunningWizard, (DWORD)0x80000000))
                {            
                    Error(("InitializeCriticalSectionAndSpinCount(&g_csRunningWizard) failed with %d\n", GetLastError()));
                    return FALSE;
                }
				g_bInitRunningWizardCS = TRUE;

                g_hModule   = hModule;
                g_hResource = GetResInstance(hModule);
                if(!g_hResource)
                {
                    return FALSE;
                }

                HeapInitialize( NULL, PrMemAlloc, PrMemFree, PrMemReAlloc );
        
                DisableThreadLibraryCalls(hModule);

                break;
            }
        case DLL_PROCESS_DETACH:

            while (gDocEventUserMemList != NULL) 
            {
                PDOCEVENTUSERMEM    pDocEventUserMem;

                pDocEventUserMem = gDocEventUserMemList;
                gDocEventUserMemList = gDocEventUserMemList->pNext;
                FreePDEVUserMem(pDocEventUserMem);
            }

            if (gs_bfaxuiSemaphoreInit)
            {
                DeleteCriticalSection(&faxuiSemaphore);
                gs_bfaxuiSemaphoreInit = FALSE;
            }

            if (g_bInitDllCritSection)
            {
                DeleteCriticalSection(&g_csInitializeDll);
                g_bInitDllCritSection = FALSE;
            }

			if (g_bInitRunningWizardCS)
			{
                DeleteCriticalSection(&g_csRunningWizard);
				g_bInitRunningWizardCS = FALSE;
			}

            UnInitializeDll();

			HeapCleanup();
            FreeResInstance();
            break;
    }

    return TRUE;

} // DllMain

BOOL
InitializeDll()
{
    BOOL bRet = TRUE;
    INITCOMMONCONTROLSEX CommonControlsEx = {sizeof(INITCOMMONCONTROLSEX),
                                             ICC_WIN95_CLASSES|ICC_DATE_CLASSES};

    if(!g_bInitDllCritSection)
    {
        Assert(FALSE);
        return FALSE;
    }

    EnterCriticalSection(&g_csInitializeDll);

    if(g_bDllInitialied)
    {
        //
        // The DLL already initialized
        //        
        goto exit;
    }

    if (!InitCommonControlsEx(&CommonControlsEx))
    {
        Verbose(("InitCommonControlsEx failed"));
        bRet = FALSE;
        goto exit;
    }

    //
	// Load FXSAPI.DLL
    // Used by Delay Load mechanism
    //
	g_hFxsApiModule = LoadLibraryFromLocalFolder(FAX_API_MODULE_NAME, g_hModule);
	if(!g_hFxsApiModule)
	{
        bRet = FALSE;
        goto exit;
	}

    if (IsWinXPOS())
    {
        //
        // We use fusion only for WinXP/.NET operating systems
        // We also explictly link against shlwapi.dll for these operating systems.
        //
        if (!SHFusionInitializeFromModuleID(g_hModule, SXS_MANIFEST_RESOURCE_ID))
        {
            Verbose(("SHFusionInitializeFromModuleID failed"));
        }
        else
        {
            g_bSHFusionInitialized = TRUE;
        }

        gs_hShlwapi = LoadLibrary (TEXT("shlwapi.dll"));
        if (gs_hShlwapi)
        {
            g_pPathIsRelativeW = (PPATHISRELATIVEW)GetProcAddress (gs_hShlwapi, "PathIsRelativeW");
            g_pPathMakePrettyW = (PPATHMAKEPRETTYW)GetProcAddress (gs_hShlwapi, "PathMakePrettyW");
            g_pSHAutoComplete  = (PSHAUTOCOMPLETE) GetProcAddress (gs_hShlwapi, "SHAutoComplete");
            if (!g_pPathIsRelativeW || !g_pPathMakePrettyW || !g_pSHAutoComplete)
            {
                Verbose (("Failed to link with shlwapi.dll - %d", GetLastError()));
            }
        }
        else
        {
            Verbose (("Failed to load shlwapi.dll - %d", GetLastError()));
        }
	}

    g_bDllInitialied = TRUE;

exit:
    LeaveCriticalSection(&g_csInitializeDll);

    return bRet;

} // InitializeDll


VOID
UnInitializeDll()
{
    if(!g_bDllInitialied)
    {
        //
        // The DLL is not initialized
        //      
        return;
    }

    if(g_hFxsApiModule)
    {
        //
        // Explicitly Unloading a Delay-Loaded DLL
        //
        if(!__FUnloadDelayLoadedDLL2(g_szDelayLoadFxsApiName))
        {
            //
            // The DLL wasn't used by delay load 
            //
            FreeLibrary(g_hFxsApiModule);
        }
        g_hFxsApiModule = NULL;
    }

    if (IsWinXPOS())
    {
        //
        // We use fusion only for WinXP/.NET operating systems
        // We also explictly link against shlwapi.dll for these operating systems.
        //
        ReleaseActivationContext();
        if (g_bSHFusionInitialized)
        {
            SHFusionUninitialize();
            g_bSHFusionInitialized = FALSE;
        }
        if (gs_hShlwapi)
        {
            FreeLibrary (gs_hShlwapi);
            gs_hShlwapi = NULL;
            g_pPathIsRelativeW = NULL;
            g_pPathMakePrettyW = NULL;
            g_pSHAutoComplete = NULL;
        }
    }

    g_bDllInitialied = FALSE;

} // UnInitializeDll

LONG
CallCompstui(
    HWND            hwndOwner,
    PFNPROPSHEETUI  pfnPropSheetUI,
    LPARAM          lParam,
    PDWORD          pResult
    )

/*++

Routine Description:

    Calling common UI DLL entry point dynamically

Arguments:

    hwndOwner, pfnPropSheetUI, lParam, pResult - Parameters passed to common UI DLL

Return Value:

    Return value from common UI library

--*/

{
    HINSTANCE   hInstCompstui;
    FARPROC     pProc;
    LONG        Result = ERR_CPSUI_GETLASTERROR;

    //
    // Only need to call the ANSI version of LoadLibrary
    //

    static const CHAR szCompstui[] = "compstui.dll";
    static const CHAR szCommonPropSheetUI[] = "CommonPropertySheetUIW";

    if ((hInstCompstui = LoadLibraryA(szCompstui)) &&
        (pProc = GetProcAddress(hInstCompstui, szCommonPropSheetUI)))
    {
        Result = (LONG)(*pProc)(hwndOwner, pfnPropSheetUI, lParam, pResult);
    }

    if (hInstCompstui)
        FreeLibrary(hInstCompstui);

    return Result;
}



VOID
GetCombinedDevmode(
    PDRVDEVMODE     pdmOut,
    PDEVMODE        pdmIn,
    HANDLE          hPrinter,
    PPRINTER_INFO_2 pPrinterInfo2,
    BOOL            publicOnly
    )

/*++

Routine Description:

    Combine DEVMODE information:
     start with the driver default
     then merge with the system default //@ not done
     then merge with the user default //@ not done
     finally merge with the input devmode

    //@ The end result of this merge operation is a dev mode with default values for all the public
    //@ fields that are not specified or not valid. Input values for all the specified fields in the 
    //@ input dev mode that were specified and valid. And default (or per user in W2K) values for the private fields.
  

Arguments:

    pdmOut - Pointer to the output devmode buffer
    pdmIn - Pointer to an input devmode
    hPrinter - Handle to a printer object
    pPrinterInfo2 - Point to a PRINTER_INFO_2 structure or NULL
    publicOnly - Only merge the public portion of the devmode

Return Value:

    TRUE

--*/

{
    PPRINTER_INFO_2 pAlloced = NULL;
    PDEVMODE        pdmUser;

    //
    // Get a PRINTER_INFO_2 structure if one is not provided
    //

    if (! pPrinterInfo2)
        pPrinterInfo2 = pAlloced = MyGetPrinter(hPrinter, 2);

    //
    // Start with driver default devmode
    //

    if (! publicOnly) {

        //@ Generates the driver default dev mode by setting default values for the public fields
        //@ and loading per user dev mode for the private fields (W2K only for NT4 it sets default
        //@ values for the private fields too).

        DriverDefaultDevmode(pdmOut,
                             pPrinterInfo2 ? pPrinterInfo2->pPrinterName : NULL,
                             hPrinter);
    }

    //
    // Merge with the system default devmode and user default devmode
    //

    if (pPrinterInfo2) {

        #if 0

        //
        // Since we have per-user devmode and there is no way to
        // change the printer's default devmode, there is no need
        // to merge it here.
        //

        if (! MergeDevmode(pdmOut, pPrinterInfo2->pDevMode, publicOnly))
            Error(("Invalid system default devmode\n"));

        #endif

        if (pdmUser = GetPerUserDevmode(pPrinterInfo2->pPrinterName)) {

            if (! MergeDevmode(pdmOut, pdmUser, publicOnly))
                Error(("Invalid user devmode\n"));

            MemFree(pdmUser);
        }
    }

    MemFree(pAlloced);

    //
    // Merge with the input devmode
    //
    //@ The merge process wil copy the private data as is.
    //@ for public data it will only consider the fields which are of interest to the fax printer.
    //@ it will copy them to the destination if they are specified and valid.
    //@ The end result of this merge operation is a dev mode with default values for all the public
    //@ fields that are not specified or not valid. Input values for all the specified fields in the 
    //@ input dev mode that were specified and valid. And default (or per user in W2K) values for the private fields.
    
    if (! MergeDevmode(pdmOut, pdmIn, publicOnly))
        Error(("Invalid input devmode\n"));
}

PUIDATA
FillUiData(
    HANDLE      hPrinter,
    PDEVMODE    pdmInput
    )

/*++

Routine Description:

    Fill in the data structure used by the fax driver user interface

Arguments:

    hPrinter - Handle to the printer
    pdmInput - Pointer to input devmode, NULL if there is none

Return Value:

    Pointer to UIDATA structure, NULL if error.

--*/

{
    PRINTER_INFO_2 *pPrinterInfo2 = NULL;
    PUIDATA         pUiData = NULL;
    HANDLE          hheap = NULL;

    //
    // Create a heap to manage memory
    // Allocate memory to hold UIDATA structure
    // Get printer info from the spooler
    // Copy the driver name
    //

    if (! (hheap = HeapCreate(0, 4096, 0)) ||
        ! (pUiData = HeapAlloc(hheap, HEAP_ZERO_MEMORY, sizeof(UIDATA))) ||
        ! (pPrinterInfo2 = MyGetPrinter(hPrinter, 2)))
    {
        if (hheap)
            HeapDestroy(hheap);

        MemFree(pPrinterInfo2);
        return NULL;
    }

    pUiData->startSign = pUiData->endSign = pUiData;
    pUiData->hPrinter = hPrinter;
    pUiData->hheap = hheap;

    //
    // Combine various devmode information
    //

    GetCombinedDevmode(&pUiData->devmode, pdmInput, hPrinter, pPrinterInfo2, FALSE);

    //
    // Validate the form requested by the input devmode
    //

    if (! ValidDevmodeForm(hPrinter, &pUiData->devmode.dmPublic, NULL))
        Error(("Invalid form specification\n"));

    MemFree(pPrinterInfo2);
    return pUiData;
}


BOOL
DevQueryPrintEx(
    PDEVQUERYPRINT_INFO pDQPInfo
    )

/*++

Routine Description:

    Implementation of DDI entry point DevQueryPrintEx. Even though we don't
    really need this entry point, we must export it so that the spooler
    will load our driver UI.

Arguments:

    pDQPInfo - Points to a DEVQUERYPRINT_INFO structure

Return Value:

    TRUE if there is no conflicts, FALSE otherwise

--*/

{ 
    //
    // Do not execute any code before this initialization
    //
    if(!InitializeDll())
    {
        return FALSE;
    }

    return TRUE;
}
=== C:/Users/treeman/Desktop/windows nt source code\Source\Win2K3\NT\printscan\faxsrv\print\faxprint\faxui\faxui.h ===
/*++

Copyright (c) 1996  Microsoft Corporation

Module Name:

    faxui.h

Abstract:

    Fax driver user interface header file

Environment:

    Fax driver user interface

Revision History:

    01/09/96 -davidx-
        Created it.

    dd-mm-yy -author-
        description

--*/


#ifndef _FAXUI_H_
#define _FAXUI_H_

#ifdef __cplusplus
extern "C" {
#endif

#define ISOLATION_AWARE_ENABLED 1

#include <windows.h>
#include <shellapi.h>
#include <fxsapip.h>

#include "faxlib.h"
#include <faxres.h>

#include <winddiui.h>
#include <commctrl.h>
#include <windowsx.h>
#include <prsht.h>
#include <shlwapi.h>

#ifdef FAX_SCAN_ENABLED
#include <twain.h>
#endif

#include "registry.h"
#include "resource.h"

#include "faxsendw.h"
#include "faxroute.h"

#include <shlobj.h>
#include <shfusion.h>

//
// DLL Initialization
//
BOOL InitializeDll();
VOID UnInitializeDll();

//
// Data structure maintained by the fax driver user interface
//

typedef struct 
{
    PVOID           startSign;
    HANDLE          hPrinter;
    HANDLE          hheap;
    DRVDEVMODE      devmode;
    PFNCOMPROPSHEET pfnComPropSheet;
    HANDLE          hComPropSheet;
    HANDLE          hFaxOptsPage;
    BOOL            hasPermission;
    BOOL            configDefault;
    LPTSTR          pHelpFile;

    INT             cForms;
    LPTSTR          pFormNames;
    PWORD           pPapers;
    PVOID           endSign;

} UIDATA, *PUIDATA;

//
// Check if a UIDATA structure is valid
//

#define ValidUiData(p) ((p) && (p) == (p)->startSign && (p) == (p)->endSign)

//
// Combine DEVMODE information:
//  start with the driver default
//  then merge with the system default
//  then merge with the user default
//  finally merge with the input devmode
//

VOID
GetCombinedDevmode(
    PDRVDEVMODE     pdmOut,
    PDEVMODE        pdmIn,
    HANDLE          hPrinter,
    PPRINTER_INFO_2 pPrinterInfo2,
    BOOL            publicOnly
    );

//
// Fill in the data structure used by the fax driver user interface
//

PUIDATA
FillUiData(
    HANDLE      hPrinter,
    PDEVMODE    pdmInput
    );

//
// Calling common UI DLL entry point dynamically
//

LONG
CallCompstui(
    HWND            hwndOwner,
    PFNPROPSHEETUI  pfnPropSheetUI,
    LPARAM          lParam,
    PDWORD          pResult
    );

//
// Retrieves a list of supported paper sizes
//

DWORD
EnumPaperSizes(
    PVOID       pOutput,
    FORM_INFO_1 *pFormsDB,
    DWORD       cForms,
    INT         wCapability
    );

#define CCHBINNAME          24      // max length for bin names
#define CCHPAPERNAME        64      // max length for form names

//
// Display an error message dialog
//

INT
DisplayErrorMessage(
    HWND    hwndParent,
    UINT    uiType,
    INT     iErrorCode,
    ...
    );

#define MAX_TITLE_LEN       128
#define MAX_FORMAT_LEN      128
#define MAX_MESSAGE_LEN     512


// Data structures used by the user mode DLL to associate private
// information with a printer device context (PDEV to be exactly)
//

typedef struct {
    PVOID           pNext;                   // Points to the next item in the linked list
    HANDLE          hPrinter;                // Printer handle
    HANDLE          hMappingFile;            // Handle to the mapping file
    HANDLE          hPreviewFile;            // Handle to the preview file (document body)
    HANDLE          hMapping;                // Handle to the mapping object
    PMAP_TIFF_PAGE_HEADER pPreviewTiffPage;  // View of the mapping containing the preview page
    HDC             hdc;                     // Handle to the device context
    INT             pageCount;               // Number of pages in the document
    DWORD           jobId;                   // Current job ID
    INT             jobType;                 // Job type
    BOOL            directPrinting;          // Direct printing and skip the fax wizard
    BOOL            bShowPrintPreview;       // Indicates the user requested print preview
    BOOL            bPreviewAborted;         // Set to TRUE if an unrecoverable error occurred
                                             // concering print preview
    BOOL            bAttachment;             // TRUE for Direct printing of an attachment
    LPTSTR          pPrintFile;              // print to file file name
    LPTSTR          pPriority;               // Fax priority
    LPTSTR          pReceiptFlags;           // Flags of FAX_ENUM_DELIVERY_REPORT_TYPES
    LPTSTR          pReceiptAddress;         // Email address or computer name

    TCHAR           szPreviewFile[MAX_PATH]; // Preview file name
    TCHAR           coverPage[MAX_PATH];     // Cover page filename
    BOOL            bServerCoverPage;        // Is the cover page a server based cover page.
    LPTSTR          pSubject;                // Subject string
    LPTSTR          pNoteMessage;            // Note message string

    DRVDEVMODE      devmode;                 // The first field must be a current version devmode

    DWORD                   dwNumberOfRecipients;
    PFAX_PERSONAL_PROFILE   lpRecipientsInfo;

    PFAX_PERSONAL_PROFILE   lpSenderInfo;

    LPTSTR          lptstrServerName;
    LPTSTR          lptstrPrinterName;

    TCHAR           tstrTifName[MAX_PATH];  // Cover page filename

    PVOID           signature;              // Signature

} DOCEVENTUSERMEM, *PDOCEVENTUSERMEM;


#define ValidPDEVUserMem(p) \
        ((p) && (p) == (p)->signature)

//
// Mark the user mode memory structure
//

#define MarkPDEVUserMem(p)  \
        { (p)->signature = (p)->devmode.dmPrivate.pUserMem = (p); }

//
// Fax prefix and extension for temporary preview files
//

#define FAX_PREFIX      TEXT("fxs")

//
// Different types of print job
//

#define JOBTYPE_DIRECT  0
#define JOBTYPE_NORMAL  1


//
// Free up the user mode memory associated with each PDEV
//

VOID
FreePDEVUserMem(
    PDOCEVENTUSERMEM    pDocEventUserMem
    );

//
// Global variable declarations
//

extern CRITICAL_SECTION faxuiSemaphore;
extern HANDLE   g_hResource;
extern BOOL     oleInitialized;
extern PDOCEVENTUSERMEM gDocEventUserMemList;
extern HANDLE      g_hModule;      // DLL instance handle

#define EnterDrvSem() EnterCriticalSection(&faxuiSemaphore)
#define LeaveDrvSem() LeaveCriticalSection(&faxuiSemaphore)

INT_PTR
UserInfoDlgProc(
    HWND hDlg,
    UINT message,
    WPARAM wParam,
    LPARAM lParam
    );


//
// Global variables and macros
//

extern HANDLE   g_hFaxSvcHandle;
extern BOOL     g_bUserCanQuerySettings;
extern BOOL     g_bUserCanChangeSettings;

extern PFAX_PORT_INFO_EX  g_pFaxPortInfo; // port information 
extern DWORD              g_dwPortsNum;   // number of available fax devices

extern BOOL  g_bPortInfoChanged;         // TRUE if selected port info in g_pFaxPortInfo 
                                         // has been changed by device property sheet


#ifndef ARRAYSIZE
#define ARRAYSIZE(a)            (sizeof(a)/sizeof(a[0]))
#endif

#define RESOURCE_STRING_LEN     256
#define MAX_DEVICE_NAME         MAX_PATH
#define MAX_FIELD_LEN           512
#define MAX_ARCHIVE_DIR         MAX_PATH - 16

#define CSID_LIMIT              20
#define TSID_LIMIT              20

#define MIN_RING_COUNT          1
#define MAX_RING_COUNT          99
#define DEFAULT_RING_COUNT      2

#define MIN_TIMEOUT     10
#define MAX_TIMEOUT     30
#define DEFAULT_TIMEOUT 10

#define RM_FOLDER   0
#define RM_PRINT    1

#define RM_COUNT    2           // number of routing methods

#define INFO_SIZE   (MAX_PATH * sizeof(TCHAR) + sizeof(DWORD))

static const LPCTSTR RoutingGuids[RM_COUNT] = {
    REGVAL_RM_FOLDER_GUID,      // RM_FOLDER
    REGVAL_RM_PRINTING_GUID     // RM_PRINT
};

typedef struct _COLUMN_HEADER {

    UINT    uResourceId;    // header string resource id
    INT     ColumnWidth;    // column width
} COLUMN_HEADER, *PCOLUMN_HEADER;

#define Notify_Change(hDlg) { \
    HWND hwndSheet = GetParent( hDlg ); \
    PropSheet_Changed( hwndSheet, hDlg ); \
} \

#define Notify_UnChange(hDlg) { \
    HWND hwndSheet = GetParent( hDlg ); \
    PropSheet_UnChanged( hwndSheet, hDlg ); \
} \

//
// Functions in devinfo.c
//

BOOL
FillInDeviceInfo(
    HWND    hDlg
    );

BOOL
DoInitDeviceList(
    HWND hDlg 
    );

BOOL
ValidateControl(
    HWND            hDlg,
    INT             iItem
    );

BOOL
ChangePriority(
    HWND            hDlg,
    BOOL            bMoveUp
    );

BOOL
DoSaveDeviceList(
    HWND hDlg // window handle of the device info page
    );

void
DisplayDeviceProperty(
    HWND    hDlg
);

HMENU 
CreateContextMenu(
    VOID
    );

INT_PTR
DeviceInfoDlgProc(
    HWND hDlg,
    UINT message,
    WPARAM wParam,
    LPARAM lParam
    );

INT_PTR 
CALLBACK 
ConfigOptionDlgProc(
    HWND hDlg,  
    UINT uMsg,     
    WPARAM wParam, 
    LPARAM lParam  
);

//
// Functions in archfldr.c
//

INT_PTR
ArchiveInfoDlgProc(
    HWND hDlg,
    UINT message,
    WPARAM wParam,
    LPARAM lParam
    );

INT_PTR
RemoteInfoDlgProc(
    HWND hDlg,
    UINT message,
    WPARAM wParam,
    LPARAM lParam
    );

//
// Functions in statopts.c
//

BOOL
ValidateNotification(
    HWND            hDlg
    );

INT_PTR
StatusOptionDlgProc(
    HWND hDlg,
    UINT message,
    WPARAM wParam,
    LPARAM lParam
    );

//
// Functions in devprop.c
//

int InitReceiveInfo(
    HWND    hDlg
    );

int SaveReceiveInfo(
    HWND    hDlg
    );

BOOL
ValidateSend(
    HWND            hDlg
    );

BOOL
ValidateReceive(
    HWND            hDlg
    );

INT_PTR CALLBACK 
DevSendDlgProc(
    IN HWND hDlg,
    IN UINT message,
    IN WPARAM wParam,
    IN LPARAM lParam 
    );

INT_PTR CALLBACK
DevRecvDlgProc(
    IN HWND hDlg,
    IN UINT message,
    IN WPARAM wParam,
    IN LPARAM lParam 
    );

INT_PTR CALLBACK
DevCleanupDlgProc(
    IN HWND hDlg,
    IN UINT message,
    IN WPARAM wParam,
    IN LPARAM lParam 
    );

//
// Functions in util.c
//

VOID
InitializeStringTable(
    VOID
    );

VOID
DeInitializeStringTable(
    VOID
    );

LPTSTR
GetString(
    DWORD ResourceId
    );

BOOL IsLocalPrinter(
    LPTSTR pPrinterName
    );

VOID
DisConnect(
    );

BOOL
Connect(
    HWND    hDlg,
    BOOL    bDisplayErrorMessage
    );

BOOL
DirectoryExists(
    LPTSTR  pDirectoryName
    );

BOOL 
FaxDeviceEnableRoutingMethod(
    HANDLE hFaxHandle,      
    DWORD dwDeviceId,       
    LPCTSTR pRoutingGuid,    
    LONG Enabled            
    );

BOOL
BrowseForDirectory(
    HWND   hDlg,
    INT    hResource,
    DWORD  dwMaxPath,
    LPTSTR title
    );

LPTSTR
ValidatePath(
    LPTSTR szPath
    ); 

PFAX_PORT_INFO_EX
FindPortInfo(
    DWORD dwDeviceId
);

void
PageEnable(
    HWND hDlg,
    BOOL bEnable
);

DWORD
CountUsedFaxDevices();

BOOL
IsDeviceInUse(
    DWORD dwDeviceId
);
 
VOID
NotifyDeviceUsageChanged ();

//
// Functions in security.cpp
//

HPROPSHEETPAGE 
CreateFaxSecurityPage();

void
ReleaseFaxSecurity();

void 
ReleaseActivationContext();

HANDLE 
GetFaxActivationContext();

//
// Explicitly imported functions from shlwapi.dll
//
typedef BOOL
(WINAPI *PPATHISRELATIVEW)(LPCWSTR);

typedef BOOL
(WINAPI *PPATHMAKEPRETTYW)(LPCWSTR);

typedef HRESULT
(WINAPI *PSHAUTOCOMPLETE)(HWND, DWORD);

extern PPATHISRELATIVEW g_pPathIsRelativeW;
extern PPATHMAKEPRETTYW g_pPathMakePrettyW;
extern PSHAUTOCOMPLETE  g_pSHAutoComplete;


#ifdef __cplusplus
}
#endif

#endif // !_FAXUI_H_
=== C:/Users/treeman/Desktop/windows nt source code\Source\Win2K3\NT\printscan\faxsrv\print\faxprint\faxui\help.h ===
/*++

Copyright (c) 1996  Microsoft Corporation

Module Name:

    help.h

Abstract:

    Help related declarations

Environment:

    Windows XP fax driver

Revision History:

    07/30/96 -davidx-
        Created it.

    dd-mm-yy -author-
        description

--*/

#ifndef _HELP_H_
#define _HELP_H_

//
// Name of the help file for the fax driver
//

#define HELP_FILENAME               TEXT("fax.hlp")

//
// Help indices
//

#define IDH_BILLING_CODE                  2002
#define IDH_IMAGE_QUALITY                 2025
#define IDH_LANDSCAPE                     2026
#define IDH_PAPER_SIZE                    2037
#define IDH_PORTRAIT                      2038
#define IDH_SEND_ASAP                     2046
#define IDH_SEND_AT_CHEAP                 2047
#define IDH_SEND_AT_TIME                  2048
#define IDH_EMAIL                         2049
#define IDH_FAX_SEND_GRP                  2075
#define IDH_DEFAULT_PRINT_SETUP_GRP       2070
#define IDH_ORIENTATION                   2062
#define IDH_SEND_AT_TIME                  2048

#endif  // !_HELP_H_
=== C:/Users/treeman/Desktop/windows nt source code\Source\Win2K3\NT\printscan\faxsrv\print\faxprint\faxui\prnevent.c ===
/*++

Copyright (c) 1996  Microsoft Corporation

Module Name:

    prnevent.c

Abstract:

    Implementation of DrvPrinterEvent

Environment:

    Fax driver user interface

Revision History:

    05/10/96 -davidx-
        Created it.

    mm/dd/yy -author-
        description

--*/


#include "faxui.h"
#include <crtdbg.h>

DWORD
GetLocaleDefaultPaperSize(
    VOID
    )

/*++

Routine Description:

    Retrieves the current locale defualt paper size.

Arguments:

    NONE

Return Value:

    One of the following values:  1 = letter, 5 = legal, 9 = a4

--*/

{

    WCHAR   szMeasure[2] = TEXT("9"); // 2 is maximum size for the LOCALE_IPAPERSIZE
                                      // value as defined is MSDN.

    if (!GetLocaleInfo(LOCALE_SYSTEM_DEFAULT, LOCALE_IPAPERSIZE, szMeasure,2))
    {
        Error(("GetLocaleDefaultPaperSize: GetLocaleInfo() failed (ec: %ld)",GetLastError()));
    }


    if (!wcscmp(szMeasure,TEXT("9")))
    {
        // A4
        return DMPAPER_A4;
    }

    if (!wcscmp(szMeasure,TEXT("5")))
    {
        // legal
        return DMPAPER_LEGAL;
    }

    //
    // Defualt value is Letter. We do not support A3.
    //
    return DMPAPER_LETTER;
}



BOOL
DrvPrinterEvent(
    LPWSTR  pPrinterName,
    int     DriverEvent,
    DWORD   Flags,
    LPARAM  lParam
)

/*++

Routine Description:

    Implementation of DrvPrinterEvent entrypoint

Arguments:

    pPrinterName - Specifies the name of the printer involved
    DriverEvent - Specifies what happened
    Flags - Specifies misc. flag bits
    lParam - Event specific parameters

Return Value:

    TRUE if successful, FALSE otherwise

--*/
{
#define FUNCTION_NAME "DrvPrinterEvent()"

    HKEY                    hRegKey = NULL;
    HANDLE                  hPrinter = NULL;
    PDRIVER_INFO_2          pDriverInfo2 = NULL;
    PPRINTER_INFO_2         pPrinterInfo2 = NULL;
    HINSTANCE               hInstFaxOcm = NULL;
    LPTSTR                  pClientSetupDir = NULL;
    INT                     status = 0;

    TCHAR                   DestPath[MAX_PATH] = {0};

    BOOL                    bFaxAlreadyInstalled = FALSE;
    BOOL                    bRes = FALSE;
    TCHAR                   FaxOcmPath[MAX_PATH] = {0};


    Verbose(("DrvPrinterEvent: %d\n", DriverEvent));

    DestPath[0] = 0;

    //
    // Do not execute any code before this initialization
    //
    if(!InitializeDll())
    {
        return FALSE;
    }

    //
    // Ignore any event other than Initialize and AddConnection
    //

    if (DriverEvent == PRINTER_EVENT_INITIALIZE)
    {
        static PRINTER_DEFAULTS printerDefault = {NULL, NULL, PRINTER_ALL_ACCESS};

        if (OpenPrinter(pPrinterName, &hPrinter, &printerDefault))
        {
            SetPrinterDataDWord(hPrinter, PRNDATA_PAPER_SIZE, GetLocaleDefaultPaperSize());
            ClosePrinter(hPrinter);
        }
        else
        {
            Error(("OpenPrinter failed: %d\n", GetLastError()));
        }

    }
    else if (DriverEvent == PRINTER_EVENT_ADD_CONNECTION)
    {
        
        if (Flags & PRINTER_EVENT_FLAG_NO_UI)
        {
            Verbose(("PRINTER_EVENT_FLAG_NO_UI is set, disable Point and Print\n"));
            return TRUE;
        }

        //
        //  client 'point and print' setup
        //
        if (FaxPointAndPrintSetup(pPrinterName,TRUE, g_hModule))
        {
            Verbose(("FaxPointAndPrintSetup succeeded\n"));
        }
        else
        {
            Error(("FaxPointAndPrintSetup failed: %d\n", GetLastError()));
        }
        return TRUE;

    }
    else if (DriverEvent == PRINTER_EVENT_ATTRIBUTES_CHANGED)
    {
        //
        // Printer attributes changed.
        // Check if the printer is now shared.
        //
        PPRINTER_EVENT_ATTRIBUTES_INFO pAttributesInfo = (PPRINTER_EVENT_ATTRIBUTES_INFO)lParam;
        Assert (pAttributesInfo);

        if (pAttributesInfo->cbSize >= (3 * sizeof(DWORD)))
        {
            //
            // We are dealing with the correct structure - see DDK
            //
            if (!(pAttributesInfo->dwOldAttributes & PRINTER_ATTRIBUTE_SHARED) &&  // The printer was not shared
                (pAttributesInfo->dwNewAttributes & PRINTER_ATTRIBUTE_SHARED))     // The printer is now shared
            {
                //
                // We shouls start the fax service
                //
                Assert (IsFaxShared()); // The fax printer can be shared

                if (!EnsureFaxServiceIsStarted (NULL))
                {
                    Error(("EnsureFaxServiceIsStarted failed: %d\n", GetLastError()));
                }
            }
        }
    }
    return TRUE;
}
=== C:/Users/treeman/Desktop/windows nt source code\Source\Win2K3\NT\printscan\faxsrv\print\faxprint\inc\covpg.h ===
/*++

Copyright (c) 1996  Microsoft Corporation

Module Name:

    covpg.h

Abstract:

    Functions for manipulating cover page structures

Environment:

    User mode

Revision History:

    01/04/2000 -LiranL-
              Created it.

    mm/dd/yyyy -author-
              description

--*/


#include "prtcovpg.h"


VOID
FreeCoverPageFields(
    PCOVERPAGEFIELDS    pCPFields
    );

PCOVERPAGEFIELDS
CollectCoverPageFields(
    PFAX_PERSONAL_PROFILE    lpSenderInfo,
    DWORD                    pageCount
    );
=== C:/Users/treeman/Desktop/windows nt source code\Source\Win2K3\NT\printscan\faxsrv\print\faxprint\faxui\statopts.c ===
/*++

Copyright (c) 1996  Microsoft Corporation

Module Name:

    statopts.c

Abstract:

    Property sheet handler for "Status Option" page

Environment:

    Fax driver user interface

Revision History:

    04/09/00 -taoyuan-
        Created it.
        Copy part of code from shell\ext\systray\dll\fax.cpp

    mm/dd/yy -author-
        description

--*/

#include <stdio.h>
#include "faxui.h"
#include "resource.h" 


HWND g_hwndTracking = NULL;

INT_PTR 
CALLBACK 
SoundDlgProc(
  HWND hwndDlg,  // handle to dialog box
  UINT uMsg,     // message
  WPARAM wParam, // first message parameter
  LPARAM lParam  // second message parameter
);


BOOL
GetSelectedDeviceId(
    HWND   hDlg,
    DWORD* pdwDeviceId
)
/*++

Routine Description:

    Returns selected divice ID from IDC_COMBO_MODEM combo box

Arguments:

    hDlg        - [in]  Handle to the Status Options property sheet page
    pdwDeviceId - [out] selected device ID

Return Value:

    TRUE for success, FALSE otherwise

--*/
{
    DWORD dwCount = 0;
    DWORD dwIndex = 0;
    HWND  hComboModem = NULL;

    hComboModem = GetDlgItem(hDlg, IDC_COMBO_MODEM);
    if(!hComboModem)
    {
        Assert(FALSE);
        Error(( "GetDlgItem(hDlg, IDC_COMBO_MODEM) failed, ec = %d.\n", GetLastError()));
        return FALSE;
    }

    dwCount = (DWORD)SendMessage(hComboModem, CB_GETCOUNT,0,0);
    if(CB_ERR == dwCount || 0 == dwCount)
    {
        Error(( "SendMessage(hComboModem, CB_GETCOUNT,0,0) failed\n"));
        return FALSE;
    }

    dwIndex = (DWORD)SendMessage(hComboModem, CB_GETCURSEL,0,0);
    if(CB_ERR == dwIndex)
    {
        Error(( "SendMessage(hComboModem, CB_GETCURSEL,0,0) failed\n"));
        return FALSE;
    }

    *pdwDeviceId = (DWORD)SendMessage(hComboModem, CB_GETITEMDATA, dwIndex, 0);
    if(CB_ERR == *pdwDeviceId)
    {
        Error(( "SendMessage(hComboModem, CB_GETITEMDATA, dwIndex, 0) failed\n"));
        return FALSE;
    }

    return TRUE;
}

void
OnDevSelectChanged(
    HWND hDlg
)
/*++

Routine Description:

    Change IDC_CHECK_MANUAL_ANSWER check box state
    according to device selection

Arguments:

    hDlg - Handle to the Status Options property sheet page

Return Value:

    NONE

--*/
{
    BOOL  bFaxEnable = FALSE;
    DWORD dwSelectedDeviceId = 0;

    PFAX_PORT_INFO_EX pPortInfo = NULL;
    TCHAR szDeviceNote[MAX_PATH] = {0};

    GetSelectedDeviceId(hDlg, &dwSelectedDeviceId);

    if(dwSelectedDeviceId)
    {
        pPortInfo = FindPortInfo(dwSelectedDeviceId);
        if(!pPortInfo)
        {
            Error(("FindPortInfo() failed\n"));
            Assert(FALSE);
            return;                
        }

        bFaxEnable = pPortInfo->bSend || (FAX_DEVICE_RECEIVE_MODE_OFF != pPortInfo->ReceiveMode);
    }

    if(!bFaxEnable)
    {
        if(!LoadString(g_hResource, 
                       0 == dwSelectedDeviceId ? IDS_NO_DEVICES : IDS_NOT_FAX_DEVICE, 
                       szDeviceNote, 
                       MAX_PATH))
        {
            Error(( "LoadString() failed with %d.\n", GetLastError()));
            Assert(FALSE);
        }
    }

    SetDlgItemText(hDlg, IDC_STATIC_DEVICE_NOTE, szDeviceNote);
    ShowWindow(GetDlgItem(hDlg, IDC_STATIC_NOTE_ICON), bFaxEnable ? SW_HIDE : SW_SHOW);

    EnableWindow(GetDlgItem(hDlg, IDC_CHECK_MONITOR_ON_SEND),     bFaxEnable);
    EnableWindow(GetDlgItem(hDlg, IDC_CHECK_MONITOR_ON_RECEIVE),  bFaxEnable);
    EnableWindow(GetDlgItem(hDlg, IDC_CHECK_NOTIFY_PROGRESS),     bFaxEnable);
    EnableWindow(GetDlgItem(hDlg, IDC_CHECK_NOTIFY_IN_COMPLETE),  bFaxEnable);
    EnableWindow(GetDlgItem(hDlg, IDC_CHECK_NOTIFY_OUT_COMPLETE), bFaxEnable);
    EnableWindow(GetDlgItem(hDlg, IDC_STATIC_AUTO_OPEN),          bFaxEnable);    
    EnableWindow(GetDlgItem(hDlg, IDC_BUTTON_SOUND),              bFaxEnable);
}


VOID
DoInitStatusOptions(
    HWND    hDlg
    )

/*++

Routine Description:

    Initializes the Status Options property sheet page with information from the registry

Arguments:

    hDlg - Handle to the Status Options property sheet page

Return Value:

    NONE

--*/
{
    HKEY    hRegKey;

    DWORD dw;
    DWORD dwItem;    
    DWORD dwSelectedDeviceId=0;
    DWORD dwSelectedItem=0;
    HWND  hComboModem = NULL;

    BOOL    bDesktopSKU = IsDesktopSKU();

    DWORD   bNotifyProgress      = bDesktopSKU;
    DWORD   bNotifyInCompletion  = bDesktopSKU;
    DWORD   bNotifyOutCompletion = bDesktopSKU;
    DWORD   bMonitorOnSend       = bDesktopSKU;
    DWORD   bMonitorOnReceive    = bDesktopSKU;

    //
    // Open the user info registry key for reading
    //    
    if ((hRegKey = OpenRegistryKey(HKEY_CURRENT_USER, REGKEY_FAX_USERINFO, FALSE,KEY_READ)))
    {
        GetRegistryDwordEx(hRegKey, REGVAL_MONITOR_ON_SEND,     &bMonitorOnSend);
        GetRegistryDwordEx(hRegKey, REGVAL_MONITOR_ON_RECEIVE,  &bMonitorOnReceive);
        GetRegistryDwordEx(hRegKey, REGVAL_NOTIFY_PROGRESS,     &bNotifyProgress);
        GetRegistryDwordEx(hRegKey, REGVAL_NOTIFY_IN_COMPLETE,  &bNotifyInCompletion);
        GetRegistryDwordEx(hRegKey, REGVAL_NOTIFY_OUT_COMPLETE, &bNotifyOutCompletion);
        GetRegistryDwordEx(hRegKey, REGVAL_DEVICE_TO_MONITOR,   &dwSelectedDeviceId);
        
        RegCloseKey(hRegKey);
    }

    CheckDlgButton( hDlg, IDC_CHECK_MONITOR_ON_SEND,     bMonitorOnSend       ? BST_CHECKED : BST_UNCHECKED);
    CheckDlgButton( hDlg, IDC_CHECK_MONITOR_ON_RECEIVE,  bMonitorOnReceive    ? BST_CHECKED : BST_UNCHECKED);
    CheckDlgButton( hDlg, IDC_CHECK_NOTIFY_PROGRESS,     bNotifyProgress      ? BST_CHECKED : BST_UNCHECKED);
    CheckDlgButton( hDlg, IDC_CHECK_NOTIFY_IN_COMPLETE,  bNotifyInCompletion  ? BST_CHECKED : BST_UNCHECKED);
    CheckDlgButton( hDlg, IDC_CHECK_NOTIFY_OUT_COMPLETE, bNotifyOutCompletion ? BST_CHECKED : BST_UNCHECKED);            


    hComboModem = GetDlgItem(hDlg, IDC_COMBO_MODEM);
    if(!hComboModem)
    {
        Assert(FALSE);
        return;
    }

    for(dw=0; dw < g_dwPortsNum; ++dw)
    {
        dwItem = (DWORD)SendMessage(hComboModem, CB_ADDSTRING, 0, (LPARAM)g_pFaxPortInfo[dw].lpctstrDeviceName);
        if(CB_ERR != dwItem && CB_ERRSPACE != dwItem)
        {
            SendMessage(hComboModem, CB_SETITEMDATA, dwItem, g_pFaxPortInfo[dw].dwDeviceID);
            if(g_pFaxPortInfo[dw].dwDeviceID == dwSelectedDeviceId)
            {
                dwSelectedItem = dwItem;                
            }
        }
        else
        {
            Error(( "SendMessage(hComboModem, CB_ADDSTRING, 0, pPortsInfo[dw].lpctstrDeviceName) failed\n"));
        }

        SendMessage(hComboModem, CB_SETCURSEL, dwSelectedItem, 0);
        OnDevSelectChanged(hDlg);
    }

    return;
}

BOOL
DoSaveStatusOptions(
    HWND    hDlg
    )   

/*++

Routine Description:

    Save the information on the Status Options property sheet page to registry

Arguments:

    hDlg - Handle to the Status Options property sheet page

Return Value:

    TRUE for success, FALSE otherwise

--*/

#define SaveStatusOptionsCheckBox(id, pValueName) \
            SetRegistryDword(hRegKey, pValueName, IsDlgButtonChecked(hDlg, id));

{
    HKEY    hRegKey;
    HWND    hWndFaxStat = NULL;
    DWORD   dwSelectedDeviceId = 0;
    DWORD   dwRes = 0;

    //
    // Open the user registry key for writing and create it if necessary
    //
    if (! (hRegKey = OpenRegistryKey(HKEY_CURRENT_USER, REGKEY_FAX_USERINFO,TRUE, KEY_ALL_ACCESS)))
    {
        dwRes = GetLastError();
        Error(("Can't open registry to save data. Error = %d\n", dwRes));
        DisplayErrorMessage(hDlg, 0, dwRes);
        return FALSE;
    }

    SaveStatusOptionsCheckBox(IDC_CHECK_MONITOR_ON_SEND,     REGVAL_MONITOR_ON_SEND);
    SaveStatusOptionsCheckBox(IDC_CHECK_MONITOR_ON_RECEIVE,  REGVAL_MONITOR_ON_RECEIVE);
    SaveStatusOptionsCheckBox(IDC_CHECK_NOTIFY_PROGRESS,     REGVAL_NOTIFY_PROGRESS);
    SaveStatusOptionsCheckBox(IDC_CHECK_NOTIFY_IN_COMPLETE,  REGVAL_NOTIFY_IN_COMPLETE);
    SaveStatusOptionsCheckBox(IDC_CHECK_NOTIFY_OUT_COMPLETE, REGVAL_NOTIFY_OUT_COMPLETE);

    if(GetSelectedDeviceId(hDlg, &dwSelectedDeviceId))
    {
        SetRegistryDword(hRegKey, REGVAL_DEVICE_TO_MONITOR, dwSelectedDeviceId);
    }

    //
    // Close the registry key before returning to the caller
    //
    RegCloseKey(hRegKey);

    //
    // See if faxstat is running
    //
    hWndFaxStat = FindWindow(FAXSTAT_WINCLASS, NULL);
    if (hWndFaxStat) 
    {
        PostMessage(hWndFaxStat, WM_FAXSTAT_CONTROLPANEL, 0, 0);
    }

    return TRUE;
}


INT_PTR 
CALLBACK 
StatusOptionDlgProc(
    HWND hDlg,  
    UINT uMsg,     
    WPARAM wParam, 
    LPARAM lParam  
)

/*++

Routine Description:

    Procedure for handling the "status option" tab

Arguments:

    hDlg - Identifies the property sheet page
    uMsg - Specifies the message
    wParam - Specifies additional message-specific information
    lParam - Specifies additional message-specific information

Return Value:

    Depends on the value of message parameter

--*/

{
    switch (uMsg)
    {
    case WM_INITDIALOG :
        { 
            DoInitStatusOptions(hDlg);
            g_hwndTracking = hDlg;
            return TRUE;
        }

    case WM_DESTROY:
        g_hwndTracking = NULL;
        break;

    case WM_COMMAND:

        switch(LOWORD(wParam)) 
        {                        
            case IDC_CHECK_MONITOR_ON_SEND:
            case IDC_CHECK_MONITOR_ON_RECEIVE:
            case IDC_CHECK_NOTIFY_PROGRESS:
            case IDC_CHECK_NOTIFY_IN_COMPLETE:
            case IDC_CHECK_NOTIFY_OUT_COMPLETE:

                if( HIWORD(wParam) == BN_CLICKED ) // notification code
                {
                    Notify_Change(hDlg);
                }

                break;

            case IDC_COMBO_MODEM:

                if(HIWORD(wParam) == CBN_SELCHANGE)
                {
                    OnDevSelectChanged(hDlg);
                    Notify_Change(hDlg);
                }
                break;

            case IDC_BUTTON_SOUND:
                //
                // open sound dialog
                //
                DialogBoxParam(g_hResource,
                               MAKEINTRESOURCE(IDD_SOUNDS),
                               hDlg,
                               SoundDlgProc,
                               (LPARAM)NULL);
                break; 

            default:
                break;
        }

        break;

    case WM_NOTIFY:
    {
        LPNMHDR lpnm = (LPNMHDR) lParam;

        switch (lpnm->code)
        {
            case PSN_SETACTIVE:
                
                OnDevSelectChanged(hDlg);

                break;

            case PSN_APPLY:

                if(!DoSaveStatusOptions(hDlg))
                {
                    SetWindowLongPtr(hDlg, DWLP_MSGRESULT, PSNRET_INVALID);
                }
                else
                {
                    Notify_UnChange(hDlg);
                }

                return TRUE;

            default :
                break;
        } // switch
        break;
    }

    case WM_HELP:
        WinHelpContextPopup(((LPHELPINFO)lParam)->dwContextId, hDlg);
        return TRUE;

    default:
        break;
    }

    return FALSE;
}


INT_PTR 
CALLBACK 
SoundDlgProc(
  HWND hDlg,    
  UINT uMsg,    
  WPARAM wParam,
  LPARAM lParam 
)
/*++

Routine Description:

    Procedure for handling the sound dialog

Arguments:

    hDlg - Identifies the property sheet page
    uMsg - Specifies the message
    wParam - Specifies additional message-specific information
    lParam - Specifies additional message-specific information

Return Value:

    Depends on the value of message parameter

--*/
{
    switch (uMsg)
    {
    case WM_INITDIALOG :
        { 
            HKEY  hRegKey;
            DWORD bSoundOnRing    = IsDesktopSKU();
            DWORD bSoundOnReceive = bSoundOnRing;
            DWORD bSoundOnSent    = bSoundOnRing;
            DWORD bSoundOnError   = bSoundOnRing;

            if ((hRegKey = OpenRegistryKey(HKEY_CURRENT_USER, REGKEY_FAX_USERINFO, FALSE,KEY_READ)))
            {
                GetRegistryDwordEx(hRegKey, REGVAL_SOUND_ON_RING,      &bSoundOnRing);
                GetRegistryDwordEx(hRegKey, REGVAL_SOUND_ON_RECEIVE,   &bSoundOnReceive);
                GetRegistryDwordEx(hRegKey, REGVAL_SOUND_ON_SENT,      &bSoundOnSent);
                GetRegistryDwordEx(hRegKey, REGVAL_SOUND_ON_ERROR,     &bSoundOnError);

                RegCloseKey(hRegKey);
            }

            CheckDlgButton( hDlg, IDC_CHECK_RING,    bSoundOnRing ?    BST_CHECKED : BST_UNCHECKED);
            CheckDlgButton( hDlg, IDC_CHECK_RECEIVE, bSoundOnReceive ? BST_CHECKED : BST_UNCHECKED);
            CheckDlgButton( hDlg, IDC_CHECK_SENT,    bSoundOnSent ?    BST_CHECKED : BST_UNCHECKED);
            CheckDlgButton( hDlg, IDC_CHECK_ERROR,   bSoundOnError ?   BST_CHECKED : BST_UNCHECKED);            

            return TRUE;
        }

    case WM_COMMAND:

        switch(LOWORD(wParam)) 
        {   
            case IDOK:
                {
                    HKEY    hRegKey;
                    DWORD   dwRes = 0;

                    //
                    // Open the user registry key for writing and create it if necessary
                    //
                    if ((hRegKey = OpenRegistryKey(HKEY_CURRENT_USER, REGKEY_FAX_USERINFO,TRUE, KEY_ALL_ACCESS)))
                    {
                        SaveStatusOptionsCheckBox(IDC_CHECK_RING,    REGVAL_SOUND_ON_RING);
                        SaveStatusOptionsCheckBox(IDC_CHECK_RECEIVE, REGVAL_SOUND_ON_RECEIVE);
                        SaveStatusOptionsCheckBox(IDC_CHECK_SENT,    REGVAL_SOUND_ON_SENT);
                        SaveStatusOptionsCheckBox(IDC_CHECK_ERROR,   REGVAL_SOUND_ON_ERROR);

                        RegCloseKey(hRegKey);

                        EndDialog(hDlg, IDOK);
                    }
                    else
                    {
                        dwRes = GetLastError();
                        Error(("Can't open registry to save data. Error = %d\n", dwRes));
                        DisplayErrorMessage(hDlg, 0, dwRes);
                    }
                }
                break;
            case IDCANCEL:
                EndDialog(hDlg, IDCANCEL);
                break;
        }

        break;

    case WM_HELP:
        WinHelpContextPopup(((LPHELPINFO)lParam)->dwContextId, hDlg);
        return TRUE;
    }

    return FALSE;
}

DWORD
FindDeviceToMonitor ()
/*++

Routine name : FindDeviceToMonitor

Routine description:

	Attempts to find a device which is either send or receive enabled

Author:

	Eran Yariv (EranY),	Apr, 2001

Arguments:
    
Return Value:

    Device id, zero if none found.

--*/
{
    DWORD             dwIndex;

    for (dwIndex = 0; dwIndex < g_dwPortsNum; dwIndex++)
    {
        if (g_pFaxPortInfo[dwIndex].bSend                                           ||  // Device is send enabled or
            (FAX_DEVICE_RECEIVE_MODE_OFF != g_pFaxPortInfo[dwIndex].ReceiveMode))       // device is receive enabled    
        {
            //
            // We have a match
            //
            return g_pFaxPortInfo[dwIndex].dwDeviceID;
        }
    }
    return 0;
}   // FindDeviceToMonitor

VOID
NotifyDeviceUsageChanged ()
/*++

Routine name : NotifyDeviceUsageChanged

Routine description:

	A notification function. 
    Called whenever the usage of a device has changed.

Author:

	Eran Yariv (EranY),	Apr, 2001

Arguments:

Return Value:

    None.

--*/
{
    DWORD dwMonitoredDeviceId;
    
    if (g_hwndTracking)
    {
        //
        // Get data from the combo-box
        //
        if(!GetSelectedDeviceId(g_hwndTracking, &dwMonitoredDeviceId))
        {
            //
            // Can't read monitored device
            //
            return;
        }
    }
    else
    {
        HKEY  hRegKey;
        //
        // Get data from the registry
        //
        if ((hRegKey = OpenRegistryKey(HKEY_CURRENT_USER, REGKEY_FAX_USERINFO, FALSE, KEY_READ)))
        {
            if (ERROR_SUCCESS != GetRegistryDwordEx(hRegKey, REGVAL_DEVICE_TO_MONITOR, &dwMonitoredDeviceId))
            {
                //
                // Can't read monitored device
                //
                RegCloseKey (hRegKey);
                return;
            }
            RegCloseKey (hRegKey);
        }
        else
        {
            //
            // Can't read monitored device
            //
            return;
        }
    }
    if (IsDeviceInUse(dwMonitoredDeviceId))
    {
        //
        // Monitored device is in use - no action required
        //
        return;
    }
    //
    // Now we know that the monitored device is no longer in use.
    // Try to find another device to monitor.
    // 
    dwMonitoredDeviceId = FindDeviceToMonitor ();
    if (!dwMonitoredDeviceId)
    {
        //
        // Can't find any device to monitor - do nothing.
        //
        return;
    }
    //
    // Set the new device
    //
    if (g_hwndTracking)
    {
        //
        // Set data to the combo-box
        //
        DWORD dwCount = 0;
        DWORD dwIndex = 0;
        HWND  hComboModem = NULL;

        hComboModem = GetDlgItem(g_hwndTracking, IDC_COMBO_MODEM);
        if(!hComboModem)
        {
            Assert(FALSE);
            return;
        }
        dwCount = (DWORD)SendMessage(hComboModem, CB_GETCOUNT,0,0);
        if(CB_ERR == dwCount || 0 == dwCount)
        {
            Error(("SendMessage(hComboModem, CB_GETCOUNT,0,0) failed\n"));
            return;
        }
        for (dwIndex = 0; dwIndex < dwCount; dwIndex++)
        {
            DWORD dwDeviceId;
            //
            // Look for the device
            //
            dwDeviceId = (DWORD)SendMessage(hComboModem, CB_GETITEMDATA, dwIndex, 0);
            if (dwDeviceId != dwMonitoredDeviceId)
            {
                continue;
            }
            //
            // Found the new device in the combo-box.
            // Select it and mark the page as modified.
            //
            SendMessage(hComboModem, CB_SETCURSEL, dwIndex, 0);
            OnDevSelectChanged(g_hwndTracking);
            Notify_Change(g_hwndTracking);
            break;
        }
    }
    else
    {
        HKEY  hRegKey;
        //
        // Set data to the registry
        //
        if ((hRegKey = OpenRegistryKey(HKEY_CURRENT_USER, REGKEY_FAX_USERINFO, FALSE, KEY_WRITE)))
        {
            if (!SetRegistryDword(hRegKey, REGVAL_DEVICE_TO_MONITOR, dwMonitoredDeviceId))
            {
                //
                // Can't write monitored device
                //
            }
            RegCloseKey (hRegKey);
        }
    }
}   // NotifyDeviceUsageChanged
=== C:/Users/treeman/Desktop/windows nt source code\Source\Win2K3\NT\printscan\faxsrv\print\faxprint\faxui\resource.h ===
//////////////////////////////////////////////////////
//                                                  //
// Fax UI resource ID file                          //
// It compiles as part of FxsRes.dll                //
// All the IDs should be in range                   //
//                                                  //
// [5000 - 5999]                                    //
//                                                  //
//////////////////////////////////////////////////////

#ifndef _FAXUI_RESOURCE_H_ 
#define _FAXUI_RESOURCE_H_

#include "..\..\..\admin\faxres\resource.h"

// 
// String resource IDs 
// 
#define IDS_FULL_REMOTE_INFO        5001 
#define IDS_PARTIAL_REMOTE_INFO     5002 
#define IDS_BROWSE_FOLDER           5003 
#define IDS_SLOT_ONLYONE            5004 
#define IDS_DEVICE_NAME             5005 
#define IDS_SEND                    5006 
#define IDS_RECEIVE                 5007 
#define IDS_NO_DEVICE_SELECTED      5008 
#define IDS_DEVICE_ENABLED          5009 
#define IDS_DEVICE_DISABLED         5010 
#define IDS_DEVICE_AUTO_ANSWER      5011 
#define IDS_DEVICE_MANUAL_ANSWER    5012 
#define IDS_MSG_TITLE               5013 
#define IDS_BROADCAST_RECIPIENT     5014 
#define IDS_REENTRANCY_TITLE		5015
#define IDS_REENTRANCY_TEXT			5016
#define IDS_QUALITY_NORMAL          5018 
#define IDS_QUALITY_DRAFT           5019 
#define IDS_NO_DEVICES              5020 
#define IDS_NOT_FAX_DEVICE          5021 

// 
// Dialog resource IDs 
// 
#define IDD_DOCPROP                     5023 
#define IDD_DEVICE_INFO                 5024 
#define IDD_SEND_PROP                   5025 
#define IDD_RECEIVE_PROP                5026 
#define IDD_STATUS_OPTIONS              5027 
#define IDD_ARCHIVE_FOLDER              5028 
#define IDD_REMOTE_INFO                 5029 
#define IDI_UP                          5030 
#define IDI_DOWN                        5031 
#define IDI_FAX_DEVICE                  5032 
#define IDI_STATUS                      5033 
#define IDI_SEND                        5034 
#define IDI_RECEIVE                     5035 
#define IDI_ARCHIVE                     5036 
#define IDI_DEVICE_INFO                 5037 
#define IDI_REMOTE                      5038 
#define IDI_FAX_ERROR                   5039 
#define IDI_FAX_OPTIONS                 5040 
#define IDR_SEND                        5041 
#define IDR_RECEIVE                     5042 
#define IDR_CONTEXTMENU                 5043 
#define IDI_FAX_INFO                    5044 
#define IDD_SOUNDS                      5045 
#define IDD_CLEANUP_PROP                5046 
#define IDI_CLEANUP                     5047 
#define IDD_CONFIG_PROP                 5048 
// 
// Control resource IDs 
// 
#define IDC_PAPER_SIZE                  5049 
#define IDC_IMAGE_QUALITY               5050 
#define IDC_PORTRAIT                    5051 
#define IDC_LANDSCAPE                   5052 
#define IDC_TITLE                       5053 
#define IDC_FAX_SEND_GRP                5054 
#define IDC_DEFAULT_PRINT_SETUP_GRP     5055 
#define IDC_ORIENTATION                 5056 
#define IDC_STATIC_DEVICE_INFO          5057 
#define IDC_PRI_UP                      5059 
#define IDC_PRI_DOWN                    5060 
#define IDC_PRINT_TO                    5062 
#define IDC_RINGS                       5064 
#define IDC_DEVICE_INFO_GRP             5065 
#define IDC_DEST_FOLDER                 5066 
#define IDC_DEVICE_PROP                 5067 
#define IDC_STATIC_TSID                 5069 
#define IDC_DEVICE_PROP_TSID            5070 
#define IDC_STATIC_TSID1                5071 
#define IDC_STATIC_CSID                 5072 
#define IDC_DEVICE_PROP_CSID            5073 
#define IDC_STATIC_CSID1                5074 
#define IDC_DEVICE_PROP_RINGS           5075 
#define IDC_DEVICE_PROP_SPIN_RINGS      5076 
#define IDC_STATIC_RINGS                5077 
#define IDC_DEVICE_PROP_PRINT           5078 
#define IDC_DEVICE_PROP_PRINT_TO        5079 
#define IDC_DEVICE_PROP_SAVE            5080 
#define IDC_DEVICE_PROP_DEST_FOLDER     5081 
#define IDC_DEVICE_PROP_DEST_FOLDER_BR  5082 
#define IDC_STATIC_ROUTE                5083 
#define IDC_STATIC_BORDER               5084 
#define IDC_STATIC_ARCHIVE              5085 
#define IDC_INCOMING                    5086 
#define IDC_INCOMING_FOLDER             5087 
#define IDC_INCOMING_FOLDER_BR          5088 
#define IDC_OUTGOING                    5089 
#define IDC_OUTGOING_FOLDER             5090 
#define IDC_OUTGOING_FOLDER_BR          5091 
#define IDC_STATIC_PRINT                5092 
#define IDC_STATIC_SAVE                 5093 
#define IDC_STATIC_DEVICE               5094 
#define IDC_STATIC_REMOTE_INFO          5095 
#define IDC_DEVICE_PROP_MANUAL_ANSWER   5096 
#define IDC_DEVICE_PROP_AUTO_ANSWER     5097 
#define IDC_STATIC_RINGS1               5098 
#define IDC_DEVICE_PROP_NEVER_ANSWER    5099 
#define IDC_STATIC_STATUS_OPTIONS       5100 
#define IDC_STATUS_TASKBAR              5101 
#define IDC_STATUS_SOUND                5102 
#define IDC_STATUS_BALLOON_TIMEOUT      5103 
#define IDC_BALLOON_TIMEOUT             5104 
#define IDC_BALLOON_TIMEOUT_SPIN        5105 
#define IDC_STATIC_BALLOON_TIMEOUT      5106 
#define IDC_STATIC_BALLOON_TIMEOUT1     5107 
#define IDC_STATUS_BALLOON              5108 
#define IDC_SEND_NOTIFICATION           5109 
#define IDC_RECEIVE_NOTIFICATION        5110 
#define IDC_SENDERROR_NOTIFICATION      5111 
#define IDC_STATIC_DISPLAY_BALLOON      5112 
#define IDC_RING_NOTIFICATION           5113 
#define IDC_STATIC_SEND_OPTIONS         5114 
#define IDC_STATIC_ARCHIVE_ICON         5115 
#define IDC_STATIC_STATUS_ICON          5116 
#define IDC_STATIC_SEND_ICON            5117 
#define IDC_STATIC_RECEIVE_OPTIONS      5118 
#define IDC_STATIC_ERROR_ICON           5119 
#define IDC_STATIC_RECEIVE_ICON         5120 
#define IDC_STATIC_ARCHIVE_OPTIONS      5121 
#define IDC_STATIC_REMOTE_PRINTER       5123 
#define IDC_STATIC_DEVICE_ICON          5124 
#define IDCSTATIC_ANSWER_MODE           5125 
#define IDC_STATIC_REMOTE_ICON          5126 
#define IDC_STATIC_CHECK_NOTIFICATION_DESC 5127 
#define IDC_STATIC_CHECK_NOTIFICATION_ICON 5128 
#define IDC_STATIC_CLEANUP_ICON         5130 
#define IDC_STATIC_CLEANUP_OPTIONS      5131 
#define IDC_CONFIG_FAX_LINK             5134 
// 
// Notifications page IDD_STATUS_OPTIONS 
// 
#define IDC_CHECK_MONITOR_ON_SEND       5137 
#define IDC_CHECK_MONITOR_ON_RECEIVE    5138 
#define IDC_BUTTON_SOUND                5139 
#define IDC_GROUP_NOTIFY                5140 
#define IDC_CHECK_NOTIFY_PROGRESS       5141 
#define IDC_CHECK_NOTIFY_IN_COMPLETE    5142 
#define IDC_CHECK_NOTIFY_OUT_COMPLETE   5143 
#define IDC_GROUP_MONITOR               5144 
#define IDC_STATIC_DEVICE_NOTE          5145 
#define IDC_STATIC_NOTE_ICON            5146 
#define IDC_STATIC_AUTO_OPEN            5147 
// 
// Sound Notifications dialog IDD_SOUNDS 
// 
#define IDC_CHECK_RING                  5148 
#define IDC_CHECK_RECEIVE               5149 
#define IDC_CHECK_SENT                  5150 
#define IDC_CHECK_ERROR                 5151 
#define IDC_BUTTON_CONFIGURE            5152 
// 
// Command resource IDs 
// 
#define IDM_PROPERTY                    5170 
#define IDM_SEND_ENABLE                 5171 
#define IDM_SEND_DISABLE                5172 
#define IDM_RECEIVE_AUTO                5173 
#define IDM_RECEIVE_MANUAL              5174 
#define IDM_RECEIVE_DISABLE             5175 
// 
//  menu IDR_SEND_RECEIVE 
// 
#define IDR_SEND_RECEIVE                5176 
#define IDM_SEND                        5177 
#define IDM_RECEIVE                     5178 
// 
// Security strings 
// 
#define IDS_SECURITY_TITLE              5196 

#endif  // _FAXUI_RESOURCE_H_ 

//////////////////////////////////////////////////////
//                                                  //
// Fax UI resource ID file                          //
// It compiles as part of FxsRes.dll                //
// All the IDs should be in range                   //
//                                                  //
// [5000 - 5999]                                    //
//                                                  //
//////////////////////////////////////////////////////
=== C:/Users/treeman/Desktop/windows nt source code\Source\Win2K3\NT\printscan\faxsrv\print\faxprint\faxui\util.c ===
/*++

Copyright (c) 1996  Microsoft Corporation

Module Name:

    util.c

Abstract:

    utility functions

Environment:

        Fax configuration applet

Revision History:

        05/26/00 -taoyuan-
                Created it.

        mm/dd/yy -author-
                description

--*/

#include <stdio.h>
#include "faxui.h"
#include "resource.h"

typedef struct _STRING_TABLE {
    DWORD   ResourceId;
    LPTSTR  String;
} STRING_TABLE, *PSTRING_TABLE;

static STRING_TABLE StringTable[] =
{
    { IDS_DEVICE_ENABLED,           NULL},
    { IDS_DEVICE_DISABLED,          NULL},
    { IDS_DEVICE_AUTO_ANSWER,       NULL},
    { IDS_DEVICE_MANUAL_ANSWER,     NULL}

};

#define CountStringTable (sizeof(StringTable)/sizeof(STRING_TABLE))

VOID
InitializeStringTable(
    VOID
    )
/*++

Routine Description:

    Initialize the string table for future use

Arguments:

    None

Return Value:

    None

--*/

{
    DWORD i;
    TCHAR szBuffer[256];

    for (i=0; i<CountStringTable; i++) 
    {
        if (LoadString(
            g_hResource,
            StringTable[i].ResourceId,
            szBuffer,
            sizeof(szBuffer)/sizeof(TCHAR))) 
        {
            StringTable[i].String = (LPTSTR) MemAlloc( StringSize( szBuffer ) );
            if (!StringTable[i].String) {
                StringTable[i].String = NULL;
            } else {
                _tcscpy( StringTable[i].String, szBuffer );
            }
        } 
        else 
        {
            Error(( "LoadString failed, resource ID is %d.\n", StringTable[i].ResourceId ));
            StringTable[i].String = NULL;
        }
    }
}

VOID
DeInitializeStringTable(
    VOID
    )
/*++

Routine Description:

    Deinitialize the string table and release allocated memory

Arguments:

    None

Return Value:

    None

--*/

{
    DWORD i;

    for (i=0; i<CountStringTable; i++) 
    {
        if(StringTable[i].String)
        {
            MemFree(StringTable[i].String);
            StringTable[i].String = NULL;
        }
    }
}

LPTSTR
GetString(
    DWORD ResourceId
    )

/*++

Routine Description:

    Loads a resource string and returns a pointer to the string.
    The caller must free the memory.

Arguments:

    ResourceId      - resource string id

Return Value:

    pointer to the string

--*/

{
    DWORD i;

    for (i=0; i<CountStringTable; i++) 
    {
        if (StringTable[i].ResourceId == ResourceId) 
        {
            return StringTable[i].String;
        }
    }

    Assert(FALSE);
    return NULL;
}


INT
DisplayErrorMessage(
    HWND    hwndParent,
    UINT    uiType,
    INT     iErrorCode,
    ...
    )

/*++

Routine Description:

    Display an Error Message dialog box

Arguments:

    hwndParent - Specifies a parent window for the error message dialog
    type - Specifies the type of message box to be displayed
    iErrorCode - Win32 Error Code
    ...

Return Value:

    Same as the return value from MessageBox

--*/

{
    LPTSTR      pTitle = NULL;
    LPTSTR      pFormat = NULL;
    LPTSTR      pMessage = NULL;
    INT         result;
    va_list     ap;
    INT         iStringID = 0;
    BOOL        bOK = TRUE;

    if ((pTitle = AllocStringZ(MAX_TITLE_LEN)) &&
        (pFormat = AllocStringZ(MAX_STRING_LEN)) &&
        (pMessage = AllocStringZ(MAX_MESSAGE_LEN)))
    {
        //
        //  Load Title String
        //
        if (!LoadString(g_hResource, IDS_MSG_TITLE, pTitle, MAX_TITLE_LEN))
        {
            Error(("Failed to load preview message string. (ec: %lc)",GetLastError()));
            bOK = FALSE;
            goto Exit;
        }

        //
        // Load Error Message 
        //
        iStringID = GetErrorStringId(iErrorCode);
        if (!LoadString(g_hResource, iStringID, pFormat, MAX_STRING_LEN))
        {
            Error(("Failed to load preview message string. (ec: %lc)",GetLastError()));
            bOK = FALSE;
            goto Exit;
        }

        //
        // Compose the message string
        //
        va_start(ap, iErrorCode);
        wvsprintf(pMessage, pFormat, ap);
        va_end(ap);

        //
        // Display the message box
        //
        if (uiType == 0)
        {
            uiType = MB_OK | MB_ICONERROR;
        }

        result = AlignedMessageBox(hwndParent, pMessage, pTitle, uiType);
    } 
    else 
    {
        bOK = FALSE;
    }

Exit:
    if (!bOK)
    {
        MessageBeep(MB_ICONHAND);
        result = 0;
    }

    MemFree(pTitle);
    MemFree(pFormat);
    MemFree(pMessage);

    return result;
}

BOOL IsLocalPrinter(
    LPTSTR pPrinterName
    )

/*++

Routine Description:

    Check whether given printer is local

Arguments:

    pPrinterName - giver printer name

Return Value:

    TRUE if it's local, FALSE otherwise

--*/

{
    DWORD ErrorCode = 0;
    BOOL Found = FALSE;
    PPRINTER_INFO_4 pPrinterInfo = NULL;
    DWORD BytesNeeded = 0;
    DWORD NumPrinters = 0;
    PPRINTER_INFO_4 pCurrPrinterInfo;

    //
    // enumerate local printers
    //
    if (EnumPrinters(PRINTER_ENUM_LOCAL, NULL, 4, NULL, 0, &BytesNeeded, &NumPrinters))
    {
        // if succeeds, there are no printers
        goto CleanUp;
    }
    else if ((GetLastError() != ERROR_INSUFFICIENT_BUFFER)
            || !(pPrinterInfo = (PPRINTER_INFO_4) GlobalAlloc(GMEM_FIXED, BytesNeeded))
            || !EnumPrinters(PRINTER_ENUM_LOCAL, NULL, 4, (LPBYTE) pPrinterInfo,
                BytesNeeded, &BytesNeeded, &NumPrinters))
    {
        ErrorCode = GetLastError();
        goto CleanUp;
    }

    for (pCurrPrinterInfo = pPrinterInfo;
        !Found && (pCurrPrinterInfo < (pPrinterInfo + NumPrinters));
        pCurrPrinterInfo++)
    {
        // check for printer name
        if (!lstrcmpi(pCurrPrinterInfo->pPrinterName, pPrinterName))
        {
            Found = TRUE;
        }
    }

CleanUp:

    if (pPrinterInfo)
    {
        GlobalFree(pPrinterInfo);
    }

    SetLastError(ErrorCode);
    return Found;
}


VOID
DisConnect(
)
/*++

Routine Description:

    Close current connection to the fax service

Arguments:

    None.

Return Value:

    None.

--*/

{
    if (g_hFaxSvcHandle) {
        FaxClose(g_hFaxSvcHandle);
        g_hFaxSvcHandle = NULL;
    }
}

BOOL
Connect(
    HWND    hDlg,
    BOOL    bDisplayErrorMessage
)
/*++

Routine Description:

    Connect to the fax service

Arguments:

    hDlg - the caller window handle
    bDisplayErrorMessage - indicate whether display the error message to the user

Return Value:

    TRUE if successfully connected, FALSE if there is an error.

--*/

{
    DWORD   dwRes = 0;

    //
    // Check if already connected to the fax service
    //
    if (g_hFaxSvcHandle) 
    {
        return TRUE;
    }

    //
    // Connect to the fax service
    //
    if (!FaxConnectFaxServer(NULL, &g_hFaxSvcHandle)) 
    {
        dwRes = GetLastError();

        Error(( "Can't connect to the fax server, ec = %d.\n", dwRes));

        if(bDisplayErrorMessage)
        {
            DisplayErrorMessage(hDlg, 0, dwRes);
        }

        return FALSE;
    }

    return TRUE;
}


BOOL
DirectoryExists(
    LPTSTR  pDirectoryName
    )

/*++

Routine Description:

    Check the existancy of given folder name

Arguments:

    pDirectoryName - point to folder name

Return Value:

    if the folder exists, return TRUE; else, return FALSE.

--*/

{
    TCHAR   pFullDirectoryName[MAX_PATH];
    DWORD   dwFileAttributes;
    DWORD   dwSize;

    if(!pDirectoryName || lstrlen(pDirectoryName) == 0)
    {
        return FALSE;
    }

    dwSize = ExpandEnvironmentStrings(pDirectoryName, pFullDirectoryName, MAX_PATH);
    if(dwSize == 0)
    {
        return FALSE;
    }

    dwFileAttributes = GetFileAttributes(pFullDirectoryName);

    if ( dwFileAttributes != 0xffffffff &&
         dwFileAttributes & FILE_ATTRIBUTE_DIRECTORY ) 
    {
        return TRUE;
    }

    return FALSE;
}

BOOL 
FaxDeviceEnableRoutingMethod(
    HANDLE hFaxHandle,      
    DWORD dwDeviceId,       
    LPCTSTR pRoutingGuid,    
    LONG Enabled            
)

/*++

Routine Description:

    Get or set the current status of a routing method for specific device

Arguments:

    hFaxHandle - fax handle by FaxConnectFaxServer()
    dwDeviceId - device ID
    pRoutingGuid - GUID that identifies the fax routing method
    Enabled - enabled status for the device and method, if Enabled is QUERY_STATUS, 
            it means return value is the current state

Return Value:

    if Enabled is QUERY_STATUS, return the current state of routing method;
    if Enabled is QUERY_ENABLE or QUERY_DISABLE, return TRUE for success, FALSE for failure.

--*/

{
    HANDLE  hFaxPortHandle = NULL;
    BOOL    bResult = FALSE;
    LPBYTE  pRoutingInfoBuffer = NULL;
    DWORD   dwRoutingInfoBufferSize;

    Assert(hFaxHandle);
    if(!hFaxHandle || !FaxOpenPort(hFaxHandle, dwDeviceId, PORT_OPEN_QUERY | PORT_OPEN_MODIFY, &hFaxPortHandle))
    {
        goto exit;
    }

    if(!FaxGetRoutingInfo(hFaxPortHandle, pRoutingGuid, &pRoutingInfoBuffer, &dwRoutingInfoBufferSize))
    {
        goto exit;
    }

    if(Enabled == QUERY_STATUS)
    {
        //
        // for query status
        // 
        bResult = *((LPDWORD)pRoutingInfoBuffer) > 0 ? TRUE : FALSE;
    }
    else
    {
        //
        // for set status
        // 
        *((LPDWORD)pRoutingInfoBuffer) = (Enabled == STATUS_ENABLE) ? TRUE : FALSE;
        if(FaxSetRoutingInfo(hFaxPortHandle, pRoutingGuid, pRoutingInfoBuffer, dwRoutingInfoBufferSize))
        {
            bResult = TRUE;
        }
    }

exit:
    if(pRoutingInfoBuffer) { FaxFreeBuffer(pRoutingInfoBuffer); }
    if(hFaxPortHandle) { FaxClose(hFaxPortHandle); }
    return bResult;
}

int CALLBACK BrowseCallbackProc(
    HWND    hDlg,
    UINT    uMsg,
    LPARAM  lParam,
    LPARAM  dwData)

/*++

Routine Description:

    We use this callback function to specify the initial folder

Arguments:

    hDlg - Specifies the dialog window on which the Browse button is displayed
    uMsg - Value identifying the event. 
    lParam - Value dependent upon the message contained in the uMsg parameter. 
    dwData - Application-defined value that was specified in the lParam member of the BROWSEINFO structure. 

Return Value:

    Returns zero.

--*/

{
    switch(uMsg)
    {
        case BFFM_INITIALIZED:
            SendMessage(hDlg, BFFM_SETSELECTION, TRUE, dwData);
            break;

        case BFFM_SELCHANGED:
        {
            BOOL bFolderIsOK = FALSE;
            TCHAR szPath [MAX_PATH + 1];

            if (SHGetPathFromIDList ((LPITEMIDLIST) lParam, szPath)) 
            {
                DWORD dwFileAttr = GetFileAttributes(szPath);
                if (-1 != dwFileAttr && (dwFileAttr & FILE_ATTRIBUTE_DIRECTORY))
                {
                    //
                    // The directory exists - enable the 'Ok' button
                    //
                    bFolderIsOK = TRUE;
                }
            }
            //
            // Enable / disable the 'ok' button
            //
            SendMessage(hDlg, BFFM_ENABLEOK , 0, (LPARAM)bFolderIsOK);
            break;
        }

    }

    return 0;
}

BOOL
BrowseForDirectory(
    HWND   hDlg,
    INT    hResource,
    DWORD  dwMaxPath,
    LPTSTR title
    )

/*++

Routine Description:

    Browse for a directory

Arguments:

    hDlg       - Specifies the dialog window on which the Browse button is displayed
    hResource  - resource id to receive the directory 
    dwMaxPath  - max path length
    title      - the title to be shown in the browse dialog

Return Value:

    TRUE if successful, FALSE if the user presses Cancel

--*/

{
    LPITEMIDLIST    pidl;
    TCHAR           buffer[MAX_PATH];
    BOOL            bResult = FALSE;
    LPMALLOC        pMalloc = NULL;

    BROWSEINFO bi = {

        hDlg,
        NULL,
        buffer,
        title,
        BIF_RETURNONLYFSDIRS | BIF_NEWDIALOGSTYLE,
        BrowseCallbackProc,
        (LPARAM) buffer,
    };

    Verbose(("Entering BrowseForDirectory...\n"));

    if (!GetDlgItemText( hDlg, hResource, buffer, MAX_PATH))
        buffer[0] = 0;

    if(E_FAIL == SHGetMalloc(&pMalloc))
    {
        return bResult;
    }

    if (pidl = SHBrowseForFolder(&bi)) 
    {
        if (SHGetPathFromIDList(pidl, buffer)) 
        {
            if (_tcslen(buffer) > dwMaxPath)
            {
                DisplayErrorMessage(hDlg, 0, FAXUI_ERROR_NAME_IS_TOO_LONG);
            }
            else 
            {
                SetDlgItemText(hDlg, hResource, buffer);
                bResult = TRUE;
            }
        }

        pMalloc->lpVtbl->Free(pMalloc, (LPVOID)pidl);

    }

    pMalloc->lpVtbl->Release(pMalloc);

    return bResult;
}

LPTSTR
ValidatePath(
    LPTSTR szPath
    )

/*++

Routine Description:

    Check and remove the '\' at the end of the string

Arguments:

    szPath - string pointer

Return Value:

    return the new string pointer

--*/

{
    DWORD i;

    if (szPath == NULL || szPath[0] == 0) 
    {
        return szPath;
    }

    i = lstrlen(szPath)-1;
    for (; i>0; i--) 
    {
        if (szPath[i] == TEXT('\\')) 
        {
            szPath[i] = 0;
        }
        else
        {
            break;
        }
    }

    return szPath;
}

PFAX_PORT_INFO_EX
FindPortInfo(
    DWORD dwDeviceId
)
/*++

Routine Description:

    Find FAX_PORT_INFO_EX by dwDeviceId in g_pFaxPortInfo

Arguments:

    dwDeviceId - [in] device ID to find

Return Value:

    pointer to FAX_PORT_INFO_EX structure if found
    NULL otherwise

--*/
{
    DWORD dw;

    if(!g_pFaxPortInfo || !g_dwPortsNum)
    {
        return NULL;
    }

    for(dw=0; dw < g_dwPortsNum; ++dw)
    {
        if(g_pFaxPortInfo[dw].dwDeviceID == dwDeviceId)
        {
            return &g_pFaxPortInfo[dw];
        }
    }           
    
    return NULL;
}

BOOL 
CALLBACK 
PageEnableProc(
  HWND   hwnd,    
  LPARAM lParam 
)
/*++

Routine Description:

    Disable each control of a property page

Arguments:

    hwnd   - [in] handle to child window
    lParam - [in] BOOL bEnable

Return Value:

    TRUE to continue enumeration

--*/
{
    EnableWindow(hwnd, (BOOL)lParam);
    return TRUE;
}


void
PageEnable(
    HWND hDlg,
    BOOL bEnable
)
/*++

Routine Description:

    Enumerate and enable/disable all controls of a property page

Arguments:

    hDlg    - [in] property page handle
    bEnable - [in] TRUE for enable, FALSE for disable

Return Value:

    none

--*/
{
    if(!EnumChildWindows(hDlg, PageEnableProc, (LPARAM)bEnable))
    {
        Error(( "EnumChildWindows failed with %d\n", GetLastError()));
    }
}

DWORD
CountUsedFaxDevices()
/*++

Routine Description:

    Count the number of the devices configured to send or receive faxes

Arguments:

  none

Return Value:

    Number of the fax devices

--*/
{
    DWORD dw;
    DWORD dwNum=0;

    if(!g_pFaxPortInfo || !g_dwPortsNum)
    {
        return dwNum;
    }

    for(dw=0; dw < g_dwPortsNum; ++dw)
    {
        if(g_pFaxPortInfo[dw].bSend || (FAX_DEVICE_RECEIVE_MODE_OFF != g_pFaxPortInfo[dw].ReceiveMode))
        {
            ++dwNum;
        }
    }           
    return dwNum;
}

BOOL
IsDeviceInUse(
    DWORD dwDeviceId
)
/*++

Routine Description:

    Determine whether the device is configured for send or receive

Arguments:

    dwDeviceId - [in] Device ID

Return Value:

    TRUE if the device is configured for send or receive
    FALSE otherwise

--*/
{
    PFAX_PORT_INFO_EX pPortInfo = FindPortInfo(dwDeviceId);
    if(!pPortInfo)
    {
        return FALSE;
    }

    if(pPortInfo->bSend || (FAX_DEVICE_RECEIVE_MODE_OFF != pPortInfo->ReceiveMode))
    {
        return TRUE;
    }
    return FALSE;
}
=== C:/Users/treeman/Desktop/windows nt source code\Source\Win2K3\NT\printscan\faxsrv\print\faxprint\faxui\prnprop.c ===
/*++

Copyright (c) 1996  Microsoft Corporation

Module Name:

    prnprop.c

Abstract:

    Implementation of DDI entry points:
        DrvDevicePropertySheets
        PrinterProperties

Environment:

    Fax driver user interface

Revision History:

    01/09/96 -davidx-
        Created it.

    mm/dd/yy -author-
        description

--*/

#include "faxui.h"
#include <shlobjp.h>
#include <shellapi.h>
#include <faxreg.h>


#include "resource.h"

BOOL    g_bUserCanChangeSettings = FALSE;
BOOL    g_bUserCanQuerySettings  = FALSE;
HANDLE  g_hFaxSvcHandle          = NULL;   // global fax handle
HANDLE  g_hFaxActCtx             = INVALID_HANDLE_VALUE; 

BOOL    g_bLinkWindowRegistered  = FALSE;



PFAX_PORT_INFO_EX  g_pFaxPortInfo = NULL;
DWORD              g_dwPortsNum = 0;

BOOL  g_bPortInfoChanged = FALSE;

#define EXTRA_PAGES 3

extern HANDLE  g_hModule;

HANDLE CreateActivationContextFromResource(LPCTSTR pszResourceName)
{
    TCHAR   tszModuleName[MAX_PATH * 2] = {0};
    ACTCTX  act = {0};
    //    
    // Get the name for the module that contains the manifest resource
    // to create the Activation Context from.
    //
    if (!GetModuleFileName(g_hModule, tszModuleName, ARR_SIZE(tszModuleName)-1))
    {
        return INVALID_HANDLE_VALUE;
    }
    //
    // Now let's try to create an activation context from manifest resource.
    //
    act.cbSize          = sizeof(act);
    act.dwFlags         = ACTCTX_FLAG_RESOURCE_NAME_VALID;
    act.lpResourceName  = pszResourceName;
    act.lpSource        = tszModuleName;

    return CreateActCtx(&act);
}   // CreateActivationContextFromResource

void ReleaseActivationContext()
{
    if (INVALID_HANDLE_VALUE != g_hFaxActCtx)
    {
        ReleaseActCtx(g_hFaxActCtx);
        g_hFaxActCtx = INVALID_HANDLE_VALUE;
    }
}   // ReleaseActivationContext


BOOL CreateFaxActivationContext()
{
    if(INVALID_HANDLE_VALUE != g_hFaxActCtx)
    {
        //
        // Already created
        //
        return TRUE;
    }
    g_hFaxActCtx = CreateActivationContextFromResource(MAKEINTRESOURCE(SXS_MANIFEST_RESOURCE_ID));
    return (INVALID_HANDLE_VALUE != g_hFaxActCtx);
}   // CreateFaxActivationContext

HANDLE GetFaxActivationContext()
{
    //
    // Make sure we've created our activation context.
    //
    CreateFaxActivationContext();
    // Return the global.
    return g_hFaxActCtx;
}   // GetFaxActivationContext


HPROPSHEETPAGE
AddPropertyPage(
    PPROPSHEETUI_INFO   pPSUIInfo,
    PROPSHEETPAGE      *psp 
)
{
    HPROPSHEETPAGE hRes;
    hRes = (HPROPSHEETPAGE)(pPSUIInfo->pfnComPropSheet(
                                pPSUIInfo->hComPropSheet, 
                                CPSFUNC_ADD_PROPSHEETPAGE, 
                                (LPARAM) psp, 
                                0));
    return hRes;
}   // AddPropertyPage

LONG
DrvDevicePropertySheets(
    PPROPSHEETUI_INFO   pPSUIInfo,
    LPARAM              lParam
    )

/*++

Routine Description:

    Display "Printer Properties" dialog

Arguments:

    pPSUIInfo - Pointer to a PROPSHEETUI_INFO structure
    lParam - Pointer to a DEVICEPROPERTYHEADER structure

Return Value:

    > 0 if successful, <= 0 if failed

[Note:]

    Please refer to WinNT DDK/SDK documentation for more details.

--*/

{
    PDEVICEPROPERTYHEADER   pDPHdr;
    PROPSHEETPAGE           psp[EXTRA_PAGES]={0};
    HPROPSHEETPAGE          hPropSheetPage;
    DWORD                   dwRes = 0;
    int                     iRet  = 1;
    HANDLE                  hActCtx = INVALID_HANDLE_VALUE;

    //
    // Do not execute any code before this initialization
    //
    if(!InitializeDll())
    {
        return -1;
    }

    //
    // Validate input parameters
    //
    if (!pPSUIInfo || !(pDPHdr = (PDEVICEPROPERTYHEADER) pPSUIInfo->lParamInit)) 
    {
        Assert(FALSE);
        return -1;
    }

    //
    // Handle various cases for which this function might be called
    //
    switch (pPSUIInfo->Reason) 
    {
        case PROPSHEETUI_REASON_INIT:

            InitializeStringTable();
            memset(psp, 0, sizeof(psp));

            //
            // Need to add a Activation Context so that Compstui will create the property page using
            // ComCtl v6 (i.e. so it will / can be Themed).
            //
            hActCtx = GetFaxActivationContext();
            if (INVALID_HANDLE_VALUE != hActCtx)
            {
                pPSUIInfo->pfnComPropSheet(pPSUIInfo->hComPropSheet, 
                                           CPSFUNC_SET_FUSION_CONTEXT, 
                                           (LPARAM)hActCtx, 
                                           0);
            }

            //
            // if the printer is remote, show a simple page
            //
            if(!IsLocalPrinter(pDPHdr->pszPrinterName))
            {
                //
                // add a simple page because we need to add at least one page
                //
                psp[0].dwSize = sizeof(PROPSHEETPAGE);
                psp[0].hInstance = g_hResource;
                psp[0].lParam = (LPARAM)pDPHdr->pszPrinterName;
                psp[0].pszTemplate = MAKEINTRESOURCE(IDD_REMOTE_INFO);
                psp[0].pfnDlgProc = RemoteInfoDlgProc;

                if ( hPropSheetPage = AddPropertyPage(pPSUIInfo, &psp[0]) )
                {
                    pPSUIInfo->UserData = 0;
                    pPSUIInfo->Result = CPSUI_CANCEL;
                    goto exit;
                }
                break;
            }

            //
            // check the user's right to query/modify device setting, if the user doesn't have
            // modify permission, all controls will be disabled.
            //
            if(Connect(NULL, TRUE))
            {
                g_bUserCanQuerySettings = FaxAccessCheckEx(g_hFaxSvcHandle, FAX_ACCESS_QUERY_CONFIG, NULL);
                if(ERROR_SUCCESS != GetLastError())
                {
                    dwRes = GetLastError();
                    Error(( "FaxAccessCheckEx(FAX_ACCESS_QUERY_CONFIG) failed with %d\n", dwRes));
                    goto ConnectError;
                }

                g_bUserCanChangeSettings = FaxAccessCheckEx(g_hFaxSvcHandle, FAX_ACCESS_MANAGE_CONFIG, NULL);
                if(ERROR_SUCCESS != GetLastError())
                {
                    dwRes = GetLastError();
                    Error(( "FaxAccessCheckEx(FAX_ACCESS_MANAGE_CONFIG) failed with %d\n", dwRes));
                    goto ConnectError;
                }

                if(g_bUserCanQuerySettings)
                {
                    g_bPortInfoChanged = FALSE;
                    if(!FaxEnumPortsEx(g_hFaxSvcHandle, &g_pFaxPortInfo, &g_dwPortsNum))
                    {
                        dwRes = GetLastError();
                        Error(( "FaxEnumPortsEx failed with %d\n", dwRes));
                        goto ConnectError;
                    }
                }

                DisConnect();
            }
			
			//
			// Tracking page  -  added both in Desktop & Server SKU's
			//
			psp[1].dwSize      = sizeof(PROPSHEETPAGE);
			psp[1].hInstance   = g_hResource;
			psp[1].lParam      = 0;
			psp[1].pszTemplate = MAKEINTRESOURCE(IDD_STATUS_OPTIONS);
			psp[1].pfnDlgProc  = StatusOptionDlgProc;

			if (IsDesktopSKU())
			{
				//
				// Devices page 
				//
				psp[0].dwSize      = sizeof(PROPSHEETPAGE);
				psp[0].hInstance   = g_hResource;
				psp[0].lParam      = 0;
				psp[0].pszTemplate = MAKEINTRESOURCE(IDD_DEVICE_INFO);
				psp[0].pfnDlgProc  = DeviceInfoDlgProc;

				//
				// Archives page
				//
				psp[2].dwSize      = sizeof(PROPSHEETPAGE);
				psp[2].hInstance   = g_hResource;
				psp[2].lParam      = 0;
				psp[2].pszTemplate = MAKEINTRESOURCE(IDD_ARCHIVE_FOLDER);
				psp[2].pfnDlgProc  = ArchiveInfoDlgProc;

				if(!IsSimpleUI())
				{
					//
					// Add Fax Security page
					//
					hPropSheetPage = CreateFaxSecurityPage();
					if(hPropSheetPage)
					{                
						if(!pPSUIInfo->pfnComPropSheet(pPSUIInfo->hComPropSheet, 
													   CPSFUNC_ADD_HPROPSHEETPAGE, 
													   (LPARAM)hPropSheetPage, 
													   0))
						{
							Error(("Failed to add Fax Security page.\n"));
						}
					}
				}

                if(g_bUserCanQuerySettings)
                {
			        if (!AddPropertyPage(pPSUIInfo, &psp[0])) 	// Devices(desktop)
			        {
				        Error(("Failed to add property page"));
				        goto exit;
			        }

			        if (!AddPropertyPage(pPSUIInfo, &psp[1]))	// Tracking (desktop & server)
			        {
				        Error(("Failed to add Tracking property page"));
				        goto exit;
			        }

			        if (!AddPropertyPage(pPSUIInfo, &psp[2]))   // Archives(desktop)
			        {
				        Error(("Failed to add Archives property page"));
				        goto exit;
			        }
                }
			}
			else 
			{
				//
				// Case of Server SKU  
				// This page contains link to Admin Console
				//
				g_bLinkWindowRegistered = LinkWindow_RegisterClass();
				if(!g_bLinkWindowRegistered)
				{
					Error(("LinkWindow_RegisterClass() failed - unable to register link window class.\n"));
					goto exit;
				}

				psp[0].dwSize      = sizeof(PROPSHEETPAGE);
				psp[0].hInstance   = g_hResource;
				psp[0].lParam      = 0;
				psp[0].pszTemplate = MAKEINTRESOURCE(IDD_CONFIG_PROP);
				psp[0].pfnDlgProc  = ConfigOptionDlgProc;

			    if (!AddPropertyPage(pPSUIInfo, &psp[0])) 	// Fax configuration
			    {
				    Error(("Failed to add property page"));
				    goto exit;
			    }

                if(g_bUserCanQuerySettings)
                {
			        if (!AddPropertyPage(pPSUIInfo, &psp[1]))	// always Tracking
			        {
				        Error(("Failed to add Tracking property page"));
				        goto exit;
			        }
                }
            }
			

			// Added all needed pages
			pPSUIInfo->UserData = 0;
			pPSUIInfo->Result = CPSUI_CANCEL;
			goto exit;
			
            break;

ConnectError:
            DisConnect();
            DisplayErrorMessage(NULL, 0, dwRes);
            break;

        case PROPSHEETUI_REASON_GET_INFO_HEADER:
            {
                PPROPSHEETUI_INFO_HEADER   pPSUIHdr;

                pPSUIHdr = (PPROPSHEETUI_INFO_HEADER) lParam;
                pPSUIHdr->Flags = PSUIHDRF_PROPTITLE | PSUIHDRF_NOAPPLYNOW;
                pPSUIHdr->pTitle = pDPHdr->pszPrinterName;
                pPSUIHdr->hInst = g_hResource;
                pPSUIHdr->IconID = IDI_CPSUI_FAX;
            }

            goto exit;

        case PROPSHEETUI_REASON_SET_RESULT:
            pPSUIInfo->Result = ((PSETRESULT_INFO) lParam)->Result;
            goto exit;

        case PROPSHEETUI_REASON_DESTROY:
            DeInitializeStringTable();

            g_dwPortsNum = 0;
            FaxFreeBuffer(g_pFaxPortInfo);
            g_pFaxPortInfo = NULL;
			if(g_bLinkWindowRegistered )
			{
				LinkWindow_UnregisterClass( g_hResource );
				g_bLinkWindowRegistered = FALSE;
			}
            //
            // Release CFaxSecurity object
            //
            ReleaseFaxSecurity();
			DisConnect();
            goto exit;
    }

exit:
    return iRet;
}   // DrvDevicePropertySheets


BOOL
PrinterProperties(
    HWND    hwnd,
    HANDLE  hPrinter
    )

/*++

Routine Description:

    Displays a printer-properties dialog box for the specified printer

Arguments:

    hwnd - Identifies the parent window of the dialog box
    hPrinter - Identifies a printer object

Return Value:

    If the function succeeds, the return value is TRUE.
    If the function fails, the return value is FALSE.

[Note:]

    This is the old entry point for the spooler. Even though
    no one should be using this, do it for compatibility.

--*/

{
    DEVICEPROPERTYHEADER devPropHdr;
    DWORD                result;

    //
    // Do not execute any code before this initialization
    //
    if(!InitializeDll())
    {
        return FALSE;
    }

    memset(&devPropHdr, 0, sizeof(devPropHdr));
    devPropHdr.cbSize = sizeof(devPropHdr);
    devPropHdr.hPrinter = hPrinter;
    devPropHdr.pszPrinterName = NULL;

    //
    // Decide if the caller has permission to change anything
    //

    if (! SetPrinterDataDWord(hPrinter, PRNDATA_PERMISSION, 1))
        devPropHdr.Flags |= DPS_NOPERMISSION;

    CallCompstui(hwnd, DrvDevicePropertySheets, (LPARAM) &devPropHdr, &result);

    return result > 0;
}
=== C:/Users/treeman/Desktop/windows nt source code\Source\Win2K3\NT\printscan\faxsrv\print\faxprint\inc\devmode.h ===
/*++

Copyright (c) 1996  Microsoft Corporation

Module Name:

    devmode.h

Abstract:

    DEVMODE related declarations and definitions

Environment:

        Fax driver, user and kernel mode

Revision History:

        01/09/96 -davidx-
                Created it.

        dd-mm-yy -author-
                description

--*/

#ifndef _DEVMODE_H_
#define _DEVMODE_H_

//
// Driver version number and signatures
//
#include <faxreg.h>

#define DRIVER_VERSION      0x400   // driver version number
#define DRIVER_SIGNATURE    'xafD'  // driver signature
#ifndef WIN95
#define DRIVER_NAME         FAX_DRIVER_NAME
#else
#define DRIVER_NAME         "Microsoft Fax Client"

#endif

//
// Maximum length of some strings in the private portion of devmode
//

#define MAX_SENDER_NAME         64
#define MAX_RECIPIENT_NAME      64
#define MAX_RECIPIENT_NUMBER    64
#define MAX_SUBJECT_LINE        128
#define MAX_EMAIL_ADDRESS       128

//
// Maximum TIFF file size for a single page
//
#define MAX_TIFF_PAGE_SIZE      0x200000    // 2Mb


//
// Preview map file header
//
typedef struct _MAP_TIFF_PAGE_HEADER
{
    DWORD cb;
    DWORD dwDataSize;
    INT iPageCount;
    BOOL bPreview;
} MAP_TIFF_PAGE_HEADER, *PMAP_TIFF_PAGE_HEADER;


//
// PostScript driver private devmode fields
//

typedef struct {

    DWORD       signature;          // private devmode signature
    DWORD       flags;              // flag bits
    INT         sendCoverPage;      // whether to send cover page
    INT         whenToSend;         // "Time to send" option
    FAX_TIME    sendAtTime;         // specific time to send
    DWORD       reserved[8];        // reserved

    //
    // Private fields used for passing info between kernel and user mode DLLs
    //  pointer to user mode memory
    //

    PVOID       pUserMem;           // PDOCEVENTUSERMEM

    //
    // Billing code
    //

    TCHAR       billingCode[MAX_USERINFO_BILLING_CODE + 1];

    //
    // email address for delivery reports
    //

    TCHAR       emailAddress[MAX_EMAIL_ADDRESS];

    //
    // Mapping file for driver communication (Used by Print preview).
    //

    TCHAR       szMappingFile[MAX_PATH];
} DMPRIVATE, *PDMPRIVATE;

typedef struct {

    DEVMODE     dmPublic;           // public devmode fields
    DMPRIVATE   dmPrivate;          // private devmode fields

} DRVDEVMODE, *PDRVDEVMODE;

//
// Check if a devmode structure is current version
//

#define CurrentVersionDevmode(pDevmode) \
        ((pDevmode) != NULL && \
         (pDevmode)->dmSpecVersion == DM_SPECVERSION && \
         (pDevmode)->dmDriverVersion == DRIVER_VERSION && \
         (pDevmode)->dmSize == sizeof(DEVMODE) && \
         (pDevmode)->dmDriverExtra == sizeof(DMPRIVATE))


//
// Constant flag bits for DMPRIVATE.flags field
//

#define FAXDM_NO_HALFTONE    0x0001 // don't halftone bitmap images
#define FAXDM_1D_ENCODING    0x0002 // use group3 1D encoding
#define FAXDM_NO_WIZARD      0x0004 // bypass wizard
#define FAXDM_DRIVER_DEFAULT 0x0008 // driver default devmode

//
// Default form names and form sizes
//

#define FORMNAME_LETTER     TEXT("Letter")
#define FORMNAME_A4         TEXT("A4")
#define FORMNAME_LEGAL      TEXT("Legal")

#define LETTER_WIDTH        215900  // 8.5" in microns
#define LETTER_HEIGHT       279400  // 11" in microns
#define A4_WIDTH            210000  // 210mm in microns
#define A4_HEIGHT           297000  // 297mm in microns

//
// Default resolutions for fax output
//

#define FAXRES_HORIZONTAL   200
#define FAXRES_VERTICAL     200
#define FAXRES_VERTDRAFT    100

//
// Maximum allowable bitmap size (in pixels) for fax output
//

#define MAX_WIDTH_PIXELS    1728
#define MAX_HEIGHT_PIXELS   2800

//
// Retrieve driver default devmode
//

VOID
DriverDefaultDevmode(
    PDRVDEVMODE pdm,
    LPTSTR      pDeviceName,
    HANDLE      hPrinter
    );

//
// Merge the source devmode into the destination devmode
//

BOOL
MergeDevmode(
    PDRVDEVMODE pdmDest,
    PDEVMODE    pdmSrc,
    BOOL        publicOnly
    );

//
// NOTE: These are defined in printers\lib directory. Declare them here to
// avoid including libproto.h and dragging in lots of other junk.
//

LONG
ConvertDevmode(
    PDEVMODE pdmIn,
    PDEVMODE pdmOut
    );

#ifdef KERNEL_MODE

extern DEVHTINFO DefDevHTInfo;
extern COLORADJUSTMENT DefHTClrAdj;

#endif

#endif // !_DEVMODE_H_
=== C:/Users/treeman/Desktop/windows nt source code\Source\Win2K3\NT\printscan\faxsrv\print\faxprint\faxui\security.cpp ===
//
// ISecurityInformation interface implementation
//

#include <aclui.h>
#include "faxui.h"

class CFaxSecurity : public ISecurityInformation
{
protected:
    ULONG  m_cRef;

    STDMETHOD(MakeSelfRelativeCopy)(PSECURITY_DESCRIPTOR  psdOriginal,
                                    PSECURITY_DESCRIPTOR* ppsdNew);
public:
    CFaxSecurity() : m_cRef(1) {}
    virtual ~CFaxSecurity() {}

    // IUnknown methods
    STDMETHOD(QueryInterface)(REFIID, LPVOID *);
    STDMETHOD_(ULONG, AddRef)();
    STDMETHOD_(ULONG, Release)();

    // ISecurityInformation methods
    STDMETHOD(GetObjectInformation)(PSI_OBJECT_INFO pObjectInfo);

    STDMETHOD(GetSecurity)(SECURITY_INFORMATION si,
                           PSECURITY_DESCRIPTOR *ppSD,
                           BOOL fDefault);

    STDMETHOD(SetSecurity)(SECURITY_INFORMATION si,
                           PSECURITY_DESCRIPTOR pSD);

    STDMETHOD(GetAccessRights)(const GUID* pguidObjectType,
                               DWORD dwFlags,
                               PSI_ACCESS *ppAccess,
                               ULONG *pcAccesses,
                               ULONG *piDefaultAccess);

    STDMETHOD(MapGeneric)(const GUID *pguidObjectType,
                          UCHAR *pAceFlags,
                          ACCESS_MASK *pmask);

    STDMETHOD(GetInheritTypes)(PSI_INHERIT_TYPE *ppInheritTypes,
                               ULONG *pcInheritTypes);

    STDMETHOD(PropertySheetPageCallback)(HWND hwnd,
                                         UINT uMsg,
                                         SI_PAGE_TYPE uPage);
};


CFaxSecurity* g_pFaxSecurity = NULL;


///////////////////////////////////////////////////////////
//
// IUnknown methods
//
///////////////////////////////////////////////////////////

STDMETHODIMP_(ULONG)
CFaxSecurity::AddRef()
{
    return ++m_cRef;
}

STDMETHODIMP_(ULONG)
CFaxSecurity::Release()
{
    if (--m_cRef == 0)
    {
        delete this;
        g_pFaxSecurity = NULL;
        return 0;
    }

    return m_cRef;
}

STDMETHODIMP
CFaxSecurity::QueryInterface(REFIID riid, LPVOID FAR* ppv)
{
    if (IsEqualIID(riid, IID_IUnknown) || IsEqualIID(riid, IID_ISecurityInformation))
    {
        *ppv = (LPSECURITYINFO)this;
        m_cRef++;
        return S_OK;
    }
    else
    {
        *ppv = NULL;
        return E_NOINTERFACE;
    }
}


///////////////////////////////////////////////////////////
//
// ISecurityInformation methods
//
///////////////////////////////////////////////////////////

STDMETHODIMP
CFaxSecurity::GetObjectInformation(PSI_OBJECT_INFO pObjectInfo)
// *** ISecurityInformation methods implementation ***
/*
 -  CFaxSecurity::GetObjectInformation
 -
 *  Purpose:
 *      Performs an access check against the fax service security descriptor
 *
 *  Arguments:
 *      [in]   pObjectInfo      - pointer to object information structure.
 *
 *  Return:
 *      OLE error code
 */
{
    DWORD  ec  = ERROR_SUCCESS;
    
    if(!Connect(NULL, FALSE))
    {
        return S_FALSE;
    }

    HANDLE  hPrivBeforeSE_TAKE_OWNERSHIP = INVALID_HANDLE_VALUE;
    HANDLE  hPrivBeforeSE_SECURITY       = INVALID_HANDLE_VALUE;

    if( pObjectInfo == NULL ) 
    {
        Error(("Invalid parameter - pObjectInfo == NULL\n"));
        Assert( pObjectInfo != NULL );
        return E_POINTER;
    }

    //
    // Set Flags
    //
    pObjectInfo->dwFlags =  SI_EDIT_ALL       | 
                            SI_NO_TREE_APPLY  | 
                            SI_NO_ACL_PROTECT |
                            SI_ADVANCED       |
                            SI_PAGE_TITLE;
    
    //
    // Check if to add SI_READONLY 
    //
    if (!FaxAccessCheckEx(g_hFaxSvcHandle, WRITE_DAC, NULL))
    {
		ec = GetLastError();
        if (ERROR_SUCCESS == ec)
        {
		    pObjectInfo->dwFlags |= SI_READONLY;
        }
        else 
        {
            Error(("FaxAccessCheckEx(WRITE_DAC) failed with %d \n", ec));
            goto exit;
        }
    }

    //
    // Check if to add SI_OWNER_READONLY 
    //
    hPrivBeforeSE_TAKE_OWNERSHIP = EnablePrivilege (SE_TAKE_OWNERSHIP_NAME);
    //
    // No error checking - If we failed we will get ERROR_ACCESS_DENIED in the access check
    // 
    if (!FaxAccessCheckEx(g_hFaxSvcHandle,WRITE_OWNER, NULL))
    {
		ec = GetLastError();
        if (ERROR_SUCCESS == ec)
        {
		    pObjectInfo->dwFlags |= SI_OWNER_READONLY;
        }
        else 
        {
            Error(("FaxAccessCheckEx(WRITE_OWNER) failed with %d \n", ec));
            goto exit;
        }
    }

    //
    // Check if to remove SI_EDIT_AUDITS 
    //
    hPrivBeforeSE_SECURITY = EnablePrivilege (SE_SECURITY_NAME);
    //
    // No error checking - If we failed we will get ERROR_ACCESS_DENIED in the access check
    // 
    if (!FaxAccessCheckEx(g_hFaxSvcHandle, ACCESS_SYSTEM_SECURITY, NULL))
    {
		ec = GetLastError();
        if (ERROR_SUCCESS == ec)
        {
		    pObjectInfo->dwFlags &= ~SI_EDIT_AUDITS;
        }
        else 
        {
            Error(("FaxAccessCheckEx(ACCESS_SYSTEM_SECURITY) failed with %d \n", ec));
            goto exit;
        }
    }


    //
    // Set all other fields
    //
    static TCHAR tszPageTitle[MAX_PATH] = {0};
    if(LoadString((HINSTANCE)g_hResource, IDS_SECURITY_TITLE, tszPageTitle, ARR_SIZE(tszPageTitle)))
    {
        pObjectInfo->pszPageTitle = tszPageTitle;
    }
    else
    {
        ec = GetLastError();
        Error(("LoadString(IDS_SECURITY_TITLE) failed with %d \n", ec));

        pObjectInfo->pszPageTitle = NULL;
    }

    static TCHAR tszPrinterName[MAX_PATH] = {0};
    if(GetFirstLocalFaxPrinterName(tszPrinterName, ARR_SIZE(tszPrinterName)))
    {
        pObjectInfo->pszObjectName = tszPrinterName;
    }
    else
    {
        ec = GetLastError();
        Error(("GetFirstLocalFaxPrinterName() failed with %d \n", ec));

        pObjectInfo->pszObjectName = NULL;
    }
   
    pObjectInfo->hInstance = (HINSTANCE)g_hResource; 
    pObjectInfo->pszServerName = NULL;    

exit:
    ReleasePrivilege (hPrivBeforeSE_SECURITY);
    ReleasePrivilege (hPrivBeforeSE_TAKE_OWNERSHIP);
    return HRESULT_FROM_WIN32(ec);

} // CFaxSecurity::GetObjectInformation


STDMETHODIMP
CFaxSecurity::GetSecurity(SECURITY_INFORMATION  si,
                          PSECURITY_DESCRIPTOR* ppSD,
                          BOOL                  fDefault)
/*
 -  CFaxSecurityInformation::GetSecurity
 -
 *  Purpose:
 *      requests a security descriptor for the securable object whose 
 *      security descriptor is being edited. The access control editor 
 *      calls this method to retrieve the object's current or default security descriptor.
 *
 *  Arguments:
 *      [in]   RequestedInformation  - security information.
 *      [out]  ppSecurityDescriptor  - pointer to security descriptor.
 *      [in]   fDefault              - not implemented
 *
 *  Return:
 *      OLE error code
 */
{
    HRESULT hRc = S_OK;
    DWORD   ec  = ERROR_SUCCESS;

    PSECURITY_DESCRIPTOR pSecurityDescriptor = NULL;

    HANDLE  hPrivBeforeSE_SECURITY = INVALID_HANDLE_VALUE;

    Assert(ppSD);

    if(!Connect(NULL, FALSE))
    {
        return S_FALSE;
    }
	   
    if( fDefault == TRUE ) 
    {
        Error(("Non implemeted feature -> fDefault == TRUE\n"));
        return E_NOTIMPL;
    }  

	if (si & SACL_SECURITY_INFORMATION)
	{
		hPrivBeforeSE_SECURITY = EnablePrivilege (SE_SECURITY_NAME);    
	}

	//
    // Get the current relative descriptor from the fax server
    //
    if(!FaxGetSecurityEx(g_hFaxSvcHandle, si, &pSecurityDescriptor)) 
    {
        ec = GetLastError();
        Error(("FaxGetSecurityEx() failed with %d\n", ec));
        hRc = HRESULT_FROM_WIN32(ec);
        goto exit;
    }

	//
    // return a self relative descriptor copy allocated with LocalAlloc()
    //
	hRc = MakeSelfRelativeCopy( pSecurityDescriptor, ppSD );
    if( FAILED( hRc ) ) 
    {
        Error(("MakeSelfRelativeCopy() failed with %08X\n", hRc));
        goto exit;
    }    
    
    Assert(S_OK == hRc);
    
exit:
	if (pSecurityDescriptor)
	{
		FaxFreeBuffer(pSecurityDescriptor);
	}
	ReleasePrivilege (hPrivBeforeSE_SECURITY);

    return hRc;

} // CFaxSecurity::GetSecurity

STDMETHODIMP
CFaxSecurity::SetSecurity(SECURITY_INFORMATION si,
                          PSECURITY_DESCRIPTOR pSD)
/*
 -  CFaxSecurityInformation::SetSecurity
 -
 *  Purpose:
 *      Provides a security descriptor containing the security information 
 *      the user wants to apply to the securable object. The access control 
 *      editor calls this method when the user clicks the Okay or Apply buttons.
 *
 *  Arguments:
 *      [in]   SecurityInformation - security information structure.
 *      [in]   pSecurityDescriptor - pointer to security descriptor.
 *
 *  Return:
 *      OLE error code
 */
{
    HRESULT  hRc = S_OK;
    DWORD    ec = ERROR_SUCCESS;

    PSECURITY_DESCRIPTOR psdSelfRelativeCopy = NULL;
    
	HANDLE  hPrivBeforeSE_TAKE_OWNERSHIP = INVALID_HANDLE_VALUE;
    HANDLE  hPrivBeforeSE_SECURITY       = INVALID_HANDLE_VALUE;
 
    Assert(pSD); 
    Assert( IsValidSecurityDescriptor( pSD ));     
	
    if(!Connect(NULL, FALSE))
    {
        return S_FALSE;
    }

	//
    // Prepare self relative descriptor
    //
	hRc = MakeSelfRelativeCopy( pSD, &psdSelfRelativeCopy );
    if( FAILED( hRc ) ) 
    {
        Error(("MakeSelfRelativeCopy() failed with %08X\n", hRc));
        goto exit;
    }

	if (si & OWNER_SECURITY_INFORMATION)
	{
		hPrivBeforeSE_TAKE_OWNERSHIP = EnablePrivilege (SE_TAKE_OWNERSHIP_NAME);    
	}

	if (si & SACL_SECURITY_INFORMATION)
	{
		hPrivBeforeSE_SECURITY = EnablePrivilege (SE_SECURITY_NAME);
	}
	
    //
    // save the new relative descriptor to the fax server
    //
    if(!FaxSetSecurity(g_hFaxSvcHandle, si, psdSelfRelativeCopy)) 
    {
        ec = GetLastError();
        Error(("FaxSetSecurity() failed with %d\n", ec));
        hRc = HRESULT_FROM_WIN32(ec);
        goto exit;
    }

    Assert( S_OK == hRc || E_ACCESSDENIED == hRc);	

exit:
    if (psdSelfRelativeCopy)
	{
		::LocalFree(psdSelfRelativeCopy);
	}

	ReleasePrivilege (hPrivBeforeSE_SECURITY);
    ReleasePrivilege (hPrivBeforeSE_TAKE_OWNERSHIP);
		
	return hRc;

} // CFaxSecurity::SetSecurity

STDMETHODIMP
CFaxSecurity::GetAccessRights(const GUID* pguidObjectType,
                              DWORD       dwFlags,
                              PSI_ACCESS* ppAccess,
                              ULONG*      pcAccesses,
                              ULONG*      piDefaultAccess)
/*
 -  CFaxSecurityInformation::GetAccessRights
 -
 *  Purpose:
 *      Requests information about the access rights that can be 
 *      controlled for a securable object. The access control 
 *      editor calls this method to retrieve display strings and 
 *      other information used to initialize the property pages.
 *
 *  Arguments:
 *      [in] pguidObjectType  - Pointer to a GUID structure that 
 *                              identifies the type of object for which 
 *                              access rights are being requested. 
 *      [in] dwFlags -          A set of bit flags that indicate the property
 *                              page being initialized
 *      [out] ppAccess -        Pointer to a variable that you should 
 *                              set to a pointer to an array of SI_ACCESS 
 *                              structures. 
 *      [out] pcAccesses -      Pointer to a variable that you should set 
 *                              to indicate the number of entries in the ppAccess array. 
 *      [out] piDefaultAccess - Pointer to a variable that you should set 
 *                              to indicate the zero-based index of the array entry that contains 
 *                              the default access rights. 
 *                              The access control editor uses this entry as the initial access rights in a new ACE. 
 *
 *  Return:
 *      OLE error code
 */
{
    Assert( ppAccess );
    Assert( pcAccesses );
    Assert( piDefaultAccess );

    //
    // Access rights for the Basic security page
    //
    static SI_ACCESS siFaxBasicAccess[] =
    {
        // 0 Fax
        {   
            &GUID_NULL, 
            FAX_ACCESS_SUBMIT_HIGH | FAX_ACCESS_SUBMIT_NORMAL | FAX_ACCESS_SUBMIT | FAX_ACCESS_QUERY_IN_ARCHIVE,
            MAKEINTRESOURCE(IDS_RIGHT_FAX),
            SI_ACCESS_GENERAL | SI_ACCESS_SPECIFIC
        },
        // 1 Manage fax configuration
        {   
            &GUID_NULL, 
            FAX_ACCESS_MANAGE_CONFIG | FAX_ACCESS_QUERY_CONFIG,
            MAKEINTRESOURCE(IDS_RIGHT_MNG_CFG),
            SI_ACCESS_GENERAL | SI_ACCESS_SPECIFIC
        },
        // 2 Manage fax documents
        {   
            &GUID_NULL, 
            FAX_ACCESS_MANAGE_JOBS			| FAX_ACCESS_QUERY_JOBS			|
            FAX_ACCESS_MANAGE_IN_ARCHIVE	| FAX_ACCESS_QUERY_IN_ARCHIVE	|
            FAX_ACCESS_MANAGE_OUT_ARCHIVE	| FAX_ACCESS_QUERY_OUT_ARCHIVE,
            MAKEINTRESOURCE(IDS_RIGHT_MNG_DOC),
            SI_ACCESS_GENERAL | SI_ACCESS_SPECIFIC
        }
    };

    //
    // Access rights for the Advanced security page
    //
    static SI_ACCESS siFaxAccess[] =
    {
        // 0 submit permission
        {   
            &GUID_NULL, 
            FAX_ACCESS_SUBMIT ,
            MAKEINTRESOURCE(IDS_FAXSEC_SUB_LOW),
            SI_ACCESS_GENERAL | SI_ACCESS_SPECIFIC
        },
        // 1 submit normal permission
        {   
            &GUID_NULL, 
            FAX_ACCESS_SUBMIT_NORMAL ,
            MAKEINTRESOURCE(IDS_FAXSEC_SUB_NORMAL),
            SI_ACCESS_GENERAL | SI_ACCESS_SPECIFIC
        },
        // 2 submit high permission
        {   
            &GUID_NULL, 
            FAX_ACCESS_SUBMIT_HIGH ,
            MAKEINTRESOURCE(IDS_FAXSEC_SUB_HIGH),
            SI_ACCESS_GENERAL | SI_ACCESS_SPECIFIC
        },
        // 3 query jobs 
        {   
            &GUID_NULL, 
            FAX_ACCESS_QUERY_JOBS,
            MAKEINTRESOURCE(IDS_FAXSEC_JOB_QRY),    
            SI_ACCESS_GENERAL | SI_ACCESS_SPECIFIC
        },
        // 4 Manage jobs
        {   
            &GUID_NULL, 
            FAX_ACCESS_MANAGE_JOBS,
            MAKEINTRESOURCE(IDS_FAXSEC_JOB_MNG),
            SI_ACCESS_GENERAL | SI_ACCESS_SPECIFIC
        },
        // 5 query configuration
        {   
            &GUID_NULL, 
            FAX_ACCESS_QUERY_CONFIG,
            MAKEINTRESOURCE(IDS_FAXSEC_CONFIG_QRY),    
            SI_ACCESS_GENERAL | SI_ACCESS_SPECIFIC
        },
        // 6 Manage configuration
        {   
            &GUID_NULL, 
            FAX_ACCESS_MANAGE_CONFIG,
            MAKEINTRESOURCE(IDS_FAXSEC_CONFIG_SET),
            SI_ACCESS_GENERAL | SI_ACCESS_SPECIFIC
        },    
        // 7 Query incoming faxes archive
        {   
            &GUID_NULL, 
            FAX_ACCESS_QUERY_IN_ARCHIVE,
            MAKEINTRESOURCE(IDS_FAXSEC_QRY_IN_ARCH),    
            SI_ACCESS_GENERAL | SI_ACCESS_SPECIFIC
        },
        // 8 Manage incoming faxes archive
        {   
            &GUID_NULL, 
            FAX_ACCESS_MANAGE_IN_ARCHIVE,
            MAKEINTRESOURCE(IDS_FAXSEC_MNG_IN_ARCH),    
            SI_ACCESS_GENERAL | SI_ACCESS_SPECIFIC
        },
        // 9 Query outgoing faxes archive
        {   
            &GUID_NULL, 
            FAX_ACCESS_QUERY_OUT_ARCHIVE,
            MAKEINTRESOURCE(IDS_FAXSEC_QRY_OUT_ARCH),    
            SI_ACCESS_GENERAL | SI_ACCESS_SPECIFIC
        },
        // 10 Manage outgoing faxes archive
        {   
            &GUID_NULL, 
            FAX_ACCESS_MANAGE_OUT_ARCHIVE,
            MAKEINTRESOURCE(IDS_FAXSEC_MNG_OUT_ARCH),    
            SI_ACCESS_GENERAL | SI_ACCESS_SPECIFIC
        },
        // specific permissions
        // 11 Read permission
        {   
            &GUID_NULL, 
            READ_CONTROL,
            MAKEINTRESOURCE(IDS_FAXSEC_READ_PERM),
            SI_ACCESS_SPECIFIC 
        },
        // 12 Change Permissions
        {   
            &GUID_NULL, 
            WRITE_DAC,
            MAKEINTRESOURCE(IDS_FAXSEC_CHNG_PERM),
            SI_ACCESS_SPECIFIC 
        },
        // 13 Take ownership
        {   
            &GUID_NULL, 
            WRITE_OWNER,
            MAKEINTRESOURCE(IDS_FAXSEC_CHNG_OWNER),
            SI_ACCESS_SPECIFIC
        }
    };

    *ppAccess        = (0 == dwFlags) ? siFaxBasicAccess : siFaxAccess;    
    *pcAccesses      = ULONG((0 == dwFlags) ? ARR_SIZE(siFaxBasicAccess) : ARR_SIZE(siFaxAccess));
    *piDefaultAccess = (0 == dwFlags) ? 0 : 1;

    return S_OK;

} // CFaxSecurity::GetAccessRights


STDMETHODIMP
CFaxSecurity::MapGeneric(const GUID*  pguidObjectType,
                         UCHAR*       pAceFlags,
                         ACCESS_MASK* pmask)
/*
 -  CFaxSecurityInformation::MapGeneric
 -
 *  Purpose:
 *      Requests that the generic access rights in an access mask 
 *      be mapped to their corresponding standard and specific access rights.
 *
 *  Arguments:
 *
 *  Return:
 *      OLE error code
 */
{
    static GENERIC_MAPPING genericMapping =
    {
            (STANDARD_RIGHTS_READ | FAX_GENERIC_READ),          // GenericRead 
            (STANDARD_RIGHTS_WRITE | FAX_GENERIC_WRITE),        // GenericWrite 
            (STANDARD_RIGHTS_EXECUTE | FAX_GENERIC_EXECUTE),    // GenericExecute 
            (READ_CONTROL | WRITE_DAC | WRITE_OWNER | FAX_GENERIC_ALL) // GenericAll 
    };

    MapGenericMask(pmask, &genericMapping);

    return S_OK;
}

STDMETHODIMP
CFaxSecurity::GetInheritTypes(PSI_INHERIT_TYPE* ppInheritTypes,
                              ULONG*            pcInheritTypes)
{
    return E_NOTIMPL;
}

STDMETHODIMP
CFaxSecurity::PropertySheetPageCallback(HWND         hwnd,
                                        UINT         uMsg,
                                        SI_PAGE_TYPE uPage)
{
    return S_OK;
}


HRESULT 
CFaxSecurity::MakeSelfRelativeCopy(PSECURITY_DESCRIPTOR  psdOriginal,
                                   PSECURITY_DESCRIPTOR* ppsdNew)
/*
 -  CFaxSecurityInformation::MakeSelfRelativeCopy
 -
 *  Purpose:
 *      This pravite method copies Security descriptors 
 *
 *  Arguments:
 *
 *  Return:
 *      OLE error code
 */
{
    Assert( NULL != psdOriginal );

    //
    // we have to find out whether the original is already self-relative
    //
    SECURITY_DESCRIPTOR_CONTROL  sdc                 = 0;
    PSECURITY_DESCRIPTOR         psdSelfRelativeCopy = NULL;
    DWORD                        dwRevision          = 0;
    DWORD                        cb                  = 0;

    Assert(IsValidSecurityDescriptor( psdOriginal ) ); 

    if( !::GetSecurityDescriptorControl( psdOriginal, &sdc, &dwRevision ) ) 
    {
        DWORD err = ::GetLastError();
        Error(("GetSecurityDescriptorControl() failed with %d\n", err));
        return HRESULT_FROM_WIN32( err );
    }

    if( sdc & SE_SELF_RELATIVE )
	{
        // the original is in self-relative format, just byte-copy it

        // get size
        cb = ::GetSecurityDescriptorLength( psdOriginal );

        // alloc the memory
        psdSelfRelativeCopy = (PSECURITY_DESCRIPTOR) ::LocalAlloc( LMEM_ZEROINIT, cb );
        if(NULL == psdSelfRelativeCopy) 
        {
            Error(("Out of memory.\n"));
            return E_OUTOFMEMORY;
        }

        // make the copy
        ::memcpy( psdSelfRelativeCopy, psdOriginal, cb );
    } 
    else 
    {
        // the original is in absolute format, convert-copy it

        // get new size - it will fail and set cb to the correct buffer size
        ::MakeSelfRelativeSD( psdOriginal, NULL, &cb );

        // alloc the new amount of memory
        psdSelfRelativeCopy = (PSECURITY_DESCRIPTOR) ::LocalAlloc( LMEM_ZEROINIT, cb );
        if(!psdSelfRelativeCopy) 
        {
            Error(("Out of memory.\n"));
            return E_OUTOFMEMORY; // just in case the exception is ignored
        }

        if( !::MakeSelfRelativeSD( psdOriginal, psdSelfRelativeCopy, &cb ) ) 
        {
            DWORD err = ::GetLastError();
            Error(("MakeSelfRelativeSD() failed with %d\n", err));

            ::LocalFree( psdSelfRelativeCopy );

            return HRESULT_FROM_WIN32( err );
        }
    }

    *ppsdNew = psdSelfRelativeCopy;
    return S_OK;
}


///////////////////////////////////////////////////////////////////////////////
//
//  This is the entry point function called from our code
//
///////////////////////////////////////////////////////////////////////////////

HMODULE g_hAclui = NULL;

extern "C"
HPROPSHEETPAGE 
CreateFaxSecurityPage()
{
    HPROPSHEETPAGE hPage = NULL;
    HPROPSHEETPAGE (*pfCreateSecurityPage)(LPSECURITYINFO) = NULL;
 
    if(!IsWinXPOS())
    {
        //
        // The security page should bge added only to the local fax printer on XP OS.
        //
        Assert(FALSE);
        return NULL;
    }

    //
    // CreateSecurityPage() Requires Windows 2000 or later, so we connect to it dynamically
    //
    if(!g_hAclui)
    {
        g_hAclui = LoadLibrary(TEXT("aclui.dll"));
        if(!g_hAclui)
        {
            Error(("LoadLibrary(aclui.dll) failed with %d\n", GetLastError()));
            goto error;
        }
    }
    
    (FARPROC&)pfCreateSecurityPage = GetProcAddress(g_hAclui, "CreateSecurityPage");
    if(!pfCreateSecurityPage)
    {
        Error(("GetProcAddress(CreateSecurityPage) failed with %d\n", GetLastError()));
        goto error;
    }

    if(!g_pFaxSecurity)
    {
        g_pFaxSecurity = new CFaxSecurity();
    }

    if(!g_pFaxSecurity)
    {
        Error(("Out of memory.\n"));
        goto error;
    }

    hPage = pfCreateSecurityPage(g_pFaxSecurity);
    if(!hPage)
    {
        Error(("CreateSecurityPage() failed with %d\n", ::GetLastError()));
        goto error;
    }

    return hPage;

error:

    if(g_hAclui)
    {
        FreeLibrary(g_hAclui);
        g_hAclui = NULL;
    }

    return NULL;
}

extern "C"
void
ReleaseFaxSecurity()
{
    if(g_pFaxSecurity)
    {
        g_pFaxSecurity->Release();
    }

    if(g_hAclui)
    {
        FreeLibrary(g_hAclui);
        g_hAclui = NULL;
    }
}
=== C:/Users/treeman/Desktop/windows nt source code\Source\Win2K3\NT\printscan\faxsrv\print\faxprint\inc\prndata.h ===
/*++

Copyright (c) 1996  Microsoft Corporation

Module Name:

    prndata.h

Abstract:

    Funtions for dealing with printer property data in the registry

Environment:

	Fax driver, user and kernel mode

Revision History:

	01/09/96 -davidx-
		Created it.

	dd-mm-yy -author-
		description

--*/

#ifndef _PRNDATA_H_
#define _PRNDATA_H_

//
// Default discount rate period: 8:00pm to 7:00am
//

#define DEFAULT_STARTCHEAP  MAKELONG(20, 0)
#define DEFAULT_STOPCHEAP   MAKELONG(7, 0)

#define PRNDATA_PERMISSION  TEXT("Permission")
#define PRNDATA_PAPER_SIZE  TEXT("PaperSize")

//
// Get a DWORD value from the registry
//

DWORD
GetPrinterDataDWord(
    HANDLE  hPrinter,
    LPTSTR  pRegKey,
    DWORD   defaultValue
    );

//
// Save a DWORD value to the registry
//

BOOL
SetPrinterDataDWord(
    HANDLE  hPrinter,
    LPTSTR  pRegKey,
    DWORD   value
    );

#endif // !_PRNDATA_H_
=== C:/Users/treeman/Desktop/windows nt source code\Source\Win2K3\NT\printscan\faxsrv\print\faxprint\inc\infowzrd.h ===
#ifndef __INFOWZRD_H_
#define __INFOWZRD_H_

#include <windows.h>
#include <fxsapip.h>
#include <faxsendw.h>

HRESULT	WINAPI
FaxFreeSenderInformation(
	PFAX_PERSONAL_PROFILE pfppSender
	);

HRESULT	WINAPI
FaxSetSenderInformation(
	PFAX_PERSONAL_PROFILE pfppSender
	);

HRESULT	WINAPI
FaxGetSenderInformation(
	PFAX_PERSONAL_PROFILE pfppSender
	);

HRESULT WINAPI 
FaxSendWizard(
        IN  DWORD					hWndOwner,
        IN  DWORD					dwFlags,
        IN  LPTSTR					lptstrServerName,
        IN	LPTSTR					lptstrPrinterName,
        IN	LPFAX_SEND_WIZARD_DATA	lpInitialData,
        OUT	LPTSTR					lptstrTifName,
        IN  UINT                    cchstrTifName,
        OUT	LPFAX_SEND_WIZARD_DATA	lpFaxSendWizardData
   );

HRESULT WINAPI 
FaxFreeSendWizardData(
		LPFAX_SEND_WIZARD_DATA	lpFaxSendWizardData
	);

#endif
=== C:/Users/treeman/Desktop/windows nt source code\Source\Win2K3\NT\printscan\faxsrv\print\faxprint\inc\faxlib.h ===
/*++

Copyright (c) 1996  Microsoft Corporation

Module Name:

    faxlib.h

Abstract:

    Fax driver library header file

Environment:

        Fax driver, kernel and user mode

Revision History:

        01/09/96 -davidx-
                Created it.

        dd-mm-yy -author-
                description

--*/


#ifndef _FAXLIB_H_
#define _FAXLIB_H_

#ifdef __cplusplus
extern "C" {
#endif

#if defined(UNICODE) && !defined(_UNICODE)
#define _UNICODE
#endif

#include <stddef.h>
#include <stdlib.h>
#include <stdarg.h>
#include <windef.h>
#include <winerror.h>
#include <winbase.h>
#include <wingdi.h>
#include <tchar.h>
#include <shlobj.h>
#include <fxsapip.h>

#ifndef KERNEL_MODE

#include <windows.h>
#include <winspool.h>
#include <stdio.h>
#include <faxreg.h>

#define FAXUTIL_ADAPTIVE
#define FAXUTIL_DEBUG
#include <faxutil.h>


#else   // !KERNEL_MODE

#include <winddi.h>


//
// Nul terminator for a character string
//

#define NUL             0

#define IsEmptyString(p)    ((p)[0] == NUL)
#define SizeOfString(p)     ((_tcslen(p) + 1) * sizeof(TCHAR))
#define IsNulChar(c)        ((c) == NUL)


#ifdef USERMODE_DRIVER
    
#include <windows.h>
#include <winspool.h>
#define FAXUTIL_ADAPTIVE
#define FAXUTIL_DEBUG
#include <faxutil.h>

#endif

#endif


#include "devmode.h"
#include "prndata.h"
#include "registry.h"

#define AllocString(cch)    MemAlloc(sizeof(TCHAR) * (cch))
#define AllocStringZ(cch)   MemAllocZ(sizeof(TCHAR) * (cch))

//
// Result of string comparison
//

#define EQUAL_STRING    0

//
// Maximum value for signed and unsigned integers
//

#ifndef MAX_LONG
#define MAX_LONG        0x7fffffff
#endif

#ifndef MAX_DWORD
#define MAX_DWORD       0xffffffff
#endif

#ifndef MAX_SHORT
#define MAX_SHORT       0x7fff
#endif

#ifndef MAX_WORD
#define MAX_WORD        0xffff
#endif

//
// Path separator character
//

#define PATH_SEPARATOR  '\\'

//
// Filename extension character
//

#define FILENAME_EXT    '.'

//
// Deal with the difference between user and kernel mode functions
//

#if defined(KERNEL_MODE) && !defined(USERMODE_DRIVER)

    #define WritePrinter        EngWritePrinter
    #define GetPrinterData      EngGetPrinterData
    #define EnumForms           EngEnumForms
    #define GetPrinter          EngGetPrinter
    #define GetForm             EngGetForm
    #define SetLastError        EngSetLastError
    #define GetLastError        EngGetLastError
    #define MulDiv              EngMulDiv
    
    #define MemAlloc(size)      EngAllocMem(0, size, DRIVER_SIGNATURE)
    #define MemAllocZ(size)     EngAllocMem(FL_ZERO_MEMORY, size, DRIVER_SIGNATURE)
    #define MemFree(ptr)        { if (ptr) EngFreeMem(ptr); }

#else // !KERNEL_MODE

    #ifndef MemAlloc  
        #define MemAlloc(size)      ((PVOID) LocalAlloc(LPTR, (size)))
    #endif    
    #ifndef MemAllocZ 
        #define MemAllocZ(size)     ((PVOID) MemAlloc((size)))
    #endif
    #ifndef MemFree   
        #define MemFree(ptr)        { if (ptr) LocalFree((HLOCAL) (ptr)); }
    #endif        

#endif


//
// Copy Unicode or ANSI string from source to destination
//

VOID
CopyStringW(
    PWSTR   pDest,
    PWSTR   pSrc,
    INT     destSize
    );

VOID
CopyStringA(
    PSTR    pDest,
    PSTR    pSrc,
    INT     destSize
    );

#ifdef  UNICODE
#define CopyString  CopyStringW
#else   // !UNICODE
#define CopyString  CopyStringA
#endif

//
// Make a duplicate of the given character string
//

LPTSTR
DuplicateString(
    LPCTSTR pSrcStr
    );

//
// Strip the directory prefix from a filename (ANSI version)
//

PCSTR
StripDirPrefixA(
    PCSTR   pFilename
    );

//
// Wrapper function for GetPrinter spooler API
//

PVOID
MyGetPrinter(
    HANDLE  hPrinter,
    DWORD   level
    );

//
// Wrapper function for GetPrinterDriver spooler API
//

PVOID
MyGetPrinterDriver(
    HANDLE  hPrinter,
    DWORD   level
    );

//
// Wrapper function for GetPrinterDriverDirectory spooler API
//

LPTSTR
MyGetPrinterDriverDirectory(
    LPTSTR  pServerName,
    LPTSTR  pEnvironment
    );


//
// These macros are used for debugging purposes. They expand
// to white spaces on a free build. Here is a brief description
// of what they do and how they are used:
//
// _debugLevel
//  A variable which controls the amount of debug messages. To generate
//  lots of debug messages, enter the following line in the debugger:
//
//      ed _debugLevel 1
//
// Verbose
//  Display a debug message if VERBOSE is set to non-zero.
//
//      Verbose(("Entering XYZ: param = %d\n", param));
//
// Error
//  Display an error message along with the filename and the line number
//  to indicate where the error occurred.
//
//      Error(("XYZ failed"));
//
// ErrorIf
//  Display an error message if the specified condition is true.
//
//      ErrorIf(error != 0, ("XYZ failed: error = %d\n", error));
//
// Assert
//  Verify a condition is true. If not, force a breakpoint.
//
//      Assert(p != NULL && (p->flags & VALID));

#if DBG

extern ULONG __cdecl DbgPrint(CHAR *, ...);
extern INT _debugLevel;

#if defined(KERNEL_MODE) && !defined(USERMODE_DRIVER)
#define DbgBreakPoint EngDebugBreak
#else
extern VOID DbgBreakPoint(VOID);
#endif

#define Warning(arg) {\
            DbgPrint("WRN %s (%d): ", StripDirPrefixA(__FILE__), __LINE__);\
            DbgPrint arg;\
        }

#define Error(arg) {\
            DbgPrint("ERR %s (%d): ", StripDirPrefixA(__FILE__), __LINE__);\
            DbgPrint arg;\
        }

#define Verbose(arg) { if (_debugLevel > 0) DbgPrint arg; }
#define ErrorIf(cond, arg) { if (cond) Error(arg); }
#define Assert(cond) {\
            if (! (cond)) {\
                DbgPrint("ASSERT: file %s, line %d\n", StripDirPrefixA(__FILE__), __LINE__);\
                DbgBreakPoint();\
            }\
        }

#else   // !DBG

#define Verbose(arg)
#define ErrorIf(cond, arg)
#define Assert(cond)
#define Warning(arg)
#define Error(arg)

#endif

#ifdef __cplusplus
}
#endif

#endif  //!_FAXLIB_H_
=== C:/Users/treeman/Desktop/windows nt source code\Source\Win2K3\NT\printscan\faxsrv\print\faxprint\inc\forms.h ===
/*++

Copyright (c) 1996  Microsoft Corporation

Module Name:

    forms.h

Abstract:

    Declaration of functions for dealing with forms

Environment:

	Fax driver, user and kernel mode

Revision History:

	01/09/96 -davidx-
		Created it.

	dd-mm-yy -author-
		description

--*/

#ifndef _FORMS_H_
#define _FORMS_H_

//
// This is defined in winspool.h but we cannot include it from
// kernel mode source. Define it here until DDI header files are fixed.
//

#if defined(KERNEL_MODE) && !defined(USERMODE_DRIVER)

typedef struct _FORM_INFO_1 {

    DWORD   Flags;
    PWSTR   pName;
    SIZEL   Size;
    RECTL   ImageableArea;

} FORM_INFO_1, *PFORM_INFO_1;

#define FORM_BUILTIN    0x00000001

typedef struct _PRINTER_INFO_2 {

    PWSTR   pServerName;
    PWSTR   pPrinterName;
    PWSTR   pShareName;
    PWSTR   pPortName;
    PWSTR   pDriverName;
    PWSTR   pComment;
    PWSTR   pLocation;
    PDEVMODEW pDevMode;
    PWSTR   pSepFile;
    PWSTR   pPrintProcessor;
    PWSTR   pDatatype;
    PWSTR   pParameters;
    PSECURITY_DESCRIPTOR pSecurityDescriptor;
    DWORD   Attributes;
    DWORD   Priority;
    DWORD   DefaultPriority;
    DWORD   StartTime;
    DWORD   UntilTime;
    DWORD   Status;
    DWORD   cJobs;
    DWORD   AveragePPM;

} PRINTER_INFO_2, *PPRINTER_INFO_2;

#endif // KERNEL_MODE && !USERMODE_DRIVER

//
// We use the highest order bit of FORM_INFO_1.Flags.
// Make sure the spooler is not using this bits.
//

#define FORM_SUPPORTED      0x80000000

#define IsSupportedForm(pForm)  ((pForm)->Flags & FORM_SUPPORTED)
#define SetSupportedForm(pForm) ((pForm)->Flags |= FORM_SUPPORTED)

//
// Our internal unit for measuring paper size and imageable area is microns.
// Following macros converts between microns and pixels, given a resolution
// measured in dots-per-inch.
//

#define MicronToPixel(micron, dpi)  MulDiv(micron, dpi, 25400)

//
// Validate the form specification in a devmode
//

BOOL
ValidDevmodeForm(
    HANDLE       hPrinter,
    PDEVMODE     pdm,
    PFORM_INFO_1 pFormInfo
    );

//
// Return a collection of forms in the system database
//

PFORM_INFO_1
GetFormsDatabase(
    HANDLE  hPrinter,
    PDWORD  pCount
    );

#endif // !_FORMS_H_
=== C:/Users/treeman/Desktop/windows nt source code\Source\Win2K3\NT\printscan\faxsrv\print\faxprint\inc\registry.h ===
/*++

Copyright (c) 1996  Microsoft Corporation

Module Name:

    reguser.h

Abstract:

    For accessing information stored under registry key:
        HKEY_CURRENT_USER and HKEY_LOCAL_MACHINE

Environment:

    Fax driver user interface

Revision History:

    01/16/96 -davidx-
        Created it.

    dd-mm-yy -author-
        description

--*/


#ifndef _REGISTRY_H_
#define _REGISTRY_H_

//
// Maximum length allowed for a string value (including the null terminator)
//

#define MAX_STRING_LEN      MAX_PATH

//
// Open a handle to the specified registry key
//

#define REG_READONLY    KEY_READ
#define REG_READWRITE   KEY_ALL_ACCESS

#define GetUserInfoRegKey(pKeyName, readOnly) \
        OpenRegistryKey(HKEY_CURRENT_USER, pKeyName, FALSE,readOnly)



//
// Get per-user devmode information
//

PDEVMODE
GetPerUserDevmode(
    LPTSTR  pPrinterName
    );

//
// Find the directories under which user cover pages are stored
//

LPTSTR
GetUserCoverPageDir(
    VOID
    );

#endif // !_REGISTRY_H_
=== C:/Users/treeman/Desktop/windows nt source code\Source\Win2K3\NT\printscan\faxsrv\print\faxprint\inc\libproto.h ===
/******************** Function Prototypes file ***************************
 *  libproto.h
 *      Function prototypes for NT printer drivers library.  Also includes
 *      a brief description of the function.
 *
 *  11:04 on Wed 14 Nov 1990    -by-    Lindsay Harris   [lindsayh]
 *
 * Copyright (C) Microsoft Corporation,  1990 - 1992
 *
 ************************************************************************/

#ifndef __LIBPROTO_H__
#define __LIBPROTO_H__

#if defined(NTGDIKM) && !defined(KERNEL_MODE)
#define KERNEL_MODE
#endif

#ifdef NTGDIKM

extern ULONG gulMemID;
#define DbgPrint         DrvDbgPrint
#define HeapAlloc(hHeap,Flags,Size)    DRVALLOC( Size )
#define HeapFree( hHeap, Flags, VBits )  DRVFREE( VBits )

#ifndef FillMemory
#define FillMemory(Destination,Length,Fill) memset((Destination),(Fill),(Length))
#endif

//#define DRVALLOC(c) EngAllocMem(0, c,gulMemID)
//#define DRVFREE(p)  EngFreeMem(p)

#endif

/*
 *   Until there is proper error logging:-
 *      WinSetError( "String" );
 *   The String appears on the debug terminal.  A \n is appended.
 */
void  WinSetError( LPSTR );

/*
 *   Function to add a copy of a string to a heap.  Returns address of copy
 *  of string (if successful) or 0 if memory cannot be allocated.
 */

LPSTR   StrToHeap( HANDLE, LPSTR );
PWSTR   StrToWHeap( HANDLE, LPSTR );            /* Expand to Wide too! */
PWSTR   WstrToHeap( HANDLE, PWSTR );            /* WIDE version */

/*
 *   Convert an ascii style string to WCHAR format, appending it to the
 *  end of the wchar passed in.  Returns value of first parameter.
 */

PWSTR  strcat2WChar( PWSTR, LPSTR );


/*
 *   Convert an ascii style string to WCHAR format, copying it to the
 *  wchar passed in.  Returns value of first parameter.
 */

PWSTR  strcpy2WChar( PWSTR, LPSTR );


/*
 *   The WCHAR world's equivalent of strlen():  returns the number of WCHARs
 *  in the string passed in.
 */

int  wchlen( PWSTR );

/*
 *   Concatenate a PWSTR to another.  Returns address of destination.
 */

PWSTR wchcat( PWSTR, PWSTR );

/*
 *   Copy a PWSTR to another.  Returns address of destination.
 */

PWSTR wchcpy( PWSTR, PWSTR );

PVOID MapFile(PWSTR);

#if NTGDIKM
/*
 *   check if two strings are identical
 */

BOOL bSameStringW(
    PWCHAR pwch1,
    PWCHAR pwch2);

/*
 *   Some system function prototypes have vanished - replace them here.
 */

void  DrvDbgPrint( char *, ... );

#if DBG
#define RIP(x) {DrvDbgPrint((PSZ)(x)); EngDebugBreak();}
#define WARNING(s) DrvDbgPrint("warning: %s",(PSZ)(s))

BOOL
SetAllocCounters(
    VOID
    );

#else
#define RIP(x)
#define WARNING(s)
#endif


LPVOID
DRVALLOC(
    DWORD  cbAlloc
    );

BOOL
DRVFREE(
    LPVOID pMem
    );

#else //NTGDIKM

/*
 *   Break into the debugger - Ye olde RIP.
 */
VOID DoRip( LPSTR );

#if DBG

#define WARNING(s) DbgPrint("warning: %s",(PSZ)(s))

#ifdef FIREWALLS
#define RIP(x) DoRip( (PSZ)(x) )
#else
#define RIP(x) {DbgPrint((PSZ)(x)); DbgBreakPoint();}
#endif

#else

#define WARNING(s)
#define RIP(x)

#endif //DBG

//
// Define kernel debugger print prototypes and macros.
// These are defined in ntrtl.h which we should include
// instead. For now, redefine them here to avoid breaking
// other components.
//

#if DBG

VOID
NTAPI
DbgBreakPoint(
    VOID
    );

ULONG
__cdecl
DbgPrint(
    PCH Format,
    ...
    );

#endif



PVOID MapFile(PWSTR);


#endif //NTGDIKM

/*
 *   A simplified write function.  Returns TRUE if the WriteFile()
 * call returns TRUE and the number of bytes written equals the
 * number requested.
 *
 *  bWrite( file_handle,  address_of_data,  number_of_bytes );
 */

BOOL   bWrite( HANDLE, void  *, int );

/*
 *  Function to copy the contents of one file to another.  The files
 * are referenced via file handles.  No positioning is done - that is
 * up to the user.
 *  The second form also allows a byte count to limit the amount of data
 * copied.
 */


long  lFICopy( HANDLE, HANDLE );
long  lFInCopy( HANDLE, HANDLE, long );


/*
 *   Spooler interaction functions.  These allow drivers to call the
 * spooler directly,  without going through engine stub functions.
 */

BOOL  bSplGetFormW( HANDLE, PWSTR, DWORD, BYTE *, DWORD, DWORD * );


DWORD dwSplGetPrinterDataW( HANDLE, PWSTR, BYTE *, DWORD, DWORD * );


BOOL  bSplWrite( HANDLE, ULONG,  VOID  * );



/*  Function needed to allow the driver to reach the spooler */

BOOL   bImpersonateClient( void );


/************************** HACK ***************************************
 *   The following function is only required until the DEVMODE contains
 *   a form name rather than an index.  And even then it might be required.
 *
 ***********************************************************************/

char  *_IndexToName( int );

// Generic devmode conversion routine

LONG
ConvertDevmode(
    PDEVMODE pdmIn,
    PDEVMODE pdmOut
    );

#ifndef KERNEL_MODE

// Copy DEVMODE to an output buffer before return to the
// caller of DrvDocumentProperties

BOOL
ConvertDevmodeOut(
    PDEVMODE pdmSrc,
    PDEVMODE pdmIn,
    PDEVMODE pdmOut,
	LONG lBufferSize
    );

// Library routine to handle common cases of DrvConvertDevmode

typedef struct {

    WORD    dmDriverVersion;    // current driver version
    WORD    dmDriverExtra;      // size of current version private devmode
    WORD    dmDriverVersion351; // 3.51 driver version
    WORD    dmDriverExtra351;   // size of 3.51 version private devmode

} DRIVER_VERSION_INFO, *PDRIVER_VERSION_INFO;

#define CDM_RESULT_FALSE        0
#define CDM_RESULT_TRUE         1
#define CDM_RESULT_NOT_HANDLED  2

INT
CommonDrvConvertDevmode(
    PWSTR    pPrinterName,
    PDEVMODE pdmIn,
    PDEVMODE pdmOut,
    PLONG    pcbNeeded,
    DWORD    fMode,
    PDRIVER_VERSION_INFO pDriverVersions
    );


UINT
cdecl
DQPsprintf(
    HINSTANCE   hInst,
    LPWSTR      pwBuf,
    DWORD       cchBuf,
    LPDWORD     pcchNeeded,
    LPWSTR      pwszFormat,
    ...
    );

#endif // KERNEL_MODE

#endif // !__LIBPROTO_H__
=== C:/Users/treeman/Desktop/windows nt source code\Source\Win2K3\NT\printscan\faxsrv\print\faxprint\lib\coverpg.c ===
/*++

Copyright (c) 2000 Microsoft Corporation

Module Name:

    coverpg.c

Abstract:

    Functions for manipulating cover page structures

Environment:

	Fax driver, user mode

Revision History:

	01/04/2000 -LiranL-
		Created it.

	mm/dd/yyyy -author-
		description

--*/


#include "faxlib.h"
#include "faxutil.h"
#include "covpg.h"

VOID
FreeCoverPageFields(
    PCOVERPAGEFIELDS    pCPFields
    )

/*++

Routine Description:

    Free up memory used to hold the cover page information

Arguments:

    pCPFields - Points to a COVERPAGEFIELDS structure

Return Value:

    NONE

--*/

{
    if (pCPFields == NULL)
        return;

    //
    // NOTE: We don't need to free the following fields here because they're
    // allocated and freed elsewhere and we're only using a copy of the pointer:
    //  RecName
    //  RecFaxNumber
    //  Note
    //  Subject
    //

    MemFree(pCPFields->SdrName);
    MemFree(pCPFields->SdrFaxNumber);
    MemFree(pCPFields->SdrCompany);
    MemFree(pCPFields->SdrAddress);
    MemFree(pCPFields->SdrTitle);
    MemFree(pCPFields->SdrDepartment);
    MemFree(pCPFields->SdrOfficeLocation);
    MemFree(pCPFields->SdrHomePhone);
    MemFree(pCPFields->SdrOfficePhone);
	MemFree(pCPFields->SdrEmail);
	
    MemFree(pCPFields->NumberOfPages);
    MemFree(pCPFields->TimeSent);

    MemFree(pCPFields);
}



PCOVERPAGEFIELDS
CollectCoverPageFields(
	PFAX_PERSONAL_PROFILE	lpSenderInfo,
    DWORD					pageCount
    )

/*++

Routine Description:

    Collect cover page information into the fields of a newly allocated COVERPAGEFIELDS structure. 
	Fills sender information using the client registry. The following fields are filled:
		SdrName
		SdrCompany
		SdrAddress
		SdrTitle
		SdrDepartment
		SdrOfficeLocation
		SdrHomePhone
		SdrOfficePhone
		SdrFaxNumber
		SdrEmail
	NumberOfPages = pageCount
	TimeSent = formatted date/time string of the current time (calculated at this point)

Arguments:

    pageCount - Total number of pages (including cover pages)

Return Value:

    Pointer to a newly allocated COVERPAGEFIELDS structure, NULL if there is an error.
	It is up to the caller to free this structure using FreeCoverPageFields() which takes
	care of freeing the fields as well.

--*/

#define FillCoverPageField(DestField, SourceField) { \
			if (lpSenderInfo->SourceField && !(pCPFields->DestField = StringDup(lpSenderInfo->SourceField))) \
			{ \
				Error(("Memory allocation failed\n")); \
				goto error;	\
			} \
        }

{
    PCOVERPAGEFIELDS    pCPFields = NULL;
    INT                 dateTimeLen = 0;

    //
    // Allocate memory to hold the top level structure
    // and open the user info registry key for reading
    //

    if (! (pCPFields = MemAllocZ(sizeof(COVERPAGEFIELDS))))
    {
        return NULL;
    }

	ZeroMemory(pCPFields,sizeof(COVERPAGEFIELDS));

    //
    // Read sender information from the registry
    //

    pCPFields->ThisStructSize = sizeof(COVERPAGEFIELDS);

    FillCoverPageField(SdrName,           lptstrName);
    FillCoverPageField(SdrCompany,        lptstrCompany);
    FillCoverPageField(SdrTitle,          lptstrTitle);
    FillCoverPageField(SdrDepartment,     lptstrDepartment);
    FillCoverPageField(SdrOfficeLocation, lptstrOfficeLocation);
    FillCoverPageField(SdrHomePhone,      lptstrHomePhone);
    FillCoverPageField(SdrOfficePhone,    lptstrOfficePhone);
    FillCoverPageField(SdrFaxNumber,      lptstrFaxNumber);
    FillCoverPageField(SdrAddress,        lptstrStreetAddress);
	FillCoverPageField(SdrEmail,		  lptstrEmail);

    //
    // Number of pages and current local system time
    //

    if (pCPFields->NumberOfPages = MemAllocZ(sizeof(TCHAR) * 16))
    {
        wsprintf(pCPFields->NumberOfPages, TEXT("%d"), pageCount);
    }
	else
    {
        Error(("Memory allocation failed\n"));
        goto error;
    }


    //
    // When the fax was sent
    //

    dateTimeLen = 128;

    if (pCPFields->TimeSent = MemAllocZ(sizeof(TCHAR) * dateTimeLen)) 
    {

        LPTSTR  p = pCPFields->TimeSent;
        INT     cch;

        if (!GetY2KCompliantDate(LOCALE_USER_DEFAULT, 0, NULL, p, dateTimeLen))
		{
			Error(("GetY2KCompliantDate: failed. ec = 0X%x\n",GetLastError()));
			goto error;
		}

        cch = _tcslen(p);
        p += cch;

        if (++cch < dateTimeLen) 
        {

            *p++ = (TCHAR)' ';
            dateTimeLen -= cch;

            FaxTimeFormat(LOCALE_USER_DEFAULT, 0, NULL, NULL, p, dateTimeLen);
        }
    }
	else 
    {
        Error(("Memory allocation failed\n"));
		goto error;
	}

    return pCPFields;
error:

	FreeCoverPageFields(pCPFields);

	return NULL;
}
=== C:/Users/treeman/Desktop/windows nt source code\Source\Win2K3\NT\printscan\faxsrv\print\faxprint\lib\devmode.c ===
/*++

Copyright (c) 1990-1993  Microsoft Corporation


Module Name:

    devmode.c


Abstract:

    This module contains devmode conversion


Author:

    08-Jun-1995 Thu 13:47:33 created  -by-  Daniel Chou (danielc)


[Environment:]

    GDI printer drivers, user and kernel mode


[Notes:]


Revision History:

    11/09/95 -davidx-
        New conversion routines

--*/


#include <windef.h>
#include <winerror.h>
#include <wingdi.h>
#include <libproto.h>


//
// This is the devmode version 320 (DM_SPECVERSION)
//

#define DM_SPECVERSION320   0x0320
#define DM_SPECVERSION400   0x0400
#define DM_SPECVERSION401   0x0401
#define DM_SPECVER_BASE     DM_SPECVERSION320

//
// size of a device name string
//

#define CCHDEVICENAME320   32
#define CCHFORMNAME320     32

typedef struct _devicemode320A {
    BYTE    dmDeviceName[CCHDEVICENAME320];
    WORD    dmSpecVersion;
    WORD    dmDriverVersion;
    WORD    dmSize;
    WORD    dmDriverExtra;
    DWORD   dmFields;
    short   dmOrientation;
    short   dmPaperSize;
    short   dmPaperLength;
    short   dmPaperWidth;
    short   dmScale;
    short   dmCopies;
    short   dmDefaultSource;
    short   dmPrintQuality;
    short   dmColor;
    short   dmDuplex;
    short   dmYResolution;
    short   dmTTOption;
    short   dmCollate;
    BYTE    dmFormName[CCHFORMNAME320];
    WORD    dmLogPixels;
    DWORD   dmBitsPerPel;
    DWORD   dmPelsWidth;
    DWORD   dmPelsHeight;
    DWORD   dmDisplayFlags;
    DWORD   dmDisplayFrequency;
} DEVMODE320A, *PDEVMODE320A, *NPDEVMODE320A, *LPDEVMODE320A;

typedef struct _devicemode320W {
    WCHAR   dmDeviceName[CCHDEVICENAME320];
    WORD    dmSpecVersion;
    WORD    dmDriverVersion;
    WORD    dmSize;
    WORD    dmDriverExtra;
    DWORD   dmFields;
    short   dmOrientation;
    short   dmPaperSize;
    short   dmPaperLength;
    short   dmPaperWidth;
    short   dmScale;
    short   dmCopies;
    short   dmDefaultSource;
    short   dmPrintQuality;
    short   dmColor;
    short   dmDuplex;
    short   dmYResolution;
    short   dmTTOption;
    short   dmCollate;
    WCHAR   dmFormName[CCHFORMNAME320];
    WORD    dmLogPixels;
    DWORD   dmBitsPerPel;
    DWORD   dmPelsWidth;
    DWORD   dmPelsHeight;
    DWORD   dmDisplayFlags;
    DWORD   dmDisplayFrequency;
} DEVMODE320W, *PDEVMODE320W, *NPDEVMODE320W, *LPDEVMODE320W;



#ifdef UNICODE

typedef DEVMODE320W     DEVMODE320;
typedef PDEVMODE320W    PDEVMODE320;
typedef NPDEVMODE320W   NPDEVMODE320;
typedef LPDEVMODE320W   LPDEVMODE320;

#else

typedef DEVMODE320A     DEVMODE320;
typedef PDEVMODE320A    PDEVMODE320;
typedef NPDEVMODE320A   NPDEVMODE320;
typedef LPDEVMODE320A   LPDEVMODE320;

#endif // UNICODE


typedef struct _DMEXTRA400 {
    DWORD  dmICMMethod;
    DWORD  dmICMIntent;
    DWORD  dmMediaType;
    DWORD  dmDitherType;
    DWORD  dmICCManufacturer;
    DWORD  dmICCModel;
} DMEXTRA400;


typedef struct _DMEXTRA401 {
    DWORD  dmPanningWidth;
    DWORD  dmPanningHeight;
} DMEXTRA401;


#define DM_SIZE320  sizeof(DEVMODE320)
#define DM_SIZE400  (DM_SIZE320 + sizeof(DMEXTRA400))
#define DM_SIZE401  (DM_SIZE400 + sizeof(DMEXTRA401))

// Current version devmode size - public portion only

#ifdef  UNICODE
#define DM_SIZE_CURRENT sizeof(DEVMODEW)
#else
#define DM_SIZE_CURRENT sizeof(DEVMODEA)
#endif



WORD
CheckDevmodeVersion(
    PDEVMODE pdm
    )

/*++

Routine Description:

    Verify dmSpecVersion and dmSize fields of a devmode

Arguments:

    pdm - Specifies a devmode to be version-checked

Return Value:

    0 if the input devmode is unacceptable
    Otherwise, return the expected dmSpecVersion value

--*/

{
    WORD    expectedVersion;

    if (pdm == NULL)
        return 0;

    // Check against known devmode sizes

    switch (pdm->dmSize) {

    case DM_SIZE320:
        expectedVersion = DM_SPECVERSION320;
        break;

    case DM_SIZE400:
        expectedVersion = DM_SPECVERSION400;
        break;

    case DM_SIZE401:
        expectedVersion = DM_SPECVERSION401;
        break;

    default:
        expectedVersion = pdm->dmSpecVersion;
        break;
    }


    return expectedVersion;
}



LONG
ConvertDevmode(
    PDEVMODE pdmIn,
    PDEVMODE pdmOut
    )

/*++

Routine Description:

    Convert an input devmode to a different version devmode.

    Whenever driver gets an input devmode, it should call this
    routine to convert it to current version.

Arguments:

    pdmIn - Points to an input devmode
    pdmOut - Points to an initialized/valid output devmode

Return Value:

    Total number of bytes copied
    -1 if either input or output devmode is invalid

--*/

{
    WORD    dmSpecVersion, dmDriverVersion;
    WORD    dmSize, dmDriverExtra;
    LONG    cbCopied = 0;

    // Look for inconsistency between dmSpecVersion and dmSize

    if (! CheckDevmodeVersion(pdmIn) ||
        ! (dmSpecVersion = CheckDevmodeVersion(pdmOut)))
    {
        return -1;
    }

    // Copy public devmode fields

    dmDriverVersion = pdmOut->dmDriverVersion;
    dmSize = pdmOut->dmSize;
    dmDriverExtra = pdmOut->dmDriverExtra;

    cbCopied = min(dmSize, pdmIn->dmSize);
    memcpy(pdmOut, pdmIn, cbCopied);

    pdmOut->dmSpecVersion = dmSpecVersion;
    pdmOut->dmDriverVersion = dmDriverVersion;
    pdmOut->dmSize = dmSize;
    pdmOut->dmDriverExtra = dmDriverExtra;

    // Copy private devmode fields

    cbCopied += min(dmDriverExtra, pdmIn->dmDriverExtra);
    memcpy((PBYTE) pdmOut + pdmOut->dmSize,
           (PBYTE) pdmIn + pdmIn->dmSize,
           min(dmDriverExtra, pdmIn->dmDriverExtra));

    return cbCopied;
}



#ifndef KERNEL_MODE

#include <windows.h>
#include <winspool.h>
#include <commctrl.h>
#include <winddiui.h>

BOOL
ConvertDevmodeOut(
    PDEVMODE pdmSrc,
    PDEVMODE pdmIn,
    PDEVMODE pdmOut,
	LONG lBufferSize
    )

/*++

Routine Description:

    Copy a source devmode to an output devmode buffer.

    Driver should call this routine before it returns to the caller
    of DrvDocumentProperties.

Arguments:

    pdmSrc - Points to a current version source devmode
    pdmIn - Points to input devmode passed to DrvDocumentProperties
    pdmOut - Output buffer pointer passed to DrvDocumentProperties
	lBufferSize - pdmOut size in BYTES.

Return Value:

    TRUE if successful, FALSE otherwise

--*/

{
    if (pdmIn == NULL)
	{
		if (lBufferSize < pdmSrc->dmSize + pdmSrc->dmDriverExtra)
		{
			return FALSE;
		}
        memcpy(pdmOut, pdmSrc, pdmSrc->dmSize + pdmSrc->dmDriverExtra);
        return TRUE;
    }
	else
	{
        // We have to deal with the public fields and private fields
        // separately. Also remember pdmIn and pdmOut may point to
        // the same buffer.

        // Public fields: take dmSpecVersion and dmSize from
        // the smaller of pdmSrc and pdmIn

        if (pdmIn->dmSize < pdmSrc->dmSize)
		{
            pdmOut->dmSpecVersion = pdmIn->dmSpecVersion;
            pdmOut->dmSize        = pdmIn->dmSize;
        }
		else
		{
            pdmOut->dmSpecVersion = pdmSrc->dmSpecVersion;
            pdmOut->dmSize        = pdmSrc->dmSize;
        }

        // Similarly for private fields

        if (pdmIn->dmDriverExtra < pdmSrc->dmDriverExtra)
		{
            pdmOut->dmDriverVersion = pdmIn->dmDriverVersion;
            pdmOut->dmDriverExtra   = pdmIn->dmDriverExtra;
        }
		else
		{
            pdmOut->dmDriverVersion = pdmSrc->dmDriverVersion;
            pdmOut->dmDriverExtra   = pdmSrc->dmDriverExtra;
        }

        return ConvertDevmode(pdmSrc, pdmOut) > 0;
    }
}



INT
CommonDrvConvertDevmode(
    PWSTR    pPrinterName,
    PDEVMODE pdmIn,
    PDEVMODE pdmOut,
    PLONG    pcbNeeded,
    DWORD    fMode,
    PDRIVER_VERSION_INFO pDriverVersions
    )

/*++

Routine Description:

    Library routine to handle common cases of DrvConvertDevMode

Arguments:

    pPrinterName, pdmIn, pdmOut, pcbNeeded, fMode
        Correspond to parameters passed to DrvConvertDevMode
    pDriverVersions - Specifies driver version numbers and private devmode sizes

Return Value:

    CDM_RESULT_TRUE
        If the case is handled by the library routine and driver
        shoud return TRUE to the caller of DrvConvertDevMode.

    CDM_RESULT_FALSE
        If the case is handled by the library routine and driver
        shoud return FALSE to the caller of DrvConvertDevMode.

    CDM_RESULT_NOT_HANDLED
        The case is NOT handled by the library routine and driver
        should continue on with whatever it needs to do.

--*/

{
    LONG    size;

    // Make sure pcbNeeded parameter is not NULL

    if (pcbNeeded == NULL) {

        SetLastError(ERROR_INVALID_PARAMETER);
        return CDM_RESULT_FALSE;
    }

    switch (fMode) {

    case CDM_CONVERT:

        // Convert any input devmode to any output devmode.
        // Both input and output must be valid.

        if (pdmOut != NULL &&
            *pcbNeeded >= (pdmOut->dmSize + pdmOut->dmDriverExtra) &&
            ConvertDevmode(pdmIn, pdmOut) > 0)
        {
            *pcbNeeded = pdmOut->dmSize + pdmOut->dmDriverExtra;
            return CDM_RESULT_TRUE;
        }
        break;

    case CDM_CONVERT351:

        // Convert any input devmode to 3.51 version devmode
        // First check if the caller provided buffer is large enough

        size = DM_SIZE320 + pDriverVersions->dmDriverExtra351;

        if (*pcbNeeded < size || pdmOut == NULL) {

            *pcbNeeded = size;
            SetLastError(ERROR_INSUFFICIENT_BUFFER);
            return CDM_RESULT_FALSE;
        }

        // Do the conversion from input devmode to 3.51 devmode

        pdmOut->dmSpecVersion = DM_SPECVERSION320;
        pdmOut->dmSize = DM_SIZE320;
        pdmOut->dmDriverVersion = pDriverVersions->dmDriverVersion351;
        pdmOut->dmDriverExtra = pDriverVersions->dmDriverExtra351;

        if (ConvertDevmode(pdmIn, pdmOut) > 0) {

            *pcbNeeded = size;
            return CDM_RESULT_TRUE;
        }

        break;

    case CDM_DRIVER_DEFAULT:

        // Convert any input devmode to current version devmode
        // First check if the caller provided buffer is large enough

        size = DM_SIZE_CURRENT + pDriverVersions->dmDriverExtra;

        if (*pcbNeeded < size || pdmOut == NULL) {

            *pcbNeeded = size;
            SetLastError(ERROR_INSUFFICIENT_BUFFER);
            return CDM_RESULT_FALSE;
        }

        // This case (getting driver-default devmode) is not handled
        // by the library routine.

        *pcbNeeded = size;

        // FALL THROUGH TO THE DEFAULT CASE!

    default:
        return CDM_RESULT_NOT_HANDLED;
    }

    SetLastError(ERROR_INVALID_PARAMETER);
    return CDM_RESULT_FALSE;
}

#endif // !KERNEL_MODE
=== C:/Users/treeman/Desktop/windows nt source code\Source\Win2K3\NT\printscan\faxsrv\print\faxprint\lib\faxdm.c ===
/*++

Copyright (c) 1996  Microsoft Corporation

Module Name:

    faxdm.c

Abstract:

    Functions for dealing with devmodes

Environment:

	Fax driver, user and kernel mode

Revision History:

	01/09/96 -davidx-
		Created it.

	mm/dd/yy -author-
		description

--*/

#include "faxlib.h"



VOID
DriverDefaultDevmode(
    PDRVDEVMODE pdm,
    LPTSTR      pDeviceName,
    HANDLE      hPrinter
    )

/*++

Routine Description:

    Return the driver's default devmode

Arguments:

    pdm - Specifies a buffer for storing driver default devmode
    pDeviceName - Points to device name string
    hPrinter - Handle to the printer object

Return Value:

    NONE

--*/

{
#ifndef KERNEL_MODE
    PDMPRIVATE dmPrivate;
    PDRVDEVMODE dmSource;    
#endif

	short DefualtPaperSize = DMPAPER_LETTER; // Letter
	LPTSTR lptstrDefualtPaperName = FORMNAME_LETTER; 


    //
    // Default value for public devmode fields
    //

    memset(pdm, 0, sizeof(DRVDEVMODE));

    if (pDeviceName == NULL)
        pDeviceName = DRIVER_NAME;

    CopyString(pdm->dmPublic.dmDeviceName, pDeviceName, CCHDEVICENAME);

    pdm->dmPublic.dmDriverVersion = DRIVER_VERSION;
    pdm->dmPublic.dmSpecVersion = DM_SPECVERSION;
    pdm->dmPublic.dmSize = sizeof(DEVMODE);
    pdm->dmPublic.dmDriverExtra = sizeof(DMPRIVATE);

    pdm->dmPublic.dmFields = DM_ORIENTATION  |
                             DM_PAPERSIZE    |
                             DM_FORMNAME     |                             
                             DM_PRINTQUALITY |
                             DM_YRESOLUTION  |
                             DM_DEFAULTSOURCE;

    pdm->dmPublic.dmOrientation = DMORIENT_PORTRAIT;    
    pdm->dmPublic.dmScale = 100;
    pdm->dmPublic.dmPrintQuality = FAXRES_HORIZONTAL;
    pdm->dmPublic.dmYResolution = FAXRES_VERTICAL;
    pdm->dmPublic.dmDuplex = DMDUP_SIMPLEX;    
    pdm->dmPublic.dmTTOption = DMTT_BITMAP;
    pdm->dmPublic.dmColor = DMCOLOR_MONOCHROME;
    pdm->dmPublic.dmDefaultSource = DMBIN_ONLYONE;

    if (hPrinter)
	{
		switch (GetPrinterDataDWord(hPrinter, PRNDATA_PAPER_SIZE, DMPAPER_LETTER))
		{
			case DMPAPER_A4:
				DefualtPaperSize = DMPAPER_A4;
				lptstrDefualtPaperName = FORMNAME_A4;
				break;

			case DMPAPER_LEGAL:
				DefualtPaperSize = DMPAPER_LEGAL;
				lptstrDefualtPaperName = FORMNAME_LEGAL;
				break;			
		}
	}

	pdm->dmPublic.dmPaperSize = DefualtPaperSize;
    CopyString(pdm->dmPublic.dmFormName, lptstrDefualtPaperName, CCHFORMNAME);
    

    //
    // Private devmode fields
    //
#ifdef KERNEL_MODE
    pdm->dmPrivate.signature = DRIVER_SIGNATURE;
    pdm->dmPrivate.flags = 0;
    pdm->dmPrivate.sendCoverPage = TRUE;
    pdm->dmPrivate.whenToSend = JSA_NOW;    
#else
    dmSource = (PDRVDEVMODE) GetPerUserDevmode(pDeviceName);
    if (!dmSource) {
        //
        // default values
        //
        pdm->dmPrivate.signature = DRIVER_SIGNATURE;
        pdm->dmPrivate.flags = 0;
        pdm->dmPrivate.sendCoverPage = TRUE;
        pdm->dmPrivate.whenToSend = JSA_NOW;    
    } else {
        dmPrivate = &dmSource->dmPrivate;
        pdm->dmPrivate.signature = dmPrivate->signature;//DRIVER_SIGNATURE;
        pdm->dmPrivate.flags = dmPrivate->flags;// 0;
        pdm->dmPrivate.sendCoverPage = dmPrivate->sendCoverPage; //TRUE;
        pdm->dmPrivate.whenToSend = dmPrivate->whenToSend;//JSA_NOW;
        pdm->dmPrivate.sendAtTime = dmPrivate->sendAtTime;
        CopyString(pdm->dmPrivate.billingCode,dmPrivate->billingCode,MAX_USERINFO_BILLING_CODE + 1);
        CopyString(pdm->dmPrivate.emailAddress,dmPrivate->emailAddress,MAX_EMAIL_ADDRESS);
        MemFree(dmSource);
    }
    
#endif
}



BOOL
MergeDevmode(
    PDRVDEVMODE pdmDest,
    PDEVMODE    pdmSrc,
    BOOL        publicOnly
    )

/*++

Routine Description:

    Merge the source devmode into the destination devmode

Arguments:

    pdmDest - Specifies the destination devmode
    pdmSrc - Specifies the source devmode
    publicOnly - Only merge public portion of the devmode

Return Value:

    TRUE if successful, FALSE if the source devmode is invalid

[Note:]

    pdmDest must point to a valid current-version devmode

--*/

#define BadDevmode(reason) { Error(("Invalid DEVMODE: %s\n", reason)); valid = FALSE; }

{
    PDEVMODE    pdmIn, pdmOut, pdmAlloced = NULL;
    PDMPRIVATE  pdmPrivate;
    BOOL        valid = TRUE;

    //
    // If there is no source devmode, levae destination devmode untouched
    //

    if ((pdmIn = pdmSrc) == NULL)
        return TRUE;

    //
    // Convert source devmode to current version if necessary
    //

    if (! CurrentVersionDevmode(pdmIn)) {

        Warning(("Converting non-current version DEVMODE ...\n"));
        
        if (! (pdmIn = pdmAlloced = MemAlloc(sizeof(DRVDEVMODE)))) {
    
            Error(("Memory allocation failed\n"));
            return FALSE;
        }
    
        Assert(pdmDest->dmPublic.dmSize == sizeof(DEVMODE) &&
               pdmDest->dmPublic.dmDriverExtra == sizeof(DMPRIVATE));
    
        memcpy(pdmIn, pdmDest, sizeof(DRVDEVMODE));
    
        if (ConvertDevmode(pdmSrc, pdmIn) <= 0) {
    
            Error(("ConvertDevmode failed\n"));
            MemFree(pdmAlloced);
            return FALSE;
        }
    }

    //
    // If the input devmode is the same as the driver default,
    // there is no need to merge it.
    //

    pdmPrivate = &((PDRVDEVMODE) pdmIn)->dmPrivate;

    if (pdmPrivate->signature == DRIVER_SIGNATURE &&
        (pdmPrivate->flags & FAXDM_DRIVER_DEFAULT))
    {
        Verbose(("Merging driver default devmode.\n"));
    }
    else
    {

        //
        // Merge source devmode into destination devmode
        //

        pdmOut = &pdmDest->dmPublic;

        //
        // Device name: Always the same as printer name
        //

        // CopyString(pdmOut->dmDeviceName, pdmIn->dmDeviceName, CCHDEVICENAME);

        //
        // Orientation
        //

        if (pdmIn->dmFields & DM_ORIENTATION) {

            if (pdmIn->dmOrientation == DMORIENT_PORTRAIT ||
                pdmIn->dmOrientation == DMORIENT_LANDSCAPE)
            {
                pdmOut->dmFields |= DM_ORIENTATION;
                pdmOut->dmOrientation = pdmIn->dmOrientation;

            } else
                BadDevmode("orientation");
        }

        //
        // Form selection
        //

        if (pdmIn->dmFields & DM_PAPERSIZE) {

            if (pdmIn->dmPaperSize >= DMPAPER_FIRST) {

                pdmOut->dmFields |= DM_PAPERSIZE;
                pdmOut->dmFields &= ~DM_FORMNAME;
                pdmOut->dmPaperSize = pdmIn->dmPaperSize;
                CopyString(pdmOut->dmFormName, pdmIn->dmFormName, CCHFORMNAME);

            } else
                BadDevmode("paper size");

        } else if (pdmIn->dmFields & DM_FORMNAME) {

            pdmOut->dmFields |= DM_FORMNAME;
            pdmOut->dmFields &= ~DM_PAPERSIZE;
            CopyString(pdmOut->dmFormName, pdmIn->dmFormName, CCHFORMNAME);
        }

        //
        // Paper source
        //

        if (pdmIn->dmFields & DM_DEFAULTSOURCE) {

            if (pdmIn->dmDefaultSource == DMBIN_ONLYONE) {

                pdmOut->dmFields |= DM_DEFAULTSOURCE;
                pdmOut->dmDefaultSource = pdmIn->dmDefaultSource;

            } else
                BadDevmode("paper source");
        }

        //
        // Print quality
        //

        if ((pdmIn->dmFields & DM_PRINTQUALITY) &&
            (pdmIn->dmPrintQuality != FAXRES_HORIZONTAL))
        {
            BadDevmode("print quality");
        }

        if (pdmIn->dmFields & DM_YRESOLUTION)
        {
            if (pdmIn->dmYResolution <= FAXRES_VERTDRAFT)
                pdmOut->dmYResolution = FAXRES_VERTDRAFT;
            else
                pdmOut->dmYResolution = FAXRES_VERTICAL;
        }

        //
        // Private devmode fields
        //

        Assert(pdmDest->dmPrivate.signature == DRIVER_SIGNATURE);

        if (pdmPrivate->signature == DRIVER_SIGNATURE) {

            if (! publicOnly)
                memcpy(&pdmDest->dmPrivate, pdmPrivate, sizeof(DMPRIVATE));

        } else
            BadDevmode("bad signature");
    }

    pdmDest->dmPrivate.flags &= ~FAXDM_DRIVER_DEFAULT;
    MemFree(pdmAlloced);
    return valid;
}
=== C:/Users/treeman/Desktop/windows nt source code\Source\Win2K3\NT\printscan\faxsrv\print\faxprint\lib\halftone.c ===
/*++

Copyright (c) 1990-1993  Microsoft Corporation


Module Name:

    halftone.c


Abstract:

    This module contains data and function to validate the COLORADJUSTMENT


Author:

    27-Oct-1995 Fri 15:48:17 created  -by-  Daniel Chou (danielc)


[Environment:]

    GDI Device Driver - Plotter.


[Notes:]


Revision History:


--*/



#ifdef NTGDIKM
#include        <stddef.h>
#include        <stdarg.h>
#include        <windef.h>
#include        <wingdi.h>
#include        <winddi.h>
#else
#include        <stddef.h>
#include        <windows.h>
#include        <winddi.h>
#endif

DEVHTINFO    DefDevHTInfo = {

        HT_FLAG_HAS_BLACK_DYE,
        HT_PATSIZE_6x6_M,
        0,                                  // DevPelsDPI

        {
            { 6380, 3350,       0 },        // xr, yr, Yr
            { 2345, 6075,       0 },        // xg, yg, Yg
            { 1410,  932,       0 },        // xb, yb, Yb
            { 2000, 2450,       0 },        // xc, yc, Yc Y=0=HT default
            { 5210, 2100,       0 },        // xm, ym, Ym
            { 4750, 5100,       0 },        // xy, yy, Yy
            { 3127, 3290,       0 },        // xw, yw, Yw=0=default

            12500,                          // R gamma
            12500,                          // G gamma
            12500,                          // B gamma, 12500=Default

            585,   120,                     // M/C, Y/C
              0,     0,                     // C/M, Y/M
              0, 10000                      // C/Y, M/Y  10000=default
        }
    };


COLORADJUSTMENT  DefHTClrAdj = {

        sizeof(COLORADJUSTMENT),
        0,
        ILLUMINANT_DEVICE_DEFAULT,
        10000,
        10000,
        10000,
        REFERENCE_BLACK_MIN,
        REFERENCE_WHITE_MAX,
        0,
        0,
        0,
        0
    };
=== C:/Users/treeman/Desktop/windows nt source code\Source\Win2K3\NT\printscan\faxsrv\print\faxprint\lib\kmfuncs.c ===
/*++

Copyright (c) 1996  Microsoft Corporation

Module Name:

    kmfuncs.c

Abstract:

    Kernel-mode specific library functions

Environment:

    Fax driver, kernel mode

Revision History:

    01/09/96 -davidx-
        Created it.

    mm/dd/yy -author-
        description

--*/

#include "faxlib.h"



#if DBG

//
// Variable to control the amount of debug messages generated
//

INT _debugLevel = 0;


#ifndef USERMODE_DRIVER

//
// Functions for outputting debug messages
//

ULONG __cdecl
DbgPrint(
    CHAR *  format,
    ...
    )

{
    va_list ap;

    va_start(ap, format);
    EngDebugPrint("", format, ap);
    va_end(ap);

    return 0;
}

#endif // !USERMODE_DRIVER
#endif // DBG
=== C:/Users/treeman/Desktop/windows nt source code\Source\Win2K3\NT\printscan\faxsrv\print\faxprint\lib\forms.c ===
/*++

Copyright (c) 1996  Microsoft Corporation

Module Name:

    forms.c

Abstract:

    Functions for manipulating forms

Environment:

    Fax driver, user and kernel mode

Revision History:

    01/09/96 -davidx-
        Created it.

    mm/dd/yy -author-
        description

--*/

#include "faxlib.h"
#include "forms.h"


BOOL
ValidDevmodeForm(
    HANDLE       hPrinter,
    PDEVMODE     pdm,
    PFORM_INFO_1 pFormInfo
    )

/*++

Routine Description:

    Validate the form specification in a devmode

Arguments:

    hPrinter - Handle to the printer object
    pdm - Pointer to the input devmode
    pFormInfo - FORM_INFO_1 structure for returning form information

Return Value:

    TRUE if the input devmode specifies a valid logical form
    FALSE otherwise

--*/

{
    PFORM_INFO_1 pForm, pFormDB;
    DWORD        cForms;

    //
    // Get a list of forms in the system
    //

    if (! (pForm = pFormDB = GetFormsDatabase(hPrinter, &cForms))) {

        Error(("Couldn't get system forms\n"));
        return FALSE;
    }

    if ((pdm->dmFields & DM_PAPERSIZE) && pdm->dmPaperSize >= DMPAPER_FIRST) {

        //
        // Devmode is specifying a form using paper size index
        //

        DWORD index = pdm->dmPaperSize - DMPAPER_FIRST;

        if (index < cForms)
            pForm = pFormDB + index;
        else
            pForm = NULL;

    } else if (pdm->dmFields & DM_FORMNAME) {

        //
        // Devmode is specifying a form using form name: go through the forms database
        // and check if the requested form name matches that of a form in the database
        //

        while (cForms && _tcsicmp(pForm->pName, pdm->dmFormName) != EQUAL_STRING) {

            pForm++;
            cForms--;
        }

        if (cForms == 0)
            pForm = NULL;
    }

    if (pForm && IsSupportedForm(pForm)) {

        if (pFormInfo)
            *pFormInfo = *pForm;

        //
        // Convert paper size unit from microns to 0.1mm
        //

        pdm->dmPaperWidth = (SHORT)(pForm->Size.cx / 100);
        pdm->dmPaperLength = (SHORT)(pForm->Size.cy / 100);

        if ((pdm->dmFields & DM_FORMNAME) == 0) {

            pdm->dmFields |= DM_FORMNAME;
            CopyString(pdm->dmFormName, pForm->pName, CCHFORMNAME);
        }
    }
    else
    {
        //
        // The form is not supported
        //
        pForm = NULL;
    }

    MemFree(pFormDB);
    return pForm != NULL;
}



PFORM_INFO_1
GetFormsDatabase(
    HANDLE  hPrinter,
    PDWORD  pCount
    )

/*++

Routine Description:

    Return a collection of forms in the spooler database

Arguments:

    hPrinter - Handle to a printer object
    pCount - Points to a variable for returning total number of forms

Return Value:

    Pointer to an array of FORM_INFO_1 structures if successful
    NULL otherwise

--*/

{
    PFORM_INFO_1 pFormDB = NULL;
    DWORD        cb=0;

    if (!EnumForms(hPrinter, 1, NULL, 0, &cb, pCount) &&
        GetLastError() == ERROR_INSUFFICIENT_BUFFER &&
        (pFormDB = MemAlloc(cb)) != NULL &&
        EnumForms(hPrinter, 1, (PBYTE) pFormDB, cb, &cb, pCount))
    {
        PFORM_INFO_1 pForm;
        DWORD        count;
        LONG         maxX, maxY;

        //
        // Calculate the maximum allowable form width and height (in microns)
        //

        maxX = MulDiv(MAX_WIDTH_PIXELS, 25400, FAXRES_HORIZONTAL);
        maxY = MulDiv(MAX_HEIGHT_PIXELS, 25400, FAXRES_VERTICAL);

        for (count=*pCount, pForm=pFormDB; count--; pForm++) {

            //
            // Make sure the highest order bits are not used by the spooler
            //

            Assert(! IsSupportedForm(pForm));

            //
            // Determine if the form in question is supported on the device
            //

            if (pForm->ImageableArea.right - pForm->ImageableArea.left <= maxX &&
                pForm->ImageableArea.bottom - pForm->ImageableArea.top <= maxY)
            {
                SetSupportedForm(pForm);
            }
        }

        return pFormDB;
    }

    Error(("EnumForms failed\n"));
    MemFree(pFormDB);
    return NULL;
}
=== C:/Users/treeman/Desktop/windows nt source code\Source\Win2K3\NT\printscan\faxsrv\print\faxprint\lib\prndata.c ===
/*++

Copyright (c) 1996  Microsoft Corporation

Module Name:

    prndata.c

Abstract:

    Functions for accessing printer property data in the registry

Environment:

	Fax driver, user and kernel mode

Revision History:

	01/09/96 -davidx-
		Created it.

	mm/dd/yy -author-
		description

--*/

#include "faxlib.h"



DWORD
GetPrinterDataDWord(
    HANDLE  hPrinter,
    LPTSTR  pRegKey,
    DWORD   defaultValue
    )

/*++

Routine Description:

    Retrieve a DWORD value under PrinterData registry key

Arguments:

    hPrinter - Specifies the printer in question
    pRegKey - Specifies the name of registry value
    defaultValue - Specifies the default value to be used if no data exists in registry

Return Value:

    Current value for the requested registry key

--*/

{
    DWORD   dwValue = defaultValue ;	//  prevents returning invalid value even if GetPrinterData(...) fails to initialize it
	DWORD	type;						//	the type of data retrieved
	DWORD	cb;							//  the size, in bytes, of the configuration data

    if (GetPrinterData(hPrinter,
                       pRegKey,
                       &type,
                       (PBYTE) &dwValue,
                       sizeof(dwValue),
                       &cb) == ERROR_SUCCESS)
    {
        return dwValue;
    }

    return defaultValue;
}



PVOID
MyGetPrinter(
    HANDLE  hPrinter,
    DWORD   level
    )

/*++

Routine Description:

    Wrapper function for GetPrinter spooler API

Arguments:

    hPrinter - Identifies the printer in question
    level - Specifies the level of PRINTER_INFO_x structure requested

Return Value:

    Pointer to a PRINTER_INFO_x structure, NULL if there is an error

--*/

{
    PBYTE   pPrinterInfo = NULL;
    DWORD   cbNeeded;

    if (!GetPrinter(hPrinter, level, NULL, 0, &cbNeeded) &&
        GetLastError() == ERROR_INSUFFICIENT_BUFFER &&
        (pPrinterInfo = MemAlloc(cbNeeded)) &&
        GetPrinter(hPrinter, level, pPrinterInfo, cbNeeded, &cbNeeded))
    {
        return pPrinterInfo;
    }

    Error(("GetPrinter failed: %d\n", GetLastError()));
    MemFree(pPrinterInfo);
    return NULL;
}



#ifndef KERNEL_MODE


BOOL
SetPrinterDataDWord(
    HANDLE  hPrinter,
    LPTSTR  pRegKey,
    DWORD   value
    )

/*++

Routine Description:

    Save a DWORD value under PrinterData registry key

Arguments:

    hPrinter - Specifies the printer in question
    pRegKey - Specifies the name of registry value
    value - Specifies the value to be saved

Return Value:

    TRUE if successful, FALSE otherwise

--*/

{
    if (SetPrinterData(hPrinter,
                       pRegKey,
                       REG_DWORD,
                       (PBYTE) &value,
                       sizeof(value)) != ERROR_SUCCESS)
    {
        Error(("Couldn't save registry key %ws: %d\n", pRegKey, GetLastError()));
        return FALSE;
    }

    return TRUE;
}



PVOID
MyGetPrinterDriver(
    HANDLE      hPrinter,
    DWORD       level
    )

/*++

Routine Description:

    Wrapper function for GetPrinterDriver spooler API

Arguments:

    hPrinter - Identifies the printer in question
    level - Specifies the level of DRIVER_INFO_x structure requested

Return Value:

    Pointer to a DRIVER_INFO_x structure, NULL if there is an error

--*/

{
    PBYTE   pDriverInfo = NULL;
    DWORD   cbNeeded;

    if (!GetPrinterDriver(hPrinter, NULL, level, NULL, 0, &cbNeeded) &&
        GetLastError() == ERROR_INSUFFICIENT_BUFFER &&
        (pDriverInfo = MemAlloc(cbNeeded)) &&
        GetPrinterDriver(hPrinter, NULL, level, pDriverInfo, cbNeeded, &cbNeeded))
    {
        return pDriverInfo;
    }

    Error(("GetPrinterDriver failed: %d\n", GetLastError()));
    MemFree(pDriverInfo);
    return NULL;
}



LPTSTR
MyGetPrinterDriverDirectory(
    LPTSTR  pServerName,
    LPTSTR  pEnvironment
    )

/*++

Routine Description:

    Wrapper function for GetPrinterDriverDirectory spooler API

Arguments:

    pServerName - Specifies the name of the print server, NULL for local machine
    pEnvironment - Specifies the processor architecture

Return Value:

    Pointer to the printer driver directory on the specified print server
    NULL if there is an error

--*/

{
    PVOID   pDriverDir = NULL;
    DWORD   cb;
    
    if (! GetPrinterDriverDirectory(pServerName, pEnvironment, 1, NULL, 0, &cb) &&
        GetLastError() == ERROR_INSUFFICIENT_BUFFER &&
        (pDriverDir = MemAlloc(cb)) &&
        GetPrinterDriverDirectory(pServerName, pEnvironment, 1, pDriverDir, cb, &cb))
    {
        return pDriverDir;
    }

    Error(("GetPrinterDriverDirectory failed: %d\n", GetLastError()));
    MemFree(pDriverDir);
    return NULL;
}

#endif // !KERNEL_MODE
=== C:/Users/treeman/Desktop/windows nt source code\Source\Win2K3\NT\printscan\faxsrv\print\faxprint\lib\registry.c ===
/*++

Copyright (c) 1996  Microsoft Corporation

Module Name:

    registry.c

Abstract:

    Functions for accessing registry information under:
        HKEY_CURRENT_USER and HKEY_LOCAL_MACHINE

Environment:

        Windows XP fax driver user interface

Revision History:

        01/29/96 -davidx-
                Created it.

        mm/dd/yy -author-
                description

--*/

#include "faxlib.h"
#include "registry.h"



typedef BOOL (FAR WINAPI SHGETSPECIALFOLDERPATH)(
    HWND hwndOwner,
    LPTSTR lpszPath,
    int nFolder,
    BOOL fCreate
);

typedef SHGETSPECIALFOLDERPATH FAR *PSHGETSPECIALFOLDERPATH;


PDEVMODE
GetPerUserDevmode(
    LPTSTR  pPrinterName
    )

/*++

Routine Description:

    Get per-user devmode information for the specified printer

Arguments:

    pPrinterName - Specifies the name of the printer we're interested in

Return Value:

    Pointer to per-user devmode information read from the registry

--*/

{
    PVOID  pDevmode = NULL;
    HANDLE hPrinter;
    PPRINTER_INFO_2 pPrinterInfo=NULL;

    //
    // Make sure the printer name is valid
    //

    Assert (pPrinterName);

    //
    // Open the printer
    //
    if (!OpenPrinter(pPrinterName,&hPrinter,NULL) )
    {
        return NULL;
    }

    pPrinterInfo = MyGetPrinter(hPrinter,2);
    if (!pPrinterInfo || !pPrinterInfo->pDevMode)
    {
        MemFree(pPrinterInfo);
        ClosePrinter(hPrinter);
        return NULL;
    }

    pDevmode = MemAlloc(sizeof(DRVDEVMODE) );

    if (!pDevmode)
    {
        MemFree(pPrinterInfo);
        ClosePrinter(hPrinter);
        return NULL;
    }

    CopyMemory((PVOID) pDevmode,
               (PVOID) pPrinterInfo->pDevMode,
                sizeof(DRVDEVMODE) );

    MemFree( pPrinterInfo );
    ClosePrinter( hPrinter );

    return pDevmode;
}


LPTSTR
GetUserCoverPageDir(
    VOID
    )
{
    LPTSTR  CpDir = NULL;
    DWORD   dwBufferSize = MAX_PATH * sizeof(TCHAR);
    
    if (!(CpDir = MemAlloc(dwBufferSize)))
    {
        Error(("MemAlloc failed\n"));
        CpDir = NULL;
        return CpDir;
    }

    if(!GetClientCpDir(CpDir, dwBufferSize / sizeof (TCHAR)))
    {
        Error(("GetClientCpDir failed\n"));
        MemFree(CpDir);
        CpDir = NULL;
        return CpDir;
    }

    return CpDir;
}
=== C:/Users/treeman/Desktop/windows nt source code\Source\Win2K3\NT\printscan\faxsrv\print\faxprint\lib\runtime.c ===
/*++

Copyright (c) 1996  Microsoft Corporation

Module Name:

    runtime.c

Abstract:

    Implementation of runtime library functions

Environment:

    Fax driver, kernel and user mode

Revision History:

    01/09/96 -davidx-
        Created it.

    mm/dd/yy -author-
        description

--*/

#include "faxlib.h"



VOID
CopyStringW(
    PWSTR   pDest,
    PWSTR   pSrc,
    INT     destSize
    )

/*++

Routine Description:

    Copy Unicode string from source to destination

Arguments:

    pDest - Points to the destination buffer
    pSrc - Points to source string
    destSize - Size of destination buffer (in characters)

Return Value:

    NONE

Note:

    If the source string is shorter than the destination buffer,
    unused chars in the destination buffer is filled with NUL.

--*/

{
    PWSTR pEnd;

    Assert(pDest != NULL && pSrc != NULL && destSize > 0);

    pEnd = pDest + (destSize - 1);

    while (pDest < pEnd && (*pDest++ = *pSrc++) != NUL)
        ;

    while (pDest <= pEnd)
        *pDest++ = NUL;
}



VOID
CopyStringA(
    PSTR    pDest,
    PSTR    pSrc,
    INT     destSize
    )

/*++

Routine Description:

    Copy Ansi string from source to destination

Arguments:

    pDest - Points to the destination buffer
    pSrc - Points to source string
    destSize - Size of destination buffer (in characters)

Return Value:

    NONE

Note:

    If the source string is shorter than the destination buffer,
    unused chars in the destination buffer is filled with NUL.

--*/

{
    PSTR pEnd;

    Assert(pDest != NULL && pSrc != NULL && destSize > 0);

    pEnd = pDest + (destSize - 1);

    while (pDest < pEnd && (*pDest++ = *pSrc++) != NUL)
        ;

    while (pDest <= pEnd)
        *pDest++ = NUL;
}



LPTSTR
DuplicateString(
    LPCTSTR pSrcStr
    )

/*++

Routine Description:

    Make a duplicate of the given character string

Arguments:

    pSrcStr - Specifies the string to be duplicated

Return Value:

    Pointer to the duplicated string, NULL if there is an error

--*/

{
    LPTSTR  pDestStr;
    INT     strSize;

    if (pSrcStr != NULL) {

        strSize = SizeOfString(pSrcStr);

        if (pDestStr = MemAlloc(strSize))
            CopyMemory(pDestStr, pSrcStr, strSize);
        else
            Error(("Memory allocation failed\n"));

    } else
        pDestStr = NULL;

    return pDestStr;
}



PCSTR
StripDirPrefixA(
    PCSTR   pFilename
    )

/*++

Routine Description:

    Strip the directory prefix off a filename (ANSI version)

Arguments:

    pFilename   Pointer to filename string

Return Value:

    Pointer to the last component of a filename (without directory prefix)

--*/

{
    LPCSTR  pstr;

    if (pstr = strrchr(pFilename, FAX_PATH_SEPARATOR_CHR))
        return pstr + 1;

    return pFilename;
}
=== C:/Users/treeman/Desktop/windows nt source code\Source\Win2K3\NT\printscan\faxsrv\print\faxprint\lib\sources.inc ===
!IF 0

Copyright (c) 1996  Microsoft Corporation

!ENDIF

PRINTERS=$(BASEDIR)\private\ntos\w32\ntgdi\printers

!ifndef NOUNICODE

C_DEFINES=$(C_DEFINES) -DVERSION_4_71


!endif

SOURCES=..\runtime.c    \
        ..\faxdm.c      \
        ..\forms.c      \
        ..\prndata.c    \
        ..\devmode.c    \
        ..\halftone.c
=== C:/Users/treeman/Desktop/windows nt source code\Source\Win2K3\NT\printscan\faxsrv\print\faxprint\prnwzrd\abobj.cpp ===
/*++

Copyright (c) 1997  Microsoft Corporation

Module Name:

    abobj.cpp

Abstract:

    Interface to the common address book.

Environment:

        Fax send wizard

Revision History:

        09/02/99 -v-sashab-
                Created it.

        mm/dd/yy -author-
                description

--*/

#include <windows.h>
#include <prsht.h>
#include <tchar.h>
#include <assert.h>
#include <mbstring.h>

#include <mapix.h>

#include "faxui.h"
#include "abobj.h"


#define PR_EMS_AB_PROXY_ADDRESSES            PROP_TAG( PT_MV_TSTRING,    0x800F)
#define PR_EMS_AB_PROXY_ADDRESSES_A          PROP_TAG( PT_MV_STRING8,    0x800F)
#define PR_EMS_AB_PROXY_ADDRESSES_W          PROP_TAG( PT_MV_UNICODE,    0x800F)

static SizedSPropTagArray(10, sPropTagsW) =
{
    10,
    {
        PR_ADDRTYPE_W,
        PR_EMAIL_ADDRESS_W,
        PR_DISPLAY_NAME_W,
        PR_PRIMARY_FAX_NUMBER_W,
        PR_HOME_FAX_NUMBER_W,
        PR_BUSINESS_FAX_NUMBER_W,
        PR_COUNTRY_W,
        PR_OBJECT_TYPE,
        PR_EMS_AB_PROXY_ADDRESSES_W,
        PR_ENTRYID
    }
};

static SizedSPropTagArray(10, sPropTagsA) =
{
    10,
    {
        PR_ADDRTYPE_A,
        PR_EMAIL_ADDRESS_A,
        PR_DISPLAY_NAME_A,
        PR_PRIMARY_FAX_NUMBER_A,
        PR_HOME_FAX_NUMBER_A,
        PR_BUSINESS_FAX_NUMBER_A,
        PR_COUNTRY_A,
        PR_OBJECT_TYPE,
        PR_EMS_AB_PROXY_ADDRESSES_A,
        PR_ENTRYID
    }
};

HINSTANCE   CCommonAbObj::m_hInstance = NULL;


/*
    Comparison operator 'less'
    Compare two PRECIPIENT by recipient's name and fax number
*/
bool 
CRecipCmp::operator()(
    const PRECIPIENT pcRecipient1, 
    const PRECIPIENT pcRecipient2) const
{
    bool bRes = false;
    int  nFaxNumberCpm = 0;

    if(!pcRecipient1 ||
       !pcRecipient2 ||
       !pcRecipient1->pAddress || 
       !pcRecipient2->pAddress)
    {
        assert(false);
        return bRes;
    }

    nFaxNumberCpm = _tcscmp(pcRecipient1->pAddress, pcRecipient2->pAddress);

    if(nFaxNumberCpm < 0)
    {
        bRes = true;
    }
    else if(nFaxNumberCpm == 0)
    {
        //
        // The fax numbers are same
        // lets compare the names
        //
        if(pcRecipient1->pName && pcRecipient2->pName)
        {
            bRes = (_tcsicmp(pcRecipient1->pName, pcRecipient2->pName) < 0);
        }
        else
        {
            bRes = (pcRecipient1->pName < pcRecipient2->pName);
        }
    }

    return bRes;

} // CRecipCmp::operator()


CCommonAbObj::CCommonAbObj(HINSTANCE hInstance) : 
    m_lpAdrBook(NULL), 
    m_lpMailUser(NULL),
    m_bUnicode(FALSE)
/*++

Routine Description:

    Constructor for CCommonAbObj class

Arguments:

    hInstance - Instance handle

Return Value:

    NONE

--*/

{
    m_hInstance = hInstance;

} // CCommonAbObj::CCommonAbObj()

CCommonAbObj::~CCommonAbObj()
/*++

Routine Description:

    Destructor for CCommonAbObj class

Arguments:

    NONE

Return Value:

    NONE

--*/
{
}


BOOL
CCommonAbObj::Address(
    HWND        hWnd,
    PRECIPIENT  pOldRecipList,
    PRECIPIENT* ppNewRecipList
    )
/*++

Routine Description:

    Bring up the address book UI.  Prepopulate the to box with the entries in
    pRecipient.  Return the modified entries in ppNewRecip.

Arguments:

    hWnd            - window handle to parent window
    pOldRecipList   - list of recipients to look up
    ppNewRecipList  - list of new/modified recipients

Return Value:

    TRUE if all recipients had a fax number.
    FALSE if one or more of them didn't.

--*/
{
    ADRPARM AdrParms = { 0 };
    HRESULT hr;
    DWORD i;
    DWORD nRecips;
    PRECIPIENT tmpRecipient;
    ULONG DestComps[1] = { MAPI_TO };
    DWORD cDropped = 0;
    DWORD dwRes = ERROR_SUCCESS;
    TCHAR tszCaption[MAX_PATH] = {0};

    nRecips = 0;
    tmpRecipient = pOldRecipList;

    m_hWnd = hWnd;

    //
    // count recipients and set up initial address list
    //
    while (tmpRecipient) 
    {
        nRecips++;
        tmpRecipient = (PRECIPIENT) tmpRecipient->pNext;
    }

    //
    // Allocate address list
    //
    m_lpAdrList = NULL;
    if (nRecips > 0) 
    {
        hr = ABAllocateBuffer( CbNewADRLIST( nRecips ), (LPVOID *) &m_lpAdrList );
        if(!m_lpAdrList)
        {
            goto exit;
        }
        ZeroMemory(m_lpAdrList, CbNewADRLIST( nRecips )); 

        m_lpAdrList->cEntries = nRecips;
    } 

    //
    // Allocate SPropValue arrays for each address entry
    //
    for (i = 0, tmpRecipient = pOldRecipList; i < nRecips; i++, tmpRecipient = tmpRecipient->pNext) 
    {
        if(!GetRecipientProps(tmpRecipient,
                              &(m_lpAdrList->aEntries[i].rgPropVals),
                              &(m_lpAdrList->aEntries[i].cValues)))
        {
            goto error;
        }

    } // for

    if(GetAddrBookCaption(tszCaption, ARR_SIZE(tszCaption)))
    {
        AdrParms.lpszCaption = tszCaption;
    }

    AdrParms.cDestFields = 1; 
    AdrParms.ulFlags = StrCoding() | DIALOG_MODAL | AB_RESOLVE;
    AdrParms.nDestFieldFocus = 0;
    AdrParms.lpulDestComps = DestComps;

    //
    // Bring up the address book UI
    //
    hr = m_lpAdrBook->Address((ULONG_PTR*)&hWnd,
                              &AdrParms,
                              &m_lpAdrList);

    //
    // IAddrBook::Address returns always S_OK (according to MSDN, July 1999), but ...
    //
    if (FAILED (hr) || !m_lpAdrList || m_lpAdrList->cEntries == 0) 
    {
        //
        // in this case the user pressed cancel, so we skip resolving 
        // any of our addresses that aren't listed in the AB
        //
        goto exit;
    }

exit:
    if (m_lpAdrList) 
    {
        m_lpMailUser = NULL;

        try
        {
            m_setRecipients.clear();
        }
        catch (std::bad_alloc&)
        {
            goto error;
        }

        for (i = cDropped = 0; i < m_lpAdrList->cEntries; i++) 
        {
            LPADRENTRY lpAdrEntry = &m_lpAdrList->aEntries[i];

            dwRes = InterpretAddress(lpAdrEntry->rgPropVals, 
                                     lpAdrEntry->cValues, 
                                     ppNewRecipList,
                                     pOldRecipList);
            if(ERROR_SUCCESS == dwRes)
            {
                continue;
            }
            else if(ERROR_INVALID_DATA == dwRes)
            {
                ++cDropped;
            }
            else
            {
                break;
            }
        } // for

error:
        if(m_lpMailUser)
        {
            m_lpMailUser->Release();
            m_lpMailUser = NULL;
        }

        //
        // Clean up
        //        
        for (ULONG iEntry = 0; iEntry < m_lpAdrList->cEntries; ++iEntry)
        {
            if(m_lpAdrList->aEntries[iEntry].rgPropVals)
            {
                ABFreeBuffer(m_lpAdrList->aEntries[iEntry].rgPropVals);
            }
        }
        ABFreeBuffer(m_lpAdrList);
        m_lpAdrList = NULL;

    } // if (m_lpAdrList) 

    m_hWnd = NULL;

    return cDropped == 0;

} // CCommonAbObj::Address


BOOL
CCommonAbObj::GetRecipientProps(
    PRECIPIENT    pRecipient,
    LPSPropValue* pMapiProps,
    DWORD*        pdwPropsNum
)
/*++

Routine Description:

    Allocate SPropValue array and fill it with recipient info
    According to MSDN "Managing Memory for ADRLIST and SRowSet Structures"

Arguments:

    pRecipient   - [in]  recipient info struct 
    pMapiProps   - [out] allocated SPropValue array
    pdwPropsNum  - [out] SPropValue array size

Return Value:

    TRUE if success
    FALSE otherwize

--*/
{
    BOOL bRes = FALSE;

    if(!pRecipient || !pMapiProps || !pdwPropsNum)
    {
        return FALSE;
    }

    HRESULT         hr;
    LPTSTR          pName = NULL;
    DWORD           dwNameSize=0;        // size of pName
    LPTSTR          pAddress = NULL;
    DWORD           dwAddressSize=0;     // size of pAddress
    LPENTRYID       lpEntryId = NULL;
    ULONG           cbEntryId = 0;       // size of lpEntryId
    UINT            ucPropertiesNum = pRecipient->bFromAddressBook ? 5 : 4;

    enum FaxMapiProp { FXS_DISPLAY_NAME, 
                       FXS_RECIPIENT_TYPE,
                       FXS_PRIMARY_FAX_NUMBER,
                       FXS_ENTRYID,
                       FXS_OBJECT_TYPE 
                     };


    //
    // Convert strings to the address book encoding
    //
    if(pRecipient->pAddress)        
    {
        pAddress = StrToAddrBk(pRecipient->pAddress, &dwAddressSize);
        if(!pAddress)
        {
            goto exit;
        }
    }

    if(pRecipient->pName)
    {
        pName = StrToAddrBk(pRecipient->pName, &dwNameSize);
        if(!pName)
        {
            goto exit;
        }
    }

    //
    // Get entry ID
    //
    if (pRecipient->bFromAddressBook)
    {
        assert(pRecipient->lpEntryId);
        lpEntryId = (LPENTRYID)pRecipient->lpEntryId;
        cbEntryId = pRecipient->cbEntryId;
    }
    else
    {
        LPTSTR pAddrType = NULL;
        if(!(pAddrType = StrToAddrBk(TEXT("FAX"))))
        {
            goto exit;
        }
        hr = m_lpAdrBook->CreateOneOff(pName,
                                       pAddrType,
                                       pAddress,
                                       StrCoding(),
                                       &cbEntryId,
                                       &lpEntryId);
        if (FAILED(hr))
        {
            goto exit;
        } 
        MemFree(pAddrType);
    }

    //
    // Allocate MAPI prop array
    //
    LPSPropValue mapiProps = NULL;  

    DWORD dwPropArrSize = sizeof( SPropValue ) * ucPropertiesNum;
    DWORD dwPropSize = dwPropArrSize + dwAddressSize + dwNameSize + cbEntryId;

    hr = ABAllocateBuffer( dwPropSize, (LPVOID *) &mapiProps );
    if(!mapiProps)
    {
        goto exit;
    }
    ZeroMemory(mapiProps, dwPropSize); 

    //
    // Set memory pointer to the end of the SPropValue prop array
    //
    LPBYTE pMem = (LPBYTE)mapiProps;
    pMem += dwPropArrSize;

    //
    // Copy fax number
    //
    if(dwAddressSize)
    {
        CopyMemory(pMem, pAddress, dwAddressSize);
        if(m_bUnicode)
        {
            mapiProps[FXS_PRIMARY_FAX_NUMBER].Value.lpszW = (LPWSTR)pMem;
        }
        else
        {
            mapiProps[FXS_PRIMARY_FAX_NUMBER].Value.lpszA = (LPSTR)pMem;
        }
        pMem += dwAddressSize;
    }
    mapiProps[FXS_PRIMARY_FAX_NUMBER].ulPropTag = m_bUnicode ? PR_PRIMARY_FAX_NUMBER_W : PR_PRIMARY_FAX_NUMBER_A;

    //
    // Copy display name
    //
    if(dwNameSize)
    {
        CopyMemory(pMem, pName, dwNameSize);
        if(m_bUnicode)
        {
            mapiProps[FXS_DISPLAY_NAME].Value.lpszW = (LPWSTR)pMem;
        }
        else
        {
            mapiProps[FXS_DISPLAY_NAME].Value.lpszA = (LPSTR)pMem;
        }
        pMem += dwNameSize;
    }
    mapiProps[FXS_DISPLAY_NAME].ulPropTag = m_bUnicode ? PR_DISPLAY_NAME_W : PR_DISPLAY_NAME_A;

    //
    // Copy entry ID
    //
    if(cbEntryId)
    {
        CopyMemory(pMem, lpEntryId, cbEntryId);
        mapiProps[FXS_ENTRYID].Value.bin.lpb = (LPBYTE)pMem;
    }
    mapiProps[FXS_ENTRYID].ulPropTag = PR_ENTRYID;
    mapiProps[FXS_ENTRYID].Value.bin.cb = cbEntryId;

    //
    // Recipient type
    //
    mapiProps[FXS_RECIPIENT_TYPE].ulPropTag = PR_RECIPIENT_TYPE;
    mapiProps[FXS_RECIPIENT_TYPE].Value.l = MAPI_TO;


    //
    // Object type
    //
    if (pRecipient->bFromAddressBook)
    {
        mapiProps[FXS_OBJECT_TYPE].ulPropTag = PR_OBJECT_TYPE;
        mapiProps[FXS_OBJECT_TYPE].Value.l   = MAPI_MAILUSER;
    }


    *pdwPropsNum = ucPropertiesNum;  
    *pMapiProps = mapiProps;

    bRes = TRUE;

exit:

    MemFree(pName);
    MemFree(pAddress);

    if (!pRecipient->bFromAddressBook && lpEntryId)
    {
        ABFreeBuffer(lpEntryId);
    }

    return bRes;

} // CCommonAbObj::GetRecipientProps

LPTSTR
CCommonAbObj::AddressEmail(
    HWND hWnd
    )
/*++

Routine Description:

    Bring up the address book UI.  Returns an E-mail address.

Arguments:

    hWnd - window handle to parent window

Return Value:

    A choosen E-mail address.
    NULL otherwise.

--*/
{
    ADRPARM AdrParms = { 0 };
    HRESULT hr;
    LPTSTR  lptstrEmailAddress = NULL;
    TCHAR   tszCaption[MAX_PATH] = {0};

    m_hWnd = hWnd;

    m_lpAdrList = NULL;

    AdrParms.ulFlags = StrCoding() | DIALOG_MODAL | ADDRESS_ONE | AB_RESOLVE ;

    if(GetAddrBookCaption(tszCaption, ARR_SIZE(tszCaption)))
    {
        AdrParms.lpszCaption = tszCaption;
    }
    
    //
    // Bring up the address book UI
    //
    hr = m_lpAdrBook->Address((ULONG_PTR *) &hWnd, &AdrParms, &m_lpAdrList);

    //
    // IAddrBook::Address returns always S_OK (according to MSDN, July 1999), but ...
    //

    if (FAILED(hr)) 
    {
        return NULL;    
    }

    if (!m_lpAdrList)
    {
        assert(m_lpAdrList->cEntries==1);
    }

    if (m_lpAdrList && (m_lpAdrList->cEntries != 0) ) 
    {
        LPADRENTRY lpAdrEntry = &m_lpAdrList->aEntries[0];

        lptstrEmailAddress = InterpretEmailAddress( lpAdrEntry->rgPropVals, lpAdrEntry->cValues);

        ABFreeBuffer(m_lpAdrList->aEntries[0].rgPropVals);
        ABFreeBuffer(m_lpAdrList);

        m_lpAdrList = NULL;
    }

    m_hWnd = NULL;

    return lptstrEmailAddress;

} // CCommonAbObj::AddressEmail

DWORD
CCommonAbObj::InterpretAddress(
    LPSPropValue SPropVal,
    ULONG cValues,
    PRECIPIENT *ppNewRecipList,
    PRECIPIENT pOldRecipList
    )
/*++

Routine Description:

    Interpret the address book entry represented by SPropVal.

Arguments:

    SPropVal - Property values for address book entry.
    cValues - number of property values
    ppNewRecip - new recipient list

Return Value:

    ERROR_SUCCESS      - if all of the entries have a fax number.
    ERROR_CANCELLED    - the operation was canceled by user
    ERROR_INVALID_DATA - otherwise.

--*/
{
    DWORD dwRes = ERROR_INVALID_DATA;
    LPSPropValue lpSPropVal;

    RECIPIENT NewRecipient = {0};

    //
    // get the object type
    //
    lpSPropVal = FindProp( SPropVal, cValues, PR_OBJECT_TYPE );

    if (lpSPropVal) 
    {
        //
        // If the object is a mail user, get the fax numbers and add the recipient
        // to the list.  If the object is a distribtion list, process it.
        //

        switch (lpSPropVal->Value.l) 
        {
            case MAPI_MAILUSER:

                dwRes = GetRecipientInfo(SPropVal, 
                                         cValues, 
                                         &NewRecipient,
                                         pOldRecipList);                                     
                if(ERROR_SUCCESS == dwRes)
                {
                    dwRes = AddRecipient(ppNewRecipList, 
                                         &NewRecipient,   
                                         TRUE);
                }

                break;

            case MAPI_DISTLIST:

                dwRes = InterpretDistList( SPropVal, 
                                           cValues, 
                                           ppNewRecipList,
                                           pOldRecipList);
        }

        return dwRes;

    } 
    else 
    {

        //
        // If there is no object type then this is valid entry that we queried on that went unresolved.
        // We know that there is a fax number so add it.
        //
        if(GetOneOffRecipientInfo( SPropVal, 
                                   cValues, 
                                   &NewRecipient,
                                   pOldRecipList)) 
        {
            dwRes = AddRecipient(ppNewRecipList,
                                 &NewRecipient,
                                 FALSE);
        }
    }

    return dwRes;

} // CCommonAbObj::InterpretAddress

LPTSTR
CCommonAbObj::InterpretEmailAddress(
    LPSPropValue SPropVal,
    ULONG cValues
    )
/*++

Routine Description:

    Interpret the address book entry represented by SPropVal.

Arguments:

    SPropVal - Property values for address book entry.
    cValues - number of property values
    
Return Value:

    A choosen E-mail address
    NULL otherwise.

--*/
{
    LPSPropValue lpSPropVal;
    LPTSTR  lptstrEmailAddress = NULL;
    BOOL rVal = FALSE;
    TCHAR tszBuffer[MAX_STRING_LEN];
    //
    // get the object type
    //
    lpSPropVal = FindProp( SPropVal, cValues, PR_OBJECT_TYPE );

    if(!lpSPropVal)
    {
        assert(FALSE);
        return NULL;
    }

    if (lpSPropVal->Value.l == MAPI_MAILUSER) 
    {       
        lptstrEmailAddress = GetEmail( SPropVal, cValues);

        return lptstrEmailAddress;
    } 
    else 
    {
        if (!::LoadString((HINSTANCE )m_hInstance, IDS_ERROR_RECEIPT_DL,tszBuffer, MAX_STRING_LEN))
        {
            assert(FALSE);
        }
        else
        {
            AlignedMessageBox( m_hWnd, tszBuffer, NULL, MB_ICONSTOP | MB_OK);
        }
    }

    return lptstrEmailAddress;

} // CCommonAbObj::InterpretEmailAddress


DWORD
CCommonAbObj::InterpretDistList(
    LPSPropValue SPropVal,
    ULONG cValues,
    PRECIPIENT* ppNewRecipList,
    PRECIPIENT pOldRecipList
    )
/*++

Routine Description:

    Process a distribution list.

Arguments:

    SPropVal       - Property values for distribution list.
    cValues        - Number of properties.
    ppNewRecipList - New recipient list.
    pOldRecipList  - Old recipient list.

Return Value:

    ERROR_SUCCESS      - if all of the entries have a fax number.
    ERROR_CANCELLED    - the operation was canceled by user
    ERROR_INVALID_DATA - otherwise.

--*/

#define EXIT_IF_FAILED(hr) { if (FAILED(hr)) goto ExitDistList; }

{
    LPSPropValue    lpPropVals;
    LPSRowSet       pRows = NULL;
    LPDISTLIST      lpMailDistList = NULL;
    LPMAPITABLE     pMapiTable = NULL;
    ULONG           ulObjType, cRows;
    HRESULT         hr;
    DWORD           dwEntriesSuccessfullyProcessed = 0;
    DWORD           dwRes = ERROR_INVALID_DATA;

    lpPropVals = FindProp( SPropVal, cValues, PR_ENTRYID );

    if (lpPropVals) 
    {
        LPENTRYID lpEntryId = (LPENTRYID) lpPropVals->Value.bin.lpb;
        DWORD cbEntryId = lpPropVals->Value.bin.cb;
        //
        // Open the recipient entry
        //
        hr = m_lpAdrBook->OpenEntry(
                    cbEntryId,
                    lpEntryId,
                    (LPCIID) NULL,
                    0,
                    &ulObjType,
                    (LPUNKNOWN *) &lpMailDistList
                    );

        EXIT_IF_FAILED(hr);
        //
        // Get the contents table of the address entry
        //
        hr = lpMailDistList->GetContentsTable(StrCoding(),
                                              &pMapiTable);
        EXIT_IF_FAILED(hr);
        //
        // Limit the query to only the properties we're interested in
        //
        hr = pMapiTable->SetColumns(m_bUnicode ? (LPSPropTagArray)&sPropTagsW : (LPSPropTagArray)&sPropTagsA, 0);
        EXIT_IF_FAILED(hr);
        //
        // Get the total number of rows
        //
        hr = pMapiTable->GetRowCount(0, &cRows);
        EXIT_IF_FAILED(hr);
        //
        // Get the individual entries of the distribution list
        //
        hr = pMapiTable->SeekRow(BOOKMARK_BEGINNING, 0, NULL);
        EXIT_IF_FAILED(hr);

        hr = pMapiTable->QueryRows(cRows, 0, &pRows);
        EXIT_IF_FAILED(hr);

        hr = S_OK;

        if (pRows && pRows->cRows) 
        {
            //
            // Handle each entry of the distribution list in turn:
            // for simple entries, call InterpretAddress
            // for embedded distribution list, call this function recursively
            //
            for (cRows = 0; cRows < pRows->cRows; cRows++) 
            {
                LPSPropValue lpProps = pRows->aRow[cRows].lpProps;
                ULONG cRowValues = pRows->aRow[cRows].cValues;

                lpPropVals = FindProp( lpProps, cRowValues, PR_OBJECT_TYPE );

                if (lpPropVals) 
                {
                    switch (lpPropVals->Value.l) 
                    {
                        case MAPI_MAILUSER:
                        {                                                       
                            dwRes = InterpretAddress( lpProps, 
                                                      cRowValues, 
                                                      ppNewRecipList,
                                                      pOldRecipList);
                            if (ERROR_SUCCESS == dwRes)
                            {
                                dwEntriesSuccessfullyProcessed++;
                            }                                                      
                            break;
                        }
                        case MAPI_DISTLIST:
                        {
                            dwRes = InterpretDistList( lpProps, 
                                                       cRowValues, 
                                                       ppNewRecipList,
                                                       pOldRecipList);
                            if (ERROR_SUCCESS == dwRes)
                            {
                                dwEntriesSuccessfullyProcessed++;
                            }                                                      
                            break;
                        }
                    }   // End of switch
                }   // End of property
            }   // End of properties loop
        }   // End of row
    }   // End of values

ExitDistList:
    //
    // Perform necessary clean up before returning to caller
    //
    if (pRows) 
    {
        for (cRows = 0; cRows < pRows->cRows; cRows++) 
        {
            ABFreeBuffer(pRows->aRow[cRows].lpProps);
        }
        ABFreeBuffer(pRows);
    }

    if (pMapiTable)
    {
        pMapiTable->Release();
    }

    if (lpMailDistList)
    {
        lpMailDistList->Release();
    }
    //
    // We only care if we successfully processed at least one object.
    // Return ERROR_SUCCESS if we did.
    //
    return dwEntriesSuccessfullyProcessed ? ERROR_SUCCESS : dwRes;

}   // CCommonAbObj::InterpretDistList


INT_PTR
CALLBACK
ChooseFaxNumberDlgProc(
    HWND hDlg,
    UINT uMsg,
    WPARAM wParam,
    LPARAM lParam
    )
/*++

Routine Description:

    Dialog proc for choose fax number dialog.

Arguments:

    lParam - pointer to PickFax structure.

Return Value:

    Control id of selection.

--*/

{
    PPICKFAX pPickFax = (PPICKFAX) lParam;

    switch (uMsg) 
    { 
        case WM_INITDIALOG:
        {

            TCHAR szTitle[MAX_PATH]  = {0};
            TCHAR szFormat[MAX_PATH] = {0};

            if(LoadString(CCommonAbObj::m_hInstance, 
                          IDS_CHOOSE_FAX_NUMBER, 
                          szFormat, 
                          MAX_PATH-1))
            {
                _sntprintf(szTitle, MAX_PATH-1, szFormat, pPickFax->DisplayName);
                SetDlgItemText(hDlg, IDC_DISPLAY_NAME, szTitle);
            }
            else
            {
                assert(FALSE);
            }                       

            if(pPickFax->BusinessFax)
            {
                SetDlgItemText(hDlg, IDC_BUSINESS_FAX_NUM, pPickFax->BusinessFax);
                CheckDlgButton(hDlg, IDC_BUSINESS_FAX, BST_CHECKED);
            }
            else
            {
                EnableWindow(GetDlgItem(hDlg, IDC_BUSINESS_FAX), FALSE);
            }

            if(pPickFax->HomeFax)
            {
                SetDlgItemText(hDlg, IDC_HOME_FAX_NUM, pPickFax->HomeFax);

                if(!pPickFax->BusinessFax)
                {
                    CheckDlgButton(hDlg, IDC_HOME_FAX, BST_CHECKED);
                }
            }
            else
            {
                EnableWindow(GetDlgItem(hDlg, IDC_HOME_FAX), FALSE);
            }

            if(pPickFax->OtherFax)
            {
                SetDlgItemText(hDlg, IDC_OTHER_FAX_NUM, pPickFax->OtherFax);
            }
            else
            {
                EnableWindow(GetDlgItem(hDlg, IDC_OTHER_FAX), FALSE);
            }

            return TRUE;
        }

        case WM_COMMAND:
        {            
            switch(LOWORD(wParam))
            {
            case IDOK:
                DWORD dwRes;
                if(IsDlgButtonChecked( hDlg, IDC_BUSINESS_FAX ))
                {
                    dwRes = IDC_BUSINESS_FAX;
                }
                else if(IsDlgButtonChecked( hDlg, IDC_HOME_FAX ))
                {
                    dwRes = IDC_HOME_FAX;
                }
                else
                {
                    dwRes = IDC_OTHER_FAX;
                }

                EndDialog( hDlg, dwRes);
                return TRUE;
                
            case IDCANCEL:
                EndDialog( hDlg, IDCANCEL);
                return TRUE;
            }
        }

        default:
            return FALSE;

    }

    return FALSE;

} // ChooseFaxNumberDlgProc

PRECIPIENT
CCommonAbObj::FindRecipient(
    PRECIPIENT   pRecipient,
    PRECIPIENT   pRecipList
)
/*++

Routine Description:

    Find recipient (pRecipient) in the recipient list (pRecipList)
    by recipient name and fax number

Arguments:

    pRecipList      - pointer to recipient list
    pRecipient      - pointer to recipient data

Return Value:

    pointer to RECIPIENT structure if found
    NULL - otherwise.
   
--*/
{
    if(!pRecipient || !pRecipList || !pRecipient->pName || !pRecipient->pAddress)
    {
        return NULL;
    }

    while(pRecipList)
    {
        if(pRecipList->pName && pRecipList->pAddress &&
           !_tcscmp(pRecipList->pName, pRecipient->pName) &&
           !_tcscmp(pRecipList->pAddress, pRecipient->pAddress))
        {
            return pRecipList;
        }
        pRecipList = pRecipList->pNext;
    }

    return NULL;

} // CCommonAbObj::FindRecipient

PRECIPIENT  
CCommonAbObj::FindRecipient(
    PRECIPIENT   pRecipList,
    PICKFAX*     pPickFax
)
/*++

Routine Description:

    Find recipient (pPickFax) in the recipient list (pRecipList)
    by recipient name and fax number

Arguments:

    pRecipList      - pointer to recipient list
    pPickFax        - pointer to recipient data

Return Value:

    pointer to RECIPIENT structure if found
    NULL - otherwise.
   
--*/
{
    if(!pRecipList || !pPickFax || !pPickFax->DisplayName)
    {
        return NULL;
    }

    while(pRecipList)
    {
        if(pRecipList->pName && pRecipList->pAddress &&
           !_tcscmp(pRecipList->pName, pPickFax->DisplayName))
        {
            if((pPickFax->BusinessFax && 
                !_tcscmp(pRecipList->pAddress, pPickFax->BusinessFax)) ||
               (pPickFax->HomeFax && 
                !_tcscmp(pRecipList->pAddress, pPickFax->HomeFax))     ||
               (pPickFax->OtherFax && 
                !_tcscmp(pRecipList->pAddress, pPickFax->OtherFax)))
            {
                return pRecipList;
            }
        }

        pRecipList = pRecipList->pNext;
    }

    return NULL;

} // CCommonAbObj::FindRecipient


BOOL
CCommonAbObj::StrPropOk(LPSPropValue lpPropVals)
{
    if(!lpPropVals)
    {
        return FALSE;
    }

#ifdef UNIOCODE
    if(!m_bUnicode)
    {
        return (lpPropVals->Value.lpszA && *lpPropVals->Value.lpszA);
    }
#endif
    return (lpPropVals->Value.LPSZ && *lpPropVals->Value.LPSZ);

} // CCommonAbObj::StrPropOk

DWORD
CCommonAbObj::GetRecipientInfo(
    LPSPropValue SPropVals,
    ULONG        cValues,
    PRECIPIENT   pNewRecip,
    PRECIPIENT   pOldRecipList
    )
/*++

Routine Description:

    Get the fax number and display name properties.

Arguments:

    SPropVal      - Property values for distribution list.
    cValues       - Number of properties.
    pNewRecip     - [out] pointer to the new recipient
    pOldRecipList - [in]  pointer to the old recipient list

Return Value:

    ERROR_SUCCESS      - if there is a fax number and display name.
    ERROR_CANCELLED    - the operation was canceled by user
    ERROR_INVALID_DATA - otherwise.
   
--*/

{
    DWORD dwRes = ERROR_SUCCESS;
    LPSPropValue lpPropVals;
    LPSPropValue lpPropArray;
    BOOL Result = FALSE;
    PICKFAX PickFax = { 0 };
    DWORD   dwFaxes = 0;

    assert(pNewRecip);
    ZeroMemory(pNewRecip, sizeof(RECIPIENT));

    //
    // Get the entryid and open the entry.
    //
    lpPropVals = FindProp( SPropVals, cValues, PR_ENTRYID );

    if (lpPropVals) 
    {
        ULONG lpulObjType;
        LPMAILUSER lpMailUser = NULL;
        HRESULT hr;
        ULONG countValues;

        pNewRecip->cbEntryId = lpPropVals->Value.bin.cb;
        ABAllocateBuffer(pNewRecip->cbEntryId, (LPVOID *)&pNewRecip->lpEntryId);
        if(!pNewRecip->lpEntryId)
        {
            return ERROR_NOT_ENOUGH_MEMORY;
        }
        else
        {
            memcpy(pNewRecip->lpEntryId, lpPropVals->Value.bin.lpb, pNewRecip->cbEntryId);
        }


        hr = m_lpAdrBook->OpenEntry(pNewRecip->cbEntryId,
                                    (ENTRYID*)pNewRecip->lpEntryId,
                                    (LPCIID) NULL,
                                    0,
                                    &lpulObjType,
                                    (LPUNKNOWN *) &lpMailUser);
        if (HR_SUCCEEDED(hr)) 
        {
            //
            // Get the properties.
            //
            hr = ((IMailUser *)lpMailUser)->GetProps(m_bUnicode ? (LPSPropTagArray)&sPropTagsW : (LPSPropTagArray)&sPropTagsA, 
                                                     StrCoding(), 
                                                     &countValues, 
                                                     &lpPropArray );
            if (HR_SUCCEEDED(hr)) 
            {
                lpPropVals = FindProp(lpPropArray, countValues, PR_PRIMARY_FAX_NUMBER);
                if (StrPropOk( lpPropVals )) 
                {
                    PickFax.OtherFax = StrFromAddrBk(lpPropVals);
                    if(PickFax.OtherFax && _tcslen(PickFax.OtherFax))
                    {
                        ++dwFaxes;
                    }
                }

                lpPropVals = FindProp(lpPropArray, countValues, PR_BUSINESS_FAX_NUMBER);
                if (StrPropOk( lpPropVals )) 
                {
                    PickFax.BusinessFax = StrFromAddrBk(lpPropVals);
                    if(PickFax.BusinessFax && _tcslen(PickFax.BusinessFax))
                    {
                        ++dwFaxes;
                    }
                }

                lpPropVals = FindProp(lpPropArray, countValues, PR_HOME_FAX_NUMBER);
                if (StrPropOk( lpPropVals )) 
                {
                    PickFax.HomeFax = StrFromAddrBk(lpPropVals);
                    if(PickFax.HomeFax && _tcslen(PickFax.HomeFax))
                    {
                        ++dwFaxes;
                    }
                }

                lpPropVals = FindProp(lpPropArray, countValues, PR_DISPLAY_NAME);
                if (StrPropOk( lpPropVals )) 
                {
                    pNewRecip->pName = PickFax.DisplayName = StrFromAddrBk(lpPropVals);
                }

                lpPropVals = FindProp(lpPropArray, countValues, PR_COUNTRY);
                if (StrPropOk( lpPropVals )) 
                {
                    pNewRecip->pCountry = PickFax.Country = StrFromAddrBk(lpPropVals);
                }

                if (0 == dwFaxes)  
                {
                    lpPropVals = FindProp(lpPropArray, countValues, PR_ADDRTYPE);

                    if(lpPropVals && ABStrCmp(lpPropVals, TEXT("FAX")))
                    {
                        lpPropVals = FindProp(lpPropArray, countValues, PR_EMAIL_ADDRESS);
                        if (StrPropOk( lpPropVals )) 
                        {
                            pNewRecip->pAddress = StrFromAddrBk(lpPropVals);
                            if(pNewRecip->pAddress)
                            {
                                ++dwFaxes;
                            }
                        }
                    }
                }

                PRECIPIENT pRecip = FindRecipient(pOldRecipList, &PickFax);
                if(pRecip)
                {
                    pNewRecip->pAddress     = StringDup(pRecip->pAddress);
                    pNewRecip->dwCountryId  = pRecip->dwCountryId;
                    pNewRecip->bUseDialingRules = pRecip->bUseDialingRules;

                    MemFree(PickFax.BusinessFax);
                    PickFax.BusinessFax = NULL;
                    MemFree(PickFax.HomeFax);
                    PickFax.HomeFax = NULL;
                    MemFree(PickFax.OtherFax);
                    PickFax.OtherFax = NULL;

                    dwFaxes = 1;
                }

                //
                // If there are more then 1 fax numbers, ask the user to pick one.
                //
                if (dwFaxes > 1) 
                {
                    INT_PTR nResult;
                    nResult = DialogBoxParam((HINSTANCE) m_hInstance,
                                             MAKEINTRESOURCE( IDD_CHOOSE_FAXNUMBER ),
                                             m_hWnd,
                                             ChooseFaxNumberDlgProc,
                                             (LPARAM) &PickFax);
                    switch( nResult ) 
                    {
                        case IDC_BUSINESS_FAX:
                            pNewRecip->pAddress = PickFax.BusinessFax;

                            MemFree(PickFax.HomeFax);
                            PickFax.HomeFax = NULL;
                            MemFree(PickFax.OtherFax);
                            PickFax.OtherFax = NULL;
                            break;

                        case IDC_HOME_FAX:
                            pNewRecip->pAddress = PickFax.HomeFax;

                            MemFree(PickFax.BusinessFax);
                            PickFax.BusinessFax = NULL;
                            MemFree(PickFax.OtherFax);
                            PickFax.OtherFax = NULL;
                            break;

                        case IDC_OTHER_FAX:
                            pNewRecip->pAddress = PickFax.OtherFax;

                            MemFree(PickFax.BusinessFax);
                            PickFax.BusinessFax = NULL;
                            MemFree(PickFax.HomeFax);
                            PickFax.HomeFax = NULL;
                            break;

                        case IDCANCEL:
                            MemFree(PickFax.BusinessFax);
                            PickFax.BusinessFax = NULL;
                            MemFree(PickFax.HomeFax);
                            PickFax.HomeFax = NULL;
                            MemFree(PickFax.OtherFax);
                            PickFax.OtherFax = NULL;

                            dwRes = ERROR_CANCELLED;
                            break;
                    }
                } 
            }

            ABFreeBuffer( lpPropArray );
        }

        if(!m_lpMailUser)
        {
            //
            // Remember the first MailUser and do not release it
            // to avoid release of the MAPI DLLs
            // m_lpMailUser should be released later
            //
            m_lpMailUser = lpMailUser;
        }
        else if(lpMailUser) 
        {
            lpMailUser->Release();
            lpMailUser = NULL;
        }
    } 

    if (0 == dwFaxes)   
    {
        lpPropVals = FindProp(SPropVals, cValues, PR_ADDRTYPE);

        if(lpPropVals && ABStrCmp(lpPropVals, TEXT("FAX")))
        {
            lpPropVals = FindProp(SPropVals, cValues, PR_EMAIL_ADDRESS);
            if (StrPropOk( lpPropVals )) 
            {
                TCHAR* pAddress =  StrFromAddrBk(lpPropVals);                
                if(pAddress)
                {
                    TCHAR* ptr = _tcschr(pAddress, TEXT('@'));
                    if(ptr)
                    {
                        ptr = _tcsinc(ptr);
                        pNewRecip->pAddress = StringDup(ptr);
                        MemFree(pAddress);
                    }
                    else
                    {
                        pNewRecip->pAddress = pAddress;
                    }
                }
            }

            lpPropVals = FindProp(SPropVals, cValues, PR_DISPLAY_NAME);
            if (StrPropOk( lpPropVals )) 
            {
                MemFree(pNewRecip->pName);
                pNewRecip->pName = NULL;

                pNewRecip->pName = StrFromAddrBk(lpPropVals);
            }
        }
    }

    if (PickFax.BusinessFax) 
    {
        pNewRecip->pAddress = PickFax.BusinessFax;
    } 
    else if (PickFax.HomeFax) 
    {
        pNewRecip->pAddress = PickFax.HomeFax;
    }
    else if (PickFax.OtherFax) 
    {
        pNewRecip->pAddress = PickFax.OtherFax;
    }

    if (ERROR_CANCELLED != dwRes && 
       (!pNewRecip->pAddress || !pNewRecip->pName))
    {
        dwRes = ERROR_INVALID_DATA;
    } 

    if(ERROR_SUCCESS != dwRes)
    {
        MemFree(pNewRecip->pName);
        MemFree(pNewRecip->pAddress);
        MemFree(pNewRecip->pCountry);
        ABFreeBuffer(pNewRecip->lpEntryId);
        ZeroMemory(pNewRecip, sizeof(RECIPIENT));
    }

    return dwRes;

} // CCommonAbObj::GetRecipientInfo

BOOL
CCommonAbObj::GetOneOffRecipientInfo(
    LPSPropValue SPropVals,
    ULONG        cValues,
    PRECIPIENT   pNewRecip,
    PRECIPIENT   pOldRecipList
    )
/*++

Routine Description:

    Get the fax number and display name properties.

Arguments:

    SPropVal      - Property values for distribution list.
    cValues       - Number of properties.
    pNewRecip     - [out] pointer to a new recipient
    pOldRecipList - pointer to the old recipient list

Return Value:

    TRUE if there is a fax number and display name.
    FALSE otherwise.

--*/

{
    PRECIPIENT  pRecip = NULL;
    LPSPropValue lpPropVals;

    assert(!pNewRecip);

    lpPropVals = FindProp(SPropVals, cValues, PR_PRIMARY_FAX_NUMBER);
    if (lpPropVals) 
    {
        if (!(pNewRecip->pAddress = StrFromAddrBk(lpPropVals)))
        {
            goto error;
        }
    }

    lpPropVals = FindProp(SPropVals, cValues, PR_DISPLAY_NAME);
    if (lpPropVals) 
    {
        if (!(pNewRecip->pName = StrFromAddrBk(lpPropVals)))
        {
            goto error;
        }
    }

    pRecip = FindRecipient(pNewRecip, pOldRecipList);
    if(pRecip)
    {
        pNewRecip->dwCountryId  = pRecip->dwCountryId;
        pNewRecip->bUseDialingRules = pRecip->bUseDialingRules;
    }

    return TRUE;

error:
    MemFree(pNewRecip->pAddress);
    MemFree(pNewRecip->pName);
    return FALSE;

} // CCommonAbObj::GetOneOffRecipientInfo


LPTSTR
CCommonAbObj::GetEmail(
    LPSPropValue SPropVals,
    ULONG cValues
    )
/*++

Routine Description:

    Get e-mail address

Arguments:

    SPropVal - Property values for distribution list.
    cValues - Number of properties.

Return Value:

    A choosen E-mail address
    NULL otherwise.

--*/

{
    LPSPropValue    lpPropVals = NULL;
    LPSPropValue    lpPropArray = NULL;
    BOOL            Result = FALSE;
    LPTSTR          lptstrEmailAddress = NULL;
    TCHAR           tszBuffer[MAX_STRING_LEN];

    ULONG      lpulObjType = 0;
    LPMAILUSER lpMailUser = NULL;
    LPENTRYID  lpEntryId = NULL;
    DWORD      cbEntryId = 0;
    HRESULT    hr;
    ULONG      countValues = 0;

    //
    // Get the entryid and open the entry.
    //

    lpPropVals = FindProp( SPropVals, cValues, PR_ENTRYID );
    if (!lpPropVals) 
    {
        goto exit;
    }

    lpEntryId = (LPENTRYID)lpPropVals->Value.bin.lpb;
    cbEntryId = lpPropVals->Value.bin.cb;

    hr = m_lpAdrBook->OpenEntry(cbEntryId,
                                lpEntryId,
                                (LPCIID) NULL,
                                0,
                                &lpulObjType,
                                (LPUNKNOWN *) &lpMailUser);
    if (HR_FAILED(hr)) 
    {
        goto exit;
    }

    //
    // Get the properties.
    //
    hr = ((IMailUser*)lpMailUser)->GetProps(m_bUnicode ? (LPSPropTagArray)&sPropTagsW : (LPSPropTagArray)&sPropTagsA,
                                            StrCoding(), 
                                            &countValues, 
                                            &lpPropArray);
    if (HR_FAILED(hr)) 
    {
        goto exit;
    }

    lpPropVals = FindProp(lpPropArray, countValues, PR_ADDRTYPE);

    if (lpPropVals && ABStrCmp(lpPropVals, TEXT("SMTP")))
    {
        lpPropVals = FindProp(lpPropArray, countValues, PR_EMAIL_ADDRESS);
        if (StrPropOk( lpPropVals )) 
        {
            lptstrEmailAddress = StrFromAddrBk(lpPropVals);
        }
    }
    else if (lpPropVals && ABStrCmp(lpPropVals, TEXT("EX")))
    {
        lpPropVals = FindProp(lpPropArray, countValues, PR_EMS_AB_PROXY_ADDRESSES);
        if (lpPropVals) 
        {
            DWORD dwArrSize = m_bUnicode ? lpPropVals->Value.MVszW.cValues : lpPropVals->Value.MVszA.cValues;

            for(DWORD dw=0; dw < dwArrSize; ++dw)
            {
                if(m_bUnicode)
                {                            
                    if(wcsstr(lpPropVals->Value.MVszW.lppszW[dw], L"SMTP:"))
                    {
                        WCHAR* ptr = wcschr(lpPropVals->Value.MVszW.lppszW[dw], L':');
                        ptr++;

                        SPropValue propVal = {0};
                        propVal.Value.lpszW = ptr;

                        lptstrEmailAddress = StrFromAddrBk(&propVal);
                        break;
                    }                            
                }
                else // ANSII
                {
                    if(strstr(lpPropVals->Value.MVszA.lppszA[dw], "SMTP:"))
                    {
                        CHAR* ptr = strchr(lpPropVals->Value.MVszA.lppszA[dw], ':');
                        ptr++;

                        SPropValue propVal = {0};
                        propVal.Value.lpszA = ptr;

                        lptstrEmailAddress = StrFromAddrBk(&propVal);
                        break;
                    }                            
                }
            }
        }
    }
            
exit:
    if(lpPropArray)
    {
        ABFreeBuffer( lpPropArray );
    }
    
    if (lpMailUser) 
    {
        lpMailUser->Release();
    }   

    if(!lptstrEmailAddress)
    {                
        if (!::LoadString((HINSTANCE )m_hInstance, IDS_ERROR_RECEIPT_SMTP,tszBuffer, MAX_STRING_LEN))
        {
            assert(FALSE);
        }
        else
        {
            AlignedMessageBox( m_hWnd, tszBuffer, NULL, MB_ICONSTOP | MB_OK); 
        }
    }

    return  lptstrEmailAddress;

} // CCommonAbObj::GetEmail

LPSPropValue
CCommonAbObj::FindProp(
    LPSPropValue rgprop,
    ULONG cprop,
    ULONG ulPropTag
    )
/*++

Routine Description:

    Searches for a given property tag in a propset. If the given
    property tag has type PT_UNSPECIFIED, matches only on the
    property ID; otherwise, matches on the entire tag.

Arguments:

    rgprop - Property values.
    cprop - Number of properties.
    ulPropTag - Property to search for.

Return Value:

    Pointer to property desired property value or NULL.
--*/

{
    if (!cprop || !rgprop)
    {
        return NULL;
    }

    LPSPropValue pprop = rgprop;

#ifdef UNICODE
    if(!m_bUnicode)
    {
        //
        // If the Address Book does not support Unicode
        // change the property type to ANSII
        //
        if(PROP_TYPE(ulPropTag) == PT_UNICODE)
        {
            ulPropTag = PROP_TAG( PT_STRING8, PROP_ID(ulPropTag));
        }

        if(PROP_TYPE(ulPropTag) == PT_MV_UNICODE)
        {
            ulPropTag = PROP_TAG( PT_MV_STRING8, PROP_ID(ulPropTag));
        }
    }
#endif

    while (cprop--)
    {
        if (pprop->ulPropTag == ulPropTag)
        {
            return pprop;
        }
        ++pprop;
    }

    return NULL;

} // CCommonAbObj::FindProp


DWORD
CCommonAbObj::AddRecipient(
    PRECIPIENT *ppNewRecipList,
    PRECIPIENT pRecipient,
    BOOL       bFromAddressBook
    )
/*++

Routine Description:

    Add a recipient to the recipient list.

Arguments:

    ppNewRecip       - pointer to pointer to list to add item to.
    pRecipient       - pointer to the new recipient data
    bFromAddressBook - boolean says if this recipient is from address book

Return Value:

    NA
--*/
{
    DWORD dwRes = ERROR_SUCCESS;
    PRECIPIENT pNewRecip = NULL;

    pNewRecip = (PRECIPIENT)MemAllocZ(sizeof(RECIPIENT));
    if(!pNewRecip)
    {
        dwRes = ERROR_NOT_ENOUGH_MEMORY;
        goto error;
    }
    else
    {
        pNewRecip->pName        = pRecipient->pName;
        pNewRecip->pAddress     = pRecipient->pAddress;
        pNewRecip->pCountry     = pRecipient->pCountry;
        pNewRecip->cbEntryId    = pRecipient->cbEntryId;
        pNewRecip->lpEntryId    = pRecipient->lpEntryId;
        pNewRecip->dwCountryId  = pRecipient->dwCountryId;
        pNewRecip->bUseDialingRules = pRecipient->bUseDialingRules;
        pNewRecip->bFromAddressBook = bFromAddressBook;
        pNewRecip->pNext = *ppNewRecipList;
    }

    try
    {
        //
        // Try to insert a recipient into the set
        //
        if(m_setRecipients.insert(pNewRecip).second == false)
        {
            //
            // Such recipient already exists
            //
            goto error;
        }
    }
    catch (std::bad_alloc&)
    {
        dwRes = ERROR_NOT_ENOUGH_MEMORY;
        goto error;
    }

    //
    // Add the recipient into the list
    //
    *ppNewRecipList = pNewRecip;

    return dwRes;

error:

    MemFree(pRecipient->pName);
    MemFree(pRecipient->pAddress);
    MemFree(pRecipient->pCountry);
    ABFreeBuffer(pRecipient->lpEntryId);
    ZeroMemory(pRecipient, sizeof(RECIPIENT));

    MemFree(pNewRecip);

    return dwRes;

} // CCommonAbObj::AddRecipient


LPTSTR 
CCommonAbObj::StrToAddrBk(
    LPCTSTR szStr, 
    DWORD* pdwSize /* = NULL*/
)
/*++

Routine Description:

    Allocate string converted to the Address book encoding

Arguments:

    szStr   - [in] source string
    pdwSize - [out] optional size of new string in bytes

Return Value:

    Pointer to the converted string
    Should be released by MemFree()
--*/
{
    if(!szStr)
    {
        Assert(FALSE);
        return NULL;
    }
    
#ifdef UNICODE

    if(!m_bUnicode)
    {
        //
        // The address book does not support Unicode
        //
        INT   nSize;
        LPSTR pAnsii;
        //
        // Figure out how much memory to allocate for the multi-byte string
        //
        if (! (nSize = WideCharToMultiByte(CP_ACP, 0, szStr, -1, NULL, 0, NULL, NULL)) ||
            ! (pAnsii = (LPSTR)MemAlloc(nSize)))
        {
            return NULL;
        }

        //
        // Convert Unicode string to multi-byte string
        //
        WideCharToMultiByte(CP_ACP, 0, szStr, -1, pAnsii, nSize, NULL, NULL);

        if(pdwSize)
        {
            *pdwSize = nSize;
        }
        return (LPTSTR)pAnsii;
    }

#endif // UNICODE

    LPTSTR pNewStr = StringDup(szStr);
    if(pdwSize && pNewStr)
    {
        *pdwSize = (_tcslen(pNewStr)+1) * sizeof(TCHAR);
    }

    return pNewStr;

} // CCommonAbObj::StrToAddrBk


LPTSTR 
CCommonAbObj::StrFromAddrBk(LPSPropValue pValue)
/*++

Routine Description:

    Allocate string converted from the Address book encoding

Arguments:

    pValue  - [in] MAPI property

Return Value:

    Pointer to the converted string
    Should be released by MemFree()
--*/
{
    if(!pValue)
    {
        Assert(FALSE);
        return NULL;
    }

#ifdef UNICODE

    if(!m_bUnicode)
    {
        //
        // The address book does not support Unicode
        //

        if(!pValue->Value.lpszA)
        {
            Assert(FALSE);
            return NULL;
        }

        INT    nSize;
        LPWSTR pUnicodeStr;
        if (! (nSize = MultiByteToWideChar(CP_ACP, MB_PRECOMPOSED, pValue->Value.lpszA, -1, NULL, 0)) ||
            ! (pUnicodeStr = (LPWSTR) MemAlloc( nSize * sizeof(WCHAR))))
        {
            return NULL;
        }

        //
        // Convert multi-byte string to Unicode string
        //
        MultiByteToWideChar(CP_ACP, MB_PRECOMPOSED, pValue->Value.lpszA, -1, pUnicodeStr, nSize);
        return pUnicodeStr;
    }

#endif // UNICODE

    if(!pValue->Value.LPSZ)
    {
        Assert(FALSE);
        return NULL;
    }

    LPTSTR pNewStr = StringDup(pValue->Value.LPSZ);
    return pNewStr;

} // CCommonAbObj::StrFromAddrBk

BOOL 
CCommonAbObj::ABStrCmp(LPSPropValue lpPropVals, LPTSTR pStr)
/*++

Routine Description:

    Compare string with MAPI property value according to the address book encoding

Arguments:

    lpPropVals  - [in] MAPI property
    pStr        - [in] string to compare

Return Value:

  TRUE if the strings are equal
  FALSE otherwise
--*/
{
    BOOL bRes = FALSE;
    if(!lpPropVals || !pStr)
    {
        Assert(FALSE);
        return bRes;
    }

#ifdef UNICODE
    if(!m_bUnicode)
    {
        LPSTR pAnsii = (LPSTR)StrToAddrBk(pStr);
        if(pAnsii)
        {
            bRes = !strcmp(lpPropVals->Value.lpszA, pAnsii);
            MemFree(pAnsii);
        }
        return bRes;
    }
#endif

    bRes = !_tcscmp(lpPropVals->Value.LPSZ, pStr);
    return bRes;

} // CCommonAbObj::ABStrCmp

BOOL 
CCommonAbObj::GetAddrBookCaption(
    LPTSTR szCaption, 
    DWORD  dwSize
)
/*++

Routine Description:

    Get address book dialog caption according to the ANSII/Unicode capability

Arguments:

    szCaption  - [out] caption buffer
    dwSize     - [in]  caption buffer size in characters

Return Value:

  TRUE if success
  FALSE otherwise
--*/
{
    if(!szCaption || !dwSize)
    {
        Assert(FALSE);
        return FALSE;
    }

    TCHAR tszStr[MAX_PATH] = {0};

    if(!LoadString(m_hInstance, IDS_ADDRESS_BOOK_CAPTION, tszStr, ARR_SIZE(tszStr)))
    {
        return FALSE;
    }
    
    _tcsncpy(szCaption, tszStr, dwSize);
               
#ifdef UNICODE
    if(!m_bUnicode || GetABType() == AB_MAPI)
    {
        //
        // MAPI interpret lpszCaption as ANSII anyway
        //
        char szAnsiStr[MAX_PATH] = {0};
        if(!WideCharToMultiByte(CP_ACP, 
                                0, 
                                tszStr, 
                                -1, 
                                szAnsiStr, 
                                ARR_SIZE(szAnsiStr), 
                                NULL, 
                                NULL))
        {
            return FALSE;
        }

        memcpy(szCaption, szAnsiStr, min(dwSize, strlen(szAnsiStr)+1));
    }
#endif // UNICODE

    return TRUE;

} // CCommonAbObj::GetAddrBookCaption
=== C:/Users/treeman/Desktop/windows nt source code\Source\Win2K3\NT\printscan\faxsrv\print\faxprint\prnwzrd\async.c ===
/*++

Copyright (c) 1996  Microsoft Corporation

Module Name:

    async.c

Abstract:

    Functions for asynch send wizard actions

Environment:

        Windows XP fax driver user interface

Revision History:

        02/05/96 -davidx-
                Created it.

        mm/dd/yy -author-
                description

--*/

#include "faxui.h"
#include "tapiutil.h"
#include "faxsendw.h"


DWORD
AsyncWizardThread(
    PBYTE param
    )
/*++

Routine Description:

    Do some agonizingly slow tasks asynchronously so the wizard seems faster to the user.

Arguments:

    none.

Return Value:

    not used.

--*/
{
    PWIZARDUSERMEM pWizardUserMem = (PWIZARDUSERMEM) param;
    HANDLE  FaxHandle = NULL;
    PFAX_TAPI_LINECOUNTRY_LIST  pLineCountryList = NULL;
    DWORD dwRights = 0;
    DWORD dwFaxQueueState = 0;
	DWORD dwRecipientsLimit = 0; // default to no limit (backwards compatibility).

    Assert(pWizardUserMem);

    InitTapi ();
    if (!SetEvent(pWizardUserMem->hTAPIEvent))
    {
        Error(("Can't set hTAPIEvent. ec = 0x%X", GetLastError()));
    }
    
    if (FaxConnectFaxServer(pWizardUserMem->lptstrServerName,&FaxHandle)) 
    {
        if (!FaxAccessCheckEx (FaxHandle, MAXIMUM_ALLOWED, &dwRights))
        {
            dwRights = 0;
            Error(("FaxAccessCheckEx: failed. ec = 0X%x\n",GetLastError()));
        }
        pWizardUserMem->dwRights = dwRights;
        
        pWizardUserMem->dwSupportedReceipts = 0;
        if(!FaxGetReceiptsOptions(FaxHandle, &pWizardUserMem->dwSupportedReceipts))
        {
            Error(("FaxGetReceiptsOptions: failed. ec = 0X%x\n",GetLastError()));
        }

        if (!FaxGetQueueStates(FaxHandle,&dwFaxQueueState) )
        {
            dwFaxQueueState = 0;
            Error(("FaxGetQueueStates: failed. ec = 0X%x\n",GetLastError()));
        }
        pWizardUserMem->dwQueueStates = dwFaxQueueState;

		if (!FaxGetRecipientsLimit(FaxHandle,&dwRecipientsLimit) )
        {            
            Error(("dwRecipientsLimit: failed. ec = 0X%x\n",GetLastError()));
        }
        pWizardUserMem->dwRecipientsLimit = dwRecipientsLimit;

        if (!FaxGetCountryList(FaxHandle,&pLineCountryList))
        {
            Verbose(("Can't get a country list from the server %s",
                    pWizardUserMem->lptstrServerName));
        }
        else
		{
            Assert(pWizardUserMem->pCountryList==NULL);
            pWizardUserMem->pCountryList = pLineCountryList;
        }

        if (FaxHandle)
		{
            if (!FaxClose(FaxHandle))
            {
                Verbose(("Can't close the fax handle %x",FaxHandle));
            }
        }
    }
    else
	{
        Verbose(("Can't connect to the fax server %s",pWizardUserMem->lptstrServerName));
    }

    if (!SetEvent(pWizardUserMem->hCountryListEvent))
    {
        Error(("Can't set hCountryListEvent. ec = 0x%X",GetLastError()));
    }

    //
    // use server coverpages (may startup fax service, which is slow)
    //
    pWizardUserMem->ServerCPOnly = UseServerCp(pWizardUserMem->lptstrServerName);
    if (!SetEvent(pWizardUserMem->hCPEvent))
    {
        Error(("Can't set hCPEvent. ec = 0x%X",GetLastError()));
    }
       
#ifdef FAX_SCAN_ENABLED
    //
    // look for twain stuff
    //
    if (!(pWizardUserMem->dwFlags & FSW_USE_SCANNER) ){
        pWizardUserMem->TwainAvail = FALSE;
    } else {
        pWizardUserMem->TwainAvail = InitializeTwain(pWizardUserMem);
    }
    if (!SetEvent(pWizardUserMem->hTwainEvent))
    {
        Error(("Can't set hTwainEvent. ec = 0x%X",GetLastError()));
    }
#endif //  FAX_SCAN_ENABLED

    return ERROR_SUCCESS;
  
}
=== C:/Users/treeman/Desktop/windows nt source code\Source\Win2K3\NT\printscan\faxsrv\print\faxprint\prnwzrd\abobj.h ===
/*++

Copyright (c) 1997  Microsoft Corporation

Module Name:

    abobj.h

Abstract:

    Class definition for CCommonAbObj

Environment:

        Fax send wizard


--*/

#ifndef __ABOBJ_H_
#define __ABOBJ_H_

/* 
    The following pre-processor directives were added so that fxswzrd.dll no longer depends on msvcp60.dll.
    That dependency raised deployment issues with point-and-print installation on down-level operating systems.
    
    Undefining _MT, _CRTIMP, and _DLL causes the STL set implementation to be non-thread-safe (no locks when accessing data).
    
    In the fax send wizard, the set is used to keep the list of recipient unique.
    Since the wizard (at that stage) has only a single thread, thread safety is not an issue anymore.

*/

#undef _MT
#undef _CRTIMP
#undef _DLL
#pragma warning (disable: 4273)
#include <set>
using namespace std;

typedef struct 
{
    LPTSTR DisplayName;
    LPTSTR BusinessFax;
    LPTSTR HomeFax;
    LPTSTR OtherFax;
    LPTSTR Country;
} PICKFAX, * PPICKFAX;

struct CRecipCmp
{
/*
    Comparison operator 'less'
    Compare two PRECIPIENT by recipient's name and fax number
*/
    bool operator()(const PRECIPIENT pcRecipient1, const PRECIPIENT pcRecipient2) const;
};


typedef set<PRECIPIENT, CRecipCmp> RECIPIENTS_SET;


class CCommonAbObj {
    
protected:

    LPADRBOOK   m_lpAdrBook;
    LPADRLIST   m_lpAdrList; 

    LPMAILUSER  m_lpMailUser;

    HWND        m_hWnd;

    // DWORD       m_PickNumber; 

    RECIPIENTS_SET m_setRecipients;

    BOOL    m_bUnicode; // The Unicode is supported by Address Book

    ULONG  StrCoding() { return m_bUnicode ? MAPI_UNICODE : 0; }

    LPTSTR StrToAddrBk(LPCTSTR szStr, DWORD* pdwSize = NULL); // return allocated string converted to the Address book encoding
    LPTSTR StrFromAddrBk(LPSPropValue pValue); // return allocated string converted from the Address book encoding

    BOOL StrPropOk(LPSPropValue lpPropVals);
    BOOL ABStrCmp(LPSPropValue lpPropVals, LPTSTR pStr);

    enum eABType {AB_MAPI, AB_WAB};

    virtual eABType GetABType()=0;

    BOOL GetAddrBookCaption(LPTSTR szCaption, DWORD dwSize);

    LPSPropValue FindProp(LPSPropValue rgprop,
                          ULONG        cprop,
                          ULONG        ulPropTag);

    virtual HRESULT     ABAllocateBuffer(
                        ULONG cbSize,           
                        LPVOID FAR * lppBuffer  
                        ) = 0;

    virtual ULONG       ABFreeBuffer(
                        LPVOID lpBuffer
                        ) = 0;

    virtual BOOL        isInitialized() const = 0;

    DWORD        GetRecipientInfo(
                    LPSPropValue SPropVals,
                    ULONG cValues,
                    PRECIPIENT pRecipient,
                    PRECIPIENT pOldRecipList
                    );

    BOOL
                GetOneOffRecipientInfo(
                    LPSPropValue SPropVals,
                    ULONG cValues,
                    PRECIPIENT pRecipient,
                    PRECIPIENT pOldRecipList
                    );

    LPTSTR      GetEmail(
                    LPSPropValue SPropVals,
                    ULONG cValues
                    );


    DWORD        InterpretAddress(
                    LPSPropValue SPropVals,
                    ULONG cValues,
                    PRECIPIENT *ppNewRecipList,
                    PRECIPIENT pOldRecipList
                    );
    LPTSTR
                InterpretEmailAddress(
                    LPSPropValue SPropVal,
                    ULONG cValues
                    );
                
    DWORD        InterpretDistList(
                    LPSPropValue SPropVals,
                    ULONG cValues,
                    PRECIPIENT *ppNewRecipList,
                    PRECIPIENT pOldRecipList
                    );

    PRECIPIENT  FindRecipient(
                    PRECIPIENT   pRecipList,
                    PICKFAX*     pPickFax
                    );

    PRECIPIENT  FindRecipient(
                    PRECIPIENT   pRecipient,
                    PRECIPIENT   pRecipList
                    );

    DWORD AddRecipient(
                    PRECIPIENT* ppNewRecip,
                    PRECIPIENT  pRecipient,
                    BOOL        bFromAddressBook
                    ); 

    BOOL GetRecipientProps(PRECIPIENT    pRecipient,
                           LPSPropValue* pMapiProps,
                           DWORD*        pdwPropsNum);

                   
public:

    CCommonAbObj(HINSTANCE hInstance);
    ~CCommonAbObj();
    
    BOOL
    Address( 
        HWND hWnd,
        PRECIPIENT pRecip,
        PRECIPIENT * ppNewRecip
        );

    LPTSTR
    AddressEmail(
        HWND hWnd
        );

    static  HINSTANCE   m_hInstance;
} ;


#endif
=== C:/Users/treeman/Desktop/windows nt source code\Source\Win2K3\NT\printscan\faxsrv\print\faxprint\prnwzrd\coverpg.h ===
/*++

Copyright (c) 1996  Microsoft Corporation

Module Name:

    coverpg.h

Abstract:

    Functions for working with cover pages

Environment:

        Windows XP fax driver user interface

Revision History:

        02/05/96 -davidx-
                Created it.

        dd-mm-yy -author-
                description

--*/


#ifndef _COVERPAGE_H_
#define _COVERPAGE_H_

//
// Cover page filename extension
//

#define MAX_FILENAME_EXT    4

//
// Data structure for representing a list of cover pages:
//  the first nServerDirs paths refer to the server cover page directory
//  remaining paths contain user cover page directories
//

#define MAX_COVERPAGE_DIRS  8

typedef struct {

    INT     nDirs;
    INT     nServerDirs;
    LPTSTR  pDirPath[MAX_COVERPAGE_DIRS];

} CPDATA, *PCPDATA;

//
// Flag bits attached to each cover page in a listbox
//

#define CPFLAG_DIRINDEX 0x00FF
#define CPFLAG_SERVERCP 0x0100
#define CPFLAG_SELECTED 0x0400
#define CPFLAG_SUFFIX   0x0800

//
// Generate a list of available cover pages (both server and user)
//

VOID
InitCoverPageList(
    PCPDATA pCPInfo,
    HWND    hwndList,
    LPTSTR  pSelectedCoverPage
    );

//
// Retrieve the currently selected cover page name
//

INT
GetSelectedCoverPage(
    PCPDATA pCPInfo,
    IN  HWND    hwndList,
    OUT LPTSTR  lptstrFullPath,
    IN  UINT    cchstrFullPath,
    OUT LPTSTR  lptstrFileName,
    IN  UINT    cchstrFileName,
    OUT BOOL * pbIsServerPage
    );

//
// Allocate memory to hold cover page information
//

PCPDATA
AllocCoverPageInfo(
	LPTSTR	lptstrServerName,
	LPTSTR	lptstrPrinterName,
    BOOL	ServerCpOnly
    );

//
// must clients use server coverpages?
//

BOOL
UseServerCp(
	LPTSTR	lptstrServerName
    );

//
// Free up memory used for cover page information
//

VOID
FreeCoverPageInfo(
    PCPDATA pCPInfo
    );

#endif  // !_COVERPAGE_H_
=== C:/Users/treeman/Desktop/windows nt source code\Source\Win2K3\NT\printscan\faxsrv\print\faxprint\prnwzrd\cwabutil.h ===
#ifndef _CWABUTIL_H_
#define _CWABUTIL_H_

LPVOID 
InitializeWAB(
    HINSTANCE hInstance
    );

VOID 
UnInitializeWAB( 
    LPVOID 
    );

BOOL
CallWabAddress(
    HWND            hDlg,
    PWIZARDUSERMEM   pWizardUserMem,
    PRECIPIENT *    ppNewRecipient
    );

LPTSTR
CallWabAddressEmail(
    HWND            hDlg,
    PWIZARDUSERMEM   pWizardUserMem
    );
    
#endif
=== C:/Users/treeman/Desktop/windows nt source code\Source\Win2K3\NT\printscan\faxsrv\print\faxprint\prnwzrd\cwabobj.cpp ===
/*++

Copyright (c) 1997  Microsoft Corporation

Module Name:

    cwabobj.cpp

Abstract:

    Interface to the windows address book.

Environment:

        Fax send wizard

Revision History:

        10/23/97 -GeorgeJe-
                Created it.

        mm/dd/yy -author-
                description

--*/

#include <windows.h>
#include <prsht.h>
#include <tchar.h>

#include <wab.h>

#include "faxui.h"
#include "cwabobj.h"

//
//  This is a global object that used for non throwing new operator.
//
//  Using non throwing new is done by using this syntax:
//
//      ptr = new (std::nothrow) CMyClass();
//
//
//  We had to instaciate this object since fxswzrd.dll is no longer depends on msvcp60.dll (see abobj.h for details).
//
//
namespace std{
    const nothrow_t nothrow;
};

CWabObj::CWabObj(
    HINSTANCE hInstance
) : CCommonAbObj(hInstance),
    m_Initialized(FALSE),
    m_hWab(NULL),
    m_lpWabOpen(NULL),
    m_lpWABObject(NULL)
/*++

Routine Description:

    Constructor for CWabObj class

Arguments:

    hInstance - Instance handle

Return Value:

    NONE

--*/

{
    TCHAR szDllPath[MAX_PATH];
    HKEY hKey = NULL;
    LONG rVal;
    DWORD dwType;
    DWORD cbData = MAX_PATH * sizeof(TCHAR);
    HRESULT hr;

    m_lpAdrBook = NULL;
    m_lpAdrList = NULL;

    //
    // get the path to wab32.dll
    //
    rVal = RegOpenKeyEx(
                    HKEY_LOCAL_MACHINE,
                    REGVAL_WABPATH,
                    0,
                    KEY_READ,
                    &hKey
                    );

    if (rVal == ERROR_SUCCESS) 
    {
        rVal = RegQueryValueEx(
                    hKey,
                    TEXT(""),
                    NULL,
                    &dwType,
                    (LPBYTE) szDllPath,
                    &cbData
                    );
    }

    if (rVal != ERROR_SUCCESS) 
    {
        _tcscpy( szDllPath, TEXT("wab32.dll") );
    }

    if (hKey)
    {
        RegCloseKey( hKey );
    }

    m_hWab = LoadLibrary( szDllPath );
    if (m_hWab == NULL) 
    {
        return;
    }

    m_lpWabOpen = (LPWABOPEN) GetProcAddress( m_hWab , "WABOpen" );
    if(m_lpWabOpen == NULL)
    {
        return;
    }

    //
    // open the wab
    //
    hr = m_lpWabOpen( &m_lpAdrBook, &m_lpWABObject, 0, 0 );
    if (HR_SUCCEEDED(hr))         
    {
        m_Initialized = TRUE;
    }

#ifdef UNICODE

    //
    // The WAB supports Unicode since version 5.5
    // So we check the version
    //

    DWORD dwRes = ERROR_SUCCESS;
    FAX_VERSION ver = {0};
    ver.dwSizeOfStruct = sizeof(ver);

    dwRes = GetFileVersion(szDllPath, &ver);
    if(ERROR_SUCCESS != dwRes)
    {
        Error(("GetFileVersion failed with %d\n", dwRes));
        return;
    }

    DWORD dwFileVer = (ver.wMajorVersion << 16) | ver.wMinorVersion;
    if(dwFileVer > 0x50000)
    {
        m_bUnicode = TRUE;
    }

#endif // UNICODE

}

CWabObj::~CWabObj()
/*++

Routine Description:

    Destructor for CWabObj class

Arguments:

    NONE

Return Value:

    NONE

--*/
{
    if (m_lpAdrBook) {
        m_lpAdrBook->Release();
    }

    if (m_lpWABObject) {
        m_lpWABObject->Release();
    }
    if (m_hWab) 
    {
        FreeLibrary( m_hWab );
        m_hWab = NULL;
    }
}


HRESULT
CWabObj::ABAllocateBuffer(
	ULONG cbSize,           
	LPVOID FAR * lppBuffer  
    )

/*++

Routine Description:


Arguments:


Return Value:
--*/

{
    return m_lpWABObject->AllocateBuffer( cbSize, lppBuffer );
}


ULONG
CWabObj::ABFreeBuffer(
	LPVOID lpBuffer
	)
{
	return m_lpWABObject->FreeBuffer(lpBuffer);
}

extern "C"
VOID
FreeWabEntryID(
    PWIZARDUSERMEM	pWizardUserMem,
	LPVOID			lpEntryId
				)
/*++

Routine Description:

    C wrapper for WAB Free

Arguments:

    pWizardUserMem - pointer to WIZARDUSERMEM structure
    lpEntryID - pointer to EntryId

Return Value:
	
	  NONE

--*/
{
    CWabObj * lpCWabObj = (CWabObj *) pWizardUserMem->lpWabInit;
	lpCWabObj->ABFreeBuffer(lpEntryId);		
}

extern "C"
BOOL
CallWabAddress(
    HWND hDlg,
    PWIZARDUSERMEM pWizardUserMem,
    PRECIPIENT * ppNewRecipient
    )
/*++

Routine Description:

    C wrapper for CWabObj->Address

Arguments:

    hDlg - parent window handle.
    pWizardUserMem - pointer to WIZARDUSERMEM structure
    ppNewRecipient - list to add new recipients to.

Return Value:

    TRUE if all of the entries have a fax number.
    FALSE otherwise.

--*/

{
    CWabObj*  lpCWabObj = (CWabObj*) pWizardUserMem->lpWabInit;

    return lpCWabObj->Address(
                hDlg,
                pWizardUserMem->pRecipients,
                ppNewRecipient
                );

}

extern "C"
LPTSTR
CallWabAddressEmail(
    HWND hDlg,
    PWIZARDUSERMEM pWizardUserMem
    )
/*++

Routine Description:

    C wrapper for CWabObj->AddressEmail

Arguments:

    hDlg - parent window handle.
    pWizardUserMem - pointer to WIZARDUSERMEM structure

Return Value:

    TRUE if found one appropriate E-mail
    FALSE otherwise.

--*/

{
    CWabObj*	lpCWabObj = (CWabObj*) pWizardUserMem->lpWabInit;

    return lpCWabObj->AddressEmail(
                hDlg
                );

}

extern "C"
LPVOID
InitializeWAB(
    HINSTANCE hInstance
    )
/*++

Routine Description:

    Initialize the WAB.

Arguments:

    hInstance - instance handle.

Return Value:

    NONE
--*/

{
    CWabObj* lpWabObj = new (std::nothrow) CWabObj( hInstance );

	if ((lpWabObj!=NULL) && (!lpWabObj->isInitialized()))	// constructor failed
	{
		delete lpWabObj;
		lpWabObj = NULL;
	}

    return (LPVOID) lpWabObj;
}

extern "C"
VOID
UnInitializeWAB(
    LPVOID lpVoid
    )
/*++

Routine Description:

    UnInitialize the WAB.

Arguments:

    NONE

Return Value:

    NONE
--*/

{
    CWabObj* lpWabObj = (CWabObj*) lpVoid;

    delete lpWabObj;
}
=== C:/Users/treeman/Desktop/windows nt source code\Source\Win2K3\NT\printscan\faxsrv\print\faxprint\prnwzrd\help.h ===
/*++

Copyright (c) 1996  Microsoft Corporation

Module Name:

    help.h

Abstract:

    Help related declarations

Environment:

    Windows XP fax driver

Revision History:

    07/30/96 -davidx-
        Created it.

    dd-mm-yy -author-
        description

--*/

#ifndef _HELP_H_
#define _HELP_H_

//
// Name of the help file for the fax driver
//

#define HELP_FILENAME               TEXT("fax.hlp")

//
// Help indices
//

#define IDH_BILLING_CODE                  2002
#define IDH_IMAGE_QUALITY                 2025
#define IDH_LANDSCAPE                     2026
#define IDH_PAPER_SIZE                    2037
#define IDH_PORTRAIT                      2038
#define IDH_SEND_ASAP                     2046
#define IDH_SEND_AT_CHEAP                 2047
#define IDH_SEND_AT_TIME                  2048
#define IDH_EMAIL                         2049
#define IDH_FAX_SEND_GRP                  2075
#define IDH_DEFAULT_PRINT_SETUP_GRP       2070
#define IDH_ORIENTATION                   2062
#define IDH_SEND_AT_TIME                  2048

#endif  // !_HELP_H_
=== C:/Users/treeman/Desktop/windows nt source code\Source\Win2K3\NT\printscan\faxsrv\print\faxprint\prnwzrd\cwabobj.h ===
/*++

Copyright (c) 1997  Microsoft Corporation

Module Name:

    cwabobj.h

Abstract:

    Class definition for CWabObj

Environment:

        Fax send wizard

Revision History:

        10/23/97 -georgeje-
                Created it.

        mm/dd/yy -author-
                description

--*/

#ifndef __CWABOBJ__H_
#define __CWABOBJ__H_

#include "abobj.h"

class CWabObj : public CCommonAbObj{
private:    
    HINSTANCE   m_hWab;
    LPWABOPEN   m_lpWabOpen;
    LPWABOBJECT m_lpWABObject;

    BOOL        m_Initialized;

    virtual eABType GetABType() { return AB_WAB; };

    HRESULT     ABAllocateBuffer(ULONG cbSize,           
                                 LPVOID FAR * lppBuffer);

public:

    BOOL isInitialized() const  {   return m_Initialized;   }

    CWabObj(HINSTANCE hInstance);
    ~CWabObj();
    
    ULONG ABFreeBuffer(LPVOID lpBuffer) ;

} ;


#endif
=== C:/Users/treeman/Desktop/windows nt source code\Source\Win2K3\NT\printscan\faxsrv\print\faxprint\prnwzrd\coverpg.c ===
/*++

Copyright (c) 1996  Microsoft Corporation

Module Name:

    coverpg.c

Abstract:

    Functions for working with cover pages

Environment:

        Windows XP fax driver user interface

Revision History:

        02/05/96 -davidx-
                Created it.

        10/20/99 -danl-
                Get server name properly in GetServerCoverPageDirs.

        mm/dd/yy -author-
            description

--*/

#include "faxui.h"
#include <faxreg.h>
#include <shlobj.h>
#include <shellapi.h>
#include <commdlg.h>
#include "faxutil.h"

#define STRSAFE_NO_DEPRECATE
#include <strsafe.h>


//
// Suffix string appended to all user cover page filenames
//

static TCHAR PersonalSuffixStr[64];



VOID
InsertOneCoverPageFilenameToList(
    HWND    hwndList,
    LPTSTR  pFilename,
    INT     flags
    )

/*++

Routine Description:

    Insert one cover page filename into the list of cover pages

Arguments:

    hwndList - Handle to list window
    pFilename - Name of the cover page file
    flags - Flags to be associated with the list item

Return Value:

    NONE

--*/

{
    INT     listIndex;
    LPTSTR  pBuffer = NULL;

    //
    // Add " (Personal)" suffix to all user cover pages
    //

    if ((flags & CPFLAG_SERVERCP) == 0) {

        if (IsEmptyString(PersonalSuffixStr))
        {
            if(!LoadString(g_hResource, IDS_USERCP_SUFFIX, PersonalSuffixStr, 64))
            {
                Assert(FALSE);
            }
        }

        if (pBuffer = MemAlloc(SizeOfString(pFilename) + SizeOfString(PersonalSuffixStr))) 
        {
            _tcscpy(pBuffer, pFilename);
            _tcscat(pBuffer, PersonalSuffixStr);

            flags |= CPFLAG_SUFFIX;
            pFilename = pBuffer;
        }
    }

    //
    // Insert the cover page filename into the list
    //

    listIndex = (INT)SendMessage(hwndList, CB_ADDSTRING, 0, (LPARAM) pFilename);

    if (listIndex != CB_ERR)
        SendMessage(hwndList, CB_SETITEMDATA, listIndex, flags);

    MemFree(pBuffer);
}



VOID
AddCoverPagesToList(
    PCPDATA     pCPInfo,
    HWND        hwndList,
    LPTSTR      pSelected,
    INT         nDirs
    )

/*++

Routine Description:

    Add the cover page files in the specified directory to a list

Arguments:

    pCPInfo   - Points to cover page information
    hwndList  - Handle to a list window
    pSelected - Currently selected cover page
    nDirs     - Cover page directory index

Return Value:

    NONE

--*/

{
    WIN32_FIND_DATA findData;
    TCHAR           filename[MAX_PATH];
    HANDLE          hFindFile;
    LPTSTR          pDirPath, pExtension;
    INT             dirLen, fileLen, flags;
    TCHAR           tszPathName[MAX_PATH] = {0};
    TCHAR*          pPathEnd;

    //
    // Are we working on server or user cover pages?
    //

    flags = nDirs | ((nDirs < pCPInfo->nServerDirs) ? CPFLAG_SERVERCP : 0);
    pDirPath = pCPInfo->pDirPath[nDirs];

    if (IsEmptyString(pDirPath))
        return;

    _tcsncpy(tszPathName, pDirPath, ARR_SIZE(tszPathName)-1);
    tszPathName[ARR_SIZE(tszPathName) - 1] = TEXT('\0');
    pPathEnd = _tcschr(tszPathName, '\0');

    //
    // Look at the directory prefix of the currently selected cover page file
    //

    if ((dirLen = _tcslen(pDirPath)) >= MAX_PATH - MAX_FILENAME_EXT - 1) 
    {
        Error(("Directory name too long: %ws\n", pDirPath));
        return;
    }

    _tcscpy(filename, pDirPath);

    if (!pSelected || _tcsnicmp(pDirPath, pSelected, dirLen) != EQUAL_STRING)
    {
        pSelected = NULL;
    }
    else
    {
        pSelected += dirLen;
    }

    //
    // Generate a specification for the files we're interested in
    //
    _tcscat(filename, FAX_COVER_PAGE_MASK);

    //
    // Call FindFirstFile/FindNextFile to enumerate the files
    // matching our specification
    //

    hFindFile = FindFirstFile(filename, &findData);
    if (hFindFile == INVALID_HANDLE_VALUE) 
    {
        return;
    }

    do 
    {
        //
        // Exclude directories and hidden files
        //

        if (findData.dwFileAttributes & (FILE_ATTRIBUTE_HIDDEN | FILE_ATTRIBUTE_DIRECTORY))
            continue;

        //
        // Make sure we have enough room to store the full pathname
        //

        if ((fileLen = _tcslen(findData.cFileName)) <= MAX_FILENAME_EXT)
            continue;

        if (fileLen + dirLen >= MAX_PATH) 
        {
            Error(("Filename too long: %ws%ws\n", pDirPath, findData.cFileName));
            continue;
        }

        //
        // Compare with the currently selected cover page filename
        //
        if (pSelected && _tcsicmp(pSelected, findData.cFileName) == EQUAL_STRING) 
        {
            pSelected = NULL;
            flags |= CPFLAG_SELECTED;
        } 
        else
        {
            flags &= ~CPFLAG_SELECTED;
        }


        _tcsncpy(pPathEnd, findData.cFileName, MAX_PATH - dirLen);
        if(!IsValidCoverPage(tszPathName))
        {
            continue;
        }                

        //
        // Don't display the filename extension
        //                 
        if (pExtension = _tcsrchr(findData.cFileName, TEXT(FILENAME_EXT))) {
            *pExtension = NUL;
        }

        //
        // Add the cover page name to the list window
        //

        InsertOneCoverPageFilenameToList(hwndList, findData.cFileName, flags);

    } while (FindNextFile(hFindFile, &findData));

    FindClose(hFindFile);        
}


VOID
InitCoverPageList(
    PCPDATA pCPInfo,
    HWND    hwndList,
    LPTSTR  pSelectedCoverPage
    )

/*++

Routine Description:

    Generate a list of available cover pages (both server and user)

Arguments:

    pCPInfo - Points to cover page information
    hwndList - Handle to the list window
    pSelectedCoverPage - Name of currently selected cover page file

Return Value:

    NONE

--*/

{
    INT itemFlags, index;

    //
    // Validate input parameters
    //

    if (pCPInfo == NULL || hwndList == NULL)
        return;

    //
    // Disable redraw on the list and reset its content
    //

    SendMessage(hwndList, WM_SETREDRAW, FALSE, 0);
    SendMessage(hwndList, CB_RESETCONTENT, FALSE, 0);

    //
    // Add server and user cover pages to the list
    //

    for (index=0; index < pCPInfo->nDirs; index++)
        AddCoverPagesToList(pCPInfo, hwndList, pSelectedCoverPage, index);

    //
    // Highlight the currently selected cover page
    //

    index = (INT)SendMessage(hwndList, CB_GETCOUNT, 0, 0);

    if (index > 0) {

        //
        // Go through each list item and check if it should be selected
        //

        while (--index >= 0) {

            itemFlags = (INT)SendMessage(hwndList, CB_GETITEMDATA, index, 0);

            if (itemFlags != CB_ERR && (itemFlags & CPFLAG_SELECTED)) {

                SendMessage(hwndList, CB_SETCURSEL, index, 0);
                break;
            }
        }

        //
        // If nothing is selected, select the first item by default
        //

        if (index < 0)
            SendMessage(hwndList, CB_SETCURSEL, 0, 0);
    }

    //
    // Enable redraw on the list window
    //

    SendMessage(hwndList, WM_SETREDRAW, TRUE, 0);
}


INT
GetSelectedCoverPage(
    PCPDATA pCPInfo,
    IN  HWND    hwndList,
    OUT LPTSTR  lptstrFullPath,
    IN  UINT    cchstrFullPath,
    OUT LPTSTR  lptstrFileName,
    IN  UINT    cchstrFileName,
    OUT BOOL * pbIsServerPage
    )

/*++

Routine Description:

    Retrieves the currently selected cover page name and returns its flags.

    Provides both its full path and short name and indicates if it is a server cover page or not.
	If the cover page is a personal cover page the returned cover page name is a full path to it.
	If the cover page is a server cover page the returned cover page is just the file name.


Arguments:

    pCPInfo - Points to cover page information
    hwndList - Handle to the list window
    lptstrFullPath - Points to a buffer for storing the selected cover page full path.
                     if lptstrFullPath is NULL the full path is not returned.
    cchstrFullPath - The size of lptstrFullPath in TCHARs.
    lptstrFileName - Points to a buffer for storing the selected cover page file name.
                     This parameter can be NULL in which case the file name will not be provided.
    cchstrFileName - The size of lptstrFileName in TCHARs.
    pbIsServerPage - Points to a BOOL variable that is set to TRUE if the selected cover page is a server cover page.

Return Value:

    Flags associated with the currently selected item
    Negative (CB_ERR) if there is an error or the CB is empty (no *.COV files)

--*/

{
    LPTSTR      pDirPath, pFilename;
    INT         selIndex, itemFlags, nameLen;
    HRESULT     hRc = E_FAIL;

    //
    // Default to empty string in case of an error
    //

    if (lptstrFullPath) {
        lptstrFullPath[0] = NUL;
    }

    if (lptstrFileName) {
        lptstrFileName[0]=NUL;
    }


    if (pCPInfo == NULL || hwndList == NULL) {
        return CB_ERR;
    }


    //
    // Get currently selected item index
    //

    // It's possible if there is no item in the combo-box (in case there are no *.COV files)
    if ((selIndex = (INT)SendMessage(hwndList, CB_GETCURSEL, 0, 0)) == CB_ERR) {
        return selIndex;
    }


    //
    // Get the flags associated with the currently selected item
    //

    itemFlags = (INT)SendMessage(hwndList, CB_GETITEMDATA, selIndex, 0);
	
	//
	// Let the caller know if this is a server cover page
    //
	*pbIsServerPage=itemFlags & CPFLAG_SERVERCP;
	

    if ((itemFlags != CB_ERR) && (lptstrFullPath || lptstrFileName)) {

        Assert((itemFlags & CPFLAG_DIRINDEX) < pCPInfo->nDirs);
        pDirPath = pCPInfo->pDirPath[itemFlags & CPFLAG_DIRINDEX];

        //
        //  assemble the full pathname for the cover page file
        //  directory prefix
        //  display name
        //  filename extension
        //
	
        
        pFilename = NULL;

        if ((nameLen = (INT)SendMessage(hwndList, CB_GETLBTEXTLEN, selIndex, 0)) != CB_ERR &&
            (pFilename = MemAlloc(sizeof(TCHAR) * (nameLen + 1))) &&
            SendMessage(hwndList, CB_GETLBTEXT, selIndex, (LPARAM) pFilename) != CB_ERR)
        {
            //
            // If the cover page filename has a suffix, we need to remove it first
            //

            if (itemFlags & CPFLAG_SUFFIX) {

                INT suffixLen = _tcslen(PersonalSuffixStr);

                if (nameLen >= suffixLen &&
                    _tcscmp(pFilename + (nameLen - suffixLen), PersonalSuffixStr) == EQUAL_STRING)
                {
                    *(pFilename + (nameLen - suffixLen)) = NUL;

                } else
                    Error(("Corrupted cover page filename: %ws\n", pFilename));

            }

            if (lptstrFullPath) 
            {
                hRc = StringCchPrintf(lptstrFullPath, cchstrFullPath, TEXT("%s%s%s"),
                                      pDirPath, 
                                      pFilename,
                                      FAX_COVER_PAGE_FILENAME_EXT);
                
                if(FAILED(hRc))
                {
                    itemFlags = CB_ERR;
                    Assert(0);
                }
            }

            if (lptstrFileName) 
            {
                hRc = StringCchPrintf(lptstrFileName, cchstrFileName, TEXT("%s%s"),
                                      pFilename,
                                      FAX_COVER_PAGE_FILENAME_EXT);
                if(FAILED(hRc))
                {
                    itemFlags = CB_ERR;
                    Assert(0);
                }
            }
		
        } else {
            itemFlags = CB_ERR;
        }

        
        MemFree(pFilename);
    }

    return itemFlags;
}



BOOL
GetServerCoverPageDirs(
	LPTSTR	lptstrServerName,
	LPTSTR	lptstrPrinterName,
    PCPDATA pCPInfo
    )

/*++

Routine Description:

    Find the directories in which the server cover pages are stored

Arguments:

  lptstrServerName - server name

Return Value:

    TRUE if successful, FALSE otherwise

--*/

{
    BOOL            status = FALSE;    
    LPTSTR          pServerDir = NULL;
    LPTSTR          pServerSubDir, p;

	Assert(pCPInfo);
	Assert(lptstrPrinterName);

	pServerDir = MemAlloc(sizeof(TCHAR) * MAX_PATH); 
	if (!pServerDir) {	
		Error(("Memory allocation failed\n"));
		goto exit;		
	}					


    if ( !GetServerCpDir(lptstrServerName, 
						 pServerDir,
						 MAX_PATH) 
	    )
	{
		Error(("GetServerCpDir failed\n"));
        goto exit;
    }
    
    pCPInfo->pDirPath[pCPInfo->nDirs] = pServerDir;
    pCPInfo->nDirs += 1;
    pCPInfo->nServerDirs += 1;
    status = TRUE;

    //
    // Find a subdirectory for the specified printer
    //

    if (p = _tcsrchr(lptstrPrinterName, FAX_PATH_SEPARATOR_CHR))
        p++;
    else
        p = lptstrPrinterName;

    if ((_tcslen(pServerDir) + _tcslen(p) + 1 < MAX_PATH ) &&
        (pServerSubDir = MemAlloc(sizeof(TCHAR) * MAX_PATH)))
    {
        _sntprintf( pServerSubDir, 
                    MAX_PATH -1,
                    TEXT("%s\\%s"),
                    pServerDir,
                    p);
	pServerSubDir[MAX_PATH -1] = _T('\0');

        pCPInfo->pDirPath[pCPInfo->nDirs] = pServerSubDir;
        pCPInfo->nDirs += 1;
        pCPInfo->nServerDirs += 1;
    }
    

    //
    // Clean up before returning to caller
    //

exit:
    if (!status) {
        MemFree(pServerDir);
    }


    return status;
}



VOID
AppendPathSeparator(
    LPTSTR  pDirPath
    )

/*++

Routine Description:

    Append a path separator (if necessary) at the end of a directory name

Arguments:

    pDirPath - Points to a directory name

Return Value:

    NONE

--*/

{
    INT length;
	TCHAR* pLast = NULL;

    //
    // Calculate the length of directory string
    //

    length = _tcslen(pDirPath);

    if (length >= MAX_PATH-1 || length < 1)
        return;

    //
    // If the last character is not a path separator,
    // append a path separator at the end
    //
	pLast = _tcsrchr(pDirPath,TEXT('\\'));
	if( !( pLast && (*_tcsinc(pLast)) == '\0' ) )
	{
		// the last character is not a separator, add one...
        _tcscat(pDirPath, TEXT("\\"));
	}

}



BOOL
UseServerCp(
	LPTSTR	lptstrServerName
    )
{
    HANDLE FaxHandle = NULL;
    BOOL Rval = FALSE;

    if (!FaxConnectFaxServer( lptstrServerName, &FaxHandle )) 
    {
		Verbose(("Can't connect to the fax server %s",lptstrServerName));
        goto exit;
    }

    if (!FaxGetPersonalCoverPagesOption( FaxHandle, &Rval)) 
    {
		Error(("FaxGetPersonalCoverPagesOption failed: %d\n", GetLastError()));
        goto exit;
    }
    else
    {
        //
        // the return value means server cover pages only
        //
        Rval = !Rval;
    }


exit:
    if (FaxHandle) 
    {
        if (!FaxClose( FaxHandle ))
		{
			Verbose(("Can't close the fax handle %x",FaxHandle));
		}
    }

    return Rval;
}



PCPDATA
AllocCoverPageInfo(
	LPTSTR	lptstrServerName,
	LPTSTR	lptstrPrinterName,
    BOOL    ServerCpOnly
    )

/*++

Routine Description:

    Allocate memory to hold cover page information

Arguments:

    lptstrServerName - server name
	ServerCpOnly	 - flag says if he function should use server CP only

Return Value:

    Pointer to a CPDATA structure, NULL if there is an error

--*/

{
    PCPDATA pCPInfo;
    INT     nDirs;
    LPTSTR  pDirPath, pUserCPDir, pSavedPtr;


    if (pCPInfo = MemAllocZ(sizeof(CPDATA))) {

        //
        // Find the directory in which the server cover pages are stored
        //

        if (! GetServerCoverPageDirs(lptstrServerName, lptstrPrinterName, pCPInfo))
            Error(("Couldn't get server cover page directories\n"));

        //
        // Find the directory in which the user cover pages are stored
        //

        if (ServerCpOnly == FALSE &&
            (pUserCPDir = pSavedPtr = GetUserCoverPageDir()))
        {
            while (pUserCPDir && pCPInfo->nDirs < MAX_COVERPAGE_DIRS) {

                LPTSTR  pNextDir = pUserCPDir;

                //
                // Find the next semicolon character
                //
				
				pNextDir = _tcschr(pNextDir,TEXT(';'));
                if (pNextDir != NUL )
				{
					_tcsnset(pNextDir,TEXT('\0'),1);
					_tcsinc(pNextDir);
				}

                //
                // Make sure the directory name is not too long
                //

                if (_tcslen(pUserCPDir) < MAX_PATH) {

                    if (! (pDirPath = MemAlloc(sizeof(TCHAR) * MAX_PATH)))
                        break;

                    pCPInfo->pDirPath[pCPInfo->nDirs++] = pDirPath;
                    _tcscpy(pDirPath, pUserCPDir);
                }

                pUserCPDir = pNextDir;
            }

            MemFree(pSavedPtr);
        }

        //
        // Append path separators at the end if necessary
        //

        for (nDirs=0; nDirs < pCPInfo->nDirs; nDirs++) {

            AppendPathSeparator(pCPInfo->pDirPath[nDirs]);
            Verbose(("Cover page directory: %ws\n", pCPInfo->pDirPath[nDirs]));
        }
    }

    return pCPInfo;
}



VOID
FreeCoverPageInfo(
    PCPDATA pCPInfo
    )

/*++

Routine Description:

    Free up memory used for cover page information

Arguments:

    pCPInfo - Points to cover page information to be freed

Return Value:

    NONE

--*/

{
    if (pCPInfo) {

        INT index;

        for (index=0; index < pCPInfo->nDirs; index++)
            MemFree(pCPInfo->pDirPath[index]);

        MemFree(pCPInfo);
    }
}
=== C:/Users/treeman/Desktop/windows nt source code\Source\Win2K3\NT\printscan\faxsrv\print\faxprint\prnwzrd\edkmdb.h ===
/*
 *	EDKMDB.H
 *
 *	Microsoft Exchange Information Store
 *	Copyright (C) 1986-1996, Microsoft Corporation
 *
 *	Contains declarations of additional properties and interfaces
 *	offered by Microsoft Exchange Information Store
 */

#ifndef	EDKMDB_INCLUDED
#define	EDKMDB_INCLUDED

/*
 *	WARNING: Many of the property id values contained within this
 *  file are subject to change.  For best results please use the
 *	literals declared here instead of the numerical values.
 */

#define pidExchangeXmitReservedMin		0x3FE0
#define pidExchangeNonXmitReservedMin	0x65E0
#define	pidProfileMin					0x6600
#define	pidStoreMin						0x6618
#define	pidFolderMin					0x6638
#define	pidMessageReadOnlyMin			0x6640
#define	pidMessageWriteableMin			0x6658
#define	pidAttachReadOnlyMin			0x666C
#define	pidSpecialMin					0x6670
#define	pidAdminMin						0x6690
#define pidSecureProfileMin				PROP_ID_SECURE_MIN

/*------------------------------------------------------------------------
 *
 *	PROFILE properties
 *
 *	These are used in profiles which contain the Exchange Messaging
 *	Service.  These profiles contain a "global section" used to store
 *	common data, plus individual sections for the transport provider,
 *	one store provider for the user, one store provider for the public
 *	store, and one store provider for each additional mailbox the user
 *	has delegate access to.
 *
 *-----------------------------------------------------------------------*/

/* GUID of the global section */

#define	pbGlobalProfileSectionGuid	"\x13\xDB\xB0\xC8\xAA\x05\x10\x1A\x9B\xB0\x00\xAA\x00\x2F\xC4\x5A"


/* Properties in the global section */

#define	PR_PROFILE_VERSION				PROP_TAG( PT_LONG, pidProfileMin+0x00)
#define	PR_PROFILE_CONFIG_FLAGS			PROP_TAG( PT_LONG, pidProfileMin+0x01)
#define	PR_PROFILE_HOME_SERVER			PROP_TAG( PT_STRING8, pidProfileMin+0x02)
#define	PR_PROFILE_HOME_SERVER_DN		PROP_TAG( PT_STRING8, pidProfileMin+0x12)
#define	PR_PROFILE_HOME_SERVER_ADDRS	PROP_TAG( PT_MV_STRING8, pidProfileMin+0x13)
#define	PR_PROFILE_USER					PROP_TAG( PT_STRING8, pidProfileMin+0x03)
#define	PR_PROFILE_CONNECT_FLAGS		PROP_TAG( PT_LONG, pidProfileMin+0x04)
#define PR_PROFILE_TRANSPORT_FLAGS		PROP_TAG( PT_LONG, pidProfileMin+0x05)
#define	PR_PROFILE_UI_STATE				PROP_TAG( PT_LONG, pidProfileMin+0x06)
#define	PR_PROFILE_UNRESOLVED_NAME		PROP_TAG( PT_STRING8, pidProfileMin+0x07)
#define	PR_PROFILE_UNRESOLVED_SERVER	PROP_TAG( PT_STRING8, pidProfileMin+0x08)
#define PR_PROFILE_BINDING_ORDER		PROP_TAG( PT_STRING8, pidProfileMin+0x09)
#define PR_PROFILE_MAX_RESTRICT			PROP_TAG( PT_LONG, pidProfileMin+0x0D)
#define	PR_PROFILE_AB_FILES_PATH		PROP_TAG( PT_STRING8, pidProfileMin+0xE)
#define PR_PROFILE_OFFLINE_STORE_PATH	PROP_TAG( PT_STRING8, pidProfileMin+0x10)
#define PR_PROFILE_OFFLINE_INFO			PROP_TAG( PT_BINARY, pidProfileMin+0x11)
#define PR_PROFILE_ADDR_INFO			PROP_TAG( PT_BINARY, pidSpecialMin+0x17)
#define PR_PROFILE_OPTIONS_DATA			PROP_TAG( PT_BINARY, pidSpecialMin+0x19)
#define PR_PROFILE_SECURE_MAILBOX		PROP_TAG( PT_BINARY, pidSecureProfileMin + 0)
#define PR_DISABLE_WINSOCK				PROP_TAG( PT_LONG, pidProfileMin+0x18)

/* Properties passed through the Service Entry to the OST */
#define PR_OST_ENCRYPTION				PROP_TAG(PT_LONG, 0x6702)

/* Values for PR_OST_ENCRYPTION */
#define OSTF_NO_ENCRYPTION              ((DWORD)0x80000000)
#define OSTF_COMPRESSABLE_ENCRYPTION    ((DWORD)0x40000000)
#define OSTF_BEST_ENCRYPTION            ((DWORD)0x20000000)

/* Properties in each profile section */

#define	PR_PROFILE_OPEN_FLAGS			PROP_TAG( PT_LONG, pidProfileMin+0x09)
#define	PR_PROFILE_TYPE					PROP_TAG( PT_LONG, pidProfileMin+0x0A)
#define	PR_PROFILE_MAILBOX				PROP_TAG( PT_STRING8, pidProfileMin+0x0B)
#define	PR_PROFILE_SERVER				PROP_TAG( PT_STRING8, pidProfileMin+0x0C)
#define	PR_PROFILE_SERVER_DN			PROP_TAG( PT_STRING8, pidProfileMin+0x14)

/* Properties in the Public Folders section */

#define PR_PROFILE_FAVFLD_DISPLAY_NAME	PROP_TAG(PT_STRING8, pidProfileMin+0x0F)
#define PR_PROFILE_FAVFLD_COMMENT		PROP_TAG(PT_STRING8, pidProfileMin+0x15)
#define PR_PROFILE_ALLPUB_DISPLAY_NAME	PROP_TAG(PT_STRING8, pidProfileMin+0x16)
#define PR_PROFILE_ALLPUB_COMMENT		PROP_TAG(PT_STRING8, pidProfileMin+0x17)

// Current value for PR_PROFILE_VERSION
#define	PROFILE_VERSION						((ULONG)0x501)

// Bit values for PR_PROFILE_CONFIG_FLAGS

#define	CONFIG_SERVICE						((ULONG)1)
#define	CONFIG_SHOW_STARTUP_UI				((ULONG)2)
#define	CONFIG_SHOW_CONNECT_UI				((ULONG)4)
#define	CONFIG_PROMPT_FOR_CREDENTIALS		((ULONG)8)

// Bit values for PR_PROFILE_CONNECT_FLAGS

#define	CONNECT_USE_ADMIN_PRIVILEGE			((ULONG)1)
#define	CONNECT_NO_RPC_ENCRYPTION			((ULONG)2)

// Bit values for PR_PROFILE_TRANSPORT_FLAGS

#define	TRANSPORT_DOWNLOAD					((ULONG)1)
#define TRANSPORT_UPLOAD					((ULONG)2)

// Bit values for PR_PROFILE_OPEN_FLAGS

#define	OPENSTORE_USE_ADMIN_PRIVILEGE		((ULONG)1)
#define OPENSTORE_PUBLIC					((ULONG)2)
#define	OPENSTORE_HOME_LOGON				((ULONG)4)
#define OPENSTORE_TAKE_OWNERSHIP			((ULONG)8)
#define OPENSTORE_OVERRIDE_HOME_MDB			((ULONG)16)
#define OPENSTORE_TRANSPORT					((ULONG)32)
#define OPENSTORE_REMOTE_TRANSPORT			((ULONG)64)

// Values for PR_PROFILE_TYPE

#define	PROFILE_PRIMARY_USER				((ULONG)1)
#define	PROFILE_DELEGATE					((ULONG)2)
#define	PROFILE_PUBLIC_STORE				((ULONG)3)
#define	PROFILE_SUBSCRIPTION				((ULONG)4)


/*------------------------------------------------------------------------
 *
 *	MDB object properties
 *
 *-----------------------------------------------------------------------*/

/* PR_MDB_PROVIDER GUID in stores table */

#define pbExchangeProviderPrimaryUserGuid	"\x54\x94\xA1\xC0\x29\x7F\x10\x1B\xA5\x87\x08\x00\x2B\x2A\x25\x17"
#define pbExchangeProviderDelegateGuid		"\x9e\xb4\x77\x00\x74\xe4\x11\xce\x8c\x5e\x00\xaa\x00\x42\x54\xe2"
#define pbExchangeProviderPublicGuid		"\x78\xb2\xfa\x70\xaf\xf7\x11\xcd\x9b\xc8\x00\xaa\x00\x2f\xc4\x5a"
#define pbExchangeProviderXportGuid			"\xa9\x06\x40\xe0\xd6\x93\x11\xcd\xaf\x95\x00\xaa\x00\x4a\x35\xc3"

// All properties in this section are readonly

// Identity of store
	// All stores
#define	PR_USER_ENTRYID					PROP_TAG( PT_BINARY, pidStoreMin+0x01)
#define	PR_USER_NAME					PROP_TAG( PT_STRING8, pidStoreMin+0x02)

	// All mailbox stores
#define	PR_MAILBOX_OWNER_ENTRYID		PROP_TAG( PT_BINARY, pidStoreMin+0x03)
#define	PR_MAILBOX_OWNER_NAME			PROP_TAG( PT_STRING8, pidStoreMin+0x04)
#define PR_OOF_STATE					PROP_TAG( PT_BOOLEAN, pidStoreMin+0x05)

	// Public stores -- name of hierarchy server
#define	PR_HIERARCHY_SERVER				PROP_TAG( PT_TSTRING, pidStoreMin+0x1B)

// Entryids of special folders
	// All mailbox stores
#define	PR_SCHEDULE_FOLDER_ENTRYID		PROP_TAG( PT_BINARY, pidStoreMin+0x06)

	// All mailbox and gateway stores
#define PR_IPM_DAF_ENTRYID				PROP_TAG( PT_BINARY, pidStoreMin+0x07)

	// Public store
#define	PR_NON_IPM_SUBTREE_ENTRYID				PROP_TAG( PT_BINARY, pidStoreMin+0x08)
#define	PR_EFORMS_REGISTRY_ENTRYID				PROP_TAG( PT_BINARY, pidStoreMin+0x09)
#define	PR_SPLUS_FREE_BUSY_ENTRYID				PROP_TAG( PT_BINARY, pidStoreMin+0x0A)
#define	PR_OFFLINE_ADDRBOOK_ENTRYID				PROP_TAG( PT_BINARY, pidStoreMin+0x0B)
#define	PR_EFORMS_FOR_LOCALE_ENTRYID			PROP_TAG( PT_BINARY, pidStoreMin+0x0C)
#define	PR_FREE_BUSY_FOR_LOCAL_SITE_ENTRYID		PROP_TAG( PT_BINARY, pidStoreMin+0x0D)
#define	PR_ADDRBOOK_FOR_LOCAL_SITE_ENTRYID		PROP_TAG( PT_BINARY, pidStoreMin+0x0E)
#define	PR_OFFLINE_MESSAGE_ENTRYID				PROP_TAG( PT_BINARY, pidStoreMin+0x0F)
#define PR_IPM_FAVORITES_ENTRYID				PROP_TAG( PT_BINARY, pidStoreMin+0x18)
#define PR_IPM_PUBLIC_FOLDERS_ENTRYID			PROP_TAG( PT_BINARY, pidStoreMin+0x19)

	// Gateway stores
#define	PR_GW_MTSIN_ENTRYID				PROP_TAG( PT_BINARY, pidStoreMin+0x10)
#define	PR_GW_MTSOUT_ENTRYID			PROP_TAG( PT_BINARY, pidStoreMin+0x11)
#define	PR_TRANSFER_ENABLED				PROP_TAG( PT_BOOLEAN, pidStoreMin+0x12)

// This property is preinitialized to 256 bytes of zeros
// GetProp on this property is guaranteed to RPC.  May be used
// to determine line speed of connection to server.
#define	PR_TEST_LINE_SPEED				PROP_TAG( PT_BINARY, pidStoreMin+0x13)

// Used with OpenProperty to get interface, also on folders
#define	PR_HIERARCHY_SYNCHRONIZER		PROP_TAG( PT_OBJECT, pidStoreMin+0x14)
#define	PR_CONTENTS_SYNCHRONIZER		PROP_TAG( PT_OBJECT, pidStoreMin+0x15)
#define	PR_COLLECTOR					PROP_TAG( PT_OBJECT, pidStoreMin+0x16)

// Used with OpenProperty to get interface for folders, messages, attachmentson
#define	PR_FAST_TRANSFER				PROP_TAG( PT_OBJECT, pidStoreMin+0x17)

// This property is available on mailbox and public stores.  If it exists
// and its value is TRUE, the store is connected to the offline store provider.
#define PR_STORE_OFFLINE				PROP_TAG( PT_BOOLEAN, pidStoreMin+0x1A)

// In transit state for store object.  This state is
// set when mail is being moved and it pauses mail delivery
// to the mail box
#define	PR_IN_TRANSIT					PROP_TAG( PT_BOOLEAN, pidStoreMin)

// Writable only with Admin rights, available on public stores and folders
#define PR_REPLICATION_STYLE			PROP_TAG( PT_LONG, pidAdminMin)
#define PR_REPLICATION_SCHEDULE			PROP_TAG( PT_BINARY, pidAdminMin+0x01)
#define PR_REPLICATION_MESSAGE_PRIORITY PROP_TAG( PT_LONG, pidAdminMin+0x02)

// Writable only with Admin rights, available on public stores
#define PR_OVERALL_MSG_AGE_LIMIT		PROP_TAG( PT_LONG, pidAdminMin+0x03 )
#define PR_REPLICATION_ALWAYS_INTERVAL	PROP_TAG( PT_LONG, pidAdminMin+0x04 )
#define PR_REPLICATION_MSG_SIZE			PROP_TAG( PT_LONG, pidAdminMin+0x05 )

// default replication style=always interval (minutes)
#define STYLE_ALWAYS_INTERVAL_DEFAULT	(ULONG) 15

// default replication message size limit (KB)
#define REPLICATION_MESSAGE_SIZE_LIMIT_DEFAULT	(ULONG) 100

// Values for PR_REPLICATION_STYLE
#define STYLE_NEVER				(ULONG) 0	// never replicate
#define STYLE_NORMAL			(ULONG) 1	// use 84 byte schedule TIB
#define STYLE_ALWAYS			(ULONG) 2	// replicate at fastest rate
#define STYLE_DEFAULT			(ULONG) -1	// default value

/*------------------------------------------------------------------------
 *
 *	INCREMENTAL CHANGE SYNCHRONIZATION
 *	folder and message properties
 *
 *-----------------------------------------------------------------------*/

#define PR_SOURCE_KEY					PROP_TAG( PT_BINARY, pidExchangeNonXmitReservedMin+0x0)
#define PR_PARENT_SOURCE_KEY			PROP_TAG( PT_BINARY, pidExchangeNonXmitReservedMin+0x1)
#define PR_CHANGE_KEY					PROP_TAG( PT_BINARY, pidExchangeNonXmitReservedMin+0x2)
#define PR_PREDECESSOR_CHANGE_LIST		PROP_TAG( PT_BINARY, pidExchangeNonXmitReservedMin+0x3)

/*------------------------------------------------------------------------
 *
 *	FOLDER object properties
 *
 *-----------------------------------------------------------------------*/

// Read only, available on all folders
#define	PR_FOLDER_CHILD_COUNT			PROP_TAG( PT_LONG, pidFolderMin)
#define	PR_RIGHTS						PROP_TAG( PT_LONG, pidFolderMin+0x01)
#define	PR_ACL_TABLE					PROP_TAG( PT_OBJECT, pidExchangeXmitReservedMin)
#define	PR_RULES_TABLE					PROP_TAG( PT_OBJECT, pidExchangeXmitReservedMin+0x1)
#define	PR_HAS_RULES				PROP_TAG( PT_BOOLEAN, pidFolderMin+0x02)

//Read only, available only for public folders
#define	PR_ADDRESS_BOOK_ENTRYID		PROP_TAG( PT_BINARY, pidFolderMin+0x03)

//Writable, available on folders in all stores
#define	PR_ACL_DATA					PROP_TAG( PT_BINARY, pidExchangeXmitReservedMin)
#define	PR_RULES_DATA				PROP_TAG( PT_BINARY, pidExchangeXmitReservedMin+0x1)
#define	PR_FOLDER_DESIGN_FLAGS		PROP_TAG( PT_LONG, pidExchangeXmitReservedMin+0x2)
#define	PR_DESIGN_IN_PROGRESS		PROP_TAG( PT_BOOLEAN, pidExchangeXmitReservedMin+0x4)
#define	PR_SECURE_ORIGINATION		PROP_TAG( PT_BOOLEAN, pidExchangeXmitReservedMin+0x5)

//Writable, available only for public folders
#define	PR_PUBLISH_IN_ADDRESS_BOOK	PROP_TAG( PT_BOOLEAN, pidExchangeXmitReservedMin+0x6)
#define	PR_RESOLVE_METHOD			PROP_TAG( PT_LONG,  pidExchangeXmitReservedMin+0x7)
#define	PR_ADDRESS_BOOK_DISPLAY_NAME	PROP_TAG( PT_TSTRING, pidExchangeXmitReservedMin+0x8)

//Writable, used to indicate locale id for eforms registry subfolders
#define	PR_EFORMS_LOCALE_ID			PROP_TAG( PT_LONG, pidExchangeXmitReservedMin+0x9)

// Writable only with Admin rights, available only for public folders
#define PR_REPLICA_LIST				PROP_TAG( PT_BINARY, pidAdminMin+0x8)
#define PR_OVERALL_AGE_LIMIT		PROP_TAG( PT_LONG, pidAdminMin+0x9)

//PR_RESOLVE_METHOD values
#define	RESOLVE_METHOD_DEFAULT			((LONG)0)	// default handling attach conflicts
#define	RESOLVE_METHOD_LAST_WRITER_WINS	((LONG)1)	// the last writer will win conflict
#define	RESOLVE_METHOD_NO_CONFLICT_NOTIFICATION ((LONG)2) // no conflict notif

//Read only, available only for public folder favorites
#define PR_PUBLIC_FOLDER_ENTRYID	PROP_TAG( PT_BINARY, pidFolderMin+0x04)

/*------------------------------------------------------------------------
 *
 *	MESSAGE object properties
 *
 *-----------------------------------------------------------------------*/

// Read only, automatically set on all messages in all stores
#define	PR_HAS_NAMED_PROPERTIES			PROP_TAG(PT_BOOLEAN, pidMessageReadOnlyMin+0x0A)

// Read only but outside the provider specific range for replication thru GDK-GWs
#define	PR_CREATOR_NAME					PROP_TAG(PT_TSTRING, pidExchangeXmitReservedMin+0x18)
#define	PR_CREATOR_ENTRYID				PROP_TAG(PT_BINARY, pidExchangeXmitReservedMin+0x19)
#define	PR_LAST_MODIFIER_NAME			PROP_TAG(PT_TSTRING, pidExchangeXmitReservedMin+0x1A)
#define	PR_LAST_MODIFIER_ENTRYID		PROP_TAG(PT_BINARY, pidExchangeXmitReservedMin+0x1B)

// Read only, appears on messages which have DAM's pointing to them
#define PR_HAS_DAMS						PROP_TAG( PT_BOOLEAN, pidExchangeXmitReservedMin+0xA)
#define PR_RULE_TRIGGER_HISTORY			PROP_TAG( PT_BINARY, pidExchangeXmitReservedMin+0x12)
#define	PR_MOVE_TO_STORE_ENTRYID		PROP_TAG( PT_BINARY, pidExchangeXmitReservedMin+0x13)
#define	PR_MOVE_TO_FOLDER_ENTRYID		PROP_TAG( PT_BINARY, pidExchangeXmitReservedMin+0x14)

// Read only, available only on messages in the public store
#define	PR_REPLICA_SERVER				PROP_TAG(PT_TSTRING, pidMessageReadOnlyMin+0x4)

// Writeable, used for recording send option dialog settings
#define	PR_DEFERRED_SEND_NUMBER			PROP_TAG( PT_LONG, pidExchangeXmitReservedMin+0xB)
#define	PR_DEFERRED_SEND_UNITS			PROP_TAG( PT_LONG, pidExchangeXmitReservedMin+0xC)
#define	PR_EXPIRY_NUMBER				PROP_TAG( PT_LONG, pidExchangeXmitReservedMin+0xD)
#define	PR_EXPIRY_UNITS					PROP_TAG( PT_LONG, pidExchangeXmitReservedMin+0xE)

// Writeable, deferred send time
#define PR_DEFERRED_SEND_TIME			PROP_TAG( PT_SYSTIME, pidExchangeXmitReservedMin+0xF)

//Writeable, intended for both folders and messages in gateway mailbox
#define	PR_GW_ADMIN_OPERATIONS			PROP_TAG( PT_LONG, pidMessageWriteableMin)

//Writeable, used for DMS messages
#define PR_P1_CONTENT					PROP_TAG( PT_BINARY, 0x1100)
#define PR_P1_CONTENT_TYPE				PROP_TAG( PT_BINARY, 0x1101)

// Properties on deferred action messages
#define	PR_CLIENT_ACTIONS		  		PROP_TAG(PT_BINARY, pidMessageReadOnlyMin+0x5)
#define	PR_DAM_ORIGINAL_ENTRYID			PROP_TAG(PT_BINARY, pidMessageReadOnlyMin+0x6)
#define PR_DAM_BACK_PATCHED				PROP_TAG( PT_BOOLEAN, pidMessageReadOnlyMin+0x7)

// Properties on deferred action error messages
#define	PR_RULE_ERROR					PROP_TAG(PT_LONG, pidMessageReadOnlyMin+0x8)
#define	PR_RULE_ACTION_TYPE				PROP_TAG(PT_LONG, pidMessageReadOnlyMin+0x9)
#define	PR_RULE_ACTION_NUMBER			PROP_TAG(PT_LONG, pidMessageReadOnlyMin+0x10)
#define PR_RULE_FOLDER_ENTRYID			PROP_TAG(PT_BINARY, pidMessageReadOnlyMin+0x11)

// Property on conflict notification indicating entryid of conflicting object
#define	PR_CONFLICT_ENTRYID				PROP_TAG(PT_BINARY, pidExchangeXmitReservedMin+0x10)

// Property on messages to indicate the language client used to create this message
#define	PR_MESSAGE_LOCALE_ID			PROP_TAG(PT_LONG, pidExchangeXmitReservedMin+0x11)

// Properties on Quota warning messages to indicate Storage quota and Excess used
#define	PR_STORAGE_QUOTA_LIMIT			PROP_TAG(PT_LONG, pidExchangeXmitReservedMin+0x15)
#define	PR_EXCESS_STORAGE_USED			PROP_TAG(PT_LONG, pidExchangeXmitReservedMin+0x16)
#define PR_SVR_GENERATING_QUOTA_MSG		PROP_TAG(PT_TSTRING, pidExchangeXmitReservedMin+0x17)

// Property affixed by delegation rule and deleted on forwards
#define PR_DELEGATED_BY_RULE			PROP_TAG( PT_BOOLEAN, pidExchangeXmitReservedMin+0x3)

// Message status bit used to indicate message is in conflict
#define	MSGSTATUS_IN_CONFLICT			((ULONG) 0x800)

/*------------------------------------------------------------------------
 *
 *	ATTACHMENT object properties
 *
 *-----------------------------------------------------------------------*/

// Appears on attachments to a message marked to be in conflict.  Identifies
// those attachments which are conflicting versions of the top level message
#define	PR_IN_CONFLICT					PROP_TAG(PT_BOOLEAN, pidAttachReadOnlyMin)


/*------------------------------------------------------------------------
 *
 *	TABLE object properties
 *
 *	Id Range: 0x662F-0x662F
 *
 *-----------------------------------------------------------------------*/

//This property can be used in a contents table to get PR_ENTRYID returned
//as a long term entryid instead of a short term entryid.
#define	PR_LONGTERM_ENTRYID_FROM_TABLE	PROP_TAG(PT_BINARY, pidSpecialMin)


/*------------------------------------------------------------------------
 *
 *	Gateway "MTE" ENVELOPE properties
 *
 *	Id Range:  0x66E0-0x66FF
 *
 *-----------------------------------------------------------------------*/

#define PR_ORIGINATOR_NAME				PROP_TAG( PT_TSTRING, pidMessageWriteableMin+0x3)
#define PR_ORIGINATOR_ADDR				PROP_TAG( PT_TSTRING, pidMessageWriteableMin+0x4)
#define PR_ORIGINATOR_ADDRTYPE			PROP_TAG( PT_TSTRING, pidMessageWriteableMin+0x5)
#define PR_ORIGINATOR_ENTRYID			PROP_TAG( PT_BINARY, pidMessageWriteableMin+0x6)
#define PR_ARRIVAL_TIME					PROP_TAG( PT_SYSTIME, pidMessageWriteableMin+0x7)
#define PR_TRACE_INFO					PROP_TAG( PT_BINARY, pidMessageWriteableMin+0x8)
#define PR_INTERNAL_TRACE_INFO 			PROP_TAG( PT_BINARY, pidMessageWriteableMin+0x12)
#define PR_SUBJECT_TRACE_INFO			PROP_TAG( PT_BINARY, pidMessageWriteableMin+0x9)
#define PR_RECIPIENT_NUMBER				PROP_TAG( PT_LONG, pidMessageWriteableMin+0xA)
#define PR_MTS_SUBJECT_ID				PROP_TAG(PT_BINARY, pidMessageWriteableMin+0xB)
#define PR_REPORT_DESTINATION_NAME		PROP_TAG(PT_TSTRING, pidMessageWriteableMin+0xC)
#define PR_REPORT_DESTINATION_ENTRYID	PROP_TAG(PT_BINARY, pidMessageWriteableMin+0xD)
#define PR_CONTENT_SEARCH_KEY			PROP_TAG(PT_BINARY, pidMessageWriteableMin+0xE)
#define PR_FOREIGN_ID					PROP_TAG(PT_BINARY, pidMessageWriteableMin+0xF)
#define PR_FOREIGN_REPORT_ID			PROP_TAG(PT_BINARY, pidMessageWriteableMin+0x10)
#define PR_FOREIGN_SUBJECT_ID			PROP_TAG(PT_BINARY, pidMessageWriteableMin+0x11)
#define PR_MTS_ID						PR_MESSAGE_SUBMISSION_ID
#define PR_MTS_REPORT_ID				PR_MESSAGE_SUBMISSION_ID


/*------------------------------------------------------------------------
 *
 *	Trace properties format
 *		PR_TRACE_INFO
 *		PR_INTERNAL_TRACE_INFO
 *
 *-----------------------------------------------------------------------*/

#define MAX_ADMD_NAME_SIZ       17
#define MAX_PRMD_NAME_SIZ       17
#define MAX_COUNTRY_NAME_SIZ    4
#define MAX_MTA_NAME_SIZ		33

#define	ADMN_PAD				3
#define	PRMD_PAD				3
#define	COUNTRY_PAD				0
#define	MTA_PAD					3

typedef struct {
    LONG     lAction;                // The routing action the tracing site
                                     // took.
    FILETIME ftArrivalTime;          // The time at which the communique
                                     // entered the tracing site.
    FILETIME ftDeferredTime;         // The time are which the tracing site
                                     // released the message.
    char     rgchADMDName[MAX_ADMD_NAME_SIZ+ADMN_PAD];           	// ADMD
    char     rgchCountryName[MAX_COUNTRY_NAME_SIZ+COUNTRY_PAD]; 	// Country
    char     rgchPRMDId[MAX_PRMD_NAME_SIZ+PRMD_PAD];              	// PRMD
    char     rgchAttADMDName[MAX_ADMD_NAME_SIZ+ADMN_PAD];       	// Attempted ADMD
    char     rgchAttCountryName[MAX_COUNTRY_NAME_SIZ+COUNTRY_PAD];  // Attempted Country
    char     rgchAttPRMDId[MAX_PRMD_NAME_SIZ+PRMD_PAD];				// Attempted PRMD
}   TRACEENTRY, FAR * LPTRACEENTRY;

typedef struct {
    ULONG       cEntries;               // Number of trace entries
    TRACEENTRY  rgtraceentry[MAPI_DIM]; // array of trace entries
} TRACEINFO, FAR * LPTRACEINFO;

typedef struct
{
	LONG		lAction;				// The routing action the tracing domain took.
	FILETIME	ftArrivalTime;			// The time at which the communique entered the tracing domain.
	FILETIME	ftDeferredTime;			// The time are which the tracing domain released the message.

    char        rgchADMDName[MAX_ADMD_NAME_SIZ+ADMN_PAD];				// ADMD
    char        rgchCountryName[MAX_COUNTRY_NAME_SIZ+COUNTRY_PAD]; 		// Country
    char        rgchPRMDId[MAX_PRMD_NAME_SIZ+PRMD_PAD];             	// PRMD
    char        rgchAttADMDName[MAX_ADMD_NAME_SIZ+ADMN_PAD];       		// Attempted ADMD
    char        rgchAttCountryName[MAX_COUNTRY_NAME_SIZ+COUNTRY_PAD];	// Attempted Country
    char        rgchAttPRMDId[MAX_PRMD_NAME_SIZ+PRMD_PAD];		        // Attempted PRMD
    char        rgchMTAName[MAX_MTA_NAME_SIZ+MTA_PAD]; 		            // MTA Name
    char        rgchAttMTAName[MAX_MTA_NAME_SIZ+MTA_PAD];		        // Attempted MTA Name
}INTTRACEENTRY, *PINTTRACEENTRY;

typedef	struct
{
	ULONG  			cEntries;					// Number of trace entries
	INTTRACEENTRY	rgIntTraceEntry[MAPI_DIM];	// array of internal trace entries
}INTTRACEINFO, *PINTTRACEINFO;


/*------------------------------------------------------------------------
 *
 *	"IExchangeModifyTable" Interface Declaration
 *
 *	Used for get/set rules and access control on folders.
 *
 *-----------------------------------------------------------------------*/


/* ulRowFlags */
#define ROWLIST_REPLACE		((ULONG)1)

#define ROW_ADD				((ULONG)1)
#define ROW_MODIFY			((ULONG)2)
#define ROW_REMOVE			((ULONG)4)
#define ROW_EMPTY			(ROW_ADD|ROW_REMOVE)

typedef struct _ROWENTRY
{
	ULONG			ulRowFlags;
	ULONG			cValues;
	LPSPropValue	rgPropVals;
} ROWENTRY, FAR * LPROWENTRY;

typedef struct _ROWLIST
{
	ULONG			cEntries;
	ROWENTRY		aEntries[MAPI_DIM];
} ROWLIST, FAR * LPROWLIST;

#define EXCHANGE_IEXCHANGEMODIFYTABLE_METHODS(IPURE)					\
	MAPIMETHOD(GetLastError)											\
		(THIS_	HRESULT						hResult,					\
				ULONG						ulFlags,					\
				LPMAPIERROR FAR *			lppMAPIError) IPURE;		\
	MAPIMETHOD(GetTable)												\
		(THIS_	ULONG						ulFlags,					\
				LPMAPITABLE FAR *			lppTable) IPURE;			\
	MAPIMETHOD(ModifyTable)												\
		(THIS_	ULONG						ulFlags,					\
				LPROWLIST					lpMods) IPURE;

#undef		 INTERFACE
#define		 INTERFACE  IExchangeModifyTable
DECLARE_MAPI_INTERFACE_(IExchangeModifyTable, IUnknown)
{
	MAPI_IUNKNOWN_METHODS(PURE)
	EXCHANGE_IEXCHANGEMODIFYTABLE_METHODS(PURE)
};
#undef	IMPL
#define IMPL

DECLARE_MAPI_INTERFACE_PTR(IExchangeModifyTable,	LPEXCHANGEMODIFYTABLE);

/* Access Control Specifics */

//Properties
#define	PR_MEMBER_ID					PROP_TAG( PT_I8, pidSpecialMin+0x01)
#define	PR_MEMBER_NAME					PROP_TAG( PT_TSTRING, pidSpecialMin+0x02)
#define	PR_MEMBER_ENTRYID				PR_ENTRYID
#define	PR_MEMBER_RIGHTS				PROP_TAG( PT_LONG, pidSpecialMin+0x03)

//Security bits
typedef DWORD RIGHTS;
#define frightsReadAny			0x0000001L
#define	frightsCreate			0x0000002L
#define	frightsEditOwned		0x0000008L
#define	frightsDeleteOwned		0x0000010L
#define	frightsEditAny			0x0000020L
#define	frightsDeleteAny		0x0000040L
#define	frightsCreateSubfolder	0x0000080L
#define	frightsOwner			0x0000100L
#define	frightsContact			0x0000200L	// NOTE: not part of rightsAll
#define	rightsNone				0x00000000
#define	rightsReadOnly			frightsReadAny
#define	rightsReadWrite			(frightsReadAny|frightsEditAny)
#define	rightsAll				0x00001FBL

/* Rules specifics */

//Property types
#define	PT_SRESTRICTION				((ULONG) 0x00FD)
#define	PT_ACTIONS					((ULONG) 0x00FE)

//Properties in rule table
#define	PR_RULE_ID						PROP_TAG( PT_I8, pidSpecialMin+0x04)
#define	PR_RULE_IDS						PROP_TAG( PT_BINARY, pidSpecialMin+0x05)
#define	PR_RULE_SEQUENCE				PROP_TAG( PT_LONG, pidSpecialMin+0x06)
#define	PR_RULE_STATE					PROP_TAG( PT_LONG, pidSpecialMin+0x07)
#define	PR_RULE_USER_FLAGS				PROP_TAG( PT_LONG, pidSpecialMin+0x08)
#define	PR_RULE_CONDITION				PROP_TAG( PT_SRESTRICTION, pidSpecialMin+0x09)
#define	PR_RULE_ACTIONS					PROP_TAG( PT_ACTIONS, pidSpecialMin+0x10)
#define	PR_RULE_PROVIDER				PROP_TAG( PT_STRING8, pidSpecialMin+0x11)
#define	PR_RULE_NAME					PROP_TAG( PT_TSTRING, pidSpecialMin+0x12)
#define	PR_RULE_LEVEL					PROP_TAG( PT_LONG, pidSpecialMin+0x13)
#define	PR_RULE_PROVIDER_DATA			PROP_TAG( PT_BINARY, pidSpecialMin+0x14)

//PR_STATE property values
#define ST_DISABLED			0x0000
#define ST_ENABLED			0x0001
#define ST_ERROR			0x0002
#define ST_ONLY_WHEN_OOF	0x0004
#define ST_KEEP_OOF_HIST	0x0008
#define ST_EXIT_LEVEL		0x0010

#define ST_CLEAR_OOF_HIST	0x80000000

//Empty restriction
#define NULL_RESTRICTION	0xff

// special RELOP for Member of DL
#define RELOP_MEMBER_OF_DL	100

//Action types
typedef enum
{
	OP_MOVE = 1,
	OP_COPY,
	OP_REPLY,
	OP_OOF_REPLY,
	OP_DEFER_ACTION,
	OP_BOUNCE,
	OP_FORWARD,
	OP_DELEGATE,
	OP_TAG,
	OP_DELETE,
	OP_MARK_AS_READ
} ACTTYPE;

// action flavors

// for OP_REPLY
#define	DO_NOT_SEND_TO_ORIGINATOR		1

//scBounceCode values
#define	BOUNCE_MESSAGE_SIZE_TOO_LARGE	(SCODE) MAPI_DIAG_LENGTH_CONSTRAINT_VIOLATD
#define BOUNCE_FORMS_MISMATCH			(SCODE) MAPI_DIAG_RENDITION_UNSUPPORTED
#define BOUNCE_ACCESS_DENIED			(SCODE) MAPI_DIAG_MAIL_REFUSED

//Message class prefix for Reply and OOF Reply templates
#define szReplyTemplateMsgClassPrefix	"IPM.Note.Rules.ReplyTemplate."
#define szOofTemplateMsgClassPrefix		"IPM.Note.Rules.OofTemplate."

//Action structure
typedef struct _action
{
	ACTTYPE		acttype;

	// to indicate which flavour of the action.
	ULONG		ulActionFlavor;

	// Action restriction
	// currently unsed and must be set to NULL
	LPSRestriction	lpRes;

	// currently unused, must be set to 0.
	LPSPropTagArray	lpPropTagArray;

	// User defined flags
	ULONG		ulFlags;

	// padding to align the union on 8 byte boundary
	ULONG		dwAlignPad;

	union
	{
		// used for OP_MOVE and OP_COPY actions
		struct
		{
			ULONG		cbStoreEntryId;
			LPENTRYID	lpStoreEntryId;
			ULONG		cbFldEntryId;
			LPENTRYID	lpFldEntryId;
		} actMoveCopy;

		// used for OP_REPLY and OP_OOF_REPLY actions
		struct
		{
			ULONG		cbEntryId;
			LPENTRYID	lpEntryId;
			GUID		guidReplyTemplate;
		} actReply;

		// used for OP_DEFER_ACTION action
		struct
		{
			ULONG		cbData;
			BYTE		*pbData;
		} actDeferAction;

		// Error code to set for OP_BOUNCE action
		SCODE			scBounceCode;

		// list of address for OP_FORWARD and OP_DELEGATE action
		LPADRLIST		lpadrlist;

		// prop value for OP_TAG action
		SPropValue		propTag;
	};
} ACTION, FAR * LPACTION;

// Rules version
#define EDK_RULES_VERSION		1

//Array of actions
typedef struct _actions
{
	ULONG		ulVersion;		// use the #define above
	UINT		cActions;
	LPACTION	lpAction;
} ACTIONS;

// message class definitions for Deferred Action and Deffered Error messages
#define szDamMsgClass		"IPC.Microsoft Exchange 4.0.Deferred Action"
#define szDemMsgClass		"IPC.Microsoft Exchange 4.0.Deferred Error"

/*
 *	Rule error codes
 *	Values for PR_RULE_ERROR
 */
#define	RULE_ERR_UNKNOWN		1			//general catchall error
#define	RULE_ERR_LOAD			2			//unable to load folder rules
#define	RULE_ERR_DELIVERY		3			//unable to deliver message temporarily
#define	RULE_ERR_PARSING		4			//error while parsing
#define	RULE_ERR_CREATE_DAE		5			//error creating DAE message
#define	RULE_ERR_NO_FOLDER		6			//folder to move/copy doesn't exist
#define	RULE_ERR_NO_RIGHTS		7			//no rights to move/copy into folder
#define	RULE_ERR_CREATE_DAM		8			//error creating DAM
#define RULE_ERR_NO_SENDAS		9			//can not send as another user
#define RULE_ERR_NO_TEMPLATE	10			//reply template is missing
#define RULE_ERR_EXECUTION		11			//error in rule execution
#define RULE_ERR_QUOTA_EXCEEDED	12

#define RULE_ERR_FIRST		RULE_ERR_UNKNOWN
#define RULE_ERR_LAST		RULE_ERR_QUOTA_EXCEEDED

/*------------------------------------------------------------------------
 *
 *	"IExchangeRuleAction" Interface Declaration
 *
 *	Used for get actions from a Deferred Action Message.
 *
 *-----------------------------------------------------------------------*/

#define EXCHANGE_IEXCHANGERULEACTION_METHODS(IPURE)						\
	MAPIMETHOD(ActionCount)												\
		(THIS_	ULONG FAR *					lpcActions) IPURE;			\
	MAPIMETHOD(GetAction)												\
		(THIS_	ULONG						ulActionNumber,				\
				LARGE_INTEGER	*			lpruleid,					\
				LPACTION FAR *				lppAction) IPURE;

#undef		 INTERFACE
#define		 INTERFACE  IExchangeRuleAction
DECLARE_MAPI_INTERFACE_(IExchangeRuleAction, IUnknown)
{
	MAPI_IUNKNOWN_METHODS(PURE)
	EXCHANGE_IEXCHANGERULEACTION_METHODS(PURE)
};
#undef	IMPL
#define IMPL

DECLARE_MAPI_INTERFACE_PTR(IExchangeRuleAction,	LPEXCHANGERULEACTION);

/*------------------------------------------------------------------------
 *
 *	"IExchangeManageStore" Interface Declaration
 *
 *	Used for store management functions.
 *
 *-----------------------------------------------------------------------*/

#define EXCHANGE_IEXCHANGEMANAGESTORE_METHODS(IPURE)					\
	MAPIMETHOD(CreateStoreEntryID)										\
		(THIS_	LPSTR						lpszMsgStoreDN,				\
				LPSTR						lpszMailboxDN,				\
				ULONG						ulFlags,					\
				ULONG FAR *					lpcbEntryID,				\
				LPENTRYID FAR *				lppEntryID) IPURE;			\
	MAPIMETHOD(EntryIDFromSourceKey)									\
		(THIS_	ULONG						cFolderKeySize,				\
				BYTE FAR *					lpFolderSourceKey,			\
				ULONG						cMessageKeySize,			\
				BYTE FAR *					lpMessageSourceKey,			\
				ULONG FAR *					lpcbEntryID,				\
				LPENTRYID FAR *				lppEntryID) IPURE;			\
	MAPIMETHOD(GetRights)												\
		(THIS_	ULONG						cbUserEntryID,				\
				LPENTRYID					lpUserEntryID,				\
				ULONG						cbEntryID,					\
				LPENTRYID					lpEntryID,					\
				ULONG FAR *					lpulRights) IPURE;			\
	MAPIMETHOD(GetMailboxTable)											\
		(THIS_	LPSTR						lpszServerName,				\
				LPMAPITABLE FAR *			lppTable,					\
				ULONG						ulFlags) IPURE;				\
	MAPIMETHOD(GetPublicFolderTable)									\
		(THIS_	LPSTR						lpszServerName,				\
				LPMAPITABLE FAR *			lppTable,					\
				ULONG						ulFlags) IPURE;

#undef		 INTERFACE
#define		 INTERFACE  IExchangeManageStore
DECLARE_MAPI_INTERFACE_(IExchangeManageStore, IUnknown)
{
	MAPI_IUNKNOWN_METHODS(PURE)
	EXCHANGE_IEXCHANGEMANAGESTORE_METHODS(PURE)
};
#undef	IMPL
#define IMPL

DECLARE_MAPI_INTERFACE_PTR(IExchangeManageStore, LPEXCHANGEMANAGESTORE);


// Properties for GetMailboxTable
#define PR_NT_USER_NAME                         PROP_TAG( PT_TSTRING, pidAdminMin+0x10)
#define PR_LOCALE_ID                            PROP_TAG( PT_LONG, pidAdminMin+0x11 )
#define PR_LAST_LOGON_TIME                      PROP_TAG( PT_SYSTIME, pidAdminMin+0x12 )
#define PR_LAST_LOGOFF_TIME                     PROP_TAG( PT_SYSTIME, pidAdminMin+0x13 )
#define PR_STORAGE_LIMIT_INFORMATION			PROP_TAG( PT_LONG, pidAdminMin+0x14 )

// Properties for GetPublicFolderTable
#define PR_FOLDER_FLAGS                         PROP_TAG( PT_LONG, pidAdminMin+0x18 )
#define	PR_LAST_ACCESS_TIME						PROP_TAG( PT_SYSTIME, pidAdminMin+0x19 )
#define PR_RESTRICTION_COUNT                    PROP_TAG( PT_LONG, pidAdminMin+0x1A )
#define PR_CATEG_COUNT                          PROP_TAG( PT_LONG, pidAdminMin+0x1B )
#define PR_CACHED_COLUMN_COUNT                  PROP_TAG( PT_LONG, pidAdminMin+0x1C )
#define PR_NORMAL_MSG_W_ATTACH_COUNT    		PROP_TAG( PT_LONG, pidAdminMin+0x1D )
#define PR_ASSOC_MSG_W_ATTACH_COUNT             PROP_TAG( PT_LONG, pidAdminMin+0x1E )
#define PR_RECIPIENT_ON_NORMAL_MSG_COUNT        PROP_TAG( PT_LONG, pidAdminMin+0x1F )
#define PR_RECIPIENT_ON_ASSOC_MSG_COUNT 		PROP_TAG( PT_LONG, pidAdminMin+0x20 )
#define PR_ATTACH_ON_NORMAL_MSG_COUNT   		PROP_TAG( PT_LONG, pidAdminMin+0x21 )
#define PR_ATTACH_ON_ASSOC_MSG_COUNT    		PROP_TAG( PT_LONG, pidAdminMin+0x22 )
#define PR_NORMAL_MESSAGE_SIZE                  PROP_TAG( PT_LONG, pidAdminMin+0x23 )
#define PR_NORMAL_MESSAGE_SIZE_EXTENDED         PROP_TAG( PT_I8, pidAdminMin+0x23 )
#define PR_ASSOC_MESSAGE_SIZE                   PROP_TAG( PT_LONG, pidAdminMin+0x24 )
#define PR_ASSOC_MESSAGE_SIZE_EXTENDED          PROP_TAG( PT_I8, pidAdminMin+0x24 )
#define PR_FOLDER_PATHNAME                      PROP_TAG(PT_TSTRING, pidAdminMin+0x25 )
#define PR_OWNER_COUNT							PROP_TAG( PT_LONG, pidAdminMin+0x26 )
#define PR_CONTACT_COUNT						PROP_TAG( PT_LONG, pidAdminMin+0x27 )

// PT_I8 version of PR_MESSAGE_SIZE defined in mapitags.h
#define	PR_MESSAGE_SIZE_EXTENDED			PROP_TAG(PT_I8, PROP_ID(PR_MESSAGE_SIZE))

/* Bits in PR_FOLDER_FLAGS */
#define MDB_FOLDER_IPM                  0x1
#define MDB_FOLDER_SEARCH               0x2
#define MDB_FOLDER_NORMAL               0x4
#define MDB_FOLDER_RULES                0x8

/* Bits used in ulFlags in GetPublicFolderTable() */
#define MDB_NON_IPM                     0x10
#define MDB_IPM                         0x20

/* Bits in PR_STORAGE_LIMIT_INFORMATION */
#define MDB_LIMIT_BELOW					0x1
#define MDB_LIMIT_ISSUE_WARNING			0x2
#define MDB_LIMIT_PROHIBIT_SEND			0x4
#define MDB_LIMIT_NO_CHECK				0x8


/*------------------------------------------------------------------------
 *
 *	"IExchangeFastTransfer" Interface Declaration
 *
 *	Used for fast transfer interface used to
 *	implement CopyTo, CopyProps, CopyFolder, and
 *	CopyMessages.
 *
 *-----------------------------------------------------------------------*/

// Transfer flags
// Use MAPI_MOVE for move option

// Transfer methods
#define	TRANSFER_COPYTO			1
#define	TRANSFER_COPYPROPS		2
#define	TRANSFER_COPYMESSAGES	3
#define	TRANSFER_COPYFOLDER		4


#define EXCHANGE_IEXCHANGEFASTTRANSFER_METHODS(IPURE)			\
	MAPIMETHOD(Config)											\
		(THIS_	ULONG				ulFlags,					\
				ULONG				ulTransferMethod) IPURE;	\
	MAPIMETHOD(TransferBuffer)									\
		(THIS_	ULONG				cb,							\
				LPBYTE				lpb,						\
				ULONG				*lpcbProcessed) IPURE;		\
	STDMETHOD_(BOOL, IsInterfaceOk)								\
		(THIS_	ULONG				ulTransferMethod,			\
				REFIID				refiid,						\
				LPSPropTagArray		lpptagList,					\
				ULONG				ulFlags) IPURE;

#undef		 INTERFACE
#define		 INTERFACE  IExchangeFastTransfer
DECLARE_MAPI_INTERFACE_(IExchangeFastTransfer, IUnknown)
{
	MAPI_IUNKNOWN_METHODS(PURE)
	EXCHANGE_IEXCHANGEFASTTRANSFER_METHODS(PURE)
};
#undef	IMPL
#define IMPL

DECLARE_MAPI_INTERFACE_PTR(IExchangeFastTransfer, LPEXCHANGEFASTTRANSFER);



/*------------------------------------------------------------------------
 *
 *	"IExchangeExportChanges" Interface Declaration
 *
 *	Used for Incremental Synchronization
 *
 *-----------------------------------------------------------------------*/

#define EXCHANGE_IEXCHANGEEXPORTCHANGES_METHODS(IPURE)		\
	MAPIMETHOD(GetLastError)								\
		(THIS_	HRESULT				hResult,				\
		 	    ULONG				ulFlags,				\
		 	    LPMAPIERROR FAR *	lppMAPIError) IPURE;	\
	MAPIMETHOD(Config)										\
		(THIS_	LPSTREAM			lpStream,				\
				ULONG				ulFlags,				\
				LPUNKNOWN			lpUnk,					\
		 		LPSRestriction		lpRestriction,			\
		 	    LPSPropTagArray		lpIncludeProps,			\
		 	    LPSPropTagArray		lpExcludeProps,			\
		 		ULONG				ulBufferSize) IPURE;	\
	MAPIMETHOD(Synchronize)									\
		(THIS_	ULONG FAR *			lpulSteps,				\
				ULONG FAR *			lpulProgress) IPURE;	\
	MAPIMETHOD(UpdateState)									\
		(THIS_	LPSTREAM			lpStream) IPURE;

#undef		 INTERFACE
#define		 INTERFACE  IExchangeExportChanges
DECLARE_MAPI_INTERFACE_(IExchangeExportChanges, IUnknown)
{
	MAPI_IUNKNOWN_METHODS(PURE)
	EXCHANGE_IEXCHANGEEXPORTCHANGES_METHODS(PURE)
};
#undef	IMPL
#define IMPL

DECLARE_MAPI_INTERFACE_PTR(IExchangeExportChanges, LPEXCHANGEEXPORTCHANGES);


typedef struct _ReadState
{
	ULONG		cbSourceKey;
	BYTE	*	pbSourceKey;
	ULONG		ulFlags;
} READSTATE, *LPREADSTATE;

/*------------------------------------------------------------------------
 *
 *	"IExchangeImportContentsChanges" Interface Declaration
 *
 *	Used for Incremental Synchronization of folder contents (i.e. messages)
 *
 *-----------------------------------------------------------------------*/


#define EXCHANGE_IEXCHANGEIMPORTCONTENTSCHANGES_METHODS(IPURE)		\
	MAPIMETHOD(GetLastError)										\
		(THIS_	HRESULT				hResult,						\
		 	    ULONG				ulFlags,						\
		 	    LPMAPIERROR FAR *	lppMAPIError) IPURE;			\
	MAPIMETHOD(Config)												\
		(THIS_	LPSTREAM				lpStream,					\
		 		ULONG					ulFlags) IPURE;				\
	MAPIMETHOD(UpdateState)											\
		(THIS_	LPSTREAM				lpStream) IPURE;			\
	MAPIMETHOD(ImportMessageChange)									\
		(THIS_	ULONG					cpvalChanges,				\
				LPSPropValue			ppvalChanges,				\
				ULONG					ulFlags,					\
				LPMESSAGE				*lppmessage) IPURE;			\
	MAPIMETHOD(ImportMessageDeletion)								\
		(THIS_	ULONG					ulFlags,					\
		 		LPENTRYLIST				lpSrcEntryList) IPURE;		\
	MAPIMETHOD(ImportPerUserReadStateChange)						\
		(THIS_	ULONG					cElements,					\
		 		LPREADSTATE			 	lpReadState) IPURE;			\
	MAPIMETHOD(ImportMessageMove)									\
		(THIS_	ULONG					cbSourceKeySrcFolder,		\
		 		BYTE FAR *				pbSourceKeySrcFolder,		\
		 		ULONG					cbSourceKeySrcMessage,		\
		 		BYTE FAR *				pbSourceKeySrcMessage,		\
		 		ULONG					cbPCLMessage,				\
		 		BYTE FAR *				pbPCLMessage,				\
		 		ULONG					cbSourceKeyDestMessage,		\
		 		BYTE FAR *				pbSourceKeyDestMessage,		\
		 		ULONG					cbChangeNumDestMessage,		\
		 		BYTE FAR *				pbChangeNumDestMessage) IPURE;


#undef		 INTERFACE
#define		 INTERFACE  IExchangeImportContentsChanges
DECLARE_MAPI_INTERFACE_(IExchangeImportContentsChanges, IUnknown)
{
	MAPI_IUNKNOWN_METHODS(PURE)
	EXCHANGE_IEXCHANGEIMPORTCONTENTSCHANGES_METHODS(PURE)
};
#undef	IMPL
#define IMPL

DECLARE_MAPI_INTERFACE_PTR(IExchangeImportContentsChanges,
						   LPEXCHANGEIMPORTCONTENTSCHANGES);

/*------------------------------------------------------------------------
 *
 *	"IExchangeImportHierarchyChanges" Interface Declaration
 *
 *	Used for Incremental Synchronization of folder hierarchy
 *
 *-----------------------------------------------------------------------*/

#define EXCHANGE_IEXCHANGEIMPORTHIERARCHYCHANGES_METHODS(IPURE)		\
	MAPIMETHOD(GetLastError)										\
		(THIS_	HRESULT				hResult,						\
				ULONG 				ulFlags,						\
				LPMAPIERROR FAR *	lppMAPIError) IPURE;			\
	MAPIMETHOD(Config)												\
		(THIS_	LPSTREAM				lpStream,					\
		 		ULONG					ulFlags) IPURE;				\
	MAPIMETHOD(UpdateState)											\
		(THIS_	LPSTREAM				lpStream) IPURE;			\
	MAPIMETHOD(ImportFolderChange)									\
		(THIS_	ULONG						cpvalChanges,			\
				LPSPropValue				ppvalChanges) IPURE;	\
	MAPIMETHOD(ImportFolderDeletion)								\
		(THIS_	ULONG						ulFlags,				\
		 		LPENTRYLIST					lpSrcEntryList) IPURE;

#undef		 INTERFACE
#define		 INTERFACE  IExchangeImportHierarchyChanges
DECLARE_MAPI_INTERFACE_(IExchangeImportHierarchyChanges, IUnknown)
{
	MAPI_IUNKNOWN_METHODS(PURE)
	EXCHANGE_IEXCHANGEIMPORTHIERARCHYCHANGES_METHODS(PURE)
};
#undef	IMPL
#define IMPL

DECLARE_MAPI_INTERFACE_PTR(IExchangeImportHierarchyChanges,
						   LPEXCHANGEIMPORTHIERARCHYCHANGES);

/*------------------------------------------------------------------------
 *
 *	Errors returned by Exchange Incremental Change Synchronization Interface
 *
 *-----------------------------------------------------------------------*/

#define MAKE_SYNC_E(err)	(MAKE_SCODE(SEVERITY_ERROR, FACILITY_ITF, err))
#define MAKE_SYNC_W(warn)	(MAKE_SCODE(SEVERITY_SUCCESS, FACILITY_ITF, warn))

#define SYNC_E_UNKNOWN_FLAGS			MAPI_E_UNKNOWN_FLAGS
#define SYNC_E_INVALID_PARAMETER		E_INVALIDARG
#define SYNC_E_ERROR					E_FAIL
#define SYNC_E_OBJECT_DELETED			MAKE_SYNC_E(0x800)
#define SYNC_E_IGNORE					MAKE_SYNC_E(0x801)
#define SYNC_E_CONFLICT					MAKE_SYNC_E(0x802)
#define SYNC_E_NO_PARENT				MAKE_SYNC_E(0x803)
#define SYNC_E_INCEST					MAKE_SYNC_E(0x804)
#define SYNC_E_UNSYNCHRONIZED			MAKE_SYNC_E(0x805)

#define SYNC_W_PROGRESS					MAKE_SYNC_W(0x820)
#define SYNC_W_CLIENT_CHANGE_NEWER		MAKE_SYNC_W(0x821)

/*------------------------------------------------------------------------
 *
 *	Flags used by Exchange Incremental Change Synchronization Interface
 *
 *-----------------------------------------------------------------------*/

#define	SYNC_UNICODE				0x01
#define SYNC_NO_DELETIONS			0x02
#define SYNC_NO_SOFT_DELETIONS		0x04
#define	SYNC_READ_STATE				0x08
#define SYNC_ASSOCIATED				0x10
#define SYNC_NORMAL					0x20
#define	SYNC_NO_CONFLICTS			0x40
#define SYNC_ONLY_SPECIFIED_PROPS	0x80
#define SYNC_NO_FOREIGN_KEYS		0x100
#define SYNC_LIMITED_IMESSAGE		0x200


/*------------------------------------------------------------------------
 *
 *	Flags used by ImportMessageDeletion and ImportFolderDeletion methods
 *
 *-----------------------------------------------------------------------*/

#define SYNC_SOFT_DELETE			0x01
#define SYNC_EXPIRY					0x02

/*------------------------------------------------------------------------
 *
 *	Flags used by ImportPerUserReadStateChange method
 *
 *-----------------------------------------------------------------------*/

#define SYNC_READ					0x01

/*------------------------------------------------------------------------
 *
 *	"IExchangeFavorites" Interface Declaration
 *
 *	Used for adding or removing favorite folders from the public store.
 *	This interface is obtained by calling QueryInterface on the folder
 *	whose EntryID is specified by PR_IPM_FAVORITES_ENTRYID on the public
 *	store.
 *
 *-----------------------------------------------------------------------*/

#define EXCHANGE_IEXCHANGEFAVORITES_METHODS(IPURE)						\
	MAPIMETHOD(GetLastError)											\
		(THIS_	HRESULT						hResult,					\
				ULONG						ulFlags,					\
				LPMAPIERROR FAR *			lppMAPIError) IPURE;		\
	MAPIMETHOD(AddFavorites)											\
		(THIS_	LPENTRYLIST					lpEntryList) IPURE;			\
	MAPIMETHOD(DelFavorites)											\
		(THIS_	LPENTRYLIST					lpEntryList) IPURE;			\

#undef		 INTERFACE
#define		 INTERFACE  IExchangeFavorites
DECLARE_MAPI_INTERFACE_(IExchangeFavorites, IUnknown)
{
	MAPI_IUNKNOWN_METHODS(PURE)
	EXCHANGE_IEXCHANGEFAVORITES_METHODS(PURE)
};

DECLARE_MAPI_INTERFACE_PTR(IExchangeFavorites,	LPEXCHANGEFAVORITES);


/*------------------------------------------------------------------------
 *
 *	Properties used by the Offline Folders API
 *
 *-----------------------------------------------------------------------*/
											  
#define PR_OFFLINE_FLAGS				PROP_TAG( PT_LONG, pidFolderMin + 0x5)
#define PR_SYNCHRONIZE_FLAGS			PROP_TAG( PT_LONG, pidExchangeNonXmitReservedMin + 0x4)
							

/*------------------------------------------------------------------------
 *
 *	Flags used by the Offline Folders API
 *
 *-----------------------------------------------------------------------*/

#define OF_AVAILABLE_OFFLINE					((ULONG) 0x00000001)
#define OF_FORCE								((ULONG) 0x80000000)

#define SF_DISABLE_STARTUP_SYNC					((ULONG) 0x00000001)


#endif	//EDKMDB_INCLUDED
=== C:/Users/treeman/Desktop/windows nt source code\Source\Win2K3\NT\printscan\faxsrv\print\faxprint\prnwzrd\mapiabobj.h ===
/*++

Copyright (c) 1997  Microsoft Corporation

Module Name:

    mapiabobj.h

Abstract:

    Class definition for CWabObj

Environment:

        Fax send wizard

Revision History:

        10/23/97 -georgeje-
                Created it.

        mm/dd/yy -author-
                description

--*/
#ifndef __MAPIABOBJ_H_
#define __MAPIABOBJ_H_


#include "abobj.h"

#define MAX_PROFILE_NAME    (64)

extern "C"
{
typedef HRESULT(STDAPICALLTYPE * LPHrQueryAllRows) (LPMAPITABLE lpTable,
                        LPSPropTagArray lpPropTags,
                        LPSRestriction lpRestriction,
                        LPSSortOrderSet lpSortOrderSet,
                        LONG crowsMax,
                        LPSRowSet FAR *lppRows);

}
class CMAPIabObj : public CCommonAbObj{
private:    
    static HINSTANCE            m_hInstMapi;

    static LPMAPISESSION        m_lpMapiSession;
    static LPMAPILOGONEX        m_lpfnMAPILogonEx;
    static LPMAPILOGOFF         m_lpfnMAPILogoff;
    static LPMAPIADDRESS        m_lpfnMAPIAddress;
    static LPMAPIFREEBUFFER     m_lpfnMAPIFreeBuffer;
    static LPMAPIINITIALIZE     m_lpfnMAPIInitialize;
    static LPMAPIUNINITIALIZE   m_lpfnMAPIUninitialize;
    static LPMAPIALLOCATEBUFFER m_lpfnMAPIAllocateBuffer;
    static LPMAPIALLOCATEMORE   m_lpfnMAPIAllocateMore;
    static LPMAPIADMINPROFILES  m_lpfnMAPIAdminProfiles;
    static LPHrQueryAllRows     m_lpfnHrQueryAllRows;

    static BOOL                 m_Initialized;

    IMsgStore * m_lpIMsgStore;          // Used to keep a referent to the exchange store
                                        // to work around a bug in office 2000. The bug causes
                                        // store to be released by the address book when in offline mode.


	// overloaded virual functions

    virtual eABType GetABType() { return AB_MAPI; };

    HRESULT     ABAllocateBuffer(ULONG cbSize,           
                                 LPVOID FAR * lppBuffer);

    // internal implementation
    BOOL    DoMapiLogon(HWND hDlg);
    BOOL    InitMapiService(HWND hDlg);
    VOID    DeinitMapiService(VOID);
    BOOL    GetDefaultMapiProfile(LPSTR,UINT);
    VOID    FreeProws(LPSRowSet prows);
    BOOL    OpenExchangeStore();

public:

    CMAPIabObj(HINSTANCE hInstance,HWND hDlg);
    ~CMAPIabObj();
    
    BOOL isInitialized() const  {   return m_Initialized;   }

    ULONG   ABFreeBuffer(LPVOID lpBuffer) ;

} ;


#endif
=== C:/Users/treeman/Desktop/windows nt source code\Source\Win2K3\NT\printscan\faxsrv\print\faxprint\prnwzrd\faxui.c ===
/*++

Copyright (c) 1996  Microsoft Corporation

Module Name:

    faxui.c

Abstract:

    Common routines for fax driver user interface

Environment:

    Fax driver user interface

Revision History:

    01/09/96 -davidx-
        Created it.

    mm/dd/yy -author-
        description

--*/

#include "faxui.h"
#include "forms.h"
#include <shlobj.h> 
#include <faxres.h>
#include <delayimp.h>

#ifdef UNICODE
    #include <shfusion.h>
#endif // UNICODE


HANDLE  g_hResource = NULL;			// Resource DLL instance handle 
HANDLE  g_hModule = NULL;			// DLL instance handle
HANDLE  g_hFxsApiModule = NULL;		// FXSAPI.DLL instance handle
HANDLE  g_hFxsTiffModule = NULL;    // FXSTIFF.DLL instance handle
INT     _debugLevel = 1;			// for debuggping purposes
BOOL    g_bDllInitialied = FALSE;   // TRUE if the DLL successfuly initialized

char    g_szDelayLoadFxsApiName[64] = {0};  // Case sensitive name of FxsApi.dll for delay load mechanism 
char    g_szDelayLoadFxsTiffName[64] = {0}; // Case sensitive name of FxsTiff.dll for delay load mechanism

#ifdef UNICODE
    BOOL    g_bSHFusionInitialized = FALSE; // Fusion initialization flag
#endif // UNICODE

FARPROC WINAPI DelayLoadHandler(unsigned dliNotify,PDelayLoadInfo pdli)
{
	switch (dliNotify)
	{
	case dliNotePreLoadLibrary:

        if(!g_hFxsApiModule || !g_hFxsTiffModule)
        {
            Assert(FALSE);
        }

		if (_strnicmp(pdli->szDll, FAX_API_MODULE_NAME_A, strlen(FAX_API_MODULE_NAME_A))==0)
		{
            //
            // Save the sensitive name DLL name for later use
            //
            strncpy(g_szDelayLoadFxsApiName, pdli->szDll, ARR_SIZE(g_szDelayLoadFxsApiName)-1);

			// trying to load FXSAPI.DLL
			return g_hFxsApiModule;
		}
		if (_strnicmp(pdli->szDll, FAX_TIFF_MODULE_NAME_A, strlen(FAX_TIFF_MODULE_NAME_A))==0)
		{
            //
            // Save the sensitive name DLL name for later use
            //
            strncpy(g_szDelayLoadFxsTiffName, pdli->szDll, ARR_SIZE(g_szDelayLoadFxsTiffName)-1);

			// trying to load FXSAPI.DLL
			return g_hFxsTiffModule;
		}
	}
	return 0;
}

PfnDliHook __pfnDliNotifyHook = DelayLoadHandler;

BOOL
DllMain(
    HANDLE      hModule,
    ULONG       ulReason,
    PCONTEXT    pContext
    )

/*++

Routine Description:

    DLL initialization procedure.

Arguments:

    hModule - DLL instance handle
    ulReason - Reason for the call
    pContext - Pointer to context (not used by us)

Return Value:

    TRUE if DLL is initialized successfully, FALSE otherwise.

--*/

{
    switch (ulReason) {

    case DLL_PROCESS_ATTACH:
		DisableThreadLibraryCalls(hModule);

        g_hModule   = hModule;
        g_hResource = GetResInstance(hModule);
        if(!g_hResource)
        {
            return FALSE;
        }

        break;

    case DLL_PROCESS_DETACH:
		HeapCleanup();
        FreeResInstance();
        break;
    }
    return TRUE;
}


BOOL
InitializeDll()
{
    INITCOMMONCONTROLSEX CommonControlsEx = {sizeof(INITCOMMONCONTROLSEX),
                                             ICC_WIN95_CLASSES|ICC_DATE_CLASSES };

    if(g_bDllInitialied)
    {
        return TRUE;
    }

	// load FXSAPI.DLL
	g_hFxsApiModule = LoadLibraryFromLocalFolder(FAX_API_MODULE_NAME, g_hModule);
	if(!g_hFxsApiModule)
	{
		return FALSE;
	}

	// load FXSTIFF.DLL
	g_hFxsTiffModule = LoadLibraryFromLocalFolder(FAX_TIFF_MODULE_NAME, g_hModule);
	if(!g_hFxsTiffModule)
	{
        FreeLibrary(g_hFxsApiModule);
        g_hFxsApiModule = NULL;
		return FALSE;
	}

#ifdef UNICODE
    if (!SHFusionInitializeFromModuleID(g_hModule, SXS_MANIFEST_RESOURCE_ID))
    {
        Verbose(("SHFusionInitializeFromModuleID failed"));
    }
    else
    {
        g_bSHFusionInitialized = TRUE;
    }
#endif // UNICODE

	if (!InitCommonControlsEx(&CommonControlsEx))
	{
		Verbose(("InitCommonControlsEx failed"));
        return FALSE;
	}

    g_bDllInitialied = TRUE;

    return TRUE;

} // InitializeDll

VOID 
UnInitializeDll()
{

#ifdef UNICODE
    if (g_bSHFusionInitialized)
    {
        SHFusionUninitialize();
        g_bSHFusionInitialized = FALSE;
    }
#endif // UNICODE

}


INT
DisplayMessageDialog(
    HWND    hwndParent,
    UINT    type,
    INT     titleStrId,
    INT     formatStrId,
    ...
    )

/*++

Routine Description:

    Display a message dialog box

Arguments:

    hwndParent - Specifies a parent window for the error message dialog
    titleStrId - Title string (could be a string resource ID)
    formatStrId - Message format string (could be a string resource ID)
    ...

Return Value:

    NONE

--*/

{
    LPTSTR  pTitle, pFormat, pMessage;
    INT     result;
    va_list ap;

    pTitle = pFormat = pMessage = NULL;

    if ((pTitle = AllocStringZ(MAX_TITLE_LEN)) &&
        (pFormat = AllocStringZ(MAX_STRING_LEN)) &&
        (pMessage = AllocStringZ(MAX_MESSAGE_LEN)))
    {
        //
        // Load dialog box title string resource
        //

        if (titleStrId == 0)
            titleStrId = IDS_ERROR_DLGTITLE;

        if(!LoadString(g_hResource, titleStrId, pTitle, MAX_TITLE_LEN))
        {
            Assert(FALSE);
        }

        //
        // Load message format string resource
        //

        if(!LoadString(g_hResource, formatStrId, pFormat, MAX_STRING_LEN))
        {
            Assert(FALSE);
        }

        //
        // Compose the message string
        //

        va_start(ap, formatStrId);
        wvsprintf(pMessage, pFormat, ap);
        va_end(ap);

        //
        // Display the message box
        //

        if (type == 0)
            type = MB_OK | MB_ICONERROR;

        result = AlignedMessageBox(hwndParent, pMessage, pTitle, type);

    } else {

        MessageBeep(MB_ICONHAND);
        result = 0;
    }

    MemFree(pTitle);
    MemFree(pFormat);
    MemFree(pMessage);
    return result;
}
=== C:/Users/treeman/Desktop/windows nt source code\Source\Win2K3\NT\printscan\faxsrv\print\faxprint\prnwzrd\faxui.h ===
/*++

Copyright (c) 1996  Microsoft Corporation

Module Name:

    faxui.h

Abstract:

    Print Wizard user interface header file

Environment:

    Fax driver user interface

Revision History:

    01/09/96 -davidx-
        Created it.

    dd-mm-yy -author-
        description

--*/


#ifndef _FAXUI_H_
#define _FAXUI_H_

#include <windows.h>
#include <fxsapip.h>

#include "faxlib.h"

#include <winddiui.h>
#include <commctrl.h>
#include <windowsx.h>
#include <prsht.h>

#ifdef FAX_SCAN_ENABLED
#include <twain.h>
#endif

#include "registry.h"
#include "coverpg.h"
#include "resource.h"
#include "faxsendw.h"


//
// Display an error message dialog
//

INT
DisplayMessageDialog(
    HWND    hwndParent,
    UINT    type,
    INT     formatStrId,
    INT     titleStrId,
    ...
    );

#define MAX_TITLE_LEN       128
#define MAX_FORMAT_LEN      128
#define MAX_MESSAGE_LEN     512

//
// Information about each recipient
//

typedef struct RECIPIENT_TAG 
{
    struct RECIPIENT_TAG*  pNext;   // Points to next recipient

    LPTSTR      pName;              // Recipient name
    LPTSTR      pAddress;           // Recipient address
    LPTSTR      pCountry;           // Recipient country
    DWORD       dwCountryId;        // Recipient country ID
    BOOL        bUseDialingRules;   // Don't dial the number as entered - use dialing rules (TAPI / Outbound routing) instead
    DWORD       dwDialingRuleId;    // If bUseDialingRules==TRUE, holds the dialing rule to use (see lineSetCurrentLocation)
    LPVOID      lpEntryId;          // Recipient MAPI/WAB EntryId after resolution
    DWORD       cbEntryId;          // Size of EntryId
    BOOL        bFromAddressBook;   // TRUE if the recipient is from address book
} RECIPIENT, *PRECIPIENT;


// Data structures used by the user mode DLL to associate private
// information with a printer device context (PDEV to be exactly)
//


typedef struct {

    BOOL            finishPressed;          // User pressed Finish in fax wizard pages
    PVOID           pCPInfo;                // For managing cover pages
    LPVOID          lpWabInit;              // pointer to wab object
    LPVOID          lpMAPIabInit;           // pointer to MPAI ab object
    DWORD           noteSubjectFlag;        // Whether note/subject fields are present on cover page
    SHORT           cpPaperSize;            // Cover page paper size
    SHORT           cpOrientation;          // Cover page orientation
#ifdef FAX_SCAN_ENABLED
    HWND            hDlgScan;               // scanning wizard page
    HMODULE         hTwain;                 // module handle for twain dll
    DSMENTRYPROC    pDsmEntry;              // pointer to the twain data source manager proc
    TW_IDENTITY     AppId;                  // application id/handle for twain
    TW_IDENTITY     DataSource;             // application id/handle for twain
    HWND            hWndTwain;              // window handle for twain
    HANDLE          hEvent;                 //
    HANDLE          hEventQuit;             //
    HANDLE          hEventXfer;             //
    HANDLE          hThread;                //
    BOOL            TwainCancelled;         // TRUE if twain UI was canceled
    HANDLE          hTwainEvent;            // signals twain detection complete
    BOOL            TwainAvail;             //
    BOOL            TwainActive;            //
    DWORD           State;                  //
#endif

    BOOL            ServerCPOnly;           //
    HANDLE          hCPEvent;               // signals fax service query for cp complete
    HANDLE          hCountryListEvent;      // signals country list enumeration complete
    HANDLE          hTAPIEvent;             // signals TAPI init complete
    TCHAR           FileName[MAX_PATH];     //
    DWORD           PageCount;              //
    HFONT           hLargeFont;             // large bold font for wizard 97

    PVOID           signature;              // Signature

    BOOL            isLocalPrinter;         // whether the printer is local
    BOOL            bSendCoverPage;

    PRECIPIENT      pRecipients;            // List of recipients
    UINT            nRecipientCount;        // Number of recipients

    DWORD           dwFlags;
    DWORD           dwRights;               // Access rights
    DWORD           dwQueueStates;          // Queue state

    DWORD           dwSupportedReceipts;            // Receipts supported by server
	DWORD			dwRecipientsLimit;				// Recipient limit for a single broadcast job.

    PFAX_TAPI_LINECOUNTRY_LIST  pCountryList;

    LPTSTR          lptstrServerName;
    LPTSTR          lptstrPrinterName;

    LPFAX_SEND_WIZARD_DATA  lpInitialData;
    LPFAX_SEND_WIZARD_DATA  lpFaxSendWizardData;

    WNDPROC wpOrigStaticControlProc; // Pointer to the original static control window procedure
                                     // we subclass to support cover page preview.

    DWORD dwComCtrlVer; // The version of COMCTRL32.DLL
    HFONT hTitleFont;
    TCHAR szTempPreviewTiff[MAX_PATH]; // The name of the temp preview tiff we pass to the viewer
    HANDLE hFaxPreviewProcess; // The process handle of the tiff viewer
} WIZARDUSERMEM, *PWIZARDUSERMEM;


#define ValidPDEVWizardUserMem(p) \
        ((p) && (p) == (p)->signature)

//
// Mark the user mode memory structure
//

#define MarkPDEVWizardUserMem(p)  \
        { (p)->signature = (p); }

//
// Free up the list of recipients associated with each fax job
//

VOID
FreeRecipientList(
    PWIZARDUSERMEM    pStrUserMem
    );

#define FreeRecipient(pRecipient) { \
            MemFree(pRecipient->pName); \
            MemFree(pRecipient->pAddress); \
            MemFree(pRecipient->pCountry); \
            if (!pRecipient->bFromAddressBook && pRecipient->lpEntryId)\
                FreeEntryID(pWizardUserMem,pRecipient->lpEntryId); \
            MemFree(pRecipient); \
        }

//
// Global variable declarations
//

extern HANDLE  g_hModule;       // DLL instance handle
extern HANDLE  g_hResource;     // Resource DLL instance handle 
extern BOOL    oleInitialized;

BOOL InitializeDll();
VOID UnInitializeDll();

DWORD
AsyncWizardThread(
    PBYTE param
    );

BOOL
InitializeTwain(
    PWIZARDUSERMEM pWizardUserMem
    );


HRESULT WINAPI
FaxFreePersonalProfileInformation(
        PFAX_PERSONAL_PROFILE   lpPersonalProfileInfo
    );

HRESULT WINAPI
FaxFreePersonalProfileInformation(
        PFAX_PERSONAL_PROFILE   lpPersonalProfileInfo
    );

HRESULT WINAPI
FaxFreeSendWizardData(
        LPFAX_SEND_WIZARD_DATA  lpFaxSendWizardData
    );

HRESULT WINAPI
FaxSendWizardUI(
        IN  DWORD                   hWndOwner,
        IN  DWORD                   dwFlags,
        IN  LPTSTR                  lptstrServerName,
        IN  LPTSTR                  lptstrPrinterName,
        IN  LPFAX_SEND_WIZARD_DATA  lpInitialData,
        OUT LPTSTR                  lptstrTifName,
        IN  UINT                    cchstrTifName,
        OUT LPFAX_SEND_WIZARD_DATA  lpFaxSendWizardData
   );




#define MyHideWindow(_hwnd) SetWindowLong((_hwnd),GWL_STYLE,GetWindowLong((_hwnd),GWL_STYLE)&~WS_VISIBLE)
#endif // !_FAXUI_H_
=== C:/Users/treeman/Desktop/windows nt source code\Source\Win2K3\NT\printscan\faxsrv\print\faxprint\prnwzrd\mapiabobj.cpp ===
/*++

Copyright (c) 1997  Microsoft Corporation

Module Name:

    cmapiabobj.cpp

Abstract:

    Interface to the MAPI address book.

Environment:

        Fax send wizard

Revision History:


--*/

#include <windows.h>
#include <prsht.h>
#include <tchar.h>

#include <mapiwin.h>
#include <mapix.h>
#include <mapiutil.h>
#include <mapi.h>

#include "faxui.h"
#include "mapiabobj.h"
#include <mapitags.h>
#include "edkmdb.h"

#define STRSAFE_NO_DEPRECATE
#include <strsafe.h>


// initialize static variables
HINSTANCE               CMAPIabObj::m_hInstMapi              = NULL;
LPMAPISESSION           CMAPIabObj::m_lpMapiSession          = NULL;
LPMAPILOGONEX           CMAPIabObj::m_lpfnMAPILogonEx        = NULL;
LPMAPILOGOFF            CMAPIabObj::m_lpfnMAPILogoff         = NULL;
LPMAPIADDRESS           CMAPIabObj::m_lpfnMAPIAddress        = NULL;
LPMAPIFREEBUFFER        CMAPIabObj::m_lpfnMAPIFreeBuffer     = NULL;
LPMAPIINITIALIZE        CMAPIabObj::m_lpfnMAPIInitialize     = NULL;
LPMAPIUNINITIALIZE      CMAPIabObj::m_lpfnMAPIUninitialize   = NULL;
LPMAPIALLOCATEBUFFER    CMAPIabObj::m_lpfnMAPIAllocateBuffer = NULL;
LPMAPIALLOCATEMORE      CMAPIabObj::m_lpfnMAPIAllocateMore   = NULL;
LPMAPIADMINPROFILES     CMAPIabObj::m_lpfnMAPIAdminProfiles  = NULL;
LPHrQueryAllRows        CMAPIabObj::m_lpfnHrQueryAllRows     = NULL;

BOOL                    CMAPIabObj::m_Initialized            = FALSE;


CMAPIabObj::CMAPIabObj(
    HINSTANCE   hInstance,
    HWND        hDlg
    ) : CCommonAbObj(hInstance)
    /*++

Routine Description:

    Constructor for CMAPIabObj class

Arguments:

    hInstance - Instance handle

Return Value:

    NONE

--*/

{
    m_Initialized = InitMapiService(hDlg);
}



VOID
CMAPIabObj::FreeProws(
    LPSRowSet prows
    )

/*++

Routine Description:

    Destroy SRowSet structure.  Copied from MAPI.

Arguments:

    hFile      - Pointer to SRowSet

Return value:

    NONE

--*/

{
    ULONG irow;

    if (!prows) {
        return;
    }

    for (irow = 0; irow < prows->cRows; ++irow) {
        m_lpfnMAPIFreeBuffer(prows->aRow[irow].lpProps);
    }

    m_lpfnMAPIFreeBuffer( prows );
}

BOOL
CMAPIabObj::GetDefaultMapiProfile(
    OUT LPSTR ProfileName,
    IN  UINT  cchProfileName  
    )
{
    BOOL rVal = FALSE;
    LPMAPITABLE pmt = NULL;
    LPSRowSet prws = NULL;
    LPSPropValue pval;
    LPPROFADMIN lpProfAdmin;
    DWORD i;
    DWORD j;

    if (FAILED(m_lpfnMAPIAdminProfiles(0, &lpProfAdmin ))) 
    {
        goto exit;
    }
    //
    // get the mapi profile table object
    //
    if (FAILED(lpProfAdmin->GetProfileTable(0, &pmt ))) 
    {
        goto exit;
    }
    //
    // get the actual profile data, FINALLY
    //
    if (FAILED(pmt->QueryRows( 4000, 0, &prws ))) 
    {
        goto exit;
    }
    //
    // enumerate the profiles looking for the default profile
    //
    for (i=0; i<prws->cRows; i++) 
    {
        pval = prws->aRow[i].lpProps;
        for (j = 0; j < 2; j++) 
        {
            if (pval[j].ulPropTag == PR_DEFAULT_PROFILE && pval[j].Value.b) 
            {
                //
                // this is the default profile
                //
                if(FAILED(StringCchCopyA(ProfileName, cchProfileName, pval[0].Value.lpszA)))
                {
                    goto exit;
                }
                
                rVal = TRUE;
                break;

            }
        }
    }

exit:
    FreeProws( prws );

    if (pmt) 
    {
        pmt->Release();
    }

    if (lpProfAdmin)
    {
        lpProfAdmin->Release();
    }
    return rVal;
}


BOOL
CMAPIabObj::DoMapiLogon(
    HWND        hDlg
    )

/*++

Routine Description:

    Logon MAPI to in order to access address book

Arguments:

    hDlg - Handle to the send fax wizard window

Return Value:

    TRUE if successful, FALSE if there is an error

--*/

{
    CHAR    strProfileName[MAX_PROFILE_NAME];
    HRESULT status;


    status = m_lpfnMAPIInitialize(NULL);

    if (status != SUCCESS_SUCCESS)
        return FALSE;


    if (!GetDefaultMapiProfile(strProfileName, ARR_SIZE(strProfileName))) 
    {
        m_lpfnMAPIUninitialize();
        return FALSE;
    }


    status = m_lpfnMAPILogonEx((ULONG_PTR) hDlg,
                                (LPTSTR)strProfileName,
                                NULL,
                                MAPI_USE_DEFAULT,
                                &m_lpMapiSession);
    if (status != SUCCESS_SUCCESS || !m_lpMapiSession ) 
    {
        m_lpfnMAPIUninitialize();
        return FALSE;
    }

    OpenExchangeStore(); // If it fails it might just indicate that exchagne is not here. 
                         // We don't fail the function in this case.

    status = m_lpMapiSession->OpenAddressBook((ULONG_PTR) hDlg,
                                        NULL,
                                        0,
                                        &m_lpAdrBook);
    if (HR_FAILED(status) || !m_lpAdrBook) 
    {
        if (m_lpMapiSession) 
        {
            m_lpMapiSession->Logoff(0,0,0);
            m_lpMapiSession->Release();
            m_lpIMsgStore->Release();
        }
        m_lpIMsgStore=NULL;
        m_lpMapiSession = NULL;
        m_lpfnMAPIUninitialize();
        return FALSE;
    }

    return TRUE;
}





BOOL CMAPIabObj::OpenExchangeStore()
{
    /*++

Routine Description:

    Open the Exchange message store and place a pointer to the IMsgStore interface 
    in CMAPIabObj::m_lpIMsgStore.
    This is done to keep the store loaded as long as we have the address book opened.
    This resolves an exchange issue where sometimes the address book is released
    alrhough we still have reference count on its interfaces.

Arguments:

    None

Return Value:

    TRUE if successful, FALSE if there is an error

--*/

    ULONG ulRow=0;
    HRESULT hr = S_OK;
    LPMAPITABLE lpStoreTable = NULL;
    LPSRowSet lprowsStores = NULL;
    SizedSPropTagArray(3, propStoreProperties)=
    {
        3,
        {PR_DISPLAY_NAME_A, PR_ENTRYID, PR_MDB_PROVIDER}

    };

    
    hr = m_lpMapiSession->GetMsgStoresTable(
                        0, // NO UNICODE
                        &lpStoreTable);


    if (FAILED(hr))
    {
        Error(("IMAPISession::GetMsgStoresTable failed. hr = 0x%08X", hr));
        goto Exit;
    }

    //
    // Now we have a pointer to the message store table. Lets find the exchange store.
    //

    Assert(NULL!=lpStoreTable);
    hr = m_lpfnHrQueryAllRows
        (
            lpStoreTable,         // pointer to the table being queried
            (LPSPropTagArray)&propStoreProperties, // properties to return in each row
            NULL,                 // no restrictions get the entire table
            NULL,                 // use default sort order
            0,                    // No limit on the number of rows retrieved
            &lprowsStores
        );

    if (FAILED(hr))
    {
         Error(("HrQueryAllRows on the stores table failed. hr = 0x%08X", hr));
        goto Exit;
    }



    //
    // Go over the rows and look for the one with PR_MDB_PROVIDER = pbExchangeProviderPrimaryUserGuid
    //

    for (ulRow=0;ulRow<lprowsStores->cRows;ulRow++)
    {

        if ( (sizeof(pbExchangeProviderPrimaryUserGuid)-1 == lprowsStores->aRow[ulRow].lpProps[2].Value.bin.cb))
        {
            
             if (!memcmp(lprowsStores->aRow[ulRow].lpProps[2].Value.bin.lpb, pbExchangeProviderPrimaryUserGuid, lprowsStores->aRow[ulRow].lpProps[2].Value.bin.cb))

             {

                 //
                 // If this is the Exchange store.
                 // Open the information store using the value of PR_ENTRYID
                 //
                 hr = m_lpMapiSession->OpenMsgStore(
                     NULL,
                     lprowsStores->aRow[ulRow].lpProps[1].Value.bin.cb,
                     (LPENTRYID)lprowsStores->aRow[ulRow].lpProps[1].Value.bin.lpb,
                     NULL, // get the standard interface IMsgStore
                     MAPI_BEST_ACCESS,
                     &m_lpIMsgStore);
                 {
                     if (FAILED(hr))
                     {
                         Error(("OpenMsgStore failed for store [%s]. hr = 0x%08X",
                                lprowsStores->aRow[ulRow].lpProps[0].Value.lpszA,
                                hr));
                         goto Exit;
                     }
                 }
             }
        }
    }
    
Exit:

    if (lpStoreTable)
    {
        lpStoreTable->Release();
        lpStoreTable = NULL;
    }

    if (lprowsStores)
    {
        FreeProws(lprowsStores);
        lprowsStores = NULL;
    }

    return SUCCEEDED(hr);
}


BOOL
CMAPIabObj::InitMapiService(
    HWND    hDlg
    )

/*++

Routine Description:

    Initialize Simple MAPI services 

Arguments:

    hDlg - Handle to the send fax wizard window

Return Value:

    TRUE if successful, FALSE otherwise

NOTE:

    Every successful call to this function must be balanced
    by a call to DeinitMapiService.

--*/

{
    BOOL result = FALSE;

    m_lpIMsgStore=NULL;
    if(!IsOutlookDefaultClient())
    {
        return result;
    }

    //
    // Load MAPI32.DLL into memory if necessary
    //

    if ((m_hInstMapi == NULL) &&
        (m_hInstMapi = LoadLibrary(TEXT("MAPI32.DLL"))))
    {
        //
        // Get pointers to various Simple MAPI functions
        //

        m_lpfnMAPILogonEx = (LPMAPILOGONEX) GetProcAddress(m_hInstMapi, "MAPILogonEx");
        m_lpfnMAPILogoff = (LPMAPILOGOFF) GetProcAddress(m_hInstMapi, "MAPILogoff");
        m_lpfnMAPIAddress = (LPMAPIADDRESS) GetProcAddress(m_hInstMapi, "MAPIAddress");
        m_lpfnMAPIFreeBuffer = (LPMAPIFREEBUFFER) GetProcAddress(m_hInstMapi, "MAPIFreeBuffer");
        m_lpfnMAPIInitialize = (LPMAPIINITIALIZE) GetProcAddress(m_hInstMapi, "MAPIInitialize");
        m_lpfnMAPIUninitialize = (LPMAPIUNINITIALIZE) GetProcAddress(m_hInstMapi, "MAPIUninitialize");
        m_lpfnMAPIAllocateBuffer = (LPMAPIALLOCATEBUFFER)   GetProcAddress(m_hInstMapi, "MAPIAllocateBuffer");
        m_lpfnMAPIAllocateMore = (LPMAPIALLOCATEMORE)   GetProcAddress(m_hInstMapi, "MAPIAllocateMore");
        m_lpfnMAPIAdminProfiles = (LPMAPIADMINPROFILES)GetProcAddress( m_hInstMapi,"MAPIAdminProfiles" );
        m_lpfnHrQueryAllRows = (LPHrQueryAllRows)GetProcAddress(m_hInstMapi,"HrQueryAllRows@24");


        //
        // Begins a simple MAPI session and obtain session handle and pointer
        //

        if (m_lpfnMAPILogonEx == NULL        ||
            m_lpfnMAPILogoff == NULL         ||
            m_lpfnMAPIAddress == NULL        ||
            m_lpfnMAPIFreeBuffer == NULL     ||
            m_lpfnMAPIInitialize == NULL     || 
            m_lpfnMAPIUninitialize == NULL   ||
            m_lpfnMAPIAllocateBuffer == NULL ||
            m_lpfnMAPIAllocateMore == NULL   ||
            m_lpfnMAPIAdminProfiles == NULL  ||
            m_lpfnHrQueryAllRows == NULL     ||
            !DoMapiLogon(hDlg))
        {
            //
            // Clean up properly in case of error
            //

            m_lpMapiSession = NULL;
            FreeLibrary(m_hInstMapi);
            m_hInstMapi = NULL;
        }
        else
        {
            result = TRUE;
        }
    }

#ifdef UNICODE
    //
    // The Outlook Address Book supports Unicode since version 10 (Office XP)
    // So we check the version
    //
    HKEY hRegKey = NULL;

    hRegKey = OpenRegistryKey(HKEY_LOCAL_MACHINE, REGKEY_OUTLOOK_CUR_VER, FALSE, KEY_READ);
    if(!hRegKey)
    {
        return result;
    }

    LPWSTR szCurVer = NULL;
    szCurVer = GetRegistryString(hRegKey, TEXT(""), TEXT(""));
    RegCloseKey(hRegKey);

    if(!szCurVer)
    {
        return result;
    }

    //
    // The Outlook version string is Outlook.Application.X
    // Where is X the version
    //
    LPWSTR ptr = wcsrchr(szCurVer, TEXT('.'));
    if(ptr)
    {
        ptr = _wcsinc(ptr);
        DWORD dwVer = _wtoi(ptr);

        if(dwVer >= 10)
        {
            m_bUnicode = TRUE;
        }
    }

    MemFree (szCurVer);

#endif // UNICODE

    return result;
}

VOID
CMAPIabObj::DeinitMapiService(
    VOID
    )

/*++

Routine Description:

    Deinitialize Simple MAPI services if necessary

Arguments:

    NONE

Return Value:

    NONE

--*/

{
    if (m_hInstMapi != NULL) 
        {
            if (m_lpAdrBook)
            {
                m_lpAdrBook->Release();
                m_lpAdrBook = NULL;
            }
            if (m_lpIMsgStore)
            {   
                m_lpIMsgStore->Release();
                m_lpIMsgStore = NULL;
            }
            if (m_lpMapiSession) 
            {
                m_lpMapiSession->Logoff(0,0,0); 
                m_lpMapiSession->Release();
                m_lpMapiSession = NULL;
            }

            m_lpfnMAPIUninitialize();
            FreeLibrary(m_hInstMapi);
            m_hInstMapi = NULL;
    }
}

CMAPIabObj::~CMAPIabObj()
/*++

Routine Description:

    Destructor for CMAPIabObj class

Arguments:

    NONE

Return Value:

    NONE

--*/
{
    DeinitMapiService();
}

HRESULT
CMAPIabObj::ABAllocateBuffer(
    ULONG cbSize,           
    LPVOID FAR * lppBuffer  
    )

/*++

Routine Description:


Arguments:


Return Value:
--*/

{
    return m_lpfnMAPIAllocateBuffer( cbSize, lppBuffer );
}


ULONG
CMAPIabObj::ABFreeBuffer(
    LPVOID lpBuffer
    )
{
    return m_lpfnMAPIFreeBuffer(lpBuffer);
}


extern "C"
VOID
FreeMapiEntryID(
    PWIZARDUSERMEM  pWizardUserMem,
    LPENTRYID       lpEntryId
                )
/*++

Routine Description:

    C wrapper for MAPI Free

Arguments:

    pWizardUserMem - pointer to WIZARDUSERMEM structure
    lpEntryID - pointer to EntryId

Return Value:
    
      NONE

--*/
{
    CMAPIabObj * lpCMAPIabObj = (CMAPIabObj *) pWizardUserMem->lpMAPIabInit;
    lpCMAPIabObj->ABFreeBuffer(lpEntryId);      
}

extern "C"
BOOL
CallMAPIabAddress(
    HWND hDlg,
    PWIZARDUSERMEM pWizardUserMem,
    PRECIPIENT * ppNewRecipient
    )
/*++

Routine Description:

    C wrapper for CMAPIabObj->Address

Arguments:

    hDlg - parent window handle.
    pWizardUserMem - pointer to WIZARDUSERMEM structure
    ppNewRecipient - list to add new recipients to.

Return Value:

    TRUE if all of the entries have a fax number.
    FALSE otherwise.

--*/

{
    CMAPIabObj * lpCMAPIabObj = (CMAPIabObj *) pWizardUserMem->lpMAPIabInit;

    return lpCMAPIabObj->Address(
                hDlg,
                pWizardUserMem->pRecipients,
                ppNewRecipient
                );

}

extern "C"
LPTSTR
CallMAPIabAddressEmail(
    HWND hDlg,
    PWIZARDUSERMEM pWizardUserMem
    )
/*++

Routine Description:

    C wrapper for CMAPIabObj->AddressEmail

Arguments:

    hDlg - parent window handle.
    pWizardUserMem - pointer to WIZARDUSERMEM structure

Return Value:

    TRUE if found one appropriate E-mail
    FALSE otherwise.

--*/

{
    CMAPIabObj * lpCMAPIabObj = (CMAPIabObj *) pWizardUserMem->lpMAPIabInit;

    return lpCMAPIabObj->AddressEmail(
                hDlg
                );

}

extern "C"
LPVOID
InitializeMAPIAB(
    HINSTANCE hInstance,
    HWND      hDlg
    )
/*++

Routine Description:

    Initialize the MAPI.

Arguments:

    hInstance - instance handle.

Return Value:

    NONE
--*/

{
    CMAPIabObj * lpCMAPIabObj = new (std::nothrow) CMAPIabObj ( hInstance, hDlg );

    if ((lpCMAPIabObj!=NULL) && (!lpCMAPIabObj->isInitialized()))   // constructor failed
    {
        delete lpCMAPIabObj;
        lpCMAPIabObj = NULL;
    }

    return (LPVOID) lpCMAPIabObj ;
}

extern "C"
VOID
UnInitializeMAPIAB(
    LPVOID lpVoid
    )
/*++

Routine Description:

    UnInitialize the MAPI.

Arguments:

    NONE

Return Value:

    NONE
--*/

{
    CMAPIabObj * lpCMAPIabObj = (CMAPIabObj *) lpVoid;

    delete lpCMAPIabObj;
}
=== C:/Users/treeman/Desktop/windows nt source code\Source\Win2K3\NT\printscan\faxsrv\print\faxprint\prnwzrd\mapiabutil.h ===
#ifndef _MAPIABUTIL_H_
#define _MAPIABUTIL_H_

LPVOID 
InitializeMAPIAB(
    HINSTANCE hInstance,
	HWND	  hDlg
    );

VOID 
UnInitializeMAPIAB( 
    LPVOID 
    );

BOOL
CallMAPIabAddress(
    HWND            hDlg,
    PWIZARDUSERMEM  pWizardUserMem,
    PRECIPIENT *    ppNewRecipient
    );

LPTSTR
CallMAPIabAddressEmail(
    HWND            hDlg,
    PWIZARDUSERMEM   pWizardUserMem
    );

BOOL
FreeMapiEntryID(
    PWIZARDUSERMEM  pWizardUserMem,
    LPVOID			lpEntryId
    );

BOOL
FreeWabEntryID(
    PWIZARDUSERMEM  pWizardUserMem,
    LPVOID			lpEntryId
    );
    
#endif
=== C:/Users/treeman/Desktop/windows nt source code\Source\Win2K3\NT\printscan\faxsrv\print\faxprint\prnwzrd\mapiwrap.h ===
/*++

Copyright (c) 1996  Microsoft Corporation

Module Name:

    mapiwrap.h

Abstract:

    Utility functions for working with MAPI

Environment:

	Windows XP fax driver user interface

Revision History:

	09/18/96 -davidx-
		Created it.

	dd-mm-yy -author-
		description

--*/


#ifndef _MAPIWRAP_H_
#define _MAPIWRAP_H_

#include <mapix.h>
#include <mapi.h>

#define MAPICALL(p) (p)->lpVtbl


//
// MAPI address type for fax addresses
//

//#define FAX_ADDRESS_TYPE    TEXT("FAX:")

//
// Determine whether MAPI is available
//

BOOL
IsMapiAvailable(
    VOID
    );

//
// Initialize Simple MAPI services if necessary
//

BOOL
InitMapiService(
    HWND    hDlg
    );

//
// Deinitialize Simple MAPI services if necessary
//

VOID
DeinitMapiService(
    VOID
    );

//
// Call MAPIAddress to display the address dialog
//

BOOL
CallMapiAddress(
    HWND            hDlg,
    PWIZARDUSERMEM  pWizardUserMem,
    PULONG          pnRecips,
    lpMapiRecipDesc *ppRecips
    );

//
// Expanded the selected addresses and insert them into the recipient list view
//

BOOL
InterpretSelectedAddresses(
    HWND            hDlg,
    PWIZARDUSERMEM  pWizardUserMem,
    HWND            hwndLV,
    ULONG           nRecips,
    lpMapiRecipDesc pRecips
    );

//
// Function points to Simple MAPI entrypoints
//

typedef SCODE (*LPSCMAPIXFROMSMAPI)(LHANDLE, ULONG, LPCIID, LPMAPISESSION *);

extern LPMAPILOGONEX        lpfnMAPILogon;
extern LPMAPILOGOFF         lpfnMAPILogoff;
extern LPMAPIADDRESS        lpfnMAPIAddress;
extern LPMAPIFREEBUFFER     lpfnMAPIFreeBuffer;
extern LPSCMAPIXFROMSMAPI   lpfnScMAPIXFromSMAPI;
extern ULONG                lhMapiSession;
extern LPMAPISESSION        lpMapiSession;

#endif	// !_MAPIWRAP_H_
=== C:/Users/treeman/Desktop/windows nt source code\Source\Win2K3\NT\printscan\faxsrv\print\faxprint\prnwzrd\registry.c ===
/*++

Copyright (c) 1999  Microsoft Corporation

Module Name:

    Registry.c

Abstract:

Environment:
        Fax driver

Revision History:
    10/13/99 -v-sashab-
        Created it.


--*/


#include "faxui.h"
#include "Registry.h"

#include "faxreg.h"
#include "registry.h"
#include "faxlib.h"

HRESULT
SaveLastReciptInfo(
    DWORD   dwReceiptDeliveryType,
    LPTSTR  szReceiptAddress
    )

/*++

Routine Description:

    Save the information about the last recipt in the registry

Arguments:
    
      dwReceiptDeliveryType - specifice delivery type: REGVAL_RECEIPT_MSGBOX, REGVAL_RECEIPT_EMAIL, REGVAL_RECEIPT_NO_RECEIPT
      szReceiptDeliveryProfile - specifies delivery profile (e-mail address)
    
Return Value:

    S_OK - if success
    E_FAIL  - otherwise

--*/

{
    HKEY    hRegKey = NULL;
    HRESULT hResult = S_OK;

   
    if (hRegKey =  OpenRegistryKey(HKEY_CURRENT_USER, REGKEY_FAX_USERINFO, TRUE,REG_READWRITE)  ) 
    {
        if (dwReceiptDeliveryType == DRT_NONE)
        {
            SetRegistryDword(hRegKey, REGVAL_RECEIPT_NO_RECEIPT, 1);
        }
        else
        {
            SetRegistryDword(hRegKey, REGVAL_RECEIPT_NO_RECEIPT, 0);
        }

        if (dwReceiptDeliveryType & DRT_GRP_PARENT)
        {
            SetRegistryDword(hRegKey, REGVAL_RECEIPT_GRP_PARENT, 1);
        }
        else
        {
            SetRegistryDword(hRegKey, REGVAL_RECEIPT_GRP_PARENT, 0);
        }

        if (dwReceiptDeliveryType & DRT_MSGBOX)
        {
            SetRegistryDword(hRegKey, REGVAL_RECEIPT_MSGBOX, 1);
        }
        else
        {
            SetRegistryDword(hRegKey, REGVAL_RECEIPT_MSGBOX, 0);
        }

        if (dwReceiptDeliveryType & DRT_EMAIL)
        {
            SetRegistryDword(hRegKey, REGVAL_RECEIPT_EMAIL, 1);
        }
        else
        {
            SetRegistryDword(hRegKey, REGVAL_RECEIPT_EMAIL, 0);
        }

        if (dwReceiptDeliveryType & DRT_ATTACH_FAX)
        {
            SetRegistryDword(hRegKey, REGVAL_RECEIPT_ATTACH_FAX, 1);
        }
        else
        {
            SetRegistryDword(hRegKey, REGVAL_RECEIPT_ATTACH_FAX, 0);
        }

        if ((dwReceiptDeliveryType & DRT_EMAIL) && szReceiptAddress)
        {
            //
            // Save profile (address) only for mail receipt types
            //
            // if this function failes, it prints a warning message inside
            SetRegistryString(hRegKey, REGVAL_RECEIPT_ADDRESS, szReceiptAddress);
        }

        RegCloseKey(hRegKey);
    }
    else
    {
        Error(("SaveLastReciptInfo: Can't open registry for READ/WRITE\n"));
        hResult = E_FAIL;
    }

    return hResult;
}


HRESULT
RestoreLastReciptInfo(
    DWORD  * pdwReceiptDeliveryType,
    LPTSTR * lpptReceiptAddress
    )

/*++

Routine Description:

    Restores the information about the last receipt from the registry

Arguments:

    pdwReceiptDeliveryType   - specifice delivery type: REGVAL_RECEIPT_MSGBOX, REGVAL_RECEIPT_EMAIL, REGVAL_RECEIPT_NO_RECEIPT
    szReceiptDeliveryProfile - specifies delivery profile (e-mail address)

Return Value:

    S_OK - if success
    E_FAIL  - otherwise

--*/

{
    HKEY    hRegKey = NULL;
    HRESULT hResult = S_OK;

    Assert(pdwReceiptDeliveryType);
    Assert(lpptReceiptAddress);

    *pdwReceiptDeliveryType = DRT_NONE;
    *lpptReceiptAddress = NULL;

    if ((hRegKey = GetUserInfoRegKey(REGKEY_FAX_USERINFO, REG_READWRITE)))
    {
        if (!GetRegistryDword(hRegKey, REGVAL_RECEIPT_NO_RECEIPT) &&
            !GetRegistryDword(hRegKey, REGVAL_RECEIPT_GRP_PARENT) &&
            !GetRegistryDword(hRegKey, REGVAL_RECEIPT_MSGBOX)      &&
            !GetRegistryDword(hRegKey, REGVAL_RECEIPT_EMAIL)) 
        {
            Verbose (("RestoreLastReciptInfo runs for the very first time\n"));
        }
        else 
        {
            if (GetRegistryDword(hRegKey, REGVAL_RECEIPT_GRP_PARENT) == 1)
            {
                *pdwReceiptDeliveryType |= DRT_GRP_PARENT;
            }
            if (GetRegistryDword(hRegKey, REGVAL_RECEIPT_MSGBOX) == 1)
            {
                *pdwReceiptDeliveryType |= DRT_MSGBOX;
            }
            if (GetRegistryDword(hRegKey, REGVAL_RECEIPT_EMAIL) == 1)
            {
                *pdwReceiptDeliveryType |= DRT_EMAIL;
            }
            if (GetRegistryDword(hRegKey, REGVAL_RECEIPT_ATTACH_FAX) == 1)
            {
                *pdwReceiptDeliveryType |= DRT_ATTACH_FAX;
            }
            if (!(*lpptReceiptAddress = GetRegistryString(hRegKey, REGVAL_RECEIPT_ADDRESS, TEXT(""))))
            {
                Error(("Memory allocation failed\n"));
                hResult = HRESULT_FROM_WIN32(ERROR_NOT_ENOUGH_MEMORY);
                goto error;
            }
        }

        RegCloseKey(hRegKey);
    }
    else
    {
        Error(("SaveLastReciptInfo: Can't open registry for READ/WRITE\n"));
        hResult = E_FAIL;
        goto error;
    }
    goto exit;
error:
    if (hRegKey)
    {
        RegCloseKey(hRegKey);
    }
    if (*lpptReceiptAddress)
    {
        MemFree(*lpptReceiptAddress);
    }
exit:
    return hResult;
}


HRESULT
SaveLastRecipientInfo(
    PFAX_PERSONAL_PROFILE pfppRecipient,
    DWORD                 dwLastRecipientCountryId
    )

/*++

Routine Description:

    Save the information about the last recipient in the registry

Arguments:

  pfppRecipient             [in] - Recipient personal info
  dwLastRecipientCountryId  [in] - Last recipient country ID
    
Return Value:

    S_OK   - if success
    E_FAIL - otherwise

--*/

{
    HKEY    hRegKey = NULL;
    HRESULT hResult = S_OK;

    Assert(pfppRecipient);

    if (hRegKey =  OpenRegistryKey(HKEY_CURRENT_USER, REGKEY_FAX_USERINFO, TRUE,REG_READWRITE) ) 
    {
        SetRegistryString(hRegKey, REGVAL_LAST_RECNAME, pfppRecipient->lptstrName);
        SetRegistryString(hRegKey, REGVAL_LAST_RECNUMBER, pfppRecipient->lptstrFaxNumber);
        SetRegistryDword( hRegKey, REGVAL_LAST_COUNTRYID, dwLastRecipientCountryId);
        RegCloseKey(hRegKey);
    }
    else
    {
        Error(("SaveLastRecipientInfo: Can't open registry for READ/WRITE\n"));
        hResult = E_FAIL;
    }

    return hResult;
}


HRESULT
RestoreLastRecipientInfo(
    DWORD*                  pdwNumberOfRecipients,
    PFAX_PERSONAL_PROFILE*  lppFaxSendWizardData,
    DWORD*                 pdwLastRecipientCountryId
    )

/*++

Routine Description:

    Restores the information about the last recipient from the registry

Arguments:

  pdwNumberOfRecipients      [out] - Number of recipients
  lppFaxSendWizardData       [out] - Recipient personal info
  pdwLastRecipientCountryId  [out] - Last recipient country ID

Return Value:

    S_OK - if success
    E_FAIL  - otherwise

--*/

{
    HKEY    hRegKey = NULL;
    LPTSTR  lptstrName = NULL, lptstrFaxNumber = NULL;
    HRESULT hResult = S_OK;

    //
    // validate parameters
    //

    Assert (pdwNumberOfRecipients);
    Assert (lppFaxSendWizardData);
    Assert (pdwLastRecipientCountryId);

    *pdwNumberOfRecipients = 0;
    *lppFaxSendWizardData = NULL;
    *pdwLastRecipientCountryId = 0;

    if (hRegKey = GetUserInfoRegKey(REGKEY_FAX_USERINFO, REG_READONLY)) 
    {
        if (!(lptstrName    = GetRegistryString(hRegKey, REGVAL_LAST_RECNAME, TEXT(""))) ||
            !(lptstrFaxNumber = GetRegistryString(hRegKey, REGVAL_LAST_RECNUMBER, TEXT(""))))
        {
             Error(("GetRegistryString failed\n"));
             hResult = HRESULT_FROM_WIN32(ERROR_NOT_ENOUGH_MEMORY);
             goto error;
        }
        if (!(*lppFaxSendWizardData = MemAllocZ(sizeof(FAX_PERSONAL_PROFILE))))
        {
            Error(("Memory allocation failed\n"));
            hResult = HRESULT_FROM_WIN32(ERROR_NOT_ENOUGH_MEMORY);
            goto error;
        }
        
        *pdwLastRecipientCountryId = GetRegistryDword(hRegKey, REGVAL_LAST_COUNTRYID);

        *pdwNumberOfRecipients = 1;
        (*lppFaxSendWizardData)[0].lptstrName = lptstrName;
        (*lppFaxSendWizardData)[0].lptstrFaxNumber = lptstrFaxNumber;


        RegCloseKey(hRegKey);
    }
    else
    {
        Error(("RestoreLastRecipientInfo: Can't open registry for READ/WRITE\n"));
        hResult = E_FAIL;
        goto error;
    }

    goto exit;
error:
    MemFree ( lptstrName    );
    MemFree ( lptstrFaxNumber );
    if (hRegKey)
        RegCloseKey(hRegKey);
exit:
    return hResult;

}


HRESULT
RestoreCoverPageInfo(
    LPTSTR * lpptstrCoverPageFileName
    )
/*++

Routine Description:

    Restores the information about the cover page from the registry

Arguments:

    lpptstrCoverPageFileName - pointer to restore coverd page file name

Return Value:

    S_OK if success
    error otherwise (may return HRESULT_FROM_WIN32(ERROR_NOT_ENOUGH_MEMORY))

--*/
{
    HKEY    hRegKey = NULL;
    HRESULT hResult = S_OK;

    //
    // validate parameter
    //

    Assert(lpptstrCoverPageFileName);

    //
    // Retrieve the most recently used cover page settings
    //


    *lpptstrCoverPageFileName = NULL;

    if (hRegKey = GetUserInfoRegKey(REGKEY_FAX_USERINFO, REG_READONLY)) 
    {
        if (!(*lpptstrCoverPageFileName = GetRegistryString(hRegKey, REGVAL_COVERPG, TEXT("") )))
        {
            Error(("Memory allocation failed\n"));
            hResult = HRESULT_FROM_WIN32(ERROR_NOT_ENOUGH_MEMORY);
            goto error;
        }
        RegCloseKey(hRegKey);
    }
    else
    {
        Error(("RestoreCoverPageInfo: Can't open registry for READ/WRITE\n"));
        hResult = E_FAIL;
        goto error;
    }
    goto exit;
error:
    if (hRegKey)
        RegCloseKey(hRegKey);
exit:
    return hResult;
}

HRESULT
SaveCoverPageInfo(
    LPTSTR lptstrCoverPageFileName
    )
/*++

Routine Description:

    Save the information about the cover page settings in the registry

Arguments:
    
      lptstrCoverPageFileName - pointer to cover page file name
    
Return Value:

    S_OK - if success
    E_FAIL  - otherwise

--*/
{
    HKEY    hRegKey = NULL;
    HRESULT hResult = S_OK;

    if (hRegKey =  OpenRegistryKey(HKEY_CURRENT_USER, REGKEY_FAX_USERINFO, TRUE,REG_READWRITE)  ) {

        SetRegistryString(hRegKey, REGVAL_COVERPG, lptstrCoverPageFileName);
        RegCloseKey(hRegKey);
    }
    else
    {
        Error(("SaveCoverPageInfo: Can't open registry for READ/WRITE\n"));
        hResult = E_FAIL;
    }

    return hResult;
}

HRESULT 
RestoreUseDialingRules(
    BOOL* pbUseDialingRules,
    BOOL* pbUseOutboundRouting
)
/*++

Routine Description:

    Restore UseDialingRules / UseOutboundRouting option from the registry

Arguments:
    
      pbUseDialingRules    - [out] TRUE if the option is selected
      pbUseOutboundRouting - [out] TRUE if the option is selected
    
Return Value:

    S_OK - if success
    E_FAIL  - otherwise

--*/
{
    HKEY    hRegKey = NULL;
    HRESULT hResult = S_OK;

    Assert(pbUseDialingRules && pbUseOutboundRouting);

    *pbUseDialingRules = FALSE;
    hRegKey = GetUserInfoRegKey(REGKEY_FAX_USERINFO, REG_READONLY);
    if(hRegKey)
    {
        *pbUseDialingRules = GetRegistryDword(hRegKey, REGVAL_USE_DIALING_RULES);
        *pbUseOutboundRouting = GetRegistryDword(hRegKey, REGVAL_USE_OUTBOUND_ROUTING);
        RegCloseKey(hRegKey);
    }
    else
    {
        Error(("RestoreUseDialingRules: GetUserInfoRegKey failed\n"));
        hResult = E_FAIL;
    }
    return hResult;
}

HRESULT 
SaveUseDialingRules(
    BOOL bUseDialingRules,
    BOOL bUseOutboundRouting
)
/*++

Routine Description:

    Save UseDialingRules / UseOutboundRouting option in the registry

Arguments:
    
      bUseDialingRules    - [in] TRUE if the option selected
      bUseOutboundRouting - [in] TRUE if the option selected
    
Return Value:

    S_OK - if success
    E_FAIL  - otherwise

--*/
{
    HKEY    hRegKey = NULL;
    HRESULT hResult = S_OK;

    hRegKey = GetUserInfoRegKey(REGKEY_FAX_USERINFO, REG_READWRITE);
    if(hRegKey)
    {
        if(!SetRegistryDword(hRegKey, REGVAL_USE_DIALING_RULES, bUseDialingRules))
        {
            Error(("SaveUseDialingRules: SetRegistryDword failed\n"));
            hResult = E_FAIL;
        }
        if(!SetRegistryDword(hRegKey, REGVAL_USE_OUTBOUND_ROUTING, bUseOutboundRouting))
        {
            Error(("SaveUseDialingRules: SetRegistryDword failed\n"));
            hResult = E_FAIL;
        }
        RegCloseKey(hRegKey);
    }
    else
    {
        Error(("SaveUseDialingRules: GetUserInfoRegKey failed\n"));
        hResult = E_FAIL;
    }
    return hResult;
}

BOOL 
IsOutlookDefaultClient()
/*++

Routine Description:

    Determine if the Microsoft Outlook is default mail client    
    
Return Value:

    TRUE   - if yes
    FALSE  - otherwise

--*/
{
    BOOL  bRes = FALSE;
    DWORD dwRes = ERROR_SUCCESS;
    HKEY  hRegKey = NULL;
    TCHAR tszMailClient[64] = {0};
    DWORD dwType;
    DWORD dwSize = sizeof(tszMailClient)-2;

    dwRes = RegOpenKeyEx(HKEY_LOCAL_MACHINE,
                         REGKEY_MAIL_CLIENT,
                         0,
                         KEY_READ,
                         &hRegKey);
    if(ERROR_SUCCESS != dwRes)
    {
        Error(("IsOutlookDefaultClient: RegOpenKeyEx failed: ec = 0x%X\n", GetLastError()));
        return bRes;
    }

    dwRes = RegQueryValueEx(hRegKey,
                            NULL,
                            NULL,
                            &dwType,
                            (LPBYTE)tszMailClient,
                            &dwSize);
    if(ERROR_SUCCESS != dwRes)
    {
        Error(("IsOutlookDefaultClient: RegQueryValueEx failed: ec = 0x%X\n", GetLastError()));
    }
    else
    {
        if((REG_SZ == dwType) && !_tcsicmp(tszMailClient, REGVAL_MS_OUTLOOK))
        {
            bRes = TRUE;
        }
    }

    RegCloseKey(hRegKey);

    return bRes;
}
=== C:/Users/treeman/Desktop/windows nt source code\Source\Win2K3\NT\printscan\faxsrv\print\faxprint\prnwzrd\registry.h ===
#ifndef __REGISTRY_H_
#define __REGISTRY_H_


#include <windows.h>
#include <fxsapip.h>
#include <faxsendw.h>

#ifdef __cplusplus
extern "C"{
#endif 

HRESULT
SaveLastReciptInfo(
	DWORD	dwReceiptDeliveryType,
	LPTSTR	szReceiptAddress
);
HRESULT	
RestoreLastReciptInfo(
    DWORD* pdwReceiptDeliveryType,
    LPTSTR * lpptReceiptDeliveryProfile
);

HRESULT	
SaveLastRecipientInfo(
    PFAX_PERSONAL_PROFILE pfppRecipient,
    DWORD                 dwLastRecipientCountryId
);
HRESULT 
RestoreLastRecipientInfo(
    DWORD*                 pdwNumberOfRecipients,
    PFAX_PERSONAL_PROFILE* lppFaxSendWizardData,
    DWORD*                 pdwLastRecipientCountryId
);

HRESULT 
RestoreCoverPageInfo(
    LPTSTR* lpptstrCoverPageFileName
);
HRESULT	
SaveCoverPageInfo(
    LPTSTR lptstrCoverPageFileName
);

HRESULT	
RestoreUseDialingRules(
    BOOL* pbUseDialingRules,
    BOOL* pbUseOutboundRouting
);

HRESULT	
SaveUseDialingRules(
    BOOL bUseDialingRules,
    BOOL bUseOutboundRouting
);

BOOL IsOutlookDefaultClient();

#ifdef __cplusplus
}
#endif


#endif
=== C:/Users/treeman/Desktop/windows nt source code\Source\Win2K3\NT\printscan\faxsrv\print\faxprint\prnwzrd\resource.h ===
//////////////////////////////////////////////////////
//                                                  //
// Fax Send Wizard resource ID file                 //
// It compiles as part of FxsRes.dll                //
// All the IDs should be in range                   //
//                                                  //
// [6000 - 6999]                                    //
//                                                  //
//////////////////////////////////////////////////////

#define IDS_ERR_TAPI_CPL_LAUNCH         6000 
#define IDS_SEND_SPECIFIC               6001 
#define IDS_MULTIPLE_RECIPIENTS         6002 
#define IDS_NONE                        6003 
#define IDS_SCAN_ERROR_TITLE            6004 
#define IDS_SCAN_ERROR_BW               6005 
#define IDS_WIZARD_TITLE                6006 
#define IDS_ERR_CPL_LAUNCH              6007 
#define IDS_NO_COUNTRY                  6008 
#define IDS_ERROR_DLGTITLE              6009 
#define IDS_BAD_RECIPIENT_NAME          6010 
#define IDS_BAD_RECIPIENT_NUMBER        6011 
#define IDS_BAD_RECIPIENT_AREACODE      6012 
#define IDS_BAD_ADDRESS_TYPE            6013 
#define IDS_COVERPAGE_FOR               6014 
#define IDS_ERROR_RECEIPT_DL            6015 
#define IDS_ERROR_RECEIPT_SMTP          6016 
#define IDS_NOTE_SUBJECT_EMPTY          6017 
#define IDS_COLUMN_RECIPIENT_NAME       6018 
#define IDS_COLUMN_RECIPIENT_NUMBER     6019 
#define IDS_FAX_SERVER                  6020 
#define IDS_ERROR_SERVER_RETRIEVE       6021 
#define IDS_USERCP_SUFFIX               6022 
#define IDS_NO_FAXSERVER                6023 
#define IDS_HOME                        6024 
#define IDS_BUSINESS                    6025 
#define IDS_ERROR_RECIPIENT_NAME        6026 
#define IDS_ERROR_AREA_CODE             6027 
#define IDS_WIZ_RECIPIENT_TITLE         6028 
#define IDS_WIZ_RECIPIENT_SUB           6029 
#define IDS_WIZ_COVERPAGE_TITLE         6030 
#define IDS_WIZ_COVERPAGE_SUB           6031 
#define IDS_WIZ_SCAN_TITLE              6032 
#define IDS_WIZ_SCAN_SUB                6033 
#define IDS_WIZ_FAXOPTS_TITLE           6034 
#define IDS_WIZ_FAXOPTS_SUB             6035 
#define IDS_WIZ_FINISH_TITLE            6036 
#define IDS_WIZ_FINISH_SUB              6037 
#define IDS_WIZ_WELCOME_TITLE           6038 
#define IDS_WIZ_WELCOME_SUB             6039 
#define IDS_WIZ_TIME_FORMAT             6040 
#define IDS_LARGEFONT_NAME              6041 
#define IDS_LARGEFONT_SIZE              6042 
#define IDS_SEND_DISCOUNT               6043 
#define IDS_SEND_ASAP                   6044 
// 
// Icon and bitmap resource IDs 
// 
#define IDI_ARROW                       6046 
#define IDB_FAXWIZ_BITMAP               6047 
#define IDB_WATERMARK_16                6048 
#define IDB_WATERMARK_256               6049 
#define IDB_FAXWIZ_WATERMARK            6050 
#define IDI_USERINFO                    6051 
#define IDC_SEND_ASAP                   6052 
#define IDC_SEND_AT_CHEAP               6053 
#define IDC_SEND_AT_TIME                6054 
#define IDC_BILLING_CODE                6059 
#define IDC_RUN_FAXCFG                  6060 
#define IDC_EMAIL                       6061 
#define IDC_SENDTIME                    6062 
#define IDC_STATIC_ATTACH_NOTE          6067 
#define IDI_WZRD_INFO                   6068 
#define IDC_WZRD_NOTE_ICON              6069 
#define IDD_WIZARD_WELCOME              6071 
#define IDD_WIZARD_CHOOSE_WHO           6072 
#define IDD_WIZARD_CHOOSE_CP            6073 
#define IDD_WIZARD_SCAN                 6074 
#define IDD_WIZARD_FAXOPTS              6075 
#define IDD_WIZARD_CONGRATS             6076 
#define IDD_CHOOSE_FAXNUMBER            6077 
#define IDD_WIZFIRSTTIME                6078 
#define IDD_WIZARD_USERINFO             6079 
#define IDD_WIZARD_FAXRECEIPT           6080 
#define IDD_WIZ_ADDRESS                 6081 
#define IDD_WIZARD_WELCOME_NOWIZARD97       6082 
#define IDD_WIZARD_CHOOSE_WHO_NOWIZARD97    6083 
#define IDD_WIZARD_CHOOSE_CP_NOWIZARD97     6084 
#define IDD_WIZARD_SCAN_NOWIZARD97          6085 
#define IDD_WIZARD_FAXOPTS_NOWIZARD97       6086 
#define IDD_WIZARD_CONGRATS_NOWIZARD97      6087 
#define IDD_WIZARD_FAXRECEIPT_NOWIZARD97    6088 
#define IDC_STATIC_HEADER_TITLE         6089 
#define IDC_STATIC_HEADER_SUB           6090 
#define IDC_BITMAP_STATIC               6091 
#define IDC_WIZ_WELCOME_BMP             6092 
#define IDC_WIZ_WELCOME_TITLE           6093 
#define IDC_WIZ_WELCOME_DESCR           6094 
#define IDC_WIZ_WELCOME_FAXSEND         6095 
#define IDC_WIZ_WELCOME_NOFAXSEND       6096 
#define IDC_CHOOSE_NAME_EDIT            6097 
#define IDC_CHOOSE_ADDRBOOK             6098 
#define IDC_CHOOSE_COUNTRY_COMBO        6099 
#define IDC_CHOOSE_AREA_CODE_EDIT       6100 
#define IDC_CHOOSE_NUMBER_EDIT          6101 
#define IDC_USE_DIALING_RULE            6102 
#define IDC_CHOOSE_ADD                  6103 
#define IDC_CHOOSE_REMOVE               6104 
#define IDC_CHOOSE_RECIPIENT_LIST       6105 
#define IDC_CHOOSE_CP_USER_INFO         6106 
#define IDC_CHOOSE_EDIT                 6107 
#define IDC_COMBO_DIALING_RULES         6108 
#define IDC_DIALING_RULES               6109 
#define IDC_BRACKET_LEFT                6110 
#define IDC_BRACKET_RIGHT               6111 
#define IDC_CHOOSE_CP_CHECK             6112 
#define IDC_CHOOSE_CP_LIST              6113 
#define IDC_STATIC_CHOOSE_CP_SUBJECT    6114 
#define IDC_CHOOSE_CP_SUBJECT           6115 
#define IDC_STATIC_CHOOSE_CP_NOTE       6116 
#define IDC_CHOOSE_CP_NOTE              6117 
#define IDC_STATIC_CHOOSE_TEMPLATE      6118 
#define IDC_STATIC_CP_PREVIEW           6119 
#define IDC_STATIC_WIZ_FAXOPTS_WHEN     6120 
#define IDC_WIZ_FAXOPTS_ASAP            6121 
#define IDC_WIZ_FAXOPTS_DISCOUNT        6122 
#define IDC_WIZ_FAXOPTS_SPECIFIC        6123 
#define IDC_WIZ_FAXOPTS_SENDTIME        6124 
#define IDC_STATIC_WIZ_FAXOPTS_BILLING  6125 
#define IDC_WIZ_FAXOPTS_BILLING         6126 
#define IDC_WIZ_FAXOPTS_DATE            6127 
#define IDC_WIZ_FAXOPTS_NONE_RECEIPT    6128 
#define IDC_WIZ_FAXOPTS_MSGBOX          6129 
#define IDC_WIZ_FAXOPTS_EMAIL           6130 
#define IDC_WIZ_FAXOPTS_ADDRBOOK        6131 
#define IDC_WIZ_FAXOPTS_EMAIL_EDIT      6132 
#define IDC_WIZ_FAXOPTS_GRP_PARENT      6133 
#define IDS_WIZ_FAXRECEIPT_TITLE        6134 
#define IDS_WIZ_FAXRECEIPT_SUB          6135 
#define IDC_HORIZONTAL_SEPARATOR        6136 
#define IDC_STATIC_WIZ_PRIORITY         6137 
#define IDC_WIZ_FAXOPTS_PRIORITY_HIGH   6138 
#define IDC_WIZ_FAXOPTS_PRIORITY_NORMAL 6139 
#define IDC_WIZ_FAXOPTS_PRIORITY_LOW    6140 
#define IDC_WIZ_FAXOPTS_ATTACH_FAX      6141 
#define IDC_SCAN_PAGE                   6142 
#define IDC_PAGE_COUNT                  6143 
#define IDC_DATA_SOURCE                 6144 
#define IDC_DISPLAY_NAME                6145 
#define IDC_BUSINESS_FAX                6146 
#define IDC_HOME_FAX                    6147 
#define IDC_OTHER_FAX                   6148 
#define IDC_ALLBUS                      6149 
#define IDC_ALLHOME                     6150 
#define IDC_ALLOTHER                    6151 
#define IDC_BUSINESS_FAX_NUM            6152 
#define IDC_HOME_FAX_NUM                6153 
#define IDC_OTHER_FAX_NUM               6154 
#define IDS_CHOOSE_FAX_NUMBER           6155 
#define IDC_WIZ_CONGRATS_BMP            6156 
#define IDC_STATIC_WIZ_CONGRATS_READY   6157 
#define IDC_STATIC_WIZ_CONGRATS_FROM    6158 
#define IDC_WIZ_CONGRATS_FROM           6159 
#define IDC_STATIC_WIZ_CONGRATS_TIME    6160 
#define IDC_WIZ_CONGRATS_TIME           6161 
#define IDC_WIZ_CONGRATS_SUBJECT        6162 
#define IDC_STATIC_WIZ_CONGRATS_SUBJECT 6163 
#define IDC_STATIC_WIZ_CONGRATS_COVERPG 6164 
#define IDC_WIZ_CONGRATS_COVERPG        6165 
#define IDC_WIZ_CONGRATS_RECIPIENT_LIST 6166 
#define IDC_WIZ_CONGRATS_PREVIEW_FAX    6167 
#define IDS_PREVIEW_FAILURE             6169 
#define IDS_PLEASE_CLOSE_FAX_PREVIEW    6170 
#define IDS_PREVIEW_NOTHING_TO_PREVIEW  6171 
#define IDC_STATIC_WIZ_USERINFO_FULLNAME        6172 
#define IDC_WIZ_USERINFO_FULLNAME               6173 
#define IDC_STATIC_WIZ_USERINFO_FAX_NUMBER      6174 
#define IDC_WIZ_USERINFO_FAX_NUMBER             6175 
#define IDC_STATIC_WIZ_USERINFO_MAILBOX         6176 
#define IDC_WIZ_USERINFO_MAILBOX                6177 
#define IDC_STATIC_WIZ_USERINFO_TITLE           6178 
#define IDC_WIZ_USERINFO_TITLE                  6179 
#define IDC_STATIC_WIZ_USERINFO_COMPANY         6180 
#define IDC_WIZ_USERINFO_COMPANY                6181 
#define IDC_STATIC_WIZ_USERINFO_OFFICE          6182 
#define IDC_WIZ_USERINFO_OFFICE                 6183 
#define IDC_STATIC_WIZ_USERINFO_DEPT            6184 
#define IDC_WIZ_USERINFO_DEPT                   6185 
#define IDC_STATIC_WIZ_USERINFO_HOME_PHONE      6186 
#define IDC_WIZ_USERINFO_HOME_PHONE             6187 
#define IDC_STATIC_WIZ_USERINFO_WORK_PHONE      6188 
#define IDC_WIZ_USERINFO_WORK_PHONE             6189 
#define IDC_BUT_WIZ_ADDRESS                     6190 
#define IDC_WIZ_USERINFO_ADDRESS                6191 
#define IDC_STATIC_WIZ_USERINFO_BILLING_CODE    6192 
#define IDC_WIZ_USERINFO_BILLING_CODE           6193 
#define IDS_WIZ_USERINFO_TITLE                  6194 
#define IDS_WIZ_USERINFO_SUB                    6195 
#define IDCSTATIC_USERINFO_ICON                 6196 
#define IDC_USER_INFO_JUST_THIS_TIME            6197 
#define IDD_CHECK_FAX_NUMBER                    6198 
#define IDC_CHECK_FAX_NUMBER                    6199 
#define IDC_CHECK_FAX_COUNTRY                   6200 
#define IDC_CHECK_FAX_CITY                      6201 
#define IDC_CHECK_FAX_LOCAL                     6202 
#define IDC_CHECK_FAX_RECIPIENT_NAME            6203 
#define IDS_BAD_RECIPIENT_COUNTRY_CODE          6204 
#define IDS_BAD_RECEIPT_FORM                    6205 
#define IDS_BAD_RECEIPT_EMAIL_ADD               6206 
#define IDR_MENU                                6207 
#define IDM_RECIPT_EDIT                         6208 
#define IDM_RECIPT_DELETE                       6209 
#define IDS_ERROR_SERVER_BLOCKED                6210 
#define IDS_ERROR_NO_SUBMIT_ACCESS              6211 
#define IDS_CPPREVIEW_NAME                      6212 
#define IDS_CPPREVIEW_FAXNUMBER                 6213 
#define IDS_CPPREVIEW_COMPANY                   6214 
#define IDS_CPPREVIEW_ADDRESS                   6215 
#define IDS_CPPREVIEW_CITY                      6216 
#define IDS_CPPREVIEW_STATE                     6217 
#define IDS_CPPREVIEW_ZIP                       6218 
#define IDS_CPPREVIEW_COUNTRY                   6219 
#define IDS_CPPREVIEW_TITLE                     6220 
#define IDS_CPPREVIEW_DEPARTMENT                6221 
#define IDS_CPPREVIEW_OFFICE                    6222 
#define IDS_CPPREVIEW_TOLIST                    6223 
#define IDS_CPPREVIEW_NUMPAGES                  6224 
#define IDS_CPPREVIEW_TIMESENT                  6225 
#define IDS_CPPREVIEW_SUBJECT                   6226 
#define IDS_CPPREVIEW_NOTE                      6227 
#define IDS_ADDRESS_BOOK_CAPTION                6228 
#define IDS_USE_OUTBOUND_ROUTING                6229 
#define IDS_INVALID_RECIPIENT_NUMBER            6230 
#define IDS_ERR_NO_ADDRESS_BOOK                 6231 
#define IDS_NO_TIF_ASSOCIATION                  6232
#define IDS_WZRD_RECIPIENTS_LIMIT				6233
#define IDS_CPPREVIEW_EMAIL						6234

//////////////////////////////////////////////////////
//                                                  //
// Fax Send Wizard resource ID file                 //
// It compiles as part of FxsRes.dll                //
// All the IDs should be in range                   //
//                                                  //
// [6000 - 6999]                                    //
//                                                  //
//////////////////////////////////////////////////////
=== C:/Users/treeman/Desktop/windows nt source code\Source\Win2K3\NT\printscan\faxsrv\print\faxprint\prnwzrd\sources.inc ===
!IF 0

Copyright (c) 1996  Microsoft Corporation

!ENDIF

!include ..\..\..\..\faxsrc.inc

TARGETNAME=$(FAXWZRD)
TARGETPATH=obj
TARGETTYPE=DYNLINK
DLLDEF=$O\PrnWzrd.DEF

C_DEFINES = $(C_DEFINES) -DTARGET_NAME=$(TARGETNAME)


!if 0
NTPROFILEINPUT=yes
!endif

UMTYPE=windows

SYNCHRONIZE_BLOCK=1

DLLENTRY=_DllMainCRTStartup 
USE_CRTDLL=1
NTKEEPRESOURCETMPFILES=1

USE_STL=1
USE_NATIVE_EH=1

PRECOMPILED_INCLUDE=..\faxui.h
PRECOMPILED_PCH=precomp.pch
PRECOMPILED_OBJ=precomp.obj

INCLUDES=\
  ..\; \
  $(INCLUDES); \
  ..\res; \
  ..\..\inc; \
  $(FAXROOT)\faxcover\renderer; \
  $(FAXROOT)\admin\faxclient\cfg; \
  $(FAXROOT)\tiff\inc

!ifndef NOUNICODE

C_DEFINES=$(C_DEFINES) -DUNICODE -D_UNICODE
LINKLIBS_INT=\
  $(SDK_LIB_PATH)\user32.lib   \
  $(SDK_LIB_PATH)\kernel32.lib \
  $(SDK_LIB_PATH)\winspool.lib \
  $(SDK_LIB_PATH)\gdi32.lib    \
  $(SDK_LIB_PATH)\shell32.lib  \
  $(SDK_LIB_PATH)\advapi32.lib \
  $(SDK_LIB_PATH)\comdlg32.lib \
  $(SDK_LIB_PATH)\tapi32.lib   \
  $(SDK_LIB_PATH)\ole32.lib    \
  $(SDK_LIB_PATH)\uuid.lib     \
  $(SDK_LIB_PATH)\imm32.lib    \
  $(SDK_LIB_PATH)\Version.lib  \
  $(FAXLIB)\*\$(WINFAX).lib                \
  $(FAXLIB)\*\faxrend.lib                  \
  $(FAXLIB)\*\$(FAXTIFF).lib               \
  $(FAXROOT)\util\unicode\$(O)\faxutil.lib


LINKLIBS=..\..\lib\umwinnt\$O\faxlib.lib $(LINKLIBS)

!else
NO_NTDLL=1
C_DEFINES=$(C_DEFINES) -DWIN__95

LINKLIBS_INT=\
  $(SDK_LIB_PATH)\user32.lib   \
  $(SDK_LIB_PATH)\kernel32.lib \
  $(SDK_LIB_PATH)\winspool.lib \
  $(SDK_LIB_PATH)\gdi32.lib    \
  $(SDK_LIB_PATH)\shell32.lib  \
  $(SDK_LIB_PATH)\advapi32.lib \
  $(SDK_LIB_PATH)\comctl32.lib \
  $(SDK_LIB_PATH)\comdlg32.lib \
  $(SDK_LIB_PATH)\tapi32.lib   \
  $(SDK_LIB_PATH)\ole32.lib    \
  $(SDK_LIB_PATH)\uuid.lib     \
  $(SDK_LIB_PATH)\imm32.lib    \
  $(FAXLIB95)\*\faxrend.lib	           \
  $(FAXLIB95)\*\$(WINFAX).lib          \
  $(FAXLIB)\*\$(FAXTIFF).lib               \
  $(FAXROOT)\util\ansii\$(O)\faxutil.lib

LINKLIBS=..\..\lib\umwin95\$O\faxlib.lib $(LINKLIBS)

!endif

TARGETLIBS=\
  $(LINKLIBS_INT)
  
DELAYLOAD=FXSAPI.DLL;FXSTIFF.DLL

DLOAD_ERROR_HANDLER=FXSWZRD.DLL

SOURCES=\
  ..\faxui.c       \
  ..\wizard.c      \
  ..\coverpg.c     \
  ..\tapiutil.c    \
  ..\mapiabobj.cpp \
  ..\cwabobj.cpp   \
  ..\abobj.cpp     \
  ..\async.c       \
  ..\registry.c	   \
  ..\version.rc
=== C:/Users/treeman/Desktop/windows nt source code\Source\Win2K3\NT\printscan\faxsrv\print\faxprint\prnwzrd\wizard.c ===
/*++

Copyright (c) 1996  Microsoft Corporation

Module Name:

    wizard.c

Abstract:

    Send fax wizard dialogs

Environment:

    Fax driver user interface

Revision History:

    01/19/96 -davidx-
        Created it.

    08/99 - 11/99 -v-sashab-
        Ported to ANSI.
        Changed UI.
        Added external interface for drivers.

    mm/dd/yy -author-
        description

--*/


#include "faxui.h"
#include "tapiutil.h"
#include "Registry.h"
#include <fxsapip.h>
#include "prtcovpg.h"
#include "tiff.h"
#include "cwabutil.h"
#include "mapiabutil.h"
#include  <shellapi.h>
#include  <imm.h>
#include "faxutil.h"
#include "faxsendw.h"
#include "shlwapi.h"
#include <MAPI.H>
#include <tifflib.h>
#include <faxuiconstants.h>

#define STRSAFE_NO_DEPRECATE
#include <strsafe.h>

#include "..\..\..\admin\cfgwzrd\FaxCfgWzExp.h"

#define USE_LOCAL_SERVER_OUTBOUND_ROUTING       0xfffffffe

#define PACKVERSION(major,minor) MAKELONG(minor,major)
#define IE50_COMCTRL_VER PACKVERSION(5,80)

DWORD GetDllVersion(LPCTSTR lpszDllName);


enum {  DEFAULT_INITIAL_DATA     = 1,
        DEFAULT_RECEIPT_INFO     = 2,
        DEFAULT_RECIPIENT_INFO   = 4,
        DEFAULT_CV_INFO          = 8,
        DEFAULT_SENDER_INFO      = 16
     };

#define REGVAL_FAKE_COVERPAGE        TEXT("FakeCoverPage")
#define REGVAL_FAKE_SERVER_BASED_CP  TEXT("FakeServerBasedCP")
#define REGVAL_FAKE_TESTS_COUNT      TEXT("FakeTestsCount")
#define REGVAL_KEY_FAKE_TESTS        REGKEY_FAX_USERINFO TEXT("\\WzrdHack")

//
// Globals
//

PWIZARDUSERMEM  g_pWizardUserMem;
HWND            g_hwndPreview = NULL;

static DWORD    g_dwCurrentDialingLocation = USE_LOCAL_SERVER_OUTBOUND_ROUTING;
static DWORD    g_dwMiniPreviewLandscapeWidth;
static DWORD    g_dwMiniPreviewLandscapeHeight;
static DWORD    g_dwMiniPreviewPortraitWidth;
static DWORD    g_dwMiniPreviewPortraitHeight;
static WORD     g_wCurrMiniPreviewOrientation;
static BOOL     g_bPreviewRTL = FALSE;


BOOL FillCoverPageFields(PWIZARDUSERMEM pWizardUserMem, PCOVERPAGEFIELDS pCPFields);

BOOL
ErrorMessageBox(
    HWND hwndParent,
    UINT nErrorMessage,
    UINT uIcon
    );

BOOL
DisplayFaxPreview(
            HWND hWnd,
            PWIZARDUSERMEM pWizardUserMem,
            LPTSTR lptstrPreviewFile);

LRESULT APIENTRY PreviewSubclassProc(
    HWND hwnd,
    UINT uMsg,
    WPARAM wParam,
    LPARAM lParam);

BOOL DrawCoverPagePreview(
            HDC hdc,
            HWND hwndPrev,
            LPCTSTR lpctstrCoverPagePath,
            WORD wCPOrientation);

BOOL EnableCoverDlgItems(PWIZARDUSERMEM pWizardUserMem, HWND hDlg);

BOOL IsCanonicalNumber(LPCTSTR lptstrNumber);

static BOOL IsNTSystemVersion();
static BOOL GetTextualSid( const PSID pSid, LPTSTR tstrTextualSid, LPDWORD cchSidSize);
static DWORD FormatCurrentUserKeyPath( const PTCHAR tstrRegRoot,
                                       PTCHAR* ptstrCurrentUserKeyPath);

DWORD GetControlRect(HWND  hCtrl, PRECT pRc);

INT_PTR
CALLBACK
FaxUserInfoProc(
    HWND    hDlg,
    UINT    message,
    WPARAM  wParam,
    LPARAM  lParam
    );


static HRESULT
FreeRecipientInfo(
        DWORD * pdwNumberOfRecipients,
        PFAX_PERSONAL_PROFILE lpRecipientsInfo
    )
/*++

Routine Description:

    Frees array of recipients.

Arguments:

    pdwNumberOfRecipients - number of recipients in array [IN/OUT]
    lpRecipientsInfo - pointer to array of recipients

Return Value:

    S_OK    - if success
    HRESULT error otherwise

--*/
{
    HRESULT hResult;
    DWORD i;

    Assert(pdwNumberOfRecipients);

    if (*pdwNumberOfRecipients==0)
    {
        return S_OK;
    }
    Assert(lpRecipientsInfo);

    for(i=0;i<*pdwNumberOfRecipients;i++)
    {
        hResult = FaxFreePersonalProfileInformation(&lpRecipientsInfo[i]);
        if (FAILED(hResult))
        {
            return hResult;
        }
    }
    MemFree(lpRecipientsInfo);
    *pdwNumberOfRecipients = 0;
    return S_OK;
}

VOID
FillInPropertyPage(
    PROPSHEETPAGE  *psp,
    BOOL             bWizard97,
    INT             dlgId,
    DLGPROC         dlgProc,
    PWIZARDUSERMEM  pWizardUserMem,
    INT             TitleId,
    INT             SubTitleId
    )

/*++

Routine Description:

    Fill out a PROPSHEETPAGE structure with the supplied parameters

Arguments:

    psp - Points to the PROPSHEETPAGE structure to be filled out
    dlgId - Dialog template resource ID
    dlgProc - Dialog procedure
    pWizardUserMem - Pointer to the user mode memory structure
    TitleId - resource id for wizard subtitle
    SubTitleId - resource id for wizard subtitle

Return Value:

    NONE

--*/

{

    LPTSTR WizardTitle = NULL;
    LPTSTR WizardSubTitle = NULL;


    Assert(psp);
    Assert(pWizardUserMem);

    Verbose(("FillInPropertyPage %d 0x%x\n",dlgId , pWizardUserMem));

    psp->dwSize = sizeof(PROPSHEETPAGE);
    //
    // Don't show titles if it's the first or last page
    //
    if (bWizard97)
    {
        if (TitleId==0 && SubTitleId ==0) {
            psp->dwFlags = PSP_DEFAULT | PSP_HIDEHEADER;
        } else {
            psp->dwFlags = PSP_USEHEADERTITLE | PSP_USEHEADERSUBTITLE;
        }
    }
    else
    {
       psp->dwFlags = PSP_DEFAULT ;
    }


    psp->hInstance = g_hResource;
    psp->pszTemplate = MAKEINTRESOURCE(dlgId);
    psp->pfnDlgProc = dlgProc;
    psp->lParam = (LPARAM) pWizardUserMem;

    if (bWizard97)
    {
        if (TitleId)
        {
            WizardTitle = MemAlloc(MAX_PATH * sizeof(TCHAR) );
            if(WizardTitle)
            {
                if (!LoadString(g_hResource, TitleId, WizardTitle, MAX_PATH))
                {
                    Warning(("LoadString failed. ec = 0x%X\n",GetLastError()));
                    Assert(FALSE);
                    WizardTitle[0] = 0;
                }
            }
            else
            {
                Error(("MemAlloc failed."));
            }
        }
        if (SubTitleId)
        {
            WizardSubTitle = MemAlloc(MAX_PATH * sizeof(TCHAR));
            if(WizardSubTitle)
            {
                if (!LoadString(g_hResource, SubTitleId, WizardSubTitle, MAX_PATH))
                {
                    Warning(("LoadString failed. ec = 0x%X\n",GetLastError()));
                    Assert(FALSE);
                    WizardSubTitle[0] = 0;
                }
            }
            else
            {
                Error(("MemAlloc failed."));
            }
        }

        psp->pszHeaderTitle = WizardTitle;
        psp->pszHeaderSubTitle = WizardSubTitle;
    }

}



LPTSTR
GetTextStringValue(
    HWND    hwnd
    )

/*++

Routine Description:

    Retrieve the string value in a text field

Arguments:

    hwnd - Handle to a text window

Return Value:

    Pointer to a string representing the current content of the text field
    NULL if the text field is empty or if there is an error

--*/

{
    INT     length;
    LPTSTR  pString;

    //
    // Find out how many characters are in the text field
    // and allocate enough memory to hold the string value
    //

    if ((length = GetWindowTextLength(hwnd)) == 0 ||
        (pString = MemAlloc(sizeof(TCHAR) * (length + 1))) == NULL)
    {
        return NULL;
    }

    //
    // Actually retrieve the string value
    //

    if (GetWindowText(hwnd, pString, length + 1) == 0) {

        MemFree(pString);
        return NULL;
    }

    return pString;
}



VOID
LimitTextFields(
    HWND    hDlg,
    INT    *pLimitInfo
    )

/*++

Routine Description:

    Limit the maximum length for a number of text fields

Arguments:

    hDlg - Specifies the handle to the dialog window
    pLimitInfo - Array of text field control IDs and their maximum length
        ID for the 1st text field, maximum length for the 1st text field
        ID for the 2nd text field, maximum length for the 2nd text field
        ...
        0
        Note: The maximum length counts the NUL-terminator.

Return Value:

    NONE

--*/

{
    while (*pLimitInfo != 0) {

        SendDlgItemMessage(hDlg, pLimitInfo[0], EM_SETLIMITTEXT, pLimitInfo[1]-1, 0);
        pLimitInfo += 2;
    }
}

PWIZARDUSERMEM
CommonWizardProc(
    HWND    hDlg,
    UINT    message,
    WPARAM  wParam,
    LPARAM  lParam,
    DWORD   buttonFlags
    )

/*++

Routine Description:

    Common procedure for handling wizard pages:

Arguments:

    hDlg - Identifies the wizard page
    message - Specifies the message
    wParam - Specifies additional message-specific information
    lParam - Specifies additional message-specific information
    buttonFlags - Indicate which buttons should be enabled

Return Value:

    NULL - Message is processed and the dialog procedure should return FALSE
    Otherwise - Message is not completely processed and
        The return value is a pointer to the user mode memory structure

--*/

{
    PWIZARDUSERMEM    pWizardUserMem;

    pWizardUserMem = NULL;

    switch (message)
    {
        case WM_INITDIALOG:
            //
            // Store the pointer to user mode memory structure
            //
            lParam = ((PROPSHEETPAGE *) lParam)->lParam;
            pWizardUserMem = (PWIZARDUSERMEM) lParam;

            Assert(ValidPDEVWizardUserMem(pWizardUserMem));
            SetWindowLongPtr(hDlg, DWLP_USER, lParam);
            //
            // Make the title text bold
            //
            if (pWizardUserMem->dwComCtrlVer < IE50_COMCTRL_VER)
            {
                HWND hwndTitle;

                hwndTitle = GetDlgItem(hDlg,IDC_STATIC_HEADER_TITLE);
                if (hwndTitle)
                {
                    SendMessage(hwndTitle,WM_SETFONT,(WPARAM)pWizardUserMem->hTitleFont ,MAKELPARAM((DWORD)FALSE,0));
                }

            }

            break;

        case WM_NOTIFY:

            pWizardUserMem = (PWIZARDUSERMEM) GetWindowLongPtr(hDlg, DWLP_USER);
            Assert(ValidPDEVWizardUserMem(pWizardUserMem));

            switch (((NMHDR *) lParam)->code)
            {
                case PSN_WIZFINISH:
                    pWizardUserMem->finishPressed = TRUE;
                    break;

                case PSN_SETACTIVE:
                    PropSheet_SetWizButtons(GetParent(hDlg), buttonFlags);
                    break;

                case PSN_RESET:
                case PSN_WIZBACK:
                case PSN_WIZNEXT:
                case PSN_KILLACTIVE:
                case LVN_KEYDOWN:
                case LVN_ITEMCHANGED:
                case NM_RCLICK:
                    break;

                default:
                    return NULL;
            }
            break;

        //
        // We wish all dialogs to recieve and handle the following commands:
        //
        case WM_DESTROY:
        case WM_COMMAND:
        case WM_CONTEXTMENU:
            pWizardUserMem = (PWIZARDUSERMEM) GetWindowLongPtr(hDlg, DWLP_USER);
            Assert(ValidPDEVWizardUserMem(pWizardUserMem));
            break;

        default:
            return NULL;
    }
    return pWizardUserMem;
}   // CommonWizardProc

INT
GetCurrentRecipient(
    HWND            hDlg,
    PWIZARDUSERMEM  pWizardUserMem,
    PRECIPIENT      *ppRecipient
    )

/*++

Routine Description:

    Extract the current recipient information in the dialog

Arguments:

    hDlg - Handle to the fax recipient wizard page
    pWizardUserMem - Points to user mode memory structure
    ppRecipient - Buffer to receive a pointer to a newly created RECIPIENT structure
        NULL if caller is only interested in the validity of recipient info

Return Value:

    = 0 if successful
    > 0 error message string resource ID otherwise
    < 0 other error conditions

--*/

{
    PFAX_TAPI_LINECOUNTRY_LIST  pCountryList = NULL;
    PFAX_TAPI_LINECOUNTRY_ENTRY pLineCountryEntry = NULL;
    DWORD                       countryId=0, countryCode=0;
    PRECIPIENT                  pRecipient = NULL;
    TCHAR                       areaCode[MAX_RECIPIENT_NUMBER];
    TCHAR                       phoneNumber[MAX_RECIPIENT_NUMBER];
    INT                         nameLen=0, areaCodeLen=0, numberLen=0;
    LPTSTR                      pName = NULL, pAddress = NULL;
    BOOL                        bUseDialingRules = FALSE;
    UINT                        cchAddress = 0;

    Assert(pWizardUserMem);

    pCountryList = pWizardUserMem->pCountryList;
    bUseDialingRules = pWizardUserMem->lpFaxSendWizardData->bUseDialingRules;

    //
    // Default value in case of error
    //
    if (ppRecipient)
    {
        *ppRecipient = NULL;
    }

    //
    // Find the current country code
    //
    if(bUseDialingRules)
    {
        countryId = GetCountryListBoxSel(GetDlgItem(hDlg, IDC_CHOOSE_COUNTRY_COMBO));

        if (countryId && (pLineCountryEntry = FindCountry(pCountryList,countryId)))
        {
            countryCode = pLineCountryEntry->dwCountryCode;
        }

        areaCodeLen = GetWindowTextLength(GetDlgItem(hDlg, IDC_CHOOSE_AREA_CODE_EDIT));

        if ((areaCodeLen <= 0 && AreaCodeRules(pLineCountryEntry) == AREACODE_REQUIRED) ||
            (areaCodeLen >= MAX_RECIPIENT_NUMBER))
        {
            return IDS_BAD_RECIPIENT_AREACODE;
        }

        if (0 == countryId)
        {
            return IDS_BAD_RECIPIENT_COUNTRY_CODE;
        }
    }

    nameLen   = GetWindowTextLength(GetDlgItem(hDlg, IDC_CHOOSE_NAME_EDIT));
    numberLen = GetWindowTextLength(GetDlgItem(hDlg, IDC_CHOOSE_NUMBER_EDIT));

    //
    // Validate the edit text fields
    //
    if (nameLen <= 0)
    {
        return IDS_BAD_RECIPIENT_NAME;
    }

    if (numberLen <= 0 || numberLen >= MAX_RECIPIENT_NUMBER)
    {
        return IDS_BAD_RECIPIENT_NUMBER;
    }

    if (NULL == ppRecipient)
    {
        return 0;
    }

    //
    // Calculate the amount of memory space we need and allocate it
    //
    pRecipient = MemAllocZ(sizeof(RECIPIENT));
    if(pRecipient)
    {
        ZeroMemory(pRecipient,sizeof(RECIPIENT));
    }
    pName = MemAllocZ((nameLen + 1) * sizeof(TCHAR));
    cchAddress = areaCodeLen + numberLen + 20;
    pAddress = MemAllocZ(cchAddress * sizeof(TCHAR));

    if (!pRecipient || !pName || !pAddress)
    {
        MemFree(pRecipient);
        MemFree(pName);
        MemFree(pAddress);
        return -1;
    }

    *ppRecipient = pRecipient;
    pRecipient->pName = pName;
    pRecipient->pAddress = pAddress;
    pRecipient->dwCountryId = countryId;
    pRecipient->bUseDialingRules = bUseDialingRules;
    pRecipient->dwDialingRuleId = g_dwCurrentDialingLocation;

    //
    // Get the recipient's name
    //
    GetWindowText(GetDlgItem(hDlg, IDC_CHOOSE_NAME_EDIT), pName, nameLen+1);
    //
    // Get the recipient's number
    //  AddressType
    //  [+ CountryCode Space]
    //  [( AreaCode ) Space]
    //  SubscriberNumber
    //
    GetWindowText(GetDlgItem(hDlg, IDC_CHOOSE_NUMBER_EDIT), phoneNumber, MAX_RECIPIENT_NUMBER);
    if (!IsValidFaxAddress (phoneNumber, !bUseDialingRules))
    {
        //
        // Fax address is invalid
        //
        MemFree(pRecipient);
        MemFree(pName);
        MemFree(pAddress);
        return IDS_INVALID_RECIPIENT_NUMBER;
    }

    if(!bUseDialingRules)
    {
        _tcscpy(pAddress, phoneNumber);
    }
    else
    {
        GetWindowText(GetDlgItem(hDlg, IDC_CHOOSE_AREA_CODE_EDIT),
                      areaCode, MAX_RECIPIENT_NUMBER);
        AssemblePhoneNumber(pAddress,
                            cchAddress,
                            countryCode,
                            areaCode,
                            phoneNumber);
    }

    return 0;
}


BOOL
InitRecipientListView(
    HWND    hwndLV
    )

/*++

Routine Description:

    Initialize the recipient list view on the first page of Send Fax wizard

Arguments:

    hwndLV - Window handle to the list view control

Return Value:

    TRUE is success
    FALSE otherwise

--*/

{
    LV_COLUMN   lvc;
    RECT        rect;
    TCHAR       buffer[MAX_TITLE_LEN];

    if (hwndLV == NULL) {
        return FALSE;
    }

    if (!GetClientRect(hwndLV, &rect))
    {
        Error(("GetClientRect failed. ec = 0x%X\n",GetLastError()));
        return FALSE;
    }

    ZeroMemory(&lvc, sizeof(lvc));

    ListView_SetExtendedListViewStyle(hwndLV, LVS_EX_FULLROWSELECT);

    lvc.mask = LVCF_FMT | LVCF_WIDTH | LVCF_TEXT | LVCF_SUBITEM;
    lvc.fmt = LVCFMT_LEFT;
    lvc.pszText = buffer;
    lvc.cx = (rect.right - rect.left) / 2;

    lvc.iSubItem = 0;
    if (!LoadString(g_hResource, IDS_COLUMN_RECIPIENT_NAME, buffer, MAX_TITLE_LEN))
    {
        Error(("LoadString failed. ec = 0x%X\n",GetLastError()));
        return FALSE;
    }


    if (ListView_InsertColumn(hwndLV, 0, &lvc) == -1)
    {
        Error(("ListView_InsertColumn failed\n"));
        return FALSE;
    }
    lvc.cx -= GetSystemMetrics(SM_CXVSCROLL);
    lvc.iSubItem = 1;
    if (!LoadString(g_hResource, IDS_COLUMN_RECIPIENT_NUMBER, buffer, MAX_TITLE_LEN))
    {
        Error(("LoadString failed. ec = 0x%X\n",GetLastError()));
        return FALSE;
    }

    if (ListView_InsertColumn(hwndLV, 1, &lvc) == -1)
    {
        Error(("ListView_InsertColumn failed\n"));
        return FALSE;
    }

    //
    // Autosize the last column to get rid of unnecessary horizontal scroll bar
    //
    ListView_SetColumnWidth(hwndLV, 1, LVSCW_AUTOSIZE_USEHEADER);

    return TRUE;
}

typedef struct {
    DWORD                       dwSizeOfStruct;
    LPTSTR                      lptstrName;
    LPTSTR                      lptstrAddress;
    LPTSTR                      lptstrCountry;
    DWORD                       dwCountryId;
	DWORD						dwDialingRuleId;
    BOOL                        bUseDialingRules;
    PFAX_TAPI_LINECOUNTRY_LIST  pCountryList;
} CHECKNUMBER, * PCHECKNUMBER;


VOID
FreeCheckNumberFields(OUT PCHECKNUMBER pCheckNumber)
/*++

Routine Description:

    Frees CHECKNUMBER structure

Arguments:

    pCheckNumber    - out pointer to CHECKNUMBER structure

Return Value:

    NONE
--*/
{
    MemFree(pCheckNumber->lptstrName);
    MemFree(pCheckNumber->lptstrAddress);
    MemFree(pCheckNumber->lptstrCountry);
    ZeroMemory(pCheckNumber,sizeof(CHECKNUMBER));
}

BOOL
InitCheckNumber(IN  LPTSTR                      lptstrName,
                IN  LPTSTR                      lptstrAddress,
                IN  LPTSTR                      lptstrCountry,
                IN  DWORD                       dwCountryId,
				IN  DWORD						dwDialingRuleId,
                IN  BOOL                        bUseDialingRules,
                IN  PFAX_TAPI_LINECOUNTRY_LIST  pCountryList,
                OUT PCHECKNUMBER                pCheckNumber)
/*++

Routine Description:

    Initializes CHECKNUMBER structure

Arguments:

    lptstrName      - recipient name
    lptstrAddress   - recipient address
    lptstrCountry   - recipient country
    dwCountryID     - recipient country ID
    bUseDialingRules- Use Dialing Rules
    pCountryList    - TAPI country list
    pCheckNumber    - out pointer to CHECKNUMBER structure

Return Value:

    TRUE if success
    FALSE otherwise
--*/
{

    ZeroMemory(pCheckNumber,sizeof(CHECKNUMBER));
    pCheckNumber->dwSizeOfStruct = sizeof(CHECKNUMBER);

    if (lptstrName && !(pCheckNumber->lptstrName = StringDup(lptstrName)))
    {
        Error(("Memory allocation failed\n"));
        goto error;
    }

    if (lptstrAddress && !(pCheckNumber->lptstrAddress = StringDup(lptstrAddress)))
    {
        Error(("Memory allocation failed\n"));
        goto error;
    }

    if (lptstrCountry  && !(pCheckNumber->lptstrCountry = StringDup(lptstrCountry)))
    {
        Error(("Memory allocation failed\n"));
        goto error;
    }

    pCheckNumber->dwCountryId  = dwCountryId;
    pCheckNumber->bUseDialingRules = bUseDialingRules;
    pCheckNumber->pCountryList = pCountryList;
	pCheckNumber->dwDialingRuleId = dwDialingRuleId;

    return TRUE;
error:
    FreeCheckNumberFields(pCheckNumber);

    return FALSE;
}


INT
ValidateCheckFaxRecipient(
    HWND         hDlg,
    PCHECKNUMBER pCheckNumber
    )

/*++

Routine Description:

    Validates the current recipient information in the dialog

Arguments:

    hDlg         - Handle to the fax recipient wizard page
    pCheckNumber - Pointer to the CHECKNUMBER struct

Return Value:

    = 0 if successful
    > 0 error message string resource ID otherwise

--*/

{
    DWORD                        countryId, countryCode;
    INT                          areaCodeLen, numberLen, nameLen;
    PFAX_TAPI_LINECOUNTRY_LIST   pCountryList = pCheckNumber->pCountryList;
    PFAX_TAPI_LINECOUNTRY_ENTRY  pLineCountryEntry;

    numberLen = GetWindowTextLength(GetDlgItem(hDlg, IDC_CHECK_FAX_LOCAL));

    if (numberLen <= 0 || numberLen >= MAX_RECIPIENT_NUMBER)
    {
        return IDS_BAD_RECIPIENT_NUMBER;
    }

    if(!pCheckNumber->bUseDialingRules)
    {
        return 0;
    }

    //
    // Find the current country code
    //

    countryCode = 0;
    pLineCountryEntry = NULL;
    countryId = GetCountryListBoxSel(GetDlgItem(hDlg, IDC_CHECK_FAX_COUNTRY));

    if ((countryId != 0) &&
        (pLineCountryEntry = FindCountry(pCountryList,countryId)))
    {
        countryCode = pLineCountryEntry->dwCountryCode;
    }

    nameLen = GetWindowTextLength(GetDlgItem(hDlg, IDC_CHECK_FAX_RECIPIENT_NAME));
    areaCodeLen = GetWindowTextLength(GetDlgItem(hDlg, IDC_CHECK_FAX_CITY));

    //
    // Validate the edit text fields
    //

    if (nameLen <= 0)
    {
        return IDS_BAD_RECIPIENT_NAME;
    }

    if ((areaCodeLen <= 0 && AreaCodeRules(pLineCountryEntry) == AREACODE_REQUIRED) ||
        (areaCodeLen >= MAX_RECIPIENT_NUMBER))
    {
        return IDS_BAD_RECIPIENT_AREACODE;
    }

    if (countryId==0)
    {
        return IDS_BAD_RECIPIENT_COUNTRY_CODE;
    }

    return 0;

}

VOID
CheckFaxSetFocus(HWND hDlg,
                 INT errId
                 )
{
    HWND hDglItem;
    switch (errId) {

        case IDS_ERROR_AREA_CODE:
            if (!SetDlgItemText(hDlg, IDC_CHECK_FAX_CITY, _T("")))
            {
                Warning(("SetDlgItemText failed. ec = 0x%X\n",GetLastError()));
            }
        case IDS_BAD_RECIPIENT_AREACODE:

            errId = IDC_CHECK_FAX_CITY;
            break;

        case IDS_BAD_RECIPIENT_COUNTRY_CODE:

            errId = IDC_CHECK_FAX_COUNTRY;
            break;

        case IDS_INVALID_RECIPIENT_NUMBER:
            if (!SetDlgItemText(hDlg, IDC_CHECK_FAX_LOCAL, _T("")))
            {
                Warning(("SetDlgItemText failed. ec = 0x%X\n",GetLastError()));
            }
        case IDS_BAD_RECIPIENT_NUMBER:

            errId = IDC_CHECK_FAX_LOCAL;
            break;

        case IDS_BAD_RECIPIENT_NAME:
        default:

            errId = IDC_CHECK_FAX_RECIPIENT_NAME;
            break;
    }

    if (!(hDglItem = GetDlgItem(hDlg, errId)))
    {
        Error(("GetDlgItem failed. ec = 0x%X\n",GetLastError()));
    }
    else if (!SetFocus(hDglItem))
    {
        Error(("SetFocus failed. ec = 0x%X\n",GetLastError()));
    }

}

DWORD
GetCountryCode(
        HWND                        hDlg,
        PFAX_TAPI_LINECOUNTRY_LIST  pCountryList,
        INT                         nIDCountryItem
        )
{
/*++

Routine Description:

    Retrieves country code.

Arguments:

    hDlg - - Specifies the handle to the dialog window
    nIDCountryItem  - Specifies the identifier of the control of country code

Return Value:

    Coutry code if the country exists
    0 otherwise

--*/
    PFAX_TAPI_LINECOUNTRY_ENTRY pLineCountryEntry;
    DWORD                       dwCountryId, dwCountryCode;

    //
    // Find the current country code
    //

    dwCountryCode = 0;
    pLineCountryEntry = NULL;
    dwCountryId = GetCountryListBoxSel(GetDlgItem(hDlg, nIDCountryItem));

    if ((dwCountryId != 0) &&
        (pLineCountryEntry = FindCountry(pCountryList,dwCountryId)))
    {
        dwCountryCode = pLineCountryEntry->dwCountryCode;
    }
    return dwCountryCode;
}

LPTSTR
GetAreaCodeOrFaxNumberFromControl(
        IN  HWND    hDlg,
        IN  INT     nIDItem,
        OUT LPTSTR  szNumber,
        IN  UINT    cchNumber
        )
{
/*++

Routine Description:

    Gets area code or phone number from an appropriate control

Arguments:

    hDlg - - Specifies the handle to the dialog window
    nIDItem - Specifies the identifier of the control to be retrieved. (area code/fax number)
    szNumber - Output buffer
    cchNumber - The size of the szNumber OUT buffer in TCHARs

Return Value:

    Area code/local fax number if the string is the number
    Or empty string otherwise

--*/
    HWND    hControl;
    Assert(szNumber);

    if (!(hControl = GetDlgItem(hDlg, nIDItem)))
    {
        Error(("GetDlgItem failed. ec = 0x%X\n",GetLastError()));
        return _T( "" );
    }

    if (!GetWindowText(hControl, szNumber, cchNumber)&&GetLastError())
    {
        Error(("GetWindowText failed. ec = 0x%X\n",GetLastError()));
        return _T( "" );
    }
    return szNumber;
}

LPTSTR
StripSpaces(
            IN LPTSTR   lptstrPhoneNumber)
{
/*++

Routine Description:

    Strips spaces from the beginning of lptstrPhoneNumber

Arguments:

    lptstrPhoneNumber - phone number with spaces in the beginning

Return Value:

    lptstrPhoneNumber without spaces in the beginning

--*/
    TCHAR   szSpaces[MAX_STRING_LEN];
    szSpaces[0] = (TCHAR) '\0';

    if (!lptstrPhoneNumber)
        return NULL;

    if (_stscanf(lptstrPhoneNumber,_T("%[ ]"),szSpaces))
        return lptstrPhoneNumber + _tcslen(szSpaces);

    return lptstrPhoneNumber;
}

LPTSTR
StripCodesFromNumber(
            IN  LPTSTR lptstrPhoneNumber,
            OUT DWORD  *pdwCountryCode,
            OUT LPTSTR lptstrAreaCode,
            IN  UINT   cchAreaCode)
/*++

Routine Description:

    Extracts, if possible,  area code. country code and local phone number from the phone number.
    This function considers three possibilities:
    1. The number is canonical and has area code
    2. The number is canonical and has no area code
    3. The number is not canonical

Arguments:

    lptstrPhoneNumber - assembled phone number
    pdwCountryCode  - adress of country code
    lptstrAreaCode - address of area code
    cchAreaCode - size of the lptstrAreaCode OUT buffer in TCHARs

Return Value:

    local phone number if the number was assembled or complete lptstrPhoneNumber otherwise
    The return value is HEAP allocated , call MemFree when the result is no longer needed.

--*/
{
    BOOL    bIsCanonical;
    DWORD   dwAreaCode;
    HRESULT hRc;
    LPTSTR  pszSubNumber;
    LPTSTR  szReturnValue;
    DWORD   dwErrorCode;
    


    //
    // Input parameters validation.
    //
    if(!lptstrPhoneNumber || 
       !pdwCountryCode || 
       !lptstrAreaCode ||
       cchAreaCode < 1)
    {
        Assert(0);
        return NULL;
    }

    // initialization
    *pdwCountryCode = 0 ;
    pszSubNumber = NULL;
    szReturnValue = NULL;

    //
    // Input params are being checked so there is at least one TCHAR in the OUT buffer.
    //
    lptstrAreaCode[0] = TEXT('\0');

    dwErrorCode = IsCanonicalAddress(lptstrPhoneNumber, 
                                     &bIsCanonical,
                                     pdwCountryCode,
                                     &dwAreaCode,
                                     &pszSubNumber);
    if(dwErrorCode != ERROR_SUCCESS)
    {
        Assert(0);
        goto Cleanup;
    }
    //
    // If the number is not canonical just return the original number.
    //
    if(!bIsCanonical)
    {
        szReturnValue = StringDup(lptstrPhoneNumber);
        if(szReturnValue == NULL)
        {
            Assert(0);
            goto Cleanup;
        }

        goto Cleanup;
    }
    else
    {
        //
        // The number is canonical and we have got 2 options
        //
        if(dwAreaCode == ROUTING_RULE_AREA_CODE_ANY)
        {
            //
            // Meaning that there is no area code
            // 
            lptstrAreaCode[0] = TEXT('\0');

            //
            // Point to the heap allocated memory and make sure the cleanup will not touch it.
            //
            szReturnValue = pszSubNumber;
            pszSubNumber = NULL;

            goto Cleanup;
        }
        else
        {
            //
            // There is a country code + area code
            //
            hRc = StringCchPrintf(lptstrAreaCode,
                                cchAreaCode,
                                TEXT("%u"),
                                dwAreaCode);
            if(FAILED(hRc))
            {
                Assert(0);
                goto Cleanup;
            }

            //
            // Point to the heap allocated memory and make sure the cleanup will not touch it.
            //
            szReturnValue = pszSubNumber;
            pszSubNumber = NULL;
            goto Cleanup;
        }
    }

Cleanup:
    MemFree(pszSubNumber);

    return szReturnValue;
}

INT_PTR
CALLBACK
CheckFaxNumberDlgProc(
    HWND hDlg,
    UINT uMsg,
    WPARAM wParam,
    LPARAM lParam
    )
/*++

Routine Description:

    Dialog proc for check of fax number.

Arguments:

    lParam - pointer to CHECKNUMBER structure.

Return Value:

    0 - if cancel
    1 - if ok

--*/

{
    INT         errId;
    INT         cmd;
    PCHECKNUMBER pCheckNumber = (PCHECKNUMBER) lParam;
    TCHAR       tszBuffer[MAX_STRING_LEN];
    TCHAR       szAddress[MAX_STRING_LEN];
    TCHAR       szAreaCode[MAX_RECIPIENT_NUMBER];
    TCHAR       szPoneNumber[MAX_RECIPIENT_NUMBER];
    TCHAR       szName[MAX_STRING_LEN];
    DWORD       dwErrorCode;
    DWORD       dwCountryId=0;
    DWORD       dwCountryCode=0 ;
    LPTSTR      lptstrLocalPhoneNumber=NULL;
    PFAX_TAPI_LINECOUNTRY_ENTRY  pLineCountryEntry;
    HWND        hControl;

    //
    // Maximum length for various text fields
    //

    static INT  textLimits[] = {

        IDC_CHECK_FAX_RECIPIENT_NAME,   64,
        IDC_CHECK_FAX_CITY,             11,
        IDC_CHECK_FAX_LOCAL,            51,
        0
    };

    ZeroMemory(szAreaCode, sizeof(szAreaCode));


    switch (uMsg)
    {
        case WM_INITDIALOG:

            LimitTextFields(hDlg, textLimits);

            if (pCheckNumber->lptstrName)
            {
                if (!SetDlgItemText(hDlg, IDC_CHECK_FAX_RECIPIENT_NAME, pCheckNumber->lptstrName))
                    Warning(("SetDlgItemText failed. ec = 0x%X\n",GetLastError()));
            }

            // store pointer for futher proceeding
            SetWindowLongPtr(hDlg, DWLP_USER, lParam);

            //
            // A numeric edit control should be LTR
            //
            SetLTREditDirection(hDlg, IDC_CHECK_FAX_NUMBER);
            SetLTREditDirection(hDlg, IDC_CHECK_FAX_CITY);
            SetLTREditDirection(hDlg, IDC_CHECK_FAX_LOCAL);

            if(!pCheckNumber->bUseDialingRules)
            {
                EnableWindow(GetDlgItem(hDlg, IDC_CHECK_FAX_COUNTRY), FALSE);
                EnableWindow(GetDlgItem(hDlg, IDC_CHECK_FAX_CITY), FALSE);
            }
            else
            {
                lptstrLocalPhoneNumber = StripCodesFromNumber( pCheckNumber->lptstrAddress,
                                                               &dwCountryCode,
                                                               szAreaCode,
                                                               ARR_SIZE(szAreaCode));
                dwCountryId = pCheckNumber->dwCountryId;
                if(!dwCountryId)
                {
                    dwCountryId = GetCountryIdFromCountryCode(pCheckNumber->pCountryList,
                                                              dwCountryCode);
                }

                // init country combo box and try to identify the country
                if (!(hControl=GetDlgItem(hDlg, IDC_CHECK_FAX_COUNTRY)))
                {
                    Warning(("GetDlgItem failed. ec = 0x%X\n",GetLastError()));
                }
                else
                {
                    InitCountryListBox(pCheckNumber->pCountryList,
                                       hControl,
                                       NULL,
                                       pCheckNumber->lptstrCountry,
                                       dwCountryId,
                                       TRUE);
                }

                if  (dwCountryCode==0)
                {   // country code wasn't indentified
                    if (!(hControl=GetDlgItem(hDlg, IDC_CHECK_FAX_COUNTRY)))
                    {
                        Warning(("GetDlgItem failed. ec = 0x%X\n",GetLastError()));
                    }
                    else
                    {
                        dwCountryId = GetCountryListBoxSel(hControl);
                    }

                    if ((dwCountryId != 0) &&
                        (pLineCountryEntry = FindCountry(pCheckNumber->pCountryList,dwCountryId)))
                    {
                        dwCountryCode = pLineCountryEntry->dwCountryCode;
                    }
                }

                Assert (lptstrLocalPhoneNumber);

                SetDlgItemText(hDlg, IDC_CHECK_FAX_CITY , szAreaCode);
                AssemblePhoneNumber(szAddress,
                                    ARR_SIZE(szAddress),
                                    dwCountryCode,
                                    szAreaCode,
                                    lptstrLocalPhoneNumber ? lptstrLocalPhoneNumber : _T(""));
            }

            SetDlgItemText(hDlg,
                           IDC_CHECK_FAX_NUMBER,
                           !(pCheckNumber->bUseDialingRules) ?
                           pCheckNumber->lptstrAddress : szAddress);

            SetDlgItemText(hDlg,
                           IDC_CHECK_FAX_LOCAL,
                           !(pCheckNumber->bUseDialingRules) ?
                           pCheckNumber->lptstrAddress : lptstrLocalPhoneNumber);

            MemFree(lptstrLocalPhoneNumber);
            return TRUE;

        case WM_COMMAND:

            cmd = GET_WM_COMMAND_CMD(wParam, lParam);

            switch (GET_WM_COMMAND_ID(wParam, lParam))
            {
                case IDC_CHECK_FAX_COUNTRY:
                    pCheckNumber = (PCHECKNUMBER) GetWindowLongPtr(hDlg, DWLP_USER);

                    Assert(pCheckNumber);

                    if (cmd == CBN_SELCHANGE)
                    {
                        if (!(GetDlgItem(hDlg, IDC_CHECK_FAX_COUNTRY)) ||
                            !(GetDlgItem(hDlg, IDC_CHECK_FAX_CITY)))
                        {
                            Warning(("GetDlgItem failed. ec = 0x%X\n",GetLastError()));
                        }
                        else
                        {
                            SelChangeCountryListBox(GetDlgItem(hDlg, IDC_CHECK_FAX_COUNTRY),
                                                    GetDlgItem(hDlg, IDC_CHECK_FAX_CITY),
                                                    pCheckNumber->pCountryList);
                        }
                        AssemblePhoneNumber(szAddress,
                                            ARR_SIZE(szAddress),
                                            GetCountryCode(hDlg,pCheckNumber->pCountryList,IDC_CHECK_FAX_COUNTRY),
                                            GetAreaCodeOrFaxNumberFromControl(hDlg,IDC_CHECK_FAX_CITY,szAreaCode,ARR_SIZE(szAreaCode)),
                                            GetAreaCodeOrFaxNumberFromControl(hDlg,IDC_CHECK_FAX_LOCAL,szPoneNumber,ARR_SIZE(szPoneNumber)));

                        SetDlgItemText(hDlg, IDC_CHECK_FAX_NUMBER, szAddress);
                    }
                break;
                case IDC_CHECK_FAX_CITY:

                    if (cmd == EN_CHANGE)
                    {

                        pCheckNumber = (PCHECKNUMBER) GetWindowLongPtr(hDlg, DWLP_USER);

                        Assert(pCheckNumber);

                       // Read the text from the edit control.

                       if (!GetDlgItemText( hDlg, IDC_CHECK_FAX_CITY, tszBuffer, MAX_STRING_LEN))
                       {
                          dwErrorCode = GetLastError();
                          if ( dwErrorCode != (DWORD) ERROR_SUCCESS )
                          {
                             // Error reading the edit control.
                          }
                       }
                       AssemblePhoneNumber(szAddress,
                            ARR_SIZE(szAddress),
                            GetCountryCode(hDlg,pCheckNumber->pCountryList,IDC_CHECK_FAX_COUNTRY),
                            GetAreaCodeOrFaxNumberFromControl(hDlg,IDC_CHECK_FAX_CITY,szAreaCode,ARR_SIZE(szAreaCode)),
                            GetAreaCodeOrFaxNumberFromControl(hDlg,IDC_CHECK_FAX_LOCAL,szPoneNumber,ARR_SIZE(szPoneNumber)));

                       SetDlgItemText(hDlg, IDC_CHECK_FAX_NUMBER, szAddress);
                    }

                break;
                case IDC_CHECK_FAX_LOCAL:

                    if (cmd == EN_CHANGE)
                    {

                        pCheckNumber = (PCHECKNUMBER) GetWindowLongPtr(hDlg, DWLP_USER);

                        Assert(pCheckNumber);
                        //
                        // Read the text from the edit control.
                        //
                        if(!GetDlgItemText(hDlg,
                                           IDC_CHECK_FAX_LOCAL,
                                           tszBuffer,
                                           MAX_STRING_LEN))
                        {
                            tszBuffer[0] = 0;
                            Warning(("GetDlgItemText(IDC_CHECK_FAX_LOCAL) failed. ec = 0x%X\n",GetLastError()));
                        }

                        if(pCheckNumber->bUseDialingRules)
                        {
                            AssemblePhoneNumber(szAddress,
                                    ARR_SIZE(szAddress),
                                    GetCountryCode(hDlg,pCheckNumber->pCountryList,IDC_CHECK_FAX_COUNTRY),
                                    GetAreaCodeOrFaxNumberFromControl(hDlg,IDC_CHECK_FAX_CITY,szAreaCode,ARR_SIZE(szAreaCode)),
                                    GetAreaCodeOrFaxNumberFromControl(hDlg,IDC_CHECK_FAX_LOCAL,szPoneNumber,ARR_SIZE(szPoneNumber)));
                        }

                        SetDlgItemText(hDlg,
                                       IDC_CHECK_FAX_NUMBER,
                                       !pCheckNumber->bUseDialingRules ?
                                       tszBuffer : szAddress);
                    }

                break;

            }

            switch(LOWORD( wParam ))
            {
                case IDOK:
                    pCheckNumber = (PCHECKNUMBER) GetWindowLongPtr(hDlg, DWLP_USER);

                    Assert(pCheckNumber);

                    errId = ValidateCheckFaxRecipient(hDlg, pCheckNumber);
                    if (errId > 0)
                    {
                        DisplayMessageDialog(hDlg, 0, IDS_WIZARD_TITLE, errId);
                        CheckFaxSetFocus(hDlg,errId);
                        return FALSE;
                    }

                    if(!GetDlgItemText(hDlg,
                                       IDC_CHECK_FAX_LOCAL,
                                       tszBuffer,
                                       MAX_STRING_LEN))
                    {
                        tszBuffer[0] = 0;
                        Warning(("GetDlgItemText(IDC_CHECK_FAX_LOCAL) failed. ec = 0x%X\n",GetLastError()));
                    }
                    if (!IsValidFaxAddress (tszBuffer, !pCheckNumber->bUseDialingRules))
                    {
                        //
                        // Fax address is invalid
                        //
                        DisplayMessageDialog(hDlg, 0, 0, IDS_INVALID_RECIPIENT_NUMBER);
                        return FALSE;
                    }

                    ZeroMemory(szName,sizeof(TCHAR)*MAX_STRING_LEN);
                    if (!GetDlgItemText(hDlg,
                                        IDC_CHECK_FAX_RECIPIENT_NAME,
                                        szName,
                                        MAX_STRING_LEN)
                         && GetLastError())
                    {
                        Error(("GetDlgItem failed. ec = 0x%X\n",GetLastError()));
                        DisplayMessageDialog(hDlg, 0, IDS_WIZARD_TITLE, IDS_BAD_RECIPIENT_NAME);
                        CheckFaxSetFocus(hDlg,IDS_BAD_RECIPIENT_NAME);
                        return FALSE;
                    }

                    MemFree(pCheckNumber->lptstrName);
                    pCheckNumber->lptstrName = NULL;
                    if ((szName[0] != '\0') &&
                        !(pCheckNumber->lptstrName = StringDup(szName)))
                    {
                        Error(("Memory allocation failed\n"));
                        return FALSE;
                    }

                    ZeroMemory(szAddress,sizeof(TCHAR)*MAX_STRING_LEN);
                    if (!GetDlgItemText(hDlg,
                                        IDC_CHECK_FAX_NUMBER,
                                        szAddress,
                                        MAX_STRING_LEN)
                         && GetLastError())
                    {
                        Error(("GetDlgItem failed. ec = 0x%X\n",GetLastError()));
                        DisplayMessageDialog(hDlg, 0, IDS_WIZARD_TITLE, IDS_BAD_RECIPIENT_NUMBER);
                        CheckFaxSetFocus(hDlg,IDS_BAD_RECIPIENT_NUMBER);
                        return FALSE;
                    }

                    MemFree(pCheckNumber->lptstrAddress);
                    pCheckNumber->lptstrAddress = NULL;
                    if ((szAddress[0] != '\0') &&
                        !(pCheckNumber->lptstrAddress = StringDup(szAddress)))
                    {
                        Error(("Memory allocation failed\n"));
                        MemFree(pCheckNumber->lptstrName);
                        return FALSE;
                    }

                    pCheckNumber->dwCountryId = GetCountryListBoxSel(GetDlgItem(hDlg,
                                                                IDC_CHECK_FAX_COUNTRY));

                    EndDialog(hDlg,1);
                    return TRUE;

                case IDCANCEL:

                    EndDialog( hDlg,0 );
                    return TRUE;

            }
            break;

        default:
            return FALSE;

    }

    return FALSE;
}

BOOL
IsCanonicalNumber(LPCTSTR lptstrNumber)
{
    if (!lptstrNumber)
    {
        return FALSE;
    }
    if ( _tcsncmp(lptstrNumber,TEXT("+"),1) != 0 )
        return FALSE;

    return TRUE;
}


BOOL
InsertRecipientListItem(
    HWND        hwndLV,
    PRECIPIENT  pRecipient
    )

/*++

Routine Description:

    Insert an item into the recipient list view

Arguments:

    hwndLV - Window handle to the recipient list view
    pRecipient - Specifies the recipient to be inserted

Return Value:

    TRUE if successful, FALSE if there is an error

--*/

{
    LV_ITEM lvi = {0};
    INT     index;
    TCHAR*  pAddress = NULL;

    lvi.mask = LVIF_PARAM | LVIF_TEXT | LVIF_STATE;
    lvi.lParam = (LPARAM) pRecipient;
    lvi.pszText = pRecipient->pName;
    lvi.state = lvi.stateMask = LVIS_SELECTED;

    if ((index = ListView_InsertItem(hwndLV, &lvi)) == -1)
    {
        Error(("ListView_InsertItem failed\n"));
        return FALSE;
    }

    pAddress = pRecipient->pAddress;

#ifdef UNICODE

    if(IsWindowRTL(hwndLV))
    {
        pAddress = (TCHAR*)MemAlloc(sizeof(TCHAR)*(_tcslen(pRecipient->pAddress)+2));
        if(!pAddress)
        {
            Error(("MemAlloc failed\n"));
            return FALSE;
        }

        _stprintf(pAddress, TEXT("%c%s"), UNICODE_LRO, pRecipient->pAddress);
    }

#endif

    ListView_SetItemText(hwndLV, index, 1, pAddress);

    if(pAddress != pRecipient->pAddress)
    {
        MemFree(pAddress);
    }

    return TRUE;
}


PRECIPIENT
GetRecipientListItem(
    HWND    hwndLV,
    INT     index
    )

/*++

Routine Description:

    Retrieve the recipient associated with an item in the list view

Arguments:

    hwndLV - Window handle to the recipient list view
    index - Specifies the index of the interested item

Return Value:

    Pointer to the requested recipient information
    NULL if there is an error

--*/

{
    LV_ITEM lvi;

    ZeroMemory(&lvi, sizeof(lvi));
    lvi.mask = LVIF_PARAM;
    lvi.iItem = index;

    if (ListView_GetItem(hwndLV, &lvi))
        return (PRECIPIENT) lvi.lParam;

    Error(("ListView_GetItem failed\n"));
    return NULL;
}

VOID
FreeEntryID(
        PWIZARDUSERMEM  pWizardUserMem,
        LPVOID          lpEntryId
            )
{
    if (pWizardUserMem->lpMAPIabInit)
    {
        FreeMapiEntryID(pWizardUserMem,lpEntryId);
    }
    else
    {
        FreeWabEntryID(pWizardUserMem,lpEntryId);
    }

}


INT
AddRecipient(
    HWND            hDlg,
    PWIZARDUSERMEM  pWizardUserMem
    )

/*++

Routine Description:

    Add the current recipient information entered by the user
    into the recipient list

Arguments:

    hDlg - Handle to the fax recipient wizard page
    pWizardUserMem - Points to user mode memory structure

Return Value:

    Same meaning as return value from GetCurrentRecipient, i.e.
    = 0 if successful
    > 0 error message string resource ID otherwise
    < 0 other error conditions

--*/

{
    PRECIPIENT  pRecipient = NULL;
    PRECIPIENT  pRecipientList = NULL;
    INT         errId = 0;
    HWND        hwndLV;
    BOOL        bNewRecipient = TRUE;

    //
    // Collect information about the current recipient
    //

    if ((errId = GetCurrentRecipient(hDlg, pWizardUserMem, &pRecipient)) != 0)
    {
        return errId;
    }

    for(pRecipientList = pWizardUserMem->pRecipients; pRecipientList; pRecipientList = pRecipientList->pNext)
    {
        if(pRecipient->pAddress     &&
           pRecipient->pName        &&
           pRecipientList->pAddress &&
           pRecipientList->pName    &&
           !_tcscmp(pRecipient->pAddress, pRecipientList->pAddress) &&
           !_tcsicmp(pRecipient->pName,   pRecipientList->pName))
        {
            //
            // The recipient is already in list
            //
            bNewRecipient = FALSE;
            FreeRecipient(pRecipient);
            pRecipient = NULL;
            break;
        }
    }


    if(bNewRecipient && pRecipient)
    {
        //
        // save last recipient country ID
        //
        pWizardUserMem->lpFaxSendWizardData->dwLastRecipientCountryId =
                 GetCountryListBoxSel(GetDlgItem(hDlg, IDC_CHOOSE_COUNTRY_COMBO));

        //
        // Insert the current recipient to the recipient list
        //
        hwndLV = GetDlgItem(hDlg, IDC_CHOOSE_RECIPIENT_LIST);
        if(!hwndLV)
        {
            Assert(hwndLV);
            errId = -1;
            goto error;
        }

        if(!InsertRecipientListItem(hwndLV, pRecipient))
        {
            errId = -1;
            goto error;
        }

        //
        // Autosize the last column to get rid of unnecessary horizontal scroll bar
        //
        ListView_SetColumnWidth(hwndLV, 1, LVSCW_AUTOSIZE_USEHEADER);

        //
        // Add the recipient into the list
        //
        pRecipient->pNext = pWizardUserMem->pRecipients;
        pWizardUserMem->pRecipients = pRecipient;
    }

    //
    // Clear the name and number fields
    //
    if (!SetDlgItemText(hDlg, IDC_CHOOSE_NAME_EDIT,   TEXT("")) ||
        !SetDlgItemText(hDlg, IDC_CHOOSE_NUMBER_EDIT, TEXT("")))
    {
        Warning(("SetWindowText failed. ec = 0x%X\n",GetLastError()));
    }

    return errId;

error:

    FreeRecipient(pRecipient);

    return errId;
}

static
HRESULT
CopyRecipientInfo(
    PFAX_PERSONAL_PROFILE pfppDestination,
    PRECIPIENT            prSource,
    BOOL                  bLocalServer)
{
    if ((pfppDestination->lptstrName = DuplicateString(prSource->pName)) == NULL)
    {
        Error(("Memory allocation failed\n"));
        return ERROR_NOT_ENOUGH_MEMORY;
    }

    if ((prSource->bUseDialingRules) &&                                     // We have a canonical address and
        bLocalServer                 &&                                     // and it's a local server
        (USE_LOCAL_SERVER_OUTBOUND_ROUTING != prSource->dwDialingRuleId))   // we don't use server's outbound routing
    {
        //
        // We need to translate the address ourseleves, using the specified dialing location
        //
        if (!TranslateAddress (prSource->pAddress,
                               prSource->dwDialingRuleId,
                               &pfppDestination->lptstrFaxNumber))
        {
            MemFree(pfppDestination->lptstrName);
            pfppDestination->lptstrName = NULL;
            return GetLastError ();
        }
    }
    else
    {
        //
        // Either 'Dial as entered' mode or using the server's outbound routing.
        // Just copy the address as is.
        //
        if ((pfppDestination->lptstrFaxNumber = DuplicateString(prSource->pAddress)) == NULL)
        {
            MemFree(pfppDestination->lptstrName);
            Error(("Memory allocation failed\n"));
            return ERROR_NOT_ENOUGH_MEMORY;
        }
    }
    Verbose(("Copied %ws from %ws\n", pfppDestination->lptstrName,pfppDestination->lptstrFaxNumber));
    return S_OK;
}

static HRESULT
StoreRecipientInfoInternal(
        PWIZARDUSERMEM  pWizardUserMem
     )
{
    DWORD   dwIndex;
    HRESULT hResult = S_OK;
    PRECIPIENT  pCurrentRecip = NULL,pNewRecip = NULL;
    PFAX_PERSONAL_PROFILE   pCurrentPersonalProfile = NULL;

    Assert(pWizardUserMem);
    Assert(pWizardUserMem->lpInitialData);
    Assert(pWizardUserMem->pRecipients == NULL);

    if (!pWizardUserMem->lpInitialData->dwNumberOfRecipients)   // zero recipients
        return S_OK;

    for (dwIndex = 0; dwIndex < pWizardUserMem->lpInitialData->dwNumberOfRecipients; dwIndex++)
    {

        if (!(pNewRecip = MemAlloc(sizeof(RECIPIENT))))
        {
            hResult = ERROR_NOT_ENOUGH_MEMORY;
            Error(("Memory allocation failed\n"));
            goto error;
        }

        ZeroMemory(pNewRecip,sizeof(RECIPIENT));

        if (dwIndex == 0)
            pWizardUserMem->pRecipients = pNewRecip;

        pCurrentPersonalProfile = &pWizardUserMem->lpInitialData->lpRecipientsInfo[dwIndex];

        if (pCurrentPersonalProfile->lptstrName && !(pNewRecip->pName = DuplicateString(pCurrentPersonalProfile->lptstrName)))
        {
            hResult = ERROR_NOT_ENOUGH_MEMORY;
            Error(("Memory allocation failed\n"));
            goto error;
        }

        if (pCurrentPersonalProfile->lptstrFaxNumber && !(pNewRecip->pAddress = DuplicateString(pCurrentPersonalProfile->lptstrFaxNumber)))
        {
            hResult = ERROR_NOT_ENOUGH_MEMORY;
            Error(("Memory allocation failed\n"));
            goto error;
        }

        pNewRecip->pCountry = NULL;
        pNewRecip->pNext = NULL;
        pNewRecip->lpEntryId = NULL;
        pNewRecip->lpEntryId = 0;
        pNewRecip->bFromAddressBook = FALSE;
        if (!pCurrentRecip)
            pCurrentRecip = pNewRecip;
        else {
            pCurrentRecip->pNext = pNewRecip;
            pCurrentRecip = pCurrentRecip->pNext;
        }
    }


    goto exit;

error:
    FreeRecipientList(pWizardUserMem);
exit:
    return hResult;
}

VOID
FreeRecipientList(
    PWIZARDUSERMEM    pWizardUserMem
    )

/*++

Routine Description:

    Free up the list of recipients associated with each fax job

Arguments:

    pWizardUserMem - Points to the user mode memory structure

Return Value:

    NONE

--*/

{
    PRECIPIENT  pNextRecipient, pFreeRecipient;

    Assert(pWizardUserMem);
    //
    // Free the list of recipients
    //

    pNextRecipient = pWizardUserMem->pRecipients;

    while (pNextRecipient) {

        pFreeRecipient = pNextRecipient;
        pNextRecipient = pNextRecipient->pNext;
        FreeRecipient(pFreeRecipient);
    }

    pWizardUserMem->pRecipients = NULL;
}

INT
SizeOfRecipientList(
    PWIZARDUSERMEM    pWizardUserMem
    )

/*++

Routine Description:

    Calculates size of the list of recipients associated with each fax job

Arguments:

    pWizardUserMem - Points to the user mode memory structure

Return Value:

    size of the list

--*/

{
    PRECIPIENT  pNextRecipient;
    INT iCount = 0;

    Assert(pWizardUserMem);

    pNextRecipient = pWizardUserMem->pRecipients;

    while (pNextRecipient) {
        iCount++;
        pNextRecipient = pNextRecipient->pNext;
    }

    return iCount;
}

INT
FillRecipientListView(
    PWIZARDUSERMEM  pWizardUserMem,
    HWND            hWndList
    )

/*++

Routine Description:

    Fills recipient list view

Arguments:

    pWizardUserMem - Points to the user mode memory structure

Return Value:

    NONE

--*/

{
    PRECIPIENT  pNextRecipient;

    Assert(pWizardUserMem);

    pNextRecipient = pWizardUserMem->pRecipients;

    while (pNextRecipient) {
        if (!InsertRecipientListItem(hWndList,pNextRecipient))
        {
            Warning(("InsertRecipientListItem failed"));
        }
        pNextRecipient = pNextRecipient->pNext;
    }

    //
    // Autosize the last column to get rid of unnecessary horizontal scroll bar
    //
    ListView_SetColumnWidth(hWndList, 1, LVSCW_AUTOSIZE_USEHEADER);

    return TRUE;
}

BOOL
IsAreaCodeMandatory(
    DWORD               dwCountryCode,
    PFAX_TAPI_LINECOUNTRY_LIST pFaxCountryList
    )
/*++

Routine name : IsAreaCodeMandatory

Routine description:

    Checks if an area code is mandatory for a specific long distance rule

Author:

    Oded Sacher (OdedS),    May, 2000

Arguments:

    dwCountryCode                       [in] - The country country code.
    pFaxCountryList                     [in] - The country list obtained by a call to FaxGetCountryList()

Return Value:

    TRUE - The area code is needed.
    FALSE - The area code is not mandatory.

--*/
{
    DWORD dwIndex;

    Assert (pFaxCountryList);

    for (dwIndex=0; dwIndex < pFaxCountryList->dwNumCountries; dwIndex++)
    {
        if (pFaxCountryList->LineCountryEntries[dwIndex].dwCountryCode == dwCountryCode)
        {
            //
            // Matching country code - Check long distance rule.
            //
            if (pFaxCountryList->LineCountryEntries[dwIndex].lpctstrLongDistanceRule)
            {
                if (_tcschr(pFaxCountryList->LineCountryEntries[dwIndex].lpctstrLongDistanceRule, TEXT('F')) != NULL)
                {
                    return TRUE;
                }
                return FALSE;
            }
        }
    }
    return FALSE;
}


BOOL
AddRecipientsToList(
    IN      HWND            hDlg,
    IN OUT  PWIZARDUSERMEM  pWizardUserMem
    )
{
/*++

Routine Description:

    Adds recipients to list control. Checks addresses of each
    recipient form the list. Inserts to the GUI list and new recipient list
    canonical adresses or confirmed addresses by user only.
    Returns a new list of recipients in PWIZARDUSERMEM struct.

Arguments:

    hDlg - Handle to the fax recipient wizard page
    pWizardUserMem - Points to user mode memory structure

Return Value:

    TRUE if successful, FALSE otherwise

--*/
    HWND            hwndLV = NULL;
    PRECIPIENT      tmpRecip = NULL, pPrevRecip=NULL;

    if (! (hwndLV = GetDlgItem(hDlg, IDC_CHOOSE_RECIPIENT_LIST)))
        return FALSE;

    if (!ListView_DeleteAllItems(hwndLV))
    {
        Warning(("ListView_DeleteAllItems failed\n"));
    }

    for (tmpRecip = pWizardUserMem->pRecipients; tmpRecip; tmpRecip = tmpRecip->pNext)
    {
        DWORD dwRes;
        BOOL bCanonicalAdress;
        DWORD dwCountryCode, dwAreaCode;

        dwRes = IsCanonicalAddress( tmpRecip->pAddress,
                                    &bCanonicalAdress,
                                    &dwCountryCode,
                                    &dwAreaCode,
                                    NULL);
        if (ERROR_SUCCESS != dwRes)
        {
            Error(("IsCanonicalAddress failed\n"));
        }
        else
        {
            tmpRecip->bUseDialingRules = TRUE;
            tmpRecip->dwDialingRuleId = g_dwCurrentDialingLocation;

            if (bCanonicalAdress)
            {
                if (IsAreaCodeMandatory(dwCountryCode, pWizardUserMem->pCountryList) &&
                    ROUTING_RULE_AREA_CODE_ANY == dwAreaCode)
                {
                    tmpRecip->bUseDialingRules = FALSE;
                }
            }
            else
            {
                tmpRecip->bUseDialingRules = FALSE;
            }
        }

        if (!InsertRecipientListItem(hwndLV, tmpRecip))
        {
            Warning(("InsertRecipientListItem failed"));
        }
    }

    // remove empty recipients
    for (tmpRecip = pWizardUserMem->pRecipients,pPrevRecip=NULL; tmpRecip; )
    {
        if ((tmpRecip->pAddress == NULL) && (tmpRecip->pName == NULL))
        {
            // Should be removed
            if (pPrevRecip==NULL)
            {
                pWizardUserMem->pRecipients = tmpRecip->pNext;
                MemFree(tmpRecip);
                tmpRecip = pWizardUserMem->pRecipients;
            }
            else
            {
                pPrevRecip->pNext= tmpRecip->pNext;
                MemFree(tmpRecip);
                tmpRecip = pPrevRecip->pNext;
            }
        }
        else
        {
            pPrevRecip = tmpRecip;
            tmpRecip = tmpRecip->pNext;
        }
    }

    return TRUE;
}

BOOL
DoAddressBook(
    HWND            hDlg,
    PWIZARDUSERMEM  pWizardUserMem
    )

/*++

Routine Description:

    Display the MAPI address book dialog

Arguments:

    hDlg - Handle to the fax recipient wizard page
    pWizardUserMem - Points to user mode memory structure

Return Value:

    TRUE if successful, FALSE otherwise

--*/

{
    HWND            hwndLV = NULL;
    BOOL            result = TRUE;
    PRECIPIENT      pNewRecip = NULL;

    //
    // Init MAPI address book
    //
    if (!pWizardUserMem->lpMAPIabInit)
    {
        pWizardUserMem->lpMAPIabInit = InitializeMAPIAB(g_hResource,hDlg);
    }

    //
    // Init WAB
    //
    if (!pWizardUserMem->lpWabInit && !pWizardUserMem->lpMAPIabInit)
    {
        pWizardUserMem->lpWabInit = InitializeWAB(g_hResource);
    }

    if(!pWizardUserMem->lpMAPIabInit && 
       !pWizardUserMem->lpWabInit)
    {
        ErrorMessageBox(hDlg, IDS_ERR_NO_ADDRESS_BOOK, MB_ICONERROR);
        return FALSE;
    }
    //
    // Add current recipient to the list if necessary
    //

    AddRecipient(hDlg, pWizardUserMem);


    if (pWizardUserMem->lpMAPIabInit)
    {
        result = CallMAPIabAddress(
                    hDlg,
                    pWizardUserMem,
                    &pNewRecip
                    );
    }
    else if(pWizardUserMem->lpWabInit)
    {
        result = CallWabAddress(
                    hDlg,
                    pWizardUserMem,
                    &pNewRecip
                    );
    }

    FreeRecipientList(pWizardUserMem);

    // copy new list of recipients from Address book to the pWizardUserMem
    pWizardUserMem->pRecipients = pNewRecip;

    if (!AddRecipientsToList(
                    hDlg,
                    pWizardUserMem))
    {
        Error(("Failed to add recipients to the list\n"));
    }

    if (!result)
    {
        DisplayMessageDialog( hDlg, MB_OK, IDS_WIZARD_TITLE, IDS_BAD_ADDRESS_TYPE );
    }

    return result;
}


LPTSTR
GetEMailAddress(
    HWND        hDlg,
    PWIZARDUSERMEM    pWizardUserMem
    )

/*++

Routine Description:

    Display the MAPI address book dialog

Arguments:

    hDlg - Handle to the fax recipient wizard page
    pWizardUserMem - Points to user mode memory structure

Return Value:

    TRUE if successful, FALSE otherwise

--*/

{
    LPTSTR          result;

    if(!pWizardUserMem->lpMAPIabInit)
    {
        pWizardUserMem->lpMAPIabInit = InitializeMAPIAB(g_hResource,hDlg);
    }

    if(!pWizardUserMem->lpMAPIabInit && !pWizardUserMem->lpWabInit)
    {
        pWizardUserMem->lpWabInit = InitializeWAB(g_hResource);
    }

    if(!pWizardUserMem->lpMAPIabInit && !pWizardUserMem->lpWabInit)
    {
        ErrorMessageBox(hDlg, IDS_ERR_NO_ADDRESS_BOOK, MB_ICONERROR);
        return FALSE;
    }
    //
    // Get a handle to the recipient list window
    //

    if (pWizardUserMem->lpMAPIabInit)
    {
        result = CallMAPIabAddressEmail(hDlg,
                                        pWizardUserMem);
    }
    else
    {
        result = CallWabAddressEmail(hDlg,
                                     pWizardUserMem);
    }

    return result;
}

BOOL
ValidateRecipients(
    HWND        hDlg,
    PWIZARDUSERMEM pWizardUserMem
    )

/*++

Routine Description:

    Validate the list of fax recipients entered by the user

Arguments:

    hDlg - Handle to the fax recipient wizard page
    pWizardUserMem - Points to user mode memory structure

Return Value:

    TRUE if successful, FALSE otherwise

--*/

{
    INT iErrorStringId = 0;
    INT iCtrlId = 0;
    BOOL bDisplayPopup = FALSE;	
    
    if ((0 == GetWindowTextLength(GetDlgItem(hDlg, IDC_CHOOSE_NUMBER_EDIT))) &&
        (0 == GetWindowTextLength(GetDlgItem(hDlg, IDC_CHOOSE_NAME_EDIT))))
    {
        //
        // The name + phone number are empty.
        // This means that the current recipient will not be added to the list.
        // It's valid to press 'Next' on the recipients page if the list of recipients is not empty
        //
        if (!pWizardUserMem->pRecipients)       
        {
            //
            // At least one recipient must be there
            //
            iErrorStringId = IDS_BAD_RECIPIENT_NAME;
        }
    }
    else
    {
        //
        // There's a phone number
        // Add current recipient to the list
        //
        iErrorStringId = AddRecipient(hDlg, pWizardUserMem);        
    }


	if (0 == iErrorStringId)
	{
		//
		// no errors so far, check recipients limit
		//
		DWORD dwRecipientsCount = SizeOfRecipientList(pWizardUserMem);        
		if (dwRecipientsCount > 0)
		{
			//
			// There are some recipients, check the recipient limit.
			//
			if (0 != pWizardUserMem->dwRecipientsLimit && // The recipients limit exists
				dwRecipientsCount > pWizardUserMem->dwRecipientsLimit)
			{
				//
				// recipients limit exceeded, tell the user to remove some
				//
				iErrorStringId = IDS_WZRD_RECIPIENTS_LIMIT;
			}
			else
			{
				//
				// All is OK
				//
				return TRUE;
			}
		}	
	}

    //
    // Failed to add recipient
    // Set current focus to the appropriate text field as a convenience
    //
    switch (iErrorStringId)
    {
        case IDS_INVALID_RECIPIENT_NUMBER:
            SetDlgItemText(hDlg, IDC_CHOOSE_NUMBER_EDIT, _T(""));
            //
            // Fall through...
            //
        case IDS_BAD_RECIPIENT_NUMBER:
            iCtrlId = IDC_CHOOSE_NUMBER_EDIT;
            bDisplayPopup = TRUE;
            break;

        case IDS_ERROR_AREA_CODE:
            SetDlgItemText(hDlg, IDC_CHOOSE_AREA_CODE_EDIT, _T(""));
            //
            // Fall through...
            //
        case IDS_BAD_RECIPIENT_AREACODE:
            iCtrlId = IDC_CHOOSE_AREA_CODE_EDIT;
            bDisplayPopup = TRUE;
            break;

        case IDS_BAD_RECIPIENT_COUNTRY_CODE:
            iCtrlId = IDC_CHOOSE_COUNTRY_COMBO;
            bDisplayPopup = TRUE;
            break;

        case IDS_BAD_RECIPIENT_NAME:
		case IDS_WZRD_RECIPIENTS_LIMIT:
            bDisplayPopup = TRUE;
            //
            // Fall through...
            //
        default:
            iCtrlId = IDC_CHOOSE_NAME_EDIT;
            break;
    }
    if (bDisplayPopup)
    {
        //
        // Display an error message
        //
		if (IDS_WZRD_RECIPIENTS_LIMIT == iErrorStringId)
		{
			DisplayMessageDialog(hDlg, 0, IDS_WIZARD_TITLE, iErrorStringId, pWizardUserMem->dwRecipientsLimit);
		}
		else
		{
			DisplayMessageDialog(hDlg, 0, IDS_WIZARD_TITLE, iErrorStringId);
		}
    }
    SetFocus(GetDlgItem(hDlg, iCtrlId));
    return FALSE;
}   // ValidateRecipients


PRECIPIENT *
FindRecipient(
    PWIZARDUSERMEM pWizardUserMem,
    PRECIPIENT  pRecipient
    )

/*++

Routine Description:

    Check if the specified recipient is in the list of recipients

Arguments:

    pWizardUserMem - Points to user mode memory structure
    pRecipient - Specifies the recipient to be found

Return Value:

    Address of the link pointer to the specified recipient
    NULL if the specified recipient is not found

--*/

{
    PRECIPIENT  pCurrent, *ppPrevNext;

    //
    // Search for the specified recipient in the list
    //

    ppPrevNext = (PRECIPIENT *) &pWizardUserMem->pRecipients;
    pCurrent = pWizardUserMem->pRecipients;

    while (pCurrent && pCurrent != pRecipient) {

        ppPrevNext = (PRECIPIENT *) &pCurrent->pNext;
        pCurrent = pCurrent->pNext;
    }

    //
    // Return the address of the link pointer to the specified recipient
    // or NULL if the specified recipient is not found
    //

    return pCurrent ? ppPrevNext : NULL;
}


BOOL
RemoveRecipient(
    HWND        hDlg,
    PWIZARDUSERMEM pWizardUserMem
    )

/*++

Routine Description:

    Remove the currently selected recipient from the recipient list

Arguments:

    hDlg - Handle to the fax recipient wizard page
    pWizardUserMem - Points to user mode memory structure

Return Value:

    TRUE if successful, FALSE otherwise

--*/

{
    PRECIPIENT  pRecipient, *ppPrevNext;
    INT         selIndex;
    HWND        hwndLV;

    //
    // Get the currently selected recipient, and
    // Find the current recipient in the list, then
    // Delete the current recipient and select the next one below it
    //

    if ((hwndLV = GetDlgItem(hDlg, IDC_CHOOSE_RECIPIENT_LIST)) &&
        (selIndex = ListView_GetNextItem(hwndLV, -1, LVNI_ALL|LVNI_SELECTED)) != -1 &&
        (pRecipient = GetRecipientListItem(hwndLV, selIndex)) &&
        (ppPrevNext = FindRecipient(pWizardUserMem, pRecipient)) &&
        ListView_DeleteItem(hwndLV, selIndex))
    {
        ListView_SetItemState(hwndLV,
                              selIndex,
                              LVIS_SELECTED|LVIS_FOCUSED,
                              LVIS_SELECTED|LVIS_FOCUSED);

        //
        // Delete the recipient from the internal list
        //

        *ppPrevNext = pRecipient->pNext;
        FreeRecipient(pRecipient);

        //
        // Autosize the last column to get rid of unnecessary horizontal scroll bar
        //
        ListView_SetColumnWidth(hwndLV, 1, LVSCW_AUTOSIZE_USEHEADER);

        return TRUE;
    }

    MessageBeep(MB_ICONHAND);
    return FALSE;
}


VOID
EditRecipient(
    HWND        hDlg,
    PWIZARDUSERMEM pWizardUserMem
    )
/*++

Routine Description:

    Edit the currently selected recipient in the recipient list

Arguments:

    hDlg - Handle to the fax recipient wizard page
    pWizardUserMem - Points to user mode memory structure

Return Value:

    NONE

--*/
{
    INT_PTR     dlgResult;
    CHECKNUMBER checkNumber = {0};
    DWORD       dwListIndex;
    LV_ITEM     lvi;
    HWND        hListWnd;
    PRECIPIENT  pRecip,pNewRecip;
    TCHAR       szCountry[MAX_STRING_LEN],szName[MAX_STRING_LEN],szAddress[MAX_STRING_LEN];

    ZeroMemory(szName,sizeof(TCHAR)*MAX_STRING_LEN);
    ZeroMemory(szAddress,sizeof(TCHAR)*MAX_STRING_LEN);
    ZeroMemory(szCountry,sizeof(TCHAR)*MAX_STRING_LEN);

    hListWnd = GetDlgItem(hDlg, IDC_CHOOSE_RECIPIENT_LIST);
    dwListIndex = ListView_GetNextItem(hListWnd , -1, LVNI_ALL | LVNI_SELECTED);
    while (dwListIndex != -1)
    {
        // Initialize lvi
        lvi.mask = LVIF_PARAM;
        // Set the item number
        lvi.iItem = dwListIndex;
        // Get the selected item from the list view
        if (ListView_GetItem(hListWnd, &lvi))
        {
            pRecip = (PRECIPIENT) lvi.lParam;
            Assert(pRecip);
            if (!pRecip)
            {
                Error(("Failed to get recipient from recipient list"));
                return;
            }
            if (InitCheckNumber(_tcscpy(szName,pRecip->pName ? pRecip->pName : _T("")),
                                _tcscpy(szAddress,pRecip->pAddress ? pRecip->pAddress : _T("")),
                                _tcscpy(szCountry,pRecip->pCountry ? pRecip->pCountry : _T("")),
                                pRecip->dwCountryId,
								pRecip->dwDialingRuleId,
                                pRecip->bUseDialingRules,
                                pWizardUserMem->pCountryList,
                                &checkNumber))
            {

                dlgResult = DialogBoxParam(
                                     (HINSTANCE) g_hResource,
                                     MAKEINTRESOURCE( IDD_CHECK_FAX_NUMBER ),
                                     hDlg,
                                     CheckFaxNumberDlgProc,
                                     (LPARAM) &checkNumber
                                     );
                if (dlgResult)
                {
                    RemoveRecipient(hDlg, pWizardUserMem);
                    if (!(pNewRecip = MemAllocZ(sizeof(RECIPIENT))))
                    {
                        Error(("Memory allocation failed"));
                        FreeCheckNumberFields(&checkNumber);
                        return;
                    }
                    ZeroMemory(pNewRecip,sizeof(RECIPIENT));

                    if (checkNumber.lptstrName && !(pNewRecip->pName    = StringDup(checkNumber.lptstrName)))
                    {
                        Error(("Memory allocation failed"));
                        MemFree(pNewRecip);
                        FreeCheckNumberFields(&checkNumber);
                        return;
                    }
                    if (checkNumber.lptstrAddress && !(pNewRecip->pAddress = StringDup(checkNumber.lptstrAddress)))
                    {
                        Error(("Memory allocation failed"));
                        MemFree(pNewRecip->pName);
                        MemFree(pNewRecip);
                        FreeCheckNumberFields(&checkNumber);
                        return;
                    }
                    if (szCountry && !(pNewRecip->pCountry = StringDup(szCountry)))
                    {
                        Error(("Memory allocation failed"));
                        MemFree(pNewRecip->pName);
                        MemFree(pNewRecip->pAddress);
                        MemFree(pNewRecip);
                        FreeCheckNumberFields(&checkNumber);
                        return;
                    }

                    pNewRecip->dwCountryId  = checkNumber.dwCountryId;
                    pNewRecip->bUseDialingRules = checkNumber.bUseDialingRules;
					pNewRecip->dwDialingRuleId = checkNumber.dwDialingRuleId;

                    if (InsertRecipientListItem(hListWnd, pNewRecip))
                    {
                        pNewRecip->pNext = pWizardUserMem->pRecipients;
                        pWizardUserMem->pRecipients = pNewRecip;
                    }
                    else
                    {
                        FreeRecipient(pNewRecip);
                    }
                }
                FreeCheckNumberFields(&checkNumber);
            }
            else
            {
                Error(("Failed to initialize CHECKNUMBER structure"));
            }
        }

        dwListIndex = ListView_GetNextItem(hListWnd, dwListIndex, LVNI_ALL | LVNI_SELECTED);
    }
}


VOID
LocationListSelChange(
    HWND            hDlg,
    PWIZARDUSERMEM  pUserMem
    )

/*++

Routine Description:

    Change the default TAPI location

Arguments:

    hDlg     - Handle to "Compose New Fax" wizard window
    pUserMem - Pointer to user mode memory structure

Return Value:

    NONE

--*/

{
    HWND    hwndList;
    LRESULT selIndex;
    DWORD   dwLocationID;

    if ((hwndList = GetDlgItem(hDlg, IDC_COMBO_DIALING_RULES)) &&
        (selIndex = SendMessage(hwndList, CB_GETCURSEL, 0, 0)) != CB_ERR &&
        (dwLocationID = (DWORD)SendMessage(hwndList, CB_GETITEMDATA, selIndex, 0)) != CB_ERR)
    {
        if (USE_LOCAL_SERVER_OUTBOUND_ROUTING != dwLocationID)
        {
            //
            // User selected a real location - set it (in TAPI)
            //
            SetCurrentLocation(dwLocationID);
            pUserMem->lpFaxSendWizardData->bUseOutboundRouting = FALSE;
        }
        else
        {
            //
            // User selected to use the server's outbound routing rules - mark that.
            // We use that information next time we run the wizard, to select the location in the combo-box.
            //
            pUserMem->lpFaxSendWizardData->bUseOutboundRouting = TRUE;
        }
        //
        // Save it globally, will be used by AddRecipient
        //
        g_dwCurrentDialingLocation = dwLocationID;
    }
}   // LocationListSelChange

VOID
LocationListInit(
    HWND              hDlg,
    PWIZARDUSERMEM    pUserMem
)
/*++

Routine Description:

    Initialize the list of TAPI locations

Arguments:

    hDlg - Handle to "Compose New Fax" wizard window
    pUserMem - Pointer to user mode memory structure

Return Value:

    NONE

--*/

{
    HWND                hwndList;
    DWORD               dwIndex;
    LRESULT             listIdx;
    LPTSTR              lptstrLocationName;
    LPTSTR              lptstrSelectedName = NULL;
    DWORD               dwSelectedLocationId;
    LPLINETRANSLATECAPS pTranslateCaps = NULL;
    LPLINELOCATIONENTRY pLocationEntry;

    Assert (pUserMem);
    Assert (pUserMem->isLocalPrinter)

    //
    // Get the list of locations from TAPI and use it
    // to initialize the location combo-box.
    //
    hwndList = GetDlgItem(hDlg, IDC_COMBO_DIALING_RULES);
    Assert (hwndList);

    if (WaitForSingleObject( pUserMem->hTAPIEvent, INFINITE ) != WAIT_OBJECT_0)
    {
        Error(("WaitForSingleObject failed. ec = 0x%X\n", GetLastError()));
        Assert(FALSE);
        return;
    }

    if (pTranslateCaps = GetTapiLocationInfo(hDlg))
    {
        SendMessage(hwndList, CB_RESETCONTENT, 0, 0);

        pLocationEntry = (LPLINELOCATIONENTRY)
            ((PBYTE) pTranslateCaps + pTranslateCaps->dwLocationListOffset);

        for (dwIndex=0; dwIndex < pTranslateCaps->dwNumLocations; dwIndex++)
        {
            lptstrLocationName = (LPTSTR)
                ((PBYTE) pTranslateCaps + pLocationEntry->dwLocationNameOffset);

            if (pLocationEntry->dwPermanentLocationID == pTranslateCaps->dwCurrentLocationID)
            {
                lptstrSelectedName = lptstrLocationName;
                dwSelectedLocationId = pLocationEntry->dwPermanentLocationID;
            }

            listIdx = SendMessage(hwndList, CB_INSERTSTRING, 0, (LPARAM) lptstrLocationName);

            if (listIdx != CB_ERR)
            {
                SendMessage(hwndList,
                            CB_SETITEMDATA,
                            listIdx,
                            pLocationEntry->dwPermanentLocationID);
            }
            pLocationEntry++;
        }
    }
    //
    // Let's see if we should add the "Use Outbound Routing Rules" option to the list
    //
    if (!IsDesktopSKU())
    {
        //
        // Not consumer SKU.
        // There's a chance we have outbound routing rules.
        // Add this option to the combo-box
        //
        TCHAR tszUseOutboundRouting[MAX_PATH];
        if (LoadString (g_hResource, IDS_USE_OUTBOUND_ROUTING, tszUseOutboundRouting, ARR_SIZE(tszUseOutboundRouting)))
        {
            SendMessage(hwndList,
                        CB_INSERTSTRING,
                        0,
                        (LPARAM)tszUseOutboundRouting);
            SendMessage(hwndList,
                        CB_SETITEMDATA,
                        0,
                        USE_LOCAL_SERVER_OUTBOUND_ROUTING);
            //
            // Restore last 'use outbound routing' option
            //
            if (pUserMem->lpFaxSendWizardData->bUseOutboundRouting)
            {
                lptstrSelectedName = NULL;
                g_dwCurrentDialingLocation = USE_LOCAL_SERVER_OUTBOUND_ROUTING;
                SendMessage(hwndList,
                            CB_SETCURSEL,
                            0,
                            0);
            }
        }
        else
        {
            Warning(("LoadString failed. ec = 0x%X\n",GetLastError()));
        }
    }

    if (lptstrSelectedName != NULL)
    {
        //
        // Select the current dialing location in the combo-box
        //
        SendMessage(hwndList,
                    CB_SELECTSTRING,
                    (WPARAM) -1,
                    (LPARAM) lptstrSelectedName);
        g_dwCurrentDialingLocation = dwSelectedLocationId;
    }
    MemFree(pTranslateCaps);
}   // LocationListInit



void
CalcRecipientButtonsState(
    HWND    hDlg,
    PWIZARDUSERMEM    pWizardUserMem
)
/*++

Routine Description:

    calculate Add, Remove and Edit buttons state

Arguments:

    hDlg           - Identifies the wizard page
    pWizardUserMem - pointer to WIZARDUSERMEM struct

Return Value:

    none

--*/
{

    BOOL bEnable;

    EnableWindow(GetDlgItem(hDlg, IDC_CHOOSE_ADD),
                 GetCurrentRecipient(hDlg,pWizardUserMem, NULL) == 0);

    bEnable = (ListView_GetNextItem(GetDlgItem(hDlg, IDC_CHOOSE_RECIPIENT_LIST),
                                    -1, LVNI_ALL | LVNI_SELECTED) != -1);

    EnableWindow(GetDlgItem(hDlg, IDC_CHOOSE_REMOVE), bEnable);
    EnableWindow(GetDlgItem(hDlg, IDC_CHOOSE_EDIT), bEnable);
}

DWORD
GetControlRect(
    HWND  hCtrl,
    PRECT pRc
)
/*++

Routine Description:

    Retrieves the dimensions of the dialog control in dialog coordinates

Arguments:

    hCtrl    [in]  - Identifies the dialog control
    pRc      [out] - control dimensions rect

Return Value:

    Win32 error code

--*/
{
    DWORD dwRes = ERROR_SUCCESS;
    POINT pt;

    if(!pRc || !hCtrl)
    {
        return ERROR_INVALID_PARAMETER;
    }

    //
    // Get the control rect
    //
    if(!GetWindowRect(hCtrl, pRc))
    {
        dwRes = GetLastError();
        Error(("GetWindowRect failed. ec = 0x%X\n", dwRes));
        return dwRes;
    }

    //
    // Convert the control dimensions to the dialog coordinates
    //
    pt.x = pRc->left;
    pt.y = pRc->top;
    if(!ScreenToClient (GetParent(hCtrl), &pt))
    {
        dwRes = GetLastError();
        Error(("ScreenToClient failed. ec = 0x%X\n", dwRes));
        return dwRes;
    }
    pRc->left = pt.x;
    pRc->top  = pt.y;

    pt.x = pRc->right;
    pt.y = pRc->bottom;
    if(!ScreenToClient (GetParent(hCtrl), &pt))
    {
        dwRes = GetLastError();
        Error(("ScreenToClient failed. ec = 0x%X\n", dwRes));
        return dwRes;
    }
    pRc->right  = pt.x;
    pRc->bottom = pt.y;

    return dwRes;

} // GetControlRect


INT_PTR
RecipientWizProc(
    HWND    hDlg,
    UINT    message,
    WPARAM  wParam,
    LPARAM  lParam
    )

/*++

Routine Description:

    Dialog procedure for the first wizard page: selecting the fax recipient

Arguments:

    hDlg - Identifies the wizard page
    message - Specifies the message
    wParam - Specifies additional message-specific information
    lParam - Specifies additional message-specific information

Return Value:

    Depends on the message parameter

--*/

{
    PWIZARDUSERMEM    pWizardUserMem;
    DWORD       countryId = 0;
    INT         cmd;
    NMHDR      *pNMHdr;
    HANDLE hEditControl;
    DWORD               dwMessagePos;
    static HMENU        hMenu = NULL;
    // hReciptMenu is the handle to the receipt menu
    static HMENU        hReciptMenu;
    BOOL                bEnable;

    //
    // Maximum length for various text fields
    //
    static INT  textLimits[] =
    {
        IDC_CHOOSE_NAME_EDIT,       64,
        IDC_CHOOSE_AREA_CODE_EDIT,  11,
        IDC_CHOOSE_NUMBER_EDIT,     51,
        0
    };
    //
    // Handle common messages shared by all wizard pages
    //
    if (! (pWizardUserMem = CommonWizardProc(hDlg,
                                             message,
                                             wParam,
                                             lParam,
                                             PSWIZB_BACK | PSWIZB_NEXT)))
    {
         return FALSE;
    }

    switch (message)
    {

    case WM_DESTROY:
        if (hMenu)
        {
            DestroyMenu (hMenu);
            hMenu = NULL;
        }
        break;

    case WM_INITDIALOG:
        //
        // check if the user has run the wizard before so they can fill in the coverpage info.
        //
        if (!(hMenu = LoadMenu(g_hResource,  MAKEINTRESOURCE(IDR_MENU) )))
        {
            Error(("LoadMenu failed. ec = 0x%X\n",GetLastError()));
            Assert(FALSE);
        }
        else if (!(hReciptMenu = GetSubMenu(hMenu,0)))
        {
            Error(("GetSubMenu failed. ec = 0x%X\n",GetLastError()));
            Assert(FALSE);
        }
        LimitTextFields(hDlg, textLimits);
        //
        // Initialize the recipient list view
        //
        if (!GetDlgItem(hDlg, IDC_CHOOSE_RECIPIENT_LIST))
        {
            Warning(("GetDlgItem failed. ec = 0x%X\n",GetLastError()));
        }
        else
        {
            if (!InitRecipientListView(GetDlgItem(hDlg, IDC_CHOOSE_RECIPIENT_LIST)))
            {
                Warning(("InitRecipientListView failed\n"));
            }
        }

        // Disable the IME for the area code edit control.

        hEditControl = GetDlgItem( hDlg, IDC_CHOOSE_AREA_CODE_EDIT );

        if ( hEditControl != NULL )
        {
            ImmAssociateContext( hEditControl, (HIMC)0 );
        }
        // Disable the IME for the fax phone number edit control.
        hEditControl = GetDlgItem( hDlg, IDC_CHOOSE_NUMBER_EDIT );

        if ( hEditControl != NULL )
        {
           ImmAssociateContext( hEditControl, (HIMC)0 );
        }


        if(IsWindowRTL(hDlg))
        {
            //
            // Area code field always should be on the left side of the fax number field
            // So, we switch them when the layout is RTL
            //
            int   nShift;
            RECT  rcNum, rcCode;
            HWND  hNum,  hCode;
            DWORD dwRes;

            //
            // A numeric edit control should be LTR
            //
            SetLTREditDirection(hDlg, IDC_CHOOSE_NUMBER_EDIT);
            SetLTREditDirection(hDlg, IDC_CHOOSE_AREA_CODE_EDIT);

            //
            // Calculate the area code shift value
            //
            hNum  = GetDlgItem( hDlg, IDC_CHOOSE_NUMBER_EDIT );
            dwRes = GetControlRect(hNum, &rcNum);
            if(ERROR_SUCCESS != dwRes)
            {
                goto rtl_exit;
            }

            hCode = GetDlgItem( hDlg, IDC_CHOOSE_AREA_CODE_EDIT );
            dwRes = GetControlRect(hCode, &rcCode);
            if(ERROR_SUCCESS != dwRes)
            {
                goto rtl_exit;
            }

            nShift = rcNum.left - rcCode.left;

            //
            // Move the fax number on the place of the crea code
            //
            SetWindowPos(hNum, 0,
                         rcCode.right,
                         rcNum.top,
                         0, 0,
                         SWP_NOSIZE | SWP_NOZORDER | SWP_SHOWWINDOW);

            //
            // Shift the area code
            //
            SetWindowPos(hCode, 0,
                         rcCode.right + nShift,
                         rcCode.top,
                         0, 0,
                         SWP_NOSIZE | SWP_NOZORDER | SWP_SHOWWINDOW);

            //
            // Shift the area code left bracket
            //
            hCode = GetDlgItem( hDlg, IDC_BRACKET_LEFT );
            dwRes = GetControlRect(hCode, &rcCode);
            if(ERROR_SUCCESS != dwRes)
            {
                goto rtl_exit;
            }
            SetWindowPos(hCode, 0,
                         rcCode.right + nShift,
                         rcCode.top,
                         0, 0,
                         SWP_NOSIZE | SWP_NOZORDER | SWP_SHOWWINDOW);

            //
            // Shift the area code right bracket
            //
            hCode = GetDlgItem( hDlg, IDC_BRACKET_RIGHT );
            dwRes = GetControlRect(hCode, &rcCode);
            if(ERROR_SUCCESS != dwRes)
            {
                goto rtl_exit;
            }
            SetWindowPos(hCode, 0,
                         rcCode.right + nShift,
                         rcCode.top,
                         0, 0,
                         SWP_NOSIZE | SWP_NOZORDER | SWP_SHOWWINDOW);

        } rtl_exit:
        //
        // Initialize the list of countries
        // Init country combo box and try to identify the country
        //
        Assert(pWizardUserMem->pCountryList != NULL);

        InitCountryListBox(pWizardUserMem->pCountryList,
                           GetDlgItem(hDlg, IDC_CHOOSE_COUNTRY_COMBO),
                           GetDlgItem(hDlg, IDC_CHOOSE_AREA_CODE_EDIT),
                           NULL,
                           countryId,
                           TRUE);

        CalcRecipientButtonsState(hDlg, pWizardUserMem);

        if (pWizardUserMem->isLocalPrinter)
        {
            //
            // On local printers, we have dialing rules capabilities
            // Init the combo-box of dialing rules
            //
            LocationListInit (hDlg, pWizardUserMem);
        }
        else
        {
            //
            // When faxing remotely, we never use dialing rules (security issue with credit card info).
            // Hide the dialing rules combo-box and button
            //
            EnableWindow(GetDlgItem(hDlg, IDC_COMBO_DIALING_RULES), FALSE);
            ShowWindow (GetDlgItem(hDlg, IDC_COMBO_DIALING_RULES), SW_HIDE);
            EnableWindow(GetDlgItem(hDlg, IDC_DIALING_RULES), FALSE);
            ShowWindow (GetDlgItem(hDlg, IDC_DIALING_RULES), SW_HIDE);
        }
        //
        // Restore the 'Use dialing rules' checkbox state
        //
        if (pWizardUserMem->lpFaxSendWizardData->bUseDialingRules)
        {
            if (!CheckDlgButton(hDlg, IDC_USE_DIALING_RULE, BST_CHECKED))
            {
                Warning(("CheckDlgButton(IDC_USE_DIALING_RULE) failed. ec = 0x%X\n",GetLastError()));
            }
        }
        else
        {
            //
            // 'Use dialing rule' is off - this implies 'Dial as entered'
            //
            EnableWindow(GetDlgItem(hDlg, IDC_CHOOSE_AREA_CODE_EDIT), FALSE);
            EnableWindow(GetDlgItem(hDlg, IDC_CHOOSE_COUNTRY_COMBO),  FALSE);
            EnableWindow(GetDlgItem(hDlg, IDC_COMBO_DIALING_RULES),   FALSE);
            EnableWindow(GetDlgItem(hDlg, IDC_DIALING_RULES),         FALSE);
        }
        break;

    case WM_CONTEXTMENU:
        {
            //
            // Also handle keyboard-originated context menu (<Shift>+F10 or VK_APP)
            //
            HWND hListWnd;
            if (!(hListWnd = GetDlgItem(hDlg, IDC_CHOOSE_RECIPIENT_LIST)))
            {
                Error(("GetDlgItem failed. ec = 0x%X\n",GetLastError()));
                break;
            }
            if (hListWnd != GetFocus())
            {
                //
                // Only show context sensitive menu if the focus is on the list control
                //
                break;
            }
            if (ListView_GetSelectedCount(hListWnd) != 1)
            {
                //
                // No item is selected in the list control ==> no menu
                //
                break;
            }
            //
            // Get the cursor position
            //
            dwMessagePos = GetMessagePos();
            //
            // Display the document context menu
            //
            if (!TrackPopupMenu(hReciptMenu,
                                TPM_LEFTALIGN | TPM_LEFTBUTTON,
                                GET_X_LPARAM (dwMessagePos),
                                GET_Y_LPARAM (dwMessagePos),
                                0,
                                hDlg,
                                NULL))
            {
                Warning(("TrackPopupMenu failed. ec = 0x%X\n",GetLastError()));
            }
            break;
        }


    case WM_NOTIFY:

        pNMHdr = (LPNMHDR ) lParam;

        Assert(pNMHdr);

        switch (pNMHdr->code)
        {

        case LVN_KEYDOWN:

            if (pNMHdr->hwndFrom == GetDlgItem(hDlg, IDC_CHOOSE_RECIPIENT_LIST) &&
                ((LV_KEYDOWN *) pNMHdr)->wVKey == VK_DELETE)
            {
                if (!RemoveRecipient(hDlg, pWizardUserMem))
                {
                    Warning(("RemoveRecipient failed\n"));
                }
            }
            break;

        case LVN_ITEMCHANGED:

            CalcRecipientButtonsState(hDlg, pWizardUserMem);

            break;

        case PSN_WIZNEXT:

            pWizardUserMem->lpFaxSendWizardData->bUseDialingRules =
                (IsDlgButtonChecked(hDlg, IDC_USE_DIALING_RULE) == BST_CHECKED);

            if (! ValidateRecipients(hDlg, pWizardUserMem))
            {
                //
                // Validate the list of recipients and prevent the user
                // from advancing to the next page if there is a problem
                //
                SetWindowLongPtr(hDlg, DWLP_MSGRESULT, -1);
                return TRUE;
            }
            break;

        case PSN_SETACTIVE:
            CalcRecipientButtonsState(hDlg, pWizardUserMem);
            break;
        }

        return FALSE;

    case WM_COMMAND:

        cmd = GET_WM_COMMAND_CMD(wParam, lParam);

        switch (GET_WM_COMMAND_ID(wParam, lParam))
        {

        case IDC_DIALING_RULES:
            //
            // Use pressed the 'Dialing rules...' button
            //
            DoTapiProps(hDlg);
            LocationListInit(hDlg, pWizardUserMem);
            break;

        case IDC_COMBO_DIALING_RULES:

            if (CBN_SELCHANGE == cmd)
            {
                LocationListSelChange(hDlg, pWizardUserMem);
            }
            break;

        case IDC_USE_DIALING_RULE:
            pWizardUserMem->lpFaxSendWizardData->bUseDialingRules =
                            (IsDlgButtonChecked(hDlg, IDC_USE_DIALING_RULE) == BST_CHECKED);

            bEnable = pWizardUserMem->lpFaxSendWizardData->bUseDialingRules;
            EnableWindow(GetDlgItem(hDlg, IDC_CHOOSE_AREA_CODE_EDIT), bEnable);
            EnableWindow(GetDlgItem(hDlg, IDC_CHOOSE_COUNTRY_COMBO),  bEnable);
            EnableWindow(GetDlgItem(hDlg, IDC_COMBO_DIALING_RULES),  bEnable);
            EnableWindow(GetDlgItem(hDlg, IDC_DIALING_RULES),  bEnable);

            CalcRecipientButtonsState(hDlg, pWizardUserMem);

            break;

        case IDC_CHOOSE_COUNTRY_COMBO:

            if (cmd == CBN_SELCHANGE)
            {

                //
                // Update the area code edit box if necessary
                //

                if (!(GetDlgItem(hDlg, IDC_CHOOSE_COUNTRY_COMBO)) ||
                    !(GetDlgItem(hDlg, IDC_CHOOSE_AREA_CODE_EDIT)))
                {
                    Warning(("GetDlgItem failed. ec = 0x%X\n",GetLastError()));
                }
                else
                {
                    SelChangeCountryListBox(GetDlgItem(hDlg, IDC_CHOOSE_COUNTRY_COMBO),
                                            GetDlgItem(hDlg, IDC_CHOOSE_AREA_CODE_EDIT),
                                            pWizardUserMem->pCountryList);
                }

                CalcRecipientButtonsState(hDlg, pWizardUserMem);

            }
            break;

        case IDC_CHOOSE_NAME_EDIT:

            if (cmd == EN_CHANGE)
            {
                CalcRecipientButtonsState(hDlg, pWizardUserMem);
            }

            break;

        case IDC_CHOOSE_AREA_CODE_EDIT:

            if (cmd == EN_CHANGE)
            {
                CalcRecipientButtonsState(hDlg, pWizardUserMem);
            }
            break;

        case IDC_CHOOSE_NUMBER_EDIT:

            if (cmd == EN_CHANGE)
            {
                CalcRecipientButtonsState(hDlg, pWizardUserMem);
            }

            break;

        case IDC_CHOOSE_ADDRBOOK:

            if (!DoAddressBook(hDlg, pWizardUserMem))
            {
                Error(("DoAddressBook failed\n"));
            }
            CalcRecipientButtonsState(hDlg, pWizardUserMem);
            break;


        case IDC_CHOOSE_ADD:

            if ((cmd = AddRecipient(hDlg, pWizardUserMem)) != 0)
            {

                if (cmd > 0)
                    DisplayMessageDialog(hDlg, 0, IDS_WIZARD_TITLE, cmd);
                else
                    MessageBeep(MB_OK);

            }
            else
            {
                SetFocus(GetDlgItem(hDlg, IDC_CHOOSE_NAME_EDIT));

                CalcRecipientButtonsState(hDlg, pWizardUserMem);
            }
            break;
         case IDC_CHOOSE_REMOVE:
            RemoveRecipient(hDlg, pWizardUserMem);
            CalcRecipientButtonsState(hDlg, pWizardUserMem);
			if (IsWindowEnabled(GetDlgItem(hDlg, IDC_CHOOSE_REMOVE)))
			{
				SetFocus(GetDlgItem(hDlg, IDC_CHOOSE_REMOVE));
			}
			else
			{
				SetFocus(GetDlgItem(hDlg, IDC_CHOOSE_NAME_EDIT));
			}
            break;
         case IDC_CHOOSE_EDIT:
            EditRecipient(hDlg, pWizardUserMem);
            SetFocus(GetDlgItem(hDlg, IDC_CHOOSE_EDIT));
            break;
        }

        switch (LOWORD(wParam))
        {

            case IDM_RECIPT_DELETE:
                RemoveRecipient(hDlg, pWizardUserMem);
                CalcRecipientButtonsState(hDlg, pWizardUserMem);
                break;
            case IDM_RECIPT_EDIT:
                EditRecipient(hDlg, pWizardUserMem);
                break;
        }
        break;
    }

    return TRUE;
}



VOID
ValidateSelectedCoverPage(
    PWIZARDUSERMEM    pWizardUserMem
    )

/*++

Routine Description:

    If a cover page is selected, then do the following:
        if the cover page file is a link resolve it
        check if the cover page file contains note/subject fields

Arguments:

    pWizardUserMem - Points to user mode memory structure

Return Value:

    NONE

--*/

{
    COVDOCINFO  covDocInfo;
    DWORD       ec;

    Verbose(("Cover page selected: %ws\n", pWizardUserMem->lpFaxSendWizardData->lpCoverPageInfo->lptstrCoverPageFileName));
    ec = RenderCoverPage(NULL,
                         NULL,
                         NULL,
                         pWizardUserMem->lpFaxSendWizardData->lpCoverPageInfo->lptstrCoverPageFileName,
                         &covDocInfo,
                         FALSE);

    if (ERROR_SUCCESS == ec)
    {
        pWizardUserMem->noteSubjectFlag = covDocInfo.Flags;
        pWizardUserMem->cpPaperSize = covDocInfo.PaperSize;
        pWizardUserMem->cpOrientation = covDocInfo.Orientation;
    }
    else
    {
        Error(("Cannot examine cover page file '%ws': %d\n",
               pWizardUserMem->lpFaxSendWizardData->lpCoverPageInfo->lptstrCoverPageFileName,
               ec));
    }
}





INT_PTR
CoverPageWizProc(
    HWND    hDlg,
    UINT    message,
    WPARAM  wParam,
    LPARAM  lParam
    )

/*++

Routine Description:

    Dialog procedure for the second wizard page:
    selecting cover page and setting other fax options

Arguments:

    hDlg - Identifies the wizard page
    message - Specifies the message
    wParam - Specifies additional message-specific information
    lParam - Specifies additional message-specific information

Return Value:

    Depends on the message parameter

--*/

{
#define PREVIEW_BITMAP_WIDTH    (850)
#define PREVIEW_BITMAP_HEIGHT   (1098)

    static INT  textLimits[] = {

        IDC_CHOOSE_CP_SUBJECT,   256,
        IDC_CHOOSE_CP_NOTE,   8192,
        0
    };

    PWIZARDUSERMEM  pWizardUserMem;
    WORD            cmdId;
    HWND            hwnd;
    RECT            rc;
    double          dRatio;
    LONG_PTR        numOfCoverPages = 0;

    HDC             hDC = NULL;
    TCHAR           szCoverFileName[MAX_PATH];

    //
    // Handle common messages shared by all wizard pages
    //
    if (! (pWizardUserMem = CommonWizardProc(hDlg, message, wParam, lParam, PSWIZB_BACK|PSWIZB_NEXT)))
    {
          return FALSE;
    }
    //
    // Handle anything specific to the current wizard page
    //

    switch (message) 
    {
    case WM_INITDIALOG:
        //
        // Measure the mini-preview current (portrait) dimensions
        //

        g_bPreviewRTL = IsWindowRTL(hDlg);

        SetLTRControlLayout(hDlg, IDC_STATIC_CP_PREVIEW);

        if (ERROR_SUCCESS != GetControlRect(GetDlgItem(hDlg, IDC_STATIC_CP_PREVIEW), &rc))
        {
            g_dwMiniPreviewPortraitWidth = 1;
            g_dwMiniPreviewPortraitHeight = 1;
        }
        else
        {        
            g_dwMiniPreviewPortraitWidth  = abs(rc.right - rc.left) + 1;
            g_dwMiniPreviewPortraitHeight = rc.bottom - rc.top + 1;
        }
        //
        // By default, the mini-preview is set to portrait
        //
        g_wCurrMiniPreviewOrientation = DMORIENT_PORTRAIT;
        //
        // Now, derive the landscape dimensions from the portrait ones
        //
        g_dwMiniPreviewLandscapeWidth = (DWORD)((double)1.2 * (double)g_dwMiniPreviewPortraitWidth);
        dRatio = (double)(g_dwMiniPreviewPortraitWidth) / (double)(g_dwMiniPreviewPortraitHeight);
        Assert (dRatio < 1.0);
        g_dwMiniPreviewLandscapeHeight = (DWORD)((double)(g_dwMiniPreviewLandscapeWidth) * dRatio);
        //
        // Initialize the list of cover pages
        //
        if (WaitForSingleObject( pWizardUserMem->hCPEvent, INFINITE ) != WAIT_OBJECT_0)
        {
            Error(("WaitForSingleObject failed. ec = 0x%X\n",GetLastError()));
            Assert(FALSE);
            //
            //  We cannot wait for this flag to be set, so make it default TRUE
            //
            pWizardUserMem->ServerCPOnly = TRUE;
        }

        pWizardUserMem->pCPInfo = AllocCoverPageInfo(pWizardUserMem->lptstrServerName,
                                                     pWizardUserMem->lptstrPrinterName,
                                                     pWizardUserMem->ServerCPOnly);
        if (pWizardUserMem->pCPInfo)
        {

            InitCoverPageList(pWizardUserMem->pCPInfo,
                              GetDlgItem(hDlg, IDC_CHOOSE_CP_LIST),
                              pWizardUserMem->lpInitialData->lpCoverPageInfo->lptstrCoverPageFileName);
        }
        //
        // Indicate whether cover page should be sent
        //
        numOfCoverPages = SendDlgItemMessage(hDlg, IDC_CHOOSE_CP_LIST, CB_GETCOUNT, 0, 0);
        if ( numOfCoverPages <= 0)
        {
            pWizardUserMem->bSendCoverPage  = FALSE;
            EnableWindow(GetDlgItem(hDlg, IDC_CHOOSE_CP_CHECK), FALSE);
        }
        //
        // make sure the user selects a coverpage if this is the fax send utility
        //
        if (pWizardUserMem->dwFlags & FSW_FORCE_COVERPAGE)
        {
            pWizardUserMem->bSendCoverPage  = TRUE;
            // hide the checkbox
            CheckDlgButton(hDlg, IDC_CHOOSE_CP_CHECK, BST_INDETERMINATE );
            EnableWindow(GetDlgItem(hDlg, IDC_CHOOSE_CP_CHECK), FALSE);
            // If there are no cover pages, we should not allow to proceed. So we flag it here
            if ( numOfCoverPages <= 0)
            {
                pWizardUserMem->bSendCoverPage = FALSE;
            }
            else
            {
                // In case there are cover pages, then
                pWizardUserMem->bSendCoverPage = TRUE;
            }
        }

        CheckDlgButton(hDlg, IDC_CHOOSE_CP_CHECK, pWizardUserMem->bSendCoverPage );
        if (!EnableCoverDlgItems(pWizardUserMem,hDlg))
        {
            Error(("Failed to enable/disable note and subject field by selected cover page on Init."));
        }
        LimitTextFields(hDlg, textLimits);

        g_hwndPreview = GetDlgItem(hDlg,IDC_STATIC_CP_PREVIEW);
        //
        // Subclass the static control we use for preview. This allows us to handle its WM_PAINT messages
        //
        pWizardUserMem->wpOrigStaticControlProc = (WNDPROC) SetWindowLongPtr(g_hwndPreview,GWLP_WNDPROC, (LONG_PTR) PreviewSubclassProc);
        //
        // Allow the preview control to have access to the WizardUserMem structure
        //
        g_pWizardUserMem = pWizardUserMem;
        //
        // Simulate cover page selection
        //
        SendMessage(hDlg,WM_COMMAND,MAKEWPARAM(IDC_CHOOSE_CP_LIST,LBN_SELCHANGE),0);

        break;

    case WM_COMMAND:
        switch (cmdId = GET_WM_COMMAND_ID(wParam, lParam)) 
        {

        case IDC_CHOOSE_CP_CHECK:
            if (!EnableCoverDlgItems(pWizardUserMem,hDlg)) 
            {
                    Error(("Failed to enable/disable note and subject field on CP_CHECK."));
            }
            break;
        case IDC_CHOOSE_CP_LIST:
            if (HIWORD(wParam)==LBN_SELCHANGE) 
            {
                //
                // Disable the subject and note edit boxes if the cover page does not contain the fields
                //
                if (!EnableCoverDlgItems(pWizardUserMem,hDlg)) 
                {
                    Error(("Failed to enable/disable note and subject field by selected cover page."));
                }
                //
                // Get the full path to the cover page so we can get its information.
                //
                if (GetSelectedCoverPage(pWizardUserMem->pCPInfo,
                         GetDlgItem(hDlg, IDC_CHOOSE_CP_LIST),
                         pWizardUserMem->lpFaxSendWizardData->lpCoverPageInfo->lptstrCoverPageFileName, //full path
                         (pWizardUserMem->lpFaxSendWizardData->lpCoverPageInfo->lptstrCoverPageFileName) ? MAX_PATH : 0,
                         szCoverFileName, //file name
                         ARR_SIZE(szCoverFileName),
                         &pWizardUserMem->lpFaxSendWizardData->lpCoverPageInfo->bServerBased) == CB_ERR)
                {
                    Warning(("GetSelectedCoverPage failed or no *.COV files"));
                }

                InvalidateRect(g_hwndPreview, NULL, TRUE);
            }

            break;

        case IDC_CHOOSE_CP_USER_INFO:
            if (! (hwnd = GetDlgItem(hDlg, IDC_CHOOSE_CP_USER_INFO))) 
            {
                Error(("GetDlgItem failed. ec = 0x%X\n",GetLastError()));
                break;
            }
            DialogBoxParam(
                (HINSTANCE) g_hResource,
                MAKEINTRESOURCE( IDD_WIZARD_USERINFO ),
                hwnd,
                FaxUserInfoProc,
                (LPARAM) pWizardUserMem
                );
            break;


        };


        break;

    case WM_NOTIFY:

        if ((pWizardUserMem->dwFlags & FSW_FORCE_COVERPAGE) && (!pWizardUserMem->bSendCoverPage)) 
        {
            // Here is a good place to add pop-up or something for the user.
            PropSheet_SetWizButtons(GetParent(hDlg),PSWIZB_BACK);
        }

        switch (((NMHDR *) lParam)->code)
        {
        case PSN_WIZNEXT:

            //
            // Remember the cover page settings selected
            //

            pWizardUserMem->noteSubjectFlag = 0;
            pWizardUserMem->cpPaperSize = 0;
            pWizardUserMem->cpOrientation = 0;
            pWizardUserMem->bSendCoverPage  = IsDlgButtonChecked(hDlg, IDC_CHOOSE_CP_CHECK);


            //
            // Get the full path to the cover page so we can get its information.
            //
            if (GetSelectedCoverPage(pWizardUserMem->pCPInfo,
                     GetDlgItem(hDlg, IDC_CHOOSE_CP_LIST),
                     pWizardUserMem->lpFaxSendWizardData->lpCoverPageInfo->lptstrCoverPageFileName, //full path
                     (pWizardUserMem->lpFaxSendWizardData->lpCoverPageInfo->lptstrCoverPageFileName) ? MAX_PATH : 0,
                     szCoverFileName, //file name
                     ARR_SIZE(szCoverFileName),
                     &pWizardUserMem->lpFaxSendWizardData->lpCoverPageInfo->bServerBased) == CB_ERR)
            {
                Warning(("GetSelectedCoverPage failed or no *.COV files"));
            }


            if (pWizardUserMem->bSendCoverPage )
            {
                //  if the cover page file is a link resolve it
                //  check if the cover page file contains note/subject fields
                //
                ValidateSelectedCoverPage(pWizardUserMem);
            }
            else
            {
                 //
                 // pWizardUserMem->coverPage must be set to "" when no cover page is to be sent
                 //
                 _tcscpy(pWizardUserMem->lpFaxSendWizardData->lpCoverPageInfo->lptstrCoverPageFileName,TEXT(""));
            }



            //
            // Collect the current values of other dialog controls
            //

            if (pWizardUserMem->lpFaxSendWizardData->lpCoverPageInfo->lptstrSubject)
                MemFree(pWizardUserMem->lpFaxSendWizardData->lpCoverPageInfo->lptstrSubject);
            if (pWizardUserMem->lpFaxSendWizardData->lpCoverPageInfo->lptstrNote)
                MemFree(pWizardUserMem->lpFaxSendWizardData->lpCoverPageInfo->lptstrNote);
            pWizardUserMem->lpFaxSendWizardData->lpCoverPageInfo->lptstrSubject = GetTextStringValue(GetDlgItem(hDlg, IDC_CHOOSE_CP_SUBJECT));
            pWizardUserMem->lpFaxSendWizardData->lpCoverPageInfo->lptstrNote = GetTextStringValue(GetDlgItem(hDlg, IDC_CHOOSE_CP_NOTE));


            //
            // If the current application is "Send Note" utility,
            // then the subject or note field must not be empty.
            //
            if((pWizardUserMem->dwFlags & FSW_FORCE_COVERPAGE) &&
              ((pWizardUserMem->noteSubjectFlag & COVFP_NOTE) ||
               (pWizardUserMem->noteSubjectFlag & COVFP_SUBJECT)))
            {
                if(!pWizardUserMem->lpFaxSendWizardData->lpCoverPageInfo->lptstrNote &&
                   !pWizardUserMem->lpFaxSendWizardData->lpCoverPageInfo->lptstrSubject)
                {
                    DisplayMessageDialog(hDlg, 0, IDS_WIZARD_TITLE, IDS_NOTE_SUBJECT_EMPTY);

                    if(pWizardUserMem->noteSubjectFlag & COVFP_SUBJECT)
                    {
                        SetFocus(GetDlgItem(hDlg, IDC_CHOOSE_CP_SUBJECT));
                    }
                    else
                    {
                        SetFocus(GetDlgItem(hDlg, IDC_CHOOSE_CP_NOTE));
                    }

                    SetWindowLongPtr(hDlg, DWLP_MSGRESULT, -1);
                    return TRUE;
                }
            }
            break;
        }
        break;

    }

    return TRUE;
}


BOOL
ValidateReceiptInfo(
                HWND    hDlg
                )
{
    TCHAR tcBuffer[MAX_STRING_LEN];
    if (IsDlgButtonChecked(hDlg,IDC_WIZ_FAXOPTS_NONE_RECEIPT))
        goto ok;

    if (!IsDlgButtonChecked(hDlg,IDC_WIZ_FAXOPTS_MSGBOX) &&
        !IsDlgButtonChecked(hDlg,IDC_WIZ_FAXOPTS_EMAIL))
    {
        DisplayMessageDialog(hDlg, 0, IDS_WIZARD_TITLE, IDS_BAD_RECEIPT_FORM );
        return FALSE;
    }

    if (IsDlgButtonChecked(hDlg,IDC_WIZ_FAXOPTS_EMAIL) &&
       (GetDlgItemText(hDlg, IDC_WIZ_FAXOPTS_EMAIL_EDIT, tcBuffer, MAX_STRING_LEN) == 0))
    {
        if(GetLastError() != ERROR_SUCCESS)
        {
            Error(("GetDlgItemText failed. ec = 0x%X\n",GetLastError()));
        }

        DisplayMessageDialog(hDlg, 0, IDS_WIZARD_TITLE, IDS_BAD_RECEIPT_EMAIL_ADD );
        SetFocus(GetDlgItem(hDlg, IDC_WIZ_FAXOPTS_EMAIL_EDIT));
        return FALSE;
    }

ok:
    return TRUE;
}

INT_PTR
FaxOptsWizProc(
    HWND    hDlg,
    UINT    message,
    WPARAM  wParam,
    LPARAM  lParam
    )

/*++

Routine Description:

    Dialog procedure for the wizard page: entering subject and note information

Arguments:

    hDlg - Identifies the wizard page
    message - Specifies the message
    wParam - Specifies additional message-specific information
    lParam - Specifies additional message-specific information

Return Value:

    Depends on the message parameter

--*/

{

    PWIZARDUSERMEM  pWizardUserMem;
    WORD            cmdId;
    BOOL            bEnabled;
    SYSTEMTIME      st;
    HANDLE          hFax = NULL;


    static HWND     hTimeControl;


    if (! (pWizardUserMem = CommonWizardProc(hDlg, message, wParam, lParam, PSWIZB_BACK|PSWIZB_NEXT)))
        return FALSE;


    switch (message)
    {
    case WM_INITDIALOG:

        hTimeControl = GetDlgItem(hDlg,IDC_WIZ_FAXOPTS_SENDTIME);
        Assert(hTimeControl);
        //
        // restore time to send controls
        //
        cmdId = (pWizardUserMem->lpInitialData->dwScheduleAction == JSA_DISCOUNT_PERIOD) ? IDC_WIZ_FAXOPTS_DISCOUNT :
                (pWizardUserMem->lpInitialData->dwScheduleAction == JSA_SPECIFIC_TIME  ) ? IDC_WIZ_FAXOPTS_SPECIFIC :
                IDC_WIZ_FAXOPTS_ASAP;

        if (!CheckDlgButton(hDlg, cmdId, TRUE))
        {
            Warning(("CheckDlgButton failed. ec = 0x%X\n",GetLastError()));
        }
        GetLocalTime(&st);


        EnableWindow(hTimeControl, (cmdId == IDC_WIZ_FAXOPTS_SPECIFIC) );
        if (pWizardUserMem->dwFlags & FSW_USE_SCHEDULE_ACTION) {
            st.wHour = pWizardUserMem->lpInitialData->tmSchedule.wHour;
            st.wMinute = pWizardUserMem->lpInitialData->tmSchedule.wMinute;
        }
        else
        {
            // use local time
        }
        if (!DateTime_SetSystemtime( hTimeControl, GDT_VALID, &st ))
        {
            Warning(("DateTime_SetFormat failed\n"));
        }

        //
        // Init priority
        //

        //
        // Low
        //
        bEnabled = ((pWizardUserMem->dwRights & FAX_ACCESS_SUBMIT) == FAX_ACCESS_SUBMIT);
        EnableWindow(GetDlgItem(hDlg,IDC_WIZ_FAXOPTS_PRIORITY_LOW), bEnabled);

        //
        // Normal
        //
        bEnabled = ((pWizardUserMem->dwRights & FAX_ACCESS_SUBMIT_NORMAL) == FAX_ACCESS_SUBMIT_NORMAL);
        EnableWindow(GetDlgItem(hDlg,IDC_WIZ_FAXOPTS_PRIORITY_NORMAL), bEnabled);
        if (bEnabled)
        {
            // 
            // Normal is our default priority
            //
            CheckDlgButton (hDlg, IDC_WIZ_FAXOPTS_PRIORITY_NORMAL, BST_CHECKED);
        }
        else
        {
            Assert ((pWizardUserMem->dwRights & FAX_ACCESS_SUBMIT) == FAX_ACCESS_SUBMIT);
            //
            // Low is enabled - use it as default
            //
            CheckDlgButton (hDlg, IDC_WIZ_FAXOPTS_PRIORITY_LOW, BST_CHECKED);
        }

        //
        // High
        //
        bEnabled = ((pWizardUserMem->dwRights & FAX_ACCESS_SUBMIT_HIGH) == FAX_ACCESS_SUBMIT_HIGH);
        EnableWindow(GetDlgItem(hDlg,IDC_WIZ_FAXOPTS_PRIORITY_HIGH), bEnabled);

        return TRUE;

    case WM_NOTIFY:

        if (((NMHDR *) lParam)->code == PSN_WIZNEXT)
        {
            //
            //
            // retrieve the sending time
            //
            pWizardUserMem->lpFaxSendWizardData->dwScheduleAction =
                                     IsDlgButtonChecked(hDlg,IDC_WIZ_FAXOPTS_DISCOUNT) ? JSA_DISCOUNT_PERIOD :
                                     IsDlgButtonChecked(hDlg,IDC_WIZ_FAXOPTS_SPECIFIC) ? JSA_SPECIFIC_TIME :
                                     JSA_NOW;

            if (pWizardUserMem->lpFaxSendWizardData->dwScheduleAction == JSA_SPECIFIC_TIME) {
#ifdef DEBUG
                DWORD rVal;
                TCHAR TimeBuffer[128];
#endif
                //
                // get specific time
                //

                if (DateTime_GetSystemtime(hTimeControl,
                                           &pWizardUserMem->lpFaxSendWizardData->tmSchedule) == GDT_ERROR )
                {
                    Error(("DateTime_GetSystemtime failed\n"));
                    return FALSE;
                }



#ifdef DEBUG
                if (!(rVal = GetY2KCompliantDate(
                    LOCALE_USER_DEFAULT,
                    0,
                    &pWizardUserMem->lpFaxSendWizardData->tmSchedule,
                    TimeBuffer,
                    ARR_SIZE(TimeBuffer)
                    )))
                {
                    Error(("GetY2KCompliantDate: failed. ec = 0X%x\n",GetLastError()));
                    return FALSE;
                }


                TimeBuffer[rVal - 1] = TEXT(' ');

                if(!FaxTimeFormat(
                                    LOCALE_USER_DEFAULT,
                                    0,
                                    &pWizardUserMem->lpFaxSendWizardData->tmSchedule,
                                    NULL,
                                    &TimeBuffer[rVal],
                                    ARR_SIZE(TimeBuffer) - rVal
                                  ))
                {
                    Error(("FaxTimeFormat: failed. ec = 0X%x\n",GetLastError()));
                    return FALSE;
                }

                Verbose(("faxui - Fax Send time %ws", TimeBuffer));
#endif
            }

            //
            // save priority
            //
            pWizardUserMem->lpFaxSendWizardData->Priority =
                IsDlgButtonChecked(hDlg,IDC_WIZ_FAXOPTS_PRIORITY_HIGH)   ? FAX_PRIORITY_TYPE_HIGH   :
                IsDlgButtonChecked(hDlg,IDC_WIZ_FAXOPTS_PRIORITY_NORMAL) ? FAX_PRIORITY_TYPE_NORMAL :
                FAX_PRIORITY_TYPE_LOW;

            if(0 == pWizardUserMem->dwSupportedReceipts)
            {
                //
                // skip notifications page
                //
                SetWindowLongPtr(hDlg, 
                                 DWLP_MSGRESULT, 
                                 (pWizardUserMem->dwComCtrlVer >= IE50_COMCTRL_VER) ? IDD_WIZARD_CONGRATS : 
                                                                                      IDD_WIZARD_CONGRATS_NOWIZARD97);                                    
                return TRUE;
            }
        }

        break;

    case WM_COMMAND:
        switch (cmdId = GET_WM_COMMAND_ID(wParam, lParam)) {

        case IDC_WIZ_FAXOPTS_SPECIFIC:
        case IDC_WIZ_FAXOPTS_DISCOUNT:
        case IDC_WIZ_FAXOPTS_ASAP:
            EnableWindow(hTimeControl, (cmdId == IDC_WIZ_FAXOPTS_SPECIFIC) );
            break;
        };

        break;
    default:
        return FALSE;
    } ;
    return TRUE;
}

void
CalcReceiptButtonsState(
    HWND            hDlg,
    PWIZARDUSERMEM  pWizardUserMem
)
/*++

Routine Description:

    Calculates receipt page button state

Arguments:

    hDlg           - Identifies the wizard page
    pWizardUserMem - pointer to WIZARDUSERMEM structure

Return Value:

    none

--*/

{
    BOOL     bMailReceipt;

    Assert(hDlg);
    Assert(pWizardUserMem);

    if((IsDlgButtonChecked(hDlg,IDC_WIZ_FAXOPTS_NONE_RECEIPT) != BST_CHECKED) &&
       (SizeOfRecipientList(pWizardUserMem) > 1))
    {
        //
        // wish receipt, multiple recipients
        //
        EnableWindow(GetDlgItem(hDlg, IDC_WIZ_FAXOPTS_GRP_PARENT),  TRUE);
    }
    else
    {
        CheckDlgButton(hDlg,IDC_WIZ_FAXOPTS_GRP_PARENT, BST_UNCHECKED);
        EnableWindow(GetDlgItem(hDlg, IDC_WIZ_FAXOPTS_GRP_PARENT),  FALSE);
    }

    bMailReceipt = IsDlgButtonChecked(hDlg,IDC_WIZ_FAXOPTS_EMAIL) == BST_CHECKED;

    EnableWindow(GetDlgItem(hDlg, IDC_WIZ_FAXOPTS_ADDRBOOK),    bMailReceipt);
    EnableWindow(GetDlgItem(hDlg, IDC_WIZ_FAXOPTS_EMAIL_EDIT),  bMailReceipt);

    if (bMailReceipt)
    {
        //
        // Receipt by e-mail
        //
        if (! ((SizeOfRecipientList(pWizardUserMem) > 1)       &&
               (pWizardUserMem->dwFlags & FSW_FORCE_COVERPAGE) &&
               IsDlgButtonChecked(hDlg,IDC_WIZ_FAXOPTS_GRP_PARENT)
              )
           )
        {
            //
            // NOT the case of (multiple recipients AND no attachment AND single receipt)
            //
            EnableWindow(GetDlgItem(hDlg, IDC_WIZ_FAXOPTS_ATTACH_FAX),  TRUE);
            ShowWindow (GetDlgItem (hDlg, IDC_STATIC_ATTACH_NOTE), SW_HIDE);
            ShowWindow (GetDlgItem (hDlg, IDC_WZRD_NOTE_ICON), SW_HIDE);
        }
        else
        {
            //
            // The case of (multiple recipients AND no attachment AND single receipt)
            //
            CheckDlgButton(hDlg,IDC_WIZ_FAXOPTS_ATTACH_FAX, BST_UNCHECKED);
            EnableWindow(GetDlgItem(hDlg, IDC_WIZ_FAXOPTS_ATTACH_FAX),  FALSE);
            ShowWindow (GetDlgItem (hDlg, IDC_STATIC_ATTACH_NOTE), SW_SHOW);
            ShowWindow (GetDlgItem (hDlg, IDC_WZRD_NOTE_ICON), SW_SHOW);
        }
    }
    else
    {
        //
        // No receipt by e-mail
        //
        ShowWindow (GetDlgItem (hDlg, IDC_STATIC_ATTACH_NOTE), SW_HIDE);
        ShowWindow (GetDlgItem (hDlg, IDC_WZRD_NOTE_ICON), SW_HIDE);
        EnableWindow(GetDlgItem(hDlg, IDC_WIZ_FAXOPTS_ATTACH_FAX), FALSE);
    }
}


INT_PTR
FaxReceiptWizProc(
    HWND    hDlg,
    UINT    message,
    WPARAM  wParam,
    LPARAM  lParam
    )

/*++

Routine Description:

    Dialog procedure for the wizard page: receipt information

Arguments:

    hDlg - Identifies the wizard page
    message - Specifies the message
    wParam - Specifies additional message-specific information
    lParam - Specifies additional message-specific information

Return Value:

    Depends on the message parameter

--*/

{

    PWIZARDUSERMEM  pWizardUserMem;
    WORD            cmdId;
    LPTSTR          lptstrEmailAddress;
    DWORD           dwReceiptDeliveryType;

    if (! (pWizardUserMem = CommonWizardProc(hDlg, message, wParam, lParam, PSWIZB_BACK|PSWIZB_NEXT)))
    {
        return FALSE;
    }

    switch (message)
    {

    case WM_INITDIALOG:

        dwReceiptDeliveryType = pWizardUserMem->lpInitialData->dwReceiptDeliveryType;
        //
        // data is initializated without validation of correctness
        // it is up to caller to check that the receipt data is correct and consistent
        //

        //
        // no receipt
        //
        if (!CheckDlgButton(hDlg,IDC_WIZ_FAXOPTS_NONE_RECEIPT,
                       (dwReceiptDeliveryType == DRT_NONE) ? BST_CHECKED : BST_UNCHECKED))
        {
            Warning(("CheckDlgButton failed. ec = 0x%X\n",GetLastError()));
        }
        //
        // single receipt
        //
        if((dwReceiptDeliveryType != DRT_NONE) && (SizeOfRecipientList(pWizardUserMem) > 1))
        {
            if (!CheckDlgButton(hDlg,IDC_WIZ_FAXOPTS_GRP_PARENT,
                           (dwReceiptDeliveryType & DRT_GRP_PARENT) ? BST_CHECKED : BST_UNCHECKED))
            {
                Warning(("CheckDlgButton failed. ec = 0x%X\n",GetLastError()));
            }
        }
        else
        {
            EnableWindow(GetDlgItem(hDlg, IDC_WIZ_FAXOPTS_GRP_PARENT), FALSE);
        }

        //
        // message box receipt
        //
        if(pWizardUserMem->dwSupportedReceipts & DRT_MSGBOX)
        {
            if (!CheckDlgButton(hDlg,IDC_WIZ_FAXOPTS_MSGBOX,
                           (dwReceiptDeliveryType & DRT_MSGBOX) ? BST_CHECKED : BST_UNCHECKED))
            {
                Warning(("CheckDlgButton failed. ec = 0x%X\n",GetLastError()));
            }
        }
        else
        {
            EnableWindow(GetDlgItem(hDlg, IDC_WIZ_FAXOPTS_MSGBOX), FALSE);

            if(dwReceiptDeliveryType & DRT_MSGBOX)
            {
                //
                // If the previous choice was inbox
                // but by now this option is disabled
                // check no receipt option
                //
                CheckDlgButton(hDlg,IDC_WIZ_FAXOPTS_NONE_RECEIPT, BST_CHECKED);
            }
        }

        //
        // email receipt
        //
        if(pWizardUserMem->dwSupportedReceipts & DRT_EMAIL)
        {
            if (!CheckDlgButton(hDlg,IDC_WIZ_FAXOPTS_EMAIL,
                           (dwReceiptDeliveryType & DRT_EMAIL) ? BST_CHECKED : BST_UNCHECKED))
            {
                Warning(("CheckDlgButton failed. ec = 0x%X\n",GetLastError()));
            }
        }
        else
        {
            EnableWindow(GetDlgItem(hDlg, IDC_WIZ_FAXOPTS_EMAIL), FALSE);

            if(dwReceiptDeliveryType & DRT_EMAIL)
            {
                //
                // If the previous choice was email
                // but by now this option is disabled
                // check no receipt option
                //
                CheckDlgButton(hDlg,IDC_WIZ_FAXOPTS_NONE_RECEIPT, BST_CHECKED);
            }
        }

        if (pWizardUserMem->lpInitialData->szReceiptDeliveryAddress && (dwReceiptDeliveryType & DRT_EMAIL))
        {
            if (!SetDlgItemText(hDlg, IDC_WIZ_FAXOPTS_EMAIL_EDIT,
                           pWizardUserMem->lpInitialData->szReceiptDeliveryAddress))
            {
                Warning(("SetDlgItemText failed. ec = 0x%X\n",GetLastError()));
            }
        }

        if (dwReceiptDeliveryType & DRT_ATTACH_FAX)
        {
            //
            // Initial data has 'Attach fax' option set - check the checkbox
            //
            if (!CheckDlgButton(hDlg, IDC_WIZ_FAXOPTS_ATTACH_FAX, BST_CHECKED))
            {
                Warning(("CheckDlgButton failed. ec = 0x%X\n",GetLastError()));
            }
        }

        CalcReceiptButtonsState(hDlg, pWizardUserMem);

        return TRUE;

    case WM_NOTIFY:

        if (((NMHDR *) lParam)->code == PSN_WIZNEXT)
        {
            if (! ValidateReceiptInfo(hDlg))
            {
                //
                // Validate the list of recipients and prevent the user
                // from advancing to the next page if there is a problem
                //
                SetWindowLongPtr(hDlg, DWLP_MSGRESULT, -1);
                return TRUE;
            }

            pWizardUserMem->lpFaxSendWizardData->dwReceiptDeliveryType = DRT_NONE;

            if (!IsDlgButtonChecked(hDlg,IDC_WIZ_FAXOPTS_NONE_RECEIPT))
            {
                TCHAR tcBuffer[MAX_STRING_LEN];
                if (IsDlgButtonChecked(hDlg,IDC_WIZ_FAXOPTS_GRP_PARENT))
                {
                    pWizardUserMem->lpFaxSendWizardData->dwReceiptDeliveryType |= DRT_GRP_PARENT;
                }
                if (IsDlgButtonChecked(hDlg,IDC_WIZ_FAXOPTS_MSGBOX))
                {
                    DWORD dwBufSize = ARR_SIZE (tcBuffer);
                    pWizardUserMem->lpFaxSendWizardData->dwReceiptDeliveryType |= DRT_MSGBOX;
                    if (!GetComputerName (tcBuffer, &dwBufSize))
                    {
                        Error(("GetComputerName failed (ec=%ld)\n", GetLastError()));
                        return FALSE;
                    }
                    if (!(pWizardUserMem->lpFaxSendWizardData->szReceiptDeliveryAddress = StringDup(tcBuffer)))
                    {
                        Error(("Allocation of szReceiptDeliveryProfile failed!!!!\n"));
                        return FALSE;
                    }
                }
                else if (IsDlgButtonChecked(hDlg,IDC_WIZ_FAXOPTS_EMAIL))
                {
                    pWizardUserMem->lpFaxSendWizardData->dwReceiptDeliveryType |= DRT_EMAIL;
                    GetDlgItemText(hDlg, IDC_WIZ_FAXOPTS_EMAIL_EDIT, tcBuffer, MAX_STRING_LEN);
                    if (!(pWizardUserMem->lpFaxSendWizardData->szReceiptDeliveryAddress = StringDup(tcBuffer)))
                    {
                        Error(("Allocation of szReceiptDeliveryProfile failed!!!!\n"));
                        return FALSE;
                    }
                    if (IsDlgButtonChecked(hDlg,IDC_WIZ_FAXOPTS_ATTACH_FAX))
                    {
                        pWizardUserMem->lpFaxSendWizardData->dwReceiptDeliveryType |= DRT_ATTACH_FAX;
                    }
                }
            }
        }

        if (((NMHDR *) lParam)->code == PSN_SETACTIVE)
        {
            CalcReceiptButtonsState(hDlg, pWizardUserMem);
        }
        break;

    case WM_COMMAND:
        switch (cmdId = GET_WM_COMMAND_ID(wParam, lParam))
        {

        case IDC_WIZ_FAXOPTS_NONE_RECEIPT:
        case IDC_WIZ_FAXOPTS_EMAIL:
        case IDC_WIZ_FAXOPTS_MSGBOX:
        case IDC_WIZ_FAXOPTS_GRP_PARENT:

            CalcReceiptButtonsState(hDlg, pWizardUserMem);

            break;

        case IDC_WIZ_FAXOPTS_ADDRBOOK:
            if (lptstrEmailAddress = GetEMailAddress(hDlg,pWizardUserMem))
            {
                SetDlgItemText(hDlg, IDC_WIZ_FAXOPTS_EMAIL_EDIT, lptstrEmailAddress);
                MemFree(lptstrEmailAddress);
            }
            break;
        };

        break;

    default:
        return FALSE;
    } ;
    return TRUE;
}


#define FillEditCtrlWithInitialUserInfo(nIDDlgItem,field)   \
    if (pWizardUserMem->lpInitialData->lpSenderInfo->field && \
        !IsEmptyString(pWizardUserMem->lpInitialData->lpSenderInfo->field)) { \
        SetDlgItemText(hDlg, nIDDlgItem, pWizardUserMem->lpInitialData->lpSenderInfo->field); \
    }

#define FillEditCtrlWithSenderWizardUserInfo(nIDDlgItem,field)  \
    if (pWizardUserMem->lpFaxSendWizardData->lpSenderInfo->field && \
        !IsEmptyString(pWizardUserMem->lpFaxSendWizardData->lpSenderInfo->field)) { \
        SetDlgItemText(hDlg, nIDDlgItem, pWizardUserMem->lpFaxSendWizardData->lpSenderInfo->field); \
    }

#define FillUserInfoFromEditCrtl(nIDDlgItem,field)                                          \
            tcBuffer[0] = 0;                                                                \
            GetDlgItemText(hDlg, nIDDlgItem, tcBuffer, MAX_STRING_LEN);                     \
            pWizardUserMem->lpFaxSendWizardData->lpSenderInfo->field = StringDup(tcBuffer); \
            if (!pWizardUserMem->lpFaxSendWizardData->lpSenderInfo->field)                  \
            {                                                                               \
                Error(("Memory allocation failed"));                                        \
            }


INT_PTR
CALLBACK
FaxUserInfoProc(
    HWND    hDlg,
    UINT    message,
    WPARAM  wParam,
    LPARAM  lParam
    )

/*++

Routine Description:

    Dialog procedure for the info page: sender information

Arguments:

    hDlg - Identifies the wizard page
    message - Specifies the message
    wParam - Specifies additional message-specific information
    lParam - Specifies additional message-specific information

Return Value:

    Depends on the message parameter

--*/

{
    //
    // Maximum length for various text fields
    //

    PWIZARDUSERMEM        pWizardUserMem;
    FAX_PERSONAL_PROFILE* pSenderInfo;
    TCHAR                 tcBuffer[MAX_STRING_LEN];

    static INT  textLimits[] = {
        IDC_WIZ_USERINFO_FULLNAME,      MAX_USERINFO_FULLNAME,
        IDC_WIZ_USERINFO_FAX_NUMBER,    MAX_USERINFO_FAX_NUMBER,
        IDC_WIZ_USERINFO_COMPANY,       MAX_USERINFO_COMPANY,
        IDC_WIZ_USERINFO_ADDRESS,       MAX_USERINFO_ADDRESS,
        IDC_WIZ_USERINFO_TITLE,         MAX_USERINFO_TITLE,
        IDC_WIZ_USERINFO_DEPT,          MAX_USERINFO_DEPT,
        IDC_WIZ_USERINFO_OFFICE,        MAX_USERINFO_OFFICE,
        IDC_WIZ_USERINFO_HOME_PHONE,    MAX_USERINFO_HOME_PHONE,
        IDC_WIZ_USERINFO_WORK_PHONE,    MAX_USERINFO_WORK_PHONE,
        IDC_WIZ_USERINFO_BILLING_CODE,  MAX_USERINFO_BILLING_CODE,
        IDC_WIZ_USERINFO_MAILBOX,       MAX_USERINFO_MAILBOX,
        0
    };


    switch (message) {

    case WM_INITDIALOG:

        pWizardUserMem = (PWIZARDUSERMEM) lParam;
        Assert(pWizardUserMem);
        SetWindowLongPtr(hDlg, DWLP_USER, lParam);

        LimitTextFields(hDlg, textLimits);

        Assert(pWizardUserMem->lpInitialData);
        Assert(pWizardUserMem->lpInitialData->lpSenderInfo);
        Assert(pWizardUserMem->lpFaxSendWizardData->lpSenderInfo);

        // init Sender Name
        if (pWizardUserMem->lpFaxSendWizardData->lpSenderInfo->lptstrName)
        {
            FillEditCtrlWithSenderWizardUserInfo(IDC_WIZ_USERINFO_FULLNAME, lptstrName);
        }
        else
        {
            FillEditCtrlWithInitialUserInfo(IDC_WIZ_USERINFO_FULLNAME,  lptstrName);
        }

        //
        // init Sender Fax Number
        //
        SetLTREditDirection(hDlg, IDC_WIZ_USERINFO_FAX_NUMBER);

        if (pWizardUserMem->lpFaxSendWizardData->lpSenderInfo->lptstrFaxNumber)
        {
            FillEditCtrlWithSenderWizardUserInfo(IDC_WIZ_USERINFO_FAX_NUMBER, lptstrFaxNumber);
        }
        else
        {
            FillEditCtrlWithInitialUserInfo(IDC_WIZ_USERINFO_FAX_NUMBER,lptstrFaxNumber);
        }

        // init Sender Company
        if (pWizardUserMem->lpFaxSendWizardData->lpSenderInfo->lptstrCompany)
        {
            FillEditCtrlWithSenderWizardUserInfo(IDC_WIZ_USERINFO_COMPANY,  lptstrCompany);
        }
        else
        {
            FillEditCtrlWithInitialUserInfo(IDC_WIZ_USERINFO_COMPANY,lptstrCompany);
        }

        // init Sender Address
        if (pWizardUserMem->lpFaxSendWizardData->lpSenderInfo->lptstrStreetAddress)
        {
            FillEditCtrlWithSenderWizardUserInfo(IDC_WIZ_USERINFO_ADDRESS,  lptstrStreetAddress);
        }
        else
        {
            FillEditCtrlWithInitialUserInfo(IDC_WIZ_USERINFO_ADDRESS,lptstrStreetAddress);
        }

        // init Sender Title
        if (pWizardUserMem->lpFaxSendWizardData->lpSenderInfo->lptstrTitle)
        {
            FillEditCtrlWithSenderWizardUserInfo(IDC_WIZ_USERINFO_TITLE,lptstrTitle);
        }
        else
        {
            FillEditCtrlWithInitialUserInfo(IDC_WIZ_USERINFO_TITLE, lptstrTitle);
        }

        // init Sender Department
        if (pWizardUserMem->lpFaxSendWizardData->lpSenderInfo->lptstrDepartment)
        {
            FillEditCtrlWithSenderWizardUserInfo(IDC_WIZ_USERINFO_DEPT,lptstrDepartment);
        }
        else
        {
            FillEditCtrlWithInitialUserInfo(IDC_WIZ_USERINFO_DEPT,lptstrDepartment);
        }

        // init Sender Office Location
        if (pWizardUserMem->lpFaxSendWizardData->lpSenderInfo->lptstrOfficeLocation)
        {
            FillEditCtrlWithSenderWizardUserInfo(IDC_WIZ_USERINFO_OFFICE,lptstrOfficeLocation);
        }
        else
        {
            FillEditCtrlWithInitialUserInfo(IDC_WIZ_USERINFO_OFFICE,lptstrOfficeLocation);
        }

        // init Sender Home Phone
        SetLTREditDirection(hDlg, IDC_WIZ_USERINFO_HOME_PHONE);
        if (pWizardUserMem->lpFaxSendWizardData->lpSenderInfo->lptstrHomePhone)
        {
            FillEditCtrlWithSenderWizardUserInfo(IDC_WIZ_USERINFO_HOME_PHONE,lptstrHomePhone);
        }
        else
        {
            FillEditCtrlWithInitialUserInfo(IDC_WIZ_USERINFO_HOME_PHONE,lptstrHomePhone);
        }

        // init Sender Office Phone
        SetLTREditDirection(hDlg, IDC_WIZ_USERINFO_WORK_PHONE);
        if (pWizardUserMem->lpFaxSendWizardData->lpSenderInfo->lptstrOfficePhone)
        {
            FillEditCtrlWithSenderWizardUserInfo(IDC_WIZ_USERINFO_WORK_PHONE,lptstrOfficePhone);
        }
        else
        {
            FillEditCtrlWithInitialUserInfo(IDC_WIZ_USERINFO_WORK_PHONE,lptstrOfficePhone);
        }

        // init Sender Billing Code
        if (pWizardUserMem->lpFaxSendWizardData->lpSenderInfo->lptstrBillingCode)
        {
            FillEditCtrlWithSenderWizardUserInfo(IDC_WIZ_USERINFO_BILLING_CODE,lptstrBillingCode);
        }
        else
        {
            FillEditCtrlWithInitialUserInfo(IDC_WIZ_USERINFO_BILLING_CODE,lptstrBillingCode);
        }

        // init Sender Internet Mail
        SetLTREditDirection(hDlg, IDC_WIZ_USERINFO_MAILBOX);
        if (pWizardUserMem->lpFaxSendWizardData->lpSenderInfo->lptstrEmail)
        {
            FillEditCtrlWithSenderWizardUserInfo(IDC_WIZ_USERINFO_MAILBOX,lptstrEmail);
        }
        else
        {
            FillEditCtrlWithInitialUserInfo(IDC_WIZ_USERINFO_MAILBOX,lptstrEmail);
        }

        if (!CheckDlgButton(hDlg, IDC_USER_INFO_JUST_THIS_TIME, !pWizardUserMem->lpFaxSendWizardData->bSaveSenderInfo))
        {
            Warning(("CheckDlgButton failed. ec = 0x%X\n",GetLastError()));
        }

        return TRUE;

    case WM_COMMAND:
        switch(LOWORD( wParam ))
        {
            case IDOK:
                pWizardUserMem = (PWIZARDUSERMEM) GetWindowLongPtr(hDlg, DWLP_USER);
                Assert(pWizardUserMem);
                pSenderInfo = pWizardUserMem->lpFaxSendWizardData->lpSenderInfo;

                //
                // free sender fields except address
                //
                MemFree(pSenderInfo->lptstrName);
                pSenderInfo->lptstrName = NULL;
                MemFree(pSenderInfo->lptstrFaxNumber);
                pSenderInfo->lptstrFaxNumber = NULL;
                MemFree(pSenderInfo->lptstrCompany);
                pSenderInfo->lptstrCompany = NULL;
                MemFree(pSenderInfo->lptstrTitle);
                pSenderInfo->lptstrTitle = NULL;
                MemFree(pSenderInfo->lptstrDepartment);
                pSenderInfo->lptstrDepartment = NULL;
                MemFree(pSenderInfo->lptstrOfficeLocation);
                pSenderInfo->lptstrOfficeLocation = NULL;
                MemFree(pSenderInfo->lptstrHomePhone);
                pSenderInfo->lptstrHomePhone = NULL;
                MemFree(pSenderInfo->lptstrOfficePhone);
                pSenderInfo->lptstrOfficePhone = NULL;
                MemFree(pSenderInfo->lptstrEmail);
                pSenderInfo->lptstrEmail = NULL;
                MemFree(pSenderInfo->lptstrBillingCode);
                pSenderInfo->lptstrBillingCode = NULL;
                MemFree(pSenderInfo->lptstrStreetAddress);
                pSenderInfo->lptstrStreetAddress = NULL;

                FillUserInfoFromEditCrtl(IDC_WIZ_USERINFO_FULLNAME,     lptstrName);
                FillUserInfoFromEditCrtl(IDC_WIZ_USERINFO_FAX_NUMBER,   lptstrFaxNumber);
                FillUserInfoFromEditCrtl(IDC_WIZ_USERINFO_COMPANY,      lptstrCompany);
                FillUserInfoFromEditCrtl(IDC_WIZ_USERINFO_TITLE,        lptstrTitle);
                FillUserInfoFromEditCrtl(IDC_WIZ_USERINFO_DEPT,         lptstrDepartment);
                FillUserInfoFromEditCrtl(IDC_WIZ_USERINFO_OFFICE,       lptstrOfficeLocation);
                FillUserInfoFromEditCrtl(IDC_WIZ_USERINFO_HOME_PHONE,   lptstrHomePhone);
                FillUserInfoFromEditCrtl(IDC_WIZ_USERINFO_WORK_PHONE,   lptstrOfficePhone);
                FillUserInfoFromEditCrtl(IDC_WIZ_USERINFO_BILLING_CODE, lptstrBillingCode);
                FillUserInfoFromEditCrtl(IDC_WIZ_USERINFO_MAILBOX,      lptstrEmail);
                FillUserInfoFromEditCrtl(IDC_WIZ_USERINFO_ADDRESS,      lptstrStreetAddress);

                pWizardUserMem->lpFaxSendWizardData->bSaveSenderInfo =
                    IsDlgButtonChecked(hDlg, IDC_USER_INFO_JUST_THIS_TIME) != BST_CHECKED;

                EndDialog(hDlg,1);
                return TRUE;

            case IDCANCEL:

                EndDialog( hDlg,0 );
                return TRUE;

        }
        break;

    case WM_HELP:
        WinHelpContextPopup(((LPHELPINFO)lParam)->dwContextId, hDlg);
        return TRUE;
    case WM_CONTEXTMENU:
        WinHelpContextPopup(GetWindowContextHelpId((HWND)wParam), hDlg);
        return TRUE;

    default:
        return FALSE;
    } ;
    return TRUE;
}




LPTSTR
FormatTime(
    WORD Hour,
    WORD Minute,
    LPTSTR Buffer,
    LPDWORD lpdwBufferSize)
{
    SYSTEMTIME SystemTime;

    ZeroMemory(&SystemTime,sizeof(SystemTime));
    SystemTime.wHour = Hour;
    SystemTime.wMinute = Minute;
    if (!FaxTimeFormat(LOCALE_USER_DEFAULT,
                  TIME_NOSECONDS,
                  &SystemTime,
                  NULL,
                  Buffer,
                  *lpdwBufferSize
                  ))
    {
        Error(("FaxTimeFormat failed. ec = 0x%X\n",GetLastError()));

        //
        //  Indicate about the error
        //
        *lpdwBufferSize = 0;
        Buffer[0] = '\0';

    }

    return Buffer;
}


INT_PTR
FinishWizProc(
    HWND    hDlg,
    UINT    message,
    WPARAM  wParam,
    LPARAM  lParam
    )

/*++

Routine Description:

    Dialog procedure for the last wizard page:
    give user a chance to confirm or cancel the dialog.

Arguments:

    hDlg - Identifies the wizard page
    message - Specifies the message
    wParam - Specifies additional message-specific information
    lParam - Specifies additional message-specific information

Return Value:

    Depends on the message parameter

--*/

{

    PWIZARDUSERMEM    pWizardUserMem;
    HWND        hPreview;
    TCHAR       TmpTimeBuffer[64];
    TCHAR       TimeBuffer[64] = {0};
    TCHAR       SendTimeBuffer[64];
    TCHAR       NoneBuffer[64];
    TCHAR       CoverpageBuffer[MAX_PATH+1] = {0};
    LPTSTR      Coverpage=NULL;
    DWORD       dwBufferSize = 0;

    if (! (pWizardUserMem = CommonWizardProc(hDlg, message, wParam, lParam, PSWIZB_BACK|PSWIZB_FINISH)) )
        return FALSE;

    switch (message)
    {
        case WM_INITDIALOG:
            //
            // Init recipient list
            //
            if (!InitRecipientListView(GetDlgItem(hDlg, IDC_WIZ_CONGRATS_RECIPIENT_LIST)))
            {
                Warning(("InitRecipientListView failed\n"));
            }

            //
            // Apply the print preview option if we where requested and default to show preview
            //
            hPreview = GetDlgItem(hDlg, IDC_WIZ_CONGRATS_PREVIEW_FAX);
            if (pWizardUserMem->dwFlags & FSW_PRINT_PREVIEW_OPTION)
            {
                Button_Enable(hPreview, TRUE);
                ShowWindow(hPreview, SW_SHOW);
            }
            else
            {
                Button_Enable(hPreview, FALSE);
                ShowWindow(hPreview, SW_HIDE);
            }
            return TRUE;
        case WM_COMMAND:
            switch(LOWORD( wParam ))
            {
                case IDC_WIZ_CONGRATS_PREVIEW_FAX:
                    {
                        if (pWizardUserMem->hFaxPreviewProcess)
                        {
                            //
                            // Preview is in progress we can not continue.
                            //
                            ErrorMessageBox(hDlg, IDS_PLEASE_CLOSE_FAX_PREVIEW, MB_ICONINFORMATION);
                        }
                        else
                        {
                            DisplayFaxPreview(
                                hDlg,
                                pWizardUserMem,
                                pWizardUserMem->lpInitialData->lptstrPreviewFile
                                );
                        }

                        return TRUE;
                    }
                    break;
                default:
                    break;

            }
            break;

        case WM_NOTIFY:
            switch (((NMHDR *) lParam)->code)
            {
            case PSN_WIZBACK :
                if(0 == pWizardUserMem->dwSupportedReceipts)
                {
                    //
                    // skip notifications page
                    //
                    SetWindowLongPtr(hDlg, 
                                     DWLP_MSGRESULT, 
                                     (pWizardUserMem->dwComCtrlVer >= IE50_COMCTRL_VER) ? IDD_WIZARD_FAXOPTS : 
                                                                                          IDD_WIZARD_FAXOPTS_NOWIZARD97);
                    return TRUE;
                }
                break;
            case PSN_WIZFINISH:
                if (pWizardUserMem->hFaxPreviewProcess)
                {
                    //
                    // Preview is in progress we can not continue.
                    //
                    ErrorMessageBox(hDlg, IDS_PLEASE_CLOSE_FAX_PREVIEW, MB_ICONINFORMATION);

                    //
                    // prevent the propsheet from closing
                    //
                    SetWindowLong(hDlg, DWLP_MSGRESULT, -1);
                    return TRUE;

                }
                else
                {
                    return FALSE; // allow the propsheet to close
                }

            case PSN_SETACTIVE:
                ZeroMemory(NoneBuffer,sizeof(NoneBuffer));
                if (!LoadString(g_hResource,
                                IDS_NONE,
                                NoneBuffer,
                                ARR_SIZE(NoneBuffer)))
                {
                    Error(("LoadString failed. ec = 0x%X\n",GetLastError()));
                    Assert(FALSE);
                }
                //
                // large title font on last page
                //
                SetWindowFont(GetDlgItem(hDlg,IDC_STATIC_WIZ_CONGRATS_READY), pWizardUserMem->hLargeFont, TRUE);

                //
                // set the sender name if it exists
                //
                if ( pWizardUserMem->lpFaxSendWizardData->lpSenderInfo->lptstrName )
                {
                        SetDlgItemText(hDlg, IDC_WIZ_CONGRATS_FROM, pWizardUserMem->lpFaxSendWizardData->lpSenderInfo->lptstrName );
                        EnableWindow(GetDlgItem(hDlg,IDC_STATIC_WIZ_CONGRATS_FROM),TRUE);
                        EnableWindow(GetDlgItem(hDlg,IDC_WIZ_CONGRATS_FROM),TRUE);
                } else {
                    if (NoneBuffer[0] != NUL)
                    {
                        SetDlgItemText(hDlg, IDC_WIZ_CONGRATS_FROM, NoneBuffer );
                        EnableWindow(GetDlgItem(hDlg,IDC_STATIC_WIZ_CONGRATS_FROM),FALSE);
                        EnableWindow(GetDlgItem(hDlg,IDC_WIZ_CONGRATS_FROM),FALSE);
                    }
                }

                //
                // set the recipient name
                //
                if (!ListView_DeleteAllItems(GetDlgItem(hDlg, IDC_WIZ_CONGRATS_RECIPIENT_LIST)))
                {
                    Warning(("ListView_DeleteAllItems failed\n"));
                }

                if (!FillRecipientListView(pWizardUserMem,GetDlgItem(hDlg, IDC_WIZ_CONGRATS_RECIPIENT_LIST)))
                {
                    Warning(("FillRecipientListView failed\n"));
                }


                //
                // when to send
                //
                switch (pWizardUserMem->lpFaxSendWizardData->dwScheduleAction)
                {
                case JSA_SPECIFIC_TIME:
                    if (!LoadString(g_hResource,
                                    IDS_SEND_SPECIFIC,
                                    TmpTimeBuffer,
                                    ARR_SIZE(TmpTimeBuffer)))
                    {
                        Warning(("LoadString failed. ec = 0x%X\n",GetLastError()));
                        Assert(FALSE);
                    }

                    dwBufferSize = ARR_SIZE(TimeBuffer);

                    wsprintf(SendTimeBuffer,
                             TmpTimeBuffer,
                             FormatTime(pWizardUserMem->lpFaxSendWizardData->tmSchedule.wHour,
                                        pWizardUserMem->lpFaxSendWizardData->tmSchedule.wMinute,
                                        TimeBuffer,
                                        &dwBufferSize));
                      break;
                case JSA_DISCOUNT_PERIOD:
                    if (!LoadString(g_hResource,
                                    IDS_SEND_DISCOUNT,
                                    SendTimeBuffer,
                                    ARR_SIZE(SendTimeBuffer)))
                    {
                        Warning(("LoadString failed. ec = 0x%X\n",GetLastError()));
                        Assert(FALSE);
                    }

                    break;
                case JSA_NOW:
                    if (!LoadString(g_hResource,
                                    IDS_SEND_ASAP,
                                    SendTimeBuffer,
                                    ARR_SIZE(SendTimeBuffer)))
                    {
                        Warning(("LoadString failed. ec = 0x%X\n",GetLastError()));
                        Assert(FALSE);
                    }

                };

                SetDlgItemText(hDlg, IDC_WIZ_CONGRATS_TIME, SendTimeBuffer );

                //
                // Coverpage
                //
                if (pWizardUserMem->bSendCoverPage ) {
                    EnableWindow(GetDlgItem(hDlg,IDC_STATIC_WIZ_CONGRATS_COVERPG),TRUE);
                    EnableWindow(GetDlgItem(hDlg,IDC_STATIC_WIZ_CONGRATS_SUBJECT),TRUE);
                    EnableWindow(GetDlgItem(hDlg,IDC_WIZ_CONGRATS_COVERPG),TRUE);
                    EnableWindow(GetDlgItem(hDlg,IDC_WIZ_CONGRATS_SUBJECT),TRUE);

                    //
                    // format the coverpage for display to the user
                    //

                    // drop path
                    Coverpage = _tcsrchr(pWizardUserMem->lpFaxSendWizardData->lpCoverPageInfo->lptstrCoverPageFileName, FAX_PATH_SEPARATOR_CHR);
                    if (!Coverpage) {
                        Coverpage = pWizardUserMem->lpFaxSendWizardData->lpCoverPageInfo->lptstrCoverPageFileName;
                    } else {
                        Coverpage++;
                    }
                    _tcsncpy(CoverpageBuffer,Coverpage, MAX_PATH);

                    // crop file extension
                    Coverpage = _tcschr(CoverpageBuffer,TEXT(FILENAME_EXT));

                    if (Coverpage && *Coverpage) {
                        *Coverpage = (TCHAR) NUL;
                    }

                    SetDlgItemText(hDlg, IDC_WIZ_CONGRATS_COVERPG, CoverpageBuffer );
                    if (pWizardUserMem->lpFaxSendWizardData->lpCoverPageInfo->lptstrSubject) {
                        if (!SetDlgItemText(hDlg, IDC_WIZ_CONGRATS_SUBJECT, pWizardUserMem->lpFaxSendWizardData->lpCoverPageInfo->lptstrSubject ))
                        {
                            Warning(("SetDlgItemText failed. ec = 0x%X\n",GetLastError()));
                        }
                    } else {
                        if (NoneBuffer[0] != NUL)
                        {

                            EnableWindow(GetDlgItem(hDlg,IDC_WIZ_CONGRATS_SUBJECT),FALSE);
                            EnableWindow(GetDlgItem(hDlg,IDC_STATIC_WIZ_CONGRATS_SUBJECT),FALSE);
                            SetDlgItemText(hDlg, IDC_WIZ_CONGRATS_SUBJECT, NoneBuffer );
                        }
                    }
                } else {
                    if (NoneBuffer[0] != NUL)
                    {
                        SetDlgItemText(hDlg, IDC_WIZ_CONGRATS_COVERPG, NoneBuffer );
                        SetDlgItemText(hDlg, IDC_WIZ_CONGRATS_SUBJECT, NoneBuffer );
                    }
                    EnableWindow(GetDlgItem(hDlg,IDC_STATIC_WIZ_CONGRATS_COVERPG),FALSE);
                    EnableWindow(GetDlgItem(hDlg,IDC_STATIC_WIZ_CONGRATS_SUBJECT),FALSE);
                    EnableWindow(GetDlgItem(hDlg,IDC_WIZ_CONGRATS_COVERPG),FALSE);
                    EnableWindow(GetDlgItem(hDlg,IDC_WIZ_CONGRATS_SUBJECT),FALSE);
                }
                break;

                default:
                    ;
            }

        default:
            return FALSE;
    } ;

    return TRUE;

}

INT_PTR
WelcomeWizProc(
    HWND    hDlg,
    UINT    message,
    WPARAM  wParam,
    LPARAM  lParam
    )

/*++

Routine Description:

    Dialog procedure for the first wizard page:
    give user a chance to confirm or cancel the dialog.

Arguments:

    hDlg - Identifies the wizard page
    message - Specifies the message
    wParam - Specifies additional message-specific information
    lParam - Specifies additional message-specific information

Return Value:

    Depends on the message parameter

--*/

{
    PWIZARDUSERMEM  pWizardUserMem;
    UINT ResourceString = IDS_ERROR_SERVER_RETRIEVE;

    if (! (pWizardUserMem = CommonWizardProc(hDlg, message, wParam, lParam, PSWIZB_NEXT)))
            return FALSE;

    switch (message) {

    case WM_INITDIALOG:
        //
        // set the large fonts
        //
        SetWindowFont(GetDlgItem(hDlg,IDC_WIZ_WELCOME_TITLE), pWizardUserMem->hLargeFont, TRUE);

        //
        // show this text only if we're running the send wizard
        //
        if ((pWizardUserMem->dwFlags & FSW_USE_SEND_WIZARD) != FSW_USE_SEND_WIZARD)
        {
            MyHideWindow(GetDlgItem(hDlg,IDC_WIZ_WELCOME_FAXSEND) );
        }
        else
        {
            MyHideWindow(GetDlgItem(hDlg,IDC_WIZ_WELCOME_NOFAXSEND) );
        }

        return TRUE;

    case WM_NOTIFY:

        if (((NMHDR *) lParam)->code == PSN_WIZNEXT)
        {
            //
            // tapi is asynchronously initialized, wait for it to finish spinning up.
            //
            if (WaitForSingleObject( pWizardUserMem->hCountryListEvent, INFINITE ) != WAIT_OBJECT_0)
            {
                Error(("WaitForSingleObject failed. ec = 0x%X\n",GetLastError()));
                Assert(FALSE);
                goto close_wizard;
            }

            //
            // Check that pCountryList is filled. Otherwise some error occured, e.g. can not
            // connect to Fax Server or TAPI initialization failed. In this case we show an
            // error pop up and close an application.
            //
            if (pWizardUserMem->dwQueueStates & FAX_OUTBOX_BLOCKED )
            {
                ResourceString = IDS_ERROR_SERVER_BLOCKED;
                goto close_wizard;
            }

            if (!pWizardUserMem->pCountryList)
            {
                ResourceString = IDS_ERROR_SERVER_RETRIEVE;
                goto close_wizard;
            }

            if((pWizardUserMem->dwRights & FAX_ACCESS_SUBMIT)        != FAX_ACCESS_SUBMIT           &&
               (pWizardUserMem->dwRights & FAX_ACCESS_SUBMIT_NORMAL) != FAX_ACCESS_SUBMIT_NORMAL    &&
               (pWizardUserMem->dwRights & FAX_ACCESS_SUBMIT_HIGH)   != FAX_ACCESS_SUBMIT_HIGH)
            {
                ResourceString = IDS_ERROR_NO_SUBMIT_ACCESS;
                goto close_wizard;
            }
        }
    } ;

    return FALSE;

close_wizard:

    ErrorMessageBox(hDlg, ResourceString, MB_ICONSTOP);

    PropSheet_PressButton(((NMHDR *) lParam)->hwndFrom,PSBTN_CANCEL);

    SetWindowLongPtr( hDlg, DWLP_MSGRESULT, -1 );

    return TRUE;

}



BOOL
GetFakeRecipientInfo( PWIZARDUSERMEM  pWizardUserMem)

/*++

Routine Description:

    Skip send fax wizard and get faked recipient information from the registry

Arguments:

    pWizardUserMem - Points to the user mode memory structure

Return Value:

    TRUE if successful.
    FALSE and last error is qual ERROR_SUCCESS, some of the registry values are missing.
    FALSE and last error is not ERROR_SUCCESS, if error occured.

--*/

{
    LPTSTR  pRecipientEntry;
    DWORD   index;
    TCHAR   buffer[MAX_STRING_LEN];
    BOOL    fSuccess = FALSE;
    HKEY    hRegKey;
    DWORD   dwRes = ERROR_SUCCESS;
    DWORD   dwStringSize;
    LPTSTR  pCoverPage = NULL;
    TCHAR* tstrCurrentUserKeyPath = NULL;
    DWORD dwTestsNum;
	BOOL  fServerBasedCP = FALSE;

    const char* strDebugPrefix = "[******REGISTRY HACK******]:";

    Verbose(("%s Send Fax Wizard skipped...\n", strDebugPrefix));

    Assert(pWizardUserMem);

    SetLastError(0);

    if(IsNTSystemVersion())
    {
        Verbose(("%s NT Platform\n", strDebugPrefix));

        dwRes =  FormatCurrentUserKeyPath( REGVAL_KEY_FAKE_TESTS,
                                           &tstrCurrentUserKeyPath);
        if(dwRes != ERROR_SUCCESS)
        {
            Error(("%s FormatCurrentUserKeyPath failed with ec = 0x%X\n",strDebugPrefix,dwRes));
            SetLastError(dwRes);
            return FALSE;
        }
    }
    else
    {
        Verbose(("%s Win9x Platform\n", strDebugPrefix));

        tstrCurrentUserKeyPath = DuplicateString(REGVAL_KEY_FAKE_TESTS);
        if(!tstrCurrentUserKeyPath)
        {
            SetLastError(ERROR_NOT_ENOUGH_MEMORY);
            return FALSE;
        }
    }

    #ifdef UNICODE
        Verbose(("%s Registry entry - %S\n", strDebugPrefix,tstrCurrentUserKeyPath));
    #else

        Verbose(("%s Registry entry - %s\n", strDebugPrefix,tstrCurrentUserKeyPath));
    #endif


    // Open user registry key
    dwRes = RegOpenKey (  HKEY_LOCAL_MACHINE ,
                          tstrCurrentUserKeyPath,
                          &hRegKey );

    if (ERROR_SUCCESS != dwRes)
    {
        //
        // Failed to open key
        //
        Error(("%s RegOpenKey failed with. ec = 0x%X\n",strDebugPrefix,dwRes));
        MemFree(tstrCurrentUserKeyPath);
		SetLastError(0);
        return FALSE;
    }

    MemFree(tstrCurrentUserKeyPath);

    //
    // UserInfo key was successfully openened
    //
    dwTestsNum = GetRegistryDword (hRegKey, REGVAL_FAKE_TESTS_COUNT);
    if (!dwTestsNum)
    {
        Verbose(("%s No tests to execute\n", strDebugPrefix));
        RegCloseKey (hRegKey);
		SetLastError(0);
        return FALSE;
    }

    Verbose(("%s %d tests to execute\n",strDebugPrefix, dwTestsNum));

    index = GetRegistryDword (hRegKey, REGVAL_STRESS_INDEX);

    if (index >= dwTestsNum)
    {
        index = 0;
    }

    wsprintf(buffer, TEXT("FakeRecipient%d"), index);

    pRecipientEntry = GetRegistryStringMultiSz (hRegKey,
                                                buffer,
                                                TEXT("NOT FOUND\0"),
                                                &dwStringSize );
    if(!pRecipientEntry || !_tcscmp(pRecipientEntry , TEXT("NOT FOUND")))
    {
        RegCloseKey (hRegKey);
		SetLastError(0);
        return FALSE;
    }

    FreeRecipientList(pWizardUserMem);

    pCoverPage = GetRegistryString (hRegKey,
                                    REGVAL_FAKE_COVERPAGE,
                                    TEXT(""));

	fServerBasedCP = GetRegistryDword (hRegKey, REGVAL_FAKE_SERVER_BASED_CP) ? TRUE : FALSE;
	
	if(fServerBasedCP)
	{
		LPTSTR pServerBasedCP = MemAlloc( sizeof(TCHAR) * (_tcslen(pCoverPage) +  2));
		if(pServerBasedCP)
		{
			_tcscpy(pServerBasedCP, TEXT("\\"));
			_tcscat(pServerBasedCP, pCoverPage);
		}
		MemFree(pCoverPage);
		pCoverPage = pServerBasedCP;

	}
    //
    // Update an index so that next time around we'll pick a different fake recipient
    //
    if (++index >= dwTestsNum)
    {
        index = 0;
    }

    SetRegistryDword(hRegKey, REGVAL_STRESS_INDEX, index);
    RegCloseKey(hRegKey);

    //
    // Each fake recipient entry is a REG_MULTI_SZ of the following format:
    //  recipient name #1
    //  recipient fax number #1
    //  recipient name #2
    //  recipient fax number #2
    //  ...
    //

    if(pRecipientEntry)
    {

        __try {

            PRECIPIENT  pRecipient = NULL;
            LPTSTR      pName, pAddress, p = pRecipientEntry;
            pName = pAddress = NULL;

            while (*p) {

                pName = p;
                pAddress = pName + _tcslen(pName);
                pAddress = _tcsinc(pAddress);
                p = pAddress + _tcslen(pAddress);
                p = _tcsinc(p);

                pRecipient = MemAllocZ(sizeof(RECIPIENT));
                if(pRecipient)
                {
                    ZeroMemory(pRecipient,sizeof(RECIPIENT));
                }
                pName = DuplicateString(pName);

                pAddress = DuplicateString(pAddress);

                if (!pRecipient || !pName || !pAddress)
                {

                    Error(("%s Invalid fake recipient information\n", strDebugPrefix));

                    SetLastError(ERROR_INVALID_DATA);

                    MemFree(pRecipient);
                    MemFree(pName);
                    MemFree(pAddress);
                    break;
                }

                pRecipient->pNext = pWizardUserMem->pRecipients;
                pWizardUserMem->pRecipients = pRecipient;
                pRecipient->pName = pName;
                pRecipient->pAddress = pAddress;
            }

        } __finally
        {

            if (fSuccess = (pWizardUserMem->pRecipients != NULL))
            {

                //
                // Determine whether a cover page should be used
                //
                pWizardUserMem->bSendCoverPage = FALSE;
                if ((pCoverPage != NULL) && lstrlen (pCoverPage) && pWizardUserMem->lpFaxSendWizardData->lpCoverPageInfo)
                {
                    //
                    // Use the cover page
                    //
                    pWizardUserMem->bSendCoverPage = TRUE;
                    CopyString(pWizardUserMem->lpFaxSendWizardData->lpCoverPageInfo->lptstrCoverPageFileName,
                               pCoverPage,
                               MAX_PATH);

					pWizardUserMem->lpFaxSendWizardData->lpCoverPageInfo->bServerBased = fServerBasedCP;
                }
            }
            else
            {
                SetLastError(ERROR_INVALID_DATA);
            }
        }
    }

    MemFree(pRecipientEntry);
    MemFree(pCoverPage);
    return fSuccess;
}

static HRESULT
FaxFreePersonalProfileInformation(
        PFAX_PERSONAL_PROFILE   lpPersonalProfileInfo
    )
{
    if (lpPersonalProfileInfo) {
        MemFree(lpPersonalProfileInfo->lptstrName);
        lpPersonalProfileInfo->lptstrName = NULL;
        MemFree(lpPersonalProfileInfo->lptstrFaxNumber);
        lpPersonalProfileInfo->lptstrFaxNumber = NULL;
        MemFree(lpPersonalProfileInfo->lptstrCompany);
        lpPersonalProfileInfo->lptstrCompany = NULL;
        MemFree(lpPersonalProfileInfo->lptstrStreetAddress);
        lpPersonalProfileInfo->lptstrStreetAddress = NULL;
        MemFree(lpPersonalProfileInfo->lptstrCity);
        lpPersonalProfileInfo->lptstrCity = NULL;
        MemFree(lpPersonalProfileInfo->lptstrState);
        lpPersonalProfileInfo->lptstrState = NULL;
        MemFree(lpPersonalProfileInfo->lptstrZip);
        lpPersonalProfileInfo->lptstrZip = NULL;
        MemFree(lpPersonalProfileInfo->lptstrCountry);
        lpPersonalProfileInfo->lptstrCountry = NULL;
        MemFree(lpPersonalProfileInfo->lptstrTitle);
        lpPersonalProfileInfo->lptstrTitle = NULL;
        MemFree(lpPersonalProfileInfo->lptstrDepartment);
        lpPersonalProfileInfo->lptstrDepartment = NULL;
        MemFree(lpPersonalProfileInfo->lptstrOfficeLocation);
        lpPersonalProfileInfo->lptstrOfficeLocation = NULL;
        MemFree(lpPersonalProfileInfo->lptstrHomePhone);
        lpPersonalProfileInfo->lptstrHomePhone = NULL;
        MemFree(lpPersonalProfileInfo->lptstrOfficePhone);
        lpPersonalProfileInfo->lptstrOfficePhone = NULL;
        MemFree(lpPersonalProfileInfo->lptstrEmail);
        lpPersonalProfileInfo->lptstrEmail = NULL;
        MemFree(lpPersonalProfileInfo->lptstrBillingCode);
        lpPersonalProfileInfo->lptstrBillingCode = NULL;
        MemFree(lpPersonalProfileInfo->lptstrTSID);
        lpPersonalProfileInfo->lptstrTSID = NULL;
    }
    return S_OK;
}

static HRESULT
FaxFreeCoverPageInformation(
        PFAX_COVERPAGE_INFO_EX  lpCoverPageInfo
    )
{
    if (lpCoverPageInfo) {
        MemFree(lpCoverPageInfo->lptstrCoverPageFileName);
        MemFree(lpCoverPageInfo->lptstrNote);
        MemFree(lpCoverPageInfo->lptstrSubject);
        MemFree(lpCoverPageInfo);
    }
    return S_OK;
}


HRESULT WINAPI
FaxFreeSendWizardData(
        LPFAX_SEND_WIZARD_DATA  lpFaxSendWizardData
    )
{
    if (lpFaxSendWizardData) {
        FaxFreeCoverPageInformation(lpFaxSendWizardData->lpCoverPageInfo) ;
        FaxFreePersonalProfileInformation(lpFaxSendWizardData->lpSenderInfo);
        MemFree(lpFaxSendWizardData->lpSenderInfo);

        FreeRecipientInfo(&lpFaxSendWizardData->dwNumberOfRecipients,lpFaxSendWizardData->lpRecipientsInfo);

        MemFree(lpFaxSendWizardData->szReceiptDeliveryAddress);
        MemFree(lpFaxSendWizardData->lptstrPreviewFile);
    }
    return S_OK;
}


BOOL
SendFaxWizardInternal(
    PWIZARDUSERMEM    pWizardUserMem
    );


HRESULT
FaxSendWizardUI(
        IN  DWORD                   hWndOwner,
        IN  DWORD                   dwFlags,
        IN  LPTSTR                  lptstrServerName,
        IN  LPTSTR                  lptstrPrinterName,
        IN  LPFAX_SEND_WIZARD_DATA  lpInitialData,
        OUT LPTSTR                  lptstrTifName,
        IN  UINT                    cchstrTifName,
        OUT LPFAX_SEND_WIZARD_DATA  lpFaxSendWizardData
   )
/*++

Routine Description:

    This function shows the fax send wizard

Arguments:

    hWndOwner - pointer to owner's window
    dwFlags - flags modified behavior of the fax send wizard. The flag can be combined from
            the following values:
            FSW_FORCE_COVERPAGE,
            FSW_USE_SCANNER,
            FSW_USE_SCHEDULE_ACTION,
            FSW_USE_RECEIPT,
            FSW_SEND_WIZARD_FROM_SN,
            FSW_RESEND_WIZARD,
            FSW_PRINT_PREVIEW_OPTION

            for more information about this flags see win9xfaxprinterdriver.doc

    lptstrServerName    -   pointer to the server name
    lptstrPrinterName   -   pointer to the printer name
    lpInitialData       -   pointer to the initial data (not NULL!!!)
    lptstrTifName       -   pointer to the output scanned tiff file (must be allocated)
    cchstrTifName       -   size of lptstrTifName buffer in TCHARs
    lpFaxSendWizardData -   pointer to received data

Return Value:

    S_OK if success,
    S_FALSE if CANCEL was pressed
    error otherwise (may return HRESULT_FROM_WIN32(ERROR_NOT_ENOUGH_MEMORY),
                                HRESULT_FROM_WIN32(ERROR_INVALID_PARAMETER))

--*/

{
    PWIZARDUSERMEM      pWizardUserMem = NULL;
    BOOL                bResult = FALSE;
    HRESULT             hResult = S_FALSE;
    INT                 i,iCount;
    PRECIPIENT          pRecipient;

    //
    // Validate parameters
    //

    Assert(lpInitialData);
    Assert(lpFaxSendWizardData);
    Assert(lptstrTifName);

    if (!lpInitialData || !lpFaxSendWizardData || !lptstrTifName ||
        lpFaxSendWizardData->dwSizeOfStruct != sizeof(FAX_SEND_WIZARD_DATA))
    {
        Error(("Invalid parameter passed to function FaxSendWizardUI\n"));
        hResult = HRESULT_FROM_WIN32(ERROR_INVALID_PARAMETER);
        goto exit;
    }

    if ((pWizardUserMem = MemAllocZ(sizeof(WIZARDUSERMEM))) == NULL)
    {
        Error(("Memory allocation failed\n"));
        hResult = HRESULT_FROM_WIN32(ERROR_NOT_ENOUGH_MEMORY);
        goto exit;
    }

    ZeroMemory(pWizardUserMem, sizeof(WIZARDUSERMEM));

    pWizardUserMem->lptstrServerName  = lptstrServerName;
    pWizardUserMem->lptstrPrinterName = lptstrPrinterName;
    pWizardUserMem->dwFlags = dwFlags;
    pWizardUserMem->lpInitialData = lpInitialData;
    pWizardUserMem->lpFaxSendWizardData = lpFaxSendWizardData;
    pWizardUserMem->isLocalPrinter = (lptstrServerName == NULL);
    pWizardUserMem->szTempPreviewTiff[0] = TEXT('\0');


    if ( (lpFaxSendWizardData->lpCoverPageInfo =
        MemAllocZ(sizeof(FAX_COVERPAGE_INFO_EX))) == NULL)
    {
        Error(("Memory allocation failed\n"));
        hResult = HRESULT_FROM_WIN32(ERROR_NOT_ENOUGH_MEMORY);
        goto error;
    }
    ZeroMemory(lpFaxSendWizardData->lpCoverPageInfo, sizeof(FAX_COVERPAGE_INFO_EX));
    lpFaxSendWizardData->lpCoverPageInfo->dwSizeOfStruct = sizeof(FAX_COVERPAGE_INFO_EX);
    lpFaxSendWizardData->lpCoverPageInfo->dwCoverPageFormat = FAX_COVERPAGE_FMT_COV;

    if ( (lpFaxSendWizardData->lpCoverPageInfo->lptstrCoverPageFileName =
        MemAllocZ(sizeof(TCHAR)*MAX_PATH)) == NULL)
    {
        Error(("Memory allocation failed\n"));
        hResult = HRESULT_FROM_WIN32(ERROR_NOT_ENOUGH_MEMORY);
        goto error;
    }
    ZeroMemory(lpFaxSendWizardData->lpCoverPageInfo->lptstrCoverPageFileName, sizeof(TCHAR) * MAX_PATH);

    if ( (lpFaxSendWizardData->lpSenderInfo = MemAllocZ(sizeof(FAX_PERSONAL_PROFILE))) == NULL)
    {
        Error(("Memory allocation failed\n"));
        hResult = HRESULT_FROM_WIN32(ERROR_NOT_ENOUGH_MEMORY);
        goto error;
    }
    ZeroMemory(lpFaxSendWizardData->lpSenderInfo, sizeof(FAX_PERSONAL_PROFILE));
    lpFaxSendWizardData->lpSenderInfo->dwSizeOfStruct = sizeof(FAX_PERSONAL_PROFILE);

    if (!CopyPersonalProfile(lpFaxSendWizardData->lpSenderInfo, lpInitialData->lpSenderInfo))
    {
        hResult = HRESULT_FROM_WIN32(GetLastError());
        Error((
                "CopyPersonalProflie() for SenderInfo failed (hr: 0x%08X)\n",
                hResult
                ));
       goto error;
    }

    FreeRecipientList(pWizardUserMem);
    //
    // copies recipient information to internal structure
    //

    if (!SUCCEEDED(StoreRecipientInfoInternal(pWizardUserMem)))
    {
        hResult = HRESULT_FROM_WIN32(ERROR_NOT_ENOUGH_MEMORY);
        goto error;
    }

    pWizardUserMem->bSendCoverPage = (pWizardUserMem->lpInitialData->lpCoverPageInfo->lptstrCoverPageFileName &&
                                      pWizardUserMem->lpInitialData->lpCoverPageInfo->lptstrCoverPageFileName[0] != NUL);

    bResult = SendFaxWizardInternal(pWizardUserMem);

    if (bResult)
    {
        for (iCount=0,pRecipient=pWizardUserMem->pRecipients;
             pRecipient;
             pRecipient=pRecipient->pNext )
        {
            iCount++;
        }
        if ((lpFaxSendWizardData->dwNumberOfRecipients = iCount) > 0)
        {
            if ( (lpFaxSendWizardData->lpRecipientsInfo
                = MemAllocZ(sizeof(FAX_PERSONAL_PROFILE)*iCount)) == NULL)
            {
                Error(("Memory allocation failed\n"));
                hResult = HRESULT_FROM_WIN32(ERROR_NOT_ENOUGH_MEMORY);
                goto error;
            }

            ZeroMemory(lpFaxSendWizardData->lpRecipientsInfo,sizeof(FAX_PERSONAL_PROFILE)*iCount);
            for (i=0,pRecipient=pWizardUserMem->pRecipients;
                 pRecipient && i<iCount ;
                 pRecipient=pRecipient->pNext , i++)
            {
                lpFaxSendWizardData->lpRecipientsInfo[i].dwSizeOfStruct = sizeof(FAX_PERSONAL_PROFILE);
                hResult = CopyRecipientInfo(&lpFaxSendWizardData->lpRecipientsInfo[i],
                                            pRecipient,
                                            pWizardUserMem->isLocalPrinter);
                if (hResult != S_OK)
                {
					goto error;
                }
			}
        }
        if (pWizardUserMem->bSendCoverPage == FALSE)
        {
            Assert(lpFaxSendWizardData->lpCoverPageInfo);
            MemFree(lpFaxSendWizardData->lpCoverPageInfo->lptstrCoverPageFileName);
            lpFaxSendWizardData->lpCoverPageInfo->lptstrCoverPageFileName = NULL;
        }

        hResult = StringCchCopy(lptstrTifName, cchstrTifName, pWizardUserMem->FileName);
        if(FAILED(hResult))
        {
            Error(("Not enough memory in lptstrTifName buffer\n"));
            Assert(0);
            goto error;
        }
    }


    hResult = bResult ? S_OK : S_FALSE;
    goto exit;
error:
    if (lpFaxSendWizardData)
    {
        FaxFreeSendWizardData(lpFaxSendWizardData);
    }

exit:

    if (pWizardUserMem)
    {
        FreeRecipientList(pWizardUserMem);
        if (pWizardUserMem->lpWabInit)
        {
            UnInitializeWAB( pWizardUserMem->lpWabInit);
        }

        if (pWizardUserMem->lpMAPIabInit)
        {
            UnInitializeMAPIAB(pWizardUserMem->lpMAPIabInit);
        }
        MemFree(pWizardUserMem);
    }

    return hResult;
}

HRESULT WINAPI
FaxSendWizard(
        IN  DWORD                   hWndOwner,
        IN  DWORD                   dwFlags,
        IN  LPTSTR                  lptstrServerName,
        IN  LPTSTR                  lptstrPrinterName,
        IN  LPFAX_SEND_WIZARD_DATA  lpInitialData,
        OUT LPTSTR                  lptstrTifName,
        IN  UINT                    cchstrTifName,
        OUT LPFAX_SEND_WIZARD_DATA  lpFaxSendWizardData
   )
/*++

Routine Description:

    This function prepares initial data and shows the fax send wizard.
    This is invoked during CREATEDCPRE document event.

Arguments:

    hWndOwner - pointer to owner's window
    dwFlags - flags modified behavior of the fax send wizard. The flag can be combined from
            the following values:
            FSW_FORCE_COVERPAGE,
            FSW_USE_SCANNER,
            FSW_USE_SCHEDULE_ACTION,
            FSW_USE_RECEIPT,
            FSW_SEND_WIZARD_FROM_SN,
            FSW_RESEND_WIZARD,
            FSW_PRINT_PREVIEW_OPTION

            for more information about this flags see win9xfaxprinterdriver.doc

    lptstrServerName    -   pointer to the server name
    lptstrPrinterName   -   pointer to the printer name
    lpInitialData       -   pointer to the initial data (if NULL default values are created)
                            this is IN parameter, but it used as a local variable and may be changed
                            during the execution of the function. Though this parameter remains unchanged
                            at the end of function.
    lptstrTifName       -   pointer to the output scanned tiff file (must be allocated)
    cchstrTifName       -   size of lptstrTifName buffer in TCHARs
    lpFaxSendWizardData -   pointer to received data

Return Value:

    S_OK if success,
    S_FALSE if CANCEL was pressed
    error otherwise (may return HRESULT_FROM_WIN32(ERROR_NOT_ENOUGH_MEMORY),
                                HRESULT_FROM_WIN32(ERROR_INVALID_PARAMETER))

--*/
{
    HRESULT             hResult;
    DWORD               dwIndex;
    DWORD               dwDeafultValues = 0;
    HMODULE             hConfigWizModule=NULL;
    FAX_CONFIG_WIZARD   fpFaxConfigWiz=NULL;
    DWORD               dwVersion, dwMajorWinVer, dwMinorWinVer;
    BOOL                bAbort = FALSE; // Do we abort because the user refused to enter a dialing location?

    // Validate parameters
    Assert(lpFaxSendWizardData);
    Assert(lptstrTifName);

    //
    // Do not execute any code before this initialization
    //
    if(!InitializeDll())
    {
        hResult = E_FAIL;
        goto exit;
    }

    if (!lpFaxSendWizardData || !lptstrTifName ||
        lpFaxSendWizardData->dwSizeOfStruct != sizeof(FAX_SEND_WIZARD_DATA))
    {
        Error(("Invalid parameter passed to function FaxSendWizard\n"));
        hResult = HRESULT_FROM_WIN32(ERROR_INVALID_PARAMETER);
        goto exit;
    }

    //
    // launch Fax Configuration Wizard
    //
    dwVersion = GetVersion();
    dwMajorWinVer = (DWORD)(LOBYTE(LOWORD(dwVersion)));
    dwMinorWinVer = (DWORD)(HIBYTE(LOWORD(dwVersion)));
    if(dwMajorWinVer != 5 || dwMinorWinVer < 1)
    {
        //
        // Configuration Wizard enable for Windows XP only
        //
        goto no_config_wizard;
    }
    if (GetEnvironmentVariable(TEXT("NTFaxSendNote"), NULL, 0))
    {
        //
        // Running from within the Fax Send Note (fxssend.exe) - config wizard alerady launched implicitly.
        //
        goto no_config_wizard;
    }

    hConfigWizModule = LoadLibrary(FAX_CONFIG_WIZARD_DLL);
    if(hConfigWizModule)
    {
        fpFaxConfigWiz = (FAX_CONFIG_WIZARD)GetProcAddress(hConfigWizModule, FAX_CONFIG_WIZARD_PROC);
        if(fpFaxConfigWiz)
        {
            if(!fpFaxConfigWiz(FALSE, &bAbort))
            {
                Error(("FaxConfigWizard failed (ec: %ld)",GetLastError()));
            }
        }
        else
        {
            Error(("GetProcAddress(FaxConfigWizard) failed (ec: %ld)",GetLastError()));
        }

        if(!FreeLibrary(hConfigWizModule))
        {
            Error(("FreeLibrary(FxsCgfWz.dll) failed (ec: %ld)",GetLastError()));
        }
    }
    else
    {
        Error(("LoadLibrary(FxsCgfWz.dll) failed (ec: %ld)",GetLastError()));
    }
    if (bAbort)
    {
        //
        // User refused to enter a dialing location - stop the wizard now
        //
        return E_ABORT;
    }

no_config_wizard:

    //
    // save the user info when finish
    //
    lpFaxSendWizardData->bSaveSenderInfo = TRUE;

    //
    // restore UseDialingRules flag for local fax
    //
    lpFaxSendWizardData->bUseDialingRules = FALSE;
    lpFaxSendWizardData->bUseOutboundRouting = FALSE;
    if(S_OK != RestoreUseDialingRules(&lpFaxSendWizardData->bUseDialingRules,
                                      &lpFaxSendWizardData->bUseOutboundRouting))
    {
        Error(("RestoreUseDialingRules failed\n"));
    }

    //
    // Allocates memory for initial data if lpInitialData is NULL
    //
    if (!lpInitialData)
    {
        if (!(lpInitialData = MemAllocZ(sizeof(FAX_SEND_WIZARD_DATA))) )
        {
            Error(("Memory allocation failed\n"));
            hResult = HRESULT_FROM_WIN32(ERROR_NOT_ENOUGH_MEMORY);
            goto exit;
        }
        ZeroMemory(lpInitialData, sizeof(FAX_SEND_WIZARD_DATA));
        lpInitialData->dwSizeOfStruct = sizeof(FAX_SEND_WIZARD_DATA);
        dwDeafultValues |= DEFAULT_INITIAL_DATA;
    }

    //
    // Restores receipt info
    //
    if (!(dwFlags & FSW_USE_RECEIPT))
    {
        RestoreLastReciptInfo(&lpInitialData->dwReceiptDeliveryType,
                              &lpInitialData->szReceiptDeliveryAddress);

        dwDeafultValues |= DEFAULT_RECEIPT_INFO;
    }

    //
    // Restores cover page inforamtion
    //
    if (!lpInitialData->lpCoverPageInfo)
    {
        if (!(lpInitialData->lpCoverPageInfo = MemAllocZ(sizeof(FAX_COVERPAGE_INFO_EX))))
        {
            Error(("Memory allocation failed\n"));
            hResult = HRESULT_FROM_WIN32(ERROR_NOT_ENOUGH_MEMORY);
            goto exit;
        }
        ZeroMemory(lpInitialData->lpCoverPageInfo, sizeof(FAX_COVERPAGE_INFO_EX));
        lpInitialData->lpCoverPageInfo->dwSizeOfStruct = sizeof(FAX_COVERPAGE_INFO_EX);
        lpInitialData->lpCoverPageInfo->dwCoverPageFormat = FAX_COVERPAGE_FMT_COV;

        hResult = RestoreCoverPageInfo(&lpInitialData->lpCoverPageInfo->lptstrCoverPageFileName);

        if (FAILED(hResult))
        {
            // Then continue to run and don't initialize cover page's fields
        }

        dwDeafultValues |= DEFAULT_CV_INFO;
    }

    //
    // Restores sender information
    //

    if (!lpInitialData->lpSenderInfo)
    {
        if (!(lpInitialData->lpSenderInfo = MemAllocZ(sizeof(FAX_PERSONAL_PROFILE))))
        {
            Error(("Memory allocation failed\n"));
            hResult = HRESULT_FROM_WIN32(ERROR_NOT_ENOUGH_MEMORY);
            goto exit;
        }

        ZeroMemory(lpInitialData->lpSenderInfo, sizeof(FAX_PERSONAL_PROFILE));
        lpInitialData->lpSenderInfo->dwSizeOfStruct = sizeof(FAX_PERSONAL_PROFILE);

        hResult = FaxGetSenderInformation(lpInitialData->lpSenderInfo);

        if (FAILED(hResult))
        {
            // Then continue to run and don't initialize sender info's fields
        }

        dwDeafultValues |= DEFAULT_SENDER_INFO;
    }



    hResult = FaxSendWizardUI(  hWndOwner,
                                dwFlags,
                                lptstrServerName,
                                lptstrPrinterName,
                                lpInitialData,
                                lptstrTifName,
                                cchstrTifName,
                                lpFaxSendWizardData
                );

    if (hResult == S_OK)
    {
        SaveLastReciptInfo(lpFaxSendWizardData->dwReceiptDeliveryType,
                           lpFaxSendWizardData->szReceiptDeliveryAddress);
        //
        // Save the information about the last recipient as a convenience
        //

        if (lpFaxSendWizardData->dwNumberOfRecipients)
        {
            SaveLastRecipientInfo(&lpFaxSendWizardData->lpRecipientsInfo[0],
                                  lpFaxSendWizardData->dwLastRecipientCountryId);
        }

        if(lpFaxSendWizardData->bSaveSenderInfo)
        {
            FaxSetSenderInformation(lpFaxSendWizardData->lpSenderInfo);
        }

        //
        // save UseDialingRules flag for local fax
        //
        if(S_OK != SaveUseDialingRules(lpFaxSendWizardData->bUseDialingRules,
                                       lpFaxSendWizardData->bUseOutboundRouting))
        {
            Error(("SaveUseDialingRules failed\n"));
        }

        if (lpFaxSendWizardData->lpCoverPageInfo &&
            lpFaxSendWizardData->lpCoverPageInfo->lptstrCoverPageFileName)
        {
            SaveCoverPageInfo(lpFaxSendWizardData->lpCoverPageInfo->lptstrCoverPageFileName);

            //
            //  If Server Based Cover Page File Name has full path, cut it off
            //
            if ( lpFaxSendWizardData->lpCoverPageInfo->bServerBased )
            {
                LPTSTR lptstrDelimiter = NULL;

                if ( lptstrDelimiter =
                    _tcsrchr(lpFaxSendWizardData->lpCoverPageInfo->lptstrCoverPageFileName,
                             FAX_PATH_SEPARATOR_CHR))
                {
                    lptstrDelimiter = _tcsinc(lptstrDelimiter);

                    _tcscpy(lpFaxSendWizardData->lpCoverPageInfo->lptstrCoverPageFileName,
                            lptstrDelimiter);
                }
                else
                {
                    //
                    //  Cover Page should always contain full path
                    //
                    Assert(FALSE);
                }
            }
        }
        else
        {
            //
            // Cover page is not used
            //
            SaveCoverPageInfo(TEXT(""));
        }
    }

exit:

    ShutdownTapi();

    if ( dwDeafultValues & DEFAULT_RECEIPT_INFO )
    {
        MemFree(lpInitialData->szReceiptDeliveryAddress);
        lpInitialData->szReceiptDeliveryAddress = NULL;
    }

    if ( dwDeafultValues & DEFAULT_RECIPIENT_INFO )
    {
        for(dwIndex = 0; dwIndex < lpInitialData->dwNumberOfRecipients; dwIndex++)
        {
            FaxFreePersonalProfileInformation(&lpInitialData->lpRecipientsInfo [dwIndex]);
        }
        MemFree(lpInitialData->lpRecipientsInfo);
        lpInitialData->lpRecipientsInfo = NULL;
        lpInitialData->dwNumberOfRecipients = 0;
    }

    if ( dwDeafultValues & DEFAULT_CV_INFO )
    {
        if (lpFaxSendWizardData->lpCoverPageInfo)
        {
            MemFree(lpInitialData->lpCoverPageInfo->lptstrCoverPageFileName);
            lpInitialData->lpCoverPageInfo->lptstrCoverPageFileName = NULL;
        }
        MemFree(lpInitialData->lpCoverPageInfo);
        lpInitialData->lpCoverPageInfo = NULL;
    }

    if ( dwDeafultValues & DEFAULT_SENDER_INFO )
    {
        if (lpInitialData->lpSenderInfo)
        {
            FaxFreeSenderInformation(lpInitialData->lpSenderInfo);
            MemFree(lpInitialData->lpSenderInfo);
            lpInitialData->lpSenderInfo = NULL;
        }
    }

    if (dwDeafultValues & DEFAULT_INITIAL_DATA)
    {
        MemFree(lpInitialData);
        lpInitialData = NULL;
    }
    //
    // Remove left of temp preview files
    //
    DeleteTempPreviewFiles (NULL, FALSE);

    UnInitializeDll();

    return hResult;
}

BOOL
SendFaxWizardInternal(
    PWIZARDUSERMEM    pWizardUserMem
    )

/*++

Routine Description:

    Present the Send Fax Wizard to the user.

Arguments:

    pWizardUserMem - Points to the user mode memory structure

Return Value:

    TRUE if successful, FALSE if there is an error or the user pressed Cancel.

--*/

#define NUM_PAGES   6  // Number of wizard pages

{
    PROPSHEETPAGE  *ppsp = NULL;
    PROPSHEETHEADER psh;
    INT             result = FALSE;
    HDC             hdc = NULL;
    INT             i;
    LOGFONT         LargeFont;
    LOGFONT         lfTitleFont;
    LOGFONT         lfSubTitleFont;
    NONCLIENTMETRICS ncm = {0};
    TCHAR           FontName[100];
    TCHAR           FontSize[30];
    INT             iFontSize;
    DWORD           ThreadId;
    HANDLE          hThread = NULL;
    BOOL            bSkipReceiptsPage = FALSE;

    LPTSTR          lptstrResource = NULL;


    //
    // A shortcut to skip fax wizard for debugging/testing purposes
    //
    if(!GetFakeRecipientInfo(pWizardUserMem))
    {
        if(GetLastError())
        {
            return FALSE;
        }
        // else continue

    }
    else
    {
        return TRUE;
    }

    Verbose(("Presenting Send Fax Wizard\n"));

    if (IsDesktopSKU() && pWizardUserMem->isLocalPrinter)
    {
        //
        // For desktop SKUs, we don't show the receipts page if faxing locally
        //
        bSkipReceiptsPage = TRUE;
        Assert (pWizardUserMem->lpInitialData);
        pWizardUserMem->lpInitialData->dwReceiptDeliveryType = DRT_NONE;
        pWizardUserMem->lpFaxSendWizardData->dwReceiptDeliveryType = DRT_NONE;
    }

    if (! (ppsp = MemAllocZ(sizeof(PROPSHEETPAGE) * NUM_PAGES))) {

        Error(("Memory allocation failed\n"));
        return FALSE;
    }

    //
    // fire off a thread to do some slow stuff later on in the wizard.
    //
    pWizardUserMem->hCPEvent = CreateEvent(NULL,TRUE,FALSE,NULL);
    if (!pWizardUserMem->hCPEvent)
    {
        Error((
                "Failed to create pWizardUserMem->hCPEvent (ec: %ld)",
                GetLastError()
             ));
        goto Error;

    }
    pWizardUserMem->hCountryListEvent = CreateEvent(NULL,TRUE,FALSE,NULL);
    if (!pWizardUserMem->hCountryListEvent)
    {
        Error((
                "Failed to create pWizardUserMem->hCountryListEvent (ec: %ld)",
                GetLastError()
             ));
        goto Error;

    }

    pWizardUserMem->hTAPIEvent = CreateEvent(NULL,TRUE,FALSE,NULL);
    if (!pWizardUserMem->hTAPIEvent)
    {
        Error((
                "Failed to create pWizardUserMem->hTAPIEvent (ec: %ld)",
                GetLastError()
             ));
        goto Error;

    }

    pWizardUserMem->pCountryList = NULL;

    MarkPDEVWizardUserMem(pWizardUserMem);

    hThread = CreateThread(NULL, 0, AsyncWizardThread, pWizardUserMem, 0, &ThreadId);
    if (!hThread)
    {
        Error(("CreateThread failed. ec = 0x%X\n",GetLastError()));
        goto Error;
    }

    //
    // Fill out one PROPSHEETPAGE structure for every page:
    //  The first page is a welcome page
    //  The first page is for choose the fax recipient
    //  The second page is for choosing cover page, subject and note
    //  The third page is for entering time to send
    //  The fourth page is for choosing of receipt form
    //  The fifth page is for scanning pages (optional)
    //  The last page gives the user a chance to confirm or cancel the dialog
    //

    pWizardUserMem->dwComCtrlVer = GetDllVersion(TEXT("comctl32.dll"));
    Verbose(("COMCTL32.DLL Version is : 0x%08X", pWizardUserMem->dwComCtrlVer));


    if ( pWizardUserMem->dwComCtrlVer >= IE50_COMCTRL_VER)
    {
        FillInPropertyPage( ppsp,  TRUE, IDD_WIZARD_WELCOME,    WelcomeWizProc,    pWizardUserMem ,0,0);
        FillInPropertyPage( ppsp+1,TRUE, IDD_WIZARD_CHOOSE_WHO, RecipientWizProc,  pWizardUserMem ,IDS_WIZ_RECIPIENT_TITLE,IDS_WIZ_RECIPIENT_SUB);
        FillInPropertyPage( ppsp+2, TRUE, IDD_WIZARD_CHOOSE_CP,  CoverPageWizProc,  pWizardUserMem ,IDS_WIZ_COVERPAGE_TITLE,IDS_WIZ_COVERPAGE_SUB );
        FillInPropertyPage( ppsp+3, TRUE, IDD_WIZARD_FAXOPTS,    FaxOptsWizProc,    pWizardUserMem ,IDS_WIZ_FAXOPTS_TITLE,IDS_WIZ_FAXOPTS_SUB);
        if (!bSkipReceiptsPage)
        {
            FillInPropertyPage( ppsp+4, TRUE, IDD_WIZARD_FAXRECEIPT, FaxReceiptWizProc, pWizardUserMem ,IDS_WIZ_FAXRECEIPT_TITLE,IDS_WIZ_FAXRECEIPT_SUB);
        }
        FillInPropertyPage( ppsp + 4 + (bSkipReceiptsPage ? 0 : 1),
                            TRUE, IDD_WIZARD_CONGRATS,   FinishWizProc,     pWizardUserMem ,0,0);
    }
    else
    {
        FillInPropertyPage( ppsp, FALSE,   IDD_WIZARD_WELCOME_NOWIZARD97,    WelcomeWizProc,    pWizardUserMem ,0,0);
        FillInPropertyPage( ppsp+1, FALSE, IDD_WIZARD_CHOOSE_WHO_NOWIZARD97, RecipientWizProc,  pWizardUserMem ,IDS_WIZ_RECIPIENT_TITLE,IDS_WIZ_RECIPIENT_SUB);
        FillInPropertyPage( ppsp+2, FALSE, IDD_WIZARD_CHOOSE_CP_NOWIZARD97,  CoverPageWizProc,  pWizardUserMem ,IDS_WIZ_COVERPAGE_TITLE,IDS_WIZ_COVERPAGE_SUB );
        FillInPropertyPage( ppsp+3, FALSE, IDD_WIZARD_FAXOPTS_NOWIZARD97,    FaxOptsWizProc,    pWizardUserMem ,IDS_WIZ_FAXOPTS_TITLE,IDS_WIZ_FAXOPTS_SUB);
        if (!bSkipReceiptsPage)
        {
            FillInPropertyPage( ppsp+4, FALSE, IDD_WIZARD_FAXRECEIPT_NOWIZARD97, FaxReceiptWizProc, pWizardUserMem ,IDS_WIZ_FAXRECEIPT_TITLE,IDS_WIZ_FAXRECEIPT_SUB);
        }
        FillInPropertyPage( ppsp + 4 + (bSkipReceiptsPage ? 0 : 1),
                            FALSE, IDD_WIZARD_CONGRATS_NOWIZARD97,   FinishWizProc,     pWizardUserMem ,0,0);
    }
    //
    // Fill out the PROPSHEETHEADER structure
    //
    ZeroMemory(&psh, sizeof(psh));

    if(pWizardUserMem->dwComCtrlVer >= PACKVERSION(4,71))
    {
        psh.dwSize = sizeof(PROPSHEETHEADER);
    }
    else
    {
        psh.dwSize = PROPSHEETHEADER_V1_SIZE;
    }



    if ( pWizardUserMem->dwComCtrlVer >= IE50_COMCTRL_VER)
    {
        psh.dwFlags = PSH_PROPSHEETPAGE | PSH_WIZARD | PSH_WIZARD97 | PSH_WATERMARK | PSH_HEADER;
    }
    else
    {
        psh.dwFlags = PSH_PROPSHEETPAGE | PSH_WIZARD ;
    }

    psh.hwndParent = GetActiveWindow();
    psh.hInstance = g_hResource;
    psh.hIcon = NULL;
    psh.pszCaption = TEXT("");
    psh.nPages = NUM_PAGES;
    psh.nStartPage = 0;
    psh.ppsp = ppsp;

    if(hdc = GetDC(NULL)) {
        if(GetDeviceCaps(hdc,BITSPIXEL) >= 8) {
            lptstrResource = MAKEINTRESOURCE(IDB_WATERMARK_256);
        }
        else lptstrResource = MAKEINTRESOURCE(IDB_WATERMARK_16);
        ReleaseDC(NULL,hdc);
    }

 if ( pWizardUserMem->dwComCtrlVer >= IE50_COMCTRL_VER)
 {
    psh.pszbmHeader = MAKEINTRESOURCE(IDB_FAXWIZ_WATERMARK);
    psh.pszbmWatermark = lptstrResource;
 }
    //
    // get the large fonts for wizard97
    //
    ncm.cbSize = sizeof(ncm);
    if (!SystemParametersInfo(SPI_GETNONCLIENTMETRICS, 0, &ncm, 0))
    {
        Error(("SystemParametersInfo failed. ec = 0x%X\n",GetLastError()));
        goto Error;
    }
    else
    {

        CopyMemory((LPVOID* )&LargeFont,     (LPVOID *) &ncm.lfMessageFont,sizeof(LargeFont) );
        CopyMemory((LPVOID* )&lfTitleFont,   (LPVOID *) &ncm.lfMessageFont,sizeof(lfTitleFont) );
        CopyMemory((LPVOID* )&lfSubTitleFont,(LPVOID *) &ncm.lfMessageFont,sizeof(lfSubTitleFont) );

        if (!LoadString(g_hResource,IDS_LARGEFONT_NAME,FontName,ARR_SIZE(FontName)))
        {
            Warning(("LoadString failed. ec = 0x%X\n",GetLastError()));
            Assert(FALSE);
        }

        if (!LoadString(g_hResource,IDS_LARGEFONT_SIZE,FontSize,ARR_SIZE(FontSize)))
        {
            Warning(("LoadString failed. ec = 0x%X\n",GetLastError()));
            Assert(FALSE);
        }

        iFontSize = _tcstoul( FontSize, NULL, 10 );

        // make sure we at least have some basic font
        if (*FontName == 0 || iFontSize == 0) {
            lstrcpy(FontName,TEXT("MS Shell Dlg") );
            iFontSize = 18;
        }

        lstrcpyn(LargeFont.lfFaceName, FontName, LF_FACESIZE);
        LargeFont.lfWeight   = FW_BOLD;

        lstrcpyn(lfTitleFont.lfFaceName,    _T("MS Shell Dlg"), LF_FACESIZE);
        lfTitleFont.lfWeight = FW_BOLD;
        lstrcpyn(lfSubTitleFont.lfFaceName, _T("MS Shell Dlg"), LF_FACESIZE);
        lfSubTitleFont.lfWeight = FW_NORMAL;
        hdc = GetDC(NULL);
        if (!hdc)
        {
            Error((
                    "GetDC() failed (ec: ld)",
                    GetLastError()
                 ));
            goto Error;
        }

        LargeFont.lfHeight = 0 - (GetDeviceCaps(hdc,LOGPIXELSY) * iFontSize / 72);
        lfTitleFont.lfHeight = 0 - (GetDeviceCaps(hdc,LOGPIXELSY) * 9 / 72);
        lfSubTitleFont.lfHeight = 0 - (GetDeviceCaps(hdc,LOGPIXELSY) * 9 / 72);
        pWizardUserMem->hLargeFont    = CreateFontIndirect(&LargeFont);
        if (!pWizardUserMem->hLargeFont)
        {
            Error((
                   "CreateFontIndirect(&LargeFont) failed (ec: %ld)",
                   GetLastError()
                   ));
            goto Error;
        }

        pWizardUserMem->hTitleFont    = CreateFontIndirect(&lfTitleFont);
        if (!pWizardUserMem->hTitleFont )
        {
            Error((
                   "CreateFontIndirect(&lfTitleFont) failed (ec: %ld)",
                   GetLastError()
                   ));
            goto Error;
        }
        ReleaseDC( NULL, hdc);
        hdc = NULL;

    }

    //
    // Display the wizard pages
    //
    if (PropertySheet(&psh) > 0)
        result = pWizardUserMem->finishPressed;
    else
    {
        Error(("PropertySheet() failed (ec: %ld)",GetLastError()));
        result = FALSE;
    }

    //
    // Cleanup properly before exiting
    //

    goto Exit;
    //
    // free headings
    //
Error:
    result = FALSE;
Exit:

    if (hThread)
    {
        DWORD dwRes = WaitForSingleObject(hThread, INFINITE);
        if(WAIT_OBJECT_0 != dwRes)
        {
            Error(("WaitForSingleObject for AsyncWizardThread failed. ec = 0x%X\n",GetLastError()));
        }

        if(!CloseHandle(hThread))
        {
            Error(("CloseHandle failed. ec = 0x%X\n",GetLastError()));
        }
    }

    if (pWizardUserMem->hCPEvent)
    {
        if (!CloseHandle(pWizardUserMem->hCPEvent))
        {
            Error(("CloseHandle(pWizardUserMem->hCPEvent) failed (ec: %ld)", GetLastError()));
        }
    }

    if (pWizardUserMem->hCountryListEvent)
    {
        if(!CloseHandle(pWizardUserMem->hCountryListEvent))
        {
            Error(("CloseHandle(pWizardUserMem->hCountryListEvent) failed (ec: %ld)",
                    GetLastError()));
        }
    }

    if (pWizardUserMem->hTAPIEvent)
    {
        if(!CloseHandle(pWizardUserMem->hTAPIEvent))
        {
            Error(("CloseHandle(pWizardUserMem->hTAPIEvent) failed (ec: %ld)",
                    GetLastError()));
        }
    }

    if (hdc)
    {
         ReleaseDC( NULL, hdc);
         hdc = NULL;
    }

    if ( pWizardUserMem->dwComCtrlVer >= IE50_COMCTRL_VER)
    {
        for (i = 0; i< NUM_PAGES; i++) {
            MemFree( (PVOID)(ppsp+i)->pszHeaderTitle );
            MemFree( (PVOID)(ppsp+i)->pszHeaderSubTitle );
        }
    }


    if (pWizardUserMem->pCountryList)
    {
        FaxFreeBuffer(pWizardUserMem->pCountryList);
    }

    MemFree(ppsp);
    if (pWizardUserMem->hLargeFont)
    {
        DeleteObject(pWizardUserMem->hLargeFont);
        pWizardUserMem->hLargeFont = NULL;
    }


    if (pWizardUserMem->hTitleFont)
    {
        DeleteObject(pWizardUserMem->hTitleFont);
        pWizardUserMem->hTitleFont = NULL;
    }


    if (pWizardUserMem->pCPInfo)
    {
        FreeCoverPageInfo(pWizardUserMem->pCPInfo);
        pWizardUserMem->pCPInfo = NULL;
    }

    Verbose(("Wizard finished...\n"));
    return result;
}



//*****************************************************************************
//* Name:   EnableCoverDlgItems
//* Author: Ronen Barenboim / 4-Feb-1999
//*****************************************************************************
//* DESCRIPTION:
//*     Enables or disables the cover page related dialog item in the cover
//*     page selection dialog.
//*     The selection is based on the following rules:
//*     If the "select cover page" checkbox is off all the other dialog items
//*     are off.
//*     Otherwise,
//*     The subject edit box is enabled only if the cover page has an embedded
//*     subject field.
//*     The note edit box is enabled only if the cover page has an embedded
//*     subject field.
//* PARAMETERS:
//*     [IN]    PWIZARDUSERMEM pWizardUserMem:
//*                 A pointer USERMEM struct that contains information used by the wizard.
//                  Specifically USERMEM.pCPDATA is used to get the selected page path.
//*     [IN]    HWND hDlg:
//*                 A handle to the cover page dialog window.
//* RETURN VALUE:
//*     FALSE: If the function failed.
//*     TRUE: Otherwise.
//*****************************************************************************
BOOL EnableCoverDlgItems(PWIZARDUSERMEM pWizardUserMem, HWND hDlg)
{

    //
    // Disable the subject and note edit boxes if the cover page does not contain the fields
    //
    TCHAR szCoverPage[MAX_PATH];
    DWORD bServerCoverPage;
    BOOL bCPSelected;

    Assert(pWizardUserMem);
    Assert(hDlg);

    if (IsDlgButtonChecked(hDlg,IDC_CHOOSE_CP_CHECK)==BST_INDETERMINATE)
        CheckDlgButton(hDlg, IDC_CHOOSE_CP_CHECK, BST_UNCHECKED );

    bCPSelected = (BST_CHECKED == IsDlgButtonChecked(hDlg,IDC_CHOOSE_CP_CHECK));
    EnableWindow(GetDlgItem(hDlg, IDC_CHOOSE_CP_LIST), bCPSelected);
    EnableWindow(GetDlgItem(hDlg, IDC_STATIC_CHOOSE_CP_SUBJECT), bCPSelected);
    EnableWindow(GetDlgItem(hDlg, IDC_CHOOSE_CP_USER_INFO), bCPSelected);
    EnableWindow(GetDlgItem(hDlg, IDC_STATIC_CP_PREVIEW), bCPSelected);
    ShowWindow (GetDlgItem(hDlg, IDC_STATIC_CP_PREVIEW), bCPSelected ? SW_SHOW : SW_HIDE);
    EnableWindow(GetDlgItem(hDlg, IDC_CHOOSE_CP_SUBJECT), bCPSelected);
    EnableWindow(GetDlgItem(hDlg, IDC_STATIC_CHOOSE_CP_NOTE), bCPSelected);
    EnableWindow(GetDlgItem(hDlg, IDC_CHOOSE_CP_NOTE), bCPSelected);
    EnableWindow(GetDlgItem(hDlg, IDC_STATIC_CHOOSE_TEMPLATE), bCPSelected);

    if (!bCPSelected)
    {
        return TRUE;
    }
    //
    // We have a CP
    //
    if (CB_ERR!=GetSelectedCoverPage(pWizardUserMem->pCPInfo,
                         GetDlgItem(hDlg, IDC_CHOOSE_CP_LIST),
                         szCoverPage,
                         ARR_SIZE(szCoverPage),
                         NULL,
                         0,
                         &bServerCoverPage))
    {
        DWORD ec;
        COVDOCINFO  covDocInfo;

        //
        // Get cover page information. The NULL parameter for hDC causes RenderCoverPage
        // to just return the cover page information in covDocInfo. It does not actually
        // create the cover page TIFF.
        //
        ec = RenderCoverPage(NULL,
                            NULL,
                            NULL,
                            szCoverPage,
                            &covDocInfo,
                            FALSE);
        if (ERROR_SUCCESS == ec)
        {
                EnableWindow(GetDlgItem(hDlg, IDC_STATIC_CHOOSE_TEMPLATE), TRUE);
                EnableWindow(GetDlgItem(hDlg, IDC_CHOOSE_CP_NOTE), (covDocInfo.Flags & COVFP_NOTE) ? TRUE : FALSE);
                EnableWindow(GetDlgItem(hDlg, IDC_STATIC_CHOOSE_CP_NOTE), (covDocInfo.Flags & COVFP_NOTE) ? TRUE : FALSE);
                EnableWindow(GetDlgItem(hDlg, IDC_CHOOSE_CP_SUBJECT), (covDocInfo.Flags & COVFP_SUBJECT) ? TRUE : FALSE);
                EnableWindow(GetDlgItem(hDlg, IDC_STATIC_CHOOSE_CP_SUBJECT), (covDocInfo.Flags & COVFP_SUBJECT) ? TRUE : FALSE);

                pWizardUserMem->noteSubjectFlag = covDocInfo.Flags;
                pWizardUserMem->cpPaperSize = covDocInfo.PaperSize;
                pWizardUserMem->cpOrientation = covDocInfo.Orientation;
        }
        else
        {
            Error(("Cannot examine cover page file '%ws': %d\n", szCoverPage, ec));
            return FALSE;
        }
    }
    else
    {
        Error(("Failed to get cover page name"));
        Assert(FALSE); // This should neverhappen
        return FALSE;
    }
    return TRUE;
}   // EnableCoverDlgItems

#ifdef DBG
#ifdef  WIN__95
ULONG __cdecl
DbgPrint(
    CHAR *  format,
    ...
    )

{
    va_list va;
    char sz[MAX_PATH]={0};

    va_start(va, format);
    _vsnprintf(sz, ARR_SIZE(sz)-1, format, va);
    va_end(va);

    OutputDebugString(sz);
    return 0;
}

VOID DbgBreakPoint(VOID)
{
    DebugBreak();
}

#endif
#endif // DBG
//*****************************************************************************
//* Name:   DrawCoverPagePreview
//* Author: Ronen Barenboim / 31-Dec-99
//*****************************************************************************
//* DESCRIPTION:
//*     Draws the specified coverpage template into the specified window using
//*     the specified device context.
//*     The coverpage template is drawn within the client area of the window
//*     and is surrounded by a 1 pixel wide black frame.
//*     The device context is required to support partial redraw due to
//*     WM_PAINT messages.
//*
//* PARAMETERS:
//*     [IN]    hDc
//*         The device context on which to draw the preview.
//*
//*     [IN]    hwndPrev
//*         The window into which the preview will be drawn.
//*
//*     [IN]    lpctstrCoverPagePath
//*         The full path to the cover page template to be drawn
//*
//*     [IN]    wCPOrientation
//*         The orientation of the cover page template to be drawn
//*
//* RETURN VALUE:
//*     TRUE if the operation succeeded.
//*     FALSE otherwise. Call GetLastError() to get the last error.
//*****************************************************************************


BOOL DrawCoverPagePreview(
            HDC     hdc,
            HWND    hwndPrev,
            LPCTSTR lpctstrCoverPagePath,
            WORD    wCPOrientation)
{

    RECT rectPreview;
    BOOL rVal = TRUE;
    HGDIOBJ hOldPen = 0;

    COVDOCINFO  covDocInfo;
    DWORD       ec;
    //
    // Dummy data for preview.
    //

    COVERPAGEFIELDS UserData;

    Assert ((DMORIENT_PORTRAIT == wCPOrientation) || (DMORIENT_LANDSCAPE == wCPOrientation));

    ZeroMemory(&UserData,sizeof(COVERPAGEFIELDS));
    UserData.ThisStructSize = sizeof(COVERPAGEFIELDS);

    UserData.RecName = AllocateAndLoadString(g_hResource, IDS_CPPREVIEW_NAME);
    UserData.RecFaxNumber = AllocateAndLoadString(g_hResource, IDS_CPPREVIEW_FAXNUMBER);
    UserData.RecCompany = AllocateAndLoadString(g_hResource, IDS_CPPREVIEW_COMPANY);
    UserData.RecStreetAddress = AllocateAndLoadString(g_hResource, IDS_CPPREVIEW_ADDRESS);
    UserData.RecCity = AllocateAndLoadString(g_hResource, IDS_CPPREVIEW_CITY);
    UserData.RecState = AllocateAndLoadString(g_hResource, IDS_CPPREVIEW_STATE);
    UserData.RecZip = AllocateAndLoadString(g_hResource, IDS_CPPREVIEW_ZIP);
    UserData.RecCountry = AllocateAndLoadString(g_hResource, IDS_CPPREVIEW_COUNTRY);
    UserData.RecTitle = AllocateAndLoadString(g_hResource, IDS_CPPREVIEW_TITLE);
    UserData.RecDepartment = AllocateAndLoadString(g_hResource, IDS_CPPREVIEW_DEPARTMENT);
    UserData.RecOfficeLocation = AllocateAndLoadString(g_hResource, IDS_CPPREVIEW_OFFICE);
    UserData.RecHomePhone = AllocateAndLoadString(g_hResource, IDS_CPPREVIEW_FAXNUMBER);
    UserData.RecOfficePhone = AllocateAndLoadString(g_hResource, IDS_CPPREVIEW_FAXNUMBER);

      //
      // Senders stuff...
      //

    UserData.SdrName = AllocateAndLoadString(g_hResource, IDS_CPPREVIEW_NAME);
    UserData.SdrFaxNumber = AllocateAndLoadString(g_hResource, IDS_CPPREVIEW_FAXNUMBER);
    UserData.SdrCompany = AllocateAndLoadString(g_hResource, IDS_CPPREVIEW_COMPANY);
    UserData.SdrAddress = AllocateAndLoadString(g_hResource, IDS_CPPREVIEW_ADDRESS);
    UserData.SdrTitle = AllocateAndLoadString(g_hResource, IDS_CPPREVIEW_TITLE);
    UserData.SdrDepartment = AllocateAndLoadString(g_hResource, IDS_CPPREVIEW_DEPARTMENT);
    UserData.SdrOfficeLocation = AllocateAndLoadString(g_hResource, IDS_CPPREVIEW_OFFICE);
    UserData.SdrHomePhone = AllocateAndLoadString(g_hResource, IDS_CPPREVIEW_FAXNUMBER);
    UserData.SdrOfficePhone = AllocateAndLoadString(g_hResource, IDS_CPPREVIEW_FAXNUMBER);
	UserData.SdrEmail = AllocateAndLoadString(g_hResource, IDS_CPPREVIEW_EMAIL);

      //
      // Misc Stuff...
      //
    UserData.Note = AllocateAndLoadString(g_hResource, IDS_CPPREVIEW_NOTE);
    UserData.Subject = AllocateAndLoadString(g_hResource, IDS_CPPREVIEW_SUBJECT);
    UserData.TimeSent = AllocateAndLoadString(g_hResource, IDS_CPPREVIEW_TIMESENT);
    UserData.NumberOfPages = AllocateAndLoadString(g_hResource, IDS_CPPREVIEW_NUMPAGES);
    UserData.ToList = AllocateAndLoadString(g_hResource, IDS_CPPREVIEW_TOLIST);
    UserData.CCList = AllocateAndLoadString(g_hResource, IDS_CPPREVIEW_TOLIST);

    if (!UserData.RecName           ||  !UserData.RecFaxNumber ||
        !UserData.RecCompany        ||  !UserData.RecStreetAddress ||
        !UserData.RecCity           ||  !UserData.RecState ||
        !UserData.RecZip            ||  !UserData.RecCountry ||
        !UserData.RecTitle          ||  !UserData.RecDepartment ||
        !UserData.RecOfficeLocation ||  !UserData.RecHomePhone      ||
        !UserData.RecOfficePhone    ||  !UserData.SdrName ||
        !UserData.SdrFaxNumber      ||  !UserData.SdrCompany ||
        !UserData.SdrAddress        ||  !UserData.SdrTitle ||
        !UserData.SdrDepartment     ||  !UserData.SdrOfficeLocation ||
        !UserData.SdrHomePhone      ||  !UserData.SdrOfficePhone ||
        !UserData.Note              ||  !UserData.Subject ||
        !UserData.TimeSent          ||  !UserData.NumberOfPages ||
        !UserData.ToList            ||  !UserData.CCList ||
		!UserData.SdrEmail)
    {
        rVal = FALSE;
        Error(("AllocateAndLoadString() is failed. ec = %ld\n", GetLastError()));
        goto exit;
    }

    if (wCPOrientation != g_wCurrMiniPreviewOrientation)
    {
        DWORD dwWidth;
        DWORD dwHeight;
        //
        // Time to change the dimensions of the mini-preview control
        //
        if (DMORIENT_LANDSCAPE == wCPOrientation)
        {
            //
            // Landscape
            //
            dwWidth  = g_dwMiniPreviewLandscapeWidth;
            dwHeight = g_dwMiniPreviewLandscapeHeight;
        }
        else
        {
            //
            // Portrait
            //
            dwWidth  = g_dwMiniPreviewPortraitWidth;
            dwHeight = g_dwMiniPreviewPortraitHeight;
        }
        //
        // Resize the mini-preview control according to the new width and height
        //
        ec = GetControlRect(hwndPrev,&rectPreview);
        if(ERROR_SUCCESS != ec)
        {
            rVal = FALSE;
            Error(("GetControlRect failed. ec = 0x%X\n", ec));
            goto exit;
        }

        //
        // Resize and hide window to avoid fliking during rendering
        //
        SetWindowPos(hwndPrev,
                     0,
                     g_bPreviewRTL ? rectPreview.right : rectPreview.left,
                     rectPreview.top,
                     dwWidth,
                     dwHeight,
                     SWP_NOZORDER | SWP_HIDEWINDOW);

        g_wCurrMiniPreviewOrientation = wCPOrientation;
    }
    //
    //
    // Get the preview window rectangle (again) that will serve as the limit for the preview.
    //
    GetClientRect(hwndPrev,&rectPreview);
    //
    // Draw frame
    //
    if ((hOldPen = SelectPen (hdc,GetStockPen(BLACK_PEN))) == HGDI_ERROR)
    {
        rVal = FALSE;
        Error(("SelectPen failed.\n"));
        goto exit;
    }
    if (!Rectangle(
            hdc,
            0,
            0,
            rectPreview.right-rectPreview.left,
            rectPreview.bottom-rectPreview.top)
            )
    {
        rVal = FALSE;
        Error(("Rectangle failed. ec = 0x%X\n",GetLastError()));
        goto exit;
    }

    //
    // Shrink the rectangle so we draw inside the frame
    //
    rectPreview.left += 1;
    rectPreview.top += 1;
    rectPreview.right -= 1;
    rectPreview.bottom -= 1;

    ec = RenderCoverPage(
            hdc,
            &rectPreview,
            &UserData,
            lpctstrCoverPagePath,
            &covDocInfo,
            TRUE);
    if (ERROR_SUCCESS != ec)
    {
        Error(("Failed to print cover page file '%s' (ec: %ld)\n",
                lpctstrCoverPagePath,
                ec)
             );
        rVal = FALSE;
        goto exit;
    }

    ShowWindow(hwndPrev, SW_SHOW);

exit:
    //
    // restore pen
    //
    if (hOldPen) {
        SelectPen (hdc,(HPEN)hOldPen);
    }

    MemFree(UserData.RecName);
    MemFree(UserData.RecFaxNumber);
    MemFree(UserData.RecCompany);
    MemFree(UserData.RecStreetAddress);
    MemFree(UserData.RecCity);
    MemFree(UserData.RecState);
    MemFree(UserData.RecZip);
    MemFree(UserData.RecCountry);
    MemFree(UserData.RecTitle);
    MemFree(UserData.RecDepartment);
    MemFree(UserData.RecOfficeLocation);
    MemFree(UserData.RecHomePhone);
    MemFree(UserData.RecOfficePhone);
    MemFree(UserData.SdrName);
    MemFree(UserData.SdrFaxNumber);
    MemFree(UserData.SdrCompany);
    MemFree(UserData.SdrAddress);
    MemFree(UserData.SdrTitle);
    MemFree(UserData.SdrDepartment);
    MemFree(UserData.SdrOfficeLocation);
    MemFree(UserData.SdrHomePhone);
    MemFree(UserData.SdrOfficePhone);
    MemFree(UserData.Note);
    MemFree(UserData.Subject);
    MemFree(UserData.TimeSent);
    MemFree(UserData.NumberOfPages);
    MemFree(UserData.ToList);
    MemFree(UserData.CCList);

    return rVal;

}

//
// Subclass procedure for the static control in which we draw the coverpage preview
// see win32 SDK for prototype description.
//
LRESULT APIENTRY PreviewSubclassProc(
    HWND hwnd,
    UINT uMsg,
    WPARAM wParam,
    LPARAM lParam)
{

     PWIZARDUSERMEM  pWizardUserMem = NULL;
     //
     // We store a pointer to the WIZARDUSERMEM in the window of the sublclassed
     // static cotntrol window. (see WM_INITDIALOG).
     //
     pWizardUserMem = g_pWizardUserMem;

     Assert(ValidPDEVWizardUserMem(pWizardUserMem));

    //
    // We only care about WM_PAINT messages.
    // Everything else is delegated to the window procedure of the class we subclassed.
    //
    if (WM_PAINT == uMsg)
    {
        PAINTSTRUCT ps;
        HDC hdc;



        hdc = BeginPaint(hwnd,&ps);
        if (!hdc)
        {
           Error(("BeginPaint failed (hWnd = 0x%X) (ec: %ld)\n",hwnd,GetLastError()));
           return FALSE;
        }

        if (!DrawCoverPagePreview(
                hdc,
                hwnd,
                pWizardUserMem->lpFaxSendWizardData->lpCoverPageInfo->lptstrCoverPageFileName,
                pWizardUserMem->cpOrientation));
        {
            Error(("Failed to draw preview window (hWnd = 0x%X)\n",hwnd));
        }
        EndPaint(hwnd,&ps);
        return FALSE; // Notify windows that we handled the paint message. We don't delegate
                      // this to the static control
    }
    else
    {
        Assert(pWizardUserMem->wpOrigStaticControlProc);

        return CallWindowProc(
                    pWizardUserMem->wpOrigStaticControlProc,
                    hwnd,
                    uMsg,
                    wParam,
                    lParam);
    }
}


/*

    Concatenates tstrRegRoot path and a the string representation of the current user's SID.

   [in]   tstrRegRoot - Registry root prefix.
   [out]  ptstrCurrentUserKeyPath - Returns a string that represents the current
          user's root key in the Registry.  Caller must call MemFree
          to free the buffer when done with it.

   Returns win32 error.

*/
static DWORD
FormatCurrentUserKeyPath( const PTCHAR tstrRegRoot,
                          PTCHAR* ptstrCurrentUserKeyPath)
{
    HANDLE hToken = NULL;
    BYTE* bTokenInfo = NULL;
    TCHAR* tstrTextualSid = NULL;
    DWORD cchSidSize = 0;
    DWORD dwFuncRetStatus = ERROR_SUCCESS;
    DWORD cbBuffer = 0;
    SID_AND_ATTRIBUTES SidUser;
    TCHAR* pLast = NULL;

    // Open impersonated token
    if(!OpenThreadToken( GetCurrentThread(),
                         TOKEN_READ,
                         TRUE,
                         &hToken))
    {
        dwFuncRetStatus = GetLastError();
    }

    if(dwFuncRetStatus != ERROR_SUCCESS)
    {
        if(dwFuncRetStatus != ERROR_NO_TOKEN)
        {
            return dwFuncRetStatus;
        }

        // Thread is not impersonating a user, get the process token
        if(!OpenProcessToken( GetCurrentProcess(),
                              TOKEN_READ,
                              &hToken))
        {
            return GetLastError();
        }
    }

    // Get user's token information
    if(!GetTokenInformation( hToken,
                             TokenUser,
                             NULL,
                             0,
                             &cbBuffer))
    {
        dwFuncRetStatus = GetLastError();
        if(dwFuncRetStatus != ERROR_INSUFFICIENT_BUFFER)
        {
            goto Exit;
        }

        dwFuncRetStatus = ERROR_SUCCESS;
    }

    bTokenInfo = MemAlloc(cbBuffer);
    if(!bTokenInfo)
    {
        dwFuncRetStatus = ERROR_OUTOFMEMORY;
        goto Exit;
    }

    if(!GetTokenInformation( hToken,
                             TokenUser,
                             bTokenInfo,
                             cbBuffer,
                             &cbBuffer))
    {

        dwFuncRetStatus = GetLastError();
        goto Exit;
    }

    SidUser = (*(TOKEN_USER*)bTokenInfo).User;


    if(!GetTextualSid( SidUser.Sid, NULL, &cchSidSize))
    {
        dwFuncRetStatus = GetLastError();
        if(dwFuncRetStatus != ERROR_INSUFFICIENT_BUFFER)
        {
            goto Exit;
        }
        dwFuncRetStatus = ERROR_SUCCESS;
    }

    tstrTextualSid = MemAlloc(sizeof(TCHAR) * cchSidSize);
    if(!tstrTextualSid)
    {
        dwFuncRetStatus = ERROR_OUTOFMEMORY;
        goto Exit;
    }

    if(!GetTextualSid( SidUser.Sid, tstrTextualSid, &cchSidSize))
    {
        dwFuncRetStatus = GetLastError();
        goto Exit;
    }

    // allocate an extra char for '\'
    *ptstrCurrentUserKeyPath = MemAlloc( sizeof(TCHAR) * (_tcslen(tstrRegRoot) + cchSidSize + 2));
    if(!*ptstrCurrentUserKeyPath)
    {
        dwFuncRetStatus = ERROR_OUTOFMEMORY;
        goto Exit;
    }

    *ptstrCurrentUserKeyPath[0] = TEXT('\0');
    if(tstrRegRoot[0] != TEXT('\0'))
    {
        _tcscat(*ptstrCurrentUserKeyPath,tstrRegRoot);
        pLast = _tcsrchr(tstrRegRoot,TEXT('\\'));
        if( !( pLast && (*_tcsinc(pLast)) == '\0' ) )
        {
            // the last character is not a backslash, add one...
            _tcscat(*ptstrCurrentUserKeyPath, TEXT("\\"));
        }
    }

    _tcscat(*ptstrCurrentUserKeyPath,tstrTextualSid);

Exit:
    if(hToken)
    {
        if(!CloseHandle(hToken))
        {
            Error(("CloseHandle failed. ec = 0x%X\n",GetLastError()));
        }
    }
    MemFree(bTokenInfo);
    MemFree(tstrTextualSid);

    return dwFuncRetStatus;

}

// ------------------------------------------
// This function was copied from SDK samples
//  ------------------------------------------
/*
    This function obtain the textual representation
    of a binary Sid.

    A standardized shorthand notation for SIDs makes it simpler to
    visualize their components:

    S-R-I-S-S...

    In the notation shown above,

    S identifies the series of digits as an SID,
    R is the revision level,
    I is the identifier-authority value,
    S is subauthority value(s).

    An SID could be written in this notation as follows:
    S-1-5-32-544

    In this example,
    the SID has a revision level of 1,
    an identifier-authority value of 5,
    first subauthority value of 32,
    second subauthority value of 544.
    (Note that the above Sid represents the local Administrators group)

    The GetTextualSid() function will convert a binary Sid to a textual
    string.

    The resulting string will take one of two forms.  If the
    IdentifierAuthority value is not greater than 2^32, then the SID
    will be in the form:

    S-1-5-21-2127521184-1604012920-1887927527-19009
      ^ ^ ^^ ^^^^^^^^^^ ^^^^^^^^^^ ^^^^^^^^^^ ^^^^^
      | | |      |          |          |        |
      +-+-+------+----------+----------+--------+--- Decimal

    Otherwise it will take the form:

    S-1-0x206C277C6666-21-2127521184-1604012920-1887927527-19009
      ^ ^^^^^^^^^^^^^^ ^^ ^^^^^^^^^^ ^^^^^^^^^^ ^^^^^^^^^^ ^^^^^
      |       |        |      |          |          |        |
      |   Hexidecimal  |      |          |          |        |
      +----------------+------+----------+----------+--------+--- Decimal

    If the function succeeds, the return value is TRUE.
    If the function fails, the return value is FALSE.  To get extended
    error information, call the Win32 API GetLastError().
*/


static BOOL
GetTextualSid( const PSID pSid,          // binary Sid
               LPTSTR tstrTextualSid,    // buffer for Textual representaion of Sid
               LPDWORD cchSidSize        // required/provided TextualSid buffersize
               )
{
    PSID_IDENTIFIER_AUTHORITY pSia;
    DWORD dwSubAuthorities;
    DWORD cchSidCopy;
    DWORD dwCounter;

    //
    // test if Sid passed in is valid
    //
    if(!IsValidSid(pSid))
    {
        return FALSE;
    }

    SetLastError(0);

    // obtain SidIdentifierAuthority
    //
    pSia = GetSidIdentifierAuthority(pSid);

    if(GetLastError())
    {
        return FALSE;
    }

    // obtain sidsubauthority count
    //
    dwSubAuthorities = *GetSidSubAuthorityCount(pSid);

    if(GetLastError())
    {
        return FALSE;
    }

    //
    // compute approximate buffer length
    // S-SID_REVISION- + identifierauthority- + subauthorities- + NULL
    //
    cchSidCopy = (15 + 12 + (12 * dwSubAuthorities) + 1) * sizeof(TCHAR);

    //
    // check provided buffer length.
    // If not large enough, indicate proper size and setlasterror
    //
    if(*cchSidSize < cchSidCopy)
    {
        *cchSidSize = cchSidCopy;
        SetLastError(ERROR_INSUFFICIENT_BUFFER);
        return FALSE;
    }

    //
    // prepare S-SID_REVISION-
    //
    cchSidCopy = wsprintf(tstrTextualSid, TEXT("S-%lu-"), SID_REVISION);

    //
    // prepare SidIdentifierAuthority
    //
    if ( (pSia->Value[0] != 0) || (pSia->Value[1] != 0) )
    {
        cchSidCopy += wsprintf(tstrTextualSid + cchSidCopy,
                               TEXT("0x%02hx%02hx%02hx%02hx%02hx%02hx"),
                               (USHORT)pSia->Value[0],
                               (USHORT)pSia->Value[1],
                               (USHORT)pSia->Value[2],
                               (USHORT)pSia->Value[3],
                               (USHORT)pSia->Value[4],
                               (USHORT)pSia->Value[5]);
    }
    else
    {
        cchSidCopy += wsprintf(tstrTextualSid + cchSidCopy,
                               TEXT("%lu"),
                               (ULONG)(pSia->Value[5])       +
                               (ULONG)(pSia->Value[4] <<  8) +
                               (ULONG)(pSia->Value[3] << 16) +
                               (ULONG)(pSia->Value[2] << 24));
    }

    //
    // loop through SidSubAuthorities
    //
    for(dwCounter = 0 ; dwCounter < dwSubAuthorities ; dwCounter++)
    {
        cchSidCopy += wsprintf(tstrTextualSid + cchSidCopy, TEXT("-%lu"),
                              *GetSidSubAuthority(pSid, dwCounter) );
    }

    //
    // tell the caller how many chars we provided, not including NULL
    //
    *cchSidSize = cchSidCopy;

    return TRUE;
}

/*
    Function returns TRUE if the current runing OS is NT platform.
    If function returned false and GetLastError() returned an error value
    the call GetVersionEx() failed.
*/
static BOOL
IsNTSystemVersion()
{
    OSVERSIONINFO osvi;

    ZeroMemory(&osvi, sizeof(OSVERSIONINFO));
    osvi.dwOSVersionInfoSize = sizeof(OSVERSIONINFO);

    if (! GetVersionEx( &osvi))
    {
         return FALSE;
    }

    if(osvi.dwPlatformId == VER_PLATFORM_WIN32_NT)
    {
        return TRUE;
    }

    SetLastError(0);
    return FALSE;
}




/*++

Routine Description:
    Returns the version information for a DLL exporting "DllGetVersion".
    DllGetVersion is exported by the shell DLLs (specifically COMCTRL32.DLL).

Arguments:

    lpszDllName - The name of the DLL to get version information from.

Return Value:

    The version is retuned as DWORD where:
    HIWORD ( version DWORD  ) = Major Version
    LOWORD ( version DWORD  ) = Minor Version
    Use the macro PACKVERSION to comapre versions.
    If the DLL does not export "DllGetVersion" the function returns 0.

--*/
DWORD GetDllVersion(LPCTSTR lpszDllName)
{

    HINSTANCE hinstDll;
    DWORD dwVersion = 0;

    hinstDll = LoadLibrary(lpszDllName);

    if(hinstDll)
    {
        DLLGETVERSIONPROC pDllGetVersion;

        pDllGetVersion = (DLLGETVERSIONPROC) GetProcAddress(hinstDll, "DllGetVersion");

    // Because some DLLs may not implement this function, you
    // must test for it explicitly. Depending on the particular
    // DLL, the lack of a DllGetVersion function may
    // be a useful indicator of the version.

        if(pDllGetVersion)
        {
            DLLVERSIONINFO dvi;
            HRESULT hr;

            ZeroMemory(&dvi, sizeof(dvi));
            dvi.cbSize = sizeof(dvi);

            hr = (*pDllGetVersion)(&dvi);

            if(SUCCEEDED(hr))
            {
                dwVersion = PACKVERSION(dvi.dwMajorVersion, dvi.dwMinorVersion);
            }
        }

        FreeLibrary(hinstDll);
    }
    return dwVersion;
}




BOOL
DisplayFaxPreview(
            HWND hWnd,
            PWIZARDUSERMEM pWizardUserMem,
            LPTSTR lptstrPreviewFile
            )

/*++

Routine Description:

    Create a temporary TIFF file of the whole job (cover page + body), pop the registered
    TIFF viewer and ask the user whether to continue sending the fax.

    TODO: Once we have our own TIFF viewer, we can use only the temporary file created by
          the driver so far. The security issue of executing an unknown TIFF viewer on a
          different copy of the preview TIFF won't exist anymore...

Arguments:

    hWnd - Parent window handle.
    pWizardUserMem        - Points to the user mode memory structure.
    lptstrPreviewFile   - Full path to the file to be previewed.

Return Value:

    TRUE to continue printing
    FALSE to cancel the job

--*/

{
    HDC hdc = NULL;
    BOOL bRet = TRUE;
    BOOL bPrintedCoverPage = FALSE;
	short Orientation = DMORIENT_PORTRAIT;

    DWORD dwSize;
    HANDLE hFile = INVALID_HANDLE_VALUE;
    DWORD ec = ERROR_SUCCESS;
    COVERPAGEFIELDS cpFields = {0};

    Assert(pWizardUserMem);
    Assert(lptstrPreviewFile);
    Assert(lptstrPreviewFile[0]);
    //
    // Get the body TIFF file size
    //
    if (INVALID_HANDLE_VALUE == (hFile = CreateFile(
                                              lptstrPreviewFile,
                                              GENERIC_READ,
                                              0,
                                              NULL,
                                              OPEN_EXISTING,
                                              FILE_ATTRIBUTE_NORMAL,
                                              NULL)))
    {
        ec = GetLastError();
        Error(("Couldn't open preview file to get the file size. Error: %d\n", ec));
        ErrorMessageBox(hWnd,IDS_PREVIEW_FAILURE, MB_ICONERROR);
        goto Err_Exit;
    }

    dwSize = GetFileSize(hFile, NULL);
    if (0xFFFFFFFF == dwSize)
    {
        ec = GetLastError();
        Error(("Failed getting file size (ec: %ld).\n",ec));
        ErrorMessageBox(hWnd,IDS_PREVIEW_FAILURE, MB_ICONERROR);
        goto Err_Exit;
    }

    if (!CloseHandle(hFile))
    {
        Error(("CloseHandle() failed: (ec: %ld).\n", GetLastError()));
        Assert(INVALID_HANDLE_VALUE == hFile); // assert false
    }
    hFile = INVALID_HANDLE_VALUE;
    //
    // Create a temporary file for the complete preview TIFF - This file will contain the
    // rendered cover page (if used) and the document body
    //
    if (!GenerateUniqueFileNameWithPrefix(
                        TRUE,                           // Use process id
                        NULL,                           // Create in the system temporary directory
                        WIZARD_PREVIEW_TIFF_PREFIX,     // Prefix
                        NULL,                           // Use FAX_TIF_FILE_EXT as extension
                        pWizardUserMem->szTempPreviewTiff,
                        MAX_PATH))
    {
        ec = GetLastError();
        Error(("Failed creating temporary cover page TIFF file (ec: %ld)", ec));
        ErrorMessageBox(hWnd,IDS_PREVIEW_FAILURE, MB_ICONERROR);
        pWizardUserMem->szTempPreviewTiff[0] = TEXT('\0');
        goto Err_Exit;
    }
	//
	// Change the default orientation if needed
	//
	if (pWizardUserMem->cpOrientation == DMORIENT_LANDSCAPE)
	{
		Orientation = DMORIENT_LANDSCAPE;
	}
    //
    // If we have a cover page merge it with the body
    //
    if (pWizardUserMem->lpFaxSendWizardData->lpCoverPageInfo->lptstrCoverPageFileName &&
        pWizardUserMem->lpFaxSendWizardData->lpCoverPageInfo->lptstrCoverPageFileName[0])
    {
        FillCoverPageFields(pWizardUserMem, &cpFields); // does not allocate any memory and can not fail

        ec = PrintCoverPageToFile(
                pWizardUserMem->lpFaxSendWizardData->lpCoverPageInfo->lptstrCoverPageFileName,
                pWizardUserMem->szTempPreviewTiff,
                pWizardUserMem->lptstrPrinterName,
                Orientation,
                0,   // Default resolution
                &cpFields);
        if (ERROR_SUCCESS != ec)
        {
                   Error(("PrintCoverPageToFile() failed (ec: %ld)", ec));
                   ErrorMessageBox(hWnd,IDS_PREVIEW_FAILURE, MB_ICONERROR);
                   goto Err_Exit;
        }
        //
        // Check if we have a non-empty body TIFF file (this happens when an empty document
        // is printed - such as our "Send cover page" utility).
        //
        if (dwSize)
        {
            //
            // Merge the document body TIFF to our cover page TIFF
            //
            if (!MergeTiffFiles(pWizardUserMem->szTempPreviewTiff, lptstrPreviewFile))
            {
                ec = GetLastError();
                Error(("Failed merging cover page and preview TIFF files (ec: %ld).\n", ec));
                ErrorMessageBox(hWnd,IDS_PREVIEW_FAILURE, MB_ICONERROR);
                goto Err_Exit;
            }
        }
    }
    else
    {
        //
        // No cover page was supplied
        //
        if (!dwSize)
        {
            //
            // No cover page was included and we recieved an empty preview file !? In this
            // case there is actually no preview to display so just exit.
            // Note: This can happen when an empty notepad document is printed with no
            //       cover page.
            //
            Warning(("Empty preview file recieved with no cover page.\n"));

            ErrorMessageBox(hWnd,IDS_PREVIEW_NOTHING_TO_PREVIEW, MB_ICONERROR);
            goto Err_Exit;
        }
        //
        // Just copy the driver body file to our temporary preview file
        //
        if (!CopyFile(lptstrPreviewFile, pWizardUserMem->szTempPreviewTiff, FALSE))
        {
            ec = GetLastError();
            Error(("Failed copying TIFF file. Error: %d.\n", ec));
            ErrorMessageBox(hWnd,IDS_PREVIEW_FAILURE, MB_ICONERROR);
            goto Err_Exit;
        }
    }
    //
    // Pop the registered TIFF viewer
    //
    ec = ViewFile (pWizardUserMem->szTempPreviewTiff);
    if (ERROR_SUCCESS != ec)
    {
        Error(("ShellExecuteEx failed\n"));
        if(ERROR_NO_ASSOCIATION == ec)
        {
            ErrorMessageBox(hWnd, IDS_NO_TIF_ASSOCIATION, MB_ICONERROR);
        }
        else
        {
            ErrorMessageBox(hWnd, IDS_PREVIEW_FAILURE, MB_ICONERROR);
        }
        goto Err_Exit;
    }
    goto Exit;

Err_Exit:

    if (pWizardUserMem->szTempPreviewTiff[0] != TEXT('\0'))
    {
        //
        // Delete the file (it is possible that the function failed with the file already created)
        //
        if(!DeleteFile(pWizardUserMem->szTempPreviewTiff))
        {
            Error(("DeleteFile failed. ec = 0x%X\n",GetLastError()));
        }
        //
        // Ignore errors since the file might not be there
        //
        pWizardUserMem->szTempPreviewTiff[0]=TEXT('\0');
    }
    bRet = FALSE;

Exit:
    if (INVALID_HANDLE_VALUE != hFile)
    {
        if (!CloseHandle(hFile))
        {
            Error(("CloseHandle() failed: (ec: %ld).\n", GetLastError()));
            Assert(INVALID_HANDLE_VALUE == hFile); // assert false
        }
    }
    return bRet;
}   // DisplayFaxPreview



BOOL
FillCoverPageFields(
    IN PWIZARDUSERMEM pWizardUserMem,
    OUT PCOVERPAGEFIELDS pCPFields)
/*++

Author:

      Ronen Barenboim 25-March-2000

Routine Description:

    Fills a COVERPAGEFIELDS structure from the content of a WIZARDUSERMEM structure.
    Used to prepare a COVERPAGEFIELDS structure for cover page rendering before cover page
    preview.

Arguments:

    [IN] pWizardUserMem - Pointer to a WIZARDUSERMEM that holds the information to be extracted.

    [OUT] pCPFields - Pointer to a COVERPAGEFIELDS structure that gets filled with
                                      the information from WIZARDUSERMEM.

Return Value:

    BOOL

Comments:
    The function DOES NOT ALLOCATE any memory. It places in COVERPAGEFIELDS pointers to already
    allocated memory in WIZARDUSERMEM.



--*/
{
    static TCHAR szTime[256];
    static TCHAR szNumberOfPages[10] = {0};
    DWORD dwPageCount;
    int iRet;

    Assert(pWizardUserMem);
    Assert(pCPFields);

    memset(pCPFields,0,sizeof(COVERPAGEFIELDS));

    pCPFields->ThisStructSize = sizeof(COVERPAGEFIELDS);

    //
    // Recipient stuff... (we use the first recipient)
    //

    pCPFields->RecName = pWizardUserMem->pRecipients->pName;
    pCPFields->RecFaxNumber = pWizardUserMem->pRecipients->pAddress;

    //
    // Senders stuff...
    //

    pCPFields->SdrName = pWizardUserMem->lpFaxSendWizardData->lpSenderInfo->lptstrName;
    pCPFields->SdrFaxNumber = pWizardUserMem->lpFaxSendWizardData->lpSenderInfo->lptstrFaxNumber;
    pCPFields->SdrCompany = pWizardUserMem->lpFaxSendWizardData->lpSenderInfo->lptstrCompany;
    pCPFields->SdrAddress = pWizardUserMem->lpFaxSendWizardData->lpSenderInfo->lptstrStreetAddress;
    pCPFields->SdrTitle = pWizardUserMem->lpFaxSendWizardData->lpSenderInfo->lptstrTitle;
    pCPFields->SdrDepartment = pWizardUserMem->lpFaxSendWizardData->lpSenderInfo->lptstrDepartment;
    pCPFields->SdrOfficeLocation = pWizardUserMem->lpFaxSendWizardData->lpSenderInfo->lptstrOfficeLocation;
    pCPFields->SdrHomePhone = pWizardUserMem->lpFaxSendWizardData->lpSenderInfo->lptstrHomePhone;
    pCPFields->SdrOfficePhone = pWizardUserMem->lpFaxSendWizardData->lpSenderInfo->lptstrOfficePhone;
	pCPFields->SdrEmail = pWizardUserMem->lpFaxSendWizardData->lpSenderInfo->lptstrEmail;

    //
    // Misc Stuff...
    //
    pCPFields->Note = pWizardUserMem->lpFaxSendWizardData->lpCoverPageInfo->lptstrNote;
    pCPFields->Subject = pWizardUserMem->lpFaxSendWizardData->lpCoverPageInfo->lptstrSubject;

    if(!GetY2KCompliantDate(LOCALE_USER_DEFAULT,
                            0,
                            NULL,
                            szTime,
                            ARR_SIZE(szTime)))
    {
        Error(("GetY2KCompliantDate: failed. ec = 0X%x\n",GetLastError()));
        return FALSE;
    }

    _tcscat(szTime, TEXT(" "));

    if(!FaxTimeFormat(LOCALE_USER_DEFAULT,
                      0,
                      NULL,
                      NULL,
                      _tcsninc(szTime, _tcslen(szTime)),
                      ARR_SIZE(szTime) - _tcslen(szTime)))
    {
        Error(("FaxTimeFormat: failed. ec = 0X%x\n",GetLastError()));
        return FALSE;
    }

    pCPFields->TimeSent = szTime;
    dwPageCount = pWizardUserMem->lpInitialData->dwPageCount;
    if (pWizardUserMem->lpFaxSendWizardData->lpCoverPageInfo->lptstrCoverPageFileName &&
        pWizardUserMem->lpFaxSendWizardData->lpCoverPageInfo->lptstrCoverPageFileName[0])
    {
        dwPageCount++;
    }

    iRet= _sntprintf( szNumberOfPages,
                ARR_SIZE(szNumberOfPages) -1,
                TEXT("%d"),
                dwPageCount);
    Assert(iRet>0);

    //
    // make sure it is allways null terminated
    //
    szNumberOfPages[ARR_SIZE(szNumberOfPages) - 1] = TEXT('\0');
    pCPFields->NumberOfPages = szNumberOfPages;

    return TRUE;
}


BOOL
ErrorMessageBox(
    HWND hwndParent,
    UINT nErrorMessage,
    UINT uIcon
    )
{
    static TCHAR szMessage[MAX_MESSAGE_LEN];
    static TCHAR szTitle[MAX_MESSAGE_LEN];

    Assert(nErrorMessage);

    if (!LoadString(g_hResource, nErrorMessage, szMessage, MAX_MESSAGE_LEN))
    {
        Error(("Failed to load  message string id %ld. (ec: %ld)", nErrorMessage, GetLastError()));
        return FALSE;
    }

    if (!LoadString(g_hResource, IDS_WIZARD_TITLE, szTitle, MAX_MESSAGE_LEN))
    {
        Error(("Failed to load  IDS_WIZARD_TITLE. (ec: %ld)", GetLastError()));
        return FALSE;
    }

    AlignedMessageBox(hwndParent, szMessage, szTitle, MB_OK | uIcon);
    return TRUE;
}
=== C:/Users/treeman/Desktop/windows nt source code\Source\Win2K3\NT\printscan\faxsrv\print\faxprint\prnwzrd\tapiutil.c ===
/*++

Copyright (c) 1996  Microsoft Corporation

Module Name:

    tapiutil.c

Abstract:

    Utility functions for working with TAPI

Environment:

    Windows fax driver user interface

Revision History:

    09/18/96 -davidx-
        Created it.

    22/07/99 -v-sashab-
        Replaced a direct access to TAPI by Server calls

  mm/dd/yy -author-
        description

--*/

#include "faxui.h"
#include "tapiutil.h"
#define STRSAFE_NO_DEPRECATE
#include <strsafe.h>


#define  UNKNOWN_DIALING_LOCATION       (0xffffffff)

static HLINEAPP          g_hLineApp = 0;
static DWORD             g_dwTapiVersion = 0x00020000;
static DWORD             g_dwDefaultDialingLocation = UNKNOWN_DIALING_LOCATION;

BOOL
CurrentLocationUsesCallingCard ();


VOID CALLBACK
TapiLineCallback(
    DWORD     hDevice,
    DWORD     dwMessage,
    ULONG_PTR dwInstance,
    ULONG_PTR dwParam1,
    ULONG_PTR dwParam2,
    ULONG_PTR dwParam3
    )

/*++

Routine Description:

    TAPI line callback function: Even though we don't actually have anything
    to do here, we must provide a callback function to keep TAPI happy.

Arguments:

    hDevice     - Line or call handle
    dwMessage   - Reason for the callback
    dwInstance  - LINE_INFO index
    dwParam1    - Callback parameter #1
    dwParam2    - Callback parameter #2
    dwParam3    - Callback parameter #3

Return Value:

    NONE

--*/

{
}

BOOL
InitTapi ()
{

//
// TAPI does not work properly on Win95
// and does not relevant for remote fax connection
//
#ifdef UNICODE

    DWORD   nLineDevs;
    LONG    status;
    LINEINITIALIZEEXPARAMS lineInitParams;

    Assert (!g_hLineApp);
    if (g_hLineApp)
    {
        return TRUE;
    }

    ZeroMemory(&lineInitParams, sizeof(lineInitParams));
    lineInitParams.dwTotalSize =
    lineInitParams.dwNeededSize =
    lineInitParams.dwUsedSize = sizeof(lineInitParams);

    status = lineInitializeEx (&g_hLineApp,
                               g_hModule,
                               TapiLineCallback,
                               TEXT("Fax Send Wizard"),
                               &nLineDevs,
                               &g_dwTapiVersion,
                               &lineInitParams);

    if (NO_ERROR != status) 
    {
        Error(("lineInitializeEx failed: %x\n", status));
        g_hLineApp = 0;
        return FALSE;
    }
#endif // UNICODE

    return TRUE;
}

void
ShutdownTapi ()
{
    if (!g_hLineApp)
    {
        return;
    }
    //
    // Restore the last dialing location the user selected
    //
    if (UNKNOWN_DIALING_LOCATION != g_dwDefaultDialingLocation)
    {
        SetCurrentLocation (g_dwDefaultDialingLocation);
    }
    lineShutdown (g_hLineApp);
    g_hLineApp = 0;
}   // ShutdownTapi


DWORD
GetDefaultCountryID(
    VOID
    )

/*++

Routine Description:

    Return the default country ID for the current location

Arguments:

    NONE

Return Value:

    The current ID for the current location

--*/

{
    //
    // We assume the correct information has already been saved to the
    // registry during the installation process.
    //

    return 0;
}



PFAX_TAPI_LINECOUNTRY_ENTRY
FindCountry(
    PFAX_TAPI_LINECOUNTRY_LIST  pCountryList,
    DWORD                       countryId
    )

/*++

Routine Description:

    Find the specified country from a list of all countries and
    return a pointer to the corresponding FAX_TAPI_LINECOUNTRY_ENTRY structure

Arguments:

    pCountryList - pointer to the country list
    countryId - Specifies the country ID we're interested in

Return Value:

    Pointer to a FAX_TAPI_LINECOUNTRY_ENTRY structure corresponding to the specified country ID
    NULL if there is an error

--*/

{
    DWORD   dwIndex;

    if (pCountryList == NULL || countryId == 0)
        return NULL;

    //
    // Look at each FAX_TAPI_LINECOUNTRY_ENTRY structure and compare its country ID with
    // the specified country ID
    //

    for (dwIndex=0; dwIndex < pCountryList->dwNumCountries; dwIndex++) {

        if (pCountryList->LineCountryEntries[dwIndex].dwCountryID == countryId)
            return &pCountryList->LineCountryEntries[dwIndex];
    }

    return NULL;
}

DWORD
GetCountryIdFromCountryCode(
    PFAX_TAPI_LINECOUNTRY_LIST  pCountryList,
    DWORD                       dwCountryCode
    )

/*++

Routine Description:


Arguments:

    pCountryList - pointer to the country list
    dwCountryCode - Specifies the country code we're interested in

Return Value:

    Country ID
--*/

{
    DWORD               dwIndex;

    if (pCountryList == NULL || dwCountryCode == 0)
        return 0;

    //
    // Look at each FAX_TAPI_LINECOUNTRY_ENTRY structure and compare its country ID with
    // the specified country ID
    //

    for (dwIndex=0; dwIndex < pCountryList->dwNumCountries; dwIndex++) {

        if (pCountryList->LineCountryEntries[dwIndex].dwCountryCode == dwCountryCode)
            return pCountryList->LineCountryEntries[dwIndex].dwCountryID;
    }

    return 0;
}


INT
AreaCodeRules(
    PFAX_TAPI_LINECOUNTRY_ENTRY  pEntry
    )

/*++

Routine Description:

    Given a FAX_TAPI_LINECOUNTRY_ENTRY structure, determine if area code is needed in that country

Arguments:

    pEntry - Points to a FAX_TAPI_LINECOUNTRY_ENTRY structure

Return Value:

    AREACODE_DONTNEED - Area code is not used in the specified country
    AREACODE_OPTIONAL - Area code is optional in the specified country
    AREACODE_REQUIRED - Area code is required in the specified country

--*/

{
    if ((pEntry != NULL) &&
        (pEntry->lpctstrLongDistanceRule != 0))
    {

        //
        // Area code is required in this country
        //

        if (_tcschr(pEntry->lpctstrLongDistanceRule, TEXT('F')) != NULL)
            return AREACODE_REQUIRED;

        //
        // Area code is not needed in this country
        //

        if (_tcschr(pEntry->lpctstrLongDistanceRule, TEXT('I')) == NULL)
            return AREACODE_DONTNEED;
    }

    //
    // Default case: area code is optional in this country
    //

    return AREACODE_OPTIONAL;
}



VOID
AssemblePhoneNumber(
    OUT LPTSTR  pAddress,
    IN  UINT    cchAddress, 
    IN  DWORD   countryCode,
    IN  LPTSTR  pAreaCode,
    IN  LPTSTR  pPhoneNumber
    )

/*++

Routine Description:

    Assemble a canonical phone number given the following:
        country code, area code, and phone number

Arguments:

    pAddress - Specifies a buffer to hold the resulting fax address
    cchAddress - The size of the pAddress OUT buffer in TCHARs
    countryCode - Specifies the country code
    pAreaCode - Specifies the area code string
    pPhoneNumber - Specifies the phone number string

Return Value:

    NONE


--*/

{
    //
    // Country code if neccessary
    //

    HRESULT hRc;


    if (countryCode != 0) {
        hRc = StringCchPrintf(pAddress, 
                              cchAddress, 
                              TEXT("+%d "),
                              countryCode);
        if(FAILED(hRc))
        {
            Assert(0);
            return;
        }
    }

    //
    // Area code if necessary
    //

    if (pAreaCode && !IsEmptyString(pAreaCode)) {

        if (countryCode != 0)
        {
            hRc = StringCchCat(pAddress, cchAddress, TEXT("(") );
            if(FAILED(hRc))
            {
                Assert(0);
                return;
            }
        }


        hRc = StringCchCat(pAddress, cchAddress, pAreaCode);
        if(FAILED(hRc))
        {
            Assert(0);
            return;
        }

        if (countryCode != 0)
        {
            hRc = StringCchCat(pAddress, cchAddress, TEXT(")"));
            if(FAILED(hRc))
            {
                Assert(0);
                return;
            }
        }

        hRc = StringCchCat(pAddress, cchAddress, TEXT(" "));
        if(FAILED(hRc))
        {
            Assert(0);
            return;
        }
    }

    //
    // Phone number at last
    //

    Assert(pPhoneNumber != NULL);

    hRc = StringCchCat(pAddress, cchAddress, pPhoneNumber);
    if(FAILED(hRc))
    {
        Assert(0);
    }
}



VOID
UpdateAreaCodeField(
    HWND                        hwndAreaCode,
    PFAX_TAPI_LINECOUNTRY_LIST  pCountryList,
    DWORD                       countryId
    )

/*++

Routine Description:

    Update any area code text field associated with a country list box

Arguments:

    hwndAreaCode - Specifies the text field associated with the country list box
    pCountryList - pointer to the country list
    countryId - Currently selected country ID

Return Value:

    NONE

--*/

{
    if (hwndAreaCode == NULL)
        return;

    if (AreaCodeRules(FindCountry(pCountryList,countryId)) == AREACODE_DONTNEED) {

        SendMessage(hwndAreaCode, WM_SETTEXT, 0, (LPARAM) TEXT(""));
        EnableWindow(hwndAreaCode, FALSE);

    } else
        EnableWindow(hwndAreaCode, TRUE);
}


DWORD
GetLocalCountryCode()
/*++

Routine Description:

    Retrieve local country code

Arguments:

    None

Return Value:

    Local country code if success
    NULL if failed

--*/
{
    HMODULE hTapi = NULL;
    TCHAR   tszLocalCountryCode[16] = {0};
    TCHAR   tszLocalCityCode[16] = {0};
    DWORD   dwCountryCode = 0;

    typedef LONG (WINAPI *TAPI_GET_LOCATION_INFO)(LPTSTR, LPTSTR);
    TAPI_GET_LOCATION_INFO pfnTapiGetLocationInfo;

    hTapi = LoadLibrary(TEXT("tapi32.dll"));
    if(!hTapi)
    {
        Error(("LoadLibrary(tapi32.dll) failed. ec = 0x%X\n",GetLastError()));
        return dwCountryCode;
    }

#ifdef UNICODE
    pfnTapiGetLocationInfo = (TAPI_GET_LOCATION_INFO)GetProcAddress(hTapi, "tapiGetLocationInfoW");
#else
    pfnTapiGetLocationInfo = (TAPI_GET_LOCATION_INFO)GetProcAddress(hTapi, "tapiGetLocationInfoA");
    if(!pfnTapiGetLocationInfo)
    {
        pfnTapiGetLocationInfo = (TAPI_GET_LOCATION_INFO)GetProcAddress(hTapi, "tapiGetLocationInfo");
    }
#endif
    if(pfnTapiGetLocationInfo)
    {
        if(0 == pfnTapiGetLocationInfo(tszLocalCountryCode, tszLocalCityCode))
        {
            if (1 != _stscanf(tszLocalCountryCode, TEXT("%u"), &dwCountryCode))
            {
                Error(("_stscanf failed."));
                dwCountryCode = 0;
            }
        }
    }
    else
    {
        Error(("tapiGetLocationInfo failed. ec = 0x%X\n",GetLastError()));
    }

    FreeLibrary(hTapi);

    return dwCountryCode;

} // GetLocalCountryCode

 
VOID
InitCountryListBox(
    PFAX_TAPI_LINECOUNTRY_LIST  pCountryList,
    HWND                        hwndList,
    HWND                        hwndAreaCode,
    LPTSTR                      lptstrCountry,
    DWORD                       countryId,
    BOOL                        bAddCountryCode
    )

/*++

Routine Description:

    Initialize the country list box

Arguments:

    pCountryList    - pointer to the country list
    hwndList        - Handle to the country list box window
    hwndAreaCode    - Handle to an associated area code text field
    lptstrCountry   - Country that should be selected or NULL
    countryId       - Initially selected country ID
    bAddCountryCode - if TRUE add a country code to a country name

Return Value:

    NONE

--*/

#define MAX_COUNTRY_NAME    256

{
    DWORD   dwIndex;
    TCHAR   buffer[MAX_COUNTRY_NAME]={0};

    if(0 == countryId)
    {
        //
        // if no country selected, select the local
        //
        countryId = GetLocalCountryCode();
        if(0 == countryId)
        {
            //
            // The default location is not configured.
            //
            DoTapiProps(hwndList);
            countryId = GetLocalCountryCode();
        }
    }

    //
    // Disable redraw on the list box and reset its content
    //
    SendMessage(hwndList, WM_SETREDRAW, FALSE, 0);
    SendMessage(hwndList, CB_RESETCONTENT, FALSE, 0);

    //
    // Loop through FAX_TAPI_LINECOUNTRY_ENTRY structures and add the available selections to
    // the country list box.
    //
    if (pCountryList) 
    {
        TCHAR szFormat[64] = { TEXT("%s (%d)") };
#ifdef UNICODE
        if(pCountryList->dwNumCountries && 
           IsWindowRTL(hwndList)        &&
           !StrHasRTLChar(LOCALE_SYSTEM_DEFAULT, pCountryList->LineCountryEntries[0].lpctstrCountryName))
        {
            //
            // The Combo Box has RTL layout
            // but the country name has not RTL characters.
            // So, we add LEFT-TO-RIGHT OVERRIDE UNICODE character.
            //
            _tcscpy(szFormat, TEXT("\x202D%s (%d)"));
        }
#endif

        for (dwIndex=0; dwIndex < pCountryList->dwNumCountries; dwIndex++) 
        {
            if (pCountryList->LineCountryEntries[dwIndex].lpctstrCountryName) 
            {
                if(bAddCountryCode)
                {
                    _sntprintf(buffer,
                             sizeof(buffer)/sizeof(buffer[0]) - 1,
                             szFormat,
                             pCountryList->LineCountryEntries[dwIndex].lpctstrCountryName,
                             pCountryList->LineCountryEntries[dwIndex].dwCountryCode);
                }
                else
                {
                    _tcsncpy(buffer, 
                             pCountryList->LineCountryEntries[dwIndex].lpctstrCountryName,
                             sizeof(buffer)/sizeof(buffer[0]) - 1);
                }

                if (lptstrCountry && _tcsstr(buffer,lptstrCountry) && !countryId)   
                {
                    // search for a first occurence of lptstrCountry
                    countryId = pCountryList->LineCountryEntries[dwIndex].dwCountryID;
                }

                SendMessage(hwndList,
                            CB_SETITEMDATA,
                            SendMessage(hwndList, CB_ADDSTRING, 0, (LPARAM) buffer),
                            pCountryList->LineCountryEntries[dwIndex].dwCountryID);
            }
        }
    }
    //
    // Figure out which item in the list should be selected
    //
    if (pCountryList != NULL) 
    {
        for (dwIndex=0; dwIndex <= pCountryList->dwNumCountries; dwIndex++) 
        {
            if ((DWORD) SendMessage(hwndList, CB_GETITEMDATA, dwIndex, 0) == countryId)
                break;
        }

        if (dwIndex > pCountryList->dwNumCountries)
        {
            dwIndex = countryId = 0;
        }
    } 
    else    
    {
        dwIndex = countryId = 0;    
    }
    SendMessage(hwndList, CB_SETCURSEL, dwIndex, 0);
    SendMessage(hwndList, WM_SETREDRAW, TRUE, 0);
    //
    // Update the associated area code text field
    //
    UpdateAreaCodeField(hwndAreaCode, pCountryList, countryId);
}


VOID
SelChangeCountryListBox(
    HWND                        hwndList,
    HWND                        hwndAreaCode,
    PFAX_TAPI_LINECOUNTRY_LIST  pCountryList
    )

/*++

Routine Description:

    Handle dialog selection changes in the country list box

Arguments:

    hwndList - Handle to the country list box window
    hwndAreaCode - Handle to an associated area code text field
    pCountryList - pointer to the country list

Return Value:

    NONE

--*/

{
    UpdateAreaCodeField(hwndAreaCode, pCountryList, GetCountryListBoxSel(hwndList));
}



DWORD
GetCountryListBoxSel(
    HWND    hwndList
    )

/*++

Routine Description:

    Return the current selection of country list box

Arguments:

    hwndList - Handle to the country list box window

Return Value:

    Currently selected country ID

--*/

{
    INT msgResult;

    if ((msgResult = (INT)SendMessage(hwndList, CB_GETCURSEL, 0, 0)) == CB_ERR ||
        (msgResult = (INT)SendMessage(hwndList, CB_GETITEMDATA, msgResult, 0)) == CB_ERR)
    {
        return 0;
    }

    return msgResult;
}

BOOL
DoTapiProps(
    HWND hDlg
    )
{

    DWORD dwRes;

    dwRes = lineTranslateDialog(g_hLineApp, 
                                0,                  // Device ID
                                g_dwTapiVersion,
                                hDlg,
                                NULL);              // Address
    if(0 != dwRes)
    {
        Error(("lineTranslateDialog failed. ec = 0x%X\n", dwRes));
        return FALSE;
    }

    return TRUE;
}   // DoTapiProps

LPLINETRANSLATECAPS
GetTapiLocationInfo(
    HWND hWnd
    )
/*++

Routine Description:

    Get a list of locations from TAPI

Arguments:

    NONE

Return Value:

    Pointer to a LINETRANSLATECAPS structure,
    NULL if there is an error

--*/

#define INITIAL_LINETRANSLATECAPS_SIZE  5000

{

    LPLINETRANSLATECAPS pTranslateCaps = NULL;

//
// TAPI does not work properly on Win95
// and does not relevant for remote fax connection
//
#ifdef UNICODE

    DWORD               cbNeeded = INITIAL_LINETRANSLATECAPS_SIZE;
    LONG                status;
    INT                 i;

    if (!g_hLineApp)
    {
        return NULL;
    }

    for (i = 0; i < 2; i++)
    {
        //
        // Free any existing buffer and allocate a new one with larger size
        //
        MemFree(pTranslateCaps);

        if (! (pTranslateCaps = MemAlloc(cbNeeded))) 
        {
            Error(("Memory allocation failed\n"));
            return NULL;
        }
        //
        // Get the LINETRANSLATECAPS structure from TAPI
        //
        pTranslateCaps->dwTotalSize = cbNeeded;
        status = lineGetTranslateCaps(g_hLineApp, g_dwTapiVersion, pTranslateCaps);
        //
        // Try to bring up UI if there are no locations.
        // 
        if (LINEERR_INIFILECORRUPT == status) 
        {
            if (lineTranslateDialog( g_hLineApp, 0, g_dwTapiVersion, hWnd, NULL )) 
            { 
                MemFree(pTranslateCaps);
                return NULL;
            }
            continue;
        }
        if ((pTranslateCaps->dwNeededSize > pTranslateCaps->dwTotalSize) ||
            (LINEERR_STRUCTURETOOSMALL == status)                        ||
            (LINEERR_NOMEM == status))
        {
            //
            // Retry since our initial estimated buffer size was too small
            //
            if (cbNeeded >= pTranslateCaps->dwNeededSize)
            {
                cbNeeded = cbNeeded * 5;
            }
            else
            {
                cbNeeded = pTranslateCaps->dwNeededSize;
            }
            Warning(("LINETRANSLATECAPS resized to: %d\n", cbNeeded));
        }
        else 
        {
            //
            // Either success of real error - break now and let the code after the loop handle it.
            //
            break;
        }
    }

    if (NO_ERROR != status) 
    {
        Error(("lineGetTranslateCaps failed: %x\n", status));
        MemFree(pTranslateCaps);
        SetLastError (status);
        pTranslateCaps = NULL;
    }
    if (pTranslateCaps)
    {
        //
        // Update the current default dialing location.
        // We save it here and restore it when the wizard exists in ShutdownTapi().
        //
        g_dwDefaultDialingLocation = pTranslateCaps->dwCurrentLocationID;
    }

#endif // UNICODE

    return pTranslateCaps;
}   // GetTapiLocationInfo


BOOL
SetCurrentLocation(
    DWORD   locationID
    )

/*++

Routine Description:

    Change the default TAPI location

Arguments:

    locationID - The permanant ID for the new default TAPI location

Return Value:

    TRUE if successful, FALSE if there is an error

--*/

{
    LONG lResult;

    Assert (g_hLineApp);
    if (!g_hLineApp)
    {
        SetLastError (ERROR_GEN_FAILURE);
        return FALSE;
    }

    lResult = lineSetCurrentLocation(g_hLineApp, locationID);
    if (NO_ERROR == lResult)
    {
        Verbose(("Current location changed: ID = %d\n", locationID));
        return TRUE;
    } 
    else 
    {
        Error(("Couldn't change current TAPI location\n"));
        SetLastError (lResult);
        return FALSE;
    }
}   // SetCurrentLocation


BOOL
TranslateAddress (
    LPCTSTR lpctstrCanonicalAddress,
    DWORD   dwLocationId,
    LPTSTR *lpptstrDialableAndDisplayableAddress
)
/*++

Routine name : TranslateAddress

Routine description:

    Translates a canonical address

Author:

    Eran Yariv (EranY), Feb, 2001

Arguments:

    lpctstrCanonicalAddress               [in]     - Canonical address string
    dwLocationId                          [in]     - Location id to use
    lpptstrDialableAndDisplayableAddress  [out]    - Allocated string holding a combination of translated 
                                                     dialable and displayable addresses

Return Value:

    TRUE if successful, FALSE otherwise (sets last error0.

--*/
{

//
// TAPI does not work properly on Win95
// and does not relevant for remote fax connection
//
#ifdef UNICODE

    DWORD                   dwLineTransOutSize = sizeof(LINETRANSLATEOUTPUT) + 4096;
    LPLINETRANSLATEOUTPUT   lpTranslateOutput = NULL;
    LONG                    lRslt = ERROR_SUCCESS;
    DWORD                   dwRes;
    LPTSTR                  lptstrTranslatedDialableString;    
    LPTSTR                  lptstrTranslatedDisplayableString;
    DWORD                   dwTranslatedStringsSize;
    BOOL                    bCanonicCheck;

    dwRes = IsCanonicalAddress(lpctstrCanonicalAddress, &bCanonicCheck, NULL, NULL, NULL);
    if (ERROR_SUCCESS != dwRes)
    {
        SetLastError (dwRes);
        return FALSE;
    }
    Assert (bCanonicCheck);
    if (!bCanonicCheck)
    {
        SetLastError (ERROR_GEN_FAILURE);
        return FALSE;
    }

    Assert (g_hLineApp);
    if (!g_hLineApp)
    {
        SetLastError (ERROR_GEN_FAILURE);
        return FALSE;
    }

    if (!SetCurrentLocation(dwLocationId))
	{
        return FALSE;
    }

    lpTranslateOutput = MemAlloc (dwLineTransOutSize);
    if (!lpTranslateOutput)
    {
        Error(("Couldn't allocate translation results buffer\n"));
        return FALSE;
    }
    lpTranslateOutput->dwTotalSize = dwLineTransOutSize;
    lRslt = lineTranslateAddress(
        g_hLineApp,
        0,
        g_dwTapiVersion,
        lpctstrCanonicalAddress,
        0,
        LINETRANSLATEOPTION_CANCELCALLWAITING,
        lpTranslateOutput
        );
    if ((lpTranslateOutput->dwNeededSize > lpTranslateOutput->dwTotalSize) ||
        (LINEERR_STRUCTURETOOSMALL == lRslt)                               ||
        (LINEERR_NOMEM == lRslt))
    {
        //
        // Retry since our initial estimated buffer size was too small
        //
        if (dwLineTransOutSize >= lpTranslateOutput->dwNeededSize)
        {
            dwLineTransOutSize = dwLineTransOutSize * 5;
        }
        else
        {
            dwLineTransOutSize = lpTranslateOutput->dwNeededSize;
        }
        //
        // Re-allocate the LineTransCaps structure
        //
        dwLineTransOutSize = lpTranslateOutput->dwNeededSize;

        MemFree(lpTranslateOutput);

        lpTranslateOutput = (LPLINETRANSLATEOUTPUT) MemAlloc(dwLineTransOutSize);
        if (!dwLineTransOutSize)
        {
            Error(("Couldn't allocate translation results buffer\n"));
            return FALSE;
        }

        lpTranslateOutput->dwTotalSize = dwLineTransOutSize;

        lRslt = lineTranslateAddress(
            g_hLineApp,
            0,
            g_dwTapiVersion,
            lpctstrCanonicalAddress,
            0,
            LINETRANSLATEOPTION_CANCELCALLWAITING,
            lpTranslateOutput
            );
        
    }
    if (ERROR_SUCCESS != lRslt)
    {
        //
        // Other error
        //
        Error(("lineGetTranslateAddress() failed, ec=0x%08x\n", lRslt));
        MemFree (lpTranslateOutput);
        SetLastError (lRslt);
        return FALSE;
    }
    //
    // We now hold the valid translated address in lpTranslateOutput
    //

    //
    // Calc required buffer size to hold combined strings.    
    //
    if (CurrentLocationUsesCallingCard ())
    {
        //
        // Calling card is used.
        // TAPI returns credit card numbers in the displayable string.
        // return the input canonical number as the displayable string.
        //      
        lptstrTranslatedDisplayableString = (LPTSTR)lpctstrCanonicalAddress;
    }
    else
    {
        //
        // Calling card isn't used - use displayable string as is.
        //
        Assert (lpTranslateOutput->dwDisplayableStringSize > 0);
        lptstrTranslatedDisplayableString = (LPTSTR)((LPBYTE)lpTranslateOutput + lpTranslateOutput->dwDisplayableStringOffset);
    }

    dwTranslatedStringsSize = _tcslen (lptstrTranslatedDisplayableString);
    Assert (lpTranslateOutput->dwDialableStringSize > 0);
    lptstrTranslatedDialableString = (LPTSTR)((LPBYTE)lpTranslateOutput + lpTranslateOutput->dwDialableStringOffset);
    dwTranslatedStringsSize += _tcslen (lptstrTranslatedDialableString);
    //
    // Add NULL + Formatting extra length
    //
    dwTranslatedStringsSize += COMBINED_TRANSLATED_STRING_EXTRA_LEN + 1;
    //
    // Allocate return buffer
    //
    *lpptstrDialableAndDisplayableAddress = (LPTSTR)MemAlloc (dwTranslatedStringsSize * sizeof (TCHAR));
    if (!*lpptstrDialableAndDisplayableAddress)
    {
        MemFree (lpTranslateOutput);
        Error(("Couldn't allocate translation results buffer\n"));
        return FALSE;
    }
    _stprintf (*lpptstrDialableAndDisplayableAddress,
               COMBINED_TRANSLATED_STRING_FORMAT,
               lptstrTranslatedDialableString,
               lptstrTranslatedDisplayableString);
    MemFree (lpTranslateOutput);
    return TRUE;

#endif // UNICODE

    return FALSE;

}   // TranslateAddress

BOOL
CurrentLocationUsesCallingCard ()
{
    LPLINETRANSLATECAPS pTranslateCaps = GetTapiLocationInfo (NULL);
    DWORD dwIndex;
    BOOL  bRes = TRUE;
    LPLINELOCATIONENTRY pLocationEntry = NULL;

    if (!pTranslateCaps)
    {
        return TRUE;
    }

    //
    // Find current location
    //
    pLocationEntry = (LPLINELOCATIONENTRY)
        ((PBYTE) pTranslateCaps + pTranslateCaps->dwLocationListOffset);
    for (dwIndex = 0; dwIndex < pTranslateCaps->dwNumLocations; dwIndex++)
    {
        if (pLocationEntry->dwPermanentLocationID == pTranslateCaps->dwCurrentLocationID)
        {
            //
            // We found the current calling location
            // Let's see if it uses calling cards.
            //
            if (pLocationEntry->dwPreferredCardID)
            {
                bRes = TRUE;
                goto exit;
            }
            else
            {
                //
                // Not using calling card
                //
                bRes = FALSE;
                goto exit;
            }
        }
        pLocationEntry++;
    }
exit:
    MemFree (pTranslateCaps);
    return bRes;
}   // CurrentLocationUsesCallingCard
=== C:/Users/treeman/Desktop/windows nt source code\Source\Win2K3\NT\printscan\faxsrv\print\faxprint\sendnote\sendnote.c ===
/*++

Copyright (c) 1996  Microsoft Corporation

Module Name:

    sendnote.c

Abstract:

    Utility program to send fax notes

Environment:

        Windows XP fax driver

Revision History:

        02/15/96 -davidx-
                Created it.

        mm/dd/yy -author-
                description

--*/

#include <windows.h>
#include <windowsx.h>
#include <tchar.h>
#include <faxuiconstants.h>
#include "..\..\..\admin\cfgwzrd\FaxCfgWzExp.h"
#include <faxres.h>
#include <faxutil.h>
#include "sendnote.h"
#include "tiff.h"
#include "faxreg.h"

VOID
DisplayErrorMessage(
    INT     errId
    );

//
// Data structure used to pass parameters to "Select Fax Printer" dialog
//

typedef struct 
{
    LPTSTR          pPrinterName;
    INT             cPrinters;
    INT             iSelectedPrinterIndex;
    PRINTER_INFO_2 *pPrinterInfo2;

} DLGPARAM, *PDLGPARAM;

//
// Global instance handle
//

HINSTANCE g_hResource = NULL;
HMODULE ghInstance = NULL;
INT     _debugLevel = 0;

//
// Maximum length of message strings
//
#define MAX_MESSAGE_LEN     256

//
// Maximum length for a printer name
//
#define MAX_PRINTER_NAME    MAX_PATH

//
// Window NT fax driver name - currently printer driver name cannot be localized
// so it shouldn't be put into the string resource.
//
static TCHAR faxDriverName[] = FAX_DRIVER_NAME;


VOID
InitSelectFaxPrinter(
    HWND        hDlg,
    PDLGPARAM   pDlgParam
    )
/*++

Routine Description:

    Initialize the "Select Fax Printer" dialog

Arguments:

    hDlg - Handle to the print setup dialog window
    pDlgParam - Points to print setup dialog parameters

Return Value:

    NONE

--*/
{
    HWND    hwndList;
    INT     selIndex, printerIndex;

    //
    // Insert all fax printers into a listbox. Note that we've already filtered
    // out non-fax printers earlier by setting their pDriverName field to NULL.
    //

    if (!(hwndList = GetDlgItem(hDlg, IDC_FAXPRINTER_LIST)))
    {
        return;
    }
    for (printerIndex=0; printerIndex < pDlgParam->cPrinters; printerIndex++) 
    {
        if (pDlgParam->pPrinterInfo2[printerIndex].pDriverName) 
        {
            selIndex = (INT)SendMessage(hwndList,
                                        LB_ADDSTRING,
                                        0,
                                        (LPARAM) pDlgParam->pPrinterInfo2[printerIndex].pPrinterName);

            if (selIndex != LB_ERR) 
            {
                if (SendMessage(hwndList, LB_SETITEMDATA, selIndex, printerIndex) == LB_ERR)
                {
                    SendMessage(hwndList, LB_DELETESTRING, selIndex, 0);
                }
            }
        }
    }
    //
    // Select the first fax printer in the list by default
    //
    SendMessage(hwndList, LB_SETCURSEL, 0, 0);
}


BOOL
GetSelectedFaxPrinter(
    HWND        hDlg,
    PDLGPARAM   pDlgParam
    )
/*++

Routine Description:

    Remember the name of currently selected fax printer

Arguments:

    hDlg - Handle to the print setup dialog window
    pDlgParam - Points to print setup dialog parameters

Return Value:

    TRUE if successful, FALSE otherwise

--*/
{
    HWND    hwndList;
    INT     selIndex, printerIndex;

    //
    // Get current selection index
    //
    if ((hwndList = GetDlgItem(hDlg, IDC_FAXPRINTER_LIST)) == NULL ||
        (selIndex = (INT)SendMessage(hwndList, LB_GETCURSEL, 0, 0)) == LB_ERR)
    {
        return FALSE;
    }
    //
    // Retrieve the selected printer index
    //
    printerIndex = (INT)SendMessage(hwndList, LB_GETITEMDATA, selIndex, 0);
    if (printerIndex < 0 || printerIndex >= pDlgParam->cPrinters)
    {
        return FALSE;
    }
    //
    // Remember the selected fax printer name
    //
    _tcsncpy(pDlgParam->pPrinterName,
             pDlgParam->pPrinterInfo2[printerIndex].pPrinterName,
             MAX_PRINTER_NAME);
    pDlgParam->iSelectedPrinterIndex = printerIndex;
    return TRUE;
}


VOID
CenterWindowOnScreen(
    HWND    hwnd
    )
/*++

Routine Description:

    Place the specified windows in the center of the screen

Arguments:

    hwnd - Specifies a window to be centered

Return Value:

    NONE

--*/
{
    HWND    hwndDesktop;
    RECT    windowRect, screenRect;
    INT     windowWidth, windowHeight, screenWidth, screenHeight;

    //
    // Get screen dimension
    //
    hwndDesktop = GetDesktopWindow();
    GetWindowRect(hwndDesktop, &screenRect);
    screenWidth = screenRect.right - screenRect.left;
    screenHeight = screenRect.bottom - screenRect.top;
    //
    // Get window position
    //
    GetWindowRect(hwnd, &windowRect);
    windowWidth = windowRect.right - windowRect.left;
    windowHeight = windowRect.bottom - windowRect.top;
    //
    // Center the window on screen
    //
    MoveWindow(hwnd,
               screenRect.left + (screenWidth - windowWidth) / 2,
               screenRect.top + (screenHeight - windowHeight) / 2,
               windowWidth,
               windowHeight,
               FALSE);
}


INT_PTR CALLBACK
SelectPrinterDlgProc(
    HWND    hDlg,
    UINT    uMsg,
    WPARAM  wParam,
    LPARAM  lParam
   )
/*++

Routine Description:

    Dialog procedure for handling "Select Fax Printer" dialog

Arguments:

    hDlg - Handle to the dialog window
    uMsg, wParam, lParam - Dialog message and message parameters

Return Value:

    Depends on dialog message

--*/
{
    PDLGPARAM   pDlgParam;

    switch (uMsg) 
    {
    case WM_INITDIALOG:

        //
        // Remember the pointer to DLGPARAM structure
        //

        pDlgParam = (PDLGPARAM) lParam;
        Assert(pDlgParam != NULL);
        SetWindowLongPtr(hDlg, DWLP_USER, lParam);

        CenterWindowOnScreen(hDlg);
        InitSelectFaxPrinter(hDlg, pDlgParam);
        return TRUE;

    case WM_COMMAND:

        switch (GET_WM_COMMAND_ID(wParam, lParam)) 
        {
        case IDC_FAXPRINTER_LIST:

            if (GET_WM_COMMAND_CMD(wParam, lParam) != LBN_DBLCLK)
            {
                break;
            }
            //
            // Fall through - double-clicking in the fax printer list
            // is treated the same as clicking OK button
            //

        case IDOK:

            //
            // User pressed OK to proceed
            //
            pDlgParam = (PDLGPARAM) GetWindowLongPtr(hDlg, DWLP_USER);
            Assert(pDlgParam != NULL);

            if (GetSelectedFaxPrinter(hDlg, pDlgParam))
            {
                LPTSTR lptstrServerName = pDlgParam->pPrinterInfo2[pDlgParam->iSelectedPrinterIndex].pServerName;
                if (lptstrServerName &&                                     // Server name exists and
                    _tcslen(lptstrServerName) > 0 &&                        // not empty (remote printer) and
                    !VerifyPrinterIsOnline (pDlgParam->pPrinterName))       // printer is inaccessible.
                {
                    DisplayErrorMessage(IDS_PRINTER_OFFLINE);
                }
                else
                {
                    // 
                    // All is ok
                    //
                    EndDialog (hDlg, IDOK);
                }
            }
            else
            {
                MessageBeep(MB_OK);
            }
            return TRUE;

        case IDCANCEL:

            //
            // User pressed Cancel to dismiss the dialog
            //
            EndDialog(hDlg, IDCANCEL);
            return TRUE;
        }
        break;

    case WM_HELP:
        WinHelpContextPopup(((LPHELPINFO)lParam)->dwContextId, hDlg);
        return TRUE;

    case WM_CONTEXTMENU:
        WinHelpContextPopup(GetWindowContextHelpId((HWND)wParam), hDlg);            
        return TRUE;

    }
    return FALSE;
}


VOID
DisplayErrorMessage(
    INT     errId
    )
/*++

Routine Description:

    Display an error message dialog

Arguments:

    errId - Specifies the resource ID of the error message string

Return Value:

    NONE

--*/
{
    TCHAR   errMsg[MAX_MESSAGE_LEN];
    TCHAR   errTitle[MAX_MESSAGE_LEN];

    DEBUG_FUNCTION_NAME(TEXT("DisplayErrorMessage"));

    if(!LoadString(g_hResource, errId, errMsg, MAX_MESSAGE_LEN))
    {
        DebugPrintEx(DEBUG_ERR, TEXT("LoadString failed. ec = 0x%X"), GetLastError());
        return;
    }

    if(!LoadString(g_hResource, IDS_SENDNOTE, errTitle, MAX_MESSAGE_LEN))
    {
        DebugPrintEx(DEBUG_ERR, TEXT("LoadString failed. ec = 0x%X"), GetLastError());
        return;
    }    
    AlignedMessageBox(NULL, errMsg, errTitle, MB_OK | MB_ICONERROR);
}


BOOL
SelectFaxPrinter(
    LPTSTR      pPrinterName
    )
/*++

Routine Description:

    Select a fax printer to send note to

Arguments:

    pPrinterName - Points to a buffer for storing selected printer name

Return Value:

    TRUE if successful, FALSE if there is an error

--*/
{
    PRINTER_INFO_2 *pPrinterInfo2;
    DWORD           index, cPrinters, cFaxPrinters;
    DLGPARAM        dlgParam;

    //
    // Enumerate the list of printers available on the system
    //

    pPrinterInfo2 = (PPRINTER_INFO_2) MyEnumPrinters(
        NULL,
        2,
        &cPrinters,
        PRINTER_ENUM_LOCAL | PRINTER_ENUM_CONNECTIONS
        );

    //
    // Find out how many fax printers there are:
    //  case 1: no fax printer at all - display an error message
    //  case 2: only one fax printer - use it
    //  case 3: more than one fax printer - display a dialog to let user choose one
    //
    cFaxPrinters = 0;

    for (index=0; index < cPrinters && pPrinterInfo2; index++) 
    {
        if (_tcscmp(pPrinterInfo2[index].pDriverName, faxDriverName) != EQUAL_STRING)
        {
            pPrinterInfo2[index].pDriverName = NULL;
        }
        else if (cFaxPrinters++ == 0)
        {
            _tcsncpy(pPrinterName, pPrinterInfo2[index].pPrinterName, MAX_PRINTER_NAME);
        }
    }

    switch (cFaxPrinters) 
    {
    case 0:
        //
        // No fax printer is installed - display an error message
        //
        if(IsWinXPOS())
        {
            DisplayErrorMessage(IDS_SENDNOTE_NO_FAX_PRINTER);
        }
        else
        {
            //
            // Down level client
            //
            DisplayErrorMessage(IDS_NO_FAX_PRINTER_CONNECTION);
        }
        break;

    case 1:
        //
        // Exactly one fax printer is installed - use it
        //
        break;

    default:
        //
        // More than one fax printer is available - let use choose one
        //
        dlgParam.pPrinterInfo2 = pPrinterInfo2;
        dlgParam.cPrinters = cPrinters;
        dlgParam.pPrinterName = pPrinterName;

        if (DialogBoxParam(g_hResource,
                           MAKEINTRESOURCE(IDD_SELECT_FAXPRINTER),
                           NULL,
                           SelectPrinterDlgProc,
                           (LPARAM) &dlgParam) != IDOK)
        {
            cFaxPrinters = 0;
        }
        break;
    }

    pPrinterName[MAX_PRINTER_NAME-1] = NUL;
    MemFree(pPrinterInfo2);
    return cFaxPrinters > 0;
}

BOOL 
LaunchConfigWizard(
    BOOL bExplicit
)
/*++

Routine name : LaunchConfigWizard

Routine description:

    launch Fax Configuration Wizard for Windows XP platform only

Arguments:

    bExplicit     [in] - TRUE if it's an explicit launch

Return Value:

    TRUE if the send wizard should continue.
    If FALSE, the user failed to set a dialing location and the client console should quit.

--*/
{
    HMODULE hConfigWizModule = NULL;
    DEBUG_FUNCTION_NAME(TEXT("LaunchConfigWizard"));

    if(!IsWinXPOS())
    {
        return TRUE;
    }

    hConfigWizModule = LoadLibrary(FAX_CONFIG_WIZARD_DLL);
    if(hConfigWizModule)
    {
        FAX_CONFIG_WIZARD fpFaxConfigWiz;
        BOOL bAbort = FALSE;
        fpFaxConfigWiz = (FAX_CONFIG_WIZARD)GetProcAddress(hConfigWizModule, 
                                                           FAX_CONFIG_WIZARD_PROC);
        if(fpFaxConfigWiz)
        {
            if(!fpFaxConfigWiz(bExplicit, &bAbort))
            {
                DebugPrintEx(
                    DEBUG_ERR,
                    TEXT("FaxConfigWizard() failed with %ld"),
                    GetLastError());
            }
        }
        else
        {
            DebugPrintEx(
                DEBUG_ERR,
                TEXT("GetProcAddress(FaxConfigWizard) failed with %ld"),
                GetLastError());
        }

        if(!FreeLibrary(hConfigWizModule))
        {
            DebugPrintEx(
                DEBUG_ERR,
                TEXT("FreeLibrary(FxsCgfWz.dll) failed with %ld"),
                GetLastError());
        }
        if (bAbort)
        {
            //
            // User refused to enter a dialing location - stop the client console.
            //
            return FALSE;
        }
    }
    else
    {
        DebugPrintEx(
            DEBUG_ERR,
            TEXT("LoadLibrary(FxsCgfWz.dll) failed with %ld"),
            GetLastError());
    }
    return TRUE;
}   // LaunchConfigWizard    


#ifdef UNICODE
INT
wWinMain(
    HINSTANCE   hInstance,
    HINSTANCE   hPrevInstance,
    LPTSTR      lpCmdLine,
    INT         nCmdShow
    )
#else
INT
WinMain(
    HINSTANCE   hInstance,
    HINSTANCE   hPrevInstance,
    LPTSTR      lpCmdLine,
    INT         nCmdShow
    )
#endif
/*++

Routine Description:

    Application entry point

Arguments:

    hInstance - Identifies the current instance of the application
    hPrevInstance - Identifies the previous instance of the application
    lpCmdLine - Specifies the command line for the application.
    nCmdShow - Specifies how the window is to be shown

Return Value:

    0

--*/
{
    TCHAR       printerName[MAX_PRINTER_NAME+1];
    HDC         hdc;
    TCHAR       sendNote[100];
    DOCINFO     docInfo = 
    {
        sizeof(DOCINFO),
        NULL,
        NULL,
        NULL,
        0,
    };

    DEBUG_FUNCTION_NAME(TEXT("WinMain"));

    InitCommonControls ();
    if(IsRTLUILanguage())
    {
        //
        // Set Right-to-Left layout for RTL languages
        //
        SetRTLProcessLayout();
    }


    //
    // Implicit launch of fax configuration wizard
    //
    if (!LaunchConfigWizard(FALSE))
    {
        //
        // User refused to enter a dialing location - stop the client console.
        //
        DebugPrintEx(
            DEBUG_MSG,
            TEXT("User refused to enter a dialing location - stop now"));
        return 0;
    }

    ghInstance = hInstance;
	g_hResource = GetResInstance(hInstance); 
    if(!g_hResource)
    {
        return 0;
    }
    sendNote[0] = TEXT(' ');
    LoadString( g_hResource, IDS_SENDNOTE, sendNote, sizeof(sendNote)/sizeof(sendNote[0]));
    docInfo.lpszDocName = sendNote ;
    //
    // Check if a printer name is specified on the command line
    //
    ZeroMemory(printerName, sizeof(printerName));

    if (lpCmdLine) 
    {
        _tcsncpy(printerName, lpCmdLine, MAX_PRINTER_NAME);
        printerName[MAX_PRINTER_NAME-1] = NUL;
    }
    //
    // Select a fax printer to send note to if necessary
    //
    if (IsEmptyString(printerName) && !SelectFaxPrinter(printerName))
    {
        goto exit;
    }
    DebugPrintEx(DEBUG_MSG, TEXT("Send note to fax printer: %ws"), printerName);
    //
    // Set an environment variable so that the driver knows
    // the current application is "Send Note" utility.
    //
    SetEnvironmentVariable(TEXT("NTFaxSendNote"), TEXT("1"));
    //
    // Create a printer DC and print an empty job
    //
    if (! (hdc = CreateDC(NULL, printerName, NULL, NULL))) 
    {
        DisplayErrorMessage(IDS_FAX_ACCESS_FAILED);
    } 
    else 
    {
        if (StartDoc(hdc, &docInfo) > 0) 
        {
            if(EndDoc(hdc) <= 0)
            {
                DebugPrintEx(DEBUG_ERR, TEXT("EndDoc failed. ec = 0x%X"), GetLastError());
                DisplayErrorMessage(IDS_FAX_ACCESS_FAILED);
            }
        }
        else
        {
            DebugPrintEx(DEBUG_ERR, TEXT("StartDoc failed. ec = 0x%X"), GetLastError());
            DisplayErrorMessage(IDS_FAX_ACCESS_FAILED);
        }
        DeleteDC(hdc);
    }
exit:
    FreeResInstance();
    return 0;
}
=== C:/Users/treeman/Desktop/windows nt source code\Source\Win2K3\NT\printscan\faxsrv\print\faxprint\prnwzrd\tapiutil.h ===
/*++

Copyright (c) 1996  Microsoft Corporation

Module Name:

    tapiutil.h

Abstract:

    Utility functions for working with TAPI

Environment:

        Windows fax driver user interface

Revision History:

        09/18/96 -davidx-
                Created it.

        dd-mm-yy -author-
                description

--*/


#ifndef _TAPIUTIL_H_
#define _TAPIUTIL_H_


#include <shellapi.h>


//
// Initialize the country list box
//

VOID
InitCountryListBox(
	PFAX_TAPI_LINECOUNTRY_LIST	pCountryList,
    HWND						hwndList,
    HWND						hwndAreaCode,
	LPTSTR						lptstrCountry,
    DWORD						countryCode,
	BOOL                        bAddCountryCode
    );

//
// Handle selection changes in the country list box
//

VOID
SelChangeCountryListBox(
    HWND						hwndList,
    HWND						hwndAreaCode,
	PFAX_TAPI_LINECOUNTRY_LIST	pCountryList
    );

//
// Return the current selection of country list box
//

DWORD
GetCountryListBoxSel(
    HWND    hwndList
    );

//
// Return the default country ID for the current location
//

DWORD
GetDefaultCountryID(
    VOID
    );

//
// Given a FAX_TAPI_LINECOUNTRY_ENTRY structure, determine if area code is needed in that country
//

INT
AreaCodeRules(
    PFAX_TAPI_LINECOUNTRY_ENTRY  pLineCountryEntry
    );

#define AREACODE_DONTNEED   0
#define AREACODE_REQUIRED   1
#define AREACODE_OPTIONAL   2

//
// Find the specified country from a list of all countries and
// return a pointer to the corresponding FAX_TAPI_LINECOUNTRY_ENTRY structure
//

PFAX_TAPI_LINECOUNTRY_ENTRY
FindCountry(
	PFAX_TAPI_LINECOUNTRY_LIST	pCountryList,
    DWORD					    countryId
    );

//
// Assemble a canonical phone number given the following:
//  country code, area code, and phone number
//

VOID
AssemblePhoneNumber(
    OUT LPTSTR  pAddress,
    IN  UINT    cchAddress, 
    IN  DWORD   countryCode,
    IN  LPTSTR  pAreaCode,
    IN  LPTSTR  pPhoneNumber
    );


//
// bring country id from the country code
//
DWORD
GetCountryIdFromCountryCode(
	PFAX_TAPI_LINECOUNTRY_LIST	pCountryList,
    DWORD						dwCountryCode
    );

BOOL
DoTapiProps(
    HWND hDlg
    );

BOOL
SetCurrentLocation(
    DWORD   locationID
    );


LPLINETRANSLATECAPS
GetTapiLocationInfo(
    HWND hWnd
    );

void
ShutdownTapi ();

BOOL
InitTapi ();

BOOL
TranslateAddress (
    LPCTSTR lpctstrCanonicalAddress,
    DWORD   dwLocationId,
    LPTSTR *lpptstrDialableAndDisplayableAddress
);





#endif  // !_TAPIUTIL_H_
=== C:/Users/treeman/Desktop/windows nt source code\Source\Win2K3\NT\printscan\faxsrv\print\faxprint\sendnote\sources.inc ===
!IF 0

Copyright (c) 1989  Microsoft Corporation

Module Name:

    sources.

Abstract:

    This file specifies the target component being built and the list of
    sources files needed to build that component.  Also specifies optional
    compiler switches and libraries that are unique for the component being
    built.


Author:

    Wesley Witt (wesw)

!ENDIF


!include ..\..\..\..\faxsrc.inc

TARGETNAME=$(FAXSEND)
TARGETPATH=obj
TARGETTYPE=PROGRAM

USE_CRTDLL=1
NTKEEPRESOURCETMPFILES=1
UMTYPE=windows

!ifdef NOUNICODE
UMENTRY=winmain
!else
UMENTRY=wwinmain
!endif

INCLUDES=$(INCLUDES);..\..\inc

!ifndef NOUNICODE
C_DEFINES=$(C_DEFINES) -DUNICODE -D_UNICODE
!else
NO_NTDLL=1
!endif

TARGETLIBS=\
    $(BASEDIR)\public\sdk\lib\*\winspool.lib \
    $(BASEDIR)\public\sdk\lib\*\user32.lib   \
    $(BASEDIR)\public\sdk\lib\*\comctl32.lib \
    $(BASEDIR)\public\sdk\lib\*\gdi32.lib    \
    $(BASEDIR)\public\sdk\lib\*\ole32.lib    \
    $(BASEDIR)\public\sdk\lib\*\uuid.lib     \
    $(BASEDIR)\public\sdk\lib\*\shell32.lib

SOURCES=\
    ..\sendnote.c  \
    ..\version.rc
=== C:/Users/treeman/Desktop/windows nt source code\Source\Win2K3\NT\printscan\faxsrv\print\faxprint\sendnote\sendnote.h ===
//////////////////////////////////////////////////////
//                                                  //
// Send fax utility resource ID file                //
// It compiles as part of FxsRes.dll                //
// All the IDs should be in range                   //
//                                                  //
// [13000 - 13499]                                   //
//                                                  //
//////////////////////////////////////////////////////

#ifndef _SENDNOTE_H_
#define _SENDNOTE_H_


#define IDS_SENDNOTE_NO_FAX_PRINTER 13000
#define IDS_FAX_ACCESS_FAILED		13001
#define IDS_SENDNOTE				13002
#define IDS_PRINTER_OFFLINE			13003

#define IDI_FAX_NOTE                13004

#define IDD_SELECT_FAXPRINTER       13005
#define IDC_SENDNOTE_STATIC		    13006
#define IDC_FAXPRINTER_LIST         13007

#define IDS_NO_FAX_PRINTER_CONNECTION   13008

#endif // !_SENDNOTE_H_

//////////////////////////////////////////////////////
//                                                  //
// Send fax utility resource ID file                //
// It compiles as part of FxsRes.dll                //
// All the IDs should be in range                   //
//                                                  //
// [13000 - 13499]                                   //
//                                                  //
//////////////////////////////////////////////////////
=== C:/Users/treeman/Desktop/windows nt source code\Source\Win2K3\NT\printscan\faxsrv\provider\t30\cl2and20\cl2and20.c ===
/*++

Copyright (c) 1997  Microsoft Corporation

Module Name:

    class20.c

Abstract:

    This is the main source for Classes 2 and 2.0 fax-modem T.30 driver

Author:
    Source base was originated by Win95 At Work Fax package.
    RafaelL - July 1997 - port to NT

Revision History:

--*/


#define USE_DEBUG_CONTEXT DEBUG_CONTEXT_T30_CLASS2


#include "prep.h"
#include "efaxcb.h"

#include "tiff.h"

#include "glbproto.h"
#include "t30gl.h"
#include "cl2spec.h"

#include "psslog.h"
#define FILE_ID FILE_ID_CL2AND20
#include "pssframe.h"

#define STRSAFE_NO_DEPRECATE
#include <strsafe.h>

WORD Class2CodeToBPS[16] =
{
/* V27_2400             0 */    2400,
/* V27_4800             1 */    4800,
/* V29_V17_7200         2 */    7200,
/* V29_V17_9600         3 */    9600,
/* V33_V17_12000        4 */    12000,
/* V33_V17_14400        5 */    14400,
                                0,
                                0,
                                0,
                                0,
                                0,
                                0,
                                0,
                                0,
                                0,
                                0
};

#define CLASS2_MAX_CODE_TO_BPS   15

// Speeds for Class2HayesSyncSpeed to try
UWORD rguwClass2Speeds[] = {19200, 9600, 2400, 1200, 0};





BOOL ParseFPTS_SendAck(PThrdGlbl pTG)
{
    BOOL fPageAck = FALSE;
    BOOL fFoundFPTS = FALSE;
    UWORD count;

    DEBUG_FUNCTION_NAME("ParseFPTS_SendAck");

    // Acknowledge that we sent the page
    // Parse the FPTS response and see if the page is good or bad.
    for (count=0; count < pTG->class2_commands.comm_count; ++count)
    {
        switch (pTG->class2_commands.command[count])
        {
        case  CL2DCE_FPTS:
                fFoundFPTS = TRUE;
                switch(pTG->class2_commands.parameters[count][0])
                {
                case 1: DebugPrintEx(DEBUG_MSG,"Found good FPTS");
                        fPageAck = TRUE;
                        // Exar hack!!!
                        // Exar modems give FPTS:1 for good pages and
                        // FPTS:1,2,0,0 for bad. So, look for the 1,2
                        // if this is an EXAR. Otherwise, 1 means good.
                        if (pTG->CurrentMFRSpec.bIsExar)
                        {
                            if (pTG->class2_commands.parameters[count][1] == 2)
                            {
                                DebugPrintEx(DEBUG_ERR,"Nope - really Found bad FPTS");
                                fPageAck = FALSE;
                            }
                        }
                        else
                        {
                            PSSLogEntry(PSS_MSG, 1, "Received MCF");
                        }
                        break;
                case 2: PSSLogEntry(PSS_WRN, 1, "Received RTN");
                        fPageAck = FALSE;
                        break;
                case 3: PSSLogEntry(PSS_WRN, 1, "Received RTP");
                        fPageAck = TRUE;  // After RTP, we send the next page!
                        break;
                case 4: PSSLogEntry(PSS_WRN, 1, "Received PIN");
                        break;
                case 5: PSSLogEntry(PSS_WRN, 1, "Received PIP");
                        break;
                default:PSSLogEntry(PSS_WRN, 1, "Received unknown response");
                }
                break;
        default:
                break;
        }
    }

    if (!fFoundFPTS)
    {
        PSSLogEntry(PSS_WRN, 1, "Didn't receive FPTS");
    }
    return fPageAck;
}


USHORT Class2Dial(PThrdGlbl pTG, LPSTR lpszDial)
{
    UWORD   uwLen,
            uwDialStringLen;
    ULONG   ulTimeout;
    SWORD   swLen;
    USHORT  uRet;
    BYTE    bBuf[DIALBUFSIZE];
    char    chMod = pTG->NCUParams2.chDialModifier;
    DWORD   dwDialTime;

    DEBUG_FUNCTION_NAME("Class2Dial");

    // Send the predial command
    if (pTG->lpCmdTab->szPreDial && (swLen=(SWORD)_fstrlen(pTG->lpCmdTab->szPreDial)))
    {
        if (Class2iModemDialog( pTG,
                                (LPSTR)pTG->lpCmdTab->szPreDial,
                                swLen,
                                10000L,
                                0,
                                TRUE,
                                pTG->cbszCLASS2_OK,
                                pTG->cbszCLASS2_ERROR,
                                (C2PSTR)NULL) != 1)
        {
            DebugPrintEx(DEBUG_WRN,"Error on User's PreDial string: %s", (LPSTR)pTG->lpCmdTab->szPreDial);
        }
    }

    // If the dial string already has a T or P prefix, we use that
    // instead.
    {
        char c = 0;
        while ((c=*lpszDial) && c==' ')
        {
            lpszDial++;
        }
        if (c=='t'|| c=='T' || c=='p'|| c=='P')
        {
            chMod = c;
            lpszDial++;
            while((c=*lpszDial) && c==' ')
            {
                lpszDial++;
            }
        }
    }

    uwLen = (UWORD)wsprintf(bBuf, pTG->cbszCLASS2_DIAL,chMod, (LPSTR)lpszDial);

// Need to set an approriate timeout here. A minimum of 15secs is too short
// (experiment calling machines within a PABX), plus one has to give extra
// time for machines that pick up after 2 or 4 rings and also for long distance
// calls. I take a minumum of 30secs and add 3secs for each digits over 7
// (unless it's pulse dial in which case I add 8secs/digit).
// (I'm assuming that a long-distance call will take a minimum of 8 digits
// anywhere in ths world!). Fax machines I've tested wait about 30secs
// independent of everything.

    uwDialStringLen = (SWORD)_fstrlen(lpszDial);
    ulTimeout = DIAL_TIMEOUT;
    if (uwDialStringLen > 7)
    {
        ulTimeout += ((chMod=='p' || chMod=='P')?8000:3000) * (uwDialStringLen - 7);
    }

    // If user aborts during one of the pre-dial commands (AT+FLID, etc.),
    // that command fails, but Class2xSend continues. Therefore, check for
    // abort here.
    if(pTG->fAbortRequested)
    {
        DebugPrintEx(DEBUG_ERR,"Class2Dial aborting");
        Class2ModemHangup(pTG);
        return CONNECT_ERROR;
    }

    dwDialTime = GetTickCount();
    LogDialCommand(pTG, pTG->cbszCLASS2_DIAL, chMod, strlen(lpszDial));
    uRet = Class2iModemDialog(  pTG,
                                (LPB)bBuf,
                                uwLen,
                                ulTimeout,
                                0,
                                FALSE,
                                pTG->cbszFCON,
                                pTG->cbszCLASS2_BUSY,
                                pTG->cbszCLASS2_NOANSWER,
                                pTG->cbszCLASS2_NODIALTONE,
                                pTG->cbszCLASS2_ERROR,
                                pTG->cbszCLASS2_NOCARRIER,
                                (NPSTR)NULL);

    // If it was "ERROR", try again - maybe the predial command screwed
    // up somehow and left and ERROR hanging around?
    if (uRet == 5)
    {
        LogDialCommand(pTG, pTG->cbszCLASS2_DIAL, chMod, strlen(lpszDial));
        uRet = Class2iModemDialog(  pTG,
                                    (LPB)bBuf,
                                    uwLen,
                                    ulTimeout,
                                    0,
                                    FALSE,
                                    pTG->cbszFCON,
                                    pTG->cbszCLASS2_BUSY,
                                    pTG->cbszCLASS2_NOANSWER,
                                    pTG->cbszCLASS2_NODIALTONE,
                                    pTG->cbszCLASS2_ERROR,
                                    pTG->cbszCLASS2_NOCARRIER,
                                    (NPSTR)NULL);
    }

    switch(uRet)
    {
    case CONNECT_TIMEOUT:       if (pTG->fFoundFHNG)
                                {
                                    PSSLogEntry(PSS_ERR, 1, "Call was disconnected");
                                }
                                else
                                {
                                    PSSLogEntry(PSS_ERR, 1, "Response - timeout");
                                }
                                pTG->fFatalErrorWasSignaled = 1;
                                SignalStatusChange(pTG, FS_NO_ANSWER);
                                break;
    case CONNECT_OK:            PSSLogEntry(PSS_MSG, 1, "Response - +FCON");
                                pTG->fReceivedHDLCflags = TRUE;
                                break;
    case CONNECT_BUSY:          PSSLogEntry(PSS_ERR, 1, "Response - BUSY");
                                pTG->fFatalErrorWasSignaled = 1;
                                SignalStatusChange(pTG, FS_BUSY);
                                break;
    case CONNECT_NOANSWER:      PSSLogEntry(PSS_ERR, 1, "Response - NOANSWER");
                                pTG->fFatalErrorWasSignaled = 1;
                                SignalStatusChange(pTG, FS_NO_ANSWER);
                                break;
    case CONNECT_NODIALTONE:    PSSLogEntry(PSS_ERR, 1, "Response - NODIALTONE");
                                pTG->fFatalErrorWasSignaled = 1;
                                SignalStatusChange(pTG, FS_NO_DIAL_TONE);
                                break;
    case CONNECT_ERROR:         PSSLogEntry(PSS_ERR, 1, "Response - ERROR");
                                pTG->fFatalErrorWasSignaled = 1;
                                SignalStatusChange(pTG, FS_NO_ANSWER);
                                break;
    case 6:                     {
                                    DWORD dwDelta = GetTickCount() - dwDialTime;
                                    PSSLogEntry(PSS_ERR, 1, "Response - NO CARRIER");
                                    if (dwDelta < 5000L)
                                    {
                                        DebugPrintEx(DEBUG_WRN,"Dial: Pretending it's BUSY");
                                        pTG->fFatalErrorWasSignaled = 1;
                                        SignalStatusChange(pTG, FS_BUSY);
                                        uRet = CONNECT_BUSY;
                                    }
                                    else
                                    {
                                        DebugPrintEx(DEBUG_WRN,"Dial: Pretending it's TIMEOUT");
                                        pTG->fFatalErrorWasSignaled = 1;
                                        SignalStatusChange(pTG, FS_NO_ANSWER);
                                        uRet = CONNECT_TIMEOUT;
                                    }
                                }
                                break;

    default:                    uRet = CONNECT_ERROR;
                                break;
    }

    if (uRet != CONNECT_OK)
    {
        if (!Class2ModemHangup(pTG ))
        {
            return CONNECT_ERROR;
        }
    }

    return uRet;
}


USHORT Class2Answer(PThrdGlbl pTG)
{
    USHORT  uRet;
    SWORD   swLen;
    ULONG   ulWaitTime;

    DEBUG_FUNCTION_NAME("Class2Answer");

    // Default time we will wait after getting right number of rings
    // to allow input buffer to flush
    ulWaitTime = 500L;

    // We may still have an "OK" coming from the modem as a result of the
    // ATS1 command. We need to wait a bit and flush it. In most cases we
    // just wait 500 milliseconds. But, if we saw a 000 from the ATS1, we
    // broke immediately out of the loop above, setting ulWaitTime to be
    // the approximate wait we need before answering the phone.

    startTimeOut(pTG, &pTG->toAnswer, ulWaitTime);
    while (checkTimeOut(pTG, &pTG->toAnswer))
    {
    }
    FComFlush(pTG );

    // Send the preanswer command
    if (pTG->lpCmdTab->szPreAnswer && (swLen=(SWORD)_fstrlen(pTG->lpCmdTab->szPreAnswer)))
    {
        if (Class2iModemDialog( pTG,
                                (LPSTR)pTG->lpCmdTab->szPreAnswer,
                                swLen,
                                10000L,
                                0,
                                TRUE,
                                pTG->cbszCLASS2_OK,
                                pTG->cbszCLASS2_ERROR,
                                (C2PSTR)NULL) != 1)
        {
            DebugPrintEx(DEBUG_WRN,"Error on User's PreAnswer str: %s", (LPSTR)pTG->lpCmdTab->szPreAnswer);
        }
    }


#define ANSWER_TIMEOUT 35000
// Need to wait reasonably long, so that we don't give up too easily
// 7/25/95 JosephJ This used to be 15000. Changed to 35000 because
// MWAVE devices needed that timeout. Also, T.30 says that callee
// should try to negotiate for T1 seconds. T1 = 35 +/- 5s.

    /*
    * Send ATA command. The result will be stored in the global
    * variable pTG->lpbResponseBuf2. We will parse that in the Class2Receive
    * routine.
    */

    // Look for ERROR return first and try again if it happened
    if ((uRet = Class2iModemDialog( pTG,
                                    pTG->cbszATA,
                                    (UWORD)(strlen(pTG->cbszATA)),
                                    ANSWER_TIMEOUT,
                                    0,
                                    TRUE,
                                    pTG->cbszCLASS2_OK,
                                    pTG->cbszCLASS2_FHNG,
                                    pTG->cbszCLASS2_ERROR,
                                    (C2PSTR) NULL)) == 3)
    {
        DebugPrintEx(DEBUG_ERR,"ATA returned ERROR on first try");
        // dunno why we try this a 2nd time. But this time if we get ERROR
        // dont exit. The Racal modem (bug#1982) gives ERROR followed by a
        // good response! Cant ignore ERROR the first time otherwise we'll
        // change the ATA--ERROR--ATA(repeat) behaviour which seems to be
        // explicitly desired for some cases. However we dont take any
        // action based on the return value of the 2nd try, so it's safe to
        // ignore ERROR here. Worst case we take longer to timeout.
        uRet = Class2iModemDialog(  pTG,
                                    pTG->cbszATA,
                                    (UWORD)(strlen(pTG->cbszATA)),
                                    ANSWER_TIMEOUT,
                                    0,
                                    TRUE,
                                    pTG->cbszCLASS2_OK,
                                    pTG->cbszCLASS2_FHNG,
                                    (C2PSTR) NULL);
    }

    // Should've used Class2xParse to detect +FHNG. However, the ATA dialogs had the
    // CLASS2_FHNG reply in them before FHNG detection was implemented into
    // Class2xParse. If these answers are removed, a modem that replies "+FHNG" and
    // then nothing (no "OK") would only fail on timeout here. So, in order not to
    // cause a regression on such (hypothetical) modems, I'm keeping the CLASS2_FHNG's.
    if (uRet==2)
    {
        pTG->fFoundFHNG = TRUE;
    }

    if ((uRet != 1) || (pTG->fFoundFHNG)) // a '1' return indicates OK.
    {
        DebugPrintEx(DEBUG_ERR,"Can't get OK after ATA");
        
        PSSLogEntry(PSS_ERR, 1, "Failed to answer - this call was not a fax call");

        pTG->fFatalErrorWasSignaled = 1;
        SignalStatusChangeWithStringId(pTG, FS_RECV_NOT_FAX_CALL, IDS_RECV_NOT_FAX_CALL);

        // try to hangup and sync with modem. This should work
        // even if phone is not really off hook
        if (!Class2ModemHangup(pTG))
        {
            DebugPrintEx(DEBUG_ERR,"Can't Hangup after ANSWERFAIL");
        }
        return CONNECT_ERROR;
    }
    else
    {
        DebugPrintEx(DEBUG_MSG,"ATA Received %s",(LPSTR)(&(pTG->lpbResponseBuf2)));
        pTG->fReceivedHDLCflags = TRUE;
        return CONNECT_OK;
    }
}


SWORD Class2ModemSync(PThrdGlbl pTG)
{
    // The command used here must be guaranteed to be harmless,
    // side-effect free & non-dstructive. i.e. we can issue it
    // at any point in command mode without chnageing the state
    // of teh modem or disrupting anything.
    // ATZ does not qualify. AT does, I think.....
    SWORD ret_value;

    DEBUG_FUNCTION_NAME("Class2ModemSync");

    DebugPrintEx(DEBUG_MSG,"Calling Class2HayesSyncSpeed");
    ret_value = Class2HayesSyncSpeed(   pTG,
                                        pTG->cbszCLASS2_ATTEN,
                                        (UWORD)(strlen(pTG->cbszCLASS2_ATTEN)));
    DebugPrintEx(DEBUG_MSG,"Class2HayesSyncSpeed returned %d ", ret_value);
    return ret_value;
}


BOOL Class2ModemHangup(PThrdGlbl pTG)
{
    DEBUG_FUNCTION_NAME("Class2ModemHangup");

    PSSLogEntry(PSS_MSG, 0, "Phase E - Hang-up");
    PSSLogEntry(PSS_MSG, 1, "Hanging up");
    if (Class2HayesSyncSpeed(   pTG,
                                pTG->cbszCLASS2_HANGUP,
                                (UWORD)(strlen(pTG->cbszCLASS2_HANGUP))) < 0)
    {
        DebugPrintEx(DEBUG_WRN,"Failed once");

        FComDTR(pTG, FALSE);    // Lower DTR on stubborn hangups in ModemHangup
        Sleep(1000); // pause 1 second
        FComDTR(pTG, TRUE);     // raise it again. Some modems return to cmd state
                                // only when this is raised again

        if (Class2HayesSyncSpeed(   pTG,
                                    pTG->cbszCLASS2_HANGUP,
                                    (UWORD)(strlen(pTG->cbszCLASS2_HANGUP))) < 0)
        {
            DebugPrintEx(DEBUG_ERR,"Failed again");
            return FALSE;
        }
    }
    DebugPrintEx(DEBUG_MSG,"HANGUP Completed");

    if (!iModemGoClass(pTG, 0))
    {
        return FALSE;
    }
    // Can also ignore this return value. Just for tidier cleanup
    DebugPrintEx(DEBUG_MSG,"Completed GoClass0");

    // Bug1982: Racal modem, doesnt accept ATA. So we send it a PreAnswer
    // command of ATS0=1, i.r. turning ON autoanswer. And we ignore the
    // ERROR response it gives to the subsequent ATAs. It then answers
    // 'automatically' and gives us all the right responses. On hangup
    // however we need to send an ATS0=0 to turn auto-answer off. The
    // ExitCommand is not sent at all in Class2 and in Class1 it is only
    // sent on releasing the modem, not between calls. So send an S0=0
    // after ATH0. If the modem doesnt like it we ignore the resp anyway.
    Class2iModemDialog( pTG,
                        pTG->cbszCLASS2_CALLDONE,
                        (UWORD)(strlen(pTG->cbszCLASS2_CALLDONE)),
                        LOCALCOMMAND_TIMEOUT,
                        0,
                        TRUE,
                        pTG->cbszCLASS2_OK,
                        pTG->cbszCLASS2_ERROR,
                        (C2PSTR)NULL);
    return TRUE;
}


BOOL Class2ModemAbort(PThrdGlbl pTG)
{
    DEBUG_FUNCTION_NAME("Class2ModemAbort");

    // If modem already reported +FHNG, no need telling it to abort
    if (!pTG->fFoundFHNG)
    {
        // Try to abort modem in reasonable fashion - send the
        // abort command and then send hangup. The abort command
        // should hangup, but I am not convinced it always does!!!
        // It should not hurt to hang up again (I hope).
        // We'll use a long timeout here to let the abort take place.
        if (!Class2iModemDialog(pTG,
                                pTG->cbszCLASS2_ABORT,
                                (UWORD)(strlen(pTG->cbszCLASS2_ABORT)),
                                STARTSENDMODE_TIMEOUT,
                                1,
                                TRUE,
                                pTG->cbszCLASS2_OK,
                                pTG->cbszCLASS2_ERROR,
                                (C2PSTR) NULL))
        {
            //Ignore failure
            DebugPrintEx(DEBUG_ERR,"FK Failed");
        }
    }

    return Class2ModemHangup(pTG );
}



SWORD Class2HayesSyncSpeed(PThrdGlbl pTG, C2PSTR cbszCommand, UWORD uwLen)
{
    /*
    Internal routine to synchronize with the modem's speed.  Tries to
    get a response from the modem by trying the speeds in rglSpeeds
    in order (terminated by a 0).  If fTryCurrent is nonzero, checks for
    a response before trying to reset the speeds.

    Returns the speed it found, 0 if they're in sync upon entry (only
    checked if fTryCurrent!=0), or -1 if it couldn't sync.
    */
    short ilWhich = 0;

    DEBUG_FUNCTION_NAME("Class2HayesSyncSpeed");

    for(;;)
    {
        if (Class2SyncModemDialog(pTG,cbszCommand,uwLen,pTG->cbszCLASS2_OK))
        {
            return (ilWhich>=0 ? rguwClass2Speeds[ilWhich] : 0);
        }

        /* failed.  try next speed. */
        if (rguwClass2Speeds[++ilWhich]==0)
        {
            // Tried all speeds. No response
            DebugPrintEx(DEBUG_ERR,"Cannot Sync with Modem on Command %s", (LPSTR)cbszCommand);
            return -1;
        }
        if (!FComSetBaudRate(pTG,  rguwClass2Speeds[ilWhich]))
        {
            return -1;
        }
    }
}



USHORT  Class2ModemRecvBuf(PThrdGlbl pTG, LPBUFFER far* lplpbf, USHORT uTimeout)
{
    USHORT uRet;

    DEBUG_FUNCTION_NAME("Class2ModemRecvBuf");

    *lplpbf = MyAllocBuf(pTG, MY_BIGBUF_SIZE);
    if (*lplpbf == NULL)
    {
        DebugPrintEx(DEBUG_ERR, "MyAllocBuf failed trying to allocate %d bytes", MY_BIGBUF_SIZE);
        return RECV_OUTOFMEMORY;
    }

    uRet = Class2ModemRecvData( pTG,
                                (*lplpbf)->lpbBegBuf,
                                (*lplpbf)->wLengthBuf,
                                uTimeout,
                                &((*lplpbf)->wLengthData));

    if  (!((*lplpbf)->wLengthData))
    {
        MyFreeBuf(pTG, *lplpbf);
        *lplpbf = NULL;
    }
    else
    {
        // If necessary, bit-reverse...
        if (pTG->CurrentMFRSpec.fSWFBOR && pTG->CurrentMFRSpec.iReceiveBOR==1)
        {
            DebugPrintEx(DEBUG_WRN,"SWFBOR Enabled. bit-reversing data");
            cl2_flip_bytes( (*lplpbf)->lpbBegBuf, ((*lplpbf)->wLengthData));
        }
    }

    return uRet;
}


USHORT Class2ModemRecvData(PThrdGlbl pTG, LPB lpb, USHORT cbMax, USHORT uTimeout, USHORT far* lpcbRecv)
{
    SWORD   swEOF;

    startTimeOut(pTG, &pTG->toRecv, uTimeout);
    // 4th arg must be TRUE for Class2
    *lpcbRecv = FComFilterReadBuf(pTG, lpb, cbMax, &pTG->toRecv, TRUE, &swEOF);

    switch(swEOF)
    {
    case 1:         // Class1 eof
    case -1:        // Class2 eof
                    return RECV_EOF;
    case 0:
                    return RECV_OK;
    default:
                    // fall through
    case -2:
                    return RECV_ERROR;
    case -3:
                    return RECV_TIMEOUT;
    }
}


BOOL  Class2ModemSendMem(PThrdGlbl pTG, LPBYTE lpb, USHORT uCount)
{
    DEBUG_FUNCTION_NAME("Class2ModemSendMem");

    if (!FComFilterAsyncWrite(pTG, lpb, uCount, FILTER_DLEZERO))
    {
        goto error;
    }

    return TRUE;

error:
    DebugPrintEx(DEBUG_ERR,"Failed on AsyncWrite");
    FComOutFilterClose(pTG);
    FComXon(pTG, FALSE);
    return FALSE;
}

/*
output:
0 - timeout
1 - OK
2 - ERROR
*/
DWORD Class2ModemDrain(PThrdGlbl pTG)
{
    DWORD dwResult = 0;
    DEBUG_FUNCTION_NAME("Class2ModemDrain");

    if (!FComDrain(pTG, TRUE, TRUE))
    {
        return FALSE;
    }

    // Must turn XON/XOFF off immediately *after* drain, but before we
    // send the next AT command, since Received frames have 0x13 or
    // even 0x11 in them!! MUST GO AFTER the getOK ---- See BELOW!!!!

    dwResult = Class2iModemDialog(pTG,
                                  NULL,
                                  0,
                                  STARTSENDMODE_TIMEOUT,
                                  0,
                                  TRUE,
                                  pTG->cbszCLASS2_OK,
                                  pTG->cbszCLASS2_ERROR,
                                  (C2PSTR)NULL);
    // Must change FlowControl State *after* getting OK because in Windows
    // this call takes 500 ms & resets chips, blows away data etc.
    // So do this *only* when you *know* both RX & TX are empty.

    // Turn off flow control.
    FComXon(pTG, FALSE);

    // FComDrain doesn't check for abort, and the dialog might succeed because of that
    // Therefore, check for it here.
    if (pTG->fAbortRequested)
    {
        return 0;   // timeout
    }

    return dwResult;
}


#define ABORT_TIMEOUT    250

UWORD Class2iModemDialog
(
    PThrdGlbl pTG,
    LPSTR szSend,
    UWORD uwLen,
    ULONG ulTimeout,
    UWORD uwRepeatCount,
    BOOL fLogSend,
    ...
)
{
/** Takes a command string, and it's lengt writes it out to the modem
    and tries to get one of the allowed responses. It writes the command
        out, waits ulTimeOut millisecs for a response. If it gets one of the
        expected responses it returns immediately.

        If it gets an unexpected/illegal response it tries (without any
        waiting) for subsequent lines to the same response.     When all the
        lines (if > 1) of the response lines are exhausted, if none is among the
        expected responses, it writes the command again and tries again,
        until ulTimeout has expired. Note that if no response is received,
        the command will be written just once.

        The whole above thing will be repeated upto uwRepeatCount times
        if uwRepeatCount is non-zero

<<<<<NOTE:::uwRepeatCount != 0 should not be used except for local sync>>>>>

        It returns when (a) one of the specified responses is received or
        (b) uwRepeatCount tries have failed (each having returned an
        illegal response or having returned no response in ulTimeout
        millsecs) or (c) the command write failed, in which
        case it returns immediately.

        It flushes the modem inque before each Command Write.

        Returns 0 on failure and the 1 based index of the successful
        response on     success.

        This can be used in the following way:-

        for Local Dialogs (AT, AT+FTH=? etc), set ulTimeout to a lowish
        value, of the order of the transmission time of the longest
        possible (erroneous or correct) line of response plus the size
        of the command. eg. at 1200baud we have about 120cps = about
        10ms/char. Therefore a timeout of about 500ms is more than
        adequate, except for really long command lines.

        for Local Sync dialogs, used to sync up with the modem which may
        be in an unsure state, use the same timeout, but also a repeat
        count of 2 or 3.

        for remote-driven dialogs, eg. AT+FRH=xx which returns a CONNECT
        after the flags have been received, and which may incur a delay
        before a response (ATDT is teh same. CONNECT is issued after a
        long delay & anything the DTE sends will abort the process).
        For these cases the caller should supply a long timeout and
        probably a repeatcount of 1, so that the
        routine will timeout after one try but go on issuing teh command
        as long as an error repsonse is received.

        For +FRH etc, the long timeout should be T1 or T2 in teh case of
        CommandRecv and ResponseRecv respectively.

**/
    BYTE bReply[REPLYBUFSIZE];
    UWORD   i, j, uwRet, uwWantCount;
    SWORD   swNumRead;
    C2PSTR  rgcbszWant[10] = {NULL};
    va_list args;
    LPTO    lpto, lptoRead, lpto0;

    DEBUG_FUNCTION_NAME("Class2iModemDialog");
    // extract the (variable length) list of acceptable responses.
    // each is a C2SZ, code based 2 byte ptr

    va_start(args, fLogSend);  // Ansi Defintion

    for(j=1; j<10; j++)
    {
        if((rgcbszWant[j] = va_arg(args, C2PSTR)) == NULL)
        {
            break;
        }
    }
    uwWantCount = j-1;
    va_end(args);

    pTG->lpbResponseBuf2[0] = 0;

    lpto = &pTG->toDialog;
    lpto0 = &pTG->toZero;
    // Try the dialog upto uwRepeatCount times
    for (uwRet=0, i=0; i<=uwRepeatCount; i++)
    {
        startTimeOut(pTG, lpto, ulTimeout);
        do
        {
            if(szSend)
            {
                // If a command is supplied, write it out, flushing input
                // first to get rid of spurious input.

                // FComInputFlush();
                FComFlush(pTG);            // Need to flush output too?

                if (fLogSend)
                {
                    PSSLogEntry(PSS_MSG, 2, "send: \"%s\"", szSend);
                }

                // Need to check that we are sending only ASCII or pre-stuffed data here
                if (!FComDirectSyncWriteFast(pTG,  szSend, uwLen))
                {
                    DebugPrintEx(DEBUG_ERR,"Modem Dialog Write timed Out");
                    uwRet = 0;
                    goto done;
                    // If Write fails, fail & return immediately.
                    // SetMyError() will already have been called.
                }
            }

            for (lptoRead=lpto;;startTimeOut(pTG, lpto0, ulTimeout), lptoRead=lpto0)
            {
                // get a CR-LF terminated line
                // for the first line use macro timeout, for multi-line
                // responses use 0 timeout.

                swNumRead = FComFilterReadLine(pTG, bReply, REPLYBUFSIZE-1, lptoRead);
                if(swNumRead < 0)
                {
                    swNumRead = (-swNumRead);       // error-but lets see what we got anyway
                }
                else if (swNumRead == 0)
                {
                    goto timeout;                          // Timeout -- restart dialog or exit
                }
                if (swNumRead == 2 && bReply[0] == '\r' && bReply[1] == '\n')
                {
                    continue;                                       // blank line -- throw away & get another
                }

                // COPIED THIS FROM DUP FUNCTION IN MODEM.C!!
                // Fix Bug#1226. Elsa Microlink returns this garbage line in
                // response to AT+FDIS?, followed by the real reply. Since
                // we only look at the first line, we see only this garbage line
                // and we never see the real reply
                if (swNumRead==3 && bReply[0]==0x13 && bReply[1]=='\r' && bReply[2]=='\n')
                {
                    continue;
                }

                PSSLogEntry(PSS_MSG, 2, "recv:     \"%s\"", bReply);

                for(bReply[REPLYBUFSIZE-1]=0, j=0; j<=uwWantCount; j++)
                {
                    if( rgcbszWant[j] && (strstr(bReply, rgcbszWant[j]) != NULL))
                    {
                        uwRet = j;
                        // It matched!!!
                        // Save this reply. This is used when checking
                        // ATS1 responses
                        goto end;
                    }
                }
                // go to ulTimeout check. i.e. *don't* set fTimedOut
                // but don't exit either. Retry command and response until
                // timeout

                // We reach here it IFF we got a non blank reply, but it wasn't what
                // we wanted. Squirrel teh first line away somewhere so that we can
                // retrieve is later. We use this hack to get multi-line informational
                // responses to things like +FTH=? Very important to ensure that
                // blank-line replies don't get recorded here. (They may override
                // the preceding line that we need!).

                if ( (strlen(pTG->lpbResponseBuf2) + strlen(bReply) ) < RESPONSE_BUF_SIZE)
                {
                    strncat(pTG->lpbResponseBuf2, bReply, (ARR_SIZE(pTG->lpbResponseBuf2) - strlen(pTG->lpbResponseBuf2) -1));
                }
                else
                {
                    DebugPrintEx(DEBUG_ERR,"Response too long!");
                    uwRet = 0;
                    goto end;
                }

                // If +FHNG was received, an OK should follow.
                if (strstr(bReply, pTG->cbszCLASS2_FHNG) != NULL)
                {
                    UWORD uwAns;

                    // Check whether OK is already on the responses list
                    for (uwAns=1; uwAns<=uwWantCount; uwAns++)
                    {
                        if (strstr(rgcbszWant[uwAns], pTG->cbszCLASS2_OK) != NULL)
                        {
                            break;
                        }
                    }

                    if (uwAns > uwWantCount)
                    {
                        // OK is not on the list, add it as response #0. When the OK
                        // comes, the dialog will terminate with response 0, and the caller
                        // will know that the dialog failed.
                        DebugPrintEx(DEBUG_MSG, "FHNG found during dialog, adding OK to want list");
                        rgcbszWant[0] = pTG->cbszCLASS2_OK;
                    }
                    else
                    {
                        // OK is already on the wanted responses list, don't add anything. The
                        // dialog will succeed with the original OK response, and the caller can
                        // explicitely check pTG->fFoundFHNG
                        DebugPrintEx(DEBUG_MSG, "FHNG found during dialog, OK already on want list");
                    }
                }
            }   // end of loop that reads lines until timeout
            // we come here only on timeout.
        } while (checkTimeOut(pTG, lpto));

timeout:
        PSSLogEntryStrings(PSS_WRN, 2, &rgcbszWant[1], uwWantCount,
                "failed to receive expected response: ");
        // Need to send anychar to abort the previous command. Use "AT"
        PSSLogEntry(PSS_MSG, 2, "send: \"AT\"");
        FComFlush(pTG); // flush first--don't want some old garbage result
        FComDirectSyncWriteFast(pTG, "\rAT", 3);
        FComFlushInput(pTG); // flush input again
        FComDirectAsyncWrite(pTG, "\r", 1);
        startTimeOut(pTG, lpto0, ABORT_TIMEOUT);
        do
        {
            swNumRead = FComFilterReadLine(pTG, bReply, REPLYBUFSIZE-1, lpto0);
        }
        while(swNumRead==2 && bReply[0]=='\r'&& bReply[1]=='\n');
        // While we get a blank line. Get another.
        bReply[REPLYBUFSIZE-1] = 0;
        if (swNumRead != 0)
        {
            PSSLogEntry(PSS_MSG, 2, "recv:     \"%s\"", bReply);
        }
    }  // for i=0..RepeatCount

end:
    if (uwRet == 0)
    {
        DebugPrintEx(   DEBUG_ERR,
                        "(%s) --> (%d)(%s, etc) Failed",
                        (LPSTR)(szSend?szSend:"null"),
                        uwWantCount,
                        (LPSTR)rgcbszWant[1]);
    }
    else
    {
        DebugPrintEx(DEBUG_MSG,"GOT IT %d (%s)", uwRet, (LPSTR)(rgcbszWant[uwRet]));
    }

done:
    // Parse modem notifications into pTG->class2_commands
    if (pTG->ModemClass == MODEM_CLASS2)
    {
       Class2Parse(pTG,  &pTG->class2_commands, pTG->lpbResponseBuf2 );
    }
    else
    {
       Class20Parse(pTG,  &pTG->class2_commands, pTG->lpbResponseBuf2 );
    }

    return uwRet;
}


/* Converts the code for a speed to the speed in BPS */
// These are in the same order as the return values
// for DIS/DCS frames defined in the Class 2 spec in
// Table 8.4


/* Converts a DCS min-scan field code into millisecs */
// One array is for normal (100 dpi) res, the other for high (200 dpi) res...
// The ordering of the arraies is based on the values that
// are defined in filet30.h - THEY ARE NOT THE SAME AS THE VALUES
// RETURNED IN THE DCS FRAME!!!! This is inconsistent with baud rate
// but it is consistent with the Class 1 code...
BYTE msPerLineNormalRes[8] = { 20, 5, 10, 20, 40, 40, 10, 0 };
BYTE msPerLineHighRes[8] =   { 20, 5, 10, 10, 40, 20, 5, 0 };





USHORT Class2MinScanToBytesPerLine(PThrdGlbl pTG, BYTE Minscan, BYTE Baud, BYTE Resolution)
{
    USHORT uStuff;
    BYTE ms;

    DEBUG_FUNCTION_NAME("Class2MinScanToBytesPerLine");

    uStuff = Class2CodeToBPS[Baud];
    if ( Resolution & AWRES_mm080_077)
    {
        ms = msPerLineHighRes[Minscan];
    }
    else
    {
        ms = msPerLineNormalRes[Minscan];
    }
    uStuff /= 100;          // StuffBytes = (BPS * ms)/8000
    uStuff *= ms;           // take care not to use longs
    uStuff /= 80;           // or overflow WORD or lose precision
    uStuff += 1;            // Rough fix for truncation problems

    DebugPrintEx(DEBUG_MSG,"Stuffing %d bytes", uStuff);
    return uStuff;
}

// Convert the SEND_CAPS or SEND_PARAMS BC structure into values used by
// the +FDCC, +FDIS, and +FDT commands



void Class2SetDIS_DCSParams
(
    PThrdGlbl pTG,
    BCTYPE bctype,
    OUT LPUWORD Encoding,
    OUT LPUWORD Resolution,
    OUT LPUWORD PageWidth,
    OUT LPUWORD PageLength,
    OUT LPSTR szID,
	IN UINT cch
)
{
    LPBC lpbc;

    DEBUG_FUNCTION_NAME("Class2SetDIS_DCSParams");

    DebugPrintEx(DEBUG_MSG,"Type = %d", (USHORT)bctype);

    if (bctype == SEND_PARAMS)
    {
        lpbc = (LPBC)&pTG->bcSendParams;
    }
    else
    {
        lpbc = (LPBC)&pTG->bcSendCaps;
    }

    if (pTG->LocalID)
    {
		HRESULT hr = StringCchCopy(szID,cch,pTG->LocalID);
		if (FAILED(hr))
		{
			// we failed, nothing to do other than debug print.
			// the OUT param is null terminated.
			DebugPrintEx(DEBUG_WRN,"StringCchCopy failed (ec=0x%08X)",hr);
		}
    }

    switch(lpbc->Fax.Encoding)
    {
    case MH_DATA:                           *Encoding = 0;
                                            break;
    case MR_DATA:
    case (MR_DATA | MH_DATA):               *Encoding = 1;
                                            break;
    case MMR_DATA:
    case (MMR_DATA | MH_DATA):
    case (MMR_DATA | MR_DATA):
    case (MMR_DATA | MR_DATA | MH_DATA):    *Encoding = 3;
                                            break;

    default:                                DebugPrintEx(DEBUG_ERR,"Bad Encoding type %x",lpbc->Fax.Encoding);
                                            break;
    }

    if ( (lpbc->Fax.AwRes) & AWRES_mm080_077)
    {
        *Resolution = 1;
    }
    else if ( (lpbc->Fax.AwRes) & AWRES_mm080_038)
    {
        *Resolution = 0;
    }
    else
    {
        DebugPrintEx(DEBUG_ERR,"Bad Resolution type %x",lpbc->Fax.AwRes);
    }

    switch (lpbc->Fax.PageWidth & 0x3)
    {
    case WIDTH_A4:      // 1728 pixels
                        *PageWidth = 0;
                        break;
    case WIDTH_B4:      // 2048 pixels
                        *PageWidth = 1;
                        break;
    case WIDTH_A3:      // 2432 pixels
                        *PageWidth = 2;
                        break;
    default:            DebugPrintEx(DEBUG_ERR,"Bad PageWidth type %x", lpbc->Fax.PageWidth);
                        break;
    }

    switch(lpbc->Fax.PageLength)
    {
    case LENGTH_A4:         *PageLength = 0;
                            break;
    case LENGTH_B4:         *PageLength = 1;
                            break;
    case LENGTH_UNLIMITED:  *PageLength = 2;
                            break;
    default:                DebugPrintEx(DEBUG_ERR,"Bad PageLength type %x", lpbc->Fax.PageLength);
                            break;
    }
}


/*++
Routine Description:
    Copies a string, removing leading and trailing spaces

Arguments:
    pszDest         [out]    Pointer to buffer that will accept output string.
    cchDest         [in]     Size of pszDest, in chars
    pszSrc          [in/out] Pointer to source string
                             Warning: This function changes pszSrc.
Return Value:
    Success / Error in HRESULT form
--*/

HRESULT Class2CopyID(LPSTR pszDest, size_t cchDest, LPSTR pszSrc)
{
    int iFirst;
    int iLast;

    for (iFirst=0; pszSrc[iFirst]==' '; iFirst++)
        ;
    for (iLast=strlen(pszSrc)-1; iLast >= iFirst && pszSrc[iLast]==' '; iLast--)
        ;
    pszSrc[iLast+1] = '\0';
    return StringCchCopy(pszDest, cchDest, &(pszSrc[iFirst]));
}


BOOL Class2ResponseAction(PThrdGlbl pTG, LPPCB lpPcb)
{
    USHORT count;
    BOOL   fFoundDIS_DCS;
    HRESULT hr;

    DEBUG_FUNCTION_NAME("Class2ResponseAction");

    fFoundDIS_DCS = FALSE;

    _fmemset(lpPcb, 0, sizeof(PCB));

    // Even though Class2iModemDialog calls Class2XParse, we need to call
    // it again, because main function may change pTG->lpbResponseBuf2.
    if (pTG->ModemClass == MODEM_CLASS2)
    {
       Class2Parse(pTG,  &pTG->class2_commands, pTG->lpbResponseBuf2 );
    }
    else
    {
       Class20Parse(pTG,  &pTG->class2_commands, pTG->lpbResponseBuf2 );
    }


    DebugPrintEx(   DEBUG_MSG,
                    "Number of commands is %d",
                    pTG->class2_commands.comm_count);
    for (count=0; count < pTG->class2_commands.comm_count; ++count)
    {
        switch (pTG->class2_commands.command[count])
        {
            case  CL2DCE_FDIS:
            case  CL2DCE_FDCS:

                    DebugPrintEx(DEBUG_MSG,"Found DCS or DIS");
                    fFoundDIS_DCS = TRUE;
                    //  Assign resolution.
                    if( pTG->class2_commands.parameters[count][0] == 0)
                    {
                        lpPcb->Resolution = AWRES_mm080_038;
                        DebugPrintEx(DEBUG_MSG,"Normal resolution");
                    }
                    else if (pTG->class2_commands.parameters[count][0] & 1 )
                    {
                        // Resolution when reported by a DIS frame indicates
                        // it accepts either fine or normal. When reported
                        // in a DCS, it means the negotiated value is FINE.
                        if (pTG->class2_commands.command[count] == CL2DCE_FDIS)
                        {
                            // we received a DIS
                            lpPcb->Resolution = AWRES_mm080_038 | AWRES_mm080_077;
                            DebugPrintEx(DEBUG_MSG,"Normal & Fine resolution");
                        }
                        else
                        {
                            // we received a DCS
                            lpPcb->Resolution = AWRES_mm080_077;
                            DebugPrintEx(DEBUG_MSG,"Fine resolution");
                        }
                    }
                    else
                    {
                        DebugPrintEx(DEBUG_MSG,"Fall through - Fine resolution");
                        lpPcb->Resolution = AWRES_mm080_077;
                    }

                    //  Assign encoding scheme.
                    if( pTG->class2_commands.parameters[count][4] == 0)
                    {
                        lpPcb->Encoding = MH_DATA;
                        DebugPrintEx(DEBUG_MSG,"MH Encoding");
                    }
                    else if ((pTG->class2_commands.parameters[count][4] == 1) ||
                             (pTG->class2_commands.parameters[count][4] == 2) ||
                             (pTG->class2_commands.parameters[count][4] == 3) )
                    {
                        lpPcb->Encoding = MH_DATA | MR_DATA;
                        DebugPrintEx(DEBUG_MSG,"MR Encoding");
                    }
                    else
                    {
                        DebugPrintEx(DEBUG_ERR,"Failed to assign encoding");
                        return FALSE;
                    }

                    //  Assign page width.
                    if( pTG->class2_commands.parameters[count][2] == 0)
                    {
                        lpPcb->PageWidth = WIDTH_A4;
                        DebugPrintEx(DEBUG_MSG,"A4 Width");
                    }
                    else if (pTG->class2_commands.parameters[count][2] == 1)
                    {
                        lpPcb->PageWidth = WIDTH_B4;
                        DebugPrintEx(DEBUG_MSG,"B4 Width");
                    }
                    else if (pTG->class2_commands.parameters[count][2] == 2)
                    {
                        lpPcb->PageWidth = WIDTH_A3;
                        DebugPrintEx(DEBUG_MSG,"A3 Width");
                    }
                    // We don't support 3 and 4 (A5, A6)
                    // but we'll still allow them and map them to A4
                    // This is for Elliot bug #1252 - it should have
                    // no deleterious effect, since this width field
                    // is not used for anything at the point in where
                    // bug 1252 occurs. FrankFi
                    else if (pTG->class2_commands.parameters[count][2] == 3)
                    {
                        lpPcb->PageWidth = WIDTH_A4;
                        DebugPrintEx(DEBUG_MSG,"A4 Width - we don't support A5");
                    }
                    else if (pTG->class2_commands.parameters[count][2] == 4)
                    {
                        lpPcb->PageWidth = WIDTH_A4;
                        DebugPrintEx(DEBUG_MSG,"A4 Width - we don't support A6");
                    }
                    else
                    {
                        DebugPrintEx(DEBUG_ERR,"Failed to assign width");
                        return FALSE;
                    }

                    //  Assign page length.
                    if( pTG->class2_commands.parameters[count][3] == 0)
                    {
                        lpPcb->PageLength = LENGTH_A4;
                        DebugPrintEx(DEBUG_MSG,"A4 Length");
                    }
                    else if (pTG->class2_commands.parameters[count][3] == 1)
                    {
                        lpPcb->PageLength = LENGTH_B4;
                        DebugPrintEx(DEBUG_MSG,"B4 Length");
                    }
                    else if (pTG->class2_commands.parameters[count][3] == 2)
                    {
                        lpPcb->PageLength = LENGTH_UNLIMITED;
                        DebugPrintEx(DEBUG_MSG,"Unlimited Length");
                    }
                    else
                    {
                        DebugPrintEx(DEBUG_ERR,"Invalid length");
                        // assume it is unlimited! Some modems
                        // screw up on length.
                        lpPcb->PageLength = LENGTH_UNLIMITED;
                    }

                    //  Assign baud rate
                    //  For now, we will use the raw numbers returned in the
                    //  DCS command. Dangerous - should fix later!
                    //  These numbers will be tied to the baud rate array in
                    //  the routine that figures out zero byte stuffing from
                    //  the scan line and baud rate.

                    // Fixed the Hack--added a Baud field
                    lpPcb->Baud = pTG->class2_commands.parameters[count][1];
                    if (lpPcb->Baud > CLASS2_MAX_CODE_TO_BPS)
                    {
                        DebugPrintEx(DEBUG_WRN, "Invalid baud rate %d, will be regarded as %d",
                                lpPcb->Baud, CLASS2_MAX_CODE_TO_BPS);
                        lpPcb->Baud = CLASS2_MAX_CODE_TO_BPS;
                    }

                    //  Assign minimum scan time - the first number
                    //  in the MINSCAN_num_num_num constant
                    //  refers to scan time in ms for 100dpi, the
                    //  second for 200dpi, and the last for 400dpi
                    //  Class 2 does not use the 400dpi number,
                    //  but these variables are shared with Class 1
                    if( pTG->class2_commands.parameters[count][7] == 0)
                    {
                        lpPcb->MinScan = MINSCAN_0_0_0;
                    }
                    else if (pTG->class2_commands.parameters[count][7] == 1)
                    {
                        lpPcb->MinScan = MINSCAN_5_5_5;
                    }
                    else if (pTG->class2_commands.parameters[count][7] == 2)
                    {
                        lpPcb->MinScan = MINSCAN_10_5_5;
                    }
                    else if (pTG->class2_commands.parameters[count][7] == 3)
                    {
                        lpPcb->MinScan = MINSCAN_10_10_10;
                    }
                    else if (pTG->class2_commands.parameters[count][7] == 4)
                    {
                        lpPcb->MinScan = MINSCAN_20_10_10;
                    }
                    else if (pTG->class2_commands.parameters[count][7] == 5)
                    {
                        lpPcb->MinScan = MINSCAN_20_20_20;
                    }
                    else if (pTG->class2_commands.parameters[count][7] == 6)
                    {
                        lpPcb->MinScan = MINSCAN_40_20_20;
                    }
                    else if (pTG->class2_commands.parameters[count][7] == 7)
                    {
                        lpPcb->MinScan = MINSCAN_40_40_40;
                    }

                    break;

            case  CL2DCE_FCSI:
            case  CL2DCE_FTSI:
            		hr = Class2CopyID(lpPcb->szID, ARR_SIZE(lpPcb->szID), pTG->class2_commands.parameters[count]);
            		if (FAILED(hr))
            		{
            			DebugPrintEx(DEBUG_WRN,"Class2CopyID failed (ec=0x%08X)",hr);
            		}

                    // prepare CSID for logging by FaxSvc

                    pTG->RemoteID = AnsiStringToUnicodeString(lpPcb->szID);
                    if (pTG->RemoteID)
                    {
                        pTG->fRemoteIdAvail = 1;
                    }
                    break;
            default:
                    break;
        }
    }

    return fFoundDIS_DCS;
}

USHORT Class2EndPageResponseAction(PThrdGlbl pTG)
{
    USHORT csi_count = 0,count;

    DEBUG_FUNCTION_NAME("Class2EndPageResponseAction");

    for(count=0; count < pTG->class2_commands.comm_count; ++count)
    {
        switch (pTG->class2_commands.command[count])
        {
        case CL2DCE_FET:
            switch (pTG->class2_commands.parameters[count][0])
            {
            case 0:  PSSLogEntry(PSS_MSG, 1, "Received MPS");
                     DebugPrintEx(DEBUG_MSG,"More pages coming");
                     return MORE_PAGES;
            case 1:  PSSLogEntry(PSS_MSG, 1, "Received EOM");
                     DebugPrintEx(DEBUG_MSG,"More pages coming");
                     return MORE_PAGES;
            case 2:  PSSLogEntry(PSS_MSG, 1, "Received EOP");
                     DebugPrintEx(DEBUG_MSG,"No more pages coming");
                     return NO_MORE_PAGES;
            default: PSSLogEntry(PSS_MSG, 1, "Received unknown response");
                     DebugPrintEx(DEBUG_MSG,"No more pages coming");
                     return NO_MORE_PAGES;
            }
            break;
        case CL2DCE_FPTS:
            pTG->FPTSreport = pTG->class2_commands.parameters[count][0];
            DebugPrintEx(DEBUG_MSG, "FPTS returned %d", pTG->FPTSreport);
            break;
        }
    }
    return FALSE;
}


extern DWORD PageWidthInPixelsFromDCS[];

/*++
Routine Description:
    Update pTG->TiffInfo according to lpPcb.

Arguments:
    lpPcb - last received DCS, in PCB format

Return Value:
    TRUE for success, FALSE for failure.
--*/
BOOL Class2UpdateTiffInfo(PThrdGlbl pTG, LPPCB lpPcb)
{
    DEBUG_FUNCTION_NAME("Class2UpdateTiffInfo");
    if (!lpPcb)
    {
        DebugPrintEx(DEBUG_WRN, "lpPcb==NULL");
        return FALSE;
    }
    if (lpPcb->PageWidth >= 4)      // PageWidthInPixelsFromDCS has 4 entries
    {
        DebugPrintEx(DEBUG_WRN, "Unsupported PageWidth %d", lpPcb->PageWidth);
        return FALSE;
    }
    pTG->TiffInfo.ImageWidth = PageWidthInPixelsFromDCS[lpPcb->PageWidth];
    pTG->TiffInfo.YResolution = (lpPcb->Resolution & (AWRES_mm080_077 |  AWRES_200_200)) ?
        TIFFF_RES_Y : TIFFF_RES_Y_DRAFT;
    pTG->TiffInfo.CompressionType = (lpPcb->Encoding & MR_DATA) ? TIFF_COMPRESSION_MR : TIFF_COMPRESSION_MH;
    return TRUE;
}


/*++
Routine Description:
    Checks whether received DCS (in PCB format) is valid. Currently, only verifies width

Arguments:
    lpPcb - last received DCS, in PCB format

Return Value:
    TRUE for valid, FALSE for invalid.
--*/
BOOL Class2IsValidDCS(LPPCB lpPcb)
{
    DEBUG_FUNCTION_NAME("Class2IsValidDCS");
    if (!lpPcb)
    {
        DebugPrintEx(DEBUG_WRN, "lpPcb==NULL");
        return FALSE;
    }
    if (lpPcb->PageWidth != WIDTH_A4)      // We currently support only A4
    {
        DebugPrintEx(DEBUG_WRN, "Unsupported PageWidth %d", lpPcb->PageWidth);
        return FALSE;
    }
    return TRUE;
}


void Class2InitBC(PThrdGlbl pTG, LPBC lpbc, USHORT uSize, BCTYPE bctype)
{
        _fmemset(lpbc, 0, uSize);
        lpbc->bctype = bctype;
        lpbc->wBCSize = sizeof(BC);
        lpbc->wTotalSize = sizeof(BC);

/**
        lpbc->Fax.AwRes = (AWRES_mm080_038 | AWRES_mm080_077 | AWRES_200_200 | AWRES_300_300);
        lpbc->Fax.Encoding   = MH_DATA;    // ENCODE_ALL eventually!
        lpbc->Fax.PageWidth  = WIDTH_A4;
        lpbc->Fax.PageLength = LENGTH_UNLIMITED;
        lpbc->Fax.MinScan    = MINSCAN_0_0_0;
**/

}

void Class2PCBtoBC(PThrdGlbl pTG, LPBC lpbc, USHORT uMaxSize, LPPCB lppcb)
{
    lpbc->Fax.AwRes         = lppcb->Resolution;
    lpbc->Fax.Encoding      = lppcb->Encoding;
    lpbc->Fax.PageWidth     = lppcb->PageWidth;
    lpbc->Fax.PageLength    = lppcb->PageLength;
}

BOOL Class2GetBC(PThrdGlbl pTG, BCTYPE bctype)
{
    USHORT  uLen;
    LPBC    lpbc;

    DEBUG_FUNCTION_NAME("Class2GetBC");

    if(bctype == BC_NONE)
    {
        DebugPrintEx(DEBUG_MSG,"entering, type = BC_NONE");
        Class2InitBC(pTG, (LPBC)&pTG->bcSendCaps, sizeof(pTG->bcSendCaps), SEND_CAPS);
        pTG->bcSendCaps.Fax.AwRes      = (AWRES_mm080_038 | AWRES_mm080_077);
        pTG->bcSendCaps.Fax.Encoding   = MH_DATA;
        pTG->bcSendCaps.Fax.PageWidth  = WIDTH_A4;
        pTG->bcSendCaps.Fax.PageLength = LENGTH_UNLIMITED;
        return TRUE;
    }

    if(!(lpbc = ICommGetBC(pTG, bctype)))
    {
        return FALSE;
    }

    DebugPrintEx(DEBUG_MSG, "Class2GetBC: entering, type = %d\n\r", bctype);
    DebugPrintEx(DEBUG_MSG, "Some params: encoding = %d, res = %d\n\r", lpbc->Fax.Encoding, lpbc->Fax.AwRes);

    // Depending on the type, pick the correct global BC structure

    if (bctype == SEND_CAPS)
    {
        uLen = min(sizeof(pTG->bcSendCaps), lpbc->wTotalSize);
        _fmemcpy(&pTG->bcSendCaps, lpbc, uLen);
        return TRUE;
    }
    else if (bctype == SEND_PARAMS)
    {
        uLen = min(sizeof(pTG->bcSendParams), lpbc->wTotalSize);
        _fmemcpy(&pTG->bcSendParams, lpbc, uLen);
        return TRUE;
    }
    else
    {
        return FALSE;
    }
}

BOOL Class2SetProtParams(PThrdGlbl pTG, LPPROTPARAMS lp)
{
    DEBUG_FUNCTION_NAME("Class2SetProtParams");

    pTG->ProtParams2 = *lp;

    DebugPrintEx(   DEBUG_MSG,
                    "Set Class2ProtParams: fV17Send=%d fV17Recv=%d uMinScan=%d",
                    " HighestSend=%d LowestSend=%d",
                    pTG->ProtParams2.fEnableV17Send,
                    pTG->ProtParams2.fEnableV17Recv,
                    pTG->ProtParams2.uMinScan,
                    pTG->ProtParams2.HighestSendSpeed,
                    pTG->ProtParams2.LowestSendSpeed);

    return TRUE;
}

void iNCUParamsReset(PThrdGlbl pTG)
{
    _fmemset(&pTG->NCUParams2, 0, sizeof(pTG->NCUParams2));
    pTG->lpCmdTab = 0;

    pTG->NCUParams2.uSize = sizeof(pTG->NCUParams2);
    // These are used to set S regs etc.
    // -1 means leave modem at default
    pTG->NCUParams2.DialPauseTime   = -1;
    // pTG->NCUParams2.PulseMakeBreak  = pTG->NCUParams2.DialBlind         = -1;
    pTG->NCUParams2.DialBlind         = -1;
    pTG->NCUParams2.SpeakerVolume   = pTG->NCUParams2.SpeakerControl    = -1;
    pTG->NCUParams2.SpeakerRing     = -1;

    // used in Dial
    pTG->NCUParams2.chDialModifier  = 'T';
}


BYTE rgbFlip256[256]  = {
        0x0,    0x80,   0x40,   0xc0,   0x20,   0xa0,   0x60,   0xe0,
        0x10,   0x90,   0x50,   0xd0,   0x30,   0xb0,   0x70,   0xf0,
        0x8,    0x88,   0x48,   0xc8,   0x28,   0xa8,   0x68,   0xe8,
        0x18,   0x98,   0x58,   0xd8,   0x38,   0xb8,   0x78,   0xf8,
        0x4,    0x84,   0x44,   0xc4,   0x24,   0xa4,   0x64,   0xe4,
        0x14,   0x94,   0x54,   0xd4,   0x34,   0xb4,   0x74,   0xf4,
        0xc,    0x8c,   0x4c,   0xcc,   0x2c,   0xac,   0x6c,   0xec,
        0x1c,   0x9c,   0x5c,   0xdc,   0x3c,   0xbc,   0x7c,   0xfc,
        0x2,    0x82,   0x42,   0xc2,   0x22,   0xa2,   0x62,   0xe2,
        0x12,   0x92,   0x52,   0xd2,   0x32,   0xb2,   0x72,   0xf2,
        0xa,    0x8a,   0x4a,   0xca,   0x2a,   0xaa,   0x6a,   0xea,
        0x1a,   0x9a,   0x5a,   0xda,   0x3a,   0xba,   0x7a,   0xfa,
        0x6,    0x86,   0x46,   0xc6,   0x26,   0xa6,   0x66,   0xe6,
        0x16,   0x96,   0x56,   0xd6,   0x36,   0xb6,   0x76,   0xf6,
        0xe,    0x8e,   0x4e,   0xce,   0x2e,   0xae,   0x6e,   0xee,
        0x1e,   0x9e,   0x5e,   0xde,   0x3e,   0xbe,   0x7e,   0xfe,
        0x1,    0x81,   0x41,   0xc1,   0x21,   0xa1,   0x61,   0xe1,
        0x11,   0x91,   0x51,   0xd1,   0x31,   0xb1,   0x71,   0xf1,
        0x9,    0x89,   0x49,   0xc9,   0x29,   0xa9,   0x69,   0xe9,
        0x19,   0x99,   0x59,   0xd9,   0x39,   0xb9,   0x79,   0xf9,
        0x5,    0x85,   0x45,   0xc5,   0x25,   0xa5,   0x65,   0xe5,
        0x15,   0x95,   0x55,   0xd5,   0x35,   0xb5,   0x75,   0xf5,
        0xd,    0x8d,   0x4d,   0xcd,   0x2d,   0xad,   0x6d,   0xed,
        0x1d,   0x9d,   0x5d,   0xdd,   0x3d,   0xbd,   0x7d,   0xfd,
        0x3,    0x83,   0x43,   0xc3,   0x23,   0xa3,   0x63,   0xe3,
        0x13,   0x93,   0x53,   0xd3,   0x33,   0xb3,   0x73,   0xf3,
        0xb,    0x8b,   0x4b,   0xcb,   0x2b,   0xab,   0x6b,   0xeb,
        0x1b,   0x9b,   0x5b,   0xdb,   0x3b,   0xbb,   0x7b,   0xfb,
        0x7,    0x87,   0x47,   0xc7,   0x27,   0xa7,   0x67,   0xe7,
        0x17,   0x97,   0x57,   0xd7,   0x37,   0xb7,   0x77,   0xf7,
        0xf,    0x8f,   0x4f,   0xcf,   0x2f,   0xaf,   0x6f,   0xef,
        0x1f,   0x9f,   0x5f,   0xdf,   0x3f,   0xbf,   0x7f,   0xff
};

#define FLIP(index) (lpb[(index)] = rgbFlip256[lpb[(index)]])

void    cl2_flip_bytes(LPB lpb, DWORD dw)
{
        while (dw>8)
        {
                FLIP(0); FLIP(1); FLIP(2); FLIP(3);
                FLIP(4); FLIP(5); FLIP(6); FLIP(7);
                dw-=8;
                lpb+=8;
        }

        while(dw)
        {
                FLIP(0);
                dw--;
                lpb++;
        }
}


// These values are taken from table 20/T.32: "Hangup status codes"
#define FHNG_DCS_NO_RESPONSE            25
#define FHNG_FAIL_TRAIN_AT_LOWEST_SPEED 27
#define FHNG_MPS_NO_RESPONSE            52
#define FHNG_EOP_NO_RESPONSE            54
#define FHNG_EOM_NO_RESPONSE            56

/*++
Routine Description:
    Calls SignalStatusChange with the appropriate StatusId and StringId, according 
    to dwFHNGReason.
--*/
void Class2SignalFatalError(PThrdGlbl pTG)
{
    DEBUG_FUNCTION_NAME("Class2ReportFatalError");

    if (pTG->fFatalErrorWasSignaled)
    {
        return;
    }
    
    pTG->fFatalErrorWasSignaled = TRUE;
    if (pTG->fFoundFHNG)
    {
        switch (pTG->dwFHNGReason)
        {
            case FHNG_DCS_NO_RESPONSE:
                        SignalStatusChangeWithStringId(pTG, FS_NO_RESPONSE, IDS_NO_RESPONSE);
                        break;
            case FHNG_FAIL_TRAIN_AT_LOWEST_SPEED:
                        if (pTG->Operation==T30_TX)
                        {
                            SignalStatusChangeWithStringId(pTG, FS_SEND_BAD_TRAINING, IDS_SEND_BAD_TRAINING);
                        }
                        else
                        {
                            SignalStatusChangeWithStringId(pTG, FS_RECV_BAD_TRAINING, IDS_RECV_BAD_TRAINING);
                        }
                        break;
            case FHNG_MPS_NO_RESPONSE:
            case FHNG_EOP_NO_RESPONSE:
            case FHNG_EOM_NO_RESPONSE:
                        SignalStatusChangeWithStringId(pTG, FS_NO_RESPONSE, IDS_NO_RESPONSE);
                        break;

            default:    SignalStatusChange(pTG, FS_FATAL_ERROR);
        }
    }
    else
    {
        SignalStatusChange(pTG, FS_FATAL_ERROR);
    }
}
=== C:/Users/treeman/Desktop/windows nt source code\Source\Win2K3\NT\printscan\faxsrv\provider\t30\cl2and20\cl2spec.h ===
#define STARTSENDMODE_TIMEOUT 40000L     // Sending Timeout needs to be pretty long!!!
#define LOCALCOMMAND_TIMEOUT  6000L    // for commands sent to modem  but not when connected
#define ANS_LOCALCOMMAND_TIMEOUT  1000L    // for commands sent to modem when answering (during ringing)

#define         CLASS2_BAUDRATE         19200
#define         NUMBER_OF_DIS_VALUES    8
#define         NUMBER_OF_DCS_VALUES    8
#define         MORE_PAGES              10
#define         NO_MORE_PAGES           20

//  Class 2 DCE Response Codes.
#define CL2DCE_CONNECT          1
#define CL2DCE_OK               2
#define CL2DCE_XON              3
#define CL2DCE_FDCS             4
#define CL2DCE_FDIS             5
#define CL2DCE_FDTC             6
#define CL2DCE_FPOLL            7
#define CL2DCE_FCFR             8
#define CL2DCE_FTSI             9
#define CL2DCE_FCSI             10
#define CL2DCE_FCIG             11
#define CL2DCE_FNSF             12
#define CL2DCE_FNSS             13
#define CL2DCE_FNSC             14
#define CL2DCE_FHT              15
#define CL2DCE_FHR              16
#define CL2DCE_FCON             17
#define CL2DCE_FVOICE           18
#define CL2DCE_FET              19
#define CL2DCE_FPTS             20
#define CL2DCE_FHNG             21
#define CL2DCE_FDM              22


#define CR                              0x0d
#define LF                              0x0a
#define DLE                             0x10            // DLE = ^P = 16d = 10h
#define ETX                             0x03


BOOL ParseFPTS_SendAck(PThrdGlbl pTG);
=== C:/Users/treeman/Desktop/windows nt source code\Source\Win2K3\NT\printscan\faxsrv\provider\t30\class1\class1.h ===
/***************************************************************************
 Name     :     CLASS1.H
 Comment  :     Main include file for Windows Comm Class-1 Modem driver

        Copyright (c) Microsoft Corp. 1991 1992 1993

 Revision Log
 Date     Name  Description
 -------- ----- ---------------------------------------------------------
***************************************************************************/



/**---------------------- #define of sizes of things ---------------------

        Frames can be at most 2.55 secs (sent) or 3.45 secs (recvd) long, or
        2.55 * 300/8 = 96 bytes and 132 bytes long respectively

        Dialstrings are limited to 60 bytes (arbitrarily)

        Commands (except dial) are never more than about 10-20 bytes long, so
        we use a buffer of 40 bytes. Replies are never big at all, but we
        might hold a frame in there, so keep it same size as a Framebuffer

        The Dial command is ATDT <string><CR>, so we use 60+10 bytes buffer

---------------------- #define of sizes of things ---------------------**/



/**---------------------- #define of other things ---------------------

        FAX_CLASSn      is used in Modem.FaxClass.

        CHECK_PATTERN is used in the Guard elements.
        ECM_FRAMESIZE in T30.C

---------------------- #define of other things ---------------------**/

#define CR                              0x0d
#define LF                              0x0a
#define DLE                             0x10            // DLE = ^P = 16d = 10h
#define ETX                             0x03

extern BYTE                             bDLEETX[];
extern BYTE                             bDLEETXOK[];


#define EndMode(pTG)         { pTG->Class1Modem.DriverMode = IDLE;      \
                                                pTG->Class1Modem.ModemMode = COMMAND;        \
                                                pTG->Class1Modem.CurMod = 0; }



// from ddi.c
void SendZeros1(PThrdGlbl pTG, USHORT uCount);

BOOL iModemDrain(PThrdGlbl pTG);


#define iModemNoPauseDialog(pTG, s, l, t, w)                 \
                iiModemDialog(pTG, s, l, t, FALSE, 1, FALSE, (CBPSTR)w, (CBPSTR)(NULL))
#define iModemNoPauseDialog2(pTG, s, l, t, w1, w2)   \
                iiModemDialog(pTG, s, l, t, FALSE, 1, FALSE, (CBPSTR)w1, (CBPSTR)w2, (CBPSTR)(NULL))
#define iModemNoPauseDialog3(pTG, s, l, t, w1, w2, w3)       \
                iiModemDialog(pTG, s, l, t, FALSE, 1, FALSE, (CBPSTR)w1, (CBPSTR)w2, (CBPSTR)w3, (CBPSTR)(NULL))
#define iModemPauseDialog(pTG, s, l, t, w)                   \
                iiModemDialog(pTG, s, l, t, FALSE, 1, TRUE, (CBPSTR)w, (CBPSTR)(NULL))
#define iModemResp2(pTG, t, w1, w2)         \
          iiModemDialog(pTG, NULL, 0, t, FALSE, 1, FALSE, (CBPSTR)w1, (CBPSTR)w2, (CBPSTR)(NULL))
#define iModemResp3(pTG,  t, w1, w2, w3)             \
          iiModemDialog(pTG, NULL, 0, t, FALSE, 1, FALSE, (CBPSTR)w1, (CBPSTR)w2, (CBPSTR)w3, (CBPSTR)(NULL))
#define iModemResp4( pTG, t, w1, w2, w3, w4)         \
          iiModemDialog(pTG, NULL, 0, t, FALSE, 1, FALSE, (CBPSTR)w1, (CBPSTR)w2, (CBPSTR)w3, (CBPSTR)w4, (CBPSTR)(NULL))
=== C:/Users/treeman/Desktop/windows nt source code\Source\Win2K3\NT\printscan\faxsrv\provider\t30\class1\ddi.c ===
/***************************************************************************
        Name      :     DDI.C

        Copyright (c) Microsoft Corp. 1991 1992 1993

        Revision Log
        Num   Date      Name     Description
        --- -------- ---------- -----------------------------------------------
***************************************************************************/


#define USE_DEBUG_CONTEXT DEBUG_CONTEXT_T30_CLASS1

#include "prep.h"

#include "mmsystem.h"
#include "comdevi.h"
#include "class1.h"

///RSL
#include "glbproto.h"

#include "psslog.h"
#define FILE_ID        FILE_ID_DDI

/* Converts a the T30 code for a speed to the Class1 code
 * Generates V.17 with Long Training.
 * Add 1 to V.17 codes to get teh Short-train version
 */
BYTE T30toC1[16] =
{
/* V27_2400             0 */    24,
/* V29_9600             1 */    96,
/* V27_4800             2 */    48,
/* V29_7200             3 */    72,
/* V33_14400    4 */    145,    // 144, // V33==V17_long_train FTM=144 is illegal
                                                0,
/* V33_12000    6 */    121,    // 120, // V33==V17_long_train FTM=120 is illegal
/* V21 squeezed in */   3,
/* V17_14400    8 */    145,
/* V17_9600             9 */    97,
/* V17_12000    10 */   121,
/* V17_7200             11 */   73,
                                                0,
                                                0,
                                                0,
                                                0
};


CBSZ cbszFTH3   = "AT+FTH=3\r";
CBSZ cbszFRH3   = "AT+FRH=3\r";
CBSZ cbszFTM    = "AT+FTM=%d\r";
CBSZ cbszFRM    = "AT+FRM=%d\r";

// echo off, verbose response, no auto answer, hangup on DTR drop
// 30 seconds timer on connect, speaker always off, speaker volume=0
// busy&dialtone detect enabled
extern  CBSZ cbszOK       ;
extern  CBSZ cbszCONNECT   ;
extern  CBSZ cbszNOCARRIER  ;
extern  CBSZ cbszERROR       ;
extern  CBSZ cbszFCERROR      ;




#define         ST_MASK         (0x8 | ST_FLAG)         // 8 selects V17 only. 16 selects ST flag

/******************** Global Vars *********/
BYTE                            bDLEETX[3] = { DLE, ETX, 0 };
BYTE                            bDLEETXOK[9] = { DLE, ETX, '\r', '\n', 'O', 'K', '\r', '\n', 0 };
/******************** Global Vars *********/

USHORT NCUDial(PThrdGlbl pTG, LPSTR szPhoneNum)
{
    USHORT uRet;

    _fmemset(&pTG->Class1Modem, 0, sizeof(CLASS1_MODEM));

    if((uRet = iModemDial(pTG, szPhoneNum)) == CONNECT_OK)
    {
        pTG->Class1Modem.ModemMode = FRH;
    }

    return uRet;
}

USHORT NCULink
(
    PThrdGlbl pTG, 
    USHORT uFlags
)
{
    USHORT uRet;

    DEBUG_FUNCTION_NAME(_T("NCULink"));

    switch(uFlags)
    {
    case NCULINK_HANGUP:
                                    if(iModemHangup(pTG))
                                    {
                                        uRet = CONNECT_OK;
                                    }
                                    else
                                    {
                                        uRet = CONNECT_ERROR;
                                    }
                                    break;
    case NCULINK_RX:
                                    _fmemset(&pTG->Class1Modem, 0, sizeof(CLASS1_MODEM));
                                    if((uRet = iModemAnswer(pTG)) == CONNECT_OK)
                                    {
                                        pTG->Class1Modem.ModemMode = FTH;
                                    }
                                    break;
    default:                        uRet = CONNECT_ERROR;
                                    break;
    }

    DebugPrintEx( DEBUG_MSG, "uRet=%d", uRet);
    return uRet;
}

// dangerous. May get 2 OKs, may get one. Generally avoid
// CBSZ cbszATAT                        = "AT\rAT\r";
CBSZ cbszAT1                    = "AT\r";

BOOL iModemSyncEx(PThrdGlbl pTG, ULONG ulTimeout, DWORD dwFlags)
{
    DEBUG_FUNCTION_NAME(("iModemSyncEx"));

    ///// Do cleanup of global state //////
    FComOutFilterClose(pTG);
    FComOverlappedIO(pTG, FALSE);
    FComXon(pTG, FALSE);
    EndMode(pTG);
    ///// Do cleanup of global state //////

    {
        LPCMDTAB lpCmdTab = iModemGetCmdTabPtr(pTG);
        if (	(dwFlags & fMDMSYNC_DCN)				&&
				(pTG->Class1Modem.ModemMode == COMMAND) &&  
				lpCmdTab								&&
				(lpCmdTab->dwFlags&fMDMSP_C1_NO_SYNC_IF_CMD) 
			)
        {
                DebugPrintEx(DEBUG_WRN, "NOT Syching modem (MSPEC)");
                Sleep(100); // +++ 4/12 JosephJ -- try to elim this -- it's juse
                                        // that we used to always issue an AT here, which
                                        // we now don't, so I issue a 100ms delay here instead.
                                        // MOST probably unnessary. The AT was issued by
                                        // accident on 4/94 -- as a side effect of
                                        // a change in T.30 code -- when iModemSyncEx was
                                        // called just before a normal dosconnect. Unfortunately
                                        // we discovered in 4/95, 2 weeks before code freeze,
                                        // that the AT&T DataPort express (TT14), didn't
                                        // like this AT.
                return TRUE;
        }
        else
        {
            return (iModemPauseDialog(pTG, (LPSTR)cbszAT1, sizeof(cbszAT1)-1, ulTimeout, cbszOK)==1);
        }
    }
}


// length of TCF = 1.5 * bpscode * 100 / 8 == 75 * bpscode / 4
USHORT TCFLen[16] =
{
/* V27_2400             0 */    450,
/* V29_9600             1 */    1800,
/* V27_4800             2 */    900,
/* V29_7200             3 */    1350,
/* V33_14400    4 */    2700,
                                                0,
/* V33_12000    6 */    2250,
                                                0,
/* V17_14400    8 */    2700,
/* V17_9600             9 */    1800,
/* V17_12000    10 */   2250,
/* V17_7200             11 */   1350,
                                                0,
                                                0,
                                                0,
                                                0
};


#define min(x,y)        (((x) < (y)) ? (x) : (y))
#define ZERO_BUFSIZE    256

void SendZeros1(PThrdGlbl pTG, USHORT uCount)
{
    BYTE    bZero[ZERO_BUFSIZE];
    short   i;              // must be signed

    DEBUG_FUNCTION_NAME(_T("SendZeros1"));

    PSSLogEntry(PSS_MSG, 2, "send: %d zeroes", uCount);  

    _fmemset(bZero, 0, ZERO_BUFSIZE);
    for(i=uCount; i>0; i -= ZERO_BUFSIZE)
    {
        // no need to stuff. They're all zeros!
        FComDirectAsyncWrite(pTG, bZero, (UWORD)(min((UWORD)i, (UWORD)ZERO_BUFSIZE)));
    }
    DebugPrintEx(DEBUG_MSG,"Sent %d zeros",uCount);
}

BOOL ModemSendMode
(
    PThrdGlbl pTG, 
    USHORT uMod
)
{
    DEBUG_FUNCTION_NAME(_T("ModemSendMode"));

    pTG->Class1Modem.CurMod = T30toC1[uMod & 0xF];

    if((uMod & ST_MASK) == ST_MASK)         // mask selects V.17 and ST bits
    {
        pTG->Class1Modem.CurMod++;
    }

    DebugPrintEx(   DEBUG_MSG,
                    "uMod=%d CurMod=%d", 
                    uMod, 
                    pTG->Class1Modem.CurMod);

    if(uMod == V21_300)
    {
        _fstrcpy(pTG->Class1Modem.bCmdBuf, (LPSTR)cbszFTH3);
        pTG->Class1Modem.uCmdLen = sizeof(cbszFTH3)-1;
        pTG->Class1Modem.fHDLC = TRUE;
        FComXon(pTG, FALSE);                 // for safety. _May_ be critical
    }
    else
    {
        pTG->Class1Modem.uCmdLen = (USHORT)wsprintf(pTG->Class1Modem.bCmdBuf, cbszFTM, pTG->Class1Modem.CurMod);
        pTG->Class1Modem.fHDLC = FALSE;
        FComXon(pTG, TRUE);          // critical!! Start of PhaseC
        // no harm doing it here(i.e before issuing +FTM)
    }
    FComOutFilterInit(pTG);    // _not_ used for 300bps HDLC
                                                    // but here just in case
    // want to do all the work _before_ issuing command

    pTG->Class1Modem.DriverMode = SEND;

    if(pTG->Class1Modem.ModemMode == FTH)
    {
        // already in send mode. This happens on Answer only
        return TRUE;
    }

#define STARTSENDMODE_TIMEOUT 5000                              // Random Timeout

    //// Try to cut down delay between getting CONNECT and writing the
    // first 00s (else modems can quit because of underrun).
    // Can do this by not sleeping in this. Only in fatal
    // cases will it lock up for too long (max 5secs). In those cases
    // the call is trashed too.

    if(!iModemNoPauseDialog(pTG, (LPB)pTG->Class1Modem.bCmdBuf, pTG->Class1Modem.uCmdLen, STARTSENDMODE_TIMEOUT, cbszCONNECT))
    {
        goto error;
    }

    // can't set this earlier. We'll trash previous value
    pTG->Class1Modem.ModemMode = ((uMod==V21_300) ? FTH : FTM);

    // Turn OFF overlapped I/O if in V.21 else ON
    FComOverlappedIO(pTG, uMod != V21_300);

    if(pTG->Class1Modem.ModemMode == FTM)
    {
        // don't send 00s if ECM
        SendZeros1(pTG, (USHORT)(TCFLen[uMod & 0x0F] / PAGE_PREAMBLE_DIV));
    }

	// FComDrain(-,FALSE) causes fcom to write out any internally-
    // maintained buffers, but not to drain the comm-driver buffers.
    FComDrain(pTG, TRUE,FALSE);

    DebugPrintEx(   DEBUG_MSG,
                    "Starting Send at %d", 
                    pTG->Class1Modem.CurMod);
    return TRUE;

error:
    FComOutFilterClose(pTG);
    FComOverlappedIO(pTG, FALSE);
    FComXon(pTG, FALSE);         // important. Cleanup on error
    EndMode(pTG);
    return FALSE;
}

BOOL iModemDrain(PThrdGlbl pTG)
{
    DEBUG_FUNCTION_NAME(_T("iModemDrain"));

    if(!FComDrain(pTG, TRUE, TRUE))
            return FALSE;

            // Must turn XON/XOFF off immediately *after* drain, but before we
            // send the next AT command, since recieved frames have 0x13 or
            // even 0x11 in them!! MUST GO AFTER the getOK ---- See BELOW!!!!

// increase this---see bug number 495. Must be big enough for
// COM_OUTBUFSIZE to safely drain at 2400bps(300bytes/sec = 0.3bytes/ms)
// let's say (COM_OUTBUFSIZE * 10 / 3) == (COM_OUTBUFSIZE * 4)
// can be quite long, because on failure we just barf anyway

#define POSTPAGEOK_TIMEOUT (10000L + (((ULONG)COM_OUTBUFSIZE) << 2))

    // Here we were looking for OK only, but some modems (UK Cray Quantun eg)
    // give me an ERROR after sending TCF or a page (at speeds < 9600) even
    // though the page was sent OK. So we were timing out here. Instead look
    // for ERROR (and NO CARRIER too--just in case!), and accept those as OK
    // No point returning ERROR from here, since we just abort. We can't/don't
    // recover from send errors

    if(iModemResp3(pTG, POSTPAGEOK_TIMEOUT, cbszOK, cbszERROR, cbszNOCARRIER) == 0)
            return FALSE;

            // Must change FlowControl State *after* getting OK because in Windows
            // this call takes 500 ms & resets chips, blows away data etc.
            // So do this *only* when you *know* both RX & TX are empty.
            // check this in all usages of this function

    return TRUE;
}


BOOL iModemSendData(PThrdGlbl pTG, LPB lpb, USHORT uCount, USHORT uFlags)
{
    DEBUG_FUNCTION_NAME(("iModemSendData"));

    {
        // always DLE-stuff here. Sometimes zero-stuff

        DebugPrintEx(DEBUG_MSG,"calling FComFilterAsyncWrite");

        if(!FComFilterAsyncWrite(pTG, lpb, uCount, FILTER_DLEZERO))
                goto error;
    }

    if(uFlags & SEND_FINAL)
    {
        DebugPrintEx(DEBUG_MSG,"FComDIRECTAsyncWrite");
        PSSLogEntry(PSS_MSG, 2, "send: <dle><etx>");
        // if(!FComDirectAsyncWrite(bDLEETXCR, 3))
        if(!FComDirectAsyncWrite(pTG, bDLEETX, 2))
                goto error;

        if(!iModemDrain(pTG))
                goto error;

        FComOutFilterClose(pTG);
        FComOverlappedIO(pTG, FALSE);
        FComXon(pTG, FALSE);         // critical. End of PhaseC
                                                // must come after Drain
        EndMode(pTG);
    }

    return TRUE;

error:
    FComXon(pTG, FALSE);                 // critical. End of PhaseC (error)
    FComFlush(pTG);                    // clean out the buffer if we got an error
    FComOutFilterClose(pTG);
    FComOverlappedIO(pTG, FALSE);
    EndMode(pTG);
    return FALSE;
}

BOOL iModemSendFrame(PThrdGlbl pTG, LPB lpb, USHORT uCount, USHORT uFlags)
{
    UWORD   uwResp=0;

    DEBUG_FUNCTION_NAME(("iModemSendFrame"));

    // always DLE-stuff here. Never zero-stuff
    // This is only called for 300bps HDLC

    if(pTG->Class1Modem.ModemMode != FTH)        // Special case on just answering!!
    {
#define FTH_TIMEOUT 5000                                // Random Timeout
        if(!iModemNoPauseDialog(    pTG, 
                                    (LPB)pTG->Class1Modem.bCmdBuf, 
                                    pTG->Class1Modem.uCmdLen, 
                                    FTH_TIMEOUT, 
                                    cbszCONNECT))
                goto error;
    }

    {
        // always DLE-stuff here. Never zero-stuff
        if(!FComFilterAsyncWrite(pTG, lpb, uCount, FILTER_DLEONLY))
                goto error;
    }


    {
        PSSLogEntry(PSS_MSG, 2, "send: <dle><etx>");

        if(!FComDirectAsyncWrite(pTG, bDLEETX, 2))
                goto error;
    }

// 2000 is too short because PPRs can be 32+7 bytes long and
// preamble is 1 sec, so set this to 3000
// 3000 is too short because NSFs and CSIs can be arbitrarily long
// MAXFRAMESIZE is defined in et30type.h. 30ms/byte at 300bps
// async (I think V.21 is syn though), so use N*30+1000+slack

#define WRITEFRAMERESP_TIMEOUT  (1000+30*MAXFRAMESIZE+500)
    if(!(uwResp = iModemResp2(pTG, WRITEFRAMERESP_TIMEOUT, cbszOK, cbszCONNECT)))
            goto error;
    pTG->Class1Modem.ModemMode = ((uwResp == 2) ? FTH : COMMAND);


    if(uFlags & SEND_FINAL)
    {
        FComOutFilterClose(pTG);
        FComOverlappedIO(pTG, FALSE);
        // FComXon(FALSE);      // at 300bps. no Xon-Xoff in use

        // in some weird cases (Practical Peripherals PM14400FXMT) we get
        // CONNECT<cr><lf>OK, but we get the CONNECT here. Should we
        // just set pTG->Class1Modem.ModemMode=COMMAND?? (EndMode does that)
        // Happens on PP 144FXSA also. Ignore it & just set mode to COMMAND
        EndMode(pTG);
    }
    return TRUE;

error:
    FComOutFilterClose(pTG);
    FComOverlappedIO(pTG, FALSE);
    FComXon(pTG, FALSE);         // just for safety. cleanup on error
    EndMode(pTG);
    return FALSE;
}

BOOL ModemSendMem
(
    PThrdGlbl pTG, 
    LPBYTE lpb, 
    USHORT uCount, 
    USHORT uFlags
)
{
        
    DEBUG_FUNCTION_NAME(_T("ModemSendMem"));

    DebugPrintEx(   DEBUG_MSG,
                    "lpb=%08lx uCount=%d wFlags=%04x",
                    lpb, 
                    uCount, 
                    uFlags);

    if(pTG->Class1Modem.DriverMode != SEND)
    {
        return FALSE;
    }

    if(pTG->Class1Modem.fHDLC)
    {
        DebugPrintEx(DEBUG_MSG,"(fHDLC) calling: iModemSendFrame");
        return iModemSendFrame(pTG, lpb, uCount, uFlags);
    }
    else
    {
        DebugPrintEx(DEBUG_MSG,"(Else) calling: iModemSendData");
        return iModemSendData(pTG, lpb, uCount, uFlags);
    }
}

#define MINRECVMODETIMEOUT      500
#define RECVMODEPAUSE           200

USHORT ModemRecvMode(PThrdGlbl pTG, USHORT uMod, ULONG ulTimeout, BOOL fRetryOnFCERROR)
{
    USHORT  uRet;
    ULONG ulBefore, ulAfter;

    DEBUG_FUNCTION_NAME(_T("ModemRecvMode"));
    // Here we should watch for a different modulation scheme from what we expect.
    // Modems are supposed to return a +FCERROR code to indicate this condition,
    // but I have not seen it from any modem yet, so we just scan for ERROR
    // (this will catch +FCERROR too since iiModemDialog does not expect whole
    // words or anything silly like that!), and treat both the same.

    pTG->Class1Modem.CurMod = T30toC1[uMod & 0xF];

    if((uMod & ST_MASK) == ST_MASK)         // mask selects V.17 and ST bits
    {
        pTG->Class1Modem.CurMod++;
    }

    if(uMod == V21_300)
    {
        _fstrcpy(pTG->Class1Modem.bCmdBuf, (LPSTR)cbszFRH3);
        pTG->Class1Modem.uCmdLen = sizeof(cbszFRH3)-1;
    }
    else
    {
        pTG->Class1Modem.uCmdLen = (USHORT)wsprintf(pTG->Class1Modem.bCmdBuf, cbszFRM, pTG->Class1Modem.CurMod);
    }

    if(pTG->Class1Modem.ModemMode == FRH)
    {
        // already in receive mode. This happens upon Dial only
        pTG->Class1Modem.fHDLC = TRUE;
        pTG->Class1Modem.DriverMode = RECV;
        FComInFilterInit(pTG);
        return RECV_OK;
    }


    // On Win32, we have a problem going into 2400baud recv.
    // +++ remember to put this into iModemFRHorM when that code is enabled.
    if (pTG->Class1Modem.CurMod==24) Sleep(80);

retry:

    ulBefore=GetTickCount();
    // Don't look for NO CARRIER. Want it to retry until FRM timeout on NO CARRIER
    // ----This is changed. See below----
    uRet = iModemNoPauseDialog3(pTG, pTG->Class1Modem.bCmdBuf, pTG->Class1Modem.uCmdLen, ulTimeout, cbszCONNECT, cbszFCERROR, cbszNOCARRIER);
    // uRet = iModemNoPauseDialog2(pTG->Class1Modem.bCmdBuf, pTG->Class1Modem.uCmdLen, ulTimeout, cbszCONNECT, cbszFCERROR);
    ulAfter=GetTickCount();

    if((fRetryOnFCERROR && uRet==2) || uRet==3)  // uRet==FCERROR or uRet==NOCARRIER
    {
        if( (ulAfter <= ulBefore) ||    // wraparound or 0 time elapsed (timer broke)
                (ulTimeout < ((ulAfter-ulBefore) + MINRECVMODETIMEOUT)))
        {
            DebugPrintEx(   DEBUG_WRN,
                            "Giving up on RecvMode. uRet=%d ulTimeout=%ld",
                            uRet, 
                            ulTimeout);
        }
        else
        {
            ulTimeout -= (ulAfter-ulBefore);

            // need this pause for NO CARRIER for USR modems. See bug#1516
            // for the RC229DP, dunno if it's reqd because I dunno why theyre
            // giving the FCERROR. Don't want to miss the carrier so currently
            // don't pause. (Maybe we can achieve same effect by simply taking
            // FCERROR out of the response list above--but that won't work for
            // NOCARRIER because we _need_ teh pause. iiModemDialog is too fast)
            if(uRet == 3)
                    Sleep(RECVMODEPAUSE);

            goto retry;
        }
    }

    DebugPrintEx(   DEBUG_MSG,
                    "uMod=%d CurMod=%dulTimeout=%ld: Got=%d", 
                    uMod, 
                    pTG->Class1Modem.CurMod,
                    ulTimeout, 
                    uRet);
    if(uRet != 1)
    {
        EndMode(pTG);
        if(uRet == 2)
        {
            DebugPrintEx(   DEBUG_WRN,
                            "Got FCERROR after %ldms", 
                            ulAfter-ulBefore);
            return RECV_WRONGMODE;  // need to return quickly
        }
        else
        {
            DebugPrintEx(   DEBUG_WRN,
                            "Got Timeout after %ldms",
                            ulAfter-ulBefore);
            return RECV_TIMEOUT;
        }
    }

    if(uMod==V21_300)
    {
        pTG->Class1Modem.ModemMode = FRH;
        pTG->Class1Modem.fHDLC = TRUE;
    }
    else
    {
        pTG->Class1Modem.ModemMode = FRM;
        pTG->Class1Modem.fHDLC = FALSE;
    }
    pTG->Class1Modem.DriverMode = RECV;
    FComInFilterInit(pTG);
    DebugPrintEx(DEBUG_MSG, "Starting Recv at %d", pTG->Class1Modem.CurMod);
    return RECV_OK;
}

USHORT iModemRecvData
(   
    PThrdGlbl pTG, 
    LPB lpb, 
    USHORT cbMax, 
    ULONG ulTimeout, 
    USHORT far* lpcbRecv
)
{
    SWORD   swEOF;
    USHORT  uRet;

    DEBUG_FUNCTION_NAME(("iModemRecvData"));

    startTimeOut(pTG, &(pTG->Class1Modem.toRecv), ulTimeout);
    // 4th arg must be FALSE for Class1
    *lpcbRecv = FComFilterReadBuf(pTG, lpb, cbMax, &(pTG->Class1Modem.toRecv), FALSE, &swEOF);
    if(swEOF == -1)
    {
        // we got a DLE-ETX _not_ followed by OK or NO CARRIER. So now
        // we have to decide whether to (a) declare end of page (swEOF=1)
        // or (b) ignore it & assume page continues on (swEOF=0).
        //
        // The problem is that some modems produce spurious EOL during a page
        // I believe this happens due a momentary loss of carrier that they
        // recover from. For example IFAX sending to the ATI 19200. In those
        // cases we want to do (b). The opposite problem is that we'll run
        // into a modem whose normal response is other than OK or NO CARRIER.
        // Then we want to do (a) because otherwise we'll _never_ work with
        // that modem.
        //
        // So we have to either do (a) always, or have an INI setting that
        // can force (a), which could be set thru the AWMODEM.INF file. But
        // we also want to do (b) if possible because otehrwise we'll not be
        // able to recieve from weak or flaky modems or machines or whatever
        //
        // Snowball does (b). I believe best soln is an INI setting, with (b)
        // as default

        // option (a)
        // swEOF = 1;

        // option (b)
        DebugPrintEx(DEBUG_WRN,"Got arbitrary DLE-ETX. Ignoring");
        swEOF = 0;
    }

    switch(swEOF)
    {
    case 1:         uRet = RECV_EOF; 
                    break;
    case 0:         return RECV_OK;
    default:        // fall through
    case -2:        uRet = RECV_ERROR; 
                    break;
    case -3:        uRet = RECV_TIMEOUT; 
                    break;
    }

    EndMode(pTG);
    return uRet;
}

const static BYTE LFCRETXDLE[4] = { LF, CR, ETX, DLE };

USHORT iModemRecvFrame
(
    PThrdGlbl pTG, 
    LPB lpb, 
    USHORT cbMax, 
    ULONG ulTimeout, 
    USHORT far* lpcbRecv
)
{
    SWORD swRead, swRet;
    USHORT i;
    BOOL fRestarted=0;
    USHORT uRet;
    BOOL fGotGoodCRC = 0;   // see comment-block below

    DEBUG_FUNCTION_NAME(_T("iModemRecvFrame"));
    /** Sometimes modems give use ERROR even when thr frame is good.
            Happens a lot from Thought to PP144MT on CFR. So we check
            the CRC. If the CRc was good and everything else looks good
            _except_ the "ERROR" response from teh modem then return
            RECV_OK, not RECV_BADFRAME.
            This should fix BUG#1218
    **/

restart:
    *lpcbRecv=0;
    if(pTG->Class1Modem.ModemMode!= FRH)
    {
        swRet=iModemNoPauseDialog2(pTG, (LPB)pTG->Class1Modem.bCmdBuf, pTG->Class1Modem.uCmdLen, ulTimeout, cbszCONNECT, cbszNOCARRIER);
        if(swRet==2||swRet==3)
        {
            DebugPrintEx(DEBUG_MSG,"Got NO CARRIER from FRH=3");
            EndMode(pTG);
            return RECV_EOF;
        }
        else if(swRet != 1)
        {
            DebugPrintEx(DEBUG_WRN,"Can't get CONNECT from FRH=3, got %d",swRet);
            EndMode(pTG);
            return RECV_TIMEOUT;    // may not need this, since we never got flags??
            // actually we dont know what the heck we got!!
        }
    }

    /*** Got CONNECT (i.e. flags). Now try to get a frame ***/

    /****************************************************************
     * Using 3 secs here is a misinterpretation of the T30 CommandReceived?
     * flowchart. WE want to wait here until we get something or until T2
     * or T4 timeout. It would have been best if we started T2 ot T4 on
     * entry into the search routine (t30.c), but starting it here is good
     * enough.
     * Using this 3secs timeout fails when Genoa simulates a bad frame
     * because Zoom PKT modem gives us a whole raft of bad frames for one
     * bad PPS-EOP and then gives a CONNECT that we timeout below exactly
     * as the sender's T4 timeout expires and he re-sends the PPS-EOP
     * so we miss all of them.
     * Alternately, we could timeout here on 2sec & retry. But that's risky
     * If less than 2sec then we'll timeout on modems that give connect
     * first flag, then 2sec elapse before CR-LF (1sec preamble & 1sec for
     * long frames, e.g. PPR!)
     ****************************************************************/

    startTimeOut(pTG, &(pTG->Class1Modem.toRecv), ulTimeout);
    swRead = FComFilterReadLine(pTG, lpb, cbMax, &(pTG->Class1Modem.toRecv));

    pTG->Class1Modem.ModemMode = COMMAND;
    // may change this to FRH if we get CONNECT later.
    // but set it here just in case we short circuit out due to errors

    if(swRead<=0)
    {
        // Timeout
        DebugPrintEx(DEBUG_WRN,"Can't get frame after connect. Got-->%d",(WORD)-swRead);
        D_HexPrint(lpb, (WORD)-swRead);
        EndMode(pTG);
        *lpcbRecv = -swRead;
        return RECV_ERROR;              // goto error;        
    }

    PSSLogEntryHex(PSS_MSG, 2, lpb, swRead, "recv:     HDLC frame, %d bytes,", swRead);

    if (pTG->fLineTooLongWasIgnored)
    {
        // the following case is dealt with here:
        // we get an HDLC frame which is longer than 132 bytes, a bad frame.
        // the problem is that we might have skipped it and read the 'ERROR' 
        // after it as the actual data.
        // since no HDLC frame can be that long, let's return an error.
        // it's important NOT to ask the modem for a response here
        // we might have already read it.
        DebugPrintEx(DEBUG_WRN,"the received frame was too long, BAD FRAME!", swRead);
        (*lpcbRecv) = 0;
        uRet = RECV_BADFRAME;
        return uRet;
    }

    if (swRead<10)
    {
        D_HexPrint(lpb, swRead);
    }

    for(i=0, swRead--; i<4 && swRead>=0; i++, swRead--)
    {
        if(lpb[swRead] != LFCRETXDLE[i])
                break;
    }
    // exits when swRead is pointing to last non-noise char
    // or swRead == -1
    // incr by 1 to give actual non-noise data size.
    // (size = ptr to last byte + 1!)
    swRead++;


    // Hack for AT&T AK144 modem that doesn't send us the CRC
    // only lop off last 2 bytes IFF the frame is >= 5 bytes long
    // that will leave us at least the FF 03/13 FCF
    // if(i==4 && swRead>=2)        // i.e. found all of DLE-ETX_CR-LF

    // 09/25/95 This code was changed to never lop of the CRC.
    // All of the routines except NSxtoBC can figure out the correct length,
    // and that way if the modem doesn't pass on the CRC, we no longer
    // lop off the data.

    // we really want this CRC-checking in the MDDI case too
    if(i==4)// i.e. found all of DLE-ETX_CR-LF
    {
        uRet = RECV_OK;
    }
    else
    {
        DebugPrintEx(DEBUG_WRN,"Frame doesn't end in dle-etx-cr-lf");
        // leave tast two bytes in. We don't *know* it's a CRC, since
        // frame ending was non-standard
        uRet = RECV_BADFRAME;
    }
    *lpcbRecv = swRead;

    // check if it is the NULL frame (i.e. DLE-ETX-CR-LF) first.
    // (check is: swRead==0 and uRet==RECV_OK (see above))
    // if so AND if we get OK or CONNECT or ERROR below then ignore
    // it completely. The Thought modem and the PP144MT generate
    // this idiotic situation! Keep a flag to avoid a possible
    // endless loop

    // broaden this so that we Restart on either a dle-etx-cr-lf
    // NULL frame or a simple cr-lf NULL frame. But then we need
    // to return an ERROR (not BADFRAME) after restarting once,
    // otheriwse there is an infinite loop with T30 calling us
    // again and again (see bug#834)

    // chnage yet again. This takes too long, and were trying to tackle
    // a specific bug (the PP144MT) bug here, so let's retsrat only
    // on dle-etx-cr-lf (not just cr-lf), and in teh latter case
    // return a response according to what we get


    /*** Got Frame. Now try to get OK or ERROR. Timeout=0! ***/

    switch(swRet = iModemResp4(pTG,0, cbszOK, cbszCONNECT, cbszNOCARRIER, cbszERROR))
    {
    case 2:         pTG->Class1Modem.ModemMode = FRH;
                    // fall through and do exactly like OK!!
    case 1: // ModemMode already == COMMAND
                    if(swRead<=0 && uRet==RECV_OK && !fRestarted)
                    {
                        DebugPrintEx(DEBUG_WRN,"Got %d after frame. RESTARTING", swRet);
                        fRestarted = 1;
                        goto restart;
                    }
                    //uRet already set
                    break;

    case 3:         // NO CARRIER. If got null-frame or no frame return
                    // RECV_EOF. Otherwise if got OK frame then return RECV_OK
                    // and return frame as usual. Next time around it'll get a
                    // NO CARRIER again (hopefully) or timeout. On a bad frame
                    // we can return RECV_EOF, but this will get into trouble if
                    // the recv is not actually done. Or return BADFRAME, and hope
                    // for a NO CARRIER again next time. But next time we may get a
                    // timeout. ModemMode is always set to COMMAND (already)
                    DebugPrintEx(   DEBUG_WRN,
                                    "Got NO CARRIER after frame. swRead=%d uRet=%d", 
                                    swRead, 
                                    uRet);
                    if(swRead <= 0)
                            uRet = RECV_EOF;
                    // else uRet is already BADFRAME or OK
                    break;

                    // this is bad!!
                    // alternately:
                    // if(swRead<=0 || uRet==RECV_BADFRAME)
                    // {
                    //              uRet = RECV_EOF;
                    //              *lpcbRecv = 0;          // must return 0 bytes with RECV_EOF
                    // }

    case 4: // ERROR
                    if(swRead<=0)
                    {
                        // got no frame
                        if(uRet==RECV_OK && !fRestarted)
                        {
                            // if we got dle-etx-cr-lf for first time
                            DebugPrintEx(   DEBUG_WRN,
                                            "Got ERROR after frame. RESTARTING");
                            fRestarted = 1;
                            goto restart;
                        }
                        else
                        {
                            uRet = RECV_ERROR;
                        }
                    }
                    else
                    {
                        // if everything was OK until we got the "ERROR" response from
                        // the modem and we got a good CRC then treat it as "OK"
                        // This should fix BUG#1218
                        if(uRet==RECV_OK && fGotGoodCRC)
                        {
                            uRet = RECV_OK;
                        }
                        else
                        {
                            uRet = RECV_BADFRAME;
                        }
                    }

                    DebugPrintEx(   DEBUG_WRN,
                                    "Got ERROR after frame. swRead=%d uRet=%d", 
                                    swRead, 
                                    uRet);
                    break;

    case 0: // timeout
                    DebugPrintEx(   DEBUG_WRN,
                                    "Got TIMEOUT after frame. swRead=%d uRet=%d", 
                                    swRead, 
                                    uRet);
                    // if everything was OK until we got the timeout from
                    // the modem and we got a good CRC then treat it as "OK"
                    // This should fix BUG#1218
                    if(uRet==RECV_OK && fGotGoodCRC)
                    {
                        uRet = RECV_OK;
                    }
                    else
                    {
                        uRet = RECV_BADFRAME;
                    }
                    break;
    }
    return uRet;
}

USHORT ModemRecvMem(PThrdGlbl pTG, LPBYTE lpb, USHORT cbMax, ULONG ulTimeout, USHORT far* lpcbRecv)
{
    USHORT uRet;

    DEBUG_FUNCTION_NAME(_T("ModemRecvMem"));

    DebugPrintEx(   DEBUG_MSG,
                    "lpb=%08lx cbMax=%d ulTimeout=%ld", 
                    lpb, 
                    cbMax, 
                    ulTimeout);

    if(pTG->Class1Modem.DriverMode != RECV)
    {
        return RECV_ERROR;      // see bug#1492
    }
    *lpcbRecv=0;

    if(pTG->Class1Modem.fHDLC)
    {
        uRet = iModemRecvFrame(pTG, lpb, cbMax, ulTimeout, lpcbRecv);
    }
    else
    {
        uRet = iModemRecvData(pTG, lpb, cbMax, ulTimeout, lpcbRecv);
    }

    DebugPrintEx(   DEBUG_MSG,
                    "lpbf=%08lx uCount=%d uRet=%d", 
                    lpb, 
                    *lpcbRecv, 
                    uRet);
    return uRet;
}
=== C:/Users/treeman/Desktop/windows nt source code\Source\Win2K3\NT\printscan\faxsrv\provider\t30\cl2and20\class20.c ===
/*++

Copyright (c) 1997  Microsoft Corporation

Module Name:

    class20.c

Abstract:

    This is the main source for Class2.0 specific functions for fax-modem T.30 driver

Author:
    Source base was originated by Win95 At Work Fax package.
    RafaelL - July 1997 - port to NT

Revision History:

--*/


#define USE_DEBUG_CONTEXT DEBUG_CONTEXT_T30_CLASS2


#include "prep.h"
#include "efaxcb.h"

#include "tiff.h"

#include "glbproto.h"
#include "t30gl.h"
#include "cl2spec.h"

#include "psslog.h"
#define FILE_ID FILE_ID_CLASS20
#include "pssframe.h"

#define STRSAFE_NO_DEPRECATE
#include <strsafe.h>

extern WORD CodeToBPS[16];
extern UWORD rguwClass2Speeds[];
extern DWORD PageWidthInPixelsFromDCS[];

BYTE   bClass20DLE_nextpage[3] = { DLE, 0x2c, 0 };
BYTE   bClass20DLE_enddoc[3] =   { DLE, 0x2e, 0 };
BYTE   bMRClass20RTC[10] =  { 0x01, 0x30, 0x00, 0x06, 0xc0, 0x00, 0x18, 0x00, 0x03, 0x00};
BYTE   bMHClass20RTC[9] =   { 0x00, 0x08, 0x80, 0x00, 0x08, 0x80, 0x00, 0x08, 0x00};



void
Class20Init(
     PThrdGlbl pTG
)

{
   pTG->lpCmdTab = 0;

   pTG->Class2bDLEETX[0] = DLE;
   pTG->Class2bDLEETX[1] = ETX;
   pTG->Class2bDLEETX[2] = 0;

   sprintf( pTG->cbszFDT,          "AT+FDT\r" );
   sprintf( pTG->cbszFDR,          "AT+FDR\r" );
   sprintf( pTG->cbszFPTS,         "AT+FPS=%%d\r" );
   sprintf( pTG->cbszFCR,          "AT+FCR=1\r" );
   sprintf( pTG->cbszFNR,          "AT+FNR=1,1,1,1\r" );
   sprintf( pTG->cbszFCQ,          "AT+FCQ=0,0\r" );
   sprintf( pTG->cbszFBUG,         "AT+FBUG=0\r" );
   sprintf( pTG->cbszSET_FBOR,     "AT+FBO=%%d\r" );

   // DCC - set High Res, Huffman, no ECM/BFT, default all others.

   sprintf( pTG->cbszFDCC_ALL,      "AT+FCC=%%d,%%d,,,0,0,0,0\r" );
   sprintf( pTG->cbszFDCC_RECV_ALL, "AT+FCC=1,%%d,,,0,0,0,0\r" );
   sprintf( pTG->cbszFDIS_RECV_ALL, "AT+FDIS=1,%%d,2,2,0,0,0,\r" );
   sprintf( pTG->cbszFDCC_RES,      "AT+FDCC=1\r" );
   sprintf( pTG->cbszFDCC_BAUD,     "AT+FDCC=1,%%d\r" );
   sprintf( pTG->cbszFDIS_BAUD,     "AT+FDIS=1,%%d\r" );
   sprintf( pTG->cbszFDIS_IS,       "AT+FIS?\r" );
   sprintf( pTG->cbszFDIS_NOQ_IS,   "AT+FDIS\r" );
   sprintf( pTG->cbszFDCC_IS,       "AT+FCC?\r" );
   sprintf( pTG->cbszFDIS_STRING,   "+FIS" );
   sprintf( pTG->cbszFDIS,          "AT+FIS=%%1d,%%1d,%%1d,%%1d,%%1d,0,0,0\r" );
   sprintf( pTG->cbszONE,           "1" );

   sprintf( pTG->cbszCLASS2_FMFR,       "AT+FMI?\r" );
   sprintf( pTG->cbszCLASS2_FMDL,       "AT+FMM?\r" );

   sprintf( pTG->cbszFDT_CONNECT,       "CONNECT" );
   sprintf( pTG->cbszFCON,              "+FCO" );
   sprintf( pTG->cbszFLID,              "AT+FLI=\"%%s\"\r" );
   sprintf( pTG->cbszENDPAGE,           "AT+FET=0\r" );
   sprintf( pTG->cbszENDMESSAGE,        "AT+FET=2\r" );
   sprintf( pTG->cbszCLASS2_ATTEN,      "AT\r" );
   sprintf( pTG->cbszATA,               "ATA\r" );

   sprintf( pTG->cbszCLASS2_HANGUP,     "ATH0\r" );
   sprintf( pTG->cbszCLASS2_CALLDONE,   "ATS0=0\r" );
   sprintf( pTG->cbszCLASS2_ABORT,      "AT+FKS\r" );
   sprintf( pTG->cbszCLASS2_DIAL,       "ATD%%c %%s\r" );
   sprintf( pTG->cbszCLASS2_NODIALTONE, "NO DIAL" );
   sprintf( pTG->cbszCLASS2_BUSY,       "BUSY" );
   sprintf( pTG->cbszCLASS2_NOANSWER,   "NO ANSWER" );
   sprintf( pTG->cbszCLASS2_OK,         "OK" );
   sprintf( pTG->cbszCLASS2_FHNG,       "+FHS" );
   sprintf( pTG->cbszCLASS2_ERROR,      "ERROR" );
   sprintf( pTG->cbszCLASS2_NOCARRIER,  "NO CARRIER" );


   Class2SetProtParams(pTG, &pTG->Inst.ProtParams);

}


/*++
Routine Description:
    Issue "AT+FDIS=?" command, parse response into pTG->DISPcb

Return Value:
    TRUE - success, FALSE - failure
--*/
BOOL Class20GetDefaultFDIS(PThrdGlbl pTG)
{
    UWORD   uwRet=0;
    BYTE    bTempBuf[200+RESPONSE_BUF_SIZE];
    LPBYTE  lpbyte;
    HRESULT hr;

    DEBUG_FUNCTION_NAME("Class20GetDefaultFDIS");

    // Find out what the default DIS is
    if(!(uwRet=Class2iModemDialog(  pTG,
                                    pTG->cbszFDIS_IS,
                                    (UWORD)(strlen(pTG->cbszFDIS_IS)),
                                    LOCALCOMMAND_TIMEOUT,
                                    0,
                                    TRUE,
                                    pTG->cbszCLASS2_OK,
                                    pTG->cbszCLASS2_ERROR,
                                    (C2PSTR) NULL)))
    {
        DebugPrintEx(DEBUG_WRN,"FDIS? failed");
        // ignore
    }

    // See if the reply was ERROR or timeout, if so try a different command
    if ( uwRet == 2)
    {
       if(!(uwRet=Class2iModemDialog(   pTG,
                                        pTG->cbszFDIS_IS,
                                        (UWORD)(strlen(pTG->cbszFDIS_IS)),
                                        LOCALCOMMAND_TIMEOUT,
                                        0,
                                        TRUE,
                                        pTG->cbszCLASS2_OK,
                                        (C2PSTR) NULL)))
       {
            // No FDIS, FDCC worked - quit!
            DebugPrintEx(DEBUG_ERR,"No FDIS? or FDCC? worked");
            return FALSE;
       }

        // If the first character in the reply before a number
        // is a ',', insert a '1' for normal & fine res (Exar hack)
        for (lpbyte = pTG->lpbResponseBuf2; *lpbyte != '\0'; lpbyte++)
        {
            if (*lpbyte == ',')
            {
                // found a leading comma
                hr = StringCchPrintf(bTempBuf, ARR_SIZE(bTempBuf), "%s%s", pTG->cbszONE, lpbyte);
            	if (FAILED(hr))
            	{
            		DebugPrintEx(DEBUG_WRN,"StringCchPrintf failed (ec=0x%08X)",hr);
            	}
            	else
            	{
                    hr = StringCchCopy(lpbyte, ARR_SIZE(pTG->lpbResponseBuf2) - (lpbyte-pTG->lpbResponseBuf2), bTempBuf);
                	if (FAILED(hr))
                	{
                		DebugPrintEx(DEBUG_WRN,"StringCchCopy failed (ec=0x%08X)",hr);
                	}
            	}
                DebugPrintEx(DEBUG_MSG,"Leading comma in DCC string =%s", (LPSTR)&pTG->lpbResponseBuf2);
            }

            if ( (*lpbyte >= '0') && (*lpbyte <= '9') )
            {
                break;
            }
        }
    }

    // If the repsonse was just a number string without "+FDIS" in front
    // of it, add the +FDIS. Some modem reply with it, some do not. The
    // general parsing algorithm used below in Class2ResponseAction needs
    // to know the command that the numbers refer to.
    if ( pTG->lpbResponseBuf2[0] != '\0' &&
       (strstr( (LPSTR)pTG->lpbResponseBuf2, (LPSTR)pTG->cbszFDIS_STRING)==NULL))
    {
        // did not get the FDIS in the response!
        hr = StringCchPrintf(bTempBuf, ARR_SIZE(bTempBuf), "%s: %s", pTG->cbszFDIS_STRING, pTG->lpbResponseBuf2);
    	if (FAILED(hr))
    	{
    		DebugPrintEx(DEBUG_WRN,"StringCchPrintf failed (ec=0x%08X)",hr);
    	}
    	else
    	{
            hr = StringCchCopy(pTG->lpbResponseBuf2, ARR_SIZE(pTG->lpbResponseBuf2), bTempBuf);
        	if (FAILED(hr))
        	{
        		DebugPrintEx(DEBUG_WRN,"StringCchCopy failed (ec=0x%08X)",hr);
        	}
    	}
    }

    DebugPrintEx(DEBUG_MSG,"Received %s from FDIS?", (LPSTR)(&(pTG->lpbResponseBuf2)));

    // Process default DIS to see if we have to send a DCC to change
    // it. Some modems react badly to just sending a DCC with ",,,"
    // so we can't rely on the modem keeping DIS parameters unchanged
    // after a DCC like that. We'll use the FDISResponse routine to load
    // the default DIS values into a PCB structure
    if ( Class2ResponseAction(pTG, (LPPCB) &pTG->DISPcb) == FALSE )
    {
        DebugPrintEx(DEBUG_ERR,"Failed to process FDIS Response");
        return FALSE;
    }

    return TRUE;
}



BOOL T30Cl20Tx(PThrdGlbl pTG,LPSTR szPhone)
{
    USHORT  uRet1, uRet2;

    BYTE    bBuf[200];

    UWORD   Encoding, Res, PageWidth, PageLength, uwLen;
    BYTE    bIDBuf[200+max(MAXTOTALIDLEN,20)+4];
    CHAR    szTSI[max(MAXTOTALIDLEN,20)+4] = {0};
    BOOL    fBaudChanged;
    BOOL    RetCode;

    DEBUG_FUNCTION_NAME("T30Cl20Tx");

    uRet2 = 0;
    if(!(pTG->lpCmdTab = iModemGetCmdTabPtr(pTG)))
    {
        DebugPrintEx(DEBUG_ERR,"iModemGetCmdTabPtr failed.");
        uRet1 = T30_CALLFAIL;

        pTG->fFatalErrorWasSignaled = 1;
        SignalStatusChange(pTG, FS_FATAL_ERROR);
        RetCode = FALSE;
        goto done;
    }

    // first get SEND_CAPS if possible.

    if(!Class2GetBC(pTG, SEND_CAPS)) // get send caps
    {
        uRet1 = T30_CALLFAIL;

        pTG->fFatalErrorWasSignaled = 1;
        SignalStatusChange(pTG, FS_FATAL_ERROR);
        RetCode = FALSE;

        goto done;
    }

    // Go to Class2.0
    if(!iModemGoClass(pTG, 3))
    {
        DebugPrintEx(DEBUG_ERR,"Failed to Go to Class 2.0");
        uRet1 = T30_CALLFAIL;

        pTG->fFatalErrorWasSignaled = 1;
        SignalStatusChange(pTG, FS_FATAL_ERROR);
        RetCode = FALSE;
        goto done;
    }

    // Begin by checking for manufacturer and ATI code.
    // Look this up against the modem specific table we
    // have and set up the send strings needed for
    // this modem.
    if(!Class2GetModemMaker(pTG))
    {
        DebugPrintEx(DEBUG_WRN,"Call to GetModemMaker failed");
        // Ignore failure!!!
    }

    // set manufacturer specific strings
    Class2SetMFRSpecific(pTG);

    // Get the capabilities of the software. I am only using this
    // right now for the TSI field (below where I send +FLID).
    // Really, this should also be used instead of the hardcoded DIS
    // values below.
    // ALL COMMANDS LOOK FOR MULTILINE RESPONSES WHILE MODEM IS ONHOOK.
    // A "RING" COULD APPEAR AT ANY TIME!

    _fmemset((LPB)szTSI, 0, strlen(szTSI));
    Class2SetDIS_DCSParams( pTG,
                            SEND_CAPS,
                            (LPUWORD)&Encoding,
                            (LPUWORD)&Res,
                            (LPUWORD)&PageWidth,
                            (LPUWORD)&PageLength,
                            (LPSTR) szTSI,
							sizeof(szTSI)/sizeof(szTSI[0]));

    bIDBuf[0] = '\0';
    uwLen = (UWORD)wsprintf(bIDBuf, pTG->cbszFLID, (LPSTR)szTSI);

    if(!Class2iModemDialog( pTG,
                            bIDBuf,
                            uwLen,
                            LOCALCOMMAND_TIMEOUT,
                            0,
                            TRUE,
                            pTG->cbszCLASS2_OK,
                            pTG->cbszCLASS2_ERROR,
                            (C2PSTR) NULL))
    {
        DebugPrintEx(DEBUG_WRN,"Local ID failed");
        // ignore failure
    }


    if (!Class20GetDefaultFDIS(pTG))
    {
        DebugPrintEx(DEBUG_ERR, "Class20GetDefaultFDIS failed");
        uRet1 = T30_CALLFAIL;

        pTG->fFatalErrorWasSignaled = 1;
        SignalStatusChange(pTG, FS_FATAL_ERROR);
        RetCode = FALSE;
        goto done;
    }

    fBaudChanged = FALSE;
    // See if we have to change the baud rate to a lower value.
    // This only happens if the user set an ini string constraining
    // the high end speed or if the user turned off V.17 for sending
    // Check the V.17 inhibit and lower baud if necessary
    if ( (pTG->DISPcb.Baud > 3) && (!pTG->ProtParams2.fEnableV17Send) )
    {
        DebugPrintEx(DEBUG_MSG,"Lowering baud from %d for V.17 inihibit", CodeToBPS[pTG->DISPcb.Baud]);

        pTG->DISPcb.Baud = 3; //9600 won't use V.17
        fBaudChanged = TRUE;
    }

    // Now see if the high end baud rate has been constrained
    if  ( (pTG->ProtParams2.HighestSendSpeed != 0) &&
            (CodeToBPS[pTG->DISPcb.Baud] > (WORD)pTG->ProtParams2.HighestSendSpeed))
    {
        DebugPrintEx(   DEBUG_MSG,
                        "Have to lower baud from %d to %d",
                        CodeToBPS[pTG->DISPcb.Baud],
                        pTG->ProtParams2.HighestSendSpeed);

        fBaudChanged = TRUE;
        switch (pTG->ProtParams2.HighestSendSpeed)
        {
                case 2400:
                        pTG->DISPcb.Baud = 0;
                        break;
                case 4800:
                        pTG->DISPcb.Baud = 1;
                        break;
                case 7200:
                        pTG->DISPcb.Baud = 2;
                        break;
                case 9600:
                        pTG->DISPcb.Baud = 3;
                        break;
                case 12000:
                        pTG->DISPcb.Baud = 4;
                        break;
                default:
                        DebugPrintEx(DEBUG_ERR,"Bad HighestSpeed");

                        uRet1 = T30_CALLFAIL;
                        pTG->fFatalErrorWasSignaled = 1;
                        SignalStatusChange(pTG, FS_FATAL_ERROR);
                        RetCode = FALSE;
                        goto done;

                        break;
        }
    }


    uwLen=(UWORD)wsprintf((LPSTR)bBuf, pTG->cbszFDCC_ALL, Res, pTG->DISPcb.Baud);
    if(!Class2iModemDialog( pTG,
                            bBuf,
                            uwLen,
                            LOCALCOMMAND_TIMEOUT,
                            0,
                            TRUE,
                            pTG->cbszCLASS2_OK,
                            (C2PSTR) NULL))
    {
          uRet1 = T30_CALLFAIL;

          pTG->fFatalErrorWasSignaled = 1;
          SignalStatusChange(pTG, FS_FATAL_ERROR);
          RetCode = FALSE;
          goto done;
    }


    // Do BOR based on the value from the modem table set in
    // Class2SetMFRSpecific
    uwLen = (UWORD)wsprintf(bBuf, pTG->cbszSET_FBOR, pTG->CurrentMFRSpec.iSendBOR);
    if(!Class2iModemDialog( pTG,
                            bBuf,
                            uwLen,
                            LOCALCOMMAND_TIMEOUT,
                            0,
                            TRUE,
                            pTG->cbszCLASS2_OK,
                            pTG->cbszCLASS2_ERROR,
                            (C2PSTR) NULL))
    {
        DebugPrintEx(DEBUG_WRN,"FBOR failed");
        // Ignore BOR failure!!!
    }

    if(!Class2iModemDialog( pTG,
                            pTG->cbszFNR,
                            (UWORD)(strlen(pTG->cbszFNR)),
                            ANS_LOCALCOMMAND_TIMEOUT,
                            0,
                            TRUE,
                            pTG->cbszCLASS2_OK,
                            pTG->cbszCLASS2_ERROR,
                            (C2PSTR) NULL))
    {
        DebugPrintEx(DEBUG_WRN,"FNR failed");
        // ignore error
    }

    // Dial the number

            // have to call hangup on every path out of here
            // after Dial is called. If Dial fails, it calls Hangup
            // if it succeeds we have to call Hangup when we're done

    PSSLogEntry(PSS_MSG, 0, "Phase A - Call establishment");

    SignalStatusChange(pTG, FS_DIALING);

    PSSLogEntry(PSS_MSG, 1, "Dialing...");

    if((uRet2 = Class2Dial(pTG, szPhone)) != CONNECT_OK)
    {
        uRet1 = T30_DIALFAIL;

        if (! pTG->fFatalErrorWasSignaled)
        {
             pTG->fFatalErrorWasSignaled = 1;
             SignalStatusChange(pTG, FS_FATAL_ERROR);
        }

        RetCode = FALSE;

        goto done;
    }

    pTG->Inst.state = BEFORE_RECVCAPS;
    // we should be using the sender msg here but that says Training
    // at speed=xxxx etc which we don't know, so we just use the
    // Recvr message which just says "negotiating"

    // Send the data
    uRet1 = (USHORT)Class20Send(pTG );
    if ( uRet1 == T30_CALLDONE)
    {
        DebugPrintEx(DEBUG_MSG,"******* DONE WITH CALL, ALL OK");

        // have to call hangup on every path out of here
        // we have to call Hangup here
        Class2ModemHangup(pTG );

        SignalStatusChange(pTG, FS_COMPLETED);
        RetCode = TRUE;
    }
    else
    {
        DebugPrintEx(DEBUG_ERR,"******* DONE WITH CALL, **** FAILED *****");

        // Make sure Modem is in OK state
        FComOutFilterClose(pTG );
        FComXon(pTG, FALSE);
        // have to call hangup on every path out of here
        // Class2ModemABort calls Hangup
        Class2ModemAbort(pTG );

        Class2SignalFatalError(pTG);
        RetCode = FALSE;
    }
    uRet2 = 0;

done:
    return RetCode;
}

BOOL Class20Send(PThrdGlbl pTG)
{
    LPBUFFER        lpbf;
    SWORD           swRet;
    ULONG           lTotalLen=0;
    PCB             Pcb;
    USHORT          uTimeout=30000;
    BOOL            err_status, fAllPagesOK = TRUE;
    BC				bc;

    UWORD           Encoding, Res=0, PageWidth, PageLength, uwLen;
    BYTE            bFDISBuf[200];
    CHAR            szTSI[max(MAXTOTALIDLEN,20)+4];
    BYTE            bNull = 0;
    DWORD           TiffConvertThreadId;
    USHORT          uNextSend;

    DEBUG_FUNCTION_NAME("Class20Send");

    /*
    * We have just dialed... Now we have to look for the FDIS response from
    * the modem. It will be followed by an OK - hunt for the OK.
    */
    PSSLogEntry(PSS_MSG, 0, "Phase B - Negotiation");

    if (Class2iModemDialog( pTG,
                            NULL,
                            0,
                            STARTSENDMODE_TIMEOUT,
                            0,
                            TRUE,
                            pTG->cbszCLASS2_OK,
                            (C2PSTR) NULL) != 1)
    {
        PSSLogEntry(PSS_ERR, 1, "Failed to receive DIS - aborting");
        err_status =  T30_CALLFAIL;
        return err_status;
    }
    if (pTG->fFoundFHNG)
    {
        PSSLogEntry(PSS_ERR, 1, "Call was disconnected");
        err_status =  T30_CALLFAIL;
        return err_status;
    }

    // The response will be in pTG->lpbResponseBuf2 - this is loaded in
    // Class2iModemDialog.

    // Parse through the received strings, looking for the DIS, CSI,
    // NSF

    if ( Class2ResponseAction(pTG, (LPPCB) &Pcb) == FALSE )
    {
        DebugPrintEx(DEBUG_ERR,"Failed to process ATD Response");
        PSSLogEntry(PSS_ERR, 1, "Failed to parse received DIS - aborting");
        err_status =  T30_CALLFAIL;
        return err_status;
    }

    PSSLogEntry(PSS_MSG, 1, "CSI is %s", Pcb.szID);
    PSSLogEntry(PSS_MSG, 1, "DIS specified the following capabilities:");
    LogClass2DISDetails(pTG, &Pcb);

    //Now that pcb is set up, call ICommReceiveCaps to tell icomfile

    Class2InitBC(pTG, (LPBC)&bc, sizeof(bc), RECV_CAPS);
    Class2PCBtoBC(pTG, (LPBC)&bc, sizeof(bc), &Pcb);

    // Class2 modems do their own negotiation & we need to stay in sync
    // Otherwise, we might send MR data while the modem sends a DCS
    // saying it is MH. This happens a lot with Exar modems because
    // they dont accept an FDIS= command during the call.
    // FIX: On all Class2 sends force remote caps to always be MH
    // Then in efaxrun we will always negotiate MH & encode MH
    // We are relying on the fact that (a) it seems that all/most
    // Class2 modems negotiate MH (b) Hopefully ALL Exar ones
    // negotiate MH and (c) We will override all non-Exar modem's
    // intrinsic negotiation by sending an AT+FDIS= just before the FDT
    // Also (d) This change makes our behaviour match Snowball exactly
    // so we will work no better or worse than it :-)
    bc.Fax.Encoding = MH_DATA;

    if( ICommRecvCaps(pTG, (LPBC)&bc) == FALSE )
    {
        DebugPrintEx(DEBUG_ERR,"Failed return from ICommRecvCaps.");
        err_status =  T30_CALLFAIL;
        return err_status;
    }

    // now get the SEND_PARAMS
    if(!Class2GetBC(pTG, SEND_PARAMS)) // sleep until we get it
    {
        err_status = T30_CALLFAIL;
        return err_status;
    }

    // Turn off flow control.
    FComXon(pTG, FALSE);

    // The Send params were set during the call to Class2GetBC
    // We'll use these to set the ID (for the TSI) and the DCS params

    // Send the FDT and get back the DCS. The FDT must be followed by
    // CONNECT and a ^Q (XON)
    // The FDT string must have the correct resolution and encoding
    // for this session. FDT=Encoding, Res, width, length
    // Encoding 0=MH, 1=MR,2=uncompressed,3=MMR
    // Res 0=200x100 (normal), 1=200x200 (fine)
    // PageWidth 0=1728pixels/215mm,1=2048/255,2=2432/303,
    //              3=1216/151,4=864/107
    // PageLength 0=A4,1=B4,2=unlimited

    Class2SetDIS_DCSParams( pTG,
                            SEND_PARAMS,
                            (LPUWORD)&Encoding,
                            (LPUWORD)&Res,
                            (LPUWORD)&PageWidth,
                            (LPUWORD)&PageLength,
                            (LPSTR) szTSI,
							sizeof(szTSI)/sizeof(szTSI[0]));

    //
    // Current Win95 version of Class2 TX is limited to MH only.
    // While not changing this, we will at least allow MR selection in future.
    //

    if (!pTG->fTiffThreadCreated)
    {
         if (Encoding)
         {
           pTG->TiffConvertThreadParams.tiffCompression = TIFF_COMPRESSION_MR;
         }
         else
         {
           pTG->TiffConvertThreadParams.tiffCompression = TIFF_COMPRESSION_MH;
         }


         if (Res)
         {
           pTG->TiffConvertThreadParams.HiRes = 1;
         }
         else
         {
           pTG->TiffConvertThreadParams.HiRes = 0;

           // use LoRes TIFF file prepared by FaxSvc

           // pTG->lpwFileName[ wcslen(pTG->lpwFileName) - 1] = (unsigned short) ('$');

         }

         _fmemcpy (pTG->TiffConvertThreadParams.lpszLineID, pTG->lpszPermanentLineID, 8);
         pTG->TiffConvertThreadParams.lpszLineID[8] = 0;

         DebugPrintEx(DEBUG_MSG,"Creating TIFF helper thread");
         pTG->hThread = CreateThread(   NULL,
                                        0,
                                        (LPTHREAD_START_ROUTINE) TiffConvertThread,
                                        (LPVOID) pTG,
                                        0,
                                        &TiffConvertThreadId);

         if (!pTG->hThread)
         {
             DebugPrintEx(DEBUG_ERR,"TiffConvertThread create FAILED");

             err_status = T30_CALLFAIL;
             return err_status;
         }

         pTG->fTiffThreadCreated = 1;
         pTG->AckTerminate = 0;
         pTG->fOkToResetAbortReqEvent = 0;

         if ( (pTG->RecoveryIndex >=0 ) && (pTG->RecoveryIndex < MAX_T30_CONNECT) )
         {
             T30Recovery[pTG->RecoveryIndex].TiffThreadId = TiffConvertThreadId;
             T30Recovery[pTG->RecoveryIndex].CkSum = ComputeCheckSum((LPDWORD) &T30Recovery[pTG->RecoveryIndex].fAvail,
                                                                    sizeof ( T30_RECOVERY_GLOB ) / sizeof (DWORD) - 1 );

         }
    }


    // Even modems that take FDT=x,x,x,x don't seem to really do it
    // right. So, for now, just send FDIS followed by FDT except for
    // the EXAR modems!!
    uwLen = (UWORD)wsprintf(bFDISBuf,
                            pTG->cbszFDIS,
                            Res,
                            min(Pcb.Baud, pTG->DISPcb.Baud),
                            PageWidth,
                            PageLength,
                            Encoding);
    if(!Class2iModemDialog( pTG,
                            bFDISBuf,
                            uwLen,
                            LOCALCOMMAND_TIMEOUT,
                            0,
                            TRUE,
                            pTG->cbszCLASS2_OK,
                            pTG->cbszCLASS2_ERROR,
                            (C2PSTR) NULL))
    {
        DebugPrintEx(DEBUG_WRN,"Failed get response from FDIS");
        // Ignore it -we are going to send what we have!
    }

    if (Class2iModemDialog( pTG,
                            pTG->cbszFDT,
                            (UWORD)(strlen(pTG->cbszFDT)),
                            STARTSENDMODE_TIMEOUT,
                            0,
                            TRUE,
                            pTG->cbszFDT_CONNECT,
                            (C2PSTR) NULL) != 1)
    {
        DebugPrintEx(DEBUG_ERR,"FDT Received %s",(LPSTR)(&(pTG->lpbResponseBuf2)));
        DebugPrintEx(DEBUG_ERR,"FDT to start first PAGE Failed!");
        if (pTG->fFoundFHNG)
        {
            PSSLogEntry(PSS_ERR, 1, "Call was disconnected");
        }
        err_status =  T30_CALLFAIL;
        return err_status;
    }

    DebugPrintEx(DEBUG_MSG,"FDT Received %s",(LPSTR)(&(pTG->lpbResponseBuf2)));

    // Turn on flow control.
    FComXon(pTG, TRUE);

    // Search through Response for the DCS frame - need it so set
    // the correct zero stuffing

    if ( Class2ResponseAction(pTG, (LPPCB) &Pcb) == FALSE )
    {
        DebugPrintEx(DEBUG_ERR,"Failed to process FDT Response");
        PSSLogEntry(PSS_ERR, 1, "Failed to parse sent DCS - aborting");
        err_status =  T30_CALLFAIL;
        return err_status;
    }

    PSSLogEntry(PSS_MSG, 1, "TSI is \"%s\"", pTG->LocalID);
    PSSLogEntry(PSS_MSG, 1, "DCS was sent as follows:");
    LogClass2DCSDetails(pTG, &Pcb);

    // Got a response - see if baud rate is OK
    DebugPrintEx(   DEBUG_MSG,
                    "Negotiated Baud Rate = %d, lower limit is %d",
                    Pcb.Baud,
                    pTG->ProtParams2.LowestSendSpeed);

    if (CodeToBPS[Pcb.Baud] < (WORD)pTG->ProtParams2.LowestSendSpeed)
    {
        DebugPrintEx(DEBUG_MSG,"Aborting due to too low baud rate!");
        err_status =  T30_CALLFAIL;
        return err_status;
    }


    // Use values obtained from the DCS frame to set zero stuffing.
    // (These were obtained by call to Class2ResponseAction above).
    // Zero stuffing is a function of minimum scan time (determined
    // by resolution and the returned scan minimum) and baud.
    // Fixed the Hack--added a Baud field

    // Init must be BEFORE SetStuffZero!
    FComOutFilterInit(pTG );
    FComSetStuffZERO(pTG, Class2MinScanToBytesPerLine(pTG, Pcb.MinScan, (BYTE) Pcb.Baud, Pcb.Resolution));

    err_status =  T30_CALLDONE;

    while ((swRet=ICommGetSendBuf(pTG, &lpbf, SEND_STARTPAGE)) == 0)
    {
        PSSLogEntry(PSS_MSG, 0, "Phase C - Page Transmission");
        PSSLogEntry(PSS_MSG, 1, "Sending page %d data...", pTG->PageCount);

        lTotalLen = 0;

        FComOverlappedIO(pTG, TRUE); // TRUE
        while ((swRet=ICommGetSendBuf(pTG, &lpbf, SEND_SEQ)) == 0)
        {
            lTotalLen += lpbf->wLengthData;
            DebugPrintEx(DEBUG_MSG,"total length: %ld", lTotalLen);

            if(!(Class2ModemSendMem(pTG, lpbf->lpbBegData,lpbf->wLengthData) & (MyFreeBuf(pTG, lpbf))))
            {
                DebugPrintEx(DEBUG_ERR,"Class2ModemSendBuf Failed");
                PSSLogEntry(PSS_ERR, 1, "Failed to send page data - aborting");
                err_status =  T30_CALLFAIL;
                FComOverlappedIO(pTG, FALSE);
                return err_status;
            }
        } // end of SEND_SEQ while
        PSSLogEntry(PSS_MSG, 2, "send: page %d data, %d bytes", pTG->PageCount, lTotalLen);

        if (swRet != SEND_EOF)
        {
            DebugPrintEx(DEBUG_ERR,"ICommGetSendBuf failed, swRet=%d", swRet);
            PSSLogEntry(PSS_MSG, 2, "send: <dle><etx>");
            FComDirectAsyncWrite(pTG, pTG->Class2bDLEETX, 2);
            PSSLogEntry(PSS_ERR, 1, "Failed to send page data - aborting");
            err_status =  T30_CALLFAIL;
            return err_status;
        }

        PSSLogEntry(PSS_MSG, 2, "send: <RTC>");
        if (Encoding)
        {
            if (! FComDirectAsyncWrite(pTG, bMRClass20RTC, 10) )
            {
                DebugPrintEx(DEBUG_ERR,"Failed to terminate page with MR RTC");
                PSSLogEntry(PSS_ERR, 1, "Failed to send RTC - aborting");
                err_status =  T30_CALLFAIL;
                return err_status;
            }
        }
        else
        {
            if (! FComDirectAsyncWrite(pTG, bMHClass20RTC, 9) )
            {
                DebugPrintEx(DEBUG_ERR,"Failed to terminate page with MH RTC");
                PSSLogEntry(PSS_ERR, 1, "Failed to send RTC - aborting");
                err_status =  T30_CALLFAIL;
                return err_status;
            }
        }

        DebugPrintEx(DEBUG_MSG,"out of while send_seq loop.");
        // Acknowledge that we sent the page
        PSSLogEntry(PSS_MSG, 0, "Phase D - Post Message Exchange");

        //See if more pages to send...
        if ( (uNextSend = ICommNextSend(pTG)) == NEXTSEND_MPS )
        {
            // Terminate the Page with DLE-,
            DebugPrintEx(DEBUG_MSG,"Another page to send...");

            PSSLogEntry(PSS_MSG, 1, "Sending MPS");
            PSSLogEntry(PSS_MSG, 2, "send: <dle><mps>");
            // Terminate the Page with DLE-ETX
            if(!FComDirectAsyncWrite(pTG, bClass20DLE_nextpage, 2))
            {
                PSSLogEntry(PSS_ERR, 1, "Failed to send <dle><mps> - aborting");
                err_status =  T30_CALLFAIL;
                return err_status;
            }
        }
        else
        {
            // Send end of message sequence
            // Terminate the document with DLE-0x2e
            PSSLogEntry(PSS_MSG, 1, "Sending EOP");
            PSSLogEntry(PSS_MSG, 2, "send: <dle><eop>");
            if(!FComDirectAsyncWrite(pTG, bClass20DLE_enddoc, 2))
            {
                PSSLogEntry(PSS_ERR, 1, "Failed to send <dle><eop> - aborting");
                err_status =  T30_CALLFAIL;
                return err_status;
            }
        }

        // Flow control is turned off inside of ModemDrain.
        swRet = (SWORD)Class2ModemDrain(pTG);
        switch (swRet)
        {
        case 0:
            DebugPrintEx(DEBUG_ERR,"Failed to drain");
            err_status =  T30_CALLFAIL;
            return err_status;
        case 1:
            PSSLogEntry(PSS_MSG, 1, "Received MCF");
            // We want ICommGetSendBuf(SEND_STARTPAGE) to give us the next page
            pTG->T30.ifrResp = ifrMCF;
            break;
        default:
            PSSLogEntry(PSS_MSG, 1, "Received RTN");
            // fAllPagesOK = FALSE;  // This page was bad, but we retransmit it
            // We want ICommGetSendBuf(SEND_STARTPAGE) to give us the same page again
            pTG->T30.ifrResp = ifrRTN;
        }

        if ((uNextSend == NEXTSEND_MPS) || (pTG->T30.ifrResp == ifrRTN))
        {
            if (pTG->fFoundFHNG)
            {
                // This could've happened during Class2ModemDrain
                PSSLogEntry(PSS_ERR, 1, "Call was disconnected");
                err_status =  T30_CALLFAIL;
                return err_status;
            }
            // Now, Send the FDT to start the next page (this was done for
            // the first page before entering the multipage loop).

            if (Class2iModemDialog( pTG,
                                    pTG->cbszFDT,
                                    (UWORD) strlen(pTG->cbszFDT),
                                    STARTSENDMODE_TIMEOUT,
                                    0,
                                    TRUE,
                                    pTG->cbszFDT_CONNECT,
                                    (C2PSTR) NULL) != 1)
            {
                DebugPrintEx(DEBUG_ERR,"FDT to start next PAGE Failed!");
                if (pTG->fFoundFHNG)
                {
                    PSSLogEntry(PSS_ERR, 1, "Call was disconnected");
                }
                err_status =  T30_CALLFAIL;
                return err_status;
            }

            // Turn on flow control.
            FComXon(pTG, TRUE);

        } //if we do not have another page, do the else...
        else
        {
            if ((pTG->fFoundFHNG) && (pTG->dwFHNGReason!=0))
            {
                // This could've happened during Class2ModemDrain
                PSSLogEntry(PSS_ERR, 1, "Call was disconnected");
                err_status =  T30_CALLFAIL;
                return err_status;
            }
            break; // All done sending pages...
        }

        if ( err_status == T30_CALLFAIL)
        {
            break;
        }
    } //End of multipage while

    FComOutFilterClose(pTG );
    FComXon(pTG, FALSE);

    // If *any* page failed to send correctly, the call failed!
    if (!fAllPagesOK)
    {
        err_status = T30_CALLFAIL;
    }
    return err_status;

}


/**************************************************************
        Receive specific routines start here
***************************************************************/

BOOL  T30Cl20Rx (PThrdGlbl pTG)
{
    USHORT          uRet1, uRet2;
    BYTE            bBuf[200];
    UWORD           uwLen;
    UWORD           Encoding, Res, PageWidth, PageLength;
    BYTE            bIDBuf[200+max(MAXTOTALIDLEN,20)+4];
    CHAR            szCSI[max(MAXTOTALIDLEN,20)+4];
    BOOL            fBaudChanged;
    BOOL            RetCode;

    DEBUG_FUNCTION_NAME("T30Cl20Rx");

    uRet2 = 0;
    if(!(pTG->lpCmdTab = iModemGetCmdTabPtr(pTG )))
    {
        DebugPrintEx(DEBUG_ERR,"iModemGetCmdTabPtr failed.");
        uRet1 = T30_CALLFAIL;

        pTG->fFatalErrorWasSignaled = 1;
        SignalStatusChange(pTG, FS_FATAL_ERROR);
        RetCode = FALSE;

        goto done;
    }

    // first get SEND_CAPS
    if(!Class2GetBC(pTG, SEND_CAPS)) // sleep until we get it
    {
        uRet1 = T30_CALLFAIL;

        pTG->fFatalErrorWasSignaled = 1;
        SignalStatusChange(pTG, FS_FATAL_ERROR);
        RetCode = FALSE;

        goto done;
    }

    // Go to Class2.0
    if(!iModemGoClass(pTG, 3))
    {
        DebugPrintEx(DEBUG_ERR,"Failed to Go to Class 2.0");
        uRet1 = T30_CALLFAIL;

        pTG->fFatalErrorWasSignaled = 1;
        SignalStatusChange(pTG, FS_FATAL_ERROR);
        RetCode = FALSE;

        goto done;
    }

    // Begin by checking for manufacturer and ATI code.
    // Look this up against the modem specific table we
    // have and set up the receive strings needed for
    // this modem.
    if(!Class2GetModemMaker(pTG))
    {
        DebugPrintEx(DEBUG_WRN,"Call to GetModemMaker failed");
        // Ignore failure!!!
    }

    // set manufacturer specific strings
    Class2SetMFRSpecific(pTG);

    // Get the capabilities of the software. I am only using this
    // right now for the CSI field (below where I send +FLID).
    // Really, this should also be used instead of the hardcoded DIS
    // values below.
    // ALL COMMANDS LOOK FOR MULTILINE RESPONSES WHILE MODEM IS ONHOOK.
    // A "RING" COULD APPEAR AT ANY TIME!
    _fmemset((LPB)szCSI, 0, sizeof(szCSI));
    Class2SetDIS_DCSParams( pTG,
                            SEND_CAPS,
                            (LPUWORD)&Encoding,
                            (LPUWORD)&Res,
                            (LPUWORD)&PageWidth,
                            (LPUWORD)&PageLength,
                            (LPSTR) szCSI,
							sizeof(szCSI)/sizeof(szCSI[0]));


    if (!Class20GetDefaultFDIS(pTG))
    {
        DebugPrintEx(DEBUG_ERR, "Class20GetDefaultFDIS failed");
        uRet1 = T30_CALLFAIL;

        pTG->fFatalErrorWasSignaled = 1;
        SignalStatusChange(pTG, FS_FATAL_ERROR);
        RetCode = FALSE;
        goto done;
    }

    fBaudChanged = FALSE;
    // See if we have to change the baud rate to a lower value.
    // This only happens if the user set an ini string inhibiting
    // V.17 receive
    if ( (pTG->DISPcb.Baud > 3) && (!pTG->ProtParams2.fEnableV17Recv) )
    {
        DebugPrintEx(DEBUG_MSG,"Lowering baud from %d for V.17 receive inihibit", CodeToBPS[pTG->DISPcb.Baud]);

        pTG->DISPcb.Baud = 3; //9600 won't use V.17
        fBaudChanged = TRUE;
    }

    // Now, look and see if any of the values in the DIS are "bad"
    // That is, make sure we can receive high res and we are not
    // claiming that we are capable of MR or MMR. Also, see if we changed
    // the baud rate. Also make sure we can receive wide pages.

    // Set the current session parameters
    uwLen=(UWORD)wsprintf((LPSTR)bBuf, pTG->cbszFDCC_RECV_ALL, pTG->DISPcb.Baud);
    if(!Class2iModemDialog( pTG,
                            bBuf,
                            uwLen,
                            LOCALCOMMAND_TIMEOUT,
                            0,
                            TRUE,
                            pTG->cbszCLASS2_OK,
                            (C2PSTR) NULL))
    {
        uRet1 = T30_CALLFAIL;

        pTG->fFatalErrorWasSignaled = 1;
        SignalStatusChange(pTG, FS_FATAL_ERROR);
        RetCode = FALSE;

        goto done;
    }


    // Enable Reception
    if(!Class2iModemDialog( pTG,
                            pTG->cbszFCR,
                            (UWORD)(strlen(pTG->cbszFCR) ),
                            ANS_LOCALCOMMAND_TIMEOUT,
                            0,
                            TRUE,
                            pTG->cbszCLASS2_OK,
                            pTG->cbszCLASS2_ERROR,
                            (C2PSTR) NULL))
    {
        DebugPrintEx(DEBUG_ERR,"FCR failed");
        uRet1 = T30_CALLFAIL;

        pTG->fFatalErrorWasSignaled = 1;
        SignalStatusChange(pTG, FS_FATAL_ERROR);
        RetCode = FALSE;

        goto done;
    }

    if(!Class2iModemDialog( pTG,
                            pTG->cbszFNR,
                            (UWORD) (strlen(pTG->cbszFNR) ),
                            ANS_LOCALCOMMAND_TIMEOUT,
                            0,
                            TRUE,
                            pTG->cbszCLASS2_OK,
                            pTG->cbszCLASS2_ERROR,
                            (C2PSTR) NULL))
    {
        DebugPrintEx(DEBUG_WRN,"FNR failed");
        // ignore error
    }

    // Turn off Copy Quality Checking - also skip for Sierra type modems
    if(!Class2iModemDialog( pTG,
                            pTG->cbszFCQ,
                            (UWORD) (strlen(pTG->cbszFCQ) ),
                            ANS_LOCALCOMMAND_TIMEOUT,
                            0,
                            TRUE,
                            pTG->cbszCLASS2_OK,
                            pTG->cbszCLASS2_ERROR,
                            (C2PSTR) NULL))
    {
        DebugPrintEx(DEBUG_WRN,"FCQ failed");
        // Ignore CQ failure!!!
    }


    // Set the local ID - need ID from above to do this.
    bIDBuf[0] = '\0';
    uwLen = (UWORD)wsprintf(bIDBuf, pTG->cbszFLID, (LPSTR)szCSI);
    if(!Class2iModemDialog( pTG,
                            bIDBuf,
                            uwLen,
                            ANS_LOCALCOMMAND_TIMEOUT,
                            0,
                            TRUE,
                            pTG->cbszCLASS2_OK,
                            pTG->cbszCLASS2_ERROR,
                            (C2PSTR) NULL))
    {
        DebugPrintEx(DEBUG_WRN,"Local ID failed");
        // ignore failure
    }

    // Answer the phone

            // have to call hangup on every path out of here
            // after Answer is called. If Answer fails, it calls Hangup.
            // if it succeeds we have to call Hangup when we're done

    SignalStatusChange(pTG, FS_ANSWERED);

    PSSLogEntry(PSS_MSG, 0, "Phase A - Call establishment");
    PSSLogEntry(PSS_MSG, 1, "Answering...");

    if((uRet2 = Class2Answer(pTG)) != CONNECT_OK)
    {
        DebugPrintEx(DEBUG_ERR, "Failed to answer - aborting");
        // SignalStatusChange is called inside Class2Answer
        uRet1 = T30_CALLFAIL;
        RetCode = FALSE;
        goto done;
    }

    DebugPrintEx(DEBUG_MSG,"Done with Class2 Answer - succeeded");

    PSSLogEntry(PSS_MSG, 0, "Phase B - Negotiation");
    PSSLogEntry(PSS_MSG, 1, "CSI is %s", szCSI);
    PSSLogEntry(PSS_MSG, 1, "DIS was composed with the following capabilities:");
    LogClass2DISDetails(pTG, &pTG->DISPcb);

    // Receive the data
    uRet1 = (USHORT)Class20Receive(pTG );

    // t-jonb: If we've already called PutRecvBuf(RECV_STARTPAGE), but not
    // PutRecvBuf(RECV_ENDPAGE / DOC), then InFileHandleNeedsBeClosed==1, meaning
    // there's a .RX file that hasn't been copied to the .TIF file. Since the
    // call was disconnected, there will be no chance to send RTN. Therefore, we call
    // PutRecvBuf(RECV_ENDDOC_FORCESAVE) to keep the partial page and tell
    // rx_thrd to terminate.
    if (pTG->InFileHandleNeedsBeClosed)
    {
        if (! FlushFileBuffers (pTG->InFileHandle ) )
        {
            DebugPrintEx(DEBUG_WRN, "FlushFileBuffers FAILED LE=%lx", GetLastError());
            // Continue to save what we have
        }
        pTG->BytesIn = pTG->BytesInNotFlushed;
        ICommPutRecvBuf(pTG, NULL, RECV_ENDDOC_FORCESAVE);
    }

    if ( uRet1 == T30_CALLDONE)
    {
        DebugPrintEx(DEBUG_MSG,"******* DONE WITH CALL, ALL OK");

        // have to call hangup on every path out of here
        // we have to call Hangup here
        Class2ModemHangup(pTG );

        SignalStatusChange(pTG, FS_COMPLETED);
        RetCode = TRUE;

    }
    else
    {
        DebugPrintEx(DEBUG_ERR,"******* DONE WITH CALL, **** FAILED *****");

        // Make sure modem is in an OK state!
        FComXon(pTG, FALSE);
        // have to call hangup on every path out of here
        // Abort calls Hangup
        Class2ModemAbort(pTG );

        Class2SignalFatalError(pTG);
        RetCode = FALSE;
    }
    uRet2 = 0;

done:
    return RetCode;
}


BOOL Class20Receive(PThrdGlbl pTG)
{
    LPBUFFER        lpbf;
    SWORD           swRet;
    ULONG           lTotalLen=0;
    PCB             Pcb;
    USHORT          uTimeout=30000, uRet;
    BOOL            err_status;
    BC				bc;
    LPSTR           lpsTemp;
    DWORD           HiRes;


    DEBUG_FUNCTION_NAME("Class20Receive");


    /*
    * We have just answered!
    */

    // The repsonse to the ATA command is in the global variable
    // pTG->lpbResponseBuf2.

    if ( Class2ResponseAction(pTG, (LPPCB) &Pcb) == FALSE )
    {
        PSSLogEntry(PSS_ERR, 1, "Failed to parse response from ATA - aborting");
        err_status =  T30_CALLFAIL;
        return err_status;
    }

    PSSLogEntry(PSS_MSG, 1, "TSI is %s", Pcb.szID);
    PSSLogEntry(PSS_MSG, 1, "Received DCS is as follows");
    LogClass2DCSDetails(pTG, &Pcb);

    if (!Class2IsValidDCS(&Pcb))
    {
        PSSLogEntry(PSS_ERR, 1, "Received bad DCS parameters - aborting");
        err_status =  T30_CALLFAIL;
        return err_status;
    }

    if (!Class2UpdateTiffInfo(pTG, &Pcb))
    {
        DebugPrintEx(DEBUG_WRN, "Class2UpdateTiffInfo failed");
    }

    //Now that pcb is set up, call ICommReceiveParams to tell icomfile

    Class2InitBC(pTG, (LPBC)&bc, sizeof(bc), RECV_PARAMS);
    Class2PCBtoBC(pTG, (LPBC)&bc, sizeof(bc), &Pcb);

    if( ICommRecvParams(pTG, (LPBC)&bc) == FALSE )
    {
        DebugPrintEx(DEBUG_ERR,"Failed return from ICommRecvParams.");
        err_status =  T30_CALLFAIL;
        return err_status;
    }

    //
    // once per RX - create TIFF file as soon as we know the compression / resolution.
    //

    pTG->Encoding   = Pcb.Encoding;
    pTG->Resolution = Pcb.Resolution;

    if (Pcb.Resolution & (AWRES_mm080_077 |  AWRES_200_200) )
    {
        HiRes = 1;
    }
    else
    {
        HiRes = 0;
    }


    if ( !pTG->fTiffOpenOrCreated)
    {
        //
        // top 32bits of 64bit handle are guaranteed to be zero
        //
        pTG->Inst.hfile =  TiffCreateW ( pTG->lpwFileName,
                                         pTG->TiffInfo.CompressionType,
                                         pTG->TiffInfo.ImageWidth,
                                         FILLORDER_LSB2MSB,
                                         HiRes
                                         );

        if (! (pTG->Inst.hfile))
        {
            lpsTemp = UnicodeStringToAnsiString(pTG->lpwFileName);
            DebugPrintEx(   DEBUG_ERR,
                            "Can't create tiff file %s compr=%d",
                            lpsTemp,
                            pTG->TiffInfo.CompressionType);

            MemFree(lpsTemp);
            err_status =  T30_CALLFAIL;
            return err_status;

        }

        pTG->fTiffOpenOrCreated = 1;

        lpsTemp = UnicodeStringToAnsiString(pTG->lpwFileName);

        DebugPrintEx(   DEBUG_MSG,
                        "Created tiff file %s compr=%d HiRes=%d",
                        lpsTemp,
                        pTG->TiffInfo.CompressionType,
                        HiRes);

        MemFree(lpsTemp);
    }

    // **** Apparently, we don't want flow control on, so we'll turn
    // it off. Is this true???? If I turn it on, fcom.c fails a
    // debug check in filterreadbuf.
    FComXon(pTG, FALSE);


    // Send the FDR. The FDR must be responded to by a CONNECT.

    if (Class2iModemDialog( pTG,
                            pTG->cbszFDR,
                            (UWORD) (strlen(pTG->cbszFDR) ),
                            STARTSENDMODE_TIMEOUT,
                            0,
                            TRUE,
                            pTG->cbszFDT_CONNECT,
                            (C2PSTR) NULL) != 1)
    {
        DebugPrintEx(DEBUG_ERR,"Failed get response from initial FDR");
        if (pTG->fFoundFHNG)
        {
            PSSLogEntry(PSS_ERR, 1, "Call was disconnected");
        }
        err_status =  T30_CALLFAIL;
        return err_status;
    }
        
    DebugPrintEx(DEBUG_MSG,"FDR Received %s", (LPSTR)(&(pTG->lpbResponseBuf2)));
    // Might have to search through FDR response, but I doubt it.

    PSSLogEntry(PSS_MSG, 0, "Phase C - Receive page");

    // Now we need to send a DC2 (0x12) to tell the modem it is OK
    // to give us data.
    // Some modems use ^Q instead of ^R - The correct value was written
    // into the DC@ string in Class20Callee where we checked for
    // manufacturer
    PSSLogEntry(PSS_MSG, 2, "send: <DC2> (=ASCII %d)", *(pTG->CurrentMFRSpec.szDC2));
    FComDirectSyncWriteFast(pTG, pTG->CurrentMFRSpec.szDC2, 1);


    // Now we can receive the data and give it to the icomfile routine

    err_status =  T30_CALLDONE;

    while ((swRet=(SWORD)ICommPutRecvBuf(pTG, NULL, RECV_STARTPAGE)) == TRUE)
    {
        PSSLogEntry(PSS_MSG, 1, "Receiving page %d data...", pTG->PageCount+1);

        // The READ_TIMEOUT is used to timeout calls to ReadBuf() either in the
        #define READ_TIMEOUT    15000

        lTotalLen = 0;
        do
        {
            DebugPrintEx(DEBUG_MSG,"In receiving a page loop");
            uRet=Class2ModemRecvBuf(pTG, &lpbf, READ_TIMEOUT);
            if(lpbf)
            {
                lTotalLen += lpbf->wLengthData;
                DebugPrintEx(DEBUG_MSG,"In lpbf if. Total Length %ld", lTotalLen);

                if(!ICommPutRecvBuf(pTG, lpbf, RECV_SEQ))
                {
                    DebugPrintEx(DEBUG_ERR,"Bad return - PutRecvBuf in page");
                    err_status=T30_CALLFAIL;
                    return err_status;
                }
                lpbf = 0;
            }
        }
        while(uRet == RECV_OK);

        PSSLogEntry(PSS_MSG, 2, "recv:     page %d data, %d bytes", pTG->PageCount+1, lTotalLen);

        if(uRet == RECV_EOF)
        {
            DebugPrintEx(DEBUG_MSG,"Got EOF from RecvBuf");

            // RSL needed interface to TIFF thread
            pTG->fLastReadBlock = 1;
            ICommPutRecvBuf(pTG, NULL, RECV_FLUSH);
        }
        else
        {
            // Timeout from ModemRecvBuf
            BYTE bCancel = 0x18;
            DebugPrintEx(DEBUG_ERR,"ModemRecvBuf Timeout or Error=%d", uRet);
            PSSLogEntry(PSS_ERR, 1, "Failed to receive page data - aborting");
            PSSLogEntry(PSS_MSG, 2, "send: <can> (=ASCII 24)");
            FComDirectSyncWriteFast(pTG, &bCancel, 1);
            err_status = T30_CALLFAIL;
            return err_status;
        }

        PSSLogEntry(PSS_MSG, 1, "Successfully received page data");
        PSSLogEntry(PSS_MSG, 0, "Phase D - Post Message Exchange");

        // See if more pages to receive by parsing the FDR response...
        // After the DLEETX was received by Class2ModemRecvBuf, the
        // FPTS and FET response should be coming from the modem, terminated
        // by an OK. Let's go read that!

        if (Class2iModemDialog(pTG,
                                NULL,
                                0,
                                STARTSENDMODE_TIMEOUT,
                                0,
                                TRUE,
                                pTG->cbszCLASS2_OK,
                                (C2PSTR)NULL) != 1)
        {
            PSSLogEntry(PSS_ERR, 1, "Failed to receive EOP or MPS or EOM - aborting");
            err_status =  T30_CALLFAIL;
            return err_status;
        }
        if (pTG->fFoundFHNG)
        {
            PSSLogEntry(PSS_ERR, 1, "Call was disconnected");
            err_status =  T30_CALLFAIL;
            return err_status;
        }

        DebugPrintEx(DEBUG_MSG,"EOP Received %s",(LPSTR)(&(pTG->lpbResponseBuf2)));

        // Process the response and see if more pages are coming

        if (Class2EndPageResponseAction(pTG ) == MORE_PAGES)
        {
            // t-jonb: Here, we should be sending AT+FPS=1 or AT+FPS=2, according to fPageIsBad.
            // However, some modems (observed on USR Courier V.34 and USR Sportster 33.6)
            // don't understand it. So, we have to work with the modem's own quality assessment.
            // For class 2.0, ICommPutRecvBuf will decide whether to save the page based the
            // value from modem's +FPS: response (Saved in pTG->FPTSreport by
            // Class2EndPageResponseAction).
            ICommPutRecvBuf(pTG, NULL, RECV_ENDPAGE);
            if (pTG->fPageIsBadOverride)
            {
                err_status = T30_CALLFAIL;  // User will see "partially received"
            }

            PSSLogEntry(PSS_MSG, 1, "sent MCF");   // Sending RTN is not yet implemented

            // Now, Send the FDR to start the next page (this was done for
            // the first page before entering the multipage loop).

            if (Class2iModemDialog( pTG,
                                    pTG->cbszFDR,
                                    (UWORD)(strlen(pTG->cbszFDR) ),
                                    STARTSENDMODE_TIMEOUT,
                                    0,
                                    TRUE,
                                    pTG->cbszFDT_CONNECT,
                                    (C2PSTR) NULL) != 1)
            {
                DebugPrintEx(DEBUG_ERR,"FDR to start next PAGE Failed!");
                if (pTG->fFoundFHNG)
                {
                    PSSLogEntry(PSS_ERR, 1, "Call was disconnected");
                }
                err_status =  T30_CALLFAIL;
                return err_status;
            }

            // Need to check whether modem performed re-negotiation, and
            // update the TIFF accordingly
            if (Class2ResponseAction(pTG, (LPPCB) &Pcb))
            {
                PSSLogEntry(PSS_MSG, 1, "Received DCS is as follows");
                LogClass2DCSDetails(pTG, &Pcb);
                if (!Class2UpdateTiffInfo(pTG, &Pcb))
                {
                    DebugPrintEx(DEBUG_WRN, "Class2UpdateTiffInfo failed");
                }
            }

            PSSLogEntry(PSS_MSG, 0, "Phase C - Receive page");
            PSSLogEntry(PSS_MSG, 2, "send: <DC2> (=ASCII %d)", *(pTG->CurrentMFRSpec.szDC2));
            // Now send the correct DC2 string set in Class20Callee
            // (DC2 is standard, some use ^q instead)
            FComDirectSyncWriteFast(pTG, pTG->CurrentMFRSpec.szDC2, 1);

        } //if we do not have another page, do the else...
        else
        {
            break; // All done receiving pages...
        }
    } //End of multipage while

    DebugPrintEx(DEBUG_MSG,"out of while multipage loop. about to send final FDR.");
    //RSL
    ICommPutRecvBuf(pTG, NULL, RECV_ENDDOC);
    if (pTG->fPageIsBadOverride)
    {
        err_status = T30_CALLFAIL;  // User will see "partially received"
    }


    // Send end of message sequence
    // Send the last FPTS - do we really need to do this???

    // Send last FDR
    if(!Class2iModemDialog( pTG,
                            pTG->cbszFDR,
                            (UWORD) (strlen(pTG->cbszFDR) ),
                            STARTSENDMODE_TIMEOUT,
                            0,
                            TRUE,
                            pTG->cbszCLASS2_OK,
                            (C2PSTR)NULL))
    {
        err_status =  T30_CALLFAIL;
        return err_status;
    }

    PSSLogEntry(PSS_MSG, 1, "sent MCF");   // Sending RTN is not yet implemented

    FComXon(pTG, FALSE);

    return err_status;

}


BOOL Class20Parse(PThrdGlbl pTG, CL2_COMM_ARRAY *cl2_comm, BYTE lpbBuf[])
{
    int     i,
            j,
            comm_numb = 0,
            parameters;
    BYTE    switch_char,
            char_1,
            char_2;
    char    c;

    BOOL    found_command = FALSE;

    DEBUG_FUNCTION_NAME("Class20Parse");


    #define STRING_PARAMETER        1
    #define NUMBER_PARAMETERS       2
    for(i = 0; lpbBuf[i] != '\0'; ++i)
    {
        if (comm_numb >= MAX_CLASS2_COMMANDS)
        {
            DebugPrintEx(DEBUG_WRN, "Reached maximum number of commands");
            break;
        }
        
        switch ( lpbBuf[i] )
        {
        case 'C':
                if (lpbBuf[++i] == 'O' && lpbBuf[++i] == 'N')
                {
                    cl2_comm->command[comm_numb++] = CL2DCE_CONNECT;
                    for(; lpbBuf[i] != '\r'; ++i )
                            ;
                }
                else
                {
                    DebugPrintEx(DEBUG_ERR,"Parse: Bad First C values");
                    return FALSE;
                }
                break;

        case 'O':
                if (lpbBuf[++i] == 'K' )
                {
                    cl2_comm->command[comm_numb++] = CL2DCE_OK;
                    for(; lpbBuf[i] != '\r'; ++i )
                            ;
                }
                else
                {
                    DebugPrintEx(DEBUG_ERR, "Parse: Bad O values");
                    return FALSE;
                }
                break;

        case 0x11:
                cl2_comm->command[comm_numb++] = CL2DCE_XON;
                break;

        case '+':
                if( lpbBuf[++i] != 'F' )
                {
                    DebugPrintEx(DEBUG_ERR, "Parse: Bad + values");
                    return FALSE;
                }
                switch_char = lpbBuf[++i];
                char_1 = lpbBuf[++i];
                char_2 = lpbBuf[++i];
                switch ( switch_char )
                {
                        case 'C':
                                //  Connect Message +FCON.
                                if ( char_1 == 'O' )
                                {
                                    cl2_comm->command[comm_numb] = CL2DCE_FCON;
                                    parameters = FALSE;
                                }

                                // Report of Remote ID. +FCIG.
                                else if (char_1 == 'I' )
                                {
                                    cl2_comm->command[comm_numb] = CL2DCE_FCSI;
                                    parameters = STRING_PARAMETER;
                                }
                                // Report DCS frame information +FCS - Clanged for Class2.0
                                else if ( char_1 == 'S' )
                                {
                                    cl2_comm->command[comm_numb] = CL2DCE_FDCS;
                                    parameters = NUMBER_PARAMETERS;
                                }
                                else
                                {
                                    DebugPrintEx(DEBUG_ERR, "Parse: Bad C values");
                                    return FALSE;
                                }
                                break;

                        case 'D':
                                if ( char_1 == 'M' )
                                {
                                      cl2_comm->command[comm_numb] = CL2DCE_FDM;
                                      parameters = NUMBER_PARAMETERS;
                                }
                                else
                                {
                                      DebugPrintEx(DEBUG_ERR,"Parse: Bad D values");
                                      return FALSE;
                                }
                                break;

                        case 'E':
                                // Post page message report. +FET.
                                if ( char_1 == 'T' )
                                {
                                    --i;
                                    cl2_comm->command[comm_numb] = CL2DCE_FET;
                                    parameters = NUMBER_PARAMETERS;
                                }
                                else
                                {
                                    DebugPrintEx(DEBUG_ERR, "Parse: Bad E values");
                                    return FALSE;
                                }
                                break;

                        case 'H':
                        // Debug report transmitted HDLC frames +FHT
                                if ( char_1 == 'T' )
                                {
                                    --i;
                                    cl2_comm->command[comm_numb] = CL2DCE_FHT;
                                    parameters = STRING_PARAMETER;
                                }
                        // Debug report received HDLC frames +FHR
                                if ( char_1 == 'R' )
                                {
                                    --i;
                                    cl2_comm->command[comm_numb] = CL2DCE_FHR;
                                    parameters = STRING_PARAMETER;
                                }
                                // Report hang up.  +FHNG.
                                else if ( char_1 == 'S' )
                                {
                                    cl2_comm->command[comm_numb] = CL2DCE_FHNG;
                                    parameters = NUMBER_PARAMETERS;
                                    DebugPrintEx(DEBUG_MSG, "Found FHNG");
                                    pTG->fFoundFHNG = TRUE;
                                }
                                else
                                {
                                    DebugPrintEx(DEBUG_ERR, "Parse: Bad H values");
                                    return FALSE;
                                }
                                break;

                        case 'I':
                                // Report DIS frame information +FIS - Changed for Class2.0
                                if ( char_1 == 'S' )
                                {
                                      cl2_comm->command[comm_numb] = CL2DCE_FDIS;
                                      parameters = NUMBER_PARAMETERS;
                                }
                                else
                                {
                                      DebugPrintEx(DEBUG_ERR,"Parse: Bad I values");
                                      return FALSE;
                                }
                                break;

                        case 'N':
                                // Report NSF frame reciept.
                                if ( char_1 == 'F' )
                                {
                                    cl2_comm->command[comm_numb] = CL2DCE_FNSF;
                                    parameters = NUMBER_PARAMETERS;
                                }
                                // Report NSS frame reciept.
                                else if ( char_1 == 'S' )
                                {
                                    cl2_comm->command[comm_numb] = CL2DCE_FNSS;
                                    parameters = NUMBER_PARAMETERS;
                                }
                                // Report NSC frame reciept.
                                else if ( char_1 == 'C' )
                                {
                                    cl2_comm->command[comm_numb] = CL2DCE_FNSC;
                                    parameters = NUMBER_PARAMETERS;
                                }
                                else
                                {
                                    DebugPrintEx(DEBUG_ERR, "Parse: Bad N values");
                                    return FALSE;
                                }
                                break;

                       case 'P':

                                // Report of Remote ID. +FPI - Changed for Class2.0
                                if (char_1 == 'I')
                                {
                                    cl2_comm->command[comm_numb] = CL2DCE_FCIG;
                                    parameters = STRING_PARAMETER;
                                }
                                // Report poll request. +FPO - Changed for Class2.0
                                else if ( char_1 == 'O' )
                                {
                                    cl2_comm->command[comm_numb] = CL2DCE_FPOLL;
                                    parameters = FALSE;
                                }
                                // Page Transfer Status Report +FPS - Changed for Class2.0
                                else if ( char_1 == 'S' )
                                {
                                    cl2_comm->command[comm_numb] = CL2DCE_FPTS;
                                    parameters = NUMBER_PARAMETERS;
                                }
                                else
                                {
                                    DebugPrintEx(DEBUG_ERR,"Parse: Bad P values");
                                    return FALSE;
                                }
                                break;

                        case 'T':

                                // Report DTC frame information +FTC - Changed for Class2.0
                                if ( char_1 == 'C' )
                                {
                                      cl2_comm->command[comm_numb] = CL2DCE_FDTC;
                                      parameters = NUMBER_PARAMETERS;
                                }
                                // Report remote ID +FTI - Changed for Class2.0
                                else if ( char_1 == 'I' )
                                {
                                      cl2_comm->command[comm_numb] = CL2DCE_FTSI;
                                      parameters = STRING_PARAMETER;
                                }
                                else
                                {
                                      DebugPrintEx(DEBUG_ERR,"Parse: Bad T values");
                                      return FALSE;
                                }
                                break;

                        case 'V':
                                // Report voice request +FVOICE.
                                if ( char_1 == 'O' )
                                {
                                    cl2_comm->command[comm_numb] = CL2DCE_FVOICE;
                                    parameters = FALSE;
                                }
                                else
                                {
                                    DebugPrintEx(DEBUG_ERR, "Parse: Bad V values");
                                    return FALSE;
                                }
                }

                //  Transfer the associated paramters to the parameter array.
                if (parameters == NUMBER_PARAMETERS)
                {
                    for (i+=1,j=0; lpbBuf[i] != '\r' && lpbBuf[i] != '\0'; ++i)
                    {
                        //  Skip past the non numeric characters.
                        if ( lpbBuf[i] < '0' || lpbBuf[i] > '9' )
                        {
                            continue;
                        }

                        /*  Convert the character representation of the numeric
                                 parameter into a true number, and store in the
                                parameter list.  */
                        cl2_comm->parameters[comm_numb][j] = 0;

                        for (; lpbBuf[i] >= '0' && lpbBuf[i] <= '9'; ++i)
                        {
                            cl2_comm->parameters[comm_numb][j] *= 10;
                            cl2_comm->parameters[comm_numb][j] += lpbBuf[i] - '0';
                        }
                        i--; // the last for loop advanced 'i' past the numeric.
                        j++; // get set up for next parameter
                    }
                }
                else if (parameters == STRING_PARAMETER )
                {
                    // Skip the : that follows the +f command (eg +FTSI:)
                    if (lpbBuf[i+1] == ':')
                    {
                        i++;
                    }
                    // Also skip leading blanks
                    while (lpbBuf[i+1] == ' ')
                    {
                        i++;
                    }
                    for (i+=1, j=0; (j < MAX_PARAM_LENGTH-1) &&
                                    (c = lpbBuf[i])  != '\r' && c != '\n' && c != '\0'; ++i, ++j)
                    {
                        cl2_comm->parameters[comm_numb][j] = c;
                        if ( lpbBuf[i] == '\"' )
                        {
                            --j;
                        }
                    }
                    cl2_comm->parameters[comm_numb][j] = '\0';
                }
                //  No parameters, so just skip to end of line.
                else
                {
                    for(; (c=lpbBuf[i]) != '\r' && c != '\n' && c != '\0'; ++i)
                        ;
                }

                if (cl2_comm->command[comm_numb] == CL2DCE_FHNG)
                {
                    pTG->dwFHNGReason = cl2_comm->parameters[comm_numb][0];
                    DebugPrintEx(DEBUG_MSG, "Found FHNG, reason = %d", pTG->dwFHNGReason);
                }

                //  Increment command count.
                ++comm_numb;
                break;

        default:
                break;
        }
    }
    cl2_comm->comm_count = (USHORT)comm_numb;
    return TRUE;
}
=== C:/Users/treeman/Desktop/windows nt source code\Source\Win2K3\NT\printscan\faxsrv\provider\t30\cl2and20\class2.c ===
/*++

Copyright (c) 1997  Microsoft Corporation

Module Name:

    class2.c

Abstract:

    This is the main source for Class2 specific functions for fax-modem T.30 driver

Author:
    Source base was originated by Win95 At Work Fax package.
    RafaelL - July 1997 - port to NT

Revision History:

--*/


#define USE_DEBUG_CONTEXT DEBUG_CONTEXT_T30_CLASS2


#include "prep.h"
#include "efaxcb.h"

#include "tiff.h"

#include "glbproto.h"
#include "t30gl.h"
#include "cl2spec.h"

#include "psslog.h"
#define FILE_ID FILE_ID_CLASS2
#include "pssframe.h"

#define STRSAFE_NO_DEPRECATE
#include <strsafe.h>

extern WORD CodeToBPS[16];
extern UWORD rguwClass2Speeds[];
extern DWORD PageWidthInPixelsFromDCS[];


// Here is the table we are using so far for manufacturer specific stuff

MFRSPEC Class2ModemTable[] = {
        { "Practical Peripherals", "PM14400FXPPM", 1, 2, "", FALSE, FALSE, FALSE, FALSE },
        { "Practical Peripherals", "PM9600FXMT",   1, 2, "", FALSE, FALSE, FALSE ,FALSE },
        { "Everex Systems", "Everfax 24/96E",      0, 2, "", FALSE, FALSE, FALSE, FALSE },
        { "ROCKWELL", "V.32AC",                    1, 2, "", FALSE, FALSE, FALSE, FALSE },
        { "ROCKWELL", "RC9624AC",                  1, 2, "", FALSE, FALSE, FALSE, FALSE },
        { "Multi-Tech", "MT1432BA",                0, 0, "", FALSE, FALSE, FALSE, FALSE },
        { "SIERRA", "SX196",                       1, 0, "", TRUE,  FALSE, FALSE, FALSE },
        { "EXAR", "ROCKWELL 144DP",                1, 0, "", FALSE, TRUE,  FALSE, FALSE },
        { "ELSA", "MicroLink 2460TL",              1, 0, "", FALSE, TRUE,  FALSE, FALSE },
        { "GVC", "ROCKWELL 144DP",                 1, 0, "", FALSE, TRUE,  TRUE , FALSE }, // Intel144Ex
        { "ADC", "SL144V32",                       1, 0, "", FALSE, TRUE,  FALSE, FALSE },
        { "UMC", "",                               1, 0, "", FALSE, TRUE,  FALSE ,FALSE },
        { "NetComm", "",                           1, 0, "", FALSE, TRUE,  FALSE, FALSE },
        { "HALCYON", "Bit Blitzer",                0, 0, "", FALSE, FALSE, FALSE, FALSE },
        { "", "",                                  1, 0, "", FALSE, FALSE, FALSE, FALSE }
        };




void
Class2Init(
     PThrdGlbl pTG
)

{
   pTG->lpCmdTab = 0;

   pTG->Class2bDLEETX[0] = DLE;
   pTG->Class2bDLEETX[1] = ETX;
   pTG->Class2bDLEETX[2] = 0;


   sprintf( pTG->cbszFDT,          "AT+FDT\r" );
   sprintf( pTG->cbszFDR,          "AT+FDR\r" );
   sprintf( pTG->cbszFPTS,         "AT+FPTS=%%d\r" );
   sprintf( pTG->cbszFCR,          "AT+FCR=1\r" );
   sprintf( pTG->cbszFCQ,          "AT+FCQ=0\r" );
   sprintf( pTG->cbszFBUG,         "AT+FBUG=0\r" );
   sprintf( pTG->cbszSET_FBOR,     "AT+FBOR=%%d\r" );

   // DCC - set High Res, Huffman, no ECM/BFT, default all others.

   sprintf( pTG->cbszFDCC_ALL,      "AT+FDCC=%%d,%%d,,,0,0,0,\r" );
   sprintf( pTG->cbszFDCC_RECV_ALL, "AT+FDCC=1,%%d,0,2,0,0,0,\r" );
   sprintf( pTG->cbszFDIS_RECV_ALL, "AT+FDIS=1,%%d,0,2,0,0,0,\r" );
   sprintf( pTG->cbszFDCC_RES,      "AT+FDCC=%%d\r" );
   sprintf( pTG->cbszFDCC_RECV_RES, "AT+FDCC=1\r" );
   sprintf( pTG->cbszFDCC_BAUD,     "AT+FDCC=%%d,%%d\r" );
   sprintf( pTG->cbszFDIS_BAUD,     "AT+FDIS=1,%%d\r" );
   sprintf( pTG->cbszFDIS_IS,       "AT+FDIS?\r" );
   sprintf( pTG->cbszFDIS_NOQ_IS,   "AT+FDIS\r" );
   sprintf( pTG->cbszFDCC_IS,       "AT+FDCC?\r" );
   sprintf( pTG->cbszFDIS_STRING,   "+FDIS" );
   sprintf( pTG->cbszFDIS,          "AT+FDIS=%%1d,%%1d,%%1d,%%1d,%%1d,0,0,0\r" );
   sprintf( pTG->cbszONE,           "1" );

   sprintf( pTG->cbszCLASS2_FMFR,       "AT+FMFR?\r" );
   sprintf( pTG->cbszCLASS2_FMDL,       "AT+FMDL?\r" );

   sprintf( pTG->cbszFDT_CONNECT,       "CONNECT" );
   sprintf( pTG->cbszFCON,              "+FCON" );
   sprintf( pTG->cbszFLID,              "AT+FLID=\"%%s\"\r" );
   sprintf( pTG->cbszENDPAGE,           "AT+FET=0\r" );
   sprintf( pTG->cbszENDMESSAGE,        "AT+FET=2\r" );
   sprintf( pTG->cbszCLASS2_ATTEN,      "AT\r" );
   sprintf( pTG->cbszATA,               "ATA\r" );

   sprintf( pTG->cbszCLASS2_HANGUP,     "ATH0\r" );
   sprintf( pTG->cbszCLASS2_CALLDONE,   "ATS0=0\r" );
   sprintf( pTG->cbszCLASS2_ABORT,      "AT+FK\r" );
   sprintf( pTG->cbszCLASS2_DIAL,       "ATD%%c %%s\r" );
   sprintf( pTG->cbszCLASS2_NODIALTONE, "NO DIAL" );
   sprintf( pTG->cbszCLASS2_BUSY,       "BUSY" );
   sprintf( pTG->cbszCLASS2_NOANSWER,   "NO ANSWER" );
   sprintf( pTG->cbszCLASS2_OK,         "OK" );
   sprintf( pTG->cbszCLASS2_FHNG,       "+FHNG" );
   sprintf( pTG->cbszCLASS2_ERROR,      "ERROR" );
   sprintf( pTG->cbszCLASS2_NOCARRIER,  "NO CARRIER" );


   Class2SetProtParams(pTG, &pTG->Inst.ProtParams);

}


/*++
Routine Description:
    Issue "AT+FDIS=?" command, parse response into pTG->DISPcb

Return Value:
    TRUE - success, FALSE - failure
--*/
BOOL Class2GetDefaultFDIS(PThrdGlbl pTG)
{
    UWORD   uwRet=0;
    BYTE    bTempBuf[200+RESPONSE_BUF_SIZE];
    LPBYTE  lpbyte;
    HRESULT hr;

    DEBUG_FUNCTION_NAME("Class2GetDefaultFDIS");

    // Find out what the default DIS is
    if (!pTG->CurrentMFRSpec.bIsExar)
    {
        if (!(uwRet=Class2iModemDialog( pTG,
                                        pTG->cbszFDIS_IS,
                                        (UWORD)(strlen(pTG->cbszFDIS_IS)),
                                        LOCALCOMMAND_TIMEOUT,
                                        0,
                                        TRUE,
                                        pTG->cbszCLASS2_OK,
                                        pTG->cbszCLASS2_ERROR,
                                        (C2PSTR) NULL)))
        {
            DebugPrintEx(DEBUG_WRN,"FDIS failed");
            // ignore
        }
    }

    // See if the reply was ERROR or timeout, if so try a different command
    // Exar modems, for example, don't take AT+FDIS?
    if ((uwRet==2)||(uwRet==0)||pTG->CurrentMFRSpec.bIsExar)
    {
        // FDIS did not work!!! Try FDCC?
        if (!(uwRet=Class2iModemDialog( pTG,
                                        pTG->cbszFDCC_IS,
                                        (UWORD)(strlen(pTG->cbszFDCC_IS)),
                                        LOCALCOMMAND_TIMEOUT,
                                        0,
                                        TRUE,
                                        pTG->cbszCLASS2_OK,
                                        pTG->cbszCLASS2_ERROR,
                                        (C2PSTR) NULL)))
        {
            DebugPrintEx(DEBUG_WRN,"FDCC_IS failed");
                // Ignore
        }

        if ((uwRet==2)||(uwRet==0))
        {
            // The FDCC failed - maybe it is an Exar that likes FDIS?
            // try that
            if (!(uwRet=Class2iModemDialog( pTG,
                                            pTG->cbszFDIS_IS,
                                            (UWORD)(strlen(pTG->cbszFDIS_IS)),
                                            LOCALCOMMAND_TIMEOUT,
                                            0,
                                            TRUE,
                                            pTG->cbszCLASS2_OK,
                                            pTG->cbszCLASS2_ERROR,
                                            (C2PSTR) NULL)))
            {
                DebugPrintEx(DEBUG_WRN,"FDIS_IS failed");
                //ignore
            }
            // Maybe it is the Class 2 modem referred to in
            // Elliot bug #1238 that wants FDIS without a
            // question mark
            if ((uwRet==2)||(uwRet==0))
            {
                if (!(uwRet=Class2iModemDialog( pTG,
                                                pTG->cbszFDIS_NOQ_IS,
                                                (UWORD)(strlen(pTG->cbszFDIS_NOQ_IS)),
                                                LOCALCOMMAND_TIMEOUT,
                                                0,
                                                TRUE,
                                                pTG->cbszCLASS2_OK,
                                                (C2PSTR) NULL)))
                {
                    // No FDIS, FDCC worked - quit!
                    DebugPrintEx(DEBUG_ERR,"No FDIS? or FDCC? worked");
                    return FALSE;
                }
            }
        }

        // If the first character in the reply before a number
        // is a ',', insert a '1' for normal & fine res (Exar hack)
        for (lpbyte = pTG->lpbResponseBuf2; *lpbyte != '\0'; lpbyte++)
        {
            if (*lpbyte == ',')
            {
                // found a leading comma
                hr = StringCchPrintf(bTempBuf, ARR_SIZE(bTempBuf), "%s%s", pTG->cbszONE, lpbyte);
            	if (FAILED(hr))
            	{
            		DebugPrintEx(DEBUG_WRN,"StringCchPrintf failed (ec=0x%08X)",hr);
            	}
            	else
            	{
                    hr = StringCchCopy(lpbyte, ARR_SIZE(pTG->lpbResponseBuf2) - (lpbyte-pTG->lpbResponseBuf2), bTempBuf);
                	if (FAILED(hr))
                	{
                		DebugPrintEx(DEBUG_WRN,"StringCchCopy failed (ec=0x%08X)",hr);
                	}
            	}
                DebugPrintEx(DEBUG_MSG, "Leading comma in DCC string =%s", (LPSTR)&pTG->lpbResponseBuf2);
            }

            if ((*lpbyte>='0')&&(*lpbyte<='9'))
            {
                break;
            }
        }
    }

    // If the repsonse was just a number string without "+FDIS" in front
    // of it, add the +FDIS. Some modem reply with it, some do not. The
    // general parsing algorithm used below in Class2ResponseAction needs
    // to know the command that the numbers refer to.
    if ( pTG->lpbResponseBuf2[0] != '\0' &&
       (strstr((LPSTR)pTG->lpbResponseBuf2, (LPSTR)pTG->cbszFDIS_STRING)==NULL))
    {
        // did not get the FDIS in the response!
        hr = StringCchPrintf(bTempBuf, ARR_SIZE(bTempBuf), "%s: %s", pTG->cbszFDIS_STRING, pTG->lpbResponseBuf2);
    	if (FAILED(hr))
    	{
    		DebugPrintEx(DEBUG_WRN,"StringCchPrintf failed (ec=0x%08X)",hr);
    	}
    	else
    	{
            hr = StringCchCopy(pTG->lpbResponseBuf2, ARR_SIZE(pTG->lpbResponseBuf2), bTempBuf);
        	if (FAILED(hr))
        	{
        		DebugPrintEx(DEBUG_WRN,"StringCchCopy failed (ec=0x%08X)",hr);
        	}
    	}
    }

    DebugPrintEx(DEBUG_MSG, "Received %s from FDIS", (LPSTR)(&(pTG->lpbResponseBuf2)));

    // Process default DIS to see if we have to send a DCC to change
    // it. Some modems react badly to just sending a DCC with ",,,"
    // so we can't rely on the modem keeping DIS parameters unchanged
    // after a DCC like that. We'll use the FDISResponse routine to load
    // the default DIS values into a PCB structure
    if (Class2ResponseAction(pTG, (LPPCB) &pTG->DISPcb) == FALSE)
    {
        DebugPrintEx(DEBUG_WRN,"Failed to process FDIS Response");
        return FALSE;
    }

    return TRUE;
}


BOOL T30Cl2Tx(PThrdGlbl pTG,LPSTR szPhone)
{
    USHORT  uRet1, uRet2;
    BYTE    bBuf[200];
    UWORD   Encoding, Res, PageWidth, PageLength, uwLen;
    BYTE    bIDBuf[200+max(MAXTOTALIDLEN,20)+4];
    CHAR    szTSI[max(MAXTOTALIDLEN,20)+4] = {0};
    BOOL    fBaudChanged;
    BOOL    RetCode;

    DEBUG_FUNCTION_NAME("T30Cl2Tx");

    uRet2 = 0;
    if (!(pTG->lpCmdTab = iModemGetCmdTabPtr(pTG)))
    {
        DebugPrintEx(DEBUG_ERR,"iModemGetCmdTabPtr failed");
        uRet1 = T30_CALLFAIL;

        pTG->fFatalErrorWasSignaled = 1;
        SignalStatusChange(pTG, FS_FATAL_ERROR);
        RetCode = FALSE;

        goto done;
    }

    // first get SEND_CAPS if possible.

    if (!Class2GetBC(pTG, SEND_CAPS)) // get send caps
    {
        DebugPrintEx(DEBUG_ERR,"Class2GetBC failed");
        uRet1 = T30_CALLFAIL;

        pTG->fFatalErrorWasSignaled = 1;
        SignalStatusChange(pTG, FS_FATAL_ERROR);
        RetCode = FALSE;

        goto done;
    }

    // Go to Class2
    if (!iModemGoClass(pTG, 2))
    {
        DebugPrintEx(DEBUG_ERR,"Failed to Go to Class 2");
        uRet1 = T30_CALLFAIL;

        pTG->fFatalErrorWasSignaled = 1;
        SignalStatusChange(pTG, FS_FATAL_ERROR);
        RetCode = FALSE;

        goto done;
    }

    // Begin by checking for manufacturer and ATI code.
    // Look this up against the modem specific table we
    // have and set up the send strings needed for
    // this modem.
    if (!Class2GetModemMaker(pTG))
    {
        DebugPrintEx(DEBUG_WRN,"Call to GetModemMaker failed");
        // Ignore failure!!!
    }

    // set manufacturer specific strings
    Class2SetMFRSpecific(pTG);

    // Get the capabilities of the software. I am only using this
    // right now for the TSI field (below where I send +FLID).
    // Really, this should also be used instead of the hardcoded DIS
    // values below.
    // ALL COMMANDS LOOK FOR MULTILINE RESPONSES WHILE MODEM IS ONHOOK.
    // A "RING" COULD APPEAR AT ANY TIME!
    Class2SetDIS_DCSParams( pTG,
                            SEND_CAPS,
                            (LPUWORD)&Encoding,
                            (LPUWORD)&Res,
                            (LPUWORD)&PageWidth,
                            (LPUWORD)&PageLength,
                            (LPSTR) szTSI,
							sizeof(szTSI)/sizeof(szTSI[0]));
    bIDBuf[0] = '\0';
    uwLen = (UWORD)wsprintf(bIDBuf, pTG->cbszFLID, (LPSTR)szTSI);

    if (!Class2iModemDialog(pTG,
                            bIDBuf,
                            uwLen,
                            LOCALCOMMAND_TIMEOUT,
                            0,
                            TRUE,
                            pTG->cbszCLASS2_OK,
                            pTG->cbszCLASS2_ERROR,
                            (C2PSTR) NULL))
    {
        DebugPrintEx(DEBUG_WRN,"Local ID failed");
        // ignore failure
    }

    // Turn off Bug mode
    if (!Class2iModemDialog(pTG,
                            pTG->cbszFBUG,
                            (UWORD)(strlen(pTG->cbszFBUG)),
                            LOCALCOMMAND_TIMEOUT,
                            0,
                            TRUE,
                            pTG->cbszCLASS2_OK,
                            pTG->cbszCLASS2_ERROR,
                            (C2PSTR) NULL))
    {
        DebugPrintEx(DEBUG_WRN,"FBUG failed");
        // Ignore FBUG failure!!!
    }

    // Find out what the default DIS is
    if (!Class2GetDefaultFDIS(pTG))
    {
        DebugPrintEx(DEBUG_ERR, "Class2GetDefaultFDIS failed");
        pTG->fFatalErrorWasSignaled = 1;
        SignalStatusChange(pTG, FS_FATAL_ERROR);
        RetCode = FALSE;
        goto done;
    }

    fBaudChanged = FALSE;
    // See if we have to change the baud rate to a lower value.
    // This only happens if the user set an ini string constraining
    // the high end speed or if the user turned off V.17 for sending
    // Check the V.17 inhibit and lower baud if necessary
    if ((pTG->DISPcb.Baud>3)&&(!pTG->ProtParams2.fEnableV17Send))
    {
        DebugPrintEx(DEBUG_MSG, "Lowering baud from %d for V.17 inihibit", CodeToBPS[pTG->DISPcb.Baud]);

        pTG->DISPcb.Baud = 3; //9600 won't use V.17
        fBaudChanged = TRUE;
    }

    // Now see if the high end baud rate has been constrained
    if  (   (pTG->ProtParams2.HighestSendSpeed != 0) &&
            (CodeToBPS[pTG->DISPcb.Baud] > (WORD)pTG->ProtParams2.HighestSendSpeed))
    {
        DebugPrintEx(   DEBUG_MSG,
                        "Have to lower baud from %d to %d",
                        CodeToBPS[pTG->DISPcb.Baud],
                        pTG->ProtParams2.HighestSendSpeed);

        fBaudChanged = TRUE;
        switch (pTG->ProtParams2.HighestSendSpeed)
        {
        case 2400:  pTG->DISPcb.Baud = 0;
                    break;
        case 4800:  pTG->DISPcb.Baud = 1;
                    break;
        case 7200:  pTG->DISPcb.Baud = 2;
                    break;
        case 9600:  pTG->DISPcb.Baud = 3;
                    break;
        case 12000: pTG->DISPcb.Baud = 4;
                    break;
        default:    DebugPrintEx(DEBUG_MSG,"Bad HighestSpeed");
                    uRet1 = T30_CALLFAIL;
                    pTG->fFatalErrorWasSignaled = 1;
                    SignalStatusChange(pTG, FS_FATAL_ERROR);
                    RetCode = FALSE;
                    goto done;
                    break;
        }
    }

    // Now, look and see if any of the values in the DIS are "bad"
    // That is, make sure we can send high res and we are not
    // claiming that we are sending MR or MMR. Also, see if we changed
    // the baud rate.
    if ((((pTG->DISPcb.Resolution ==                  AWRES_mm080_038 ) && (Res==0)) ||
         ((pTG->DISPcb.Resolution == (AWRES_mm080_077|AWRES_mm080_038)) && (Res==1))   ) &&
        (pTG->DISPcb.Encoding == MH_DATA) &&
        (!fBaudChanged) )
    {
        //Do nothing - leave DIS alone!
        DebugPrintEx(DEBUG_MSG,"no need to change DIS");
    }
    else
    {
        // Send DCC command to the modem to set it up
        // Do the minimum necessary - only set resoultion if possible
        // (Again, this is because some modems don't like FDCC).
        if ((pTG->DISPcb.Encoding==MH_DATA)&&(!fBaudChanged))
        {
            uwLen=(UWORD)wsprintf((LPSTR)bBuf, pTG->cbszFDCC_RES, Res);
            if (!Class2iModemDialog(pTG,
                                    bBuf,
                                    (UWORD)(strlen(bBuf)),
                                    LOCALCOMMAND_TIMEOUT,
                                    0,
                                    TRUE,
                                    pTG->cbszCLASS2_OK,
                                    (C2PSTR) NULL))
            {
                DebugPrintEx(DEBUG_ERR,"FDCC_RES failed");
                uRet1 = T30_CALLFAIL;

                pTG->fFatalErrorWasSignaled = 1;
                SignalStatusChange(pTG, FS_FATAL_ERROR);
                RetCode = FALSE;

                goto done;
            }
        }
        else if ( (pTG->DISPcb.Encoding == MH_DATA) && (fBaudChanged) )
        {
            // Changed the baud rate, but Encoding is OK.
            uwLen=(UWORD)wsprintf((LPSTR)bBuf, pTG->cbszFDCC_BAUD, Res, pTG->DISPcb.Baud);
            if (!Class2iModemDialog(pTG,
                                    bBuf,
                                    uwLen,
                                    LOCALCOMMAND_TIMEOUT,
                                    0,
                                    TRUE,
                                    pTG->cbszCLASS2_OK,
                                    (C2PSTR) NULL))
            {
                DebugPrintEx(DEBUG_ERR,"FDCC_BAUD failed");
                uRet1 = T30_CALLFAIL;

                pTG->fFatalErrorWasSignaled = 1;
                SignalStatusChange(pTG, FS_FATAL_ERROR);
                RetCode = FALSE;

                goto done;
            }
        }
        else // the encoding format has changed
        {
            uwLen=(UWORD)wsprintf((LPSTR)bBuf, pTG->cbszFDCC_ALL, Res, pTG->DISPcb.Baud);
            if (!Class2iModemDialog(  pTG,
                                    bBuf,
                                    uwLen,
                                    LOCALCOMMAND_TIMEOUT,
                                    0,
                                    TRUE,
                                    pTG->cbszCLASS2_OK,
                                    (C2PSTR) NULL))
            {
                DebugPrintEx(DEBUG_ERR,"FDCC_ALL failed");
                uRet1 = T30_CALLFAIL;

                pTG->fFatalErrorWasSignaled = 1;
                SignalStatusChange(pTG, FS_FATAL_ERROR);
                RetCode = FALSE;

                goto done;
            }
        }
    }


    // Do BOR based on the value from the modem table set in
    // Class2SetMFRSpecific
    uwLen = (UWORD)wsprintf(bBuf, pTG->cbszSET_FBOR, pTG->CurrentMFRSpec.iSendBOR);
    if (!Class2iModemDialog(pTG,
                            bBuf,
                            uwLen,
                            LOCALCOMMAND_TIMEOUT,
                            0,
                            TRUE,
                            pTG->cbszCLASS2_OK,
                            pTG->cbszCLASS2_ERROR,
                            (C2PSTR) NULL))
    {
        DebugPrintEx(DEBUG_ERR,"FBOR failed");
        // Ignore BOR failure!!!
    }

    // Dial the number

    // have to call hangup on every path out of here
    // after Dial is called. If Dial fails, it calls Hangup
    // if it succeeds we have to call Hangup when we're done

    PSSLogEntry(PSS_MSG, 0, "Phase A - Call establishment");

    SignalStatusChange(pTG, FS_DIALING);

    PSSLogEntry(PSS_MSG, 1, "Dialing...");

    if ((uRet2=Class2Dial(pTG, szPhone))!=CONNECT_OK)
    {
        DebugPrintEx(DEBUG_ERR,"Class2Dial failed");
        uRet1 = T30_DIALFAIL;

        if (!pTG->fFatalErrorWasSignaled)
        {
           pTG->fFatalErrorWasSignaled = 1;
           SignalStatusChange(pTG, FS_FATAL_ERROR);
        }

        RetCode = FALSE;

        goto done;
    }

    pTG->Inst.state = BEFORE_RECVCAPS;
    // we should be using the sender msg here but that says Training
    // at speed=xxxx etc which we don't know, so we just use the
    // Recvr message which just says "negotiating"

	// Send the data
    uRet1 = (USHORT)Class2Send(pTG);
    if (uRet1 == T30_CALLDONE)
    {
        DebugPrintEx(DEBUG_MSG,"DONE WITH CALL, ALL OK");

        // have to call hangup on every path out of here
        // we have to call Hangup here
        Class2ModemHangup(pTG);

        SignalStatusChange(pTG, FS_COMPLETED);
        RetCode = TRUE;
    }
    else
    {
        DebugPrintEx(DEBUG_ERR,"DONE WITH CALL, FAILED");

        // Make sure Modem is in OK state
        FComOutFilterClose(pTG );
        FComXon(pTG, FALSE);
        // have to call hangup on every path out of here
        // Class2ModemABort calls Hangup
        Class2ModemAbort(pTG );

        Class2SignalFatalError(pTG);
        RetCode = FALSE;
    }
    uRet2 = 0;

done:

    return RetCode;
}

BOOL Class2Send(PThrdGlbl pTG)
{
    LPBUFFER        lpbf;
    SWORD           swRet;
    ULONG           lTotalLen=0;
    PCB             Pcb;
    USHORT          uTimeout=30000;
    BOOL            err_status, fAllPagesOK = TRUE;
    BC				bc;

    UWORD           Encoding, Res=0, PageWidth, PageLength, uwLen;
    BYTE            bFDISBuf[200];
    CHAR            szTSI[max(MAXTOTALIDLEN,20)+4];
    BYTE            bNull = 0;
    DWORD           TiffConvertThreadId;

    DEBUG_FUNCTION_NAME("Class2Send");
    /*
    * We have just dialed... Now we have to look for the FDIS response from
    * the modem. It will be followed by an OK - hunt for the OK.
    */

    PSSLogEntry(PSS_MSG, 0, "Phase B - Negotiation");

    if (!Class2iModemDialog(pTG,
                             NULL,
                             0,
                             STARTSENDMODE_TIMEOUT,
                             0,
                             TRUE,
                             pTG->cbszCLASS2_OK,
                             (C2PSTR) NULL))
    {
        DebugPrintEx(DEBUG_ERR,"Failed to get OK for FDIS");
        PSSLogEntry(PSS_ERR, 1, "Failed to receive DIS - aborting");
        err_status =  T30_CALLFAIL;
        return err_status;
    }
    if (pTG->fFoundFHNG)
    {
        PSSLogEntry(PSS_ERR, 1, "Call was disconnected");
        err_status =  T30_CALLFAIL;
        return err_status;
    }


    // The response will be in pTG->lpbResponseBuf2 - this is loaded in
    // Class2iModemDialog.

    // Parse through the received strings, looking for the DIS, CSI,
    // NSF

    if (Class2ResponseAction(pTG, (LPPCB) &Pcb) == FALSE)
    {
        DebugPrintEx(DEBUG_MSG, "Failed to process ATD Response");
        PSSLogEntry(PSS_ERR, 1, "Failed to parse received DIS - aborting");
        err_status =  T30_CALLFAIL;
        return err_status;
    }

    PSSLogEntry(PSS_MSG, 1, "CSI is %s", Pcb.szID);
    PSSLogEntry(PSS_MSG, 1, "DIS specified the following capabilities:");
    LogClass2DISDetails(pTG, &Pcb);

    //Now that pcb is set up, call ICommReceiveCaps to tell icomfile

    Class2InitBC(pTG, (LPBC)&bc, sizeof(bc), RECV_CAPS);
    Class2PCBtoBC(pTG, (LPBC)&bc, sizeof(bc), &Pcb);

    // Class2 modems do their own negotiation & we need to stay in sync
    // Otherwise, we might send MR data while the modem sends a DCS
    // saying it is MH. This happens a lot with Exar modems because
    // they dont accept an FDIS= command during the call.
    // FIX: On all Class2 sends force remote caps to always be MH
    // Then in efaxrun we will always negotiate MH & encode MH
    // We are relying on the fact that (a) it seems that all/most
    // Class2 modems negotiate MH (b) Hopefully ALL Exar ones
    // negotiate MH and (c) We will override all non-Exar modem's
    // intrinsic negotiation by sending an AT+FDIS= just before the FDT
    // Also (d) This change makes our behaviour match Snowball exactly
    // so we will work no better or worse than it :-)
    bc.Fax.Encoding = MH_DATA;

    if( ICommRecvCaps(pTG, (LPBC)&bc) == FALSE )
    {
        DebugPrintEx(DEBUG_ERR,"Failed return from ICommRecvCaps");
        err_status =  T30_CALLFAIL;
        return err_status;
    }

    // now get the SEND_PARAMS
    if (!Class2GetBC(pTG, SEND_PARAMS)) // sleep until we get it
    {
        DebugPrintEx(DEBUG_ERR,"Class2GetBC Failed");
        err_status = T30_CALLFAIL;
        return err_status;
    }

    // Turn off flow control.
    FComXon(pTG, FALSE);

    // The Send params were set during the call to Class2GetBC
    // We'll use these to set the ID (for the TSI) and the DCS params

    // Send the FDT and get back the DCS. The FDT must be followed by
    // CONNECT and a ^Q (XON)
    // The FDT string must have the correct resolution and encoding
    // for this session. FDT=Encoding, Res, width, length
    // Encoding 0=MH, 1=MR,2=uncompressed,3=MMR
    // Res 0=200x100 (normal), 1=200x200 (fine)
    // PageWidth 0=1728pixels/215mm,1=2048/255,2=2432/303,
    //              3=1216/151,4=864/107
    // PageLength 0=A4,1=B4,2=unlimited

    Class2SetDIS_DCSParams( pTG,
                            SEND_PARAMS,
                            (LPUWORD)&Encoding,
                            (LPUWORD)&Res,
                            (LPUWORD)&PageWidth,
                            (LPUWORD)&PageLength,
                            (LPSTR) szTSI,
							sizeof(szTSI)/sizeof(szTSI[0]));

    //
    // Current Win95 version of Class2 TX is limited to MH only.
    // While not changing this, we will at least allow MR selection in future.
    //

    if (!pTG->fTiffThreadCreated)
    {
        if (Encoding)
        {
            pTG->TiffConvertThreadParams.tiffCompression = TIFF_COMPRESSION_MR;
        }
        else
        {
            pTG->TiffConvertThreadParams.tiffCompression = TIFF_COMPRESSION_MH;
        }

        if (Res)
        {
            pTG->TiffConvertThreadParams.HiRes = 1;
        }
        else
        {
            pTG->TiffConvertThreadParams.HiRes = 0;
            // use LoRes TIFF file prepared by FaxSvc
            // pTG->lpwFileName[ wcslen(pTG->lpwFileName) - 1] = (unsigned short) ('$');
        }

        _fmemcpy (pTG->TiffConvertThreadParams.lpszLineID, pTG->lpszPermanentLineID, 8);
        pTG->TiffConvertThreadParams.lpszLineID[8] = 0;

        DebugPrintEx(DEBUG_MSG,"Creating TIFF helper thread");
        pTG->hThread = CreateThread(NULL,
                                    0,
                                   (LPTHREAD_START_ROUTINE) TiffConvertThread,
                                   (LPVOID) pTG,
                                   0,
                                   &TiffConvertThreadId);
        if (!pTG->hThread)
        {
            DebugPrintEx(DEBUG_ERR,"TiffConvertThread create FAILED");

            err_status = T30_CALLFAIL;
            return err_status;
        }

        pTG->fTiffThreadCreated = 1;
        pTG->AckTerminate = 0;
        pTG->fOkToResetAbortReqEvent = 0;

        if ((pTG->RecoveryIndex >=0)&&(pTG->RecoveryIndex < MAX_T30_CONNECT))
        {
            T30Recovery[pTG->RecoveryIndex].TiffThreadId = TiffConvertThreadId;
            T30Recovery[pTG->RecoveryIndex].CkSum = ComputeCheckSum((LPDWORD) &T30Recovery[pTG->RecoveryIndex].fAvail,
                                                                    sizeof(T30_RECOVERY_GLOB)/sizeof(DWORD)-1);
        }
    }

    // Even modems that take FDT=x,x,x,x don't seem to really do it
    // right. So, for now, just send FDIS followed by FDT except for
    // the EXAR modems!!
    if (!pTG->CurrentMFRSpec.bIsExar)
    {
        uwLen = (WORD)wsprintf( bFDISBuf,
                                pTG->cbszFDIS,
                                Res,
                                min(Pcb.Baud, pTG->DISPcb.Baud),
                                PageWidth,
                                PageLength,
                                Encoding);

        if (!Class2iModemDialog(pTG,
                                bFDISBuf,
                                uwLen,
                                LOCALCOMMAND_TIMEOUT,
                                0,
                                TRUE,
                                pTG->cbszCLASS2_OK,
                                pTG->cbszCLASS2_ERROR,
                                (C2PSTR) NULL))
        {
            DebugPrintEx(DEBUG_ERR,"Failed get response from FDIS!!");
            // Ignore it -we are going to send what we have!
        }
    }

    if (Class2iModemDialog(pTG,
                            pTG->cbszFDT,
                            (UWORD)(strlen(pTG->cbszFDT)),
                            STARTSENDMODE_TIMEOUT,
                            0,
                            TRUE,
                            pTG->cbszFDT_CONNECT,
                            (C2PSTR) NULL) != 1)
    {
        DebugPrintEx(DEBUG_MSG,"FDT Received %s",(LPSTR)(&(pTG->lpbResponseBuf2)));
        if (pTG->fFoundFHNG)
        {
            PSSLogEntry(PSS_ERR, 1, "Call was disconnected");
        }
        else
        {
            PSSLogEntry(PSS_ERR, 1, "Failed to start first page");
        }
        err_status =  T30_CALLFAIL;
        return err_status;
    }
    DebugPrintEx(DEBUG_MSG,"FDT Received %s", (LPSTR)(&(pTG->lpbResponseBuf2)));

    if (pTG->CurrentMFRSpec.fSkipCtrlQ)
    {
        DebugPrintEx(DEBUG_WRN,"Skipping <XON> - sending immedaitely after CONNECT");
    }
    // Get the  from the COMM driver
    else if (!FComGetOneChar(pTG, 0x11))
    {
        PSSLogEntry(PSS_WRN, 1, "Didn't receive <XON> - continuing anyway");
    }
    else
    {
        PSSLogEntry(PSS_MSG, 2, "recv:     <XON>");
    }

    // Turn on flow control.
    FComXon(pTG, TRUE);

    // Search through Response for the DCS frame - need it so set
    // the correct zero stuffing
    if (Class2ResponseAction(pTG, (LPPCB) &Pcb) == FALSE)
    {
        DebugPrintEx(DEBUG_ERR,"Failed to process FDT Response");
        PSSLogEntry(PSS_ERR, 1, "Failed to parse sent DCS - aborting");
        err_status =  T30_CALLFAIL;
        return err_status;
    }

    PSSLogEntry(PSS_MSG, 1, "TSI is \"%s\"", szTSI);
    PSSLogEntry(PSS_MSG, 1, "DCS was sent as follows:");
    LogClass2DCSDetails(pTG, &Pcb);

    // Got a response - see if baud rate is OK
    DebugPrintEx(   DEBUG_MSG,
                    "Negotiated Baud Rate = %d, lower limit is %d",
                    Pcb.Baud,
                    pTG->ProtParams2.LowestSendSpeed);

    if (CodeToBPS[Pcb.Baud]<(WORD)pTG->ProtParams2.LowestSendSpeed)
    {
        DebugPrintEx(DEBUG_ERR,"Aborting due to too low baud rate!");
        err_status =  T30_CALLFAIL;
        return err_status;
    }

    // Use values obtained from the DCS frame to set zero stuffing.
    // (These were obtained by call to Class2ResponseAction above).
    // Zero stuffing is a function of minimum scan time (determined
    // by resolution and the returned scan minimum) and baud.
    // Fixed the Hack--added a Baud field

    // Init must be BEFORE SetStuffZero!
    FComOutFilterInit(pTG);
    FComSetStuffZERO(   pTG,
                        Class2MinScanToBytesPerLine(pTG,
                                                    Pcb.MinScan,
                                                    (BYTE)Pcb.Baud,
                                                    Pcb.Resolution));


    err_status =  T30_CALLDONE;
    while ((swRet=ICommGetSendBuf(pTG, &lpbf, SEND_STARTPAGE)) == 0)
    {
        PSSLogEntry(PSS_MSG, 0, "Phase C - Page Transmission");
        PSSLogEntry(PSS_MSG, 1, "Sending page %d data...", pTG->PageCount);

        lTotalLen = 0;

        FComOverlappedIO(pTG, TRUE); // TRUE
        while ((swRet=ICommGetSendBuf(pTG, &lpbf, SEND_SEQ)) == 0)
        {
            lTotalLen += lpbf->wLengthData;
            DebugPrintEx(DEBUG_MSG,"Total length: %ld",lTotalLen);

            if (!   (Class2ModemSendMem(   pTG,
                                        lpbf->lpbBegData,
                                        lpbf->wLengthData) &
                    (MyFreeBuf(pTG, lpbf))))
            {
                DebugPrintEx(DEBUG_ERR,"Class2ModemSendBuf Failed");
                PSSLogEntry(PSS_ERR, 1, "Failed to send page data - aborting");
                err_status =  T30_CALLFAIL;
                FComOverlappedIO(pTG, FALSE);
                return err_status;
            }
        } // end of SEND_SEQ while

        // don't check swRet for error yet - even in case of page preparation
        // failure or abort, we still want to send <dle><etx> and then abort.
        FComOverlappedIO(pTG, FALSE);
        PSSLogEntry(PSS_MSG, 2, "send: page %d data, %d bytes", pTG->PageCount, lTotalLen);

        PSSLogEntry(PSS_MSG, 2, "send: <dle><etx>");
        // Terminate the Page with DLE-ETX
        if (!FComDirectAsyncWrite(pTG, pTG->Class2bDLEETX, 2))
        {
            PSSLogEntry(PSS_ERR, 1, "Failed to send <dle><etx> - aborting");
            err_status =  T30_CALLFAIL;
            return err_status;
        }

        if (swRet != SEND_EOF)
        {
            DebugPrintEx(DEBUG_ERR,"ICommGetSendBuf failed, swRet=%d", swRet);

            PSSLogEntry(PSS_ERR, 1, "Failed to send page data - aborting");
            err_status =  T30_CALLFAIL;
            return err_status;
        }

        PSSLogEntry(PSS_MSG, 1, "Successfully sent page data");

        if (1 != Class2ModemDrain(pTG))
        {
            DebugPrintEx(DEBUG_ERR,"Failed to drain");
            err_status =  T30_CALLFAIL;
            return err_status;
        }
        if (pTG->fFoundFHNG)
        {
            PSSLogEntry(PSS_ERR, 1, "Call was disconnected");
            err_status =  T30_CALLFAIL;
            return err_status;
        }


        PSSLogEntry(PSS_MSG, 0, "Phase D - Post Message Exchange");

        //See if more pages to send...
        if (ICommNextSend(pTG) == NEXTSEND_MPS)
        {
            // We are about to send a second or more page. Terminate the
            // last page with FET=0, signalling a new one to come
            PSSLogEntry(PSS_MSG, 1, "Sending MPS");
            if (!Class2iModemDialog(pTG,
                                    pTG->cbszENDPAGE,
                                    (UWORD)(strlen(pTG->cbszENDPAGE)),
                                    STARTSENDMODE_TIMEOUT,
                                    0,
                                    TRUE,
                                    pTG->cbszCLASS2_OK,
                                    (C2PSTR)NULL))
            {
                PSSLogEntry(PSS_ERR, 1, "Failed to send MPS - aborting");
                err_status =  T30_CALLFAIL;
                return err_status;
            }
            if (pTG->fFoundFHNG)
            {
                PSSLogEntry(PSS_ERR, 1, "Call was disconnected");
                err_status =  T30_CALLFAIL;
                return err_status;
            }
        }
        else
        {
            // Purge input COM queue to purge all OKs
            FComFlushInput(pTG);

            // Send end of message sequence
            PSSLogEntry(PSS_MSG, 1, "Sending EOP");
            if (!Class2iModemDialog(pTG,
                                    pTG->cbszENDMESSAGE,
                                    (UWORD)(strlen(pTG->cbszENDMESSAGE)),
                                    STARTSENDMODE_TIMEOUT,
                                    0,
                                    TRUE,
                                    pTG->cbszCLASS2_OK,
                                    (C2PSTR)NULL))
            {
                PSSLogEntry(PSS_ERR, 1, "Failed to send EOP - aborting");
                err_status =  T30_CALLFAIL;
                return err_status;
            }
            // Don't test for pTG->fFoundFHNG - it might be OK
        }

        // Acknowledge that we sent the page
        // Parse the FPTS response and see if the page is good or bad.
        // Keep track of any bad pages in fAllPagesOK
        if (!ParseFPTS_SendAck(pTG ))
        {
            // fAllPagesOK = FALSE;  // It's still ok - we'll retransmit the page
            // We want ICommGetSendBuf(SEND_STARTPAGE) to give us the same page again
            pTG->T30.ifrResp = ifrRTN;
        }
        else
        {
            // We want ICommGetSendBuf(SEND_STARTPAGE) to give us the next page
            // Note: This includes RTP too!
            pTG->T30.ifrResp = ifrMCF;
        }

        if ((ICommNextSend(pTG) == NEXTSEND_MPS) || (pTG->T30.ifrResp == ifrRTN))
        {
            if (pTG->fFoundFHNG)
            {
                // This could've happened after we sent the EOP, and only now we
                // know it's not OK
                PSSLogEntry(PSS_ERR, 1, "Call was disconnected");
                err_status =  T30_CALLFAIL;
                return err_status;
            }
            // Now, Send the FDT to start the next page (this was done for
            // the first page before entering the multipage loop).
            if (Class2iModemDialog(pTG,
                                    pTG->cbszFDT,
                                    (UWORD)(strlen(pTG->cbszFDT)),
                                    STARTSENDMODE_TIMEOUT,
                                    0,
                                    TRUE,
                                    pTG->cbszFDT_CONNECT,
                                    (C2PSTR)NULL) != 1)
            {
                DebugPrintEx(DEBUG_ERR,"FDT to start next PAGE Failed!");
                if (pTG->fFoundFHNG)
                {
                    PSSLogEntry(PSS_ERR, 1, "Call was disconnected");
                }
                err_status =  T30_CALLFAIL;
                return err_status;
            }

            // Get the  from the COMM driver
            if (!FComGetOneChar(pTG, 0x11))
            {
                PSSLogEntry(PSS_WRN, 1, "Didn't receive <XON> - proceeding to next page anyway");
            }
            else
            {
                PSSLogEntry(PSS_MSG, 2, "recv:     <XON>");
            }

            // Turn on flow control.
            FComXon(pTG, TRUE);
        } //if we do not have another page, do the else...
        else
        {
            break; // All done sending pages...
        }

        if (err_status==T30_CALLFAIL)
        {
            break;
        }
    } //End of multipage while

    DebugPrintEx(DEBUG_MSG,"out of while multipage loop.");

    FComOutFilterClose(pTG);
    FComXon(pTG, FALSE);

    // If *any* page failed to send correctly, the call failed!
    if (!fAllPagesOK)
    {
        err_status = T30_CALLFAIL;
    }
    return err_status;
}


/**************************************************************
        Receive specific routines start here
***************************************************************/

BOOL  T30Cl2Rx(PThrdGlbl pTG)
{
    USHORT          uRet1, uRet2;
    BYTE            bBuf[200];
    UWORD           uwLen, uwRet;
    UWORD           Encoding, Res, PageWidth, PageLength;
    BYTE            bIDBuf[200+max(MAXTOTALIDLEN,20)+4];
    CHAR            szCSI[max(MAXTOTALIDLEN,20)+4];
    BOOL            fBaudChanged;
    BOOL            RetCode;

    DEBUG_FUNCTION_NAME("T30Cl2Rx");

    uRet2 = 0;
    if (!(pTG->lpCmdTab=iModemGetCmdTabPtr(pTG)))
    {
        DebugPrintEx(DEBUG_ERR,"iModemGetCmdTabPtr failed");
        uRet1 = T30_CALLFAIL;

        pTG->fFatalErrorWasSignaled = 1;
        SignalStatusChange(pTG, FS_FATAL_ERROR);
        RetCode = FALSE;

        goto done;
    }

    // first get SEND_CAPS
    if (!Class2GetBC(pTG, SEND_CAPS)) // sleep until we get it
    {
        DebugPrintEx(DEBUG_ERR,"Class2GetBC failed");
        uRet1 = T30_CALLFAIL;

        pTG->fFatalErrorWasSignaled = 1;
        SignalStatusChange(pTG, FS_FATAL_ERROR);
        RetCode = FALSE;

        goto done;
    }

    // Go to Class2
    // Elliot Bug#3421 -- incoming RING sometimes clobbers AT+FCLASS=1/2 cmd.
    if (pTG->lpCmdTab->dwFlags & fMDMSP_ANS_GOCLASS_TWICE)
    {
        iModemGoClass(pTG, 2);
    }
    if(!iModemGoClass(pTG, 2))
    {
        DebugPrintEx(DEBUG_ERR,"Failed to Go to Class 2");
        uRet1 = T30_CALLFAIL;

        pTG->fFatalErrorWasSignaled = 1;
        SignalStatusChange(pTG, FS_FATAL_ERROR);
        RetCode = FALSE;

        goto done;
    }

    // Begin by checking for manufacturer and ATI code.
    // Look this up against the modem specific table we
    // have and set up the receive strings needed for
    // this modem.
    if (!Class2GetModemMaker(pTG))
    {
        DebugPrintEx(DEBUG_WRN,"Call to GetModemMaker failed");
        // Ignore failure!!!
    }

    // set manufacturer specific strings
    Class2SetMFRSpecific(pTG);

    // Get the capabilities of the software. I am only using this
    // right now for the CSI field (below where I send +FLID).
    // Really, this should also be used instead of the hardcoded DIS
    // values below.
    // ALL COMMANDS LOOK FOR MULTILINE RESPONSES WHILE MODEM IS ONHOOK.
    // A "RING" COULD APPEAR AT ANY TIME!
    _fmemset((LPB)szCSI, 0, sizeof(szCSI));
    Class2SetDIS_DCSParams( pTG,
                            SEND_CAPS,
                            (LPUWORD)&Encoding,
                            (LPUWORD)&Res,
                            (LPUWORD)&PageWidth,
                            (LPUWORD)&PageLength,
                            (LPSTR) szCSI,
							sizeof(szCSI)/sizeof(szCSI[0]));

    // Find out what the default DIS is
    if (!Class2GetDefaultFDIS(pTG))
    {
        DebugPrintEx(DEBUG_ERR, "Class2GetDefaultFDIS failed");
        pTG->fFatalErrorWasSignaled = 1;
        SignalStatusChange(pTG, FS_FATAL_ERROR);
        RetCode = FALSE;
        goto done;
    }

    fBaudChanged = FALSE;
    // See if we have to change the baud rate to a lower value.
    // This only happens if the user set an ini string inhibiting
    // V.17 receive
    if ((pTG->DISPcb.Baud>3) && (!pTG->ProtParams2.fEnableV17Recv))
    {
        DebugPrintEx(   DEBUG_MSG,
                        "Lowering baud from %d for V.17 receive inihibit",
                        CodeToBPS[pTG->DISPcb.Baud]);

        pTG->DISPcb.Baud = 3; //9600 won't use V.17
        fBaudChanged = TRUE;
    }

    // Now, look and see if any of the values in the DIS are "bad"
    // That is, make sure we can receive high res and we are not
    // claiming that we are capable of MR or MMR. Also, see if we changed
    // the baud rate. Also make sure we can receive wide pages.

    if (    (pTG->DISPcb.Resolution & AWRES_mm080_077)  &&
            ( pTG->DISPcb.Encoding == MH_DATA)          &&
            (!fBaudChanged)                             &&
            (pTG->DISPcb.PageLength == 2)               &&
            (pTG->DISPcb.PageWidth == 0)                )
    {
        //Do nothing - leave DIS alone!
        DebugPrintEx(DEBUG_MSG,"no need to change DIS");
    }
    else
    {
        // Send DCC command to the modem to set it up
        // Do the minimum necessary - only set resoultion if possible
        // (Again, this is because some modems don't like FDCC).
        if (    (pTG->DISPcb.Encoding == MH_DATA)   &&
                (!fBaudChanged)                     &&
                (pTG->DISPcb.PageLength == 2)       &&
                (pTG->DISPcb.PageWidth == 0)        )
        {
            if (!Class2iModemDialog(pTG,
                                    pTG->cbszFDCC_RECV_RES,
                                    (UWORD)(strlen(pTG->cbszFDCC_RECV_RES)),
                                    LOCALCOMMAND_TIMEOUT,
                                    0,
                                    TRUE,
                                    pTG->cbszCLASS2_OK,
                                    (C2PSTR) NULL))
            {
                DebugPrintEx(DEBUG_ERR,"FDCC_RES Failed");
                //Ignore it
            }
        }
        else if (   (pTG->DISPcb.Encoding == MH_DATA)   &&
                    (fBaudChanged)                      &&
                    (pTG->DISPcb.PageLength == 2)       &&
                    (pTG->DISPcb.PageWidth == 0)        )
        {
            // Changed the baud rate, but Encoding is OK.
            uwLen=(USHORT)wsprintf((LPSTR)bBuf, pTG->cbszFDCC_BAUD, 1, pTG->DISPcb.Baud);
            if(!Class2iModemDialog( pTG,
                                    bBuf,
                                    uwLen,
                                    LOCALCOMMAND_TIMEOUT,
                                    0,
                                    TRUE,
                                    pTG->cbszCLASS2_OK,
                                    (C2PSTR) NULL))
            {
                DebugPrintEx(DEBUG_ERR,"FDCC_BAUD Failed");
                //Ignore it
            }
        }
        else // the encoding format has changed or page size is bad
        {
            uwLen=(USHORT)wsprintf((LPSTR)bBuf, pTG->cbszFDCC_RECV_ALL, pTG->DISPcb.Baud);
            if (!(uwRet=Class2iModemDialog( pTG,
                                            bBuf,
                                            uwLen,
                                            LOCALCOMMAND_TIMEOUT,
                                            0,
                                            TRUE,
                                            pTG->cbszCLASS2_OK,
                                            pTG->cbszCLASS2_ERROR,
                                            (C2PSTR) NULL)))
            {
                DebugPrintEx(DEBUG_ERR,"FDCC_RECV_ALL Failed");
                // ignore it.
            }

            // If the FDCC failed, try FDIS.
            if ((uwRet == 0)||(uwRet == 2))
            {
                uwLen=(USHORT)wsprintf((LPSTR)bBuf, pTG->cbszFDIS_RECV_ALL, pTG->DISPcb.Baud);
                if (!Class2iModemDialog(pTG,
                                        bBuf,
                                        uwLen,
                                        LOCALCOMMAND_TIMEOUT,
                                        0,
                                        TRUE,
                                        pTG->cbszCLASS2_OK,
                                        pTG->cbszCLASS2_ERROR,
                                        (C2PSTR) NULL))
                {
                    DebugPrintEx(DEBUG_ERR,"FDIS_RECV_ALL Failed");
                    // ignore it.
                }

                // if the above failed, try just setting the baud
                // rate and resolution with FDCC.
                if ((uwRet == 0)||(uwRet == 2))
                {
                    uwLen=(USHORT)wsprintf((LPSTR)bBuf, pTG->cbszFDCC_BAUD, 1, pTG->DISPcb.Baud);
                    if (!(uwRet=Class2iModemDialog( pTG,
                                                    bBuf,
                                                    uwLen,
                                                    LOCALCOMMAND_TIMEOUT,
                                                    0,
                                                    TRUE,
                                                    pTG->cbszCLASS2_OK,
                                                    pTG->cbszCLASS2_ERROR,
                                                    (C2PSTR) NULL)))
                    {
                        DebugPrintEx(DEBUG_ERR,"FDCC_BAUD Failed");
                        // Ignore it
                    }
                }

                // if the above failed, try just setting the baud
                // rate and resolution with FDIS.
                if ((uwRet == 0)||(uwRet == 2))
                {
                    uwLen=(USHORT)wsprintf((LPSTR)bBuf, pTG->cbszFDIS_BAUD, pTG->DISPcb.Baud);
                    if (!(uwRet=Class2iModemDialog( pTG,
                                                    bBuf,
                                                    uwLen,
                                                    LOCALCOMMAND_TIMEOUT,
                                                    0,
                                                    TRUE,
                                                    pTG->cbszCLASS2_OK,
                                                    pTG->cbszCLASS2_ERROR,
                                                    (C2PSTR) NULL)))
                    {
                        DebugPrintEx(DEBUG_ERR,"FDIS_BAUD Failed");
                        // Ignore it
                    }
                }
            }
        }
    }

    // Enable Reception
    if (!Class2iModemDialog(pTG,
                            pTG->cbszFCR,
                            (UWORD)(strlen(pTG->cbszFCR)),
                            ANS_LOCALCOMMAND_TIMEOUT,
                            0,
                            TRUE,
                            pTG->cbszCLASS2_OK,
                            pTG->cbszCLASS2_ERROR,
                            (C2PSTR) NULL))
    {
        DebugPrintEx(DEBUG_WRN,"FCR failed");
        // ignore failure
    }

    // Turn off Copy Quality Checking - also skip for Sierra type modems
    if (!pTG->CurrentMFRSpec.bIsSierra)
    {
        if (!Class2iModemDialog(pTG,
                                pTG->cbszFCQ,
                                (UWORD)(strlen(pTG->cbszFCQ)),
                                ANS_LOCALCOMMAND_TIMEOUT,
                                0,
                                TRUE,
                                pTG->cbszCLASS2_OK,
                                pTG->cbszCLASS2_ERROR,
                                (C2PSTR) NULL))
        {
            DebugPrintEx(DEBUG_ERR,"FCQ failed");
            // Ignore CQ failure!!!
        }
    }
    // Turn off Bug mode
    if (!Class2iModemDialog(pTG,
                            pTG->cbszFBUG,
                            (UWORD)(strlen(pTG->cbszFBUG)),
                            ANS_LOCALCOMMAND_TIMEOUT,
                            0,
                            TRUE,
                            pTG->cbszCLASS2_OK,
                            pTG->cbszCLASS2_ERROR,
                            (C2PSTR) NULL))
    {
        DebugPrintEx(DEBUG_ERR,"FBUG failed");
        // Ignore FBUG failure!!!
    }

    // Do BOR based on the value from the modem table set in
    // Class2SetMFRSpecific
    bBuf[0] = '\0';
    {
        UINT uBOR = pTG->CurrentMFRSpec.iReceiveBOR;
        if (pTG->CurrentMFRSpec.fSWFBOR && uBOR==1)
        {
            DebugPrintEx(DEBUG_WRN,"SWFBOR Enabled. Using AT+FBOR=0 instead of AT+FBOR=1");
            uBOR = 0;
        }
        uwLen = (USHORT)wsprintf(bBuf, pTG->cbszSET_FBOR, uBOR);
    }
    if (!Class2iModemDialog(pTG,
                            bBuf,
                            uwLen,
                            ANS_LOCALCOMMAND_TIMEOUT,
                            0,
                            TRUE,
                            pTG->cbszCLASS2_OK,
                            pTG->cbszCLASS2_ERROR,
                            (C2PSTR) NULL))
    {
        DebugPrintEx(DEBUG_ERR,"FBOR failed");
        // Ignore BOR failure!!!
    }

    // Set the local ID - need ID from above to do this.
    bIDBuf[0] = '\0';
    uwLen = (USHORT)wsprintf(bIDBuf, pTG->cbszFLID, (LPSTR)szCSI);
    if (!Class2iModemDialog(pTG,
                            bIDBuf,
                            uwLen,
                            ANS_LOCALCOMMAND_TIMEOUT,
                            0,
                            TRUE,
                            pTG->cbszCLASS2_OK,
                            pTG->cbszCLASS2_ERROR,
                            (C2PSTR) NULL))
    {
        DebugPrintEx(DEBUG_ERR,"Local ID failed");
        // ignore failure
    }

    // Answer the phone

    // have to call hangup on every path out of here
    // after Answer is called. If Answer fails, it calls Hangup.
    // if it succeeds we have to call Hangup when we're done

    SignalStatusChange(pTG, FS_ANSWERED);

    PSSLogEntry(PSS_MSG, 0, "Phase A - Call establishment");
    PSSLogEntry(PSS_MSG, 1, "Answering...");

    if((uRet2 = Class2Answer(pTG)) != CONNECT_OK)
    {
        DebugPrintEx(DEBUG_ERR, "Failed to answer - aborting");
        // SignalStatusChange is called inside Class2Answer
        uRet1 = T30_CALLFAIL;
        RetCode = FALSE;
        goto done;
    }

    DebugPrintEx(DEBUG_MSG,"Done with Class2 Answer - succeeded");

    // Receive the data
    PSSLogEntry(PSS_MSG, 0, "Phase B - Negotiation");

    PSSLogEntry(PSS_MSG, 1, "CSI is %s", szCSI);

    PSSLogEntry(PSS_MSG, 1, "DIS was composed with the following capabilities:");
    LogClass2DISDetails(pTG, &pTG->DISPcb);

    uRet1 = (USHORT)Class2Receive(pTG );

    // t-jonb: If we've already called PutRecvBuf(RECV_STARTPAGE), but not
    // PutRecvBuf(RECV_ENDPAGE / DOC), then InFileHandleNeedsBeClosed==1, meaning
    // there's a .RX file that hasn't been copied to the .TIF file. Since the
    // call was disconnected, there will be no chance to send RTN. Therefore, we call
    // PutRecvBuf(RECV_ENDDOC_FORCESAVE) to keep the partial page and tell
    // rx_thrd to terminate.
    if (pTG->InFileHandleNeedsBeClosed)
    {
        ICommPutRecvBuf(pTG, NULL, RECV_ENDDOC_FORCESAVE);
    }

    if (uRet1 == T30_CALLDONE)
    {
        DebugPrintEx(DEBUG_MSG,"DONE WITH CALL, ALL OK");

        // have to call hangup on every path out of here
        // we have to call Hangup here
        Class2ModemHangup(pTG );

        SignalStatusChange(pTG, FS_COMPLETED);
        RetCode = TRUE;
    }
    else
    {
        DebugPrintEx(DEBUG_ERR,"DONE WITH CALL, FAILED");

        // Make sure modem is in an OK state!
        FComXon(pTG, FALSE);
        // have to call hangup on every path out of here
        // Abort calls Hangup
        Class2ModemAbort(pTG );

        Class2SignalFatalError(pTG);
        RetCode = FALSE;
    }
    uRet2 = 0;

done:
    return RetCode;
}

BOOL Class2Receive(PThrdGlbl pTG)
{
    LPBUFFER        lpbf;
    SWORD           swRet;
    UWORD           uwLen;
    ULONG           lTotalLen=0;
    PCB             Pcb;
    USHORT          uTimeout=30000, uRet, uEndPageAction=NO_MORE_PAGES;
    BOOL            err_status;
    BC				bc;
    BYTE            bBuf[200];
    LPSTR           lpsTemp;
    DWORD           HiRes;

    DEBUG_FUNCTION_NAME("Class2Receive");

    /*
    * We have just answered!
    */

    // The repsonse to the ATA command is in the global variable
    // pTG->lpbResponseBuf2.

    if (Class2ResponseAction(pTG, (LPPCB) &Pcb) == FALSE)
    {
        PSSLogEntry(PSS_ERR, 1, "Failed to parse response from ATA - aborting");
        err_status =  T30_CALLFAIL;
        return err_status;
    }

    PSSLogEntry(PSS_MSG, 1, "TSI is %s", Pcb.szID);
    PSSLogEntry(PSS_MSG, 1, "Received DCS is as follows");
    LogClass2DCSDetails(pTG, &Pcb);

    if (!Class2IsValidDCS(&Pcb))
    {
        PSSLogEntry(PSS_ERR, 1, "Received bad DCS parameters - aborting");
        err_status =  T30_CALLFAIL;
        return err_status;
    }

    if (!Class2UpdateTiffInfo(pTG, &Pcb))
    {
        DebugPrintEx(DEBUG_WRN, "Class2UpdateTiffInfo failed");
    }

    //Now that pcb is set up, call ICommReceiveParams to tell icomfile

    Class2InitBC(pTG, (LPBC)&bc, sizeof(bc), RECV_PARAMS);
    Class2PCBtoBC(pTG, (LPBC)&bc, sizeof(bc), &Pcb);

    if (ICommRecvParams(pTG, (LPBC)&bc) == FALSE)
    {
        DebugPrintEx(DEBUG_ERR,"Failed return from ICommRecvParams");
        err_status =  T30_CALLFAIL;
        return err_status;
    }

    //
    // once per RX - create TIFF file as soon as we know the compression / resolution.
    //

    pTG->Encoding   = Pcb.Encoding;
    pTG->Resolution = Pcb.Resolution;

    if (Pcb.Resolution & (AWRES_mm080_077 |  AWRES_200_200) )
    {
        HiRes = 1;
    }
    else
    {
        HiRes = 0;
    }

    if ( !pTG->fTiffOpenOrCreated)
    {
        //
        // top 32bits of 64bit handle are guaranteed to be zero
        //
        pTG->Inst.hfile =  TiffCreateW ( pTG->lpwFileName,
                                         pTG->TiffInfo.CompressionType,
                                         pTG->TiffInfo.ImageWidth,
                                         FILLORDER_LSB2MSB,
                                         HiRes
                                         );

        if (! (pTG->Inst.hfile))
        {
            lpsTemp = UnicodeStringToAnsiString(pTG->lpwFileName);
            DebugPrintEx(   DEBUG_ERR,
                            "ERROR:Can't create tiff file %s compr=%d",
                            lpsTemp,
                            pTG->TiffInfo.CompressionType);

            MemFree(lpsTemp);
            err_status =  T30_CALLFAIL;
            return err_status;
        }

        pTG->fTiffOpenOrCreated = 1;

        lpsTemp = UnicodeStringToAnsiString(pTG->lpwFileName);

        DebugPrintEx(   DEBUG_MSG,
                        "Created tiff file %s compr=%d HiRes=%d",
                        lpsTemp,
                        pTG->TiffInfo.CompressionType,
                        HiRes);

        MemFree(lpsTemp);
    }

    // **** Apparently, we don't want flow control on, so we'll turn
    // it off. Is this true???? If I turn it on, fcom.c fails a
    // debug check in filterreadbuf.
    FComXon(pTG, FALSE);

    // Send the FDR. The FDR must be responded to by a CONNECT.

    if (Class2iModemDialog(pTG,
                            pTG->cbszFDR,
                            (UWORD)(strlen(pTG->cbszFDR)),
                            STARTSENDMODE_TIMEOUT,
                            0,
                            TRUE,
                            pTG->cbszFDT_CONNECT,
                            (C2PSTR) NULL) != 1)
    {
        DebugPrintEx(DEBUG_ERR,"Failed get response from initial FDR");
        if (pTG->fFoundFHNG)
        {
            PSSLogEntry(PSS_ERR, 1, "Call was disconnected");
        }
        err_status =  T30_CALLFAIL;
        return err_status;
    }

    DebugPrintEx(DEBUG_MSG,"FDR Received %s", (LPSTR)(&(pTG->lpbResponseBuf2)));

    // Might have to search through FDR response, but I doubt it.

    // Now we need to send a DC2 (0x12) to tell the modem it is OK
    // to give us data.
    // Some modems use ^Q instead of ^R - The correct value was written
    // into the DC@ string in Class2Callee where we checked for
    // manufacturer

    PSSLogEntry(PSS_MSG, 0, "Phase C - Receive page");

    PSSLogEntry(PSS_MSG, 2, "send: <DC2> (=ASCII %d)", *(pTG->CurrentMFRSpec.szDC2));

    FComDirectSyncWriteFast(pTG, pTG->CurrentMFRSpec.szDC2, 1);

    // Now we can receive the data and give it to the icomfile routine

    err_status =  T30_CALLDONE;

    while ((swRet=(SWORD)ICommPutRecvBuf(pTG, NULL, RECV_STARTPAGE)) == TRUE)
    {
        PSSLogEntry(PSS_MSG, 1, "Receiving page %d data...", pTG->PageCount+1);

        // The READ_TIMEOUT is used to timeout calls to ReadBuf() either in the
        #define READ_TIMEOUT    15000

        lTotalLen = 0;
        do
        {
            DebugPrintEx(DEBUG_MSG,"In receiving a page loop");
            uRet = Class2ModemRecvBuf(pTG, &lpbf, READ_TIMEOUT);
            DebugPrintEx(DEBUG_MSG,"Class2ModemRecvBuf returned uRet=%x",uRet);
            if(lpbf)
            {
                lTotalLen += lpbf->wLengthData;
                DebugPrintEx(   DEBUG_MSG,
                                "In lpbf if. length = %ld, Total Length %ld",
                                lpbf->wLengthData,
                                lTotalLen);

                if (!ICommPutRecvBuf(pTG, lpbf, RECV_SEQ))
                {
                    DebugPrintEx(DEBUG_ERR,"Bad return - PutRecvBuf in page");
                    err_status=T30_CALLFAIL;
                    return err_status;
                }
                lpbf = 0;
            }
        }
        while(uRet == RECV_OK);

        PSSLogEntry(PSS_MSG, 2, "recv:     page %d data, %d bytes", pTG->PageCount+1, lTotalLen);

        if(uRet == RECV_EOF)
        {
            DebugPrintEx(DEBUG_MSG,"Got EOF from RecvBuf");

            // RSL needed interface to TIFF thread
            pTG->fLastReadBlock = 1;
            ICommPutRecvBuf(pTG, NULL, RECV_FLUSH);
        }
        else
        {
            // Timeout from ModemRecvBuf
            BYTE bCancel = 0x18;
            DebugPrintEx(DEBUG_ERR,"ModemRecvBuf Timeout or Error=%d",uRet);
            PSSLogEntry(PSS_ERR, 1, "Failed to receive page data - aborting");
            PSSLogEntry(PSS_MSG, 2, "send: <can> (=ASCII 24)");
            FComDirectSyncWriteFast(pTG, &bCancel, 1);
            ICommPutRecvBuf(pTG, NULL, RECV_FLUSH);
            err_status = T30_CALLFAIL;
            return err_status;
        }

        PSSLogEntry(PSS_MSG, 1, "Successfully received page data");
        PSSLogEntry(PSS_MSG, 0, "Phase D - Post Message Exchange");

        // See if more pages to receive by parsing the FDR response...
        // After the DLEETX was received by Class2ModemRecvBuf, the
        // FPTS and FET response should be coming from the modem, terminated
        // by an OK. Let's go read that!

        if (!Class2iModemDialog(pTG,
                                NULL,
                                0,
                                STARTSENDMODE_TIMEOUT,
                                0,
                                TRUE,
                                pTG->cbszCLASS2_OK,
                                (C2PSTR)NULL))
        {
            PSSLogEntry(PSS_ERR, 1, "Failed to receive EOP or MPS or EOM - aborting");
            err_status =  T30_CALLFAIL;
            return err_status;
        }
        if (pTG->fFoundFHNG)
        {
            PSSLogEntry(PSS_ERR, 1, "Call was disconnected");
            err_status =  T30_CALLFAIL;
            return err_status;
        }

        DebugPrintEx(DEBUG_MSG,"EOP Received %s", (LPSTR)(&(pTG->lpbResponseBuf2)));

        // Process the response and see if more pages are coming

        uEndPageAction = Class2EndPageResponseAction(pTG);
        if (uEndPageAction == MORE_PAGES)
        {
            ICommPutRecvBuf(pTG, NULL, RECV_ENDPAGE);
        }
        else
        {
            ICommPutRecvBuf(pTG, NULL, RECV_ENDDOC);
        }

        // Send the FPTS - don't do this for Exar modems!
        if (!pTG->CurrentMFRSpec.bIsExar)
        {
            if (pTG->fPageIsBad)
            {
                PSSLogEntry(PSS_MSG, 1, "Sending RTN");
            }
            else
            {
                PSSLogEntry(PSS_MSG, 1, "Sending MCF");
            }
            uwLen = (UWORD)wsprintf(bBuf, pTG->cbszFPTS, pTG->fPageIsBad ? 2 : 1);
            if (!Class2iModemDialog(pTG,
                                    bBuf,
                                    uwLen,
                                    LOCALCOMMAND_TIMEOUT,
                                    0,
                                    TRUE,
                                    pTG->cbszCLASS2_OK,
                                    pTG->cbszCLASS2_ERROR,
                                    (C2PSTR) NULL))
            {
                PSSLogEntry(PSS_WRN, 1, "Failed to send MCF/RTN - continuing anyway");
                // Ignore FPTS failure!!!
            }
        }

        if ((uEndPageAction==MORE_PAGES) || (pTG->fPageIsBad))
        {
            // Now, Send the FDR to start the next page (this was done for
            // the first page before entering the multipage loop).

            if (Class2iModemDialog(pTG,
                                    pTG->cbszFDR,
                                    (UWORD)(strlen(pTG->cbszFDR)),
                                    STARTSENDMODE_TIMEOUT,
                                    0,
                                    TRUE,
                                    pTG->cbszFDT_CONNECT,
                                    (C2PSTR) NULL) != 1)
            {
                DebugPrintEx(DEBUG_ERR,"FDR to start next PAGE Failed");
                if (pTG->fFoundFHNG)
                {
                    PSSLogEntry(PSS_ERR, 1, "Call was disconnected");
                }
                err_status =  T30_CALLFAIL;
                return err_status;
            }
            // Need to check whether modem performed re-negotiation, and
            // update the TIFF accordingly
            if (Class2ResponseAction(pTG, (LPPCB) &Pcb))
            {
                PSSLogEntry(PSS_MSG, 1, "Received DCS is as follows");
                LogClass2DCSDetails(pTG, &Pcb);
                if (!Class2UpdateTiffInfo(pTG, &Pcb))
                {
                    DebugPrintEx(DEBUG_WRN, "Class2UpdateTiffInfo failed");
                }
            }

            PSSLogEntry(PSS_MSG, 0, "Phase C - Receive page");
            PSSLogEntry(PSS_MSG, 2, "send: <DC2> (=ASCII %d)", *(pTG->CurrentMFRSpec.szDC2));
            // Now send the correct DC2 string set in Class2Callee
            // (DC2 is standard, some use ^q instead)
            FComDirectSyncWriteFast(pTG, pTG->CurrentMFRSpec.szDC2, 1);

        } //if we do not have another page, do the else...
        else
        {
            // Send last FDR
            if (!Class2iModemDialog(pTG,
                                    pTG->cbszFDR,
                                    (UWORD)(strlen(pTG->cbszFDR)),
                                    STARTSENDMODE_TIMEOUT,
                                    0,
                                    TRUE,
                                    pTG->cbszCLASS2_OK,
                                    (C2PSTR)NULL))
            {
                DebugPrintEx(DEBUG_ERR,"FDR failed");
                err_status =  T30_CALLFAIL;
                return err_status;
            }
            // pTG->fFoundFHNG should be TRUE here - that's normal
            break; // All done receiving pages...
        }
    } //End of multipage while

    FComXon(pTG, FALSE);

    return err_status;
}


BOOL Class2GetModemMaker(PThrdGlbl pTG)
{
    HRESULT hr;
    
    DEBUG_FUNCTION_NAME("Class2GetModemMaker");
    // Initialize the current modem variable's (global) strings.
    pTG->CurrentMFRSpec.szMFR[0] = '\0';
    pTG->CurrentMFRSpec.szMDL[0] = '\0';

    // For all responses, "ERROR" may come back - that is OK - we will
    // never match ERROR to an acceptable modem manufacturer name, model,
    // revision, etc.

    // Get the FMFR - repsonse is in pTG->lpbResponseBuf2
    if (!Class2iModemDialog(pTG,
                            pTG->cbszCLASS2_FMFR,
                            (UWORD)(strlen(pTG->cbszCLASS2_FMFR)),
                            ANS_LOCALCOMMAND_TIMEOUT,
                            0,
                            TRUE,
                            pTG->cbszCLASS2_OK,
                            pTG->cbszCLASS2_ERROR,
                            (C2PSTR) NULL))
    {
        DebugPrintEx(DEBUG_ERR,"FMFR failed");
        // Ignore FMFR failure!!!
    }
    else
    {
        // copy FMFR answer into FMFR variable
        hr = StringCchCopy(pTG->CurrentMFRSpec.szMFR, ARR_SIZE(pTG->CurrentMFRSpec.szMFR), pTG->lpbResponseBuf2);
    	if (FAILED(hr))
    	{
    		DebugPrintEx(DEBUG_WRN,"StringCchCopy failed (ec=0x%08X)",hr);
    	}
    
        DebugPrintEx(DEBUG_MSG,"Received FMFR %s", (LPSTR)(&(pTG->lpbResponseBuf2)));
    }


    // Get the FMDL - repsonse is in pTG->lpbResponseBuf2
    if (!Class2iModemDialog(pTG,
                            pTG->cbszCLASS2_FMDL,
                            (UWORD)(strlen(pTG->cbszCLASS2_FMDL)),
                            ANS_LOCALCOMMAND_TIMEOUT,
                            0,
                            TRUE,
                            pTG->cbszCLASS2_OK,
                            pTG->cbszCLASS2_ERROR,
                            (C2PSTR) NULL))
    {
        DebugPrintEx(DEBUG_ERR,"FMDL failed");
        // Ignore FMDL failure!!!
    }
    else
    {
        // copy FMDL answer into FMDL variable
        hr = StringCchCopy(pTG->CurrentMFRSpec.szMDL, ARR_SIZE(pTG->CurrentMFRSpec.szMDL), pTG->lpbResponseBuf2);
    	if (FAILED(hr))
    	{
    		DebugPrintEx(DEBUG_WRN,"StringCchCopy failed (ec=0x%08X)",hr);
    	}
        DebugPrintEx(DEBUG_MSG,"Received FMDL %s", (LPSTR)(&(pTG->lpbResponseBuf2)));
    }

    return TRUE;
}


void Class2SetMFRSpecific(PThrdGlbl pTG)
{

    USHORT iIndex, iFoundMFR,iFoundMDL;
    LPMFRSPEC lpmfrMatched;

    DEBUG_FUNCTION_NAME("Class2SetMFRSpecific");

    // Find the index into the table that corresponds most closely
    // to the modem. If we can't find the mfr and model, find a mfr
    // that matches (use the last one). If neither, use the default
    // last entry.

    // Look for Manufacturer name
    iIndex = 0;
    iFoundMFR = 0;
    iFoundMDL = 0;
    DebugPrintEx(DEBUG_MSG,"Entering search table loop");
    while (Class2ModemTable[iIndex].szMFR[0] != '\0')
    {
        lpmfrMatched = &(Class2ModemTable[iIndex]);
        // Look and see if the current name matches
        // the name in the list.
        if (strstr( (LPSTR)pTG->CurrentMFRSpec.szMFR,
                            (LPSTR)lpmfrMatched->szMFR) != NULL)
        {
            // Found a match!
            DebugPrintEx(   DEBUG_MSG,
                            "Matched manufacturer name: %s %s",
                            (LPSTR)(&pTG->CurrentMFRSpec.szMFR),
                            (LPSTR)(&(lpmfrMatched->szMFR)));

            iFoundMFR = iIndex;
            //Now see if this matches the model number, too.
            if(strstr(  (LPSTR) pTG->CurrentMFRSpec.szMDL,
                                (LPSTR) lpmfrMatched->szMDL) != NULL)
            {
                //Got a MDL match, too! Stop looking.
                iFoundMDL = iIndex;
                DebugPrintEx(   DEBUG_MSG,
                                "Matched model: %s %s",
                                (LPSTR)(&pTG->CurrentMFRSpec.szMDL),
                                (LPSTR)(&(lpmfrMatched->szMDL)));
                break;
            }
        }

        iIndex++;
    }


    // We now either have the modem match or are using the defaults!
    if (iFoundMFR != 0)
    {
        lpmfrMatched = &Class2ModemTable[iFoundMFR];
    }
    else
    {
        lpmfrMatched = &Class2ModemTable[iIndex];
    }

    // All these settings were read from the registry during T30ModemInit.
    // Since we want registry values to take precedence over internal table
    // values, change only the settings that were not found in the registry
    // (they'll have a value of CL2_DEFAULT_SETTING).

    // Set proper BOR for receive and send

    if (pTG->CurrentMFRSpec.iSendBOR == CL2_DEFAULT_SETTING)
    {
        pTG->CurrentMFRSpec.iSendBOR = lpmfrMatched->iSendBOR;
    }
    if (pTG->CurrentMFRSpec.iReceiveBOR == CL2_DEFAULT_SETTING)
    {
        pTG->CurrentMFRSpec.iReceiveBOR = lpmfrMatched->iReceiveBOR;
    }
    if (pTG->CurrentMFRSpec.fSWFBOR == CL2_DEFAULT_SETTING)
    {
        pTG->CurrentMFRSpec.fSWFBOR  = lpmfrMatched->fSWFBOR;
    }

    // Set the DC2 string - this is used in receive mode
    // after sending the FDR to tell the modem we are ready
    // to receive data. The standard says it should be a Dc2
    // (^R). But, some modems use ^Q
    if (pTG->CurrentMFRSpec.szDC2[0] == (CHAR)CL2_DEFAULT_SETTING)
    {
        pTG->CurrentMFRSpec.szDC2[0] = lpmfrMatched->szDC2[0];
    }
    // Set the Sierra  and Exar flags flag

    if (pTG->CurrentMFRSpec.bIsSierra == CL2_DEFAULT_SETTING)
    {
        pTG->CurrentMFRSpec.bIsSierra = lpmfrMatched->bIsSierra;
    }
    if (pTG->CurrentMFRSpec.bIsExar == CL2_DEFAULT_SETTING)
    {
        pTG->CurrentMFRSpec.bIsExar = lpmfrMatched->bIsExar;
    }
    if (pTG->CurrentMFRSpec.fSkipCtrlQ == CL2_DEFAULT_SETTING)
    {
        pTG->CurrentMFRSpec.fSkipCtrlQ = lpmfrMatched->fSkipCtrlQ;
    }

    DebugPrintEx(DEBUG_MSG, "CurrentMFRSpec = %02x, %02x, %02x, %02x, %02x, %02x, %02x",
            pTG->CurrentMFRSpec.iReceiveBOR,
            pTG->CurrentMFRSpec.iSendBOR,
            pTG->CurrentMFRSpec.szDC2[0],
            pTG->CurrentMFRSpec.bIsSierra,
            pTG->CurrentMFRSpec.bIsExar,
            pTG->CurrentMFRSpec.fSkipCtrlQ = lpmfrMatched->fSkipCtrlQ,
            pTG->CurrentMFRSpec.fSWFBOR);
}


BOOL Class2Parse(PThrdGlbl pTG, CL2_COMM_ARRAY *cl2_comm, BYTE lpbBuf[])
{
    int     i,
            j,
            comm_numb = 0,
            parameters;
    BYTE    switch_char,
            char_1,
            char_2;
    char    c;

    BOOL    found_command = FALSE;

    DEBUG_FUNCTION_NAME("Class2Parse");

    #define STRING_PARAMETER        1
    #define NUMBER_PARAMETERS       2
    for (i = 0; lpbBuf[i] != '\0'; ++i)
    {
        if (comm_numb >= MAX_CLASS2_COMMANDS)
        {
            DebugPrintEx(DEBUG_WRN, "Reached maximum number of commands");
            break;
        }

        switch (lpbBuf[i])
        {
        case 'C':
                if (lpbBuf[++i] == 'O' && lpbBuf[++i] == 'N')
                {
                    cl2_comm->command[comm_numb++] = CL2DCE_CONNECT;
                    for(; lpbBuf[i] != '\r'; ++i )
                            ;
                }
                else
                {
                    DebugPrintEx(DEBUG_ERR,"Parse: Bad First C values");
                    return FALSE;
                }
                break;

        case 'O':
                if (lpbBuf[++i] == 'K' )
                {
                    cl2_comm->command[comm_numb++] = CL2DCE_OK;
                    for(; lpbBuf[i] != '\r'; ++i )
                            ;
                }
                else
                {
                    DebugPrintEx(DEBUG_ERR,"Parse: Bad O values");
                    return FALSE;
                }
                break;

        case 0x11:
                cl2_comm->command[comm_numb++] = CL2DCE_XON;
                break;

        case '+':
                if( lpbBuf[++i] != 'F' )
                {
                    DebugPrintEx(DEBUG_ERR,"Parse: Bad + values");
                    return FALSE;
                }
                switch_char = lpbBuf[++i];
                char_1 = lpbBuf[++i];
                char_2 = lpbBuf[++i];
                switch ( switch_char )
                {
                case 'C':
                        //  Connect Message +FCON.
                        if ( char_1 == 'O' && char_2 == 'N' )
                        {
                            cl2_comm->command[comm_numb] = CL2DCE_FCON;
                            parameters = FALSE;
                        }

                        // Report of Remote ID. +FCIG.
                        else if (char_1 == 'I' && char_2 == 'G' )
                        {
                            cl2_comm->command[comm_numb] = CL2DCE_FCIG;
                            parameters = STRING_PARAMETER;
                        }

                        // Prepare to receive prompt.  +FCFR.
                        else if ( char_1 == 'F' && char_2 == 'R' )
                        {
                            cl2_comm->command[comm_numb] = CL2DCE_FCFR;
                            parameters = FALSE;
                        }
                        // Report the Remote ID CSI +FCSI.
                        else if ( char_1 == 'S' && char_2 == 'I' )
                        {
                            cl2_comm->command[comm_numb] = CL2DCE_FCSI;
                            parameters = STRING_PARAMETER;
                        }
                        else
                        {
                            DebugPrintEx(DEBUG_ERR,"Parse: Bad C values");
                            return FALSE;
                        }
                        break;

                case 'D':
                        // Report DCS frame information +FDCS.
                        if ( char_1 == 'C' && char_2 == 'S' )
                        {
                            cl2_comm->command[comm_numb] = CL2DCE_FDCS;
                            parameters = NUMBER_PARAMETERS;
                        }
                        // Report DIS frame information +FDIS.
                        else if ( char_1 == 'I' && char_2 == 'S' )
                        {
                            cl2_comm->command[comm_numb] = CL2DCE_FDIS;
                            parameters = NUMBER_PARAMETERS;
                        }
                        // Report DTC frame information +FDTC.
                        else if ( char_1 == 'T' && char_2 == 'C' )
                        {
                            cl2_comm->command[comm_numb] = CL2DCE_FDTC;
                            parameters = NUMBER_PARAMETERS;
                        }
                        else
                        {
                            DebugPrintEx(DEBUG_ERR,"Parse: Bad D values");
                            return FALSE;
                        }
                        break;

                case 'E':
                        // Post page message report. +FET.
                        if ( char_1 == 'T' )
                        {
                            --i;
                            cl2_comm->command[comm_numb] = CL2DCE_FET;
                            parameters = NUMBER_PARAMETERS;
                        }
                        else
                        {
                            DebugPrintEx(DEBUG_ERR,"Parse: Bad E values");
                            return FALSE;
                        }
                        break;

                case 'H':
                        // Debug report transmitted HDLC frames +FHT
                        if ( char_1 == 'T' )
                        {
                            --i;
                            cl2_comm->command[comm_numb] = CL2DCE_FHT;
                            parameters = STRING_PARAMETER;
                        }
                        // Debug report received HDLC frames +FHR
                        else if ( char_1 == 'R' )
                        {
                            --i;
                            cl2_comm->command[comm_numb] = CL2DCE_FHR;
                            parameters = STRING_PARAMETER;
                        }
                        // Report hang up.  +FHNG.
                        else if ( char_1 == 'N' && char_2 == 'G' )
                        {
                            cl2_comm->command[comm_numb] = CL2DCE_FHNG;
                            parameters = NUMBER_PARAMETERS;
                            DebugPrintEx(DEBUG_MSG, "Found FHNG");
                            pTG->fFoundFHNG = TRUE;
                        }
                        else
                        {
                            DebugPrintEx(DEBUG_ERR,"Parse: Bad H values");
                            return FALSE;
                        }
                        break;
                case 'N':
                        // Report NSF frame reciept.
                        if ( char_1 == 'S' && char_2 == 'F' )
                        {
                            cl2_comm->command[comm_numb] = CL2DCE_FNSF;
                            parameters = NUMBER_PARAMETERS;
                        }
                        // Report NSS frame reciept.
                        else if ( char_1 == 'S' && char_2 == 'S' )
                        {
                            cl2_comm->command[comm_numb] = CL2DCE_FNSS;
                            parameters = NUMBER_PARAMETERS;
                        }
                        // Report NSC frame reciept.
                        else if ( char_1 == 'S' && char_2 == 'C' )
                        {
                            cl2_comm->command[comm_numb] = CL2DCE_FNSC;
                            parameters = NUMBER_PARAMETERS;
                        }
                        else
                        {
                            DebugPrintEx(DEBUG_ERR,"Parse: Bad N values");
                            return FALSE;
                        }
                        break;

                case 'P':
                        // Report poll request. +FPOLL
                        if ( char_1 == 'O' && char_2 == 'L' )
                        {
                            cl2_comm->command[comm_numb] = CL2DCE_FPOLL;
                            parameters = FALSE;
                        }
                        // Page Transfer Status Report +FPTS.
                        else if ( char_1 == 'T' && char_2 == 'S' )
                        {
                            cl2_comm->command[comm_numb] = CL2DCE_FPTS;
                            parameters = NUMBER_PARAMETERS;
                        }
                        else
                        {
                            DebugPrintEx(DEBUG_ERR,"Parse: Bad P values");
                            return FALSE;
                        }
                        break;
                case 'T':
                        // Report remote ID +FTSI.
                        if ( char_1 == 'S' && char_2 == 'I' )
                        {
                            cl2_comm->command[comm_numb] = CL2DCE_FTSI;
                            parameters = STRING_PARAMETER;
                        }
                        else
                        {
                            DebugPrintEx(DEBUG_ERR,"Parse: Bad T values");
                            return FALSE;
                        }
                        break;
                case 'V':
                        // Report voice request +FVOICE.
                        if ( char_1 == 'O' && char_2 == 'I' )
                        {
                            cl2_comm->command[comm_numb] = CL2DCE_FVOICE;
                            parameters = FALSE;
                        }
                        else
                        {
                            DebugPrintEx(DEBUG_ERR,"Parse: Bad V values");
                            return FALSE;
                        }
                }

                //  Transfer the associated paramters to the parameter array.
                if (parameters == NUMBER_PARAMETERS)
                {
                    for (i+=1,j=0; lpbBuf[i] != '\r' && lpbBuf[i] != '\0'; ++i)
                    {
                        //  Skip past the non numeric characters.
                        if ( lpbBuf[i] < '0' || lpbBuf[i] > '9' )
                        {
                            continue;
                        }

                        /*  Convert the character representation of the numeric
                                 parameter into a true number, and store in the
                                parameter list.  */
                        cl2_comm->parameters[comm_numb][j] = 0;

                        for (; lpbBuf[i] >= '0' && lpbBuf[i] <= '9'; ++i)
                        {
                            cl2_comm->parameters[comm_numb][j] *= 10;
                            cl2_comm->parameters[comm_numb][j] += lpbBuf[i] - '0';
                        }
                        i--; // the last for loop advanced 'i' past the numeric.
                        j++; // get set up for next parameter
                    }
                }
                else if (parameters == STRING_PARAMETER )
                {
                    // Skip the : that follows the +f command (eg +FTSI:)
                    if (lpbBuf[i+1] == ':')
                    {
                        i++;
                    }
                    // Also skip leading blanks
                    while (lpbBuf[i+1] == ' ')
                    {
                        i++;
                    }
                    for (i+=1, j=0; (j < MAX_PARAM_LENGTH-1) && 
                                    (c = lpbBuf[i])  != '\r' && c != '\n' && c != '\0'; ++i, ++j)
                    {
                        cl2_comm->parameters[comm_numb][j] = c;
                        if ( lpbBuf[i] == '\"' )
                        {
                            --j;
                        }
                    }
                    cl2_comm->parameters[comm_numb][j] = '\0';
                }
                //  No parameters, so just skip to end of line.
                else
                {
                    for(; (c=lpbBuf[i]) != '\r' && c != '\n' && c != '\0'; ++i)
                        ;
                }

                if (cl2_comm->command[comm_numb] == CL2DCE_FHNG)
                {
                    pTG->dwFHNGReason = cl2_comm->parameters[comm_numb][0];
                    DebugPrintEx(DEBUG_MSG, "Found FHNG, reason = %d", pTG->dwFHNGReason);
                }

                //  Increment command count.
                ++comm_numb;
                break;

        default:
                break;
        }
    }
    cl2_comm->comm_count = (USHORT)comm_numb;
    return TRUE;
}
=== C:/Users/treeman/Desktop/windows nt source code\Source\Win2K3\NT\printscan\faxsrv\provider\t30\comm\fdebug.h ===
/***************************************************************************
 Name     :     FDEBUG.H
 Comment  :
 Functions:     (see Prototypes just below)

                Copyright (c) Microsoft Corp. 1991, 1992, 1993

 Revision Log
 Date     Name  Description
 -------- ----- ---------------------------------------------------------
***************************************************************************/



/****************** begin prototypes from debug.c *****************/
extern void   far D_HexPrint(LPB b1, UWORD incnt);

#ifdef DEBUG
        void D_PrintCE(int err);
        void D_PrintCOMSTAT(PThrdGlbl pTG, COMSTAT far* lpcs);
        void D_PrintFrame(LPB npb, UWORD cb);
#else
#       define D_PrintCE(err)                           {}
#       define D_PrintCOMSTAT(pTG, lpcs)                     {}
#       define D_PrintFrame(npb, cb)            {}
#endif
/***************** end of prototypes from debug.c *****************/





#define FILEID_FCOM             21
#define FILEID_FDEBUG           22
#define FILEID_FILTER           23
#define FILEID_IDENTIFY         24
#define FILEID_MODEM            25
#define FILEID_NCUPARMS         26
#define FILEID_TIMEOUTS         27
=== C:/Users/treeman/Desktop/windows nt source code\Source\Win2K3\NT\printscan\faxsrv\provider\t30\comm\fcomint.h ===
/***************************************************************************
        Name      :     FCOMINt.H
        Comment   :     Interface between FaxComm driver (entirely different for
                                Windows and DOS) and everything else.

                Copyright (c) Microsoft Corp. 1991, 1992, 1993

        Num   Date      Name     Description
        --- -------- ---------- -----------------------------------------------
***************************************************************************/

#define WRITEQUANTUM    (pTG->Comm.cbOutSize / 8)            // totally arbitrary

#define CR                              0x0d
#define LF                              0x0a
#define DLE                             0x10            // DLE = ^P = 16d = 10h
#define ETX                             0x03

BOOL            ov_init(PThrdGlbl pTG);
BOOL            ov_deinit(PThrdGlbl pTG);
OVREC *         ov_get(PThrdGlbl pTG);
BOOL            ov_write(PThrdGlbl  pTG, OVREC *lpovr, LPDWORD lpdwcbWrote);
BOOL            ov_drain(PThrdGlbl pTG, BOOL fLongTO);
BOOL            ov_unget(PThrdGlbl pTG, OVREC *lpovr);
BOOL            iov_flush(PThrdGlbl pTG, OVREC *lpovr, BOOL fLongTO);
=== C:/Users/treeman/Desktop/windows nt source code\Source\Win2K3\NT\printscan\faxsrv\provider\t30\comm\makefile.inc ===
obj\$(TARGET_DIRECTORY)\awmodem.h: awmodem.inf
        bin2c -a awmodem.inf obj\$(TARGET_DIRECTORY)\awmodem.h szAwmodemInf

obj\$(TARGET_DIRECTORY)\adaptive.h: adaptive.inf
        bin2c -a adaptive.inf obj\$(TARGET_DIRECTORY)\adaptive.h szAdaptiveInf
=== C:/Users/treeman/Desktop/windows nt source code\Source\Win2K3\NT\printscan\faxsrv\provider\t30\comm\identify.c ===
/***************************************************************************
        Name      :     IDENTIFY.C
        Comment   :     Identifying modems

                Copyright (c) Microsoft Corp. 1991, 1992, 1993

        Revision Log
        Num   Date      Name     Description
        --- -------- ---------- -----------------------------------------------
***************************************************************************/
#define USE_DEBUG_CONTEXT   DEBUG_CONTEXT_T30_CLASS1


#include "prep.h"


#include "modemint.h"
//#include "fcomint.h"
#include "fdebug.h"

#include "awmodem.h"
#include "adaptive.h"


///RSL
#include "glbproto.h"

#define BIGTEMPSIZE             250

#include "inifile.h"

char szModemFaxClasses[] = "ModemFaxClasses";
char szModemSendSpeeds[] = "ModemSendSpeeds";
char szModemRecvSpeeds[] = "ModemRecvSpeeds";
char szModemId[]         = "ModemId";
char szModemIdCmd[]      = "ModemIdCmd";
char szClass0ModemId[]   = "Class0ModemId";
char szClass2ModemId[]   = "Class2ModemId";
char szClass20ModemId[]  = "Class2.0ModemId";

char szResetCommand[]    = "ResetCommand";
char szResetCommandGenerated[] = "ResetCommandGenerated";
char szSetupCommand[]    = "SetupCommand";
char szSetupCommandGenerated[] = "SetupCommandGenerated";
char szExitCommand[]     = "ExitCommand";
char szPreDialCommand[]  = "PreDialCommand";
char szPreAnswerCommand[]= "PreAnswerCommand";

// RSL new UNIMODEM INF settings (FAX GENERIC)

char szHardwareFlowControl[]  = "HardwareFlowControl";
char szSerialSpeedInit[]      = "SerialSpeedInit";
char szSerialSpeedConnect[]   = "SerialSpeedConnect";
char szAdaptiveAnswerEnable[] = "AdaptiveAnswerEnable"; 

// new ADAPTIVE INF file (FAX ADAPTIVE)
char      szResponsesKeyName[]  =    "ResponsesKeyName=";
char      szResponsesKeyName2[]  =   "ResponsesKeyName";

char szAdaptiveRecordUnique[] =      "AdaptiveRecordUnique";
char szAdaptiveCodeId[] =            "AdaptiveCodeId";  
char szFaxClass[] =                  "FaxClass";
char szAnswerCommand[] =             "AnswerCommand";
char szModemResponseFaxDetect[] =    "ModemResponseFaxDetect";
char szModemResponseDataDetect[] =   "ModemResponseDataDetect";
char szSerialSpeedFaxDetect[] =      "SerialSpeedFaxDetect";
char szSerialSpeedDataDetect[] =     "SerialSpeedDataDetect";
char szHostCommandFaxDetect[] =      "HostCommandFaxDetect";
char szHostCommandDataDetect[] =     "HostCommandDataDetect";
char szModemResponseFaxConnect[] =   "ModemResponseFaxConnect";
char szModemResponseDataConnect[] =  "ModemResponseDataConnect";

// how was the Modem Key created
char szModemKeyCreationId[] =        "ModemKeyCreationId";


#define NUM_CL0IDCMDS           7
#define NUM_CL2IDCMDS           3
#define NUM_CL20IDCMDS          3

#define LEN_CL0IDCMDS           5
#define LEN_CL2IDCMDS           9
#define LEN_CL20IDCMDS          8


USHORT iModemFigureOutCmdsExt(PThrdGlbl pTG);
BOOL iModemCopyOEMInfo(PThrdGlbl pTG);
void SmashCapsAccordingToSettings(PThrdGlbl pTG);


NPSTR szClass0IdCmds[NUM_CL0IDCMDS] =
{
        "ATI0\r",
        "ATI1\r",
        "ATI2\r",
        "ATI3\r",
        "ATI4\r",
        "ATI5\r",
        "ATI6\r"
};

NPSTR szClass2IdCmds[NUM_CL2IDCMDS] =
{
        "AT+FMFR?\r",
        "AT+FMDL?\r",
        "AT+FREV?\r"
};

NPSTR szClass20IdCmds[NUM_CL20IDCMDS] =
{
        "AT+FMI?\r",
        "AT+FMM?\r",
        "AT+FMR?\r"
};


typedef struct {
        USHORT  uGoClass,   //@ The fax class the modem need to be put on before using the id commands.
                uNum,       //@ The number of strings (commands) in the command table.
                uLen;       //@ The maximum length (required buffer size) in the command table.
                            //@ (including space for a terminating NULL char).
        NPSTR   *CmdTable;  //@ An array of strings each containing a modem id command.
        NPSTR   szIniEntry; //@ The name of the registry value in which the resulting
                            //@ is should be saved ("Class0ModemId", "Class2ModemId", "Class2.0ModemId")

} GETIDSTRUCT, near* NPGETIDSTRUCT;

GETIDSTRUCT GetIdTable[3] =
{
        { 0, NUM_CL0IDCMDS, LEN_CL0IDCMDS, szClass0IdCmds, szClass0ModemId },
        { 2, NUM_CL2IDCMDS, LEN_CL2IDCMDS, szClass2IdCmds, szClass2ModemId },
        { GOCLASS2_0, NUM_CL20IDCMDS, LEN_CL20IDCMDS, szClass20IdCmds, szClass20ModemId }
};

#define MAXCMDSIZE              128
#define MAXIDSIZE               128
#define RESPONSEBUFSIZE 256
#define SMALLTEMPSIZE   80
#define TMPSTRINGBUFSIZE (8*MAXCMDSIZE+MAXIDSIZE+RESPONSEBUFSIZE+2*SMALLTEMPSIZE+12)
                                // Enough space for all the lpszs below.




BOOL imodem_alloc_tmp_strings(PThrdGlbl pTG);
void imodem_free_tmp_strings(PThrdGlbl pTG);
void imodem_clear_tmp_settings(PThrdGlbl pTG);


///////////////////////////////////////////////////////////////////////////////////////
//  Function: 
//                  IsCacheIntDirty
//
//  Purpose:        
//                  This function verifies if the cached settings we have
//                  under HKLM\Sw\Ms\Fax\TAPIDevices is the same as the setting
//                  under Unimodem's key:
//                  HKLM\SYSTEM\CurrentControlSet\Control\Class\{4D36E96D-E325-11CE-BFC1-08002BE10318}
//                  If this setting is different it means that the modem driver was 
//                  updated and we have to re-install the modem and thus update our
//                  cache.
//                  The function validates a numeric setting, which is actually stored 
//                  as a REG_SZ in the registry and converted to UINT.
//                  
//  Params:
//                  ULONG_PTR   UnimodemFaxKey: An open key to Unimodem's registry, 
//                                              retrieved from a call to ProfileOpen.
//                  LPSTR       szSetting:      The setting to check, this is the same
//                                              as appears in the docs (i.e. "FixModemClass").
//                  UINT        uCachedValue:   Our cached value, to be compared with what's
//                                              read from Unimodem's registry.
//
//  Return Value:
//                  TRUE    - Cached value does not match Unimodem's value, need re-installation
//                  FALSE   - Cache is not dirty, OK to continue.
//
//  Author:
//                  Mooly Beery (MoolyB) 14-Nov-2001
///////////////////////////////////////////////////////////////////////////////////////
BOOL IsCacheIntDirty(ULONG_PTR UnimodemFaxKey, LPSTR szSetting,UINT uCachedValue)
{
    BOOL fRet               = FALSE;
    UINT uUnimodemSetting   = 0;
    BOOL fExist             = FALSE;

    DEBUG_FUNCTION_NAME(("IsCacheIntDirty"));

    if (UnimodemFaxKey)
    {
        uUnimodemSetting = ProfileGetInt(UnimodemFaxKey, szSetting, 0, &fExist);
        if (!fExist)
        {
            DebugPrintEx(DEBUG_MSG, "Modem does not have a %s section in its Fax INF section",szSetting);
        }
        else
        {
            if (uUnimodemSetting!=uCachedValue)
            {
                fRet = TRUE;
            }
        }
    }

    return fRet;
}

///////////////////////////////////////////////////////////////////////////////////////
//  Function: 
//                  IsCacheStringDirty
//
//  Purpose:        
//                  This function verifies if the cached settings we have
//                  under HKLM\Sw\Ms\Fax\TAPIDevices is the same as the setting
//                  under Unimodem's key:
//                  HKLM\SYSTEM\CurrentControlSet\Control\Class\{4D36E96D-E325-11CE-BFC1-08002BE10318}
//                  If this setting is different it means that the modem driver was 
//                  updated and we have to re-install the modem and thus update our
//                  cache.
//                  The function validates a string setting.
//                  
//  Params:
//                  ULONG_PTR   UnimodemFaxKey: An open key to Unimodem's registry, 
//                                              retrieved from a call to ProfileOpen.
//                  LPSTR       szSetting:      The setting to check, this is the same
//                                              as appears in the docs (i.e. "FixModemClass").
//                  LPSTR       szCachedValue:  Our cached value, to be compared with what's
//                                              read from Unimodem's registry.
//
//  Return Value:
//                  TRUE    - Cached value does not match Unimodem's value, need re-installation
//                  FALSE   - Cache is not dirty, OK to continue.
//
//  Author:
//                  Mooly Beery (MoolyB) 14-Nov-2001
///////////////////////////////////////////////////////////////////////////////////////
BOOL IsCacheStringDirty(ULONG_PTR UnimodemFaxKey, LPSTR szSetting,LPSTR szCachedValue)
{
    BOOL fRet                           = FALSE;
    UINT uLen                           = 0;
    char szUnimodemSetting[MAXCMDSIZE]  = {0};

    DEBUG_FUNCTION_NAME(("IsCacheStringDirty"));

    if (UnimodemFaxKey)
    {
        uLen = ProfileGetString(UnimodemFaxKey,szSetting,NULL,szUnimodemSetting,MAXCMDSIZE-1);
        if (uLen==0)
        {
            DebugPrintEx(DEBUG_MSG, "Modem does not have a %s section in its Fax INF section",szSetting);
        }
        else
        {
            // szCachedValue has <cr> at the end, so don't include the <cr> in the compare
            if (strncmp(szUnimodemSetting, szCachedValue, max(strlen(szUnimodemSetting), strlen(szCachedValue)-1)))
            {
                fRet = TRUE;
            }
        }
    }

    return fRet;
}

                    
BOOL 
imodem_list_get_str(
    PThrdGlbl pTG,
    ULONG_PTR KeyList[10],
    LPSTR lpszName,
    LPSTR lpszCmdBuf,
    UINT  cbMax,
    BOOL  fCmd);

BOOL imodem_get_str(PThrdGlbl pTG, ULONG_PTR dwKey, LPSTR lpszName, LPSTR lpszCmdBuf, UINT cbMax,
                                        BOOL fCmd);

BOOL SearchInfFile(PThrdGlbl pTG, LPSTR lpstrFile, LPSTR lpstr1, LPSTR lpstr2, LPSTR lpstr3, DWORD_PTR dwLocalKey);
void CheckAwmodemInf(PThrdGlbl pTG);
void ToCaps(LPBYTE lpb);

BOOL iModemGetCurrentModemInfo(PThrdGlbl pTG);

BOOL iModemSaveCurrentModemInfo(PThrdGlbl pTG);


USHORT EndWithCR( LPSTR sz, USHORT uLen)
{
    if(uLen)
    {
        // Check if the string is terminated with a \r
        if(sz[uLen-1] != '\r')
        {
            // add a \r
            sz[uLen++] = '\r';
            sz[uLen] = 0;
        }
    }
    return uLen;
}



BOOL RemoveCR( LPSTR  sz )
{
   DWORD  len;

    if (!sz) 
    {
       return FALSE;
    }

    len = strlen(sz);
    if (len == 0) 
    {
       return FALSE;
    }

    if (sz[len-1] == '\r') 
    {
       sz[len-1] = 0;
    }

    return TRUE;
}


//@
//@ Sends an Id command to the modem and returns the resulting id string.
//@ 
USHORT GetIdResp(PThrdGlbl pTG, LPSTR szSend, USHORT uSendLen, LPBYTE lpbRespOut, USHORT cbMaxOut)
{
    USHORT uRespLen;

    DEBUG_FUNCTION_NAME(("GetIdResp"));

    DebugPrintEx(DEBUG_MSG,"Want Id for (%s)", (LPSTR)szSend);

    pTG->fMegaHertzHack = TRUE;
    //@
    //@ Send the id command to the modem and wait for a response followed by OK or ERROR.
    //@ On return pTG->bLastReply contains the last modem response before the OK or ERROR.
    //@
    OfflineDialog2(pTG, (LPSTR)szSend, uSendLen, cbszOK, cbszERROR);
    pTG->fMegaHertzHack=FALSE;

    // sometimes we don't get the OK so try to parse what we got anyway
    DebugPrintEx(DEBUG_MSG, "LastLine = (%s)",(LPSTR)(&(pTG->FComModem.bLastReply)));
    uRespLen = min(cbMaxOut, _fstrlen(pTG->FComModem.bLastReply));

    _fmemcpy(lpbRespOut, pTG->FComModem.bLastReply, uRespLen);
    lpbRespOut[uRespLen] = 0; // zero terminate the string

    return uRespLen;
}




USHORT GetIdForClass
(
    PThrdGlbl pTG, 
    NPGETIDSTRUCT npgids, 
    LPBYTE lpbOut, 
    USHORT cbMaxOut,
    LPBYTE lpbLongestId, 
    USHORT cbMaxLongestId, 
    LPBYTE lpbLongestCmd
)
/*++

Routine Description:

    The functions returns a id string for the modem. 
    The string is class dependent (as indicated in npgids,uGoClass).
    The string will be in the format id1;id2;..idn where id<i> is the response of the 
    modem to command i in the input GETIDSTRUCT::CmdTable array.
    It optionally returns the longest id ( form the result of the first 3 commands) and 
    the command that generatedthis longest id.


Arguments:

    pTG [IN/OU]
        A pointer to the infamous ThrdGlbl.

    npgids [IN]
        Pointer to GETIDSTRUCT that specifies the commands to send to get the id

    lpbOut [OUT]
        A buffer where the generated id string will be placed.
        The string will be in the format id1;id2;..idn where id<i> is the response of the 
        modem to command i in the input GETIDSTRUCT::CmdTable array.

    cbMaxOut [IN]
        The maximum size of the above buffer

    lpbLongestId [OUT] OPTIONAL
        A buffer where longest id string will be placed.
        Can be NULL in which case it will not be used.

    cbMaxLongestId [IN] OPTIONAL
        The size of the longest id buffer
        
    lpbLongestCmd
        A pointer to the command string (in the provided npgids::CmdTable) that generated
        the longer id as described above.

Return Value:


--*/
{
        USHORT  i, j, k, uRet, uLen, uLenLong, iLong;
        LPBYTE  lpbLong;
        
        DEBUG_FUNCTION_NAME(TEXT("GetIdForClass"));

        cbMaxOut -= 2; // make space for trailing ; and \0
        if(lpbLongestId)
                cbMaxLongestId -= 1; // make space for trailing \0
        uLen=0;

        if(npgids->uGoClass)
        {
                //@
                //@ Put the modem into the class required to use the id commands
                //@
                DebugPrintEx(DEBUG_MSG,
                             TEXT("Putting the modem into class %ld"),
                             npgids->uGoClass);

                if(!iiModemGoClass(pTG, npgids->uGoClass, 0))
                {
                        DebugPrintEx(   DEBUG_ERR,
                                        "GoClass %d failed",
                                        npgids->uGoClass);
                        goto done;
                }
        }

        for(lpbLong=NULL, uLenLong=0, i=0; i<npgids->uNum; i++)
        {
            //@ 
            //@ Sent the command at index I in the command table to the modem
            //@ and get the response in (*lpbOut+uLen). This effectively
            //@ concatenates all the responses (seperated with ";")
            //@
                uRet = GetIdResp(
                            pTG, 
                            npgids->CmdTable[i], 
                            npgids->uLen, 
                            lpbOut+uLen, 
                            (USHORT)(cbMaxOut-uLen)
                            );
                // find longest ID among ATI0 thru 3 only!
                if(i<=3 && uLenLong < cbMaxLongestId && uRet > uLenLong)
                {
                        //@
                        //@ Update the length of the longest id (but not above the
                        //@ max size the caller specified).
                        //@
                        uLenLong = min(uRet, cbMaxLongestId);
                        //@
                        //@ lpbLong points to the longets id
                        //@
                        lpbLong = lpbOut + uLen;
                        //@
                        //@ iLong id holds the index (0,1,2) of the longer id
                        //@
                        iLong = i;
                }
                uLen += uRet;
                //@
                //@ Seperate the ids by a ";"
                //@
                lpbOut[uLen++] = ';';
        }
        lpbOut[uLen] = 0;

        if(lpbLongestId && lpbLongestCmd && cbMaxLongestId && lpbLong && uLenLong)
        {
                //@ 
                //@ Copy the longest id (0,1 or 2) to the caller's buffer
                //@
                _fmemcpy(lpbLongestId, lpbLong, uLenLong);
                lpbLongestId[uLenLong] = 0;
                //@
                //@ Copy the command that generated the longest id to the caller's buffer
                //@
                _fmemcpy(lpbLongestCmd, npgids->CmdTable[iLong], npgids->uLen);
                lpbLongestCmd[npgids->uLen] = 0;
                DebugPrintEx(   DEBUG_MSG,
                                "LongestId (%s)-->(%s)", 
                                (LPSTR)lpbLongestCmd, 
                                (LPSTR)lpbLongestId);
        }
        // strip non-prinatbles. *AFTER* extracting the ModemId string!!
        for(j=0, k=0; j<uLen; j++)
        {
            if(lpbOut[j] >= 32 && lpbOut[j] <= 127)
                    lpbOut[k++] = lpbOut[j];
        }
        uLen = k;
        lpbOut[uLen] = 0;
        DebugPrintEx(   DEBUG_MSG,
                        "Class%dId (%s)", 
                        npgids->uGoClass, 
                        (LPSTR)lpbOut);

done:
        if(npgids->uGoClass)
        {
            //@
            //@ Go back to class 0 if we changes classes
            //@
                iiModemGoClass(pTG, 0, 0);
        }
        return uLen;
}


void iModemGetWriteIds(PThrdGlbl pTG, BOOL fGotOEMInfo)
{
        // As with iModemFigureOutCmds and iModemGetCaps, we selectively
        // detect ID's taking into account OEM info that's already read in...
        USHORT     uLen1, uLen2, uLen3;
        DWORD_PTR  dwKey=0;
        LPSTR      lpstr1 = 0, lpstr2 = 0, lpstr3 = 0;
        USHORT     uClasses = pTG->TmpSettings.lpMdmCaps->uClasses;

        DEBUG_FUNCTION_NAME(("iModemGetWriteIds"));

        uLen1 = uLen2 = uLen3 = 0;

        //@ Open the device key 
        if (!(dwKey=ProfileOpen(    pTG->FComModem.dwProfileID, 
                                    pTG->FComModem.rgchKey,
                                    fREG_CREATE | fREG_READ | fREG_WRITE)))

        {
                DebugPrintEx(DEBUG_ERR,"Couldn't get location of modem info.");
                goto end;
        }
        
        if (pTG->TmpSettings.dwGot & fGOTPARM_IDCMD)
        {
            //@
            //@ We already have the id command (we read it from the registry during iModemGetCurrentModemInfo)
            //@

                int i=0;

                if (!pTG->TmpSettings.szIDCmd[0])
                {
                    //@
                    //@ We have a null ID command so we can't really do anything 
                    //@ just save and exit.
                    goto SaveIDandCMD;
                }
                //@
                //@ We have a non empty id command and can try to use it to detect the id.
                //@
                while(i++<2)
                {
                        pTG->TmpSettings.szID[0]=0;
                        pTG->TmpSettings.szResponseBuf[0]=0;
                        //@ Send the id command to the modem. The id string is returned
                        //@ in pTG->TmpSettigns.szID
                        GetIdResp(  pTG, 
                                    pTG->TmpSettings.szIDCmd,
                                    (USHORT) _fstrlen(pTG->TmpSettings.szIDCmd),
                                    pTG->TmpSettings.szID, 
                                    MAXIDSIZE);
                        //@
                        //@ Send the id command again this time putting the result
                        //@ in pTG->TmpSettings.szResponseBuf.
                        //@
                        GetIdResp(  pTG,
                                    pTG->TmpSettings.szIDCmd,
                                    (USHORT)_fstrlen(pTG->TmpSettings.szIDCmd),
                                    pTG->TmpSettings.szResponseBuf, 
                                    MAXIDSIZE);
                        //@
                        //@ Compate the two results. If they are the same then break.
                        //@ Otherwise try again.
                        //@ (Why do we need to do this comparision ????)
                        //@
                        if (!_fstrcmp(pTG->TmpSettings.szID, pTG->TmpSettings.szResponseBuf)) 
                        {
                            break;
                        }
                }
                if (i>=3 || !pTG->TmpSettings.szID[0])
                {
                    //@
                    //@ We failed to the the id response.
                    //@

                    DebugPrintEx(   DEBUG_ERR,
                                    "Can't get matching ID for supplied IDCMD: %s",
                                    (LPSTR) pTG->TmpSettings.szIDCmd);
                    //@
                    //@ Nullify the command id and id held in TmpSettings.
                    //@
                        pTG->TmpSettings.szIDCmd[0]=pTG->TmpSettings.szID[0]=0;
                }
                else
                {
                    //@
                    //@ The id command worked and we have a matching id.
                    //@
                        DebugPrintEx(   DEBUG_MSG,
                                        "OEM IDCmd=%s --> %s",
                                        (LPSTR) pTG->TmpSettings.szIDCmd,
                                        (LPSTR) pTG->TmpSettings.szID);
                }
                //@
                //@ In any case we indicate that we have an id command and matchind id.
                //@ (Why do we do that in the case we did not find a matching id ?)
                //@ And save the results to the registry.
                pTG->TmpSettings.dwGot |= (fGOTPARM_IDCMD | fGOTPARM_ID);
                goto SaveIDandCMD;

        }

        //@
        //@ This is the case where we do not have a command id that we previously found.
        //@

        // write ModemId first, then ModemIdCmd

        // the lpszOemIDCmd and lpszOemID above).
        pTG->TmpSettings.szID[0]=0;
        lpstr1 = pTG->TmpSettings.szResponseBuf;

        //@
        //@ Get the class 0 full id string into lpstr1.
        //@ Get the longest id (1st three commands) into pTG->TmpSettings.szID
        //@ Get the command that generated the longest id into pTG->TmpSettings.szIDCmd
        //@
        uLen1 = GetIdForClass(pTG, &GetIdTable[0], lpstr1,
                        RESPONSEBUFSIZE, pTG->TmpSettings.szID, MAXIDSIZE,
                        pTG->TmpSettings.szIDCmd);
        lpstr1[uLen1] = 0;
        if (pTG->TmpSettings.szID[0])
        {   
            pTG->TmpSettings.dwGot |= (fGOTPARM_IDCMD|fGOTPARM_ID);
        }
        
        //@
        //@ Write the full id string for class 0 into the registry (Class0ModemId)
        //@
        ProfileWriteString(dwKey, GetIdTable[0].szIniEntry, lpstr1, FALSE);

       

        if(uClasses & FAXCLASS2) //@ if the modem supports class 2
        {
                //@
                //@ Get the class 2 full id string into lpstr2.
                //@ Dont ask for longest id (not relevant for class 2).
                //@ Note that lptstr2 is placed just after lpstr1 in pTG->TmpSettings.szResponseBuf
                //@
                lpstr2 = pTG->TmpSettings.szResponseBuf + uLen1 + 1;
                uLen2 = GetIdForClass(pTG, &GetIdTable[1], lpstr2,
                                        (USHORT)(RESPONSEBUFSIZE-uLen1-1), 0, 0, 0);
                lpstr2[uLen2] = 0;
                ProfileWriteString(dwKey, GetIdTable[1].szIniEntry, lpstr2, FALSE);
        }
        if(uClasses & FAXCLASS2_0) //@ if the modem supports class 2.0
        {
                lpstr3 = pTG->TmpSettings.szResponseBuf + uLen1 + uLen2 + 2;
                //@
                //@ Get the class 2.0 full id string into lpstr3.
                //@ Dont ask for longest id (not relevant for class 2).
                //@ Note that lptstr3 is placed just after lpstr2 in pTG->TmpSettings.szResponseBuf
                //@
                uLen3 = GetIdForClass(pTG, &GetIdTable[2], lpstr3, (USHORT)((RESPONSEBUFSIZE)-uLen1-uLen2-2), 0, 0, 0);
                lpstr3[uLen3] = 0;
                ProfileWriteString(dwKey, GetIdTable[2].szIniEntry, lpstr3, FALSE);
        }

        //@
        //@ Note: At this point we changed the value of pTG->TmpSettings.szId and szIdCmd.
        //@ and placed there the class 0 id and command respectively.
        //@
        ToCaps(lpstr1);
        ToCaps(lpstr2);
        ToCaps(lpstr3);

        DebugPrintEx(   DEBUG_MSG,
                        "Got Ids (%s)\r\n(%s)\r\n(%s)",
                        ((LPSTR)(lpstr1 ? lpstr1 : "null")),
                        ((LPSTR)(lpstr2 ? lpstr2 : "null")),
                        ((LPSTR)(lpstr3 ? lpstr3 : "null")));

        // If we've read any commands or caps from the OEM location we
        // skip this...

        //@
        //@ This means that if we read the information from Unimodem key
        //@ or find it in the adaptive answering file we will never search
        //@ AWMODEM.INF or AWOEM.INF
        //@
        if (fGotOEMInfo || ( pTG->ModemKeyCreationId != MODEMKEY_FROM_NOTHING) )
        {
            DebugPrintEx(DEBUG_WRN,"Got OEM info: Skipping AWMODEM.INF file search!");
        }
        else
        {
            if (!SearchInfFile(pTG, "AWOEM.INF", lpstr1, lpstr2, lpstr3, dwKey))
            {
                 SearchInfFile(pTG, "AWMODEM.INF", lpstr1, lpstr2, lpstr3, dwKey);
            }
        }

SaveIDandCMD:

        ProfileWriteString(dwKey, szModemId, pTG->TmpSettings.szID, FALSE);
        ProfileWriteString(dwKey, szModemIdCmd, pTG->TmpSettings.szIDCmd, TRUE);

end:
        if (dwKey) ProfileClose(dwKey);
        return;
}

// state: 0=ineol  1=insectionhdr  2=in midline  3=got] 4=got\r\n
// inputs: \r\n==0 space/tab=1 2=[ 3=] 4=pritables 5=others
USHORT uNext[5][6] =
{
  // crlf sp [  ] asc oth
        { 0, 0, 1, 2, 2, 2 },   //in eol
        { 0, 1, 2, 3, 1, 2 },   //in sectionhdr
        { 0, 2, 2, 2, 2, 2 },   //in ordinary line
        { 4, 3, 2, 2, 2, 2 },   //found ]
        { 4, 4, 4, 4, 4, 4 }    //found closing \r\n
};

#define START           0
#define INHEADER1       1
#define INHEADER2       3
#define FOUND           4



void ToCaps(LPBYTE lpb)
{
        // capitalize string
        USHORT i;

        for(i=0; lpb && lpb[i]; i++)
        {
                if(lpb[i] >= 'a' && lpb[i] <= 'z')
                        lpb[i] -= 32;
        }
}



BOOL SearchInfFile
(
    PThrdGlbl pTG, 
    LPSTR lpstrFile, 
    LPSTR lpstr1, 
    LPSTR lpstr2, 
    LPSTR lpstr3, 
    DWORD_PTR dwLocalKey
)
{
        char    bTemp[BIGTEMPSIZE];
        char    szHeader[SMALLTEMPSIZE+SMALLTEMPSIZE];
        char    bTemp2[SMALLTEMPSIZE+SMALLTEMPSIZE];
        UINT    uLen, state=0, input=0, uHdrLen;
        HFILE   hfile;
        LPBYTE  lpb, lpbCurr;

        DEBUG_FUNCTION_NAME(("SearchInfFile"));

        uLen = GetWindowsDirectory(bTemp, BIGTEMPSIZE-15);
        if(!uLen)
        {
            return FALSE;
        }
        // if last char is not a \ then append a '\'
        if(bTemp[uLen-1] != '\\')
        {
            bTemp[uLen++] = '\\';
            bTemp[uLen] = 0;                // add new 0 terminator
        }
        _fstrcpy(bTemp+uLen, lpstrFile);
        if((hfile = DosOpen(bTemp, 0)) == HFILE_ERROR)
        {
            DebugPrintEx(DEBUG_WRN,"%s: No such file", (LPSTR)bTemp);
            return FALSE;
        }

        uLen = 0;
        lpbCurr = bTemp;

nextround:
        DebugPrintEx(DEBUG_MSG,"Nextround");
        state = START;
        uHdrLen = 0;
        for(;;)
        {
                if(!uLen)
                {
                        uLen = DosRead( hfile, bTemp, sizeof(bTemp));
                        if(!uLen || uLen == ((UINT) -1))
                                goto done;
                        lpbCurr = bTemp;
                }

                switch(*lpbCurr)
                {
                case '\r':
                case '\n':      input = 0; break;
                case ' ':
                case '\t':      input = 1; break;
                case '[':       input = 2; break;
                case ']':       input = 3; break;
                default:        if(*lpbCurr >= 32 && *lpbCurr < 128)
                                {
                                    input = 4;
                                }
                                else
                                {
                                    input = 5;
                                }
                                break;
                }
                state = uNext[state][input];

                if(state == FOUND)
                {
                    if(uHdrLen > 2)
                    {
                        break;
                    }
                    else
                    {
                        goto nextround;
                    }
                }

                if(state == INHEADER1)
                {
                        if(*lpbCurr != '[' && uHdrLen < sizeof(szHeader)-1)
                                szHeader[uHdrLen++] = *lpbCurr;
                }
                else if(state != INHEADER2)
                        uHdrLen=0;

                lpbCurr++;
                uLen--;

                // szHeader[uHdrLen] = 0;
        }
        DebugPrintEx(DEBUG_MSG,"Found[%s]", (LPSTR)szHeader);
        szHeader[uHdrLen] = 0;

        // capitalize search string
        ToCaps(szHeader);

        DebugPrintEx(DEBUG_MSG,"Found[%s]", (LPSTR)szHeader);

        if(     (lpstr1 ? strstr(lpstr1, szHeader) : FALSE) ||
                (lpstr2 ? strstr(lpstr2, szHeader) : FALSE) ||
                (lpstr3 ? strstr(lpstr3, szHeader) : FALSE) )
        {
            DebugPrintEx(   DEBUG_WRN,
                            "Copying INI file section [%s] from %s",
                            (LPSTR)szHeader, 
                            (LPSTR)lpstrFile);

            DosClose( hfile);
            // read the whole section as profile string
            if(GetPrivateProfileString(szHeader, NULL, "", bTemp, sizeof(bTemp), lpstrFile) == 0)
            {
                DebugPrintEx(DEBUG_ERR,"Can't read INF file section");
                return FALSE;
            }
            // copy it to our IniFile
            for(lpb=bTemp; *lpb; lpb += _fstrlen(lpb)+1)
            {
                // lpb is a key in the [szHeader] section of the INF file
                if(GetPrivateProfileString(szHeader, lpb, "", bTemp2, sizeof(bTemp2), lpstrFile) == 0)
                {
                    DebugPrintEx(DEBUG_ERR,"Can't read INF file entry");
                }
                else
                {
                    // copy it to our IniFile
                    ProfileWriteString(dwLocalKey, lpb, bTemp2, FALSE);
                    DebugPrintEx(   DEBUG_MSG, 
                                    "Wrote %s=%s", 
                                    (LPSTR)lpb, 
                                    (LPSTR)bTemp2);
                }
            }
            // found what we wanted. Outta here
                return TRUE;
        }

        // couldnt match, try again
        DebugPrintEx(DEBUG_MSG,"No match");
        goto nextround;

done:
        DebugPrintEx(DEBUG_MSG,"End of INF file %s",(LPSTR)lpstrFile);
        // end of inf file--close it
        DosClose(hfile);
        return FALSE;
}

void CheckAwmodemInf(PThrdGlbl pTG)
{
    USHORT uLen;
    char bTemp[BIGTEMPSIZE];
    HFILE hfile;

    DEBUG_FUNCTION_NAME(_T("CheckAwmodemInf"));

    uLen = (USHORT)GetWindowsDirectory(bTemp, sizeof(bTemp)-15);
    if(!uLen)
    {
        return;
    }
    // if last char is not a \ then append a '\'
    if(bTemp[uLen-1] != '\\')
    {
        bTemp[uLen++] = '\\';
        bTemp[uLen] = 0;                // add new 0 terminator
    }
    _fstrcpy(bTemp+uLen, "AWMODEM.INF");
    if((hfile = DosCreate(bTemp, 0)) == HFILE_ERROR)
    {
        DebugPrintEx(DEBUG_ERR,"Could not create %s",(LPSTR)bTemp);
    }
    else
    {
        DosWrite( hfile, (LPSTR)szAwmodemInf, sizeof(szAwmodemInf)-1);
        DosClose( hfile);
        DebugPrintEx(DEBUG_WRN,"Created %s",(LPSTR)bTemp);
    }
    return;
}

#define ADDSTRING(DST, SRC) \
        u = _fstrlen(pTG->TmpSettings.SRC)+1; \
        _fmemcpy(pb, pTG->TmpSettings.SRC,u); \
        lpCmdTab->DST=pb;\
        pb+=u;

USHORT iModemGetCmdTab
(
    PThrdGlbl pTG, 
    LPCMDTAB lpCmdTab, 
    LPMODEMCAPS lpMdmCaps
)
{
    USHORT uRet = INIT_INTERNAL_ERROR;
    USHORT uPassCount = 0;
    BOOL   fDontPurge=FALSE; //If true, we won't delete section in install.

    DEBUG_FUNCTION_NAME(("iModemGetCmdTab"));

    if (!imodem_alloc_tmp_strings(pTG)) 
        goto done;

    pTG->TmpSettings.lpMdmCaps = lpMdmCaps;

ReadConfig:
    // check for ModemIdCmd, ModemId, ModemFaxClasses,
    //       ResetCommand, SetupCommand, PreDialCommand, PreAnswerCommand,
    //       ExitCommand, FaxSerialSpeed vars
    //       and (if Class1) ModemSendCaps, ModemRecvCaps
    // if all present [some exceptions--see below], then verify that
    //       ModemId is still correct (send ModemIdCmd, get ModemId)
    // if correct then copy all INI values into lpMdmCaps and lpCmdTab
    // else do full install

// get ModemCaps from current settings

    imodem_clear_tmp_settings(pTG);

    if (!iModemGetCurrentModemInfo(pTG))
    {
        goto DoInstall;
    }

    SmashCapsAccordingToSettings(pTG);

    if (! pTG->fCommInitialized) 
    {
       if( ! T30ComInit(pTG) ) 
       {
          DebugPrintEx(DEBUG_MSG,"T30ComInit failed");
           goto done;
       }

       FComDTR(pTG, TRUE); // Raise DTR in ModemInit
       FComFlush(pTG);

       pTG->fCommInitialized = 1;
    }


    // do modem reset, or ID check won't work (because of echo)
    if (!pTG->TmpSettings.szReset[0] && !pTG->TmpSettings.szResetGenerated[0])
    {
        DebugPrintEx(DEBUG_WRN,"NULL reset command specified!");
    }
    else
    {
        if(iModemReset(pTG, pTG->TmpSettings.szResetGenerated[0] ? 
                                pTG->TmpSettings.szResetGenerated : 
                                pTG->TmpSettings.szReset) < 0)
        {
            fDontPurge=TRUE; // we specifically don't purge in this case.
            goto DoInstall;
        }
    }

    uRet = 0; 
    goto done;

DoInstall:
    if(uPassCount > 0)
    {
        DebugPrintEx(DEBUG_ERR,"Install looping!!");
        uRet =  INIT_INTERNAL_ERROR;
        goto done;
    }
    uPassCount++;

    // +++ currently we always do a "clean" install -- dwGot=0
    // EXCEPT that we use fDontPurge do determine whether we
    // delete the profile section or not.
    fDontPurge=fDontPurge|| (pTG->TmpSettings.uDontPurge!=0);
    imodem_clear_tmp_settings(pTG);

    if(uRet = iModemInstall(pTG, fDontPurge))
    {
        goto done;      // failed
    }
    else
    {
        goto ReadConfig;        // success
    }

    // on success we want to go back and start over because (a) we want to check
    // that everything is indeed OK and (b) UI etc may have modfied some of the
    // settings so we need to go back and read them in again.

done:
    if (!uRet)
    {
        char *pb = pTG->bModemCmds;
        UINT u;

        // Initialize all command strings in lpCmdTab to static buffer,
        // copying from the corresponding strings in the TmpSettings structure.
        // the latter strings point into
        // the temporarily allocated buffer allocated in
        // imodem_alloc_tmp_strings and will be freed on exit.

        _fmemset(lpCmdTab, 0, sizeof(CMDTAB));

        if (pTG->TmpSettings.szResetGenerated[0])
        {
            ADDSTRING(szReset, szResetGenerated);
        }
        else
        {
            ADDSTRING(szReset, szReset);
        }

        if (pTG->TmpSettings.szSetupGenerated[0])
        {
            ADDSTRING(szSetup, szSetupGenerated);
        }
        else
        {
            ADDSTRING(szSetup, szSetup);
        }
       
        ADDSTRING(szExit, szExit);
        ADDSTRING(szPreDial, szPreDial);
        ADDSTRING(szPreAnswer, szPreAnswer);
    }

    lpCmdTab->dwSerialSpeed = pTG->SerialSpeedInit;
    lpCmdTab->dwFlags = pTG->TmpSettings.dwFlags;
    imodem_free_tmp_strings(pTG);
    return uRet;
}

USHORT iModemInstall
(
    PThrdGlbl pTG,
    BOOL fDontPurge
)
{
    USHORT   uRet = 0;
    BOOL     fGotOEMInfo = FALSE;
    DWORD_PTR hkFr;
    DWORD    localModemKeyCreationId;

    DEBUG_FUNCTION_NAME(("iModemInstall"));

    CheckAwmodemInf(pTG);              // check that AWMODEM.INf exist, otherwise create it

    if (!pTG->TmpSettings.dwGot) 
    {
        /////// clear settings in input //////

        // Clear out persistant (registry) info...
        if (!fDontPurge && !ProfileDeleteSection(DEF_BASEKEY,pTG->FComModem.rgchKey))
        {
            DebugPrintEx(   DEBUG_WRN,
                            "ClearCurrentModemInfo:Can't delete section %s",
                            (LPSTR) pTG->FComModem.rgchKey);
        }


        {
            ULONG_PTR key;
            if (!(key=ProfileOpen(pTG->FComModem.dwProfileID, pTG->FComModem.rgchKey,
                                              fREG_CREATE | fREG_READ | fREG_WRITE)))
            {
                DebugPrintEx(DEBUG_ERR,"Couldn't get location of modem info.");
            }
            else
            {
                ProfileWriteString(key, szResetCommandGenerated, "", TRUE);
                ProfileWriteString(key, szSetupCommandGenerated, "", TRUE);
                ProfileClose(key);
            }
        }
        //@
        //@ First lets see if the modem has a Unimodem FAX key.
        //@ If it does then we will use the Unimodem FAX key settings
        //@ and will not attempt to search ADAPTIVE.INF AWMODEM.INF or AWOEM.INF
        //@ Note: This is different from thw W2K implementation. W2K provider
        //@       looked first in ADAPTIVE.INF and if it found a match it DID NOT
        //@       look for a Unimodem FAX key.
        //@

        pTG->ModemKeyCreationId = MODEMKEY_FROM_NOTHING;

        hkFr = ProfileOpen( OEM_BASEKEY, pTG->lpszUnimodemFaxKey, fREG_READ);
        if ( hkFr  ) 
        {
              pTG->ModemKeyCreationId = MODEMKEY_FROM_UNIMODEM;
              ProfileClose( hkFr);
              //@
              //@ This copies all the information from the unimodem FAX key to 
              //@ our registry.
              //@
              iModemCopyOEMInfo(pTG);
        }
        else
        {
            //@
            //@ Check to see if this modem is defined in Adaptive.Inf
            //@ Since the last parameret is FALSE we will not read in the record content
            //@ if it contains an "AdaptiveCodeId" field (which indiciates we need to 
            //@ make sure what is the modem revision first). If it does not contain
            //@ this field we will read the content into the pTG.
            //@
            SearchNewInfFile(pTG, pTG->ResponsesKeyName, NULL, FALSE);

            if (pTG->fAdaptiveRecordFound) 
            {
               if (! pTG->fAdaptiveRecordUnique) 
               {
                  //@
                  //@ The section indicates that a modem id identification is required.
                  //@ The next oddly named function will set pTG->fAdaptiveRecordUnique to 1
                  //@ if it identified the modem revision as a one for which 
                  //@ adaptive answering is working.
                  //@
                  TalkToModem (pTG, FALSE); //@ void function
                  if (pTG->fAdaptiveRecordUnique) 
                  {
                    //@
                    //@ Now we are we are sure the the adaptive record matches the modem.
                    //@ We search the INF again but this time allways read the record 
                    //@ content into the pTG (last parameter is TRUE).
                    //@
                     SearchNewInfFile(pTG, pTG->ResponsesKeyName, NULL, TRUE);
                  }
                  else 
                  {
                      //@
                      //@ The modem does not match the revision for which adaptive
                      //@ answering is enabled.
                      //@
                     pTG->fAdaptiveRecordFound = 0;
                     pTG->ModemClass = 0;
                  }
               }
            }

            if (pTG->fAdaptiveRecordFound) 
            {
                //@
                //@ If we succeeded to find an adaptive record then we need
                //@ to save the information we read from it into the pTG to the
                //@ registry.
                //@
               pTG->ModemKeyCreationId = MODEMKEY_FROM_ADAPTIVE; //@ so we will know the information source
               SaveInf2Registry(pTG);
            }

        }

       
        localModemKeyCreationId = pTG->ModemKeyCreationId;
        pTG->AdaptiveAnswerEnable = 0; //@ we are going to read it back from the registry in a second
        
        //
        // At this point we have all the info from Adaptive.inf or Unimodem Reg.
        // into Modem Reg.
        // We have nothing in memory.
        //

        if (! pTG->ModemClass) 
        {
           ReadModemClassFromRegistry(pTG);
        }

        if (! pTG->ModemClass) 
        {
           TalkToModem(pTG, TRUE);
           SaveModemClass2Registry(pTG);
        }


        //@
        //@ Read the modem data back from the registry. (We have just written it
        //@ to the registry in the preceeding functions and we want it back into
        //@ memory).
        //@ Note that this sets pTG->TmpSettings.dwGot with the fGOTCAPS_X, fGOTPARM_X, etc. flags
        //@ Also note that this will turn off or on the adaptive answering flag
        //@ (pTG->AdaptiveAnswerEnable) based on the extension configuration of the T30 FSP.
        //@
        iModemGetCurrentModemInfo(pTG);
        pTG->ModemKeyCreationId = localModemKeyCreationId;

    }

    //
    // We are ready now to initialize the hardware.
    // Can be second init (first one is in TalkToModem
    //

    if(! T30ComInit(pTG) )
    {
        DebugPrintEx(DEBUG_ERR,"Cannot Init COM port");
        // error already set to ERR_COMM_FAILED
        uRet = INIT_PORTBUSY;
        goto done;
    }

    FComDTR(pTG, TRUE); // Raise DTR in ModemInit
    FComFlush(pTG);

    pTG->fCommInitialized = 1;

    // we use this to decide if we must read our OEM inf files or not....
    //@ Make sure we have all what we need to operate. If we miss any of these
    //@ we will attempt to find it in AWMODEM.INF and AWOEM.INF.
    //@ 
    //@ CMDS: 
    //@     fGOTCMD_Reset \
    //@     fGOTCMD_Setup \
    //@     fGOTCMD_PreAnswer \
    //@     fGOTCMD_PreDial \
    //@     fGOTCMD_PreExit
    //@ CAPS:
    //@     fGOTCAP_CLASSES 
    //@     fGOTCAP_SENDSPEEDS 
    //@     fGOTCAP_RECVSPEEDS
    //@ PARAMS:
    //@     fGOTPARM_PORTSPEED
    //@     fGOTPARM_IDCMD
    //@     fGOTPARM_ID
    //@
    fGotOEMInfo = (pTG->TmpSettings.dwGot & (fGOTCMDS|fGOTCAPS|fGOTPARMS));

    // At this point, we have possibly an incompletely and/or
    // incorrectly filled out set of commands and capabilities.

    // must be first, or modem is in a totally unknown state
    //@
    //@ If the setup and reset command were not read or are not good
    //@ iModemFigureOutCmdsExt attempts to find them and place them in
    //@ pTG->TmpSettings.szReset and pTG->TmpSettings.szSetup
    //@
    if(uRet = iModemFigureOutCmdsExt(pTG))
        goto done;

    // iModemFigureOut leaves modem is a good (synced up) state
    // this needs to be _after_ lpCmdTab is filled out
    if(!iModemGetCaps(  pTG, 
                        pTG->TmpSettings.lpMdmCaps,
                        pTG->TmpSettings.dwSerialSpeed,
                        pTG->TmpSettings.szResetGenerated[0] ? 
                            pTG->TmpSettings.szResetGenerated : 
                            pTG->TmpSettings.szReset,
                        &pTG->TmpSettings.dwGot))
    {
        uRet = INIT_GETCAPS_FAIL;
        goto done;
    }

    // we always save settings here because iModemGetWriteIds below
    // will need to possibly override our settings so far...
    iModemSaveCurrentModemInfo(pTG);

    // must be last since it also does the AWMODEM.INF search
    //@
    //@ Note that iModemGetWriteIds will not do the INF search (and copy)
    //@ if fGotOEMInfo is TRUE or if pTG->ModemKeyCreationId != MODEMKEY_FROM_NOTHING.
    //@ This means that if we read the information from Unimodem the AWMODEM.INF and
    //@ AWOEM.INF will be ignored. This is what we want !
    //@
    iModemGetWriteIds(pTG, fGotOEMInfo);

    CleanModemInfStrings(pTG);
    imodem_clear_tmp_settings(pTG);

    // Now we've done all we can. We've got all the settings, written them to
    // the INI file. Call back the UI function here. This will read the
    // current settings from INI file, may modify them and returns OK, Cancel
    // and Detect. On OK & Cancel, just exit. On Detect loop back to start
    // of this function, but this time _skip_ UNIMODEM & do detection ourself

    uRet = 0;

done:

    return uRet;
}


/***-------------------- FLOW CONTROL ----------------------**********

        Each modem seems to have it's own stupid way of setting
        flow control. Here's a survey

Manuf           which modem?            Flow    Sideeffects
-----           ------------            ----    -----------
Rockwell        RC2324AC                        &K4             &H unused.  \Q unused.
US Robotics Sportster14400              &H2             &K0-3 used, &K4 unused. \cmds unused
                        Courier(HST,V32bis)
PracPeriph      PP14400FXMT/SA          &K4             &H unsued. \cmds unused.
                    PP2400EFXSA
Zoom            9600 V.32 VFX           &K4             &H unused. \Q unused
UDSMotorola Fastalk                             \Q1             &H unused &K unused
HayesOptima Optima24/144                &K4             &H unused \cmds unused
MegaHertz       P2144                    \Q1 \Q4        &H unused &K unused
TwinCom         144/DF                          &K4             &H unused \Q unused
PCLogic         ???                                     ???             ????
????            ???                                     \Q1             &H unused &K unused
ATI                     2400 etc                        &K4             &H unused \cmds unused
MultiTech       MultiModemMT1432MU      &E5             &H unused &K unused \Q unused
                        MultiModemII MT932
                        MultiModemII MT224
Viva            14.4i/Fax and 9624i &K4         &H unused \Q unused &E unused
GVC                     "9600bps Fax Modem" \Q1         &H unused &K unused &E unused
SmartOne        1442F/1442FX            &K4             &H unused \Q unused &E unused
DSI                     ScoutPlus                       *F2             &H &E &K \Q1 unused


        We had &K4 and \Q1 commands being sent (until 7/10/93).
        This is a potential problem for US Robotics, MultiTech
        and DSI modems.

        US Robotics defaults to ALL flow control disabled
        DSI ScoutPlus defaults to CTS/RTS flow control
        MultiTech defaults to CTS/RTS flow control
        MultiTech is Class2-only, so we may not have trouble there

7/10/93
        Added &H2 command to iModemReInit -- doesn't affect anyone else I think
later
        Removed &H2 -- some modems use that as  'help' cmd & display a page
        of help info that they refuse to exit except on pressing N or some such!
        So we think the modem's hung!
later
        Removed *F2 -- Starts a Flassh ROM download on Rockwell!!

****-------------------- FLOW CONTROL -------------------------*******/



/*************************************************************************
        According to "Data and Fax Communications" by Hummel,flow control
        settings are as follows

xon     both
&H2     &H3     -- US Robotics (though this fatally invokes Help on some modems)
&K4     -- Dallas, Hayes, Practical, Prometheus, Rockwell, Sierra, Telebit
                        Twincom, Zoom
\Q1     -- AT&T, Dallas, Microcom, Practical, Prometheus, Sierra
*F2             -- Prometheus (though it fatally invokes Flash ROM download on Rockwell)
#K4             -- Sierra-based fax modems
S68=3   -- Telebit

**************************************************************************/


#define AT      "AT"
#define ampF    "&F"
#define S0_0    "S0=0"
#define E0      "E0"
#define V1      "V1"
#define Q0      "Q0"
#define S7_60  "S7=60"
#define ampD2   "&D2"
#define ampD3   "&D3"
#define bsQ1    "\\Q1"
#define bsJ0    "\\J0"
#define ampK4   "&K4"
#define ampH2   "&H2"
#define ampI2   "&I2"
#define ampE5   "&E5"
#define cr      "\r"
//#define       ampC1   "&C1"


USHORT iModemFigureOutCmdsExt(PThrdGlbl pTG)

/*++

Routine Description:

    Tries to figure out the reset and setup command for the modem if the were
    not read from the registry or what was read does not work.
    If a reset command works the fGOTCMD_Reset is set in pTG->TmpSettings.dwGot and it is saved in pTG->TmpSettings.szReset.
    If a setup command works the fGOTCMD_Setup is set in pTG->TmpSettings.dwGot and it is saved in pTG->TmpSettings.szReset.
    if pTG->TmpSettings.dwSerialSpeed is not set (0) then we set it to pTG->SerialSpeedInit and turn on 
    the fGOTPARM_PORTSPEED flag.

Return Value:
    0 if succeeded.
    INIT_MODEMDEAD if the modem does not respond.


--*/
{
    USHORT uLen1 = 0, uLen2 = 0;
    BOOL fGotFlo;

    // At this point, we have possibly an incompletely and/or
    // incorrectly filled out set of commands and capabilities.

    // Our job here is to use a combination of detection and
    // pre-filled commands to come up with a working set of
    // commands..

    DEBUG_FUNCTION_NAME(_T("iModemFigureOutCmdsExt"));

    if (pTG->TmpSettings.dwGot & fGOTCMD_Reset)
    {
        //@
        //@ If we read a reset command from the registry we
        //@ don't attempt to find it if it is NULL or empty.
        if (!(pTG->TmpSettings.szReset)
           || !*(pTG->TmpSettings.szReset)
           || iModemReset(pTG, pTG->TmpSettings.szReset) >= 0)
        {
            //@ If we dont have a pre read reset command
            //@ or the reset command is empty
            //@ or we succeeded in getting a response from the specified reset command
            //@ then we don't attemp to figure this out.
                goto SkipReset;
        }
        else
        {
            DebugPrintEx(   DEBUG_WRN,
                            "BOGUS supplied reset cmd: \"%s\"",
                            (LPSTR) pTG->TmpSettings.szReset);
        }
    }

    //@
    //@ We wither did not read a reset command from the registr or read
    //@ a non empty one and it did not work.
    //@
    //@ We now try to figure out the right reset command by just trying
    //@ the most common strings...
    //@

    // Quick test to see if we have a modem at all...
    // +++ REMOVE!
    _fstrcpy(pTG->TmpSettings.szSmallTemp1, AT E0 V1 cr);
    if(iModemReset(pTG, pTG->TmpSettings.szSmallTemp1) < 0)
    {
        DebugPrintEx(DEBUG_ERR,"can't set ATE0V1");
        goto modem_dead;
    }

    _fstrcpy(pTG->TmpSettings.szSmallTemp1, AT ampF S0_0 E0 V1 Q0 cr);
    if(iModemReset(pTG, pTG->TmpSettings.szSmallTemp1) >= 0)
            goto GotReset;

    // too many variants, too slow, V1Q0 are default anyway
    //_fstrcpy(pTG->TmpSettings.szSmallTemp1, AT ampF S0_0 E0 V1 cr);
    //if(iModemReset(pTG->TmpSettings.szSmallTemp1) >= 0)
    //      goto GotReset;

    _fstrcpy(pTG->TmpSettings.szSmallTemp1, AT ampF S0_0 E0 cr);
    if(iModemReset(pTG, pTG->TmpSettings.szSmallTemp1) >= 0)
            goto GotReset;

    _fstrcpy(pTG->TmpSettings.szSmallTemp1, AT ampF E0 cr);
    if(iModemReset(pTG, pTG->TmpSettings.szSmallTemp1) >= 0)
            goto GotReset;

    DebugPrintEx(DEBUG_ERR,"can't set AT&FE0");

    // Purge comm here, because there may be stuff left in the output
    // buffer that FComClose will try to complete, and if the modem
    // is dead, that  will take a while...
modem_dead:
    FComFlush(pTG);

    return INIT_MODEMDEAD;

GotReset:
    //@
    //@ We succeeded in figuring out a reset command. Turn on the fGOTCMD_Reset flag
    //@ and save it in pTG->TmpSettings.szReset.
    //@
    pTG->TmpSettings.dwGot |= fGOTCMD_Reset;
    _fstrcpy(pTG->TmpSettings.szResetGenerated, pTG->TmpSettings.szSmallTemp1);

SkipReset:
    // now try setup cmd
    if (pTG->TmpSettings.dwGot & fGOTCMD_Setup)
    {
        if (!(pTG->TmpSettings.szSetup)
           || !*(pTG->TmpSettings.szSetup)
           || OfflineDialog2(pTG, pTG->TmpSettings.szSetup,
                                        (USHORT)_fstrlen(pTG->TmpSettings.szSetup), cbszOK,
                                                cbszERROR)==1)
        {
            goto SkipSetup;
        }
        else
        {
            DebugPrintEx(   DEBUG_WRN,
                            "BOGUS supplied setup cmd: \"%s\"\r\n",
                            (LPSTR) pTG->TmpSettings.szSetup);
        }
    }
    _fstrcpy(pTG->TmpSettings.szSmallTemp1, AT);
    uLen2 = sizeof(AT)-1;

    if(OfflineDialog2(pTG, (LPSTR)(AT S7_60 cr), sizeof(AT S7_60 cr)-1, cbszOK, cbszERROR) == 1)
    {
        _fstrcpy(pTG->TmpSettings.szSmallTemp1+uLen2, S7_60);
        uLen2 += sizeof(S7_60)-1;
    }
    else
    {
        DebugPrintEx(DEBUG_WRN,"can't set S7=255");
    }

    if(OfflineDialog2(pTG, (LPSTR)(AT ampD3 cr), sizeof(AT ampD3 cr)-1, cbszOK, cbszERROR) == 1)
    {
        _fstrcpy(pTG->TmpSettings.szSmallTemp1+uLen2, ampD3);
        uLen2 += sizeof(ampD3)-1;
    }
    else if(OfflineDialog2(pTG, (LPSTR)(AT ampD2 cr), sizeof(AT ampD2 cr)-1, cbszOK, cbszERROR) == 1)
    {
        _fstrcpy(pTG->TmpSettings.szSmallTemp1+uLen2, ampD2);
        uLen2 += sizeof(ampD2)-1;
    }
    else
    {
        DebugPrintEx(DEBUG_WRN,"can't set &D3 or &D2");
    }

    fGotFlo=FALSE;
    if(OfflineDialog2(pTG, (LPSTR)(AT ampK4 cr), sizeof(AT ampK4 cr)-1, cbszOK, cbszERROR) == 1)
    {
        _fstrcpy(pTG->TmpSettings.szSmallTemp1+uLen2, ampK4);
        uLen2 += sizeof(ampK4)-1;
        fGotFlo=TRUE;
    }

    // JosephJ 3/10/95: We try \Q1\J0 even if &K4 passed,
    // because many japanese modems return OK to &K4 but in fact
    // use \J0 for xon xoff flow control
    if(OfflineDialog2(pTG, (LPSTR)(AT bsQ1 cr), sizeof(AT bsQ1 cr)-1, cbszOK, cbszERROR) == 1)
    {
        _fstrcpy(pTG->TmpSettings.szSmallTemp1+uLen2, bsQ1);
        uLen2 += sizeof(bsQ1)-1;

        if(OfflineDialog2(pTG, (LPSTR)(AT bsJ0 cr), sizeof(AT bsJ0 cr)-1, cbszOK, cbszERROR) == 1)
        {
            _fstrcpy(pTG->TmpSettings.szSmallTemp1+uLen2, bsJ0);
            uLen2 += sizeof(bsJ0)-1;
        }
        fGotFlo=TRUE;
    }

    if (!fGotFlo)
    {
        DebugPrintEx(DEBUG_WRN,"can't set &K4 or \\Q1, trying &K5");
        if(OfflineDialog2(pTG, (LPSTR)(AT ampE5 cr), sizeof(AT ampE5 cr)-1, cbszOK, cbszERROR) == 1)
        {
            _fstrcpy(pTG->TmpSettings.szSmallTemp1+uLen2, ampE5);
            uLen2 += sizeof(ampE5)-1;
            fGotFlo=TRUE;
        }
    }

    _fstrcpy(pTG->TmpSettings.szSmallTemp1+uLen2, cr);
    uLen2 += sizeof(cr)-1;

    _fstrcpy(pTG->TmpSettings.szSetupGenerated, pTG->TmpSettings.szSmallTemp1);
    pTG->TmpSettings.dwGot |=fGOTCMD_Setup;

SkipSetup:

    if (!pTG->TmpSettings.dwSerialSpeed)
    {
        pTG->TmpSettings.dwSerialSpeed = pTG->SerialSpeedInit;
        pTG->TmpSettings.dwGot |=fGOTPARM_PORTSPEED;
    }

    return 0;
}

void 
TalkToModem 
(
    PThrdGlbl pTG,
    BOOL fGetClass
)
{

   char    Command [400];
   char    Response[1000];
   DWORD   RespLen;
   USHORT  uRet;
   char    *lpBeg;
   char    *lpCur;

#define uMULTILINE_SAVEENTIRE   0x1234

   //
   // This function implements special case modems firmware identification
   // as well as modem class identification.
   //

   DEBUG_FUNCTION_NAME(("TalkToModem"));

   if ( (! fGetClass) && (pTG->AdaptiveCodeId != 1) ) 
   {
      return;
   }

   //
   // Initialize modem
   //

   if(! T30ComInit(pTG) ) 
   {
      DebugPrintEx(DEBUG_ERR,"cannot init COM port");
      return;
   }

   FComDTR(pTG, TRUE); // Raise DTR in ModemInit
   FComFlush(pTG);

   pTG->fCommInitialized = 1;
   
   sprintf (Command, "AT E0 Q0 V1\r" );

   if( (uRet = OfflineDialog2(pTG, (LPSTR) Command, (USHORT) strlen(Command), cbszOK, cbszERROR) ) != 1)    
   {
       DebugPrintEx(DEBUG_ERR, "1 %s FAILED",  Command);
       return;
   }
   
   DebugPrintEx(DEBUG_MSG,"TalkToModem 1 %s rets OK",  Command);


   if (fGetClass) 
   {
      //
      // Get modem class
      //

      pTG->ModemClass=MODEM_CLASS1;  // default
     
      sprintf (Command, "AT+FCLASS=?\r" );
     
      if( (uRet = OfflineDialog2(pTG, (LPSTR) Command, (USHORT) strlen(Command), cbszOK, cbszERROR) ) != 1)    
      {
          DebugPrintEx(DEBUG_ERR, "TalkToModem 1 %s FAILED",  Command);
          return;
      }
     
      DebugPrintEx( DEBUG_MSG, 
                    "TalkToModem 1 %s returned %s",  
                    Command, 
                    pTG->FComModem.bLastReply);
     
      if (strchr(pTG->FComModem.bLastReply, '1') ) 
      {
         DebugPrintEx(DEBUG_MSG, "Default to Class1");
      }
      else if ( lpBeg = strchr (pTG->FComModem.bLastReply, '2') )  
      {
         lpBeg++;
         if ( *lpBeg != '.' ) 
         {
            DebugPrintEx(DEBUG_MSG, "Default to Class2");
            pTG->ModemClass=MODEM_CLASS2;
         }
         else if ( strchr (lpBeg, '2') ) 
         {
             DebugPrintEx(DEBUG_MSG, "Default to Class2");
             pTG->ModemClass=MODEM_CLASS2;
         }
         else 
         {
            DebugPrintEx(DEBUG_MSG, "Default to Class2.0");
            pTG->ModemClass=MODEM_CLASS2_0;
         }
      }
      else 
      {
         DebugPrintEx(DEBUG_ERR, "Could not get valid Class answer. Default to Class1");
      }
   }

   //
   // If needed, get firmware identification.
   //

   switch (pTG->AdaptiveCodeId) 
   {
   case 1:
      // Sportster 28800-33600 internal/external

      sprintf (Command, "ATI7\r" );

      FComFlushOutput(pTG);
      FComDirectAsyncWrite(pTG, (LPSTR) Command, (USHORT) strlen(Command) );

      if ( ( uRet = iiModemDialog( pTG, 0, 0, 5000, uMULTILINE_SAVEENTIRE,1, TRUE,
                               cbszOK,
                               cbszERROR,
                               (CBPSTR)NULL) ) != 1 )  
      {
          DebugPrintEx(DEBUG_ERR, "TalkToModem 2 %s FAILED",  Command);
          return;
      }

      DebugPrintEx(DEBUG_MSG,"TalkToModem 2 %s rets OK",  Command);

      RespLen = min(sizeof(Response) - 1,  strlen(pTG->FComModem.bEntireReply) );
      memcpy(Response, pTG->FComModem.bEntireReply, RespLen);
      Response[RespLen] = 0;

      ToCaps(Response);

      //
      // if "EPROM DATE" is "10/18/95" then the adaptive answer is broken (Hugh Riley, USR 03/25/97).
      // otherwise enable adaptive answer.  
      // If we enabled adaptive answer and firmware is broken then the customer needs to upgrade f/w.
      //

      if ( ! strstr(Response, "10/18/95") ) 
      {
         pTG->fAdaptiveRecordUnique = 1;
         return;
      }

      // 
      // found "10/18/95".  Lets check if this is an EPROM DATE.
      //
      if ( ! (lpBeg = strstr(Response, "EPROM DATE") ) ) 
      {
         return;
      }

      if ( ! (lpCur = strstr(lpBeg, "10/18/95") ) ) 
      {
         pTG->fAdaptiveRecordUnique = 1;
         return;
      }

      if ( ! strstr(lpCur, "DSP DATE") ) 
      {
         pTG->fAdaptiveRecordUnique = 1;
         return;
      }
      
      return;

   default:
      return;

   }
   return;
}

BOOL iModemGetCurrentModemInfo(PThrdGlbl pTG)
                // Reads as much as it can from the current profile. Returns TRUE
                // IFF it has read enough for a proper init.
                // On failure, zero's out everything.
                // All info is maintained in global TmpSettings;
{
    USHORT          uLen1               = 0;
    USHORT          uLen2               = 0;
    ULONG_PTR       dwKey               = 0;
    ULONG_PTR       dwKeyAdaptiveAnswer = 0;
    ULONG_PTR       dwKeyAnswer         = 0;
    ULONG_PTR       UnimodemFaxKey      = 0;
    BOOL            fRet                = FALSE;
    ULONG_PTR       KeyList[10]         = {0};
    char            KeyName[200]        = {0};
    char            lpTemp[MAXCMDSIZE]  = {0};
    char            szClass[10]         = {0};
    DWORD           i                   = 0;
    UINT            uTmp                = 0;

    LPMODEMCAPS     lpMdmCaps = pTG->TmpSettings.lpMdmCaps;

    DEBUG_FUNCTION_NAME(("iModemGetCurrentModemInfo"));

    imodem_clear_tmp_settings(pTG);

    //
    // get T.30 modem Fax key
    //

    if ( ! (dwKey = ProfileOpen(pTG->FComModem.dwProfileID, pTG->FComModem.rgchKey, fREG_READ))) 
    {
        goto end;
    }

    // open the Unimodem fax section
    UnimodemFaxKey = ProfileOpen(OEM_BASEKEY,pTG->lpszUnimodemFaxKey,fREG_READ);
    if (!UnimodemFaxKey)
    {
        // Fax section in Unimodem's registry does not exist.
        // There's no need to worry if Windows Update was used
        // to change settings there. Our cache is correct.
        DebugPrintEx(DEBUG_MSG, "Modem does not have a Fax section in its INF");
    }

    //
    // Lets see what modem Class we will use
    //
    uTmp = ProfileGetInt(dwKey, szFixModemClass, 0, FALSE);
    if (IsCacheIntDirty(UnimodemFaxKey,szFixModemClass,uTmp))
    {
        DebugPrintEx(DEBUG_WRN, "FixModemClass cached settings are invalid, need to re-install the modem.");
        fRet = FALSE;
        goto end;
    }

    if (uTmp == 1) 
    {
       pTG->ModemClass = MODEM_CLASS1;
    }
    else if (uTmp == 2) 
    {
       pTG->ModemClass = MODEM_CLASS2;
    }
    else if (uTmp == 20) 
    {
       pTG->ModemClass = MODEM_CLASS2_0;
    }

    if (! pTG->ModemClass) 
    {
       DebugPrintEx(DEBUG_ERR, "MODEM CLASS was not defined.");
    }

    switch (pTG->ModemClass) 
    {
    case MODEM_CLASS1 :
       sprintf(szClass, "Class1");
       break;

    case MODEM_CLASS2 :
       sprintf(szClass, "Class2");
       break;

    case MODEM_CLASS2_0 :
       sprintf(szClass, "Class2_0");
       break;

    default:
       sprintf(szClass, "Class1");
    }


    //
    // depending on a requested operation, find the appropriate settings 
    //

    if (pTG->Operation == T30_RX) 
    {
       KeyList[0] = dwKey;

       sprintf(KeyName, "%s\\%s", pTG->FComModem.rgchKey, szClass);
       KeyList[1] = ProfileOpen(pTG->FComModem.dwProfileID, KeyName, fREG_READ);

       sprintf(KeyName, "%s\\%s\\AdaptiveAnswer", pTG->FComModem.rgchKey, szClass);
       KeyList[2] = ProfileOpen(pTG->FComModem.dwProfileID, KeyName, fREG_READ);

       if (KeyList[2] == 0) 
       {
           pTG->AdaptiveAnswerEnable = 0;

           sprintf(KeyName, "%s\\%s\\Receive", pTG->FComModem.rgchKey, szClass);
           KeyList[2] = ProfileOpen(pTG->FComModem.dwProfileID, KeyName, fREG_READ);
       }
       else 
       {
           dwKeyAdaptiveAnswer = KeyList[2];
           pTG->AdaptiveAnswerEnable = 1;
       }

       KeyList[3] = 0;
       //
       // Turn off adaptive answering if the admin disabled it via the UI
       //
       pTG->AdaptiveAnswerEnable = pTG->AdaptiveAnswerEnable && pTG->ExtData.bAdaptiveAnsweringEnabled;       

    }
    else if (pTG->Operation == T30_TX) 
    {
       KeyList[0] = dwKey;

       sprintf(KeyName, "%s\\%s", pTG->FComModem.rgchKey, szClass);
       KeyList[1] = ProfileOpen(pTG->FComModem.dwProfileID, KeyName, fREG_READ);

       sprintf(KeyName, "%s\\%s\\Send", pTG->FComModem.rgchKey, szClass);
       KeyList[2] = ProfileOpen(pTG->FComModem.dwProfileID, KeyName, fREG_READ);
       
       KeyList[3] = 0;
    }
    else 
    {
       DebugPrintEx(DEBUG_ERR, "INVALID pTG->Operation=%d",(int)pTG->Operation );
       goto end;
    }

    if (lpMdmCaps->uClasses = (USHORT)ProfileListGetInt(KeyList, szModemFaxClasses, 0))
    {
        pTG->TmpSettings.dwGot |= fGOTCAP_CLASSES;
    }

    if(lpMdmCaps->uClasses & FAXCLASS1)
    {
        if (lpMdmCaps->uSendSpeeds = (USHORT)ProfileListGetInt(KeyList, szModemSendSpeeds, 0))
        {
            pTG->TmpSettings.dwGot |= fGOTCAP_SENDSPEEDS;
        }
        if (lpMdmCaps->uRecvSpeeds = (USHORT)ProfileListGetInt(KeyList, szModemRecvSpeeds, 0))
        {
            pTG->TmpSettings.dwGot |= fGOTCAP_RECVSPEEDS;
        }
    }

    pTG->ModemKeyCreationId = ProfileGetInt(dwKey, szModemKeyCreationId, 0, FALSE);

    //RSL 10/10/96

    pTG->Inst.ProtParams.fEnableV17Send   = ProfileListGetInt(KeyList, szEnableV17Send, 1);

    if (IsCacheIntDirty(UnimodemFaxKey,szEnableV17Send,pTG->Inst.ProtParams.fEnableV17Send))
    {
        DebugPrintEx(DEBUG_WRN, "EnableV17Send cached settings are invalid, need to re-install the modem.");
        fRet = FALSE;
        goto end;
    }

    pTG->Inst.ProtParams.fEnableV17Recv   = ProfileListGetInt(KeyList, szEnableV17Recv, 1);

    if (IsCacheIntDirty(UnimodemFaxKey,szEnableV17Recv,pTG->Inst.ProtParams.fEnableV17Recv))
    {
        DebugPrintEx(DEBUG_WRN, "EnableV17Recv cached settings are invalid, need to re-install the modem.");
        fRet = FALSE;
        goto end;
    }

    uTmp = ProfileListGetInt(KeyList, szHighestSendSpeed, 0);

    if (IsCacheIntDirty(UnimodemFaxKey,szHighestSendSpeed,uTmp))
    {
        DebugPrintEx(DEBUG_WRN, "HighestSendSpeed cached settings are invalid, need to re-install the modem.");
        fRet = FALSE;
        goto end;
    }

    if (uTmp) 
    {
        pTG->Inst.ProtParams.HighestSendSpeed = (SHORT)uTmp;
    }

    uTmp = ProfileListGetInt(KeyList, szLowestSendSpeed, 0);
    
    if (IsCacheIntDirty(UnimodemFaxKey,szLowestSendSpeed,uTmp))
    {
        DebugPrintEx(DEBUG_WRN, "LowestSendSpeed cached settings are invalid, need to re-install the modem.");
        fRet = FALSE;
        goto end;
    }

    if (uTmp) 
    {
        pTG->Inst.ProtParams.LowestSendSpeed = (SHORT)uTmp;
    }

    uTmp = ProfileListGetInt(KeyList, szSerialSpeedInit, 0);

    if (IsCacheIntDirty(UnimodemFaxKey,szSerialSpeedInit,uTmp))
    {
        DebugPrintEx(DEBUG_WRN, "SerialSpeedInit cached settings are invalid, need to re-install the modem.");
        fRet = FALSE;
        goto end;
    }

    if (uTmp) 
    {
        pTG->SerialSpeedInit = (UWORD)uTmp;
        pTG->SerialSpeedInitSet = 1;
        pTG->TmpSettings.dwGot |= fGOTPARM_PORTSPEED;
    }

    uTmp = ProfileListGetInt(KeyList, szSerialSpeedConnect, 0);
    if (uTmp) 
    {
        pTG->SerialSpeedConnect = (UWORD)uTmp;
        pTG->SerialSpeedConnectSet = 1;
        pTG->TmpSettings.dwGot |= fGOTPARM_PORTSPEED;
    }

    uTmp = ProfileListGetInt(KeyList, szHardwareFlowControl, 0);

    if (IsCacheIntDirty(UnimodemFaxKey,szHardwareFlowControl,uTmp))
    {
        DebugPrintEx(DEBUG_WRN, "HardwareFlowControl cached settings are invalid, need to re-install the modem.");
        fRet = FALSE;
        goto end;
    }

    if (uTmp) 
    {
        pTG->fEnableHardwareFlowControl = 1;
    }


    DebugPrintEx(   DEBUG_MSG, 
                    "fEnableV17Send=%d, fEnableV17Recv=%d, "
                    "HighestSendSpeed=%d, Low=%d EnableAdaptAnswer=%d",
                     pTG->Inst.ProtParams.fEnableV17Send,
                     pTG->Inst.ProtParams.fEnableV17Recv,
                     pTG->Inst.ProtParams.HighestSendSpeed,
                     pTG->Inst.ProtParams.LowestSendSpeed,
                     pTG->AdaptiveAnswerEnable);
    
    DebugPrintEx(   DEBUG_MSG, 
                    "HardwareFlowControl=%d, SerialSpeedInit=%d, SerialSpeedConnect=%d",
                    pTG->fEnableHardwareFlowControl,
                    pTG->SerialSpeedInit,
                    pTG->SerialSpeedConnect);

    // get CmdTab. We distinguish been a command being not-specified and null.
    //

    if (imodem_list_get_str(pTG,KeyList,szResetCommand,pTG->TmpSettings.szReset,MAXCMDSIZE,TRUE))
    {
        pTG->TmpSettings.dwGot |= fGOTCMD_Reset;
    }

    if (IsCacheStringDirty(UnimodemFaxKey,szResetCommand,pTG->TmpSettings.szReset))
    {
        DebugPrintEx(DEBUG_WRN, "ResetCommand cached settings are invalid, need to re-install the modem.");
        fRet = FALSE;
        goto end;
    }

    if (imodem_list_get_str(pTG,KeyList,szSetupCommand,pTG->TmpSettings.szSetup,MAXCMDSIZE,TRUE))
    {
        pTG->TmpSettings.dwGot |= fGOTCMD_Setup;
    }

    if (IsCacheStringDirty(UnimodemFaxKey,szSetupCommand,pTG->TmpSettings.szSetup))
    {
        DebugPrintEx(DEBUG_WRN, "SetupCommand cached settings are invalid, need to re-install the modem.");
        fRet = FALSE;
        goto end;
    }

    if (imodem_list_get_str(pTG,KeyList,szResetCommandGenerated,pTG->TmpSettings.szResetGenerated,MAXCMDSIZE,TRUE))
    {
        DebugPrintEx(DEBUG_MSG, "Will use generated ResetCommand %s", pTG->TmpSettings.szResetGenerated);
    }
    if (imodem_list_get_str(pTG,KeyList,szSetupCommandGenerated,pTG->TmpSettings.szSetupGenerated,MAXCMDSIZE,TRUE))
    {
        DebugPrintEx(DEBUG_MSG, "Will use generated SetupCommand %s", pTG->TmpSettings.szSetupGenerated);
    }

    if (imodem_list_get_str(pTG,KeyList,szPreDialCommand,pTG->TmpSettings.szPreDial,MAXCMDSIZE,TRUE))
    {
        pTG->TmpSettings.dwGot |= fGOTCMD_PreDial;
    }

    if (IsCacheStringDirty(UnimodemFaxKey,szPreDialCommand,pTG->TmpSettings.szPreDial))
    {
        DebugPrintEx(DEBUG_WRN, "PreDialCommand cached settings are invalid, need to re-install the modem.");
        fRet = FALSE;
        goto end;
    }

    if (imodem_list_get_str(pTG,KeyList,szPreAnswerCommand,pTG->TmpSettings.szPreAnswer,MAXCMDSIZE,TRUE))
    {
        pTG->TmpSettings.dwGot |= fGOTCMD_PreAnswer;
    }

    if (IsCacheStringDirty(UnimodemFaxKey,szPreAnswerCommand,pTG->TmpSettings.szPreAnswer))
    {
        DebugPrintEx(DEBUG_WRN, "PreAnswerCommand cached settings are invalid, need to re-install the modem.");
        fRet = FALSE;
        goto end;
    }

    if (imodem_list_get_str(pTG,KeyList,szExitCommand,pTG->TmpSettings.szExit,MAXCMDSIZE,TRUE))
    {
        pTG->TmpSettings.dwGot |= fGOTCMD_PreExit;
    }

    if (IsCacheStringDirty(UnimodemFaxKey,szExitCommand,pTG->TmpSettings.szExit))
    {
        DebugPrintEx(DEBUG_WRN, "ExitCommand cached settings are invalid, need to re-install the modem.");
        fRet = FALSE;
        goto end;
    }

    //
    // Adaptive Answer strings ONLY.
    //

    if (pTG->AdaptiveAnswerEnable) 
    {
       pTG->AnswerCommandNum = 0;

       // get Answer commands key
       sprintf(KeyName, "%s\\Class1\\AdaptiveAnswer\\AnswerCommand", pTG->FComModem.rgchKey);

       dwKeyAnswer = ProfileOpen(pTG->FComModem.dwProfileID, KeyName, fREG_READ);

       if (dwKeyAnswer == 0) 
       {
          DebugPrintEx(DEBUG_ERR, "AdaptiveAnswer\\AnswerCommand does not exist");
          goto lPostAdaptiveAnswer;
       }

       for (i=1; i<=20; i++) 
       {
          sprintf (KeyName, "%d", i);
          if ( ! imodem_get_str(pTG, dwKeyAnswer, KeyName, lpTemp, MAXCMDSIZE, TRUE) ) 
          {
             break;
          }

          if (NULL != (pTG->AnswerCommand[pTG->AnswerCommandNum] = MemAlloc( strlen(lpTemp) + 1))) 
          {
             strcpy  ( pTG->AnswerCommand[pTG->AnswerCommandNum], lpTemp);
          }
          else 
          {
             goto end;
          }

          pTG->AnswerCommandNum++;
       }

       ProfileClose(dwKeyAnswer);

       if (pTG->AnswerCommandNum == 0) 
       {
          DebugPrintEx(DEBUG_ERR, "AdaptiveAnswer\\AnswerCommand Zero values.");
          goto lPostAdaptiveAnswer;
       }

       if ( imodem_get_str(pTG, dwKeyAdaptiveAnswer, szModemResponseFaxDetect, lpTemp, MAXCMDSIZE, FALSE) ) 
       {
          if (NULL != (pTG->ModemResponseFaxDetect = MemAlloc( strlen(lpTemp) + 1)))
             strcpy  ( pTG->ModemResponseFaxDetect, lpTemp);
          else
             goto end;
       }

       if ( imodem_get_str(pTG, dwKeyAdaptiveAnswer, szModemResponseDataDetect, lpTemp, MAXCMDSIZE, FALSE) ) 
       {
          if (NULL != (pTG->ModemResponseDataDetect = MemAlloc( strlen(lpTemp) + 1)))
             strcpy  ( pTG->ModemResponseDataDetect, lpTemp);
          else
             goto end;
       }

       if ( imodem_get_str(pTG, dwKeyAdaptiveAnswer, szSerialSpeedFaxDetect, lpTemp, MAXCMDSIZE, FALSE) ) 
       {
          pTG->SerialSpeedFaxDetect = (UWORD)atoi (lpTemp);
       }

       if ( imodem_get_str(pTG, dwKeyAdaptiveAnswer, szSerialSpeedDataDetect, lpTemp, MAXCMDSIZE, FALSE) ) 
       {
          pTG->SerialSpeedDataDetect = (UWORD)atoi (lpTemp);
       }

       if ( imodem_get_str(pTG, dwKeyAdaptiveAnswer, szHostCommandFaxDetect, lpTemp, MAXCMDSIZE, TRUE) ) 
       {
          if (NULL != (pTG->HostCommandFaxDetect = MemAlloc( strlen(lpTemp) + 1)))
             strcpy  ( pTG->HostCommandFaxDetect, lpTemp);
          else
             goto end;
       }

       if ( imodem_get_str(pTG, dwKeyAdaptiveAnswer, szHostCommandDataDetect, lpTemp, MAXCMDSIZE, TRUE) ) 
       {
          if (NULL != (pTG->HostCommandDataDetect = MemAlloc( strlen(lpTemp) + 1)))
             strcpy  ( pTG->HostCommandDataDetect, lpTemp);
          else
              goto end;
       }

       if ( imodem_get_str(pTG, dwKeyAdaptiveAnswer, szModemResponseFaxConnect, lpTemp, MAXCMDSIZE, FALSE) ) 
       {
          if (NULL != (pTG->ModemResponseFaxConnect = MemAlloc( strlen(lpTemp) + 1)))
             strcpy  ( pTG->ModemResponseFaxConnect, lpTemp);
          else
              goto end;
       }

       if ( imodem_get_str(pTG, dwKeyAdaptiveAnswer, szModemResponseDataConnect, lpTemp, MAXCMDSIZE, FALSE) ) 
       {
          if (NULL != (pTG->ModemResponseDataConnect = MemAlloc( strlen(lpTemp) + 1)))
             strcpy  ( pTG->ModemResponseDataConnect, lpTemp);
          else
             goto end;
       }


    }




lPostAdaptiveAnswer:

    pTG->FixSerialSpeed = (UWORD)ProfileListGetInt(KeyList, szFixSerialSpeed, 0);
    if (pTG->FixSerialSpeed) 
    {
         pTG->TmpSettings.dwGot |= fGOTPARM_PORTSPEED;
         pTG->FixSerialSpeedSet = 1;
    }

    if (IsCacheIntDirty(UnimodemFaxKey,szFixSerialSpeed,pTG->FixSerialSpeed))
    {
        DebugPrintEx(DEBUG_WRN, "FixSerialSpeed cached settings are invalid, need to re-install the modem.");
        fRet = FALSE;
        goto end;
    }

    //
    // Merge 3 optional different settings for Serial Speed here
    //

    // FixSerialSpeed overrides the others (init/connect)

    if (pTG->FixSerialSpeedSet) 
    {
        pTG->SerialSpeedInit = pTG->FixSerialSpeed;
        pTG->SerialSpeedConnect = pTG->FixSerialSpeed;
        pTG->SerialSpeedInitSet = 1;
        pTG->SerialSpeedConnectSet = 1;
    }

    // if only one of init/connect then the other is same

    if ( pTG->SerialSpeedInitSet && (!pTG->SerialSpeedConnectSet) ) 
    {
       pTG->SerialSpeedConnect = pTG->SerialSpeedInit;
       pTG->SerialSpeedConnectSet = 1;
    }
    else if ( (!pTG->SerialSpeedInitSet) && pTG->SerialSpeedConnectSet ) 
    {
       pTG->SerialSpeedInit = pTG->SerialSpeedConnect;
       pTG->SerialSpeedInitSet = 1;
    }

    // values init/connect are always initialized. 
    // Use (init/connect)Set flags to determine whether there were originally set.
    
    if (! pTG->SerialSpeedInit) 
    {
        pTG->SerialSpeedInit    = 57600;
        pTG->SerialSpeedConnect = 57600;
    }

    // +++ Expand as necessary:
    if (ProfileListGetInt(KeyList, szCL1_NO_SYNC_IF_CMD, 1))
    {
        pTG->TmpSettings.dwFlags |= fMDMSP_C1_NO_SYNC_IF_CMD;
    }
    if (ProfileListGetInt(KeyList, szANS_GOCLASS_TWICE, 1))
    {
        pTG->TmpSettings.dwFlags |= fMDMSP_ANS_GOCLASS_TWICE; // DEFAULT
    }
#define szMDMSP_C1_FCS  "Cl1FCS" // 0==dunno 1=NO 2=yes-bad
    // specifies whether the modem reports the 2-byteFCS with
    // received HDLC data. (Elliot bugs# 3641, 3668, 3086 report
    // cases of modems sending incorrect FCS bytes).
    // 9/7/95 JosephJ -- changed default from 0 to 2 because Class1 spec
    // says we should NOT rely on the FCS bytes being computed correctly.
    switch(ProfileListGetInt(KeyList, szMDMSP_C1_FCS, 2))
    {
    case 1: pTG->TmpSettings.dwFlags |= fMDMSP_C1_FCS_NO;
            break;
    case 2: pTG->TmpSettings.dwFlags |= fMDMSP_C1_FCS_YES_BAD;
            break;
    }
    pTG->TmpSettings.dwGot |= fGOTFLAGS;

    // Retrieve ID command.
    // a way around this Id check. If IdCmd has been manually deleted, skip chk
    if (imodem_list_get_str(pTG, KeyList, szModemIdCmd,
                                    pTG->TmpSettings.szIDCmd, MAXCMDSIZE, TRUE))
    {
            pTG->TmpSettings.dwGot |= fGOTPARM_IDCMD;
            if (imodem_list_get_str(pTG, KeyList, szModemId,
                                    pTG->TmpSettings.szID, MAXIDSIZE, FALSE))
                    pTG->TmpSettings.dwGot |= fGOTPARM_ID;
    }

    pTG->TmpSettings.uDontPurge= (USHORT)ProfileListGetInt(KeyList, szDONT_PURGE, 0xff);


    //
    // Classes 2 and 2.0
    //

    if (pTG->ModemClass != MODEM_CLASS1) 
    {
        uTmp = ProfileListGetInt(KeyList,szRECV_BOR, CL2_DEFAULT_SETTING);
        pTG->CurrentMFRSpec.iReceiveBOR = (USHORT) uTmp;
   
        uTmp = ProfileListGetInt(KeyList, szSEND_BOR, CL2_DEFAULT_SETTING);
        pTG->CurrentMFRSpec.iSendBOR = (USHORT) uTmp;
                  
        uTmp = ProfileListGetInt(KeyList, szSW_BOR, CL2_DEFAULT_SETTING);
        pTG->CurrentMFRSpec.fSWFBOR = (BOOL) uTmp;
   
        uTmp = ProfileListGetInt(KeyList, szDC2CHAR, CL2_DEFAULT_SETTING);
        pTG->CurrentMFRSpec.szDC2[0] = (CHAR) uTmp;
   
        uTmp = ProfileListGetInt(KeyList, szIS_SIERRA, CL2_DEFAULT_SETTING);
        pTG->CurrentMFRSpec.bIsSierra = (BOOL) uTmp;
   
        uTmp = ProfileListGetInt(KeyList, szIS_EXAR, CL2_DEFAULT_SETTING);
        pTG->CurrentMFRSpec.bIsExar = (BOOL) uTmp;
   
        uTmp = ProfileListGetInt(KeyList, szSKIP_CTRL_Q, CL2_DEFAULT_SETTING);
        pTG->CurrentMFRSpec.fSkipCtrlQ = (BOOL) uTmp;
    }

    if (dwKey)
        ProfileClose(dwKey);

#define fMANDATORY (fGOTCMD_Reset|fGOTCMD_Setup|fGOTCAP_CLASSES)
#define fCLASS1MANDATORY (fMANDATORY | fGOTCAP_SENDSPEEDS | fGOTCAP_RECVSPEEDS)
    fRet = (lpMdmCaps->uClasses & FAXCLASS1)
              ?     ((pTG->TmpSettings.dwGot & fCLASS1MANDATORY) == fCLASS1MANDATORY)
              :     ((pTG->TmpSettings.dwGot & fMANDATORY) == fMANDATORY);

end:
        
   for (i=1; i<10; i++) 
   {
        if (KeyList[i] != 0) 
        {
             ProfileClose (KeyList[i]);
        }
   }

   if (UnimodemFaxKey)
   {
        ProfileClose(UnimodemFaxKey);
   }
   if (!fRet) 
   { // Lets free all memory that was allocated here
       CleanModemInfStrings (pTG);
   }

   return fRet;
}


void SaveCl2Settings(PThrdGlbl pTG, DWORD_PTR dwKey)
{
    DEBUG_FUNCTION_NAME(("SaveCl2Settings"));

    if (pTG->ModemClass != MODEM_CLASS1) 
    {
        if (pTG->CurrentMFRSpec.iReceiveBOR != CL2_DEFAULT_SETTING)
        {
            wsprintf(pTG->TmpSettings.szSmallTemp1, "%lu", (unsigned long) pTG->CurrentMFRSpec.iReceiveBOR);
            ProfileWriteString(dwKey, szRECV_BOR, pTG->TmpSettings.szSmallTemp1, FALSE);
        }
        if (pTG->CurrentMFRSpec.iSendBOR != CL2_DEFAULT_SETTING)
        {
            wsprintf(pTG->TmpSettings.szSmallTemp1, "%lu", (unsigned long) pTG->CurrentMFRSpec.iSendBOR);
            ProfileWriteString(dwKey, szSEND_BOR, pTG->TmpSettings.szSmallTemp1, FALSE);
        }
        if (pTG->CurrentMFRSpec.fSWFBOR != CL2_DEFAULT_SETTING)
        {
            wsprintf(pTG->TmpSettings.szSmallTemp1, "%lu", (unsigned long) pTG->CurrentMFRSpec.fSWFBOR);
            ProfileWriteString(dwKey, szSW_BOR, pTG->TmpSettings.szSmallTemp1, FALSE);
        }
        if (pTG->CurrentMFRSpec.szDC2[0] != (CHAR)CL2_DEFAULT_SETTING)
        {
            wsprintf(pTG->TmpSettings.szSmallTemp1, "%lu", (unsigned long) pTG->CurrentMFRSpec.szDC2[0]);
            ProfileWriteString(dwKey, szDC2CHAR, pTG->TmpSettings.szSmallTemp1, FALSE);
        }
        if (pTG->CurrentMFRSpec.bIsSierra != CL2_DEFAULT_SETTING)
        {
            wsprintf(pTG->TmpSettings.szSmallTemp1, "%lu", (unsigned long) pTG->CurrentMFRSpec.bIsSierra);
            ProfileWriteString(dwKey, szIS_SIERRA, pTG->TmpSettings.szSmallTemp1, FALSE);
        }
        if (pTG->CurrentMFRSpec.bIsExar != CL2_DEFAULT_SETTING)
        {
            wsprintf(pTG->TmpSettings.szSmallTemp1, "%lu", (unsigned long) pTG->CurrentMFRSpec.bIsExar);
            ProfileWriteString(dwKey, szIS_EXAR, pTG->TmpSettings.szSmallTemp1, FALSE);
        }
        if (pTG->CurrentMFRSpec.fSkipCtrlQ != CL2_DEFAULT_SETTING)
        {
            wsprintf(pTG->TmpSettings.szSmallTemp1, "%lu", (unsigned long) pTG->CurrentMFRSpec.fSkipCtrlQ);
            ProfileWriteString(dwKey, szSKIP_CTRL_Q, pTG->TmpSettings.szSmallTemp1, FALSE);
        }
    }
}


BOOL iModemSaveCurrentModemInfo(PThrdGlbl pTG)
{
    DWORD_PTR      dwKey=0;
    LPMODEMCAPS    lpMdmCaps = pTG->TmpSettings.lpMdmCaps;
    char           KeyName[200];
    DWORD_PTR      dwKeyAdaptiveAnswer=0;
    DWORD_PTR      dwKeyAnswer=0;
    DWORD          i;
    char           szClass[10];


    DEBUG_FUNCTION_NAME(("iModemSaveCurrentModemInfo"));
    //
    // Right now we save all major caps at the root level.
    //
      
    if (!(dwKey=ProfileOpen(pTG->FComModem.dwProfileID, pTG->FComModem.rgchKey,
                                                    fREG_CREATE | fREG_READ | fREG_WRITE)))
    {
        DebugPrintEx(DEBUG_ERR,"Couldn't get location of modem info.");
        goto failure;
    }

    if (! pTG->ModemClass) 
    {
       pTG->ModemClass = MODEM_CLASS1;  
       DebugPrintEx(DEBUG_ERR, "MODEM CLASS was not defined.");
    }

    switch (pTG->ModemClass) 
    {
    case MODEM_CLASS1 :
       ProfileWriteString(dwKey, szFixModemClass, "1", TRUE);
       sprintf(szClass, "Class1");
       break;

    case MODEM_CLASS2 :
       sprintf(szClass, "Class2");
       ProfileWriteString(dwKey, szFixModemClass, "2", TRUE);
       break;

    case MODEM_CLASS2_0 :
       sprintf(szClass, "Class2_0");
       ProfileWriteString(dwKey, szFixModemClass, "20", TRUE);
       break;

    default:
       sprintf(szClass, "Class1");
    }

    wsprintf(pTG->TmpSettings.szSmallTemp1, "%lu", (unsigned long) pTG->ModemKeyCreationId );
    ProfileWriteString(dwKey, szModemKeyCreationId,   pTG->TmpSettings.szSmallTemp1, FALSE);
    
    ////// Modem Commands
    ProfileWriteString(dwKey, szResetCommand,          pTG->TmpSettings.szReset, TRUE);
    ProfileWriteString(dwKey, szResetCommandGenerated, pTG->TmpSettings.szResetGenerated, TRUE);
    ProfileWriteString(dwKey, szSetupCommand,          pTG->TmpSettings.szSetup, TRUE);
    ProfileWriteString(dwKey, szSetupCommandGenerated, pTG->TmpSettings.szSetupGenerated, TRUE);
    ProfileWriteString(dwKey, szExitCommand ,          pTG->TmpSettings.szExit, TRUE);
    ProfileWriteString(dwKey, szPreDialCommand  ,      pTG->TmpSettings.szPreDial, TRUE);
    ProfileWriteString(dwKey, szPreAnswerCommand,      pTG->TmpSettings.szPreAnswer, TRUE);


    //
    // Adaptive Answer
    //

    if (pTG->AdaptiveAnswerEnable) 
    {
       // create Class key if it doesn't exist

       sprintf(KeyName, "%s\\%s", pTG->FComModem.rgchKey, szClass);

       dwKeyAdaptiveAnswer = ProfileOpen(pTG->FComModem.dwProfileID, KeyName, fREG_CREATE | fREG_READ | fREG_WRITE);
       if (dwKeyAdaptiveAnswer == 0) 
       {
            DebugPrintEx(DEBUG_ERR,"couldn't open Class1.");
            goto failure;
       }

       ProfileClose(dwKeyAdaptiveAnswer);

       // create Class1\AdaptiveAnswer key if it doesn't exist

       sprintf(KeyName, "%s\\%s\\AdaptiveAnswer", pTG->FComModem.rgchKey, szClass);

       dwKeyAdaptiveAnswer = ProfileOpen(pTG->FComModem.dwProfileID, KeyName, fREG_CREATE | fREG_READ | fREG_WRITE);
       if (dwKeyAdaptiveAnswer == 0) 
       {
            DebugPrintEx(DEBUG_ERR,"couldn't open AdaptiveAnswer.");
            goto failure;
       }

       // create Class1\AdaptiveAnswer\Answer key if it doesn't exist

       sprintf(KeyName, "%s\\%s\\AdaptiveAnswer\\AnswerCommand", pTG->FComModem.rgchKey, szClass);

       dwKeyAnswer = ProfileOpen(pTG->FComModem.dwProfileID, KeyName, fREG_CREATE | fREG_READ | fREG_WRITE);
       if (dwKeyAnswer == 0) 
       {
            DebugPrintEx(DEBUG_ERR,"couldn't open AdaptiveAnswer\\AnswerCommand .");
            goto failure;
       }

       for (i=0; i<pTG->AnswerCommandNum; i++) 
       {
          sprintf (KeyName, "%d", i+1);
          ProfileWriteString (dwKeyAnswer, KeyName , pTG->AnswerCommand[i], TRUE );
       }

       ProfileClose(dwKeyAnswer);

       // store the rest of the AdaptiveAnswer values

       if (pTG->ModemResponseFaxDetect)
          ProfileWriteString (dwKeyAdaptiveAnswer, szModemResponseFaxDetect, pTG->ModemResponseFaxDetect, FALSE);

       if (pTG->ModemResponseDataDetect)
          ProfileWriteString (dwKeyAdaptiveAnswer, szModemResponseDataDetect, pTG->ModemResponseDataDetect, FALSE);

       if (pTG->SerialSpeedFaxDetect) 
       {
          sprintf (KeyName, "%d", pTG->SerialSpeedFaxDetect);
          ProfileWriteString (dwKeyAdaptiveAnswer, szSerialSpeedFaxDetect, KeyName, FALSE);
       }

       if (pTG->SerialSpeedDataDetect)   
       {
          sprintf (KeyName, "%d", pTG->SerialSpeedDataDetect);
          ProfileWriteString (dwKeyAdaptiveAnswer, szSerialSpeedDataDetect, KeyName, FALSE);
       }

       if (pTG->HostCommandFaxDetect)
          ProfileWriteString (dwKeyAdaptiveAnswer, szHostCommandFaxDetect, pTG->HostCommandFaxDetect, TRUE);

       if (pTG->HostCommandDataDetect)
          ProfileWriteString (dwKeyAdaptiveAnswer, szHostCommandDataDetect, pTG->HostCommandDataDetect, TRUE);


       if (pTG->ModemResponseFaxConnect)
          ProfileWriteString (dwKeyAdaptiveAnswer, szModemResponseFaxConnect, pTG->ModemResponseFaxConnect, FALSE);

       if (pTG->ModemResponseDataConnect)
          ProfileWriteString (dwKeyAdaptiveAnswer, szModemResponseDataConnect, pTG->ModemResponseDataConnect, FALSE);


       ProfileClose(dwKeyAdaptiveAnswer);

    }

    if (pTG->fEnableHardwareFlowControl) 
    {
       ProfileWriteString (dwKey, szHardwareFlowControl, "1", FALSE);
    }


    //
    // Serial Speed
    //

    if (!pTG->SerialSpeedInitSet) 
    {
         wsprintf(pTG->TmpSettings.szSmallTemp1, "%lu", (unsigned long) pTG->TmpSettings.dwSerialSpeed);
         ProfileWriteString(dwKey, szFixSerialSpeed,   pTG->TmpSettings.szSmallTemp1, FALSE);
    }
    else 
    {
       wsprintf(pTG->TmpSettings.szSmallTemp1, "%lu", (unsigned long) pTG->SerialSpeedInit);
       ProfileWriteString(dwKey, szSerialSpeedInit, pTG->TmpSettings.szSmallTemp1, FALSE);
    }

    if (pTG->TmpSettings.dwGot & fGOTFLAGS)
    {
        if (pTG->TmpSettings.dwFlags & fMDMSP_C1_NO_SYNC_IF_CMD)
        {
            ProfileWriteString(dwKey, szCL1_NO_SYNC_IF_CMD, "1", FALSE);
        }

        if (!(pTG->TmpSettings.dwFlags & fMDMSP_ANS_GOCLASS_TWICE))
        {
            ProfileWriteString(dwKey, szANS_GOCLASS_TWICE, "0", FALSE);
        }
    }

    // uDontPurge==1 => save 1
    // otherwise     => save 0
    wsprintf(pTG->TmpSettings.szSmallTemp1, "%lu", (unsigned long) (pTG->TmpSettings.uDontPurge==1)?1:0);
    ProfileWriteString(dwKey, szDONT_PURGE, pTG->TmpSettings.szSmallTemp1, FALSE);

    ///////// Modem Caps...
    // write out Classes, then Speeds
    wsprintf(pTG->TmpSettings.szSmallTemp1, "%u", (unsigned) lpMdmCaps->uClasses);
    ProfileWriteString(dwKey, szModemFaxClasses,   pTG->TmpSettings.szSmallTemp1, FALSE);

    // Classes 2 and 2.0 
    SaveCl2Settings(pTG, dwKey);

    if(lpMdmCaps->uClasses & FAXCLASS1)
    {
        wsprintf(pTG->TmpSettings.szSmallTemp1, "%u", (unsigned) lpMdmCaps->uSendSpeeds);
        ProfileWriteString(dwKey, szModemSendSpeeds, pTG->TmpSettings.szSmallTemp1, FALSE);

        wsprintf(pTG->TmpSettings.szSmallTemp1, "%u", (unsigned) lpMdmCaps->uRecvSpeeds);
        ProfileWriteString(dwKey, szModemRecvSpeeds, pTG->TmpSettings.szSmallTemp1, FALSE);
    }
    if (dwKey)
            ProfileClose(dwKey);

    return TRUE;

failure:
    if (dwKey)
            ProfileClose(dwKey);

    return FALSE;
}

BOOL ReadModemClassFromRegistry  (PThrdGlbl pTG)
{

   UINT            uTmp;
   DWORD_PTR       dwKey;


   if ( ! (dwKey = ProfileOpen(pTG->FComModem.dwProfileID, pTG->FComModem.rgchKey, fREG_READ))) 
   {
       return FALSE;
   }

   //
   // Lets see what modem Class we will use
   //
   uTmp = ProfileGetInt(dwKey, szFixModemClass, 0, FALSE);
   
   if (uTmp == 1) 
   {
      pTG->ModemClass = MODEM_CLASS1;
   }
   else if (uTmp == 2) 
   {
      pTG->ModemClass = MODEM_CLASS2;
   }
   else if (uTmp == 20) 
   {
      pTG->ModemClass = MODEM_CLASS2_0;
   }

   if (dwKey) 
      ProfileClose(dwKey);

   return TRUE;
}

BOOL SaveModemClass2Registry(PThrdGlbl pTG)
{
   DWORD_PTR      dwKey=0;

   DEBUG_FUNCTION_NAME(("SaveModemClass2Registry"));

   if (!(dwKey=ProfileOpen(pTG->FComModem.dwProfileID, pTG->FComModem.rgchKey,
                                                   fREG_CREATE | fREG_READ | fREG_WRITE)))
   {
       DebugPrintEx(DEBUG_ERR,"Couldn't get location of modem info.");
       goto failure;
   }


   switch (pTG->ModemClass) 
   {
   case MODEM_CLASS1 :
      ProfileWriteString(dwKey, szFixModemClass, "1", TRUE);
      break;

   case MODEM_CLASS2 :
      ProfileWriteString(dwKey, szFixModemClass, "2", TRUE);
      break;

   case MODEM_CLASS2_0 :
      ProfileWriteString(dwKey, szFixModemClass, "20", TRUE);
      break;

   default:
      DebugPrintEx(DEBUG_ERR,"pTG->ModemClass=%d", pTG->ModemClass);
      ProfileWriteString(dwKey, szFixModemClass, "1", TRUE);
   }

   if (dwKey)
           ProfileClose(dwKey);

   return TRUE;


failure:
   return FALSE;


}


BOOL SaveInf2Registry  (PThrdGlbl pTG)
{
    DWORD_PTR      dwKey=0;
    LPMODEMCAPS    lpMdmCaps = pTG->TmpSettings.lpMdmCaps;
    char           KeyName[200];
    DWORD_PTR      dwKeyAdaptiveAnswer=0;
    DWORD_PTR      dwKeyAnswer=0;
    DWORD          i;
    char           szClass[10];

    DEBUG_FUNCTION_NAME(("SaveInf2Registry"));

    if (!(dwKey=ProfileOpen(pTG->FComModem.dwProfileID, pTG->FComModem.rgchKey,
                                                    fREG_CREATE | fREG_READ | fREG_WRITE)))
    {
        DebugPrintEx(DEBUG_ERR,"Couldn't get location of modem info.");
        goto failure;
    }

    if (! pTG->ModemClass) 
    {
       DebugPrintEx(DEBUG_ERR,"MODEM CLASS was not defined.");
    }

    switch (pTG->ModemClass) 
    {
    case MODEM_CLASS1 :
       sprintf(szClass, "Class1");
       ProfileWriteString(dwKey, szFixModemClass, "1", TRUE);
       break;

    case MODEM_CLASS2 :
       sprintf(szClass, "Class2");
       ProfileWriteString(dwKey, szFixModemClass, "2", TRUE);
       break;

    case MODEM_CLASS2_0 :
       sprintf(szClass, "Class2_0");
       ProfileWriteString(dwKey, szFixModemClass, "20", TRUE);
       break;

    default:
       sprintf(szClass, "Class1");
    }

    ////// Modem Commands
    if (pTG->TmpSettings.dwGot & fGOTCMD_Reset)
       ProfileWriteString(dwKey, szResetCommand,     pTG->TmpSettings.szReset, TRUE);

    if (pTG->TmpSettings.dwGot & fGOTCMD_Setup)
       ProfileWriteString(dwKey, szSetupCommand,     pTG->TmpSettings.szSetup, TRUE);

    if (pTG->TmpSettings.dwGot & fGOTCMD_PreExit)
       ProfileWriteString(dwKey, szExitCommand ,     pTG->TmpSettings.szExit, TRUE);

    if (pTG->TmpSettings.dwGot & fGOTCMD_PreDial)
       ProfileWriteString(dwKey, szPreDialCommand  , pTG->TmpSettings.szPreDial, TRUE);
    
    if (pTG->TmpSettings.dwGot & fGOTCMD_PreAnswer)
       ProfileWriteString(dwKey, szPreAnswerCommand, pTG->TmpSettings.szPreAnswer, TRUE);


    //
    // Adaptive Answer
    //

    if (pTG->AdaptiveAnswerEnable) 
    {
       // create szClass key if it doesn't exist

       sprintf(KeyName, "%s\\%s", pTG->FComModem.rgchKey, szClass);

       dwKeyAdaptiveAnswer = ProfileOpen(pTG->FComModem.dwProfileID, KeyName, fREG_CREATE | fREG_READ | fREG_WRITE);
       if (dwKeyAdaptiveAnswer == 0) 
       {
            DebugPrintEx(DEBUG_ERR,"couldn't open szClass.");
            goto failure;
       }

       ProfileClose(dwKeyAdaptiveAnswer);

       // create Class\AdaptiveAnswer key if it doesn't exist

       sprintf(KeyName, "%s\\%s\\AdaptiveAnswer", pTG->FComModem.rgchKey, szClass);

       dwKeyAdaptiveAnswer = ProfileOpen(pTG->FComModem.dwProfileID, KeyName, fREG_CREATE | fREG_READ | fREG_WRITE);
       if (dwKeyAdaptiveAnswer == 0) 
       {
            DebugPrintEx(DEBUG_ERR,"couldn't open AdaptiveAnswer.");
            goto failure;
       }

       // create Class1\AdaptiveAnswer\Answer key if it doesn't exist

       sprintf(KeyName, "%s\\%s\\AdaptiveAnswer\\AnswerCommand", pTG->FComModem.rgchKey ,szClass);

       dwKeyAnswer = ProfileOpen(pTG->FComModem.dwProfileID, KeyName, fREG_CREATE | fREG_READ | fREG_WRITE);
       if (dwKeyAnswer == 0) 
       {
            DebugPrintEx(DEBUG_ERR,"couldn't open AdaptiveAnswer\\AnswerCommand .");
            goto failure;
       }

       for (i=0; i<pTG->AnswerCommandNum; i++) 
       {
          sprintf (KeyName, "%d", i+1);
          ProfileWriteString (dwKeyAnswer, KeyName , pTG->AnswerCommand[i], TRUE );
          MemFree( pTG->AnswerCommand[i]);
          pTG->AnswerCommand[i] = NULL;
       }
       pTG->AnswerCommandNum = 0;
       ProfileClose(dwKeyAnswer);

       // store the rest of the AdaptiveAnswer values

       if (pTG->ModemResponseFaxDetect) 
       {
          ProfileWriteString (dwKeyAdaptiveAnswer, szModemResponseFaxDetect, pTG->ModemResponseFaxDetect, FALSE);
          MemFree( pTG->ModemResponseFaxDetect );
          pTG->ModemResponseFaxDetect = NULL;
       }

       if (pTG->ModemResponseDataDetect) 
       {
          ProfileWriteString (dwKeyAdaptiveAnswer, szModemResponseDataDetect, pTG->ModemResponseDataDetect, FALSE);
          MemFree (pTG->ModemResponseDataDetect);
          pTG->ModemResponseDataDetect = NULL;
       }

       if (pTG->SerialSpeedFaxDetect) 
       {
          sprintf (KeyName, "%d", pTG->SerialSpeedFaxDetect);
          ProfileWriteString (dwKeyAdaptiveAnswer, szSerialSpeedFaxDetect, KeyName, FALSE);
       }

       if (pTG->SerialSpeedDataDetect)   
       {
          sprintf (KeyName, "%d", pTG->SerialSpeedDataDetect);
          ProfileWriteString (dwKeyAdaptiveAnswer, szSerialSpeedDataDetect, KeyName, FALSE);
       }

       if (pTG->HostCommandFaxDetect) 
       {
          ProfileWriteString (dwKeyAdaptiveAnswer, szHostCommandFaxDetect, pTG->HostCommandFaxDetect, TRUE);
          MemFree( pTG->HostCommandFaxDetect);
          pTG->HostCommandFaxDetect = NULL;
       }

       if (pTG->HostCommandDataDetect) 
       {
          ProfileWriteString (dwKeyAdaptiveAnswer, szHostCommandDataDetect, pTG->HostCommandDataDetect,TRUE);
          MemFree( pTG->HostCommandDataDetect);
          pTG->HostCommandDataDetect = NULL;
       }

       if (pTG->ModemResponseFaxConnect) 
       {
          ProfileWriteString (dwKeyAdaptiveAnswer, szModemResponseFaxConnect, pTG->ModemResponseFaxConnect, FALSE);
          MemFree( pTG->ModemResponseFaxConnect);
          pTG->ModemResponseFaxConnect = NULL;
       }

       if (pTG->ModemResponseDataConnect) 
       {
          ProfileWriteString (dwKeyAdaptiveAnswer, szModemResponseDataConnect, pTG->ModemResponseDataConnect, FALSE);
          MemFree(pTG->ModemResponseDataConnect);
          pTG->ModemResponseDataConnect = NULL;
       }


       ProfileClose(dwKeyAdaptiveAnswer);

    }


    if (pTG->fEnableHardwareFlowControl) 
    {
       ProfileWriteString (dwKey, szHardwareFlowControl, "1", FALSE);
    }


    //
    // Serial Speed
    //

    if (pTG->SerialSpeedInitSet) 
    {
       wsprintf(pTG->TmpSettings.szSmallTemp1, "%lu", (unsigned long) pTG->SerialSpeedInit);
       ProfileWriteString(dwKey, szSerialSpeedInit, pTG->TmpSettings.szSmallTemp1, FALSE);
    }

    // Classes 2 and 2.0 
    SaveCl2Settings(pTG, dwKey);

    if (dwKey)
            ProfileClose(dwKey);
    return TRUE;



failure:
    if (dwKey)
            ProfileClose(dwKey);
    return FALSE;
}




BOOL imodem_alloc_tmp_strings(PThrdGlbl pTG)
{
    WORD w;
    LPSTR lpstr;
    LPVOID lpv;

    DEBUG_FUNCTION_NAME(("imodem_alloc_tmp_strings"));

    w = TMPSTRINGBUFSIZE;
    pTG->TmpSettings.hglb  = (ULONG_PTR) MemAlloc(TMPSTRINGBUFSIZE);

    if (!pTG->TmpSettings.hglb) 
    {
        goto failure;
    }

    lpv = (LPVOID) (pTG->TmpSettings.hglb);
    lpstr=(LPSTR)lpv;
    if (!lpstr) 
    {
        MemFree( (PVOID) pTG->TmpSettings.hglb); 
        pTG->TmpSettings.hglb=0; 
        goto failure;
    }
    pTG->TmpSettings.lpbBuf = (LPBYTE)lpstr;

    _fmemset(lpstr, 0, TMPSTRINGBUFSIZE);

    pTG->TmpSettings.szReset             = lpstr; lpstr+=MAXCMDSIZE;
    pTG->TmpSettings.szResetGenerated    = lpstr; lpstr+=MAXCMDSIZE;
    pTG->TmpSettings.szSetup             = lpstr; lpstr+=MAXCMDSIZE;
    pTG->TmpSettings.szSetupGenerated    = lpstr; lpstr+=MAXCMDSIZE;
    pTG->TmpSettings.szExit              = lpstr; lpstr+=MAXCMDSIZE;
    pTG->TmpSettings.szPreDial           = lpstr; lpstr+=MAXCMDSIZE;
    pTG->TmpSettings.szPreAnswer         = lpstr; lpstr+=MAXCMDSIZE;
    pTG->TmpSettings.szIDCmd             = lpstr; lpstr+=MAXCMDSIZE;
    pTG->TmpSettings.szID                = lpstr; lpstr+=MAXIDSIZE;
    pTG->TmpSettings.szResponseBuf       = lpstr; lpstr+=RESPONSEBUFSIZE;
    pTG->TmpSettings.szSmallTemp1        = lpstr; lpstr+=SMALLTEMPSIZE;
    pTG->TmpSettings.szSmallTemp2        = lpstr; lpstr+=SMALLTEMPSIZE;

    pTG->TmpSettings.dwGot=0;

    if ( ((LPSTR)lpv+TMPSTRINGBUFSIZE) < lpstr)
    {
        MemFree( (PVOID) pTG->TmpSettings.hglb); 
        pTG->TmpSettings.hglb=0; 
        goto failure;
    }

    return TRUE;

failure:

    DebugPrintEx(DEBUG_ERR,"MyAlloc/MyLock failed!");
    return FALSE;
}

void imodem_free_tmp_strings(PThrdGlbl pTG)
{
    if (pTG->TmpSettings.hglb)
    {
        MemFree( (PVOID) pTG->TmpSettings.hglb);
    }
    _fmemset(&pTG->TmpSettings, 0, sizeof(pTG->TmpSettings));
}

void imodem_clear_tmp_settings(PThrdGlbl pTG)
{
    _fmemset(pTG->TmpSettings.lpMdmCaps, 0, sizeof(MODEMCAPS));
    pTG->TmpSettings.dwGot=0;
    pTG->TmpSettings.uDontPurge=0;
    pTG->TmpSettings.dwSerialSpeed=0;
    pTG->TmpSettings.dwFlags=0;
    _fmemset(pTG->TmpSettings.lpbBuf, 0, TMPSTRINGBUFSIZE);
}

BOOL 
imodem_list_get_str
(
    PThrdGlbl pTG,
    ULONG_PTR  KeyList[10],
    LPSTR     lpszName,
    LPSTR     lpszCmdBuf,
    UINT      cbMax,
    BOOL      fCmd
)
{
    int       i;
    int       Num=0;
    BOOL      bRet=0;


    for (i=0; i<10; i++) 
    {
        if (KeyList[i] == 0) 
        {
            Num = i-1;
            break;
        }
    }

    for (i=Num; i>=0; i--)  
    {
        if ( bRet = imodem_get_str(pTG, KeyList[i], lpszName,  lpszCmdBuf, cbMax,  fCmd) ) 
        {
            return bRet;
        }
    }
   
    return bRet;
}

BOOL imodem_get_str
(
    PThrdGlbl pTG, 
    ULONG_PTR dwKey, 
    LPSTR lpszName, 
    LPSTR lpszCmdBuf, 
    UINT cbMax,
    BOOL fCmd
)
{
    UINT uLen2;
    char *pc = "bogus";

    *lpszCmdBuf=0;

    uLen2 = ProfileGetString(dwKey, lpszName,pc, lpszCmdBuf, cbMax-1);
    if (uLen2)
    {
        if (!_fstrcmp(lpszCmdBuf, pc))
        {
            *lpszCmdBuf=0; return FALSE;
        }
        if (fCmd)
            EndWithCR(lpszCmdBuf, (USHORT)uLen2);
    }
    return TRUE;
}

BOOL iModemCopyOEMInfo(PThrdGlbl pTG)
{

   return ProfileCopyTree(  DEF_BASEKEY, 
                            pTG->FComModem.rgchKey, 
                            OEM_BASEKEY,
                            pTG->lpszUnimodemFaxKey);

}



#define MASKOFFV17              0x03

void SmashCapsAccordingToSettings(PThrdGlbl pTG)
{
    // INI file has already been read.

    DEBUG_FUNCTION_NAME(("SmashCapsAccordingToSettings"));
    // If !fV17Enable then smash the V17 bits of the Capabilities
    if(!pTG->Inst.ProtParams.fEnableV17Send) 
    {
        DebugPrintEx(DEBUG_WRN,"Masking off V.17 send capabilities");
        pTG->FComModem.CurrMdmCaps.uSendSpeeds &= MASKOFFV17;
    }

    if(!pTG->Inst.ProtParams.fEnableV17Recv) 
    {
        DebugPrintEx(DEBUG_WRN,"Masking off V.17 receive capabilities");
        pTG->FComModem.CurrMdmCaps.uRecvSpeeds &= MASKOFFV17;
    }

    //
    // commented out RSL. We run at 19200. Nowhere in awmodem.inf have I seen FixSerialSpeed clause.
    //

    DebugPrintEx(   DEBUG_MSG, 
                    "uSendSpeeds=%x uRecvSpeeds=%x",
                    pTG->FComModem.CurrMdmCaps.uSendSpeeds,  
                    pTG->FComModem.CurrMdmCaps.uRecvSpeeds);

}

int
SearchNewInfFile
(
   PThrdGlbl     pTG,
   char         *Key1,
   char         *Key2,
   BOOL          fRead
)
{

   char      szInfSection[] = "SecondKey=";
   DWORD     lenNewInf;
   int       RetCode = FALSE;
   char      Buffer[400];     // to hold lpToken=lpValue string
   char     *lpCurrent;
   char     *lpStartSection;
   char     *lpTmp;
   char     *lpToken;
   char     *lpValue;


   ToCaps(Key1);

   if (Key2) 
   {
      ToCaps(Key2);
   }

   pTG->AnswerCommandNum = 0;

   if ( ( lenNewInf = strlen(szAdaptiveInf) ) == 0 )  
   {
      return FALSE;
   }
   

   //
   // Loop thru all segments.
   // Each segment starts with InfPath=
   //

   lpCurrent = szAdaptiveInf;

   do 
   {
      // find InfPath
      lpStartSection = strstr (lpCurrent, szResponsesKeyName);
      if (! lpStartSection) 
      {
         goto exit;
      }

      lpTmp = strchr (lpStartSection, '\r' );
      if (!lpTmp) 
      {
         goto exit;
      }

      // compare Key1
      if ( strlen(Key1) != (lpTmp - lpStartSection - strlen(szResponsesKeyName) ) ) 
      {
          lpCurrent = lpTmp;
          continue;
      }

      if ( memcmp (lpStartSection+strlen(szResponsesKeyName),
                   Key1,
                   (ULONG)(lpTmp - lpStartSection - strlen(szResponsesKeyName) ) ) != 0 ) 
      {
         lpCurrent = lpTmp;
         continue;
      }

      // find InfSection

      lpCurrent = lpTmp;

      if (Key2) 
      {
           lpStartSection = strstr (lpCurrent, szInfSection);
           if (! lpStartSection) 
           {
              goto exit;
           }
         
           lpTmp = strchr (lpStartSection, '\r' );
           if (!lpTmp) 
           {
              goto exit;
           }

          // compare Key2

          if ( strlen(Key2) != (lpTmp - lpStartSection - strlen(szInfSection) ) ) 
          {
              lpCurrent = lpTmp;
              continue;
          }
       
          if ( memcmp (lpStartSection+strlen(szInfSection),
                       Key2,
                       (ULONG)(lpTmp - lpStartSection - strlen(szInfSection)) ) != 0 ) 
          {
             lpCurrent = lpTmp;
             continue;
          }

      lpCurrent = lpTmp;

      }

      //
      // both keys matched. Go get settings and return
      //
      
      do 
      {
         lpCurrent = strchr (lpCurrent, '\r' );
         if (!lpCurrent) 
         {
            goto exit;
         }

         lpCurrent += 2;


         // find next setting inside the matching section
         lpToken = lpCurrent;

         lpCurrent = strchr (lpCurrent, '=' );
         if (!lpCurrent) 
         {
            goto exit;
         }

         lpTmp = strchr (lpToken, '\r' );
         if (!lpTmp) 
         {
            goto exit;
         }

         if (lpCurrent > lpTmp) 
         {
            // empty string
            lpCurrent = lpTmp;
            continue;
         }


         lpValue = ++lpCurrent;

         lpTmp = strchr (lpValue, '\r' );
         if (!lpTmp) 
         {
            goto exit;
         }

         // we parsed the string. Now get it to the Buffer

         if (lpTmp - lpToken > sizeof (Buffer) ) 
         {
            goto exit;
         }

         memcpy(Buffer, lpToken, (ULONG)(lpTmp - lpToken));

         Buffer[lpValue -lpToken - 1] = 0;
         Buffer[lpTmp - lpToken] = 0;
         
         lpValue = &Buffer[lpValue - lpToken];
         lpToken = Buffer;

         pTG->fAdaptiveRecordFound = 1;


         if ( my_strcmp(lpToken, szAdaptiveAnswerEnable) ) 
         {
            pTG->AdaptiveAnswerEnable = atoi (lpValue);
         }
         else if ( my_strcmp(lpToken, szAdaptiveRecordUnique) ) 
         {
            pTG->fAdaptiveRecordUnique = atoi (lpValue);
         }
         else if ( my_strcmp(lpToken, szAdaptiveCodeId) ) 
         {
            pTG->AdaptiveCodeId = atoi (lpValue);
            if ( ! fRead ) 
            {
               goto exit;
            }
         }
         else if ( my_strcmp(lpToken, szFaxClass) ) 
         {
            ;
         }
         else if ( my_strcmp(lpToken, szHardwareFlowControl) ) 
         {
            pTG->fEnableHardwareFlowControl = atoi (lpValue);
         }
         else if ( my_strcmp(lpToken, szSerialSpeedInit) ) 
         {
            pTG->SerialSpeedInit = (USHORT)atoi (lpValue);
            pTG->SerialSpeedInitSet = 1;
         }
         else if ( my_strcmp(lpToken, szResetCommand) ) 
         {
            sprintf ( pTG->TmpSettings.szReset, "%s\r", lpValue);
            pTG->TmpSettings.dwGot |= fGOTCMD_Reset;
         }
         else if ( my_strcmp(lpToken, szSetupCommand) ) 
         {
            sprintf ( pTG->TmpSettings.szSetup, "%s\r", lpValue);
            pTG->TmpSettings.dwGot |= fGOTCMD_Setup;
         }
         else if ( my_strcmp(lpToken, szAnswerCommand) ) 
         {
            if (pTG->AnswerCommandNum >= MAX_ANSWER_COMMANDS) 
            {
               goto exit;
            }
    
            if (NULL != (pTG->AnswerCommand[pTG->AnswerCommandNum] = MemAlloc( strlen(lpValue) + 1))) 
            {
                strcpy  ( pTG->AnswerCommand[pTG->AnswerCommandNum], lpValue);
                pTG->AnswerCommandNum++;
            }
            else 
            {
                goto bad_exit;
            }            
         }    
         else if ( my_strcmp(lpToken, szModemResponseFaxDetect) ) 
         {
            if (NULL != (pTG->ModemResponseFaxDetect = MemAlloc( strlen(lpValue) + 1)))
                strcpy  ( pTG->ModemResponseFaxDetect, lpValue);
            else
                goto bad_exit;
         }
         else if ( my_strcmp(lpToken, szModemResponseDataDetect) ) 
         {
            if (NULL != (pTG->ModemResponseDataDetect = MemAlloc( strlen(lpValue) + 1)))
                strcpy  ( pTG->ModemResponseDataDetect, lpValue);
            else
                goto bad_exit;
         }
         else if ( my_strcmp(lpToken, szSerialSpeedFaxDetect) ) 
         {
            pTG->SerialSpeedFaxDetect = (USHORT)atoi (lpValue);
         }
         else if ( my_strcmp(lpToken, szSerialSpeedDataDetect) ) 
         {
            pTG->SerialSpeedDataDetect = (USHORT)atoi (lpValue);
         }
         else if ( my_strcmp(lpToken, szHostCommandFaxDetect) ) 
         {
            if (NULL != (pTG->HostCommandFaxDetect = MemAlloc( strlen(lpValue) + 1)))
                strcpy  ( pTG->HostCommandFaxDetect, lpValue);
            else
                goto bad_exit;
         }
         else if ( my_strcmp(lpToken, szHostCommandDataDetect) ) 
         {
            if (NULL != (pTG->HostCommandDataDetect = MemAlloc( strlen(lpValue) + 1)))
                strcpy  ( pTG->HostCommandDataDetect, lpValue);
            else
                goto bad_exit;
         }
         else if ( my_strcmp(lpToken, szModemResponseFaxConnect) ) 
         {
            if (NULL != (pTG->ModemResponseFaxConnect = MemAlloc( strlen(lpValue) + 1)))
                strcpy  ( pTG->ModemResponseFaxConnect, lpValue);
            else
                goto bad_exit;
         }
         else if ( my_strcmp(lpToken, szModemResponseDataConnect) ) 
         {
            if (NULL != (pTG->ModemResponseDataConnect = MemAlloc( strlen(lpValue) + 1)))
                strcpy  ( pTG->ModemResponseDataConnect, lpValue);
            else
                goto bad_exit;
         }
         else if ( my_strcmp(lpToken, szResponsesKeyName2) ) 
         {
            RetCode = TRUE;
            goto exit;
         }

      } 
      while ( 1 );    // section loop
   } 
   while ( 1 );       // file loop
   return (FALSE);

bad_exit:
   CleanModemInfStrings (pTG);
exit:
   return (RetCode);

}


VOID
CleanModemInfStrings (
       PThrdGlbl pTG
       )

{
   DWORD    i;

   for (i=0; i<pTG->AnswerCommandNum; i++) {
      if (pTG->AnswerCommand[i]) {
         MemFree( pTG->AnswerCommand[i]);
         pTG->AnswerCommand[i] = NULL;
      }
   }

   pTG->AnswerCommandNum = 0;

   if (pTG->ModemResponseFaxDetect) {
      MemFree( pTG->ModemResponseFaxDetect );
      pTG->ModemResponseFaxDetect = NULL;
   }

   if (pTG->ModemResponseDataDetect) {
      MemFree (pTG->ModemResponseDataDetect);
      pTG->ModemResponseDataDetect = NULL;
   }


   if (pTG->HostCommandFaxDetect) {
      MemFree( pTG->HostCommandFaxDetect);
      pTG->HostCommandFaxDetect = NULL;
   }

   if (pTG->HostCommandDataDetect) {
      MemFree( pTG->HostCommandDataDetect);
      pTG->HostCommandDataDetect = NULL;
   }


   if (pTG->ModemResponseFaxConnect) {
      MemFree( pTG->ModemResponseFaxConnect);
      pTG->ModemResponseFaxConnect = NULL;
   }

   if (pTG->ModemResponseDataConnect) {
      MemFree(pTG->ModemResponseDataConnect);
      pTG->ModemResponseDataConnect = NULL;
   }

}
=== C:/Users/treeman/Desktop/windows nt source code\Source\Win2K3\NT\printscan\faxsrv\provider\t30\comm\fdebug.c ===
/***************************************************************************
        Name      :     fdebug.C
        Comment   :     Factored out debug code
        Functions :     (see Prototypes just below)

                Copyright (c) Microsoft Corp. 1991, 1992, 1993

        Revision Log
        Num   Date      Name     Description
        --- -------- ---------- -----------------------------------------------
***************************************************************************/
#define USE_DEBUG_CONTEXT   DEBUG_CONTEXT_T30_COMM

#include "prep.h"

#include <comdevi.h>

#include "efaxcb.h"
#include "fcomapi.h"
#include "fcomint.h"
#include "fdebug.h"


#include "glbproto.h"

#define FLUSHBUFSIZE 256

#undef USE_DEBUG_CONTEXT
#define USE_DEBUG_CONTEXT   DEBUG_CONTEXT_T30_CLASS1

void far D_HexPrint(LPB b1, UWORD incnt)
{
#ifdef DEBUG
        BYTE    b2[FLUSHBUFSIZE];
        UWORD   i, j;

        DEBUG_FUNCTION_NAME(("D_HexPrint"));

        DebugPrintEx(   DEBUG_MSG,
                        "b1=0x%08lx incnt=%d",
                        (LPSTR)b1, 
                        incnt);

        for(i=0; i<incnt;)
        {
            for(j=0; i<incnt && j<FLUSHBUFSIZE-6;)
            {
                j += (UWORD)wsprintf(b2+j, "%02x ", (UWORD)(b1[i]));
                i++;
            }
            b2[j] = 0;
            DebugPrintEx(DEBUG_MSG,"(%s)",(LPSTR)b2);
        }
#endif
}

#undef USE_DEBUG_CONTEXT
#define USE_DEBUG_CONTEXT   DEBUG_CONTEXT_T30_COMM

#ifdef DEBUG


void D_PrintCE(int err)
{
    DEBUG_FUNCTION_NAME(("D_PrintCE"));
    if(err & CE_MODE)
    {
        DebugPrintEx(DEBUG_ERR,"CE(%02x) CE Mode -- or nCid is illegal", err);
        return;
    }
    if(err & CE_RXOVER)
    {
        DebugPrintEx(DEBUG_ERR,"CE(%02x) Receive Buffer Overflow", err);
    }
    if(err & CE_OVERRUN)
    {
        DebugPrintEx(DEBUG_ERR,"CE(%02x) Receive Overrun (not an error during startup)", err);
    }
    if(err & CE_RXPARITY)
    {
        DebugPrintEx(DEBUG_ERR,"CE(%02x) Receive Parity error", err);
    }
    if(err & CE_FRAME)
    {
        DebugPrintEx(DEBUG_ERR,"CE(%02x) Framing error (not an error during call startup or shutdown)", err);
    }
    if(err & CE_BREAK)
    {
        DebugPrintEx(DEBUG_ERR,"CE(%02x) Break condition (not an error during call startup or shutdown)", err);
    }
    if(err & CE_TXFULL)
    {
        DebugPrintEx(DEBUG_ERR,"CE(%02x) Transmit Buffer full", err);
    }
    if(err & (CE_PTO | CE_IOE | CE_DNS | CE_OOP))
    {
        DebugPrintEx(DEBUG_ERR,"CE(%02x) Parallel Printer Errors!!!", err);
    }
}

void D_PrintCOMSTAT(PThrdGlbl pTG, COMSTAT far* lpcs)
{

    DEBUG_FUNCTION_NAME(_T("D_PrintCOMSTAT"));

    if( (lpcs->cbInQue != pTG->PrevcbInQue)             || 
        (lpcs->cbOutQue != pTG->PrevcbOutQue)           ||
        (lpcs->fXoffHold != (DWORD)pTG->PrevfXoffHold)  ||
        (lpcs->fXoffSent != (DWORD)pTG->PrevfXoffSent)  )
    {
        DebugPrintEx(   DEBUG_MSG, 
                        "STAT::: InQ=%d PutQ=%d XoffHold=%d XoffSent=%d",
                        lpcs->cbInQue, 
                        lpcs->cbOutQue,
                        lpcs->fXoffHold, 
                        lpcs->fXoffSent);
    }

    if( lpcs->fCtsHold  || 
        lpcs->fDsrHold  || 
        lpcs->fRlsdHold || 
        lpcs->fEof      || 
        lpcs->fTxim     )
    {
        DebugPrintEx(   DEBUG_MSG, 
                        "???::: CTShold=%d DSRhold=%d RLShold=%d FOF=%d TXim=%d",
                        lpcs->fCtsHold, 
                        lpcs->fDsrHold, 
                        lpcs->fRlsdHold, 
                        lpcs->fEof, 
                        lpcs->fTxim);
    }

    pTG->PrevfXoffHold = lpcs->fXoffHold;
    pTG->PrevfXoffSent = lpcs->fXoffSent;

    pTG->PrevcbInQue = (USHORT) lpcs->cbInQue;
    pTG->PrevcbOutQue = (USHORT) lpcs->cbOutQue;
}

#undef USE_DEBUG_CONTEXT   
#define USE_DEBUG_CONTEXT   DEBUG_CONTEXT_T30_CLASS1


#undef USE_DEBUG_CONTEXT   
#define USE_DEBUG_CONTEXT   DEBUG_CONTEXT_T30_COMM

#endif //DEBUG
=== C:/Users/treeman/Desktop/windows nt source code\Source\Win2K3\NT\printscan\faxsrv\provider\t30\comm\mdmcmds.h ===
#ifdef DEFINE_MDMCMDS

CBSZ cbszAT             = "AT\r";
CBSZ cbszHANGUP         = "ATH0\r";
CBSZ cbszANSWER         = "ATA\r";
CBSZ cbszDIAL           = "ATD%c %s\r";
CBSZ cbszDIAL_EXT       = "ATX%cD%c %s%s\r";

CBSZ cbszS8             = "S8=%d";
CBSZ cbszXn             = "X%d";
CBSZ cbszLn             = "L%d";
CBSZ cbszMn             = "M%d";
CBSZ cbszJustAT         = "AT";

CBSZ cbszOK             = "OK";
CBSZ cbszCONNECT        = "CONNECT";
CBSZ cbszRING           = "RING";
CBSZ cbszNOCARRIER      = "NO CARRIER";
CBSZ cbszERROR          = "ERROR";
CBSZ cbszBLACKLISTED    = "BLACKLISTED";
CBSZ cbszDELAYED        = "DELAYED";
CBSZ cbszNODIALTONE     = "NO DIAL"; // Was NO DIALTONE. Changed to fix
                                     // Elliot Bug#2009: USR28 and USR14
                                     // modems return NO DIAL TONE instead
                                     // of NO DIALTONE.
CBSZ cbszBUSY           = "BUSY";
CBSZ cbszNOANSWER       = "NO ANSWER";
CBSZ cbszFCERROR        = "+FCERROR";


CBSZ cbszGO_CLASS0      = "AT+FCLASS=0\r";
CBSZ cbszGO_CLASS1      = "AT+FCLASS=1\r";
CBSZ cbszGO_CLASS2      = "AT+FCLASS=2\r";
CBSZ cbszGO_CLASS2_0    = "AT+FCLASS=2.0\r";
CBSZ cbszGET_CLASS      = "AT+FCLASS?\r";

CBPSTR rgcbpstrGO_CLASS[] =
{       cbszGO_CLASS0,
        cbszGO_CLASS1,
        cbszGO_CLASS2,
        cbszGO_CLASS2_0
};

USHORT uLenGO_CLASS[] =
{
        sizeof(cbszGO_CLASS0)-1,
        sizeof(cbszGO_CLASS1)-1,
        sizeof(cbszGO_CLASS2)-1,
        sizeof(cbszGO_CLASS2_0)-1,
};

CBSZ cbszQUERY_CLASS    = "AT+FCLASS=?\r";
CBSZ cbszQUERY_FTH              = "AT+FTH=?\r";
CBSZ cbszQUERY_FTM              = "AT+FTM=?\r";
CBSZ cbszQUERY_FRH              = "AT+FRH=?\r";
CBSZ cbszQUERY_FRM              = "AT+FRM=?\r";
CBSZ cbszQUERY_S1               = "ATS1?\r";

#else

extern  CBSZ cbszAT;
extern  CBSZ cbszHANGUP;
extern  CBSZ cbszANSWER;
extern  CBSZ cbszDIAL;
extern  CBSZ cbszDIAL_EXT;

extern  CBSZ cbszS8;
extern  CBSZ cbszXn;
extern  CBSZ cbszLn;
extern  CBSZ cbszMn;
extern  CBSZ cbszJustAT;

extern  CBSZ cbszOK;
extern  CBSZ cbszCONNECT;
extern  CBSZ cbszRING;
extern  CBSZ cbszNOCARRIER;
extern  CBSZ cbszERROR;
extern  CBSZ cbszNODIALTONE;



extern  CBSZ cbszBUSY;
extern  CBSZ cbszNOANSWER;
extern  CBSZ cbszFCERROR;


extern  CBSZ cbszGO_CLASS0;
extern  CBSZ cbszGO_CLASS1;
extern  CBSZ cbszGO_CLASS2;
extern  CBSZ cbszGO_CLASS2_0;
extern  CBSZ cbszGET_CLASS;

extern  CBPSTR rgcbpstrGO_CLASS[];

extern  USHORT uLenGO_CLASS[];

extern  CBSZ cbszQUERY_CLASS;
extern  CBSZ cbszQUERY_FTH;
extern  CBSZ cbszQUERY_FTM;
extern  CBSZ cbszQUERY_FRH;
extern  CBSZ cbszQUERY_FRM;
extern  CBSZ cbszQUERY_S1;

#endif
=== C:/Users/treeman/Desktop/windows nt source code\Source\Win2K3\NT\printscan\faxsrv\provider\t30\comm\filter.c ===
/**************************************************************************
 Name     :     FILTER.C
 Comment  :
 Functions:     (see Prototypes just below)

                Copyright (c) Microsoft Corp. 1991, 1992, 1993

 Revision Log
 Date     Name  Description
 -------- ----- ---------------------------------------------------------
***************************************************************************/
#define USE_DEBUG_CONTEXT   DEBUG_CONTEXT_T30_COMM

#include "prep.h"


#include "fdebug.h"
#include "fcomapi.h"
#include "fcomint.h"



#include "glbproto.h"

UWORD StuffZeroDLE(PThrdGlbl pTG, LPBYTE lpbIn, UWORD cbIn, LPBYTE lpbOut, UWORD cbOutSize, LPUWORD lpcbDone);

/**--------------------------Locals-----------------------------------**/




#define FILTERBUFSIZE  (WRITEQUANTUM * 2)



void  FComSetStuffZERO(PThrdGlbl pTG, USHORT cbLineMin)
{
        pTG->Filter.cbLineMin = cbLineMin;
        pTG->Filter.cbLineCount = 0;
}


void  FComOutFilterInit(PThrdGlbl pTG)
{
        pTG->Filter.cbLineMin = 0;
        pTG->Filter.cbLineCount = 0;
        pTG->Filter.bLastOutByte = 0xFF;

        pTG->Filter.lpbFilterBuf = pTG->bStaticFilterBuf;
}

void  FComOutFilterClose(PThrdGlbl pTG)
{
        pTG->Filter.cbLineMin = 0;
        pTG->Filter.cbLineCount = 0;

        if(!pTG->Filter.lpbFilterBuf)
        {
            DEBUG_FUNCTION_NAME(("FComOutFilterClose"));
            DebugPrintEx(DEBUG_WRN,"called when not open");
            return;
        }

        pTG->Filter.lpbFilterBuf = 0;
}

void  FComInFilterInit(PThrdGlbl pTG)
{
        pTG->Filter.bPrevIn = 0;
        pTG->Filter.fGotDLEETX = 0;
        pTG->Filter.cbPost = 0;
}




/***************************************************************************
        Name      :     UWORD FComFilterWrite(LPB lpb, UWORD cb)
        Purpose   :     Filters bytes for DLE and ZERO stuffing and writes them out.
                                Returns when bytes are in the Comm ISR buffer.
                                DLE stuffing is always on. ZERO stuffing is usually on.
        Parameters:     lpb == data
                                cb == size of pb[]
        Returns   :     cb on success, 0 on failure

        Revision Log
        Num   Date      Name     Description
        --- -------- ---------- -----------------------------------------------
***************************************************************************/

UWORD  FComFilterWrite(PThrdGlbl pTG, LPB lpb, UWORD cb, USHORT flags)
{
    UWORD   cbIn, cbOut, cbDone;
    LPB             lpbIn;

    DEBUG_FUNCTION_NAME(("FComFilterWrite"));

    DebugPrintEx(   DEBUG_MSG, 
                    "lpb=0x%08lx cb=%d lpbFilterBuf=0x%08lx",
                    lpb, 
                    cb, 
                    pTG->Filter.lpbFilterBuf);

    for(lpbIn=lpb, cbIn=cb; cbIn>0; lpbIn += cbDone, cbIn -= cbDone)
    {
        cbOut = StuffZeroDLE(pTG, lpbIn, cbIn, pTG->Filter.lpbFilterBuf,
                                  (UWORD)FILTERBUFSIZE, (LPUWORD)&cbDone);
        if(FComDirectWrite(pTG, pTG->Filter.lpbFilterBuf, cbOut) != cbOut)
        {
            DebugPrintEx(DEBUG_ERR,"exit Timeout");
            return 0;
        }
    }

    // Done....
    DebugPrintEx(DEBUG_MSG,"Exit");
    return cb;
}


/***************************************************************************
 Purpose  :     Copy Input buffer to output, stuffing DLEs and Zeros
                        as specified by fStuffZERO, and cbLineMin. (DLE stuffing
                        is always on).
 Comment  :      This is both debugged and fast. Don't mess around!

;;              Registers are used here as follows
;;
;;      DF = cleared (forward)
;;      AH = previous byte
;;      AL = current byte
;;      CX = byte count of current image line -- initially Filter.cbLineCount
;;      DX = bytes left in input  -- initially [cbIn]
;;      BX = Space left in output -- initially [cbOut]
;;      ES:DI = destination             -- initially [lpbOut]
;;      DS:SI = source                  -- initially [lpbIn]
;;
;;              Since ES & DS are both used, we use the stack frame too
;;              We need to restore the DF flag and the seg regs. can trash
;;              any others.

 Revision Log
 Date     Name  Description
 -------- ----- ---------------------------------------------------------
***************************************************************************/

#define         DLE             0x10
#define         SUB             0x1a
#define         EOL             0x80
#define         EffEff          0xFF
#define         ELEVEN_ZEROS    0xF07F

UWORD StuffZeroDLE
(
    PThrdGlbl pTG, 
    LPBYTE lpbIn, 
    UWORD cbIn, 
    LPBYTE lpbOut,
    UWORD cbOutSize, 
    LPUWORD lpcbDone
)
{
    UWORD   LineMin;        // copy of Filter.cbLineMin. Need it on stack
    UWORD   cbOutLeft;

   BYTE CurByte;
   BYTE PrevByte = pTG->Filter.bLastOutByte;
   UWORD CurLineCount = pTG->Filter.cbLineCount;
   LPBYTE SrcEnd = lpbIn + cbIn;
   LPBYTE DstEnd = lpbOut + cbOutSize - 1;   //Subtract 1 in case write 2 bytes at once
   LPBYTE CurrentSrc = lpbIn;
   LPBYTE CurrentDst = lpbOut;
   UWORD NumZeros;

    DEBUG_FUNCTION_NAME(_T("StuffZeroDLE"));

    DebugPrintEx(   DEBUG_MSG,
                    "lpbIn=0x%08lx cbIn=%d lpbOut=0x%08lx cbOutSize=%d",
                    lpbIn, 
                    cbIn, 
                    lpbOut, 
                    cbOutSize);

    DebugPrintEx(   DEBUG_MSG,
                    "lpcbDone=0x%08lx cbLineMin=%d cbLineCount=%d bLastOutByte=0x%02x",
                    lpcbDone, 
                    pTG->Filter.cbLineMin, 
                    pTG->Filter.cbLineCount, 
                    pTG->Filter.bLastOutByte);

    // OK. Setup stack frame
    LineMin = pTG->Filter.cbLineMin;

    while ((CurrentSrc < SrcEnd) && (CurrentDst < DstEnd)) 
    {
       CurByte = *CurrentSrc++;
       if (CurByte == DLE) 
       {
          *CurrentDst++ = CurByte;
          CurLineCount++;
       }
       if ((CurByte == EOL) && ((PrevByte & 0xF0) == 0)) 
       {
          if ((CurLineCount+1) < LineMin) 
          {
             NumZeros = (LineMin - CurLineCount) - 1;
             if (NumZeros <= (DstEnd - CurrentDst))        // DstEnd-CurrentDst is 1 less than bytes left, leave 1 byte for end of line, hence <=
             {
                for (;NumZeros > 0;NumZeros--)
                   *CurrentDst++ = 0;
             }
             else 
             {
                CurrentSrc--;       //Unget the end of line for count or bytes written
                break;
             }
          }
          CurLineCount = (WORD)-1;
       }
       *CurrentDst++ = CurByte;
       PrevByte = CurByte;
       CurLineCount++;
    }



   pTG->Filter.cbLineCount = CurLineCount;
   pTG->Filter.bLastOutByte = PrevByte;
   *lpcbDone = (UWORD)(cbIn - (SrcEnd - CurrentSrc));
   cbOutLeft = (UWORD)((DstEnd - CurrentDst) + 1);

    DebugPrintEx(   DEBUG_MSG, 
                    "exit: *lpcbDone=%d cbLineMin=%d cbLineCount=%d bLastOutByte=0x%02x",
                    *lpcbDone, 
                    pTG->Filter.cbLineMin, 
                    pTG->Filter.cbLineCount, 
                    pTG->Filter.bLastOutByte);

    DebugPrintEx(   DEBUG_MSG,
                    "exit: cbOutSize=%d cbOutLeft=%d uwRet=%d",
                    cbOutSize, 
                    cbOutLeft, 
                    (cbOutSize-cbOutLeft));

    return (cbOutSize - cbOutLeft);
}

// Used to use NOCARRIER_CRLF. However Elliot bug#3619: Ger TE3801 cannot
// receive in Class1 mode -- this
// modem sends us NO CARRIER\n (missing \r), so we look for
// NO CARRIER[\r\n]*..
// CBSZ cbszNOCARRIER_CRLF      = "NO CARRIER\r\n";
extern CBSZ cbszNOCARRIER;
CBSZ cbszOK_CRLF                = "OK\r\n";
#define NCsize          (sizeof("NO CARRIER")-1)
#define OKsize          (sizeof(cbszOK_CRLF)-1)

#define cbPost          pTG->Filter.cbPost
#define rgbPost         pTG->Filter.rgbPost
#define fGotDLEETX      pTG->Filter.fGotDLEETX
#define bPrevIn         pTG->Filter.bPrevIn

// void WINAPI OutputDebugStr(LPSTR);

#define PortcbSkip   cbSkip
#define PortbPrevIn  bPrevIn

UWORD FComStripBuf
(
    PThrdGlbl pTG, 
    LPB lpbOut, 
    LPB lpbIn, 
    UWORD cb, 
    BOOL fClass2, 
    LPSWORD lpswEOF,
    LPUWORD lpcbUsed
)
{
    LPB     lpbOutStart, lpbLim;
    LPB     lpbInOrig = lpbIn;
    UWORD   cbLeft;
    UWORD   cbSkip;
    UWORD   i;
    LPBYTE CurrentSrc;

    DEBUG_FUNCTION_NAME(_T("FComStripBuf"));

    cbLeft = cb;
    lpbOutStart = lpbOut;
    lpbLim = lpbIn + cb;

    if(fGotDLEETX)
    {
        goto MatchPost;
    }

    for( ;lpbIn<lpbLim; )
    {
        if(bPrevIn == DLE)
        {
            switch(*lpbIn++)
            {
                case DLE:       *lpbOut++ = DLE;
                                break;                          // insert single DLE
                case SUB:       *lpbOut++ = DLE;
                                *lpbOut++ = DLE;
                                break;                          // insert _two_ DLEs!
                case EffEff: // treat DLE-0xFF same as DLE-ETX. Intel gives us this
                case ETX:       goto gotDLEETX;
                // default:     break;                          // delete two
            }
            bPrevIn = 0;
        }
        else
        {
            for (CurrentSrc = lpbIn;  (CurrentSrc < lpbLim) && (*CurrentSrc != DLE); CurrentSrc++);

            if (CurrentSrc != lpbLim) 
            {
               PortbPrevIn = DLE;
            }
            PortcbSkip = (UWORD)(CurrentSrc - lpbIn);

            _fmemcpy(lpbOut, lpbIn, cbSkip);
            lpbOut += cbSkip;
            lpbIn += cbSkip+1;
        }
    }
    return (UWORD)(lpbOut-lpbOutStart);

gotDLEETX:
    // lpbIn now points to character *after* ETX
    // neither DLE nor ETX have been copied to output

    // return everything upto the last char before DLE
    // and *lpswEOF == TRUE iff the entirety of what follows
    // the DLE-ETX consists of (CR|LF)*("NO CARRIER")(CR|LF)*
    // *or* (CR|LF)*("OK")(CR|LF)*
    // else return error

    if(fClass2)
    {
        *lpcbUsed = (UWORD)(lpbIn - lpbInOrig);
        *lpswEOF = -1;  // -1==Class2 eof
        goto done;
    }

    fGotDLEETX = TRUE;
    cbPost = 0;

MatchPost:
    cbLeft = min((USHORT)(lpbLim-lpbIn), (USHORT)(POSTBUFSIZE-cbPost));
    _fmemcpy(rgbPost+cbPost, lpbIn, cbLeft);
    cbPost += cbLeft;

    DebugPrintEx(DEBUG_MSG,"GotDLEETX: cbPost=%d cbLeft=%d",cbPost,cbLeft);

    // skip CR LFs. Remember to restart from beginning of the post buffer
    for(i=0; i<cbPost && (rgbPost[i]==CR || rgbPost[i]==LF); i++);

    if(i >= cbPost)
        goto done;

    if(rgbPost[i] == 'N')
    {
        if(cbPost-i < NCsize)
        {
            goto done;
        }
        else if(_fmemcmp(rgbPost+i, cbszNOCARRIER, NCsize)==0)
        {
            i += NCsize;
            goto eof;
        }
        else
        {
            goto error;
        }
    }
    else if(rgbPost[i] == 'O')
    {
        if(cbPost-i < OKsize)
        {
            goto done;
        }
        else if(_fmemcmp(rgbPost+i, cbszOK_CRLF, OKsize)==0)
        {
            i += OKsize;
            goto eof;
        }
        else
        {
            goto error;
        }
    }
    else
    {
        goto error;
    }

eof:
    // skip any trailing CR/LFs
    for( ; i<cbPost && (rgbPost[i]==CR || rgbPost[i]==LF); i++)
            ;
    if(i == cbPost)
    {
        *lpswEOF = 1;
        goto done;
    }
    // else drop thru to error

error:
    *lpswEOF = -1;
    // goto done;
    fGotDLEETX = 0;         // reset this or we get 'stuck' in this state!

done:
    DebugPrintEx(   DEBUG_MSG,
                    "GotDLEETX exit: swEOF=%d uRet=%d", 
                    *lpswEOF, 
                    lpbOut-lpbOutStart);

    return (UWORD)(lpbOut-lpbOutStart);
}
=== C:/Users/treeman/Desktop/windows nt source code\Source\Win2K3\NT\printscan\faxsrv\provider\t30\comm\fcom.c ===
/***************************************************************************
        Name      :     FCOM.C
        Comment   :     Functions for dealing with Windows Comm driver

        Revision Log
        Num   Date      Name     Description
        --- -------- ---------- -----------------------------------------------
***************************************************************************/
#define USE_DEBUG_CONTEXT   DEBUG_CONTEXT_T30_COMM

#include "prep.h"


#include <comdevi.h>
#include "fcomapi.h"
#include "fcomint.h"
#include "fdebug.h"


///RSL
#include "t30gl.h"
#include "glbproto.h"

#include "psslog.h"
#define FILE_ID     FILE_ID_FCOM


/***------------- Local Vars and defines ------------------***/

#define AT              "AT"
#define cr              "\r"

#define  iSyncModemDialog2(pTG, s, l, w1, w2)\
iiModemDialog(pTG, s, l, 990, TRUE, 2, TRUE, (CBPSTR)w1, (CBPSTR)w2, (CBPSTR)(NULL))


#define LONG_DEADCOMMTIMEOUT                 60000L
#define SHORT_DEADCOMMTIMEOUT                10000L

#define WAIT_FCOM_FILTER_FILLCACHE_TIMEOUT   120000
#define WAIT_FCOM_FILTER_READBUF_TIMEOUT     120000


// don't want DEADCOMMTIMEOUT to be greater than 32767, so make sure
// buf sizes are always 9000 or less. maybe OK.

// Our COMM timeout settings, used in call to SetCommTimeouts. These
// values (expect read_interval_timeout) are the default values for
// Daytona NT Beta 2, and seem to work fine..
#define READ_INTERVAL_TIMEOUT                   100
#define READ_TOTAL_TIMEOUT_MULTIPLIER           0
#define READ_TOTAL_TIMEOUT_CONSTANT             0
#define WRITE_TOTAL_TIMEOUT_MULTIPLIER          0
#define WRITE_TOTAL_TIMEOUT_CONSTANT            LONG_DEADCOMMTIMEOUT

#define         CTRL_P          0x10
#define         CTRL_Q          0x11
#define         CTRL_S          0x13



#define MYGETCOMMERROR_FAILED 117437834L



// Forward declarations
static BOOL FComFilterFillCache(PThrdGlbl pTG, UWORD cbSize, LPTO lptoRead);
static BOOL CancellPendingIO(PThrdGlbl pTG, HANDLE hComm, LPOVERLAPPED lpOverlapped, LPDWORD lpCounter);




BOOL FComDTR(PThrdGlbl pTG, BOOL fEnable)
{
    DEBUG_FUNCTION_NAME(_T("FComDTR"));

    DebugPrintEx(DEBUG_MSG,"FComDTR = %d", fEnable);

    if(!GetCommState(pTG->hComm, &(pTG->Comm.dcb)))
        goto error;

    DebugPrintEx(DEBUG_MSG, "Before: %02x", pTG->Comm.dcb.fDtrControl);

    pTG->Comm.dcb.fDtrControl = (fEnable ? DTR_CONTROL_ENABLE : DTR_CONTROL_DISABLE);

    if(!SetCommState(pTG->hComm, &(pTG->Comm.dcb)))
        goto error;

    DebugPrintEx(DEBUG_MSG,"After: %02x", pTG->Comm.dcb.fDtrControl);

    return TRUE;

error:
    DebugPrintEx(DEBUG_ERR, "Can't Set/Get DCB");
    GetCommErrorNT(pTG);
    return FALSE;
}

BOOL FComClose(PThrdGlbl pTG)
{
    BOOL fRet = TRUE;

    DEBUG_FUNCTION_NAME(_T("FComClose"));

    DebugPrintEx(   DEBUG_MSG, "Closing Comm pTG->hComm=%d", pTG->hComm);
    //
    // handoff
    //
    if (pTG->Comm.fEnableHandoff &&  pTG->Comm.fDataCall) 
    {
        if (pTG->hComm)
        {
    		if (!CloseHandle(pTG->hComm))
    		{
                DebugPrintEx(   DEBUG_ERR,
                                "Close Handle pTG->hComm failed (ec=%d)",
                                GetLastError());
    		}
    		else
    		{
    		    pTG->hComm = NULL;
    		}
        }
        goto lEnd;
    }

    // We flush our internal buffer here...
    if (pTG->Comm.lpovrCur)
    {
        int nNumWrote; // Must be 32bits in WIN32
        if (!ov_write(pTG, pTG->Comm.lpovrCur, &nNumWrote))
        {
            // error...
            DebugPrintEx(DEBUG_ERR, "1st ov_write failed");
        }
        pTG->Comm.lpovrCur=NULL;
        DebugPrintEx(DEBUG_MSG,"done writing mybuf.");
    }
    
    ov_drain(pTG, FALSE);

    {
        // Here we will restore settings to what it was when we
        // took over the port. Currently (9/23/94) we (a) restore the
        // DCB to pTG->Comm.dcbOrig and (b) If DTR was originally ON,
        // try to sync the modem to
        // the original speed by issueing "AT" -- because unimodem does
        // only a half-hearted attempt at synching before giving up.

        if(pTG->Comm.fStateChanged && (!pTG->Comm.fEnableHandoff || !pTG->Comm.fDataCall))
        {
            if (!SetCommState(pTG->hComm, &(pTG->Comm.dcbOrig)))
            {
                DebugPrintEx(   DEBUG_WRN,
                                "Couldn't restore state.  Err=0x%lx",
                                (unsigned long) GetLastError());
            }

            DebugPrintEx(   DEBUG_MSG, 
                            "restored DCB to Baud=%d, fOutxCtsFlow=%d, "
                            " fDtrControl=%d, fOutX=%d",
                            pTG->Comm.dcbOrig.BaudRate,
                            pTG->Comm.dcbOrig.fOutxCtsFlow,
                            pTG->Comm.dcbOrig.fDtrControl,
                            pTG->Comm.dcbOrig.fOutX);

            pTG->CurrentSerialSpeed = (UWORD) pTG->Comm.dcbOrig.BaudRate;

            if (pTG->Comm.dcbOrig.fDtrControl==DTR_CONTROL_ENABLE)
            {
                // Try to pre-sync modem at new speed before we hand
                // it back to TAPI. Can't call iiSyncModemDialog here because
                // it's defined at a higher level. We don't really care
                // to determine if we get an OK response anyway...
                if (!iSyncModemDialog2(pTG, AT cr,sizeof(AT cr)-1,"OK", "0")) 
                {
                    DebugPrintEx(DEBUG_ERR,"couldn't sync AT command");
                }
                else 
                {
                    DebugPrintEx(DEBUG_MSG,"Sync AT command OK");
                   // We flush our internal buffer here...
                   if (pTG->Comm.lpovrCur)
                   {
                       int nNumWrote; // Must be 32bits in WIN32
                       if (!ov_write(pTG, pTG->Comm.lpovrCur, &nNumWrote))
                       {
                            // error...
                            DebugPrintEx(DEBUG_ERR, "2nd ov_write failed");
                       }
                       pTG->Comm.lpovrCur=NULL;
                       DebugPrintEx(DEBUG_MSG,"done writing mybuf.");
                   }
                   ov_drain(pTG, FALSE);
                }
            }
        }
        pTG->Comm.fStateChanged=FALSE;
        pTG->Comm.fDataCall=FALSE;

    }

    if (pTG->hComm)
    {
        DebugPrintEx(DEBUG_MSG,"Closing Comm pTG->hComm=%d.", pTG->hComm);

		if (!CloseHandle(pTG->hComm))
		{
            DebugPrintEx(   DEBUG_ERR,
                            "Close Handle pTG->hComm failed (ec=%d)",
                            GetLastError());
            GetCommErrorNT(pTG);
            fRet=FALSE;
        }
		else
		{
		    pTG->hComm = NULL;
		}
    }


lEnd:

    if (pTG->Comm.ovAux.hEvent) CloseHandle(pTG->Comm.ovAux.hEvent);
    _fmemset(&pTG->Comm.ovAux, 0, sizeof(pTG->Comm.ovAux));
    ov_deinit(pTG);

    pTG->Comm.fCommOpen = FALSE;

    pTG->Comm.fDoOverlapped=FALSE;

    return fRet;
}

/////////////////////////////////////////////////////////////////////////////////////////////
BOOL
T30ComInit  
(
    PThrdGlbl pTG
)
{

    DEBUG_FUNCTION_NAME(("T30ComInit"));

    if (pTG->fCommInitialized) 
    {
        goto lSecondInit;
    }

    pTG->Comm.fDataCall=FALSE;

    DebugPrintEx(DEBUG_MSG,"Opening Comm Port=%x", pTG->hComm);

    pTG->CommCache.dwMaxSize = 4096;

    ClearCommCache(pTG);
    pTG->CommCache.fReuse = 0;

    DebugPrintEx(   DEBUG_MSG,
                    "OPENCOMM: bufs in=%d out=%d", 
                    COM_INBUFSIZE, 
                    COM_OUTBUFSIZE);

    if (BAD_HANDLE(pTG->hComm))
    {
        DebugPrintEx(DEBUG_ERR,"OPENCOMM failed. nRet=%d", pTG->hComm);
        goto error2;
    }

    DebugPrintEx(DEBUG_MSG,"OPENCOMM succeeded hComm=%d", pTG->hComm);
    pTG->Comm.fCommOpen = TRUE;
    pTG->Comm.cbInSize = COM_INBUFSIZE;
    pTG->Comm.cbOutSize = COM_OUTBUFSIZE;

    // Reset Comm timeouts...
    {
        COMMTIMEOUTS cto;
        _fmemset(&cto, 0, sizeof(cto));

        // Out of curiosity, see what they are set at currently...
        if (!GetCommTimeouts(pTG->hComm, &cto))
        {
            DebugPrintEx(   DEBUG_WRN, 
                            "GetCommTimeouts fails for handle=0x%lx",
                            pTG->hComm);
        }
        else
        {
            DebugPrintEx(   DEBUG_MSG, 
                            "GetCommTimeouts: cto={%lu, %lu, %lu, %lu, %lu}",
                            (unsigned long) cto.ReadIntervalTimeout,
                            (unsigned long) cto.ReadTotalTimeoutMultiplier,
                            (unsigned long) cto.ReadTotalTimeoutConstant,
                            (unsigned long) cto.WriteTotalTimeoutMultiplier,
                            (unsigned long) cto.WriteTotalTimeoutConstant);
        }

        cto.ReadIntervalTimeout =  READ_INTERVAL_TIMEOUT;
        cto.ReadTotalTimeoutMultiplier =  READ_TOTAL_TIMEOUT_MULTIPLIER;
        cto.ReadTotalTimeoutConstant =  READ_TOTAL_TIMEOUT_CONSTANT;
        cto.WriteTotalTimeoutMultiplier =  WRITE_TOTAL_TIMEOUT_MULTIPLIER;
        cto.WriteTotalTimeoutConstant =  WRITE_TOTAL_TIMEOUT_CONSTANT;
        if (!SetCommTimeouts(pTG->hComm, &cto))
        {
            DebugPrintEx(   DEBUG_WRN, 
                            "SetCommTimeouts fails for handle=0x%lx",
                            pTG->hComm);
        }
    }

    pTG->Comm.fCommOpen = TRUE;

    pTG->Comm.cbInSize = COM_INBUFSIZE;
    pTG->Comm.cbOutSize = COM_OUTBUFSIZE;

    _fmemset(&(pTG->Comm.comstat), 0, sizeof(COMSTAT));

    if(!GetCommState(pTG->hComm, &(pTG->Comm.dcb)))
            goto error2;

    pTG->Comm.dcbOrig = pTG->Comm.dcb; // structure copy.
    pTG->Comm.fStateChanged=TRUE;


lSecondInit:


    // Use of 2400/ 8N1 and 19200 8N1 is not actually specified
    // in Class1, but seems to be adhered to be universal convention
    // watch out for modems that break this!

    if (pTG->SerialSpeedInit) 
    {
       pTG->Comm.dcb.BaudRate = pTG->SerialSpeedInit;
    }
    else 
    {
       pTG->Comm.dcb.BaudRate = 57600;     // default              
    }

    pTG->CurrentSerialSpeed = (UWORD) pTG->Comm.dcb.BaudRate;

    pTG->Comm.dcb.ByteSize       = 8;
    pTG->Comm.dcb.Parity         = NOPARITY;
    pTG->Comm.dcb.StopBits       = ONESTOPBIT;

    pTG->Comm.dcb.fBinary        = 1;
    pTG->Comm.dcb.fParity        = 0;

    /************************************
        Pins assignments, & Usage

        Protective Gnd                             --              1
        Transmit TxD (DTE to DCE)                  3               2
        Recv     RxD (DCE to DTE)                  2               3
        RTS (Recv Ready--DTE to DCE)               7               4
        CTS (TransReady--DCE to DTE)               8               5
        DSR                      (DCE to DTE)      6               6
        signal ground                              5               7
        CD                       (DCE to DTR)      1               8
        DTR                      (DTE to DCE)      4               20
        RI                       (DCE to DTE)      9               22

        Many 9-pin adaptors & cables use only 6 pins, 2,3,4,5, and 7.
        We need to worry about this because some modems actively
        use CTS, ie. pin 8.
        We don't care about RI and CD (Unless a really weird modem
        uses CD for flow control). We ignore DSR, but some (not so
        weird, but not so common either) modems use DSR for flow
        control.

        Thought :: Doesn't generate DSR. Seems to tie CD and CTS together
        DOVE    :: Generates only CTS. But the Appletalk-9pin cable
                   only passes 1-5 and pin 8.
        GVC     :: CTS, DSR and CD
    ************************************/

            // CTS -- dunno. There is some evidence that the
            // modem actually uses it for flow control
    
    
    if (pTG->fEnableHardwareFlowControl) 
    {
       pTG->Comm.dcb.fOutxCtsFlow = 1;      // Using it hangs the output sometimes...
    }
    else 
    {
       pTG->Comm.dcb.fOutxCtsFlow = 0;
    }
                                         // Try ignoring it and see if it works?
    pTG->Comm.dcb.fOutxDsrFlow   = 0;      // Never use this??
    pTG->Comm.dcb.fRtsControl    = RTS_CONTROL_ENABLE;   // Current code seems to leave this ON
    pTG->Comm.dcb.fDtrControl    = DTR_CONTROL_DISABLE;
    pTG->Comm.dcb.fErrorChar     = 0;
    pTG->Comm.dcb.ErrorChar      = 0;
    // Can't change this cause SetCommState() resets hardware.
    pTG->Comm.dcb.EvtChar        = ETX;          // set this when we set an EventWait
    pTG->Comm.dcb.fOutX          = 0;    // Has to be OFF during HDLC recv phase
    pTG->Comm.dcb.fInX           = 0;    // Will this do any good??
                                         // Using flow-control on input is only a good
                                         // idea if the modem has a largish buffer
    pTG->Comm.dcb.fNull          = 0;
    pTG->Comm.dcb.XonChar        = CTRL_Q;
    pTG->Comm.dcb.XoffChar       = CTRL_S;
    pTG->Comm.dcb.XonLim         = 100;                  // Need to set this when BufSize is set
    pTG->Comm.dcb.XoffLim        = 50;                   // Set this when BufSize is set
            // actually we *never* use XON/XOFF in recv, so don't worry about this
            // right now. (Later, when we have smart modems with large buffers, &
            // we are worried about our ISR buffer filling up before our windows
            // process gets run, we can use this). Some tuning will be reqd.
    pTG->Comm.dcb.EofChar        = 0;
    pTG->Comm.dcb.fAbortOnError  = 0;   // RSL don't fail if minor problems

    if(!SetCommState(pTG->hComm, &(pTG->Comm.dcb)))
        goto error2;

    if (pTG->fCommInitialized) 
    {
       return TRUE;
    }

    pTG->Comm.fStateChanged=TRUE;

    if (!SetCommMask(pTG->hComm, 0))                            // all events off
	{
        DebugPrintEx(DEBUG_ERR, "SetCommMask failed (ec=%d)",GetLastError());
	}

    pTG->Comm.lpovrCur=NULL;

    _fmemset(&pTG->Comm.ovAux,0, sizeof(pTG->Comm.ovAux));
    pTG->Comm.ovAux.hEvent = CreateEvent(NULL, TRUE, FALSE, NULL);
    if (pTG->Comm.ovAux.hEvent==NULL)
    {
        DebugPrintEx(DEBUG_ERR, "FComOpen: couldn't create event");
        goto error2;
    }
    if (!ov_init(pTG))
    {
        CloseHandle(pTG->Comm.ovAux.hEvent);
        pTG->Comm.ovAux.hEvent=0;
        goto error2;
    }

    return TRUE;

error2:

    DebugPrintEx(DEBUG_ERR, "FComOpen failed");
    GetCommErrorNT(pTG);
    if (pTG->Comm.fCommOpen)
    {
        FComClose(pTG);
    }
    return FALSE;
}

BOOL FComSetBaudRate(PThrdGlbl pTG, UWORD uwBaudRate)
{
    DEBUG_FUNCTION_NAME(("FComSetBaudRate"));

    DebugPrintEx(DEBUG_MSG,"Setting BAUDRATE=%d",uwBaudRate);

    if(!GetCommState( pTG->hComm, &(pTG->Comm.dcb)))
        goto error;

    pTG->Comm.dcb.BaudRate  = uwBaudRate;
    pTG->CurrentSerialSpeed = uwBaudRate;

    if(!SetCommState( pTG->hComm, &(pTG->Comm.dcb)))
        goto error;

    return TRUE;

error:
    DebugPrintEx(DEBUG_ERR, "Set Baud Rate --- Can't Get/Set DCB");
    GetCommErrorNT(pTG);
    return FALSE;
}

BOOL FComInXOFFHold(PThrdGlbl pTG)
{
    DEBUG_FUNCTION_NAME(_T("FComInXOFFHold"));
    GetCommErrorNT(pTG);

    if(pTG->Comm.comstat.fXoffHold)
    {
        DebugPrintEx(DEBUG_MSG,"In XOFF hold");
        return TRUE;
    }
    else
    {
        return FALSE;
    }
}

BOOL FComXon(PThrdGlbl pTG, BOOL fEnable)
{

    DEBUG_FUNCTION_NAME(_T("FComXon"));

     if (pTG->fEnableHardwareFlowControl) 
     {
        DebugPrintEx(   DEBUG_MSG, 
                        "FComXon = %d IGNORED : h/w flow control", 
                        fEnable);
        return TRUE;
     }

    DebugPrintEx(DEBUG_MSG,"FComXon = %d",fEnable);

    // enables/disables flow control
    // returns TRUE on success, false on failure

    if(!GetCommState( pTG->hComm, &(pTG->Comm.dcb)))
        goto error;

    DebugPrintEx(DEBUG_MSG,"FaxXon Before: %02x", pTG->Comm.dcb.fOutX);

    pTG->Comm.dcb.fOutX  = fEnable;

    if(!SetCommState(pTG->hComm, &(pTG->Comm.dcb)))
        goto error;

    DebugPrintEx(DEBUG_MSG,"After: %02x",pTG->Comm.dcb.fOutX);
    return TRUE;

error:
    DebugPrintEx(DEBUG_ERR,"Can't Set/Get DCB");
    GetCommErrorNT(pTG);
    return FALSE;
}

// queue=0 --> receiving queue
// queue=1 --> transmitting queue
void FComFlushQueue(PThrdGlbl pTG, int queue)
{
    int     nRet;
    DWORD   lRet;

    DEBUG_FUNCTION_NAME(_T("FComFlushQueue"));

    DebugPrintEx(DEBUG_MSG, "FlushQueue = %d", queue);
    if (queue == 1) 
    {
        DebugPrintEx(DEBUG_MSG,"ClearCommCache");
        ClearCommCache(pTG);
    }

	nRet = PurgeComm(pTG->hComm, (queue ? PURGE_RXCLEAR : PURGE_TXCLEAR));
    if(!nRet)
    {
        DebugPrintEx(DEBUG_ERR,"FlushComm failed (ec=%d)", GetLastError());
        GetCommErrorNT(pTG);
        // Throwing away errors that happen here.
        // No good reason for it!
    }
    if(queue == 1)
    {
        FComInFilterInit(pTG);
    }
    else // (queue == 0)
    {
        // Let's dump any stuff we may have in *our* buffer.
        if (pTG->Comm.lpovrCur && pTG->Comm.lpovrCur->dwcb)
        {
            DebugPrintEx(   DEBUG_WRN, 
                            "Clearing NonNULL pTG->Comm.lpovrCur->dwcb=%lx",
                            (unsigned long) pTG->Comm.lpovrCur->dwcb);
            pTG->Comm.lpovrCur->dwcb=0;
            ov_unget(pTG, pTG->Comm.lpovrCur);
            pTG->Comm.lpovrCur=NULL;
        }

        // Lets "drain" -- should always return immediately, because
        // we have just purged the output comm buffers.
        if (pTG->Comm.fovInited) 
        {
            DebugPrintEx(DEBUG_MSG," before ov_drain");
            ov_drain(pTG, FALSE);
            DebugPrintEx(DEBUG_MSG," after ov_drain");
        }

        // just incase it got stuck due to a mistaken XOFF
		lRet = EscapeCommFunction(pTG->hComm, SETXON);
        if(!lRet)
        {
            // Returns the comm error value CE!!
            DebugPrintEx(DEBUG_MSG,"EscapeCommFunc(SETXON) returned %d", lRet);
            GetCommErrorNT(pTG);
        }
    }
}

/***************************************************************************
        Name      :     FComDrain(BOOL fLongTO, BOOL fDrainComm)
        Purpose   :     Drain internal buffers. If fDrainComm, wait for Comm
                        ISR Output buffer to drain.
                        Returns when buffer is drained or if no progress is made
                        for DRAINTIMEOUT millisecs. (What about XOFFed sections?
                        Need to set     Drain timeout high enough)
        Parameters:
        Returns   :     TRUE on success (buffer drained)
                        FALSE on failure (error or timeout)

        Revision Log
        Num   Date      Name     Description
        --- -------- ---------- -----------------------------------------------
        101     06/03/92        arulm   Created it in a new incarnation
***************************************************************************/

// This timeout has to be low at time and high at others. We want it low
// so we don't spend too much time trying to talk to a non-existent modem
// during Init/Setup. However in PhaseC, when the timer expires all we
// do is abort and kill everything. So it serves no purpose to make it
// too low. With the Hayes ESP FIFO card long stretches can elapse without
// any visible "progress", so we fail with that card because we think
// "no progress" is being made


//    So....make it short for init/install
// but not too short. Some cmds (e.g. AT&F take a long time)
// Used to be 800ms & seemed to work then, so leave it at that
#define SHORT_DRAINTIMEOUT      800

//    So....make it long for PhaseC
// 4secs should be about long enough
#define LONG_DRAINTIMEOUT       4000

BOOL FComDrain(PThrdGlbl pTG, BOOL fLongTO, BOOL fDrainComm)
{
    WORD    wTimer = 0;
    UWORD   cbPrevOut = 0xFFFF;
    BOOL    fStuckOnce=FALSE;
    BOOL    fRet=FALSE;

    DEBUG_FUNCTION_NAME(_T("FComDrain"));

    // We flush our internal buffer here...
    if (pTG->Comm.lpovrCur)
    {
        int nNumWrote; // Must be 32bits in WIN32
        if (!ov_write(pTG, pTG->Comm.lpovrCur, &nNumWrote))
            goto done;

        pTG->Comm.lpovrCur=NULL;
        DebugPrintEx(DEBUG_MSG,"done writing mybuf.");
    }

    if (!fDrainComm)
    {
        fRet=TRUE; 
        goto done;
    }

    // +++ Here we drain all our overlapped events..
    // If we setup the system comm timeouts properly, we
    // don't need to do anything else, except for the XOFF/XON
    // stuff...
    fRet =  ov_drain(pTG, fLongTO);
    goto done;

done:

    return fRet;  //+++ was (cbOut == 0);
}

/***************************************************************************
        Name      :     FComDirectWrite(, lpb, cb)
        Purpose   :     Write cb bytes starting from lpb to pTG->Comm. If Comm buffer
                        is full, set up notifications and timers and wait until space
                        is available. Returns when all bytes have been written to
                        the Comm buffer or if no progress is made
                        for WRITETIMEOUT millisecs. (What about XOFFed sections?
                        Need to set     timeout high enough)
        Parameters:     , lpb, cb
        Returns   :     Number of bytes written, i.e. cb on success and <cb on timeout,
                                or error.

        Revision Log
        Num   Date      Name     Description
        --- -------- ---------- -----------------------------------------------
        101     06/03/92        arulm   Created it
***************************************************************************/

// This is WRONG -- see below!!
// totally arbitrary should be no more than the time as it would
// take to write WRITEQUANTUM out at the fastest speed
// (say 14400 approx 2 bytes/ms)
// #define      WRITETIMEOUT    min((WRITEQUANTUM / 2), 200)

// This timeout was too low. We wanted it low so we don't spend too much
// time trying to talk to a non-existent modem during Init/Setup. But in
// those cases we _never_ reach full buffer, so we don't wait here
// we wait in FComDrain(). Here we wait _only_ in PhaseC, so when the
// timer expires all we do is abort and kill everything. So it serves
// no purpose to make it too low. With the Hayes ESP FIFO card long
// stretches can elapse without any visible "progress", so we fail with
// that card because we think "no progress" is being made
//    So....make it long
// 2secs should be about long enough
#define         WRITETIMEOUT    2000


UWORD FComDirectWrite(PThrdGlbl pTG, LPB lpb, UWORD cb)
{
    DWORD   cbLeft = cb;

    DEBUG_FUNCTION_NAME(_T("FComDirectWrite"));

    while(cbLeft)
    {
        DWORD dwcbCopy;
        DWORD dwcbWrote;

        if (!pTG->Comm.lpovrCur)
        {
            pTG->Comm.lpovrCur = ov_get(pTG);
            if (!pTG->Comm.lpovrCur) goto error;
        }

        dwcbCopy = OVBUFSIZE-pTG->Comm.lpovrCur->dwcb;

        if (dwcbCopy>cbLeft)
		{
			dwcbCopy = cbLeft;
		}

        // Copy as much as we can to the overlapped buffer...
        _fmemcpy(pTG->Comm.lpovrCur->rgby+pTG->Comm.lpovrCur->dwcb, lpb, dwcbCopy);
        cbLeft -= dwcbCopy; 
		pTG->Comm.lpovrCur->dwcb += dwcbCopy; 
		lpb += dwcbCopy;

        // Let's always update comstat here...
        GetCommErrorNT(pTG);

        DebugPrintEx(   DEBUG_MSG,
                        "OutQ has %d fDoOverlapped=%d",
                        pTG->Comm.comstat.cbOutQue, 
                        pTG->Comm.fDoOverlapped);

        // We write to comm if our buffer is full or the comm buffer is
        // empty or if we're not in overlapped mode...
        if (	!pTG->Comm.fDoOverlapped			||
                pTG->Comm.lpovrCur->dwcb>=OVBUFSIZE || 
				!pTG->Comm.comstat.cbOutQue)
        {
            BOOL fRet = ov_write(pTG, pTG->Comm.lpovrCur, &dwcbWrote);
            pTG->Comm.lpovrCur=NULL;
            if (!fRet) 
			{
                goto error;
			}
        }

    } // while (cbLeft)

    return cb;

error:
    return 0;

}

/***************************************************************************
        Name      :     FComFilterReadLine(, lpb, cbSize, pto)
        Purpose   :     Reads upto cbSize bytes from Comm into memory starting from
                        lpb. If Comm buffer is empty, set up notifications and timers
                        and wait until characters are available.

                        Filters out DLE characters. i.e DLE-DLE is reduced to
                        a single DLE, DLE ETX is left intact and DLE-X is deleted.

                        Returns success (+ve bytes count) when CR-LF has been
                        encountered, and returns failure (-ve bytes count).
                        when either (a) cbSize bytes have been read (i.e. buffer is
                        full) or (b) PTO times out or an error is encountered.

                        It is critical that this function never returns a
                        timeout, as long as data
                        is still pouring/trickling in. This implies two things
                        (a) FIRST get all that is in the InQue (not more than a
                        line, though), THEN check the timeout.
                        (b) Ensure that at least 1 char-arrival-time at the
                        slowest Comm speed passes between the function entry
                        point and the last time we check for a byte, or between
                        two consecutive checks for a byte, before we return a timeout.

                        Therefor conditions to return a timeout are Macro timeout
                        over and inter-char timeout over.

                        In theory the slowest speed we need to worry about is 2400,
                        because that's the slowest we run the Comm at, but be paranoid
                        and assume the modem sends the chars at the same speed that
                        they come in the wire, so slowest is now 300. 1 char-arrival-time
                        is now 1000 / (300/8) == 26.67ms.

                        If pto expires, returns error, i.e. -ve of the number of
                        bytes read.

        Returns   :     Number of bytes read, i.e. cb on success and -ve of number
                        of bytes read on timeout. 0 is a timeout error with no bytes
                        read.

        Revision Log
        Num   Date      Name     Description
        --- -------- ---------- -----------------------------------------------
        101     06/03/92        arulm   Created it
***************************************************************************/

// totally arbitrary
#define         READLINETIMEOUT         50

#define         ONECHARTIME                     (30 * 2)                // see above *2 to be safe

// void WINAPI OutputDebugStr(LPSTR);
// char szJunk[200];




// Read a line of size no more than cbSize to lpb
// 
#undef USE_DEBUG_CONTEXT   
#define USE_DEBUG_CONTEXT   DEBUG_CONTEXT_T30_CLASS1

SWORD FComFilterReadLine(PThrdGlbl pTG, LPB lpb, UWORD cbSize, LPTO lptoRead)
{
    WORD           wTimer = 0;
    UWORD          cbIn = 0, cbGot = 0;
    LPB            lpbNext;
    BOOL           fPrevDLE = 0;
    SWORD          i, beg;
    TO to;
    DWORD          dwLoopCount = 0;

    DEBUG_FUNCTION_NAME(_T("FComFilterReadLine"));

    DebugPrintEx(   DEBUG_MSG, 
                    "lpb=0x%08lx cb=%d timeout=%lu", 
                    lpb, 
                    cbSize, 
                    lptoRead->ulTimeout);

    cbSize--;               // make room for terminal NULL
    lpbNext = lpb;          // we write the NULL to *lpbNext, so init this NOW!
    cbGot = 0;              // return value (even err return) is cbGot. Init NOW!!
    fPrevDLE=0;

    pTG->fLineTooLongWasIgnored = FALSE;
    //
    // check the cache first.
    // Maybe the cache contains data

    if ( ! pTG->CommCache.dwCurrentSize) 
    {
        DebugPrintEx(DEBUG_MSG,"Cache is empty. Resetting comm cache.");
        ClearCommCache(pTG);
        // Try to fill the cache
        if (!FComFilterFillCache(pTG, cbSize, lptoRead)) 
        {
            DebugPrintEx(DEBUG_ERR,"FillCache failed");
            goto error;
        }
    }

    while (1) 
    {
        if ( ! pTG->CommCache.dwCurrentSize) 
        {
            DebugPrintEx(DEBUG_ERR, "Cache is empty after FillCache");
            goto error;
        }

        DebugPrintEx(   DEBUG_MSG,
                        "Cache: size=%d, offset=%d", 
                        pTG->CommCache.dwCurrentSize, 
                        pTG->CommCache.dwOffset);

        lpbNext = pTG->CommCache.lpBuffer + pTG->CommCache.dwOffset;

        if (pTG->CommCache.dwCurrentSize >= 3) 
        {
            DebugPrintEx(   DEBUG_MSG, 
                            "0=%x 1=%x 2=%x 3=%x 4=%x 5=%x 6=%x 7=%x 8=%x /"
                            " %d=%x, %d=%x, %d=%x",
                            *lpbNext, 
                            *(lpbNext+1), 
                            *(lpbNext+2), 
                            *(lpbNext+3), 
                            *(lpbNext+4), 
                            *(lpbNext+5), 
                            *(lpbNext+6), 
                            *(lpbNext+7), 
                            *(lpbNext+8),
                            pTG->CommCache.dwCurrentSize-3, 
                            *(lpbNext+ pTG->CommCache.dwCurrentSize-3),
                            pTG->CommCache.dwCurrentSize-2, 
                            *(lpbNext+ pTG->CommCache.dwCurrentSize-2),
                            pTG->CommCache.dwCurrentSize-1,
                            *(lpbNext+ pTG->CommCache.dwCurrentSize-1) );
        }
        else 
        {
            DebugPrintEx(DEBUG_MSG,"1=%x 2=%x", *lpbNext, *(lpbNext+1) );
        }

        for (i=0, beg=0; i< (SWORD) pTG->CommCache.dwCurrentSize; i++) 
        {
            if (i > 0 ) 
            { // check from the second char in the buffer for CR + LF.
               if ( ( *(pTG->CommCache.lpBuffer + pTG->CommCache.dwOffset + i - 1) == CR ) &&
                    ( *(pTG->CommCache.lpBuffer + pTG->CommCache.dwOffset + i)     == LF ) )  
               {
                  if ( i - beg >= cbSize)  
                  {
                     // line too long.  try next one.
                     DebugPrintEx(  DEBUG_ERR, 
                                    "Line len=%d is longer than bufsize=%d "
                                    " Found in cache pos=%d, CacheSize=%d, Offset=%d",
                                    i-beg, 
                                    cbSize, 
                                    i+1, 
                                    pTG->CommCache.dwCurrentSize, 
                                    pTG->CommCache.dwOffset);
                     beg = i + 1;
                     pTG->fLineTooLongWasIgnored = TRUE;
                     continue;
                  }

                  // found the line.
                  CopyMemory (lpb, (pTG->CommCache.lpBuffer + pTG->CommCache.dwOffset + beg), (i - beg + 1) );

                  pTG->CommCache.dwOffset += (i+1);
                  pTG->CommCache.dwCurrentSize -= (i+1);
                  *(lpb+i-beg+1) = '\0'; // Make sure that the line is null terminated

                  DebugPrintEx( DEBUG_MSG, 
                                "Found in cache pos=%d, CacheSize=%d, Offset=%d",
                                i+1, 
                                pTG->CommCache.dwCurrentSize, 
                                pTG->CommCache.dwOffset);

                  // return how much bytes in the line
                  return ( i-beg+1 );
               }
           }
        }

        // we get here if we didn't find CrLf in Cache
        DebugPrintEx(DEBUG_MSG,"Cache wasn't empty but we didn't find CrLf");

        // if cache too big (and we have not found anything anyway) --> clean it

        if (pTG->CommCache.dwCurrentSize >= cbSize) 
        {
           DebugPrintEx(DEBUG_MSG, "ClearCommCache");
           ClearCommCache(pTG);
        }
        else if ( ! pTG->CommCache.dwCurrentSize) 
        {
           DebugPrintEx(DEBUG_MSG,"Cache is empty. Resetting comm cache.");
           ClearCommCache(pTG);
        }

        // If the modem returned part of a line, the rest of the line should already be
        // in the serial buffer. In this case, read again with a short timeout (500ms).
        // However, some modems can get into a state where they give random data forever.
        // So... give the modem only one "second chance".
        if (dwLoopCount && (!checkTimeOut(pTG, lptoRead)))
        {
           DebugPrintEx(DEBUG_ERR,"Total Timeout passed");
           goto error; 
        }
        dwLoopCount++;
        
        to.ulStart = 0;
        to.ulTimeout = 0;
        to.ulEnd = 500;
        if ( ! FComFilterFillCache(pTG, cbSize, &to/*lptoRead*/) ) 
        {
            DebugPrintEx(DEBUG_ERR, "FillCache failed");
            goto error;
        }
    }

error:
    ClearCommCache(pTG);
    return (0);

}


// Read from the comm port.
// The input is written to 'the end' of pTG->CommCache.lpBuffer buffer.
// returns TRUE on success, FALSE - otherwise.
BOOL  FComFilterFillCache(PThrdGlbl pTG, UWORD cbSize, LPTO lptoRead)
{
    WORD             wTimer = 0;
    UWORD            cbGot = 0, cbAvail = 0;
    DWORD            cbRequested = 0;
    char             lpBuffer[4096]; // ATTENTION: We do overlapped read into the stack!!
    LPB              lpbNext;
    int              nNumRead;       // _must_ be 32 bits in Win32!!
    LPOVERLAPPED     lpOverlapped;
    COMMTIMEOUTS     cto;
    DWORD            dwLastErr;

    DWORD            dwTimeoutRead;
    DWORD            dwTimeoutOrig;
    DWORD            dwTickCountOrig;

    char             *pSrc;
    char             *pDest;
    DWORD            i, j;
    DWORD            dwErr;
    COMSTAT          ErrStat;
    DWORD            NumHandles=2;
    HANDLE           HandlesArray[2];
    DWORD            WaitResult;

    DEBUG_FUNCTION_NAME(_T("FComFilterFillCache"));

    HandlesArray[1] = pTG->AbortReqEvent;

    dwTickCountOrig = GetTickCount();
    dwTimeoutOrig = (DWORD) (lptoRead->ulEnd - lptoRead->ulStart);
    dwTimeoutRead = dwTimeoutOrig;

    lpbNext = lpBuffer;
    
    DebugPrintEx(   DEBUG_MSG, 
                    "cb=%d to=%d",
                    cbSize, 
                    dwTimeoutRead);

    // we want to request the read such that we will be back
    // no much later than dwTimeOut either with the requested
    // amount of data or without it.
    cbRequested = cbSize;

    do
    {
        // use COMMTIMEOUTS to detect there are no more data
        cto.ReadIntervalTimeout =  50;   // 30 ms is during negotiation frames; del(ff, 2ndchar> = 54 ms with USR 28.8
        cto.ReadTotalTimeoutMultiplier =  0;
        cto.ReadTotalTimeoutConstant =  dwTimeoutRead;  // RSL may want to set first time ONLY*/
        cto.WriteTotalTimeoutMultiplier =  WRITE_TOTAL_TIMEOUT_MULTIPLIER;
        cto.WriteTotalTimeoutConstant =  WRITE_TOTAL_TIMEOUT_CONSTANT;
        if (!SetCommTimeouts(pTG->hComm, &cto)) 
        {
            DebugPrintEx(   DEBUG_ERR, 
                            "SetCommTimeouts fails for handle %lx , le=%x",
                            pTG->hComm, 
                            GetLastError());
        }

        lpOverlapped =  &pTG->Comm.ovAux;

        (lpOverlapped)->Internal = 0;
		(lpOverlapped)->InternalHigh = 0;
		(lpOverlapped)->Offset = 0;
		(lpOverlapped)->OffsetHigh = 0;

        if ((lpOverlapped)->hEvent)
        {
            if (!ResetEvent((lpOverlapped)->hEvent))
            {
				DebugPrintEx(   DEBUG_ERR,
								"ResetEvent failed (ec=%d)", 
								GetLastError());
            }
        }
        
        nNumRead = 0;
        DebugPrintEx(   DEBUG_MSG,
                        "Before ReadFile Req=%d", 
                        cbRequested);

        if (! ReadFile( pTG->hComm, lpbNext, cbRequested, &nNumRead, lpOverlapped) ) 
        {
            if ( (dwLastErr = GetLastError() ) == ERROR_IO_PENDING) 
            {
                //
                // We want to be able to un-block ONCE only from waiting on I/O when the AbortReqEvent is signaled.
                //
                if (pTG->fAbortRequested) 
                {
                    if (pTG->fOkToResetAbortReqEvent && (!pTG->fAbortReqEventWasReset)) 
                    {
                        DebugPrintEx(DEBUG_MSG,"RESETTING AbortReqEvent");
                        pTG->fAbortReqEventWasReset = TRUE;
                        if (!ResetEvent(pTG->AbortReqEvent))
                        {
							DebugPrintEx(   DEBUG_ERR,
											"ResetEvent failed (ec=%d)", 
											GetLastError());
                        }
                    }
                    pTG->fUnblockIO = TRUE;
                }

                HandlesArray[0] = pTG->Comm.ovAux.hEvent;
                // Remeber that: HandlesArray[1] = pTG->AbortReqEvent;
                if (pTG->fUnblockIO) 
                {
                    NumHandles = 1; // We don't want to be disturb by an abort
                }
                else 
                {
                    NumHandles = 2;
                }

                if (pTG->fStallAbortRequest)
                {
                    // this is used to complete a whole IO operation (presumably a short one)
                    // when this flag is set, the IO won't be disturbed by the abort event
                    // this flag should NOT be set for long periods of time since abort
                    // is disabled while it is set.
                    DebugPrintEx(DEBUG_MSG,"StallAbortRequest, do not abort here...");
                    NumHandles = 1; // We don't want to be disturb by an abort
                    pTG->fStallAbortRequest = FALSE;
                }

                DebugPrintEx(DEBUG_MSG,"Waiting for %d Event(s)",NumHandles);
                WaitResult = WaitForMultipleObjects(NumHandles, HandlesArray, FALSE, WAIT_FCOM_FILTER_FILLCACHE_TIMEOUT);
                DebugPrintEx(DEBUG_MSG,"WaitForMultipleObjects returned %d",WaitResult);

                if (WaitResult == WAIT_TIMEOUT) 
                {
                    DebugPrintEx(DEBUG_ERR, "WaitForMultipleObjects TIMEOUT");
                    goto error;
                }

                if (WaitResult == WAIT_FAILED) 
                {
                    DebugPrintEx(   DEBUG_ERR, 
                                    "WaitForMultipleObjects FAILED le=%lx NumHandles=%d",
                                    GetLastError(), 
                                    NumHandles);
                    goto error;
                }

                if ( (NumHandles == 2) && (WaitResult == WAIT_OBJECT_0 + 1) ) 
                {
                    // There was an abort by the user and that there are still pending reads
                    // Lets cancell the pending I/O operations, and then wait for the overlapped results  
                    pTG->fUnblockIO = TRUE;
                    DebugPrintEx(DEBUG_MSG,"ABORTed");
                    goto error;
                }

                // The IO operation was complete. Lets try to get the overlapped result.
                if ( ! GetOverlappedResult ( pTG->hComm, lpOverlapped, &nNumRead, TRUE) ) 
                {
                    DebugPrintEx(DEBUG_ERR, "GetOverlappedResult le=%x", GetLastError());
                    if (! ClearCommError( pTG->hComm, &dwErr, &ErrStat) ) 
                    {
                        DebugPrintEx(DEBUG_ERR, "ClearCommError le=%x", GetLastError());
                    }
                    else 
                    {
                        DebugPrintEx(   DEBUG_ERR, 
                                        "ClearCommError dwErr=%x ErrSTAT: Cts=%d Dsr=%d "
                                        " Rls=%d XoffHold=%d XoffSent=%d fEof=%d Txim=%d "
                                        " In=%d Out=%d",
                                        dwErr, 
                                        ErrStat.fCtsHold, 
                                        ErrStat.fDsrHold, 
                                        ErrStat.fRlsdHold, 
                                        ErrStat.fXoffHold, 
                                        ErrStat.fXoffSent, 
                                        ErrStat.fEof,
                                        ErrStat.fTxim, 
                                        ErrStat.cbInQue, 
                                        ErrStat.cbOutQue);
                    }
                    goto errorWithoutCancel;
                }
            }
            else 
            {
                DebugPrintEx(DEBUG_ERR, "ReadFile");
                // We will do cancell pending IO, should we?
                goto errorWithoutCancel;
            }
        }
        else 
        {
            DebugPrintEx(DEBUG_WRN,"ReadFile returned w/o WAIT");
        }

        DebugPrintEx(   DEBUG_MSG,
                        "After ReadFile Req=%d Ret=%d",
                        cbRequested, 
                        nNumRead);

        // How much bytes we actually have read
        cbAvail = (UWORD)nNumRead;

        if (!cbAvail) 
        {
            // With USB modems, ReadFile sometimes returns after 60ms with 0 bytes
            // read regardless of supplied timeout. So, if we got 0 bytes, check
            // whether timeout has passed, and if not - issue another ReadFile.
            DWORD dwTimePassed = GetTickCount() - dwTickCountOrig;

            // Allow for 20ms inaccuracy in TickCount
            if (dwTimePassed+20 >= dwTimeoutOrig)
            {
                DebugPrintEx(DEBUG_ERR, "0 read, to=%d, passed=%d", dwTimeoutOrig, dwTimePassed);
                goto errorWithoutCancel;
            }

            dwTimeoutRead = dwTimeoutOrig - dwTimePassed;
            DebugPrintEx(	DEBUG_WRN, 
							"0 read, to=%d, passed=%d, re-reading with to=%d",
							dwTimeoutOrig, 
							dwTimePassed, 
							dwTimeoutRead);
        }
       
    } while (cbAvail==0);

    // filter DLE stuff 

    pSrc  = lpbNext;
    pDest = pTG->CommCache.lpBuffer + pTG->CommCache.dwOffset+ pTG->CommCache.dwCurrentSize;

    for (i=0, j=0; i<cbAvail; ) 
    {
        if ( *(pSrc+i) == DLE)  
        {
            if ( *(pSrc+i+1) == DLE ) 
            {
                *(pDest+j) =    DLE;
                j += 1;
                i += 2;
            }
            else if ( *(pSrc+i+1) == ETX ) 
            {
                *(pDest+j) = DLE;
                *(pDest+j+1) = ETX;
                j += 2;
                i += 2;
            }
            else 
            {
                i += 2;
            }
        }
        else
        {
            *(pDest+j) = *(pSrc+i);
            i++;
            j++;
        }
    }

    pTG->CommCache.dwCurrentSize += j;
    return TRUE;

error:
    
    if (!CancellPendingIO(pTG , pTG->hComm , lpOverlapped , (LPDWORD) &nNumRead))
    {
        DebugPrintEx(DEBUG_ERR, "failed when call to CancellPendingIO");
    }

errorWithoutCancel:
    
    return FALSE;
}

/***************************************************************************
        Name      :     FComDirectReadBuf(, lpb, cbSize, lpto, pfEOF)
        Purpose   :     Reads upto cbSize bytes from Comm into memory starting from
                        lpb. If Comm buffer is empty, set up notifications and timers
                        and wait until characters are available.

                        Returns when success (+ve byte count) either (a) cbSize
                        bytes have been read or (b) DLE-ETX has been encountered
                        (in which case *pfEOF is set to TRUE).

                        Does no filtering. Reads the Comm buffer in large quanta.

                        If lpto expires, returns error, i.e. -ve of the number of
                        bytes read.

        Returns   :     Number of bytes read, i.e. cb on success and -ve of number
                        of bytes read on timeout. 0 is a timeout error with no bytes
                        read.

        Revision Log
        Num   Date      Name     Description
        --- -------- ---------- -----------------------------------------------
        101     06/03/92        arulm   Created it
***************************************************************************/

// +++ #define          READBUFQUANTUM          (pTG->Comm.cbInSize / 8)
// totally arbitrary
// +++ #define  READBUFTIMEOUT                  200

// *lpswEOF is 1 on Class1 EOF, 0 on non-EOF, -1 on Class2 EOF, -2 on error -3 on timeout

UWORD FComFilterReadBuf
(
    PThrdGlbl pTG, 
    LPB lpb, 
    UWORD cbSize, 
    LPTO lptoRead, 
    BOOL fClass2, 
    LPSWORD lpswEOF
)
{
    WORD             wTimer = 0;
    UWORD            cbGot = 0, cbAvail = 0;
    UWORD            cbUsed = 0;
    DWORD            cbRequested = 0;
    LPB              lpbNext;
    int              nNumRead = 0;       // _must_ be 32 bits in Win32!!
    LPOVERLAPPED     lpOverlapped;
    COMMTIMEOUTS     cto;
    DWORD            dwLastErr;
    DWORD            dwTimeoutRead;
    DWORD            cbFromCache = 0;
    DWORD            dwErr;
    COMSTAT          ErrStat;
    DWORD            NumHandles=2;
    HANDLE           HandlesArray[2];
    DWORD            WaitResult;

    DEBUG_FUNCTION_NAME(_T("FComFilterReadBuf"));
    HandlesArray[1] = pTG->AbortReqEvent;


    dwTimeoutRead = (DWORD) (lptoRead->ulEnd - lptoRead->ulStart);

    DebugPrintEx(   DEBUG_MSG, 
                    "lpb=0x%08lx cbSize=%d to=%d",
                    lpb, 
                    cbSize, 
                    dwTimeoutRead);

    // Dont want to take ^Q/^S from modem to
    // be XON/XOFF in the receive data phase!!

    *lpswEOF=0;

    // Leave TWO spaces at start to make sure Out pointer will
    // never get ahead of the In pointer in StripBuf, even
    // if the last byte of prev block was DLE & first byte
    // of this one is SUB (i.e need to insert two DLEs in
    // output).
    // Save a byte at end for the NULL terminator (Why? Dunno...)

    lpb += 2;
    cbSize -= 3;

    cbRequested = cbSize;

    for(lpbNext=lpb;;) 
    {
        DebugPrintEx(   DEBUG_MSG,
                        "cbSize=%d cbGot=%d cbAvail=%d",
                        cbSize, 
                        cbGot, 
                        cbAvail);

        if((cbSize - cbGot) < cbAvail) 
        {
             cbAvail = cbSize - cbGot;
        }

        if( (!cbGot) && !checkTimeOut(pTG, lptoRead) ) 
        {
            // No chars available *and* lptoRead expired
            DebugPrintEx(   DEBUG_ERR, 
                            "ReadLn:Timeout %ld-toRd=%ld start=%ld",
                            GetTickCount(), 
                            lptoRead->ulTimeout, 
                            lptoRead->ulStart);
            *lpswEOF = -3;
            goto done;
        }

        // check Comm cache first (AT+FRH leftovers)
        if ( pTG->CommCache.fReuse && pTG->CommCache.dwCurrentSize ) 
        {
            DebugPrintEx(   DEBUG_MSG, 
                            "CommCache will REUSE %d offset=%d 0=%x 1=%x",
                            pTG->CommCache.dwCurrentSize, 
                            pTG->CommCache.dwOffset,
                            *(pTG->CommCache.lpBuffer + pTG->CommCache.dwOffset),
                            *(pTG->CommCache.lpBuffer + pTG->CommCache.dwOffset+1) );

            if ( pTG->CommCache.dwCurrentSize >= cbRequested)  
            {
                CopyMemory (lpbNext, pTG->CommCache.lpBuffer + pTG->CommCache.dwOffset, cbRequested);

                pTG->CommCache.dwOffset +=  cbRequested;
                pTG->CommCache.dwCurrentSize -=  cbRequested;

                cbAvail =  (UWORD) cbRequested;
                cbRequested = 0;

                DebugPrintEx(DEBUG_MSG,"CommCache still left; no need to read");
                goto l_merge;
            }
            else 
            {
                cbFromCache =  pTG->CommCache.dwCurrentSize;
                CopyMemory (lpbNext, pTG->CommCache.lpBuffer + pTG->CommCache.dwOffset, cbFromCache);
                ClearCommCache(pTG);
                cbRequested -= cbFromCache;
                DebugPrintEx(DEBUG_MSG,"CommCache used all %d",cbFromCache);
            }
        }

        // use COMMTIMEOUTS to detect there are no more data

        cto.ReadIntervalTimeout =  20;  // 0  RSL make 15 later
        cto.ReadTotalTimeoutMultiplier =  0;
        cto.ReadTotalTimeoutConstant =  dwTimeoutRead;  // RSL may want to set first time ONLY
        cto.WriteTotalTimeoutMultiplier =  WRITE_TOTAL_TIMEOUT_MULTIPLIER;
        cto.WriteTotalTimeoutConstant =  WRITE_TOTAL_TIMEOUT_CONSTANT;
        if (!SetCommTimeouts(pTG->hComm, &cto)) 
        {
            DebugPrintEx(   DEBUG_ERR, 
                            "SetCommTimeouts fails for handle %lx , le=%x",
                            pTG->hComm, 
                            GetLastError());
        }

        lpOverlapped =  &pTG->Comm.ovAux;

        (lpOverlapped)->Internal = (lpOverlapped)->InternalHigh = (lpOverlapped)->Offset = \
                            (lpOverlapped)->OffsetHigh = 0;

        if ((lpOverlapped)->hEvent)
        {
            if(!ResetEvent((lpOverlapped)->hEvent))
            {
				DebugPrintEx(   DEBUG_ERR,
								"ResetEvent failed (ec=%d)", 
								GetLastError());
            }
        }

        nNumRead = 0;
        
        DebugPrintEx(DEBUG_MSG,"Before ReadFile Req=%d",cbRequested);

        if (! ReadFile( pTG->hComm, lpbNext+cbFromCache, cbRequested, &nNumRead, &pTG->Comm.ovAux) ) 
        {
            if ( (dwLastErr = GetLastError() ) == ERROR_IO_PENDING) 
            {
                // We want to be able to un-block ONCE only from waiting on I/O when the AbortReqEvent is signaled.
                //
                if (pTG->fAbortRequested) 
                {
                    if (pTG->fOkToResetAbortReqEvent && (!pTG->fAbortReqEventWasReset)) 
                    {
                        DebugPrintEx(DEBUG_MSG,"RESETTING AbortReqEvent");
                        pTG->fAbortReqEventWasReset = TRUE;
                        if (!ResetEvent(pTG->AbortReqEvent))
                        {
							DebugPrintEx(   DEBUG_ERR,
											"ResetEvent failed (ec=%d)", 
											GetLastError());
                        }
                    }

                    pTG->fUnblockIO = TRUE;
                    *lpswEOF = -2;
                    goto error;
                }

                HandlesArray[0] = pTG->Comm.ovAux.hEvent;
                HandlesArray[1] = pTG->AbortReqEvent;

                if (pTG->fUnblockIO) 
                {
                    NumHandles = 1;
                }
                else 
                {
                    NumHandles = 2;
                }

                WaitResult = WaitForMultipleObjects(NumHandles, HandlesArray, FALSE, WAIT_FCOM_FILTER_READBUF_TIMEOUT);

                if (WaitResult == WAIT_TIMEOUT) 
                {
                    DebugPrintEx(DEBUG_ERR, "WaitForMultipleObjects TIMEOUT");
                    *lpswEOF = -3;
                    goto error;
                }

                if (WaitResult == WAIT_FAILED) 
                {
                    DebugPrintEx(   DEBUG_ERR, 
                                    "WaitForMultipleObjects FAILED le=%lx",
                                    GetLastError());

                    *lpswEOF = -3;
                    goto error;
                }

                if ( (NumHandles == 2) && (WaitResult == WAIT_OBJECT_0 + 1) ) 
                {
                    // We have an abort and also there is pending IO ReadFile.
                    pTG->fUnblockIO = TRUE;
                    DebugPrintEx(DEBUG_MSG,"ABORTed");
                    *lpswEOF = -2;
                    goto error;
                }

                if ( ! GetOverlappedResult ( pTG->hComm, &pTG->Comm.ovAux, &nNumRead, TRUE) ) 
                {
                    DebugPrintEx(DEBUG_ERR, "GetOverlappedResult le=%x", GetLastError());
                    if (! ClearCommError( pTG->hComm, &dwErr, &ErrStat) ) 
                    {
                        DebugPrintEx(DEBUG_ERR, "ClearCommError le=%x", GetLastError());
                    }
                    else 
                    {
                        DebugPrintEx(   DEBUG_WRN, 
                                        "ClearCommError dwErr=%x ErrSTAT: Cts=%d "
                                        "Dsr=%d Rls=%d XoffHold=%d XoffSent=%d "
                                        "fEof=%d Txim=%d In=%d Out=%d",
                                        dwErr, 
                                        ErrStat.fCtsHold, 
                                        ErrStat.fDsrHold, 
                                        ErrStat.fRlsdHold, 
                                        ErrStat.fXoffHold, 
                                        ErrStat.fXoffSent, 
                                        ErrStat.fEof,
                                        ErrStat.fTxim, 
                                        ErrStat.cbInQue, 
                                        ErrStat.cbOutQue);
                    }
                    *lpswEOF = -3;
                    goto done;
                }
            }
            else 
            {
                DebugPrintEx(DEBUG_ERR, "ReadFile le=%x", dwLastErr);
                *lpswEOF = -3;
                goto done;
            }
        }
        else 
        {
            DebugPrintEx(DEBUG_WRN,"ReadFile returned w/o WAIT");
        }

        DebugPrintEx(   DEBUG_MSG,
                        "After ReadFile Req=%d Ret=%d", 
                        cbRequested, 
                        nNumRead);

        cbAvail = (UWORD) (nNumRead + cbFromCache);

l_merge:

        if (!cbAvail) 
        {
            DebugPrintEx(DEBUG_MSG,"cbAvail = %d --> continue", cbAvail);
            continue;
        }
        // else we just drop through

        // try to catch COMM read problems

        DebugPrintEx(   DEBUG_MSG, 
                        "Just read %d bytes, from cache =%d, "
                        "log [%x .. %x], 1st=%x last=%x",
                        nNumRead, 
                        cbFromCache, 
                        pTG->CommLogOffset, 
                        (pTG->CommLogOffset+cbAvail),
                        *lpbNext, 
                        *(lpbNext+cbAvail-1) );

        pTG->CommLogOffset += cbAvail;

        // Strip the redunant chars. The return value is the number of chars we got.
        cbAvail = FComStripBuf(pTG, lpbNext-2, lpbNext, cbAvail, fClass2, lpswEOF, &cbUsed);

        // If the requested buffer size is small, and the buffer includes some <dle>
        // chars, FComStripBuf could return 0. In this case, reset cbRequested, so 
        // that we read the next characters correctly.
        if (cbAvail==0)
        {
            cbRequested = cbSize - cbGot;
        }

        if (fClass2)
        {
            // for class 2 FComFilterReadBuf should keep cache for FComFilterReadLine
            if ((*lpswEOF)==-1)
            {
                // We got EOF, we should keep the extra data we got for FComFilterReadLine
                // cbUsed is the number of input bytes consumed by FComStripBuf, including dle-etx
                // any data after cbUsed bytes should go to ComCache
                INT iExtraChars = nNumRead - cbUsed;
                if (iExtraChars>0)
                {
                    DebugPrintEx(DEBUG_MSG,"There are %ld chars after EOF",iExtraChars);
                    CopyMemory (pTG->CommCache.lpBuffer,lpbNext+cbUsed, iExtraChars);
                    pTG->CommCache.dwOffset = 0;
                    pTG->CommCache.dwCurrentSize = iExtraChars;
                }
                else
                {
                    DebugPrintEx(DEBUG_MSG,"No extra data after EOF");
                }
            }
        }

        DebugPrintEx(DEBUG_MSG,"After FComStripBuf cbAvail=%ld",cbAvail);

        cbGot += cbAvail;
        lpbNext += cbAvail;

        // RSL 970123. Dont wanna loop if got anything.

        if ( (*lpswEOF != 0) || (cbGot > 0) )    
        {   // some eof or full buf
                goto done;
        }

    }

    *lpswEOF = -2;
    goto done;


error:
    if (!CancellPendingIO(pTG , pTG->hComm , lpOverlapped , (LPDWORD) &nNumRead))
    {
        DebugPrintEx(DEBUG_ERR, "failed when call to CancellPendingIO");
    }

    // fall through to done
done:

//    DebugPrintEx(DEBUG_MSG,"exit: cbGot=%d swEOF=%d", cbGot, *lpswEOF);
    return cbGot;
}

#undef USE_DEBUG_CONTEXT   
#define USE_DEBUG_CONTEXT   DEBUG_CONTEXT_T30_COMM

BOOL
FComGetOneChar
(
   PThrdGlbl pTG,
   UWORD ch
)
{
    BYTE             rgbRead[10];    // must be 3 or more. 10 for safety
    // ATTENTION: We do overlapped read into the stack!!
    TO               toCtrlQ;
    int              nNumRead;               // _must_ be 32 bits in WIN32
    LPOVERLAPPED     lpOverlapped;
    DWORD            dwErr;
    COMSTAT          ErrStat;
    DWORD            NumHandles=2;
    HANDLE           HandlesArray[2];
    DWORD            WaitResult;
    DWORD            dwLastErr;
    SWORD            i;

    DEBUG_FUNCTION_NAME(("FComGetOneChar"));

    HandlesArray[1] = pTG->AbortReqEvent;

    //
    // check the cache first.
    //
    if ( ! pTG->CommCache.dwCurrentSize) 
    {
        DebugPrintEx(DEBUG_MSG, "Cache is empty. Resetting comm cache.");
        ClearCommCache(pTG);
    }
    else 
    {
       // The cache is not empty, lets look for ch in the cache
       for (i=0; i< (SWORD) pTG->CommCache.dwCurrentSize; i++) 
       {
          if ( *(pTG->CommCache.lpBuffer + pTG->CommCache.dwOffset + i) == ch) 
          {
             // found in cache
             DebugPrintEx(  DEBUG_MSG,
                            "Found XON in cache pos=%d total=%d",
                            i, 
                            pTG->CommCache.dwCurrentSize);
             
             pTG->CommCache.dwOffset += (i+1);
             pTG->CommCache.dwCurrentSize -= (i+1);

             goto GotCtrlQ;
          }
       }

       DebugPrintEx(    DEBUG_MSG, 
                        "Cache wasn't empty. Didn't find XON. Resetting comm cache.");

       ClearCommCache(pTG);
    }

    // Send nothing - look for cntl-Q (XON) after connect
    startTimeOut(pTG, &toCtrlQ, 1000);
    do
    {
        lpOverlapped =  &pTG->Comm.ovAux;

        (lpOverlapped)->Internal = 0;
		(lpOverlapped)->InternalHigh = 0;
		(lpOverlapped)->Offset = 0;
        (lpOverlapped)->OffsetHigh = 0;

        if ((lpOverlapped)->hEvent)
        {
            if (!ResetEvent((lpOverlapped)->hEvent))
            {
				DebugPrintEx(   DEBUG_ERR,
								"ResetEvent failed (ec=%d)", 
								GetLastError());
            }
        }

        nNumRead = 0;

        DebugPrintEx(DEBUG_MSG, "Before ReadFile Req=1");

        if (! ReadFile( pTG->hComm, rgbRead, 1, &nNumRead, lpOverlapped) ) 
        {
           if ( (dwLastErr = GetLastError() ) == ERROR_IO_PENDING) 
           {
               // We want to be able to un-block ONCE only from waiting on I/O when the AbortReqEvent is signaled.
               //
               if (pTG->fAbortRequested) 
               {
                   if (pTG->fOkToResetAbortReqEvent && (!pTG->fAbortReqEventWasReset)) 
                   {
                       DebugPrintEx(DEBUG_MSG,"RESETTING AbortReqEvent");
                       pTG->fAbortReqEventWasReset = TRUE;
                       if (!ResetEvent(pTG->AbortReqEvent))
                       {
							DebugPrintEx(   DEBUG_ERR,
											"ResetEvent failed (ec=%d)", 
											GetLastError());
                       }
                   }

                   pTG->fUnblockIO = TRUE;
                   goto error;
               }

               HandlesArray[0] = pTG->Comm.ovAux.hEvent;
               HandlesArray[1] = pTG->AbortReqEvent;

               if (pTG->fUnblockIO) 
               {
                   NumHandles = 1;
               }
               else 
               {
                   NumHandles = 2;
               }

               WaitResult = WaitForMultipleObjects(NumHandles, HandlesArray, FALSE, WAIT_FCOM_FILTER_READBUF_TIMEOUT);

               if (WaitResult == WAIT_TIMEOUT) 
               {
                   DebugPrintEx(DEBUG_ERR, "WaitForMultipleObjects TIMEOUT");
                      
                   goto error;
               }

               if (WaitResult == WAIT_FAILED) 
               {
                   DebugPrintEx(    DEBUG_ERR,
                                    "WaitForMultipleObjects FAILED le=%lx",
                                    GetLastError());
                   goto error;
               }

               if ( (NumHandles == 2) && (WaitResult == WAIT_OBJECT_0 + 1) ) 
               {
                   pTG->fUnblockIO = TRUE;
                   DebugPrintEx(DEBUG_MSG,"ABORTed");
                   goto error;
               }

                // The IO operation was complete. Lets try to get the overlapped result.
               if ( ! GetOverlappedResult ( pTG->hComm, lpOverlapped, &nNumRead, TRUE) ) 
               {
                   DebugPrintEx(DEBUG_ERR,"GetOverlappedResult le=%x",GetLastError());
                   if (! ClearCommError( pTG->hComm, &dwErr, &ErrStat) ) 
                   {
                       DebugPrintEx(DEBUG_ERR, "ClearCommError le=%x",GetLastError());
                   }
                   else 
                   {
                       DebugPrintEx(    DEBUG_ERR, 
                                        "ClearCommError dwErr=%x ErrSTAT: Cts=%d "
                                        "Dsr=%d Rls=%d XoffHold=%d XoffSent=%d "
                                        "fEof=%d Txim=%d In=%d Out=%d",
                                        dwErr, 
                                        ErrStat.fCtsHold, 
                                        ErrStat.fDsrHold, 
                                        ErrStat.fRlsdHold, 
                                        ErrStat.fXoffHold, 
                                        ErrStat.fXoffSent, 
                                        ErrStat.fEof,
                                        ErrStat.fTxim, 
                                        ErrStat.cbInQue, 
                                        ErrStat.cbOutQue);
                   }
                   goto errorWithoutCancel;
               }
           }
           else 
           { // error in ReadFile (not ERROR_IO_PENDING), so there is no Pending IO operations
               DebugPrintEx(DEBUG_ERR, "ReadFile le=%x at",dwLastErr);
               goto errorWithoutCancel;
           }
        }
        else 
        {
           DebugPrintEx(DEBUG_WRN,"ReadFile returned w/o WAIT");
        }

        DebugPrintEx(DEBUG_MSG,"After ReadFile Req=1 Ret=%d",nNumRead);

        switch(nNumRead)
        {
        case 0:         break;          // loop until we get something
        case 1:         
                        if(rgbRead[0] == ch)
                        {
                            goto GotCtrlQ;
                        }
                        else
                        {
                            DebugPrintEx(DEBUG_ERR,"GetCntlQ: Found non ^Q char");
                            goto errorWithoutCancel;
                        }
        default:        goto errorWithoutCancel;
        }
    }
    while(checkTimeOut(pTG, &toCtrlQ));
    goto errorWithoutCancel;

GotCtrlQ:
    return TRUE;

error:

    if (!CancellPendingIO(pTG , pTG->hComm , lpOverlapped , (LPDWORD) &nNumRead))
    {
        DebugPrintEx(DEBUG_ERR, "failed when call to CancellPendingIO");
    }

errorWithoutCancel:

return FALSE;
}

OVREC *ov_get(PThrdGlbl pTG)
{
    OVREC   *lpovr=NULL;

    DEBUG_FUNCTION_NAME(_T("ov_get"));

    if (!pTG->Comm.covAlloced)
    {
        // There are no OVREC in use now.
        lpovr = &(pTG->Comm.rgovr[0]);
    }
    else
    {
        UINT uNewLast = (pTG->Comm.uovLast+1) % NUM_OVS;

        DebugPrintEx(   DEBUG_MSG, 
                        "iov_flush: 1st=%d, last=%d", 
                        pTG->Comm.uovFirst, 
                        pTG->Comm.uovLast);

        lpovr = pTG->Comm.rgovr+uNewLast;
        if (uNewLast == pTG->Comm.uovFirst)
        {
            if (!iov_flush(pTG, lpovr, TRUE))
            {
                ov_unget(pTG, lpovr);
                lpovr=NULL; // We fail if a flush operation failed...
            }
            else
            {
                pTG->Comm.uovFirst = (pTG->Comm.uovFirst+1) % NUM_OVS;
            }
        }
        if (lpovr)
            pTG->Comm.uovLast = uNewLast;
    }
    if (lpovr && lpovr->eState!=eALLOC)
    {
        pTG->Comm.covAlloced++;
        lpovr->eState=eALLOC;
    }
    return lpovr;
}

// We have array of overllaped structures (size: NUM_OVS)
// This function release given OVREC

BOOL ov_unget(PThrdGlbl pTG, OVREC *lpovr)
{
    BOOL fRet = FALSE;

    DEBUG_FUNCTION_NAME(("ov_unget"));

    DebugPrintEx(DEBUG_MSG,"lpovr=%lx",lpovr);

    if (    lpovr->eState!=eALLOC ||
            !pTG->Comm.covAlloced || 
            lpovr!=(pTG->Comm.rgovr+pTG->Comm.uovLast))
    {
        DebugPrintEx(DEBUG_ERR, "invalid lpovr.");
        goto end;
    }

    if (pTG->Comm.covAlloced==1)
    {
        pTG->Comm.uovLast = pTG->Comm.uovFirst = 0;
    }
    else
    {
        pTG->Comm.uovLast = (pTG->Comm.uovLast)?  (pTG->Comm.uovLast-1) : (NUM_OVS-1);
    }
    pTG->Comm.covAlloced--;
    lpovr->eState=eFREE;
    fRet = TRUE;

end:
    return fRet;
}

// function: ov_write
// This function writes the buffer from lpovr to the comm. In case of error or return w/o waiting, the function free
// the ovrec. In case of IO_PENDING we write to *lpdwcbWrote the size of the buffer to write and return without waiting
// for operation to complete
// 

BOOL ov_write(PThrdGlbl pTG, OVREC *lpovr, LPDWORD lpdwcbWrote)
{
    DEBUG_FUNCTION_NAME(_T("ov_write"));
    // Write out the buffer associated with lpovr.
    if (!lpovr->dwcb) // Nothing in the buffer
    {
        // Just free the overlapped structure
        ov_unget(pTG, lpovr);
        lpovr=NULL;
    }
    else
    {
        BOOL fRet;
        DWORD dw;
        OVERLAPPED *lpov = &(lpovr->ov);

        DWORD cbQueue;

        pTG->Comm.comstat.cbOutQue += lpovr->dwcb;

        GetCommErrorNT(pTG);

        cbQueue = pTG->Comm.comstat.cbOutQue;

        {
            DebugPrintEx(   DEBUG_MSG, 
                            "Before WriteFile lpb=%x, cb=%d lpovr=%lx",
                            lpovr->rgby,
                            lpovr->dwcb, 
                            lpovr);

            if (!(fRet = WriteFile( pTG->hComm, 
                                    lpovr->rgby, 
                                    lpovr->dwcb,
                                    lpdwcbWrote, 
                                    lpov)))
            {
                dw=GetLastError();
            }
            DebugPrintEx(DEBUG_MSG,"After, wrote %ld",*lpdwcbWrote);

            GetCommErrorNT(pTG);

			DebugPrintEx(   DEBUG_MSG, 
                            "Queue before=%lu; after = %lu. n= %lu, *pn=%lu",
                            (unsigned long) cbQueue,
                            (unsigned long) (pTG->Comm.comstat.cbOutQue),
                            (unsigned long) lpovr->dwcb,
                            (unsigned long) *lpdwcbWrote);
        }
        if (fRet)
        {
            // Write operation completed
            DebugPrintEx(DEBUG_WRN, "WriteFile returned w/o wait");
            OVL_CLEAR( lpov);
            lpovr->dwcb=0;
            ov_unget(pTG, lpovr);
            lpovr=NULL;
        }
        else
        {
            if (dw==ERROR_IO_PENDING)
            {
                DebugPrintEx(DEBUG_MSG,"WriteFile returned PENDING");
                *lpdwcbWrote = lpovr->dwcb; // We set *pn to n on success else 0.
                lpovr->eState=eIO_PENDING;
            }
            else
            {
                DebugPrintEx(   DEBUG_ERR,
                                "WriteFile returns error 0x%lx",
                                (unsigned long)dw);
                OVL_CLEAR(lpov);
                lpovr->dwcb=0;
                ov_unget(pTG, lpovr);
                lpovr=NULL;
                goto error;
            }
        }
    }

    return TRUE;

error:

    return FALSE;
}

// This function do "iov_flush" on all the allocated OVREC, and free the OVREC for future use.

BOOL ov_drain(PThrdGlbl pTG, BOOL fLongTO)
{
    BOOL fRet = TRUE;

    // We want to iterate on all the OVREC that are in use.
    UINT u = pTG->Comm.covAlloced;

    DEBUG_FUNCTION_NAME(_T("ov_drain"));

    while(u--)
    {
        OVREC *lpovr = pTG->Comm.rgovr+pTG->Comm.uovFirst;
        OVERLAPPED *lpov = &(lpovr->ov);

        if (lpovr->eState==eIO_PENDING)
        {
            if (!iov_flush(pTG, lpovr, fLongTO))
                fRet=FALSE;

            lpovr->eState=eFREE;
            pTG->Comm.covAlloced--;
            pTG->Comm.uovFirst = (pTG->Comm.uovFirst+1) % NUM_OVS;
        }
        else
        {
            // Only the newest (last) structure can be still in the
            // allocated state.
            DebugPrintEx(DEBUG_WRN,"called when alloc'd structure pending");
        }
    }

    if (!pTG->Comm.covAlloced)
    {
        pTG->Comm.uovFirst=pTG->Comm.uovLast=0;
    }

    return fRet;
}


BOOL ov_init(PThrdGlbl pTG)
{
    UINT u;
    OVREC *lpovr = pTG->Comm.rgovr;

    DEBUG_FUNCTION_NAME(_T("ov_init"));
    // init overlapped structures, including creating events...
    if (pTG->Comm.fovInited)
    {
        DebugPrintEx(DEBUG_ERR, "we're *already* inited.");
        ov_deinit(pTG);
    }

    for (u=0;u<NUM_OVS;u++,lpovr++) 
    {
        OVERLAPPED *lpov = &(lpovr->ov);
        _fmemset(lpov, 0, sizeof(OVERLAPPED));
        lpov->hEvent = CreateEvent(NULL, TRUE, FALSE, NULL);
        if (lpov->hEvent==NULL)
        {
            DebugPrintEx(   DEBUG_ERR, 
                            "couldn't create event #%lu",
                            (unsigned long)u);
            goto failure;
        }
        lpovr->eState=eFREE;
        lpovr->dwcb=0;
    }

    pTG->Comm.fovInited=TRUE;

    return TRUE;

failure:
    while (u--)
    {   
        --lpovr; 
        CloseHandle(lpovr->ov.hEvent); 
        lpovr->eState=eDEINIT;
    }
    return FALSE;

}

BOOL ov_deinit(PThrdGlbl pTG)
{
    UINT u=NUM_OVS;
    OVREC *lpovr = pTG->Comm.rgovr;

    DEBUG_FUNCTION_NAME(("ov_deinit"));

    if (!pTG->Comm.fovInited)
    {
        DebugPrintEx(DEBUG_WRN,"Already deinited.");
        goto end;
    }

    //
    // if handoff ==> dont flush
    //
    if (pTG->Comm.fEnableHandoff &&  pTG->Comm.fDataCall) 
    {
        goto lNext;
    }

    // deinit overlapped structures, including freeing events...
    if (pTG->Comm.covAlloced)
    {
        DWORD dw;
        DebugPrintEx(   DEBUG_WRN,
                        "%lu IO's pending.",
                        (unsigned long) pTG->Comm.covAlloced);
        if (pTG->Comm.lpovrCur)
        {
            ov_write(pTG, pTG->Comm.lpovrCur,&dw); 
            pTG->Comm.lpovrCur=NULL;
        }
        ov_drain(pTG, FALSE);
    }

lNext:

    while (u--)
    {
        lpovr->eState=eDEINIT;
        if (lpovr->ov.hEvent) 
            CloseHandle(lpovr->ov.hEvent);

        _fmemset(&(lpovr->ov), 0, sizeof(lpovr->ov));
        lpovr++;
    }

    pTG->Comm.fovInited=FALSE;

end:
    return TRUE;
}


BOOL iov_flush(PThrdGlbl pTG, OVREC *lpovr, BOOL fLongTO)
// On return, state of lpovr is *always* eALLOC, but
// it returns FALSE if there was a comm error while trying
// to flush (i.e. drain) the buffer.
// If we timeout with the I/O operation still pending, we purge
// the output buffer and abort all pending write operations.
{
    DWORD dwcbPrev;
    DWORD dwStart = GetTickCount();
    BOOL  fRet=FALSE;
    DWORD dwWaitRes;
    DWORD dw;

    DEBUG_FUNCTION_NAME(_T("iov_flush"));

    DebugPrintEx(DEBUG_MSG,"fLongTo=%d lpovr=%lx",fLongTO,lpovr);

    if (!pTG->hComm)
    {
        lpovr->eState=eALLOC; 
        goto end;
    }

    // We call
    // WaitForSingleObject multiple times ... basically
    // the same logic as the code in the old FComDirectWrite...
    // fLongTO is TRUE except when initing
    // the modem (see comments for FComDrain).

    GetCommErrorNT(pTG);
    // We want to check for progress, so we check the amount of bytes in the output buffer.
    dwcbPrev = pTG->Comm.comstat.cbOutQue;

    while( (dwWaitRes=WaitForSingleObject(  lpovr->ov.hEvent,
                                            fLongTO ? 
                                            LONG_DRAINTIMEOUT : 
                                            SHORT_DRAINTIMEOUT))==WAIT_TIMEOUT)
    {
        BOOL fStuckOnce=FALSE;

        DebugPrintEx(DEBUG_MSG,"After WaitForSingleObject TIMEOUT");

        GetCommErrorNT(pTG);
        // Timed out -- check if any progress
        if (dwcbPrev == pTG->Comm.comstat.cbOutQue)
        {
            //  No pregess, the size of the output buffer is without any change.
            DebugPrintEx(DEBUG_WRN,"No progress %d",dwcbPrev);

            // No progress... If not in XOFFHold, we break....
            if(!FComInXOFFHold(pTG))
            {
                if(fStuckOnce)
                {
                    DebugPrintEx(   DEBUG_ERR, 
                                    "No Progress -- OutQ still %d", 
                                    (int)pTG->Comm.comstat.cbOutQue);
                    goto done;
                }
                else
                {
                    fStuckOnce=TRUE;
                }
            }
        }
        else
        {
            // Some progress...
            dwcbPrev= pTG->Comm.comstat.cbOutQue;
            fStuckOnce=FALSE;
        }

        // Independant deadcom timeout... I don't want
        // to use TO because of the 16bit limitation.
        {
            DWORD dwNow = GetTickCount();
            DWORD dwDelta = (dwNow>dwStart)
                            ?  (dwNow-dwStart)
                               :  (0xFFFFFFFFL-dwStart) + dwNow;
            if (dwDelta > (unsigned long)((fLongTO)?LONG_DEADCOMMTIMEOUT:SHORT_DEADCOMMTIMEOUT))
            {
                DebugPrintEx(   DEBUG_ERR, 
                                "Drain:: Deadman Timer -- OutQ still %d", 
                                (int) pTG->Comm.comstat.cbOutQue);
                goto end;
            }
        }
    }

    if (dwWaitRes==WAIT_FAILED)
    {
        DebugPrintEx(   DEBUG_ERR, 
                        "WaitForSingleObject failed (ec=%d)", 
                        GetLastError());
        goto end;
    }
done:

    DebugPrintEx(DEBUG_MSG,"Before GetOverlappedResult");

    if (GetOverlappedResult(pTG->hComm, &(lpovr->ov), &dw, FALSE))
    {
        fRet=TRUE;
    }
    else
    {
        dw = GetLastError();
        DebugPrintEx(   DEBUG_ERR,
                        "GetOverlappedResult returns error 0x%lx",
                        (unsigned long)dw);
        if (dw==ERROR_IO_INCOMPLETE)
        {
            // IO operation still pending, but we *have* to
            // reuse this buffer -- what should we do?!-
            // purge the output buffer and abort all pending
            // write operations on it..

            DebugPrintEx(DEBUG_ERR, "Incomplete");
            PurgeComm(pTG->hComm, PURGE_TXABORT);
        }
        fRet=FALSE;
    }
    OVL_CLEAR( &(lpovr->ov));
    lpovr->eState=eALLOC;
    lpovr->dwcb=0;

end:
    return fRet;
}

void WINAPI FComOverlappedIO(PThrdGlbl pTG, BOOL fBegin)
{
    DEBUG_FUNCTION_NAME(_T("FComOverlappedIO"));

    DebugPrintEx(DEBUG_MSG,"Turning %s OVERLAPPED IO", (fBegin) ? "ON" : "OFF");
    pTG->Comm.fDoOverlapped=fBegin;
}


BOOL
CancellPendingIO
(
    PThrdGlbl pTG , 
    HANDLE hComm , 
    LPOVERLAPPED lpOverlapped , 
    LPDWORD lpCounter)
{ 
    BOOL retValue = TRUE;
    /*
    The CancelIo function cancels all pending input and output (I/O) operations 
    that were issued by the calling thread for the specified file handle. The 
    function does not cancel I/O operations issued for the file handle by other threads.
    */

    DEBUG_FUNCTION_NAME(_T("CancellPendingIO"));

    if (!CancelIo(hComm))
    {
        retValue = FALSE;
        DebugPrintEx(DEBUG_ERR, "CancelIO failed, ec=%x",GetLastError());
    }
    else
    {
        DebugPrintEx(DEBUG_MSG,"CancelIO succeeded.");
    }

    (*lpCounter) = 0;
    if (!GetOverlappedResult (hComm , lpOverlapped, lpCounter , TRUE))
    {
        DebugPrintEx(   DEBUG_MSG,
                        "GetOverlappedResult failed because we cancel the "
                        "IO operation, ec=%x", 
                        GetLastError());
    }
    else
    {
        // If the function was successful then something fishy with the CancellIo(hComm)
        // The operation succeeded cause the pending IO was finished before the 'CancelIo'
        DebugPrintEx(   DEBUG_MSG,
                        "GetOverlappedResult succeeded. Number of bytes read %d", 
                        *lpCounter);
    }
    ClearCommCache(pTG);
    return retValue;
}

void GetCommErrorNT(PThrdGlbl pTG)
{
	DWORD err;

    DEBUG_FUNCTION_NAME(_T("GetCommErrorNT"));
    if (!ClearCommError( pTG->hComm, &err, &(pTG->Comm.comstat))) 
    {
        DebugPrintEx(   DEBUG_ERR, 
                        "(0x%lx) FAILS. Returns 0x%lu",
                        pTG->hComm,  
                        GetLastError());
        err =  MYGETCOMMERROR_FAILED;
    }
#ifdef DEBUG
	if (err)
	{
        D_PrintCE(err);
        D_PrintCOMSTAT(pTG, &pTG->Comm.comstat);
	}
#endif // DEBUG

}


void
ClearCommCache
(
    PThrdGlbl   pTG
)
{
    pTG->CommCache.dwCurrentSize = 0;
    pTG->CommCache.dwOffset      = 0;
}
=== C:/Users/treeman/Desktop/windows nt source code\Source\Win2K3\NT\printscan\faxsrv\provider\t30\headers\awnsfapi.h ===
/***************************************************************************
 Name     :     AWNSFAPI.H
 Comment  :     Definitions of the AtWork AWBC (Basicaps) structure which is the
            decrypted/decooded/reformatted form of the At Work NSF and NSC
            Also the decrypted form of the At Work NSS
            Also defines the APIs for encoding/decoding AtWork NSF/NSC/NSS

     Copyright (c) 1993 Microsoft Corp.

 Revision Log
 Date     Name  Description
 -------- ----- ---------------------------------------------------------
 08/28/93 arulm Created
***************************************************************************/

#ifndef _AWNSFAPI_H
#define _AWNSFAPI_H


/***********************************************************************
 *                                                                     *
 * NOTICE: This file has to be ANSI compilable, under GCC on UNIX      *
 * and other ANSI compiles. Be sure to use no MS C specific features   *
 * In particular, don't use // for comments!!!!                        *
 *                                                                     *
 ***********************************************************************/
typedef int      BOOL;
typedef unsigned char   BYTE;
typedef unsigned short  WORD;
typedef unsigned long   DWORD;
typedef unsigned short  USHORT;
typedef BYTE FAR*               LPBYTE;
typedef WORD FAR*               LPWORD;

#include <fr.h>

#pragma pack(2)    /** ensure packing is portable, i.e. 2 or more **/


typedef enum {
    BC_NONE = 0,
    SEND_CAPS,      /** Used to derive an NSF to send **/
    RECV_CAPS,      /** Derived from a received NSF   **/
    SEND_PARAMS,    /** Used to derive an NSS to send **/
    RECV_PARAMS,    /** Derived from a received NSS   **/
} BCTYPE;

#define MAXTOTALIDLEN           61

/** Appropriate values for some of the above fields **/

#pragma pack()

#endif /** _AWNSFAPI_H **/
=== C:/Users/treeman/Desktop/windows nt source code\Source\Win2K3\NT\printscan\faxsrv\provider\t30\comm\modemint.h ===
/***************************************************************************
 Name     :     MODEMINT.H
 Comment  :
 Functions:     (see Prototypes just below)

                Copyright (c) Microsoft Corp. 1991, 1992, 1993

 Revision Log
 Date     Name  Description
 -------- ----- ---------------------------------------------------------
***************************************************************************/

/**---------------------- #define of sizes of things ---------------------

        Frames can be at most 2.55 secs (sent) or 3.45 secs (recvd) long, or
        2.55 * 300/8 = 96 bytes and 132 bytes long respectively

        Dialstrings are limited to 512 bytes (arbitrarily)

        Commands (except dial) are never more than about 10-20 bytes long, so
        we use a buffer of 40 bytes. Replies are never big at all, but we
        might hold a frame in there, so keep it same size as a Framebuffer

        The Dial command is ATDT <string><CR>, so we use 512+10 bytes buffer

---------------------- #define of sizes of things ---------------------**/

#define MAXPHONESIZE    512
#define DIALBUFSIZE     MAXPHONESIZE + 10


#define CR                              0x0d
#define LF                              0x0a
#define DLE                             0x10            // DLE = ^P = 16d = 10h
#define ETX                             0x03

// The following bunch of defines allow us to combine detection
// with pre-read settings (from unimodem, say).

#define fGOTCMD_Reset           (0x1)
#define fGOTCMD_Setup           (0x1<<1)
#define fGOTCMD_PreAnswer       (0x1<<2)
#define fGOTCMD_PreDial         (0x1<<3)
#define fGOTCMD_PreExit         (0x1<<4)

#define fGOTCMDS \
          fGOTCMD_Reset \
        | fGOTCMD_Setup \
        | fGOTCMD_PreAnswer \
        | fGOTCMD_PreDial \
        | fGOTCMD_PreExit

#define fGOTCAP_CLASSES         (0x1<<10)
#define fGOTCAP_SENDSPEEDS      (0x1<<11)
#define fGOTCAP_RECVSPEEDS      (0x1<<12)

#define fGOTCAPS \
          fGOTCAP_CLASSES \
        | fGOTCAP_SENDSPEEDS \
        | fGOTCAP_RECVSPEEDS

#define fGOTPARM_PORTSPEED      (0x1<<20)
#define fGOTPARM_IDCMD          (0x1<<21)
#define fGOTPARM_ID                     (0x1<<22)

#define fGOTPARMS \
          fGOTPARM_PORTSPEED \
        | fGOTPARM_IDCMD \
        | fGOTPARM_ID

#define fGOTIDS \
          fGOTPARM_IDCMD \
        | fGOTPARM_ID

#define fGOTFLAGS (0x1<<23)


// Following structure has stuff which should ideally go into
// MODEMCAPS, but we can't change that at this state (11/94).

extern BOOL                             fMegaHertzHack;



// used for Resync type stuff. RepeatCount = 2
// This has to be multi-line too, because echo could be on and
// we could get the command echoed back instead of response!
// Looks like even 330 is too short for some modems..
// 550 is too short for Sharad's PP9600FXMT & things
// can get really screwed up if this times out, so use
// a nice large value
#define  iSyncModemDialog(pTG, s, l, w)                                                      \
                iiModemDialog(pTG, s, l, 990, TRUE, 2, TRUE, (CBPSTR)w, (CBPSTR)(NULL))

// This version for dealing with possible NON-numeric responses as well...
#define  iSyncModemDialog2(pTG, s, l, w1, w2)                                                        \
                iiModemDialog(pTG, s, l, 990, TRUE, 2, TRUE, (CBPSTR)w1, (CBPSTR)w2, (CBPSTR)(NULL))


// These are used for offline things, so we make them all (a) multiline
// (b) long timeout (c) 2 tries and (d) make sure they all look for ERROR
// as a response, to speed things up

#define OfflineDialog2(pTG, s,l,w1,w2)        iiModemDialog(pTG, s, l, 5000, TRUE, 2, TRUE, (CBPSTR)w1, (CBPSTR)w2, (CBPSTR)(NULL))

#define GOCLASS2_0      3
extern CBSZ cbszOK, cbszERROR;




/****************** begin prototypes from modem.c *****************/
SWORD iModemSync(PThrdGlbl pTG);
SWORD iModemReset(PThrdGlbl pTG, CBPSTR szCmd);
UWORD GetCap(PThrdGlbl pTG, CBPSTR cbpstrSend, UWORD uwLen);
UWORD GetCapAux(PThrdGlbl pTG, CBPSTR cbpstrSend, UWORD uwLen);
BOOL iModemGetCaps(PThrdGlbl pTG, LPMODEMCAPS lpMdmCaps,
                                        DWORD dwSpeed, LPSTR lpszReset, LPDWORD lpdwGot);
BOOL iiModemGoClass(PThrdGlbl pTG, USHORT uClass, DWORD dwSpeed);
/***************** end of prototypes from modem.c *****************/


/****************** begin prototypes from identify.c *****************/
USHORT iModemGetCmdTab(PThrdGlbl pTG, LPCMDTAB lpCmdTab, LPMODEMCAPS lpMdmCaps);
USHORT iModemInstall(PThrdGlbl pTG, BOOL fDontPurge);
USHORT iModemFigureOutCmds(PThrdGlbl pTG, LPCMDTAB lpCmdTab);
USHORT iModemGetWriteCaps(PThrdGlbl pTG);
/***************** end of prototypes from identify.c *****************/
=== C:/Users/treeman/Desktop/windows nt source code\Source\Win2K3\NT\printscan\faxsrv\provider\t30\comm\timeouts.c ===
/***************************************************************************
        Name      :     TIMEOUTS.C
        Comment   :     Various support functions

        Revision Log

        Num   Date      Name     Description
        --- -------- ---------- -----------------------------------------------
        001 12/18/91    arulm   Commenting it for the first time. This is the
                                                        "stable" DOS version from which the Windows code
                                                        will be derived. This file should not change
                                                        for Windows
***************************************************************************/
#define USE_DEBUG_CONTEXT   DEBUG_CONTEXT_T30_COMM

#include "prep.h"

#include "fcomint.h"
#include "fdebug.h"

///RSL
#include "glbproto.h"


/***************************************************************************
        Name      :     Timers Class
        Purpose   :     Provide for Timeouts
                                        TO                 -- Timeout struct
                                        startTimeout -- creates a new timeout
***************************************************************************/

void   startTimeOut(PThrdGlbl pTG, LPTO lpto, ULONG ulTimeout)
{
	lpto->ulStart = GetTickCount();
	lpto->ulTimeout = ulTimeout;
	lpto->ulEnd = lpto->ulStart + ulTimeout;        // will wrap around as system
}


BOOL   checkTimeOut(PThrdGlbl pTG, LPTO lpto)
{
	// if it returns FALSE, caller must return FALSE immediately
	// (after cleaning up, as appropriate).

	ULONG ulTime;

	ulTime = GetTickCount();

	if(lpto->ulTimeout == 0)
	{
		goto out;
	}
	else if(lpto->ulEnd >= lpto->ulStart)
	{
		if(ulTime >= lpto->ulStart && ulTime <= lpto->ulEnd)
				return TRUE;
		else
				goto out;
	}
	else    // ulEnd wrapped around!!
	{
		if(ulTime >= lpto->ulStart || ulTime <= lpto->ulEnd)
				return TRUE;
		else
				goto out;
	}

out:
	return FALSE;
}

// this will return garbage values if
ULONG   leftTimeOut(PThrdGlbl pTG, LPTO lpto)
{
    ULONG ulTime;

    ulTime = GetTickCount();

    if(lpto->ulTimeout == 0)
            return 0;
    else if(lpto->ulEnd >= lpto->ulStart)
    {
        if(ulTime >= lpto->ulStart && ulTime <= lpto->ulEnd)
            return (lpto->ulEnd - ulTime);
        else
            return 0;
    }
    else
    {
        if(ulTime >= lpto->ulStart || ulTime <= lpto->ulEnd)
            return (lpto->ulEnd - ulTime);  // in unsigned arithmetic this works correctly even if End<Time
        else
            return 0;
    }
}
=== C:/Users/treeman/Desktop/windows nt source code\Source\Win2K3\NT\printscan\faxsrv\provider\t30\comm\modem.c ===
/***************************************************************************
        Name      :     MODEM.C
        Comment   :     Various modem dialog & support functions, specific
                                to COM connected modems. For a modem on the bus
                                everything below & including this file is replaced
                                by the modem driver.

                Copyright (c) Microsoft Corp. 1991, 1992, 1993

        Revision Log
        Num   Date      Name     Description
        --- -------- ---------- -----------------------------------------------
        101     06/04/92        arulm   Modif to SUPPORT to provide a replaceable interface
                                                        and to use new FCom functions.
***************************************************************************/
#define USE_DEBUG_CONTEXT   DEBUG_CONTEXT_T30_CLASS1

#include "prep.h"

#include "mmsystem.h"
#include "modemint.h"
#include "fcomint.h"
#include "fdebug.h"

#include "efaxcb.h"

#define DEFINE_MDMCMDS
#include "mdmcmds.h"

///RSL
#include "glbproto.h"

#include "psslog.h"
#define FILE_ID     FILE_ID_MODEM

void    InitMonitorLogging(PThrdGlbl pTG);


#       pragma message("Compiling with ADAPTIVE_ANSWER")
USHORT iModemGetAdaptiveResp(PThrdGlbl pTG);
#define uMULTILINE_SAVEENTIRE   0x1234 // +++ HACK passed in as fMultiLine
                                                   //  in iiModemDialog to get it so save
                                                   //  entire buffer in FComModem.bEntireReply.

// Need to have these in descending order so that we'll
// Sync at teh highest common speed with auto-bauding modems!
static UWORD rguwSpeeds[] = {57600,19200, 19200, 9600, 2400, 1200, 300, 0};
// static UWORD rguwSpeeds[] = {19200, 2400, 9600, 1200, 300, 0};
// static UWORD rguwSpeeds[] = {2400, 19200, 9600, 1200, 300, 0};

SWORD HayesSyncSpeed(PThrdGlbl pTG, CBPSTR cbszCommand, UWORD uwLen)
{
    /* Internal routine to synchronize with the modem's speed.  Tries to
       get a response from the modem by trying the speeds in rglSpeeds
       in order (terminated by a 0).  If fTryCurrent is nonzero, checks for
       a response before trying to reset the speeds.

       Returns the speed it found, 0 if they're in sync upon entry (only
       checked if fTryCurrent!=0), or -1 if it couldn't sync.
    */
    // short i;
    short ilWhich = -1;

    DEBUG_FUNCTION_NAME(("HayesSyncSpeed"));
    rguwSpeeds[0] = pTG->CurrentSerialSpeed;

    if ( rguwSpeeds[0] == rguwSpeeds[1]) 
    {
        ilWhich++;
    }

    for(;;)
    {
        DebugPrintEx(   DEBUG_MSG,
                        "Trying: ilWhich=%d  speed=%d", 
                        ilWhich,
                        rguwSpeeds[ilWhich]);

        if(iSyncModemDialog(pTG, (LPSTR)cbszCommand, uwLen, cbszOK))
        {
            DebugPrintEx(   DEBUG_MSG,
                            "Succeeded in Syncing at Speed = %d (il=%d)",
                            rguwSpeeds[ilWhich], 
                            ilWhich);

            return (ilWhich>=0 ? rguwSpeeds[ilWhich] : 0);
        }

        /* failed.  try next speed. */
        if (rguwSpeeds[++ilWhich]==0)
        {
            // Tried all speeds. No response
            DebugPrintEx(   DEBUG_ERR,
                            "Cannot Sync with Modem on Command %s", 
                            (LPSTR)cbszCommand);
            return -1;
        }
        if(!FComSetBaudRate(pTG, rguwSpeeds[ilWhich]))
            return -1;
    }
}

SWORD iModemSync(PThrdGlbl pTG)
{
    // The command used here must be guaranteed to be harmless,
    // side-effect free & non-dstructive. i.e. we can issue it
    // at any point in command mode without chnageing the state
    // of teh modem or disrupting anything.
    // ATZ does not qualify. AT does, I think.....

    return HayesSyncSpeed(pTG, cbszAT, sizeof(cbszAT)-1);
}


SWORD iModemReset(PThrdGlbl pTG, CBPSTR szCmd)
{
    SWORD swRet;

    if (szCmd == NULL) 
    {
        return -1;
    }

    if((swRet = HayesSyncSpeed(pTG, szCmd, (UWORD) _fstrlen(szCmd))) < 0)
    {
        return swRet;
    }
    else
    {
        // ATZ may result in a change in the state/baud rate of the modem
        // (eg. Thought board drops to 2400), therefore we must Sync up
        // again because this function is really a Reset&Sync function.

        // instead of syncing up on AT and then doing ATE0, just
        // sync up on ATE0 directly

        if(iModemSync(pTG) < 0)
                return -1;

        /////////////////////
        // the above idea does not work with Sharad's PP9600FXMT
        // somehow I end up sending it ATATE0 and it answers the phone
        // In other cases, the ATE0 simply has no effect (because the AT&F
        // thing above got confused and teh ATE0 ended up just aborting
        // some previous command) and on ATA I get the ATA echoed,
        // get confused (because multi-line is FALSE) & send ATA again
        // which aborts the whole thing....
        //

        return 0;
    }
}


//////////////////////////////////////////////////////////////////////////////////////////////////////////////
#define ATV1                "ATV1"
#define AT                  "AT"
#define cr                  "\r"
#define cbszZero            "0"

USHORT
T30ModemInit(PThrdGlbl pTG)
{
    USHORT uLen, uRet;

    /*** Inits (or re-inits) the COM port, Syncs up with Modem (at whatever,
             speed), gets modem capabilities, puts it into CLASS0, syncs again,
              flushes buffers and returns TRUE on success FALSE on failure
    ***/

    DEBUG_FUNCTION_NAME(("T30ModemInit"));

    PSSLogEntry(PSS_MSG, 0, "Modem initialization");

    // Save the profile ID and key string.
    pTG->FComModem.dwProfileID = DEF_BASEKEY;

    uLen = min(_fstrlen(pTG->lpszPermanentLineID), sizeof(pTG->FComModem.rgchKey)-1);
    _fmemcpy(pTG->FComModem.rgchKey, pTG->lpszPermanentLineID, uLen);
    pTG->FComModem.rgchKey[uLen] = 0;

    if (!uLen)
    {
        DebugPrintEx(   DEBUG_ERR,
                        "Bad param: ProfileID=0x%lx; Key=%s",
                        (unsigned long) pTG->FComModem.dwProfileID,
                        (LPSTR) pTG->FComModem.rgchKey);
        return INIT_INTERNAL_ERROR;
    }

    InitMonitorLogging(pTG);

    //
    // Get the modem info before talking to h/w.
    //

    if(uRet = iModemGetCmdTab(  pTG, 
                                &pTG->FComModem.CurrCmdTab, 
                                &pTG->FComModem.CurrMdmCaps))
    {
        goto error;
    }

    // use MultiLine because we may get asynchronous RING responses
    // at arbitrary times when on-hook

    if(pTG->FComModem.CurrCmdTab.szSetup && (uLen=(USHORT)_fstrlen(pTG->FComModem.CurrCmdTab.szSetup)))
    {
        if(OfflineDialog2(pTG, (LPSTR)pTG->FComModem.CurrCmdTab.szSetup, uLen, cbszOK, cbszERROR) != 1)
        {
            DebugPrintEx(   DEBUG_ERR,
                            "Error in SETUP string: %s", 
                            (LPSTR)pTG->FComModem.CurrCmdTab.szSetup);
            // SETUP is usually the defaults?? So do nothing if this fails
            // uRet = INIT_MODEMERROR;
            // goto error;
        }
    }

    switch (pTG->dwSpeakerMode) 
    {
        case MDMSPKR_OFF:
            pTG->NCUParams.SpeakerControl = 0;
            break;

        case MDMSPKR_DIAL:
            pTG->NCUParams.SpeakerControl = 1;
            break;

        case MDMSPKR_ON:
            pTG->NCUParams.SpeakerControl = 2;
            break;

        default:
            pTG->NCUParams.SpeakerControl = 0;
            break;
    }

    switch (pTG->dwSpeakerVolume) 
    {
        case MDMVOL_LOW:
            pTG->NCUParams.SpeakerVolume = 0;
            break;

        case MDMVOL_MEDIUM:
            pTG->NCUParams.SpeakerVolume = 2;
            break;

        case MDMVOL_HIGH:
            pTG->NCUParams.SpeakerVolume = 3;
            break;

        default:
            pTG->NCUParams.SpeakerVolume = 0;
            break;
    }


    pTG->NCUParams.DialBlind      = 4;  //X4

    // need to do this every time after a Reset/AT&F
    if(! iModemSetNCUParams(    pTG, 
                                -1,
                                pTG->NCUParams.SpeakerControl,
                                pTG->NCUParams.SpeakerVolume,
                                pTG->NCUParams.DialBlind,
                                pTG->NCUParams.SpeakerRing))
    {
        DebugPrintEx(DEBUG_WRN,"Can't Set NCU params - Ignoring that");
    }

    // Why is this here??
    FComFlush(pTG);

    pTG->FComStatus.fModemInit = TRUE;
    uRet = INIT_OK;
    goto end;

error:
    FComClose(pTG);
    pTG->FComStatus.fModemInit = FALSE;
    // fall through...
end:
    return uRet;
}


LPCMDTAB iModemGetCmdTabPtr(PThrdGlbl pTG)
{
    return (pTG->FComStatus.fModemInit) ? &pTG->FComModem.CurrCmdTab: NULL;
}


#define PARAMSBUFSIZE   60
#define fDETECT_DIALTONE 1
#define fDETECT_BUSYTONE 2

BOOL iModemSetNCUParams
(
    PThrdGlbl pTG, 
    int comma, 
    int speaker,
    int volume, 
    int fBlind, 
    int fRingAloud
)
{

    char bBuf[PARAMSBUFSIZE];
    USHORT uLen;

    DEBUG_FUNCTION_NAME(("iModemSetNCUParams"));

    _fstrcpy(bBuf, cbszJustAT);
    uLen = sizeof(cbszJustAT)-1;

    // +++ If we want to split this into dial-tone & busy-tone we
    //         Do it here...
    if ( (fBlind >= 0) && (pTG->ModemKeyCreationId == MODEMKEY_FROM_NOTHING) )
    {
        UINT u=0;
        switch(fBlind)
        {
        case 0:
                break;
        case fDETECT_DIALTONE:
                u=2;
                break;
        case fDETECT_BUSYTONE:
                u=3;
                break;
        default:
                u=4;
                break;
        }
        uLen += (USHORT)wsprintf(bBuf+uLen, cbszXn, u);
    }

    if(comma >= 0)
    {
        if(comma > 255)
        {
            comma = 255;
        }
        uLen += (USHORT)wsprintf(bBuf+uLen, cbszS8, comma);
    }
    if(speaker >= 0)
    {
        if(speaker > 2)
        {
            speaker = 2;
        }
        uLen += (USHORT)wsprintf(bBuf+uLen, cbszMn, speaker);
    }
    if(volume >= 0)
    {
        if(volume > 3)
        {
            volume = 3;
        }
        uLen += (USHORT)wsprintf(bBuf+uLen, cbszLn, volume);
    }

    // do something with RingAloud

    bBuf[uLen++] = '\r';
    bBuf[uLen] = 0;

    // use MultiLine because we may get asynchronous RING responses
    // at arbitrary times when on-hook
    if(OfflineDialog2(pTG, (LPSTR)bBuf, uLen, cbszOK, cbszERROR) != 1)
    {
        DebugPrintEx(DEBUG_ERR,"Can't Set NCU params");
        return FALSE;
    }
    return TRUE;
}

UWORD GetCap(PThrdGlbl pTG, CBPSTR cbpstrSend, UWORD uwLen)
{
    UWORD uRet1=0, uRet2=0, uRet3=0;

    DEBUG_FUNCTION_NAME(("GetCap"));
    // We call GetCapAux twice and if they don't match we
    // call it a 3rd time and arbitrate. Provided it doesn't
    // fail the first time.
    if (!(uRet1=GetCapAux(pTG, cbpstrSend, uwLen))) 
        goto end;

    uRet2=GetCapAux(pTG, cbpstrSend, uwLen);
    if (uRet1!=uRet2)
    {
        DebugPrintEx(   DEBUG_WRN,
                        "2nd getcaps return differs 1=%u,2=%u",
                        (unsigned)uRet1,
                        (unsigned)uRet2);

        uRet3=GetCapAux(pTG, cbpstrSend, uwLen);
        if (uRet1==uRet2 || uRet1==uRet3) 
        {
            goto end;
        }
        else if (uRet2==uRet3)
        {
            uRet1=uRet2; 
            goto end;
        }
        else
        {
            DebugPrintEx(   DEBUG_ERR,
                            "all 2 getcaps differ! 1=%u,2=%u, 3=%u",
                            (unsigned) uRet1, (unsigned) uRet2,
                            (unsigned) uRet3);
        }
    }

end: 
    return uRet1;

}

UWORD GetCapAux(PThrdGlbl pTG, CBPSTR cbpstrSend, UWORD uwLen)
{
    NPSTR sz;
    BYTE  speed, high;
    UWORD i, code;
    USHORT  retry;
    USHORT  uRet;

    DEBUG_FUNCTION_NAME(("GetCapAux"));
    retry = 0;
restart:
    retry++;
    if(retry > 2)
            return 0;

    DebugPrintEx(DEBUG_MSG,"Want Caps for (%s)", (LPSTR)cbpstrSend);

    pTG->fMegaHertzHack = TRUE;
    uRet = OfflineDialog2(pTG, (LPSTR)cbpstrSend, uwLen, cbszOK, cbszERROR);
    pTG->fMegaHertzHack=FALSE;

    // sometimes we don't get the OK so try to parse what we got anyway
    DebugPrintEx(DEBUG_MSG,"LastLine = (%s)",(LPSTR)(&(pTG->FComModem.bLastReply)));

    if(uRet == 2)
            goto restart;

    if(_fstrlen((LPSTR)pTG->FComModem.bLastReply) == 0)
            goto restart;

    speed = 0;
    high = 0;
    for(i=0, sz=pTG->FComModem.bLastReply, code=0; i<REPLYBUFSIZE && sz[i]; i++)
    {
            if(sz[i] >= '0' &&  sz[i] <= '9')
            {
                    code = code*10 + (sz[i] - '0');
                    continue;
            }
            // reached a non-numeric char
            // if its teh first after a code, need to process the code.

            switch(code)
            {
            case 0:  continue;      // not the first char after a code
            case 3:  break;
            case 24: break;
            case 48: speed |= V27; break;
            case 72:
            case 96: speed |= V29; break;
            case 73:
            case 97:
            case 121:
            case 145: speed |= V33; break;  // long-train codes
            case 74:
            case 98:
            case 122:
            case 146: speed |= V17; break;  // short-train codes

            //case 92:
            //case 93:      break;
            // case 120: // not legal
            // case 144: // not legal
            default:
                            DebugPrintEx(   DEBUG_WRN,
                                            "Ignoring unknown Modulation code = %d",
                                            code);
                            code=0;
                            break;
            }
            if(code > high)
                    high=(BYTE)code;

            // reset code counter after processing the baud rate code
            code = 0;
    }

    if(speed == 0)
    {
        // got garbage in response to query
        DebugPrintEx(   DEBUG_MSG,
                        "Can't get Caps for (%s) = 0x%04x  Highest=%d", 
                        (LPSTR)cbpstrSend, 
                        speed, 
                        high);
        return 0;
    }

    if(speed == 0x0F) 
        speed = V27_V29_V33_V17;

    DebugPrintEx(   DEBUG_MSG,
                    "Got Caps for (%s) = 0x%04x  Highest=%d", 
                    (LPSTR)cbpstrSend, 
                    speed, 
                    high);

    return MAKEWORD(speed, high);   // speed==low byte
}

BOOL iModemGetCaps
(
    PThrdGlbl pTG, 
    LPMODEMCAPS lpMdmCaps, 
    DWORD dwSpeed, 
    LPSTR lpszReset,
    LPDWORD lpdwGot
)
{
    /** Modem must be synced up and in normal (non-fax) mode.
            Queries available classes,
            HDLC & Data receive and transmit speeds. Returns
            TRUE if Modem is Class1 or Class2, FALSE if not fax modem
            or other error. Sets the fields in the ET30INST struct **/
    // lpszReset, if nonempty, will be used to reset the modem after
    // the FCLASS=? command see comment about US Robotics Sportster below...

    UWORD   i, uwRet;
    BYTE    speed;
    BOOL    err;
    NPSTR   sz;
    USHORT  retry, uResp;

    DEBUG_FUNCTION_NAME(("iModemGetCaps"));
    if (!*lpdwGot) 
    {
        _fmemset(lpMdmCaps, 0, sizeof(MODEMCAPS));
    }

    if (*lpdwGot & fGOTCAP_CLASSES) 
        goto GotClasses;

    for(retry=0; retry<2; retry++)
    {
        pTG->fMegaHertzHack = TRUE;
        uResp = OfflineDialog2(pTG, (LPSTR)cbszQUERY_CLASS, sizeof(cbszQUERY_CLASS)-1, cbszOK, cbszERROR);
        pTG->fMegaHertzHack=FALSE;
        if(uResp != 2)
                break;
    }

    // sometimes we don't get the OK so try to parse what we got anyway
    DebugPrintEx(   DEBUG_MSG, 
                    "LastLine = (%s)", 
                    (LPSTR)(&(pTG->FComModem.bLastReply)));


    lpMdmCaps->uClasses = 0;
    for(i=0, sz=pTG->FComModem.bLastReply; i<REPLYBUFSIZE && sz[i]; i++)
    {
        UINT uDig=0, uDec=(UINT)-1;

        // This code will accept 1.x as class1, 2 as class2 and 2.x as class2.0
        // Also, it will not detect class 1 in 2.1 or class2 in 1.2 etc.
        // (JDecuir newest class2.0 is labeled class2.1, and he talks
        //  of class 1.0...)
        if(sz[i] >= '0' && sz[i] <= '9')
        {
            uDig = sz[i]- '0';
            if (sz[i+1]=='.')
            {
                i++;
                if(sz[i+1] >= '0' && sz[i+1] <= '9')
                {
                    uDec = sz[i] - '0';
                    i++;
                }
            }
        }
        if(uDig==1) 
        {
            lpMdmCaps->uClasses |= FAXCLASS1;
        }
        if(uDig==2) 
        {
            if (uDec==((UINT)-1)) 
            {
                lpMdmCaps->uClasses |= FAXCLASS2;
            }
            else
            {
                lpMdmCaps->uClasses |= FAXCLASS2_0;
            }
        }
    }
    *lpdwGot |= fGOTCAP_CLASSES;

GotClasses:

    if(!lpMdmCaps->uClasses)
    {
        DebugPrintEx(DEBUG_ERR,"Not a fax modem or unsupported fax class");
        *lpdwGot &= ~(fGOTCAP_CLASSES|fGOTCAP_SENDSPEEDS|fGOTCAP_RECVSPEEDS);
        return FALSE;
    }

    if(!(lpMdmCaps->uClasses & FAXCLASS1)) 
        return TRUE;

///////////////// rest is for Class1 only //////////////////////////

    if(lpszReset && *lpszReset && iModemReset(pTG, lpszReset) < 0) 
        return FALSE;
    //////////

    if(!iiModemGoClass(pTG, 1, dwSpeed)) 
        goto NotClass1;

    err = FALSE;
    if (!(*lpdwGot & fGOTCAP_SENDSPEEDS))
    {
        uwRet = GetCap( pTG, cbszQUERY_FTM, sizeof(cbszQUERY_FTM)-1);
        err = (err || uwRet==0);
        speed = LOBYTE(uwRet);
        lpMdmCaps->uSendSpeeds = speed;
        *lpdwGot |= fGOTCAP_SENDSPEEDS;
    }
    if (!(*lpdwGot & fGOTCAP_RECVSPEEDS))
    {
        uwRet = GetCap(pTG, cbszQUERY_FRM, sizeof(cbszQUERY_FRM)-1);
        err = (err || uwRet==0);
        speed = LOBYTE(uwRet);
        lpMdmCaps->uRecvSpeeds = speed;
        *lpdwGot |= fGOTCAP_RECVSPEEDS;
    }

    if(!iiModemGoClass(pTG, 0, dwSpeed))
        err = TRUE;

    if(err)
    {
        DebugPrintEx(DEBUG_ERR,"Cannot get capabilities");
        goto NotClass1;
    }

    DebugPrintEx(DEBUG_MSG,"Got Caps");
    return TRUE;

NotClass1:
    // Reported Class1 but failed AT+FCLASS=1 or one of the Cap queries
    // GVC9624Vbis does this. See bug#1016
    // FIX: Just zap out the Class1 bit. If any other class supported
    // then return TRUE, else FALSE

    lpMdmCaps->uClasses &= (~FAXCLASS1);    // make the Class1 bit==0
    if(lpMdmCaps->uClasses)
    {
        return TRUE;
    }
    else
    {
        *lpdwGot &= ~(fGOTCAP_CLASSES|fGOTCAP_SENDSPEEDS|fGOTCAP_RECVSPEEDS);
        return FALSE;
    }
}

BOOL iModemGoClass(PThrdGlbl pTG, USHORT uClass)
{
    return iiModemGoClass(pTG, uClass, pTG->FComModem.CurrCmdTab.dwSerialSpeed);
}


BOOL iiModemGoClass(PThrdGlbl pTG, USHORT uClass, DWORD dwSpeed)
{
    int i;
    USHORT uBaud;
    
    DEBUG_FUNCTION_NAME(("iiModemGoClass"));

    for(i=0; i<3; i++)
    {
        // UDS V.3257 modem needs this time, because if we send it a
        // command too quickly after the previous response, it ignores
        // it or gets garbage
        Sleep(100);
        FComFlush(pTG);
        PSSLogEntry(PSS_MSG, 2, "send: \"%s\"", rgcbpstrGO_CLASS[uClass]);
        if(!FComDirectSyncWriteFast(pTG, (LPB)rgcbpstrGO_CLASS[uClass], uLenGO_CLASS[uClass]))
            goto error;
        // wait 500ms. Give modem enough time to get into Class1 mode
        // otherwise the AT we send may abort the transition
        Sleep(500);

        if(dwSpeed)
        {
            USHORT usSpeed  = (USHORT) dwSpeed;
            uBaud = usSpeed;
        }
        else if (pTG->SerialSpeedInit) 
        {
           uBaud = pTG->SerialSpeedInit;
        }
        else 
        {
           uBaud = 57600;
        }

        // RSL don't do hard-coded 2400 for class0.

        FComSetBaudRate(pTG, uBaud);

        FComFlush(pTG);
        if(iModemSync(pTG) >= 0)
        {
            return TRUE;
        }
    }
error:
    // no point -- and we'll smash our settings
    // iModemReset();
    // error is already set to ERR_NO_RESPONSE inside HayesSync()
    DebugPrintEx(DEBUG_ERR,"Cant go to Class %d", uClass);
    return FALSE;
}

BOOL iModemClose(PThrdGlbl pTG)
{
    USHORT uLen;
    BOOL fRet=FALSE;

    DEBUG_FUNCTION_NAME(("iModemClose"));

    if(!pTG->FComStatus.fModemInit)
        return TRUE;


    /** Hangs up the phone if it is off hook, closes the COM port
            and returns. If hangup fails then port is also left open. **/


    if(!iModemHangup(pTG))
        goto lNext;


    if (pTG->Comm.fEnableHandoff &&  pTG->Comm.fDataCall) 
    {
        goto lNext;
    }

    if(pTG->FComModem.CurrCmdTab.szExit && (uLen=(USHORT)_fstrlen(pTG->FComModem.CurrCmdTab.szExit)))
    {
        if(OfflineDialog2(pTG, (LPSTR)pTG->FComModem.CurrCmdTab.szExit, uLen, cbszOK, cbszERROR) != 1)
        {
            DebugPrintEx(   DEBUG_ERR,
                            "Error in EXIT string: %s", 
                            (LPSTR)pTG->FComModem.CurrCmdTab.szExit);
        }
    }

lNext:
    if(FComClose(pTG))
    {
        pTG->FComStatus.fModemInit = FALSE;
        fRet=TRUE;
    }

    return fRet;
}

BOOL iModemHangup(PThrdGlbl pTG)
{
    BOOL fRet=FALSE;

    DEBUG_FUNCTION_NAME(("iModemHangup"));

    if(!pTG->FComStatus.fOffHook) 
    {
        DebugPrintEx(   DEBUG_WRN,
                        "The modem is already on-hook!!!! return without doing nothing");
        return TRUE;
    }

    // Note: iModemHangup is called by NCULink in ddi.c.
    // Rather than do adaptive-answer-specific code in ddi.c as well,
    // we simply ignore the hangup command in the following case...

    if (pTG->Comm.fEnableHandoff &&  pTG->Comm.fDataCall)
    {
        DebugPrintEx(DEBUG_WRN,"IGNORING Hangup of datamodem call");
            return TRUE;
    }

    PSSLogEntry(PSS_MSG, 1, "Hanging up");

    // FComDTR(FALSE);              // Lower DTR to hangup in ModemHangup
                                            // Need to have &D2 in init string for this.

    // Do this twice. There is a bizarre case where you drop DTR,
    // then go into Dialog, flush, send ATH0, then the modem gives
    // you an OK for the DTR, and you take it as one for the ATH0
    // maybe that's ok....if this gets too slow, skip this.
    HayesSyncSpeed(pTG, cbszHANGUP, sizeof(cbszHANGUP)-1);

    if(HayesSyncSpeed(pTG, cbszHANGUP, sizeof(cbszHANGUP)-1) < 0)
    {
        FComDTR(pTG, FALSE);         // Lower DTR on stubborn hangups in ModemHangup
        Sleep(1000);    // pause 1 second
        FComDTR(pTG, TRUE);          // raise it again. Some modems return to cmd state
                                                // only when this is raised again

        if(iModemReset(pTG, pTG->FComModem.CurrCmdTab.szReset) < 0)
            goto error;
        if(HayesSyncSpeed(pTG, cbszHANGUP, sizeof(cbszHANGUP)-1) < 0)
            goto error;
    }
    pTG->FComStatus.fOffHook = FALSE;

    if(!iiModemGoClass(pTG, 0, pTG->FComModem.CurrCmdTab.dwSerialSpeed))
        goto end;
            // Can also ignore this return value. Just for tidier cleanup

    // Avoid! we'll smash our settings
    // iModemReset();
    fRet=TRUE;
    goto end;

error:
    FComDTR(pTG, TRUE);          // raise it again
    // fall through...

end:
    return fRet;
}

/*++
Routine Description:
    Print the dial command to PSS log, hiding the actual number, like this: "ATDT ####"
Arguments:
    pTG
    lpszFormat - format for sprintf, usually #defined as "ATD%c %s"
    chMod - Dial mode ('T' or 'P')
    iLen - Length of number
Return Value:
    None    
 --*/

void LogDialCommand(PThrdGlbl pTG, LPSTR lpszFormat, char chMod, int iLen)
{
    BYTE    bBufHideDest[DIALBUFSIZE] = {'\0'};
    int i;

    sprintf(bBufHideDest, lpszFormat, chMod, TEXT(""));
    if (_tcslen(bBufHideDest)+iLen > DIALBUFSIZE-1)
    {   // Not enough room - don't log!
        return;
    }
    for (i=0; i<iLen; i++)
    {
        strcat(bBufHideDest, "#");
    }
    PSSLogEntry(PSS_MSG, 2, "send: \"%s\"", bBufHideDest);
}


USHORT iModemDial(PThrdGlbl pTG, LPSTR lpszDial)
{
    ULONG   ulTimeout;
    USHORT  uRet, uLen, uDialStringLen;
    BYTE    bBuf[DIALBUFSIZE];
    CBPSTR  cbpstr;
    char    chMod = pTG->NCUParams.chDialModifier;
    DWORD   dwDialTime = 0;
    char    KeyName[200];
    HKEY    hKey;
    char    BlindDialString[200];
    char    RegBlindDialString[200];
    long    lRet;
    DWORD   dwSize;
    DWORD   dwType;

    DEBUG_FUNCTION_NAME(("iModemDial"));
    
    pTG->FComStatus.fOffHook = TRUE;     // Has to be here. Can get an error return
                                         // below even after connecting
                                         // and we want to hangup after that!!
    pTG->Comm.fDataCall=FALSE;

    //
    // check "Modems->Properties->Connection->Wait for dial tone" setting before dialing
    // to correctly set ATX to possibly blind dial
    //
    if (pTG->fBlindDial) 
    {
       // create default string
       sprintf(BlindDialString, "ATX3\r");
       
       // need to check Unimodem Settings\Blind_On key. 
       sprintf(KeyName, "%s\\Settings", pTG->lpszUnimodemKey);

       lRet = RegOpenKeyEx(
                       HKEY_LOCAL_MACHINE,
                       KeyName,
                       0,
                       KEY_READ,
                       &hKey);
   
       if (lRet != ERROR_SUCCESS) 
       {
          DebugPrintEx(DEBUG_ERR, "Can't read Unimodem Settings key %s", KeyName);
       }
       else 
       {
          dwSize = sizeof(RegBlindDialString); 

          lRet = RegQueryValueEx(
                     hKey,
                     "Blind_On",
                     0,
                     &dwType,
                     RegBlindDialString,
                     &dwSize);

          RegCloseKey(hKey);

          if (lRet != ERROR_SUCCESS) 
          {
              DebugPrintEx( DEBUG_ERR, 
                            "Can't read Unimodem key\\Settings\\Blind_On value");
          }
          else if (RegBlindDialString) 
          {
             sprintf(BlindDialString, "AT%s\r", RegBlindDialString);
          }
       }
    }

    if(!iiModemGoClass(pTG, 1, pTG->FComModem.CurrCmdTab.dwSerialSpeed))
    {
        uRet = CONNECT_ERROR;
        goto error;
    }

    //
    // blind dial set here if requested by user
    //
    if (pTG->fBlindDial && BlindDialString) 
    {
       uLen = (USHORT)strlen(BlindDialString);
       if(OfflineDialog2(pTG, BlindDialString, uLen, cbszOK, cbszERROR) != 1)
       {
           DebugPrintEx(    DEBUG_ERR,
                            "Error in BLIND DIAL string: %s", 
                            BlindDialString);
       }
    }

    if(pTG->FComModem.CurrCmdTab.szPreDial && (uLen=(USHORT)_fstrlen(pTG->FComModem.CurrCmdTab.szPreDial)))
    {
        if(OfflineDialog2(pTG, (LPSTR)pTG->FComModem.CurrCmdTab.szPreDial, uLen, cbszOK, cbszERROR) != 1)
        {
            DebugPrintEx(   DEBUG_ERR,
                            "Error in PREDIAL string: %s", 
                            (LPSTR)pTG->FComModem.CurrCmdTab.szPreDial);
        }
    }

    cbpstr = cbszDIAL;

    // If the dial string already has a T or P prefix, we use that
    // instead.
    {
        char c=0;
        while((c=*lpszDial) && c==' ')
        {
            lpszDial++;
        }

        if (c=='t'|| c=='T' || c=='p'|| c=='P')
        {
            chMod = c;
            lpszDial++;
            while((c=*lpszDial) && c==' ')
            {
                lpszDial++;
            }
        }
    }

    // in mdmcmds.h you can find this line: cbszDIAL = "ATD%c %s\r"
    uLen = (USHORT)wsprintf(bBuf, cbpstr, chMod, (LPSTR)lpszDial);

    // Need to set an approriate timeout here. A minimum of 15secs is too short
    // (experiment calling machines within a PABX), plus one has to give extra
    // time for machines that pick up after 2 or 4 rings and also for long distance
    // calls. I take a minumum of 30secs and add 3secs for each digits over 7
    // (unless it's pulse dial in which case I add 8secs/digit).
    // (I'm assuming that a long-distance call will take a minimum of 8 digits
    // anywhere in ths world!). Fax machines I've tested wait about 30secs
    // independent of everything.

    uDialStringLen = (USHORT)_fstrlen(lpszDial);

    ulTimeout = DIAL_TIMEOUT;
    if(uDialStringLen > 7)
    {
            ulTimeout += ((chMod=='p' || chMod=='P')?8000:3000)
                                     * (uDialStringLen - 7);
    }


    pTG->FComStatus.fInDial = TRUE;
    // look for MultiLine, just in case we get echo or garbage.
    // Nothing lost, since on failure of this we can't do anything

    // uRet = iiModemDialog((LPB)bBuf, uLen, ulTimeout, TRUE, 1, TRUE,
    //                                       cbszCONNECT, cbszBUSY, cbszNOANSWER,
    //                                       cbszNODIALTONE, cbszERROR, (CBPSTR)NULL);
    // Send seperately & use iiModemDialog only for the response

    // all this just to send the ATDT
    FComFlushOutput(pTG);
    Sleep(200);     // 100 is not too long for this IMPORTANT one!
    FComFlushInput(pTG);

    LogDialCommand(pTG, cbszDIAL, chMod, uDialStringLen);

    FComDirectAsyncWrite(pTG, bBuf, uLen);
    // now try to get a response
    dwDialTime = GetTickCount();
    uRet = iiModemDialog(   pTG, 
                            0, 
                            0, 
                            ulTimeout, 
                            TRUE, 
                            1, 
                            TRUE,
                            cbszCONNECT, 
                            cbszBUSY, 
                            cbszNOANSWER,
                            cbszNODIALTONE, 
                            cbszERROR, 
                            cbszBLACKLISTED,
                            cbszDELAYED,
                            cbszNOCARRIER, 
                            (CBPSTR)NULL);

    pTG->FComStatus.fInDial = FALSE;
    DebugPrintEx(DEBUG_MSG,"ModemDial -- got %d response from Dialog", uRet);


#if !((CONNECT_TIMEOUT==0) && (CONNECT_OK==1) && (CONNECT_BUSY==2) && (CONNECT_NOANSWER == 3) && (CONNECT_NODIALTONE==4) && (CONNECT_ERROR==5) && (CONNECT_BLACKLISTED==6) && (CONNECT_DELAYED==7))
#error CONNECT defines not correct ERROR, OK, BUSY, NOANSWER, NODIALTONE == CONNECT_ERROR, CONNECT_OK, CONNECT_BUSY, CONNECT_NOANSWER, CONNECT_NODIALTONE
#else
#pragma message("verified CONNECT defines")
#endif


    switch(uRet)
    {
    case CONNECT_TIMEOUT:
        pTG->fFatalErrorWasSignaled = 1;
        SignalStatusChange(pTG, FS_NO_ANSWER);
        PSSLogEntry(PSS_ERR, 1, "Response - timeout");
        break;

    case CONNECT_OK:
        PSSLogEntry(PSS_MSG, 1, "Response - CONNECT");
        pTG->fReceivedHDLCflags = TRUE;
        break;

    case CONNECT_BUSY:
        pTG->fFatalErrorWasSignaled = 1;
        SignalStatusChange(pTG, FS_BUSY);
        PSSLogEntry(PSS_ERR, 1, "Response - BUSY");
        break;

    case CONNECT_NOANSWER:
        pTG->fFatalErrorWasSignaled = 1;
        SignalStatusChange(pTG, FS_NO_ANSWER);
        PSSLogEntry(PSS_ERR, 1, "Response - NO ANSWER");
        break;

    case CONNECT_NODIALTONE:
        pTG->fFatalErrorWasSignaled = 1;
        SignalStatusChange(pTG, FS_NO_DIAL_TONE);
        PSSLogEntry(PSS_ERR, 1, "Response - NO DIALTONE");
        break;

    case CONNECT_ERROR:
        pTG->fFatalErrorWasSignaled = 1;
        SignalStatusChange(pTG, FS_NO_ANSWER);
        PSSLogEntry(PSS_ERR, 1, "Response - ERROR");
        break;

    case CONNECT_BLACKLISTED:
        pTG->fFatalErrorWasSignaled = 1;
        SignalStatusChange(pTG, FS_CALL_BLACKLISTED);
        PSSLogEntry(PSS_ERR, 1, "Response - BLACKLISTED");
        break;

    case CONNECT_DELAYED:
        pTG->fFatalErrorWasSignaled = 1;
        SignalStatusChange(pTG, FS_CALL_DELAYED);
        PSSLogEntry(PSS_ERR, 1, "Response - DELAYED");
        break;

    case 8: {
                DWORD dwDelta = GetTickCount() - dwDialTime;
                PSSLogEntry(PSS_ERR, 1, "Response - NO CARRIER");
                if (dwDelta < 5000L)
                {
                    DebugPrintEx(DEBUG_WRN,"Dial: Pretending it's BUSY");
                    pTG->fFatalErrorWasSignaled = 1;
                    SignalStatusChange(pTG, FS_BUSY);
                    uRet = CONNECT_BUSY;
                }
                else
                {
                    DebugPrintEx(DEBUG_WRN,"Dial: Pretending it's TIMEOUT");
                    pTG->fFatalErrorWasSignaled = 1;
                    SignalStatusChange(pTG, FS_NO_ANSWER);
                    uRet = CONNECT_TIMEOUT;
                }
            }
            break;

    }

    if(uRet == CONNECT_OK)
    {
            goto done;
    }
    else
    {
            if(uRet == CONNECT_TIMEOUT)     
            {
                pTG->fFatalErrorWasSignaled = 1;
                SignalStatusChange(pTG, FS_NO_ANSWER);

                uRet = CONNECT_NOANSWER;
                    // call it a no answer
            }

            goto error;
    }

error:
    if(!iModemHangup(pTG))
    {
        // at this point in teh production version we
        // need to call some OS reboot function!!
        DebugPrintEx(DEBUG_ERR,"Can't Hangup after DIALFAIL");
        uRet = CONNECT_ERROR;
    }
    // fall through
done:
    return uRet;
}


USHORT   iModemAnswer(PThrdGlbl pTG)
{
    CBPSTR  cbpstr;
    USHORT  uLen, uRet;
    char    Command[400];
    int     i;

    DEBUG_FUNCTION_NAME(("iModemAnswer"));

    pTG->FComStatus.fOffHook=TRUE;       // Has to be here. Can screwup after answering
                                                            // but before CONNECT and we want to hangup
                                                            // after that!!
    pTG->Comm.fDataCall=FALSE;

    //
    // below is Adaptive Answer handling. 
    // It is separate because all the commands are defined via INF
    //

    if (pTG->AdaptiveAnswerEnable) 
    {
       for (i=0; i< (int) pTG->AnswerCommandNum; i++) 
       {
          strcpy  (Command, pTG->AnswerCommand[i] );

          if (i == (int) pTG->AnswerCommandNum - 1) 
          {
             // last command-answer
             FComFlushOutput(pTG);
             Sleep(200);     // 100 is not too long for this IMPORTANT one!
             FComFlushInput(pTG);

             PSSLogEntry(PSS_MSG, 2, "send: \"%s\"", Command);
             FComDirectAsyncWrite(pTG, (LPSTR) Command, (USHORT) strlen(Command) );

             pTG->FComStatus.fInAnswer = TRUE;
             
             break;

          }


          if( (uRet = OfflineDialog2(pTG, (LPSTR) Command, (USHORT) strlen(Command), cbszOK, cbszERROR) ) != 1)    
          {
              DebugPrintEx(DEBUG_ERR, "Answer %d=%s FAILED", i, Command);
          }
          else 
          {
              DebugPrintEx(DEBUG_MSG, "Answer %d=%s rets OK", i, Command);
          }
       }

       uRet=iModemGetAdaptiveResp(pTG);
       pTG->FComStatus.fInAnswer=FALSE;
       if (uRet==CONNECT_OK) 
           goto done;
       else          
           goto error;
    }

    //
    // assuming FAX call since can't determine that anyway...
    //
    else
    {
            // 5/95 JosephJ:Elliot Bug#3421 -- we issue the AT+FCLASS=1 command
            //      twice so that if one gets zapped by a RING the other will
            //          be OK.
            if (pTG->FComModem.CurrCmdTab.dwFlags&fMDMSP_ANS_GOCLASS_TWICE)
                    iiModemGoClass(pTG, 1, pTG->FComModem.CurrCmdTab.dwSerialSpeed);
            if(!iiModemGoClass(pTG, 1, pTG->FComModem.CurrCmdTab.dwSerialSpeed))
            {
                    uRet = CONNECT_ERROR;
                    goto error;
            }
    }

    if(pTG->FComModem.CurrCmdTab.szPreAnswer && (uLen=(USHORT)_fstrlen(pTG->FComModem.CurrCmdTab.szPreAnswer)))
    {
            if(OfflineDialog2(pTG, (LPSTR)pTG->FComModem.CurrCmdTab.szPreAnswer, uLen, cbszOK, cbszERROR) != 1)
            {
                    DebugPrintEx(   DEBUG_WRN,
                                    "Error on PREANSWER string: %s", 
                                    (LPSTR)pTG->FComModem.CurrCmdTab.szPreAnswer);
            }
    }



#define ANSWER_TIMEOUT 40000                            // Random Timeout
// Need to wait reasonably long, so that we don't give up too easily

    cbpstr = cbszANSWER;
    uLen = sizeof(cbszANSWER)-1;

    pTG->FComStatus.fInAnswer = TRUE;

    // if(!iModemDialog((LPSTR)cbpstr, uLen, ANSWER_TIMEOUT, cbszCONNECT))
    // look for MultiLine, just in case we get echo or garbage.
    // Nothing lost, since on failure of this we can't do anything

    // if(!iiModemDialog((LPB)cbpstr, uLen, ANSWER_TIMEOUT, TRUE, 1, TRUE,
    //                                       cbszCONNECT, (CBPSTR)NULL))
    // Send seperately & use iiModemDialog only for the response

    // all this just to send the ATA


    FComFlushOutput(pTG);
    Sleep(200);     // 100 is not too long for this IMPORTANT one!
    FComFlushInput(pTG);
    PSSLogEntry(PSS_MSG, 2, "send: \"%s\"", cbpstr);
    FComDirectAsyncWrite(pTG, cbpstr, uLen);

    // this is used to complete a whole IO operation (presumably a short one)
    // when this flag is set, the IO won't be disturbed by the abort event
    // this flag should NOT be set for long periods of time since abort
    // is disabled while it is set.
    pTG->fStallAbortRequest = TRUE;
    // now try to get a response
    
    if(!iiModemDialog(pTG, 0, 0, ANSWER_TIMEOUT, TRUE, 1, TRUE, cbszCONNECT, (CBPSTR)NULL))
    {
        pTG->FComStatus.fInAnswer = FALSE;
        PSSLogEntry(PSS_ERR, 1, "Response - ERROR");

        // try to hangup and sync with modem. This should work
        // even if phone is not really off hook
        uRet = CONNECT_ERROR;
        goto error;
    }
    else
    {
        pTG->FComStatus.fInAnswer = FALSE;
        PSSLogEntry(PSS_MSG, 1, "Response - CONNECT");

        uRet = CONNECT_OK;
        goto done;
    }

error:

    if (pTG->Comm.fEnableHandoff && uRet==CONNECT_WRONGMODE_DATAMODEM)
    {
        // We won't hangup.
        // We deliberately leave pTG->FComStatus.fOffHook to TRUE, because
        // it is off hook.
        goto done;
    }

    if(!iModemHangup(pTG))
    {
        // at this point in teh production version we need to
        // call some OS reboot function!!
        DebugPrintEx(DEBUG_ERR,"Can't Hangup after ANSWERFAIL");
        uRet = CONNECT_ERROR;
    }
    // fall through

done:
    return uRet;

}


int my_strcmp(LPSTR sz1, LPSTR sz2)
{

   if ( (sz1 == NULL) || (sz2 == NULL) ) 
   {
       return FALSE;
   }

   if ( strcmp(sz1, sz2) == 0 ) 
   {
      return TRUE;
   }

   return FALSE;

}


BOOL fHasNumerals(PThrdGlbl pTG, LPSTR sz)
{
        int i;

        if (sz == NULL) 
        {
            return FALSE;
        }

        for(i=0; sz[i]; i++)
        {
                if(sz[i] >= '0' && sz[i] <= '9')
                        return TRUE;
        }
        return FALSE;
}


#define DIALOGRETRYMIN  600
#define SECONDLINE_TIMEOUT      500
#define ABORT_TIMEOUT    250
#ifdef DEBUG
#       define DEFMONVAL 1
#else   //!DEBUG
#       define DEFMONVAL 0
#endif  //!DEBUG
#define szMONITOREXISTINGFILESIZE "MonitorMaxOldSizeKB"
#define szMONITORDIR                      "MonitorDir"


UWORD far iiModemDialog
(   PThrdGlbl pTG, 
    LPSTR szSend, 
    UWORD uwLen, 
    ULONG ulTimeout,
    BOOL fMultiLine, 
    UWORD uwRepeatCount, 
    BOOL fPause,
    CBPSTR cbpstrWant1, 
    CBPSTR cbpstrWant2,
    ...
)
{
        /** Takes a command string, and it's lengt writes it out to the modem
            and tries to get one of the allowed responses. It writes the command
                out, waits ulTimeOut millisecs for a response. If it gets one of the
                expected responses it returns immediately.

                If it gets an unexpected/illegal response it tries (without any
                waiting) for subsequent lines to the same response.     When all the
                lines (if > 1) of the response lines are exhausted, if none is among the
                expected responses, it writes the command again and tries again,
                until ulTimeout has expired. Note that if no response is received,
                the command will be written just once.

                The whole above thing will be repeated upto uwRepeatCount times
                if uwRepeatCount is non-zero

<<<<<NOTE:::uwRepeatCount != 0 should not be used except for local sync>>>>>

                It returns when (a) one of the specified responses is received or
                (b) uwRepeatCount tries have failed (each having returned an
                illegal response or having returned no response in ulTimeout
                millsecs) or (c) the command write failed, in which
                case it returns immediately.

                It flushes the modem inque before each Command Write.

                Returns 0 on failure and the 1 based index of the successful
                response on     success.

                This can be used in the following way:-

                for Local Dialogs (AT, AT+FTH=? etc), set ulTimeout to a lowish
                value, of the order of the transmission time of the longest
                possible (erroneous or correct) line of response plus the size
                of the command. eg. at 1200baud we have about 120cps = about
                10ms/char. Therefore a timeout of about 500ms is more than
                adequate, except for really long command lines.

                for Local Sync dialogs, used to sync up with the modem which may
                be in an unsure state, use the same timeout, but also a repeat
                count of 2 or 3.

                for remote-driven dialogs, eg. AT+FRH=xx which returns a CONNECT
                after the flags have been received, and which may incur a delay
                before a response (ATDT is teh same. CONNECT is issued after a
                long delay & anything the DTE sends will abort the process).
                For these cases the caller should supply a long timeout and
                probably a repeatcount of 1, so that the
                routine will timeout after one try but go on issuing teh command
                as long as an error repsonse is received.

                For +FRH etc, the long timeout should be T1 or T2 in teh case of
                CommandRecv and ResponseRecv respectively.

        **/


    BYTE bReply[REPLYBUFSIZE];
    UWORD   i, j, uwRet, uwWantCount;
    SWORD   swNumRead;
    CBPSTR  rgcbszWant[10];
    va_list ap;
    LPTO    lpto, lptoRead, lpto0;
    BOOL    fGotFirstLine, fFirstSend;
    ULONG   ulLeft;
    UINT    uPos=0;

    DEBUG_FUNCTION_NAME(("iiModemDialog"));
    pTG->FComModem.bEntireReply[0]=0;

    // ensure that we'll abort in FComm only on fresh calls to NCUAbort
    // protecting ourselves against this var being randomly left set.
    // Note we check this variable _just_ before calling ModemDialog
    // in NCUDial and NCUAnswer & assuming atomicity between then and here
    // we'll never miss an abort in a Dial/Answer

    // extract the (variable length) list of acceptable responses.
    // each is a CBSZ, code based 2 byte ptr

    // first response always present
    rgcbszWant[1] = cbpstrWant1;

    if((rgcbszWant[2] = cbpstrWant2) != NULL)
    {
        // if more than one response
        va_start(ap, cbpstrWant2);
        for(j=3; j<10; j++)
        {
                if((rgcbszWant[j] = va_arg(ap, CBPSTR)) == NULL)
                        break;
        }
        uwWantCount = j-1;
        va_end(ap);
    }
    else
    {
        uwWantCount = 1;
    }

    if(szSend)
    {
        DebugPrintEx(   DEBUG_MSG, 
                        "Dialog: Send (%s) len=%d WantCount=%d time=%ld rep=%d", 
                        (LPSTR)szSend,
                        uwLen, 
                        uwWantCount, 
                        ulTimeout, 
                        uwRepeatCount);
    }
    else
    {
        DebugPrintEx(   DEBUG_MSG, 
                        "Response: WantCount=%d time=%ld rep=%d",
                        uwWantCount, 
                        ulTimeout, 
                        uwRepeatCount);
    }
    for(j=1; j<=uwWantCount; j++)
    {
        DebugPrintEx(DEBUG_MSG,"Want %s",(LPSTR)(rgcbszWant[j]));
    }

    lpto = &(pTG->FComModem.toDialog);
    lpto0 = &(pTG->FComModem.toZero);
    pTG->FComStatus.fInDialog = TRUE;

    // Try the dialog upto uwRepeatCount times
    for(uwRet=0, i=0; i<uwRepeatCount; i++)
    {
        startTimeOut(pTG, lpto, ulTimeout);
        fFirstSend = TRUE;
        do
        {
            if(szSend)
            {
                if(!fFirstSend)
                {
                    ulLeft = leftTimeOut(pTG, lpto);
                    if(ulLeft <= DIALOGRETRYMIN)
                    {
                        DebugPrintEx(DEBUG_MSG,"ulLeft=%ul too low",ulLeft);
                        break;
                    }
                    else
                    {
                        DebugPrintEx(DEBUG_MSG,"ulLeft=%ul OK",ulLeft);
                    }
                }
                fFirstSend = FALSE;

                // If a command is supplied, write it out, flushing input
                // first to get rid of spurious input.

        /*** SyncWrite calls Drain here which we should not need **
         *** as we are immediately waiting for a response *********
         **********************************************************
                if(!FComDirectSyncWrite(szSend, uwLen))
         **********************************************************/

                if(fPause)
                        Sleep(40);      // 100 is too long

                // FComFlushInput();
                FComFlush(pTG);            // Need to flush output too? Maybe...
                // there's nowhere else to flush/loosen up teh output

                // The flush has to be as late in the game as possible,
                // because if teh previous command got confused & accepted
                // a response to an earlier command or something, then
                // it's response may still be in transit (this happened
                // on Sharad's PP9600FXMT), so the later we do this the
                // better. So we send the entire command w/o teh \r,
                // wait for it to drain, then Flush again (input only
                // this time) then send the CR

				///////// Potential Major source of failures ////////
				// DirectSyncWrite calls Drain which calls DllSleep if everything
				// is not drained, so we could end up waiting for 1 time slice
				// which is at least 50ms and looks like it can be much higher on
				// some machines. This was screwing up our AT+FTM=96 is some cases
				// FIX: Enter Crit section here exit after this is done
				//////////////////////////////////////////////////////

                PSSLogEntry(PSS_MSG, 2, "send: \"%s\"", szSend);
                
                if(!FComDirectSyncWriteFast(pTG, szSend, (UWORD)(uwLen-1)))
                {
                    // Need to check that we are sending only ASCII or pre-stuffed data here
                    DebugPrintEx(DEBUG_ERR,"Modem Dialog Sync Write timed Out");
                    uwRet = 0;
                    goto error;
                    // If Write fails, fail & return immediately.
                    // SetMyError() will already have been called.
                }
                // output has drained. Now flush input
                FComFlushInput(pTG);
                // and then send the CR
                if(!FComDirectAsyncWrite(pTG, "\r", 1))
                {
                    DebugPrintEx(DEBUG_ERR,"Modem Dialog Write timed Out on CR");
                    uwRet = 0;
                    goto error;
                }
            }

            // Try to get a response until timeout or bad response
            pTG->FComModem.bLastReply[0] = 0;
            fGotFirstLine=FALSE;

            for(lptoRead=lpto;;startTimeOut(pTG, lpto0, SECONDLINE_TIMEOUT), lptoRead=lpto0)
            {
                    // get a CR-LF terminated line
                    // for the first line use macro timeout, for multi-line
                    // responses use 0 timeout.
retry:
                    swNumRead = FComFilterReadLine(pTG, bReply, REPLYBUFSIZE-1, lptoRead);
                    DebugPrintEx(DEBUG_MSG,"FComFilterReadLine returns %d",swNumRead);
                    if(swNumRead == 2 && bReply[0] == '\r' && bReply[1] == '\n')
                            goto retry;             // blank line -- throw away & get another

                    // Fix Bug#1226. Elsa Microlink returns this garbage line in
                    // response to AT+FCLASS=?, followed by the real reply. Since
                    // we only look at the first line, we see only this garbage line
                    // and we never see the real reply (0, 1, 2, 2.0)
                    if(swNumRead==3 && bReply[0]==0x13 && bReply[1]=='\r' && bReply[2]=='\n')
                            goto retry;

                    // Fix Elliot bug#3619 -- German modem TE3801 sends us
                    // \r\r\nOK\r\n -- so we treat \r\r\n as blank line.
                    if(swNumRead==3 && bReply[0]=='\r' && bReply[1]=='\r' && bReply[2]=='\n')
                            goto retry;

                    if(swNumRead == 0)      // timeout
                    {
                        if(fGotFirstLine)
                        {
                            // for MegaHertz, which returns no OK after
                            // capabilities queries
                            if(pTG->fMegaHertzHack)
                            {
                                if(fHasNumerals(pTG, pTG->FComModem.bLastReply))
                                {
                                    uwRet = 1;
                                    goto end;
                                }
                            }
                            break;
                        }
                        else
                        {
                            goto timeout;
                        }
                    }
                    if(swNumRead < 0)       // error-but lets see what we got anyway
                            swNumRead = (-swNumRead);

                    fGotFirstLine=TRUE;


                    //
                    // +++ HACK:
                    // We add everything upto the first NULL of each
                    // line of reply to bEntireReply, for the specific
                    // case of fMultiLine==uMULTILINE_SAVEENTIRE
                    // This is so we save things like:
                    // \r\nDATA\r\n\r\nCONNECT 12000\r\n
                    //
                    if(pTG->Comm.fEnableHandoff && fMultiLine==uMULTILINE_SAVEENTIRE
                            && uPos<sizeof(pTG->FComModem.bEntireReply))
                    {
                        UINT cb;
                        bReply[REPLYBUFSIZE-1]=0;
                        cb = _fstrlen(bReply);
                        if ((cb+1)> (sizeof(pTG->FComModem.bEntireReply)-uPos))
                        {
                            DebugPrintEx(DEBUG_WRN, "bEntireReply: out of space");
                            cb=sizeof(pTG->FComModem.bEntireReply)-uPos;
                            if (cb) cb--;
                        }
                        _fmemcpy((LPB)pTG->FComModem.bEntireReply+uPos, (LPB)bReply, cb);
                        uPos+=cb;
                        pTG->FComModem.bEntireReply[uPos]=0;
                    }

                    PSSLogEntry(PSS_MSG, 2, "recv:     \"%s\"", bReply);

                    for(bReply[REPLYBUFSIZE-1]=0, j=1; j<=uwWantCount; j++)
                    {
                        if(rgcbszWant[j] && (strstr(bReply, rgcbszWant[j]) != NULL))
                        {
                            uwRet = j;
                            goto end;
                        }
                    }


                    if(!fMultiLine)
                            break;
                    // Got something unknown
                    // Retry command and response until timeout

                    // We reach here it IFF we got a non blank reply, but it wasn't what
                    // we wanted. Squirrel teh first line away somewhere so that we can
                    // retrieve is later. We use this hack to get multi-line informational
                    // responses to things like +FTH=? Very important to ensure that
                    // blank-line replies don't get recorded here. (They may override
                    // the preceding line that we need!).

                    if( (pTG->FComModem.bLastReply[0] == 0) ||
                        ( ! _fstrcmp(pTG->FComModem.bLastReply, cbszRING) ) ) 
                    {
                                // copy only if _first_ response line
                            _fmemcpy((LPB)pTG->FComModem.bLastReply, (LPB)bReply, REPLYBUFSIZE);
                    }
                    // copies whole of bReply which includes zero-termination put
                    // there by FComFilterReadLine
                    DebugPrintEx(   DEBUG_MSG,
                                    "Saved line (%s)", 
                                    (LPSTR)(&(pTG->FComModem.bLastReply)));
            }
        }
        while(checkTimeOut(pTG, lpto));

        if(fGotFirstLine)
                continue;

        DebugPrintEx(DEBUG_WRN,"Weird!! got timeout in iiModemDialog loop");
timeout:
        PSSLogEntryStrings(PSS_WRN, 2, &rgcbszWant[1], uwWantCount, 
                "failed to receive expected response: ");
        // Need to send anychar to abort the previous command.
        // use random 120ms timeout -- too short. upped to 250
        // send \rAT\r
        // no need for pause--we just timed out!!

        PSSLogEntry(PSS_MSG, 2, "send: \"AT\"");
        FComFlush(pTG); // flush first--don't wnat some old garbage result
        FComDirectSyncWriteFast(pTG, "\rAT", 3);
        FComFlushInput(pTG); // flush input again
        FComDirectAsyncWrite(pTG, "\r", 1);
        startTimeOut(pTG, lpto0, ABORT_TIMEOUT);
        do
        {
            swNumRead = FComFilterReadLine(pTG, bReply, REPLYBUFSIZE-1, lpto0);
        }
        while(swNumRead==2 && bReply[0]=='\r'&& bReply[1]=='\n');
        // While we get a blank line. Get another.
        bReply[REPLYBUFSIZE-1] = 0;
        if (bReply[0])
        {
            PSSLogEntry(PSS_MSG, 2, "recv:     \"%s\"", bReply);
        }
        if(bReply[0] && strstr(bReply, cbszOK)==NULL)
            DebugPrintEx(   DEBUG_ERR,
                            "Anykey abort reply not OK. Got <<%s>>", 
                            (LPSTR)bReply);

        // Need Flush here, because \rAT\r will often get us
        // a cr-lf-OK-cr-lf-cr-lfOK-cr-lf response. If we send
        // just a \r, sometimes we may get nothing

        // FComFlushInput();
        FComFlush(pTG);
    }

error:
    DebugPrintEx(   DEBUG_WRN,
                    "(%s) --> (%d)(%s, etc) Failed", 
                    (LPSTR)(szSend?szSend:"null"), 
                    uwWantCount, 
                    (LPSTR)rgcbszWant[1]);

    pTG->FComStatus.fInDialog = 0;
    return 0;

end:

    DebugPrintEx(DEBUG_MSG,"GOT IT %d (%s)", uwRet, (LPSTR)(rgcbszWant[uwRet]));
    pTG->FComStatus.fInDialog = 0;
    return uwRet;
}


void InitMonitorLogging(PThrdGlbl pTG)
{
    DEBUG_FUNCTION_NAME(("InitMonitorLogging"));
    pTG->Comm.fEnableHandoff=1;
    if (pTG->Comm.fEnableHandoff)
    {
        DebugPrintEx(DEBUG_WRN,"ADAPTIVE ANSWER ENABLED");
    }
}

// RSL was 60 000
#define AA_ANSWER_TIMEOUT       40000

USHORT iModemGetAdaptiveResp(PThrdGlbl pTG)
{
    USHORT                uRet=CONNECT_ERROR;
    BOOL                  fGotOK=FALSE;
    BOOL                  fGotData=FALSE;
    BOOL                  fGotFax=FALSE;
    LONG                  lRet;
    char                  Command[400];


    DEBUG_FUNCTION_NAME(("iModemGetAdaptiveResp"));

    pTG->Comm.fDataCall = FALSE;
    //
    // handle Adaptive Answer
    // should get FAX/DATA response
    //
    switch( iiModemDialog(  pTG, 
                            0, 
                            0, 
                            AA_ANSWER_TIMEOUT, 
                            uMULTILINE_SAVEENTIRE,
                            1, 
                            TRUE,
                            pTG->ModemResponseFaxDetect,
                            pTG->ModemResponseDataDetect,
                            cbszCONNECT,
                            cbszOK,
                            (CBPSTR)NULL)) 
    {

         case 1:
              fGotFax = 1;
              DebugPrintEx(DEBUG_MSG,"AdaptiveAnswer: got FAX response");
              break;

         case 2:
             fGotData = 1;
             DebugPrintEx(DEBUG_MSG,"AdaptiveAnswer: got DATA response");
             break;

         case 3:
             DebugPrintEx(DEBUG_ERR,"AnswerPhone: Can't get CONNECT before FAX/DATA");
             pTG->Comm.fDataCall = FALSE;
             uRet = CONNECT_ERROR;
             goto end;

         case 4:
             DebugPrintEx(DEBUG_ERR,"AnswerPhone: Can't get OK before FAX/DATA");
             pTG->Comm.fDataCall = FALSE;
             uRet = CONNECT_ERROR;
             goto end;

         default:
         case 0:   
            DebugPrintEx(DEBUG_ERR,"AnswerPhone: Can't get default before FAX/DATA");
            pTG->Comm.fDataCall = FALSE;
            uRet = CONNECT_ERROR;
            goto end;
    }

    // here we may have to change the serial speed and send some cmds (such as ATO-go online)

    if (fGotFax) 
    {
       if (pTG->SerialSpeedFaxDetect) 
       {
          FComSetBaudRate(pTG, pTG->SerialSpeedFaxDetect);
       }

       if (pTG->HostCommandFaxDetect)  
       {
          strcpy (Command, pTG->HostCommandFaxDetect );

          FComFlushOutput(pTG);
          FComDirectAsyncWrite(pTG, (LPSTR) Command, (USHORT) strlen(Command) );
       }

    }
    else if (fGotData) 
    {
       if (pTG->SerialSpeedDataDetect) 
       {
          FComSetBaudRate(pTG, pTG->SerialSpeedDataDetect);
       }

       if (pTG->HostCommandDataDetect)    
       {
          strcpy (Command, pTG->HostCommandDataDetect );

          FComFlushOutput(pTG);
          FComDirectAsyncWrite(pTG, (LPSTR) Command, (USHORT) strlen(Command) );
       }
    }
    else 
    {
       DebugPrintEx(DEBUG_ERR,"AnswerPhone: LOGICAL PGM ERROR");
       pTG->Comm.fDataCall = FALSE;
       uRet = CONNECT_ERROR;
       goto end;
    }


    // wait for connect now.

    switch( iiModemDialog(  pTG, 
                            0, 
                            0, 
                            AA_ANSWER_TIMEOUT, 
                            uMULTILINE_SAVEENTIRE,
                            1, 
                            TRUE,
                            (fGotFax) ? pTG->ModemResponseFaxConnect : pTG->ModemResponseDataConnect,
                            cbszCONNECT,
                            cbszOK,
                            (CBPSTR)NULL)) 
    {

         case 1:
              if (fGotFax) 
              {
                 uRet=CONNECT_OK;
                 goto end;
              }
              else 
              {
                 goto lDetectDataCall;
              }

         case 2:
            if (fGotFax) 
            {
               uRet=CONNECT_OK;
               goto end;
            }
            else 
            {
               goto lDetectDataCall;
            }

         case 3:
             DebugPrintEx(DEBUG_ERR,"AnswerPhone: Can't get OK after FAX/DATA");
             pTG->Comm.fDataCall = FALSE;
             uRet = CONNECT_ERROR;
             goto end;

         default:
         case 0:
            DebugPrintEx(DEBUG_ERR,"AnswerPhone: Can't get default after FAX/DATA");
            pTG->Comm.fDataCall = FALSE;
            uRet = CONNECT_ERROR;
            goto end;
    }



lDetectDataCall:
    // Now we've got to fake out modem and fcom into thinking that
    // the phone is off hook when in fact it isn't.
    pTG->Comm.fDataCall = TRUE;
    uRet = CONNECT_WRONGMODE_DATAMODEM;
    //
    // New TAPI: Have to switch out of passtrough before handing off the call
    //

    DebugPrintEx(DEBUG_MSG,"AdaptiveAnswer: lineSetCallParams called");

    if (!itapi_async_setup(pTG)) 
    {
        DebugPrintEx(DEBUG_ERR,"AdaptiveAnswer: itapi_async_setup failed");

        pTG->Comm.fDataCall = FALSE;
        uRet = CONNECT_ERROR;
        goto end;
    }

    lRet = lineSetCallParams(pTG->CallHandle,
                             LINEBEARERMODE_VOICE,
                             0,
                             0xffffffff,
                             NULL);

    if (lRet < 0) 
    {
        DebugPrintEx(DEBUG_ERR, "AdaptiveAnswer: lineSetCallParams failed");

        pTG->fFatalErrorWasSignaled = 1;
        SignalStatusChange(pTG, FS_FATAL_ERROR);

        pTG->Comm.fDataCall = FALSE;
        uRet = CONNECT_ERROR;
        goto end;
    }
    else 
    {
         DebugPrintEx(  DEBUG_MSG,
                        "AdaptiveAnswer: lineSetCallParams returns ID %ld", 
                        (long) lRet);
    }

    if(!itapi_async_wait(pTG, (DWORD)lRet, (LPDWORD)&lRet, NULL, ASYNC_TIMEOUT)) 
    {
        DebugPrintEx(DEBUG_ERR, "AdaptiveAnswer: itapi_async_wait failed");
        pTG->fFatalErrorWasSignaled = 1;
        SignalStatusChange(pTG, FS_FATAL_ERROR);

        pTG->Comm.fDataCall = FALSE;
        uRet = CONNECT_ERROR;
        goto end;
    }

    pTG->fFatalErrorWasSignaled = 1;
    SignalStatusChange(pTG, FS_NOT_FAX_CALL);

end:
    return uRet;

}
=== C:/Users/treeman/Desktop/windows nt source code\Source\Win2K3\NT\printscan\faxsrv\provider\t30\headers\class2.h ===
#define         IDSIZE                  20
#define         MFR_SIZE                80
#define         RESPONSE_BUF_SIZE       300

typedef enum {  
  PCB_SEND_CAPS,
  PCB_SEND_PARAMS,
  PCB_RECV_PARAMS
}  PCBTYPE;


typedef struct {
        BYTE    Resolution;             // one or more of the RES_ #defines below
        BYTE    Encoding;               // one or more of the ENCODE_ #defines below
        BYTE    PageWidth;                      // one of the WIDTH_ #defines below
        BYTE    PageLength;                     // one of the LENGTH_ #defines below
        BYTE    MinScan;                // one of the MINSCAN_ #defines below
                                                        // used only in RecvCaps
        CHAR    szID[IDSIZE+2]; // Must use '0' to '9' or ' '(space) only

        BOOL    fBinary;                // accepts binary files inside linearized EFAX messages

        BYTE    Baud;
} PCB, far* LPPCB, near* NPPCB;


//  Array to hold parsed class2 command strings.
#define MAX_CLASS2_COMMANDS     10
#define MAX_PARAM_LENGTH        50

typedef struct cl2_command {
    USHORT    comm_count;
    BYTE    command[MAX_CLASS2_COMMANDS];
    BYTE    parameters[MAX_CLASS2_COMMANDS][MAX_PARAM_LENGTH];
} CL2_COMM_ARRAY;


// structure for modem specific hacks
typedef struct {
        // Fields for manufacturer, model, and revision number
        CHAR    szMFR[MFR_SIZE];
        CHAR    szMDL[MFR_SIZE];
        //Fields for specific actions to take
        //BOR values to use
        USHORT    iReceiveBOR;
        USHORT    iSendBOR;
        //Value to enable data to be recieved after FDR
        CHAR    szDC2[2];
        BOOL    bIsSierra;
        BOOL    bIsExar;
        BOOL    fSkipCtrlQ;     // DONT wait for CtrlQ after FDT
        BOOL    fSWFBOR;        // Implement AT+FBOR=1 in software (i.e., bitreverse)
                                // Only invoked on send(recv) if iSendBOR(iRecvBOR)
                                // is 1 (in which it will send AT+FBOR=0).
} MFRSPEC, far *LPMFRSPEC;



/**-------------------- from MODEM.H -----------------------------**/

typedef char  C2SZ;
typedef char  *C2PSTR;




/**-------------------- from COMMODEM.H -----------------------------**/

#define MAXPHONESIZE    512
#define DIALBUFSIZE     MAXPHONESIZE + 10






/**-------------------- modelled after MODEMINT.H -----------------------------**/
// used for Resync type stuff. RepeatCount = 2
// This has to be multi-line too, because echo could be on and
// we could get the command echoed back instead of response!
                // Looks like even 330 is too short for some modems..

#define Class2SyncModemDialog(pTG, s, l, w)                                  \
    Class2iModemDialog(pTG, (s), (l), 550, 2, TRUE, (C2PSTR)(w), (C2PSTR)(NULL))
=== C:/Users/treeman/Desktop/windows nt source code\Source\Win2K3\NT\printscan\faxsrv\provider\t30\headers\awnsfcor.h ===
/***************************************************************************
 Name     :	AWNSFCOR.H
 Comment  :	NSF related definitions that _must_ be kept the same.
			EVERYTHING in this file affects what is sent across the
			wire. For full compatibility with all versions of Microsoft
			At Work NSFs, _nothing_ in here should be changed.

			The NSF protocol can be extended by adding new groups
			and by appending fields at the end of existing groups.

			Interfaces, structures and constants that only affect one
			machine (i.e. not what is on the wire) should not be in
			this file


	Copyright (c) 1993 Microsoft Corp.

 Revision Log
 Date     Name  Description
 -------- ----- ---------------------------------------------------------
 12/31/93 arulm Created this. Verified in matches Snowball.rc
***************************************************************************/

#ifndef _AWNSFCOR_H
#define _AWNSFCOR_H

/***********************************************************************
 *                                                                     *
 * NOTICE: This file has to be ANSI compilable, under GCC on UNIX      *
 * and other ANSI compiles. Be sure to use no MS C specific features   *
 * In particular, don't use // for comments!!!!                        *
 *                                                                     *
 ***********************************************************************/


#define AWRES_ALLT30 (AWRES_mm080_038 | AWRES_mm080_077 | AWRES_mm080_154 | AWRES_mm160_154 | AWRES_200_200 | AWRES_300_300 | AWRES_400_400)


#define WIDTH_A4	0	
#define WIDTH_B4	1	
#define WIDTH_A3	2	
#define WIDTH_MAX	WIDTH_A3

#define WIDTH_A5		16 	/* 1216 pixels */
#define WIDTH_A6		32	/* 864 pixels  */
#define WIDTH_A5_1728	64 	/* 1216 pixels */
#define WIDTH_A6_1728	128	/* 864 pixels  */




#define LENGTH_A4			0	
#define LENGTH_B4			1	
#define LENGTH_UNLIMITED	2


#endif /* _AWNSFCOR_H */
=== C:/Users/treeman/Desktop/windows nt source code\Source\Win2K3\NT\printscan\faxsrv\provider\t30\headers\awnsfint.h ===
/***************************************************************************
 Name     :     AWNSFINT.H
 Comment  :     INTERNAL-ONLY Definitions of BC and NSF related structs

        Copyright (c) 1993 Microsoft Corp.

 Revision Log
 Date     Name  Description
 -------- ----- ---------------------------------------------------------
 08/28/93 arulm Modifying aftering adding encryption
***************************************************************************/


#ifndef _AWNSFINT_H
#define _AWNSFINT_H

#include <awnsfcor.h>
#include <fr.h>

/***********************************************************************
 *                                                                     *
 * NOTICE: This file has to be ANSI compilable, under GCC on UNIX      *
 * and other ANSI compiles. Be sure to use no MS C specific features   *
 * In particular, don't use // for comments!!!!                        *
 *                                                                     *
 ***********************************************************************/


#pragma pack(2)         /* ensure portable packing (i.e. 2 or more) */


typedef struct
{
        ///////// This structure is not transmitted /////////

        WORD    fPublicPoll;
//2bytes

        DWORD   AwRes;          /* One or more of the AWRES_ #defines           */
        WORD    Encoding;       /* One or more of MH_DATA/MR_DATA/MMR_DATA      */
        WORD    PageWidth;      /* One of the WIDTH_ #defines (these are not bitflags!) */
        WORD    PageLength;     /* One of the LENGTH_ #defines (these are not bitflags!) */
//12 bytes
}
BCFAX, far* LPBCFAX, near* NPBCFAX;


typedef struct
{
        BCTYPE  bctype;					// must always be set. One of the enum values above
        WORD    wBCSize;				// size of this (fixed size) BC struct, must be set
        WORD    wTotalSize;				// total size of header + associated var len strings

        BCFAX   Fax;					// for internal use _only_
}
BC, far* LPBC, near* NPBC;

#define InitBC(lpbc, uSize, t)                                          \
{                                                                       \
        _fmemset((lpbc), 0, (uSize));                                   \
        (lpbc)->bctype  = (t);                                          \
        (lpbc)->wBCSize = sizeof(BC);                                   \
        (lpbc)->wTotalSize = sizeof(BC);                                \
}

#pragma pack()

#endif /** _AWNSFINT_H **/
=== C:/Users/treeman/Desktop/windows nt source code\Source\Win2K3\NT\printscan\faxsrv\provider\t30\headers\buffers.h ===
/*==============================================================================
This file includes the BUFFER typedef and standard meta-data values.

23-Feb-93    RajeevD    Moved from ifaxos.h
17-Jul-93    KGallo     Added STORED_BUF_DATA metadata type for buffers containing 
                        the stored info for another buffer.
28-Sep-93    ArulM      Added RES_ ENCODE_ WIDTH_ and LENGTH_ typedefs
==============================================================================*/
#ifndef _INC_BUFFERS
#define _INC_BUFFERS

typedef struct _BUFFER
{       
	// Read Only portion
	LPBYTE  lpbBegBuf;      // Physical start of buffer
	WORD    wLengthBuf;     // Length of buffer

	// Read write public portion
	WORD    wLengthData;    // length of valid data
	LPBYTE  lpbBegData;     // Ptr to start of data

} BUFFER, *LPBUFFER;

#define MH_DATA           0x00000001L
#define MR_DATA           0x00000002L
#define MMR_DATA          0x00000004L

#define AWRES_mm080_038         0x00000002L
#define AWRES_mm080_077         0x00000004L
#define AWRES_mm080_154         0x00000008L
#define AWRES_mm160_154         0x00000010L
#define AWRES_200_100           0x00000020L
#define AWRES_200_200           0x00000040L
#define AWRES_200_400           0x00000080L
#define AWRES_300_300           0x00000100L
#define AWRES_400_400           0x00000200L
#define AWRES_600_600           0x00000400L
#define AWRES_600_300           0x00000800L

#endif // _INC_BUFFERS
=== C:/Users/treeman/Desktop/windows nt source code\Source\Win2K3\NT\printscan\faxsrv\provider\t30\headers\dosio.h ===
#define DosOpen(f, m)			_lopen(f, m)
#define DosClose(h)				_lclose(h)
#define DosCreate(f, m)			_lcreat(f, m)
#define DosRead(h, lpb, cb)		_lread(h, lpb, cb)	
#define DosWrite(h, lpb, cb)	_lwrite(h, lpb, cb)
=== C:/Users/treeman/Desktop/windows nt source code\Source\Win2K3\NT\printscan\faxsrv\provider\t30\headers\comdevi.h ===
/***************************************************************************
 Name     :     COMDEVI.H
 Comment  :     Controls Comm interface used by Fax Modem Driver. There are
                        4 choices.
                        (a) If UCOM is defined, it uses the WIN16 Comm API as exported
                                by USER.EXE (though eventually it gets to COMM.DRV)
                        (b) If UCOM is not defined and VC is defined, it uses the
                                COMM.DRV-like interface exported by DLLSCHED.DLL (which
                                merely serves as a front for VCOMM.386)
                        (c) If neither UCOM nor VC are defined, it uses Win3.1 COMM.DRV
                                export directly.
                        (d) If WIN32 is defined (neither UCOM or VC should be defined at
                                the same time), it uses the WIN32 Comm API

 Functions:     (see Prototypes just below)

 Revision Log
 Date     Name  Description
 -------- ----- ---------------------------------------------------------
***************************************************************************/



#pragma optimize("e", off)              // "e" is buggy

// must be 8K or less, dues to DEADCOMMTIMEOUT. See fcom.c!!
// maybe not...

#define COM_INBUFSIZE           4096
#define COM_OUTBUFSIZE          4096

#define OVL_CLEAR(lpovl) \
                                 { \
                                        if (lpovl) \
                                        { \
                                                (lpovl)->Internal = (lpovl)->InternalHigh=\
                                                (lpovl)->Offset = (lpovl)->OffsetHigh=0; \
                                                if ((lpovl)->hEvent) ResetEvent((lpovl)->hEvent); \
                                        } \
                                 }
=== C:/Users/treeman/Desktop/windows nt source code\Source\Win2K3\NT\printscan\faxsrv\provider\t30\headers\fcomapi.h ===
/***************************************************************************
        Name      :     FCOMAPI.H
        Comment   :     Interface between FaxComm driver (entirely different for
                                Windows and DOS) and everything else.
        Functions :     (see Prototypes just below)
        Revision Log

        Copyright (c) Microsoft Corp. 1991, 1992, 1993

        Num   Date      Name     Description
        --- -------- ---------- -----------------------------------------------
***************************************************************************/

#include "timeouts.h"

#define FILTER_DLEONLY  1
#define FILTER_DLEZERO  0



// following currently defined in FileT30.h
#define LINEID_COMM_PORTNUM             (0x1)
#define LINEID_COMM_HANDLE              (0x2)
#define LINEID_TAPI_DEVICEID            (0x3)
#define LINEID_TAPI_PERMANENT_DEVICEID  (0x4)










/***************************************************************************
                                        Common Modem Operations
***************************************************************************/

typedef char far CBSZ[];
typedef char far *CBPSTR;

// iModemInit takes following SPECIAL values for fInstall:
#define fMDMINIT_NORMAL 0       // Normal Init -- includes ID Check.
#define fMDMINIT_INSTALL 1      // Full install
#define fMDMINIT_ANSWER 10      // Quick init before answering -- Skips ID check.

// +++ Old code sometimes calls with fINSTALL=TRUE
#if     (fMDMINIT_INSTALL!=TRUE) || (fMDMINIT_ANSWER==TRUE) || (fMDMINIT_NORMAL!=0) || !fMDMINIT_ANSWER
#       error "fMDMINIT_* ERROR"
#endif

// iModemInit returns these
#define INIT_OK                         0
#define INIT_INTERNAL_ERROR     13
#define INIT_MODEMERROR         15
#define INIT_PORTBUSY           16
=== C:/Users/treeman/Desktop/windows nt source code\Source\Win2K3\NT\printscan\faxsrv\provider\t30\headers\et30type.h ===
/**************************************************************************
    Name      : ET30TYPE.H
    Comment   : Types used in several et30 modules

    Copyright (c) Microsoft Corp. 1991, 1992, 1993

    Revision Log
    Num   Date      Name     Description
    --- -------- ---------- -----------------------------------------------
***************************************************************************/


#include <fr.h>

typedef enum 
{                       
    actionNULL = 0,
    actionFALSE,        
    actionTRUE,
    actionERROR,
    actionHANGUP,
    actionDCN,
    actionGONODE_T,
    actionGONODE_R1,
    actionGONODE_R2,
    actionGONODE_A,     
    actionGONODE_D,     
    actionGONODE_E,
    actionGONODE_F,
    actionGONODE_I,     
    actionGONODE_II,    
    actionGONODE_III,
    actionGONODE_IV,    
    actionGONODE_V,     
    actionGONODE_VII,
    actionGONODE_RECVCMD,
    actionGONODE_ECMRETRANSMIT,
    actionGONODE_RECVPHASEC,
    actionGONODE_RECVECMRETRANSMIT,
    actionSEND_DIS,     
    actionSEND_DTC,     
    actionSEND_DCS,
    actionSENDMPS,      
    actionSENDEOM,      
    actionSENDEOP,
    actionSENDMCF,      
    actionSENDRTP,      
    actionSENDRTN,
    actionSENDFTT,      
    actionSENDCFR,      
    actionSENDEOR_EOP,
    actionGETTCF,       
    actionSKIPTCF,    
    actionSENDDCSTCF,   
    actionDCN_SUCCESS,  
    actionNODEF_SUCCESS,
    actionHANGUP_SUCCESS,
    actionNUM_ACTIONS,

} ET30ACTION;

LPCTSTR action_GetActionDescription(ET30ACTION);

typedef enum 
{
    eventNULL = 0,
    eventGOTFRAMES,
    eventNODE_A,
    eventSENDDCS,
    eventGOTFTT,
    eventGOTCFR,
    eventSTARTSEND,
    eventPOSTPAGE,
    eventGOTPOSTPAGERESP,
    eventGOT_ECM_PPS_RESP,
    eventSENDDIS,
    eventSENDDTC,
    eventRECVCMD,
    eventGOTTCF,
    eventSTARTRECV,
    eventRECVPOSTPAGECMD,
    eventECM_POSTPAGE,
    event4THPPR,
    eventNODE_T,
    eventNODE_R,
    eventNUM_EVENTS,

} ET30EVENT;

LPCTSTR event_GetEventDescription(ET30EVENT);

/** ifr indexes. These numbers must match the ones in hdlc.c.
 ** They must be consecutive, and start from 1
 **/

#define     ifrNULL     0
#define     ifrDIS      1
#define     ifrCSI      2
#define     ifrNSF      3
#define     ifrDTC      4
#define     ifrCIG      5
#define     ifrNSC      6
#define     ifrDCS      7
#define     ifrTSI      8
#define     ifrNSS      9
#define     ifrCFR      10
#define     ifrFTT      11
#define     ifrMPS      12
#define     ifrEOM      13
#define     ifrEOP      14
#define     ifrPWD      15
#define     ifrSEP      16
#define     ifrSUB      17
#define     ifrMCF      18
#define     ifrRTP      19
#define     ifrRTN      20
#define     ifrPIP      21
#define     ifrPIN      22
#define     ifrDCN      23
#define     ifrCRP      24 

#define     ifrPRI_MPS      25
#define     ifrPRI_EOM      26
#define     ifrPRI_EOP      27

#define     ifrPRI_FIRST    ifrPRI_MPS
#define     ifrPRI_LAST     ifrPRI_EOP

    /********* ECM stuff starts here. T.30 section A.4 ******/

#define     ifrCTC      28
#define     ifrCTR      29
#define     ifrRR       30
#define     ifrPPR      31
#define     ifrRNR      32
#define     ifrERR      33

#define     ifrPPS_NULL     34
#define     ifrPPS_MPS      35
#define     ifrPPS_EOM      36
#define     ifrPPS_EOP      37
#define     ifrPPS_PRI_MPS  38
#define     ifrPPS_PRI_EOM  39
#define     ifrPPS_PRI_EOP  40

#define     ifrPPS_FIRST        ifrPPS_NULL
#define     ifrPPS_LAST         ifrPPS_PRI_EOP
#define     ifrPPS_PRI_FIRST    ifrPPS_PRI_MPS
#define     ifrPPS_PRI_LAST     ifrPPS_PRI_EOP

#define     ifrEOR_NULL     41
#define     ifrEOR_MPS      42
#define     ifrEOR_EOM      43
#define     ifrEOR_EOP      44
#define     ifrEOR_PRI_MPS  45
#define     ifrEOR_PRI_EOM  46
#define     ifrEOR_PRI_EOP  47

#define     ifrEOR_FIRST        ifrEOR_NULL
#define     ifrEOR_LAST         ifrEOR_PRI_EOP
#define     ifrEOR_PRI_FIRST    ifrEOR_PRI_MPS
#define     ifrEOR_PRI_LAST     ifrEOR_PRI_EOP

#define     ifrECM_FIRST    ifrCTC
#define     ifrECM_LAST     ifrEOR_PRI_EOP

#define     ifrMAX      48      // Max legal values (not incl this one)
#define     ifrBAD      49
#define     ifrTIMEOUT  50
// #define      ifrERROR    51

LPCTSTR ifr_GetIfrDescription(BYTE);


/**** Global buffer mgmnt ****/


#define MAXFRAMESIZE    132

// #define ECM_FRAME_SIZE   256
// #define ECM_EXTRA        9   // 4 for prefix, 2 for suffix, 3 for slack in recv


// use same for 64 bytes frames also
#   define MY_ECMBUF_SIZE           (256 + 9)   
#   define MY_ECMBUF_ACTUALSIZE     (256 + 9)
#   define MY_BIGBUF_SIZE           (MY_ECMBUF_SIZE * 4)
#   define MY_BIGBUF_ACTUALSIZE     (MY_ECMBUF_SIZE * 4)


// too long
// #define PAGE_PREAMBLE    1700
// too long
// #define PAGE_PREAMBLE    400
// MUST BE LESS THAN 375 (TCF length at 2400bps)
// too short for slow 386/20 with Twincom at 9600
// #define PAGE_PREAMBLE   100

// too long
// #define PAGE_POSTAMBLE  500
// #define PAGE_POSTAMBLE  250

// Can all teh above. WE're going to make it a factor of the TCF len
// let's be nice & safe & use 750ms (see bug#1196)
#define PAGE_PREAMBLE_DIV   2   // 750ms preamble at all speeds

// Postamble is not that important so use a smaller time
#define PAGE_POSTAMBLE_DIV  3   // 500ms preamble at all speeds
=== C:/Users/treeman/Desktop/windows nt source code\Source\Win2K3\NT\printscan\faxsrv\provider\t30\headers\efaxcb.h ===
/***************************************************************************
 Name     :     EFAXCB.H
 Comment  :

        Copyright (c) Microsoft Corp. 1991, 1992, 1993

 Revision Log
 Date     Name  Description
 -------- ----- ---------------------------------------------------------
***************************************************************************/

#include "protparm.h"


/****************** begin prototypes from icomfile.c *****************/
BOOL   ICommRecvCaps(PThrdGlbl pTG, LPBC lpBC);
BOOL   ICommRecvParams(PThrdGlbl pTG, LPBC lpBC);
USHORT   ICommNextSend(PThrdGlbl pTG);
SWORD   ICommGetSendBuf(PThrdGlbl pTG, LPBUFFER far* lplpbf, SLONG slOffset);
BOOL   ICommPutRecvBuf(PThrdGlbl pTG, LPBUFFER lpbf, SLONG slOffset);
LPBC   ICommGetBC(PThrdGlbl pTG, BCTYPE bctype);

/***************** end of prototypes from icomfile.c *****************/


// flags for PutRecvBuf
#define RECV_STARTPAGE          -2
#define RECV_ENDPAGE            -3
#define RECV_ENDDOC             -4
#define RECV_SEQ                -5
#define RECV_SEQBAD             -6
#define RECV_FLUSH              -7
#define RECV_ENDDOC_FORCESAVE   -8

// flags for GetSendBuf
#define SEND_STARTPAGE          -2
#define SEND_SEQ                -4

#define SEND_ERROR              -1
#define SEND_EOF                 1
#define SEND_OK                  0
=== C:/Users/treeman/Desktop/windows nt source code\Source\Win2K3\NT\printscan\faxsrv\provider\t30\headers\filet30.h ===
/***************************************************************************
 Name     :
 Comment  :

 Revision Log
 Date     Name  Description
 -------- ----- ---------------------------------------------------------
  ???     arulm created
 3/17/94  josephj Modified to handle AWG3 format, tapi and other device ids.
                  Specifically, changed prototypes for FileT30Init,
                  and FileT30ModemClasses, and added #defines for LINEID_*
***************************************************************************/
#ifndef _FILET30_
#define _FILET30_

#include <ifaxos.h>

#ifdef __cplusplus
extern "C" {
#endif

//      Types of LineId's
#define LINEID_NONE             (0x0)
#define LINEID_COMM_PORTNUM             (0x1)
#define LINEID_COMM_HANDLE              (0x2)
#define LINEID_TAPI_DEVICEID            (0x3)
#define LINEID_TAPI_PERMANENT_DEVICEID  (0x4)
#define LINEID_NETFAX_DEVICE    (0x10)


#       define          FAXCLASS0               0x01
#       define          FAXCLASS1               0x02
#       define          FAXCLASS2               0x04
#       define          FAXCLASS2_0             0x08    // Class4==0x10
#       define          FAXCLASSMOUSE   0x40    // used if mouse found
#       define          FAXCLASSCAS             0x80

 /**----- result values --------**/
#define T30_OK                          0
#define T30_CALLDONE            1
#define T30_CALLFAIL            2
#define T30_BUSY                        3
#define T30_DIALFAIL            4
#define T30_ANSWERFAIL          5
#define T30_BADPARAM            6
#define T30_WRONGTYPE           7
#define T30_BETTERTYPE          8
#define T30_NOMODEM                     9
#define T30_MISSING_DLLS        10
#define T30_FILE_ERROR          11
#define T30_RECVLEFT            12
#define T30_INTERNAL_ERROR      13
#define T30_ABORT                       14
#define T30_MODEMERROR          15
#define T30_PORTBUSY            16
#define T30_MODEMDEAD           17
#define T30_GETCAPS_FAIL        18
#define T30_NOSUPPORT           19
/**----- ICommEnd values **/

//--------------------- PROFILE ACCESS API's ---------------
//
//      Following APIs provide access the fax-related information
//      stored in the the registry/ini-file.
//
//      These API's should be used, rather than GetPrivateProfileString, etc...
//  On WIN32, these API's use the registry.
//


#define  DEF_BASEKEY 1
#define  OEM_BASEKEY 2

#define MAXFHBIDLEN     20

#define szDIALTONETIMEOUT       "DialToneWait"
#define szANSWERTIMEOUT         "HangupDelay"
#define szDIALPAUSETIME         "CommaDelay"
#define szPULSEDIAL             "PULSEDIAL"
#define szDIALBLIND             "BlindDial"
#define szSPEAKERCONTROL        "SpeakerMode"
#define szSPEAKERVOLUME         "Volume"
#define szSPEAKERRING           "RingAloud"
#define szRINGSBEFOREANSWER     "NumRings"
#define szHIGHESTSENDSPEED      "HighestSendSpeed"
#define szLOWESTSENDSPEED       "LowestSendSpeed"
#define szENABLEV17SEND         "EnableV17Send"
#define szENABLEV17RECV         "EnableV17Recv"

#define szFIXMODEMCLASS         "FixModemClass"
#define szFIXSERIALSPEED        "FixSerialSpeed"
#define szCL1_NO_SYNC_IF_CMD "Cl1DontSync"
#define szANSWERMODE            "AnswerMode"
#define szANS_GOCLASS_TWICE "AnsGoClassTwice"


// Following use to specify model-specific behavour of CLASS2 Modems.
// Used only in the class2 driver.
#define         szRECV_BOR              "Cl2RecvBOR"
#define         szSEND_BOR              "Cl2SendBOR"
#define         szDC2CHAR               "Cl2DC2Char"    // decimal ascii code.
#define         szIS_SIERRA             "Cl2IsSr"       // Sierra
#define         szIS_EXAR               "Cl2IsEx"       // Exar
#define         szSKIP_CTRL_Q           "Cl2SkipCtrlQ"  // Don't wait for ^Q to send
#define         szSW_BOR                "Cl2SWBOR"      // Implement +FBOR in software.

#define         CL2_DEFAULT_SETTING     (0xff)

// Cotrols whether we delete the modem section on installing modem...
#define         szDONT_PURGE "DontPurge"


//      Flags passed into ProfileOpen
enum {
fREG_READ       = 0x1,
fREG_WRITE      = 0x1<<1,
fREG_CREATE     = 0x1<<2,
fREG_VOLATILE   = 0x1<<3
};

//--------------------- END PROFILE ACCESS API's ---------------

#ifdef __cplusplus
} // extern "C"
#endif

#endif // _FILET30_
=== C:/Users/treeman/Desktop/windows nt source code\Source\Win2K3\NT\printscan\faxsrv\provider\t30\headers\fr.h ===
#ifndef _FR_H
#define _FR_H

#pragma pack(1)    /** ensure packed structures **/

typedef BYTE 		IFR;
typedef IFR FAR*	LPIFR;

typedef struct 
{
	IFR		ifr;
	BYTE	cb;

} FRBASE;

typedef struct 
{
	FRBASE;			/* anonymous */
	BYTE	fif[1];	/* variable length fif field */
	    
} FR, FAR* LPFR, NEAR* NPFR;

typedef LPFR FAR* LPLPFR;
typedef LPLPFR FAR* LPLPLPFR;


typedef struct
{

    BYTE    Baud;
    BYTE    MinScan;
}
LLPARAMS, FAR* LPLLPARAMS, NEAR* NPLLPARAMS;

/** Baud rate capability codes **/
// Bit order is from 14 to 11: 14 13 12 11
#define V27_SLOW			0   // 0000
#define V27_ONLY			2   // 0010 
#define V29_ONLY			1   // 0001
#define V33_ONLY			4   // 0100
#define V17_ONLY			8   // 1000
#define V27_V29				3   // 0011
#define V27_V29_V33			7   // 0111
#define V27_V29_V33_V17		11  // 1011
#define V_ALL				15  // 1111


/** Baud rate mode codes **/
#define V27_2400     0          // 0000  
#define V29_9600     1          // 0001
#define V27_4800     2          // 0010  
#define V29_7200     3          // 0011 
#define V33_14400    4          // 0100 
#define V33_12000    6          // 0110
#define V17_14400    8          // 1000
#define V17_9600     9          // 1001
#define V17_12000    10         // 1010
#define V17_7200     11         // 1011    


/** Minscan capability codes **/
#define MINSCAN_0_0_0		7
#define MINSCAN_5_5_5		1
#define MINSCAN_10_10_10	2
#define MINSCAN_20_20_20	0
#define MINSCAN_40_40_40	4
#define MINSCAN_40_20_20	5
#define MINSCAN_20_10_10	3
#define MINSCAN_10_5_5		6
#define MINSCAN_10_10_5	   	10
#define MINSCAN_20_20_10   	8
#define MINSCAN_40_40_20   	12
#define MINSCAN_40_20_10   	13
#define MINSCAN_20_10_5	   	11



#pragma pack()    

#endif /* _FR_H */
=== C:/Users/treeman/Desktop/windows nt source code\Source\Win2K3\NT\printscan\faxsrv\provider\t30\headers\glbproto.h ===
//!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!
//!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!


//from headers\timeouts.h

/****************** begin prototypes from timeouts.c *****************/
extern void    startTimeOut( PThrdGlbl pTG, TO *lpto, ULONG ulTimeOut);
extern BOOL    checkTimeOut( PThrdGlbl pTG, TO *lpto);
extern ULONG  leftTimeOut( PThrdGlbl pTG, TO *lpto);
/****************** begin prototypes from timeouts.c *****************/





//!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!
//!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!


USHORT MinScanToBytesPerLine(PThrdGlbl pTG, BYTE Minscan, BYTE Baud);


/****************** begin prototypes from protapi.c *****************/
BOOL    ProtGetBC(PThrdGlbl pTG, BCTYPE bctype);

BOOL WINAPI ET30ProtSetProtParams(PThrdGlbl pTG, LPPROTPARAMS lp, USHORT uRecvSpeeds, USHORT uSendSpeeds);

/***************** end of prototypes from protapi.c *****************/


//from headers\comapi.h

#define FComFilterAsyncWrite(pTG, lpb,cb,fl) (FComFilterWrite(pTG, lpb, cb, fl) == cb)
#define FComDirectAsyncWrite(pTG, lpb,cb) ((FComDirectWrite(pTG, lpb, cb)==cb) ? 1 : 0)
#define FComDirectSyncWriteFast(pTG, lpb,cb)  ((FComDirectWrite(pTG, lpb, cb)==cb) && FComDrain(pTG, FALSE,TRUE))

#define FComFlush(pTG)             { FComFlushQueue(pTG, 0); FComFlushQueue(pTG, 1); }
#define FComFlushInput(pTG)        { FComFlushQueue(pTG, 1); }
#define FComFlushOutput(pTG)       { FComFlushQueue(pTG, 0); }


extern BOOL    FComInit(PThrdGlbl pTG, DWORD dwLineID, DWORD dwLineIDType);
extern BOOL    FComClose(PThrdGlbl pTG);
extern BOOL    FComSetBaudRate(PThrdGlbl pTG, UWORD uwBaudRate);
extern void    FComFlushQueue(PThrdGlbl pTG, int queue);
extern BOOL    FComXon(PThrdGlbl pTG, BOOL fEnable);
extern BOOL    FComDTR(PThrdGlbl pTG, BOOL fEnable);
extern UWORD   FComDirectWrite(PThrdGlbl pTG, LPB lpb, UWORD cb);
extern UWORD   FComFilterWrite(PThrdGlbl pTG, LPB lpb, UWORD cb, USHORT flags);
extern BOOL    FComDrain(PThrdGlbl pTG, BOOL fLongTimeout, BOOL fDrainComm);
extern UWORD   FComFilterReadBuf(PThrdGlbl pTG, LPB lpb, UWORD cbSize, LPTO lpto, BOOL fClass2, LPSWORD lpswEOF);
// *lpswEOF is 1 on Class1 EOF, 0 on non-EOF, -1 on Class2 EOF, -2 on error -3 on timeout
extern SWORD    FComFilterReadLine(PThrdGlbl pTG, LPB lpb, UWORD cbSize, LPTO lptoRead);

extern void    FComInFilterInit(PThrdGlbl pTG);
extern void    FComOutFilterInit(PThrdGlbl pTG);
extern void    FComOutFilterClose(PThrdGlbl pTG);

extern void    FComAbort(PThrdGlbl pTG, BOOL f);
extern void    FComSetStuffZERO(PThrdGlbl pTG, USHORT cbLineMin);

BOOL FComGetOneChar(PThrdGlbl pTG, UWORD ch);


extern void WINAPI FComOverlappedIO(PThrdGlbl pTG, BOOL fStart);

/****************** begin DEBUG prototypes *****************/
extern void  far D_HexPrint(LPB b1, UWORD incnt);

/***************** end of prototypes *****************/



/****************** begin prototypes from modem.c *****************/
extern USHORT  iModemInit(	PThrdGlbl pTG, 
							DWORD dwLineID, 
							DWORD dwLineIDType,
                            DWORD dwProfileID,
                            LPSTR lpszKey,
                            BOOL fInstall);

extern BOOL  iModemClose(PThrdGlbl pTG);

void LogDialCommand(PThrdGlbl pTG, LPSTR lpszFormat, char chMod, int iLen);

extern BOOL     iModemSetNCUParams(PThrdGlbl pTG, int comma, int speaker, int volume, int fBlind, int fRingAloud);
extern BOOL     iModemHangup(PThrdGlbl pTG);
extern USHORT   iModemDial(PThrdGlbl pTG, LPSTR lpszDial);
extern USHORT   iModemAnswer(PThrdGlbl pTG);
extern LPCMDTAB   iModemGetCmdTabPtr(PThrdGlbl pTG);

// 6 fixed args, then variable number of CBPSTRs, but there
// must be at leat 2. One real one and one NULL terminator
extern UWORD  far iiModemDialog(PThrdGlbl pTG, LPSTR szSend, UWORD uwLen, ULONG ulTimeout,
                                        BOOL fMultiLine, UWORD uwRepeatCount, BOOL fPause,
                                        CBPSTR w1, CBPSTR w2, ...);
/***************** end of prototypes from modem.c *****************/

/****************** begin prototypes from whatnext.c *****************/
ET30ACTION  
__cdecl 
FAR 
WhatNext
(
	PThrdGlbl pTG, 
	ET30EVENT event,
    WORD wArg1, 
	DWORD_PTR lArg2, 
	DWORD_PTR lArg3
);
/***************** end of prototypes from whatnext.c *****************/


//from headers\filet30.h

ULONG_PTR   ProfileOpen(DWORD dwProfileID, LPSTR lpszSection, DWORD dwFlags);
                //                      dwProfileID should be one of DEF_BASEKEY or OEM_BASEKEY.
                //                      lpszSection should be (for example) "COM2" or "TAPI02345a04"
                //                      If dwProfileID == DEF_BASEKEY, the value is set to be a
                //                      sub key of:
                //                              HKEY_LOCAL_MACHINE\SOFTWARE\MICROSOFT\At Work Fax\
                //                              Local Modems\<lpszSection>.
                //                      Else if it is DEF_OEMKEY, it is assumed to be a fully-
                //                      qualified Key name, like "SOFTWARE\MICROSOFT.."
                //
                //                      Currently both are based of HKEY_LOCAL_MACHINE.
                //
                //      When you're finished with this key, call ProfileClose.
                //
                //  dwFlags is a combination of one of the fREG keys above..
                //
                //  WIN32 ONLY: if lpszSection is NULL, it will open the base key,
                //              and return its handle, which can be used in the Reg* functions.


// Following are emulations of Get/WritePrivateProfileInt/String...

BOOL
ProfileWriteString(
    ULONG_PTR dwKey,
    LPSTR lpszValueName,
    LPSTR lpszBuf,
    BOOL  fRemoveCR
    );


DWORD   ProfileGetString(ULONG_PTR dwKey, LPSTR lpszValueName, LPSTR lpszDefault, LPSTR lpszBuf , DWORD dwcbMax);
UINT   ProfileGetInt(ULONG_PTR dwKey, LPSTR szValueName, UINT uDefault, BOOL *fExist);


UINT
ProfileListGetInt(
    ULONG_PTR  KeyList[10],
    LPSTR     lpszValueName,
    UINT      uDefault
);


// Following read/write binary data (type REG_BINARY). Available
// on Win32 only....

void   ProfileClose(ULONG_PTR dwKey);
BOOL   ProfileDeleteSection(DWORD dwProfileID, LPSTR lpszSection);

BOOL
ProfileCopySection(
      DWORD   dwProfileIDTo,
      LPSTR   lpszSectionTo,
      DWORD   dwProfileIDFr,
      LPSTR   lpszSectionFr,
      BOOL    fCreateAlways
);

BOOL   ProfileCopyTree(DWORD dwProfileIDTo,
                        LPSTR lpszSectionTo, DWORD dwProfileIDFrom, LPSTR lpszSectionFrom);







//!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!
//!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!



// from headers\modemddi.h


/****************** begin prototypes from ddi.c *****************/
                USHORT   NCULink(PThrdGlbl pTG, USHORT uFlags);
                USHORT   NCUDial(PThrdGlbl pTG, LPSTR szPhoneNum);

                        // dwFlags -- one of...
#                       define fMDMSYNC_DCN 0x1L

                BOOL  ModemSendMode(PThrdGlbl pTG, USHORT uMod);
                BOOL  ModemSendMem(PThrdGlbl pTG, LPBYTE lpb, USHORT uCount, USHORT uParams);
                BOOL  iModemSyncEx(PThrdGlbl pTG, ULONG   ulTimeout, DWORD dwFlags);
                BOOL  ModemRecvSilence(PThrdGlbl pTG, USHORT uMillisecs, ULONG ulTimeout);
                USHORT  ModemRecvMode(PThrdGlbl pTG, USHORT uMod, ULONG ulTimeout, BOOL fRetryOnFCERROR);
                USHORT  ModemRecvMem(PThrdGlbl pTG, LPBYTE lpb, USHORT cbMax, ULONG ulTimeout, USHORT far* lpcbRecv);
/***************** end of prototypes from ddi.c *****************/

LPBUFFER  MyAllocBuf(PThrdGlbl pTG, LONG sSize);
BOOL  MyFreeBuf(PThrdGlbl pTG, LPBUFFER);
void MyAllocInit(PThrdGlbl pTG);

//negot.c

BOOL NegotiateCaps(PThrdGlbl pTG);



VOID
T30LineCallBackFunction(
    HANDLE              hFax,
    DWORD               hDevice,
    DWORD               dwMessage,
    DWORD_PTR           dwInstance,
    DWORD_PTR           dwParam1,
    DWORD_PTR           dwParam2,
    DWORD_PTR           dwParam3
    );




BOOL    T30ComInit( PThrdGlbl pTG);
PVOID T30AllocThreadGlobalData(VOID);
BOOL T30Cl1Rx (PThrdGlbl  pTG);
BOOL T30Cl1Tx (PThrdGlbl  pTG,LPSTR      szPhone);


USHORT
T30ModemInit(PThrdGlbl pTG);


BOOL itapi_async_setup(PThrdGlbl pTG);
BOOL itapi_async_wait(PThrdGlbl pTG,DWORD dwRequestID,PDWORD lpdwParam2,PDWORD_PTR lpdwParam3,DWORD dwTimeout);
BOOL itapi_async_signal(PThrdGlbl pTG, DWORD dwRequestID, DWORD dwParam2, DWORD_PTR dwParam3);

LPLINECALLPARAMS itapi_create_linecallparams(void);

void
GetCommErrorNT(
    PThrdGlbl       pTG
	);


void
ClearCommCache(
    PThrdGlbl   pTG
    );


UWORD FComStripBuf(PThrdGlbl pTG, LPB lpbOut, LPB lpbIn, UWORD cb, BOOL fClass2, LPSWORD lpswEOF, LPUWORD lpcbUsed);

void InitCapsBC(PThrdGlbl pTG, LPBC lpbc, USHORT uSize, BCTYPE bctype);

BOOL
SignalStatusChange(
    PThrdGlbl   pTG,
    DWORD       StatusId
    );

BOOL
SignalStatusChangeWithStringId(
    PThrdGlbl   pTG,
    DWORD       StatusId,
    DWORD       StringId
    );
    
////////////////////////////////////////////////////////////////////
// Ansi prototypes
////////////////////////////////////////////////////////////////////

VOID  CALLBACK
T30LineCallBackFunctionA(
    HANDLE              hFax,
    DWORD               hDevice,
    DWORD               dwMessage,
    DWORD_PTR           dwInstance,
    DWORD_PTR           dwParam1,
    DWORD_PTR           dwParam2,
    DWORD_PTR           dwParam3
    );

BOOL WINAPI
FaxDevInitializeA(
    IN  HLINEAPP LineAppHandle,
    IN  HANDLE HeapHandle,
    OUT PFAX_LINECALLBACK *LineCallbackFunction,
    IN  PFAX_SERVICE_CALLBACK FaxServiceCallback
    );


BOOL WINAPI
FaxDevStartJobA(
    HLINE           LineHandle,
    DWORD           DeviceId,
    PHANDLE         pFaxHandle,
    HANDLE          CompletionPortHandle,
    ULONG_PTR       CompletionKey
    );

BOOL WINAPI
FaxDevEndJobA(
    HANDLE          FaxHandle
    );


BOOL WINAPI
FaxDevSendA(
    IN  HANDLE               FaxHandle,
    IN  PFAX_SEND_A          FaxSend,
    IN  PFAX_SEND_CALLBACK   FaxSendCallback
    );

BOOL WINAPI
FaxDevReceiveA(
    HANDLE              FaxHandle,
    HCALL               CallHandle,
    PFAX_RECEIVE_A      FaxReceive
    );

BOOL WINAPI
FaxDevReportStatusA(
    IN  HANDLE FaxHandle OPTIONAL,
    OUT PFAX_DEV_STATUS FaxStatus,
    IN  DWORD FaxStatusSize,
    OUT LPDWORD FaxStatusSizeRequired
    );

BOOL WINAPI
FaxDevAbortOperationA(
    HANDLE              FaxHandle
    );


HRESULT WINAPI
FaxDevShutdownA();



HANDLE
TiffCreateW(
    LPWSTR FileName,
    DWORD  CompressionType,
    DWORD  ImageWidth,
    DWORD  FillOrder,
    DWORD  HiRes
    );




HANDLE
TiffOpenW(
    LPWSTR FileName,
    PTIFF_INFO TiffInfo,
    BOOL ReadOnly
    );



// fast tiff


DWORD
TiffConvertThread(
    PThrdGlbl   pTG
    );




DWORD
PageAckThread(
    PThrdGlbl   pTG
    );


DWORD
ComputeCheckSum(
    LPDWORD     BaseAddr,
    DWORD       NumDwords
    );

BOOL
SignalRecoveryStatusChange(
    T30_RECOVERY_GLOB   *Recovery
    );


int
SearchNewInfFile(
       PThrdGlbl     pTG,
       char         *Key1,
       char         *Key2,
       BOOL          fRead
       );


int
my_strcmp(
       LPSTR sz1,
       LPSTR sz2
       );


void
TalkToModem (
       PThrdGlbl pTG,
       BOOL      fGetClass
       );


BOOL
SaveInf2Registry (
       PThrdGlbl pTG
       );

BOOL
SaveModemClass2Registry  (
       PThrdGlbl pTG
       );


BOOL
ReadModemClassFromRegistry  (
       PThrdGlbl pTG
       );


VOID
CleanModemInfStrings (
       PThrdGlbl pTG
       );



BOOL
RemoveCR (
     LPSTR  sz
     );



/***  BEGIN PROTOTYPES FROM CLASS2.c ***/

BOOL
T30Cl2Rx(
   PThrdGlbl pTG
);


BOOL
T30Cl2Tx(
   PThrdGlbl pTG,
   LPSTR szPhone
);


BOOL    Class2Send(PThrdGlbl pTG);
BOOL    Class2Receive(PThrdGlbl pTG);
USHORT  Class2Dial(PThrdGlbl pTG, LPSTR lpszDial);
USHORT  Class2Answer(PThrdGlbl pTG);
SWORD   Class2ModemSync(PThrdGlbl pTG);
UWORD   Class2iModemDialog(PThrdGlbl pTG, LPSTR szSend, UWORD uwLen, ULONG ulTimeout,
            UWORD uwRepeatCount,  BOOL fLogSend, ...);
BOOL    Class2ModemHangup(PThrdGlbl pTG);
BOOL    Class2ModemAbort(PThrdGlbl pTG);
SWORD   Class2HayesSyncSpeed(PThrdGlbl pTG, C2PSTR cbszCommand, UWORD uwLen);
USHORT  Class2ModemRecvData(PThrdGlbl pTG, LPB lpb, USHORT cbMax, USHORT uTimeout,
                        USHORT far* lpcbRecv);
BOOL    Class2ModemSendMem(PThrdGlbl pTG, LPBYTE lpb, USHORT uCount);
DWORD   Class2ModemDrain(PThrdGlbl pTG);
USHORT  Class2MinScanToBytesPerLine(PThrdGlbl pTG, BYTE Minscan, BYTE Baud, BYTE Resolution);
BOOL    Class2ResponseAction(PThrdGlbl pTG, LPPCB lpPcb);
USHORT  Class2ModemRecvBuf(PThrdGlbl pTG, LPBUFFER far* lplpbf, USHORT uTimeout);
USHORT  Class2EndPageResponseAction(PThrdGlbl pTG);
BOOL    Class2GetModemMaker(PThrdGlbl pTG);
void    Class2SetMFRSpecific(PThrdGlbl pTG);
BOOL    Class2Parse( PThrdGlbl pTG, CL2_COMM_ARRAY *, BYTE responsebuf[] );
BOOL    Class2UpdateTiffInfo(PThrdGlbl pTG, LPPCB lpPcb);
BOOL    Class2IsValidDCS(LPPCB lpPcb);
void    Class2InitBC(PThrdGlbl pTG, LPBC lpbc, USHORT uSize, BCTYPE bctype);
void    Class2PCBtoBC(PThrdGlbl pTG, LPBC lpbc, USHORT uMaxSize, LPPCB lppcb);

void
Class2SetDIS_DCSParams
(
	PThrdGlbl pTG, 
	BCTYPE bctype, 
	OUT LPUWORD Encoding, 
	OUT LPUWORD Resolution,
    OUT LPUWORD PageWidth, 
	OUT LPUWORD PageLength, 
	OUT LPSTR szID,
	UINT cch
);

void    Class2BCHack(PThrdGlbl pTG);
BOOL    Class2GetBC(PThrdGlbl pTG, BCTYPE bctype);
void    cl2_flip_bytes( LPB lpb, DWORD dw);
void    Class2SignalFatalError(PThrdGlbl pTG);


BOOL   iModemGoClass(PThrdGlbl pTG, USHORT uClass);

void
Class2Init(
     PThrdGlbl pTG
);


BOOL
Class2SetProtParams(
     PThrdGlbl pTG,
     LPPROTPARAMS lp
);

/***    BEGIN PROTOTYPES FROM CLASS2_0.c ***/

BOOL
T30Cl20Rx (
    PThrdGlbl pTG
);


BOOL
T30Cl20Tx(
   PThrdGlbl pTG,
   LPSTR szPhone
);


BOOL  Class20Send(PThrdGlbl pTG);
BOOL  Class20Receive(PThrdGlbl pTG);

void
Class20Init(
     PThrdGlbl pTG
);

BOOL    Class20Parse( PThrdGlbl pTG, CL2_COMM_ARRAY *, BYTE responsebuf[] );
=== C:/Users/treeman/Desktop/windows nt source code\Source\Win2K3\NT\printscan\faxsrv\provider\t30\headers\inifile.h ===
#ifndef INIFILE_H
#define INIFILE_H

// Defines data so can be included only once in each DLL!!

char szDialtoneTimeout[]= szDIALTONETIMEOUT;
char szAnswerTimeout[]	= szANSWERTIMEOUT;
char szDialPauseTime[]	= szDIALPAUSETIME;
char szPulseDial[]		= szPULSEDIAL;
char szDialBlind[]		= szDIALBLIND;
char szSpeakerControl[]	= szSPEAKERCONTROL;
char szSpeakerVolume[]	= szSPEAKERVOLUME;
char szSpeakerRing[]	= szSPEAKERRING;
char szRingsBeforeAnswer[]	= szRINGSBEFOREANSWER;
char szHighestSendSpeed[]	= szHIGHESTSENDSPEED;
char szLowestSendSpeed[]	= szLOWESTSENDSPEED;
char szEnableV17Send[]		= szENABLEV17SEND;
char szEnableV17Recv[]		= szENABLEV17RECV;

char szFixModemClass[] 		= szFIXMODEMCLASS;
char szFixSerialSpeed[]     = szFIXSERIALSPEED;



#endif INIFILE_H
=== C:/Users/treeman/Desktop/windows nt source code\Source\Win2K3\NT\printscan\faxsrv\provider\t30\headers\ifaxos.h ===
#ifndef _INC_IFAXOS
#define _INC_IFAXOS

#ifdef __cplusplus
extern "C" {
#endif

// -------------------------- Include Files ------------------------------------

#include <windows.h>
#include <windowsx.h>

typedef CHAR    FAR *LPCHAR;
typedef CHAR    NEAR *NPCHAR;

#include <buffers.h>

#endif  // _INC_IFAXOS
=== C:/Users/treeman/Desktop/windows nt source code\Source\Win2K3\NT\printscan\faxsrv\provider\t30\headers\prep.h ===
#include "resource.h"

#include <ifaxos.h>

#include <awnsfapi.h>
#include <awnsfint.h>

#include "stdio.h"
#include "stdlib.h"

#include <memory.h>

#include "tchar.h"

#include <filet30.h>
#include <dosio.h>


#include "tipes.h"
#include "et30type.h"
#include "tapi.h"

#include "modemddi.h"
#include "protapi.h"

#include <faxdev.h>
#include "faxutil.h"


#include "timeouts.h"

#include "root.h"

#include "class2.h"

#include "..\..\..\tiff\inc\tifflib.h"
#include "global.h"

#include "fcomapi.h"
=== C:/Users/treeman/Desktop/windows nt source code\Source\Win2K3\NT\printscan\faxsrv\provider\t30\headers\global.h ===
#include <t30ext.h>
//
// thread sync. timeouts
//

#define RX_WAIT_ACK_TERMINATE_TIMEOUT   60000
#define RX_ACK_THRD_TIMEOUT             3000

#define TX_WAIT_ACK_TERMINATE_TIMEOUT   60000

#define  T30_RX       1
#define  T30_TX       2


//
//  Timeout for ATDT command
//
#define DIAL_TIMEOUT    70000L

//
// Custom StatusID's
//
#define FS_UNSUPPORTED_CHAR      0x40000800
#define FS_RECV_NOT_FAX_CALL     0x40000801
#define FS_NO_RESPONSE           0x40000802
#define FS_SEND_BAD_TRAINING     0x40000803
#define FS_RECV_BAD_TRAINING     0x40000804

typedef struct {
    DWORD           tiffCompression;
    BOOL            HiRes;
    char            lpszLineID[16];  // to be used for a temp. TIFF page data file
}  TX_THRD_PARAMS;

#define   DECODE_BUFFER_SIZE    44000

#define   MODEMKEY_FROM_UNIMODEM   1
#define   MODEMKEY_FROM_ADAPTIVE   2
#define   MODEMKEY_FROM_NOTHING    3

#define MAX_REG_KEY_NAME_SIZE (200)

//identify.c

typedef struct {
   DWORD_PTR hglb;              // Tmp globall alloc "handle" for strings.
                                // type HGLOBAL for non-ifax and LPVOID
                                // for IFAX
   LPBYTE lpbBuf;
   LPBYTE szReset;              // MAXCMDSIZE
   LPBYTE szResetGenerated;     // MAXCMDSIZE
   LPBYTE szSetup;              // MAXCMDSIZE
   LPBYTE szSetupGenerated;     // MAXCMDSIZE
   LPBYTE szExit;               // MAXCMDSIZE
   LPBYTE szPreDial;            // MAXCMDSIZE
   LPBYTE szPreAnswer;          // MAXCMDSIZE
   LPBYTE szIDCmd;              // MAXCMDSIZE
   LPBYTE szID;                 // MAXIDSIZE
   LPBYTE szResponseBuf;        // RESPONSEBUFSIZE
   LPBYTE szSmallTemp1;         // SMALLTEMPSIZE
   LPBYTE szSmallTemp2;         // SMALLTEMPSIZE

   LPMODEMCAPS lpMdmCaps;
   DWORD dwSerialSpeed;
   DWORD dwFlags;               // dwFlags, as defined in the CMDTAB structure.
   DWORD dwGot;
   USHORT uDontPurge;           // Profile entry says shouldn't delete the profile.
                                // NOTE: We will ignore this and not delete the
                                // profile if we don't get a response from the
                                // modem, to avoid unnecessarily deleting the
                                // profile simply because the modem is not
                                // responding/off/disconnected.
                                //
                                // 0 = purge
                                // 1 = don't purge
                                // anything else = uninitialized.
} S_TmpSettings;

// This is how ResetCommand vs. ResetCommandGenerated work:
// When first installing the modem, we copy ResetCommand from Unimodem/.inf. If there's
// no ResetCommand, or ResetCommand is bad (produces ERROR), iModemFigureOutCmdsExt
// generates a new command from scrach, and saves it in ResetCommandGenerated. When trying
// to read from registry:
// * If ResetCommand is different from Unimodem's ResetCommand, then there has been a 
//   Unimodem inf upddate - install from scratch
// * If ResetCommand is the same, and there's a non-null ResetCommandGenerated, use 
//   ResetCommandGenerated - we've already tried the original ResetCommand once, and failed.
// * If ResetCommand is the same, and there's no ResetCommandGenerate, use ResetCommand.
// 
// Same goes for SetupCommand vs. SetupCommandGenerated


typedef struct tagThreadGlobal {
        //  t30.c
    int                     RecoveryIndex;
    ET30T30                 T30;         // same
    ET30ECHOPROTECT         EchoProtect; // same
        // protapi.c
    PROT                    ProtInst;    // protocol\protocol.h
    PROTPARAMS              ProtParams;  // headers\protparm.h
        // ddi.c
    CLASS1_MODEM            Class1Modem; // class1\class1.h
        // 4. fcom.c
    FCOM_COMM               Comm;        // comm\fcomint.h
        // identify.c
    S_TmpSettings           TmpSettings; // here
        // ncuparams.c
    NCUPARAMS               NCUParams;   // headers\ncuparm.h
        // modem.c
    FCOM_MODEM              FComModem;   // same
    FCOM_STATUS             FComStatus;  // same

    INSTDATA                Inst;        // fxrn\efaxrun.h

    HLINE                   LineHandle;
    HCALL                   CallHandle;
    DWORD                   DeviceId;
    HANDLE                  FaxHandle;
    HANDLE                  hComm;
        // memory management
    USHORT					uCount;
    USHORT					uUsed;
    BUFFER					bfStaticBuf[STATICBUFCOUNT];
    BYTE					bStaticBufData[STATICBUFSIZE];
        // additional mostly from gTAPI
    int                     fGotConnect;
    HANDLE                  hevAsync;
    int                     fWaitingForEvent;
    DWORD                   dwSignalledRID;
    DWORD                   dwSignalledParam2;
    DWORD_PTR               dwSignalledParam3;
    DWORD                   dwPermanentLineID;
    char                    lpszPermanentLineID[16];
    char                    lpszUnimodemFaxKey[MAX_REG_KEY_NAME_SIZE];
    char                    lpszUnimodemKey[MAX_REG_KEY_NAME_SIZE];
    TIFF_INFO               TiffInfo;
    LPBYTE                  TiffData;
    int                     TiffPageSizeAlloc;
    int                     TiffOffset;
    int                     fTiffOpenOrCreated;
    char                    lpszDialDestFax[MAXPHONESIZE];
    DWORD                   StatusId;
    DWORD                   StringId;
    DWORD                   PageCount;
    LPTSTR                  CSI;
    char                    CallerId[200];
    LPTSTR                  RoutingInfo;
    int                     fDeallocateCall;
    COMM_CACHE              CommCache;
    BOOL                    fMegaHertzHack;
    FCOM_FILTER             Filter;

#define MAXFILTERBUFSIZE 2048
    BYTE                    bStaticFilterBuf[MAXFILTERBUFSIZE];

#define CMDTABSIZE 100
    BYTE                    bModemCmds[CMDTABSIZE];    // store modem cmds read from INI/registry here

#define SMALLTEMPSIZE   80
    char                    szSmallTemp1[SMALLTEMPSIZE];
    char                    szSmallTemp2[SMALLTEMPSIZE];

    PROTDUMP                fsDump;


#define TOTALRECVDFRAMESPACE    500
    BYTE                    bStaticRecvdFrameSpace[TOTALRECVDFRAMESPACE];

    RFS                     rfsSend;

    WORD                    PrevcbInQue;
    WORD                    PrevcbOutQue;
    BOOL                    PrevfXoffHold;
    BOOL                    PrevfXoffSent;


    LPWSTR                  lpwFileName;

    HANDLE                  CompletionPortHandle;
    ULONG_PTR               CompletionKey;

// helper thread interface
    BOOL                    fTiffThreadRunning;


    TX_THRD_PARAMS          TiffConvertThreadParams;
    BOOL                    fTiffThreadCreated;
    HANDLE                  hThread;

    HANDLE                  ThrdSignal;
    HANDLE                  FirstPageReadyTxSignal;

    DWORD                   CurrentOut;
    DWORD                   FirstOut;
    DWORD                   LastOut;
    DWORD                   CurrentIn;

    BOOL                    ReqTerminate;
    BOOL                    AckTerminate;
    BOOL                    ReqStartNewPage;
    BOOL                    AckStartNewPage;

    char                    InFileName[_MAX_FNAME];
    HANDLE                  InFileHandle;
    BOOL                    InFileHandleNeedsBeClosed;
    BOOL                    fTxPageDone;
    BOOL                    fTiffPageDone;
    BOOL                    fTiffDocumentDone;

// helper RX interface


    BOOL                    fPageIsBad;      // Is the page bad (determined by rx_thrd)
    BOOL                    fPageIsBadOverride;  // Was fPageIsBad overridden in ICommPutRecvBuf
    BOOL                    fLastReadBlock;

    HANDLE                  ThrdDoneSignal;
    HANDLE                  ThrdAckTerminateSignal;

    DWORD                   ThrdDoneRetCode;

    DWORD                   BytesIn;
    DWORD                   BytesInNotFlushed;
    DWORD                   BytesOut;
    DWORD                   BytesOutWillBe;

    char                    OutFileName[_MAX_FNAME];
    HANDLE                  OutFileHandle;
    BOOL                    SrcHiRes;

    // Need to have these as globals, so we can report them in PSS log
    DWORD                   Lines;
    DWORD                   BadFaxLines;
    DWORD                   ConsecBadLines;
    int                     iResScan;

// error reporting
    BOOL                    fFatalErrorWasSignaled;
    BOOL                    fLineTooLongWasIgnored;

    // Set when we get CONNECT for AT+FRH=3. If this is not set when call ends,
    // it means the other side never sent any HDLC flags, and therefore is not
    // considered a fax machine.
    BOOL                    fReceivedHDLCflags;     
    // Set when we send FTT, reset when we receive the next frame. If the next
    // frame is DCN, it means the other side has disconnected because of the FTT
    BOOL                    fSentFTT;

// abort sync.
    HANDLE                  AbortReqEvent;
    HANDLE                  AbortAckEvent;
    
    // fUnblockIO:
    // Original documentation says: pending I/O should be aborted ONCE only
    //
    // This flag never initiated, but it's value is FALSE (0) at start. 
    