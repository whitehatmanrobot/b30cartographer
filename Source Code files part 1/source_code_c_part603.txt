eck pixel Aspect Ratio
        if (m_GifScreen.AspectRatio != 0 && m_GifScreen.AspectRatio != 49)
        {
            float r;
            r = ((float) (m_GifScreen.AspectRatio) + (float) 15.0) / (float) 64.0;
            DbgLog((LOG_TRACE, 1, TEXT("GIF Warning: non-square pixels!\n")));
        }
    

    while(1)
    {
        if (!Read(&c, 1))
        {
            DbgLog((LOG_TRACE, 1, TEXT("EOF / read error on image data\n")));
            //*X*  RaiseException_UserError(E_FAIL, IDS_ERR_CORRUPT_FILE,_szFileName);
            goto exitPoint;
        }
        
        //*X* search for ;-> terminator !->extension  ,->not a valid start charactor
        if (c == ';')
        {   /* GIF terminator */
            if (m_imageCount < imageNumber)
            {
                DbgLog((LOG_TRACE, 1, TEXT("No images found in file\n")));
                //RaiseException_UserError(E_FAIL, IDS_ERR_DECODER_FAILED,_szFileName);
                goto exitPoint;
             }
        }

        if (c == '!')
        {     /* Extension */
              if (!Read(&c, 1))
              {
                DbgLog((LOG_TRACE, 1, TEXT("EOF / read error on extension function code\n")));
                //RaiseException_UserError(E_FAIL, IDS_ERR_CORRUPT_FILE,_szFileName);
                goto exitPoint;
               }
		// this will update the disposal. remember what it used to be
		// (the frame we are reading is affected by the PREVIOUS 
		// disposal)
               disposal = m_gifinfo.Gif89.disposal;
               DoExtension(c);
               continue;
        }

        if (c != ',')
        {    /* Not a valid start character */
            goto exitPoint;
        }

        ++m_imageCount;

        //*X* read another 9 charactor
        if (!Read(buf, 9))
        {
            DbgLog((LOG_TRACE, 1, TEXT("couldn't read left/top/width/height\n")));
            goto exitPoint;
        }
        // Use the GIF's main palette, not a special palette for this frame
        useGlobalColormap = !BitSet(buf[8], LOCALCOLORMAP);

	// if this frame has its own palette, how many colors?
        NumColors = 1 << ((buf[8] & 0x07) + 1);
        //bitCount =(buf[8] & 0x07)+1;
	bitCount = 8;

        /*
         * We only want to set width and height for the imageNumber
         * we are requesting.
         */
        //if (imageCount == imageNumber)  //*X* imageNumber is set to 1
        if (lpbi!=NULL)  
        {
           // Replicate some of Netscape's special cases:
           // Don't use the logical screen if it's a GIF87a and the topLeft of the first image is at the origin.
           // Don't use the logical screen if the first image spills out of the logical screen.
           // These are artifacts of primitive authoring tools falling into the hands of hapless users.
           RECT    rectImage;  // rect defining bounds of GIF
           //RECT    rectLS;     // rect defining bounds of GIF logical screen.
           //RECT    rectSect;   // intersection of image an logical screen
           //BOOL    fNoSpill;   // True if the image doesn't spill out of the logical screen
           //BOOL    fGoofy87a;  // TRUE if its one of the 87a pathologies that Netscape special cases

           rectImage.left = LM_to_uint(buf[0], buf[1]);
           rectImage.top = LM_to_uint(buf[2], buf[3]);
           rectImage.right = rectImage.left + LM_to_uint(buf[4], buf[5]);
           rectImage.bottom = rectImage.top + LM_to_uint(buf[6], buf[7]);

           DbgLog((LOG_TRACE,3,TEXT("(%d,%d,%d,%d) %d"),
			(int)rectImage.left,
			(int)rectImage.top,
			(int)(rectImage.right - rectImage.left),
			(int)(rectImage.bottom - rectImage.top),
			(int)buf[8]));

            m_ITrans = m_gifinfo.Gif89.transparent;
        }
        
        // this frame has its own palette
        if (!useGlobalColormap)
        {
            if (ReadColorMap(NumColors, rgbLocal)) {
                DbgLog((LOG_TRACE, 1, TEXT("error reading local colormap\n")));
                goto exitPoint;
            }
        }

	// make a 32 bit per pixel area
        long w = m_GifScreen.Width;
        long stride = w * 4;	// 4 bytes per pixel
        stride = ((stride + 3) / 4) * 4;
        long h = m_GifScreen.Height;
        long dwBits  = stride * h;

	// this particular frame's placement
	long left = LM_to_uint(buf[0], buf[1]);
	long top = LM_to_uint(buf[2], buf[3]);
	long width = LM_to_uint(buf[4], buf[5]);
	long height = LM_to_uint(buf[6], buf[7]);
	// correct for upside downness
	top = h - (top + height);

        PBYTE pbImage = new BYTE[dwBits];
	if (pbImage == NULL) 
	    return E_OUTOFMEMORY;

	// Disposal mode 0/1 means DO NOT DISPOSE.  Any transparency in the next
	// frame will see right through to what was in this frame
	// Disposal mode 2 means DISPOSE of this frame when you're done, and 
	// write BACKGROUND colour in the rectangle
	// Disposal mode 3 means DISPOSE of this frame by putting everything
	// back the way it was in the PREVIOUS FRAME
	//

	// something in this frame will be transparent - either because this
	// image has a transparency colour, or it does not fill the entire 
	// canvas
        BOOL fSeeThru = m_ITrans != -1 || height < h || width < w;

	ASSERT(disposal < 4);	// not yet invented
        DbgLog((LOG_TRACE,3,TEXT("Using previous disposal=%d"), disposal));

	// Disposal 0 or 1 - if any pixels will be transparent, init with
	// previous frames bits
	if (m_pList && disposal < 2 && fSeeThru) {
	    CopyMemory(pbImage, m_pListTail->pbImage, dwBits);

	// Disposal 2 - dispose of last frame's rect with key colour
	} else if (m_pList && disposal == 2 && fSeeThru) {
	    // init with the previous frame outside of the area being disposed
	    if (oldWidth < w || oldHeight < h) {
	        CopyMemory(pbImage, m_pListTail->pbImage, dwBits);
	    }
	    // now dispose of the last frame's portion
	    Dispose2(pbImage, stride, oldLeft, oldTop, oldWidth, oldHeight);

	// Disposal 3 - dispose of last frame's rect with 2nd to last frame data
	// 		(if there is one)
	} else if (pListOldTail && disposal == 3 && fSeeThru) {
	    // init with the previous frame outside of the area being disposed
	    if (oldWidth < w || oldHeight < h) {
	        CopyMemory(pbImage, m_pListTail->pbImage, dwBits);
	    }
	    // now dispose of the last frame by replacing with 2nd to last frame
	    Dispose3(pbImage, pListOldTail->pbImage, stride, oldLeft,
						oldTop, oldWidth, oldHeight);

	// else init with key color if anything transparent
	} else if (fSeeThru) {
	    ZeroMemory(pbImage, dwBits);    // init to key color (superblack)
	}
        
        hr = ReadImage(w, h, left, top, width, height,	// all in pixels
				stride,			// stride in bytes
				m_ITrans, 		// transparency
                                BitSet(buf[8], INTERLACE),
                                m_imageCount != imageNumber, 
				// special palette for this frame?
				useGlobalColormap ? rgbGlobal : rgbLocal,
                                pbImage);

	// remember the frame before last
	pListOldTail = m_pListTail;

        if(m_pList==NULL)
        {
            m_pList=new LIST;
            m_pList->pbImage=pbImage;
	    // remember the duration for this frame of the animated GIF
            m_pList->delayTime=m_gifinfo.Gif89.delayTime;
	    if (m_pList->delayTime < 5)
		m_pList->delayTime = 10;	// IE does this so I better too
            DbgLog((LOG_TRACE,3,TEXT("GIF delay=%ld"), m_pList->delayTime));
	    m_pList->next = NULL;
            m_pListTail=m_pList;
        }
        else
        {
            m_pListTail->next=new LIST;
            m_pListTail=m_pListTail->next;
            m_pListTail->pbImage=pbImage;
	    // remember the duration for this frame of the animated GIF
            m_pListTail->delayTime=m_gifinfo.Gif89.delayTime;
	    if (m_pListTail->delayTime < 5)
		m_pListTail->delayTime = 10;	// IE does this so I better too
            DbgLog((LOG_TRACE,3,TEXT("GIF delay=%ld"), m_pListTail->delayTime));
	    m_pListTail->next = NULL;
        }

	// there may not be a new duration on each frame... just keep the
	// delay time and disposal variables as they are in case they aren't
	// set for the next frame

        // sanity check the numbers, before remembering them or we'll fault.
        // The above code needed to see them as they were, without being fixed.
        if (left + width > w)
            width = w - left;
        if (top + height > h)
            height = h - top;

	// the area covered by this last frame
	oldTop = top;
	oldLeft = left;
	oldWidth = width;
	oldHeight = height;
    }

    //*X* make new media format

exitPoint:
    if(m_pList!=NULL) {
	// our media type is a 32 bit type
        BuildBitMapInfoHeader(lpbi, m_GifScreen.Width, m_GifScreen.Height,
								32, 0);
    }                   

    return hr;
}

/*X* 
    open gif file to get the mediatype
*X*/
HRESULT CImgGif::OpenGIFFile( LIST **ppList, CMediaType *pmt)
{
    ASSERT( (ppList!=NULL) );

    //*X* open an new GIF file, set m_imageCount to 0
    m_imageCount=0;

    //make media type
    VIDEOINFO *pvi = (VIDEOINFO *) pmt->AllocFormatBuffer(sizeof(VIDEOINFO));
    if (NULL == pvi) 
	    return(E_OUTOFMEMORY);
    ZeroMemory(pvi, sizeof(VIDEOINFO));

    LPBITMAPINFOHEADER lpbi = HEADER(pvi);

    //read the first page, return the format we're sending.
    HRESULT hr=ReadGIFMaster(pvi);

    // not possible?
    if (lpbi->biCompression > BI_BITFIELDS)
	    return E_INVALIDARG;

    pmt->SetType(&MEDIATYPE_Video);

    // we always produce 32 bit at the moment, but...
    switch (lpbi->biBitCount)
    {
        case 32:
	        pmt->SetSubtype(&MEDIASUBTYPE_ARGB32);
	        break;
        case 24:
		ASSERT(FALSE);
	        pmt->SetSubtype(&MEDIASUBTYPE_RGB24);
	        break;
        case 16:
		ASSERT(FALSE);
	        if (lpbi->biCompression == BI_RGB)
	            pmt->SetSubtype(&MEDIASUBTYPE_RGB555);
	        else {
	            DWORD *p = (DWORD *)(lpbi + 1);
	            if (*p == 0x7c00 && *(p+1) == 0x03e0 && *(p+2) == 0x001f)
    	            pmt->SetSubtype(&MEDIASUBTYPE_RGB555);
	            else if (*p == 0xf800 && *(p+1) == 0x07e0 && *(p+2) == 0x001f)
	                pmt->SetSubtype(&MEDIASUBTYPE_RGB565);
	            else
		            return E_INVALIDARG;
	        }
	        break;
        case 8:
		ASSERT(FALSE);
	        if (lpbi->biCompression == BI_RLE8) {
	            FOURCCMap fcc = BI_RLE8;
	            pmt->SetSubtype(&fcc);
	        } else
	            pmt->SetSubtype(&MEDIASUBTYPE_RGB8);

	        break;
        case 4:
		ASSERT(FALSE);
	        if (lpbi->biCompression == BI_RLE4) {
	            FOURCCMap fcc = BI_RLE4;
	            pmt->SetSubtype(&fcc);
	        } else
	        pmt->SetSubtype(&MEDIASUBTYPE_RGB4);
	        break;
        case 1:
		ASSERT(FALSE);
	        pmt->SetSubtype(&MEDIASUBTYPE_RGB1);
	        break;
        default:
		ASSERT(FALSE);
	        return E_UNEXPECTED;
	        break;
    }
    pmt->SetFormatType(&FORMAT_VideoInfo);
    pmt->SetTemporalCompression(FALSE);

    // Calculate the memory needed to hold the DIB - DON'T TRUST biSizeImage!
    DWORD dwBits = DIBSIZE(*lpbi); 
    pmt->SetSampleSize(dwBits);

    //make it circular link list
    m_pListTail->next=m_pList;

    *ppList = m_pList;
    
    return hr;
}
=== C:/Users/treeman/Desktop/windows nt source code\Source\Win2K3\NT\multimedia\dshow\filterus\dexter\silence\silence.h ===
//@@@@AUTOBLOCK+============================================================;
//
//  THIS CODE AND INFORMATION IS PROVIDED "AS IS" WITHOUT WARRANTY OF ANY
//  KIND, EITHER EXPRESSED OR IMPLIED, INCLUDING BUT NOT LIMITED TO THE
//  IMPLIED WARRANTIES OF MERCHANTABILITY AND/OR FITNESS FOR A PARTICULAR
//  PURPOSE.
//
//  File: silence.h
//
//  Copyright (c) Microsoft Corporation.  All Rights Reserved.
//
//@@@@AUTOBLOCK-============================================================;

// Designed for warning level:4
#pragma warning (disable: 4100 4201 4244)

#ifndef __SILENCE__
#define __SILENCE__

#define MAXBUFFERCNT   1

class CSilenceFilter;
class CSilenceStream;
class CFilterPropertyPage;

// -------------------------------------------------------------------------
// CSilenceStream
// -------------------------------------------------------------------------

class CSilenceStream :    public CSourceStream
			, public IDexterSequencer
			, public ISpecifyPropertyPages
			, public IMediaSeeking
{ // CSilenceStream //

    public:

      // CSourceStream

      CSilenceStream (HRESULT *phr, CSilenceFilter *pParent, LPCWSTR pPinName);
      ~CSilenceStream ();

      DECLARE_IUNKNOWN;

      // Reveal our interfaces
      STDMETHODIMP NonDelegatingQueryInterface (REFIID, void **);

      HRESULT FillBuffer (IMediaSample *);
      HRESULT GetMediaType (CMediaType *);
      HRESULT DecideBufferSize (IMemAllocator *, ALLOCATOR_PROPERTIES *);
      HRESULT DecideAllocator (IMemInputPin *, IMemAllocator **);
      HRESULT Active (void);

      // ISpecifyPropertyPages
      STDMETHODIMP GetPages (CAUUID *);

      // IDexterSequencer methods
      STDMETHODIMP get_MediaType(AM_MEDIA_TYPE *pmt);
      STDMETHODIMP put_MediaType(const AM_MEDIA_TYPE *pmt);
      STDMETHODIMP get_OutputFrmRate(double *pRate) {return E_NOTIMPL;};
      STDMETHODIMP put_OutputFrmRate(double Rate) {return E_NOTIMPL;};
      STDMETHODIMP GetStartStopSkew(REFERENCE_TIME *, REFERENCE_TIME *,
					REFERENCE_TIME *, double *);
      STDMETHODIMP AddStartStopSkew(REFERENCE_TIME, REFERENCE_TIME,
					REFERENCE_TIME, double);
      STDMETHODIMP ClearStartStopSkew();
      STDMETHODIMP GetStartStopSkewCount(int *);

      // IMediaSeeking methods
      STDMETHODIMP GetCapabilities (DWORD *);
      STDMETHODIMP CheckCapabilities (DWORD *);
      STDMETHODIMP SetTimeFormat (const GUID *);
      STDMETHODIMP GetTimeFormat (GUID *);
      STDMETHODIMP IsUsingTimeFormat (const GUID *);
      STDMETHODIMP IsFormatSupported (const GUID *);
      STDMETHODIMP QueryPreferredFormat (GUID *);
      STDMETHODIMP ConvertTimeFormat (LONGLONG *, const GUID *, LONGLONG, const GUID *) { return E_NOTIMPL; };
      STDMETHODIMP SetPositions (LONGLONG *, DWORD, LONGLONG *, DWORD);
      STDMETHODIMP GetPositions (LONGLONG *, LONGLONG *);
      STDMETHODIMP GetCurrentPosition (LONGLONG *);
      STDMETHODIMP GetStopPosition (LONGLONG *);
      STDMETHODIMP SetRate (double) { return E_NOTIMPL; };
      STDMETHODIMP GetRate (double *);
      STDMETHODIMP GetDuration (LONGLONG *);
      STDMETHODIMP GetAvailable (LONGLONG *, LONGLONG *);
      STDMETHODIMP GetPreroll (LONGLONG *) { return E_NOTIMPL; };

    private:

      REFERENCE_TIME  m_rtStartTime;
      REFERENCE_TIME  m_rtDuration;

      REFERENCE_TIME  m_rtStamp;
      REFERENCE_TIME  m_rtDelta;

      REFERENCE_TIME  m_rtNewSeg;	// last NewSeg we sent

      CMediaType m_mtAccept;	// accept only this type

      friend class CSilenceFilter;


      int		m_iBufferCnt;			//record how many buffer it can gets
      BYTE		m_bZeroBufCnt;			// How many buffer already set to 0
      BYTE		**m_ppbDstBuf;

      CCritSec	m_csFilling;	// are we filling a buffer now?


  };

// -------------------------------------------------------------------------
// CSilenceFilter
// -------------------------------------------------------------------------

class CSilenceFilter : public CSource
			, public CPersistStream

  { // CSilenceFilter //

    public:

      static CUnknown * WINAPI CreateInstance (LPUNKNOWN, HRESULT *);
      ~CSilenceFilter ();

      DECLARE_IUNKNOWN;

      // Reveal our interfaces
      STDMETHODIMP NonDelegatingQueryInterface (REFIID, void **);

      // CPersistStream
      HRESULT WriteToStream(IStream *pStream);
      HRESULT ReadFromStream(IStream *pStream);
      STDMETHODIMP GetClassID(CLSID *pClsid);
      int SizeMax();

    private:

      friend class CSilenceStream;

      CSilenceFilter (LPUNKNOWN, HRESULT *);

      CSilenceStream *m_stream;

  };

class CFilterPropertyPage : public CBasePropertyPage

  { // CFilterPropertyPage //

    public:

      static CUnknown *CreateInstance(LPUNKNOWN lpunk, HRESULT *phr);

    private:

      INT_PTR OnReceiveMessage (HWND, UINT ,WPARAM ,LPARAM);

      HRESULT OnConnect (IUnknown *);
      HRESULT OnDisconnect (void);
      HRESULT OnActivate (void);
      HRESULT OnDeactivate (void);
      HRESULT OnApplyChanges (void);

      void SetDirty (void);

      CFilterPropertyPage (LPUNKNOWN, HRESULT *);

      HRESULT GetControlValues (void);

      IDexterSequencer *m_pis;

      // Temporary variables (until OK/Apply)

      REFERENCE_TIME  m_rtStartTime;
      REFERENCE_TIME  m_rtDuration;

      UINT            m_nSamplesPerSec;  //samples/second
      int	      m_nChannelNum;	// audio channel
      int	      m_nBits;		// bits/sample

      BOOL            m_bInitialized;

};  // CFilterPropertyPage //

const AMOVIESETUP_MEDIATYPE sudOpPinTypes =

  {   // Media types - output

    &MEDIATYPE_Audio,   // clsMajorType
    &MEDIASUBTYPE_NULL  // clsMinorType

  };  // Media types - output

const AMOVIESETUP_PIN sudOpPin =
{ L"Output"          // strName
, FALSE              // bRendered
, TRUE               // bOutput
, FALSE              // bZero
, FALSE              // bMany
, &CLSID_NULL        // clsConnectsToFilter
, L"Input"           // strConnectsToPin
, 1                  // nTypes
, &sudOpPinTypes };  // lpTypes

const AMOVIESETUP_FILTER sudSilence =
{
  &CLSID_Silence,
  L"Silence",
  MERIT_DO_NOT_USE,
  1,
  &sudOpPin
};

#endif
=== C:/Users/treeman/Desktop/windows nt source code\Source\Win2K3\NT\multimedia\dshow\filterus\dexter\sr\sr.h ===
//@@@@AUTOBLOCK+============================================================;
//
//  THIS CODE AND INFORMATION IS PROVIDED "AS IS" WITHOUT WARRANTY OF ANY
//  KIND, EITHER EXPRESSED OR IMPLIED, INCLUDING BUT NOT LIMITED TO THE
//  IMPLIED WARRANTIES OF MERCHANTABILITY AND/OR FITNESS FOR A PARTICULAR
//  PURPOSE.
//
//  File: sr.h
//
//  Copyright (c) Microsoft Corporation.  All Rights Reserved.
//
//@@@@AUTOBLOCK-============================================================;

#ifndef __SR__
#define __SR__

#include "..\errlog\cerrlog.h"

// which input pin does what?
#define U_INPIN 0
#define C_INPIN 1
#define COMP_INPIN 2
#define COMP_OUTPIN 1

// our state machine
#define SR_INVALID -1
enum {
    SR_WAITING,	// waiting to get inputs on both pins
    SR_COMPRESSED,	// currently sending compressed data
    SR_UNCOMPRESSED // currently sending uncompressed data
};
	
extern const AMOVIESETUP_FILTER sudSR;

class CSR;
class CSROutputPin;
class CSRInputPin;
class CSRInputAllocator;

// class for the SR filter's Input allocator

class CSRInputAllocator : public CMemAllocator
{
    friend class CSRInputPin;

protected:

    CSRInputPin *m_pSwitchPin;

public:

    CSRInputAllocator(TCHAR *pName, LPUNKNOWN pUnk, HRESULT *phr) :
    	CMemAllocator(pName, pUnk, phr) {};
    ~CSRInputAllocator() {};

    STDMETHODIMP GetBuffer(IMediaSample **ppBuffer, REFERENCE_TIME *pStartTime,
                                  REFERENCE_TIME *pEndTime, DWORD dwFlags);
};


class CSRInputPin : public CBaseInputPin
{
    friend class CSRInputAllocator;
    friend class CSROutputPin;
    friend class CSR;

public:

    // Constructor and destructor
    CSRInputPin(TCHAR *pObjName,
                 CSR *pTee,
                 HRESULT *phr,
                 LPCWSTR pPinName);
    ~CSRInputPin();

    // overridden to allow cyclic-looking graphs
    STDMETHODIMP QueryInternalConnections(IPin **apPin, ULONG *nPin);

    // check the input pin connection
    HRESULT CheckMediaType(const CMediaType *pmt);

    // release our special allocator, if any
    HRESULT BreakConnect();

    // get our special SR allocator
    STDMETHODIMP GetAllocator(IMemAllocator **ppAllocator);

    // provide a type to make connecting faster?
    HRESULT GetMediaType(int iPosition, CMediaType *pMediaType);

    // don't allow us to connect directly to a switch output pin
    virtual HRESULT CompleteConnect(IPin *pReceivePin);

    // ask the switch for the allocator requirements
    STDMETHODIMP GetAllocatorRequirements(ALLOCATOR_PROPERTIES*pProps);

    // does special processing to make sure switch knows about the biggest
    // allocator provided to it
    STDMETHODIMP NotifyAllocator(IMemAllocator *pAllocator, BOOL bReadOnly);

    // pass on EOS, then see if we need to do a crank
    STDMETHODIMP EndOfStream();

    // very complicated function...
    STDMETHODIMP BeginFlush();

    // very complicated function...
    STDMETHODIMP EndFlush();

    // deliver every input's newsegment to every output pin
    //
    STDMETHODIMP NewSegment(
                    REFERENCE_TIME tStart,
                    REFERENCE_TIME tStop,
                    double dRate);

    // Just say yes, could possibly infinite loop?
    STDMETHODIMP ReceiveCanBlock();

    // Handles the next block of data from the stream
    STDMETHODIMP Receive(IMediaSample *pSample);

    // each type of pin does receive a little differently
    STDMETHODIMP U_Receive(IMediaSample *pSample, REFERENCE_TIME);
    STDMETHODIMP C_Receive(IMediaSample *pSample, REFERENCE_TIME);
    STDMETHODIMP COMP_Receive(IMediaSample *pSample, REFERENCE_TIME);

    // create and destroy synchronization events
    HRESULT Active();
    HRESULT Inactive();

protected:

    CSRInputAllocator *m_pAllocator; // our special allocator
    CSR *m_pSwitch;      // Main filter object
    int m_iInpin;	        // which input pin are we?
    int m_cBuffers;	        // number of buffers in allocator
    int m_cbBuffer;	        // size of the allocator buffers
    BOOL m_fOwnAllocator;	//using our own?
    HANDLE m_hEventBlock;	// event blocking receive/getbuffer
    HANDLE m_hEventSeek;	// block input while seeking
    REFERENCE_TIME m_rtBlock;	// sample arrived here
    REFERENCE_TIME m_rtLastDelivered;	// end time of last thing delivered
    BOOL m_fEOS;

    BOOL m_fReady;	// in WAITING state, is this pin done?
    BOOL m_fEatKeys;	// key eating mode?
    BOOL m_fNeedDiscon;	// U pin needs to set discon bit

    CCritSec m_csReceive;
};


// Class for the big switch filter's Output pins.

class CSROutputPin : public CBaseOutputPin, IMediaSeeking
{
    friend class CSRInputAllocator;
    friend class CSRInputPin;
    friend class CSR;

public:

    // Constructor and destructor

    CSROutputPin(TCHAR *pObjName,
                   CSR *pTee,
                   HRESULT *phr,
                   LPCWSTR pPinName);
    ~CSROutputPin();

    DECLARE_IUNKNOWN

    // Reveals IMediaSeeking
    STDMETHODIMP NonDelegatingQueryInterface(REFIID riid, void ** ppv);

    // overridden to allow cyclic-looking graphs
    STDMETHODIMP QueryInternalConnections(IPin **apPin, ULONG *nPin);

    // Check that we can support an output type, checks against switch's MT
    HRESULT CheckMediaType(const CMediaType *pmt);

    // gets the switch media type
    HRESULT GetMediaType(int iPosition, CMediaType *pMediaType);

    // Negotiation to use our input pins allocator. Weird fancy allocator stuff
    HRESULT DecideAllocator(IMemInputPin *pPin, IMemAllocator **ppAlloc);

    // make sure the allocator has the biggest size of any of our input pins
    // and output pins
    HRESULT DecideBufferSize(IMemAllocator *pMemAllocator,
                              ALLOCATOR_PROPERTIES * ppropInputRequest);

    // Overriden to handle quality messages
    STDMETHODIMP Notify(IBaseFilter *pSender, Quality q);

    // IMediaSeeking
    STDMETHODIMP IsFormatSupported(const GUID * pFormat);
    STDMETHODIMP QueryPreferredFormat(GUID *pFormat);
    STDMETHODIMP SetTimeFormat(const GUID * pFormat);
    STDMETHODIMP IsUsingTimeFormat(const GUID * pFormat);
    STDMETHODIMP GetTimeFormat(GUID *pFormat);
    STDMETHODIMP GetDuration(LONGLONG *pDuration);
    STDMETHODIMP GetStopPosition(LONGLONG *pStop);
    STDMETHODIMP GetCurrentPosition(LONGLONG *pCurrent);
    STDMETHODIMP GetCapabilities( DWORD * pCapabilities );
    STDMETHODIMP CheckCapabilities( DWORD * pCapabilities );
    STDMETHODIMP ConvertTimeFormat(
	LONGLONG * pTarget, const GUID * pTargetFormat,
	LONGLONG    Source, const GUID * pSourceFormat );
    STDMETHODIMP SetPositions(
	LONGLONG * pCurrent,  DWORD CurrentFlags,
	LONGLONG * pStop,  DWORD StopFlags );
    STDMETHODIMP GetPositions( LONGLONG * pCurrent, LONGLONG * pStop );
    STDMETHODIMP GetAvailable( LONGLONG * pEarliest, LONGLONG * pLatest );
    STDMETHODIMP SetRate( double dRate);
    STDMETHODIMP GetRate( double * pdRate);
    STDMETHODIMP GetPreroll(LONGLONG *pPreroll);

protected:

    CSR *m_pSwitch;                  // Main filter object pointer
    BOOL m_fOwnAllocator;	     // using our own?
    int m_iOutpin;	             // which output pin are we?
};




// Class for the Smart Recompression Filter

class CSR
    : public CCritSec
    , public CBaseFilter
    , public IAMSmartRecompressor
    , public CPersistStream
    , public CAMSetErrorLog
    , public IAMOutputBuffering	// ??
{
    // Let the pins access our internal state
    friend class CSRInputPin;
    friend class CSROutputPin;
    friend class CSRInputAllocator;
    friend class CSRWorker;
    
protected:

    STDMETHODIMP CreateInputPins(long);
    STDMETHODIMP CreateOutputPins(long);
    HRESULT AllDone();

    CSRInputPin **m_pInput;
    CSROutputPin **m_pOutput;
    int m_cInputs;
    int m_cOutputs;
    BOOL m_bAcceptFirstCompressed;

    REFERENCE_TIME m_rtStop;
    double m_dFrameRate;

    AM_MEDIA_TYPE m_mtAccept;		// all pins only connect with this

    BOOL m_fEOS;	// we are all done

    REFERENCE_TIME m_rtLastSeek;	// last timeline time seeked to
    REFERENCE_TIME m_rtNewLastSeek;	// last timeline time seeked to

    BOOL m_fSeeking;	// inside a seek?
    BOOL m_fSpecialSeek;// we are seeking ourself

    int m_cbPrefix, m_cbAlign;	// each pin needs its allocator to do these
    LONG m_cbBuffer;		// 

    CMemAllocator *m_pPoolAllocator;  // pool of extra buffers

    BOOL m_fPreview;

    int  m_nOutputBuffering;	// IAMOutputBuffering

public:

    DECLARE_IUNKNOWN

    // Reveals IAMSmartRecompressor
    STDMETHODIMP NonDelegatingQueryInterface(REFIID riid, void ** ppv);

    CSR(TCHAR *pName,LPUNKNOWN pUnk,HRESULT *hr);
    ~CSR();

    CBasePin *GetPin(int n);
    int GetPinCount();

    // Function needed for the class factory
    static CUnknown * WINAPI CreateInstance(LPUNKNOWN pUnk, HRESULT *phr);

    STDMETHODIMP Pause();
    STDMETHODIMP Stop();

    // IAMSmartRecompressor goes here
    //
    STDMETHODIMP GetMediaType(AM_MEDIA_TYPE *);
    STDMETHODIMP SetMediaType(AM_MEDIA_TYPE *);
    STDMETHODIMP GetFrameRate(double *);
    STDMETHODIMP SetFrameRate(double);
    STDMETHODIMP SetPreviewMode(BOOL);
    STDMETHODIMP GetPreviewMode(BOOL *);
    STDMETHODIMP AcceptFirstCompressed( ) { m_bAcceptFirstCompressed = TRUE; return NOERROR; }

    // IAMOutputBuffering ???
    STDMETHODIMP GetOutputBuffering(int *);
    STDMETHODIMP SetOutputBuffering(int);

    // CPersistStream
    HRESULT WriteToStream(IStream *pStream);
    HRESULT ReadFromStream(IStream *pStream);
    STDMETHODIMP GetClassID(CLSID *pClsid);
    int SizeMax();

    // change state of state machine
    HRESULT CheckState();

    // which time is bigger, and by how much?
    int CompareTimes(REFERENCE_TIME, REFERENCE_TIME);

    // seek our own U pin to the next spot needed
    HRESULT SeekNextSegment();

    int m_myState;

    BOOL m_fThreadCanSeek;	// safe to seek ourself?
    CCritSec m_csState;		// changing the state machine
    CCritSec m_csThread;	// we seek ourself, and the app seeks us

    BOOL m_fNewSegOK;		// OK to send a new segment

};

#endif // __SR__
=== C:/Users/treeman/Desktop/windows nt source code\Source\Win2K3\NT\multimedia\dshow\filterus\dexter\sr\sr.cpp ===
//@@@@AUTOBLOCK+============================================================;
//
//  THIS CODE AND INFORMATION IS PROVIDED "AS IS" WITHOUT WARRANTY OF ANY
//  KIND, EITHER EXPRESSED OR IMPLIED, INCLUDING BUT NOT LIMITED TO THE
//  IMPLIED WARRANTIES OF MERCHANTABILITY AND/OR FITNESS FOR A PARTICULAR
//  PURPOSE.
//
//  File: sr.cpp
//
//  Copyright (c) Microsoft Corporation.  All Rights Reserved.
//
//@@@@AUTOBLOCK-============================================================;

// !!! CANT OBEY SEEK COMMANDS YET

// This filter receives data on its uncompressed pin, from 0 to END, unbroken
// It also receives data on the compressed pin, but only part of the time.
//
// It will use the data on the compressed pin whenever it exists, and only use
// the uncompressed data when there is no compressed data.  The uncompressed
// data must be sent to a compressor before going to the main output, so that
// our filter's main output is always compressed.
//
// It is a state machine.  First of all, a WAITING state, to get input on both
// pins. Then if the U has earlier data than C, it goes into UNCOMPRESSED state,
// where it uses that pin.  Otherwise, into COMPRESSED state.
//
// When compressed pin runs out, or when a gap is seen, it seeks the
// UNCOMPRESSED pin to where it ran out and moves to UNCOMPRESSED state.
//
// When uncompressed pin gets to the time available on the compressed pin,
// it switches to COMPRESSED state.
//
// One more complication; the compressed pin throws away everything until it
// sees a key frame before letting it switch to using that data, or you'll get
// a corrupt data stream.
//

// Input 0 is uncompressed
// Input 1 is compressed
// Input 2 is the output of the compressor
//
// Output 0 is the main output
// Output 1 is to the compressor, which comes back as Input 2
//

#include <streams.h>
#include <qeditint.h>
#include <qedit.h>
#include <vfw.h>
#include "sr.h"
#include "..\util\conv.cxx"
#include "..\util\filfuncs.h"

//#define TEST

const AMOVIESETUP_FILTER sudSR =
{
    &CLSID_SRFilter,        // CLSID of filter
    L"Smart Recompressor",  // Filter's name
    MERIT_DO_NOT_USE,       // Filter merit
    0,                      // Number of pins
    NULL //psudPins         // Pin information
};

//
// CreateInstance
//
// Creator function for the class ID
//
CUnknown * WINAPI CSR::CreateInstance(LPUNKNOWN pUnk, HRESULT *phr)
{
    return new CSR(NAME("Smart Recompressor"), pUnk, phr);
}

const double DEFAULT_FPS = 15.0;

// ================================================================
// CSR Constructor
// ================================================================

CSR::CSR(TCHAR *pName, LPUNKNOWN pUnk, HRESULT *phr) :
    m_cInputs(0),	// no pins yet
    m_cOutputs(0),
    m_rtStop(-1),	// at what time we switch from U to C
    m_dFrameRate(DEFAULT_FPS),	// everything must be at this frame rate
    m_rtLastSeek(0),	// last seek command in timeline time
    m_fSeeking(FALSE),  // in the middle of seeking?
    m_fSpecialSeek(FALSE),  // we are seeking our own U pin, not an app seek
    m_cbPrefix(0),
    m_bAcceptFirstCompressed( TRUE ), // when connecting, use the media type first suggested on an input pin
    m_cbAlign(1),
    m_cbBuffer(512),
    m_fPreview(TRUE),
    m_nOutputBuffering(DEX_DEF_OUTPUTBUF),
    m_fEOS( FALSE ),
    m_rtNewLastSeek( 0 ),
    m_myState( 0 ),
    m_fThreadCanSeek( FALSE ),
    m_fNewSegOK( FALSE ),
    CBaseFilter(pName, pUnk, this, CLSID_SRFilter),
    CPersistStream(pUnk, phr)
{
    DbgLog((LOG_TRACE,1,TEXT("::CSR")));

    ZeroMemory(&m_mtAccept, sizeof(AM_MEDIA_TYPE));
    m_mtAccept.majortype = GUID_NULL;

    // as well as all the individual allocators, we have a pool of buffers
    // that all the inputs can use if they want to
    //
    m_pPoolAllocator = NULL;
    m_pPoolAllocator = new CMemAllocator(
		NAME("Special Switch pool allocator"), NULL, phr);
    if (FAILED(*phr)) {
	return;
    }
    m_pPoolAllocator->AddRef();
    DbgLog((LOG_TRACE,1,TEXT("Created a POOL Allocator")));

    CreateInputPins(3);
    CreateOutputPins(2);

    ASSERT(phr);
}


//
// Destructor
//
CSR::~CSR()
{
    DbgLog((LOG_TRACE,1,TEXT("::~CSR")));

    DbgLog((LOG_TRACE,1,TEXT("Deleting inputs")));
    for (int z = 0; z < m_cInputs; z++)
	delete m_pInput[z];
    if (m_cInputs)
        delete m_pInput;
    DbgLog((LOG_TRACE,1,TEXT("Deleting outputs")));
    for (z = 0; z < m_cOutputs; z++)
	delete m_pOutput[z];
    if (m_cOutputs)
        delete m_pOutput;
    SaferFreeMediaType( m_mtAccept );
    if (m_pPoolAllocator)
        m_pPoolAllocator->Release();
}



STDMETHODIMP CSR::NonDelegatingQueryInterface(REFIID riid, void ** ppv)
{
    CheckPointer(ppv,E_POINTER);

    if (riid == IID_IAMSetErrorLog) {
        return GetInterface( (IAMSetErrorLog*) this, ppv );
    } else if (riid == IID_IAMOutputBuffering) {
        return GetInterface( (IAMOutputBuffering*) this, ppv );
    } else if (riid == IID_IAMSmartRecompressor) {
        DbgLog((LOG_TRACE,1,TEXT("CSR: QI for IAMSmartRecompressor")));
        return GetInterface((IAMSmartRecompressor *) this, ppv);
    } else if (riid == IID_IPersistStream) {
        return GetInterface((IPersistStream *) this, ppv);
    }
    return CBaseFilter::NonDelegatingQueryInterface(riid, ppv);
}

//
// IAMSmartRecompressor implementation
//

// connect with this media type
//
STDMETHODIMP CSR::SetMediaType(AM_MEDIA_TYPE *pmt)
{
    CAutoLock cObjectLock(m_pLock);
    CheckPointer(pmt, E_POINTER);
    if (m_State != State_Stopped)
	return VFW_E_NOT_STOPPED;

    DbgLog((LOG_TRACE,1,TEXT("IAMSmartRecompressor::SetMediaType")));
    for (int i = 0; i < m_cInputs; i++) {
	if (m_pInput[i]->IsConnected())
	    return VFW_E_ALREADY_CONNECTED;
    }
    for (i = 0; i < m_cOutputs; i++) {
	if (m_pOutput[i]->IsConnected())
	    return VFW_E_ALREADY_CONNECTED;
    }

    SaferFreeMediaType(m_mtAccept);
    HRESULT hr = CopyMediaType(&m_mtAccept, pmt);
    SetDirty(TRUE);
    return hr;
}


// what media type are we connecting with?
//
STDMETHODIMP CSR::GetMediaType(AM_MEDIA_TYPE *pmt)
{
    CAutoLock cObjectLock(m_pLock);
    DbgLog((LOG_TRACE,1,TEXT("IAMSmartRecompressor::GetMediaType")));
    CheckPointer(pmt, E_POINTER);
    return CopyMediaType(pmt, &m_mtAccept);
}



STDMETHODIMP CSR::GetFrameRate(double *pd)
{
    CAutoLock cObjectLock(m_pLock);
    CheckPointer(pd, E_POINTER);
    *pd = m_dFrameRate;
    DbgLog((LOG_TRACE,1,TEXT("IAMSmartRecompressor::GetFrameRate %d/10"), (int)(*pd * 10)));
    return S_OK;
}


STDMETHODIMP CSR::SetFrameRate(double d)
{
    CAutoLock cObjectLock(m_pLock);
    if (m_State != State_Stopped)
	return VFW_E_NOT_STOPPED;
    if (d <= 0.)
	return E_INVALIDARG;
    DbgLog((LOG_TRACE,1,TEXT("IAMSmartRecompressor::SetFrameRate %d/10 fps"),
						(int)(d * 10)));
    m_dFrameRate = d;
    SetDirty(TRUE);
    return S_OK;
}


STDMETHODIMP CSR::SetPreviewMode(BOOL fPreview)
{
    CAutoLock cObjectLock(m_pLock);
    if (m_State != State_Stopped)
	return VFW_E_NOT_STOPPED;
    DbgLog((LOG_TRACE,2,TEXT("SR:  PreviewMode %d"), fPreview));
    m_fPreview = fPreview;
    return NOERROR;
}


STDMETHODIMP CSR::GetPreviewMode(BOOL *pfPreview)
{
    CAutoLock cObjectLock(m_pLock);
    if (m_State != State_Stopped)
	return VFW_E_NOT_STOPPED;
    CheckPointer(pfPreview, E_POINTER);
    *pfPreview = m_fPreview;
    return NOERROR;
}



//
// GetPinCount
//
int CSR::GetPinCount()
{
    return (m_cInputs + m_cOutputs);
}


//
// GetPin
//
CBasePin *CSR::GetPin(int n)
{
    if (n < 0 || n >= m_cInputs + m_cOutputs)
        return NULL;

    if (n < m_cInputs) {
        return m_pInput[n];
    } else {
	return m_pOutput[n - m_cInputs];
    }
}


//
// CreateInputPins
//
HRESULT CSR::CreateInputPins(long Depth)
{
    DbgLog((LOG_TRACE,3,TEXT("CSR::CreateInputPins")));
    HRESULT hr = NOERROR;
    const WCHAR *szbuf;
    CSRInputPin *pPin;

    m_pInput = new CSRInputPin *[Depth];
    for (int z = 0; z < Depth; z++) 
    {
    	if (z == U_INPIN)
                szbuf = L"Uncompressed";
    	else if (z == C_INPIN)
                szbuf = L"Compressed";
    	else if (z == COMP_INPIN)
                szbuf = L"From Compressor";
    	else
        {
            ASSERT(FALSE);
            return E_FAIL;
        }
        pPin = new CSRInputPin(NAME("Switch Input"), this, &hr, szbuf);
        if (FAILED(hr) || pPin == NULL) 
        {
            delete pPin;
            return E_OUTOFMEMORY;
        }
    	m_cInputs++;
     	m_pInput[z] = pPin;
    	pPin->m_iInpin = z;	// which pin is this?
    }
    return S_OK;
}


//
// CreateOutputPins
//
HRESULT CSR::CreateOutputPins(long Depth)
{
    DbgLog((LOG_TRACE,3,TEXT("CSR::CreateOutputPins")));
    HRESULT hr = NOERROR;
    const WCHAR *szbuf;
    CSROutputPin *pPin;

    m_pOutput = new CSROutputPin *[Depth];
    for (int z = 0; z < Depth; z++) 
    {
    	if (z == 0)
                szbuf = L"Output";
    	else if (z == 1)
                szbuf = L"To Compressor";
    	else
        {
            ASSERT(FALSE);
            return E_FAIL;
        }
        pPin = new CSROutputPin(NAME("Switch Output"), this, &hr, szbuf);
        if (FAILED(hr) || pPin == NULL) 
        {
            delete pPin;
            return E_OUTOFMEMORY;
        }
    	m_cOutputs++;
     	m_pOutput[z] = pPin;
    	pPin->m_iOutpin = z;	// which pin is this?
    }
    return S_OK;
}



//
// IPersistStream
//

// tell our clsid
//
STDMETHODIMP CSR::GetClassID(CLSID *pClsid)
{
    CheckPointer(pClsid, E_POINTER);
    *pClsid = CLSID_SRFilter;
    return S_OK;
}


typedef struct {
    int version;
    double dFrameRate;
    BOOL fPreviewMode;
    AM_MEDIA_TYPE mt; // format is hidden after the array
} saveSwitch;


// persist ourself - we have a bunch of random stuff to save, our media type
// (sans format), an array of queued connections, and finally the format of
// the media type
//
HRESULT CSR::WriteToStream(IStream *pStream)
{
    DbgLog((LOG_TRACE,1,TEXT("CSR::WriteToStream")));

    CheckPointer(pStream, E_POINTER);
    int savesize;
    saveSwitch *px;

    savesize = sizeof(saveSwitch) + m_mtAccept.cbFormat;
    DbgLog((LOG_TRACE,1,TEXT("Persisted data is %d bytes"), savesize));
    px = (saveSwitch *)QzTaskMemAlloc(savesize);
    if (px == NULL) {
        DbgLog((LOG_ERROR,1,TEXT("*** Out of memory")));
	return E_OUTOFMEMORY;
    }
    px->version = 1;  // version 2 has dynamic stuff in it!
    px->dFrameRate = m_dFrameRate;
    px->fPreviewMode = m_fPreview;
    px->mt = m_mtAccept; // AM_MEDIA_TYPE
    // Can't persist pointers
    px->mt.pbFormat = NULL;
    px->mt.pUnk = NULL;		// !!!

    // the format goes after the array
    CopyMemory(px + 1, m_mtAccept.pbFormat, m_mtAccept.cbFormat);

    HRESULT hr = pStream->Write(px, savesize, 0);
    QzTaskMemFree(px);
    if(FAILED(hr)) {
        DbgLog((LOG_ERROR,1,TEXT("*** WriteToStream FAILED")));
        return hr;
    }
    return NOERROR;
}


// load ourself back in
//
HRESULT CSR::ReadFromStream(IStream *pStream)
{
    DbgLog((LOG_TRACE,1,TEXT("CSR::ReadFromStream")));
    CheckPointer(pStream, E_POINTER);

    // we don't yet know how many saved connections there are
    // all we know we have for sure is the beginning of the struct
    int savesize1 = sizeof(saveSwitch);
    saveSwitch *px = (saveSwitch *)QzTaskMemAlloc(savesize1);
    if (px == NULL) {
        DbgLog((LOG_ERROR,1,TEXT("*** Out of memory")));
	return E_OUTOFMEMORY;
    }

    HRESULT hr = pStream->Read(px, savesize1, 0);
    if(FAILED(hr)) {
        DbgLog((LOG_ERROR,1,TEXT("*** ReadFromStream FAILED")));
        QzTaskMemFree(px);
        return hr;
    }

    if (px->version != 1) {
        DbgLog((LOG_ERROR,1,TEXT("*** ERROR! Bad version file")));
        QzTaskMemFree(px);
	return S_OK;
    }

    // how much saved data was there, really?  Get the rest
    int savesize = sizeof(saveSwitch) + px->mt.cbFormat;
    DbgLog((LOG_TRACE,1,TEXT("Persisted data is %d bytes"), savesize));
    px = (saveSwitch *)QzTaskMemRealloc(px, savesize);
    if (px == NULL) {
        DbgLog((LOG_ERROR,1,TEXT("*** Out of memory")));
	// ??? QzTaskMemFree(px);
	return E_OUTOFMEMORY;
    }
    hr = pStream->Read(px + 1, savesize - savesize1, 0);
    if(FAILED(hr)) {
        DbgLog((LOG_ERROR,1,TEXT("*** ReadFromStream FAILED")));
        QzTaskMemFree(px);
        return hr;
    }

    SetFrameRate(px->dFrameRate);
    SetPreviewMode(px->fPreviewMode);

    AM_MEDIA_TYPE mt = px->mt;
    mt.pbFormat = (BYTE *)QzTaskMemAlloc(mt.cbFormat);
    // remember, the format is after the array
    CopyMemory(mt.pbFormat, px + 1, mt.cbFormat);

    SetMediaType(&mt);
    SaferFreeMediaType(mt);
    QzTaskMemFree(px);
    SetDirty(FALSE);
    return S_OK;
}


// how big is our save data?
//
int CSR::SizeMax()
{
    return sizeof(saveSwitch) + m_mtAccept.cbFormat;
}


// Pause
//
// Overriden to handle no input connections
//
STDMETHODIMP CSR::Pause()
{
    DbgLog((LOG_TRACE,1,TEXT("CSR::Pause")));

    CAutoLock cObjectLock(m_pLock);
    HRESULT hr = S_OK;

    if (m_State == State_Stopped) {

	m_fEOS = FALSE;
        m_fThreadCanSeek = FALSE;	// can't seek ourself yet

	m_fNewSegOK = TRUE;	// the first NewSeg after we start is OK
				// to propogate downstream

	// set initial state of state machine to WAITING
        m_myState = SR_INVALID;
        CheckState();

        hr = m_pPoolAllocator->Commit(); // !!! danny had this outside the 'if'
        if (FAILED(hr))
	    return hr;
    }
    return CBaseFilter::Pause();
}


// the state machine sees if it's time to change state
//
HRESULT CSR::CheckState()
{
    CAutoLock cs(&m_csState);

    // uninitialized state? go into WAITING state.
    // in the WAITING state, all pins block in receive, and are not ready
    //
    if (m_myState == SR_INVALID) {
        m_myState = SR_WAITING;
        DbgLog((LOG_TRACE,2,TEXT("CSR::Entering WAITING state")));

	// only the U and C pins get reset like this
	for (int z=0; z < COMP_INPIN; z++) {
	    m_pInput[z]->m_fReady = FALSE;
	    m_pInput[z]->m_fEatKeys = FALSE;
	    ResetEvent(m_pInput[z]->m_hEventBlock);
	    m_pInput[z]->m_rtLastDelivered = -1;
	}
    }

    // not ready to change state yet unless both U and C are ready
    if (!m_pInput[U_INPIN]->m_fReady || !m_pInput[C_INPIN]->m_fReady)
	return S_OK;

    // all done?
    if (m_pInput[U_INPIN]->m_fEOS && m_pInput[C_INPIN]->m_fEOS) {
        DbgLog((LOG_TRACE,2,TEXT("CSR::ALL DONE!")));
	AllDone();
	return S_OK;
    }

    // change state?

    if (m_myState == SR_WAITING) {
        DbgLog((LOG_TRACE,2,TEXT("CSR::Both inputs are ready.")));

	// we have uncompressed data strictly earlier than compressed data.
	// so UNC state is next
	if (CompareTimes(m_pInput[U_INPIN]->m_rtBlock,
				m_pInput[C_INPIN]->m_rtBlock) > 0) {
            DbgLog((LOG_TRACE,2,TEXT("CSR::Entering UNCOMPRESSED state")));
	    m_myState = SR_UNCOMPRESSED;
	    // this makes sure U won't throw away its blocked sample, because
	    // the sample it's blocking is one we need to use
	    m_pInput[U_INPIN]->m_fReady = TRUE;	// don't throw it away
	    // to make the compressor realize this new data being compressed
	    // in no way relates to whatever it last saw
	    m_pInput[U_INPIN]->m_fNeedDiscon = TRUE;
	    // this is where we'll switch back to C samples
	    m_rtStop = m_pInput[C_INPIN]->m_rtBlock;
	    // let U go
	    SetEvent(m_pInput[U_INPIN]->m_hEventBlock);
	} else {
            DbgLog((LOG_TRACE,2,TEXT("CSR::Entering COMPRESSED state")));
	    m_myState = SR_COMPRESSED;
	    // this makes sure C won't throw away its blocked sample
	    m_pInput[C_INPIN]->m_fReady = TRUE;	// don't throw it away
	    // Let C go
	    SetEvent(m_pInput[C_INPIN]->m_hEventBlock);
	}


    // after UNC state can only come COMP state
    } else if (m_myState == SR_UNCOMPRESSED) {
        DbgLog((LOG_TRACE,2,TEXT("CSR::Finished UNCOMPRESSED state")));
        DbgLog((LOG_TRACE,2,TEXT("     Last sent: %dms"),
			(int)(m_pInput[U_INPIN]->m_rtLastDelivered / 10000)));
	m_myState = SR_COMPRESSED;
	// this makes sure C won't throw away its blocked sample
	m_pInput[C_INPIN]->m_fReady = TRUE;	// don't throw it away
	// tell compressor filter to release any cached data, in case it
	// delivers several frames behind us delivering to it.  When the
	// compressor gives us an EOS, we'll know it's safe to go into
	// COMP state, and do it then.
	m_pOutput[COMP_OUTPIN]->DeliverEndOfStream();
        DbgLog((LOG_TRACE,1,TEXT("CSR::Waiting for compressor to finish.")));

    // after COMP state can only come UNC state
    } else if (m_myState == SR_COMPRESSED) {
        DbgLog((LOG_TRACE,2,TEXT("CSR::Finished COMPRESSED state")));
        DbgLog((LOG_TRACE,2,TEXT("     Last sent: %dms"),
			(int)(m_pInput[C_INPIN]->m_rtLastDelivered / 10000)));
	m_myState = SR_UNCOMPRESSED;
	// this makes sure U throws away its blocked sample and starts where
	// we seek it.. the sample it's holding is old and stale, we're about
	// to seek it to the spot we want
	m_pInput[U_INPIN]->m_fReady = FALSE;	// throw it away
	// to make the compressor realize this new data being compressed
	// in no way relates to whatever it last saw
	m_pInput[U_INPIN]->m_fNeedDiscon = TRUE;
	// this is when to switch to C state, the point where C has samples
	m_rtStop = m_pInput[C_INPIN]->m_rtBlock;
	// seek U pin to next part we need
	m_fThreadCanSeek = TRUE;	// OK to seek our own U pin
	HRESULT hr = SeekNextSegment();	// OK, U pin, seek to where we need you
	if (FAILED(hr))
	    return hr;
	// now let the U pin go
        DbgLog((LOG_TRACE,1,TEXT("CSR:Seek done.Entering UNCOMPRESSED state")));

	// The seek will generate a flush, since the pin is active, and that
	// flush will unblock the U pin
	//SetEvent(m_pInput[U_INPIN]->m_hEventBlock);
    }


    return S_OK;
}


STDMETHODIMP CSR::Stop()
{
    DbgLog((LOG_TRACE,1,TEXT("CSR::Stop")));

    CAutoLock cObjectLock(m_pLock);

    m_pPoolAllocator->Decommit();

    return CBaseFilter::Stop();
}



// Are they close, or is one really so much bigger that it's a whole frame
// away?  Also, is is >1 frame away?
//
int CSR::CompareTimes(REFERENCE_TIME rt1, REFERENCE_TIME rt2)
{
    // half a frame
    REFERENCE_TIME half = (REFERENCE_TIME)(UNITS / m_dFrameRate / 2);

// !!! is this right?

    if (rt1 + half >= rt2 && rt2 + half >= rt1)
	return 0;			// same
    else if (rt1 + 3 * half < rt2)
	return 2;			// rt2 >1 frame bigger
    else if (rt1 < rt2)
	return 1;			// rt2 1 frame bigger
    else if (rt2 + 3 * half < rt1)
	return -2;			// rt1 >1 frame bigger
    else if (rt2 < rt1)
	return -1;			// rt1 1 frame bigger
	
    ASSERT(FALSE);
    return 0;
}




// seek the U pin to the next spot it needs to provide.  Note that this is
// only ever called on the C pin's thread, that is why it is safe to do this.
// Seeking a pin on its thread HANGS
//
HRESULT CSR::SeekNextSegment()
{
    // we can't seek at the same time the app seeks us
    CAutoLock cAutolock(&m_csThread);

    // it is not safe for us to seek ourselves, app is doing it
    if (!m_fThreadCanSeek) {
	return S_OK;
    }
    m_fThreadCanSeek = FALSE;

    DbgLog((LOG_TRACE,1,TEXT("SR:Seek U ourselves for NextSegment")));

    // figure out where to seek U pin... last C frame delivered plus 1
    ASSERT(m_pInput[C_INPIN]->m_rtLastDelivered >= 0);
    LONGLONG frame = RoundTime2Frame(m_pInput[C_INPIN]->m_rtLastDelivered,
					m_dFrameRate);
    REFERENCE_TIME rtStart = Frame2Time(frame + 1, m_dFrameRate);
    DbgLog((LOG_TRACE,1,TEXT("C ended on frame %d, seek U to %dms"),
				(int)frame, (int)(rtStart / 10000)));

    // note we're seeking during the flush that this will generate
    m_fSeeking = TRUE;
    m_fSpecialSeek = TRUE;	// it's a special self-seek

    IMediaSeeking *pMS;
    IPin *pPin = m_pInput[U_INPIN]->GetConnected();
    HRESULT hr = pPin->QueryInterface(IID_IMediaSeeking, (void **)&pMS);
    if (FAILED(hr))
	return E_FAIL;
    // Make sure we're talking MEDIA TIME
    hr = pMS->SetTimeFormat(&TIME_FORMAT_MEDIA_TIME);
    // this will FAIL if we're not stopped, and that's OK

    // what's the stop time?
    REFERENCE_TIME rtStop;
    hr = pMS->GetStopPosition(&rtStop);
    if (FAILED(hr)) {
	rtStop = 3600*UNITS;	// !!! one hour OK?
    }
    DbgLog((LOG_TRACE,2,TEXT("Stop time is %d"), (int)(rtStop / 10000)));

    if (rtStop > rtStart) {
        // this can fail, we're streaming
        hr = pMS->SetRate(1.0);

        hr = pMS->SetPositions(&rtStart, AM_SEEKING_AbsolutePositioning,
			&rtStop, AM_SEEKING_AbsolutePositioning);
        if (hr != S_OK) {
            DbgLog((LOG_ERROR,1,TEXT("SR: ERROR in SetPositions")));
	    pMS->Release();
	    return hr;
        }
    } else {
	// looks like we're seeking to the end of the project, which means...
 	// WE'RE DONE! YAY!
	m_pInput[U_INPIN]->EndOfStream();
    }

    // DO NOT update m_rtLastSeek as a result of a private seek like this. That
    // variable means where did an app last seek us

    // all done
    m_fSpecialSeek = FALSE;
    m_fSeeking = FALSE;

    pMS->Release();

    // only now that the above calculations were made, can we accept data again
    // Receive is blocked not letting us process samples until the seek settles
    // down
    SetEvent(m_pInput[U_INPIN]->m_hEventSeek);

    return S_OK;
}


// ================================================================
// CSRInputPin constructor
// ================================================================

CSRInputPin::CSRInputPin(TCHAR *pName,
                           CSR *pSwitch,
                           HRESULT *phr,
                           LPCWSTR pPinName) :
    CBaseInputPin(pName, pSwitch, pSwitch, phr, pPinName),
    m_pSwitch(pSwitch),
    m_cbBuffer(0),
    m_cBuffers(0),
    m_pAllocator(NULL),
    m_hEventBlock(NULL),
    m_hEventSeek(NULL),
    m_fNeedDiscon(FALSE),
    m_fOwnAllocator( FALSE )
{
    DbgLog((LOG_TRACE,2,TEXT("::CSRInputPin")));
    ASSERT(pSwitch);

}


//
// CSRInputPin destructor
//
CSRInputPin::~CSRInputPin()
{
    DbgLog((LOG_TRACE,3,TEXT("::~CSRInputPin")));
}

// overridden to allow cyclic-looking graphs - we say that we aren't actually
// connected to anybody
// !!! maybe we could tell the truth? does it matter?
//
STDMETHODIMP CSRInputPin::QueryInternalConnections(IPin **apPin, ULONG *nPin)
{
    DbgLog((LOG_TRACE,99,TEXT("CSRIn::QueryInteralConnections")));
    CheckPointer(nPin, E_POINTER);
    *nPin = 0;
    return S_OK;
}


//
// CheckMediaType - only allow the type we're supposed to allow, except for
//		    the uncompressed input pin, which allows any uncompressed
//		    type similar to the compressed pin's type
// Also, it can accept only the type that it's first queried with (eric added
// that)
//
HRESULT CSRInputPin::CheckMediaType(const CMediaType *pmt)
{
    DbgLog((LOG_TRACE,5,TEXT("CSRIn[%d]::CheckMT"), m_iInpin));

    HRESULT hr;

    if( m_pSwitch->m_bAcceptFirstCompressed )
    {
        if( m_pSwitch->m_mtAccept.majortype == GUID_NULL )
        {
            hr = CopyMediaType( &m_pSwitch->m_mtAccept, pmt );
            if( FAILED( hr ) )
            {
                return hr;
            }
        }
    }

    CAutoLock lock_it(m_pLock);
    CMediaType mtAccept(m_pSwitch->m_mtAccept);

    if (IsEqualGUID(*pmt->Type(), *mtAccept.Type())) {
	// the uncompressed input doesn't need to be compressed
        if (m_iInpin == U_INPIN || IsEqualGUID(*pmt->Subtype(),
						*mtAccept.Subtype())) {
	    if (*pmt->FormatType() == *mtAccept.FormatType()) {

// !!! check FRAME RATE and DATA RATE

        	    if (IsEqualGUID(*pmt->FormatType(), FORMAT_VideoInfo)) {
			LPBITMAPINFOHEADER lpbi = HEADER((VIDEOINFOHEADER *)
							pmt->Format());
			LPBITMAPINFOHEADER lpbiAccept =HEADER((VIDEOINFOHEADER*)
							mtAccept.Format());
			if (lpbi->biWidth != lpbiAccept->biWidth ||
				lpbi->biHeight != lpbiAccept->biHeight) {
			    return VFW_E_INVALIDMEDIATYPE;
			}

			if (m_iInpin == C_INPIN || m_iInpin == COMP_INPIN) {
			    if ((lpbi->biCompression == lpbiAccept->biCompression)
				&& (lpbi->biBitCount == lpbiAccept->biBitCount))
		    	    return S_OK;
			} else if (m_iInpin == 0) {
			    // !!! Make sure compressor accepts this bit depth
			    if (lpbi->biCompression <= BI_BITFIELDS)
		    	        return S_OK;
			}

		    // only video is acceptable, sorry
        	    } else {
		    }
		}
                else
                {
                    DbgLog((LOG_TRACE,5,TEXT("fmt lengths didn't match")));
                }
        }
    }
    return VFW_E_INVALIDMEDIATYPE;

} // CheckMediaType


//
// GetMediaType - return the type we prefer. If we're the uncompressed input,
// then it's not our switch's type, it's an uncompressed type similar to
// our switch's compressed type, but uncompressed
// !!! I chose 555 at random, because it's the default switch type
//
//
HRESULT CSRInputPin::GetMediaType(int iPosition, CMediaType *pMediaType)
{
    if (iPosition != 0)
        return VFW_S_NO_MORE_ITEMS;

    HRESULT hr = CopyMediaType(pMediaType, &m_pSwitch->m_mtAccept);
    if( FAILED( hr ) )
    {
        return hr;
    }

    // our uncompressed pin preferred type is RGB555
    if (pMediaType->FormatLength() && m_iInpin == U_INPIN) {
	LPBITMAPINFOHEADER lpbi = HEADER(pMediaType->Format());
	pMediaType->SetSubtype(&MEDIASUBTYPE_RGB555);
        // compressed biSize may have been different
	lpbi->biSize = sizeof(BITMAPINFOHEADER);
	lpbi->biCompression = BI_RGB;
	lpbi->biBitCount = 16;
	lpbi->biSizeImage = DIBSIZE(*lpbi);
	pMediaType->SetSampleSize(DIBSIZE(*lpbi));
	pMediaType->SetTemporalCompression(FALSE);
    }

    return S_OK;

} // GetMediaType



//
// BreakConnect
//
HRESULT CSRInputPin::BreakConnect()
{
    DbgLog((LOG_TRACE,3,TEXT("CSRIn[%d]::BreakConnect"), m_iInpin));

    // !!!
    // Release any allocator that we are holding
    if (m_pAllocator)
    {
        m_pAllocator->Release();
        m_pAllocator = NULL;
    }
    return CBaseInputPin::BreakConnect();
} // BreakConnect


// for efficiency, our input pins use their own allocators
//
STDMETHODIMP CSRInputPin::GetAllocator(IMemAllocator **ppAllocator)
{

    CheckPointer(ppAllocator,E_POINTER);
    ValidateReadWritePtr(ppAllocator,sizeof(IMemAllocator *));
    CAutoLock cObjectLock(m_pLock);

    DbgLog((LOG_TRACE,2,TEXT("CSRIn[%d]: GetAllocator"), m_iInpin));

    if (m_pAllocator == NULL) {
	HRESULT hr = S_OK;

	/* Create the new allocator object */

	CSRInputAllocator *pMemObject = new CSRInputAllocator(
				NAME("Big switch input allocator"), NULL, &hr);
	if (pMemObject == NULL) {
	    return E_OUTOFMEMORY;
	}

	if (FAILED(hr)) {
	    ASSERT(pMemObject);
	    delete pMemObject;
	    return hr;
	}

        m_pAllocator = pMemObject;

        /*  We AddRef() our own allocator */
        m_pAllocator->AddRef();

	//remember pin using it
	((CSRInputAllocator *)m_pAllocator)->m_pSwitchPin = this;

        DbgLog((LOG_TRACE,2,TEXT("Created a FAKE allocator")));
    }
    ASSERT(m_pAllocator != NULL);
    m_pAllocator->AddRef();
    *ppAllocator = m_pAllocator;
    return NOERROR;
}


// Make sure we use the maximum alignment and prefix required by any pin or
// we'll fault.
//
STDMETHODIMP
CSRInputPin::GetAllocatorRequirements(ALLOCATOR_PROPERTIES*pProps)
{
    CheckPointer(pProps, E_POINTER);
    pProps->cbAlign = m_pSwitch->m_cbAlign;
    pProps->cbPrefix = m_pSwitch->m_cbPrefix;
    pProps->cbBuffer = m_pSwitch->m_cbBuffer;
    return S_OK;
}


//
// NotifyAllocator
//
STDMETHODIMP
CSRInputPin::NotifyAllocator(IMemAllocator *pAllocator, BOOL bReadOnly)
{
    CAutoLock lock_it(m_pLock);
    IUnknown *p1, *p2;

    DbgLog((LOG_TRACE,2,TEXT("CSRIn[%d]: NotifyAllocator"), m_iInpin));

    m_fOwnAllocator = FALSE;
    if (pAllocator->QueryInterface(IID_IUnknown, (void **)&p1) == S_OK) {
        if (m_pAllocator && m_pAllocator->QueryInterface(IID_IUnknown,
						(void **)&p2) == S_OK) {
	    if (p1 == p2)
		m_fOwnAllocator = TRUE;
	    p2->Release();
	}
	p1->Release();
    }

#ifdef DEBUG
    if (m_fOwnAllocator) {
        DbgLog((LOG_TRACE,2,TEXT("Using our own allocator")));
    } else {
        DbgLog((LOG_ERROR,2,TEXT("Using a FOREIGN allocator")));
    }
#endif

    HRESULT hr = CBaseInputPin::NotifyAllocator(pAllocator, bReadOnly);
    if (SUCCEEDED(hr)) {
	ALLOCATOR_PROPERTIES prop;
	hr = pAllocator->GetProperties(&prop);
	if (SUCCEEDED(hr)) {
	    m_cBuffers = prop.cBuffers;
	    m_cbBuffer = prop.cbBuffer;

	    if (prop.cbAlign < m_pSwitch->m_cbAlign ||
				prop.cbPrefix < m_pSwitch->m_cbPrefix) {
		// !!! Nasty filters don't listen to our buffering requirement
		// so failing if cbBuffer is too small would prevent us from
		// connecting
                DbgLog((LOG_ERROR,1,TEXT("Allocator too small!")));
		return E_FAIL;
	    }

	    // update the maximum alignment and prefix needed
	    if (m_pSwitch->m_cbPrefix < prop.cbPrefix)
		m_pSwitch->m_cbPrefix = prop.cbPrefix;
	    if (m_pSwitch->m_cbAlign < prop.cbAlign)
		m_pSwitch->m_cbAlign = prop.cbAlign;
	    if (m_pSwitch->m_cbBuffer < prop.cbBuffer)
		m_pSwitch->m_cbBuffer = prop.cbBuffer;

            DbgLog((LOG_TRACE,2,TEXT("Allocator is using %d buffers, size %d"),
						prop.cBuffers, prop.cbBuffer));
            DbgLog((LOG_TRACE,2,TEXT("Prefix %d   Align %d"),
						prop.cbPrefix, prop.cbAlign));
	}
    }

    return hr;

} // NotifyAllocator

// Use POOL buffers if we run out of buffers
//
HRESULT CSRInputAllocator::GetBuffer(IMediaSample **ppBuffer,
                  	REFERENCE_TIME *pStartTime, REFERENCE_TIME *pEndTime,
			DWORD dwFlags)
{

        ASSERT(m_pSwitchPin->m_fOwnAllocator);

	HRESULT hr;

        DbgLog((LOG_TRACE,3,TEXT("CSRIn[%d]::GetBuffer"),
						m_pSwitchPin->m_iInpin));

	// For read only, we can't very well use random buffers from our pool
	if (m_pSwitchPin->m_bReadOnly) {
            DbgLog((LOG_TRACE,3,TEXT("R/O: Can't use POOL")));
             return CMemAllocator::GetBuffer(ppBuffer, pStartTime, pEndTime,
						dwFlags);
	} else {
            hr = CMemAllocator::GetBuffer(ppBuffer, pStartTime, pEndTime,
						dwFlags | AM_GBF_NOWAIT);
	    if (hr == VFW_E_TIMEOUT) {
                DbgLog((LOG_TRACE,3,TEXT("BUSY: Use POOL allocator")));

		// !!! THIS WILL HANG!  This allocator doesn't belong to us,
		// so this will not unblock when we flush.  We are counting
		// on the queue not letting all these buffers get outstanding
		// at once (see special code in the queue, m_hEventStall)
		// If we were connected to a different filter that didn't block
		// in receive, then this code will hang!

                hr = m_pSwitchPin->m_pSwitch->m_pPoolAllocator->GetBuffer(
				    ppBuffer, pStartTime, pEndTime, dwFlags);
	        return hr;
	    } else {
	        return hr;
	    }
	}
}


//
// BeginFlush - only the U pin's flush goes downstream to avoid many of them
// a seek we caused ourselves must NOT flush downstream
//
HRESULT CSRInputPin::BeginFlush()
{
    DbgLog((LOG_TRACE,2,TEXT("CSRIn[%d]:BeginFlush"), m_iInpin));

    // enter flushing state
    CBaseInputPin::BeginFlush();

    m_fReady = FALSE;

    // unblock receive AFTER we've set ready to false so receive knows
    // to bail after waking up, not to crash,hang,etc
    SetEvent(m_hEventBlock);
    if (m_pSwitch->m_fSeeking)
        SetEvent(m_hEventSeek);

    // only flushing the U pin will do anything downstream.
    // That should be enough?
    if (m_iInpin != U_INPIN)
	return S_OK;

    if (!m_pSwitch->m_fSeeking)
        DbgLog((LOG_ERROR,1,TEXT("SR::FLUSH WITHOUT SEEK!")));

    // pass the flush downstream only necessary during a seek?
    // Seeks we did ourselves shouldn't flush downstream
    if (m_pSwitch->m_fSeeking && !m_pSwitch->m_fSpecialSeek) {
        for (int z=0; z<m_pSwitch->m_cOutputs; z++) {
            DbgLog((LOG_TRACE,1,TEXT("CSR:Flushing outpin %d"), z));
	    m_pSwitch->m_pOutput[z]->DeliverBeginFlush();
        }
    } else if (m_pSwitch->m_fSeeking) {
	// a new segment is going to be compressed, having nothing to do
	// with the last thing compressed... let the compressor know to not
	// consider the previous frame it got anymore... throw it away!
        DbgLog((LOG_TRACE,1,TEXT("CSR:Flushing COMPRESSOR")));
	m_pSwitch->m_pOutput[1]->DeliverBeginFlush();
    }

    return S_OK;
}


//
// EndFlush - only the U pin's flush goes downstream to avoid many of them
// a seek we caused ourselves must NOT flush downstream
// Note this is the last time we've seeked, if the app seeked us.
// Hold off all receives until the seek settles down.
//
HRESULT CSRInputPin::EndFlush()
{
    DbgLog((LOG_TRACE,2,TEXT("CSRIn[%d]:EndFlush"), m_iInpin));

    if (m_pSwitch->m_fSeeking) {
        DbgLog((LOG_TRACE,2,TEXT("Block this input until seek is done")));

	// update this before NewSeg comes, but only for REAL seeks
	if (!m_pSwitch->m_fSpecialSeek) {
	    m_pSwitch->m_rtLastSeek = m_pSwitch->m_rtNewLastSeek;
	}

	// this is only for the U and C pins
	if (m_iInpin != COMP_INPIN) {
    	    // we're seeking, so every pin is flushing.  Until every other input
    	    // is flushed and ready, and we know our new current position, hold
    	    // off all input on this pin (or it will think new arriving data is
    	    // from before the seek)
	    ResetEvent(m_hEventSeek);
	}
    }

    ResetEvent(m_hEventBlock);

    m_rtBlock = -1;	// we're no longer blocked, or at EOS
    m_fEOS = FALSE;

    // always exit flush mode, since we always enter it
    CBaseInputPin::EndFlush();

    // only flushing the U pin will do anything downstream.
    // That should be enough?
    if (m_iInpin != U_INPIN)
	return S_OK;

    if (m_pSwitch->m_fSeeking && !m_pSwitch->m_fSpecialSeek) {
        for (int z=0; z<m_pSwitch->m_cOutputs; z++) {
	    m_pSwitch->m_pOutput[z]->DeliverEndFlush();
        }
    } else if (m_pSwitch->m_fSeeking) {
	// a new segment is going to be compressed, having nothing to do
	// with the last thing compressed... let the compressor know to not
	// consider the previous frame it got anymore... throw it away!
	m_pSwitch->m_pOutput[1]->DeliverEndFlush();
    }

    return S_OK;
}


// NewSegment - we remember the new segment we are given, but the one we
// broadcast is the timeline time we were last seeked to BY THE APP
// NOTE: We only send a newseg the first time after a Pause.  All other newsegs
// come from our own private seeks and must NOT make it downstream
//
HRESULT CSRInputPin::NewSegment(REFERENCE_TIME tStart,
                                 REFERENCE_TIME tStop, double dRate)
{
    DbgLog((LOG_TRACE,2,TEXT("CSRIn[%d]:NewSegment"), m_iInpin));

    // Only the U pin passes downstream, and only if allowed
    if (m_iInpin == U_INPIN && m_pSwitch->m_fNewSegOK) {
	m_pSwitch->m_fNewSegOK = FALSE;
        DbgLog((LOG_TRACE,1,TEXT("Passing on NewSegment=%dms to all outputs"),
				(int)(m_pSwitch->m_rtLastSeek / 10000)));
        for (int i = 0; i < m_pSwitch->m_cOutputs; i++) {
	    m_pSwitch->m_pOutput[i]->DeliverNewSegment(m_pSwitch->m_rtLastSeek,
			m_pSwitch->m_rtLastSeek + tStop - tStart, dRate);
        }
    }

    // remember the newsegment times we were given so we know the real time
    // of arriving data (it could be different for each input pin)
    HRESULT hr = CBaseInputPin::NewSegment(tStart, tStop, dRate);
    return hr;
}

// just say yes, don't recurse
//
HRESULT CSRInputPin::ReceiveCanBlock()
{
    return S_OK;
}


//
// Receive - send this sample to whoever gets it at this moment
//
HRESULT CSRInputPin::Receive(IMediaSample *pSample)
{
    CAutoLock cs(&m_csReceive);

    HRESULT hr = CBaseInputPin::Receive(pSample);
    if (hr != NOERROR) {
        DbgLog((LOG_ERROR,1,TEXT("CSRIn[%d]:Receive base class ERROR!"),
                                                                    m_iInpin));
        return hr;
    }

    // we're supposed to be all done.
    if (m_pSwitch->m_fEOS) {
            return S_FALSE;
    }

    // we're in the middle of seeking, and we're supposed to hold all input
    DbgLog((LOG_TRACE,3,TEXT("CSRIn[%d]::Receive seek block"), m_iInpin));

    // (not necessary for COMP_INPIN)
    WaitForSingleObject(m_hEventSeek, INFINITE);

    // our variables are in flux, we're seeking and this is an OLD sample
    if (m_pSwitch->m_fSeeking)
	return S_FALSE;

    // add newsegment time to get the real timeline time of this sample
    REFERENCE_TIME rtStart, rtStop;
    hr = pSample->GetTime(&rtStart, &rtStop);
    if (hr != S_OK) {
	EndOfStream();
	return E_FAIL;
    }

    rtStart += m_tStart;	// add NewSegment offset
    rtStop += m_tStart;

    // Fix the time stamps if our new segment is higher than the filters'.
    // EG: We're seeking to timeline time 10, but this input doesn't have
    // anything until time 15.  So our pins' new segment was 15, but the new
    // segment we passed on to the transform was 10.  Now it's finally time 15,
    // and we have a sample with time stamp 0, which if delivered downstream,
    // will be thought to belong at timestamp 10, so we need to set the time
    // stamp to 5 so that the transform will know that it belongs at time 15.

    REFERENCE_TIME a = rtStart, b = rtStop;
    a -= m_pSwitch->m_rtLastSeek;
    b -= m_pSwitch->m_rtLastSeek;
    hr = pSample->SetTime(&a, &b);
    if (hr != S_OK) {
	EndOfStream();
	return E_FAIL;
    }

    // which pin is this?
    if (m_iInpin == U_INPIN) {
	return U_Receive(pSample, rtStart);
    } else if (m_iInpin == C_INPIN) {
	return C_Receive(pSample, rtStart);
    } else if (m_iInpin == COMP_INPIN) {
	return COMP_Receive(pSample, rtStart);
    }

    ASSERT(FALSE);
    return E_NOTIMPL;
}


// UNCOMPRESSED data receive
//
HRESULT CSRInputPin::U_Receive(IMediaSample *pSample, REFERENCE_TIME rt)
{

  while (1) {
    // we're waiting for data to arrive on both the U and C pins
    //
    if (m_pSwitch->m_myState == SR_WAITING) {
        DbgLog((LOG_TRACE,3,TEXT("U_INPIN:WAITING")));
	// this pin is done waiting
	m_fReady = TRUE;
	m_rtBlock = rt;	// here's the sample we're ready with
	// see if everybody's ready to change state (like we are)
	m_pSwitch->CheckState();

	// this will fire when we're ready to change state
        WaitForSingleObject(m_hEventBlock, INFINITE);
        ResetEvent(m_hEventBlock);
        // we are apparently flushing now and NOT supposed to deliver this
        if (m_bFlushing)
	    return S_OK;
        // oops - we finished since we blocked
        if (m_pSwitch->m_fEOS)
	    return S_FALSE;

	// this will tell us to swallow or actually deliver it
	if (m_fReady) {
	    m_fReady = FALSE;
	    continue;
	} else {
	    return S_OK;
	}

    } else if (m_pSwitch->m_myState == SR_UNCOMPRESSED) {
        DbgLog((LOG_TRACE,3,TEXT("U_INPIN:UNCOMPRESSED")));
	// not time to switch to C samples yet
	if (m_pSwitch->CompareTimes(rt, m_pSwitch->m_rtStop) > 0) {
	    // a MUX will get confused if we don't send it frames that strictly
	    // increase in time - no big deal to skip an uncompressed frame
	    if (rt > m_rtLastDelivered &&
			rt > m_pSwitch->m_pInput[C_INPIN]->m_rtLastDelivered) {
                m_rtLastDelivered = rt;
	        // to make the compressor realize this new data being compressed
	        // in no way relates to whatever it last saw
	        if (m_fNeedDiscon) {
        	    DbgLog((LOG_TRACE,3,TEXT("Setting DISCONT for compressor")));
		    pSample->SetDiscontinuity(TRUE);
		    m_fNeedDiscon = FALSE;
	        }
                return m_pSwitch->m_pOutput[1]->Deliver(pSample);
	    } else {
		return S_OK;
	    }
	} else {
	    // OK, now time for compressed samples
	    m_fReady = TRUE;
	    m_rtBlock = rt;	// here's the sample we're ready with
	    m_pSwitch->CheckState();

	    // wait until state goes BACK to UNCompressed again
            WaitForSingleObject(m_hEventBlock, INFINITE);
            ResetEvent(m_hEventBlock);
    	    // we are apparently flushing now and NOT supposed to deliver this
    	    if (m_bFlushing)
		return S_OK;
            // oops - we finished since we blocked
            if (m_pSwitch->m_fEOS)
	        return S_FALSE;

	    // this will tell us to swallow or actually deliver it
	    if (m_fReady) {
	        m_fReady = FALSE;
	        continue;
	    } else {
	        return S_OK;
	    }
	}

    // this should never happen
    } else if (m_pSwitch->m_myState == SR_COMPRESSED) {
	ASSERT(FALSE);
	return S_OK;
    }

    ASSERT(FALSE);
    return E_NOTIMPL;
  }
}


// COMPRESSED data receive
//
HRESULT CSRInputPin::C_Receive(IMediaSample *pSample, REFERENCE_TIME rt)
{

  while (1) {

    // we're waiting for data to arrive on both the U and C pins
    //
    if (m_pSwitch->m_myState == SR_WAITING) {
        DbgLog((LOG_TRACE,3,TEXT("C_INPIN:WAITING")));

	// eat samples until a keyframe, we must start with one
	if (pSample->IsSyncPoint() != S_OK) {
            DbgLog((LOG_TRACE,3,TEXT("eating a non-key")));
	    return S_OK;
	}
	// this pin is done waiting
	m_fReady = TRUE;
	m_rtBlock = rt;	// here's the sample we're ready with
	// see if everybody's ready to change state (like we are)
	m_pSwitch->CheckState();

	// this will fire when we're ready
        WaitForSingleObject(m_hEventBlock, INFINITE);
        ResetEvent(m_hEventBlock);
        // we are apparently flushing now and NOT supposed to deliver this
        if (m_bFlushing)
	    return S_OK;
        // oops - we finished since we blocked
        if (m_pSwitch->m_fEOS)
	    return S_FALSE;

	// Now it's out turn to deliver?
	if (!m_fReady)
	    return S_OK;
	// we're looking for GAPS in sample times we get - we need to switch
	// to U samples temporarily to fill any gaps
	m_rtLastDelivered = rt;	// so discontinuity won't scare us
	continue;

    } else if (m_pSwitch->m_myState == SR_COMPRESSED) {
        DbgLog((LOG_TRACE,3,TEXT("C_INPIN:COMPRESSED")));

	// Don't deliver!  Either we're eating keyframes, or it's time to
	// switch back to U samples because we saw a GAP in our data,
	// or we have a discontinuity that is not a key
	if (m_fEatKeys || (pSample->IsDiscontinuity() == S_OK &&
		 (m_pSwitch->CompareTimes(m_rtLastDelivered, rt) > 1 ||
		  pSample->IsSyncPoint() != S_OK))) {

	    // eat samples from now on until a keyframe.  That's where you'll
	    // be able to switch back to compressed samples, after the U has
	    // a go for a while
	    if (pSample->IsSyncPoint() != S_OK) {
		m_fEatKeys = TRUE;
                DbgLog((LOG_TRACE,3,TEXT("C DONE:eating a non-key")));
	        return S_OK;
	    }
	
	    m_fEatKeys = FALSE;
	
	    // time to switch back to uncompressed stuff
	    m_fReady = TRUE;
	    m_rtBlock = rt;	// here's the sample we're ready with
	    m_pSwitch->CheckState();

	    // wait until time for compressed again
            WaitForSingleObject(m_hEventBlock, INFINITE);
            ResetEvent(m_hEventBlock);
    	    // we are apparently flushing now and NOT supposed to deliver this
    	    if (m_bFlushing)
		return S_OK;
            // oops - we finished since we blocked
            if (m_pSwitch->m_fEOS)
	        return S_FALSE;

	    if (m_fReady == FALSE)
		return S_OK;
	    m_rtLastDelivered = rt;	// so discontinuity won't scare us
	    continue;

	// deliver to the main output
	} else {
	    m_rtLastDelivered = rt;
    	    DbgLog((LOG_TRACE,3,TEXT("SR:Deliver %dms"), (int)(rt / 10000)));
            return m_pSwitch->m_pOutput[0]->Deliver(pSample);
	}

    // this should never happen
    } else if (m_pSwitch->m_myState == SR_UNCOMPRESSED) {
	ASSERT(FALSE);
	return S_OK;
    }

    ASSERT(FALSE);
    return E_NOTIMPL;
  }
}


// RECURSIVE COMPRESSOR INPUT data receive
// always deliver to main output
//
HRESULT CSRInputPin::COMP_Receive(IMediaSample *pSample, REFERENCE_TIME rt)
{
    DbgLog((LOG_TRACE,3,TEXT("SR:Deliver %dms"), (int)(rt / 10000)));
    return m_pSwitch->m_pOutput[0]->Deliver(pSample);
}



HRESULT CSRInputPin::Active()
{
    DbgLog((LOG_TRACE,2,TEXT("CSRIn[%d]: Active"), m_iInpin));
    // blocks until it's time to process input
    m_hEventBlock = CreateEvent(NULL, TRUE, FALSE, NULL);
    if (m_hEventBlock == NULL)
	return E_OUTOFMEMORY;
    // blocks when we're in the middle of a seek until seek is over
    m_hEventSeek = CreateEvent(NULL, TRUE, TRUE, NULL);
    if (m_hEventSeek == NULL) {
	CloseHandle(m_hEventBlock);
	m_hEventBlock = NULL;
	return E_OUTOFMEMORY;
    }
    m_rtBlock = -1;	// we are not blocked, nor at EOS
    m_fEOS = FALSE;
    return CBaseInputPin::Active();
}


HRESULT CSRInputPin::Inactive()
{
    DbgLog((LOG_TRACE,2,TEXT("CSRIn[%d]: Inactive"), m_iInpin));

    // make sure receive isn't blocked
    m_bFlushing = TRUE;
    m_fReady = FALSE;	// make sure receive dies after waking up, instead of
			// hanging,etc
    SetEvent(m_hEventBlock);
    SetEvent(m_hEventSeek);

    // make sure receive won't get entered any more
    HRESULT hr = CBaseInputPin::Inactive();

    // now make sure receive is done
    CAutoLock cs(&m_csReceive);

    // now destroy things, knowing receive won't try to use them
    if (m_hEventBlock)
    {
	CloseHandle(m_hEventBlock);
        m_hEventBlock = NULL;
    }
    if (m_hEventSeek)
    {
	CloseHandle(m_hEventSeek);
        m_hEventSeek = NULL;
    }

    return hr;
}


// EOS means this pin is always ready to change state, and we can never provide
// more data.
// When the COMPRESSOR filter gives us this, it means it's safe to switch
// from U to C state.
//
HRESULT CSRInputPin::EndOfStream()
{
    DbgLog((LOG_TRACE,2,TEXT("CSRIn[%d]: EOS"), m_iInpin));
    m_fEOS = TRUE;
    m_fEatKeys = FALSE;

    // if C ever runs out of data, U needs to do the rest of the project itself
    m_rtBlock = MAX_TIME;

    // the compressor is done, OK to switch back to compressed samples
    if (m_iInpin == COMP_INPIN) {
        DbgLog((LOG_TRACE,2,TEXT("COMPRESSOR is done. Switch to COMPRESS state")));
	SetEvent(m_pSwitch->m_pInput[C_INPIN]->m_hEventBlock);
	return CBaseInputPin::EndOfStream();
    }

    // nothing more interesting is happening to this pin.  Change state?
    m_fReady = TRUE;
    m_pSwitch->CheckState();

    return CBaseInputPin::EndOfStream();
}



// All done.  Stop processing.
//
HRESULT CSR::AllDone()
{
    // give the final renderer its EOS.
    DbgLog((LOG_TRACE,1,TEXT("*** ALL DONE!  Delivering EOS")));
    if (!m_fEOS)
        m_pOutput[0]->DeliverEndOfStream();

    // !!! Fire all events... is this right?
    m_fEOS = TRUE;

    for (int z = 0; z < m_cInputs; z++) {
	SetEvent(m_pInput[z]->m_hEventBlock);
    }

    return NOERROR;
}



HRESULT CSR::GetOutputBuffering(int *pnBuffer)
{
    CheckPointer( pnBuffer, E_POINTER );
    *pnBuffer = m_nOutputBuffering;
    return NOERROR;

}


HRESULT CSR::SetOutputBuffering(int nBuffer)
{
    // minimum 2, or we could hang.  If there's only 1, and the FRC is doing
    // a data copy to avoid giving the switch a read only buffer, the FRC has
    // a ref on the only pool buffer.   Then it goes through a DXT and another
    // switch input needs a pool buffer, because it's own buffer is still
    // addrefed by the output queue.  HANG.  If the FRC doesn't call GetBuffer
    // twice we don't have this problem
    if (nBuffer <=1)
	return E_INVALIDARG;
    m_nOutputBuffering = nBuffer;
    return NOERROR;
}

//
// Don't allow our input to connect directly to our output
//
HRESULT CSRInputPin::CompleteConnect(IPin *pReceivePin)
{
    DbgLog((LOG_TRACE,2,TEXT("CSRIn[%d]::CompleteConnect"), m_iInpin));

    PIN_INFO pinfo;
    IAMSmartRecompressor *pBS;
    HRESULT hr = pReceivePin->QueryPinInfo(&pinfo);
    if (hr == S_OK) {
	pinfo.pFilter->Release();	// it won't go away yet
	hr = pinfo.pFilter->QueryInterface(IID_IAMSmartRecompressor, (void **)&pBS);
	if (hr == S_OK) {
	    pBS->Release();
            DbgLog((LOG_TRACE,1,TEXT("CSRIn[%d]::CompleteConnect failing because it was another switch"), m_iInpin));
	    return E_FAIL;
	}
    }
    return CBaseInputPin::CompleteConnect(pReceivePin);
}



// ================================================================
// CSROutputPin constructor
// ================================================================

CSROutputPin::CSROutputPin(TCHAR *pName,
                             CSR *pSwitch,
                             HRESULT *phr,
                             LPCWSTR pPinName) :
    CBaseOutputPin(pName, pSwitch, pSwitch, phr, pPinName) ,
    m_pSwitch(pSwitch),
    m_fOwnAllocator( FALSE )
{
    DbgLog((LOG_TRACE,3,TEXT("::CSROutputPin")));
    ASSERT(pSwitch);
}



//
// CSROutputPin destructor
//
CSROutputPin::~CSROutputPin()
{
    DbgLog((LOG_TRACE,3,TEXT("::~CSROutputPin")));
}


// overridden to allow cyclic-looking graphs - this output is not connected
// to any of our input pins
//
STDMETHODIMP CSROutputPin::QueryInternalConnections(IPin **apPin, ULONG *nPin)
{
    DbgLog((LOG_TRACE,99,TEXT("CSROut::QueryInternalConnections")));
    CheckPointer(nPin, E_POINTER);
    *nPin = 0;
    return S_OK;
}


//
// DecideBufferSize
//
// This has to be present to override the PURE virtual class base function
//
// !!! insist on max buffers of all inputs to avoid hanging?
HRESULT CSROutputPin::DecideBufferSize(IMemAllocator *pAllocator,
                                        ALLOCATOR_PROPERTIES * pProperties)
{
    DbgLog((LOG_TRACE,1,TEXT("CSROut[%d]::DecideBufferSize"),
								m_iOutpin));

    // !!! don't lie? admit we have more buffers in a pool?
    if (pProperties->cBuffers == 0)
        pProperties->cBuffers = 1;

    // bump up this allocator to have as much alignment and prefix as the
    // highest required by any pin
    if (m_pSwitch->m_cbPrefix > pProperties->cbPrefix)
        pProperties->cbPrefix = m_pSwitch->m_cbPrefix;
    if (m_pSwitch->m_cbAlign > pProperties->cbAlign)
        pProperties->cbAlign = m_pSwitch->m_cbAlign;
    if (m_pSwitch->m_cbBuffer > pProperties->cbBuffer)
        pProperties->cbBuffer = m_pSwitch->m_cbBuffer;

    // keep the max up to date
    if (pProperties->cbPrefix > m_pSwitch->m_cbPrefix)
	m_pSwitch->m_cbPrefix = pProperties->cbPrefix;
    if (pProperties->cbAlign > m_pSwitch->m_cbAlign)
	m_pSwitch->m_cbAlign = pProperties->cbAlign;
    if (pProperties->cbBuffer > m_pSwitch->m_cbBuffer)
	m_pSwitch->m_cbBuffer = pProperties->cbBuffer;

    ALLOCATOR_PROPERTIES Actual;
    HRESULT hr = pAllocator->SetProperties(pProperties,&Actual);
    if (FAILED(hr)) {
        DbgLog((LOG_ERROR,1,TEXT("Error in SetProperties")));
	return hr;
    }

    if (Actual.cbBuffer < pProperties->cbBuffer ||
			Actual.cbPrefix < pProperties->cbPrefix ||
    			Actual.cbAlign < pProperties->cbAlign) {
	// can't use this allocator
        DbgLog((LOG_ERROR,1,TEXT("Can't use allocator - something too small")));
	return E_INVALIDARG;
    }

    DbgLog((LOG_TRACE,1,TEXT("Using %d buffers of size %d"),
					Actual.cBuffers, Actual.cbBuffer));
    DbgLog((LOG_TRACE,1,TEXT("Prefix=%d Align=%d"),
					Actual.cbPrefix, Actual.cbAlign));


    return S_OK;
}


//
// DecideAllocator - override to notice if it's our allocator
//
HRESULT CSROutputPin::DecideAllocator(IMemInputPin *pPin, IMemAllocator **ppAlloc)
{
    HRESULT hr = NOERROR;
    *ppAlloc = NULL;

    // get downstream prop request
    // the derived class may modify this in DecideBufferSize, but
    // we assume that he will consistently modify it the same way,
    // so we only get it once
    ALLOCATOR_PROPERTIES prop;
    ZeroMemory(&prop, sizeof(prop));

// !!! BUGBUG TEMPORARY FIX WHO CARES WHAT HE WANTS?  GIVE HIM WHAT OUR INPUTS
//     ARE USING
    // whatever he returns, we assume prop is either all zeros
    // or he has filled it out.
    // pPin->GetAllocatorRequirements(&prop);
    prop.cbBuffer = m_pSwitch->m_cbBuffer;
    prop.cbAlign = m_pSwitch->m_cbAlign;
    prop.cbPrefix = m_pSwitch->m_cbPrefix;
// !!! END BUGBUG

    // if he doesn't care about alignment, then set it to 1
    if (prop.cbAlign == 0) {
        prop.cbAlign = 1;
    }

    /* Try the allocator provided by the input pin */

    // !!! We seem to HANG if we don't provide the allocator
    // We always use our allocator for efficiency (no DDraw!!!)

    hr = E_FAIL; //pPin->GetAllocator(ppAlloc);
    if (SUCCEEDED(hr)) {

	hr = DecideBufferSize(*ppAlloc, &prop);
	if (SUCCEEDED(hr)) {
	    hr = pPin->NotifyAllocator(*ppAlloc, FALSE);
	    if (SUCCEEDED(hr)) {
	 	m_fOwnAllocator = FALSE;
    	        DbgLog((LOG_TRACE,1,TEXT("CSROut[%d]: using a foreign allocator"), m_iOutpin));
		return NOERROR;
	    }
	}
    }

    /* If the GetAllocator failed we may not have an interface */

    if (*ppAlloc) {
	(*ppAlloc)->Release();
	*ppAlloc = NULL;
    }

    /* Try the output pin's allocator by the same method */

    hr = InitAllocator(ppAlloc);
    if (SUCCEEDED(hr)) {

        // note - the properties passed here are in the same
        // structure as above and may have been modified by
        // the previous call to DecideBufferSize
	hr = DecideBufferSize(*ppAlloc, &prop);
	if (SUCCEEDED(hr)) {
	    // !!! read only?
	    hr = pPin->NotifyAllocator(*ppAlloc, FALSE);
	    if (SUCCEEDED(hr)) {
		m_fOwnAllocator = TRUE;
    	        DbgLog((LOG_TRACE,1,TEXT("CSROut[%d]: using our own allocator"), m_iOutpin));
		goto FixOtherAllocators;
	    }
	}
    }

    /* Likewise we may not have an interface to release */

    if (*ppAlloc) {
	(*ppAlloc)->Release();
	*ppAlloc = NULL;
    }
    return hr;

FixOtherAllocators:
    ALLOCATOR_PROPERTIES actual;

    // make sure the pool has a whole bunch of buffers, obeying align and prefix
    // !!! You can't connect the main output first, or we won't yet know how
    // big pool buffers need to be (no inputs connected yet) and we'll blow up.
    // Luckily, Dexter can only connect the main output last.
    prop.cBuffers = m_pSwitch->m_nOutputBuffering;
    hr = m_pSwitch->m_pPoolAllocator->SetProperties(&prop, &actual);
    ASSERT(SUCCEEDED(hr));
    if (FAILED(hr))
	return hr;
    DbgLog((LOG_TRACE,1,TEXT("Increased POOL to %d buffers"), actual.cBuffers));

    return S_OK;

} // DecideAllocator


//
// CheckMediaType - output 0 accepts only our switch's compressed type
//                - output 1 accepts only what the uncompressed input is using
//
HRESULT CSROutputPin::CheckMediaType(const CMediaType *pmt)
{
    DbgLog((LOG_TRACE,5,TEXT("CSROut[%d]::CheckMT"), m_iOutpin));

    CAutoLock lock_it(m_pLock);

    CMediaType mtAccept(m_pSwitch->m_mtAccept);

    if (IsEqualGUID(*pmt->Type(), *mtAccept.Type())) {
	// the output going to a compressor doesn't need to be compressed
        if (m_iOutpin == COMP_OUTPIN ||
			IsEqualGUID(*pmt->Subtype(), *mtAccept.Subtype())) {
	    if (*pmt->FormatType() == *mtAccept.FormatType()) {
	        if (pmt->FormatLength() >= mtAccept.FormatLength()) {

// !!! check frame rate and data rate too

        	    if (IsEqualGUID(*pmt->FormatType(), FORMAT_VideoInfo)) {
			LPBITMAPINFOHEADER lpbi = HEADER((VIDEOINFOHEADER *)
							pmt->Format());
			LPBITMAPINFOHEADER lpbiAccept =HEADER((VIDEOINFOHEADER*)
							mtAccept.Format());

			if (lpbi->biWidth != lpbiAccept->biWidth ||
				lpbi->biHeight != lpbiAccept->biHeight) {
			    return VFW_E_INVALIDMEDIATYPE;
			}

			// our output going to the compressor only accepts
			// what the uncompressed input is using
		 	if (m_iOutpin == COMP_OUTPIN) {
			    // if the U pin is not connected, accept any U type
			    // !!! I'd reject the connection, but loading a
			    // saved GRF tries this connection before U's
			    if (!m_pSwitch->m_pInput[U_INPIN]->IsConnected()) {
				if (lpbi->biCompression <= BI_BITFIELDS)
				    return S_OK;
			    }
			    AM_MEDIA_TYPE *pmtU =
					&m_pSwitch->m_pInput[U_INPIN]->m_mt;
			    lpbiAccept = HEADER(pmtU->pbFormat);
			}
			if ((lpbi->biCompression == lpbiAccept->biCompression)
				&& (lpbi->biBitCount == lpbiAccept->biBitCount))
		    	    return S_OK;

		    // will other formats match exactly?
		    }
		}
	    }
        }
    }
    return VFW_E_INVALIDMEDIATYPE;

} // CheckMediaType



//
// GetMediaType - return the type we accept.   If we're the output going to a
// compressor, then it's not our switch's type, it's the type of our
// uncompressed input pin
//
HRESULT CSROutputPin::GetMediaType(int iPosition, CMediaType *pMediaType)
{
    if (iPosition != 0)
        return VFW_S_NO_MORE_ITEMS;

    HRESULT hr = CopyMediaType(pMediaType, &m_pSwitch->m_mtAccept);
    if( FAILED( hr ) )
    {
        return hr;
    }

    // we like whatever our U inpin is connected as
    //
    if (pMediaType->FormatLength() && m_iOutpin == COMP_OUTPIN) {
	// U inpin has to be connected
	if (!m_pSwitch->m_pInput[U_INPIN]->IsConnected())
	    return VFW_S_NO_MORE_ITEMS;
	AM_MEDIA_TYPE *pmtAccept = &m_pSwitch->m_pInput[U_INPIN]->m_mt;
	LPBITMAPINFOHEADER lpbi = HEADER(pMediaType->Format());
	LPBITMAPINFOHEADER lpbiAccept = HEADER(pmtAccept->pbFormat);
	pMediaType->SetSubtype(&pmtAccept->subtype);
        // compressed biSize may have been different
	lpbi->biSize = sizeof(BITMAPINFOHEADER);
	lpbi->biCompression = lpbiAccept->biCompression;
	lpbi->biBitCount = lpbiAccept->biBitCount;
	lpbi->biSizeImage = DIBSIZE(*lpbi);
	pMediaType->SetSampleSize(DIBSIZE(*lpbi));
	pMediaType->SetTemporalCompression(FALSE);
    }

    return S_OK;

} // GetMediaType


//
// Notify
//
STDMETHODIMP CSROutputPin::Notify(IBaseFilter *pSender, Quality q)
{
    CAutoLock lock_it(m_pLock);

    DbgLog((LOG_TRACE,1,TEXT("SR: LATE %d ms"), (int)(q.Late / 10000)));

// !!! CODE GOES HERE!

    // we handle this, renderer do NOT drop frames!  The compressor in the graph
    // is slow, and we're always behind!
    return S_OK;
}

HRESULT CSROutputPin::IsFormatSupported(const GUID * pFormat)
{
    CheckPointer(pFormat, E_POINTER);
    return (*pFormat == TIME_FORMAT_MEDIA_TIME) ? S_OK : S_FALSE;
}

HRESULT CSROutputPin::QueryPreferredFormat(GUID *pFormat)
{
    CheckPointer(pFormat, E_POINTER);
    *pFormat = TIME_FORMAT_MEDIA_TIME;
    return S_OK;
}

HRESULT CSROutputPin::SetTimeFormat(const GUID * pFormat)
{
    CheckPointer(pFormat, E_POINTER);
    if (*pFormat == TIME_FORMAT_MEDIA_TIME)
        return S_OK;
    return E_FAIL;
}

HRESULT CSROutputPin::IsUsingTimeFormat(const GUID * pFormat)
{
    CheckPointer(pFormat, E_POINTER);
    if (*pFormat != TIME_FORMAT_MEDIA_TIME)
        return S_FALSE;
    return S_OK;
}

HRESULT CSROutputPin::GetTimeFormat(GUID *pFormat)
{
    CheckPointer(pFormat, E_POINTER);
    *pFormat = TIME_FORMAT_MEDIA_TIME ;
    return S_OK;
}

HRESULT CSROutputPin::GetDuration(LONGLONG *pDuration)
{
    CheckPointer(pDuration, E_POINTER);

    DbgLog((LOG_TRACE,5,TEXT("SR: GetDuration")));
    HRESULT hr = E_UNEXPECTED;
    if (m_pSwitch->m_pInput[U_INPIN]->IsConnected()) {
	IPin *pPin = m_pSwitch->m_pInput[U_INPIN]->GetConnected();
	if (pPin == NULL)
	    return E_UNEXPECTED;
	IMediaSeeking *pMS;
	hr = pPin->QueryInterface(IID_IMediaSeeking, (void **)&pMS);
	if (SUCCEEDED(hr)) {
	    hr = pMS->GetDuration(pDuration);
	    pMS->Release();
	}
    }
    return hr;
}


// !!! We don't listen to stop positions right now
//
HRESULT CSROutputPin::GetStopPosition(LONGLONG *pStop)
{
    CheckPointer(pStop, E_POINTER);

    // !!! ACK!
    return GetDuration(pStop);
}


// What's the last thing we sent?
// !!! This is wrong, at end of playback and other times... LastDelivered isn't
// up to date (if we finish on a compressed segment, we go into U mode but
// LastDelivered isn't updated)
//
HRESULT CSROutputPin::GetCurrentPosition(LONGLONG *pCurrent)
{
    CheckPointer(pCurrent, E_POINTER);

    if (m_pSwitch->m_myState == SR_UNCOMPRESSED)
	*pCurrent = m_pSwitch->m_pInput[U_INPIN]->m_rtLastDelivered;
    else if (m_pSwitch->m_myState == SR_COMPRESSED)
	*pCurrent = m_pSwitch->m_pInput[C_INPIN]->m_rtLastDelivered;
    else
	*pCurrent = 0;	// !!!
	

    return S_OK;
}

HRESULT CSROutputPin::GetCapabilities(DWORD *pCap)
{
    CheckPointer(pCap, E_POINTER);
    *pCap =	AM_SEEKING_CanSeekAbsolute |
		AM_SEEKING_CanSeekForwards |
		AM_SEEKING_CanSeekBackwards |
		AM_SEEKING_CanGetCurrentPos |
		AM_SEEKING_CanGetStopPos |
                AM_SEEKING_CanGetDuration;

    // ask UNC input?

    return S_OK;
}

HRESULT CSROutputPin::CheckCapabilities( DWORD * pCapabilities )
{
    DWORD dwMask;
    GetCapabilities(&dwMask);
    *pCapabilities &= dwMask;
    return S_OK;
}


HRESULT CSROutputPin::ConvertTimeFormat(
  		LONGLONG * pTarget, const GUID * pTargetFormat,
  		LONGLONG    Source, const GUID * pSourceFormat )
{
    return E_NOTIMPL;
}


// Here's the biggie... SEEK!
//
HRESULT CSROutputPin::SetPositions(
		LONGLONG * pCurrent,  DWORD CurrentFlags,
  		LONGLONG * pStop,  DWORD StopFlags )
{

    // !!! THIS IS STILL BUGGY, and not really necessary
    return E_NOTIMPL;

    // app can't seek us while we're seeking our own U pin ourselves
    CAutoLock cAutolock(&m_pSwitch->m_csThread);

    // don't let us seek ourselves anymore
    m_pSwitch->m_fThreadCanSeek = FALSE;

    // !!! I don't handle changing STOP time

    REFERENCE_TIME rtCurrent, rtDuration, rtCurrentOld;
    HRESULT hr = GetCurrentPosition(&rtCurrent);
    if (FAILED(hr))
	return hr;
    rtCurrentOld = rtCurrent;
    hr = GetDuration(&rtDuration);
    if (FAILED(hr))
	return hr;

    // segment not supported
    if ((CurrentFlags & AM_SEEKING_Segment) ||
				(StopFlags & AM_SEEKING_Segment)) {
    	DbgLog((LOG_TRACE,1,TEXT("SR: ERROR-Seek used EC_ENDOFSEGMENT!")));
	return E_INVALIDARG;
    }

    DWORD dwFlags = (CurrentFlags & AM_SEEKING_PositioningBitsMask);

    // start ABSOLUTE seek
    if (dwFlags == AM_SEEKING_AbsolutePositioning) {
	CheckPointer(pCurrent, E_POINTER);
	if (*pCurrent < 0 || *pCurrent > rtDuration) {
    	    DbgLog((LOG_TRACE,1,TEXT("SR::Invalid Seek to %dms"),
					(int)(*pCurrent / 10000)));
	    return E_INVALIDARG;
	}
    	DbgLog((LOG_TRACE,1,TEXT("SR::Seek to %dms"),
					(int)(*pCurrent / 10000)));
	rtCurrent = *pCurrent;

    // start RELATIVE seek
    } else if (dwFlags == AM_SEEKING_RelativePositioning) {
	CheckPointer(pCurrent, E_POINTER);
	if (rtCurrent + *pCurrent < 0 || rtCurrent + *pCurrent > rtDuration) {
    	    DbgLog((LOG_TRACE,1,TEXT("SR::Invalid Relative Seek to %dms"),
			(int)((rtCurrent + *pCurrent) / 10000)));
	    return E_INVALIDARG;
	}
    	DbgLog((LOG_TRACE,1,TEXT("SR::Relative Seek to %dms"),
			(int)((rtCurrent + *pCurrent) / 10000)));
	rtCurrent += *pCurrent;

    } else if (dwFlags) {
    	DbgLog((LOG_TRACE,1,TEXT("SR::Invalid Current Seek flags")));
	return E_INVALIDARG;
    }

    // return the time?
    if ((CurrentFlags & AM_SEEKING_ReturnTime) && pCurrent)
	*pCurrent = rtCurrent;
    if ((StopFlags & AM_SEEKING_ReturnTime) && pStop)
	*pStop = rtDuration;	// !!! Nope

    // so after all that, has the current or stop time changed?
    if (rtCurrent != rtCurrentOld) {

	// YEP!  Time to seek!
	
        m_pSwitch->m_fSeeking = TRUE;
	// EndFlush or us will update rtLastSeek to this value
        m_pSwitch->m_rtNewLastSeek = rtCurrent;	// the last seek was to here
	// after seeking, it's OK to propogate a newseg downstream
	m_pSwitch->m_fNewSegOK = TRUE;

	// we're no longer at EOS.  Do this BEFORE passing seek upstream or
	// we might get new data while we still think we're at EOS
	m_pSwitch->m_fEOS = FALSE;		// not at EOS yet

	// seek upstream of the U and C inpins only
	for (int i = 0; i < COMP_INPIN; i++) {

	    IPin *pPin = m_pSwitch->m_pInput[i]->GetConnected();
	    IMediaSeeking *pMS;

	    // only bother to seek pins that will evenutally do something
	    if (pPin) {
		hr = pPin->QueryInterface(IID_IMediaSeeking, (void **)&pMS);
		if (hr == S_OK) {
		    // convert all seeks to absolute seek commands.  Pass on
		    // FLUSH flag.
		    DWORD CFlags=(CurrentFlags &AM_SEEKING_PositioningBitsMask)?
				AM_SEEKING_AbsolutePositioning :
				AM_SEEKING_NoPositioning;
		    if (CurrentFlags & AM_SEEKING_NoFlush)
			CFlags |= AM_SEEKING_NoFlush;
		    DWORD SFlags =(StopFlags & AM_SEEKING_PositioningBitsMask) ?
				AM_SEEKING_AbsolutePositioning :
				AM_SEEKING_NoPositioning;
		    if (StopFlags & AM_SEEKING_NoFlush)
			SFlags |= AM_SEEKING_NoFlush;
		    // make sure we're in MEDIA TIME format
		    if (pMS->IsUsingTimeFormat(&TIME_FORMAT_MEDIA_TIME) != S_OK)
			pMS->SetTimeFormat(&TIME_FORMAT_MEDIA_TIME);
    		    DbgLog((LOG_TRACE,1,TEXT("SR::Passing seek upstream")));
		    // !!! Stop isn't right
		    hr = pMS->SetPositions(&rtCurrent, CFlags,
							&rtDuration, SFlags);

		    if (FAILED(hr)) {
			ASSERT(FALSE);
            		DbgLog((LOG_ERROR,1,TEXT("SR: ERROR in SetPositions")));
	    		pMS->Release();
	    		return hr;
		    }

		    pMS->Release();
		} else {
    		    DbgLog((LOG_ERROR,1,TEXT("SR::In %d CAN'T SEEK"), i));
		    ASSERT(FALSE); // we're screwed
		}
	    }
	}

        // we know all the flushes have now come through

	// Reset this AGAIN because seeking upstream could set it again
	m_pSwitch->m_fEOS = FALSE;		// not at EOS yet

        m_pSwitch->m_fSeeking = FALSE;	// this thread is all done

        // if the push thread was stopped, we won't get flushed, and this won't
        // have been updated.   !!! I ASSUME the push thread won't be started
	// until this thread does it when this function returns, or there is a
	// race condition (so the NewSeg will come after we do this)
        m_pSwitch->m_rtLastSeek = m_pSwitch->m_rtNewLastSeek;

	// now that we've seeked, our state machine starts over again
	m_pSwitch->m_myState = SR_WAITING;

        DbgLog((LOG_TRACE,1,TEXT("Completing the seek to %d,%dms"),
				(int)(rtCurrent / 10000),
				(int)(rtDuration / 10000)));

	// do stuff that EndFlush did for each pin, in case no EndFlush happened
	for (i = 0; i < m_pSwitch->m_cInputs; i++) {
	    // if we weren't streaming, EndFlush didn't do this yet
	    m_pSwitch->m_pInput[i]->m_rtBlock = -1;
	    m_pSwitch->m_pInput[i]->m_fReady = FALSE;	// not ready
	    m_pSwitch->m_pInput[i]->m_fEOS = FALSE;
	    SetEvent(m_pSwitch->m_pInput[i]->m_hEventSeek);
	    ResetEvent(m_pSwitch->m_pInput[i]->m_hEventBlock);
	}
    }
    return S_OK;
}


HRESULT CSROutputPin::GetPositions(LONGLONG * pCurrent, LONGLONG * pStop)
{
    HRESULT hr = GetCurrentPosition(pCurrent);
    if (SUCCEEDED(hr))
	hr = GetStopPosition(pStop);
    return hr;
}

HRESULT CSROutputPin::GetAvailable( LONGLONG * pEarliest, LONGLONG * pLatest )
{
    DbgLog((LOG_TRACE,5,TEXT("SR: GetAvailable")));
    HRESULT hr = E_UNEXPECTED;
    if (m_pSwitch->m_pInput[U_INPIN]->IsConnected()) {
	IPin *pPin = m_pSwitch->m_pInput[U_INPIN]->GetConnected();
	if (pPin == NULL)
	    return E_UNEXPECTED;
	IMediaSeeking *pMS;
	hr = pPin->QueryInterface(IID_IMediaSeeking, (void **)&pMS);
	if (SUCCEEDED(hr)) {
	    hr = pMS->GetAvailable(pEarliest, pLatest);
	    pMS->Release();
	}
    }
    return hr;
}

HRESULT CSROutputPin::SetRate( double dRate)
{
    return E_NOTIMPL;
}

HRESULT CSROutputPin::GetRate( double * pdRate)
{
    return E_NOTIMPL;
}

HRESULT CSROutputPin::GetPreroll(LONGLONG *pPreroll)
{
    return E_NOTIMPL;
}

STDMETHODIMP CSROutputPin::NonDelegatingQueryInterface(REFIID riid, void ** ppv)
{
    CheckPointer(ppv,E_POINTER);

    // only the render pin supports seeking
    if (this == m_pSwitch->m_pOutput[0] && riid == IID_IMediaSeeking) {
        //DbgLog((LOG_TRACE,9,TEXT("CSROut: QI for IMediaSeeking")));
        return GetInterface((IMediaSeeking *) this, ppv);
    } else {
        return CBaseOutputPin::NonDelegatingQueryInterface(riid, ppv);
    }
}
=== C:/Users/treeman/Desktop/windows nt source code\Source\Win2K3\NT\multimedia\dshow\filterus\dexter\stillvid\ourtgafile.h ===
//@@@@AUTOBLOCK+============================================================;
//
//  THIS CODE AND INFORMATION IS PROVIDED "AS IS" WITHOUT WARRANTY OF ANY
//  KIND, EITHER EXPRESSED OR IMPLIED, INCLUDING BUT NOT LIMITED TO THE
//  IMPLIED WARRANTIES OF MERCHANTABILITY AND/OR FITNESS FOR A PARTICULAR
//  PURPOSE.
//
//  File: ourtgafile.h
//
//  Copyright (c) Microsoft Corporation.  All Rights Reserved.
//
//@@@@AUTOBLOCK-============================================================;

/****************************************************************************
**
**	For more information about the original Truevision TGA(tm) file format,
**	or for additional information about the new extensions to the
**	Truevision TGA file, refer to the "Truevision TGA File Format
**	Specification Version 2.0" available from Truevision or your
**	Truevision dealer.
**
**  FILE STRUCTURE FOR THE ORIGINAL TRUEVISION TGA FILE				
**	  FIELD 1 :	NUMBER OF CHARACTERS IN ID FIELD (1 BYTES)	
**	  FIELD 2 :	COLOR MAP TYPE (1 BYTES)			
**	  FIELD 3 :	IMAGE TYPE CODE (1 BYTES)			
**					= 0	NO IMAGE DATA INCLUDED		
**					= 1	UNCOMPRESSED, COLOR-MAPPED IMAGE
**					= 2	UNCOMPRESSED, TRUE-COLOR IMAGE	
**					= 3	UNCOMPRESSED, BLACK AND WHITE IMAGE
**					= 9	RUN-LENGTH ENCODED COLOR-MAPPED IMAGE
**					= 10 RUN-LENGTH ENCODED TRUE-COLOR IMAGE
**					= 11 RUN-LENGTH ENCODED BLACK AND WHITE IMAGE
**	  FIELD 4 :	COLOR MAP SPECIFICATION	(5 BYTES)		
**				4.1 : COLOR MAP ORIGIN (2 BYTES)	
**				4.2 : COLOR MAP LENGTH (2 BYTES)	
**				4.3 : COLOR MAP ENTRY SIZE (2 BYTES)	
**	  FIELD 5 :	IMAGE SPECIFICATION (10 BYTES)			
**				5.1 : X-ORIGIN OF IMAGE (2 BYTES)	
**				5.2 : Y-ORIGIN OF IMAGE (2 BYTES)	
**				5.3 : WIDTH OF IMAGE (2 BYTES)		
**				5.4 : HEIGHT OF IMAGE (2 BYTES)		
**				5.5 : IMAGE PIXEL SIZE (1 BYTE)		
**				5.6 : IMAGE DESCRIPTOR BYTE (1 BYTE) 	
**	  FIELD 6 :	IMAGE ID FIELD (LENGTH SPECIFIED BY FIELD 1)	
**	  FIELD 7 :	COLOR MAP DATA (BIT WIDTH SPECIFIED BY FIELD 4.3 AND
**				NUMBER OF COLOR MAP ENTRIES SPECIFIED IN FIELD 4.2)
**	  FIELD 8 :	IMAGE DATA FIELD (WIDTH AND HEIGHT SPECIFIED IN
**				FIELD 5.3 AND 5.4)				
****************************************************************************/

typedef struct _devDir
{
	unsigned short	tagValue;
	UINT32	tagOffset;
	UINT32	tagSize;
} DevDir;

typedef struct _TGAFile
{
	BYTE	idLength;		/* length of ID string */
	BYTE	mapType;		/* color map type */
	BYTE	imageType;		/* image type code */
	unsigned short	mapOrigin;		/* starting index of map */
	unsigned short	mapLength;		/* length of map */
	BYTE	mapWidth;		/* width of map in bits */
	unsigned short	xOrigin;		/* x-origin of image */
	unsigned short	yOrigin;		/* y-origin of image */
	unsigned short	imageWidth;		/* width of image */
	unsigned short	imageHeight;	/* height of image */
	BYTE	pixelDepth;		/* bits per pixel */
	BYTE	imageDesc;		/* image descriptor */
	char	idString[256];	/* image ID string */
	unsigned short	devTags;		/* number of developer tags in directory */
	DevDir	*devDirs;		/* pointer to developer directory entries */
	unsigned short	extSize;		/* extension area size */
	char	author[41];		/* name of the author of the image */
	char	authorCom[4][81];	/* author's comments */
	unsigned short	month;			/* date-time stamp */
	unsigned short	day;
	unsigned short	year;
	unsigned short	hour;
	unsigned short	minute;
	unsigned short	second;
	char	jobID[41];		/* job identifier */
	unsigned short	jobHours;		/* job elapsed time */
	unsigned short	jobMinutes;
	unsigned short	jobSeconds;
	char	softID[41];		/* software identifier/program name */
	unsigned short	versionNum;		/* software version designation */
	BYTE	versionLet;
	UINT32	keyColor;		/* key color value as A:R:G:B */
	unsigned short	pixNumerator;	/* pixel aspect ratio */
	unsigned short	pixDenominator;
	unsigned short	gammaNumerator;	/* gamma correction factor */
	unsigned short	gammaDenominator;
	UINT32	colorCorrectOffset;	/* offset to color correction table */
	UINT32	stampOffset;	/* offset to postage stamp data */
	UINT32	scanLineOffset;	/* offset to scan line table */
	BYTE	alphaAttribute;	/* alpha attribute description */
	UINT32	*scanLineTable;	/* address of scan line offset table */
	BYTE	stampWidth;		/* width of postage stamp */
	BYTE	stampHeight;	/* height of postage stamp */
	void	*postStamp;		/* address of postage stamp data */
	unsigned short	*colorCorrectTable;
	UINT32	extAreaOffset;	/* extension area offset */
	UINT32	devDirOffset;	/* developer directory offset */
	char	signature[18];	/* signature string	*/
} TGAFile;
=== C:/Users/treeman/Desktop/windows nt source code\Source\Win2K3\NT\multimedia\dshow\filterus\dexter\stillvid\resource.h ===
// Copyright (c) 1998  Microsoft Corporation.  All Rights Reserved.
//{{NO_DEPENDENCIES}}
// Microsoft Developer Studio generated include file.
// Used by stilprop.rc
//
#define IDS_STILLTITLE                  500
#define IDD_GENSTILL                    501
#define IDC_STILL_START                 502
#define IDC_STILL_DURATION              503
#define IDC_STILL_FRMRATE               504
#define IDS_STATIC                      -1

// Next default values for new objects
// 
#ifdef APSTUDIO_INVOKED
#ifndef APSTUDIO_READONLY_SYMBOLS
#define _APS_NEXT_RESOURCE_VALUE        101
#define _APS_NEXT_COMMAND_VALUE         40001
#define _APS_NEXT_CONTROL_VALUE         1000
#define _APS_NEXT_SYMED_VALUE           101
#endif
#endif
=== C:/Users/treeman/Desktop/windows nt source code\Source\Win2K3\NT\multimedia\dshow\filterus\dexter\stillvid\loadjpg.cpp ===
//@@@@AUTOBLOCK+============================================================;
//
//  THIS CODE AND INFORMATION IS PROVIDED "AS IS" WITHOUT WARRANTY OF ANY
//  KIND, EITHER EXPRESSED OR IMPLIED, INCLUDING BUT NOT LIMITED TO THE
//  IMPLIED WARRANTIES OF MERCHANTABILITY AND/OR FITNESS FOR A PARTICULAR
//  PURPOSE.
//
//  File: loadjpg.cpp
//
//  Copyright (c) Microsoft Corporation.  All Rights Reserved.
//
//@@@@AUTOBLOCK-============================================================;


#include <streams.h>
#include <atlconv.h>
#include <gdiplus.h>
#include "../util/jpegfuncs.h"


using namespace Gdiplus;



HRESULT LoadJPEGImage (Bitmap& bitJpeg, CMediaType *pmt, CMediaType *pOldmt, BYTE *pData);


HRESULT LoadJPEGImageNewBuffer(LPTSTR filename , CMediaType *pmt, BYTE ** ppData)
// Will be called if this code is supposed to allocate the buffer.
{
    if ((pmt == NULL) || (filename == NULL) || (ppData == NULL))
    {
        return E_INVALIDARG;
    }


    Status stat;
    HRESULT hr;
    
    USES_CONVERSION;
    LPWSTR wfilename = T2W(filename);
    
    // Create a GDI+ Bitmap object from the file.
    
    Bitmap bitJpeg(wfilename,TRUE);
    
    // Check if the Bitmap was created.
    
    stat = bitJpeg.GetLastStatus(); 
    if ( stat != Ok)
    {
       // Construction failed...  I'm out of here
       return ConvertStatustoHR(stat);
    }

    // We need the height and width to allocate the buffer.
    UINT iHeight = bitJpeg.GetHeight();
    UINT iWidth = bitJpeg.GetWidth();

    // We will be using RGB 24 with no stride

    long AllocSize = iHeight * WIDTHBYTES( iWidth * 24 );
    
    *ppData = new BYTE [AllocSize];

    if (*ppData ==  NULL)
    {
        return E_OUTOFMEMORY;
    }

    hr = LoadJPEGImage (bitJpeg, pmt, NULL, *ppData);
    if (FAILED(hr))
    {
        delete [] *ppData;
    }
    
    return hr;
}

HRESULT LoadJPEGImagePreAllocated (LPTSTR filename , CMediaType *pmt , CMediaType *pOldmt, BYTE * pData)
// Will be called if Buffer has already been allocated according to a predetermined media type
// If the pmt created from the file does not match the pOldmt for which the buffer was allocated this method
// will return an error code.
{
    if ((pmt == NULL) || (filename == NULL) || (pData == NULL) || (pOldmt == NULL))
    {
        return E_INVALIDARG;
    }

    Status stat;
    
    USES_CONVERSION;
    LPWSTR wfilename = T2W(filename);
    
    // Create a GDI Bitmap object from the file.
    
    Bitmap bitJpeg(wfilename,TRUE);
    
    // Check if the Bitmap was created.
    
    stat = bitJpeg.GetLastStatus() ;
    if (stat != Ok)
    {
       // Construction failed...  I'm out of here
       return ConvertStatustoHR(stat);
    }

    return (LoadJPEGImage(bitJpeg,pmt,pOldmt, pData));
}


HRESULT LoadJPEGImage (Bitmap& bitJpeg, CMediaType *pmt, CMediaType *pOldmt, BYTE *pData)
{
    // Only called from the above two methods so not checking parameters..
    // After pmt is constructed from the bitmap, it is compared to pOldmt, and the method will fail if
    // they do not match.  pOldmt is allowed to be NULL in which case no comparison occurs.

    // First we will setup pmt.

    Status stat;

    VIDEOINFO *pvi = (VIDEOINFO *) pmt->AllocFormatBuffer(sizeof(VIDEOINFO));
    if (!pvi)
    {
        return E_OUTOFMEMORY;
    }

    ZeroMemory (pvi, sizeof (VIDEOINFO));

    // Set up windows bitmap info header
    LPBITMAPINFO pbi = (LPBITMAPINFO) &pvi->bmiHeader;

    pbi->bmiHeader.biSize = sizeof (BITMAPINFOHEADER);

    pbi->bmiHeader.biHeight = (LONG)bitJpeg.GetHeight();
    pbi->bmiHeader.biWidth  = bitJpeg.GetWidth ();

    
    pbi->bmiHeader.biClrUsed = 0;

    pbi->bmiHeader.biPlanes             = 1;        // always
    pbi->bmiHeader.biCompression        = BI_RGB;

    pbi->bmiHeader.biBitCount           = 24;
    pmt->SetSubtype(&MEDIASUBTYPE_RGB24);
    pbi->bmiHeader.biSizeImage = pbi->bmiHeader.biHeight * WIDTHBYTES( pbi->bmiHeader.biWidth * 24 );

    pbi->bmiHeader.biXPelsPerMeter      = 0;
    pbi->bmiHeader.biYPelsPerMeter      = 0;
    pbi->bmiHeader.biClrImportant       = 0;

    
    pmt->SetType (&MEDIATYPE_Video);
    pmt->SetFormatType(&FORMAT_VideoInfo);
    pmt->SetTemporalCompression (FALSE);
    pmt->SetSampleSize(pbi->bmiHeader.biSizeImage);

    // Now lets check if the mediatype has changed, making the buffer we received unsuitable.

    if (pOldmt && (*pmt != *pOldmt))
    {  
        pmt->ResetFormatBuffer();
        return E_ABORT;
    }

    // Now lets copy the bits to the buffer.

    // Move Pointer to bottom of image to copy bottom-up.
    pData = pData + (pbi->bmiHeader.biHeight-1) * WIDTHBYTES( pbi->bmiHeader.biWidth * 24 );

    Rect rect(0,0,pbi->bmiHeader.biWidth , pbi->bmiHeader.biHeight);

    BitmapData bitData;
    bitData.Width       = pbi->bmiHeader.biWidth;
    bitData.Height      = pbi->bmiHeader.biHeight;
    bitData.Stride      = - long( WIDTHBYTES( pbi->bmiHeader.biWidth * 24 ) );
    bitData.PixelFormat = PixelFormat24bppRGB;
    bitData.Scan0       = (PVOID) pData;

    stat = bitJpeg.LockBits(&rect, ImageLockModeRead | ImageLockModeUserInputBuf, PixelFormat24bppRGB,
                            &bitData);

    if (stat != Ok)
    {
        pmt->ResetFormatBuffer();
        return ConvertStatustoHR(stat);
    }
   
    stat = bitJpeg.UnlockBits(&bitData);
    if (stat != Ok)
    {
        pmt->ResetFormatBuffer();
        return ConvertStatustoHR(stat);
    }

   
    // pData should have the image in it now
    return S_OK;
}
=== C:/Users/treeman/Desktop/windows nt source code\Source\Win2K3\NT\multimedia\dshow\filterus\dexter\stillvid\stillvid.cpp ===
//@@@@AUTOBLOCK+============================================================;
//
//  THIS CODE AND INFORMATION IS PROVIDED "AS IS" WITHOUT WARRANTY OF ANY
//  KIND, EITHER EXPRESSED OR IMPLIED, INCLUDING BUT NOT LIMITED TO THE
//  IMPLIED WARRANTIES OF MERCHANTABILITY AND/OR FITNESS FOR A PARTICULAR
//  PURPOSE.
//
//  File: stillvid.cpp
//
//  Copyright (c) Microsoft Corporation.  All Rights Reserved.
//
//@@@@AUTOBLOCK-============================================================;

// !!! FILTER should support IGenVideo/IDexterSequencer, not the pin?

#include <streams.h>
#include <qeditint.h>
#include <qedit.h>
#include "StillVid.h"
#include "StilProp.h"
#include "ourtgafile.h"
#include <gdiplus.h>



#include "..\util\conv.cxx"
#include "..\util\filfuncs.h"
#include "..\util\dexmisc.h"


using namespace Gdiplus;
#define GIF_UNIT 100000	// # of UNITs per unit of GIF delay
#define CHECKCALL(x) if (!(x)) return VFW_E_INVALID_MEDIA_TYPE;


extern HRESULT LoadJPEGImageNewBuffer(LPTSTR filename , CMediaType *pmt, BYTE ** ppData);
extern HRESULT LoadJPEGImagePreAllocated (LPTSTR filename , CMediaType *pmt , CMediaType *pOldmt, BYTE * pData);


// util for DIB sequces
static DWORD dseqParseFileName(	LPTSTR lpszFileName,	    //the first file name
				LPTSTR lpszTemplate,	    //file template
				DWORD FAR * lpdwMaxValue);

HRESULT OpenDIBFile ( HANDLE hFile, PBYTE *ppbData, CMediaType *pmt, PBYTE pBuf) ;
HRESULT OpenTGAFile ( HANDLE hFile, PBYTE *ppbData, CMediaType *pmt, PBYTE pBuf) ;
HRESULT ReadDibBitmapInfo (HANDLE hFile, LPBITMAPINFOHEADER lpbi);
HRESULT ReadTgaBitmapInfo (HANDLE hFile, LPBITMAPINFOHEADER lpbi);

TCHAR* LSTRRCHR( const TCHAR* lpString, int bChar )
{
  if( lpString != NULL ) {	
    const TCHAR*	lpBegin;
    lpBegin = lpString;

    while( *lpString != 0 ) lpString=CharNext(lpString);
    while( 1 ) {
      if( *lpString == bChar ) return (TCHAR*)lpString;
      if( lpString == lpBegin ) break;
      lpString=CharPrev(lpBegin,lpString);
    }
  }

  return NULL;
} /* LSTRRCHR */


// Setup data

const AMOVIESETUP_MEDIATYPE sudOpPinTypes =
{
    &MEDIATYPE_Video,       // Major type
    &MEDIASUBTYPE_NULL      // Minor type
};

const AMOVIESETUP_PIN sudOpPin =
{
    L"Output",              // Pin string name
    FALSE,                  // Is it rendered
    TRUE,                   // Is it an output
    FALSE,                  // Can we have none
    FALSE,                  // Can we have many
    &CLSID_NULL,            // Connects to filter
    NULL,                   // Connects to pin
    1,                      // Number of types
    &sudOpPinTypes };       // Pin details

const AMOVIESETUP_FILTER sudStillVid =
{
    &CLSID_GenStilVid,    // Filter CLSID
    L"Generate Still Video",  // String name
    MERIT_DO_NOT_USE,       // Filter merit
    1,                      // Number pins
    &sudOpPin               // Pin details
};

//
// CreateInstance
//
// Create GenStilVid filter
//
CUnknown * WINAPI CGenStilVid::CreateInstance(LPUNKNOWN lpunk, HRESULT *phr)
{
    CUnknown *punk = new CGenStilVid(lpunk, phr);
    if (punk == NULL) {
        *phr = E_OUTOFMEMORY;
    }
    return punk;

} // CreateInstance


//
// Constructor
//
// Initialise a CStilVidStream object so that we have a pin.
//
CGenStilVid::CGenStilVid(LPUNKNOWN lpunk, HRESULT *phr) :
    CSource(NAME("Generate Still Video"),
            lpunk,
            CLSID_GenStilVid)
     ,CPersistStream(lpunk, phr)
     ,m_lpszDIBFileTemplate(NULL)
     ,m_bFileType(NULL)
     ,m_dwMaxDIBFileCnt(0)
     ,m_dwFirstFile(0)
     ,m_pFileName(NULL)
     ,m_llSize(0)
     ,m_pbData (NULL)
     ,m_hbitmap(NULL)
     ,m_fAllowSeq(FALSE)
     ,m_pGif(NULL)
     ,m_pList(NULL)
     ,m_pListHead(NULL)
     ,m_rtGIFTotal(0)
{

    //Initialize GDI +
    GdiplusStartupInput gdiplusStartupInput;
    GdiplusStartup (&m_GdiplusToken, &gdiplusStartupInput, NULL);
}

CGenStilVid::~CGenStilVid()
{
    delete [] m_lpszDIBFileTemplate;

    Unload();

    SaferFreeMediaType(m_mt);

    delete m_pGif;
    if (m_paStreams) {
        delete m_paStreams[0];
    }
    delete [] m_paStreams;
    GdiplusShutdown(m_GdiplusToken);

    
};

STDMETHODIMP CGenStilVid::NonDelegatingQueryInterface(
    REFIID riid,
    void ** ppv
    )
{
    if (riid == IID_IFileSourceFilter) {
	return GetInterface((IFileSourceFilter *) this, ppv);
    }else if (riid == IID_IPersistStream) {
	return GetInterface((IPersistStream *) this, ppv);
    }else if (riid == IID_IAMSetErrorLog) {
	return GetInterface((IAMSetErrorLog *) this, ppv);
    }else {
        return CSource::NonDelegatingQueryInterface(riid, ppv);
    }

}

// IPersistStream

// tell our clsid
//
STDMETHODIMP CGenStilVid::GetClassID(CLSID *pClsid)
{
    CheckPointer(pClsid, E_POINTER);
    *pClsid = CLSID_GenStilVid;
    return S_OK;
}


typedef struct _STILLSave {
    REFERENCE_TIME	rtStartTime;
    REFERENCE_TIME	rtDuration;
    double		dOutputFrmRate;		// Output frm rate frames/second
} STILLSav;

// !!! Persist the media type too?
// !!! we only use 1 start/stop/skew right now

// persist ourself
//
HRESULT CGenStilVid::WriteToStream(IStream *pStream)
{
    DbgLog((LOG_TRACE,1,TEXT("CGenStilVid::WriteToStream")));

    CheckPointer(pStream, E_POINTER);
    CheckPointer(m_paStreams, E_POINTER);
    CheckPointer(m_paStreams[0], E_POINTER);

    STILLSav x;

    DbgLog((LOG_TRACE,1,TEXT("Persisted data is %d bytes"), sizeof(x)));

    CStilVidStream *pOutpin=( CStilVidStream *)m_paStreams[0];

    x.rtStartTime	= pOutpin->m_rtStartTime;
    x.rtDuration	= pOutpin->m_rtDuration;
    x.dOutputFrmRate	= pOutpin->m_dOutputFrmRate;

    HRESULT hr = pStream->Write(&x, sizeof(x), 0);
    if(FAILED(hr)) {
        DbgLog((LOG_ERROR,1,TEXT("*** WriteToStream FAILED")));
        return hr;
    }
    return NOERROR;
}


// load ourself
//
HRESULT CGenStilVid::ReadFromStream(IStream *pStream)
{
    DbgLog((LOG_TRACE,1,TEXT("CenBlkVid::ReadFromStream")));

    CheckPointer(pStream, E_POINTER);
    CheckPointer(m_paStreams, E_POINTER);
    CheckPointer(m_paStreams[0], E_POINTER);

    STILLSav x;

    HRESULT hr = pStream->Read(&x, sizeof(x), 0);
    if(FAILED(hr)) {
        DbgLog((LOG_ERROR,1,TEXT("*** ReadFromStream FAILED")));
        return hr;
    }

    CStilVidStream *pOutpin=( CStilVidStream *)m_paStreams[0];

    pOutpin->put_OutputFrmRate(x.dOutputFrmRate);
    pOutpin->ClearStartStopSkew();
    pOutpin->AddStartStopSkew(x.rtStartTime, x.rtStartTime + x.rtDuration, 0,1);	
    SetDirty(FALSE);
    return S_OK;
}

// how big is our save data?
int CGenStilVid::SizeMax()
{
    return sizeof(STILLSav);
}


// return a non-addrefed pointer to the CBasePin.
CBasePin *CGenStilVid::GetPin(int n)
{
    if ( m_paStreams != NULL)
    {
	if ( (!n) && m_paStreams[0] != NULL)
	return m_paStreams[0];
    }
    return NULL;
}
int CGenStilVid::GetPinCount()
{
    if ( m_paStreams != NULL)
    {
	if(m_paStreams[0] != NULL)
	    return 1;
    }
    return 0;
}

//
// lFileSourceFilter
//
STDMETHODIMP CGenStilVid::Unload()
{
    if (m_pFileName) {
	delete[] m_pFileName;
	m_pFileName = NULL;
    }

    // if we have an hbitmap, then m_pbData is in that and doesn't need freeing
    if (m_hbitmap) {
	DeleteObject(m_hbitmap);
	m_hbitmap = NULL;
    } else if(m_pbData) {
	delete[] m_pbData;
	m_pbData=NULL;
    }

    return S_OK;
}

STDMETHODIMP CGenStilVid::Load(
    LPCOLESTR lpwszFileName,
    const AM_MEDIA_TYPE *pmt)
{
    DbgLog((LOG_TRACE,2,TEXT("Still::Load")));
    CheckPointer(lpwszFileName, E_POINTER);
    HRESULT hr = S_OK;
    
    hr = ValidateFilename ((WCHAR*)lpwszFileName,_MAX_PATH, FALSE);
    if (FAILED(hr))
    {
        return (hr);
    }
    
    // Remove previous name
    Unload();

    if(m_lpszDIBFileTemplate!=NULL)
    {
	delete []m_lpszDIBFileTemplate;
	m_lpszDIBFileTemplate=NULL;
    }

    USES_CONVERSION;
    TCHAR * lpszFileName = W2T((WCHAR*) lpwszFileName );

    //
    // Compare against known extensions that we don't punt to the plugin
    // decoders
    //

    TCHAR* ext = LSTRRCHR(lpszFileName, (int)TEXT('.'));
    
    // create output pin
    if (m_paStreams == NULL) {
        m_paStreams = (CSourceStream **)new CStilVidStream*[1];
        if (m_paStreams == NULL)
            return E_OUTOFMEMORY;

        m_paStreams[0] = new CStilVidStream(&hr, this, L"Generate Still Video");
        if (m_paStreams[0] == NULL) {
	    delete [] m_paStreams;
	    m_paStreams = NULL;
            return E_OUTOFMEMORY;
	}
    }

    hr = E_FAIL;

    // if it's a .bmp or a .jpg or a .tga
    //
    if (ext && (!DexCompare(ext, TEXT(".bmp")) || !DexCompare(ext, TEXT(".dib")) ||
		!DexCompare(ext, TEXT(".jpg")) || !DexCompare(ext, TEXT(".jpeg"))||
		!DexCompare(ext, TEXT(".jfif")) || !DexCompare(ext, TEXT(".jpe")) ||
                !DexCompare(ext, TEXT(".tga"))
                ))
    {
	//open space to SAVE file name
	m_lpszDIBFileTemplate	= new TCHAR[MAX_PATH];
	if (!m_lpszDIBFileTemplate)
        return E_OUTOFMEMORY;
   
    //check how many dib files exist
	m_dwFirstFile= dseqParseFileName( lpszFileName,	    //file name
				m_lpszDIBFileTemplate,	    //
				&m_dwMaxDIBFileCnt);

	//open the first DIB/JPEG file
	HANDLE hFile = CreateFile(lpszFileName,		//file name	
			      GENERIC_READ,		//DesiredAccess
                              FILE_SHARE_READ,		//dwShareMode
                              NULL,			//SecurityAttrib
                              OPEN_EXISTING,		//dwCreationDisposition
                              0,			//dwFlagsAndAttributes
                              NULL);			//hTemplateFile

	if ( hFile == INVALID_HANDLE_VALUE)
	{
	    DbgLog((LOG_TRACE,2,TEXT("Could not open %s\n"), lpszFileName));
	    return E_INVALIDARG;
	}

	//have to open file to get mt
        //
	if (!DexCompare(ext, TEXT(".bmp")) || !DexCompare(ext, TEXT(".dib")))
	{
	    //only one DIB file
	    hr= OpenDIBFile (hFile, &m_pbData, &m_mt, NULL);	
	    CloseHandle(hFile);
		//X* I can use LoadImage(). But do not know whether it support BITMAPCOREHEADER
	}
	else if( !DexCompare( ext, TEXT(".tga")) )
	{
        hr = OpenTGAFile( hFile, &m_pbData, &m_mt, NULL );
    }
    else
    {
	    CloseHandle(hFile);
        // it is a JPEG file
        hr = LoadJPEGImageNewBuffer(lpszFileName, &m_mt, &m_pbData);
    }

	// can we do sequences?  (We don't know yet if we want to)
	if (m_dwFirstFile==0 && m_dwMaxDIBFileCnt ==0)
	{
	    // one file
	    delete [] m_lpszDIBFileTemplate;
	    m_lpszDIBFileTemplate=NULL;
	
	}
	else
	{
	    //sequence
	    if (!DexCompare(ext, TEXT(".bmp")) ||
					!DexCompare(ext, TEXT(".dib"))) {
	 	m_bFileType =STILLVID_FILETYPE_DIB;
	    } else if( !DexCompare( ext, TEXT(".tga") ) )
            {
	 	m_bFileType = STILLVID_FILETYPE_TGA;
            }
            else
            {
	 	m_bFileType =STILLVID_FILETYPE_JPG;
		// Leave the first jpeg loaded.. we may not do sequences, and
		// the single one we've loaded may be needed
	    }
	}
    }
    else if ( ext && (!DexCompare(ext, TEXT(".gif")))) // if it's a gif
    {

        HANDLE hFile = CreateFile(lpszFileName,		//file name	
			      GENERIC_READ,		//DesiredAccess
                              FILE_SHARE_READ,		//dwShareMode
                              NULL,			//SecurityAttrib
                              OPEN_EXISTING,		//dwCreationDisposition
                              0,			//dwFlagsAndAttributes
                              NULL);			//hTemplateFile

	if ( hFile == INVALID_HANDLE_VALUE)
	{
	        DbgLog((LOG_TRACE,2,TEXT("Could not open %s\n"), lpszFileName));
	        return E_INVALIDARG;
	}

        m_bFileType=STILLVID_FILETYPE_GIF;

        //create a GIF object
        m_pGif  = new CImgGif( hFile);
	if (m_pGif == NULL) {
	    CloseHandle(hFile);
	    return E_OUTOFMEMORY;
	}

	// !!! This loads EVERY FRAME of the animated GIF up front and uses
	// an extra frame copy for every delta frame that could all be avoided
	// by loading the GIF as needed into a single output buffer.
	// !!! But then seeking would be slower.. we'd need to re-read many
	// frames every seek (although no memory copies)
	//
	hr = m_pGif->OpenGIFFile(&m_pList, &m_mt);	// gets MT too
	CloseHandle(hFile);
        m_pListHead = m_pList;
	m_rtGIFTotal = 0;
	int count = 0;

	if (SUCCEEDED(hr)) {
	    do {
	        m_rtGIFTotal += m_pList->delayTime * GIF_UNIT;
		count++;
		m_pList = m_pList->next;
	    } while (m_pList != m_pListHead);

	    m_pList = m_pListHead;	// put this back
            DbgLog((LOG_TRACE,2,TEXT("GIF Total play time = %dms"),
					(int)(m_rtGIFTotal / 10000)));
	    if (count > 1) {
		VIDEOINFOHEADER *pvi = (VIDEOINFOHEADER *)m_mt.Format();
	        pvi->AvgTimePerFrame = m_rtGIFTotal / count;
                DbgLog((LOG_TRACE,2,TEXT("AvgTimePerFrame = %dms"),
					(int)(pvi->AvgTimePerFrame / 10000)));
	    }
	}
    }
    else
    {
        DbgLog((LOG_TRACE, 1, TEXT("not supported compressiion format.\n")));
    }						

    if (SUCCEEDED(hr)) {
	//copy file name
	//m_Stream.Init(m_ppbData, m_llSize);
// SEC: string
	m_pFileName = new WCHAR[wcslen(lpwszFileName) + 1];
	if (m_pFileName!=NULL) {
// SEC: string
	    wcscpy(m_pFileName, lpwszFileName);
	}
    }

    return hr;
}

//
// GetCurFile
//
STDMETHODIMP CGenStilVid::GetCurFile(
		LPOLESTR * ppszFileName,
                AM_MEDIA_TYPE *pmt)
{
    // return the current file name from avifile

    CheckPointer(ppszFileName, E_POINTER);
    *ppszFileName = NULL;
    if (m_pFileName!=NULL) {
        *ppszFileName = (LPOLESTR) QzTaskMemAlloc( sizeof(WCHAR)
                                                 * (1+lstrlenW(m_pFileName)));
        if (*ppszFileName!=NULL) {
            lstrcpyW(*ppszFileName, m_pFileName);
        }
        else 
        {
            return E_OUTOFMEMORY;
        }
    }

    if (pmt) {
	pmt->majortype = GUID_NULL;   // Later!
	pmt->subtype = GUID_NULL;     // Later!
	pmt->pUnk = NULL;             // Later!
	pmt->lSampleSize = 0;         // Later!
	pmt->cbFormat = 0;            // Later!
    }

    return NOERROR;
}

WORD DibNumColors (VOID FAR *pv)
{
    int bits;
    LPBITMAPINFOHEADER lpbi;
    LPBITMAPCOREHEADER lpbc;

    lpbi = ((LPBITMAPINFOHEADER)pv);
    lpbc = ((LPBITMAPCOREHEADER)pv);

    //  With the BITMAPINFO format headers, the size of the palette
    //  is in biClrUsed, whereas in the BITMAPCORE - style headers, it
    //  is dependent on the bits per pixel ( = 2 raised to the power of
    //  bits/pixel).
    //
    if (lpbi->biSize != sizeof(BITMAPCOREHEADER))
    {
        if (lpbi->biClrUsed != 0)
        {
            return (WORD)lpbi->biClrUsed;
        }
        bits = lpbi->biBitCount;
    }
    else
        bits = lpbc->bcBitCount;

    switch (bits)
    {
    case 1:
        return 2;   //
    case 4:
        return 16;
    case 8:
        return 256;
    default:
        /* higher bitcounts have no color table */
        return 0;
    }
}

//
// OpenDIBFile()
// Function: build media type pmt
//	     read DIB data to a buffer, and pbData points to it
//	
HRESULT OpenDIBFile ( HANDLE hFile, PBYTE *ppbData, CMediaType *pmt, PBYTE pBuf)
{
    ASSERT( (ppbData!=NULL) | (pBuf!= NULL) );

    //make media type
    VIDEOINFO *pvi = (VIDEOINFO *) pmt->AllocFormatBuffer(sizeof(VIDEOINFO));
    if (NULL == pvi) {
	return(E_OUTOFMEMORY);
    }
    ZeroMemory(pvi, sizeof(VIDEOINFO));

    LPBITMAPINFOHEADER lpbi = HEADER(pvi);

    //Retrieves the BITMAPINFOHEADER info
    if( ReadDibBitmapInfo(hFile, lpbi) != NOERROR )
	return E_FAIL;

    // !!! support compression?
    if (lpbi->biCompression > BI_BITFIELDS)
	return E_INVALIDARG;

    pmt->SetType(&MEDIATYPE_Video);
    switch (lpbi->biBitCount)
    {
    case 32:
	pmt->SetSubtype(&MEDIASUBTYPE_ARGB32);
	break;
    case 24:
	pmt->SetSubtype(&MEDIASUBTYPE_RGB24);
	break;
    case 16:
	if (lpbi->biCompression == BI_RGB)
	    pmt->SetSubtype(&MEDIASUBTYPE_RGB555);
	else {
	    DWORD *p = (DWORD *)(lpbi + 1);
	    if (*p == 0x7c00 && *(p+1) == 0x03e0 && *(p+2) == 0x001f)
	        pmt->SetSubtype(&MEDIASUBTYPE_RGB555);
	    else if (*p == 0xf800 && *(p+1) == 0x07e0 && *(p+2) == 0x001f)
	        pmt->SetSubtype(&MEDIASUBTYPE_RGB565);
	    else
		return E_INVALIDARG;
	}
	break;
    case 8:
	if (lpbi->biCompression == BI_RLE8) {
	    FOURCCMap fcc = BI_RLE8;
	    pmt->SetSubtype(&fcc);
	} else
	    pmt->SetSubtype(&MEDIASUBTYPE_RGB8);
	break;
    case 4:
	if (lpbi->biCompression == BI_RLE4) {
	    FOURCCMap fcc = BI_RLE4;
	    pmt->SetSubtype(&fcc);
	} else
	    pmt->SetSubtype(&MEDIASUBTYPE_RGB4);
	break;
    case 1:
	pmt->SetSubtype(&MEDIASUBTYPE_RGB1);
	break;
    default:
	return E_UNEXPECTED;
	// !!! pmt->SetSubtype(&MEDIASUBTYPE_NULL);
	break;
    }
    pmt->SetFormatType(&FORMAT_VideoInfo);
    pmt->SetTemporalCompression(FALSE);

    // Calculate the memory needed to hold the DIB - DON'T TRUST biSizeImage!
    DWORD dwBits = DIBSIZE(*lpbi);
    pmt->SetSampleSize(dwBits);

    //Retrieves the BITMAPINFOHEADER info. block associated with a CF_DIB format memory block
    //DibInfo(hdib,&bi);

    // set a buffer for DIB
    PBYTE pbMem;
    if(ppbData==NULL)
    {
	pbMem=pBuf;
    }
    else
    {
	pbMem = new BYTE[dwBits];
	if (pbMem == NULL)
	    return E_OUTOFMEMORY;
    }

    //Read Data to Buffer
    DWORD dwBytesRead=0;
    if (!ReadFile(hFile,
                  (LPVOID)pbMem,	// pointer to buffer that receives daata
                  dwBits,		// Number of bytes to read
                  &dwBytesRead,		// Munber of bytes read
                  NULL) ||
		  dwBytesRead != dwBits)
    {
	DbgLog((LOG_TRACE, 1, TEXT("Could not read file\n")));
        delete [] pbMem;
        return E_INVALIDARG;
    }

    if(ppbData!=NULL)
	*ppbData =pbMem;

    return NOERROR;
}

//
// OpenDIBFile()
// Function: build media type pmt
//	     read DIB data to a buffer, and pbData points to it
//	
HRESULT OpenTGAFile ( HANDLE hFile, PBYTE *ppbData, CMediaType *pmt, PBYTE pBuf)
{
    ASSERT( (ppbData!=NULL) | (pBuf!= NULL) );

    //make media type
    //
    VIDEOINFO * pvi = (VIDEOINFO *) pmt->AllocFormatBuffer( sizeof(VIDEOINFO) );
    if (NULL == pvi)
    {
	return(E_OUTOFMEMORY);
    }
    ZeroMemory(pvi, sizeof(VIDEOINFO));

    LPBITMAPINFOHEADER lpbi = HEADER(pvi);

    //Retrieves the BITMAPINFOHEADER info
    HRESULT hrRead = ReadTgaBitmapInfo(hFile, lpbi);
    if( FAILED( hrRead ) ) return hrRead;

    pmt->SetType(&MEDIATYPE_Video);
    switch (lpbi->biBitCount)
    {
    case 32:
	pmt->SetSubtype(&MEDIASUBTYPE_ARGB32);
	break;
    case 24:
	pmt->SetSubtype(&MEDIASUBTYPE_RGB24);
	break;
    case 16:
	pmt->SetSubtype(&MEDIASUBTYPE_RGB555);
	break;
    default:
        return E_UNEXPECTED;
    }
    pmt->SetFormatType(&FORMAT_VideoInfo);
    pmt->SetTemporalCompression(FALSE);

    // Calculate the memory needed to hold the DIB - DON'T TRUST biSizeImage!
    DWORD dwBits = DIBSIZE(*lpbi);
    pmt->SetSampleSize(dwBits);

    // set a buffer for DIB
    PBYTE pbMem;
    if(ppbData==NULL)
    {
	pbMem=pBuf;
    }
    else
    {
	pbMem = new BYTE[dwBits];
	if (pbMem == NULL)
	    return E_OUTOFMEMORY;
    }

    //Read Data to Buffer
    DWORD dwBytesRead=0;
    if (!ReadFile(hFile,
                  (LPVOID)pbMem,	// pointer to buffer that receives daata
                  dwBits,		// Number of bytes to read
                  &dwBytesRead,		// Munber of bytes read
                  NULL) ||
		  dwBytesRead != dwBits)
    {
	DbgLog((LOG_TRACE, 1, TEXT("Could not read file\n")));
        delete [] pbMem;
        return E_INVALIDARG;
    }

    if(ppbData!=NULL)
	*ppbData =pbMem;

    return NOERROR;
}


//
// ReadDibBitmapInfo()
// It works with "old" (BITMAPCOREHEADER) and "new" (BITMAPINFOHEADER)
//       bitmap formats, but will always return a "new" BITMAPINFO
//
HRESULT ReadDibBitmapInfo (HANDLE hFile, LPBITMAPINFOHEADER lpbi)
{
    CheckPointer(lpbi, E_POINTER);

    DWORD dwBytesRead=0;

    if (hFile == NULL)
        return E_FAIL;

    // Reset file pointer and read file BITMAPFILEHEADER
    DWORD  dwResult = SetFilePointer(	hFile,
					0L,
					NULL,
					FILE_BEGIN);
    DWORD off =dwResult;
    if(dwResult == 0xffffffff)
    {
	DbgLog((LOG_TRACE, 3, TEXT("Could not seek to the beginning of the File\n")));
        return E_INVALIDARG;
    }
    BITMAPFILEHEADER   bf;
    if ( !ReadFile(	hFile,
			(LPVOID)&bf,				// pointer to buffer that receives daata
			sizeof(BITMAPFILEHEADER),		// Number of bytes to read
			&dwBytesRead,				// Munber of bytes read
			NULL) ||
			dwBytesRead != sizeof(BITMAPFILEHEADER) )
    {
	DbgLog((LOG_TRACE, 1, TEXT("Could not read BitMapFileHeader\n")));
        return E_INVALIDARG;
    }

    // Do we have a RC HEADER?
#define BFT_BITMAP 0x4d42	//"BM"
    if ( bf.bfType !=BFT_BITMAP)
    {
        bf.bfOffBits = 0L;
        DWORD dwResult1 = SetFilePointer(hFile,
					dwResult,
					NULL,
					FILE_BEGIN);

	if(dwResult1 == 0xffffffff)
        {
	    DbgLog((LOG_TRACE, 1, TEXT("Could not seek to RC HEADER\n")));
	    return E_INVALIDARG;
        }
    }

    // Read BITMAPINFOHEADER
    BITMAPINFOHEADER   bi;
    if (!ReadFile(	hFile,
			(LPVOID)&bi,					// pointer to buffer that receives daata
			sizeof(BITMAPINFOHEADER),		// Number of bytes to read
			&dwBytesRead,					// Munber of bytes read
			NULL) ||
			dwBytesRead != sizeof(BITMAPINFOHEADER) )
    {
	DbgLog((LOG_TRACE, 1, TEXT("Could not read BitMapInfoHeader\n")));
        return E_INVALIDARG;
    }

    // calc DIB number colors
    WORD      nNumColors;
    nNumColors = DibNumColors (&bi);
    if( nNumColors > 256 )
    {
        return VFW_E_INVALIDMEDIATYPE;
    }

    /* Check the nature (BITMAPINFO or BITMAPCORE) of the info. block
     * and extract the field information accordingly. If a BITMAPCOREHEADER,
     * transfer it's field information to a BITMAPINFOHEADER-style block
     */
    int       size;
    DWORD          dwWidth = 0;
    DWORD          dwHeight = 0;
    switch (size = (int)bi.biSize)
    {
    case sizeof (BITMAPINFOHEADER):
        break;

    case sizeof (BITMAPCOREHEADER):
	//make BITMAPHEADER
	BITMAPCOREHEADER   bc;
	WORD           wPlanes, wBitCount;

	bc = *(BITMAPCOREHEADER*)&bi;
        dwWidth   = (DWORD)bc.bcWidth;
        dwHeight  = (DWORD)bc.bcHeight;
        wPlanes   = bc.bcPlanes;
        wBitCount = bc.bcBitCount;
        bi.biSize           = sizeof(BITMAPINFOHEADER);
        bi.biWidth          = dwWidth;
        bi.biHeight         = dwHeight;
        bi.biPlanes         = wPlanes;
        bi.biBitCount       = wBitCount;
        bi.biCompression    = BI_RGB;
        bi.biSizeImage      = 0;
        bi.biXPelsPerMeter  = 0;
        bi.biYPelsPerMeter  = 0;
        bi.biClrUsed        = nNumColors;
        bi.biClrImportant   = nNumColors;

	dwResult = SetFilePointer(hFile,
				  LONG(sizeof (BITMAPCOREHEADER) -
					sizeof (BITMAPINFOHEADER)),
				  NULL,
				  FILE_BEGIN);

	if(dwResult == 0xffffffff)
        {
   	    DbgLog((LOG_TRACE, 1, TEXT("Could not seek to Data\n")));
	    return E_INVALIDARG;
        }

        break;

    default:
        // Not a DIB!
        return E_FAIL;
    }

    //  Fill in some default values if they are zero
    if (bi.biSizeImage == 0)
    {
        bi.biSizeImage = WIDTHBYTES((DWORD)bi.biWidth * bi.biBitCount)
            * bi.biHeight;
    }
    if (bi.biClrUsed == 0)
        bi.biClrUsed = DibNumColors(&bi);

    if( bi.biClrUsed > 256 )
    {
        return VFW_E_INVALIDMEDIATYPE;
    }

    // set bitMapInforHeader
    *lpbi = bi;

    // Get a pointer to the color table
    RGBQUAD FAR  *pRgb = (RGBQUAD FAR *)((LPSTR)lpbi + bi.biSize);
    if (nNumColors)
    {
        if (size == sizeof(BITMAPCOREHEADER))
        {
            // Convert a old color table (3 byte RGBTRIPLEs) to a new
            // color table (4 byte RGBQUADs)
	    if ( !ReadFile( hFile,
			    (LPVOID)pRgb,			// pointer to buffer that receives daata
			    nNumColors * sizeof(RGBTRIPLE),		// Number of bytes to read
			    &dwBytesRead,				// Munber of bytes read
			    NULL) ||
			    dwBytesRead != (nNumColors * sizeof(RGBTRIPLE)) )
	    {
		DbgLog((LOG_TRACE, 1, TEXT("Could not read RGB table\n")));
		return E_INVALIDARG;
	    }

            for (int i = nNumColors - 1; i >= 0; i--)
            {
                RGBQUAD rgb;

                rgb.rgbRed  = ((RGBTRIPLE FAR *)pRgb)[i].rgbtRed;
                rgb.rgbBlue = ((RGBTRIPLE FAR *)pRgb)[i].rgbtBlue;
                rgb.rgbGreen    = ((RGBTRIPLE FAR *)pRgb)[i].rgbtGreen;
                rgb.rgbReserved = 255; // opaque

                pRgb[i] = rgb;
            }
        }
        else
        {
    	
	    if ( !ReadFile( hFile,
			    (LPVOID)pRgb,			// pointer to buffer that receives daata
			    nNumColors * sizeof(RGBQUAD),		// Number of bytes to read
			    &dwBytesRead,				// Munber of bytes read
			    NULL) ||
			    dwBytesRead != (nNumColors * sizeof(RGBQUAD) ) )
	    {
		DbgLog((LOG_TRACE, 1, TEXT("Could not read RGBQUAD table\n")));
		return E_INVALIDARG;
	    }
	}
    }

    if (bf.bfOffBits != 0L)
    {
       	dwResult = SetFilePointer(hFile,
		  (off + bf.bfOffBits),								
		  NULL,
		  FILE_BEGIN);

	if(dwResult == 0xffffffff)
        {
   	    DbgLog((LOG_TRACE, 1, TEXT("Could not seek to Data\n")));
	    return E_INVALIDARG;
        }
    }

    return NOERROR;
}

HRESULT ReadTgaBitmapInfo( HANDLE hFile, BITMAPINFOHEADER * pBIH )
{
    CheckPointer( pBIH, E_POINTER );
    if( !hFile ) return E_POINTER;

    DWORD dwResult = SetFilePointer( hFile, 0, NULL, FILE_BEGIN );
    if( dwResult == 0xffffffff )
    {
        return STG_E_SEEKERROR;
    }

    // you absolutely, CANNOT, no matter what you THINK you know,
    // read this structure in one fell swoop. You must read them
    // individually
    //
    DWORD dwBytesRead = 0;
    TGAFile TgaHeader;
    DWORD totRead = 0;
    CHECKCALL(ReadFile( hFile, &TgaHeader.idLength, 1, &dwBytesRead, NULL ));
    totRead += dwBytesRead;
    CHECKCALL(ReadFile( hFile, &TgaHeader.mapType, 1, &dwBytesRead, NULL ));
    totRead += dwBytesRead;
    CHECKCALL(ReadFile( hFile, &TgaHeader.imageType, 1, &dwBytesRead, NULL ));
    totRead += dwBytesRead;
    CHECKCALL(ReadFile( hFile, &TgaHeader.mapOrigin, 2, &dwBytesRead, NULL ));
    totRead += dwBytesRead;
    CHECKCALL(ReadFile( hFile, &TgaHeader.mapLength, 2, &dwBytesRead, NULL ));
    totRead += dwBytesRead;
    CHECKCALL(ReadFile( hFile, &TgaHeader.mapWidth, 1, &dwBytesRead, NULL ));
    totRead += dwBytesRead;
    CHECKCALL(ReadFile( hFile, &TgaHeader.xOrigin, 2, &dwBytesRead, NULL ));
    totRead += dwBytesRead;
    CHECKCALL(ReadFile( hFile, &TgaHeader.yOrigin, 2, &dwBytesRead, NULL ));
    totRead += dwBytesRead;
    CHECKCALL(ReadFile( hFile, &TgaHeader.imageWidth, 2, &dwBytesRead, NULL ));
    totRead += dwBytesRead;
    CHECKCALL(ReadFile( hFile, &TgaHeader.imageHeight, 2, &dwBytesRead, NULL ));
    totRead += dwBytesRead;
    CHECKCALL(ReadFile( hFile, &TgaHeader.pixelDepth, 1, &dwBytesRead, NULL ));
    totRead += dwBytesRead;
    CHECKCALL(ReadFile( hFile, &TgaHeader.imageDesc, 1, &dwBytesRead, NULL ));
    totRead += dwBytesRead;

    // it has to have read at least the header length
    //
    if( totRead != 18 )
    {
        return VFW_E_INVALID_MEDIA_TYPE;
    }

    // we only read uncompressed TGA's
    //
    if( TgaHeader.imageType != 2 )
    {
        return VFW_E_INVALID_MEDIA_TYPE;
    }

    // we only read 24 bit or 32 bit TGA's
    //
    if( TgaHeader.pixelDepth < 16 )
    {
        return VFW_E_INVALID_MEDIA_TYPE;
    }

    BYTE dummy[256];
    if( TgaHeader.idLength > 256 )
    {
        return E_FAIL;
    }
    if( TgaHeader.idLength > 0 )
    {
        CHECKCALL(ReadFile( hFile, dummy, TgaHeader.idLength, &dwBytesRead, NULL ));
        if( dwBytesRead != TgaHeader.idLength )
        {
            return VFW_E_INVALID_MEDIA_TYPE;
        }
    }

    memset( pBIH, 0, sizeof( BITMAPINFOHEADER ) );
    pBIH->biSize = sizeof(BITMAPINFOHEADER);
    pBIH->biWidth = TgaHeader.imageWidth;
    pBIH->biHeight = TgaHeader.imageHeight;
    pBIH->biPlanes = 1;
    pBIH->biBitCount = TgaHeader.pixelDepth;
    pBIH->biSizeImage = DIBSIZE(*pBIH);

    return NOERROR;
}

//
// output pin Constructor
//
CStilVidStream::CStilVidStream(HRESULT *phr,
                         CGenStilVid *pParent,
                         LPCWSTR pPinName) :
    CSourceStream(NAME("Generate Still Video"),phr, pParent, pPinName),
    m_pGenStilVid(pParent),
    m_rtStartTime(0),
    m_rtDuration(MAX_TIME/1000), // MUST BE INFINITE, Dexter doesn't set stop
				 // time (but not so big math on it overflows)
    m_rtNewSeg(0),
    m_rtLastStop(0),
    m_lDataLen(0), // output buffer data length
    m_dwOutputSampleCnt(0),
    m_dOutputFrmRate(0.1),
    m_bIntBufCnt(0),
    m_iBufferCnt(0),    //How many buffer we get
    m_bZeroBufCnt(0),
    m_ppbDstBuf(NULL)
{
} // (Constructor)

    //X
// destructor
CStilVidStream::~CStilVidStream()
{
    /* BUFFER POINTER */
    if (m_ppbDstBuf)
    {
	delete [] m_ppbDstBuf;
	m_ppbDstBuf=NULL;
    }

}

//
// NonDelegatingQueryInterface
//
STDMETHODIMP CStilVidStream::NonDelegatingQueryInterface(
    REFIID riid,
    void ** ppv
    )
{
    if (riid == IID_IGenVideo) {			
        return GetInterface((IGenVideo *) this, ppv);
    } else if (riid == IID_IDexterSequencer) {			
        return GetInterface((IDexterSequencer *) this, ppv);
    } else if (riid == IID_ISpecifyPropertyPages) {
        return GetInterface((ISpecifyPropertyPages *) this, ppv);
    } else if (IsEqualIID(IID_IMediaSeeking, riid)) {
        return GetInterface((IMediaSeeking *) this, ppv);
    } else {
        return CSourceStream::NonDelegatingQueryInterface(riid, ppv);
    }

}


// overridden NOT to spin when GetBuffer Fails - base class
//
HRESULT CStilVidStream::DoBufferProcessingLoop(void) {

    Command com;

    OnThreadStartPlay();

    do {
	while (!CheckRequest(&com)) {

	    IMediaSample *pSample;

	    HRESULT hr = GetDeliveryBuffer(&pSample,NULL,NULL,0);
	    if (FAILED(hr)) {
		return S_OK;	// !!! Overridden to fix this base class bug
	    }

	    // Virtual function user will override.
	    hr = FillBuffer(pSample);

	    if (hr == S_OK) {
		hr = Deliver(pSample);
                pSample->Release();

                // downstream filter returns S_FALSE if it wants us to
                // stop or an error if it's reporting an error.
                if(hr != S_OK)
                {
                  DbgLog((LOG_TRACE, 2, TEXT("Deliver() returned %08x; stopping"), hr));
                  return S_OK;
                }

	    } else if (hr == S_FALSE) {
                // derived class wants us to stop pushing data
		pSample->Release();
		DeliverEndOfStream();
		return S_OK;
	    } else {
                // derived class encountered an error
                pSample->Release();
		DbgLog((LOG_ERROR, 1, TEXT("Error %08lX from FillBuffer!!!"), hr));
                DeliverEndOfStream();
                m_pFilter->NotifyEvent(EC_ERRORABORT, hr, 0);
                return hr;
	    }

            // all paths release the sample
	}

        // For all commands sent to us there must be a Reply call!

	if (com == CMD_RUN || com == CMD_PAUSE) {
	    Reply(NOERROR);
	} else if (com != CMD_STOP) {
	    Reply((DWORD) E_UNEXPECTED);
	    DbgLog((LOG_ERROR, 1, TEXT("Unexpected command!!!")));
	}
    } while (com != CMD_STOP);

    return S_FALSE;
}

// copy and flip image or just copy. handles in-place flips
//
void CopyWithFlip(BYTE *pbDest, BYTE *pbSrc, AM_MEDIA_TYPE *pmt, bool fFlip)
{
    LONG lHeight = abs(HEADER(pmt->pbFormat)->biHeight);
    LONG lBytesPerLine = DIBWIDTHBYTES(*HEADER(pmt->pbFormat));

    if(pbDest != pbSrc)
    {
        if(fFlip)
        {
            for(LONG iLine = 0; iLine < lHeight; iLine++)
            {
                CopyMemory(pbDest + iLine * lBytesPerLine,
                           pbSrc + (lHeight - 1) * lBytesPerLine - lBytesPerLine * iLine,
                           lBytesPerLine);
            }
        }
        else
        {
            CopyMemory(pbDest, pbSrc, lHeight * lBytesPerLine);
        }
    }
    else if(fFlip)
    {
        // slower in place flip
        //
        // DIB lines start on DWORD boundaries.
        ASSERT(lBytesPerLine % sizeof(DWORD) == 0);

        for(LONG iLine = 0; iLine < lHeight / 2; iLine++)
        {
            DWORD *pdwTop = (DWORD *)(pbDest + iLine * lBytesPerLine);
            DWORD *pdwBot = (DWORD *)(pbSrc + (lHeight - 1 - iLine) * lBytesPerLine);

            for(int iw = 0; (ULONG)iw < lBytesPerLine / sizeof(DWORD); iw++)
            {
                DWORD dwTmp = *pdwTop;
                *pdwTop++ = *pdwBot;
                *pdwBot++ = dwTmp;
            }
        }
    }
}

//
// FillBuffer called by HRESULT CSourceStream::DoBufferProcessingLoop(void) {
//
// Plots a Still video into the supplied video buffer
//
// Give  a start time, a duration, and a frame rate,
// it sends  a certain size (RGB32) Still frames out time stamped appropriately starting
// at the start time.
//
HRESULT CStilVidStream::FillBuffer(IMediaSample *pms)
{
    CAutoLock foo(&m_csFilling);

    ASSERT( m_ppbDstBuf != NULL );
    ASSERT( m_iBufferCnt );

    // !!! Figure out AvgTimePerFrame and set that in the media type?

    // calc the output sample times the SAME WAY FRC DOES, or we'll HANG!
    LONGLONG llOffset = Time2Frame( m_rtNewSeg + m_rtStartTime, m_dOutputFrmRate );

    // calc the output sample's start time
    REFERENCE_TIME rtStart = Frame2Time( llOffset + m_dwOutputSampleCnt, m_dOutputFrmRate );
    rtStart -= m_rtNewSeg;


    // calc the outut sample's stop time
    REFERENCE_TIME rtStop = Frame2Time( llOffset + m_dwOutputSampleCnt + 1, m_dOutputFrmRate );
    rtStop -= m_rtNewSeg;

    // animated GIFs have variable frame rate and need special code to
    // figure out the time stamps
    if (m_pGenStilVid->m_bFileType == STILLVID_FILETYPE_GIF &&
			m_pGenStilVid->m_pList != m_pGenStilVid->m_pList->next){
	// gif delay is in 1/100th seconds
        REFERENCE_TIME rtDur = m_pGenStilVid->m_pList->delayTime * GIF_UNIT;
	ASSERT(rtDur > 0);	// should have been fixed up already
	if (m_dwOutputSampleCnt > 0) {
	    rtStart = m_rtLastStop;
	} else {
	    rtStart = 0;
	}
	rtStop = rtStart + rtDur;
	m_rtLastStop = rtStop;
    }

    // seeking from (n,n) should at least send SOMETHING, or the sample grabber
    // won't work (it seeks us to (0,0)
    if ( rtStart > m_rtStartTime + m_rtDuration ||
		(rtStart == m_rtStartTime + m_rtDuration && m_rtDuration > 0))
    {
        DbgLog((LOG_TRACE,3,TEXT("Still: All done")));
        return S_FALSE;
    }

    BYTE *pData;

    //pms: output media sample pointer
    pms->GetPointer(&pData);	    //get pointer to output buffer


    USES_CONVERSION;

    if (m_pGenStilVid->m_fAllowSeq && m_pGenStilVid->m_lpszDIBFileTemplate)
    {
	HRESULT hr = 0;
	
	// sequence
	TCHAR		ach[_MAX_PATH];
	DbgLog((LOG_TRACE, 2, TEXT("!!! %s\n"), m_pGenStilVid->m_lpszDIBFileTemplate));
	wsprintf(ach, m_pGenStilVid->m_lpszDIBFileTemplate,
		(int)(llOffset + m_dwOutputSampleCnt + m_pGenStilVid->m_dwFirstFile));
        WCHAR * wach = T2W( ach );

	if(m_pGenStilVid->m_bFileType ==STILLVID_FILETYPE_DIB)
	{
	    HANDLE hFile = CreateFile(ach,		//file name	
			      GENERIC_READ,		//DesiredAccess
                              FILE_SHARE_READ,		//dwShareMode
                              NULL,			//SecurityAttrib
                              OPEN_EXISTING,		//dwCreationDisposition
                              0,			//dwFlagsAndAttributes
                              NULL);			//hTemplateFile

	    if ( hFile == INVALID_HANDLE_VALUE) {

		DbgLog((LOG_TRACE, 2, TEXT("Could not open %s\n"), ach));
		// VITALLY IMPORTANT to return S_FALSE, which means stop pushing
		// This MAY NOT BE AN ERROR, if we've played all we need to play
		// signalling an error would grind dexter to a halt needlessly
		return S_FALSE;
	    }

	    //DIB
	    CMediaType TmpMt;
	    hr= OpenDIBFile (hFile, NULL, &TmpMt, pData );

	    CloseHandle(hFile);

	    if(hr!=NOERROR)
	     return S_FALSE;

            // sign flipped?
            if(HEADER(TmpMt.pbFormat)->biHeight == -HEADER(m_mt.pbFormat)->biHeight) {
                // flip image (in-place)
                CopyWithFlip(pData, pData, &TmpMt, true);
            }

	    //we only stream media samples which have same mt
	    if(TmpMt!=m_pGenStilVid->m_mt) {
		// oops, one of these things is not like the others...
                VARIANT v;
                VariantInit(&v);

                v.vt = VT_BSTR;
                v.bstrVal = SysAllocString( wach );

		hr = E_INVALIDARG;

                if( !v.bstrVal )
                {
                    return E_OUTOFMEMORY;
                }

		m_pGenStilVid->_GenerateError(2, DEX_IDS_DIBSEQ_NOTALLSAME,
							hr, &v);

                SysFreeString( v.bstrVal );
		return S_FALSE;
	    }
	}
	else if(m_pGenStilVid->m_bFileType ==STILLVID_FILETYPE_TGA)
	{
	    HANDLE hFile = CreateFile(ach,		//file name	
			      GENERIC_READ,		//DesiredAccess
                              FILE_SHARE_READ,		//dwShareMode
                               NULL,			//SecurityAttrib
                              OPEN_EXISTING,		//dwCreationDisposition
                              0,			//dwFlagsAndAttributes
                              NULL);			//hTemplateFile

	    if ( hFile == INVALID_HANDLE_VALUE) {

                DbgLog((LOG_TRACE, 2, TEXT("Could not open %s\n"), ach));
		// VITALLY IMPORTANT to return S_FALSE, which means stop pushing
		// This MAY NOT BE AN ERROR, if we've played all we need to play
		// signalling an error would grind dexter to a halt needlessly
		return S_FALSE;
	    }

	    //DIB
	    CMediaType TmpMt;
	    hr= OpenTGAFile (hFile, NULL, &TmpMt, pData );

            // sign flipped?
            if(HEADER(TmpMt.pbFormat)->biHeight == -HEADER(m_mt.pbFormat)->biHeight) {
                // flip image (in-place)
                CopyWithFlip(pData, pData, &TmpMt, true);
            }

	    CloseHandle(hFile);

	    if(hr!=NOERROR)
	     return S_FALSE;

	    //we only stream media samples which have same mt
	    if(TmpMt!=m_pGenStilVid->m_mt) {
		// oops, one of these things is not like the others...
                VARIANT v;
                VariantInit(&v);

                v.vt = VT_BSTR;
                v.bstrVal = SysAllocString( wach );

		hr = E_INVALIDARG;

                if( !v.bstrVal )
                {
                    return E_OUTOFMEMORY;
                }

		m_pGenStilVid->_GenerateError(2, DEX_IDS_DIBSEQ_NOTALLSAME,
							hr, &v);

                SysFreeString( v.bstrVal );
		return S_FALSE;
	    }
	}
	else
	{

        CMediaType TmpMt;
        hr = LoadJPEGImagePreAllocated( ach, &TmpMt, &m_pGenStilVid->m_mt, pData);

        if (hr == E_ABORT)
        {
            // This means that the mediatype has changed since the last jpeg
            VARIANT v;
            VariantInit(&v);
            
            v.vt = VT_BSTR;
            v.bstrVal = SysAllocString( wach );
            
            hr = E_INVALIDARG;
            
            if( !v.bstrVal )
            {
                return E_OUTOFMEMORY;
            }
            
            m_pGenStilVid->_GenerateError(2, DEX_IDS_DIBSEQ_NOTALLSAME,
                    hr, &v);
            SysFreeString( v.bstrVal );
            return S_FALSE;
        }

        if (FAILED(hr))
        {
            return hr;
        }
    }
	}
    
    else
    {
        if(m_pGenStilVid->m_bFileType==STILLVID_FILETYPE_GIF)
        {
	    // !!! avoid this copying

            bool fFlip = false;
            if(HEADER(m_pGenStilVid->m_mt.pbFormat)->biHeight == -HEADER(m_mt.pbFormat)->biHeight) {
                fFlip = true;
            }

            CopyWithFlip(pData, m_pGenStilVid->m_pList->pbImage, &m_mt, fFlip);

	    // circular...
            m_pGenStilVid->m_pList = m_pGenStilVid->m_pList->next;
        }
        else
        {
            if( m_bZeroBufCnt < m_iBufferCnt  )	
            {
                //
                // there is no guarenty that the buffer we just get is not initilized before
                //
                int	i	= 0;
                BOOL	bInit	= FALSE;
                while ( i <  m_bZeroBufCnt )
                {
                    if( m_ppbDstBuf[ i++ ] == pData)
                    {
                        bInit	= TRUE;
                        break;
                    }
                }

                if( bInit   == FALSE )
                {
                    bool fFlip = false;
                    if(HEADER(m_pGenStilVid->m_mt.pbFormat)->biHeight == -HEADER(m_mt.pbFormat)->biHeight) {
                        fFlip = true;
                    }
                    CopyWithFlip(pData, m_pGenStilVid->m_pbData, &m_mt, fFlip);
                    m_ppbDstBuf[i] = pData;
                    m_bZeroBufCnt++;
                }
            }
        }
    }


    DbgLog( ( LOG_TRACE, 2, TEXT("StillVid::FillBuffer, sample = %ld to %ld"), long( rtStart/ 10000 ), long( rtStop / 10000 ) ) );

    pms->SetTime( &rtStart,&rtStop);

    m_dwOutputSampleCnt++;
    pms->SetActualDataLength(m_lDataLen);
    pms->SetSyncPoint(TRUE);
    return NOERROR;

} // FillBuffer


//
// GetMediaType
//
// return a 32bit mediatype
//
HRESULT CStilVidStream::GetMediaType(int iPosition, CMediaType *pmt)
{
    CAutoLock cAutoLock(m_pFilter->pStateLock());

    if(iPosition == 0)
    {
        //Decided by CGenStilVid reads the input file
        m_pGenStilVid->get_CurrentMT(pmt);
    }
    else if(iPosition == 1)
    {
        //Decided by CGenStilVid reads the input file
        m_pGenStilVid->get_CurrentMT(pmt);

        // we can flip the image.
        HEADER(pmt->Format())->biHeight = - HEADER(pmt->Format())->biHeight;
    }
    else
    {
        return VFW_S_NO_MORE_ITEMS;
    }

    return NOERROR;

} // GetMediaType


// set media type
//
HRESULT CStilVidStream::SetMediaType(const CMediaType* pmt)
{
    HRESULT hr;
    DbgLog((LOG_TRACE,2,TEXT("SetMediaType %x %dbit %dx%d"),
		HEADER(pmt->Format())->biCompression,
		HEADER(pmt->Format())->biBitCount,
		HEADER(pmt->Format())->biWidth,
		HEADER(pmt->Format())->biHeight));

    //Decided by CGenStilVid reads the input file
    CMediaType mt;
    m_pGenStilVid->get_CurrentMT(&mt);


    hr = CheckMediaType(pmt);
    if(SUCCEEDED(hr)) {
        hr =  CSourceStream::SetMediaType(pmt);
    }
    return hr;
}

//
// CheckMediaType
//
// We accept mediatype =vids, subtype =MEDIASUBTYPE_ARGB32
// Returns E_INVALIDARG if the mediatype is not acceptable
//
HRESULT CStilVidStream::CheckMediaType(const CMediaType *pMediaType)
{
    CAutoLock cAutoLock(m_pFilter->pStateLock());

    //Decided by CGenStilVid reads the input file
    CMediaType mt;
    m_pGenStilVid->get_CurrentMT(&mt);

    if ( mt != *pMediaType)
    {
        // we can flip
        HEADER(mt.Format())->biHeight = - HEADER(mt.Format())->biHeight;
        if ( mt != *pMediaType) {
            return VFW_E_TYPE_NOT_ACCEPTED;
        }
    }

    return S_OK;  // This format is acceptable.

} // CheckMediaType


//
// Since the Original image will be only coped once,  it does not matter who's buffer to use
//
HRESULT CStilVidStream::DecideAllocator(IMemInputPin *pPin, IMemAllocator **ppAlloc)
{
    HRESULT hr = NOERROR;
    *ppAlloc = NULL;

    // get downstream prop request
    // the derived class may modify this in DecideBufferSize, but
    // we assume that he will consistently modify it the same way,
    // so we only get it once
    ALLOCATOR_PROPERTIES prop;
    ZeroMemory(&prop, sizeof(prop));

    // whatever he returns, we assume prop is either all zeros
    // or he has filled it out.
    pPin->GetAllocatorRequirements(&prop);

    // if he doesn't care about alignment, then set it to 1
    if (prop.cbAlign == 0) {
        prop.cbAlign = 1;
    }

    /* Try the allocator provided by the input pin */

    hr = pPin->GetAllocator(ppAlloc);
    if (SUCCEEDED(hr)) {

        hr = DecideBufferSize(*ppAlloc, &prop);
        if (SUCCEEDED(hr)) {
	    // !!! OVERRIDDEN to say Read Only
            hr = pPin->NotifyAllocator(*ppAlloc, TRUE);
            if (SUCCEEDED(hr)) {
                return NOERROR;
            }
        }
    }

    /* If the GetAllocator failed we may not have an interface */

    if (*ppAlloc) {
        (*ppAlloc)->Release();
        *ppAlloc = NULL;
    }

    /* Try the output pin's allocator by the same method */

    hr = InitAllocator(ppAlloc);
    if (SUCCEEDED(hr)) {

        // note - the properties passed here are in the same
        // structure as above and may have been modified by
        // the previous call to DecideBufferSize
        hr = DecideBufferSize(*ppAlloc, &prop);
        if (SUCCEEDED(hr)) {
	    // !!! OVERRIDDEN to say Read Only
            hr = pPin->NotifyAllocator(*ppAlloc, TRUE);
            if (SUCCEEDED(hr)) {
                return NOERROR;
            }
        }
    }

    /* Likewise we may not have an interface to release */

    if (*ppAlloc) {
        (*ppAlloc)->Release();
        *ppAlloc = NULL;
    }
    return hr;
}

//
// DecideBufferSize
//
// This will always be called after the format has been sucessfully
// negotiated. So we have a look at m_mt to see what size image we agreed.
// Then we can ask for buffers of the correct size to contain them.
//
HRESULT CStilVidStream::DecideBufferSize(IMemAllocator *pAlloc,ALLOCATOR_PROPERTIES *pProperties)
{
    CAutoLock cAutoLock(m_pFilter->pStateLock());

    ASSERT(pAlloc);
    ASSERT(pProperties);
    HRESULT hr = NOERROR;

    VIDEOINFO *pvi = (VIDEOINFO *) m_mt.Format();

    if (pProperties->cBuffers < MAXBUFFERCNT)
        pProperties->cBuffers = MAXBUFFERCNT;   //only one read-only buffer
    if (pProperties->cbBuffer < (long)DIBSIZE(pvi->bmiHeader))
        pProperties->cbBuffer = DIBSIZE(pvi->bmiHeader);
    if (pProperties->cbAlign == 0)
        pProperties->cbAlign = 1;


    // Ask the allocator to reserve us some sample memory, NOTE the function
    // can succeed (that is return NOERROR) but still not have allocated the
    // memory that we requested, so we must check we got whatever we wanted

    ALLOCATOR_PROPERTIES Actual;
    hr = pAlloc->SetProperties(pProperties,&Actual);
    if (FAILED(hr)) {
        return hr;
    }

    // Is this allocator unsuitable

    if (Actual.cbBuffer < (long)DIBSIZE(pvi->bmiHeader)) {
        return E_FAIL;
    }

    //because I am not insisting my own buffer, I may get more than MAXBUFFERCNT buffers.
    m_iBufferCnt =Actual.cBuffers; //how many buffer need to be set to 0

    return NOERROR;

} // DecideBufferSize



//
// OnThreadCreate
//
//
HRESULT CStilVidStream::OnThreadCreate()
{
    // we have to have at least MAXBUFFERCNT buffer
    ASSERT(m_iBufferCnt >= MAXBUFFERCNT);

    //output frame cnt
    m_dwOutputSampleCnt	    =0;

    //how many buffer is already set to 0.
    m_bZeroBufCnt	    =0;

    // actual output buffer's data size
    VIDEOINFO *pvi = (VIDEOINFO *) m_mt.Format();
    m_lDataLen = DIBSIZE(pvi->bmiHeader);

    // will be used to zero the Dst buffers
    delete [] m_ppbDstBuf;
    m_ppbDstBuf = new BYTE *[ m_iBufferCnt ];   //NULL;
    if( !m_ppbDstBuf )
    {
        return E_OUTOFMEMORY;
    }

    for (int i=0; i<m_iBufferCnt; i++)
	m_ppbDstBuf[i]=NULL;

    // don't reset m_rtNewSeg!  We might have seeked while stopped

    // now round m_rtStartTime to be on a frame boundary!
    LONGLONG llOffset = Time2Frame( m_rtStartTime, m_dOutputFrmRate );
    m_rtStartTime = Frame2Time( llOffset, m_dOutputFrmRate );


    return NOERROR;

} // OnThreadCreate


//
// Notify
//
//
STDMETHODIMP CStilVidStream::Notify(IBaseFilter * pSender, Quality q)
{
    //Even I am later, I do not care. I still send my time frame as nothing happened.
    return NOERROR;

} // Notify

//
// GetPages
//
// Returns the clsid's of the property pages we support
//
STDMETHODIMP CStilVidStream::GetPages(CAUUID *pPages)
{
    pPages->cElems = 1;
    pPages->pElems = (GUID *) CoTaskMemAlloc(sizeof(GUID));
    if (pPages->pElems == NULL)
    {
        return E_OUTOFMEMORY;
    }
    *(pPages->pElems) = CLSID_GenStilPropertiesPage;
    return NOERROR;

} // GetPages


//
// IDexterSequencer
//


STDMETHODIMP CStilVidStream::get_OutputFrmRate( double *dpFrmRate )
{
    CAutoLock cAutolock(m_pFilter->pStateLock());

    CheckPointer(dpFrmRate,E_POINTER);

    *dpFrmRate = m_dOutputFrmRate;

    return NOERROR;

} // get_OutputFrmRate


//
// Frame rate can be changed as long as the filter is stopped.
//
STDMETHODIMP CStilVidStream::put_OutputFrmRate( double dFrmRate )
{
    CAutoLock cAutolock(m_pFilter->pStateLock());
    //can not change property if our filter is not currently stopped
    if(!IsStopped() )
      return VFW_E_WRONG_STATE;

    // don't blow up with 0 fps, but don't allow dib sequences
    if (dFrmRate == 0.0) {
        m_dOutputFrmRate = 0.01;	// ???
	m_pGenStilVid->m_fAllowSeq = FALSE;
    } else {
        m_dOutputFrmRate = dFrmRate;
	m_pGenStilVid->m_fAllowSeq = TRUE;
    }

    return NOERROR;

} // put_OutputFrmRate

STDMETHODIMP CStilVidStream::get_MediaType( AM_MEDIA_TYPE *pmt )
{
    CAutoLock cAutolock(m_pFilter->pStateLock());
    CheckPointer(pmt,E_POINTER);

    *pmt=m_mt;   //return current media type

    return E_NOTIMPL;

}

//
// size can be changed only the output pin is not connected yet.
//
STDMETHODIMP CStilVidStream::put_MediaType( const AM_MEDIA_TYPE *pmt )
{
    CAutoLock cAutolock(m_pFilter->pStateLock());
    CheckPointer(pmt,E_POINTER);

    if ( IsConnected() )
	return VFW_E_ALREADY_CONNECTED;

    // only useful when ImportSrcBuffer() is called.
    // If importSrcBuffer() is not called, the load() will reset m_mt
    m_pGenStilVid->put_CurrentMT(*pmt);


    return NOERROR;

}

// !!! We only support 1 start/stop/skew right now

//
STDMETHODIMP CStilVidStream::GetStartStopSkewCount(int *piCount)
{
    CheckPointer(piCount, E_POINTER);
    *piCount = 1;
    return S_OK;
}


STDMETHODIMP CStilVidStream::GetStartStopSkew(REFERENCE_TIME *prtStart, REFERENCE_TIME *prtStop, REFERENCE_TIME *prtSkew, double *pdRate )
{
    CAutoLock cAutolock(m_pFilter->pStateLock());
    CheckPointer(prtStart,E_POINTER);
    CheckPointer(prtStop,E_POINTER);
    CheckPointer(prtSkew,E_POINTER);
    CheckPointer(pdRate,E_POINTER);

    //can not change starttime if our filter is not currently stopped
    if(!IsStopped() )
	return VFW_E_WRONG_STATE;

    *prtStart= m_rtStartTime;
    *prtStop= m_rtStartTime + m_rtDuration;
    *prtSkew= 0;
    *pdRate = 1.0;
    return NOERROR;

}

//
// Start/Stop can be changed as long as the filter is stopped.
//
STDMETHODIMP CStilVidStream::AddStartStopSkew(REFERENCE_TIME rtStart, REFERENCE_TIME rtStop, REFERENCE_TIME rtSkew, double dRate )
{

    if (dRate != 1.0)
	return E_INVALIDARG;

    CAutoLock cAutolock(m_pFilter->pStateLock());
    //can not change starttime if our filter is not currently stopped
    if(!IsStopped() )
	return VFW_E_WRONG_STATE;

    m_rtStartTime= rtStart;
    m_rtDuration= rtStop - rtStart;
    return NOERROR;

}


//
STDMETHODIMP CStilVidStream::ClearStartStopSkew()
{
    return S_OK;
}


// --- IMediaSeeking methods ----------

STDMETHODIMP CStilVidStream::GetCapabilities(DWORD * pCaps)
{
    CheckPointer(pCaps,E_POINTER);

    // we always know the current position
    *pCaps =     AM_SEEKING_CanSeekAbsolute
		   | AM_SEEKING_CanSeekForwards
		   | AM_SEEKING_CanSeekBackwards
		   | AM_SEEKING_CanGetCurrentPos
		   | AM_SEEKING_CanGetStopPos
		   | AM_SEEKING_CanGetDuration;
		   //| AM_SEEKING_CanDoSegments
		   //| AM_SEEKING_Source;	  //has to flush
    return S_OK;
}


STDMETHODIMP CStilVidStream::CheckCapabilities(DWORD * pCaps)
{
    CheckPointer(pCaps,E_POINTER);

    DWORD dwMask = 0;
    GetCapabilities(&dwMask);
    *pCaps &= dwMask;

    return S_OK;
}


STDMETHODIMP CStilVidStream::IsFormatSupported(const GUID * pFormat)
{
    CheckPointer(pFormat,E_POINTER);
    return (*pFormat == TIME_FORMAT_MEDIA_TIME) ? S_OK : S_FALSE;
}

STDMETHODIMP CStilVidStream::QueryPreferredFormat(GUID *pFormat)
{
    CheckPointer(pFormat,E_POINTER);
    *pFormat = TIME_FORMAT_MEDIA_TIME;
    return S_OK;
}

STDMETHODIMP CStilVidStream::SetTimeFormat(const GUID * pFormat)
{
    CheckPointer(pFormat,E_POINTER);

    if(*pFormat == TIME_FORMAT_MEDIA_TIME)
	return S_OK;
    else
	return E_FAIL;
}

STDMETHODIMP CStilVidStream::GetTimeFormat(GUID *pFormat)
{
    CheckPointer(pFormat,E_POINTER);
    *pFormat = TIME_FORMAT_MEDIA_TIME ;
    return S_OK;
}

STDMETHODIMP CStilVidStream::IsUsingTimeFormat(const GUID * pFormat)
{
    CheckPointer(pFormat,E_POINTER);
    if (*pFormat == TIME_FORMAT_MEDIA_TIME)
	return S_OK;
    else
	return S_FALSE;
}

//
//  !!SetPositions!!
//
STDMETHODIMP CStilVidStream::SetPositions( LONGLONG * pCurrent, DWORD CurrentFlags
			  , LONGLONG * pStop, DWORD StopFlags )
{
    // make sure we're not filling a buffer right now
    m_csFilling.Lock();

    HRESULT hr;
    REFERENCE_TIME rtStart, rtStop;

    // we don't do segments ->can't call EC_ENDOFSEGMENT at end of the stream
    if ((CurrentFlags & AM_SEEKING_Segment) ||
				(StopFlags & AM_SEEKING_Segment)) {
    	DbgLog((LOG_TRACE,1,TEXT("Still: ERROR-Seek used EC_ENDOFSEGMENT!")));
        m_csFilling.Unlock();
	return E_INVALIDARG;
    }

    // default to current values unless this seek changes them
    GetCurrentPosition(&rtStart);
    GetStopPosition(&rtStop);

    // figure out where we're seeking to
    DWORD dwFlags = (CurrentFlags & AM_SEEKING_PositioningBitsMask);
    if (dwFlags == AM_SEEKING_AbsolutePositioning) {
	CheckPointer(pCurrent, E_POINTER);
	rtStart = *pCurrent;
    } else if (dwFlags == AM_SEEKING_RelativePositioning) {
	CheckPointer(pCurrent, E_POINTER);
	hr = GetCurrentPosition(&rtStart);
	rtStart += *pCurrent;
    } else if (dwFlags) {
    	DbgLog((LOG_TRACE,1,TEXT("Switch::Invalid Current Seek flags")));
        m_csFilling.Unlock();
	return E_INVALIDARG;
    }

    dwFlags = (StopFlags & AM_SEEKING_PositioningBitsMask);
    if (dwFlags == AM_SEEKING_AbsolutePositioning) {
	CheckPointer(pStop, E_POINTER);
	rtStop = *pStop;
    } else if (dwFlags == AM_SEEKING_RelativePositioning) {
	CheckPointer(pStop, E_POINTER);
	hr = GetStopPosition(&rtStop);
	rtStop += *pStop;
    } else if (dwFlags == AM_SEEKING_IncrementalPositioning) {
	CheckPointer(pStop, E_POINTER);
	hr = GetCurrentPosition(&rtStop);
	rtStop += *pStop;
    }

    DbgLog((LOG_TRACE,3,TEXT("STILL:  Start=%d Stop=%d"),
			(int)(rtStart / 10000), (int)(rtStop / 10000)));

    // flush first, so that our thread won't be blocked delivering
    DeliverBeginFlush();

    // Unlock/Stop so that our thread can wake up and stop without hanging
    m_csFilling.Unlock();
    Stop();

    // now fix the new values
    // now do the actual seek - rounding the start time to a frame boundary
    LONGLONG llOffset = Time2Frame( rtStart, m_dOutputFrmRate );
    m_rtStartTime = Frame2Time( llOffset, m_dOutputFrmRate );

    // for an animated gif, there is a variable frame rate, and m_dOutputFrmRate
    // is nonsense, so we need to calculate where the seek was
    if (m_pGenStilVid->m_bFileType == STILLVID_FILETYPE_GIF &&
	    m_pGenStilVid->m_pListHead != m_pGenStilVid->m_pListHead->next) {
	m_rtStartTime = rtStart / m_pGenStilVid->m_rtGIFTotal;	
	REFERENCE_TIME rtOff = rtStart % m_pGenStilVid->m_rtGIFTotal;
	REFERENCE_TIME rtGIF = 0;
	m_pGenStilVid->m_pList = m_pGenStilVid->m_pListHead;
	do {
	    if (rtGIF + m_pGenStilVid->m_pList->delayTime * GIF_UNIT > rtOff) {
		break;
	    }
	    rtGIF += m_pGenStilVid->m_pList->delayTime * GIF_UNIT;
	    m_pGenStilVid->m_pList = m_pGenStilVid->m_pList->next;
	    ASSERT(m_pGenStilVid->m_pList != m_pGenStilVid->m_pListHead);
	
	} while (m_pGenStilVid->m_pList != m_pGenStilVid->m_pListHead);
	m_rtStartTime *= m_pGenStilVid->m_rtGIFTotal;
	m_rtStartTime += rtGIF;

	// Now m_rtStartTime and m_pList are set to behave properly post seek
        DbgLog((LOG_TRACE,2,TEXT("Seeked %dms into GIF cycle of %d"),
	    (int)(rtOff / 10000), (int)(m_pGenStilVid->m_rtGIFTotal / 10000)));
        DbgLog((LOG_TRACE,2,TEXT("NewSeg will be %d"),
					(int)(m_rtStartTime / 10000)));
    }

    m_rtDuration = rtStop - m_rtStartTime;

    // now finish flushing
    DeliverEndFlush();

    DeliverNewSegment(m_rtStartTime, rtStop, 1.0);
    m_rtNewSeg = m_rtStartTime;

    // now make the time stamps 0 based
    m_rtStartTime = 0;

    // reset same stuff we reset when we start streaming
    m_dwOutputSampleCnt = 0;
    //m_bZeroBufCnt = 0;

    // now start the thread up again
    Pause();

    DbgLog((LOG_TRACE,3,TEXT("Completed STILL seek  dur=%d"),
				(int)(m_rtDuration / 10000)));

    return S_OK;
}

STDMETHODIMP CStilVidStream::GetPositions(LONGLONG *pCurrent, LONGLONG * pStop)
{
    CheckPointer(pCurrent, E_POINTER);
    CheckPointer(pStop, E_POINTER);
    GetCurrentPosition(pCurrent);
    GetStopPosition(pStop);
    return S_OK;
}

//
// !! GetCurrentPosition !!
//
STDMETHODIMP
CStilVidStream::GetCurrentPosition(LONGLONG *pCurrent)
{
    CheckPointer(pCurrent, E_POINTER);
    *pCurrent = m_rtNewSeg + m_rtStartTime +
			Frame2Time(m_dwOutputSampleCnt, m_dOutputFrmRate);
    return S_OK;
}

//
// !! GetStopPostion !!
//
STDMETHODIMP CStilVidStream::GetStopPosition(LONGLONG *pStop)
{
    CheckPointer(pStop, E_POINTER);
    *pStop = m_rtNewSeg + m_rtStartTime + m_rtDuration;
    return S_OK;
}

STDMETHODIMP
CStilVidStream::GetAvailable( LONGLONG *pEarliest, LONGLONG *pLatest )
{
    CheckPointer(pEarliest, E_POINTER);
    CheckPointer(pLatest, E_POINTER);
    *pEarliest = 0;
    *pLatest = MAX_TIME;
    return S_OK;
}

//*x*
// if it is DIB sequence, figure out the
//*X*
STDMETHODIMP
CStilVidStream::GetDuration( LONGLONG *pDuration )
{
    CheckPointer(pDuration, E_POINTER);

    // if we are playing an animated GIF, give the app the actual length
    // !!! We still play it forever in a loop, but just report the length
    // to be nice
    if (m_pGenStilVid->m_bFileType == STILLVID_FILETYPE_GIF &&
		m_pGenStilVid->m_pList != m_pGenStilVid->m_pList->next) {
        *pDuration = m_pGenStilVid->m_rtGIFTotal;
    // for a dib sequence, give infinity, or whatever we were last seeked to
    } else if (m_pGenStilVid->m_fAllowSeq && m_pGenStilVid->m_lpszDIBFileTemplate) {
        *pDuration = m_rtDuration;
    // for a single image, give 0?
    } else {
        *pDuration = 0;
    }
    return S_OK;
}

STDMETHODIMP
CStilVidStream::GetRate( double *pdRate )
{
    CheckPointer(pdRate, E_POINTER);
    *pdRate = 1.0;
    return S_OK;
}

STDMETHODIMP
CStilVidStream::SetRate( double dRate )
{
    // yeah, whatever, the FRC doesn't know we're a still, so it will set
    // funky rates
    return S_OK;
}

// util function for read DIB sequece

/*	-	-	-	-	-	-	-	-	*/

//
// This function takes the name of the first file in a DIB sequence, and
// returns a printf() specifier which can be used to create the names in
// the sequence, along with minimum and maximum values that can be used.
//
//
// Examples:
//  lpszFileName = "FOO0047.DIB"
//	 -> lpszTemplate = "FOO%04d.DIB", dwMaxValue = 9999, return = 47
//
//  lpszFileName = "TEST01.DIB"
//	 -> lpszTemplate = "TEST%01d.DIB", dwMaxValue = 9, return = 1
//
//  lpszFileName = "TEST1.DIB"
//	 -> lpszTemplate = "TEST%d.DIB", dwMaxValue = 9999, return = 1
//
//  lpszFileName = "SINGLE.DIB"
//	 -> lpszTemplate = "SINGLE.DIB", dwMaxValue = 0, return = 0
//
static DWORD dseqParseFileName(	LPTSTR lpszFileName,	    //file name
				LPTSTR lpszTemplate,	    //
				DWORD FAR * lpdwMaxValue)
{

    TCHAR	aTchar[_MAX_PATH];
    DWORD	dwFirst;
    WORD	wFieldWidth;
    DWORD	dwMult;
    BOOL	fLeadingZero = FALSE;


    LPTSTR	lp;
    LPTSTR	lp2;
    LPTSTR	lpExt;

    /* Find end of string */
    lp2 = lpszFileName;
    lp = aTchar;

    while (*lp2)
    {
	*lp++ = *lp2++;
    }

    *lp = TEXT('\0') ;

    /* Make lp2 point at last character of base filename (w/o extension) */
    /* Make lpExt point at the extension (without the dot) */
    for (lp2 = lp; *lp2 != TEXT('.'); ) {
	lpExt = lp2;
	if ((lp2 == aTchar) || ( *lp2 == TEXT('\\'))
				|| (*lp2 == TEXT(':')) || (*lp2 ==TEXT('!'))) {
	    /* There is no extension */
	    lp2 = lp;
	    lpExt = lp;
	    break;
	}
	lp2=CharPrev(aTchar,lp2);
    }

    lp2=CharPrev(aTchar,lp2);

    // Count the number of numeric characters here....
    dwFirst = 0;
    wFieldWidth = 0;
    dwMult = 1;
    while (lp2 >= aTchar && (*lp2 >= TEXT('0')) && (*lp2 <= TEXT('9'))) {
	fLeadingZero = (*lp2 == TEXT('0'));
	dwFirst += dwMult * (*lp2 - TEXT('0'));
	dwMult *= 10;
	wFieldWidth++;
	lp2=CharPrev(aTchar, lp2);
    }

    *lpdwMaxValue = dwMult - 1;

    lp2=CharNext(lp2);
    *lp2 = TEXT('\0');

    // Make the format specifier....
    if (wFieldWidth) {
	if (fLeadingZero) {
	    wsprintf(lpszTemplate,TEXT("%s%%0%uu.%s"),
			      aTchar, (int)wFieldWidth,lpExt);
	} else {
	    wsprintf(lpszTemplate,TEXT("%s%%u.%s"),
			     aTchar,lpExt);
	    *lpdwMaxValue = 999999L;
	    // !!! This should really be based on the number of
	    // characters left after the base name....
	}
    } else
	wsprintf(lpszTemplate,TEXT("%s.%s"),
			 aTchar, lpExt);
	
    DbgLog((LOG_TRACE,3,TEXT("First = %u, Width = %u, Template = '%s'"),
			(int)dwFirst, (int)wFieldWidth, lpszTemplate));

    return dwFirst;
}

//
// count how many DIB sequence file
static DWORD dseqFileNumber( LPTSTR lpszTemplate, DWORD dwFirstFile, DWORD dwMaxDIBFileCnt)
{
    //DIB sequence, count how many files are present
    TCHAR		ach[_MAX_PATH];
    DWORD		dwFrame;
	
    for (dwFrame = 0; TRUE; dwFrame++) {
	if (dwFrame > dwMaxDIBFileCnt)
	    break;

	wsprintf(ach,lpszTemplate, dwFrame + dwFirstFile);

	HANDLE hFile = CreateFile(ach,		//file name	
				GENERIC_READ,		//DesiredAccess
                              FILE_SHARE_READ,		//dwShareMode
                              NULL,			//SecurityAttrib
                              OPEN_EXISTING,		//dwCreationDisposition
                              0,			//dwFlagsAndAttributes
                              NULL);			//hTemplateFile

	if ( hFile == INVALID_HANDLE_VALUE) {
	    DbgLog((LOG_TRACE, 2, TEXT("Could not open %s\n"), ach));
	    break;
	}
	CloseHandle(hFile);
    }
    return dwFrame;
}
=== C:/Users/treeman/Desktop/windows nt source code\Source\Win2K3\NT\multimedia\dshow\filterus\dexter\stillvid\stilprop.h ===
//@@@@AUTOBLOCK+============================================================;
//
//  THIS CODE AND INFORMATION IS PROVIDED "AS IS" WITHOUT WARRANTY OF ANY
//  KIND, EITHER EXPRESSED OR IMPLIED, INCLUDING BUT NOT LIMITED TO THE
//  IMPLIED WARRANTIES OF MERCHANTABILITY AND/OR FITNESS FOR A PARTICULAR
//  PURPOSE.
//
//  File: stilprop.h
//
//  Copyright (c) Microsoft Corporation.  All Rights Reserved.
//
//@@@@AUTOBLOCK-============================================================;

//
// Stilprop.h
//
// {693644B0-6858-11d2-9EEB-006008039E37}
DEFINE_GUID(CLSID_GenStilPropertiesPage, 
0x693644b0, 0x6858, 0x11d2, 0x9e, 0xeb, 0x0, 0x60, 0x8, 0x3, 0x9e, 0x37);


class CGenStilProperties : public CBasePropertyPage
{

public:

    static CUnknown *CreateInstance(LPUNKNOWN lpunk, HRESULT *phr);
         
private:
    INT_PTR OnReceiveMessage(HWND hwnd,UINT uMsg,WPARAM wParam,LPARAM lParam);
    HRESULT OnConnect(IUnknown *pUnknown);
    HRESULT OnDisconnect();
    HRESULT OnActivate();
    HRESULT OnDeactivate();
    HRESULT OnApplyChanges();

    void SetDirty();

    CGenStilProperties(LPUNKNOWN lpunk, HRESULT *phr);


    STDMETHODIMP GetFromDialog();

    BOOL m_bIsInitialized;  // Will be false while we set init values in Dlg
                            // to prevent theDirty flag from being set.

    REFERENCE_TIME	m_rtStartTime;
    REFERENCE_TIME	m_rtDuration;
    double		m_dOutputFrmRate;		// Output frm rate frames/second
    char		m_sFileName[60];		//source file name


    IDexterSequencer	*m_pGenStil;
    IDexterSequencer	*piGenStill(void) { ASSERT(m_pGenStil); return m_pGenStil; }

};
=== C:/Users/treeman/Desktop/windows nt source code\Source\Win2K3\NT\multimedia\dshow\filterus\dexter\switch\inpin.cpp ===
//@@@@AUTOBLOCK+============================================================;
//
//  THIS CODE AND INFORMATION IS PROVIDED "AS IS" WITHOUT WARRANTY OF ANY
//  KIND, EITHER EXPRESSED OR IMPLIED, INCLUDING BUT NOT LIMITED TO THE
//  IMPLIED WARRANTIES OF MERCHANTABILITY AND/OR FITNESS FOR A PARTICULAR
//  PURPOSE.
//
//  File: inpin.cpp
//
//  Copyright (c) Microsoft Corporation.  All Rights Reserved.
//
//@@@@AUTOBLOCK-============================================================;

//depot/private/Lab06_DEV/MultiMedia/dshow/filterus/dexter/switch/inpin.cpp#5 - edit change 27342 (text)
#include <streams.h>
#include <qeditint.h>
#include <qedit.h>
#include "switch.h"
#include "..\util\conv.cxx"
#include "..\util\filfuncs.h"
#include "..\render\dexhelp.h"

const int TRACE_EXTREME = 0;
const int TRACE_HIGHEST = 2;
const int TRACE_MEDIUM = 3;
const int TRACE_LOW = 4;
const int TRACE_LOWEST = 5;

// ================================================================
// CBigSwitchInputPin constructor
// ================================================================

CBigSwitchInputPin::CBigSwitchInputPin(TCHAR *pName,
                           CBigSwitch *pSwitch,
                           HRESULT *phr,
                           LPCWSTR pPinName) :
    CBaseInputPin(pName, pSwitch, pSwitch, phr, pPinName),
    m_pSwitch(pSwitch),
    m_cbBuffer(0),
    m_cBuffers(0),
    m_pAllocator(NULL),
    m_hEventBlock(NULL),
    m_hEventSeek(NULL),
    m_rtBlock(-1),
    m_fEOS(FALSE),
    m_fInNewSegment(FALSE), // in the middle of NewSegment
    m_rtLastDelivered(0),	// last time stamp we delivered
    m_fIsASource(FALSE),	// by default, not a source
    m_fStaleData(FALSE),	// otherwise not init until connected - BAD
    m_pCrankHead(NULL),	    // our connection array
    m_fActive(false)
{
    DbgLog((LOG_TRACE, TRACE_MEDIUM,TEXT("::CBigSwitchInputPin")));
    ASSERT(pSwitch);

    // ! We have to know this already!
    if( pSwitch->IsDynamic( ) )
    {
        SetReconnectWhenActive(TRUE);
    }
}


//
// CBigSwitchInputPin destructor
//
CBigSwitchInputPin::~CBigSwitchInputPin()
{
    DbgLog((LOG_TRACE, TRACE_LOW, TEXT("::~CBigSwitchInputPin")));

    // !!! Reset should have been called by now....
    ASSERT(!m_pCrankHead);

    ASSERT(!m_fActive);         // filter should be stopped when destroyed
}

// overridden to allow cyclic-looking graphs - we say that we aren't actually
// connected to anybody
//
STDMETHODIMP CBigSwitchInputPin::QueryInternalConnections(IPin **apPin, ULONG *nPin)
{
    DbgLog((LOG_TRACE,99,TEXT("CBigSwitchIn::QueryInteralConnections")));
    CheckPointer(nPin, E_POINTER);
    *nPin = 0;
    return S_OK;
}


// !!! what about non-format fields?
//
// CheckMediaType - only allow the type we're supposed to allow
//
HRESULT CBigSwitchInputPin::CheckMediaType(const CMediaType *pmt)
{
    DbgLog((LOG_TRACE, TRACE_LOWEST, TEXT("CBigSwitchIn[%d]::CheckMT"), m_iInpin));

    CAutoLock lock_it(m_pLock);
    CMediaType mtAccept(m_pSwitch->m_mtAccept);

    if (IsEqualGUID(*pmt->Type(), *mtAccept.Type())) {
        if (IsEqualGUID(*pmt->Subtype(), *mtAccept.Subtype())) {
	    if (*pmt->FormatType() == *mtAccept.FormatType()) {
	        if (pmt->FormatLength() >= mtAccept.FormatLength()) {

		    // ! video formats will NOT match exactly
        	    if (IsEqualGUID(*pmt->FormatType(), FORMAT_VideoInfo)) {
			LPBITMAPINFOHEADER lpbi = HEADER((VIDEOINFOHEADER *)
							pmt->Format());
			LPBITMAPINFOHEADER lpbiAccept =HEADER((VIDEOINFOHEADER*)
							mtAccept.Format());
			if ((lpbi->biCompression == lpbiAccept->biCompression)
				&& (lpbi->biBitCount == lpbiAccept->biBitCount))
		    	    return S_OK;
			// colour converter gives 555 as bitfields!
			if (lpbi->biCompression == BI_BITFIELDS &&
				lpbiAccept->biCompression == BI_RGB &&
				lpbi->biBitCount == lpbiAccept->biBitCount &&
				*pmt->Subtype() == MEDIASUBTYPE_RGB555)
			    return S_OK;

		    // will other formats match exactly?
        	    } else {
		        LPBYTE lp1 = pmt->Format();
		        LPBYTE lp2 = mtAccept.Format();
		        if (memcmp(lp1, lp2, mtAccept.FormatLength()) == 0)
		            return S_OK;
		    }
		}
                else
                {
                    DbgLog((LOG_TRACE, TRACE_LOW, TEXT("CBigSwitchInputPin::CheckMediaType, format lengths didn't match")));
                }
	    }
        }
    }
    return VFW_E_INVALIDMEDIATYPE;

} // CheckMediaType


//
// GetMediaType - return the type we accept
//
HRESULT CBigSwitchInputPin::GetMediaType(int iPosition, CMediaType *pMediaType)
{
    if (iPosition != 0)
        return VFW_S_NO_MORE_ITEMS;

    return CopyMediaType(pMediaType, &m_pSwitch->m_mtAccept);

} // GetMediaType



//
// BreakConnect
//
HRESULT CBigSwitchInputPin::BreakConnect()
{
    DbgLog((LOG_TRACE, TRACE_LOW, TEXT("CBigSwitchIn[%d]::BreakConnect"), m_iInpin));

    // Release any allocator that we are holding
    if (m_pAllocator)
    {
        m_pAllocator->Release();
        m_pAllocator = NULL;
    }
    return CBaseInputPin::BreakConnect();
} // BreakConnect

HRESULT CBigSwitchInputPin::Disconnect()
{
    CAutoLock l(m_pLock);
    return DisconnectInternal();
}



// for efficiency, our input pins use their own allocators
//
STDMETHODIMP CBigSwitchInputPin::GetAllocator(IMemAllocator **ppAllocator)
{

    CheckPointer(ppAllocator,E_POINTER);
    ValidateReadWritePtr(ppAllocator,sizeof(IMemAllocator *));
    CAutoLock cObjectLock(m_pLock);

    DbgLog((LOG_TRACE, TRACE_MEDIUM,TEXT("CBigSwitchIn[%d]: GetAllocator"), m_iInpin));

    if (m_pAllocator == NULL) {
	HRESULT hr = S_OK;

	/* Create the new allocator object */

	CBigSwitchInputAllocator *pMemObject = new CBigSwitchInputAllocator(
				NAME("Big switch input allocator"), NULL, &hr);
	if (pMemObject == NULL) {
	    return E_OUTOFMEMORY;
	}

	if (FAILED(hr)) {
	    ASSERT(pMemObject);
	    delete pMemObject;
	    return hr;
	}

        m_pAllocator = pMemObject;

        /*  We AddRef() our own allocator */
        m_pAllocator->AddRef();

	//remember pin using it
	((CBigSwitchInputAllocator *)m_pAllocator)->m_pSwitchPin = this;

        DbgLog((LOG_TRACE, TRACE_MEDIUM,TEXT("Created a FAKE allocator")));
    }
    ASSERT(m_pAllocator != NULL);
    m_pAllocator->AddRef();
    *ppAllocator = m_pAllocator;

    return NOERROR;
}


// Make sure we use the maximum alignment and prefix required by any pin or
// we'll fault.
//
STDMETHODIMP
CBigSwitchInputPin::GetAllocatorRequirements(ALLOCATOR_PROPERTIES*pProps)
{
    CheckPointer(pProps, E_POINTER);
    pProps->cbAlign = m_pSwitch->m_cbAlign;
    pProps->cbPrefix = m_pSwitch->m_cbPrefix;
    pProps->cbBuffer = m_pSwitch->m_cbBuffer;
    return S_OK;
}


//
// NotifyAllocator
//
STDMETHODIMP
CBigSwitchInputPin::NotifyAllocator(IMemAllocator *pAllocator, BOOL bReadOnly)
{
    CAutoLock lock_it(m_pLock);
    IUnknown *p1, *p2;

    DbgLog((LOG_TRACE, TRACE_MEDIUM,TEXT("CBigSwitchIn[%d]: NotifyAllocator"), m_iInpin));

    m_fOwnAllocator = FALSE;
    if (pAllocator->QueryInterface(IID_IUnknown, (void **)&p1) == S_OK) {
        if (m_pAllocator && m_pAllocator->QueryInterface(IID_IUnknown,
						(void **)&p2) == S_OK) {
	    if (p1 == p2)
		m_fOwnAllocator = TRUE;
	    p2->Release();
	}
	p1->Release();
    }

#ifdef DEBUG
    if (m_fOwnAllocator) {
        DbgLog((LOG_TRACE, TRACE_MEDIUM,TEXT("Using our own allocator")));
    } else {
        DbgLog((LOG_ERROR,2,TEXT("Using a FOREIGN allocator")));
    }
#endif

    HRESULT hr = CBaseInputPin::NotifyAllocator(pAllocator, bReadOnly);
    if (SUCCEEDED(hr)) {
	ALLOCATOR_PROPERTIES prop;
	hr = pAllocator->GetProperties(&prop);
	if (SUCCEEDED(hr)) {
	    m_cBuffers = prop.cBuffers;
	    m_cbBuffer = prop.cbBuffer;

	    if (prop.cbAlign < m_pSwitch->m_cbAlign ||
				prop.cbPrefix < m_pSwitch->m_cbPrefix) {
		// ! Nasty filters don't listen to our buffering requirement
		// so failing if cbBuffer is too small would prevent us from
		// connecting
                DbgLog((LOG_ERROR,1,TEXT("Allocator too small!")));
		return E_FAIL;
	    }

	    // update the maximum alignment and prefix needed
	    if (m_pSwitch->m_cbPrefix < prop.cbPrefix)
		m_pSwitch->m_cbPrefix = prop.cbPrefix;
	    if (m_pSwitch->m_cbAlign < prop.cbAlign)
		m_pSwitch->m_cbAlign = prop.cbAlign;
	    if (m_pSwitch->m_cbBuffer < prop.cbBuffer)
		m_pSwitch->m_cbBuffer = prop.cbBuffer;

            DbgLog((LOG_TRACE, TRACE_MEDIUM,TEXT("Allocator is using %d buffers, size %d"),
						prop.cBuffers, prop.cbBuffer));
            DbgLog((LOG_TRACE, TRACE_MEDIUM,TEXT("Prefix %d   Align %d"),
						prop.cbPrefix, prop.cbAlign));
	}
    }

    return hr;

} // NotifyAllocator

// If GetBuffer and Receive times don't match, we'll give a buffer from
// the WRONG ALLOCATOR and hang unless the switch is the allocator for
// downstream
// Luckily, we are the allocator
//
HRESULT CBigSwitchInputAllocator::GetBuffer(IMediaSample **ppBuffer,
                  	REFERENCE_TIME *pStartTime, REFERENCE_TIME *pEndTime,
			DWORD dwFlags)
{
    int nOutpin = -1;
    HRESULT hr = NOERROR;
    BOOL fSecretFlag = FALSE;

    // our Waits have to be protected, so Stop doesn't kill the event on us
    {
        CAutoLock cc(&m_pSwitchPin->m_csReceive);

        if (m_pSwitchPin->m_pSwitch->m_pOutput[0]->IsConnected() == FALSE) {
	    return VFW_E_NOT_CONNECTED;
        }

        // we're flushing... don't go blocking below!  Receive calls the base
        // class receive to catch this, but we have no equivalent
        if (m_pSwitchPin->m_bFlushing) {
	    return E_FAIL;
        }

        DbgLog((LOG_TRACE, TRACE_LOW, TEXT("CBigSwitchIn[%d]::GetBuffer."),
						m_pSwitchPin->m_iInpin));

        // we're in the middle of seeking, and we're supposed to hold all input
        WaitForSingleObject(m_pSwitchPin->m_hEventSeek, INFINITE);

        // we're seeking... don't let FancyStuff we called or we'll crank and mess
        // up the flushing route
        if (m_pSwitchPin->m_pSwitch->m_fSeeking)
	    return E_FAIL;

        // this check needs to happen AFTER the wait for seek event, or a
        // surprise flush and new data will get thrown away
        if (m_pSwitchPin->m_pSwitch->m_fEOS) {
	    return E_FAIL;
        }

        // if we're dealing with compressed data, we may not get time stamps
        // in GetBuffer (we are not frame rate converting)
        BOOL fComp = (m_pSwitchPin->m_pSwitch->m_mtAccept.bTemporalCompression == TRUE);
        if (fComp || 1) {	// we are the allocator for our output pin connections.
	    goto JustGetIt; // No need to do this fancystuff
        }

    }     // release the lock before blocking in GetBuffer, which will hang us

JustGetIt:
    if (nOutpin < 0 || m_pSwitchPin->m_pSwitch->
					m_pOutput[nOutpin]->m_fOwnAllocator) {
        DbgLog((LOG_TRACE, TRACE_LOW, TEXT("CBigSwitchIn[%d]::GetBuffer from us for pin %d"),
					m_pSwitchPin->m_iInpin, nOutpin));
	// For read only, we can't very well use random buffers from our pool
	if (m_pSwitchPin->m_bReadOnly && !fSecretFlag) {
            DbgLog((LOG_TRACE, TRACE_LOW, TEXT("R/O: Can't use POOL")));
             return CMemAllocator::GetBuffer(ppBuffer, pStartTime, pEndTime,
						dwFlags);
	} else {
            while (1) {
                hr = CMemAllocator::GetBuffer(ppBuffer, pStartTime, pEndTime,
						dwFlags | AM_GBF_NOWAIT);
	        if (hr == VFW_E_TIMEOUT) {
                    DbgLog((LOG_TRACE, TRACE_LOW, TEXT("BUSY: Try POOL allocator")));
                    // this special allocator will timeout after 10ms
                    hr = m_pSwitchPin->m_pSwitch->m_pPoolAllocator->GetBuffer(
				    ppBuffer, pStartTime, pEndTime,
                                    dwFlags | AM_GBF_NOWAIT);
                    // give the original buffer another chance
                    if (hr == VFW_E_TIMEOUT) {
                        Sleep(10);
                        DbgLog((LOG_TRACE, TRACE_LOW, TEXT("BUSY: Try private allocator again")));
                        continue;
                    }
                }
                break;
	    }
            return hr;
	}
    } else {
	ASSERT(FALSE);	// should never happen! we'll hang if we skipped calling
			// FancyStuff
        DbgLog((LOG_TRACE, TRACE_LOW, TEXT("CBigSwitchIn[%d]::GetBuffer from downstream of pin %d"),
					m_pSwitchPin->m_iInpin, nOutpin));
        return m_pSwitchPin->m_pSwitch->m_pOutput[nOutpin]->m_pAllocator->
			GetBuffer(ppBuffer, pStartTime, pEndTime, dwFlags);
    }
}


// go unstale
//
HRESULT CBigSwitchInputPin::Unstale()
{
    if (m_fStaleData) {
        m_fStaleData = FALSE;
        m_pSwitch->m_cStaleData--;

        // if nobody else is stale, then this is the last flush to come through
        // and it's FINALLY OK to let data be delivered by all our pins
        // if we do this earlier, somebody will deliver, and some other flush is
        // still coming that will screw up that data that got delivered
        if (m_pSwitch->m_cStaleData == 0) {

            // We might not have sent a NewSeg since our last seek. We were
            // waiting for the last flush for this, too
            if (!m_pSwitch->m_fNewSegSent) {
                DbgLog((LOG_TRACE,TRACE_HIGHEST,TEXT("Switch:Send NewSeg=%dms"),
				(int)(m_pSwitch->m_rtLastSeek / 10000)));
                for (int i = 0; i < m_pSwitch->m_cOutputs; i++) {
	            m_pSwitch->m_pOutput[i]->DeliverNewSegment(
			        m_pSwitch->m_rtLastSeek, m_pSwitch->m_rtStop, 1.0);
	        }
	        m_pSwitch->m_fNewSegSent = TRUE;
            }

	    // MUST COME AFTER NEW SEG delivered, or we'll deliver data before
	    // the new seg!  That would be bad...
            DbgLog((LOG_TRACE,TRACE_MEDIUM,TEXT("NO MORE STALE DATA. Unblock")));
            for (int i = 0; i < m_pSwitch->m_cInputs; i++) {
	        SetEvent(m_pSwitch->m_pInput[i]->m_hEventSeek);
	    }

	}
    }
    return S_OK;
}


//
// BeginFlush
//
HRESULT CBigSwitchInputPin::BeginFlush()
{
    // no no no CAutoLock lock_it(m_pLock);

    // thanks, I gave at the office (a 2 input DXT sent us 2 of these)
    // !!! might hide a real bug?
    if (m_bFlushing)
	return S_OK;

    // sombody is flushing us when stopped.  BAD!  That will screw us up
    // (a dynamic source being created might do this)
    if (!m_fActive) {
        return S_OK;
    }

    DbgLog((LOG_TRACE, TRACE_MEDIUM,TEXT("CBigSwitchIn[%d]:BeginFlush"),
								m_iInpin));

    if (!m_pSwitch->m_fSeeking && !m_fFlushAfterSeek && m_fIsASource) {
	// This flush came NOT inside a seek, and no seek has ever come before
	m_fFlushBeforeSeek = TRUE;
        DbgLog((LOG_TRACE,2,TEXT("Switch::FLUSH BEFORE SEEK!")));
    } else if (m_pSwitch->m_fSeeking) {
	// set by every seek.  The seek generated a flush, therefore, we are
	// NOT actually in the case where flushes don't come till after the seek
	m_fFlushAfterSeek = FALSE;
    }

    // first, make sure receives are failed
    CBaseInputPin::BeginFlush();

    // unblock receive
    SetEvent(m_hEventBlock);

    // only set this if we're being seeked, or we'll unblock when a bogus flush
    // comes from an audio parser pin when the video pin was seeked.  Receive
    // should never be blocked on this unless we're seeking, so this shouldn't
    // be necessary to unblock receive.
    // StaleData means we need to set this event anyway, we were blocked waiting
    // for THIS FLUSH.
    if (m_pSwitch->m_fSeeking || m_fStaleData) {
        SetEvent(m_hEventSeek);
    }

    // We need to flush ALL the outputs because we don't know which pin
    // we need to flush to unblock, (we may have cranked since then)
    // Flush the main output first to avoid hanging.

    // At least we won't flush if this isn't a source pin; that means we're
    // recursing

    if (m_fIsASource) {
	m_pSwitch->m_nLastInpin = -1;
        for (int z=0; z<m_pSwitch->m_cOutputs; z++) {
	    m_pSwitch->m_pOutput[z]->DeliverBeginFlush();
        }
    }

    // now that Receive is unblocked, and can't be entered, wait for it to
    // finish
    CAutoLock cc(&m_csReceive);

    return S_OK;
}


//
// EndFlush
//
HRESULT CBigSwitchInputPin::EndFlush()
{
    // no no no CAutoLock lock_it(m_pLock);

    // thanks, I gave at the office (a 2 input DXT sent us 2 of these)
    // !!! might hide a real bug?
    if (!m_bFlushing)
	return S_OK;

    DbgLog((LOG_TRACE,TRACE_MEDIUM,TEXT("CBigSwitchIn[%d]:EndFlush"),m_iInpin));

    if (m_fIsASource) {
        for (int z=0; z<m_pSwitch->m_cOutputs; z++) {
	    m_pSwitch->m_pOutput[z]->DeliverEndFlush();
        }
    }

    // we're seeking, so every pin is flushing.  Until every other input is
    // flushed and ready, and we know our new current position, hold off all
    // input on this pin (or it will think new arriving data is from before
    // the seek)
    // Also, if we're stale, it's NOT OK to start delivering yet
    // Also, if this is a surprise flush, the push thread is going to start
    // delivering new data before we're ready, so hold it off!
    if (m_pSwitch->m_fSeeking || m_fStaleData || m_fFlushBeforeSeek) {
        DbgLog((LOG_TRACE, TRACE_MEDIUM,TEXT("Block this input until seek is done")));
	ResetEvent(m_hEventSeek);
    }

    // go unstale
    Unstale();

    ResetEvent(m_hEventBlock);

    // reset some stuff so we're ready to get data again
    m_rtBlock = -1;	// we're no longer blocked, or at EOS
    m_fEOS = FALSE;

    // bring this pin up to date to where we're going to start playing from
    if (m_pSwitch->m_fSeeking)
    	m_rtLastDelivered = m_pSwitch->m_rtSeekCurrent;//m_rtCurrent not set yet
    else
    	m_rtLastDelivered = m_pSwitch->m_rtCurrent;

    return CBaseInputPin::EndFlush();
}


//
// NewSegment - we remember the new segment we are given, but the one we
// broadcast is the timeline time we were last seeked to, because that's what
// we'll be sending next
//
HRESULT CBigSwitchInputPin::NewSegment(REFERENCE_TIME tStart,
                                 REFERENCE_TIME tStop, double dRate)
{
    // no no no we'll hang CAutoLock lock_it(m_pLock);

    DbgLog((LOG_TRACE, TRACE_MEDIUM,TEXT("CBigSwitchIn[%d]:NewSegment"), m_iInpin));

    // if this pin has last delivered, and we get a NewSegment, then
    // this is like a discontinuity.  We must notice this, because the
    // compressed switch sends a delta frame with no relation to the
    // previous frame in this situation
    if (m_pSwitch->m_nLastInpin == m_iInpin) {
        DbgLog((LOG_TRACE, TRACE_MEDIUM,TEXT("NewSeg is a DISCONTINUITY")));
        m_pSwitch->m_fDiscon = TRUE;
    }

    // remember the newsegment times we were given so we know the real time
    // of arriving data (it could be different for each input pin)
    HRESULT hr = CBaseInputPin::NewSegment(tStart, tStop, dRate);

    return hr;
}

// just say yes, base class function is SLOW, and could infinite loop
//
HRESULT CBigSwitchInputPin::ReceiveCanBlock()
{
    return S_OK;
}


//
// Receive - send this sample to whoever gets it at this moment
//

// !!! IF Switch isn't using any allocators, we need to COPY THE SAMPLE to
// !!! a buffer we get from downstream!

HRESULT CBigSwitchInputPin::Receive(IMediaSample *pSample)
{
    if (m_pSwitch->m_pOutput[0]->IsConnected() == FALSE) {
	return VFW_E_NOT_CONNECTED;
    }

    CAutoLock lock_it(&m_csReceive);

    // Check that all is well with the base class
    HRESULT hr = NOERROR;

    {

        hr = CBaseInputPin::Receive(pSample);
        if (hr != NOERROR) {
            DbgLog((LOG_ERROR,1,TEXT("CBigSwitchIn[%d]:Receive base class ERROR!"),
                                                                    m_iInpin));
            return hr;
        }

    }

    // we're in the middle of seeking, and we're supposed to hold all input
    DbgLog((LOG_TRACE, TRACE_LOW, TEXT("CBigSwitchIn[%d]::Receive seek block"),
								m_iInpin));
    WaitForSingleObject(m_hEventSeek, INFINITE);

    // our variables are in flux, we're seeking and this is an OLD sample
    if (m_pSwitch->m_fSeeking)
	return S_FALSE;

    // this check needs to happen AFTER the wait for seek event, or a
    // surprise flush and new data will get thrown away
    if (m_pSwitch->m_fEOS) {
        return S_FALSE;
    }

    // we were unblocked by a flush
    if (m_bFlushing) {
        DbgLog((LOG_TRACE, TRACE_LOW, TEXT("flushing, discard...")));
	return S_FALSE;
    }

    // add newsegment time to get the real timeline time of this sample
    REFERENCE_TIME rtStart, rtStop;
    hr = pSample->GetTime(&rtStart, &rtStop);
    if (hr != S_OK) {
	EndOfStream();
	return E_FAIL;
    }

    rtStart += m_tStart;	// add NewSegment offset
    rtStop += m_tStart;

    // correct rounding errors (eg. 1.9999==>2)
    rtStart = Frame2Time(Time2Frame(rtStart, m_pSwitch->m_dFrameRate), m_pSwitch->m_dFrameRate);
    rtStop = Frame2Time(Time2Frame(rtStop, m_pSwitch->m_dFrameRate), m_pSwitch->m_dFrameRate);

    // Fix the time stamps if our new segment is higher than the filters'.
    // EG: We're seeking to timeline time 10, but this input doesn't have
    // anything until time 15.  So our pins' new segment was 15, but the new
    // segment we passed on to the transform was 10.  Now it's finally time 15,
    // and we have a sample with time stamp 0, which if delivered downstream,
    // will be thought to belong at timestamp 10, so we need to set the time
    // stamp to 5 so that the transform will know that it belongs at time 15.
    REFERENCE_TIME a = rtStart, b = rtStop;
    a -= m_pSwitch->m_rtLastSeek;
    b -= m_pSwitch->m_rtLastSeek;
    hr = pSample->SetTime(&a, &b);
    if (hr != S_OK) {
	EndOfStream();
	return E_FAIL;
    }

    // What do we do with this sample? This will set/reset the event below
    if (FancyStuff(rtStart) == S_FALSE) {
	// we were told to swallow it
	ResetEvent(m_hEventBlock);	// make sure we'll block next time
	return NOERROR;
    }

    // Wait until it is time to deliver this thing
    DbgLog((LOG_TRACE, TRACE_LOW, TEXT("CBigSwitchIn[%d]::Receive blocking..."),
								m_iInpin));
    WaitForSingleObject(m_hEventBlock, INFINITE);
    ResetEvent(m_hEventBlock);

    // we are apparently flushing now and NOT supposed to deliver this (or
    // that unexpected event will HANG)
    if (m_bFlushing)
	return S_FALSE;

    // oops - we finished since we blocked
    if (m_pSwitch->m_fEOS)
	return S_FALSE;

    // by the time we unblocked, we have advanced our crank past the time for
    // this frame... so we have gone from being too early for this frame to
    // being too late, and it can be discarded
    if (rtStart < m_pSwitch->m_rtCurrent) {
        DbgLog((LOG_TRACE, TRACE_LOW, TEXT("Oops. Sample no longer needed.")));
	return NOERROR;
    }

    // where should we deliver this?
    int iOutpin = OutpinFromTime(rtStart);
    DbgLog((LOG_TRACE, TRACE_MEDIUM, TEXT("CBigSwitchIn[%d]::Receive %dms, Delivering to %d"),
				m_iInpin, (int)(rtStart / 10000), iOutpin));
    if (iOutpin >= 0) {
	m_rtLastDelivered = m_pSwitch->m_rtNext;

        // remove bogus discontinuities now that we're making one stream
        pSample->SetDiscontinuity(FALSE);

	// Is this supposed to be a discontinuity? Yes, if we're dealing with
	// data that is temporally compressed and we switch input pins.  (The
	// thing coming from a new input pin is garbage when considered as a
	// delta from what the last pin sent)
	BOOL fComp = (m_pSwitch->m_mtAccept.bTemporalCompression == TRUE);
	if (iOutpin == 0 && (m_pSwitch->m_fDiscon ||
			(m_pSwitch->m_nLastInpin != -1 && fComp &&
			m_iInpin != m_pSwitch->m_nLastInpin))) {
            DbgLog((LOG_TRACE, TRACE_LOW, TEXT("and it was a DISCONTINUITY")));
	    pSample->SetDiscontinuity(TRUE);
	    m_pSwitch->m_fDiscon = FALSE;
	}

	// different segments will have random media times, confusing the mux
	// fix them up right, or kill them.  I'm lazy.
        pSample->SetMediaTime(NULL, NULL);

        hr = m_pSwitch->m_pOutput[iOutpin]->Deliver(pSample);

	// we just realized we're late.  The frame rate converter is probably
	// busy replicating frames.  We better tell it to stop, or trying
	// to crank ahead won't do any good
	if (m_pSwitch->m_fJustLate == TRUE) {
            DbgLog((LOG_TRACE, TRACE_LOW, TEXT("LATE:Tell the FRC to stop replicating")));
	    // The LATE variable is set to where the switch should crank to after
	    // noticing it was late.  Subtract the start time given to us by
	    // the FRC, to get the amount that the FRC is late by.  Give this
	    // number to the FRC.  The reason I do this, is that if I give a
	    // a bigger number to the FRC, and make it skip past the point that
	    // the switch skipped to, the switch will get confused and hang,
	    // so I have to be careful about how much the FRC skips

        // crank, now that we're back from Deliver (or we'll deliver 2 things
        // at once to the poor renderer!)
        m_pSwitch->ActualCrank(m_pSwitch->m_qJustLate.Late);

	    m_pSwitch->m_qJustLate.Late -= rtStart;
	    PassNotify(m_pSwitch->m_qJustLate);
	    m_pSwitch->m_fJustLate = FALSE;
	}

	// keep track of the last thing sent to the main output
	if (iOutpin == 0) {
	    m_pSwitch->m_nLastInpin = m_iInpin;	// it came from here
	    m_pSwitch->m_rtLastDelivered = m_pSwitch->m_rtCurrent;
	}
    } else {
	// nowhere to send it.
	hr = S_OK;
    }

    // Are we all done with our current time?  Is it time to advance the clock?
    if (m_pSwitch->TimeToCrank()) {
        //DbgLog((LOG_TRACE, TRACE_LOW, TEXT("It's time to crank!")));
	// Yep!  Advance the clock!
	m_pSwitch->Crank();
    }

    return hr;

} // Receive


HRESULT CBigSwitchInputPin::Active()
{
    DbgLog((LOG_TRACE, TRACE_MEDIUM,TEXT("CBigSwitchIn[%d]: Active"), m_iInpin));
    // blocks until it's time to process input
    m_hEventBlock = CreateEvent(NULL, TRUE, FALSE, NULL);
    if (m_hEventBlock == NULL)
	return E_OUTOFMEMORY;
    // blocks when we're in the middle of a seek until seek is over
    m_hEventSeek = CreateEvent(NULL, TRUE, TRUE, NULL);
    if (m_hEventSeek == NULL) {
	CloseHandle(m_hEventBlock);
        m_hEventBlock = NULL;
	return E_OUTOFMEMORY;
    }
    m_rtBlock = -1;	// we are not blocked, nor at EOS
    m_fEOS = FALSE;
    m_fStaleData = FALSE;
    m_fFlushBeforeSeek = FALSE;
    m_fFlushAfterSeek = FALSE;

    // !!! Do we need to send NewSeg ever when a dynamic input gets started up?
    // I don't think so... this can happen literally at any moment


    // We just went live.  Nobody has seeked us to the right spot yet.  Do it
    // now, for better perf, otherwise the switch will have to eat all the data
    // up to the point it wanted
    //
    // Only seek sources, that's all that's necessary.  Don't do any seeking
    // if this is the compressed switch (it will crash).
    // !!! If smart recompression ever supports seeking, we'll need to make this
    // work to get the perf benefit
    //
    if (m_pSwitch->IsDynamic() && m_fIsASource && !m_pSwitch->m_bIsCompressed) {
        IPin *pPin = GetConnected();
        ASSERT(pPin);
        CComQIPtr <IMediaSeeking, &IID_IMediaSeeking> pMS(pPin);
        if (pMS) {

            // make sure we're in MEDIA TIME format
            if (pMS->IsUsingTimeFormat(&TIME_FORMAT_MEDIA_TIME) != S_OK)
                pMS->SetTimeFormat(&TIME_FORMAT_MEDIA_TIME);

            DbgLog((LOG_TRACE, TRACE_HIGHEST,TEXT("Doing first DYNAMIC seek")));

            // Flushing would CONFUSE THE heck out of us.  We'll think we're
            // in flush without seek mode.
            HRESULT hr = pMS->SetPositions(&m_pSwitch->m_rtCurrent,
                                    AM_SEEKING_AbsolutePositioning |
                                    AM_SEEKING_NoFlush, &m_pSwitch->m_rtStop,
                                    AM_SEEKING_AbsolutePositioning |
                                    AM_SEEKING_NoFlush);

            if (FAILED(hr)) {
                // oh well, guess we won't have the optimal perf
                DbgLog((LOG_ERROR,1,TEXT("Switch::SEEK FAILED!")));
                ASSERT(FALSE);
            }
        } else {
            // oh well, guess we won't have the optimal perf
            DbgLog((LOG_ERROR,1,TEXT("Switch pin CAN'T SEEK")));
            ASSERT(FALSE); // we're screwed
        }
    }

    m_fActive = true;

    return CBaseInputPin::Active();
}


HRESULT CBigSwitchInputPin::Inactive()
{
    DbgLog((LOG_TRACE, TRACE_MEDIUM,TEXT("CBigSwitchIn[%d]: Inactive"), m_iInpin));


    // pretend we're flushing. We need Receive to unblock, but not deliver
    // anything (that would screw everything up.)  We can't actually flush,
    // that delivers the flush downstream.
    // This will make Receive and GetBuffer fail from now on
    m_bFlushing = TRUE;

    // unblock Receive and GetBuffer
    SetEvent(m_hEventBlock);
    SetEvent(m_hEventSeek);

    // wait until Receive and GetBuffer are not waiting on these events
    CAutoLock lock_it(&m_csReceive);

    if (m_hEventBlock)
    {
	CloseHandle(m_hEventBlock);
        m_hEventBlock = NULL;
    }
    if (m_hEventSeek)
    {
	CloseHandle(m_hEventSeek);
        m_hEventSeek = NULL;
    }

    m_fActive = false;

    // this will turn m_bFlushing off again
    return CBaseInputPin::Inactive();
}


HRESULT CBigSwitchInputPin::EndOfStream()
{
    // Uh oh!  We've seeked and are waiting for the flush to come through. Until
    // then, cranking or setting m_fEOS or anything will hang us.
    if (m_fStaleData) {
	return S_OK;
    }

    DbgLog((LOG_TRACE, TRACE_MEDIUM,TEXT("CBigSwitchIn[%d]: EOS"), m_iInpin));
    m_fEOS = TRUE;

    // Were we expecting more data? I certainly hope not...
    // if this pin hasn't delivered in a while, use the current time to see
    // if this pin is still needed
    // !!! add 2 ms to avoid rounding error since we don't know next crank
    REFERENCE_TIME rt = max(m_rtLastDelivered + 20000, m_pSwitch->m_rtCurrent);
    int n = OutpinFromTime(rt);
    if (n == -1)
	n = NextOutpinFromTime(rt, NULL);

    BOOL fComp = (m_pSwitch->m_mtAccept.bTemporalCompression == TRUE);

    // !!! If we are dealing with compressed data, do NOT think this is an
    // error. A smart recompression source could be any arbitrary frame rate
    // (thanks to ASF) so we don't know if we should have gotten more samples
    if ( n >= 0 && !m_pSwitch->m_fSeeking && !fComp) {

        DbgLog((LOG_ERROR,1,TEXT("*** OOPS! RAN OUT OF MOVIE TOO SOON!")));
	// !!! NEEDS TO LOG WHAT FILENAME MISBEHAVED (dynamic)
	m_pSwitch->_GenerateError(2, DEX_IDS_CLIPTOOSHORT, E_INVALIDARG);
        // !!! David didn't want to panic
	m_pSwitch->AllDone();	 // otherwise we could hang
    }

    // Eric added if( m_pSwitch->m_State != State_Stopped )
    {
        // Everytime something interesting happens, we see if it's time to advance
        // the clock
        if (m_pSwitch->TimeToCrank()) {
            //DbgLog((LOG_TRACE, TRACE_LOW, TEXT("It's time to crank!")));
	    m_pSwitch->Crank();
        }
    }

    return CBaseInputPin::EndOfStream();
}


// We got a sample at time "rt".  What do we do with it?  Hold it off, or eat
// it, or deliver it now?
//
HRESULT CBigSwitchInputPin::FancyStuff(REFERENCE_TIME rt)
{
    CAutoLock cObjectLock(&m_pSwitch->m_csCrank);

    HRESULT hrRet;

    // we're all done.
    if (m_pSwitch->m_fEOS) {
	SetEvent(m_hEventBlock);	// don't hang!
	return NOERROR;
    }

    // This sample is later than our current clock time.  It's not time to
    // deliver it yet.  When it is time, it goes to a valid output.  Let's block
    if (rt >= m_pSwitch->m_rtNext && OutpinFromTime(rt) >= 0) {
        m_rtBlock = rt;	// when we want to wake up
        DbgLog((LOG_TRACE, TRACE_LOW, TEXT("[%d] time: %d  Next: %d - not time yet"),
					m_iInpin, (int)(rt / 10000),
					(int)(m_pSwitch->m_rtNext / 10000)));
	hrRet = NOERROR;
    // this sample is earlier than we are dealing with.  I don't know where it
    // came from.  Throw it away.
    } else if (rt < m_pSwitch->m_rtCurrent) {
	// this pin will never be used again.  don't waste time... block
        if (OutpinFromTime(m_pSwitch->m_rtCurrent) < 0 &&
			NextOutpinFromTime(m_pSwitch->m_rtCurrent, NULL) < 0) {
	    m_rtBlock = MAX_TIME;
            DbgLog((LOG_TRACE, TRACE_LOW, TEXT("[%d] time: %d  Current: %d - NEVER NEEDED, block"),
					m_iInpin, (int)(rt / 10000),
					(int)(m_pSwitch->m_rtCurrent / 10000)));
	} else {
	    m_rtBlock = -1;
	    SetEvent(m_hEventBlock);
            DbgLog((LOG_TRACE, TRACE_LOW, TEXT("[%d] time: %d  Current: %d - TOO EARLY, discard"),
					m_iInpin, (int)(rt / 10000),
					(int)(m_pSwitch->m_rtCurrent / 10000)));
	}
	// to know if an EOS will be bad or not... it wasn't delivered but
	// we've seen something for this time, and we need to know that for
	// immediately after a seek when rtCurrent is not on a package boundary
	// !!! This can't be right!
	m_rtLastDelivered = m_pSwitch->m_rtNext;
	hrRet = S_FALSE;

    } else {
	hrRet = NOERROR;
        if (OutpinFromTime(rt) < 0) {
	    // This pin is not connected anywhere at the time of the sample.
	    // Will it ever be connected again?
	    if (NextOutpinFromTime(rt, NULL) >= 0) {
		// Yes, eventually this pin needs to deliver stuff, but not now,
		// so throw this sample away
		m_rtBlock = -1;
		SetEvent(m_hEventBlock);
        	DbgLog((LOG_TRACE, TRACE_LOW, TEXT("[%d] time: %d  Current: %d - TOO EARLY, discard"),
					m_iInpin, (int)(rt / 10000),
					(int)(m_pSwitch->m_rtCurrent / 10000)));
		hrRet = S_FALSE;
	    } else {
		// No, this pin will never be needed again.  BLOCK it so it
		// doesn't waste anybody's time if its a source (otherwise the
		// source will keep pushing data at us eating CPU).  If its
		// not a source, blocking could hang the graph making the
		// sources that eventually feed us not crank, so we will discard
		// (it will be a timely discard, one each crank so that's OK)
		if (m_fIsASource) {
		    // It _is_ time for this sample, but it's also the end of
		    // the project!  If we don't realize this, we'll hang
		    if (rt < m_pSwitch->m_rtNext && rt >= m_pSwitch->m_rtStop) {
			m_pSwitch->AllDone();
		    } else {
	               m_rtBlock = rt;
                       DbgLog((LOG_TRACE, TRACE_LOW, TEXT("[%d] no longer needed - block")
						, m_iInpin));
		    }
		} else {
		    m_rtBlock = -1;
		    SetEvent(m_hEventBlock);
                    DbgLog((LOG_TRACE, TRACE_LOW, TEXT("[%d] no longer needed - discard"),
						m_iInpin));
		}
	    }
        } else {
            // It is time for this sample to be delivered!
            DbgLog((LOG_TRACE, TRACE_LOW, TEXT("[%d] time: %d  time to unblock"),
						m_iInpin, (int)(rt / 10000)));
	    m_rtBlock = -1;
	    // looks like our crank time is not ssynced with the incoming times
	    // (we must have just seeked to an arbitrary spot.)  MAKE THEM
	    // THE SAME, or we'll get confused processing stuff at time X and
	    // deciding whether to crank or not thinking we're at time (X-delta)
	    if (rt > m_pSwitch->m_rtCurrent) {
                ASSERT(FALSE);  // shouldn't happen, we only seek to boundaries
                DbgLog((LOG_TRACE, TRACE_LOW, TEXT("HONORARY CRANK to %dms"),
							(int)(rt / 10000)));
		m_pSwitch->ActualCrank(rt);
	    }
            SetEvent(m_hEventBlock);
	}
    }

    // OK, are we ready to advance our internal clock yet?
    if (m_pSwitch->TimeToCrank()) {
        //DbgLog((LOG_TRACE, TRACE_LOW, TEXT("It's time to crank!")));
	m_pSwitch->Crank();
    }

    return hrRet;
}

//
// Don't allow our input to connect directly to our output
//
HRESULT CBigSwitchInputPin::CompleteConnect(IPin *pReceivePin)
{
    DbgLog((LOG_TRACE, TRACE_MEDIUM,TEXT("CBigSwitchIn[%d]::CompleteConnect"), m_iInpin));

    PIN_INFO pinfo;
    IBigSwitcher *pBS;
    HRESULT hr = pReceivePin->QueryPinInfo(&pinfo);
    if (hr == S_OK) {
	pinfo.pFilter->Release();	// it won't go away yet
	hr = pinfo.pFilter->QueryInterface(IID_IBigSwitcher, (void **)&pBS);
	if (hr == S_OK) {
	    pBS->Release();
            DbgLog((LOG_TRACE, TRACE_HIGHEST,TEXT("CBigSwitchIn[%d]::CompleteConnect failing because it was another switch"), m_iInpin));
	    return E_FAIL;
	}
    }
    return CBaseInputPin::CompleteConnect(pReceivePin);
}


// what output is this pin connected to at this time?  check our linked list
//
int CBigSwitchInputPin::OutpinFromTime(REFERENCE_TIME rt)
{
    if (rt < 0 || rt >= m_pSwitch->m_rtProjectLength)
	return -1;

    CRANK *p = m_pCrankHead;
    while (p) {
	if (p->rtStart <= rt && p->rtStop > rt) {
	    return p->iOutpin;
	}
	p = p->Next;
    }
    return -1;
}


// after the one it's sending to now, what outpin will be next?
// !!! Assumes two of the same outpin are not in a row, but collapsed
//
int CBigSwitchInputPin::NextOutpinFromTime(REFERENCE_TIME rt,
						REFERENCE_TIME *prtNext)
{
    if (rt < 0 || rt >= m_pSwitch->m_rtProjectLength)
	return -1;

    CRANK *p = m_pCrankHead;
    while (p) {
	if (p->rtStart <= rt && p->rtStop > rt) {
	    if (p->Next == NULL)
	        return -1;
	    else {
		if (prtNext)
		    *prtNext = p->Next->rtStart;
		return p->Next->iOutpin;
	    }
	} else if (p->rtStart > rt) {
	    if (prtNext)
		*prtNext = p->rtStart;
	    return p->iOutpin;
	}
	p = p->Next;
    }
    return -1;
}

// DEBUG code to show who this pin is connected to at what times
//
#ifdef DEBUG
HRESULT CBigSwitchInputPin::DumpCrank()
{
    DbgLog((LOG_TRACE, TRACE_MEDIUM,TEXT("CBigSwitchIn[%d]::DumpCrank"), m_iInpin));
    CRANK *p = m_pCrankHead;
    while (p) {
        DbgLog((LOG_TRACE, TRACE_MEDIUM,TEXT("Pin %d  %8d-%8d ms"), p->iOutpin,
			(int)(p->rtStart / 10000), (int)(p->rtStop / 10000)));
	p = p->Next;
    }
    return S_OK;
}
#endif
=== C:/Users/treeman/Desktop/windows nt source code\Source\Win2K3\NT\multimedia\dshow\filterus\dexter\stillvid\stillvid.h ===
//@@@@AUTOBLOCK+============================================================;
//
//  THIS CODE AND INFORMATION IS PROVIDED "AS IS" WITHOUT WARRANTY OF ANY
//  KIND, EITHER EXPRESSED OR IMPLIED, INCLUDING BUT NOT LIMITED TO THE
//  IMPLIED WARRANTIES OF MERCHANTABILITY AND/OR FITNESS FOR A PARTICULAR
//  PURPOSE.
//
//  File: stillvid.h
//
//  Copyright (c) Microsoft Corporation.  All Rights Reserved.
//
//@@@@AUTOBLOCK-============================================================;

#include "..\errlog\cerrlog.h"
#include "loadgif.h"


extern const AMOVIESETUP_FILTER sudStillVid;

enum
{
    STILLVID_FILETYPE_DIB = 1,
    STILLVID_FILETYPE_JPG =2,
    STILLVID_FILETYPE_GIF =3,
    STILLVID_FILETYPE_TGA = 4
};

// this filter uses more memory than anything else, don't waste memory
#define MAXBUFFERCNT   1

// The class managing the output pin
class CStilVidStream;	    //Still Video stream
class CImgGif;

// Main object for a Generate Still Video
class CGenStilVid : public CSource
		    , public IFileSourceFilter
		    , public CPersistStream
		    , public CAMSetErrorLog

{
    friend class CStilVidStream ;
    friend class CImgGif;

public:

    CGenStilVid(LPUNKNOWN lpunk, HRESULT *phr);
    ~CGenStilVid();

    // Create GenBlkVid filter!
    static CUnknown * WINAPI CreateInstance(LPUNKNOWN lpunk, HRESULT *phr);

    STDMETHODIMP NonDelegatingQueryInterface(REFIID riid,void **ppv);
    DECLARE_IUNKNOWN;

    //IFileSourceFilter
    STDMETHODIMP Load( LPCOLESTR pszFileName,const AM_MEDIA_TYPE *pmt);
    /* Free any resources acquired by Load */
    STDMETHODIMP Unload();
    STDMETHODIMP GetCurFile(LPOLESTR * ppszFileName,AM_MEDIA_TYPE *pmt);

    CBasePin *GetPin (int n) ;                         // gets a pin ptr
    int CGenStilVid::GetPinCount();

    // CPersistStream
    HRESULT WriteToStream(IStream *pStream);
    HRESULT ReadFromStream(IStream *pStream);
    STDMETHODIMP GetClassID(CLSID *pClsid);
    int SizeMax();

private:
    void get_CurrentMT(CMediaType *pmt){ *pmt=m_mt; };  
    void put_CurrentMT(CMediaType mt){ m_mt=mt; };  

    //for DIB sequence
    LPTSTR	m_lpszDIBFileTemplate;	//space for DIB file name template
    BOOL	m_bFileType;	    //1:DIB sequence; 2 JPEG sequence
    DWORD	m_dwMaxDIBFileCnt;
    DWORD	m_dwFirstFile;

    LPOLESTR	m_pFileName;		//source file name
    LONGLONG	m_llSize;		//
    PBYTE	m_pbData;		//source data pointer
    HBITMAP     m_hbitmap;	// holds the JPEG data
    // media type of the src data
    CMediaType  m_mt;

    BOOL m_fAllowSeq;	// allow dib sequences?

    CImgGif *m_pGif;
    LIST        *m_pList, *m_pListHead;
    REFERENCE_TIME m_rtGIFTotal;	// total duration of animated GIF
    ULONG_PTR   m_GdiplusToken;                 // GDI +


}; // CGenStilVid


// CStilVidStream manages the data flow from the output pin.
class CStilVidStream : public CSourceStream 
		    ,public IGenVideo
		    , public IDexterSequencer
		    ,public ISpecifyPropertyPages
		    ,public IMediaSeeking
{
    friend class CGenStilVid ;

public:

    CStilVidStream(HRESULT *phr, CGenStilVid *pParent, LPCWSTR pPinName);
    ~CStilVidStream();

    //expose	IGenVideo
    //		ISpecifyPropertyPages
    //		IDexterSequencer
    STDMETHODIMP NonDelegatingQueryInterface(REFIID riid,void **ppv);
    DECLARE_IUNKNOWN;


    // put blank RGB32 video into the supplied video frame
    HRESULT DoBufferProcessingLoop();
    HRESULT FillBuffer(IMediaSample *pms);

    // To say "read only buffer"
    HRESULT DecideAllocator(IMemInputPin *pPin, IMemAllocator **ppAlloc);

    // Ask for buffers of the size appropriate to the agreed media type
    HRESULT DecideBufferSize(IMemAllocator *pIMemAlloc,
                             ALLOCATOR_PROPERTIES *pProperties);


    HRESULT CheckMediaType(const CMediaType *pMediaType);
    HRESULT GetMediaType(int iPosition, CMediaType *pmt);
    HRESULT SetMediaType(const CMediaType* pmt);

    // Resets the stream time to zero
    HRESULT OnThreadCreate(void);

    // DO NO SUPPORT Quality control notifications sent to us
    // STDMETHODIMP Notify(IBaseFilter * pSender, Quality q);
    
    // IMediaSeeking methods
    STDMETHODIMP GetCapabilities( DWORD * pCapabilities );
    STDMETHODIMP CheckCapabilities( DWORD * pCapabilities ); 
    STDMETHODIMP SetTimeFormat(const GUID * pFormat);	
    STDMETHODIMP GetTimeFormat(GUID *pFormat);		    
    STDMETHODIMP IsUsingTimeFormat(const GUID * pFormat);  
    STDMETHODIMP IsFormatSupported( const GUID * pFormat); 
    STDMETHODIMP QueryPreferredFormat( GUID *pFormat);	    
    STDMETHODIMP SetPositions( LONGLONG * pCurrent, DWORD CurrentFlags
                             , LONGLONG * pStop, DWORD StopFlags );
    STDMETHODIMP GetPositions( LONGLONG * pCurrent, LONGLONG * pStop );
    STDMETHODIMP GetCurrentPosition( LONGLONG * pCurrent );
    STDMETHODIMP GetStopPosition( LONGLONG * pStop );
    STDMETHODIMP GetAvailable( LONGLONG *pEarliest, LONGLONG *pLatest );
    STDMETHODIMP GetDuration( LONGLONG *pDuration );
    STDMETHODIMP GetPreroll( LONGLONG *pllPreroll )
	{ if( pllPreroll) *pllPreroll =0; return S_OK; };
    STDMETHODIMP SetRate( double dRate);
    STDMETHODIMP GetRate( double * pdRate);
    STDMETHODIMP ConvertTimeFormat(LONGLONG *pTarget, const GUID *pTargetFormat,
				   LONGLONG Source, const GUID *pSourceFormat ) { return E_NOTIMPL ;};

    
    //can be called by IMedieaSeeking's SetPositions()
    //STDMETHODIMP set_StartStop(REFERENCE_TIME start, REFERENCE_TIME stop);

    STDMETHODIMP Notify(IBaseFilter * pSender, Quality q);
    STDMETHODIMP GetPages(CAUUID *pPages);

    
    //IDexterSequencer
    STDMETHODIMP get_OutputFrmRate( double *dpFrmRate );
    STDMETHODIMP put_OutputFrmRate( double dFrmRate );
    STDMETHODIMP get_MediaType( AM_MEDIA_TYPE *pmt);
    STDMETHODIMP put_MediaType( const AM_MEDIA_TYPE *pmt);
    STDMETHODIMP GetStartStopSkewCount(int *piCount);
    STDMETHODIMP GetStartStopSkew(REFERENCE_TIME *prtStart,
			REFERENCE_TIME *prtStop, REFERENCE_TIME *prtSkew,
			double *pdRate);
    STDMETHODIMP AddStartStopSkew(REFERENCE_TIME rtStart,
			REFERENCE_TIME rtStop, REFERENCE_TIME rtSkew,
			double dRate);
    STDMETHODIMP ClearStartStopSkew();

    //IGenVideo
    STDMETHODIMP ImportSrcBuffer( const AM_MEDIA_TYPE *pmt,
				const BYTE *pBuf) {return E_NOTIMPL;};
    STDMETHODIMP get_RGBAValue(long *dwRGBA){return E_NOTIMPL;};
    STDMETHODIMP put_RGBAValue(long dwRGBA){return E_NOTIMPL;};

private:

    CGenStilVid		*m_pGenStilVid;
    	    
    REFERENCE_TIME	m_rtStartTime;
    REFERENCE_TIME	m_rtDuration;

    REFERENCE_TIME	m_rtNewSeg;	// last NewSeg given

    REFERENCE_TIME	m_rtLastStop;		// used for animated GIF
    LONG		m_lDataLen;		//actual output data lenght
    DWORD		m_dwOutputSampleCnt;	// output frame cnt
    double		m_dOutputFrmRate;	// Output frm rate frames/second
    BYTE		m_bIntBufCnt;		// CNT for first 2 samples
    int			m_iBufferCnt;		// how many buffers it gets
    BYTE		m_bZeroBufCnt;		// How many buffer already 0'd
    BYTE		**m_ppbDstBuf;
   
    CCritSec    m_csFilling;	// are we delivering?
   

}; // CStilVidStream
=== C:/Users/treeman/Desktop/windows nt source code\Source\Win2K3\NT\multimedia\dshow\filterus\dexter\stillvid\stilprop.cpp ===
//@@@@AUTOBLOCK+============================================================;
//
//  THIS CODE AND INFORMATION IS PROVIDED "AS IS" WITHOUT WARRANTY OF ANY
//  KIND, EITHER EXPRESSED OR IMPLIED, INCLUDING BUT NOT LIMITED TO THE
//  IMPLIED WARRANTIES OF MERCHANTABILITY AND/OR FITNESS FOR A PARTICULAR
//  PURPOSE.
//
//  File: stilprop.cpp
//
//  Copyright (c) Microsoft Corporation.  All Rights Reserved.
//
//@@@@AUTOBLOCK-============================================================;

//
//Stilprop.cpp
//

#include <streams.h>
#include <qeditint.h>
#include <qedit.h>
#include "resource.h"
#include "StilProp.h"

//void Handle_Browse( HWND hWndDlg );

// *
// * CGenStilProperties
// *


//
// CreateInstance
//
CUnknown *CGenStilProperties::CreateInstance(LPUNKNOWN lpunk, HRESULT *phr)
{

    CUnknown *punk = new CGenStilProperties(lpunk, phr);
    if (punk == NULL)
    {
	*phr = E_OUTOFMEMORY;
    }

    return punk;
}


//
// CGenStilProperties::Constructor
//
CGenStilProperties::CGenStilProperties(LPUNKNOWN pUnk, HRESULT *phr)
    : CBasePropertyPage(NAME("GenStilVid Property Page"),pUnk,
        IDD_GENSTILL, IDS_STILLTITLE)
    , m_pGenStil(NULL)
    , m_bIsInitialized(FALSE)
{
    //m_sFileName[60]="";
}


//
// SetDirty
//
// Sets m_hrDirtyFlag and notifies the property page site of the change
//
void CGenStilProperties::SetDirty()
{
    m_bDirty = TRUE;
    if (m_pPageSite)
    {
        m_pPageSite->OnStatusChange(PROPPAGESTATUS_DIRTY);
    }
}


INT_PTR CGenStilProperties::OnReceiveMessage(HWND hwnd,
                                        UINT uMsg,
                                        WPARAM wParam,
                                        LPARAM lParam)
{
    switch (uMsg)
    {
        case WM_INITDIALOG:
        {
	    //start time
	    SetDlgItemInt(hwnd, IDC_STILL_START, (int)(m_rtStartTime / 10000),FALSE);
	
	    //frame rate
	    SetDlgItemInt(hwnd, IDC_STILL_FRMRATE, (int)(m_dOutputFrmRate * 100), FALSE);

    	    //duration
	    SetDlgItemInt(hwnd, IDC_STILL_DURATION, (int)(m_rtDuration/ 10000), FALSE);

            return (LRESULT) 1;
        }
        case WM_COMMAND:
        {
            if (m_bIsInitialized)
            {
                m_bDirty = TRUE;
                if (m_pPageSite)
                {
                    m_pPageSite->OnStatusChange(PROPPAGESTATUS_DIRTY);
                }
            }

	   /*X* switch ( LOWORD(wParam) )
	    {
		case IDC_BT_BROWSE:
		    Handle_Browse( hwnd );
		    break;
	    }
	    *X*/
            return (LRESULT) 1;
        }
    }
    return CBasePropertyPage::OnReceiveMessage(hwnd,uMsg,wParam,lParam);
}

HRESULT CGenStilProperties::OnConnect(IUnknown *pUnknown)
{

    // Get IDexterSequencer interface
    ASSERT(m_pGenStil == NULL);
    HRESULT hr = pUnknown->QueryInterface(IID_IDexterSequencer,
				(void **) &m_pGenStil);
    if (FAILED(hr))
    {
	return E_NOINTERFACE;
    }

    ASSERT(m_pGenStil);

    // get init data
    piGenStill()->get_OutputFrmRate( &m_dOutputFrmRate );
    REFERENCE_TIME rt;
    double d;
    piGenStill()->GetStartStopSkew( &m_rtStartTime, &m_rtDuration, &rt, &d );
    m_rtDuration -= m_rtStartTime;

    m_bIsInitialized = FALSE ;

    return NOERROR;
}

HRESULT CGenStilProperties::OnDisconnect()
{
    // Release the interface

    if (m_pGenStil == NULL)
    {
        return(E_UNEXPECTED);
    }
    m_pGenStil->Release();
    m_pGenStil = NULL;
    return NOERROR;
}


// We are being activated

HRESULT CGenStilProperties::OnActivate()
{
    m_bIsInitialized = TRUE;
    return NOERROR;
}


// We are being deactivated

HRESULT CGenStilProperties::OnDeactivate(void)
{
    // remember present effect level for next Activate() call

    GetFromDialog();
    return NOERROR;
}

//
// get data from Dialog

STDMETHODIMP CGenStilProperties::GetFromDialog(void)
{
    int n;

    //get start time
    m_rtStartTime = GetDlgItemInt(m_Dlg, IDC_STILL_START, NULL, FALSE);
    m_rtStartTime *= 10000;

    //get frame rate
    n = GetDlgItemInt(m_Dlg, IDC_STILL_FRMRATE, NULL, FALSE);
    m_dOutputFrmRate = (double)(n / 100.);

    // duration
    m_rtDuration = GetDlgItemInt(m_Dlg, IDC_STILL_DURATION, NULL, FALSE);
    m_rtDuration *= 10000;

    return NOERROR;
}


HRESULT CGenStilProperties::OnApplyChanges()
{
    GetFromDialog();

    m_bDirty  = FALSE; // the page is now clean

    // set data
    piGenStill()->put_OutputFrmRate( m_dOutputFrmRate );
    piGenStill()->ClearStartStopSkew();
    piGenStill()->AddStartStopSkew( m_rtStartTime, m_rtStartTime + m_rtDuration,
								0, 1);
    return(NOERROR);

}
=== C:/Users/treeman/Desktop/windows nt source code\Source\Win2K3\NT\multimedia\dshow\filterus\dexter\switch\setup.cpp ===
//@@@@AUTOBLOCK+============================================================;
//
//  THIS CODE AND INFORMATION IS PROVIDED "AS IS" WITHOUT WARRANTY OF ANY
//  KIND, EITHER EXPRESSED OR IMPLIED, INCLUDING BUT NOT LIMITED TO THE
//  IMPLIED WARRANTIES OF MERCHANTABILITY AND/OR FITNESS FOR A PARTICULAR
//  PURPOSE.
//
//  File: setup.cpp
//
//  Copyright (c) Microsoft Corporation.  All Rights Reserved.
//
//@@@@AUTOBLOCK-============================================================;

#include <streams.h>
#include <qeditint.h>
#include <qedit.h>
#include "switch.h"
#include "..\util\conv.cxx"
#include "..\util\filfuncs.h"
#include "..\render\dexhelp.h"

// Since this filter has no property page, it is useless unless programmed.
// I have test code which will allow it to be inserted into graphedit pre-
// programmed to do something useful
//
//#define TEST

const AMOVIESETUP_FILTER sudBigSwitch =
{
    &CLSID_BigSwitch,       // CLSID of filter
    L"Big Switch",          // Filter's name
    MERIT_DO_NOT_USE,       // Filter merit
    0,                      // Number of pins
    NULL //psudPins                // Pin information
};

//
// CreateInstance
//
// Creator function for the class ID
//
CUnknown * WINAPI CBigSwitch::CreateInstance(LPUNKNOWN pUnk, HRESULT *phr)
{
    return new CBigSwitch(NAME("Big Switch Filter"), pUnk, phr);
}
=== C:/Users/treeman/Desktop/windows nt source code\Source\Win2K3\NT\multimedia\dshow\filterus\dexter\switch\switch.cpp ===
//@@@@AUTOBLOCK+============================================================;
//
//  THIS CODE AND INFORMATION IS PROVIDED "AS IS" WITHOUT WARRANTY OF ANY
//  KIND, EITHER EXPRESSED OR IMPLIED, INCLUDING BUT NOT LIMITED TO THE
//  IMPLIED WARRANTIES OF MERCHANTABILITY AND/OR FITNESS FOR A PARTICULAR
//  PURPOSE.
//
//  File: switch.cpp
//
//  Copyright (c) Microsoft Corporation.  All Rights Reserved.
//
//@@@@AUTOBLOCK-============================================================;

//depot/private/Lab06_DEV/MultiMedia/DShow/filterus/dexter/switch/switch.cpp#5 - edit change 27342 (text)
//depot/private/Lab06_DEV/MultiMedia/DShow/filterus/dexter/switch/switch.cpp#3 - edit change 24879 (text)
// !!! When you seek, chances are it's not on a frame boundary (according to
// the fps value we have).  Should the first crank value after the seek be
// rounded down to the frame boundary?  It seems to work OK because the FRC is
// smart enough to send all new streams with time stamps on frame boundaries.

// !!! At a given crank value, we don't know the next value we're going to crank
// to, so we guess!  Any bad repercussions?

/*

THE BIG SWITCHER:

It can have many inputs and many outputs.  Inputs can either be from video
sources (all must be the same frame rate), or outputs that have been re-routed
back to the input.  The last output pin is the final output stream.  Every
other output pin goes into a one input or two input effect filter, and then
back to an input.

The switcher knows which input pin to send to which output pin at what time.
This can be programmed arbitrarily.

As far as timing goes, this filter has an internal time of the current timeline
time being processed.  If it is seeked to time 10, it waits until all inputs
that were supposed to send something at time 10 do so, and then it updates its
internal clock to the earliest incoming time stamp of its sources.

Here is how the allocator fun works:  Our inputs and output both like to
be the allocator.  That way, we can do evil switchy things and not upset the
other filters.  When we receive a sample, we can send it to any output we
please without a copy.  So we need to make sure all buffers have max alignment
and prefixing of any of the connected pins.  As far as number of buffers go,
we are happy with 1 buffer for each input pin allocator to save space, but we
have a pool of 30 or however many extra buffers all inputs can share.  Only
if an input pin's buffers are not read only, is it allowed to partake of the
pool if its own buffer is busy.  Assuming we have an output queue on the final
output, this allows the graph to run ahead a second or two, for when slow DXT's
slow us down, and we might still play flawlessly!  And we don't need 30 buffers
per pin (which could be thousands) and we don't do any memory copies.
Pretty neat, eh?

*/

	//////////////////////////////////////////////////////////
	// * SEE THE ESSAY ON SHARING A SOURCE IN AUDPACK.CPP * //
	//////////////////////////////////////////////////////////

/*

Here is more info about source sharing for the switch:  If we are attached
to a shared parser pin that ignores seeks, when somebody seeks the other pin,
we get seeked without any warning.  We'll see a FLUSH on one of our pins for
no good reason.  At some later point in time, we'll see a Seek come on our
output pin associated with the surprise flush.  In between these 2 events,
the AUDPACK or FRC that is in front of us is smart enough not to deliver us
any data because it is going to be data from before the seek, not data from
after the seek like we are expecting.  This keeps us from breaking and doing the
wrong thing.

The other possibility is that we get seeked 1st, but some of our pins that we
pass the seek along to ignore the seek.  They're still delivering old data,
until some later point when the seek makes it up the other branch of the shared
source, and those input pins of ours will get flushed without warning and start
sending the new post-seek data.  When we try to seek a pin, and it isn't flushed
that pin goes STALE (m_fStaleData) meaning that it cannot deliver any data,
or accept an EOS, or do ANYTHING until it gets flushed and it's sending the new
data, from after the seek we gave it long ago.

We keep a count, when we are seeked, of how many pins are stale (didn't flush
but should have), and we don't let those pins do anything to us anymore... they
don't deliver, send us EOS, or do anything.  Then when all the stale pins are
finally flushed, we deliver the new seg downstream for the seek, and let all
the pins start partying again


#ifXXXdef NOFLUSH (this code was removed for security review)

If you have a parser that doesn't ALWAYS FLUSH when it's seeked and streaming,
you need all the code ifdef'd out right now in NOFLUSH.  Thankfully, all
the Dexter sources that exist right now will always flush, even if they haven't
ever sent data before so theoretically don't need to flush

Actually it's a little more complicated than that.  Some parsers don't flush
if they've never delivered data yet, so we can't count on getting the flush,
so here's what we do:

1. A pin will go unstale if it gets a NewSeg OR if it gets flushed (the flush
   might not happen, but the NewSeg will) (I hope)
2. If you get a NewSeg during the seek (see audpack.cpp - one might get sent
   then) that's the same as getting a flush.  DO NOT consider that pin stale
3. There is a timing hole... Protect with a CritSec NewSeg from being called
   while seeking (see :SetPositions for explanation)

#endif

*/


// This code assumes that the switch IS the allocator for all its connections
// in order to work its magic.


#include <streams.h>
#include <qeditint.h>
#include <qedit.h>
//#include <vfw.h>
#include "switch.h"
#include "..\util\conv.cxx"
#include "..\util\dexmisc.h"
#include "..\util\filfuncs.h"
#include "..\render\dexhelp.h"

// to use COM enumerator
#include <atlbase.h>
extern CComModule _Module;
#include <atlcom.h>

#include <strsafe.h>

// don't have this many dynamic inputs connected at a time if they're not all
// needed at the same time (mostly to get around the 75 instances of an ICM
// codec limit).
#define MAX_SOURCES_LOADED	5

const int TRACE_EXTREME = 0;
const int TRACE_HIGHEST = 2;
const int TRACE_MEDIUM = 3;
const int TRACE_LOW = 4;
const int TRACE_LOWEST = 5;

const double DEFAULT_FPS = 15.0;

// ================================================================
// CBigSwitch Constructor
// ================================================================

CBigSwitch::CBigSwitch(TCHAR *pName, LPUNKNOWN pUnk, HRESULT *phr) :
    m_cInputs(0),	// no pins yet
    m_cOutputs(0),
    m_rtProjectLength(0),	// length of time the graph will run
    m_rtStop(0),	// if we want to stop before the project is done
    m_dFrameRate(DEFAULT_FPS),	// everything must be at this frame rate
    m_rtLastSeek(0),	// last seek command in timeline time
    m_fSeeking(FALSE),  // in the middle of seeking
    m_fNewSegSent(FALSE), // fwd'd the NewSeg yet?
    m_pFilterLoad(NULL),// sources to dynamically load
    m_pGraphConfig(NULL), // IAMGraphConfig interface (no addref)
    m_cbPrefix(0),
    m_cbAlign(1),
    m_cbBuffer(512),
    m_fPreview(TRUE),
    m_fDiscon(FALSE),
    m_bIsCompressed(FALSE),
    m_nDynaFlags( CONNECTF_DYNAMIC_NONE ),
    m_nOutputBuffering(DEX_DEF_OUTPUTBUF),
    m_nLastInpin(-1),
    m_cLoaded(0),
    m_fJustLate(FALSE),
    CBaseFilter(NAME("Big Switch filter"), pUnk, this, CLSID_BigSwitch),
    CPersistStream(pUnk, phr),
    m_hEventThread( NULL ),
    m_pDeadGraph( NULL ),
    m_nGroupNumber( -1 ),
    m_pShareSwitch( NULL ),
    m_rtCurrent( NULL )
{
#ifdef DEBUG
    m_nSkippedTotal = 0;
#endif

    DbgLog((LOG_TRACE, TRACE_HIGHEST,TEXT("::CBigSwitch")));

    ZeroMemory(&m_mtAccept, sizeof(AM_MEDIA_TYPE)); // safe
    m_mtAccept.majortype = GUID_NULL;
    m_qLastLate = 0;

    // as well as all the individual allocators, we have a pool of buffers
    // that all the inputs can use if they want to
    //
    m_pPoolAllocator = NULL;
    m_pPoolAllocator = new CMemAllocator(
		NAME("Special Switch pool allocator"), NULL, phr);
    if (FAILED(*phr)) {
	return;
    }
    m_pPoolAllocator->AddRef();
    DbgLog((LOG_TRACE, TRACE_HIGHEST,TEXT("Created a POOL Allocator")));

    // Init the pool allocator now.  It may never happen otherwise if we don't
    // connect any output pins, and an uninited allocator prevents the filter
    // from streaming
    ALLOCATOR_PROPERTIES prop, actual;
    prop.cBuffers = m_nOutputBuffering;
    prop.cbBuffer = m_cbBuffer;
    prop.cbAlign = m_cbAlign;
    prop.cbPrefix = m_cbPrefix;
    m_pPoolAllocator->SetProperties(&prop, &actual);

    ASSERT(phr);

}


//
// Destructor
//
CBigSwitch::~CBigSwitch()
{
    DbgLog((LOG_TRACE, TRACE_HIGHEST,TEXT("::~CBigSwitch")));

    Reset();

    DbgLog((LOG_TRACE, TRACE_HIGHEST,TEXT("Deleting inputs")));
    for (int z = 0; z < m_cInputs; z++)
	delete m_pInput[z];
    if (m_cInputs)
        delete m_pInput;
    DbgLog((LOG_TRACE, TRACE_HIGHEST,TEXT("Deleting outputs")));
    for (z = 0; z < m_cOutputs; z++)
	delete m_pOutput[z];
    if (m_cOutputs)
        delete m_pOutput;
    SaferFreeMediaType( m_mtAccept );
    if (m_pPoolAllocator)
        m_pPoolAllocator->Release();
    if (m_pShareSwitch)
        m_pShareSwitch->Release();
}



STDMETHODIMP CBigSwitch::NonDelegatingQueryInterface(REFIID riid, void ** ppv)
{
    CheckPointer(ppv,E_POINTER);

    if (riid == IID_IAMSetErrorLog) {
        return GetInterface( (IAMSetErrorLog*) this, ppv );
    } else if (riid == IID_IAMOutputBuffering) {
        return GetInterface( (IAMOutputBuffering*) this, ppv );
    } else if (riid == IID_IBigSwitcher) {
        DbgLog((LOG_TRACE, TRACE_HIGHEST,TEXT("CBigSwitch: QI for IBigSwitcher")));
        return GetInterface((IBigSwitcher *) this, ppv);
    } else if (riid == IID_IPersistPropertyBag) {
        // return GetInterface((IPersistPropertyBag *) this, ppv);
    } else if (riid == IID_IGraphConfigCallback) {
        return GetInterface((IGraphConfigCallback *) this, ppv);
    } else if (riid == IID_IPersistStream) {
        return GetInterface((IPersistStream *) this, ppv);
    }
    return CBaseFilter::NonDelegatingQueryInterface(riid, ppv);
}

//
// IBigSwitcher implementation
//

// Throw all queued data away, and start over
//
STDMETHODIMP CBigSwitch::Reset()
{
    CAutoLock cObjectLock(m_pLock);
    if (m_State != State_Stopped)
	return VFW_E_NOT_STOPPED;

    DbgLog((LOG_TRACE, TRACE_HIGHEST,TEXT("CBigSwitch::Reset switch matrix")));
    for (int i = 0; i < m_cInputs; i++) {

        InputIsASource( i, FALSE );

        CRANK *p = m_pInput[i]->m_pCrankHead, *p2;
        while (p) {
	    p2 = p->Next;
	    delete p;
 	    p = p2;
        }
        m_pInput[i]->m_pCrankHead = NULL;
    }

    // free delayload info
    //
    if( IsDynamic( ) )
    {
        CAutoLock lock(&m_csFilterLoad);

        UnloadAll();	// unload all the dynamic sources

        FILTERLOADINFO *pfli = m_pFilterLoad;
        while (pfli) {
            if (pfli->bstrURL) {
                SysFreeString(pfli->bstrURL);
            }
	    if (pfli->pSkew) {
		CoTaskMemFree(pfli->pSkew);
	    }
	    if (pfli->pSetter) {
		pfli->pSetter->Release();
	    }
            SaferFreeMediaType(pfli->mtShare);

            FILTERLOADINFO *p = pfli;
            pfli = pfli->pNext;
            delete p;
        }

        m_pFilterLoad = NULL;
    }

    SetDirty(TRUE);
    return S_OK;
}


// pin X goes to pin Y starting at time rt
//
STDMETHODIMP CBigSwitch::SetX2Y( REFERENCE_TIME rt, long X, long Y )
{
    CAutoLock cObjectLock(m_pLock);
    if (m_State != State_Stopped)
	return VFW_E_NOT_STOPPED;

    if (X < 0 || X >= m_cInputs || Y >= m_cOutputs)
	return E_INVALIDARG;
    if (rt < 0)
	return E_INVALIDARG;

    DbgLog((LOG_TRACE, TRACE_MEDIUM,TEXT("SetX2Y %dms (%d,%d)"), (int)(rt / 10000), X, Y));

    CRANK *p = m_pInput[X]->m_pCrankHead, *pNew, *pP = NULL;

    // insert into our linked list sorted by time.  Fix the end times to be
    // the start time of the next pin's connection

    while (p && p->rtStart < rt) {
	pP = p;
	p = p->Next;
    }
    if (p && p->rtStart == rt)
	return E_INVALIDARG;
    pNew = new CRANK;
    if (pNew == NULL)
	return E_OUTOFMEMORY;
    pNew->iOutpin = Y;
    pNew->rtStart = rt;
    pNew->rtStop = MAX_TIME;
    if (p)
	pNew->rtStop = p->rtStart;
    if (pP) {
	pP->rtStop = rt;
	pP->Next = pNew;
    }
    pNew->Next = p;
    if (m_pInput[X]->m_pCrankHead == NULL || p == m_pInput[X]->m_pCrankHead)
	m_pInput[X]->m_pCrankHead = pNew;

#ifdef DEBUG
    m_pInput[X]->DumpCrank();
#endif
    SetDirty(TRUE);
    return S_OK;
}



// !!! error can't back out the ones that worked, scrap this?
//
STDMETHODIMP CBigSwitch::SetX2YArray( REFERENCE_TIME *relative, long * pX, long * pY, long ArraySize )
{
    if( ArraySize <= 0 )
    {
        return E_INVALIDARG;
    }

    CAutoLock cObjectLock(m_pLock);
    if (m_State != State_Stopped)
	return VFW_E_NOT_STOPPED;

    HRESULT hr = E_INVALIDARG;
    for (int i = 0; i < ArraySize; i++) {
	hr = SetX2Y(relative[i], pX[i], pY[i]);
	if (hr != NOERROR)
	    break;
    }
    return hr;
}


// how many input pins?
//
STDMETHODIMP CBigSwitch::GetInputDepth( long * pDepth )
{
    CAutoLock cObjectLock(m_pLock);
    CheckPointer(pDepth,E_POINTER);

    if (m_cInputs == 0)
	return E_UNEXPECTED;
    else
	*pDepth = m_cInputs;
    return NOERROR;
}


// how many input pins do we have?
//
STDMETHODIMP CBigSwitch::SetInputDepth( long Depth )
{
    CAutoLock cObjectLock(m_pLock);
    if (m_State != State_Stopped)
	return VFW_E_NOT_STOPPED;

    DbgLog((LOG_TRACE, TRACE_HIGHEST,TEXT("IBigSwitcher::SetInputDepth to %d"), Depth));
    if (Depth <= 0)
	return E_INVALIDARG;
    else
        return CreateInputPins(Depth);
}

// how many output pins?
//
STDMETHODIMP CBigSwitch::GetOutputDepth( long * pDepth )
{
    CAutoLock cObjectLock(m_pLock);
    CheckPointer(pDepth,E_POINTER);
    if (m_cOutputs == 0)
	return E_UNEXPECTED;
    else
	*pDepth = m_cOutputs;
    return NOERROR;
}


// how many output pins do we have?
//
STDMETHODIMP CBigSwitch::SetOutputDepth( long Depth )
{
    CAutoLock cObjectLock(m_pLock);
    if (m_State != State_Stopped)
	return VFW_E_NOT_STOPPED;

    DbgLog((LOG_TRACE, TRACE_HIGHEST,TEXT("IBigSwitcher::SetOutputDepth to %d"), Depth));
    if (Depth <= 0)
	return E_INVALIDARG;
    else
        return CreateOutputPins(Depth);
}


STDMETHODIMP CBigSwitch::GetVendorString( BSTR * pVendorString )
{
    return E_NOTIMPL;
}


STDMETHODIMP CBigSwitch::GetCaps( long Index, long * pReturn )
{
    return E_NOTIMPL;
}


// which TLDB group this switch is used for
//
STDMETHODIMP CBigSwitch::SetGroupNumber( int n )
{
    CAutoLock cObjectLock(m_pLock);

    if (n < 0)
	return E_INVALIDARG;
    else
	m_nGroupNumber = n;
    return NOERROR;
}


// which TLDB group this switch is used for
//
STDMETHODIMP CBigSwitch::GetGroupNumber( int *pn )
{
    CAutoLock cObjectLock(m_pLock);
    CheckPointer(pn, E_POINTER);

    *pn = m_nGroupNumber;
    return NOERROR;
}


// our current CRANK position
//
STDMETHODIMP CBigSwitch::GetCurrentPosition( REFERENCE_TIME *prt )
{
    CAutoLock cObjectLock(m_pLock);
    CheckPointer(prt, E_POINTER);

    *prt = m_rtCurrent;
    return NOERROR;
}


// !!! only checks for muxing - the graph won't necessarily accomplish anything
// !!! doesn't say if an output won't get data at time 0
// !!! return which inputs go to the same output on failure?
//
// Does the current switch matrix make sense, or can we find something that
// was programmed wrong?  Are we ready to run?
//
STDMETHODIMP CBigSwitch::IsEverythingConnectedRight()
{
    CAutoLock cObjectLock(m_pLock);
    if (m_State != State_Stopped)
	return VFW_E_NOT_STOPPED;

    DbgLog((LOG_TRACE, TRACE_HIGHEST,TEXT("IBigSwitcher::IsEverythingConnectedRight")));
    if (m_cInputs == 0 || m_cOutputs == 0) {
        DbgLog((LOG_TRACE, TRACE_HIGHEST,TEXT("NO - no pins")));
	return VFW_E_NOT_CONNECTED;
    }
    if (m_mtAccept.majortype == GUID_NULL) {
        DbgLog((LOG_TRACE, TRACE_HIGHEST,TEXT("NO - no media type")));
	return VFW_E_INVALIDMEDIATYPE;
    }
    
    // some groups might be empty, but others might not, so don't error

    if (m_dFrameRate <= 0) {
        DbgLog((LOG_TRACE, TRACE_HIGHEST,TEXT("NO - no frame rate set")));
	return E_INVALIDARG;
    }

    // in order for smart recompression to fail gracefully, having an
    // unconnected output isn't an error
    // If there's no sound card, the app can notice RenderOutputPins failing

    // check that the necessary inputs and outputs are connected, and that
    // the times are not too high
    for (int z = 0; z < m_cInputs; z++) {
        CRANK *p = m_pInput[z]->m_pCrankHead;

        if( !IsDynamic( ) )
        {
	    if (p && m_pInput[z]->m_Connected == NULL) {
                DbgLog((LOG_TRACE, TRACE_HIGHEST,TEXT("NO - in %d is not connected"), z));
	        return VFW_E_NOT_CONNECTED;
	    }
        }
        else
        {
	    // sources are connected dynamically
	    if(p && m_pInput[z]->m_Connected == NULL && !m_pInput[z]->m_fIsASource){
                DbgLog((LOG_TRACE, TRACE_HIGHEST,TEXT("NO - in %d is not connected"), z));
	        return VFW_E_NOT_CONNECTED;
	    }
        }

	while (p) {
	    if (p->iOutpin >0 && m_pOutput[p->iOutpin]->m_Connected == NULL) {
		DbgLog((LOG_TRACE, TRACE_HIGHEST,TEXT("NO - out %d is not connected"),
					p->iOutpin));
		return VFW_E_NOT_CONNECTED;
	    }
	    if (p->iOutpin >= 0 && p->rtStart >= m_rtProjectLength) {
		DbgLog((LOG_TRACE, TRACE_HIGHEST,TEXT("NO - out %d connected at time %dms"),
					p->iOutpin, (int)(p->rtStart / 10000)));
		DbgLog((LOG_TRACE, TRACE_HIGHEST,TEXT("   and project length is only %dms"),
					(int)(m_rtProjectLength / 10000)));
		return E_INVALIDARG;
	    }
	    p = p->Next;
	}
    }

    // check that more than one input isn't trying to get at the same output
    // at the same time
    for (z = 0; z < m_cInputs - 1; z++) {
        CRANK *p = m_pInput[z]->m_pCrankHead;
	while (p) {
	    for (int y = z + 1; y < m_cInputs; y++) {
		CRANK *p2 = m_pInput[y]->m_pCrankHead;
		while (p2) {
		    if ((p->iOutpin == p2->iOutpin) && (p->iOutpin != -1) &&
			    ((p2->rtStart >= p->rtStart &&
			    p2->rtStart < p->rtStop) || (p2->rtStop > p->rtStart
			    && p2->rtStop < p->rtStop))) {
        		DbgLog((LOG_TRACE, TRACE_HIGHEST,TEXT("NO - in %d & %d both go to out %d"), z, y, p->iOutpin));
			return E_INVALIDARG;
		    }
		    p2 = p2->Next;
		}
	    }
	    p = p->Next;
	}
    }
    DbgLog((LOG_TRACE, TRACE_HIGHEST,TEXT("YES!")));
    return S_OK;
}


// connect with this media type
//
STDMETHODIMP CBigSwitch::SetMediaType(AM_MEDIA_TYPE *pmt)
{
    CAutoLock cObjectLock(m_pLock);
    CheckPointer(pmt, E_POINTER);
    if (m_State != State_Stopped)
	return VFW_E_NOT_STOPPED;

    DbgLog((LOG_TRACE, TRACE_HIGHEST,TEXT("IBigSwitcher::SetMediaType")));
    for (int i = 0; i < m_cInputs; i++) {
	if (m_pInput[i]->IsConnected())
	    return VFW_E_ALREADY_CONNECTED;
    }
    for (i = 0; i < m_cOutputs; i++) {
	if (m_pOutput[i]->IsConnected())
	    return VFW_E_ALREADY_CONNECTED;
    }

    // Make sure our buffers are going to be big enough to hold a video frame
    // or 1/FPS sec worth of audio.  If we're doing dynamic connections
    // we're not going to connect any sources, so nobody is ever going to
    // tell us how big to make our buffers.  We need to figure it out
    // now or blow up
    // !!! this won't work if the switch accepts compressed audio
    if (pmt->majortype == MEDIATYPE_Audio) {
        ASSERT(IsEqualGUID(pmt->formattype, FORMAT_WaveFormatEx));
	LPWAVEFORMATEX pwfx = (LPWAVEFORMATEX)pmt->pbFormat;
	// a little extra to be safe
	m_cbBuffer = (LONG)(pwfx->nSamplesPerSec / m_dFrameRate * 1.2 *
						pwfx->nBlockAlign);
    } else if (pmt->majortype == MEDIATYPE_Video) {
	if (pmt->lSampleSize) {
	    m_cbBuffer = pmt->lSampleSize;
	} else {
	    //
            if (IsEqualGUID(pmt->formattype, FORMAT_VideoInfo)) {
		VIDEOINFOHEADER *pvi = (VIDEOINFOHEADER *)pmt->pbFormat;
		m_cbBuffer = (LONG)(HEADER(pvi)->biSizeImage);
	        // broken file doesn't have biSizeImage set.  Assume as
	        // big as uncompressed
	        if (m_cbBuffer == 0) {
		    m_cbBuffer = DIBSIZE(*HEADER(pvi));
	        }
	    } else if (IsEqualGUID(pmt->formattype, FORMAT_MPEGVideo)) {
		MPEG1VIDEOINFO *pvi = (MPEG1VIDEOINFO *)pmt->pbFormat;
		m_cbBuffer = (LONG)(pvi->hdr.bmiHeader.biSizeImage);
	        // broken file doesn't have biSizeImage set.  Assume as
	        // big as uncompressed
	        if (m_cbBuffer == 0) {
		    m_cbBuffer = DIBSIZE(pvi->hdr.bmiHeader);
	        }

                // testing for VideoInfo2 or MPEG2Video won't work
                // If we ever support MPEG smart recompression,
                // be careful - biSizeImage is going to be 0.

	    } else {
		// !!! DShow, how can I tell generically?
		ASSERT(FALSE);
		m_cbBuffer = 100000;	// ick ick
	    }
	}
    }

    SaferFreeMediaType(m_mtAccept);
    HRESULT hr = CopyMediaType(&m_mtAccept, pmt);
    SetDirty(TRUE);
    return hr;
}


// what media type are we connecting with?
//
STDMETHODIMP CBigSwitch::GetMediaType(AM_MEDIA_TYPE *pmt)
{
    CAutoLock cObjectLock(m_pLock);
    DbgLog((LOG_TRACE, TRACE_HIGHEST,TEXT("IBigSwitcher::GetMediaType")));
    CheckPointer(pmt, E_POINTER);
    return CopyMediaType(pmt, &m_mtAccept);
}



STDMETHODIMP CBigSwitch::GetProjectLength(REFERENCE_TIME *prt)
{
    CAutoLock cObjectLock(m_pLock);
    DbgLog((LOG_TRACE, TRACE_HIGHEST,TEXT("IBigSwitcher::GetProjectLength")));
    CheckPointer(prt, E_POINTER);
    *prt = m_rtProjectLength;
    return S_OK;
}


STDMETHODIMP CBigSwitch::SetProjectLength(REFERENCE_TIME rt)
{
    CAutoLock cObjectLock(m_pLock);
    if (m_State != State_Stopped)
	return VFW_E_NOT_STOPPED;
    DbgLog((LOG_TRACE, TRACE_HIGHEST,TEXT("IBigSwitcher::SetProjectLength")));
    if (rt < 0)
	return E_INVALIDARG;
    m_rtProjectLength = rt;
    m_rtStop = rt;	// unless told otherwise, play the whole project
    SetDirty(TRUE);
    return S_OK;
}


STDMETHODIMP CBigSwitch::GetFrameRate(double *pd)
{
    CAutoLock cObjectLock(m_pLock);
    CheckPointer(pd, E_POINTER);
    *pd = m_dFrameRate;
    DbgLog((LOG_TRACE, TRACE_HIGHEST,TEXT("IBigSwitcher::GetFrameRate %f"), (float)*pd));
    return S_OK;
}


STDMETHODIMP CBigSwitch::SetFrameRate(double d)
{
    CAutoLock cObjectLock(m_pLock);
    if (m_State != State_Stopped)
	return VFW_E_NOT_STOPPED;
    if (d <= 0.)
	return E_INVALIDARG;
    DbgLog((LOG_TRACE, TRACE_HIGHEST,TEXT("IBigSwitcher::SetFrameRate %d/10 fps"),
						(int)(d * 10)));
    m_dFrameRate = d;
    m_rtCurrent = Frame2Time( Time2Frame( m_rtCurrent, m_dFrameRate ), m_dFrameRate );
    m_rtNext = Frame2Time( Time2Frame( m_rtCurrent, m_dFrameRate ) + 1, m_dFrameRate );

    // for audio, make sure our buffers are going to be big enough to hold
    // enough data for 1/FPS sec worth of audio.  If we're doing dynamic
    // connections, we're not going to connect any sources, so nobody is ever
    // going to tell us how big to make our buffers.  We need to figure it out
    // now or blow up
    if (m_mtAccept.majortype == MEDIATYPE_Audio) {
        ASSERT(IsEqualGUID(m_mtAccept.formattype, FORMAT_WaveFormatEx));
	LPWAVEFORMATEX pwfx = (LPWAVEFORMATEX)m_mtAccept.pbFormat;
	// a little extra to be safe
	m_cbBuffer = (LONG)(pwfx->nSamplesPerSec / m_dFrameRate * 1.2 *
						pwfx->nBlockAlign);
    }

    SetDirty(TRUE);
    return S_OK;
}


STDMETHODIMP CBigSwitch::InputIsASource(int n, BOOL fSource)
{
    if (n < 0 || n >= m_cInputs)
	return E_INVALIDARG;

    m_pInput[n]->m_fIsASource = fSource;
    if (fSource)
        DbgLog((LOG_TRACE, TRACE_HIGHEST,TEXT("IBigSwitch::Input %d is a SOURCE"), n));

    return NOERROR;
}

STDMETHODIMP CBigSwitch::IsInputASource( int n, BOOL * pBool )
{
    CheckPointer( pBool, E_POINTER );

    if( ( n < 0 ) || ( n >= m_cInputs ) )
    {
        return E_INVALIDARG;
    }

    *pBool = m_pInput[n]->m_fIsASource;
    return NOERROR;
}

STDMETHODIMP CBigSwitch::SetPreviewMode(BOOL fPreview)
{
    CAutoLock cObjectLock(m_pLock);
    if (m_State != State_Stopped)
	return VFW_E_NOT_STOPPED;
    DbgLog((LOG_TRACE, TRACE_MEDIUM,TEXT("Switch:  PreviewMode %d"), fPreview));
    m_fPreview = fPreview;
    return NOERROR;
}


STDMETHODIMP CBigSwitch::GetPreviewMode(BOOL *pfPreview)
{
    CAutoLock cObjectLock(m_pLock);
    if (m_State != State_Stopped)
	return VFW_E_NOT_STOPPED;
    CheckPointer(pfPreview, E_POINTER);
    *pfPreview = m_fPreview;
    return NOERROR;
}

STDMETHODIMP CBigSwitch::GetInputPin(int iPin, IPin **ppPin)
{
    CheckPointer(ppPin, E_POINTER);

    if (iPin < 0 || iPin >= m_cInputs)
        return E_INVALIDARG;

    *ppPin = m_pInput[iPin];
    m_pInput[iPin]->AddRef();

    return S_OK;
}

STDMETHODIMP CBigSwitch::GetOutputPin(int iPin, IPin **ppPin)
{
    CheckPointer(ppPin, E_POINTER);

    if (iPin < 0 || iPin >= m_cOutputs)
        return E_INVALIDARG;

    *ppPin = m_pOutput[iPin];
    m_pOutput[iPin]->AddRef();

    return S_OK;
}


// We have to declare ourselves a "live graph" to avoid hanging if we don't
// always deliver frames in pause mode. We do this by returning VFW_S_CANT_CUE

//
// GetPinCount
//
int CBigSwitch::GetPinCount()
{
    return (m_cInputs + m_cOutputs);
}


//
// GetPin
//
CBasePin *CBigSwitch::GetPin(int n)
{
    if (n < 0 || n >= m_cInputs + m_cOutputs)
        return NULL;

    if (n < m_cInputs) {
        return m_pInput[n];
    } else {
	return m_pOutput[n - m_cInputs];
    }
}

// we provide our own pin enumerator because the one in the base class
// takes O(n^2) time and this filter has many pins making pin
// enumeration a huge hotspot
//
HRESULT CBigSwitch::EnumPins(IEnumPins ** ppEnum)
{
    HRESULT hr = S_OK;
    *ppEnum = 0;

    typedef CComEnum<IEnumPins,
        &IID_IEnumPins, IPin*,
        _CopyInterface<IPin> >
        CEnumPin;

    CEnumPin *pep = new CComObject<CEnumPin>;
    if(pep)
    {
        // make an array of pins to send atl enumerator which does an
        // alloc and copy. can't see how to save that step.
        ULONG cPins = m_cInputs + m_cOutputs;
        IPin **rgpPin = new IPin *[cPins];
        if(rgpPin)
        {
            for(LONG i = 0; i < m_cInputs; i++) {
                rgpPin[i] = m_pInput[i];
            }
            for(i = 0; i < m_cOutputs; i++) {
                rgpPin[i + m_cInputs] = m_pOutput[i];
            }

            hr = pep->Init(rgpPin, rgpPin + cPins, 0, AtlFlagCopy);
            if(SUCCEEDED(hr))
            {
                *ppEnum = pep;
                pep->AddRef();
            }
            delete[] rgpPin;
        }
        else
        {
            hr = E_OUTOFMEMORY;
        }

        if(FAILED(hr)) {
            delete pep;
        }
    }
    else
    {
        hr = E_OUTOFMEMORY;
    }

    return hr;
}

//
// CreateInputPins
//
HRESULT CBigSwitch::CreateInputPins(long Depth)
{
    DbgLog((LOG_TRACE, TRACE_LOW, TEXT("CBigSwitch::CreateInputPins")));
    HRESULT hr = NOERROR;
    WCHAR szbuf[40];
    CBigSwitchInputPin *pPin;

    // make a new array as big as we'll need
    //
    CBigSwitchInputPin **pNew = new CBigSwitchInputPin *[Depth];
    if (pNew == NULL)
	return E_OUTOFMEMORY;

    // if we're shrinking the input pin count, delete the extras
    //
    if( Depth < m_cInputs )
    {
        for( int z = Depth ; z < m_cInputs ; z++ )
        {
            delete m_pInput[z];
            m_pInput[z] = NULL;
        }
    }

    // copy over as many as we can from the old array
    //
    for (int z = 0; z < min( Depth, m_cInputs ); z++) {
	pNew[z] = m_pInput[z];
    }

    // if the old array existed, delete it now, since we copied it
    //
    if (m_cInputs)
        delete m_pInput;
    m_pInput = pNew;

    // if we grew the array, create new pins and put them in the array
    //
    if( Depth > m_cInputs )
    {
        for (z = m_cInputs; z < Depth; z++) {
            StringCchPrintf( szbuf, sizeof(szbuf)/sizeof(WCHAR), L"Input %d", z );
            pPin = new CBigSwitchInputPin(NAME("Switch Input"), this, &hr, szbuf);
            if (FAILED(hr) || pPin == NULL) {
                delete pPin;
                return E_OUTOFMEMORY;
            }
 	    m_pInput[z] = pPin;
	    pPin->m_iInpin = z;	// which pin is this?
        }
    }

    m_cInputs = Depth;

    return S_OK;
}


//
// CreateOutputPins
//
HRESULT CBigSwitch::CreateOutputPins(long Depth)
{
    DbgLog((LOG_TRACE, TRACE_LOW, TEXT("CBigSwitch::CreateOutputPins")));
    HRESULT hr = NOERROR;
    WCHAR szbuf[40];
    CBigSwitchOutputPin *pPin;

    CBigSwitchOutputPin **pNew = new CBigSwitchOutputPin *[Depth];
    if (pNew == NULL)
	return E_OUTOFMEMORY;

    if( Depth < m_cOutputs )
    {
        for( int z = Depth ; z < m_cOutputs ; z++ )
        {
            delete m_pOutput[z];
            m_pOutput[z] = NULL;
        }
    }

    for (int z = 0; z < min( Depth,  m_cOutputs ); z++) {
	pNew[z] = m_pOutput[z];
    }

    if (m_cOutputs)
        delete m_pOutput;
    m_pOutput = pNew;

    if( Depth > m_cOutputs )
    {
        for (z = m_cOutputs; z < Depth; z++) {
            StringCchPrintf( szbuf, sizeof(szbuf)/sizeof(WCHAR), L"Output %d", z );
            pPin = new CBigSwitchOutputPin(NAME("Switch Output"), this, &hr, szbuf);
            if (FAILED(hr) || pPin == NULL) {
                delete pPin;
                return E_OUTOFMEMORY;
            }
 	    m_pOutput[z] = pPin;
	    pPin->m_iOutpin = z;	// which pin is this?
        }
    }

    m_cOutputs = Depth;

    return S_OK;
}



//
// IPersistStream
//

// tell our clsid
//
STDMETHODIMP CBigSwitch::GetClassID(CLSID *pClsid)
{
    CheckPointer(pClsid, E_POINTER);
    *pClsid = CLSID_BigSwitch;
    return S_OK;
}


typedef struct {
    REFERENCE_TIME rtStart;
    int iInpin;
    int iOutpin;
} CRANK2;

typedef struct {
    int version;
    long nDynaFlags;	// dynamic or not?
    int InputDepth;
    int OutputDepth;
    int nGroupNumber;
    REFERENCE_TIME rtProjectLength;
    double dFrameRate;
    BOOL fPreviewMode;
    BOOL fIsCompressed;
    AM_MEDIA_TYPE mt; // format is hidden after the array
    int count;
    CRANK2 crank[1];
    // also hidden after the array is the list of which inputs are sources
} saveSwitch;


// persist ourself - we have a bunch of random stuff to save, our media type
// (sans format), an array of queued connections, and finally the format of
// the media type
//
HRESULT CBigSwitch::WriteToStream(IStream *pStream)
{
    DbgLog((LOG_TRACE, TRACE_HIGHEST,TEXT("CBigSwitch::WriteToStream")));

    CheckPointer(pStream, E_POINTER);
    int count = 0;
    int savesize;
    saveSwitch *px;
    CRANK *p;

    // how many queued connections to save?

    for (int i = 0; i < m_cInputs; i++) {
        p = m_pInput[i]->m_pCrankHead;
        while (p) {
	    count++;
	    p = p->Next;
        }
    }

    // how big will our saved data be?
    savesize = sizeof(saveSwitch) + (count - 1) * sizeof(CRANK2) +
					m_mtAccept.cbFormat +
					m_cInputs * sizeof(BOOL);

    // !!! We need to change version number based on whether we're dynamic
    // or not???

    // m_pFilterLoad won't be valid unless we're dynamic
    //
    FILTERLOADINFO *pfli = m_pFilterLoad;
    DWORD cLoadInfo = 0;
    if (pfli) {
        savesize += sizeof(cLoadInfo); // count to load
        while (pfli) {
	    if (pfli->bstrURL)
                savesize += sizeof(FILTERLOADINFO) + sizeof(WCHAR) *
					(lstrlenW(pfli->bstrURL) + 1); //safe
	    else
		savesize += sizeof(FILTERLOADINFO) + sizeof(WCHAR);
	    ASSERT(pfli->cSkew > 0);
	    savesize += sizeof(pfli->cSkew) + pfli->cSkew *
					sizeof(STARTSTOPSKEW);
	    savesize += pfli->mtShare.cbFormat;
	    savesize += sizeof(LONG);	// size of props
	    if (pfli->pSetter) {	// how much to save the props?
		LONG cBlob = 0;
		BYTE *pBlob = NULL;
		pfli->pSetter->SaveToBlob(&cBlob, &pBlob);
		if (cBlob) savesize += cBlob;
	    }
            ++cLoadInfo;
            pfli = pfli->pNext;
        }
    }

    DbgLog((LOG_TRACE, TRACE_HIGHEST,TEXT("Persisted data is %d bytes"), savesize));
    px = (saveSwitch *)QzTaskMemAlloc(savesize);
    if (px == NULL) {
        DbgLog((LOG_ERROR,1,TEXT("*** Out of memory")));
	return E_OUTOFMEMORY;
    }
    px->version = 1;  // version 2 has dynamic stuff in it!
    px->nDynaFlags = m_nDynaFlags;
    px->InputDepth = m_cInputs;
    px->OutputDepth = m_cOutputs;
    px->nGroupNumber = m_nGroupNumber;
    px->rtProjectLength = m_rtProjectLength;
    px->dFrameRate = m_dFrameRate;
    px->fPreviewMode = m_fPreview;
    px->fIsCompressed = m_bIsCompressed;
    px->count = 0;
    // save all the queued connection data
    for (i = 0; i < m_cInputs; i++) {
        p = m_pInput[i]->m_pCrankHead;
        while (p) {
	    px->crank[px->count].rtStart = p->rtStart;
	    px->crank[px->count].iInpin = i;
	    px->crank[px->count].iOutpin = p->iOutpin;
            px->count++;
	    p = p->Next;
        }
    }
    px->mt = m_mtAccept; // AM_MEDIA_TYPE
    // Can't persist pointers
    px->mt.pbFormat = NULL;
    px->mt.pUnk = NULL;		// !!!

    // the format goes after the array
    CopyMemory(&px->crank[px->count], m_mtAccept.pbFormat, m_mtAccept.cbFormat);

    // finally, the array of which inputs are sources
    BOOL *pfSource = (BOOL *)((BYTE *)(&px->crank[px->count]) +
						m_mtAccept.cbFormat);
    for (i = 0; i < m_cInputs; i++){
	*(pfSource + i) = m_pInput[i]->m_fIsASource;
    }

    // but after that, comes the dynamic loading info....
    BYTE *pStuff = (BYTE *) pfSource + m_cInputs * sizeof(BOOL);

    if (cLoadInfo) {
        px->version = 2;  // mark as having dynamic stuff

        CopyMemory(pStuff, (BYTE *) &cLoadInfo, sizeof(cLoadInfo));
        pStuff += sizeof(cLoadInfo);

        pfli = m_pFilterLoad;
        while (pfli) {
            CopyMemory(pStuff, pfli, sizeof(FILTERLOADINFO));
            AM_MEDIA_TYPE *pmt = &(((FILTERLOADINFO *)pStuff)->mtShare);
            pmt->pbFormat = NULL;       // can't persist these as is
            pmt->pUnk = NULL;

	    ((FILTERLOADINFO *)pStuff)->pSetter = NULL;	// can't persist as is

	    int cb;
	    if (pfli->bstrURL)
                cb = sizeof(WCHAR) * (lstrlenW(pfli->bstrURL) + 1); // safe
	    else
                cb = sizeof(WCHAR);

            // hack: overwrite first DWORD with string length
            CopyMemory(pStuff, (BYTE *) &cb, sizeof(cb));

            pStuff += sizeof(FILTERLOADINFO);

	    CopyMemory(pStuff, &pfli->cSkew, sizeof(pfli->cSkew));
            pStuff += sizeof(pfli->cSkew);
	    CopyMemory(pStuff, pfli->pSkew, pfli->cSkew *
							sizeof(STARTSTOPSKEW));
            pStuff += pfli->cSkew * sizeof(STARTSTOPSKEW);

	    if (pfli->bstrURL)
                CopyMemory(pStuff, pfli->bstrURL, cb);
	    else
		*(WCHAR *)pStuff = 0;
            pStuff += cb;

            // now persist the format of the mediatype in the FILTERLOADINFO
            if (pfli->mtShare.cbFormat) {
                CopyMemory(pStuff, pfli->mtShare.pbFormat,
                                                pfli->mtShare.cbFormat);
                pStuff += pfli->mtShare.cbFormat;
            }

	    // now persist the sizeof props, and the props
	    LONG cBlob = 0;
	    BYTE *pBlob = NULL;
	    if (pfli->pSetter) {
		pfli->pSetter->SaveToBlob(&cBlob, &pBlob);
		if (cBlob) {
		    pBlob = (BYTE *)CoTaskMemAlloc(cBlob);
		    if (pBlob == NULL)
			cBlob = 0;	// OOM, can't save
		}
	    }
	    CopyMemory(pStuff, &cBlob, sizeof(cBlob));
	    pStuff += sizeof(LONG);
	    if (cBlob) {
		pfli->pSetter->SaveToBlob(&cBlob, &pBlob);
		CopyMemory(pStuff, pBlob, cBlob);
		pStuff += cBlob;
		CoTaskMemFree(pBlob);
	    }

            pfli = pfli->pNext;
        }
    }

    HRESULT hr = pStream->Write(px, savesize, 0);
    QzTaskMemFree(px);
    if(FAILED(hr)) {
        DbgLog((LOG_ERROR,1,TEXT("*** WriteToStream FAILED")));
        return hr;
    }
    return NOERROR;
}


// load ourself back in
//
HRESULT CBigSwitch::ReadFromStream(IStream *pStream)
{
    DbgLog((LOG_TRACE, TRACE_HIGHEST,TEXT("CBigSwitch::ReadFromStream")));
    CheckPointer(pStream, E_POINTER);

    Reset();	// start over

    // we don't yet know how many saved connections there are
    // all we know we have for sure is the beginning of the struct
    int savesize1 = sizeof(saveSwitch) - sizeof(CRANK2);
    saveSwitch *px = (saveSwitch *)QzTaskMemAlloc(savesize1);
    if (px == NULL) {
        DbgLog((LOG_ERROR,1,TEXT("*** Out of memory")));
	return E_OUTOFMEMORY;
    }

    HRESULT hr = pStream->Read(px, savesize1, 0);
    if(FAILED(hr)) {
        DbgLog((LOG_ERROR,1,TEXT("*** ReadFromStream FAILED")));
        QzTaskMemFree(px);
        return hr;
    }

    if (px->version != 1 && px->version != 2) {
        DbgLog((LOG_ERROR,1,TEXT("*** ERROR! Bad version file")));
        QzTaskMemFree(px);
	return S_OK;
    }

    // how much saved data was there, really?  Get the rest
    int savesize = sizeof(saveSwitch) - sizeof(CRANK2) +
			px->count * sizeof(CRANK2) + px->mt.cbFormat +
			px->InputDepth * sizeof(BOOL);
    DbgLog((LOG_TRACE, TRACE_HIGHEST,TEXT("Persisted data is %d bytes"), savesize));
    px = (saveSwitch *)QzTaskMemRealloc(px, savesize);
    if (px == NULL) {
        DbgLog((LOG_ERROR,1,TEXT("*** Out of memory")));
	return E_OUTOFMEMORY;
    }
    hr = pStream->Read(&(px->crank[0]), savesize - savesize1, 0);
    if(FAILED(hr)) {
        DbgLog((LOG_ERROR,1,TEXT("*** ReadFromStream FAILED")));
        QzTaskMemFree(px);
        return hr;
    }

    SetDynamicReconnectLevel(px->nDynaFlags);
    SetInputDepth(px->InputDepth);
    SetOutputDepth(px->OutputDepth);
    SetGroupNumber(px->nGroupNumber);
    SetProjectLength(px->rtProjectLength);
    SetFrameRate(px->dFrameRate);
    SetPreviewMode(px->fPreviewMode);
    if (px->fIsCompressed)
        SetCompressed();

    // re-program our connection array
    for (int i = 0; i < px->count; i++) {
	SetX2Y(px->crank[i].rtStart, px->crank[i].iInpin, px->crank[i].iOutpin);
    }

    // remember, the format is after the array
    AM_MEDIA_TYPE mt = px->mt;
    mt.pbFormat = (BYTE *)QzTaskMemAlloc(mt.cbFormat);
    if (mt.pbFormat == NULL) {
        QzTaskMemFree(px);
        return E_OUTOFMEMORY;
    }
    CopyMemory(mt.pbFormat, &(px->crank[px->count]), mt.cbFormat);

    // finally, pick out which inputs are sources
    BOOL *pfSource = (BOOL *)((BYTE *)(&px->crank[px->count]) + mt.cbFormat);
    for (i = 0; i < m_cInputs; i++) {
	InputIsASource(i, *(pfSource + i));
    }

    // and after that, load any dynamic information if present
    if (px->version == 2) {
        DWORD   cLoadInfo;

        hr = pStream->Read(&cLoadInfo, sizeof(cLoadInfo), 0);
        if(FAILED(hr)) {
            DbgLog((LOG_ERROR,1,TEXT("*** ReadFromStream FAILED")));
            QzTaskMemFree(px);
            return hr;
        }

        while (cLoadInfo-- > 0) {
            FILTERLOADINFO fli;

            hr = pStream->Read(&fli, sizeof(fli), 0);
            if(FAILED(hr)) {
                DbgLog((LOG_ERROR,1,TEXT("*** ReadFromStream FAILED")));
                QzTaskMemFree(px);
                return hr;
            }

            hr = pStream->Read(&fli.cSkew, sizeof(fli.cSkew), 0);
            if(FAILED(hr)) {
                DbgLog((LOG_ERROR,1,TEXT("*** ReadFromStream FAILED")));
                QzTaskMemFree(px);
                return hr;
            }
	    fli.pSkew = (STARTSTOPSKEW *)CoTaskMemAlloc(fli.cSkew *
						sizeof(STARTSTOPSKEW));
	    if (fli.pSkew == NULL) {
                DbgLog((LOG_ERROR,1,TEXT("*** Out of Memory")));
                QzTaskMemFree(px);
                return E_OUTOFMEMORY;
	    }
            hr = pStream->Read(fli.pSkew, fli.cSkew *
						sizeof(STARTSTOPSKEW), 0);
            if(FAILED(hr)) {
                DbgLog((LOG_ERROR,1,TEXT("*** ReadFromStream FAILED")));
                QzTaskMemFree(px);
                CoTaskMemFree(fli.pSkew);
                return hr;
            }
	
            // hack: overwrite first DWORD with string length
            int cb = (int)(INT_PTR)fli.bstrURL;
	    if (cb > sizeof(WCHAR)) {
                fli.bstrURL = SysAllocStringLen(NULL, (cb / sizeof(WCHAR)) - 1);
		if (fli.bstrURL == NULL) {
    		    SaferFreeMediaType(mt);
                    QzTaskMemFree(px);
                    CoTaskMemFree(fli.pSkew);
		    return E_OUTOFMEMORY;
		}
	    } else {
                fli.bstrURL = NULL;
	    }

            if (fli.bstrURL) {
                hr = pStream->Read(fli.bstrURL, cb, 0);
	    } else  {
		WCHAR wch;
                hr = pStream->Read(&wch, cb, 0);
	    }

            if(FAILED(hr)) {
                DbgLog((LOG_ERROR,1,TEXT("*** ReadFromStream FAILED")));
	        SaferFreeMediaType(mt);
                QzTaskMemFree(px);
                CoTaskMemFree(fli.pSkew);
		if (fli.bstrURL)
		    SysFreeString(fli.bstrURL);
                return hr;
            }

            // get the FILTERLOADINFO media type format
            AM_MEDIA_TYPE *pmt = &fli.mtShare;
            if (pmt->cbFormat) {
                pmt->pbFormat = (BYTE *)QzTaskMemAlloc(pmt->cbFormat);
                if (pmt->pbFormat == NULL) {
                    SaferFreeMediaType(mt);
                    QzTaskMemFree(px);
                    CoTaskMemFree(fli.pSkew);
                    if (fli.bstrURL)
                        SysFreeString(fli.bstrURL);
                    return E_OUTOFMEMORY;
                }
                hr = pStream->Read(pmt->pbFormat, pmt->cbFormat, 0);
            }

	    // now read the props back in
	    LONG cBlob = 0;
	    BYTE *pBlob = NULL;
	    pStream->Read(&cBlob, sizeof(LONG), 0);
	    if (cBlob) {
		pBlob = (BYTE *)CoTaskMemAlloc(cBlob);
		if (pBlob) {
		    pStream->Read(pBlob, cBlob, 0);
		    CoCreateInstance(CLSID_PropertySetter, NULL, CLSCTX_INPROC,
				IID_IPropertySetter, (void **)&fli.pSetter);
		    if (fli.pSetter) {
		        fli.pSetter->LoadFromBlob(cBlob, pBlob);
		    }
		    CoTaskMemFree(pBlob);
		}
	    }
	
            AM_MEDIA_TYPE tempmt;
            ZeroMemory(&tempmt, sizeof(AM_MEDIA_TYPE)); // safe
            hr = AddSourceToConnect(fli.bstrURL, &fli.GUID,
					fli.nStretchMode,
					fli.lStreamNumber,
					fli.dSourceFPS,
					fli.cSkew, fli.pSkew,
					fli.lInputPin, FALSE, 0, tempmt, 0.0,
					fli.pSetter);
            // this represents two things to connect... Audio and video shared
            if (fli.fShare) {
                hr = AddSourceToConnect(NULL, NULL,
					fli.nShareStretchMode,
					fli.lShareStreamNumber,
					0,
					fli.cSkew, fli.pSkew,
					fli.lInputPin,
                                        TRUE, fli.lShareInputPin,
                                        fli.mtShare, fli.dShareFPS,
					NULL);
            }

	    if (fli.pSetter)
		fli.pSetter->Release();
            CoTaskMemFree(fli.pSkew);
            SaferFreeMediaType(fli.mtShare);
	    if (fli.bstrURL)
		SysFreeString(fli.bstrURL);

            if (FAILED(hr)) {
		ASSERT(FALSE);
                DbgLog((LOG_ERROR,1,TEXT("*** AddSourceToConnect FAILED")));
    	        SaferFreeMediaType(mt);
                QzTaskMemFree(px);
                return hr;
            }
        }
    }

    SetMediaType(&mt);
    SaferFreeMediaType(mt);
    QzTaskMemFree(px);
    SetDirty(FALSE);
    return S_OK;
}


// how big is our save data?
//
int CBigSwitch::SizeMax()
{
    int count = 0;
    int savesize;
    for (int i = 0; i < m_cInputs; i++) {
        CRANK *p = m_pInput[i]->m_pCrankHead;
        while (p) {
	    count++;
	    p = p->Next;
        }
    }

    savesize = sizeof(saveSwitch) + (count - 1) * sizeof(CRANK2) +
				m_mtAccept.cbFormat + m_cInputs * sizeof(BOOL);

    // now count the dynamic stuff to save
    //
    FILTERLOADINFO *pfli = m_pFilterLoad;
    DWORD cLoadInfo = 0;
    if (pfli) {
        savesize += sizeof(cLoadInfo); // count to load
        while (pfli) {
	    if (pfli->bstrURL)
                savesize += sizeof(FILTERLOADINFO) + sizeof(WCHAR) *
					(lstrlenW(pfli->bstrURL) + 1); // safe
	    else
		savesize += sizeof(FILTERLOADINFO) + sizeof(WCHAR);
	    ASSERT(pfli->cSkew > 0);
	    savesize += sizeof(pfli->cSkew) + pfli->cSkew *
					sizeof(STARTSTOPSKEW);
	    savesize += pfli->mtShare.cbFormat;
	    savesize += sizeof(LONG);	// size of props
	    if (pfli->pSetter) {	// how much to save the props?
		LONG cBlob = 0;
		BYTE *pBlob = NULL;
		pfli->pSetter->SaveToBlob(&cBlob, &pBlob);
		if (cBlob) savesize += cBlob;
	    }
            ++cLoadInfo;
            pfli = pfli->pNext;
        }
    }

    return savesize;
}



//
// JoinFiltergraph
//
// OK.  It's illegal for a worker thread of a filter to take a refcount on the
// graph, but our worker thread needs to use the graph builder to do dynamic
// graph building.  So we take a non-addref'd copy of a pointer here, and just
// use it later.  We know this won't fault, because before the graph can go
// away, our filter has to be stopped, which will kill the thread that's going
// to use this pointer.
//      So never use this pointer except by the worker thread, and never let the
// filter stream when not in a graph, and you'll be OK.
//
STDMETHODIMP CBigSwitch::JoinFilterGraph(IFilterGraph *pfg, LPCWSTR lpcw)
{
    if (pfg) {
        HRESULT hr = pfg->QueryInterface(IID_IGraphBuilder, (void **)&m_pGBNoRef);
        if (FAILED(hr))
            return hr;
        m_pGBNoRef->Release();
    }

    return CBaseFilter::JoinFilterGraph(pfg, lpcw);
}


//
// Pause
//
// Overriden to handle no input connections
//
STDMETHODIMP CBigSwitch::Pause()
{
    DbgLog((LOG_TRACE, TRACE_HIGHEST,TEXT("CBigSwitch::Pause")));

    CAutoLock cObjectLock(m_pLock);
    HRESULT hr = S_OK;

    // we can't work outside of a graph - dynamic graph building assumes it
    // (see JoinFilterGraph)
    if (m_pGraph == NULL)
        return E_UNEXPECTED;

    if (m_State == State_Stopped) {

#ifdef DEBUG
    m_nSkippedTotal = 0;
#endif

	// every time we stream, reset EOS and delivered count
        m_llFramesDelivered = 0;
	m_fEOS = FALSE;

	m_rtCurrent = m_rtLastSeek;
	m_fDiscon = FALSE;	// start over, no discon
	m_nLastInpin = -1;
        m_cStaleData = 0;

        // reset our number so we don't start off being late
        //
        m_qLastLate = 0;

        hr = IsEverythingConnectedRight();
        if (hr != S_OK) {
            DbgLog((LOG_TRACE, TRACE_HIGHEST,TEXT("*Can't stream: not connected right %x"),
								hr));
	    return hr;
        }

        if( IsDynamic( ) )
        {

            // we may need to know which switch we share sources with.  Switch
            // for group 0 may be responsible for building things for switch 1
            // too.
            // This assumes only group 0 and 1 can share!
            // find out NOW while there are still hardly any filters in the
            // graph (best perf)
            if (!m_pShareSwitch && m_nGroupNumber == 0) {
                FindShareSwitch(&m_pShareSwitch);
            }

            if (!m_pGraphConfig) {
                if (SUCCEEDED(m_pGraph->QueryInterface(IID_IGraphConfig,
						(void **) &m_pGraphConfig))) {
                    m_pGraphConfig->Release(); // don't keep refcount
                }
            }

	    // pull in the initial sources on this higher priority thread now?
	    // NO! NO!  Doing dynamic connections during Pause will deadlock
	    // DoDynamicStuff(m_rtCurrent);

            if (m_pFilterLoad) {
    	        m_hEventThread = CreateEvent(NULL, FALSE, FALSE, NULL);
    	        if (m_hEventThread == NULL) {
		    return E_OUTOFMEMORY;
	        }
                // start the background loading thread....
                if (m_worker.Create(this)) {
                    m_worker.Run();
	        }
            }
	}

        hr = m_pPoolAllocator->Commit();
        if (FAILED(hr))
	    return hr;

        DbgLog((LOG_TRACE, TRACE_HIGHEST,TEXT("CBigSwitch::Pause  done with preparations")));
        // if there's nothing for this switch to do (like in a smart recomp
        // graph where no smart recompression can be done), then we need to send
        // EOS RIGHT NOW! or we hang.

        BOOL fEmpty = TRUE;
        for (int z = 0; z < m_cInputs; z++) {
            CRANK *p = m_pInput[z]->m_pCrankHead;
	    if (p) {
	        fEmpty = FALSE;
	    }
        }
        if (fEmpty) {
	    AllDone();
        }

	// we're never going to send anything.  Send an EOS or we'll hang!
	if (m_rtCurrent >= m_rtProjectLength) {
	    AllDone();
	}

	// pass on the NewSeg before things get started. It may not have
	// been sent yet since the last time we were seeked
        DbgLog((LOG_TRACE,TRACE_HIGHEST,TEXT("Switch:Send NewSeg=%dms"),
				(int)(m_rtLastSeek / 10000)));
        for (int i = 0; i < m_cOutputs; i++) {
	    m_pOutput[i]->DeliverNewSegment(m_rtLastSeek, m_rtStop, 1.0);
        }
    }
	
    return CBaseFilter::Pause();
}


STDMETHODIMP CBigSwitch::Stop()
{
    DbgLog((LOG_TRACE, TRACE_HIGHEST,TEXT("CBigSwitch::Stop")));

    CAutoLock cObjectLock(m_pLock);

    m_pPoolAllocator->Decommit();

    // Do we need to unload the dynamic sources?  No, let's keep them around
    // so the graph can start up quickly again

    if (IsDynamic()) {
	m_worker.m_rt = -1;		// thread looks at this when woken up
        SetEvent(m_hEventThread);	// wake the thread up so it dies quickly
        m_worker.Stop();
        m_worker.Exit();
        m_worker.Close();
        if (m_hEventThread) {
	    CloseHandle(m_hEventThread);
            m_hEventThread = NULL;
        }
    }

    HRESULT hr = CBaseFilter::Stop();

    // Dexter has cyclic graphs, and the filter attached to the inpins may get
    // stopped before the filters attached to our outpins, since they are
    // equal distance from the renderer.  That will hang us, so since we
    // can't make the DXT on our outpin get stopped first, we need to flush it
    // now that we've stopped any further delivers.  This will get around the
    // problem of our filters not being stopped in the right order
    for (int z = 0; z < m_cOutputs; z++) {
        m_pOutput[z]->DeliverBeginFlush();
        m_pOutput[z]->DeliverEndFlush();
    }

    return hr;
}


HRESULT CBigSwitch::UnloadAll()
{
    FILTERLOADINFO *p = m_pFilterLoad;
    HRESULT hr = S_FALSE;
    while (p && SUCCEEDED(hr)) {
        if (p->fLoaded) {
                DbgLog((LOG_TRACE, TRACE_HIGHEST, TEXT("unloading %ls"), p->bstrURL ?
					    p->bstrURL : L"<blank>"));
                hr = CallUnloadSource(p);
        }
        p = p->pNext;
    }
    m_cLoaded = 0;
    if (hr != S_FALSE) {
        // tell whoever cares that we did something
        NotifyEvent(EC_GRAPH_CHANGED,0,0);
    }
    return hr;
}


// Is it time to advance our internal clock?  Let's see what all the inputs are
// up to...
//

BOOL CBigSwitch::TimeToCrank()
{
    CAutoLock cObjectLock(&m_csCrank);

    // in the middle of a seek, cranking could send frames we're not supposed to
    if (m_fSeeking)
	return FALSE;

    int iReady = 0;
    for (int z = 0; z < m_cInputs; z++) {
        CBigSwitchInputPin *pPin = m_pInput[z];
	// an unconnected pin is ready
	if (pPin->IsConnected() == FALSE) {
	    if (IsDynamic()) {
                BOOL fShouldBeConnectedNow = FALSE;
	        if (pPin->OutpinFromTime(m_rtCurrent) != -1)
		    fShouldBeConnectedNow = TRUE;
                if (fShouldBeConnectedNow) {
                    DbgLog((LOG_TRACE, TRACE_LOW, TEXT("? %d UNC, waiting for connect"), z));
                } else {
		    iReady++;
		}
	    } else {
                //DbgLog((LOG_TRACE, TRACE_LOW, TEXT("? %d unconnected, not needed"), z));
                iReady++;
            }
	
        // a pin at EOS is ready
        } else if (pPin->m_fEOS) {
    	    DbgLog((LOG_TRACE, TRACE_LOW, TEXT("? %d EOS"), z));
	    iReady++;
	
        // a pin that is blocked waiting for time to pass is ready
        } else if (pPin->m_rtBlock >= 0) {
    	    DbgLog((LOG_TRACE, TRACE_LOW, TEXT("? %d blocked"), z));
	    iReady++;
	// a pin that has already delivered at this current time is ready
	// if it isn't a source (no data is being pushed to it)
        } else if (!pPin->m_fIsASource && pPin->m_rtLastDelivered >= m_rtNext) {
    	    DbgLog((LOG_TRACE, TRACE_LOW, TEXT("? %d done"), z));
	    iReady++;
	// since this is a source, we're waiting for more data to be pushed
        } else if (pPin->m_fIsASource && pPin->m_rtLastDelivered >= m_rtNext) {
    	    DbgLog((LOG_TRACE, TRACE_LOW, TEXT("? %d done/wait"), z));
	// this pin is NOT ready
	// a recursive pin that is not supposed to deliver anything for a while
        } else if (!pPin->m_fIsASource && pPin->OutpinFromTime(m_rtCurrent) == -1) {
    	    DbgLog((LOG_TRACE, TRACE_LOW, TEXT("? %d unused"), z));
	    iReady++;
	// a pin that is never needed again
	} else if (pPin->OutpinFromTime(m_rtCurrent) == -1 &&
			pPin->NextOutpinFromTime(m_rtCurrent, NULL) == -1) {
    	    DbgLog((LOG_TRACE, TRACE_LOW, TEXT("? %d not needed anymore"), z));
	    iReady++;
	} else {
    	    DbgLog((LOG_TRACE, TRACE_LOW, TEXT("? %d waiting..."), z));
        }
    }
    // If all pins are ready, then we are ready!
    return (iReady == m_cInputs);
}


HRESULT CBigSwitch::Crank()
{
    CAutoLock cObjectLock(&m_csCrank);

    REFERENCE_TIME rt = CrankTime();
    return ActualCrank(rt);
}


REFERENCE_TIME CBigSwitch::CrankTime()
{
    CAutoLock cObjectLock(&m_csCrank);

    // to handle intermittent data of different types,
    // I'm going to crank to the next available time, not up a fixed amount
    REFERENCE_TIME rt = MAX_TIME, rtT;
    for (int z = 0; z < m_cInputs; z++) {
        CBigSwitchInputPin *pPin = m_pInput[z];
	// some pins are blocked just to keep from wasting time, but don't go
	// anywhere
	if (pPin->m_rtBlock >= 0 && pPin->OutpinFromTime(pPin->m_rtBlock) >= 0){
	    if (pPin->m_rtBlock > m_rtCurrent && pPin->m_rtBlock < rt)
	        rt = pPin->m_rtBlock;
        // if it's at EOS, we won't get more data so waiting for any will hang
	} else if (pPin->m_fIsASource && pPin->OutpinFromTime(m_rtCurrent)== -1
			&& pPin->NextOutpinFromTime(m_rtCurrent, &rtT) >= 0 &&
                        pPin->m_fEOS == FALSE) {
	    if (rtT < rt)
		rt = rtT;
	}
    }
    return rt;
}


// when is the next time any pin has anything to do?
//
REFERENCE_TIME CBigSwitch::NextInterestingTime(REFERENCE_TIME rtNow)
{
    CAutoLock cObjectLock(&m_csCrank);

    REFERENCE_TIME rt = MAX_TIME, rtT;
    for (int z = 0; z < m_cInputs; z++) {
        CBigSwitchInputPin *pPin = m_pInput[z];
	// this pin has something to do now
	if (pPin->m_fIsASource && pPin->OutpinFromTime(rtNow) >= 0) {
	    rt = rtNow;
	    break;
	// this pin will have something to do in the future
	} else if (pPin->m_fIsASource && pPin->OutpinFromTime(rtNow)== -1
			&& pPin->NextOutpinFromTime(rtNow, &rtT) >= 0) {
	    if (rtT < rt) {
	        rt = rtT;
	    }
	}
    }
    return rt;
}

// advance our internal clock
//
HRESULT CBigSwitch::ActualCrank(REFERENCE_TIME rt)
{
    CAutoLock cObjectLock(&m_csCrank);

    // are we cranking further than 1 frame ahead? That would be a discontinuity
    if (rt > m_rtCurrent + (REFERENCE_TIME)(UNITS / m_dFrameRate * 1.5)) {
	// NO! smart recompression of ASF thinks every frame is a discont, and
	// refuses to use smart recompression
	// m_fDiscon = TRUE;
    }

    m_rtCurrent = rt;
    DWORDLONG dwl = Time2Frame(m_rtCurrent, m_dFrameRate);
    m_rtNext = Frame2Time(dwl + 1, m_dFrameRate);

    DbgLog((LOG_TRACE, TRACE_LOW, TEXT("CRANK to %dms"), (int)(m_rtCurrent / 10000)));

    // If a pin was waiting until this time to unblock, then unblock it now
    for (int z = 0; z < m_cInputs; z++) {
        CBigSwitchInputPin *pPin = m_pInput[z];
	// the unblock time is before Next, and this pin is connected
	// to a valid output then, so unblock it!
	if (pPin->m_rtBlock >= 0 && pPin->m_rtBlock < m_rtNext &&
				pPin->OutpinFromTime(pPin->m_rtBlock) >= 0) {
            DbgLog((LOG_TRACE, TRACE_LOW, TEXT("Unblocking %d"), z));
	    pPin->m_rtBlock = -1;
	    SetEvent(pPin->m_hEventBlock);
	}
    }

    // If all inputs are at EOS, we're all done!  Yay!
    // If all inputs are blocked or at EOS, we're in trouble! (unless we're doing
    //     dynamic reconnection - then we could still be saved)
    int iEOS = 0, iBlock = 0;
    for (z = 0; z < m_cInputs; z++) {
	if (m_pInput[z]->m_fEOS)
	    iEOS++;
	else if (m_pInput[z]->m_rtBlock >= 0)
	    iBlock++;
    }

    if (iEOS == m_cInputs) {
        DbgLog((LOG_TRACE, TRACE_HIGHEST,TEXT("*** ALL INPUTS AT EOS!")));
	m_rtCurrent = m_rtProjectLength;
    } else if (iEOS + iBlock == m_cInputs && !m_fSeeking &&
					    m_rtCurrent < m_rtProjectLength)
    {
        if( !IsDynamic( ) )
        {
            DbgLog((LOG_TRACE, TRACE_HIGHEST,TEXT("*** I AM HUNG!!!")));
            DbgLog((LOG_TRACE, TRACE_HIGHEST,TEXT("*** I AM HUNG!!!")));
            DbgLog((LOG_TRACE, TRACE_HIGHEST,TEXT("*** I AM HUNG!!!")));
 	    ASSERT(FALSE);
        }
    }

    // Are we completely finished yet?
    if (m_rtCurrent >= m_rtStop) {
	AllDone();
    }

    return NOERROR;
}


// All done.  Stop processing.
//
HRESULT CBigSwitch::AllDone()
{
    CAutoLock cObjectLock(&m_csCrank);

    // give the final renderer its EOS.
    if (!m_fEOS) {
        DbgLog((LOG_TRACE, TRACE_HIGHEST,TEXT("*** ALL DONE!  Delivering EOS")));
        m_pOutput[0]->DeliverEndOfStream();
    }

    // !!! Fire all events... is this right?
    m_fEOS = TRUE;

    for (int z = 0; z < m_cInputs; z++) {
	SetEvent(m_pInput[z]->m_hEventBlock);
    }

    // if you try to DeliverBeginFlush/DeliverEndFlush, you'll get into
    // an infinite flush loop

    return NOERROR;
}



HRESULT CBigSwitch::GetOutputBuffering(int *pnBuffer)
{
    CheckPointer( pnBuffer, E_POINTER );
    *pnBuffer = m_nOutputBuffering;
    return NOERROR;

}


HRESULT CBigSwitch::SetOutputBuffering(int nBuffer)
{
    // minimum 2, or we could hang.  If there's only 1, and the FRC is doing
    // a data copy to avoid giving the switch a read only buffer, the FRC has
    // a ref on the only pool buffer.   Then it goes through a DXT and another
    // switch input needs a pool buffer, because it's own buffer is still
    // addrefed by the output queue.  HANG.  If the FRC doesn't call GetBuffer
    // twice we don't have this problem
    if (nBuffer <=1)
	return E_INVALIDARG;
    m_nOutputBuffering = nBuffer;
    return NOERROR;
}

// merge some new skews into the existing ones sorted by timeline time
// !!! should signal error if skew ranges overlap in timeline time, but I know
// that won't happen (?)
// NOTE: MergeSkews operates on ONE source, by the pointer "p"
//
STDMETHODIMP CBigSwitch::MergeSkews(FILTERLOADINFO *p, int cSkew, STARTSTOPSKEW *pSkew)
{
    // calculate the total amount of skews we MIGHT need (we may merge some)
    int cTotal = p->cSkew + cSkew;

    // how many of the new skews have 0 rates in them? These are just "stop extenders" and won't
    // add another skew to our list. Shorten our cTotal by that many
    for( int i = 0 ; i < cSkew ; i++ )
    {
        if( pSkew[i].dRate == 0.0 )
        {
            cTotal--;
        }
    }

    STARTSTOPSKEW *pNew = (STARTSTOPSKEW *)CoTaskMemAlloc(cTotal *
					sizeof(STARTSTOPSKEW));
    if (pNew == NULL)
    {
	return E_OUTOFMEMORY;
    }

    int OldIndex = 0;
    int NewIndex = 0;

    int z = 0;
    while( 1 )
    {
        STARTSTOPSKEW * pOldUnit = &p->pSkew[OldIndex];
        STARTSTOPSKEW * pNewUnit = &pSkew[NewIndex];

        if( OldIndex < p->cSkew && NewIndex < cSkew )
        {
            REFERENCE_TIME OldTLStart = SkewTimelineStart( pOldUnit );
            REFERENCE_TIME NewTLStart = SkewTimelineStart( pNewUnit );

            if( OldTLStart < NewTLStart )
            {
                ASSERT( z < cTotal );
                pNew[z++] = *pOldUnit;
                OldIndex++;
            }
            else
            {
                if( pNewUnit->dRate == 0.0 )
                {
                    // adjust the rate of the old one
                    //
                    ASSERT( z > 0 );
                    pNew[z-1].rtStop = pNewUnit->rtStop;
                }
                else
                {
                    ASSERT( z < cTotal );
                    pNew[z++] = *pNewUnit;
                }
                NewIndex++;
            }
        }
        else if( OldIndex < p->cSkew )
        {
            ASSERT( z < cTotal );
            pNew[z++] = *pOldUnit;
            OldIndex++;
        }
        else if( NewIndex < cSkew )
        {
            if( pNewUnit->dRate == 0.0 )
            {
                // adjust the rate of the old one
                //
                ASSERT( z > 0 );
                pNew[z-1].rtStop = pNewUnit->rtStop;
            }
            else
            {
                ASSERT( z < cTotal );
                pNew[z++] = *pNewUnit;
            }
            NewIndex++;
        }
        else
        {
            break;
        }
    }

    // free up the old array
    if (p->cSkew)
    {
        CoTaskMemFree(p->pSkew);
    }

    p->pSkew = pNew;
    p->cSkew = cTotal;

    return S_OK;
}

STDMETHODIMP CBigSwitch::SetDynamicReconnectLevel(long Level)
{
/*
    if (m_cInputs > 0) {
	return E_UNEXPECTED;
    }
*/
    m_nDynaFlags = Level;
    return S_OK;
}


STDMETHODIMP CBigSwitch::GetDynamicReconnectLevel(long *pLevel)
{
    CheckPointer(pLevel, E_POINTER);
    *pLevel = m_nDynaFlags;
    return S_OK;
}

// this is really asking us, ARE YOUR SOURCES DYNAMIC?
// (because that's all we do right now, this is a useless function)
BOOL CBigSwitch::IsDynamic()
{
    if( m_nDynaFlags & CONNECTF_DYNAMIC_SOURCES )
        return TRUE;
    return FALSE;
}


// dynamic graph stuff. AddSourceToConnect is CURRENTLY called for each
// source (real and not) one skew at a time
//
STDMETHODIMP CBigSwitch::AddSourceToConnect(BSTR bstrURL, const GUID *pGuid,
			       int nStretchMode,
			       long lStreamNumber,
			       double SourceFPS,
                               int cSkew, STARTSTOPSKEW *pSkew,
                               long lInputPin,
                               BOOL fShare,             // sharing
                               long lShareInputPin,     //
                               AM_MEDIA_TYPE mtShare,   //
                               double dShareFPS,        //
			       IPropertySetter *pSetter)
{
    if( !IsDynamic( ) )
    {
        return E_NOTIMPL;
    }

    HRESULT hr;
    if (m_cInputs <= lInputPin)
	return E_INVALIDARG;

    // validatefilename checks for null too, so only if 
    // it's non-null do we validate it
    //
    if( SUCCEEDED( ValidateFilenameIsntNULL( bstrURL ) ) )
    {
        size_t urllen = 0;
        hr = StringCchLength( bstrURL, _MAX_PATH, &urllen );
        if( FAILED( hr ) )
        {
            return hr;
        }
    }

    CAutoLock lock(&m_csFilterLoad);

    DbgLog((LOG_TRACE, TRACE_LOW, TEXT("Switch:AddSourceToConnect...")));

    FILTERLOADINFO *p = m_pFilterLoad, *pNew, *pP = NULL;

    // is this source going to the same pin as a previous source?  Every
    // attribute better match, or that's illegal!  If so, we can re-use this
    // source for multiple skews that don't overlap
    //
    while (p) {
	if (p->lInputPin == lInputPin) {
            // we're being told to make 2 branches of the source at once
            if (fShare == TRUE) {
                DbgLog((LOG_TRACE,1,TEXT("SHARING: this SRC is shared with another switch")));
                // better not be sharing and re-using at the same time
                ASSERT(p->cSkew == 1);
                ASSERT(cSkew == 1);
                p->fShare = TRUE;
                p->lShareInputPin = lShareInputPin;
                hr = CopyMediaType(&p->mtShare, &mtShare);
                if( FAILED( hr ) )
                {
                    return hr;
                }
                p->dShareFPS = dShareFPS;
                p->nShareStretchMode = nStretchMode;
                p->lShareStreamNumber = lStreamNumber;
                // !!! I don't triple check that skew/name/etc. all matches
                return S_OK;
            } else if (p->nStretchMode == nStretchMode &&
			p->lStreamNumber == lStreamNumber &&
			p->dSourceFPS == SourceFPS) {
		if ((hr = MergeSkews(p, cSkew, pSkew)) != S_OK) {
    		    DbgLog((LOG_ERROR,1,TEXT("*** ERROR: Merging skews")));
		    return hr;
		}
    		SetDirty(TRUE);
    		return S_OK;
	    } else {
    		DbgLog((LOG_ERROR,1,TEXT("*** ERROR: RE-USE source doesn't match!")));
		return E_INVALIDARG;
	    }
	}
	p = p->pNext;
    }

    p = m_pFilterLoad;

    pNew = new FILTERLOADINFO;
    if (pNew == NULL)
	return E_OUTOFMEMORY;
    ZeroMemory(pNew, sizeof(FILTERLOADINFO)); // safe, zero out sharing bits

    // !!! insert into our linked list sorted by the earliest time needed.

    // find the place to insert it
    //
    while (p && p->pSkew->rtStart + p->pSkew->rtSkew <
					pSkew->rtStart + pSkew->rtSkew)
    {
	pP = p;
	p = p->pNext;
    }

    // allocate some space for the string
    //
    pNew->bstrURL = SysAllocString(bstrURL); // safe, bounded
    if (bstrURL && pNew->bstrURL == NULL) {
	delete pNew;
	return E_OUTOFMEMORY;
    }

    // set the props on the new struct. This struct will define
    // what sources we want to load and at what time
    //
    if (pGuid)
        pNew->GUID = *pGuid;
    else
        pNew->GUID = GUID_NULL;
    pNew->nStretchMode = nStretchMode;
    pNew->lStreamNumber = lStreamNumber;
    pNew->dSourceFPS = SourceFPS;
    pNew->cSkew = cSkew;
    pNew->pSkew = (STARTSTOPSKEW *)CoTaskMemAlloc(cSkew *
						sizeof(STARTSTOPSKEW));
    if (pNew->pSkew == NULL) {
	SysFreeString(pNew->bstrURL);
	delete pNew;
	return E_OUTOFMEMORY;
    }
    CopyMemory(pNew->pSkew, pSkew, cSkew * sizeof(STARTSTOPSKEW));
    pNew->lInputPin = lInputPin;
    pNew->fLoaded = FALSE;
    pNew->pSetter = pSetter;
    if (pSetter) pSetter->AddRef();

    // inject the new struct in the linked list
    //
    pNew->pNext = p;
    if (pP == NULL)
        m_pFilterLoad = pNew;
    else
        pP->pNext = pNew;

    // make sure we know this is a source
    //
    InputIsASource(lInputPin, TRUE);

    SetDirty(TRUE);

    return S_OK;
}


// !!! David, why is this never called?
//
STDMETHODIMP CBigSwitch::Reconfigure(PVOID pvContext, DWORD dwFlags)
{
    FILTERLOADINFO *pInfo = (FILTERLOADINFO *) pvContext;

    DbgLog((LOG_TRACE, TRACE_LOW,  TEXT("CBigSwitch::Reconfigure")));

    if (dwFlags & 1) {
        return LoadSource(pInfo);
    } else {
        return UnloadSource(pInfo);
    }
}

HRESULT CBigSwitch::CallLoadSource(FILTERLOADINFO *pInfo)
{
    if (!m_pGraphConfig) {
        DbgLog((LOG_TRACE, TRACE_HIGHEST, TEXT("No IGraphConfig, calling immediately")));

        return LoadSource(pInfo);
    }

    DbgLog((LOG_TRACE, TRACE_LOW,  TEXT("calling LoadSource through IGraphConfig::Reconfigure")));
    return m_pGraphConfig->Reconfigure(this, pInfo, 1, m_worker.GetRequestHandle());
}

HRESULT CBigSwitch::CallUnloadSource(FILTERLOADINFO *pInfo)
{
    if (!m_pGraphConfig) {
        DbgLog((LOG_TRACE, TRACE_HIGHEST,TEXT("No IGraphConfig, calling UnloadSource immediately")));
        return UnloadSource(pInfo);
    }

    DbgLog((LOG_TRACE, TRACE_LOW, TEXT("calling UnloadSource through IGraphConfig::Reconfigure")));
    return m_pGraphConfig->Reconfigure(this, pInfo, 0, m_worker.GetRequestHandle());
}

HRESULT CBigSwitch::LoadSource(FILTERLOADINFO *pInfo)
{

#ifdef DEBUG
    LONG lTime = timeGetTime();
#endif

    HRESULT hr = S_OK;

    IPin *pSwitchIn = m_pInput[pInfo->lInputPin];

    // is this a real source, or black/silence?
    BOOL fSource = TRUE;
    if ((pInfo->bstrURL == NULL || lstrlenW(pInfo->bstrURL) == 1) && // safe
			pInfo->GUID == GUID_NULL)
	fSource = FALSE;


    CComPtr< IPin > pOutput;
    IBaseFilter *pDangly = NULL;
    hr = BuildSourcePart(
        m_pGBNoRef,
        fSource,
        pInfo->dSourceFPS,
	&m_mtAccept,
        m_dFrameRate,
	pInfo->lStreamNumber,
        pInfo->nStretchMode,
	pInfo->cSkew,
        pInfo->pSkew,
        this,
        pInfo->bstrURL,
        &pInfo->GUID,
	NULL,
	&pOutput,
        0,
        m_pDeadGraph,
        m_bIsCompressed,
        NULL,       // medloc filter strings
        0,          // medloc flags
        NULL,       // medloc chain callback
	pInfo->pSetter,	// props for the source
        &pDangly);      // NOT ADDREF'D revived this extra chain from the cache

    if (FAILED(hr)) {
	AllDone();	 // otherwise we could hang
	return hr;
    }

    // connect newly created source chain to the Switcher
    hr = m_pGBNoRef->Connect(pOutput, pSwitchIn);
    DbgLog((LOG_TRACE, TRACE_HIGHEST,TEXT("DYN connect to switcher returned %x"), hr));

    // we need to connect up the other switch too, that we are sharing with
    //
    IPin *pShareSwitchIn = NULL;
    if (pInfo->fShare) {
        DbgLog((LOG_TRACE,TRACE_HIGHEST,TEXT("Need to connect shared src to another switch"), hr));
        IPin *pSplitPin;
        pSplitPin = FindOtherSplitterPin(pOutput, pInfo->mtShare.majortype,
                        pInfo->lShareStreamNumber);

        // we are going to use the extra dangly chain we revived, so we don't
        // have to worry about killing it
        CComPtr <IPin> pDIn;
        if (pSplitPin)
            pSplitPin->ConnectedTo(&pDIn);
        if (pDIn) {
            PIN_INFO pinfo;
            pDIn->QueryPinInfo(&pinfo);
            if (pinfo.pFilter) pinfo.pFilter->Release();
            // the chain we are going to build is the extra chain that was built
            if (pinfo.pFilter == pDangly) {
                pDangly = NULL;
                DbgLog((LOG_TRACE,1,TEXT("We are using the extra chain created by BuildSourcePart")));
            }
        }

        pOutput.Release();      // re-using it below
        if (SUCCEEDED(hr)) {
            hr = BuildSourcePart(
                m_pGBNoRef,
                fSource,
                0,                          // 0 if sharing
	        &pInfo->mtShare,            // shared one?
                pInfo->dShareFPS,           // shared one?
	        pInfo->lShareStreamNumber,  // shared one?
                pInfo->nShareStretchMode,   // shared one?
	        pInfo->cSkew,
                pInfo->pSkew,
                this,
                pInfo->bstrURL,
                &pInfo->GUID,
	        pSplitPin,                  // Use this share pin
	        &pOutput,
                0,
                m_pDeadGraph,
                FALSE,
                NULL,       // medloc filter strings
                0,          // medloc flags
                NULL,       // medloc chain callback
	        NULL, NULL);// props for the source
        }

        if (FAILED(hr)) {
	    AllDone();	 // otherwise we could hang
	    return hr;
        }

        // connect other branch to the other switcher

        // what happened to the other switcher?
        if (!m_pShareSwitch) {
            ASSERT(FALSE);
	    AllDone();	 // otherwise we could hang
	    return E_UNEXPECTED;
        }
        hr= m_pShareSwitch->GetInputPin(pInfo->lShareInputPin, &pShareSwitchIn);
        if (FAILED(hr)) {
            ASSERT(FALSE);
	    AllDone();	 // otherwise we could hang
	    return hr;
        }

        hr = m_pGBNoRef->Connect(pOutput, pShareSwitchIn);
        DbgLog((LOG_TRACE, TRACE_HIGHEST,TEXT("DYN CONNECT shared src to other switch returned %x"),
                                                                 hr));
    }

    // making the source chain revived an extra appendage for a shared source
    // that is not going to be used... kill it
    if (pDangly) {
        DbgLog((LOG_TRACE,TRACE_HIGHEST,TEXT("Need to KILL unused revived appendage")));
	IPin *pDIn = GetInPin(pDangly, 0);
	ASSERT(pDIn);
	CComPtr <IPin> pOut;
	hr = pDIn->ConnectedTo(&pOut);
	ASSERT(pOut);
	pDIn->Disconnect();
	pOut->Disconnect();
	RemoveDownstreamFromFilter(pDangly);
    }

    // put the new filters into the same state as the rest of the graph.
    if (m_State != State_Stopped) {

        // active hasn't been called yet on this pin, so we call it.
        hr = m_pInput[pInfo->lInputPin]->Active();
        ASSERT(SUCCEEDED(hr));

        // also call active on the shared switch pin, if it exists
        if (pInfo->fShare) {
            CBigSwitchInputPin *pSIn = NULL;
            pSIn = static_cast <CBigSwitchInputPin *>(pShareSwitchIn); // !!!
            ASSERT(pSIn);
            hr = pSIn->Active();
            ASSERT(SUCCEEDED(hr));
        }

        // if we're sharing a source, make sure it gets paused LAST, after
        // both chains are paused
        //
        if (SUCCEEDED(hr)) {
            // pause chain (don't pause start filter if there are 2 chains)
            hr = StartUpstreamFromPin(pSwitchIn, FALSE, !pInfo->fShare);
            ASSERT(SUCCEEDED(hr));

            // pause 2nd chain (including start filter)
            if (pInfo->fShare) {
                hr = StartUpstreamFromPin(pShareSwitchIn, FALSE, TRUE);
                ASSERT(SUCCEEDED(hr));
            }

            if (SUCCEEDED(hr) && m_State == State_Running) {
                // run chain (don't run start filter if there are 2 chains)
                hr = StartUpstreamFromPin(pSwitchIn, TRUE, !pInfo->fShare);
                ASSERT(SUCCEEDED(hr));

                if (pInfo->fShare) {
                    // run 2nd chain (including start filter)
                    hr = StartUpstreamFromPin(pShareSwitchIn, TRUE, TRUE);
                    ASSERT(SUCCEEDED(hr));
                }
            }
        }
    }
    if (pShareSwitchIn)
        pShareSwitchIn->Release();

    pInfo->fLoaded = TRUE; // !!! only if it worked?
    m_cLoaded++;

#ifdef DEBUG
    lTime = timeGetTime() - lTime;
    DbgLog((LOG_TRACE, TRACE_HIGHEST,TEXT("LoadSource %ls returning %x   (time = %d ms)"), pInfo->bstrURL, hr, lTime));
#endif

    return hr;
}


HRESULT CBigSwitch::UnloadSource(FILTERLOADINFO *pInfo)
{
#ifdef DEBUG
    LONG lTime = timeGetTime();
#endif
    HRESULT hr = S_OK;

    // somebody might have disconnected it on us already.  Even if it fails,
    // decrement our count
    pInfo->fLoaded = FALSE;
    m_cLoaded--;

    // which input pin is connected to this source
    IPin *pSwitchIn = m_pInput[pInfo->lInputPin];

    // Get the other switch's input pin that is sharing this source, if needed
    IPin *pShareIn = NULL;
    if (pInfo->fShare && m_pShareSwitch) {
        hr = m_pShareSwitch->GetInputPin(pInfo->lShareInputPin, &pShareIn);
        ASSERT(pShareIn);
    }

    if (m_State != State_Stopped) {

        if (m_State == State_Running) {

            // pause filters upstream of this pin (don't pause the first filter
            // in the chain yet if we're sharing the source - do it last)
            hr = StopUpstreamFromPin(pSwitchIn, TRUE, !pShareIn);
            ASSERT(SUCCEEDED(hr));

            if (pShareIn) {
                hr = StopUpstreamFromPin(pShareIn, TRUE, TRUE);
                ASSERT(SUCCEEDED(hr));
            }
        }

        // stop the filters prior to removal

        if (SUCCEEDED(hr)) {

            // first stop our own pin
            hr = m_pInput[pInfo->lInputPin]->Inactive();
            ASSERT(SUCCEEDED(hr));

            // now stop the shared pin
            if (pShareIn) {
                CBigSwitchInputPin *pSIn = NULL;
                pSIn = static_cast <CBigSwitchInputPin *>(pShareIn); // !!!
                ASSERT(pSIn);
                hr = pSIn->Inactive();
            }
        }

        // stop the chain (but not the source filter if it's shared)
        hr = StopUpstreamFromPin(pSwitchIn, FALSE, !pShareIn);
        ASSERT(SUCCEEDED(hr));

        // stop the shared chain (and the source filter)
        if (pShareIn) {
            hr = StopUpstreamFromPin(pShareIn, FALSE, TRUE);
            ASSERT(SUCCEEDED(hr));
        }
    }

    // now remove the chain(s) of source filters
    //
    hr = RemoveUpstreamFromPin(pSwitchIn);
    ASSERT(SUCCEEDED(hr));
    if (pShareIn) {
        hr = RemoveUpstreamFromPin(pShareIn);
        ASSERT(SUCCEEDED(hr));
        pShareIn->Release();
    }

#ifdef DEBUG
    lTime = timeGetTime() - lTime;
    DbgLog((LOG_TRACE, TRACE_HIGHEST,TEXT("UnloadSource %ls returning %x   (time = %d ms)"), pInfo->bstrURL, hr, lTime));
#endif

    return hr;
}

// constants defining how long to keep things loaded
#define UNLOAD_BEFORE_TIME      (30 * UNITS)    // unload if not needed until after 30 seconds
#define UNLOAD_AFTER_TIME       (5 * UNITS)     // unload if last used 5 seconds ago
//#define LOAD_BEFORE_TIME        (10 * UNITS)    // load if needed in next 10 seconds
#define LOAD_BEFORE_TIME        (5 * UNITS)    // load if needed in next 10 seconds
#define LOAD_AFTER_TIME         (0 * UNITS)     // load if needed before now

//
// never call this when not streaming
//
HRESULT CBigSwitch::DoDynamicStuff(REFERENCE_TIME rt)
{
    HRESULT hr = S_FALSE;

    if (rt < 0)
	return S_OK;

    CAutoLock lock(&m_csFilterLoad);

    DbgLog((LOG_TRACE, TRACE_LOW, TEXT("DoDynamicStuff at %dms"), (int)(rt / 10000)));

    // could just use m_rtCurrent?

    // should we have a flag, or use rt == -1, to indicate "unload all"?

    // !!! currently this is called with the filter lock held, is this bad?

    if (rt == MAX_TIME) {
        DbgLog((LOG_TRACE, TRACE_HIGHEST,TEXT("DoDynamicStuff(MAX_TIME), ignoring")));
        return S_OK;
    }

    // Even though it's time rt, if nothing is happening on any pins until time
    // rt + x + LOAD_BEFORE_TIME, we need to bring in the source for that NOW,
    // because we will be cranking straight to rt + x soon, so that source
    // really is needed! So let's figure out what time it really would be after
    // cranking... (but we can't actually crank, that will mess everything up
    // and it's going to magically crank itself later anyway)
    //
    REFERENCE_TIME rtOld = rt;
    rt = NextInterestingTime(rtOld);
    if (rt != rtOld) {
        DbgLog((LOG_TRACE, TRACE_LOW, TEXT("WILL BE CRANKING - DoDynamicStuff at %dms"),
							(int)(rt / 10000)));
    }

    // first, look for things to unload
    FILTERLOADINFO *p = m_pFilterLoad;

    while (p && SUCCEEDED(hr)) {

	// UNLOAD a source if there are >50 sources loaded and this one isn't
	// needed.  This is done mostly because you can't open >75 ICM codec
	// instances at the same time
        if (p->fLoaded && m_cLoaded > MAX_SOURCES_LOADED) {
	    // a source must not be needed for any of its segments in order
	    // to truly not be needed
	    int yy = 0;
            REFERENCE_TIME rtTLStart, rtTLStop, rtTLDur;
	    for (int zz=0; zz<p->cSkew; zz++) {
                // !!! pre-calculate this
	        rtTLDur = p->pSkew[zz].rtStop - p->pSkew[zz].rtStart;
	        rtTLDur = (REFERENCE_TIME)(rtTLDur / p->pSkew[zz].dRate);
                rtTLStart = p->pSkew[zz].rtStart + p->pSkew[zz].rtSkew;
                rtTLStop = rtTLStart + rtTLDur;
		if ( (rtTLStart > rt + UNLOAD_BEFORE_TIME ||
            		rtTLStop <= rt - UNLOAD_AFTER_TIME)) {
		    yy++;
		} else {
		    break;
		}
	    }
            if (yy == p->cSkew) {

                // DO NOT unload a shared source, unless the shared switch is
                // also done with it!
                DbgLog((LOG_TRACE,1,TEXT("Time to UNLOAD a src that's done")));
                BOOL fUnload = TRUE;
                if (p->fShare) {
                    fUnload = FALSE;
                    DbgLog((LOG_TRACE,1,TEXT("Src is SHARED.  Make sure th other switch is done with it too")));
                    CComPtr <IBigSwitcher> pSS;
                    hr = FindShareSwitch(&pSS);
                    if (hr == S_OK) {
                        REFERENCE_TIME rtS;
                        pSS->GetCurrentPosition(&rtS);  // other switch's pos
                        yy = 0;
                        for (int zz=0; zz<p->cSkew; zz++) {
		            if (rtTLStart > rtS + UNLOAD_BEFORE_TIME
                            || rtTLStop <= rtS - UNLOAD_AFTER_TIME) {
		                yy++;
		            } else {
		                break;
		            }
	                }
                        if (yy == p->cSkew) {
                            DbgLog((LOG_TRACE,1,TEXT("The other switch IS done with it")));
                            fUnload = TRUE;
                        } else {
                            DbgLog((LOG_TRACE,1,TEXT("The other switch is NOT done with it")));
                        }
                    }
                }
                if (fUnload) {
                    DbgLog((LOG_TRACE, TRACE_HIGHEST,TEXT("*** unloading %ls, not needed"),
				p->bstrURL ? p->bstrURL : L"<blank>"));
                    hr = CallUnloadSource(p);
                }
            }

	// If it's time (or about to be time) for this source to be used,
	// better connect it up now!
        } else if (!p->fLoaded) {
	    for (int zz=0; zz<p->cSkew; zz++) {
	        REFERENCE_TIME rtDur = p->pSkew[zz].rtStop -
						p->pSkew[zz].rtStart;
	        rtDur = (REFERENCE_TIME)(rtDur / p->pSkew[zz].dRate);
	        // fudge 1 ms so rounding error doesn't hang the app
                if (p->pSkew[zz].rtStart + p->pSkew[zz].rtSkew + rtDur +
			10000 > rt + LOAD_AFTER_TIME &&
			p->pSkew[zz].rtStart + p->pSkew[zz].rtSkew <
			(rt + LOAD_BEFORE_TIME)) {
                    DbgLog((LOG_TRACE, TRACE_HIGHEST,TEXT("loading %ls used now or about to be used")
			, p->bstrURL ? p->bstrURL : L"<blank>"));
		    // If the app uses sources that are hidden (never
		    // visible at any time on the timeline), then the switch
		    // may be programmed to never use this input and we could
		    // avoid loading it. (The GRID should never let that happen)
                    hr = CallLoadSource(p);
		    break;	// please, only load it once! :-)
                }
	    }
        }

        p = p->pNext;
    }

    if (hr != S_FALSE) {
        // tell whoever cares that we did something
        NotifyEvent(EC_GRAPH_CHANGED,0,0);
    }


    return hr;
}





STDMETHODIMP CBigSwitch::SetCompressed( )
{
    m_bIsCompressed = TRUE;
    return NOERROR;
}

STDMETHODIMP CBigSwitch::ReValidateSourceRanges( long lInputPin, long cSkews, STARTSTOPSKEW * pInSkews )
{
    // don't bother
    //
    if( !IsDynamic( ) )
    {
        return E_NOTIMPL;
    }

    // don't bother
    //
    if (m_cInputs <= lInputPin)
    {
	return E_INVALIDARG;
    }

    // lock us up
    //
    CAutoLock lock(&m_csFilterLoad);

    FILTERLOADINFO * p = m_pFilterLoad;

    // run each of our filterload infos
    //
    while (p)
    {
        // if pins don't match, continue
        //
        if( p->lInputPin != lInputPin )
        {
            p = p->pNext;
            continue;
        }

        // the internal list of skews is merged, but not combined, for every
        // source that we add on the timeline. We don't need to worry about
        // two merges being combined.

        // we need to go through the set skews, strip out any that don't have
        // some portion in the passed in pSkews, and intersect those that do

        // there's only 4 ways an internal skew can coincide with any ONE of
        // the input skews. An internal skew will NOT be able to span two input
        // skews, since

        STARTSTOPSKEW * pSkews = p->pSkew;

        long NewCount = p->cSkew;

        int i;

        for( i = 0 ; i < p->cSkew ; i++ )
        {
            REFERENCE_TIME Start = pSkews[i].rtStart;
            REFERENCE_TIME Stop = pSkews[i].rtStop;
            REFERENCE_TIME Skew = pSkews[i].rtSkew;
            Start += Skew;
            Stop += Skew;

            BOOL Found = FALSE;
            for( int j = 0 ; j < cSkews ; j++ )
            {

                REFERENCE_TIME InStart = pInSkews[j].rtStart;
                REFERENCE_TIME InStop = pInSkews[j].rtStop;

                REFERENCE_TIME Lesser = max( InStart, Start );
                REFERENCE_TIME Greater = min( InStop, Stop );
                if( Lesser < Greater )
                {
                    Found = TRUE;

                    BOOL Modified = FALSE;

                    if( InStart > Start )
                    {
                        Start = InStart;
                        Modified = TRUE;
                    }
                    if( InStop < Stop )
                    {
                        Stop = InStop;
                        Modified = TRUE;
                    }

                    if( Modified )
                    {
                        pSkews[i].rtStart = Start - Skew;
                        pSkews[i].rtStop = Stop - Skew;
                    }
                }

            }

            // if we didn't find it, invalidate it
            //
            if( !Found )
            {
                pSkews[i].rtStart = 0;
                pSkews[i].rtStop = 0;
                pSkews[i].dRate = 0;
                pSkews[i].rtSkew = 0;
                NewCount--;
            }

        }

    	SetDirty(TRUE);

        // copy over the old skews to a new array
        //
        STARTSTOPSKEW * pNew = (STARTSTOPSKEW*) CoTaskMemAlloc( NewCount * sizeof(STARTSTOPSKEW) );
        if (pNew == NULL)
        {
	    return E_OUTOFMEMORY;
        }

        int j = 0;

        for( i = 0 ; i < NewCount ; i++ )
        {
            while( pSkews[j].dRate == 0  && j < p->cSkew )
            {
                j++;
            }

            pNew[i] = pSkews[j];
            j++;
        }

        CoTaskMemFree( p->pSkew );

        p->pSkew = pNew;
        p->cSkew = NewCount;

        // there shouldn't be any others in the list that match our input pin!
        //
        return NOERROR;

    } // while p

    return S_OK;
}

STDMETHODIMP CBigSwitch::SetDeadGraph( IDeadGraph * pCache )
{
    // don't hold a refcount. Render Engine will always be calling us,
    // not the other way around
    //
    m_pDeadGraph = pCache;

    return NOERROR;
}

STDMETHODIMP CBigSwitch::FlushOutput( )
{
    // !!! don't do this, too risky!
    return 0;

    DbgLog((LOG_TRACE, TRACE_MEDIUM, "Flushing the output pin!" ));
    m_pOutput[0]->DeliverBeginFlush( );
    m_pOutput[0]->DeliverEndFlush( );
    return 0;
}


// we are group 0.  Find the switch that is group 1
//
STDMETHODIMP CBigSwitch::FindShareSwitch(IBigSwitcher **ppSwitch)
{
    DbgLog((LOG_TRACE,1,TEXT("Find the other Switch we share sources with")));

    CheckPointer(ppSwitch, E_POINTER);
    if (m_pShareSwitch) {
        *ppSwitch = m_pShareSwitch;
        m_pShareSwitch->AddRef();
        return S_OK;
    }

    if (!IsDynamic())
        return E_UNEXPECTED;
    if (m_nGroupNumber != 0)
        return E_UNEXPECTED;
    if (!m_pGraph)
        return E_UNEXPECTED;

    // walk the graph for group 0
    CComPtr< IEnumFilters > pEnumFilters;
    m_pGraph->EnumFilters( &pEnumFilters );
    ULONG Fetched = 0;
    if (pEnumFilters) {
        while (1) {
            CComPtr< IBaseFilter > pFilter;
            Fetched = 0;
            pEnumFilters->Next( 1, &pFilter, &Fetched );
            if (!Fetched) {
                break;
            }
            CComQIPtr <IBigSwitcher, &IID_IBigSwitcher> pBigS(pFilter);
            if (pBigS) {
                int n = -1;
                pBigS->GetGroupNumber(&n);
                if (n == 1) {
                    *ppSwitch = pBigS;
                    (*ppSwitch)->AddRef();
                    DbgLog((LOG_TRACE,1,TEXT("Found it!")));
                    return S_OK;
                }
            }
        }
    } // if enum filters
    return E_FAIL;
}
=== C:/Users/treeman/Desktop/windows nt source code\Source\Win2K3\NT\multimedia\dshow\filterus\dexter\switch\outpin.cpp ===
//@@@@AUTOBLOCK+============================================================;
//
//  THIS CODE AND INFORMATION IS PROVIDED "AS IS" WITHOUT WARRANTY OF ANY
//  KIND, EITHER EXPRESSED OR IMPLIED, INCLUDING BUT NOT LIMITED TO THE
//  IMPLIED WARRANTIES OF MERCHANTABILITY AND/OR FITNESS FOR A PARTICULAR
//  PURPOSE.
//
//  File: outpin.cpp
//
//  Copyright (c) Microsoft Corporation.  All Rights Reserved.
//
//@@@@AUTOBLOCK-============================================================;

#include <streams.h>
#include <qeditint.h>
#include <qedit.h>
#include "switch.h"
#include "..\util\conv.cxx"
#include "..\util\filfuncs.h"
#include "..\render\dexhelp.h"

const int TRACE_EXTREME = 0;
const int TRACE_HIGHEST = 2;
const int TRACE_MEDIUM = 3;
const int TRACE_LOW = 4;
const int TRACE_LOWEST = 5;

const int LATE_THRESHOLD = 1 * UNITS / 10;
const int JUMP_AHEAD_BY = 1 * UNITS / 4;

// ================================================================
// CBigSwitchOutputPin constructor
// ================================================================

CBigSwitchOutputPin::CBigSwitchOutputPin(TCHAR *pName,
                             CBigSwitch *pSwitch,
                             HRESULT *phr,
                             LPCWSTR pPinName) :
    CBaseOutputPin(pName, pSwitch, pSwitch, phr, pPinName) ,
    m_pSwitch(pSwitch)
{
    DbgLog((LOG_TRACE, TRACE_LOW, TEXT("::CBigSwitchOutputPin")));
    ASSERT(pSwitch);
}



//
// CBigSwitchOutputPin destructor
//
CBigSwitchOutputPin::~CBigSwitchOutputPin()
{
    DbgLog((LOG_TRACE, TRACE_LOW, TEXT("::~CBigSwitchOutputPin")));
    //ASSERT(m_pOutputQueue == NULL);
}


// overridden to allow cyclic-looking graphs - this output is not connected
// to any of our input pins
//
STDMETHODIMP CBigSwitchOutputPin::QueryInternalConnections(IPin **apPin, ULONG *nPin)
{
    DbgLog((LOG_TRACE,99,TEXT("CBigSwitchOut::QueryInternalConnections")));
    CheckPointer(nPin, E_POINTER);
    *nPin = 0;
    return S_OK;
}


//
// DecideBufferSize
//
// This has to be present to override the PURE virtual class base function
//
// !!! insist on max buffers of all inputs to avoid hanging?
HRESULT CBigSwitchOutputPin::DecideBufferSize(IMemAllocator *pAllocator,
                                        ALLOCATOR_PROPERTIES * pProperties)
{
    DbgLog((LOG_TRACE, TRACE_HIGHEST,TEXT("CBigSwitchOut[%d]::DecideBufferSize"),
								m_iOutpin));

    HRESULT hrRet = S_OK;

    // !!! don't lie? admit we have more buffers in a pool?
    if (pProperties->cBuffers == 0)
        pProperties->cBuffers = 1;

    // bump up this allocator to have as much alignment and prefix as the
    // highest required by any pin
    if (m_pSwitch->m_cbPrefix > pProperties->cbPrefix)
        pProperties->cbPrefix = m_pSwitch->m_cbPrefix;
    if (m_pSwitch->m_cbAlign > pProperties->cbAlign)
        pProperties->cbAlign = m_pSwitch->m_cbAlign;
    if (m_pSwitch->m_cbBuffer > pProperties->cbBuffer)
        pProperties->cbBuffer = m_pSwitch->m_cbBuffer;

    // keep the max up to date - if we need to bump our max, then return a
    // special return code so the caller knows this and can reconnect other
    // pins so they know it too.
    if (pProperties->cbPrefix > m_pSwitch->m_cbPrefix) {
	m_pSwitch->m_cbPrefix = pProperties->cbPrefix;
	hrRet = S_FALSE;
    }
    if (pProperties->cbAlign > m_pSwitch->m_cbAlign) {
	m_pSwitch->m_cbAlign = pProperties->cbAlign;
	hrRet = S_FALSE;
    }
    if (pProperties->cbBuffer > m_pSwitch->m_cbBuffer) {
	m_pSwitch->m_cbBuffer = pProperties->cbBuffer;
	hrRet = S_FALSE;
    }

    ALLOCATOR_PROPERTIES Actual;
    HRESULT hr = pAllocator->SetProperties(pProperties,&Actual);
    if (FAILED(hr)) {
        DbgLog((LOG_ERROR,1,TEXT("Error in SetProperties")));
	return hr;
    }

    if (Actual.cbBuffer < pProperties->cbBuffer ||
			Actual.cbPrefix < pProperties->cbPrefix ||
    			Actual.cbAlign < pProperties->cbAlign) {
	// can't use this allocator
        DbgLog((LOG_ERROR,1,TEXT("Can't use allocator - something too small")));
	return E_INVALIDARG;
    }

    DbgLog((LOG_TRACE, TRACE_HIGHEST,TEXT("Using %d buffers of size %d"),
					Actual.cBuffers, Actual.cbBuffer));
    DbgLog((LOG_TRACE, TRACE_HIGHEST,TEXT("Prefix=%d Align=%d"),
					Actual.cbPrefix, Actual.cbAlign));

    return hrRet;
}


//
// DecideAllocator - override to notice if it's our allocator
//
HRESULT CBigSwitchOutputPin::DecideAllocator(IMemInputPin *pPin, IMemAllocator **ppAlloc)
{
    HRESULT hr = NOERROR;
    *ppAlloc = NULL;

    // get downstream prop request
    // the derived class may modify this in DecideBufferSize, but
    // we assume that he will consistently modify it the same way,
    // so we only get it once
    ALLOCATOR_PROPERTIES prop;
    ZeroMemory(&prop, sizeof(prop)); // safe

    // whatever he returns, we assume prop is either all zeros
    // or he has filled it out.
    pPin->GetAllocatorRequirements(&prop);

    // if he doesn't care about alignment, then set it to 1
    if (prop.cbAlign == 0) {
        prop.cbAlign = 1;
    }

    // !!! We don't work with funny allocator requirements... well we almost
    // do, except the AVI parser cannot connect straight to FRC and SWITCH when
    // the AVI MUX is on the output wanting special alignment and prefixing.
    // Connecting the MUX reconnects the switch inputs (telling them of the
    // new buffer requirements) which makes the FRC reconnect its input, which
    // fails, because the parser can't do it.  So avoid this problem by not
    // letting anyone use anything but align=1 and prefix=0
    prop.cbAlign = 1;
    prop.cbPrefix = 0;

    /* Try the allocator provided by the input pin */
    // REMOVED - we have to use our own allocator - GetBuffer requires it

    /* If the GetAllocator failed we may not have an interface */

    if (*ppAlloc) {
	(*ppAlloc)->Release();
	*ppAlloc = NULL;
    }

    /* Try the output pin's allocator by the same method */

    hr = InitAllocator(ppAlloc);
    if (SUCCEEDED(hr)) {

        // note - the properties passed here are in the same
        // structure as above and may have been modified by
        // the previous call to DecideBufferSize
	HRESULT hrRet = DecideBufferSize(*ppAlloc, &prop);
	if (SUCCEEDED(hrRet)) {
	    // !!! read only?
	    hr = pPin->NotifyAllocator(*ppAlloc, FALSE);
	    if (SUCCEEDED(hr)) {
		m_fOwnAllocator = TRUE;
    	        DbgLog((LOG_TRACE, TRACE_HIGHEST,TEXT("CBigSwitchOut[%d]: using our own allocator"), m_iOutpin));
		if (hrRet == S_OK) {
		    goto SkipFix;
		} else {
		    // this means we bumped up the allocator requirements, and
		    // we need to reconnect our input pins
		    goto FixOtherAllocators;
		}
	    }
	} else {
	    hr = hrRet;
	}
    }

    /* Likewise we may not have an interface to release */

    if (*ppAlloc) {
	(*ppAlloc)->Release();
	*ppAlloc = NULL;
    }
    return hr;

FixOtherAllocators:

    // we have to make all the input allocators know about the alignment and
    // prefix this output needs.  If it's our allocator, just make a note of it
    // otherwise we need to reconnect (which we hate to do; takes forever)
    // (!!! so don't do it this often, only after all outputs connected!)
    // Luckily, the common scenario is that inputs use their own allocator
    //
    ALLOCATOR_PROPERTIES actual;
    if (this == m_pSwitch->m_pOutput[0]) {
      for (int z=0; z<m_pSwitch->m_cInputs; z++) {

        // the FRC needs to know the new properties too, unfortunately we really
        // do have to reconnect
	if (m_pSwitch->m_pInput[z]->IsConnected()) {
	    hr = m_pSwitch->ReconnectPin(m_pSwitch->m_pInput[z],
				(AM_MEDIA_TYPE *)&m_pSwitch->m_pInput[z]->m_mt);
	    ASSERT(hr == S_OK);
    	    DbgLog((LOG_TRACE, TRACE_HIGHEST,TEXT("*Reconnecting input %d to fix allocator"),
							z));
	}
      }
    }

SkipFix:

    // make sure the pool has a whole bunch of buffers, obeying align and prefix
    // !!! You can't connect the main output first, or we won't yet know how
    // big pool buffers need to be (no inputs connected yet) and we'll blow up.
    // Luckily, Dexter can only connect the main output last.
    prop.cBuffers = m_pSwitch->m_nOutputBuffering;
    hr = m_pSwitch->m_pPoolAllocator->SetProperties(&prop, &actual);
    ASSERT(SUCCEEDED(hr));
    if (FAILED(hr))
	return hr;
    DbgLog((LOG_TRACE, TRACE_HIGHEST,TEXT("Increased POOL to %d buffers"), actual.cBuffers));

    return S_OK;

} // DecideAllocator


//
// CheckMediaType - accept only the type we're supposed to accept
//
HRESULT CBigSwitchOutputPin::CheckMediaType(const CMediaType *pmt)
{
    DbgLog((LOG_TRACE, TRACE_LOWEST, TEXT("CBigSwitchOut[%d]::CheckMT"), m_iOutpin));

    CAutoLock lock_it(m_pLock);

    CMediaType mtAccept(m_pSwitch->m_mtAccept);

    if (IsEqualGUID(*pmt->Type(), *mtAccept.Type())) {
        if (IsEqualGUID(*pmt->Subtype(), *mtAccept.Subtype())) {
	    if (*pmt->FormatType() == *mtAccept.FormatType()) {
	        if (pmt->FormatLength() >= mtAccept.FormatLength()) {

		    // !!! video formats will NOT match exactly
        	    if (IsEqualGUID(*pmt->FormatType(), FORMAT_VideoInfo)) {
			LPBITMAPINFOHEADER lpbi = HEADER((VIDEOINFOHEADER *)
							pmt->Format());
			LPBITMAPINFOHEADER lpbiAccept =HEADER((VIDEOINFOHEADER*)
							mtAccept.Format());
			if ((lpbi->biCompression == lpbiAccept->biCompression)
				&& (lpbi->biBitCount == lpbiAccept->biBitCount))
		    	    return S_OK;

		    // will other formats match exactly?
        	    } else {
		        LPBYTE lp1 = pmt->Format();
		        LPBYTE lp2 = mtAccept.Format();
		        if (memcmp(lp1, lp2, mtAccept.FormatLength()) == 0)
		            return S_OK;
		    }
		}
	    }
        }
    }
    return VFW_E_INVALIDMEDIATYPE;

} // CheckMediaType



//
// GetMediaType - return the type we accept
//
HRESULT CBigSwitchOutputPin::GetMediaType(int iPosition, CMediaType *pMediaType)
{
    if (iPosition != 0)
        return VFW_S_NO_MORE_ITEMS;

    return CopyMediaType(pMediaType, &m_pSwitch->m_mtAccept);

} // GetMediaType


//
// Notify
//
STDMETHODIMP CBigSwitchOutputPin::Notify(IBaseFilter *pSender, Quality q)
{
    // NO! This gets called in Receive! CAutoLock lock_it(m_pLock);

    DbgLog((
        LOG_TIMING,
        TRACE_MEDIUM,
        TEXT("Switch: LATE %d ms, late timestamp = %ld"),
        (int)(q.Late / 10000),
        (int)(q.TimeStamp/10000) ));
    REFERENCE_TIME rt = q.Late;

// !!! FIGURE OUT THE BEST TIME TO SKIP (after how many ms) and how far
// !!! to skip ahead for best results

    // if we're NOT late, reset our threshold, so we dn't allow us to get too behind
    // audio later
    //
    if( rt <= 0 )
    {
        m_pSwitch->m_qLastLate = 0;
    }

    // More than such-and-such late? And that's at least ? frames in the future?
    if (m_pSwitch->m_fPreview && rt > LATE_THRESHOLD &&	// !!!
	    rt >= (m_pSwitch->m_rtNext - m_pSwitch->m_rtLastDelivered)) {

        // we're late, but we're getting less late. Don't pass a notify
        // upstream or we might upset our catching up
        //
        if( m_pSwitch->m_qLastLate > rt )
        {
            DbgLog((LOG_TRACE, TRACE_MEDIUM, "allowing catch up" ));
            return E_NOTIMPL;
        }

        // flush the output downstream of us, in case it's logged up a bunch of stuff
        //
        m_pSwitch->FlushOutput( );

        // flag how late we are.
        m_pSwitch->m_qLastLate = rt + JUMP_AHEAD_BY;

	// the late value we get is based on the time we delivered to the
	// renderer. It MUST BE FRAME ALIGNED or we can hang (one frame will
	// be thought of as too early, and the next one too late)
	rt = m_pSwitch->m_rtLastDelivered + rt + JUMP_AHEAD_BY; // !!! better choice
	DWORDLONG dwl = Time2Frame(rt, m_pSwitch->m_dFrameRate);
	rt = Frame2Time(dwl, m_pSwitch->m_dFrameRate);
#ifdef DEBUG
        dwl = Time2Frame( q.Late + JUMP_AHEAD_BY, m_pSwitch->m_dFrameRate );
        DbgLog((
            LOG_TRACE,
            TRACE_MEDIUM,TEXT("last delivered to %ld, LATE CRANK to %d ms"),
            (int)(m_pSwitch->m_rtLastDelivered/10000),
            (int)(rt / 10000)));
        m_pSwitch->m_nSkippedTotal += dwl;
        DbgLog((LOG_TRACE, TRACE_MEDIUM,"(skipping %ld frames, tot = %ld)", long( dwl ), long( m_pSwitch->m_nSkippedTotal ) ));
#endif
        // don't crank yet, we're still in the middle of delivering something
	m_pSwitch->m_fJustLate = TRUE;
	q.Late = rt;	// make a note of we need to crank to
	m_pSwitch->m_qJustLate = q;
    }

    // make the render keep trying to make up time, too
    return E_NOTIMPL;
}

HRESULT CBigSwitchOutputPin::IsFormatSupported(const GUID * pFormat)
{
    CheckPointer(pFormat, E_POINTER);
    return (*pFormat == TIME_FORMAT_MEDIA_TIME) ? S_OK : S_FALSE;
}

HRESULT CBigSwitchOutputPin::QueryPreferredFormat(GUID *pFormat)
{
    CheckPointer(pFormat, E_POINTER);
    *pFormat = TIME_FORMAT_MEDIA_TIME;
    return S_OK;
}

HRESULT CBigSwitchOutputPin::SetTimeFormat(const GUID * pFormat)
{
    CheckPointer(pFormat, E_POINTER);
    if (*pFormat == TIME_FORMAT_MEDIA_TIME)
        return S_OK;
    return E_FAIL;
}

HRESULT CBigSwitchOutputPin::IsUsingTimeFormat(const GUID * pFormat)
{
    CheckPointer(pFormat, E_POINTER);
    if (*pFormat != TIME_FORMAT_MEDIA_TIME)
        return S_FALSE;
    return S_OK;
}

HRESULT CBigSwitchOutputPin::GetTimeFormat(GUID *pFormat)
{
    CheckPointer(pFormat, E_POINTER);
    *pFormat = TIME_FORMAT_MEDIA_TIME ;
    return S_OK;
}

HRESULT CBigSwitchOutputPin::GetDuration(LONGLONG *pDuration)
{
    CheckPointer(pDuration, E_POINTER);
    DbgLog((LOG_TRACE, TRACE_LOWEST, TEXT("Switch: Duration is %d"),
				(int)(m_pSwitch->m_rtProjectLength / 10000)));
    *pDuration = m_pSwitch->m_rtProjectLength;
    return S_OK;
}

HRESULT CBigSwitchOutputPin::GetStopPosition(LONGLONG *pStop)
{
    CheckPointer(pStop, E_POINTER);
    DbgLog((LOG_TRACE, TRACE_LOWEST, TEXT("Switch: Stop is %d"),
				(int)(m_pSwitch->m_rtStop / 10000)));
    *pStop = m_pSwitch->m_rtStop;
    return S_OK;
}

HRESULT CBigSwitchOutputPin::GetCurrentPosition(LONGLONG *pCurrent)
{
    CheckPointer(pCurrent, E_POINTER);
    DbgLog((LOG_TRACE, TRACE_LOWEST, TEXT("Switch: Current is %d"),
				(int)(m_pSwitch->m_rtCurrent / 10000)));
    *pCurrent = m_pSwitch->m_rtCurrent;
    return S_OK;
}

HRESULT CBigSwitchOutputPin::GetCapabilities(DWORD *pCap)
{
    CheckPointer(pCap, E_POINTER);
    *pCap =	AM_SEEKING_CanSeekAbsolute |
		AM_SEEKING_CanSeekForwards |
		AM_SEEKING_CanSeekBackwards |
		AM_SEEKING_CanGetCurrentPos |
		AM_SEEKING_CanGetStopPos |
                AM_SEEKING_CanGetDuration;

    // !!! AM_SEEKING_Source?

    return S_OK;
}

HRESULT CBigSwitchOutputPin::CheckCapabilities( DWORD * pCapabilities )
{
    DWORD dwMask;
    GetCapabilities(&dwMask);
    *pCapabilities &= dwMask;
    return S_OK;
}


HRESULT CBigSwitchOutputPin::ConvertTimeFormat(
  		LONGLONG * pTarget, const GUID * pTargetFormat,
  		LONGLONG    Source, const GUID * pSourceFormat )
{
    return E_NOTIMPL;
}


// Here's the biggie... SEEK!
//
HRESULT CBigSwitchOutputPin::SetPositions(
		LONGLONG * pCurrent,  DWORD CurrentFlags,
  		LONGLONG * pStop,  DWORD StopFlags )
{
    // I want to make sure we don't get paused during the seek, or that this
    // doesn't change while I'm unloading a dynamic shared source
    CAutoLock lock_it(m_pLock);

    HRESULT hr;
    REFERENCE_TIME rtCurrent = m_pSwitch->m_rtCurrent;
    REFERENCE_TIME rtStop = m_pSwitch->m_rtStop;

    // segment not supported
    if ((CurrentFlags & AM_SEEKING_Segment) ||
				(StopFlags & AM_SEEKING_Segment)) {
    	DbgLog((LOG_TRACE, TRACE_HIGHEST,TEXT("Switch: ERROR-Seek used EC_ENDOFSEGMENT!")));
	return E_INVALIDARG;
    }

    DWORD dwFlags = (CurrentFlags & AM_SEEKING_PositioningBitsMask);

    // start ABSOLUTE seek
    if (dwFlags == AM_SEEKING_AbsolutePositioning) {
	CheckPointer(pCurrent, E_POINTER);
	if (*pCurrent < 0) {
    	    DbgLog((LOG_TRACE, TRACE_HIGHEST,TEXT("Switch::Invalid Seek to %dms"),
					(int)(*pCurrent / 10000)));
	    ASSERT(FALSE);
	    return E_INVALIDARG;
	}
	// this happens if other switches are in the graph
	if (*pCurrent > m_pSwitch->m_rtProjectLength) {
	    *pCurrent = m_pSwitch->m_rtProjectLength;
	}
	rtCurrent = *pCurrent;
    	DbgLog((LOG_TRACE, TRACE_HIGHEST,TEXT("Switch::Seek to %dms"),
					(int)(rtCurrent / 10000)));

    // start RELATIVE seek
    } else if (dwFlags == AM_SEEKING_RelativePositioning) {
	CheckPointer(pCurrent, E_POINTER);
	if (m_pSwitch->m_rtCurrent + *pCurrent < 0) {
    	    DbgLog((LOG_TRACE, TRACE_HIGHEST,TEXT("Switch::Invalid Relative Seek to %dms"),
			(int)((m_pSwitch->m_rtCurrent + *pCurrent) / 10000)));
	    ASSERT(FALSE);
	    return E_INVALIDARG;
	}
	// this happens if other switches are in the graph
	if (m_pSwitch->m_rtCurrent + *pCurrent > m_pSwitch->m_rtProjectLength) {
	    rtCurrent = m_pSwitch->m_rtProjectLength;
	} else {
	    rtCurrent += *pCurrent;
	}
    	DbgLog((LOG_TRACE, TRACE_HIGHEST,TEXT("Switch::Relative Seek to %dms"),
					(int)((rtCurrent) / 10000)));

    } else if (dwFlags) {
    	DbgLog((LOG_TRACE, TRACE_HIGHEST,TEXT("Switch::Invalid Current Seek flags")));
	return E_INVALIDARG;
    }

    dwFlags = (StopFlags & AM_SEEKING_PositioningBitsMask);

    // stop ABSOLUTE seek
    if (dwFlags == AM_SEEKING_AbsolutePositioning) {
	CheckPointer(pStop, E_POINTER);
	if (*pStop < 0 || *pStop < rtCurrent) {
    	    DbgLog((LOG_TRACE, TRACE_HIGHEST,TEXT("Switch::Invalid Seek until %dms"),
					(int)(*pStop / 10000)));
	    ASSERT(FALSE);
	    return E_INVALIDARG;
	}
	if (*pStop > m_pSwitch->m_rtProjectLength) {
	    *pStop = m_pSwitch->m_rtProjectLength;
	}
    	DbgLog((LOG_TRACE, TRACE_HIGHEST,TEXT("Switch::Seek until %dms"),
					(int)(*pStop / 10000)));
	rtStop = *pStop;

    // stop RELATIVE seek
    } else if (dwFlags == AM_SEEKING_RelativePositioning) {
	CheckPointer(pStop, E_POINTER);
	if (m_pSwitch->m_rtStop + *pStop < 0 || m_pSwitch->m_rtStop + *pStop <
					rtCurrent) {
    	    DbgLog((LOG_TRACE, TRACE_HIGHEST,TEXT("Switch::Invalid Relative Seek until %dms")
			, (int)((m_pSwitch->m_rtStop + *pStop) / 10000)));
	    ASSERT(FALSE);
	    return E_INVALIDARG;
	}
	if (m_pSwitch->m_rtStop + *pStop > m_pSwitch->m_rtProjectLength) {
	    rtStop = m_pSwitch->m_rtProjectLength;
	} else {
	    rtStop += *pStop;
	}
    	DbgLog((LOG_TRACE, TRACE_HIGHEST,TEXT("Switch::Relative Seek until %dms"),
						(int)(rtStop / 10000)));

    // stop INCREMENTAL seek
    } else if (dwFlags == AM_SEEKING_IncrementalPositioning) {
	CheckPointer(pStop, E_POINTER);
	if (rtCurrent + *pStop < 0) {
    	    DbgLog((LOG_TRACE, TRACE_HIGHEST,TEXT("Switch::Invalid Increment Seek until %dms"
			), (int)((rtCurrent + *pStop) / 10000)));
	    ASSERT(FALSE);
	    return E_INVALIDARG;
	}
	if (rtCurrent + *pStop > m_pSwitch->m_rtProjectLength) {
	    rtStop = m_pSwitch->m_rtProjectLength;
	} else {
	    rtStop = rtCurrent + *pStop;
	}
    	DbgLog((LOG_TRACE, TRACE_HIGHEST,TEXT("Switch::Incremental Seek until %dms"),
					(int)(rtStop / 10000)));
    }

    // I'm going to round the current seek time down to a frame boundary, or
    // a seek to (x,x) will not send anything instead of sending 1 frame.  It's
    // x rounded down to a frame boundary which is the first thing the switch
    // will see, so we don't want it throwing it away as being too early.
    // The next frame time stamped >x is too late and playback will stop.
    LONGLONG llOffset = Time2Frame( rtCurrent, m_pSwitch->m_dFrameRate );
    rtCurrent = Frame2Time( llOffset, m_pSwitch->m_dFrameRate );
    DbgLog((LOG_TRACE, TRACE_LOW, TEXT("New current pos rounded down to %dms"),
					(int)(rtCurrent / 10000)));

    // return the time?
    if ((CurrentFlags & AM_SEEKING_ReturnTime) && pCurrent)
	*pCurrent = rtCurrent;
    if ((StopFlags & AM_SEEKING_ReturnTime) && pStop)
	*pStop = rtStop;

    // if we seek to the end, and we're already at the end, that's pointless
    // It will also hang us.  The non-source pins will flush the video renderer
    // yet no source will have been passed the seek, so no data or EOS will
    // be forthcoming, and the renderer will never complete a state change
    //
    if (rtCurrent >= m_pSwitch->m_rtProjectLength && m_pSwitch->m_rtCurrent >=
						m_pSwitch->m_rtProjectLength) {
	// or else when we are paused, we'll think the last seek was somewhere
	// else!
        m_pSwitch->m_rtLastSeek = rtCurrent;

	// we're not actually seeking, better send this now?
        DbgLog((LOG_TRACE,TRACE_HIGHEST,TEXT("Switch: Send NewSeg=%dms"),
				(int)(rtCurrent / 10000)));
        for (int i = 0; i < m_pSwitch->m_cOutputs; i++) {
	    m_pSwitch->m_pOutput[i]->DeliverNewSegment(rtCurrent, rtStop, 1.0);
        }
	m_pSwitch->m_fNewSegSent = TRUE;

	return S_OK;
    }

    // if we're seeking to the end, there are no sources needed at the new time,
    // so nobody will flush and send EOS, which is necessary.  So let's do it.
    if (rtCurrent >= m_pSwitch->m_rtProjectLength && m_pSwitch->m_rtCurrent <
						m_pSwitch->m_rtProjectLength) {
        for (int z=0; z < m_pSwitch->m_cOutputs; z++) {
	    m_pSwitch->m_pOutput[z]->DeliverBeginFlush();
	    m_pSwitch->m_pOutput[z]->DeliverEndFlush();
        }
        m_pSwitch->AllDone();   // deliver EOS, etc.
        return S_OK;
    }

    // so after all that, has the current or stop time changed?
    // it doesn't matter!  If it's delivering time 100 and we want to seek back
    // to 100, we still need to seek! Or we'll hang!
    // if (rtCurrent != m_pSwitch->m_rtCurrent || rtStop != m_pSwitch->m_rtStop)
    {

	// YEP!  Time to seek!


	if (m_pSwitch->IsDynamic()) {
	    // make sure any new sources needed at the new time are in so we can
	    // seek them below

	    // Dynamic graph building while seeking HANGS (that's the rule)
	    // so this won't work
	    // m_pSwitch->DoDynamicStuff(rtCurrent);

	    // when woken up, use this time
	    m_pSwitch->m_worker.m_rt = rtCurrent;
	    SetEvent(m_pSwitch->m_hEventThread);
	}

	// during the seek, people need to know where we're seeking to
        m_pSwitch->m_rtSeekCurrent = rtCurrent;
        m_pSwitch->m_rtSeekStop = rtStop;

        m_pSwitch->m_fSeeking = TRUE;
        m_pSwitch->m_rtLastSeek = rtCurrent;	// the last seek was to here
	m_pSwitch->m_fNewSegSent = FALSE;	// need to send this new time

	// we're no longer at EOS.  Do this BEFORE passing seek upstream or
	// we might get new data while we still think we're at EOS
	m_pSwitch->m_fEOS = FALSE;		// not at EOS yet

	// If a pin was not flushed by surprise before this seek, let's find
	// out if it gets flushed during this seek.  If so, m_fFlushAfterSeek
	// will be reset.  If not, then we can expect a flush to come by
	// surprise later. If not paused, no flushing happens
        if (m_pSwitch->m_State == State_Paused) {
            for (int j = 0; j < m_pSwitch->m_cInputs; j++) {
		if (!m_pSwitch->m_pInput[j]->m_fFlushBeforeSeek &&
				m_pSwitch->m_pInput[j]->m_fIsASource) {
	            m_pSwitch->m_pInput[j]->m_fFlushAfterSeek = TRUE;
		}
	    }
	}

	// seek upstream of every input pin
        // not all inputs are sources, so ignore error codes!!!
	for (int i = 0; i < m_pSwitch->m_cInputs; i++) {

	    // only bother to seek sources
	    if (!m_pSwitch->m_pInput[i]->m_fIsASource &&
	    			m_pSwitch->m_pInput[i]->IsConnected()) {
		// since we're not seeking upstream of this pin, it won't get
		// flushed unless we do it ourself, and that will not block
		// this input until the seek is complete, and we'll hang
		m_pSwitch->m_pInput[i]->BeginFlush();
		m_pSwitch->m_pInput[i]->EndFlush();
		continue;
	    }

	    IPin *pPin = m_pSwitch->m_pInput[i]->GetConnected();
	    IMediaSeeking *pMS;
    	    int n = m_pSwitch->m_pInput[i]->OutpinFromTime(rtCurrent);
    	    if (n == -1)
	 	n = m_pSwitch->m_pInput[i]->NextOutpinFromTime(rtCurrent, NULL);

	    // only bother to seek pins that will evenutally do something
	    if (pPin && n != -1) {
		hr = pPin->QueryInterface(IID_IMediaSeeking, (void **)&pMS);
		if (hr == S_OK) {
		    // convert all seeks to absolute seek commands.  Pass on
		    // FLUSH flag.
		    DWORD CFlags=(CurrentFlags &AM_SEEKING_PositioningBitsMask)?
				AM_SEEKING_AbsolutePositioning :
				AM_SEEKING_NoPositioning;
		    if (CurrentFlags & AM_SEEKING_NoFlush)
			CFlags |= AM_SEEKING_NoFlush;
		    DWORD SFlags =(StopFlags & AM_SEEKING_PositioningBitsMask) ?
				AM_SEEKING_AbsolutePositioning :
				AM_SEEKING_NoPositioning;
		    if (StopFlags & AM_SEEKING_NoFlush)
			SFlags |= AM_SEEKING_NoFlush;
		    // make sure we're in MEDIA TIME format
		    if (pMS->IsUsingTimeFormat(&TIME_FORMAT_MEDIA_TIME) != S_OK)
			pMS->SetTimeFormat(&TIME_FORMAT_MEDIA_TIME);

    		    DbgLog((LOG_TRACE, TRACE_HIGHEST,TEXT("Switch[%d]::Passing seek upstream"), i));
		    hr = pMS->SetPositions(&rtCurrent, CFlags, &rtStop, SFlags);

		    if (FAILED(hr)) {
		        // !!! Seeking audio parser pin when both are connected
			// fails silently and doesn't cause flushing!
    		        DbgLog((LOG_ERROR,1,TEXT("Switch::SEEK FAILED!")));
    		        // seek failed, we won't get flushed, this won't happen
    		        m_pSwitch->m_pInput[i]->m_rtBlock = -1;
    		        m_pSwitch->m_pInput[i]->m_fEOS = FALSE;
    		        m_pSwitch->m_pInput[i]->m_rtLastDelivered =
						m_pSwitch->m_rtSeekCurrent;
		    }

		    pMS->Release();
		} else {
    		    DbgLog((LOG_ERROR,1,TEXT("Switch::In %d CAN'T SEEK"), i));
		    ASSERT(FALSE); // we're in trouble
		}
            } else if (n != 1 || pPin) {
                // If this pin is connected and blocked, but not used after the
                // seek, we still need to unblock it! (but not seek it)
		// In Dynamic sources, this pin might not be connected yet, but
		// it is the source we need to use now because of this seek, and
		// we're counting on getting flushed, which won't happen since
		// it's not connected yet.  We need to pretend a source upstream
		// flushed us, or the renderer won't get flushed, and it will
		// ignore what we send it after this seek (when paused) and the
		// seek will not show the new frame
		m_pSwitch->m_pInput[i]->BeginFlush();
		m_pSwitch->m_pInput[i]->EndFlush();
		continue;
	    } else {
		// we are a source that is not needed after this seek point, so
		// we're not going to seek it.  Well, we better also darn well
		// not think we're going to get a flush on this pin!
		m_pSwitch->m_pInput[i]->m_fFlushAfterSeek = FALSE;
	    }
	}

        // we know all the flushes have now come through

	// Reset this AGAIN because seeking upstream could set it again
	m_pSwitch->m_fEOS = FALSE;		// not at EOS yet

        m_pSwitch->m_fSeeking = FALSE;	// this thread is all done

        DbgLog((LOG_TRACE, TRACE_HIGHEST,TEXT("Completing the seek to %d,%dms"),
				(int)(m_pSwitch->m_rtSeekCurrent / 10000),
				(int)(m_pSwitch->m_rtSeekStop / 10000)));

	// update our internal clock to the new position
 	m_pSwitch->m_rtCurrent = m_pSwitch->m_rtSeekCurrent;

	// !!! assumed so because of a new segment?
	m_pSwitch->m_fDiscon = FALSE;	// after a seek, no discontinuity?
        m_pSwitch->m_rtNext = Frame2Time( Time2Frame( m_pSwitch->m_rtCurrent,
                       m_pSwitch->m_dFrameRate ) + 1, m_pSwitch->m_dFrameRate );
 	m_pSwitch->m_rtStop = m_pSwitch->m_rtSeekStop;
        m_pSwitch->m_llFramesDelivered = 0;	// nothing delivered yet

	// now that new current and stop times are set, reset every input's
	// last delivered time, and default back to blocking every input until
	// its time to deliver
	// Also, send NewSeg if necessary, and let pins start delivering again

	for (i = 0; i < m_pSwitch->m_cInputs; i++) {

	    // if we didn't get flushed, EndFlush didn't do this important stuff
	    m_pSwitch->m_pInput[i]->m_rtLastDelivered = m_pSwitch->m_rtCurrent;
            m_pSwitch->m_pInput[i]->m_rtBlock = -1;
            m_pSwitch->m_pInput[i]->m_fEOS = FALSE;

	    // We got a seek, which didn't generate a flush, but should have.
	    // I can only conclude we're sharing a parser, and the seek was
	    // ignored by our pin, and at some later date, the other parser pin
	    // will get seeked.  It's important we don't deliver anything else
	    // until that seek really happens, or we'll crank and screw up our
	    // variables set by the seek.  So we block receives now.  When the
	    // flush comes later, it will be OK to deliver again, and unblock.
	    if ((m_pSwitch->m_pInput[i]->m_fFlushAfterSeek
                        ) && m_pSwitch->m_pInput[i]->IsConnected()) {
	        DbgLog((LOG_TRACE,2,TEXT("Switch[%d]:SEEK W/O FLUSH - going STALE"),
						i));
	        m_pSwitch->m_pInput[i]->m_fStaleData = TRUE;
	        m_pSwitch->m_cStaleData++;
	        ResetEvent(m_pSwitch->m_pInput[i]->m_hEventSeek);
	    }
	    ResetEvent(m_pSwitch->m_pInput[i]->m_hEventBlock);
	}

	// We need to send a NewSeg now, unless anybody was stale, in which
	// case they might still deliver old data, and we better NOT send
	// a NewSeg now, or the offsets will be wrong!
        // If we don't send a NewSeg, we can't let ANY INPUT PIN deliver yet,
        // or the filter downstream will be screwed up
	if (m_pSwitch->m_cStaleData == 0) {
            DbgLog((LOG_TRACE,TRACE_HIGHEST,TEXT("Switch:Send NewSeg=%dms"),
					(int)(rtCurrent / 10000)));
            for (int j = 0; j < m_pSwitch->m_cOutputs; j++) {
	        m_pSwitch->m_pOutput[j]->DeliverNewSegment(rtCurrent,
							rtStop, 1.0);
	    }
	    m_pSwitch->m_fNewSegSent = TRUE;

	    // last but not least, after the NewSeg has been sent, let the pins
	    // start delivering.
	    for (i = 0; i < m_pSwitch->m_cInputs; i++) {
	        SetEvent(m_pSwitch->m_pInput[i]->m_hEventSeek);
	    }
	}
    }
    return S_OK;
}


HRESULT CBigSwitchOutputPin::GetPositions(LONGLONG * pCurrent, LONGLONG * pStop)
{
    DbgLog((LOG_TRACE, TRACE_LOWEST, TEXT("Switch: Positions are %d and %d"),
			(int)(m_pSwitch->m_rtCurrent / 10000),
			(int)(m_pSwitch->m_rtStop / 10000)));
    if (pCurrent)
    	*pCurrent = m_pSwitch->m_rtCurrent;
    if (pStop)
	*pStop = m_pSwitch->m_rtStop;
    return S_OK;
}

HRESULT CBigSwitchOutputPin::GetAvailable( LONGLONG * pEarliest, LONGLONG * pLatest )
{
    DbgLog((LOG_TRACE, TRACE_LOWEST, TEXT("Switch: GetAvailable")));
    if (pEarliest)
    	*pEarliest = 0;
    if (pLatest)
	*pLatest = m_pSwitch->m_rtProjectLength;
    return S_OK;
}

HRESULT CBigSwitchOutputPin::SetRate( double dRate)
{
    return E_NOTIMPL;
}

HRESULT CBigSwitchOutputPin::GetRate( double * pdRate)
{
    return E_NOTIMPL;
}

HRESULT CBigSwitchOutputPin::GetPreroll(LONGLONG *pPreroll)
{
    return E_NOTIMPL;
}

STDMETHODIMP CBigSwitchOutputPin::NonDelegatingQueryInterface(REFIID riid, void ** ppv)
{
    CheckPointer(ppv,E_POINTER);

    // only the render pin supports seeking
    if (this == m_pSwitch->m_pOutput[0] && riid == IID_IMediaSeeking) {
        //DbgLog((LOG_TRACE,9,TEXT("CBigSwitchOut: QI for IMediaSeeking")));
        return GetInterface((IMediaSeeking *) this, ppv);
    } else {
        return CBaseOutputPin::NonDelegatingQueryInterface(riid, ppv);
    }
}
=== C:/Users/treeman/Desktop/windows nt source code\Source\Win2K3\NT\multimedia\dshow\filterus\dexter\switch\switch.h ===
//@@@@AUTOBLOCK+============================================================;
//
//  THIS CODE AND INFORMATION IS PROVIDED "AS IS" WITHOUT WARRANTY OF ANY
//  KIND, EITHER EXPRESSED OR IMPLIED, INCLUDING BUT NOT LIMITED TO THE
//  IMPLIED WARRANTIES OF MERCHANTABILITY AND/OR FITNESS FOR A PARTICULAR
//  PURPOSE.
//
//  File: switch.h
//
//  Copyright (c) Microsoft Corporation.  All Rights Reserved.
//
//@@@@AUTOBLOCK-============================================================;

#ifndef __SWITCH__
#define __SWITCH__

#include "..\errlog\cerrlog.h"

extern const AMOVIESETUP_FILTER sudBigSwitch;

// !!! don't change - frc assumes this
#define SECRET_FLAG 65536

class CBigSwitch;
class CBigSwitchOutputPin;
class CBigSwitchInputPin;
class CBigSwitchInputAllocator;

// each input pin has one of these
typedef struct _crank {
    int iOutpin;
    REFERENCE_TIME rtStart;
    REFERENCE_TIME rtStop;
    _crank *Next;
} CRANK;

struct FILTERLOADINFO {
    BSTR            bstrURL;
    GUID            GUID;
    int             nStretchMode;
    long            lStreamNumber;
    double          dSourceFPS;
    int             cSkew;
    STARTSTOPSKEW * pSkew;
    long            lInputPin;
    BOOL            fLoaded;

    BOOL            fShare;             // for source sharing
    long            lShareInputPin;     // other switch's input pin
    int             nShareStretchMode;
    long            lShareStreamNumber;
    AM_MEDIA_TYPE   mtShare;
    double          dShareFPS;

    IPropertySetter *pSetter;
    FILTERLOADINFO *pNext;
};

const int HI_PRI_TRACE = 2;
const int MED_PRI_TRACE = 3;
const int LOW_PRI_TRACE = 4;
const int EXLOW_PRI_TRACE = 5;

// class for the big switch filter's Input allocator

class CBigSwitchInputAllocator : public CMemAllocator
{
    friend class CBigSwitchInputPin;

protected:

    CBigSwitchInputPin *m_pSwitchPin;

public:

    CBigSwitchInputAllocator(TCHAR *pName, LPUNKNOWN pUnk, HRESULT *phr) :
    	CMemAllocator(pName, pUnk, phr) {};
    ~CBigSwitchInputAllocator() {};

    STDMETHODIMP GetBuffer(IMediaSample **ppBuffer, REFERENCE_TIME *pStartTime,
                                  REFERENCE_TIME *pEndTime, DWORD dwFlags);
};


class CBigSwitchInputPin : public CBaseInputPin
{
    friend class CBigSwitchInputAllocator;
    friend class CBigSwitchOutputPin;
    friend class CBigSwitch;

public:

    // Constructor and destructor
    CBigSwitchInputPin(TCHAR *pObjName,
                 CBigSwitch *pTee,
                 HRESULT *phr,
                 LPCWSTR pPinName);
    ~CBigSwitchInputPin();

    // overridden to allow cyclic-looking graphs
    STDMETHODIMP QueryInternalConnections(IPin **apPin, ULONG *nPin);

    // check the input pin connection
    HRESULT CheckMediaType(const CMediaType *pmt);

    // release our special allocator, if any
    HRESULT BreakConnect();

    STDMETHODIMP Disconnect();

    // get our special BigSwitch allocator
    STDMETHODIMP GetAllocator(IMemAllocator **ppAllocator);

    // provide a type to make connecting faster?
    HRESULT GetMediaType(int iPosition, CMediaType *pMediaType);

    // don't allow us to connect directly to a switch output pin
    virtual HRESULT CompleteConnect(IPin *pReceivePin);

    // ask the switch for the allocator requirements
    STDMETHODIMP GetAllocatorRequirements(ALLOCATOR_PROPERTIES*pProps);

    // does special processing to make sure switch knows about the biggest
    // allocator provided to it
    STDMETHODIMP NotifyAllocator(IMemAllocator *pAllocator, BOOL bReadOnly);

    // pass on EOS, then see if we need to do a crank
    STDMETHODIMP EndOfStream();

    // go unstale
    STDMETHODIMP Unstale();

    // very complicated function...
    STDMETHODIMP BeginFlush();

    // very complicated function...
    STDMETHODIMP EndFlush();

    // just say yes, base class function is SLOW
    STDMETHODIMP ReceiveCanBlock();

    // deliver every input's newsegment to every output pin
    //
    STDMETHODIMP NewSegment(
                    REFERENCE_TIME tStart,
                    REFERENCE_TIME tStop,
                    double dRate);

    // Handles the next block of data from the stream
    STDMETHODIMP Receive(IMediaSample *pSample);

    // create and destroy synchronization events
    HRESULT Active();
    HRESULT Inactive();

protected:

#ifdef DEBUG
    // Dump switch matrix for this pin
    HRESULT DumpCrank();
#endif

    int OutpinFromTime(REFERENCE_TIME rt);
    int NextOutpinFromTime(REFERENCE_TIME rt, REFERENCE_TIME *prtNext);
    HRESULT FancyStuff(REFERENCE_TIME);	// on Receive and GetBuffer

    CBigSwitchInputAllocator *m_pAllocator; // our special allocator
    CBigSwitch *m_pSwitch;      // Main filter object
    CRANK *m_pCrankHead;        // which pins to send to, and when
    int m_iInpin;	        // which input pin are we?
    int m_cBuffers;	        // number of buffers in allocator
    int m_cbBuffer;	        // size of the allocator buffers
    BOOL m_fOwnAllocator;	//using our own?
    HANDLE m_hEventBlock;	// event blocking receive/getbuffer
    HANDLE m_hEventSeek;	// block input while seeking
    REFERENCE_TIME m_rtBlock;	// sample arrived here
    REFERENCE_TIME m_rtLastDelivered;	// end time of last thing delivered
    BOOL m_fEOS;
    BOOL m_fIsASource;		// input is connected to a source, as opposed
				// to the output of an effect
    BOOL m_fInNewSegment;	// prevent recursion

    BOOL m_fFlushBeforeSeek;	// sharing a parser, seek happens before we ask
    BOOL m_fFlushAfterSeek;	// seek happens before

    BOOL m_fStaleData;		// true if we know a seek is coming. We've sent
				// the NewSeg, so don't deliver anything until
				// the new data arrives

    CCritSec m_csReceive;
    bool m_fActive;
};


// Class for the big switch filter's Output pins.

class CBigSwitchOutputPin : public CBaseOutputPin, IMediaSeeking
{
    friend class CBigSwitchInputAllocator;
    friend class CBigSwitchInputPin;
    friend class CBigSwitch;

public:

    // Constructor and destructor

    CBigSwitchOutputPin(TCHAR *pObjName,
                   CBigSwitch *pTee,
                   HRESULT *phr,
                   LPCWSTR pPinName);
    ~CBigSwitchOutputPin();

    DECLARE_IUNKNOWN

    // Reveals IMediaSeeking
    STDMETHODIMP NonDelegatingQueryInterface(REFIID riid, void ** ppv);

    // overridden to allow cyclic-looking graphs
    STDMETHODIMP QueryInternalConnections(IPin **apPin, ULONG *nPin);

    // Check that we can support an output type, checks against switch's MT
    HRESULT CheckMediaType(const CMediaType *pmt);

    // gets the switch media type
    HRESULT GetMediaType(int iPosition, CMediaType *pMediaType);

    // Negotiation to use our input pins allocator. Weird fancy allocator stuff
    HRESULT DecideAllocator(IMemInputPin *pPin, IMemAllocator **ppAlloc);

    // make sure the allocator has the biggest size of any of our input pins
    // and output pins
    HRESULT DecideBufferSize(IMemAllocator *pMemAllocator,
                              ALLOCATOR_PROPERTIES * ppropInputRequest);

    // Used to create output queue objects
    //HRESULT Active();
    //HRESULT Inactive();

    // Overriden to pass data to the output queues
    //HRESULT Deliver(IMediaSample *pMediaSample);
    //HRESULT DeliverEndOfStream();
    //HRESULT DeliverBeginFlush();
    //HRESULT DeliverEndFlush();
    //HRESULT DeliverNewSegment(REFERENCE_TIME tStart, REFERENCE_TIME tStop, double dRate);

    // Overriden to handle quality messages
    STDMETHODIMP Notify(IBaseFilter *pSender, Quality q);

    // IMediaSeeking
    STDMETHODIMP IsFormatSupported(const GUID * pFormat);
    STDMETHODIMP QueryPreferredFormat(GUID *pFormat);
    STDMETHODIMP SetTimeFormat(const GUID * pFormat);
    STDMETHODIMP IsUsingTimeFormat(const GUID * pFormat);
    STDMETHODIMP GetTimeFormat(GUID *pFormat);
    STDMETHODIMP GetDuration(LONGLONG *pDuration);
    STDMETHODIMP GetStopPosition(LONGLONG *pStop);
    STDMETHODIMP GetCurrentPosition(LONGLONG *pCurrent);
    STDMETHODIMP GetCapabilities( DWORD * pCapabilities );
    STDMETHODIMP CheckCapabilities( DWORD * pCapabilities );
    STDMETHODIMP ConvertTimeFormat(
	LONGLONG * pTarget, const GUID * pTargetFormat,
	LONGLONG    Source, const GUID * pSourceFormat );
    STDMETHODIMP SetPositions(
	LONGLONG * pCurrent,  DWORD CurrentFlags,
	LONGLONG * pStop,  DWORD StopFlags );
    STDMETHODIMP GetPositions( LONGLONG * pCurrent, LONGLONG * pStop );
    STDMETHODIMP GetAvailable( LONGLONG * pEarliest, LONGLONG * pLatest );
    STDMETHODIMP SetRate( double dRate);
    STDMETHODIMP GetRate( double * pdRate);
    STDMETHODIMP GetPreroll(LONGLONG *pPreroll);

protected:

    CBigSwitch *m_pSwitch;                  // Main filter object pointer
    BOOL m_fOwnAllocator;	            //using our own?
    int m_iOutpin;	                    // which output pin are we?
};

// worker thread object
class CBigSwitchWorker : public CAMThread
{
    friend class CBigSwitch;
    friend class CBigSwitchOutputPin;

protected:
    CBigSwitch * m_pSwitch;
    HANDLE m_hThread;
    REFERENCE_TIME m_rt;

public:
    enum Command { CMD_RUN, CMD_STOP, CMD_EXIT };

private:
    // type-corrected overrides of communication funcs
    Command GetRequest() {
	return (Command) CAMThread::GetRequest();
    };

    BOOL CheckRequest(Command * pCom) {
	return CAMThread::CheckRequest( (DWORD *) pCom);
    };

    HRESULT DoRunLoop(void);

public:

    CBigSwitchWorker();

    BOOL Create(CBigSwitch * pSwitch);

    DWORD ThreadProc();

    // commands we can give the thread
    HRESULT Run();
    HRESULT Stop();
    HRESULT Exit();
};


// Class for the Big Switch filter

class CBigSwitch
    : public CCritSec
    , public CBaseFilter
    , public IBigSwitcher
    , public CPersistStream
    , public CAMSetErrorLog
    , public IAMOutputBuffering
    , public IGraphConfigCallback
{
    // Let the pins access our internal state
    friend class CBigSwitchInputPin;
    friend class CBigSwitchOutputPin;
    friend class CBigSwitchInputAllocator;
    friend class CBigSwitchWorker;

protected:

    IDeadGraph * m_pDeadGraph;

    STDMETHODIMP CreateInputPins(long);
    STDMETHODIMP CreateOutputPins(long);
    BOOL TimeToCrank();
    HRESULT Crank();
    HRESULT ActualCrank(REFERENCE_TIME rt);
    REFERENCE_TIME CrankTime();
    REFERENCE_TIME NextInterestingTime(REFERENCE_TIME);
    HRESULT AllDone();

    CBigSwitchInputPin **m_pInput;
    CBigSwitchOutputPin **m_pOutput;
    int m_cInputs;
    int m_cOutputs;

    REFERENCE_TIME m_rtProjectLength;
    REFERENCE_TIME m_rtStop;
    double m_dFrameRate;

    AM_MEDIA_TYPE m_mtAccept;		// all pins only connect with this

    REFERENCE_TIME m_rtCurrent;		// current timeline time
    REFERENCE_TIME m_rtNext;		// this will be next
    LONGLONG m_llFramesDelivered;	// count to avoid error propagation

    BOOL m_fEOS;	// we are all done

    REFERENCE_TIME m_rtLastSeek;	// last timeline time seeked to
    REFERENCE_TIME m_rtSeekCurrent;
    REFERENCE_TIME m_rtSeekStop;

    BOOL m_fSeeking;	// inside a seek?
    BOOL m_fNewSegSent;	// have we fwd'd the NewSeg yet?
    BOOL m_bIsCompressed;

    int m_cbPrefix, m_cbAlign;	// each pin needs its allocator to do these
    LONG m_cbBuffer;		// 

    CMemAllocator *m_pPoolAllocator;  // pool of extra buffers

    BOOL m_fPreview;

    REFERENCE_TIME m_rtLastDelivered;	// last time sent to main output
    int m_nLastInpin;			// last pin delivered to

    int  m_nOutputBuffering;	// IAMOutputBuffering

    CCritSec m_csCrank;

    long m_nDynaFlags;
    BOOL m_fDiscon;	// is there a discontinuity in what we're sending?

    BOOL m_fJustLate;		// we just got a late notification
    Quality m_qJustLate;	// (this one)
    REFERENCE_TIME m_qLastLate;


    BOOL m_cStaleData;		// how many flushes we're waiting for in the
				// seek before flush case

    // DYNAMIC STUFF
    // DYNAMIC STUFF
    // DYNAMIC STUFF

    IGraphBuilder *m_pGBNoRef;  // see JoinFilterGraph
    int m_nGroupNumber;         // which TLDB group this switch is for
    IBigSwitcher *m_pShareSwitch; // the switch we share sources with

    // crit sec for dynamic stuff
    CCritSec m_csFilterLoad;

    // an array of FILTERLOAD infos
    FILTERLOADINFO *m_pFilterLoad;
    long m_cLoaded;		// how many are loaded?
    HRESULT UnloadAll();	// unload all the dynamic sources

    // a worker thread used to pre-set the sources
    CBigSwitchWorker m_worker;
    HANDLE m_hEventThread;

    // * to the IGraphConfig on the graph the switch is in
    IGraphConfig *   m_pGraphConfig;
    
    // called from Reconfigure, CallLoadSource
    HRESULT LoadSource(FILTERLOADINFO *pInfo);

    // called from Reconfigure, CallUnloadSource
    HRESULT UnloadSource(FILTERLOADINFO *pInfo);

    // called from DoDynamicStuff
    HRESULT CallLoadSource(FILTERLOADINFO *pInfo);

    // called from DoDynamicStuff and Stop
    HRESULT CallUnloadSource(FILTERLOADINFO *pInfo);

    // called from worker thread
    HRESULT DoDynamicStuff(REFERENCE_TIME rt);

    // flush the Q if we're late, don't bother sending data to VR
    STDMETHODIMP FlushOutput( );

    BOOL IsDynamic( );

    // find the other switch we share sources with
    STDMETHODIMP FindShareSwitch(IBigSwitcher **ppSwitch);

    STDMETHODIMP EnumPins(IEnumPins ** ppEnum);

#ifdef DEBUG
    DWORDLONG m_nSkippedTotal;
#endif

public:

    DECLARE_IUNKNOWN

    // Reveals IBigSwitcher
    STDMETHODIMP NonDelegatingQueryInterface(REFIID riid, void ** ppv);

    CBigSwitch(TCHAR *pName,LPUNKNOWN pUnk,HRESULT *hr);
    ~CBigSwitch();

    CBasePin *GetPin(int n);
    int GetPinCount();

    // Function needed for the class factory
    static CUnknown * WINAPI CreateInstance(LPUNKNOWN pUnk, HRESULT *phr);

    STDMETHODIMP Pause();
    STDMETHODIMP Stop();
    STDMETHODIMP JoinFilterGraph(IFilterGraph *, LPCWSTR);

    // override GetState to return VFW_S_CANT_CUE when pausing
    //
    // STDMETHODIMP GetState(DWORD dwMSecs, FILTER_STATE *State);


    // IBigSwitcher
    //
    STDMETHODIMP Reset();
    STDMETHODIMP SetX2Y( REFERENCE_TIME relative, long X, long Y );
    STDMETHODIMP SetX2YArray( REFERENCE_TIME * relative, long * pX, long * pY, long ArraySize );
    STDMETHODIMP GetInputDepth( long * pDepth );
    STDMETHODIMP SetInputDepth( long Depth );
    STDMETHODIMP GetOutputDepth( long * pDepth );
    STDMETHODIMP SetOutputDepth( long Depth );
    STDMETHODIMP GetVendorString( BSTR * pVendorString );
    STDMETHODIMP GetCaps( long Index, long * pReturn );
    //		HRESULT GetReadyEvent( IMediaEvent ** ppReady );
    STDMETHODIMP IsEverythingConnectedRight( );
    STDMETHODIMP GetMediaType(AM_MEDIA_TYPE *);
    STDMETHODIMP SetMediaType(AM_MEDIA_TYPE *);
    STDMETHODIMP GetProjectLength(REFERENCE_TIME *);
    STDMETHODIMP SetProjectLength(REFERENCE_TIME);
    STDMETHODIMP GetFrameRate(double *);
    STDMETHODIMP SetFrameRate(double);
    STDMETHODIMP InputIsASource(int, BOOL);
    STDMETHODIMP IsInputASource( int, BOOL * );
    STDMETHODIMP SetPreviewMode(BOOL);
    STDMETHODIMP GetPreviewMode(BOOL *);
    STDMETHODIMP GetInputPin(int, IPin **);
    STDMETHODIMP GetOutputPin(int, IPin **);
    STDMETHODIMP SetGroupNumber(int);
    STDMETHODIMP GetGroupNumber(int *);
    STDMETHODIMP GetCurrentPosition(REFERENCE_TIME *);

    // IAMOutputBuffering
    STDMETHODIMP GetOutputBuffering(int *);
    STDMETHODIMP SetOutputBuffering(int);

    STDMETHODIMP AddSourceToConnect(BSTR bstrURL, const GUID *pGuid,
				    int nStretchMode, 
				    long lStreamNumber, 
				    double SourceFPS, 
				    int nSkew, STARTSTOPSKEW *pSkew,
                                    long lInputPin,
                                    BOOL fShare,          // for source sharing
                                    long lShareInputPin,  //
                                    AM_MEDIA_TYPE mtShare,//
                                    double dShareFPS,     //
				    IPropertySetter *pSetter);
    STDMETHODIMP ReValidateSourceRanges( long lInputPin, long cSkews, STARTSTOPSKEW * pSkew );
    STDMETHODIMP MergeSkews(FILTERLOADINFO *, int, STARTSTOPSKEW *);

    STDMETHODIMP SetDynamicReconnectLevel( long Level );
    STDMETHODIMP GetDynamicReconnectLevel( long *pLevel );
    STDMETHODIMP SetCompressed( );
    STDMETHODIMP SetDeadGraph( IDeadGraph * pCache );

    // CPersistStream
    HRESULT WriteToStream(IStream *pStream);
    HRESULT ReadFromStream(IStream *pStream);
    STDMETHODIMP GetClassID(CLSID *pClsid);
    int SizeMax();

    // IGraphConfigCallback
    STDMETHODIMP Reconfigure(PVOID pvContext, DWORD dwFlags);
};

#endif // __SWITCH__
=== C:/Users/treeman/Desktop/windows nt source code\Source\Win2K3\NT\multimedia\dshow\filterus\dexter\tldb\stdafx.h ===
//@@@@AUTOBLOCK+============================================================;
//
//  THIS CODE AND INFORMATION IS PROVIDED "AS IS" WITHOUT WARRANTY OF ANY
//  KIND, EITHER EXPRESSED OR IMPLIED, INCLUDING BUT NOT LIMITED TO THE
//  IMPLIED WARRANTIES OF MERCHANTABILITY AND/OR FITNESS FOR A PARTICULAR
//  PURPOSE.
//
//  File: stdafx.h
//
//  Copyright (c) Microsoft Corporation.  All Rights Reserved.
//
//@@@@AUTOBLOCK-============================================================;

// stdafx.h : include file for standard system include files,
//  or project specific include files that are used frequently, but
//      are changed infrequently

#if !defined(AFX_STDAFX_H__8B015554_61FD_11D2_8CAD_00A024580902__INCLUDED_)
#define AFX_STDAFX_H__8B015554_61FD_11D2_8CAD_00A024580902__INCLUDED_

#if _MSC_VER > 1000
#pragma once
#endif // _MSC_VER > 1000

#define _ATL_APARTMENT_THREADED
#define WIN32_LEAN_AND_MEAN		// Exclude rarely-used stuff from Windows headers

#include <atlbase.h>
extern CComModule _Module;
#include <atlcom.h>
#include "qeditint.h"
#include "qedit.h"

//{{AFX_INSERT_LOCATION}}
// Microsoft Visual C++ will insert additional declarations immediately before the previous line.

#endif // !defined(AFX_STDAFX_H__8B015554_61FD_11D2_8CAD_00A024580902__INCLUDED_)
=== C:/Users/treeman/Desktop/windows nt source code\Source\Win2K3\NT\multimedia\dshow\filterus\dexter\switch\worker.cpp ===
//@@@@AUTOBLOCK+============================================================;
//
//  THIS CODE AND INFORMATION IS PROVIDED "AS IS" WITHOUT WARRANTY OF ANY
//  KIND, EITHER EXPRESSED OR IMPLIED, INCLUDING BUT NOT LIMITED TO THE
//  IMPLIED WARRANTIES OF MERCHANTABILITY AND/OR FITNESS FOR A PARTICULAR
//  PURPOSE.
//
//  File: worker.cpp
//
//  Copyright (c) Microsoft Corporation.  All Rights Reserved.
//
//@@@@AUTOBLOCK-============================================================;

#include <streams.h>
#include <qeditint.h>
#include <qedit.h>
#include "switch.h"
#include "..\util\conv.cxx"
#include "..\util\filfuncs.h"
#include "..\render\dexhelp.h"

const int TRACE_EXTREME = 0;
const int TRACE_HIGHEST = 2;
const int TRACE_MEDIUM = 3;
const int TRACE_LOW = 4;
const int TRACE_LOWEST = 5;

const int BACKGROUND_THREAD_WAIT_TIME = 500; // ms

CBigSwitchWorker::CBigSwitchWorker()
{
}

BOOL
CBigSwitchWorker::Create(CBigSwitch *pSwitch)
{
    m_pSwitch = pSwitch;
    m_hThread = 0;

    return CAMThread::Create();
}

HRESULT
CBigSwitchWorker::Run()
{
    return CallWorker(CMD_RUN);
}

HRESULT
CBigSwitchWorker::Stop()
{
    return CallWorker(CMD_STOP);
}

HRESULT
CBigSwitchWorker::Exit()
{
    return CallWorker(CMD_EXIT);
}

// called on the worker thread to do all the work. Thread exits when this
// function returns.
DWORD
CBigSwitchWorker::ThreadProc()
{
    BOOL bExit = FALSE;

    m_hThread = GetCurrentThread();

    QzInitialize(NULL);


    while (!bExit) {

	Command cmd = GetRequest();

	switch (cmd) {

	case CMD_EXIT:
	    bExit = TRUE;
	    Reply(NOERROR);
	    break;

	case CMD_RUN:
	    Reply(NOERROR);
	    DoRunLoop();
	    break;

	case CMD_STOP:
	    Reply(NOERROR);
	    break;

	default:
	    Reply(E_NOTIMPL);
	    break;
	}
    }

    QzUninitialize();

    return NOERROR;
}

HRESULT
CBigSwitchWorker::DoRunLoop()
{
    DWORD dw = WAIT_TIMEOUT;
    HRESULT hr = S_OK;

    DbgLog((LOG_TRACE, TRACE_MEDIUM,TEXT("entering worker thread")));

    while (1) {
	Command com;
	if (CheckRequest(&com)) {
	    if (com == CMD_STOP)
		break;
	}

	if (dw == WAIT_TIMEOUT) {
            m_pSwitch->DoDynamicStuff(m_pSwitch->m_rtCurrent);
	} else {
	    // we were woken up... this is the time to use (if any)
            m_pSwitch->DoDynamicStuff(m_rt);
	}

        // check every once in a while
        dw = WaitForSingleObject(m_pSwitch->m_hEventThread, BACKGROUND_THREAD_WAIT_TIME );
    }

    DbgLog((LOG_TRACE, TRACE_MEDIUM,TEXT("getting ready to leave worker thread")));

    return hr;
}
=== C:/Users/treeman/Desktop/windows nt source code\Source\Win2K3\NT\multimedia\dshow\filterus\dexter\tldb\tldb.h ===
//@@@@AUTOBLOCK+============================================================;
//
//  THIS CODE AND INFORMATION IS PROVIDED "AS IS" WITHOUT WARRANTY OF ANY
//  KIND, EITHER EXPRESSED OR IMPLIED, INCLUDING BUT NOT LIMITED TO THE
//  IMPLIED WARRANTIES OF MERCHANTABILITY AND/OR FITNESS FOR A PARTICULAR
//  PURPOSE.
//
//  File: tldb.h
//
//  Copyright (c) Microsoft Corporation.  All Rights Reserved.
//
//@@@@AUTOBLOCK-============================================================;

#define MAX_TIMELINE_GROUPS 32

#include "..\errlog\cerrlog.h"
#include "..\util\conv.cxx"

// forward reference
//
class CAMTimeline;
class CAMTimelineObj;
class CAMTimelineSrc;
class CAMTimelineVirtualTrack;
class CAMTimelineTrack;
class CAMTimelineEffect;
class CAMTimelineComp;
class CAMTimelineGroup;
class CAMTimelineTransable;

//########################################################################
//########################################################################

class CAMTimelineNode : public IAMTimelineNode
{
    friend CAMTimeline;

    CComPtr< IAMTimelineObj > m_pParent;
    CComPtr< IAMTimelineObj > m_pPrev;
    CComPtr< IAMTimelineObj > m_pNext;
    CComPtr< IAMTimelineObj > m_pKid;
    BOOL m_bPriorityOverTime;

protected:

    // helper methods
    //
    void                XAddKid( IAMTimelineObj * p );
    IAMTimelineObj *    XGetLastKidNoRef( );
    STDMETHODIMP        XRemoveOnlyMe( );
    IAMTimelineObj *    XGetFirstKidNoRef( );

    // not needed outside of the node
    //
    STDMETHODIMP XGetPrev( IAMTimelineObj ** ppResult );
    STDMETHODIMP XSetPrev( IAMTimelineObj * pVal );
    STDMETHODIMP XSetParent( IAMTimelineObj * pVal );
    STDMETHODIMP XGetNext( IAMTimelineObj ** ppResult );
    STDMETHODIMP XSetNext( IAMTimelineObj * pVal );
    STDMETHODIMP XGetPrevNoRef( IAMTimelineObj ** ppResult );
    STDMETHODIMP XGetNextNoRef( IAMTimelineObj ** ppResult );
    STDMETHODIMP XClearAllKids( );
    STDMETHODIMP XResetFirstKid( IAMTimelineObj * p );                    // special
    STDMETHODIMP XInsertKidBeforeKid( IAMTimelineObj * pToAdd, IAMTimelineObj * pIndirectObject );
    STDMETHODIMP XInsertKidAfterKid( IAMTimelineObj * pKid, IAMTimelineObj * pIndirectObject );
    STDMETHODIMP XHavePrev( long * pVal ) { return E_NOTIMPL; }
    STDMETHODIMP XHaveNext( long * pVal ) { return E_NOTIMPL; }

    CAMTimelineNode( );

public:

    ~CAMTimelineNode( );

    // IAMTimelineNode
    //
    STDMETHODIMP XSetPriorityOverTime( ) { m_bPriorityOverTime = TRUE; return NOERROR; }
    STDMETHODIMP XGetPriorityOverTime( BOOL * pResult );
    STDMETHODIMP XGetNextOfType( long MajorType, IAMTimelineObj ** ppResult );
    STDMETHODIMP XGetNextOfTypeNoRef( long MajorType, IAMTimelineObj ** ppResult );
    STDMETHODIMP XGetParent( IAMTimelineObj ** ppResult );
    STDMETHODIMP XGetParentNoRef( IAMTimelineObj ** ppResult );
    STDMETHODIMP XHaveParent( long * pVal );
    // kid functions!
    STDMETHODIMP XGetNthKidOfType( long MajorType, long WhichKid, IAMTimelineObj ** ppResult );
    STDMETHODIMP XKidsOfType( long MajorType, long * pVal );
    STDMETHODIMP XAddKidByPriority( long MajorType, IAMTimelineObj * pToAdd, long Priority );
    STDMETHODIMP XAddKidByTime( long MajorType, IAMTimelineObj * pToAdd );
    STDMETHODIMP XSwapKids( long MajorType, long KidA, long KidB );
    STDMETHODIMP XRemove( );
    STDMETHODIMP XWhatPriorityAmI( long MajorType, long * pVal );

    BOOL HasPriorityOverTime( ) { return m_bPriorityOverTime; }
};

//########################################################################
//########################################################################

class CAMTimelineObj 
    : public CUnknown
    , public CAMTimelineNode
    , public IAMTimelineObj
{
friend class CAMTimelineObj;
friend class CAMTimelineSrc;
friend class CAMTimelineTrack;
friend class CAMTimelineEffect;
friend class CAMTimelineComp;
friend class CAMTimelineTransable;

    static long         m_nStaticGenID;

protected:

    CComPtr< IPropertySetter > m_pSetter;
    CComPtr< IUnknown > m_pSubObject;
    GUID                m_ClassID;
    TIMELINE_MAJOR_TYPE m_TimelineType;
    long                m_UserID;
    WCHAR               m_UserName[256];
    REFERENCE_TIME      m_rtStart;
    REFERENCE_TIME      m_rtStop;
    GUID                m_SubObjectGuid;
    BOOL                m_bMuted;
    REFERENCE_TIME      m_rtDirtyStart;
    REFERENCE_TIME      m_rtDirtyStop;
    BOOL                m_bLocked;
    BYTE *              m_pUserData;
    long                m_nUserDataSize;
    long                m_nGenID;

    void                _Clear( );
    void                _ClearSubObject( );
    GUID                _GetObjectGuid( IUnknown * pObject );
    void                _BumpGenID( );

    CAMTimelineObj( TCHAR *pName, LPUNKNOWN pUnk, HRESULT * phr );

public:

    ~CAMTimelineObj( );

    // needed to override CBaseUnknown
    DECLARE_IUNKNOWN

    // override to return our special interfaces
    STDMETHODIMP NonDelegatingQueryInterface(REFIID riid, void **ppv);

    // IAMTimelineObj
    STDMETHODIMP GetStartStop(REFERENCE_TIME * pStart, REFERENCE_TIME * pStop);
    STDMETHODIMP GetStartStop2(REFTIME * pStart, REFTIME * pStop);
    STDMETHODIMP SetStartStop(REFERENCE_TIME Start, REFERENCE_TIME Stop);
    STDMETHODIMP SetStartStop2(REFTIME Start, REFTIME Stop);
    STDMETHODIMP GetSubObject(IUnknown* *pVal);
    STDMETHODIMP GetSubObjectLoaded(BOOL*pVal);
    STDMETHODIMP SetSubObject(IUnknown* newVal);
    STDMETHODIMP SetSubObjectGUID(GUID newVal);
    STDMETHODIMP GetSubObjectGUID(GUID * pVal);
    STDMETHODIMP SetSubObjectGUIDB(BSTR newVal);
    STDMETHODIMP GetSubObjectGUIDB(BSTR * pVal);
    STDMETHODIMP GetTimelineType(TIMELINE_MAJOR_TYPE * pVal);
    STDMETHODIMP SetTimelineType(TIMELINE_MAJOR_TYPE newVal);
    STDMETHODIMP GetUserID(long * pVal);
    STDMETHODIMP SetUserID(long newVal);
    STDMETHODIMP GetGenID(long * pVal);
    STDMETHODIMP GetUserName(BSTR * pVal);
    STDMETHODIMP SetUserName(BSTR newVal);
    STDMETHODIMP GetPropertySetter(IPropertySetter **pVal);
    STDMETHODIMP SetPropertySetter(IPropertySetter *pVal);
    STDMETHODIMP GetUserData(BYTE * pData, long * pSize);
    STDMETHODIMP SetUserData(BYTE * pData, long Size);
    STDMETHODIMP GetMuted(BOOL * pVal);
    STDMETHODIMP SetMuted(BOOL newVal);
    STDMETHODIMP GetLocked(BOOL * pVal);
    STDMETHODIMP SetLocked(BOOL newVal);
    STDMETHODIMP GetDirtyRange(REFERENCE_TIME * pStart, REFERENCE_TIME * pStop);
    STDMETHODIMP GetDirtyRange2(REFTIME * pStart, REFTIME * pStop);
    STDMETHODIMP SetDirtyRange(REFERENCE_TIME Start, REFERENCE_TIME Stop);
    STDMETHODIMP SetDirtyRange2(REFTIME Start, REFTIME Stop);
    STDMETHODIMP ClearDirty( );
    STDMETHODIMP Remove();
    STDMETHODIMP RemoveAll();
    STDMETHODIMP GetTimelineNoRef( IAMTimeline ** ppResult );
    STDMETHODIMP FixTimes( REFERENCE_TIME * pStart, REFERENCE_TIME * pStop );
    STDMETHODIMP FixTimes2( REFTIME * pStart, REFTIME * pStop );
    STDMETHODIMP GetGroupIBelongTo( IAMTimelineGroup ** ppGroup );
    STDMETHODIMP GetEmbedDepth( long * pVal );

    // public helper functions
    //
    HRESULT CopyDataTo( IAMTimelineObj * pSource, REFERENCE_TIME TimelineTime );
};

//########################################################################
//########################################################################

class CAMTimelineEffectable
    : public IAMTimelineEffectable
{
    friend CAMTimeline;
    friend CAMTimelineTrack;

protected:

    CAMTimelineEffectable( );

public:

    ~CAMTimelineEffectable( );

    // IAMTimelineEffectable
    STDMETHODIMP EffectInsBefore(IAMTimelineObj * pFX, long priority);
    STDMETHODIMP EffectSwapPriorities(long PriorityA, long PriorityB);
    STDMETHODIMP EffectGetCount(long * pCount);
    STDMETHODIMP GetEffect(IAMTimelineObj ** ppFx, long Which);

};

//########################################################################
//########################################################################

class CAMTimelineTransable
    : public IAMTimelineTransable
{
    bool _IsSpaceAvailable( REFERENCE_TIME Start, REFERENCE_TIME Stop );

protected:

    CAMTimelineTransable( );

public:

    ~CAMTimelineTransable( );

    // IAMTimelineTransable
    STDMETHODIMP TransAdd(IAMTimelineObj * pTrans);
    STDMETHODIMP TransGetCount(long * pCount);
    STDMETHODIMP GetNextTrans(IAMTimelineObj ** ppTrans, REFERENCE_TIME * pInOut);
    STDMETHODIMP GetNextTrans2(IAMTimelineObj ** ppTrans, REFTIME * pInOut);
    STDMETHODIMP GetTransAtTime(IAMTimelineObj ** ppObj, REFERENCE_TIME Time, long SearchDirection ); 
    STDMETHODIMP GetTransAtTime2(IAMTimelineObj ** ppObj, REFTIME Time, long SearchDirection ); 
};

//########################################################################
//########################################################################

class CAMTimelineEffect
    : public CAMTimelineObj
    , public IAMTimelineEffect
    , public IAMTimelineSplittable
{
    friend CAMTimeline;

    BOOL m_bRealSave;
    long m_nSaveLength;

    CAMTimelineEffect( TCHAR *pName, LPUNKNOWN pUnk, HRESULT * phr );

public:

    ~CAMTimelineEffect( );

    // needed to override CBaseUnknown
    DECLARE_IUNKNOWN

    // override to return our special interfaces
    STDMETHODIMP NonDelegatingQueryInterface(REFIID riid, void **ppv);

    // IAMTimelineEffect
    STDMETHODIMP EffectGetPriority(long * pVal);

    // IAMTimelineSplittable
    STDMETHODIMP SplitAt(REFERENCE_TIME Time);
    STDMETHODIMP SplitAt2(REFTIME Time);

    // IAMTimelineObj overrides
    STDMETHODIMP        SetSubObject(IUnknown* newVal);
    STDMETHODIMP GetStartStop(REFERENCE_TIME * pStart, REFERENCE_TIME * pStop);
    STDMETHODIMP GetStartStop2(REFTIME * pStart, REFTIME * pStop);
};

//########################################################################
//########################################################################

class CAMTimelineTrans
    : public CAMTimelineObj
    , public IAMTimelineTrans
    , public IAMTimelineSplittable
{
    friend CAMTimeline;

    REFERENCE_TIME  m_rtCut;
    BOOL            m_fSwapInputs;
    BOOL            m_bCutsOnly;

    CAMTimelineTrans( TCHAR *pName, LPUNKNOWN pUnk, HRESULT * phr );

public:

    ~CAMTimelineTrans( );

    // needed to override CBaseUnknown
    DECLARE_IUNKNOWN

    // override to return our special interfaces
    STDMETHODIMP NonDelegatingQueryInterface(REFIID riid, void **ppv);

    // IAMTimelineTrans
    STDMETHODIMP GetCutPoint(REFERENCE_TIME * pTLTime);
    STDMETHODIMP SetCutPoint(REFERENCE_TIME TLTime);
    STDMETHODIMP GetCutPoint2(REFTIME * pTLTime);
    STDMETHODIMP SetCutPoint2(REFTIME TLTime);
    STDMETHODIMP GetSwapInputs( BOOL * pVal );
    STDMETHODIMP SetSwapInputs( BOOL Val );
    STDMETHODIMP GetCutsOnly( BOOL * pVal );
    STDMETHODIMP SetCutsOnly( BOOL Val );

    // IAMTimelineSplittable
    STDMETHODIMP SplitAt(REFERENCE_TIME Time);
    STDMETHODIMP SplitAt2(REFTIME Time);
};

//########################################################################
//########################################################################

class CAMTimelineSrc 
    : public CAMTimelineObj
    , public CAMTimelineTransable
    , public CAMTimelineEffectable
    , public IAMTimelineSplittable
    , public IAMTimelineSrc
    , public IAMTimelineSrcPriv
{
    friend CAMTimeline;
    friend CAMTimelineTrack;

protected:

    REFERENCE_TIME  m_rtMediaStart;
    REFERENCE_TIME  m_rtMediaStop;
    REFERENCE_TIME  m_rtMediaLength;
    long            m_nStreamNumber;
    double          m_dDefaultFPS;
    int             m_nStretchMode;
    BOOL            m_bIsRecompressable;
    BOOL            m_bToldIsRecompressable;

    // the media name is ONLY used for the programmer's convenience.
    // the user need not get/set it, and it's just a placeholder for
    // a name.
    WCHAR           * m_szMediaName;

    BOOL            _NullName( ) { return ( m_szMediaName == NULL ); }

    CAMTimelineSrc( TCHAR *pName, LPUNKNOWN pUnk, HRESULT * phr );

public:

    ~CAMTimelineSrc( );

    // needed to override CBaseUnknown
    DECLARE_IUNKNOWN

    // override to return our special interfaces
    STDMETHODIMP NonDelegatingQueryInterface(REFIID riid, void **ppv);
    ULONG _stdcall NonDelegatingAddRef( )
    {
        return CUnknown::NonDelegatingAddRef( );
    }
    ULONG _stdcall NonDelegatingRelease( )
    {
        return CUnknown::NonDelegatingRelease( );
    }

    // IAMTimelineSrc
    STDMETHODIMP GetMediaTimes(REFERENCE_TIME * pStart, REFERENCE_TIME * pStop);
    STDMETHODIMP GetMediaTimes2(REFTIME * pStart, REFTIME * pStop);
    STDMETHODIMP SetMediaTimes(REFERENCE_TIME Start, REFERENCE_TIME Stop);
    STDMETHODIMP SetMediaTimes2(REFTIME Start, REFTIME Stop);
    STDMETHODIMP GetMediaName(BSTR * pVal);
    STDMETHODIMP SetMediaName(BSTR newVal);
    STDMETHODIMP SpliceWithNext(IAMTimelineObj * pNext);
    STDMETHODIMP FixMediaTimes(REFERENCE_TIME * pStart, REFERENCE_TIME * pStop);
    STDMETHODIMP FixMediaTimes2(REFTIME * pStart, REFTIME * pStop);
    STDMETHODIMP GetStreamNumber(long * pVal);
    STDMETHODIMP SetStreamNumber(long Val);
    STDMETHODIMP SetMediaLength(REFERENCE_TIME Length);
    STDMETHODIMP SetMediaLength2(REFTIME Length);
    STDMETHODIMP GetMediaLength(REFERENCE_TIME * pLength);
    STDMETHODIMP GetMediaLength2(REFTIME * pLength);
    STDMETHODIMP ModifyStopTime(REFERENCE_TIME Stop);
    STDMETHODIMP ModifyStopTime2(REFTIME Stop);
    STDMETHODIMP GetDefaultFPS(double * pFPS);
    STDMETHODIMP SetDefaultFPS(double FPS);
    STDMETHODIMP GetStretchMode(int * pnStretchMode);
    STDMETHODIMP SetStretchMode(int nStretchMode);
    STDMETHODIMP IsNormalRate( BOOL * pVal );

    // IAMTimelineObj override
    STDMETHODIMP SetStartStop( REFERENCE_TIME Start, REFERENCE_TIME Stop );

    // IAMTimelineSrcPriv
    STDMETHODIMP SetIsRecompressable( BOOL Val );
    STDMETHODIMP GetIsRecompressable( BOOL * pVal );
    STDMETHODIMP ClearAnyKnowledgeOfRecompressability( );

    // IAMTimelineSplittable
    STDMETHODIMP SplitAt(REFERENCE_TIME Time);
    STDMETHODIMP SplitAt2(REFTIME Time);
};

//########################################################################
//########################################################################

class CAMTimelineTrack
    : public CAMTimelineObj
    , public CAMTimelineEffectable
    , public CAMTimelineTransable
    , public IAMTimelineTrack
    , public IAMTimelineVirtualTrack
    , public IAMTimelineSplittable
{
    friend CAMTimeline;

protected:

    CAMTimelineTrack( TCHAR *pName, LPUNKNOWN pUnk, HRESULT * phr );

public:

    ~CAMTimelineTrack( );

    // needed to override CBaseUnknown
    DECLARE_IUNKNOWN

    // override to return our special interfaces
    STDMETHODIMP NonDelegatingQueryInterface(REFIID riid, void **ppv);

    // IAMTimelineTrack
    STDMETHODIMP SrcAdd(IAMTimelineObj * pSource);
    STDMETHODIMP GetNextSrc(IAMTimelineObj ** ppSrc, REFERENCE_TIME * pInOut);
    STDMETHODIMP GetNextSrc2(IAMTimelineObj ** ppSrc, REFTIME * pInOut);
    STDMETHODIMP MoveEverythingBy( REFERENCE_TIME Start, REFERENCE_TIME MoveBy );
    STDMETHODIMP MoveEverythingBy2( REFTIME Start, REFTIME MoveBy );
    STDMETHODIMP GetSourcesCount( long * pVal );
    STDMETHODIMP AreYouBlank( long * pVal );
    STDMETHODIMP GetSrcAtTime(IAMTimelineObj ** ppSrc, REFERENCE_TIME Time, long SearchDirection ); 
    STDMETHODIMP GetSrcAtTime2(IAMTimelineObj ** ppSrc, REFTIME Time, long SearchDirection ); 
    STDMETHODIMP InsertSpace( REFERENCE_TIME rtStart, REFERENCE_TIME rtEnd );
    STDMETHODIMP InsertSpace2( REFTIME rtStart, REFTIME rtEnd );
    STDMETHODIMP ZeroBetween( REFERENCE_TIME rtStart, REFERENCE_TIME rtEnd );
    STDMETHODIMP ZeroBetween2( REFTIME rtStart, REFTIME rtEnd );
    STDMETHODIMP GetNextSrcEx(IAMTimelineObj * pLast, IAMTimelineObj **ppNext);

    // IAMTimelineVirtualTrack
    STDMETHODIMP TrackGetPriority(long * pPriority);
    STDMETHODIMP SetTrackDirty( );

    // IAMTimelineSplittable
    STDMETHODIMP SplitAt(REFERENCE_TIME Time);
    STDMETHODIMP SplitAt2(REFTIME Time);

    // IAMTimelineObj
    STDMETHODIMP GetStartStop(REFERENCE_TIME * pStart, REFERENCE_TIME * pStop);
    STDMETHODIMP GetStartStop2(REFTIME * pStart, REFTIME * pStop);
    STDMETHODIMP SetStartStop(REFERENCE_TIME Start, REFERENCE_TIME Stop);
    STDMETHODIMP SetStartStop2(REFTIME Start, REFTIME Stop);
};

//########################################################################
//########################################################################

class CAMTimelineComp
    : public CAMTimelineObj
    , public CAMTimelineEffectable
    , public CAMTimelineTransable
    , public IAMTimelineComp
    , public IAMTimelineVirtualTrack
{
    friend CAMTimeline;
    friend CAMTimelineGroup;

protected:

    CAMTimelineComp( TCHAR *pName, LPUNKNOWN pUnk, HRESULT * phr );

public:

    ~CAMTimelineComp( );

    // needed to override CBaseUnknown
    DECLARE_IUNKNOWN

    // override to return our special interfaces
    STDMETHODIMP NonDelegatingQueryInterface(REFIID riid, void **ppv);
    ULONG _stdcall NonDelegatingAddRef( )
    {
        return CUnknown::NonDelegatingAddRef( );
    }
    ULONG _stdcall NonDelegatingRelease( )
    {
        return CUnknown::NonDelegatingRelease( );
    }

    // IAMTimelineComp
    STDMETHODIMP VTrackInsBefore(IAMTimelineObj * pVirtualTrack, long Priority);
    STDMETHODIMP VTrackSwapPriorities(long VirtualTrackA, long VirtualTrackB);
    STDMETHODIMP VTrackGetCount(long * pVal);
    STDMETHODIMP GetVTrack(IAMTimelineObj ** ppVirtualTrack, long Which);
    STDMETHODIMP GetCountOfType(long * pCount, long * pCountWithComps, TIMELINE_MAJOR_TYPE Type);
    STDMETHODIMP GetRecursiveLayerOfTypeI(IAMTimelineObj ** ppVirtualTrack, long * pWhich, TIMELINE_MAJOR_TYPE Type);
    STDMETHODIMP GetRecursiveLayerOfType(IAMTimelineObj ** ppVirtualTrack, long Which, TIMELINE_MAJOR_TYPE Type);
    STDMETHODIMP GetNextVTrack(IAMTimelineObj *pVirtualTrack, IAMTimelineObj **ppNextVirtualTrack);

    // IAMTimelineVirtualTrack
    STDMETHODIMP TrackGetPriority(long * pPriority);
    STDMETHODIMP SetTrackDirty( );

    // IAMTimelineObj
    STDMETHODIMP GetStartStop(REFERENCE_TIME * pStart, REFERENCE_TIME * pStop);
    STDMETHODIMP GetStartStop2(REFTIME * pStart, REFTIME * pStop);
    STDMETHODIMP SetStartStop(REFERENCE_TIME Start, REFERENCE_TIME Stop);
    STDMETHODIMP SetStartStop2(REFTIME Start, REFTIME Stop);
};

//########################################################################
//########################################################################

class CAMTimelineGroup
    : public CAMTimelineComp
    , public IAMTimelineGroup
{
    friend CAMTimeline;

    long                    m_nPriority;
    double                  m_dFPS;
    IAMTimeline *           m_pTimeline; // no longer refcounted
    AM_MEDIA_TYPE           m_MediaType;
    WCHAR                   m_szGroupName[256]; // must be 256 now
    BOOL                    m_fPreview;
    int                     m_nOutputBuffering;

    CMediaType              m_RecompressType;
    BOOL                    m_bRecompressTypeSet;
    BOOL                    m_bRecompressFormatDirty;

    CAMTimelineGroup( TCHAR *pName, LPUNKNOWN pUnk, HRESULT * phr );

public:

    ~CAMTimelineGroup( );

    // needed to override CBaseUnknown
    DECLARE_IUNKNOWN

    // override to return our special interfaces
    STDMETHODIMP NonDelegatingQueryInterface(REFIID riid, void **ppv);

    // IAMTimelineGroup
    STDMETHODIMP GetPriority( long * pPriority );
    STDMETHODIMP GetMediaType( AM_MEDIA_TYPE * );
    STDMETHODIMP SetMediaType( AM_MEDIA_TYPE * );
    STDMETHODIMP SetOutputFPS(double FPS);
    STDMETHODIMP GetOutputFPS(double * pFPS);
    STDMETHODIMP SetTimeline( IAMTimeline * pTimeline );
    STDMETHODIMP GetTimeline( IAMTimeline ** ppTimeline );
    STDMETHODIMP SetGroupName( BSTR GroupName );
    STDMETHODIMP GetGroupName( BSTR * pGroupName );
    STDMETHODIMP SetPreviewMode( BOOL fPreview );
    STDMETHODIMP GetPreviewMode( BOOL *pfPreview );
    STDMETHODIMP SetMediaTypeForVB( long Val );
    STDMETHODIMP SetOutputBuffering( int nBuffer );
    STDMETHODIMP GetOutputBuffering( int *pnBuffer );
    STDMETHODIMP SetSmartRecompressFormat( long * pFormat );
    STDMETHODIMP GetSmartRecompressFormat( long ** ppFormat );
    STDMETHODIMP IsSmartRecompressFormatSet( BOOL * pVal );
    STDMETHODIMP IsRecompressFormatDirty( BOOL * pVal );
    STDMETHODIMP ClearRecompressFormatDirty( );
    STDMETHODIMP SetRecompFormatFromSource( IAMTimelineSrc * pSource );

    // IAMTimelineObj overrides
    STDMETHODIMP Remove();
    STDMETHODIMP RemoveAll();
};

//########################################################################
//########################################################################

class CAMTimeline 
    : public CUnknown
    , public IAMTimeline
    , public CAMSetErrorLog
    , public IServiceProvider
    , public IObjectWithSite
{
private:

    CComPtr< IAMTimelineObj > m_pGroup[MAX_TIMELINE_GROUPS];
    CComPtr< IAMErrorLog > m_pErrorLog;
    long                m_nGroups;
    long                m_nInsertMode;
    long                m_nSpliceMode;
    double              m_dDefaultFPS;
    BOOL                m_bTransitionsEnabled;
    BOOL                m_bEffectsEnabled;
    GUID                m_DefaultTransition;
    GUID                m_DefaultEffect;

public:

    CAMTimeline( TCHAR *pName, LPUNKNOWN pUnk, HRESULT * phr );
    ~CAMTimeline( );

    // Function needed for the class factory
    static CUnknown * WINAPI CreateInstance( LPUNKNOWN pUnk, HRESULT *phr );

    // needed to override CBaseUnknown
    DECLARE_IUNKNOWN

    // override to return our special interfaces
    STDMETHODIMP NonDelegatingQueryInterface(REFIID riid, void **ppv);
    ULONG _stdcall NonDelegatingAddRef( )
    {
        return CUnknown::NonDelegatingAddRef( );
    }
    ULONG _stdcall NonDelegatingRelease( )
    {
        return CUnknown::NonDelegatingRelease( );
    }

    // IAMTimeline
    STDMETHODIMP CreateEmptyNode( IAMTimelineObj ** ppObj, TIMELINE_MAJOR_TYPE TimelineType );
    STDMETHODIMP AddGroup( IAMTimelineObj * pGroup );
    STDMETHODIMP RemGroupFromList( IAMTimelineObj * pGroup );
    STDMETHODIMP GetGroup( IAMTimelineObj ** ppGroup, long WhichGroup );
    STDMETHODIMP GetGroupCount( long * pCount );
    STDMETHODIMP ClearAllGroups( );
    STDMETHODIMP GetInsertMode( long * pMode );
    STDMETHODIMP SetInsertMode(long Mode);
    STDMETHODIMP EnableTransitions(BOOL fEnabled);
    STDMETHODIMP EnableEffects(BOOL fEnabled);
    STDMETHODIMP TransitionsEnabled(BOOL * pfEnabled);
    STDMETHODIMP EffectsEnabled(BOOL * pfEnabled);
    STDMETHODIMP SetInterestRange(REFERENCE_TIME Start, REFERENCE_TIME Stop);
    STDMETHODIMP SetInterestRange2(REFTIME Start, REFTIME Stop);
    STDMETHODIMP GetDuration(REFERENCE_TIME * pDuration);
    STDMETHODIMP GetDuration2(REFTIME * pDuration);
    STDMETHODIMP IsDirty(BOOL * pDirty);
    STDMETHODIMP GetDirtyRange(REFERENCE_TIME * pStart, REFERENCE_TIME * pStop);
    STDMETHODIMP GetDirtyRange2(REFTIME * pStart, REFTIME * pStop);
    STDMETHODIMP GetCountOfType(long Group, long * pCount, long * pCountWithComps, TIMELINE_MAJOR_TYPE Type);
    STDMETHODIMP SetDefaultFPS( double FPS );
    STDMETHODIMP GetDefaultFPS( double * pFPS );
    STDMETHODIMP SetDefaultTransition( GUID * pGuid );
    STDMETHODIMP GetDefaultTransition( GUID * pGuid );
    STDMETHODIMP SetDefaultEffect( GUID * pGuid );
    STDMETHODIMP GetDefaultEffect( GUID * pGuid );
    STDMETHODIMP SetDefaultTransitionB( BSTR pGuid );
    STDMETHODIMP GetDefaultTransitionB( BSTR * pGuid );
    STDMETHODIMP SetDefaultEffectB( BSTR pGuid );
    STDMETHODIMP GetDefaultEffectB( BSTR * pGuid );
    STDMETHODIMP ValidateSourceNames( long ValidateFlags, IMediaLocator * pChainer, LONG_PTR NotifyEventHandle );

    // public methods
    REFERENCE_TIME Fixup( REFERENCE_TIME Time );
    
    // --- IObjectWithSite methods
    // This interface is here so we can keep track of the context we're
    // living in.
    STDMETHODIMP    SetSite(IUnknown *pUnkSite);
    STDMETHODIMP    GetSite(REFIID riid, void **ppvSite);

    IUnknown *       m_punkSite;

    // IServiceProvider
    STDMETHODIMP QueryService(REFGUID guidService, REFIID riid, void **ppvObject);

};


extern int function_not_done;
extern double TIMELINE_DEFAULT_FPS;
extern HRESULT _GenerateError( IAMTimelineObj * pObj, long Severity, WCHAR * pErrorString, LONG ErrorCode, HRESULT hresult, VARIANT * pExtraInfo = NULL );
=== C:/Users/treeman/Desktop/windows nt source code\Source\Win2K3\NT\multimedia\dshow\filterus\dexter\tldb\tldbcomp.cpp ===
//@@@@AUTOBLOCK+============================================================;
//
//  THIS CODE AND INFORMATION IS PROVIDED "AS IS" WITHOUT WARRANTY OF ANY
//  KIND, EITHER EXPRESSED OR IMPLIED, INCLUDING BUT NOT LIMITED TO THE
//  IMPLIED WARRANTIES OF MERCHANTABILITY AND/OR FITNESS FOR A PARTICULAR
//  PURPOSE.
//
//  File: tldbcomp.cpp
//
//  Copyright (c) Microsoft Corporation.  All Rights Reserved.
//
//@@@@AUTOBLOCK-============================================================;

#include <streams.h>
#include "stdafx.h"
#include "tldb.h"

const int VIRTUAL_TRACK_COMBO = 
                TIMELINE_MAJOR_TYPE_COMPOSITE | 
                TIMELINE_MAJOR_TYPE_TRACK;

//############################################################################
// Composition - either holds tracks or other compositions in a layered
// ordering. Comps can also have effects or transition on them, except for 
// the first composition, which cannot have a transition.
//############################################################################

CAMTimelineComp::CAMTimelineComp
    ( TCHAR *pName, LPUNKNOWN pUnk, HRESULT * phr )
    : CAMTimelineObj( pName, pUnk, phr )
{
    m_ClassID = CLSID_AMTimelineComp;
    m_TimelineType = TIMELINE_MAJOR_TYPE_COMPOSITE;
}

//############################################################################
// 
//############################################################################

CAMTimelineComp::~CAMTimelineComp( )
{
}

//############################################################################
// 
//############################################################################

STDMETHODIMP CAMTimelineComp::NonDelegatingQueryInterface
    (REFIID riid, void **ppv)
{
    if( riid == IID_IAMTimelineEffectable )
    {
        return GetInterface( (IAMTimelineEffectable*) this, ppv );
    }
    if( riid == IID_IAMTimelineVirtualTrack )
    {
        return GetInterface( (IAMTimelineVirtualTrack*) this, ppv );
    }
    if( riid == IID_IAMTimelineTransable )
    {
        return GetInterface( (IAMTimelineTransable*) this, ppv );
    }
    if( riid == IID_IAMTimelineComp )
    {
        return GetInterface( (IAMTimelineComp*) this, ppv );
    }
    return CAMTimelineObj::NonDelegatingQueryInterface( riid, ppv );
}

//############################################################################
// Insert a track before another one. A priority of -1 means "at the end". If
// there are N tracks, you cannot add a track with a Priority greater than N.
//############################################################################

STDMETHODIMP CAMTimelineComp::VTrackInsBefore
    (IAMTimelineObj * pTrackToInsert, long Priority)
{
    HRESULT hr = 0;

    // make sure incoming object isn't null
    //
    if( NULL == pTrackToInsert )
    {
        return E_INVALIDARG;
    }

    // make sure it's a track, I guess
    //
    CComQIPtr< IAMTimelineTrack, &IID_IAMTimelineTrack > p1( pTrackToInsert );
    CComQIPtr< IAMTimelineComp, &IID_IAMTimelineComp > p2( pTrackToInsert );
    CComQIPtr< IAMTimelineVirtualTrack, &IID_IAMTimelineVirtualTrack > pVirtualTrack( pTrackToInsert );
    if( !p1 && !p2 )
    {
        return E_NOINTERFACE;
    }
    if( !pVirtualTrack )
    {
        return E_NOINTERFACE;
    }

    // make sure track isn't in some other tree. If this operation failed,
    // then the tree stayed the same.
    //
    hr = pTrackToInsert->Remove( );
    if( FAILED( hr ) )
    {
        return hr;
    }

    // ...incoming object is either a track or another comp...

    // find out how many tracks we have already
    //
    long Count = 0;
    hr = VTrackGetCount( &Count );
    // assume that worked

    // check to make sure Priority is valid
    //
    if( ( Priority < -1 ) || ( Priority > Count ) )
    {
        return E_INVALIDARG;
    }

    hr = XAddKidByPriority( VIRTUAL_TRACK_COMBO, pTrackToInsert, Priority );
    if( FAILED( hr ) )
    {
        return hr;
    }

    // who do we dirty? We just added a track, but the whole thing 
    // is dirty. Compositions don't really have a "time", their time is set
    // by the times of all the things they contain. Compositions response
    // to asking if they are dirty is by asking their tracks, so we do
    // not dirty here.

    // make the entire track dirty, since we just inserted it. 
    //
    if( pVirtualTrack )
    {
        pVirtualTrack->SetTrackDirty( );
    }

    return NOERROR;
}

//############################################################################
// switch around a couple of the track layers in this composition. Haven't
// figured out a good use for this yet, or tested it, but it should work.
//############################################################################

STDMETHODIMP CAMTimelineComp::VTrackSwapPriorities
    ( long VirtualTrackA, long VirtualTrackB)
{
    HRESULT worked =        
        XSwapKids( VIRTUAL_TRACK_COMBO, VirtualTrackA, VirtualTrackB );
    if( FAILED( worked ) )
    {
        return worked;
    }

    return NOERROR;
}

//############################################################################
// Ask how many virtual tracks this composition is holding
//############################################################################

STDMETHODIMP CAMTimelineComp::VTrackGetCount
    (long * pVal)
{
    // base function does error checking
    return XKidsOfType( VIRTUAL_TRACK_COMBO, pVal );
}

//############################################################################
// Get the nth virtual track
//############################################################################

STDMETHODIMP CAMTimelineComp::GetVTrack
    (IAMTimelineObj ** ppVirtualTrack, long Which)
{
    HRESULT hr = 0;

    // find out how many kids we have
    //
    long count = 0;
    hr = XKidsOfType( VIRTUAL_TRACK_COMBO, &count );
    // assume that worked

    // are we in range?
    //
    if( Which < 0 || Which >= count )
    {
        return E_INVALIDARG;
    }

    // can we stuff the value?
    //
    CheckPointer( ppVirtualTrack, E_POINTER );

    // get the nth kid
    //
    hr = XGetNthKidOfType( VIRTUAL_TRACK_COMBO, Which, ppVirtualTrack );

    return hr;
}

STDMETHODIMP CAMTimelineComp::GetNextVTrack(IAMTimelineObj *pVirtualTrack, IAMTimelineObj **ppNextVirtualTrack)
{
    if (!pVirtualTrack)
        return GetVTrack(ppNextVirtualTrack, 0);
    
    CComQIPtr< IAMTimelineNode, &IID_IAMTimelineNode > pNode( pVirtualTrack );

    return pNode->XGetNextOfType( VIRTUAL_TRACK_COMBO, ppNextVirtualTrack );
}


//############################################################################
// A comp's start/stop is the min/max of anything it contains
//############################################################################

STDMETHODIMP CAMTimelineComp::GetStartStop2(REFTIME * pStart, REFTIME * pStop)
{
    REFERENCE_TIME p1 = DoubleToRT( *pStart );
    REFERENCE_TIME p2 = DoubleToRT( *pStop );
    HRESULT hr = GetStartStop( &p1, &p2 );
    *pStart = RTtoDouble( p1 );
    *pStop = RTtoDouble( p2 );
    return hr;
}

STDMETHODIMP CAMTimelineComp::GetStartStop
    (REFERENCE_TIME * pStart, REFERENCE_TIME * pStop)
{
    CheckPointer( pStart, E_POINTER );
    CheckPointer( pStop, E_POINTER );

    HRESULT hr = 0;

    REFERENCE_TIME Min = 0;
    REFERENCE_TIME Max = 0;

    long VTracks = 0;
    CComPtr<IAMTimelineObj> pTrack;

    // get first track
    hr = XGetNthKidOfType( VIRTUAL_TRACK_COMBO, 0, &pTrack);

    while(pTrack)
    {
//#define DEBUGDEBUG 1
#ifdef DEBUGDEBUG
        {
            CComQIPtr< IAMTimelineObj, &IID_IAMTimelineObj > ptTmp;
            XGetNthKidOfType( VIRTUAL_TRACK_COMBO, VTracks, &ptTmp );
            ASSERT(ptTmp == pTrack);
        }
#endif
        
        // ask it for it's times
        //
        REFERENCE_TIME Start = 0;
        REFERENCE_TIME Stop = 0;
        pTrack->GetStartStop( &Start, &Stop );
        if( Max == 0 )
        {
            Min = Start;
            Max = Stop;
        }
        if( Start < Min ) Min = Start;
        if( Stop > Max ) Max = Stop;

        IAMTimelineNode *pNodeTmp;
        pTrack->QueryInterface(IID_IAMTimelineNode, (void **)&pNodeTmp);
        pTrack.p->Release();    // bypass CComPtr for perf
        pNodeTmp->XGetNextOfType(VIRTUAL_TRACK_COMBO, &pTrack.p);
        pNodeTmp->Release();
        VTracks++;
    }


    
#ifdef DEBUG
    long VTracksTmp;
    XKidsOfType( VIRTUAL_TRACK_COMBO, &VTracksTmp );
    ASSERT(VTracks == VTracksTmp);
#endif


    *pStart = Min;
    *pStop = Max;

    return NOERROR;
}

//############################################################################
//
//############################################################################

STDMETHODIMP CAMTimelineComp::GetRecursiveLayerOfType
    (IAMTimelineObj ** ppVirtualTrack, long WhichLayer, TIMELINE_MAJOR_TYPE Type )
{
    long Dummy = WhichLayer;
    HRESULT hr = GetRecursiveLayerOfTypeI( ppVirtualTrack, &Dummy, Type );
    if( hr == S_FALSE )
    {
        ASSERT( Dummy > 0 );
        hr = E_INVALIDARG;
    }
    else if( hr == NOERROR )
    {
        ASSERT( Dummy == 0 );
    }
    return hr;
}

STDMETHODIMP CAMTimelineComp::GetRecursiveLayerOfTypeI
    (IAMTimelineObj ** ppVirtualTrack, long * pWhich, TIMELINE_MAJOR_TYPE Type )
{
    HRESULT hr = 0;

    // make sure we can stuff the value
    //
    CheckPointer( ppVirtualTrack, E_POINTER );

    *ppVirtualTrack = 0;

    CComPtr <IAMTimelineObj> pTrack;

    while (1)
    {
        if (!pTrack)
            hr = XGetNthKidOfType( VIRTUAL_TRACK_COMBO, 0, &pTrack );
        else {
            CComQIPtr< IAMTimelineNode, &IID_IAMTimelineNode > pNode( pTrack );
            pTrack.Release( );
            pNode->XGetNextOfType( VIRTUAL_TRACK_COMBO, &pTrack );
        }

        if (!pTrack)
            break;
        // assume that worked

        // it's either another composition or a track
        //
        CComQIPtr<IAMTimelineTrack, &IID_IAMTimelineTrack> pTrack2( pTrack );

        if( !pTrack2 )
        {   // we are a composition

            CComQIPtr<IAMTimelineComp, &IID_IAMTimelineComp> pComp( pTrack );

            hr = pComp->GetRecursiveLayerOfTypeI( ppVirtualTrack, pWhich, Type );

            if( FAILED( hr ) )
            {
                *ppVirtualTrack = NULL;
                *pWhich = 0;
                return hr;
            }

            // if they gave us the real deal, then return
            //
            if( *ppVirtualTrack != NULL )
            {
                return NOERROR;
            }

            *pWhich = *pWhich - 1;

            // they didn't find it in this composition, we should try the next one,
            // right?
        }
        else
        {   // we are a track
            TIMELINE_MAJOR_TYPE TrackType;
            hr = pTrack->GetTimelineType( &TrackType );
            // assume that worked

            // if we found a match, then decrement the found number. Note that Which will be zero coming into this
            // function if the present track is the one we want. So if we decrement Which, it will be -1.
            //
            if( Type == TrackType )
            {
                if( *pWhich == 0 )
                {
                    *ppVirtualTrack = pTrack;
                    (*ppVirtualTrack)->AddRef( );
                    return NOERROR;
                }

                *pWhich = *pWhich - 1;
            }
        }
    }

    // if Which is = 0 then we must not have any more kids
    // and have exhausted our search. Therefore we 
    //
    if( *pWhich == 0 )
    {
        *ppVirtualTrack = this;
        (*ppVirtualTrack)->AddRef( );
        return NOERROR;
    }

    // didn't find it, flag this by returning S_FALSE.
    //
    return S_FALSE;
}

//############################################################################
// 
//############################################################################

STDMETHODIMP CAMTimelineComp::TrackGetPriority
    (long * pPriority)
{
    CheckPointer( pPriority, E_POINTER );

    return XWhatPriorityAmI( TIMELINE_MAJOR_TYPE_TRACK | TIMELINE_MAJOR_TYPE_COMPOSITE, pPriority );
}

//############################################################################
//
//############################################################################

HRESULT CAMTimelineComp::SetTrackDirty
    ( )
{
    return E_NOTIMPL; // settrackdirty
}

//############################################################################
// 
//############################################################################

STDMETHODIMP CAMTimelineComp::GetCountOfType
    (long * pVal, long * pValWithComps, TIMELINE_MAJOR_TYPE MajorType )
{
    HRESULT hr = 0;

    long Total = 0;
    long Comps = 1; // automatically get one because it's in a group

    // make sure we can stuff the value
    //
    CheckPointer( pVal, E_POINTER );
    CheckPointer( pValWithComps, E_POINTER );

    // find out how many kids we have, so we can enum them
    //
    BOOL SetFirst = FALSE;
    CComPtr<IAMTimelineObj> pTrackObj;

    // "this" is a comp, enumerate it's effects/transitions here

    // ... are we looking for effects? Add this comp's number of effects
    //
    if( MajorType == TIMELINE_MAJOR_TYPE_EFFECT )
    {
        CComQIPtr< IAMTimelineEffectable, &IID_IAMTimelineEffectable > pEffectable( this );
        if( pEffectable )
        {
            long Count = 0;
            pEffectable->EffectGetCount( &Count );
            Total += Count;
        }
    }

    // ... are we looking for transitions? Add this comp's number of transitions
    //
    if( MajorType == TIMELINE_MAJOR_TYPE_TRANSITION )
    {
        CComQIPtr< IAMTimelineTransable, &IID_IAMTimelineTransable > pTransable( this );
        if( pTransable )
        {
            long Count = 0;
            pTransable->TransGetCount( &Count );
            Total += Count;
        }
    }

    // ask each of the kids for the amount of whatever it is we're looking for
    for(;;)
    {
        if( !SetFirst )
        {
            // get first track
            hr = XGetNthKidOfType( VIRTUAL_TRACK_COMBO, 0, &pTrackObj);
            SetFirst = TRUE;
        }
        else
        {
            // get next track
            IAMTimelineNode *pNodeTmp;
            pTrackObj->QueryInterface(IID_IAMTimelineNode, (void **)&pNodeTmp);
            pTrackObj.p->Release(); // bypass CComPtr for perf
            pNodeTmp->XGetNextOfType(VIRTUAL_TRACK_COMBO, &pTrackObj.p);
            pNodeTmp->Release();
        }

        if(pTrackObj == 0) {
            break;
        }
        
        // it's either another composition or a track
        //
        CComQIPtr<IAMTimelineTrack, &IID_IAMTimelineTrack> pTrackTrack( pTrackObj );

        // if it's a track...
        //
        if( pTrackTrack != NULL )
        {
            // ... are we looking for effects? Add this track's number of effects
            //
            if( MajorType == TIMELINE_MAJOR_TYPE_EFFECT )
            {
                CComQIPtr< IAMTimelineEffectable, &IID_IAMTimelineEffectable > pEffectable( pTrackObj );
                if( pEffectable )
                {
                    long Count = 0;
                    pEffectable->EffectGetCount( &Count );
                    Total += Count;
                }
            }

            // ... are we looking for transitions? Add this track's number of transitions
            //
            if( MajorType == TIMELINE_MAJOR_TYPE_TRANSITION )
            {
                CComQIPtr< IAMTimelineTransable, &IID_IAMTimelineTransable > pTransable( pTrackObj );
                if( pTransable )
                {
                    long Count = 0;
                    pTransable->TransGetCount( &Count );
                    Total += Count;
                }
            }

            // are we looking for tracks? If so, we're "1"
            //
            if( MajorType == TIMELINE_MAJOR_TYPE_TRACK )
            {
                Total++;
                continue;
            }

            long SourcesCount = 0;
            hr = pTrackTrack->GetSourcesCount( &SourcesCount );
            // assume that worked

            // ... are we looking for sources? If so, count 'em up.
            //
            if( MajorType == TIMELINE_MAJOR_TYPE_SOURCE )
            {
                Total += SourcesCount;
            }

            // ... are we looking for effects? If so, add each of our source's total
            //
            if( MajorType == TIMELINE_MAJOR_TYPE_EFFECT )
            {
                CComQIPtr< IAMTimelineNode, &IID_IAMTimelineNode > pTrackNode( pTrackTrack );
                CComPtr< IAMTimelineObj > pSource;
                pTrackNode->XGetNthKidOfType( TIMELINE_MAJOR_TYPE_SOURCE, 0, &pSource );
                while( pSource )
                {
                    CComQIPtr< IAMTimelineEffectable, &IID_IAMTimelineEffectable > pEffectable( pSource );
                    if( pEffectable )
                    {
                        long Count = 0;
                        pEffectable->EffectGetCount( &Count );
                        Total += Count;
                    }

                    CComQIPtr< IAMTimelineNode, &IID_IAMTimelineNode > pNode( pSource );
                    pSource.Release( );
                    pNode->XGetNextOfType( TIMELINE_MAJOR_TYPE_SOURCE, &pSource );
                }
            } // if looking for EFFECT
        }
        else // it's a composition
        {
            CComQIPtr<IAMTimelineComp, &IID_IAMTimelineComp> pComp( pTrackObj );

            long SubTotal = 0;
            long SubTotalWithComps = 0;

            hr = pComp->GetCountOfType( &SubTotal, &SubTotalWithComps, MajorType );

            if( FAILED( hr ) )
            {
                *pVal = 0;
                *pValWithComps = 0;
                return hr;
            }

            Total += SubTotal;

            // since we're only counting comps here, we need to add the difference
            //
            Comps += ( SubTotalWithComps - SubTotal );
        }
    }

    // if we didn't find anything, then zero out comps so we don't
    // misadjust when doing recursive adding. If we're not counting
    // composites, that is
    //
    if( ( Total == 0 ) && ( MajorType != TIMELINE_MAJOR_TYPE_COMPOSITE ) )
    {
        Comps = 0;
    }

    *pValWithComps = Total + Comps;
    *pVal = Total;

    return NOERROR;
}

//############################################################################
// 
//############################################################################

STDMETHODIMP CAMTimelineComp::SetStartStop(REFERENCE_TIME Start, REFERENCE_TIME Stop)
{
    return E_NOTIMPL; // okay, we don't implement SetStartStop here
}

STDMETHODIMP CAMTimelineComp::SetStartStop2(REFTIME Start, REFTIME Stop)
{
    return E_NOTIMPL; // okay, we don't implement SetStartStop here
}
=== C:/Users/treeman/Desktop/windows nt source code\Source\Win2K3\NT\multimedia\dshow\filterus\dexter\tldb\tldb.cpp ===
//@@@@AUTOBLOCK+============================================================;
//
//  THIS CODE AND INFORMATION IS PROVIDED "AS IS" WITHOUT WARRANTY OF ANY
//  KIND, EITHER EXPRESSED OR IMPLIED, INCLUDING BUT NOT LIMITED TO THE
//  IMPLIED WARRANTIES OF MERCHANTABILITY AND/OR FITNESS FOR A PARTICULAR
//  PURPOSE.
//
//  File: tldb.cpp
//
//  Copyright (c) Microsoft Corporation.  All Rights Reserved.
//
//@@@@AUTOBLOCK-============================================================;

#include <streams.h>
#include "stdafx.h"
#include "tldb.h"

int function_not_done = 0;
double TIMELINE_DEFAULT_FPS = 15.0;
const int OUR_STREAM_VERSION = 0;

#include <initguid.h>

DEFINE_GUID( DefaultTransition,
0x810E402F, 0x056B, 0x11D2, 0xA4, 0x84, 0x00, 0xC0, 0x4F, 0x8E, 0xFB, 0x69 );

DEFINE_GUID( DefaultEffect,
0xF515306D, 0x0156, 0x11D2, 0x81, 0xEA, 0x00, 0x00, 0xF8, 0x75, 0x57, 0xDB );

//############################################################################
// 
//############################################################################

//
// CreateInstance
//
// Creator function for the class ID
//
CUnknown * WINAPI CAMTimeline::CreateInstance( LPUNKNOWN pUnk, HRESULT * phr )
{
    return new CAMTimeline( TEXT( "MS Timeline" ), pUnk, phr );
}

//############################################################################
// 
//############################################################################

CAMTimeline::CAMTimeline( TCHAR *pName, LPUNKNOWN pUnk, HRESULT * phr )
    : CUnknown( pName, pUnk )
    , m_nSpliceMode( 0 )
    , m_dDefaultFPS( TIMELINE_DEFAULT_FPS )
    , m_nInsertMode( TIMELINE_INSERT_MODE_OVERLAY )
    , m_nGroups( 0 )
    , m_bTransitionsEnabled( TRUE )
    , m_bEffectsEnabled( TRUE )
    , m_DefaultEffect( DefaultEffect )
    , m_DefaultTransition( DefaultTransition )
    , m_punkSite( NULL )
{
}

//############################################################################
// 
//############################################################################

CAMTimeline::~CAMTimeline( )
{
    ClearAllGroups( );
}

//############################################################################
// 
//############################################################################

STDMETHODIMP CAMTimeline::NonDelegatingQueryInterface(REFIID riid, void **ppv)
{
    if( riid == IID_IAMSetErrorLog )
    {
        return GetInterface( (IAMSetErrorLog*) this, ppv );
    }
    if( riid == IID_IAMTimeline )
    {
        return GetInterface( (IAMTimeline*) this, ppv );
    }
    if( riid == IID_IObjectWithSite )
    {            
        return GetInterface( (IObjectWithSite*) this, ppv );
    }
    if( riid == IID_IServiceProvider )
    {            
        return GetInterface( (IServiceProvider*) this, ppv );
    }
    
    return CUnknown::NonDelegatingQueryInterface( riid, ppv );
}

//############################################################################
// 
//############################################################################

STDMETHODIMP CAMTimeline::CreateEmptyNode( IAMTimelineObj ** ppObj, TIMELINE_MAJOR_TYPE TimelineType )
{
    CheckPointer( ppObj, E_POINTER );

    HRESULT hr = 0;

    switch( TimelineType )
    {
        case TIMELINE_MAJOR_TYPE_GROUP:
            {
            CAMTimelineGroup * p = new CAMTimelineGroup( NAME( "Timeline Group" ), NULL, &hr );
            *ppObj = p;
            if( p )
            {
                p->SetOutputFPS( m_dDefaultFPS );
            }
            break;
            }
        case TIMELINE_MAJOR_TYPE_COMPOSITE:
            {
            CAMTimelineComp * p = new CAMTimelineComp( NAME( "Timeline Comp" ), NULL, &hr );
            *ppObj = p;
            break;
            }
    case TIMELINE_MAJOR_TYPE_TRACK:
            {
            CAMTimelineTrack * p = new CAMTimelineTrack( NAME( "Timeline Track" ), NULL, &hr );
            *ppObj = p;
            break;
            }
    case TIMELINE_MAJOR_TYPE_SOURCE:
            {
            CAMTimelineSrc * p = new CAMTimelineSrc( NAME( "Timeline Source" ), NULL, &hr );
            *ppObj = p;
            break;
            }
    case TIMELINE_MAJOR_TYPE_TRANSITION:
            {
            CAMTimelineTrans * p = new CAMTimelineTrans( NAME( "Timeline Transition" ), NULL, &hr );
            *ppObj = p;
            break;
            }
    case TIMELINE_MAJOR_TYPE_EFFECT:
            {
            CAMTimelineEffect * p = new CAMTimelineEffect( NAME( "Timeline Effect" ), NULL, &hr );
            *ppObj = p;
            break;
            }
        default:
            return E_INVALIDARG;
    }

    if( NULL == *ppObj )
    {
        return E_OUTOFMEMORY;
    }

    // the major type's already set by the new call, set the mid type
    //
    (*ppObj)->AddRef( );

    return NOERROR;
}

//############################################################################
// 
//############################################################################

STDMETHODIMP CAMTimeline::GetInsertMode(long * pMode)
{
    CheckPointer( pMode, E_POINTER );

    *pMode = m_nInsertMode;

    return NOERROR;
}

//############################################################################
// 
//############################################################################

STDMETHODIMP CAMTimeline::SetInsertMode(long Mode)
{
    return E_NOTIMPL; // this is okay, for now
}

//############################################################################
// 
//############################################################################

STDMETHODIMP CAMTimeline::EnableTransitions(BOOL fEnabled)
{
    m_bTransitionsEnabled = fEnabled;
    return NOERROR;

}

//############################################################################
// 
//############################################################################

STDMETHODIMP CAMTimeline::TransitionsEnabled(BOOL * pfEnabled)
{
    CheckPointer( pfEnabled, E_POINTER );
    *pfEnabled = (BOOL) m_bTransitionsEnabled;
    return NOERROR;
}

//############################################################################
// 
//############################################################################

STDMETHODIMP CAMTimeline::EnableEffects(BOOL fEnabled)
{
    m_bEffectsEnabled = fEnabled;
    return NOERROR;
}

//############################################################################
// 
//############################################################################

STDMETHODIMP CAMTimeline::EffectsEnabled(BOOL * pfEnabled)
{
    CheckPointer( pfEnabled, E_POINTER );
    *pfEnabled = (BOOL) m_bEffectsEnabled;
    return NOERROR;
}

//############################################################################
// 
//############################################################################

STDMETHODIMP CAMTimeline::SetInterestRange(REFERENCE_TIME Start, REFERENCE_TIME Stop)
{
    // what should we do here? we have a bunch of groups and
    // a bunch of tracks and how the heck do we get rid of the commie objects?
    //
    return E_NOTIMPL; // setinterestrange, not yet working.
}

//############################################################################
// 
//############################################################################

STDMETHODIMP CAMTimeline::GetDuration(REFERENCE_TIME * pDuration)
{
    CheckPointer( pDuration, E_POINTER );

    // have to go through all the groups and get the durations of each
    //
    REFERENCE_TIME MaxStop = 0; 
    for( int i = 0 ; i < m_nGroups ; i++ )
    {
        REFERENCE_TIME Start = 0;
        REFERENCE_TIME Stop = 0;
        m_pGroup[i]->GetStartStop( &Start, &Stop );
        MaxStop = max( MaxStop, Stop );
    }
    *pDuration = MaxStop;

    return NOERROR;
}

STDMETHODIMP CAMTimeline::GetDuration2(double * pDuration)
{
    CheckPointer( pDuration, E_POINTER );
    *pDuration = 0;

    REFERENCE_TIME Duration = 0;
    HRESULT hr = GetDuration( &Duration );
    if( FAILED( hr ) )
    {
        return hr;
    }

    *pDuration = RTtoDouble( Duration );
    return NOERROR;
}

//############################################################################
// 
//############################################################################

STDMETHODIMP CAMTimeline::SetDefaultFPS(double FPS)
{
    // !!! truncate FPS to 3 decimal places?
    // m_dDefaultFPS = double( long( FPS * 1000.0 ) / 1000.0 );

    // can't have the frame rate be zero
    if( FPS <= 0.0 )
    {
        return E_INVALIDARG;
    }

    m_dDefaultFPS = FPS;

    return NOERROR;
}

//############################################################################
// 
//############################################################################

STDMETHODIMP CAMTimeline::GetDefaultFPS(double * pFPS)
{
    CheckPointer( pFPS, E_POINTER );

    *pFPS = m_dDefaultFPS;

    return NOERROR;
}

//############################################################################
// 
//############################################################################

STDMETHODIMP CAMTimeline::IsDirty(BOOL * pDirty)
{
    CheckPointer( pDirty, E_POINTER );

    // we are dirty if any of our groups are dirty
    //
    for( int i = 0 ; i < m_nGroups ; i++ )
    {
        REFERENCE_TIME Start, Stop;
        Start = 0;
        Stop = 0;
        m_pGroup[i]->GetDirtyRange( &Start, &Stop );
        if( Stop > 0 )
        {
            *pDirty = TRUE;
            return NOERROR;
        }
    }

    *pDirty = FALSE;
    return NOERROR;
}

//############################################################################
// 
//############################################################################

STDMETHODIMP CAMTimeline::GetDirtyRange2(REFTIME * pStart, REFTIME * pStop)
{
    return GetDirtyRange( (REFERENCE_TIME*) &pStart, (REFERENCE_TIME*) &pStop );
}

//############################################################################
// 
//############################################################################

STDMETHODIMP CAMTimeline::GetDirtyRange(REFERENCE_TIME * pStart, REFERENCE_TIME * pStop)
{
    CheckPointer( pStart, E_POINTER );
    CheckPointer( pStop, E_POINTER );

    // we are dirty if any of our groups are dirty
    //
    REFERENCE_TIME MaxStop = 0;
    for( int i = 0 ; i < m_nGroups ; i++ )
    {
        REFERENCE_TIME Start, Stop;
        Start = 0;
        Stop = 0;
        m_pGroup[i]->GetDirtyRange( &Start, &Stop );
        if( Stop > MaxStop )
        {
            Stop = MaxStop;
        }
    }

    *pStart = 0;
    *pStop = MaxStop;
    return NOERROR;
}

//############################################################################
// 
//############################################################################

REFERENCE_TIME CAMTimeline::Fixup( REFERENCE_TIME Time )
{
    // bump up then down to get fixed up times
    //
    LONGLONG Frame = Time2Frame( Time, m_dDefaultFPS );
    Time = Frame2Time( Frame, m_dDefaultFPS );
    return Time;
}

//############################################################################
// 
//############################################################################

STDMETHODIMP CAMTimeline::GetCountOfType
    (long Group, long * pVal, long * pValWithComps, TIMELINE_MAJOR_TYPE MajorType )
{
    CheckPointer( pVal, E_POINTER );

    if( Group < 0 )
    {
        return E_INVALIDARG;
    }
    if( Group >= m_nGroups )
    {
        return E_INVALIDARG;
    }

    CComQIPtr< IAMTimelineComp, &IID_IAMTimelineComp > pComp( m_pGroup[Group] );
    return pComp->GetCountOfType( pVal, pValWithComps, MajorType );
}

//############################################################################
// 
//############################################################################

STDMETHODIMP CAMTimeline::AddGroup( IAMTimelineObj * pGroupObj )
{
    CheckPointer( pGroupObj, E_POINTER );

    // only allow so many groups
    //
    if( m_nGroups >= MAX_TIMELINE_GROUPS )
    {
        return E_INVALIDARG;
    }

    // make sure it's a group
    //
    CComQIPtr< IAMTimelineGroup, &IID_IAMTimelineGroup > pAddedGroup( pGroupObj );
    if( !pAddedGroup )
    {
        return E_NOINTERFACE;
    }

    m_pGroup[m_nGroups] = pGroupObj;
    m_nGroups++;
    pAddedGroup->SetTimeline( this );
    return NOERROR;
}

//############################################################################
// 
//############################################################################

STDMETHODIMP CAMTimeline::RemGroupFromList( IAMTimelineObj * pGroupObj )
{
    CheckPointer( pGroupObj, E_POINTER );

    for( int i = 0 ; i < m_nGroups ; i++ )
    {
        if( m_pGroup[i] == pGroupObj )
        {
            m_pGroup[i] = m_pGroup[m_nGroups-1];
            m_pGroup[m_nGroups-1].Release( );
            m_nGroups--;
            return NOERROR;
        }
    }
    return S_FALSE;
}

//############################################################################
// 
//############################################################################

STDMETHODIMP CAMTimeline::GetGroup( IAMTimelineObj ** ppGroupObj, long WhichGroup )
{
    CheckPointer( ppGroupObj, E_POINTER );
    if( WhichGroup < 0 || WhichGroup >= m_nGroups )
    {
        return E_INVALIDARG;
    }
    *ppGroupObj = m_pGroup[WhichGroup];
    (*ppGroupObj)->AddRef( );
    return NOERROR;
}

//############################################################################
// 
//############################################################################

STDMETHODIMP CAMTimeline::GetGroupCount( long * pCount )
{
    CheckPointer( pCount, E_POINTER );
    *pCount = m_nGroups;
    return NOERROR;
}

//############################################################################
// 
//############################################################################

STDMETHODIMP CAMTimeline::ClearAllGroups( )
{
    while(m_nGroups > 0)
    {
        HRESULT hr = m_pGroup[0]->RemoveAll();
        if (FAILED(hr))
	    return hr;
    }
    return NOERROR;
}

//############################################################################
// 
//############################################################################

STDMETHODIMP CAMTimeline::SetDefaultEffect( GUID * pDummyGuid )
{
    GUID * pGuid = (GUID*) pDummyGuid;
    CheckPointer( pGuid, E_POINTER );
    m_DefaultEffect = *pGuid;
    return NOERROR;
}

//############################################################################
// 
//############################################################################

STDMETHODIMP CAMTimeline::GetDefaultEffect( GUID * pGuid )
{
    CheckPointer( pGuid, E_POINTER );
    *pGuid = m_DefaultEffect;
    return NOERROR;
}

//############################################################################
// 
//############################################################################

STDMETHODIMP CAMTimeline::SetDefaultTransition( GUID * pGuid )
{
    CheckPointer( pGuid, E_POINTER );
    m_DefaultTransition = *pGuid;
    return NOERROR;
}

//############################################################################
// 
//############################################################################

STDMETHODIMP CAMTimeline::GetDefaultTransition( GUID * pGuid )
{
    CheckPointer( pGuid, E_POINTER );
    *pGuid = m_DefaultTransition;
    return NOERROR;
}

//############################################################################
// 
//############################################################################

STDMETHODIMP CAMTimeline::SetDefaultEffectB( BSTR pGuid )
{
    GUID g;
    HRESULT hr = CLSIDFromString( pGuid, &g );
    if( FAILED( hr ) ) return hr;
    m_DefaultEffect = g;
    return NOERROR;
}

//############################################################################
// 
//############################################################################

STDMETHODIMP CAMTimeline::GetDefaultEffectB( BSTR * pGuid )
{
    HRESULT hr;

    WCHAR * TempVal = NULL;
    hr = StringFromCLSID( m_DefaultEffect, &TempVal );
    if( FAILED( hr ) )
    {
        return hr;
    }
    *pGuid = SysAllocString( TempVal );
    CoTaskMemFree( TempVal );
    if( !(*pGuid) ) return E_OUTOFMEMORY;
    return NOERROR;
}

//############################################################################
// 
//############################################################################

STDMETHODIMP CAMTimeline::SetDefaultTransitionB( BSTR pGuid )
{
    GUID g;
    HRESULT hr = CLSIDFromString( pGuid, &g );
    if( FAILED( hr ) ) return hr;
    m_DefaultTransition = g;
    return NOERROR;
}

//############################################################################
// 
//############################################################################

STDMETHODIMP CAMTimeline::GetDefaultTransitionB( BSTR * pGuid )
{
    HRESULT hr;

    WCHAR * TempVal = NULL;
    hr = StringFromCLSID( m_DefaultTransition, &TempVal );
    if( FAILED( hr ) )
    {
        return hr;
    }
    *pGuid = SysAllocString( TempVal );
    CoTaskMemFree( TempVal );
    if( !(*pGuid) ) return E_OUTOFMEMORY;
    return NOERROR;
}

//############################################################################
// flag an error back to the app.
//############################################################################

HRESULT _GenerateError( 
                       IAMTimelineObj * pObj, 
                       long Severity, 
                       WCHAR * pErrorString, 
                       LONG ErrorCode, 
                       HRESULT hresult, 
                       VARIANT * pExtraInfo )
{
    HRESULT hr = hresult;
    if( pObj )
    {
        IAMTimeline * pTimeline = NULL;
        pObj->GetTimelineNoRef( &pTimeline );
        if( pTimeline )
        {
            CAMTimeline * pCTimeline = static_cast<CAMTimeline*>( pTimeline );
            pCTimeline->_GenerateError( Severity, pErrorString, ErrorCode, ErrorCode, pExtraInfo );
        }
    }

    return hr;
}

//############################################################################
// 
//############################################################################

STDMETHODIMP CAMTimeline::ValidateSourceNames
    ( long ValidateFlags, IMediaLocator * pOverride, LONG_PTR lNotifyEventHandle )
{
    BOOL Replace = 
        ( ( ValidateFlags & SFN_VALIDATEF_REPLACE ) == SFN_VALIDATEF_REPLACE );
    BOOL IgnoreMuted = 
        ( ( ValidateFlags & SFN_VALIDATEF_IGNOREMUTED ) == SFN_VALIDATEF_IGNOREMUTED );
    BOOL DoCheck = ( ( ValidateFlags & SFN_VALIDATEF_CHECK ) == SFN_VALIDATEF_CHECK );

    if( !Replace || !DoCheck )
    {
        return E_INVALIDARG;
    }

    HANDLE NotifyEventHandle = (HANDLE) lNotifyEventHandle;
    if( NotifyEventHandle ) ResetEvent( NotifyEventHandle );

    HRESULT hr = 0;
    CComPtr< IMediaLocator > pLoc;
    if( pOverride )
    {
        pLoc = pOverride;
    }
    else
    {
        hr = CoCreateInstance(
            CLSID_MediaLocator,
            NULL,
            CLSCTX_INPROC_SERVER,
            IID_IMediaLocator,
            (void**) &pLoc );
        if( FAILED( hr ) )
        {
            return hr;
        }
    }

    // create a media locator for us to check

    for( int Group = 0 ; Group < m_nGroups ; Group++ )
    {
        // get the group
        //
        CComPtr< IAMTimelineObj > pObj = m_pGroup[Group];
        CComQIPtr< IAMTimelineGroup, &IID_IAMTimelineGroup > pGroup( pObj );
        CComQIPtr< IAMTimelineComp, &IID_IAMTimelineComp > pComp( pObj );

        // ask timeline for how many layers and tracks we've got
        //
        long TrackCount = 0;   // tracks only
        long LayerCount = 0;       // tracks including compositions
        GetCountOfType( Group, &TrackCount, &LayerCount, TIMELINE_MAJOR_TYPE_TRACK );
        if( TrackCount < 1 )
        {
            continue;
        }

        for(  int CurrentLayer = 0 ; CurrentLayer < LayerCount ; CurrentLayer++ )
        {
            // get the layer itself
            //
            CComPtr< IAMTimelineObj > pLayer;
            hr = pComp->GetRecursiveLayerOfType( &pLayer, CurrentLayer, TIMELINE_MAJOR_TYPE_TRACK );
            ASSERT( !FAILED( hr ) );
            if( FAILED( hr ) )
            {
                continue; // audio layers
            }

            // if it's not an actual TRACK, then continue, who cares
            //
            CComQIPtr< IAMTimelineTrack, &IID_IAMTimelineTrack > pTrack( pLayer );
            if( !pTrack )
            {
                continue; // audio layers
            }

            // run all the sources on this layer
            //
            REFERENCE_TIME InOut = 0;
            while( 1 )
            {
                CComPtr< IAMTimelineObj > pSourceObj;
                hr = pTrack->GetNextSrc( &pSourceObj, &InOut );

                // ran out of sources, so we're done
                //
                if( hr != NOERROR )
                {
                    break;
                }

                BOOL Muted = FALSE;
                pSourceObj->GetMuted( &Muted );
                if( Muted && IgnoreMuted )
                {
                    continue;
                }

                CComQIPtr< IAMTimelineSrc, &IID_IAMTimelineSrc > pSource( pSourceObj );
                CComBSTR bszMediaName;
                hr = pSource->GetMediaName( &bszMediaName );
                if( FAILED( hr ) )
                {
                    continue; // ignore it, doesn't have to work
                }

                // can this happen?
                //
                if( bszMediaName[0] == 0 )
                {
                    continue;
                }

                HRESULT FoundHr = 0;
                CComBSTR FoundName;

                // validate the name here
                //
                FoundHr = pLoc->FindMediaFile( bszMediaName, NULL, &FoundName, ValidateFlags );

                if( FoundHr == S_FALSE )
                {
                    pSource->SetMediaName( FoundName );
                }
            } // while sources

        } // while layers

    } // while groups

    if( NotifyEventHandle ) SetEvent( NotifyEventHandle );
    return NOERROR;
}

//############################################################################
// 
//############################################################################
// IObjectWithSite::SetSite
// remember who our container is, for QueryService or other needs
STDMETHODIMP CAMTimeline::SetSite(IUnknown *pUnkSite)
{
    // note: we cannot addref our site without creating a circle
    // luckily, it won't go away without releasing us first.
    m_punkSite = pUnkSite;
    
    return S_OK;
}

//############################################################################
// 
//############################################################################
// IObjectWithSite::GetSite
// return an addrefed pointer to our containing object
STDMETHODIMP CAMTimeline::GetSite(REFIID riid, void **ppvSite)
{
    if (m_punkSite)
        return m_punkSite->QueryInterface(riid, ppvSite);
    
    return E_NOINTERFACE;
}

//############################################################################
// 
//############################################################################
// Forward QueryService calls up to the "real" host
STDMETHODIMP CAMTimeline::QueryService(REFGUID guidService, REFIID riid, void **ppvObject)
{
    IServiceProvider *pSP;
    
    if (!m_punkSite)
        return E_NOINTERFACE;
    
    HRESULT hr = m_punkSite->QueryInterface(IID_IServiceProvider, (void **) &pSP);
    
    if (SUCCEEDED(hr)) {
        hr = pSP->QueryService(guidService, riid, ppvObject);
        pSP->Release();
    }
    
    return hr;
}

//############################################################################
// 
//############################################################################
=== C:/Users/treeman/Desktop/windows nt source code\Source\Win2K3\NT\multimedia\dshow\filterus\dexter\tldb\tldbfxbl.cpp ===
//@@@@AUTOBLOCK+============================================================;
//
//  THIS CODE AND INFORMATION IS PROVIDED "AS IS" WITHOUT WARRANTY OF ANY
//  KIND, EITHER EXPRESSED OR IMPLIED, INCLUDING BUT NOT LIMITED TO THE
//  IMPLIED WARRANTIES OF MERCHANTABILITY AND/OR FITNESS FOR A PARTICULAR
//  PURPOSE.
//
//  File: tldbfxbl.cpp
//
//  Copyright (c) Microsoft Corporation.  All Rights Reserved.
//
//@@@@AUTOBLOCK-============================================================;

#include <streams.h>
#include "stdafx.h"
#include "tldb.h"

const long OUR_STREAM_VERSION = 0;

//############################################################################
// 
//############################################################################

CAMTimelineEffectable::CAMTimelineEffectable( )
{
}

//############################################################################
// 
//############################################################################

CAMTimelineEffectable::~CAMTimelineEffectable( )
{
}

//############################################################################
// 
//############################################################################

STDMETHODIMP CAMTimelineEffectable::EffectInsBefore
    (IAMTimelineObj * pFX, long priority)
{
    HRESULT hr = 0;

    // make sure somebody's really inserting an effect
    //
    CComQIPtr< IAMTimelineEffect, &IID_IAMTimelineEffect > pEffect( pFX );
    if( !pEffect )
    {
        return E_NOTIMPL;
    }

    CComQIPtr< IAMTimelineNode, &IID_IAMTimelineNode > pThis( (IUnknown*) this );
    hr = pThis->XAddKidByPriority( TIMELINE_MAJOR_TYPE_EFFECT, pFX, priority );
    return hr;
}

//############################################################################
// 
//############################################################################

STDMETHODIMP CAMTimelineEffectable::EffectSwapPriorities
    (long PriorityA, long PriorityB)
{
    HRESULT hr = 0;

    CComQIPtr< IAMTimelineNode, &IID_IAMTimelineNode > pThis( (IUnknown*) this );

    hr = pThis->XSwapKids( TIMELINE_MAJOR_TYPE_EFFECT, PriorityA, PriorityB );

    return hr;
}

//############################################################################
// 
//############################################################################

STDMETHODIMP CAMTimelineEffectable::EffectGetCount
    (long * pCount)
{
    HRESULT hr = 0;

    CComQIPtr< IAMTimelineNode, &IID_IAMTimelineNode > pThis( (IUnknown*) this );

    CheckPointer( pCount, E_POINTER );

    hr = pThis->XKidsOfType( TIMELINE_MAJOR_TYPE_EFFECT, pCount );

    return hr;
}

//############################################################################
// 
//############################################################################

STDMETHODIMP CAMTimelineEffectable::GetEffect
    (IAMTimelineObj ** ppFx, long Which)
{
    HRESULT hr = 0;

    CComQIPtr< IAMTimelineNode, &IID_IAMTimelineNode > pThis( (IUnknown*) this );

    CheckPointer( ppFx, E_POINTER );

    hr = pThis->XGetNthKidOfType( TIMELINE_MAJOR_TYPE_EFFECT, Which, ppFx );

    return hr;
}
=== C:/Users/treeman/Desktop/windows nt source code\Source\Win2K3\NT\multimedia\dshow\filterus\dexter\tldb\tldbfx.cpp ===
//@@@@AUTOBLOCK+============================================================;
//
//  THIS CODE AND INFORMATION IS PROVIDED "AS IS" WITHOUT WARRANTY OF ANY
//  KIND, EITHER EXPRESSED OR IMPLIED, INCLUDING BUT NOT LIMITED TO THE
//  IMPLIED WARRANTIES OF MERCHANTABILITY AND/OR FITNESS FOR A PARTICULAR
//  PURPOSE.
//
//  File: tldbfx.cpp
//
//  Copyright (c) Microsoft Corporation.  All Rights Reserved.
//
//@@@@AUTOBLOCK-============================================================;

#include <streams.h>
#include "stdafx.h"
#include "tldb.h"

//############################################################################
// 
//############################################################################

CAMTimelineEffect::CAMTimelineEffect( TCHAR *pName, LPUNKNOWN pUnk, HRESULT * phr )
    : CAMTimelineObj( pName, pUnk, phr )
    , m_bRealSave( FALSE )
    , m_nSaveLength( 0 )
{
    m_ClassID = CLSID_AMTimelineEffect;
    m_TimelineType = TIMELINE_MAJOR_TYPE_EFFECT;
    XSetPriorityOverTime( );
}

//############################################################################
// 
//############################################################################

CAMTimelineEffect::~CAMTimelineEffect( )
{
}

//############################################################################
// 
//############################################################################

STDMETHODIMP CAMTimelineEffect::NonDelegatingQueryInterface(REFIID riid, void **ppv)
{
    if( riid == IID_IAMTimelineEffect )
    {
        return GetInterface( (IAMTimelineEffect*) this, ppv );
    }
    if( riid == IID_IAMTimelineSplittable )
    {
        return GetInterface( (IAMTimelineSplittable*) this, ppv );
    }
    return CAMTimelineObj::NonDelegatingQueryInterface( riid, ppv );
}

//############################################################################
// 
//############################################################################

STDMETHODIMP CAMTimelineEffect::EffectGetPriority(long * pVal)
{
    CheckPointer( pVal, E_POINTER );

    HRESULT hr = XWhatPriorityAmI( TIMELINE_MAJOR_TYPE_EFFECT, pVal );
    return hr;
}

//############################################################################
// 
//############################################################################

STDMETHODIMP CAMTimelineEffect::SplitAt2( REFTIME t )
{
    REFERENCE_TIME t1 = DoubleToRT( t );
    return SplitAt( t1 );
}

STDMETHODIMP CAMTimelineEffect::SplitAt( REFERENCE_TIME SplitTime )
{
    // is our split time withIN our time?
    //
    if( SplitTime <= m_rtStart || SplitTime >= m_rtStop )
    {
        return E_INVALIDARG;
    }

    // we need to be attached to something.
    //
    IAMTimelineObj * pParent;
    XGetParentNoRef( &pParent );
    if( !pParent )
    {
        return E_INVALIDARG;
    }

    HRESULT hr = 0;
    CAMTimelineEffect * pNew = new CAMTimelineEffect( NAME("Timeline Effect"), NULL, &hr );
    if( FAILED( hr ) )
    {
        return E_OUTOFMEMORY;
    }

    // we have created an object that has NO references on it. If we call ANYTHING that
    // addreffs and releases the pNewSrc, it will be deleted. So addref it NOW.

    pNew->AddRef( );

    hr = CopyDataTo( pNew, SplitTime );
    if( FAILED( hr ) )
    {
        delete pNew;
        return hr;
    }

    pNew->m_rtStart = SplitTime;
    pNew->m_rtStop = m_rtStop;
    m_rtStop = SplitTime;

    // get our priority
    //
    long Priority = 0;
    hr = EffectGetPriority( &Priority );

    // need to add the new transition to the tree
    //
    CComQIPtr< IAMTimelineEffectable, &IID_IAMTimelineEffectable > pEffectable( pParent );
    hr = pEffectable->EffectInsBefore( pNew, Priority + 1 );

    if( !FAILED( hr ) )
    {
        pNew->Release( );
    }

    return hr;
}


//############################################################################
// 
//############################################################################

STDMETHODIMP CAMTimelineEffect::SetSubObject(IUnknown* newVal)
{
    HRESULT hr = 0;

    hr = CAMTimelineObj::SetSubObject( newVal );

    return NOERROR;
}

//############################################################################
// 
//############################################################################

STDMETHODIMP CAMTimelineEffect::GetStartStop2
    (REFTIME * pStart, REFTIME * pStop)
{
    REFERENCE_TIME p1;
    REFERENCE_TIME p2;
    HRESULT hr = GetStartStop( &p1, &p2 );
    *pStart = RTtoDouble( p1 );
    *pStop = RTtoDouble( p2 );
    return hr;
}

STDMETHODIMP CAMTimelineEffect::GetStartStop
    (REFERENCE_TIME * pStart, REFERENCE_TIME * pStop)
{
    HRESULT hr = CAMTimelineObj::GetStartStop( pStart, pStop );
    if( FAILED( hr ) )
    {
        return hr;
    }

    // make sure the times we got don't exceed our parent's
    //
    IAMTimelineObj * pParent = NULL;
    hr = XGetParentNoRef( &pParent );
    if( !pParent )
    {
        return NOERROR;
    }
    REFERENCE_TIME ParentStart = *pStart;
    REFERENCE_TIME ParentStop = *pStop;
    hr = pParent->GetStartStop( &ParentStart, &ParentStop );
    if( FAILED( hr ) )
    {
        return NOERROR;
    }
    REFERENCE_TIME ParentDuration = ParentStop - ParentStart;
    if( *pStart < 0 )
    {
        *pStart = 0;
    }
    if( *pStart > ParentDuration )
    {
        *pStart = ParentDuration;
    }
    if( *pStop > ParentDuration )
    {
        *pStop = ParentDuration;
    }
    return NOERROR;
}
=== C:/Users/treeman/Desktop/windows nt source code\Source\Win2K3\NT\multimedia\dshow\filterus\dexter\tldb\tldbnode.cpp ===
//@@@@AUTOBLOCK+============================================================;
//
//  THIS CODE AND INFORMATION IS PROVIDED "AS IS" WITHOUT WARRANTY OF ANY
//  KIND, EITHER EXPRESSED OR IMPLIED, INCLUDING BUT NOT LIMITED TO THE
//  IMPLIED WARRANTIES OF MERCHANTABILITY AND/OR FITNESS FOR A PARTICULAR
//  PURPOSE.
//
//  File: tldbnode.cpp
//
//  Copyright (c) Microsoft Corporation.  All Rights Reserved.
//
//@@@@AUTOBLOCK-============================================================;

#include <streams.h>
#include "stdafx.h"
#include "tldb.h"

//############################################################################
// 
//############################################################################

CAMTimelineNode::CAMTimelineNode( )
: m_pParent( NULL )
, m_pNext( NULL )
, m_pPrev( NULL )
, m_pKid( NULL )
, m_bPriorityOverTime( FALSE )
{
}

//############################################################################
// 
//############################################################################

CAMTimelineNode::~CAMTimelineNode( )
{
    // the order in which release things is important. Don't do it otherwise
    m_pParent = NULL;
    m_pNext = NULL;
    m_pPrev = NULL;
    m_pKid = NULL;
}

//############################################################################
// 
//############################################################################

HRESULT CAMTimelineNode::XGetParent( IAMTimelineObj ** ppResult )
{
    CheckPointer( ppResult, E_POINTER );
    if( m_pParent )
    {
        *ppResult = m_pParent;
        (*ppResult)->AddRef( );
    }
    return NOERROR;
}

HRESULT CAMTimelineNode::XGetParentNoRef( IAMTimelineObj ** ppResult )
{
    CheckPointer( ppResult, E_POINTER );
    if( m_pParent )
    {
        *ppResult = m_pParent;
    }
    return NOERROR;
}

//############################################################################
// 
//############################################################################

HRESULT CAMTimelineNode::XSetParent( IAMTimelineObj * pObj )
{
    m_pParent = pObj;
    return NOERROR;
}

//############################################################################
// 
//############################################################################

HRESULT CAMTimelineNode::XGetPrev( IAMTimelineObj ** ppResult )
{
    CheckPointer( ppResult, E_POINTER );

    HRESULT hr = XGetPrevNoRef( ppResult );
    if( *ppResult )
    {
        (*ppResult)->AddRef( );
    }
    return hr;
}

//############################################################################
// 
//############################################################################

HRESULT CAMTimelineNode::XSetPrev( IAMTimelineObj * pObj )
{
    m_pPrev = pObj;
    return NOERROR;
}

//############################################################################
// 
//############################################################################

HRESULT CAMTimelineNode::XGetNext( IAMTimelineObj ** ppResult )
{
    CheckPointer( ppResult, E_POINTER );
    HRESULT hr = XGetNextNoRef( ppResult );
    if( *ppResult )
    {
        (*ppResult)->AddRef( );
    }
    return hr;
}

//############################################################################
// 
//############################################################################

HRESULT CAMTimelineNode::XSetNext( IAMTimelineObj * pObj )
{
    m_pNext = pObj;
    return NOERROR;
}

//############################################################################
// 
//############################################################################

HRESULT CAMTimelineNode::XKidsOfType( long MajorTypeCombo, long * pVal )
{
    CheckPointer( pVal, E_POINTER );

    // if no kids, return 0
    //
    if( !m_pKid )
    {
        *pVal = 0;
        return NOERROR;
    }

    // since we never use bumping of refcounts in here, don't use a CComPtr
    //
    IAMTimelineObj * p = m_pKid; // okay not CComPtr

    long count = 0;

    while( p )
    {
        TIMELINE_MAJOR_TYPE Type;
        p->GetTimelineType( &Type );
        if( ( Type & MajorTypeCombo ) == Type )
        {
            count++;
        }

        // get the next kid
        //
        CComQIPtr< IAMTimelineNode, &IID_IAMTimelineNode > p2( p );
        p2->XGetNextNoRef( &p );
    }

    *pVal = count;
    return NOERROR;
}

//############################################################################
// 
//############################################################################


HRESULT CAMTimelineNode::XGetNthKidOfType
    ( long MajorTypeCombo, long Number, IAMTimelineObj ** ppResult )
{
    // since we never use bumping of refcounts in here, don't use a CComPtr
    //
    IAMTimelineObj * p = m_pKid; // okay not CComPtr

    while( p )
    {
        // get the type
        //
        TIMELINE_MAJOR_TYPE Type;
        p->GetTimelineType( &Type ); // assume won't fail

        // found a type that matches, decrement how many we're looking for.
        //
        if( ( Type & MajorTypeCombo ) == Type )
        {
            // if Number is 0, then we've found the Xth child, return it.
            //
            if( Number == 0 )
            {
                *ppResult = p;
                (*ppResult)->AddRef( );
                return NOERROR;
            }

            // not yet, go get the next one
            //
            Number--;
        }

        // doesn't match our type, get the next one
        //
        IAMTimelineNode *p2;    // avoid CComPtr for perf
        p->QueryInterface(IID_IAMTimelineNode, (void **)&p2);
        p2->XGetNextNoRef( &p );
        p2->Release();
    } // while p

    *ppResult = NULL;
    return S_FALSE;
}

//############################################################################
// 
//############################################################################

HRESULT CAMTimelineNode::XSwapKids( long MajorTypeCombo, long KidA, long KidB )
{
    long KidCount = 0;
    XKidsOfType( MajorTypeCombo, &KidCount );
    if( ( KidA < 0 ) || ( KidB < 0 ) )
    {
        return E_INVALIDARG;
    }
    if( ( KidA >= KidCount ) || ( KidB >= KidCount ) )
    {
        return E_INVALIDARG;
    }

    // there are two things we can swap so far, tracks and effects, both of them
    // take priorities. 

    // make this easier on us
    //
    long min = min( KidA, KidB );
    long max = max( KidA, KidB );

    // get the objects themselves
    //
    CComPtr< IAMTimelineObj > pMinKid;
    HRESULT hr;
    hr = XGetNthKidOfType( MajorTypeCombo, min, &pMinKid );
    CComPtr< IAMTimelineObj > pMaxKid;
    hr = XGetNthKidOfType( MajorTypeCombo, max, &pMaxKid );
    CComQIPtr< IAMTimelineNode, &IID_IAMTimelineNode > pMinKidNode( pMinKid );
    CComQIPtr< IAMTimelineNode, &IID_IAMTimelineNode > pMaxKidNode( pMaxKid );

    // don't compare for being the exact same type, we already know this works
    // because we got the "nth" kid of the right type

    // get everyone's neighboors
    //
    CComPtr< IAMTimelineObj > pMinKidPrev;
    hr = pMinKidNode->XGetPrev( &pMinKidPrev );
    CComPtr< IAMTimelineObj > pMinKidNext;
    hr = pMinKidNode->XGetNext( &pMinKidNext );
    CComPtr< IAMTimelineObj > pMaxKidPrev;
    hr = pMaxKidNode->XGetPrev( &pMaxKidPrev );
    CComPtr< IAMTimelineObj > pMaxKidNext;
    hr = pMaxKidNode->XGetNext( &pMaxKidNext );

    // what if pMinKid what the first kid?
    //
    if( pMinKid == m_pKid )
    {
        m_pKid.Release( );
        m_pKid = pMaxKid;
    }

    // do something special if we're swapping direct neighboors
    //
    if( pMinKidNext == pMaxKid )
    {
        pMaxKidNode->XSetPrev( pMinKidPrev );
        pMinKidNode->XSetNext( pMaxKidNext );
        pMaxKidNode->XSetNext( pMinKid );
        pMinKidNode->XSetPrev( pMaxKid );
        if( pMinKidPrev )
        {
            CComQIPtr< IAMTimelineNode, &IID_IAMTimelineNode > pMinKidPrevNode( pMinKidPrev );
            pMinKidPrevNode->XSetNext( pMaxKid );
        }
        if( pMaxKidNext )
        {
            CComQIPtr< IAMTimelineNode, &IID_IAMTimelineNode > pMaxKidNextNode( pMaxKidNext );
            pMaxKidNextNode->XSetPrev( pMinKid );
        }
        return NOERROR;
    }

    pMaxKidNode->XSetPrev( pMinKidPrev );
    pMinKidNode->XSetNext( pMaxKidNext );
    pMaxKidNode->XSetNext( pMinKidNext );
    pMinKidNode->XSetPrev( pMaxKidPrev );
    if( pMinKidPrev )
    {
        CComQIPtr< IAMTimelineNode, &IID_IAMTimelineNode > pMinKidPrevNode( pMinKidPrev );
        pMinKidPrevNode->XSetNext( pMaxKid );
    }
    CComQIPtr< IAMTimelineNode, &IID_IAMTimelineNode > pMinKidNextNode( pMinKidNext );
    pMinKidNextNode->XSetPrev( pMaxKid );
    if( pMaxKidNext )
    {
        CComQIPtr< IAMTimelineNode, &IID_IAMTimelineNode > pMaxKidNextNode( pMaxKidNext );
        pMaxKidNextNode->XSetPrev( pMinKid );
    }
    CComQIPtr< IAMTimelineNode, &IID_IAMTimelineNode > pMaxKidPrevNode( pMaxKidPrev );
    pMaxKidPrevNode->XSetNext( pMinKid );

    return NOERROR;
}

//############################################################################
// 
//############################################################################

HRESULT CAMTimelineNode::XHaveParent( long * pVal )
{
    CheckPointer( pVal, E_POINTER );

    *pVal = 0;

    if( m_pParent ) 
    {
        *pVal = 1;
    }

    return NOERROR;
}

//############################################################################
// 
//############################################################################

HRESULT CAMTimelineNode::XWhatPriorityAmI( long MajorTypeCombo, long * pVal )
{
    CheckPointer( pVal, E_POINTER );

    IAMTimelineObj * pParent = NULL; // okay not ComPtr
    XGetParentNoRef( &pParent );
    CComQIPtr< IAMTimelineNode, &IID_IAMTimelineNode > pParent2( pParent );

    if( NULL == pParent )
    {
        *pVal = -1;
        return NOERROR;
    }

    long counter = 0;

    CComPtr< IAMTimelineObj > pKid; 
    pParent2->XGetNthKidOfType( MajorTypeCombo, 0, &pKid );

    while( 1 )
    {
        // no more kids, and we're still looking, so return -1
        //
        if( pKid == NULL )
        {
            return E_FAIL;
        }

        CComQIPtr< IAMTimelineNode, &IID_IAMTimelineNode > pKid2( pKid );

        // we addreffed it just above
        //
        pKid.Release( );

        // found it, return how many kids we looked at
        //
        if( pKid2 == (IAMTimelineNode*) this )
        {
            *pVal = counter;
            return NOERROR;
        }

        counter++;
        pKid2->XGetNextOfType( MajorTypeCombo, &pKid );
    }

    // never get here
}

//############################################################################
// 
//############################################################################

HRESULT CAMTimelineNode::XGetNextOfType( long MajorTypeCombo, IAMTimelineObj ** ppResult )
{
    // since we never use bumping of refcounts in here, don't use a CComPtr
    //
    IAMTimelineObj * pNext = m_pNext; // okay not CComPtr

    while( pNext )
    {
        TIMELINE_MAJOR_TYPE Type;
        pNext->GetTimelineType( &Type );
        
        // if the types match, this is the next we want
        //
        if( ( Type & MajorTypeCombo ) == Type )
        {
            *ppResult = pNext;
            (*ppResult)->AddRef( );
            return NOERROR;
        }

        IAMTimelineNode *pNextNext; // no CComPtr for perf.
        pNext->QueryInterface(IID_IAMTimelineNode, (void **)&pNextNext);
        pNextNext->XGetNextNoRef( &pNext );
        pNextNext->Release();
    }

    // didn't find any next of type!
    //
    DbgLog((LOG_TRACE, 2, TEXT("XGetNextOfType: Didn't find anything of type %ld" ), MajorTypeCombo ));
    *ppResult = NULL;
    return S_FALSE;
}

//############################################################################
// release all of our references and remove ourselves from the tree.
// DO NOT REMOVE KIDS
//############################################################################

HRESULT CAMTimelineNode::XRemoveOnlyMe( )
{
    CComQIPtr< IAMTimelineNode, &IID_IAMTimelineNode > pPrev( m_pPrev );
    CComQIPtr< IAMTimelineNode, &IID_IAMTimelineNode > pNext( m_pNext );
    CComQIPtr< IAMTimelineNode, &IID_IAMTimelineNode > pParent( m_pParent );

    // take care of who points to us as the parent

    // if we're the first kid, the parent needs
    // to point to someone else besides us.
    //
    if( !m_pPrev )
    {
        if( !m_pParent )
        {
            // no parent is okay, as long as you are the root comp
        }
        else
        {
            // parent' first kid is not us, that's for sure!
            //
            pParent->XResetFirstKid( m_pNext );
            m_pParent.Release();
        }
    }

    CComPtr< IAMTimelineObj > pPrevTemp( m_pPrev );

    // take care of who points to us as the prev
    //
    if( m_pPrev )
    {
        m_pPrev = NULL;

        pPrev->XSetNext( m_pNext );
    }

    // take care of who points to us as the next
    //
    if( pNext )
    {
        m_pNext = NULL;

        pNext->XSetPrev( pPrevTemp );
    }

    return NOERROR;
}

//############################################################################
// release all of our references and remove ourselves from the tree.
//############################################################################

HRESULT CAMTimelineNode::XRemove( )
{
    CComQIPtr< IAMTimelineNode, &IID_IAMTimelineNode > pPrev( m_pPrev );
    CComQIPtr< IAMTimelineNode, &IID_IAMTimelineNode > pNext( m_pNext );
    CComQIPtr< IAMTimelineNode, &IID_IAMTimelineNode > pParent( m_pParent );

    // take care of who points to us as the parent

    // if we're the first kid, the parent needs
    // to point to someone else besides us.
    //
    if( !m_pPrev )
    {
        if( !m_pParent )
        {
            // no parent is okay, as long as you are the root comp
        }
        else
        {
            // parent' first kid is not us, that's for sure!
            //
            pParent->XResetFirstKid( m_pNext );
            m_pParent.Release();
        }
    }

    CComPtr< IAMTimelineObj > pPrevTemp( m_pPrev );

    // take care of who points to us as the prev
    //
    if( m_pPrev )
    {
        m_pPrev = NULL;

        pPrev->XSetNext( m_pNext );
    }

    // take care of who points to us as the next
    //
    if( pNext )
    {
        m_pNext = NULL;

        pNext->XSetPrev( pPrevTemp );
    }

    // remove all of our kids
    //
    XClearAllKids( );

    // done removing kids, good.

    return NOERROR;
}

//############################################################################
// 
//############################################################################

void CAMTimelineNode::XAddKid
    ( IAMTimelineObj * pAddor )
{
    if( !m_pKid )
    {
        m_pKid = pAddor;
    }
    else
    {
        // find last kid
        //
        IAMTimelineObj * pLastKid = XGetLastKidNoRef( ); // okay not CComPtr

        CComQIPtr< IAMTimelineNode, &IID_IAMTimelineNode > pLastKid2( pLastKid );

        pLastKid2->XSetNext( pAddor );

        CComQIPtr< IAMTimelineNode, &IID_IAMTimelineNode > pAddor2( pAddor );

        pAddor2->XSetPrev( pLastKid );
    }

    CComQIPtr< IAMTimelineObj, &IID_IAMTimelineObj > pParent( (IAMTimelineNode*) this );
    CComQIPtr< IAMTimelineNode, &IID_IAMTimelineNode > pKid( pAddor );
    pKid->XSetParent( pParent );
}

//############################################################################
// 
//############################################################################

HRESULT CAMTimelineNode::XAddKidByPriority
    ( long MajorTypeCombo, IAMTimelineObj * pThingToInsert, long Which )
{
    // -1 means add last
    //
    if( Which == -1 )
    {
        XAddKid( pThingToInsert );
        return NOERROR;
    }

    CComPtr< IAMTimelineObj > pThingBeingAddedTo;
    XGetNthKidOfType( MajorTypeCombo, Which, &pThingBeingAddedTo );

    // we want to insert the new one just before the nth kid we just got.
    
    if( !pThingBeingAddedTo )
    {
        // we don't have the one we're looking fer, 
        // so just add it to the end of the list
        //
        XAddKid( pThingToInsert );
        return NOERROR;
    }

    // found who we want to insert in front of.
    //
    HRESULT hr = XInsertKidBeforeKid( pThingToInsert, pThingBeingAddedTo );
    return hr;
}

//############################################################################
// 
//############################################################################

HRESULT CAMTimelineNode::XInsertKidBeforeKid( IAMTimelineObj * pThingToInsert, IAMTimelineObj * pThingBeingAddedTo )
{
    // we can assume pThingToInsert is a kid of ours
    
    // if pThingBeingAddedTo is NULL, then add pThingToInsert at end of list
    //
    if( pThingBeingAddedTo == NULL )
    {
        XAddKid( pThingToInsert );
        return NOERROR;
    }

    // is pThingBeingAddedTo the very first kid?
    //
    if( pThingBeingAddedTo == m_pKid )
    {
        // yep, then insert pThingToInsert before that
        //
        CComPtr< IAMTimelineObj > pOldFirstKid = m_pKid;
        m_pKid = pThingToInsert;
        CComQIPtr< IAMTimelineNode, &IID_IAMTimelineNode > p( m_pKid );
        p->XSetNext( pOldFirstKid );
        p = pOldFirstKid;
        p->XSetPrev( m_pKid );
    }
    else
    {
        // nope, insert pThingToInsert before the kid
        //
        CComPtr< IAMTimelineObj > pPrev;
        CComQIPtr< IAMTimelineNode, &IID_IAMTimelineNode > p( pThingBeingAddedTo );
        // get the thing previous to the addor
        p->XGetPrev( &pPrev );
        p = pPrev;
        // by setting prev/next, this will temporarily drop the refcount on the old pThingBeingAddedTo,
        // so we need to addref/release around it
        pThingBeingAddedTo->AddRef( );
        p->XSetNext( pThingToInsert );
        p = pThingToInsert;
        p->XSetPrev( pPrev );
        p->XSetNext( pThingBeingAddedTo );
        p = pThingBeingAddedTo;
        p->XSetPrev( pThingToInsert );
        pThingBeingAddedTo->Release( );
    }

    CComQIPtr< IAMTimelineObj, &IID_IAMTimelineObj > pParent( (IUnknown*) this );
    CComQIPtr< IAMTimelineNode, &IID_IAMTimelineNode > pKid( pThingToInsert );
    pKid->XSetParent( pParent );

    return NOERROR;
}

//############################################################################
// 
//############################################################################

HRESULT CAMTimelineNode::XInsertKidAfterKid( IAMTimelineObj * pThingToInsert, IAMTimelineObj * pThingBeingAddedTo )
{
    // we can assume pThingToInsert is a kid of ours
    
    // if pThingBeingAddedTo is NULL, then add pThingToInsert at end of list
    //
    if( pThingBeingAddedTo == NULL )
    {
        XAddKid( pThingToInsert );
        return NOERROR;
    }

    CComPtr< IAMTimelineObj > pNext;
    CComQIPtr< IAMTimelineNode, &IID_IAMTimelineNode > p( pThingBeingAddedTo );
    // get the thing after the addor
    p->XGetNext( &pNext );
    if (pNext) 
    {
        p = pNext;
        p->XSetPrev( pThingToInsert );
    }
    p = pThingToInsert;
    p->XSetNext( pNext );
    p->XSetPrev( pThingBeingAddedTo );
    p = pThingBeingAddedTo;
    p->XSetNext( pThingToInsert );

    CComQIPtr< IAMTimelineObj, &IID_IAMTimelineObj > pParent( (IUnknown*) this );
    CComQIPtr< IAMTimelineNode, &IID_IAMTimelineNode > pKid( pThingToInsert );
    pKid->XSetParent( pParent );

    return NOERROR;
}

//############################################################################
// 
//############################################################################

IAMTimelineObj * CAMTimelineNode::XGetLastKidNoRef( )
{
    // no kids = no return
    //
    if( !m_pKid )
    {
        return NULL;
    }

    // since we never use bumping of refcounts in here, don't use a CComPtr
    //
    IAMTimelineObj * pKid = m_pKid; // okay not CComPtr

    while( 1 )
    {
        CComQIPtr< IAMTimelineNode, &IID_IAMTimelineNode > pKid2( pKid );
        IAMTimelineObj * pNext = NULL; // okay not CComPtr
        pKid2->XGetNextNoRef( &pNext );

        if( NULL == pNext )
        {
            return pKid;
        }

        pKid = pNext;
    }

    // never gets here.
}

//############################################################################
// 
//############################################################################

STDMETHODIMP CAMTimelineNode::XClearAllKids( )
{
    // remove all of our kids
    //
    CComPtr< IAMTimelineObj > pKid;

    while( 1 )
    {
        // kick out of while loop if we've removed all of the kids from the tree
        //
        if( !m_pKid )
        {
            break;
        }

        // reset pointer, because it may have changed below
        //
        pKid = m_pKid;

        {
            CComQIPtr< IAMTimelineNode, &IID_IAMTimelineNode > pNode( pKid );

            // remove kid from tree, this may change our kid pointer
            //
            pNode->XRemove( );
        }

        pKid = NULL;
    }

    return NOERROR;
}

//############################################################################
// 
//############################################################################

STDMETHODIMP CAMTimelineNode::XGetNextOfTypeNoRef( long MajorType, IAMTimelineObj ** ppResult )
{
    CheckPointer( ppResult, E_POINTER );

    HRESULT hr = XGetNextOfType( MajorType, ppResult );
    if( *ppResult )
    {
        (*ppResult)->Release( );
    }

    return hr;
}

//############################################################################
// 
//############################################################################

STDMETHODIMP CAMTimelineNode::XGetNextNoRef( IAMTimelineObj ** ppResult )
{
    CheckPointer( ppResult, E_POINTER );
    *ppResult = m_pNext; // since we are making an assignment, no addref
    return NOERROR;
}

//############################################################################
// 
//############################################################################

STDMETHODIMP CAMTimelineNode::XGetPrevNoRef( IAMTimelineObj ** ppResult )
{
    CheckPointer( ppResult, E_POINTER );
    *ppResult = m_pPrev;
    return NOERROR;
}

//############################################################################
// 
//############################################################################

STDMETHODIMP CAMTimelineNode::XResetFirstKid( IAMTimelineObj * pKid )
{
    m_pKid = pKid;
    return NOERROR;
}

//############################################################################
// 
//############################################################################

STDMETHODIMP CAMTimelineNode::XAddKidByTime( long MajorTypeCombo, IAMTimelineObj * pToAdd )
{
    HRESULT hr = 0;

    // no kids = no return
    //
    if( !m_pKid )
    {
        XAddKid( pToAdd );
        return NOERROR;
    }

    REFERENCE_TIME InStart = 0;
    REFERENCE_TIME InStop = 0;
    pToAdd->GetStartStop( &InStart, &InStop );

    // since we never use bumping of refcounts in here, don't use a CComPtr
    //
    IAMTimelineObj * pKid = m_pKid; // okay not CComPtr

    while( pKid )
    {
        // ask the kid if he's (he?) the right type
        //
        TIMELINE_MAJOR_TYPE Type;
        pKid->GetTimelineType( &Type );

        // only consider it if the types match
        //
        if( ( Type & MajorTypeCombo ) == Type )
        {
            // ask it for it's times
            //
            REFERENCE_TIME Start = 0;
            REFERENCE_TIME Stop = 0;
            pKid->GetStartStop( &Start, &Stop );

            if( InStop <= Start )
            {
                // found the one to insert into
                //
                hr = XInsertKidBeforeKid( pToAdd, pKid );
                return hr;
            }
        }

        // get the next one
        //
        CComQIPtr< IAMTimelineNode, &IID_IAMTimelineNode > pKid2( pKid );
        pKid2->XGetNextNoRef( &pKid );
    }

    // well, didn't find anything that matched, so add it at the end
    //
    XAddKid( pToAdd );

    return NOERROR;

}

STDMETHODIMP CAMTimelineNode::XGetPriorityOverTime( BOOL * pResult )
{
    CheckPointer( pResult, E_POINTER );
    *pResult = m_bPriorityOverTime;
    return NOERROR;
}

IAMTimelineObj * CAMTimelineNode::XGetFirstKidNoRef( )
{
    return m_pKid;
}
=== C:/Users/treeman/Desktop/windows nt source code\Source\Win2K3\NT\multimedia\dshow\filterus\dexter\tldb\tldbtnbl.cpp ===
//@@@@AUTOBLOCK+============================================================;
//
//  THIS CODE AND INFORMATION IS PROVIDED "AS IS" WITHOUT WARRANTY OF ANY
//  KIND, EITHER EXPRESSED OR IMPLIED, INCLUDING BUT NOT LIMITED TO THE
//  IMPLIED WARRANTIES OF MERCHANTABILITY AND/OR FITNESS FOR A PARTICULAR
//  PURPOSE.
//
//  File: tldbtnbl.cpp
//
//  Copyright (c) Microsoft Corporation.  All Rights Reserved.
//
//@@@@AUTOBLOCK-============================================================;

#include <streams.h>
#include "stdafx.h"
#include "tldb.h"

//############################################################################
// 
//############################################################################

CAMTimelineTransable::CAMTimelineTransable( )
{
}

//############################################################################
// 
//############################################################################

CAMTimelineTransable::~CAMTimelineTransable( )
{
}

//############################################################################
// 
//############################################################################

STDMETHODIMP CAMTimelineTransable::TransAdd
    (IAMTimelineObj * pTransObj)
{
    CComQIPtr< IAMTimelineTrans, &IID_IAMTimelineTrans > pTrans( pTransObj );
    if( !pTrans )
    {
        return E_NOINTERFACE;
    }

    CComQIPtr< IAMTimelineNode, &IID_IAMTimelineNode > pThis( (IUnknown*) this );
    REFERENCE_TIME Start = 0;
    REFERENCE_TIME Stop = 0;
    pTransObj->GetStartStop( &Start, &Stop );
    bool available = _IsSpaceAvailable( Start, Stop );
    if( !available )
    {
        return E_INVALIDARG;
    }
    return pThis->XAddKidByTime( TIMELINE_MAJOR_TYPE_TRANSITION, pTransObj );
}

//############################################################################
// 
//############################################################################

STDMETHODIMP CAMTimelineTransable::TransGetCount
    (long * pCount)
{
    CComQIPtr< IAMTimelineNode, &IID_IAMTimelineNode > pThis( (IUnknown*) this );

    CheckPointer( pCount, E_POINTER );

    return pThis->XKidsOfType( TIMELINE_MAJOR_TYPE_TRANSITION, pCount );
}

//############################################################################
// 
//############################################################################

STDMETHODIMP CAMTimelineTransable::GetNextTrans2
    (IAMTimelineObj ** ppTrans, REFTIME * pInOut)
{
    REFERENCE_TIME p1 = DoubleToRT( *pInOut );
    HRESULT hr = GetNextTrans( ppTrans, &p1 );
    *pInOut = RTtoDouble( p1 );
    return hr;
}

STDMETHODIMP CAMTimelineTransable::GetNextTrans
    (IAMTimelineObj ** ppTrans, REFERENCE_TIME * pInOut)
{
    CComQIPtr< IAMTimelineNode, &IID_IAMTimelineNode > pThis( (IUnknown*) this );

    // since we're enumerating stuff, the times we pass out will be aligned
    // to the output FPS.

    // search through our kids until we find something that's at or just 
    // before the given time.

    // get the pointer, and immediately release it. This is almost safe,
    // since we (almost) know the thing is going to stay in the timeline throughout
    // the duration of this call. This is not technically thread-safe
    //
    IAMTimelineObj * pChild = NULL; // okay not CComPtr
    pThis->XGetNthKidOfType( TIMELINE_MAJOR_TYPE_TRANSITION, 0, &pChild );
    if( pChild )
    {
        pChild->Release( );
    }

    while( pChild )
    {
        // get the source times
        //
        REFERENCE_TIME Start, Stop;
        pChild->GetStartStop( &Start, &Stop ); // assume no error

        if( Stop > * pInOut ) // careful of off-by-one!
        {
            // found it!
            //
            *ppTrans = pChild;
            (*ppTrans)->AddRef( );
            *pInOut = Stop;

            return NOERROR;
        }

        CComQIPtr< IAMTimelineNode, &IID_IAMTimelineNode > pChild2( pChild );
        pChild = NULL;
        pChild2->XGetNextOfTypeNoRef( TIMELINE_MAJOR_TYPE_TRANSITION, &pChild );
    }

    *ppTrans = NULL;
    *pInOut = 0;
    return S_FALSE;
}

//############################################################################
// 
//############################################################################

bool CAMTimelineTransable::_IsSpaceAvailable
    ( REFERENCE_TIME SearchStart, REFERENCE_TIME SearchStop )
{
    CComQIPtr< IAMTimelineNode, &IID_IAMTimelineNode > pThis( (IUnknown*) this );

    // get the pointer, and immediately release it. This is almost safe,
    // since we (almost) know the thing is going to stay in the timeline throughout
    // the duration of this call. !!! This is not technically thread-safe
    //
    IAMTimelineObj * pChild = NULL; // okay not CComPtr
    pThis->XGetNthKidOfType( TIMELINE_MAJOR_TYPE_TRANSITION, 0, &pChild );
    if( pChild )
    {
        pChild->Release( );
    }

    while( pChild )
    {
        // get the source times
        //
        REFERENCE_TIME Start, Stop;
        pChild->GetStartStop( &Start, &Stop ); // assume no error

        // if we haven't found a stop time greater than our search start,
        // we can ignore it
        //
        if( Stop > SearchStart )
        {
            // if the start time is greater, then our search stop, then
            // everything's fine
            //
            if( Start >= SearchStop )
            {
                return true;
            }

            // or, it must fall in our range and we cannot return
            // true
            //
            return false;
        }

        // well, keep looking then

        CComQIPtr< IAMTimelineNode, &IID_IAMTimelineNode > pChild2( pChild );
        pChild = NULL;
        pChild2->XGetNextOfTypeNoRef( TIMELINE_MAJOR_TYPE_TRANSITION, &pChild );
    }

    // huh, we must not have found anything
    //
    return true;
}

//############################################################################
// 
//############################################################################

STDMETHODIMP CAMTimelineTransable::GetTransAtTime2
    (IAMTimelineObj ** ppObj, REFTIME Time, long SearchDirection )
{
    REFERENCE_TIME p1 = DoubleToRT( Time );
    HRESULT hr = GetTransAtTime( ppObj, p1, SearchDirection );
    return hr;
}

//############################################################################
// 
//############################################################################

STDMETHODIMP CAMTimelineTransable::GetTransAtTime
    (IAMTimelineObj ** ppObj, REFERENCE_TIME Time, long SearchDirection )
{
    CheckPointer( ppObj, E_POINTER );

    switch( SearchDirection )
    {
    case DEXTERF_EXACTLY_AT:
    case DEXTERF_BOUNDING:
    case DEXTERF_FORWARDS:
        break;
    default:
        return E_INVALIDARG;
    }

    // make the result invalid first
    //
    *ppObj = NULL;

    // if we don't have any sources, then nothing
    //
    CComPtr< IAMTimelineObj > pObj;
    CComQIPtr< IAMTimelineNode, &IID_IAMTimelineNode > pNode( this );
    pNode->XGetNthKidOfType( TIMELINE_MAJOR_TYPE_TRANSITION, 0, &pObj );
    if( !pObj )
    {
        return S_FALSE;
    }

    while( pObj )
    {
        REFERENCE_TIME Start = 0;
        REFERENCE_TIME Stop = 0;
        pObj->GetStartStop( &Start, &Stop );

        if( SearchDirection == DEXTERF_EXACTLY_AT )
        {
            if( Start == Time )
            {
                *ppObj = pObj;
                (*ppObj)->AddRef( );
                return NOERROR;
            }
        }
        if( SearchDirection == DEXTERF_FORWARDS )
        {
            if( Start >= Time )
            {
                *ppObj = pObj;
                (*ppObj)->AddRef( );
                return NOERROR;
            }
        }
        if( SearchDirection == DEXTERF_BOUNDING )
        {
            if( Start <= Time && Stop > Time )
            {
                *ppObj = pObj;
                (*ppObj)->AddRef( );
                return NOERROR;
            }
        }

        // get the next source
        //
        CComQIPtr< IAMTimelineNode, &IID_IAMTimelineNode > pNode( pObj );
        pObj.Release( );
        pNode->XGetNextOfType( TIMELINE_MAJOR_TYPE_TRANSITION, &pObj );
    }

    return S_FALSE;
}
=== C:/Users/treeman/Desktop/windows nt source code\Source\Win2K3\NT\multimedia\dshow\filterus\dexter\tldb\tldbtran.cpp ===
//@@@@AUTOBLOCK+============================================================;
//
//  THIS CODE AND INFORMATION IS PROVIDED "AS IS" WITHOUT WARRANTY OF ANY
//  KIND, EITHER EXPRESSED OR IMPLIED, INCLUDING BUT NOT LIMITED TO THE
//  IMPLIED WARRANTIES OF MERCHANTABILITY AND/OR FITNESS FOR A PARTICULAR
//  PURPOSE.
//
//  File: tldbtran.cpp
//
//  Copyright (c) Microsoft Corporation.  All Rights Reserved.
//
//@@@@AUTOBLOCK-============================================================;

#include <streams.h>
#include "stdafx.h"
#include "tldb.h"

#define CUT_NOT_SET_TIME -1

#pragma warning( disable : 4800 )  // Disable warning messages

//############################################################################
// 
//############################################################################

CAMTimelineTrans::CAMTimelineTrans( TCHAR *pName, LPUNKNOWN pUnk, HRESULT * phr )
    : CAMTimelineObj( pName, pUnk, phr )
    , m_rtCut( CUT_NOT_SET_TIME )
    , m_fSwapInputs( FALSE )
    , m_bCutsOnly( FALSE )
{
    m_ClassID = CLSID_AMTimelineTrans;
    m_TimelineType = TIMELINE_MAJOR_TYPE_TRANSITION;
}

//############################################################################
// 
//############################################################################

CAMTimelineTrans::~CAMTimelineTrans( )
{
}

//############################################################################
// 
//############################################################################

STDMETHODIMP CAMTimelineTrans::NonDelegatingQueryInterface(REFIID riid, void **ppv)
{
    if( riid == IID_IAMTimelineTrans )
    {
        return GetInterface( (IAMTimelineTrans*) this, ppv );
    }
    if( riid == IID_IAMTimelineSplittable )
    {
        return GetInterface( (IAMTimelineSplittable*) this, ppv );
    }
    return CAMTimelineObj::NonDelegatingQueryInterface( riid, ppv );
}

//############################################################################
// 
//############################################################################

HRESULT CAMTimelineTrans::GetCutPoint2( REFTIME * pTLTime )
{
    REFERENCE_TIME p1 = DoubleToRT( *pTLTime );
    HRESULT hr = GetCutPoint( &p1 );
    *pTLTime = RTtoDouble( p1 );
    return hr;
}

HRESULT CAMTimelineTrans::GetCutPoint( REFERENCE_TIME * pTLTime )
{
    CheckPointer( pTLTime, E_POINTER );

    // if we haven't set a cut point, then cut point is midway and we return S_FALSE
    //
    if( CUT_NOT_SET_TIME == m_rtCut )
    {
        *pTLTime = ( m_rtStop - m_rtStart ) / 2;
        return S_FALSE;
    }

    *pTLTime = m_rtCut;

    return NOERROR;
}

//############################################################################
// 
//############################################################################

HRESULT CAMTimelineTrans::SetCutPoint2( REFTIME TLTime )
{
    REFERENCE_TIME p1 = DoubleToRT( TLTime );
    HRESULT hr = SetCutPoint( p1 );
    return hr;
}

HRESULT CAMTimelineTrans::SetCutPoint( REFERENCE_TIME TLTime )
{
    // validate ranges
    //
    if( TLTime < 0 )
    {
        TLTime = 0;
    }
    if( TLTime > m_rtStop - m_rtStart )
    {
        TLTime = m_rtStop - m_rtStart;
    }

    m_rtCut = TLTime;

    return NOERROR;
}


//############################################################################
// 
//############################################################################

STDMETHODIMP CAMTimelineTrans::GetSwapInputs( BOOL * pVal )
{
    CheckPointer( pVal, E_POINTER );

    *pVal = (BOOL) m_fSwapInputs;
    return NOERROR;
}

//############################################################################
// 
//############################################################################

STDMETHODIMP CAMTimelineTrans::SetSwapInputs( BOOL pVal )
{
    m_fSwapInputs = pVal;
    return NOERROR;
}


//############################################################################
// 
//############################################################################

STDMETHODIMP CAMTimelineTrans::SplitAt2( REFTIME t )
{
    REFERENCE_TIME t1 = DoubleToRT( t );
    return SplitAt( t1 );
}

STDMETHODIMP CAMTimelineTrans::SplitAt( REFERENCE_TIME SplitTime )
{
    DbgLog((LOG_TRACE,2,TEXT("Trans::Split")));

    // is our split time withIN our time?
    //
    if( SplitTime <= m_rtStart || SplitTime >= m_rtStop )
    {
        return E_INVALIDARG;
    }

    // we need to be attached to something.
    //
    IAMTimelineObj * pParent;
    XGetParentNoRef( &pParent );
    if( !pParent )
    {
        return E_INVALIDARG;
    }

    HRESULT hr = 0;
    CAMTimelineTrans * pNew = new CAMTimelineTrans( NAME("Timeline Transition"), NULL, &hr );
    if( FAILED( hr ) )
    {
        return E_OUTOFMEMORY;
    }

    // we have created an object that has NO references on it. If we call ANYTHING that
    // addreffs and releases the pNewSrc, it will be deleted. So addref it NOW.

    pNew->AddRef( );

    hr = CopyDataTo( pNew, SplitTime );
    if( FAILED( hr ) )
    {
        delete pNew;
        return hr;
    }

    pNew->m_rtStart = SplitTime;
    pNew->m_rtStop = m_rtStop;
    m_rtStop = SplitTime;

    // need to add the new transition to the tree
    // !!! Will priority be right?
    //
    CComQIPtr< IAMTimelineTransable, &IID_IAMTimelineTransable > pTransable( pParent );
    hr = pTransable->TransAdd( pNew );

    if( !FAILED( hr ) )
    {
        pNew->Release( );
    }

    return hr;
}

//############################################################################
// 
//############################################################################

STDMETHODIMP CAMTimelineTrans::SetCutsOnly( BOOL Val )
{
    m_bCutsOnly = Val;
    return NOERROR;
}

//############################################################################
// 
//############################################################################

STDMETHODIMP CAMTimelineTrans::GetCutsOnly( BOOL * pVal )
{
    CheckPointer( pVal, E_POINTER );
    *pVal = m_bCutsOnly;
    return NOERROR;
}
=== C:/Users/treeman/Desktop/windows nt source code\Source\Win2K3\NT\multimedia\dshow\filterus\dexter\util\conv.cxx ===
LONGLONG inline Time2Frame( REFERENCE_TIME rt, double FPS )
{
    ASSERT( FPS );
    if (rt >= 0) {
        return LONGLONG( double( rt + 1 ) * FPS / double( UNITS ) );
    } else {
        return LONGLONG( double( rt - 1 ) * FPS / double( UNITS ) );
    }
}

REFERENCE_TIME inline Frame2Time( LONGLONG Frame, double FPS )
{
    ASSERT( FPS );
    
    double dt = (Frame * UNITS / FPS );

    // ftol rounds towards 0, and we want to round to nearest.
    if(Frame >= 0) {
        dt += 0.5;
    } else {
        dt -= 0.5;              // we do see -ve numbers for some reason
    }

    return (REFERENCE_TIME)dt;
}

LONGLONG inline RoundTime2Frame( REFERENCE_TIME rt, double FPS )
{
    ASSERT( FPS );
    double d = double( rt ) * FPS / double( UNITS ) + 0.5;
    LONGLONG l = (LONGLONG)d;
    return l;
}

LONGLONG inline RoundUpTime2Frame( REFERENCE_TIME rt, double FPS )
{
    ASSERT( FPS );
    double d;
    // rt might be rounded too high, since we're rounding up, subtract 1
    d = double(rt  - 1) * FPS / double( UNITS );
    long l = long( d );
    if( double( l ) < d )
    {
        l++;
    }
    return l;
}

REFERENCE_TIME inline DoubleToRT( double d )
{
    REFERENCE_TIME rt = REFERENCE_TIME( d * double( UNITS ) + 0.5 );
    return rt;
}

double inline RTtoDouble( REFERENCE_TIME rt )
{
    double d = double( rt ) / double( UNITS );
    return d;
}

inline REFERENCE_TIME SkewTimelineStart( STARTSTOPSKEW * pSkew )
{
    return pSkew->rtStart + pSkew->rtSkew;
}

inline REFERENCE_TIME SkewTimelineStop( STARTSTOPSKEW * pSkew )
{
    return pSkew->rtStart + pSkew->rtSkew + 
        REFERENCE_TIME( ( pSkew->rtStop - pSkew->rtStart ) / pSkew->dRate );
}

inline bool AreTimesAndRateReallyClose( 
                         REFERENCE_TIME TLStopLast,
                         REFERENCE_TIME TLStartNext,
                         REFERENCE_TIME MediaStopLast,
                         REFERENCE_TIME MediaStartNext,
                         double Rate1,
                         double Rate2,
                         double TimelineFPS )
{
    // must be REALLY close!
    //
    if( ( TLStartNext - TLStopLast > 10 ) || ( TLStopLast - TLStartNext > 10 ) )
    {
        return false;
    }

    // the media times can be off by a frame's worth, or we don't combine
    //
    ASSERT( TimelineFPS != 0.0 );
    if( TimelineFPS == 0.0 ) TimelineFPS = 15.0; // don't allow a 0, if it occurs
    REFERENCE_TIME FudgeFactor = REFERENCE_TIME( UNITS / TimelineFPS );
    if( ( MediaStartNext - MediaStopLast >= FudgeFactor ) || ( MediaStopLast - MediaStartNext >= FudgeFactor ) )
    {
        return false;
    }

    if( Rate1 == 0.0 || Rate2 == 0.0 )
    {
        return true;
    }

    // rates must match to 1/10th of a percent
    long p = abs( long( ( Rate2 - Rate1 ) * 1000 / Rate2 ) );
    if( p > 1 )
    {
        return false;
    }

    return true;
}
=== C:/Users/treeman/Desktop/windows nt source code\Source\Win2K3\NT\multimedia\dshow\filterus\dexter\tldb\tldbtrck.cpp ===
//@@@@AUTOBLOCK+============================================================;
//
//  THIS CODE AND INFORMATION IS PROVIDED "AS IS" WITHOUT WARRANTY OF ANY
//  KIND, EITHER EXPRESSED OR IMPLIED, INCLUDING BUT NOT LIMITED TO THE
//  IMPLIED WARRANTIES OF MERCHANTABILITY AND/OR FITNESS FOR A PARTICULAR
//  PURPOSE.
//
//  File: tldbtrck.cpp
//
//  Copyright (c) Microsoft Corporation.  All Rights Reserved.
//
//@@@@AUTOBLOCK-============================================================;

#include <streams.h>
#include "stdafx.h"
#include "tldb.h"

//############################################################################
// 
//############################################################################

CAMTimelineTrack::CAMTimelineTrack( TCHAR *pName, LPUNKNOWN pUnk, HRESULT * phr )
    : CAMTimelineObj( pName, pUnk, phr )
{
    m_TimelineType = TIMELINE_MAJOR_TYPE_TRACK;
}

//############################################################################
// 
//############################################################################

CAMTimelineTrack::~CAMTimelineTrack( )
{
}

//############################################################################
// 
//############################################################################

STDMETHODIMP CAMTimelineTrack::NonDelegatingQueryInterface(REFIID riid, void **ppv)
{
    if( riid == IID_IAMTimelineTrack )
    {
        return GetInterface( (IAMTimelineTrack*) this, ppv );
    }
    if( riid == IID_IAMTimelineSplittable )
    {
        return GetInterface( (IAMTimelineSplittable*) this, ppv );
    }
    if( riid == IID_IAMTimelineVirtualTrack )
    {
        return GetInterface( (IAMTimelineVirtualTrack*) this, ppv );
    }
    if( riid == IID_IAMTimelineEffectable )
    {
        return GetInterface( (IAMTimelineEffectable*) this, ppv );
    }
    if( riid == IID_IAMTimelineTransable )
    {
        return GetInterface( (IAMTimelineTransable*) this, ppv );
    }
    return CAMTimelineObj::NonDelegatingQueryInterface( riid, ppv );
}

//############################################################################
// we are always in overwrite mode. If application wants to do insert mode,
// it must put the space there manually.
//############################################################################

STDMETHODIMP CAMTimelineTrack::SrcAdd
    (IAMTimelineObj * pSource)
{
    HRESULT hr = 0;

    CComQIPtr< IAMTimelineSrc, &IID_IAMTimelineSrc > pSrc( pSource );
    if( !pSrc )
    {
        return E_NOINTERFACE;
    }

    REFERENCE_TIME AddedStart, AddedStop;
    pSource->GetStartStop( &AddedStart, &AddedStop ); // assume this works

    hr = ZeroBetween( AddedStart, AddedStop );
    if( FAILED( hr ) )
    {
        return hr;
    }    
    // find who we're supposed to be in front of
    //
    CComPtr<IAMTimelineObj> pNextSrc;

    // S_FALSE means we're sure this source goes at the end
    if (hr != S_FALSE)
    {
        hr = GetSrcAtTime( &pNextSrc, AddedStart, 1 );
    }
    
    // if we found something, insert it before that source
    //
    if( pNextSrc )
    {
        hr = XInsertKidBeforeKid( pSource, pNextSrc ); // assume works
    }
    else
    {
        // didn't find somebody to put it in front of, so just add it to the end
        //
        hr = XAddKidByPriority( TIMELINE_MAJOR_TYPE_SOURCE, pSource, -1 ); // assume works
    }

    return hr;
}

//############################################################################
// 
//############################################################################

STDMETHODIMP CAMTimelineTrack::GetNextSrc2
    (IAMTimelineObj ** ppSrc, REFTIME * pInOut)
{
    REFERENCE_TIME p1 = DoubleToRT( *pInOut );
    HRESULT hr = GetNextSrc( ppSrc, &p1 );
    *pInOut = RTtoDouble( p1 );
    return hr;
}

STDMETHODIMP CAMTimelineTrack::GetNextSrc
    (IAMTimelineObj ** ppSrc, REFERENCE_TIME * pInOut)
{
    // since we're enumerating stuff, the times we pass out will be aligned
    // to the output FPS.

    // search through our kids until we find something that's at or just 
    // before the given time.

    CComPtr< IAMTimelineObj > pChild;
    XGetNthKidOfType( TIMELINE_MAJOR_TYPE_SOURCE, 0, &pChild );

    while( pChild )
    {
        // get the source times
        //
        REFERENCE_TIME Start, Stop;
        pChild->GetStartStop( &Start, &Stop ); // assume no error

        if( Stop > *pInOut ) // careful of off-by-one!
        {
            // found it!
            //
            *ppSrc = pChild;
            (*ppSrc)->AddRef( );
            *pInOut = Stop;

            return NOERROR;
        }

        // get the next one
        //
        CComQIPtr< IAMTimelineNode, &IID_IAMTimelineNode > pChild2( pChild );
        pChild.Release( );
        pChild2->XGetNextOfType( TIMELINE_MAJOR_TYPE_SOURCE, &pChild );
    }

    *ppSrc = NULL;
    *pInOut = 0;
    return S_FALSE;
}

//############################################################################
// 
//############################################################################

STDMETHODIMP CAMTimelineTrack::GetNextSrcEx
    (IAMTimelineObj *pSrcLast, IAMTimelineObj ** ppSrcNext)
{
    if (!pSrcLast)
        return XGetNthKidOfType( TIMELINE_MAJOR_TYPE_SOURCE, 0, ppSrcNext );

    // otherwise get the next one
    //
    CComQIPtr< IAMTimelineNode, &IID_IAMTimelineNode > pSrcLastNode( pSrcLast );

    return pSrcLastNode->XGetNextOfType( TIMELINE_MAJOR_TYPE_SOURCE, ppSrcNext );
}

//############################################################################
// 
//############################################################################

STDMETHODIMP CAMTimelineTrack::TrackGetPriority
    (long * pPriority)
{
    CheckPointer( pPriority, E_POINTER );

    return XWhatPriorityAmI( TIMELINE_MAJOR_TYPE_TRACK | TIMELINE_MAJOR_TYPE_COMPOSITE, pPriority );
}

//############################################################################
//
//############################################################################

HRESULT CAMTimelineTrack::GetSourcesCount
    ( long * pVal )
{
    CheckPointer( pVal, E_POINTER );

    return XKidsOfType( TIMELINE_MAJOR_TYPE_SOURCE, pVal );
}

//############################################################################
//
//############################################################################

HRESULT CAMTimelineTrack::SetTrackDirty
    ( )
{
    // ASSERT( function_not_done );
    return E_NOTIMPL; // settrackdirty
}

//############################################################################
// A track's start/stop is the min/max of anything it contains
//
//############################################################################

STDMETHODIMP CAMTimelineTrack::GetStartStop2
    (REFTIME * pStart, REFTIME * pStop)
{
    REFERENCE_TIME p1 = DoubleToRT( *pStart );
    REFERENCE_TIME p2 = DoubleToRT( *pStop );
    HRESULT hr = GetStartStop( &p1, &p2 );
    *pStart = RTtoDouble( p1 );
    *pStop = RTtoDouble( p2 );
    return hr;
}

STDMETHODIMP CAMTimelineTrack::GetStartStop
    (REFERENCE_TIME * pStart, REFERENCE_TIME * pStop)
{
    CheckPointer( pStart, E_POINTER );
    CheckPointer( pStop, E_POINTER );

    REFERENCE_TIME Min = 0;
    REFERENCE_TIME Max = 0;

    // ask each of the kids for the amount of whatever it is we're looking for
    //
    IAMTimelineObj * pTrack = NULL;
    XGetNthKidOfType( TIMELINE_MAJOR_TYPE_SOURCE, 0, &pTrack );
    if( pTrack )
    {
        pTrack->Release( ); // don't keep a ref count on it
    }
    while( pTrack )
    {
        // ask it for it's times
        //
        REFERENCE_TIME Start = 0;
        REFERENCE_TIME Stop = 0;
        pTrack->GetStartStop( &Start, &Stop );
        if( Max == 0 )
        {
            Min = Start;
            Max = Stop;
        }
        // if( Start < Min ) Min = Start;
        if( Stop > Max ) Max = Stop;

        CComQIPtr< IAMTimelineNode, &IID_IAMTimelineNode > pNode = pTrack;
        pTrack = NULL;
        pNode->XGetNextOfTypeNoRef( TIMELINE_MAJOR_TYPE_SOURCE, &pTrack );
    }

    *pStart = 0; // track times always start at 0
    *pStop = Max;

    return NOERROR;
}

//############################################################################
// ask if there are any sources on this track
//############################################################################

STDMETHODIMP CAMTimelineTrack::AreYouBlank
    (long * pVal)
{
    CheckPointer( pVal, E_POINTER );
    *pVal = 1;

    HRESULT hr = 0;
    CComQIPtr< IAMTimelineObj, &IID_IAMTimelineObj > pSource;
    hr = XGetNthKidOfType( TIMELINE_MAJOR_TYPE_SOURCE, 0, &pSource );

    if( pSource )
    {
        *pVal = 0;
    }

    // !!! what about fx and transitions?

    return hr;
}

//############################################################################
//
//############################################################################

HRESULT CAMTimelineTrack::GetSrcAtTime2
    ( IAMTimelineObj ** ppSrc, REFTIME Time, long SearchDirection )
{
    REFERENCE_TIME p1 = DoubleToRT( Time );
    HRESULT hr = GetSrcAtTime( ppSrc, p1, SearchDirection );
    return hr;
}

HRESULT CAMTimelineTrack::GetSrcAtTime
    ( IAMTimelineObj ** ppSrc, REFERENCE_TIME Time, long SearchDirection )
{
    CheckPointer( ppSrc, E_POINTER );

    switch( SearchDirection )
    {
    case DEXTERF_EXACTLY_AT:
    case DEXTERF_BOUNDING:
    case DEXTERF_FORWARDS:
        break;
    default:
        return E_INVALIDARG;
    }

    // make the result invalid first
    //
    *ppSrc = NULL;

    // if we don't have any sources, then nothing
    //
    CComPtr< IAMTimelineObj > pSource;
    XGetNthKidOfType( TIMELINE_MAJOR_TYPE_SOURCE, 0, &pSource );
    if( !pSource )
    {
        return S_FALSE;
    }

    while( pSource )
    {
        REFERENCE_TIME Start = 0;
        REFERENCE_TIME Stop = 0;
        pSource->GetStartStop( &Start, &Stop );

        if( SearchDirection == DEXTERF_EXACTLY_AT )
        {
            if( Start == Time )
            {
                *ppSrc = pSource;
                (*ppSrc)->AddRef( );
                return NOERROR;
            }
        }
        if( SearchDirection == DEXTERF_FORWARDS )
        {
            if( Start >= Time )
            {
                *ppSrc = pSource;
                (*ppSrc)->AddRef( );
                return NOERROR;
            }
        }
        if( SearchDirection == DEXTERF_BOUNDING )
        {
            if( Start <= Time && Stop > Time )
            {
                *ppSrc = pSource;
                (*ppSrc)->AddRef( );
                return NOERROR;
            }
        }

        // get the next source
        //
        CComQIPtr< IAMTimelineNode, &IID_IAMTimelineNode > pNode( pSource );
        pSource.Release( );
        pNode->XGetNextOfType( TIMELINE_MAJOR_TYPE_SOURCE, &pSource );
    }

    return S_FALSE;
}

//############################################################################
//
//############################################################################

STDMETHODIMP CAMTimelineTrack::InsertSpace2
    ( REFTIME rtStart, REFTIME rtEnd )
{
    REFERENCE_TIME p1 = DoubleToRT( rtStart );
    REFERENCE_TIME p2 = DoubleToRT( rtEnd );
    HRESULT hr = InsertSpace( p1, p2 );
    return hr;
}

STDMETHODIMP CAMTimelineTrack::InsertSpace( REFERENCE_TIME rtStart, REFERENCE_TIME rtEnd )
{
    HRESULT hr = 0;

    // check for errors, ding-dong!
    //
    if( ( rtStart < 0 ) || ( rtEnd < 0 ) || ( rtEnd <= rtStart ) )
    {
        return E_INVALIDARG;
    }

    // first, chop anything on this track that crosses rtStart into two sections,
    // this will make it much easier to move
    //
    hr = SplitAt( rtStart );
    if( FAILED( hr ) )
    {
        return hr;
    }

    // now, move everything
    //
    hr = MoveEverythingBy( rtStart, rtEnd - rtStart );

    return hr;
}

//############################################################################
//
//############################################################################

STDMETHODIMP CAMTimelineTrack::ZeroBetween2( REFTIME rtStart, REFTIME rtEnd )
{
    REFERENCE_TIME p1 = DoubleToRT( rtStart );
    REFERENCE_TIME p2 = DoubleToRT( rtEnd );
    HRESULT hr = ZeroBetween( p1, p2 );
    return hr;
}

// !!! if we whack the start of a source, we should whack the whole thing?

HRESULT CAMTimelineTrack::ZeroBetween
    ( REFERENCE_TIME Start, REFERENCE_TIME Stop )
{
    HRESULT hr = 0;

    // first make sure we can zero out stuff by slicing at the
    // beginning AND at the end! This will of course take longer than
    // simply adjusting the start and stop points of things that
    // cross the split boundaries, but this is simpler.
    //
    hr = SplitAt( Start );

    // S_FALSE means we can exit early, since there were no clips,
    // effects, or transitions past time = Start
    if( hr == S_FALSE )
    {
        return hr;
    }
    
    if( FAILED( hr ) )
    {
        return hr;
    }
    hr = SplitAt( Stop );
    if( FAILED( hr ) )
    {
        return hr;
    }

    // !!! horrible way to enumerate sources! Fix this!
    
    // whack all sources between the times
    //
    REFERENCE_TIME t = 0;
    while( 1 )
    {
        REFERENCE_TIME oldt = t;
        CComPtr< IAMTimelineObj > p;
        HRESULT hr = GetNextSrc( &p, &t );
        if( ( hr != S_OK ) || ( oldt == t ) )
        {
            // no more sources, exit
            //
            break;
        }
        
        CComQIPtr< IAMTimelineSrc, &IID_IAMTimelineSrc > pSource( p );

        REFERENCE_TIME s,e;
        p->GetStartStop( &s, &e );

        // if lesser than our bounds, continue
        //
        if( e <= Start )
        {
            p.Release( );
            continue;
        }

        // if greater than our bounds, exit
        //
        if( s >= Stop )
        {
            p.Release( );
            break;
        }

        // it's GOT to be completely within bounds. Whack it.
        //
        IAMTimeline * pRoot = NULL; // okay not CComPtr
        GetTimelineNoRef( &pRoot );
        p->RemoveAll( ); // removing this effect will change priorities of everything.
        p.Release( );

    } // all sources

    // since this track starts at time 0, we don't need to mess with
    // the start/stop times when looking for effect start/stop times

    // remove all the effects. Since we split the track above, all the effects
    // will either be completely outside of or inside of the times we're looking
    // between. This makes things simpler
    //
    CComPtr< IAMTimelineObj > pEffect;
    long EffectCount;

loopeffects:

    EffectCount = 0;
    hr = EffectGetCount( &EffectCount );
    for( int i = 0 ; i < EffectCount ; i++ )
    {
        CComPtr< IAMTimelineObj > p;
        GetEffect( &p, i );
        
        REFERENCE_TIME s,e;
        p->GetStartStop( &s, &e );

        // if lesser than our bounds, continue
        //
        if( e <= Start )
        {
            p.Release( );
            continue;
        }

        // if greater than our bounds, exit
        //
        if( s >= Stop )
        {
            p.Release( );
            break;
        }

        p->RemoveAll( ); // removing this effect will change priorities of everything.
        p.Release( );

        goto loopeffects;
    }

    // remove all the effects. Since we split the track above, all the effects
    // will either be completely outside of or inside of the times we're looking
    // between. This makes things simpler
    //
    CComPtr< IAMTimelineObj > pTransition;
    REFERENCE_TIME TransTime = 0;

looptrans:

    while( 1 )
    {
        CComPtr< IAMTimelineObj > p;
        REFERENCE_TIME t = TransTime;
        HRESULT hr = GetNextTrans( &p, &TransTime );
        if( ( hr != NOERROR ) || ( t == TransTime ) )
        {
            break;
        }
        
        REFERENCE_TIME s,e;
        p->GetStartStop( &s, &e );

        // if lesser than our bounds, continue
        //
        if( e <= Start )
        {
            p.Release( );
            continue;
        }

        // if greater than our bounds, exit
        //
        if( s >= Stop )
        {
            p.Release( );
            break;
        }

        p->RemoveAll( ); // removing this effect will change priorities of everything.
        p.Release( );

        goto looptrans;
    }

    return NOERROR;
}

//############################################################################
// called externally, and from InsertSpace
//############################################################################

HRESULT CAMTimelineTrack::MoveEverythingBy2
    ( REFTIME StartTime, REFTIME Delta )
{
    REFERENCE_TIME p1 = DoubleToRT( StartTime );
    REFERENCE_TIME p2 = DoubleToRT( Delta );
    HRESULT hr = MoveEverythingBy( p1, p2 );
    return hr;
}

HRESULT CAMTimelineTrack::MoveEverythingBy
    ( REFERENCE_TIME StartTime, REFERENCE_TIME Delta )
{
    // if we don't have any kids, then nothin to do.
    //
    if( !XGetFirstKidNoRef( ) )
    {
        return NOERROR;
    }

    // what all can a track contain? Sources, FX, and Transitions, right?
    // move EVERYTHING after a given time. 

    CComPtr< IAMTimelineObj > pFirstObj = XGetFirstKidNoRef( );

    bool MovedSomething = false;

    // go look for the first object at our time
    //
    while( pFirstObj )
    {
        // ask for the time
        //
        REFERENCE_TIME nStart, nStop;
        pFirstObj->GetStartStop( &nStart, &nStop );

        // if the time is over, then move it.
        //
        if( nStart >= StartTime )
        {
            nStart += Delta;
            nStop += Delta;
		// !!! see comment below
		// this will not work for people who create their OWN IAMTimelineObj,
		// but hypothetically, they can NEVER do this because the only way for them
		// to create one is by asking the timeline to CreateEmptyNode. So we 
		// shouldn't have to worry but sometimes people get a bit too clever for
		// their britches.
            CAMTimelineObj * pObj = static_cast< CAMTimelineObj * > ( (IAMTimelineObj*) pFirstObj );
            pObj->m_rtStart = nStart;
            pObj->m_rtStop = nStop;
            // do not call this, it will fault out.
//            pFirstObj->SetStartStop( nStart, nStop );
            MovedSomething = true;
        }

        // get the next thing
        //
        CComQIPtr< IAMTimelineNode, &IID_IAMTimelineNode > pFirstNode( pFirstObj );
        pFirstObj.Release( );
        pFirstNode->XGetNext( &pFirstObj );
    }

    if( !MovedSomething )
    {
        return S_FALSE;
    }

    return NOERROR;
}

//############################################################################
// 
//############################################################################

STDMETHODIMP CAMTimelineTrack::SplitAt2( double dSplitTime )
{
    REFERENCE_TIME p1 = DoubleToRT( dSplitTime );
    HRESULT hr = SplitAt( p1 );
    return hr;
}

// new version: faster, also returns S_FALSE if SplitTime is past everything on the track
STDMETHODIMP CAMTimelineTrack::SplitAt( REFERENCE_TIME SplitTime )
{
    HRESULT hr = S_FALSE;

    const long SPLITAT_TYPE = TIMELINE_MAJOR_TYPE_TRANSITION |
                              TIMELINE_MAJOR_TYPE_EFFECT |
                              TIMELINE_MAJOR_TYPE_SOURCE;
                              
    CComPtr< IAMTimelineObj > pChild;
    XGetNthKidOfType( SPLITAT_TYPE, 0, &pChild );

    while( pChild )
    {
        // get the source times
        //
        REFERENCE_TIME s,e;
        pChild->GetStartStop( &s, &e );

        // if the end time is less than our split time, it's completely
        // out of bounds, ignore it
        //
        if( e > SplitTime && s < SplitTime )
        {
            CComQIPtr< IAMTimelineSplittable, &IID_IAMTimelineSplittable > pSplittable( pChild );
            hr = pSplittable->SplitAt( SplitTime );

            if (FAILED(hr))
                break;
        }

        if( e > SplitTime )
            hr = S_OK; // S_FALSE return only if nothing reaches split time

        // get the next one
        //
        CComQIPtr< IAMTimelineNode, &IID_IAMTimelineNode > pChild2( pChild );
        pChild.Release( );
        pChild2->XGetNextOfType( SPLITAT_TYPE, &pChild );
    }

    return hr;
}

STDMETHODIMP CAMTimelineTrack::SetStartStop(REFERENCE_TIME Start, REFERENCE_TIME Stop)
{
    return E_NOTIMPL; // okay, we don't implement SetStartStop here
}

STDMETHODIMP CAMTimelineTrack::SetStartStop2(REFTIME Start, REFTIME Stop)
{
    return E_NOTIMPL; // okay, we don't implement SetStartStop here
}
=== C:/Users/treeman/Desktop/windows nt source code\Source\Win2K3\NT\multimedia\dshow\filterus\dexter\tldb\tldbobj.cpp ===
//@@@@AUTOBLOCK+============================================================;
//
//  THIS CODE AND INFORMATION IS PROVIDED "AS IS" WITHOUT WARRANTY OF ANY
//  KIND, EITHER EXPRESSED OR IMPLIED, INCLUDING BUT NOT LIMITED TO THE
//  IMPLIED WARRANTIES OF MERCHANTABILITY AND/OR FITNESS FOR A PARTICULAR
//  PURPOSE.
//
//  File: tldbobj.cpp
//
//  Copyright (c) Microsoft Corporation.  All Rights Reserved.
//
//@@@@AUTOBLOCK-============================================================;

#include <streams.h>
#include "stdafx.h"
#include "tldb.h"
#include <strsafe.h>

const int OUR_MAX_STREAM_SIZE = 2048; // chosen at random
long CAMTimelineObj::m_nStaticGenID = 0;

//############################################################################
// 
//############################################################################

CAMTimelineObj::CAMTimelineObj( TCHAR *pName, LPUNKNOWN pUnk, HRESULT * phr )
    : CUnknown( pName, pUnk )
    , m_rtStart( 0 )
    , m_rtStop( 0 )
    , m_bMuted( FALSE )
    , m_bLocked( FALSE )
    , m_rtDirtyStart( -1 )
    , m_rtDirtyStop( -1 )
    , m_pUserData( NULL )
    , m_nUserDataSize( 0 )
    , m_UserID( 0 )
    , m_SubObjectGuid( GUID_NULL )
    , m_nGenID( 0 )
{
    m_UserName[0] = 0;
    m_ClassID = GUID_NULL;

    // bad logic since we don't init globals
    //
    static bool SetStatic = false;
    if( !SetStatic )
    {
        SetStatic = true;
        m_nStaticGenID = 0;
    }

    _BumpGenID( );
}

//############################################################################
// 
//############################################################################

CAMTimelineObj::~CAMTimelineObj( )
{
    _Clear( );
}

//############################################################################
// clear all the memory this object allocated for it's subobject and data
//############################################################################

void CAMTimelineObj::_Clear( )
{
    _ClearSubObject( );

    if( m_pUserData )
    {
        delete [] m_pUserData;
        m_pUserData = NULL;
    }
    m_nUserDataSize = 0;
}

//############################################################################
// clear out the subobject and anything it had in it.
//############################################################################

void CAMTimelineObj::_ClearSubObject( )
{
    m_pSubObject.Release( );
    m_SubObjectGuid = GUID_NULL;
    m_pSetter.Release( );
}

//############################################################################
// return the interfaces we support
//############################################################################

STDMETHODIMP CAMTimelineObj::NonDelegatingQueryInterface(REFIID riid, void **ppv)
{
    if( riid == IID_IAMTimelineObj )
    {
        return GetInterface( (IAMTimelineObj*) this, ppv );
    }
    if( riid == IID_IAMTimelineNode )
    {
        return GetInterface( (IAMTimelineNode*) this, ppv );
    }
    return CUnknown::NonDelegatingQueryInterface( riid, ppv );
}

//############################################################################
// 
//############################################################################

STDMETHODIMP CAMTimelineObj::GetStartStop2(REFTIME * pStart, REFTIME * pStop)
{
    REFERENCE_TIME p1;
    REFERENCE_TIME p2;
    HRESULT hr = GetStartStop( &p1, &p2 );
    *pStart = RTtoDouble( p1 );
    *pStop = RTtoDouble( p2 );
    return hr;
}

STDMETHODIMP CAMTimelineObj::GetStartStop(REFERENCE_TIME * pStart, REFERENCE_TIME * pStop)
{
    CheckPointer( pStart, E_POINTER );
    CheckPointer( pStop, E_POINTER );

    *pStart = m_rtStart;
    *pStop = m_rtStop;

    return NOERROR;
}

//############################################################################
// 
//############################################################################

STDMETHODIMP CAMTimelineObj::SetStartStop2(REFTIME Start, REFTIME Stop)
{
    if( ( Start == -1 ) && ( Stop == -1 ) )
    {
        return NOERROR;
    }

    // see how long we are
    //
    REFERENCE_TIME diff = m_rtStop - m_rtStart;

    REFERENCE_TIME p1 = DoubleToRT( Start );
    REFERENCE_TIME p2 = DoubleToRT( Stop );

    // if they didn't give the start time
    //
    if( Start == -1 )
    {
        p1 = p2 - diff;
    }

    // if they didn't give the stop time
    //
    if( Stop == -1 )
    {
        p2 = p1 + diff;
    }

    HRESULT hr = SetStartStop( p1, p2 );
    return hr;
}

STDMETHODIMP CAMTimelineObj::SetStartStop(REFERENCE_TIME Start, REFERENCE_TIME Stop)
{
    if( ( Start == -1 ) && ( Stop == -1 ) )
    {
        return NOERROR;
    }

    CComPtr< IAMTimelineObj > pRefHolder( this );

    // is this object already in the tree? Don't add and remove it if it is NOT.
    //
    CComPtr< IAMTimelineObj > pParent;
    XGetParent( &pParent );

    REFERENCE_TIME p1 = Start;
    REFERENCE_TIME p2 = Stop;

    // if they didn't give the start time
    //
    if( Start == -1 )
    {
        p1 = m_rtStart;
    }
    else if( Start < 0 )
    {
        return E_INVALIDARG;
    }
        
    // if they didn't give the stop time
    //
    if( Stop == -1 )
    {
        p2 = m_rtStop;
    } else if( Stop < 0 )
    {
        return E_INVALIDARG;
    }

    // if stop time is less than Start
    //
    if( Start > Stop )
    {
        return E_INVALIDARG;
    }

    // if we're time based, not priority based, we need to remove this
    // object from the tree first, in case we change the start times to
    // something weird
    //
    if( !HasPriorityOverTime( ) && pParent )
    {
        XRemoveOnlyMe( );
    }

    m_rtStart = p1;
    m_rtStop = p2;

    SetDirtyRange( m_rtStart, m_rtStop );

    // if prioriity is more important, then we're done
    //
    if( HasPriorityOverTime( ) || !pParent )
    {
        return NOERROR;
    }

    HRESULT hr = 0;

    CComQIPtr< IAMTimelineNode, &IID_IAMTimelineNode > pParentNode( pParent );
    hr = pParentNode->XAddKidByTime( m_TimelineType, pRefHolder );

    return hr;
}

//############################################################################
// 
//############################################################################

STDMETHODIMP CAMTimelineObj::GetSubObject(IUnknown* *ppVal)
{
    CheckPointer( ppVal, E_POINTER );

    *ppVal = m_pSubObject;
    if( *ppVal )
    {
        (*ppVal)->AddRef( );
    }

    return NOERROR;
}

//############################################################################
// 
//############################################################################

STDMETHODIMP CAMTimelineObj::GetSubObjectLoaded(BOOL * pVal)
{
    CheckPointer( pVal, E_POINTER );

    *pVal = ( m_pSubObject != NULL );

    return NOERROR;
}

//############################################################################
// set the COM object that this timeline object holds. This can be used instead
// of a GUID to the COM object.
//############################################################################

// why will people be calling us to tell us what our sub object is?
// 1: we don't already have one, so we need to fill in our com
// pointer and GUID, and sub-object data. Problem is, only sometimes
// will we want sub-object data, depending on what type of node we are.
// how do we tell?
// 2: we already have a sub-object, but want to clear it out. We can call
// a clear method, then pretend it's #1 above.
//
STDMETHODIMP CAMTimelineObj::SetSubObject(IUnknown* newVal)
{
    // if they're the same, return
    //
    if( newVal == m_pSubObject )
    {
        return NOERROR;
    }

    GUID incomingGuid = _GetObjectGuid( newVal );

    if( incomingGuid == GUID_NULL )
    {
        DbgLog((LOG_TRACE, 2, TEXT("SetSubObject: CLSID doesn't exist." )));
    }
    else
    {
        m_SubObjectGuid = incomingGuid;
    }

    // blow out the cache
    //
    _BumpGenID( );

    // dirty ourselves for our duration
    //
    SetDirtyRange( m_rtStart, m_rtStop );

    m_pSubObject = newVal;

    return NOERROR;
}

//############################################################################
// 
//############################################################################

STDMETHODIMP CAMTimelineObj::SetSubObjectGUID(GUID newVal)
{
    // if they're the same, return
    //
    if( newVal == m_SubObjectGuid )
    {
        return NOERROR;
    }

    // wipe out what used to be here, since we're setting a new object.
    //
    _ClearSubObject( );

    // blow out the cache
    //
    _BumpGenID( );

    // ??? should we wipe out user data, too?

    m_SubObjectGuid = newVal;

    SetDirtyRange( m_rtStart, m_rtStop );

    return NOERROR;
}

//############################################################################
// 
//############################################################################

STDMETHODIMP CAMTimelineObj::GetSubObjectGUID(GUID * pVal)
{
    CheckPointer( pVal, E_POINTER );

    *pVal = m_SubObjectGuid;

    return NOERROR;
}

STDMETHODIMP CAMTimelineObj::SetSubObjectGUIDB(BSTR newVal)
{
    GUID NewGuid = GUID_NULL;
    HRESULT hr = CLSIDFromString( newVal, &NewGuid );
    if( FAILED( hr ) )
    {
        return hr;
    }

    hr = SetSubObjectGUID( NewGuid );
    return hr;
}

STDMETHODIMP CAMTimelineObj::GetSubObjectGUIDB(BSTR * pVal)
{
    HRESULT hr;

    WCHAR * TempVal = NULL;
    hr = StringFromCLSID( m_SubObjectGuid, &TempVal );
    if( FAILED( hr ) )
    {
        return hr;
    }
    *pVal = SysAllocString( TempVal );
    CoTaskMemFree( TempVal );
    if( !(*pVal) ) return E_OUTOFMEMORY;
    return NOERROR;
}


//############################################################################
// ask what our type is.
//############################################################################

STDMETHODIMP CAMTimelineObj::GetTimelineType(TIMELINE_MAJOR_TYPE * pVal)
{
    CheckPointer( pVal, E_POINTER );

    *pVal = m_TimelineType;

    return NOERROR;
}

//############################################################################
// 
//############################################################################

STDMETHODIMP CAMTimelineObj::SetTimelineType(TIMELINE_MAJOR_TYPE newVal)
{
    // don't care if they're the same
    //
    if( newVal == m_TimelineType )
    {
        return NOERROR;
    }

    // can't set the type, once it's been set
    //
    if( m_TimelineType != 0 )
    {
        DbgLog((LOG_TRACE, 2, TEXT("SetTimelineType: Timeline type already set." )));
        return E_INVALIDARG;
    }

    SetDirtyRange( m_rtStart, m_rtStop );

    m_TimelineType = newVal;

    return NOERROR;
}

//############################################################################
//
//############################################################################

STDMETHODIMP CAMTimelineObj::GetUserID(long * pVal)
{
    CheckPointer( pVal, E_POINTER );

    *pVal = m_UserID;

    return NOERROR;
}

//############################################################################
// 
//############################################################################

STDMETHODIMP CAMTimelineObj::SetUserID(long newVal)
{
    m_UserID = newVal;

    SetDirtyRange( m_rtStart, m_rtStop );

    return NOERROR;
}

//############################################################################
// 
//############################################################################

STDMETHODIMP CAMTimelineObj::GetUserName(BSTR * pVal)
{
    CheckPointer( pVal, E_POINTER );
    *pVal = SysAllocString( m_UserName );
    if( !(*pVal) ) return E_OUTOFMEMORY;
    return NOERROR;
}

//############################################################################
// 
//############################################################################

STDMETHODIMP CAMTimelineObj::SetUserName(BSTR newVal)
{
    if (newVal == NULL) {
	m_UserName[0] = 0;
    } else {
        HRESULT hr = StringCchCopy( m_UserName, 256, newVal );
        if( FAILED( hr ) )
        {
            return hr;
        }
    }

    SetDirtyRange( m_rtStart, m_rtStop );

    return NOERROR;
}

//############################################################################
// 
//############################################################################

STDMETHODIMP CAMTimelineObj::GetPropertySetter(IPropertySetter **ppSetter)
{
    CheckPointer(ppSetter, E_POINTER);

    *ppSetter = m_pSetter;
    if (*ppSetter)
        (*ppSetter)->AddRef();
    return NOERROR;
}

//############################################################################
// 
//############################################################################

STDMETHODIMP CAMTimelineObj::SetPropertySetter(IPropertySetter *pSetter)
{
    m_pSetter = pSetter;
    // !!! _GiveSubObjectData(); if sub object instantiated, give it props now?
    return NOERROR;
}


//############################################################################
// 
//############################################################################

STDMETHODIMP CAMTimelineObj::GetUserData(BYTE * pData, long * pSize)
{
    // somebody was fooling us
    //
    if( !pData && !pSize )
    {
        return E_POINTER;
    }

    CheckPointer( pSize, E_POINTER );

    *pSize = m_nUserDataSize;

    // they just want the size
    //
    if( !pData )
    {
        return NOERROR;
    }

    // if passed in size isn't what we expect it to be... ???

    CopyMemory( pData, m_pUserData, m_nUserDataSize );

    return NOERROR;
}

//############################################################################
// 
//############################################################################

STDMETHODIMP CAMTimelineObj::SetUserData(BYTE * pData, long Size)
{
    // somebody was fooling us
    //
    if( Size == 0 )
    {
        return NOERROR;
    }

    SetDirtyRange( m_rtStart, m_rtStop );

    if( m_pUserData )
    {
        delete [] m_pUserData;
        m_pUserData = NULL;
    }

    BYTE * pNewData = new BYTE[Size];

    if( !pNewData )
    {
        DbgLog((LOG_TRACE, 2, TEXT("SetUserData: memory allocation failed." )));
        return E_OUTOFMEMORY;
    }

    m_pUserData = pNewData;
    CopyMemory( m_pUserData, pData, Size );
    m_nUserDataSize = Size;

    return NOERROR;
}

//############################################################################
// 
//############################################################################

STDMETHODIMP CAMTimelineObj::GetMuted(BOOL * pVal)
{
    CheckPointer( pVal, E_POINTER );
    *pVal = FALSE;

    // if the parent is muted, so are we
    CComPtr< IAMTimelineObj > pObj;
    HRESULT hr = XGetParent(&pObj);
    if (hr == S_OK && pObj)
	pObj->GetMuted(pVal);

    if (m_bMuted)
        *pVal = TRUE;

    return NOERROR;
}

//############################################################################
// 
//############################################################################

STDMETHODIMP CAMTimelineObj::SetMuted(BOOL newVal)
{
    // drived class should override
    //
    //DbgLog((LOG_TRACE,2,TEXT("SetMuted: Derived class should implement?" )));
    m_bMuted = newVal;
    return S_OK;
}

//############################################################################
// 
//############################################################################

STDMETHODIMP CAMTimelineObj::GetLocked(BOOL * pVal)
{
    CheckPointer( pVal, E_POINTER );

    *pVal = m_bLocked;

    return NOERROR;
}

//############################################################################
// 
//############################################################################

STDMETHODIMP CAMTimelineObj::SetLocked(BOOL newVal)
{
    // drived class should override
    //
    //DbgLog((LOG_TRACE,2,TEXT("SetLocked: Derived class should implement?" )));

    m_bLocked = newVal;

    return NOERROR;
}

//############################################################################
// 
//############################################################################

STDMETHODIMP CAMTimelineObj::GetDirtyRange2
    (REFTIME * pStart, REFTIME * pStop)
{
    REFERENCE_TIME p1 = DoubleToRT( *pStart );
    REFERENCE_TIME p2 = DoubleToRT( *pStop );
    HRESULT hr = GetDirtyRange( &p1, &p2 );
    *pStart = RTtoDouble( p1 );
    *pStop = RTtoDouble( p2 );
    return hr;
}

STDMETHODIMP CAMTimelineObj::GetDirtyRange
    (REFERENCE_TIME * pStart, REFERENCE_TIME * pStop)
{
    CheckPointer( pStart, E_POINTER );
    CheckPointer( pStop, E_POINTER );

    *pStart = m_rtDirtyStart;
    *pStop = m_rtDirtyStop;

    return NOERROR;
}

//############################################################################
// 
//############################################################################

STDMETHODIMP CAMTimelineObj::SetDirtyRange2
    (REFTIME Start, REFTIME Stop )
{
    REFERENCE_TIME p1 = DoubleToRT( Start );
    REFERENCE_TIME p2 = DoubleToRT( Stop );
    HRESULT hr = SetDirtyRange( p1, p2 );
    return hr;
}

STDMETHODIMP CAMTimelineObj::SetDirtyRange
    (REFERENCE_TIME Start, REFERENCE_TIME Stop )
{
    // need to do different things, depending on what our major type is.
    // every C++ class should need to override this.

    DbgLog((LOG_TRACE, 2, TEXT("SetDirtyRange: Derived class should implement." )));

    return E_NOTIMPL; // okay
}

//############################################################################
// 
//############################################################################

STDMETHODIMP CAMTimelineObj::ClearDirty
    ( )
{
    m_rtDirtyStart = -1;
    m_rtDirtyStop = -1;

    return NOERROR;
}

//############################################################################
// 
//############################################################################

STDMETHODIMP CAMTimelineObj::Remove()
{
    // if this thing isn't in the tree already, don't do anything
    //
    IAMTimelineObj * pParent = 0;
    XGetParentNoRef( &pParent );
    if( !pParent )
    {
        return NOERROR;
    }

    return XRemoveOnlyMe( );
}

STDMETHODIMP CAMTimelineObj::RemoveAll()
{
    // if this thing isn't in the tree already, don't do anything
    //
    IAMTimelineObj * pParent = 0;
    XGetParentNoRef( &pParent );
    if( !pParent )
    {
        return NOERROR;
    }

    return XRemove( );
}

//############################################################################
// complicated function. Must copy everything, including the sub-object,
//############################################################################

HRESULT CAMTimelineObj::CopyDataTo( IAMTimelineObj * pSrc, REFERENCE_TIME TimelineTime )
{
    HRESULT hr = 0;

    // these functions cannot fail
    //
    pSrc->SetStartStop( m_rtStart, m_rtStop );
    pSrc->SetTimelineType( m_TimelineType );
    pSrc->SetUserID( m_UserID );
    pSrc->SetSubObjectGUID( m_SubObjectGuid );
    pSrc->SetMuted( m_bMuted );
    pSrc->SetLocked( m_bLocked );
    pSrc->SetDirtyRange( m_rtStart, m_rtStop );

    // these functions can bomb on allocating memory
    //
    hr = pSrc->SetUserData( m_pUserData, m_nUserDataSize );
    if( FAILED( hr ) )
    {
        return hr;
    }

    BSTR bName = SysAllocString (m_UserName);
    if (bName)
    {
        hr = pSrc->SetUserName( bName);
        SysFreeString(bName);
    }
    else
    {
        hr = E_OUTOFMEMORY;
    }
    if( FAILED( hr ) )
    {
        return hr;
    }

    // if we have any properties in the property setter, the new object
    // needs them too.
    //
    if( !m_pSetter )
    {
        hr = pSrc->SetPropertySetter( NULL );
    }
    else
    {
        // clone our property setter and give it to the new
        // !!! these times are wrong.
        CComPtr< IPropertySetter > pNewSetter;
        hr = m_pSetter->CloneProps( &pNewSetter, TimelineTime - m_rtStart, m_rtStop - m_rtStart );
        ASSERT( !FAILED( hr ) );
        if( FAILED( hr ) )
        {
            return hr;
        }
        hr = pSrc->SetPropertySetter( pNewSetter );
    }

    if( FAILED( hr ) )
    {
        return hr;
    }

    if( m_pSubObject )
    {
        // how to create a copy of a COM object
        //
        CComPtr< IStream > pMemStream;
        CreateStreamOnHGlobal( NULL, TRUE, &pMemStream );
        if( !pMemStream )
        {
            return E_OUTOFMEMORY;
        }
        CComQIPtr< IPersistStream, &IID_IPersistStream > pPersistStream( m_pSubObject );
        if( pPersistStream )
        {
            CComPtr< IUnknown > pNewSubObject;
            hr = pPersistStream->Save( pMemStream, TRUE );
            ASSERT( !FAILED( hr ) );
            if( FAILED( hr ) )
            {
                return hr;
            }
            hr = pMemStream->Commit( 0 );
            if( FAILED( hr ) )
            {
                return hr;
            }
            LARGE_INTEGER li;
            li.QuadPart = 0;
            hr = pMemStream->Seek( li, STREAM_SEEK_SET, NULL );
            if( FAILED( hr ) )
            {
                return hr;
            }
            OleLoadFromStream( pMemStream, IID_IUnknown, (void**) &pNewSubObject );
            if( !pNewSubObject )
            {
                return E_OUTOFMEMORY;
            }
            hr = pSrc->SetSubObject( pNewSubObject );
        }
    }

    return hr;
}


//############################################################################
// 
//############################################################################

STDMETHODIMP CAMTimelineObj::GetTimelineNoRef( IAMTimeline ** ppResult )
{
    HRESULT hr = 0;

    CheckPointer( ppResult, E_POINTER );
    *ppResult = NULL;

    CComPtr< IAMTimelineGroup > pGroup;
    hr = GetGroupIBelongTo( &pGroup );
    if( FAILED( hr ) )
    {
        return hr;
    }

    hr = pGroup->GetTimeline( ppResult );

    // don't hold a reference to it
    //
    if( *ppResult )
    {
        (*ppResult)->Release( );
    }
    return hr;
}

//############################################################################
// try to find the subobject's GUID, only called by SetSubObject.
//############################################################################

GUID CAMTimelineObj::_GetObjectGuid( IUnknown * pObject )
{
    GUID guid;
    HRESULT hr = 0;

    // ask IPersist for it
    CComQIPtr< IPersist, &IID_IPersist > pPersist( pObject );
    if( pPersist )
    {
        hr = pPersist->GetClassID( &guid );
        return guid;
    }

    // ask IPersistStorage for it
    CComQIPtr< IPersistStorage, &IID_IPersistStorage > pPersistStorage( pObject );
    if( pPersistStorage )
    {
        hr = pPersistStorage->GetClassID( &guid );
        return guid;
    }

    // oh darn, ask IPersistPropertyBag?
    //
    CComQIPtr< IPersistPropertyBag, &IID_IPersistPropertyBag > pPersistPropBag( pObject );
    if( pPersistPropBag )
    {
        hr = pPersistPropBag->GetClassID( &guid );
        return guid;
    }

    // DARN!
    //
    return GUID_NULL;
}

//############################################################################
// 
//############################################################################

HRESULT CAMTimelineObj::GetGenID( long * pVal )
{
    CheckPointer( pVal, E_POINTER );
    *pVal = m_nGenID;
    return NOERROR;
}

//############################################################################
// fix up the times to align on our group's frame rate
//############################################################################

STDMETHODIMP CAMTimelineObj::FixTimes2( REFTIME * pStart, REFTIME * pStop )
{
    REFERENCE_TIME p1 = 0;
    if( pStart )
    {
        p1 = DoubleToRT( *pStart );
    }
    REFERENCE_TIME p2 = 0;
    if( pStop )
    {
        p2 = DoubleToRT( *pStop );
    }
    HRESULT hr = FixTimes( &p1, &p2 );
    if( pStart )
    {
        *pStart = RTtoDouble( p1 );
    }
    if( pStop )
    {
        *pStop = RTtoDouble( p2 );
    }
    return hr;
}

//############################################################################
// These parameters are IN/OUT. It fixes up what was passed in.
//############################################################################

STDMETHODIMP CAMTimelineObj::FixTimes
    ( REFERENCE_TIME * pStart, REFERENCE_TIME * pStop )
{
    REFERENCE_TIME Start = 0;
    REFERENCE_TIME Stop = 0;
    if( pStart )
    {
        Start = *pStart;
    }
    if( pStop )
    {
        Stop = *pStop;
    }

    CComPtr< IAMTimelineGroup > pGroup;
    HRESULT hr = 0;
    hr = GetGroupIBelongTo( &pGroup );
    if( !pGroup )
    {
        return E_NOTINTREE;
    }

    double FPS = TIMELINE_DEFAULT_FPS;
    pGroup->GetOutputFPS( &FPS );

    LONGLONG f = Time2Frame( Start, FPS );
    REFERENCE_TIME NewStart = Frame2Time( f, FPS );
    f = Time2Frame( Stop, FPS );
    REFERENCE_TIME NewStop = Frame2Time( f, FPS );

    if( pStart )
    {
        *pStart = NewStart;
    }
    if( pStop )
    {
        *pStop = NewStop;
    }
    return NOERROR;
}

//############################################################################
// 
//############################################################################

STDMETHODIMP CAMTimelineObj::GetGroupIBelongTo( IAMTimelineGroup ** ppGroup )
{
    CheckPointer( ppGroup, E_POINTER );

    *ppGroup = NULL;
    HRESULT hr = 0;

    // since we never use bumping of refcounts in here, don't use a CComPtr
    //
    IAMTimelineObj * p = this; // okay not CComPtr

    long HaveParent;
    while( 1 )
    {
        CComQIPtr< IAMTimelineNode, &IID_IAMTimelineNode > pNode( p );
        HaveParent = 0;
        hr = pNode->XHaveParent( &HaveParent );
        if( HaveParent == 0 )
        {
            break;
        }
        pNode->XGetParentNoRef( &p );
    }

    CComQIPtr< IAMTimelineGroup, &IID_IAMTimelineGroup > pGroup( p );
    if( !pGroup )
    {
        return E_NOINTERFACE;
    }

    *ppGroup = pGroup;
    (*ppGroup)->AddRef( );
    return NOERROR;
}

//############################################################################
// 
//############################################################################

STDMETHODIMP CAMTimelineObj::GetEmbedDepth( long * pVal )
{
    CheckPointer( pVal, E_POINTER );

    *pVal = 0;
    HRESULT hr = 0;

    // since we never use bumping of refcounts in here, don't use a CComPtr
    //
    IAMTimelineObj * p = this; // okay not CComPtr

    long HaveParent;
    while( 1 )
    {
        CComQIPtr< IAMTimelineNode, &IID_IAMTimelineNode > pNode( p );
        HaveParent = 0;
        hr = pNode->XHaveParent( &HaveParent );
        if( HaveParent == 0 )
        {
            break;
        }

        (*pVal)++;
        pNode->XGetParentNoRef( &p );

    }

    return NOERROR;
}

//############################################################################
// 
//############################################################################

void CAMTimelineObj::_BumpGenID( )
{
    // bump by a # to account for things who want to fiddle with secret
    // things in the graph cache. Don't change this.
    m_nStaticGenID = m_nStaticGenID + 10;
    m_nGenID = m_nStaticGenID;
}
=== C:/Users/treeman/Desktop/windows nt source code\Source\Win2K3\NT\multimedia\dshow\filterus\dexter\tldb\tldbgroup.cpp ===
//@@@@AUTOBLOCK+============================================================;
//
//  THIS CODE AND INFORMATION IS PROVIDED "AS IS" WITHOUT WARRANTY OF ANY
//  KIND, EITHER EXPRESSED OR IMPLIED, INCLUDING BUT NOT LIMITED TO THE
//  IMPLIED WARRANTIES OF MERCHANTABILITY AND/OR FITNESS FOR A PARTICULAR
//  PURPOSE.
//
//  File: tldbgroup.cpp
//
//  Copyright (c) Microsoft Corporation.  All Rights Reserved.
//
//@@@@AUTOBLOCK-============================================================;

#include <streams.h>
#include "stdafx.h"
#include "tldb.h"
#include "..\util\filfuncs.h"
#include <strsafe.h>

//############################################################################
//
//############################################################################

CAMTimelineGroup::CAMTimelineGroup
    ( TCHAR *pName, LPUNKNOWN pUnk, HRESULT * phr )
    : CAMTimelineComp( pName, pUnk, phr )
    , m_nPriority( 0 )
    , m_dFPS( TIMELINE_DEFAULT_FPS )
    , m_pTimeline( NULL )
    , m_fPreview( TRUE )
    , m_nOutputBuffering( DEX_DEF_OUTPUTBUF ) // default to 30 frms of buffering
{
    m_ClassID = CLSID_AMTimelineGroup;
    m_TimelineType = TIMELINE_MAJOR_TYPE_GROUP;
    ZeroMemory( &m_MediaType, sizeof( AM_MEDIA_TYPE ) );
    m_szGroupName[0] = 0;

    m_bRecompressTypeSet = FALSE;
    m_bRecompressFormatDirty = FALSE;
}

//############################################################################
// 
//############################################################################

CAMTimelineGroup::~CAMTimelineGroup( )
{
     SaferFreeMediaType( m_MediaType );
}

//############################################################################
// 
//############################################################################

STDMETHODIMP CAMTimelineGroup::NonDelegatingQueryInterface
    (REFIID riid, void **ppv)
{
    // specifically prohibit this interface, since we
    // do inherit it from the base CAMTimelineComp class,
    // but we don't support it on top-level tree nodes
    //
    if( riid == IID_IAMTimelineVirtualTrack )
    {
        return E_NOINTERFACE;
    }
    if( riid == IID_IAMTimelineGroup )
    {
        return GetInterface( (IAMTimelineGroup*) this, ppv );
    }
    return CAMTimelineComp::NonDelegatingQueryInterface( riid, ppv );
}

//############################################################################
// 
//############################################################################

STDMETHODIMP CAMTimelineGroup::GetPriority( long * pPriority )
{
    CheckPointer( pPriority, E_POINTER );

    *pPriority = m_nPriority;
    return NOERROR;
}

//############################################################################
// this media type will be getting set in one of two ways. The user is setting
// the uncompressed type for the group OR the SetSmartRecompressFormat is calling
// us with a COMPRESSSED media type, and we're to glean the uncompressed info
// from it. We can assume that the user has correctly set the BIT DEPTH of the
// UNCOMPRESSED format to allow connection to the compressor. Pay attention
// to this closely - the UNCOMPRESSED media type is the type that will eventually
// be connected to the compressor. The compressed media type is what the user
// wants to compress to, but we're notified of that fact in this method so
// we can make sure the width/height/etc match
//############################################################################

STDMETHODIMP CAMTimelineGroup::SetMediaType( AM_MEDIA_TYPE * pMediaType )
{
    CheckPointer( pMediaType, E_POINTER );

    // Make sure they are using a valid media type allowed by Dexter
    //
    if( m_MediaType.majortype == MEDIATYPE_Video &&
        		m_MediaType.subtype != GUID_NULL) {
	if (m_MediaType.formattype != FORMAT_VideoInfo) {
	    return VFW_E_INVALIDMEDIATYPE;
	}
	VIDEOINFO *pvi = (VIDEOINFO *)m_MediaType.pbFormat;
	if (HEADER(pvi)->biCompression != BI_RGB) {
	    return VFW_E_INVALIDMEDIATYPE;
	}
	if (HEADER(pvi)->biBitCount != 16 && HEADER(pvi)->biBitCount != 24 &&
					HEADER(pvi)->biBitCount != 32) {
	    return VFW_E_INVALIDMEDIATYPE;
	}
	// we can't handle top-down video... the resizer filter can't deal with
	// it
	if (HEADER(pvi)->biHeight < 0) {
	    return VFW_E_INVALIDMEDIATYPE;
	}
    }
    if( m_MediaType.majortype == MEDIATYPE_Audio) {
	if (m_MediaType.formattype != FORMAT_WaveFormatEx) {
	    return VFW_E_INVALIDMEDIATYPE;
	}
	LPWAVEFORMATEX pwfx = (LPWAVEFORMATEX)m_MediaType.pbFormat;
	if (pwfx->nChannels != 2 || pwfx->wBitsPerSample != 16) {
	    return VFW_E_INVALIDMEDIATYPE;
	}
    }

    SaferFreeMediaType( m_MediaType );
    HRESULT hr = CopyMediaType( &m_MediaType, pMediaType );
    if( FAILED( hr ) )
    {
        return hr;
    }

    // assume that if they set the format, they've set everything else
    //
    if( m_MediaType.pbFormat )
    {
        return NOERROR;
    }

    if( m_MediaType.majortype == MEDIATYPE_Video )
    {
        // if they forgot to set the subtype, we'll set the whole thing for them
        //
        if( m_MediaType.subtype == GUID_NULL )
        {
            ZeroMemory(&m_MediaType, sizeof(AM_MEDIA_TYPE));
            m_MediaType.majortype = MEDIATYPE_Video;
            m_MediaType.subtype = MEDIASUBTYPE_RGB555;
            m_MediaType.formattype = FORMAT_VideoInfo;
            m_MediaType.bFixedSizeSamples = TRUE;
            m_MediaType.pbFormat = (BYTE *)QzTaskMemAlloc(SIZE_PREHEADER +
                            sizeof(BITMAPINFOHEADER));
            m_MediaType.cbFormat = SIZE_PREHEADER + sizeof(BITMAPINFOHEADER);
            ZeroMemory(m_MediaType.pbFormat, m_MediaType.cbFormat);
            LPBITMAPINFOHEADER lpbi = HEADER(m_MediaType.pbFormat);
            lpbi->biSize = sizeof(BITMAPINFOHEADER);
            lpbi->biCompression = BI_RGB;
            lpbi->biBitCount = 16;
            lpbi->biWidth = 320;
            lpbi->biHeight = 240;
            lpbi->biPlanes = 1;
            lpbi->biSizeImage = DIBSIZE(*lpbi);
            m_MediaType.lSampleSize = DIBSIZE(*lpbi);
        }
    }
    if( m_MediaType.majortype == MEDIATYPE_Audio )
    {
        ZeroMemory(&m_MediaType, sizeof(AM_MEDIA_TYPE));
        m_MediaType.majortype = MEDIATYPE_Audio;
        m_MediaType.subtype = MEDIASUBTYPE_PCM;
        m_MediaType.bFixedSizeSamples = TRUE;
        m_MediaType.formattype = FORMAT_WaveFormatEx;
        m_MediaType.pbFormat = (BYTE *)QzTaskMemAlloc( sizeof( WAVEFORMATEX ) );
        m_MediaType.cbFormat = sizeof( WAVEFORMATEX );
        WAVEFORMATEX * vih = (WAVEFORMATEX*) m_MediaType.pbFormat;
        ZeroMemory( vih, sizeof( WAVEFORMATEX ) );
        vih->wFormatTag = WAVE_FORMAT_PCM;
        vih->nChannels = 2;
        vih->nSamplesPerSec = 44100;
        vih->nBlockAlign = 4;
        vih->nAvgBytesPerSec = vih->nBlockAlign * vih->nSamplesPerSec;
        vih->wBitsPerSample = 16;
        m_MediaType.lSampleSize = vih->nBlockAlign;
    }

    return NOERROR;
}

//############################################################################
// 
//############################################################################

STDMETHODIMP CAMTimelineGroup::SetMediaTypeForVB( long Val )
{
    CMediaType GroupMediaType;
    if( Val == 0 )
    {
        GroupMediaType.SetType( &MEDIATYPE_Video );
    }
    else
    {
        GroupMediaType.SetType( &MEDIATYPE_Audio );
    }
    SetMediaType( &GroupMediaType );

    return NOERROR;
}

//############################################################################
// 
//############################################################################

STDMETHODIMP CAMTimelineGroup::GetMediaType( AM_MEDIA_TYPE * pMediaType )
{
    CheckPointer( pMediaType, E_POINTER );
    return CopyMediaType( pMediaType, &m_MediaType );
}

//############################################################################
// 
//############################################################################

STDMETHODIMP CAMTimelineGroup::SetOutputFPS( double FPS )
{
    if (FPS <= 0)
    {
        return E_INVALIDARG;
    }
    m_dFPS = FPS;
    return NOERROR;
}

//############################################################################
// 
//############################################################################

STDMETHODIMP CAMTimelineGroup::GetOutputFPS( double * pFPS )
{
    CheckPointer( pFPS, E_POINTER );
    *pFPS = m_dFPS;
    return NOERROR;
}

//############################################################################
// Set the timeline that this composition uses. This should not be called
// externally, but I can't really prevent it.
//############################################################################

STDMETHODIMP CAMTimelineGroup::SetTimeline
    ( IAMTimeline * pTimeline )
{
    // don't allow setting it twice
    //
    if( m_pTimeline )
    {
        return E_INVALIDARG;
    }

    m_pTimeline = pTimeline; // !!! notice the lack of addreff here. I'm not sure if this is a bug

    return NOERROR;
}

//############################################################################
// Ask the group who the timeline is. Any groups except the root
// one will return NULL. The root one knows about the timeline who's using it.
// The base object's GetTimelineNoRef will eventually call this method on the
// root group.
//############################################################################

STDMETHODIMP CAMTimelineGroup::GetTimeline
    ( IAMTimeline ** ppTimeline )
{
    CheckPointer( ppTimeline, E_POINTER );

    *ppTimeline = m_pTimeline;

    if( *ppTimeline )
    {
        (*ppTimeline)->AddRef( );
    }

    return NOERROR;
}

//############################################################################
// 
//############################################################################

STDMETHODIMP CAMTimelineGroup::SetGroupName
    (BSTR newVal)
{
    HRESULT hr = StringCchCopy( m_szGroupName, 256, newVal );
    return hr;
}

//############################################################################
// 
//############################################################################

STDMETHODIMP CAMTimelineGroup::GetGroupName
    (BSTR * pVal)
{
    CheckPointer( pVal, E_POINTER );
    *pVal = SysAllocString( m_szGroupName );
    if( !(*pVal) )
    {
        return E_OUTOFMEMORY;
    }
    return NOERROR;
}

//############################################################################
// 
//############################################################################

STDMETHODIMP CAMTimelineGroup::SetPreviewMode
    (BOOL fPreview)
{
    m_fPreview = fPreview;
    return NOERROR;
}

//############################################################################
// 
//############################################################################

STDMETHODIMP CAMTimelineGroup::GetPreviewMode
    (BOOL *pfPreview)
{
    CheckPointer( pfPreview, E_POINTER );
    *pfPreview = m_fPreview;
    return NOERROR;
}

//############################################################################
// 
//############################################################################

STDMETHODIMP CAMTimelineGroup::SetOutputBuffering
    (int nBuffer)
{
    // minimum 2, or switch hangs
    if (nBuffer <=1)
    return E_INVALIDARG;
    m_nOutputBuffering = nBuffer;
    return NOERROR;
}

//############################################################################
// 
//############################################################################

STDMETHODIMP CAMTimelineGroup::GetOutputBuffering
    (int *pnBuffer)
{
    CheckPointer( pnBuffer, E_POINTER );
    *pnBuffer = m_nOutputBuffering;
    return NOERROR;
}

//############################################################################
// 
//############################################################################

STDMETHODIMP CAMTimelineGroup::Remove()
{
    HRESULT hr = 0;

    // all we want to do is to take this group out of the tree.
    //
    if( m_pTimeline )
    {
        hr = m_pTimeline->RemGroupFromList( this );
    }

    m_pTimeline = NULL;

    return hr;
}

//############################################################################
// 
//############################################################################

STDMETHODIMP CAMTimelineGroup::RemoveAll()
{
    // the 'owner' of us is the timeline's list itself.
    // That's the only thing that holds a refcount on us
    // so make sure to remove us from the tree first, 
    // THEN remove us from the parent's list

    // don't call the base class RemoveAll( ) function, since it will
    // check for the presence of a timeline
    //
    XRemove( );

    IAMTimeline * pTemp = m_pTimeline;
    m_pTimeline = NULL;

    // we need to take this group out of the timeline's list
    //
    pTemp->RemGroupFromList( this );

    // at this time, the group will already have had it's
    // destructor called. Do NOT reference any member variables!

    return NOERROR;
}

//############################################################################
// 
//############################################################################

STDMETHODIMP CAMTimelineGroup::SetSmartRecompressFormat( long * pFormat )
{
    CheckPointer( pFormat, E_POINTER );
    long id = *pFormat;
    if( id != 0 )
    {
        return E_INVALIDARG;
    }

    SCompFmt0 * pS = (SCompFmt0*) pFormat;

    m_bRecompressTypeSet = TRUE;
    m_bRecompressFormatDirty = TRUE;
    m_RecompressType = pS->MediaType;

    // copy compressed media type's fps and size to the group's
    //
    if( m_MediaType.majortype == MEDIATYPE_Video )
    {
        VIDEOINFOHEADER * pVIH = (VIDEOINFOHEADER*) m_RecompressType.Format( );
        REFERENCE_TIME rt = pVIH->AvgTimePerFrame;
	// ASF files do not tell us their frame rate.  Ugh.
        // ASSERT( rt );
	// Use the smart recompresson frame rate as the output frame rate of
	// the project, so smart recompression will work.  If we don't know
	// the frame rate, just trust the rate they already programmed the
	// group with, and use that for the smart rate too, since we need
	// to pick a non-zero number or we're in trouble
        if (rt) {
            m_dFPS = 1.0 / RTtoDouble( rt );
	} else {
	    // don't let this be zero!
	    pVIH->AvgTimePerFrame = (REFERENCE_TIME)(UNITS / m_dFPS);
	}

	if (m_MediaType.formattype == FORMAT_VideoInfo) {

            VIDEOINFOHEADER * pOurVIH = (VIDEOINFOHEADER*) m_MediaType.pbFormat;
            ASSERT( pOurVIH );
            if( !pOurVIH )
            {
                return VFW_E_INVALIDMEDIATYPE;
            }

            pOurVIH->bmiHeader.biWidth = pVIH->bmiHeader.biWidth;
            pOurVIH->bmiHeader.biHeight = pVIH->bmiHeader.biHeight;
            pOurVIH->bmiHeader.biSizeImage = DIBSIZE( pOurVIH->bmiHeader );
	    m_MediaType.lSampleSize = pOurVIH->bmiHeader.biSizeImage;

            return NOERROR;
        }
    }

    return NOERROR;
}

STDMETHODIMP CAMTimelineGroup::GetSmartRecompressFormat( long ** ppFormat )
{
    CheckPointer( ppFormat, E_POINTER );

    *ppFormat = NULL;

    SCompFmt0 * pS = new SCompFmt0;
    if( !pS )
    {
        return E_OUTOFMEMORY;
    }
    pS->nFormatId = 0;
    HRESULT hr = CopyMediaType( &pS->MediaType, &m_RecompressType );
    *ppFormat = (long*) pS;

    return hr;
}

STDMETHODIMP CAMTimelineGroup::IsSmartRecompressFormatSet( BOOL * pVal )
{
    CheckPointer( pVal, E_POINTER );
    *pVal = FALSE;

    // if they've set a type, then look at them both to see if SR can
    // even be done on this group
    //
    if( m_bRecompressTypeSet )
    {
        if( m_RecompressType.majortype != m_MediaType.majortype )
        {
            return NOERROR; // won't work
        }

	// !!! This means you can't do smart recompression with MPEG or
	// anything without VIDEOINFO type !!!
	//
        if( m_RecompressType.formattype != m_MediaType.formattype )
        {
            return NOERROR; // won't work
        }

        if( m_RecompressType.majortype == MEDIATYPE_Video )
        {
            VIDEOINFOHEADER * pVIH1 = (VIDEOINFOHEADER*) m_MediaType.pbFormat;
            VIDEOINFOHEADER * pVIH2 = (VIDEOINFOHEADER*) m_RecompressType.pbFormat;
            
            if( pVIH1->bmiHeader.biWidth != pVIH2->bmiHeader.biWidth )
            {
                return NOERROR;
            }
            if( pVIH1->bmiHeader.biHeight != pVIH2->bmiHeader.biHeight )
            {
                return NOERROR;
            }

	    // BIT DEPTH WILL BE DIFFERENT BETWEEN COMP AND UNCOMP TYPES

        }
        else
        {
            return NOERROR; // won't work
        }
    }

    *pVal = m_bRecompressTypeSet;

    return NOERROR;
}

STDMETHODIMP CAMTimelineGroup::IsRecompressFormatDirty( BOOL * pVal )
{
    CheckPointer( pVal, E_POINTER );
    *pVal = m_bRecompressFormatDirty;
    return NOERROR;
}

STDMETHODIMP CAMTimelineGroup::ClearRecompressFormatDirty( )
{
    m_bRecompressFormatDirty = FALSE;
    return NOERROR;
}

STDMETHODIMP CAMTimelineGroup::SetRecompFormatFromSource( IAMTimelineSrc * pSource )
{
    CheckPointer( pSource, E_POINTER );
    if( !m_pTimeline )
    {
        return E_NO_TIMELINE;
    }

    if( m_MediaType.majortype != MEDIATYPE_Video ) {
        return VFW_E_INVALIDMEDIATYPE;
    }

    CComBSTR Filename;
    HRESULT hr = 0;
    hr = pSource->GetMediaName(&Filename);
    if( FAILED( hr ) )
    {
        return hr;
    }

    SCompFmt0 * pFmt = new SCompFmt0;
    if( !pFmt )
    {
        return E_OUTOFMEMORY;
    }
    ZeroMemory( pFmt, sizeof( SCompFmt0 ) );

    // create a mediadet
    //
    CComPtr< IMediaDet > pDet;
    hr = CoCreateInstance( CLSID_MediaDet,
        NULL,
        CLSCTX_INPROC_SERVER,
        IID_IMediaDet,
        (void**) &pDet );
    if( FAILED( hr ) )
    {
        delete pFmt;
        return hr;
    }

    //
    // set the site provider on the MediaDet object to allowed keyed apps
    // to use ASF filters with dexter
    //
    CComQIPtr< IObjectWithSite, &IID_IObjectWithSite > pOWS( pDet );
    CComQIPtr< IServiceProvider, &IID_IServiceProvider > pTimelineSP( m_pTimeline );
    ASSERT( pOWS );
    if( pOWS )
    {
        pOWS->SetSite( pTimelineSP );
    }

    hr = pDet->put_Filename( Filename );
    if( FAILED( hr ) )
    {
        delete pFmt;
        return hr;
    }

    // go through and find the video stream type
    //
    long Streams = 0;
    long VideoStream = -1;
    hr = pDet->get_OutputStreams( &Streams );
    for( int i = 0 ; i < Streams ; i++ )
    {
        pDet->put_CurrentStream( i );
        GUID Major = GUID_NULL;
        pDet->get_StreamType( &Major );
        if( Major == MEDIATYPE_Video )
        {
            VideoStream = i;
            break;
        }
    }
    if( VideoStream == -1 )
    {
        delete pFmt;
        return VFW_E_INVALIDMEDIATYPE;
    }

    hr = pDet->get_StreamMediaType( &pFmt->MediaType );
    if( SUCCEEDED( hr ) )
    {
        hr = SetSmartRecompressFormat( (long*) pFmt );
    }

    SaferFreeMediaType( pFmt->MediaType );

    delete pFmt;

    return hr;
}
=== C:/Users/treeman/Desktop/windows nt source code\Source\Win2K3\NT\multimedia\dshow\filterus\dexter\tldb\tldbsrc.cpp ===
//@@@@AUTOBLOCK+============================================================;
//
//  THIS CODE AND INFORMATION IS PROVIDED "AS IS" WITHOUT WARRANTY OF ANY
//  KIND, EITHER EXPRESSED OR IMPLIED, INCLUDING BUT NOT LIMITED TO THE
//  IMPLIED WARRANTIES OF MERCHANTABILITY AND/OR FITNESS FOR A PARTICULAR
//  PURPOSE.
//
//  File: tldbsrc.cpp
//
//  Copyright (c) Microsoft Corporation.  All Rights Reserved.
//
//@@@@AUTOBLOCK-============================================================;

#include <streams.h>
#include "stdafx.h"
#include "tldb.h"
#include "..\..\..\filters\h\ftype.h"
#include "..\util\dexmisc.h"
#include <strsafe.h>

const int OUR_MAX_STREAM_SIZE = 2048; // chosen at random

//############################################################################
// 
//############################################################################

CAMTimelineSrc::CAMTimelineSrc
    ( TCHAR *pName, LPUNKNOWN pUnk, HRESULT * phr )
    : CAMTimelineObj( pName, pUnk, phr )
    , m_rtMediaStart( 0 )
    , m_rtMediaStop( 0 )
    , m_rtMediaLength( 0 )
    , m_nStreamNumber( 0 )
    , m_dDefaultFPS( 0.0 )	// ???
    , m_nStretchMode( RESIZEF_STRETCH )	// what kind of stretch to do?
    , m_szMediaName( NULL )
{
    m_TimelineType = TIMELINE_MAJOR_TYPE_SOURCE;
    m_ClassID = CLSID_AMTimelineSrc;
    m_bIsRecompressable = FALSE;
    m_bToldIsRecompressable = FALSE;
}

//############################################################################
// 
//############################################################################

CAMTimelineSrc::~CAMTimelineSrc( )
{
    if( m_szMediaName )
    {
        delete [] m_szMediaName;
    }
}

//############################################################################
// 
//############################################################################

STDMETHODIMP CAMTimelineSrc::NonDelegatingQueryInterface
    (REFIID riid, void **ppv)
{
    if( riid == IID_IAMTimelineSrc )
    {
        return GetInterface( (IAMTimelineSrc*) this, ppv );
    }
    if( riid == IID_IAMTimelineSrcPriv )
    {
        return GetInterface( (IAMTimelineSrcPriv*) this, ppv );
    }
    if( riid == IID_IAMTimelineSplittable )
    {
        return GetInterface( (IAMTimelineSplittable*) this, ppv );
    }
    if( riid == IID_IAMTimelineEffectable )
    {
        return GetInterface( (IAMTimelineEffectable*) this, ppv );
    }
    return CAMTimelineObj::NonDelegatingQueryInterface( riid, ppv );
}

//############################################################################
// return the media times this source runs at.
//############################################################################

STDMETHODIMP CAMTimelineSrc::GetMediaTimes2
    (REFTIME * pStart, REFTIME * pStop)
{
    REFERENCE_TIME p1 = DoubleToRT( *pStart );
    REFERENCE_TIME p2 = DoubleToRT( *pStop );
    HRESULT hr = GetMediaTimes( &p1, &p2 );
    *pStart = RTtoDouble( p1 );
    *pStop = RTtoDouble( p2 );
    return hr;
}

STDMETHODIMP CAMTimelineSrc::GetMediaTimes
    (REFERENCE_TIME * pStart, REFERENCE_TIME * pStop)
{
    CheckPointer( pStart, E_POINTER );
    CheckPointer( pStop, E_POINTER );

    *pStart = m_rtMediaStart;
    *pStop = m_rtMediaStop;

    return NOERROR;
}

//############################################################################
// 
//############################################################################

STDMETHODIMP CAMTimelineSrc::FixMediaTimes2
    (REFTIME * pStart, REFTIME * pStop)
{
    REFERENCE_TIME p1 = DoubleToRT( *pStart );
    REFERENCE_TIME p2 = DoubleToRT( *pStop );
    HRESULT hr = FixMediaTimes( &p1, &p2 );
    *pStart = RTtoDouble( p1 );
    *pStop = RTtoDouble( p2 );
    return hr;
}

STDMETHODIMP CAMTimelineSrc::FixMediaTimes
    (REFERENCE_TIME * pStart, REFERENCE_TIME * pStop)
{
    CheckPointer( pStart, E_POINTER );
    CheckPointer( pStop, E_POINTER );

    // first stuff 'em, like a vegetarian gourmet eggplant dish.
    //
    REFERENCE_TIME MediaStart = *pStart;
    REFERENCE_TIME MediaStop = *pStop;
    REFERENCE_TIME MediaLen = MediaStop - MediaStart;

    // If the regular start/stop times of this clip weren't on a frame boundary,
    // they are also fixed up like we did above.  But now we need to fix the
    // media times to still be in the same ratio to the start/stop times as
    // they were before either of them was fixed up, or we've changed the 
    // behaviour.  eg:  timeline time .45 to .9 is media time 0 to .45
    // The movie is 5fps.  Timeline times wil be fixed up to (.4,1) and media
    // times will be fixed up to (0,.4)  Uh oh!  They're not the same length
    // like they used to be!  So we need to make the media times .6 long like
    // the timeline times so we don't think we're stretching the video

    // We're aligning to the OUTPUT frame rate of the timeline, not
    // the source's frame rate. We could bump the media stop time beyond
    // the source's length. We should account for this

    // get the times and fix them up
    //
    REFERENCE_TIME NewStart = m_rtStart;
    REFERENCE_TIME NewStop = m_rtStop;
    GetStartStop(&NewStart, &NewStop);
    FixTimes( &NewStart, &NewStop );

        REFERENCE_TIME Len;    // len of fixed up media times
        if (m_rtStop - m_rtStart == MediaLen) 
        {
            // I don't trust FP to get this result in the else case
            Len = NewStop - NewStart;
        } 
        else 
        {
            Len = (REFERENCE_TIME)((double)(NewStop - NewStart) *
                            MediaLen / (m_rtStop - m_rtStart));
        }

    // We have to be careful when growing the media times to be in the right
    // ratio to the timeline times, because we don't want to make the start
    // get < 0, or the stop be > the movie length (which we don't know).
    // So we'll grow by moving the start back, until it hits 0, in which case
    // we'll grow the stop too, but hopefully this cannot cause a problem
    // because we're fudging by at most one output frame length, so the
    // switch should get all the frames it needs.
    if( Len > MediaLen ) // we're growing media times (dangerous)
    {   
        if ( MediaStop  - Len >= 0 ) 
        {
            *pStart = MediaStop - Len;
        } 
        else 
        {
            *pStart = 0;
            MediaStop = Len;
        }
    } 
    else 
    {
	MediaStop = MediaStart + Len;
    }

    // make sure stop doesn't go over, if there is a length.
    //
    if( m_rtMediaLength && ( MediaStop > m_rtMediaLength ) )
    {
        MediaStop = m_rtMediaLength;
    }

    *pStop = MediaStop;

    return NOERROR;

}

//############################################################################
// ask for the name that's been stored in here.
//############################################################################

STDMETHODIMP CAMTimelineSrc::GetMediaName
    (BSTR * pVal)
{
    CheckPointer( pVal, E_POINTER );

    // return a blank (nothing in it) string if nothing loaded
    if( _NullName( ) )
    {
        *pVal = SysAllocString( L"" );
    }
    else
    {
        *pVal = SysAllocString( m_szMediaName ); // safe, bounded
    }

    if( !(*pVal) ) return E_OUTOFMEMORY;

    return NOERROR;
}

//############################################################################
// NOTE: If a sub-COM object is being used as a media source (like within a 
// graph), changing this string will NOT change the actual clip that this
// source refers to. You're only changing a NAME, not the real clip. This
// name placeholder functionality is here for convenience purposes and if this
    // is too confusing, will be removed.
//############################################################################

STDMETHODIMP CAMTimelineSrc::SetMediaName
    (BSTR newVal)
{
    // if they're different, then bump the genid, so something that's caching
    // us can tell we changed. If the input name is unbounded, the comparison
    // will run off the end of the page and fault, which is okay
    //
    if( !_NullName( ) && ( wcscmp( m_szMediaName, newVal ) == 0 ) ) // safe, barely
    {
        return NOERROR;
    }

    // validate the path is limited, and doesn't have funny characters in it
    // *do not* validate the file really exists, because it may be fixed up later
    //
    HRESULT hr = ValidateFilename( newVal, MAX_PATH, FALSE, FALSE );

    // get the length
    size_t len = 0;
    hr = StringCchLength( newVal, _MAX_PATH, &len );
    if( FAILED( hr ) )
    {
        return hr;
    }
    len++; // terminator character

    // allocate space for new name
    if( m_szMediaName ) delete [] m_szMediaName;
    m_szMediaName = new WCHAR[len];
    if( !m_szMediaName )
    {
        return E_OUTOFMEMORY;
    }

    // blow the cache
    _BumpGenID( );

    // no recompress knowledge if we change source
    ClearAnyKnowledgeOfRecompressability( );

    // copy it, this should not fail
    hr = StringCchCopy( m_szMediaName, len, newVal );
    return hr;
}

//############################################################################
// 
//############################################################################

STDMETHODIMP CAMTimelineSrc::SpliceWithNext
    (IAMTimelineObj * pNext)
{
    HRESULT hr = 0;

    CheckPointer( pNext, E_POINTER );

    CComQIPtr<IAMTimelineSrc, &IID_IAMTimelineSrc> p( pNext );
    if( !p )
    {
        return E_NOINTERFACE;
    }

    BSTR NextName;
    hr = p->GetMediaName( &NextName );
    if( FAILED( hr ) )
    {
        return hr;
    }
    if( _NullName( ) )
    {
        SysFreeString( NextName );
        return E_INVALIDARG;
    }
    // both strings are valid
    hr = NOERROR;
    if( wcscmp( NextName, m_szMediaName ) != 0 )
    {
        SysFreeString( NextName );
        return E_INVALIDARG;
    }
    SysFreeString( NextName );

    REFERENCE_TIME NextStart, NextStop;
    CComQIPtr<IAMTimelineObj, &IID_IAMTimelineObj> pNextBase( pNext );
    
    hr = pNextBase->GetStartStop( &NextStart, &NextStop );
    if( FAILED( hr ) )
    {
        return hr;
    }

    if( NextStart != m_rtStop )
    {
        return E_INVALIDARG;
    }

    // get the next guy's stop time
    //
    REFERENCE_TIME NextMediaStart, NextMediaStop;
    p->GetMediaTimes( &NextMediaStart, &NextMediaStop );

    // compare our rate to the next guy's rate. We need to be the same
    //
    double OurRate = double( m_rtMediaStop - m_rtMediaStart ) / double( m_rtStop - m_rtStart );
    double NextRate = double( NextMediaStop - NextMediaStart ) / double( NextStop - NextStart );
    double absv = NextRate - OurRate;
    if( absv < 0.0 )
    {
        absv *= -1.0;
    }
    // have to be close by 10 percent?
    if( absv > NextRate / 10.0 )
    {
        return E_INVALIDARG;
    }

    // set our times to the same thing
    //
    m_rtMediaStop = NextMediaStop;
    m_rtStop = NextStop;

    // we're dirty (and so's our parent)
    //
    SetDirtyRange( m_rtStart, m_rtStop );

    // remove the next guy from the tree, he's outta there! Switch around the
    // insert modes, so we don't move stuff on the remove
    //
    IAMTimeline * pRoot = NULL; // okay not CComPtr2
    GetTimelineNoRef( &pRoot );
    ASSERT( pRoot );
    hr = pNextBase->RemoveAll( );

    // !!! what about 2nd clip's effects it had on it? Need to add them to the first

    return hr;
}

//############################################################################
// 
//############################################################################

STDMETHODIMP CAMTimelineSrc::SetMediaTimes2
    (REFTIME Start, REFTIME Stop)
{
    REFERENCE_TIME p1 = DoubleToRT( Start );
    REFERENCE_TIME p2 = DoubleToRT( Stop );
    HRESULT hr = SetMediaTimes( p1, p2 );
    return hr;
}

STDMETHODIMP CAMTimelineSrc::SetMediaTimes
    (REFERENCE_TIME Start, REFERENCE_TIME Stop)
{

    if (Stop < Start)
        return E_INVALIDARG;

    // if a duration is set, make sure we don't go past it
    //
    if( m_rtMediaLength )
    {
        if( Stop > m_rtMediaLength )
        {
            Stop = m_rtMediaLength;
        }
    }

    // don't bump genid - this will ruin the cache
    // don't blow recompressability - IsNormallyRated will do

    m_rtMediaStart = Start;
    m_rtMediaStop = Stop;

    return NOERROR;
}

#include "..\render\dexhelp.h"

//############################################################################
// 
//############################################################################

STDMETHODIMP CAMTimelineSrc::GetStreamNumber(long * pVal)
{
    CheckPointer( pVal, E_POINTER );

    *pVal = m_nStreamNumber;
    return NOERROR;
}

//############################################################################
// 
//############################################################################

STDMETHODIMP CAMTimelineSrc::SetStreamNumber(long Val)
{
    if (Val < 0)
	return E_INVALIDARG;

    // user is reponsible for making sure this is valid
    //
    m_nStreamNumber = Val;

    ClearAnyKnowledgeOfRecompressability( );

    return NOERROR;
}


//############################################################################
// 
//############################################################################

// If a source can't figure out its frames per second, this number
// will be used (eg: Dib sequences)
// AVI, MPEG, etc. will not need this
//
STDMETHODIMP CAMTimelineSrc::GetDefaultFPS(double *pFPS)
{
    CheckPointer(pFPS, E_POINTER);
    *pFPS = m_dDefaultFPS;
    return NOERROR;
}


STDMETHODIMP CAMTimelineSrc::SetDefaultFPS(double FPS)
{
    // 0.0 means do not allow dib sequences
    if (FPS < 0.0)
	return E_INVALIDARG;
    m_dDefaultFPS = FPS;
    return NOERROR;
}


//############################################################################
// 
//############################################################################

// If this source needs to be stretched, how should it be stretched?
// The choices are RESIZEF_STRETCH, RESIZEF_CROP, and
// RESIZEF_PRESERVEASPECTRATIO.
//
STDMETHODIMP CAMTimelineSrc::GetStretchMode(int *pnStretchMode)
{
    CheckPointer(pnStretchMode, E_POINTER);
    *pnStretchMode = m_nStretchMode;
    return NOERROR;
}

//############################################################################
// 
//############################################################################

STDMETHODIMP CAMTimelineSrc::SetStretchMode(BOOL nStretchMode)
{
    m_nStretchMode = nStretchMode;
    return NOERROR;
}

//############################################################################
// user is reponsible for setting this right
//############################################################################

STDMETHODIMP CAMTimelineSrc::SetMediaLength2(REFTIME Length)
{
    REFERENCE_TIME dummy = DoubleToRT( Length );
    HRESULT hr = SetMediaLength( dummy );
    return hr;
}

STDMETHODIMP CAMTimelineSrc::SetMediaLength(REFERENCE_TIME Length)
{
    m_rtMediaLength = Length;
    return NOERROR;
}

//############################################################################
// 
//############################################################################

STDMETHODIMP CAMTimelineSrc::GetMediaLength2(REFTIME * pLength)
{
    CheckPointer( pLength, E_POINTER );
    *pLength = 0.0;
    if( !m_rtMediaLength )
    {
        return E_NOTDETERMINED;
    }
    *pLength = RTtoDouble( m_rtMediaLength );
    return NOERROR;
}

STDMETHODIMP CAMTimelineSrc::GetMediaLength(REFERENCE_TIME * pLength)
{
    CheckPointer( pLength, E_POINTER );
    *pLength = 0;
    if( !m_rtMediaLength )
    {
        return E_NOTDETERMINED;
    }
    *pLength = m_rtMediaLength;
    return NOERROR;
}

//############################################################################
// 
//############################################################################

STDMETHODIMP CAMTimelineSrc::ModifyStopTime2(REFTIME Stop)
{
    REFERENCE_TIME t1 = DoubleToRT( Stop );
    return ModifyStopTime( t1 );
}

STDMETHODIMP CAMTimelineSrc::ModifyStopTime(REFERENCE_TIME Stop)
{
    return SetStartStop( m_rtStart, Stop );
}

//############################################################################
// 
//############################################################################

STDMETHODIMP CAMTimelineSrc::SplitAt2( REFTIME t )
{
    REFERENCE_TIME t1 = DoubleToRT( t );
    return SplitAt( t1 );
}

STDMETHODIMP CAMTimelineSrc::SplitAt( REFERENCE_TIME SplitTime )
{
    // is our split time withIN our time?
    //
    if( SplitTime <= m_rtStart || SplitTime >= m_rtStop )
    {
        return E_INVALIDARG;
    }

    IAMTimelineObj * pTrack = NULL;
    XGetParentNoRef( &pTrack );
    if( !pTrack )
    {
        return E_INVALIDARG;
    }
    CComQIPtr< IAMTimelineNode, &IID_IAMTimelineNode > pTrackNode( pTrack );

    // create the shell
    //
    HRESULT hr = 0;
    CAMTimelineSrc * pNewSrc = new CAMTimelineSrc( NAME("Timeline Source"), NULL, &hr );
    if( !pNewSrc )
    {
        return E_OUTOFMEMORY;
    }

    // we have created an object that has NO references on it. If we call ANYTHING that
    // addreffs and releases the pNewSrc, it will be deleted. So addref it NOW.

    pNewSrc->AddRef( );

    hr = CopyDataTo( pNewSrc, SplitTime );
    if( FAILED( hr ) )
    {
        delete pNewSrc;
        return hr;
    }

    double dMediaRate = (double) (m_rtMediaStop - m_rtMediaStart) / (m_rtStop - m_rtStart);

    pNewSrc->m_rtStart = SplitTime;
    pNewSrc->m_rtStop = m_rtStop;
    // first clip end = new timeline time of first clip * rate
    pNewSrc->m_rtMediaStart = m_rtMediaStart + (REFERENCE_TIME)((SplitTime - m_rtStart) * dMediaRate);
    // second clip starts where first ends
    pNewSrc->m_rtMediaStop = m_rtMediaStop;

    m_rtStop = SplitTime;
    m_rtMediaStop = pNewSrc->m_rtMediaStart;

    if( !_NullName( ) )
    {
        // need to allocate a BSTR to pass into a function that takes a BSTR.
        // technically, we shouldn't have to do this, since we don't count
        // on it being a BSTR, but this is cleaner

        BSTR bMediaName = SysAllocString(m_szMediaName);
        if (bMediaName)
        {
            hr = pNewSrc->SetMediaName( bMediaName );
            SysFreeString(bMediaName);
        }
        else 
        {
            hr = E_OUTOFMEMORY;
        }
    }
    if( FAILED( hr ) )
    {
        pNewSrc->Release( );
        delete pNewSrc;
        return hr;
    }

    // get the src's parent
    //
    hr = pTrackNode->XInsertKidAfterKid( pNewSrc, this );

    // if it took or not, we can still release our local pNewSrc ref
    //
    pNewSrc->Release( );

    if( FAILED( hr ) )
    {
        delete pNewSrc;
        return hr;
    }

    // we need to adjust SplitTime so that it's relative to the start of this clip
    // before splitting effects up
    //
    SplitTime -= m_rtStart;

    // split all the effects. 
    //
    CComPtr< IAMTimelineObj > pEffect;
    long EffectCount = 0;
    hr = EffectGetCount( &EffectCount );
    for( int i = 0 ; i < EffectCount ; i++ )
    {
        CComPtr< IAMTimelineObj > p;
        HRESULT hr = GetEffect( &p, i );
        
        REFERENCE_TIME s,e;
        p->GetStartStop( &s, &e );

        // if the end time is less than our split time, it's completely
        // out of bounds, ignore it
        //
        if( e <= SplitTime )
        {
            p.Release( );
            continue;
        }

        // if it's start time is equal to or greater than our split time,
        // it's completely out of bounds, ignore it. Plus, we're done searching.
        //
        if( s >= SplitTime )
        {
            p.Release( );
            break;
        }

        CComQIPtr< IAMTimelineSplittable, &IID_IAMTimelineSplittable > pSplittable( p );
        hr = pSplittable->SplitAt( SplitTime );
        if( FAILED( hr ) )
        {
            // right in the middle of it all, it FAILED! What now?
            //
            return hr;
        }

        break; // found one to split, we're done
    }

    return hr;
}

//############################################################################
// 
//############################################################################

STDMETHODIMP CAMTimelineSrc::SetIsRecompressable( BOOL Val )
{
    m_bIsRecompressable = Val;
    m_bToldIsRecompressable = TRUE;
    return NOERROR;
}

//############################################################################
// 
//############################################################################

STDMETHODIMP CAMTimelineSrc::GetIsRecompressable( BOOL * pVal )
{
    CheckPointer( pVal, E_POINTER );
    if( !m_bToldIsRecompressable )
    {
        *pVal = FALSE;
        return S_FALSE;
    }
    *pVal = m_bIsRecompressable;
    return NOERROR;
}

//############################################################################
// 
//############################################################################

STDMETHODIMP CAMTimelineSrc::ClearAnyKnowledgeOfRecompressability( )
{
    m_bToldIsRecompressable = FALSE;
    m_bIsRecompressable = FALSE;
    return NOERROR;
}

//############################################################################
// 
//############################################################################

STDMETHODIMP CAMTimelineSrc::IsNormalRate( BOOL * pVal )
{
    CheckPointer( pVal, E_POINTER );

    REFERENCE_TIME MediaLen = m_rtMediaStop - m_rtMediaStart;
    REFERENCE_TIME TLlen = m_rtStop - m_rtStart;
    if( TLlen != MediaLen )
    {
        *pVal = FALSE;
        return NOERROR;
    }

    *pVal = TRUE;
    return NOERROR;
}

//############################################################################
// 
//############################################################################

STDMETHODIMP CAMTimelineSrc::SetStartStop( REFERENCE_TIME Start, REFERENCE_TIME Stop )
{
    // don't bump genid - this will ruin the cache
    // don't blow recompressability - IsNormallyRated will do
    return CAMTimelineObj::SetStartStop( Start, Stop );
}
=== C:/Users/treeman/Desktop/windows nt source code\Source\Win2K3\NT\multimedia\dshow\filterus\dexter\util\jpegfuncs.cpp ===
//@@@@AUTOBLOCK+============================================================;
//
//  THIS CODE AND INFORMATION IS PROVIDED "AS IS" WITHOUT WARRANTY OF ANY
//  KIND, EITHER EXPRESSED OR IMPLIED, INCLUDING BUT NOT LIMITED TO THE
//  IMPLIED WARRANTIES OF MERCHANTABILITY AND/OR FITNESS FOR A PARTICULAR
//  PURPOSE.
//
//  File: jpegfuncs.cpp
//
//  Copyright (c) Microsoft Corporation.  All Rights Reserved.
//
//@@@@AUTOBLOCK-============================================================;

#include "jpegfuncs.h"
#include <vfwmsgs.h>

HRESULT ConvertStatustoHR (Status stat)
{
    
    switch (stat)
    {
        case Ok:
            return S_OK;
        case GenericError:
        case ObjectBusy:
        case ValueOverflow:
            return E_FAIL;
        case InvalidParameter:
        case InsufficientBuffer:
            return E_INVALIDARG;
        case OutOfMemory:
            return E_OUTOFMEMORY;
        case NotImplemented:
            return E_NOTIMPL;
        case WrongState:
            return VFW_E_WRONG_STATE;
        case Aborted:
            return E_ABORT;
        case FileNotFound:
            return STG_E_FILENOTFOUND;
        case AccessDenied:
            return E_ACCESSDENIED;
        case UnknownImageFormat:
            return VFW_E_INVALID_FILE_FORMAT;
        default:
            return E_FAIL;
    }
}
=== C:/Users/treeman/Desktop/windows nt source code\Source\Win2K3\NT\multimedia\dshow\filterus\dexter\util\dexmisc.h ===
//@@@@AUTOBLOCK+============================================================;
//
//  THIS CODE AND INFORMATION IS PROVIDED "AS IS" WITHOUT WARRANTY OF ANY
//  KIND, EITHER EXPRESSED OR IMPLIED, INCLUDING BUT NOT LIMITED TO THE
//  IMPLIED WARRANTIES OF MERCHANTABILITY AND/OR FITNESS FOR A PARTICULAR
//  PURPOSE.
//
//  File: dexmisc.h
//
//  Copyright (c) Microsoft Corporation.  All Rights Reserved.
//
//@@@@AUTOBLOCK-============================================================;

#define US_ENGLISH  MAKELCID(MAKELANGID(LANG_ENGLISH, SUBLANG_ENGLISH_US), SORT_DEFAULT)
#define DexCompare(a, b) (CompareString(US_ENGLISH, NORM_IGNORECASE, a, -1, b, -1) != CSTR_EQUAL)
#ifdef UNICODE
    #define DexCompareW(a, b) (CompareStringW(US_ENGLISH, NORM_IGNORECASE, a, -1, b, -1) != CSTR_EQUAL)
#else
    #define DexCompareW(a, b) lstrcmpiW(a, b)
#endif

#define US_LCID MAKELCID(MAKELANGID(LANG_ENGLISH, SUBLANG_ENGLISH_US), SORT_DEFAULT)

BOOL DexCompareWN( WCHAR * psz1, const WCHAR * psz2 );

HRESULT FindCompressor( AM_MEDIA_TYPE * pUncompType, AM_MEDIA_TYPE * pCompType, IBaseFilter ** ppCompressor, IServiceProvider * pKeyProvider );

HRESULT ValidateFilename(WCHAR * pFilename, size_t MaxCharacters, BOOL bNewFile, BOOL FileShouldExist = TRUE );
HRESULT ValidateFilenameIsntNULL( const WCHAR * pFilename );

HRESULT VarChngTypeHelper( VARIANT * pvarDest, VARIANT * pvarSrc, VARTYPE vt );

HRESULT _TimelineError(IAMTimeline * pTimeline,
                       long Severity,
                       LONG ErrorCode,
                       HRESULT hresult,
                       VARIANT * pExtraInfo = NULL);
=== C:/Users/treeman/Desktop/windows nt source code\Source\Win2K3\NT\multimedia\dshow\filterus\dexter\util\dexmisc.cpp ===
//@@@@AUTOBLOCK+============================================================;
//
//  THIS CODE AND INFORMATION IS PROVIDED "AS IS" WITHOUT WARRANTY OF ANY
//  KIND, EITHER EXPRESSED OR IMPLIED, INCLUDING BUT NOT LIMITED TO THE
//  IMPLIED WARRANTIES OF MERCHANTABILITY AND/OR FITNESS FOR A PARTICULAR
//  PURPOSE.
//
//  File: dexmisc.cpp
//
//  Copyright (c) Microsoft Corporation.  All Rights Reserved.
//
//@@@@AUTOBLOCK-============================================================;

#include <streams.h>
#include <atlbase.h>
#include <qeditint.h>
#include "filfuncs.h"
#include "dexmisc.h"
#define STRSAFE_NO_DEPRECATE
#include <strsafe.h>



// we used to find FourCC-matching compressors first, which was bad because it was finding the Windows Media ICM compressor before
// finding the Windows Media DMO. So now we look for the FourCC compressors LAST, which of course, incurs a perf-hit.
// oh well
HRESULT FindCompressor( AM_MEDIA_TYPE * pUncompType, AM_MEDIA_TYPE * pCompType, IBaseFilter ** ppCompressor, IServiceProvider * pKeyProvider )
{
    HRESULT hr = 0;

    CheckPointer( pUncompType, E_POINTER );
    CheckPointer( pCompType, E_POINTER );
    CheckPointer( ppCompressor, E_POINTER );

    // preset it to nothing
    //
    *ppCompressor = NULL;

    // !!! can we assume we'll always get a video compressor for now?
    //
    if( pUncompType->majortype != MEDIATYPE_Video )
    {
        return E_INVALIDARG;
    }

    // since we rely on videoinfo below, make sure it's videoinfo here!
    if( pUncompType->formattype != FORMAT_VideoInfo )
    {
	return VFW_E_INVALID_MEDIA_TYPE;
    }

    // get the FourCC out of the media type
    //
    VIDEOINFOHEADER * pVIH = (VIDEOINFOHEADER*) pCompType->pbFormat;

    DWORD WantedFourCC = FourCCtoUpper( pVIH->bmiHeader.biCompression );

    // enumerate all compressors and find one that matches
    //
    CComPtr< ICreateDevEnum > pCreateDevEnum;
    hr = CoCreateInstance(
        CLSID_SystemDeviceEnum, 
        NULL, 
        CLSCTX_INPROC_SERVER,
        IID_ICreateDevEnum, 
        (void**) &pCreateDevEnum );
    if( FAILED( hr ) )
    {
        return hr;
    }

    CComPtr< IEnumMoniker > pEm;
    hr = pCreateDevEnum->CreateClassEnumerator( CLSID_VideoCompressorCategory, &pEm, 0 );
     if( !pEm )
    {
        if( hr == S_FALSE )
        {
            return VFW_E_NO_ACCEPTABLE_TYPES;
        }
        return hr;
    }

    // --- first, we'll go through and enumerate friendly filters which provide FourCC's
    // --- first, we'll go through and enumerate friendly filters which provide FourCC's
    // --- first, we'll go through and enumerate friendly filters which provide FourCC's
    // --- first, we'll go through and enumerate friendly filters which provide FourCC's

    ULONG cFetched;
    CComPtr< IMoniker > pM;

    // --- Put each compressor in a graph and test it
    // --- Put each compressor in a graph and test it
    // --- Put each compressor in a graph and test it
    // --- Put each compressor in a graph and test it

    // create a graph
    //
    CComPtr< IGraphBuilder > pGraph;
    hr = CoCreateInstance(
        CLSID_FilterGraph,
        NULL,
        CLSCTX_INPROC_SERVER,
        IID_IGraphBuilder,
        (void**) &pGraph );
    if( FAILED( hr ) )
    {
        return hr;
    }

    if( pKeyProvider )
    {
        // unlock the graph
        CComQIPtr< IObjectWithSite, &IID_IObjectWithSite > pOWS( pGraph );
        ASSERT( pOWS );
        if( pOWS )
        {
            pOWS->SetSite( pKeyProvider );
        }
    }

    // create a black source to hook up
    //
    CComPtr< IBaseFilter > pSource;
    hr = CoCreateInstance(
        CLSID_GenBlkVid,
        NULL,
        CLSCTX_INPROC_SERVER,
        IID_IBaseFilter,
        (void**) &pSource );
    if( FAILED( hr ) )
    {
        return hr;
    }
    hr = pGraph->AddFilter( pSource, NULL );
    if( FAILED( hr ) )
    {
        return hr;
    }
    IPin * pSourcePin = GetOutPin( pSource, 0 );
    if( !pSourcePin )
    {
        return E_FAIL;
    }

    CComQIPtr< IDexterSequencer, &IID_IDexterSequencer > pDexSeq( pSourcePin );
    hr = pDexSeq->put_MediaType( pUncompType );
    if( FAILED( hr ) )
    {
        return hr;
    }

    pEm->Reset();
    while( 1 )
    {
        pM.Release( );
        hr = pEm->Next( 1, &pM, &cFetched );
        if( hr != S_OK ) break;

        DWORD MatchFourCC = 0;

        CComPtr< IPropertyBag > pBag;
	hr = pM->BindToStorage(0, 0, IID_IPropertyBag, (void **)&pBag);
        if( FAILED( hr ) )
        {
            continue;
        }

	VARIANT var;
        VariantInit( &var );
	var.vt = VT_BSTR;
	hr = pBag->Read(L"FriendlyName", &var, NULL);
        if( FAILED( hr ) )
        {
            continue;
        }
        VariantClear( &var );

        // found a compressor, see if it's the right type
        //
        VARIANT var2;
        VariantInit( &var2 );
        var2.vt = VT_BSTR;
        HRESULT hrHandler = pBag->Read( L"FccHandler", &var2, NULL );
        if( hrHandler == NOERROR )
        {
            // hey! found a FourCC! Look at that instead!

            // convert the bstr to a TCHAR
            //
            USES_CONVERSION;
            TCHAR * pTCC = W2T( var2.bstrVal );
            MatchFourCC = FourCCtoUpper( *((DWORD*)pTCC) ); // YUCK!
            VariantClear( &var2 );

            if( MatchFourCC == WantedFourCC )
            {
                // found it.
                //
                hr = pM->BindToObject(0, 0, IID_IBaseFilter,
							(void**)ppCompressor );
                if( !FAILED( hr ) )
                {
                    // nothing left to free up, we can return now.
                    //
                    pGraph->RemoveFilter( pSource );
                    return hr;
                }
	    }

            // we don't care, we already looked here
            //
            continue;
        }

        // didn't find a FourCC handler, oh well
        
        CComPtr< IBaseFilter > pFilter;
        hr = pM->BindToObject(0, 0, IID_IBaseFilter, (void**) &pFilter );
        if( FAILED( hr ) )
        {
            continue;
        }

        // put the filter in the graph and connect up it's input pin
        //
        hr = pGraph->AddFilter( pFilter, NULL );
        if( FAILED( hr ) )
        {
            continue;
        }

        IPin * pInPin = GetInPin( pFilter, 0 );
        if( !pInPin )
        {
            continue;
        }

        IPin * pOutPin = GetOutPin( pFilter, 0 );
        if( !pOutPin )
        {
            continue;
        }

        hr = pGraph->Connect( pSourcePin, pInPin );
        if( FAILED( hr ) )
        {
            pGraph->RemoveFilter( pFilter );
            continue;
        }

        CComPtr< IEnumMediaTypes > pEnum;
        pOutPin->EnumMediaTypes( &pEnum );
        if( pEnum )
        {
            DWORD Fetched = 0;
            while( 1 )
            {
                AM_MEDIA_TYPE * pOutPinMediaType = NULL;
                Fetched = 0;
                pEnum->Next( 1, &pOutPinMediaType, &Fetched );
                if( ( Fetched == 0 ) || ( pOutPinMediaType == NULL ) )
                {
                    break;
                }

                if( pOutPinMediaType->majortype == pCompType->majortype )
                if( pOutPinMediaType->subtype   == pCompType->subtype )
                if( pOutPinMediaType->formattype == pCompType->formattype )
                {
                    // !!! if we change the rules for SetSmartRecompressFormat on the group,
                    // this may not be a VIDEOINFOHEADER at all!
                    //
                    VIDEOINFOHEADER * pVIH2 = (VIDEOINFOHEADER*) pOutPinMediaType->pbFormat;
                    MatchFourCC = FourCCtoUpper( pVIH2->bmiHeader.biCompression );

                } // if formats match

                DeleteMediaType( pOutPinMediaType );

                if( MatchFourCC )
                {
                    break;
                }

            } // while 1

        } // if pEnum

	// connect may have put intermediate filters in.  Destroy them all
        RemoveChain(pSourcePin, pInPin);
	// remove the codec that didn't work
        pGraph->RemoveFilter( pFilter );

        if( MatchFourCC && MatchFourCC == WantedFourCC )
        {
            // found it.
            //
            hr = pM->BindToObject(0, 0, IID_IBaseFilter, (void**) ppCompressor );
            if( !FAILED( hr ) )
            {
                break;
            }
        }

    } // while trying to insert filters into a graph and look at their FourCC

    // remove the black source now
    //
    pGraph->RemoveFilter( pSource );

    // return now if we found one
    //
    if( *ppCompressor )
    {
        return NOERROR;
    }

    // no compressor. Darn.
    return E_FAIL; 
}

inline BOOL CheckFilenameBeginning (WCHAR *pFilename)
{    
    // Local Files
    if ((pFilename[2] == L'\\') &&
        (pFilename[1] == L':') &&
        (((pFilename[0] >= 'A') && (pFilename[0] <= 'Z')) ||
         ((pFilename[0] >= 'a') && (pFilename[0] <= 'z'))))
    {
        //
        // a-z:\ path
        // A-Z:\ path
        //
        return TRUE;
    }
    // Network Shares
    else if ((pFilename[0] == L'\\') && (pFilename[1] == L'\\'))
 
    {
        return TRUE;
    }

    return FALSE;


}

HRESULT ValidateFilename(WCHAR * pFilename, size_t MaxCharacters, BOOL bNewFile, BOOL bFileShouldExist )
// bNewFile is true if this is a file we will create (output file)
{
    HRESULT hr;

    hr = ValidateFilenameIsntNULL( pFilename );
    ASSERT( !FAILED( hr ) );
    if( FAILED( hr ) )
    {
        return hr;
    }

    // first test to ensure pathname is something reasonable
    size_t OutLen = 0;
    hr = StringCchLengthW( (WCHAR*) pFilename, MaxCharacters, &OutLen );
    ASSERT( !FAILED( hr ) );
    if( FAILED( hr ) )
    {
        // string too long
        return hr;
    }

    // canonicalize it
    // Maybe use CUrl in future if it is ported to this tree

    // don't allow really shorty filenames
    //
    if (OutLen < 3)
    {
        // Too Short
        ASSERT( 0 );
        return HRESULT_FROM_WIN32( ERROR_INVALID_NAME ); 
    }

    // don't allow extra long names (why not?)
    //
    if (wcsncmp(pFilename, L"\\\\?", 3) == 0)
    {
        ASSERT( 0 );
        return HRESULT_FROM_WIN32( ERROR_INVALID_NAME ); 
    }

    // see if the file has a safe beginning
    BOOL safePath = CheckFilenameBeginning(pFilename);

    WCHAR  wszNewFilename [ MAX_PATH] = {0};

    if( !safePath )
    {
        // add the current directory in
        //
        DWORD result = GetCurrentDirectory( MAX_PATH, wszNewFilename );
        // result = 0, didnt' work
        // result = MAX_PATH = not allowed
        // result = MAX_PATH - 1, buffer was fully used up
        // retult 
        if( result >= MAX_PATH )
        {
            ASSERT( 0 );
            return STRSAFE_E_INSUFFICIENT_BUFFER;
        }
        hr = StringCchCatW( wszNewFilename, MAX_PATH, L"\\" );
        if( FAILED( hr ) )
        {
            return hr;
        }
        hr = StringCchCatW( wszNewFilename, MAX_PATH, pFilename );
        if( FAILED( hr ) )
        {
            return hr;
        }

        safePath = CheckFilenameBeginning(wszNewFilename);
        if( !safePath )
        {
            ASSERT( 0 );
            return HRESULT_FROM_WIN32( ERROR_SEEK_ON_DEVICE );
        }
    }
    else
    {
        // pFilename could be longer than max path, so check the error
        hr = StringCchCopyW(wszNewFilename, MAX_PATH, pFilename);
        ASSERT( !FAILED( hr ) );
        if( FAILED( hr ) )
        {
            return hr;
        }
    }

    // are there any invalid characters in there
    // We'll check everything other than the first 2 characters
    // Any problems there would already have been caught.

    const WCHAR* wIllegalChars = L"/:*?\"<>|";
    if (wcspbrk(wszNewFilename+2, wIllegalChars) != NULL)
    {
        ASSERT( 0 );
        return HRESULT_FROM_WIN32( ERROR_INVALID_NAME ); 
    }

    // if the file should exist, or we're creating a file,
    // then test for it. Otherwise, we're done

    if( bFileShouldExist || bNewFile )
    {
        HANDLE hFile;
        // Is this a device?
        // We will query the file with CreateFile.  We're not opening the file actually so this
        // is cheap
        if (!bNewFile)
        {
            hFile = CreateFile(wszNewFilename,0,0, NULL, OPEN_EXISTING, 0, NULL);
        }
        else
        {
            // A bit expensive, but thats the cost of security.
            // This whole function shouldn't be called often enough to affect performance.
            hFile = CreateFile(wszNewFilename,0,0,NULL, CREATE_ALWAYS, FILE_FLAG_DELETE_ON_CLOSE,NULL);
        }

        if (hFile == INVALID_HANDLE_VALUE)
        {
            return HRESULT_FROM_WIN32( GetLastError( ) ); 
        }
        else if (GetFileType (hFile) != FILE_TYPE_DISK)
        {
            ASSERT( 0 );
            CloseHandle(hFile);
            return HRESULT_FROM_WIN32( ERROR_SEEK_ON_DEVICE );
        }
        else
        {
            // Done with handle
            CloseHandle(hFile);
        }
    }

    return NOERROR;
}

HRESULT ValidateFilenameIsntNULL( const WCHAR * pFilename )
{
    if( !pFilename ) return STRSAFE_E_INSUFFICIENT_BUFFER;
    if( pFilename[0] == 0 ) return STRSAFE_E_INSUFFICIENT_BUFFER;
    return NOERROR;
}

HRESULT _TimelineError(IAMTimeline * pTimeline,
                       long Severity,
                       LONG ErrorCode,
                       HRESULT hresult,
                       VARIANT * pExtraInfo )
{
    HRESULT hr = hresult;
    if( pTimeline )
    {
            CComQIPtr< IAMSetErrorLog, &IID_IAMSetErrorLog > pTimelineLog( pTimeline );
            if( pTimelineLog )
            {
                CComPtr< IAMErrorLog > pErrorLog;
                pTimelineLog->get_ErrorLog( &pErrorLog );
                if( pErrorLog )
                {
        	    TCHAR tBuffer[256];
        	    tBuffer[0] = 0;
        	    LoadString( g_hInst, ErrorCode, tBuffer, 256 ); // sec: make sure this worked
        	    USES_CONVERSION;
        	    WCHAR * w = T2W( tBuffer );
		    if (hresult == E_OUTOFMEMORY)
                        hr = pErrorLog->LogError( Severity, L"Out of memory",
				DEX_IDS_OUTOFMEMORY, hresult, pExtraInfo);
		    else
                        hr = pErrorLog->LogError( Severity, w, ErrorCode,
							hresult, pExtraInfo);
                }
            }
    }

    return hr;
}

HRESULT VarChngTypeHelper(
    VARIANT * pvarDest, VARIANT * pvarSrc, VARTYPE vt)
{
    // our implementation doesn't handle this case and is not
    // currently used that way.
    ASSERT(pvarDest != pvarSrc);
    ASSERT(pvarDest->vt == VT_EMPTY); 
    
    // force US_LCID so that .xtl parsing is independent of different
    // numerical separators in different locales (?)
    // 
    HRESULT hr = VariantChangeTypeEx(pvarDest, pvarSrc, US_LCID, 0, vt);
    if(SUCCEEDED(hr)) {
        return hr;
    }

    // we need to parse hex strings. The NT VCTE() implementation does
    // not, but the WinME one does.
    if(vt == VT_R8 && pvarSrc->vt == VT_BSTR)
    {
        // wcstoul can be used even if not implemented on win9x
        // because we only care about NT if we got here.
        //
        WCHAR *pchLast;
        ULONG ulHexVal = wcstoul(pvarSrc->bstrVal, &pchLast, 16);
        // ulHexVal might be 0 or 0xffffffff on failure or success. We
        // can't test the global errno to determine what happened
        // because it's not thread safe. But we should have ended up
        // at the null terminator if the whole string was parsed; that
        // should catch some errors at least.

        if(*pchLast == 0 && lstrlenW(pvarSrc->bstrVal) <= 10)
        {
            pvarDest->vt = VT_R8;
            V_R8(pvarDest) = ulHexVal;
            hr = S_OK;
        }
        else
        {
            hr = DISP_E_TYPEMISMATCH;
        }
    }

    return hr;
}
=== C:/Users/treeman/Desktop/windows nt source code\Source\Win2K3\NT\multimedia\dshow\filterus\dexter\xmltl\resource.h ===
// Copyright (c) 1999  Microsoft Corporation.  All Rights Reserved.
//{{NO_DEPENDENCIES}}
// Microsoft Developer Studio generated include file.
//
#define IDR_XML2DEX                     198

// Next default values for new objects
// 
#ifdef APSTUDIO_INVOKED
#ifndef APSTUDIO_READONLY_SYMBOLS
#define _APS_NEXT_RESOURCE_VALUE        201
#define _APS_NEXT_COMMAND_VALUE         32768
#define _APS_NEXT_CONTROL_VALUE         201
#define _APS_NEXT_SYMED_VALUE           102
#endif
#endif
=== C:/Users/treeman/Desktop/windows nt source code\Source\Win2K3\NT\multimedia\dshow\filterus\dexter\util\filfuncs.h ===
//@@@@AUTOBLOCK+============================================================;
//
//  THIS CODE AND INFORMATION IS PROVIDED "AS IS" WITHOUT WARRANTY OF ANY
//  KIND, EITHER EXPRESSED OR IMPLIED, INCLUDING BUT NOT LIMITED TO THE
//  IMPLIED WARRANTIES OF MERCHANTABILITY AND/OR FITNESS FOR A PARTICULAR
//  PURPOSE.
//
//  File: filfuncs.h
//
//  Copyright (c) Microsoft Corporation.  All Rights Reserved.
//
//@@@@AUTOBLOCK-============================================================;

#include <streams.h>

// NONE of these functions will addref the returned pointers! ! ! !
HRESULT CopyMediaType( CMediaType * pDest, const AM_MEDIA_TYPE * pSource );
HRESULT CopyMediaType( CMediaType * pDest, const CMediaType * pSource );
void SaferFreeMediaType( AM_MEDIA_TYPE &mt );
DWORD FourCCtoUpper( DWORD u );
IPin * GetInPin( IBaseFilter * pFilter, int PinNum );
IPin * GetOutPin( IBaseFilter * pFilter, int PinNum );
IPin * GetOutPinNotOfType( IBaseFilter * pFilter, int PinNum, GUID* );
long GetPinCount( IBaseFilter * pFilter, PIN_DIRECTION pindir );
void RemoveChain( IPin * pPin1, IPin * pPin2 );
IBaseFilter * GetStartFilterOfChain( IPin * pPin );
IBaseFilter * GetStopFilterOfChain( IPin * pPin );
IBaseFilter * GetNextDownstreamFilter( IBaseFilter * pFilter );
IBaseFilter * GetNextUpstreamFilter( IBaseFilter * pFilter );
BOOL IsInputPin( IPin * pPin );
HRESULT StartUpstreamFromPin(IPin *pPinIn, BOOL fRun, BOOL fHeadToo);
HRESULT StartUpstreamFromFilter(IBaseFilter *pf, BOOL fRun, BOOL fHeadToo, REFERENCE_TIME RunTime = 0 );
HRESULT StopUpstreamFromPin(IPin *pPinIn, BOOL fPause, BOOL fHeadToo);
HRESULT StopUpstreamFromFilter(IBaseFilter *pf, BOOL fPause, BOOL fHeadToo);
HRESULT RemoveUpstreamFromPin(IPin *pPinIn);
HRESULT RemoveDownstreamFromPin(IPin *pPinIn);
HRESULT RemoveUpstreamFromFilter(IBaseFilter *pf);
HRESULT RemoveDownstreamFromFilter(IBaseFilter *pf);
HRESULT WipeOutGraph( IGraphBuilder * pGraph );
HRESULT CheckGraph( IGraphBuilder * pGraph );
HRESULT ReconnectToDifferentSourcePin(IGraphBuilder *pGraph,
                                      IBaseFilter *pUnkFilter, 
                                      long StreamNumber, 
                                      const GUID *pGuid );
long    GetFilterGenID( IBaseFilter * pFilter );
void GetFilterName( long UniqueID, WCHAR * pSuffix, WCHAR * pNameToWriteTo, long SizeOfString );
IBaseFilter * FindFilterWithInterfaceUpstream( IBaseFilter * pFilter, const GUID * pInterface );
IUnknown * FindPinInterfaceUpstream( IBaseFilter * pFilter, const GUID * pInterface );
HRESULT DisconnectFilters( IBaseFilter * p1, IBaseFilter * p2 );
HRESULT DisconnectFilter( IBaseFilter * p1 );
void * FindInterfaceUpstream( IBaseFilter * pFilter, const GUID * pInterface );
IBaseFilter * GetFilterFromPin( IPin * pPin );
IFilterGraph * GetFilterGraphFromPin( IPin * pPin );
IFilterGraph * GetFilterGraphFromFilter( IBaseFilter * );
HRESULT FindMediaTypeInChain( 
                             IBaseFilter * pSource, 
                             AM_MEDIA_TYPE * pFindMediaType, 
                             long StreamNumber );

BOOL AreMediaTypesCompatible( AM_MEDIA_TYPE * pType1, AM_MEDIA_TYPE * pType2 );

HRESULT FindFirstPinWithMediaType( IPin ** ppPin, IPin * pEndPin, GUID MajorType );

BOOL DoesPinHaveMajorType( IPin * pPin, GUID MajorType );
HRESULT FindCompressor( AM_MEDIA_TYPE * pType, 
                        AM_MEDIA_TYPE * pCompType, 
                        IBaseFilter ** ppCompressor, 
                        IServiceProvider * pKeyProvider = NULL );
HRESULT DisconnectExtraAppendage(IBaseFilter *, GUID *, IBaseFilter *, IBaseFilter **);
IPin * FindOtherSplitterPin(IPin *pPinIn, GUID guid, int StreamNumber );

class DbgTimer
{
#ifdef DEBUG
    char m_Text[256];
    long m_Level;
    long m_StartTime;
#endif
    
public:

    DbgTimer( char * pText, long Level = 1 )
    {
#ifdef DEBUG
        strcpy( m_Text, "DEXTIME:" );
        strcat( m_Text, pText );
        strcat( m_Text, " = %ld ms" );
        m_Level = Level;
        m_StartTime = timeGetTime( );
#endif
    };
    ~DbgTimer( )
    {
#ifdef DEBUG
        DbgLog( ( LOG_TIMING, m_Level, m_Text, timeGetTime( ) - m_StartTime ) );
//#else
//        char temp[256];
//        wsprintf(temp, m_Text, timeGetTime( ) - m_StartTime);
//       strcat(temp, "\r\n");
//        OutputDebugString(temp);
#endif
    }
};
=== C:/Users/treeman/Desktop/windows nt source code\Source\Win2K3\NT\multimedia\dshow\filterus\dexter\util\jpegfuncs.h ===
//@@@@AUTOBLOCK+============================================================;
//
//  THIS CODE AND INFORMATION IS PROVIDED "AS IS" WITHOUT WARRANTY OF ANY
//  KIND, EITHER EXPRESSED OR IMPLIED, INCLUDING BUT NOT LIMITED TO THE
//  IMPLIED WARRANTIES OF MERCHANTABILITY AND/OR FITNESS FOR A PARTICULAR
//  PURPOSE.
//
//  File: jpegfuncs.h
//
//  Copyright (c) Microsoft Corporation.  All Rights Reserved.
//
//@@@@AUTOBLOCK-============================================================;

#ifndef _JPEGFUNCS_H_
#define _JPEGFUNCS_H_

#include <windows.h>
#include <gdiplus.h>

using namespace Gdiplus;

HRESULT ConvertStatustoHR (Status stat);



#endif
=== C:/Users/treeman/Desktop/windows nt source code\Source\Win2K3\NT\multimedia\dshow\filterus\dexter\util\filfuncs.cpp ===
//@@@@AUTOBLOCK+============================================================;
//
//  THIS CODE AND INFORMATION IS PROVIDED "AS IS" WITHOUT WARRANTY OF ANY
//  KIND, EITHER EXPRESSED OR IMPLIED, INCLUDING BUT NOT LIMITED TO THE
//  IMPLIED WARRANTIES OF MERCHANTABILITY AND/OR FITNESS FOR A PARTICULAR
//  PURPOSE.
//
//  File: filfuncs.cpp
//
//  Copyright (c) Microsoft Corporation.  All Rights Reserved.
//
//@@@@AUTOBLOCK-============================================================;

#include <streams.h>
#include <atlbase.h>
#include <initguid.h>
#include "filfuncs.h"
#define STRSAFE_NO_DEPRECATE
#include <strsafe.h>

DEFINE_GUID( CLSID_Indeo5, 0x1F73E9B1, 0x8C3A, 0x11d0, 0xA3, 0xBE, 0x00, 0xa0, 0xc9, 0x24, 0x44, 0x36 );

// ensure the media type we're stuffing to doesn't already have something in it
// can't do this when the dest is a AM_MEDIA_TYPE, because it's not guaranteed to have nothing in it
//
HRESULT CopyMediaType( CMediaType * pDest, const AM_MEDIA_TYPE * pSource )
{
    CheckPointer( pDest, E_POINTER );
    CheckPointer( pSource, E_POINTER );

    // free up the old memory first
    //
    if( pDest->pbFormat )
    {
	ASSERT( 0 ); // sec: remove this before final checkin!
        DbgLog( ( LOG_ERROR, 0, "CopyMediaTypeSafer: Somebody forgot to free up old memory!" ) );

        CoTaskMemFree( (PVOID) pDest->pbFormat);
        pDest->pbFormat = NULL;
    }
    else
    {
        ASSERT( pDest->cbFormat == 0 );
    }
    pDest->cbFormat = 0;

    // don't take off the cast, or we'll call ourselves and stack fault!
    return CopyMediaType( (AM_MEDIA_TYPE*) pDest, pSource );
}

HRESULT CopyMediaType( CMediaType * pDest, const CMediaType * pSource )
{
    CheckPointer( pDest, E_POINTER );
    CheckPointer( pSource, E_POINTER );

    // free up the old memory first
    //
    ASSERT( !pDest->pbFormat );
    ASSERT( !pDest->cbFormat );

    if( pDest->pbFormat )
    {
        DbgLog( ( LOG_ERROR, 0, "CopyMediaTypeSafer: Somebody forgot to free up old memory!" ) );

        CoTaskMemFree( (PVOID) pDest->pbFormat);
        pDest->pbFormat = NULL;
    }
    pDest->cbFormat = 0;

    // don't take off the cast, or we'll call ourselves and stack fault!
    return CopyMediaType( (AM_MEDIA_TYPE*) pDest, pSource );
}

void SaferFreeMediaType(AM_MEDIA_TYPE & mt)
{
    if (mt.pbFormat != 0) {
        CoTaskMemFree((PVOID)mt.pbFormat);
        mt.pbFormat = NULL;
    }
    mt.cbFormat = 0;
    if (mt.pUnk != NULL) {
        mt.pUnk->Release();
        mt.pUnk = NULL;
    }
}

IPin * GetInPin( IBaseFilter * pFilter, int PinNum )
{
    IEnumPins * pEnum = 0;
    pFilter->EnumPins( &pEnum );
    pEnum->Reset( );
    ULONG Fetched;
    do
    {
        Fetched = 0;
        IPin * pPin = 0;
        pEnum->Next( 1, &pPin, &Fetched );
        if( Fetched )
        {
            PIN_DIRECTION pd;
            pPin->QueryDirection( &pd);
            pPin->Release( );
            if( pd == PINDIR_INPUT )
            {
                if( PinNum == 0 )
                {
                    pEnum->Release( );
                    return pPin;
                }
                PinNum--;
            }
        }
    }
    while( Fetched );
    pEnum->Release( );
    return NULL;
}

IPin * GetOutPin( IBaseFilter * pFilter, int PinNum )
{
    IEnumPins * pEnum = 0;
    pFilter->EnumPins( &pEnum );
    pEnum->Reset( );
    ULONG Fetched;
    do
    {
        Fetched = 0;
        IPin * pPin = 0;
        pEnum->Next( 1, &pPin, &Fetched );
        if( Fetched )
        {
            PIN_DIRECTION pd;
            pPin->QueryDirection( &pd);
            pPin->Release( );
            if( pd == PINDIR_OUTPUT )
            {
                if( PinNum == 0 )
                {
                    pEnum->Release( );
                    return pPin;
                }
                PinNum--;
            }
        }
    }
    while( Fetched );
    pEnum->Release( );
    return NULL;
}

// I only want output pins NOT of this major type
//
IPin * GetOutPinNotOfType( IBaseFilter * pFilter, int PinNum, GUID * type )
{
    IEnumPins * pEnum = 0;
    pFilter->EnumPins( &pEnum );
    pEnum->Reset( );
    ULONG Fetched;
    do
    {
        Fetched = 0;
        IPin * pPin = 0;
        pEnum->Next( 1, &pPin, &Fetched );
        if( Fetched )
        {
            pPin->Release( );
            PIN_INFO pi;
            pPin->QueryPinInfo( &pi );
            if( pi.pFilter ) pi.pFilter->Release( );
            if( pi.dir == PINDIR_OUTPUT )
            {
                CComPtr <IEnumMediaTypes> pMediaEnum;
	        AM_MEDIA_TYPE *pMediaType;
                pPin->EnumMediaTypes(&pMediaEnum);
                if (!pMediaEnum ) continue;
                ULONG tFetched = 0;
                pMediaEnum->Next(1, &pMediaType, &tFetched);
                if (!tFetched) continue;
                if (pMediaType->majortype == *type)  {
                    DeleteMediaType(pMediaType);
                    continue;	// NOT YOU!
                }
                DeleteMediaType(pMediaType);                
                if (PinNum == 0)
                {
                    pEnum->Release( );
                    return pPin;
                }
                PinNum--;
            }
        }
    }
    while( Fetched );
    pEnum->Release( );
    return NULL;
}

// this will remove everything from the graph, NOT including
// the filters of pPin1 and pPin2
//
void RemoveChain( IPin * pPin1, IPin * pPin2 )
{
    HRESULT hr = 0;

    // find the pin that our output is connected to, this
    // will be on the "next" filter
    //
    CComPtr< IPin > pDownstreamInPin;
    pPin1->ConnectedTo( &pDownstreamInPin );
    if( !pDownstreamInPin )
    {
        return;
    }

    // if the connected to is the same as the pPin2, then we
    // have reached the LAST two connected pins, so just
    // disconnect them
    //
    if( pDownstreamInPin == pPin2 )
    {
        pPin1->Disconnect( );
        pPin2->Disconnect( );

        return;
    }
    
    // ask that pin for it's info, so we know what filter
    // it's on
    //
    PIN_INFO PinInfo;
    ZeroMemory( &PinInfo, sizeof( PinInfo ) );
    pDownstreamInPin->QueryPinInfo( &PinInfo );
    if( !PinInfo.pFilter )
    {
        return;
    }

    // find a pin enumerator on the downstream filter, so we
    // can find IT'S connected output pin
    //
    CComPtr< IEnumPins > pPinEnum;
    PinInfo.pFilter->EnumPins( &pPinEnum );
    PinInfo.pFilter->Release( );
    if( !pPinEnum )
    {
        // error condition, but we'll continue anyhow. This should never happen
        //
        ASSERT( pPinEnum );
        return;
    }

    // go look for the first connected output pin
    //
    while( 1 )
    {
        CComPtr< IPin > pPin;
        ULONG Fetched = 0;
        hr = pPinEnum->Next( 1, &pPin, &Fetched );
        if( hr != 0 )
        {
            ASSERT( hr != 0 );
            break;
        }

        PIN_INFO PinInfo2;
        ZeroMemory( &PinInfo2, sizeof( PinInfo2 ) );
        pPin->QueryPinInfo( &PinInfo2 );
        if( !PinInfo2.pFilter )
        {
            // error condition, but we'll continue anyhow. This should never happen
            //
            ASSERT( PinInfo2.pFilter );
            continue;
        }

        if( PinInfo2.dir == PINDIR_OUTPUT )
        {
            CComPtr< IPin > pConnected;
            pPin->ConnectedTo( &pConnected );
            if( !pConnected )
            {
                continue;
            }

            // we found a connected output pin, so
            // recursively call Remove( ) on those two...
            //
            RemoveChain( pPin, pPin2 );

            // then disconnect the upper two...
            //
            pPin1->Disconnect( );
            pDownstreamInPin->Disconnect( );

            // then remove the filter from the graph..
            //
            FILTER_INFO FilterInfo;
            PinInfo2.pFilter->QueryFilterInfo( &FilterInfo );
            hr  = FilterInfo.pGraph->RemoveFilter( PinInfo2.pFilter );
            FilterInfo.pGraph->Release( );

            // and release our refcount! The filter should go away now
            //
            PinInfo2.pFilter->Release( );

            return;
        }

        PinInfo2.pFilter->Release( );
    }

    // nothing to do here. It should in fact, never get here
    //
    ASSERT( 0 );
}

// Pause or Run (fRun) each filter walking upstream from pPinIn (taking all
//      upstream branches)
// Optionally change the state of the filter at the head of the chains (filters
//      without input pins)
//
HRESULT StartUpstreamFromPin(IPin *pPinIn, BOOL fRun, BOOL fHeadToo)
{
    CComPtr< IPin > pPin;
    HRESULT hr = pPinIn->ConnectedTo(&pPin);

    if (pPin == NULL) {
        // not connected, we don't need to follow further
        return S_OK;
    }
    
    PIN_INFO pinfo;
    
    hr = pPin->QueryPinInfo(&pinfo);
    if (FAILED(hr))
        return hr;

    FILTER_STATE State;

    hr = pinfo.pFilter->GetState(0, &State);

    if (FAILED(hr)) {
        DbgLog((LOG_ERROR, 1, "pFilter->GetState returned %x, I'm confused", hr));
        pinfo.pFilter->Release();
        return E_FAIL;
    }

    hr = StartUpstreamFromFilter(pinfo.pFilter, fRun, fHeadToo);

    pinfo.pFilter->Release();

    return hr;
}

// Run or Pause (fRun) this filter, unless it has no input pins and we don't
//     want to change the state of the head filter (fHeadToo)
// Continue upstream of all input pins
//
HRESULT StartUpstreamFromFilter(IBaseFilter *pf, BOOL fRun, BOOL fHeadToo, REFERENCE_TIME RunTime )
{
    HRESULT hr;

    DbgLog((LOG_TRACE, 2, "  StartUpstreamFromFilter(%x, %d)", pf, fRun));

    // has this filter been started yet? Don't start it now, we don't know yet
    // if we're supposed to
    BOOL fStarted = FALSE;

    CComPtr< IEnumPins > pEnum;
    hr = pf->EnumPins(&pEnum);
    if (FAILED(hr)) {
        DbgLog((LOG_ERROR, 1, "Filter %x failed EnumPins, hr = %x", pf, hr));
    } else {

        for (;;) {

            ULONG ulActual;
            CComPtr< IPin > aPin;

            hr = pEnum->Next(1, &aPin, &ulActual);
            if (hr != S_OK) {       // no more pins
                hr = S_FALSE;
                break;
            }
            
            PIN_DIRECTION pd;
            hr = aPin->QueryDirection(&pd);

            if (hr == S_OK && pd == PINDIR_INPUT) {

                // start this filter if it hasn't been yet.  It's not the head
                // filter, it has input pins
                //
                if (fStarted == FALSE) {
                    fStarted = TRUE;
                    if (fRun) {
                        hr = pf->Run(RunTime);
                    } else {
                        hr = pf->Pause();
                    }
                    if (FAILED(hr)) {
                        DbgLog((LOG_ERROR, 1, "Filter %x failed %hs, hr = %x", pf, fRun ? "run" : "pause", hr));
                    }
                }

                // recurse upstream of each input pin
                if (SUCCEEDED(hr)) {
                    hr = StartUpstreamFromPin(aPin, fRun, fHeadToo);
                }
            }

            if (FAILED(hr))
                break;
        }

        if (hr == S_FALSE) {
            DbgLog((LOG_TRACE, 2, "  Successfully dealt with all pins of filter %x", pf));
            hr = S_OK;

            // start this filter (if the head filter of the chain is 
            // supposed to be started) If it isn't started yet, it has no inputs
            if (fHeadToo && fStarted == FALSE) {
                fStarted = TRUE;
                if (fRun) {
                    hr = pf->Run(RunTime);
                } else {
                    hr = pf->Pause();
                }
                if (FAILED(hr)) {
                    DbgLog((LOG_ERROR, 1, "Filter %x failed %hs, hr = %x", pf, fRun ? "run" : "pause", hr));
                }
            }
        }
    }

    DbgLog((LOG_TRACE, 2, "  StartUpstreamFromFilter(%x, %d) returning %x", pf, fRun, hr));
    
    return hr;
}


// Pause or Stop (fPause) each filter walking upstream from pPinIn (taking all
//      upstream branches)
// Optionally change the state of the filter at the head of the chains (filters
//      without input pins)
//
HRESULT StopUpstreamFromPin(IPin *pPinIn, BOOL fPause, BOOL fHeadToo)
{
    CComPtr< IPin > pPin;
    HRESULT hr = pPinIn->ConnectedTo(&pPin);

    if (pPin == NULL) {
        // not connected, we don't need to follow further
        return S_OK;
    }
    
    PIN_INFO pinfo;
    
    hr = pPin->QueryPinInfo(&pinfo);
    if (FAILED(hr))
        return hr;

    hr = StopUpstreamFromFilter(pinfo.pFilter, fPause, fHeadToo);

    pinfo.pFilter->Release();
    
    return hr;
}

// Pause or Stop (fPause) this filter, unless it has no input pins and we don't
//     want to change the state of the head filter (fHeadToo)
// Continue upstream of all input pins
//
HRESULT StopUpstreamFromFilter(IBaseFilter *pf, BOOL fPause, BOOL fHeadToo)
{
    HRESULT hr = S_OK;

    DbgLog((LOG_TRACE, 2, "  StopUpstreamFromFilter(%x)", pf));

    // has this filter been stopped yet?  Don't stop it now, we don't yet know
    // if we're supposed to
    BOOL fStopped = FALSE;
    
    CComPtr< IEnumPins > pEnum;
    hr = pf->EnumPins(&pEnum);
    if (FAILED(hr)) {
        DbgLog((LOG_ERROR,1,"Filter %x failed EnumPins, hr = %x", pf, hr));
    } else {

        for (;;) {

            ULONG       ulActual;
            CComPtr< IPin > aPin;

            hr = pEnum->Next(1, &aPin, &ulActual);
            if (hr != S_OK) {       // no more pins
                hr = S_FALSE;
                break;
            }

            PIN_DIRECTION pd;
            hr = aPin->QueryDirection(&pd);

            if (hr == S_OK && pd == PINDIR_INPUT) {

                // There is an input pin.  this is not the head of the chain
                // so we can stop this filter now, if it hasn't been yet
                if (!fStopped) {
                    DbgLog((LOG_TRACE, 3, "about to %hs Filter %x",
                                    fPause ? "pause" : "stop", pf));
                    fStopped = TRUE;
                    if (fPause) {
                        hr = pf->Pause();
                    } else {
                        hr = pf->Stop();
                    }
                    if (FAILED(hr)) {
                        DbgLog((LOG_ERROR,1,"Filter %x failed %hs, hr = %x", pf,
                                        fPause ? "pause" : "stop", hr));
                    }
                }

                hr = StopUpstreamFromPin(aPin, fPause, fHeadToo);
            }

            if (FAILED(hr))
                break;
        }

        if (hr == S_FALSE) {
            DbgLog((LOG_TRACE,5,"Successfully dealt with all pins of filter %x", pf));
            hr = S_OK;

            // start this filter (if the head filter is supposed to be
            // started) If it isn't started yet, it has no inputs
            if (!fStopped && fHeadToo) {
                DbgLog((LOG_TRACE,3,"about to %hs Filter %x",
                                    fPause ? "pause" : "stop", pf));
                fStopped = TRUE;
                if (fPause) {
                    hr = pf->Pause();
                } else {
                    hr = pf->Stop();
                }
                if (FAILED(hr)) {
                    DbgLog((LOG_ERROR,1,"Filter %x failed %hs, hr = %x", pf,
                                     fPause ? "pause" : "stop", hr));
                }
            }
        }
    }

    DbgLog((LOG_TRACE, 2, "  StopUpstreamFromFilter(%x) returning %x", pf, hr));
    
    return hr;
}


//----------------------------------------------------------------------------
// Remove anything that is upstream of this pin from the graph.
//----------------------------------------------------------------------------

HRESULT RemoveUpstreamFromPin(IPin *pPinIn)
{
    DbgLog((LOG_TRACE, 2, "  RemoveUpstreamFromPin(%x)", pPinIn));

    CComPtr< IPin > pPin;
    HRESULT hr = pPinIn->ConnectedTo(&pPin);

    if (pPin == NULL) {
        // not connected, we don't need to follow further
        return S_OK;
    }
    
    PIN_INFO pinfo;
    
    hr = pPin->QueryPinInfo(&pinfo);

    if (FAILED(hr))
        return hr;

    hr = RemoveUpstreamFromFilter(pinfo.pFilter);
    
    pinfo.pFilter->Release();
        
    return hr;
}


//----------------------------------------------------------------------------
// Remove anything that is downstream of this pin from the graph.
//----------------------------------------------------------------------------

HRESULT RemoveDownstreamFromPin(IPin *pPinIn)
{
    DbgLog((LOG_TRACE, 2, "  RemoveDownstreamFromPin(%x)", pPinIn));

    CComPtr< IPin > pPin;
    HRESULT hr = pPinIn->ConnectedTo(&pPin);

    if (pPin == NULL) {
        // not connected, we don't need to follow further
        return S_OK;
    }
    
    PIN_INFO pinfo;
    
    hr = pPin->QueryPinInfo(&pinfo);

    if (FAILED(hr))
        return hr;

    hr = RemoveDownstreamFromFilter(pinfo.pFilter);
    
    pinfo.pFilter->Release();
        
    return hr;
}


//----------------------------------------------------------------------------
// Remove anything that is upstream of this filter from the graph.
//----------------------------------------------------------------------------

HRESULT RemoveUpstreamFromFilter(IBaseFilter *pf)
{
    DbgLog((LOG_TRACE, 2, "  RemoveUpstreamFromFilter(%x)", pf));

    HRESULT hr;

    // do this function on all pins on this filter
    CComPtr< IEnumPins > pEnum;
    hr = pf->EnumPins(&pEnum);
    if (FAILED(hr)) {
        DbgLog((LOG_ERROR, 1, "Filter %x failed EnumPins, hr = %x", pf, hr));
    } else {

        // for each pin on this filter
        for (;;) {

            ULONG ulActual = 0;
            CComPtr< IPin > aPin;

            hr = pEnum->Next(1, &aPin, &ulActual);
            if (hr != S_OK) {       // no more pins
                hr = S_FALSE;
                break;
            }

            // ask for the pin direction
            PIN_DIRECTION pd;
            hr = aPin->QueryDirection(&pd);

            // if it's an input pin, then remove anything upstream of it
            if (hr == S_OK && pd == PINDIR_INPUT) {
                hr = RemoveUpstreamFromPin(aPin);
            }

            if (FAILED(hr))
                break;
        }

        if (hr == S_FALSE) {
            DbgLog((LOG_TRACE, 2, "Successfully dealt with all pins of filter %x", pf));
            hr = S_OK;
        }
    }

    // removed all upstream pins of this filter, now remove this filter from
    // the graph as well
    if (SUCCEEDED(hr)) {
        FILTER_INFO fi;
        pf->QueryFilterInfo( &fi );
        if( fi.pGraph )
        {
            hr = fi.pGraph->RemoveFilter( pf );
            fi.pGraph->Release( );
        }

        ASSERT(SUCCEEDED(hr));

        if (FAILED(hr)) {
            DbgLog((LOG_ERROR, 1, "error removing Filter %x, hr = %x", pf, hr));
        }
    }
    
    DbgLog((LOG_TRACE, 2, "  RemoveUpstreamFromFilter(%x) returning %x", pf, hr));
    
    return hr;
}


//----------------------------------------------------------------------------
// Remove anything that is downstream of this filter from the graph.
//----------------------------------------------------------------------------

HRESULT RemoveDownstreamFromFilter(IBaseFilter *pf)
{
    DbgLog((LOG_TRACE, 2, "  RemoveDownstreamFromFilter(%x)", pf));

    HRESULT hr;

    // do this function on all pins on this filter
    CComPtr< IEnumPins > pEnum;
    hr = pf->EnumPins(&pEnum);
    if (FAILED(hr)) {
        DbgLog((LOG_ERROR, 1, "Filter %x failed EnumPins, hr = %x", pf, hr));
    } else {

        // for each pin on this filter
        for (;;) {

            ULONG ulActual = 0;
            CComPtr< IPin > aPin;

            hr = pEnum->Next(1, &aPin, &ulActual);
            if (hr != S_OK) {       // no more pins
                hr = S_FALSE;
                break;
            }

            // ask for the pin direction
            PIN_DIRECTION pd;
            hr = aPin->QueryDirection(&pd);

            // if it's an input pin, then remove anything upstream of it
            if (hr == S_OK && pd == PINDIR_OUTPUT) {
                hr = RemoveDownstreamFromPin(aPin);
            }

            if (FAILED(hr))
                break;
        }

        if (hr == S_FALSE) {
            DbgLog((LOG_TRACE, 2, "Successfully dealt with all pins of filter %x", pf));
            hr = S_OK;
        }
    }

    // removed all downstream pins of this filter, now remove this filter from
    // the graph as well
    if (SUCCEEDED(hr)) {
        FILTER_INFO fi;
        pf->QueryFilterInfo( &fi );
        if( fi.pGraph )
        {
            hr = fi.pGraph->RemoveFilter( pf );
            fi.pGraph->Release( );
        }

        ASSERT(SUCCEEDED(hr));

        if (FAILED(hr)) {
            DbgLog((LOG_ERROR, 1, "error removing Filter %x, hr = %x", pf, hr));
        }
    }
    
    DbgLog((LOG_TRACE, 2, "  RemoveDownstreamFromFilter(%x) returning %x", pf, hr));
    
    return hr;
}


HRESULT WipeOutGraph( IGraphBuilder * pGraph )
{
    USES_CONVERSION;

    if( pGraph )
    {
        CComPtr< IEnumFilters > pEnumFilters;
        pGraph->EnumFilters( &pEnumFilters );
        if( pEnumFilters )
        {
            // remove all filters from the graph
            //
            ULONG Fetched = 0;
            while( 1 )
            {
                CComPtr< IBaseFilter > pFilter;
                Fetched = 0;
                pEnumFilters->Next( 1, &pFilter, &Fetched );
                if( !Fetched )
                {
                    break;
                }

#ifdef DEBUG
                FILTER_INFO fi;
                pFilter->QueryFilterInfo( &fi );
                if( fi.pGraph ) fi.pGraph->Release( );
                TCHAR * t = W2T( fi.achName );
                DbgLog( ( LOG_TRACE, 2, "WipeOutGraph removing filter %s", t ) );
#endif
                pGraph->RemoveFilter( pFilter );
                pEnumFilters->Reset( );
            } // while filters

        } // if enum filters

    } // if pGraph

    return NOERROR;
}

//############################################################################
// This function takes a source filter with an output pin connected already,
// and reconnects a different output pin to the downstream connected filter
// instead. This is because we can't easily pull in a parser for a given
// source filter. It's easier just to connect the first one and diconnect it.
//############################################################################

HRESULT ReconnectToDifferentSourcePin(IGraphBuilder *pGraph, 
                                      IBaseFilter *pUnkFilter, 
                                      long StreamNumber, 
                                      const GUID *pGuid)
{
    HRESULT hr = E_FAIL;

    CComPtr< IBaseFilter > pBaseFilter = pUnkFilter;

    // !!! We assume there will only be one connected pin on each filter (of
    // the mediatype we're interested in) on our search downstream
    
    // look at each downstream filter
    //    
    while( pBaseFilter )
    {
        CComPtr< IEnumPins > pEnumPins;
        pBaseFilter->EnumPins( &pEnumPins );
        if( !pEnumPins )
        {
            break;
        }

        // Walk downstream using the first connected pin of any kind.
	// But if there is a connected pin of type pGuid, stop walking
	// downstream, and see if we need to reconnect what's downstream of
	// that to a different pin of type pGuid
        //
        CComPtr< IBaseFilter > pNextFilter;
        CComPtr< IPin > pConnectedOutPin;
        while( 1 )
        {
            ULONG Fetched = 0;
            CComPtr< IPin > pPin;
            pEnumPins->Next( 1, &pPin, &Fetched );
            if( !Fetched ) break;
            PIN_INFO pi;
            pPin->QueryPinInfo( &pi );
            if( pi.pFilter ) pi.pFilter->Release( );
            if( pi.dir != PINDIR_OUTPUT ) continue;
            CComPtr< IPin > pConnected;
            pPin->ConnectedTo( &pConnected );
            if( !pConnected ) continue;

	    // this is the filter we'll walk downstream to, if we do
            pConnected->QueryPinInfo( &pi );
            pNextFilter = pi.pFilter;
            if( pi.pFilter ) pi.pFilter->Release( );
	    
            CComPtr< IEnumMediaTypes > pMediaEnum;
	    pPin->EnumMediaTypes(&pMediaEnum);
	    if (!pMediaEnum) continue;
	    Fetched = 0;
	    AM_MEDIA_TYPE *pMediaType;
	    pMediaEnum->Next(1, &pMediaType, &Fetched);
	    if (!Fetched) continue;
	    // this is the wrong pin - (wrong mediatype)
	    if (pMediaType->majortype != *pGuid) {
		DeleteMediaType(pMediaType);
		continue;
	    }
	    DeleteMediaType( pMediaType );
            pConnectedOutPin = pPin;
            break; // found it
        }
        pEnumPins->Reset( );

        // we found the first connected output pin, now go through
        // the pins again and count up output types that match the media
        // type we're looking for

        long FoundPins = -1;
	// if we didn't find an outpin of the right type, don't waste time here
        while (pConnectedOutPin) {
            ULONG Fetched = 0;
            CComPtr< IPin > pPin;
            pEnumPins->Next( 1, &pPin, &Fetched );
            if( !Fetched ) break;   // out of pins, done
            PIN_INFO pi;
            pPin->QueryPinInfo( &pi );
            if( pi.pFilter ) pi.pFilter->Release( );
            if( pi.dir != PINDIR_OUTPUT ) continue; // not output pin, continue
            AM_MEDIA_TYPE * pMediaType = NULL;
            CComPtr< IEnumMediaTypes > pMediaEnum;
            pPin->EnumMediaTypes( &pMediaEnum );
            ASSERT( pMediaEnum );
            if( !pMediaEnum ) continue; // no media types on this pin, continue
            Fetched = 0;
            pMediaEnum->Next( 1, &pMediaType, &Fetched );
            if( !Fetched ) continue; // no media types on this pin, continue
            GUID MajorType = pMediaType->majortype;
            DeleteMediaType( pMediaType );
            if( MajorType == *pGuid )
            {
                FoundPins++;
                if( FoundPins == StreamNumber )
                {
                    // found it!
                    
                    // if they're the same pin, we're done
                    //
                    if( pConnectedOutPin == pPin )
                    {
                        return 0;
                    }

                    // disconnect the connected output pin and
                    // reconnect the right output pin
                    //
                    CComPtr< IPin > pDestPin;
                    pConnectedOutPin->ConnectedTo( &pDestPin );
                    RemoveChain( pConnectedOutPin, pDestPin );
                    pConnectedOutPin->Disconnect( );
                    pDestPin->Disconnect( );

                    hr = pGraph->Connect( pPin, pDestPin );

                    return hr;
                } // if we found the pin
            } // if the media type matches
        } // for every pin

        pBaseFilter = pNextFilter;

    } // for each filter

    return VFW_E_UNSUPPORTED_STREAM;
}

IBaseFilter * GetStartFilterOfChain( IPin * pPin )
{
    PIN_INFO ThisPinInfo;
    pPin->QueryPinInfo( &ThisPinInfo );
    if( ThisPinInfo.pFilter ) ThisPinInfo.pFilter->Release( );

    CComPtr< IEnumPins > pEnumPins;
    ThisPinInfo.pFilter->EnumPins( &pEnumPins );
    if( !pEnumPins )
    {
        return NULL;
    }

    // look at every pin on the current filter...
    //
    ULONG Fetched = 0;
    do
    {
        CComPtr< IPin > pPin;
        Fetched = 0;
        ASSERT( !pPin ); // is it out of scope?
        pEnumPins->Next( 1, &pPin, &Fetched );
        if( !Fetched )
        {
            break;
        }

        PIN_INFO pi;
        pPin->QueryPinInfo( &pi );
        if( pi.pFilter ) pi.pFilter->Release( );

        // if it's an input pin...
        //
        if( pi.dir == PINDIR_INPUT )
        {
            // see if it's connected, and if it is...
            //
            CComPtr< IPin > pConnected;
            pPin->ConnectedTo( &pConnected );

            // go return IT'S filter!
            //
            if( pConnected )
            {
                return GetStartFilterOfChain( pConnected );
            }
        }

        // go try the next pin
        
    } while( Fetched > 0 );

    // hey! didn't find any connected input pins, it must be us!
    //
    return ThisPinInfo.pFilter;
}

IBaseFilter * GetStopFilterOfChain( IPin * pPin )
{
    PIN_INFO ThisPinInfo;
    pPin->QueryPinInfo( &ThisPinInfo );
    if( ThisPinInfo.pFilter ) ThisPinInfo.pFilter->Release( );

    CComPtr< IEnumPins > pEnumPins;
    ThisPinInfo.pFilter->EnumPins( &pEnumPins );
    if( !pEnumPins )
    {
        return NULL;
    }

    // look at every pin on the current filter...
    //
    ULONG Fetched = 0;
    do
    {
        CComPtr< IPin > pPin;
        Fetched = 0;
        pPin.Release( );
        pEnumPins->Next( 1, &pPin, &Fetched );
        if( !Fetched )
        {
            break;
        }
        PIN_INFO pi;
        pPin->QueryPinInfo( &pi );
        if( pi.pFilter ) pi.pFilter->Release( );

        // if it's an output pin...
        //
        if( pi.dir == PINDIR_OUTPUT )
        {
            // see if it's connected, and if it is...
            //
            CComPtr< IPin > pConnected;
            pPin->ConnectedTo( &pConnected );

            // go return IT'S filter!
            //
            if( pConnected )
            {
                return GetStopFilterOfChain( pConnected );
            }
        }

        // go try the next pin
        
    } while( Fetched > 0 );

    // hey! didn't find any connected input pins, it must be us!
    //
    return ThisPinInfo.pFilter;
}

IBaseFilter * GetNextDownstreamFilter( IBaseFilter * pFilter )
{
    CComPtr< IEnumPins > pEnumPins;
    pFilter->EnumPins( &pEnumPins );
    if( !pEnumPins )
    {
        return NULL;
    }

    // look at every pin on the current filter...
    //
    ULONG Fetched = 0;
    do
    {
        CComPtr< IPin > pPin;
        Fetched = 0;
        pPin.Release( );
        pEnumPins->Next( 1, &pPin, &Fetched );
        if( !Fetched )
        {
            break;
        }
        PIN_INFO pi;
        pPin->QueryPinInfo( &pi );
        if( pi.pFilter ) pi.pFilter->Release( );

        // if it's an output pin...
        //
        if( pi.dir == PINDIR_OUTPUT )
        {
            // see if it's connected, and if it is...
            //
            CComPtr< IPin > pConnected;
            pPin->ConnectedTo( &pConnected );

            // return that pin's filter
            //
            if( pConnected )
            {
                pConnected->QueryPinInfo( &pi );
                pi.pFilter->Release( );
                return pi.pFilter;
            }
        }

        // go try the next pin
        
    } while( Fetched > 0 );

    return NULL;
}

IBaseFilter * GetNextUpstreamFilter( IBaseFilter * pFilter )
{
    CComPtr< IEnumPins > pEnumPins;
    pFilter->EnumPins( &pEnumPins );
    if( !pEnumPins )
    {
        return NULL;
    }

    // look at every pin on the current filter...
    //
    ULONG Fetched = 0;
    do
    {
        CComPtr< IPin > pPin;
        Fetched = 0;
        pPin.Release( );
        pEnumPins->Next( 1, &pPin, &Fetched );
        if( !Fetched )
        {
            break;
        }
        PIN_INFO pi;
        pPin->QueryPinInfo( &pi );
        if( pi.pFilter ) pi.pFilter->Release( );

        // if it's an output pin...
        //
        if( pi.dir == PINDIR_INPUT )
        {
            // see if it's connected, and if it is...
            //
            CComPtr< IPin > pConnected;
            pPin->ConnectedTo( &pConnected );

            // return that pin's filter
            //
            if( pConnected )
            {
                pConnected->QueryPinInfo( &pi );
                pi.pFilter->Release( );
                return pi.pFilter;
            }
        }

        // go try the next pin
        
    } while( Fetched > 0 );

    return NULL;
}

IFilterGraph * GetFilterGraphFromPin( IPin * pPin )
{
    PIN_INFO pi;
    pPin->QueryPinInfo( &pi );
    if( !pi.pFilter )
    {
        return NULL;
    }

    FILTER_INFO fi;
    pi.pFilter->QueryFilterInfo( &fi );
    pi.pFilter->Release( );
    fi.pGraph->Release( );
    return fi.pGraph;
}

IFilterGraph * GetFilterGraphFromFilter( IBaseFilter * pFilter )
{
    FILTER_INFO fi;
    pFilter->QueryFilterInfo( &fi );
    if( !fi.pGraph ) return NULL;
    fi.pGraph->Release( );
    return fi.pGraph;
}

BOOL IsInputPin( IPin * pPin )
{
    PIN_INFO pi;
    pPin->QueryPinInfo( &pi );
    if( pi.pFilter ) pi.pFilter->Release( );
    return ( pi.dir == PINDIR_INPUT );
}

long GetFilterGenID( IBaseFilter * pFilter )
{
    FILTER_INFO fi;
    pFilter->QueryFilterInfo( &fi );
    if( fi.pGraph ) fi.pGraph->Release( );
    // for it to be a "special" dexter filter in the graph,
    // it's name must conform to a special structure.
    if( wcsncmp( fi.achName, L"DEXFILT", 7 ) != 0 ) // safe because name in string is bigger, and on stack
    {
        return 0;
    }

    // the last 8 digits represent the ID in hex
    //
    long ID = 0;
    for( int i = 0 ; i < 8 ; i++ )
    {
        WCHAR w = fi.achName[7+i];
        int x = w;
        if( x > '9' )
        {
            x -= 7;
        }
        x -= '0';

        ID = ( ID * 16 ) + x;
    }

    return ID;
}

void GetFilterName( long UniqueID, WCHAR * pSuffix, WCHAR * pNameToWriteTo, long SizeOfString /* in characters */ )
{
    // if nothing to write to, or return string is too small,
    // return without doing anything
    if( !pNameToWriteTo || ( SizeOfString < 2 ) ) return;

    // we at least have something to write to, ensure the name has nothing in it
    pNameToWriteTo[0] = 0;
    pNameToWriteTo[1] = 0;

    // return now if we can't even hold the prefix string
    if( SizeOfString < 16 )
        return;

    StringCchCopyW( pNameToWriteTo, SizeOfString, L"DEXFILT" );
    StringCchCatW( pNameToWriteTo, SizeOfString - 7, L"00000000" ); // leave space for unique ID

    // copy in the suffix, truncate if necessary
    if( pSuffix )
    {
        StringCchCatW( pNameToWriteTo, SizeOfString - 15, pSuffix );
    }

    // fill out the uniqueID
    long ID = UniqueID;
    for( int i = 0 ; i < 8 ; i++ )
    {
        long r = ID & 15;
        ID /= 16;
        r += '0';
        if( r > '9' )
        {
            r += 7;
        }
        WCHAR w = WCHAR( r );
        pNameToWriteTo[14-i] = w;
    }
}

IBaseFilter * FindFilterWithInterfaceUpstream( IBaseFilter * pFilter, const GUID * pInterface )
{
    while( pFilter )
    {
        IUnknown * pInt = NULL;
        pFilter->QueryInterface( *pInterface, (void**) &pInt );
        if( pInt )
        {
            pInt->Release( );
            return pFilter;
        }
        pFilter = GetNextUpstreamFilter( pFilter );
    }
    return NULL;
}

void * FindInterfaceUpstream( IBaseFilter * pFilter, const GUID * pInterface )
{
    while( pFilter )
    {
        IUnknown * pInt = NULL;
        pFilter->QueryInterface( *pInterface, (void**) &pInt );
        if( pInt )
        {
            return (void**) pInt;
        }
        pFilter = GetNextUpstreamFilter( pFilter );
    }
    return NULL;
}

IUnknown * FindPinInterfaceUpstream( IBaseFilter * pFilter, const GUID * pInterface )
{
    return NULL;
}

IBaseFilter * GetFilterFromPin( IPin * pPin )
{
    if( !pPin ) return NULL;
    PIN_INFO pi;
    pPin->QueryPinInfo( &pi );
    pi.pFilter->Release( );
    return pi.pFilter;
}

HRESULT DisconnectFilters( IBaseFilter * p1, IBaseFilter * p2 )
{
    CheckPointer( p1, E_POINTER );
    CheckPointer( p2, E_POINTER );

    // enumerate all pins on p1 and if they're connected to p2,
    // disconnect both

    CComPtr< IEnumPins > pEnum;
    p1->EnumPins( &pEnum );
    if( !pEnum )
    {
        return E_NOINTERFACE;
    }

    while( 1 )
    {
        ULONG Fetched = 0;
        CComPtr< IPin > pOutPin;
        pEnum->Next( 1, &pOutPin, &Fetched );
        if( !pOutPin )
        {
            break;
        }
        PIN_INFO OutInfo;
        pOutPin->QueryPinInfo( &OutInfo );
        if( OutInfo.pFilter ) OutInfo.pFilter->Release( );
        if( OutInfo.dir != PINDIR_OUTPUT )
        {
            continue;
        }

        CComPtr< IPin > pInPin;
        pOutPin->ConnectedTo( &pInPin );
        if( pInPin )
        {
            PIN_INFO InInfo;
            pInPin->QueryPinInfo( &InInfo );
            if( InInfo.pFilter ) InInfo.pFilter->Release( );
            if( InInfo.pFilter == p2 )
            {
                pOutPin->Disconnect( );
                pInPin->Disconnect( );
            }
        }
    }
    return NOERROR;
}

HRESULT DisconnectFilter( IBaseFilter * p1 )
{
    CheckPointer( p1, E_POINTER );

    // enumerate all pins on p1 and if they're connected to p2,
    // disconnect both

    CComPtr< IEnumPins > pEnum;
    p1->EnumPins( &pEnum );
    if( !pEnum )
    {
        return E_NOINTERFACE;
    }

    while( 1 )
    {
        ULONG Fetched = 0;
        CComPtr< IPin > pPin;
        pEnum->Next( 1, &pPin, &Fetched );
        if( !pPin )
        {
            break;
        }
        PIN_INFO OutInfo;
        pPin->QueryPinInfo( &OutInfo );
        if( OutInfo.pFilter ) OutInfo.pFilter->Release( );

        CComPtr< IPin > pOtherPin;
        pPin->ConnectedTo( &pOtherPin );
        if( pOtherPin )
        {
            pPin->Disconnect( );
            pOtherPin->Disconnect( );
        }
    }
    return NOERROR;
}

// this function looks for the major type defined in the
// findmediatype until it finds the nth stream which matches
// the media type, then copies the entire media type into the
// passed in struct.
//
HRESULT FindMediaTypeInChain( 
                             IBaseFilter * pSource, 
                             AM_MEDIA_TYPE * pFindMediaType, 
                             long StreamNumber )
{
    CComPtr< IBaseFilter > pBaseFilter = pSource;

    // !!! We assume there
    // will only be one connected pin on each filter as it gets
    // to our destination pin
    
    // look at each downstream filter
    //    
    while( 1 )
    {
        CComPtr< IEnumPins > pEnumPins;
        pBaseFilter->EnumPins( &pEnumPins );
        if( !pEnumPins )
        {
            break;
        }

        // find the first connected output pin and the downstream filter
        // it's connected to
        //
        CComPtr< IBaseFilter > pNextFilter;
        CComPtr< IPin > pConnectedOutPin;
        while( 1 )
        {
            ULONG Fetched = 0;
            CComPtr< IPin > pPin;
            pEnumPins->Next( 1, &pPin, &Fetched );
            if( !Fetched ) break;
            PIN_INFO pi;
            pPin->QueryPinInfo( &pi );
            if( pi.pFilter ) pi.pFilter->Release( );
            if( pi.dir != PINDIR_OUTPUT ) continue;
            CComPtr< IPin > pConnected;
            pPin->ConnectedTo( &pConnected );
            if( !pConnected ) continue;
            pConnected->QueryPinInfo( &pi );
            pNextFilter = pi.pFilter;
            if( pi.pFilter ) pi.pFilter->Release( );
            pConnectedOutPin = pPin;
            break; // found it
        }
        pEnumPins->Reset( );

        // we found the first connected output pin, now go through
        // the pins again and count up output types that match the media
        // type we're looking for

        long FoundPins = -1;
        while( 1 )
        {
            ULONG Fetched = 0;
            CComPtr< IPin > pPin;
            pEnumPins->Next( 1, &pPin, &Fetched );
            if( !Fetched ) break;   // out of pins, done
            PIN_INFO pi;
            pPin->QueryPinInfo( &pi );
            if( pi.pFilter ) pi.pFilter->Release( );
            if( pi.dir != PINDIR_OUTPUT ) continue; // not output pin, continue
            AM_MEDIA_TYPE * pMediaType = NULL;
            CComPtr< IEnumMediaTypes > pMediaEnum;
            pPin->EnumMediaTypes( &pMediaEnum );
            ASSERT( pMediaEnum );
            if( !pMediaEnum ) continue; // no media types on this pin, continue
            Fetched = 0;
            pMediaEnum->Next( 1, &pMediaType, &Fetched );
            if( !Fetched ) continue; // no media types on this pin, continue
            GUID MajorType = pMediaType->majortype;
            if( MajorType == pFindMediaType->majortype )
            {
                FoundPins++;
                if( FoundPins == StreamNumber )
                {
                    // found it! Copy the media type to the
                    // one we passed in

                    HRESULT hr = CopyMediaType( pFindMediaType, pMediaType );

                    DeleteMediaType( pMediaType );

                    return hr;
                    
                } // if we found the pin

            } // if the media type matches

            DeleteMediaType( pMediaType );

        } // for every pin

        pBaseFilter.Release( );
        pBaseFilter = pNextFilter;

    } // for each filter

    return S_FALSE;
}

DWORD FourCCtoUpper( DWORD u )
{
    DWORD t = 0;
    for( int i = 0 ; i < 4 ; i++ )
    {
        int j = ( u & 0xff000000 ) >> 24;
        if( j >= 'a' && j <= 'z' )
        {
            j -= ( 'a' - 'A' );
        }
        t = t * 256 + j;
        u <<= 8;
    }
    return t;
}

// Is the first type acceptable for not needing to be uncompressed, given that
// pTypeNeeded is the format of the project
//
BOOL AreMediaTypesCompatible( AM_MEDIA_TYPE * pType1, AM_MEDIA_TYPE * pTypeNeeded )
{
    if( !pType1 ) return FALSE;
    if( !pTypeNeeded ) return FALSE;

    if( pType1->majortype != pTypeNeeded->majortype )
    {
        return FALSE;
    }

    if( pType1->subtype != pTypeNeeded->subtype )
    {
        return FALSE;
    }

    // how do we compare formattypes? will they always be the same?
    //
    if( pType1->formattype != pTypeNeeded->formattype )
    {
        return FALSE;
    }

    // okay, the formats are the same. NOW what? I guess we'll have to
    // do a switch on the formattype to see if the formats are the same
    //
    if( pType1->formattype == FORMAT_None )
    {
        return TRUE;
    }
    else if( pType1->formattype == FORMAT_VideoInfo )
    {
        VIDEOINFOHEADER * pVIH1 = (VIDEOINFOHEADER*) pType1->pbFormat;
        VIDEOINFOHEADER * pVIH2 = (VIDEOINFOHEADER*) pTypeNeeded->pbFormat;

        if( pVIH1->bmiHeader.biWidth != pVIH2->bmiHeader.biWidth )
        {
            return FALSE;
        }
        if( pVIH1->bmiHeader.biHeight != pVIH2->bmiHeader.biHeight )
        {
            return FALSE;
        }
        if( pVIH1->bmiHeader.biBitCount != pVIH2->bmiHeader.biBitCount )
        {
            return FALSE;
        }
        // !!! do a non-case-sensitive compare
        //
        if( pVIH1->bmiHeader.biCompression != pVIH2->bmiHeader.biCompression )
        {
            return FALSE;
        }
        
        // compare frame rates
        //
        if( pVIH1->AvgTimePerFrame == 0 )
        {
            if( pVIH2->AvgTimePerFrame != 0 )
            {
		// !!! This assumes any file that doesn't know its frame rate
		// is acceptable without recompressing!
		// MediaPad can't do smart recompression with ASF sources
		// without this - WM files don't know their frame rate.
		// But using ASF sources to write an AVI file with Smart
		// recompression will make an out of sync file because I'm
		// not returning FALSE!
                return TRUE;
            }
        }
        // !!! accept frame rate <1% different?
        else
        {
            REFERENCE_TIME Percent = ( pVIH1->AvgTimePerFrame - pVIH2->AvgTimePerFrame ) * 100 / ( pVIH1->AvgTimePerFrame );
            if( Percent > 1 || Percent < -1)
            {
                return FALSE;
            }
        }

        // compare bit rates - !!! if they didn't give us a bit rate to insist upon, don't reject any source
        //
        if( pVIH2->dwBitRate == 0 )
        {
            // do nothing la la la
        }
        // !!! accept data rate <5% too high?
        else
        {
            int Percent = (int)(((LONGLONG)pVIH1->dwBitRate - pVIH2->dwBitRate)
					* 100 / pVIH2->dwBitRate);
            if( Percent > 5 )
            {
                return FALSE;
            }
        }
    }
    else if( pType1->formattype == FORMAT_WaveFormatEx )
    {
        WAVEFORMATEX * pFormat1 = (WAVEFORMATEX*) pType1->pbFormat;
        WAVEFORMATEX * pFormat2 = (WAVEFORMATEX*) pTypeNeeded->pbFormat;

        if( pFormat1->wFormatTag != pFormat2->wFormatTag )
        {
            return FALSE;
        }
        if( pFormat1->nChannels != pFormat2->nChannels )
        {
            return FALSE;
        }
        if( pFormat1->nSamplesPerSec != pFormat2->nSamplesPerSec )
        {
            return FALSE;
        }
        if( pFormat1->nAvgBytesPerSec != pFormat2->nAvgBytesPerSec )
        {
            return FALSE;
        }
        if( pFormat1->wBitsPerSample != pFormat2->wBitsPerSample )
        {
            return FALSE;
        }
        if( pFormat1->cbSize != pFormat2->cbSize )
        {
            return FALSE;
        }

        // if there's a size, then compare the compression blocks
        //
        if( pFormat1->cbSize )
        {
            char * pExtra1 = ((char*) pFormat1) + pFormat1->cbSize;
            char * pExtra2 = ((char*) pFormat2) + pFormat2->cbSize;
            if( memcmp( pExtra1, pExtra2, pFormat1->cbSize ) != 0 )
            {
                return FALSE;
            }
        }
    }
    else
    {
        return FALSE;
    }

    return TRUE;
}

long GetPinCount( IBaseFilter * pFilter, PIN_DIRECTION pindir )
{
    CheckPointer( pFilter, E_POINTER );

    CComPtr< IEnumPins > pEnumPins;
    pFilter->EnumPins( &pEnumPins );
    if( !pEnumPins )
    {
        return 0;
    }

    long Count = 0;

    while( 1 )
    {
        ULONG Fetched = 0;
        CComPtr< IPin > pPin;
        pEnumPins->Next( 1, &pPin, &Fetched );
        if( !Fetched )
        {
            return Count;
        }
        PIN_INFO PinInfo;
        ZeroMemory( &PinInfo, sizeof( PinInfo ) );
        pPin->QueryPinInfo( &PinInfo );
        if( PinInfo.pFilter ) PinInfo.pFilter->Release( );
        if( PinInfo.dir == pindir )
        {
            Count++;
        }
    }
}

BOOL DoesPinHaveMajorType( IPin * pPin, GUID MajorType )
{
    if( !pPin ) return FALSE;

    HRESULT hr;

    AM_MEDIA_TYPE MediaType;
    ZeroMemory( &MediaType, sizeof( MediaType ) );
    hr = pPin->ConnectionMediaType( &MediaType );
    GUID FoundType = MediaType.majortype;
    SaferFreeMediaType( MediaType );
    if( FoundType == MajorType ) return TRUE;
    return FALSE;
}

// the passed in pin should be an input pin for a filter, not an output pin
//
HRESULT FindFirstPinWithMediaType( IPin ** ppPin, IPin * pEndPin, GUID MajorType )
{
    CheckPointer( ppPin, E_POINTER );
    CheckPointer( pEndPin, E_POINTER );

    *ppPin = NULL;

    HRESULT hr;

    // find the pin the end pin is connected to
    //
    CComPtr< IPin > pOutPin;
    hr = pEndPin->ConnectedTo( &pOutPin );
    if( FAILED( hr ) )
    {
        return hr;
    }

    // travel upstream until we come to a filter whose input pin is not the
    // same type as the output pin. When this happens, we will have found
    // a splitter or a source filter which provides the media type we're looking
    // for. We'll return that pin
    //
    while( 1 )
    {
        IBaseFilter * pFilter = GetFilterFromPin( pOutPin );
        IPin * pInPin = GetInPin( pFilter, 0 );

        // if the filter doesn't have an input pin, it must be the
        // source filter
        //
        if( !pInPin )
        {
            // the output pin should already match the media type
            // we're looking for, since we traveled upstream to get
            // it
            //
            *ppPin = pOutPin;
            (*ppPin)->AddRef( );
            return NOERROR;
        }

        // does the input pin's type match? If not, we're done
        //
        if( !DoesPinHaveMajorType( pInPin, MajorType ) )
        {
            *ppPin = pOutPin;
            (*ppPin)->AddRef( );
            return NOERROR;
        }

        // they both match, travel upstream to find the next one
        //
        pOutPin.Release( );
        pInPin->ConnectedTo( &pOutPin );
        if( !pOutPin )
        {
            return NOERROR;
        }
    }

    // never gets here
}

HRESULT CheckGraph( IGraphBuilder * pGraph )
{
    USES_CONVERSION;

    if( pGraph )
    {
        CComPtr< IEnumFilters > pEnumFilters;
        pGraph->EnumFilters( &pEnumFilters );
        if( pEnumFilters )
        {
            while( 1 )
            {
                CComPtr< IBaseFilter > pFilter;
                ULONG Fetched = 0;
                pEnumFilters->Next( 1, &pFilter, &Fetched );
                if( !Fetched )
                {
                    break;
                }

                FILTER_INFO fi;
                pFilter->QueryFilterInfo( &fi );
                if( fi.pGraph ) fi.pGraph->Release( );

                TCHAR * t = W2T( fi.achName );
                DbgLog( ( LOG_TRACE, 2, "Checking filter %s", t ) );

                if( fi.pGraph != pGraph )
                {
                    DbgLog( ( LOG_TRACE, 2, "CheckGraph has BAD filter %s", t ) );
                    ASSERT( 0 );
                }

                // check all the pins for this filter
                //
                CComPtr< IEnumPins > pEnumPins;
                pFilter->EnumPins( &pEnumPins );
                while( 1 )
                {
                    CComPtr< IPin > pPin;
                    Fetched = 0;
                    pEnumPins->Next( 1, &pPin, &Fetched );
                    if( !Fetched )
                    {
                        break;
                    }

                    PIN_INFO pi;
                    pPin->QueryPinInfo( &pi );
                    if( pi.pFilter ) pi.pFilter->Release( );

                    CComPtr< IPin > pConnected;
                    pPin->ConnectedTo( &pConnected );
                    if( pConnected )
                    {
                        PIN_INFO pi2;
                        pConnected->QueryPinInfo( &pi2 );
                        if( pi2.pFilter ) pi2.pFilter->Release( );

                        IBaseFilter * s = pi2.pFilter;
                        while( s )
                        {
                            s->QueryFilterInfo( &fi );
                            if( fi.pGraph ) fi.pGraph->Release( );

                            TCHAR * t2 = W2T( fi.achName );
//                            DbgLog( ( LOG_TRACE, 2, "Checking linked filter %s", t2 ) );

                            if( fi.pGraph != pGraph )
                            {
                                DbgLog( ( LOG_TRACE, 2, "CheckGraph has BAD filter %s", t2 ) );
                                ASSERT( 0 );
                            }

                            if( pi2.dir == PINDIR_OUTPUT )
                            {
                                s = GetNextUpstreamFilter( s );
                            }
                            else
                            {
                                s = GetNextDownstreamFilter( s );
                            }
                        }
                    }
                }
            } // while filters
        } // if enum filters
    } // if pGraph

    return NOERROR;
}


// Disconnect the pin that is still attached to the switch.  Downstream of
// pSource will be a splitter with both branches connected, only one of which
// is still attached to a switch (the one of media type pmt).  Disconnect that
// one.
//
HRESULT DisconnectExtraAppendage(IBaseFilter *pSource, GUID *pmt, IBaseFilter *pSwitch, IBaseFilter **ppDanglyBit)
{
    CheckPointer(pSource, E_POINTER);
    CheckPointer(pmt, E_POINTER);
    CheckPointer(pSwitch, E_POINTER);
    CheckPointer(ppDanglyBit, E_POINTER);
    *ppDanglyBit = NULL;

    CComPtr<IPin> pSwitchIn;
    CComPtr<IPin> pCon;

    while (pSource && pSource != pSwitch) {

        CComPtr <IEnumPins> pEnumPins;
        pSource->EnumPins(&pEnumPins);
        if (!pEnumPins) {
            return E_FAIL;
        }
	pSource = NULL;

        // look at every pin on the current filter...
        //
        ULONG Fetched = 0;
        while (1) {
            CComPtr <IPin> pPin;
    	    CComPtr<IPin> pPinIn;
            Fetched = 0;
            pEnumPins->Next(1, &pPin, &Fetched);
            if (!Fetched) {
                break;
            }
	    PIN_INFO pi;
	    pPin->QueryPinInfo(&pi);
	    if (pi.pFilter) pi.pFilter->Release();
            if( pi.dir == PINDIR_INPUT )
            {
                continue;
            } else {
                pPin->ConnectedTo(&pPinIn);
		if (pPinIn) {
                    PIN_INFO pi2;
                    pPinIn->QueryPinInfo(&pi2);
                    if (pi2.pFilter) pi2.pFilter->Release();
                    pSource = pi2.pFilter;	// we'll continue down from here
						// unless it's the wrong split
						// pin
		    if (pSource == pSwitch) {
			pSwitchIn = pPinIn;
			pCon = pPin;
		        break;
                    }
		}
                CComPtr<IEnumMediaTypes> pMediaEnum;
                pPin->EnumMediaTypes(&pMediaEnum);
                if (pMediaEnum && pPinIn) {
                    Fetched = 0;
                    AM_MEDIA_TYPE *pMediaType;
                    pMediaEnum->Next(1, &pMediaType, &Fetched);
                    if (Fetched) {
                        if (pMediaType->majortype == *pmt) {
                            DeleteMediaType(pMediaType);
			    // return the head of the dangly chain
			    *ppDanglyBit = GetFilterFromPin(pPinIn);
                            //pSplitPin = pPin;
			    // This is where to continue downstream from
			    break;
			}
                        DeleteMediaType(pMediaType);
		    }
		}
	    }
	}

	// continue downstream
    }

    // we never did find an appropriate splitter pin and switch input pin
    if (pCon == NULL || pSwitchIn == NULL) {
	return S_OK;
    }

    //
    // now disconnect
    //
    HRESULT hr = pSwitchIn->Disconnect();
    hr = pCon->Disconnect();
    return hr;
}


// Look upstream from pPinIn for a splitter with an output pin that supports
// type "guid".  Return that pin, non-addrefed.  It may already be connected,
// that's OK. AND GET THE RIGHT STREAM #!  If we don't get the correct split
// pin for the stream # desired right now, our caching dangly bit logic
// won't work!
//
IPin * FindOtherSplitterPin(IPin *pPinIn, GUID guid, int nStream)
{
    DbgLog((LOG_TRACE,1,TEXT("FindOtherSplitterPin")));

    CComPtr< IPin > pPinOut;
    pPinOut = pPinIn;

    while (pPinOut) {
        PIN_INFO ThisPinInfo;
        pPinOut->QueryPinInfo( &ThisPinInfo );
        if( ThisPinInfo.pFilter ) ThisPinInfo.pFilter->Release( );

	pPinOut = NULL;
        CComPtr< IEnumPins > pEnumPins;
        ThisPinInfo.pFilter->EnumPins( &pEnumPins );
        if( !pEnumPins )
        {
            return NULL;
        }

        // look at every pin on the current filter...
        //
        ULONG Fetched = 0;
        while (1) {
            CComPtr< IPin > pPin;
            Fetched = 0;
            ASSERT( !pPin ); // is it out of scope?
            pEnumPins->Next( 1, &pPin, &Fetched );
            if( !Fetched )
            {
                break;
            }

            PIN_INFO pi;
            pPin->QueryPinInfo( &pi );
            if( pi.pFilter ) pi.pFilter->Release( );

            // if it's an input pin...
            //
            if( pi.dir == PINDIR_INPUT )
            {
                // continue searching upstream from this pin
                //
                pPin->ConnectedTo(&pPinOut);

	    // a pin that supports the required media type is the
	    // splitter pin we are looking for!  We are done
	    //
            } else {
            	    CComPtr< IEnumMediaTypes > pMediaEnum;
            	    pPin->EnumMediaTypes(&pMediaEnum);
            	    if (pMediaEnum) {
            		Fetched = 0;
			AM_MEDIA_TYPE *pMediaType;
            		pMediaEnum->Next(1, &pMediaType, &Fetched);
            		if (Fetched) {
			    if (pMediaType->majortype == guid) {
				if (nStream-- == 0) {
            			    DeleteMediaType(pMediaType);
    		    		    DbgLog((LOG_TRACE,1,TEXT("Found SPLIT pin")));
		    		    return pPin;
				}
			    }
            		    DeleteMediaType( pMediaType );
			}
		    }
	    }

            // go try the next pin
            
        } // while
    }
    // file doesn't contain any video/audio that is wanted ASSERT(FALSE);
    return NULL;
}
=== C:/Users/treeman/Desktop/windows nt source code\Source\Win2K3\NT\multimedia\dshow\filterus\dexter\util\wmkeystuff.h ===
//@@@@AUTOBLOCK+============================================================;
//
//  THIS CODE AND INFORMATION IS PROVIDED "AS IS" WITHOUT WARRANTY OF ANY
//  KIND, EITHER EXPRESSED OR IMPLIED, INCLUDING BUT NOT LIMITED TO THE
//  IMPLIED WARRANTIES OF MERCHANTABILITY AND/OR FITNESS FOR A PARTICULAR
//  PURPOSE.
//
//  File: wmkeystuff.h
//
//  Copyright (c) Microsoft Corporation.  All Rights Reserved.
//
//@@@@AUTOBLOCK-============================================================;

#pragma once

#include <..\..\..\filters\asf\wmsdk\inc\wmsdkidl.h>

typedef HRESULT STDAPICALLTYPE WMCREATEKEYPROC(BYTE *, DWORD, LPUNKNOWN *);

// note: this object is a SEMI-COM object, and can only be created statically.
class CKeyProvider : public IServiceProvider {
public:
    STDMETHODIMP_(ULONG) AddRef() { return 2; }
    STDMETHODIMP_(ULONG) Release() { return 1; }

    STDMETHODIMP QueryInterface(REFIID riid, void ** ppv)
    {
        if (riid == IID_IServiceProvider || riid == IID_IUnknown) {
            *ppv = (void *) static_cast<IServiceProvider *>(this);
            return NOERROR;
        }    
        return E_NOINTERFACE;
    }


    STDMETHODIMP QueryService(REFIID siid, REFIID riid, void **ppv)
    {
        if (siid == __uuidof(IWMReader) && riid == IID_IUnknown) {

            IUnknown *punkCert;

            HRESULT hr = WMCreateCertificate( &punkCert );
            if (SUCCEEDED(hr)) {
                *ppv = (void *) punkCert;
            }
            return hr;
        }
        return E_NOINTERFACE;
    }

};
=== C:/Users/treeman/Desktop/windows nt source code\Source\Win2K3\NT\multimedia\dshow\filterus\dexter\xmltl\xml2dex.h ===
//@@@@AUTOBLOCK+============================================================;
//
//  THIS CODE AND INFORMATION IS PROVIDED "AS IS" WITHOUT WARRANTY OF ANY
//  KIND, EITHER EXPRESSED OR IMPLIED, INCLUDING BUT NOT LIMITED TO THE
//  IMPLIED WARRANTIES OF MERCHANTABILITY AND/OR FITNESS FOR A PARTICULAR
//  PURPOSE.
//
//  File: xml2dex.h
//
//  Copyright (c) Microsoft Corporation.  All Rights Reserved.
//
//@@@@AUTOBLOCK-============================================================;

// Xml2Dex.h : Declaration of the CXml2Dex

#ifndef __XML2DEX_H_
#define __XML2DEX_H_

#include <atlbase.h>
extern CComModule _Module;
#include <atlcom.h>
#include "resource.h"       // main symbols
#include <qedit.h>

/////////////////////////////////////////////////////////////////////////////
// CXml2Dex
class ATL_NO_VTABLE CXml2Dex : 
	public CComObjectRootEx<CComSingleThreadModel>,
	public CComCoClass<CXml2Dex, &CLSID_Xml2Dex>,
	public IDispatchImpl<IXml2Dex, &IID_IXml2Dex, &LIBID_DexterLib>
{
            CComPtr< IRenderEngine > m_pRenderEngine;
public:
	CXml2Dex()
	{
	}

DECLARE_REGISTRY_RESOURCEID(IDR_XML2DEX)

DECLARE_PROTECT_FINAL_CONSTRUCT()

BEGIN_COM_MAP(CXml2Dex)
	COM_INTERFACE_ENTRY(IXml2Dex)
	COM_INTERFACE_ENTRY(IDispatch)
END_COM_MAP()

// IXml2Dex
public:
	STDMETHOD(WriteXMLFile)(IUnknown *pTL, BSTR FileName);
	STDMETHOD(WriteGrfFile)(IUnknown *pGraph, BSTR FileName);
	STDMETHOD(CreateGraphFromFile)(IUnknown ** ppGraph, IUnknown * pTimeline, BSTR Filename);
        STDMETHOD(ReadXMLFile)(IUnknown * pTimelineUnk, BSTR Filename);
        STDMETHOD(Delete)(IUnknown * pTimelineUnk, double dStart, double dEnd);
	STDMETHOD(WriteXMLPart)(IUnknown *pTL, double dStart, double dEnd, BSTR FileName);
	STDMETHOD(PasteXMLFile)(IUnknown *pTL, double dStart, BSTR FileName);
	STDMETHOD(CopyXML)(IUnknown *pTL, double dStart, double dEnd);
	STDMETHOD(PasteXML)(IUnknown *pTL, double dStart);
	STDMETHOD(Reset)();
        STDMETHOD(ReadXML)(IUnknown * pTimelineUnk, IUnknown *pxmlunk);
	STDMETHOD(WriteXML)(IUnknown *pTL, BSTR *pbstrXML);
};

#endif //__XML2DEX_H_
=== C:/Users/treeman/Desktop/windows nt source code\Source\Win2K3\NT\multimedia\dshow\filterus\dexter\xmltl\xmldom.h ===
//@@@@AUTOBLOCK+============================================================;
//
//  THIS CODE AND INFORMATION IS PROVIDED "AS IS" WITHOUT WARRANTY OF ANY
//  KIND, EITHER EXPRESSED OR IMPLIED, INCLUDING BUT NOT LIMITED TO THE
//  IMPLIED WARRANTIES OF MERCHANTABILITY AND/OR FITNESS FOR A PARTICULAR
//  PURPOSE.
//
//  File: xmldom.h
//
//  Copyright (c) Microsoft Corporation.  All Rights Reserved.
//
//@@@@AUTOBLOCK-============================================================;

BSTR FindAttribute(IXMLDOMElement *p, LPWSTR name);
DWORD ParseNum(LPWSTR p);
LONG ReadNumAttribute(IXMLDOMElement *p, LPWSTR attrName, LONG lDefault = 0);
LONGLONG ParseTime(LPWSTR p);
LONGLONG ReadTimeAttribute(IXMLDOMElement *p, LPWSTR attrName, LONGLONG llDefault = 0);
BOOL ReadBoolAttribute(IXMLDOMElement *p, LPWSTR attrName, BOOL bDefault);

BSTR FindAttribute(IXMLDOMElement *p, LPWSTR name)
{
    VARIANT v;
    HRESULT hr = E_OUTOFMEMORY;
    VariantInit(&v);
    BSTR bname = SysAllocString (name);
    if (bname)
    {
        hr = p->getAttribute(bname, &v);
        SysFreeString(bname);
    }
    
    if( hr != NOERROR )
    {
        return NULL;
    }

    return V_BSTR(&v);
}

DWORD ParseNum(LPWSTR p)
{
    DWORD dwRet = 0;

    WCHAR c;
    while (((c = *p++) >= L'0') && (c <= L'9') )
	dwRet = (dwRet * 10) + (c - L'0');

    return dwRet;
}

LONG ReadNumAttribute(IXMLDOMElement *p, LPWSTR attrName, LONG lDefault /* = 0 */)
{
    // remember, never assign anything to this
    CComBSTR val = FindAttribute(p, attrName);

    LONG lRet = lDefault;

    if (val) {
	lRet = ParseNum(val);
    }

    return lRet;
}


LONGLONG ParseTime(LPWSTR p)
{
    DbgLog((LOG_TRACE, 4, TEXT("ParseTime: parsing '%hs'"), p));
    
    WCHAR c = *p++;

    // !!! could handle SMPTE frames here?
    DWORD	dwSec = 0;
    DWORD	dwMin = 0;
    DWORD	dwFrac = 0;
    int		iFracPlaces = -1;
    while (c != L'\0') {
	if (c >= L'0' && c <= L'9') {
	    if (iFracPlaces >= 0) {
		++iFracPlaces;
		dwFrac = dwFrac * 10 + (c - L'0');
	    } else {
		dwSec = dwSec * 10 + (c - L'0');
            }
	} else if (iFracPlaces >= 0) {
            break;
        } else if (c == L':') {
	    dwMin = dwMin * 60 + dwSec;
	    dwSec = 0;
	} else if (c == L'.') {
	    iFracPlaces = 0;
	} else
	    break;	// !!! allow for skipping whitespace?

	c = *p++;
    }

    LONGLONG llRet = (LONGLONG) dwFrac * UNITS;
    while (iFracPlaces-- > 0) {
	llRet /= 10;
    }

    llRet += (LONGLONG) dwMin * 60 * UNITS + (LONGLONG) dwSec * UNITS;

    DbgLog((LOG_TRACE, 4, TEXT("ParseTime: returning %d ms"), (DWORD) (llRet / 10000)));
    
    return llRet;
}

LONGLONG ReadTimeAttribute(IXMLDOMElement *p, LPWSTR attrName, LONGLONG llDefault /* = 0 */)
{
    // remember, never assign anything to this
    CComBSTR val = FindAttribute(p, attrName);

    LONGLONG llRet = llDefault;

    if (val) {
	llRet = ParseTime(val);
    }

    return llRet;
}

BOOL ReadBoolAttribute(IXMLDOMElement *p, LPWSTR attrName, BOOL bDefault)
{
    // remember, never assign anything to this
    CComBSTR val = FindAttribute(p, attrName);

    if (val) {
	WCHAR c = *val;
	if (c == L'y' || c == L'Y' || c == L't' || c == L'T' || c == L'1')
	    bDefault = TRUE;
	else if (c == L'n' || c == L'N' || c == L'f' || c == L'F' || c == L'0')
	    bDefault = FALSE;
	else {
	    DbgLog((LOG_ERROR, 1, TEXT("Looking for yes/no value, found '%ls'"), val));
	}
    }

    return bDefault;
}
=== C:/Users/treeman/Desktop/windows nt source code\Source\Win2K3\NT\multimedia\dshow\filterus\dexter\xmltl\xml2dex.cpp ===
//@@@@AUTOBLOCK+============================================================;
//
//  THIS CODE AND INFORMATION IS PROVIDED "AS IS" WITHOUT WARRANTY OF ANY
//  KIND, EITHER EXPRESSED OR IMPLIED, INCLUDING BUT NOT LIMITED TO THE
//  IMPLIED WARRANTIES OF MERCHANTABILITY AND/OR FITNESS FOR A PARTICULAR
//  PURPOSE.
//
//  File: xml2dex.cpp
//
//  Copyright (c) Microsoft Corporation.  All Rights Reserved.
//
//@@@@AUTOBLOCK-============================================================;

// Xml2Dex.cpp : Implementation of CXml2Dex
#include <streams.h>
#include <qeditint.h>
#include <qedit.h>
#include "xmltl.h"
#include "Xml2Dex.h"
#include "..\util\filfuncs.h"
#include "..\util\dexmisc.h"

/////////////////////////////////////////////////////////////////////////////
// CXml2Dex

STDMETHODIMP CXml2Dex::ReadXMLFile(IUnknown * pTimelineUnk, BSTR Filename)
{
    // don't check filename here, do it in BuildFromXMLFile

    CheckPointer(pTimelineUnk, E_POINTER);
    CheckPointer(Filename, E_POINTER);

    CComQIPtr< IAMTimeline, &_uuidof(IAMTimeline) > pTimeline( pTimelineUnk );

    HRESULT hr = BuildFromXMLFile( pTimeline, Filename );

    return hr;
}

STDMETHODIMP CXml2Dex::ReadXML(IUnknown * pTimelineUnk, IUnknown *pxmlunk)
{
    CheckPointer(pTimelineUnk, E_POINTER);
    CheckPointer(pxmlunk, E_POINTER);

    CComQIPtr< IAMTimeline, &_uuidof(IAMTimeline) > pTimeline( pTimelineUnk );
    CComQIPtr< IXMLDOMElement, &_uuidof(IXMLDOMElement) > pxml( pxmlunk );

    HRESULT hr = BuildFromXML( pTimeline, pxml );

    return hr;
}

STDMETHODIMP CXml2Dex::Delete(IUnknown *pTimelineUnk, double Start, double End)
{
    CComQIPtr< IAMTimeline, &_uuidof(IAMTimeline) > pTimeline( pTimelineUnk );

    HRESULT hr = InsertDeleteTLSection(pTimeline,
                                       (REFERENCE_TIME) (Start * UNITS),
                                       (REFERENCE_TIME) (End * UNITS),
                                       TRUE); // delete

    return hr;
}

STDMETHODIMP CXml2Dex::CreateGraphFromFile(IUnknown **ppGraph, IUnknown * pTimelineUnk, BSTR Filename)
{
    // don't check name here

    HRESULT hr = 0;

    CComQIPtr< IAMTimeline, &_uuidof(IAMTimeline) > pTimeline( pTimelineUnk );

    hr = BuildFromXMLFile( pTimeline, Filename );
    if( FAILED( hr ) ) return hr;

    // create a render engine
    //
    hr = CoCreateInstance(
        __uuidof(RenderEngine),
        NULL,
        CLSCTX_INPROC_SERVER,
        __uuidof(IRenderEngine),
        (void**) &m_pRenderEngine
    );

    if (FAILED(hr))
    {
        return hr;
    }

    hr = m_pRenderEngine->SetTimelineObject( pTimeline );
    if( FAILED( hr ) ) return hr;

    hr = m_pRenderEngine->ConnectFrontEnd( );
    if( FAILED( hr ) ) return hr;
    hr = m_pRenderEngine->RenderOutputPins( );
    if( FAILED( hr ) ) return hr;


    CComPtr< IGraphBuilder > pGraphTemp;
    hr = m_pRenderEngine->GetFilterGraph( &pGraphTemp );
    *ppGraph = (IUnknown*) pGraphTemp;
    (*ppGraph)->AddRef( );

    return hr;
}

STDMETHODIMP CXml2Dex::WriteGrfFile(IUnknown *pGraphUnk, BSTR FileName)
{
    CheckPointer(pGraphUnk, E_POINTER);
    CheckPointer(FileName, E_POINTER);

    HRESULT hrFile = ValidateFilename( FileName, _MAX_PATH, TRUE );
    if( FAILED( hrFile ) )
    {
        return hrFile;
    }

    HRESULT hr = E_INVALIDARG;

    CComQIPtr< IGraphBuilder, &_uuidof(IGraphBuilder) > pGraph( pGraphUnk );
    if (pGraph == NULL)
        return E_INVALIDARG;

    if (!DexCompareW(FileName + lstrlenW(FileName) - 3, L"grf")) { // safe, since bounded
        CComPtr< IStorage > pStg;
        hr = StgCreateDocfile
        (
            FileName,
            STGM_READWRITE | STGM_CREATE | STGM_SHARE_EXCLUSIVE,
            0, // reserved
            &pStg
        );

        if (SUCCEEDED(hr)) {
            CComPtr< IStream > pStream;
            hr = pStg->CreateStream
            (
                L"ActiveMovieGraph",
                STGM_READWRITE | STGM_CREATE | STGM_SHARE_EXCLUSIVE,
                NULL,
                NULL,
                &pStream
            );
            if (SUCCEEDED(hr)) {
                CComQIPtr< IPersistStream, &IID_IPersistStream > pPersist( pGraph );
                if (pPersist) {
                    hr = pPersist->Save( pStream, FALSE );
                } else {
                    hr = E_INVALIDARG;
                }

                if (SUCCEEDED(hr)) {
                    hr = pStg->Commit( STGC_DEFAULT );
                }
            }
        }
    } else
    {
        ASSERT(!"filename should have ended in .grf!");
        hr = E_INVALIDARG;
    }

    return hr;
}

STDMETHODIMP CXml2Dex::WriteXMLFile(IUnknown * pTimelineUnk, BSTR FileName)
{
    // don't check filename here, do it in savetimeline...

    CheckPointer(pTimelineUnk, E_POINTER);
    CheckPointer(FileName, E_POINTER);

    CComQIPtr< IAMTimeline, &__uuidof(IAMTimeline) > pTimeline( pTimelineUnk );

    return SaveTimelineToXMLFile(pTimeline, FileName);
}


STDMETHODIMP CXml2Dex::Reset( )
{
    if( !m_pRenderEngine )
    {
        return NOERROR;
    }

    m_pRenderEngine->ScrapIt( );
    m_pRenderEngine.Release( );
    m_pRenderEngine = NULL;

    return NOERROR;
}

STDMETHODIMP CXml2Dex::WriteXML(IUnknown * pTimelineUnk, BSTR *pbstrXML)
{
    // don't check name here

    CheckPointer(pTimelineUnk, E_POINTER);
    CheckPointer(pbstrXML, E_POINTER);

    CComQIPtr< IAMTimeline, &__uuidof(IAMTimeline) > pTimeline( pTimelineUnk );

    return SaveTimelineToXMLString(pTimeline, pbstrXML);
}

STDMETHODIMP CXml2Dex::WriteXMLPart(IUnknown * pTimelineUnk, double dStart, double dEnd, BSTR FileName)
{
    return E_NOTIMPL;
}

STDMETHODIMP CXml2Dex::PasteXMLFile(IUnknown * pTimelineUnk, double dStart, BSTR FileName)
{
    return E_NOTIMPL;
}

STDMETHODIMP CXml2Dex::CopyXML(IUnknown * pTimelineUnk, double dStart, double dEnd)
{
    return E_NOTIMPL;
}

STDMETHODIMP CXml2Dex::PasteXML(IUnknown * pTimelineUnk, double dStart)
{
    return E_NOTIMPL;
}
=== C:/Users/treeman/Desktop/windows nt source code\Source\Win2K3\NT\multimedia\dshow\filterus\dexter\xmltl\varyprop.cpp ===
//@@@@AUTOBLOCK+============================================================;
//
//  THIS CODE AND INFORMATION IS PROVIDED "AS IS" WITHOUT WARRANTY OF ANY
//  KIND, EITHER EXPRESSED OR IMPLIED, INCLUDING BUT NOT LIMITED TO THE
//  IMPLIED WARRANTIES OF MERCHANTABILITY AND/OR FITNESS FOR A PARTICULAR
//  PURPOSE.
//
//  File: varyprop.cpp
//
//  Copyright (c) Microsoft Corporation.  All Rights Reserved.
//
//@@@@AUTOBLOCK-============================================================;

extern bool IsCommentElement(IXMLDOMNode *p);

// helper function. We require whoever calls us to guarantee we don't blow out the string
long PrintIndentW(WCHAR * pOut, int indent)
{
    long i = indent;
    while (indent--) {
        pOut += wsprintfW(pOut, L"    ");
    }
    return i * 4;
}

// helper function. We require whoever calls us to guarantee we don't blow out the string
long PrintTimeW(WCHAR * pOut, REFERENCE_TIME rt)
{
    int secs = (int) (rt / UNITS);
    WCHAR * pOutOrg = pOut;

    double dsecs = rt - (double)(secs * UNITS);
    int isecs = (int)dsecs;

    if (isecs) {
        pOut += wsprintfW(pOut, L"%d.%07d", secs, isecs);
    } else {
        pOut += wsprintfW(pOut, L"%d", secs);
    }
    return long( pOut - pOutOrg );
}

HRESULT CPropertySetter::CreatePropertySetterInstanceFromXML( IPropertySetter ** ppSetter, IXMLDOMElement * pxml )
{
    CPropertySetter *pSetter = new CPropertySetter(NULL);
    if (!pSetter)
        return E_OUTOFMEMORY;
    
    pSetter->AddRef();

    // it's perfectly safe to cast down to IUnknown *, but we'll immediately cast back up to IXMLDOMElement *
    HRESULT hr = pSetter->LoadXML(pxml);
    
    // S_FALSE here means there weren't any properties, so throw the object away.
    if (hr != S_OK) {
        pSetter->Release();
        *ppSetter = NULL;
    } else {
        *ppSetter = pSetter;
    }
    
    return hr;
}


CUnknown * WINAPI CPropertySetter::CreateInstance(LPUNKNOWN pUnk, HRESULT *phr)
{
    return new CPropertySetter(pUnk);
}


CPropertySetter::~CPropertySetter()
{
    ClearProps();
}


// call SetProps(-1) to set static props
// call SetProps(t), t>0 to set dynamic props (won't resend the prop at time 0)
//
HRESULT CPropertySetter::SetProps(IUnknown *punkTarget, REFERENCE_TIME rtNow)
{
    
    HRESULT hr = S_OK;
    
    // there are no props
    if (m_pLastParam == NULL)
        return S_OK;
    
    CComPtr< IDispatch > pTarget;
    hr = punkTarget->QueryInterface(IID_IDispatch, (void **) &pTarget);
    if (FAILED(hr))
        return hr;
    
    QPropertyParam *pParams = &m_params;
    
    while (pParams) 
    {
        QPropertyValue *pVal = &pParams->val;
        
        // braces for the goto
        {
            if (rtNow != -1) {
                // if we aren't setting static props skip a single value at
                // time 0
                if (pVal->rt == 0 && pVal->pNext == NULL)
                    goto next;
                
                while (pVal->pNext && pVal->pNext->rt < rtNow) {
                    pVal = pVal->pNext;
                }
                
                // there are no properties yet
                if (pVal->rt > rtNow)
                    goto next;
                
                
                // we are being told to only set the first prop if it is time 0
            } else {
                if (pVal->rt > 0)
                    goto next;
            }
            
            if (!pParams->dispID) {
                hr = pTarget->GetIDsOfNames(IID_IDispatch,
                    &pParams->bstrPropName, 1,
                    LOCALE_USER_DEFAULT, &pParams->dispID);
                if (FAILED(hr)) {
                    VARIANT var;
                    VariantInit(&var);
                    var.vt = VT_BSTR;
                    var.bstrVal = pParams->bstrPropName;
                    _GenerateError( 2, L"No such property exists on an object", DEX_IDS_NO_SUCH_PROPERTY, E_INVALIDARG, &var );
                    break;
                }
            }
            
            VARIANT v;
            VariantInit(&v);
            
            // try to make it a real, if we can.  Otherwise, leave it alone
            hr = VarChngTypeHelper(&v, &pVal->v, VT_R8);
            if( hr != S_OK)
            {
                hr = VariantCopy( &v, &pVal->v );
                ASSERT(hr == S_OK);
            }
            
            if (rtNow != -1 && pVal->pNext &&
                pVal->pNext->dwInterp == DEXTERF_INTERPOLATE) {
                VARIANT v2;
                VariantInit(&v2);
                
                hr = VarChngTypeHelper(&v2, &pVal->pNext->v, VT_R8);
                if (hr != S_OK || V_VT(&v) != VT_R8) {
                    _GenerateError( 2, L"Illegal value for a property", DEX_IDS_ILLEGAL_PROPERTY_VAL, E_INVALIDARG, NULL );
                    break;
                }
                
                double d = (double)(rtNow - pVal->rt) / (pVal->pNext->rt - pVal->rt);
                ASSERT(V_VT(&v) == VT_R8);
                ASSERT(V_VT(&v2) == VT_R8);
                V_R8(&v) = (V_R8(&v) * (1-d) + V_R8(&v2) * d);
            }
            
            DbgLog((LOG_TRACE,3,TEXT("CALLING INVOKE")));
            DbgLog((LOG_TRACE,3,TEXT("time = %d ms  pval->rt = %d ms  val = %d")
                , (int)(rtNow / 10000), (int)(pVal->rt / 10000)
                , (int)(V_R8(&v) * 100)));
            
            DISPID dispidNamed = DISPID_PROPERTYPUT;
            DISPPARAMS disp;
            disp.cNamedArgs = 1;
            disp.cArgs = 1;
            disp.rgdispidNamedArgs = &dispidNamed;
            disp.rgvarg = &v;
            VARIANT result;
            VariantInit(&result);
            
            hr = pTarget->Invoke(pParams->dispID,
                IID_NULL,
                LOCALE_USER_DEFAULT,
                DISPATCH_PROPERTYPUT,
                &disp,
                &result,
                NULL,
                NULL);
            
            if (FAILED(hr)) {
                _GenerateError( 2, L"Illegal value for a property", DEX_IDS_ILLEGAL_PROPERTY_VAL, E_INVALIDARG, NULL );
                break;
            }
        }
        
next:
        pParams = pParams->pNext;
    }
    
    return hr;
}


HRESULT CPropertySetter::LoadOneProperty(IXMLDOMElement *p, QPropertyParam *pParam)
{
    HRESULT hr = S_OK;
    
    QPropertyValue *pLastValue = &pParam->val;
    
    CComQIPtr<IXMLDOMNode, &IID_IXMLDOMNode> pNode( p );
    
    CComPtr< IXMLDOMNodeList > pcoll;
    hr = pNode->get_childNodes(&pcoll);
    
    if (hr != S_OK)
        return S_FALSE; // nothing to do
    
    bool fLoadedProperty = false;
    
    long lChildren = 0;
    hr = pcoll->get_length(&lChildren);
    
    int lVal = 0;                    
    
    for (; lVal < lChildren && SUCCEEDED(hr); lVal++) {
        CComPtr< IXMLDOMNode > pNode;
        hr = pcoll->get_item(lVal, &pNode);
        
        if (SUCCEEDED(hr) && pNode) {
            CComPtr< IXMLDOMElement > pelem;
            hr = pNode->QueryInterface(__uuidof(IXMLDOMElement), (void **) &pelem);
            
            if (SUCCEEDED(hr)) {
                CComBSTR bstrTag; // remember, never assign anything to this
                hr = pelem->get_tagName(&bstrTag);
                
                if (SUCCEEDED(hr)) {
                    if (!DexCompareW(bstrTag, L"at") || !DexCompareW(bstrTag, L"linear")) { // tagg
                        // remember, never assign anything to this
                        CComBSTR bstrValue = FindAttribute(pelem, L"value"); // tagg 
                        REFERENCE_TIME rtTime = ReadTimeAttribute(pelem, L"time", -1); // tagg
                        
                        // times MUST be pre-sorted in the value list
                        if (pLastValue->rt >= rtTime) {
                            // !!! LOG A MORE USEFUL ERROR?
                            hr = E_INVALIDARG;
                        }
                        
                        ASSERT(pLastValue);
                        if (SUCCEEDED(hr)) {
                            QPropertyValue *pValue = new QPropertyValue;
                            if (!pValue) {
                                hr = E_OUTOFMEMORY;
                            } else {
                                pLastValue->pNext = pValue;
                                pLastValue = pValue;
                                fLoadedProperty = true;
                            }
                        }
                        
                        if (SUCCEEDED(hr)) {
                            pLastValue->dwInterp =
                                (!DexCompareW(bstrTag, L"at")) ? DEXTERF_JUMP // tagg
                                : DEXTERF_INTERPOLATE;
                            pLastValue->rt = rtTime;
                            V_VT(&pLastValue->v) = VT_BSTR;
                            V_BSTR(&pLastValue->v) = bstrValue.Detach( );
                        }
                    } else {
                        // !!! unknown other subtag?
                        
                    }
                } // get_tagName succeded
            } else {
                if(IsCommentElement(pNode))
                {
                    // don't error on comments.
                    hr = S_OK;
                }
            }
        }
    }
    
    // return S_FALSE to indicate there were no properties.
    if(hr == S_OK) {
        return fLoadedProperty ? S_OK : S_FALSE;
    } else {
        return hr;
    }
}


HRESULT CPropertySetter::LoadXML(IUnknown * pUnk)
{
    CheckPointer(pUnk, E_POINTER);
    HRESULT hr = S_OK;
    
    // for some reason, QI'ing pUnk for IXMLDomElement doesn't work!
    IXMLDOMElement * p = (IXMLDOMElement*) pUnk;
    
    CComPtr< IXMLDOMNodeList > pcoll;
    hr = p->get_childNodes(&pcoll);
    
    if (hr != S_OK)
        return S_FALSE; // nothing to do
    
    bool fLoadedProperty = false;
    
    long lChildren = 0;
    hr = pcoll->get_length(&lChildren);
    
    int lVal = 0;                    
    
    for (SUCCEEDED(hr); lVal < lChildren; lVal++) {
        CComPtr< IXMLDOMNode > pNode;
        hr = pcoll->get_item(lVal, &pNode);
        
        if (SUCCEEDED(hr) && pNode) {
            CComPtr< IXMLDOMElement > pelem;
            hr = pNode->QueryInterface(__uuidof(IXMLDOMElement), (void **) &pelem);
            
            if (SUCCEEDED(hr)) {
                // remember, never assign anything to this
                CComBSTR bstrTag; // safe to go away
                hr = pelem->get_tagName(&bstrTag);
                
                if (SUCCEEDED(hr)) {
                    if (!DexCompareW(bstrTag, L"param")) { // tagg
                        // remember, never assign anything to this
                        CComBSTR bstrName = FindAttribute(pelem, L"name"); // tagg
                        
                        if (bstrName) {
                            CComBSTR bstrValue = FindAttribute(pelem, L"value"); // tagg
                            
                            if (!bstrValue) {
                                HRESULT hr2 = pelem->get_text(&bstrValue);
                            }
                            
                            if (m_pLastParam) {
                                QPropertyParam *pParam = new QPropertyParam;
                                if (!pParam)
                                    hr = E_OUTOFMEMORY;
                                else {
                                    m_pLastParam->pNext = pParam;
                                    m_pLastParam = pParam;
                                    fLoadedProperty = true;
                                }
                            } else {
                                m_pLastParam = &m_params;
                                fLoadedProperty = true;
                            }
                            
                            if (SUCCEEDED(hr)) {
                                m_pLastParam->bstrPropName = bstrName.Detach( );
                            }
                            
                            if (bstrValue) {
                                if (SUCCEEDED(hr)) {
                                    V_BSTR(&m_pLastParam->val.v) = bstrValue.Detach( );
                                    V_VT(&m_pLastParam->val.v) = VT_BSTR;
                                    
                                    // now get sub-tags!
                                    hr = LoadOneProperty(pelem, m_pLastParam);
                                    // it's OK if there are none
                                    if (hr == S_FALSE)
                                        hr = S_OK;
                                    
                                }
                            }
                        } else {
                            hr = VFW_E_INVALID_FILE_FORMAT;
                        }
                        
                    } else {
                        // !!! unknown other subtag?
                        
                    }
                } // get_tagName succeeded
            } else {
                if(IsCommentElement(pNode))
                {
                    // don't error on comments.
                    hr = S_OK;
                }
            }
        }
    }
    
    // return S_FALSE to indicate there were no properties.
    if(hr == S_OK) {
        return fLoadedProperty ? S_OK : S_FALSE;
    } else {
        return hr;
    }
}

// we are passed a string to fill, don't go over that size no matter what.
// pCharsInOut on input should have max length of string, including terminator
// pCharsInOut on output will have chars written, not including terminator

HRESULT CPropertySetter::SaveToXMLW(WCHAR * pString, int iIndent, int * pCharsInOut )
{
    // <param name=" " value="...">
    //          <at time="..." value="..."/>
    //          <linear time="..." value="..."/>
    QPropertyParam *pParams = &m_params;

    long MaxLen = *pCharsInOut; // including terminator!
    long len;
    
    // zero return string first
    //
    *pCharsInOut = 0;
    long CurrentLen = 0;
    
    while (pParams) 
    {
        QPropertyValue *pVal = &pParams->val;

        // make room for the indent we're about to print
        // the <= takes care of the extra terminator that could be written
        if( MaxLen <= CurrentLen + ( iIndent * 4 ) )
        {
            return STRSAFE_E_INSUFFICIENT_BUFFER;
        }
        
        CurrentLen += PrintIndentW(pString + CurrentLen, iIndent);
        
        // it may not have been programmed as a BSTR - make it one to save it
        VARIANT v2;
        VariantInit(&v2);
        HRESULT hr = VariantChangeTypeEx(&v2, &pVal->v, US_LCID, 0, VT_BSTR);
        if (FAILED(hr)) 
        {
            ASSERT(FALSE);	// huh?
            return hr;
        }
        
        // what's the length of what we're about to write?
        // 23 = ~length of xml stuff
        // add length of 2 strings
        // 4 = "/>\r\n"
        len = 23 + wcslen( pParams->bstrPropName ) + wcslen( V_BSTR(&v2) ) + 4;
        if( MaxLen <= CurrentLen + len )        
        {
            return STRSAFE_E_INSUFFICIENT_BUFFER;
        }
        
        CurrentLen += wsprintfW( 
            pString + CurrentLen, 
            L"<param name=\"%ls\" value=\"%ls\"", // tagg
            pParams->bstrPropName,
            V_BSTR(&v2) );
        
        VariantClear(&v2);
        
        if (pVal->pNext) 
        {
            // ">\r\n"
            if( MaxLen <= CurrentLen + 3 )            
            {
                return STRSAFE_E_INSUFFICIENT_BUFFER;
            }
            
            CurrentLen += wsprintfW( pString + CurrentLen, L">\r\n" );
            
            while (pVal->pNext) 
            {
                pVal = pVal->pNext;
                
                // it may not have been programmed as a BSTR
                VARIANT v2;
                VariantInit(&v2);
                hr = VariantChangeTypeEx(&v2, &pVal->v, US_LCID, 0, VT_BSTR);
                if (FAILED(hr)) 
                {
                    ASSERT(FALSE);	// huh?
                    return hr;
                }
                
                len = ( iIndent + 1 ) * 4; // make room for indent
                len += wcslen( V_BSTR(&v2 ) ); // make room for value string
                len += 14 + 29; // make room for xml string
                len += 30; // make room for time string (I hate guessing the length of time strings!)
                
                if( MaxLen <= CurrentLen + len )                
                {
                    return STRSAFE_E_INSUFFICIENT_BUFFER;
                }
                
                if (pVal->dwInterp == DEXTERF_JUMP) 
                {
                    CurrentLen += PrintIndentW(pString + CurrentLen, iIndent + 1);
                    CurrentLen += wsprintfW( pString + CurrentLen, L"<at time=\"" ); // tagg
                    CurrentLen += PrintTimeW(pString + CurrentLen, pVal->rt);
                    CurrentLen += wsprintfW(pString + CurrentLen, L"\" value=\"%ls\"/>\r\n", V_BSTR(&v2) ); // tagg
                } 
                else if (pVal->dwInterp == DEXTERF_INTERPOLATE) 
                {
                    CurrentLen += PrintIndentW(pString + CurrentLen, iIndent + 1);
                    CurrentLen += wsprintfW( pString + CurrentLen, L"<linear time=\""); // tagg
                    CurrentLen += PrintTimeW(pString + CurrentLen, pVal->rt);
                    CurrentLen += wsprintfW( pString + CurrentLen, L"\" value=\"%ls\"/>\r\n", V_BSTR(&v2) ); // tagg
                }
                
                VariantClear(&v2);
            }
            
            // 10 = "</param>\r\n"
            if( MaxLen <= CurrentLen + ( iIndent * 4 ) + 10 )
            {
                return STRSAFE_E_INSUFFICIENT_BUFFER;
            }
            
            CurrentLen += PrintIndentW(pString + CurrentLen, iIndent);
            CurrentLen += wsprintfW(pString + CurrentLen, L"</param>\r\n"); // tagg
        } 
        else 
        {
            // we made room for this above, so this is safe
            // no children, just end tag
            CurrentLen += wsprintfW(pString + CurrentLen, L"/>\r\n");
        }
        
        pParams = pParams->pNext;
    }

    // it's safe to put in a terminator, we've already ensured the string is long enough
    pString[CurrentLen] = 0;
    *pCharsInOut = CurrentLen;
    
    return S_OK;
}


// never called by actual dexter code. This is a public API we unfortunately decided to
// implement. We'll just call and convert back to ANSI
//
STDMETHODIMP CPropertySetter::PrintXML(char *pszXML, int cbXML, int *pcbPrinted, int indent)
{
    CheckPointer( pszXML, E_POINTER );
    
    *pcbPrinted = 0;
    *pszXML = 0;
    
    // make a wide string to stuff it to
    //
    WCHAR * wszXML = new WCHAR[cbXML];
    if( !wszXML ) return E_OUTOFMEMORY;
    
    HRESULT hr = PrintXMLW( wszXML, cbXML, pcbPrinted, indent );
    if( FAILED( hr ) )
    {
        delete [] wszXML;
        return hr;
    }
    
    // convert back to A
    //
    USES_CONVERSION;
    lstrcpynA( pszXML, W2A( wszXML ), *pcbPrinted + 1 );
    delete [] wszXML;
    
    return NOERROR;
}


STDMETHODIMP CPropertySetter::PrintXMLW(WCHAR *pszXML, int cchXML, int *pcchPrinted, int indent)
{
    CheckPointer( pszXML, E_POINTER );
    
    int Written = cchXML; // size including terminator
    HRESULT hr = SaveToXMLW( pszXML, indent, &Written );

    if( FAILED( hr ) )
    {
        *pcchPrinted = 0;
        *pszXML = 0;
        
        return hr;
    }

    // size NOT including terminator
    *pcchPrinted = Written;
    return NOERROR;
    
}

// When cloning, it only copies properties stamped between the times given.
// And the new set will be zero based.
// !!! Doesn't split PROGRESS since it isn't in here!
// !!! This could all be much simpler by just changing the times on the 
// existing properties, if static props wouldn't break by doing that
//
STDMETHODIMP CPropertySetter::CloneProps(IPropertySetter **ppSetter, REFERENCE_TIME rtStart, REFERENCE_TIME rtStop)
{
    DbgLog((LOG_TRACE,2,TEXT("CPropSet:CloneProps - %d"),
        (int)(rtStart / 10000)));
    CheckPointer(ppSetter, E_POINTER);
    
    if (rtStart < 0)
        return E_INVALIDARG;
    
    // !!! I have to ignore the stop, or it gets complicated
    
    CPropertySetter *pNew = new CPropertySetter(NULL);
    if (pNew == NULL)
        return E_OUTOFMEMORY;
    pNew->AddRef();
    
    DEXTER_PARAM *pP;
    DEXTER_VALUE *pV;
    LONG c;
    HRESULT hr = GetProps(&c, &pP, &pV);
    if (FAILED(hr)) {
        pNew->Release();
        return hr;
    }
    
    LONG val=0;
    // walk through all the parameters that have (dynamic) values
    for (int z=0; z<c; z++) {
        DEXTER_VALUE *pVNew = NULL;
        int nNew = 0;
        
        // walk through each value
        for (int y=val; y < val+pP[z].nValues; y++) {
            
            // first time through, make space for copying just the values we
            // are interested in (plus one for the initial value)
            if (pVNew == NULL) {
                pVNew = new DEXTER_VALUE[pP[z].nValues + 1];
                if (pVNew == NULL)
                    goto CloneError;
            }
            
            // we only copy properties that start at or after our split time
            if (pV[y].rt >= rtStart) {
                DbgLog((LOG_TRACE,2,TEXT("found time %d"),
                    (int)(pV[y].rt / 10000)));
                
                // If there isn't a property value right on the split time,
                // construct what the initial value for this parameter should be
                if (nNew == 0 && pV[y].rt > rtStart) {
                    ASSERT(y>0);
                    VariantInit(&pVNew[nNew].v);
                    if (pV[y].dwInterp == DEXTERF_JUMP) {
                        // It's just the last value before this time
                        hr = VariantCopy(&pVNew[nNew].v, &pV[y-1].v);
                        DbgLog((LOG_TRACE,2,TEXT("START WITH JUMP")));
                        ASSERT(SUCCEEDED(hr));
                    } else if (pV[y].dwInterp == DEXTERF_INTERPOLATE) {
                        // Figure out what the value would be by doing the
                        // interpolate between the last value and split time.
                        DbgLog((LOG_TRACE,2,TEXT("START WITH INTERP")));
                        VARIANT v2, v;
                        VariantInit(&v2);
                        VariantInit(&v);
                        // okay to change to float, since we're interpolating
                        hr = VariantChangeTypeEx(&v, &pV[y-1].v, US_LCID, 0, VT_R8);
                        ASSERT(SUCCEEDED(hr));
                        hr = VariantChangeTypeEx(&v2, &pV[y].v, US_LCID, 0, VT_R8);
                        ASSERT(SUCCEEDED(hr));
                        double d = (double)(rtStart - pV[y-1].rt) /
                            (pV[y].rt - pV[y-1].rt);
                        V_R8(&v) = (V_R8(&v) * (1-d) + V_R8(&v2) * d);
                        DbgLog((LOG_TRACE,2,TEXT("interp val=%d"),
                            (int)(V_R8(&v))));
                        hr = VariantCopy(&pVNew[nNew].v, &v);
                        ASSERT(SUCCEEDED(hr));
                        VariantClear(&v);
                        VariantClear(&v2);
                    } else {
                        ASSERT(FALSE);
                        // Ooh! Imagine how much fun spline code would be!
                    }	
                    // The first value is always a jump at time 0
                    pVNew[nNew].rt = 0;
                    pVNew[nNew].dwInterp = DEXTERF_JUMP;
                    nNew++;
                }
                
                // Now copy the value over to our new list of values, offset in
                // time by the split time
                VariantInit(&pVNew[nNew].v);
                hr = VariantCopy(&pVNew[nNew].v, &pV[y].v);
                ASSERT(SUCCEEDED(hr));
                if (FAILED(hr)) {
                    for (y=0; y<nNew; y++)
                        VariantClear(&pVNew[y].v);
                    delete [] pVNew;
                    goto CloneError;
                }
                pVNew[nNew].rt = pV[y].rt - rtStart;
                // The first value is always a jump, otherwise it stays the same
                if (nNew == 0)
                    pVNew[nNew].dwInterp = DEXTERF_JUMP;
                else
                    pVNew[nNew].dwInterp = pV[y].dwInterp;
                DbgLog((LOG_TRACE,2,TEXT("next is now at time %d"),
                    (int)(pVNew[nNew].rt / 10000)));
                
                nNew++;
            }
        }
        
        if (nNew) {
            // Add the new values we constructed to the new property setter
            int n = pP[z].nValues;
            pP[z].nValues = nNew;  // temporarily change this, we're adding nNew
            hr = pNew->AddProp(pP[z], pVNew);
            pP[z].nValues = n;
            ASSERT(SUCCEEDED(hr));
            for (y=0; y<nNew; y++)
                VariantClear(&pVNew[y].v);
            delete [] pVNew;
            if (FAILED(hr)) {
                goto CloneError;
            }
            
            // There are no values set after the split time.  Use the most recent
            // value before the split time as the new static value
        } else if (pP[z].nValues) {
            y = val + pP[z].nValues - 1;
            VariantInit(&pVNew[0].v);
            hr = VariantCopy(&pVNew[0].v, &pV[y].v);
            ASSERT(SUCCEEDED(hr));
            if (SUCCEEDED(hr)) {
                DbgLog((LOG_TRACE,2,TEXT("Using last value")));
                pVNew[0].rt = 0;
                pVNew[0].dwInterp = DEXTERF_JUMP;
                int n = pP[z].nValues;
                pP[z].nValues = 1;  // temporarily change this, we're adding 1
                hr = pNew->AddProp(pP[z], pVNew);
                pP[z].nValues = n;
                ASSERT(SUCCEEDED(hr));
                VariantClear(&pVNew[0].v);
            }
            delete [] pVNew;
            if (FAILED(hr)) {
                goto CloneError;
            }
        }
        val += pP[z].nValues;
    }
    
    FreeProps(c, pP, pV);
    *ppSetter = pNew;
    return S_OK;
    
CloneError:
    FreeProps(c, pP, pV);
    pNew->ClearProps();
    pNew->Release();
    return hr;
}


// !!! allow them to set/clear individual values of a parameter?
//
STDMETHODIMP CPropertySetter::AddProp(DEXTER_PARAM Param, DEXTER_VALUE *paValue)
{
    HRESULT hr;
    CheckPointer(paValue, E_POINTER);
    
    if (Param.nValues <= 0)
        return E_INVALIDARG;
    
    // !!! better error?
    // first value must be 0
    if (paValue[0].rt != 0)
        return E_INVALIDARG;
    
    // caller must provide values pre-sorted!
    if (Param.nValues > 1) {
        for (int z=1; z<Param.nValues; z++) {
            if (paValue[z].rt <= paValue[z-1].rt)
                return E_INVALIDARG;
        }
    }
    
    if (m_pLastParam) {
        QPropertyParam *pParam = new QPropertyParam;
        if (!pParam)
            return E_OUTOFMEMORY;
        else {
            m_pLastParam->pNext = pParam;
            m_pLastParam = pParam;
        }
    } else {
        m_pLastParam = &m_params;
        m_pLastParam->pNext = NULL;	// won't be cleared
    }
    
    m_pLastParam->bstrPropName = SysAllocString(Param.Name);
    if (m_pLastParam->bstrPropName == NULL)
        return E_OUTOFMEMORY;
    m_pLastParam->dispID = 0;
    
    VariantInit(&m_pLastParam->val.v);
    hr = VariantCopy(&m_pLastParam->val.v, &paValue->v);
    ASSERT(SUCCEEDED(hr));
    m_pLastParam->val.rt = paValue->rt;
    m_pLastParam->val.dwInterp = paValue->dwInterp;
    
    QPropertyValue *pLastValue = &m_pLastParam->val;
    for (int z=1; z<Param.nValues; z++) {
        
        QPropertyValue *pValue = new QPropertyValue;
        if (!pValue)
            return E_OUTOFMEMORY;	// free anything now?
        else {
            pLastValue->pNext = pValue;
            pLastValue = pValue;
        }
        
        pLastValue->dwInterp = paValue[z].dwInterp;
        pLastValue->rt = paValue[z].rt;
        VariantInit(&pLastValue->v);
        hr = VariantCopy(&pLastValue->v, &paValue[z].v);
        ASSERT(SUCCEEDED(hr));
    }
    return S_OK;
}


// Caller must free the BSTR in each Param, and the BSTR in the VARIANT in
// each Value
//
STDMETHODIMP CPropertySetter::GetProps(LONG *pcParams, DEXTER_PARAM **paParam, DEXTER_VALUE **paValue)
{
    CheckPointer(pcParams, E_POINTER);
    CheckPointer(paParam, E_POINTER);
    CheckPointer(paValue, E_POINTER);
    
    if (m_pLastParam == NULL) {
        *pcParams = 0;
        return S_OK;
    }
    
    QPropertyParam *p = &m_params;
    QPropertyValue *v;
    
    // count things
    *pcParams = 0;
    LONG cVals = 0;
    while (p) {
        v = &(p->val);
        while (v) {
            cVals++;
            v = v->pNext;
        }
        (*pcParams)++;
        p = p->pNext;
    }
    DbgLog((LOG_TRACE,2,TEXT("CPropSet:GetProps - %d params"), (int)*pcParams));
    
    // allocate space
    *paParam = (DEXTER_PARAM *)CoTaskMemAlloc(*pcParams * sizeof(DEXTER_PARAM));
    if (*paParam == NULL)
        return E_OUTOFMEMORY;
    *paValue = (DEXTER_VALUE *)CoTaskMemAlloc(cVals * sizeof(DEXTER_VALUE));
    if (*paValue == NULL) {
        CoTaskMemFree(*paParam);
        return E_OUTOFMEMORY;
    }
    
    // do it
    p = &m_params;
    *pcParams = 0;
    LONG cValsTot = 0;
    while (p) {
        (*paParam)[*pcParams].Name = SysAllocString(p->bstrPropName);
        if ((*paParam)[*pcParams].Name == NULL)
            return E_OUTOFMEMORY;	// !!! leaks
        (*paParam)[*pcParams].dispID = p->dispID;
        v = &(p->val);
        cVals = 0;
        while (v) {
            (*paValue)[cValsTot].rt = v->rt;
            VariantInit(&(*paValue)[cValsTot].v);
            HRESULT hr = VariantCopy(&(*paValue)[cValsTot].v, &v->v);
            ASSERT(SUCCEEDED(hr));
            (*paValue)[cValsTot].dwInterp = v->dwInterp;
            cValsTot++;
            cVals++;
            v = v->pNext;
        }
        (*paParam)[*pcParams].nValues = cVals;
        (*pcParams)++;
        p = p->pNext;
    }
    return S_OK;
}


// And the Lord said:  "Whosoever shall call GetProps must subsequently call
// FreeProps!!"  And it was a good idea.
//
STDMETHODIMP CPropertySetter::FreeProps(LONG cParams, DEXTER_PARAM *pParam, DEXTER_VALUE *pValue)
{
    if (cParams == 0)
        return S_OK;
    LONG v = 0;
    for (LONG zz=0; zz<cParams; zz++) {
        SysFreeString(pParam[zz].Name);
        for (LONG yy=0; yy < pParam[zz].nValues; yy++) {
            VariantClear(&pValue[v+yy].v);
        }
        v += pParam[zz].nValues;
    }
    CoTaskMemFree(pParam);
    CoTaskMemFree(pValue);
    return S_OK;
}


// Nuke everything, start over
//
STDMETHODIMP CPropertySetter::ClearProps()
{
    if (m_pLastParam == NULL)
        return S_OK;
    QPropertyParam *p = &m_params, *t1;
    QPropertyValue *t2, *r;
    while (p) {
        r = &p->val;
        while (r) {
            VariantClear(&r->v);
            t2 = r->pNext;
            if (r != &p->val)
                delete r;
            r = t2;
        }
        SysFreeString(p->bstrPropName);
        t1 = p->pNext;
        if (p != &m_params)
            delete p;
        p = t1;
    }
    m_pLastParam = NULL;
    return S_OK;
}

// version of the structures with no pointers that is saveable.

const int MAX_BLOB_PARAM_NAME_LEN = 40; // !!!

typedef struct
{
    WCHAR Name[MAX_BLOB_PARAM_NAME_LEN];
    DISPID dispID;
    LONG nValues;
} DEXTER_PARAM_BLOB;

typedef struct
{
    WCHAR wchName[MAX_BLOB_PARAM_NAME_LEN];
    REFERENCE_TIME rt;
    DWORD dwInterp;
} DEXTER_VALUE_BLOB;


// !!! This should do versioning

STDMETHODIMP CPropertySetter::SaveToBlob(LONG *pcSize, BYTE **ppSave)
{
    CheckPointer(ppSave, E_POINTER);
    CheckPointer(pcSize, E_POINTER);
    
    LONG cParams = 0;
    DEXTER_PARAM *param;
    DEXTER_VALUE *value;
    
    // get the properties
    HRESULT hr = GetProps(&cParams, &param, &value);
    if (FAILED(hr)) {
        return hr;
    }
    
    DbgLog((LOG_TRACE,2,TEXT("CPropSet:SaveToBlob - %d params to save"),
        (int)cParams));
    
    // count up the total # of values
    LONG cValues = 0;
    for (LONG z=0; z<cParams; z++) {
        cValues += param[z].nValues;
        DbgLog((LOG_TRACE,2,TEXT("Param %d has %d values"), (int)z, 
            (int)param[z].nValues));
    }
    
    // find out how big to make the blob
    LONG size = sizeof(LONG) + cParams * sizeof(DEXTER_PARAM_BLOB) +
        cValues * sizeof(DEXTER_VALUE_BLOB);
    *pcSize = size;
    DbgLog((LOG_TRACE,2,TEXT("Total prop size = %d"), (int)size));
    
    *ppSave = (BYTE *)CoTaskMemAlloc(size);
    if (*ppSave == NULL) {
        FreeProps(cParams, param, value);
        return E_OUTOFMEMORY;
    }
    BYTE *pSave = *ppSave;
    
    // how many param structures for this effect?
    *((LONG *)pSave) = cParams;
    pSave += sizeof(LONG);
    
    // save the param structures
    DEXTER_PARAM_BLOB *pParam = (DEXTER_PARAM_BLOB *)pSave;
    for (z=0; z<cParams; z++) {
        lstrcpynW(pParam[z].Name, param[z].Name, MAX_BLOB_PARAM_NAME_LEN); 	// !!!
        pParam[z].dispID = param[z].dispID;
        pParam[z].nValues = param[z].nValues;
    }
    pSave += cParams * sizeof(DEXTER_PARAM_BLOB);
    
    // save the values
    DEXTER_VALUE_BLOB *pValue = (DEXTER_VALUE_BLOB *)pSave;
    for (z=0; z<cValues; z++) {
        // always save as BSTR
        if (value[z].v.vt == VT_BSTR) {
            lstrcpynW(pValue[z].wchName, value[z].v.bstrVal, MAX_BLOB_PARAM_NAME_LEN);	// !!!
        } else {
            VARIANT v;
            VariantInit(&v);
            hr = VariantChangeTypeEx(&v, &value[z].v, US_LCID, 0, VT_BSTR);
            ASSERT (SUCCEEDED(hr));
            if (FAILED(hr))
                return hr;	// !!! leaks
            lstrcpynW(pValue[z].wchName, v.bstrVal, MAX_BLOB_PARAM_NAME_LEN);	// !!!
            VariantClear(&v);
        }
        pValue[z].rt = value[z].rt;
        pValue[z].dwInterp = value[z].dwInterp;
    }
    
    FreeProps(cParams, param, value);
    return S_OK;
}


STDMETHODIMP CPropertySetter::LoadFromBlob(LONG cSize, BYTE *pSave)
{
    
    LONG cParams = *(LONG *)pSave;
    DbgLog((LOG_TRACE,2,TEXT("CPropSet:LoadFromBlob - %d params"),
        (int)cParams));
    
    pSave += sizeof(LONG);
    
    ClearProps();	// start fresh
    
    if (cParams) {
        DEXTER_PARAM_BLOB *pParamB = (DEXTER_PARAM_BLOB *)pSave;
        DEXTER_VALUE_BLOB *pValueB = (DEXTER_VALUE_BLOB *)(pSave + cParams
            * sizeof(DEXTER_PARAM_BLOB));
        for (LONG z = 0; z < cParams; z++) {
            DEXTER_PARAM param;
            LONG nValues = pParamB->nValues;
            DbgLog((LOG_TRACE,2,TEXT("Param %d has %d values"), (int)z,
                (int)nValues));
            DEXTER_VALUE *pValue = (DEXTER_VALUE *)CoTaskMemAlloc(
                nValues * sizeof(DEXTER_VALUE));
            
            param.Name = SysAllocString(pParamB->Name);
            if (param.Name == NULL)
                return E_OUTOFMEMORY;	// !!! leaks?
            param.dispID = pParamB->dispID;
            param.nValues = pParamB->nValues;
            for (LONG y=0; y<nValues; y++) {
                pValue[y].rt = pValueB[y].rt;
                pValue[y].dwInterp = pValueB[y].dwInterp;
                BSTR abstr = SysAllocString(pValueB[y].wchName);
                if (abstr == NULL)
                    return E_OUTOFMEMORY;	// !!! leaks?
                pValue[y].v.vt = VT_BSTR;
                pValue[y].v.bstrVal = abstr;
            }
            
            HRESULT hr = AddProp(param, pValue);
            SysFreeString(param.Name);
            for (y=0; y<nValues; y++) {
                VariantClear(&pValue[y].v);
            }
            CoTaskMemFree(pValue);
            if (FAILED(hr)) {
                return hr;
            }
            pParamB += 1;
            pValueB += nValues;
        }
    }
    return S_OK;
}
=== C:/Users/treeman/Desktop/windows nt source code\Source\Win2K3\NT\multimedia\dshow\filterus\dexter\xmltl\xmltl.cpp ===
//@@@@AUTOBLOCK+============================================================;
//
//  THIS CODE AND INFORMATION IS PROVIDED "AS IS" WITHOUT WARRANTY OF ANY
//  KIND, EITHER EXPRESSED OR IMPLIED, INCLUDING BUT NOT LIMITED TO THE
//  IMPLIED WARRANTIES OF MERCHANTABILITY AND/OR FITNESS FOR A PARTICULAR
//  PURPOSE.
//
//  File: xmltl.cpp
//
//  Copyright (c) Microsoft Corporation.  All Rights Reserved.
//
//@@@@AUTOBLOCK-============================================================;

#include <streams.h>
#include <atlbase.h>
#include <atlconv.h>
#include <msxml.h>

#include "xmldom.h"
#include "qeditint.h"
#include "qedit.h"
#include "xmltl.h"
#include "..\util\dexmisc.h"
#include "..\util\filfuncs.h"
#include "varyprop.h"
#include "xtlprint.h"
#include "xtlcommon.h"
#define STRSAFE_NO_DEPRECATE
#include <strsafe.h>
#include "varyprop.cpp"		// can't include qxmlhelp.h twice

// forward decls
HRESULT BuildOneElement(IAMTimeline *pTL, IAMTimelineObj *pParent, IXMLDOMElement *p, REFERENCE_TIME rtOffset);

bool IsCommentElement(IXMLDOMNode *p)
{
    DOMNodeType Type;
    if(p->get_nodeType(&Type) == S_OK && Type == NODE_COMMENT) {
        return true;
    }

    // there was an error or it's not a comment
    return false;
}

HRESULT BuildChildren(IAMTimeline *pTL, IAMTimelineObj *pParent, IXMLDOMElement *pxml, REFERENCE_TIME rtOffset)
{
    HRESULT hr = S_OK;

    CComPtr< IXMLDOMNodeList > pcoll;

    CComQIPtr<IXMLDOMNode, &IID_IXMLDOMNode> pNode( pxml );

    hr = pNode->get_childNodes(&pcoll);
    ASSERT(hr == S_OK);

    if (hr != S_OK)
	return S_OK; // nothing to do, is this an error?

    long lChildren = 0;
    hr = pcoll->get_length(&lChildren);
    ASSERT(hr == S_OK);

    int lVal = 0;

    for (; SUCCEEDED(hr) && lVal < lChildren; lVal++) {
	CComPtr< IXMLDOMNode > pNode;
	hr = pcoll->get_item(lVal, &pNode);
	ASSERT(hr == S_OK);

	if (SUCCEEDED(hr) && pNode) {
	    CComPtr< IXMLDOMElement > pelem;
	    hr = pNode->QueryInterface(__uuidof(IXMLDOMElement), (void **) &pelem);
	    if (SUCCEEDED(hr)) {
		hr = BuildOneElement(pTL, pParent, pelem, rtOffset);
	    } else {
                // just skip over comments.
                if(IsCommentElement(pNode)) {
                    hr = S_OK;
                }
            }
	}
    }

    return hr;
}	

HRESULT ReadObjStuff(IXMLDOMElement *p, IAMTimelineObj *pObj)
{
    HRESULT hr = 0;

    REFERENCE_TIME rtStart = ReadTimeAttribute(p, L"start", -1); // tagg
    REFERENCE_TIME rtStop = ReadTimeAttribute(p, L"stop", -1); // tagg
    // caller will handle it if stop is missing
    if (rtStop != -1) {
        hr = pObj->SetStartStop(rtStart, rtStop);
        // group/comp/track will fail this
    }
    // backwards compatability
    if (rtStart == -1) {
        REFERENCE_TIME rtTLStart = ReadTimeAttribute(p, L"tlstart", -1); // tagg
        REFERENCE_TIME rtTLStop = ReadTimeAttribute(p, L"tlstop", -1); // tagg
        // caller will handle it if stop is missing
        if (rtTLStop != -1) {
            hr = pObj->SetStartStop(rtTLStart, rtTLStop);
            ASSERT(SUCCEEDED(hr));
        }
    }

    BOOL fMute = ReadBoolAttribute(p, L"mute", FALSE); // tagg
    pObj->SetMuted(fMute);

    BOOL fLock = ReadBoolAttribute(p, L"lock", FALSE); // tagg
    pObj->SetLocked(fLock);

    long nUserID = ReadNumAttribute(p, L"userid", 0); // tagg
    pObj->SetUserID(nUserID);

    // remember, never assign anything to this
    CComBSTR bstrName = FindAttribute(p, L"username"); // tagg
    hr = pObj->SetUserName(bstrName);
    if( FAILED( hr ) )
    {
        return hr;
    }

    // remember, never assign anything to this
    CComBSTR bstrData = FindAttribute(p, L"userdata"); // tagg
    UINT size = 0;
    if (bstrData) {
        size = lstrlenW(bstrData);
    }
    if (size > 0) {
        BYTE *pData = (BYTE *)QzTaskMemAlloc(size / 2);
        if (pData == NULL) {
            return E_OUTOFMEMORY;
        }
        ZeroMemory(pData, size / 2);
        ASSERT((size % 2) == 0);
        for (UINT i = 0; i < size / 2; i++) {
            WCHAR wch = bstrData[i * 2];
            if (wch >= L'0' && wch <= L'9')
                pData[i] = (BYTE) (wch - L'0') * 16;
            else if (wch >= L'A' && wch <= L'F')
                pData[i] = (BYTE) (wch - L'A' + 10) * 16;

            wch = bstrData[i * 2 + 1];
            if (wch >= L'0' && wch <= L'9')
                pData[i] += (BYTE) (wch - L'0');
            else if (wch >= L'A' && wch <= L'F')
                pData[i] += (BYTE) (wch - L'A' + 10);
        }
        hr = pObj->SetUserData(pData, size / 2);
        QzTaskMemFree(pData);
    } // if size > 0
    if( FAILED( hr ) )
    {
        return hr;
    }

    CLSID guid;
    // remember, never assign anything to this
    CComBSTR bstrCLSID = FindAttribute(p, L"clsid"); // tagg
    if (bstrCLSID) {
        hr = CLSIDFromString(bstrCLSID, &guid);
        if( FAILED( hr ) )
        {
            return E_INVALIDARG;
        }
        hr = pObj->SetSubObjectGUID(guid);
        if( FAILED( hr ) )
        {
            return hr;
        }
    }

    // !!! can't do SubObject
    // !!! category/instance will only save clsid

    return S_OK;
}

HRESULT BuildTrackOrComp(IAMTimeline *pTL, IAMTimelineObj *pParent, IXMLDOMElement *p,
                        TIMELINE_MAJOR_TYPE maj, REFERENCE_TIME rtOffset)
{
    HRESULT hr = S_OK;

    //ASSERT(pParent && "<track> must be in a <group> tag now!");
    if (!pParent) {
        DbgLog((LOG_ERROR,0,"ERROR: track must be in a GROUP tag"));
        return VFW_E_INVALID_FILE_FORMAT;
    }

    CComPtr< IAMTimelineComp > pParentComp;
    hr = pParent->QueryInterface(__uuidof(IAMTimelineComp), (void **) &pParentComp);
    if (SUCCEEDED(hr)) {
        CComPtr< IAMTimelineObj> pCompOrTrack;

        hr = pTL->CreateEmptyNode(&pCompOrTrack, maj);
        if (SUCCEEDED(hr)) {
            hr = ReadObjStuff(p, pCompOrTrack);
        } else {
            DbgLog((LOG_ERROR,0,TEXT("ERROR:Failed to create empty track node")));
        }
        if( SUCCEEDED( hr ) ) {
            hr = pParentComp->VTrackInsBefore( pCompOrTrack, -1 );
        }

        if (SUCCEEDED(hr)) {
            hr = BuildChildren(pTL, pCompOrTrack, p, rtOffset);
        }

    } else {
        DbgLog((LOG_ERROR, 0, "ERROR: Track/composition can only be a child of a composition"));
    }

    return hr;
}

HRESULT BuildElementProperties(IAMTimelineObj *pElem, IXMLDOMElement *p)
{
    CComPtr< IPropertySetter> pSetter;

    HRESULT hr = CPropertySetter::CreatePropertySetterInstanceFromXML(&pSetter, p);

    if (FAILED(hr))
        return hr;

    if (pSetter) {
        pElem->SetPropertySetter(pSetter);
    }

    return S_OK;
}



HRESULT BuildOneElement(IAMTimeline *pTL, IAMTimelineObj *pParent, IXMLDOMElement *p, REFERENCE_TIME rtOffset)
{
    HRESULT hr = S_OK;

    // remember, never assign anything to this
    CComBSTR bstrName;
    hr = p->get_tagName(&bstrName);

    if (FAILED(hr))
    {
        return hr;
    }

    // do the appropriate thing based on the current tag
 
    if (!DexCompareW(bstrName, L"group")) { // tagg

        if (pParent) {
            // group shouldn't have parent
            return VFW_E_INVALID_FILE_FORMAT;
        }

        CComPtr< IAMTimelineObj> pGroupObj;

        // remember, never assign anything to this
        CComBSTR bstrGName = FindAttribute(p, L"name"); // tagg
        if (bstrGName) {
            long cGroups;
            hr = pTL->GetGroupCount(&cGroups);
            if (SUCCEEDED(hr)) {
                for (long lGroup = 0; lGroup < cGroups; lGroup++) {
                    CComPtr< IAMTimelineObj> pExistingGroupObj;
                    hr = pTL->GetGroup(&pExistingGroupObj, lGroup);
                    if (FAILED(hr))
                        break;

                    CComPtr< IAMTimelineGroup> pGroup;
                    hr = pExistingGroupObj->QueryInterface(__uuidof(IAMTimelineGroup), (void **) &pGroup);

                    if (SUCCEEDED(hr)) {
                        // remember, never assign anything to this
                        CComBSTR wName;
                        hr = pGroup->GetGroupName(&wName);

                        if( FAILED( hr ) )
                            break;

                        long iiiii = DexCompareW(wName, bstrGName);

                        if (iiiii == 0 ) {
                            pGroupObj = pExistingGroupObj;
                            break;
                        }
                    }
                }
            }
        }

        if (!pGroupObj) {
            hr = pTL->CreateEmptyNode(&pGroupObj, TIMELINE_MAJOR_TYPE_GROUP);
            if (FAILED(hr)) {
                return hr;
            }

            hr = ReadObjStuff(p, pGroupObj);

            // remember, never assign anything to this
            CComBSTR bstrType = FindAttribute(p, L"type"); // tagg
            {
                // !!! can be confused by colons - only decimal supported
                REFERENCE_TIME llfps = ReadTimeAttribute(p, L"framerate", // tagg
                                                                15*UNITS);
                double fps = (double)llfps / UNITS;

                BOOL fPreviewMode = ReadBoolAttribute(p, L"previewmode", TRUE); // tagg
                long nBuffering = ReadNumAttribute(p, L"buffering", 30); // tagg

                CMediaType GroupMediaType;
                // !!! fill in more of the MediaType later
                if (bstrType && 
                        !DexCompareW(bstrType, L"audio")) {
                    long sr = ReadNumAttribute(p, L"samplingrate", // tagg
                                                        DEF_SAMPLERATE);
                    GroupMediaType.majortype = MEDIATYPE_Audio;
                    GroupMediaType.subtype = MEDIASUBTYPE_PCM;
                    GroupMediaType.formattype = FORMAT_WaveFormatEx;
                    GroupMediaType.AllocFormatBuffer(sizeof(WAVEFORMATEX));
                    GroupMediaType.SetSampleSize(4);
                    WAVEFORMATEX * vih = (WAVEFORMATEX*)GroupMediaType.Format();
                    ZeroMemory( vih, sizeof( WAVEFORMATEX ) );
                    vih->wFormatTag = WAVE_FORMAT_PCM;
                    vih->nChannels = 2;
                    vih->nSamplesPerSec = sr;
                    vih->nBlockAlign = 4;
                    vih->nAvgBytesPerSec = vih->nBlockAlign * sr;
                    vih->wBitsPerSample = 16;
                } else if (bstrType && 
                        !DexCompareW(bstrType, L"video")) {
                    long w = ReadNumAttribute(p, L"width", DEF_WIDTH); // tagg
                    long h = ReadNumAttribute(p, L"height", DEF_HEIGHT); // tagg 
                    long b = ReadNumAttribute(p, L"bitdepth", DEF_BITDEPTH); // tagg
                    GroupMediaType.majortype = MEDIATYPE_Video;
                    if (b == 16)
                        GroupMediaType.subtype = MEDIASUBTYPE_RGB555;
                    else if (b == 24)
                        GroupMediaType.subtype = MEDIASUBTYPE_RGB24;
                    else if (b == 32)
                        GroupMediaType.subtype = MEDIASUBTYPE_ARGB32;
                    GroupMediaType.formattype = FORMAT_VideoInfo;
                    GroupMediaType.AllocFormatBuffer(sizeof(VIDEOINFOHEADER));
                    VIDEOINFOHEADER * vih = (VIDEOINFOHEADER*)
                                                GroupMediaType.Format();
                    ZeroMemory(vih, sizeof(VIDEOINFOHEADER));
                    vih->bmiHeader.biBitCount = (WORD)b;
                    vih->bmiHeader.biWidth = w;
                    vih->bmiHeader.biHeight = h;
                    vih->bmiHeader.biPlanes = 1;
                    vih->bmiHeader.biSize = sizeof(BITMAPINFOHEADER);
                    vih->bmiHeader.biSizeImage = DIBSIZE(vih->bmiHeader);
                    GroupMediaType.SetSampleSize(DIBSIZE(vih->bmiHeader));
                } else {
                    return E_INVALIDARG;
                }
                CComPtr< IAMTimelineGroup> pGroup;
                hr = pGroupObj->QueryInterface(__uuidof(IAMTimelineGroup), (void **) &pGroup);
                if (SUCCEEDED(hr)) {
                    if (bstrGName) {
                        pGroup->SetGroupName(bstrGName);
                    }
                    hr = pGroup->SetMediaType( &GroupMediaType );
                    if (FAILED(hr)) {
                        // !!! be nice and tell them the group #?
                        _TimelineError(pTL, 2, DEX_IDS_BAD_MEDIATYPE, hr);
                    }
                    // you're on your own if fps is <=0, you should know better
                    pGroup->SetOutputFPS( fps );
                    pGroup->SetPreviewMode( fPreviewMode );
                    pGroup->SetOutputBuffering( nBuffering );
                }
            }

            if (SUCCEEDED(hr))
                 hr = pTL->AddGroup(pGroupObj);
        }

        if (SUCCEEDED(hr))
            hr = BuildChildren(pTL, pGroupObj, p, rtOffset);

    } else if (!DexCompareW(bstrName, L"composite") || // tagg
    !DexCompareW(bstrName, L"timeline")) { // tagg
        hr = BuildTrackOrComp(pTL, pParent, p, TIMELINE_MAJOR_TYPE_COMPOSITE,
                              rtOffset );
    } else if (!DexCompareW(bstrName, L"track") || // tagg
    !DexCompareW(bstrName, L"vtrack") || // tagg
    !DexCompareW(bstrName, L"atrack")) { // tagg
	// create track
        hr = BuildTrackOrComp(pTL, pParent, p, TIMELINE_MAJOR_TYPE_TRACK,
                              rtOffset );
    } else if (!DexCompareW(bstrName, L"clip") || // tagg
    !DexCompareW(bstrName, L"daclip")) { // tagg

	// create the timeline source
	//
	CComPtr< IAMTimelineObj> pSourceObj;
	hr = pTL->CreateEmptyNode(&pSourceObj, TIMELINE_MAJOR_TYPE_SOURCE);

	if (FAILED(hr)) {
	    goto ClipError;
	}

      {
	// every object has this
	hr = ReadObjStuff(p, pSourceObj);

	// clip objects also support...

        // remember, never assign anything to this
	CComBSTR bstrSrc = FindAttribute(p, L"src"); // tagg
        // remember, never assign anything to this
	CComBSTR bstrStretchMode = FindAttribute(p, L"stretchmode"); // tagg
	REFERENCE_TIME rtMStart = ReadTimeAttribute(p, L"mstart", -1); // tagg
	REFERENCE_TIME rtMStop = ReadTimeAttribute(p, L"mstop", -1); // tagg
	REFERENCE_TIME rtMLen = ReadTimeAttribute(p, L"mlength", 0); // tagg
        long StreamNum = ReadNumAttribute(p, L"stream", 0); // tagg

	// do these 2 again so we can do a default stop
	REFERENCE_TIME rtStart = ReadTimeAttribute(p, L"start", -1); // tagg
	REFERENCE_TIME rtStop = ReadTimeAttribute(p, L"stop", -1); // tagg
	// backwards compat
	if (rtStart == -1) {
	    rtStart = ReadTimeAttribute(p, L"tlstart", -1); // tagg
	    rtStop = ReadTimeAttribute(p, L"tlstop", -1); // tagg
	}

        // default to something reasonable
        if (rtStart == -1 && rtStop == -1)
            rtStart = 0;

	// !!! can be confused by colons - only decimal supported
	REFERENCE_TIME llfps = ReadTimeAttribute(p, L"framerate", 0); // tagg
	double fps = (double)llfps / UNITS;

        if (rtStop == -1 && rtMStop != -1) {
	    // default tstop
            rtStop = rtStart + (rtMStop - rtMStart);
	    pSourceObj->SetStartStop(rtStart, rtStop);
        }
        if (rtMStop == -1 && rtMStart != -1 && rtStop != -1) {
            // default mstop
            rtMStop = rtMStart + (rtStop - rtStart);
        }

	int StretchMode = RESIZEF_STRETCH;
	if (bstrStretchMode && 
              !DexCompareW(bstrStretchMode, L"crop"))
	    StretchMode = RESIZEF_CROP;
	else if (bstrStretchMode && 
    !DexCompareW(bstrStretchMode, L"PreserveAspectRatio"))
	    StretchMode = RESIZEF_PRESERVEASPECTRATIO;
	else if (bstrStretchMode &&
    !DexCompareW(bstrStretchMode, L"PreserveAspectRatioNoLetterbox"))
	    StretchMode = RESIZEF_PRESERVEASPECTRATIO_NOLETTERBOX;
	
        // support "daclip" hack
        CLSID clsidSrc = GUID_NULL;
        if (!DexCompareW(bstrName, L"daclip")) { // tagg
            clsidSrc = __uuidof(DAScriptParser);
            hr = pSourceObj->SetSubObjectGUID(clsidSrc);
            ASSERT(hr == S_OK);
        }

	CComPtr< IAMTimelineSrc> pSourceSrc;

        hr = pSourceObj->QueryInterface(__uuidof(IAMTimelineSrc), (void **) &pSourceSrc);
	    ASSERT(SUCCEEDED(hr));
            if (SUCCEEDED(hr)) {
		hr = S_OK;
		if (rtMStart != -1 && rtMStop != -1)
                    hr = pSourceSrc->SetMediaTimes(rtMStart, rtMStop);
		ASSERT(hr == S_OK);
                if (bstrSrc) {
                    hr = pSourceSrc->SetMediaName(bstrSrc);
                    ASSERT(hr == S_OK);
                }
                pSourceSrc->SetMediaLength(rtMLen);
		pSourceSrc->SetDefaultFPS(fps);
		pSourceSrc->SetStretchMode(StretchMode);
                pSourceSrc->SetStreamNumber( StreamNum );
            }

	    if (SUCCEEDED(hr)) {
                CComPtr< IAMTimelineTrack> pRealTrack;
                hr = pParent->QueryInterface(__uuidof(IAMTimelineTrack),
							(void **) &pRealTrack);
                if (SUCCEEDED(hr)) {
                    hr = pRealTrack->SrcAdd(pSourceObj);
		    ASSERT(hr == S_OK);
                } else {
	            DbgLog((LOG_ERROR, 0, "ERROR: Clip must be a child of a track"));
	        }
	    }

            if (SUCCEEDED(hr)) {
                // any effects on this source
                hr = BuildChildren(pTL, pSourceObj, p, rtOffset);
            }

            if (SUCCEEDED(hr)) {
                // any parameters on this source?
                // !!! should/must this be combined with the BuildChildren above which
                // !!! also enumerates any subtags?
                hr = BuildElementProperties(pSourceObj, p);
            }

      }
ClipError:;

    } else if (!DexCompareW(bstrName, L"effect")) { // tagg
	// <effect

        CComPtr< IAMTimelineObj> pTimelineObj;
    	// create the timeline effect
        //
        hr = pTL->CreateEmptyNode(&pTimelineObj,TIMELINE_MAJOR_TYPE_EFFECT);
	ASSERT(hr == S_OK);
	if (FAILED(hr)) {
	    return hr;
	}

	hr = ReadObjStuff(p, pTimelineObj);

	CComPtr< IAMTimelineEffectable> pEffectable;
	hr = pParent->QueryInterface(__uuidof(IAMTimelineEffectable), (void **) &pEffectable);

	if (SUCCEEDED(hr)) {
	    hr = pEffectable->EffectInsBefore( pTimelineObj, -1 );
	    ASSERT(hr == S_OK);
	} else {
	    DbgLog((LOG_ERROR, 0, "ERROR: Effect cannot be a child of this object"));
	}

	if (SUCCEEDED(hr)) {
	    hr = BuildElementProperties(pTimelineObj, p);
	}

    } else if (!DexCompareW(bstrName, L"transition")) { // tagg
	// <transition

        CComPtr< IAMTimelineObj> pTimelineObj;
    	// create the timeline effect
        //
        hr = pTL->CreateEmptyNode(&pTimelineObj,TIMELINE_MAJOR_TYPE_TRANSITION);
	ASSERT(hr == S_OK);
	if (FAILED(hr)) {
	    return hr;
	}

	hr = ReadObjStuff(p, pTimelineObj);

	REFERENCE_TIME rtCut = ReadTimeAttribute(p, L"cutpoint", -1); // tagg
	BOOL fSwapInputs = ReadBoolAttribute(p, L"swapinputs", FALSE); // tagg
	BOOL fCutsOnly = ReadBoolAttribute(p, L"cutsonly", FALSE); // tagg

            // set up filter right
            if (rtCut >= 0 || fSwapInputs || fCutsOnly) {
                CComPtr< IAMTimelineTrans> pTimeTrans;
                hr = pTimelineObj->QueryInterface(__uuidof(IAMTimelineTrans), (void **) &pTimeTrans);
		ASSERT(SUCCEEDED(hr));

                if (SUCCEEDED(hr)) {
		    if (rtCut >= 0) {
                        hr = pTimeTrans->SetCutPoint(rtCut);
	    	        ASSERT(hr == S_OK);
		    }
                    hr = pTimeTrans->SetSwapInputs(fSwapInputs);
	    	    ASSERT(hr == S_OK);
                    hr = pTimeTrans->SetCutsOnly(fCutsOnly);
	    	    ASSERT(hr == S_OK);
		}
            }

            CComPtr< IAMTimelineTransable> pTransable;
            hr = pParent->QueryInterface(__uuidof(IAMTimelineTransable), (void **) &pTransable);

            if (SUCCEEDED(hr)) {
                hr = pTransable->TransAdd( pTimelineObj );
	    } else {
	        DbgLog((LOG_ERROR, 0, "ERROR: Transition cannot be a child of this object"));
	    }

            if (SUCCEEDED(hr)) {
                hr = BuildElementProperties(pTimelineObj, p);
            }

    } else {
	// !!! ignore unknown tags?
	DbgLog((LOG_ERROR, 0, "ERROR: Ignoring unknown tag '%ls'", bstrName));
    }

    return hr;
}

HRESULT BuildFromXML(IAMTimeline *pTL, IXMLDOMElement *pxml)
{
    CheckPointer(pTL, E_POINTER);
    CheckPointer(pxml, E_POINTER);

    HRESULT hr = S_OK;

    // remember, never assign anything to this
    CComBSTR bstrName;
    hr = pxml->get_tagName(&bstrName);

    if (FAILED(hr))
	return hr;

    int i = DexCompareW(bstrName, L"timeline"); // tagg

    if (i != 0)
	return VFW_E_INVALID_FILE_FORMAT;

    CLSID DefTrans, DefFX;
    BOOL fEnableTrans = ReadBoolAttribute(pxml, L"enabletrans", 1); // tagg
    hr = pTL->EnableTransitions(fEnableTrans);

    BOOL fEnableFX = ReadBoolAttribute(pxml, L"enablefx", 1); // tagg
    hr = pTL->EnableEffects(fEnableFX);

    // remember, never assign anything to this
    CComBSTR bstrDefTrans = FindAttribute(pxml, L"defaulttrans"); // tagg
    if (bstrDefTrans) {
        hr = CLSIDFromString(bstrDefTrans, &DefTrans);
	hr = pTL->SetDefaultTransition(&DefTrans);
    }
    // remember, never assign anything to this
    CComBSTR bstrDefFX = FindAttribute(pxml, L"defaultfx"); // tagg
    if (bstrDefFX) {
        hr = CLSIDFromString(bstrDefFX, &DefFX);
	hr = pTL->SetDefaultEffect(&DefFX);
    }

    REFERENCE_TIME llfps = ReadTimeAttribute(pxml, L"framerate", 15*UNITS); // tagg
    double fps = (double)llfps / UNITS;
    hr = pTL->SetDefaultFPS(fps);

    hr = BuildChildren(pTL, NULL, pxml, 0);

    return hr;
}	

HRESULT BuildFromXMLDoc(IAMTimeline *pTL, IXMLDOMDocument *pxml)
{
    CheckPointer(pTL, E_POINTER);
    CheckPointer(pxml, E_POINTER);

    HRESULT hr = S_OK;

    CComPtr< IXMLDOMElement> proot;

    hr = pxml->get_documentElement(&proot);

    if (hr == S_FALSE)          // can't read the file - no root
        hr = E_INVALIDARG;

    if (FAILED(hr))
	return hr;

    hr = BuildFromXML(pTL, proot);

    return hr;
}

HRESULT BuildFromXMLFile(IAMTimeline *pTL, WCHAR *wszXMLFile)
{
    CheckPointer(pTL, E_POINTER);
    CheckPointer(wszXMLFile, E_POINTER);

   HRESULT hr = ValidateFilename( wszXMLFile, _MAX_PATH, FALSE );
   if( FAILED( hr ) )
   {
       return hr;
   }

    // convert to absolute path because relative paths don't work with
    // XMLDocument on Win98 (IE4?)
    USES_CONVERSION;
    TCHAR *szXMLFile = W2T(wszXMLFile);
    TCHAR szFullPath[MAX_PATH];
    TCHAR *pName;
    if(GetFullPathName(szXMLFile, NUMELMS(szFullPath), szFullPath, &pName) == 0) {
        return AmGetLastErrorToHResult();
    }
    WCHAR *wszFullPath = T2W(szFullPath);
    
    CComQIPtr<IAMSetErrorLog, &IID_IAMSetErrorLog> pSet( pTL );
    CComPtr<IAMErrorLog> pLog;
    if (pSet) {
	pSet->get_ErrorLog(&pLog);
    }

    CComPtr< IXMLDOMDocument> pxml;
    hr = CoCreateInstance(CLSID_DOMDocument, NULL,
				CLSCTX_INPROC_SERVER,
				IID_IXMLDOMDocument, (void**)&pxml);
    if (SUCCEEDED(hr)) {

        VARIANT var;
        VariantInit(&var);
        var.vt = VT_BSTR;
        var.bstrVal = W2BSTR(wszFullPath);

        VARIANT_BOOL b;
	hr = pxml->load(var, &b);
        if (hr == S_FALSE)
            hr = E_INVALIDARG;

        VariantClear(&var);

	// !!! async?

	if (SUCCEEDED(hr)) {
	    hr = BuildFromXMLDoc(pTL, pxml);
	}

	if (FAILED(hr)) {
            // Print error information !

            CComPtr< IXMLDOMParseError> pXMLError;
            HRESULT hr2 = pxml->get_parseError(&pXMLError);
            if (SUCCEEDED(hr2)) {
                long nLine;
                hr2 = pXMLError->get_line(&nLine);
                if (SUCCEEDED(hr2)) {
                    DbgLog((LOG_ERROR, 0, TEXT(" Error on line %d"), (int)nLine));
	    	    VARIANT var;
	    	    VariantInit(&var);
	    	    var.vt = VT_I4;
	    	    V_I4(&var) = nLine;
	    	    _TimelineError(pTL, 1, DEX_IDS_INVALID_XML, hr, &var);
                } else {
	    	    _TimelineError(pTL, 1, DEX_IDS_INVALID_XML, hr);
		}
            } else {
	    	_TimelineError(pTL, 1, DEX_IDS_INVALID_XML, hr);
	    }
        }

    } else {
	_TimelineError(pTL, 1, DEX_IDS_INSTALL_PROBLEM, hr);
    }
    return hr;
}


HRESULT InsertDeleteTLObjSection(IAMTimelineObj *p, REFERENCE_TIME rtStart, REFERENCE_TIME rtStop, BOOL fDelete)
{
    TIMELINE_MAJOR_TYPE lType;
    HRESULT hr = p->GetTimelineType(&lType);

    switch (lType) {
        case TIMELINE_MAJOR_TYPE_TRACK:
        {
            CComPtr< IAMTimelineTrack> pTrack;
            if (SUCCEEDED(p->QueryInterface(__uuidof(IAMTimelineTrack), (void **) &pTrack))) {
                if (fDelete)
                {
                    hr = pTrack->ZeroBetween(rtStart, rtStop);
                    hr = pTrack->MoveEverythingBy( rtStop, rtStart - rtStop );
                }
                else
                {
                    hr = pTrack->InsertSpace(rtStart, rtStop);
                }
            }
        }
        break;

        case TIMELINE_MAJOR_TYPE_GROUP:
        case TIMELINE_MAJOR_TYPE_COMPOSITE:
        {
            CComPtr< IAMTimelineNode> pNode;
            HRESULT hr = p->QueryInterface(__uuidof(IAMTimelineNode), (void **) &pNode);
            if (SUCCEEDED(hr)) {
                long count;
                hr = pNode->XKidsOfType( TIMELINE_MAJOR_TYPE_TRACK |
                                         TIMELINE_MAJOR_TYPE_COMPOSITE,
                                         &count );

                if (SUCCEEDED(hr) && count > 0) {
                    for (int i = 0; i < count; i++) {
                        CComPtr< IAMTimelineObj> pChild;
                        hr = pNode->XGetNthKidOfType(SUPPORTED_TYPES, i, &pChild);

                        if (SUCCEEDED(hr)) {
                            // recurse!
                            hr = InsertDeleteTLObjSection(pChild, rtStart, rtStop, fDelete);
                        }
                    }
                }
            }

            break;
        }

        default:
            break;
    }

    return hr;
}


HRESULT InsertDeleteTLSection(IAMTimeline *pTL, REFERENCE_TIME rtStart, REFERENCE_TIME rtStop, BOOL fDelete)
{
    long cGroups;
    HRESULT hr = pTL->GetGroupCount(&cGroups);
    if (FAILED(hr))
        return hr;

    for (long lGroup = 0; lGroup < cGroups; lGroup++) {
        CComPtr< IAMTimelineObj > pGroupObj;
        hr = pTL->GetGroup(&pGroupObj, lGroup);
        if (FAILED(hr))
            break;

        hr = InsertDeleteTLObjSection(pGroupObj, rtStart, rtStop, fDelete);
        if (FAILED(hr))
            break;
    }

    return hr;
}

// !!! I need to get the OFFICIAL defaults, and not print out a value if it's
// the REAL default.  If the defaults change, I am in trouble!
//
HRESULT SaveTimelineToXMLFile(IAMTimeline *pTL, WCHAR *pwszXML)
{
    CheckPointer(pTL, E_POINTER);
    CheckPointer(pwszXML, E_POINTER);

    HRESULT hr = ValidateFilename( pwszXML, _MAX_PATH, TRUE );
    if( FAILED( hr ) )
    {
        return hr;
    }

    CXTLPrinter print;
    hr = print.PrintTimeline(pTL);

    if (SUCCEEDED(hr)) {
        USES_CONVERSION;
        TCHAR * tpwszXML = W2T( pwszXML );
        HANDLE hFile = CreateFile( tpwszXML,
                                   GENERIC_WRITE,
                                   0,
                                   NULL,
                                   CREATE_ALWAYS,
                                   FILE_ATTRIBUTE_NORMAL,
                                   NULL);

        if (hFile && hFile != (HANDLE)-1) {
            DWORD cb = lstrlenW(print.GetOutput()) * sizeof(WCHAR);

            BOOL fOK =  WriteFile(hFile, print.GetOutput(), cb, &cb, NULL);
            if (fOK == FALSE) {
                _TimelineError(pTL, 1, DEX_IDS_DISK_WRITE_ERROR, hr);
                hr = E_INVALIDARG;
            }

            CloseHandle(hFile);
        } else {
            hr = E_INVALIDARG;
            _TimelineError(pTL, 1, DEX_IDS_DISK_WRITE_ERROR, hr);
        }
    }

    return hr;
}

HRESULT SaveTimelineToXMLString(IAMTimeline *pTL, BSTR *pbstrXML)
{
    CheckPointer(pTL, E_POINTER);
    CheckPointer(pbstrXML, E_POINTER);

    CXTLPrinter print;

    HRESULT hr = print.PrintTimeline(pTL);

    if (SUCCEEDED(hr)) {
        *pbstrXML = W2BSTR(print.GetOutput());

        if (!*pbstrXML)
            hr = E_OUTOFMEMORY;
    }

    return hr;
}
=== C:/Users/treeman/Desktop/windows nt source code\Source\Win2K3\NT\multimedia\dshow\filterus\dexter\xmltl\varyprop.h ===
//@@@@AUTOBLOCK+============================================================;
//
//  THIS CODE AND INFORMATION IS PROVIDED "AS IS" WITHOUT WARRANTY OF ANY
//  KIND, EITHER EXPRESSED OR IMPLIED, INCLUDING BUT NOT LIMITED TO THE
//  IMPLIED WARRANTIES OF MERCHANTABILITY AND/OR FITNESS FOR A PARTICULAR
//  PURPOSE.
//
//  File: varyprop.h
//
//  Copyright (c) Microsoft Corporation.  All Rights Reserved.
//
//@@@@AUTOBLOCK-============================================================;

#include "..\errlog\cerrlog.h"

class CPropertySetter;

class QPropertyValue {
public:
    DWORD dwInterp; // DEXTERF_JUMP or DEXTERF_INTERPOLATE
    REFERENCE_TIME rt;
    VARIANT v;
    QPropertyValue *pNext;

    QPropertyValue() { pNext = NULL; dwInterp = 0; rt = 0; VariantInit(&v); }
};

class QPropertyParam {
public:
    BSTR bstrPropName;
    DISPID dispID;
    QPropertyValue val;
    QPropertyParam *pNext;

    QPropertyParam() { dispID = 0; pNext = NULL; bstrPropName = NULL; }
};

class CPropertySetter 
    : public CUnknown
    , public IPropertySetter
    , public CAMSetErrorLog
{
    STDMETHODIMP NonDelegatingQueryInterface(REFIID riid, void **ppv) {
	if (riid == IID_IPropertySetter) 
        {
	    return GetInterface((IPropertySetter *) this, ppv);
	} 
        if (riid == IID_IAMSetErrorLog)
        {
	    return GetInterface((IAMSetErrorLog*) this, ppv);
	}
	return CUnknown::NonDelegatingQueryInterface(riid, ppv);
    };


    QPropertyParam m_params;
    QPropertyParam *m_pLastParam;
    
    HRESULT LoadOneProperty(IXMLDOMElement *pxml, QPropertyParam *pParam);
    HRESULT SaveToXMLW( WCHAR * pOut, int iIndent, int * pCharsInOut );

    CPropertySetter(LPUNKNOWN punk) :
            CUnknown(NAME("Varying property holder"), punk),
            m_pLastParam(NULL) {};

public:
    DECLARE_IUNKNOWN

    ~CPropertySetter();

    // Function needed for the class factory
    static CUnknown * WINAPI CreateInstance(LPUNKNOWN pUnk, HRESULT *phr);
    static HRESULT CreatePropertySetterInstanceFromXML( IPropertySetter ** ppSetter, IXMLDOMElement * pxml );

    // IPropertySetter
    STDMETHODIMP SetProps(IUnknown *pTarget, REFERENCE_TIME rtNow);
    STDMETHODIMP CloneProps(IPropertySetter **pSetter, REFERENCE_TIME rtStart,
					REFERENCE_TIME rtStop);
    STDMETHODIMP AddProp(DEXTER_PARAM Param, DEXTER_VALUE *paValue);
    STDMETHODIMP GetProps(LONG *pcParams, DEXTER_PARAM **paParam,
			DEXTER_VALUE **paValue);
    STDMETHODIMP FreeProps(LONG cParams, DEXTER_PARAM *pParam,
			DEXTER_VALUE *pValue);
    STDMETHODIMP ClearProps();
    STDMETHODIMP LoadXML(IUnknown * pxml);
    STDMETHODIMP PrintXML(char *pszXML, int cbXML, int *pcbPrinted, int indent);
    STDMETHODIMP PrintXMLW(WCHAR *pszXML, int cbXML, int *pcbPrinted, int indent);
    STDMETHODIMP SaveToBlob(LONG *pcSize, BYTE **ppb);
    STDMETHODIMP LoadFromBlob(LONG cSize, BYTE *pb);

};
=== C:/Users/treeman/Desktop/windows nt source code\Source\Win2K3\NT\multimedia\dshow\filterus\dexter\xmltl\xmltl.h ===
//@@@@AUTOBLOCK+============================================================;
//
//  THIS CODE AND INFORMATION IS PROVIDED "AS IS" WITHOUT WARRANTY OF ANY
//  KIND, EITHER EXPRESSED OR IMPLIED, INCLUDING BUT NOT LIMITED TO THE
//  IMPLIED WARRANTIES OF MERCHANTABILITY AND/OR FITNESS FOR A PARTICULAR
//  PURPOSE.
//
//  File: xmltl.h
//
//  Copyright (c) Microsoft Corporation.  All Rights Reserved.
//
//@@@@AUTOBLOCK-============================================================;

HRESULT BuildFromXMLFile(IAMTimeline *pTL, WCHAR *wszXMLFile);
HRESULT BuildFromXML(IAMTimeline *pTL, IXMLDOMElement *pxml);
HRESULT SaveTimelineToXMLFile(IAMTimeline *pTL, WCHAR *pwszXML);
HRESULT InsertDeleteTLSection(IAMTimeline *pTL, REFERENCE_TIME rtStart, REFERENCE_TIME rtStop, BOOL fDelete);
HRESULT SaveTimelineToXMLString(IAMTimeline *pTL, BSTR *pbstrXML);
=== C:/Users/treeman/Desktop/windows nt source code\Source\Win2K3\NT\multimedia\dshow\filterus\dexter\xmltl\xtlprint.h ===
//@@@@AUTOBLOCK+============================================================;
//
//  THIS CODE AND INFORMATION IS PROVIDED "AS IS" WITHOUT WARRANTY OF ANY
//  KIND, EITHER EXPRESSED OR IMPLIED, INCLUDING BUT NOT LIMITED TO THE
//  IMPLIED WARRANTIES OF MERCHANTABILITY AND/OR FITNESS FOR A PARTICULAR
//  PURPOSE.
//
//  File: xtlprint.h
//
//  Copyright (c) Microsoft Corporation.  All Rights Reserved.
//
//@@@@AUTOBLOCK-============================================================;

#pragma once

class CXTLPrinter {
    WCHAR *m_pOut;
    long m_dwAlloc;    // characters allocated
    long m_dwCurrent;  // characters in string
    int   m_indent;     // current indent

    HRESULT Print(const WCHAR *pFormat, ...);  // format-prints to self
    HRESULT PrintTime(REFERENCE_TIME rt);      // format-prints time to self
    HRESULT PrintIndent();                     // 

    HRESULT EnsureSpace(long dw);

    HRESULT PrintObjStuff(IAMTimelineObj *pObj, BOOL fTimesToo);

    HRESULT PrintProperties(IPropertySetter *pSetter);

    HRESULT PrintPartial(IAMTimelineObj *p);

    HRESULT PrintPartialChildren(IAMTimelineObj *p);

public:
    CXTLPrinter();
    ~CXTLPrinter();

    HRESULT PrintTimeline(IAMTimeline *pTL);
    WCHAR *GetOutput() { return m_pOut; }
};
=== C:/Users/treeman/Desktop/windows nt source code\Source\Win2K3\NT\multimedia\dshow\filterus\dexter\xmltl\xtlprint.cpp ===
//@@@@AUTOBLOCK+============================================================;
//
//  THIS CODE AND INFORMATION IS PROVIDED "AS IS" WITHOUT WARRANTY OF ANY
//  KIND, EITHER EXPRESSED OR IMPLIED, INCLUDING BUT NOT LIMITED TO THE
//  IMPLIED WARRANTIES OF MERCHANTABILITY AND/OR FITNESS FOR A PARTICULAR
//  PURPOSE.
//
//  File: xtlprint.cpp
//
//  Copyright (c) Microsoft Corporation.  All Rights Reserved.
//
//@@@@AUTOBLOCK-============================================================;

#include <streams.h>
#include <atlbase.h>
#include <atlconv.h>
#include <msxml.h>
#include "qeditint.h"
#include "qedit.h"
#include "xtlprint.h"
#include "xtlcommon.h"
#define STRSAFE_NO_DEPRECATE
#include <strsafe.h>

// !!! Timeline hopefully thinks these are the defaults
DEFINE_GUID( DefaultTransition,
0x810E402F, 0x056B, 0x11D2, 0xA4, 0x84, 0x00, 0xC0, 0x4F, 0x8E, 0xFB, 0x69);

DEFINE_GUID( DefaultEffect,
0xF515306D, 0x0156, 0x11D2, 0x81, 0xEA, 0x00, 0x00, 0xF8, 0x75, 0x57, 0xDB);

const int GROW_SIZE = 1024;

CXTLPrinter::CXTLPrinter()
: m_dwAlloc( -1 )
, m_pOut( NULL )
, m_indent( 0 )
, m_dwCurrent( 0 )
{
    m_pOut = NULL;
}

CXTLPrinter::~CXTLPrinter()
{
    if( m_pOut )
    {
        free( m_pOut );
    }
}

// ehr: this is very clever now!
//
HRESULT CXTLPrinter::Print(const WCHAR *pFormat, ...)
{
    // unicode only now. Don't bother with TCHARs until we try to back-prop this

    // we'll try to allocate this much more on a 1st try if we need to
    long AllocLen = GROW_SIZE;

    // if we have enough space already, don't allocate on 1st try
    if( m_dwAlloc > m_dwCurrent + 512 )
    {
        AllocLen = 0;
    }

    // AllocLen will keep growing if we need more space, within limits that is
loop:

    // reallocate the memory. If it runs out, we're toast since nothing
    // in this file checks for Print( )'s return code
    if( AllocLen )
    {
        WCHAR * pNewOut = (WCHAR*) realloc( m_pOut, ( m_dwAlloc + AllocLen ) * sizeof(WCHAR) );
        if( !pNewOut )
        {
            free( m_pOut );
            m_pOut = NULL;

            // oh darn
            //
            m_dwAlloc = -1;
            m_dwCurrent = 0;
            return E_OUTOFMEMORY;
        }
        else
        {
            m_pOut = pNewOut;
        }
    }

    // this is where to start printing
    WCHAR * pAddString = m_pOut + m_dwCurrent;

    // how many characters we can fill up
    long Available = ( m_dwAlloc + AllocLen ) - m_dwCurrent;

    va_list va;
    va_start( va, pFormat );

    // use Available - 1 to allow for null terminator to be printed
    int written = _vsnwprintf( pAddString, Available - 1, pFormat, va );

    // written is characters written + terminator
    if( ( written < 0 ) || ( written > Available ) )
    {
        // string was too short, try again with a bigger size
        AllocLen += GROW_SIZE;
        ASSERT( AllocLen <= 256 * GROW_SIZE );

        // give up. Somebody's trying to give us a HUGE string
        if( AllocLen > 256 * GROW_SIZE )
        {
            m_pOut[0] = 0;
            m_dwAlloc = 0;
            m_dwCurrent = 0;
            return NOERROR;
        }

        // terminate where we started from before
        m_pOut[m_dwCurrent] = 0; 

        goto loop;
    }

    // keep current with what we wrote
    m_dwCurrent += written;
    m_dwAlloc += AllocLen;

    ASSERT(m_dwCurrent < m_dwAlloc);
    return NOERROR;
}

HRESULT CXTLPrinter::PrintIndent()
{
    int indent = m_indent;
    while (indent--) 
    {
        HRESULT hr = Print(L"    ");
        if( FAILED( hr ) )
        {
            return hr;
        }
   }
   return NOERROR;
}

HRESULT CXTLPrinter::PrintTime(REFERENCE_TIME rt)
{
    int secs = (int) (rt / UNITS);

    double dsecs = rt - (double)(secs * UNITS);
    int isecs = (int)dsecs;

    HRESULT hr;
    if (isecs) {
        hr = Print(L"%d.%07d", secs, isecs);
    } else {
        hr = Print(L"%d", secs);
    }

    return hr;
}

// the property setter needs to print it's properties to our string
//
HRESULT CXTLPrinter::PrintProperties(IPropertySetter *pSetter)
{
    // make a temporary spot to put the properties string
    WCHAR * pPropsString = NULL;
    long Len = GROW_SIZE;

loop:
    WCHAR * pNewPropsString = (WCHAR*) realloc( pPropsString, Len * sizeof(WCHAR) );
    if( !pNewPropsString )
    {
        free( pPropsString );

        return E_OUTOFMEMORY;
    }
    else
    {
        pPropsString = pNewPropsString;
    }

    int cchPrinted = 0; // not including terminator
    HRESULT hr = pSetter->PrintXMLW(
        pPropsString, 
        Len, 
        &cchPrinted, 
        m_indent);

    // string was too short, grow it
    //
    if( hr == STRSAFE_E_INSUFFICIENT_BUFFER )
    {
        Len *= 2;
        if( Len > 256 * GROW_SIZE )
        {
            return STRSAFE_E_INSUFFICIENT_BUFFER;
        }
        goto loop;
    }

    // failed, bomb out
    //
    if( FAILED( hr ) )
    {
        return hr;
    }

    // got a good string, now copy it in
    //
    hr = EnsureSpace( m_dwCurrent + cchPrinted + 1 );
    if( FAILED( hr ) )
    {
        return hr;
    }
    lstrcpynW( m_pOut + m_dwCurrent, pPropsString, cchPrinted + 1 ); // add 1 for terminator
    m_dwCurrent += cchPrinted;

    return hr;
}

// ensure there's enough room for dw characters
//
HRESULT CXTLPrinter::EnsureSpace(long dwAlloc)
{
    // round up to the nearest K
    dwAlloc -= 1; // so 1024 will round to 1024
    dwAlloc /= 1024;
    dwAlloc++;
    dwAlloc *= 1024;
    
    if( m_dwAlloc >= dwAlloc )
    {
        return NOERROR; // already big enough
    }

    WCHAR * pNewOut = (WCHAR*) realloc( m_pOut, dwAlloc * sizeof(WCHAR) );

    if( !pNewOut )
    {
        free( m_pOut );
        m_pOut = NULL;

        m_dwAlloc = -1;
        m_dwCurrent = 0;
        return E_OUTOFMEMORY;
    }
    else
    {
        m_pOut = pNewOut;
    }

    m_dwAlloc = dwAlloc;

    return S_OK;
}

// safe
HRESULT CXTLPrinter::PrintObjStuff(IAMTimelineObj *pObj, BOOL fTimesToo)
{
    REFERENCE_TIME rtStart;
    REFERENCE_TIME rtStop;

    HRESULT hr = pObj->GetStartStop(&rtStart, &rtStop);
    if (fTimesToo && SUCCEEDED(hr) && rtStop > 0) {
        Print(L" start=\""); // tagg
        PrintTime(rtStart);
        Print(L"\" stop=\""); // tagg
        PrintTime(rtStop);
        Print(L"\"");
    }

    CLSID clsidObj;
    hr = pObj->GetSubObjectGUID(&clsidObj);
    WCHAR wszClsid[50];
    if (SUCCEEDED(hr) && clsidObj != GUID_NULL) {
        StringFromGUID2(clsidObj, wszClsid, 50);
        Print(L" clsid=\"%ls\"", wszClsid); // tagg
    }

    // !!! BROKEN - Child is muted if parent is.  Save. Load.  Unmute parent.
    // Child will still be muted
    BOOL Mute;
    pObj->GetMuted(&Mute);
    if (Mute)
        Print(L" mute=\"%d\"", Mute); // tagg

    BOOL Lock;
    pObj->GetLocked(&Lock);
    if (Lock)
        Print(L" lock=\"%d\"", Lock); // tagg

    long UserID;
    pObj->GetUserID(&UserID);
    if (UserID != 0)
        Print(L" userid=\"%d\"", (int)UserID);// !!! trunc? // tagg

    // remember, never assign anything to this
    CComBSTR bstr;
    hr = pObj->GetUserName(&bstr);
    if (bstr) {
	if (lstrlenW(bstr) > 0) {
            Print(L" username=\"%ls\"", bstr); // tagg
	}
    }	

    LONG size;
    hr = pObj->GetUserData(NULL, &size);
    if (size > 0) {
        BYTE *pData = (BYTE *)QzTaskMemAlloc(size);
        if (pData == NULL) {
	    return E_OUTOFMEMORY;
	}

        WCHAR *pHex = (WCHAR *)QzTaskMemAlloc(sizeof(WCHAR) + ( 2 * size * sizeof(WCHAR) ) ); // add 1 for terminator
        if (pHex == NULL) {
	    QzTaskMemFree(pData);
	    return E_OUTOFMEMORY;
	}
        hr = pObj->GetUserData(pData, &size);
        // convert to dmuu-encoded text
        WCHAR *pwch = pHex;
        for (int zz=0; zz<size; zz++) {
	    wsprintfW(pwch, L"%02X", pData[zz]);
	    pwch += 2;
        }
        *pwch = 0; // don't forget to null terminate!
        Print(L" userdata=\"%ls\"", pHex); // tagg
	QzTaskMemFree(pHex);
	QzTaskMemFree(pData);
    }

    return S_OK;
}

// safe
HRESULT CXTLPrinter::PrintTimeline(IAMTimeline *pTL)
{
    m_indent = 1;
    HRESULT hr = EnsureSpace( GROW_SIZE );
    if( FAILED( hr ) )
    {
        return hr;
    }

    // unicode strings are prefixed by FFFE
    *(LPBYTE)m_pOut = 0xff;
    *(((LPBYTE)m_pOut) + 1) = 0xfe;
    m_dwCurrent = 1;

    REFERENCE_TIME rtDuration;
    hr = pTL->GetDuration(&rtDuration);
    if (FAILED(hr))
        return hr;

    long cGroups;
    hr = pTL->GetGroupCount(&cGroups);
    if (FAILED(hr))
        return hr;

    Print(L"<timeline"); // tagg

    BOOL fEnableTrans;
    pTL->TransitionsEnabled(&fEnableTrans);
    if (!fEnableTrans)
        Print(L" enabletrans=\"%d\"", fEnableTrans); // tagg

    BOOL fEnableFX;
    hr = pTL->EffectsEnabled(&fEnableFX);
    if (!fEnableFX)
        Print(L" enablefx=\"%d\"", fEnableFX); // tagg

    CLSID DefTrans, DefFX;
    WCHAR wszClsid[50];
    hr = pTL->GetDefaultTransition(&DefTrans);
    if (SUCCEEDED(hr) && DefTrans != GUID_NULL && !IsEqualGUID(DefTrans,
						DefaultTransition)) {
        StringFromGUID2(DefTrans, wszClsid, 50);
        Print(L" defaulttrans=\"%ls\"", wszClsid); // tagg
    }
    hr = pTL->GetDefaultEffect(&DefFX);
    if (SUCCEEDED(hr) && DefFX != GUID_NULL && !IsEqualGUID(DefFX,
						DefaultEffect)) {
        StringFromGUID2(DefFX, wszClsid, 50);
        Print(L" defaultfx=\"%ls\"", wszClsid); // tagg
    }

    double frc;
    hr = pTL->GetDefaultFPS(&frc);
    if (frc != 15.0) {
        LONG lfrc = (LONG)frc;
        double ffrc = (frc - (double)lfrc) * UNITS;
        Print(L" framerate=\"%d.%07d\"", (int)frc, (int)ffrc); // tagg
    }

    Print(L">\r\n");

    for (long lGroup = 0; lGroup < cGroups; lGroup++) {
        CComPtr< IAMTimelineObj > pGroupObj;
        hr = pTL->GetGroup(&pGroupObj, lGroup);
        if (FAILED(hr))
            break;

        hr = PrintPartial(pGroupObj);

        if (FAILED(hr))
            break;
    }
    Print(L"</timeline>\r\n"); // tagg

    return hr;
}

// safe
HRESULT CXTLPrinter::PrintPartialChildren(IAMTimelineObj *p)
{
    CComPtr< IAMTimelineNode > pNode;
    HRESULT hr = p->QueryInterface(__uuidof(IAMTimelineNode), (void **) &pNode);
    if (SUCCEEDED(hr)) {
        long count;
        hr = pNode->XKidsOfType( SUPPORTED_TYPES, &count );

        if (SUCCEEDED(hr) && count > 0) {

            Print(L">\r\n");

            for (int i = 0; i < count; i++) {
                CComPtr< IAMTimelineObj > pChild;
                hr = pNode->XGetNthKidOfType(SUPPORTED_TYPES, i, &pChild);

                if (SUCCEEDED(hr)) {
                    // recurse!
                    ++m_indent;
                    hr = PrintPartial(pChild);
		    if (FAILED(hr)) {
			break;
		    }
                    --m_indent;
                }
            }
        }

        if (SUCCEEDED(hr) && count == 0)
            hr = S_FALSE;
    }

    return hr;
}

// safe
HRESULT CXTLPrinter::PrintPartial(IAMTimelineObj *p)
{
    HRESULT hr = S_OK;

    if (FAILED(hr))
        return hr;

    TIMELINE_MAJOR_TYPE lType;
    hr = p->GetTimelineType(&lType);

    switch (lType) {
        case TIMELINE_MAJOR_TYPE_TRACK:
        {
            CComPtr< IAMTimelineVirtualTrack > pTrack;
            if (SUCCEEDED(p->QueryInterface(__uuidof(IAMTimelineVirtualTrack), (void **) &pTrack))) {

                PrintIndent();

    		Print(L"<track"); // tagg

		hr = PrintObjStuff(p, FALSE);
		if (FAILED(hr))
		    break;

                hr = PrintPartialChildren(p);
		if (FAILED(hr))
		    break;

                if (hr == S_FALSE) {
                    Print(L"/>\r\n");
                    hr = S_OK;
                } else {
                    PrintIndent();
                    Print(L"</track>\r\n"); // tagg
                }
            }
        }
        break;

        case TIMELINE_MAJOR_TYPE_SOURCE:
        {
            CComPtr< IAMTimelineSrc > pSrc;
            if SUCCEEDED(p->QueryInterface(__uuidof(IAMTimelineSrc),
							(void **) &pSrc)) {

                REFERENCE_TIME rtMStart;
                REFERENCE_TIME rtMStop;
                hr = pSrc->GetMediaTimes(&rtMStart, &rtMStop);

                // remember, never assign anything to this
                CComBSTR bstrSrc;
                hr = pSrc->GetMediaName(&bstrSrc);

                PrintIndent();
                Print(L"<clip"); // tagg

		hr = PrintObjStuff(p, TRUE);

                // safe enough - string shouldn't ever be really long
		if (bstrSrc && lstrlenW(bstrSrc) > 0)
                {
                    Print(L" src=\"%ls\"", bstrSrc); // tagg
                }

		if (rtMStop > 0) {
                    Print(L" mstart=\""); // tagg
                    PrintTime(rtMStart);

                    // only print out MStop if it's not the default....
                    REFERENCE_TIME rtStart;
                    REFERENCE_TIME rtStop;
                    hr = p->GetStartStop(&rtStart, &rtStop);
                    if (rtMStop != (rtMStart + (rtStop - rtStart))) {
                        Print(L"\" mstop=\""); // tagg
                        PrintTime(rtMStop);
                    }
                    Print(L"\"");
		}

		REFERENCE_TIME rtLen;
                hr = pSrc->GetMediaLength(&rtLen);
		if (rtLen > 0) {
                    Print(L" mlength=\""); // tagg
                    PrintTime(rtLen);
                    Print(L"\"");
		}

		int StretchMode;
		pSrc->GetStretchMode(&StretchMode);
		if (StretchMode == RESIZEF_PRESERVEASPECTRATIO)
                    Print(L" stretchmode=\"PreserveAspectRatio\""); // tagg
		else if (StretchMode == RESIZEF_CROP)
                    Print(L" stretchmode=\"Crop\""); // tagg
		else if (StretchMode == RESIZEF_PRESERVEASPECTRATIO_NOLETTERBOX)
		    Print(L" stretchmode=\"PreserveAspectRatioNoLetterbox\""); // tagg
		else
                    ; // !!! Is Stretch really the default?

		double fps; LONG lfps;
		pSrc->GetDefaultFPS(&fps);
		lfps = (LONG)fps;
		if (fps != 0.0)	// !!! Is 0 really the default?
                    Print(L" framerate=\"%d.%07d\"", (int)fps, // tagg
					(int)((fps - (double)lfps) * UNITS));

		long stream;
		pSrc->GetStreamNumber(&stream);
		if (stream > 0)
                    Print(L" stream=\"%d\"", (int)stream); // tagg

                hr = PrintPartialChildren(p);
		if (FAILED(hr))
		    break;

                CComPtr< IPropertySetter > pSetter = NULL;
                HRESULT hr2 = p->GetPropertySetter(&pSetter);

                // save properties!
                if (hr2 == S_OK && pSetter) {
                    if (hr == S_FALSE) {
                        Print(L">\r\n");
                        hr = S_OK;
                    }

                    hr = PrintProperties(pSetter);
    		    if (FAILED(hr))
		        break;
                }

                if (hr == S_FALSE) {
                    Print(L"/>\r\n");
                    hr = S_OK;
                } else {
                    PrintIndent();
                    Print(L"</clip>\r\n"); // tagg
                }
            }
        }
            break;

        case TIMELINE_MAJOR_TYPE_EFFECT:
        {
            CComPtr< IAMTimelineEffect > pEffect;
            if SUCCEEDED(p->QueryInterface(__uuidof(IAMTimelineEffect), (void **) &pEffect)) {

                PrintIndent();
                Print(L"<effect"); // tagg

		hr = PrintObjStuff(p, TRUE);
		if (FAILED(hr))
		    break;

                hr = PrintPartialChildren(p);
		if (FAILED(hr))
		    break;

                {
                    CComPtr< IPropertySetter > pSetter = NULL;
                    HRESULT hr2 = p->GetPropertySetter(&pSetter);

                    // save properties!
                    if (hr2 == S_OK && pSetter) {
                        if (hr == S_FALSE) {
                            Print(L">\r\n");
                            hr = S_OK;
                        }

                        hr = PrintProperties(pSetter);
        		if (FAILED(hr))
		            break;
                    }
                }

                if (hr == S_FALSE) {
                    Print(L"/>\r\n");
                    hr = S_OK;
                } else {
                    PrintIndent();
                    Print(L"</effect>\r\n"); // tagg
                }
            }
        }
            break;

        case TIMELINE_MAJOR_TYPE_TRANSITION:
        {
            CComPtr< IAMTimelineTrans > pTrans;
            if SUCCEEDED(p->QueryInterface(__uuidof(IAMTimelineTrans), (void **) &pTrans)) {
                PrintIndent();
                Print(L"<transition"); // tagg

		hr = PrintObjStuff(p, TRUE);

		BOOL fSwapInputs;
		pTrans->GetSwapInputs(&fSwapInputs);
		if (fSwapInputs)
                    Print(L" swapinputs=\"%d\"", fSwapInputs); // tagg

		BOOL fCutsOnly;
		pTrans->GetCutsOnly(&fCutsOnly);
		if (fCutsOnly)
                    Print(L" cutsonly=\"%d\"", fCutsOnly); // tagg

		REFERENCE_TIME rtCutPoint;
		hr = pTrans->GetCutPoint(&rtCutPoint);
		if (hr == S_OK) { // !!! S_FALSE means not set, using default
                    Print(L" cutpoint=\""); // tagg
		    PrintTime(rtCutPoint);
                    Print(L"\"");
		}

                hr = PrintPartialChildren(p);
		if (FAILED(hr))
		    break;

                // save properties!
                {
                    CComPtr< IPropertySetter > pSetter = NULL;
                    HRESULT hr2 = p->GetPropertySetter(&pSetter);

                    if (hr2 == S_OK && pSetter) {
                        if (hr == S_FALSE) {
                            Print(L">\r\n");
                            hr = S_OK;
                        }

                        hr = PrintProperties(pSetter);
    		        if (FAILED(hr))
		            break;
                    }
                }

                if (hr == S_FALSE) {
                    Print(L"/>\r\n");
                    hr = S_OK;
                } else {
                    PrintIndent();
                    Print(L"</transition>\r\n"); // tagg
                }
            }
        }
            break;

        case TIMELINE_MAJOR_TYPE_COMPOSITE:
        {
            CComPtr< IAMTimelineVirtualTrack > pTrack;
            if (SUCCEEDED(p->QueryInterface(__uuidof(IAMTimelineVirtualTrack), (void **) &pTrack))) {
                PrintIndent();
                Print(L"<composite"); // tagg

		hr = PrintObjStuff(p, FALSE);
		if (FAILED(hr))
		    break;

                hr = PrintPartialChildren(p);
		if (FAILED(hr))
		    break;

                if (hr == S_FALSE) {
                    Print(L"/>\r\n");
                    hr = S_OK;
                } else {
                    PrintIndent();
                    Print(L"</composite>\r\n"); // tagg
                }
            }
            break;
        }

        case TIMELINE_MAJOR_TYPE_GROUP:
        {
            PrintIndent();

            CComPtr< IAMTimelineGroup > pGroup;
            if SUCCEEDED(p->QueryInterface(__uuidof(IAMTimelineGroup), (void **) &pGroup)) {
                Print(L"<group"); // tagg

		hr = PrintObjStuff(p, FALSE);

		CMediaType mt;
                pGroup->GetMediaType(&mt);
		if (*mt.Type() == MEDIATYPE_Video) {
		    LPBITMAPINFOHEADER lpbi = HEADER(mt.Format());
		    int bitdepth = lpbi->biBitCount;
		    int width = lpbi->biWidth;
		    int height = lpbi->biHeight;
		    USES_CONVERSION;
                    Print(L" type=\"video\""); // tagg
		    if (bitdepth != DEF_BITDEPTH)
                        Print(L" bitdepth=\"%d\"", bitdepth); // tagg
		    if (width != DEF_WIDTH)
                        Print(L" width=\"%d\"", width); // tagg
		    if (height != DEF_HEIGHT)
                        Print(L" height=\"%d\"", height); // tagg
		} else if (*mt.Type() == MEDIATYPE_Audio) {
		    WAVEFORMATEX *pwfx = (WAVEFORMATEX *)mt.Format();
		    int samplingrate = pwfx->nSamplesPerSec;
                    Print(L" type=\"audio\""); // tagg
		    if (samplingrate != DEF_SAMPLERATE)
                        Print(L" samplingrate=\"%d\"", // tagg
							samplingrate);
		}

		double frc, ffrc; LONG lfrc;
		int nPreviewMode, nBuffering;
                // remember, never assign anything to this
                CComBSTR wName;
		pGroup->GetOutputFPS(&frc);
		pGroup->GetPreviewMode(&nPreviewMode);
		pGroup->GetOutputBuffering(&nBuffering);
		hr = pGroup->GetGroupName(&wName);
		lfrc = (LONG)frc;
		ffrc = (frc - (double)lfrc) * UNITS;
		if (frc != 15.0)  // !!! Is 15 really the default?
                    Print(L" framerate=\"%d.%07d\"", // tagg
						(int)frc, (int)ffrc);
		if (nPreviewMode == 0)	// Is ON really the default?
                    Print(L" previewmode=\"%d\"",nPreviewMode); // tagg
		if (nBuffering != DEX_DEF_OUTPUTBUF)
                    Print(L" buffering=\"%d\"", nBuffering); // tagg
		if (lstrlenW(wName) > 0) {
                    Print(L" name=\"%ls\"", wName); // tagg
                }

                hr = PrintPartialChildren(p);
		if (FAILED(hr))
		    break;

                if (hr == S_FALSE) {
                    Print(L"/>\r\n");
                    hr = S_OK;
                } else {
                    PrintIndent();
                    Print(L"</group>\r\n"); // tagg
                }
            }
            break;
        }

        default:
        {
            hr = PrintPartialChildren(p);
            break;
        }
    }

    return hr;
}
=== C:/Users/treeman/Desktop/windows nt source code\Source\Win2K3\NT\multimedia\dshow\filterus\dexter\xmltl\xtlcommon.h ===
//@@@@AUTOBLOCK+============================================================;
//
//  THIS CODE AND INFORMATION IS PROVIDED "AS IS" WITHOUT WARRANTY OF ANY
//  KIND, EITHER EXPRESSED OR IMPLIED, INCLUDING BUT NOT LIMITED TO THE
//  IMPLIED WARRANTIES OF MERCHANTABILITY AND/OR FITNESS FOR A PARTICULAR
//  PURPOSE.
//
//  File: xtlcommon.h
//
//  Copyright (c) Microsoft Corporation.  All Rights Reserved.
//
//@@@@AUTOBLOCK-============================================================;

// global defines
//
#define DEF_BITDEPTH	16
#define DEF_WIDTH	320
#define DEF_HEIGHT	240
#define DEF_SAMPLERATE	44100

const int SUPPORTED_TYPES =  TIMELINE_MAJOR_TYPE_TRACK |
                             TIMELINE_MAJOR_TYPE_SOURCE |
                             TIMELINE_MAJOR_TYPE_GROUP |
                             TIMELINE_MAJOR_TYPE_COMPOSITE |
                             TIMELINE_MAJOR_TYPE_TRANSITION |
                             TIMELINE_MAJOR_TYPE_EFFECT;
=== C:/Users/treeman/Desktop/windows nt source code\Source\Win2K3\NT\multimedia\dshow\filterus\midi\midirdr\midif.h ===
// Copyright (c) 1996  Microsoft Corporation.  All Rights Reserved.

// The MIDI format consists of the time division of the file.  This is found
// in the header of an smf file.  It doesn't change and needs to be sent to
// MMSYSTEM before we play the file.
typedef struct _MIDIFORMAT {
    DWORD		dwDivision;
    DWORD		dwReserved[7];
} MIDIFORMAT, FAR * LPMIDIFORMAT;
=== C:/Users/treeman/Desktop/windows nt source code\Source\Win2K3\NT\multimedia\dshow\filterus\midi\midirdr\debug.c ===
//==========================================================================;
//
//      Copyright (c) 1996 - 1999  Microsoft Corporation.  All Rights Reserved.
//
//      You have a royalty-free right to use, modify, reproduce and
//      distribute the Sample Files (and/or any modified version) in
//      any way you find useful, provided that you agree that
//      Microsoft has no warranty obligations or liability for any
//      Sample Application Files which are modified.
//
//--------------------------------------------------------------------------;
//
//  debug.c
//
//  Description:
//      This file contains code yanked from several places to provide debug
//      support that works in win 16 and win 32.
//
//  History:
//      11/23/92    cjp     [curtisp]
//
//==========================================================================;

#ifdef   DEBUG

#include <windows.h>
#include <mmsystem.h>
#include <stdarg.h>
#include "debug.h"

#ifdef WIN32
   #define  BCODE
#else
   #define  BCODE                   __based(__segname("_CODE"))
#endif


#define WSPRINTF_LIMIT 1024

//
//
//
BOOL    __gfDbgEnabled  = TRUE;     // master enable
UINT    __guDbgLevel    = 0;        // current debug level

WORD    wDebugLevel     = 0;

//************************************************************************
//**
//**  WinAssert();
//**
//**  DESCRIPTION:
//**
//**
//**  ARGUMENTS:
//**     LPSTR lpstrExp
//**     LPSTR lpstrFile
//**     DWORD dwLine
//**
//**  RETURNS:
//**     void
//**
//**  HISTORY:
//**
//************************************************************************
VOID WINAPI WinAssert(
    LPSTR           lpstrExp,
    LPSTR           lpstrFile,
    DWORD           dwLine)
{
    static char szWork[256];
    static char BCODE szFormat[] =
        "!Assert: %s#%lu [%s]";

    dprintf(0, (LPSTR)szFormat, (LPSTR)lpstrFile, dwLine, (LPSTR)lpstrExp);
}

//************************************************************************
//**
//**  DbgVPrintF();
//**
//**  DESCRIPTION:
//**
//**
//**  ARGUMENTS:
//**     LPSTR szFmt
//**     LPSTR va
//**
//**  RETURNS:
//**     void
//**
//**  HISTORY:
//**
//************************************************************************

void FAR CDECL DbgVPrintF(
   LPSTR szFmt,
   va_list va)
{
    char    ach[DEBUG_MAX_LINE_LEN];
    BOOL    fDebugBreak = FALSE;
    BOOL    fPrefix     = TRUE;
    BOOL    fCRLF       = TRUE;

    ach[0] = '\0';

    for (;;)
    {
        switch(*szFmt)
        {
            case '!':
                fDebugBreak = TRUE;
                szFmt++;
                continue;

            case '`':
                fPrefix = FALSE;
                szFmt++;
                continue;

            case '~':
                fCRLF = FALSE;
                szFmt++;
                continue;
        }

        break;
    }

    if (fDebugBreak)
    {
        ach[0] = '\007';
        ach[1] = '\0';
    }

    if (fPrefix)
        lstrcatA(ach, DEBUG_MODULE_NAME ": ");

    wvsprintfA(ach + lstrlenA(ach), szFmt, va);

    if (fCRLF)
        lstrcatA(ach, "\r\n");

    OutputDebugStringA(ach);

    if (fDebugBreak)
        DebugBreak();
} //** DbgVPrintF()


//************************************************************************
//**
//**  dprintf();
//**
//**  DESCRIPTION:
//**     dprintf() is called by the DPF macro if DEBUG is defined at compile
//**     time.
//**
//**     The messages will be send to COM1: like any debug message. To
//**     enable debug output, add the following to WIN.INI :
//**
//**     [debug]
//**     smf=1
//**
//**
//**  ARGUMENTS:
//**     UINT     uDbgLevel
//**     LPCSTR   szFmt
//**     ...
//**
//**  RETURNS:
//**     void
//**
//**  HISTORY:
//**     06/12/93       [t-kyleb]
//**
//************************************************************************

void FAR CDECL dprintf(
   UINT     uDbgLevel,
   LPSTR   szFmt,
   ...)
{
    va_list va;

    if (!__gfDbgEnabled || (__guDbgLevel < uDbgLevel))
        return;

    va_start(va, szFmt);
    DbgVPrintF(szFmt, va);
    va_end(va);
} //** dprintf()


//************************************************************************
//**
//**  DbgEnable();
//**
//**  DESCRIPTION:
//**
//**
//**  ARGUMENTS:
//**     BOOL fEnable
//**
//**  RETURNS:
//**     BOOL
//**
//**  HISTORY:
//**     06/12/93       [t-kyleb]
//**
//************************************************************************

BOOL WINAPI DbgEnable(
   BOOL fEnable)
{
    BOOL    fOldState;

    fOldState      = __gfDbgEnabled;
    __gfDbgEnabled = fEnable;

    return (fOldState);
} //** DbgEnable()



//************************************************************************
//**
//**  DbgSetLevel();
//**
//**  DESCRIPTION:
//**
//**
//**  ARGUMENTS:
//**     UINT uLevel
//**
//**  RETURNS:
//**     UINT
//**
//**  HISTORY:
//**     06/12/93       [t-kyleb]
//**
//************************************************************************

UINT WINAPI DbgSetLevel(
   UINT uLevel)
{
    UINT    uOldLevel;

    uOldLevel    = __guDbgLevel;
    __guDbgLevel = uLevel;
	wDebugLevel = (WORD) uLevel;

    return (uOldLevel);
} //** DbgSetLevel()


//--------------------------------------------------------------------------;
//
//  UINT DbgInitialize(void)
//
//  Description:
//
//
//  Arguments:
//
//  Return (UINT):
//
//
//  History:
//      11/24/92    cjp     [curtisp]
//
//--------------------------------------------------------------------------;

UINT WINAPI DbgInitialize(BOOL fEnable)
{
    DbgSetLevel(GetProfileIntA(DEBUG_SECTION, DEBUG_MODULE_NAME, 0));
    DbgEnable(fEnable);

    return (__guDbgLevel);
} // DbgInitialize()

#endif
=== C:/Users/treeman/Desktop/windows nt source code\Source\Win2K3\NT\multimedia\dshow\filterus\midi\midirdr\global.h ===
/*****************************************************************************
*
*  THIS CODE AND INFORMATION IS PROVIDED "AS IS" WITHOUT WARRANTY OF
*  ANY KIND, EITHER EXPRESSED OR IMPLIED, INCLUDING BUT NOT LIMITED
*  TO THE IMPLIED WARRANTIES OF MERCHANTABILITY AND/OR FITNESS FOR
*  A PARTICULAR PURPOSE.
*
*  Copyright (c) 1996 - 1996  Microsoft Corporation.  All Rights Reserved.
*
******************************************************************************
*
* Global.H
*
* #define's everybody needs
*
*****************************************************************************/

#ifndef _GLOBAL_
#define _GLOBAL_

#ifndef _WIN32
#define  BCODE                  __based(__segname("_CODE"))
#define  BSTACK                 __based(__segname("_STACK"))
#define  BSEG(x)                __based(__segname(x))
#define  HUGE                   __huge
#else
#define  BCODE
#define  BSTACK
#define  BSEG(x)
#define  HUGE
#endif

/* Allow visibility of static functions for debug
*/ 
#ifdef DEBUG
#define  PUBLIC
#define  PRIVATE
#else
#define  PUBLIC                 
#define  PRIVATE                static
#endif

#define  FNLOCAL                NEAR PASCAL
#define  FNGLOBAL               FAR PASCAL
#define  FNEXPORT               FAR PASCAL __export __loadds

#endif
=== C:/Users/treeman/Desktop/windows nt source code\Source\Win2K3\NT\multimedia\dshow\filterus\midi\midirdr\debug.h ===
//==========================================================================;
//
//      Copyright (c) 1996 - 1996  Microsoft Corporation.  All Rights Reserved.
//
//      You have a royalty-free right to use, modify, reproduce and 
//      distribute the Sample Files (and/or any modified version) in 
//      any way you find useful, provided that you agree that 
//      Microsoft has no warranty obligations or liability for any 
//      Sample Application Files which are modified. 
//
//--------------------------------------------------------------------------;
//
//  debug.h
//
//  Description:
//
//
//  Notes:
//
//      To use this library at interrupt time under Win16, you must do
//      the following:
//
//      1. Defined ISRDEBUG when compiling debug.c
//  
//      2. Add a line in the SEGMENTS section of your .DEF file to
//         define the DEBUG_TEXT segment:
//
//
//      SEGMENTS
//          DEBUG_TEXT FIXED PRELOAD
//
//
//      These routines are callable at interrupt time under Win32 by
//      default.
//
//  win.ini
//  [debug]
//  SMF=0|1|2|3|4
//
//  History:
//      11/23/92    cjp     [curtisp] 
//
//==========================================================================;

#ifndef _INC_DEBUG
#define _INC_DEBUG
#ifdef __cplusplus
extern "C"
{
#endif

//
//  
//
//
//
#define  ISRDEBUG             1
#define  DEBUG_SECTION        "debug"        // section name for 
#define  DEBUG_MODULE_NAME    "smf"          // key name and prefix for output
#define  DEBUG_MAX_LINE_LEN   255            // max line length (bytes)
                                             
//- - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - ;
//
//
//
//- - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - ;

#ifdef DEBUG
    VOID WINAPI WinAssert(LPSTR lpstrExp, LPSTR lpstrFile, DWORD dwLine);
    BOOL WINAPI DbgEnable(BOOL fEnable);
    UINT WINAPI DbgSetLevel(UINT uLevel);
    UINT WINAPI DbgInitialize(BOOL fEnable);

    void FAR CDECL dprintf(UINT uDbgLevel, LPSTR szFmt, ...);

    #define assert(exp) \
        ( (exp) ? (void) 0 : WinAssert(#exp, __FILE__, __LINE__) )

    #define DPF                  dprintf

    #define D1(sz)               dprintf(1,sz) 
    #define D2(sz)               dprintf(2,sz) 
    #define D3(sz)               dprintf(3,sz) 
    #define D4(sz)               dprintf(4,sz) 
#else
    #define assert(exp)          ((void)0)
    
    #define DbgEnable(x)         FALSE
    #define DbgSetLevel(x)       0
    #define DbgInitialize(x)     0

    #define DPF                  1 ? (void)0 : (void)

    #define D1(sz)
    #define D2(sz)
    #define D3(sz)
    #define D4(sz)
#endif


#ifdef __cplusplus
}
#endif
#endif  // _INC_DEBUG
=== C:/Users/treeman/Desktop/windows nt source code\Source\Win2K3\NT\multimedia\dshow\filterus\midi\midirdr\muldiv32.h ===
//==========================================================================;
//
//  THIS CODE AND INFORMATION IS PROVIDED "AS IS" WITHOUT WARRANTY OF ANY
//  KIND, EITHER EXPRESSED OR IMPLIED, INCLUDING BUT NOT LIMITED TO THE
//  IMPLIED WARRANTIES OF MERCHANTABILITY AND/OR FITNESS FOR A PARTICULAR
//  PURPOSE.
//
//  Copyright (c) 1992 - 1996  Microsoft Corporation.  All Rights Reserved.
//
//--------------------------------------------------------------------------;
//
//  muldiv32.h
//
//  Description:
//      math routines for 32 bit signed and unsiged numbers.
//
//      MulDiv32(a,b,c) = (a * b) / c         (round down, signed)
//
//      MulDivRD(a,b,c) = (a * b) / c         (round down, unsigned)
//      MulDivRN(a,b,c) = (a * b + c/2) / c   (round nearest, unsigned)
//      MulDivRU(a,b,c) = (a * b + c-1) / c   (round up, unsigned)
//
//==========================================================================;

#ifndef _INC_MULDIV32
#define _INC_MULDIV32


#ifndef INLINE
#define INLINE __inline
#endif


#ifdef _X86_

    //
    //  Use 32-bit x86 assembly.
    //

    #pragma warning(disable:4035 4704)

    INLINE LONG MulDiv32(LONG a,LONG b,LONG c)
    {
        _asm     mov     eax,dword ptr a  //  mov  eax, a
        _asm     mov     ebx,dword ptr b  //  mov  ebx, b
        _asm     mov     ecx,dword ptr c  //  mov  ecx, c
        _asm     imul    ebx              //  imul ebx
        _asm     idiv    ecx              //  idiv ecx
        _asm	 shld	 edx, eax, 16     //  shld edx, eax, 16

    } // MulDiv32()

    INLINE DWORD MulDivRN(DWORD a,DWORD b,DWORD c)
    {
        _asm     mov     eax,dword ptr a  //  mov  eax, a
        _asm     mov     ebx,dword ptr b  //  mov  ebx, b
        _asm     mov     ecx,dword ptr c  //  mov  ecx, c
        _asm     mul     ebx              //  mul  ebx
        _asm     mov     ebx,ecx          //  mov  ebx,ecx
        _asm     shr     ebx,1            //  sar  ebx,1
        _asm     add     eax,ebx          //  add  eax,ebx
        _asm     adc     edx,0            //  adc  edx,0
        _asm     div     ecx              //  div  ecx
        _asm     shld    edx, eax, 16     //  shld edx, eax, 16

    } // MulDiv32()

    INLINE DWORD MulDivRU(DWORD a,DWORD b,DWORD c)
    {
        _asm     mov     eax,dword ptr a  //  mov  eax, a
        _asm     mov     ebx,dword ptr b  //  mov  ebx, b
        _asm     mov     ecx,dword ptr c  //  mov  ecx, c
        _asm     mul     ebx              //  mul  ebx
        _asm     mov     ebx,ecx          //  mov  ebx,ecx
        _asm     dec     ebx              //  dec  ebx
        _asm     add     eax,ebx          //  add  eax,ebx
        _asm     adc     edx,0            //  adc  edx,0
        _asm     div     ecx              //  div  ecx
        _asm     shld    edx, eax, 16     //  shld edx, eax, 16

    } // MulDivRU32()

    INLINE DWORD MulDivRD(DWORD a,DWORD b,DWORD c)
    {
        _asm     mov     eax,dword ptr a  //  mov  eax, a
        _asm     mov     ebx,dword ptr b  //  mov  ebx, b
        _asm     mov     ecx,dword ptr c  //  mov  ecx, c
        _asm     mul     ebx              //  mul  ebx
        _asm     div     ecx              //  div  ecx
        _asm     shld    edx, eax, 16     //  shld edx, eax, 16

    } // MulDivRD32()

    #pragma warning(default:4035 4704)


#else

    //
    //  Use C9 __int64 support for Daytona RISC platforms.
    //

    INLINE LONG MulDiv32( LONG a, LONG b, LONG c )
    {
        return (LONG)( Int32x32To64(a,b) / c );
    }


    INLINE DWORD MulDivRD( DWORD a, DWORD b, DWORD c )
    {
        return (DWORD)( UInt32x32To64(a,b) / c );
    }


    INLINE DWORD MulDivRN( DWORD a, DWORD b, DWORD c )
    {
        return (DWORD)( (UInt32x32To64(a,b)+c/2) / c );
    }


    INLINE DWORD MulDivRU( DWORD a, DWORD b, DWORD c )
    {
        return (DWORD)( (UInt32x32To64(a,b)+c-1) / c );
    }

#endif


//
//  some code references these by other names.
//
#define muldiv32    MulDivRN
#define muldivrd32  MulDivRD
#define muldivru32  MulDivRU

#endif  // _INC_MULDIV32
=== C:/Users/treeman/Desktop/windows nt source code\Source\Win2K3\NT\multimedia\dshow\filterus\midi\midirdr\midirdr.h ===
// Copyright (c) Microsoft Corporation 1994-1996. All Rights Reserved

extern const AMOVIESETUP_FILTER sudMIDIParse;

// CLSID_MIDIParser,
// {D51BD5A2-7548-11cf-A520-0080C77EF58A}
DEFINE_GUID(CLSID_MIDIParser,
0xd51bd5a2, 0x7548, 0x11cf, 0xa5, 0x20, 0x0, 0x80, 0xc7, 0x7e, 0xf5, 0x8a);

#include "simpread.h"
#include <qnetwork.h> // IAMMediaContent

extern "C" {
    #include "smf.h"
};

class CMIDIStream;       // manages the output stream & pin

//
// CMIDIParse
//
class CMIDIParse : 
    public CSimpleReader, 
    IAMMediaContent 
{
    friend class CMIDIStream;
public:

    // Construct our filter
    static CUnknown *CreateInstance(LPUNKNOWN lpunk, HRESULT *phr);

    CCritSec m_cStateLock;      // Lock this when a function accesses
                                // the filter state.
                                // Generally _all_ functions, since access to this
                                // filter will be by multiple threads.

private:

    DECLARE_IUNKNOWN

    STDMETHODIMP NonDelegatingQueryInterface(REFIID riid, void ** ppv);    

    // During construction we create the single CMIDIStream object that provides the
    // output pin.
    CMIDIParse(TCHAR *, LPUNKNOWN, HRESULT *);
    ~CMIDIParse();

    // pure CSimpleReader overrides
    HRESULT ParseNewFile();
    HRESULT CheckMediaType(const CMediaType* mtOut);
    LONG StartFrom(LONG sStart) { return sStart; };
    HRESULT FillBuffer(IMediaSample *pSample, DWORD dwStart, DWORD *pcSamples);
    LONG RefTimeToSample(CRefTime t);
    CRefTime SampleToRefTime(LONG s);
    ULONG GetMaxSampleSize();

    // IAMMediaContent

    STDMETHODIMP GetTypeInfoCount(THIS_ UINT FAR* pctinfo) { return E_NOTIMPL; }

    STDMETHODIMP GetTypeInfo(
      THIS_
      UINT itinfo,
      LCID lcid,
      ITypeInfo FAR* FAR* pptinfo) { return E_NOTIMPL; }

    STDMETHODIMP GetIDsOfNames(
      THIS_
      REFIID riid,
      OLECHAR FAR* FAR* rgszNames,
      UINT cNames,
      LCID lcid,
      DISPID FAR* rgdispid) { return E_NOTIMPL; }

    STDMETHODIMP Invoke(
      THIS_
      DISPID dispidMember,
      REFIID riid,
      LCID lcid,
      WORD wFlags,
      DISPPARAMS FAR* pdispparams,
      VARIANT FAR* pvarResult,
      EXCEPINFO FAR* pexcepinfo,
      UINT FAR* puArgErr) { return E_NOTIMPL; }

    STDMETHODIMP get_Copyright(BSTR FAR* pbstrCopyright);
    STDMETHODIMP get_AuthorName(BSTR FAR* pbstrAuthorName) { return E_NOTIMPL; } ;
    STDMETHODIMP get_Title(BSTR FAR* pbstrTitle) { return E_NOTIMPL; };
    STDMETHODIMP get_Rating(BSTR FAR* pbstrRating) { return E_NOTIMPL; }
    STDMETHODIMP get_Description(BSTR FAR* pbstrDescription) { return E_NOTIMPL; };
    STDMETHODIMP get_BaseURL(BSTR FAR* pbstrBaseURL) { return E_NOTIMPL; }
    STDMETHODIMP get_LogoURL(BSTR FAR* pbstrLogoURL) { return E_NOTIMPL; }
    STDMETHODIMP get_LogoIconURL(BSTR FAR* pbstrLogoIconURL) { return E_NOTIMPL; }
    STDMETHODIMP get_WatermarkURL(BSTR FAR* pbstrWatermarkURL) { return E_NOTIMPL; }
    STDMETHODIMP get_MoreInfoURL(BSTR FAR* pbstrMoreInfoURL) { return E_NOTIMPL; }
    STDMETHODIMP get_MoreInfoBannerURL(BSTR FAR* pbstrMoreInfoBannerURL) { return E_NOTIMPL; }
    STDMETHODIMP get_MoreInfoBannerImage(BSTR FAR* pbstrMoreInfoBannerImage) { return E_NOTIMPL; }
    STDMETHODIMP get_MoreInfoText(BSTR FAR* pbstrMoreInfoText) { return E_NOTIMPL; }
    

    BYTE *      m_lpFile;		// whole file, kept in memory
    HSMF	m_hsmf;			// handle for contigous reader
    HSMF	m_hsmfK;		// handle for keyframe reader
    DWORD	m_dwTimeDivision;	// used for the format

    DWORD	m_dwLastSampleRead;
};
=== C:/Users/treeman/Desktop/windows nt source code\Source\Win2K3\NT\multimedia\dshow\filterus\midi\midirdr\smf.h ===
/**********************************************************************

    Copyright (c) 1992 - 1996  Microsoft Corporation.  All Rights Reserved.

    smf.h

    DESCRIPTION:
      Public include file for Standard MIDI File access routines.

*********************************************************************/

#ifndef _SMF_
#define _SMF_

#include "global.h"             // #define's we need
//-----------------------------------------------------------------------------
//
// Debug from test app - remove later
//
extern void NEAR SeqDebug(LPSTR lpstrDebugText, ...);
//-----------------------------------------------------------------------------


typedef DWORD SMFRESULT;
typedef DWORD TICKS;
typedef TICKS FAR *PTICKS;
typedef BYTE HUGE *HPBYTE;
// !!! typedef BYTE __huge *HPBYTE;

#define MAX_TICKS           ((TICKS)0xFFFFFFFFL)

#define SMF_SUCCESS         (0L)
#define SMF_INVALID_FILE    (1L)
#define SMF_NO_MEMORY       (2L)
#define SMF_OPEN_FAILED     (3L)
#define SMF_INVALID_TRACK   (4L)
#define SMF_META_PENDING    (5L)
#define SMF_ALREADY_OPEN    (6L)
#define SMF_END_OF_TRACK    (7L)
#define SMF_NO_META         (8L)
#define SMF_INVALID_PARM    (9L)
#define SMF_INVALID_BUFFER  (10L)
#define SMF_END_OF_FILE     (11L)
#define SMF_REACHED_TKMAX   (12L)

DECLARE_HANDLE(HSMF);
DECLARE_HANDLE(HTRACK);

//-----------------------------------------------------------------------------

extern SMFRESULT FNLOCAL smfOpenFile(
    LPBYTE		lp,
    DWORD		cb,
    HSMF	       *phsmf);

extern SMFRESULT FNLOCAL smfCloseFile(
    HSMF                hsmf);

typedef struct tag_smffileinfo
{
    DWORD               dwTracks;
    DWORD               dwFormat;
    DWORD               dwTimeDivision;
    TICKS               tkLength;
    BOOL                fMSMidi; 
    LPBYTE              pbTrackName;
    LPBYTE              pbCopyright;
    WORD                wChanInUse;
}   SMFFILEINFO,
    FAR *PSMFFILEINFO;

extern SMFRESULT FNLOCAL smfGetFileInfo(
    HSMF                hsmf,
    PSMFFILEINFO        psfi);

extern void FNLOCAL smfSetChannelMask(
    HSMF                hsmf,
    WORD                wChannelMask);

extern void FNLOCAL smfSetRemapDrum(
    HSMF                hsmf,
    BOOL                fRemapDrum);                                    

//-----------------------------------------------------------------------------

extern DWORD FNLOCAL smfTicksToMillisecs(
    HSMF                hsmf,
    TICKS               tkOffset);

extern DWORD FNLOCAL smfMillisecsToTicks(
    HSMF                hsmf,
    DWORD               msOffset);

//-----------------------------------------------------------------------------

#define SMF_REF_NOMETA      0x00000001L

extern SMFRESULT FNLOCAL smfReadEvents(
    HSMF                hsmf,
    LPMIDIHDR           lpmh,
    DWORD               fdwRead,
    TICKS               tkMax,
    BOOL                fDiscardTempoEvents);

extern SMFRESULT FNLOCAL smfSeek(
    HSMF                hsmf,
    TICKS               tkPosition,
    LPMIDIHDR           lpmh);

// !!! new
extern SMFRESULT FNLOCAL smfDannySeek(
    HSMF                hsmf,
    TICKS               tkPosition,
    LPMIDIHDR           lpmh);

extern DWORD FNLOCAL smfGetTempo(
    HSMF                hsmf,
    TICKS               tkPosition);

extern DWORD FNLOCAL smfGetStateMaxSize(
    void);

extern LPWORD FNGLOBAL smfGetPatchCache(
    HSMF            hsmf);

extern LPWORD FNGLOBAL smfGetKeyCache(
    HSMF            hsmf);


//-----------------------------------------------------------------------------

//
// Buffer described by LPMIDIHDR is in polymsg format, except that it
// can contain meta-events (which will be ignored during playback by
// the current system). This means we can use the pack functions, etc.
//
#define PMSG_META       ((BYTE)0xC0)

#endif
=== C:/Users/treeman/Desktop/windows nt source code\Source\Win2K3\NT\multimedia\dshow\filterus\midi\midirdr\smfi.h ===
/**********************************************************************

    Copyright (c) 1992 - 1996  Microsoft Corporation.  All Rights Reserved.

    smfi.h

    DESCRIPTION:
      Private include file for Standard MIDI File access routines.

*********************************************************************/

#ifndef _SMFI_
#define _SMFI_

#define CH_DRUM_BASE        15
#define CH_DRUM_EXT         9

#define EV_DRUM_BASE        (MIDI_NOTEON | CH_DRUM_BASE)
#define EV_DRUM_EXT         (MIDI_NOTEON | CH_DRUM_EXT)

// 
// Handle structure for HSMF
// 

#define SMF_TF_EOT          0x00000001L
#define SMF_TF_INVALID      0x00000002L

typedef struct tag_tempomapentry
{
    TICKS           tkTempo;            // Where this change takes effect
    DWORD           msBase;             // Milliseconds already passed at this point
    DWORD           dwTempo;            // New tempo value in microseconds per quarter note
}   TEMPOMAPENTRY,
    *PTEMPOMAPENTRY;

typedef struct tag_smf *PSMF;

typedef struct tag_keyframe
{
    //
    // Meta events. All FF's indicates never seen.
    //
    BYTE        rbTempo[3];

    //
    // MIDI channel messages. FF indicates never seen.
    //
    BYTE        rbProgram[16];
    BYTE        rbControl[16*120];
}   KEYFRAME,
    FAR *PKEYFRAME;

#define KF_EMPTY ((BYTE)0xFF)

typedef struct tag_track
{
    PSMF            psmf;

    DWORD           idxTrack;           // Start of track rel to psmf->hpbImage
    
    TICKS           tkPosition;         // Tick position of last event played
    DWORD           cbLeft;             // Bytes left in track past hpbImage
    HPBYTE          hpbImage;           // Pointer to current position in track
    
    DWORD           fdwTrack;           // Flags about current state

    struct
    {
        TICKS       tkLength;
        DWORD       cbLength;
    }
    smti;                               // Returnable track information
    BYTE            bRunningStatus;     // Running status for this track

}   TRACK,
    *PTRACK;

#define SMF_F_EOF               0x00000001L
#define SMF_F_MSMIDI            0x00000002L
#define SMF_F_INSERTSYSEX       0x00000004L
#define SMF_F_REMAPDRUM         0x00000008L

#define C_TEMPO_MAP_CHK     16
typedef struct tag_smf
{
    HPBYTE          hpbImage;
    DWORD           cbImage;

    TICKS           tkPosition;
    TICKS           tkLength;
    TICKS           tkDiscardedEvents;
    DWORD           dwFormat;
    DWORD           dwTracks;
    DWORD           dwTimeDivision;
    DWORD           fdwSMF;
    WORD            wChanInUse;
    WORD            wChannelMask;

    DWORD           cTempoMap;
    DWORD           cTempoMapAlloc;
    HLOCAL          hTempoMap;
    PTEMPOMAPENTRY  pTempoMap;

    DWORD           dwPendingUserEvent;
    DWORD           cbPendingUserEvent;
    HPBYTE          hpbPendingUserEvent;

    PBYTE           pbTrackName;
    PBYTE           pbCopyright;

    WORD            awPatchCache[128];
    WORD            awKeyCache[128];
    
    // !!! new
    KEYFRAME	    kf;

    TRACK           rTracks[];
}   SMF;

typedef struct tagEVENT
{
    TICKS           tkDelta;            // Delta tick count for event
    DWORD           cbParm;             // Length of parameters if any
    HPBYTE          hpbParm;            // -> into image at paramters
    BYTE            abEvent[3];         // abEvent[0] == F0 or F7 for SysEx
                                        //            == FF for meta
                                        // Otherwise channel message (running
                                        // status expanded)
}   EVENT,
    BSTACK *SPEVENT;

#define EVENT_TYPE(event)       ((event).abEvent[0])
#define EVENT_CH_B1(event)      ((event).abEvent[1])
#define EVENT_CH_B2(event)      ((event).abEvent[2])

#define EVENT_META_TYPE(event)  ((event).abEvent[1])

//----------------------------------------------------------------------------
//
// Globals
//
extern UINT rbChanMsgLen[];


//----------------------------------------------------------------------------
// 
// Internal prototypes
//
// read.c
extern SMFRESULT FNLOCAL smfBuildFileIndex(
    PSMF BSTACK *       ppsmf);

extern DWORD FNLOCAL smfGetVDword(
    HPBYTE              hpbImage,
    DWORD               dwLeft,                                
    DWORD BSTACK *      pdw);

extern SMFRESULT FNLOCAL smfGetNextEvent(
    PSMF                psmf,
    SPEVENT             pevent,
    TICKS               tkMax);

//----------------------------------------------------------------------------
// 
// Stuff from MIDI specs
//

//
// Useful macros when dealing with hi-lo format integers
//
#define DWORDSWAP(dw) \
    ((((dw)>>24)&0x000000FFL)|\
    (((dw)>>8)&0x0000FF00L)|\
    (((dw)<<8)&0x00FF0000L)|\
    (((dw)<<24)&0xFF000000L))

#define WORDSWAP(w) \
    ((((w)>>8)&0x00FF)|\
    (((w)<<8)&0xFF00))

#define FOURCC_RMID     mmioFOURCC('R','M','I','D')
#define FOURCC_data     mmioFOURCC('d','a','t','a')
#define FOURCC_MThd     mmioFOURCC('M','T','h','d')
#define FOURCC_MTrk     mmioFOURCC('M','T','r','k')

typedef struct tag_chunkhdr
{
    FOURCC  fourccType;
    DWORD   dwLength;
}   CHUNKHDR,
    *PCHUNKHDR;

typedef struct tag_filehdr
{
    WORD    wFormat;
    WORD    wTracks;
    WORD    wDivision;
}   FILEHDR,
    *PFILEHDR;

// NOTE: This is arbitrary and only used if there is a tempo map but no
// entry at tick 0.
//
#define MIDI_DEFAULT_TEMPO      (500000L)

#define MIDI_MSG                ((BYTE)0x80)
#define MIDI_NOTEOFF            ((BYTE)0x80)
#define MIDI_NOTEON             ((BYTE)0x90)
#define MIDI_POLYPRESSURE       ((BYTE)0xA0)
#define MIDI_CONTROLCHANGE      ((BYTE)0xB0)
#define MIDI_PROGRAMCHANGE      ((BYTE)0xC0)
#define MIDI_CHANPRESSURE       ((BYTE)0xD0)
#define MIDI_PITCHBEND          ((BYTE)0xE0)
#define MIDI_META               ((BYTE)0xFF)
#define MIDI_SYSEX              ((BYTE)0xF0)
#define MIDI_SYSEXEND           ((BYTE)0xF7)

#define MIDI_META_COPYRIGHT     ((BYTE)0x02)
#define MIDI_META_TRACKNAME     ((BYTE)0x03)
#define MIDI_META_EOT           ((BYTE)0x2F)
#define MIDI_META_TEMPO         ((BYTE)0x51)
#define MIDI_META_TIMESIG       ((BYTE)0x58)
#define MIDI_META_KEYSIG        ((BYTE)0x59)
#define MIDI_META_SEQSPECIFIC   ((BYTE)0x7F)

#endif
=== C:/Users/treeman/Desktop/windows nt source code\Source\Win2K3\NT\multimedia\dshow\filterus\midi\midirdr\smf.c ===
// !!!
// This version differs slightly from the code in MCISEQ to make the API
// compatible with AVIMIDI.  Look for !!!
// !!!

/**********************************************************************
 
    Copyright (c) 1992 - 1999  Microsoft Corporation.  All Rights Reserved.

    smf.c

    DESCRIPTION:
      Routines for reading and writing Standard MIDI Files.

*********************************************************************/

// !!! #define STRICT
#include <windows.h>
#include <windowsx.h>
#include <mmsystem.h>
#include <memory.h>
#include "muldiv32.h" 
#include "smf.h"
#include "smfi.h"
#include "debug.h"

void * __stdcall memmoveInternal(void *, const void *, size_t);
#undef hmemcpy
#define hmemcpy memmoveInternal

PRIVATE SMFRESULT FNLOCAL smfInsertParmData(
    PSMF                psmf,
    TICKS               tkDelta,                                            
    LPMIDIHDR           lpmh);


// For memory mapped riff file io:

typedef struct RIFF {  
    DWORD ckid;
    DWORD cksize;
} RIFF;

typedef struct RIFFLIST {
    DWORD ckid;
    DWORD cksize;
    DWORD fccType;
} RIFFLIST;

 #ifndef FCC
  #define FCC(dw) (((dw & 0xFF) << 24) | ((dw & 0xFF00) << 8) | ((dw & 0xFF0000) >> 8) | ((dw & 0xFF000000) >> 24))
 #endif


/*****************************************************************************
 * @doc SMF EXTERNAL
 *
 * @api SMFRESULT | smfOpenFile | This function opens a MIDI file for access. No
 *  I/O can actually be performed until an HTRACK handle is obtained from
 *  <f smfOpenTrack>.
 *
 * @parm <t PSMFOPENFILESTRUCT> | psofs | Specifies the file to open and
 *  associated parameters. Contains a valid HSMF handle on success.
 *
 * @rdesc Contains the result of the operation.
 *  @flag SMF_SUCCESS | The specified file was opened.
 *  @flag SMF_OPEN_FAILED | The specified file could not be opened because it
 *   did not exist or could not be created on the disk.
 *  @flag SMF_INVALID_FILE | The specified file was corrupt or not a MIDI file.
 *  @flag SMF_NO_MEMORY | There was insufficient memory to open the file.
 *  @flag SMF_INVALID_PARM | The given flags or time division in the
 *   <t SMFOPENFILESTRUCT> were invalid.
 * 
 * @xref <t SMFOPENFILESTRUCT>, <f smfCloseFile>, <f smfOpenTrack>
 *****************************************************************************/
SMFRESULT FNLOCAL smfOpenFile(
    LPBYTE		lp,
    DWORD		cb,
    HSMF	       *phsmf)
{
    PSMF                psmf;
    SMFRESULT           smfrc = SMF_SUCCESS;
    RIFFLIST *riffptr = (RIFFLIST *) lp;

    // !!! as good a place as any?
    DbgInitialize(TRUE);

    // Now see if we can create the handle structure
    //
    psmf = (PSMF)LocalAlloc(LPTR, sizeof(SMF));
    if (NULL == psmf)
    {
        DPF(1, "smfOpenFile: LocalAlloc failed!");
        smfrc = SMF_NO_MEMORY;
        goto smf_Open_File_Cleanup;
    }

    psmf->fdwSMF = 0;
    psmf->pTempoMap = NULL;
    psmf->pbTrackName = NULL;
    psmf->pbCopyright = NULL;
    psmf->wChannelMask = 0xFFFF;

    if (riffptr->ckid == FCC('RIFF') && riffptr->fccType == FCC('RMID'))
    {
	DWORD offset = sizeof(RIFFLIST);
	RIFF * dataptr;
	
	while (offset < cb - 8) {
	    dataptr = (RIFF *) ((BYTE *) lp + offset);

	    if (dataptr->ckid == FCC('data'))
		break;

	    offset += sizeof(RIFF) + dataptr->cksize;
	}

	if (offset >= cb - 8) {
	    smfrc = SMF_INVALID_FILE;
	    goto smf_Open_File_Cleanup;
	}

        if(riffptr->cksize > cb) {
	    smfrc = SMF_INVALID_FILE;
	    goto smf_Open_File_Cleanup;
        }
        
	psmf->cbImage = riffptr->cksize;
	psmf->hpbImage = (BYTE *) (dataptr + 1);
    }
    else
    {
        psmf->cbImage = cb;
	psmf->hpbImage = lp;
    }
    
    //
    // If the file exists, parse it just enough to pull out the header and
    // build a track index.
    //
    smfrc = smfBuildFileIndex((PSMF BSTACK *)&psmf);
    if (MMSYSERR_NOERROR != smfrc)
    {
        DPF(1, "smfOpenFile: smfBuildFileIndex failed! [%lu]", (DWORD)smfrc);
    }
    else {
	// this code was in MCISeq, which did this after SMFOpen....
	// moved here, DavidMay, 11/11/96

	
	// Channel masks for getting events
	#define CHANMASK_GENERAL            0xFFFF      // 1-16
	#define CHANMASK_EXTENDED           0x03FF      // 1-10
	#define CHANMASK_BASE               0xFC00      // 11-16

	smfSetChannelMask((HSMF) psmf, CHANMASK_GENERAL);
	smfSetRemapDrum((HSMF) psmf, FALSE);
	if (psmf->fdwSMF & SMF_F_MSMIDI)
	{
	    if (psmf->wChanInUse & CHANMASK_EXTENDED)
		smfSetChannelMask((HSMF) psmf, CHANMASK_EXTENDED);
	    else
	    {
		smfSetChannelMask((HSMF) psmf, CHANMASK_BASE);
		smfSetRemapDrum((HSMF) psmf, TRUE);
	    }
	}
    }
        

smf_Open_File_Cleanup:

    if (SMF_SUCCESS != smfrc)
    {
        if (NULL != psmf)
        {
            LocalFree((HLOCAL)psmf);
        }
    }
    else
    {
        *phsmf = (HSMF)psmf;
    }
    
    return smfrc;
}

/*****************************************************************************
 *
 * @doc SMF EXTERNAL
 *
 * @api SMFRESULT | smfCloseFile | This function closes an open MIDI file.
 *  Any open tracks are closed. All data is flushed and the MIDI file is
 *  remerged with any new track data. 
 *
 * @parm HSMF | hsmf | The handle of the open file to close.
 *
 * @comm 
 *  Any track handles opened from this file handle are invalid after this
 *  call.
 *        
 * @rdesc Contains the result of the operation.
 *  @flag SMF_SUCCESS | The specified file was closed.
 *  @flag SMF_INVALID_PARM | The given handle was not valid.
 *
 * @xref <f smfOpenFile>
 *****************************************************************************/
SMFRESULT FNLOCAL smfCloseFile(
    HSMF                hsmf)
{
    PSMF                psmf        = (PSMF)hsmf;
    
    assert(psmf != NULL);
    
    //
    // Free up handle memory 
    //
    if (NULL != psmf->pbTrackName)
        LocalFree((HLOCAL)psmf->pbTrackName);
    
    if (NULL != psmf->pbCopyright)
        LocalFree((HLOCAL)psmf->pbCopyright);
    
    if (NULL != psmf->hTempoMap)
    {
        LocalUnlock(psmf->hTempoMap);
        LocalFree(psmf->hTempoMap);
    }
    
    LocalFree((HLOCAL)psmf);
    
    return SMF_SUCCESS;
}

/******************************************************************************
 *
 * @doc SMF EXTERNAL
 *
 * @api SMFRESULT | smfGetFileInfo | This function gets information about
 *  the MIDI file.
 *
 * @parm HSMF | hsmf | Specifies the open MIDI file to inquire about.
 *
 * @parm PSMFFILEINFO | psfi | A structure which will be filled in with
 *  information about the file.
 *
 * @rdesc Contains the result of the operation.
 *  @flag SMF_SUCCESS | Information was gotten about the file.
 *  @flag SMF_INVALID_PARM | The given handle was invalid.
 *
 * @xref <t SMFFILEINFO>
 *****************************************************************************/
SMFRESULT FNLOCAL smfGetFileInfo(
    HSMF                hsmf,
    PSMFFILEINFO        psfi)
{
    PSMF                psmf = (PSMF)hsmf;

    assert(psmf != NULL);
    assert(psfi != NULL);

    // 
    // Just fill in the structure with useful information.
    //
    psfi->dwTracks      = psmf->dwTracks;
    psfi->dwFormat      = psmf->dwFormat;
    psfi->dwTimeDivision= psmf->dwTimeDivision;
    psfi->tkLength      = psmf->tkLength;
    psfi->fMSMidi       = (psmf->fdwSMF & SMF_F_MSMIDI) ? TRUE : FALSE;
    psfi->pbTrackName   = (LPBYTE)psmf->pbTrackName;
    psfi->pbCopyright   = (LPBYTE)psmf->pbCopyright;
    psfi->wChanInUse    = psmf->wChanInUse;
    
    return SMF_SUCCESS;
}

/*****************************************************************************
 *
 * @doc SMF EXTERNAL
 *
 * @api void | smfSetChannelMask | This function sets the channel mask that
 *  SMF will use in all future read operations. The low bit corresponds to
 *  channel 0; the high bit to channel 15. Only 454-0055 events which are on
 *  channels with the corresponding bit set in the channel mask will be read.
 *
 * @parm HSMF | hsmf | The handle of the open file to close.
 *
 * @parm WORD | wChannelMask | The new channel mask.
 *
 * @comm
 *  Don't change this in the middle of the file unless you want to have 
 *  missing note off's for note on's that already happened. 
 *        
 *****************************************************************************/
void FNLOCAL smfSetChannelMask(
    HSMF                hsmf,
    WORD                wChannelMask)
{
    PSMF                psmf = (PSMF)hsmf;

    assert(psmf != NULL);

    DPF(1, "smfSetChannelMask(%04X)", wChannelMask);

    psmf->wChannelMask = wChannelMask;
}

/*****************************************************************************
 *
 * @doc SMF EXTERNAL
 *
 * @api void | smfRemapDrum | This function sets the remap drum flag. If
 *  this flag is set, SMF will convert all events on channel 16 to channel
 *  10.
 *
 * @parm HSMF | hsmf | The handle of the open file to close.
 *
 * @parm BOOL | fRemapDrum | The value to set the remap flag to
 *
 *****************************************************************************/
void FNLOCAL smfSetRemapDrum(
    HSMF                hsmf,
    BOOL                fRemapDrum)
{
    PSMF                psmf = (PSMF)hsmf;

    assert(psmf != NULL);

    DPF(2, "smfSetRemapDrum(%04X)", fRemapDrum);

    if (fRemapDrum)
        psmf->fdwSMF |= SMF_F_REMAPDRUM;
    else
        psmf->fdwSMF &=~SMF_F_REMAPDRUM;
}


/******************************************************************************
 *
 * @doc SMF EXTERNAL
 *
 * @api DWORD | smfTicksToMillisecs | This function returns the millisecond
 *  offset into the file given the tick offset.
 *
 * @parm HSMF | hsmf | Specifies the open MIDI file to perform the conversion
 *  on.
 *
 * @parm TICKS | tkOffset | Specifies the tick offset into the stream to convert.
 *
 * @comm
 *  The conversion is performed taking into account the file's time division and
 *  tempo map from the first track. Note that the same millisecond value
 *  might not be valid at a later time if the tempo track is rewritten.
 *
 * @rdesc Returns the number of milliseconds from the start of the stream.
 *
 * @xref <f smfMillisecsToTicks>
 *****************************************************************************/
DWORD FNLOCAL smfTicksToMillisecs(
    HSMF                hsmf,
    TICKS               tkOffset)
{
    PSMF                psmf            = (PSMF)hsmf;
    PTEMPOMAPENTRY      pTempo;
    UINT                idx;
    UINT                uSMPTE;
    DWORD               dwTicksPerSec;

    assert(psmf != NULL);

    // SMPTE time is easy -- no tempo map, just linear conversion
    // Note that 30-Drop means nothing to us here since we're not
    // converting to a colonized format, which is where dropping
    // happens.
    //
    if (psmf->dwTimeDivision & 0x8000)
    {
        uSMPTE = -(int)(char)((psmf->dwTimeDivision >> 8)&0xFF);
        if (29 == uSMPTE)
            uSMPTE = 30;
        
        dwTicksPerSec = (DWORD)uSMPTE *
                        (DWORD)(BYTE)(psmf->dwTimeDivision & 0xFF);
        
        return (DWORD)muldiv32(tkOffset, 1000L, dwTicksPerSec);
    }
       
    // Walk the tempo map and find the nearest tick position. Linearly
    // calculate the rest (using MATH.ASM)
    //

    pTempo = psmf->pTempoMap;
    assert(pTempo != NULL);
    
    for (idx = 0; idx < psmf->cTempoMap; idx++, pTempo++)
        if (tkOffset < pTempo->tkTempo)
            break;

    pTempo--;       // Want the one just BEFORE

    // pTempo is the tempo map entry preceding the requested tick offset.
    //

    return pTempo->msBase + muldiv32(tkOffset-pTempo->tkTempo,
                                     pTempo->dwTempo,
                                     1000L*psmf->dwTimeDivision);
}


/******************************************************************************
 *
 * @doc SMF EXTERNAL
 *
 * @api DWORD | smfMillisecsToTicks | This function returns the nearest tick
 *  offset into the file given the millisecond offset.
 *
 * @parm HSMF | hsmf | Specifies the open MIDI file to perform the conversion
 *  on.
 *
 * @parm DWORD | msOffset | Specifies the millisecond offset into the stream
 *  to convert.
 *
 * @comm
 *  The conversion is performed taking into account the file's time division and
 *  tempo map from the first track. Note that the same tick value
 *  might not be valid at a later time if the tempo track is rewritten.
 *  If the millisecond value does not exactly map to a tick value, then
 *  the tick value will be rounded down.
 *
 * @rdesc Returns the number of ticks from the start of the stream.
 *
 * @xref <f smfTicksToMillisecs>
 *****************************************************************************/
DWORD FNLOCAL smfMillisecsToTicks(
    HSMF                hsmf,
    DWORD               msOffset)
{
    PSMF                psmf            = (PSMF)hsmf;
    PTEMPOMAPENTRY      pTempo;
    UINT                idx;
    UINT                uSMPTE;
    DWORD               dwTicksPerSec;

    DPF(2, "smfMillisecsToTicks");
    assert(psmf != NULL);
    
    // SMPTE time is easy -- no tempo map, just linear conversion
    // Note that 30-Drop means nothing to us here since we're not
    // converting to a colonized format, which is where dropping
    // happens.
    //
    if (psmf->dwTimeDivision & 0x8000)
    {
        uSMPTE = -(int)(char)((psmf->dwTimeDivision >> 8)&0xFF);
        if (29 == uSMPTE)
            uSMPTE = 30;
        
        dwTicksPerSec = (DWORD)uSMPTE *
                        (DWORD)(BYTE)(psmf->dwTimeDivision & 0xFF);

        DPF(2, "SMPTE: dwTicksPerSec %ld", dwTicksPerSec);
        
        return (DWORD)muldiv32(msOffset, dwTicksPerSec, 1000L);
    }
    
    // Walk the tempo map and find the nearest millisecond position. Linearly
    // calculate the rest (using MATH.ASM)
    //
    pTempo = psmf->pTempoMap;
    assert(pTempo != NULL);
    
    for (idx = 0; idx < psmf->cTempoMap; idx++, pTempo++)
        if (msOffset < pTempo->msBase)
            break;

    pTempo--;       // Want the one just BEFORE

    // pTempo is the tempo map entry preceding the requested tick offset.
    //
    DPF(2, "pTempo->tkTempo %lu msBase %lu dwTempo %lu", (DWORD)pTempo->tkTempo, (DWORD)pTempo->msBase, pTempo->dwTempo);
    return pTempo->tkTempo + muldiv32(msOffset-pTempo->msBase,
                                     1000L*psmf->dwTimeDivision,
                                     pTempo->dwTempo);
}

/******************************************************************************
 *
 * @doc SMF EXTERNAL
 *
 * @api SMFRESULT | smfReadEvents | This function reads events from a track.
 *
 * @parm HSMF | hsmf | Specifies the file to read data from.
 *
 * @parm LPMIDIHDR | lpmh | Contains information about the buffer to fill.
 *
 * @parm DWORD | fdwRead | Contains flags specifying how to do the read.
 *  @flag SMF_REF_NOMETA | Meta events will not be put into the buffer.         
 *
 * @comm
 *  This function may only be called on a file opened for read access.
 * 
 * @rdesc Contains the result of the operation.
 *  @flag SMF_SUCCESS | The events were successfully read.
 *  @flag SMF_END_OF_TRACK | There are no more events to read in this track.
 *  @flag SMF_INVALID_PARM | The given handle, buffer, or flags were invalid.
 *  @flag SMF_INVALID_FILE | A disk error occured on the file.
 * 
 * @xref <f smfWriteEvents>
 *****************************************************************************/
SMFRESULT FNLOCAL smfReadEvents(
    HSMF                hsmf,
    LPMIDIHDR           lpmh,
    DWORD               fdwRead,
    TICKS               tkMax,
    BOOL                fDiscardTempoEvents)
{
    PSMF                psmf = (PSMF)hsmf;
    SMFRESULT           smfrc;
    EVENT               event;
    LPDWORD             lpdw;
    DWORD               dwTempo;

    assert(psmf != NULL);
    assert(lpmh != NULL);

    // 
    // Read events from the track and pack them into the buffer in polymsg
    // format.
    // 
    // If a SysEx or meta would go over a buffer boundry, split it.
    // 
    lpmh->dwBytesRecorded = 0;
    if (psmf->dwPendingUserEvent)
    {
        DPF(1, "smfReadEvents: Inserting pending event...");
        
        smfrc = smfInsertParmData(psmf, (TICKS)0, lpmh);
        if (SMF_SUCCESS != smfrc)
        {
            DPF(1, "smfInsertParmData() -> %u", (UINT)smfrc);
            return smfrc;
        }
    }
    
    lpdw = (LPDWORD)(lpmh->lpData + lpmh->dwBytesRecorded);

    if (psmf->fdwSMF & SMF_F_EOF)
    {
        DPF(1, "smfReadEvents: SMF_F_EOF set; instant out");
        return SMF_END_OF_FILE;
    }

    while(TRUE)
    {
        assert(lpmh->dwBytesRecorded <= lpmh->dwBufferLength);
        
        // If we know ahead of time we won't have room for the
        // event, just break out now. We need at least 3 DWORD's
        // for any event we might store - this will allow us a full
        // short event or the delta time and stub for a long
        // event to be split.
        //
        if (lpmh->dwBufferLength - lpmh->dwBytesRecorded < 3*sizeof(DWORD))
        {
            break;
        }

        smfrc = smfGetNextEvent(psmf, (SPEVENT)&event, tkMax);
        if (SMF_SUCCESS != smfrc)
        {
            // smfGetNextEvent doesn't set this because smfSeek uses it
            // as well and needs to distinguish between reaching the
            // seek point and reaching end-of-file.
            //
            // To the user, however, we present the selection between
            // their given tkBase and tkEnd as the entire file, therefore
            // we want to translate this into EOF.
            //
            if (SMF_REACHED_TKMAX == smfrc)
            {
	 	// !!! poor API!!! This prevents Read(100), Read(200) from
		// working, because the Read(200) will fail just because the
		// Read(100) succeeded and says that the EOF is reached!
                // pSmf->fdwSMF |= SMF_F_EOF;
            }
            
            DPF(2, "smfReadEvents: smfGetNextEvent() -> %u", (UINT)smfrc);
            break;
        }

        
        if (MIDI_SYSEX > EVENT_TYPE(event))
        {
            BYTE b = EVENT_TYPE(event);

            // If we're remapping drum events, and this event is on
            // channel 16, move it to channel 10 (or, 0-based, 15 to 9)
            //
            if (psmf->fdwSMF & SMF_F_REMAPDRUM &&
                ((b & 0x0F) == 0x0F))
            {
               b = (b & 0xF0) | 0x09;
            }
            
            *lpdw++ = (DWORD)(psmf->tkDiscardedEvents + event.tkDelta);
            psmf->tkDiscardedEvents = 0;
            
            *lpdw++ = 0;
            *lpdw++ = (((DWORD)MEVT_SHORTMSG)<<24) |
                      ((DWORD)b)|
                      (((DWORD)EVENT_CH_B1(event)) << 8) |
                      (((DWORD)EVENT_CH_B2(event)) << 16);
            
            lpmh->dwBytesRecorded += 3*sizeof(DWORD);
        }
        else if (MIDI_META == EVENT_TYPE(event) &&
                 MIDI_META_EOT == EVENT_META_TYPE(event))
        {
            // These are ignoreable since smfReadNextEvent()
            // takes care of track merging
            //
            DPF(1, "smfReadEvents: Hit META_EOT");
        }
        else if (MIDI_META == EVENT_TYPE(event) &&
                 MIDI_META_TEMPO == EVENT_META_TYPE(event))
        {
            if (event.cbParm != 3)
            {
                DPF(1, "smfReadEvents: Corrupt tempo event");
                return SMF_INVALID_FILE;
            }

            if( !fDiscardTempoEvents ) {
                dwTempo = (((DWORD)MEVT_TEMPO)<<24)|
                        (((DWORD)event.hpbParm[0])<<16)|
                        (((DWORD)event.hpbParm[1])<<8)|
                        ((DWORD)event.hpbParm[2]);

                *lpdw++ = (DWORD)(psmf->tkDiscardedEvents + event.tkDelta);
                psmf->tkDiscardedEvents = 0;

                // Tempo should be honored by everyone
                //
                *lpdw++ = (DWORD)-1L;
                *lpdw++ = dwTempo;

                lpmh->dwBytesRecorded += 3*sizeof(DWORD);
            }
        }
        else if (MIDI_META != EVENT_TYPE(event))
        {
            // Must be F0 or F7 system exclusive or FF meta
            // that we didn't recognize
            //
            psmf->cbPendingUserEvent = event.cbParm;
            psmf->hpbPendingUserEvent = event.hpbParm;
            psmf->fdwSMF &= ~SMF_F_INSERTSYSEX;

            switch(EVENT_TYPE(event))
            {
//                case MIDI_META:
//                    psmf->dwPendingUserEvent = ((DWORD)MEVT_META) << 24;
//                    break;

                case MIDI_SYSEX:
                    psmf->fdwSMF |= SMF_F_INSERTSYSEX;
            
                    ++psmf->cbPendingUserEvent;

                    // Falling through...
                    //

                case MIDI_SYSEXEND:
                    psmf->dwPendingUserEvent = ((DWORD)MEVT_LONGMSG) << 24;
                    break;
            }

            smfrc = smfInsertParmData(psmf,
                                      psmf->tkDiscardedEvents + event.tkDelta,
                                      lpmh);
            psmf->tkDiscardedEvents = 0;
            
            if (SMF_SUCCESS != smfrc)
            {
                DPF(1, "smfInsertParmData[2] %u", (UINT)smfrc);
                return smfrc;
            }

            lpdw = (LPDWORD)(lpmh->lpData + lpmh->dwBytesRecorded);
        }
        else
        {
            // Take into account the delta-time of any events
            // we don't actually put into the buffer
            //
            psmf->tkDiscardedEvents += event.tkDelta;
        }        
    }

    if( 0 == lpmh->dwBytesRecorded ) {
	// !!! poor API!!! This prevents Read(100), Read(200) from
	// working, because the Read(200) will fail just because the
	// Read(100) succeeded and says that the EOF is reached!
        // psmf->fdwSMF |= SMF_F_EOF;
    }

    return (psmf->fdwSMF & SMF_F_EOF) ? SMF_END_OF_FILE : SMF_SUCCESS;
}

/******************************************************************************
 *
 * @doc SMF INTERNAL
 *
 * @api SMFRESULT | smfInsertParmData | Inserts pending long data from
 *  a track into the given buffer.
 *
 * @parm PSMF | psmf | Specifies the file to read data from.
 *
 * @parm LPMIDIHDR | lpmh | Contains information about the buffer to fill.
 *
 * @comm
 *  Fills as much data as will fit while leaving room for the buffer
 *  terminator.
 *
 *  If the long data is depleted, resets <p psmf!dwPendingUserEvent> so
 *  that the next event may be read.
 * 
 * @rdesc Contains the result of the operation.
 *  @flag SMF_SUCCESS | The events were successfully read.
 *  @flag SMF_END_OF_TRACK | There are no more events to read in this track.
 *  @flag SMF_INVALID_FILE | A disk error occured on the file.
 * 
 * @xref <f smfReadEvents>
 *****************************************************************************/
PRIVATE SMFRESULT FNLOCAL smfInsertParmData(
    PSMF                psmf,
    TICKS               tkDelta,                                            
    LPMIDIHDR           lpmh)
{
    DWORD               dwLength;
    DWORD               dwRounded;
    LPDWORD             lpdw;

    assert(psmf != NULL);
    assert(lpmh != NULL);
    
    // Can't fit 4 DWORD's? (tkDelta + stream-id + event + some data) Can't do anything.
    //
    assert(lpmh->dwBufferLength >= lpmh->dwBytesRecorded);
    
    if (lpmh->dwBufferLength - lpmh->dwBytesRecorded < 4*sizeof(DWORD))
    {
        if (0 == tkDelta)
            return SMF_SUCCESS;

        // If we got here with a real delta, that means smfReadEvents screwed
        // up calculating left space and we should flag it somehow.
        //
        return SMF_INVALID_FILE;
    }

    lpdw = (LPDWORD)(lpmh->lpData + lpmh->dwBytesRecorded);

    dwLength = lpmh->dwBufferLength - lpmh->dwBytesRecorded - 3*sizeof(DWORD);
    dwLength = min(dwLength, psmf->cbPendingUserEvent);

    *lpdw++ = (DWORD)tkDelta;

    // Stream ID -- SysEx is broadcast
    //
    *lpdw++ = (DWORD)-1L;
    *lpdw++ = (psmf->dwPendingUserEvent & 0xFF000000L) | (dwLength & 0x00FFFFFFL);

    dwRounded = (dwLength + 3) & (~3L);
    
    if (psmf->fdwSMF & SMF_F_INSERTSYSEX)
    {
        *((LPBYTE)lpdw)++ = MIDI_SYSEX;
        psmf->fdwSMF &= ~SMF_F_INSERTSYSEX;
        --dwLength;
        --psmf->cbPendingUserEvent;
    }    

    hmemcpy(lpdw, psmf->hpbPendingUserEvent, dwLength);
    if (0 == (psmf->cbPendingUserEvent -= dwLength))
        psmf->dwPendingUserEvent = 0;

    lpmh->dwBytesRecorded += 3*sizeof(DWORD) + dwRounded;

    return SMF_SUCCESS;
}

/******************************************************************************
 *
 * @doc SMF EXTERNAL
 *
 * @api SMFRESULT | smfSeek | This function moves the file pointer within a track
 *  and gets the state of the track at the new position. It returns a buffer of
 *  state information which can be used to set up to play from the new position.
 *
 * @parm HTRACK | htrack | The track to seek and get state information from.
 *
 * @parm TICKS | tkPosition | The position to seek to in the track.
 *         
 * @parm LPMIDIHDR | lpmh | A buffer to contain the state information.
 *  If this pointer is NULL, then no state information will be returned.
 *
 * @comm
 *  The state information in the buffer includes patch changes, tempo changes,
 *  time signature, key signature, 
 *  and controller information. Only the most recent of these paramters before
 *  the current position will be stored. The state buffer will be returned
 *  in polymsg format so that it may be directly transmitted over the MIDI
 *  bus to bring the state up to date.
 *
 *  The buffer is mean to be sent as a streaming buffer; i.e. immediately
 *  followed by the first data buffer. If the requested tick position
 *  does not exist in the file, the last event in the buffer
 *  will be a MEVT_NOP with a delta time calculated to make sure that
 *  the next stream event plays at the proper time.
 *
 *  The meta events (tempo, time signature, key signature) will be the
 *  first events in the buffer if they exist.
 * 
 *  This function may only be called on a file opened for read access.
 *
 *  Use <f smfGetStateMaxSize> to determine the maximum size of the state
 *  information buffer. State information that will not fit into the given
 *  buffer will be lost.
 *
 *  On return, the <t dwBytesRecorded> field of <p lpmh> will contain the
 *  actual number of bytes stored in the buffer.
 *
 * @rdesc Contains the result of the operation.
 *  @flag SMF_SUCCESS | The state was successfully read.
 *  @flag SMF_END_OF_TRACK | The pointer was moved to end of track and no state
 *   information was returned.
 *  @flag SMF_INVALID_PARM | The given handle or buffer was invalid.
 *  @flag SMF_NO_MEMORY | There was insufficient memory in the given buffer to
 *   contain all of the state data.
 *
 * @xref <f smfGetStateMaxSize>
 *****************************************************************************/

PRIVATE SMFRESULT FNLOCAL smfFillBufferFromKeyframe(HSMF hsmf, LPMIDIHDR lpmh);

SMFRESULT FNLOCAL smfSeek(
    HSMF                hsmf,
    TICKS               tkPosition,
    LPMIDIHDR           lpmh)
{
    PSMF                psmf    = (PSMF)hsmf;
    PTRACK              ptrk;
    DWORD               idxTrack;
    SMFRESULT           smfrc;
    EVENT               event;
    BYTE                bEvent;
    
// !!! KEYFRAME is now part of SMF

    assert( tkPosition <= psmf->tkLength );  // Caller should guarantee this!

    _fmemset(&psmf->kf, 0xFF, sizeof(KEYFRAME));
    
    psmf->tkPosition = 0;
    psmf->tkDiscardedEvents = 0;
    psmf->fdwSMF &= ~(SMF_F_EOF|SMF_F_MSMIDI);
    
    for (ptrk = psmf->rTracks, idxTrack = psmf->dwTracks; idxTrack--; ptrk++)
    {
        ptrk->psmf              = psmf;
        ptrk->tkPosition        = 0;
        ptrk->cbLeft            = ptrk->smti.cbLength;
        ptrk->hpbImage          = psmf->hpbImage + ptrk->idxTrack;
        ptrk->bRunningStatus    = 0;
        ptrk->fdwTrack          = 0;
    }

    // If we're starting at zero, let events get sent in normal buffer.
    // Else seek through tkPosition-1 to get everything before where we're
    // going to start playing. This avoids the problem of discardind
    // the non-keyframe events (such as note on's) at the tick tkPosition.
    //
    smfrc = SMF_REACHED_TKMAX;
    
    if (tkPosition)
    {
        --tkPosition;
        while (SMF_SUCCESS == (smfrc = smfGetNextEvent(psmf, (SPEVENT)&event, tkPosition)))
        {
            if (MIDI_META == (bEvent = EVENT_TYPE(event)))
            {
                if (EVENT_META_TYPE(event) == MIDI_META_TEMPO)
                {
                    if (event.cbParm != sizeof(psmf->kf.rbTempo))
                        return SMF_INVALID_FILE;

                    hmemcpy((HPBYTE)psmf->kf.rbTempo, event.hpbParm, event.cbParm);
                }
            }
            else switch(bEvent & 0xF0)
            {
 case MIDI_PROGRAMCHANGE:
     psmf->kf.rbProgram[bEvent & 0x0F] = EVENT_CH_B1(event);
     break;

 case MIDI_CONTROLCHANGE:
     psmf->kf.rbControl[(((WORD)bEvent & 0x0F)*120) + EVENT_CH_B1(event)] =
         EVENT_CH_B2(event);
     break;
            }
        }
    }

    //
    //  If we hit EOF, then we must have been seeking for the end.
    //
    if( ( SMF_REACHED_TKMAX != smfrc )  &&
        ( SMF_END_OF_FILE   != smfrc ) )
    {
        return smfrc;
    }

#ifdef DEBUG
    if( (SMF_END_OF_FILE==smfrc) && (tkPosition!=psmf->tkLength) ) {
        DPF(1,"smfSeek: hit EOF, yet we weren't seeking to the end (tkPosition=%lu, tkLength=%lu).",tkPosition,psmf->tkLength);
    }
#endif

    // Now fill the buffer from our keyframe data
    // !!! This part has been pulled out into a separate function
    smfrc = smfFillBufferFromKeyframe(hsmf, lpmh);

    // Force all tracks to be at tkPosition. We are guaranteed that
    // all tracks will be past the event immediately preceding tkPosition;
    // this will force correct delta-ticks to be generated so that events
    // on all tracks will line up properly on a seek into the middle of the
    // file.
    //
// !!! I think this is commented out because of the --tkPosition added above
//    for (ptrk = psmf->rTracks, idxTrack = psmf->dwTracks; idxTrack--; ptrk++)
//    {
//        ptrk->tkPosition        = tkPosition;
//    }

    return smfrc;
    
}
    

// !!! Danny's new function to seek forward a bit and keep the old keyframe
// info around, only adding to it, to avoid every seek seeking from the
// beginning of the file.  You would use it like:
//
// smfSeek(10);
// smfDannySeek(20);
// smfDannySeek(30);
//
// which will work as long as you make no other calls on this handle in between.
// The subsequent seeks will NOT re-seek from the beginning, but remember where
// they left off.
//
SMFRESULT FNLOCAL smfDannySeek(
    HSMF                hsmf,
    TICKS               tkPosition,
    LPMIDIHDR           lpmh)
{
    PSMF                psmf    = (PSMF)hsmf;
    SMFRESULT           smfrc;
    EVENT               event;
    BYTE                bEvent;
    
    assert( tkPosition <= psmf->tkLength );  // Caller should guarantee this!

    if (tkPosition < psmf->tkPosition) {
        DPF(1,"smfDannySeek: not seeking forward... doing a REAL seek");
	return smfSeek(hsmf, tkPosition, lpmh);
    }

    // If we're starting at zero, let events get sent in normal buffer.
    // Else seek through tkPosition-1 to get everything before where we're
    // going to start playing. This avoids the problem of discardind
    // the non-keyframe events (such as note on's) at the tick tkPosition.
    //
    smfrc = SMF_REACHED_TKMAX;
    
    if (tkPosition)
    {
        --tkPosition;
        while (SMF_SUCCESS == (smfrc = smfGetNextEvent(psmf, (SPEVENT)&event, tkPosition)))
        {
            if (MIDI_META == (bEvent = EVENT_TYPE(event)))
            {
                if (EVENT_META_TYPE(event) == MIDI_META_TEMPO)
                {
                    if (event.cbParm != sizeof(psmf->kf.rbTempo))
                        return SMF_INVALID_FILE;

                    hmemcpy((HPBYTE)psmf->kf.rbTempo, event.hpbParm, event.cbParm);
                }
            }
            else switch(bEvent & 0xF0)
            {
 case MIDI_PROGRAMCHANGE:
     psmf->kf.rbProgram[bEvent & 0x0F] = EVENT_CH_B1(event);
     break;

 case MIDI_CONTROLCHANGE:
     psmf->kf.rbControl[(((WORD)bEvent & 0x0F)*120) + EVENT_CH_B1(event)] =
         EVENT_CH_B2(event);
     break;
            }
        }
    }

    //
    //  If we hit EOF, then we must have been seeking for the end.
    //
    if( ( SMF_REACHED_TKMAX != smfrc )  &&
        ( SMF_END_OF_FILE   != smfrc ) )
    {
        return smfrc;
    }

#ifdef DEBUG
    if( (SMF_END_OF_FILE==smfrc) && (tkPosition!=psmf->tkLength) ) {
        DPF(1,"smfSeek: hit EOF, yet we weren't seeking to the end (tkPosition=%lu, tkLength=%lu).",tkPosition,psmf->tkLength);
    }
#endif

    // Now fill the buffer from our keyframe data
    return smfFillBufferFromKeyframe(hsmf, lpmh);
}


// !!! new function
SMFRESULT FNLOCAL smfFillBufferFromKeyframe(HSMF hsmf, LPMIDIHDR lpmh)
{
    UINT                idx;
    UINT                idxChannel;
    UINT                idxController;
    LPDWORD             lpdw;
    PSMF                psmf    = (PSMF)hsmf;

    // Build lpmh from keyframe
    //
    lpmh->dwBytesRecorded = 0;
    lpdw = (LPDWORD)lpmh->lpData;

    // Tempo change event?
    //
    if (KF_EMPTY != psmf->kf.rbTempo[0] ||
        KF_EMPTY != psmf->kf.rbTempo[1] ||
        KF_EMPTY != psmf->kf.rbTempo[2])
    {
        if (lpmh->dwBufferLength - lpmh->dwBytesRecorded < 3*sizeof(DWORD))
            return SMF_NO_MEMORY;

        *lpdw++ = 0;
        *lpdw++ = 0;
        *lpdw++ = (((DWORD)psmf->kf.rbTempo[0])<<16)|
                  (((DWORD)psmf->kf.rbTempo[1])<<8)|
                  ((DWORD)psmf->kf.rbTempo[2])|
                  (((DWORD)MEVT_TEMPO) << 24);

        lpmh->dwBytesRecorded += 3*sizeof(DWORD);
    }

    // Program change events?
    //
    for (idx = 0; idx < 16; idx++)
    {
        if (KF_EMPTY != psmf->kf.rbProgram[idx])
        {
            if (lpmh->dwBufferLength - lpmh->dwBytesRecorded < 3*sizeof(DWORD))
                return SMF_NO_MEMORY;

            *lpdw++ = 0;
            *lpdw++ = 0;
            *lpdw++ = (((DWORD)MEVT_SHORTMSG) << 24)      |
                      ((DWORD)MIDI_PROGRAMCHANGE)         |
                      ((DWORD)idx)                        |
                      (((DWORD)psmf->kf.rbProgram[idx]) << 8);

            lpmh->dwBytesRecorded += 3*sizeof(DWORD);
        }
    }

    // Controller events?
    //
    idx = 0;
    for (idxChannel = 0; idxChannel < 16; idxChannel++)
    {
        for (idxController = 0; idxController < 120; idxController++)
        {
            if (KF_EMPTY != psmf->kf.rbControl[idx])
            {
                if (lpmh->dwBufferLength - lpmh->dwBytesRecorded < 3*sizeof(DWORD))
                    return SMF_NO_MEMORY;

                *lpdw++ = 0;
                *lpdw++ = 0;
                *lpdw++ = (((DWORD)MEVT_SHORTMSG << 24)     |
                          ((DWORD)MIDI_CONTROLCHANGE)       |
                          ((DWORD)idxChannel)               |
                          (((DWORD)idxController) << 8)     |
                          (((DWORD)psmf->kf.rbControl[idx]) << 16));

                lpmh->dwBytesRecorded += 3*sizeof(DWORD);
            }

            idx++;
        }
    }

    return SMF_SUCCESS;
}

DWORD FNLOCAL smfGetTempo(
    HSMF                hsmf,
    TICKS               tkPosition)
{
    PSMF                psmf     = (PSMF)hsmf;
    PTEMPOMAPENTRY      pTempo;
    UINT                idx;
    
    // Walk the tempo map and find the nearest tick position. Linearly
    // calculate the rest (using MATH.ASM)
    //

    pTempo = psmf->pTempoMap;
    assert(pTempo != NULL);
    
    for (idx = 0; idx < psmf->cTempoMap; idx++, pTempo++)
        if (tkPosition < pTempo->tkTempo)
            break;

    pTempo--;       // Want the one just BEFORE

    // pTempo is the tempo map entry preceding the requested tick offset.
    //
    return pTempo->dwTempo;
}
                          

/******************************************************************************
 *
 * @doc SMF EXTERNAL
 *
 * @api SMFRESULT | smfGetStateMaxSize | This function returns the maximum size
 *  of buffer that is needed to hold the state information returned by
 *  <f smfSeek>.
 *
 * @parm PDWORD | pdwSize | Gets the size in bytes that should be allocated
 *  for the state buffer.
 *
 * @rdesc Contains the result of the operation.
 *  @flag SMF_SUCCESS | The state was successfully read.
 *
 * @xref <f smfSeek>
 *****************************************************************************/
DWORD FNLOCAL smfGetStateMaxSize(
    void)
{
    return  3*sizeof(DWORD) +           // Tempo
            3*16*sizeof(DWORD) +        // Patch changes
            3*16*120*sizeof(DWORD) +    // Controller changes
            3*sizeof(DWORD);            // Time alignment NOP
}

/******************************************************************************
 *
 * @doc SMF EXTERNAL
 *
 * @api LPWORD | smfGetPatchCache | This function returns the patch cache
 *  array for the given MIDI file. This information was compiled at file open
 *  time. The returned pointer points to an array suitable for
 *  midiOutCachePatches.
 *
 * @parm HSMF | hsmf | The handle of the open file to get patch information from.
 *
 * @xref <f smfGetKeyCache>
 *****************************************************************************/
LPWORD FNGLOBAL smfGetPatchCache(
    HSMF            hsmf)
{
    PSMF            psmf    = (PSMF)hsmf;

    assert(psmf != NULL);

    return (LPWORD)psmf->awPatchCache;
}

/******************************************************************************
 *
 * @doc SMF EXTERNAL
 *
 * @api LPWORD | smfGetKeyCache | This function returns the key cache
 *  array for the given MIDI file. This information was compiled at file open
 *  time. The returned pointer points to an array suitable for
 *  midiOutCacheDrumPatches.
 *
 * @parm HSMF | hsmf | The handle of the open file to get key information from.
 *
 * @xref <f smfGetPatchCache>
 *****************************************************************************/
LPWORD FNGLOBAL smfGetKeyCache(
    HSMF            hsmf)
{
    PSMF            psmf    = (PSMF)hsmf;

    assert(psmf != NULL);

    return (LPWORD)psmf->awKeyCache;
}
=== C:/Users/treeman/Desktop/windows nt source code\Source\Win2K3\NT\multimedia\dshow\filterus\midi\midirdr\midirdr.cpp ===
// Copyright (c) 1994 - 1998  Microsoft Corporation.  All Rights Reserved.

//
//  WAV file parser
//

// Caveats
//

#include <streams.h>
#include <windowsx.h>
#include "midif.h"

#ifdef FILTER_DLL
#include <initguid.h>
#endif
#include <mmsystem.h>

#include "midirdr.h"
// We break MIDI data up into samples of 1s each - constant time, variable
// size.
#define MSPERSAMPLE	1000L	// smaller buffers break up too often

//
// setup data
//

// !!!! is this a good idea???
#define MEDIASUBTYPE_Midi	MEDIATYPE_Midi

const AMOVIESETUP_MEDIATYPE
psudMIDIParseType[] = { { &MEDIATYPE_Stream       // 1. clsMajorType
                        , &MEDIASUBTYPE_Midi } }; //    clsMinorType


const AMOVIESETUP_MEDIATYPE
sudMIDIParseOutType = { &MEDIATYPE_Midi       // 1. clsMajorType
                       , &MEDIASUBTYPE_NULL }; //    clsMinorType

const AMOVIESETUP_PIN
psudMIDIParsePins[] =  { { L"Input"             // strName
		    , FALSE                // bRendered
		    , FALSE                // bOutput
		    , FALSE                // bZero
		    , FALSE                // bMany
		    , &CLSID_NULL          // clsConnectsToFilter
		    , L""                  // strConnectsToPin
		    , 1                    // nTypes
		    , psudMIDIParseType }, // lpTypes
		         { L"Output"             // strName
		    , FALSE                // bRendered
		    , TRUE                 // bOutput
		    , FALSE                // bZero
		    , FALSE                // bMany
		    , &CLSID_NULL          // clsConnectsToFilter
		    , L""                  // strConnectsToPin
		    , 1                    // nTypes
		    , &sudMIDIParseOutType } }; // lpTypes

const AMOVIESETUP_FILTER
sudMIDIParse = { &CLSID_MIDIParser     // clsID
               , L"MIDI Parser"        // strName
               , MERIT_UNLIKELY        // dwMerit
               , 2                     // nPins
               , psudMIDIParsePins };   // lpPin

#ifdef FILTER_DLL
// COM global table of objects available in this dll
CFactoryTemplate g_Templates[] = {

    { L"MIDI Parser"
    , &CLSID_MIDIParser
    , CMIDIParse::CreateInstance
    , NULL
    , &sudMIDIParse }
};
int g_cTemplates = sizeof(g_Templates) / sizeof(g_Templates[0]);

// exported entry points for registration and
// unregistration (in this case they only call
// through to default implmentations).
//
STDAPI DllRegisterServer()
{
  return AMovieDllRegisterServer2( TRUE );
}

STDAPI DllUnregisterServer()
{
  return AMovieDllRegisterServer2( FALSE );
}
#endif

//
// CMIDIParse::Constructor
//
CMIDIParse::CMIDIParse(TCHAR *pName, LPUNKNOWN lpunk, HRESULT *phr)
    : CSimpleReader(pName, lpunk, CLSID_MIDIParser, &m_cStateLock, phr),
	m_hsmf(NULL),
	m_hsmfK(NULL),
	m_dwTimeDivision(0),
	m_lpFile(NULL)
{

    CAutoLock l(&m_cStateLock);

    DbgLog((LOG_TRACE, 1, TEXT("CMIDIParse created")));
}


//
// CMIDIParse::Destructor
//
CMIDIParse::~CMIDIParse(void) {
    if (m_hsmf)
	smfCloseFile(m_hsmf);
    if (m_hsmfK)
	smfCloseFile(m_hsmfK);

    delete[] m_lpFile;
    
    DbgLog((LOG_TRACE, 1, TEXT("CMIDIParse destroyed")) );
}


//
// CreateInstance
//
// Called by CoCreateInstance to create a QuicktimeReader filter.
CUnknown *CMIDIParse::CreateInstance(LPUNKNOWN lpunk, HRESULT *phr) {

    CUnknown *punk = new CMIDIParse(NAME("MIDI parsing filter"), lpunk, phr);
    if (punk == NULL) {
        *phr = E_OUTOFMEMORY;
    }
    return punk;
}

STDMETHODIMP
CMIDIParse::NonDelegatingQueryInterface(REFIID riid, void **ppv)
{
    if(riid == IID_IAMMediaContent)
    {
        return GetInterface((IAMMediaContent  *)this, ppv);
    }
    else
    {
        return CSimpleReader::NonDelegatingQueryInterface(riid, ppv);
    }
}


HRESULT CMIDIParse::ParseNewFile()
{
    HRESULT         hr = NOERROR;

    LONGLONG llTotal, llAvailable;

    for (;;) {
	hr = m_pAsyncReader->Length(&llTotal, &llAvailable);
	if (FAILED(hr))
	    return hr;

	if (hr != VFW_S_ESTIMATED)
	    break;	// success....

        MSG Message;
        while (PeekMessage(&Message, NULL, 0, 0, TRUE))
        {
            TranslateMessage(&Message);
            DispatchMessage(&Message);
        }
        
	Sleep(10);	// wait until file has finished reading....
    }

	
    DWORD cbFile = (DWORD) llTotal;

    //
    // Something bogus to force a seek on first read
    //
    m_dwLastSampleRead = (DWORD) -64;
    
    m_lpFile = new BYTE[cbFile];

    if (!m_lpFile)
	goto memerror;
    
    /* Try to read whole file */
    hr = m_pAsyncReader->SyncRead(0, cbFile, m_lpFile);

    if (hr != S_OK)
        goto readerror;

    
    {
	// call smfOpenFile to set up the MIDI parser....

	SMFRESULT f = smfOpenFile(m_lpFile, cbFile, &m_hsmf);
	if (f != SMF_SUCCESS) {
	    DbgLog((LOG_ERROR,1,TEXT("*Error %d opening MIDI file"), (int)f));
	    goto formaterror;
	}

	f = smfOpenFile(m_lpFile, cbFile, &m_hsmfK);
	if (f != SMF_SUCCESS) {
	    DbgLog((LOG_ERROR,1,TEXT("*Error %d opening MIDI file"), (int)f));
	    goto formaterror;
	}

	// Get the length (in samples)
	SMFFILEINFO	sfi;
	f = smfGetFileInfo(m_hsmf, &sfi);
	if (f != SMF_SUCCESS) {
	    DbgLog((LOG_ERROR,1,TEXT("*Error %d from smfGetFileInfo"), f));
	    // !!! Now what?
	}
	m_dwTimeDivision = sfi.dwTimeDivision;	// save for the format
	// Get the length of the file in ms and convert to samples
	DWORD dwLength = smfTicksToMillisecs(m_hsmf, sfi.tkLength);
	m_sLength = (dwLength + MSPERSAMPLE - 1) / MSPERSAMPLE;
    }

    {
	CMediaType mtMIDI;

	if (mtMIDI.AllocFormatBuffer(sizeof(MIDIFORMAT)) == NULL)
	    goto memerror;

	ZeroMemory((BYTE *) mtMIDI.Format(), sizeof(MIDIFORMAT));

	// !!! get format
	((MIDIFORMAT *) (mtMIDI.Format()))->dwDivision = m_dwTimeDivision;


	mtMIDI.SetType(&MEDIATYPE_Midi);
	mtMIDI.SetFormatType(&GUID_NULL);
	mtMIDI.SetVariableSize();
	mtMIDI.SetTemporalCompression(FALSE);
	// !!! anything else?

	SetOutputMediaType(&mtMIDI);
    }
    
    return hr;

memerror:
    hr = E_OUTOFMEMORY;
    goto error;

formaterror:
    hr = VFW_E_INVALID_FILE_FORMAT;
    goto error;

readerror:
    hr = VFW_E_INVALID_FILE_FORMAT;

error:
    return hr;
}


ULONG CMIDIParse::GetMaxSampleSize()
{
    DWORD dwSize = 2 * sizeof(MIDIHDR) + smfGetStateMaxSize() +
	MulDiv(1 /*lSamples*/ * MSPERSAMPLE, 31250 * 4, 1000);	// !!!

    // midi stream buffers can't be bigger than this....
    if (dwSize > 30000)
	dwSize = 30000;
    
    return dwSize;
}


// !!! rounding
// returns the sample number showing at time t
LONG
CMIDIParse::RefTimeToSample(CRefTime t)
{
    // Rounding down
    LONG s = (LONG) ((t.GetUnits() * MILLISECONDS / MSPERSAMPLE) / UNITS);
    return s;
}

CRefTime
CMIDIParse::SampleToRefTime(LONG s)
{
    // Rounding up
    return llMulDiv( s, MSPERSAMPLE * UNITS, MILLISECONDS, MILLISECONDS-1 );
}


HRESULT
CMIDIParse::CheckMediaType(const CMediaType* pmt)
{
    if (*(pmt->Type()) != MEDIATYPE_Stream)
        return E_INVALIDARG;

    if (*(pmt->Subtype()) != MEDIASUBTYPE_Midi)
        return E_INVALIDARG;

    return S_OK;
}


HRESULT CMIDIParse::FillBuffer(IMediaSample *pSample, DWORD dwStart, DWORD *pdwSamples)
{
    PBYTE pbuf;
    const DWORD lSamples = 1;

    DWORD dwSize = pSample->GetSize();
    
    HRESULT hr = pSample->GetPointer(&pbuf);
    if (FAILED(hr)) {
	DbgLog((LOG_ERROR,1,TEXT("pSample->GetPointer failed!")));
	pSample->Release();
	return E_OUTOFMEMORY;
    }

    // Seek to the spot we'll begin reading from, and get keyframe info to
    // write our keyframe. Since this disturbs reading the file contiguously,
    // we have our own file handle for this.

    TICKS tk = smfMillisecsToTicks(m_hsmfK, dwStart * MSPERSAMPLE);
    LPMIDIHDR lpmh = (LPMIDIHDR)pbuf;
    lpmh->lpData = (LPSTR)lpmh + sizeof(MIDIHDR);
    lpmh->dwBufferLength    = dwSize - sizeof(MIDIHDR);
    lpmh->dwBytesRecorded   = 0;
    lpmh->dwFlags           = 0;

    // the API smfSeek() starts looking from the beginning, and takes forever
    // if you are seeking way into the file.  We can't do that while streaming
    // playback, there is no time.  So if we are just being asked for the next
    // portion of MIDI after the last one we just gave, we will do a special
    // seek I wrote that remembers the keyframe last time and adds just the
    // new bits for this next section.

    SMFRESULT smfrc;
    
    if (m_dwLastSampleRead != dwStart - 1) {
        DbgLog((LOG_TRACE,4,TEXT("Doing a REAL seek from the beginning for keyframe info")));
        if ((smfrc = smfSeek(m_hsmfK, tk, lpmh)) != SMF_SUCCESS) {
	    return E_FAIL;
        }
    } else {
        DbgLog((LOG_TRACE,4,TEXT("Doing a small forward seek for keyframe info")));
        if ((smfrc = smfDannySeek(m_hsmfK, tk, lpmh)) != SMF_SUCCESS) {
	    return E_FAIL;
        }
    }

    lpmh->dwBufferLength = (lpmh->dwBytesRecorded + 3) & ~3;
    DbgLog((LOG_TRACE,3,TEXT("Key frame is %ld bytes"), lpmh->dwBytesRecorded));

    // Now prepare to read the actual data for these samples.
    // !!! I'll bet this blows up when dwSize > 64K even if data read < 64K
    // because we're already offset in the pointer!
    lpmh = (LPMIDIHDR)((LPBYTE)lpmh + sizeof(MIDIHDR) + lpmh->dwBufferLength);
    lpmh->lpData = (LPSTR)lpmh + sizeof(MIDIHDR);
    lpmh->dwBufferLength    = dwSize - (DWORD)((LPBYTE)lpmh - pbuf) - sizeof(MIDIHDR);
    lpmh->dwBytesRecorded   = 0;
    lpmh->dwFlags           = 0;

    // We are NOT reading contiguously, so we'll have to do a seek to get to
    // the right spot.
    if (m_dwLastSampleRead != dwStart - 1) {
        DbgLog((LOG_TRACE,1,TEXT("Discontiguous Read:  Seeking from %ld to %ld")
					, m_dwLastSampleRead, dwStart));
	tk = smfMillisecsToTicks(m_hsmf, dwStart * MSPERSAMPLE);
	if ((smfrc = smfSeek(m_hsmf, tk, lpmh)) != SMF_SUCCESS) {
	    return E_FAIL;
	}
    }

    // We are reading contiguously, simply continue where we left off, with
    // a new high limit

    tk = smfMillisecsToTicks(m_hsmf, (dwStart + lSamples) * MSPERSAMPLE);
    smfrc = smfReadEvents(m_hsmf, lpmh, 0, tk, FALSE);
    if (smfrc != SMF_SUCCESS && smfrc != SMF_END_OF_FILE)
	return E_FAIL;
    
    lpmh->dwBufferLength = (lpmh->dwBytesRecorded + 3) & ~3;
    DWORD dwReadSize = lpmh->dwBufferLength + sizeof(MIDIHDR) + (DWORD)((LPBYTE)lpmh - pbuf);
    DbgLog((LOG_TRACE,3,TEXT("Data is %ld bytes"), lpmh->dwBytesRecorded));

    // Looks like we're actually going to return success; update the last sample
    // we returned to them.
    m_dwLastSampleRead = dwStart;
    
    hr = pSample->SetActualDataLength(dwReadSize);
    ASSERT(SUCCEEDED(hr));

    // mark as a sync point if it should be....
    pSample->SetSyncPoint(TRUE);  // !!!
	
    *pdwSamples = 1;

    return S_OK;
}

HRESULT CMIDIParse::get_Copyright(BSTR FAR* pbstrCopyright)
{
    //
    // If the file has a Copyright meta-event, use that
    //
    HRESULT hr = VFW_E_NOT_FOUND;

    if( m_hsmf )
    {    
        SMFFILEINFO sfi;
        SMFRESULT f = smfGetFileInfo(m_hsmf, &sfi);
        if (f == SMF_SUCCESS) 
        {
            if( sfi.pbCopyright )
            {
                DWORD dwcch = strlen( (char *)sfi.pbCopyright );
                *pbstrCopyright = SysAllocStringLen( 0, dwcch + 1 );
                if(*pbstrCopyright)
                {
                    MultiByteToWideChar(CP_ACP, 0, (char *)sfi.pbCopyright, -1, *pbstrCopyright, dwcch + 1);
                    hr = S_OK;
                }
                else
                {
                    hr = E_OUTOFMEMORY;
                }
            }
        }
    }                    
    return hr;
}
=== C:/Users/treeman/Desktop/windows nt source code\Source\Win2K3\NT\multimedia\dshow\filterus\midi\midirdr\smfread.c ===
// !!!
// This version differs slightly from the code in MCISEQ to make the API
// compatible with AVIMIDI.  Look for !!!
// !!!

/**********************************************************************

    Copyright (c) 1992 - 1996  Microsoft Corporation.  All Rights Reserved.

    read.c

    DESCRIPTION:
      Routines for reading Standard MIDI Files.

*********************************************************************/

// !!! #define STRICT
#include <windows.h>
#include <windowsx.h>
#include <mmsystem.h>
#include <memory.h>
#include "muldiv32.h" 
#include "smf.h"
#include "smfi.h"
#include "debug.h"

void * __stdcall memmoveInternal(void *, const void *, size_t);
#undef hmemcpy
#define hmemcpy memmoveInternal

UINT rbChanMsgLen[] =
{ 
    0,                      // 0x   not a status byte
    0,                      // 1x   not a status byte
    0,                      // 2x   not a status byte
    0,                      // 3x   not a status byte
    0,                      // 4x   not a status byte
    0,                      // 5x   not a status byte
    0,                      // 6x   not a status byte
    0,                      // 7x   not a status byte
    3,                      // 8x   Note off
    3,                      // 9x   Note on
    3,                      // Ax   Poly pressure
    3,                      // Bx   Control change
    2,                      // Cx   Program change
    2,                      // Dx   Chan pressure
    3,                      // Ex   Pitch bend change
    0,                      // Fx   SysEx (see below)                  
} ;

PRIVATE SMFRESULT FNLOCAL smfAddTempoMapEntry(
    PSMF                    psmf,                                       
    EVENT BSTACK            *pevent);

/******************************************************************************
 *
 * @doc SMF INTERNAL
 *
 * @func SMFRESULT | smfBuildFileIndex | Preliminary parsing of a MIDI file.
 *
 * @parm PSMF BSTACK * | ppsmf | Pointer to a returned SMF structure if the
 *  file is successfully parsed.
 *
 * @comm
 *  This function validates the format of and existing MIDI or RMI file
 *  and builds the handle structure which will refer to it for the
 *  lifetime of the instance.
 *  
 *  The file header information will be read and verified, and
 *  <f smfBuildTrackIndices> will be called on every existing track
 *  to build keyframes and validate the track format.
 *
 * @rdesc Contains the result of the operation.
 *  @flag SMF_SUCCESS | The events were successfully read.
 *  @flag SMF_NO_MEMORY | Out of memory to build key frames.
 *  @flag SMF_INVALID_FILE | A disk or parse error occured on the file.
 * 
 * @xref <f smfTrackIndices>
 *****************************************************************************/

SMFRESULT FNLOCAL smfBuildFileIndex(
    PSMF BSTACK         *ppsmf)
{
    SMFRESULT           smfrc;
    CHUNKHDR UNALIGNED FAR *      pch;
    FILEHDR UNALIGNED FAR *       pfh;
    DWORD               i;
    PSMF                psmf,
                        psmfTemp;
    PTRACK              ptrk;
    WORD                wMemory;
    DWORD               dwLeft;
    HPBYTE              hpbImage;
    
    DWORD               idxTrack;
    EVENT               event;
    DWORD               dwLength;
    WORD                wChanInUse;
    WORD                wFirstNote;
    const WORD          WORD_MAX = ~0;
    const DWORD         MAX_NUMBER_OF_TRACKS = (WORD_MAX - sizeof(SMF)) / sizeof(TRACK);

    assert(ppsmf != NULL);

    psmf = *ppsmf;

    assert(psmf != NULL);

    // MIDI data image is already in hpbImage (already extracted from
    // RIFF header if necessary).
    //

    // Validate MIDI header
    //
    dwLeft   = psmf->cbImage;
    hpbImage = psmf->hpbImage;
    
    if (dwLeft < sizeof(CHUNKHDR))
        return SMF_INVALID_FILE;

    pch = (CHUNKHDR UNALIGNED FAR *)hpbImage;

    dwLeft   -= sizeof(CHUNKHDR);
    hpbImage += sizeof(CHUNKHDR);
    
    if (pch->fourccType != FOURCC_MThd)
        return SMF_INVALID_FILE;

    dwLength = DWORDSWAP(pch->dwLength);
    if (dwLength < sizeof(FILEHDR) || dwLength > dwLeft)
        return SMF_INVALID_FILE;

    pfh = (FILEHDR UNALIGNED FAR *)hpbImage;

    dwLeft   -= dwLength;
    hpbImage += dwLength;
    
    psmf->dwFormat       = (DWORD)(WORDSWAP(pfh->wFormat));
    DPF(1, "*This MIDI file is format %ld", psmf->dwFormat);	// !!!
    psmf->dwTracks       = (DWORD)(WORDSWAP(pfh->wTracks));
    DPF(1, "*This MIDI file has %ld tracks", psmf->dwTracks);	// !!!
    psmf->dwTimeDivision = (DWORD)(WORDSWAP(pfh->wDivision));

    //
    // We've successfully parsed the header. Now try to build the track
    // index.
    // 
    // We only check out the track header chunk here; the track will be
    // preparsed after we do a quick integretiy check.
    //

    if( psmf->dwTracks > MAX_NUMBER_OF_TRACKS ) {
        return SMF_INVALID_FILE;
    }

    wMemory = sizeof(SMF) + (WORD)(psmf->dwTracks*sizeof(TRACK)); 
    psmfTemp = (PSMF)LocalReAlloc((HLOCAL)psmf, wMemory, LMEM_MOVEABLE|LMEM_ZEROINIT);

    if (NULL == psmfTemp)
    {
        DPF(1, "No memory for extended psmf");
        return SMF_NO_MEMORY;
    }

    psmf = *ppsmf = psmfTemp;
    ptrk = psmf->rTracks;
    
    for (i=0; i<psmf->dwTracks; i++)
    {
        if (dwLeft < sizeof(CHUNKHDR))
            return SMF_INVALID_FILE;

        pch = (CHUNKHDR UNALIGNED FAR *)hpbImage;

        dwLeft   -= sizeof(CHUNKHDR);
        hpbImage += sizeof(CHUNKHDR);

        if (pch->fourccType != FOURCC_MTrk)
            return SMF_INVALID_FILE;
        
        ptrk->idxTrack      = (DWORD)(hpbImage - psmf->hpbImage);
        ptrk->smti.cbLength = DWORDSWAP(pch->dwLength);

        if (ptrk->smti.cbLength > dwLeft)
        {
            DPF(1, "Track longer than file!");
            return SMF_INVALID_FILE;
        }

        dwLeft   -= ptrk->smti.cbLength;
        hpbImage += ptrk->smti.cbLength;

        ptrk++;
    }

    // File looks OK. Now preparse, doing the following:
    // (1) Build tempo map so we can convert to/from ticks quickly
    // (2) Determine actual tick length of file
    // (3) Validate all events in all tracks
    // 
    psmf->tkPosition = 0;
    psmf->tkDiscardedEvents = 0;
    psmf->fdwSMF &= ~(SMF_F_EOF|SMF_F_MSMIDI);
    
    for (ptrk = psmf->rTracks, idxTrack = psmf->dwTracks; idxTrack--; ptrk++)
    {
        ptrk->psmf              = psmf;
        ptrk->tkPosition        = 0;
        ptrk->cbLeft            = ptrk->smti.cbLength;
        ptrk->hpbImage          = psmf->hpbImage + ptrk->idxTrack;
        ptrk->bRunningStatus    = 0;
        ptrk->fdwTrack          = 0;
    }

//    for (idxTrack=0,ptrk=psmf->rTracks; idxTrack < psmf->dwTracks; idxTrack++,ptrk++)
//    {
//        DPF(1, "Track %lu ptrk %04X ptrk->hpbImage %08lX", (DWORD)idxTrack, (WORD)ptrk, (DWORD)ptrk->hpbImage);
//    }

    psmf->awPatchCache[0] = 0xFDFF; // assume default patch on all but channel 10
    wFirstNote = wChanInUse = 0;
    while (SMF_SUCCESS == (smfrc = smfGetNextEvent(psmf, (EVENT BSTACK *)&event, MAX_TICKS)))
    {
        // track whether a channel is used, and whether we have seen
        // the first note-on event yet
        //
        if (0xF0 != (EVENT_TYPE(event)))
        {
            WORD wChan = (1 << (EVENT_TYPE(event) & 0x0F));
            wChanInUse |= wChan;
            if ((EVENT_TYPE(event) & 0xF0) == 0x80) // if note on
                wFirstNote |= wChan;
        }
            
        if (MIDI_META == EVENT_TYPE(event))
        {
            switch(EVENT_META_TYPE(event))
            {
                case MIDI_META_TEMPO:
                    if (SMF_SUCCESS != (smfrc = smfAddTempoMapEntry(psmf, (EVENT BSTACK *)&event)))
                    {
                        return smfrc;
                    }
                    break;

                case MIDI_META_SEQSPECIFIC:
                    if (3 == event.cbParm &&
                        event.hpbParm[0] == 0x00 &&
                        event.hpbParm[1] == 0x00 &&
                        event.hpbParm[2] == 0x41)
                    {
                        DPF(1, "This file is MSMIDI");
                        psmf->fdwSMF |= SMF_F_MSMIDI;
                    }
                    break;

                case MIDI_META_TRACKNAME:
                    if (psmf->pbTrackName)
                        LocalFree((HLOCAL)psmf->pbTrackName);

                    psmf->pbTrackName = (PBYTE)LocalAlloc(LPTR, 1+(UINT)event.cbParm);
                    if (NULL != psmf->pbTrackName)
                    {
                        hmemcpy((HPBYTE)psmf->pbTrackName, event.hpbParm, (UINT)event.cbParm);
                        psmf->pbTrackName[(UINT)event.cbParm] = '\0';
                    }
                    break;
                    
                case MIDI_META_COPYRIGHT:
                    if (psmf->pbCopyright)
                        LocalFree((HLOCAL)psmf->pbCopyright);

                    psmf->pbCopyright = (PBYTE)LocalAlloc(LPTR, 1+(UINT)event.cbParm);
                    if (NULL != psmf->pbCopyright)
                    {
                        hmemcpy((HPBYTE)psmf->pbCopyright, event.hpbParm, (UINT)event.cbParm);
                        psmf->pbCopyright[(UINT)event.cbParm] = '\0';
                    }
                    break;
            }
        }
        else if (MIDI_PROGRAMCHANGE == (EVENT_TYPE(event)&0xF0))
        {
            WORD wChan = (1 << (EVENT_TYPE(event) & 0x0F));
            //
            // if this channel has a patch change, and it is
            // before the first keydown event on the channel
            // clear the 'default' patch and set the bit
            // for the requested patch
            //
            if (!(wFirstNote & wChan))
               psmf->awPatchCache[0] &= ~wChan;
            psmf->awPatchCache[EVENT_CH_B1(event)] |= wChan;
        }
        else if (EV_DRUM_BASE == EVENT_TYPE(event) ||
                 EV_DRUM_EXT  == EVENT_TYPE(event))
        {
            psmf->awKeyCache[EVENT_CH_B1(event)]
                |= (1 << (EVENT_TYPE(event)&0x0F));
        }
    }

    psmf->wChanInUse = wChanInUse;
    
    if (SMF_END_OF_FILE == smfrc || SMF_SUCCESS == smfrc)
    {
	// !!! Will format 2 work?
        // NOTE: This is wrong for format 2, where the tracks are end-to-end
        //
        psmf->tkLength = psmf->tkPosition;
        smfrc = SMF_SUCCESS;
    }

    // Do something reasonable if we don't have a tempo entry in the file
    //
    if (SMF_SUCCESS == smfrc && 0 == psmf->cTempoMap)
    {
        if (NULL == (psmf->hTempoMap = LocalAlloc(LHND, sizeof(TEMPOMAPENTRY))))
            return SMF_NO_MEMORY;

        psmf->pTempoMap = (PTEMPOMAPENTRY)LocalLock(psmf->hTempoMap);

        psmf->cTempoMap = 1;
        psmf->cTempoMapAlloc = 1;

        psmf->pTempoMap->tkTempo = 0;
        psmf->pTempoMap->msBase = 0;
        psmf->pTempoMap->dwTempo = MIDI_DEFAULT_TEMPO;
    }
        
    return smfrc;
}

/******************************************************************************
 *
 * @doc SMF INTERNAL
 *
 * @func SMFRESULT | smfAddTempoMapEntry | Adds a tempo map entry.
 *
 * @parm PSMF | psmf | Pointer to the owning SMF structure.
 *
 * @parm PEVENT BSTACK * | pevent | Pointer to the tempo event.
 *
 * @comm
 *  Add the event to the map.
 *  
 * @rdesc Contains the result of the operation.
 *  @flag SMF_SUCCESS | The events were successfully read.
 *  @flag SMF_NO_MEMORY | Out of memory in the local heap for the map.
 * 
 * @xref <f smfBuildTrackIndex>
 *****************************************************************************/
PRIVATE SMFRESULT FNLOCAL smfAddTempoMapEntry(
    PSMF                    psmf,                                       
    EVENT BSTACK            *pevent)
{
    BOOL                    fFirst;
    HLOCAL                  hlocal;
    PTEMPOMAPENTRY          pTempo;
    DWORD                   dwTempo;
    
    if (3 != pevent->cbParm)
    {
        return SMF_INVALID_FILE;
    }

    dwTempo = (((DWORD)pevent->hpbParm[0])<<16)|
              (((DWORD)pevent->hpbParm[1])<<8)|
              ((DWORD)pevent->hpbParm[2]);

    // Some MIDI files have tempo changes strewn through them at regular
    // intervals even tho the tempo never changes -- or they have the same
    // tempo change across all tracks to the same value. In either case, most
    // of the changes are redundant -- don't waste memory storing them.
    //
    if (psmf->cTempoMap)
        if (psmf->pTempoMap[psmf->cTempoMap-1].dwTempo == dwTempo)
            return SMF_SUCCESS;

    fFirst = FALSE;
    if (psmf->cTempoMap == psmf->cTempoMapAlloc)
    {
        if (NULL != psmf->hTempoMap)
        {
            LocalUnlock(psmf->hTempoMap);
        }

        psmf->cTempoMapAlloc += C_TEMPO_MAP_CHK;
        fFirst = FALSE;
        if (0 == psmf->cTempoMap)
        {
            hlocal = LocalAlloc(LHND, (UINT)(psmf->cTempoMapAlloc*sizeof(TEMPOMAPENTRY)));
            fFirst = TRUE;
        }
        else
        {
            hlocal = LocalReAlloc(psmf->hTempoMap, (UINT)(psmf->cTempoMapAlloc*sizeof(TEMPOMAPENTRY)), LHND);
        }

        if (NULL == hlocal)
        {
            return SMF_NO_MEMORY;
        }

        psmf->pTempoMap = (PTEMPOMAPENTRY)LocalLock(psmf->hTempoMap = hlocal);
    }

    if (fFirst && psmf->tkPosition != 0)
    {
        // Inserting first event and the absolute time is zero.
        // This is not good since we have no idea what the tempo
        // should be; assume the standard 500,000 uSec/QN (120 BPM
        // at 4/4 time).
        //

        pTempo = &psmf->pTempoMap[psmf->cTempoMap++];

        pTempo->tkTempo = 0;
        pTempo->msBase  = 0;
        pTempo->dwTempo = MIDI_DEFAULT_TEMPO;

        fFirst = FALSE;
    }

    pTempo = &psmf->pTempoMap[psmf->cTempoMap++];

    pTempo->tkTempo = psmf->tkPosition;
    if (fFirst)
    {
        pTempo->msBase = 0;
    }
    else
    {
        // NOTE: Better not be here unless we're q/n format!
        //
        pTempo->msBase = (pTempo-1)->msBase +
                         muldiv32(pTempo->tkTempo-((pTempo-1)->tkTempo),
                                  (pTempo-1)->dwTempo,
                                  1000L*psmf->dwTimeDivision);
    }
    
    pTempo->dwTempo = dwTempo;

    return SMF_SUCCESS;
}

/******************************************************************************
 *
 * @doc SMF INTERNAL
 *
 * @func SMFRESULT | smfGetNextEvent | Read the next event from the given
 *  file.
 *
 * @parm PSMF | psmf | File to read the event from.
 *
 * @parm SPEVENT | pevent | Pointer to an event structure which will receive
 *  basic information about the event.
 *
 * @parm TICKS | tkMax | Tick destination. An attempt to read past this
 *  position in the file will fail.
 *
 * @comm
 *  This is the lowest level of parsing for a raw MIDI stream. The basic
 *  information about one event in the file will be returned in <p pevent>.
 *
 *  Merging data from all tracks into one stream is performed here.
 * 
 *  <p pevent!tkDelta> will contain the tick delta for the event.
 *
 *  <p pevent!abEvent> will contain a description of the event.
 *   <p pevent!abEvent[0]> will contain
 *    F0 or F7 for a System Exclusive message.
 *    FF for a MIDI file meta event.
 *    The status byte of any other MIDI message. (Running status will
 *    be tracked and expanded).
 *
 *  <p pevent!cbParm> will contain the number of bytes of paramter data
 *   which is still in the file behind the event header already read.
 *   This data may be read with <f smfGetTrackEventData>. Any unread
 *   data will be skipped on the next call to <f smfGetNextTrackEvent>.
 *
 *  Channel messages (0x8? - 0xE?) will always be returned fully in
 *   <p pevent!abEvent>.
 *
 *  Meta events will contain the meta type in <p pevent!abEvent[1]>.
 *
 *  System exclusive events will contain only an 0xF0 or 0xF7 in
 *   <p pevent!abEvent[0]>.
 *
 *  The following fields in <p ptrk> are used to maintain state and must
 *  be updated if a seek-in-track is performed:
 *
 *  <f bRunningStatus> contains the last running status message or 0 if
 *   there is no valid running status.
 *
 *  <f hpbImage> is a pointer into the file image of the first byte of
 *   the event to follow the event just read.
 *
 *  <f dwLeft> contains the number of bytes from hpbImage to the end
 *   of the track.
 *
 *
 * Get the next due event from all (in-use?) tracks
 *
 * For all tracks
 *  If not end-of-track
 *   decode event delta time without advancing through buffer
 *   event_absolute_time = track_tick_time + track_event_delta_time
 *   relative_time = event_absolute_time - last_stream_time
 *   if relative_time is lowest so far
 *    save this track as the next to pull from, along with times
 *
 * If we found a track with a due event
 *  Advance track pointer past event, saving ptr to parm data if needed
 *  track_tick_time += track_event_delta_time
 *  last_stream_time = track_tick_time
 * Else
 *  Mark and return end_of_file
 *
 * @rdesc Contains the result of the operation.
 *  @flag SMF_SUCCESS | The events were successfully read.
 *  @flag SMF_END_OF_FILE | There are no more events to read in this track.
 *  @flag SMF_REACHED_TKMAX | No event was read because <p tkMax> was reached.
 *  @flag SMF_INVALID_FILE | A disk or parse error occured on the file.
 * 
 * @xref <f smfGetTrackEventData>
 *****************************************************************************/

SMFRESULT FNLOCAL smfGetNextEvent(
    PSMF                psmf,
    EVENT BSTACK *      pevent,
    TICKS               tkMax)
{
    PTRACK              ptrk;
    PTRACK              ptrkFound;
    DWORD               idxTrack;
    TICKS               tkEventDelta;
    TICKS               tkRelTime;
    TICKS               tkMinRelTime;
    BYTE                bEvent;
    DWORD               dwGotTotal;
    DWORD               dwGot;
    DWORD               cbEvent;
    WORD                wChannelMask;

    assert(psmf != NULL);
    assert(pevent != NULL);

    if (psmf->fdwSMF & SMF_F_EOF)
    {
        return SMF_END_OF_FILE;
    }

    pevent->tkDelta = 0;

    for(;;)
    {
        ptrkFound       = NULL;
        tkMinRelTime    = MAX_TICKS;

        for (ptrk = psmf->rTracks, idxTrack = psmf->dwTracks; idxTrack--; ptrk++)
        {
            if (ptrk->fdwTrack & SMF_TF_EOT)
                continue;

            //        DPF(1, "ptrk %04X ptrk->hpbImage %08lX", (WORD)ptrk, (DWORD)ptrk->hpbImage);

            if (!smfGetVDword(ptrk->hpbImage, ptrk->cbLeft, (DWORD BSTACK *)&tkEventDelta))
            {
                DPF(1, "Hit end of track w/o end marker!");
                return SMF_INVALID_FILE;
            }

            tkRelTime = ptrk->tkPosition + tkEventDelta - psmf->tkPosition;

            if (tkRelTime < tkMinRelTime)
            {
                tkMinRelTime = tkRelTime;
                ptrkFound = ptrk;
            }
        }

        if (!ptrkFound)
        {
            DPF(2, "END_OF_FILE!");

	    // !!! poor API!!! This prevents Read(100), Read(200) from
	    // working, because the Read(200) will fail just because the
	    // Read(100) succeeded and says that the EOF is reached!
            // pSmf->fdwSMF |= SMF_F_EOF;
            return SMF_END_OF_FILE;
        }

        ptrk = ptrkFound;

        if (psmf->tkPosition + tkMinRelTime > tkMax)
        {
            return SMF_REACHED_TKMAX;
        }


        ptrk->hpbImage += (dwGot = smfGetVDword(ptrk->hpbImage, ptrk->cbLeft, (DWORD BSTACK *)&tkEventDelta));
        ptrk->cbLeft   -= dwGot;

        // We MUST have at least three bytes here (cause we haven't hit
        // the end-of-track meta yet, which is three bytes long). Checking
        // against three means we don't have to check how much is left
        // in the track again for any short event, which is most cases.
        //
        if (ptrk->cbLeft < 3)
        {
            return SMF_INVALID_FILE;
        }

        ptrk->tkPosition += tkEventDelta;
        pevent->tkDelta += ptrk->tkPosition - psmf->tkPosition;

        bEvent = *ptrk->hpbImage++;

        if (MIDI_MSG > bEvent)
        {
            if (0 == ptrk->bRunningStatus)
            {
                DPF(1, "Need running status; it's zero");
                return SMF_INVALID_FILE;
            }

            dwGotTotal = 1;
            pevent->abEvent[0] = ptrk->bRunningStatus;
            pevent->abEvent[1] = bEvent;
            if (3 == rbChanMsgLen[(ptrk->bRunningStatus >> 4) & 0x0F])
            {
                pevent->abEvent[2] = *ptrk->hpbImage++;
                dwGotTotal++;
            }
        }
        else if (MIDI_SYSEX > bEvent)
        {
            ptrk->bRunningStatus = bEvent;
            
            dwGotTotal = 2;
            pevent->abEvent[0] = bEvent;
            pevent->abEvent[1] = *ptrk->hpbImage++;
            if (3 == rbChanMsgLen[(bEvent >> 4) & 0x0F])
            {
                pevent->abEvent[2] = *ptrk->hpbImage++;
                dwGotTotal++;
            }
        }
        else
        {
            // Even though the SMF spec says that meta and SysEx clear
            // running status, there are files out there that make the
            // assumption that you can span running status across these
            // events (Knowledge Adventure's Aviation Adventure). So we
            // do NOT clear running status here
            //
            if (MIDI_META == bEvent)
            {
                pevent->abEvent[0] = MIDI_META;
                if (MIDI_META_EOT == (pevent->abEvent[1] = *ptrk->hpbImage++))
                {
                    ptrk->fdwTrack |= SMF_TF_EOT;
                }

                dwGotTotal = 2;
            }
            else if (MIDI_SYSEX == bEvent || MIDI_SYSEXEND == bEvent)
            {
                pevent->abEvent[0] = bEvent;
                dwGotTotal = 1;
            }
            else
            {
                return SMF_INVALID_FILE;
            }

            if (0 == (dwGot = smfGetVDword(ptrk->hpbImage, ptrk->cbLeft - 2, (DWORD BSTACK *)&cbEvent)))
            {
                return SMF_INVALID_FILE;
            }

            ptrk->hpbImage  += dwGot;
            dwGotTotal      += dwGot;

            if (dwGotTotal + cbEvent > ptrk->cbLeft)
            {
                return SMF_INVALID_FILE;
            }

            pevent->cbParm  = cbEvent;
            pevent->hpbParm = ptrk->hpbImage;

            ptrk->hpbImage += cbEvent;
            dwGotTotal     += cbEvent;
        }

        // DON'T update total file time based including end-of-track
        // deltas -- these are sometimes way off
        //
        if (!(ptrk->fdwTrack & SMF_TF_EOT))
            psmf->tkPosition = ptrk->tkPosition;
        
        assert(ptrk->cbLeft >= dwGotTotal);

        ptrk->cbLeft -= dwGotTotal;

        if (MIDI_SYSEX > pevent->abEvent[0])
        {
            wChannelMask = 1 << (pevent->abEvent[0] & 0x0F);
            if (!(wChannelMask & psmf->wChannelMask))
            {
//                DPF(3, "Skip event mask=%04X", wChannelMask);
                continue;
            }
        }

        return SMF_SUCCESS;
    }
}

/******************************************************************************
 *
 * @doc SMF INTERNAL
 *
 * @func BOOL | smfGetVDword | Reads a variable length DWORD from
 *  the given file.
 *
 * @parm HPBYTE | hpbImage | Pointer to the first byte of the VDWORD.
 *
 * @parm DWORD | dwLeft | Bytes left in image
 *
 *
 * @parm DWORD BSTACK * | pdw | Pointer to a DWORD to store the result in.
 *  track.
 *
 * @comm
 *  A variable length DWORD stored in a MIDI file contains one or more
 *  bytes. Each byte except the last has the high bit set; only the
 *  low 7 bits are significant.
 *  
 * @rdesc # of bytes consumed on success; else 0.
 * 
 *****************************************************************************/

DWORD FNLOCAL smfGetVDword(
    HPBYTE              hpbImage,                                
    DWORD               dwLeft,                               
    DWORD BSTACK *      pdw)
{
    BYTE                b;
    DWORD               dwUsed  = 0;

    assert(hpbImage != NULL);
    assert(pdw != NULL);
    
    *pdw = 0;

    do
    {
        if (!dwLeft)
        {
            return 0;
        }

        b = *hpbImage++;
        dwLeft--;
        dwUsed++;
        
        *pdw = (*pdw << 7) | (b & 0x7F);
    } while (b&0x80);

    return dwUsed;
}
=== C:/Users/treeman/Desktop/windows nt source code\Source\Win2K3\NT\multimedia\dshow\filterus\pnp\devenum\acmp.cpp ===
// Copyright (c) 1997 - 1999  Microsoft Corporation.  All Rights Reserved.
#include "stdafx.h"
#include "acmp.h"
#include <vfw.h>
#include "util.h"

static const TCHAR g_szDriverClsid[] = TEXT("CLSID");
const TCHAR g_szAcmDriverIndex[] = TEXT("AcmId");
static const WCHAR g_wszDriverIndex[] = L"AcmId";

CAcmClassManager::CAcmClassManager() :
        CClassManagerBase(TEXT("FriendlyName")),
        m_lDev(NAME("acm dev list"), 10)
{
    m_hmod = LoadLibrary(TEXT("msacm32.dll"));
    if(m_hmod)
    {
        m_pacmFormatTagEnum = (PacmFormatTagEnum)GetProcAddress(m_hmod,
#ifdef UNICODE
                                             "acmFormatTagEnumW"
#else
                                             "acmFormatTagEnumA"
#endif
                                             );
    }
}

CAcmClassManager::~CAcmClassManager()
{
    LegacyAcm *plamCurrent;
    for(; plamCurrent = m_lDev.RemoveHead(); )
        delete plamCurrent;

    if(m_hmod != 0)
        FreeLibrary(m_hmod);
}

HRESULT CAcmClassManager::ReadLegacyDevNames()
{
    LegacyAcm *plamCurrent;
    for(; plamCurrent = m_lDev.RemoveHead(); )
        delete plamCurrent;

    
    ACMFORMATTAGDETAILS aftd;

    ZeroMemory(&aftd, sizeof(aftd));

    /* Enumerate the format tags */
    aftd.cbStruct = sizeof(aftd);

    if(m_pacmFormatTagEnum)
    {

        MMRESULT mmr = m_pacmFormatTagEnum(
            NULL,
            &aftd,
            FormatTagsCallbackSimple,
            (DWORD_PTR)this,
            0L);
    
        if(MMSYSERR_NOERROR != mmr)
        {
        }
    }
    
    m_cNotMatched = m_lDev.GetCount();
    return S_OK;
}


BOOL CALLBACK CAcmClassManager::FormatTagsCallbackSimple
(
    HACMDRIVERID            hadid,
    LPACMFORMATTAGDETAILS   paftd,
    DWORD_PTR               dwInstance,
    DWORD                   fdwSupport
)
{
    MMRESULT            mmr;
    int                 n;
    LPWAVEFORMATEX	pwfxSave;
    DWORD		cbwfxSave;
    BOOL                f;
    DWORD               dw;

    //
    //
    //
    CAcmClassManager *pThis = (CAcmClassManager *)dwInstance;

    LegacyAcm *plamCurrent = new LegacyAcm;
    if(plamCurrent)
    {
        lstrcpy(plamCurrent->szLongName, paftd->szFormatTag);
        plamCurrent->dwFormatTag = paftd->dwFormatTag;
        pThis->m_lDev.AddTail(plamCurrent);

        DbgLog((LOG_TRACE, 10, TEXT("CAcmClassManager: adding %d %s"),
                paftd->dwFormatTag, paftd->szFormatTag));

        return TRUE;
    }

    return (FALSE);
} // FormatTagsCallbackSimple()

BOOL CAcmClassManager::MatchString(const TCHAR *szDevName)
{
    
    for(POSITION pos = m_lDev.GetHeadPositionI();
        pos;
        pos = m_lDev.Next(pos))
    {
        LegacyAcm *plamCurrent = m_lDev.Get(pos);
        if(lstrcmp(plamCurrent->szLongName, szDevName) == 0)
        {
            DbgLog((LOG_TRACE, 5, TEXT("CAcmClassManager: matched %s"),
                    szDevName));
            return TRUE;
        }
    }
        
    return FALSE;
}

HRESULT CAcmClassManager::CreateRegKeys(IFilterMapper2 *pFm2)
{
    USES_CONVERSION;
    HRESULT hr = S_OK;

    ResetClassManagerKey(CLSID_AudioCompressorCategory);
    ReadLegacyDevNames();
    
    for(POSITION pos = m_lDev.GetHeadPositionI();
        pos;
        pos = m_lDev.Next(pos))
    {
        LegacyAcm *plamCurrent = m_lDev.Get(pos);
        const WCHAR *wszFriendlyName = T2CW(plamCurrent->szLongName);
        TCHAR szUniq[ACMFORMATTAGDETAILS_FORMATTAG_CHARS + 100];
        wsprintf(szUniq, TEXT("%d%s"), plamCurrent->dwFormatTag, plamCurrent->szLongName);

        // we could probably specify that the input pins accept PCM
        // only, but a wildcard should be fine.
        static const AMOVIESETUP_MEDIATYPE sudInPinTypes =
        {
            &MEDIATYPE_Audio,   // clsMajorType
            &MEDIASUBTYPE_NULL  // clsMinorType
        }; 

        const FOURCCMap fccSubtype(plamCurrent->dwFormatTag);
        const AMOVIESETUP_MEDIATYPE sudOutPinTypes =
        {
            &MEDIATYPE_Audio,   // clsMajorType
            &fccSubtype         // clsMinorType
        }; 

        const AMOVIESETUP_PIN sudpPins [] =
        {
            { L"Input"             // strName
              , FALSE              // bRendered
              , FALSE              // bOutput
              , FALSE              // bZero
              , FALSE              // bMany
              , &CLSID_NULL        // clsConnectsToFilter
              , NULL               // strConnectsToPin
              , 1                  // nTypes
              , &sudInPinTypes     // lpTypes
            },
            { L"Output"            // strName
              , FALSE              // bRendered
              , TRUE               // bOutput
              , FALSE              // bZero
              , FALSE              // bMany
              , &CLSID_NULL        // clsConnectsToFilter
              , NULL               // strConnectsToPin
              , 1                  // nTypes
              , &sudOutPinTypes    // lpTypes
            }
        };

        REGFILTER2 rf2;
        rf2.dwVersion = 1;
        rf2.dwMerit = MERIT_DO_NOT_USE;
        rf2.cPins = NUMELMS(sudpPins);
        rf2.rgPins = sudpPins;
            
        IMoniker *pMoniker = 0;
        hr = RegisterClassManagerFilter(
            pFm2,
            CLSID_ACMWrapper,
            wszFriendlyName,
            &pMoniker,
            &CLSID_AudioCompressorCategory,
            T2CW(szUniq),
            &rf2);
        
        if(SUCCEEDED(hr))
        {
            IPropertyBag *pPropBag;
            hr = pMoniker->BindToStorage(
                0, 0, IID_IPropertyBag, (void **)&pPropBag);
            if(SUCCEEDED(hr))
            {
                VARIANT var;
                var.vt = VT_I4;
                var.lVal = plamCurrent->dwFormatTag;
                hr = pPropBag->Write(g_wszDriverIndex, &var);

                pPropBag->Release();
            }
            pMoniker->Release();
        }              
    }

            

    return S_OK;
}
=== C:/Users/treeman/Desktop/windows nt source code\Source\Win2K3\NT\multimedia\dshow\filterus\pnp\devenum\acmp.h ===
// Copyright (c) 1997 - 1998  Microsoft Corporation.  All Rights Reserved.
#include "resource.h"
#include "cmgrbase.h"

#include <mmreg.h>
#include <msacm.h>

class CAcmClassManager :
    public CClassManagerBase,
    public CComObjectRoot,
    public CComCoClass<CAcmClassManager,&CLSID_CAcmCoClassManager>
{
    struct LegacyAcm
    {
        TCHAR szLongName[ACMFORMATTAGDETAILS_FORMATTAG_CHARS];
        DWORD dwFormatTag;
    };

    CGenericList<LegacyAcm> m_lDev;

//     static BOOL CALLBACK AcmDriverEnumCallback(
//         HACMDRIVERID hadid,
//         DWORD dwInstance,
//         DWORD fdwSupport);

    static BOOL CALLBACK FormatTagsCallbackSimple(
        HACMDRIVERID            hadid,
        LPACMFORMATTAGDETAILS   paftd,
        DWORD_PTR               dwInstance,
        DWORD                   fdwSupport);

    // dynlink stuff. dynlink.h doesn't help us much. and enumerating
    // this category loads every single driver anyway.

    HMODULE m_hmod;

    typedef MMRESULT (/* ACMAPI */ *PacmFormatTagEnumA) (
        HACMDRIVER              had,
        LPACMFORMATTAGDETAILSA  paftd,
        ACMFORMATTAGENUMCBA     fnCallback,
        DWORD_PTR               dwInstance, 
        DWORD                   fdwEnum
    );

    typedef MMRESULT (/* ACMAPI */ *PacmFormatTagEnumW)(
        HACMDRIVER              had,
        LPACMFORMATTAGDETAILSW  paftd,
        ACMFORMATTAGENUMCBW     fnCallback,
        DWORD_PTR               dwInstance, 
        DWORD                   fdwEnum
        );

#ifdef UNICODE
    typedef PacmFormatTagEnumW PacmFormatTagEnum;
#else
    typedef PacmFormatTagEnumA PacmFormatTagEnum;
#endif

    PacmFormatTagEnum m_pacmFormatTagEnum;
    

public:

    CAcmClassManager();
    ~CAcmClassManager();

    BEGIN_COM_MAP(CAcmClassManager)
	COM_INTERFACE_ENTRY2(IDispatch, ICreateDevEnum)
	COM_INTERFACE_ENTRY(ICreateDevEnum)
    END_COM_MAP();

    DECLARE_NOT_AGGREGATABLE(CAcmClassManager) ;
    DECLARE_NO_REGISTRY();
    
    HRESULT ReadLegacyDevNames();
    BOOL MatchString(const TCHAR *szDevName);
    HRESULT CreateRegKeys(IFilterMapper2 *pFm2);
};
=== C:/Users/treeman/Desktop/windows nt source code\Source\Win2K3\NT\multimedia\dshow\filterus\pnp\devenum\cenumpnp.cpp ===
// Copyright (c) 1997 - 1999  Microsoft Corporation.  All Rights Reserved.
#include "stdafx.h"
#include "cenumpnp.h"

// declare statics
CEnumPnp *CEnumInterfaceClass::m_pEnumPnp = 0;
struct CEnumInterfaceClass::SetupApiFns CEnumInterfaceClass::m_setupFns;

// dyn-load setupapi
CEnumInterfaceClass::CEnumInterfaceClass() :
        m_fLoaded(false)
{
    PNP_PERF(m_msrPerf = MSR_REGISTER("CEnumInterfaceClass"));
    PNP_PERF(MSR_INTEGER(m_msrPerf, 1));
    
    // NT4 has setupapi without the new apis. loading it on slow
    // machines takes 120-600 ms
    extern OSVERSIONINFO g_osvi;
    if(g_osvi.dwPlatformId == VER_PLATFORM_WIN32_NT &&
       g_osvi.dwMajorVersion <= 4)
    {
        m_hmodSetupapi = 0;
        DbgLog((LOG_TRACE, 5, TEXT("nt4 - not loading setupapi")));
    }
    else if(g_osvi.dwPlatformId == VER_PLATFORM_WIN32_WINDOWS &&
            g_osvi.dwMajorVersion == 4 &&
            g_osvi.dwMinorVersion < 10)
    {
        m_hmodSetupapi = 0;
        DbgLog((LOG_TRACE, 5, TEXT("win95 non memphis - not loading setupapi")));
    }
    else
    {
        m_hmodSetupapi = LoadLibrary(TEXT("setupapi.dll"));
    }
    //PNP_PERF(static int msrSetupapi = MSR_REGISTER("mkenum: setupapi"));
    //PNP_PERF(MSR_NOTE(msrSetupapi));

    if(m_hmodSetupapi != 0)
    {
        m_fLoaded = LoadSetupApiProcAdds();
    }
    else
    {
        DbgLog((LOG_TRACE, 5, TEXT("devenum: didn't load setupapi")));
    }
    PNP_PERF(MSR_INTEGER(m_msrPerf, 2));
}

// load proc addresses for SetupApi
bool CEnumInterfaceClass::LoadSetupApiProcAdds( )
{
    bool fLoaded = FALSE;
    
#ifdef UNICODE
    static const char szSetupDiGetClassDevs[] = "SetupDiGetClassDevsW";
    static const char szSetupDiGetDeviceInterfaceDetail[] = "SetupDiGetDeviceInterfaceDetailW";
    static const char szSetupDiCreateDeviceInterfaceRegKey[] = "SetupDiCreateDeviceInterfaceRegKeyW";
    static const char szSetupDiOpenDeviceInterface[] = "SetupDiOpenDeviceInterfaceW";
#else
    static const char szSetupDiGetClassDevs[] = "SetupDiGetClassDevsA";
    static const char szSetupDiGetDeviceInterfaceDetail[] = "SetupDiGetDeviceInterfaceDetailA";
    static const char szSetupDiCreateDeviceInterfaceRegKey[] = "SetupDiCreateDeviceInterfaceRegKeyA";
    static const char szSetupDiOpenDeviceInterface[] = "SetupDiOpenDeviceInterfaceA";
#endif

    ASSERT(m_hmodSetupapi != 0);

    if((m_setupFns.pSetupDiGetClassDevs =
        (PSetupDiGetClassDevs)GetProcAddress(
            m_hmodSetupapi, szSetupDiGetClassDevs)) &&

       (m_setupFns.pSetupDiDestroyDeviceInfoList =
        (PSetupDiDestroyDeviceInfoList)GetProcAddress(
            m_hmodSetupapi, "SetupDiDestroyDeviceInfoList")) &&

       (m_setupFns.pSetupDiEnumDeviceInterfaces =
        (PSetupDiEnumDeviceInterfaces)GetProcAddress(
            m_hmodSetupapi, "SetupDiEnumDeviceInterfaces")) &&

       (m_setupFns.pSetupDiOpenDeviceInterfaceRegKey =
        (PSetupDiOpenDeviceInterfaceRegKey)GetProcAddress(
            m_hmodSetupapi, "SetupDiOpenDeviceInterfaceRegKey")) &&

       (m_setupFns.pSetupDiCreateDeviceInterfaceRegKey =
        (PSetupDiCreateDeviceInterfaceRegKey)GetProcAddress(
            m_hmodSetupapi, szSetupDiCreateDeviceInterfaceRegKey)) &&

//        (m_setupFns.pSetupDiOpenDevRegKey =
//         (PSetupDiOpenDevRegKey)GetProcAddress(
//             m_hmodSetupapi, "SetupDiOpenDevRegKey")) &&
       
       (m_setupFns.pSetupDiGetDeviceInterfaceDetail =
        (PSetupDiGetDeviceInterfaceDetail)GetProcAddress(
            m_hmodSetupapi, szSetupDiGetDeviceInterfaceDetail)) &&
       
       (m_setupFns.pSetupDiCreateDeviceInfoList =
        (PSetupDiCreateDeviceInfoList)GetProcAddress(
            m_hmodSetupapi, "SetupDiCreateDeviceInfoList")) &&

       (m_setupFns.pSetupDiOpenDeviceInterface =
        (PSetupDiOpenDeviceInterface)GetProcAddress(
            m_hmodSetupapi, szSetupDiOpenDeviceInterface)) &&

       (m_setupFns.pSetupDiGetDeviceInterfaceAlias =
        (PSetupDiGetDeviceInterfaceAlias)GetProcAddress(
            m_hmodSetupapi, "SetupDiGetDeviceInterfaceAlias"))
       )
    {
        fLoaded = true;
    }
    else
    {
        DbgLog((LOG_ERROR, 0,
                TEXT("devenum: couldn't get setupapi entry points.")));
    }
    return fLoaded;
}


// use the persistent DEVICEPATH to create DeviceList with just the
// one device so we can call the OpenRegKey API. We can't always the
// DeviceInterfaceData saved off from the enumeration, but that might
// be an optimization if this is too slow.

HRESULT CEnumInterfaceClass::OpenDevRegKey(
    HKEY *phk, WCHAR *wszDevicePath,
    BOOL fReadOnly)
{
    *phk = 0;
    HRESULT hr = S_OK;
    if(!m_fLoaded)
    {
        DbgBreak("CEnumInterfaceClass: caller lost earlier error");
        return E_UNEXPECTED;
    }

    HDEVINFO hDevInfoTmp = m_setupFns.pSetupDiCreateDeviceInfoList(0, 0);
    if(hDevInfoTmp != INVALID_HANDLE_VALUE)
    {
        USES_CONVERSION;
        SP_DEVICE_INTERFACE_DATA DeviceInterfaceData;
        DeviceInterfaceData.cbSize = sizeof(SP_DEVICE_INTERFACE_DATA);
        SP_DEVINFO_DATA DevInfoData;
        BOOL f = m_setupFns.pSetupDiOpenDeviceInterface(
            hDevInfoTmp,
            W2T(wszDevicePath),
            0,
            &DeviceInterfaceData);
        if(f)
        {
            HKEY hkDev;
            if(fReadOnly)
            {
                hkDev = m_setupFns.pSetupDiOpenDeviceInterfaceRegKey(
                    hDevInfoTmp, 
                    &DeviceInterfaceData,
                    0,              // RESERVED
                    KEY_READ
                    );
            }
            else
            {
                hkDev = m_setupFns.pSetupDiCreateDeviceInterfaceRegKey(
                    hDevInfoTmp, 
                    &DeviceInterfaceData, 
                    0,                  // Reserved
                    KEY_READ | KEY_SET_VALUE,
                    0,                  // InfHandler
                    0                   // InfSectionName
                    );
                    
            }
            if(hkDev != INVALID_HANDLE_VALUE)
            {
                // Note that SetupDi returns INVALID_HANDLE_VALUE
                // rather than null for a bogus reg key.
                *phk = hkDev;
                hr = S_OK;
            }
            else
            {
                // we can expect this to fail.
                DWORD dwLastError = GetLastError();
                DbgLog((LOG_ERROR, 1, TEXT("SetupDi{Create,Open}DeviceInterfaceRegKey failed: %d"),
                        dwLastError));
                hr = HRESULT_FROM_WIN32(dwLastError);
            }
        }
        else
        {
            DWORD dwLastError = GetLastError();
            DbgLog((LOG_ERROR, 0, TEXT("SetupDiOpenDeviceInterface failed: %d"),
                    dwLastError));
            hr = HRESULT_FROM_WIN32(dwLastError);
        }
            
        
        m_setupFns.pSetupDiDestroyDeviceInfoList(hDevInfoTmp);
    }
    else
    {
        DWORD dwLastError = GetLastError();
        DbgLog((LOG_ERROR, 0, TEXT("SetupDiCreateDeviceInfoList failed: %d"),
                dwLastError));
        hr = HRESULT_FROM_WIN32(dwLastError);
    }

    return hr;
}

bool CEnumInterfaceClass::IsActive(WCHAR *wszDevicePath)
{
    bool fRet = false;
    
    HDEVINFO hDevInfoTmp = m_setupFns.pSetupDiCreateDeviceInfoList(0, 0);
    if(hDevInfoTmp != INVALID_HANDLE_VALUE)
    {
        USES_CONVERSION;
        SP_DEVICE_INTERFACE_DATA DeviceInterfaceData;
        DeviceInterfaceData.cbSize = sizeof(SP_DEVICE_INTERFACE_DATA);
        SP_DEVINFO_DATA DevInfoData;
        BOOL f = m_setupFns.pSetupDiOpenDeviceInterface(
            hDevInfoTmp,
            W2T(wszDevicePath),
            0,
            &DeviceInterfaceData);
        if(f)
        {
            if(DeviceInterfaceData.Flags & SPINT_ACTIVE)
            {
                fRet = true;
            }
        }
        m_setupFns.pSetupDiDestroyDeviceInfoList(hDevInfoTmp);
    
    }

    return fRet;
}

//
// enumerator using cursor. returns the device path for the next
// device with aliases in all categories in rgpclsidKsCat
// 

HRESULT
CEnumInterfaceClass::GetDevicePath(
    WCHAR **pwszDevicePath,
    const CLSID **rgpclsidKsCat,
    CEnumInternalState *pCursor)
{
    HRESULT hr = S_OK;
    if(!m_fLoaded)
    {
        // ??? wrong error?
        return HRESULT_FROM_WIN32(ERROR_NO_MORE_ITEMS);;
    }


    SP_DEVICE_INTERFACE_DATA DeviceInterfaceData;
    DeviceInterfaceData.cbSize = sizeof(SP_DEVICE_INTERFACE_DATA);
    SP_DEVICE_INTERFACE_DATA DeviceInterfaceDataAlias;
    DeviceInterfaceDataAlias.cbSize = sizeof(SP_DEVICE_INTERFACE_DATA);

    // use this one unless we find an InterfaceLink alias
    SP_DEVICE_INTERFACE_DATA *pdidSelected = &DeviceInterfaceData;

    GUID guidTmp0 = *rgpclsidKsCat[0];
            
    if(pCursor->hdev == INVALID_HANDLE_VALUE)
    {
        // workaround around for rogue dlls that might unload setupapi out from under us
        // (codec download in IE process, for example)
        HMODULE hMod = GetModuleHandle( TEXT("setupapi.dll"));
        if( NULL == hMod )
        {
            DbgLog(( LOG_TRACE, 1,
                TEXT("ERROR CEnumInterfaceClass::GetDevicePath - setupapi was unloaded!! Attempting reload... ")));
             
            m_hmodSetupapi = LoadLibrary(TEXT("setupapi.dll"));
            if( !m_hmodSetupapi )
            {        
                DbgLog(( LOG_TRACE, 1,
                    TEXT("ERROR CEnumInterfaceClass::GetDevicePath - LoadLibrary on setupapi FAILED!!. ")));
                                    
                return AmGetLastErrorToHResult();
            }
            else
            {
                // always the possibility that addresses have changed
                m_fLoaded = LoadSetupApiProcAdds();
                if( !m_fLoaded )
                {            
                    DbgLog(( LOG_TRACE, 1,
                        TEXT("ERROR CEnumInterfaceClass::GetDevicePath - failed to reload setupapi proc addresses. Aborting... ")));
                    return E_FAIL;
                }                
            }            
        }            
        pCursor->hdev = m_setupFns.pSetupDiGetClassDevs(
            &guidTmp0,              // guid
            0,                      // enumerator
            0,                      // hwnd
            DIGCF_DEVICEINTERFACE | DIGCF_PRESENT);
        if(pCursor->hdev == INVALID_HANDLE_VALUE)
        {
            DbgLog((LOG_ERROR, 0, TEXT("SetupDiGetClassDevs failed.")));
            return AmGetLastErrorToHResult();
        }
    }

    HDEVINFO &hdev = pCursor->hdev;

    // get next device in first category that is also in all the other
    // required categories.
    
    while(m_setupFns.pSetupDiEnumDeviceInterfaces(
        hdev, NULL, &guidTmp0, pCursor->iDev++, &DeviceInterfaceData))
    {
        UINT iCatInstersect = 1;
        while(rgpclsidKsCat[iCatInstersect])
        {
            GUID guidTmp1 = *rgpclsidKsCat[iCatInstersect];
            if(!m_setupFns.pSetupDiGetDeviceInterfaceAlias(
                hdev,
                &DeviceInterfaceData,
                &guidTmp1,
                &DeviceInterfaceDataAlias))
            {
                DbgLog((LOG_TRACE, 5, TEXT("devenum: didn't match %d in %08x"),
                        pCursor->iDev - 1,
                        rgpclsidKsCat[iCatInstersect]->Data1));

                break;
            }

            iCatInstersect++;
        }

        if(rgpclsidKsCat[iCatInstersect]) {
            // must not have matched a category
            continue;
        }
        else
        {
            DbgLog((LOG_TRACE, 15, TEXT("devenum: %d matched %d categories"),
                    pCursor->iDev - 1, iCatInstersect));
        }

        // Read the InterfaceLink value and use that alias
        HKEY hkDeviceInterface =
            m_setupFns.pSetupDiOpenDeviceInterfaceRegKey(
                hdev, 
                &DeviceInterfaceData,
                0,              // RESERVED
                KEY_READ
                );
        if(hkDeviceInterface != INVALID_HANDLE_VALUE)
        {
            CLSID clsIfLink;
            DWORD dwcb = sizeof(clsIfLink);
            DWORD dwType;
            LONG lResult = RegQueryValueEx(
                hkDeviceInterface,
                TEXT("InterfaceLink"),
                0,
                &dwType,
                (BYTE *)&clsIfLink,
                &dwcb);

            EXECUTE_ASSERT(RegCloseKey(hkDeviceInterface) ==
                           ERROR_SUCCESS);
            
            if(lResult == ERROR_SUCCESS)
            {
                ASSERT(dwType == REG_BINARY && dwcb == sizeof(clsIfLink));
            
                ASSERT(DeviceInterfaceDataAlias.cbSize ==
                       sizeof(SP_DEVICE_INTERFACE_DATA));
                
                if(m_setupFns.pSetupDiGetDeviceInterfaceAlias(
                    hdev,
                    &DeviceInterfaceData,
                    &clsIfLink,
                    &DeviceInterfaceDataAlias))
                {
                    // use this base interface instead
                    pdidSelected = &DeviceInterfaceDataAlias;
                }
                else
                {
                    DbgBreak("registry error: InterfaceLink invalid");
                }

            } // read InterfaceLink
           
        } // SetupDiOpenDeviceInterfaceRegKey
        

        //
        // get the device path.
        // 

        SP_DEVINFO_DATA DevInfoData;
        DevInfoData.cbSize = sizeof(DevInfoData);

        BYTE *rgbDeviceInterfaceDetailData = 0;
        PSP_DEVICE_INTERFACE_DETAIL_DATA &rpDeviceInterfaceDetailData =
            (PSP_DEVICE_INTERFACE_DETAIL_DATA &)rgbDeviceInterfaceDetailData;

        // start with 1k buffer to hopefully avoid calling this
        // expensive api twice.
        DWORD dwcbAllocated = 1024;
        for(;;)
        {
            rgbDeviceInterfaceDetailData = new BYTE[dwcbAllocated];
            if(rgbDeviceInterfaceDetailData)
            {
                rpDeviceInterfaceDetailData->cbSize = sizeof(SP_DEVICE_INTERFACE_DETAIL_DATA);

                // reported size. shouldn't reuse dwcbAllocated for out param.
                DWORD dwcbRequired; 
                
                BOOL f = m_setupFns.pSetupDiGetDeviceInterfaceDetail(
                    hdev,
                    pdidSelected,
                    rpDeviceInterfaceDetailData,
                    dwcbAllocated,
                    &dwcbRequired,
                    &DevInfoData);

                if(f)
                {
                    hr = S_OK;
                }
                else
                {
                    DWORD dwLastError = GetLastError();
                    if(dwLastError == ERROR_INSUFFICIENT_BUFFER)
                    {
                        // try again with a properly sized buffer
                        delete[] rgbDeviceInterfaceDetailData;
                        dwcbAllocated = dwcbRequired;
                        continue;
                    }
                    else
                    {
                        hr = HRESULT_FROM_WIN32(dwLastError);
                    }
                }
            }
            else
            {
                hr = E_OUTOFMEMORY;
            }

            break;
        } // for

        if(SUCCEEDED(hr))
        {
            UINT cch = lstrlen(rpDeviceInterfaceDetailData->DevicePath) + 1;
            *pwszDevicePath = new WCHAR[cch];
            if(*pwszDevicePath)
            {
                USES_CONVERSION;
                lstrcpyW(*pwszDevicePath, T2CW(rpDeviceInterfaceDetailData->DevicePath));
                hr = S_OK;
            }
            else
            {
                hr = E_OUTOFMEMORY;
            }
        }
        
        // always safe to delete it
        delete[] rgbDeviceInterfaceDetailData;
        return hr;
    }

    // exit while loop only on error from SetupDiEnumDeviceInterfaces
    DWORD dwLastError = GetLastError();

    ASSERT(dwLastError);
    hr = HRESULT_FROM_WIN32(dwLastError);
    return hr;
}

extern CRITICAL_SECTION g_devenum_cs;
CEnumPnp *CEnumInterfaceClass::CreateEnumPnp()
{
    // cs initialized in dll entry point
    EnterCriticalSection(&g_devenum_cs);
    if(m_pEnumPnp == 0)
    {
        // created only once; released when dll unloaded
        m_pEnumPnp = new CEnumPnp;
    }
    LeaveCriticalSection(&g_devenum_cs);

    return m_pEnumPnp;
}
=== C:/Users/treeman/Desktop/windows nt source code\Source\Win2K3\NT\multimedia\dshow\filterus\pnp\devenum\cenumpnp.h ===
// Copyright (c) 1997 - 1999  Microsoft Corporation.  All Rights Reserved.
#ifndef _CENUM_H
#define _CENUM_H

// class to cache setupapi.dll (dynamically loaded) and call the
// various SetupDi apis

#include <setupapi.h>

struct CEnumInternalState;

class CEnumInterfaceClass 
{
public:

    CEnumInterfaceClass();

    //HRESULT OpenDevRegKey(HKEY *phk, REFCLSID clsidCategory, UINT iDev);
    HRESULT OpenDevRegKey(HKEY *phk, WCHAR *wszDevicePath, BOOL fReadOnly);

    bool IsActive(WCHAR *wszDevicePath);
    bool LoadSetupApiProcAdds(void);

    // used to enumerate. ERROR_NO_MORE_ITEMS returned at the
    // end. caller must zero pCursor the first time.
    HRESULT GetDevicePath(
        WCHAR **pwszDevicePath,
        const CLSID **rgpclsidKsCat,
        CEnumInternalState *pCursor);
    
    // the user must be in devenum.dll since we don't increment the
    // refcount on devenum.dll
    static CEnumInterfaceClass *m_pEnumPnp;

    // return an CEnumPnp or NULL. 
    static CEnumInterfaceClass *CreateEnumPnp();
    
private:

    bool m_fLoaded;
    HMODULE m_hmodSetupapi;

    typedef HDEVINFO (/* WINSETUPAPI */ WINAPI *PSetupDiGetClassDevsW)(
        IN LPGUID ClassGuid,  OPTIONAL
        IN PCWSTR Enumerator, OPTIONAL
        IN HWND   hwndParent, OPTIONAL
        IN DWORD  Flags
        );

    typedef HDEVINFO (/* WINSETUPAPI */ WINAPI *PSetupDiGetClassDevsA)(
        IN LPGUID ClassGuid,  OPTIONAL
        IN PCSTR  Enumerator, OPTIONAL
        IN HWND   hwndParent, OPTIONAL
        IN DWORD  Flags
        );

    typedef BOOL (/* WINSETUPAPI */ WINAPI *PSetupDiDestroyDeviceInfoList)(
        IN HDEVINFO DeviceInfoSet
        );

    typedef BOOL (/* WINSETUPAPI */ WINAPI *PSetupDiEnumDeviceInterfaces)(
        IN  HDEVINFO                  DeviceInfoSet,
        IN  PSP_DEVINFO_DATA          DeviceInfoData,     OPTIONAL
        IN  LPGUID                    InterfaceClassGuid,
        IN  DWORD                     MemberIndex,
        OUT PSP_DEVICE_INTERFACE_DATA DeviceInterfaceData
        );

    typedef HKEY (/* WINSETUPAPI */ WINAPI *PSetupDiOpenDeviceInterfaceRegKey)(
        IN HDEVINFO                  DeviceInfoSet,
        IN PSP_DEVICE_INTERFACE_DATA DeviceInterfaceData,
        IN DWORD                     Reserved,
        IN REGSAM                    samDesired
        );

    typedef HKEY (/* WINSETUPAPI */ WINAPI *PSetupDiOpenDevRegKey)(
        IN HDEVINFO         DeviceInfoSet,
        IN PSP_DEVINFO_DATA DeviceInfoData,
        IN DWORD            Scope,
        IN DWORD            HwProfile,
        IN DWORD            KeyType,
        IN REGSAM           samDesired
        );

    typedef BOOL (/* WINSETUPAPI */ WINAPI *PSetupDiGetDeviceInterfaceDetailA)(
        IN  HDEVINFO                           DeviceInfoSet,
        IN  PSP_DEVICE_INTERFACE_DATA          DeviceInterfaceData,
        OUT PSP_DEVICE_INTERFACE_DETAIL_DATA_A DeviceInterfaceDetailData,
        IN  DWORD                              DeviceInterfaceDetailDataSize,
        OUT PDWORD                             RequiredSize,
        OUT PSP_DEVINFO_DATA                   DeviceInfoData
        );

    typedef BOOL (/* WINSETUPAPI */ WINAPI *PSetupDiGetDeviceInterfaceDetailW)(
        IN  HDEVINFO                           DeviceInfoSet,
        IN  PSP_DEVICE_INTERFACE_DATA          DeviceInterfaceData,
        OUT PSP_DEVICE_INTERFACE_DETAIL_DATA_W DeviceInterfaceDetailData,
        IN  DWORD                              DeviceInterfaceDetailDataSize,
        OUT PDWORD                             RequiredSize,
        OUT PSP_DEVINFO_DATA                   DeviceInfoData
        );

    typedef HKEY (/* WINSETUPAPI */ WINAPI *PSetupDiCreateDeviceInterfaceRegKeyA)(
        IN HDEVINFO                  DeviceInfoSet,
        IN PSP_DEVICE_INTERFACE_DATA DeviceInterfaceData,
        IN DWORD                     Reserved,
        IN REGSAM                    samDesired,
        IN HINF                      InfHandle,
        IN PCSTR                     InfSectionName
        );

    typedef HKEY (/* WINSETUPAPI */ WINAPI *PSetupDiCreateDeviceInterfaceRegKeyW)(
        IN HDEVINFO                  DeviceInfoSet,
        IN PSP_DEVICE_INTERFACE_DATA DeviceInterfaceData,
        IN DWORD                     Reserved,
        IN REGSAM                    samDesired,
        IN HINF                      InfHandle,           OPTIONAL
        IN PCWSTR                    InfSectionName       OPTIONAL
        );

    typedef HDEVINFO (/* WINSETUPAPI */ WINAPI *PSetupDiCreateDeviceInfoList)(
        IN LPGUID ClassGuid, OPTIONAL
        IN HWND   hwndParent OPTIONAL
        );

    typedef BOOL (/* WINSETUPAPI */ WINAPI *PSetupDiOpenDeviceInterfaceA)(
        IN  HDEVINFO                  DeviceInfoSet,
        IN  PCSTR                     DevicePath,
        IN  DWORD                     OpenFlags,
        OUT PSP_DEVICE_INTERFACE_DATA DeviceInterfaceData OPTIONAL
        );

    typedef BOOL (/* WINSETUPAPI */ WINAPI *PSetupDiOpenDeviceInterfaceW)(
        IN  HDEVINFO                  DeviceInfoSet,
        IN  PCWSTR                    DevicePath,
        IN  DWORD                     OpenFlags,
        OUT PSP_DEVICE_INTERFACE_DATA DeviceInterfaceData OPTIONAL
        );

    typedef BOOL (/* WINSETUPAPI */ WINAPI *PSetupDiGetDeviceInterfaceAlias)(
        IN  HDEVINFO                  DeviceInfoSet,
        IN  PSP_DEVICE_INTERFACE_DATA DeviceInterfaceData,
        IN  LPGUID                    AliasInterfaceClassGuid,
        OUT PSP_DEVICE_INTERFACE_DATA AliasDeviceInterfaceData
        );
        

#ifdef UNICODE
    typedef PSetupDiGetClassDevsW PSetupDiGetClassDevs;
    typedef PSetupDiGetDeviceInterfaceDetailW PSetupDiGetDeviceInterfaceDetail;
    typedef PSetupDiCreateDeviceInterfaceRegKeyW PSetupDiCreateDeviceInterfaceRegKey;
    typedef PSetupDiOpenDeviceInterfaceW PSetupDiOpenDeviceInterface;
#else
    typedef PSetupDiGetClassDevsA PSetupDiGetClassDevs;
    typedef PSetupDiGetDeviceInterfaceDetailA PSetupDiGetDeviceInterfaceDetail;
    typedef PSetupDiCreateDeviceInterfaceRegKeyA PSetupDiCreateDeviceInterfaceRegKey;
    typedef PSetupDiOpenDeviceInterfaceA PSetupDiOpenDeviceInterface;
#endif

    static struct SetupApiFns
    {
        PSetupDiGetClassDevs pSetupDiGetClassDevs;
        PSetupDiDestroyDeviceInfoList pSetupDiDestroyDeviceInfoList;
        PSetupDiEnumDeviceInterfaces pSetupDiEnumDeviceInterfaces;
        PSetupDiOpenDeviceInterfaceRegKey pSetupDiOpenDeviceInterfaceRegKey;
//         PSetupDiOpenDevRegKey pSetupDiOpenDevRegKey;
        PSetupDiGetDeviceInterfaceDetail pSetupDiGetDeviceInterfaceDetail;
        PSetupDiCreateDeviceInterfaceRegKey pSetupDiCreateDeviceInterfaceRegKey;
        PSetupDiCreateDeviceInfoList pSetupDiCreateDeviceInfoList;
        PSetupDiOpenDeviceInterface pSetupDiOpenDeviceInterface;
        PSetupDiGetDeviceInterfaceAlias pSetupDiGetDeviceInterfaceAlias;
    } m_setupFns;

    friend struct CEnumInternalState;

#ifdef PNP_PERF
    int m_msrPerf;
#endif
};

// used to remember the last device returned when caller asks for the
// next.
struct CEnumInternalState
{
    CEnumInternalState() { hdev = INVALID_HANDLE_VALUE; iDev = 0; }
    ~CEnumInternalState() { if(hdev != INVALID_HANDLE_VALUE) {
        EXECUTE_ASSERT(CEnumInterfaceClass::m_setupFns.pSetupDiDestroyDeviceInfoList(hdev));}
    }
    UINT iDev;
    HDEVINFO hdev;
};



// typedef CComObject<CEnumInterfaceClass> CEnumPnp;
typedef CEnumInterfaceClass CEnumPnp;

#endif
=== C:/Users/treeman/Desktop/windows nt source code\Source\Win2K3\NT\multimedia\dshow\filterus\pnp\devenum\cmgrbase.h ===
// Copyright (c) 1997 - 1999  Microsoft Corporation.  All Rights Reserved.
#ifndef _ClassManagerBase_H
#define _ClassManagerBase_H

#include "resource.h"

class CClassManagerBase :
    public ICreateDevEnum
// public ISupportErrorInfo
{
public:
    CClassManagerBase(const TCHAR *szUniqueName);
    ~CClassManagerBase() {}

protected:
    virtual HRESULT ReadLegacyDevNames() = 0;
    BOOL VerifyRegistryInSync(IEnumMoniker *pEnum);

    // override one of the two. the first one lets you read whatever
    // you need from the propertybag. the second one reads
    // m_szUniqueName for you.
    virtual BOOL MatchString(IPropertyBag *pPropBag);
    virtual BOOL MatchString(const TCHAR *szDevName);

    virtual HRESULT CreateRegKeys(IFilterMapper2 *pFm2) = 0;

    virtual BOOL CheckForOmittedEntries() { return FALSE; }

    LONG m_cNotMatched;
    const TCHAR *m_szUniqueName;
    bool m_fDoAllDevices;  // Set by CreateClassEnumerator

private:
    STDMETHODIMP CreateClassEnumerator(
        REFCLSID clsidDeviceClass,
        IEnumMoniker ** ppEnumMoniker,
        DWORD dwFlags);

//     // ISupportsErrorInfo
//     STDMETHOD(InterfaceSupportsErrorInfo)(REFIID riid);
};


// remove all class manager entries and create the key if it wasn't
// there.
HRESULT ResetClassManagerKey(
    REFCLSID clsidCat);

// register the filter through IFilterMapper2 and return the moniker
HRESULT RegisterClassManagerFilter(
    IFilterMapper2 *pfm2,
    REFCLSID clsidFilter,
    LPCWSTR szName,
    IMoniker **ppMonikerOut,
    const CLSID *clsidCategory,
    LPCWSTR szInstance,
    REGFILTER2 *prf2);

#endif // _ClassManagerBase_H
=== C:/Users/treeman/Desktop/windows nt source code\Source\Win2K3\NT\multimedia\dshow\filterus\pnp\devenum\cmgrbase.cpp ===
// Copyright (c) 1997 - 1999  Microsoft Corporation.  All Rights Reserved.
#include "stdafx.h"
#include "util.h"
#include "cmgrbase.h"
#include "mkenum.h"

CClassManagerBase::CClassManagerBase(const TCHAR *szUniqueName) :
        m_szUniqueName(szUniqueName),
        m_fDoAllDevices(true)
{
}

//
// Routine
//
//     Updates the registry to match installed devices if necessary
//     and create an enumerator for this category
//
// Arguments
//
//     clsidDeviceClass - category we're enumerating
//
//     ppEnumDevMoniker - enumerator returned here. null returned if
//     anything other than S_OK is returned
//
//     dwFlags - non used yet
//
// Returns
//
//     S_FALSE (and null) if the category is empty
//
STDMETHODIMP CClassManagerBase::CreateClassEnumerator(
    REFCLSID clsidDeviceClass,
    IEnumMoniker ** ppEnumDevMoniker,
    DWORD dwFlags)
{
    PNP_PERF(static int msrCmgr = MSR_REGISTER("cmgrBase: Create"));
    PNP_PERF(static int msrCmgrRead = MSR_REGISTER("cmgr: ReadLegacyDevNames"));
    PNP_PERF(static int msrCmgrVrfy = MSR_REGISTER("cmgr: VerifyRegistryInSync"));
    PNP_PERF(MSR_INTEGER(msrCmgr, clsidDeviceClass.Data1));

    DbgLog((LOG_TRACE, 2, TEXT("CreateClassEnumerator enter")));

    HRESULT hr = S_OK;

    // the m_fDoAllDevices performance hack is more noticeably broken
    // for the AM filter category, so don't do it there. what happens
    // is that an AM 1.0 filter is not found for playback because the
    // cache of AM 1.0 filters is not rebuilt. !!!
    
    //  Save the flags
    m_fDoAllDevices = (0 == (dwFlags & CDEF_MERIT_ABOVE_DO_NOT_USE) ||
                       clsidDeviceClass == CLSID_LegacyAmFilterCategory);

    // serialize registry verification and editing with global mutex 
    CCreateSwEnum * pSysCreateEnum;
    hr = CoCreateInstance(CLSID_SystemDeviceEnum, NULL,
                          CLSCTX_INPROC_SERVER, CLSID_SystemDeviceEnum,
                          (void **)&pSysCreateEnum);
    if (SUCCEEDED(hr))
    {
        extern HANDLE g_devenum_mutex;
        // because CCreateSwEnum ctor must have been called
        ASSERT(g_devenum_mutex);
        
        EXECUTE_ASSERT(WaitForSingleObject(g_devenum_mutex, INFINITE) ==
                       WAIT_OBJECT_0);

        CComPtr<IEnumMoniker> pEnumClassMgrMonikers;
        CComPtr<IEnumMoniker> pSysEnumClass;
        hr = pSysCreateEnum->CreateClassEnumerator(
            clsidDeviceClass, &pSysEnumClass,
            dwFlags | CDEF_BYPASS_CLASS_MANAGER,
            &pEnumClassMgrMonikers);
        if(SUCCEEDED(hr))
        {
            // S_FALSE means category is empty and no enumerator
            // is returned. pEnumClassMgrMonikers need not be null
            // even if there are no class-managed devices.
            ASSERT((hr == S_OK && pSysEnumClass) ||
                   (hr == S_FALSE && !pEnumClassMgrMonikers && !pSysEnumClass));

            PNP_PERF(MSR_START(msrCmgrRead));
            DbgLog((LOG_TRACE, 2, TEXT("ReadLegacyDeviceNames start")));
            hr = ReadLegacyDevNames();
            DbgLog((LOG_TRACE, 2, TEXT("ReadLegacyDeviceNames end")));
            PNP_PERF(MSR_STOP(msrCmgrRead));

            if(SUCCEEDED(hr))
            {
                PNP_PERF(MSR_START(msrCmgrVrfy));
                DbgLog((LOG_TRACE, 2, TEXT("Verify registry in sync start")));
                BOOL fVrfy = VerifyRegistryInSync(pEnumClassMgrMonikers);
                DbgLog((LOG_TRACE, 2, TEXT("Verify registry in sync end")));
                PNP_PERF(MSR_STOP(msrCmgrVrfy));
                if (fVrfy)
                {
                    // registry was in sync. just return our
                    // enumerator.
                    *ppEnumDevMoniker = pSysEnumClass;
                    if (*ppEnumDevMoniker)
                    {
                        (*ppEnumDevMoniker)->AddRef();
                        hr = S_OK;
                    }
                    else
                    {
                        hr = S_FALSE;
                    }
                }
                else
                {
                    // Recreate now that the registry is in sync
#ifdef DEBUG
                    // auto relase with check for null (may be
                    // null in S_FALSE case)
                    pEnumClassMgrMonikers = 0;
#endif
                    DbgLog((LOG_TRACE, 2, TEXT("Bypass class manager")));
                    hr = pSysCreateEnum->CreateClassEnumerator(
                        clsidDeviceClass,
                        ppEnumDevMoniker,
                        dwFlags | CDEF_BYPASS_CLASS_MANAGER,
#ifdef DEBUG
                        &pEnumClassMgrMonikers
#else
                        0   // don't check again in retail builds
#endif
                        );
#ifdef DEBUG
                    // check again in debug builds
                    if(pEnumClassMgrMonikers)
                    {
                        ASSERT(VerifyRegistryInSync(pEnumClassMgrMonikers));
                    }
#endif // DEBUG
                } // registry was out of sync

            } // ReadLegacyDevNames succeeded

        } // CreateClassEnumerator succeeded

        pSysCreateEnum->Release();

        EXECUTE_ASSERT(ReleaseMutex(g_devenum_mutex));

    } // CoCreate succeeded

    PNP_PERF(MSR_INTEGER(msrCmgr, 7));


    DbgLog((LOG_TRACE, 2, TEXT("CreateClassEnumerator leave")));
    return hr;
}

//
// Routine
//
//     checks that the registry matches what the derived class thinks
//     is installed. updates the registry if not in sync. and returns
//     FALSE.
//
// Arguments
//
//     pEnum - enumerator containing the class-managed devices to
//     check.
//
BOOL CClassManagerBase::VerifyRegistryInSync(IEnumMoniker *pEnum)
{
    IMoniker *pDevMoniker;
    ULONG cFetched;
    if(pEnum)
    {
        while (m_cNotMatched > -1 &&
               pEnum->Next(1, &pDevMoniker, &cFetched) == S_OK)
        {
            // if we don't need to enumerate all devices and we've already
            // written something to this key then we assume that either this
            // category has already been fully enumerated (in which case we 
            // don't want to delete the reg cache) or the higher merit filters
            // have already been enumerated (so we don't need to do it again).
            if( !m_fDoAllDevices )
            {
                pDevMoniker->Release();
                return TRUE;
            }                
                            
            IPropertyBag *pPropBag;
            HRESULT hr = pDevMoniker->BindToStorage(
                0, 0, IID_IPropertyBag, (void **)&pPropBag);
            if(SUCCEEDED(hr))
            {
                if(MatchString(pPropBag))
                {
                    m_cNotMatched--;
                }
                else
                {
                    hr = S_FALSE;
                }

                pPropBag->Release();
            }
            pDevMoniker->Release();

            if(hr != S_OK)
            {
                m_cNotMatched = -1;
                break;
            }
        }
        if (m_cNotMatched == 0)
        {
            return TRUE;
        }
    }
    else if(m_cNotMatched == 0)
    {
        return TRUE;
    }

    IFilterMapper2 *pFm2;
    HRESULT hr = CoCreateInstance(
        CLSID_FilterMapper2, NULL, CLSCTX_INPROC_SERVER,
        IID_IFilterMapper2, (void **)&pFm2);
    if(SUCCEEDED(hr))
    {
        CreateRegKeys(pFm2);
        pFm2->Release();
    }

    return FALSE;
}

//
// Routine
//
//     Deletes everything in the class manager key (in HKCU) or
//     creates the key if it's missing
//
HRESULT ResetClassManagerKey(
    REFCLSID clsidCat)
{
    HRESULT hr = S_OK;
    CRegKey rkClassMgr;

    TCHAR szcmgrPath[100];
    WCHAR wszClsidCat[CHARS_IN_GUID];
    EXECUTE_ASSERT(StringFromGUID2(clsidCat, wszClsidCat, CHARS_IN_GUID) ==
                   CHARS_IN_GUID);

    LONG lResult = rkClassMgr.Open(
        g_hkCmReg,
        g_szCmRegPath,
        KEY_WRITE);
    if(lResult == ERROR_SUCCESS)
    {
        USES_CONVERSION;
        TCHAR *szClsidCat = W2T(wszClsidCat);
        rkClassMgr.RecurseDeleteKey(szClsidCat);

        lResult = rkClassMgr.Create(
            rkClassMgr,
            szClsidCat);
    }

    return HRESULT_FROM_WIN32(lResult);
}

//
// Routine
//
//     Determine if one entry in the registry is matched in the
//     derived class. read m_szUniqueName and give it to the derived
//     class.
//
BOOL CClassManagerBase::MatchString(
    IPropertyBag *pPropBag)
{
    BOOL fReturn = FALSE;

    VARIANT var;
    var.vt = VT_EMPTY;
    USES_CONVERSION;
    HRESULT hr = pPropBag->Read(T2COLE(m_szUniqueName), &var, 0);
    if(SUCCEEDED(hr))
    {
        fReturn = MatchString(OLE2CT(var.bstrVal));

        if(!fReturn) {
            DbgLog((LOG_TRACE, 5, TEXT("devenum: failed to match %S"), var.bstrVal));
        }

        SysFreeString(var.bstrVal);
    }
    else
    {
        DbgLog((LOG_ERROR, 1, TEXT("devenum: couldn't read %s"), m_szUniqueName));
    }

    return fReturn;
}

BOOL CClassManagerBase::MatchString(
    const TCHAR *szDevName)
{
    DbgBreak("MatchString should be overridden");
    return FALSE;
}

// register the filter through IFilterMapper2 and return the
// moniker. requires building a moniker by hand since the
// RegisterFilter method puts it somewhere the ClassManager cannot
// write.
HRESULT RegisterClassManagerFilter(
    IFilterMapper2 *pfm2,
    REFCLSID clsidFilter,
    LPCWSTR szName,
    IMoniker **ppMonikerOut,
    const CLSID *pclsidCategory,
    LPCWSTR szInstance,
    REGFILTER2 *prf2)
{
    USES_CONVERSION;
    TCHAR szDisplayName[MAX_PATH]; // we limit cm display names to 100 chars
    WCHAR wszCategory[CHARS_IN_GUID], wszFilterClsid[CHARS_IN_GUID];

    EXECUTE_ASSERT(StringFromGUID2(*pclsidCategory, wszCategory, CHARS_IN_GUID) ==
                   CHARS_IN_GUID);
    EXECUTE_ASSERT(StringFromGUID2(clsidFilter, wszFilterClsid, CHARS_IN_GUID) ==
                   CHARS_IN_GUID);

    // truncate instance name at 100 characters.
    wsprintf(szDisplayName, TEXT("@device:cm:%s\\%.100s"),
             W2CT(wszCategory),
             W2CT((szInstance == 0 ? wszFilterClsid : szInstance)));

    IBindCtx *lpBC;
    HRESULT hr = CreateBindCtx(0, &lpBC);
    if(SUCCEEDED(hr))
    {
        IParseDisplayName *ppdn;
        hr = CoCreateInstance(
            CLSID_CDeviceMoniker,
            NULL,
            CLSCTX_INPROC_SERVER,
            IID_IParseDisplayName,
            (void **)&ppdn);
        if(SUCCEEDED(hr))
        {
            IMoniker *pMoniker = 0;
            ULONG cchEaten;
            hr = ppdn->ParseDisplayName(
                lpBC, T2OLE(szDisplayName), &cchEaten, &pMoniker);

            if(SUCCEEDED(hr))
            {
                IMoniker *pMonikerTmp = pMoniker;
                hr = pfm2->RegisterFilter(
                    clsidFilter,
                    szName,
                    &pMonikerTmp,
                    0,
                    0,
                    prf2);

                if(SUCCEEDED(hr))
                {
                    if(ppMonikerOut)
                    {
                        hr = pMoniker->QueryInterface(
                            IID_IMoniker,
                            (void **)ppMonikerOut);
                    }
                }

                pMoniker->Release();
            }

            ppdn->Release();
        }

        lpBC->Release();
    }

    return hr;
}
=== C:/Users/treeman/Desktop/windows nt source code\Source\Win2K3\NT\multimedia\dshow\filterus\pnp\devenum\devenum.cpp ===
// Copyright (c) 1997 - 1999  Microsoft Corporation.  All Rights Reserved.
// devenum.cpp : Implementation of DLL Exports.

// You will need the NT SUR Beta 2 SDK or VC 4.2 in order to build this 
// project.  This is because you will need MIDL 3.00.15 or higher and new
// headers and libs.  If you have VC 4.2 installed, then everything should
// already be configured correctly.

// Note: Proxy/Stub Information
//              To build a separate proxy/stub DLL, 
//              run nmake -f devenumps.mak in the project directory.

#include "stdafx.h"
#include "resource.h"
#include "initguid.h"
#include "mkenum.h"
#include "devmon.h"
#include "vidcap.h"
#include "qzfilter.h"
#include "icmco.h"
#include "waveinp.h"
#include "cenumpnp.h"
#include "acmp.h"
#include "waveoutp.h"
#include "midioutp.h"

CComModule _Module;
extern OSVERSIONINFO g_osvi;
OSVERSIONINFO g_osvi;

// critical section used to reference count dlls, cached objects, etc.
CRITICAL_SECTION g_devenum_cs;

// mutex used for cross process registry synchronization for HKCU
HANDLE g_devenum_mutex = 0;

BEGIN_OBJECT_MAP(ObjectMap)
  OBJECT_ENTRY(CLSID_SystemDeviceEnum, CCreateSwEnum)
  OBJECT_ENTRY(CLSID_CDeviceMoniker, CDeviceMoniker)
  OBJECT_ENTRY(CLSID_CQzFilterClassManager, CQzFilterClassManager)
#ifndef _WIN64
  OBJECT_ENTRY(CLSID_CIcmCoClassManager, CIcmCoClassManager)
  OBJECT_ENTRY(CLSID_CVidCapClassManager, CVidCapClassManager)
#endif
  OBJECT_ENTRY(CLSID_CWaveinClassManager, CWaveInClassManager)
  OBJECT_ENTRY(CLSID_CWaveOutClassManager, CWaveOutClassManager)
  OBJECT_ENTRY(CLSID_CMidiOutClassManager, CMidiOutClassManager)
  OBJECT_ENTRY(CLSID_CAcmCoClassManager, CAcmClassManager)
END_OBJECT_MAP()



/////////////////////////////////////////////////////////////////////////////
// DLL Entry Point

extern "C"
BOOL WINAPI DllMain(HINSTANCE hInstance, DWORD dwReason, LPVOID /*lpReserved*/)
{
	if (dwReason == DLL_PROCESS_ATTACH)
	{
	    _Module.Init(ObjectMap, hInstance);
	    DisableThreadLibraryCalls(hInstance);

            _ASSERTE(g_devenum_mutex == 0);

	    DbgInitialise(hInstance);
	    InitializeCriticalSection(&g_devenum_cs);

            g_osvi.dwOSVersionInfoSize = sizeof(g_osvi);
            BOOL f = GetVersionEx(&g_osvi);
            ASSERT(f);
	}
	else if (dwReason == DLL_PROCESS_DETACH)
	{
	    // We hit this ASSERT in NT setup
#ifdef DEBUG
	    if (_Module.GetLockCount() != 0) {
                DbgLog((LOG_ERROR, 0, TEXT("devenum object leak")));
            }
#endif
            if(g_devenum_mutex != 0)
            {
                BOOL f = CloseHandle(g_devenum_mutex);
                _ASSERTE(f);
            }
            delete CEnumInterfaceClass::m_pEnumPnp;
	    DeleteCriticalSection(&g_devenum_cs);
	    _Module.Term();
	    DbgTerminate();

	}
	return TRUE;    // ok
}

/////////////////////////////////////////////////////////////////////////////
// Used to determine whether the DLL can be unloaded by OLE

STDAPI DllCanUnloadNow(void)
{
	return (_Module.GetLockCount()==0) ? S_OK : S_FALSE;
}

/////////////////////////////////////////////////////////////////////////////
// Returns a class factory to create an object of the requested type

STDAPI DllGetClassObject(REFCLSID rclsid, REFIID riid, LPVOID* ppv)
{
	return _Module.GetClassObject(rclsid, riid, ppv);
}

// remove dynamically generated filter registration info from a
// previous release when the dynamically discovered filters went in
// the same key as the statically registered ones. find and remove
// only the dynamically registered ones.
// 
void SelectiveDeleteCmgrKeys(const CLSID *pclsid, const TCHAR *szcmgrid)
{
    WCHAR wszClsid[CHARS_IN_GUID];
    EXECUTE_ASSERT(StringFromGUID2(*pclsid, wszClsid, CHARS_IN_GUID) == CHARS_IN_GUID);

    TCHAR szInstancePath[100];
    wsprintf(szInstancePath, TEXT("%s\\%ls\\%s"), TEXT("CLSID"), wszClsid, TEXT("Instance"));

    // must not use KEY_ALL_ACCESS (CRegKey's default) because on NT,
    // permissions are set so that KEY_ALL_ACCESS fails unless you are
    // administrator.
    CRegKey rkInstance;
    LONG lResult = rkInstance.Open(HKEY_CLASSES_ROOT, szInstancePath, MAXIMUM_ALLOWED);

    //if(lResult == ERROR_SUCCESS) {
    for(LONG iReg = 0; lResult == ERROR_SUCCESS; iReg++)
    {
	TCHAR szSubKey[MAX_PATH];
	DWORD dwcchszSubkey = NUMELMS(szSubKey);
	    
	lResult = RegEnumKeyEx(
	    rkInstance,
	    iReg,
	    szSubKey,
	    &dwcchszSubkey,
	    0,              // reserved
	    0,              // class string
	    0,              // class string size
	    0);             // lpftLastWriteTime
	if(lResult == ERROR_SUCCESS)
	{
	    CRegKey rkDev;
	    lResult = rkDev.Open(rkInstance, szSubKey, MAXIMUM_ALLOWED);
	    if(lResult == ERROR_SUCCESS)
	    {
		if(RegQueryValueEx(
		    rkDev,
		    szcmgrid,
		    0,          // reserved
		    0,          // type
		    0,          // lpData
		    0)          // cbData
		   == ERROR_SUCCESS)
		{
		    lResult = rkDev.Close();
		    ASSERT(lResult == ERROR_SUCCESS);

		    lResult = rkInstance.RecurseDeleteKey(szSubKey);

		    // delete could fail if permissions set funny, but
		    // we'll still break out of the loop
		    ASSERT(lResult == ERROR_SUCCESS);

		    // keys are now renumbered, so enumeration must
		    // restart. probably could just subtract 1
		    iReg = -1;
		}
	    }
	}
    } // for
}

// remove dynamically generated filter registration info from a
// previous release when the dynamically discovered filters went in
// the InstanceCm key under HKCR
//
// not strictly necessary since we no longer look here.
// 
void RemoveInstanceCmKeys(const CLSID *pclsid)
{
    HRESULT hr = S_OK;
    CRegKey rkClassMgr;

    TCHAR szcmgrPath[100];
    WCHAR wszClsidCat[CHARS_IN_GUID];
    EXECUTE_ASSERT(StringFromGUID2(*pclsid, wszClsidCat, CHARS_IN_GUID) ==
                   CHARS_IN_GUID);
    wsprintf(szcmgrPath, TEXT("CLSID\\%ls"), wszClsidCat);
    
    LONG lResult = rkClassMgr.Open(
        HKEY_CLASSES_ROOT,
        szcmgrPath,
        KEY_WRITE);
    if(lResult == ERROR_SUCCESS)
    {
        rkClassMgr.RecurseDeleteKey(TEXT("InstanceCm"));
    }

    return;;
}
 

/////////////////////////////////////////////////////////////////////////////
// DllRegisterServer - Adds entries to the system registry

STDAPI DllRegisterServer(void)
{
    // registers object, no typelib
    HRESULT hr = _Module.RegisterServer(FALSE);

    // we cannot use the .rgs file to write a version number because
    // we don't want to remove it on unregister, and there is no way
    // to tell the registrar to do that.
    //
    // note that we no longer look at the version number; we're just
    // more careful about which keys we delete (which is the only
    // thing that looks at the version # for now
    //
    // if we do remove it then uninstall, we register an old version
    // of devenum that may blow away 3rd party filters
    // 
    if(SUCCEEDED(hr))
    {
	CRegKey rkSysDevEnum;
	
	LONG lResult = rkSysDevEnum.Open(
            HKEY_CLASSES_ROOT, G_SZ_DEVENUM_PATH, MAXIMUM_ALLOWED);
	if(lResult == ERROR_SUCCESS)
	{
	    lResult = rkSysDevEnum.SetValue(DEVENUM_VERSION, TEXT("Version"));
        }

	if(lResult != ERROR_SUCCESS)
	{
	    hr = HRESULT_FROM_WIN32(lResult);
	}
    }

    if(SUCCEEDED(hr))
    {
	// if it was an IE4 install (v=0) then delete all of its class
	// manager keys. Class Manager now writes to a different
	// location and we don't want the ie4 entries to be
	// duplicates. ** actually we now just always delete what look
	// like class manager keys from the old location.


	static const struct {const CLSID *pclsid; const TCHAR *sz;} rgIE4KeysToPurge[] =
	{
#ifndef _WIN64
	    { &CLSID_VideoCompressorCategory,  g_szIcmDriverIndex },
	    { &CLSID_VideoInputDeviceCategory, g_szVidcapDriverIndex }, 
#endif
	    { &CLSID_LegacyAmFilterCategory,   g_szQzfDriverIndex },
	    { &CLSID_AudioCompressorCategory,  g_szAcmDriverIndex },
	    /* two in the Audio Renderer category */
	    { &CLSID_AudioRendererCategory,    g_szWaveoutDriverIndex },
	    { &CLSID_AudioRendererCategory,    g_szDsoundDriverIndex },
	    { &CLSID_AudioInputDeviceCategory, g_szWaveinDriverIndex },
	    { &CLSID_MidiRendererCategory,     g_szMidiOutDriverIndex }
	};

	for(int i = 0; i < NUMELMS(rgIE4KeysToPurge); i++)
	{
	    SelectiveDeleteCmgrKeys(
		rgIE4KeysToPurge[i].pclsid,
		rgIE4KeysToPurge[i].sz);

            RemoveInstanceCmKeys(rgIE4KeysToPurge[i].pclsid);

            // remove the current class manager key too, but that'll
            // be handled by the versioning.
            // ResetClassManagerKey(*rgIE4KeysToPurge[i].pclsid);
	}
    }

    return hr;
}

/////////////////////////////////////////////////////////////////////////////
// DllUnregisterServer - Removes entries from the system registry

STDAPI DllUnregisterServer(void)
{
    _Module.UnregisterServer();
    return S_OK;
}
=== C:/Users/treeman/Desktop/windows nt source code\Source\Win2K3\NT\multimedia\dshow\filterus\pnp\devenum\devmon.h ===
// Copyright (c) 1997 - 1999  Microsoft Corporation.  All Rights Reserved.
#ifndef _DEVMON_H
#define _DEVMON_H

#include "resource.h"       // main symbols
#include "mkenum.h"
#include "cenumpnp.h"
#include "isactive.h"

#include <dmodshow.h>
#include <dmoreg.h>

typedef HRESULT (STDAPICALLTYPE *PDMOEnum)(
   REFGUID guidCategory,
   DWORD dwFlags,
   DWORD cInTypes,
   const DMO_PARTIAL_MEDIATYPE *pInTypes, 
   DWORD cOutTypes,
   const DMO_PARTIAL_MEDIATYPE *pOutTypes,
   IEnumDMO **ppEnum);

typedef HRESULT (STDAPICALLTYPE *PDMOGetName)(
   REFCLSID clsidDMO,
   WCHAR szName[80]
);

typedef HRESULT (STDAPICALLTYPE *PDMOGetTypes)(
   REFCLSID clsidDMO,
   unsigned long ulInputTypesRequested,
   unsigned long *pulInputTypesSupplied,
   DMO_PARTIAL_MEDIATYPE *pInputTypes,
   unsigned long ulOutputTypesRequested,
   unsigned long *pulOutputTypesSupplied,
   DMO_PARTIAL_MEDIATYPE *pOutputTypes
);

class CDeviceMoniker :
  public IMoniker,
  public IPropertyBag,
  public IParseDisplayName,
  public CIsActive,
  public CComObjectRootEx<CComMultiThreadModelNoCS>,
  public CComCoClass<CDeviceMoniker,&CLSID_CDeviceMoniker>
{
    // cached thing on which we call CoCreateInstance
    CLSID m_clsidDeviceClass;

    WCHAR *m_szPersistName;

    enum DevType {
        Software,               // registered directly
        ClassMgr,               // through class manager
        PnP,                    // through SetupApi
        Dmo,                    // through DMO enumeration
        Invalid
    };
    DevType m_type;

    // pointer to m_szPersistName that contains the useful part
    WCHAR *m_sz;

    HRESULT RegConvertToVariant(VARIANT *pvar, HKEY hk, const TCHAR *szProp);

    HRESULT GetPnpEnum();

    void ConstructKeyPath(TCHAR szPath[MAX_PATH], HKEY *phk);
    HRESULT DmoRead(LPCOLESTR pszPropName, LPVARIANT pVar);

public:
    CDeviceMoniker();

    HRESULT Init(LPCWSTR pszPersistName);
    ~CDeviceMoniker();

    BEGIN_COM_MAP(CDeviceMoniker)
        COM_INTERFACE_ENTRY(IMoniker)
        COM_INTERFACE_ENTRY(IPersist)
        COM_INTERFACE_ENTRY(IPersistStream)
        COM_INTERFACE_ENTRY(IPropertyBag)
        COM_INTERFACE_ENTRY(IParseDisplayName)
        COM_INTERFACE_ENTRY_IID(CLSID_CDeviceMoniker, CDeviceMoniker)
        COM_INTERFACE_ENTRY_IID(CLSID_CIsActive, CIsActive)
    END_COM_MAP()
    DECLARE_NOT_AGGREGATABLE(CDeviceMoniker) //!!!
//    bug in ATL 2.1 requires admin priv. on NT for this to work
//    DECLARE_REGISTRY(CCreateSwEnum, _T("device.1"), _T("device"), IDS_DEVICEMONIKER_DESC, THREADFLAGS_BOTH)
    // x86 specific entries done here.
#ifdef WIN64
    DECLARE_NO_REGISTRY();
#else
    DECLARE_REGISTRY_RESOURCEID(IDR_REGISTRY_X86)
#endif
    DECLARE_GET_CONTROLLING_UNKNOWN();

    // *** IPersist methods ***
    STDMETHOD(GetClassID)(
        CLSID * pClassID);

    // *** IPersistStream methods ***
    STDMETHOD(IsDirty) ();

    STDMETHOD(Load)(
        IStream * pStream);

    STDMETHOD(Save) (
        IStream * pStream,
        BOOL      fClearDirty);

    STDMETHOD(GetSizeMax)(
        ULARGE_INTEGER * pcbSize);

    // *** IMoniker methods ***
    STDMETHOD(BindToObject) (
        IBindCtx *pbc,
        IMoniker *pmkToLeft,
        REFIID    iidResult,
        void **   ppvResult);

    STDMETHOD(BindToStorage) (
        IBindCtx *pbc,
        IMoniker *pmkToLeft,
        REFIID    riid,
        void **   ppv);

    STDMETHOD(Reduce) (
        IBindCtx *  pbc,
        DWORD       dwReduceHowFar,
        IMoniker ** ppmkToLeft,
        IMoniker ** ppmkReduced);

    STDMETHOD(ComposeWith) (
        IMoniker * pmkRight,
        BOOL       fOnlyIfNotGeneric,
        IMoniker **ppmkComposite);

    STDMETHOD(Enum)(
        BOOL            fForward,
        IEnumMoniker ** ppenumMoniker);

    STDMETHOD(IsEqual)(
        IMoniker *pmkOther);

    STDMETHOD(Hash)(
        DWORD * pdwHash);

    STDMETHOD(IsRunning) (
        IBindCtx * pbc,
        IMoniker * pmkToLeft,
        IMoniker * pmkNewlyRunning);

    STDMETHOD(GetTimeOfLastChange) (
        IBindCtx * pbc,
        IMoniker * pmkToLeft,
        FILETIME * pFileTime);

    STDMETHOD(Inverse)(
        IMoniker ** ppmk);

    STDMETHOD(CommonPrefixWith) (
        IMoniker *  pmkOther,
        IMoniker ** ppmkPrefix);

    STDMETHOD(RelativePathTo) (
        IMoniker *  pmkOther,
        IMoniker ** ppmkRelPath);

    STDMETHOD(GetDisplayName) (
        IBindCtx * pbc,
        IMoniker * pmkToLeft,
        LPWSTR   * lplpszDisplayName);

    STDMETHOD(ParseDisplayName) (
        IBindCtx *  pbc,
        IMoniker *  pmkToLeft,
        LPWSTR      lpszDisplayName,
        ULONG    *  pchEaten,
        IMoniker ** ppmkOut);

    STDMETHOD(IsSystemMoniker)(
        DWORD * pdwType);

    // IParseDisplayName
    STDMETHOD(ParseDisplayName) (
        IBindCtx *  pbc,
        LPWSTR      lpszDisplayName,
        ULONG    *  pchEaten,
        IMoniker ** ppmkOut);


    //   // *** IROTData Methods ***
    //     STDMETHOD(GetComparisonData)(
    //         byte * pbData,
    //         ULONG  cbMax,
    //         ULONG *pcbData);

    // IPropertyBag methods
    STDMETHOD(Read)(THIS_ LPCOLESTR pszPropName, LPVARIANT pVar,
                    LPERRORLOG pErrorLog);
    STDMETHOD(Write)(THIS_ LPCOLESTR pszPropName, LPVARIANT pVar);

    bool IsActive();
};

typedef CComObject<CDeviceMoniker> DevMon;

#endif // _DEVMON_H
=== C:/Users/treeman/Desktop/windows nt source code\Source\Win2K3\NT\multimedia\dshow\filterus\pnp\devenum\devmon.cpp ===
// Copyright (c) 1997 - 1999  Microsoft Corporation.  All Rights Reserved.
#include "stdafx.h"
#include "devmon.h"
#include "util.h"
#include "cenumpnp.h"

// compiler bug prevents making these static class members
PDMOGetTypes g_pDMOGetTypes;
PDMOGetName g_pDMOGetName;

static BOOL CompareSubstr(const WCHAR *wsz1, const WCHAR *wszSubstr)
{
    while(*wszSubstr != 0)
    {
        if(*wszSubstr++ != *wsz1++)
            return FALSE;
    }

    return TRUE;
}
static BOOL CopySubstr(WCHAR *wszDest, const WCHAR *wszSrc, UINT cchDest)
{
    while(*wszSrc != 0 && cchDest > 1)
    {
        *wszDest++ = *wszSrc++;
        cchDest--;
    }

    *wszDest = 0;
    return cchDest == 1;
}

CDeviceMoniker::CDeviceMoniker() :
    m_szPersistName(0),
    m_type(Invalid),
    m_clsidDeviceClass(GUID_NULL)
{

}

//
// Routine
//
//     initialize moniker. can be called more than once.
//
// Arguments
//
//     pszPersistName - the display name:
//
//          @device:sw:{category}\{Unique-id}
//          @device:cm:{category}\{Unique-id}
//          @device:pnp:{device-path}
//

HRESULT CDeviceMoniker::Init(
    LPCWSTR pszPersistName)
{
    HRESULT hr = S_OK;

    DbgLog((LOG_TRACE, 0x50, TEXT("CDeviceMoniker::Init called with %ws"),
            pszPersistName));

    m_clsidDeviceClass = GUID_NULL;

    delete[] m_szPersistName;
    m_szPersistName = new WCHAR[(lstrlenW(pszPersistName) + 1) * sizeof(WCHAR)];
    if(m_szPersistName == 0)
    {
        return E_OUTOFMEMORY;
    }

    lstrcpyW(m_szPersistName, pszPersistName);

    WCHAR *pwch = m_szPersistName;
    UINT cColons = 0;

    for(;*pwch != 0 && cColons < 2; pwch++)
        if(*pwch == L':')
            cColons++;

    if(cColons == 2)
    {
        if(pwch - m_szPersistName > 4 &&
           CompareSubstr(pwch - 4, L":sw:"))
        {
            m_sz = pwch;
            m_type = Software;
        }
        else if(pwch - m_szPersistName > 4 &&
           CompareSubstr(pwch - 4, L":cm:"))
        {
            m_sz = pwch;
            m_type = ClassMgr;
        }
        else if(pwch - m_szPersistName > 5 &&
                CompareSubstr(pwch - 5, L":pnp:"))
        {
            m_sz = pwch;
            m_type = PnP;
        }
        else if(pwch - m_szPersistName > 5 &&
                CompareSubstr(pwch - 5, L":dmo:"))
        {
            if (lstrlenW(pwch) != 2 * (CHARS_IN_GUID - 1)) {
                hr = MK_E_SYNTAX;
            } else {
                m_sz = pwch;
                m_type = Dmo;
            }
        }
        else
        {
            hr = MK_E_SYNTAX;
        }
    }
    else
    {
        hr = MK_E_SYNTAX;
    }

    return hr;
}

CDeviceMoniker::~CDeviceMoniker()
{
    delete[] m_szPersistName;
}

STDMETHODIMP CDeviceMoniker::GetClassID(
    CLSID *pClassID)
{
    HRESULT hr;

    __try
        {
            *pClassID = CLSID_CDeviceMoniker;
            hr = S_OK;
        }
    __except(EXCEPTION_EXECUTE_HANDLER)
        {
            hr = E_INVALIDARG;
        }

    return hr;
}


STDMETHODIMP CDeviceMoniker::IsDirty()
{
    return S_FALSE;
}

STDMETHODIMP CDeviceMoniker::Load(
    IStream *pStream)
{
    HRESULT hr;

    DWORD dwcb;
    ULONG cbRead;
    hr = pStream->Read(&dwcb, sizeof(DWORD), &cbRead);
    if(SUCCEEDED(hr))
    {
        WCHAR *wszDisplayName = (WCHAR *)new BYTE[dwcb];
        if(wszDisplayName)
        {
            hr = pStream->Read(wszDisplayName, dwcb, &cbRead);

            if(SUCCEEDED(hr))
            {
                // force null terminator
                wszDisplayName[dwcb / sizeof(WCHAR) - 1] = 0;

                hr = Init(wszDisplayName);
            }

            delete[] wszDisplayName;
        }
        else
        {
            hr = E_OUTOFMEMORY;
        }

    }

    return hr;
}

// ------------------------------------------------------------------------
// format in stream is DWORD containing size (incl. null) in bytes of
// display name + display name

STDMETHODIMP CDeviceMoniker::Save(
    IStream *pStream,
    BOOL     fClearDirty)
{
    CheckPointer(m_szPersistName, E_UNEXPECTED);

    DWORD dwcb = (lstrlenW(m_szPersistName) + 1) * sizeof(WCHAR);
    HRESULT hr = pStream->Write(&dwcb, sizeof(dwcb), 0);
    if(SUCCEEDED(hr))
    {
        hr = pStream->Write(m_szPersistName, dwcb, 0);
    }

    return  hr;
}


STDMETHODIMP CDeviceMoniker::GetSizeMax(
    ULARGE_INTEGER * pcbSize)
{
    CheckPointer(pcbSize, E_POINTER);
    CheckPointer(m_szPersistName, E_UNEXPECTED);


    // size in bytes incl null + DWORD for length up front
    DWORD dwcb = (lstrlenW(m_szPersistName) + 1) * sizeof(WCHAR) + sizeof(DWORD);
    pcbSize->QuadPart = dwcb;
    return S_OK;
}

// helper to get the class manager to update the registry so that
// BindToObject() can read the device's values. this function creates
// the class manager enumerator rather than calling the class manager
// function directly.
//
// returns S_OK on success; S_FALSE or failure on failure.
// 
HRESULT PopulateRegistry(WCHAR *wszMoniker)
{
    WCHAR wszClsid[CHARS_IN_GUID];
    lstrcpynW(wszClsid, wszMoniker, CHARS_IN_GUID);
    CLSID clsidCat;
    HRESULT hr = CLSIDFromString( wszClsid, &clsidCat);
    if(SUCCEEDED(hr))
    {
        ICreateDevEnum *pcde;
        HRESULT hr = CoCreateInstance(CLSID_SystemDeviceEnum, NULL, CLSCTX_INPROC_SERVER,
                                      IID_ICreateDevEnum, (void **)&pcde);
        if(SUCCEEDED(hr))
        {
            IEnumMoniker *pEnum;
            hr = pcde->CreateClassEnumerator(clsidCat, &pEnum, CDEF_DEVMON_CMGR_DEVICE);
            if(hr == S_OK)      // S_FALSE means no items
            {
                pEnum->Release();
            }

            pcde->Release();
        }
    }

    return hr;
}

STDMETHODIMP CDeviceMoniker::BindToObject (
    IBindCtx *pbc,
    IMoniker *pmkToLeft,
    REFIID    iidResult,
    void **   ppvResult)
{
    CheckPointer(ppvResult, E_POINTER);

    HRESULT    hr = S_OK;

    *ppvResult = NULL;

    if(m_type == Dmo)
    {
        IDMOWrapperFilter *pFilter;
        hr = CoCreateInstance(
            CLSID_DMOWrapperFilter, NULL, CLSCTX_INPROC_SERVER,
            IID_IDMOWrapperFilter, (void **)&pFilter);
        if(SUCCEEDED(hr))
        {
            CLSID clsid;
            GUID guidCategory;
            WCHAR szTemp[CHARS_IN_GUID];

            //  Extract the 2 GUIDs - clsid categoryid
            szTemp[CHARS_IN_GUID - 1] = 0;
            CopyMemory(szTemp, m_sz, sizeof(szTemp) - sizeof(WCHAR));
            hr = CLSIDFromString(szTemp, &clsid);
            if (SUCCEEDED(hr)) {
                hr = CLSIDFromString(m_sz + CHARS_IN_GUID - 1, &guidCategory);
            }
            if(SUCCEEDED(hr))
            {
                hr = pFilter->Init(clsid, guidCategory);
            }
            if(SUCCEEDED(hr))
            {
                hr = pFilter->QueryInterface(iidResult, ppvResult);
            }
            pFilter->Release();
        }

        return hr;
    }

    for(int i = 0; i < 2; i++)
    {
        if(m_clsidDeviceClass == GUID_NULL)
        {
            VARIANT var;
            var.vt = VT_BSTR;
            hr = Read(L"CLSID", &var, 0);

            if(SUCCEEDED(hr))
            {
                hr = CLSIDFromString(var.bstrVal, &m_clsidDeviceClass);
                SysFreeString(var.bstrVal);
            }
        }

        if(i == 0 && hr == HRESULT_FROM_WIN32(ERROR_FILE_NOT_FOUND) &&
           PopulateRegistry(m_sz) == S_OK)
        {
            continue;
        }

        break;
    }
    

    if(SUCCEEDED(hr))
    {
        IUnknown *pUnk;

        // don't fault in server from DS in ZAW. can't always specify
        // NO_DOWNLOAD flag because is not supported on win98. ole
        // team of all groups (debim) says use the operating system
        // version info since they provide no way to discover what
        // flags are supported

#ifdef CLSCTX_NO_CODE_DOWNLOAD
# if CLSCTX_NO_CODE_DOWNLOAD != 0x400
#  error fix CLSCTX_NO_CODE_DOWNLOAD value
# endif
#else
# define CLSCTX_NO_CODE_DOWNLOAD 0x400
#endif

        extern OSVERSIONINFO g_osvi;
        DWORD dwFlags = CLSCTX_INPROC_SERVER;
        if(g_osvi.dwPlatformId == VER_PLATFORM_WIN32_NT &&
           g_osvi.dwMajorVersion >= 5)
        {
            dwFlags |= CLSCTX_NO_CODE_DOWNLOAD;
        }
        else
        {
            // because we would specify the flag if it was supported
            ASSERT(CoCreateInstance(
                m_clsidDeviceClass, NULL, dwFlags | CLSCTX_NO_CODE_DOWNLOAD,
                IID_IUnknown, (void **)&pUnk) == E_INVALIDARG);
            // failed, so nothing to release.
        }

        DbgLog((LOG_TRACE, 15, TEXT("BindToObject CoCreateInstance flags: %08x"), dwFlags));

        hr = CoCreateInstance(
            m_clsidDeviceClass, NULL, dwFlags,
            IID_IUnknown, (void **)&pUnk);
        if(SUCCEEDED(hr))
        {
            IPersistPropertyBag *pDevice;
            hr = pUnk->QueryInterface(IID_IPersistPropertyBag, (void **)&pDevice);
            if(SUCCEEDED(hr))
            {
                IPropertyBag *pPropBag;
                hr = BindToStorage(0, 0, IID_IPropertyBag, (void**)&pPropBag);
                if(SUCCEEDED(hr))
                {
                    hr = pDevice->Load(pPropBag, 0);
                    if(SUCCEEDED(hr))
                    {
                        hr = pDevice->QueryInterface(iidResult, ppvResult);
                    }
                    pPropBag->Release();
                }

                pDevice->Release();
            }
            else
            {
                hr = pUnk->QueryInterface(iidResult, ppvResult);
            }

            pUnk->Release();
        }
    }

    return hr;
}


//+---------------------------------------------------------------------------
//
//  Method:     CDeviceMoniker::BindToStorage
//
//  Synopsis:   Bind to the storage for the object named by the moniker.
//
//----------------------------------------------------------------------------
STDMETHODIMP CDeviceMoniker::BindToStorage(
    IBindCtx *pbc,
    IMoniker *pmkToLeft,
    REFIID    riid,
    void **   ppv)
{
    CheckPointer(ppv, E_POINTER);

    HRESULT hr = S_OK;

    if(riid == IID_IPropertyBag)
    {
        *ppv = (IPropertyBag *)this;
        GetControllingUnknown()->AddRef();
    }
    else
    {
      hr = E_NOINTERFACE;
    }

    return hr;
}


//+---------------------------------------------------------------------------
//
//  Method:     CDeviceMoniker::Reduce
//
//  Synopsis:   Reduce the moniker.
//
//----------------------------------------------------------------------------
STDMETHODIMP CDeviceMoniker::Reduce(
    IBindCtx *  pbc,
    DWORD       dwReduceHowFar,
    IMoniker ** ppmkToLeft,
    IMoniker ** ppmkReduced)
{
    HRESULT hr;

    __try
    {
        //Validate parameters.
        *ppmkReduced = NULL;

        GetControllingUnknown()->AddRef();
        *ppmkReduced = (IMoniker *) this;
        hr = MK_S_REDUCED_TO_SELF;
    }
    __except(EXCEPTION_EXECUTE_HANDLER)
    {
        hr = E_INVALIDARG;
    }

    return hr;
}


//+---------------------------------------------------------------------------
//
//  Method:     CDeviceMoniker::ComposeWith
//
//  Synopsis:   Compose another moniker onto the end of this moniker.
//
//----------------------------------------------------------------------------
STDMETHODIMP CDeviceMoniker::ComposeWith(
    IMoniker * pmkRight,
    BOOL       fOnlyIfNotGeneric,
    IMoniker **ppmkComposite)
{
    return E_NOTIMPL;
}



//+---------------------------------------------------------------------------
//
//  Method:     CDeviceMoniker::Enum
//
//  Synopsis:   Enumerate the components of this moniker.
//
//----------------------------------------------------------------------------
STDMETHODIMP CDeviceMoniker::Enum(
    BOOL            fForward,
    IEnumMoniker ** ppenumMoniker)
{
    HRESULT hr;

    __try
    {
        *ppenumMoniker = NULL;
        hr = S_OK;
    }
    __except(EXCEPTION_EXECUTE_HANDLER)
    {
        hr = E_INVALIDARG;
    }

    return hr;
}



//+---------------------------------------------------------------------------
//
//  Method:     CDeviceMoniker::IsEqual
//
//  Synopsis:   Compares with another moniker.
//
//----------------------------------------------------------------------------
STDMETHODIMP CDeviceMoniker::IsEqual(
    IMoniker *pmkOther)
{
    HRESULT        hr;
    CDeviceMoniker *pDeviceMoniker;

    __try
    {
        hr = pmkOther->QueryInterface(CLSID_CDeviceMoniker,
                                      (void **) &pDeviceMoniker);

        if(SUCCEEDED(hr))
        {

            if(m_szPersistName && pDeviceMoniker->m_szPersistName &&
               lstrcmpW(m_szPersistName, pDeviceMoniker->m_szPersistName) == 0)
            {
                hr = S_OK;
            }
            else
            {
                hr = S_FALSE;
            }

            pDeviceMoniker->GetControllingUnknown()->Release();
        }
        else
        {
            hr = S_FALSE;
        }
    }
    __except(EXCEPTION_EXECUTE_HANDLER)
    {
        hr = E_INVALIDARG;
    }

    return hr;
}


//+---------------------------------------------------------------------------
//
//  Method:     CDeviceMoniker::Hash
//
//  Synopsis:   Compute a hash value
//
//----------------------------------------------------------------------------
STDMETHODIMP CDeviceMoniker::Hash(
    DWORD * pdwHash)
{
    HRESULT hr;

    __try
    {
        *pdwHash = m_clsidDeviceClass.Data1;
        hr = S_OK;
    }
    __except(EXCEPTION_EXECUTE_HANDLER)
    {
        hr = E_INVALIDARG;
    }

    return hr;
}


STDMETHODIMP CDeviceMoniker::IsRunning(
    IBindCtx * pbc,
    IMoniker * pmkToLeft,
    IMoniker * pmkNewlyRunning)
{
    return E_NOTIMPL;
}


STDMETHODIMP CDeviceMoniker::GetTimeOfLastChange        (
    IBindCtx * pbc,
    IMoniker * pmkToLeft,
    FILETIME * pFileTime)
{
    return MK_E_UNAVAILABLE;
}



//+---------------------------------------------------------------------------
//
//  Method:     CDeviceMoniker::Inverse
//
//  Synopsis:  Returns the inverse of this moniker.
//
//----------------------------------------------------------------------------
STDMETHODIMP CDeviceMoniker::Inverse(
    IMoniker ** ppmk)
{
    return CreateAntiMoniker(ppmk);
}



//+---------------------------------------------------------------------------
//
//  Method:     CDeviceMoniker::CommonPrefixWith
//
//  Synopsis:  Returns the common prefix shared by this moniker and the
//             other moniker.
//
//----------------------------------------------------------------------------
STDMETHODIMP CDeviceMoniker::CommonPrefixWith(
    IMoniker *  pmkOther,
    IMoniker ** ppmkPrefix)
{
    return E_NOTIMPL;
}



//+---------------------------------------------------------------------------
//
//  Method:     CDeviceMoniker::RelativePathTo
//
//  Synopsis:  Returns the relative path between this moniker and the
//             other moniker.
//
//----------------------------------------------------------------------------
STDMETHODIMP CDeviceMoniker::RelativePathTo(
    IMoniker *  pmkOther,
    IMoniker ** ppmkRelPath)
{
    return E_NOTIMPL;
}

//+---------------------------------------------------------------------------
//
//  Method:     CDeviceMoniker::GetDisplayName
//
//  Synopsis:   Get the display name of this moniker. looks like
//  device:{device_clsid}sw:{class_manager_clsid}\Instance\Instance_name
//
//----------------------------------------------------------------------------
STDMETHODIMP CDeviceMoniker::GetDisplayName(
    IBindCtx * pbc,
    IMoniker * pmkToLeft,
    LPWSTR   * lplpszDisplayName)
{
    HRESULT hr = E_FAIL;
    LPWSTR pszDisplayName;

    __try
        {

            //Validate parameters.
            *lplpszDisplayName = NULL;


            pszDisplayName = (LPWSTR) CoTaskMemAlloc((lstrlenW(m_szPersistName) + 1) * sizeof(wchar_t));
            if(pszDisplayName != NULL)
            {
                lstrcpyW(pszDisplayName, m_szPersistName);
                *lplpszDisplayName = pszDisplayName;
                hr = S_OK;
            }
            else
            {
                hr = E_OUTOFMEMORY;
            }
        }

    __except(EXCEPTION_EXECUTE_HANDLER)
        {
            hr = E_INVALIDARG;
        }

    return hr;
}

//+---------------------------------------------------------------------------
//
//  Method:     GetDefaultMoniker
//
//  Synopsis:   Return the default device for a category.
//
//  Algorithm:  Enumerate category clsidCategory and return first moniker
//
//----------------------------------------------------------------------------

HRESULT GetDefaultMoniker(CLSID& clsidCategory, IMoniker **ppMon)
{
    ICreateDevEnum *pcde;
    HRESULT hr = CoCreateInstance(CLSID_SystemDeviceEnum, NULL, CLSCTX_INPROC_SERVER,
                                  IID_ICreateDevEnum, (void **)&pcde);
    if(SUCCEEDED(hr))
    {
        IEnumMoniker *pEnum;
        hr = pcde->CreateClassEnumerator(clsidCategory, &pEnum, 0);
        if(hr == S_OK)          // S_FALSE means no items
        {
            ULONG cFetched;
            IMoniker *pMon;
            hr = pEnum->Next(1, &pMon, &cFetched);
            if(hr == S_OK)      // S_FALSE means no items
            {
                *ppMon = pMon;  // transfer refcount
            }

            pEnum->Release();
        }

        pcde->Release();
    }
    if (hr == S_FALSE)
    {
        hr = HRESULT_FROM_WIN32(ERROR_FILE_NOT_FOUND);
    }

    return hr;
}

//+---------------------------------------------------------------------------
//
//  Method:     CDeviceMoniker::ParseDisplayName
//
//  Synopsis:   Parse the display name.
//
//  Algorithm:  Call BindToObject to get an IParseDisplayName on the class
//              object.  Call IParseDisplayName::ParseDisplayName on the
//              class object.
//
//----------------------------------------------------------------------------
STDMETHODIMP CDeviceMoniker::ParseDisplayName (
    IBindCtx *  pbc,
    IMoniker *  pmkToLeft,
    LPWSTR      lpszDisplayName,
    ULONG    *  pchEaten,
    IMoniker ** ppmkOut)
{
    CheckPointer(ppmkOut, E_POINTER);
    CheckPointer(pchEaten, E_POINTER);
    *ppmkOut = 0;
    *pchEaten = 0;

    bool fInited = false;

    HRESULT hr = S_OK;

    {
        static const WCHAR wsz[] = L"@device:";
        WCHAR *wszDispNameIn = lpszDisplayName;
        
        bool fAtPrefix = (wszDispNameIn[0] == L'@');
        if(!CompareSubstr(wszDispNameIn, fAtPrefix ? wsz : (wsz + 1)))
        {
            return MK_E_SYNTAX;
        }

        // find type and check for "default" moniker
        wszDispNameIn += (NUMELMS(wsz) - (fAtPrefix ? 1 : 2));
        if(*wszDispNameIn++ == L'*' &&
           *wszDispNameIn++ == L':')
        {
            CLSID clsCategory;
            hr = CLSIDFromString(wszDispNameIn, &clsCategory);
            if(SUCCEEDED(hr))
            {
                IMoniker *pMonDefault;
                hr = GetDefaultMoniker(clsCategory, &pMonDefault);
                if(SUCCEEDED(hr))
                {
                    WCHAR *wszDisplayName;
                    hr = pMonDefault->GetDisplayName(0, 0, &wszDisplayName);
                    if(SUCCEEDED(hr))
                    {
                        hr = Init(wszDisplayName);
                        fInited = SUCCEEDED(hr);
                        CoTaskMemFree(wszDisplayName);
                    }
                    pMonDefault->Release();
                }
            }
        } // default moniker
    }

    if(!fInited && SUCCEEDED(hr)) {
        hr =  Init(lpszDisplayName);
    }
    if(SUCCEEDED(hr))
    {
        *ppmkOut = this;
        (*ppmkOut)->AddRef();
        *pchEaten = lstrlenW(lpszDisplayName);
    }

    return hr;
}

//+---------------------------------------------------------------------------
//
//  Method:     CDeviceMoniker::IsSystemMoniker
//
//  Synopsis:   Determines if this is one of the system supplied monikers.
//
//----------------------------------------------------------------------------
STDMETHODIMP CDeviceMoniker::IsSystemMoniker(
    DWORD * pdwType)
{
    HRESULT hr;

    __try
    {
        *pdwType = MKSYS_NONE;
        hr = S_FALSE;
    }
    __except(EXCEPTION_EXECUTE_HANDLER)
    {
        hr = E_INVALIDARG;
    }

    return hr;
}

STDMETHODIMP CDeviceMoniker::ParseDisplayName (
    IBindCtx *  pbc,
    LPWSTR      lpszDisplayName,
    ULONG    *  pchEaten,
    IMoniker ** ppmkOut)
{
    return ParseDisplayName(pbc, 0, lpszDisplayName, pchEaten, ppmkOut);
}

STDMETHODIMP CDeviceMoniker::Read(
    LPCOLESTR pszPropName, LPVARIANT pVar,
    LPERRORLOG pErrorLog)
{
    CheckPointer(pszPropName, E_POINTER);
    CheckPointer(pVar, E_POINTER);

    HRESULT hr = S_OK;

    if(m_type == Software || m_type == ClassMgr)
    {

        LONG lResult = ERROR_SUCCESS;
        CRegKey rkDevKey;
        HKEY hkRoot;
        TCHAR szPath[MAX_PATH];
        ConstructKeyPath(szPath, &hkRoot);

        USES_CONVERSION;
        lResult = rkDevKey.Open(hkRoot, szPath, KEY_READ) ;
        DbgLog((LOG_TRACE, 5, TEXT("CDeviceMoniker::OpenKey opening %s %d"),
                W2CT(m_sz), lResult));

        if(lResult == ERROR_SUCCESS)
        {
            USES_CONVERSION;
            const TCHAR *szProp = OLE2CT(pszPropName);

            hr = RegConvertToVariant(pVar, rkDevKey, szProp);
        }
        else
        {
            hr = HRESULT_FROM_WIN32(lResult);
        }
    }
    else if(m_type == PnP)
    {
        hr = S_OK;

        if(lstrcmpW(pszPropName, L"DevicePath") == 0)
        {
            if(pVar->vt == VT_EMPTY || pVar->vt == VT_BSTR)
            {
                pVar->vt = VT_BSTR;
                pVar->bstrVal = SysAllocString(m_sz);

                hr = pVar->bstrVal ? S_OK : E_OUTOFMEMORY;
            }
            else
            {
                hr = E_INVALIDARG;
            }
        }
        else
        {
            // unknown things and things like FriendlyName
            // and CLSID come out of the InterfaceDevice
            // registry key

            CRegKey rkDevKey;
            CEnumPnp *pEnumPnp = CEnumInterfaceClass::CreateEnumPnp();
            if(pEnumPnp)
            {
                hr = pEnumPnp->OpenDevRegKey(&rkDevKey.m_hKey, m_sz, TRUE);
            }
            else
            {
                hr = E_OUTOFMEMORY;
            }
            if(SUCCEEDED(hr))
            {
                USES_CONVERSION;
                hr = RegConvertToVariant(
                    pVar, rkDevKey, OLE2CT(pszPropName));
            }
        }
    }
    else if(m_type == Dmo)
    {
        hr = DmoRead(pszPropName, pVar);
    }
    else
    {
        hr = MK_E_SYNTAX;
    }

    return hr;
}

HRESULT VariantArrayHelper(VARIANT *pVar, BYTE *pbSrc, ULONG cbSrc)
{
    HRESULT hr = S_OK;
    pVar->vt = VT_UI1 | VT_ARRAY;

    SAFEARRAY * psa;
    SAFEARRAYBOUND rgsabound[1];
    rgsabound[0].lLbound = 0;
    rgsabound[0].cElements = cbSrc;
    psa = SafeArrayCreate(VT_UI1, 1, rgsabound);

    if(psa)
    {
        BYTE *pbData;
        EXECUTE_ASSERT(SafeArrayAccessData(psa, (void **)&pbData) == S_OK);
        CopyMemory(pbData, pbSrc, cbSrc);
        EXECUTE_ASSERT(SafeArrayUnaccessData(psa) == S_OK);
        pVar->parray = psa;
        hr = S_OK;
    }
    else
    {
        hr = E_OUTOFMEMORY;
    }

    return hr;
}


HRESULT CDeviceMoniker::RegConvertToVariant(
    VARIANT *pVar, HKEY hk, const TCHAR *szProp)
{
    HRESULT hr = E_FAIL;

    DWORD dwType;
    DWORDLONG rgdwl[32];         // 256 bytes, 64bit aligned
    DWORD dwcb = sizeof(rgdwl);

    // pbRegValue points to allocated memory if these are not
    // equal. memory on the stack otherwise
    BYTE *pbRegValue = (BYTE *)rgdwl;

    // try reading the registry with a few bytes on the
    // stack. allocate from the heap if that's not enough
    LONG lResult = RegQueryValueEx(
        hk,
        szProp,
        0,
        &dwType,
        pbRegValue,
        &dwcb);
    if(lResult == ERROR_MORE_DATA)
    {
        pbRegValue = new BYTE[dwcb];
        if(pbRegValue == 0) {
            lResult = ERROR_NOT_ENOUGH_MEMORY;
        }
        else
        {
            lResult = RegQueryValueEx(
                hk,
                szProp,
                0,
                &dwType,
                pbRegValue,
                &dwcb);
        }
    }

    if(lResult == ERROR_SUCCESS)
    {
        if(dwType == REG_SZ &&
           (pVar->vt == VT_EMPTY || pVar->vt == VT_BSTR))
        {
            USES_CONVERSION;
            pVar->vt = VT_BSTR;
            pVar->bstrVal = SysAllocString(T2COLE((TCHAR *)pbRegValue));
            if(pVar->bstrVal)
            {
                hr = S_OK;
            }
            else
            {
                hr = E_OUTOFMEMORY;
            }
        }
        // 16 bit INFs cannot write out DWORDs. so accept binary data
        // if the caller wanted a DWORD
        else if((dwType == REG_DWORD && (pVar->vt == VT_EMPTY || pVar->vt == VT_I4)) ||
                (dwType == REG_BINARY && dwcb == sizeof(DWORD) && pVar->vt == VT_I4))
        {
            pVar->vt = VT_I4;
            pVar->lVal = *(DWORD *)pbRegValue;
            hr = S_OK;
        }
        else if(dwType == REG_QWORD && (pVar->vt == VT_EMPTY || pVar->vt == VT_I8))
        {
            pVar->vt = VT_I8;
            pVar->llVal = *(LONGLONG *)pbRegValue;
            hr = S_OK;
        }
        else if(dwType == REG_BINARY &&
                (pVar->vt == VT_EMPTY || pVar->vt == (VT_UI1 | VT_ARRAY)))
        {
            hr = VariantArrayHelper(pVar, pbRegValue, dwcb);
        }
        else
        {
            hr = E_INVALIDARG;
        }

    }
    else
    {
        hr = HRESULT_FROM_WIN32(lResult);
    }

    // pbRegValue not on the stack but allocated, so free it
    if(pbRegValue != (BYTE *)rgdwl) {
        delete[] pbRegValue;
    }

    return hr;
}

STDMETHODIMP CDeviceMoniker::Write(
    LPCOLESTR pszPropName,
    LPVARIANT pVar)
{
    CheckPointer(pszPropName, E_POINTER);
    CheckPointer(pVar, E_POINTER);
    USES_CONVERSION;

    HRESULT hr = S_OK;

    CRegKey rkDevKey;

    // open the key with Write access each time.
    if(m_type == PnP)
    {
        CEnumPnp *pEnumPnp = CEnumInterfaceClass::CreateEnumPnp();
        if(pEnumPnp)
        {
            hr = pEnumPnp->OpenDevRegKey(&rkDevKey.m_hKey, m_sz, FALSE);
        }
        else
        {
            hr = E_OUTOFMEMORY;
        }
    }
    else if(m_type == Dmo)
    {
        hr = HRESULT_FROM_WIN32(ERROR_ACCESS_DENIED);
    }
    else
    {
        HKEY hkRoot;
        TCHAR szPath[MAX_PATH];
        ConstructKeyPath(szPath, &hkRoot);

        ASSERT(m_type == Software || m_type == ClassMgr);
        USES_CONVERSION;
        LONG lResult = rkDevKey.Create(
            hkRoot,
            szPath,
            NULL,               // class
            0,                  // flags
            KEY_READ | KEY_SET_VALUE
            );
        if(lResult != ERROR_SUCCESS)
            hr = HRESULT_FROM_WIN32(lResult);

        DbgLog((LOG_TRACE, 5, TEXT("CDeviceMoniker: creating %s: %d"),
                szPath, lResult));
    }

    // write the value
    if(SUCCEEDED(hr))
    {
        const TCHAR *szPropName = OLE2CT(pszPropName);
        LONG lResult = ERROR_SUCCESS;
        switch(pVar->vt)
        {
          case VT_I4:
              lResult = rkDevKey.SetValue(pVar->lVal, szPropName);
              break;

          case VT_I8:
              lResult = RegSetValueEx(
                  rkDevKey,
                  szPropName,
                  0,            // dwReserved
                  REG_QWORD,
                  (BYTE *)&pVar->llVal,
                  sizeof(pVar->llVal));
              break;

          case VT_BSTR:
              lResult = rkDevKey.SetValue(OLE2CT(pVar->bstrVal), szPropName);
              break;

          case VT_UI1 | VT_ARRAY:
              BYTE *pbData;
              EXECUTE_ASSERT(SafeArrayAccessData(
                  pVar->parray, (void **)&pbData) == S_OK);

              lResult = RegSetValueEx(
                  rkDevKey,
                  szPropName,
                  0,            // dwReserved
                  REG_BINARY,
                  pbData,
                  pVar->parray->rgsabound[0].cElements);

              EXECUTE_ASSERT(SafeArrayUnaccessData(
                  pVar->parray) == S_OK);

              break;

          default:
              lResult = ERROR_INVALID_PARAMETER;

        }
        if(lResult != ERROR_SUCCESS)
            hr = HRESULT_FROM_WIN32(lResult);
    }

    return hr;
}

//
// returns what key to open from the DisplayName. HKCU\...\devenum or
// HKCR\...\Instance
//
// szPath is MAX_PATH characters long
//
void CDeviceMoniker::ConstructKeyPath(
    TCHAR szPath[MAX_PATH],
    HKEY *phk)
{
    ASSERT(m_type == Software || m_type == ClassMgr);
    USES_CONVERSION;

    TCHAR *szPathStart = szPath;
    const TCHAR *sz = W2CT(m_sz);

    if(m_type == Software)
    {
        static const TCHAR szClsid[] = TEXT("CLSID\\");
        lstrcpy(szPath, szClsid);
        szPath += NUMELMS(szClsid) - 1;

        lstrcpyn(szPath, sz, CHARS_IN_GUID);
        szPath += CHARS_IN_GUID - 1;

        static const TCHAR szInstace[] = TEXT("\\Instance\\");
        lstrcpy(szPath, szInstace);
        szPath += NUMELMS(szInstace) - 1;

        *phk = HKEY_CLASSES_ROOT;
    }
    else
    {
        lstrcpy(szPath, g_szCmRegPath);
        szPath += NUMELMS(g_szCmRegPath) - 1;

        *szPath++ = TEXT('\\');

        lstrcpyn(szPath, sz, CHARS_IN_GUID);
        szPath += CHARS_IN_GUID - 1;

        *szPath++ = TEXT('\\');

        *phk = g_hkCmReg;
    }

    if(lstrlen(sz) > CHARS_IN_GUID) {
        lstrcpyn(szPath, sz + CHARS_IN_GUID, MAX_PATH - (LONG)(szPath - szPathStart));
    }

}

#include "fil_data.h"
#include "fil_data_i.c"

HRESULT CDeviceMoniker::DmoRead(
    LPCOLESTR pszPropName, LPVARIANT pVar)
{
    bool  InitDmo();
    if(!InitDmo()) {
        return E_FAIL;
    }

    HRESULT hr = S_OK;

    if(lstrcmpiW(pszPropName, L"FriendlyName") == 0 &&
       (pVar->vt == VT_EMPTY || pVar->vt == VT_BSTR))
    {
        WCHAR szName[80];       // !!!
        CLSID clsid;
        WCHAR szTemp[CHARS_IN_GUID];
        szTemp[CHARS_IN_GUID - 1] = 0;
        CopyMemory(szTemp, m_sz, sizeof(szTemp) - sizeof(WCHAR));
        hr = CLSIDFromString(szTemp, &clsid);
        if(SUCCEEDED(hr))
        {
            hr = g_pDMOGetName(clsid, szName);
        }
        if(SUCCEEDED(hr))
        {
            pVar->bstrVal = SysAllocString(szName);
            pVar->vt = VT_BSTR;

            if(pVar->bstrVal == 0) {
                hr = E_OUTOFMEMORY;
            }
        }
    }
    else if(lstrcmpiW(pszPropName, L"FilterData") == 0 &&
            (pVar->vt == VT_EMPTY || pVar->vt == (VT_UI1 | VT_ARRAY)))
    {
        USES_CONVERSION;
        CLSID clsid;
        WCHAR szTemp[CHARS_IN_GUID];
        szTemp[CHARS_IN_GUID - 1] = 0;
        CopyMemory(szTemp, m_sz, sizeof(szTemp) - sizeof(WCHAR));
        hr = CLSIDFromString(szTemp, &clsid);
        ULONG ulIn, ulOut;
        DMO_PARTIAL_MEDIATYPE dmoMtIn[10], dmoMtOut[10];
        if(SUCCEEDED(hr))
        {
            hr = g_pDMOGetTypes(clsid, 10, &ulIn, dmoMtIn, 10, &ulOut, dmoMtOut);
        }

        //  Try to get the merit from the CLSID key
        DWORD dwMerit = MERIT_NORMAL + 0x800;
        CRegKey rkCLSID;
        TCHAR szClsidPath[MAX_PATH];
        lstrcpy(szClsidPath, TEXT("clsid\\"));
        lstrcat(szClsidPath, W2T(szTemp));
        LONG lRc = rkCLSID.Open(HKEY_CLASSES_ROOT, szClsidPath, KEY_READ);
        if (ERROR_SUCCESS == lRc) {
            rkCLSID.QueryValue(dwMerit, TEXT("Merit"));
        }
        if(SUCCEEDED(hr))
        {
            IAMFilterData *pfd;
            hr = CoCreateInstance(
                CLSID_FilterMapper,
                NULL,
                CLSCTX_INPROC_SERVER,
                IID_IAMFilterData,
                (void **)&pfd);

            if(SUCCEEDED(hr))
            {
                REGPINTYPES *rgrptIn = (REGPINTYPES *)_alloca(ulIn * sizeof(REGPINTYPES));
                for(UINT i = 0; i < ulIn; i++)
                {
                    rgrptIn[i].clsMajorType = &dmoMtIn[i].type;
                    rgrptIn[i].clsMinorType = &dmoMtIn[i].subtype;
                }

                REGPINTYPES *rgrptOut = (REGPINTYPES *)_alloca(ulOut * sizeof(REGPINTYPES));
                for(i = 0; i < ulOut; i++)
                {
                    rgrptOut[i].clsMajorType = &dmoMtOut[i].type;
                    rgrptOut[i].clsMinorType = &dmoMtOut[i].subtype;
                }

                REGFILTERPINS2 rfpIn, rfpOut;
                ZeroMemory(&rfpIn, sizeof(rfpIn));
                ZeroMemory(&rfpOut, sizeof(rfpOut));

                rfpIn.dwFlags = 0;
                rfpIn.nMediaTypes = ulIn;
                rfpIn.lpMediaType = rgrptIn;

                rfpOut.dwFlags = REG_PINFLAG_B_OUTPUT;
                rfpOut.nMediaTypes = ulOut;
                rfpOut.lpMediaType = rgrptOut;

                REGFILTERPINS2 rgrfp2[2];
                rgrfp2[0] = rfpIn;
                rgrfp2[1] = rfpOut;

                REGFILTER2 rf2;
                rf2.dwVersion = 2;
                rf2.dwMerit = dwMerit;

                // no correspondence between pins and types, so just
                // make two pins to represent input & output types.
                rf2.cPins = 2;
                rf2.rgPins2 = rgrfp2;

                ULONG cbData;
                BYTE *pbData = 0;
                hr = pfd->CreateFilterData(&rf2, &pbData, &cbData);

                if(SUCCEEDED(hr))
                {
                    hr = VariantArrayHelper(pVar, pbData, cbData);
                }

                pfd->Release();
                if(pbData) {
                    CoTaskMemFree(pbData);
                }
            }
        }
    }
    else
    {
        hr = HRESULT_FROM_WIN32(ERROR_NOT_FOUND);
    }

    return hr;
}

bool CDeviceMoniker::IsActive()
{
    bool fRet = false;
    if(m_type == PnP)
    {
        CEnumPnp *pEnumPnp = CEnumInterfaceClass::CreateEnumPnp();
        if(pEnumPnp)
        {
            fRet = pEnumPnp->IsActive(m_sz);
        }
    }

    return fRet;
}
=== C:/Users/treeman/Desktop/windows nt source code\Source\Win2K3\NT\multimedia\dshow\filterus\pnp\devenum\icmco.h ===
// Copyright (c) 1997  Microsoft Corporation.  All Rights Reserved.
#include "resource.h"
#include "cmgrbase.h"

#include <vfw.h>

static const cchIcDriverName = 16;

class CIcmCoClassManager :
    public CClassManagerBase,
    public CComObjectRoot,
    public CComCoClass<CIcmCoClassManager,&CLSID_CIcmCoClassManager>
{
    struct LegacyCo
    {
        DWORD fccHandler;
    } *m_rgIcmCo;

    ULONG m_cCompressors;

    typedef BOOL(VFWAPI *PICInfo)(
        DWORD fccType, DWORD fccHandler, ICINFO FAR * lpicinfo);
    typedef HIC(VFWAPI *PICOpen)(
        DWORD fccType, DWORD fccHandler, UINT wMode);
    typedef LRESULT (VFWAPI *PICGetInfo)(
        HIC hic, ICINFO FAR *picinfo, DWORD cb);
    typedef LRESULT(VFWAPI *PICClose)(HIC hic);

    PICInfo m_pICInfo;
    PICOpen m_pICOpen;
    PICGetInfo m_pICGetInfo;
    PICClose m_pICClose;
    HMODULE m_hmodMsvideo;
    HRESULT DynLoad();

public:

    CIcmCoClassManager();
    ~CIcmCoClassManager();

    BEGIN_COM_MAP(CIcmCoClassManager)
	COM_INTERFACE_ENTRY2(IDispatch, ICreateDevEnum)
	COM_INTERFACE_ENTRY(ICreateDevEnum)
    END_COM_MAP();

    DECLARE_NOT_AGGREGATABLE(CIcmCoClassManager) ;
    DECLARE_NO_REGISTRY();
    
    HRESULT ReadLegacyDevNames();
    BOOL MatchString(const TCHAR *szDevName);
    HRESULT CreateRegKeys(IFilterMapper2 *pFm2);
    BOOL CheckForOmittedEntries() { return TRUE; }
};
=== C:/Users/treeman/Desktop/windows nt source code\Source\Win2K3\NT\multimedia\dshow\filterus\pnp\devenum\ksaudio.h ===
// Copyright (c) 1998  Microsoft Corporation.  All Rights Reserved.
#ifndef _KSAUDIO_H
#define _KSAUDIO_H

#define KSAUD_F_ENUM_WAVE_CAPTURE 0x0001
#define KSAUD_F_ENUM_WAVE_RENDER  0x0002

#include "cenumpnp.h"
#include "devmon.h"

// Pnp audio devices
struct KsProxyAudioDev
{
    GUID clsid;
    TCHAR *szName;
    LPTSTR lpstrDevicePath;
    DWORD dwMerit;
    IPropertyBag * pPropBag;
};


HRESULT BuildPnpAudDeviceList
(
    const CLSID **rgpclsidKsCat, 
    CGenericList<KsProxyAudioDev> &lstDev,
    DWORD dwFlags = 0
);

BOOL IsFilterWanted( DevMon * pDevMon, DWORD dwFlags );

#endif
=== C:/Users/treeman/Desktop/windows nt source code\Source\Win2K3\NT\multimedia\dshow\filterus\pnp\devenum\makefile.inc ===
$(O)\devenum.res: devenum.rgs dev_x86.rgs
=== C:/Users/treeman/Desktop/windows nt source code\Source\Win2K3\NT\multimedia\dshow\filterus\pnp\devenum\isactive.h ===
// note this is not really a COM interface -- its methods are not
// stdcall.

struct CIsActive : public IUnknown {
    virtual bool IsActive() = 0;
};

static CLSID CLSID_CIsActive = { /* f6c8e5a4-86fc-43f4-a058-242b420af6b5 */
    0xf6c8e5a4,
    0x86fc,
    0x43f4,
    {0xa0, 0x58, 0x24, 0x2b, 0x42, 0x0a, 0xf6, 0xb5}
};
=== C:/Users/treeman/Desktop/windows nt source code\Source\Win2K3\NT\multimedia\dshow\filterus\pnp\devenum\icmco.cpp ===
// Copyright (c) 1997 - 1998  Microsoft Corporation.  All Rights Reserved.
#include "stdafx.h"
#include "icmco.h"
#include <vfw.h>
#include "util.h"

static const TCHAR g_szDriverClsid[] = TEXT("CLSID");
const TCHAR g_szIcmDriverIndex[] = TEXT("FccHandler");


#ifdef _WIN64
#error build error -- this is x86 only
#endif

CIcmCoClassManager::CIcmCoClassManager() :
        CClassManagerBase(g_szIcmDriverIndex),
        m_hmodMsvideo(0),
        m_rgIcmCo(0)
{
}

CIcmCoClassManager::~CIcmCoClassManager()
{
    delete[] m_rgIcmCo;

    if(m_hmodMsvideo)
    {
        FreeLibrary(m_hmodMsvideo);
    }
}

HRESULT CIcmCoClassManager::ReadLegacyDevNames()
{
    m_cNotMatched = 0;

    HRESULT hr = DynLoad();
    if(FAILED(hr))
        return hr;
    
    // count
    for (m_cCompressors = 0;; m_cCompressors++)
    {
        ICINFO icinfo;
        // docs wrong about return code
        if(m_pICInfo(ICTYPE_VIDEO, m_cCompressors, &icinfo) == ICERR_OK)
            break;
    }

    if(m_cCompressors == 0)
        return S_FALSE;

    delete[] m_rgIcmCo;
    m_rgIcmCo = new LegacyCo[m_cCompressors];
    if(m_rgIcmCo == 0)
        return E_OUTOFMEMORY;

    // save names
    for(UINT i = 0; i < m_cCompressors; i++)
    {
        ICINFO icinfo;
        if(m_pICInfo(ICTYPE_VIDEO, i, &icinfo) != ICERR_OK)
        {
            m_rgIcmCo[i].fccHandler = icinfo.fccHandler;
        }
        else
        {
        }
    }

    m_cNotMatched = m_cCompressors;
    return S_OK;
}

BOOL CIcmCoClassManager::MatchString(const TCHAR *szDevName)
{
    for (UINT i = 0; i < m_cCompressors; i++)
    {
	USES_CONVERSION;
        DWORD dwFccHandler = *(DWORD UNALIGNED*)(T2CA(szDevName)); 
        if (dwFccHandler == m_rgIcmCo[i].fccHandler)
        {
            return TRUE;
        }

    }
    return FALSE;
}

HRESULT CIcmCoClassManager::CreateRegKeys(IFilterMapper2 *pFm2)
{
    ResetClassManagerKey(CLSID_VideoCompressorCategory);
    USES_CONVERSION;

    HRESULT hr =  ReadLegacyDevNames();
    if( FAILED( hr )) {
        // m_pICOpen could be null if ignored 
        return hr;
    }

    for (UINT i = 0; i < m_cCompressors; i++)
    {
        // is fccHandler unique?
        char szFccHandler[sizeof(DWORD) + 1];
        *(DWORD UNALIGNED *)szFccHandler = m_rgIcmCo[i].fccHandler;
        szFccHandler[sizeof(DWORD)] = 0;
        const WCHAR *wszUniq = A2CW(szFccHandler);
        WCHAR wszFriendlyName[MAX_PATH];
        *wszFriendlyName = 0;

        // assume codec is broken for some reason
        DWORD dwFlags = CLASS_MGR_OMIT;

        HIC hic = m_pICOpen(ICTYPE_VIDEO, m_rgIcmCo[i].fccHandler, ICMODE_QUERY);
        if(hic)
        {
            ICINFO icinfo;
            if(m_pICGetInfo(hic, &icinfo, sizeof(icinfo)) != 0)
            {
                lstrcpyW(wszFriendlyName, icinfo.szDescription);


                // mark codecs that can't compress
                HIC hicCompress = m_pICOpen(
                    ICTYPE_VIDEO,  m_rgIcmCo[i].fccHandler, ICMODE_COMPRESS);
                if(hicCompress)
                {
                    dwFlags = 0; // codec isn't broken after all
                    m_pICClose(hicCompress);
                }
                else
                {
                }

            }
                
            m_pICClose(hic);
        }

        const FOURCCMap fccSubtype(m_rgIcmCo[i].fccHandler);
        const AMOVIESETUP_MEDIATYPE sudAVICoTypeOut =  {
            &MEDIATYPE_Video,
            &fccSubtype };

        static const AMOVIESETUP_MEDIATYPE sudAVICoTypeIn =  {
            &MEDIATYPE_Video,
            &GUID_NULL };

        const AMOVIESETUP_PIN psudAVICoPins[] =
        {
            {
                L"Input"        // strName
                , FALSE         // bRendered
                , FALSE         // bOutput
                , FALSE         // bZero
                , FALSE         // bMany
                , &CLSID_NULL   // clsConnectsToFilter
                , 0             // strConnectsToPin
                , 1             // nTypes
                , &sudAVICoTypeIn } // lpTypes
            , { L"Output"       // strName
                , FALSE         // bRendered
                , TRUE          // bOutput
                , FALSE         // bZero
                , FALSE         // bMany
                , &CLSID_NULL   // clsConnectsToFilter
                , 0             // strConnectsToPin
                , 1             // nTypes
                , &sudAVICoTypeOut
            }
        };   // lpTypes

        REGFILTER2 rf2;
        rf2.dwVersion = 1;
        rf2.dwMerit = MERIT_DO_NOT_USE;
        rf2.cPins = NUMELMS(psudAVICoPins);
        rf2.rgPins = psudAVICoPins;
        

        IMoniker *pMoniker = 0;
        hr = RegisterClassManagerFilter(
            pFm2,
            CLSID_AVICo,
            wszFriendlyName,
            &pMoniker,
            &CLSID_VideoCompressorCategory,
            wszUniq,
            &rf2);
        if(SUCCEEDED(hr))
        {
            IPropertyBag *pPropBag;
            hr = pMoniker->BindToStorage(
                0, 0, IID_IPropertyBag, (void **)&pPropBag);
            if(SUCCEEDED(hr))
            {
                VARIANT var;
                var.vt = VT_BSTR;
                var.bstrVal = SysAllocString(wszUniq);
                if(var.bstrVal)
                {
                    hr = pPropBag->Write(T2CW(g_szIcmDriverIndex), &var);
                    SysFreeString(var.bstrVal);
                }
                else
                {
                    hr = E_OUTOFMEMORY;
                }

                if(SUCCEEDED(hr))
                {
                    VARIANT var;
                    var.vt = VT_I4;
                    var.lVal = dwFlags;
                    hr = pPropBag->Write(g_wszClassManagerFlags, &var);
                }

                    

                pPropBag->Release();
            }
            pMoniker->Release();                
        }
    }
    

    return S_OK;
}


HRESULT CIcmCoClassManager::DynLoad()
{
    if(m_hmodMsvideo)
        return S_OK;
    
    m_hmodMsvideo = LoadLibrary(TEXT("msvfw32.dll"));
    if(m_hmodMsvideo == 0)
    {
        DWORD dwLastError = GetLastError();
        return HRESULT_FROM_WIN32(dwLastError);
    }

    if(
        (m_pICInfo = (PICInfo)GetProcAddress(m_hmodMsvideo, "ICInfo")) &&
        (m_pICOpen = (PICOpen)GetProcAddress(m_hmodMsvideo, "ICOpen")) &&
        (m_pICGetInfo = (PICGetInfo)GetProcAddress(m_hmodMsvideo, "ICGetInfo")) &&
        (m_pICClose = (PICClose)GetProcAddress(m_hmodMsvideo, "ICClose"))
        )
    {
        return S_OK;
    }
    else
    {
        DWORD dwLastError = GetLastError();
        FreeLibrary(m_hmodMsvideo);
        m_hmodMsvideo = 0;
        return HRESULT_FROM_WIN32(dwLastError);
    }
}
=== C:/Users/treeman/Desktop/windows nt source code\Source\Win2K3\NT\multimedia\dshow\filterus\pnp\devenum\midioutp.h ===
// Copyright (c) 1997 - 1998  Microsoft Corporation.  All Rights Reserved.
#include "resource.h"
#include "cmgrbase.h"

class CMidiOutClassManager :
    public CClassManagerBase,
    public CComObjectRoot,
    public CComCoClass<CMidiOutClassManager,&CLSID_CMidiOutClassManager>
{
    struct LegacyMidiOut
    {

	TCHAR szName[MAXPNAMELEN];
	DWORD dwMidiId;
	DWORD dwMerit;

    } *m_rgMidiOut;

    ULONG m_cMidiOut;

public:

    CMidiOutClassManager();
    ~CMidiOutClassManager();

    BEGIN_COM_MAP(CMidiOutClassManager)
	COM_INTERFACE_ENTRY2(IDispatch, ICreateDevEnum)
	COM_INTERFACE_ENTRY(ICreateDevEnum)
    END_COM_MAP();

    DECLARE_NOT_AGGREGATABLE(CMidiOutClassManager) ;
    DECLARE_NO_REGISTRY();
    
    HRESULT ReadLegacyDevNames();
    BOOL MatchString(const TCHAR *szDevName);
    HRESULT CreateRegKeys(IFilterMapper2 *pFm2);
};
=== C:/Users/treeman/Desktop/windows nt source code\Source\Win2K3\NT\multimedia\dshow\filterus\pnp\devenum\midioutp.cpp ===
// Copyright (c) 1997 - 1999  Microsoft Corporation.  All Rights Reserved.
#include "stdafx.h"
#include "midioutp.h"
#include <vfw.h>
#include "util.h"

static const WCHAR g_wszDriverIndex[] = L"MidiOutId";
const TCHAR g_szMidiOutDriverIndex[] = TEXT("MidiOutId");

const AMOVIESETUP_MEDIATYPE
midiOpPinTypes = { &MEDIATYPE_Midi, &MEDIASUBTYPE_NULL };

const AMOVIESETUP_PIN
midiOutOpPin = { L"Input"
               , TRUE    	   	// bRendered
               , FALSE		   // bOutput
               , FALSE		   // bZero
               , FALSE		   // bMany
               , &CLSID_NULL	   // clsConnectToFilter
               , NULL	           // strConnectsToPin
               , 1	           	// nMediaTypes
               , &midiOpPinTypes }; // lpMediaTypes

CMidiOutClassManager::CMidiOutClassManager() :
        CClassManagerBase(TEXT("FriendlyName")),
        m_rgMidiOut(0)
{
}

CMidiOutClassManager::~CMidiOutClassManager()
{
    delete[] m_rgMidiOut;

}

HRESULT CMidiOutClassManager::ReadLegacyDevNames()
{
    m_cNotMatched = 0;

    HRESULT hr = S_OK;
    if (m_fDoAllDevices) {
        m_cMidiOut = midiOutGetNumDevs() + 1;	// leave room for "midiOut mapper"
    } else {
        m_cMidiOut = 1;
    }

    ASSERT(m_cMidiOut > 0);
    
    delete[] m_rgMidiOut;
    m_rgMidiOut = new LegacyMidiOut[m_cMidiOut];
    if(m_rgMidiOut == 0)
    {
        hr = E_OUTOFMEMORY;
    }
    else
    {
        // save names
        const UINT cMidiOutPhysical = m_cMidiOut - 1;
        for(UINT i = 0; i < cMidiOutPhysical; i++)
        {
            MIDIOUTCAPS moCaps;

            if(midiOutGetDevCaps(i, &moCaps, sizeof(moCaps)) == MMSYSERR_NOERROR)
            {
                lstrcpy(m_rgMidiOut[i].szName, moCaps.szPname);
                m_rgMidiOut[i].dwMidiId = i;
                m_rgMidiOut[i].dwMerit = MERIT_DO_NOT_USE;
            }
            else
            {
                DbgLog((LOG_ERROR, 0, TEXT("midiOutGetDevCaps failed")));
                // leave room for the default one
                m_cMidiOut = i + 1;
                break;
            }
        }

        int ret = LoadString(
            _Module.GetResourceInstance(), IDS_MIDIOUTMAPPER,
            m_rgMidiOut[i].szName, MAXPNAMELEN);

        ASSERT(ret);

        m_rgMidiOut[i].dwMidiId = MIDI_MAPPER;
        m_rgMidiOut[i].dwMerit = MERIT_PREFERRED;
    }
    

    m_cNotMatched = m_cMidiOut;
    return hr;
}

BOOL CMidiOutClassManager::MatchString(const TCHAR *szDevName)
{
    for (UINT i = 0; i < m_cMidiOut; i++)
    {
	USES_CONVERSION;
        if (lstrcmp(m_rgMidiOut[i].szName, szDevName) == 0)
        {
            return TRUE;
        }
    }
    return FALSE;
}

HRESULT CMidiOutClassManager::CreateRegKeys(IFilterMapper2 *pFm2)
{
    ResetClassManagerKey(CLSID_MidiRendererCategory);

    USES_CONVERSION;

    ReadLegacyDevNames();
    for (DWORD i = 0; i < m_cMidiOut; i++)
    {
        const WCHAR *wszUniq = T2COLE(m_rgMidiOut[i].szName);

        REGFILTER2 rf2;
        rf2.dwVersion = 1;
        rf2.dwMerit = m_rgMidiOut[i].dwMerit;
        rf2.cPins = 1;
        rf2.rgPins = &midiOutOpPin;

        IMoniker *pMoniker = 0;
        HRESULT hr = RegisterClassManagerFilter(
            pFm2,
            CLSID_AVIMIDIRender,
            wszUniq,
            &pMoniker,
            &CLSID_MidiRendererCategory,
            wszUniq,
            &rf2);

        if(SUCCEEDED(hr))
        {
            IPropertyBag *pPropBag;
            hr = pMoniker->BindToStorage(
                0, 0, IID_IPropertyBag, (void **)&pPropBag);
            if(SUCCEEDED(hr))
            {
                VARIANT var;
                var.vt = VT_I4;
                var.lVal = m_rgMidiOut[i].dwMidiId;
                hr = pPropBag->Write(g_wszDriverIndex, &var);

                pPropBag->Release();
            }
            pMoniker->Release();
        }
        else
        {
            break;
        }
    } // for

    return S_OK;
}
=== C:/Users/treeman/Desktop/windows nt source code\Source\Win2K3\NT\multimedia\dshow\filterus\pnp\devenum\ksaudio.cpp ===
// Copyright (c) 1998 - 1999  Microsoft Corporation.  All Rights Reserved.
#include "stdafx.h"
#include <ks.h>
#include <ksmedia.h>
#include <ksproxy.h>
#include "ksaudio.h"

//--------------------------------------------------------------------------;
//
// BuildPnpAudDeviceList
//
// Add the correct ksproxy audio filters to the passed in DirectShow category.
//
//--------------------------------------------------------------------------;
HRESULT BuildPnpAudDeviceList
(
    const CLSID **rgpclsidKsCat, 
    CGenericList<KsProxyAudioDev> &lstDev,
    DWORD dwFlags
)
{
    HRESULT hr = S_OK;
    CEnumInternalState cenumState;
    for(;;)
    {
        WCHAR *wszDevicePath = 0;
        CEnumPnp *pEnumPnp = CEnumInterfaceClass::CreateEnumPnp();
        if(pEnumPnp)
        {
            hr = pEnumPnp->GetDevicePath(&wszDevicePath, rgpclsidKsCat, &cenumState);
            if( S_OK == hr )
            {
                IBaseFilter * pFilter = NULL;
                DevMon *pDevMon = new DevMon;
                if( pDevMon )
                {
                    // addref the moniker
                    pDevMon->AddRef();
                    
                    USES_CONVERSION;
                         
                    BOOL bUseFilter = FALSE;   
                    UINT cchDevicePath = lstrlenW(wszDevicePath) + sizeof("@device:pnp:");
                    WCHAR *wszPersistName = new WCHAR[cchDevicePath];
                    if(wszPersistName)
                    {
                        lstrcpyW(wszPersistName, L"@device:pnp:");
                        lstrcatW(wszPersistName, wszDevicePath);

                        ASSERT((UINT)lstrlenW(wszPersistName) == cchDevicePath - 1);

                        hr = pDevMon->Init(wszPersistName);
                        if( SUCCEEDED( hr ) )
                        {
                            bUseFilter = IsFilterWanted( pDevMon, dwFlags );
                            if( bUseFilter )
                            {                            
                                IPropertyBag * pPropBag;
                                hr = pDevMon->BindToStorage( 0, 0, IID_IPropertyBag, (void **)&pPropBag );
                                if (FAILED (hr))
                                {
                                    DbgLog((LOG_TRACE, 1, TEXT("ERROR: IMoniker::BindToStorage failed [0x%08lx]"), hr));
                                }
                                else
                                {
                                    KsProxyAudioDev *pksp = new KsProxyAudioDev;
                                    ZeroMemory( pksp, sizeof( KsProxyAudioDev ) );
                                    if( pksp )
                                    {
                                        VARIANT varFriendly, varDevPath;
                                        varFriendly.vt = VT_EMPTY;
                                        varDevPath.vt = VT_EMPTY;
                                        USES_CONVERSION;
                                    
                                        hr = pPropBag->Read( L"FriendlyName", &varFriendly, 0 );
                                        if( SUCCEEDED( hr ) )
                                        {   
                                            TCHAR szKsProxyFmt[100];
                                            int ret = LoadString(
                                            _Module.GetResourceInstance(), IDS_KSPREFIX,
                                            szKsProxyFmt, 100);
                                            ASSERT(ret);
                                            
                                            pksp->szName = new TCHAR[lstrlen( szKsProxyFmt ) + 
                                                                     lstrlen( W2T( varFriendly.bstrVal ) ) +
                                                                     1];
                                            if( pksp->szName )
                                            {    
                                                wsprintf( pksp->szName, szKsProxyFmt, W2T( varFriendly.bstrVal ) );
                                        
                                                hr = pPropBag->Read( L"DevicePath", &varDevPath, 0 ); 
                                                if( SUCCEEDED( hr ) )
                                                {    
                                                    UINT cch = lstrlen( W2T( varDevPath.bstrVal ) ) + 1;
                                                    pksp->lpstrDevicePath = new TCHAR[cch];
                                                    pksp->pPropBag = pPropBag;
                                                    pksp->dwMerit = MERIT_DO_NOT_USE;
                                                    pksp->clsid = CLSID_Proxy; // ksproxy clsid
                                                    lstrcpy(pksp->lpstrDevicePath, W2T( varDevPath.bstrVal ) );
                                                    SysFreeString( varDevPath.bstrVal );
                                            
                                                    if(!lstDev.AddTail(pksp)) {
                                                        hr = E_OUTOFMEMORY;
                                                    }
                                                }
                                            }                            
                                            else
                                            {
                                                hr = E_OUTOFMEMORY;
                                            }
                                            SysFreeString( varFriendly.bstrVal );
                                        }
                                        
                                        if( FAILED( hr ) )
                                        {
                                            pPropBag->Release();
                                            delete pksp;
                                        }                                            
                                    }                                        
                                }
                            }
                        }                            
                        delete[] wszPersistName;
                    }
                    pDevMon->Release();
                }
                else
                {
                    hr = E_OUTOFMEMORY;
                }
                delete[] wszDevicePath;
            }
            else
            {
                if(hr == HRESULT_FROM_WIN32(ERROR_NO_MORE_ITEMS))
                {
					hr = S_OK;
                } 
                // else error                        
				
                break;
            }

        }
        else
			hr = E_OUTOFMEMORY;
    }
         
    return hr;
}

//--------------------------------------------------------------------------;
//
// IsFilterWanted
//
// Query the ks filter to tell if it's of the desired type 
//
//--------------------------------------------------------------------------;
BOOL IsFilterWanted( DevMon * pDevMon, DWORD dwFlags )
{
    ASSERT( pDevMon );
    
    BOOL bWanted = FALSE;
    
    if( 0 == dwFlags ) // take anything
        bWanted =  TRUE;
    
    IBaseFilter * pFilter;
        
    HRESULT hr = pDevMon->BindToObject(0, 0, IID_IBaseFilter, (void**)&pFilter );
    if (SUCCEEDED(hr))
    {
        IEnumPins * pEnum;
        if( KSAUD_F_ENUM_WAVE_CAPTURE & dwFlags )
        {    
            //
            // for capture filters: 
            //      first look for an output capture pin, next
            //      look for wave audio as a supported type
            //
            HRESULT hr = pFilter->EnumPins( &pEnum );
            if( SUCCEEDED( hr ) )
            {
                for( ; !bWanted ; )
                {
                    IPin * pPin;
                    ULONG  ul;
            
                    hr = pEnum->Next(1,  &pPin, &ul );
                    if( S_OK != hr )
                    {
                        break;
                    }                        
                    else
                    {
                        DbgLog( ( LOG_TRACE
                                , 7
                                , TEXT( "CreateRegKeys(waveinp): checking ksaud filter for capture support..." ) ) );
                        PIN_DIRECTION dir;
                        hr = pPin->QueryDirection( &dir );
                        if( SUCCEEDED( hr ) && PINDIR_OUTPUT == dir)
                        {
                            IKsPropertySet * pKs;
                            GUID clsidPinCategory;
                            ULONG ulBytesReturned;
                            if (pPin->QueryInterface( IID_IKsPropertySet
                                                    , (void **)&pKs) == S_OK) 
                            {
                                hr = pKs->Get( AMPROPSETID_Pin
                                             , AMPROPERTY_PIN_CATEGORY
                                             , NULL
                                             , 0
                                             , &clsidPinCategory
                                             , sizeof( clsidPinCategory )
                                             , &ulBytesReturned );
                                if( SUCCEEDED( hr ) && 
                                    ( clsidPinCategory == PINNAME_CAPTURE ) )
                                {
                                    IEnumMediaTypes * pEnumMT;
                                    hr = pPin->EnumMediaTypes( &pEnumMT );
                                    if( SUCCEEDED( hr ) )
                                    {
                                        // 
                                        // if this pin enumerates Wave Audio then
                                        // it's the one we want
                                        //
                                        for( ; ; )
                                        {
                                            AM_MEDIA_TYPE *pMediaType = NULL;
                                            ULONG ulCount;
                        
                                            hr = pEnumMT->Next( 1, &pMediaType, &ulCount );  
                                            if( S_OK != hr )
                                            {
                                                break;
                                            }                                        
                                            else if( ( MEDIATYPE_Audio == pMediaType->majortype ) &&
                                                     ( FORMAT_WaveFormatEx == pMediaType->formattype ) )
                                            {
                                                DbgLog( ( LOG_TRACE
                                                    , 5
                                                    , TEXT( "CreateRegKeys(waveinp): found ks wave audio capture filter" ) ) );
                                                DeleteMediaType( pMediaType );
                                                bWanted = TRUE;
                                                break;
                                            }
                                            DeleteMediaType( pMediaType );
                                        }
                                        pEnumMT->Release();                                                                       
                                    }          
                                }
                                pKs->Release();
                            }            
                        }
                        pPin->Release();
                    }                    
                }                    
                pEnum->Release();
            }
        }
        pFilter->Release();            
    }
    else
        DbgLog((LOG_TRACE, 1, TEXT("ERROR: CreateRegKeys - BindToObject failed [0x%08lx]"), hr));
    
    return bWanted;
}
=== C:/Users/treeman/Desktop/windows nt source code\Source\Win2K3\NT\multimedia\dshow\filterus\pnp\devenum\mkenum.h ===
// Copyright (c) 1997 - 1998  Microsoft Corporation.  All Rights Reserved.
// CreateSwEnum.h : Declaration of the CCreateSwEnum

#ifndef _MKENUM_H
#define _MKENUM_H

#include "resource.h"       // main symbols

#include "cenumpnp.h"
#include "devmon.h"

// flags for CreateClassEnumerator
static const DWORD CREATE_ENUM_OMITTED = 0x1;

class CCreateSwEnum : 
    public ICreateDevEnum,
    public CComObjectRoot,
    public CComCoClass<CCreateSwEnum,&CLSID_SystemDeviceEnum>
{
    typedef CComEnum<IEnumMoniker,
        &IID_IEnumMoniker, IMoniker*,
        _CopyInterface<IMoniker> >
    CEnumMonikers;
    
public:

BEGIN_COM_MAP(CCreateSwEnum)
    COM_INTERFACE_ENTRY(ICreateDevEnum)
    COM_INTERFACE_ENTRY_IID(CLSID_SystemDeviceEnum, CCreateSwEnum)
END_COM_MAP()

    DECLARE_NOT_AGGREGATABLE(CCreateSwEnum) ;
    // Remove the comment from the line above if you don't want your object to 
    // support aggregation.  The default is to support it

    DECLARE_GET_CONTROLLING_UNKNOWN();

    // register all categories. x86 specific class managers done through devmon.h
    DECLARE_REGISTRY_RESOURCEID(IDR_REGISTRY)

    // ICreateDevEnum
    STDMETHOD(CreateClassEnumerator)(REFCLSID clsidDeviceClass,
                                     IEnumMoniker ** ppEnumMoniker,
                                     DWORD dwFlags);

    // private method
    STDMETHOD(CreateClassEnumerator)(
        REFCLSID clsidDeviceClass,
        IEnumMoniker ** ppEnumMoniker,
        DWORD dwFlags,
        IEnumMoniker ** ppEnumClassMgrMonikers);

    CCreateSwEnum();

private:

#ifdef PERF
    int m_msrEnum;
    int m_msrCreateOneSw;
#endif

    ICreateDevEnum * CreateClassManager(REFCLSID clsidDeviceClass, DWORD dwFlags);

    // S_FALSE to signal no more items
    HRESULT CreateOnePnpMoniker(
        IMoniker **pDevMon,
        const CLSID **rgpclsidKsCat,
        CEnumInternalState *pcenumState);

    // S_FALSE to signal non-fatal error
    HRESULT CreateOneSwMoniker(
        IMoniker **pDevMon,
        HKEY hkClass,
	const TCHAR *szThisClass,
        DWORD iKey);

    HRESULT CreateSwMonikers(
        CComPtr<IUnknown> **prgpMoniker,
        UINT *pcMonikers,
	REFCLSID clsidDeviceClass);

    HRESULT CreateCmgrMonikers(
        CComPtr<IUnknown> **prgpMoniker,
        UINT *pcMonikers,
	REFCLSID clsidDeviceClass,
        CEnumMonikers **ppEnumMonInclSkipped,
        IMoniker **ppPreferred);

    HRESULT CreateOneCmgrMoniker(
        IMoniker **pDevMon,
        HKEY hkClass,
	const TCHAR *szThisClass,
        DWORD iKey,
        bool *pfShouldSkip,
        bool *pfIsDefaultDevice);        

    HRESULT CreatePnpMonikers(
        CGenericList<IMoniker> *plstMoniker,
	REFCLSID clsidDeviceClass);

    HRESULT CreateDmoMonikers(
        CGenericList<IMoniker> *plstMoniker,
	REFCLSID clsidDeviceClass);

    CEnumPnp *m_pEnumPnp;
};


#endif // _MKENUM_H
=== C:/Users/treeman/Desktop/windows nt source code\Source\Win2K3\NT\multimedia\dshow\filterus\pnp\devenum\mkenum.cpp ===
// Copyright (c) 1997 - 1999  Microsoft Corporation.  All Rights Reserved.
// CreateDevEnum.cpp : Implementation of CdevenumApp and DLL registration.

#include "stdafx.h"
#include "mkenum.h"
#include "devmon.h"
#include "util.h"
#include "ks.h"
#include "ksmedia.h"

#include <mediaobj.h>
#include <dmoreg.h>

static const TCHAR g_szDriverDesc[] = TEXT("FriendlyName");
static const TCHAR g_szDriver[] = TEXT("Driver");
static const TCHAR g_szClsid[] = TEXT("CLSID");
const WCHAR g_wszClassManagerFlags[] = L"ClassManagerFlags";
const TCHAR g_szClassManagerFlags[] = TEXT("ClassManagerFlags");

// compiler bug prevents making this a static class member
PDMOEnum g_pDMOEnum = 0;

bool InitDmo();

CCreateSwEnum::CCreateSwEnum()
{
#ifdef PERF
    m_msrEnum = MSR_REGISTER(TEXT("CCreateSwEnum"));
    m_msrCreateOneSw = MSR_REGISTER(TEXT("CreateOneSwMoniker"));
#endif

    // get a refcounted setupapi.dll so we don't keep loading and
    // unloading it. we can't just load setupapi in DllEntry because
    // of the win95 bug freeing libraries in DETACH
    m_pEnumPnp = CEnumInterfaceClass::CreateEnumPnp();

    // see if a new version of devenum.dll was installed since the
    // current user last enumerated devices.
    //
    // do this here because this is run less frequently than anything
    // else.
    //

    // if mutex was already created, we can skip the version check
    // because it has already been executed.
    extern HANDLE g_devenum_mutex;
    if(g_devenum_mutex) {
        return;
    }

    extern CRITICAL_SECTION g_devenum_cs;
    EnterCriticalSection(&g_devenum_cs);
    if(g_devenum_mutex == 0)
    {
        g_devenum_mutex = CreateMutex(
            NULL,                   // no security attributes
            FALSE,                  // not initially owned
            TEXT("eed3bd3a-a1ad-4e99-987b-d7cb3fcfa7f0")); // name
    }
    LeaveCriticalSection(&g_devenum_cs);
    if(g_devenum_mutex == NULL)
    {
        DbgLog((LOG_ERROR, 0, TEXT("g_devenum_mutex creation failed.")));
        return;
    }

    // serialize HKCU registry editing
    EXECUTE_ASSERT(WaitForSingleObject(g_devenum_mutex, INFINITE) ==
                   WAIT_OBJECT_0);

    bool fBreakCache = true;
    {
        CRegKey rk;
        LONG lResult = rk.Open(g_hkCmReg, g_szCmRegPath, KEY_READ);

        DWORD dwCachedVer;
        if(lResult == ERROR_SUCCESS)
        {
            lResult = rk.QueryValue(dwCachedVer, G_SZ_DEVENUM_VERSION);
        }
        if(lResult == ERROR_SUCCESS && dwCachedVer == DEVENUM_VERSION) {
            fBreakCache = false;
        }

        // auto close key (it is deleted below)
    }

    if(fBreakCache)
    {
        RegDeleteTree(g_hkCmReg, g_szCmRegPath);

        DbgLog((LOG_TRACE, 0,
                TEXT("CCreateSwEnum: resetting class manager keys.")));

        CRegKey rk;
        LONG lResult = rk.Create(
            g_hkCmReg,
            g_szCmRegPath,
            0,                  // lpszClass
            REG_OPTION_NON_VOLATILE, // dwOptions
            KEY_WRITE);
        if(lResult == ERROR_SUCCESS)
        {
            lResult = rk.SetValue(DEVENUM_VERSION, G_SZ_DEVENUM_VERSION);
        }
    }

    EXECUTE_ASSERT(ReleaseMutex(g_devenum_mutex));
};

// the one method from our published ICreateDevEnum interface
//
STDMETHODIMP CCreateSwEnum::CreateClassEnumerator(
  REFCLSID clsidDeviceClass,
  IEnumMoniker **ppEnumMoniker,
  DWORD dwFlags)
{
    // call the real method and pass in a null for the
    // ppEnumClassMgrMonikers argument
    return CreateClassEnumerator(clsidDeviceClass, ppEnumMoniker, dwFlags, 0);
}

void FreeMonList(CGenericList<IMoniker> *plstMoniker)
{
    for(POSITION pos = plstMoniker->GetHeadPosition();
        pos;
        pos = plstMoniker->Next(pos))
    {
        plstMoniker->Get(pos)->Release();
    }
}


//
// Routine Description
//
//     This routine returns an enumerator for the monikers for pnp,
//     software, and class-managed devices. optionally returns an
//     enumerator containing just the managed devices.
//
// Arguments
//
//     clsidDeviceClass - guid of the category we're enumerating
//
//     ppEnumMoniker - enumerator is returned here. cannot be null.
//
//     dwFlags - CDEF_BYPASS_CLASS_MANAGER - just enumerate what's in
//     the registry without letting the class manager have a go.
//
//     pEnumMonInclSkipped - (optional) an enumerator containing
//     only the devices maintained by the class manager. Used by the
//     class manager to verify that the registry is in sync. Does
//     include devices with the CLASS_MGR_OMIT flag.
//
STDMETHODIMP CCreateSwEnum::CreateClassEnumerator(
  REFCLSID clsidDeviceClass,
  IEnumMoniker **ppEnumMoniker,
  DWORD dwFlags,
  IEnumMoniker ** ppEnumClassMgrMonikers
  )
{
    PNP_PERF(static int msrCreatePnp = MSR_REGISTER(TEXT("mkenum: CreatePnp")));
    PNP_PERF(static int msrCreateSw = MSR_REGISTER(TEXT("mkenum: CreateSw")));
    MSR_INTEGER(m_msrEnum, clsidDeviceClass.Data1);

    CheckPointer(ppEnumMoniker, E_POINTER);
    *ppEnumMoniker = NULL;

    ICreateDevEnum *pClassManager = CreateClassManager(clsidDeviceClass, dwFlags);
    if (pClassManager)
    {
        HRESULT hr = pClassManager->CreateClassEnumerator(clsidDeviceClass, ppEnumMoniker, dwFlags);
        pClassManager->Release();
        MSR_INTEGER(m_msrEnum, clsidDeviceClass.Data1);
        return hr;
    }

    HRESULT hr = S_OK;

// if no mask flags are set then enumerate everything. Otherwise
// enumerate only the specified types.
#define CHECK_SEL(x) (((dwFlags & CDEF_DEVMON_SELECTIVE_MASK) == 0) || \
                      (dwFlags & x))

    PNP_PERF(MSR_START(msrCreatePnp));
    CGenericList<IMoniker> lstPnpMon(NAME("pnp moniker list"), 10);
    if(CHECK_SEL(CDEF_DEVMON_PNP_DEVICE)) {
        hr = CreatePnpMonikers(&lstPnpMon, clsidDeviceClass);
    }
    PNP_PERF(MSR_STOP(msrCreatePnp));

    if(FAILED(hr)) {
        DbgLog((LOG_TRACE, 0, TEXT("devenum: CreatePnpMonikers failed.")));
    }

    UINT cPnpMonikers = lstPnpMon.GetCount();

    PNP_PERF(MSR_START(msrCreateSw));
    CComPtr<IUnknown> *rgpCmMoniker = 0;
    CComPtr<IMoniker> pPreferredCmgrDev;
    CComPtr<CEnumMonikers> pEnumMonInclSkipped;
    UINT cCmMonikers = 0;
    if(CHECK_SEL(CDEF_DEVMON_CMGR_DEVICE)) {
        hr = CreateCmgrMonikers(
            &rgpCmMoniker, &cCmMonikers, clsidDeviceClass,
            &pEnumMonInclSkipped, &pPreferredCmgrDev );
    }

    if(FAILED(hr)) {
        DbgLog((LOG_TRACE, 0, TEXT("devenum: CreateCmgrMonikers failed.")));
    }

    CComPtr<IUnknown> *rgpSwMoniker = 0;
    UINT cSwMonikers = 0;
    if(CHECK_SEL(CDEF_DEVMON_FILTER)) {
        hr = CreateSwMonikers(&rgpSwMoniker, &cSwMonikers, clsidDeviceClass);
    }

    PNP_PERF(MSR_STOP(msrCreateSw));

    if(FAILED(hr)) {
        DbgLog((LOG_TRACE, 0, TEXT("devenum: CreateSwMonikers failed.")));
    }

    CGenericList<IMoniker> lstDmoMon(NAME("DMO moniker list"));
    if(CHECK_SEL(CDEF_DEVMON_DMO)) {
        hr = CreateDmoMonikers(&lstDmoMon, clsidDeviceClass);
    }
    if(FAILED(hr)) {
        DbgLog((LOG_ERROR, 0, TEXT("CreateDmoMonikers failed.")));
    }
    UINT cDmoMonikers = lstDmoMon.GetCount();


    DbgLog((LOG_TRACE, 5, TEXT("devenum: cat %08x. sw:%d, pnp:%d, cm:%d, dmo: %d"),
            clsidDeviceClass.Data1, cSwMonikers, cPnpMonikers, cCmMonikers, cDmoMonikers));

    UINT cMonikers = cPnpMonikers + cSwMonikers + cCmMonikers + cDmoMonikers;

    if(cMonikers != 0)
    {
        // copy all monikers into one array for CEnumMonikers

        IUnknown **rgpMonikerNotAddRefd = new IUnknown*[cMonikers];
        if(rgpMonikerNotAddRefd)
        {
            // order is important -- we want the enumerator to return
            // pnp things, then things installed directly, and finally
            // stuff installed by class managers. But the very first
            // thing is the "preferred device" if there is one.

            UINT iMonDest = 0;
            if(pPreferredCmgrDev) {
                rgpMonikerNotAddRefd[iMonDest++] = pPreferredCmgrDev;
            }


            POSITION pos = lstPnpMon.GetHeadPosition();
            for(UINT iMoniker = 0 ; iMoniker < cPnpMonikers; iMoniker++)
            {
                IMoniker *pDevMon = lstPnpMon.Get(pos);
                ASSERT(pDevMon);
                rgpMonikerNotAddRefd[iMonDest++] = pDevMon;
                pos = lstPnpMon.Next(pos) ;
            }
            ASSERT(pos == 0);

            pos = lstDmoMon.GetHeadPosition();
            for(iMoniker = 0 ; iMoniker < cDmoMonikers; iMoniker++)
            {
                IMoniker *pDevMon = lstDmoMon.Get(pos);
                ASSERT(pDevMon);
                rgpMonikerNotAddRefd[iMonDest++] = pDevMon;
                pos = lstDmoMon.Next(pos) ;
            }
            ASSERT(pos == 0);

            for(iMoniker = 0; iMoniker < cSwMonikers; iMoniker++)
            {
                ASSERT(rgpSwMoniker[iMoniker]);
                rgpMonikerNotAddRefd[iMonDest++] = rgpSwMoniker[iMoniker];
            }

            for(iMoniker = 0; iMoniker < cCmMonikers; iMoniker++)
            {
                ASSERT(rgpCmMoniker[iMoniker]);

                // skip the preferred device because we already
                // handled it above.
                if(rgpCmMoniker[iMoniker] != pPreferredCmgrDev) {
                    rgpMonikerNotAddRefd[iMonDest++] = rgpCmMoniker[iMoniker];
                }
            }

            ASSERT(iMonDest == cPnpMonikers + cSwMonikers + cCmMonikers + cDmoMonikers);

            CEnumMonikers *pDevEnum = new CComObject<CEnumMonikers>;
            if(pDevEnum)
            {
                IMoniker **ppMonikerRgStart = (IMoniker **)&rgpMonikerNotAddRefd[0];
                IMoniker **ppMonikerRgEnd = ppMonikerRgStart + cMonikers;

                hr = pDevEnum->Init(ppMonikerRgStart,
                                    ppMonikerRgEnd,
                                    GetControllingUnknown(),
                                    AtlFlagCopy);
                if(SUCCEEDED(hr))
                {
                    hr = S_OK;
                    pDevEnum->AddRef();
                    *ppEnumMoniker = pDevEnum;

                    if(ppEnumClassMgrMonikers && pEnumMonInclSkipped) {
                        *ppEnumClassMgrMonikers = pEnumMonInclSkipped;
                        pEnumMonInclSkipped.p->AddRef();
                    }
                }
                else
                {
                    delete pDevEnum;
                }
            }
            else
            {
                hr = E_OUTOFMEMORY;
            }

            delete[] rgpMonikerNotAddRefd;
        }
        else
        {
            hr = E_OUTOFMEMORY;
        }
    }
    else
    {
        hr = S_FALSE;
    }

    delete[] rgpSwMoniker;
    delete[] rgpCmMoniker;

    FreeMonList(&lstPnpMon);
    FreeMonList(&lstDmoMon);

    MSR_INTEGER(m_msrEnum, clsidDeviceClass.Data1);
    return hr;
}


//
// Routine Description
//
//     This routine creates and returns one moniker for a device in
//     the class manager location in the registry.
//
// Arguments
//
//     ppDevMon - the moniker is returned here (with a refcount)
//
//     hkClass - The opened registry key of the key containing the
//     device registry key
//
//     szThisClass - the string for the category guid for the moniker
//
//     iKey - index of key in hkClass of the device to open
//
//     pfShouldSkip - returns whether the device should be skipped in
//     the enumerator. used when it's too expensive to determine
//     whether a particular item should be returned otherwise.
//
//     pfIsDefaultDevice - "preferred" devices. Indicates this one
//     should be returned first.
//

HRESULT CCreateSwEnum::CreateOneCmgrMoniker(
    IMoniker **ppDevMon,
    HKEY hkClass,
    const TCHAR *szThisClass,
    DWORD iKey,
    bool *pfShouldSkip,
    bool *pfIsDefaultDevice)
{
    PNP_PERF(static int msrCreateSw = MSR_REGISTER(TEXT("mkenum: CreateOneCmgrMoniker")));

    TCHAR szInstanceName[MAX_PATH];
    HRESULT hr = S_OK;
    *ppDevMon = 0;
    *pfIsDefaultDevice = false;
    *pfShouldSkip = false;

    if(RegEnumKey(hkClass, iKey, szInstanceName, MAX_PATH) != ERROR_SUCCESS)
        return S_FALSE;

    HKEY hkDevice;
    if(RegOpenKeyEx(hkClass, szInstanceName, 0, KEY_READ, &hkDevice) != ERROR_SUCCESS)
        return S_FALSE;

    bool bCloseDevKey = true;   // moniker may want to hold on to it

    DWORD dwType;

    DWORD dwFlags;
    DWORD dwcb = sizeof(dwFlags);
    if(RegQueryValueEx(hkDevice, g_szClassManagerFlags,
                       0, &dwType, (BYTE *)&dwFlags, &dwcb) ==
       ERROR_SUCCESS)
    {
        *pfShouldSkip = (dwFlags & CLASS_MGR_OMIT) != 0;
        *pfIsDefaultDevice = (dwFlags & CLASS_MGR_DEFAULT) != 0;
    }
    EXECUTE_ASSERT(ERROR_SUCCESS == RegCloseKey(hkDevice));

    if(hr == S_OK)
    {
        USES_CONVERSION;

        CComObject<CDeviceMoniker> *pDevMon = new CComObject<CDeviceMoniker>;
        if(pDevMon)
        {
            TCHAR szPersistentName[MAX_PATH * 2];
            lstrcpy(szPersistentName, TEXT("@device:cm:"));
            lstrcat(szPersistentName, szThisClass);
            lstrcat(szPersistentName, TEXT("\\"));
            lstrcat(szPersistentName, szInstanceName);

            hr = pDevMon->Init(T2CW(szPersistentName));
            if(SUCCEEDED(hr))
            {
                hr = S_OK;
                *ppDevMon = pDevMon;
                pDevMon->AddRef();
                bCloseDevKey = false;
            }
            else
            {
                delete pDevMon;
            }
        }
        else
        {
            hr = E_OUTOFMEMORY;
        }
    }

    if(bCloseDevKey)
    {
        RegCloseKey(hkDevice);
    }

    return hr;
}

//
// Routine
//
//     returns an array of monikers of devices created by a class
//     manager (in HKEY_CLASSES_ROOT).
//
// Arguments
//
//     prgpMoniker - array of monikers is returned here. excludes
//     devices that are registered with the "OMIT" flag.
//
//     pcMonikers - # of elements in array above is returned here.
//
//     clsidDeviceClass - category we're enumerating
//
//     ppEnumMoniker - enumerator containing all devices that the
//     class manager deals with is returned here (optional).

HRESULT CCreateSwEnum::CreateCmgrMonikers(
    CComPtr<IUnknown> **prgpMoniker,
    UINT *pcMonikers,
    REFCLSID clsidDeviceClass,
    CEnumMonikers **ppEnumMonInclSkipped,
    IMoniker **ppPreferred
    )
{
    *prgpMoniker = 0;
    *pcMonikers = 0;
    *ppPreferred = 0;

    if(ppEnumMonInclSkipped) {
        *ppEnumMonInclSkipped = 0;
    }

    HRESULT hr = S_OK;

    TCHAR szInstance[MAX_PATH];

    OLECHAR wszThisClass[CHARS_IN_GUID];
    EXECUTE_ASSERT(StringFromGUID2(clsidDeviceClass, wszThisClass, CHARS_IN_GUID) ==
                   CHARS_IN_GUID);

    USES_CONVERSION;
    const TCHAR *szThisClass = W2CT(wszThisClass);
    lstrcpy(szInstance, g_szCmRegPath);
    szInstance[NUMELMS(g_szCmRegPath) - 1] = TEXT('\\');
    lstrcpy(szInstance + NUMELMS(g_szCmRegPath), szThisClass);

    HKEY hkThisClass;
    LONG lResult = RegOpenKeyEx(g_hkCmReg, szInstance, 0, KEY_READ, &hkThisClass);
    if (lResult == ERROR_SUCCESS)
    {
        DWORD cEntries;
        LONG lResult = RegQueryInfoKey(hkThisClass, 0, 0, 0, &cEntries, 0, 0, 0, 0, 0, 0, 0);
        if(lResult == ERROR_SUCCESS)
        {
            CComPtr<IUnknown> *rgpMonikerExclSkipped = new CComPtr<IUnknown>[cEntries];
            if(rgpMonikerExclSkipped)
            {
                CComPtr<IUnknown> *rgpMonikerInclSkipped = 0;
                if(ppEnumMonInclSkipped) {
                    rgpMonikerInclSkipped = new CComPtr<IUnknown>[cEntries];
                }
                if(rgpMonikerInclSkipped || !ppEnumMonInclSkipped)
                {
                    CComPtr<IMoniker> pPreferred;

                    DWORD cEntriesFound = 0;
                    DWORD cEntriesLessSkipped = 0;
                    for(DWORD iEntry = 0; iEntry < cEntries; iEntry++)
                    {
                        //PNP_PERF(MSR_START(m_msrCreateOneSw));
                        bool fDefaultDevice;
                        bool fShouldSkip;
                        IMoniker *pDevMon;
                        hr = CreateOneCmgrMoniker(
                            &pDevMon,
                            hkThisClass,
                            szThisClass,
                            iEntry,
                            &fShouldSkip,
                            &fDefaultDevice);
                        //PNP_PERF(MSR_STOP(m_msrCreateOneSw));

                        if(hr == S_OK)
                        {
                            ASSERT(pDevMon);

                            if(fDefaultDevice)
                            {
                                ASSERT(pPreferred == 0);
                                pPreferred = pDevMon; // auto addref
                            }

                            if(ppEnumMonInclSkipped) {
                                // auto addref
                                rgpMonikerInclSkipped[cEntriesFound] = pDevMon;
                            }
                            cEntriesFound++;

                            if(!fShouldSkip)
                            {
                                // avoid auto addref; transfer refcount
                                rgpMonikerExclSkipped[cEntriesLessSkipped].p = pDevMon;

                                cEntriesLessSkipped++;
                            }
                            else
                            {
                                pDevMon->Release();
                            }
                        }
                        else if(hr == S_FALSE)
                        {
                            ASSERT(pDevMon == 0);

                            // non-fatal error
                            continue;
                        }
                        else
                        {
                            ASSERT(pDevMon == 0);

                            // fatal error
                            break;
                        }
                    }

                    CEnumMonikers *pEnumMonInclSkipped = 0;;
                    if(SUCCEEDED(hr) && ppEnumMonInclSkipped)
                    {
                        pEnumMonInclSkipped = new CComObject<CEnumMonikers>;
                        if(pEnumMonInclSkipped)
                        {
                            IMoniker **ppMonikerRgStart = (IMoniker **)rgpMonikerInclSkipped;
                            IMoniker **ppMonikerRgEnd = ppMonikerRgStart + cEntriesFound;

                            hr = pEnumMonInclSkipped->Init(
                                ppMonikerRgStart,
                                ppMonikerRgEnd,
                                GetControllingUnknown(),
                                AtlFlagCopy);
                        }
                        else
                        {
                            hr = E_OUTOFMEMORY;
                        }
                    }

                    if(SUCCEEDED(hr))
                    {
                        hr = S_OK; // may see S_FALSE
                        *pcMonikers = cEntriesLessSkipped;
                        *prgpMoniker = rgpMonikerExclSkipped;
                        if(ppEnumMonInclSkipped) {
                            *ppEnumMonInclSkipped = pEnumMonInclSkipped;
                            pEnumMonInclSkipped->AddRef();
                        }

                        if(pPreferred)
                        {
                            *ppPreferred = pPreferred;
                            pPreferred.p->AddRef();
                        }
                    }

                    delete[] rgpMonikerInclSkipped;
                }
                else
                {
                    hr = E_OUTOFMEMORY;
                }

                if(FAILED(hr))
                {
                    delete[] rgpMonikerExclSkipped;
                }
            }
            else
            {
                hr = E_OUTOFMEMORY;
            }
        }

        RegCloseKey(hkThisClass);
    }

    return hr;
}

//
// Routine Description
//
//     This routine creates and returns one moniker for a device in
//     the Instance location in the registry (HKCR\{category}\Instance
//
// Arguments
//
//     ppDevMon - the moniker is returned here (with a refcount)
//
//     hkClass - The opened registry key of the key containing the
//     device registry key
//
//     szThisClass - the string for the category guid for the moniker
//
//     iKey - index of key in hkClass of the device to open
//
//

HRESULT CCreateSwEnum::CreateOneSwMoniker(
    IMoniker **ppDevMon,
    HKEY hkClass,
    const TCHAR *szThisClass,
    DWORD iKey)
{
    PNP_PERF(static int msrCreateSw = MSR_REGISTER(TEXT("mkenum: CreateOneSwMoniker")));

    TCHAR szInstanceName[MAX_PATH];
    HRESULT hr = S_OK;
    *ppDevMon = 0;

    if(RegEnumKey(hkClass, iKey, szInstanceName, MAX_PATH) != ERROR_SUCCESS)
        return S_FALSE;

    HKEY hkDevice;
    if(RegOpenKeyEx(hkClass, szInstanceName, 0, KEY_READ, &hkDevice) != ERROR_SUCCESS)
        return S_FALSE;

    bool bCloseDevKey = true;   // moniker may want to hold on to it


    USES_CONVERSION;

    CComObject<CDeviceMoniker> *pDevMon = new CComObject<CDeviceMoniker>;
    if(pDevMon)
    {
        TCHAR szPersistentName[MAX_PATH * 2];
        lstrcpy(szPersistentName, TEXT("@device:sw:"));
        lstrcat(szPersistentName, szThisClass);
        lstrcat(szPersistentName, TEXT("\\"));
			
        {
            USES_CONVERSION;
            lstrcat(szPersistentName, szInstanceName);
        }
        hr = pDevMon->Init(T2CW(szPersistentName));
        if(SUCCEEDED(hr))
        {
            hr = S_OK;
            *ppDevMon = pDevMon;
            pDevMon->AddRef();
        }
        else
        {
            delete pDevMon;
        }
    }
    else
    {
        hr = E_OUTOFMEMORY;
    }



    if(bCloseDevKey)
    {
        RegCloseKey(hkDevice);
    }

    return hr;
}


//
// Routine
//
//     returns an array of monikers of devices installed in the
//     Instance location (HKCR\{category}\Interface)
//
// Arguments
//
//     prgpMoniker - array of monikers is returned here.
//
//     pcMonikers - # of elements in array above is returned here.
//
//     clsidDeviceClass - category we're enumerating
//
HRESULT CCreateSwEnum::CreateSwMonikers(
    CComPtr<IUnknown> **prgpMoniker,
    UINT *pcMonikers,
    REFCLSID clsidDeviceClass)
{
    *prgpMoniker = 0;
    *pcMonikers = 0;

    HRESULT hr = S_OK;
    HKEY hkUserDevRoot;
    if(RegOpenKeyEx(HKEY_CLASSES_ROOT, g_szClsid, 0, KEY_READ, &hkUserDevRoot) == ERROR_SUCCESS)
    {
        TCHAR szInstance[MAX_PATH];

        OLECHAR wszThisClass[CHARS_IN_GUID];
        EXECUTE_ASSERT(StringFromGUID2(clsidDeviceClass, wszThisClass, CHARS_IN_GUID) ==
                       CHARS_IN_GUID);
        USES_CONVERSION;
        const TCHAR *szThisClass = W2CT(wszThisClass);
        lstrcpy(szInstance, szThisClass);
        lstrcpy(szInstance + CHARS_IN_GUID - 1, TEXT("\\Instance"));

        HKEY hkThisClass;
        LONG lResult;
        {
            USES_CONVERSION;
            lResult = RegOpenKeyEx(hkUserDevRoot, szInstance, 0, KEY_READ, &hkThisClass);
        }
        if (lResult == ERROR_SUCCESS)
        {
            // static const cchIndex = 5;
            DWORD cEntries;
            LONG lResult = RegQueryInfoKey(hkThisClass, 0, 0, 0, &cEntries, 0, 0, 0, 0, 0, 0, 0);
            if(lResult == ERROR_SUCCESS)
            {
                CComPtr<IUnknown> *rgpMoniker = new CComPtr<IUnknown>[cEntries];
                if(rgpMoniker)
                {
                    DWORD cEntriesFound = 0;
                    for(DWORD iEntry = 0; iEntry < cEntries; iEntry++)
                    {
                        //PNP_PERF(MSR_START(m_msrCreateOneSw));
                        IMoniker *pDevMon;
                        hr = CreateOneSwMoniker(
                            &pDevMon,
                            hkThisClass,
                            szThisClass,
                            iEntry);
                        //PNP_PERF(MSR_STOP(m_msrCreateOneSw));

                        if(hr == S_OK)
                        {
                            // avoid auto addref; transfer refcount
                            rgpMoniker[cEntriesFound].p = pDevMon;

                            cEntriesFound++;
                        }
                        else if(hr == S_FALSE)
                        {
                            // non-fatal error
                            continue;
                        }
                        else
                        {
                            break;
                        }
                    }

                    if(SUCCEEDED(hr))
                    {
                        hr = S_OK; // may see S_FALSE
                        *pcMonikers = cEntriesFound;
                        *prgpMoniker = rgpMoniker;
                    }
                    else
                    {
                        delete[] rgpMoniker;
                    }
                }
            }

            RegCloseKey(hkThisClass);
        }

        RegCloseKey(hkUserDevRoot);
    }

    return hr;
}


// instatiate and destroy device. gives George's filters a chance to
// register their filter data key
//
void RegisterFilterDataKey(DevMon *pDevMon)
{
    VARIANT var;
    var.vt = VT_EMPTY;
    HRESULT hr = pDevMon->Read(L"FilterData", &var, 0);
    if(SUCCEEDED(hr))
    {
        hr = VariantClear(&var);
        ASSERT(hr == S_OK);
    }
    else
    {
        IUnknown *pUnk;
        hr = pDevMon->BindToObject(
            0,                  // bindCtx
            0,                  // mkToLeft
            IID_IUnknown,
            (void **)&pUnk);
        if(SUCCEEDED(hr))
        {
            pUnk->Release();
        }
    }
}


HRESULT CCreateSwEnum::CreateOnePnpMoniker(
    IMoniker **ppDevMon,
    const CLSID **rgpclsidKsCat,
    CEnumInternalState *pcenumState)
{
    HRESULT hr = S_OK;

    WCHAR *wszDevicePath = 0;
    CEnumPnp *pEnumPnp = CEnumInterfaceClass::CreateEnumPnp();
    if(pEnumPnp)
    {
        hr = pEnumPnp->GetDevicePath(&wszDevicePath, rgpclsidKsCat, pcenumState);
        if(hr == S_OK)
        {
            DevMon *pDevMon = new DevMon;
            if(pDevMon)
            {
                pDevMon->AddRef(); // keep refcount from hitting 0
                USES_CONVERSION;

                UINT cchDevicePath = lstrlenW(wszDevicePath) + sizeof("@device:pnp:");
                WCHAR *wszPersistName = new WCHAR[cchDevicePath];
                if(wszPersistName)
                {
                    lstrcpyW(wszPersistName, L"@device:pnp:");
                    lstrcatW(wszPersistName, wszDevicePath);

                    ASSERT((UINT)lstrlenW(wszPersistName) == cchDevicePath - 1);

                    hr = pDevMon->Init(wszPersistName);
                    if(SUCCEEDED(hr))
                    {
                        RegisterFilterDataKey(pDevMon);

                        hr = S_OK;
                        *ppDevMon = pDevMon;
                        pDevMon->AddRef();
                    }

                    delete[] wszPersistName;
                }

                pDevMon->Release();
            }
            else
            {
                hr = E_OUTOFMEMORY;
            }

            delete[] wszDevicePath;
        }
        else if(hr == HRESULT_FROM_WIN32(ERROR_NO_MORE_ITEMS))
        {
            hr = S_FALSE;
        }
    }
    else
    {
        hr = E_OUTOFMEMORY;
    }

    return hr;
}

#define MAX_INTERSECTIONS 10

// map CLSID_VideoInputDeviceCategory to KS_CAPTURE . KS_VIDEO. return
// a null terminated array of pointers
//
HRESULT
MapAmCatToKsCat(
    REFCLSID clsidAmCat,
    const CLSID **rgpclsidKsCat)
{

    // !!! table

    // put the shortest list first since that's the one we actually
    // enumerate

    // don't add ksproxy aud renderer devices this way
    //if(clsidAmCat == CLSID_AudioRendererCategory)
    //{
    //    rgpclsidKsCat[0] = &AM_KSCATEGORY_AUDIO;
    //    rgpclsidKsCat[1] = &AM_KSCATEGORY_RENDER;
    //    rgpclsidKsCat[0] = 0;
    //}
    //else
    if(clsidAmCat == CLSID_VideoRenderer)
    {
        rgpclsidKsCat[0] = &AM_KSCATEGORY_VIDEO;
        rgpclsidKsCat[1] = &AM_KSCATEGORY_RENDER;
        rgpclsidKsCat[2] = 0;
    }
    else if(clsidAmCat == CLSID_VideoInputDeviceCategory)
    {
        rgpclsidKsCat[0] = &AM_KSCATEGORY_CAPTURE;
        rgpclsidKsCat[1] = &AM_KSCATEGORY_VIDEO;
        rgpclsidKsCat[2] = 0;
    }
    // don't add ksproxy aud capture devices this way
    //else if(clsidAmCat == CLSID_AudioInputDeviceCategory)
    //{
    //    rgpclsidKsCat[0] = &AM_KSCATEGORY_CAPTURE;
    //    rgpclsidKsCat[1] = &AM_KSCATEGORY_AUDIO;
    //    rgpclsidKsCat[0] = 0;
    //}
    else
    {
        // don't return &clsidAmCat because it's on the caller's stack
        return S_FALSE;
    }

    return S_OK;
}

HRESULT CCreateSwEnum::CreatePnpMonikers(
    CGenericList<IMoniker> *plstMoniker,
    REFCLSID clsidDeviceClass)
{

    HRESULT hr = S_OK;

    const CLSID *rgpclsidKsCat[MAX_INTERSECTIONS];
    hr = MapAmCatToKsCat(clsidDeviceClass, rgpclsidKsCat);
    if(hr != S_OK)
    {
        rgpclsidKsCat[0] = &clsidDeviceClass;
        rgpclsidKsCat[1] = 0;
        hr = S_OK;
    }

    if(SUCCEEDED(hr))
    {
        CEnumInternalState cenumState;

        for(;;)
        {
            IMoniker *pDevMon;

            hr = CreateOnePnpMoniker(
                &pDevMon,
                rgpclsidKsCat,
                &cenumState);

            if(hr == S_OK)
            {
                // keep ref count
                plstMoniker->AddTail(pDevMon);
            }
            else
            {
                // CreateOne can return S_FALSE
                if(hr == S_FALSE)
                    hr = S_OK;
                break;
            }
        }
    }

    return hr;
}

static HRESULT DoDmoEnum(REFCLSID clsidDmoCat, CGenericList<IMoniker> *plstMoniker)
{
    IEnumDMO *pEnumDmo;

    HRESULT hr = g_pDMOEnum(clsidDmoCat,
            DMO_ENUMF_INCLUDE_KEYED, // dwFlags
            0, 0,                    // input type count / array
            0, 0,                    // output type count / array
            &pEnumDmo);

    if(SUCCEEDED(hr))
    {
        CLSID clsidDmo;
        WCHAR *wszDmo;
        ULONG cFetched;

        while(pEnumDmo->Next(1, &clsidDmo, &wszDmo, &cFetched) == S_OK)
        {
            ASSERT(cFetched == 1);
            DevMon *pDevMon = new DevMon;
            if(pDevMon)
            {
                pDevMon->AddRef(); // keep refcount from hitting zero

                //char szPrefix[] = "@device:dmo:";
                WCHAR wszPrefix[] = L"@device:dmo:";
                const cchName = 2 * (CHARS_IN_GUID - 1) + NUMELMS(wszPrefix);

                WCHAR wszName[cchName];
                lstrcpyW(wszName, wszPrefix);

                EXECUTE_ASSERT(StringFromGUID2(
                    clsidDmo,
                    wszName + NUMELMS(wszPrefix) - 1, CHARS_IN_GUID) ==
                               CHARS_IN_GUID);
                EXECUTE_ASSERT(StringFromGUID2(
                    clsidDmoCat,
                    wszName + CHARS_IN_GUID - 1 + NUMELMS(wszPrefix) - 1, CHARS_IN_GUID) ==
                               CHARS_IN_GUID);
                ASSERT(lstrlenW(wszName) + 1 == cchName);

                hr = pDevMon->Init(wszName);

                if(SUCCEEDED(hr))
                {
                    if(plstMoniker->AddTail(pDevMon))
                    {
                        hr = S_OK;
                        pDevMon->AddRef();
                    }
                    else
                    {
                        hr = E_OUTOFMEMORY;
                    }
                }

                pDevMon->Release();
            }

            CoTaskMemFree(wszDmo);
        }
        pEnumDmo->Release();
    }

    return hr;
}

HRESULT CCreateSwEnum::CreateDmoMonikers(
    CGenericList<IMoniker> *plstMoniker,
    REFCLSID clsidDeviceClass)
{
    HRESULT hr = S_OK;

    if(!InitDmo()) {
        return E_FAIL;
    }

    // !!! registry lookup

    if(clsidDeviceClass == CLSID_LegacyAmFilterCategory)
    {
        hr = DoDmoEnum(DMOCATEGORY_AUDIO_DECODER, plstMoniker);
        //ignore error
        hr = DoDmoEnum(DMOCATEGORY_VIDEO_DECODER, plstMoniker);
    }
    else if(clsidDeviceClass == CLSID_VideoCompressorCategory)
    {
        hr = DoDmoEnum(DMOCATEGORY_VIDEO_ENCODER, plstMoniker);
    }
    else if(clsidDeviceClass == CLSID_AudioCompressorCategory)
    {
        hr = DoDmoEnum(DMOCATEGORY_AUDIO_ENCODER, plstMoniker);
    }
    else
    {
        // treat the class as a dmo category and enumerate it directly
        hr = DoDmoEnum(clsidDeviceClass, plstMoniker);
    }
    return hr;
}

ICreateDevEnum * CCreateSwEnum::CreateClassManager(
    REFCLSID clsidDeviceClass,
    DWORD dwFlags)
{
    ICreateDevEnum *pClassManager = NULL;
    if ((dwFlags & CDEF_BYPASS_CLASS_MANAGER) == 0) {
        {
            HRESULT hr = CoCreateInstance(clsidDeviceClass, NULL, CLSCTX_INPROC_SERVER,
                                          IID_ICreateDevEnum, (void **) &pClassManager);
            if(FAILED(hr))
            {
                pClassManager = NULL;
            }
        }
    }
    return pClassManager;
}

bool InitDmo()
{
    extern CRITICAL_SECTION g_devenum_cs;
    EnterCriticalSection(&g_devenum_cs);
    if(g_pDMOEnum == 0)
    {
        // note we leak msdmo.dll
        HINSTANCE h = LoadLibrary(TEXT("msdmo.dll"));
        if(h != 0)
        {
            g_pDMOEnum = (PDMOEnum)GetProcAddress(h, "DMOEnum");

            extern PDMOGetTypes g_pDMOGetTypes;
            extern PDMOGetName g_pDMOGetName;
            g_pDMOGetTypes = (PDMOGetTypes)GetProcAddress(h, "DMOGetTypes");
            g_pDMOGetName = (PDMOGetName)GetProcAddress(h, "DMOGetName");

            // probably not a valid assertion.
            ASSERT(g_pDMOGetName && g_pDMOGetTypes && g_pDMOEnum);
        }
    }

    if(g_pDMOEnum == 0)
    {
        // only valid failure would be out of memory failures.
        DbgBreak("msdmo.dll should be installed");

        // hack to cache failures.
        g_pDMOEnum = (PDMOEnum)1;
    }

    bool fRet = true;
    if(g_pDMOEnum == 0 || g_pDMOEnum == (PDMOEnum)1) {
        fRet = false;
    }
    LeaveCriticalSection(&g_devenum_cs);

    return fRet;
}
=== C:/Users/treeman/Desktop/windows nt source code\Source\Win2K3\NT\multimedia\dshow\filterus\pnp\devenum\qzfilter.cpp ===
// Copyright (c) 1997 - 1999  Microsoft Corporation.  All Rights Reserved.
#include "stdafx.h"
#include "qzfilter.h"
#include "util.h"

#ifdef DEBUG
static void DbgValidateHeaps()
{
  HANDLE rgh[512];
  DWORD dwcHeaps = GetProcessHeaps(512, rgh);
  for(UINT i = 0; i < dwcHeaps; i++)
    ASSERT(HeapValidate(rgh[i], 0, 0) );
}
#else
static inline void DbgValidateHeaps()
{
}
#endif




const TCHAR g_szQzfDriverIndex[] = TEXT("ClassManagerFlags");
static const WCHAR g_wszQzfDriverIndex[] = L"ClassManagerFlags";

static const TCHAR g_szFiltersReg[] = TEXT("Filter");

CQzFilterClassManager::CQzFilterClassManager() :
        CClassManagerBase(TEXT("CLSID")),
        m_rgFilters(0)
{
}

CQzFilterClassManager::~CQzFilterClassManager()
{
    delete[] m_rgFilters;
}

// to reduce registry access, don't read filter names if fReadNames is
// false.
HRESULT CQzFilterClassManager::ReadLegacyDevNames(BOOL fReadNames)
{
    HRESULT hr = S_OK;
    BOOL bAnyLegacy = FALSE;
    m_cNotMatched = 0;
    m_cFilters = 0;

    // can't use quartz mapper because it'll use us
    HKEY hkFilter;
    LONG lResult = RegOpenKeyEx(
        HKEY_CLASSES_ROOT, g_szFiltersReg, 0, KEY_READ, &hkFilter);
    if(lResult == ERROR_SUCCESS)
    {
        DWORD cEntries;
        LONG lResult = RegQueryInfoKey(hkFilter, 0, 0, 0, &cEntries, 0, 0, 0, 0, 0, 0, 0);
        if(lResult == ERROR_SUCCESS)
        {
            delete[] m_rgFilters;
            m_rgFilters = new LegacyFilter[cEntries];
            if(m_rgFilters)
            {
                for(UINT iRegEntry = 0; iRegEntry < cEntries; iRegEntry++)
                {
                    LegacyFilter *pLf = &m_rgFilters[m_cFilters];

                    LONG lResult = RegEnumKey(
                        hkFilter, iRegEntry, pLf->szClsid, NUMELMS(pLf->szClsid));

                    if(lResult == ERROR_SUCCESS)
                    {
                        if(IsInvisibleInstanceKey(pLf->szClsid))
                        {
                            DbgLog((
                                LOG_TRACE, 10,
                                TEXT("CQzFilterClassManager: ReadLegacyDevNames: Skipping %s"),
                                pLf->szClsid));

                            continue;
                        }

                        // don't want the class manager to override
                        // anything registered directly
                        if(!IsNativeInInstanceKey(pLf->szClsid))
                        {
                            DbgLog((
                                LOG_TRACE, 10,
                                TEXT("CQzFilterClassManager: ReadLegacyDevNames: %s"),
                                pLf->szClsid));

                            bAnyLegacy = TRUE;
                            pLf->bNotMatched = TRUE;
                            ASSERT(pLf->szName == 0);

                            // see if this filter really exists in the
                            // CLSID\XXX. otherwise the filter
                            // migration code fails and the registry
                            // is perpetually out of sync. this
                            // doesn't fix all failures migrating
                            // registry keys.
                            //
                            HKEY hkPerhapsBogus = NULL;
                            TCHAR FilterCLSID[_MAX_PATH];
                            lstrcpy( FilterCLSID, TEXT("CLSID\\"));
                            lstrcat( FilterCLSID, pLf->szClsid );
                            LONG llll = RegOpenKeyEx( HKEY_CLASSES_ROOT, FilterCLSID, 0, KEY_READ, &hkPerhapsBogus );
                            if( llll != ERROR_SUCCESS )
                            {
                                DbgLog((
                                    LOG_TRACE, 10,
                                    TEXT("CQzFilterClassManager: ReadLegacyDevNames: could not read %s"), FilterCLSID ));
                                continue;
                            }
                            else
                            {
                                RegCloseKey( hkPerhapsBogus );
                            }

                            if(fReadNames)
                            {

                                HKEY hkEntry;
                                LONG lResult = RegOpenKeyEx(
                                    hkFilter, pLf->szClsid, 0,
                                    KEY_READ, &hkEntry);
                                if(lResult == ERROR_SUCCESS)
                                {
                                    TCHAR szName[MAX_PATH];
                                    DWORD dwType, dwcbRead = sizeof(szName);

                                    LONG lResult = RegQueryValueEx(
                                        hkEntry, 0, 0,
                                        &dwType, (BYTE *)szName, &dwcbRead);
                                    if(lResult == ERROR_SUCCESS)
                                    {
                                        pLf->szName = new TCHAR[dwcbRead];
                                        if(pLf->szName)
                                            lstrcpy(pLf->szName, szName);
                                        DbgLog((
                                            LOG_TRACE, 10,
                                            TEXT("CQzFilterClassManager: ReadLegacyDevNames: %s"),
                                            szName));
                                    }
                                    RegCloseKey(hkEntry);
                                }
                            } // fReadNames

                            m_cFilters++;
                        } // native
                        else
                        {
                            DbgLog((LOG_TRACE, 5,
                                    TEXT("CQzFilterClassManager: skipping native %s"),
                                    pLf->szClsid));
                        }
                    }
                    else
                    {
                        break;
                    }
                } // for
            }
            else
            {
                hr = E_OUTOFMEMORY;
            }
        }

        RegCloseKey(hkFilter);
    }

    m_cNotMatched = m_cFilters;

    return bAnyLegacy ? S_OK : S_FALSE;
}

// called by the base class
HRESULT CQzFilterClassManager::ReadLegacyDevNames()
{
    // don't read filter names
    return ReadLegacyDevNames(FALSE);
}


BOOL CQzFilterClassManager::MatchString(const TCHAR *szDevName)
{
    for(UINT iFilter = 0; iFilter < m_cFilters; iFilter++)
    {
        if(m_rgFilters[iFilter].bNotMatched &&
           lstrcmpi(m_rgFilters[iFilter].szClsid, szDevName) == 0)
        {
            m_rgFilters[iFilter].bNotMatched = FALSE;
            return TRUE;
        }
    }
    return FALSE;
}

HRESULT CQzFilterClassManager::CreateRegKeys(IFilterMapper2 *pFm2)
{
    ResetClassManagerKey(CLSID_LegacyAmFilterCategory);

    USES_CONVERSION;

    // do read filter names
    HRESULT hr = ReadLegacyDevNames(TRUE);
    if(hr == S_OK)
    {
        for(UINT iFilter = 0; iFilter < m_cFilters; iFilter++)
        {
            IMoniker *pMoniker = 0;
            LegacyFilter *pLf = &m_rgFilters[iFilter];
            hr = MigrateFilter(pFm2, pLf->szClsid, &pMoniker);
            if(SUCCEEDED(hr))
            {
                // write out class manager key so that we can tell
                // whether this filter was migrated or not.
                IPropertyBag *pPropBag;
                hr = pMoniker->BindToStorage(
                    0, 0, IID_IPropertyBag, (void **)&pPropBag);
                if(SUCCEEDED(hr))
                {
                    VARIANT var;
                    var.vt = VT_I4;
                    var.lVal = 0;
                    hr = pPropBag->Write(g_wszQzfDriverIndex, &var);

                    pPropBag->Release();
                }
                pMoniker->Release();
            }
        }
    }

    return S_OK;
}


#define MAX_STR_LEN 256

//
// Copy the filter info from hkcr/{filter_clsid} to the new data block
// value
//

HRESULT CQzFilterClassManager::MigrateFilter(
    IFilterMapper2 *pFm2,
    const TCHAR *szclsid,
    IMoniker **ppMoniker)
{
    HRESULT hr = S_OK;
    USES_CONVERSION;

    TCHAR szFilterName[MAX_PATH];
    CRegFilterPin *rgRfp = 0;
    ULONG cPins = 0;

    TCHAR szTmp[MAX_PATH];
    lstrcpy(szTmp, TEXT("clsid\\"));
    lstrcat(szTmp, szclsid);

    CRegKey rkFilter;

    LONG lResult = rkFilter.Open(HKEY_CLASSES_ROOT, szTmp, KEY_READ);
    if(lResult == ERROR_SUCCESS)
    {

        // default to MERIT_NORMAL for compatibility with 1.0
        DWORD dwMerit = MERIT_NORMAL;
        rkFilter.QueryValue(dwMerit, TEXT("Merit"));

        // filter name (default to clsid string)
        DWORD dwcbszFilterName = sizeof(szFilterName);
        if(rkFilter.QueryValue(szFilterName, TEXT(""), &dwcbszFilterName) != ERROR_SUCCESS)
            lstrcpy(szFilterName, szclsid);

        CRegKey rkPins;
        if(rkPins.Open(rkFilter, TEXT("pins"), KEY_READ) == ERROR_SUCCESS)
        {
            lResult = RegQueryInfoKey(rkPins, 0, 0, 0, &cPins, 0, 0, 0, 0, 0, 0, 0);
            if(lResult == ERROR_SUCCESS)
            {
                rgRfp = new CRegFilterPin[cPins];
                if(rgRfp)
                {
                    lResult = MigrateFilterPins(cPins, rgRfp, rkPins);
                }
                else
                {
                    lResult = ERROR_NOT_ENOUGH_MEMORY;
                }
            }
        }


        CLSID clsidFilter;
        if(lResult == ERROR_SUCCESS &&
           ((hr = CLSIDFromString((WCHAR *) T2CW(szclsid), &clsidFilter)) == S_OK))
        {

            REGFILTER2 rf2;
            rf2.dwVersion = 1;
            rf2.dwMerit = dwMerit;
            rf2.cPins = cPins;
            rf2.rgPins = rgRfp;

            *ppMoniker = 0; // 0 means return a moniker
            hr = RegisterClassManagerFilter(
                pFm2,
                clsidFilter,
                T2CW(szFilterName),
                ppMoniker,
                &CLSID_LegacyAmFilterCategory,
                NULL, // instance key
                &rf2);

            DbgLog((
                LOG_TRACE, 10,
                TEXT("CQzFilterClassManager::MigrateFilter: %08x, %s, ")
                TEXT("merit %08x, cPins %d"),
                clsidFilter.Data1, szFilterName, dwMerit, cPins));
        }

        delete[] rgRfp;
    }
    else
    {
        DbgLog((
            LOG_TRACE, 10,
            TEXT("CQzFilterClassManager::MigrateFilter failed to open key %s"),
            szTmp
            ));
    }

    return (lResult == ERROR_SUCCESS) ? hr :  HRESULT_FROM_WIN32(lResult);;
}

LONG CQzFilterClassManager::MigrateFilterPins(
    ULONG cPins, REGFILTERPINS *rgRfp, CRegKey &rkPins)
{
    USES_CONVERSION;
    LONG lResult = ERROR_SUCCESS;

    for(UINT iPin = 0; iPin < cPins; iPin++)
    {
        REGFILTERPINS *pRfp = &rgRfp[iPin];
        TCHAR strPin[MAX_STR_LEN];     // name of pin
        DWORD dwLen = NUMELMS(strPin);

        lResult = RegEnumKeyEx(rkPins, iPin, strPin, &dwLen, 0, 0, 0, 0);
        if(lResult == ERROR_SUCCESS)
        {
            // do one pin

            CRegKey rkPin;
            lResult = rkPin.Open(rkPins, strPin, KEY_READ);
            if(lResult == ERROR_SUCCESS)
            {
                // do the flags
                DWORD dwRenderered = 0, dwOutput = 0, dwZero = 0, dwMany = 0;
                rkPin.QueryValue(dwRenderered, TEXT("IsRendered"));
                rkPin.QueryValue(dwOutput, TEXT("Direction"));
                rkPin.QueryValue(dwZero, TEXT("AllowedZero"));
                rkPin.QueryValue(dwMany, TEXT("AllowedMany"));
                // ignore errors (except direction?)

                pRfp->bRendered = dwRenderered;
                pRfp->bOutput = dwOutput; // 0 is input
                pRfp->bZero = dwZero;
                pRfp->bMany = dwMany;

                pRfp->strConnectsToPin = 0;
                TCHAR szConnectsTo[MAX_STR_LEN];
                ULONG cb = sizeof(szConnectsTo);
                if(rkPin.QueryValue(szConnectsTo, TEXT("ConnectsToPin"), &cb) == ERROR_SUCCESS)
                {
                    pRfp->strConnectsToPin = new WCHAR[lstrlen(szConnectsTo) + 1];
                    if(pRfp->strConnectsToPin)
                    {
                        lstrcpyW((WCHAR *)(pRfp->strConnectsToPin), T2W(szConnectsTo));
                    }
                    else
                    {
                        lResult = ERROR_OUTOFMEMORY;
                    }
                }
            }

            if(lResult == ERROR_SUCCESS)
            {
                pRfp->clsConnectsToFilter = new GUID;
                if(pRfp->clsConnectsToFilter)
                {
                    TCHAR szConnectsTo[CHARS_IN_GUID];
                    ULONG cb = sizeof(szConnectsTo);

                    *(GUID *)pRfp->clsConnectsToFilter = GUID_NULL;
                    if(rkPin.QueryValue(szConnectsTo, TEXT("ConnectsToFilter"), &cb) == ERROR_SUCCESS)
                    {
                        CLSIDFromString(T2W(szConnectsTo), (GUID *)pRfp->clsConnectsToFilter);
                    }
                }
                else
                {
                    lResult = E_OUTOFMEMORY;
                }
            }

            if(lResult == ERROR_SUCCESS)
            {
                pRfp->strName = new WCHAR[lstrlen(strPin) + 1];
                if(pRfp->strName)
                {
                    lstrcpyW(pRfp->strName, T2W(strPin));
                }
                else
                {
                    lResult = ERROR_OUTOFMEMORY;
                }
            }

            if(lResult == ERROR_SUCCESS)
            {
                ULONG cTypes;
                REGPINTYPES *rgrpt;
                lResult = MigratePinTypes(rkPin, &rgrpt, &cTypes);
                if(lResult == ERROR_SUCCESS)
                {
                    pRfp->lpMediaType = rgrpt;
                    pRfp->nMediaTypes = cTypes;
                }
            }

            DbgLog((
                LOG_TRACE, 10,
                TEXT("CQzFilterClassManager::MigrateFilterPins: strName: %s, ")
		TEXT("bRendered: %d, bOutput: %d, bZero: %d, bMany: %d, ")
		TEXT("clsConnectsToFilter: %08x, strConnectsToPin: %S, nMediaTypes: %d"),
                pRfp->strName, pRfp->bRendered, pRfp->bOutput, pRfp->bZero, pRfp->bMany,
                pRfp->clsConnectsToFilter->Data1,
                pRfp->strConnectsToPin ? pRfp->strConnectsToPin : L"",
                pRfp->nMediaTypes));
        }

        if(lResult != ERROR_SUCCESS)
        {
            break;
        }
    } // for

    return lResult;
}

LONG CQzFilterClassManager::MigratePinTypes(CRegKey &rkPin, REGPINTYPES **prgrpt, ULONG *pct)
{
    const ULONG MAX_MINOR_TYPES = 100;
    REGPINTYPES *rgRpt = 0;
    ULONG iMediaType = 0; // maj-min pair index
    LONG lResult = ERROR_SUCCESS;
    USES_CONVERSION;

    CRegKey rkTypes;
    if(ERROR_SUCCESS == rkTypes.Open(rkPin, TEXT("Types"), KEY_READ))
    {
        ULONG cMajorTypes;
        lResult = RegQueryInfoKey(rkTypes, 0, 0, 0, &cMajorTypes, 0, 0, 0, 0, 0, 0, 0);
        if(lResult == ERROR_SUCCESS)
        {
            // assume a max of 100 minor types per major type.
            rgRpt = new REGPINTYPES[cMajorTypes * MAX_MINOR_TYPES];
            if(rgRpt)
            {
                ZeroMemory(rgRpt, sizeof(REGPINTYPES) * cMajorTypes * MAX_MINOR_TYPES);

                for(UINT iMajorType = 0; iMajorType < cMajorTypes; iMajorType++)
                {
                    TCHAR szClsidMajor[CHARS_IN_GUID];
                    DWORD dwLen = sizeof(szClsidMajor) / sizeof(TCHAR);
                    lResult = RegEnumKeyEx(rkTypes, iMajorType, szClsidMajor, &dwLen, 0, 0, 0, 0);
                    if(lResult == ERROR_SUCCESS)
                    {
                        CLSID clsMajor;
                        if(CLSIDFromString(T2W(szClsidMajor), &clsMajor) == S_OK)
                        {
                            CRegKey rkMajorType;
                            lResult = rkMajorType.Open(rkTypes, szClsidMajor, KEY_READ);
                            if(lResult == ERROR_SUCCESS)
                            {
                                for(ULONG iMinorType = 0; iMinorType < MAX_MINOR_TYPES; iMinorType++)
                                {
                                    TCHAR szClsidMinor[CHARS_IN_GUID];
                                    DWORD dwLen = sizeof(szClsidMinor) / sizeof(TCHAR);

                                    lResult = RegEnumKeyEx(rkMajorType, iMinorType, szClsidMinor, &dwLen, 0, 0, 0, 0);
                                    if(lResult == ERROR_SUCCESS)
                                    {
                                        CLSID clsMinor;
                                        if(CLSIDFromString(T2W(szClsidMinor), &clsMinor) == S_OK)
                                        {
                                            rgRpt[iMediaType].clsMajorType = new CLSID;
                                            rgRpt[iMediaType].clsMinorType = new CLSID;
                                            if(rgRpt[iMediaType].clsMajorType && rgRpt[iMediaType].clsMinorType)
                                            {
                                                *(GUID *)rgRpt[iMediaType].clsMajorType = clsMajor;
                                                *(GUID *)rgRpt[iMediaType].clsMinorType = clsMinor;
                                                iMediaType++;

                                                DbgLog((
                                                    LOG_TRACE, 10,
                                                    TEXT("CQzFilterClassManager::MigratePinTypes:")
						    TEXT("clsMaj: %08x, clsMin: %08x"),
                                                         clsMajor.Data1, clsMinor.Data1));
                                            }
                                            else
                                            {
                                                lResult = ERROR_OUTOFMEMORY;
                                            }
                                        }
                                        else
                                        {
                                            lResult = ERROR_INVALID_DATA;
                                        }
                                    }
                                    else
                                    {
                                        if(lResult == ERROR_NO_MORE_ITEMS)
                                        {
                                            lResult = ERROR_SUCCESS;
                                            break;
                                        }
                                    }


                                    if(lResult != ERROR_SUCCESS)
                                        break;
                                } // for
                            }
                        }
                        else
                        {
                            lResult = ERROR_INVALID_DATA;
                        }
                    }

                    if(lResult != ERROR_SUCCESS)
                        break;
                } // for loop
            }
            else
            {
                lResult = ERROR_OUTOFMEMORY;
            }
        }
    }

    if(lResult != ERROR_SUCCESS)
    {
        Del(rgRpt, iMediaType);
        rgRpt = 0;
        iMediaType = 0;

        // more useful errors: missing key means the registry isn't what
        // we expect
        if(lResult == ERROR_FILE_NOT_FOUND)
            lResult = ERROR_INVALID_DATA;
    }

    *prgrpt = rgRpt;
    *pct = iMediaType;

    return lResult;
}

void CQzFilterClassManager::Del(REGPINTYPES *rgRpt, ULONG cMediaTypes)
{
    if(rgRpt)
    {
        do
        {
            delete (void *) rgRpt[cMediaTypes].clsMajorType;
            delete (void *) rgRpt[cMediaTypes].clsMinorType;
        } while(cMediaTypes--);

        delete[] rgRpt;
    }
}

CRegFilterPin::CRegFilterPin()
{
    clsConnectsToFilter = 0;
    strConnectsToPin = 0;
    lpMediaType = 0;
    strName = 0;
    nMediaTypes = 0;
}

CRegFilterPin::~CRegFilterPin()
{
    delete (CLSID *)clsConnectsToFilter;
    delete[] (LPWSTR)strConnectsToPin;
    for(UINT iMt = 0; iMt < nMediaTypes; iMt++)
    {
        delete (CLSID *)lpMediaType[iMt].clsMinorType;
        delete (CLSID *)lpMediaType[iMt].clsMajorType;
    }

    delete[] (REGPINTYPES *)lpMediaType;
    delete[] (WCHAR *)strName;
}

// check if filter szClsid is a filter which we wish to mask and not enumerate
bool CQzFilterClassManager::IsInvisibleInstanceKey(const TCHAR *szClsid)
{
    bool fRet = false;
    USES_CONVERSION;   // atl string cvt

    CLSID clsidInstanceKey;
    if(CLSIDFromString((WCHAR *) T2CW(szClsid), &clsidInstanceKey) == S_OK)
    {
        fRet = clsidInstanceKey == CLSID_AVIMIDIRender ||
            clsidInstanceKey == CLSID_DSoundRender ||
            clsidInstanceKey == CLSID_AudioRender;
    }

    return fRet;
}

// check if filter szClsid registered directly in instance key
//
bool CQzFilterClassManager::IsNativeInInstanceKey(const TCHAR *szClsid)
{
    // check if CLSID\\{083*}\\Instance\\szClsid and ClassManagerFlags
    // value exist. !!! should use a moniker

    static const TCHAR szQzFilterClassRoot[] = TEXT(
     "CLSID\\{083863F1-70DE-11d0-BD40-00A0C911CE86}\\Instance");

    bool fResult = false;

    TCHAR szKey[MAX_PATH];
    // wsprintf("%s\\%s", szQzFilterClassRoot, szClsid)
    CopyMemory(szKey, szQzFilterClassRoot, sizeof(szQzFilterClassRoot) - sizeof(TCHAR));
    TCHAR *pch = szKey + NUMELMS(szQzFilterClassRoot) - 1;
    *(pch++) = TEXT('\\');
    CopyMemory(pch, szClsid, CHARS_IN_GUID * sizeof(TCHAR));

    HKEY hkInst;
    if(RegOpenKeyEx(HKEY_CLASSES_ROOT, szKey, 0, KEY_READ, &hkInst) == ERROR_SUCCESS)
    {
        if(RegQueryValueEx(
            hkInst,
            g_szQzfDriverIndex,
            0,                  // reserved
            0,                  // type
            0,                  // data
            0) !=               // byte count
           ERROR_SUCCESS)
        {
            fResult = true;
        }
        RegCloseKey(hkInst);
    }

    return fResult;
}
=== C:/Users/treeman/Desktop/windows nt source code\Source\Win2K3\NT\multimedia\dshow\filterus\pnp\devenum\resource.h ===
// Copyright (c) 1997 - 1998  Microsoft Corporation.  All Rights Reserved.
//{{NO_DEPENDENCIES}}
// Microsoft Developer Studio generated include file.
// Used by devenum.rc
//
#define IDS_DEVICEMONIKER_DESC          6
#define IDS_DSOUNDDEFAULTDEVICE         7
#define IDS_DSOUNDPREFIX                8
#define IDS_WAVEOUTMAPPER               9
#define IDS_MIDIOUTMAPPER               10
#define IDS_KSMAPPER                    11
#define IDS_KSPREFIX                    12
#define IDR_REGISTRY                    202
#define IDR_REGISTRY_X86                203
=== C:/Users/treeman/Desktop/windows nt source code\Source\Win2K3\NT\multimedia\dshow\filterus\pnp\devenum\stdafx.cpp ===
// Copyright (c) 1997 - 1998  Microsoft Corporation.  All Rights Reserved.
// stdafx.cpp : source file that includes just the standard includes
//  stdafx.pch will be the pre-compiled header
//  stdafx.obj will contain the pre-compiled type information

#include "stdafx.h"

#ifdef _ATL_STATIC_REGISTRY
#include <statreg.h>
#include <statreg.cpp>
#endif // _ATL_STATIC_REGISTRY

#include <atlimpl.cpp>
=== C:/Users/treeman/Desktop/windows nt source code\Source\Win2K3\NT\multimedia\dshow\filterus\pnp\devenum\util.cpp ===
// Copyright (c) 1997  Microsoft Corporation.  All Rights Reserved.
#include <Streams.h>
#include "stdafx.h"

// // copied from msdn
// DWORD RegDeleteTree(HKEY hStartKey , const TCHAR* pKeyName )
// {
//     DWORD   dwRtn, dwSubKeyLength;
//     LPTSTR  pSubKey = NULL;
//     TCHAR   szSubKey[MAX_PATH]; // (256) this should be dynamic.
//     HKEY    hKey;

//     // do not allow NULL or empty key name
//     if ( pKeyName &&  lstrlen(pKeyName))
//     {
//         if( (dwRtn=RegOpenKeyEx(hStartKey,pKeyName,
//                                 0, KEY_ENUMERATE_SUB_KEYS | DELETE, &hKey )) == ERROR_SUCCESS)
//         {
//             while (dwRtn == ERROR_SUCCESS )
//             {
//                 dwSubKeyLength = MAX_PATH;
//                 dwRtn=RegEnumKeyEx(
//                     hKey,
//                     0,       // always index zero
//                     szSubKey,
//                     &dwSubKeyLength,
//                     NULL,
//                     NULL,
//                     NULL,
//                     NULL
//                     );

//                 if(dwRtn == ERROR_NO_MORE_ITEMS)
//                 {
//                     dwRtn = RegDeleteKey(hStartKey, pKeyName);
//                     break;
//                 }
//                 else if(dwRtn == ERROR_SUCCESS)
//                     dwRtn=RegDeleteTree(hKey, szSubKey);
//             }
//             RegCloseKey(hKey);
//             // Do not save return code because error
//             // has already occurred
//         }
//     }
//     else
//         dwRtn = ERROR_BADKEY;

//     return dwRtn;


// }

DWORD RegDeleteTree(HKEY hStartKey , const TCHAR* pKeyName )
{
  CRegKey key;
  key.Attach(hStartKey);
  LONG lResult = key.RecurseDeleteKey(pKeyName);
  key.Detach();
  return lResult;
}

#include <initguid.h>
DEFINE_GUID(IID_IConnectionPointContainer,
	0xB196B284,0xBAB4,0x101A,0xB6,0x9C,0x00,0xAA,0x00,0x34,0x1D,0x07);
DEFINE_GUID(IID_IEnumConnectionPoints,
	0xB196B285,0xBAB4,0x101A,0xB6,0x9C,0x00,0xAA,0x00,0x34,0x1D,0x07);
=== C:/Users/treeman/Desktop/windows nt source code\Source\Win2K3\NT\multimedia\dshow\filterus\pnp\devenum\qzfilter.h ===
// Copyright (c) 1997  Microsoft Corporation.  All Rights Reserved.
#include "resource.h"
#include "cmgrbase.h"
#include "util.h"

class CQzFilterClassManager :
    public CClassManagerBase,
    public CComObjectRoot,
    public CComCoClass<CQzFilterClassManager,&CLSID_CQzFilterClassManager>
{
    // legacy meaning doesn't support IPersistRegKey.
    struct LegacyFilter
    {
        LegacyFilter() { szName = 0; }
        ~LegacyFilter() { delete[] szName;}
        TCHAR szClsid[CCH_CLSID];
        TCHAR *szName;
        BOOL bNotMatched;
    } *m_rgFilters;

    ULONG m_cFilters;

    bool IsNativeInInstanceKey(const TCHAR *szClsid);
	bool IsInvisibleInstanceKey(const TCHAR *szClsid);

public:

    CQzFilterClassManager();
    ~CQzFilterClassManager();

    BEGIN_COM_MAP(CQzFilterClassManager)
	COM_INTERFACE_ENTRY2(IDispatch, ICreateDevEnum)
	COM_INTERFACE_ENTRY(ICreateDevEnum)
    END_COM_MAP();

    DECLARE_NOT_AGGREGATABLE(CQzFilterClassManager);
    DECLARE_NO_REGISTRY();
    
    HRESULT ReadLegacyDevNames();
    HRESULT ReadLegacyDevNames(BOOL fReadNames);

    BOOL MatchString(const TCHAR *szDevName);
    HRESULT CreateRegKeys(IFilterMapper2 *pFm2);

    HRESULT MigrateFilter(IFilterMapper2 *pFm2, const TCHAR *szclsid, IMoniker **ppMoniker);
    LONG MigrateFilterPins(ULONG cPins, REGFILTERPINS *rgRfp, CRegKey &rkPins);
    LONG MigratePinTypes(CRegKey &rkPin, REGPINTYPES **prgrpt, ULONG *pct);
    void Del(REGPINTYPES *rgRpt, ULONG cMediaTypes);
};

class CRegFilterPin : public REGFILTERPINS
{
public:
    CRegFilterPin();
    ~CRegFilterPin();
};
=== C:/Users/treeman/Desktop/windows nt source code\Source\Win2K3\NT\multimedia\dshow\filterus\pnp\devenum\stdafx.h ===
// Copyright (c) 1997 - 1999  Microsoft Corporation.  All Rights Reserved.
// stdafx.h : include file for standard system include files,
//      or project specific include files that are used frequently,
//      but are changed infrequently

#ifndef _WIN32_WINNT
#define _WIN32_WINNT 0x0400
#endif

// only devmon needs to be free threaded, but it's difficult to mix
// them with this precompiled header.
#define _ATL_FREE_THREADED

// // adds 5k. otherwise we need register.dll. also need statreg.h
#ifndef _ATL_STATIC_REGISTRY
#define _ATL_STATIC_REGISTRY
#endif


#ifndef _USRDLL
#define _USRDLL
#endif
#include <atlbase.h>
extern CComModule _Module;
#include <atlcom.h>

extern CComModule _Module;

#include <streams.h>
#include <atlconv.h>

//#define PERFZ

#ifdef PERFZ
#define PNP_PERF(x) x
#else
#define PNP_PERF(x)
#endif

// this value is set in the property bag if this is the default device.
extern const WCHAR g_wszClassManagerFlags[];


extern const TCHAR g_szVidcapDriverIndex [];
extern const TCHAR g_szQzfDriverIndex    [];
extern const TCHAR g_szIcmDriverIndex    [];
extern const TCHAR g_szAcmDriverIndex    [];
extern const TCHAR g_szWaveoutDriverIndex[];
extern const TCHAR g_szDsoundDriverIndex [];
extern const TCHAR g_szWaveinDriverIndex [];
extern const TCHAR g_szMidiOutDriverIndex[];
=== C:/Users/treeman/Desktop/windows nt source code\Source\Win2K3\NT\multimedia\dshow\filterus\pnp\devenum\util.h ===
// Copyright (c) 1997 - 1999  Microsoft Corporation.  All Rights Reserved.

#ifndef _DEVENUM_UTIL_H
#define _DEVENUM_UTIL_H


DWORD RegDeleteTree(HKEY hStartKey , const TCHAR* pKeyName );

// where in the registry do we find the class manager stuff?
// filterus\dexter\dxt\dxtenum looks at this too
static const HKEY g_hkCmReg = HKEY_CURRENT_USER;
static TCHAR g_szCmRegPath[] = TEXT("Software\\Microsoft\\ActiveMovie\\devenum");

static const CCH_CLSID = 39;        // {xxxxxxxx-xxxx-xxxx-xxxx-xxxxxxxxxxxx}\0

// class manager flags (goes in the registry)
static const CLASS_MGR_OMIT = 0x1;
static const CLASS_MGR_DEFAULT = 0x2;

#define DEVENUM_VERSION (6)
#define G_SZ_DEVENUM_VERSION (TEXT("Version"))
#define G_SZ_DEVENUM_PATH (TEXT("CLSID\\{62BE5D10-60EB-11d0-BD3B-00A0C911CE86}"))

#endif // _DEVENUM_UTIL_H
=== C:/Users/treeman/Desktop/windows nt source code\Source\Win2K3\NT\multimedia\dshow\filterus\pnp\devenum\vidcap.cpp ===
// Copyright (c) 1997 - 1999  Microsoft Corporation.  All Rights Reserved.
#include "stdafx.h"
#include "vidcap.h"
#include <vfw.h>
#include "util.h"

static const TCHAR g_szDriverClsid[] = TEXT("CLSID"); // !!!
static const WCHAR g_wszVidcapDriverIndex[] = L"VFWIndex";
const TCHAR g_szVidcapDriverIndex[] = TEXT("VFWIndex");

// !!! get this from Quartz?
static const TCHAR g_szClsidVfwFilter[] = TEXT("{1b544c22-fd0b-11ce-8c63-00aa0044b51e}");

#ifdef WIN64
#error build error -- this is x86 only
#endif

CVidCapClassManager::CVidCapClassManager() :
        CClassManagerBase(TEXT("FriendlyName")),
        m_hmodAvicap32(0)
{
}

CVidCapClassManager::~CVidCapClassManager()
{
    if(m_hmodAvicap32)
    {
        FreeLibrary(m_hmodAvicap32);
    }
}

HRESULT CVidCapClassManager::ReadLegacyDevNames()
{

#ifdef UNICODE
    static const char sz_capGetDriverDescription[] = "capGetDriverDescriptionW";
#else
    static const char sz_capGetDriverDescription[] = "capGetDriverDescriptionA";
#endif

    if(m_hmodAvicap32 == 0)
    {
        if(m_hmodAvicap32 = LoadLibrary(TEXT("avicap32.dll")))
        {
            m_capGetDriverDescription = (PcapGetDriverDescription)
                GetProcAddress(m_hmodAvicap32, sz_capGetDriverDescription);
            if(m_capGetDriverDescription == 0)
            {
                DWORD dwLastError = GetLastError();
                FreeLibrary(m_hmodAvicap32);
                m_hmodAvicap32 = 0;
                return HRESULT_FROM_WIN32(dwLastError);
            }
        }
        else
        {
            DWORD dwLastError = GetLastError();
            return HRESULT_FROM_WIN32(dwLastError);
        }
    }
    
    BOOL bAnyLegacy = FALSE;
    m_cNotMatched = 0;

#ifdef DEBUG
    DWORD dw;
    CRegKey rkSkipMapper;
    const bool fSkipMapper = !
        (rkSkipMapper.Open(g_hkCmReg, g_szCmRegPath) == ERROR_SUCCESS &&
         rkSkipMapper.QueryValue(dw, TEXT("EnumerateMappedDevices")) == ERROR_SUCCESS &&
         dw);
#else
    const bool fSkipMapper = true;
#endif
    
    for(int i = 0; i < NUM_LEGACY_DEVICES; i++)
    {
        m_rgLegacyCap[i].bNotMatched = FALSE;
        if(m_capGetDriverDescription(
            i,
            m_rgLegacyCap[i].szName, g_cchCapName,
            m_rgLegacyCap[i].szDesc, g_cchCapDesc))
        {
            // unlocalizable hack to skip the VFW capture mapper !!!
            // Just check the beginning of the string. There may be a
            // (win32) on the end of the nt version.
            static const TCHAR szMapper[] = TEXT("Microsoft WDM Image Capture");

            // make sure the string we're comparing is smaller than we
            // allocated 
            ASSERT(sizeof(m_rgLegacyCap[i].szName) >= sizeof(szMapper));
            
            if((fSkipMapper &&
                memcmp(m_rgLegacyCap[i].szName, szMapper, sizeof(szMapper) - sizeof(TCHAR)) != 0) ||
               !fSkipMapper)
            {
                m_rgLegacyCap[i].bNotMatched = bAnyLegacy = TRUE;
                m_cNotMatched++;
            }
        }
    }

    return bAnyLegacy ? S_OK : S_FALSE;
}

BOOL CVidCapClassManager::MatchString(IPropertyBag *pPropBag)
{
    USES_CONVERSION;

    VARIANT varName, varId;
    varName.vt = VT_EMPTY;
    varId.vt = VT_EMPTY;

    bool fRet = false;

    HRESULT hr = pPropBag->Read(g_wszVidcapDriverIndex, &varId, 0);
    if(SUCCEEDED(hr))
    {
        ASSERT(varId.vt == VT_I4);
        hr = pPropBag->Read(T2COLE(m_szUniqueName), &varName, 0);
    }
    if(SUCCEEDED(hr))
    {
        ASSERT(varName.vt == VT_BSTR);
    
        for (int i = 0; i < NUM_LEGACY_DEVICES; i++)
        {
            if (m_rgLegacyCap[i].bNotMatched)
            {
                if(lstrcmp(m_rgLegacyCap[i].szName, W2T(varName.bstrVal)) == 0)
                {
                    if(varId.lVal == i)
                    {
                        m_rgLegacyCap[i].bNotMatched = FALSE;
                        fRet =  true;
                        break;
                    }
                }
            }
        }

        SysFreeString(varName.bstrVal);
    } 
    
    return fRet;
}

HRESULT CVidCapClassManager::CreateRegKeys(IFilterMapper2 *pFm2)
{
    ResetClassManagerKey(CLSID_VideoInputDeviceCategory);
    USES_CONVERSION;


    HRESULT hr = ReadLegacyDevNames();
    if(hr == S_OK)
    {
        for (int i = 0; i < NUM_LEGACY_DEVICES; i++)
        {
            if (m_rgLegacyCap[i].bNotMatched)
            {
                IMoniker *pMoniker = 0;

                const WCHAR *wszUniq = T2CW(m_rgLegacyCap[i].szName);
            
                REGFILTER2 rf2;
                rf2.dwVersion = 1;
                rf2.dwMerit = MERIT_DO_NOT_USE;
                rf2.cPins = 0;
                rf2.rgPins = 0;
                
                hr = RegisterClassManagerFilter(
                    pFm2,
                    CLSID_VfwCapture,
                    wszUniq,
                    &pMoniker,
                    &CLSID_VideoInputDeviceCategory,
                    wszUniq,
                    &rf2);

                if(SUCCEEDED(hr))
                        
                {
                    IPropertyBag *pPropBag;
                    hr = pMoniker->BindToStorage(
                        0, 0, IID_IPropertyBag, (void **)&pPropBag);
                    if(SUCCEEDED(hr))
                    {
                        VARIANT var;
                        var.vt = VT_I4;
                        var.lVal = i;
                        hr = pPropBag->Write(g_wszVidcapDriverIndex, &var);

                        if(SUCCEEDED(hr))
                        {
//                             // hide VFW devices that also appear in
//                             // the WDM list.
                            
//                             BOOL bThisIsVfwWdm = FALSE;
//                             HANDLE h;
//                             if (videoOpen(&h, i, VIDEO_IN) == DV_ERR_OK) {
//                                 CHANNEL_CAPS Caps;
//                                 if (h && videoGetChannelCaps(h, &Caps, sizeof(CHANNEL_CAPS)) == DV_ERR_OK) {
//                                     bThisIsVfwWdm = (BOOL)(Caps.dwFlags & (DWORD)0x04000000);
//                                 }
//                             }

//                             if(bThisIsVfwWdm)
//                             {
//                                 VARIANT var;
//                                 var.vt = VT_I4;
//                                 var.lVal = CLASS_MGR_OMIT;

//                                 hr = pPropBag->Write(g_wszClassManagerFlags, &var);
//                             }
                        }

                        pPropBag->Release();
                    }
                    pMoniker->Release();
                }
            }
        }


 
        return S_OK;
    } else {
        return hr;
    }
}
=== C:/Users/treeman/Desktop/windows nt source code\Source\Win2K3\NT\multimedia\dshow\filterus\pnp\devenum\waveinp.cpp ===
// Copyright (c) 1997 - 1999  Microsoft Corporation.  All Rights Reserved.
#include "stdafx.h"
#include <mmddk.h>
#include "waveinp.h"
#include <vfw.h>
#include <ks.h>
#include <ksmedia.h>
#include <ksproxy.h>
#include "util.h"
#include "cenumpnp.h"
#include "devmon.h"

static const WCHAR g_wszDriverIndex[] = L"WaveInId";
const TCHAR g_szWaveinDriverIndex[] = TEXT("WaveInId");
static const TCHAR g_szInput[] = TEXT("Record");

CWaveInClassManager::CWaveInClassManager() :
        CClassManagerBase(TEXT("FriendlyName")),
        m_rgWaveIn(0),
        m_lKsProxyAudioDevices(NAME("ksaudio capture dev list"), 10)
{
    // only show ksproxy audio capture devices on nt5
    //extern OSVERSIONINFO g_osvi;
    //m_bEnumKs = (g_osvi.dwPlatformId == VER_PLATFORM_WIN32_NT &&
    //             g_osvi.dwMajorVersion >= 5);
    m_bEnumKs = FALSE; // nevermind, don't show them on any os, for now
}

CWaveInClassManager::~CWaveInClassManager()
{

    delete[] m_rgWaveIn;
    DelLocallyRegisteredPnpDevData();

}

void GetPreferredDeviceName(TCHAR szNamePreferredDevice[MAXPNAMELEN],
                            const TCHAR *szVal, bool bOutput)
{
    // first try to use the new DRVM_MAPPER_PREFERRED_GET message to get the preferred
    // device id. note that this message was added in nt5 and so is not guaranteed to
    // be supported on all os's.
    DWORD dw1, dw2;

    MMRESULT mmr;
    if (bOutput) {
        mmr = waveOutMessage( (HWAVEOUT) IntToPtr(WAVE_MAPPER)   // assume waveIn will translate WAVE_MAPPER?
                           , DRVM_MAPPER_PREFERRED_GET
                           , (DWORD_PTR) &dw1
                           , (DWORD_PTR) &dw2 );
    } else {
        mmr = waveInMessage( (HWAVEIN) IntToPtr(WAVE_MAPPER)   // assume waveIn will translate WAVE_MAPPER?
                           , DRVM_MAPPER_PREFERRED_GET
                           , (DWORD_PTR) &dw1
                           , (DWORD_PTR) &dw2 );
    }
    if( MMSYSERR_NOERROR == mmr )
    {
        UINT uiPrefDevId = (UINT)dw1;
        TCHAR *szPname;
        if (bOutput) {
            WAVEOUTCAPS woCaps;
            szPname = woCaps.szPname;
            mmr = waveOutGetDevCaps( uiPrefDevId
                                  , &woCaps
                                  , sizeof( woCaps ) );
        } else {
            WAVEINCAPS wiCaps;
            szPname = wiCaps.szPname;
            mmr = waveInGetDevCaps( uiPrefDevId
                                  , &wiCaps
                                  , sizeof( wiCaps ) );
        }
        if( ( MMSYSERR_NOERROR == mmr ) && ( ( (UINT)-1 ) != uiPrefDevId ) )
        {
            lstrcpy( szNamePreferredDevice, szPname );
        }
        else
        {
            DbgLog( ( LOG_ERROR
                  , 0
                  , TEXT("devenum: Failed to get preferred dev (%s for dev id %ld returned %ld)")
                  , bOutput ? TEXT("waveOutGetDevCaps") :
                              TEXT("waveInGetDevCaps")
                  , uiPrefDevId
                  , mmr ) );
            szNamePreferredDevice[0] = 0;
        }
    }
    else
    {
        // revert back to reading the registry to get the preferred device name
        DbgLog( ( LOG_ERROR
              , 5
              , TEXT("devenum: waveInMessage doesn't support DRVM_MAPPER_PREFERRED_GET (err = %ld). Reading registry instead...")
              , mmr ) );

        HKEY hkSoundMapper;
        LONG lResult = RegOpenKeyEx(
            HKEY_CURRENT_USER,
            TEXT("Software\\Microsoft\\Multimedia\\Sound Mapper"),
            0,                      // reserved
            KEY_READ,
            &hkSoundMapper);
        if(lResult == ERROR_SUCCESS)
        {
            DWORD dwType, dwcb = MAXPNAMELEN * sizeof(TCHAR);
            lResult = RegQueryValueEx(
                hkSoundMapper,
                szVal,
                0,                  // reserved
                &dwType,
                (BYTE *)szNamePreferredDevice,
                &dwcb);

            ASSERT(lResult == ERROR_SUCCESS ? dwType == REG_SZ : TRUE);
            EXECUTE_ASSERT(RegCloseKey(hkSoundMapper) == ERROR_SUCCESS);
        }

        if(lResult != ERROR_SUCCESS) {
            DbgLog((LOG_ERROR, 0, TEXT("devenum: couldn't get preferred %s device from registry"),
                    szVal));
            szNamePreferredDevice[0] = 0;
        }
    }
}

HRESULT CWaveInClassManager::ReadLegacyDevNames()
{
    m_cNotMatched = 0;
    m_pPreferredDevice = 0;

    HRESULT hr = S_OK;
    m_cWaveIn = waveInGetNumDevs();
    if(m_cWaveIn == 0)
    {
        hr = S_FALSE;
    }
    else
    {
        TCHAR szNamePreferredDevice[MAXPNAMELEN];
        GetPreferredDeviceName(szNamePreferredDevice, g_szInput, false);

        delete[] m_rgWaveIn;
        m_rgWaveIn = new LegacyWaveIn[m_cWaveIn];
        if(m_rgWaveIn == 0)
        {
            hr = E_OUTOFMEMORY;
        }
        else
        {
            // save names
            for(UINT i = 0; i < m_cWaveIn; i++)
            {
                WAVEINCAPS wiCaps;

                if(waveInGetDevCaps(i, &wiCaps, sizeof(wiCaps)) == MMSYSERR_NOERROR)
                {
                    m_rgWaveIn[i].dwWaveId = i;
                    lstrcpy(m_rgWaveIn[i].szName, wiCaps.szPname);

                    if(lstrcmp(wiCaps.szPname, szNamePreferredDevice) == 0)
                    {
                        ASSERT(m_pPreferredDevice == 0);
                        m_pPreferredDevice = &m_rgWaveIn[i];
                    }
                }
                else
                {
                    DbgLog((LOG_ERROR, 0, TEXT("waveInGetDevCaps failed")));
                    m_cWaveIn = i;
                    break;
                }
            }

            if(m_pPreferredDevice == 0) {
                m_pPreferredDevice = &m_rgWaveIn[0];
            }
        }
    }
    int cKsProxy = 0;
    if( S_OK == hr && m_bEnumKs )
    {
        PNP_PERF(static int k  = MSR_REGISTER("ksproxy audio capture device enum"));
        PNP_PERF(MSR_INTEGER(k, 1));
        // now handle any pnp devices that we register locally (so far this is only ksproxy audio devices)
        hr = ReadLocallyRegisteredPnpDevData();
        if( SUCCEEDED( hr ) )
            cKsProxy = m_lKsProxyAudioDevices.GetCount();
        else
            DbgLog( ( LOG_ERROR
                    , 1
                    , TEXT("ReadLegacyDeviceNames - ReadLocallyRegisteredPnpDevData failed[0x%08lx]")
                    , hr ) );

        PNP_PERF(MSR_INTEGER(k, 2));

        // NOTE!! should we return hr?
    }

    m_cNotMatched = m_cWaveIn + cKsProxy;
    return S_OK;
}

// the names and preferred devices need to match.
//

BOOL CWaveInClassManager::MatchString(IPropertyBag *pPropBag)
{
    BOOL fReturn = FALSE;

    VARIANT varName, varDefaultDevice, varDevId;
    varName.vt = VT_EMPTY;
    varDefaultDevice.vt = VT_I4;
    varDevId.vt = VT_I4;

    USES_CONVERSION;
    HRESULT hr = pPropBag->Read(T2COLE(m_szUniqueName), &varName, 0);
    if(SUCCEEDED(hr))
    {
        hr = pPropBag->Read(g_wszClassManagerFlags, &varDefaultDevice, 0);

        bool fPreferred = SUCCEEDED(hr) && (varDefaultDevice.lVal & CLASS_MGR_DEFAULT);

        for (UINT i = 0; i < m_cWaveIn; i++)
        {
            // xnor: is the preferred flag the same in the both places?
            if(fPreferred == (m_pPreferredDevice == &m_rgWaveIn[i]))
            {
                if (lstrcmp(m_rgWaveIn[i].szName, OLE2T(varName.bstrVal)) == 0)
                {
                    // last check, make sure device id hasn't changed!
                    hr = pPropBag->Read(g_wszDriverIndex, &varDevId, 0);
                    if( SUCCEEDED( hr ) && ( m_rgWaveIn[i].dwWaveId == (DWORD)varDevId.lVal ) )
                    {
                        fReturn = TRUE;
                        break;
                    }
                    else
                        DbgLog( ( LOG_TRACE
                              , 5
                              , TEXT("CWaveInClassManager: device ids changed (prop bag has %d, wo has %d)!")
                              , varDevId.lVal
                              , m_rgWaveIn[i].dwWaveId ) );
                }
            }
        }

        const TCHAR *szKsDevName = W2CT( varName.bstrVal );
        if( szKsDevName )
        {
            for(POSITION pos = m_lKsProxyAudioDevices.GetHeadPositionI();
                pos && !fReturn;
                pos = m_lKsProxyAudioDevices.Next(pos))
            {
                KsProxyAudioDev *pksp = m_lKsProxyAudioDevices.Get(pos);
                if( lstrcmp( pksp->szName, szKsDevName ) == 0 )
                {
                    // lastly, make sure device path hasn't changed
                    VARIANT varDevPath;
                    varDevPath.vt = VT_EMPTY;
                    
                    hr = pPropBag->Read(L"DevicePath", &varDevPath, 0);
                    if( SUCCEEDED( hr ) )
                    {
                        if( 0 == lstrcmp( pksp->lpstrDevicePath, W2T( varDevPath.bstrVal ) ) )
                        {
                            fReturn = TRUE;
                            DbgLog((LOG_TRACE, 5, TEXT("CWaveOutClassManager: matched %S"),
                                    varName.bstrVal));
                        }
                        else
                        {                        
                            DbgLog( ( LOG_TRACE
                                  , 5
                                  , TEXT("CWaveInClassManager: device path changed for ksproxy capture filter") ) );
                        }
                        SysFreeString( varDevPath.bstrVal );
                        
                        if( fReturn )
                            break;
                    }                                                          
                }
            }
        }

        SysFreeString(varName.bstrVal);
    }

    return fReturn;
}

HRESULT CWaveInClassManager::CreateRegKeys(IFilterMapper2 *pFm2)
{
    ResetClassManagerKey(CLSID_AudioInputDeviceCategory);

    USES_CONVERSION;

    ReadLegacyDevNames();
    for (DWORD i = 0; i < m_cWaveIn; i++)
    {
        const WCHAR *wszUniq = T2COLE(m_rgWaveIn[i].szName);

        REGFILTER2 rf2;
        rf2.dwVersion = 1;
        rf2.dwMerit = MERIT_DO_NOT_USE;
        rf2.cPins = 0;
        rf2.rgPins = 0;

        IMoniker *pMoniker = 0;
        HRESULT hr = RegisterClassManagerFilter(
            pFm2,
            CLSID_AudioRecord,
            wszUniq,
            &pMoniker,
            &CLSID_AudioInputDeviceCategory,
            wszUniq,
            &rf2);
        if(SUCCEEDED(hr))
        {
            IPropertyBag *pPropBag;
            hr = pMoniker->BindToStorage(
                0, 0, IID_IPropertyBag, (void **)&pPropBag);
            if(SUCCEEDED(hr))
            {
                VARIANT var;
                var.vt = VT_I4;
                var.lVal = i;
                hr = pPropBag->Write(g_wszDriverIndex, &var);

                if(SUCCEEDED(hr) && m_pPreferredDevice == &m_rgWaveIn[i])
                {
                    VARIANT var;
                    var.vt = VT_I4;
                    var.lVal = CLASS_MGR_DEFAULT;
                    hr = pPropBag->Write(g_wszClassManagerFlags, &var);
                }

                pPropBag->Release();
            }
            pMoniker->Release();
        }
        else
        {
            break;
        }
    } // for

    for( POSITION pos = m_lKsProxyAudioDevices.GetHeadPositionI();
         pos;
         pos = m_lKsProxyAudioDevices.Next(pos) )
    {
        KsProxyAudioDev *pksp = m_lKsProxyAudioDevices.Get( pos );

        const WCHAR *wszUniq = T2CW( pksp->szName );

        REGFILTER2 rf2;
        rf2.dwVersion = 1;
        rf2.dwMerit = MERIT_DO_NOT_USE;
        rf2.cPins = 0;
        rf2.rgPins = 0;

        IMoniker *pMoniker = 0;
        HRESULT hr = RegisterClassManagerFilter(
            pFm2,
            pksp->clsid,
            wszUniq,
            &pMoniker,
            &CLSID_AudioInputDeviceCategory,
            wszUniq,
            &rf2);
        ASSERT( SUCCEEDED( hr ) );
        if(SUCCEEDED(hr))
        {
            IPropertyBag *pPropBag;
            hr = pMoniker->BindToStorage(
                0, 0, IID_IPropertyBag, (void **)&pPropBag);
            if(SUCCEEDED(hr))
            {
                VARIANT var;
                var.vt = VT_BSTR;
                var.bstrVal = SysAllocString( T2CW( pksp->lpstrDevicePath ) );
                if(var.bstrVal)
                {
                    hr = pPropBag->Write(L"DevicePath", &var);
                    SysFreeString(var.bstrVal);
                }
                else
                {
                    hr = E_OUTOFMEMORY;
                }
                pPropBag->Release();
            }
            pMoniker->Release();
        }
        else
        {
            break;
        }
    }

    return S_OK;
}


HRESULT CWaveInClassManager::ReadLocallyRegisteredPnpDevData()
{
    ASSERT( m_bEnumKs );

    DelLocallyRegisteredPnpDevData();

    const CLSID *rgpclsidKsCat[2];
    rgpclsidKsCat[0] = &KSCATEGORY_AUDIO_DEVICE;
    rgpclsidKsCat[1] = 0;

    HRESULT hr = BuildPnpAudDeviceList( rgpclsidKsCat
                                      , m_lKsProxyAudioDevices
                                      , KSAUD_F_ENUM_WAVE_CAPTURE);
    return hr;
}


void CWaveInClassManager::DelLocallyRegisteredPnpDevData()
{
    KsProxyAudioDev *pksp;
    for(; pksp = m_lKsProxyAudioDevices.RemoveHead(); )
    {
        if( pksp->pPropBag )
            pksp->pPropBag->Release();

        delete[] pksp->lpstrDevicePath;
        delete[] pksp->szName;
        delete pksp;
    }
}
=== C:/Users/treeman/Desktop/windows nt source code\Source\Win2K3\NT\multimedia\dshow\filterus\pnp\devenum\vidcap.h ===
// Copyright (c) 1997 - 1999  Microsoft Corporation.  All Rights Reserved.
#include "resource.h"
#include "cmgrbase.h"

#include <vfw.h>

static const g_cchCapName = 64;
static const g_cchCapDesc = 64;
static const NUM_LEGACY_DEVICES = 10;

class CVidCapClassManager :
    public CClassManagerBase,
    public CComObjectRoot,
    public CComCoClass<CVidCapClassManager,&CLSID_CVidCapClassManager>
{
    struct LegacyCap
    {
        TCHAR szName[g_cchCapName];
        TCHAR szDesc[g_cchCapDesc];
        BOOL bNotMatched;
    } m_rgLegacyCap[NUM_LEGACY_DEVICES];


public:

    CVidCapClassManager();
    ~CVidCapClassManager();

    BEGIN_COM_MAP(CVidCapClassManager)
	COM_INTERFACE_ENTRY2(IDispatch, ICreateDevEnum)
	COM_INTERFACE_ENTRY(ICreateDevEnum)
// 	COM_INTERFACE_ENTRY(ISupportErrorInfo)
    END_COM_MAP();

    DECLARE_NOT_AGGREGATABLE(CVidCapClassManager) ;
    DECLARE_NO_REGISTRY();
    
    HRESULT ReadLegacyDevNames();
    BOOL MatchString(IPropertyBag *pPropBag);
    // BOOL MatchString(const TCHAR *szDevName);
    HRESULT CreateRegKeys(IFilterMapper2 *pFm2);

private:

    typedef BOOL(VFWAPI *PcapGetDriverDescriptionA)(
        UINT wDriverIndex,
        LPSTR lpszName, int cbName,
        LPSTR lpszVer, int cbVer);        

    typedef BOOL(VFWAPI *PcapGetDriverDescriptionW)(
        UINT wDriverIndex,
        LPWSTR lpszName, int cbName,
        LPWSTR lpszVer, int cbVer);

#ifdef UNICODE
    typedef PcapGetDriverDescriptionW PcapGetDriverDescription;
#else
    typedef PcapGetDriverDescriptionA PcapGetDriverDescription;
#endif

    PcapGetDriverDescription m_capGetDriverDescription;
    HMODULE m_hmodAvicap32;
};
=== C:/Users/treeman/Desktop/windows nt source code\Source\Win2K3\NT\multimedia\dshow\filterus\pnp\devenum\waveoutp.h ===
// Copyright (c) 1997 - 1999  Microsoft Corporation.  All Rights Reserved.
// class managwer for audio renderers (waveOut and DSound)

#include "resource.h"
#include "cmgrbase.h"

#include <dsound.h>


class CWaveOutClassManager :
    public CClassManagerBase,
    public CComObjectRoot,
    public CComCoClass<CWaveOutClassManager,&CLSID_CWaveOutClassManager>
{
    struct LegacyWaveOut
    {
        TCHAR szName[MAXPNAMELEN];
        DWORD dwMerit;
        DWORD dwWaveId;
    };

    CGenericList<LegacyWaveOut> m_lWaveoutDevices;

    struct DSoundDev
    {
        TCHAR *szName;
        GUID guid;
        DWORD dwMerit;
    };

    CGenericList<DSoundDev> m_lDSoundDevices;

    static BOOL DSoundCallback(
        GUID FAR * lpGuid,
        LPCTSTR lpstrDescription,
        LPCTSTR lpstrModule,
        LPVOID lpContext);

    HRESULT m_hrEnum;

    void DelNames();

    // instance handle to dsound.dll
    HINSTANCE           m_hDSoundInstance;

    typedef HRESULT (/* WINAPI */ *PDirectSoundEnumerateW)(
        LPDSENUMCALLBACKW lpCallback, LPVOID lpContext
        );
    typedef HRESULT (/* WINAPI */ *PDirectSoundEnumerateA)(
        LPDSENUMCALLBACKA lpCallback, LPVOID lpContext
        );

#ifdef UNICODE
    typedef PDirectSoundEnumerateW PDirectSoundEnumerate;
#else
    typedef PDirectSoundEnumerateA PDirectSoundEnumerate;
#endif

    PDirectSoundEnumerate m_pDirectSoundEnumerate;

    bool m_fUseWaveoutNotDsound;

    // pointer to element in the list.
    LegacyWaveOut *m_pPreferredDevice;

public:

    CWaveOutClassManager();
    ~CWaveOutClassManager();

    BEGIN_COM_MAP(CWaveOutClassManager)
	COM_INTERFACE_ENTRY2(IDispatch, ICreateDevEnum)
	COM_INTERFACE_ENTRY(ICreateDevEnum)
    END_COM_MAP();

    DECLARE_NOT_AGGREGATABLE(CWaveOutClassManager) ;
    DECLARE_NO_REGISTRY();

    HRESULT ReadLegacyDevNames();
    BOOL MatchString(IPropertyBag *pPropBag);
    HRESULT CreateRegKeys(IFilterMapper2 *pFm2);
};
=== C:/Users/treeman/Desktop/windows nt source code\Source\Win2K3\NT\multimedia\dshow\filterus\pnp\devenum\waveinp.h ===
// Copyright (c) 1997 - 1999  Microsoft Corporation.  All Rights Reserved.
#include "resource.h"
#include "cmgrbase.h"
#include "ksaudio.h"

class CWaveInClassManager :
    public CClassManagerBase,
    public CComObjectRoot,
    public CComCoClass<CWaveInClassManager,&CLSID_CWaveinClassManager>
{
    struct LegacyWaveIn
    {
        TCHAR szName[MAXPNAMELEN];
        DWORD dwWaveId;
    } *m_rgWaveIn;

    CGenericList<KsProxyAudioDev> m_lKsProxyAudioDevices;
    void DelLocallyRegisteredPnpDevData();

    ULONG m_cWaveIn;
    BOOL  m_bEnumKs;

    // pointer to element in the array. 
    LegacyWaveIn *m_pPreferredDevice;

public:

    CWaveInClassManager();
    ~CWaveInClassManager();

    BEGIN_COM_MAP(CWaveInClassManager)
	COM_INTERFACE_ENTRY2(IDispatch, ICreateDevEnum)
	COM_INTERFACE_ENTRY(ICreateDevEnum)
    END_COM_MAP();

    DECLARE_NOT_AGGREGATABLE(CWaveInClassManager) ;
    DECLARE_NO_REGISTRY();
    
    HRESULT ReadLegacyDevNames();
    HRESULT ReadLocallyRegisteredPnpDevData();
    BOOL MatchString(IPropertyBag *pPropBag);
    HRESULT CreateRegKeys(IFilterMapper2 *pFm2);
};
=== C:/Users/treeman/Desktop/windows nt source code\Source\Win2K3\NT\multimedia\dshow\filterus\pnp\devenum\waveoutp.cpp ===
// Copyright (c) 1997 - 1999  Microsoft Corporation.  All Rights Reserved.
#include "stdafx.h"
#include "waveOutp.h"
#include "util.h"
#include "mmreg.h"

const TCHAR g_szDriverClsid[] = TEXT("CLSID");
const WCHAR g_wszDriverIndex[] = L"WaveOutId";
const TCHAR g_szWaveoutDriverIndex[] = TEXT("WaveOutId");
const TCHAR g_szDsoundDriverIndex[] = TEXT("DSGuid");
const TCHAR g_szOutput[] = TEXT("Playback");

const AMOVIESETUP_MEDIATYPE wavOpPinTypes =
{
    &MEDIATYPE_Audio,
    &MEDIASUBTYPE_NULL
};

// static BOOL __stdcall DSoundCallback(
//     GUID FAR * lpGuid,
//     LPSTR lpstrDescription,
//     LPSTR lpstrModule,
//     LPVOID lpContext)
// {
//     return CWaveOutClassManager::DSoundCallback(
//         lpGuid, lpstrDescription, lpstrModule, lpContext);
// }

// dsound accepts only pcm and float, waveout accepts any audio
const AMOVIESETUP_MEDIATYPE
wavInPinTypes = { &MEDIATYPE_Audio, &MEDIASUBTYPE_NULL };

const AMOVIESETUP_MEDIATYPE
dsoundInPinTypes[] =
{
    { &MEDIATYPE_Audio, &MEDIASUBTYPE_PCM },
    // kmixer supports float & DRM natively, legacy dsound doesn't
    { &MEDIATYPE_Audio, &MEDIASUBTYPE_DRM_Audio },
    { &MEDIATYPE_Audio, &MEDIASUBTYPE_IEEE_FLOAT },
    { &MEDIATYPE_Audio, &MEDIASUBTYPE_DOLBY_AC3_SPDIF }, // turn on ac3/spdif compressed formats for dsound
    { &MEDIATYPE_Audio, &MEDIASUBTYPE_RAW_SPORT },
    { &MEDIATYPE_Audio, &MEDIASUBTYPE_SPDIF_TAG_241h }
};

const AMOVIESETUP_PIN
waveOutInPin = { NULL              // pin name
               , TRUE              // bRendered
               , FALSE             // bOutput
               , FALSE             // bZero
               , FALSE             // bMany
               , &CLSID_NULL       // clsConnectToFilter
               , NULL              // strConnectsToPin
               , 1                 // nMediaTypes
               , &wavOpPinTypes }; // lpMediaTypes

const AMOVIESETUP_PIN
dsoundInPin = {  NULL              // pin name
               , TRUE              // bRendered
               , FALSE             // bOutput
               , FALSE             // bZero
               , FALSE             // bMany
               , &CLSID_NULL       // clsConnectToFilter
               , NULL              // strConnectsToPin
               , NUMELMS(dsoundInPinTypes)                 // nMediaTypes
               , dsoundInPinTypes }; // lpMediaTypes


CWaveOutClassManager::CWaveOutClassManager() :
        CClassManagerBase(TEXT("FriendlyName")),
        m_lWaveoutDevices(NAME("waveout dev list"), 10),
        m_lDSoundDevices(NAME("dsound dev list"), 10)
{
    OSVERSIONINFO osvi;
    osvi.dwOSVersionInfoSize = sizeof(osvi);
    BOOL f = GetVersionEx(&osvi);
    ASSERT(f);

    // use dsound on nt4 to work around latency problems and
    // crash. couldn't see any relevant entries in dscaps
    m_fUseWaveoutNotDsound = (osvi.dwPlatformId == VER_PLATFORM_WIN32_NT &&
                              osvi.dwMajorVersion <= 4);

    m_hDSoundInstance = 0;
    m_pDirectSoundEnumerate = 0;

    PNP_PERF(static int i = MSR_REGISTER("dsound"));
    PNP_PERF(MSR_INTEGER(i, 1));


    PNP_PERF(MSR_INTEGER(i, 2));

}

CWaveOutClassManager::~CWaveOutClassManager()
{
    DelNames();

    // don't free it because the dsound renderer will usually just
    // load it again.

//      if(m_hDSoundInstance)
//      {
//          FreeLibrary(m_hDSoundInstance);
//      }
}

void CWaveOutClassManager::DelNames()
{
    LegacyWaveOut *plwo;
    for(; plwo = m_lWaveoutDevices.RemoveHead(); )
        delete plwo;
    DSoundDev *pdsd;
    for(; pdsd = m_lDSoundDevices.RemoveHead(); )
    {
        delete pdsd->szName;
        delete pdsd;
    }

}

HRESULT CWaveOutClassManager::ReadLegacyDevNames()
{
    m_cNotMatched = 0;
    DelNames();
    m_pPreferredDevice = 0;

    TCHAR szNamePreferredDevice[MAXPNAMELEN];
    extern void GetPreferredDeviceName(TCHAR szNamePreferredDevice[MAXPNAMELEN],
                                       const TCHAR *szVal, bool bOutput);
    if (m_fDoAllDevices) {
        GetPreferredDeviceName(szNamePreferredDevice, g_szOutput, true);
    }

    HRESULT hr = S_OK;

    // old waveOut devices
    WAVEOUTCAPS wiCaps;
    if (m_fDoAllDevices) {
        for(UINT i = 0;
            SUCCEEDED(hr) &&
                waveOutGetDevCaps(i, &wiCaps, sizeof(wiCaps)) == MMSYSERR_NOERROR;
            i++)
        {
            LegacyWaveOut *plwo = new LegacyWaveOut;
            if(plwo)
            {
                if(i == 0) {
                    m_pPreferredDevice = plwo;
                }

                lstrcpy(plwo->szName, wiCaps.szPname);
                plwo->dwWaveId = i;
                plwo->dwMerit = MERIT_DO_NOT_USE;

                if(lstrcmp(plwo->szName, szNamePreferredDevice) == 0)
                {
                    m_pPreferredDevice = plwo;
                }

                if(!m_lWaveoutDevices.AddTail(plwo)) {
                    hr = E_OUTOFMEMORY;
                }
            }
            else
            {
                hr = E_OUTOFMEMORY;
            }
        }
    }

    if (m_fDoAllDevices || m_fUseWaveoutNotDsound) {
        LegacyWaveOut *plwo = new LegacyWaveOut;
        if(plwo)
        {
            int ret = LoadString(
                _Module.GetResourceInstance(), IDS_WAVEOUTMAPPER,
                plwo->szName, MAXPNAMELEN);
            ASSERT(ret);

            plwo->dwWaveId = WAVE_MAPPER;
            plwo->dwMerit = m_fUseWaveoutNotDsound ? MERIT_PREFERRED : MERIT_DO_NOT_USE;
            m_lWaveoutDevices.AddTail(plwo);
        }
        else
        {
            hr = E_OUTOFMEMORY;
        }
    }

    if (m_fDoAllDevices) {
        m_hDSoundInstance = LoadLibrary(TEXT("dsound.dll"));
        if(m_hDSoundInstance)
        {
            m_pDirectSoundEnumerate = (PDirectSoundEnumerate)GetProcAddress(
                m_hDSoundInstance,
#ifdef UNICODE
                "DirectSoundEnumerateW"
#else
                "DirectSoundEnumerateA"
#endif
                );
        }
    }

    if(SUCCEEDED(hr) && m_pDirectSoundEnumerate)
    {

        m_hrEnum = S_OK;
        LPDSENUMCALLBACK dscb = DSoundCallback;
        BOOL f = m_pDirectSoundEnumerate( dscb, (void *)this );

        if(f != DS_OK || FAILED(m_hrEnum))
        {
            DbgLog((LOG_ERROR, 1, TEXT("dsound enum failed %08x. so what."),
                    m_hrEnum));
        }
    }

    // always add in the default dsound device
    if(SUCCEEDED(hr) && (m_fDoAllDevices || !m_fUseWaveoutNotDsound))
    {
        DSoundDev *pdsd = new DSoundDev;
        if(pdsd)
        {
            TCHAR szDSoundName[100];
            int ret = LoadString(
                _Module.GetResourceInstance(), IDS_DSOUNDDEFAULTDEVICE,
                szDSoundName, 100);
            ASSERT(ret);

            pdsd->szName = new TCHAR[lstrlen(szDSoundName) + 1];
            if(pdsd->szName)
            {
                lstrcpy(pdsd->szName, szDSoundName);

                pdsd->guid = GUID_NULL; // used by dsr.cpp for default device
                pdsd->dwMerit = m_fUseWaveoutNotDsound ? MERIT_DO_NOT_USE : MERIT_PREFERRED;

                m_lDSoundDevices.AddTail(pdsd);
            }
            else
            {
                delete pdsd;
                hr = E_OUTOFMEMORY;
            }
        }
        else
        {
            hr = E_OUTOFMEMORY;
        }
    }

    m_cNotMatched = m_lWaveoutDevices.GetCount() + m_lDSoundDevices.GetCount();

    return hr;
}

BOOL CWaveOutClassManager::DSoundCallback(
    GUID FAR * lpGuid,
    LPCTSTR lpstrDescription,
    LPCTSTR lpstrModule,
    LPVOID lpContext)
{
    CWaveOutClassManager *pThis = (CWaveOutClassManager *)lpContext;
    ASSERT(pThis->m_hrEnum == S_OK);

    if(lpGuid)
    {
        DSoundDev *pdsd = new DSoundDev;
        if(pdsd)
        {
            TCHAR szDSoundFmt[100];
            int ret = LoadString(
                _Module.GetResourceInstance(), IDS_DSOUNDPREFIX,
                szDSoundFmt, 100);

            pdsd->szName = new TCHAR[lstrlen(lpstrDescription) + 1 +
                                    lstrlen(szDSoundFmt) + 1];
            if(pdsd->szName)
            {
                wsprintf(pdsd->szName, szDSoundFmt, lpstrDescription);

                pdsd->guid = *lpGuid;
                pdsd->dwMerit = MERIT_DO_NOT_USE;

                pThis->m_lDSoundDevices.AddTail(pdsd);
            }
            else
            {
                delete pdsd;
                pThis->m_hrEnum = E_OUTOFMEMORY;
            }
        }
        else
        {
            pThis->m_hrEnum = E_OUTOFMEMORY;
        }
    }

    return SUCCEEDED(pThis->m_hrEnum);
}

BOOL CWaveOutClassManager::MatchString(IPropertyBag *pPropBag)
{
    BOOL fReturn = FALSE;

    VARIANT varName, varDefaultDevice, varDevId;
    varName.vt = VT_EMPTY;
    varDefaultDevice.vt = VT_I4;
    varDevId.vt = VT_I4;

    USES_CONVERSION;
    HRESULT hr = pPropBag->Read(T2COLE(m_szUniqueName), &varName, 0);
    if(SUCCEEDED(hr))
    {
        hr = pPropBag->Read(g_wszClassManagerFlags, &varDefaultDevice, 0);
        bool fPreferred = SUCCEEDED(hr) && (varDefaultDevice.lVal & CLASS_MGR_DEFAULT);
        TCHAR *szDevName = OLE2T(varName.bstrVal);

        for(POSITION pos = m_lWaveoutDevices.GetHeadPositionI();
            pos && !fReturn;
            pos = m_lWaveoutDevices.Next(pos))
        {
            LegacyWaveOut *plwo = m_lWaveoutDevices.Get(pos);

            // xnor: is the preferred flag the same in the both places?
            if(fPreferred == (m_pPreferredDevice == plwo))
            {
                if (lstrcmp(plwo->szName, szDevName) == 0)
                {
                    DbgLog((LOG_TRACE, 5, TEXT("CWaveOutClassManager: matched %S"),
                            varName.bstrVal));

                    // last check, make sure device id hasn't changed!
                    hr = pPropBag->Read(g_wszDriverIndex, &varDevId, 0);
                    if( SUCCEEDED( hr ) && ( plwo->dwWaveId == (DWORD)varDevId.lVal ) )
                        fReturn = TRUE;
                    else
                        DbgLog( ( LOG_TRACE
                              , 5
                              , TEXT("CWaveOutClassManager: device ids changed (prop bag has %d, wo has %d)!")
                              , varDevId.lVal
                              , plwo->dwWaveId ) );
                }
            }
        }

        for(pos = m_lDSoundDevices.GetHeadPositionI();
            pos && !fReturn;
            pos = m_lDSoundDevices.Next(pos))
        {
            DSoundDev *pdsd = m_lDSoundDevices.Get(pos);
            if(lstrcmp(pdsd->szName, szDevName) == 0)
            {
                DbgLog((LOG_TRACE, 5, TEXT("CWaveOutClassManager: matched %S"),
                        varName.bstrVal));
                fReturn = TRUE;
            }
        }

        SysFreeString(varName.bstrVal);
    }

    return fReturn;
}

HRESULT CWaveOutClassManager::CreateRegKeys(IFilterMapper2 *pFm2)
{
    ResetClassManagerKey(CLSID_AudioRendererCategory);

    USES_CONVERSION;
    HRESULT hr = S_OK;

    ReadLegacyDevNames();

    for(POSITION pos = m_lWaveoutDevices.GetHeadPositionI();
        pos;
        pos = m_lWaveoutDevices.Next(pos))
    {
        LegacyWaveOut *plwo = m_lWaveoutDevices.Get(pos);

        const WCHAR *wszUniq = T2COLE(plwo->szName);

        REGFILTER2 rf2;
        rf2.dwVersion = 1;
        rf2.dwMerit = plwo->dwMerit;
        rf2.cPins = 1;
        rf2.rgPins = &waveOutInPin;

        IMoniker *pMoniker = 0;
        hr = RegisterClassManagerFilter(
            pFm2,
            CLSID_AudioRender,
            wszUniq,
            &pMoniker,
            &CLSID_AudioRendererCategory,
            wszUniq,
            &rf2);
        if(SUCCEEDED(hr))
        {
            CComPtr<IPropertyBag> pPropBag;
            hr = pMoniker->BindToStorage(
                0, 0, IID_IPropertyBag, (void **)&pPropBag);
            if(SUCCEEDED(hr))
            {
                VARIANT var;
                var.vt = VT_I4;
                var.lVal = plwo->dwWaveId;
                hr = pPropBag->Write(g_wszDriverIndex, &var);
            }


            if(SUCCEEDED(hr) && m_pPreferredDevice == plwo)
            {
                VARIANT var;
                var.vt = VT_I4;
                var.lVal = CLASS_MGR_DEFAULT;
                hr = pPropBag->Write(g_wszClassManagerFlags, &var);
            }

            pMoniker->Release();
        }
        else
        {
            break;
        }

    } // for

    for(pos = m_lDSoundDevices.GetHeadPositionI();
        pos;
        pos = m_lDSoundDevices.Next(pos))
    {
        DSoundDev *pdsd = m_lDSoundDevices.Get(pos);

        const WCHAR *wszUniq = T2CW(pdsd->szName);

        REGFILTER2 rf2;
        rf2.dwVersion = 1;
        rf2.dwMerit = pdsd->dwMerit;
        rf2.cPins = 1;
        rf2.rgPins = &dsoundInPin;

        IMoniker *pMoniker = 0;
        hr = RegisterClassManagerFilter(
            pFm2,
            CLSID_DSoundRender,
            wszUniq,
            &pMoniker,
            &CLSID_AudioRendererCategory,
            wszUniq,
            &rf2);

        if(SUCCEEDED(hr))
        {
            IPropertyBag *pPropBag;
            hr = pMoniker->BindToStorage(
                0, 0, IID_IPropertyBag, (void **)&pPropBag);
            if(SUCCEEDED(hr))
            {
                WCHAR szGuid[CHARS_IN_GUID];
                StringFromGUID2(pdsd->guid, szGuid, CHARS_IN_GUID);

                VARIANT var;
                var.vt = VT_BSTR;
                var.bstrVal = SysAllocString(szGuid);
                if(var.bstrVal)
                {
                    hr = pPropBag->Write(L"DSGuid", &var);
                    SysFreeString(var.bstrVal);
                }
                else
                {
                    hr = E_OUTOFMEMORY;
                }

                pPropBag->Release();
            }
            pMoniker->Release();
        }
        else
        {
            break;
        }
    }

    return hr;
}
=== C:/Users/treeman/Desktop/windows nt source code\Source\Win2K3\NT\multimedia\dshow\filterus\text\sami\rawparse.h ===
// Copyright (c) 1997 - 1998  Microsoft Corporation.  All Rights Reserved.

struct STRING_ENTRY {
    char *	pTag;
    int		token;
};


typedef enum _PARSETOKEN {
    TOK_EMPTY = -3,
    TOK_NUMBER = -2,
    TOK_STRING = -1,
    TOK_CUSTOM = 100
} PARSETOKEN;

const int MAX_TAGS = 20;

const int MAX_STRING_LEN = 1024;

const int MAX_TAG_STRING_LEN = 20;      // QFE #33995 fix

class CToken {
public:
    PARSETOKEN	tokType;

    union {
	int	tokValue;

	struct {
	    char *	tokString;
	    int		cbString;
	};

	struct {
	    int	cTags;
	    struct {
		char tag[MAX_TAG_STRING_LEN];   // QFE #33995 fix
		char value[MAX_STRING_LEN];
		BOOL fUsed;
	    } tokTags[MAX_TAGS];

	    BOOL	fEnd;		// if custom tag, is this the end of a tag?
	    BOOL	fSingle;	// for XML-style tags, is it complete? <tag stuff />
	};

	// !!! how to represent custom data?
    };

};

const int MAX_TOKENS=50;	// number of new tokens


class CTokenInterpreter {
public:
    virtual BOOL	SpecialTagParsing(int token) = 0;
    virtual HRESULT	NewToken(CToken &tok) = 0;
};


class CRawParser {
    STRING_ENTRY	m_sTab[MAX_TOKENS];
    int			m_cTab;

    STRING_ENTRY *	m_sTabInitial;
    int			m_cTabInitial;

    CTokenInterpreter *	m_pInterp;

    BOOL		m_bReturnCopy;
    
public:
    CRawParser(CTokenInterpreter *pInterp,
	       STRING_ENTRY *sTabInitial = 0, int cTabInitial = 0, BOOL bReturnCopy = FALSE)
    {
	m_pInterp = pInterp;
	ResetStringTable(sTabInitial, cTabInitial);
	m_bReturnCopy = bReturnCopy;
    };

    HRESULT ResetStringTable(STRING_ENTRY *sTabInitial = 0, int cTabInitial = 0)
    {
	m_sTabInitial = sTabInitial;
	m_cTabInitial = cTabInitial;
	m_cTab = 0;

	return S_OK;
    };

    HRESULT Parse(char *pData, int cbData)
    {
	// does this need to be restartable, or can we get the whole file all at once?
	HRESULT hr = S_OK;

	CToken	tok;

	while (cbData--) {
	    char c = *pData++;

	    if (c == '\0') {
		DbgLog((LOG_ERROR, 1, TEXT("got null with %d chars left?"), cbData+1));
		break;
	    }

	    if (c == '<') {
		int cbTag = 0;
		BOOL fNot = FALSE;

		if (*pData == '/') {
		    fNot = TRUE;
		    pData++;
		    cbData--;
		}

		while (cbTag + 1 < cbData && pData[cbTag] != '>' &&
			       pData[cbTag] != ' ' &&
			       pData[cbTag] != '\t' &&
			       pData[cbTag] != '\r' &&
			       pData[cbTag] != '\n' &&
			       pData[cbTag] != '=')
		    ++cbTag;

		STRING_ENTRY *	pTagToTest = NULL;
		BOOL fFound = FALSE;
		if (cbTag == 0) {
		    if (fNot) {
			DbgLog((LOG_TRACE, 4, TEXT("Found /> tag")));
			fFound = TRUE;
		    } else {

		    }
		} else {
		    for (int i = 0; i < m_cTab + m_cTabInitial; i++) {
			if (i < m_cTabInitial) {
			    pTagToTest = &m_sTabInitial[i];
			} else {
			    pTagToTest = &m_sTab[i - m_cTabInitial];
			}

			int res = CompareStringA(0, NORM_IGNORECASE,
						pTagToTest->pTag, -1,
						pData, cbTag);

			if (res == 2) {	// are strings equal?

			    DbgLog((LOG_TRACE, 4, TEXT("Found token #%d '%hs'  fNot = %d...."),
				   pTagToTest->token, pTagToTest->pTag, fNot));

			    fFound = TRUE;
			    break;
			}
		    }
		}
		if (!fFound) {
		    DbgLog((LOG_TRACE, 2, TEXT("couldn't interpret %.10hs"), pData-1));
		    // !!! go handle as a string instead

		    if (fNot) {
			--pData;
			++cbData;
		    }
		} else {
		    // skip over tag name, up to space or closing bracket
		    pData += cbTag;
		    cbData -= cbTag;

		    if (pTagToTest) {
			tok.tokType = (PARSETOKEN) pTagToTest->token;
		    } else 
			tok.tokType = TOK_EMPTY;
		    tok.cTags = 0;
		    tok.fEnd = fNot;
		    tok.fSingle = FALSE;
		    if (FAILED(hr))	// what's hr here???
			return hr;

		    if (m_pInterp->SpecialTagParsing(tok.tokType)) {
			while (--cbData) {
			    char c = *pData++;

			    if (c == ' ' || c == '\r' || c == '\n' || c == '\t')
				continue;

			    if (c == '-')
				continue;

			    if (c == '>')
				break;

			    if (tok.cTags >= MAX_TAGS) {
				// !!!
				continue;
			    }

			    int cbTag = 0;
			    while (cbTag < cbData && cbTag < (MAX_TAG_STRING_LEN-1) && c != ' ' && c != '=' && c != '>') {  /* QFE #33995 fix */
				tok.tokTags[tok.cTags].tag[cbTag] = c;
				c = pData[cbTag++];
			    }
			    tok.tokTags[tok.cTags].tag[cbTag] = '\0';
			    tok.tokTags[tok.cTags].fUsed = FALSE;

			    pData += cbTag-1;
			    cbData -= cbTag-1;

			    int cbValue = 0;

			    if (c == ' ') { // we have a value, get that too
				pData++; --cbData;		// first skip '=' sign

				c = *pData++; --cbData;	// get first character of value
				if (c == '{') {
				    c = *pData++; --cbData;	// skip opening '{'
				}

				while (cbValue < cbData &&
				       cbValue < MAX_STRING_LEN-1 &&
				       c != '>') {
				    tok.tokTags[tok.cTags].value[cbValue] = c;
				    if (c == '}') {
					++cbValue;
					break;
				    }

				    c = pData[cbValue++];
				}

				pData += cbValue-1;
				cbData -= cbValue-1;
			    }

			    if (cbValue > 0 && tok.tokTags[tok.cTags].value[cbValue-1] == '}')
				--cbValue;

			    tok.tokTags[tok.cTags].value[cbValue] = '\0';

			    DbgLog((LOG_TRACE, 4, TEXT("Tag #%d: '%hs' = '%hs'"), tok.cTags,
				    tok.tokTags[tok.cTags].tag,
				    tok.tokTags[tok.cTags].value));

			    tok.cTags++;
			}
		    } else {
			while (--cbData) {
			    char c = *pData++;

			    if (c == '/' && *pData == '*') {
				DbgLog((LOG_TRACE, 4, TEXT("Found a C-style comment")));

				for (int cmtLength = 3; cmtLength < cbData; cmtLength++) {
				    if (pData[cmtLength-2] == '*' && pData[cmtLength-1] == '/') {
					pData += cmtLength;
					cbData -= cmtLength;
					break;
				    }
				}
				continue;
			    }

			    if (c == '/' && *pData == '>') {
				tok.fSingle = TRUE;
				c = *pData++;
				--cbData;
			    }

			    if (c == '>')
				break;

			    if (c == ' ' || c == '\t' || c == '\r' || c == '\n')
				continue;

			    if (tok.cTags >= MAX_TAGS) {
				// !!!
				continue;
			    }

			    int cbTag = 0;
                while (cbTag < cbData && cbTag < (MAX_TAG_STRING_LEN-1) && c != ' ' && c != '=' && c != '/' && c != '>') { /* QFE #33995 fix */
				tok.tokTags[tok.cTags].tag[cbTag] = c;
				c = pData[cbTag++];
			    }
			    tok.tokTags[tok.cTags].tag[cbTag] = '\0';

			    pData += cbTag;
			    cbData -= cbTag;

			    int cbValue = 0;

			    while (c == ' ' || c == '\r' || c == '\n' || c == '\t') {
				c = *pData++;
				--cbData;
			    }

			    if (c == '=') { // we have a value, get that too
				c = *pData++; --cbData;	// get first character of value

				while (c == ' ' || c == '\r' || c == '\n' || c == '\t') {
				    c = *pData++;
				    --cbData;
				}

				BOOL fQuoted = FALSE;
				if (c == '"') {
				    fQuoted = TRUE;
				    c= *pData++;
				    --cbData;
				}


				while (cbValue < cbData &&
				       cbValue < MAX_STRING_LEN-1 &&        /* QFE #33995 Fix */
				       !((fQuoted && c == '"') ||
					 (!fQuoted && (c == ' ' ||
						       c == '"' ||
						       c == '/' ||
						       c == '>' ||
						       c == '\t' ||
						       c == '\r' ||
						       c == '\n')))) {
				    tok.tokTags[tok.cTags].value[cbValue] = c;
				    c = pData[cbValue++];
				}

				pData += cbValue-1;
				cbData -= cbValue-1;

				if (c == '"') {
				    if (fQuoted) {
					// skip over ending quote
					pData++;
					cbData--;
				    } else {
					// random quote in the file
					return VFW_E_INVALID_FILE_FORMAT;
				    }
				}
			    } else {
				// push extra character back
				pData--;
				cbData++;
			    }

			    tok.tokTags[tok.cTags].value[cbValue] = '\0';

			    DbgLog((LOG_TRACE, 4, TEXT("Tag #%d: '%hs' = '%hs'"), tok.cTags,
				    tok.tokTags[tok.cTags].tag,
				    tok.tokTags[tok.cTags].value));

			    tok.cTags++;
			}
		    }

		    hr = m_pInterp->NewToken(tok);
		    if (FAILED(hr))
			return hr;

		    continue;
		}
	    }

	    if (c == ' ' || c == '\t' || c == '\r' || c == '\n') {
		continue;
    #ifdef DO_WE_REALLY_SPECIAL_CASE_NUMBERS
	    } else if (c >= '0' && c <= '9') {
		int num = c - '0';

		while (cbData && (c = *pData, (c >= '0' && c <= '9'))) {
		    num = num * 10 + (c - '0');
		    ++pData;
		    --cbData;
		}

		DbgLog((LOG_TRACE, 2, TEXT("Found a number...%d"), num));
		tok.tokType = TOK_NUMBER;
		tok.tokValue = num;
		hr = m_pInterp->NewToken(tok);

		if (FAILED(hr))
		    return hr;
    #endif
	    } else {
		// it's a string, parse it somehow.
		int cbString = 0;

		char achString[MAX_STRING_LEN];

		char *pString = pData - 1;

		int iSinceNonSpace = 0;

		while (cbString < cbData && cbString < MAX_STRING_LEN-1 &&
					   ((cbString == 0) || (c != '<'))) {
		    if (c == ' ' || c == '\t' || c == '\r' || c == '\n')
			++iSinceNonSpace;
		    else
			iSinceNonSpace = 0;

		    achString[cbString] = c;
		    c = pData[cbString++];
		}

		cbString -= iSinceNonSpace;

		if (cbString == cbData)
		    cbString++;	// normally, don't copy last char, but now we must

		pData += cbString-1;
		cbData -= cbString-1;
		achString[cbString] = '\0';
		DbgLog((LOG_TRACE, 2, TEXT("Found a %d byte string, '%hs'"), cbString, achString));
		tok.tokType = TOK_STRING;
		tok.tokString = m_bReturnCopy ? achString : pString;
		tok.cbString = cbString;
		hr = m_pInterp->NewToken(tok);

		if (FAILED(hr))
		    return hr;
	    }
	}

	return S_OK;
    }

    HRESULT AddString(char *pString, int cString, int newID)
    {
	if (m_cTab == MAX_TOKENS)
	    return E_OUTOFMEMORY;

	m_sTab[m_cTab].pTag = new char[lstrlenA(pString)+1];
	lstrcpyA(m_sTab[m_cTab].pTag, pString);

	// !!! cString?
	m_sTab[m_cTab].token = newID;

	++m_cTab;

	return S_OK;
    }
};
=== C:/Users/treeman/Desktop/windows nt source code\Source\Win2K3\NT\multimedia\dshow\filterus\text\sami\samitab.h ===
TABLE_ENTRY("SAMI", TOK_SAMI)
TABLE_ENTRY("Head", TOK_HEAD)
TABLE_ENTRY("Copyright", TOK_COPYRIGHT)
TABLE_ENTRY("Title", TOK_TITLE)
TABLE_ENTRY("SAMIParam", TOK_SAMIPARAM)
TABLE_ENTRY("STYLE", TOK_STYLE)
TABLE_ENTRY("!--", TOK_COMMENT)
TABLE_ENTRY("Resource", TOK_RESOURCE)
TABLE_ENTRY("Body", TOK_BODY)
TABLE_ENTRY("SYNC", TOK_SYNC)
TABLE_ENTRY("P", TOK_PARA)
TABLE_ENTRY("Command", TOK_COMMAND)
=== C:/Users/treeman/Desktop/windows nt source code\Source\Win2K3\NT\multimedia\dshow\filterus\text\sami\samiread.h ===
// Copyright (c) 1994 - 1997  Microsoft Corporation.  All Rights Reserved.

extern const AMOVIESETUP_FILTER sudSAMIRead;

// {33FACFE0-A9BE-11d0-A520-00A0D10129C0}
DEFINE_GUID(CLSID_SAMIReader, 
0x33facfe0, 0xa9be, 0x11d0, 0xa5, 0x20, 0x0, 0xa0, 0xd1, 0x1, 0x29, 0xc0);

CUnknown *CreateSAMIInstance(LPUNKNOWN lpunk, HRESULT *phr);
=== C:/Users/treeman/Desktop/windows nt source code\Source\Win2K3\NT\multimedia\dshow\filterus\text\sami\sami.cpp ===
#include <streams.h>

// Idea for how to implement:
// Two classes.

// First one looks at raw text, calls second with "tokens" when it finds them.


// !!! notes
// should I just get rid of the "number" type?
// can I have helpers for copying quoted strings?
// standard logic for copying or not copying strings?
// macro/inline function for keeping lpData/cbData in synch?

// !!! SAMIParam--is stuff in a comment tag, or not?  What do I need to look at?
// !!! end of file handling may be wrong, are we giving a big enough duration?


#pragma warning(disable:4355)

#include "rawparse.h"


struct TEXT_ENTRY {
    DWORD	dwStart;
    char *	pText;
    int		cText;
};

#define TABLE_ENTRY(a,b)	b,
enum SAMI_TOKEN {
#include "samitab.h"
};

#undef TABLE_ENTRY
#define TABLE_ENTRY(a,b)	{ a, b },

STRING_ENTRY stabSAMI[] = {
#include "samitab.h"
};

const int ctabSAMI = sizeof(stabSAMI) / sizeof(stabSAMI[0]);

class CSAMIInterpreter : CTokenInterpreter
{
    CRawParser		m_parser;

    // need to keep track of where we are in the file....

    HRESULT NewToken(CToken &tok);
    BOOL    SpecialTagParsing(int token);

    enum SAMIParseState {
	STATE_INITIAL,
	STATE_FOUND_SAMI,
	STATE_IN_HEAD,
	STATE_AFTER_HEAD,
	STATE_IN_COPYRIGHT,
	STATE_IN_TITLE,
	STATE_IN_STYLE,
	STATE_IN_RESOURCE,
	STATE_IN_BODY,
	STATE_IN_SOURCEID,
	STATE_IN_PARA,
	STATE_IN_SYNC,
	STATE_AFTER_BODY,
	STATE_FINAL
	// !!! more?

    } m_state;

    BOOL	m_fWasInCC;

    DWORD	m_msStart;
    DWORD	m_dwActiveStream;
    BOOL	m_fInSource;

    char *	m_SourceID;
    DWORD	m_SourceIDLen;

public:
    CSAMIInterpreter() : m_parser(this, stabSAMI, ctabSAMI),
	    m_streams(NAME("stream list")), m_sourceStyle(NULL),
	    m_styles(NAME("style list")), 
	    m_paraStyle(NULL) {};

    ~CSAMIInterpreter();

    HRESULT ParseSAMI(char *pData, int cbData);

    // more methods to get # of streams, information about streams
    // and also individual text items

    DWORD	m_cStreams;
    DWORD	m_cResources;

    class CStreamInfo {
	public:
	LPSTR		m_streamTag;

	LPSTR		m_streamStyle;
	
	CGenericList<TEXT_ENTRY> m_list;
	CGenericList<TEXT_ENTRY> m_sourcelist;

	CStreamInfo() : m_streamTag(NULL),
		    m_streamStyle(NULL),
		    m_list(NAME("text list")),
		    m_sourcelist(NAME("source list")){}

	~CStreamInfo();
    };

    CGenericList<CStreamInfo> m_streams;
	
    class CStyleInfo {
	public:
	LPSTR		m_styleTag;

	LPSTR		m_styleStyle;

	~CStyleInfo();
    };

    CGenericList<CStyleInfo> m_styles;
	
    
    CStreamInfo	*m_pActiveStream;
    DWORD	m_cbMaxString;
    DWORD	m_cbMaxSource;
    DWORD       m_msMaxToken;
    DWORD	m_dwLength;

    LPSTR	m_sourceStyle;

    LPSTR	m_paraStyle;
	
    HRESULT AddEntry(CStreamInfo *pInfo, CToken& tok);
};

HRESULT CSAMIInterpreter::ParseSAMI(char *pData, int cbData)
{
    m_state = STATE_INITIAL;

    m_cStreams = 0;
    m_cResources = 0;
    m_dwActiveStream = 0xffff;
    m_fInSource =  FALSE;

    m_cbMaxString = 0;
    m_cbMaxSource = 0;
    m_msMaxToken = -1;

    // !!! does this function do anything else?
    HRESULT hr = m_parser.Parse(pData, cbData);

    if (FAILED(hr))
	return hr;

    if (m_state != STATE_FINAL) {
	DbgLog((LOG_ERROR, 1, "didn't see final </SAMI> tag"));
	return E_INVALIDARG;
    }

    return hr;
}

BOOL CSAMIInterpreter::SpecialTagParsing(int token)
{
    if (token != TOK_COMMENT)
	return FALSE;

    return m_state == STATE_IN_STYLE;
}


HRESULT CSAMIInterpreter::AddEntry(CStreamInfo *pStream, CToken &tok)
{

    TEXT_ENTRY *pEntry = new TEXT_ENTRY;
    if (!pEntry)
	return E_OUTOFMEMORY;

    pEntry->dwStart = m_msStart;
    pEntry->pText = tok.tokString;
    pEntry->cText = tok.cbString;

    if (m_fInSource) {
	if (NULL == pStream->m_sourcelist.AddTail(pEntry))
	    return E_OUTOFMEMORY;
    } else {
	if (NULL == pStream->m_list.AddTail(pEntry))
	    return E_OUTOFMEMORY;
    }

    return S_OK;
}

HRESULT CSAMIInterpreter::NewToken(CToken &tok)
{
    HRESULT hr = S_OK;

    switch (m_state) {
	case STATE_INITIAL:
	    if (tok.tokType != TOK_SAMI) {
		DbgLog((LOG_ERROR, 1, "Initial tag not <SAMI>"));
		return E_INVALIDARG;
	    }
	    break;


	case STATE_FINAL:
	    break;
    };

    switch(tok.tokType) {
	case TOK_SAMI:
	    if (!tok.fEnd) {
		if (m_state != STATE_INITIAL) {
		    DbgLog((LOG_ERROR, 1, "<SAMI> tag not at beginning?"));
		    return E_INVALIDARG;
		}
		m_state = STATE_FOUND_SAMI;
	    } else {
		m_state = STATE_FINAL;
	    }
	    break;


	case TOK_HEAD:
	    if (!tok.fEnd) {
		if (m_state != STATE_FOUND_SAMI) {
		    DbgLog((LOG_ERROR, 1, "<HEAD> tag not at beginning?"));
		    return E_INVALIDARG;
		}
		m_state = STATE_IN_HEAD;
	    } else {
		m_state = STATE_AFTER_HEAD;
	    }
	    break;

	case TOK_BODY:
	    if (!tok.fEnd) {
		if (m_state != STATE_AFTER_HEAD) {
		    DbgLog((LOG_ERROR, 1, "<BODY> tag not at expected place?"));
		    return E_INVALIDARG;
		}
		m_state = STATE_IN_BODY;
	    } else {
		m_state = STATE_AFTER_BODY;
	    }
	    break;

	case TOK_STRING:
	    switch (m_state) {
		case STATE_IN_PARA:
		{
		    // !!! might need to concatenate several strings
		    if (m_fInSource) {
                        if (m_msMaxToken != m_msStart)
                        {
			    if (tok.cbString > (int)m_cbMaxSource)
                            {
			        m_cbMaxSource = tok.cbString;
                                m_msMaxToken = m_msStart;
                            } 
                        } else { 
                            m_cbMaxSource += tok.cbString;
                        }
		    } else {
                        if (m_msMaxToken != m_msStart)
                        {
			    if (tok.cbString > (int)m_cbMaxString)
                            {
			        m_cbMaxString = tok.cbString;
                                m_msMaxToken = m_msStart;
                            } 
                        } else { 
                            m_cbMaxString += tok.cbString;
                        }
		    }

		    if (m_pActiveStream)
			hr = AddEntry(m_pActiveStream, tok);
		    else {
			CStreamInfo *pInfo;
			POSITION pos = m_streams.GetHeadPosition();
			while (pInfo = m_streams.GetNext(pos)) {
			    hr = AddEntry(pInfo, tok);

			    if (FAILED(hr))
				break;
			}
		    }

		    m_dwLength = m_msStart;
		}
		    break;

		case STATE_IN_SOURCEID:
		    m_SourceID = tok.tokString;
		    m_SourceIDLen = tok.cbString;
		    break;
		
		case STATE_IN_COPYRIGHT:
		    break;
		
		case STATE_IN_TITLE:
		    DbgLog((LOG_TRACE, 1, "Got title: %s", tok.tokString));
		    break;

		case STATE_IN_STYLE:
		    // !!! really shouldn't be something here....
		    break;

		case STATE_IN_BODY:
		    // !!! ignore strings in body, html headers we don't want?
		    // (or add to html header?)
		    break;
		default:
		    DbgLog((LOG_ERROR, 1, "Got a string in unexpected state #%d", m_state));

		    break;
	    }
	    break;

	case TOK_COPYRIGHT:
	    // handle copyright...
	    if (!tok.fEnd) {
		if (m_state != STATE_IN_HEAD) {
		    DbgLog((LOG_ERROR, 1, "Copyright key not at right place?"));
		    return E_INVALIDARG;
		}

		m_state = STATE_IN_COPYRIGHT;

		// !!! copyright has no end tag???
		m_state = STATE_IN_HEAD; // !!!!
	    } else {
		// check that we've seen the copyright?
		
		if (m_state != STATE_IN_COPYRIGHT) {
		    DbgLog((LOG_ERROR, 1, "/Copyright key not at right place?"));
		    return E_INVALIDARG;
		}

		m_state = STATE_IN_HEAD;
	    }
	    break;

	case TOK_TITLE:
	    // handle title...
	    if (!tok.fEnd) {
		if (m_state != STATE_IN_HEAD) {
		    DbgLog((LOG_ERROR, 1, "Title key not at right place?"));
		    return E_INVALIDARG;
		}

		m_state = STATE_IN_TITLE;
	    } else {
		// check that we've seen the TITLE?
		
		if (m_state != STATE_IN_TITLE) {
		    DbgLog((LOG_ERROR, 1, "/Title key not at right place?"));
		    return E_INVALIDARG;
		}

		m_state = STATE_IN_HEAD;
	    }
	    break;

	case TOK_STYLE:
	    if (!tok.fEnd) {
		if (m_state != STATE_IN_HEAD) {
		    DbgLog((LOG_ERROR, 1, "Style not in header?"));
		    return E_INVALIDARG;
		}

		if (m_cStreams > 0) {
		    DbgLog((LOG_ERROR, 1, "duplicate STYLE key?"));
		    return E_INVALIDARG;
		}

		// !!! check that there's a TYPE key which says "text/css"?

		m_state = STATE_IN_STYLE;
	    } else {
		// check that we've seen a language?
		
		if (m_state != STATE_IN_STYLE) {
		    DbgLog((LOG_ERROR, 1, "/Style key not at right place?"));
		    return E_INVALIDARG;
		}

		if (m_cStreams == 0) {
		    DbgLog((LOG_ERROR, 1, "no streams defined in Style key?"));
		    return E_INVALIDARG;
		}

		m_state = STATE_IN_HEAD;
	    }
	    break;

	case TOK_RESOURCE:
	    if (tok.cTags != 1)
		return E_INVALIDARG;

	    if (!tok.fEnd) {
		if (m_state != STATE_IN_HEAD) {
		    DbgLog((LOG_ERROR, 1, "Resource key not at right place?"));
		    return E_INVALIDARG;
		}

		DbgLog((LOG_TRACE, 1, "Adding new resource tag %s", tok.tokTags[0].tag));

		m_parser.AddString(tok.tokTags[0].tag, 0, 200 + m_cResources++);

		m_state = STATE_IN_RESOURCE;

		// !!! resource has no end tag???
		m_state = STATE_IN_HEAD; // !!!!
	    } else {
		if (m_state != STATE_IN_RESOURCE) {
		    DbgLog((LOG_ERROR, 1, "/Res key not at right place?"));
		    return E_INVALIDARG;
		}
		m_state = STATE_IN_HEAD;
	    }
	    break;

	case TOK_SAMIPARAM:
	    if (m_state != STATE_IN_HEAD) {
		DbgLog((LOG_ERROR, 1, "CC key not at right place?"));
		return E_INVALIDARG;
	    }

	    // !!! process tags....
	    break;

	case TOK_COMMENT:
	    if (m_state == STATE_IN_STYLE) {
		// tags are the style names....
		for (int i = 0; i < tok.cTags; i++) {
		    if (tok.tokTags[i].tag[0] == '.') {
			DbgLog((LOG_TRACE, 1, "Found new stream named %s '%s'",
				&tok.tokTags[i].tag[1],
			        tok.tokTags[i].value));
			
			// !!!
			CStreamInfo *pStream = new CStreamInfo();
			if (!pStream)
			    return E_OUTOFMEMORY;

			pStream->m_streamTag = new char[lstrlenA(&tok.tokTags[i].tag[1])+1];
			if (!pStream->m_streamTag)
			    return E_OUTOFMEMORY;

			lstrcpyA(pStream->m_streamTag, &tok.tokTags[i].tag[1]);

			pStream->m_streamStyle = new char[lstrlenA(tok.tokTags[i].value)+1];
			if (!pStream->m_streamStyle)
			    return E_OUTOFMEMORY;

			lstrcpyA(pStream->m_streamStyle, tok.tokTags[i].value);

			if (NULL == m_streams.AddTail(pStream))
			    return E_OUTOFMEMORY;

			++m_cStreams;
		    } else if (tok.tokTags[i].tag[0] == '#') {
			DbgLog((LOG_TRACE, 1, "Found style tag named %s '%s'",
				&tok.tokTags[i].tag[1],
			        tok.tokTags[i].value));

			// !!! should we check that it says "source"?
			if (lstrcmpiA("Source", &tok.tokTags[i].tag[1]) == 0) {
			    m_sourceStyle = new char[lstrlenA(tok.tokTags[i].value)+1];
			    if (!m_sourceStyle)
				return E_OUTOFMEMORY;

			    lstrcpyA(m_sourceStyle, tok.tokTags[i].value);
			} else {
			    CStyleInfo *pStyle = new CStyleInfo;
			    if (!pStyle)
				return E_OUTOFMEMORY;

			    // copy style tag without the #
			    pStyle->m_styleTag = new char[lstrlenA(tok.tokTags[i].tag)];
			    if (!pStyle->m_styleTag)
				return E_OUTOFMEMORY;

			    lstrcpyA(pStyle->m_styleTag, tok.tokTags[i].tag+1);

			    pStyle->m_styleStyle = new char[lstrlenA(tok.tokTags[i].value)+1];
			    if (!pStyle->m_styleStyle)
				return E_OUTOFMEMORY;

			    lstrcpyA(pStyle->m_styleStyle, tok.tokTags[i].value);

			    m_styles.AddTail(pStyle);
			}
		    } else {
			// what's this?
			DbgLog((LOG_TRACE, 1, "Found extra style tag: %s '%s'",
				tok.tokTags[i].tag,
			        tok.tokTags[i].value));

			if (lstrcmpiA("P", tok.tokTags[i].tag) == 0) {
			    m_paraStyle = new char[lstrlenA(tok.tokTags[i].value)+1];
			    if (!m_paraStyle)
				return E_OUTOFMEMORY;

			    lstrcpyA(m_paraStyle, tok.tokTags[i].value);
			} else {
			    // !!!
			}
		    }
		}
	    } else {
		// !!! random other comment???
	    }
	    break;

	case TOK_PARA:
	    if (!tok.fEnd) {
		if ((m_state != STATE_IN_SYNC) && (m_state != STATE_IN_PARA)) {
		    DbgLog((LOG_ERROR, 1, "P key not at right place?"));
		    return E_INVALIDARG;
		}

		if (m_cStreams == 0) {
		    DbgLog((LOG_ERROR, 1, "CC data with no streams defined?"));

		    // !!! we could handle this case specially, and default one stream....
		
		    return E_INVALIDARG;
		}

		int tagClass = -1;
		BOOL fSource = FALSE;
		if (tok.cTags == 0) {
		    DbgLog((LOG_TRACE, 1, "P token with no tags???"));
		
		}

		for (int i = 0; i < tok.cTags; i++) {
		    if (lstrcmpiA("class", tok.tokTags[i].tag) == 0) {
			tagClass = i;
		    } else if (lstrcmpiA("ID", tok.tokTags[i].tag) == 0) {
			if (lstrcmpiA("Source", tok.tokTags[i].value) != 0) {
			    DbgLog((LOG_TRACE, 1, "P token with odd ID '%s'?",
				    tok.tokTags[i].value));
			    continue;
			}
			fSource = TRUE;
		    } else {
			DbgLog((LOG_TRACE, 1, "P token with odd tag '%s'?",
				tok.tokTags[i].tag));
		    }
		}

		CStreamInfo *pInfo;
		DWORD dwActiveStream = 0;
		m_fInSource = fSource;
		BOOL	fFound = FALSE;

		if (tagClass == -1) {
		    DbgLog((LOG_TRACE, 1, "P token with no class?"));
		} else {
		    POSITION pos = m_streams.GetHeadPosition();
		    while (pInfo = m_streams.GetNext(pos)) {
			if (lstrcmpA(pInfo->m_streamTag, tok.tokTags[tagClass].value) == 0) {
			    fFound = TRUE;
			    break;
			}
			++dwActiveStream;
		    }

		    if (!fFound) {
			DbgLog((LOG_TRACE, 1, "Didn't find stream '%s'",
				tok.tokTags[tagClass].value));
		    }
		}
		
		if (fFound) {
		    m_pActiveStream = pInfo;

		    m_dwActiveStream = dwActiveStream;
		} else {
		    m_pActiveStream = NULL;

		    m_dwActiveStream = (DWORD) -1;
		}
		
		m_state = STATE_IN_PARA;
	    } else {
		if (m_state != STATE_IN_PARA) {
		    DbgLog((LOG_ERROR, 1, "/P key not at right place?"));
		    return E_INVALIDARG;
		}

		m_state = STATE_IN_SYNC;
	    }


	    break;

	case TOK_SYNC:
	    if (!tok.fEnd) {
		// get the start tag....
		BOOL fStart = FALSE;

		for (int i = 0; i < tok.cTags; i++) {
		    if (lstrcmpiA("start", tok.tokTags[i].tag) == 0) {
			fStart = TRUE;
			m_msStart = atoiA(tok.tokTags[i].value);
		    }
		}

		if (!fStart) {
		    DbgLog((LOG_ERROR, 1, "CC key missing start?"));
		    return E_INVALIDARG;
		}
		
		DbgLog((LOG_TRACE, 2, "Found Sync key: start = %d", m_msStart));

		m_state = STATE_IN_SYNC;
	    } else {
		if ((m_state != STATE_IN_SYNC) && (m_state != STATE_IN_PARA)) {
		    DbgLog((LOG_ERROR, 1, "/sync key not at right place?"));
		    return E_INVALIDARG;
		}

		m_state = STATE_IN_BODY;
	    }
	    break;

	default:
	    if (tok.tokType >= 100 && tok.tokType < 100 + (int)m_cStreams) {
		DbgLog((LOG_TRACE, 4, "Switch to stream #%d", tok.tokType - 100));

		m_dwActiveStream = tok.tokType - 100;
		
	    } else if (tok.tokType >= 200 && tok.tokType < 200 + (int)m_cStreams) {
		DbgLog((LOG_TRACE, 4, "Switch to resource #%d", tok.tokType - 200));
	    } else {
		DbgLog((LOG_ERROR, 0, "Unexpected token %d", tok.tokType));
// !!!		ASSERT(0);
	    }
	    break;
    };





    return hr;
}

CSAMIInterpreter::~CSAMIInterpreter()
{
    CStreamInfo *pInfo;
    POSITION pos = m_streams.GetHeadPosition();
    while (pInfo = m_streams.GetNext(pos)) {
	delete pInfo;
    }

    CStyleInfo *pStyle;
    pos = m_styles.GetHeadPosition();
    while (pStyle = m_styles.GetNext(pos)) {
	delete pStyle;
    }

    delete [] m_paraStyle;
    delete [] m_sourceStyle;
}

CSAMIInterpreter::CStreamInfo::~CStreamInfo()
{
    POSITION pos = m_list.GetHeadPosition();

    while (pos) {
	TEXT_ENTRY *pEntry = m_list.GetNext(pos);

	delete pEntry;
    }

    pos = m_sourcelist.GetHeadPosition();

    while (pos) {
	TEXT_ENTRY *pEntry = m_sourcelist.GetNext(pos);

	delete pEntry;
    }

    delete[] m_streamTag;
    delete[] m_streamStyle;
}

CSAMIInterpreter::CStyleInfo::~CStyleInfo()
{
    delete[] m_styleTag;
    delete[] m_styleStyle;
}



BOOL FindValueInStyle(LPSTR lpStyle, LPSTR lpTag, LPSTR& lpOut, int &cbOut)
{
    char achThisTag[100];
    int	 cbThisTag = 0;

    enum _findstate { TAG, AFTERTAG, VALUE, QUOTEDVALUE, AFTERVALUE };

    _findstate state = AFTERVALUE;
    char c;
    while (c = *lpStyle++) {

	switch (state) {
	    case TAG:
		if (c == ':') {
		    achThisTag[cbThisTag] = '\0';
		    state = AFTERTAG;
		} else if (cbThisTag < 99)
		    achThisTag[cbThisTag++] = c;
		break;

	    case AFTERTAG:
		if (c == '"') {
		    lpOut = lpStyle;
		    cbOut = 0;
		    state = QUOTEDVALUE;
		} else if (c != ' ' && c != '\t' && c != '\r' && c != '\n') {
		    state = VALUE;
		    lpOut = lpStyle - 1;
		    cbOut = 1;
		}
		
		break;

	    case VALUE:
		if (c == ';') {
		    if (lstrcmpiA(achThisTag, lpTag) == 0)
			return TRUE;
		    
		    state = AFTERVALUE;
		} else
		    cbOut++;
		    
		break;

	    case QUOTEDVALUE:
		if (c == '"') {
		    if (lstrcmpiA(achThisTag, lpTag) == 0)
			return TRUE;
		    
		    state = AFTERVALUE;
		} else
		    cbOut++;
		break;

	    case AFTERVALUE:
		if (c != ' ' && c != '\t' && c != '\r' && c != '\n') {
		    cbThisTag = 1;
		    achThisTag[0] = c;
		    state = TAG;
		}
		break;
	}

    }

    return FALSE;
}
=== C:/Users/treeman/Desktop/windows nt source code\Source\Win2K3\NT\multimedia\dshow\filterus\text\sami\samiread.cpp ===
// Copyright (c) 1994 - 1998  Microsoft Corporation.  All Rights Reserved.

//
// CC file parser
//

#include <streams.h>
#include <windowsx.h>

#ifdef FILTER_DLL
#include <initguid.h>
#endif

#include "samiread.h"

#include "sami.cpp"

#include "simpread.h"

// we use a 1024 character guard because it's wsprintf's limit
#define CCH_WSPRINTFMAX 1024

// !!! Things left to do:
//
// Support >1 language, either via a switch or >1 output pin
// expose descriptive audio somehow
// look at samiparam length, other samiparams
//
// Should switch to passing Unicode SCRIPTCOMMAND data, rather than text
//

//
// CSAMIRead
//
class CSAMIRead : public CSimpleReader, public IAMStreamSelect {
public:

    // Construct our filter
    static CUnknown *CreateInstance(LPUNKNOWN lpunk, HRESULT *phr);

    CCritSec m_cStateLock;      // Lock this when a function accesses
                                // the filter state.
                                // Generally _all_ functions, since access to this
                                // filter will be by multiple threads.

private:

    DECLARE_IUNKNOWN

    STDMETHODIMP NonDelegatingQueryInterface(REFIID riid,void **ppv);

    CSAMIRead(TCHAR *, LPUNKNOWN, HRESULT *);
    ~CSAMIRead();

    /* IAMStreamSelect */

    //  Returns total count of streams
    STDMETHODIMP Count(
        /*[out]*/ DWORD *pcStreams);      // Count of logical streams

    //  Return info for a given stream - S_FALSE if iIndex out of range
    //  The first steam in each group is the default
    STDMETHODIMP Info(
        /*[in]*/ long iIndex,              // 0-based index
        /*[out]*/ AM_MEDIA_TYPE **ppmt,   // Media type - optional
                                          // Use DeleteMediaType to free
        /*[out]*/ DWORD *pdwFlags,        // flags - optional
        /*[out]*/ LCID *plcid,            // Language id - optional
        /*[out]*/ DWORD *pdwGroup,        // Logical group - 0-based index - optional
        /*[out]*/ WCHAR **ppszName,       // Name - optional - free with CoTaskMemFree
                                          // Can return NULL
        /*[out]*/ IUnknown **ppPin,       // Associated pin - returns NULL - optional
                                          // if no associated pin
        /*[out]*/ IUnknown **ppUnk);      // Stream specific interface

    //  Enable or disable a given stream
    STDMETHODIMP Enable(
        /*[in]*/  long iIndex,
        /*[in]*/  DWORD dwFlags);

    // pure CSimpleReader overrides
    HRESULT ParseNewFile();
    HRESULT CheckMediaType(const CMediaType* mtOut);
    LONG StartFrom(LONG sStart);
    HRESULT FillBuffer(IMediaSample *pSample, DWORD dwStart, DWORD *pcSamples);
    LONG RefTimeToSample(CRefTime t);
    CRefTime SampleToRefTime(LONG s);
    ULONG GetMaxSampleSize();

    DWORD	m_dwMaxPosition;
    BYTE *	m_lpFile;
    DWORD	m_cbFile;
    DWORD	m_dwLastPosition;

    CSAMIInterpreter	m_interp;

    CSAMIInterpreter::CStreamInfo *	m_pstream;
    CSAMIInterpreter::CStyleInfo *	m_pstyle;
};




//
// setup data
//

const AMOVIESETUP_MEDIATYPE
psudSAMIReadType[] = { { &MEDIATYPE_Stream       // 1. clsMajorType
                        , &CLSID_SAMIReader } }; //    clsMinorType


const AMOVIESETUP_MEDIATYPE
sudSAMIReadOutType = { &MEDIATYPE_Text       // 1. clsMajorType
                       , &MEDIASUBTYPE_NULL }; //    clsMinorType

const AMOVIESETUP_PIN
psudSAMIReadPins[] =  { { L"Input"             // strName
		    , FALSE                // bRendered
		    , FALSE                // bOutput
		    , FALSE                // bZero
		    , FALSE                // bMany
		    , &CLSID_NULL          // clsConnectsToFilter
		    , L""                  // strConnectsToPin
		    , 1                    // nTypes
		    , psudSAMIReadType }, // lpTypes
		         { L"Output"             // strName
		    , FALSE                // bRendered
		    , TRUE                 // bOutput
		    , FALSE                // bZero
		    , FALSE                // bMany
		    , &CLSID_NULL          // clsConnectsToFilter
		    , L""                  // strConnectsToPin
		    , 1                    // nTypes
		    , &sudSAMIReadOutType } }; // lpTypes

const AMOVIESETUP_FILTER
sudSAMIRead = { &CLSID_SAMIReader     // clsID
               , L"SAMI (CC) Parser"        // strName
               , MERIT_UNLIKELY        // dwMerit
               , 2                     // nPins
               , psudSAMIReadPins };   // lpPin

#ifdef FILTER_DLL
// COM global table of objects available in this dll
CFactoryTemplate g_Templates[] = {

    { L"SAMI (CC) file parser"
    , &CLSID_SAMIReader
    , CreateSAMIInstance
    , NULL
    , &sudSAMIRead }
};
int g_cTemplates = sizeof(g_Templates) / sizeof(g_Templates[0]);

// exported entry points for registration and
// unregistration (in this case they only call
// through to default implmentations).
//
STDAPI DllRegisterServer()
{
  return AMovieDllRegisterServer2( TRUE );
}

STDAPI DllUnregisterServer()
{
  return AMovieDllRegisterServer2( FALSE );
}
#endif

//
// CSAMIRead::Constructor
//
CSAMIRead::CSAMIRead(TCHAR *pName, LPUNKNOWN lpunk, HRESULT *phr)
    : CSimpleReader(pName, lpunk, CLSID_SAMIReader, &m_cStateLock, phr),
	m_lpFile(NULL)
{

    CAutoLock l(&m_cStateLock);

    DbgLog((LOG_TRACE, 1, TEXT("CSAMIRead created")));
}


//
// CSAMIRead::Destructor
//
CSAMIRead::~CSAMIRead(void) {
    // !!! NukeLyrics();
    
    delete[] m_lpFile;
    DbgLog((LOG_TRACE, 1, TEXT("CSAMIRead destroyed")) );
}


CUnknown *CreateSAMIInstance(LPUNKNOWN lpunk, HRESULT *phr)
{
    return CSAMIRead::CreateInstance(lpunk, phr);
}

//
// CreateInstance
//
// Called by CoCreateInstance to create our filter.
CUnknown *CSAMIRead::CreateInstance(LPUNKNOWN lpunk, HRESULT *phr) {

    CUnknown *punk = new CSAMIRead(NAME("SAMI parsing filter"), lpunk, phr);
    if (punk == NULL) {
        *phr = E_OUTOFMEMORY;
    }
    return punk;
}


/* Override this to say what interfaces we support and where */

STDMETHODIMP
CSAMIRead::NonDelegatingQueryInterface(REFIID riid,void ** ppv)
{
    /* Do we have this interface? */
    if (riid == IID_IAMStreamSelect) {
        return GetInterface((IAMStreamSelect *)this, ppv);
    }

    return CSimpleReader::NonDelegatingQueryInterface(riid,ppv);
}


HRESULT CSAMIRead::ParseNewFile()
{
    HRESULT         hr = NOERROR;

    LONGLONG llTotal, llAvailable;

    for (;;) {
	hr = m_pAsyncReader->Length(&llTotal, &llAvailable);
	if (FAILED(hr))
	    return hr;

	if (hr != VFW_S_ESTIMATED)
	    break;	// success....

        // need to dispatch messages if on the graph thread as urlmon
        // won't download o/w. a better fix would be to block SyncRead
        // which does this for us.
        MSG Message;
        while (PeekMessage(&Message, NULL, 0, 0, TRUE))
        {
            TranslateMessage(&Message);
            DispatchMessage(&Message);
        }
        
	Sleep(10);	// wait until file has finished reading....
    }

    m_cbFile = (DWORD) llTotal;

    m_lpFile = new BYTE[m_cbFile];

    if (!m_lpFile)
	goto readerror;
    
    /* Try to read whole file */
    hr = m_pAsyncReader->SyncRead(0, m_cbFile, m_lpFile);

    if (hr != S_OK)
        goto error;


    hr = m_interp.ParseSAMI((char *) m_lpFile, m_cbFile);

    if (FAILED(hr))
	goto error;

    m_pstream = m_interp.m_streams.GetHead();
    if(!m_pstream) {
        return E_FAIL;
    }
    
    m_pstyle = m_interp.m_styles.GetHead();


    {
	CMediaType mtText;

	mtText.SetType(&MEDIATYPE_Text);
	mtText.SetFormatType(&GUID_NULL);
	mtText.SetVariableSize();
	mtText.SetTemporalCompression(FALSE);
	// !!! anything else?

	SetOutputMediaType(&mtText);
    }
    

    m_sLength = m_interp.m_dwLength + 1;
    
    return hr;

    hr = E_OUTOFMEMORY;
    goto error;

readerror:
    hr = VFW_E_INVALID_FILE_FORMAT;

error:
    return hr;
}


ULONG CSAMIRead::GetMaxSampleSize()
{
    // add in a CCH_WSPRINTFMAX guard for convenience (for wsprintf)
    return m_interp.m_cbMaxString + m_interp.m_cbMaxSource +
	    lstrlenA(m_interp.m_paraStyle) * 2 + lstrlenA(m_interp.m_sourceStyle) + 300 + // !!!
        CCH_WSPRINTFMAX;  
}


// !!! rounding
// returns the sample number showing at time t
LONG
CSAMIRead::RefTimeToSample(CRefTime t)
{
    // Rounding down
    LONG s = (LONG) ((t.GetUnits() * MILLISECONDS) / UNITS);
    return s;
}

CRefTime
CSAMIRead::SampleToRefTime(LONG s)
{
    // Rounding up
    return llMulDiv( s, UNITS, MILLISECONDS, MILLISECONDS-1 );
}


HRESULT
CSAMIRead::CheckMediaType(const CMediaType* pmt)
{
    if (*(pmt->Type()) != MEDIATYPE_Stream)
        return E_INVALIDARG;

    if (*(pmt->Subtype()) != CLSID_SAMIReader)
        return E_INVALIDARG;

    return S_OK;
}


LONG CSAMIRead::StartFrom(LONG sStart)
{
    LONG sLast = 0;

    POSITION pos = m_pstream->m_list.GetHeadPosition();

    while (pos) {
	TEXT_ENTRY *pText = m_pstream->m_list.GetNext(pos);
	if (pText->dwStart > (DWORD) sStart)
	    break;
	sLast = (LONG) pText->dwStart;
    }
    
    return sLast;
}

// it's a bug not to allocate enough. but avoid overruns
// in retail builds in case GetMaxSampleSize is wrong.
#define CHK_OVERRUN(cch) \
        if(dwTotalSize + cch >= dwSize) { \
            DbgBreak("FillBuffer: buffer full");\
            return E_FAIL; \
        }


HRESULT CSAMIRead::FillBuffer(IMediaSample *pSample, DWORD dwStart, DWORD *pdwSamples)
{
    PBYTE pbuf;
    const DWORD lSamples = 1;

    DWORD dwSize = pSample->GetSize();
    
    HRESULT hr = pSample->GetPointer(&pbuf);
    if (FAILED(hr)) {
	DbgLog((LOG_ERROR,1,TEXT("pSample->GetPointer failed!")));
	pSample->Release();
	return E_OUTOFMEMORY;
    }

    // !!! keep locked while we're looking at the current stream
    CAutoLock lck(&m_cStateLock);

    DWORD dwTotalSize = 0;

    POSITION pos;
    TEXT_ENTRY *pText;

    // is there a "source" line?
    if (m_pstream->m_sourcelist.GetCount()) {

        CHK_OVERRUN(CCH_WSPRINTFMAX);

	// insert paragraph tag with inline styles....
	dwTotalSize += wsprintfA((char *) pbuf+dwTotalSize,
				"<P STYLE=\"%hs %hs %hs\">",
				 m_interp.m_paraStyle ? m_interp.m_paraStyle : "",
				 m_pstream->m_streamStyle ? m_pstream->m_streamStyle : "",
				 m_interp.m_sourceStyle ? m_interp.m_sourceStyle : "");


	// first, find the current 'source' tag
	pos = m_pstream->m_sourcelist.GetHeadPosition();

	pText = NULL;
	while (pos) {
	    TEXT_ENTRY *pNextText = m_pstream->m_sourcelist.GetNext(pos);
	    if (pNextText->dwStart > dwStart)
		break;

	    pText = pNextText;
	}

	if (pText) {

            CHK_OVERRUN(pText->cText + 1);
	    ASSERT(pText->cText + dwTotalSize < (int) dwSize);
	    lstrcpynA((LPSTR) pbuf+dwTotalSize, pText->pText, pText->cText+1);

	    dwTotalSize += pText->cText;
	}

        CHK_OVERRUN(CCH_WSPRINTFMAX);
	dwTotalSize += wsprintfA((char *) pbuf+dwTotalSize, "</P>");
    }


    CHK_OVERRUN(CCH_WSPRINTFMAX);
    // !!! insert a paragraph break?
	// insert paragraph tag with inline styles....
	dwTotalSize += wsprintfA((char *) pbuf+dwTotalSize,
				"<P STYLE=\"%hs %hs %hs\">",
				 m_interp.m_paraStyle ? m_interp.m_paraStyle : "",
				 m_pstream->m_streamStyle ? m_pstream->m_streamStyle : "",
				 m_pstyle && m_pstyle->m_styleStyle ? m_pstyle->m_styleStyle : "");
    
    // now go back and get body text
    pos = m_pstream->m_list.GetHeadPosition();
    pText = NULL;

    POSITION posReal = pos;
    TEXT_ENTRY *pReal = NULL;
    
    // find the first block of text that's current
    while (pos) {
	TEXT_ENTRY *pNextText = m_pstream->m_list.Get(pos); // peek, don't advance...
	if (pNextText->dwStart > dwStart) {
	    pos = posReal;
	    pText = pReal;
	    break;
	}

	pText = m_pstream->m_list.GetNext(pos);

	if ((pReal == NULL) || (pText->dwStart > pReal->dwStart)) {
	    pReal = pText;
	    posReal = pos;
	}
    }

    DWORD dwThisStart = pText ? pText->dwStart : 0;
    
    if (pText) {
	for (;;) {    
	    ASSERT(pText->cText + dwTotalSize < (int) dwSize);

            CHK_OVERRUN(pText->cText + 1);
	    lstrcpynA((LPSTR) pbuf+dwTotalSize, pText->pText, pText->cText+1);

	    dwTotalSize += pText->cText;

	    // if there are other text blocks with the same timestamp, copy them too
	    if (!pos)
		break;
	    
	    pText = m_pstream->m_list.GetNext(pos);
	    if (pText->dwStart > dwThisStart)
		break;
	}
    } else {
	pText = m_pstream->m_list.GetNext(pos);
    }


    // !!! insert HTML footer?
    
    pbuf[dwTotalSize] = 0;
    hr = pSample->SetActualDataLength(dwTotalSize+1);
    ASSERT(SUCCEEDED(hr));

    *pdwSamples = pText ? pText->dwStart - dwThisStart : m_interp.m_dwLength - dwThisStart;

    if (0 == *pdwSamples)
        *pdwSamples = 1;

    // mark as a sync point if it should be....
    pSample->SetSyncPoint(TRUE);  // !!!

    return S_OK;
}


//  Returns total count of streams
STDMETHODIMP CSAMIRead::Count(
    /*[out]*/ DWORD *pcStreams)       // Count of logical streams
{
    CAutoLock lck(&m_cStateLock);

    *pcStreams = m_interp.m_streams.GetCount() + m_interp.m_styles.GetCount();

    return S_OK;
}

extern "C" {
typedef BOOL (*Rfc1766ToLcidA_t)(LCID *, LPCSTR);
}

HRESULT WSTRFromAnsi(WCHAR **pb, LPSTR p, int cb)
{
    if (!p)
	return E_NOTIMPL;
    
    *pb = (WCHAR *) CoTaskMemAlloc((cb + 1) * sizeof(WCHAR));

    if (!*pb)
	return E_OUTOFMEMORY;
    
    int len = MultiByteToWideChar( CP_ACP
				   , 0L
				   , p	
				   , cb
				   , *pb
				   , cb + 1 );

    if (len < cb+1)
	(*pb)[len] = L'\0';
    
    return S_OK;
}

//  Return info for a given stream - S_FALSE if iIndex out of range
//  The first steam in each group is the default
STDMETHODIMP CSAMIRead::Info(
    /*[in]*/ long iIndex,              // 0-based index
    /*[out]*/ AM_MEDIA_TYPE **ppmt,   // Media type - optional
                                      // Use DeleteMediaType to free
    /*[out]*/ DWORD *pdwFlags,        // flags - optional
    /*[out]*/ LCID *plcid,            // Language id
    /*[out]*/ DWORD *pdwGroup,        // Logical group - 0-based index - optional
    /*[out]*/ WCHAR **ppszName,       // Name - optional - free with CoTaskMemFree
                                      // Can return NULL
    /*[out]*/ IUnknown **ppPin,       // Pin if any
    /*[out]*/ IUnknown **ppUnk)       // Stream specific interface
{
    CAutoLock lck(&m_cStateLock);

    /*  Find the stream corresponding to this one that has a pin */
    CBasePin *pPin = GetPin(0);
    ASSERT(pPin != NULL);

    if (iIndex < m_interp.m_streams.GetCount()) {
	CSAMIInterpreter::CStreamInfo *pstream = NULL;

	POSITION pos = m_interp.m_streams.GetHeadPosition();
	while (iIndex-- >= 0) {
	    pstream = m_interp.m_streams.GetNext(pos);

	    if (pstream == NULL)
		return S_FALSE;
	}
	if (pdwFlags) {
	    *pdwFlags = pstream == m_pstream ? AMSTREAMSELECTINFO_ENABLED : 0;
	}
	if (ppUnk) {
	    *ppUnk = NULL;
	}
	if (pdwGroup) {
	    *pdwGroup = 0;
	}
	if (ppmt) {
	    CMediaType mtText;

	    mtText.SetType(&MEDIATYPE_Text);
	    mtText.SetSubtype(&GUID_NULL);
	    mtText.SetFormatType(&GUID_NULL);
	    mtText.SetVariableSize();
	    mtText.SetTemporalCompression(FALSE);
	    *ppmt = CreateMediaType(&mtText);
	}
	if (plcid) {
	    *plcid = 0;

	    LPSTR lpLang; int cbLang;
	    if (FindValueInStyle(pstream->m_streamStyle, "lang", lpLang, cbLang)) {
		// !!! load MLANG.DLL, find Rfc1766ToLcidA and call it
		UINT uOldErrorMode = SetErrorMode (SEM_NOOPENFILEERRORBOX);
		HINSTANCE hMLangDLL = LoadLibrary (TEXT("MLANG.DLL"));
		SetErrorMode (uOldErrorMode);

		if (hMLangDLL) {
		    Rfc1766ToLcidA_t pfnRfc1766ToLcidA;

		    pfnRfc1766ToLcidA = (Rfc1766ToLcidA_t)
					GetProcAddress (hMLangDLL, "Rfc1766ToLcidA");

		    if (pfnRfc1766ToLcidA) {
			char *p = new char[cbLang + 1];
			if (p) {
			    memcpy(p, lpLang, cbLang);
			    p[cbLang] = '\0';
			    pfnRfc1766ToLcidA(plcid, p);
			    delete[] p;

			    DbgLog((LOG_TRACE, 2, "Rfc1766ToLcidA(%hs) returned %x", pstream->m_streamTag, *plcid));
			}
		    } else {
			DbgLog((LOG_TRACE, 2, "Couldn't find Rfc1766ToLcidA in MLANG.DLL"));
		    }

		    FreeLibrary(hMLangDLL);
		} else {
		    DbgLog((LOG_TRACE, 2, "Couldn't find MLANG.DLL"));
		}
	    }
	}
	if (ppszName) {
	    *ppszName = NULL;	// !!! get name

	    LPSTR lpName; int cbName;
	    if (FindValueInStyle(pstream->m_streamStyle, "name", lpName, cbName)) {
		WSTRFromAnsi(ppszName, lpName, cbName); 
	    }
	}
    } else {
	CSAMIInterpreter::CStyleInfo *pstyle = NULL;

	iIndex -= m_interp.m_streams.GetCount();
	POSITION pos = m_interp.m_styles.GetHeadPosition();
	while (iIndex-- >= 0) {
	    pstyle = m_interp.m_styles.GetNext(pos);

	    if (pstyle == NULL)
		return S_FALSE;
	}
	if (pdwFlags) {
	    *pdwFlags = pstyle == m_pstyle ? AMSTREAMSELECTINFO_ENABLED : 0;
	}
	if (ppUnk) {
	    *ppUnk = NULL;
	}
	if (pdwGroup) {
	    *pdwGroup = 1;
	}
	if (ppmt) {
	    *ppmt = NULL;
	}
	if (plcid) {
	    *plcid = 0;
	}
	if (ppszName) {
	    *ppszName = NULL;	// !!! get name

	    LPSTR lpName; int cbName;
	    if (FindValueInStyle(pstyle->m_styleStyle, "name", lpName, cbName)) {
		WSTRFromAnsi(ppszName, lpName, cbName); 
	    }
	}
    }
    
    if (ppPin) {
        pPin->QueryInterface(IID_IUnknown, (void**)ppPin);
    }
    return S_OK;
}

//  Enable or disable a given stream
STDMETHODIMP CSAMIRead::Enable(
    /*[in]*/  long iIndex,
    /*[in]*/  DWORD dwFlags)
{
    if (!(dwFlags & AMSTREAMSELECTENABLE_ENABLE)) {
        return E_NOTIMPL;
    }

    CAutoLock lck(&m_cStateLock);

    if (iIndex < m_interp.m_streams.GetCount()) {
	/*  Find the stream from the index */
	CSAMIInterpreter::CStreamInfo *pstream = NULL;

	POSITION pos = m_interp.m_streams.GetHeadPosition();
	while (iIndex-- >= 0) {
	    pstream = m_interp.m_streams.GetNext(pos);

	    if (pstream == NULL)
		return E_INVALIDARG;
	}

	m_pstream = pstream;
    } else {
	iIndex -= m_interp.m_streams.GetCount();
	
	/*  Find the stream from the index */
	CSAMIInterpreter::CStyleInfo *pstyle = NULL;

	POSITION pos = m_interp.m_styles.GetHeadPosition();
	while (iIndex-- >= 0) {
	    pstyle = m_interp.m_styles.GetNext(pos);

	    if (pstyle == NULL)
		return E_INVALIDARG;
	}

	m_pstyle = pstyle;

    }
    return S_OK;
}
=== C:/Users/treeman/Desktop/windows nt source code\Source\Win2K3\NT\multimedia\dshow\filterus\text\textrend\textrend.h ===
// Copyright (c) 1997  Microsoft Corporation.  All Rights Reserved.
DEFINE_GUID(IID_ITextThing,
0x48025244, 0x2d39, 0x11ce, 0x87, 0x5d, 0x0, 0x60, 0x8c, 0xb7, 0x80, 0x66);


typedef HRESULT (* TEXTEVENTFN)(void *, LPSTR); 

interface ITextThing : IUnknown
{
    virtual HRESULT SetEventTarget(void * pContext, TEXTEVENTFN fn) = 0;
};


DEFINE_GUID(CLSID_TextThing,
0x48025243, 0x2d39, 0x11ce, 0x87, 0x5d, 0x0, 0x60, 0x8c, 0xb7, 0x80, 0x66);

#ifdef __STREAMS__

extern const AMOVIESETUP_FILTER sudTextRend;

class CTextThing : public CBaseRenderer, public ITextThing
{
public:

    static CUnknown * WINAPI CreateInstance(LPUNKNOWN pUnk, HRESULT *phr);

    CTextThing(LPUNKNOWN pUnk,HRESULT *phr);
    ~CTextThing();

    DECLARE_IUNKNOWN
	    
    STDMETHODIMP NonDelegatingQueryInterface(REFIID, void **);

    HRESULT CheckMediaType(const CMediaType *pmt);
    HRESULT SetMediaType(const CMediaType *pmt);
    HRESULT DoRenderSample(IMediaSample *pMediaSample);
    void OnReceiveFirstSample(IMediaSample *pMediaSample);
    void DrawText(IMediaSample *pMediaSample);

    HRESULT SetEventTarget(void * pContext, TEXTEVENTFN fn);
    void *m_pContext;
    TEXTEVENTFN m_pfn;

    BOOL m_fOldTextFormat;
}; // CTextThing


#endif
=== C:/Users/treeman/Desktop/windows nt source code\Source\Win2K3\NT\multimedia\dshow\filterus\text\textrend\textrend.cpp ===
// Copyright (c) 1997 - 1998  Microsoft Corporation.  All Rights Reserved.
#include <streams.h>
#ifdef FILTER_DLL
#include <initguid.h>
#endif

#pragma warning(disable:4355)

#include "textrend.h"

// Setup data

const AMOVIESETUP_MEDIATYPE sudTRPinTypes[] =
{
    { &MEDIATYPE_ScriptCommand, &MEDIASUBTYPE_NULL },
    { &MEDIATYPE_Text, &MEDIASUBTYPE_NULL }
};

const AMOVIESETUP_PIN sudTRPin =
{
    L"Input",                     // The Pins name
    TRUE,                         // Is rendered
    FALSE,                        // Is an output pin
    FALSE,                        // Allowed none
    FALSE,                        // Allowed many
    &CLSID_NULL,                  // Connects to filter
    NULL,                         // Connects to pin
    NUMELMS(sudTRPinTypes),       // Number of types
    sudTRPinTypes                 // Pin details
};

const AMOVIESETUP_FILTER sudTextRend =
{
    &CLSID_TextThing,            // Filter CLSID
    L"Internal Script Command Renderer",  // String name
    MERIT_PREFERRED + 1,          // Filter merit higher than the sample text renderer
    1,                            // Number of pins
    &sudTRPin                     // Pin details
};

#ifdef FILTER_DLL

CFactoryTemplate g_Templates[] = {
    { L""
    , &CLSID_TextThing
    , CTextThing::CreateInstance
    , NULL
    , NULL } // &sudRASource
};

int g_cTemplates = sizeof(g_Templates) / sizeof(g_Templates[0]);

STDAPI DllRegisterServer()
{
  return AMovieDllRegisterServer2( TRUE );
}

STDAPI DllUnregisterServer()
{
  return AMovieDllRegisterServer2( FALSE );
}
#endif



//
CTextThing::CTextThing(LPUNKNOWN pUnk,HRESULT *phr) :
    CBaseRenderer(CLSID_TextThing, NAME("TextOut Filter"), pUnk, phr),
    m_pfn(NULL),
    m_pContext(NULL)
{
} // (Constructor)


//
// Destructor
//
CTextThing::~CTextThing()
{
}


//
// CreateInstance
//
// This goes in the factory template table to create new instances
//
CUnknown * WINAPI CTextThing::CreateInstance(LPUNKNOWN pUnk, HRESULT *phr)
{
    CTextThing *pTextOutFilter = new CTextThing(pUnk,phr);
    if (pTextOutFilter == NULL) {
        return NULL;
    }
    return (CBaseMediaFilter *) pTextOutFilter;

} // CreateInstance


//
// NonDelegatingQueryInterface
//
// Overriden to say what interfaces we support and where
//
STDMETHODIMP
CTextThing::NonDelegatingQueryInterface(REFIID riid,void **ppv)
{
    CheckPointer(ppv,E_POINTER);

    if (riid == IID_ITextThing) {
        return GetInterface((ITextThing *)this, ppv);
    }
    return CBaseRenderer::NonDelegatingQueryInterface(riid,ppv);

} // NonDelegatingQueryInterface


//
// CheckMediaType
//
// Check that we can support a given proposed type
//
HRESULT CTextThing::CheckMediaType(const CMediaType *pmt)
{
    // Accept text or "script commands"

    if (pmt->majortype != MEDIATYPE_ScriptCommand && pmt->majortype != MEDIATYPE_Text) {
        return E_INVALIDARG;
    }

    // !!! check other things about the format?
    
    return NOERROR;

} // CheckMediaType

//
// SetMediaType
//
// Called when the media type is really chosen
//
HRESULT CTextThing::SetMediaType(const CMediaType *pmt)
{
    // Accept text or "script commands"

    if (pmt->majortype == MEDIATYPE_Text) {
        m_fOldTextFormat = TRUE;
    } else {
        // !!! check if it really is "script commands"?
        m_fOldTextFormat = FALSE;
    }


    return NOERROR;

} // CheckMediaType


//
// DoRenderSample
//
// This is called when a sample is ready for rendering
//
HRESULT CTextThing::DoRenderSample(IMediaSample *pMediaSample)
{
    ASSERT(pMediaSample);
    DrawText(pMediaSample);
    return NOERROR;

} // DoRenderSample


//
// OnReceiveFirstSample
//
// Display an image if not streaming
//
void CTextThing::OnReceiveFirstSample(IMediaSample *pMediaSample)
{
    // !!! anything to do?
    if(IsStreaming() == FALSE)
    {
        ASSERT(pMediaSample);
        DrawText(pMediaSample);
    }
} // OnReceiveFirstSample


//
// DrawText
//
// This is called with an IMediaSample interface on the image to be drawn. We
// are called from two separate code paths. The first is when we're signalled
// that an image has become due for rendering, the second is when we need to
// refresh a static window image. NOTE it is safe to check the type of buffer
// allocator as to change it we must be inactive, which by definition means
// we cannot have any samples available to render so we cannot be here
//
void CTextThing::DrawText(IMediaSample *pMediaSample)
{
    BYTE *pText;        // Pointer to image data

    pMediaSample->GetPointer(&pText);
    ASSERT(pText != NULL);

    // Ignore zero length samples

    LONG lActual = pMediaSample->GetActualDataLength();
    if (lActual == 0) {
        // !!! or draw blank?
        return;
    }

    // Remove trailing NULL from the text data

    // !!! do something!!!

    if (m_pfn) {
        ASSERT(0);      // remove this case!
        
        (m_pfn)(m_pContext, (char *) pText);
    } else {
        if (m_pSink) {

            if(m_fOldTextFormat)
            {
                ULONG cNulls = 0;
                for(int i = 0; i < lActual && cNulls < 1; i++)
                {
                    if(pText[i] == 0)
                    {
                        cNulls++;
                    }
                }
            


                if (cNulls >= 1)
                {
                    DWORD dwSize = MultiByteToWideChar(CP_ACP, 0L, (char *) pText, -1, 0, 0);

                    BSTR bstr = SysAllocStringLen(NULL, dwSize);

                    if (bstr) {
                        MultiByteToWideChar(CP_ACP, 0L, (char *) pText, -1, bstr, dwSize+1);

                        BSTR bstrType = SysAllocString(L"Text");

                        if (bstrType) {
                            if (FAILED(NotifyEvent(EC_OLE_EVENT, (LONG_PTR) bstrType, (LONG_PTR) bstr))) {
                                DbgLog(( LOG_ERROR, 5, TEXT("WARNING in CTextThing::DrawText(): CBaseFilter::NotifyEvent() failed.") ));
                            }
                        } else {
                            SysFreeString(bstr);
                        }
                    
                    }
                }
                else
                {
                    // corrupt
                }
            }
            else
            {
                WCHAR *pw = (WCHAR *) pText;
                ULONG cNulls = 0;
                for(int i = 0; i < lActual / 2 && cNulls < 2; i++)
                {
                    if(pw[i] == 0)
                    {
                        cNulls++;
                    }
                }
            

                if(cNulls >= 2) {
                    // buffer is two unicode strings, with a NULL in between....

                    BSTR bstrType = SysAllocString(pw);

                    if (bstrType) {
                        BSTR bstr = SysAllocString(pw + lstrlenW(pw) + 1);
                        if (bstr) {
                            if (FAILED(NotifyEvent(EC_OLE_EVENT, (LONG_PTR) bstrType, (LONG_PTR) bstr))) {
                                DbgLog(( LOG_ERROR, 5, TEXT("WARNING in CTextThing::DrawText(): CBaseFilter::NotifyEvent() failed.") ));
                            }
                        } else {
                            SysFreeString(bstrType);
                        }
                    }
                } else {
                    // corrupt
                }
            }
        }
    }
} // DrawText


// !!!! get rid of this!
HRESULT CTextThing::SetEventTarget(void * pContext, TEXTEVENTFN fn)
{

    m_pfn = fn;
    m_pContext = pContext;

    return NOERROR;
}
=== C:/Users/treeman/Desktop/windows nt source code\Source\Win2K3\NT\multimedia\dshow\filterus\wav\acmwrap\acmwrap.h ===
//
// Copyright (c) 1994 - 1999  Microsoft Corporation.  All Rights Reserved.
//
//
//  Wrapper for ACM
//
//   10/17/95 - mikegi, created
//

extern const AMOVIESETUP_FILTER sudAcmWrap;

class CACMWrapper : public CTransformFilter     DYNLINKACM,
                    public IPersistPropertyBag, public CPersistStream
 {
  public:
    CACMWrapper(TCHAR *, LPUNKNOWN, HRESULT *);
    ~CACMWrapper();

    DECLARE_IUNKNOWN

    CBasePin *GetPin(int n);	// overridden to make special output pin
    HRESULT Transform(IMediaSample * pIn, IMediaSample * pOut);
    HRESULT Receive(IMediaSample *pInSample);
    HRESULT EndOfStream();
    HRESULT SendExtraStuff();
    HRESULT ProcessSample(BYTE *pbSrc, LONG cbSample, IMediaSample *pOut,
                          LONG *pcbUsed, LONG* pcbDstUsed, BOOL fBlockAlign);

    // check if you can support mtIn
    HRESULT CheckInputType(const CMediaType* mtIn);

    // check if you can support the transform from this input to
    // this output
    HRESULT CheckTransform(const CMediaType* mtIn, const CMediaType* mtOut);

    // called from CBaseOutputPin to prepare the allocator's count
    // of buffers and sizes
    HRESULT DecideBufferSize(IMemAllocator * pAllocator,
                             ALLOCATOR_PROPERTIES *pProperties);

    // optional overrides - we want to know when streaming starts and stops
    HRESULT StartStreaming();
    HRESULT StopStreaming();
    HRESULT EndFlush();

    HRESULT BreakConnect(PIN_DIRECTION pindir);

    // overriden to suggest OUTPUT pin media types
    HRESULT GetMediaType(int iPosition, CMediaType *pMediaType);
    HRESULT InitMediaTypes();	// helper function
    HRESULT MakePCMMT(int freq);// helper function

    // this goes in the factory template table to create new instances
    static CUnknown * CreateInstance(LPUNKNOWN, HRESULT *);
    STDMETHODIMP NonDelegatingQueryInterface(REFIID riid,void **ppv);

    // overridden to do some pretty fancy reconnecting footwork
    HRESULT SetMediaType(PIN_DIRECTION direction, const CMediaType *pmt);

    // IPersistRegistryKey
   // IPersistPropertyBag methods
   STDMETHOD(InitNew)(THIS);
   STDMETHOD(Load)(THIS_ LPPROPERTYBAG pPropBag, LPERRORLOG pErrorLog);
   STDMETHOD(Save)(THIS_ LPPROPERTYBAG pPropBag, BOOL fClearDirty,
                   BOOL fSaveAllProperties);

    STDMETHODIMP GetClassID(CLSID *pClsid);

    // CPersistStream
    HRESULT WriteToStream(IStream *pStream);
    HRESULT ReadFromStream(IStream *pStream);
    int SizeMax();

  private:
    HACMSTREAM m_hacmStream;
    BOOL       m_bStreaming;
    REFERENCE_TIME m_tStartFake;
    DWORD      m_nAvgBytesPerSec;
    LPWAVEFORMATEX m_lpwfxOutput;
    int 	   m_cbwfxOutput;
    LPBYTE m_lpExtra;	// samples we couldn't compress last time Receive called
    int m_cbExtra;	// size of lpExtra
    REFERENCE_TIME m_rtExtra;	// time stamp of extra stuff
	
    CCritSec m_csReceive; 	// for Receive

	TCHAR *m_rgFormatMap;	 // acm codec format mapper strings
	TCHAR *m_pFormatMapPos;
	WORD 	m_wCachedTryFormat;
	WORD	m_wCachedSourceFormat;
	WORD	m_wCachedTargetFormat;
	WORD 	m_wSourceFormat;
	WORD 	m_wTargetFormat;

	DWORD 	ACMCodecMapperOpen(WORD wFormatTag);
	void 	ACMCodecMapperClose();
	WORD 	ACMCodecMapperQuery();

        MMRESULT CallacmStreamOpen(
                                   LPHACMSTREAM            phas,       // pointer to stream handle
                                   HACMDRIVER              had,        // optional driver handle
                                   LPWAVEFORMATEX          pwfxSrc,    // source format to convert
                                   LPWAVEFORMATEX          pwfxDst,    // required destination format
                                   LPWAVEFILTER            pwfltr,     // optional filter
                                   DWORD_PTR               dwCallback, // callback
                                   DWORD_PTR               dwInstance, // callback instance data
                                   DWORD                   fdwOpen     // ACM_STREAMOPENF_* and CALLBACK_*
                                  );

        
  public:
    // !!! ack - public so enum callback can see them!

    WORD m_wFormatTag;		// only produce outputs with this format tag

    #define MAXTYPES 200
    LPWAVEFORMATEX m_lpwfxArray[MAXTYPES];	// all the things we return
    int m_cArray;				// in GetMediaType

  friend class CACMOutputPin;
 };


class CACMPosPassThru : public CPosPassThru
{
public:

    CACMPosPassThru(const TCHAR *, LPUNKNOWN, HRESULT*, IPin *);
    DECLARE_IUNKNOWN

    // IMediaSeeking methods
    STDMETHODIMP SetTimeFormat(const GUID * pFormat);
    STDMETHODIMP IsFormatSupported( const GUID * pFormat);
    STDMETHODIMP QueryPreferredFormat( GUID *pFormat);
    STDMETHODIMP ConvertTimeFormat(LONGLONG *pTarget, const GUID *pTargetFormat, LONGLONG Source, const GUID *pSourceFormat);
};


// We need a new class to support IAMStreamConfig
//
class CACMOutputPin : public CTransformOutputPin, IAMStreamConfig
{

public:

    CACMOutputPin(
        TCHAR *pObjectName,
        CACMWrapper *pFilter,
        HRESULT * phr,
        LPCWSTR pName);

    virtual ~CACMOutputPin();

    DECLARE_IUNKNOWN

    // IAMStreamConfig stuff
    STDMETHODIMP SetFormat(AM_MEDIA_TYPE *pmt);
    STDMETHODIMP GetFormat(AM_MEDIA_TYPE **ppmt);
    STDMETHODIMP GetNumberOfCapabilities(int *piCount, int *piSize);
    STDMETHODIMP GetStreamCaps(int i, AM_MEDIA_TYPE **ppmt, LPBYTE pSCC);

    STDMETHODIMP NonDelegatingQueryInterface(REFIID riid,void **ppv);

    HRESULT CheckMediaType(const CMediaType *pmt);
    HRESULT BreakConnect();
    HRESULT GetMediaType(int iPosition, CMediaType *pMediaType);

private:
    CACMWrapper *m_pFilter;

    CACMPosPassThru *m_pPosition;

    // for GetStreamCaps... how many different format tags can we do?
    #define MAXFORMATTAGS 100
    int m_awFormatTag[MAXFORMATTAGS];
    int m_cFormatTags;
};
=== C:/Users/treeman/Desktop/windows nt source code\Source\Win2K3\NT\multimedia\dshow\filterus\wav\wavemsr\wavemsr.h ===
// Copyright (c) 1994 - 1999  Microsoft Corporation.  All Rights Reserved.

extern const AMOVIESETUP_FILTER sudWAVEParse;

#include <aviriff.h>

// CLSID_WAVEParser,
// {D51BD5A1-7548-11cf-A520-0080C77EF58A}
DEFINE_GUID(CLSID_WAVEParser,
0xd51bd5a1, 0x7548, 0x11cf, 0xa5, 0x20, 0x0, 0x80, 0xc7, 0x7e, 0xf5, 0x8a);

#include "reader.h"
#include "alloc.h"
#include "qnetwork.h"

class CWAVEStream;       // manages the output stream & pin

//
// CWAVEParse
//
class CWAVEParse :
    public CBaseMSRFilter,
    public IAMMediaContent,    
    public IPersistMediaPropertyBag
{
    friend class CWAVEStream;
    friend class CWAVEMSRWorker;

public:

    // Construct our filter
    static CUnknown *CreateInstance(LPUNKNOWN lpunk, HRESULT *phr);

    CCritSec m_cStateLock;      // Lock this when a function accesses
                                // the filter state.
                                // Generally _all_ functions, since access to this
                                // filter will be by multiple threads.

private:

    DECLARE_IUNKNOWN

    // During construction we create the single CWAVEStream object that provides the
    // output pin.
    CWAVEParse(TCHAR *, LPUNKNOWN, HRESULT *);
    ~CWAVEParse();

    // pure CBaseMSRFilter overrides
    HRESULT CreateOutputPins();
    HRESULT CheckMediaType(const CMediaType* mtOut);

    HRESULT GetCacheParams(
      StreamBufParam *rgSbp,
      ULONG *pcbRead,
      ULONG *pcBuffers,
      int *piLeadingStream);

    STDMETHODIMP NonDelegatingQueryInterface(REFIID riid, void ** ppv);

    // IPersistMediaPropertyBag methods
    STDMETHODIMP InitNew();
    STDMETHODIMP Load(IMediaPropertyBag *pPropBag, LPERRORLOG pErrorLog);
    STDMETHODIMP Save(IMediaPropertyBag *pPropBag, BOOL fClearDirty,
                      BOOL fSaveAllProperties);
    STDMETHODIMP GetClassID(CLSID *pClsid);

    //
    HRESULT NotifyInputDisconnected();

    HRESULT CacheInfoChunk();
    RIFFLIST *m_pInfoList;
    bool m_fNoInfoList;         // search failed; don't keep searching

  // IAMMediaContent

  STDMETHODIMP GetTypeInfoCount(THIS_ UINT FAR* pctinfo) { return E_NOTIMPL; }

  STDMETHODIMP GetTypeInfo(
    THIS_
    UINT itinfo,
    LCID lcid,
    ITypeInfo FAR* FAR* pptinfo) { return E_NOTIMPL; }

  STDMETHODIMP GetIDsOfNames(
    THIS_
    REFIID riid,
    OLECHAR FAR* FAR* rgszNames,
    UINT cNames,
    LCID lcid,
    DISPID FAR* rgdispid) { return E_NOTIMPL; }

  STDMETHODIMP Invoke(
    THIS_
    DISPID dispidMember,
    REFIID riid,
    LCID lcid,
    WORD wFlags,
    DISPPARAMS FAR* pdispparams,
    VARIANT FAR* pvarResult,
    EXCEPINFO FAR* pexcepinfo,
    UINT FAR* puArgErr) { return E_NOTIMPL; }

  STDMETHODIMP get_AuthorName(BSTR FAR* pbstrAuthorName);
  STDMETHODIMP get_Title(BSTR FAR* pbstrTitle);
  STDMETHODIMP get_Rating(BSTR FAR* pbstrRating) { return E_NOTIMPL; }
  STDMETHODIMP get_Description(BSTR FAR* pbstrDescription) { return E_NOTIMPL; }
  STDMETHODIMP get_Copyright(BSTR FAR* pbstrCopyright);
  STDMETHODIMP get_BaseURL(BSTR FAR* pbstrBaseURL) { return E_NOTIMPL; }
  STDMETHODIMP get_LogoURL(BSTR FAR* pbstrLogoURL) { return E_NOTIMPL; }
  STDMETHODIMP get_LogoIconURL(BSTR FAR* pbstrLogoIconURL) { return E_NOTIMPL; }
  STDMETHODIMP get_WatermarkURL(BSTR FAR* pbstrWatermarkURL) { return E_NOTIMPL; }
  STDMETHODIMP get_MoreInfoURL(BSTR FAR* pbstrMoreInfoURL) { return E_NOTIMPL; }
  STDMETHODIMP get_MoreInfoBannerURL(BSTR FAR* pbstrMoreInfoBannerURL) { return E_NOTIMPL; }
  STDMETHODIMP get_MoreInfoBannerImage(BSTR FAR* pbstrMoreInfoBannerImage) { return E_NOTIMPL; }
  STDMETHODIMP get_MoreInfoText(BSTR FAR* pbstrMoreInfoText) { return E_NOTIMPL; }

  STDMETHODIMP GetInfoString(DWORD dwFcc, BSTR *pbstr);
};


//
// CWAVEStream
//
// Manages the output pins for the various streams
class CWAVEStream : public CBaseMSROutPin {
    friend class CWAVEParse;

public:

    CWAVEStream( TCHAR           *pObjectName
              , HRESULT         *phr
              , CWAVEParse		*pParentFilter
              , LPCWSTR         pPinName
	      , int		id
              );

    ~CWAVEStream();

    //
    //  --- CSourceStream implementation ---
    //
public:

    // base class overrides
    ULONG GetMaxSampleSize();

    // in m_guidFormat units
    HRESULT GetDuration(LONGLONG *pDuration);
    HRESULT GetAvailable(LONGLONG *pEarliest, LONGLONG *pLatest);
    HRESULT IsFormatSupported(const GUID *const pFormat);

    HRESULT RecordStartAndStop(
      LONGLONG *pCurrent, LONGLONG *pStop, REFTIME *pTime,
      const GUID *const pGuidFormat
      );

    REFERENCE_TIME ConvertInternalToRT(const LONGLONG llVal);
    LONGLONG ConvertRTToInternal(const REFERENCE_TIME rtVal);

    HRESULT OnActive();
    BOOL UseDownstreamAllocator();
    HRESULT DecideBufferSize(IMemAllocator * pAlloc, ALLOCATOR_PROPERTIES *pProperties);

private:

    // base class overrides
    HRESULT GetMediaType(int iPosition, CMediaType* pt);
    LONGLONG GetStreamStart();
    LONGLONG GetStreamLength();

private:        // State shared between worker & client
    CCritSec            m_cSharedState;         // Lock this to access this state,
                                                // shared with the worker thread

    // returns the sample number starting at or after time t
    LONG RefTimeToSample(CRefTime t);

    // returns the RefTime for s (media time)
    CRefTime SampleToRefTime(LONG s);

    WAVEFORMATEX            m_wfx;

    CMediaType		    m_mtStream;

    CWAVEParse *	    m_pFilter;

    int			    m_id;			// stream #

    DWORD                   m_dwDataOffset;
    DWORD                   m_dwDataLength;

    BOOL                    m_bByteSwap16;
    BOOL                    m_bSignMunge8;

    friend class CWAVEMSRWorker;
};

// ------------------------------------------------------------------------
// ------------------------------------------------------------------------

class CWAVEMSRWorker : public CBaseMSRWorker
{
public:
  // constructor
  CWAVEMSRWorker(
    UINT stream,
    IMultiStreamReader *pReader,
    CWAVEStream *pStream);

  // pure base overrides
  HRESULT PushLoopInit(LONGLONG *pllCurrentOut, ImsValues *pImsValues);

  // Perform any necessary modifications
  HRESULT AboutToDeliver(IMediaSample *pSample);

  HRESULT TryQueueSample(
    LONGLONG &rllCurrent,       // [in, out]
    BOOL &rfQueuedSample,       // [out]
    ImsValues *pImsValues
    );

  HRESULT CopyData(IMediaSample **ppSampleOut, IMediaSample *pms);

private:

    CWAVEStream *m_ps;

    LONG		    m_sampCurrent;
};
=== C:/Users/treeman/Desktop/windows nt source code\Source\Win2K3\NT\multimedia\dshow\filterus\writer\fio.cpp ===
// Copyright (c) 1996 - 1999  Microsoft Corporation.  All Rights Reserved.
#pragma warning(disable: 4097 4511 4512 4514 4705)

#include <streams.h>
#include "fio.h"

// number of WriteRequest structures allocated. limits the number of
// simultaneous writes possible. should this be configurable? 
static const C_WRITE_REQS = 32; // number duplicated in mux

// calls to these methods must be serialized by the caller.

// Completion events and new requests come to the completion port; the
// key field is used to distinguish them
//
enum Keys
{
  CKEY_WRITE,
  CKEY_EOS,
  CKEY_EXIT
};

CFileWriterFilter::CFileWriterFilter(LPUNKNOWN pUnk, HRESULT *pHr) :
    CBaseWriterFilter(pUnk, pHr),
    m_pFileIo(0),
    m_fBufferedIo(FALSE),
    m_dwOpenFlags(0),
    m_wszFileName(0),
    CPersistStream(pUnk, pHr)
{
}

CFileWriterFilter::~CFileWriterFilter()
{
  delete[] m_wszFileName;
  delete m_pFileIo;
}

HRESULT CFileWriterFilter::Open()
{
  // we refuse to pause otherwise
  ASSERT(m_pFileIo);
  
  return m_pFileIo->Open();
}

HRESULT CFileWriterFilter::Close()
{
  if(m_pFileIo)
    return m_pFileIo->Close();
  else
    return S_OK;
}

HRESULT CFileWriterFilter::GetAlignReq(ULONG *pcbAlign)
{
  if(m_pFileIo)
  {
    return m_pFileIo->GetAlignReq(pcbAlign);
  }
  else
  {
    // will reconnect when file name set
    *pcbAlign = 1;
    return S_OK;
  }
}

HRESULT CFileWriterFilter::AsyncWrite(
  const DWORDLONG dwlFileOffset,
  const ULONG cb,
  BYTE *pb,
  FileIoCallback fnCallback,
  void *pCallbackArg)
{
  return m_pFileIo->AsyncWrite(dwlFileOffset, cb, pb, fnCallback, pCallbackArg);
}

HRESULT CFileWriterFilter::CreateFileObject()
{
  if(m_wszFileName == 0) {
    return S_OK;
  }
  
  delete m_pFileIo;
  
  OSVERSIONINFO osvi;
  osvi.dwOSVersionInfoSize = sizeof(osvi);

  BOOL f = GetVersionEx(&osvi);
  ASSERT(f);

  // really should check whether CreateIoCompletionPort succeeds. to
  // do that, i need to make one class which does both modes, and let
  // it decide on the stop->pause transition. !!!

  BOOL fOpenExisting = !(m_dwOpenFlags & AM_FILE_OVERWRITE);
  
  HRESULT hr = S_OK;
  if(osvi.dwPlatformId == VER_PLATFORM_WIN32_NT)
  {
//     DbgBreak("not using overlapped io");
//     m_pFile = new CSyncFileIo(m_wszFileName, FALSE, &hr);
    m_pFileIo = new CFileIo(m_wszFileName, m_fBufferedIo, fOpenExisting, &hr);
  }
  else
  {
    m_pFileIo = new CSyncFileIo(m_wszFileName, m_fBufferedIo, fOpenExisting, &hr);
  }
  if(m_pFileIo == 0)
    return E_OUTOFMEMORY;
  if(FAILED(hr))
  {
    delete m_pFileIo;
    m_pFileIo = 0;
    return hr;
  }

  return S_OK;
}

STDMETHODIMP
CFileWriterFilter::NotifyAllocator(
  IMemAllocator * pAllocator,
  BOOL bReadOnly)
{
  // we will go through this again when we do set a file because we
  // force a reconnect which calls NotifyAllocator
  if(!m_pFileIo)
    return S_OK;

  ULONG cbAlignFile;
  HRESULT hr = m_pFileIo->GetAlignReq(&cbAlignFile);
  if(SUCCEEDED(hr))
  {
    ALLOCATOR_PROPERTIES apUpstream;
    hr = pAllocator->GetProperties(&apUpstream);

    if(SUCCEEDED(hr) && apUpstream.cbAlign >= (LONG)cbAlignFile)
    {
      DbgLog((LOG_TRACE, 2,
              TEXT("CBaseWriterInput::NotifyAllocator: unbuffered io")));
      m_fBufferedIo = FALSE;
      return S_OK;
    }
  }

  DbgLog((LOG_TRACE, 2,
          TEXT("CBaseWriterInput::NotifyAllocator: buffered io")));
  m_fBufferedIo = TRUE;

  return CreateFileObject();
}

// ------------------------------------------------------------------------
// IFileSinkFilter

STDMETHODIMP CFileWriterFilter::SetFileName(
  LPCOLESTR wszFileName,
  const AM_MEDIA_TYPE *pmt)
{
  CheckPointer(wszFileName, E_POINTER);
  CAutoLock lock(&m_cs);

  if(m_State != State_Stopped)
    return VFW_E_WRONG_STATE;

  if(pmt && m_inputPin.IsConnected() && (
      m_mtSet.majortype != pmt->majortype ||
      m_mtSet.subtype != pmt->subtype))
  {
      return E_FAIL;
  }

  delete[] m_wszFileName;
  m_wszFileName = 0;

  long cLetters = lstrlenW(wszFileName);
//   if(cLetters > MAX_PATH)
//     return HRESULT_FROM_WIN32(ERROR_FILENAME_EXCED_RANGE);

  m_wszFileName = new WCHAR[cLetters + 1];
  if(m_wszFileName == 0)
    return E_OUTOFMEMORY;

  lstrcpyW(m_wszFileName, wszFileName);

  if(pmt)
  {
    m_mtSet.majortype = pmt->majortype;
    m_mtSet.subtype = pmt->subtype;
  }
  else
  {
    m_mtSet.majortype = MEDIATYPE_Stream;
    m_mtSet.subtype = GUID_NULL;
  }

  HRESULT hr = CreateFileObject();
  if(FAILED(hr))
  {
    return hr;
  }

  // alignment requirement may have changed. reconnect.
  if(m_inputPin.IsConnected())
  {
    hr = m_pGraph->Reconnect(&m_inputPin);
    if(FAILED(hr))
      return hr;
  }

  return S_OK;
}

STDMETHODIMP CFileWriterFilter::SetMode(
    DWORD dwFlags)
{
    // refuse flags we don't know 
    if(dwFlags & ~AM_FILE_OVERWRITE)
    {
        return E_INVALIDARG;
    }
    
    CAutoLock lock(&m_cs);

    HRESULT hr = S_OK;

    if(m_State == State_Stopped)
    {
        m_dwOpenFlags = dwFlags;
        SetDirty(TRUE);
        hr = CreateFileObject();
    }
    else
    {
        hr = VFW_E_WRONG_STATE;
    }

    return hr;
}

STDMETHODIMP CFileWriterFilter::GetCurFile(
  LPOLESTR * ppszFileName,
  AM_MEDIA_TYPE *pmt)
{
  CheckPointer(ppszFileName, E_POINTER);

  *ppszFileName = NULL;
  if(m_wszFileName!=NULL)
  {
    *ppszFileName = (LPOLESTR)
      QzTaskMemAlloc(sizeof(WCHAR) * (1+lstrlenW(m_wszFileName)));
    if (*ppszFileName != NULL)
      lstrcpyW(*ppszFileName, m_wszFileName);
    else
      return E_OUTOFMEMORY;
  }

  if(pmt)
  {
    pmt->majortype = m_mtSet.majortype;
    pmt->subtype = m_mtSet.subtype;
  }

  return S_OK;
}

STDMETHODIMP CFileWriterFilter::GetMode(
    DWORD *pdwFlags)
{
    CheckPointer(pdwFlags, E_POINTER);
    *pdwFlags = m_dwOpenFlags;
    return S_OK;
}


STDMETHODIMP CFileWriterFilter::CanPause()
{
  if(m_pFileIo == 0)
  {
    ASSERT(m_State == State_Stopped);
    return HRESULT_FROM_WIN32(ERROR_INVALID_NAME);
  }
  else
  {
    return S_OK;
  }
}

struct FwPersist
{
    DWORD dwSize;
    DWORD dwFlags;
};

HRESULT CFileWriterFilter::WriteToStream(IStream *pStream)
{
    FwPersist fp;
    fp.dwSize = sizeof(fp);
    fp.dwFlags = m_dwOpenFlags;
    
    return pStream->Write(&fp, sizeof(fp), 0);
}

HRESULT CFileWriterFilter::ReadFromStream(IStream *pStream)
{
   FwPersist fp;
   HRESULT hr = pStream->Read(&fp, sizeof(fp), 0);
   if(FAILED(hr)) {
       return hr;
   }

   if(fp.dwSize != sizeof(fp)) {
       return HRESULT_FROM_WIN32(ERROR_INVALID_DATA);
   }

   m_dwOpenFlags = fp.dwFlags;

   return CreateFileObject();
}

int CFileWriterFilter::SizeMax()
{
    return sizeof(FwPersist);
}

STDMETHODIMP CFileWriterFilter::GetClassID(CLSID *pClsid)
{
    CheckPointer(pClsid, E_POINTER);
    *pClsid = m_clsid;
    return S_OK;  
}


STDMETHODIMP CFileWriterFilter::NonDelegatingQueryInterface(
  REFIID riid, void ** ppv)
{
  if(riid == IID_IFileSinkFilter2)
  {
    return GetInterface((IFileSinkFilter2 *) this, ppv);
  }
  if(riid == IID_IFileSinkFilter)
  {
    return GetInterface((IFileSinkFilter *) this, ppv);
  }
  if(riid == IID_IPersistStream)
  {
    return GetInterface((IPersistStream *) this, ppv);
  }
  
  return CBaseWriterFilter::NonDelegatingQueryInterface(riid, ppv);
}

STDMETHODIMP
CFileWriterFilter::CreateIStream(void **ppStream)
{
  // you get a new one with its own state each time
  HRESULT hr = S_OK;
  CFwIStream *pIStream = new CFwIStream(
    m_wszFileName,
    NAME("file writer istream"),
    0,
    m_dwOpenFlags & AM_FILE_OVERWRITE,
    &hr);
  if(pIStream == 0)
    return E_OUTOFMEMORY;
  if(FAILED(hr))
  {
    delete pIStream;
    return hr;
  }
  return GetInterface((IStream *)pIStream, ppStream);
}


// ------------------------------------------------------------------------
// constructor

CFileIo::CFileIo(
    WCHAR *wszName,
    BOOL fBuffered,
    BOOL fOpenExisting,
    HRESULT *phr) :
        m_qWriteReq(C_WRITE_REQS),
        m_fOpenExisting(fOpenExisting),
        m_fBuffered(fBuffered)
{
  m_rgWriteReq = 0;
  Cleanup();
  m_cbSector = 0;
  m_ilcActive = 0;
  m_szName[0] = 0;
  m_hrError = S_OK;

#ifdef PERF
  m_idPerfWrite = Msr_Register(TEXT("cfileio: write queued/completed"));
#endif // PERF
  
  if(FAILED(*phr))
    return;

  m_rgWriteReq = new WriteRequest[C_WRITE_REQS];
  if(m_rgWriteReq == 0)
  {
    *phr = E_OUTOFMEMORY;
    return;
  }
  for(int i = 0; i < C_WRITE_REQS; i++)
    m_qWriteReq.PutQueueObject(&m_rgWriteReq[i]);
    

  *phr = SetFilename(wszName);
  return;
  
}

void CFileIo::Cleanup()
{
  m_hFileFast = INVALID_HANDLE_VALUE;
  m_hCPort = 0;
  m_fStopping = FALSE;
}

CFileIo::~CFileIo()
{
  ASSERT(m_hFileFast == INVALID_HANDLE_VALUE);
  ASSERT(m_hCPort == 0);
  Cleanup();
  delete[] m_rgWriteReq;
}

// ------------------------------------------------------------------------
// get filesystem's sector size from filename

HRESULT CFileIo::SetFilename(WCHAR *wszName)
{
  if(lstrlenW(wszName) > MAX_PATH)
    return HRESULT_FROM_WIN32(ERROR_FILENAME_EXCED_RANGE);

  DWORD dwFreeClusters, dwBytesPerSector, dwSectorsPerCluster, dwClusters;

  TCHAR szName[MAX_PATH];
  
# if defined(WIN32) && !defined(UNICODE)
  {
    if(!WideCharToMultiByte(CP_ACP, 0, wszName, -1, szName, MAX_PATH, 0, 0))
      return HRESULT_FROM_WIN32(ERROR_INVALID_NAME);
  }
# else
  {
    lstrcpyW(szName, wszName);
  }
# endif
  
  TCHAR root[MAX_PATH];
  BOOL b = GetRoot(root, szName);
  if(b)
  {
      b = GetDiskFreeSpace(
          root,
          &dwSectorsPerCluster,
          &dwBytesPerSector,
          &dwFreeClusters,
          &dwClusters);
  }

  // GetDiskFreeSpace doesn't work on Win95 to a network
  m_cbSector = b ? dwBytesPerSector : 1;

  lstrcpy(m_szName, szName);

  return S_OK;
}

// ------------------------------------------------------------------------
// create / open the file, create completion port, create writer
// thread

HRESULT CFileIo::Open()
{
  ASSERT(m_hFileFast == INVALID_HANDLE_VALUE);
  ASSERT(m_hCPort == 0);
  m_fStopping = FALSE;
  m_hrError = S_OK;

  // must have been given a filename.
  ASSERT(m_cbSector != 0);

  HRESULT hr = DoCreateFile();
  if(FAILED(hr))
    return hr;

  // create worker thread
  if(!this->Create())
  {
    DbgBreak("fio: couldn't create worker thread");
    Close();
    return E_UNEXPECTED;
  }

  return S_OK;
}

HRESULT CFileIo::DoCreateFile()
{
  const DWORD dwfBuffering = m_fBuffered ? 0 : FILE_FLAG_NO_BUFFERING;
  const DWORD dwCreationDistribution =
      m_fOpenExisting ? OPEN_ALWAYS : CREATE_ALWAYS;

  DbgLog((LOG_TRACE, 5, TEXT("CFileIo: opening file. buffering: %d"),
          m_fBuffered ));

  m_hFileFast = CreateFile(
    m_szName,                   // lpFileName
    GENERIC_WRITE,              // dwDesiredAccess
    FILE_SHARE_WRITE | FILE_SHARE_READ, // dwShareMode
    0,                          // lpSecurityAttribytes
    dwCreationDistribution,
    FILE_ATTRIBUTE_NORMAL | FILE_FLAG_OVERLAPPED | dwfBuffering,
    0);

  if(m_hFileFast == INVALID_HANDLE_VALUE)
  {
    DWORD dwLastError = GetLastError();
    DbgLog(( LOG_TRACE, 2,
             NAME("CFileIo::CreateFile: CreateFile overlapped failed. %i"),
             dwLastError));

    Close();
    return AmHresultFromWin32(dwLastError);
  }

  m_hCPort = CreateIoCompletionPort(
    m_hFileFast,                // file handle
    0,                          // existing completion port
    CKEY_WRITE,                 // completion key
    0);                         // # concurrent threads

  if(m_hCPort == 0)
  {
    DWORD dwLastError = GetLastError();
    Close();
    DbgLog(( LOG_TRACE, 2,
             NAME("CFileIo::CreateFile: CreateIoCompletionPort failed. %i"),
             dwLastError));
    return AmHresultFromWin32(dwLastError);
  }

  return S_OK;
}


HRESULT CFileIo::Close()
{
  DbgLog((LOG_TRACE, 5, TEXT("CFileIo: closing file")));

  HRESULT hr = S_OK;
  DWORD dwLastError = 0;

  m_fStopping = TRUE;

  StopWorker();
  if(m_hCPort != 0)
  {
    CloseHandle(m_hCPort);
  }
  m_hCPort = 0;

  if(m_hFileFast != INVALID_HANDLE_VALUE)
    if(!CloseHandle(m_hFileFast))
      dwLastError = GetLastError(), hr = AmHresultFromWin32(dwLastError);
  m_hFileFast = INVALID_HANDLE_VALUE;

  return hr == S_OK ? m_hrError : hr;
}

HRESULT CFileIo::StopWorker()
{
  if(!ThreadExists())
    return S_OK;
  
  HRESULT hr = PostCompletedMsg(CKEY_EXIT);
  if(FAILED(hr))
  {
    DbgBreak("PostQueuedCompletionStatus failed");
    return E_UNEXPECTED;
  }
  hr = CallWorker(CMD_EXIT);
  ASSERT(hr == S_OK);
  CAMThread::Close();
  ASSERT(m_hThread == 0);
  return S_OK;
}

HRESULT CFileIo::GetAlignReq(ULONG *pcbAlign)
{
  ASSERT(m_szName[0] != 0);

  *pcbAlign = m_cbSector;
  
  return S_OK;
}

HRESULT CFileIo::AsyncWrite(
  const DWORDLONG dwlFileOffset,
  const ULONG cb,
  BYTE *pb,
  FileIoCallback fnCallback,
  void *pCallbackArg)
{
  // relies on filter cs
  if(!m_fBuffered)
  {
    ASSERT(dwlFileOffset % m_cbSector == 0);
    DbgAssertAligned(pb, m_cbSector );
    ASSERT(cb % m_cbSector == 0);
  }

  if(m_hrError != S_OK)
    return m_hrError;

  // we're flushing
  if(m_fStopping)
  {
    DbgLog((LOG_TRACE, 10, TEXT("Write while flushing.")));
    return S_FALSE;
  }

  WriteRequest *pReq = m_qWriteReq.GetQueueObject();
  pReq->hEvent = 0;
  pReq->SetPos(dwlFileOffset);
  pReq->fnCallback = fnCallback;
  pReq->dwSize = cb;
  pReq->pb = pb;
  pReq->pMisc = pCallbackArg;

  long sign = InterlockedIncrement(&m_ilcActive);
  ASSERT(sign > 0);

  MSR_INTEGER(m_idPerfWrite, (long)pReq->Offset);

  HRESULT hr = QueueAsyncWrite(pReq);
  if(FAILED(hr))
  {
    DbgLog((LOG_ERROR, 5, TEXT("CFileIo: QueueAsyncWrite failed: %08x"), hr));
    long sign = InterlockedDecrement(&m_ilcActive);
    ASSERT(sign >= 0);
    m_hrError = hr;
    return hr;
  }
  else
  {
    DbgLog((LOG_TRACE, 10, TEXT("CFileIo: queued 0x%08x offset=%08x%08x"),
            pReq, (DWORD)(dwlFileOffset >> 32), (dwlFileOffset & 0xffffffff)));
    return S_OK;
  }
}

HRESULT CFileIo::QueueAsyncWrite(
  WriteRequest *pReq)
{
  BOOL fWrite = WriteFile(m_hFileFast, pReq->pb, pReq->dwSize, 0, pReq);
  if(!fWrite)
  {
    DWORD dwError = GetLastError();
    if(dwError == ERROR_IO_PENDING)
      return S_OK;
    return AmHresultFromWin32(dwError);
  }
  return S_OK;
}

HRESULT CFileIo::GetCompletedWrite(
  DWORD *pdwcbTransferred,
  DWORD_PTR *pdwCompletionKey,
  WriteRequest **ppReq)
{
  BOOL fResult = GetQueuedCompletionStatus(
    m_hCPort,
    pdwcbTransferred,
    pdwCompletionKey,
   (OVERLAPPED **)ppReq,
    INFINITE);

  if(!fResult)
  {
    DbgBreak("GetQueuedCompletionStatus failed");
    DWORD dwRes = GetLastError();
    return AmHresultFromWin32(dwRes);
  }

  if(*ppReq && (*ppReq)->dwSize != *pdwcbTransferred)
  {
    DbgBreak("Incomplete write");
    return HRESULT_FROM_WIN32(ERROR_DISK_FULL);
  }
  
  return S_OK;
}

HRESULT CFileIo::PostCompletedMsg(DWORD_PTR dwKey)
{
  ASSERT(dwKey != CKEY_WRITE);
  BOOL f = PostQueuedCompletionStatus(
    m_hCPort,
    0,
    dwKey,
    0);
  if(!f)
  {
    DWORD dwRes = GetLastError();
    return AmHresultFromWin32(dwRes);
  }
  return S_OK;
}

// ------------------------------------------------------------------------
// return the "root" of a full path. doesn't handle all cases
//

BOOL CFileIo::GetRoot(
  TCHAR szDest_[MAX_PATH],
  TCHAR *const szSrc_)
{
  LPTSTR ptmp;    //required arg

  // need to find path for root directory on drive containing
  // this file.

  LONG l = GetFullPathName(szSrc_, MAX_PATH, szDest_, &ptmp);
  if(l == 0 || l >= MAX_PATH) {
      return FALSE;
  }

  // truncate this to the name of the root directory
  if ((szDest_[0] == TEXT('\\')) && (szDest_[1] == TEXT('\\')))
  {

    // path begins with  \\server\share\path so skip the first
    // three backslashes
    ptmp = &szDest_[2];
    while (*ptmp && (*ptmp != TEXT('\\')))
    {
      ptmp++;
    }
    if (*ptmp)
    {
      // advance past the third backslash
      ptmp++;
    }
  } else {
    // path must be drv:\path
    ptmp = szDest_;
  }

  // find next backslash and put a null after it
  while (*ptmp && (*ptmp != TEXT('\\')))
  {
    ptmp++;
  }
  // found a backslash ?
  if (*ptmp)
  {
    // skip it and insert null
    ptmp++;
    *ptmp = (TCHAR)0;
  }

  return TRUE;
}

// ------------------------------------------------------------------------
// Thread work loop

DWORD CFileIo::ThreadProc()
{
  BOOL fStop = FALSE;
  for(;;)
  {
    WriteRequest *pReq;
    DWORD dwcbTransferred;
    DWORD_PTR dwCompletionKey;
    HRESULT hr = GetCompletedWrite(
      &dwcbTransferred,
      &dwCompletionKey,
      &pReq);

    if(FAILED(hr))
    {
      m_hrError = hr;
      DbgLog((LOG_ERROR, 5, TEXT("CFileIo: GetCompletedWrite failed")));
    }

    if(dwCompletionKey == CKEY_EXIT)
    {
      ASSERT(m_fStopping);
      
      if(pReq)
        CallCallback(pReq);
      
      fStop = TRUE;
      DbgLog((LOG_TRACE, 10, ("CFileIo: stop requested %08x"),
              pReq));
    }
    else
    {
      ASSERT(dwCompletionKey == CKEY_WRITE);

      CallCallback(pReq);

      MSR_INTEGER(m_idPerfWrite, -(long)pReq->Offset);      
    
      long sign = InterlockedDecrement(&m_ilcActive);
      ASSERT(sign >= 0);
      DbgLog((LOG_TRACE, 15, ("CFileIo: completed write %08x. %d active"),
              pReq, m_ilcActive));
    }

    if(fStop && m_ilcActive == 0)
      break;
  }

  ULONG com = GetRequest();
  ASSERT(com == CMD_EXIT);
  
  Reply(NOERROR);
  return 0;                     // ?
}

void CFileIo::CallCallback(WriteRequest *pReq)
{
  void *pMisc = pReq->pMisc;
  FileIoCallback fnCallback = pReq->fnCallback;
  m_qWriteReq.PutQueueObject(pReq);
  if(fnCallback)
    fnCallback(pMisc);
}

// ------------------------------------------------------------------------
// CSyncFileIo

CSyncFileIo::CSyncFileIo(
    WCHAR *wszName,
    BOOL fBuffered,
    BOOL fOpenExisting,
    HRESULT *phr) :
        CFileIo(wszName, fBuffered, fOpenExisting, phr),
        m_qPendingWrites(C_WRITE_REQS)
{
}

HRESULT CSyncFileIo::DoCreateFile()
{
  const DWORD dwfBuffering = m_fBuffered ? 0 : FILE_FLAG_NO_BUFFERING;
  const DWORD dwCreationDistribution =
      m_fOpenExisting ? OPEN_ALWAYS : CREATE_ALWAYS;

  m_hFileFast = CreateFile(
    m_szName,                   // lpFileName
    GENERIC_WRITE,              // dwDesiredAccess
    FILE_SHARE_WRITE | FILE_SHARE_READ, // dwShareMode
    0,                          // lpSecurityAttribytes
    dwCreationDistribution,
    FILE_ATTRIBUTE_NORMAL | dwfBuffering,
    0);

  if(m_hFileFast == INVALID_HANDLE_VALUE)
  {
    DWORD dwLastError = GetLastError();
    DbgLog(( LOG_TRACE, 2,
             NAME("CSyncFileIo::CreateFile: CreateFile failed. %i"),
             dwLastError));

    Close();
    return AmHresultFromWin32(dwLastError);
  }

  DbgLog((LOG_TRACE, 5, TEXT("CFileIo: opened file. buffering: %d"),
          dwfBuffering ? 1 : 0));

  
  return S_OK;
}

HRESULT CSyncFileIo::QueueAsyncWrite(
  WriteRequest *pReq)
{
  pReq->Internal = CKEY_WRITE;
  m_qPendingWrites.PutQueueObject(pReq);
  return S_OK;
}

HRESULT CSyncFileIo::GetCompletedWrite(
  DWORD *pdwcbTransferred,
  DWORD_PTR *pdwCompletionKey,
  WriteRequest **ppReq)
{
  HRESULT hr = S_OK;
  WriteRequest *pReq = m_qPendingWrites.GetQueueObject();
  *pdwCompletionKey = pReq->Internal;
  *ppReq = pReq;
  if(pReq->Internal == CKEY_WRITE)
  {
    *pdwcbTransferred = 0;
    LONG HighPart = pReq->OffsetHigh;
    DWORD dwResult = SetFilePointer(
      m_hFileFast,
      pReq->Offset,
      &HighPart,
      FILE_BEGIN);
    if(dwResult == 0xffffffff)
    {
      DWORD dwLastError = GetLastError();
      if(dwLastError != 0)
      {
        DbgLog(( LOG_ERROR, 2,
                 NAME("CSyncFileIo::Seek: SetFilePointer failed.")));
        hr =  AmHresultFromWin32(dwLastError);
      }
    }
    if(hr == S_OK)
    {
      DWORD cbWritten;
      BOOL fResult = WriteFile(
        m_hFileFast, pReq->pb, pReq->dwSize, &cbWritten, 0);
      if(!fResult)
      {
        DbgLog(( LOG_ERROR, 2,
                 NAME("CSyncFileIo:: WriteFile failed.")));
        DWORD dwLastError = GetLastError();
        hr = AmHresultFromWin32(dwLastError);
      }
      else
      {
        *pdwcbTransferred = cbWritten;
        if(cbWritten != pReq->dwSize)
        {
          DbgBreak("Incomplete write");
          hr = HRESULT_FROM_WIN32(ERROR_DISK_FULL);
        }
      }
    }
  }
  else
  {
    DbgLog((LOG_TRACE, 10, TEXT("CSyncFileIo:GetCompletedWrite: CKEY_EXIT")));
    ASSERT(pReq->Internal == CKEY_EXIT);
  }

  return hr;
}

HRESULT CSyncFileIo::PostCompletedMsg(DWORD_PTR dwKey)
{
  WriteRequest *pReq = m_qWriteReq.GetQueueObject();
  ASSERT(dwKey != CKEY_WRITE);
  pReq->Internal = dwKey;
  pReq->fnCallback = 0;
  m_qPendingWrites.PutQueueObject(pReq);  
  return S_OK;
}

 
// ------------------------------------------------------------------------
// IStream

CFwIStream::CFwIStream(
  WCHAR *wszName,
  TCHAR *pName,
  LPUNKNOWN lpUnk,
  bool fTruncate,
  HRESULT *phr) :
    CUnknown(pName, lpUnk),
    m_hFileSlow(INVALID_HANDLE_VALUE),
    m_fTruncate(fTruncate),
    m_szFilename(0)
{
  DbgLog((LOG_TRACE, 15, TEXT("CFwIStream::CFwIStream")));
  if(FAILED(*phr))
    return;
  
  TCHAR szName[MAX_PATH];
  
# if defined(WIN32) && !defined(UNICODE)
  {
    if(!WideCharToMultiByte(CP_ACP, 0, wszName, -1, szName, MAX_PATH, 0, 0))
    {
      *phr = HRESULT_FROM_WIN32(ERROR_INVALID_NAME);
      return;
    }
  }
# else
  {
    lstrcpyW(szName, wszName);
  }
# endif

  int cch = lstrlen(szName) + 1;
  m_szFilename = new TCHAR[cch];
  if(!m_szFilename) {
      *phr = E_OUTOFMEMORY;
      return;
  }
  CopyMemory(m_szFilename, szName, cch * sizeof(TCHAR));
  
  m_hFileSlow = CreateFile(
    szName,                     // lpFileName
    GENERIC_WRITE | GENERIC_READ, // dwDesiredAccess
    FILE_SHARE_WRITE | FILE_SHARE_READ, // dwShareMode
    0,                          // lpSecurityAttribytes
    OPEN_ALWAYS,                // dwCreationDistribution
    FILE_ATTRIBUTE_NORMAL,
    0);

  if(m_hFileSlow == INVALID_HANDLE_VALUE)
  {
    DWORD dwLastError = GetLastError();
    DbgLog(( LOG_ERROR, 2,
             NAME("CFwIStream:: CreateFile m_hFileSlow failed. %i"),
             dwLastError));
    *phr = AmHresultFromWin32(dwLastError);
  }

  return;
}

STDMETHODIMP CFwIStream::NonDelegatingQueryInterface(REFIID riid, void ** pv)
{
  if (riid == IID_IStream) {
    return GetInterface((IStream *)this, pv);
  } else {
    return CUnknown::NonDelegatingQueryInterface(riid, pv);
  }
}


CFwIStream::~CFwIStream()
{
  DbgLog((LOG_TRACE, 15, TEXT("CFwIStream::~CFwIStream")));
  if(m_hFileSlow != INVALID_HANDLE_VALUE)
  {
      DWORD dwh, dwl = GetFileSize(m_hFileSlow, &dwh);
      CloseHandle(m_hFileSlow);

      // check for zero byte file (w/ error check)
      if((dwl | dwh) == 0) {
          DeleteFile(m_szFilename);
      }
  }
  delete[] m_szFilename;
}

STDMETHODIMP CFwIStream::SetSize(ULARGE_INTEGER libNewSize)
{
  // don't set size to zero if trying to preserve preallocated file
  if(!m_fTruncate && libNewSize.QuadPart == 0) {
      return S_OK;
  }
  
  // needs serialization since we change the file pointer
  CAutoLock l(&m_cs);

  HRESULT hr = S_OK;

  // SetSize() should preserve the file pointer.
  LARGE_INTEGER liOldPos;
  liOldPos.QuadPart = 0;
  liOldPos.LowPart = SetFilePointer(
      m_hFileSlow,
      liOldPos.LowPart,
      &liOldPos.HighPart,
      FILE_CURRENT);
  if(liOldPos.LowPart == 0xffffffff)
  {
      DWORD dwResult = GetLastError();
      if(dwResult != NO_ERROR)
      {
          DbgLog(( LOG_ERROR, 0,
                   TEXT("CFwIStream::SetSize: SetFilePointer failed.")));
          hr = AmHresultFromWin32(dwResult);
      }
  }

  bool fResetFilePointer = false;
  
  if(SUCCEEDED(hr))
  {
      LONG HighPart = libNewSize.HighPart;
    
      DWORD dwResult= SetFilePointer(
          m_hFileSlow,
          libNewSize.LowPart,
          &HighPart,
          FILE_BEGIN);

      if(dwResult == 0xffffffff)
      {
          DWORD dwResult = GetLastError();
          if(dwResult != NO_ERROR)
          {
              DbgLog(( LOG_ERROR, 0,
                       TEXT("CFwIStream::SetSize: SetFilePointer failed.")));
              hr = AmHresultFromWin32(dwResult);
          }
      }

      fResetFilePointer = SUCCEEDED(hr);

      if(SUCCEEDED(hr))
      {

          BOOL f = SetEndOfFile(m_hFileSlow);
          if(f)
          {
              // succcess.
          }
          else
          {
              DWORD dwResult = GetLastError();
              hr = AmHresultFromWin32(dwResult);
          }
      }
  }

  if(fResetFilePointer)
  {
      LONG HighPart = liOldPos.HighPart;
    
      DWORD dwResult= SetFilePointer(
          m_hFileSlow,
          liOldPos.LowPart,
          &HighPart,
          FILE_BEGIN);

      if(dwResult == 0xffffffff)
      {
          DWORD dwResult = GetLastError();
          if(dwResult != NO_ERROR)
          {
              DbgLog(( LOG_ERROR, 0,
                       TEXT("CFwIStream::SetSize: SetFilePointer failed.")));
              hr = AmHresultFromWin32(dwResult);
          }
      }
  }

  return hr;
}

STDMETHODIMP CFwIStream::CopyTo(
  IStream *pstm, ULARGE_INTEGER cb,
  ULARGE_INTEGER *pcbRead,
  ULARGE_INTEGER *pcbWritten)
{
  return E_NOTIMPL;
}
STDMETHODIMP CFwIStream::Commit(DWORD grfCommitFlags)
{
  return E_NOTIMPL;
}
STDMETHODIMP CFwIStream::Revert()
{
  return E_NOTIMPL;
}
STDMETHODIMP CFwIStream::LockRegion(
  ULARGE_INTEGER libOffset,
  ULARGE_INTEGER cb,
  DWORD dwLockType)
{
  return E_NOTIMPL;
}

STDMETHODIMP CFwIStream::UnlockRegion(
  ULARGE_INTEGER libOffset,
  ULARGE_INTEGER cb,
  DWORD dwLockType)
{
  return E_NOTIMPL;
}
STDMETHODIMP CFwIStream::Clone(IStream **ppstm)
{
  return E_NOTIMPL;
}

STDMETHODIMP CFwIStream::Write(
  CONST VOID * pv, ULONG cb, PULONG pcbWritten)
{
  CAutoLock l(&m_cs);
  DWORD dwcbWritten;
  if(!WriteFile(
    m_hFileSlow,
    pv,
    cb,
    &dwcbWritten,
    0))
  {
    DbgLog(( LOG_ERROR, 2,
             NAME("CFwIStream::Write: WriteFile failed.")));

    if(pcbWritten)
      *pcbWritten = 0;
    
    DWORD dwResult = GetLastError();
    return AmHresultFromWin32(dwResult);
  }

  if(pcbWritten)
    *pcbWritten = dwcbWritten;

  if(dwcbWritten != cb)
  {
    // !!! need to test disk full scenario
    DbgBreak("disk full?");
    return HRESULT_FROM_WIN32(ERROR_DISK_FULL);
  }

  return S_OK;
}

STDMETHODIMP CFwIStream::Read(
  void * pv, ULONG cb, PULONG pcbRead)
{
  CAutoLock l(&m_cs);
  DWORD dwcbRead;
  if(!ReadFile(
    m_hFileSlow,
    (void *)pv,
    cb,
    &dwcbRead,
    0))
  {
    DbgLog(( LOG_ERROR, 2,
             NAME("CFileIo::SynchronousRead: ReadFile failed.")));
    DWORD dwResult = GetLastError();
    return AmHresultFromWin32(dwResult);
  }

  if(pcbRead)
    *pcbRead = dwcbRead;

  if(dwcbRead != cb)
  {
    DbgLog((LOG_ERROR, 5, ("CFwIStream: reading off the end")));
    return HRESULT_FROM_WIN32(ERROR_HANDLE_EOF);
  }

  return S_OK;
}

STDMETHODIMP CFwIStream::Seek(
  LARGE_INTEGER dlibMove, DWORD dwOrigin,
  ULARGE_INTEGER *plibNewPosition)
{
  CAutoLock l(&m_cs);
  DWORD dwMoveMethod;
  switch(dwOrigin)
  {
    case STREAM_SEEK_SET:
      dwMoveMethod = FILE_BEGIN;
      break;
              
    case STREAM_SEEK_CUR:
      dwMoveMethod = FILE_CURRENT;
      break;
      
    case STREAM_SEEK_END:
      dwMoveMethod = FILE_END;
      break;

    default:
      DbgBreak("unexpected");
      return E_INVALIDARG;
  }

  LONG HighPart = dlibMove.HighPart;

  DWORD dwResult= SetFilePointer(
    m_hFileSlow,
    dlibMove.LowPart,
    &HighPart,
    dwMoveMethod);

  if(dwResult == 0xffffffff && GetLastError() != NO_ERROR)
  {
    DbgLog(( LOG_ERROR, 2,
             NAME("CFwIStream::Seek: SetFilePointer failed.")));
    DWORD dwResult = GetLastError();
    return AmHresultFromWin32(dwResult);
  }

  if(plibNewPosition)
  {
    plibNewPosition->LowPart = dwResult;
    plibNewPosition->HighPart = HighPart;
  }

  return S_OK;
}

STDMETHODIMP CFwIStream::Stat(
  STATSTG *pstatstg,
  DWORD grfStatFlag)
{
  return E_NOTIMPL;
}

// ------------------------------------------------------------------------
// setup and quartz filter stuff

#ifdef FILTER_DLL

HRESULT DllRegisterServer()
{
  return AMovieDllRegisterServer2(TRUE);
}

HRESULT DllUnregisterServer()
{
  return AMovieDllRegisterServer2(FALSE);
}

CFactoryTemplate g_Templates[]= {
  {L"file writer", &CLSID_FileWriter, CFileWriterFilter::CreateInstance, NULL, &sudFileWriter},
};
int g_cTemplates = sizeof(g_Templates) / sizeof(g_Templates[0]);;

#endif // FILTER_DLL

// setup data - allows the self-registration to work.
AMOVIESETUP_MEDIATYPE sudWriterPinTypes =   {
  &MEDIATYPE_NULL,              // clsMajorType
  &MEDIASUBTYPE_NULL };         // clsMinorType

AMOVIESETUP_PIN psudWriterPins[] =
{
  { L"Input"                    // strName
    , FALSE                     // bRendered
    , FALSE                     // bOutput
    , FALSE                     // bZero
    , FALSE                     // bMany
    , &CLSID_NULL               // clsConnectsToFilter
    , L""                       // strConnectsToPin
    , 1                         // nTypes
    , &sudWriterPinTypes        // lpTypes
  }
};


const AMOVIESETUP_FILTER sudFileWriter =
{
  &CLSID_FileWriter             // clsID
  , L"File writer"              // strName
  , MERIT_DO_NOT_USE            // dwMerit
  , 1                           // nPins
  , psudWriterPins              // lpPin
};

CUnknown *CFileWriterFilter::CreateInstance(LPUNKNOWN punk, HRESULT *pHr)
{
  return new CFileWriterFilter(punk, pHr);
}
=== C:/Users/treeman/Desktop/windows nt source code\Source\Win2K3\NT\multimedia\dshow\filterus\writer\fio.h ===
// Copyright (c) 1996 - 1999  Microsoft Corporation.  All Rights Reserved.
#pragma warning(disable: 4097 4511 4512 4514 4705)

// Asynchronous, unbuffered file writer using completion ports and a
// separate writer thread
//


#ifndef _FileIo_H
#define _FileIo_H

extern const AMOVIESETUP_FILTER sudFileWriter ;


#include <windows.h>            // for win32 functions, types
#include "fw.h"

// This structure is passed in for a write. The misc pointer is for a
// container object which needs to be Released() when the write is
// complete. dwSize field may be overwritten.
//
struct WriteRequest : OVERLAPPED
{
  void SetPos(DWORDLONG dwlPos)
    {
      Offset = (DWORD)(dwlPos & 0xffffffff), OffsetHigh = (DWORD)(dwlPos >> 32);
    }

  DWORD dwSize;
  BYTE *pb;
  void *pMisc;
  FileIoCallback fnCallback;
};

class CFileIo;

class CFileWriterFilter :
  public CBaseWriterFilter,
  public CPersistStream,
  public IFileSinkFilter2
{
public:
  CFileWriterFilter(LPUNKNOWN pUnk, HRESULT *pHr);
  ~CFileWriterFilter();
  
  HRESULT Open();               // needed to get alignment
  HRESULT Close();              // needed to return error value
  HRESULT GetAlignReq(ULONG *pcbAlign);

  HRESULT AsyncWrite(
    const DWORDLONG dwlFileOffset,
    const ULONG cb,
    BYTE *pb,
    FileIoCallback fnCallback,
    void *pCallbackArg);

  STDMETHODIMP NotifyAllocator(
    IMemAllocator * pAllocator,
    BOOL bReadOnly);  

  HRESULT CreateFileObject();

  static CUnknown *CreateInstance(LPUNKNOWN punk, HRESULT *pHr);

  DECLARE_IUNKNOWN;  
  STDMETHODIMP NonDelegatingQueryInterface(REFIID riid, void ** ppv);

  // Return IStream
  STDMETHODIMP CreateIStream(void **ppStream);

    //
  // Implements the IFileSinkFilter interface
  //
  STDMETHODIMP SetFileName(
    LPCOLESTR pszFileName,
    const AM_MEDIA_TYPE *pmt);

  STDMETHODIMP SetMode(
    DWORD dwFlags);

  STDMETHODIMP GetCurFile(
    LPOLESTR * ppszFileName,
    AM_MEDIA_TYPE *pmt);

  STDMETHODIMP GetMode(
    DWORD *pdwFlags);

  STDMETHODIMP CanPause();

private:

  // CPersistStream
  HRESULT WriteToStream(IStream *pStream);
  HRESULT ReadFromStream(IStream *pStream);
  int SizeMax();
  STDMETHODIMP GetClassID(CLSID *pClsid);
    

  CFileIo *m_pFileIo;

  BOOL m_fBufferedIo;
  OLECHAR *m_wszFileName;
  DWORD m_dwOpenFlags;
};

class CFileIo :
  public CAMThread
{
public:

  CFileIo(WCHAR *wszName, BOOL fBuffered, BOOL fOpenExisting, HRESULT *phr);
  virtual ~CFileIo();

  HRESULT Open();
  virtual HRESULT DoCreateFile();
  HRESULT Close();
  HRESULT GetAlignReq(ULONG *pcbAlign);

  HRESULT AsyncWrite(
    const DWORDLONG dwlFileOffset,
    const ULONG cb,
    BYTE *pb,
    FileIoCallback fnCallback,
    void *pCallbackArg);

protected:

  virtual HRESULT QueueAsyncWrite(
    WriteRequest *pReq);

  virtual HRESULT GetCompletedWrite(
    DWORD *pdwcbTransferred,
    DWORD_PTR *pdwCompletionKey,
    WriteRequest **ppReq);

  // this is used to unblock the worker if it is blocked and there is
  // no pending write to unblock it.
  virtual HRESULT PostCompletedMsg(DWORD_PTR dwKey);

protected:

  void Cleanup();
  BOOL GetRoot(TCHAR szDest_[MAX_PATH], TCHAR *const szSrc_);
  HRESULT SetFilename(WCHAR* wszName);

  ULONG m_cbSector;
  TCHAR m_szName[MAX_PATH];

  HANDLE m_hFileFast;           /* unbuffered, possibly asynchronous */
  HANDLE m_hCPort;

  // thread commands
  HRESULT StopWorker();

  // thread
  DWORD ThreadProc();
  
  CQueue<WriteRequest *> m_qWriteReq;
  long m_ilcActive;
  HRESULT m_hrError;
  WriteRequest *m_rgWriteReq;

  BOOL m_fBuffered;
  BOOL m_fOpenExisting;

  volatile BOOL m_fStopping;

  enum Command
  {
    CMD_EXIT
  };
  
  void CallCallback(WriteRequest *pReq);

#ifdef PERF
  int m_idPerfWrite;
#endif PERF
};

// uses synchronous i/o with a separate thread to queue writes
class CSyncFileIo :
  public CFileIo
{
public:
  CSyncFileIo(WCHAR *wszName, BOOL fBuffered, BOOL fOpenExisting, HRESULT *phr);
  HRESULT DoCreateFile();  

  HRESULT QueueAsyncWrite(
    WriteRequest *pReq);

  HRESULT GetCompletedWrite(
    DWORD *pdwcbTransferred,
    DWORD_PTR *pdwCompletionKey,
    WriteRequest **ppReq);

  HRESULT PostCompletedMsg(DWORD_PTR dwKey);

private:
  CQueue<WriteRequest *> m_qPendingWrites;  
};

class CFwIStream :
  public IStream,
  public CUnknown
{
public:
  CFwIStream(WCHAR *wszName, TCHAR *pName, LPUNKNOWN lpUnk, bool fTruncate, HRESULT *phr);
    
  ~CFwIStream();

  // IStream interfaces
  DECLARE_IUNKNOWN
  STDMETHODIMP NonDelegatingQueryInterface(REFIID riid, void ** pv);

  STDMETHODIMP SetSize(ULARGE_INTEGER libNewSize);

  STDMETHODIMP CopyTo(
    IStream *pstm,
    ULARGE_INTEGER cb,
    ULARGE_INTEGER *pcbRead,
    ULARGE_INTEGER *pcbWritten);

  STDMETHODIMP Commit(DWORD grfCommitFlags);
  STDMETHODIMP Revert();

  STDMETHODIMP LockRegion(
    ULARGE_INTEGER libOffset,
    ULARGE_INTEGER cb,
    DWORD dwLockType);

  STDMETHODIMP UnlockRegion(
    ULARGE_INTEGER libOffset,
    ULARGE_INTEGER cb,
    DWORD dwLockType);

  STDMETHODIMP Clone(IStream **ppstm);

  STDMETHODIMP Write(CONST VOID *pv, ULONG cb, PULONG pcbWritten);
  STDMETHODIMP Read(void * pv, ULONG cb, PULONG pcbRead);
  STDMETHODIMP Seek(
    LARGE_INTEGER dlibMove, DWORD dwOrigin,
    ULARGE_INTEGER *plibNewPosition);
  STDMETHODIMP Stat(
    STATSTG *pstatstg,
    DWORD grfStatFlag);

private:

  HANDLE m_hFileSlow;           /* synchronous buffered */
  CCritSec m_cs;
  bool m_fTruncate;
  TCHAR *m_szFilename;
};


#endif // _FileIo_H
=== C:/Users/treeman/Desktop/windows nt source code\Source\Win2K3\NT\multimedia\dshow\filterus\wav\acmwrap\acmwrap.cpp ===
// Copyright (c) 1994 - 1999  Microsoft Corporation.  All Rights Reserved.
// Quartz wrapper for ACM, David Maymudes, January 1996
//
//  10/15/95 mikegi - created
//

#include <streams.h>
#include <mmsystem.h>
#include <mmreg.h>
#include <msacm.h>
#include <measure.h>
#include <dynlink.h>
#include <malloc.h>
#include <tchar.h>

#ifdef FILTER_DLL
// define the GUIDs for streams and my CLSID in this file
#include <initguid.h>
#endif

#include "acmwrap.h"

//*****************************************************************************
//*****************************************************************************
//*****************************************************************************
// setup data

const AMOVIESETUP_MEDIATYPE
sudPinTypes = { &MEDIATYPE_Audio      // clsMajorType
, &MEDIASUBTYPE_NULL }; // clsMinorType

const AMOVIESETUP_PIN sudpPins [] =
{
    { L"Input"             // strName
        , FALSE              // bRendered
        , FALSE              // bOutput
        , FALSE              // bZero
        , FALSE              // bMany
        , &CLSID_NULL        // clsConnectsToFilter
        , L"Output"          // strConnectsToPin
        , 1                  // nTypes
        , &sudPinTypes       // lpTypes
    },
    { L"Output"            // strName
    , FALSE              // bRendered
    , TRUE               // bOutput
    , FALSE              // bZero
    , FALSE              // bMany
    , &CLSID_NULL        // clsConnectsToFilter
    , L"Input"           // strConnectsToPin
    , 1                  // nTypes
    , &sudPinTypes       // lpTypes
    }
};


const AMOVIESETUP_FILTER sudAcmWrap =
{ &CLSID_ACMWrapper    // clsID
, L"ACM Wrapper"       // strName
, MERIT_NORMAL         // dwMerit
, 2                    // nPins
, sudpPins };          // lpPin


//*****************************************************************************
//*****************************************************************************
//*****************************************************************************

#ifdef FILTER_DLL
// List of class IDs and creator functions for class factory
CFactoryTemplate g_Templates[] =
{
    { L"ACM Wrapper"
        , &CLSID_ACMWrapper
        , CACMWrapper::CreateInstance
        , NULL
        , &sudAcmWrap }
};

int g_cTemplates = sizeof(g_Templates) / sizeof(g_Templates[0]);

//*****************************************************************************
//*****************************************************************************
//*****************************************************************************
// exported entry points for registration and unregistration (in this case they
// only call through to default implmentations).
//

STDAPI DllRegisterServer()
{
    return AMovieDllRegisterServer2( TRUE );
}

STDAPI DllUnregisterServer()
{
    return AMovieDllRegisterServer2( FALSE );
}

#endif

//*****************************************************************************
//*****************************************************************************
//*****************************************************************************
//
// CreateInstance()
//
//

CUnknown *CACMWrapper::CreateInstance(LPUNKNOWN pUnk, HRESULT * phr)
{
    DbgLog((LOG_TRACE, 2, TEXT("CACMWrapper::CreateInstance")));

    return new CACMWrapper(TEXT("ACM wrapper transform"), pUnk, phr);
}


//*****************************************************************************
//
// NonDelegatingQueryInterface()
//
//

STDMETHODIMP CACMWrapper::NonDelegatingQueryInterface( REFIID riid, void **ppv )
{
    *ppv = NULL;

    if( riid == IID_IPersist )
    {
        return GetInterface((IPersist *) (CTransformFilter *)this, ppv);
    }
    else if( riid == IID_IPersistPropertyBag )
    {
        return GetInterface((IPersistPropertyBag *)this, ppv);
    }
    else if( riid == IID_IPersistStream )
    {
        return GetInterface((IPersistStream *)this, ppv);
    }

    {
        return CTransformFilter::NonDelegatingQueryInterface(riid, ppv);
    }
}


//*****************************************************************************
//
// CACMWrapper()
//
//

CACMWrapper::CACMWrapper( TCHAR *pName, LPUNKNOWN pUnk, HRESULT *phr )
: CTransformFilter( pName,
                   pUnk,
                   CLSID_ACMWrapper),
                   m_hacmStream(NULL),
                   m_bStreaming(FALSE),
                   m_lpwfxOutput(NULL),
                   m_cbwfxOutput(0),
                   m_cArray(0),
                   m_lpExtra(NULL),
                   m_cbExtra(0),
                   m_wFormatTag(WAVE_FORMAT_PCM),
                   m_rgFormatMap(NULL),
                   m_pFormatMapPos(NULL),
                   m_wCachedTryFormat(0),
                   m_wSourceFormat(0),
                   m_wTargetFormat(0),
                   m_wCachedSourceFormat(0),
                   m_wCachedTargetFormat(0),
                   CPersistStream(pUnk, phr)
{
    DbgLog((LOG_TRACE,2,TEXT("CACMWrapper constructor")));

}


//*****************************************************************************
//
// ~CACMWrapper()
//
//

CACMWrapper::~CACMWrapper()
{
    CAutoLock lock(&m_csFilter);

    DbgLog((LOG_TRACE,2,TEXT("~CACMWrapper")));

    if( m_hacmStream )
    {
        DbgLog((LOG_TRACE,5,TEXT("  closing m_hacmStream")));
        acmStreamClose( m_hacmStream, 0 );
        m_hacmStream = NULL;
    }

    if (m_lpwfxOutput)
        QzTaskMemFree(m_lpwfxOutput);

    // our cached formats we can offer through GetMediaType
    while (m_cArray-- > 0)
        QzTaskMemFree(m_lpwfxArray[m_cArray]);

    if (m_cbExtra)
        QzTaskMemFree(m_lpExtra);
}


// !!! stolen from msaudio.h
#if !defined(WAVE_FORMAT_MSAUDIO)
#   define  WAVE_FORMAT_MSAUDIO     353
#   define  MSAUDIO_ENCODE_KEY "F6DC9830-BC79-11d2-A9D0-006097926036"
#   define  MSAUDIO_DECODE_KEY "1A0F78F0-EC8A-11d2-BBBE-006008320064"
#endif
#if !defined(WAVE_FORMAT_MSAUDIOV1)
#   define  WAVE_FORMAT_MSAUDIOV1     352
#endif

#include "..\..\..\filters\asf\wmsdk\inc\wmsdk.h"

MMRESULT CACMWrapper::CallacmStreamOpen
(
 LPHACMSTREAM            phas,       // pointer to stream handle
 HACMDRIVER              had,        // optional driver handle
 LPWAVEFORMATEX          pwfxSrc,    // source format to convert
 LPWAVEFORMATEX          pwfxDst,    // required destination format
 LPWAVEFILTER            pwfltr,     // optional filter
 DWORD_PTR               dwCallback, // callback
 DWORD_PTR               dwInstance, // callback instance data
 DWORD                   fdwOpen     // ACM_STREAMOPENF_* and CALLBACK_*
 ) {

    if (pwfxSrc && (pwfxSrc->wFormatTag == WAVE_FORMAT_MSAUDIO ||
        pwfxSrc->wFormatTag == WAVE_FORMAT_MSAUDIOV1)) {
        if (m_pGraph) {
            IObjectWithSite *pSite;
            HRESULT hrKey = m_pGraph->QueryInterface(IID_IObjectWithSite, (VOID **)&pSite);
            if (SUCCEEDED(hrKey)) {
                IServiceProvider *pSP;
                hrKey = pSite->GetSite(IID_IServiceProvider, (VOID **)&pSP);
                pSite->Release();

                if (SUCCEEDED(hrKey)) {
                    IUnknown *pKey;
                    hrKey = pSP->QueryService(__uuidof(IWMReader), IID_IUnknown, (void **) &pKey);
                    pSP->Release();

                    if (SUCCEEDED(hrKey)) {
                        // !!! verify key?
                        pKey->Release();
                        DbgLog((LOG_TRACE, 1, "Unlocking MSAudio codec"));

                        char *p = (char *) _alloca(sizeof(WAVEFORMATEX) + pwfxSrc->cbSize + sizeof(MSAUDIO_DECODE_KEY));

                        CopyMemory(p, pwfxSrc, sizeof(WAVEFORMATEX) + pwfxSrc->cbSize);

                        pwfxSrc = (WAVEFORMATEX *) p;

                        if (pwfxSrc->cbSize < sizeof(MSAUDIO_DECODE_KEY)) {
                            strcpy(p + sizeof(WAVEFORMATEX) + pwfxSrc->cbSize, MSAUDIO_DECODE_KEY);
                            pwfxSrc->cbSize += sizeof(MSAUDIO_DECODE_KEY);
                        } else {
                            strcpy(p + sizeof(WAVEFORMATEX) + pwfxSrc->cbSize - sizeof(MSAUDIO_DECODE_KEY),
                                MSAUDIO_DECODE_KEY);
                        }
                    }
                }
            }
        }
    }

    if (pwfxDst && (pwfxDst->wFormatTag == WAVE_FORMAT_MSAUDIO ||
        pwfxDst->wFormatTag == WAVE_FORMAT_MSAUDIOV1)) {
        char *p = (char *) _alloca(sizeof(WAVEFORMATEX) + pwfxDst->cbSize + sizeof(MSAUDIO_ENCODE_KEY));

        CopyMemory(p, pwfxDst, sizeof(WAVEFORMATEX) + pwfxDst->cbSize);

        pwfxDst = (WAVEFORMATEX *) p;

        if (pwfxDst->cbSize < sizeof(MSAUDIO_ENCODE_KEY)) {
            strcpy(p + sizeof(WAVEFORMATEX) + pwfxDst->cbSize, MSAUDIO_ENCODE_KEY);
            pwfxDst->cbSize += sizeof(MSAUDIO_ENCODE_KEY);
        } else {
            strcpy(p + sizeof(WAVEFORMATEX) + pwfxDst->cbSize - sizeof(MSAUDIO_ENCODE_KEY),
                MSAUDIO_ENCODE_KEY);
        }
    }

    return acmStreamOpen(phas, had, pwfxSrc, pwfxDst, pwfltr, dwCallback, dwInstance, fdwOpen);
}



















//*****************************************************************************
//
// DumpWAVEFORMATEX()
//
//



#ifdef DEBUG
// note: the debug build will not use dynamic linking to MSACM32.

#define DumpWAVEFORMATEX(args) XDumpWAVEFORMATEX args

 void XDumpWAVEFORMATEX( char *psz, WAVEFORMATEX *pwfx )
 {

     ACMFORMATTAGDETAILS acmftd;

     ACMFORMATDETAILS acmfd;
     DWORD            dwSize;
     WAVEFORMATEX     *pwfxQuery;


     if( psz ) DbgLog((LOG_TRACE,4,TEXT("%s" ),psz));

     //--------------------  Dump WAVEFORMATEX  ------------------------

     DbgLog((LOG_TRACE,4,TEXT("  wFormatTag           %u" ), pwfx->wFormatTag));
     DbgLog((LOG_TRACE,4,TEXT("  nChannels            %u" ), pwfx->nChannels));
     DbgLog((LOG_TRACE,4,TEXT("  nSamplesPerSec       %lu"), pwfx->nSamplesPerSec));
     DbgLog((LOG_TRACE,4,TEXT("  nAvgBytesPerSec      %lu"), pwfx->nAvgBytesPerSec));
     DbgLog((LOG_TRACE,4,TEXT("  nBlockAlign          %u" ), pwfx->nBlockAlign));
     DbgLog((LOG_TRACE,4,TEXT("  wBitsPerSample       %u" ), pwfx->wBitsPerSample));

     //  if( pmt->FormatLength() >= sizeof(WAVEFORMATEX) )
     //   {
     //    DbgLog((LOG_TRACE,1,TEXT("  cbSize                %u"), pwfx->cbSize));
     //   }

     //---------------------  Dump format type  ------------------------

     memset( &acmftd, 0, sizeof(acmftd) );

     acmftd.cbStruct    = sizeof(acmftd);
     acmftd.dwFormatTag = (DWORD)pwfx->wFormatTag;

     MMRESULT mmr;
     mmr = acmFormatTagDetails( NULL, &acmftd, ACM_FORMATTAGDETAILSF_FORMATTAG );
     if( mmr == 0 )
     {
         DbgLog((LOG_TRACE,4,TEXT("  szFormatTag          '%s'"),acmftd.szFormatTag));
     }
     else
     {
         DbgLog((LOG_ERROR,1,TEXT("*** acmFormatTagDetails failed, mmr = %u"),mmr));
     }


     //-----------------------  Dump format  ---------------------------

     dwSize = sizeof(WAVEFORMATEX)+pwfx->cbSize;

     pwfxQuery = (WAVEFORMATEX *)LocalAlloc( LPTR, dwSize );
     if( pwfxQuery )
     {
         memcpy( pwfxQuery, pwfx, dwSize );

         memset( &acmfd, 0, sizeof(acmfd) );

         acmfd.cbStruct    = sizeof(acmfd);
         acmfd.dwFormatTag = (DWORD)pwfx->wFormatTag;
         acmfd.pwfx        = pwfxQuery;
         acmfd.cbwfx       = dwSize;

         mmr = acmFormatDetails( NULL, &acmfd, ACM_FORMATDETAILSF_FORMAT );
         if( mmr == 0 )
         {
             DbgLog((LOG_TRACE,4,TEXT("  szFormat             '%s'"),acmfd.szFormat));
         }
         else
         {
             DbgLog((LOG_ERROR,1,TEXT("*** acmFormatDetails failed, mmr = %u"),mmr));
         }

         LocalFree( pwfxQuery );
     }
     else
     {
         DbgLog((LOG_ERROR,1,TEXT("*** LocalAlloc failed")));
     }
 }

#else

#define DumpWAVEFORMATEX(args)

#endif

 //*****************************************************************************
 //
 // CheckInputType()
 //
 // We will accept anything that we can transform into a type with the
 // format tag we are supposed to always be outputting
 //


 HRESULT CACMWrapper::CheckInputType(const CMediaType* pmtIn)
 {
     HRESULT      hr;
     WAVEFORMATEX *pwfx;
     MMRESULT     mmr;
     DWORD        dwSize;
     WAVEFORMATEX *pwfxOut, *pwfxMapped;

     DbgLog((LOG_TRACE, 3, TEXT("CACMWrapper::CheckInputType")));

     //DisplayType("pmtIn details:", pmtIn);

     hr = VFW_E_INVALIDMEDIATYPE;

     pwfx = (WAVEFORMATEX *)pmtIn->Format();

     if (pmtIn->majortype != MEDIATYPE_Audio) {
         DbgLog((LOG_ERROR, 1, TEXT("*** CheckInputType only takes audio")));
         return hr;
     }

     if (pmtIn->FormatLength() < sizeof(PCMWAVEFORMAT)) {
         DbgLog((LOG_ERROR, 1, TEXT("*** pmtIn->FormatLength < PCMWAVEFORMAT")));
         return hr;
     }

     if (*pmtIn->FormatType() != FORMAT_WaveFormatEx) {
         DbgLog((LOG_ERROR,1,TEXT("*** pmtIn->FormatType != FORMAT_WaveFormatEx"
             )));
         return hr;
     }

     // some invalid formats have non-zero cbSize with PCM, which makes me blow
     // up
     if (((LPWAVEFORMATEX)(pmtIn->Format()))->wFormatTag == WAVE_FORMAT_PCM &&
         ((LPWAVEFORMATEX)(pmtIn->Format()))->cbSize > 0) {
         DbgLog((LOG_ERROR,1,TEXT("*** cbSize > 0 for PCM !!!")));
         return hr;
     }

     // it takes 200ms for acmFormatSuggest to say, "yes, I can convert PCM".
     // What a waste of time!  Of course we can accept any PCM data, as long as
     // we're in "accepting PCM" mode
     if (m_wFormatTag == WAVE_FORMAT_PCM && pwfx->wFormatTag == WAVE_FORMAT_PCM)
         return S_OK;

     mmr = acmMetrics( NULL, ACM_METRIC_MAX_SIZE_FORMAT, &dwSize );
     if (mmr == 0) {

         // make sure that the size returned is big enough for a WAVEFORMATEX
         // structure.

         if (dwSize < sizeof (WAVEFORMATEX))
             dwSize = sizeof (WAVEFORMATEX) ;

         // Hack for VoxWare codec bug
         if (dwSize < 256)
             dwSize = 256;

         pwfxOut = (WAVEFORMATEX *)LocalAlloc( LPTR, dwSize );
         if (pwfxOut) {

             // ask for formats with a specific tag
             pwfxOut->wFormatTag = m_wFormatTag;
             //pwfxOut->cbSize = 0;

             if (pwfx->wFormatTag != m_wCachedSourceFormat) {
                 // usual case
                 mmr = acmFormatSuggest(NULL, pwfx, pwfxOut, dwSize, ACM_FORMATSUGGESTF_WFORMATTAG);
             } else {
                 DbgLog((LOG_TRACE, 1, TEXT("*** CheckInputType: remapping input format %u to %u"), m_wCachedSourceFormat, m_wCachedTryFormat));

                 pwfxMapped = (LPWAVEFORMATEX)_alloca(sizeof(WAVEFORMATEX) + pwfx->cbSize);
                 CopyMemory(pwfxMapped, pwfx, sizeof(WAVEFORMATEX) + pwfx->cbSize);
                 pwfxMapped->wFormatTag = m_wCachedTryFormat;  // remap tags

                 mmr = acmFormatSuggest(NULL, pwfxMapped, pwfxOut, dwSize, ACM_FORMATSUGGESTF_WFORMATTAG);
             }

             if(mmr == 0) {
                 if(pwfx->wFormatTag == m_wCachedSourceFormat)
                     m_wCachedTargetFormat = m_wCachedTryFormat; // save our new cached target format

                 DumpWAVEFORMATEX(("Input accepted. It can produce:", pwfxOut));
                 hr = NOERROR;
             } else {
                 DbgLog((LOG_TRACE,3,TEXT("Input rejected: Cannot produce tag %d"), m_wFormatTag));
             }

             LocalFree( pwfxOut );
         } else {
             DbgLog((LOG_ERROR,1,TEXT("LocalAlloc failed")));
         }
     } else {
         DbgLog((LOG_ERROR,1,TEXT("acmMetrics failed, mmr = %u"), mmr));
     }

     if (mmr && !m_wCachedTryFormat) {
         DbgLog((LOG_TRACE, 1, TEXT("CheckInputType: Trying ACMCodecMapper....")));
         if (ACMCodecMapperOpen(m_wCachedSourceFormat = pwfx->wFormatTag) != ERROR_SUCCESS) {
             m_wCachedTryFormat = m_wCachedSourceFormat = m_wCachedTargetFormat = 0;
             ACMCodecMapperClose();  // may have been a partial open failure
             return hr;
         }

         while(m_wCachedTryFormat = ACMCodecMapperQuery()) {
             if(m_wCachedTryFormat == pwfx->wFormatTag)  // no need to retry our current format
                 continue;

             if(SUCCEEDED(CheckInputType(pmtIn))) {
                 ACMCodecMapperClose();
                 return NOERROR;
             }
         }
         ACMCodecMapperClose();
     }

     return hr;
}

// helper function used for cleaning up after the acm codec mapper (a set of registry entries specifying equivalence classes for wave format tags)
void CACMWrapper::ACMCodecMapperClose()
{
    DbgLog((LOG_TRACE,2,TEXT("::ACMCodecMapperClose()")));

    if (m_rgFormatMap) {
        delete[] m_rgFormatMap;
        m_rgFormatMap  = NULL;
    }

    m_pFormatMapPos     = NULL;
    m_wCachedTryFormat  = 0;
}

// helper function used for opening the codec mapper (a set of registry entries specifying equivalence classes for wave format tags) and finding
// the equivalence class for format 'dwFormatTag'
DWORD CACMWrapper::ACMCodecMapperOpen(WORD dwFormatTag)
{
    DbgLog((LOG_TRACE,2,TEXT("::ACMCodecMapperOpen(%u)"), dwFormatTag));

    ASSERT(m_rgFormatMap == NULL);

    HKEY hkMapper;
    LONG lResult = RegOpenKeyEx(
        HKEY_LOCAL_MACHINE,
        TEXT("SOFTWARE\\Microsoft\\NetShow\\Player\\CodecMapper\\ACM"),
        0,
        KEY_READ,
        &hkMapper);

    if (lResult != ERROR_SUCCESS) {
        DbgLog((LOG_ERROR,1,TEXT("RegOpenKeyEx failed lResult = %u"), lResult));
        return lResult;
    }

    TCHAR szTarget[10];

    wsprintf(szTarget, TEXT("%d"), dwFormatTag);

    DWORD dwFormatMapLengthBytes;
    lResult = RegQueryValueEx(hkMapper, szTarget, NULL, NULL, NULL, &dwFormatMapLengthBytes);
    if(lResult != ERROR_SUCCESS) {
        DbgLog((LOG_TRACE,1,TEXT("RegQueryValueEx failed lResult = %u"), lResult));
        RegCloseKey(hkMapper);
        return lResult;
    }

    m_rgFormatMap = new TCHAR[dwFormatMapLengthBytes/sizeof(TCHAR) + 1];
    if (!m_rgFormatMap) {
        RegCloseKey(hkMapper);
        return E_OUTOFMEMORY;
    }

    m_pFormatMapPos = m_rgFormatMap;

    lResult = RegQueryValueEx(hkMapper, szTarget, NULL, NULL,
        (BYTE *) m_rgFormatMap, &dwFormatMapLengthBytes);
    if(lResult != ERROR_SUCCESS) {
        DbgLog((LOG_TRACE,1,TEXT("RegQueryValueEx failed lResult = %u"), lResult));
    }

    RegCloseKey(hkMapper);

    return lResult;
}

// helper function used getting the next entry in the codec mapper (a set of registry entries specifying equivalence classes for wave format tags)
WORD CACMWrapper::ACMCodecMapperQuery()
{
    DbgLog((LOG_TRACE,3,TEXT("::ACMCodecMapperQuery()")));

    if(!m_rgFormatMap || !m_pFormatMapPos)
        return 0;   // 0 is an invalid format

    DbgLog((LOG_TRACE,3,TEXT("Finding next format")));

    TCHAR *pCurFormat;
    WORD wCurFormat;
    pCurFormat = m_pFormatMapPos;
    for(;;) {
        if(*pCurFormat == TCHAR(',')) {
            *pCurFormat = TCHAR('\0');  // null terminate the substring from m_pFormatMapPos to pCurFormatPos (if necessary)
            wCurFormat = (WORD)_ttoi(m_pFormatMapPos); // cvt this substring

            DbgLog((LOG_TRACE,3,TEXT("Found delimeter, wCurFormat=%u"), wCurFormat));

            m_pFormatMapPos = ++pCurFormat; // prepare for the next substring
            return wCurFormat;
        } else if(*pCurFormat == TCHAR('\0')) {
            wCurFormat = (WORD)_ttoi(m_pFormatMapPos); // cvt this substring

            DbgLog((LOG_TRACE,3,TEXT("Found eos, wCurFormat=%u"), wCurFormat));

            m_pFormatMapPos = NULL; // we're done for good
            return wCurFormat;
        }

        ++pCurFormat;
    }

    DbgLog((LOG_TRACE,2,TEXT("Exiting ::ACMCodecMapperQuery(), no format found")));

    return 0; // invalid format
}

// Every format supported comes through here.  We memorize them all so we
// can quickly offer them in GetMediaType without taking O(n) time
// We will only memorize formats that match the kind of formats we're
// supposed to allow (we only work with a specific format tag, m_wFormatTag
//
BOOL FormatEnumCallback(HACMDRIVERID had, LPACMFORMATDETAILS lpafd, DWORD_PTR dwInstance, DWORD fdwSupport)
{
    CACMWrapper *pC = (CACMWrapper *)dwInstance;

    if (pC->m_cArray < MAXTYPES) {
        // Is this a format we care to offer?
        if (lpafd->pwfx->wFormatTag == pC->m_wFormatTag) {
            DWORD dwSize = max(sizeof(WAVEFORMATEX), lpafd->cbwfx);
            pC->m_lpwfxArray[pC->m_cArray] = (LPWAVEFORMATEX)QzTaskMemAlloc(
                dwSize);
            if (pC->m_lpwfxArray[pC->m_cArray]) {
                CopyMemory(pC->m_lpwfxArray[pC->m_cArray], lpafd->pwfx,
                    lpafd->cbwfx);
                if (lpafd->pwfx->wFormatTag == WAVE_FORMAT_PCM)
                    // not necessarily 0 in MSACM but Quartz promises it will be
                    pC->m_lpwfxArray[pC->m_cArray]->cbSize = 0;
                pC->m_cArray++;
            } else {
                return FALSE;
            }
        }
    } else {
        return FALSE;   // I'm stuffed
    }
    return TRUE;
}


HRESULT CACMWrapper::MakePCMMT(int freq)
{
    int xx, yy;
    for (xx=16;xx>=8;xx-=8) {
        for (yy=2;yy>=1;yy--) {
            m_lpwfxArray[m_cArray] = (LPWAVEFORMATEX)QzTaskMemAlloc(
                sizeof(WAVEFORMATEX));
            if (m_lpwfxArray[m_cArray] == NULL)
                return E_OUTOFMEMORY;
            m_lpwfxArray[m_cArray]->wFormatTag = WAVE_FORMAT_PCM;
            m_lpwfxArray[m_cArray]->wBitsPerSample = (WORD)xx;
            m_lpwfxArray[m_cArray]->nChannels = (WORD)yy;
            m_lpwfxArray[m_cArray]->nSamplesPerSec = freq;
            m_lpwfxArray[m_cArray]->nBlockAlign = (xx / 8) * yy;
            m_lpwfxArray[m_cArray]->nAvgBytesPerSec = freq * (xx / 8) * yy;
            m_lpwfxArray[m_cArray]->cbSize = 0;
            m_cArray++;
        }
    }
    return S_OK;
}


// Helper function for GetMediaType
// Makes a note of all the formats we can output given our current input.
// If we have no input type yet, just get all the formats this tag can possibly
// produce. (NetShow will use that part)
//
HRESULT CACMWrapper::InitMediaTypes()
{
    HRESULT hr;
    MMRESULT mmr;
    DWORD dwSize;
    ACMFORMATDETAILS afd;
    LPWAVEFORMATEX lpwfxMapped;
    LPWAVEFORMATEX lpwfxEnum;
    LPWAVEFORMATEX lpwfxIn;
    if (m_pInput->IsConnected())
        lpwfxIn = (LPWAVEFORMATEX)m_pInput->CurrentMediaType().Format();
    else
        lpwfxIn = NULL;

    // we've been called before.
    if (m_cArray > 0)
        return NOERROR;

    DbgLog((LOG_TRACE, 2, TEXT("*** Enumerating our MediaTypes")));

    // Find out every type we can convert our input format into

    // How big is the biggest format?
    mmr = acmMetrics(NULL, ACM_METRIC_MAX_SIZE_FORMAT, &dwSize);
    if (mmr != 0)
        return E_FAIL;
    if (dwSize < sizeof(WAVEFORMATEX))
        dwSize = sizeof(WAVEFORMATEX) ;

    // Hack for VoxWare codec bug
    if (dwSize < 256)
        dwSize = 256;

    if (lpwfxIn == NULL)
        goto SkipSuggest;

    // The first thing we want to offer is ACM's suggested preferred format,
    // because that's usually the best choice.
    // But if we are converting PCM to PCM, then the first thing we want to
    // offer is the same format as the input format so we NEVER CONVERT by
    // default.
    // !!! We'll end up offering this twice, once now, once when we enum all
    m_lpwfxArray[0] = (LPWAVEFORMATEX)QzTaskMemAlloc(dwSize);
    if (m_lpwfxArray[0] == NULL)
        return E_OUTOFMEMORY;
    ZeroMemory(m_lpwfxArray[0], dwSize);

    if (m_wFormatTag == WAVE_FORMAT_PCM && lpwfxIn->wFormatTag ==
        WAVE_FORMAT_PCM) {
        CopyMemory(m_lpwfxArray[0], lpwfxIn, sizeof(WAVEFORMATEX));
        m_cArray = 1;
    } else {
        // ask for formats with a specific tag
        m_lpwfxArray[0]->wFormatTag = m_wFormatTag;


        if(lpwfxIn->wFormatTag != m_wSourceFormat)
        {
            // this is the typical case
            mmr = acmFormatSuggest(NULL, lpwfxIn, m_lpwfxArray[0], dwSize,
                ACM_FORMATSUGGESTF_WFORMATTAG);
        }
        else
        {
            DbgLog((LOG_TRACE, 1, TEXT("*** InitMediaTypes: remapping input format %u to %u"), m_wSourceFormat, m_wTargetFormat));

            // should we bound this alloc/copy by dwSize to protect against a bogus cbSize?
            // but if we did we'd need to update the format's cbSize
            lpwfxMapped = (LPWAVEFORMATEX)_alloca(sizeof(WAVEFORMATEX) + lpwfxIn->cbSize);
            CopyMemory(lpwfxMapped, lpwfxIn, sizeof(WAVEFORMATEX) + lpwfxIn->cbSize);
            lpwfxMapped->wFormatTag = m_wTargetFormat;  // remap tags

            mmr = acmFormatSuggest(NULL, lpwfxMapped, m_lpwfxArray[0], dwSize, ACM_FORMATSUGGESTF_WFORMATTAG);
        }

        if (mmr == 0) {
            m_cArray = 1;       // OK, we have our first format
            if (m_lpwfxArray[0]->wFormatTag == WAVE_FORMAT_PCM)
                // not necessarily 0 in MSACM, but Quartz promises it will be
                m_lpwfxArray[0]->cbSize = 0;
        } else {
            QzTaskMemFree(m_lpwfxArray[0]);
        }
    }

SkipSuggest:

    // Now, if we are in PCM conversion mode, we want to construct all of the
    // formats we offer in some logical order, and not waste time asking ACM
    // which will not admit to 48000 and 32000, and offer bad quality formats
    // first, and take a long time to do it
    if (m_wFormatTag == WAVE_FORMAT_PCM && (lpwfxIn == NULL ||
        lpwfxIn->wFormatTag == WAVE_FORMAT_PCM)) {
        MakePCMMT(44100);
        MakePCMMT(22050);
        MakePCMMT(11025);
        MakePCMMT(8000);
        MakePCMMT(48000);       // done last so we'll connect to fussy filters
        hr = MakePCMMT(32000);  // but not prefer these wierd formats

        return hr;
    }

    lpwfxEnum = (LPWAVEFORMATEX)QzTaskMemAlloc(dwSize);
    if (lpwfxEnum == NULL)
        return E_OUTOFMEMORY;
    ZeroMemory(lpwfxEnum, dwSize);
    if (lpwfxIn == NULL)
        lpwfxEnum->wFormatTag = m_wFormatTag;

    // Now enum the formats we can convert our input format into
    ZeroMemory(&afd, sizeof(afd));
    afd.cbStruct = sizeof(afd);
    afd.pwfx = lpwfxEnum;
    afd.cbwfx = dwSize;
    afd.dwFormatTag = (lpwfxIn == NULL) ? m_wFormatTag : WAVE_FORMAT_UNKNOWN;

    if (lpwfxIn) {
        if (lpwfxIn->wFormatTag != m_wSourceFormat) {
            // typical case
            
            // ensure we don't copy more than the buffer size, in the case of a bogus cbSize.
            // note that the format we pass to acmFormatEnum assumes this, too.
            CopyMemory(lpwfxEnum, lpwfxIn, min( sizeof(WAVEFORMATEX) + lpwfxIn->cbSize, dwSize ) );
        } else {
            ASSERT(lpwfxMapped != NULL);
            ASSERT(lpwfxMapped->wFormatTag == m_wTargetFormat);

            // ensure we don't copy more than the buffer size, in the case of a bogus cbSize
            CopyMemory(lpwfxEnum, lpwfxMapped, min( sizeof(WAVEFORMATEX) + lpwfxMapped->cbSize, dwSize ) );
        }
    }

    if (lpwfxIn == NULL) {
        mmr = acmFormatEnum(NULL, &afd, (ACMFORMATENUMCB)FormatEnumCallback,
            (DWORD_PTR)this, ACM_FORMATENUMF_WFORMATTAG);
    } else {
        mmr = acmFormatEnum(NULL, &afd, (ACMFORMATENUMCB)FormatEnumCallback,
            (DWORD_PTR)this, ACM_FORMATENUMF_CONVERT);
    }

    if (mmr != 0) {
        DbgLog((LOG_ERROR, 1, TEXT("*acmFormatEnum FAILED! %d"), mmr));
        QzTaskMemFree(lpwfxEnum);
        return E_FAIL;
    }

    QzTaskMemFree(lpwfxEnum);
    return NOERROR;
}


//*****************************************************************************
//
// GetMediaType()
//
//
// Return our preferred output media types (in order)
// remember that we do not need to support all of these formats -
// if one is considered potentially suitable, our CheckTransform method
// will be called to check if it is acceptable right now.
// Remember that the enumerator calling this will stop enumeration as soon as
// it receives a S_FALSE return.

HRESULT CACMWrapper::GetMediaType(int iPosition, CMediaType *pmt)
{
#if 0   // NetShow needs to see possible outputs before connecting input
    // output types depend on input types... no input yet?
    // This is pointless!  We'll never get here if we're not connected
    if (!m_pInput->CurrentMediaType().IsValid())
        return VFW_E_NOT_CONNECTED;
#endif

    DbgLog((LOG_TRACE, 3, TEXT("CACMWrapper::GetMediaType %d"), iPosition));

    // Somebody called SetFormat().  Offer this first, instead of the
    // preferred format that normally heads our list
    if (m_lpwfxOutput && iPosition == 0) {
        return CreateAudioMediaType(m_lpwfxOutput, pmt, TRUE);
    }

    // figure out what we offer
    InitMediaTypes();

    if (m_cArray <= iPosition) {
        DbgLog((LOG_TRACE, 3, TEXT("No more formats")));
        return VFW_S_NO_MORE_ITEMS;
    }

    //DisplayType("*** Offering:",  pmt);
    LPWAVEFORMATEX lpwfx = m_lpwfxArray[iPosition];
    DbgLog((LOG_TRACE,3,TEXT("*** ACM giving tag:%d ch:%d freq:%d bits:%d"),
        lpwfx->wFormatTag, lpwfx->nChannels,
        lpwfx->nSamplesPerSec, lpwfx->wBitsPerSample));

    // Here it is!
    return CreateAudioMediaType(m_lpwfxArray[iPosition], pmt, TRUE);
}


//*****************************************************************************
//
// CheckTransform()
//
//

HRESULT CACMWrapper::CheckTransform(const CMediaType* pmtIn,
                                    const CMediaType* pmtOut)
{
    MMRESULT     mmr;
    WAVEFORMATEX *pwfxIn, *pwfxOut, *pwfxMapped;

    DbgLog((LOG_TRACE, 3, TEXT("CACMWrapper::CheckTransform")));

    //DisplayType("pmtIn:",  pmtIn);
    //DisplayType("pmtOut:", pmtOut);


    //---------------------  Do some format verification  -----------------------

    // we can't convert between toplevel types.
    if (*pmtIn->Type() != *pmtOut->Type()) {
        DbgLog((LOG_TRACE,3,TEXT("  pmtIn->Type != pmtOut->Type!")));
        return E_INVALIDARG;
    }

    // and we only accept audio
    if (*pmtIn->Type() != MEDIATYPE_Audio) {
        DbgLog((LOG_TRACE,3,TEXT("  pmtIn->Type != MEDIATYPE_Audio!")));
        return E_INVALIDARG;
    }

    // check this is a waveformatex
    if (*pmtOut->FormatType() != FORMAT_WaveFormatEx) {
        DbgLog((LOG_TRACE,3,TEXT("  pmtOut->FormatType != FORMAT_WaveFormatEx!")));
        return E_INVALIDARG;
    }

    // we only transform into formats with a specific tag
    if (((LPWAVEFORMATEX)(pmtOut->Format()))->wFormatTag != m_wFormatTag) {
        DbgLog((LOG_TRACE,3,TEXT("  Wrong FormatTag! %d not %d"),
            ((LPWAVEFORMATEX)(pmtOut->Format()))->wFormatTag, m_wFormatTag));
        return E_INVALIDARG;
    }

    //---------------------  See if ACM can do conversion  -----------------------

    pwfxIn  = (WAVEFORMATEX *)pmtIn->Format();
    pwfxOut = (WAVEFORMATEX *)pmtOut->Format();

    if(pwfxIn->wFormatTag != m_wSourceFormat)
    {
        // the usual case
        mmr = CallacmStreamOpen(NULL,
            NULL,
            pwfxIn,
            pwfxOut,
            NULL,
            NULL,
            NULL,
            ACM_STREAMOPENF_QUERY | ACM_STREAMOPENF_NONREALTIME);

    }
    else
    {
        DbgLog((LOG_TRACE, 1, TEXT("*** CheckTransform: remapping input format %u to %u"), m_wSourceFormat, m_wTargetFormat));

        pwfxMapped = (LPWAVEFORMATEX)_alloca(sizeof(WAVEFORMATEX) + pwfxIn->cbSize);
        CopyMemory(pwfxMapped, pwfxIn, sizeof(WAVEFORMATEX) + pwfxIn->cbSize);
        pwfxMapped->wFormatTag = m_wTargetFormat;  // remap tags

        mmr = CallacmStreamOpen(NULL,
            NULL,
            pwfxMapped,
            pwfxOut,
            NULL,
            NULL,
            NULL,
            ACM_STREAMOPENF_QUERY | ACM_STREAMOPENF_NONREALTIME);
    }

    if( mmr == 0 )
    {
        DbgLog((LOG_TRACE, 5, TEXT("  acmStreamOpen succeeded")));
        return NOERROR;
    }
    else
    {
        DbgLog((LOG_ERROR, 1, TEXT("  acmStreamOpen failed, mmr = %u"),mmr));
    }


    return E_INVALIDARG;
}


//*****************************************************************************
//
// DecideBufferSize()
//
//  There is a design flaw in the Transform filter when it comes
//  to decompression, the Transform override doesn't allow a single
//  input buffer to map to multiple output buffers. This flaw exposes
//  a second flaw in DecideBufferSize, in order to determine the
//  output buffer size I need to know the input buffer size and
//  the compression ratio. Well, I don't have access to the input
//  buffer size and, more importantly, don't have a way to limit the
                                    //  input buffer size. For example, our new TrueSpeech(TM) codec has
//  a ratio of 12:1 compression and we get input buffers of 12K
//  resulting in an output buffer size of >144K.
//
//  To get around this flaw I overrode the Receive member and
//  made it capable of mapping a single input buffer to multiple
//  output buffers. This allows DecideBufferSize to choose a size
//  that it deems appropriate, in this case 1/4 second.
//


HRESULT CACMWrapper::DecideBufferSize( IMemAllocator * pAllocator,
                                      ALLOCATOR_PROPERTIES *pProperties )
{
    DbgLog((LOG_TRACE, 2, TEXT("CACMWrapper::DecideBufferSize")));

    WAVEFORMATEX *pwfxOut = (WAVEFORMATEX *) m_pOutput->CurrentMediaType().Format();
    WAVEFORMATEX *pwfxIn  = (WAVEFORMATEX *) m_pInput->CurrentMediaType().Format();

    if (pProperties->cBuffers < 1)
        pProperties->cBuffers = 1;
    if (pProperties->cbBuffer < (LONG)pwfxOut->nAvgBytesPerSec / 4)
        pProperties->cbBuffer = pwfxOut->nAvgBytesPerSec / 4;
    if (pProperties->cbBuffer < (LONG)m_pOutput->CurrentMediaType().GetSampleSize())
        pProperties->cbBuffer = (LONG)m_pOutput->CurrentMediaType().GetSampleSize();
    if (pProperties->cbAlign < 1)
        pProperties->cbAlign = 1;
    // pProperties->cbPrefix = 0;

    DWORD cbStream;
    MMRESULT mmr;
    HACMSTREAM hacmStreamTmp;

    mmr = CallacmStreamOpen( &hacmStreamTmp
        , NULL
        , pwfxIn
        , pwfxOut
        , NULL
        , NULL
        , NULL
        , ACM_STREAMOPENF_NONREALTIME );
    if( mmr == 0 )
    {
        // Check with the decoder that this output buffer is big enough for at least a single
        // input data block.
        // Encoders like wma may use a large block align that will produce more than 1/4 second
        // of data
        mmr = acmStreamSize( hacmStreamTmp
            , pwfxIn->nBlockAlign
            , &cbStream
            , ACM_STREAMSIZEF_SOURCE );
        if( mmr == 0 && cbStream > (DWORD)pProperties->cbBuffer )
        {
            DbgLog( (LOG_TRACE
                , 2
                , TEXT("!Need a larger buffer size in CACMWrapper::DecideBufferSize cbStream needed = %d")
                , cbStream) );
            // just guard against ridiculously big buffers now that we allow for anything acm says (say 8 seconds?)
            if( pProperties->cbBuffer < (LONG)pwfxOut->nAvgBytesPerSec * 8 )
                pProperties->cbBuffer = cbStream;
#ifdef DEBUG
            else
                DbgLog( (LOG_TRACE
                , 1
                , TEXT("Error! CACMWrapper::DecideBufferSize cbStream exceeds limit, possibly bogus so ignoring...")
                , cbStream) );
#endif
        }
        acmStreamClose( hacmStreamTmp, 0 );
    }

    ALLOCATOR_PROPERTIES Actual;
    HRESULT hr = pAllocator->SetProperties(pProperties,&Actual);

    if( FAILED(hr) )
    {
        DbgLog((LOG_ERROR,1,TEXT("Allocator doesn't like properties")));
        return hr;
    }
    if( Actual.cbBuffer < pProperties->cbBuffer )
    {
        // can't use this allocator
        DbgLog((LOG_ERROR,1,TEXT("Allocator buffers too small")));
        DbgLog((LOG_ERROR,1,TEXT("Got %d, need %d"), Actual.cbBuffer,
            m_pOutput->CurrentMediaType().GetSampleSize()));
        return E_INVALIDARG;
    }

    return S_OK;
}


//*****************************************************************************
//
// StartStreaming()
//
//

HRESULT CACMWrapper::StartStreaming()
{
    MMRESULT     mmr;
    WAVEFORMATEX *pwfxIn, *pwfxOut, *pwfxMapped;
    CAutoLock    lock(&m_csFilter);


    DbgLog((LOG_TRACE, 2, TEXT("CACMWrapper::StartStreaming")));


    pwfxIn  = (WAVEFORMATEX *)m_pInput->CurrentMediaType().Format();
    pwfxOut = (WAVEFORMATEX *)m_pOutput->CurrentMediaType().Format();

    if(pwfxIn->wFormatTag != m_wSourceFormat)
    {

        mmr = CallacmStreamOpen(&m_hacmStream,
            NULL,
            pwfxIn,
            pwfxOut,
            NULL,
            NULL,
            NULL,
            // this is what VFW did
            ACM_STREAMOPENF_NONREALTIME);
    }
    else
    {
        DbgLog((LOG_TRACE, 1, TEXT("*** StartStreaming: remapping input format %u to %u"), m_wSourceFormat, m_wTargetFormat));

        pwfxMapped = (LPWAVEFORMATEX)_alloca(sizeof(WAVEFORMATEX) + pwfxIn->cbSize);
        CopyMemory(pwfxMapped, pwfxIn, sizeof(WAVEFORMATEX) + pwfxIn->cbSize);
        pwfxMapped->wFormatTag = m_wTargetFormat;  // remap tags

        mmr = CallacmStreamOpen(&m_hacmStream,
            NULL,
            pwfxMapped,
            pwfxOut,
            NULL,
            NULL,
            NULL,
            // this is what VFW did
            ACM_STREAMOPENF_NONREALTIME);
    }

    if( mmr == 0 )
    {
        m_bStreaming = TRUE;
        DbgLog((LOG_TRACE, 5, TEXT("  acmStreamOpen succeeded")));

        // If our input samples are not time stamped, make some time stamps up by
        // using the number they would be based on the stream's avg bytes per sec
        // This won't account for discontinuities, etc, but it's better than
        // nothing
        m_tStartFake = 0;

        // also, at this time, save the "average bytes per sec" that we play
        // out of the output pin. This will be used to adjust the time
        // stamps of samples.
        m_nAvgBytesPerSec = pwfxOut->nAvgBytesPerSec ;
        DbgLog((LOG_TRACE,2,TEXT("Output nAvgBytesPerSec =  %lu"), m_nAvgBytesPerSec));

        return NOERROR;
    }
    else
    {
        DbgLog((LOG_ERROR, 1, TEXT("  acmStreamOpen failed, mmr = %u"),mmr));
    }

    return E_INVALIDARG;
}


HRESULT CACMWrapper::EndFlush()
{
    CAutoLock lock(&m_csFilter);

    // forget any pending conversion - wait till EndFlush because otherwise
    // we could be in the middle of a Receive
    CAutoLock lock2(&m_csReceive);// OK, call me paranoid
    if (m_lpExtra) {
        QzTaskMemFree(m_lpExtra);
        m_cbExtra = 0;
        m_lpExtra = NULL;
    }

    return CTransformFilter::EndFlush();
}


//*****************************************************************************
//
// StopStreaming()
//
//

HRESULT CACMWrapper::StopStreaming()
{
    HRESULT    mmr;
    CAutoLock lock(&m_csFilter);


    DbgLog((LOG_TRACE, 2, TEXT("CACMWrapper::StopStreaming")));

    if( m_bStreaming )
    {
        mmr = acmStreamClose( m_hacmStream, 0 );
        if( mmr != 0 )
        {
            DbgLog((LOG_ERROR, 1, TEXT("  acmStreamClose failed!")));
        }

        m_hacmStream = NULL;
        m_bStreaming = FALSE;
    }
    else
    {
        DbgLog((LOG_ERROR, 1, TEXT("*** StopStreaming called when not streaming!")));
    }

    // forget any pending conversion
    CAutoLock lock2(&m_csReceive);// we'll blow up if Receive is using it
    if (m_lpExtra) {
        QzTaskMemFree(m_lpExtra);
        m_cbExtra = 0;
        m_lpExtra = NULL;
    }

    return NOERROR;
}


HRESULT CACMWrapper::Transform( IMediaSample *pIn, IMediaSample *pOut )
{
    DbgLog((LOG_ERROR, 1, TEXT("*** CACMWrapper->Transform() called!")));
    return S_FALSE;   // ???
}


HRESULT CACMWrapper::ProcessSample(BYTE *pbSrc, LONG cbSample,
                                   IMediaSample *pOut, LONG *pcbUsed,
                                   LONG *pcbDstUsed, BOOL fBlockAlign)
{
    HRESULT   hr;
    BYTE      *pbDst;
    LONG      cbDestBuffer, cbStream;

    // Don't take the filter lock in Receive, you FOOL!!
    // CAutoLock lock(&m_csFilter);


    DbgLog((LOG_TRACE, 5, TEXT("CACMWrapper::ProcessSample")));

    *pcbUsed = 0;
    *pcbDstUsed = 0;

    hr = pOut->GetPointer(&pbDst);
    if( !FAILED(hr) )
    {
        MMRESULT        mmr;
        ACMSTREAMHEADER acmSH;

        DbgLog((LOG_TRACE, 9, TEXT("  pOut->GetPointer succeeded")));

        hr = S_FALSE;

        cbDestBuffer = pOut->GetSize();

        mmr = acmStreamSize( m_hacmStream, (DWORD)cbDestBuffer,
            (DWORD *)&cbStream, ACM_STREAMSIZEF_DESTINATION );
        if( mmr == 0 )
        {
            DbgLog((LOG_TRACE, 9, TEXT("  cbStream = %d"),cbStream));


            memset(&acmSH,0,sizeof(acmSH));

            acmSH.cbStruct    = sizeof(acmSH);

            acmSH.pbSrc       = pbSrc;

            // !!! trick PrepareHeader into succeeding... it will fail if
            // we tell it how many bytes we're actually converting (cbSample)
            // if it's smaller than what's necessary to make a destination block
            // size
            int cbHack = min(cbStream, cbSample);
            int cbAlign = ((LPWAVEFORMATEX)m_pOutput->CurrentMediaType().Format())
                ->nBlockAlign;
            int cbSrcAlign;
            mmr = acmStreamSize(m_hacmStream, (DWORD)cbAlign,
                (DWORD *)&cbSrcAlign, ACM_STREAMSIZEF_DESTINATION);
            if (mmr == 0 && cbHack < cbSrcAlign) {
                cbHack = cbSrcAlign;
                DbgLog((LOG_TRACE,4,TEXT("Hacking PrepareHeader size to %d"),
                    cbHack));
            }
            acmSH.cbSrcLength = cbHack;

            acmSH.pbDst       = pbDst;
            acmSH.cbDstLength = (DWORD)cbDestBuffer;

            DbgLog((LOG_TRACE, 6, TEXT("  Calling acmStreamPrepareHeader")));
            DbgLog((LOG_TRACE, 6, TEXT("    pbSrc       = 0x%.8X"), acmSH.pbSrc));
            DbgLog((LOG_TRACE, 6, TEXT("    cbSrcLength = %u"),     acmSH.cbSrcLength));
            DbgLog((LOG_TRACE, 6, TEXT("    pbDst       = 0x%.8X"), acmSH.pbDst));
            DbgLog((LOG_TRACE, 6, TEXT("    cbDstLength = %u"),     acmSH.cbDstLength));

            mmr = acmStreamPrepareHeader( m_hacmStream, &acmSH, 0 );

            // now set the source length to the proper conversion size to be done
            acmSH.cbSrcLength = min(cbStream, cbSample);

            if( mmr == 0 )
            {
                DbgLog((LOG_TRACE, 5, TEXT("  Calling acmStreamConvert")));

                mmr = acmStreamConvert(m_hacmStream, &acmSH,
                    fBlockAlign? ACM_STREAMCONVERTF_BLOCKALIGN : 0);

                // now put it back to what it was for Prepare so Unprepare works
                acmSH.cbSrcLength = cbHack;

                if( mmr == 0 )
                {
                    DbgLog((LOG_TRACE, 6, TEXT("  acmStreamConvert succeeded")));
                    DbgLog((LOG_TRACE, 6, TEXT("    cbSrcLength     = %u"),acmSH.cbSrcLength));
                    DbgLog((LOG_TRACE, 6, TEXT("    cbSrcLengthUsed = %u"),acmSH.cbSrcLengthUsed));
                    DbgLog((LOG_TRACE, 6, TEXT("    cbDstLength     = %u"),acmSH.cbDstLength));
                    DbgLog((LOG_TRACE, 6, TEXT("    cbDstLengthUsed = %u"),acmSH.cbDstLengthUsed));

                    hr = NOERROR;

                    *pcbUsed = acmSH.cbSrcLengthUsed;
                    *pcbDstUsed = acmSH.cbDstLengthUsed;

                    pOut->SetActualDataLength( acmSH.cbDstLengthUsed );
                }
                else
                {
                    DbgLog((LOG_ERROR, 1, TEXT("  acmStreamConvert failed, mmr = %u"),mmr));
                }

                // acmStreamUnprepareHeader()'s documentation states "An application must
                // specify the source and destination buffer lengths (cbSrcLength and
                // cbDstLength, respectively) that were used during a call to the
                // corresponding acmStreamPrepareHeader. Failing to reset these member
                // values will cause acmStreamUnprepareHeader to fail with an
                // MMSYSERR_INVALPARAM error." (MSDN July 2000).  This code ensures that
                // cbDstLength contains the same value used to call acmStreamPrepareHeader().
                DbgLog((LOG_TRACE, 9, TEXT("  setting cbDstLength ")));
                acmSH.cbDstLength = cbDestBuffer;

                DbgLog((LOG_TRACE, 9, TEXT("  calling acmStreamUnprepareHeader")));
                mmr = acmStreamUnprepareHeader( m_hacmStream, &acmSH, 0 );
                if( mmr != 0 )
                {
                    DbgLog((LOG_ERROR, 1, TEXT("  acmStreamUnprepareHeader failed, mmr = %u"),mmr));
                }
            }
            else
            {
                DbgLog((LOG_TRACE,4,TEXT("  acmStreamPrepareHeader failed, mmr = %u"),mmr));
            }
        }
        else
        {
            DbgLog((LOG_ERROR, 1, TEXT("  acmStreamSize failed, mmr = %u"),mmr));
        }
    }
    else
    {
        DbgLog((LOG_ERROR, 1, TEXT("*** pOut->GetPointer() failed")));
    }

    DbgLog((LOG_TRACE, 9, TEXT("  returning hr = %u"),hr));

    return hr;
}


//*****************************************************************************
//
// Receive()
//
//
//

HRESULT CACMWrapper::Receive( IMediaSample *pInSample )
{
    HRESULT      hr = NOERROR;
    CRefTime     tStart, tStop, tIntStop;
    IMediaSample *pOutSample;

    CAutoLock lock(&m_csReceive);

    BYTE *pbSample;
    LONG  cbSampleLength, cbUsed, cbDstUsed;

    AM_MEDIA_TYPE *pmt;
    pInSample->GetMediaType(&pmt);
    if (pmt != NULL && pmt->pbFormat != NULL)
    {
        // spew some debug output
        ASSERT(!IsEqualGUID(pmt->majortype, GUID_NULL));
#ifdef DEBUG
        WAVEFORMATEX *pwfx = (WAVEFORMATEX *) pmt->pbFormat;
        DbgLog((LOG_TRACE,1,TEXT("*Changing input type on the fly to %d channel %d bit %dHz"),
            pwfx->nChannels, pwfx->wBitsPerSample, pwfx->nSamplesPerSec));
#endif

        // now switch to using the new format.  I am assuming that the
        // derived filter will do the right thing when its media type is
        // switched and streaming is restarted.

        StopStreaming();
        m_pInput->CurrentMediaType() = *pmt;
        DeleteMediaType(pmt);
        // not much we can do if this fails
        hr = StartStreaming();
    }

    cbSampleLength = pInSample->GetActualDataLength();

    DbgLog((LOG_TRACE, 4, TEXT("Received %d samples"), cbSampleLength));

    // this is a discontinuity.  we better send any extra stuff that was pending
    // separately from the new stuff we got
    if (pInSample->IsDiscontinuity() == S_OK) {
        DbgLog((LOG_TRACE,4,TEXT("Discontinuity - Sending extra bytes NOW")));
        SendExtraStuff();
        // !!! if this fails, throw it away, or leave it prepended?
    }

    // get input start and stop times, or fake them up

    int nAvgBytes = ((WAVEFORMATEX *)m_pInput->CurrentMediaType().Format())
        ->nAvgBytesPerSec;
    hr = pInSample->GetTime((REFERENCE_TIME *)&tStart, (REFERENCE_TIME *)&tStop);
    if (FAILED(hr)) {
        // If we have no time stamps, make some up using a best guess
        tStart = m_tStartFake;
        tStop = tStart + (cbSampleLength * UNITS) / nAvgBytes;
        DbgLog((LOG_TRACE,5,TEXT("No time stamps... faking them")));
    }
    // the next fake number will be this...
    m_tStartFake = tStop;

    pInSample->GetPointer( &pbSample );

    DbgLog((LOG_TRACE, 5, TEXT("Total Sample: Start = %s End = %s"),
        (LPCTSTR)CDisp((LONGLONG)(tStart),CDISP_HEX),
        (LPCTSTR)CDisp((LONGLONG)(tStop),CDISP_HEX)));

    // We have extra stuff left over from the last Receive.  We need to do
    // that first, and then get on with the new stuff
    if (m_cbExtra) {
        DbgLog((LOG_TRACE,4,TEXT("Still %d bytes left from last time"),
            m_cbExtra));
        m_cbExtra += cbSampleLength;
        LPBYTE lpSave = m_lpExtra;
        m_lpExtra = (LPBYTE)QzTaskMemAlloc(m_cbExtra);
        if (m_lpExtra == NULL) {
            DbgLog((LOG_ERROR,1,TEXT("Extra bytes - Out of memory!")));
            m_cbExtra = 0;
            return E_OUTOFMEMORY;
        }
        CopyMemory(m_lpExtra, lpSave, m_cbExtra - cbSampleLength);
        QzTaskMemFree(lpSave);
        CopyMemory(m_lpExtra + m_cbExtra - cbSampleLength, pbSample,
            cbSampleLength);
        pbSample = m_lpExtra;
        cbSampleLength = m_cbExtra;

        // the time stamp we got above is for the beginning of the new data.
        // we need to go back to the time of the extra bits we're doing first
        tStart -= m_rtExtra;
    }

    cbDstUsed = 10000;    // don't quit yet
    while(cbSampleLength > 0 && cbDstUsed > 0)
    {
        hr = m_pOutput->GetDeliveryBuffer( &pOutSample, NULL, NULL, 0 );
        if( FAILED(hr) )
        {
            DbgLog((LOG_ERROR, 1, TEXT("GetDeliveryBuffer(pOutSample) failed, hr = %x"),hr));
            return hr;
        }

        pOutSample->SetSyncPoint( pInSample->IsSyncPoint() == S_OK );
        pOutSample->SetDiscontinuity( pInSample->IsDiscontinuity() == S_OK );

        MSR_START(m_idTransform);


        //
        //    // have the derived class transform the data
        //    hr = Transform( pSample, pOutSample );
        //

        hr = ProcessSample(pbSample, cbSampleLength, pOutSample, &cbUsed, &cbDstUsed
            ,TRUE);

        //  MPEG can consume data without outputting any
        //ASSERT(cbDstUsed > 0 || cbUsed == 0);

        if( cbUsed <= cbSampleLength )
        {
            cbSampleLength -= cbUsed;
            pbSample       += cbUsed;
            DbgLog((LOG_TRACE,4,TEXT("turned %d bytes into %d:  %d left"), cbUsed,
                cbDstUsed, cbSampleLength));
        }
        else
        {
            DbgLog((LOG_ERROR,1,TEXT("*** cbUsed > cbSampleLength!")));
            cbSampleLength = 0;
        }

        // Hmm... ACM didn't convert anything (it doesn't have enough data)
        // That's bad.  Let's remember the rest for next time and do that first.
        //  (If there is no next time, then they weren't important).
        if (cbDstUsed == 0 && cbSampleLength != 0) {
            DbgLog((LOG_TRACE,4,TEXT("We will have %d bytes left"),cbSampleLength));
            // remember, pbSample may point somewhere in m_lpExtra's buffer!
            if (m_lpExtra) {
                CopyMemory(m_lpExtra, pbSample, cbSampleLength);
            } else {
                m_lpExtra = (LPBYTE)QzTaskMemAlloc(cbSampleLength);
                if (m_lpExtra)
                    CopyMemory(m_lpExtra, pbSample, cbSampleLength);
            }
            if (m_lpExtra) {
                m_cbExtra = cbSampleLength;
                // when we finally do this left over stuff, this is how much
                // earlier stuff there is to do
                m_rtExtra = tStop - tStart;
            } else {
                DbgLog((LOG_ERROR,1,TEXT("Extra memory - Out of memory!")));
                m_cbExtra = 0;
                hr = E_OUTOFMEMORY;
            }
        }

        // we used up everything, and there is nothing left over for next time
        if (hr == NOERROR && 0 == cbSampleLength) {
            DbgLog((LOG_TRACE,4,TEXT("We used up everything we had!")));
            m_cbExtra = 0;
            QzTaskMemFree(m_lpExtra);
            m_lpExtra = NULL;
        }


        // adjust the start and stop times based on the amount of data used up.
        LONGLONG tDelta = (cbDstUsed * UNITS) / m_nAvgBytesPerSec ;
        tIntStop = tStart + tDelta ;

        pOutSample->SetTime( (REFERENCE_TIME *) &tStart,
            (REFERENCE_TIME *) &tIntStop );

        DbgLog((LOG_TRACE, 5, TEXT("  Breaking up: Start = %s End = %s"),
            (LPCTSTR)CDisp((LONGLONG)(tStart),CDISP_HEX),
            (LPCTSTR)CDisp((LONGLONG)(tIntStop),CDISP_HEX)));

        tStart += tDelta ;


        // Stop the clock and log it (if PERF is defined)
        MSR_STOP(m_idTransform);

        if(FAILED(hr))
        {
            DbgLog((LOG_ERROR,1,TEXT("Error from transform")));
            pOutSample->Release();
            return hr;
        }


        // the Transform() function can return S_FALSE to indicate that the
        // sample should not be delivered; we only deliver the sample if it's
        // really S_OK (same as NOERROR, of course.)

        // pretend nothing went wrong, but dont' deliver it, just GET OUT
        // OF HERE!
        if (hr == S_FALSE)
        {
            pOutSample->Release();
            hr = NOERROR;
            break;
        }

        // don't deliver empty samples
        if (hr == NOERROR && cbDstUsed)
        {
            DbgLog((LOG_TRACE,4,TEXT("Delivering...")));
            hr = m_pOutput->Deliver(pOutSample);
            if (hr != S_OK) {
                pOutSample->Release();
                break;
            }
        }

        // release the output buffer. If the connected pin still needs it,
        // it will have addrefed it itself.
        pOutSample->Release();

   }

   //tIntStop at this point should be same as tStop ??
   DbgLog((LOG_TRACE, 5, TEXT("  tStop = %s tIntStop = %s"),
       (LPCTSTR)CDisp((LONGLONG)(tStop),CDISP_HEX),
       (LPCTSTR)CDisp((LONGLONG)(tIntStop),CDISP_HEX)));


   return hr;
}


// send our leftover data
//
HRESULT CACMWrapper::SendExtraStuff()
{
    int cbAlign, cbSrcAlign;

    // nothing extra to send
    if (m_cbExtra == 0)
        return NOERROR;

    // wait till receive finishes processing what it has
    CAutoLock lock(&m_csReceive);
    DbgLog((LOG_TRACE,2,TEXT("Processing remaining %d bytes"), m_cbExtra));

    IMediaSample *pOutSample;
    CRefTime tStart, tStop;
    HRESULT hr = m_pOutput->GetDeliveryBuffer(&pOutSample, NULL, NULL, 0);
    if (FAILED(hr)) {
        DbgLog((LOG_ERROR,1,TEXT("GetBuffer failed: can't deliver last bits")));
        return hr;
    }
    pOutSample->SetSyncPoint(TRUE);             // !!!
    pOutSample->SetDiscontinuity(FALSE);

    // !!! ProcessSample is going to have to lie about the size of the input
    // to work around an ACM bug, so we may have to grow the size of
    // our input to be as big as we are going to lie and say it is
    cbAlign = ((LPWAVEFORMATEX)m_pOutput->CurrentMediaType().Format())
        ->nBlockAlign;
    MMRESULT mmr = acmStreamSize(m_hacmStream, (DWORD)cbAlign,
        (DWORD *)&cbSrcAlign, ACM_STREAMSIZEF_DESTINATION);
    if (mmr == 0 && m_cbExtra < cbSrcAlign) {
        DbgLog((LOG_TRACE,4,TEXT("Growing m_lpExtra to lie to ACM")));
        LPBYTE lpExtra = (LPBYTE)QzTaskMemRealloc(m_lpExtra, cbSrcAlign);
        // don't update m_cbExtra... that's the real amount of data
        if (lpExtra == NULL) {
            DbgLog((LOG_ERROR,1,TEXT("Out of memory growing m_lpExtra")));
            pOutSample->Release();
            return E_OUTOFMEMORY;
        }
        m_lpExtra = lpExtra;
    }

    LONG cbUsed, cbDstUsed;
    // Do NOT block align the last bits... there isn't enough
    hr = ProcessSample(m_lpExtra, m_cbExtra, pOutSample, &cbUsed, &cbDstUsed,
        FALSE);

    // !!! nothing we can do if it anything's left over?
    DbgLog((LOG_TRACE,4,TEXT("turned %d bytes into %d:  %d left"), cbUsed,
        cbDstUsed, m_cbExtra - cbUsed));

    // well, no more extra stuff
    m_cbExtra = 0;
    QzTaskMemFree(m_lpExtra);
    m_lpExtra = NULL;

    if (cbDstUsed == 0) {
        DbgLog((LOG_ERROR,1,TEXT("can't convert last bits")));
        pOutSample->Release();
        return E_FAIL;
    }

    // set the start and stop times based on the amount of data used up.
    tStart = m_tStartFake - m_rtExtra;
    tStop = tStart + (cbDstUsed * UNITS) / m_nAvgBytesPerSec ;
    pOutSample->SetTime((REFERENCE_TIME *)&tStart, (REFERENCE_TIME *)&tStop);

    hr = m_pOutput->Deliver(pOutSample);
    pOutSample->Release();

    DbgLog((LOG_TRACE, 5, TEXT("Extra time stamps: tStart=%s tStop=%s"),
        (LPCTSTR)CDisp((LONGLONG)(tStart),CDISP_HEX),
        (LPCTSTR)CDisp((LONGLONG)(tStop),CDISP_HEX)));

    return NOERROR;
}


// overridden to send the leftover data
//
HRESULT CACMWrapper::EndOfStream()
{
    SendExtraStuff();
    return CTransformFilter::EndOfStream();
}


// overridden to complete our fancy reconnection footwork
//
HRESULT CACMWrapper::SetMediaType(PIN_DIRECTION direction,const CMediaType *pmt)
{
    HRESULT hr;

    // Set the OUTPUT type.
    if (direction == PINDIR_OUTPUT) {

        DbgLog((LOG_TRACE,2,TEXT("*Set OUTPUT type tag:%d %dbit %dchannel %dHz")
            ,((LPWAVEFORMATEX)(pmt->Format()))->wFormatTag,
            ((LPWAVEFORMATEX)(pmt->Format()))->wBitsPerSample,
            ((LPWAVEFORMATEX)(pmt->Format()))->nChannels,
            ((LPWAVEFORMATEX)(pmt->Format()))->nSamplesPerSec));

        // Uh oh.  As part of our fancy footwork we may be being asked to
        // provide a media type we cannot provide unless we reconnect our
        // input pin to provide a different type
        if (m_pInput && m_pInput->IsConnected()) {

            // If we can actually provide this type now, don't worry
            hr = CheckTransform(&m_pInput->CurrentMediaType(),
                &m_pOutput->CurrentMediaType());
            if (hr == NOERROR)
                return hr;

            DbgLog((LOG_TRACE,2,TEXT("*Set OUTPUT requires RECONNECT of INPUT!")));

            // Oh boy. Reconnect our input pin.  Cross your fingers.
            return m_pGraph->Reconnect(m_pInput);

        }

        return NOERROR;
    }

    // some invalid formats have non-zero cbSize with PCM, which makes me blow
    // up
    ASSERT(((LPWAVEFORMATEX)(pmt->Format()))->wFormatTag != WAVE_FORMAT_PCM ||
        ((LPWAVEFORMATEX)(pmt->Format()))->cbSize == 0);


    DbgLog((LOG_TRACE,2,TEXT("*Set INPUT type tag:%d %dbit %dchannel %dHz"),
        ((LPWAVEFORMATEX)(pmt->Format()))->wFormatTag,
        ((LPWAVEFORMATEX)(pmt->Format()))->wBitsPerSample,
        ((LPWAVEFORMATEX)(pmt->Format()))->nChannels,
        ((LPWAVEFORMATEX)(pmt->Format()))->nSamplesPerSec));

    // we have a new input type, we need to recalculate the types we can
    // provide
    while (m_cArray-- > 0)
        QzTaskMemFree(m_lpwfxArray[m_cArray]);
    m_cArray = 0;       // will be -1 if it started out at 0

    hr = CheckInputType(pmt);  // refresh acm codec mapper cache
    if(FAILED(hr))
        return hr;
    m_wSourceFormat = m_wCachedSourceFormat;
    m_wTargetFormat = m_wCachedTargetFormat;

    // If we accept an input type that requires changing our output type,
    // we need to do this, but only if necessary, or we'll infinite loop
#if 0
    ASSERT(direction == PINDIR_INPUT);

    // If we can actually do this right now, don't bother reconnecting
    hr = CheckTransform(&m_pInput->CurrentMediaType(),
        &m_pOutput->CurrentMediaType());
    if (hr == NOERROR)
        return hr;

    if (m_pOutput && m_pOutput->IsConnected()) {
        DbgLog((LOG_TRACE,2,TEXT("***Changing IN when OUT already connected")));
        return ((CACMOutputPin *)m_pOutput)->Reconnect();
    }
#endif

    // !!! TEST
#if 0
    int i, z;
    AM_MEDIA_TYPE *pmtx;
    AUDIO_STREAM_CONFIG_CAPS ascc;
    ((CACMOutputPin *)m_pOutput)->GetNumberOfCapabilities(&i);
    DbgLog((LOG_TRACE,1,TEXT("We support %d caps"), i));
    for (z=0; z<i; z++) {
        ((CACMOutputPin *)m_pOutput)->GetStreamCaps(z, &pmtx, &ascc);
        DbgLog((LOG_TRACE,1,TEXT("%d: %d"), z,
            ((LPWAVEFORMATEX)pmtx->pbFormat)->wFormatTag));
    }
    DeleteMediaType(pmtx);
#endif

    return NOERROR;
}


HRESULT CACMWrapper::BreakConnect(PIN_DIRECTION direction)
{
    // our possible output formats change if input is not connected
    if (direction == PINDIR_INPUT) {
        while (m_cArray-- > 0)
            QzTaskMemFree(m_lpwfxArray[m_cArray]);
        m_cArray = 0;   // will be -1 if it started out at 0
    }
    return CTransformFilter::BreakConnect(direction);
}


// override to have a special output pin
//
CBasePin * CACMWrapper::GetPin(int n)
{
    HRESULT hr = S_OK;

    DbgLog((LOG_TRACE,5,TEXT("CACMWrapper::GetPin")));

    // Check for valid input
    if (n != 0 && n != 1)
    {
        DbgLog((LOG_ERROR,1,TEXT("CACMWrapper::GetPin: Invalid input parameter")));
        return NULL;
    }

    // Create pins if necessary

    if (m_pInput == NULL) {

        DbgLog((LOG_TRACE,2,TEXT("Creating an input pin")));

        m_pInput = new CTransformInputPin(NAME("Transform input pin"),
            this,              // Owner filter
            &hr,               // Result code
            L"Input");         // Pin name


        if (FAILED(hr) || m_pInput == NULL) {
            return NULL;
        }

        // Create the output pin

        DbgLog((LOG_TRACE,2,TEXT("Creating an output pin")));

        m_pOutput = new CACMOutputPin(NAME("Transform output pin"),
            this,            // Owner filter
            &hr,             // Result code
            L"Output");      // Pin name

        if (FAILED(hr) || m_pOutput == NULL) {
            // delete the input pin
            delete m_pInput;
            m_pInput = NULL;
            return NULL;
        }
    }


    // Return the appropriate pin

    if (0 == n)
        return m_pInput;
    else if (1 == n)
        return m_pOutput;
    else
        return NULL;
}


// --- CACMOutputPin ----------------------------------------

/*
CACMOutputPin constructor
*/
CACMOutputPin::CACMOutputPin(
                             TCHAR              * pObjectName,
                             CACMWrapper        * pFilter,
                             HRESULT            * phr,
                             LPCWSTR              pPinName) :

CTransformOutputPin(pObjectName, pFilter, phr, pPinName),
m_pFilter(pFilter),
m_pPosition(NULL),
m_cFormatTags(0)
{
    DbgLog((LOG_TRACE,2,TEXT("*Instantiating the CACMOutputPin")));

    // !!! TESTING ONLY
#if 0
    CMediaType cmt;
    WAVEFORMATEX wfx;

    wfx.wFormatTag = WAVE_FORMAT_PCM;
    wfx.wBitsPerSample = 16;
    wfx.nChannels = 2;
    wfx.nSamplesPerSec = 44100;
    wfx.nBlockAlign = 4;
    wfx.nAvgBytesPerSec = 44100 * 2 * 2;
    wfx.cbSize = 0;

    cmt.SetType(&MEDIATYPE_Audio);
    cmt.SetSubtype(&GUID_NULL);
    cmt.SetFormatType(&FORMAT_WaveFormatEx);
    cmt.SetTemporalCompression(FALSE);
    cmt.SetSampleSize(4);

    cmt.AllocFormatBuffer(sizeof(wfx));
    CopyMemory(cmt.Format(), &wfx, sizeof(wfx));

    SetFormat(&cmt);
#endif
}

CACMOutputPin::~CACMOutputPin()
{
    DbgLog((LOG_TRACE,2,TEXT("*Destroying the CACMOutputPin")));
    if (m_pPosition)
        delete m_pPosition;
};


// overriden to expose IMediaPosition and IMediaSeeking control interfaces
// and all the capture interfaces we support
// !!! The base classes change all the time and I won't pick up their bug fixes!
STDMETHODIMP CACMOutputPin::NonDelegatingQueryInterface(REFIID riid, void **ppv)
{
    CheckPointer(ppv,E_POINTER);
    ValidateReadWritePtr(ppv,sizeof(PVOID));
    *ppv = NULL;

    DbgLog((LOG_TRACE,99,TEXT("QI on CACMOutputPin")));

    if (riid == IID_IAMStreamConfig) {
        return GetInterface((LPUNKNOWN)(IAMStreamConfig *)this, ppv);
    }

    if (riid == IID_IMediaPosition || riid == IID_IMediaSeeking) {
        if (m_pPosition == NULL) {
            HRESULT hr = S_OK;
            m_pPosition = new CACMPosPassThru(NAME("ACM PosPassThru"),
                GetOwner(),
                &hr,
                (IPin *)m_pFilter->m_pInput);
            if (m_pPosition == NULL) {
                return E_OUTOFMEMORY;
            }
            if (FAILED(hr)) {
                delete m_pPosition;
                m_pPosition = NULL;
                return hr;
            }
        }
        return m_pPosition->NonDelegatingQueryInterface(riid, ppv);
    } else {
        return CBaseOutputPin::NonDelegatingQueryInterface(riid, ppv);
    }
}


// Overridden to do fancy reconnecting footwork to allow a chain of 3 ACM
// filters to be found by the filtergraph.
//
HRESULT CACMOutputPin::CheckMediaType(const CMediaType *pmtOut)
{
    DWORD j;
    HRESULT hr;
    CMediaType *pmtEnum;
    BOOL fFound = FALSE;
    IEnumMediaTypes *pEnum;

    if (!m_pFilter->m_pInput->IsConnected()) {
        DbgLog((LOG_TRACE,3,TEXT("Input not connected")));
        return VFW_E_NOT_CONNECTED;
    }

    // There's no way we can do anything but audio
    if (*pmtOut->FormatType() != FORMAT_WaveFormatEx) {
        DbgLog((LOG_TRACE,3,TEXT("Format type not WaveFormatEx")));
        return VFW_E_INVALIDMEDIATYPE;
    }
    if ( pmtOut->majortype != MEDIATYPE_Audio) {
        DbgLog((LOG_TRACE,3,TEXT("Type not Audio")));
        return VFW_E_INVALIDMEDIATYPE;
    }
    if ( pmtOut->FormatLength() < sizeof(PCMWAVEFORMAT)) {
        DbgLog((LOG_TRACE,3,TEXT("Format length too small")));
        return VFW_E_INVALIDMEDIATYPE;
    }

    // Somebody called SetFormat, so don't accept anything that isn't that.
    if (m_pFilter->m_lpwfxOutput) {
        LPWAVEFORMATEX lpwfxTry = (LPWAVEFORMATEX)pmtOut->Format();
        if (m_pFilter->m_lpwfxOutput->cbSize != lpwfxTry->cbSize) {
            DbgLog((LOG_TRACE,3,TEXT("Only accepting one thing")));
            return VFW_E_INVALIDMEDIATYPE;
        }
        if (_fmemcmp(lpwfxTry, m_pFilter->m_lpwfxOutput, lpwfxTry->cbSize) != 0)
        {
            DbgLog((LOG_TRACE,3,TEXT("Only accepting one thing")));
            return VFW_E_INVALIDMEDIATYPE;
        }
    }

    // we only transform into formats with a specific tag - there's no sense
    // wasting time trying to see if reconnecting our input will help.  We know
    // right now we should fail.
    if (((LPWAVEFORMATEX)(pmtOut->Format()))->wFormatTag !=
        m_pFilter->m_wFormatTag) {
        DbgLog((LOG_TRACE,3,TEXT("  Wrong FormatTag! %d not %d"),
            ((LPWAVEFORMATEX)(pmtOut->Format()))->wFormatTag,
            m_pFilter->m_wFormatTag));
        return VFW_E_INVALIDMEDIATYPE;
    }

    // We can accept this output type like normal; nothing fancy required
    hr = m_pFilter->CheckTransform(&m_pFilter->m_pInput->CurrentMediaType(),
        pmtOut);
    if (hr == NOERROR)
        return hr;

    DbgLog((LOG_TRACE,3,TEXT("*We can't accept this output media type")));
    DbgLog((LOG_TRACE,3,TEXT(" tag:%d %dbit %dchannel %dHz"),
        ((LPWAVEFORMATEX)(pmtOut->Format()))->wFormatTag,
        ((LPWAVEFORMATEX)(pmtOut->Format()))->wBitsPerSample,
        ((LPWAVEFORMATEX)(pmtOut->Format()))->nChannels,
        ((LPWAVEFORMATEX)(pmtOut->Format()))->nSamplesPerSec));
    DbgLog((LOG_TRACE,3,TEXT(" But how about if we reconnected our input...")));
    DbgLog((LOG_TRACE,3,TEXT(" Current input: tag:%d %dbit %dchannel %dHz"),
        ((LPWAVEFORMATEX)m_pFilter->m_pInput->CurrentMediaType().Format())->wFormatTag,
        ((LPWAVEFORMATEX)m_pFilter->m_pInput->CurrentMediaType().Format())->wBitsPerSample,
        ((LPWAVEFORMATEX)m_pFilter->m_pInput->CurrentMediaType().Format())->nChannels,
        ((LPWAVEFORMATEX)m_pFilter->m_pInput->CurrentMediaType().Format())->nSamplesPerSec));

    // Now let's get fancy.  We could accept this type if we reconnected our
    // input pin... in other words if the guy our input pin is connected to
    // could provide a type that we could convert into the necessary type
    hr = m_pFilter->m_pInput->GetConnected()->EnumMediaTypes(&pEnum);
    if (hr != NOERROR)
        return E_FAIL;
    while (1) {
        hr = pEnum->Next(1, (AM_MEDIA_TYPE **)&pmtEnum, &j);

        // all out of enumerated types
        if (hr == S_FALSE || j == 0) {
            break;
        }

        // can we convert between these?
        hr = m_pFilter->CheckTransform(pmtEnum, pmtOut);

        if (hr != NOERROR) {
            DeleteMediaType(pmtEnum);
            continue;
        }

        // OK, it offers the type, and we like it, but will it accept it NOW?
        hr = m_pFilter->m_pInput->GetConnected()->QueryAccept(pmtEnum);
        // nope
        if (hr != NOERROR) {
            DeleteMediaType(pmtEnum);
            continue;
        }
        // OK, I'm satisfied
        fFound = TRUE;
        DbgLog((LOG_TRACE,2,TEXT("*We can only accept this output type if we reconnect")));
        DbgLog((LOG_TRACE,2,TEXT("our input to tag:%d %dbit %dchannel %dHz"),
            ((LPWAVEFORMATEX)(pmtEnum->pbFormat))->wFormatTag,
            ((LPWAVEFORMATEX)(pmtEnum->pbFormat))->wBitsPerSample,
            ((LPWAVEFORMATEX)(pmtEnum->pbFormat))->nChannels,
            ((LPWAVEFORMATEX)(pmtEnum->pbFormat))->nSamplesPerSec));
        // all done with this
        DeleteMediaType(pmtEnum);
        break;
    }
    pEnum->Release();

    if (!fFound)
        DbgLog((LOG_TRACE,3,TEXT("*NO! Reconnecting our input won't help")));

    return fFound ? NOERROR : VFW_E_INVALIDMEDIATYPE;
}

// overridden just so we can cleanup after the acm codec mapper
HRESULT CACMOutputPin::BreakConnect()
{
    m_pFilter->ACMCodecMapperClose();
    m_pFilter->m_wCachedSourceFormat = 0;
    m_pFilter->m_wCachedTargetFormat = 0;
    return CBaseOutputPin::BreakConnect();
}

// overridden to get media types even when the input is not connected
//
HRESULT CACMOutputPin::GetMediaType(int iPosition, CMediaType *pmt)
{
    CAutoLock cObjectLock(&m_pFilter->m_csFilter);
    ASSERT(m_pFilter->m_pInput != NULL);

    return m_pFilter->GetMediaType(iPosition, pmt);
}


////////////////////////////////
// IAMStreamConfig stuff      //
////////////////////////////////


HRESULT CACMOutputPin::SetFormat(AM_MEDIA_TYPE *pmt)
{
    HRESULT hr;
    LPWAVEFORMATEX lpwfx;
    DWORD dwSize;

    if (pmt == NULL)
        return E_POINTER;

    // To make sure we're not in the middle of start/stop streaming
    CAutoLock cObjectLock(&m_pFilter->m_csFilter);

    DbgLog((LOG_TRACE,2,TEXT("::SetFormat to tag:%d %dbit %dchannel %dHz"),
        ((LPWAVEFORMATEX)(pmt->pbFormat))->wFormatTag,
        ((LPWAVEFORMATEX)(pmt->pbFormat))->wBitsPerSample,
        ((LPWAVEFORMATEX)(pmt->pbFormat))->nChannels,
        ((LPWAVEFORMATEX)(pmt->pbFormat))->nSamplesPerSec));

    if (m_pFilter->m_State != State_Stopped)
        return VFW_E_NOT_STOPPED;

    // our possible output formats depend on our input format
    if (!m_pFilter->m_pInput->IsConnected())
        return VFW_E_NOT_CONNECTED;

    // We're already using this format
    if (IsConnected() && CurrentMediaType() == *pmt)
        return NOERROR;

    // see if we like this type
    if ((hr = CheckMediaType((CMediaType *)pmt)) != NOERROR) {
        DbgLog((LOG_TRACE,2,TEXT("IAMStreamConfig::SetFormat rejected")));
        return hr;
    }

    // If we are connected to somebody, make sure they like it
    if (IsConnected()) {
        hr = GetConnected()->QueryAccept(pmt);
        if (hr != NOERROR)
            return VFW_E_INVALIDMEDIATYPE;
    }

    // Now make a note that from now on, this is the only format allowed
    lpwfx = (LPWAVEFORMATEX)pmt->pbFormat;
    dwSize = lpwfx->cbSize + sizeof(WAVEFORMATEX);
    CoTaskMemFree(m_pFilter->m_lpwfxOutput);
    m_pFilter->m_lpwfxOutput = (LPWAVEFORMATEX)QzTaskMemAlloc(dwSize);
    if (NULL == m_pFilter->m_lpwfxOutput) {
        return E_OUTOFMEMORY;
    }
    m_pFilter->m_cbwfxOutput = dwSize;
    CopyMemory(m_pFilter->m_lpwfxOutput, pmt->pbFormat, dwSize);

    // Changing the format means reconnecting if necessary
    if (IsConnected())
        m_pFilter->m_pGraph->Reconnect(this);

    return NOERROR;
}


HRESULT CACMOutputPin::GetFormat(AM_MEDIA_TYPE **ppmt)
{
    DbgLog((LOG_TRACE,2,TEXT("IAMStreamConfig::GetFormat")));

    if (ppmt == NULL)
        return E_POINTER;

    // our possible output formats depend on our input format
    if (!m_pFilter->m_pInput->IsConnected())
        return VFW_E_NOT_CONNECTED;

    *ppmt = (AM_MEDIA_TYPE *)CoTaskMemAlloc(sizeof(AM_MEDIA_TYPE));
    if (*ppmt == NULL)
        return E_OUTOFMEMORY;
    ZeroMemory(*ppmt, sizeof(AM_MEDIA_TYPE));
    HRESULT hr = GetMediaType(0, (CMediaType *)*ppmt);
    if (hr != NOERROR) {
        CoTaskMemFree(*ppmt);
        *ppmt = NULL;
        return hr;
    }
    return NOERROR;
}


HRESULT CACMOutputPin::GetNumberOfCapabilities(int *piCount, int *piSize)
{
    if (piCount == NULL || piSize == NULL)
        return E_POINTER;

#if 0   // NetShow needs to see possible outputs before connecting input
    // output types depend on input types...
    if (!m_pFilter->m_pInput->CurrentMediaType().IsValid())
        return VFW_E_NOT_CONNECTED;
#endif

    // make the list of the media types we support
    m_pFilter->InitMediaTypes();

    *piCount = m_pFilter->m_cArray;
    *piSize = sizeof(AUDIO_STREAM_CONFIG_CAPS);

    return NOERROR;
}


HRESULT CACMOutputPin::GetStreamCaps(int i, AM_MEDIA_TYPE **ppmt, LPBYTE pSCC)
{
    AUDIO_STREAM_CONFIG_CAPS *pASCC = (AUDIO_STREAM_CONFIG_CAPS *)pSCC;

    DbgLog((LOG_TRACE,2,TEXT("IAMStreamConfig::GetStreamCaps")));

    // make sure this is current
    m_pFilter->InitMediaTypes();

    if (i < 0)
        return E_INVALIDARG;
    if (i >= m_pFilter->m_cArray)
        return S_FALSE;
    if (pSCC == NULL || ppmt == NULL)
        return E_POINTER;

#if 0   // NetShow needs to see possible outputs before connecting input
    // our possible output formats depend on our input format
    if (!m_pFilter->m_pInput->IsConnected())
        return VFW_E_NOT_CONNECTED;
#endif

    // I don't know how to modify the waveformats I get from ACM to produce
    // other acceptable types.  All I can give them is what ACM gives me.
    ZeroMemory(pASCC, sizeof(AUDIO_STREAM_CONFIG_CAPS));
    pASCC->guid = MEDIATYPE_Audio;

    *ppmt = (AM_MEDIA_TYPE *)CoTaskMemAlloc(sizeof(AM_MEDIA_TYPE));
    if (*ppmt == NULL)
        return E_OUTOFMEMORY;
    ZeroMemory(*ppmt, sizeof(AM_MEDIA_TYPE));
    HRESULT hr = GetMediaType(i, (CMediaType *)*ppmt);
    if (hr != NOERROR) {
        CoTaskMemFree(*ppmt);
        *ppmt = NULL;
    }
    return hr;
}


STDMETHODIMP CACMWrapper::Load(LPPROPERTYBAG pPropBag, LPERRORLOG pErrorLog)
{
    CAutoLock cObjectLock(&m_csFilter);
    if(m_State != State_Stopped) {
        return VFW_E_WRONG_STATE;
    }

    VARIANT var;
    var.vt = VT_I4;
    HRESULT hr = pPropBag->Read(L"AcmId", &var, 0);
    if(SUCCEEDED(hr))
    {
        hr = S_OK;
        m_wFormatTag = (WORD)var.lVal;

        DbgLog((LOG_TRACE,1,TEXT("CACMWrapper::Load: wFormatTag: %d"),
            m_wFormatTag));
    } else {
        // If we are NOT chosen via PNP as an audio compressor, then we
        // are supposed to be an audio DECOMPRESSOR
        m_wFormatTag = WAVE_FORMAT_PCM;
        hr = S_OK;
    }

    return hr;
}


STDMETHODIMP CACMWrapper::Save(LPPROPERTYBAG pPropBag, BOOL fClearDirty,
                               BOOL fSaveAllProperties)
{
    return E_NOTIMPL;
}

struct AcmPersist
{
    DWORD dwSize;
    WORD wFormatTag;
};

HRESULT CACMWrapper::WriteToStream(IStream *pStream)
{
    AcmPersist ap;
    ap.dwSize = sizeof(ap);
    ap.wFormatTag = m_wFormatTag;

    return pStream->Write(&ap, sizeof(AcmPersist), 0);
}


HRESULT CACMWrapper::ReadFromStream(IStream *pStream)
{
    CAutoLock cObjectLock(&m_csFilter);
    if(m_State != State_Stopped) {
        return VFW_E_WRONG_STATE;
    }

    if(m_wFormatTag != WAVE_FORMAT_PCM) {
        return HRESULT_FROM_WIN32(ERROR_ALREADY_INITIALIZED);
    }

    AcmPersist ap;
    HRESULT hr = pStream->Read(&ap, sizeof(ap), 0);
    if(SUCCEEDED(hr))
    {
        if(ap.dwSize == sizeof(ap))
        {
            m_wFormatTag = ap.wFormatTag;
            DbgLog((LOG_TRACE,1,TEXT("CACMWrapper::ReadFromStream  wFormatTag: %d"),
                m_wFormatTag));

        }
        else
        {
            hr = HRESULT_FROM_WIN32(ERROR_INVALID_DATA);
        }
    }


    return hr;
}


int CACMWrapper::SizeMax()
{
    return sizeof(AcmPersist);
}


STDMETHODIMP CACMWrapper::GetClassID(CLSID *pClsid)
{
    CheckPointer(pClsid, E_POINTER);
    *pClsid = m_clsid;
    return S_OK;
}


STDMETHODIMP CACMWrapper::InitNew()
{
    if (m_wFormatTag != WAVE_FORMAT_PCM) {
        return HRESULT_FROM_WIN32(ERROR_ALREADY_INITIALIZED);
    } else {
        return S_OK;
    }
}

// When you play a file with 1,000,000 samples in it, if the ACM wrapper is in
// the graph compressing or decompressing, it's going to output more or less
// than 1,000,000 samples.  So if somebody asks our output pin how many samples
// are in this file, it's wrong to propogate the request upstream and respond
// with the number of samples the file source thinks there are.
// I will be lazy and refuse any seeking requests that have anything to do with
// samples so we don't end up reporting the wrong thing.

CACMPosPassThru::CACMPosPassThru(const TCHAR *pName, LPUNKNOWN pUnk, HRESULT *phr, IPin *pPin) :
CPosPassThru(pName, pUnk, phr, pPin)
{
}


STDMETHODIMP CACMPosPassThru::SetTimeFormat(const GUID * pFormat)
{
    if(pFormat && *pFormat == TIME_FORMAT_SAMPLE)
        return E_INVALIDARG;
    return CPosPassThru::SetTimeFormat(pFormat);
}


STDMETHODIMP CACMPosPassThru::IsFormatSupported(const GUID *pFormat)
{
    if (pFormat && *pFormat == TIME_FORMAT_SAMPLE)
        return S_FALSE;
    return CPosPassThru::IsFormatSupported(pFormat);
}


STDMETHODIMP CACMPosPassThru::QueryPreferredFormat(GUID *pFormat)
{
    if (pFormat)
        *pFormat = TIME_FORMAT_MEDIA_TIME;
    return S_OK;
}


STDMETHODIMP CACMPosPassThru::ConvertTimeFormat(LONGLONG *pTarget, const GUID *pTargetFormat, LONGLONG Source, const GUID *pSourceFormat)
{
    if ((pSourceFormat && *pSourceFormat == TIME_FORMAT_SAMPLE) ||
        (pTargetFormat && *pTargetFormat == TIME_FORMAT_SAMPLE))
        return E_INVALIDARG;
    return CPosPassThru::ConvertTimeFormat(pTarget, pTargetFormat, Source,
        pSourceFormat);
}
=== C:/Users/treeman/Desktop/windows nt source code\Source\Win2K3\NT\multimedia\dshow\filterus\wav\wavemsr\wavemsr.cpp ===
// Copyright (c) 1994 - 1999  Microsoft Corporation.  All Rights Reserved.

//
//  WAV file parser
//

// Caveats
//

#include <streams.h>
#include <windowsx.h>

#ifdef FILTER_DLL
#include <initguid.h>
#endif
#include <mmsystem.h>
#include <vfw.h>
#include "basemsr.h"
#include "wavemsr.h"

//
// setup data
//

const AMOVIESETUP_MEDIATYPE
psudWAVEParseType[] = { { &MEDIATYPE_Stream       // 1. clsMajorType
                        , &MEDIASUBTYPE_WAVE }    //    clsMinorType
                      , { &MEDIATYPE_Stream       // 2. clsMajorType
                        , &MEDIASUBTYPE_AU   }    //    clsMinorType
                      , { &MEDIATYPE_Stream       // 3. clsMajorType
                        , &MEDIASUBTYPE_AIFF } }; //    clsMinorType

const AMOVIESETUP_MEDIATYPE
sudWAVEParseOutType = { &MEDIATYPE_Audio       // 1. clsMajorType
                       , &MEDIASUBTYPE_NULL }; //    clsMinorType

const AMOVIESETUP_PIN
psudWAVEParsePins[] =  { { L"Input"             // strName
            , FALSE                // bRendered
            , FALSE                // bOutput
            , FALSE                // bZero
            , FALSE                // bMany
            , &CLSID_NULL          // clsConnectsToFilter
            , L""                  // strConnectsToPin
            , 3                    // nTypes
            , psudWAVEParseType }, // lpTypes
                 { L"Output"             // strName
            , FALSE                // bRendered
            , TRUE                 // bOutput
            , FALSE                // bZero
            , FALSE                // bMany
            , &CLSID_NULL          // clsConnectsToFilter
            , L""                  // strConnectsToPin
            , 1                    // nTypes
            , &sudWAVEParseOutType } }; // lpTypes

const AMOVIESETUP_FILTER
sudWAVEParse = { &CLSID_WAVEParser     // clsID
               , L"Wave Parser"        // strName
               , MERIT_UNLIKELY        // dwMerit
               , 2                     // nPins
               , psudWAVEParsePins };   // lpPin

#ifdef FILTER_DLL
// COM global table of objects available in this dll
CFactoryTemplate g_Templates[] = {

    { L"WAVE Parser"
    , &CLSID_WAVEParser
    , CWAVEParse::CreateInstance
    , NULL
    , &sudWAVEParse }
};
int g_cTemplates = sizeof(g_Templates) / sizeof(g_Templates[0]);

// exported entry points for registration and
// unregistration (in this case they only call
// through to default implmentations).
//
STDAPI DllRegisterServer()
{
  return AMovieDllRegisterServer2( TRUE );
}

STDAPI DllUnregisterServer()
{
  return AMovieDllRegisterServer2( FALSE );
}
#endif

//
// CWAVEParse::Constructor
//
CWAVEParse::CWAVEParse(TCHAR *pName, LPUNKNOWN lpunk, HRESULT *phr)
        : CBaseMSRFilter(pName, lpunk, CLSID_WAVEParser, phr),
          m_pInfoList(0),
          m_fNoInfoList(false)
{

    //  Override seeking caps
    m_dwSeekingCaps = AM_SEEKING_CanSeekForwards
                    | AM_SEEKING_CanSeekBackwards
                    | AM_SEEKING_CanSeekAbsolute
                    | AM_SEEKING_CanGetStopPos
                    | AM_SEEKING_CanGetDuration
                    | AM_SEEKING_CanDoSegments;
    CreateInputPin(&m_pInPin);

    DbgLog((LOG_TRACE, 1, TEXT("CWAVEParse created")));
}


//
// CWAVEParse::Destructor
//
CWAVEParse::~CWAVEParse(void) {

    DbgLog((LOG_TRACE, 1, TEXT("CWAVEParse destroyed")) );

    ASSERT(m_pInfoList == 0);
    ASSERT(!m_fNoInfoList);
}


//
// CreateInstance
//
// Called by CoCreateInstance to create a QuicktimeReader filter.
CUnknown *CWAVEParse::CreateInstance(LPUNKNOWN lpunk, HRESULT *phr) {

    CUnknown *punk = new CWAVEParse(NAME("WAVE parsing filter"), lpunk, phr);
    if (punk == NULL) {
        *phr = E_OUTOFMEMORY;
    }
    return punk;
}


#define SWAP(x,y)   (((x)^=(y)), ((y)^=(x)), ((x)^=(y)))

void inline SwapDWORD( DWORD *pdw )
{
    *pdw = _lrotl(((*pdw & 0xFF00FF00) >> 8) | ((*pdw & 0x00FF00FF) << 8), 16);
}

WORD inline SwapWORD(WORD w)
{
        return ((w & 0x00FF) << 8) |
               ((w & 0xFF00) >> 8) ;
}

void inline SwapWORD( WORD *pw )
{
    *pw = SwapWORD(*pw);
}


typedef struct {
    DWORD magic;               /* magic number SND_MAGIC */
    DWORD dataLocation;        /* offset or poDWORDer to the data */
    DWORD dataSize;            /* number of bytes of data */
    DWORD dataFormat;          /* the data format code */
    DWORD samplingRate;        /* the sampling rate */
    DWORD channelCount;        /* the number of channels */
    DWORD fccInfo;             /* optional text information */
} SNDSoundStruct;

#define  SND_FORMAT_MULAW_8   1 // 8-bit mu-law samples
#define  SND_FORMAT_LINEAR_8  2 // 8-bit linear samples (twos complement)
#define  SND_FORMAT_LINEAR_16 3 // 16-bit linear samples (twos complement, moto order)


// get an extended value and return this value converted to a long
LONG ExtendedToLong(BYTE *pExt)
{
    LONG lRtn;
    WORD wNeg, wExp;

    wNeg = pExt[0] & 0x80;

    wExp = (((WORD)(pExt[0] & 0x7F)<<8) + (BYTE)pExt[1] - 16383) & 0x07FF;

    if( (wExp > 24) || (wExp <= 0 ) ) {
        return( (LONG)0xFFFFFFFF );
    }

    if( wExp > 15 ) {
        lRtn = ((wExp < 7) ? ( (BYTE)pExt[2] >> (7-wExp) ) :
            (DWORD)((BYTE)pExt[2] << (wExp-7)));
    } else {
        lRtn = ((wExp < 7) ? ( (BYTE)pExt[2] >> (7-wExp) ) :
            (WORD)((BYTE)pExt[2] << (wExp-7)));
    }

    lRtn += ((wExp<15) ? ( (BYTE)pExt[3] >> (15-wExp) ) :
            ((BYTE)pExt[3] << (wExp-15)));

    lRtn += ((wExp<23) ? ( (BYTE)pExt[4] >> (23-wExp) ) :
            ((BYTE)pExt[4] << (wExp-23)));

    if( wNeg ) {
        lRtn = 0 - lRtn;
    }

    return( lRtn );
}


#include <pshpack2.h>
typedef struct {
    WORD    channels;
    BYTE    frames[4];
    WORD    bits;
    BYTE    extRate[10];        // IEEE extended double
} AIFFFMT;

// Extended Common Chunk
struct AIFCFMT :
    public AIFFFMT
{
    DWORD   compressionType;    // this is the DWORD on a WORD boundary
    // BYTE    compressionName; // variable size string for compression type
};
#include <poppack.h>




//
// structures for manipulating RIFF headers
//
#define FCC(ch4) ((((DWORD)(ch4) & 0xFF) << 24) |     \
                  (((DWORD)(ch4) & 0xFF00) << 8) |    \
                  (((DWORD)(ch4) & 0xFF0000) >> 8) |  \
                  (((DWORD)(ch4) & 0xFF000000) >> 24))


// functions shared between avi parser and wav parser
HRESULT SearchList(
    IAsyncReader *pAsyncReader,
    DWORDLONG *qwPosOut, FOURCC fccSearchKey,
    DWORDLONG qwPosStart, ULONG *cb);

HRESULT SaveInfoChunk(
    RIFFLIST UNALIGNED *pRiffInfo, IPropertyBag *pbag);

HRESULT GetInfoStringHelper(RIFFLIST *pInfoList, DWORD dwFcc, BSTR *pbstr);


#define C_QUEUED_SAMPLES 5


HRESULT CWAVEParse::CreateOutputPins()
{
    HRESULT         hr = NOERROR;
    RIFFLIST        ckhead;

    const int MAX_STREAMS = 1;
    m_rgpOutPin = new CBaseMSROutPin*[MAX_STREAMS];
    if (!m_rgpOutPin)
        return E_OUTOFMEMORY;

    m_rgpOutPin[0] = 0;

    /* Try to read RIFF chunk header */
    hr = m_pAsyncReader->SyncRead(0, sizeof(ckhead), (BYTE *) &ckhead);

    if (hr != S_OK)
        goto readerror;

    CWAVEStream *ps;

    if (ckhead.fcc == FCC('RIFF')) {
        DWORD dwPos = sizeof(RIFFLIST);

        DWORD dwFileSize = ckhead.cb + sizeof(RIFFCHUNK);

        if (ckhead.fccListType != FCC('WAVE'))
            goto formaterror;

        RIFFCHUNK ck;
        while (1) {
            if (dwPos > dwFileSize - sizeof(RIFFCHUNK)) {
                DbgLog((LOG_TRACE, 1, TEXT("eof while searching for fmt")));
                goto readerror;
            }

            hr = m_pAsyncReader->SyncRead(dwPos, sizeof(ck), (BYTE *) &ck);
            if (hr != S_OK)
                goto readerror;

            // !!! handle 'fact' chunk here?

            if (ck.fcc == FCC('fmt '))
                break;

            dwPos += sizeof(ck) + (ck.cb + (ck.cb & 1));
        }

        DbgLog((LOG_TRACE, 1, TEXT("found fmt at %x"), dwPos));

        m_rgpOutPin[0] = ps = new CWAVEStream(NAME("WAVE Stream Object"), &hr, this,
                                   L"output", m_cStreams);
        if (FAILED(hr)) {
            delete m_rgpOutPin[0];
            m_rgpOutPin[0] = NULL;
        }

        if (!m_rgpOutPin[0])
            goto memerror;

        m_cStreams++;
        m_rgpOutPin[0]->AddRef();

        BYTE *pbwfx = new BYTE[ck.cb];
        if (pbwfx == NULL)
            goto memerror;

        hr = m_pAsyncReader->SyncRead(dwPos + sizeof(RIFFCHUNK), ck.cb, pbwfx);
        if (hr != S_OK)
        {
            delete[] pbwfx;
            goto readerror;
        }

        extern HRESULT SetAudioSubtypeAndFormat(CMediaType *pmt, BYTE *pbwfx, ULONG cbwfx);
        HRESULT hrTmp = SetAudioSubtypeAndFormat(&ps->m_mtStream, pbwfx, ck.cb);
        delete[] pbwfx;

        if(hrTmp != S_OK) {
            goto memerror;
        }
    

        

        // work around acm bug for broken pcm files
        {
            WAVEFORMATEX *pwfx = (WAVEFORMATEX *)ps->m_mtStream.Format();
            if(pwfx->wFormatTag == WAVE_FORMAT_PCM /* && pwfx->cbSize != 0 */)
                pwfx->cbSize = 0;
        }

        // keep a private copy of the interesting part
        CopyMemory((void *)&ps->m_wfx, ps->m_mtStream.Format(), sizeof(WAVEFORMATEX));

        // verify important header fields?
        if (ps->m_wfx.nBlockAlign == 0) // would cause div by 0
            goto readerror;

        //CreateAudioMediaType(&ps->m_wfx, &ps->m_mtStream, FALSE);
        ps->m_mtStream.majortype            = MEDIATYPE_Audio;
        ps->m_mtStream.formattype           = FORMAT_WaveFormatEx;
        ps->m_mtStream.bFixedSizeSamples    = TRUE;
        ps->m_mtStream.bTemporalCompression = FALSE;
        ps->m_mtStream.lSampleSize          = ps->m_wfx.nBlockAlign;
        ps->m_mtStream.pUnk                 = NULL;

        while (1) {
            dwPos += sizeof(ck) + (ck.cb + (ck.cb & 1));
            if (dwPos > dwFileSize - sizeof(RIFFCHUNK)) {
                DbgLog((LOG_TRACE, 1, TEXT("eof while searching for data")));
                goto readerror;
            }

            hr = m_pAsyncReader->SyncRead(dwPos, sizeof(ck), (BYTE *) &ck);
            if (hr != S_OK)
                goto readerror;

            if (ck.fcc == FCC('data'))
                break;
        }

        DbgLog((LOG_TRACE, 1, TEXT("found data at %x"), dwPos));

        ps->m_dwDataOffset = dwPos + sizeof(ck);
        ps->m_dwDataLength = ck.cb;
    } else if (ckhead.fcc == FCC('FORM')) {
        //
        //  AIFF and some AIFF-C support
        //

        DWORD   dwPos = sizeof(RIFFLIST);
        BOOL    bFoundSSND = FALSE;
        BOOL    bFoundCOMM = FALSE;

        SwapDWORD(&ckhead.cb);
        DWORD dwFileSize = ckhead.cb + sizeof(RIFFCHUNK);

        if (ckhead.fccListType != FCC('AIFF') &&
            ckhead.fccListType != FCC('AIFC'))
            goto formaterror;

        m_rgpOutPin[0] = ps = new CWAVEStream(NAME("WAVE Stream Object"), &hr, this,
                                   L"output", m_cStreams);
        if (FAILED(hr)) {
            delete m_rgpOutPin[0];
            m_rgpOutPin[0] = NULL;
        }

        if (!m_rgpOutPin[0])
            goto memerror;

        m_cStreams++;
        m_rgpOutPin[0]->AddRef();

        RIFFCHUNK ck;
        AIFFFMT     header;

        while (!(bFoundCOMM && bFoundSSND)) {
            if (dwPos > dwFileSize - sizeof(RIFFCHUNK)) {
                DbgLog((LOG_TRACE, 1, TEXT("eof while searching for COMM")));
                goto readerror;
            }

            hr = m_pAsyncReader->SyncRead(dwPos, sizeof(ck), (BYTE *) &ck);
            if (hr != S_OK)
                goto readerror;

            SwapDWORD(&ck.cb);

            if (ck.fcc == FCC('COMM')) {

                // treat the mystery common chunk with 2 extra bytes
                // as a normal common chunk
                if(ck.cb == sizeof(AIFFFMT) || ck.cb == sizeof(AIFFFMT) + 2) {
                    /* Try to read AIFF format */
                    hr = m_pAsyncReader->SyncRead(dwPos + sizeof(RIFFCHUNK), sizeof(header), (BYTE *) &header);

                    if (hr != S_OK)
                        goto readerror;

                    DbgLog((LOG_TRACE, 1, TEXT("found COMM at %x"), dwPos));

                    SwapWORD(&header.channels);
                    SwapWORD(&header.bits);

                    bFoundCOMM = TRUE;
                }
                else if(ck.cb >= sizeof(AIFCFMT))
                {
                    AIFCFMT extHeader;
                    /* Try to read AIFC format */
                    hr = m_pAsyncReader->SyncRead(dwPos + sizeof(RIFFCHUNK), sizeof(extHeader), (BYTE *) &extHeader);

                    if (hr != S_OK)
                        goto readerror;

                    // we can only handle uncompressed AIFC...
                    if(extHeader.compressionType != FCC('NONE'))
                    {
                        DbgLog((LOG_ERROR, 1, TEXT("wavemsr: unhandled AIFC")));
                        hr = VFW_E_UNSUPPORTED_AUDIO;
                        goto error;
                    }

                    DbgLog((LOG_TRACE, 1, TEXT("found extended-COMM at %x"), dwPos));
                    CopyMemory(&header, &extHeader, sizeof(header));

                    SwapWORD(&header.channels);
                    SwapWORD(&header.bits);

                    bFoundCOMM = TRUE;
                }
                else
                {
                    DbgLog((LOG_ERROR, 1, TEXT("bad COMM size %x"), ck.cb));
                    goto formaterror;
                }
            }

            if (ck.fcc == FCC('SSND')) {
                DbgLog((LOG_TRACE, 1, TEXT("found data SSND at %x"), dwPos));
                bFoundSSND = TRUE;
                /* Tell rest of handler where data is */
                ps->m_dwDataOffset = dwPos + sizeof(ck);

                LONGLONG llLength = 0, llAvail;
                m_pAsyncReader->Length(&llLength, &llAvail);
                if(llLength != 0)
                  ps->m_dwDataLength = min(ck.cb, ((ULONG)(llLength - ps->m_dwDataOffset)));
                else
                  ps->m_dwDataLength = ck.cb;
            }

            dwPos += sizeof(ck) + ck.cb;
        }

        // fill in wave format fields
        ps->m_wfx.wFormatTag = WAVE_FORMAT_PCM;
        ps->m_wfx.nChannels = header.channels;
        ps->m_wfx.nSamplesPerSec = ExtendedToLong(header.extRate);
        ps->m_wfx.wBitsPerSample = header.bits;
        ps->m_wfx.nBlockAlign = header.bits / 8 * header.channels;
        ps->m_wfx.nAvgBytesPerSec = ps->m_wfx.nSamplesPerSec * ps->m_wfx.nBlockAlign;
        ps->m_wfx.cbSize = 0;

        if (header.bits == 8)
            ps->m_bSignMunge8 = TRUE;
        else if (header.bits == 16)
            ps->m_bByteSwap16 = TRUE;
        else
            goto formaterror;

        if (ps->m_mtStream.AllocFormatBuffer(sizeof(WAVEFORMATEX)) == NULL)
            goto memerror;

        // keep a private copy of the interesting part
        CopyMemory(ps->m_mtStream.Format(), (void *)&ps->m_wfx, sizeof(WAVEFORMATEX));

        CreateAudioMediaType(&ps->m_wfx, &ps->m_mtStream, FALSE);
        // !!! anything else?

    } else {
        //
        //  AU support
        //

        SNDSoundStruct  header;

        /* Try to read AU header */
        hr = m_pAsyncReader->SyncRead(0, sizeof(header), (BYTE *) &header);

        if (hr != S_OK)
            goto readerror;

        // validate header
        if (header.magic != FCC('.snd'))
            goto formaterror;


        SwapDWORD(&header.dataFormat);
        SwapDWORD(&header.dataLocation);
        SwapDWORD(&header.dataSize);
        SwapDWORD(&header.samplingRate);
        SwapDWORD(&header.channelCount);


        m_rgpOutPin[0] = ps = new CWAVEStream(NAME("WAVE Stream Object"), &hr, this,
                                   L"output", m_cStreams);
        if (FAILED(hr)) {
            delete m_rgpOutPin[0];
            m_rgpOutPin[0] = NULL;
        }

        if (!m_rgpOutPin[0])
            goto memerror;

        m_cStreams++;
        m_rgpOutPin[0]->AddRef();

        // fill in wave format fields
        if (header.dataFormat == SND_FORMAT_MULAW_8) {
            ps->m_wfx.wFormatTag = WAVE_FORMAT_MULAW;
            ps->m_wfx.wBitsPerSample = 8;

            // !!! HACK: if the sampling rate is almost 8KHz, make it be
            // exactly 8KHz, so that more sound cards will play it right.
            if (header.samplingRate > 7980 && header.samplingRate < 8020)
                header.samplingRate = 8000;

        } else if (header.dataFormat == SND_FORMAT_LINEAR_8) {
            ps->m_wfx.wFormatTag = WAVE_FORMAT_PCM;
            ps->m_wfx.wBitsPerSample = 8;
            ps->m_bSignMunge8 = TRUE;
        } else if (header.dataFormat == SND_FORMAT_LINEAR_16) {
            ps->m_wfx.wFormatTag = WAVE_FORMAT_PCM;
            ps->m_wfx.wBitsPerSample = 16;
            ps->m_bByteSwap16 = TRUE;
        } else
            goto error;

        ps->m_wfx.nChannels = (UINT) header.channelCount;
        ps->m_wfx.nSamplesPerSec = header.samplingRate;
        ps->m_wfx.nBlockAlign = ps->m_wfx.wBitsPerSample * ps->m_wfx.nChannels / 8;
        ps->m_wfx.nAvgBytesPerSec =  header.samplingRate * ps->m_wfx.nBlockAlign;
        ps->m_wfx.cbSize = 0;

        /* Tell rest of handler where data is */
        ps->m_dwDataOffset = header.dataLocation;
        LONGLONG llLength = 0, llAvail;
        m_pAsyncReader->Length(&llLength, &llAvail);
        if (header.dataSize == 0xffffffff) {
            // can't really play these if the length is zero (ftp case)
            ps->m_dwDataLength = (DWORD) llLength - header.dataLocation;
        } else {
            if(llLength != 0)
              ps->m_dwDataLength = min(header.dataSize, (DWORD) llLength - header.dataLocation);
            else
              ps->m_dwDataLength = header.dataSize;
        }

        if (ps->m_mtStream.AllocFormatBuffer(sizeof(WAVEFORMATEX)) == NULL)
            goto memerror;

        // keep a private copy of the interesting part
        CopyMemory(ps->m_mtStream.Format(), (void *)&ps->m_wfx, sizeof(WAVEFORMATEX));

        CreateAudioMediaType(&ps->m_wfx, &ps->m_mtStream, FALSE);
        // !!! anything else?
    }

    if (hr == S_OK) {
        // set up allocator
        ALLOCATOR_PROPERTIES Request,Actual;

        // plus ten so that there are more samples than samplereqs;
        // GetBuffer blocks only when the downstream guy has a few
        // samples
        Request.cBuffers = C_QUEUED_SAMPLES + 3;

        Request.cbBuffer = ps->GetMaxSampleSize();
        Request.cbAlign = (LONG) 1;
        Request.cbPrefix = (LONG) 0;

        // m_pAllocator is not set, so use m_pRecAllocator
        HRESULT hr = ps->m_pRecAllocator->SetPropertiesInternal(&Request,&Actual);
        ASSERT(SUCCEEDED(hr));

        // ask for 8 buffers (2 seconds) at pin
        ps->m_pRecAllocator->SetCBuffersReported(8);

    }

    return hr;

formaterror:
    hr = VFW_E_INVALID_FILE_FORMAT;
    goto error;

memerror:
    hr = E_OUTOFMEMORY;
    goto error;

readerror:
    hr = HRESULT_FROM_WIN32(ERROR_INVALID_DATA);

error:
    if (SUCCEEDED(hr)) {
        hr = E_FAIL;
    }

    return hr;
}

HRESULT CWAVEParse::GetCacheParams(
  StreamBufParam *rgSbp,
  ULONG *pcbRead,
  ULONG *pcBuffers,
  int *piLeadingStream)
{
  HRESULT hr = CBaseMSRFilter::GetCacheParams(
    rgSbp,
    pcbRead,
    pcBuffers,
    piLeadingStream);
  if(FAILED(hr))
    return hr;

  // from the base class
  ASSERT(*piLeadingStream < 0);

  // configure the reader to try to read 1 a second at a time (matches the DSOUND buffer length) and use 2 buffers.
  // (AVI files can give a dwMaxBytesPerSec that is too small)
  WAVEFORMAT *pwfx = ((WAVEFORMAT *)((CWAVEStream *)m_rgpOutPin[0])->m_mtStream.Format());

  *pcbRead = max(pwfx->nAvgBytesPerSec, pwfx->nBlockAlign);
  *pcBuffers = 2;

  rgSbp[0].cSamplesMax = C_QUEUED_SAMPLES;

  return S_OK;
}

STDMETHODIMP
CWAVEParse::NonDelegatingQueryInterface(REFIID riid, void **ppv)
{
    if(riid == IID_IPersistMediaPropertyBag)
    {
        return GetInterface((IPersistMediaPropertyBag *)this, ppv);
    }
    else if(riid == IID_IAMMediaContent)
    {
        return GetInterface((IAMMediaContent *)this, ppv);
    }
    else
    {
        return CBaseMSRFilter::NonDelegatingQueryInterface(riid, ppv);
    }
}

// ------------------------------------------------------------------------
// IPersistMediaPropertyBag

STDMETHODIMP CWAVEParse::Load(IMediaPropertyBag *pPropBag, LPERRORLOG pErrorLog)
{
    CheckPointer(pPropBag, E_POINTER);

    // the avi parser is read-only!
    HRESULT hr = STG_E_ACCESSDENIED;
    return hr;
}

// dump everything in the info chunk into the caller's property bag

STDMETHODIMP CWAVEParse::Save(
    IMediaPropertyBag *pPropBag,
    BOOL fClearDirty,
    BOOL fSaveAllProperties)
{
    CAutoLock l (m_pLock);
    HRESULT hr = CacheInfoChunk();
    if(SUCCEEDED(hr))
    {
        hr = SaveInfoChunk(m_pInfoList, pPropBag);
    }
    
    return hr;

}

STDMETHODIMP CWAVEParse::InitNew()
{
    return S_OK;
}

STDMETHODIMP CWAVEParse::GetClassID(CLSID *pClsID)
{
    return CBaseFilter::GetClassID(pClsID);
}

HRESULT CWAVEParse::NotifyInputDisconnected()
{
  delete[] (BYTE *)m_pInfoList;
  m_pInfoList = 0;
  m_fNoInfoList = false;

  return CBaseMSRFilter::NotifyInputDisconnected();
}

HRESULT CWAVEParse::CacheInfoChunk()
{
    ASSERT(CritCheckIn(m_pLock));
    
    if(m_pInfoList) {
        return S_OK;
    }
    if(m_fNoInfoList) {
        return VFW_E_NOT_FOUND;
    }

    HRESULT hr = S_OK;

    CMediaType mtIn;
    hr = m_pInPin->ConnectionMediaType(&mtIn);
    if(SUCCEEDED(hr))
    {
        if(*(mtIn.Subtype()) != MEDIASUBTYPE_WAVE)
        {
            hr= E_FAIL;
        }
    }

    if(SUCCEEDED(hr))
    {

        // !!! don't block waiting for progressive download

        // search the first RIFF list for an INFO list
        DWORDLONG dwlInfoPos;
        ULONG cbInfoList;
        hr = SearchList(
            m_pAsyncReader,
            &dwlInfoPos, FCC('INFO'), sizeof(RIFFLIST), &cbInfoList);
        if(SUCCEEDED(hr))
        {
            hr = AllocateAndRead((BYTE **)&m_pInfoList, cbInfoList, dwlInfoPos);
        }
    }
    if(FAILED(hr)) {
        ASSERT(!m_fNoInfoList);
        m_fNoInfoList = true;
    }

    return hr;
    
}

// *
// * Implements CWAVEStream - manages the output pin
//

//
// CWAVEStream::Constructor
//
// keep the driver index to open.
// We will open it when we go active, as we shouldn't keep resources
// whilst inactive.
CWAVEStream::CWAVEStream(TCHAR     *pObjectName
                      , HRESULT *phr
                      , CWAVEParse    *pParentFilter
                      , LPCWSTR pPinName
                      , int     id
                      )
    : CBaseMSROutPin(pParentFilter, pParentFilter, id,
                     pParentFilter->m_pImplBuffer, phr, pPinName),
       m_id(id),
       m_bByteSwap16(FALSE),
       m_bSignMunge8(FALSE),
       m_pFilter(pParentFilter)
    {

    DbgLog( (LOG_TRACE, 1, TEXT("CWAVEStream created") ) );
}


//
// CWAVEStream::Destructor
//
// we should be inactive before this is called.
CWAVEStream::~CWAVEStream(void) {
    ASSERT(!m_pFilter->IsActive());

    DbgLog( (LOG_TRACE, 1, TEXT("CWAVEStream destroyed") ) );
}


//
// GetMediaType
//
// Queries the video driver and places an appropriate media type in *pmt
HRESULT CWAVEStream::GetMediaType(int iPosition, CMediaType *pmt) {
    CAutoLock l(&m_cSharedState);

    HRESULT hr;

    // check it is the single type they want
    // This method is only called by base class code so we don't have to
    // check arguments
    if (iPosition != 0 && 
        !(iPosition == 1 && m_wfx.wFormatTag == WAVE_FORMAT_MPEG)) {
        hr =  VFW_S_NO_MORE_ITEMS;
    } else {
        *pmt = m_mtStream;
    
        //  Backwards compatibility
        if (iPosition == 1) {
            pmt->subtype = MEDIASUBTYPE_MPEG1Payload;
        }
        if (pmt->pbFormat == NULL) {
            hr = E_OUTOFMEMORY;
        } else {
            hr = S_OK;
        }
    }

    return hr;
}


//
// Active
//
//
HRESULT CWAVEStream::OnActive() {

    HRESULT hr = NOERROR;

    if(!m_pWorker) {
        m_pWorker = new CWAVEMSRWorker(m_id, m_rpImplBuffer, this);
        if(m_pWorker == 0)
            return E_OUTOFMEMORY;
    }

    return hr;
}

BOOL CWAVEStream::UseDownstreamAllocator()
{
  return m_bSignMunge8 || m_bByteSwap16;
}

HRESULT CWAVEStream::DecideBufferSize(
    IMemAllocator * pAlloc,
    ALLOCATOR_PROPERTIES *pProperties) {
    HRESULT hr;

    ALLOCATOR_PROPERTIES Request,Actual;

    // configure this allocator same as internal allocator. note
    // GetProperties reports the value saved in SetCBuffersReported
    hr = m_pRecAllocator->GetProperties(&Request);
    if(FAILED(hr))
      return hr;

    hr = pAlloc->SetProperties(&Request,&Actual);
    if(FAILED(hr))
      return hr;

    if(Actual.cbBuffer < Request.cbBuffer)
      return E_UNEXPECTED;

    return S_OK;
}

ULONG CWAVEStream::GetMaxSampleSize()
{
    ULONG ul = max(m_wfx.nAvgBytesPerSec / 4, m_wfx.nBlockAlign);

    ul += (m_wfx.nBlockAlign - 1);
    ul -= (ul % m_wfx.nBlockAlign);
    return ul;
}

HRESULT CWAVEStream::GetDuration(LONGLONG *pDuration)
{
  if(m_guidFormat == TIME_FORMAT_SAMPLE)
  {
    *pDuration = ((m_dwDataLength + m_wfx.nBlockAlign - 1) / m_wfx.nBlockAlign);
  }
  else
  {
    ASSERT(m_guidFormat == TIME_FORMAT_MEDIA_TIME);
    *pDuration = SampleToRefTime(((m_dwDataLength + m_wfx.nBlockAlign - 1) / m_wfx.nBlockAlign));
  }

  return S_OK;
}

HRESULT CWAVEStream::GetAvailable(LONGLONG * pEarliest, LONGLONG * pLatest)
{
  if (pEarliest)
    *pEarliest = 0;

  if (pLatest)
  {
    // ask the source file reader how much of the file is available
    LONGLONG llLength, llAvail;
    m_pFilter->m_pAsyncReader->Length(&llLength, &llAvail);

    DWORD dwAvail = 0;

    // the current read position may be before the actual wave data
    // !!! wouldn't work right for wave files > 2GB
    if ((DWORD) llAvail > m_dwDataOffset)
        dwAvail = (DWORD) llAvail - m_dwDataOffset;

    // or after the end....
    if (dwAvail > m_dwDataLength)
        dwAvail = m_dwDataLength;


    if(m_guidFormat == TIME_FORMAT_SAMPLE)
    {
      *pLatest = ((dwAvail + m_wfx.nBlockAlign - 1) / m_wfx.nBlockAlign);
    }
    else
    {
      ASSERT(m_guidFormat == TIME_FORMAT_MEDIA_TIME);
      *pLatest = SampleToRefTime(((dwAvail + m_wfx.nBlockAlign - 1) / m_wfx.nBlockAlign));
    }
  }

  return S_OK;
}

HRESULT CWAVEStream::IsFormatSupported(const GUID *const pFormat)
{
  // !!! only support time_format_sample for pcm?

  if(*pFormat == TIME_FORMAT_MEDIA_TIME)
    return S_OK;
  else if(*pFormat == TIME_FORMAT_SAMPLE &&
          ((WAVEFORMATEX *)m_mtStream.Format())->wFormatTag == WAVE_FORMAT_PCM)
    return S_OK;

  return S_FALSE;
}



HRESULT CWAVEStream::RecordStartAndStop(
  LONGLONG *pCurrent, LONGLONG *pStop, REFTIME *pTime,
  const GUID *const pGuidFormat
  )
{
  if(*pGuidFormat == TIME_FORMAT_MEDIA_TIME)
  {
    if(pCurrent)
      m_llCvtImsStart = RefTimeToSample(*pCurrent);

    // we want to round up the stop time for apps which round down the
    // stop time then get confused when we round it down further. This
    // relies on RefTimeToSample rounding down always
    if(pStop)
      m_llCvtImsStop = RefTimeToSample(*pStop + SampleToRefTime(1) - 1);

    if(pTime)
    {
      ASSERT(pCurrent);
      *pTime = (double)(*pCurrent) / UNITS;
    }

    DbgLog((LOG_TRACE, 5,
            TEXT("wav parser RecordStartAndStop: %d to %d ms"),
            pCurrent ? (long)(*pCurrent) : -1,
            pStop ? (long)(*pStop) : -1));
    DbgLog((LOG_TRACE, 5,
            TEXT("wav parser RecordStartAndStop: %d to %d ticks"),
            (long)m_llCvtImsStart,
            (long)m_llCvtImsStop));
  }
  else
  {
    ASSERT(*pGuidFormat == TIME_FORMAT_SAMPLE);
    if(pCurrent)
      m_llCvtImsStart = *pCurrent;

    if(pStop)
      m_llCvtImsStop = *pStop;

    DbgLog((LOG_TRACE, 5,
            TEXT("wav parser RecordStartAndStop: %d to %d ticks"),
            pCurrent ? (long)(*pCurrent) : -1,
            pStop ? (long)(*pStop) : -1));

    DbgLog((LOG_TRACE, 5,
            TEXT("wav parser RecordStartAndStop: %d to %d ticks"),
            (long)m_llCvtImsStart,
            (long)m_llCvtImsStop));

    if(pTime)
    {
      ASSERT(pCurrent);
      *pTime = (double)SampleToRefTime((long)(*pCurrent)) / UNITS;
    }
  }

  return S_OK;
}

REFERENCE_TIME CWAVEStream::ConvertInternalToRT(const LONGLONG llVal)
{
  return SampleToRefTime((long)llVal);
}

LONGLONG CWAVEStream::ConvertRTToInternal(const REFERENCE_TIME rtVal)
{
  return RefTimeToSample(rtVal);
}

// ------------------------------------------------------------------------
// ------------------------------------------------------------------------

CWAVEMSRWorker::CWAVEMSRWorker(UINT stream,
                             IMultiStreamReader *pReader,
                             CWAVEStream *pStream) :
    CBaseMSRWorker(stream, pReader),
    m_ps(pStream)
{
}


// Start streaming & reset time samples are stamped with.
HRESULT CWAVEMSRWorker::PushLoopInit(LONGLONG *pllCurrentOut, ImsValues *pImsValues)
{
// !!!!    CAutoLock l(&m_cSharedState);

    m_sampCurrent = (long)pImsValues->llTickStart;

    DbgLog((LOG_TRACE, 1, TEXT("Playing samples %d to %d, starting from %d"),
            (ULONG)pImsValues->llTickStart, (ULONG)pImsValues->llTickStop, m_sampCurrent));

    *pllCurrentOut = pImsValues->llTickStart;

    return NOERROR;
}


HRESULT CWAVEMSRWorker::AboutToDeliver(IMediaSample *pSample)
{
    if (m_ps->m_wfx.wFormatTag == WAVE_FORMAT_MPEG ||
        m_ps->m_wfx.wFormatTag == WAVE_FORMAT_MPEGLAYER3) {
        FixMPEGAudioTimeStamps(pSample, m_cSamples == 0, &m_ps->m_wfx);
    }
    if (m_cSamples == 0) {
        pSample->SetDiscontinuity(TRUE);
    }

    return S_OK;
}


// QueueBuffer
//
// Queue another read....
HRESULT CWAVEMSRWorker::TryQueueSample(
  LONGLONG &rllCurrent,         // current time updated
  BOOL &rfQueuedSample,         // [out] queued sample?
  ImsValues *pImsValues
  )
{
    HRESULT hr;
    rfQueuedSample = FALSE;

    // sample passed into QueueRead().
    CRecSample *pSampleOut = 0;

    // actually read data

    // get an empty sample w/ no allocated space. ok if this blocks
    // because we configured it with more samples than there are
    // SampleReqs for this stream in the buffer. that means that if
    // it blocks it is because down stream filters have refcounts on
    // samples
    hr = m_ps->GetDeliveryBufferInternal(&pSampleOut, 0, 0, 0);
    if (FAILED(hr)) {
        DbgLog((LOG_TRACE, 5, TEXT("CBaseMSRWorker::PushLoop: getbuffer failed")));
        return hr;
    }

    ASSERT(pSampleOut != 0);

    LONG        lSamplesTotal = m_ps->GetMaxSampleSize() / m_ps->m_wfx.nBlockAlign;

    LONG        lSamplesRead = 0;
    LONG        lBytesRead = 0;
    LONG        lSampleStart = m_sampCurrent;

    if (m_sampCurrent + lSamplesTotal > pImsValues->llTickStop)
    {
        lSamplesTotal = (long)pImsValues->llTickStop - m_sampCurrent;

        // Had to add the bomb proofing.  Don't know why...
        if (lSamplesTotal < 0) lSamplesTotal = 0;
    }

    if (lSamplesTotal == 0)
    {
        hr = VFW_S_NO_MORE_ITEMS;
    }
    else  {
        LONG lByteOffset = m_sampCurrent * m_ps->m_wfx.nBlockAlign;
        lBytesRead = lSamplesTotal * m_ps->m_wfx.nBlockAlign;
        if(lByteOffset + lBytesRead > (long)m_ps->m_dwDataLength)
          lBytesRead = m_ps->m_dwDataLength - lByteOffset;

        hr = m_pReader->QueueReadSample(lByteOffset + m_ps->m_dwDataOffset,
                                        lBytesRead, pSampleOut, m_id);

        if (hr == S_OK) {
            m_sampCurrent += lSamplesTotal;
        }
    }

    if (hr == S_OK) {
        pSampleOut->SetActualDataLength(lBytesRead);
    }

    if (hr == E_OUTOFMEMORY) {
        DbgLog((LOG_TRACE, 5, TEXT("CBaseMSRWorker::TryQSample: q full") ));
        hr = S_FALSE;
    }

    // real error or the downstream filter stopped.
    if(FAILED(hr))
    {
      DbgLog(( LOG_ERROR, 5, TEXT("CWAVEMSRWorker::TryQSample: error %08x"), hr ));
    }

    if (hr == S_OK) {

        REFERENCE_TIME rtstStart = (REFERENCE_TIME)m_ps->SampleToRefTime(lSampleStart - (long)pImsValues->llTickStart);
        REFERENCE_TIME rtstEnd = (REFERENCE_TIME)m_ps->SampleToRefTime(m_sampCurrent - (long)pImsValues->llTickStart);

        // adjust both times by Rate. !!! adjust media time?
        if(pImsValues->dRate != 1 && pImsValues->dRate != 0)
        {
            // scale up and divide
            rtstStart = (REFERENCE_TIME)((double)rtstStart / pImsValues->dRate);
            rtstEnd = (REFERENCE_TIME)((double)rtstEnd / pImsValues->dRate);
        }

        rtstStart += m_pPin->m_rtAccumulated;
        rtstEnd   += m_pPin->m_rtAccumulated;

        pSampleOut->SetTime(&rtstStart, &rtstEnd);

        LONGLONG llmtStart = lSampleStart, llmtEnd = m_sampCurrent;
        pSampleOut->SetMediaTime(&llmtStart, &llmtEnd);

        rfQueuedSample = TRUE;

        DbgLog((LOG_TRACE, 0x3f,
                TEXT("wav parser: queued %d to %d ticks. %d bytes"),
                (LONG)llmtStart, (LONG)llmtEnd, lBytesRead));
    }

    // !!! set discontinuity, key frame bits

    // Release sample, refcount will be kept by reader code if appropriate.
    pSampleOut->Release();

    return hr;
}


// returns the sample number showing at time t
LONG
CWAVEStream::RefTimeToSample(CRefTime t)
{
    // Rounding down
    LONG s = (LONG) ((t.GetUnits() * m_wfx.nAvgBytesPerSec) / (UNITS * m_wfx.nBlockAlign));

    return s;
}

CRefTime
CWAVEStream::SampleToRefTime(LONG s)
{
    // Rounding up
    return llMulDiv( s, m_wfx.nBlockAlign * UNITS, m_wfx.nAvgBytesPerSec, m_wfx.nAvgBytesPerSec-1 );
}

LONGLONG CWAVEStream::GetStreamStart()
{
    return 0;
}

LONGLONG CWAVEStream::GetStreamLength()
{
    // !!! rounding?
    return (m_dwDataLength + m_wfx.nBlockAlign - 1) / m_wfx.nBlockAlign;
}


HRESULT
CWAVEParse::CheckMediaType(const CMediaType* pmt)
{
    if (*(pmt->Type()) != MEDIATYPE_Stream)
        return E_INVALIDARG;

    if (*(pmt->Subtype()) != MEDIASUBTYPE_WAVE
        && *(pmt->Subtype()) != MEDIASUBTYPE_AU
        && *(pmt->Subtype()) != MEDIASUBTYPE_AIFF)
        return E_INVALIDARG;

    return S_OK;
}


HRESULT CWAVEMSRWorker::CopyData(IMediaSample **ppSampleOut, IMediaSample *pms)
{
    BYTE        *pData;
    BYTE        *pDataOut;
    long        lDataLen;

    ASSERT(m_ps->m_bByteSwap16 || m_ps->m_bSignMunge8);

    // this is the GetDeliveryBuffer in CBaseOutputPin which gets it
    // from the allocator negotiated by the pins. (takes IMediaSample,
    // not CRecSample)
    HRESULT hr = m_pPin->GetDeliveryBuffer(ppSampleOut, 0, 0, 0);
    if(FAILED(hr))
      return hr;

    pms->GetPointer(&pData);
    (*ppSampleOut)->GetPointer(&pDataOut);

    lDataLen = pms->GetActualDataLength();
    ASSERT(lDataLen <= (*ppSampleOut)->GetSize());
    hr = (*ppSampleOut)->SetActualDataLength(lDataLen);
    if(FAILED(hr))
      return hr;

    if (m_ps->m_bByteSwap16) {
        WORD *pw = (WORD *) pData;
        WORD *pwOut = (WORD *)pDataOut;
        for (long l = 0; l < lDataLen / 2; l++) {
            pwOut[l] = SwapWORD(pw[l]);
        }

        // let TwosComplement work from the altered buffer
        pData = (BYTE *)pwOut;
    }

    if (m_ps->m_bSignMunge8) {
        for (long l = 0; l < lDataLen; l++) {
            pDataOut[l] = pData[l] ^ 0x80;
        }
    }

    REFERENCE_TIME rtStart, rtEnd;
    if (SUCCEEDED(pms->GetTime(&rtStart, &rtEnd)))
        (*ppSampleOut)->SetTime(&rtStart, &rtEnd);
    LONGLONG llmtStart, llmtEnd;
    if (SUCCEEDED(pms->GetMediaTime(&llmtStart, &llmtEnd)))
        (*ppSampleOut)->SetMediaTime(&llmtStart, &llmtEnd);

    return S_OK;
}

HRESULT CWAVEParse::GetInfoString(DWORD dwFcc, BSTR *pbstr)
{
    *pbstr = 0;
    CAutoLock l(m_pLock);
    
    HRESULT hr = CacheInfoChunk();
    if(SUCCEEDED(hr)) {
        hr = GetInfoStringHelper(m_pInfoList, dwFcc, pbstr);
    }
    return hr;
}



HRESULT CWAVEParse::get_Copyright(BSTR FAR* pbstrX)
{
    return GetInfoString(FCC('ICOP'), pbstrX);
}
HRESULT CWAVEParse::get_AuthorName(BSTR FAR* pbstrX)
{
    return GetInfoString(FCC('IART'), pbstrX);
}
HRESULT CWAVEParse::get_Title(BSTR FAR* pbstrX)
{
    return GetInfoString(FCC('INAM'), pbstrX);
}
=== C:/Users/treeman/Desktop/windows nt source code\Source\Win2K3\NT\multimedia\dshow\filterus\writer\fw.cpp ===
// Copyright (c) 1996 - 1999  Microsoft Corporation.  All Rights Reserved.
#include <streams.h>
#include <initguid.h>
#include "fw.h"

// ------------------------------------------------------------------------
// filter

#pragma warning(disable:4355)
CBaseWriterFilter::CBaseWriterFilter(LPUNKNOWN pUnk, HRESULT *pHr) :
    CBaseFilter(NAME("fw filter"), pUnk, &m_cs, CLSID_FileWriter),
    m_inputPin(NAME("fw inpin"), this, &m_cs, pHr)
{
  ASSERT(m_mtSet.majortype == GUID_NULL);
  ASSERT(m_mtSet.subtype == GUID_NULL);
}

CBaseWriterFilter::~CBaseWriterFilter()
{
}

STDMETHODIMP
CBaseWriterFilter::NonDelegatingQueryInterface(REFIID riid, void ** ppv)
{
  if(riid == IID_IAMFilterMiscFlags)
    return GetInterface((IAMFilterMiscFlags *)this, ppv);
  else
    return CBaseFilter::NonDelegatingQueryInterface(riid, ppv);    
}

int CBaseWriterFilter::GetPinCount()
{
  return 1;
}

CBasePin *CBaseWriterFilter::GetPin(int pin)
{
  return pin == 0 ? &m_inputPin : 0;
}

HRESULT CBaseWriterFilter::Pause()
{
  CAutoLock lock(&m_cs);

  if(m_State == State_Stopped)
  {
    m_fEosSignaled = FALSE;
    m_fErrorSignaled = FALSE;

    HRESULT hr = CanPause();
    if(FAILED(hr))
    {
      m_fErrorSignaled = TRUE;
      return hr;
    }
    
    // send an EC_COMPLETE event first time we run with input
    // disconnected
    if(!m_inputPin.IsConnected())
    {
      m_fEosSignaled = TRUE;
    }
    
    hr = Open();
    if(FAILED(hr))
    {
      m_fErrorSignaled = TRUE;
      return hr;
    }
  }

  return CBaseFilter::Pause();
}

HRESULT CBaseWriterFilter::Run(REFERENCE_TIME rtStart)
{
  CAutoLock Lock(&m_cs);
  HRESULT hr = CBaseFilter::Run(rtStart);

  // every time we transition to Run, need to send EC_COMPLETE if
  // we're done.
  if(m_fEosSignaled && !m_fErrorSignaled)
  {
    NotifyEvent(EC_COMPLETE, S_OK, (LONG_PTR)(IBaseFilter *)this);
  }

  return hr;
    
}

HRESULT CBaseWriterFilter::Stop()
{
  CAutoLock lock(&m_cs);
  HRESULT hrClose = Close();
  HRESULT hrStop = CBaseFilter::Stop();
  if(m_fErrorSignaled)
    return hrStop;
  else
    return FAILED(hrClose) ? hrClose : hrStop;
}



// could be used to close asynchronous file handle (used by
// IMemInputPin) early

STDMETHODIMP CBaseWriterFilter::EndOfStream()
{
  DbgLog((LOG_TRACE, 3, TEXT("CBaseWriterFilter: EOS")));
  CAutoLock lock(&m_cs);
  ASSERT(!m_fEosSignaled);
  m_fEosSignaled = TRUE;

  if(!m_fErrorSignaled)
  {
    if(m_State == State_Running)
    {
      NotifyEvent(EC_COMPLETE, S_OK, (LONG_PTR)(IBaseFilter *)this);
    }
    else if(m_State == State_Paused)
    {
      // m_fEosSignaled set, so will be signaled on run
    }
    else
    {
      ASSERT(m_State == State_Stopped);
      // we could have stopped already; ignore EOS
    }
  }
  
  return S_OK;
}


// ------------------------------------------------------------------------
// input pin

CBaseWriterInput::CBaseWriterInput(
  TCHAR *pObjectName,
  CBaseWriterFilter *pFilter,
  CCritSec *pLock,
  HRESULT *phr) : 
    CBaseInputPin(pObjectName, pFilter, pLock, phr, L"in"),
    m_pFwf(pFilter)
{
}

STDMETHODIMP
CBaseWriterInput::NonDelegatingQueryInterface(REFIID riid, void ** pv)
{
  if(riid == IID_IStream)
  {
    return m_pFwf->CreateIStream(pv);
  }
  else
  {
    return CBaseInputPin::NonDelegatingQueryInterface(riid, pv);
  }
}

HRESULT CBaseWriterInput::CheckMediaType(const CMediaType *pmt)
{
  // accept what's set or anything if not set
  if((m_pFwf->m_mtSet.majortype == pmt->majortype ||
      m_pFwf->m_mtSet.majortype == GUID_NULL) &&
     (m_pFwf->m_mtSet.subtype == pmt->subtype ||
      m_pFwf->m_mtSet.subtype == GUID_NULL))
  {
    return S_OK;
  }
  else
  {
    return S_FALSE;
  }
}

STDMETHODIMP
CBaseWriterInput::BeginFlush(void)
{
  return E_UNEXPECTED;
}

STDMETHODIMP
CBaseWriterInput::EndFlush(void)
{
  return E_UNEXPECTED;
}

STDMETHODIMP CBaseWriterInput::GetAllocator(IMemAllocator **ppA)
{
  *ppA = 0;
  // what do you want with my allocator.... you can't set the data
  // pointer on it...
  return E_INVALIDARG;
}

// return disk sector size through here
STDMETHODIMP CBaseWriterInput::GetAllocatorRequirements(
  ALLOCATOR_PROPERTIES *pAp)
{
  ULONG cb;
  ZeroMemory(pAp, sizeof(*pAp));
  HRESULT hr = m_pFwf->GetAlignReq(&cb);
  ASSERT(hr == S_OK);
  pAp->cbAlign = cb;

  return S_OK;
}

STDMETHODIMP CBaseWriterInput::Receive(IMediaSample *pSample)
{
  CAutoLock l(&m_pFwf->m_cs);
  if(m_pFwf->m_fErrorSignaled)
    return S_FALSE;

  ASSERT(!m_pFwf->m_fEosSignaled);
  
  REFERENCE_TIME rtStart, rtEnd;
  HRESULT hr = pSample->GetTime(&rtStart, &rtEnd);
  if(hr != S_OK)
  {
    m_pFwf->m_fErrorSignaled = TRUE;
    m_pFwf->NotifyEvent(EC_ERRORABORT, hr, 0);
    return hr;
  }

//   ULONG cb = pSample->GetActualDataLength();
//   if(rtStart + cb != rtEnd)
//   {
//     DbgBreak("start, stop, and size don't mathc");
//     return E_INVALIDARG;
//   }

  ULONG cb = (ULONG)(rtEnd - rtStart);
  BYTE *pb;
  
  hr = pSample->GetPointer(&pb);
  ASSERT(hr == S_OK);

  pSample->AddRef();
  hr = m_pFwf->AsyncWrite(rtStart, cb, pb, Callback, pSample);
  if(hr != S_OK)
  {
    DbgLog((LOG_ERROR, 5, TEXT("CBaseWriterInput: AsyncWrite returned %08x"),
            hr));

    // the call back is called only if AsyncWrite succeeds.
    pSample->Release();

    if(FAILED(hr))
    {
      DbgLog((LOG_ERROR, 1, TEXT("fw Receive: signalling error")));
      m_pFwf->m_fErrorSignaled = TRUE;
      m_pFwf->NotifyEvent(EC_ERRORABORT, hr, 0);
    }
  }

  return hr;
}

STDMETHODIMP CBaseWriterInput::EndOfStream()
{
  return m_pFwf->EndOfStream();
}


STDMETHODIMP
CBaseWriterInput::NotifyAllocator(
  IMemAllocator * pAllocator,
  BOOL bReadOnly)
{
  HRESULT hr = CBaseInputPin::NotifyAllocator(pAllocator, bReadOnly);
  if(FAILED(hr))
    return hr;
  else
    return m_pFwf->NotifyAllocator(pAllocator, bReadOnly);
}


void CBaseWriterInput::Callback(void *pMisc)
{
  IMediaSample *pSample = (IMediaSample *)pMisc;
  pSample->Release();
}
=== C:/Users/treeman/Desktop/windows nt source code\Source\Win2K3\NT\multimedia\dshow\h\decibels.h ===
//--------------------------------------------------------------------------;
//
//  File: decibels.cpp
//
//  Copyright (c) 1995 - 1996  Microsoft Corporation.  All Rights Reserved.
//
//  Abstract:
//
//       utilities for converting volume/pan in decibel units to/from
//       the 0-0xffff (0-1000) range used by waveOutSetVolume (MCI) etc
//
//  Contents:
//
//  History:
//      06/15/95	SteveDav    plagiarised from Direct Sound
//
//--------------------------------------------------------------------------;

#ifdef __cplusplus
extern "C" {
#endif // __cplusplus

#ifndef _AMOVIE_DB_
#define AMOVIEAPI_DB   DECLSPEC_IMPORT
#else
#define AMOVIEAPI_DB
#endif

AMOVIEAPI_DB LONG WINAPI AmpFactorToDB( DWORD dwFactor );
AMOVIEAPI_DB DWORD WINAPI DBToAmpFactor( LONG lDB );

#ifdef __cplusplus
}
#endif // __cplusplus

#define AX_MIN_VOLUME -10000
#define AX_QUARTER_VOLUME -1200
#define AX_HALF_VOLUME -600
#define AX_THREEQUARTERS_VOLUME -240
#define AX_MAX_VOLUME 0

#define AX_BALANCE_LEFT -10000
#define AX_BALANCE_RIGHT 10000
#define AX_BALANCE_NEUTRAL 0
=== C:/Users/treeman/Desktop/windows nt source code\Source\Win2K3\NT\multimedia\dshow\h\amutil.h ===
//  Copyright (c) 1992 - 1997  Microsoft Corporation.  All Rights Reserved.
/*  Dynamic arrays */

#ifndef __AMUTIL_H__
#define __AMUTIL_H__

/*  Dynamic array support */
template <class _TInterface, class _TArray>
class CDynamicArray
{
public:
    CDynamicArray(int iIncrement) : m_pArray(NULL),
                      m_nElements(0),
                      m_iIncrement(iIncrement),
                      m_nSize(0) {}
    CDynamicArray() : m_pArray(NULL),
                      m_nElements(0),
                      m_iIncrement(4),
                      m_nSize(0) {}
    ~CDynamicArray() { delete [] m_pArray; }

    _TInterface Element(int i) const {
        _ASSERTE(i < m_nElements);
        return m_pArray[i];
    }

    _TInterface operator [] (int i)
    {
        return m_pArray[i];
    }

    int Size() const {
        return m_nElements;
    }

    BOOL Add(_TInterface Element)
    {
        _ASSERTE(m_nSize >= m_nElements);
        if (m_nSize == m_nElements) {
            _TArray *pNewArray = new _TArray[m_nSize + m_iIncrement];
            if (pNewArray == NULL) {
                return FALSE;
            }
            for (int i = 0; i < m_nElements; i++) {
                pNewArray[i] = m_pArray[i];
            }
            delete [] m_pArray;
            m_pArray = pNewArray;
            m_nSize = m_nSize + m_iIncrement;
        }
        m_pArray[m_nElements++] = Element;
        return TRUE;
    }
    BOOL Remove(_TInterface Element)
    {
        for (int i = 0; m_pArray[i] != Element; i++ ) {
            if (i >= m_nElements) {
                return FALSE;
            }
        }
        Remove(i);
        return TRUE;
    }
    void Remove(int i)
    {
        _ASSERTE(i < m_nElements);
        m_nElements--;
        for (; i < m_nElements; i++) {
            m_pArray[i] = m_pArray[i + 1];
        }
        m_pArray[m_nElements] = NULL;
    }
    void RemoveAll()
    {
        for (int i = 0; i < m_nElements; i++) {
            m_pArray[i] = NULL;
        }
        m_nElements = 0;
    }

private:
    _TArray   *m_pArray;
    int       m_nSize;
    int       m_nElements;
    const int m_iIncrement;
};

template <class Base, const IID *piid, class T>
class CAMEnumInterfaceImpl :
    public Base,
    public CDynamicArray<T*, CComPtr<T> >
{
public:
    CAMEnumInterfaceImpl() : m_iter(0) {}

    /*  The actual interface we support */
    STDMETHOD(Next)(ULONG celt, T** rgelt, ULONG* pceltFetched);
    STDMETHOD(Skip)(ULONG celt);
    STDMETHOD(Reset)(void){m_iter = 0;return S_OK;}
    STDMETHOD(Clone)(Base** ppEnum);

    int m_iter;
};

template <class Base, const IID* piid, class T>
STDMETHODIMP CAMEnumInterfaceImpl<Base, piid, T>::Next(ULONG celt, T** rgelt,
    ULONG* pceltFetched)
{
    if (rgelt == NULL || (celt != 1 && pceltFetched == NULL))
        return E_POINTER;
    ULONG nRem = (ULONG)(Size() - m_iter);
    HRESULT hRes = S_OK;
    if (nRem < celt)
        hRes = S_FALSE;
    ULONG nMin = min(celt, nRem);
    if (pceltFetched != NULL)
        *pceltFetched = nMin;
    while(nMin--) {
        Element(m_iter)->AddRef();
        *(rgelt++) = Element(m_iter++);
    }
    return hRes;
}

template <class Base, const IID* piid, class T>
STDMETHODIMP CAMEnumInterfaceImpl<Base, piid, T>::Skip(ULONG celt)
{
    m_iter += celt;
    if (m_iter < Size())
        return S_OK;
    m_iter = Size();
    return S_FALSE;
}

template <class Base, const IID* piid, class T>
STDMETHODIMP CAMEnumInterfaceImpl<Base, piid, T>::Clone(Base** ppEnum)
{
    typedef CComObject<CAMEnumInterface<Base, piid, T> > _class;
    HRESULT hRes = E_POINTER;
    if (ppEnum != NULL)
    {
        _class* p = NULL;
        ATLTRY(p = new _class)
        if (p == NULL)
        {
            *ppEnum = NULL;
            hRes = E_OUTOFMEMORY;
        }
        else
        {
            for (int i = 0; i < Size(); i++) {
                if (!p->Add(Element(i))) {
                    break;
                }
            }
            if (i != Size()) {
                delete p;
                hRes = E_OUTOFMEMORY;
                *ppEnum = NULL;
            }
            else
            {
                p->m_iter = m_iter;
                hRes = p->_InternalQueryInterface(*piid, (void**)ppEnum);
                if (FAILED(hRes))
                    delete p;
            }
        }
    }
    return hRes;
}

template <class Base, const IID* piid, class T>
class CAMEnumInterface : public CAMEnumInterfaceImpl<Base, piid, T>, public CComObjectRoot
{
public:
    typedef CComObjectRoot _BaseClass ;
    typedef CAMEnumInterface<Base, piid, T> _CComEnum;
    typedef CAMEnumInterfaceImpl<Base, piid, T> _CComEnumBase;

#ifdef DEBUG
    ULONG InternalAddRef()
    {
        return _BaseClass::InternalAddRef();
    }
    ULONG InternalRelease()
    {
        return _BaseClass::InternalRelease();
    }
#endif
    BEGIN_COM_MAP(_CComEnum)
        COM_INTERFACE_ENTRY_IID(*piid, _CComEnumBase)
    END_COM_MAP()
};

#ifndef __WXUTIL__

// wrapper for whatever critical section we have
class CCritSec {

    // make copy constructor and assignment operator inaccessible

    CCritSec(const CCritSec &refCritSec);
    CCritSec &operator=(const CCritSec &refCritSec);

    CRITICAL_SECTION m_CritSec;

public:
    CCritSec() {
	InitializeCriticalSection(&m_CritSec);
    };

    ~CCritSec() {
	DeleteCriticalSection(&m_CritSec);
    };

    void Lock() {
	EnterCriticalSection(&m_CritSec);
    };

    void Unlock() {
	LeaveCriticalSection(&m_CritSec);
    };
};

// locks a critical section, and unlocks it automatically
// when the lock goes out of scope
class CAutoLock {

    // make copy constructor and assignment operator inaccessible

    CAutoLock(const CAutoLock &refAutoLock);
    CAutoLock &operator=(const CAutoLock &refAutoLock);

protected:
    CCritSec * m_pLock;

public:
    CAutoLock(CCritSec * plock)
    {
        m_pLock = plock;
        m_pLock->Lock();
    };

    ~CAutoLock() {
        m_pLock->Unlock();
    };
};

// locks a critical section, and unlocks it automatically
// when the lock goes out of scope
class CAutoObjectLock {

    // make copy constructor and assignment operator inaccessible

    CAutoObjectLock(const CAutoObjectLock &refAutoLock);
    CAutoObjectLock &operator=(const CAutoObjectLock &refAutoLock);

protected:
    CComObjectRoot * m_pObject;

public:
    CAutoObjectLock(CComObjectRoot * pobject)
    {
        m_pObject = pobject;
        m_pObject->Lock();
    };

    ~CAutoObjectLock() {
        m_pObject->Unlock();
    };
};

#define AUTO_CRIT_LOCK CAutoObjectLock lck(this);

#ifdef _DEBUG
#define EXECUTE_ASSERT(_x_) _ASSERTE(_x_)
#else
#define EXECUTE_ASSERT(_x_) _x_
#endif


#endif

#endif // __AMUTIL_H__
=== C:/Users/treeman/Desktop/windows nt source code\Source\Win2K3\NT\multimedia\dshow\h\checkbmi.h ===
//  Copyright (c) 1992 - 1997  Microsoft Corporation.  All Rights Reserved.

#ifndef _CHECKBMI_H_
#define _CHECKBMI_H_

#ifdef __cplusplus
extern "C" {
#endif

//  Helper
inline BOOL MultiplyCheckOverflow(DWORD a, DWORD b, DWORD *pab) {
    *pab = a * b;
    if ((a == 0) || (((*pab) / a) == b)) {
        return TRUE;
    }
    return FALSE;
}


//  Checks if the fields in a BITMAPINFOHEADER won't generate
//  overlows and buffer overruns
//  This is not a complete check and does not guarantee code using this structure will be secure
//  from attack
//  Bugs this is guarding against:
//        1.  Total structure size calculation overflowing
//        2.  biClrUsed > 256 for 8-bit palettized content
//        3.  Total bitmap size in bytes overflowing
//        4.  biSize < size of the base structure leading to accessessing random memory
//        5.  Total structure size exceeding know size of data
//

inline BOOL ValidateBitmapInfoHeader(
    const BITMAPINFOHEADER *pbmi,   // pointer to structure to check
    DWORD cbSize                    // size of memory block containing structure
)
{
    DWORD dwWidthInBytes;
    DWORD dwBpp;
    DWORD dwWidthInBits;
    DWORD dwHeight;
    DWORD dwSizeImage;
    DWORD dwClrUsed;

    // Reject bad parameters - do the size check first to avoid reading bad memory
    if (cbSize < sizeof(BITMAPINFOHEADER) ||
        pbmi->biSize < sizeof(BITMAPINFOHEADER) ||
        pbmi->biSize > 4096) {
        return FALSE;
    }

    // Use bpp of 32 for validating against further overflows if not set for compressed format
    dwBpp = 32;

    // Strictly speaking abs can overflow so cast explicitly to DWORD
    dwHeight = (DWORD)abs(pbmi->biHeight);

    if (!MultiplyCheckOverflow(dwBpp, (DWORD)pbmi->biWidth, &dwWidthInBits)) {
        return FALSE;
    }

    //  Compute correct width in bytes - rounding up to 4 bytes
    dwWidthInBytes = (dwWidthInBits / 8 + 3) & ~3;

    if (!MultiplyCheckOverflow(dwWidthInBytes, dwHeight, &dwSizeImage)) {
        return FALSE;
    }

    // Fail if total size is 0 - this catches indivual quantities being 0
    // Also don't allow huge values > 1GB which might cause arithmetic
    // errors for users
    if (dwSizeImage > 0x40000000 ||
        pbmi->biSizeImage > 0x40000000) {
        return FALSE;
    }

    //  Fail if biClrUsed looks bad
    if (pbmi->biClrUsed > 256) {
        return FALSE;
    }

    if (pbmi->biClrUsed == 0 && dwBpp <= 8) {
        dwClrUsed = (1 << dwBpp);
    } else {
        dwClrUsed = pbmi->biClrUsed;
    }

    //  Check total size
    if (cbSize < pbmi->biSize + dwClrUsed * sizeof(RGBQUAD) +
                 (pbmi->biCompression == BI_BITFIELDS ? 3 * sizeof(DWORD) : 0)) {
        return FALSE;
    }

    return TRUE;
}

#ifdef __cplusplus
}
#endif

#endif // _CHECKBMI_H_
=== C:/Users/treeman/Desktop/windows nt source code\Source\Win2K3\NT\multimedia\dshow\filterus\writer\fw.h ===
// Copyright (c) 1996 - 1999  Microsoft Corporation.  All Rights Reserved.
// base classes for filter which supports asynchronous writes to
// media via IMemInputPin. Also support for IStream

typedef void (*FileIoCallback)(void *pCallbackArg);

class CBaseWriterFilter;

class CBaseWriterInput :
  public CBaseInputPin
{
public:

  STDMETHODIMP NonDelegatingQueryInterface(REFIID riid, void ** pv);
  
  CBaseWriterInput(
    TCHAR *pObjectName,         // Object description
    CBaseWriterFilter *pFwf,    // Owning filter who knows about pins
    CCritSec *pLock,            // Object who implements the lock
    HRESULT *phr);              // General OLE return code

  // CBasePin
  HRESULT CheckMediaType(const CMediaType *);
  STDMETHODIMP BeginFlush(void);
  STDMETHODIMP EndFlush(void);

  // IMemInputPin... derived class may want these
  STDMETHODIMP GetAllocator(IMemAllocator ** ppAllocator);
  STDMETHODIMP GetAllocatorRequirements(ALLOCATOR_PROPERTIES *pProps);

  STDMETHODIMP Receive(IMediaSample *pSample);
  STDMETHODIMP ReceiveCanBlock() { return S_OK;}
  STDMETHODIMP EndOfStream();
  STDMETHODIMP SignalEos();

  virtual STDMETHODIMP NotifyAllocator(
    IMemAllocator * pAllocator,
    BOOL bReadOnly);
                                        
private:

  CBaseWriterFilter *m_pFwf;
  static void Callback(void *pMisc);
};

class CBaseWriterFilter :
  public CBaseFilter,
  public IAMFilterMiscFlags
{
public:
  
  virtual HRESULT Open() PURE;  // needed to get alignment
  virtual HRESULT Close() PURE; // needed to return error value
  virtual HRESULT GetAlignReq(ULONG *pcbAlign) PURE;

  virtual HRESULT AsyncWrite(
    const DWORDLONG dwlFileOffset,
    const ULONG cb,
    BYTE *pb,
    FileIoCallback fnCallback,
    void *pCallbackArg) PURE;

  DECLARE_IUNKNOWN;
  virtual STDMETHODIMP NonDelegatingQueryInterface(REFIID riid, void ** ppv);

  // should return a new IStream (with its own seek ptr)
  virtual STDMETHODIMP CreateIStream(void **ppIStream) PURE;
  
   CBaseWriterFilter(LPUNKNOWN pUnk, HRESULT *pHr);
  ~CBaseWriterFilter();
                       
  CBasePin* GetPin(int n);
  int GetPinCount();

  virtual STDMETHODIMP NotifyAllocator(
    IMemAllocator * pAllocator,
    BOOL bReadOnly) { return S_OK; }

  // messy to override Pause
  virtual STDMETHODIMP CanPause() { return S_OK; }

  STDMETHODIMP Pause();
  STDMETHODIMP Stop();
  STDMETHODIMP Run(REFERENCE_TIME rtStart);

  STDMETHODIMP EndOfStream();

protected:

  // only the major & minor types are used. the media type we accept
  // or null media types. set by derived class
  CMediaType m_mtSet;

  CCritSec m_cs;

  CBaseWriterInput m_inputPin;

private:

  // report only one error to graph
  BOOL m_fErrorSignaled;

  // EOS signaled. or EOS needs to be signaled on Run()
  BOOL m_fEosSignaled;

  friend class CBaseWriterInput;

  STDMETHODIMP_(ULONG) GetMiscFlags(void) { return AM_FILTER_MISC_FLAGS_IS_RENDERER; }
};
=== C:/Users/treeman/Desktop/windows nt source code\Source\Win2K3\NT\multimedia\dshow\h\dynlink.h ===
// Copyright (c) 1996 - 1999  Microsoft Corporation.  All Rights Reserved.

#ifndef __DYNLINK_H__
#define __DYNLINK_H__

// Add DYNLINKAVI to the class definition statement
// for all classes that use AVI/VFW function
// to enable dynamic linking to AVI.  That, and #includ'ing this file
// should be the only thing you need to do
//
// For example:
//    class CAVIDec : public CTransformFilter   DYNLINKAVI   DYNLINKVFW
//
// In the case where the filter is being built into its own DLL dynamic
// linking is not enabled and DYNLINKAVI is #define'd to nothing.
//
// If the class in which you want to use dynamic linking does not
// inherit from anything else use _DYNLINKAVI or _DYNLINKVFW
//
// For example:
//    class CNoInherit : _DYNLINKAVI
// or
//    class CNoInherit : _DYNLINKVFW
// or
//    class CNoInterit : _DYNLINKVFW    DYNLINKAVI  //etc...
//

#define NODRAWDIB
#define NOAVIFMT
#include <vfw.h>		// we need the avi definitions
#include <urlmon.h>

#ifdef FILTER_DLL

#define DYNLINKAVI
#define DYNLINKVFW
#define DYNLINKACM
#define DYNLINKURLMON
#define _DYNLINKAVI
#define _DYNLINKVFW
#define _DYNLINKACM
#define _DYNLINKURLMON
#else

// Add DYNLINKAVI at the end of the class definition statement
// for all classes that use AVI/VFW function
// to enable dynamic linking to AVI.  That, and #includ'ing this file
// should be the only thing you need to do

// define string that will bind dynamic linking to the class definition
#define DYNLINKAVI  , CAVIDynLink
#define DYNLINKVFW  , CVFWDynLink
#define DYNLINKACM  , CACMDynLink
#define DYNLINKURLMON , CURLMonDynLink

// for those classes that have no inheritance and still want dynamic linking
#define _DYNLINKAVI  CAVIDynLink
#define _DYNLINKVFW  CVFWDynLink
#define _DYNLINKACM  CACMDynLink
#define _DYNLINKURLMON CURLMonDynLink

//
// typedef the AVIFILE API set that we redirect
//

typedef HRESULT  (STDAPICALLTYPE *pAVIFileOpenW )(PAVIFILE FAR * ppfile, LPCWSTR szFile, UINT uMode, LPCLSID lpHandler);
typedef HRESULT  (STDAPICALLTYPE *pAVIStreamRead)(PAVISTREAM pavi, LONG lStart, LONG lSamples, LPVOID lpBuffer, LONG cbBuffer, LONG FAR * plBytes, LONG FAR * plSamples);
typedef LONG     (STDAPICALLTYPE *pAVIStreamStart)       (PAVISTREAM pavi);
typedef LONG     (STDAPICALLTYPE *pAVIStreamLength)      (PAVISTREAM pavi);
typedef LONG     (STDAPICALLTYPE *pAVIStreamTimeToSample)(PAVISTREAM pavi, LONG lTime);
typedef LONG     (STDAPICALLTYPE *pAVIStreamSampleToTime)(PAVISTREAM pavi, LONG lSample);
typedef HRESULT  (STDAPICALLTYPE *pAVIStreamBeginStreaming)(PAVISTREAM pavi, LONG lStart, LONG lEnd, LONG lRate);
typedef HRESULT  (STDAPICALLTYPE *pAVIStreamEndStreaming)(PAVISTREAM pavi);
typedef LONG     (STDAPICALLTYPE *pAVIStreamFindSample)(PAVISTREAM pavi, LONG lPos, LONG lFlags);

#undef AVIStreamEnd  // sigh... nasty AVI macro

//
// Class to link dynamically to AVIFIL32.DLL entry points
//

class CAVIDynLink {

private:
    static HMODULE m_hAVIFile32;  	// handle to AVIFIL32
    static LONG    m_dynlinkCount;     	// instance count for this process
    static CRITICAL_SECTION m_LoadAVILock;      // serialise constructor/destructor

public:
    static  void  CAVIDynLinkLoad() {
	InitializeCriticalSection(&CAVIDynLink::m_LoadAVILock);      // serialise constructor/destructor
    }
    static  void  CAVIDynLinkUnload() {
	DeleteCriticalSection(&CAVIDynLink::m_LoadAVILock);      // serialise constructor/destructor
    }

    static  void  AVIFileInit(void);
    static  void  AVIFileExit(void);
    static  HRESULT  AVIFileOpenW       (PAVIFILE FAR * ppfile, LPCWSTR szFile,
			  UINT uMode, LPCLSID lpHandler);

    static HRESULT  AVIStreamRead(PAVISTREAM pavi,
    		      LONG lStart,
    		      LONG lSamples,
    		      LPVOID lpBuffer,
    		      LONG cbBuffer,
    		      LONG FAR * plBytes,
    		      LONG FAR * plSamples)
    {
    return(pavi->Read(lStart, lSamples, lpBuffer, cbBuffer, plBytes, plSamples));
    }

    static LONG  AVIStreamStart(PAVISTREAM pavi)
    {
        AVISTREAMINFOW aviStreamInfo;
        HRESULT hr;
        hr = pavi->Info(&aviStreamInfo, sizeof(aviStreamInfo));
        if (hr!=NOERROR) {
	    aviStreamInfo.dwStart=0;
        }
        return(LONG)aviStreamInfo.dwStart;
        //return(((pAVIStreamStart)aAVIEntries[indxAVIStreamStart])(pavi));
    }

    static LONG  AVIStreamLength(PAVISTREAM pavi)
    {
        AVISTREAMINFOW	aviStreamInfo;
        HRESULT		hr;
        hr = pavi->Info(&aviStreamInfo, sizeof(aviStreamInfo));
        if (hr!=NOERROR) {
	    aviStreamInfo.dwLength=1;
        }
        return (LONG)aviStreamInfo.dwLength;
        //return(((pAVIStreamLength)aAVIEntries[indxAVIStreamLength])(pavi));
    }

    /*static*/  LONG  AVIStreamTimeToSample (PAVISTREAM pavi, LONG lTime);
    /*static*/  LONG  AVIStreamSampleToTime (PAVISTREAM pavi, LONG lSample);
    /*static*/  HRESULT  AVIStreamBeginStreaming(PAVISTREAM pavi, LONG lStart, LONG lEnd, LONG lRate);
    /*static*/  HRESULT  AVIStreamEndStreaming(PAVISTREAM pavi);

    static LONG  AVIStreamFindSample(PAVISTREAM pavi, LONG lPos, LONG lFlags)
    {
        // The use of AVIStreamFindSample within Quartz ALWAYS set the type
        // and direction
        ASSERT(lFlags & FIND_TYPE);
        ASSERT(lFlags & FIND_DIR);

        return(pavi->FindSample(lPos, lFlags));
        //return(((pAVIStreamFindSample)aAVIEntries[indxAVIStreamFindSample])(pavi));
    }

    static LONG AVIStreamEnd(PAVISTREAM pavi)
    {
        AVISTREAMINFOW aviStreamInfo;
        HRESULT hr;
        hr = pavi->Info(&aviStreamInfo, sizeof(aviStreamInfo));
        if (hr!=NOERROR) {
	    aviStreamInfo.dwStart=0;
	    aviStreamInfo.dwLength=1;
        }
        return (LONG)aviStreamInfo.dwLength + (LONG)aviStreamInfo.dwStart;
        //return(((pAVIStreamStart)aAVIEntries[indxAVIStreamStart])(pavi)
        //    + ((pAVIStreamLength)aAVIEntries[indxAVIStreamLength])(pavi));
    }


    CAVIDynLink();
    ~CAVIDynLink();

private:

    // make copy and assignment inaccessible
    CAVIDynLink(const CAVIDynLink &refAVIDynLink);
    CAVIDynLink &operator=(const CAVIDynLink &refAVIDynLink);
};

//
// Class for dynamic linking to MSVFW32.DLL
//
// Most of the IC API set are macros that call ICSendMessage.  There are
// a couple of awkward ones that we expand inline.
//


//
// Dynamically loaded array of entry points
//
extern FARPROC aVFWEntries[];

//
// List of index entries into the array for each redirected API
//
#define indxICClose                  0
#define indxICSendMessage            1
#define indxICLocate                 2
#define indxICOpen                   3
#define indxICInfo		     4
#define indxICGetInfo		     5


//
// typedef the API set that we redirect
//

typedef LRESULT (WINAPI *pICClose)(HIC hic);
typedef HIC     (WINAPI *pICLocate)(DWORD fccType, DWORD fccHandler, LPBITMAPINFOHEADER lpbiIn, LPBITMAPINFOHEADER lpbiOut, WORD wFlags);
typedef LRESULT (WINAPI *pICSendMessage)(HIC hic, UINT msg, DWORD_PTR dw1, DWORD_PTR dw2);
typedef HIC     (VFWAPI *pICOpen)(DWORD fccType, DWORD fccHandler, UINT wMode);
typedef BOOL    (VFWAPI *pICInfo)(DWORD fccType, DWORD fccHandler, ICINFO FAR* lpicinfo);
typedef BOOL    (VFWAPI *pICGetInfo)(HIC hic, ICINFO FAR* lpicinfo, DWORD cb);

class CVFWDynLink {

private:
    static HMODULE m_hVFW;        	// handle to MSVFW32
    static LONG    m_vfwlinkCount;     	// instance count for this process
    static CRITICAL_SECTION m_LoadVFWLock;      // serialise constructor/destructor

public:
    static void CVFWDynLinkLoad()
    {
	InitializeCriticalSection(&m_LoadVFWLock);      // serialise constructor/destructor
    }
    static void CVFWDynLinkUnload()
    {
	DeleteCriticalSection(&m_LoadVFWLock);      // serialise constructor/destructor
    }

    static DWORD_PTR ICDecompress(
	HIC                 hic,
	DWORD               dwFlags,    // flags (from AVI index...)
	LPBITMAPINFOHEADER  lpbiFormat, // BITMAPINFO of compressed data
					// biSizeImage has the chunk size
					// biCompression has the ckid (AVI only)
	LPVOID              lpData,     // data
	LPBITMAPINFOHEADER  lpbi,       // DIB to decompress to
	LPVOID              lpBits)
    {
	ICDECOMPRESS icd;
	icd.dwFlags    = dwFlags;
	icd.lpbiInput  = lpbiFormat;
	icd.lpInput    = lpData;

	icd.lpbiOutput = lpbi;
	icd.lpOutput   = lpBits;
	icd.ckid       = 0;	
	return ICSendMessage(hic, ICM_DECOMPRESS, (DWORD_PTR)(LPVOID)&icd, sizeof(ICDECOMPRESS));
    }

    static LRESULT CVFWDynLink::ICClose(HIC hic)
    {
        return((((pICClose)aVFWEntries[indxICClose]))(hic));
    }

    static HIC ICLocate(DWORD fccType, DWORD fccHandler, LPBITMAPINFOHEADER lpbiIn, LPBITMAPINFOHEADER lpbiOut, WORD wFlags)
    {
        return((((pICLocate)aVFWEntries[indxICLocate]))(fccType, fccHandler, lpbiIn, lpbiOut, wFlags));
    }


    static LRESULT ICSendMessage(HIC hic, UINT msg, DWORD_PTR dw1, DWORD_PTR dw2)
    {
        return((((pICSendMessage)aVFWEntries[indxICSendMessage]))(hic, msg, dw1, dw2));
    }

    static HIC     ICOpen(DWORD fccType, DWORD fccHandler, UINT wMode)
    {
        return((((pICOpen)aVFWEntries[indxICOpen]))(fccType, fccHandler, wMode));
    }

    static BOOL    ICInfo(DWORD fccType, DWORD fccHandler, ICINFO* lpicinfo)
    {
        return((((pICInfo)aVFWEntries[indxICInfo]))(fccType, fccHandler, lpicinfo));
    }

    static BOOL    ICGetInfo(HIC hic, ICINFO* lpicinfo, DWORD cb)
    {
        return((((pICGetInfo)aVFWEntries[indxICGetInfo]))(hic, lpicinfo, cb));
    }

    static LRESULT ICDecompressEx(
            HIC hic,
            DWORD dwFlags,
            LPBITMAPINFOHEADER lpbiSrc,
            LPVOID lpSrc,
            int xSrc,int ySrc,int dxSrc,int dySrc,LPBITMAPINFOHEADER lpbiDst,
            LPVOID lpDst,
            int xDst,int yDst,int dxDst,int dyDst)
    {
        ICDECOMPRESSEX ic;

        ic.dwFlags = dwFlags;
        ic.lpbiSrc = lpbiSrc;
        ic.lpSrc = lpSrc;
        ic.xSrc = xSrc;
        ic.ySrc = ySrc;
        ic.dxSrc = dxSrc;
        ic.dySrc = dySrc;
        ic.lpbiDst = lpbiDst;
        ic.lpDst = lpDst;
        ic.xDst = xDst;
        ic.yDst = yDst;
        ic.dxDst = dxDst;
        ic.dyDst = dyDst;

        // note that ICM swaps round the length and pointer
        // length in lparam2, pointer in lparam1
        return ICSendMessage(hic, ICM_DECOMPRESSEX, (DWORD_PTR)&ic, sizeof(ic));
    }

    static LRESULT ICDecompressExQuery(
            HIC hic,
            DWORD dwFlags,
            LPBITMAPINFOHEADER lpbiSrc,
            LPVOID lpSrc,
            int xSrc,int ySrc,int dxSrc,int dySrc,
            LPBITMAPINFOHEADER lpbiDst,
            LPVOID lpDst,
            int xDst,int yDst,int dxDst,int dyDst)
    {
        ICDECOMPRESSEX ic;

        ic.dwFlags = dwFlags;
        ic.lpbiSrc = lpbiSrc;
        ic.lpSrc = lpSrc;
        ic.xSrc = xSrc;
        ic.ySrc = ySrc;
        ic.dxSrc = dxSrc;
        ic.dySrc = dySrc;
        ic.lpbiDst = lpbiDst;
        ic.lpDst = lpDst;
        ic.xDst = xDst;
        ic.yDst = yDst;
        ic.dxDst = dxDst;
        ic.dyDst = dyDst;

        // note that ICM swaps round the length and pointer
        // length in lparam2, pointer in lparam1
        return ICSendMessage(hic, ICM_DECOMPRESSEX_QUERY, (DWORD_PTR)&ic, sizeof(ic));
    }

    static LRESULT ICDecompressExBegin(
            HIC hic,
            DWORD dwFlags,
            LPBITMAPINFOHEADER lpbiSrc,
            LPVOID lpSrc,
            int xSrc,int ySrc,int dxSrc,int dySrc,
            LPBITMAPINFOHEADER lpbiDst,
            LPVOID lpDst,
            int xDst,int yDst,int dxDst,int dyDst)
    {
        ICDECOMPRESSEX ic;

        ic.dwFlags = dwFlags;
        ic.lpbiSrc = lpbiSrc;
        ic.lpSrc = lpSrc;
        ic.xSrc = xSrc;
        ic.ySrc = ySrc;
        ic.dxSrc = dxSrc;
        ic.dySrc = dySrc;
        ic.lpbiDst = lpbiDst;
        ic.lpDst = lpDst;
        ic.xDst = xDst;
        ic.yDst = yDst;
        ic.dxDst = dxDst;
        ic.dyDst = dyDst;

        // note that ICM swaps round the length and pointer
        // length in lparam2, pointer in lparam1
        return ICSendMessage(hic, ICM_DECOMPRESSEX_BEGIN, (DWORD_PTR)&ic, sizeof(ic));
    }

    static DWORD_PTR VFWAPIV ICDrawBegin(
        HIC                 hic,
        DWORD               dwFlags,        // flags
        HPALETTE            hpal,           // palette to draw with
        HWND                hwnd,           // window to draw to
        HDC                 hdc,            // HDC to draw to
        int                 xDst,           // destination rectangle
        int                 yDst,
        int                 dxDst,
        int                 dyDst,
        LPBITMAPINFOHEADER  lpbi,           // format of frame to draw
        int                 xSrc,           // source rectangle
        int                 ySrc,
        int                 dxSrc,
        int                 dySrc,
        DWORD               dwRate,         // frames/second = (dwRate/dwScale)
        DWORD               dwScale)
    {
        ICDRAWBEGIN icdraw;
        icdraw.dwFlags   =  dwFlags;
        icdraw.hpal      =  hpal;
        icdraw.hwnd      =  hwnd;
        icdraw.hdc       =  hdc;
        icdraw.xDst      =  xDst;
        icdraw.yDst      =  yDst;
        icdraw.dxDst     =  dxDst;
        icdraw.dyDst     =  dyDst;
        icdraw.lpbi      =  lpbi;
        icdraw.xSrc      =  xSrc;
        icdraw.ySrc      =  ySrc;
        icdraw.dxSrc     =  dxSrc;
        icdraw.dySrc     =  dySrc;
        icdraw.dwRate    =  dwRate;
        icdraw.dwScale   =  dwScale;

        return ICSendMessage(hic, ICM_DRAW_BEGIN, (DWORD_PTR)(LPVOID)&icdraw, sizeof(ICDRAWBEGIN));
    }

    static DWORD_PTR VFWAPIV ICDraw(
        HIC                 hic,
        DWORD               dwFlags,        // flags
        LPVOID	            lpFormat,       // format of frame to decompress
        LPVOID              lpData,         // frame data to decompress
        DWORD               cbData,         // size in bytes of data
        LONG                lTime)          // time to draw this frame (see drawbegin dwRate and dwScale)
    {
        ICDRAW  icdraw;
        icdraw.dwFlags  =   dwFlags;
        icdraw.lpFormat =   lpFormat;
        icdraw.lpData   =   lpData;
        icdraw.cbData   =   cbData;
        icdraw.lTime    =   lTime;

        return ICSendMessage(hic, ICM_DRAW, (DWORD_PTR)(LPVOID)&icdraw, sizeof(ICDRAW));
    }

    CVFWDynLink();
    ~CVFWDynLink();

private:

    // make copy and assignment inaccessible
    CVFWDynLink(const CVFWDynLink &refVFWDynLink);
    CVFWDynLink &operator=(const CVFWDynLink &refVFWDynLink);
};


//
// Class for dynamic linking to MSACM32.DLL
//


//
// Dynamically loaded array of entry points
//
extern FARPROC aACMEntries[];

//
// List of index entries into the array for each redirected API
//
#define indxacmStreamConvert		0
#define indxacmStreamSize		1
#define indxacmStreamPrepareHeader	2
#define indxacmMetrics			3
#define indxacmStreamUnprepareHeader	4
#define indxacmStreamOpen		5
#define indxacmFormatSuggest		6
#define indxacmStreamClose		7
#ifdef UNICODE
# define indxacmFormatEnumW		8
#else
# define indxacmFormatEnumA		8
#endif


//
// typedef the API set that we redirect
//

typedef MMRESULT (ACMAPI *pacmStreamConvert)(HACMSTREAM has, LPACMSTREAMHEADER pash, DWORD fdwConvert);
typedef MMRESULT (ACMAPI *pacmStreamSize)
(
    HACMSTREAM              has,
    DWORD                   cbInput,
    LPDWORD                 pdwOutputBytes,
    DWORD                   fdwSize
);
typedef MMRESULT (ACMAPI *pacmStreamPrepareHeader)
(
    HACMSTREAM          has,
    LPACMSTREAMHEADER   pash,
    DWORD               fdwPrepare
);
typedef MMRESULT (ACMAPI *pacmMetrics)
(
    HACMOBJ                 hao,
    UINT                    uMetric,
    LPVOID                  pMetric
);
typedef MMRESULT (ACMAPI *pacmStreamUnprepareHeader)
(
    HACMSTREAM          has,
    LPACMSTREAMHEADER   pash,
    DWORD               fdwUnprepare
);
typedef MMRESULT (ACMAPI *pacmStreamOpen)
(
    LPHACMSTREAM            phas,       // pointer to stream handle
    HACMDRIVER              had,        // optional driver handle
    LPWAVEFORMATEX          pwfxSrc,    // source format to convert
    LPWAVEFORMATEX          pwfxDst,    // required destination format
    LPWAVEFILTER            pwfltr,     // optional filter
    DWORD_PTR               dwCallback, // callback
    DWORD_PTR               dwInstance, // callback instance data
    DWORD                   fdwOpen     // ACM_STREAMOPENF_* and CALLBACK_*
);
typedef MMRESULT (ACMAPI *pacmFormatSuggest)
(
    HACMDRIVER          had,
    LPWAVEFORMATEX      pwfxSrc,
    LPWAVEFORMATEX      pwfxDst,
    DWORD               cbwfxDst,
    DWORD               fdwSuggest
);
typedef MMRESULT (ACMAPI *pacmStreamClose)
(
    HACMSTREAM              has,
    DWORD                   fdwClose
);
typedef MMRESULT (ACMAPI *pacmFormatEnumA)
(
    HACMDRIVER              had,
    LPACMFORMATDETAILSA     pafd,
    ACMFORMATENUMCBA        fnCallback,
    DWORD_PTR               dwInstance, 
    DWORD                   fdwEnum
);

typedef MMRESULT (ACMAPI *pacmFormatEnumW)
(
    HACMDRIVER              had,
    LPACMFORMATDETAILSW     pafd,
    ACMFORMATENUMCBW        fnCallback,
    DWORD_PTR               dwInstance,
    DWORD                   fdwEnum
);


class CACMDynLink {

private:
    static HMODULE m_hACM;        	// handle to MSVFW32
    static LONG    m_ACMlinkCount;     	// instance count for this process
    static CRITICAL_SECTION m_LoadACMLock;      // serialise constructor/destructor

public:
    static void CACMDynLinkLoad()
    {
	InitializeCriticalSection(&m_LoadACMLock);      // serialise constructor/destructor
    }
    static void CACMDynLinkUnload()
    {
	DeleteCriticalSection(&m_LoadACMLock);      // serialise constructor/destructor
    }

    static MMRESULT ACMAPI acmStreamConvert(HACMSTREAM has, LPACMSTREAMHEADER pash, DWORD fdwConvert)
    {
        return((((pacmStreamConvert)aACMEntries[indxacmStreamConvert]))(has, pash, fdwConvert));
    }

    static MMRESULT ACMAPI acmStreamSize
    (
        HACMSTREAM              has,
        DWORD                   cbInput,
        LPDWORD                 pdwOutputBytes,
        DWORD                   fdwSize
    )
    {
        return((((pacmStreamSize)aACMEntries[indxacmStreamSize]))(has, cbInput, pdwOutputBytes, fdwSize));
    }


    static MMRESULT ACMAPI acmStreamPrepareHeader
    (
        HACMSTREAM          has,
        LPACMSTREAMHEADER   pash,
        DWORD               fdwPrepare
    )
    {
        return((((pacmStreamPrepareHeader)aACMEntries[indxacmStreamPrepareHeader]))(has, pash, fdwPrepare));
    }

    static MMRESULT ACMAPI acmMetrics
    (
        HACMOBJ                 hao,
        UINT                    uMetric,
        LPVOID                  pMetric
    )
    {
        return((((pacmMetrics)aACMEntries[indxacmMetrics]))(hao, uMetric, pMetric));
    }

    static MMRESULT ACMAPI acmStreamUnprepareHeader
    (
        HACMSTREAM          has,
        LPACMSTREAMHEADER   pash,
        DWORD               fdwUnprepare
    )
    {
        return((((pacmStreamUnprepareHeader)aACMEntries[indxacmStreamUnprepareHeader]))(has, pash, fdwUnprepare));
    }

    static MMRESULT ACMAPI acmStreamOpen
    (
        LPHACMSTREAM            phas,       // pointer to stream handle
        HACMDRIVER              had,        // optional driver handle
        LPWAVEFORMATEX          pwfxSrc,    // source format to convert
        LPWAVEFORMATEX          pwfxDst,    // required destination format
        LPWAVEFILTER            pwfltr,     // optional filter
        DWORD_PTR               dwCallback, // callback
        DWORD_PTR               dwInstance, // callback instance data
        DWORD                   fdwOpen     // ACM_STREAMOPENF_* and CALLBACK_*
    )
    {
        return((((pacmStreamOpen)aACMEntries[indxacmStreamOpen]))(phas,had,pwfxSrc,pwfxDst,pwfltr,dwCallback,dwInstance,fdwOpen));
    }

    static MMRESULT ACMAPI acmFormatSuggest
    (
        HACMDRIVER          had,
        LPWAVEFORMATEX      pwfxSrc,
        LPWAVEFORMATEX      pwfxDst,
        DWORD               cbwfxDst,
        DWORD               fdwSuggest
    )
    {
        return((((pacmFormatSuggest)aACMEntries[indxacmFormatSuggest]))(had, pwfxSrc, pwfxDst, cbwfxDst, fdwSuggest));
    }

    static MMRESULT ACMAPI acmStreamClose
    (
        HACMSTREAM              has,
        DWORD                   fdwClose
    )
    {
        return((((pacmStreamClose)aACMEntries[indxacmStreamClose]))(has, fdwClose));
    }

#ifdef UNICODE
    static MMRESULT ACMAPI acmFormatEnumW
    (
        HACMDRIVER              had,
        LPACMFORMATDETAILSW     pafd,
        ACMFORMATENUMCBW        fnCallback,
        DWORD_PTR               dwInstance,
        DWORD                   fdwEnum
    )
    {
        return((((pacmFormatEnumW)aACMEntries[indxacmFormatEnumW]))(had,pafd,fnCallback,dwInstance,fdwEnum));
    }
#else
    static MMRESULT ACMAPI acmFormatEnumA
    (
        HACMDRIVER              had,
        LPACMFORMATDETAILSA     pafd,
        ACMFORMATENUMCBA        fnCallback,
        DWORD_PTR               dwInstance, 
        DWORD                   fdwEnum
    )
    {
        return((((pacmFormatEnumA)aACMEntries[indxacmFormatEnumA]))(had,pafd,fnCallback,dwInstance,fdwEnum));
    }
#endif

    CACMDynLink();
    ~CACMDynLink();

private:

    // make copy and assignment inaccessible
    CACMDynLink(const CVFWDynLink &refVFWDynLink);
    CACMDynLink &operator=(const CVFWDynLink &refVFWDynLink);
};


//
// Class for dynamic linking to URLMON.DLL
//
//
// Dynamically loaded array of entry points
//
extern FARPROC aURLMonEntries[];

//
// List of index entries into the array for each redirected API
//
#define indxurlmonCreateURLMoniker	0
#define indxurlmonRegisterCallback	1
#define indxurlmonRevokeCallback	2

//
// typedef the API set that we redirect
//


typedef HRESULT (STDAPICALLTYPE * pCreateURLMoniker) (LPMONIKER pMkCtx, LPCWSTR szURL, LPMONIKER FAR * ppmk);             
typedef HRESULT (STDAPICALLTYPE * pRegisterBindStatusCallback)(LPBC pBC, IBindStatusCallback *pBSCb,                     
                                IBindStatusCallback**  ppBSCBPrev, DWORD dwReserved);       
typedef HRESULT (STDAPICALLTYPE * pRevokeBindStatusCallback)(LPBC pBC, IBindStatusCallback *pBSCb);                      


class CURLMonDynLink {

private:
    static HMODULE m_hURLMon;	        	// handle to URLMON
    static LONG    m_URLMonlinkCount;     	// instance count for this process
    static CRITICAL_SECTION m_LoadURLMonLock;   // serialise constructor/destructor

public:
    static void CURLMonDynLinkLoad()
    {
	InitializeCriticalSection(&m_LoadURLMonLock);      // serialise constructor/destructor
    }
    static void CURLMonDynLinkUnload()
    {
	DeleteCriticalSection(&m_LoadURLMonLock);      // serialise constructor/destructor
    }

    static HRESULT STDAPICALLTYPE CreateURLMoniker (LPMONIKER pMkCtx, LPCWSTR szURL, LPMONIKER FAR * ppmk)
    {
        return((((pCreateURLMoniker)aURLMonEntries[indxurlmonCreateURLMoniker]))
	       (pMkCtx, szURL, ppmk));
    }
	    
    static HRESULT STDAPICALLTYPE RegisterBindStatusCallback (LPBC pBC, IBindStatusCallback *pBSCb,                     
                                IBindStatusCallback**  ppBSCBPrev, DWORD dwReserved)
    {
        return((((pRegisterBindStatusCallback)aURLMonEntries[indxurlmonRegisterCallback]))
	       (pBC, pBSCb, ppBSCBPrev, dwReserved));
    }
    static HRESULT STDAPICALLTYPE RevokeBindStatusCallback (LPBC pBC, IBindStatusCallback *pBSCb)
    {
        return((((pRevokeBindStatusCallback)aURLMonEntries[indxurlmonRevokeCallback]))
	       (pBC, pBSCb));
    }

    CURLMonDynLink();
    ~CURLMonDynLink();

private:

    // make copy and assignment inaccessible
    CURLMonDynLink(const CVFWDynLink &refVFWDynLink);
    CURLMonDynLink &operator=(const CVFWDynLink &refVFWDynLink);
};

#endif //  FILTER_DLL
#endif //  __DYNLINK_H__
=== C:/Users/treeman/Desktop/windows nt source code\Source\Win2K3\NT\multimedia\dshow\h\evcodei.h ===
//==========================================================================;
//
//  THIS CODE AND INFORMATION IS PROVIDED "AS IS" WITHOUT WARRANTY OF ANY
//  KIND, EITHER EXPRESSED OR IMPLIED, INCLUDING BUT NOT LIMITED TO THE
//  IMPLIED WARRANTIES OF MERCHANTABILITY AND/OR FITNESS FOR A PARTICULAR
//  PURPOSE.
//
//  Copyright (c) 1992 - 1998  Microsoft Corporation.  All Rights Reserved.
//
//--------------------------------------------------------------------------;

//
// list of additional (perhaps standard someday) Quartz event codes
// and the expected params
//

#define EC_SKIP_FRAMES                      0x25
// ( nFramesToSkip, IFrameSkipResultCallback) : internal
// Get the filter graph to seek accuratley.

#define EC_PLEASE_REOPEN		    0x40
// (void, void) : application
// Something has changed enough that the graph should be re-rendered.

#define EC_STATUS	                    0x41
// ( BSTR, BSTR) : application
// Two arbitrary strings, a short one and a long one.

#define EC_MARKER_HIT			    0x42
// (int, void) : application
// The specified "marker #" has just been passed

#define EC_LOADSTATUS			    0x43
// (int, void) : application
// Sent when various points during the loading of a network file are reached

#define EC_FILE_CLOSED			    0x44
// (void, void) : application
// Sent when the file is involuntarily closed, i.e. by a network server shutdown

#define EC_ERRORABORTEX			    0x45
// ( HRESULT, BSTR ) : application
// Operation aborted because of error.  Additional information available.

// status codes for EC_LOADSTATUS....
#define AM_LOADSTATUS_CLOSED	        0x0000
#define AM_LOADSTATUS_LOADINGDESCR      0x0001
#define AM_LOADSTATUS_LOADINGMCAST      0x0002
#define AM_LOADSTATUS_LOCATING		0x0003
#define AM_LOADSTATUS_CONNECTING	0x0004
#define AM_LOADSTATUS_OPENING		0x0005
#define AM_LOADSTATUS_OPEN		0x0006


#define EC_NEW_PIN			    0x20
#define	EC_RENDER_FINISHED		    0x21


#define EC_EOS_SOON			   0x046
// (void, void) : application
// sent when the source filter is about to deliver an EOS downstream....

#define EC_CONTENTPROPERTY_CHANGED   0x47
// (ULONG, void) 
// Sent when a streaming media filter recieves a change in stream description information.
// the UI is expected to re-query for the changed property in response
#define AM_CONTENTPROPERTY_TITLE     0x0001
#define AM_CONTENTPROPERTY_AUTHOR    0x0002
#define AM_CONTENTPROPERTY_COPYRIGHT 0x0004
#define AM_CONTENTPROPERTY_DESCRIPTION 0x0008


#define EC_BANDWIDTHCHANGE		    0x48
// (WORD, long) : application
// sent when the bandwidth of the streaming data has changed.  First parameter
// is the new level of bandwidth. Second is the MAX number of levels. Second
// parameter may be 0, if the max levels could not be determined.

#define EC_VIDEOFRAMEREADY		    0x49
// (void, void) : application
// sent to notify the application that the first video frame is about to be drawn
=== C:/Users/treeman/Desktop/windows nt source code\Source\Win2K3\NT\multimedia\dshow\h\fil_data_i.c ===
/* Copyright (c) 1999  Microsoft Corporation.  All Rights Reserved. */
/* this file contains the actual definitions of */
/* the IIDs and CLSIDs */

/* link this file in with the server and any clients */


/* File created by MIDL compiler version 5.01.0164 */
/* at Sat Oct 23 12:28:23 1999
 */
/* Compiler settings for fil_data.idl:
    Os (OptLev=s), W1, Zp8, env=Win32, ms_ext, c_ext
    error checks: allocation ref bounds_check enum stub_data 
*/
//@@MIDL_FILE_HEADING(  )
#ifdef __cplusplus
extern "C"{
#endif 


#ifndef __IID_DEFINED__
#define __IID_DEFINED__

typedef struct _IID
{
    unsigned long x;
    unsigned short s1;
    unsigned short s2;
    unsigned char  c[8];
} IID;

#endif // __IID_DEFINED__

#ifndef CLSID_DEFINED
#define CLSID_DEFINED
typedef IID CLSID;
#endif // CLSID_DEFINED

const IID IID_IAMFilterData = {0x97f7c4d4,0x547b,0x4a5f,{0x83,0x32,0x53,0x64,0x30,0xad,0x2e,0x4d}};


#ifdef __cplusplus
}
#endif
=== C:/Users/treeman/Desktop/windows nt source code\Source\Win2K3\NT\multimedia\dshow\h\ovmixpos.h ===
// Copyright (c) 1997 - 1999  Microsoft Corporation.  All Rights Reserved.
#ifndef __OVMIXPOS__
#define __OVMIXPOS__

EXTERN_GUID(IID_IAMOverlayMixerPosition,0x56a868fc,0x0ad4,0x11ce,0xb0,0xa3,0x0,0x20,0xaf,0x0b,0xa7,0x70);

interface DECLSPEC_UUID("56a868fc-0ad4-11ce-b03a-0020af0ba770")
IAMOverlayMixerPosition : IUnknown
{
   virtual HRESULT STDMETHODCALLTYPE GetScaledDest(RECT *prcSrc, RECT* prcDst) = 0;

   // other methods?
};

#endif
=== C:/Users/treeman/Desktop/windows nt source code\Source\Win2K3\NT\multimedia\dshow\h\multmon.h ===
// Copyright (c) 1999  Microsoft Corporation.  All Rights Reserved.
#ifdef COMPILE_MULTIMON_STUBS
#define COMPILE_MULTIMON_STUBS2
#endif


#if !defined(_WIN32_WINNT) || (_WIN32_WINNT < 0x0500)

#include <multimon.h>

//=============================================================================
//
// MULTIMON
// stub module that fakes multiple monitor apis on pre Memphis Win32 OSes
//
// By using this header your code will work unchanged on Win95,
// you will get back default values from GetSystemMetrics() for new metrics
// and the new APIs will act like only one display is present.
//
// exactly one source must include this with COMPILE_MULTIMON_STUBS defined
//
//=============================================================================

#ifdef __cplusplus
extern "C" {            /* Assume C declarations for C++ */
#endif  /* __cplusplus */

#undef ChangeDisplaySettingsEx

//
// define this to compile the stubs
// otherwise you get the declarations
//
#ifdef COMPILE_MULTIMON_STUBS2

//-----------------------------------------------------------------------------
//
// Implement the API stubs.
//
//-----------------------------------------------------------------------------

BOOL (WINAPI* g_pfnChangeDisplaySettingsEx)(LPCSTR, LPDEVMODE, HWND, DWORD, LPVOID);

BOOL InitMultipleMonitorStubs2(void)
{
    HMODULE hUser32;
    static BOOL fInitDone;

    if (fInitDone)
    {
        return g_pfnGetMonitorInfo != NULL;
    }

    if ((hUser32 = GetModuleHandle(TEXT("USER32"))) &&
#ifdef UNICODE
        (*(FARPROC*)&g_pfnChangeDisplaySettingsEx = GetProcAddress(hUser32,"ChangeDisplaySettingsExW")) &&
#else
        (*(FARPROC*)&g_pfnChangeDisplaySettingsEx = GetProcAddress(hUser32,"ChangeDisplaySettingsExA")) &&
#endif
        //
        // Old builds of Memphis had different indices for these metrics, and
        // some of the APIs and structs have changed since then, so validate that
        // the returned metrics are not totally messed up.  (for example on an old
        // Memphis build, the new index for SM_CYVIRTUALSCREEN will fetch 0)
        //
        // If this is preventing you from using the shell on secondary monitors
        // under Memphis then upgrade to a new Memphis build that is in sync with
        // the current version of the multi-monitor APIs.
        //
        (GetSystemMetrics(SM_CXVIRTUALSCREEN) >= GetSystemMetrics(SM_CXSCREEN)) &&
        (GetSystemMetrics(SM_CYVIRTUALSCREEN) >= GetSystemMetrics(SM_CYSCREEN)) )
    {
        fInitDone = TRUE;
        return TRUE;
    }
    else
    {
        g_pfnChangeDisplaySettingsEx = NULL ;

        fInitDone = TRUE;
        return FALSE;
    }
}

#ifdef UNICODE

LONG WINAPI
xChangeDisplaySettingsExW(LPCSTR lpszDeviceName, LPDEVMODEW lpDevMode,
                          HWND hwnd, DWORD dwflags, LPVOID lParam)
{
    if (InitMultipleMonitorStubs2())
        return g_pfnChangeDisplaySettingsEx(lpszDeviceName, lpDevMode, hwnd,
                                            dwflags, lParam) ;

    // Otherwise return DISP_CHANGE_SUCCESSFUL, because OS doesn't support it
    return DISP_CHANGE_SUCCESSFUL ;  // what else?
}

#else

LONG WINAPI
xChangeDisplaySettingsExA(LPCSTR lpszDeviceName, LPDEVMODEA lpDevMode,
                          HWND hwnd, DWORD dwflags, LPVOID lParam)
{
    if (InitMultipleMonitorStubs2())
        return g_pfnChangeDisplaySettingsEx(lpszDeviceName, lpDevMode, hwnd,
                                            dwflags, lParam) ;

    // Otherwise return DISP_CHANGE_SUCCESSFUL, because OS doesn't support it
    return DISP_CHANGE_SUCCESSFUL ;  // what else?
}

#endif // UNICODE

#undef COMPILE_MULTIMON_STUBS2

#else   // COMPILE_MULTIMON_STUBS2

#ifdef UNICODE
extern LONG WINAPI xChangeDisplaySettingsExW(LPCSTR, LPDEVMODE, HWND, DWORD, LPVOID);
#else
extern LONG WINAPI xChangeDisplaySettingsExA(LPCSTR, LPDEVMODE, HWND, DWORD, LPVOID);
#endif

#endif  // COMPILE_MULTIMON_STUBS2

//
// build defines that replace the regular APIs with our versions
//
#ifdef UNICODE
#define ChangeDisplaySettingsEx xChangeDisplaySettingsExW
#else
#define ChangeDisplaySettingsEx xChangeDisplaySettingsExA
#define ChangeDisplaySettingsExA xChangeDisplaySettingsExA
#endif

#ifdef __cplusplus
}
#endif  /* __cplusplus */

#endif  /* !defined(_WIN32_WINNT) || (_WIN32_WINNT < 0x0500) */
=== C:/Users/treeman/Desktop/windows nt source code\Source\Win2K3\NT\multimedia\dshow\h\hrexcept.h ===
// Copyright (c) 1995 - 1996  Microsoft Corporation.  All Rights Reserved.
//
// hrExcept.h
//

#ifndef __HREXCEPT__
#define __HREXCEPT__


// A hierarchy of classes intended to be used
// as exceptions.
// Based around the common HRESULT error code.

//
// CHRESULTException
//
// the root exception. the HRESULT stored provides more 
// information as to why the exception was thrown
class CHRESULTException {
public:

    CHRESULTException(const HRESULT hrReason = E_FAIL) { m_hrReason = hrReason; }
    
    HRESULT Reason(void) const { return m_hrReason; }

private:

    HRESULT m_hrReason;	// the reason for throwing the exception
};


//
// The following sub classes are provided as short cuts for their respective
// HRESULT codes.

//
// CE_OUTOFMEMORY
//
class CE_OUTOFMEMORY : public CHRESULTException {
public:
    CE_OUTOFMEMORY() : CHRESULTException(E_OUTOFMEMORY) {}
};


//
// CE_UNEXPECTED
//
class CE_UNEXPECTED : public CHRESULTException {
public:
    CE_UNEXPECTED() : CHRESULTException(E_UNEXPECTED) {}
};


//
// CE_FAIL
//
class CE_FAIL : public CHRESULTException {
public:
    CE_FAIL() : CHRESULTException(E_FAIL) {}
};


//
// CE_INVALIDARG
//
class CE_INVALIDARG : public CHRESULTException {
public:
    CE_INVALIDARG() : CHRESULTException(E_INVALIDARG) {}
};

#endif // __HREXCEPT__
=== C:/Users/treeman/Desktop/windows nt source code\Source\Win2K3\NT\multimedia\dshow\h\fil_data.h ===
// Copyright (c) 1999  Microsoft Corporation.  All Rights Reserved.
/* this ALWAYS GENERATED file contains the definitions for the interfaces */


/* File created by MIDL compiler version 5.01.0164 */
/* at Sat Oct 23 12:28:23 1999
 */
/* Compiler settings for fil_data.idl:
    Os (OptLev=s), W1, Zp8, env=Win32, ms_ext, c_ext
    error checks: allocation ref bounds_check enum stub_data 
*/
//@@MIDL_FILE_HEADING(  )


/* verify that the <rpcndr.h> version is high enough to compile this file*/
#ifndef __REQUIRED_RPCNDR_H_VERSION__
#define __REQUIRED_RPCNDR_H_VERSION__ 440
#endif

#include "rpc.h"
#include "rpcndr.h"

#ifndef __RPCNDR_H_VERSION__
#error this stub requires an updated version of <rpcndr.h>
#endif // __RPCNDR_H_VERSION__

#ifndef COM_NO_WINDOWS_H
#include "windows.h"
#include "ole2.h"
#endif /*COM_NO_WINDOWS_H*/

#ifndef __fil_data_h__
#define __fil_data_h__

#ifdef __cplusplus
extern "C"{
#endif 

/* Forward Declarations */ 

#ifndef __IAMFilterData_FWD_DEFINED__
#define __IAMFilterData_FWD_DEFINED__
typedef interface IAMFilterData IAMFilterData;
#endif 	/* __IAMFilterData_FWD_DEFINED__ */


/* header files for imported files */
#include "unknwn.h"
#include "strmif.h"

void __RPC_FAR * __RPC_USER MIDL_user_allocate(size_t);
void __RPC_USER MIDL_user_free( void __RPC_FAR * ); 

/* interface __MIDL_itf_fil_data_0000 */
/* [local] */ 




extern RPC_IF_HANDLE __MIDL_itf_fil_data_0000_v0_0_c_ifspec;
extern RPC_IF_HANDLE __MIDL_itf_fil_data_0000_v0_0_s_ifspec;

#ifndef __IAMFilterData_INTERFACE_DEFINED__
#define __IAMFilterData_INTERFACE_DEFINED__

/* interface IAMFilterData */
/* [unique][uuid][object] */ 


EXTERN_C const IID IID_IAMFilterData;

#if defined(__cplusplus) && !defined(CINTERFACE)
    
    MIDL_INTERFACE("97f7c4d4-547b-4a5f-8332-536430ad2e4d")
    IAMFilterData : public IUnknown
    {
    public:
        virtual HRESULT STDMETHODCALLTYPE ParseFilterData( 
            /* [size_is][in] */ BYTE __RPC_FAR *rgbFilterData,
            /* [in] */ ULONG cb,
            /* [out] */ BYTE __RPC_FAR *__RPC_FAR *prgbRegFilter2) = 0;
        
        virtual HRESULT STDMETHODCALLTYPE CreateFilterData( 
            /* [in] */ REGFILTER2 __RPC_FAR *prf2,
            /* [out] */ BYTE __RPC_FAR *__RPC_FAR *prgbFilterData,
            /* [out] */ ULONG __RPC_FAR *pcb) = 0;
        
    };
    
#else 	/* C style interface */

    typedef struct IAMFilterDataVtbl
    {
        BEGIN_INTERFACE
        
        HRESULT ( STDMETHODCALLTYPE __RPC_FAR *QueryInterface )( 
            IAMFilterData __RPC_FAR * This,
            /* [in] */ REFIID riid,
            /* [iid_is][out] */ void __RPC_FAR *__RPC_FAR *ppvObject);
        
        ULONG ( STDMETHODCALLTYPE __RPC_FAR *AddRef )( 
            IAMFilterData __RPC_FAR * This);
        
        ULONG ( STDMETHODCALLTYPE __RPC_FAR *Release )( 
            IAMFilterData __RPC_FAR * This);
        
        HRESULT ( STDMETHODCALLTYPE __RPC_FAR *ParseFilterData )( 
            IAMFilterData __RPC_FAR * This,
            /* [size_is][in] */ BYTE __RPC_FAR *rgbFilterData,
            /* [in] */ ULONG cb,
            /* [out] */ BYTE __RPC_FAR *__RPC_FAR *prgbRegFilter2);
        
        HRESULT ( STDMETHODCALLTYPE __RPC_FAR *CreateFilterData )( 
            IAMFilterData __RPC_FAR * This,
            /* [in] */ REGFILTER2 __RPC_FAR *prf2,
            /* [out] */ BYTE __RPC_FAR *__RPC_FAR *prgbFilterData,
            /* [out] */ ULONG __RPC_FAR *pcb);
        
        END_INTERFACE
    } IAMFilterDataVtbl;

    interface IAMFilterData
    {
        CONST_VTBL struct IAMFilterDataVtbl __RPC_FAR *lpVtbl;
    };

    

#ifdef COBJMACROS


#define IAMFilterData_QueryInterface(This,riid,ppvObject)	\
    (This)->lpVtbl -> QueryInterface(This,riid,ppvObject)

#define IAMFilterData_AddRef(This)	\
    (This)->lpVtbl -> AddRef(This)

#define IAMFilterData_Release(This)	\
    (This)->lpVtbl -> Release(This)


#define IAMFilterData_ParseFilterData(This,rgbFilterData,cb,prgbRegFilter2)	\
    (This)->lpVtbl -> ParseFilterData(This,rgbFilterData,cb,prgbRegFilter2)

#define IAMFilterData_CreateFilterData(This,prf2,prgbFilterData,pcb)	\
    (This)->lpVtbl -> CreateFilterData(This,prf2,prgbFilterData,pcb)

#endif /* COBJMACROS */


#endif 	/* C style interface */



HRESULT STDMETHODCALLTYPE IAMFilterData_ParseFilterData_Proxy( 
    IAMFilterData __RPC_FAR * This,
    /* [size_is][in] */ BYTE __RPC_FAR *rgbFilterData,
    /* [in] */ ULONG cb,
    /* [out] */ BYTE __RPC_FAR *__RPC_FAR *prgbRegFilter2);


void __RPC_STUB IAMFilterData_ParseFilterData_Stub(
    IRpcStubBuffer *This,
    IRpcChannelBuffer *_pRpcChannelBuffer,
    PRPC_MESSAGE _pRpcMessage,
    DWORD *_pdwStubPhase);


HRESULT STDMETHODCALLTYPE IAMFilterData_CreateFilterData_Proxy( 
    IAMFilterData __RPC_FAR * This,
    /* [in] */ REGFILTER2 __RPC_FAR *prf2,
    /* [out] */ BYTE __RPC_FAR *__RPC_FAR *prgbFilterData,
    /* [out] */ ULONG __RPC_FAR *pcb);


void __RPC_STUB IAMFilterData_CreateFilterData_Stub(
    IRpcStubBuffer *This,
    IRpcChannelBuffer *_pRpcChannelBuffer,
    PRPC_MESSAGE _pRpcMessage,
    DWORD *_pdwStubPhase);



#endif 	/* __IAMFilterData_INTERFACE_DEFINED__ */


/* Additional Prototypes for ALL interfaces */

/* end of Additional Prototypes */

#ifdef __cplusplus
}
#endif

#endif
=== C:/Users/treeman/Desktop/windows nt source code\Source\Win2K3\NT\multimedia\dshow\h\skipfrm_i.c ===
#pragma warning( disable: 4049 )  /* more than 64k source lines */

/* this ALWAYS GENERATED file contains the IIDs and CLSIDs */

/* link this file in with the server and any clients */


 /* File created by MIDL compiler version 6.00.0347 */
/* Compiler settings for skipfrm.idl:
    Oicf, W1, Zp8, env=Win32 (32b run)
    protocol : dce , ms_ext, c_ext, robust
    error checks: allocation ref bounds_check enum stub_data 
    VC __declspec() decoration level: 
         __declspec(uuid()), __declspec(selectany), __declspec(novtable)
         DECLSPEC_UUID(), MIDL_INTERFACE()
*/
//@@MIDL_FILE_HEADING(  )

#if !defined(_M_IA64) && !defined(_M_AMD64)

#ifdef __cplusplus
extern "C"{
#endif 


#include <rpc.h>
#include <rpcndr.h>

#ifdef _MIDL_USE_GUIDDEF_

#ifndef INITGUID
#define INITGUID
#include <guiddef.h>
#undef INITGUID
#else
#include <guiddef.h>
#endif

#define MIDL_DEFINE_GUID(type,name,l,w1,w2,b1,b2,b3,b4,b5,b6,b7,b8) \
        DEFINE_GUID(name,l,w1,w2,b1,b2,b3,b4,b5,b6,b7,b8)

#else // !_MIDL_USE_GUIDDEF_

#ifndef __IID_DEFINED__
#define __IID_DEFINED__

typedef struct _IID
{
    unsigned long x;
    unsigned short s1;
    unsigned short s2;
    unsigned char  c[8];
} IID;

#endif // __IID_DEFINED__

#ifndef CLSID_DEFINED
#define CLSID_DEFINED
typedef IID CLSID;
#endif // CLSID_DEFINED

#define MIDL_DEFINE_GUID(type,name,l,w1,w2,b1,b2,b3,b4,b5,b6,b7,b8) \
        const type name = {l,w1,w2,{b1,b2,b3,b4,b5,b6,b7,b8}}

#endif !_MIDL_USE_GUIDDEF_

MIDL_DEFINE_GUID(IID, IID_IFrameSkipResultCallback,0x7536960D,0x1977,0x4807,0x98,0xEA,0x48,0x5F,0x6C,0x84,0x2A,0x54);

#undef MIDL_DEFINE_GUID

#ifdef __cplusplus
}
#endif



#endif /* !defined(_M_IA64) && !defined(_M_AMD64)*/


#pragma warning( disable: 4049 )  /* more than 64k source lines */

/* this ALWAYS GENERATED file contains the IIDs and CLSIDs */

/* link this file in with the server and any clients */


 /* File created by MIDL compiler version 6.00.0347 */
/* Compiler settings for skipfrm.idl:
    Oicf, W1, Zp8, env=Win64 (32b run,appending)
    protocol : dce , ms_ext, c_ext, robust
    error checks: allocation ref bounds_check enum stub_data 
    VC __declspec() decoration level: 
         __declspec(uuid()), __declspec(selectany), __declspec(novtable)
         DECLSPEC_UUID(), MIDL_INTERFACE()
*/
//@@MIDL_FILE_HEADING(  )

#if defined(_M_IA64) || defined(_M_AMD64)

#ifdef __cplusplus
extern "C"{
#endif 


#include <rpc.h>
#include <rpcndr.h>

#ifdef _MIDL_USE_GUIDDEF_

#ifndef INITGUID
#define INITGUID
#include <guiddef.h>
#undef INITGUID
#else
#include <guiddef.h>
#endif

#define MIDL_DEFINE_GUID(type,name,l,w1,w2,b1,b2,b3,b4,b5,b6,b7,b8) \
        DEFINE_GUID(name,l,w1,w2,b1,b2,b3,b4,b5,b6,b7,b8)

#else // !_MIDL_USE_GUIDDEF_

#ifndef __IID_DEFINED__
#define __IID_DEFINED__

typedef struct _IID
{
    unsigned long x;
    unsigned short s1;
    unsigned short s2;
    unsigned char  c[8];
} IID;

#endif // __IID_DEFINED__

#ifndef CLSID_DEFINED
#define CLSID_DEFINED
typedef IID CLSID;
#endif // CLSID_DEFINED

#define MIDL_DEFINE_GUID(type,name,l,w1,w2,b1,b2,b3,b4,b5,b6,b7,b8) \
        const type name = {l,w1,w2,{b1,b2,b3,b4,b5,b6,b7,b8}}

#endif !_MIDL_USE_GUIDDEF_

MIDL_DEFINE_GUID(IID, IID_IFrameSkipResultCallback,0x7536960D,0x1977,0x4807,0x98,0xEA,0x48,0x5F,0x6C,0x84,0x2A,0x54);

#undef MIDL_DEFINE_GUID

#ifdef __cplusplus
}
#endif



#endif /* defined(_M_IA64) || defined(_M_AMD64)*/
=== C:/Users/treeman/Desktop/windows nt source code\Source\Win2K3\NT\multimedia\dshow\h\intset.h ===
// Copyright (c) 1996 - 1999  Microsoft Corporation.  All Rights Reserved.
#ifndef __IntSet_h__
#define __IntSet_h__

#include <stdlib.h>
#include <memory.h>

// To test this class, copy this file into a .cpp,
// load into Dev Studio, define self_test and run.
#ifdef self_test
    #include <iostream.h>
    #include <assert.h>
    #define ASSERT assert
#endif

// Class denoting a set of integers within the range [min..max]
// A number may be added to the set by +=,
// removed from the set by -=,
// and tested by [number].

class IntSet
{
protected:
    const int m_min, m_max;
    unsigned * m_pBits;
    enum { bit_width = 8 * sizeof(unsigned), low_mask = bit_width - 1, high_shift = 5 };

public:
    ~IntSet();
    IntSet( int min, int max );

    int Max() const { return m_max; }
    int Min() const { return m_min; }

    void Clear()
    {
        memset( m_pBits, 0, ((m_max - m_min) / bit_width + 1) * sizeof(unsigned) );
    }

    void operator += ( int elmt )
    {
        ASSERT( elmt >= m_min && elmt <= m_max );
        elmt -= m_min;
        m_pBits[elmt >> high_shift] |= 1 << (elmt & low_mask);
    }

    void operator -= ( int elmt )
    {
        ASSERT( elmt >= m_min && elmt <= m_max );
        elmt -= m_min;
        m_pBits[elmt >> high_shift] &= ~(1 << (elmt & low_mask));
    }

    int operator[] ( int elmt ) const
    {
        if (elmt < m_min) return 0;
        if (elmt > m_max) return 0;
        elmt -= m_min;
        return (m_pBits[elmt >> high_shift] >> (elmt & low_mask)) & 1;
    }

#ifdef self_test
    void COut() const
    {
        for (int i = m_min; i <= m_max; i++) cout << ( (*this)[i] ? 'Y' : 'n' );
        cout << endl;
    }
#endif
};

inline IntSet::~IntSet()
{
    delete [] m_pBits;
}

inline IntSet::IntSet( int min, int max )
: m_min(min), m_max(max)
{
    m_pBits = new unsigned [(max-min)/bit_width + 1];
    Clear();
}


// Variation that can only hold objects [0..31].
// An initial value can be specified on creation.
// Appart from its construction, this object should
// look like an IntSet.

class IntSmallSet
{
protected:
    enum { m_min = 0, m_max = 63 };
    unsigned __int64 m_Bits;

public:
    static const __int64 One;

    IntSmallSet( unsigned __int64 init = 0 )
    : m_Bits(init)
    {}

    int Max() const { return m_max; }
    int Min() const { return m_min; }

    void Clear()
    {
        m_Bits = 0;
    }

    void operator += ( int elmt )
    {
        ASSERT( elmt >= m_min && elmt <= m_max );
        elmt -= m_min;
        m_Bits |= One << elmt;
    }

    void operator -= ( int elmt )
    {
        ASSERT( elmt >= m_min && elmt <= m_max );
        elmt -= m_min;
        m_Bits &= ~(One << elmt);
    }

    int operator[] ( int elmt ) const
    {
        if (elmt < m_min) return 0;
        if (elmt > m_max) return 0;
        elmt -= m_min;

        // Eliminate compiler warning: The conditional expression is an
        // _int64, convert it to an int
        return ((m_Bits >> elmt) & 1)? 1 : 0;
    }

    IntSmallSet operator | ( const IntSmallSet & s ) const
    { return IntSmallSet( m_Bits | s.m_Bits ); }

    IntSmallSet operator & ( const IntSmallSet & s ) const
    { return IntSmallSet( m_Bits & s.m_Bits ); }

    IntSmallSet operator ~ () const
    { return IntSmallSet( ~m_Bits ); }


    int operator == ( const IntSmallSet & s ) const
    { return m_Bits == s.m_Bits; }

    int operator == ( unsigned i ) const
    { return m_Bits == i; }

#ifdef self_test
    void COut() const
    {
        for (int i = m_min; i <= m_max; i++) cout << ( (*this)[i] ? 'Y' : 'n' );
        cout << endl;
    }
#endif
};


#ifdef self_test
void main()
{
    // IntSet Set1(-30,+102);
    IntSmallSet Set1;

    int i;

    for ( i = Set1.Min(); i <= Set1.Max(); i++ )
    {
        Set1 += i;
        Set1.COut();
    }

    for ( i = Set1.Max(); i >= Set1.Min(); i-- )
    {
        Set1 -= i;
        Set1.COut();
    }
}
#endif

#endif
=== C:/Users/treeman/Desktop/windows nt source code\Source\Win2K3\NT\multimedia\dshow\h\skipfrm.h ===
#pragma warning( disable: 4049 )  /* more than 64k source lines */

/* this ALWAYS GENERATED file contains the definitions for the interfaces */


 /* File created by MIDL compiler version 6.00.0347 */
/* Compiler settings for skipfrm.idl:
    Oicf, W1, Zp8, env=Win32 (32b run)
    protocol : dce , ms_ext, c_ext, robust
    error checks: allocation ref bounds_check enum stub_data 
    VC __declspec() decoration level: 
         __declspec(uuid()), __declspec(selectany), __declspec(novtable)
         DECLSPEC_UUID(), MIDL_INTERFACE()
*/
//@@MIDL_FILE_HEADING(  )


/* verify that the <rpcndr.h> version is high enough to compile this file*/
#ifndef __REQUIRED_RPCNDR_H_VERSION__
#define __REQUIRED_RPCNDR_H_VERSION__ 475
#endif

#include "rpc.h"
#include "rpcndr.h"

#ifndef __RPCNDR_H_VERSION__
#error this stub requires an updated version of <rpcndr.h>
#endif // __RPCNDR_H_VERSION__

#ifndef COM_NO_WINDOWS_H
#include "windows.h"
#include "ole2.h"
#endif /*COM_NO_WINDOWS_H*/

#ifndef __skipfrm_h__
#define __skipfrm_h__

#if defined(_MSC_VER) && (_MSC_VER >= 1020)
#pragma once
#endif

/* Forward Declarations */ 

#ifndef __IFrameSkipResultCallback_FWD_DEFINED__
#define __IFrameSkipResultCallback_FWD_DEFINED__
typedef interface IFrameSkipResultCallback IFrameSkipResultCallback;
#endif 	/* __IFrameSkipResultCallback_FWD_DEFINED__ */


/* header files for imported files */
#include "unknwn.h"

#ifdef __cplusplus
extern "C"{
#endif 

void * __RPC_USER MIDL_user_allocate(size_t);
void __RPC_USER MIDL_user_free( void * ); 

#ifndef __IFrameSkipResultCallback_INTERFACE_DEFINED__
#define __IFrameSkipResultCallback_INTERFACE_DEFINED__

/* interface IFrameSkipResultCallback */
/* [unique][uuid][object][local] */ 


EXTERN_C const IID IID_IFrameSkipResultCallback;

#if defined(__cplusplus) && !defined(CINTERFACE)
    
    MIDL_INTERFACE("7536960D-1977-4807-98EA-485F6C842A54")
    IFrameSkipResultCallback : public IUnknown
    {
    public:
        virtual void STDMETHODCALLTYPE FrameSkipStarted( 
            /* [in] */ HRESULT hr) = 0;
        
        virtual void STDMETHODCALLTYPE FrameSkipFinished( 
            /* [in] */ HRESULT hr) = 0;
        
    };
    
#else 	/* C style interface */

    typedef struct IFrameSkipResultCallbackVtbl
    {
        BEGIN_INTERFACE
        
        HRESULT ( STDMETHODCALLTYPE *QueryInterface )( 
            IFrameSkipResultCallback * This,
            /* [in] */ REFIID riid,
            /* [iid_is][out] */ void **ppvObject);
        
        ULONG ( STDMETHODCALLTYPE *AddRef )( 
            IFrameSkipResultCallback * This);
        
        ULONG ( STDMETHODCALLTYPE *Release )( 
            IFrameSkipResultCallback * This);
        
        void ( STDMETHODCALLTYPE *FrameSkipStarted )( 
            IFrameSkipResultCallback * This,
            /* [in] */ HRESULT hr);
        
        void ( STDMETHODCALLTYPE *FrameSkipFinished )( 
            IFrameSkipResultCallback * This,
            /* [in] */ HRESULT hr);
        
        END_INTERFACE
    } IFrameSkipResultCallbackVtbl;

    interface IFrameSkipResultCallback
    {
        CONST_VTBL struct IFrameSkipResultCallbackVtbl *lpVtbl;
    };

    

#ifdef COBJMACROS


#define IFrameSkipResultCallback_QueryInterface(This,riid,ppvObject)	\
    (This)->lpVtbl -> QueryInterface(This,riid,ppvObject)

#define IFrameSkipResultCallback_AddRef(This)	\
    (This)->lpVtbl -> AddRef(This)

#define IFrameSkipResultCallback_Release(This)	\
    (This)->lpVtbl -> Release(This)


#define IFrameSkipResultCallback_FrameSkipStarted(This,hr)	\
    (This)->lpVtbl -> FrameSkipStarted(This,hr)

#define IFrameSkipResultCallback_FrameSkipFinished(This,hr)	\
    (This)->lpVtbl -> FrameSkipFinished(This,hr)

#endif /* COBJMACROS */


#endif 	/* C style interface */



void STDMETHODCALLTYPE IFrameSkipResultCallback_FrameSkipStarted_Proxy( 
    IFrameSkipResultCallback * This,
    /* [in] */ HRESULT hr);


void __RPC_STUB IFrameSkipResultCallback_FrameSkipStarted_Stub(
    IRpcStubBuffer *This,
    IRpcChannelBuffer *_pRpcChannelBuffer,
    PRPC_MESSAGE _pRpcMessage,
    DWORD *_pdwStubPhase);


void STDMETHODCALLTYPE IFrameSkipResultCallback_FrameSkipFinished_Proxy( 
    IFrameSkipResultCallback * This,
    /* [in] */ HRESULT hr);


void __RPC_STUB IFrameSkipResultCallback_FrameSkipFinished_Stub(
    IRpcStubBuffer *This,
    IRpcChannelBuffer *_pRpcChannelBuffer,
    PRPC_MESSAGE _pRpcMessage,
    DWORD *_pdwStubPhase);



#endif 	/* __IFrameSkipResultCallback_INTERFACE_DEFINED__ */


/* Additional Prototypes for ALL interfaces */

/* end of Additional Prototypes */

#ifdef __cplusplus
}
#endif

#endif
=== C:/Users/treeman/Desktop/windows nt source code\Source\Win2K3\NT\multimedia\dshow\mfvideo\mswebdvd\capture.h ===
/*************************************************************************/
/* Copyright (C) 2000 Microsoft Corporation                              */
/* File: capture.h                                                       */
/* Description: Declaration for capture related functions                */
/* Author: Phillip Lu                                                    */
/*************************************************************************/
#ifndef __CAPTURE_H_
#define __CAPTURE_H_

#define BYTES_PER_PIXEL  3

typedef struct 
{
    int Width;
    int Height;
    int Stride;
    unsigned char *Scan0;
    unsigned char *pBuffer;
} CaptureBitmapData;


#endif // __CAPTURE_H_
=== C:/Users/treeman/Desktop/windows nt source code\Source\Win2K3\NT\multimedia\dshow\mfvideo\mswebdvd\bookmark.h ===
/*************************************************************************/
/* Copyright (C) 1999 Microsoft Corporation                              */
/* File: Bookmark.h                                                      */
/* Description: Implementation of Bookmark API                           */
/* Author: Steve Rowe                                                    */
/* Modified: David Janecek                                               */
/*************************************************************************/
#ifndef __BOOKMARK_H
#define __BOOKMARK_H

//#include <streams.h>

class CBookmark {

public:	
    static HRESULT SaveToRegistry(IDvdState *ppBookmark);
    static HRESULT LoadFromRegistry(IDvdState **ppBookmark);
    static HRESULT DeleteFromRegistry();

};/* end of class CBookmark */

#endif // __BOOKMARK_H
/*************************************************************************/
/* Function: Bookmark.h                                                  */
/*************************************************************************/
=== C:/Users/treeman/Desktop/windows nt source code\Source\Win2K3\NT\multimedia\dshow\mfvideo\mswebdvd\bookmark.cpp ===
/*************************************************************************/
/* Copyright (C) 1999 Microsoft Corporation                              */
/* File: Bookmark.h                                                      */
/* Description: Implementation of Bookmark API                           */
/* Author: Steve Rowe                                                    */
/* Modified: David Janecek                                               */
/*************************************************************************/
#include "stdafx.h"
#include "msdvd.h"
#include "msdvdadm.h"
#include "Bookmark.h"

/*************************************************************************/
/* Global consts.                                                        */
/*************************************************************************/
static const WCHAR* cgszBookmarkName = L"StopBookMark";
static const TCHAR g_szBookmark[] = TEXT("DVD.bookmark");

/*************************************************************************/
/* Outgoing interaface implementation.                                   */
/*************************************************************************/

/*************************************************************************/
/* Function: SaveBookmark                                                */
/*************************************************************************/
STDMETHODIMP CMSWebDVD::SaveBookmark(){

    HRESULT hr = S_OK;

    try {

        INITIALIZE_GRAPH_IF_NEEDS_TO_BE

        if(!m_pDvdInfo2){

            throw(E_UNEXPECTED);
        }/* end of if statement */    

        CComPtr<IDvdState> pBookmark;

        hr = m_pDvdInfo2->GetState(&pBookmark);

        if(FAILED(hr)){

            throw(hr);
        }/* end of if statement */

        hr = CBookmark::SaveToRegistry(pBookmark);
    }/* end of try statement */
    catch(HRESULT hrTmp){
        hr = hrTmp;
    }/* end of catch statement */
    catch(...){
        hr = E_UNEXPECTED;
    }/* end of catch statement */

	return HandleError(hr);
}/* end of function SaveBookmark */

/*************************************************************************/
/* Function: RestoreBookmark                                             */
/* Description: Restores the state by loading the bookmark stream        */
/*************************************************************************/
STDMETHODIMP CMSWebDVD::RestoreBookmark(){

    HRESULT hr = S_OK;

    try {
       
        CComPtr<IDvdState> pBookmark;

        HRESULT hrTemp = CBookmark::LoadFromRegistry(&pBookmark);

        if(SUCCEEDED(hrTemp)){

            INITIALIZE_GRAPH_IF_NEEDS_TO_BE
                
            if(!m_pDvdCtl2){
                
                throw(E_UNEXPECTED);
            }/* end of if statement */
            
            hr = m_pDvdCtl2->SetState(pBookmark, DVD_CMD_FLAG_Block| DVD_CMD_FLAG_Flush, 0);
        }

    }/* end of try statement */
    catch(HRESULT hrTmp){
        hr = hrTmp;
    }/* end of catch statement */
    catch(...){
        hr = E_UNEXPECTED;
    }/* end of catch statement */

	return HandleError(hr);
}/* end of function RestoreBookmark */

/*************************************************************************/
/* Function: DeleteBookmark                                               */
/* Description: Blasts the bookmark file away.                           */
/*************************************************************************/
STDMETHODIMP CMSWebDVD::DeleteBookmark(){

	HRESULT hr = S_OK;

    try {

        hr = CBookmark::DeleteFromRegistry();

    }/* end of try statement */
    catch(HRESULT hrTmp){
        hr = hrTmp;
    }/* end of catch statement */
    catch(...){
        hr = E_UNEXPECTED;
    }/* end of catch statement */

	return HandleError(hr);
}/* end of function DeleteBookmark */

/*************************************************************************/
/* CBookMark helper class implementation.                                */
/*************************************************************************/

/*************************************************************/
/* Name: SaveToRegistry
/* Description: Save the bookmark to registry
/*************************************************************/
HRESULT CBookmark::SaveToRegistry(IDvdState *pbookmark)
{
	IPersistMemory* pPersistMemory;
    HRESULT hr = pbookmark->QueryInterface(IID_IPersistMemory, (void **) &pPersistMemory );

    if (SUCCEEDED(hr)) {

		ULONG ulMax;
		hr = pPersistMemory->GetSizeMax( &ulMax );
		if( SUCCEEDED( hr )) {

			BYTE *buffer = new BYTE[ulMax];
			hr = pPersistMemory->Save( buffer, TRUE, ulMax );
            
            DWORD dwLen = ulMax;
            if (SUCCEEDED(hr)) {
                BOOL bSuccess = SetRegistryBytesCU(g_szBookmark, buffer, dwLen);
                if (!bSuccess)
                    hr = E_FAIL;
            }

            delete[] buffer; 
        }
		pPersistMemory->Release();
    } 
	return hr;
}

/*************************************************************/
/* Name: LoadFromRegistry
/* Description: load the bookmark from registry
/*************************************************************/
HRESULT CBookmark::LoadFromRegistry(IDvdState **ppBookmark)
{
	HRESULT hr = CoCreateInstance( CLSID_DVDState, NULL, CLSCTX_INPROC_SERVER, IID_IDvdState, (LPVOID*) ppBookmark );

	if( SUCCEEDED( hr )) {

		IPersistMemory* pPersistMemory;
		hr = (*ppBookmark)->QueryInterface(IID_IPersistMemory, (void **) &pPersistMemory );

        if( SUCCEEDED( hr )) {

            ULONG ulMax;
            hr = pPersistMemory->GetSizeMax( &ulMax );
            
            if (SUCCEEDED(hr)) {
                
                BYTE *buffer = new BYTE[ulMax];
                DWORD dwLen = ulMax;
                BOOL bFound = GetRegistryBytesCU(g_szBookmark, buffer, &dwLen);
           
                if (bFound && dwLen != 0){
                    hr = pPersistMemory->Load( buffer, dwLen);
                }
                else{
					dwLen = ulMax;
                    bFound = GetRegistryBytes(g_szBookmark, buffer, &dwLen);
                    if (bFound && dwLen != 0){
                        hr = pPersistMemory->Load( buffer, dwLen);
                        if(SUCCEEDED(hr)){
                            SetRegistryBytes(g_szBookmark, NULL, 0);
                        }
                    }
                    else{
                        hr = E_FAIL;
                    }
                }
                delete[] buffer; 

            }
            pPersistMemory->Release();
        }
	}
	return hr;
}

/*************************************************************/
/* Name: DeleteFromRegistry
/* Description: load the bookmark from registry
/*************************************************************/
HRESULT CBookmark::DeleteFromRegistry()
{
    HRESULT hr = S_OK;
    BOOL bSuccess = SetRegistryBytesCU(g_szBookmark, NULL, 0);
    if (!bSuccess)
        hr = E_FAIL;
    return hr;
}

/*************************************************************************/
/* End of file: Bookmark.cpp                                             */
/*************************************************************************/
=== C:/Users/treeman/Desktop/windows nt source code\Source\Win2K3\NT\multimedia\dshow\mfvideo\mswebdvd\capture.cpp ===
/*************************************************************************/
/* Copyright (C) 1999 Microsoft Corporation                              */
/* File: capture.cpp                                                     */
/* Description: Convert a captured DVD frame from YUV formats to RGB,    */
/*              and save to file in various formats.                     */
/* Author: phillu                                                        */
/*************************************************************************/

#include "stdafx.h"

#include "MSWebDVD.h"
#include "msdvd.h"
#include <shlobj.h>
#include "capture.h"


HRESULT WriteBitmapDataToJPEGFile(char * filename, CaptureBitmapData *bm);
HRESULT WriteBitmapDataToBMPFile(char * filename, CaptureBitmapData *bm);

// YUV FourCC Formats (byte-swapped). We support a subset of them.
// Ref: http://www.webartz.com/fourcc/

// packed formats
#define FourCC_IYU1     '1UYI'
#define FourCC_IYU2     '2UYI'
#define FourCC_UYVY     'YVYU'      // supported
#define FourCC_UYNV     'VNYU'      // supported
#define FourCC_cyuv     'vuyc'
#define FourCC_YUY2     '2YUY'      // supported
#define FourCC_YUNV     'VNUY'      // supported
#define FourCC_YVYU     'UYVY'      // supported
#define FourCC_Y41P     'P14Y'
#define FourCC_Y211     '112Y'
#define FourCC_Y41T     'T14Y'
#define FourCC_Y42T     'T24Y'
#define FourCC_CLJR     'RJLC'

// planar formats
#define FourCC_YVU9     '9UVY'
#define FourCC_IF09     '90FI'
#define FourCC_YV12     '21VY'      // supported
#define FourCC_I420     '024I'
#define FourCC_IYUV     'VUYI'
#define FourCC_CLPL     'LPLC'


extern CComModule _Module;

//
// Save image file
//

static HRESULT
SaveFileDialog(HWND hwnd, CaptureBitmapData *bmpdata)
{
    USES_CONVERSION;
    HRESULT hr = S_OK;
    OPENFILENAME ofn;
    TCHAR filename[MAX_PATH];
    TCHAR FolderPath[MAX_PATH];
    const ciBufSize = 256;
    TCHAR titlestring[ciBufSize];

    // get the path of "My Pictures" and use it as default location
    if (SHGetSpecialFolderPath(NULL, FolderPath, CSIDL_MYPICTURES, FALSE) == FALSE)
    {
        // if My Pictures doesn't exist, try My Documents
        if (SHGetSpecialFolderPath(NULL, FolderPath, CSIDL_PERSONAL, FALSE) == FALSE)
        {
            // use current directory as last resort
            lstrcpyn(FolderPath,  _T("."), sizeof(FolderPath) / sizeof(FolderPath[0]));
        }
    }

    ZeroMemory(&ofn, sizeof(ofn));

    ofn.lStructSize = sizeof(ofn);
    ofn.hwndOwner = hwnd;
    ofn.hInstance = _Module.m_hInstResource;
    ofn.lpstrFile = filename;
    ofn.lpstrDefExt = _T("jpg"); // it appears it doesn't matter what string to use
                       // it will use the ext in lpstrFilter according to selected type.
    ofn.nMaxFile = MAX_PATH;
    ::LoadString(_Module.m_hInstResource, IDS_SAVE_FILE, titlestring, ciBufSize);
    ofn.lpstrTitle = titlestring;
    ofn.lpstrInitialDir = FolderPath;
    ofn.Flags = OFN_CREATEPROMPT | OFN_OVERWRITEPROMPT | OFN_EXPLORER;
    lstrcpyn(filename, _T("capture"), sizeof(filename) / sizeof(filename[0]));

    // Make up the file type filter string

    TCHAR* filter = _T("JPEG\0*.JPG\0Windows Bitmap\0*.BMP\0");

    ofn.lpstrFilter = filter;
    ofn.nFilterIndex = 1; // set format to JPG as default

    // Present the file/save dialog

    if (GetSaveFileName(&ofn))
    {
        switch (ofn.nFilterIndex)
        {
        case 2:
            hr = WriteBitmapDataToBMPFile(T2A(filename), bmpdata);
            break;
        default:
            hr = WriteBitmapDataToJPEGFile(T2A(filename), bmpdata);
            break;
        }
    }

    return hr;
}


///////////////////////////////////////////////////////////////////////
// This block of code deals with converting YUV format to RGB bitmap
///////////////////////////////////////////////////////////////////////

static inline BYTE Clamp(float x)
{
    if (x < 0.0f)
        return 0;
    else if (x > 255.0f)
        return 255;
    else
        return (BYTE)(x + 0.5f);
}

// Convert YUV to RGB
static inline void ConvertPixelToRGB(int y, int u, int v, BYTE *pBuf)
{
    //
    // This equation was taken from Video Demystified (2nd Edition)
    // by Keith Jack, page 43.
    //

    BYTE red = Clamp((1.1644f * (y-16)) + (1.5960f * (v-128))                       );
    BYTE grn = Clamp((1.1644f * (y-16)) - (0.8150f * (v-128)) - (0.3912f * (u-128)));
    BYTE blu = Clamp((1.1644f * (y-16))                        + (2.0140f * (u-128)));

    // RGB format, 3 bytes per pixel

    pBuf[0] = red;
    pBuf[1] = grn;
    pBuf[2] = blu;
}

// Convert image in YUY2 format to RGB bitmap

static void ConvertYUY2ToBitmap(YUV_IMAGE* lpImage, CaptureBitmapData* bmpdata)
{
    long  y, x;
    BYTE *pYUVBits;
    BYTE *pRGB;

    for (y = 0; y < lpImage->lHeight; y++)
    {
        pYUVBits = (BYTE *)lpImage + sizeof(YUV_IMAGE) + y * lpImage->lStride;
        pRGB = (BYTE *)(bmpdata->Scan0) + y * bmpdata->Stride;

        for (x = 0; x < lpImage->lWidth; x += 2)
        {
            int  Y0 = (int) *pYUVBits++;
            int  U0 = (int) *pYUVBits++;
            int  Y1 = (int) *pYUVBits++;
            int  V0 = (int) *pYUVBits++;

            ConvertPixelToRGB(Y0, U0, V0, pRGB);
            pRGB += BYTES_PER_PIXEL;
            ConvertPixelToRGB(Y1, U0, V0, pRGB);
            pRGB += BYTES_PER_PIXEL;
        }
    }
}

// Convert image in UYVY format to RGB bitmap

static void ConvertUYVYToBitmap(YUV_IMAGE* lpImage, CaptureBitmapData* bmpdata)
{
    long  y, x;
    BYTE *pYUVBits;
    BYTE *pRGB;

    for (y = 0; y < lpImage->lHeight; y++)
    {
        pYUVBits = (BYTE *)lpImage + sizeof(YUV_IMAGE) + y * lpImage->lStride;
        pRGB = (BYTE *)(bmpdata->Scan0) + y * bmpdata->Stride;

        for (x = 0; x < lpImage->lWidth; x += 2)
        {
            int  U0 = (int) *pYUVBits++;
            int  Y0 = (int) *pYUVBits++;
            int  V0 = (int) *pYUVBits++;
            int  Y1 = (int) *pYUVBits++;

            ConvertPixelToRGB(Y0, U0, V0, pRGB);
            pRGB += BYTES_PER_PIXEL;
            ConvertPixelToRGB(Y1, U0, V0, pRGB);
            pRGB += BYTES_PER_PIXEL;
        }
    }
}

// Convert image in YVYU format to RGB bitmap

static void ConvertYVYUToBitmap(YUV_IMAGE* lpImage, CaptureBitmapData* bmpdata)
{
    long  y, x;
    BYTE *pYUVBits;
    BYTE *pRGB;

    for (y = 0; y < lpImage->lHeight; y++)
    {
        pYUVBits = (BYTE *)lpImage + sizeof(YUV_IMAGE) + y * lpImage->lStride;
        pRGB = (BYTE *)(bmpdata->Scan0) + y * bmpdata->Stride;

        for (x = 0; x < lpImage->lWidth; x += 2)
        {
            int  Y0 = (int) *pYUVBits++;
            int  V0 = (int) *pYUVBits++;
            int  Y1 = (int) *pYUVBits++;
            int  U0 = (int) *pYUVBits++;

            ConvertPixelToRGB(Y0, U0, V0, pRGB);
            pRGB += BYTES_PER_PIXEL;
            ConvertPixelToRGB(Y1, U0, V0, pRGB);
            pRGB += BYTES_PER_PIXEL;
        }
    }
}


// Convert image in YV12 format to RGB bitmap

static void ConvertYV12ToBitmap(YUV_IMAGE* lpImage, CaptureBitmapData* bmpdata)
{
    long  y, x;
    BYTE *pYBits;
    BYTE *pUBits;
    BYTE *pVBits;
    BYTE *pRGB;

    for (y = 0; y < lpImage->lHeight; y++)
    {
        pYBits = (BYTE *)lpImage + sizeof(YUV_IMAGE) + y * lpImage->lStride;
        pVBits = (BYTE *)lpImage + sizeof(YUV_IMAGE) + lpImage->lHeight * lpImage->lStride
                + (y/2) * (lpImage->lStride/2);
        pUBits = (BYTE *)lpImage + sizeof(YUV_IMAGE) + lpImage->lHeight * lpImage->lStride
                + ((lpImage->lHeight + y)/2) * (lpImage->lStride/2);

        pRGB = (BYTE *)(bmpdata->Scan0) + y * bmpdata->Stride;

        for (x = 0; x < lpImage->lWidth; x ++)
        {
            int  Y0 = (int) *pYBits++;
            int  V0 = (int) *pVBits;
            int  U0 = (int) *pUBits;

            // U, V are shared by 2x2 pixels. only advance pointers every two pixels

            if (x&1)
            {
                pVBits++;
                pUBits++;
            }

            ConvertPixelToRGB(Y0, U0, V0, pRGB);
            pRGB += BYTES_PER_PIXEL;
        }
    }
}

// Convert image in YVU9 format to RGB bitmap

static void ConvertYVU9ToBitmap(YUV_IMAGE* lpImage, CaptureBitmapData* bmpdata)
{
    long  y, x;
    BYTE *pYBits;
    BYTE *pUBits;
    BYTE *pVBits;
    BYTE *pRGB;

    for (y = 0; y < lpImage->lHeight; y++)
    {
        pYBits = (BYTE *)lpImage + sizeof(YUV_IMAGE) + y * lpImage->lStride;
        pVBits = (BYTE *)lpImage + sizeof(YUV_IMAGE) + lpImage->lHeight * lpImage->lStride
                + (y/4) * (lpImage->lStride/4);
        pUBits = (BYTE *)lpImage + sizeof(YUV_IMAGE) + lpImage->lHeight * lpImage->lStride
                + ((lpImage->lHeight + y)/4) * (lpImage->lStride/4);

        pRGB = (BYTE *)(bmpdata->Scan0) + y * bmpdata->Stride;

        for (x = 0; x < lpImage->lWidth; x ++)
        {
            int  Y0 = (int) *pYBits++;
            int  V0 = (int) *pVBits;
            int  U0 = (int) *pUBits;

            // U, V are shared by 4x4 pixels. only advance pointers every 4 pixels

            if ((x&3) == 3)
            {
                pVBits++;
                pUBits++;
            }

            ConvertPixelToRGB(Y0, U0, V0, pRGB);
            pRGB += BYTES_PER_PIXEL;
        }
    }
}


static HRESULT InitBitmapData(CaptureBitmapData *bmpdata, int Width, int Height)
{
    bmpdata->Width = Width;
    bmpdata->Height = Height;
    bmpdata->Stride = (BYTES_PER_PIXEL*Width + 3) & (~3); // align with word boundary
    bmpdata->Scan0 = new BYTE[Height * bmpdata->Stride];
    bmpdata->pBuffer = bmpdata->Scan0;

    if (NULL == bmpdata->Scan0)
    {
        return E_OUTOFMEMORY;
    }

    
    return S_OK;
}


static void FreeBitmapData(CaptureBitmapData *bmpdata)
{
    delete[] bmpdata->pBuffer;
    bmpdata->pBuffer = NULL;
    bmpdata->Scan0 = NULL;
}


static HRESULT ConvertToBitmapImage(YUV_IMAGE *lpImage, CaptureBitmapData *bmp)
{
    HRESULT hr = S_OK;

    // create a bitmap object

    hr = InitBitmapData(bmp, lpImage->lWidth, lpImage->lHeight);

    if (FAILED(hr))
    {
        return hr;
    }

    bool fSupported = true;

        // convert different types of YUV formats to RGB

    switch (lpImage->dwFourCC)
    {
    case FourCC_YUY2:
    case FourCC_YUNV:  // the two are equivalent
        ConvertYUY2ToBitmap(lpImage, bmp);
        break;

    case FourCC_UYVY:
    case FourCC_UYNV:  // equivalent
        ConvertUYVYToBitmap(lpImage, bmp);
        break;

    case FourCC_YVYU:
        ConvertYVYUToBitmap(lpImage, bmp);
        break;

    case FourCC_YV12:
        ConvertYV12ToBitmap(lpImage, bmp);
        break;

    case FourCC_YVU9:
        ConvertYVU9ToBitmap(lpImage, bmp);
        break;

    default:
        fSupported = false;
        break;
    }

    if (!fSupported)
    {
        hr = E_FORMAT_NOT_SUPPORTED;
    }

    return hr;
}


#ifdef _DEBUG
static void AlertUnsupportedFormat(DWORD dwFourCC, HWND hwnd)
{
    char buf[256];
    StringCchPrintf(buf, sizeof(buf), "YUV format %c%c%c%c not supported\n",
        dwFourCC & 0xff,
        (dwFourCC >> 8) & 0xff,
        (dwFourCC >> 16) & 0xff,
        (dwFourCC >> 24) & 0xff);
    MessageBoxA(hwnd, buf, "", MB_OK);
}
#endif


// This helper function does several things.
//
// First, it determines if clipping is necessary, return true if it is,
// and false otherwise.
//
// Second, it maps the ViewClipRect (clipping rect in the view coordinates,
// i.e. the one after correcting aspect ratio) back to the raw captured
// image coordinates. Return it in ImageClipRect. This step is skipped (and
// ImageClipRect will be invalid) if clipping is not necessary.
//
// Third, it calculates the stretched image size. It should be in the same
// aspect ratio as the ViewClipRect. It will also be made as full-size as possible

static bool ClipAndStretchSizes(YUV_IMAGE *lpImage, const RECT *pViewClipRect,
                         RECT *pImageClipRect, int *pViewWidth, int *pViewHeight)
{
    float aspectRaw = (float)lpImage->lHeight / (float)lpImage->lWidth;
    float aspectView = (float)lpImage->lAspectY / (float)lpImage->lAspectX;
    int viewWidth = lpImage->lWidth;
    int viewHeight = (int)(viewWidth * aspectView + 0.5f);

    // the rect is given in the stretched (aspect-ratio corrected) window
    // we will adjust it back to the raw image space

    bool fClip = false;

    if (pViewClipRect)
    {
        RECT rc;
        rc.left = pViewClipRect->left;
        rc.right = pViewClipRect->right;
        rc.top = (int)(pViewClipRect->top * aspectRaw / aspectView + 0.5f);
        rc.bottom = (int)(pViewClipRect->bottom * aspectRaw / aspectView + 0.5f);

        RECT rcFullImage;
        ::SetRect(&rcFullImage, 0, 0, lpImage->lWidth, lpImage->lHeight);

        if (! ::EqualRect(&rc, &rcFullImage) &&
            ::IntersectRect(pImageClipRect, &rc, &rcFullImage))
        {
            fClip = true;
        }
    }

    // adjust the stretched image size according to the rect aspect ratio

    if (fClip)
    {
        float aspectRect = (float)(RECTHEIGHT(pViewClipRect))
                            / (float)(RECTWIDTH(pViewClipRect));

        if (aspectRect < aspectView)
        {
            // clip rect has a wider aspect ratio.
            // keep the width, adjust the height

            viewHeight = (int)(viewWidth * aspectRect + 0.5f);
        }
        else
        {
            // clip rect has a taller aspect ratio.
            // keep the height, adjust width

            viewWidth = (int)(viewHeight / aspectRect + 0.5f);
        }
    }

    *pViewWidth = viewWidth;
    *pViewHeight = viewHeight;

    return fClip;
}


static HRESULT ClipBitmap(CaptureBitmapData *bmpdata, RECT *rect)
{
    HRESULT hr = S_OK;

    if (NULL == rect)
    {
        return S_OK;
    }

    bmpdata->Width = rect->right - rect->left;
    bmpdata->Height = rect->bottom - rect->top;
    //    bmpdata->Stride = bmpdata->Stride;
    bmpdata->Scan0 = bmpdata->Scan0 +
                     rect->top * bmpdata->Stride + (rect->left * BYTES_PER_PIXEL);

    return S_OK;
}


static HRESULT StretchBitmap(CaptureBitmapData *bmpdata, int newWidth, int newHeight)
{
    HRESULT hr = S_OK;
    int nX, nY, nX0, nY0, nX1, nY1;
    double dXRatio, dYRatio, dXCoor, dYCoor, dXR, dYR;
    double pdRGB0[3];
    double pdRGB1[3];
    BYTE *pRow0;
    BYTE *pRow1;
    BYTE *pPix0;
    BYTE *pPix1;
    BYTE *pDest;

    if (bmpdata->Width == newWidth && bmpdata->Height == newHeight)
    {
        return hr;
    }

    int newStride = (newWidth*BYTES_PER_PIXEL + 3) & (~3); // align with word boundary
    BYTE *pBuffer = new BYTE[newHeight * newStride];

    if (NULL == pBuffer)
    {
        return E_OUTOFMEMORY;
    }

    dXRatio = (double)(bmpdata->Width)/(double)(newWidth);
    dYRatio = (double)(bmpdata->Height)/(double)(newHeight);

    // bilinear stretching
    // Note this is not the most efficient algorithm as it uses a lot of floating calc
    // Nevertheless it is simple

    for (nY = 0; nY < newHeight; nY++)
    {
        // determine two coordinates along Y direction for interpolation

        dYCoor = (nY + 0.5)*dYRatio - 0.5;

        if (dYCoor < 0)
        {
            nY0 = nY1 = 0;
            dYR = 0.0;
        }
        else if (dYCoor >= bmpdata->Height - 1)
        {
            nY0 = nY1 = bmpdata->Height - 1;
            dYR = 0.0;
        }
        else
        {
            nY0 = (int)dYCoor;
            nY1 = nY0 + 1;
            dYR = dYCoor - nY0;
        }

        pRow0 = bmpdata->Scan0 + nY0 * bmpdata->Stride;
        pRow1 = bmpdata->Scan0 + nY1 * bmpdata->Stride;
        pDest = pBuffer + nY * newStride;

        for (nX = 0; nX < newWidth; nX++, pDest+=3)
        {
            // determine two coordinates along X direction for interpolation

            dXCoor = (nX + 0.5)*dXRatio - 0.5;

            if (dXCoor < 0)
            {
                nX0 = nX1 = 0;
                dXR = 0.0;
            }
            else if (dXCoor >= bmpdata->Width - 1)
            {
                nX0 = nX1 = bmpdata->Width - 1;
                dXR = 0.0;
            }
            else
            {
                nX0 = (int)dXCoor;
                nX1 = nX0 + 1;
                dXR = dXCoor - nX0;
            }

            // interpolate along X, in the upper row
            pPix0 = pRow0 + nX0 * BYTES_PER_PIXEL;
            pPix1 = pRow0 + nX1 * BYTES_PER_PIXEL;
            pdRGB0[0] = pPix0[0] + (pPix1[0] - pPix0[0])*dXR;
            pdRGB0[1] = pPix0[1] + (pPix1[1] - pPix0[1])*dXR;
            pdRGB0[2] = pPix0[2] + (pPix1[2] - pPix0[2])*dXR;

            // interpolate along X, in the lower row
            pPix0 = pRow1 + nX0 * BYTES_PER_PIXEL;
            pPix1 = pRow1 + nX1 * BYTES_PER_PIXEL;
            pdRGB1[0] = pPix0[0] + (pPix1[0] - pPix0[0])*dXR;
            pdRGB1[1] = pPix0[1] + (pPix1[1] - pPix0[1])*dXR;
            pdRGB1[2] = pPix0[2] + (pPix1[2] - pPix0[2])*dXR;

            // interpolate along Y
            pDest[0] = (BYTE)(pdRGB0[0] + (pdRGB1[0] - pdRGB0[0])*dYR + 0.5);
            pDest[1] = (BYTE)(pdRGB0[1] + (pdRGB1[1] - pdRGB0[1])*dYR + 0.5);
            pDest[2] = (BYTE)(pdRGB0[2] + (pdRGB1[2] - pdRGB0[2])*dYR + 0.5);
        }
    }

    // replace the bitmap buffer

    delete[] bmpdata->pBuffer;
    bmpdata->pBuffer = bmpdata->Scan0 = pBuffer;
    bmpdata->Stride = newStride;
    bmpdata->Width = newWidth;
    bmpdata->Height = newHeight;

    return hr;
}


/////////////////////////////////////////////////////////////////////////////
//
// ConvertImageAndSave: this is the main function to be called by the player.
//
// Convert a captured YUV image to a GDI BitmapImage, and save it to a file
// allowing user to choose file format and file name.

// The clipping rectangle should be in the full size view coordinate system
// with corrected aspect ratio (i.e. 720x540 for 4:3).

HRESULT ConvertImageAndSave(YUV_IMAGE *lpImage, RECT *pViewClipRect, HWND hwnd)
{
    HRESULT hr = S_OK;
    CaptureBitmapData bmpdata;

    hr = ConvertToBitmapImage(lpImage, &bmpdata);


#ifdef _DEBUG
    if (E_FORMAT_NOT_SUPPORTED == hr)
    {
        AlertUnsupportedFormat(lpImage->dwFourCC, hwnd);
    }
#endif


    // calculate size and rectangles for clipping and stretching

    int viewWidth, viewHeight; // size of the clipped and stretch image
    bool fClip;  // is clipping necessary
    RECT rcClipImage;  // view clipping rect mapped to image space

    fClip = ClipAndStretchSizes(lpImage, pViewClipRect, &rcClipImage,
                                &viewWidth, &viewHeight);

    // crop the image to the clip rectangle.

    if (SUCCEEDED(hr) && fClip)
    {
        hr = ClipBitmap(&bmpdata, &rcClipImage);
    }

    // stretch the image to the right aspect ratio

    if (SUCCEEDED(hr))
    {
        hr = StretchBitmap(&bmpdata, viewWidth, viewHeight);
    }

    // save final bitmap to a file

    if (SUCCEEDED(hr))
    {
        hr = SaveFileDialog(hwnd, &bmpdata);
    }

    // clean up, release the image buffer

    FreeBitmapData(&bmpdata);

    return hr;
}
=== C:/Users/treeman/Desktop/windows nt source code\Source\Win2K3\NT\multimedia\dshow\mfvideo\mswebdvd\capture_gdi.cpp ===
/*************************************************************************/
/* Copyright (C) 1999 Microsoft Corporation                              */
/* File: capture.cpp                                                     */
/* Description: Convert a captured DVD frame from YUV formats to RGB,    */
/*              and save to file in various formats.                     */
/* Author: phillu                                                        */
/*************************************************************************/

#include "stdafx.h"

// This version of capture is for Millennium where GDI+ is installed

#include "MSWebDVD.h"
#include "msdvd.h"
#include <initguid.h>
#include "imaging.h"
#include <shlobj.h>

// YUV FourCC Formats (byte-swapped). We support a subset of them.
// Ref: http://www.webartz.com/fourcc/

// packed formats
#define FourCC_IYU1     '1UYI'
#define FourCC_IYU2     '2UYI'
#define FourCC_UYVY     'YVYU'      // supported
#define FourCC_UYNV     'VNYU'      // supported
#define FourCC_cyuv     'vuyc'
#define FourCC_YUY2     '2YUY'      // supported
#define FourCC_YUNV     'VNUY'      // supported
#define FourCC_YVYU     'UYVY'      // supported
#define FourCC_Y41P     'P14Y'
#define FourCC_Y211     '112Y'
#define FourCC_Y41T     'T14Y'
#define FourCC_Y42T     'T24Y'
#define FourCC_CLJR     'RJLC'

// planar formats
#define FourCC_YVU9     '9UVY'
#define FourCC_IF09     '90FI'
#define FourCC_YV12     '21VY'      // supported
#define FourCC_I420     '024I'
#define FourCC_IYUV     'VUYI'
#define FourCC_CLPL     'LPLC'

// global variables

IImagingFactory* g_pImgFact = NULL;   // pointer to IImageingFactory object

// helper: calls release on a Non-NULL pointer, and sets it to NULL
#define SAFE_RELEASE(ptr)       \
{                               \
	if (ptr)					\
	{							\
		ptr->Release();			\
		ptr	= NULL;				\
	}							\
}

extern CComModule _Module;

///////////////////////////////////////////////////////////////////////////
// This block of code handles saving a GDI+ image object to a file,
// allowing user to select a format.
///////////////////////////////////////////////////////////////////////////


//
// Save the current image to a file
//

static HRESULT
SaveImageFile(IImage *pImage, const TCHAR* filename, const CLSID* clsid)
{
    USES_CONVERSION;
    HRESULT hr = S_OK;

    if (!pImage || !g_pImgFact)
        return E_FAIL;

    // Create an encoder object

    IImageEncoder* encoder = NULL;
    hr = g_pImgFact->CreateImageEncoderToFile(clsid, T2CW(filename), &encoder);

    if (FAILED(hr))
        return hr;

    // Get an IImageSink interface to the encoder

    IImageSink* sink = NULL;

    hr = encoder->GetEncodeSink(&sink);

    if (SUCCEEDED(hr))
    {
        hr = pImage->PushIntoSink(sink);
        SAFE_RELEASE(sink);
    }

    encoder->TerminateEncoder();
    SAFE_RELEASE(encoder);

    return hr;
}


//
// Compose a file type filter string given an array of
// ImageCodecInfo structures; also find the index of JPG format
//

static TCHAR* 
MakeFilterFromCodecs(UINT count, const ImageCodecInfo* codecs, UINT *jpgIndex)
{
    USES_CONVERSION;
    
    // Figure out the total size of the filter string

    UINT index, size;

    for (index=size=0; index < count; index++)
    {
        size += wcslen(codecs[index].FormatDescription) + 1
                + wcslen(codecs[index].FilenameExtension) + 1;
    }

    size += 1; // for the double trailing '\0'

    // Allocate memory

    TCHAR *filter = (TCHAR*) malloc(size*sizeof(TCHAR));
    UINT strSize = size;
    if (!filter)
        return NULL;

    TCHAR* p = filter;
    const WCHAR* ws;
    *jpgIndex = 0;
    LPCTSTR strTemp = NULL;

    for (index=0; index < count; index++)
    {
        ws = codecs[index].FormatDescription;
        size = wcslen(ws) + 1;
        strTemp = W2CT(ws);
        if (NULL != strTemp)
        {
            lstrcpyn(p, strTemp, strSize - lstrlen(p));
            p += size;
        }

        ws = codecs[index].FilenameExtension;
        size = wcslen(ws) + 1;
        strTemp = W2CT(ws);
        if (NULL != strTemp)
        {
            lstrcpyn(p, strTemp, strSize - lstrlen(p));
            p += size;
        }

        // find the index of jpg format
        if (wcsstr(ws, L"JPG"))
        {
            *jpgIndex = index + 1;
        }
    }

    *((TCHAR*) p) = _T('\0');

    return filter;
}

//
// Save image file
//

static HRESULT 
SaveFileDialog(HWND hwnd, IImage *pImage)
{
    USES_CONVERSION;
    HRESULT hr = S_OK;
    OPENFILENAME ofn;
    TCHAR filename[MAX_PATH];
    TCHAR FolderPath[MAX_PATH];
    const ciBufSize = 256;
    TCHAR titlestring[ciBufSize];

    // get the path of "My Pictures" and use it as default location
    if (SHGetSpecialFolderPath(NULL, FolderPath, CSIDL_MYPICTURES, FALSE) == FALSE)
    {
        // if My Pictures doesn't exist, try My Documents
        
        if (SHGetSpecialFolderPath(NULL, FolderPath, CSIDL_PERSONAL, FALSE) == FALSE)
        { 
            // use current directory as last resort
            lstrcpyn(FolderPath, _T("."), sizeof(FolderPath) / sizeof(FolderPath[0]));
        }
    }

    ZeroMemory(&ofn, sizeof(ofn));

    ofn.lStructSize = sizeof(ofn);
    ofn.hwndOwner = hwnd;
    ofn.hInstance = _Module.m_hInstResource;
    ofn.lpstrFile = filename;
    ofn.lpstrDefExt = _T("jpg"); // it appears it doesn't matter what string to use
                       // it will use the ext in lpstrFilter according to selected type.
    ofn.nMaxFile = MAX_PATH;
    ::LoadString(_Module.m_hInstResource, IDS_SAVE_FILE, titlestring, ciBufSize);
    ofn.lpstrTitle = titlestring;
    ofn.lpstrInitialDir = FolderPath;
    ofn.Flags = OFN_CREATEPROMPT | OFN_OVERWRITEPROMPT | OFN_EXPLORER;
    lstrcpyn(filename, _T("capture"), sizeof(filename) / sizeof(filename[0]));

    // Make up the file type filter string

    ImageCodecInfo* codecs;
    UINT count;

    hr = g_pImgFact->GetInstalledEncoders(&count, &codecs);

    if (FAILED(hr))
        return hr;

    UINT jpgIndex;
    TCHAR* filter = MakeFilterFromCodecs(count, codecs, &jpgIndex);

    if (!filter)
    {
        hr = HRESULT_FROM_WIN32(GetLastError());
        return hr;
    }
    else
    {
        ofn.lpstrFilter = filter;
        ofn.nFilterIndex = jpgIndex; // set format to JPG as default

        // Present the file/save dialog

        if (GetSaveFileName(&ofn))
        {
            UINT index = ofn.nFilterIndex;

            if (index == 0 || index > count)
                index = 0;
            else
                index--;

            hr = SaveImageFile(pImage, filename, &codecs[index].Clsid);
        }   

        free(filter);
    } 

    CoTaskMemFree(codecs);

    return hr;
}


///////////////////////////////////////////////////////////////////////
// This block of code deals with converting YUV format to RGB bitmap
///////////////////////////////////////////////////////////////////////

inline BYTE Clamp(float x)
{
    if (x < 0.0f)
        return 0;
    else if (x > 255.0f)
        return 255;
    else
        return (BYTE)(x + 0.5f);
}

// Convert YUV to ARGB
static inline ARGB ConvertPixelToARGB(int y, int u, int v)
{
    //
    // This equation was taken from Video Demystified (2nd Edition)
    // by Keith Jack, page 43.
    //

    BYTE red = Clamp((1.1644f * (y-16)) + (1.5960f * (v-128))                       );
    BYTE grn = Clamp((1.1644f * (y-16)) - (0.8150f * (v-128)) - (0.3912f * (u-128)));
    BYTE blu = Clamp((1.1644f * (y-16))                        + (2.0140f * (u-128)));

    return MAKEARGB(0xff, red, grn, blu);
}

// Convert image in YUY2 format to RGB bitmap

static void ConvertYUY2ToBitmap(YUV_IMAGE* lpImage, BitmapData* bmpdata)
{
    long  y, x;
    BYTE *pYUVBits;
    ARGB *pARGB;

    for (y = 0; y < lpImage->lHeight; y++) 
    {
        pYUVBits = (BYTE *)lpImage + sizeof(YUV_IMAGE) + y * lpImage->lStride;
        pARGB = (ARGB *)((BYTE *)(bmpdata->Scan0) + y * bmpdata->Stride);

        for (x = 0; x < lpImage->lWidth; x += 2) 
        {
            int  Y0 = (int) *pYUVBits++;
            int  U0 = (int) *pYUVBits++;
            int  Y1 = (int) *pYUVBits++;
            int  V0 = (int) *pYUVBits++;

            *pARGB++ = ConvertPixelToARGB(Y0, U0, V0);
            *pARGB++ = ConvertPixelToARGB(Y1, U0, V0);
        }
    }
}

// Convert image in UYVY format to RGB bitmap

static void ConvertUYVYToBitmap(YUV_IMAGE* lpImage, BitmapData* bmpdata)
{
    long  y, x;
    BYTE *pYUVBits;
    ARGB *pARGB;

    for (y = 0; y < lpImage->lHeight; y++) 
    {
        pYUVBits = (BYTE *)lpImage + sizeof(YUV_IMAGE) + y * lpImage->lStride;
        pARGB = (ARGB *)((BYTE *)(bmpdata->Scan0) + y * bmpdata->Stride);

        for (x = 0; x < lpImage->lWidth; x += 2) 
        {
            int  U0 = (int) *pYUVBits++;
            int  Y0 = (int) *pYUVBits++;
            int  V0 = (int) *pYUVBits++;
            int  Y1 = (int) *pYUVBits++;

            *pARGB++ = ConvertPixelToARGB(Y0, U0, V0);
            *pARGB++ = ConvertPixelToARGB(Y1, U0, V0);
        }
    }
}

// Convert image in YVYU format to RGB bitmap

static void ConvertYVYUToBitmap(YUV_IMAGE* lpImage, BitmapData* bmpdata)
{
    long  y, x;
    BYTE *pYUVBits;
    ARGB *pARGB;

    for (y = 0; y < lpImage->lHeight; y++) 
    {
        pYUVBits = (BYTE *)lpImage + sizeof(YUV_IMAGE) + y * lpImage->lStride;
        pARGB = (ARGB *)((BYTE *)(bmpdata->Scan0) + y * bmpdata->Stride);

        for (x = 0; x < lpImage->lWidth; x += 2) 
        {
            int  Y0 = (int) *pYUVBits++;
            int  V0 = (int) *pYUVBits++;
            int  Y1 = (int) *pYUVBits++;
            int  U0 = (int) *pYUVBits++;

            *pARGB++ = ConvertPixelToARGB(Y0, U0, V0);
            *pARGB++ = ConvertPixelToARGB(Y1, U0, V0);
        }
    }
}


// Convert image in YV12 format to RGB bitmap

static void ConvertYV12ToBitmap(YUV_IMAGE* lpImage, BitmapData* bmpdata)
{
    long  y, x;
    BYTE *pYBits;
    BYTE *pUBits;
    BYTE *pVBits;
    ARGB *pARGB;

    for (y = 0; y < lpImage->lHeight; y++) 
    {
        pYBits = (BYTE *)lpImage + sizeof(YUV_IMAGE) + y * lpImage->lStride;
        pVBits = (BYTE *)lpImage + sizeof(YUV_IMAGE) + lpImage->lHeight * lpImage->lStride
                + (y/2) * (lpImage->lStride/2);
        pUBits = (BYTE *)lpImage + sizeof(YUV_IMAGE) + lpImage->lHeight * lpImage->lStride
                + ((lpImage->lHeight + y)/2) * (lpImage->lStride/2);

        pARGB = (ARGB *)((BYTE *)(bmpdata->Scan0) + y * bmpdata->Stride);

        for (x = 0; x < lpImage->lWidth; x ++) 
        {
            int  Y0 = (int) *pYBits++;
            int  V0 = (int) *pVBits;
            int  U0 = (int) *pUBits;

            // U, V are shared by 2x2 pixels. only advance pointers every two pixels

            if (x&1)
            {
                pVBits++;
                pUBits++;
            }

            *pARGB++ = ConvertPixelToARGB(Y0, U0, V0);
        }
    }
}

// Convert image in YVU9 format to RGB bitmap

static void ConvertYVU9ToBitmap(YUV_IMAGE* lpImage, BitmapData* bmpdata)
{
    long  y, x;
    BYTE *pYBits;
    BYTE *pUBits;
    BYTE *pVBits;
    ARGB *pARGB;

    for (y = 0; y < lpImage->lHeight; y++) 
    {
        pYBits = (BYTE *)lpImage + sizeof(YUV_IMAGE) + y * lpImage->lStride;
        pVBits = (BYTE *)lpImage + sizeof(YUV_IMAGE) + lpImage->lHeight * lpImage->lStride
                + (y/4) * (lpImage->lStride/4);
        pUBits = (BYTE *)lpImage + sizeof(YUV_IMAGE) + lpImage->lHeight * lpImage->lStride
                + ((lpImage->lHeight + y)/4) * (lpImage->lStride/4);

        pARGB = (ARGB *)((BYTE *)(bmpdata->Scan0) + y * bmpdata->Stride);

        for (x = 0; x < lpImage->lWidth; x ++) 
        {
            int  Y0 = (int) *pYBits++;
            int  V0 = (int) *pVBits;
            int  U0 = (int) *pUBits;

            // U, V are shared by 4x4 pixels. only advance pointers every 4 pixels

            if ((x&3) == 3)
            {
                pVBits++;
                pUBits++;
            }

            *pARGB++ = ConvertPixelToARGB(Y0, U0, V0);
        }
    }
}


static HRESULT ConvertToBitmapImage(YUV_IMAGE *lpImage, IBitmapImage **bmp)
{
    IBitmapImage* bmpimg = NULL;
    BitmapData bmpdata;
    HRESULT hr = S_OK;

    // create a bitmap object

    if (!g_pImgFact || bmp == NULL)
    {
        return E_FAIL;
    }

    hr = g_pImgFact->CreateNewBitmap(
                lpImage->lWidth,
                lpImage->lHeight,
                PIXFMT_32BPP_ARGB,
                &bmpimg);

    bool fSupported = true;

    if (SUCCEEDED(hr)) // bmpimg created
    {
        hr = bmpimg->LockBits(
                    NULL,
                    IMGLOCK_WRITE,
                    PIXFMT_DONTCARE,
                    &bmpdata);

        if (SUCCEEDED(hr))
        {
            // convert different types of YUV formats to RGB

            switch (lpImage->dwFourCC) 
            {
            case FourCC_YUY2:
            case FourCC_YUNV:  // the two are equivalent
                ConvertYUY2ToBitmap(lpImage, &bmpdata);
                break;

            case FourCC_UYVY:
            case FourCC_UYNV:  // equivalent
                ConvertUYVYToBitmap(lpImage, &bmpdata);
                break;

            case FourCC_YVYU:
                ConvertYVYUToBitmap(lpImage, &bmpdata);
                break;

            case FourCC_YV12:
                ConvertYV12ToBitmap(lpImage, &bmpdata);
                break;

            case FourCC_YVU9:
                ConvertYVU9ToBitmap(lpImage, &bmpdata);
                break;

            default:
                fSupported = false;
                break;
            }

            hr = bmpimg->UnlockBits(&bmpdata);
        }

        if (!fSupported)
        {
            SAFE_RELEASE(bmpimg);
            hr = E_FORMAT_NOT_SUPPORTED;
        }
    }

    *bmp = bmpimg;
    // Addref() and Release() cancels out
    bmpimg = NULL;

    return hr;
}


#ifdef _DEBUG
static void AlertUnsupportedFormat(DWORD dwFourCC, HWND hwnd)
{
    char buf[256];
    StringCchPrintf(buf, sizeof(buf), "YUV format %c%c%c%c not supported\n",
        dwFourCC & 0xff, 
        (dwFourCC >> 8) & 0xff,
        (dwFourCC >> 16) & 0xff, 
        (dwFourCC >> 24) & 0xff);
    MessageBoxA(hwnd, buf, "", MB_OK);
}
#endif


// This helper function does several things.
//
// First, it determines if clipping is necessary, return true if it is,
// and false otherwise.
// 
// Second, it maps the ViewClipRect (clipping rect in the view coordinates,
// i.e. the one after correcting aspect ratio) back to the raw captured
// image coordinates. Return it in ImageClipRect. This step is skipped (and
// ImageClipRect will be invalid) if clipping is not necessary.
//
// Third, it calculates the stretched image size. It should be in the same
// aspect ratio as the ViewClipRect. It will also be made as full-size as possible

static bool ClipAndStretchSizes(YUV_IMAGE *lpImage, const RECT *pViewClipRect,
                         RECT *pImageClipRect, int *pViewWidth, int *pViewHeight)
{
    float aspectRaw = (float)lpImage->lHeight / (float)lpImage->lWidth;
    float aspectView = (float)lpImage->lAspectY / (float)lpImage->lAspectX;
    int viewWidth = lpImage->lWidth;
    int viewHeight = (int)(viewWidth * aspectView + 0.5f);

    // the rect is given in the stretched (aspect-ratio corrected) window
    // we will adjust it back to the raw image space
    
    bool fClip = false;

    if (pViewClipRect)
    {
        RECT rc;
        rc.left = pViewClipRect->left;
        rc.right = pViewClipRect->right;
        rc.top = (int)(pViewClipRect->top * aspectRaw / aspectView + 0.5f);
        rc.bottom = (int)(pViewClipRect->bottom * aspectRaw / aspectView + 0.5f);

        RECT rcFullImage;
        ::SetRect(&rcFullImage, 0, 0, lpImage->lWidth, lpImage->lHeight);

        if (! ::EqualRect(&rc, &rcFullImage) &&
            ::IntersectRect(pImageClipRect, &rc, &rcFullImage))
        {
            fClip = true;
        }
    }

    // adjust the stretched image size according to the rect aspect ratio

    if (fClip)
    {
        float aspectRect = (float)(RECTHEIGHT(pViewClipRect)) 
                            / (float)(RECTWIDTH(pViewClipRect));

        if (aspectRect < aspectView)
        {
            // clip rect has a wider aspect ratio.
            // keep the width, adjust the height

            viewHeight = (int)(viewWidth * aspectRect + 0.5f);
        }
        else
        {
            // clip rect has a taller aspect ratio.
            // keep the height, adjust width

            viewWidth = (int)(viewHeight / aspectRect + 0.5f);
        }
    }

    *pViewWidth = viewWidth;
    *pViewHeight = viewHeight;

    return fClip;
}


/////////////////////////////////////////////////////////////////////////////
//
// ConvertImageAndSave: this is the main function to be called by the player.
// 
// Convert a captured YUV image to a GDI BitmapImage, and save it to a file
// allowing user to choose file format and file name.

// The clipping rectangle should be in the full size view coordinate system
// with corrected aspect ratio (i.e. 720x540 for 4:3).

HRESULT GDIConvertImageAndSave(YUV_IMAGE *lpImage, RECT *pViewClipRect, HWND hwnd)
{
    IBitmapImage* bmpimg = NULL;
    IBitmapImage* bmpStretched = NULL;
    HRESULT hr = S_OK;
    
    // Create an IImagingFactory object
     
    hr = CoCreateInstance(
            CLSID_ImagingFactory,
            NULL,
            CLSCTX_INPROC_SERVER,
            IID_IImagingFactory,
            (VOID**) &g_pImgFact);

    if (FAILED(hr))
    {
        return hr;
    }

    hr = ConvertToBitmapImage(lpImage, &bmpimg);
    
#ifdef _DEBUG
    if (E_FORMAT_NOT_SUPPORTED == hr)
    {
        AlertUnsupportedFormat(lpImage->dwFourCC, hwnd);
    }
#endif


    // calculate size and rectangles for clipping and stretching

    int viewWidth, viewHeight; // size of the clipped and stretch image
    bool fClip;  // is clipping necessary
    RECT rcClipImage;  // view clipping rect mapped to image space

    fClip = ClipAndStretchSizes(lpImage, pViewClipRect, &rcClipImage,
                                &viewWidth, &viewHeight);

    // crop the image to the clip rectangle.

    if (SUCCEEDED(hr) && fClip) // by now we have valid bits in bmpimg
    {
        IBasicBitmapOps *bmpops = NULL;
        IBitmapImage* bmpClipped = NULL;

        hr = bmpimg->QueryInterface(IID_IBasicBitmapOps, (VOID**) &bmpops);

        if (SUCCEEDED(hr))
        {
            hr = bmpops->Clone(&rcClipImage, &bmpClipped);
            SAFE_RELEASE(bmpops);
        }

        if (SUCCEEDED(hr)) // valid bmpClipped
        {
            // replace bmpimg with bmpClipped

            SAFE_RELEASE(bmpimg);
            bmpimg = bmpClipped;
            bmpimg->AddRef();
            SAFE_RELEASE(bmpClipped);
        }
    }

    // stretch the image to the right aspect ratio

    if (SUCCEEDED(hr)) // valid bits in bmpimg
    {
        IImage *image = NULL;

        hr = bmpimg->QueryInterface(IID_IImage, (VOID**) &image);

        if (SUCCEEDED(hr))
        {
            hr = g_pImgFact->CreateBitmapFromImage(
                        image,
                        viewWidth, 
                        viewHeight,
                        PIXFMT_DONTCARE, 
                        INTERP_BILINEAR, 
                        &bmpStretched);
    
            SAFE_RELEASE(image);
        }

        SAFE_RELEASE(bmpimg);
    }

    // save final bitmap to a file

    if (SUCCEEDED(hr)) // bmpStretched valid
    {
        IImage *image = NULL;

        hr = bmpStretched->QueryInterface(IID_IImage, (VOID**) &image);

        if (SUCCEEDED(hr))
        {
            hr = SaveFileDialog(hwnd, image);
            SAFE_RELEASE(image);
        }

        SAFE_RELEASE(bmpStretched);
    } 

    // clean up, release the imaging factory

    SAFE_RELEASE(g_pImgFact);

    return hr;
}
=== C:/Users/treeman/Desktop/windows nt source code\Source\Win2K3\NT\multimedia\dshow\mfvideo\mswebdvd\ddrawobj.cpp ===
#include "stdafx.h"
#include "mswebdvd.h"
#include "msdvd.h"
#include "ddrawobj.h"
//
// CDDrawDVD constructor
//
CDDrawDVD::CDDrawDVD(CMSWebDVD *pDVD)
{
    m_pDVD = pDVD;

    // Default colors to be used for filling
    m_VideoKeyColor = RGB(255, 0, 255) ;

    m_pOverlayCallback = new CComObject<COverlayCallback> ;
    
    CComVariant vData;
    vData.vt = VT_VOID;
    vData.byref = this;
    if(m_pOverlayCallback){
        m_pOverlayCallback->SetDDrawDVD(vData);
    }
}


//
// CDDrawDVD destructor
//
CDDrawDVD::~CDDrawDVD(void)
{
}

/*************************************************************************/
/* Function: SetupDDraw                                                  */
/* Description: Creates DDrawObject and Surface                          */
/*************************************************************************/
HRESULT CDDrawDVD::SetupDDraw(const AMDDRAWGUID* lpDDGUID, HWND hwnd){

    // DO NOT CALL TWICE !!!
    // WILL CRASH OV MIXER DJ
    HRESULT hr = E_UNEXPECTED;
        
    if(!::IsWindow(hwnd)){
        
        return(hr);
    }/* end of if statement */

    m_pDDObject.Release();
    hr = ::DirectDrawCreate(lpDDGUID->lpGUID, &m_pDDObject, NULL);
    
    if(FAILED(hr)){

        return(hr);
    }/* end of if statement */

    hr = m_pDDObject->SetCooperativeLevel(hwnd, DDSCL_NORMAL);

    if(FAILED(hr)){

        m_pDDObject.Release();            
        return(hr);
    }/* end of if statement */

    DDSURFACEDESC ddsd;
    ::ZeroMemory(&ddsd, sizeof(ddsd));
    ddsd.dwSize = sizeof(ddsd);

    ddsd.dwFlags = DDSD_CAPS;
    ddsd.ddsCaps.dwCaps = DDSCAPS_PRIMARYSURFACE;

    m_pPrimary.Release();
    hr = m_pDDObject->CreateSurface(&ddsd, &m_pPrimary, NULL);

    if(FAILED(hr)){
        
        m_pDDObject.Release();            
        return(hr);
    }/* end of if statement */

    CComPtr<IDirectDrawClipper> pClipper;
    
    hr = m_pDDObject->CreateClipper(0, &pClipper, NULL);

    if(FAILED(hr)){
        
        m_pPrimary.Release();
        m_pDDObject.Release();            
        
        return(hr);
    }/* end of if statement */

    hr = pClipper->SetHWnd(0, hwnd);

    if(FAILED(hr)){

        m_pPrimary.Release();            
        m_pDDObject.Release();            
        pClipper.Release();            
        return(hr);
    }/* end of if statement */


    hr = m_pPrimary->SetClipper(pClipper);

	if (FAILED(hr)){

        m_pPrimary.Release();        
        m_pDDObject.Release();            
        pClipper.Release();            
        return(hr);
	}/* end of if statement */

	/*
	 * We release the clipper interface after attaching it to the surface
	 * as we don't need to use it again and the surface holds a reference
	 * to the clipper when its been attached. The clipper will therefore
	 * be released when the surface is released.
	 */
	pClipper.Release();

    return(hr);
}/* end of function SetupDDraw */

/*************************************************************/
/* Name: 
/* Description: 
/*************************************************************/
HRESULT CDDrawDVD::SetColorKey(COLORREF colorKey)
{
    m_VideoKeyColor = colorKey;

    // if 256 color mode, force to set back to magenta
    HWND hwnd = ::GetDesktopWindow();
    HDC hdc = ::GetWindowDC(hwnd);

    if(NULL == hdc){

        return(E_UNEXPECTED);
    }/* end of if statement */

    HRESULT hr = S_OK;

    if ((::GetDeviceCaps(hdc, RASTERCAPS) & RC_PALETTE) == RC_PALETTE)
    {   
        if (m_VideoKeyColor != MAGENTA_COLOR_KEY) {
            hr = m_pDVD->put_ColorKey(MAGENTA_COLOR_KEY);
            if (SUCCEEDED(hr)) 
                m_VideoKeyColor = MAGENTA_COLOR_KEY;
        }
    }

    ::ReleaseDC(hwnd, hdc);
    return hr ;
}

/*************************************************************/
/* Name: 
/* Description: 
/*************************************************************/
COLORREF CDDrawDVD::GetColorKey()
{
     // if 256 color mode, force to set back to magenta
    HWND hwnd = ::GetDesktopWindow();
    HDC hdc = ::GetWindowDC(hwnd);

    if(NULL == hdc){

        return(E_UNEXPECTED);
    }/* end of if statement */

    if ((::GetDeviceCaps(hdc, RASTERCAPS) & RC_PALETTE) == RC_PALETTE)
    {   
        if (m_VideoKeyColor != MAGENTA_COLOR_KEY) {

            if (SUCCEEDED(m_pDVD->put_ColorKey(MAGENTA_COLOR_KEY)))
                m_VideoKeyColor = MAGENTA_COLOR_KEY;
        }
    }
    
    ::ReleaseDC(hwnd, hdc);
    return m_VideoKeyColor;
}

/*************************************************************************/
/* Function: HasOverlay                                                  */
/* Description: Tells us if the video card support overlay.              */
/*************************************************************************/
HRESULT CDDrawDVD::HasOverlay(){

    HRESULT hr = S_OK;

    if(!m_pDDObject){

        return(E_UNEXPECTED);
    }/* end of if statement */

    DDCAPS caps;

    ::ZeroMemory(&caps, sizeof(DDCAPS));

     caps.dwSize = sizeof(DDCAPS);

    hr = m_pDDObject->GetCaps(&caps, NULL);

    if(FAILED(hr)){

        return(hr);
    }/* end of if statement */

    if(caps.dwMaxVisibleOverlays > 0){

        hr = S_OK;
    }
    else {

        hr = S_FALSE;
    }/* end of if statement */    
    
    return(hr);
}/* end of function HasOverlay */

/*************************************************************************/
/* Function: HasAvailableOverlay                                         */
/* Description: Tells us if the overlay is used.                         */
/*************************************************************************/
HRESULT CDDrawDVD::HasAvailableOverlay(){

    HRESULT hr = S_OK;

    if(!m_pDDObject){

        return(E_UNEXPECTED);
    }/* end of if statement */

    DDCAPS caps;

    ::ZeroMemory(&caps, sizeof(DDCAPS));

     caps.dwSize = sizeof(DDCAPS);

    hr = m_pDDObject->GetCaps(&caps, NULL);

    if(FAILED(hr)){

        return(hr);
    }/* end of if statement */
   
    if((caps.dwMaxVisibleOverlays > 0) && (caps.dwMaxVisibleOverlays > caps.dwCurrVisibleOverlays)){

        hr = S_OK;
    }
    else {

        hr = S_FALSE;
    }/* end of if statement */    
    
    return(hr);
}/* end of function HasAvailableOverlay */

/*************************************************************************/
/* Function: GetOverlayMaxStretch                                        */
/* Description: Tells us the maximum stretch factors of overlay.         */
/*************************************************************************/
HRESULT CDDrawDVD::GetOverlayMaxStretch(DWORD *pdwMaxStretch){

    HRESULT hr = S_OK;

    if(!m_pDDObject){

        return(E_UNEXPECTED);
    }/* end of if statement */

    DDCAPS caps;

    ::ZeroMemory(&caps, sizeof(DDCAPS));

     caps.dwSize = sizeof(DDCAPS);

    hr = m_pDDObject->GetCaps(&caps, NULL);

    if(FAILED(hr)){

        return(hr);
    }/* end of if statement */

    if (caps.dwCaps & DDCAPS_OVERLAYSTRETCH && caps.dwMaxOverlayStretch!=0) {
        *pdwMaxStretch = caps.dwMaxOverlayStretch/2;
    }

    else {
#ifdef _DEBUG
        ::MessageBox(::GetFocus(), TEXT("Overlay can't stretch"), TEXT("Error"), MB_OK) ;
#endif
    }

     
    return(hr);
}/* end of function GetOverlayMaxStretch */

// convert a RGB color to a pysical color.
// we do this by leting GDI SetPixel() do the color matching
// then we lock the memory and see what it got mapped to.
HRESULT CDDrawDVD::DDColorMatchOffscreen(COLORREF rgb, DWORD* dwColor)
{
    HDC hdc;
    *dwColor = CLR_INVALID;
    DDSURFACEDESC ddsd;
    IDirectDrawSurface* pdds;
    
    LPDIRECTDRAW pdd = GetDDrawObj();

    HRESULT hr = S_OK;

    ZeroMemory(&ddsd, sizeof(ddsd)) ;
    ddsd.dwSize = sizeof(ddsd) ;
    ddsd.dwFlags = DDSD_CAPS | DDSD_HEIGHT | DDSD_WIDTH;
    ddsd.ddsCaps.dwCaps = DDSCAPS_OFFSCREENPLAIN;
    ddsd.dwWidth = 8;
    ddsd.dwHeight = 8;
    hr = pdd->CreateSurface(&ddsd, &pdds, NULL);
    if (hr != DD_OK) {
        return 0;
    }
 
    //  use GDI SetPixel to color match for us
    if (rgb != CLR_INVALID && pdds->GetDC(&hdc) == DD_OK)
    {
        // set our value
        SetPixel(hdc, 0, 0, rgb);              
        pdds->ReleaseDC(hdc);
    }
 
    // now lock the surface so we can read back the converted color
    ZeroMemory(&ddsd, sizeof(ddsd)) ;
    ddsd.dwSize = sizeof(ddsd) ;
    while ((hr = pdds->Lock(NULL, &ddsd, 0, NULL)) == DDERR_WASSTILLDRAWING)
        ;
 
    if (hr == DD_OK)
    {
        // get DWORD
        DWORD temp = *(DWORD *)ddsd.lpSurface;
 
        // mask it to bpp
        if (ddsd.ddpfPixelFormat.dwRGBBitCount < 32)
            temp &= (1 << ddsd.ddpfPixelFormat.dwRGBBitCount)-1;

        pdds->Unlock(NULL);

        *dwColor = temp;
        hr = S_OK; 
    }
 
    pdds->Release();
    return hr;
}

/*************************************************************/
/* Name: CreateDIBBrush
/* Description: 
/*************************************************************/
HRESULT CDDrawDVD::CreateDIBBrush(COLORREF rgb, HBRUSH *phBrush)
{
#if 1
  
    HDC hdc;
    DDSURFACEDESC ddsd;
    IDirectDrawSurface* pdds;
    
    LPDIRECTDRAW pdd = GetDDrawObj();
    HRESULT hr = S_OK;

    ZeroMemory(&ddsd, sizeof(ddsd)) ;
    ddsd.dwSize = sizeof(ddsd) ;
    ddsd.dwFlags = DDSD_CAPS | DDSD_HEIGHT | DDSD_WIDTH;
    ddsd.ddsCaps.dwCaps = DDSCAPS_OFFSCREENPLAIN;
    ddsd.dwWidth = 8;
    ddsd.dwHeight = 8;
    hr = pdd->CreateSurface(&ddsd, &pdds, NULL);
    if (hr != DD_OK) {
        return 0;
    }
 
    //  use GDI SetPixel to color match for us
    if (rgb != CLR_INVALID && pdds->GetDC(&hdc) == DD_OK)
    {
        // set our value
        SetPixel(hdc, 0, 0, rgb);              
        pdds->ReleaseDC(hdc);
    }
 
    // now lock the surface so we can read back the converted color
    ZeroMemory(&ddsd, sizeof(ddsd)) ;
    ddsd.dwSize = sizeof(ddsd) ;
    while ((hr = pdds->Lock(NULL, &ddsd, 0, NULL)) == DDERR_WASSTILLDRAWING)
        ;
 
    DWORD temp = CLR_INVALID;
    if (hr == DD_OK)
    {
        // get DWORD
        temp = *((DWORD *)ddsd.lpSurface);
        
        // mask it to bpp
        if (ddsd.ddpfPixelFormat.dwRGBBitCount < 32)
            temp &= (1 << ddsd.ddpfPixelFormat.dwRGBBitCount)-1;

        pdds->Unlock(NULL);

        hr = S_OK; 
    }
 
    ::ZeroMemory(&ddsd, sizeof(ddsd)) ;
    ddsd.dwSize = sizeof(ddsd) ;        
    hr = pdds->GetSurfaceDesc(&ddsd) ;
    if (! (SUCCEEDED(hr) && (ddsd.dwFlags & DDSD_WIDTH) && (ddsd.dwFlags & DDSD_HEIGHT)) ) {
        return hr;
    }

    if (hr == DD_OK && temp != CLR_INVALID) {
        DDBLTFX ddBltFx;
        ::ZeroMemory(&ddBltFx, sizeof(ddBltFx)) ;
        ddBltFx.dwSize = sizeof(DDBLTFX);
        ddBltFx.dwFillColor = temp;

        RECT rc;
        ::SetRect(&rc, 0, 0, ddsd.dwWidth, ddsd.dwHeight);

        hr = pdds->Blt(&rc, NULL, NULL, DDBLT_COLORFILL|DDBLT_WAIT, &ddBltFx);
        if (FAILED(hr)) {
            return hr;
        }

        DWORD dwBitCount = ddsd.ddpfPixelFormat.dwRGBBitCount;
        DWORD dwWidth = WIDTHBYTES(ddsd.dwWidth*dwBitCount);
        DWORD dwSizeImage = ddsd.dwHeight*dwWidth;

        BYTE *packedDIB = new BYTE[sizeof(BITMAPINFOHEADER) + dwSizeImage + 1024];
        BITMAPINFOHEADER *lpbmi = (BITMAPINFOHEADER*) packedDIB;

        ::ZeroMemory(lpbmi, sizeof(BITMAPINFOHEADER));
        lpbmi->biSize = sizeof(BITMAPINFOHEADER);
        lpbmi->biBitCount = (WORD)dwBitCount;
        lpbmi->biWidth = ddsd.dwWidth;
        lpbmi->biHeight = ddsd.dwHeight;
        lpbmi->biPlanes = 1;
        
        LPDWORD pdw = (LPDWORD)DibColors(lpbmi);

        switch (dwBitCount) {
        case 8: {
            lpbmi->biCompression = BI_RGB;
            lpbmi->biClrUsed = 256;
            for (int i=0; i<(int)lpbmi->biClrUsed/16; i++)
            {
                *pdw++ = 0x00000000;    // 0000  black
                *pdw++ = 0x00800000;    // 0001  dark red
                *pdw++ = 0x00008000;    // 0010  dark green
                *pdw++ = 0x00808000;    // 0011  mustard
                *pdw++ = 0x00000080;    // 0100  dark blue
                *pdw++ = 0x00800080;    // 0101  purple
                *pdw++ = 0x00008080;    // 0110  dark turquoise
                *pdw++ = 0x00C0C0C0;    // 1000  gray
                *pdw++ = 0x00808080;    // 0111  dark gray
                *pdw++ = 0x00FF0000;    // 1001  red
                *pdw++ = 0x0000FF00;    // 1010  green
                *pdw++ = 0x00FFFF00;    // 1011  yellow
                *pdw++ = 0x000000FF;    // 1100  blue
                *pdw++ = 0x00FF00FF;    // 1101  pink (magenta)
                *pdw++ = 0x0000FFFF;    // 1110  cyan
                *pdw++ = 0x00FFFFFF;    // 1111  white
            }
            break;
        }
        case 16:
            lpbmi->biCompression = BI_BITFIELDS;
            lpbmi->biClrUsed = 3;
            pdw[0] = ddsd.ddpfPixelFormat.dwRBitMask ;
            pdw[1] = ddsd.ddpfPixelFormat.dwGBitMask ;
            pdw[2] = ddsd.ddpfPixelFormat.dwBBitMask ;
            break;
        case 24:
        case 32:
            lpbmi->biCompression = BI_RGB;
            lpbmi->biClrUsed = 0;
            break;
        }

        ZeroMemory(&ddsd, sizeof(ddsd)) ;
        ddsd.dwSize = sizeof(ddsd) ;
        while ((hr = pdds->Lock(NULL, &ddsd, 0, NULL)) == DDERR_WASSTILLDRAWING)
        ;

        if (hr != DD_OK)
            return hr;

        BYTE *lpTempSurf = (BYTE *)ddsd.lpSurface;
        for (DWORD i=0; i<ddsd.dwHeight; i++) {
            ::memcpy((BYTE*) DibPtr(lpbmi)+i*dwWidth, 
                lpTempSurf+i*ddsd.lPitch, dwWidth);
        }
        pdds->Unlock(NULL);

        *phBrush = ::CreateDIBPatternBrushPt((LPVOID) packedDIB, DIB_RGB_COLORS);
    }

    pdds->Release();
#else
        
    HRESULT hr = S_OK;
    typedef struct {
        BYTE rgb[3];
    } RGB;

    typedef struct {
        BITMAPINFOHEADER bmiHeader;
        RGB pBits[8][8];
    } PackedDIB;

    PackedDIB packedDIB;

    ::ZeroMemory(&packedDIB, sizeof(PackedDIB));
    packedDIB.bmiHeader.biSize = sizeof (BITMAPINFOHEADER);
    packedDIB.bmiHeader.biCompression = BI_RGB;
    packedDIB.bmiHeader.biBitCount = 24;
    packedDIB.bmiHeader.biHeight = 8;
    packedDIB.bmiHeader.biWidth = 8;
    packedDIB.bmiHeader.biPlanes = 1;
    
    for (int i=0; i<8; i++) {
        for (int j=0; j<8; j++)
            packedDIB.pBits[i][j] = *((RGB*)&rgb);
    }
    
    *phBrush = ::CreateDIBPatternBrushPt((LPVOID)&packedDIB, DIB_RGB_COLORS);
#endif
    return hr;
}


/* COverlayCallback */
/*************************************************************/
/* Name: OnUpdateOverlay
/* Description: 
/*************************************************************/
HRESULT STDMETHODCALLTYPE COverlayCallback::OnUpdateOverlay(BOOL  bBefore,
                                             DWORD dwFlags,
                                             BOOL  bOldVisible,
                                             const RECT *prcSrcOld,
                                             const RECT *prcDestOld,
                                             BOOL  bNewVisible,
                                             const RECT *prcSrcNew,
                                             const RECT *prcDestNew)
{
    if (bBefore)
        return S_OK;

    if(!prcSrcOld || !prcDestOld || !prcSrcNew || !prcDestNew){
        return E_POINTER;
    }
    CMSWebDVD *pDVD = m_pDDrawDVD->GetDVD();
    ATLASSERT(pDVD);

    if (m_dwWidth != (DWORD)RECTWIDTH(prcDestNew) ||
        m_dwHeight != (DWORD)RECTHEIGHT(prcDestNew) ||
        m_dwARWidth != (DWORD)RECTWIDTH(prcDestNew) ||
        m_dwARHeight != (DWORD)RECTHEIGHT(prcDestNew)) {

        m_dwWidth = (DWORD)RECTWIDTH(prcDestNew);
        m_dwHeight = (DWORD)RECTHEIGHT(prcDestNew);
        m_dwARWidth = (DWORD)RECTWIDTH(prcDestNew);
        m_dwARHeight = (DWORD)RECTHEIGHT(prcDestNew);

        return pDVD->UpdateOverlay();
    } /* end of if statement */

    return S_OK;
}


/*************************************************************/
/* Name: OnUpdateColorKey
/* Description: 
/*************************************************************/
HRESULT STDMETHODCALLTYPE COverlayCallback::OnUpdateColorKey(COLORKEY const *pKey, DWORD dwColor)
{
    m_pDDrawDVD->SetColorKey(pKey->HighColorValue);
    return S_OK ;
}


/*************************************************************/
/* Name: OnUpdateSize
/* Description: 
/*************************************************************/
HRESULT STDMETHODCALLTYPE COverlayCallback::OnUpdateSize(DWORD dwWidth, DWORD dwHeight, 
                                          DWORD dwARWidth, DWORD dwARHeight)
{
    CMSWebDVD *pDVD = m_pDDrawDVD->GetDVD();
    ATLASSERT(pDVD);
    
    if (m_dwWidth != dwWidth ||
        m_dwHeight != dwHeight ||
        m_dwARWidth != dwARWidth ||
        m_dwARHeight != dwARHeight) {

        m_dwWidth = dwWidth;
        m_dwHeight = dwHeight;
        m_dwARWidth = dwARWidth;
        m_dwARHeight = dwARHeight;

        return pDVD->UpdateOverlay();
    } /* end of if statement */

    return S_OK;
}

/*************************************************************/
/* Name: SetDDrawDVD
/* Description: 
/*************************************************************/
STDMETHODIMP COverlayCallback::SetDDrawDVD(VARIANT pDDrawDVD)
{
    switch(pDDrawDVD.vt){
        
    case VT_VOID: {  
        m_pDDrawDVD = static_cast<CDDrawDVD*> (pDDrawDVD.byref);
        break;
    }
    
    } /* end of switch statement */

	return S_OK;
}
=== C:/Users/treeman/Desktop/windows nt source code\Source\Win2K3\NT\multimedia\dshow\mfvideo\mswebdvd\ddrawobj.h ===
/*************************************************************************/
/* Helper function                                                       */
/*************************************************************************/
#include "resource.h"       // main symbols
#include <atlctl.h>
#include "MSWebDVD.h"
#include "msdvd.h"

class CDDrawDVD;

/////////////////////////////////////////////////////////////////////////////
// COverlayCallback
class ATL_NO_VTABLE COverlayCallback : 
	public CComObjectRootEx<CComSingleThreadModel>,
	public CComCoClass<COverlayCallback, &CLSID_OverlayCallback>,
	public IDispatchImpl<IOverlayCallback, &IID_IOverlayCallback, &LIBID_MSWEBDVDLib>,
    public IObjectWithSiteImplSec<COverlayCallback>,
    public IDDrawExclModeVideoCallback
{
public:
	COverlayCallback()
	{
        m_dwWidth = 0;
        m_dwHeight = 0;
        m_dwARWidth = 1;
        m_dwARHeight = 1;
        m_pDDrawDVD = NULL;
    }

DECLARE_REGISTRY_RESOURCEID(IDR_OVERLAYCALLBACK)

DECLARE_PROTECT_FINAL_CONSTRUCT()

BEGIN_COM_MAP(COverlayCallback)
	COM_INTERFACE_ENTRY(IOverlayCallback)
	COM_INTERFACE_ENTRY(IDispatch)
    COM_INTERFACE_ENTRY(IObjectWithSite)
	COM_INTERFACE_ENTRY(IDDrawExclModeVideoCallback)
END_COM_MAP()

// IOverlayCallback
public:

    STDMETHOD(SetDDrawDVD)(VARIANT pDDrawDVD);

    //IDDrawExclModeVideoCallback
    HRESULT STDMETHODCALLTYPE OnUpdateOverlay(BOOL  bBefore,
        DWORD dwFlags,
        BOOL  bOldVisible,
        const RECT *prcSrcOld,
        const RECT *prcDestOld,
        BOOL  bNewVisible,
        const RECT *prcSrcNew,
        const RECT *prcDestNew);    
    HRESULT STDMETHODCALLTYPE OnUpdateColorKey(COLORKEY const *pKey, DWORD dwColor);
    HRESULT STDMETHODCALLTYPE OnUpdateSize(DWORD dwWidth, DWORD dwHeight, 
        DWORD dwARWidth, DWORD dwARHeight);
private:
    CDDrawDVD *m_pDDrawDVD;
    DWORD m_dwWidth;
    DWORD m_dwHeight;
    DWORD m_dwARWidth;
    DWORD m_dwARHeight;
};


//
// DDraw object class to paint color key, flip etc etc.
//
class CDDrawDVD {

public:
    CDDrawDVD(CMSWebDVD *pDVD);
    ~CDDrawDVD();

    HRESULT SetupDDraw(const AMDDRAWGUID* lpDDGUID, HWND hWnd);
    HRESULT SetColorKey(COLORREF dwColorKey);
    COLORREF GetColorKey();

    HRESULT CreateDIBBrush(COLORREF rgb, HBRUSH *phBrush);

    inline CMSWebDVD* GetDVD() {return m_pDVD;};
    inline IDirectDraw* GetDDrawObj(){return ((IDirectDraw*) m_pDDObject);}
    inline IDirectDrawSurface* GetDDrawSurf(){return ((IDirectDrawSurface*) m_pPrimary);}
    inline IDDrawExclModeVideoCallback * GetCallbackInterface() { 

        CComQIPtr<IDDrawExclModeVideoCallback, &IID_IDDrawExclModeVideoCallback> pIDDrawExclModeVideoCallback(m_pOverlayCallback);
        return (IDDrawExclModeVideoCallback*) pIDDrawExclModeVideoCallback ; 
    } ;

    HRESULT DDColorMatchOffscreen(COLORREF rgb, DWORD* dwColor);
    HRESULT HasOverlay();
    HRESULT HasAvailableOverlay();
    HRESULT GetOverlayMaxStretch(DWORD *pdwMaxStretch);
private:

    CComPtr<IDirectDraw>  m_pDDObject; // ddraw object
    CComPtr<IDirectDrawSurface> m_pPrimary; // primary ddraw surface    
    CComPtr<IOverlayCallback> m_pOverlayCallback ;  // overlay callback handler interface

    COLORREF m_VideoKeyColor ;
    CMSWebDVD *m_pDVD;
};

#define DibFree(pdib)           GlobalFreePtr(pdib)
#define DibWidth(lpbi)          _abs((int)(LONG)(((LPBITMAPINFOHEADER)(lpbi))->biWidth))
#define DibHeight(lpbi)         _abs((int)(LONG)(((LPBITMAPINFOHEADER)(lpbi))->biHeight))
#define DibBitCount(lpbi)       (UINT)(((LPBITMAPINFOHEADER)(lpbi))->biBitCount)
#define DibCompression(lpbi)    (DWORD)(((LPBITMAPINFOHEADER)(lpbi))->biCompression)

#define DibWidthBytesN(lpbi, n) (UINT)WIDTHBYTES((UINT)(lpbi)->biWidth * (UINT)(n))
#define DibWidthBytes(lpbi)     DibWidthBytesN(lpbi, (lpbi)->biBitCount)

#define DibSizeImage(lpbi)      ((lpbi)->biSizeImage == 0 \
                                    ? ((DWORD)(UINT)DibWidthBytes(lpbi) * (DWORD)DibHeight(lpbi)) \
                                    : (lpbi)->biSizeImage)

#define DibSize(lpbi)           ((lpbi)->biSize + (lpbi)->biSizeImage + (int)(lpbi)->biClrUsed * sizeof(RGBQUAD))
#define DibPaletteSize(lpbi)    (DibNumColors(lpbi) * sizeof(RGBQUAD))

#define DibFlipY(lpbi, y)       ((int)_abs((lpbi)->biHeight)-1-(y))

//HACK for NT BI_BITFIELDS DIBs
#ifdef WIN32
    #define DibPtr(lpbi)        ((lpbi)->biCompression == BI_BITFIELDS \
                                    ? (LPVOID)(DibColors(lpbi) + 3) : (LPVOID)(DibColors(lpbi) + (UINT)(lpbi)->biClrUsed))
#else
    #define DibPtr(lpbi)        (LPVOID)(DibColors(lpbi) + (UINT)(lpbi)->biClrUsed)
#endif

#define DibColors(lpbi)         ((RGBQUAD FAR *)((LPBYTE)(lpbi) + (int)(lpbi)->biSize))

#define DibNumColors(lpbi)      ((lpbi)->biClrUsed == 0 && (lpbi)->biBitCount <= 8 \
                                    ? (int)(1 << (int)(lpbi)->biBitCount)          \
                                    : (int)(lpbi)->biClrUsed)
=== C:/Users/treeman/Desktop/windows nt source code\Source\Win2K3\NT\multimedia\dshow\mfvideo\mswebdvd\gdipluspixelformats.h ===
/**************************************************************************\
*
* Copyright (c) 1998-1999, Microsoft Corp.  All Rights Reserved.
*
* Module Name:
*
*   Gdiplus pixel formats
*
* Abstract:
*
*   Definitions for color types, palettes, pixel format IDs.
*
* Notes:
*
*   imaging.h
*
* Revision History:
*
*   10/13/1999 agodfrey
*       Separated it from imaging.h
*
\**************************************************************************/

#ifndef _GDIPLUSPIXELFORMATS_H
#define _GDIPLUSPIXELFORMATS_H

//
// 32-bit and 64-bit ARGB pixel value
//

typedef DWORD ARGB;
typedef DWORDLONG ARGB64;

#define ALPHA_SHIFT 24
#define RED_SHIFT   16
#define GREEN_SHIFT 8
#define BLUE_SHIFT  0
#define ALPHA_MASK  ((ARGB) 0xff << ALPHA_SHIFT)

#define MAKEARGB(a, r, g, b) \
        (((ARGB) ((a) & 0xff) << ALPHA_SHIFT) | \
         ((ARGB) ((r) & 0xff) <<   RED_SHIFT) | \
         ((ARGB) ((g) & 0xff) << GREEN_SHIFT) | \
         ((ARGB) ((b) & 0xff) <<  BLUE_SHIFT))

//
// In-memory pixel data formats:
//  bits 0-7 = format index
//  bits 8-15 = pixel size (in bits)
//  bits 16-23 = flags
//  bits 24-31 = reserved
//

typedef enum PixelFormatID
{
    PIXFMTFLAG_INDEXED      = 0x00010000, // Indexes into a palette
    PIXFMTFLAG_GDI          = 0x00020000, // Is a GDI-supported format
    PIXFMTFLAG_ALPHA        = 0x00040000, // Has an alpha component
    PIXFMTFLAG_PALPHA       = 0x00080000, // Uses pre-multiplied alpha
    PIXFMTFLAG_EXTENDED     = 0x00100000, // Uses extended color (16 bits per channel)
    PIXFMTFLAG_CANONICAL    = 0x00200000, // ?

    PIXFMT_UNDEFINED        =  0,
    PIXFMT_DONTCARE         =  0,
    PIXFMT_1BPP_INDEXED     =  1 | ( 1 << 8) | PIXFMTFLAG_INDEXED
                                             | PIXFMTFLAG_GDI,
    PIXFMT_4BPP_INDEXED     =  2 | ( 4 << 8) | PIXFMTFLAG_INDEXED
                                             | PIXFMTFLAG_GDI,
    PIXFMT_8BPP_INDEXED     =  3 | ( 8 << 8) | PIXFMTFLAG_INDEXED
                                             | PIXFMTFLAG_GDI,
    PIXFMT_16BPP_GRAYSCALE  =  4 | (16 << 8) | PIXFMTFLAG_EXTENDED,
    PIXFMT_16BPP_RGB555     =  5 | (16 << 8) | PIXFMTFLAG_GDI,
    PIXFMT_16BPP_RGB565     =  6 | (16 << 8) | PIXFMTFLAG_GDI,
    PIXFMT_16BPP_ARGB1555   =  7 | (16 << 8) | PIXFMTFLAG_ALPHA
                                             | PIXFMTFLAG_GDI,
    PIXFMT_24BPP_RGB        =  8 | (24 << 8) | PIXFMTFLAG_GDI,
    PIXFMT_32BPP_RGB        =  9 | (32 << 8) | PIXFMTFLAG_GDI,
    PIXFMT_32BPP_ARGB       = 10 | (32 << 8) | PIXFMTFLAG_ALPHA
                                             | PIXFMTFLAG_GDI
                                             | PIXFMTFLAG_CANONICAL,
    PIXFMT_32BPP_PARGB      = 11 | (32 << 8) | PIXFMTFLAG_ALPHA
                                             | PIXFMTFLAG_PALPHA
                                             | PIXFMTFLAG_GDI,
    PIXFMT_48BPP_RGB        = 12 | (48 << 8) | PIXFMTFLAG_EXTENDED,
    PIXFMT_64BPP_ARGB       = 13 | (64 << 8) | PIXFMTFLAG_ALPHA
                                             | PIXFMTFLAG_CANONICAL
                                             | PIXFMTFLAG_EXTENDED,
    PIXFMT_64BPP_PARGB      = 14 | (64 << 8) | PIXFMTFLAG_ALPHA
                                             | PIXFMTFLAG_PALPHA
                                             | PIXFMTFLAG_EXTENDED,
    PIXFMT_24BPP_BGR        = 15 | (24 << 8) | PIXFMTFLAG_GDI,

    PIXFMT_MAX              = 16
} PixelFormatID;

// Return the pixel size for the specified format (in bits)

inline UINT
GetPixelFormatSize(
    PixelFormatID pixfmt
    )
{
    return (pixfmt >> 8) & 0xff;
}

// Determine if the specified pixel format is an indexed color format

inline BOOL
IsIndexedPixelFormat(
    PixelFormatID pixfmt
    )
{
    return (pixfmt & PIXFMTFLAG_INDEXED) != 0;
}

// Determine if the pixel format can have alpha channel

inline BOOL
IsAlphaPixelFormat(
    PixelFormatID pixfmt
    )
{
    return (pixfmt & PIXFMTFLAG_ALPHA) != 0;
}

// Determine if the pixel format is an extended format,
// i.e. supports 16-bit per channel

inline BOOL
IsExtendedPixelFormat(
    PixelFormatID pixfmt
    )
{
    return (pixfmt & PIXFMTFLAG_EXTENDED) != 0;
}

// Determine if the pixel format is canonical format:
//  PIXFMT_32BPP_ARGB
//  PIXFMT_32BPP_PARGB
//  PIXFMT_64BPP_ARGB
//  PIXFMT_64BPP_PARGB

inline BOOL
IsCanonicalPixelFormat(
    PixelFormatID pixfmt
    )
{
    return (pixfmt & PIXFMTFLAG_CANONICAL) != 0;
}


//
// Color palette
//  palette entries are limited to 32bpp ARGB pixel format
//

enum
{
    PALFLAG_HASALPHA    = 0x0001,
    PALFLAG_GRAYSCALE   = 0x0002,
    PALFLAG_HALFTONE    = 0x0004
};

typedef struct tagColorPalette
{
    UINT Flags;             // palette flags
    UINT Count;             // number of color entries
    ARGB Entries[1];        // palette color  entries
} ColorPalette;

#endif
=== C:/Users/treeman/Desktop/windows nt source code\Source\Win2K3\NT\multimedia\dshow\mfvideo\mswebdvd\dvdrect.cpp ===
/*************************************************************************/
/* Copyright (C) 1999 Microsoft Corporation                              */
/* File: DVDRect.cpp                                                     */
/* Description: Implementation of CDVDRect                               */
/* Author: David Janecek                                                 */
/*************************************************************************/
#include "stdafx.h"
#include "MSWebDVD.h"
#include "DVDRect.h"
#include <errors.h>


/////////////////////////////////////////////////////////////////////////////
// CDVDRect

/*************************************************************************/
/* Function: get_x                                                       */
/*************************************************************************/
STDMETHODIMP CDVDRect::get_x(long *pVal){

    HRESULT hr = S_OK;

    try {
        if(NULL == pVal){

            throw(E_POINTER);
        }/* end of if statement */

        *pVal = m_x;
    }
    catch(HRESULT hrTmp){

        hr = hrTmp;
    }/* end of catch statement */
    catch(...){

        hr = E_UNEXPECTED;
    }/* end of catch statement */
    
	return HandleError(hr);	
}/* end of function get_x */

/*************************************************************************/
/* Function: put_x                                                       */
/*************************************************************************/
STDMETHODIMP CDVDRect::put_x(long newVal){

    HRESULT hr = S_OK;

    try {
 
        m_x = newVal;
    }
    catch(HRESULT hrTmp){

        hr = hrTmp;
    }/* end of catch statement */
    catch(...){

        hr = E_UNEXPECTED;
    }/* end of catch statement */
    
	return HandleError(hr);	
}/* end of function put_x */

/*************************************************************************/
/* Function: get_y                                                       */
/*************************************************************************/
STDMETHODIMP CDVDRect::get_y(long *pVal){

    HRESULT hr = S_OK;

    try {
        if(NULL == pVal){

            throw(E_POINTER);
        }/* end of if statement */

        *pVal = m_y;
    }
    catch(HRESULT hrTmp){

        hr = hrTmp;
    }/* end of catch statement */
    catch(...){

        hr = E_UNEXPECTED;
    }/* end of catch statement */
    
	return HandleError(hr);	
}/* end of function get_y */

/*************************************************************************/
/* Function: put_y                                                       */
/*************************************************************************/
STDMETHODIMP CDVDRect::put_y(long newVal){

    HRESULT hr = S_OK;

    try {
 
        m_y = newVal;
    }
    catch(HRESULT hrTmp){

        hr = hrTmp;
    }/* end of catch statement */
    catch(...){

        hr = E_UNEXPECTED;
    }/* end of catch statement */
    
	return HandleError(hr);	
}/* end of function put_y */

/*************************************************************************/
/* Function: get_Width                                                   */
/*************************************************************************/
STDMETHODIMP CDVDRect::get_Width(long *pVal){

    HRESULT hr = S_OK;

    try {
        if(NULL == pVal){

            throw(E_POINTER);
        }/* end of if statement */

        *pVal = m_lWidth;
    }
    catch(HRESULT hrTmp){

        hr = hrTmp;
    }/* end of catch statement */
    catch(...){

        hr = E_UNEXPECTED;
    }/* end of catch statement */
    
	return HandleError(hr);	
}/* end of function get_Width */

/*************************************************************************/
/* Function: put_Width                                                   */
/*************************************************************************/
STDMETHODIMP CDVDRect::put_Width(long newVal){

   HRESULT hr = S_OK;

    try {

        if(newVal <= 0){

            throw(E_INVALIDARG);
        }/* end of if statement */

        m_lWidth = newVal;
    }
    catch(HRESULT hrTmp){

        hr = hrTmp;
    }/* end of catch statement */
    catch(...){

        hr = E_UNEXPECTED;
    }/* end of catch statement */
    
	return HandleError(hr);	
}/* end of function put_Width */

/*************************************************************************/
/* Function: get_Height                                                  */
/*************************************************************************/
STDMETHODIMP CDVDRect::get_Height(long *pVal){	

    HRESULT hr = S_OK;

    try {
        if(NULL == pVal){

            throw(E_POINTER);
        }/* end of if statement */

        *pVal = m_lHeight;
    }
    catch(HRESULT hrTmp){

        hr = hrTmp;
    }/* end of catch statement */
    catch(...){

        hr = E_UNEXPECTED;
    }/* end of catch statement */
    
	return HandleError(hr);	
}/* end of function get_Height */

/*************************************************************************/
/* Function: put_Height                                                  */
/*************************************************************************/
STDMETHODIMP CDVDRect::put_Height(long newVal){

    HRESULT hr = S_OK;

    try {

        if(newVal <= 0){

            throw(E_INVALIDARG);
        }/* end of if statement */

        m_lHeight = newVal;	
    }
    catch(HRESULT hrTmp){

        hr = hrTmp;
    }/* end of catch statement */
    catch(...){

        hr = E_UNEXPECTED;
    }/* end of catch statement */
    
	return HandleError(hr);	
}/* end of function put_Height */

/*************************************************************************/
/* Function: GetInterfaceSafetyOptions                                   */
/* Description: For support of security model in IE                      */
/* This control is safe since it does not write to HD.                   */
/*************************************************************************/
STDMETHODIMP CDVDRect::GetInterfaceSafetyOptions(REFIID /*riid*/, 
                                               DWORD* pdwSupportedOptions, 
                                               DWORD* pdwEnabledOptions){

    HRESULT hr = S_OK;
    if(!pdwSupportedOptions || !pdwEnabledOptions){
        return E_POINTER;
    }
	*pdwSupportedOptions = INTERFACESAFE_FOR_UNTRUSTED_CALLER | INTERFACESAFE_FOR_UNTRUSTED_DATA;

	*pdwEnabledOptions = *pdwSupportedOptions;

	return(hr);
}/* end of function GetInterfaceSafetyOptions */ 

/*************************************************************************/
/* Function: SetInterfaceSafetyOptions                                   */
/* Description: For support of security model in IE                      */
/*************************************************************************/
STDMETHODIMP CDVDRect::SetInterfaceSafetyOptions(REFIID /*riid*/, 
                                               DWORD /* dwSupportedOptions */, 
                                               DWORD /* pdwEnabledOptions */){

	return (S_OK);
}/* end of function SetInterfaceSafetyOptions */ 

/*************************************************************************/
/* Function: InterfaceSupportsErrorInfo                                  */
/*************************************************************************/
STDMETHODIMP CDVDRect::InterfaceSupportsErrorInfo(REFIID riid){	
	static const IID* arr[] = {
        &IID_IDVDRect,		
	};

	for (int i=0; i<sizeof(arr)/sizeof(arr[0]); i++){
		if (InlineIsEqualGUID(*arr[i], riid))
			return S_OK;
	}/* end of for loop */

	return S_FALSE;
}/* end of function InterfaceSupportsErrorInfo */

/*************************************************************************/
/* Function: HandleError                                                 */
/* Description: Gets Error Description, so we can suppor IError Info.    */
/*************************************************************************/
HRESULT CDVDRect::HandleError(HRESULT hr){

    try {

        if(FAILED(hr)){
        
            // Ensure that the string is Null Terminated
            TCHAR strError[MAX_ERROR_TEXT_LEN+1];
            ZeroMemory(strError, MAX_ERROR_TEXT_LEN+1);

            if(AMGetErrorText(hr , strError , MAX_ERROR_TEXT_LEN)){
                USES_CONVERSION;
                Error(T2W(strError));
            } 
            else {
                    ATLTRACE(TEXT("Unhandled Error Code \n")); // please add it
                    ATLASSERT(FALSE);
            }/* end of if statement */
        }/* end of if statement */
    }/* end of try statement */
    catch(HRESULT hrTmp){

        hr = hrTmp;
    }/* end of catch statement */
    catch(...){
        // keep the hr same    
    }/* end of catch statement */
    
	return (hr);
}/* end of function HandleError */

/*************************************************************************/
/* End of file: DVDRect.cpp                                              */
/*************************************************************************/
=== C:/Users/treeman/Desktop/windows nt source code\Source\Win2K3\NT\multimedia\dshow\mfvideo\mswebdvd\dvdrect.h ===
/*************************************************************************/
/* Copyright (C) 1999 Microsoft Corporation                              */
/* File: DVDRect.h                                                       */
/* Description: Declaration of the CDVDRect                              */
/* Author: David Janecek                                                 */
/*************************************************************************/
#ifndef __DVDRECT_H_
#define __DVDRECT_H_

#include "resource.h"       // main symbols

/////////////////////////////////////////////////////////////////////////////
// CDVDRect
class ATL_NO_VTABLE CDVDRect : 
	public CComObjectRootEx<CComSingleThreadModel>,
	public CComCoClass<CDVDRect, &CLSID_DVDRect>,
	public IDispatchImpl<IDVDRect, &IID_IDVDRect, &LIBID_MSWEBDVDLib>,
    public IObjectWithSiteImplSec<CDVDRect>,
    public ISupportErrorInfo,
    public IObjectSafety
{
public:
    CDVDRect(){ m_x = 0; m_y = 0; m_lWidth = 0; m_lHeight = 0;};

DECLARE_REGISTRY_RESOURCEID(IDR_DVDRECT)

DECLARE_PROTECT_FINAL_CONSTRUCT()

BEGIN_COM_MAP(CDVDRect)
	COM_INTERFACE_ENTRY(IDVDRect)
	COM_INTERFACE_ENTRY(IDispatch)
    COM_INTERFACE_ENTRY(IObjectWithSite)
    COM_INTERFACE_ENTRY(ISupportErrorInfo)
    COM_INTERFACE_ENTRY(IObjectSafety)
END_COM_MAP()

// ISupportsErrorInfo
    STDMETHOD(InterfaceSupportsErrorInfo)(REFIID riid);

public:
// IDVDRect
	STDMETHOD(get_Height)(/*[out, retval]*/ long *pVal);
	STDMETHOD(put_Height)(/*[in]*/ long newVal);
	STDMETHOD(get_Width)(/*[out, retval]*/ long *pVal);
	STDMETHOD(put_Width)(/*[in]*/ long newVal);
	STDMETHOD(get_y)(/*[out, retval]*/ long *pVal);
	STDMETHOD(put_y)(/*[in]*/ long newVal);
	STDMETHOD(get_x)(/*[out, retval]*/ long *pVal);
	STDMETHOD(put_x)(/*[in]*/ long newVal);

//IObjectSafety
     STDMETHOD(GetInterfaceSafetyOptions)( REFIID riid, 
                                          DWORD *pdwSupportedOptions, 
                                          DWORD *pdwEnabledOptions );

    STDMETHOD(SetInterfaceSafetyOptions)( REFIID riid, 
                                          DWORD dwOptionSetMask, 
                                          DWORD dwEnabledOptions );
protected:
    HRESULT HandleError(HRESULT hr);

private:
    long m_x;
    long m_y;
    long m_lWidth;
    long m_lHeight;
};

#endif //__DVDRECT_H_

/*************************************************************************/
/* End of file: DVDRect.h                                                */
/*************************************************************************/
=== C:/Users/treeman/Desktop/windows nt source code\Source\Win2K3\NT\multimedia\dshow\mfvideo\mswebdvd\imaging.h ===
/**************************************************************************\
* 
* Copyright (c) 1999  Microsoft Corporation
*
* Module Name:
*
*   imaging.h
*
* Abstract:
*
*   Public SDK header file for the imaging library
*
* Notes:
*
*   This is hand-coded for now. Eventually it'll be automatically
*   generated from an IDL file.
*
* Revision History:
*
*   05/10/1999 davidx
*       Created it.
*
\**************************************************************************/

#ifndef _IMAGING_H
#define _IMAGING_H

#include "GdiplusPixelFormats.h"

//
// Imaging library GUIDS:
//  image file format identifiers
//  interface and class identifers
//

#include "imgguids.h"

//
// Image property ID tags (PROPID's from the EXIF tags)
//

#define TAG_EXIF_IFD            0x8769
#define TAG_GPS_IFD             0x8825

#define TAG_IMAGE_WIDTH         0x0100
#define TAG_IMAGE_HEIGHT        0x0101
#define TAG_BITS_PER_SAMPLE     0x0102
#define TAG_COMPRESSION         0x0103
#define TAG_PHOTOMETRIC_INTERP  0x0106
#define TAG_IMAGE_DESCRIPTION   0x010E
#define TAG_EQUIP_MAKE          0x010F
#define TAG_EQUIP_MODEL         0x0110
#define TAG_STRIP_OFFSETS       0x0111
#define TAG_ORIENTATION         0x0112
#define TAG_SAMPLES_PER_PIXEL   0x0115
#define TAG_ROWS_PER_STRIP      0x0116
#define TAG_STRIP_BYTES_COUNT   0x0117
#define TAG_X_RESOLUTION        0x011A
#define TAG_Y_RESOLUTION        0x011B
#define TAG_PLANAR_CONFIG       0x011C
#define TAG_RESOLUTION_UNIT     0x0128
#define TAG_TRANSFER_FUNCTION   0x012D
#define TAG_SOFTWARE_USED       0x0131
#define TAG_DATE_TIME           0x0132
#define TAG_ARTIST              0x013B
#define TAG_WHITE_POINT         0x013E
#define TAG_PRIMAY_CHROMATICS   0x013F

#define TAG_JPEG_INTER_FORMAT   0x0201
#define TAG_JPEG_INTER_LENGTH   0x0202
#define TAG_YCbCr_COEFFICIENTS  0x0211
#define TAG_YCbCr_SUBSAMPLING   0x0212
#define TAG_YCbCr_POSITIONING   0x0213
#define TAG_REF_BLACK_WHITE     0x0214

#define TAG_COPYRIGHT           0x8298

// Extra TAGs (Like Adobe Image Information tags etc.)

#define TAG_RESOLUTION_X_UNIT   0x5001
#define TAG_RESOLUTION_Y_UNIT   0x5002
#define TAG_RESOLUTION_X_LENGTH_UNIT   0x5003
#define TAG_RESOLUTION_Y_LENGTH_UNIT   0x5004
#define TAG_PRINT_FLAGS         0x5005
#define TAG_HALFTONE_LPI        0x5006
#define TAG_HALFTONE_LPI_UNIT   0x5007
#define TAG_HALFTONE_DEGREE     0x5008
#define TAG_HALFTONE_SHAPE      0x5009
#define TAG_HALFTONE_MISC       0x5010
#define TAG_HALFTONE_SCREEN     0x5011
#define TAG_JPEG_QUALITY        0x5012
#define TAG_GRID_SIZE           0x5013
#define TAG_THUMBNAIL_FORMAT    0x5014
#define TAG_THUMBNAIL_WIDTH     0x5015
#define TAG_THUMBNAIL_HEIGHT    0x5016
#define TAG_THUMBNAIL_COLORDEPTH    0x5017
#define TAG_THUMBNAIL_PLANES    0x5018
#define TAG_THUMBNAIL_RAWBYTES  0x5019
#define TAG_THUMBNAIL_SIZE      0x5020
#define TAG_THUMBNAIL_COMPRESSED_SIZE   0x5021

// EXIF specific tag

#define EXIF_TAG_EXPOSURE_TIME  0x829A
#define EXIF_TAG_F_NUMBER       0x829D

#define EXIF_TAG_EXPOSURE_PROG  0x8822
#define EXIF_TAG_SPECTRAL_SENSE 0x8824
#define EXIF_TAG_ISO_SPEED      0x8827
#define EXIF_TAG_OECF           0x8828

#define EXIF_TAG_VER            0x9000
#define EXIF_TAG_D_T_ORIG       0x9003 // Date & time of original
#define EXIF_TAG_D_T_DIGITIZED  0x9004 // Date & time of digital data generation

#define EXIF_TAG_COMP_CONFIG    0x9101
#define EXIF_TAG_COMP_BPP       0x9102

#define EXIF_TAG_SHUTTER_SPEED  0x9201
#define EXIF_TAG_APERATURE      0x9202
#define EXIF_TAG_BRIGHTNESS     0x9203
#define EXIF_TAG_EXPOSURE_BIAS  0x9204
#define EXIF_TAG_MAX_APERATURE  0x9205
#define EXIF_TAG_SUBJECT_DIST   0x9206
#define EXIF_TAG_METERING_MODE  0x9207
#define EXIF_TAG_LIGHT_SOURCE   0x9208
#define EXIF_TAG_FLASH          0x9209
#define EXIF_TAG_FOCAL_LENGTH   0x920A
#define EXIF_TAG_MAKER_NOTE     0x927C
#define EXIF_TAG_USER_COMMENT   0x9286
#define EXIF_TAG_D_T_SUBSEC     0x9290  // Date & Time subseconds
#define EXIF_TAG_D_T_ORIG_SS    0x9291  // Date & Time original subseconds
#define EXIF_TAG_D_T_DIG_SS     0x9292  // Date & TIme digitized subseconds

#define EXIF_TAG_FPX_VER        0xA000
#define EXIF_TAG_COLOR_SPACE    0xA001
#define EXIF_TAG_PIX_X_DIM      0xA002
#define EXIF_TAG_PIX_Y_DIM      0xA003
#define EXIF_TAG_RELATED_WAV    0xA004  // related sound file
#define EXIF_TAG_INTEROP        0xA005
#define EXIF_TAG_FLASH_ENERGY   0xA20B
#define EXIF_TAG_SPATIAL_FR     0xA20C  // Spatial Frequency Response
#define EXIF_TAG_FOCAL_X_RES    0xA20E  // Focal Plane X Resolution
#define EXIF_TAG_FOCAL_Y_RES    0xA20F  // Focal Plane Y Resolution
#define EXIF_TAG_FOCAL_RES_UNIT 0xA210  // Focal Plane Resolution Unit
#define EXIF_TAG_SUBJECT_LOC    0xA214
#define EXIF_TAG_EXPOSURE_INDEX 0xA215
#define EXIF_TAG_SENSING_METHOD 0xA217
#define EXIF_TAG_FILE_SOURCE    0xA300
#define EXIF_TAG_SCENE_TYPE     0xA301
#define EXIF_TAG_CFA_PATTERN    0xA302

#define GPS_TAG_VER             0x0000
#define GPS_TAG_LATTITUDE_REF   0x0001
#define GPS_TAG_LATTITUDE       0x0002
#define GPS_TAG_LONGITUDE_REF   0x0003
#define GPS_TAG_LONGITUDE       0x0004
#define GPS_TAG_ALTITUDE_REF    0x0005
#define GPS_TAG_ALTITUDE        0x0006
#define GPS_TAG_GPS_TIME        0x0007
#define GPS_TAG_GPS_SATELLITES  0x0008
#define GPS_TAG_GPS_STATUS      0x0009
#define GPS_TAG_GPS_MEASURE_MODE 0x00A
#define GPS_TAG_GPS_DOP         0x000B  // Measurement precision
#define GPS_TAG_SPEED_REF       0x000C
#define GPS_TAG_SPEED           0x000D
#define GPS_TAG_TRACK_REF       0x000E
#define GPS_TAG_TRACK           0x000F
#define GPS_TAG_IMG_DIR_REF     0x0010
#define GPS_TAG_IMG_DIR         0x0011
#define GPS_TAG_MAP_DATUM       0x0012
#define GPS_TAG_DEST_LAT_REF    0x0013
#define GPS_TAG_DEST_LAT        0x0014
#define GPS_TAG_DEST_LONG_REF   0x0015
#define GPS_TAG_DEST_LONG       0x0016
#define GPS_TAG_DEST_BEAR_REF   0x0017
#define GPS_TAG_DEST_BEAR       0x0018
#define GPS_TAG_DEST_DIST_REF   0x0019
#define GPS_TAG_DEST_DIST       0x001A

//
// Information about image pixel data
//

typedef struct tagBitmapData
{
    UINT Width;
    UINT Height;
    INT Stride;
    PixelFormatID PixelFormat;
    VOID* Scan0;
    UINT_PTR Reserved;
} BitmapData;

//
// Access modes used when calling IImage::LockBits
//

typedef enum ImageLockMode
{
    IMGLOCK_READ        = 0x0001,
    IMGLOCK_WRITE       = 0x0002,
    IMGLOCK_USERINPUTBUF= 0x0004
} ImageLockMode;

//
// Image flags
//

typedef enum ImageFlag
{
    IMGFLAG_NONE        = 0,

    // Low-word: shared with SINKFLAG_x

    IMGFLAG_SCALABLE            = 0x0001,
    IMGFLAG_HASALPHA            = 0x0002,
    IMGFLAG_HASTRANSLUCENT      = 0x0004,
    IMGFLAG_PARTIALLY_SCALABLE  = 0x0008,

    // Low-word: color space definition

    IMGFLAG_COLORSPACE_RGB      = 0x0010,
	IMGFLAG_COLORSPACE_CMYK     = 0x0020,
	IMGFLAG_COLORSPACE_GRAY     = 0x0040,
	IMGFLAG_COLORSPACE_YCBCR    = 0x0080,
	IMGFLAG_COLORSPACE_YCCK     = 0x0100,

    // Low-word: image size info

    IMGFLAG_HASREALDPI          = 0x1000,
    IMGFLAG_HASREALPIXELSIZE    = 0x2000,

    // High-word

    IMGFLAG_READONLY    = 0x00010000,
    IMGFLAG_CACHING     = 0x00020000
} ImageFlag;

//
// Decoder flags
//

typedef enum DecoderInitFlag
{
    DECODERINIT_NONE        = 0,

    // DECODERINIT_NOBLOCK indicates that the caller requires non-blocking
    // behavior.  This will be honored only by non-blocking decoders, that
    // is, decoders that don't have the IMGCODEC_BLOCKING_DECODE flag.

    DECODERINIT_NOBLOCK     = 0x0001,

    // Choose built-in decoders first before looking at any
    // installed plugin decoders.

    DECODERINIT_BUILTIN1ST  = 0x0002
} DecoderInitFlag;

//
// Flag to indicate how the memory buffer passed to
// IImagingFactory::CreateImageFromBuffer should be disposed.
//

typedef enum BufferDisposalFlag
{
    DISPOSAL_NONE,
    DISPOSAL_GLOBALFREE,
    DISPOSAL_COTASKMEMFREE,
    DISPOSAL_UNMAPVIEW
} BufferDisposalFlag;

//
// Quality hints used by resize/rotation operations
//

typedef enum InterpolationHint
{
    INTERP_DEFAULT,
    INTERP_NEAREST_NEIGHBOR,
    INTERP_BILINEAR,
    INTERP_AVERAGING,
    INTERP_BICUBIC
} InterpolationHint;

//
// Information about image codecs
//

enum
{
    IMGCODEC_ENCODER            = 0x00000001,
    IMGCODEC_DECODER            = 0x00000002,
    IMGCODEC_SUPPORT_BITMAP     = 0x00000004,
    IMGCODEC_SUPPORT_VECTOR     = 0x00000008,
    IMGCODEC_SEEKABLE_ENCODE    = 0x00000010,
    IMGCODEC_BLOCKING_DECODE    = 0x00000020,

    IMGCODEC_BUILTIN            = 0x00010000,
    IMGCODEC_SYSTEM             = 0x00020000,
    IMGCODEC_USER               = 0x00040000
};

typedef struct tagImageCodecInfo
{
    CLSID Clsid;
    GUID FormatID;
    const WCHAR* CodecName;
    const WCHAR* FormatDescription;
    const WCHAR* FilenameExtension;
    const WCHAR* MimeType;
    DWORD Flags;
    DWORD SigCount;
    DWORD SigSize;
    const BYTE* SigPattern;
    const BYTE* SigMask;
} ImageCodecInfo;

//
// Identifier for channel(s) in a pixel
//

typedef enum ChannelID
{
    ALPHA_CHANNEL       = 0x00000001,
    RED_CHANNEL         = 0x00000002,
    GREEN_CHANNEL       = 0x00000004,
    BLUE_CHANNEL        = 0x00000008,
    COLOR_CHANNELS      = RED_CHANNEL|GREEN_CHANNEL|BLUE_CHANNEL,
    ALL_CHANNELS        = COLOR_CHANNELS|ALPHA_CHANNEL,

    INTENSITY_CHANNEL   = 0x00010000
} ChannelID;

//
// Data structure for communicating to an image sink
//

enum
{
    // Low-word: shared with IMGFLAG_x

    SINKFLAG_SCALABLE   = IMGFLAG_SCALABLE,
    SINKFLAG_HASALPHA   = IMGFLAG_HASALPHA,
    SINKFLAG_PARTIALLY_SCALABLE = IMGFLAG_PARTIALLY_SCALABLE,

    // High-word

    SINKFLAG_TOPDOWN    = 0x00010000,
    SINKFLAG_BOTTOMUP   = 0x00020000,
    SINKFLAG_FULLWIDTH  = 0x00040000,
    SINKFLAG_MULTIPASS  = 0x00080000,
    SINKFLAG_COMPOSITE  = 0x00100000,
    SINKFLAG_WANTPROPS  = 0x00200000
};

typedef struct tagImageInfo
{
    GUID RawDataFormat;
    PixelFormatID PixelFormat;
    UINT Width, Height;
    UINT TileWidth, TileHeight;
    double Xdpi, Ydpi;
    UINT Flags;
} ImageInfo;

//
// Data structure for passing encoder paramaters
//

// NOTE:
//  Should this be in GdiplusTypes.h instead?  Leave imaging.h for stuff
//  shared between the internal stuff and the API?

typedef struct tagEncoderParam
{
    GUID    paramGuid;
    char*   Value;
} EncoderParam;

typedef struct tagEncoderParams
{
    UINT Count;
    EncoderParam Params[1];
} EncoderParams;

//
// Interface and class identifiers
//

interface IImagingFactory;
interface IImage;
interface IBitmapImage;
interface IImageDecoder;
interface IImageEncoder;
interface IImageSink;
interface IBasicBitmapOps;


//--------------------------------------------------------------------------
// Imaging utility factory object
//  This is a CoCreate-able object.
//--------------------------------------------------------------------------

MIDL_INTERFACE("327ABDA7-072B-11D3-9D7B-0000F81EF32E")
IImagingFactory : public IUnknown
{
public:

    // Create an image object from an input stream
    //  stream doesn't have to seekable
    //  caller should Release the stream if call is successful

    STDMETHOD(CreateImageFromStream)(
        IN IStream* stream,
        OUT IImage** image
        ) = 0;

    // Create an image object from a file

    STDMETHOD(CreateImageFromFile)(
        IN const WCHAR* filename,
        OUT IImage** image
        ) = 0;
    
    // Create an image object from a memory buffer

    STDMETHOD(CreateImageFromBuffer)(
        IN const VOID* buf,
        IN UINT size,
        IN BufferDisposalFlag disposalFlag,
        OUT IImage** image
        ) = 0;

    // Create a new bitmap image object

    STDMETHOD(CreateNewBitmap)(
        IN UINT width,
        IN UINT height,
        IN PixelFormatID pixelFormat,
        OUT IBitmapImage** bitmap
        ) = 0;

    // Create a bitmap image from an IImage object

    STDMETHOD(CreateBitmapFromImage)(
        IN IImage* image,
        IN OPTIONAL UINT width,
        IN OPTIONAL UINT height,
        IN OPTIONAL PixelFormatID pixelFormat,
        IN InterpolationHint hints,
        OUT IBitmapImage** bitmap
        ) = 0;

    // Create a new bitmap image object on user-supplied memory buffer

    STDMETHOD(CreateBitmapFromBuffer)(
        IN BitmapData* bitmapData,
        OUT IBitmapImage** bitmap
        ) = 0;

    // Create an image decoder object to process the given input stream

    STDMETHOD(CreateImageDecoder)(
        IN IStream* stream,
        IN DecoderInitFlag flags,
        OUT IImageDecoder** decoder
        ) = 0;

    // Create an image encoder object that can output data in the
    // specified image file format.

    STDMETHOD(CreateImageEncoderToStream)(
        IN const CLSID* clsid,
        IN IStream* stream,
        OUT IImageEncoder** encoder
        ) = 0;

    STDMETHOD(CreateImageEncoderToFile)(
        IN const CLSID* clsid,
        IN const WCHAR* filename,
        OUT IImageEncoder** encoder
        ) = 0;

    // Get a list of all currently installed image decoders

    STDMETHOD(GetInstalledDecoders)(
        OUT UINT* count,
        OUT ImageCodecInfo** decoders
        ) = 0;

    // Get a list of all currently installed image decoders

    STDMETHOD(GetInstalledEncoders)(
        OUT UINT* count,
        OUT ImageCodecInfo** encoders
        ) = 0;

    // Install an image encoder / decoder
    //  caller should do the regular COM component
    //  installation before calling this method

    STDMETHOD(InstallImageCodec)(
        IN const ImageCodecInfo* codecInfo
        ) = 0;

    // Uninstall an image encoder / decoder

    STDMETHOD(UninstallImageCodec)(
        IN const WCHAR* codecName,
        IN UINT flags
        ) = 0;

    // Create an in-memory IPropertySetStorage object

    STDMETHOD(CreateMemoryPropertyStore)(
        IN OPTIONAL HGLOBAL hmem,
        OUT IPropertySetStorage** propSet
        ) = 0;
};


//--------------------------------------------------------------------------
// Image interface
//  bitmap image
//  vector image
//  procedural image
//--------------------------------------------------------------------------

MIDL_INTERFACE("327ABDA9-072B-11D3-9D7B-0000F81EF32E")
IImage : public IUnknown
{
public:

    // Get the device-independent physical dimension of the image
    //  in unit of 0.01mm

    STDMETHOD(GetPhysicalDimension)(
        OUT SIZE* size
        ) = 0;

    // Get basic image info

    STDMETHOD(GetImageInfo)(
        OUT ImageInfo* imageInfo
        ) = 0;

    // Set image flags

    STDMETHOD(SetImageFlags)(
        IN UINT flags
        ) = 0;

    // Display the image in a GDI device context

    STDMETHOD(Draw)(
        IN HDC hdc,
        IN const RECT* dstRect,
        IN OPTIONAL const RECT* srcRect
        ) = 0;

    // Push image data into an IImageSink

    STDMETHOD(PushIntoSink)(
        IN IImageSink* sink
        ) = 0;

    // Get a thumbnail representation for the image object

    STDMETHOD(GetThumbnail)(
        IN OPTIONAL UINT thumbWidth,
        IN OPTIONAL UINT thumbHeight,
        OUT IImage** thumbImage
        ) = 0;

    // Get/set the properties in the standard property set
    //  x-res
    //  y-res
    //  gamma
    //  ICC profile
    //  thumbnail
    //  tile width
    //  tile height
    //
    // Property-related methods

    STDMETHOD(GetProperties)(
        IN DWORD mode,
        OUT IPropertySetStorage** propSet
        ) = 0;
};


//--------------------------------------------------------------------------
// Bitmap interface
//--------------------------------------------------------------------------

MIDL_INTERFACE("327ABDAA-072B-11D3-9D7B-0000F81EF32E")
IBitmapImage : public IUnknown
{
public:

    // Get bitmap dimensions in pixels

    STDMETHOD(GetSize)(
        OUT SIZE* size
        ) = 0;

    // Get bitmap pixel format

    STDMETHOD(GetPixelFormatID)(
        OUT PixelFormatID* pixelFormat
        ) = 0;

    // Access bitmap data in the specified pixel format
    //  must support at least PIXFMT_DONTCARE and
    //  the caninocal formats.

    STDMETHOD(LockBits)(
        IN const RECT* rect,
        IN UINT flags,
        IN PixelFormatID pixelFormat,
        IN OUT BitmapData* lockedBitmapData
        ) = 0;

    STDMETHOD(UnlockBits)(
        IN const BitmapData* lockedBitmapData
        ) = 0;

    // Set/get palette associated with the bitmap image

    STDMETHOD(GetPalette)(
        OUT ColorPalette** palette
        ) = 0;

    STDMETHOD(SetPalette)(
        IN const ColorPalette* palette
        ) = 0;
};


//--------------------------------------------------------------------------
// Interface for performing basic operations on a bitmap image
//  This can be QI'ed from an IBitmapImage object.
//--------------------------------------------------------------------------

MIDL_INTERFACE("327ABDAF-072B-11D3-9D7B-0000F81EF32E")
IBasicBitmapOps : public IUnknown
{
public:

    // Clone an area of the bitmap image

    STDMETHOD(Clone)(
        IN OPTIONAL const RECT* rect,
        OUT IBitmapImage** outbmp
        );

    // Flip the bitmap image in x- and/or y-direction

    STDMETHOD(Flip)(
        IN BOOL flipX,
        IN BOOL flipY,
        OUT IBitmapImage** outbmp
        ) = 0;

    // Resize the bitmap image

    STDMETHOD(Resize)(
        IN UINT newWidth,
        IN UINT newHeight,
        IN PixelFormatID pixelFormat,
        IN InterpolationHint hints,
        OUT IBitmapImage** outbmp
        ) = 0;

    // Rotate the bitmap image by the specified angle

    STDMETHOD(Rotate)(
        IN FLOAT angle,
        IN InterpolationHint hints,
        OUT IBitmapImage** outbmp
        ) = 0;

    // Adjust the brightness of the bitmap image

    STDMETHOD(AdjustBrightness)(
        IN FLOAT percent
        ) = 0;
    
    // Adjust the contrast of the bitmap image

    STDMETHOD(AdjustContrast)(
        IN FLOAT shadow,
        IN FLOAT highlight
        ) = 0;
    
    // Adjust the gamma of the bitmap image

    STDMETHOD(AdjustGamma)(
        IN FLOAT gamma
        ) = 0;
};


//--------------------------------------------------------------------------
// Image decoder interface
//--------------------------------------------------------------------------

MIDL_INTERFACE("327ABDAB-072B-11D3-9D7B-0000F81EF32E")
IImageDecoder : public IUnknown
{
public:

    // Initialize the image decoder object

    STDMETHOD(InitDecoder)(
        IN IStream* stream,
        IN DecoderInitFlag flags
        ) = 0;

    // Clean up the image decoder object

    STDMETHOD(TerminateDecoder)() = 0;

    // Start decoding the current frame

    STDMETHOD(BeginDecode)(
        IN IImageSink* sink,
        IN OPTIONAL IPropertySetStorage* newPropSet
        ) = 0;

    // Continue decoding

    STDMETHOD(Decode)() = 0;

    // Stop decoding the current frame

    STDMETHOD(EndDecode)(
        IN HRESULT statusCode
        ) = 0;

    // Query multi-frame dimensions

    STDMETHOD(QueryFrameDimensions)(
        OUT UINT* count,
        OUT GUID** dimensionIDs
        ) = 0;

    // Get number of frames for the specified dimension

    STDMETHOD(GetFrameCount)(
        IN const GUID* dimensionID,
        OUT UINT* count
        ) = 0;

    // Select currently active frame

    STDMETHOD(SelectActiveFrame)(
        IN const GUID* dimensionID,
        IN UINT frameIndex
        ) = 0;

    // Get basic information about the image

    STDMETHOD(GetImageInfo)(
        OUT ImageInfo* imageInfo
        ) = 0;

    // Get image thumbnail

    STDMETHOD(GetThumbnail)(
        IN OPTIONAL UINT thumbWidth,
        IN OPTIONAL UINT thumbHeight,
        OUT IImage** thumbImage
        ) = 0;

    // Property/metadata related methods

    STDMETHOD(GetProperties)(
        OUT IPropertySetStorage** propSet
        ) = 0;

    // Query decoder parameters

    STDMETHOD(QueryDecoderParam)(
        IN GUID		Guid
        ) = 0;

    // Set decoder parameters

    STDMETHOD(SetDecoderParam)(
        IN GUID		Guid,
		IN UINT		Length,
		IN PVOID	Value
        ) = 0;
};


//--------------------------------------------------------------------------
// Image decode sink interface
//--------------------------------------------------------------------------

MIDL_INTERFACE("327ABDAE-072B-11D3-9D7B-0000F81EF32E")
IImageSink : public IUnknown
{
public:

    // Begin the sink process

    STDMETHOD(BeginSink)(
        IN OUT ImageInfo* imageInfo,
        OUT OPTIONAL RECT* subarea
        ) = 0;

    // End the sink process

    STDMETHOD(EndSink)(
        IN HRESULT statusCode
        ) = 0;

    // Pass the color palette to the image sink

    STDMETHOD(SetPalette)(
        IN const ColorPalette* palette
        ) = 0;

    // Ask the sink to allocate pixel data buffer

    STDMETHOD(GetPixelDataBuffer)(
        IN const RECT* rect,
        IN PixelFormatID pixelFormat,
        IN BOOL lastPass,
        OUT BitmapData* bitmapData
        ) = 0;

    // Give the sink pixel data and release data buffer

    STDMETHOD(ReleasePixelDataBuffer)(
        IN const BitmapData* bitmapData
        ) = 0;

    // Push pixel data

    STDMETHOD(PushPixelData)(
        IN const RECT* rect,
        IN const BitmapData* bitmapData,
        IN BOOL lastPass
        ) = 0;

    // Push raw image data

    STDMETHOD(PushRawData)(
        IN const VOID* buffer,
        IN UINT bufsize
        ) = 0;

    // Methods for passing metadata / properties

    STDMETHOD(PushProperties)(
        IN IPropertySetStorage* propSet
        ) = 0;
    
    STDMETHOD(NeedTransform)(
        OUT UINT* rotation
        ) = 0;

    STDMETHOD(PushRawInfo)(
    IN OUT void* info
    ) = 0;

};


//--------------------------------------------------------------------------
// Image encoder interface
//--------------------------------------------------------------------------

MIDL_INTERFACE("327ABDAC-072B-11D3-9D7B-0000F81EF32E")
IImageEncoder : public IUnknown
{
public:

    // Initialize the image encoder object

    STDMETHOD(InitEncoder)(
        IN IStream* stream
        ) = 0;
    
    // Clean up the image encoder object

    STDMETHOD(TerminateEncoder)() = 0;

    // Get an IImageSink interface for encoding the next frame

    STDMETHOD(GetEncodeSink)(
        OUT IImageSink** sink
        ) = 0;
    
    // Set active frame dimension

    STDMETHOD(SetFrameDimension)(
        IN const GUID* dimensionID
        ) = 0;
    
    // Query encoder parameters

    STDMETHOD(QueryEncoderParam)(
        OUT EncoderParams** Params
    ) = 0;

    // Set encoder parameters

    STDMETHOD(SetEncoderParam)(
        IN EncoderParams* Param
        ) = 0;
};


//--------------------------------------------------------------------------
// Imaging library error codes
//
// !!! TODO
//  How does one pick a facility code?
//
// Standard error code used:
//  E_INVALIDARG
//  E_OUTOFMEMORY
//  E_NOTIMPL
//  E_ACCESSDENIED
//  E_PENDING
//--------------------------------------------------------------------------

#define FACILITY_IMAGING        0x87b
#define MAKE_IMGERR(n)          MAKE_HRESULT(SEVERITY_ERROR, FACILITY_IMAGING, n)
#define IMGERR_OBJECTBUSY       MAKE_IMGERR(1)
#define IMGERR_NOPALETTE        MAKE_IMGERR(2)
#define IMGERR_BADLOCK          MAKE_IMGERR(3)
#define IMGERR_BADUNLOCK        MAKE_IMGERR(4)
#define IMGERR_NOCONVERSION     MAKE_IMGERR(5)
#define IMGERR_CODECNOTFOUND    MAKE_IMGERR(6)
#define IMGERR_NOFRAME          MAKE_IMGERR(7)
#define IMGERR_ABORT            MAKE_IMGERR(8)

#endif // !_IMAGING_H
=== C:/Users/treeman/Desktop/windows nt source code\Source\Win2K3\NT\multimedia\dshow\mfvideo\mswebdvd\iso3166.h ===
// Copyright (c) 1998 - 1999  Microsoft Corporation.  All Rights Reserved.
#ifndef __ISO3166_H
#define __ISO3166_H

char DVDToUpper(char x)
{
    if('a' <= x && x <= 'z') {
        return x - ('a' - 'A');
    } else {
        return x;
    }
}

struct ISO3166
{
    const char *Code;
    
    // access the table as ISO3166::GetCountry()
    static const ISO3166& GetCountry( unsigned i );
    static unsigned	GetNumCountries();

    // creates an ISO code from a two letter string
    static WORD	PackCode( const char string[2] )
    {
        return DVDToUpper(string[0])<<8 | DVDToUpper(string[1]);
    }
    
};

// ISO3166 country code table
static const ISO3166 g_Table[] =
{ // current as of Dec 22, 2000
    {/* "Afghanistan", */       "AF"},
    {/* "Albania", */           "AL"},
    {/* "Algeria", */           "DZ"},
    {/* "American Samoa", */    "AS"},
    {/* "Andorra", */           "AD"},
    {/* "Angola", */            "AO"},
    {/* "Anguilla", */          "AI"},
    {/* "Antarctica", */        "AQ"},
    {/* "Antigua and Barbuda", */  "AG"},
    {/* "Argentina", */         "AR"},
    {/* "Armenia", */           "AM"},
    {/* "Aruba", */             "AW"},
    {/* "Australia", */         "AU"},
    {/* "Austria", */           "AT"},
    {/* "Azerbaijan", */        "AZ"},
    {/* "Bahamas", */           "BS"},
    {/* "Bahrain", */           "BH"},
    {/* "Bangladesh", */        "BD"},
    {/* "Barbados", */          "BB"},
    {/* "Belarus", */           "BY"},
    {/* "Belgium", */           "BE"},
    {/* "Belize", */            "BZ"},
    {/* "Benin", */             "BJ"},
    {/* "Bermuda", */           "BM"},
    {/* "Bhutan", */            "BT"},
    {/* "Bolivia", */           "BO"},
    {/* "Bosnia and Herzegovina", */        "BA"},
    {/* "Botswana", */          "BW"},
    {/* "Bouvet Island", */     "BV"},
    {/* "Brazil", */            "BR"},
    {/* "British Indian Ocean Territory", */  "IO"},
    {/* "Brunei Darussalam", */ "BN"},
    {/* "Bulgaria", */          "BG"},
    {/* "Burkina Faso", */      "BF"},
    {/* "Burundi", */           "BI"},
    {/* "Cambodia", */          "KH"},
    {/* "Cameroon", */          "CM"},
    {/* "Canada", */            "CA"},
    {/* "Cape Verde", */        "CV"},
    {/* "Cayman Islands", */    "KY"},
    {/* "Central African Republic", */      "CF"},
    {/* "Chad", */              "TD"},
    {/* "Channel Islands", */	"GB"},
    {/* "Chile", */             "CL"},
    {/* "China", */             "CN"},
    {/* "Christmas Island", */  "CX"},
    {/* "Cocos (Keeling) Islands", */       "CC"},
    {/* "Colombia", */          "CO"},
    {/* "Comoros", */           "KM"},
    {/* "Congo", */             "CG"},
    {/* "Cook Islands", */      "CK"},
    {/* "Costa Rica", */        "CR"},
    {/* "Cte d'Ivoire", */     "CI"},
    {/* "Croatia (local name: Hrvatska)", */  "HR"},
    {/* "Cuba", */              "CU"},
    {/* "Cyprus", */            "CY"},
    {/* "Czech Republic", */    "CZ"},
    {/* "Denmark", */           "DK"},
    {/* "Djibouti", */          "DJ"},
    {/* "Dominica", */          "DM"},
    {/* "Dominican Republic", */  "DO"},
    {/* "East Timor", */        "TP"},
    {/* "Ecuador", */           "EC"},
    {/* "Egypt", */             "EG"},
    {/* "El Salvador", */       "SV"},
    {/* "Equatorial Guinea", */  "GQ"},
    {/* "Eritrea", */           "ER"},
    {/* "Estonia", */           "EE"},
    {/* "Ethiopia", */          "ET"},
    {/* "Falkland Islands (Malvinas)", */   "FK"},
    {/* "Faroe Islands", */     "FO"},
    {/* "Fiji", */              "FJ"},
    {/* "Finland", */           "FI"},
    {/* "France", */            "FR"},
    {/* "France, Metropolitan", */  "FX"},
    {/* "French Guiana", */     "GF"},
    {/* "French Polynesia", */  "PF"},
    {/* "French Southern and Antarctic Lands", */	"TF"},
    {/* "Gabon", */             "GA"},
    {/* "Gambia", */            "GM"},
    {/* "Georgia", */           "GE"},
    {/* "Germany", */           "DE"},
    {/* "Ghana", */             "GH"},
    {/* "Gibraltar", */         "GI"},
    {/* "Greece", */            "GR"},
    {/* "Greenland", */         "GL"},
    {/* "Grenada", */           "GD"},
    {/* "Guadeloupe", */        "GP"},
    {/* "Guam", */              "GU"},
    {/* "Guatemala", */         "GT"},
    {/* "Guinea", */            "GN"},
    {/* "Guinea-Bissau", */     "GW"},
    {/* "Guyana", */            "GY"},
    {/* "Haiti", */             "HT"},
    {/* "Heard and Mc Donald Islands", */   "HM"},
    {/* "Holy See (Vatican City State)", */ "VA"},
    {/* "Honduras", */          "HN"},
    {/* "Hong Kong SAR", */         "HK"},
    {/* "Hungary", */           "HU"},
    {/* "Iceland", */           "IS"},
    {/* "India", */             "IN"},
    {/* "Indonesia", */         "ID"},
    {/* "Iran (Islamic Republic Of)", */    "IR"},
    {/* "Iraq", */              "IQ"},
    {/* "Ireland", */           "IE"},
    {/* "Israel", */            "IL"},
    {/* "Italy", */             "IT"},
    {/* "Jamaica", */           "JM"},
    {/* "Japan", */             "JP"},
    {/* "Jordan", */            "JO"},
    {/* "Kazakhstan", */        "KZ"},
    {/* "Kenya", */             "KE"},
    {/* "Kiribati", */          "KI"},
    {/* "Korea, Democratic People's Republic Of", */  "KP"},
    {/* "Korea, Republic Of", */  "KR"},
    {/* "Kuwait", */            "KW"},
    {/* "Kyrgyzstan", */        "KG"},
    {/* "Lao People's Democratic Republic", */  "LA"},
    {/* "Latvia", */            "LV"},
    {/* "Lebanon", */           "LB"},
    {/* "Lesotho", */           "LS"},
    {/* "Liberia", */           "LR"},
    {/* "Libyan Arab Jamahiriya", */        "LY"},
    {/* "Liechtenstein", */     "LI"},
    {/* "Lithuania", */         "LT"},
    {/* "Luxembourg", */        "LU"},
    {/* "Macau SAR", */             "MO"},
    {/* "Macedonia, The Former Yugoslav Republic Of", */  "MK"},
    {/* "Madagascar", */        "MG"},
    {/* "Malawi", */            "MW"},
    {/* "Malaysia", */          "MY"},
    {/* "Maldives", */          "MV"},
    {/* "Mali", */              "ML"},
    {/* "Malta", */             "MT"},
    {/* "Man, Isle of",*/   	"GB"},
    {/* "Marshall Islands", */  "MH"},
    {/* "Martinique", */        "MQ"},
    {/* "Mauritania", */        "MR"},
    {/* "Mauritius", */         "MU"},
    {/* "Mayotte", */           "YT"},
    {/* "Mexico", */            "MX"},
    {/* "Micronesia, Federated States Of", */  "FM"},
    {/* "Moldova, Republic Of", */          "MD"},
    {/* "Monaco", */            "MC"},
    {/* "Mongolia", */          "MN"},
    {/* "Montserrat", */        "MS"},
    {/* "Morocco", */           "MA"},
    {/* "Mozambique", */        "MZ"},
    {/* "Myanmar", */           "MM"},
    {/* "Namibia", */           "NA"},
    {/* "Nauru", */             "NR"},
    {/* "Nepal", */             "NP"},
    {/* "Netherlands", */       "NL"},
    {/* "Netherlands ANTILLES", */          "AN"},
    {/* "New Caledonia", */     "NC"},
    {/* "New Zealand", */       "NZ"},
    {/* "Nicaragua", */         "NI"},
    {/* "Niger", */             "NE"},
    {/* "Nigeria", */           "NG"},
    {/* "Niue", */              "NU"},
    {/* "Norfolk Island", */    "NF"},
    {/* "Northern Mariana Islands", */      "MP"},
    {/* "Norway", */            "NO"},
    {/* "Oman", */              "OM"},
    {/* "Pakistan", */          "PK"},
    {/* "Palau", */             "PW"},
    {/* "Panama", */            "PA"},
    {/* "Papua New Guinea", */  "PG"},
    {/* "Paraguay", */          "PY"},
    {/* "Peru", */              "PE"},
    {/* "Philippines", */       "PH"},
    {/* "Pitcairn Islands", */  "PN"},
    {/* "Poland", */            "PL"},
    {/* "Portugal", */          "PT"},
    {/* "Puerto Rico", */       "PR"},
    {/* "Qatar", */             "QA"},
    {/* "Reunion", */           "RE"},
    {/* "Romania", */           "RO"},
    {/* "Russian Federation", */            "RU"},
    {/* "Rwanda", */            "RW"},
    {/* "Saint Kitts and Nevis", */         "KN"},
    {/* "Saint Lucia", */       "LC"},
    {/* "Saint Vincent and The Grenadines", */  "VC"},
    {/* "Samoa", */             "WS"},
    {/* "San Marino", */        "SM"},
    {/* "So Tom and Prncipe ", */         "ST"},
    {/* "Saudi Arabia", */      "SA"},
    {/* "Senegal", */           "SN"},
    {/* "Seychelles", */        "SC"},
    {/* "Sierra Leone", */      "SL"},
    {/* "Singapore", */         "SG"},
    {/* "Slovakia (Slovak Republic)", */    "SK"},
    {/* "Slovenia", */          "SI"},
    {/* "Solomon Islands", */   "SB"},
    {/* "Somalia", */           "SO"},
    {/* "South Africa", */      "ZA"},
    {/* "South Georgia and The South Sandwich Islands", */  "GS"},
    {/* "Spain", */             "ES"},
    {/* "Sri Lanka", */         "LK"},
    {/* "St. Helena", */        "SH"},
    {/* "St. Pierre and Miquelon", */        "PM"},
    {/* "Sudan", */             "SD"},
    {/* "Suriname", */          "SR"},
    {/* "Svalbard and Jan Mayen Islands", */ "SJ"},
    {/* "Swaziland", */         "SZ"},
    {/* "Sweden", */            "SE"},
    {/* "Switzerland", */       "CH"},
    {/* "Syrian Arab Republic", */  "SY"},
    {/* "Taiwan", */            "TW"},
    {/* "Tajikistan", */        "TJ"},
    {/* "Tanzania, United Republic Of", */  "TZ"},
    {/* "Thailand", */          "TH"},
    {/* "Togo", */              "TG"},
    {/* "Tokelau", */           "TK"},
    {/* "Tonga", */             "TO"},
    {/* "Trinidad and Tobago", */  "TT"},
    {/* "Tunisia", */           "TN"},
    {/* "Turkey", */            "TR"},
    {/* "Turkmenistan", */      "TM"},
    {/* "Turks and Caicos Islands", */      "TC"},
    {/* "Tuvalu", */            "TV"},
    {/* "Uganda", */            "UG"},
    {/* "Ukraine", */           "UA"},
    {/* "United Arab Emirates", */  "AE"},
    {/* "United Kingdom", */    "GB"},
    {/* "United States", */     "US"},
    {/* "U.S. Minor Outlying Islands", */  "UM"},
    {/* "Uruguay", */           "UY"},
    {/* "Uzbekistan", */        "UZ"},
    {/* "Vanuatu", */           "VU"},
    {/* "Venezuela", */         "VE"},
    {/* "Viet Nam", */          "VN"},
    {/* "Virgin Islands (British)", */      "VG"},
    {/* "Virgin Islands (U.S.)", */         "VI"},
    {/* "Wallis and Futuna Islands", */     "WF"},
    {/* "Yemen", */             "YE"},
    {/* "Yugoslavia", */        "YU"},
    {/* "Congo (DRC)", */             "ZR"},
    {/* "Zambia", */            "ZM"},
    {/* "Zimbabwe", */          "ZW"}
};

static const unsigned g_uTableSize = sizeof( g_Table )/ sizeof( g_Table[0] );

const ISO3166& ISO3166::GetCountry( unsigned i )
{
    return g_Table[i];
}

unsigned ISO3166::GetNumCountries()
{
    return g_uTableSize;
}

#endif
=== C:/Users/treeman/Desktop/windows nt source code\Source\Win2K3\NT\multimedia\dshow\mfvideo\mswebdvd\mediahndlr.h ===
//
// Copyright (c) 1996 - 1999  Microsoft Corporation.  All Rights Reserved.
//
#ifndef __CMediaHandler__h
#define __CMediaHandler__h

#include "msgwindow.h"

class CMSWebDVD;
//
//  Specific code
//
class CMediaHandler : public CMsgWindow 
{
    typedef CMsgWindow ParentClass ;

public:
                        CMediaHandler();
                        ~CMediaHandler() ;

    virtual LRESULT     WndProc( UINT uMsg, WPARAM wParam, LPARAM lParam );

    bool                WasEjected() const { return m_ejected; };
    bool                WasInserted() const { return m_inserted; };
    void                ClearFlags();

    bool                SetDrive( TCHAR tcDriveLetter );

    // currently unused by the pump thread, but it will be required if the ejection
    // handler becomes a new thread
    HANDLE              GetEventHandle() const;

    void                SetDVD(CMSWebDVD* pDVD) {m_pDVD = pDVD;};

private:
    DWORD               m_driveMask;

    bool                m_ejected;
    bool                m_inserted;
    CMSWebDVD*          m_pDVD;
};
#endif
=== C:/Users/treeman/Desktop/windows nt source code\Source\Win2K3\NT\multimedia\dshow\mfvideo\mswebdvd\imgguids.h ===
/**************************************************************************\
* 
* Copyright (c) 1999  Microsoft Corporation
*
* Module Name:
*
*   imgguids.h
*
* Abstract:
*
*   GUIDs defined and used by the imaging library
*
* Revision History:
*
*   05/10/1999 davidx
*       Created it.
*
\**************************************************************************/

//
// Image file format identifiers
//

DEFINE_GUID(IMGFMT_UNDEFINED, 0xb96b3ca9,0x0728,0x11d3,0x9d,0x7b,0x00,0x00,0xf8,0x1e,0xf3,0x2e);
DEFINE_GUID(IMGFMT_MEMORYBMP, 0xb96b3caa,0x0728,0x11d3,0x9d,0x7b,0x00,0x00,0xf8,0x1e,0xf3,0x2e);
DEFINE_GUID(IMGFMT_BMP, 0xb96b3cab,0x0728,0x11d3,0x9d,0x7b,0x00,0x00,0xf8,0x1e,0xf3,0x2e);
DEFINE_GUID(IMGFMT_EMF, 0xb96b3cac,0x0728,0x11d3,0x9d,0x7b,0x00,0x00,0xf8,0x1e,0xf3,0x2e);
DEFINE_GUID(IMGFMT_WMF, 0xb96b3cad,0x0728,0x11d3,0x9d,0x7b,0x00,0x00,0xf8,0x1e,0xf3,0x2e);
DEFINE_GUID(IMGFMT_JPEG, 0xb96b3cae,0x0728,0x11d3,0x9d,0x7b,0x00,0x00,0xf8,0x1e,0xf3,0x2e);
DEFINE_GUID(IMGFMT_PNG, 0xb96b3caf,0x0728,0x11d3,0x9d,0x7b,0x00,0x00,0xf8,0x1e,0xf3,0x2e);
DEFINE_GUID(IMGFMT_GIF, 0xb96b3cb0,0x0728,0x11d3,0x9d,0x7b,0x00,0x00,0xf8,0x1e,0xf3,0x2e);
DEFINE_GUID(IMGFMT_TIFF, 0xb96b3cb1,0x0728,0x11d3,0x9d,0x7b,0x00,0x00,0xf8,0x1e,0xf3,0x2e);
DEFINE_GUID(IMGFMT_EXIF, 0xb96b3cb2,0x0728,0x11d3,0x9d,0x7b,0x00,0x00,0xf8,0x1e,0xf3,0x2e);
DEFINE_GUID(IMGFMT_PHOTOCD, 0xb96b3cb3,0x0728,0x11d3,0x9d,0x7b,0x00,0x00,0xf8,0x1e,0xf3,0x2e);
DEFINE_GUID(IMGFMT_FLASHPIX, 0xb96b3cb4,0x0728,0x11d3,0x9d,0x7b,0x00,0x00,0xf8,0x1e,0xf3,0x2e);
DEFINE_GUID(IMGFMT_ICO, 0xb96b3cb5,0x0728,0x11d3,0x9d,0x7b,0x00,0x00,0xf8,0x1e,0xf3,0x2e);

//
// Interface and class identifiers
//

DEFINE_GUID(IID_IImagingFactory, 0x327abda7,0x072b,0x11d3,0x9d,0x7b,0x00,0x00,0xf8,0x1e,0xf3,0x2e);
DEFINE_GUID(CLSID_ImagingFactory, 0x327abda8,0x072b,0x11d3,0x9d,0x7b,0x00,0x00,0xf8,0x1e,0xf3,0x2e);
DEFINE_GUID(IID_IImage, 0x327abda9,0x072b,0x11d3,0x9d,0x7b,0x00,0x00,0xf8,0x1e,0xf3,0x2e);
DEFINE_GUID(IID_IBitmapImage, 0x327abdaa,0x072b,0x11d3,0x9d,0x7b,0x00,0x00,0xf8,0x1e,0xf3,0x2e);
DEFINE_GUID(IID_IImageDecoder, 0x327abdab,0x072b,0x11d3,0x9d,0x7b,0x00,0x00,0xf8,0x1e,0xf3,0x2e);
DEFINE_GUID(IID_IImageEncoder, 0x327abdac,0x072b,0x11d3,0x9d,0x7b,0x00,0x00,0xf8,0x1e,0xf3,0x2e);
DEFINE_GUID(IID_IImageSink, 0x327abdae,0x072b,0x11d3,0x9d,0x7b,0x00,0x00,0xf8,0x1e,0xf3,0x2e);
DEFINE_GUID(IID_IBasicBitmapOps, 0x327abdaf,0x072b,0x11d3,0x9d,0x7b,0x00,0x00,0xf8,0x1e,0xf3,0x2e);

//
// Predefined multi-frame dimension IDs
//

DEFINE_GUID(FRAMEDIM_TIME, 0x6aedbd6d,0x3fb5,0x418a,0x83,0xa6,0x7f,0x45,0x22,0x9d,0xc8,0x72);
DEFINE_GUID(FRAMEDIM_RESOLUTION, 0x84236f7b,0x3bd3,0x428f,0x8d,0xab,0x4e,0xa1,0x43,0x9c,0xa3,0x15);
DEFINE_GUID(FRAMEDIM_PAGE, 0x7462dc86,0x6180,0x4c7e,0x8e,0x3f,0xee,0x73,0x33,0xa7,0xa4,0x83);

//
// Property sets
//

DEFINE_GUID(FMTID_ImageInformation, 0xe5836cbe,0x5eef,0x4f1d,0xac,0xde,0xae,0x4c,0x43,0xb6,0x08,0xce);
DEFINE_GUID(FMTID_JpegAppHeaders, 0x1c4afdcd,0x6177,0x43cf,0xab,0xc7,0x5f,0x51,0xaf,0x39,0xee,0x85);

//
// Decoder parameter sets
//
DEFINE_GUID(DECODER_TRANSCOLOR, 0xb7a98c8f,0xdce7,0x457d,0xbf,0xa5,0xce,0xa7,0x1b,0xd1,0x4d,0xd6);
DEFINE_GUID(DECODER_TRANSRANGE, 0xabeed189,0xd988,0x4d03,0xb4,0x25,0x57,0x10,0x55,0xc7,0x6a,0xd1);
DEFINE_GUID(DECODER_OUTPUTCHANNEL, 0x2ff8f51e,0x724d,0x45fe,0x86,0xce,0x17,0x77,0xa0,0x56,0xda,0x60);
 
//
// Encoder parameter sets
//
DEFINE_GUID(ENCODER_COMPRESSION, 0xe09d739d,0xccd4,0x44ee,0x8e,0xba,0x3f,0xbf,0x8b,0xe4,0xfc,0x58);
DEFINE_GUID(ENCODER_COLORDEPTH, 0x66087055,0xad66,0x4c7c,0x9a,0x18,0x38,0xa2,0x31,0x0b,0x83,0x37);
DEFINE_GUID(ENCODER_SCANMETHOD, 0x3a4e2661,0x3109,0x4e56,0x85,0x36,0x42,0xc1,0x56,0xe7,0xdc,0xfa);
DEFINE_GUID(ENCODER_VERSION, 0x24d18c76,0x814a,0x41a4,0xbf,0x53,0x1c,0x21,0x9c,0xcc,0xf7,0x97);
DEFINE_GUID(ENCODER_RENDERMETHOD, 0x6d42c53a,0x229a,0x4825,0x8b,0xb7,0x5c,0x99,0xe2,0xb9,0xa8,0xb8);
DEFINE_GUID(ENCODER_QUALITY, 0x1d5be4b5,0xfa4a,0x452d,0x9c,0xdd,0x5d,0xb3,0x51,0x05,0xe7,0xeb);
DEFINE_GUID(ENCODER_ROTATION,0x109555d4,0x2ab6,0x4379,0xa8,0x3f,0x5d,0x78,0xfa,0x53,0x8c,0x45);
=== C:/Users/treeman/Desktop/windows nt source code\Source\Win2K3\NT\multimedia\dshow\mfvideo\mswebdvd\mediahndlr.cpp ===
// Copyright (c) 1999  Microsoft Corporation.  All Rights Reserved.
#include <stdafx.h>

#include <winuser.h>
#include <windows.h>

#include "mswebdvd.h"
#include "msdvd.h"
#include "MediaHndlr.h"
#include <dbt.h>    // device broadcast structure

//
//  Ejection event handler
//

CMediaHandler::CMediaHandler()
: m_driveMask( 0 )
, m_ejected( false )
, m_inserted( false )
{
    m_pDVD = NULL;
}

CMediaHandler::~CMediaHandler()
{
}

void CMediaHandler::ClearFlags()
{
    m_ejected = false;
    m_inserted = false;
}

bool CMediaHandler::SetDrive( TCHAR tcDriveLetter )
{
    if( TEXT('A') <= tcDriveLetter && tcDriveLetter <= TEXT('Z') ) {
        m_driveMask = 1<< (tcDriveLetter-TEXT('A'));
    } else if( TEXT('a') <= tcDriveLetter && tcDriveLetter <= TEXT('z')) {
        m_driveMask = 1<< (tcDriveLetter-TEXT('a'));
    } else {
        return false;
    }
    ClearFlags();
    return true;
}

LRESULT CMediaHandler::WndProc( UINT uMsg, WPARAM wParam, LPARAM lParam )
{
    if (m_pDVD == NULL)
        return ParentClass::WndProc( uMsg, wParam, lParam);

    switch (uMsg) {
        case WM_DEVICECHANGE:
        {
            switch( wParam ) {
            case DBT_DEVICEREMOVECOMPLETE:
            case DBT_DEVICEARRIVAL:
            case DBT_DEVICEQUERYREMOVE:
            {
                PDEV_BROADCAST_HDR pdbch = (PDEV_BROADCAST_HDR) lParam;
                if(pdbch->dbch_devicetype == DBT_DEVTYP_VOLUME ) {
                    PDEV_BROADCAST_VOLUME pdbcv = (PDEV_BROADCAST_VOLUME) pdbch;
                    if (pdbcv->dbcv_flags == DBTF_MEDIA || wParam == DBT_DEVICEQUERYREMOVE) 
                    {
                        // pdbcv->dbcv_unitmask identifies which logical drive
                        switch( wParam ) {
                            case DBT_DEVICEARRIVAL:
                                if( pdbcv->dbcv_unitmask & m_driveMask ) {
                                    // send change event
                                    if( !m_inserted ) {
                                        CComVariant var = 0;
                                        m_pDVD->Fire_DVDNotify(EC_DVD_DISC_INSERTED, var, var);
                                    }
                                    m_inserted = true;
                                    m_ejected = false;
                                    m_pDVD->SetDiscEjected(false);
                                }
                                // return TRUE .. see the MSDN docs for DBT_DEVICEQUERYREMOVE
                                return TRUE;

                            case DBT_DEVICEQUERYREMOVE:
                                if( pdbcv->dbcv_unitmask & m_driveMask ) {
                                    if( !m_ejected ) {
                                        CComVariant var = 0;
                                        m_pDVD->Fire_DVDNotify(EC_DVD_DISC_EJECTED, var, var);
                                    }
                                    m_ejected = true;
                                    m_inserted = false;
                                    m_pDVD->SetDiscEjected(true);

                                }
                                return TRUE;    // grant permission

                            case DBT_DEVICEREMOVECOMPLETE:
                                if( pdbcv->dbcv_unitmask & m_driveMask ) {
                                    if( !m_ejected ) {
                                        CComVariant var = 0;
                                        m_pDVD->Fire_DVDNotify(EC_DVD_DISC_EJECTED, var, var);
                                    }
                                    m_ejected = true;
                                    m_inserted = false;
                                    m_pDVD->SetDiscEjected(true);
                                }
                                return TRUE;    // grant permission

                            default:
                                return TRUE;
                        }
                    }
                }
                break;
            }
            default:
                break;
            }
            break;
        }
        default:
            break;
    }
    return ParentClass::WndProc( uMsg, wParam, lParam);
}
=== C:/Users/treeman/Desktop/windows nt source code\Source\Win2K3\NT\multimedia\dshow\mfvideo\mswebdvd\msdvdadm.cpp ===
/*************************************************************************/
/* Copyright (C) 1999 Microsoft Corporation                              */
/* File: MSDVDAdm.cpp                                                    */
/* Description: DImplementation of CMSDVDAdm                             */
/* Author: Fang Wang                                                     */
/*************************************************************************/
#include "stdafx.h"
#include "MSWebDVD.h"
#include "MSDVDAdm.h"
#include "iso3166.h"
#include <stdio.h>
#include <errors.h>
#include <wincrypt.h>

const TCHAR g_szRegistryKey[] = TEXT("Software\\Microsoft\\Multimedia\\DVD");
const TCHAR g_szPassword[] = TEXT("DVDAdmin.password");
const TCHAR g_szSalt[] = TEXT("DVDAdmin.ps"); // password salt
const TCHAR g_szUserSalt[] = TEXT("DVDAdmin.us"); // username salt
const TCHAR g_szUsername[] = TEXT("DVDAdmin.username");
const TCHAR g_szPlayerLevel[] = TEXT("DVDAdmin.playerLevel");
const TCHAR g_szPlayerCountry[] = TEXT("DVDAdmin.playerCountry");
const TCHAR g_szDisableScrnSvr[] = TEXT("DVDAdmin.disableScreenSaver");
const TCHAR g_szBookmarkOnClose[] = TEXT("DVDAdmin.bookmarkOnClose");
const TCHAR g_szBookmarkOnStop[] = TEXT("DVDAdmin.bookmarkOnStop");
const TCHAR g_szDefaultAudio[] = TEXT("DVDAdmin.defaultAudioLCID");
const TCHAR g_szDefaultSP[] = TEXT("DVDAdmin.defaultSPLCID");
const TCHAR g_szDefaultMenu[] = TEXT("DVDAdmin.defaultMenuLCID");

/*************************************************************/
/* Helper functions                                          */
/*************************************************************/

/*************************************************************/
/* Function: LoadStringFromRes                               */
/* Description: load a string from resource                  */
/*************************************************************/
LPTSTR LoadStringFromRes(DWORD redId){

    TCHAR *string = new TCHAR[MAX_PATH];

    if(NULL == string){

       return(NULL);
    }   

    ::ZeroMemory(string, sizeof(TCHAR) * MAX_PATH);
    ::LoadString(_Module.GetModuleInstance(), redId, string, MAX_PATH);
    return string;
}/* end of if statement */

/*************************************************************/
/* Function: lstrlenWInternal                                */
/*************************************************************/
int WINAPI lstrlenWInternal(LPCWSTR lpString){

    int length = 0;
    while (*lpString++ != L'\0')
        length++;
    return length;
}/* end of function lstrlenWInternal */

/*************************************************************/
/* Name: GetRegistryDword
/* Description: 
/*************************************************************/
BOOL GetRegistryDword(const TCHAR *pKey, DWORD* dwRet, DWORD dwDefault)
{
    HKEY hKey;
    LONG lRet;
    *dwRet = dwDefault;

    lRet = RegOpenKeyEx(HKEY_LOCAL_MACHINE, g_szRegistryKey, 0, KEY_QUERY_VALUE, &hKey);
    if (lRet == ERROR_SUCCESS) {

        DWORD   dwType, dwLen;
        dwLen = sizeof(DWORD);

        if (ERROR_SUCCESS != RegQueryValueEx(hKey, pKey, NULL, &dwType, (LPBYTE)dwRet, &dwLen)){ 
            *dwRet = dwDefault;
            RegCloseKey(hKey);
            return FALSE;
        }
        RegCloseKey(hKey);
    }
    return (lRet == ERROR_SUCCESS);
}

/*************************************************************/
/* Name: SetRegistryDword
/* Description: 
/*************************************************************/
BOOL SetRegistryDword(const TCHAR *pKey, DWORD dwRet)
{
    HKEY hKey;
    LONG lRet;

    lRet = RegCreateKey(HKEY_LOCAL_MACHINE, g_szRegistryKey, &hKey);
    if (lRet == ERROR_SUCCESS) {

        lRet = RegSetValueEx(hKey, pKey, NULL, REG_DWORD, (LPBYTE)&dwRet, sizeof(dwRet));
        RegCloseKey(hKey);
    }
    return (lRet == ERROR_SUCCESS);
}

/*************************************************************/
/* Name: GetRegistryString
/* Description: 
/*************************************************************/
BOOL GetRegistryString(const TCHAR *pKey, TCHAR* szRet, DWORD* dwLen, TCHAR* szDefault)
{
    HKEY hKey;
    LONG lRet;
    DWORD dwTempLen = 0;
    lstrcpyn(szRet, szDefault, *dwLen);

    lRet = RegOpenKeyEx(HKEY_LOCAL_MACHINE, g_szRegistryKey, 0, KEY_QUERY_VALUE, &hKey);
    if (lRet == ERROR_SUCCESS) {

        DWORD dwType;
        dwTempLen = (*dwLen) * sizeof(TCHAR);
        if (ERROR_SUCCESS != RegQueryValueEx(hKey, pKey, NULL, &dwType, (LPBYTE)szRet, &dwTempLen)) {
            lstrcpyn(szRet, szDefault, *dwLen);
            *dwLen = 0;
        }
        *dwLen = dwTempLen/sizeof(TCHAR);
        RegCloseKey(hKey);
    }
    return (lRet == ERROR_SUCCESS);
}

/*************************************************************/
/* Name: SetRegistryString
/* Description: 
/*************************************************************/
BOOL SetRegistryString(const TCHAR *pKey, TCHAR *szString, DWORD dwLen)
{
    HKEY hKey;
    LONG lRet;

    lRet = RegCreateKey(HKEY_LOCAL_MACHINE, g_szRegistryKey, &hKey);
    if (lRet == ERROR_SUCCESS) {

        lRet = RegSetValueEx(hKey, pKey, NULL, REG_SZ, (LPBYTE)szString, dwLen*sizeof(TCHAR));
        RegCloseKey(hKey);
    }
    return (lRet == ERROR_SUCCESS);
}

/*************************************************************/
/* Name: GetRegistryByte
/* Description: 
/*************************************************************/
BOOL GetRegistryBytes(const TCHAR *pKey, BYTE* szRet, DWORD* dwLen)
{
    HKEY hKey;
    LONG lRet;

    lRet = RegOpenKeyEx(HKEY_LOCAL_MACHINE, g_szRegistryKey, 0, KEY_QUERY_VALUE, &hKey);
    if (lRet == ERROR_SUCCESS) {

        DWORD dwType;
        if (ERROR_SUCCESS != RegQueryValueEx(hKey, pKey, NULL, &dwType, (LPBYTE)szRet, dwLen)) {
            *dwLen = 0;
        }
        RegCloseKey(hKey);
    }
    return (lRet == ERROR_SUCCESS);
}

/*************************************************************/
/* Name: SetRegistryBytes
/* Description: 
/*************************************************************/
BOOL SetRegistryBytes(const TCHAR *pKey, BYTE *szString, DWORD dwLen)
{
    HKEY hKey;
    LONG lRet;

    lRet = RegCreateKey(HKEY_LOCAL_MACHINE, g_szRegistryKey, &hKey);

    BOOL bRet = TRUE;
    if (lRet == ERROR_SUCCESS) {

        if (szString == NULL) {
            lRet = RegDeleteValue(hKey, pKey);
            bRet = (lRet == ERROR_SUCCESS) || (lRet == ERROR_FILE_NOT_FOUND);
        }
        else  {
            lRet = RegSetValueEx(hKey, pKey, NULL, REG_BINARY, (LPBYTE)szString, dwLen);
            bRet = (lRet == ERROR_SUCCESS);
        }

        RegCloseKey(hKey);
    }
    return (bRet);
}

// Start not so lame functions

/*************************************************************/
/* Name: GetRegistryDwordCU
/* Description: 
/*************************************************************/
BOOL GetRegistryDwordCU(const TCHAR *pKey, DWORD* dwRet, DWORD dwDefault)
{
    HKEY hKey;
    LONG lRet;
    *dwRet = dwDefault;

    lRet = RegOpenKeyEx(HKEY_CURRENT_USER, g_szRegistryKey, 0, KEY_QUERY_VALUE, &hKey);
    if (lRet == ERROR_SUCCESS) {

        DWORD   dwType, dwLen;
        dwLen = sizeof(DWORD);

        if (ERROR_SUCCESS != RegQueryValueEx(hKey, pKey, NULL, &dwType, (LPBYTE)dwRet, &dwLen)){ 
            *dwRet = dwDefault;
            RegCloseKey(hKey);
            return FALSE;
        }

        RegCloseKey(hKey);
    }
    return (lRet == ERROR_SUCCESS);
}

/*************************************************************/
/* Name: SetRegistryDwordCU
/* Description: 
/*************************************************************/
BOOL SetRegistryDwordCU(const TCHAR *pKey, DWORD dwRet)
{
    HKEY hKey;
    LONG lRet;

    lRet = RegCreateKey(HKEY_CURRENT_USER, g_szRegistryKey, &hKey);
    if (lRet == ERROR_SUCCESS) {

        lRet = RegSetValueEx(hKey, pKey, NULL, REG_DWORD, (LPBYTE)&dwRet, sizeof(dwRet));
        RegCloseKey(hKey);
    }
    return (lRet == ERROR_SUCCESS);
}

/*************************************************************/
/* Name: GetRegistryStringCU
/* Description: 
/*************************************************************/
BOOL GetRegistryStringCU(const TCHAR *pKey, TCHAR* szRet, DWORD* dwLen, TCHAR* szDefault)
{
    HKEY hKey;
    LONG lRet;
    DWORD dwTempLen = 0;
    lstrcpyn(szRet, szDefault, *dwLen);

    lRet = RegOpenKeyEx(HKEY_CURRENT_USER, g_szRegistryKey, 0, KEY_QUERY_VALUE, &hKey);
    if (lRet == ERROR_SUCCESS) {

        DWORD dwType;
        dwTempLen = (*dwLen) * sizeof(TCHAR);
        if (ERROR_SUCCESS != RegQueryValueEx(hKey, pKey, NULL, &dwType, (LPBYTE)szRet, &dwTempLen)) {
            lstrcpyn(szRet, szDefault, sizeof(szRet) / sizeof(szRet[0]));
            *dwLen = 0;
        }
        *dwLen = dwTempLen/sizeof(TCHAR);
        RegCloseKey(hKey);
    }
    return (lRet == ERROR_SUCCESS);
}

/*************************************************************/
/* Name: SetRegistryStringCU
/* Description: 
/*************************************************************/
BOOL SetRegistryStringCU(const TCHAR *pKey, TCHAR *szString, DWORD dwLen)
{
    HKEY hKey;
    LONG lRet;

    lRet = RegCreateKey(HKEY_CURRENT_USER, g_szRegistryKey, &hKey);
    if (lRet == ERROR_SUCCESS) {

        lRet = RegSetValueEx(hKey, pKey, NULL, REG_SZ, (LPBYTE)szString, dwLen*sizeof(TCHAR));
        RegCloseKey(hKey);
    }
    return (lRet == ERROR_SUCCESS);
}

/*************************************************************/
/* Name: GetRegistryByteCU
/* Description: 
/*************************************************************/
BOOL GetRegistryBytesCU(const TCHAR *pKey, BYTE* szRet, DWORD* dwLen)
{
    HKEY hKey;
    LONG lRet;

    lRet = RegOpenKeyEx(HKEY_CURRENT_USER, g_szRegistryKey, 0, KEY_QUERY_VALUE, &hKey);
    if (lRet == ERROR_SUCCESS) {

        DWORD dwType;
        if (ERROR_SUCCESS != RegQueryValueEx(hKey, pKey, NULL, &dwType, (LPBYTE)szRet, dwLen)) {
            *dwLen = 0;
        }
        RegCloseKey(hKey);
    }
    return (lRet == ERROR_SUCCESS);
}

/*************************************************************/
/* Name: SetRegistryBytesCU
/* Description: 
/*************************************************************/
BOOL SetRegistryBytesCU(const TCHAR *pKey, BYTE *szString, DWORD dwLen)
{
    HKEY hKey;
    LONG lRet;

    lRet = RegCreateKey(HKEY_CURRENT_USER, g_szRegistryKey, &hKey);

    BOOL bRet = TRUE;
    if (lRet == ERROR_SUCCESS) {

        if (szString == NULL) {
            lRet = RegDeleteValue(hKey, pKey);
            bRet = (lRet == ERROR_SUCCESS) || (lRet == ERROR_FILE_NOT_FOUND);
        }
        else  {
            lRet = RegSetValueEx(hKey, pKey, NULL, REG_BINARY, (LPBYTE)szString, dwLen);
            bRet = (lRet == ERROR_SUCCESS);
        }

        RegCloseKey(hKey);
    }
    return (bRet);
}

// end not so lame functions
/*************************************************************/
/* Function: CMSDVDAdm                                       */
/*************************************************************/
CMSDVDAdm::CMSDVDAdm(){

    DWORD temp;
    GetRegistryDword(g_szPlayerLevel, &temp, (DWORD)LEVEL_ADULT);		
    m_lParentctrlLevel = temp;

    GetRegistryDword(g_szPlayerCountry, &temp, (DWORD)0);		
    m_lParentctrlCountry = temp;

    GetRegistryDword(g_szDisableScrnSvr, &temp, (DWORD)VARIANT_TRUE);		
    m_fDisableScreenSaver = (VARIANT_BOOL)temp;
    SaveScreenSaver();
    if (m_fDisableScreenSaver != VARIANT_FALSE)
        DisableScreenSaver();

    GetRegistryDword(g_szBookmarkOnStop, &temp, (DWORD)VARIANT_FALSE);		
    m_fBookmarkOnStop = (VARIANT_BOOL)temp;
    GetRegistryDword(g_szBookmarkOnClose, &temp, (DWORD)VARIANT_TRUE);		
    m_fBookmarkOnClose = (VARIANT_BOOL)temp;
}/* end of function CMSDVDAdm */

/*************************************************************/
/* Function: ~CMSDVDAdm                                      */
/*************************************************************/
CMSDVDAdm::~CMSDVDAdm(){
    
    RestoreScreenSaver();
}/* end of function ~CMSDVDAdm */
    

/*************************************************************/
/* Name: EncryptPassword                                     */
/* Description: Hash the password                            */
/* Params:                                                   */
/*  lpPassword: password to hash                             */
/*  lpAssaultedHash: hashed password,                        */
/*      allocated by this fucntion, released by caller       */
/*  p_dwAssault: salt, save with hash; or salt passed in     */
/*  genAssault: TRUE = generate salt; FALSE = salt passed in */
/*************************************************************/
HRESULT CMSDVDAdm::EncryptPassword(LPTSTR lpPassword, BYTE **lpAssaultedHash, DWORD *p_dwCryptLen, DWORD *p_dwAssault, BOOL genAssault){
    if(!lpPassword || !lpAssaultedHash || !p_dwAssault || !p_dwCryptLen){
        return E_POINTER;
    }
    if( lstrlen(lpPassword) > MAX_PASSWD){
        return E_INVALIDARG;
    }
    
    HCRYPTPROV hProv = NULL;   // Handle to Crypto Context
    HCRYPTHASH hHash = NULL;   // Handle to Hash Function    
    DWORD dwAssault = 0;       // As(Sa)u(lt) for hash
    DWORD dwAssaultedHash = 0; // Length of Assaulted hash
    
    // Init Crypto Context
    if(!CryptAcquireContext(&hProv, 0, 0, PROV_RSA_FULL, CRYPT_VERIFYCONTEXT)){
        return E_UNEXPECTED;
    }
    
    // Store the Salt in dwAssault, either generate it or copy the user passed value
    if(genAssault){        
        if(!CryptGenRandom(hProv, sizeof(DWORD), reinterpret_cast<BYTE *>(&dwAssault))){
            if(hProv) CryptReleaseContext(hProv, 0);                                                                       
            return E_UNEXPECTED;   
        }
        *p_dwAssault = dwAssault;
    }
    else{
        dwAssault = *p_dwAssault;
    }
    
    // Create the handle to the Hash function
    if(!CryptCreateHash(hProv, CALG_SHA1, 0, 0, &hHash)){
        if(hProv) CryptReleaseContext(hProv, 0);                                  
        if(hHash) CryptDestroyHash(hHash);                                      
        return E_UNEXPECTED;
    }
    
    // Hash the password
    if(!CryptHashData(hHash, reinterpret_cast<BYTE *>(lpPassword), lstrlen(lpPassword)*sizeof(lpPassword[0]), 0)){
        if(hProv) CryptReleaseContext(hProv, 0);                                  
        if(hHash) CryptDestroyHash(hHash);                                      
        return E_UNEXPECTED;
    }
    
    // Add the salt
    if(!CryptHashData(hHash, reinterpret_cast<BYTE *>(&dwAssault), sizeof(DWORD), 0)){
        if(hProv) CryptReleaseContext(hProv, 0);                                  
        if(hHash) CryptDestroyHash(hHash);                                      
        return E_UNEXPECTED;
    }
    
    // Get the size of the hashed data
    if(!CryptGetHashParam(hHash, HP_HASHVAL, 0, &dwAssaultedHash, 0)){
        if(hProv) CryptReleaseContext(hProv, 0);                                  
        if(hHash) CryptDestroyHash(hHash);                                      
        return E_UNEXPECTED;
    }
    
    // Allocate a string large enough to hold the hash data and a null
    *lpAssaultedHash = new BYTE[dwAssaultedHash];
    if(!lpAssaultedHash){
        if(hProv) CryptReleaseContext(hProv, 0);                                  
        if(hHash) CryptDestroyHash(hHash);                                      
        return E_UNEXPECTED;
    }
    
    // Zero the string
    ZeroMemory(*lpAssaultedHash, dwAssaultedHash);
    
    // Copy length of Encrypted bytes to return value
    *p_dwCryptLen = dwAssaultedHash;
    
    // Get the hash data and store it in a string
    if(!CryptGetHashParam(hHash, HP_HASHVAL, *lpAssaultedHash, &dwAssaultedHash, 0)){
        if(hProv) CryptReleaseContext(hProv, 0);                                  
        if(hHash) CryptDestroyHash(hHash);                                      
        if(lpAssaultedHash){
            delete[] *lpAssaultedHash;
            *lpAssaultedHash = NULL;
        }
        return E_UNEXPECTED;
    }
    
    // Clean up
    if(hProv) CryptReleaseContext(hProv, 0);                                  
    if(hHash) CryptDestroyHash(hHash);                                      

    return S_OK;

}/* end of function EncryptPassword */

/*************************************************************/
/* Function: ConfirmPassword                                 */
/* Description:                                              */
/* There is no need for a user to confirm passwords unless   */
/* they are hacking the password.                            */ 
/* ConfirmPassword always fails (and waits five seconds)     */
/*************************************************************/
STDMETHODIMP CMSDVDAdm::ConfirmPassword(BSTR strUserName, BSTR strPassword, VARIANT_BOOL *pVal){
    Sleep(1000);
    return E_FAIL;
}
/*************************************************************/
/* Function: _ConfirmPassword                                */
/* Description: comfired a password with the one saved       */
/*************************************************************/
STDMETHODIMP CMSDVDAdm::_ConfirmPassword(BSTR /*strUserName*/,
                                        BSTR strPassword, VARIANT_BOOL *fRight){

    HRESULT hr = S_OK;

    try {

        USES_CONVERSION;

		if(!strPassword || !fRight){
			throw E_POINTER;
		}
        UINT bStrLen = lstrlen(strPassword);
        if(bStrLen >= MAX_PASSWD){
            throw E_INVALIDARG;
        }

        LPTSTR szPassword = OLE2T(strPassword);
	    BYTE szSavedPasswd[MAX_PASSWD];
        DWORD dwLen = MAX_PASSWD;
        BOOL bFound = GetRegistryBytes(g_szPassword, szSavedPasswd, &dwLen);

        // if no password has been set yet
        if (!bFound || dwLen == 0) {
            // so in this case accept only an empty string 
            if(lstrlen(szPassword) <= 0){
                *fRight = VARIANT_TRUE;
            }
            else {
                *fRight = VARIANT_FALSE;
            }
            throw (hr);
        }

        DWORD dwAssault = 0;
        bFound = GetRegistryDword(g_szSalt, &dwAssault, 0);
        if(!bFound ){
            // Old style password since there is no salt
            // ignore current password until it is reset
            *fRight = VARIANT_TRUE;
            throw(hr);
        }

        // if password is 0 len and password is set don't even try to encrypt just return false
        if(lstrlen(szPassword) <= 0){
            *fRight = VARIANT_FALSE;
            throw(hr);
        }

        // Encrypt the password with the salt from the registry
	    BYTE *pszEncrypted = NULL;
        DWORD dwCryptLen = 0;
        hr = EncryptPassword(szPassword, &pszEncrypted, &dwCryptLen, &dwAssault, FALSE);
        if(FAILED(hr)){
            throw (hr);
        }

        // Compare the Encrypted input password with the saved password
        if(memcmp(pszEncrypted, szSavedPasswd, (dwAssault <= dwLen?dwAssault:dwLen) ) == 0)
            *fRight = VARIANT_TRUE;
        else
            *fRight = VARIANT_FALSE;
        delete[] pszEncrypted;
    }
    catch(HRESULT hrTmp){

        hr = hrTmp;
    }
    catch(...){
        hr = E_UNEXPECTED;
    }

    if(FAILED(hr)){
        Sleep(1000);
    }

    return (HandleError(hr));        
}/* end of function ConfirmPassword */

/*************************************************************/
/* Function: ChangePassword                                  */
/* Description: password change requested                    */
/*************************************************************/
STDMETHODIMP CMSDVDAdm::ChangePassword(BSTR strUserName, 
                                       BSTR strOldPassword, BSTR strNewPassword){

    HRESULT hr = S_OK;

    try {

        USES_CONVERSION;
        if(!strUserName || !strOldPassword || !strNewPassword){
            return E_POINTER;
        }
        // check the size of the string so we do not overwrite 
        // or write a very big chunk into registry 
        if(lstrlen(strNewPassword) >= MAX_PASSWD){
            throw(E_FAIL);            
        }


        LPTSTR szNewPassword = OLE2T(strNewPassword);

        // Confirm old password first
        VARIANT_BOOL temp;
        _ConfirmPassword(strUserName, strOldPassword, &temp);
        if (temp == VARIANT_FALSE){
            throw E_ACCESSDENIED;
        }

        DWORD dwAssault = 0;
        DWORD dwCryptLen = 0;
        BYTE *pszEncrypted = NULL;
        
	    hr = EncryptPassword(szNewPassword, &pszEncrypted, &dwCryptLen, &dwAssault, TRUE);
        if(FAILED(hr)){
            throw E_FAIL;
        }

        BOOL bSuccess = SetRegistryBytes(g_szPassword, pszEncrypted, dwCryptLen);
        if (!bSuccess){
            hr = E_FAIL;
        }

        delete[] pszEncrypted;

        // If storing the password hash failed, don't store the salt
        if(SUCCEEDED(hr)){
            bSuccess = SetRegistryDword(g_szSalt, dwAssault);
            if (!bSuccess){
                hr = E_FAIL;
            }
        }
    }
    catch(HRESULT hrTmp){
        hr = hrTmp;
    }
    catch(...){
        hr = E_UNEXPECTED;
    }

    return HandleError(hr);        
}/* end of function ChangePassword */

/*************************************************************/
/* Function: SaveParentalLevel                               */
/*************************************************************/
STDMETHODIMP CMSDVDAdm::SaveParentalLevel(long lParentalLevel, 
                         BSTR strUserName, BSTR strPassword){
    HRESULT hr = S_OK;

    try {

        if (lParentalLevel != LEVEL_DISABLED && 
           (lParentalLevel < LEVEL_G || lParentalLevel > LEVEL_ADULT)) {

            throw (E_INVALIDARG);
        } /* end of if statement */

        if (m_lParentctrlLevel != lParentalLevel) {

            // Confirm password first
            VARIANT_BOOL temp;
            _ConfirmPassword(strUserName, strPassword, &temp);
            if (temp == VARIANT_FALSE)
                throw (E_ACCESSDENIED);

        }
        
        BOOL bSuccess = SetRegistryDword(g_szPlayerLevel, (DWORD) lParentalLevel);
        if (!bSuccess){
            throw E_FAIL;
        }

        m_lParentctrlLevel = lParentalLevel;

    }
    catch(HRESULT hrTmp){

        hr = hrTmp;
    }
    catch(...){
        hr = E_UNEXPECTED;
    }

    return HandleError(hr);
}/* end of function SaveParentalLevel */

/*************************************************************/
/* Name: SaveParentalCountry                                 */
/*************************************************************/
STDMETHODIMP CMSDVDAdm::SaveParentalCountry(long lCountry,                                               
                        BSTR strUserName,BSTR strPassword){

    HRESULT hr = S_OK;

    try {

        if(lCountry < 0 && lCountry > 0xffff){

            throw(E_INVALIDARG);
        }/* end of if statement */

        BYTE bCountryCode[2];

        bCountryCode[0] = BYTE(lCountry>>8);
        bCountryCode[1] = BYTE(lCountry);

        // convert the input country code to upper case by applying ToUpper to each letter
        WORD wCountry = ISO3166::PackCode( (char *)bCountryCode );
        BOOL bFound = FALSE;

        for( unsigned i=0; i<ISO3166::GetNumCountries(); i++ )
        {
            if( ISO3166::PackCode(ISO3166::GetCountry(i).Code) == wCountry )
            {
                bFound = TRUE;
            }
        }

        // Not a valid country code
        if (!bFound) {

            throw(E_INVALIDARG);
        }/* end of if statement */

        if (m_lParentctrlCountry != lCountry) {

            // Confirm password first
            VARIANT_BOOL temp;
            _ConfirmPassword(strUserName, strPassword, &temp);
            if (temp == VARIANT_FALSE)
                throw(E_ACCESSDENIED);
        
        }
        BOOL bSuccess = SetRegistryDword(g_szPlayerCountry, (DWORD) lCountry);
        if (!bSuccess){
            throw E_FAIL;
        }    
        m_lParentctrlCountry = lCountry;
    }
    catch(HRESULT hrTmp){

        hr = hrTmp;
    }
    catch(...){
        hr = E_UNEXPECTED;
    }

    return (HandleError(hr));        
}/* end of function SaveParentalCountry */

/*************************************************************/
/* Function: put_DisableScreenSaver                          */
/*************************************************************/
STDMETHODIMP CMSDVDAdm::put_DisableScreenSaver(VARIANT_BOOL fDisable){

    HRESULT hr = S_OK;

    try {

        if (fDisable == VARIANT_FALSE)
            RestoreScreenSaver();
        else 
            DisableScreenSaver();

        SetRegistryDword(g_szDisableScrnSvr, (DWORD) fDisable);
        m_fDisableScreenSaver = fDisable;
    }
    catch(HRESULT hrTmp){

        hr = hrTmp;
    }
    catch(...){
        hr = E_UNEXPECTED;
    }

    return HandleError(hr);        
}/* end of function put_DisableScreenSaver */

/*************************************************************/
/* Function: get_DisableScreenSaver                          */
/*************************************************************/
STDMETHODIMP CMSDVDAdm::get_DisableScreenSaver(VARIANT_BOOL *fDisable){

    HRESULT hr = S_OK;

    try {
        if(NULL == fDisable){

            hr = E_POINTER;
            throw(hr);
        }/* end of if statement */
   
        *fDisable = m_fDisableScreenSaver;
    }
    catch(HRESULT hrTmp){

        hr = hrTmp;
    }
    catch(...){
        hr = E_UNEXPECTED;
    }

    return HandleError(hr);
}/* end of function get_DisableScreenSaver */

/*************************************************************/
/* Function: SaveScreenSaver                                 */
/*************************************************************/
HRESULT CMSDVDAdm::SaveScreenSaver(){

    SystemParametersInfo(SPI_GETSCREENSAVEACTIVE, 0, &m_bScrnSvrOld, 0);
    SystemParametersInfo(SPI_GETLOWPOWERACTIVE, 0, &m_bPowerlowOld, 0);
    SystemParametersInfo(SPI_GETPOWEROFFACTIVE, 0, &m_bPowerOffOld, 0);

    return S_OK;
}
/*************************************************************/
/* Function: DisableScreenSaver                              */
/*************************************************************/
HRESULT CMSDVDAdm::DisableScreenSaver(){

    SystemParametersInfo(SPI_SETSCREENSAVEACTIVE, FALSE, NULL, 0);
    SystemParametersInfo(SPI_SETLOWPOWERACTIVE, FALSE, NULL, 0);
    SystemParametersInfo(SPI_SETPOWEROFFACTIVE, FALSE, NULL, 0);

    return S_OK;
}/* end of function DisableScreenSaver */

/*************************************************************/
/* Function: RestoreScreenSaver                              */
/*************************************************************/
STDMETHODIMP CMSDVDAdm::RestoreScreenSaver(){

    HRESULT hr = S_OK;

    try {

        SystemParametersInfo(SPI_SETSCREENSAVEACTIVE, m_bScrnSvrOld, NULL, 0);
        SystemParametersInfo(SPI_SETLOWPOWERACTIVE, m_bPowerlowOld, NULL, 0);
        SystemParametersInfo(SPI_SETPOWEROFFACTIVE, m_bPowerOffOld, NULL, 0);

    }
    catch(HRESULT hrTmp){

        hr = hrTmp;
    }
    catch(...){
        hr = E_UNEXPECTED;
    }

    return HandleError(hr);
}/* end of function RestoreScreenSaver */

/*************************************************************/
/* Function: GetParentalLevel                                */
/*************************************************************/
STDMETHODIMP CMSDVDAdm::GetParentalLevel(long *lLevel){

    HRESULT hr = S_OK;

    try {
        if(NULL == lLevel){

            hr = E_POINTER;
            throw(hr);
        }/* end of if statement */

        *lLevel = m_lParentctrlLevel;

    }
    catch(HRESULT hrTmp){

        hr = hrTmp;
    }
    catch(...){
        hr = E_UNEXPECTED;
    }

    return HandleError(hr);        
}/* end of function GetParentalLevel */

/*************************************************************/
/* Function: GetParentalCountry                              */
/*************************************************************/
STDMETHODIMP CMSDVDAdm::GetParentalCountry(long *lCountry){

    HRESULT hr = S_OK;

    try {
        if(NULL == lCountry){

            hr = E_POINTER;
            throw(hr);
        }/* end of if statement */

        *lCountry = m_lParentctrlCountry;
    }
    catch(HRESULT hrTmp){

        hr = hrTmp;
    }
    catch(...){
        hr = E_UNEXPECTED;
    }

    return HandleError(hr);        
}/* end of function GetParentalCountry */

/*************************************************************/
/* Name: get_DefaultAudioLCID
/* Description: -1 means title default
/*************************************************************/
STDMETHODIMP CMSDVDAdm::get_DefaultAudioLCID(long *pVal){

    HRESULT hr = S_OK;

    try {

        if(NULL == pVal){

            hr = E_POINTER;
            throw(hr);
        }/* end of if statement */
    
        BOOL bSuccess = GetRegistryDwordCU(g_szDefaultAudio, (DWORD*) pVal, (DWORD)-1);
    }    
    catch(HRESULT hrTmp){

        hr = hrTmp;
    }
    catch(...){
        hr = E_UNEXPECTED;
    }

    return HandleError(hr);        
} /* end of function get_DefaultAudioLCID */

/*************************************************************/
/* Name: put_DefaultAudioLCID
/* Description: -1 means title default
/*************************************************************/
STDMETHODIMP CMSDVDAdm::put_DefaultAudioLCID(long newVal)
{
    HRESULT hr = S_OK;

    try {

        if (!::IsValidLocale(newVal, LCID_SUPPORTED) && newVal != -1) {

            throw (E_INVALIDARG);
        } /* end of if statement */
    
        SetRegistryDwordCU(g_szDefaultAudio, (DWORD) newVal);
    }    
    catch(HRESULT hrTmp){

        hr = hrTmp;
    }
    catch(...){
        hr = E_UNEXPECTED;
    }

    return HandleError(hr);
} /* end of put_DefaultAudioLCID */

/*************************************************************/
/* Name: get_DefaultSubpictureLCID
/* Description: -1 means title default
/*************************************************************/
STDMETHODIMP CMSDVDAdm::get_DefaultSubpictureLCID(long *pVal)
{
    HRESULT hr = S_OK;

    try {
        if(NULL == pVal){

            hr = E_POINTER;
            throw(hr);
        }/* end of if statement */

        GetRegistryDwordCU(g_szDefaultSP, (DWORD*) pVal, (DWORD)-1);

    }    
    catch(HRESULT hrTmp){

        hr = hrTmp;
    }
    catch(...){
        hr = E_UNEXPECTED;
    }

    return HandleError(hr);	
} /* end of get_DefaultSubpictureLCID */

/*************************************************************/
/* Name: put_DefaultSubpictureLCID
/* Description: -1 means title default
/*************************************************************/
STDMETHODIMP CMSDVDAdm::put_DefaultSubpictureLCID(long newVal)
{
    HRESULT hr = S_OK;

    try {

        if (!::IsValidLocale(newVal, LCID_SUPPORTED) && newVal != -1) {

            throw (E_INVALIDARG);
        } /* end of if statement */
    
        SetRegistryDwordCU(g_szDefaultSP, (DWORD) newVal);
    }    
    catch(HRESULT hrTmp){

        hr = hrTmp;
    }
    catch(...){
        hr = E_UNEXPECTED;
    }

	return HandleError(hr);
} /* end of put_DefaultSubpictureLCID */

/*************************************************************/
/* Name: get_DefaultMenuLCID
/* Description: -1 means title default
/*************************************************************/
STDMETHODIMP CMSDVDAdm::get_DefaultMenuLCID(long *pVal)
{
    HRESULT hr = S_OK;

    try {

       if(NULL == pVal){

            hr = E_POINTER;
            throw(hr);
        }/* end of if statement */

        GetRegistryDwordCU(g_szDefaultMenu, (DWORD*) pVal, (DWORD)-1);
    }    
    catch(HRESULT hrTmp){

        hr = hrTmp;
    }
    catch(...){
        hr = E_UNEXPECTED;
    }

	return HandleError(hr);
} /* end of get_DefaultMenuLCID */

/*************************************************************/
/* Name: put_DefaultMenuLCID
/* Description: -1 means title default
/*************************************************************/
STDMETHODIMP CMSDVDAdm::put_DefaultMenuLCID(long newVal)
{
    HRESULT hr = S_OK;

    try {

        if (!::IsValidLocale(newVal, LCID_SUPPORTED) && newVal != -1) {

            throw (E_INVALIDARG);
        } /* end of if statement */
    
        SetRegistryDwordCU(g_szDefaultMenu, (DWORD) newVal);
    }    
    catch(HRESULT hrTmp){

        hr = hrTmp;
    }
    catch(...){
        hr = E_UNEXPECTED;
    }

	return HandleError(hr); 
} /* end of put_DefaultMenuLCID */

/*************************************************************/
/* Name: put_BookmarkOnStop
/* Description: 
/*************************************************************/
STDMETHODIMP CMSDVDAdm::put_BookmarkOnStop(VARIANT_BOOL fEnable){

    HRESULT hr = S_OK;

    try {
        m_fBookmarkOnStop = fEnable;
        SetRegistryDword(g_szBookmarkOnStop, (DWORD) fEnable);
    }    
    catch(HRESULT hrTmp){

        hr = hrTmp;
    }
    catch(...){
        hr = E_UNEXPECTED;
    }

	return HandleError(hr);
}

/*************************************************************/
/* Name: get_BookmarkOnStop
/* Description: 
/*************************************************************/
STDMETHODIMP CMSDVDAdm::get_BookmarkOnStop(VARIANT_BOOL *fEnable){
    
    HRESULT hr = S_OK;

    try {

       if(NULL == fEnable){

           hr = E_POINTER;
           throw(hr);
       }/* end of if statement */

       *fEnable = m_fBookmarkOnStop;
    }
    catch(HRESULT hrTmp){

        hr = hrTmp;
    }
    catch(...){
        hr = E_UNEXPECTED;
    }

	return HandleError(hr);
}

/*************************************************************/
/* Name: put_BookmarkOnClose
/* Description: 
/*************************************************************/
STDMETHODIMP CMSDVDAdm::put_BookmarkOnClose(VARIANT_BOOL fEnable){

    HRESULT hr = S_OK;
    try {

        m_fBookmarkOnClose = fEnable;
        SetRegistryDword(g_szBookmarkOnClose, (DWORD) fEnable);
    }
    catch(HRESULT hrTmp){

        hr = hrTmp;
    }
    catch(...){
        hr = E_UNEXPECTED;
    }

	return HandleError(hr);        
}

/*************************************************************/
/* Name: get_BookmarkOnClose
/* Description: 
/*************************************************************/
STDMETHODIMP CMSDVDAdm::get_BookmarkOnClose(VARIANT_BOOL *fEnable){

    HRESULT hr = S_OK;

    try {
        if(NULL == fEnable){

           hr = E_POINTER;
           throw(hr);
       }/* end of if statement */

        *fEnable = m_fBookmarkOnClose;
    }
    catch(HRESULT hrTmp){

        hr = hrTmp;
    }
    catch(...){
        hr = E_UNEXPECTED;
    }

	return HandleError(hr);        
}

/*************************************************************************/
/* Function: InterfaceSupportsErrorInfo                                  */
/*************************************************************************/
STDMETHODIMP CMSDVDAdm::InterfaceSupportsErrorInfo(REFIID riid){	
	static const IID* arr[] = {
        &IID_IMSDVDAdm,		
	};

	for (int i=0; i<sizeof(arr)/sizeof(arr[0]); i++){
		if (InlineIsEqualGUID(*arr[i], riid))
			return S_OK;
	}/* end of for loop */

	return S_FALSE;
}/* end of function InterfaceSupportsErrorInfo */

/*************************************************************************/
/* Function: HandleError                                                 */
/* Description: Gets Error Descriptio, so we can suppor IError Info.     */
/*************************************************************************/
HRESULT CMSDVDAdm::HandleError(HRESULT hr){

    try {

        if(FAILED(hr)){
        
            // Ensure that the string is Null Terminated
            TCHAR strError[MAX_ERROR_TEXT_LEN+1];
            ZeroMemory(strError, MAX_ERROR_TEXT_LEN+1);

            if(AMGetErrorText(hr , strError , MAX_ERROR_TEXT_LEN)){
                USES_CONVERSION;
                Error(T2W(strError));
            } 
            else {
                    ATLTRACE(TEXT("Unhandled Error Code \n")); // please add it
                    ATLASSERT(FALSE);
            }/* end of if statement */
        }/* end of if statement */
    }/* end of try statement */
    catch(HRESULT hrTmp){

        hr = hrTmp;
    }/* end of catch statement */
    catch(...){
        // keep the hr same    
    }/* end of catch statement */
    
	return (hr);
}/* end of function HandleError */

/*************************************************************************/
/* End of file: MSDVDAdm.cpp                                             */
/*************************************************************************/
=== C:/Users/treeman/Desktop/windows nt source code\Source\Win2K3\NT\multimedia\dshow\mfvideo\mswebdvd\msdvd.h ===
/*************************************************************************/
/* Copyright (C) 1999 Microsoft Corporation                              */
/* File: msdvd.h                                                         */
/* Description: Declaration of CMSWebDVD                                 */
/* Author: David Janecek                                                 */
/*************************************************************************/
#ifndef __MSWEBDVD_H_
#define __MSWEBDVD_H_

#include "resource.h"       // main symbols
#include <atlctl.h>
#include <streams.h>
#include <dvdevcod.h>
#include "MSWebDVD.h"
#include "MSWebDVDCP.h"
#include "MSDVDAdm.h"
#include "ThunkProc.h" // for template for MSDVD timer
#include "MSLCID.h"
#include "mediahndlr.h"

//
// Special user message used by the app for event notification
//
#define WM_DVDPLAY_EVENT    (WM_USER+101)
#define NO_STOP             (-1)
#define RECTWIDTH(lpRect)     ((lpRect)->right - (lpRect)->left)
#define RECTHEIGHT(lpRect)    ((lpRect)->bottom - (lpRect)->top)

#define UNDEFINED_COLORKEY_COLOR 0xff000000
#define MAGENTA_COLOR_KEY 0x00ff00ff
#define DEFAULT_COLOR_KEY 0x00100010
#define DEFAULT_BACK_COLOR 0x00100010
#define OCR_ARROW_DEFAULT 100

/////////////////////////////////////////////////////////////////////////////////
// copied from vpinfo.h which is a private header

#if defined(CCHDEVICENAME)
#define AMCCHDEVICENAME CCHDEVICENAME
#else
#define AMCCHDEVICENAME 32
#endif
#define AMCCHDEVICEDESCRIPTION  256

#define AMDDRAWMONITORINFO_PRIMARY_MONITOR          0x0001
typedef struct {
    GUID*       lpGUID; // is NULL if the default DDraw device
    GUID        GUID;   // otherwise points to this GUID
} AMDDRAWGUID;


typedef struct {
    AMDDRAWGUID guid;
    RECT        rcMonitor;
    HMONITOR    hMon;
    DWORD       dwFlags;
    char        szDevice[AMCCHDEVICENAME];
    char        szDescription[AMCCHDEVICEDESCRIPTION];
    DDCAPS_DX3  ddHWCaps;
} AMDDRAWMONITORINFO;


DECLARE_INTERFACE_(IAMSpecifyDDrawConnectionDevice, IUnknown)
{
    // Use this method on a Multi-Monitor system to specify to the overlay
    // mixer filter which Direct Draw driver should be used when connecting
    // to an upstream decoder filter.
    //
    STDMETHOD (SetDDrawGUID)(THIS_
        /* [in] */ const AMDDRAWGUID *lpGUID
        ) PURE;

    // Use this method to determine the direct draw object that will be used when
    // connecting the overlay mixer filter to an upstream decoder filter.
    //
    STDMETHOD (GetDDrawGUID)(THIS_
        /* [out] */ AMDDRAWGUID *lpGUID
        ) PURE;

    // Use this method on a multi-monitor system to specify to the
    // overlay mixer filter the default Direct Draw device to use when
    // connecting to an upstream filter.  The default direct draw device
    // can be overriden for a particular connection by SetDDrawGUID method
    // described above.
    //
    STDMETHOD (SetDefaultDDrawGUID)(THIS_
        /* [in] */ const AMDDRAWGUID *lpGUID
        ) PURE;

    // Use this method on a multi-monitor system to determine which
    // is the default direct draw device the overlay mixer filter
    // will  use when connecting to an upstream filter.
    //
    STDMETHOD (GetDefaultDDrawGUID)(THIS_
        /* [out] */ AMDDRAWGUID *lpGUID
        ) PURE;


    // Use this method to get a list of Direct Draw device GUIDs and thier
    // associated monitor information that the overlay mixer can use when
    // connecting to an upstream decoder filter.
    //
    // The method allocates and returns an array of AMDDRAWMONITORINFO
    // structures, the caller of function is responsible for freeing this
    // memory when it is no longer needed via CoTaskMemFree.
    //
    STDMETHOD (GetDDrawGUIDs)(THIS_
        /* [out] */ LPDWORD lpdwNumDevices,
        /* [out] */ AMDDRAWMONITORINFO** lplpInfo
        ) PURE;
};


typedef struct {
    long    lHeight;       // in pels
    long    lWidth;        // in pels
    long    lBitsPerPel;   // Usually 16 but could be 12 for the YV12 format
    long    lAspectX;      // X aspect ratio
    long    lAspectY;      // Y aspect ratio
    long    lStride;       // stride in bytes
    DWORD   dwFourCC;      // YUV type code ie. 'YUY2', 'YV12' etc
    DWORD   dwFlags;       // Flag used to further describe the image
    DWORD   dwImageSize;   // Size of the bImage array in bytes, which follows this
                           // data structure

//  BYTE    bImage[dwImageSize];

} YUV_IMAGE;

#define DM_BOTTOMUP_IMAGE   0x00001
#define DM_TOPDOWN_IMAGE    0x00002
#define DM_FIELD_IMAGE      0x00004
#define DM_FRAME_IMAGE      0x00008


DECLARE_INTERFACE_(IDDrawNonExclModeVideo , IDDrawExclModeVideo )
{
    //
    // Call this function to capture the current image being displayed
    // by the overlay mixer.  It is not always possible to capture the
    // current frame, for example MoComp may be in use.  Applications
    // should always call IsImageCaptureSupported (see below) before
    // calling this function.
    //
    STDMETHOD (GetCurrentImage)(THIS_
        /* [out] */ YUV_IMAGE** lplpImage
        ) PURE;

    STDMETHOD (IsImageCaptureSupported)(THIS_
        ) PURE;

    //
    // On a multi-monitor system, applications call this function when they
    // detect that the playback rectangle has moved to a different monitor.
    // This call has no effect on a single monitor system.
    //
    STDMETHOD (ChangeMonitor)(THIS_
        /* [in]  */ HMONITOR hMonitor,
        /* [in]  */ LPDIRECTDRAW pDDrawObject,
        /* [in]  */ LPDIRECTDRAWSURFACE pDDrawSurface
        ) PURE;

    //
    // When an application receives a WM_DISPLAYCHANGE message it should
    // call this function to allow the OVMixer to recreate DDraw surfaces
    // suitable for the new display mode.  The application itself must re-create
    // the new DDraw object and primary surface passed in the call.
    //
    STDMETHOD (DisplayModeChanged)(THIS_
        /* [in]  */ HMONITOR hMonitor,
        /* [in]  */ LPDIRECTDRAW pDDrawObject,
        /* [in]  */ LPDIRECTDRAWSURFACE pDDrawSurface
        ) PURE;

    //
    // Applications should continually check that the primary surface passed
    // to the OVMixer does not become "lost", ie. the user entered a Dos box or
    // pressed Alt-Ctrl-Del.  When "surface loss" is detected the application should
    // call this function so that the OVMixer can restore the surfaces used for
    // video playback.
    //
    STDMETHOD (RestoreSurfaces)(THIS_
        ) PURE;
};

////////////////////////////////////////////////////////////////////////////////////
/*************************************************************************/
/* Local Defines to sort of abstract the implementation and make the     */
/* changes bit more convinient.                                          */
/*************************************************************************/
#define INITIALIZE_GRAPH_IF_NEEDS_TO_BE   \
        {                                 \
            hr = RenderGraphIfNeeded();   \
            if(FAILED(hr)){               \
                                          \
                throw(hr);                \
            }/* end of if statement */    \
        }

#define RETRY_IF_IN_FPDOM(func)              \
        {                                    \
            hr = (func);                     \
            if((VFW_E_DVD_INVALIDDOMAIN == hr || \
                VFW_E_DVD_OPERATION_INHIBITED == hr)){  \
                if(SUCCEEDED(PassFP_DOM())){ \
                                             \
                    hr = (func);             \
                }/* end of if statement */   \
            }/* end of if statement */       \
            if(FAILED(hr)){                  \
                RestoreGraphState();         \
            }/* end of if statement */       \
        }


#define INITIALIZE_GRAPH_IF_NEEDS_TO_BE_AND_PLAY   \
        {                                          \
            hr = Play(); /* put in the play mode*/  \
                                                   \
            if(FAILED(hr)){                        \
                                                   \
                throw(hr);                         \
            }/* end of if statement */             \
        }

class CDDrawDVD;
class COverlayCallback;

/////////////////////////////////////////////////////////////////////////////
// CMSWebDVD
class ATL_NO_VTABLE CMSWebDVD :
	public CComObjectRootEx<CComSingleThreadModel>,
    public CStockPropImpl<CMSWebDVD, IMSWebDVD, &IID_IMSWebDVD, &LIBID_MSWEBDVDLib>,    
    public IPropertyNotifySinkCP<CMSWebDVD>,
	public CComControl<CMSWebDVD>,
	public IPersistStreamInitImpl<CMSWebDVD>,
	public IOleControlImpl<CMSWebDVD>,
	public IOleObjectImpl<CMSWebDVD>,
	public IOleInPlaceActiveObjectImpl<CMSWebDVD>,
	public IViewObjectExImpl<CMSWebDVD>,
	public IOleInPlaceObjectWindowlessImpl<CMSWebDVD>,
	public IPersistStorageImpl<CMSWebDVD>,
	public ISpecifyPropertyPagesImpl<CMSWebDVD>,
	public IDataObjectImpl<CMSWebDVD>,
	public IProvideClassInfo2Impl<&CLSID_MSWebDVD, &DIID__IMSWebDVD, &LIBID_MSWEBDVDLib>,
	public CComCoClass<CMSWebDVD, &CLSID_MSWebDVD>,
    public IObjectSafety,
    public ISupportErrorInfo,
    public IPersistPropertyBagImpl<CMSWebDVD>,
	public CProxy_IMSWebDVD< CMSWebDVD >,
#ifdef _WMP
    public IWMPUIPluginImpl<CMSWebDVD>,
    public IWMPUIPluginEventsImpl,
#endif
    public IConnectionPointContainerImpl<CMSWebDVD>,
    public IObjectWithSiteImplSec<CMSWebDVD>,
    public CMSDVDTimer<CMSWebDVD>
{
public:
    CMSWebDVD();
    virtual ~CMSWebDVD();

//DECLARE_CLASSFACTORY_SINGLETON(CMSWebDVD)

DECLARE_REGISTRY_RESOURCEID(IDR_MSWEBDVD)

DECLARE_PROTECT_FINAL_CONSTRUCT()

BEGIN_COM_MAP(CMSWebDVD)
	COM_INTERFACE_ENTRY(IMSWebDVD)
	COM_INTERFACE_ENTRY(IDispatch)
	COM_INTERFACE_ENTRY(IViewObjectEx)
	COM_INTERFACE_ENTRY(IViewObject2)
	COM_INTERFACE_ENTRY(IViewObject)
	COM_INTERFACE_ENTRY(IOleInPlaceObjectWindowless)
	COM_INTERFACE_ENTRY(IOleInPlaceObject)
	COM_INTERFACE_ENTRY2(IOleWindow, IOleInPlaceObjectWindowless)
	COM_INTERFACE_ENTRY(IOleInPlaceActiveObject)
	COM_INTERFACE_ENTRY(IOleControl)
	COM_INTERFACE_ENTRY(IOleObject)
	COM_INTERFACE_ENTRY(IPersistStreamInit)
	COM_INTERFACE_ENTRY2(IPersist, IPersistStreamInit)
	COM_INTERFACE_ENTRY(ISpecifyPropertyPages)
	COM_INTERFACE_ENTRY(IPersistStorage)
	COM_INTERFACE_ENTRY(IDataObject)
	COM_INTERFACE_ENTRY(IProvideClassInfo)
	COM_INTERFACE_ENTRY(IProvideClassInfo2)
    COM_INTERFACE_ENTRY_IMPL(IPersistPropertyBag)
    COM_INTERFACE_ENTRY(IObjectSafety)
    COM_INTERFACE_ENTRY(ISupportErrorInfo)
    COM_INTERFACE_ENTRY_IMPL(IConnectionPointContainer)    
    COM_INTERFACE_ENTRY(IObjectWithSite)
END_COM_MAP()

BEGIN_PROP_MAP(CMSWebDVD)
	PROP_DATA_ENTRY("_cx", m_sizeExtent.cx, VT_UI4)
	PROP_DATA_ENTRY("_cy", m_sizeExtent.cy, VT_UI4)
    PROP_ENTRY("DisableAutoMouseProcessing", 70, CLSID_NULL)
    PROP_ENTRY("BackColor", DISPID_BACKCOLOR, CLSID_StockColorPage)
    PROP_ENTRY("EnableResetOnStop", 66, CLSID_NULL)
    PROP_ENTRY("ColorKey", 58, CLSID_NULL)
    PROP_ENTRY("WindowlessActivation", 69, CLSID_NULL)
#if 0
    PROP_ENTRY("ToolTip",    92, CLSID_NULL)
    PROP_ENTRY("ToolTipMaxWidth", 95, CLSID_NULL)
#endif
END_PROP_MAP()

BEGIN_CONNECTION_POINT_MAP(CMSWebDVD)
	CONNECTION_POINT_ENTRY(DIID__IMSWebDVD)
    CONNECTION_POINT_ENTRY(IID_IPropertyNotifySink)
END_CONNECTION_POINT_MAP()

BEGIN_MSG_MAP(CMSWebDVD)
	MESSAGE_HANDLER(WM_CREATE, OnCreate); // works only in windowed case
	MESSAGE_HANDLER(WM_DESTROY,OnDestroy);// works only in windowed case
    MESSAGE_HANDLER(WM_SIZE, OnSize);
    MESSAGE_HANDLER(WM_SIZING, OnSize);
    MESSAGE_HANDLER(WM_ERASEBKGND,  OnErase)
    MESSAGE_HANDLER(WM_DVDPLAY_EVENT, OnDVDEvent);
    MESSAGE_RANGE_HANDLER(WM_MOUSEFIRST, WM_MOUSELAST, OnMouseToolTip)
    MESSAGE_HANDLER(WM_MOUSEMOVE,   OnMouseMove)
	MESSAGE_HANDLER(WM_LBUTTONDOWN, OnButtonDown)
	MESSAGE_HANDLER(WM_LBUTTONUP,   OnButtonUp)
    MESSAGE_HANDLER(WM_DISPLAYCHANGE, OnDispChange);
    MESSAGE_HANDLER(WM_SETCURSOR, OnSetCursor);
	CHAIN_MSG_MAP(CComControl<CMSWebDVD>)
	DEFAULT_REFLECTION_HANDLER()
END_MSG_MAP()
// Handler prototypes:
//  LRESULT MessageHandler(UINT uMsg, WPARAM wParam, LPARAM lParam, BOOL& bHandled);
//  LRESULT CommandHandler(WORD wNotifyCode, WORD wID, HWND hWndCtl, BOOL& bHandled);
//  LRESULT NotifyHandler(int idCtrl, LPNMHDR pnmh, BOOL& bHandled);


// ISupportsErrorInfo
	STDMETHOD(InterfaceSupportsErrorInfo)(REFIID riid);
	
// IViewObjectEx
	DECLARE_VIEW_STATUS(VIEWSTATUS_SOLIDBKGND | VIEWSTATUS_OPAQUE)

// IMSWebDVD
public:
	STDMETHOD(get_FullScreenMode)(/*[out, retval]*/ VARIANT_BOOL *pVal);
	STDMETHOD(put_FullScreenMode)(/*[in]*/ VARIANT_BOOL newVal);
	STDMETHOD(PlayChaptersAutoStop)(LONG lTitle, LONG lstrChapter, LONG lChapterCount);
	STDMETHOD(GetNumberOfChapters)(long lTitle, /*[out, retval]*/ long *pVal);
	STDMETHOD(get_TitlesAvailable)(/*[out, retval]*/ long* pVal);
	STDMETHOD(Render)(/*[in]*/ long lRender = 0);
	STDMETHOD(Stop)();
	STDMETHOD(Pause)();
	STDMETHOD(Play)();
	STDMETHOD(PlayTitle)(LONG lTitle);
	STDMETHOD(PlayChapterInTitle)(LONG lTitle, LONG lChapter);
	STDMETHOD(PlayChapter)(LONG lChapter);
    STDMETHOD(GetSubpictureLanguage)(LONG lStream, BSTR* strLanguage);
	STDMETHOD(PlayAtTime)(BSTR strTime);
	STDMETHOD(PlayAtTimeInTitle)(long lTitle, BSTR strTime);
    STDMETHOD(PlayPeriodInTitleAutoStop)(long lTitle, BSTR strStartTime, BSTR strEndTime);
	STDMETHOD(ReplayChapter)();
	STDMETHOD(PlayPrevChapter)();
	STDMETHOD(PlayNextChapter)();
	STDMETHOD(PlayForwards)(double dSpeed, VARIANT_BOOL fDoNotReset);
	STDMETHOD(PlayBackwards)(double dSpeed, VARIANT_BOOL fDoNotReset);
	STDMETHOD(StillOff)();
	STDMETHOD(GetAudioLanguage)(LONG lStream, VARIANT_BOOL fFormat, BSTR* strAudioLang);
	STDMETHOD(ReturnFromSubmenu)();
	STDMETHOD(SelectAndActivateButton)(long lButton);
	STDMETHOD(ActivateButton)();
	STDMETHOD(SelectRightButton)();
	STDMETHOD(SelectLeftButton)();
	STDMETHOD(SelectLowerButton)();
	STDMETHOD(SelectUpperButton)();
	STDMETHOD(get_PlayState)(/*[out, retval]*/ DVDFilterState *pVal);
	STDMETHOD(ShowMenu)(DVDMenuIDConstants MenuID);
	STDMETHOD(Resume)();
    STDMETHOD(get_CurrentSubpictureStream)(/*[out, retval]*/ long *pVal);
	STDMETHOD(put_CurrentSubpictureStream)(/*[in]*/ long newVal);
	STDMETHOD(get_VolumesAvailable)(/*[out, retval]*/ long *pVal);
	STDMETHOD(get_CurrentVolume)(/*[out, retval]*/ long *pVal);
	STDMETHOD(get_CurrentDiscSide)(/*[out, retval]*/ long *pVal);
	STDMETHOD(get_CurrentDomain)(/*[out, retval]*/ long *pVal);
	STDMETHOD(get_DVDDirectory)(/*[out, retval]*/ BSTR *pVal);
	STDMETHOD(put_DVDDirectory)(/*[in]*/ BSTR newVal);
	STDMETHOD(get_CurrentTime)(/*[out, retval]*/ BSTR *pVal);
	STDMETHOD(get_FramesPerSecond)(/*[out, retval]*/ long *pVal);
	STDMETHOD(get_CurrentChapter)(/*[out, retval]*/ long *pVal);
	STDMETHOD(get_CurrentTitle)(/*[out, retval]*/ long *pVal);
    STDMETHOD(get_ColorKey)(/*[out, retval]*/ long *pVal);
	STDMETHOD(put_ColorKey)(/*[in]*/ long newVal);
	STDMETHOD(get_CurrentAudioStream)(/*[out, retval]*/ long *pVal);
	STDMETHOD(put_CurrentAudioStream)(/*[in]*/ long newVal);
	STDMETHOD(get_AudioStreamsAvailable)(/*[out, retval]*/ long *pVal);
	STDMETHOD(get_AnglesAvailable)(/*[out, retval]*/ long *pVal);
	STDMETHOD(get_CurrentAngle)(/*[out, retval]*/ long *pVal);
	STDMETHOD(put_CurrentAngle)(/*[in]*/ long newVal);
	STDMETHOD(get_CCActive)(/*[out, retval]*/ VARIANT_BOOL *pVal);
	STDMETHOD(put_CCActive)(/*[in]*/ VARIANT_BOOL newVal);
	STDMETHOD(get_ButtonsAvailable)(/*[out, retval]*/ long *pVal);
	STDMETHOD(get_CurrentButton)(/*[out, retval]*/ long *pVal);
	STDMETHOD(get_CurrentCCService)(/*[out, retval]*/ long *pVal);
	STDMETHOD(put_CurrentCCService)(/*[in]*/ long newVal);
	STDMETHOD(get_TotalTitleTime)(/*[out, retval]*/ BSTR *pVal);
	STDMETHOD(get_SubpictureStreamsAvailable)(/*[out, retval]*/ long *pVal);
	STDMETHOD(get_SubpictureOn)(/*[out, retval]*/ VARIANT_BOOL *pVal);
	STDMETHOD(put_SubpictureOn)(/*[in]*/ VARIANT_BOOL newVal);
   	STDMETHOD(UOPValid)(long lUOP, VARIANT_BOOL* pfValid);
    STDMETHOD(get_Balance)(/*[out, retval]*/ long *pVal);
	STDMETHOD(put_Balance)(/*[in]*/ long newVal);
	STDMETHOD(get_Volume)(/*[out, retval]*/ long *pVal);
	STDMETHOD(put_Volume)(/*[in]*/ long newVal);
	STDMETHOD(get_Mute)(/*[out, retval]*/ VARIANT_BOOL *pVal);
	STDMETHOD(put_Mute)(/*[in]*/ VARIANT_BOOL newVal);
	STDMETHOD(get_DVDUniqueID)(/*[out, retval]*/ BSTR *pVal);
	STDMETHOD(GetSPRM)(long lIndex, short *psSPRM);
	STDMETHOD(GetGPRM)(long lIndex, short *psSPRM);
    STDMETHOD(get_EnableResetOnStop)(/*[out, retval]*/ VARIANT_BOOL *pVal);
	STDMETHOD(put_EnableResetOnStop)(/*[in]*/ VARIANT_BOOL newVal);
    STDMETHOD(get_BackColor)(VARIANT* pclrBackColor);
    STDMETHOD(put_BackColor)(VARIANT clrBackColor);
	STDMETHOD(get_ReadyState)(/*[out, retval]*/ LONG *pVal);
    STDMETHOD(ActivateAtPosition)(long xPos, long yPos);
    STDMETHOD(SelectAtPosition)(long xPos, long yPos);
	STDMETHOD(get_DisableAutoMouseProcessing)(/*[out, retval]*/ VARIANT_BOOL *pVal);
	STDMETHOD(put_DisableAutoMouseProcessing)(/*[in]*/ VARIANT_BOOL newVal);
	STDMETHOD(get_WindowlessActivation)(/*[out, retval]*/ VARIANT_BOOL *pVal);
	STDMETHOD(put_WindowlessActivation)(/*[in]*/ VARIANT_BOOL newVal);
    STDMETHOD(GetButtonRect)(long lButton, IDVDRect** pRect);
	STDMETHOD(GetButtonAtPosition)(long xPos, long yPos, long* plButton);
    STDMETHOD(AcceptParentalLevelChange)(VARIANT_BOOL fAccept, BSTR strUserName, BSTR strPassword);	
	STDMETHOD(NotifyParentalLevelChange)(/*[in]*/ VARIANT_BOOL newVal);
	STDMETHOD(SelectParentalCountry)(long lCountry, BSTR strUserName, BSTR strPassword);
	STDMETHOD(SelectParentalLevel)(long lParentalLevel, BSTR strUserName, BSTR strPassword);
	STDMETHOD(GetTitleParentalLevels)(long lTitle, long* plParentalLevels);
	STDMETHOD(GetPlayerParentalCountry)(long* plCountryCode);
	STDMETHOD(GetPlayerParentalLevel)(long* plParentalLevel);
	STDMETHOD(SetClipVideoRect)(IDVDRect* pRect);
	STDMETHOD(GetVideoSize)(IDVDRect** ppRect);
	STDMETHOD(GetClipVideoRect)(IDVDRect** ppRect);
	STDMETHOD(SetDVDScreenInMouseCoordinates)(IDVDRect* pRect);
	STDMETHOD(GetDVDScreenInMouseCoordinates)(IDVDRect** ppRect);	
#if 1
	STDMETHOD(get_ToolTip)(/*[out, retval]*/ BSTR *pVal);
	STDMETHOD(put_ToolTip)(/*[in]*/ BSTR newVal);
    STDMETHOD(get_ToolTipMaxWidth)(/*[out, retval]*/ long *pVal);
	STDMETHOD(put_ToolTipMaxWidth)(/*[in]*/ long newVal);
    STDMETHOD(GetDelayTime)(/*[in]*/ long delayType, /*[out, retval]*/ VARIANT *pVal);
	STDMETHOD(SetDelayTime)(/*[in]*/ long delayType, /*[in]*/ VARIANT newVal);	
#endif
    HRESULT ProcessEvents();
	STDMETHOD(Eject)();
    STDMETHOD(SetGPRM)(long lIndex, short sValue);
    STDMETHOD(GetDVDTextStringType)(long lLangIndex, long lStringIndex,  DVDTextStringType* pType);
	STDMETHOD(GetDVDTextString)(long lLangIndex, long lStringIndex,  BSTR* pstrText);
	STDMETHOD(GetDVDTextNumberOfStrings)(long lLangIndex, long* plNumOfStrings);
	STDMETHOD(GetDVDTextNumberOfLanguages)(long* plNumOfLangs);
	STDMETHOD(GetDVDTextLanguageLCID)(/*[in]*/ long lLangIndex, /*[out, retval]*/ long* lcid);
    STDMETHOD(RegionChange)();
	STDMETHOD(Zoom)(long x, long y, double zoomRatio);
	STDMETHOD(get_CursorType)(/*[out, retval]*/ DVDCursorType *pVal);
	STDMETHOD(put_CursorType)(/*[in]*/ DVDCursorType newVal);
	STDMETHOD(get_DVDAdm)(/*[out, retval]*/ IDispatch* *pVal);
    STDMETHOD(DeleteBookmark)();
	STDMETHOD(RestoreBookmark)();
    STDMETHOD(SaveBookmark)();
    STDMETHOD(Capture)();
    STDMETHOD(SelectDefaultAudioLanguage)(long lang, long ext);
	STDMETHOD(SelectDefaultSubpictureLanguage)(long lang, DVDSPExt ext);
    STDMETHOD(get_PreferredSubpictureStream)(/*[out, retval]*/ long *pVal);
    STDMETHOD(CanStep)(VARIANT_BOOL fBackwards, VARIANT_BOOL *pfCan);
    STDMETHOD(Step)(long lStep);
    STDMETHOD(get_DefaultMenuLanguage)(long* lang);
	STDMETHOD(put_DefaultMenuLanguage)(long lang);
    STDMETHOD(get_DefaultSubpictureLanguage)(long* lang);
	STDMETHOD(get_DefaultAudioLanguage)(long *lang);
	STDMETHOD(get_DefaultSubpictureLanguageExt)(DVDSPExt* ext);
	STDMETHOD(get_DefaultAudioLanguageExt)(long *ext);
	STDMETHOD(get_KaraokeAudioPresentationMode)(/*[out, retval]*/ long *pVal);
	STDMETHOD(put_KaraokeAudioPresentationMode)(/*[in]*/ long newVal);
	STDMETHOD(GetKaraokeChannelContent)(long lStream, long lChan, long* lContent);
	STDMETHOD(GetKaraokeChannelAssignment)(long lStream, long *lChannelAssignment);
	STDMETHOD(get_AspectRatio)(/*[out, retval]*/ double *pVal);
	STDMETHOD(put_ShowCursor)(VARIANT_BOOL fShow);
    STDMETHOD(get_ShowCursor)(VARIANT_BOOL* pfShow);
	STDMETHOD(GetLangFromLangID)(/*[in]*/ long langID, /*[out, retval]*/ BSTR* lang);
	STDMETHOD(DVDTimeCode2bstr)(/*[in]*/ long timeCode, /*[out, retval]*/ BSTR *pTimeStr);
	STDMETHOD(IsSubpictureStreamEnabled)(/*[in]*/ long lstream, /*[out, retval]*/ VARIANT_BOOL *fEnabled);
	STDMETHOD(IsAudioStreamEnabled)(/*[in]*/ long lstream, /*[out, retval]*/ VARIANT_BOOL *fEnabled);


    STDMETHOD(SetObjectRects)(LPCRECT prcPos,LPCRECT prcClip);
	

	//ISafety
    STDMETHOD(GetInterfaceSafetyOptions)( REFIID riid,
                                          DWORD *pdwSupportedOptions,
                                          DWORD *pdwEnabledOptions );

    STDMETHOD(SetInterfaceSafetyOptions)( REFIID riid,
                                          DWORD dwOptionSetMask,
                                          DWORD dwEnabledOptions );
    STDMETHOD(SetClientSite)(IOleClientSite *pClientSite);

    // local helper functions
public:
    HRESULT AdjustDestRC();
	HRESULT OnDraw(ATL_DRAWINFO& di);

#ifdef _WMP
	HRESULT InPlaceActivate(LONG iVerb, const RECT* /*prcPosRect*/);
#endif 

    HRESULT OnPostVerbInPlaceActivate();
    HRESULT TimerProc(); // needs to be called from a timer proc
    static CWndClassInfo& GetWndClassInfo(){
        static HBRUSH hbr= ::CreateSolidBrush(RGB(0,0,0));




        /**********************************
        #define OCR_ARROW_DEFAULT 100
        // need special cursor, we we do not have color key around it
        static HCURSOR hcr = (HCURSOR) ::LoadImage((HINSTANCE) NULL,
                                MAKEINTRESOURCE(OCR_ARROW_DEFAULT),
                                IMAGE_CURSOR,0,0,0);
        *********************/
	    static CWndClassInfo wc = {{ sizeof(WNDCLASSEX), 0, StartWindowProc,

		      0, 0, NULL, NULL, NULL, /* NULL */ hbr,
              NULL, TEXT("MSMFVideoClass"), NULL },
		    NULL, NULL, MAKEINTRESOURCE(OCR_ARROW_DEFAULT), TRUE, 0, _T("") };
	    return wc;
    }/* end of function GetWndClassInfo */

private:
    VOID Init();
    VOID Cleanup();
    HRESULT SetDDrawExcl();
    LRESULT OnDVDEvent(UINT uMsg, WPARAM wParam, LPARAM lParam, BOOL& bHandled);
    LRESULT OnSize(UINT uMsg, WPARAM wParam, LPARAM lParam, BOOL& bHandled);
    LRESULT OnDispChange(UINT uMsg, WPARAM wParam, LPARAM lParam, BOOL& bHandled);
    LRESULT OnErase(UINT uMsg, WPARAM wParam, LPARAM lParam, BOOL& bHandled);
    LRESULT OnCreate(UINT uMsg, WPARAM wParam, LPARAM lParam, BOOL& bHandled);
    LRESULT OnDestroy(UINT uMsg, WPARAM wParam, LPARAM lParam, BOOL& bHandled);
    LRESULT OnMouseToolTip(UINT, WPARAM wParam, LPARAM lParam, BOOL& bHandled);
    LRESULT OnButtonDown(UINT, WPARAM wParam, LPARAM lParam, BOOL& bHandled);
    LRESULT OnButtonUp(UINT, WPARAM wParam, LPARAM lParam, BOOL& bHandled);
    LRESULT OnMouseMove(UINT, WPARAM wParam, LPARAM lParam, BOOL& bHandled);
    LRESULT OnSetCursor(UINT, WPARAM wParam, LPARAM lParam, BOOL& bHandled);
    HRESULT SetReadyState(LONG lReadyState);
    static HRESULT DVDTime2bstr(const DVD_HMSF_TIMECODE *pulTime, BSTR *pbstrTime);
    static HRESULT Bstr2DVDTime(DVD_HMSF_TIMECODE *pulTime, const BSTR *pbstrTime);
    HRESULT SetColorKey(COLORREF clr);
    HRESULT GetColorKey(COLORREF* pClr);
    HRESULT TraverseForInterface(REFIID iid, LPVOID* ppvObject);
    HRESULT SetupAudio(); // fills in the audio interface
    HRESULT SetupDDraw();
    HRESULT SetupEventNotifySink(); // sets up IMediaEventSink
    HRESULT RenderGraphIfNeeded();
    HRESULT PassFP_DOM();
    HRESULT getCDDriveLetter(TCHAR* lpDrive);
    DWORD OpenCdRom(TCHAR chDrive, LPDWORD lpdwErrCode);
    HRESULT CloseCdRom(DWORD DevHandle);
    HRESULT EjectCdRom(DWORD DevHandle);
    HRESULT UnEjectCdRom(DWORD DevHandle);
    HRESULT HandleError(HRESULT hr);
    HRESULT SelectParentalLevel(long lParentalLevel);
    HRESULT SelectParentalCountry(long lCountry);
    HRESULT TransformToWndwls(POINT& pt);
    HRESULT getDVDDriveLetter(TCHAR* lpDrive);
    HRESULT GetMostOuterWindow(HWND* phwndParent);
    HRESULT RestoreDefaultSettings();
    HRESULT GetParentHWND(HWND* pWnd);
    HRESULT GetUsableWindow(HWND* pWnd);
    HRESULT GetClientRectInScreen(RECT* prc);
    HRESULT OnResize(); //helper function that we need to marshal
    HRESULT RestoreGraphState();
    HRESULT AppendString(TCHAR* strDest, INT strID, LONG dwLen);
    HRESULT InvalidateRgn(bool fErase = false);
    // monitor support
    HRESULT RefreshDDrawGuids();
    HRESULT DDrawGuidFromHMonitor(HMONITOR hMon, AMDDRAWGUID* lpGUID);
    bool IsWindowOnWrongMonitor(HMONITOR* lphMon);
    HRESULT RestoreSurfaces();
    HRESULT ChangeMonitor(HMONITOR hMon, const AMDDRAWGUID* lpguid);
    HRESULT DisplayChange(HMONITOR hMon, const AMDDRAWGUID* lpguid);
    HRESULT UpdateCurrentMonitor(const AMDDRAWGUID* lpguid);
    HRESULT HandleMultiMonMove();
    HRESULT HandleMultiMonPaint(HDC hdc);
    HRESULT get_IntVolume(LONG* plVolume);
    HRESULT put_IntVolume(long lVolume);
    HRESULT CanStepBackwards();

// member variables
private:
    LONG              m_lChapter, m_lTitle;
    LONG              m_lChapterCount; // count of the chapters to play
    CComPtr<IDvdGraphBuilder> m_pDvdGB;     // IDvdGraphBuilder interface
    CComPtr<IGraphBuilder>    m_pGB;        // IGraphBuilder interface
    CComPtr<IMediaControl>    m_pMC;        // IMediaControl interface
    CComPtr<IMediaEventEx>    m_pME ;       // IMediaEventEx interface
    CComPtr<IDvdControl2>     m_pDvdCtl2;    // New DVD Control    
    CComPtr<IDvdInfo2>        m_pDvdInfo2;  // New DVD Info Interface
    CComPtr<IBasicAudio>      m_pAudio;     // Audio interface
    CComPtr<IMediaEventSink>  m_pMediaSink;         
    BOOL              m_bUseColorKey; // flag to see if we are using color key
    COLORREF          m_clrColorKey;  // color key
    BOOL              m_bMute;        // mute flag
    LONG              m_lLastVolume; // used to preserve the last volume for mute
    BOOL              m_fEnableResetOnStop; // disable or enable the restart of the seek
    CComPtr<IVideoFrameStep>  m_pVideoFrameStep; 
    CComPtr<IDDrawNonExclModeVideo> m_pDDEX;   // The new interface that can capture
    //IDDrawExclModeVideo *m_pDDEX;   // IDDrawExclModeVideo interface    
    bool              m_fUseDDrawDirect; // flag to switch between a ddraw mode and none ddraw mode
    bool              m_fInitialized; // flag to see if we are initialize
    HANDLE            m_hFPDOMEvent; // handle to the FP_DOM event which gets signaled when we get out of FP_DOM
    bool              m_fDisableAutoMouseProcessing; // Disable the automatic mouse processing
    bool              m_bEjected;   // whether disc is ejected right now
    bool              m_fStillOn;    // flag to see if we have a still
    bool              m_fResetSpeed; 
    CComPtr<IMSDVDAdm> m_pDvdAdmin;
    DVDCursorType     m_nCursorType;
    RECT              *m_pClipRect;
    RECT              m_ClipRectDown;
    BOOL              m_bMouseDown;
    POINT             m_ClipCenter;
    POINT             m_LastMouse;
    POINT             m_LastMouseDown;
    HCURSOR           m_hCursor;
    double            m_dZoomRatio;
    DWORD             m_dwAspectX;
    DWORD             m_dwAspectY;
    DWORD             m_dwVideoWidth;
    DWORD             m_dwVideoHeight;
    DWORD             m_dwOvMaxStretch;
    HWND              m_hWndOuter;
    RECT              m_rcOldPos;
    RECT              m_rcPosAspectRatioAjusted;
    UINT_PTR          m_hTimerId;
    DVDFilterState    m_DVDFilterState;
    MSLangID          m_LangID;
    long              m_lKaraokeAudioPresentationMode;
    DWORD_PTR         m_dwTTReshowDelay;
    DWORD_PTR         m_dwTTAutopopDelay;
    DWORD_PTR         m_dwTTInitalDelay;
    // monitor support
    CDDrawDVD* m_pDDrawDVD;
    DWORD m_dwNumDevices;
    AMDDRAWMONITORINFO* m_lpInfo;
    AMDDRAWMONITORINFO* m_lpCurMonitor;
    BOOL m_MonitorWarn;
    bool m_fStepComplete;
    BOOL m_bFireUpdateOverlay;
    // ejection/insert handling
    // This MUST be in the same thread as the disk reader or we'll
    // end up with some nasty race conditions (ejection notification
    // will happen after a read instead of before)
    CMediaHandler   m_mediaHandler;
    BOOL m_bFireNoSubpictureStream;
#if 1
    HWND m_hWndTip;         // Tooltip window
    LONG m_nTTMaxWidth;     // Max tooltip width
    CComBSTR m_bstrToolTip; // Tooltip string
    BOOL m_bTTCreated;      // Has tooltip been created yet
    HRESULT CreateToolTip();
#endif
    bool m_fBackWardsFlagInitialized;
    bool m_fCanStepBackwards;

// stock properties have to be public due to ATL implementation
public: 		
	LONG m_nReadyState; // ready state change stock property
    OLE_COLOR m_clrBackColor;   // stock property implemeted in the CStockPropImpl	

    void SetDiscEjected(bool bEjected) {m_bEjected = bEjected;};
    HRESULT UpdateOverlay();
};



// error code

#define E_FORMAT_NOT_SUPPORTED MAKE_HRESULT(SEVERITY_ERROR, FACILITY_ITF, 0xFF2)


#endif //__MSWEBDVD_H_
/*************************************************************************/
/* End of file: msdvd.h                                                  */
/*************************************************************************/
=== C:/Users/treeman/Desktop/windows nt source code\Source\Win2K3\NT\multimedia\dshow\mfvideo\mswebdvd\monitor.cpp ===
/*************************************************************************/
/* Copyright (C) 1999 Microsoft Corporation                              */
/* File: msdvd.cpp                                                       */
/* Description: Implementation of CMSWebDVD.                             */
/* Author: David Janecek                                                 */
/*************************************************************************/
#include "stdafx.h"
#include "MSDVD.h"
#include "ddrawobj.h"

#define COMPILE_MULTIMON_STUBS
#define HMONITOR_DECLARED // to cover up DDraw Monitor redefinition
#include <multimon.h>

extern GUID IID_IDDrawNonExclModeVideo = {
            0xec70205c,0x45a3,0x4400,{0xa3,0x65,0xc4,0x47,0x65,0x78,0x45,0xc7}};


/*****************************Private*Routine******************************\
* UpdateCurrentMonitor
*
* Updates the "m_lpCurMonitor" global to match the specified DDraw GUID
*
* History:
* Wed 11/17/1999 - StEstrop - Created
*
\**************************************************************************/
HRESULT CMSWebDVD::UpdateCurrentMonitor(
    const AMDDRAWGUID* lpguid
    )
{
    if (lpguid->lpGUID)
    {
        for (AMDDRAWMONITORINFO* lpCurMonitor = &m_lpInfo[0];
             lpCurMonitor < &m_lpInfo[m_dwNumDevices]; lpCurMonitor++)
        {
            if (lpCurMonitor->guid.lpGUID &&
               *lpCurMonitor->guid.lpGUID == *lpguid->lpGUID)
            {
                m_lpCurMonitor = lpCurMonitor;
                return S_OK;
            }
        }
    }
    else
    {
        for (AMDDRAWMONITORINFO* lpCurMonitor = &m_lpInfo[0];
             lpCurMonitor < &m_lpInfo[m_dwNumDevices]; lpCurMonitor++)
        {
            if (lpguid->lpGUID == lpCurMonitor->guid.lpGUID)
            {
                m_lpCurMonitor = lpCurMonitor;
                return S_OK;
            }
        }
    }

    return E_FAIL;
}

/******************************Public*Routine******************************\
* DisplayChange
*
*
*
* History:
* Sat 11/27/1999 - StEstrop - Created
*
\**************************************************************************/
HRESULT
CMSWebDVD::DisplayChange(
    HMONITOR hMon,
    const AMDDRAWGUID* lpguid
    )
{
    HRESULT hr = E_FAIL;

    if(!m_pDvdGB){
        
        return(E_FAIL);
    }/* end of if statement */

    CDDrawDVD* pDDrawObj = new CDDrawDVD(this);

    if(NULL == pDDrawObj){

        return (E_OUTOFMEMORY);
    }/* end if statement */

    HWND hwnd;

    hr = GetUsableWindow(&hwnd);

    if(FAILED(hr)){

        delete pDDrawObj;
        return(hr);
    }/* end of if statement */

    hr = pDDrawObj->SetupDDraw(lpguid, hwnd);

    if (FAILED(hr))
    {
        delete pDDrawObj;
        return hr;
    }

    IDDrawNonExclModeVideo* pDDXMV;
    hr = m_pDvdGB->GetDvdInterface(IID_IDDrawNonExclModeVideo,
                                           (LPVOID *)&pDDXMV) ;
    if (FAILED(hr))
    {
        delete pDDrawObj;
        return hr;
    }

    LPDIRECTDRAW pDDObj = pDDrawObj->GetDDrawObj();
    LPDIRECTDRAWSURFACE pDDPrimary = pDDrawObj->GetDDrawSurf();

    hr = pDDXMV->SetCallbackInterface(NULL, 0) ;
    if (FAILED(hr)){

        pDDXMV->Release() ;  // release before returning
        return hr;
    }/* end of if statement */

    hr = pDDXMV->DisplayModeChanged(hMon, pDDObj, pDDPrimary);

    if (SUCCEEDED(hr)) {

        delete m_pDDrawDVD;
        m_pDDrawDVD = pDDrawObj;
        hr = UpdateCurrentMonitor(lpguid);
    }
    else {
        delete pDDrawObj;
    }

    hr = pDDXMV->SetCallbackInterface(m_pDDrawDVD->GetCallbackInterface(), 0) ;

    if (SUCCEEDED(hr))
    {
        hr = SetColorKey(DEFAULT_COLOR_KEY);
    }/* end of it statement */


    pDDXMV->Release();
    return hr;
}

/******************************Public*Routine******************************\
* ChangeMonitor
*
* Tells the OVMixer that we want to change to another monitor.
*
* History:
* Wed 11/17/1999 - StEstrop - Created
*
\**************************************************************************/
HRESULT
CMSWebDVD::ChangeMonitor(
    HMONITOR hMon,
    const AMDDRAWGUID* lpguid
    )
{

    HRESULT hr = E_FAIL;

    if(!m_pDvdGB){
        
        return(E_FAIL);
    }/* end of if statement */

    CDDrawDVD* pDDrawObj = new CDDrawDVD(this);

    if(NULL == pDDrawObj){

        return (E_OUTOFMEMORY);
    }/* end if statement */

    HWND hwnd;

    hr = GetUsableWindow(&hwnd);

    if(FAILED(hr)){

        delete pDDrawObj;
        return(hr);
    }/* end of if statement */

    hr = pDDrawObj->SetupDDraw(lpguid, hwnd);

    if (FAILED(hr))
    {
        delete pDDrawObj;
        return hr;
    }

    IDDrawNonExclModeVideo* pDDXMV;
    hr = m_pDvdGB->GetDvdInterface(IID_IDDrawNonExclModeVideo,
                                           (LPVOID *)&pDDXMV) ;
    if (FAILED(hr))
    {
        delete pDDrawObj;
        return hr;
    }

    LPDIRECTDRAW pDDObj = pDDrawObj->GetDDrawObj();
    LPDIRECTDRAWSURFACE pDDPrimary = pDDrawObj->GetDDrawSurf();

    hr = pDDXMV->SetCallbackInterface(NULL, 0) ;
    if (FAILED(hr)){

        pDDXMV->Release() ;  // release before returning
        return hr;
    }/* end of if statement */

    hr = pDDXMV->ChangeMonitor(hMon, pDDObj, pDDPrimary);

    if (SUCCEEDED(hr)) {

        delete m_pDDrawDVD;
        m_pDDrawDVD = pDDrawObj;
        hr = UpdateCurrentMonitor(lpguid);
    }
    else {
        delete pDDrawObj;
    }

    hr = pDDXMV->SetCallbackInterface(m_pDDrawDVD->GetCallbackInterface(), 0) ;

    if (SUCCEEDED(hr))
    {
        hr = SetColorKey(DEFAULT_COLOR_KEY);
    }/* end of it statement */

    pDDXMV->Release();
    return hr;
}


/******************************Public*Routine******************************\
* RestoreSurfaces
*
* Tells the OVMixer to restore its internal DDraw surfaces
*
* History:
* Wed 11/17/1999 - StEstrop - Created
*
\**************************************************************************/
HRESULT
CMSWebDVD::RestoreSurfaces()
{
    if(!m_pDvdGB){
        
        return(E_FAIL);
    }/* end of if statement */

    IDDrawNonExclModeVideo* pDDXMV;
    HRESULT hr = m_pDvdGB->GetDvdInterface(IID_IDDrawNonExclModeVideo,
                                           (LPVOID *)&pDDXMV) ;
    if (FAILED(hr))
    {
        return hr;
    }

    hr = pDDXMV->RestoreSurfaces();
    pDDXMV->Release();

    return hr;
}

/*************************************************************************/
/* Function: RefreshDDrawGuids                                           */
/*************************************************************************/
HRESULT CMSWebDVD::RefreshDDrawGuids()
{
    IDDrawNonExclModeVideo* pDDXMV;
    if(!m_pDvdGB){
        
        return(E_FAIL);
    }/* end of if statement */

    HRESULT hr = m_pDvdGB->GetDvdInterface(IID_IDDrawNonExclModeVideo,
                                           (LPVOID *)&pDDXMV) ;
    if (FAILED(hr))
    {
        return hr;
    }

    GUID IID_IAMSpecifyDDrawConnectionDevice = {
            0xc5265dba,0x3de3,0x4919,{0x94,0x0b,0x5a,0xc6,0x61,0xc8,0x2e,0xf4}};

    IAMSpecifyDDrawConnectionDevice* pSDDC;
    hr = pDDXMV->QueryInterface(IID_IAMSpecifyDDrawConnectionDevice, (LPVOID *)&pSDDC);
    if (FAILED(hr))
    {
        pDDXMV->Release();
        return hr;
    }

    DWORD dwNumDevices;
    AMDDRAWMONITORINFO* lpInfo;

    hr = pSDDC->GetDDrawGUIDs(&dwNumDevices, &lpInfo);
    if (SUCCEEDED(hr)) {
        CoTaskMemFree(m_lpInfo);
        m_lpCurMonitor = NULL;
        m_lpInfo = lpInfo;
        m_dwNumDevices = dwNumDevices;
    }

    pSDDC->Release();
    pDDXMV->Release();

    return hr;
}/* end of function RefreshDDrawGuids */

/*****************************Private*Routine******************************\
* IsWindowOnWrongMonitor
*
* Use the same algorithm that the OVMixer uses to determine if we are on
* the wrong monitor or not.
*
* If we are on the wrong monitor *lphMon contains the monitor handle of the
* new monitor to use.
*
* History:
* Wed 11/17/1999 - StEstrop - Created
*
\**************************************************************************/
bool CMSWebDVD::IsWindowOnWrongMonitor(
    HMONITOR* lphMon)
{

    if (!m_lpCurMonitor)
    {
        return false;
    }

    HWND hwnd;

    HRESULT hr = GetUsableWindow(&hwnd);

    if(FAILED(hr)){

        return(false);
    }/* end of if statement */

    RECT rc;

    hr = GetClientRectInScreen(&rc);

    if(FAILED(hr)){

        return(false);
    }/* end of if statement */

    *lphMon = m_lpCurMonitor->hMon;
    if (GetSystemMetrics(SM_CMONITORS) > 1 && !::IsIconic(hwnd))
    {
        LPRECT lprcMonitor = &m_lpCurMonitor->rcMonitor;

        if (rc.left < lprcMonitor->left || rc.right > lprcMonitor->right ||
            rc.top < lprcMonitor->top   || rc.bottom > lprcMonitor->bottom)
        {
            HMONITOR hMon = MonitorFromRect(&rc, MONITOR_DEFAULTTONEAREST);
            if (*lphMon != hMon)
            {
                *lphMon = hMon;
                return true;
            }
        }
    }

    return false;
}

/*****************************Private*Routine******************************\
* DDrawGuidFromHMonitor
*
* Return the DDraw guid from the specified hMonitor handle.
*
* History:
* Wed 11/17/1999 - StEstrop - Created
*
\**************************************************************************/
HRESULT CMSWebDVD::DDrawGuidFromHMonitor(
    HMONITOR hMon,
    AMDDRAWGUID* lpGUID
    )
{
    AMDDRAWMONITORINFO* lpCurMonitor = &m_lpInfo[0];

#if 1
    if (m_dwNumDevices == 1) {
        *lpGUID = lpCurMonitor->guid;
        return S_OK;
    }
#endif

    for (; lpCurMonitor < &m_lpInfo[m_dwNumDevices]; lpCurMonitor++)
    {
        if (lpCurMonitor->hMon == hMon) {
            *lpGUID = lpCurMonitor->guid;
            return S_OK;
        }
    }

    return E_FAIL;
}

struct MONITORDATA {
    HMONITOR hMonPB;
    BOOL fMsgShouldBeDrawn;
};


/*****************************Private*Routine******************************\
* MonitorEnumProc
*
* On Multi-Monitor systems make sure that the part of the window that is not
* on the primary monitor is black.
*
* History:
* Thu 06/03/1999 - StEstrop - Created
*
\**************************************************************************/
BOOL CALLBACK
MonitorEnumProc(
  HMONITOR hMonitor,        // handle to display monitor
  HDC hdc,                  // handle to monitor-appropriate device context
  LPRECT lprcMonitor,       // pointer to monitor intersection rectangle
  LPARAM dwData             // data passed from EnumDisplayMonitors
  )
{
    MONITORDATA* lpmd = (MONITORDATA*)dwData;
    //COLORREF clrOld = GetBkColor(hdc);

    if (lpmd->hMonPB != hMonitor)
    {
        //SetBkColor(hdc, RGB(0,0,0));
        lpmd->fMsgShouldBeDrawn = TRUE;
    }
    else
    {   // put your own color key here
        ;//SetBkColor(hdc, RGB(255,0,255));
    }

    //ExtTextOut(hdc, 0, 0, ETO_OPAQUE, lprcMonitor, NULL, 0, NULL);
    //SetBkColor(hdc, clrOld);

    return TRUE;
}

/*************************************************************************/
/* Function: OnDispChange                                                */
/*************************************************************************/
LRESULT CMSWebDVD::OnDispChange(UINT /* uMsg */, WPARAM  wParam,
                            LPARAM lParam, BOOL& bHandled){

    if(::IsWindow(m_hWnd)){

        bHandled = FALSE;
        return(0);
        //do not handle this in windowed mode
    }/* end of if statement */

    RECT rc;

    HRESULT hr = GetClientRectInScreen(&rc);

    if(FAILED(hr)){

        return(-1);
    }/* end of if statement */

    HMONITOR hMon = ::MonitorFromRect(&rc, MONITOR_DEFAULTTONEAREST);

    AMDDRAWGUID guid;
    hr = RefreshDDrawGuids();

    if(FAILED(hr)){

        return -1;
    }/* end of if statement */

    hr = DDrawGuidFromHMonitor(hMon, &guid);

    if(FAILED(hr)){

        return -1;
    }/* end of if statement */

    hr = DisplayChange(hMon, &guid);

    if(FAILED(hr)){

        return -1;
    }/* end of if statement */

    return 0;
}/* end of function OnDispChange */

/*************************************************************************/
/* Function: HandleMultiMonMove                                          */
/* Description: Moves the playback to another monitor when needed.       */
/*************************************************************************/
HRESULT CMSWebDVD::HandleMultiMonMove(){

    HRESULT hr = S_FALSE;

    if (::GetSystemMetrics(SM_CMONITORS) > 1){

        HMONITOR hMon;
        if (IsWindowOnWrongMonitor(&hMon)) {

            AMDDRAWGUID guid;
            hr = DDrawGuidFromHMonitor(hMon, &guid);

            if(FAILED(hr)){

                return(hr);
            }/* end of if statement */

            hr = ChangeMonitor(hMon, &guid);

            if(FAILED(hr)){

                m_MonitorWarn = TRUE;
                InvalidateRgn();
                return(hr);
            }/* end of if statement */
        }/* end of if statement */

        //
        // We always have to invalidate the windows client area, otherwise
        // we handle the Multi-Mon case very badly.
        //

        //::InvalidateRect(hWnd, NULL, FALSE);
        InvalidateRgn();
        return(hr);
    }/* end of if statement */

    return(hr);
}/* end of function HandleMultiMonMove */

/*************************************************************************/
/* Function: HandleMultiMonPaint                                         */
/*************************************************************************/
HRESULT CMSWebDVD::HandleMultiMonPaint(HDC hDC){

    if (::GetSystemMetrics(SM_CMONITORS) > 1){

        MONITORDATA md;
        md.hMonPB = m_lpCurMonitor ? m_lpCurMonitor->hMon : (HMONITOR)NULL;
        md.fMsgShouldBeDrawn = FALSE;

        RECT rc;

        HRESULT hr = GetClientRectInScreen(&rc);

        if(FAILED(hr)){

            return(hr);
        }/* end of if statement */

        //EnumDisplayMonitors(hDC, NULL, MonitorEnumProc, (LPARAM)&md);
        EnumDisplayMonitors(NULL, &rc, MonitorEnumProc, (LPARAM)&md);

        if (m_MonitorWarn && md.fMsgShouldBeDrawn){


            TCHAR strBuffer[MAX_PATH];
            if(!::LoadString(_Module.m_hInstResource, IDS_MOVE_TO_OTHER_MON, strBuffer, MAX_PATH)){

                return(E_UNEXPECTED);
            }/* end of if statement */

            SetBkColor(hDC, RGB(0,0,0));
            SetTextColor(hDC, RGB(255,255,0));

            if(FAILED(hr)){

                return(hr);
            }/* end of if statement */

            DrawText(hDC, strBuffer, -1, &m_rcPos, DT_CENTER | DT_WORDBREAK);
        }/* end of if statement */

        return(S_OK);
    }/* end of if statement */

    return(S_FALSE);
}/* end of function HandleMultiMonPaint */

/*************************************************************************/
/* Function: InvalidateRgn                                               */
/* Description: Invalidates the whole rect in case we need to repaint it.*/
/*************************************************************************/
HRESULT CMSWebDVD::InvalidateRgn(bool fErase){

    HRESULT hr = S_OK;

    if(m_bWndLess){

        m_spInPlaceSite->InvalidateRgn(NULL ,fErase ? TRUE: FALSE);
    }
    else {
        if(NULL == m_hWnd){

            hr = E_FAIL;
            return(hr);
        }/* end of if statement */

        if(::IsWindow(m_hWnd)){

		    ::InvalidateRgn(m_hWnd, NULL, fErase ? TRUE: FALSE); // see if we can get by by not erasing..
        }
        else {
            hr = E_UNEXPECTED;
        }/* end of if statement */

    }/* end of if statement */

    return(hr);
}/* end of function InvalidateRgn */

/*************************************************************************/
/* End of file: monitor.cpp                                              */
/*************************************************************************/
=== C:/Users/treeman/Desktop/windows nt source code\Source\Win2K3\NT\multimedia\dshow\mfvideo\mswebdvd\msgwindow.h ===
//
// Copyright (c) 1996 - 1999  Microsoft Corporation.  All Rights Reserved.
//
#ifndef __CMsgWindow__h
#define __CMsgWindow__h

//
//  Message Window class (for handling WM_TIMER messages) definition
//
class CMsgWindow
{
public:
    virtual         ~CMsgWindow() ;

    virtual bool    Open( LPCTSTR pWindowName = 0);
    virtual bool    Close();
    virtual LRESULT WndProc( UINT uMsg, WPARAM wParam, LPARAM lParam );

    HWND            GetHandle() const { return m_hWnd; } ;
    void            SetHandle(HWND hwnd) {m_hWnd = hwnd; } ;

protected:
                    CMsgWindow();
private:
    HWND            m_hWnd ;
};
#endif
=== C:/Users/treeman/Desktop/windows nt source code\Source\Win2K3\NT\multimedia\dshow\mfvideo\mswebdvd\msdvd.cpp ===
/*************************************************************************/
/* Copyright (C) 1999 Microsoft Corporation                              */
/* File: msdvd.cpp                                                       */
/* Description: Implementation of CMSWebDVD.                             */
/* Author: David Janecek                                                 */
/*************************************************************************/
#include "stdafx.h"
#include "MSDVD.h"
#include "resource.h"
#include <mpconfig.h>
#include <il21dec.h> // line 21 decoder
#include <commctrl.h>
#include "ThunkProc.h"
#include "ddrawobj.h"
#include "stdio.h"

/*************************************************************************/
/* Local constants and defines                                           */
/*************************************************************************/
const DWORD cdwDVDCtrlFlags = DVD_CMD_FLAG_Block| DVD_CMD_FLAG_Flush;
const DWORD cdwMaxFP_DOMWait = 30000; // 30sec for FP_DOM passing should be OK
const LONG cgStateTimeout = 0; // wait till the state transition occurs
                               // modify if needed

const LONG cgDVD_MIN_SUBPICTURE = 0;
const LONG cgDVD_MAX_SUBPICTURE = 31;
const LONG cgDVD_ALT_SUBPICTURE = 63;
const LONG cgDVD_MIN_ANGLE  = 0;
const LONG cgDVD_MAX_ANGLE = 9;
const double cgdNormalSpeed = 1.00;
const LONG cgDVDMAX_TITLE_COUNT = 99;
const LONG cgDVDMIN_TITLE_COUNT = 1;
const LONG cgDVDMAX_CHAPTER_COUNT = 999;
const LONG cgDVDMIN_CHAPTER_COUNT = 1;
const LONG cgTIME_STRING_LEN = 2;
const LONG cgMAX_DELIMITER_LEN = 4;
const LONG cgDVD_TIME_STR_LEN = (3*cgMAX_DELIMITER_LEN)+(4*cgTIME_STRING_LEN) + 1 /*NULL Terminator*/;
const LONG cgVOLUME_MAX = 0;
const LONG cgVOLUME_MIN = -10000;
const LONG cgBALANCE_MIN = -10000;
const LONG cgBALANCE_MAX = 10000;
const WORD cgWAVE_VOLUME_MIN = 0;
const WORD cgWAVE_VOLUME_MAX = 0xffff;

const DWORD cdwTimeout = 10; //100
const LONG  cgnStepTimeout = 100;

#define EC_DVD_PLAYING                 (EC_DVDBASE + 0xFE)
#define EC_DVD_PAUSED                  (EC_DVDBASE + 0xFF)
#define E_NO_IDVD2_PRESENT MAKE_HRESULT(SEVERITY_ERROR, FACILITY_ITF, 0xFF0)
#define E_REGION_CHANGE_FAIL MAKE_HRESULT(SEVERITY_ERROR, FACILITY_ITF, 0xFF1)
#define E_NO_DVD_VOLUME MAKE_HRESULT(SEVERITY_ERROR, FACILITY_ITF, 0xFF3)
#define E_REGION_CHANGE_NOT_COMPLETED MAKE_HRESULT(SEVERITY_ERROR, FACILITY_ITF, 0xFF4)
#define E_NO_SOUND_STREAM MAKE_HRESULT(SEVERITY_ERROR, FACILITY_ITF, 0xFF5)
#define E_NO_VIDEO_STREAM MAKE_HRESULT(SEVERITY_ERROR, FACILITY_ITF, 0xFF6)
#define E_NO_OVERLAY MAKE_HRESULT(SEVERITY_ERROR, FACILITY_ITF, 0xFF7)
#define E_NO_USABLE_OVERLAY MAKE_HRESULT(SEVERITY_ERROR, FACILITY_ITF, 0xFF8)
#define E_NO_DECODER MAKE_HRESULT(SEVERITY_ERROR, FACILITY_ITF, 0xFF9)
#define E_NO_CAPTURE_SUPPORT MAKE_HRESULT(SEVERITY_ERROR, FACILITY_ITF, 0xFFA)

#define DVD_ERROR_NoSubpictureStream    99

#if WINVER < 0x0500
typedef struct tagCURSORINFO
{
    DWORD   cbSize;
    DWORD   flags;
    HCURSOR hCursor;
    POINT   ptScreenPos;
} CURSORINFO, *PCURSORINFO, *LPCURSORINFO;

#define CURSOR_SHOWING     0x00000001
static BOOL (WINAPI *pfnGetCursorInfo)(PCURSORINFO);
typedef BOOL (WINAPI *PFNGETCURSORINFOHANDLE)(PCURSORINFO);

HRESULT CallGetCursorInfo(PCURSORINFO pci)
{
    HRESULT hr = E_FAIL;
    HINSTANCE hinstDll = ::LoadLibrary(TEXT("USER32.DLL"));

    if (hinstDll)
    {
        pfnGetCursorInfo = (PFNGETCURSORINFOHANDLE)GetProcAddress(hinstDll, "GetCursorInfo");

        if (pfnGetCursorInfo)
        {
            hr = pfnGetCursorInfo(pci);
        }

        FreeLibrary(hinstDll);
    }

    return hr;
}
#endif

GUID IID_IAMSpecifyDDrawConnectionDevice = {
            0xc5265dba,0x3de3,0x4919,{0x94,0x0b,0x5a,0xc6,0x61,0xc8,0x2e,0xf4}};

extern CComModule _Module;

/*************************************************************************/
/* Global Helper Functions                                               */
/*************************************************************************/
// helper function for converting a captured YUV image to RGB
// and saving to file.


extern HRESULT GDIConvertImageAndSave(YUV_IMAGE *lpImage, RECT *prc, HWND hwnd);
extern HRESULT ConvertImageAndSave(YUV_IMAGE *lpImage, RECT *prc, HWND hwnd);


// Helper function to calcuate max common denominator
long MCD(long i, long j) {
    if (i == j)
        return i;

    else if (i>j) {
        if (i%j == 0)
            return j;
        else
            return MCD(i%j, j);
    }

    else {
        if (j%i == 0)
            return i;
        else
            return MCD(j%i, i);
    }
}

/////////////////////////////////////////////////////////////////////////////
// CMSWebDVD

/*************************************************************************/
/* General initialization methods                                        */
/*************************************************************************/

/*************************************************************************/
/* Function: CMSWebDVD                                                 */
/*************************************************************************/
CMSWebDVD::CMSWebDVD(){

    Init();
}/* end of function CMSWebDVD */

/*************************************************************************/
/* Function: ~CMSWebDVD                                                */
/*************************************************************************/
CMSWebDVD::~CMSWebDVD(){
    
    // if we haven't been rendered or already been cleaned up
    if (!m_fInitialized){ 
        
        return;
    }/* end of if statement */

    Stop();
    Cleanup();    
    Init();
    ATLTRACE(TEXT("Inside the MSWEBDVD DESTRUCTOR!!\n"));
}/* end of function ~CMSWebDVD */

/*************************************************************************/
/* Function: Init                                                        */
/*************************************************************************/
VOID CMSWebDVD::Init(){

#if 1 // switch this to have the windowless case to be the deafult handling case
    m_bWindowOnly = TRUE; // turn on and off window only implementation
    m_fUseDDrawDirect = false;
#else
    m_bWindowOnly = FALSE;
    m_fUseDDrawDirect = true;
#endif

    m_lChapter = m_lTitle = 1;
    m_lChapterCount = NO_STOP;    
    m_clrColorKey = UNDEFINED_COLORKEY_COLOR;
    m_nReadyState = READYSTATE_LOADING;        
    m_bMute = FALSE;
    m_lLastVolume = 0;
    m_fEnableResetOnStop = FALSE; // TRUE
    m_clrBackColor = DEFAULT_BACK_COLOR; // off black used as a default key value to avoid flashing
#if 1
    m_nTTMaxWidth = 200;
    m_hWndTip = NULL;
    m_bTTCreated = FALSE;
#endif    
    m_fInitialized = false;
    m_hFPDOMEvent = NULL;
    m_fDisableAutoMouseProcessing = false;
    m_bEjected = false;
    m_fStillOn = false;    
    m_nCursorType = dvdCursor_Arrow;
    m_pClipRect = NULL;
    m_bMouseDown = FALSE;
    m_hCursor = ::LoadCursor(NULL, MAKEINTRESOURCE(OCR_ARROW_DEFAULT));
    m_dZoomRatio = 1;
    m_hWndOuter  = NULL;
    ::ZeroMemory(&m_rcOldPos, sizeof(RECT));
    m_hTimerId = NULL;
    m_fResetSpeed = true;
    m_DVDFilterState = dvdState_Undefined;
    m_lKaraokeAudioPresentationMode = 0;
    m_dwTTInitalDelay = 10;
    m_dwTTReshowDelay = 2;
    m_dwTTAutopopDelay = 10000;
    m_pDDrawDVD = NULL;
    m_dwNumDevices = 0;
    m_lpInfo = NULL;
    m_lpCurMonitor = NULL;
    m_MonitorWarn = FALSE;
    ::ZeroMemory(&m_ClipRectDown, sizeof(RECT));
    m_fStepComplete = false;
    m_bFireUpdateOverlay = FALSE;

    m_dwAspectX = 1;
    m_dwAspectY = 1;
    m_dwVideoWidth = 1;
    m_dwVideoHeight =1;

    // default overlay stretch factor x1000
    m_dwOvMaxStretch = 32000;
    m_bFireNoSubpictureStream = FALSE;

    // flags for caching decoder flags
    m_fBackWardsFlagInitialized = false;
    m_fCanStepBackwards = false;

}/* end of function Init */

/*************************************************************************/
/* Function: Cleanup                                                     */
/* Description: Releases all the interfaces.                             */
/*************************************************************************/
VOID CMSWebDVD::Cleanup(){

   m_mediaHandler.Close();

   if (m_pME){

        m_pME->SetNotifyWindow(NULL, WM_DVDPLAY_EVENT, 0) ;
        m_pME.Release() ;        
    }/* end of if statement */

    if(NULL != m_hTimerId){

        ::KillTimer(NULL, m_hTimerId);
    }/* end of if statement */

    if(NULL != m_hFPDOMEvent){

        ::CloseHandle(m_hFPDOMEvent);
        m_hFPDOMEvent = NULL;
    }/* end of if statement */

    m_pAudio.Release();
    m_pMediaSink.Release();
    m_pDvdInfo2.Release();
    m_pDvdCtl2.Release();
    m_pMC.Release();
    m_pVideoFrameStep.Release();
        
                 
    m_pGB.Release();        
    m_pDvdGB.Release();        
    m_pDDEX.Release();
    m_pDvdAdmin.Release();
        
    if (m_hCursor != NULL) {
        ::DestroyCursor(m_hCursor);
    }/* end of if statement */

    if(NULL != m_pDDrawDVD){

        delete m_pDDrawDVD;
        m_pDDrawDVD = NULL;
    }/* end of if statement */

    if(NULL != m_lpInfo){

        ::CoTaskMemFree(m_lpInfo);
        m_lpInfo = NULL;
    }/* end of if statement */

    ::ZeroMemory(&m_rcOldPos, sizeof(RECT));
}/* end of function Cleanup */

/*************************************************************************/
/* "ActiveX" methods  needed to support our interfaces                   */
/*************************************************************************/

/*************************************************************************/
/* Function: OnDraw                                                      */
/* Description: Just Draws the rectangular background.                   */
/*************************************************************************/
HRESULT CMSWebDVD::OnDraw(ATL_DRAWINFO& di){

    try {
       
        if(!m_bWndLess && m_fInitialized){
            // have to draw background only if in windowless mode or if we are not rendered yet
            
            // Get the active movie window
            HWND hwnd = ::GetWindow(m_hWnd, GW_CHILD);

            if (!::IsWindow(hwnd)){ 
    
                return S_OK;
            }/* end of if statement */

            if(::IsWindowVisible(hwnd)){

                return S_OK;
            }/* end of if statement */
        }/* end of if statement */

        HDC hdc = di.hdcDraw;

        // Not used for now
        // bool fHandled = true;

        // Paint backcolor first
        COLORREF clr;
                
        ::OleTranslateColor(m_clrBackColor, NULL, &clr);

        RECT rcClient = *(RECT*)di.prcBounds;
    
        HBRUSH hbrush = ::CreateSolidBrush(clr);

        if(NULL != hbrush){

            HBRUSH oldBrush = (HBRUSH)::SelectObject(hdc, hbrush);

            ::Rectangle(hdc, rcClient.left, rcClient.top, rcClient.right, rcClient.bottom);
            //ATLTRACE(TEXT("BackColor, %d %d %d %d\n"), rcClient.left, rcClient.top, rcClient.right, rcClient.bottom);

            ::SelectObject(hdc, oldBrush);

            ::DeleteObject(hbrush);
            hbrush = NULL;
        }/* end of if statement */
                
        // Paint color key in the video area

        if(NULL == m_pDDrawDVD){

            return(S_OK);
        }/* end of if statement */
        
        if(SUCCEEDED(AdjustDestRC())){
            RECT rcVideo = m_rcPosAspectRatioAjusted;
            rcVideo.left = rcClient.left+(RECTWIDTH(&rcClient)-RECTWIDTH(&rcVideo))/2;
            rcVideo.top = rcClient.top+(RECTHEIGHT(&rcClient)-RECTHEIGHT(&rcVideo))/2;
            rcVideo.right = rcVideo.left + RECTWIDTH(&rcVideo);
            rcVideo.bottom = rcVideo.top + RECTHEIGHT(&rcVideo);
    
            m_clrColorKey = m_pDDrawDVD->GetColorKey();
#if 1
            hbrush = ::CreateSolidBrush(::GetNearestColor(hdc, m_clrColorKey));
#else
            m_pDDrawDVD->CreateDIBBrush(m_clrColorKey, &hbrush);
#endif

            if(NULL != hbrush){

                HBRUSH oldBrush = (HBRUSH)::SelectObject(hdc, hbrush);

                ::Rectangle(hdc, rcVideo.left, rcVideo.top, rcVideo.right, rcVideo.bottom);
                //ATLTRACE(TEXT("ColorKey, %d %d %d %d\n"), rcVideo.left, rcVideo.top, rcVideo.right, rcVideo.bottom);

                ::SelectObject(hdc, oldBrush);

                ::DeleteObject(hbrush);
                hbrush = NULL;
            }/* end of if statement */
        }/* end of if statement */

        // in case we have a multimon we need to draw our warning
        HandleMultiMonPaint(hdc);
    }/* end of try statement statement */
    catch(...){
        return(0);
    }/* end of catch statement */

    return(1);
}/* end of function OnDraw */

#ifdef _WMP    
/*************************************************************************/
/* Function: InPlaceActivate                                             */
/* Description: Modified InPlaceActivate so WMP can startup.             */
/*************************************************************************/
HRESULT CMSWebDVD::InPlaceActivate(LONG iVerb, const RECT* /*prcPosRect*/){
    HRESULT hr;

    if (m_spClientSite == NULL)
        return S_OK;

    CComPtr<IOleInPlaceObject> pIPO;
    ControlQueryInterface(IID_IOleInPlaceObject, (void**)&pIPO);
    ATLASSERT(pIPO != NULL);

    if (!m_bNegotiatedWnd)
    {
        if (!m_bWindowOnly)
            // Try for windowless site
            hr = m_spClientSite->QueryInterface(IID_IOleInPlaceSiteWindowless, (void **)&m_spInPlaceSite);

        if (m_spInPlaceSite)
        {
            m_bInPlaceSiteEx = TRUE;
            // CanWindowlessActivate returns S_OK or S_FALSE
            if ( m_spInPlaceSite->CanWindowlessActivate() == S_OK )
            {
                m_bWndLess = TRUE;
                m_bWasOnceWindowless = TRUE;
            }
            else
            {
                m_bWndLess = FALSE;
            }
        }
        else
        {
            m_spClientSite->QueryInterface(IID_IOleInPlaceSiteEx, (void **)&m_spInPlaceSite);
            if (m_spInPlaceSite)
                m_bInPlaceSiteEx = TRUE;
            else
                hr = m_spClientSite->QueryInterface(IID_IOleInPlaceSite, (void **)&m_spInPlaceSite);
        }
    }

    ATLASSERT(m_spInPlaceSite);
    if (!m_spInPlaceSite)
        return E_FAIL;

    m_bNegotiatedWnd = TRUE;

    if (!m_bInPlaceActive)
    {

        BOOL bNoRedraw = FALSE;
        if (m_bWndLess)
            m_spInPlaceSite->OnInPlaceActivateEx(&bNoRedraw, ACTIVATE_WINDOWLESS);
        else
        {
            if (m_bInPlaceSiteEx)
                m_spInPlaceSite->OnInPlaceActivateEx(&bNoRedraw, 0);
            else
            {
                hr = m_spInPlaceSite->CanInPlaceActivate();
                // CanInPlaceActivate returns S_FALSE or S_OK
                if (FAILED(hr))
                    return hr;
                if ( hr != S_OK )
                {
                   // CanInPlaceActivate returned S_FALSE.
                   return( E_FAIL );
                }
                m_spInPlaceSite->OnInPlaceActivate();
            }
        }
    }

    m_bInPlaceActive = TRUE;

    // get location in the parent window,
    // as well as some information about the parent
    //
    OLEINPLACEFRAMEINFO frameInfo;
    RECT rcPos, rcClip;
    CComPtr<IOleInPlaceFrame> spInPlaceFrame;
    CComPtr<IOleInPlaceUIWindow> spInPlaceUIWindow;
    frameInfo.cb = sizeof(OLEINPLACEFRAMEINFO);
    HWND hwndParent;

    // DJ - GetParentHWND per MNnovak

    if (SUCCEEDED( GetParentHWND(&hwndParent) ))
    {
        m_spInPlaceSite->GetWindowContext(&spInPlaceFrame,
            &spInPlaceUIWindow, &rcPos, &rcClip, &frameInfo);

        if (!m_bWndLess)
        {
            if (m_hWndCD)
            {
                ::ShowWindow(m_hWndCD, SW_SHOW);
                if (!::IsChild(m_hWndCD, ::GetFocus()))
                    ::SetFocus(m_hWndCD);
            }
            else
            {
                HWND h = CreateControlWindow(hwndParent, rcPos);
                ATLASSERT(h != NULL);   // will assert if creation failed
                ATLASSERT(h == m_hWndCD);
                h;  // avoid unused warning
            }
        }

        pIPO->SetObjectRects(&rcPos, &rcClip);
    }

    CComPtr<IOleInPlaceActiveObject> spActiveObject;
    ControlQueryInterface(IID_IOleInPlaceActiveObject, (void**)&spActiveObject);

    // Gone active by now, take care of UIACTIVATE
    if (DoesVerbUIActivate(iVerb))
    {
        if (!m_bUIActive)
        {
            m_bUIActive = TRUE;
            hr = m_spInPlaceSite->OnUIActivate();
            if (FAILED(hr))
                return hr;

            SetControlFocus(TRUE);
            // set ourselves up in the host.
            //
            if (spActiveObject)
            {
                if (spInPlaceFrame)
                    spInPlaceFrame->SetActiveObject(spActiveObject, NULL);
                if (spInPlaceUIWindow)
                    spInPlaceUIWindow->SetActiveObject(spActiveObject, NULL);
            }

            if (spInPlaceFrame)
                spInPlaceFrame->SetBorderSpace(NULL);
            if (spInPlaceUIWindow)
                spInPlaceUIWindow->SetBorderSpace(NULL);
        }
    }

    m_spClientSite->ShowObject();

    return S_OK;
}/* end of function InPlaceActivate */
#endif

/*************************************************************************/
/* Function: InterfaceSupportsErrorInfo                                  */
/*************************************************************************/
STDMETHODIMP CMSWebDVD::InterfaceSupportsErrorInfo(REFIID riid){	
	static const IID* arr[] = {

		&IID_IMSWebDVD,
	};

	for (int i=0; i<sizeof(arr)/sizeof(arr[0]); i++){
		if (InlineIsEqualGUID(*arr[i], riid))
			return S_OK;
	}/* end of for loop */

	return S_FALSE;
}/* end of function InterfaceSupportsErrorInfo */

/*************************************************************************/
/* Function: OnSize                                                      */
/*************************************************************************/
LRESULT CMSWebDVD::OnSize(UINT uMsg, WPARAM /* wParam */, 
                            LPARAM lParam, BOOL& bHandled){

#ifdef _DEBUG
    if (WM_SIZING == uMsg) {
        //ATLTRACE(TEXT("WM_SIZING\n"));
    }
#endif 

    if(m_pDvdGB == NULL){
        
        return(0);
    }/* end of if statement */

    if (m_bWndLess || m_fUseDDrawDirect){

        OnResize();
    }
    else {

        IVideoWindow* pVW;

        HRESULT hr = m_pDvdGB->GetDvdInterface(IID_IVideoWindow, (LPVOID *)&pVW) ;

        if (SUCCEEDED(hr)){       
       
           LONG nWidth = LOWORD(lParam);  // width of client area 
           LONG nHeight = HIWORD(lParam); // height of client area 
       
           hr =  pVW->SetWindowPosition(0, 0, nWidth, nHeight);

           pVW->Release();
        }/* end of if statement */
    }/* end of if statement */

    bHandled = TRUE;

    return(0);
}/* end of function OnSize */

/*************************************************************************/
/* Function: OnResize                                                    */
/* Description: Handles the resizing and moving in windowless case.      */
/*************************************************************************/
HRESULT CMSWebDVD::OnResize(){

    HRESULT hr = S_FALSE;

    if (m_bWndLess || m_fUseDDrawDirect){

        RECT rc;

        hr = GetClientRectInScreen(&rc);
        
        if(FAILED(hr)){

            return(hr);
        }/* end of if statement */                
        
        if(m_pDDEX){

            hr = m_pDDEX->SetDrawParameters(m_pClipRect, &rc);
            //ATLTRACE(TEXT("SetDrawParameters\n"));
        }/* end of if statement */

        HandleMultiMonMove();

    }/* end of if statement */

    return(hr);
}/* end of function OnResize */

/*************************************************************************/
/* Function: OnErase                                                     */
/* Description: Skip the erasing to avoid flickers.                      */
/*************************************************************************/
LRESULT CMSWebDVD::OnErase(UINT, WPARAM wParam, LPARAM lParam, BOOL& bHandled){

    bHandled = TRUE;
	return 1;
}/* end of function OnErase */

/*************************************************************************/
/* Function: OnCreate                                                    */
/* Description: Sets our state to complete so we can proceed in          */
/* in initialization.                                                    */
/*************************************************************************/
LRESULT CMSWebDVD::OnCreate(UINT /* uMsg */, WPARAM /* wParam */, 
                            LPARAM lParam, BOOL& bHandled){
    
    return(0);
}/* end of function OnCreate */

/*************************************************************************/
/* Function: OnDestroy                                                   */
/* Description: Sets our state to complete so we can proceed in          */
/* in initialization.                                                    */
/*************************************************************************/
LRESULT CMSWebDVD::OnDestroy(UINT /* uMsg */, WPARAM /* wParam */, 
                            LPARAM lParam, BOOL& bHandled){

    // if we haven't been rendered
    if (!m_fInitialized){ 
        
        return 0;
    }/* end of if statement */

    Stop();
    Cleanup();
    Init();
    return(0);
}/* end of function OnCreate */

/*************************************************************************/
/* Function: GetInterfaceSafetyOptions                                   */
/* Description: For support of security model in IE                      */
/* This control is safe since it does not write to HD.                   */
/*************************************************************************/
STDMETHODIMP CMSWebDVD::GetInterfaceSafetyOptions(REFIID riid, 
                                               DWORD* pdwSupportedOptions, 
                                               DWORD* pdwEnabledOptions){

    HRESULT hr = S_OK;

	*pdwSupportedOptions = INTERFACESAFE_FOR_UNTRUSTED_CALLER | INTERFACESAFE_FOR_UNTRUSTED_DATA;

	*pdwEnabledOptions = *pdwSupportedOptions;

	return(hr);
}/* end of function GetInterfaceSafetyOptions */ 

/*************************************************************************/
/* Function: SetInterfaceSafetyOptions                                   */
/* Description: For support of security model in IE                      */
/*************************************************************************/
STDMETHODIMP CMSWebDVD::SetInterfaceSafetyOptions(REFIID riid, 
                                               DWORD /* dwSupportedOptions */, 
                                               DWORD /* pdwEnabledOptions */){

	return (S_OK);
}/* end of function SetInterfaceSafetyOptions */ 

/*************************************************************************/
/* Function: SetObjectRects                                              */
/*************************************************************************/
STDMETHODIMP CMSWebDVD::SetObjectRects(LPCRECT prcPos,LPCRECT prcClip){

#if 0
    ATLTRACE(TEXT("Resizing control prcPos->left = %d, prcPos.right = %d, prcPos.bottom =%d, prcPos.top = %d\n"),
        prcPos->left, prcPos->right, prcPos->bottom, prcPos->top); 


    ATLTRACE(TEXT("Resizing control Clip prcClip->left = %d, prcClip.right = %d, prcClip.bottom =%d, prcClip.top = %d\n"),
        prcClip->left, prcClip->right, prcClip->bottom, prcClip->top); 
#endif

    HRESULT hr = IOleInPlaceObjectWindowlessImpl<CMSWebDVD>::SetObjectRects(prcPos,prcClip);

    if(FAILED(hr)){

        return(hr);
    }/* end of if statement */

    if(!::IsWindow(m_hWnd)){

        hr = OnResize(); // need to update DDraw destination rectangle
    }/* end of if statement */

    return(hr);
}/* end of function SetObjectRects */

/*************************************************************************/
/* Function: GetParentHWND                                               */
/* Description: Gets the parent window HWND where we are operating.      */
/*************************************************************************/
HRESULT CMSWebDVD::GetParentHWND(HWND* pWnd){

    HRESULT hr = S_OK;

    IOleClientSite *pClientSite;
    IOleContainer *pContainer;
    IOleObject *pObject;

    hr = GetClientSite(&pClientSite);

    if(FAILED(hr)){

		return(hr);	
    }/* end of if statement */

    IOleWindow *pOleWindow;
    
    do {
        hr = pClientSite->QueryInterface(IID_IOleWindow, (LPVOID *) &pOleWindow);
        
        if(FAILED(hr)){
            
            return(hr);	
        }/* end of if statement */
        
        hr = pOleWindow->GetWindow((HWND*)pWnd);
        
        pOleWindow->Release();

        // if pClientSite is windowless, go get its container
        if (FAILED(hr)) {
            HRESULT hrTemp = pClientSite->GetContainer(&pContainer);
            if(FAILED(hrTemp)){
                
                return(hrTemp);	
            }/* end of if statement */
            pClientSite->Release();
            
            hrTemp = pContainer->QueryInterface(IID_IOleObject, (LPVOID*)&pObject);
            if(FAILED(hrTemp)){
                
                return(hrTemp);	
            }/* end of if statement */
            pContainer->Release();
            
            hrTemp = pObject->GetClientSite(&pClientSite);
            if(FAILED(hrTemp)){
                
                return(hrTemp);	
            }/* end of if statement */
        }
    } while (FAILED(hr));

    pClientSite->Release();
    return(hr);
}/* end of function GetParentHWND */

/*************************************************************************/
/* Function: SetReadyState                                               */
/* Description: Sets ready state and fires event if it needs to be fired */
/*************************************************************************/
HRESULT CMSWebDVD::SetReadyState(LONG lReadyState){

    HRESULT hr = S_OK;
    
    bool bFireEvent = (lReadyState != m_nReadyState);

    
#ifdef _DEBUG    
    if(m_nFreezeEvents > 0){

        ::Sleep(10);
        ATLTRACE("Container not expecting events at the moment");
    }/* end of is statement */

#endif

    if(bFireEvent){

        put_ReadyState(lReadyState);
        Fire_ReadyStateChange(lReadyState);
    }
    else {
        // set the variable
        m_nReadyState = lReadyState;
    }/* end of if statement */

    return(hr);
}/* end of function SetReadyState */

/*************************************************************************/
/* DVD methods to do with supporting DVD Playback                        */
/*************************************************************************/

/*************************************************************************/
/* Function: Render                                                      */
/* Description: Builds Graph.                                            */
/* lRender not used in curent implemetation, but might be used in the    */
/* future to denote different mode of initializations.                   */
/*************************************************************************/
STDMETHODIMP CMSWebDVD::Render(long lRender){
USES_CONVERSION;

    HRESULT hr = S_OK;

    try {

        //throw(E_NO_DECODER);

        if(m_fInitialized && ((dvdRender_Reinitialize & lRender) != dvdRender_Reinitialize)){
            
            ATLTRACE(TEXT("Graph was already initialized\n"));
            throw(S_FALSE);
        }/* end of if statement */

        Cleanup(); // release all the interfaces so we start from ground up
        //Init();    // initialize the variables

        m_fInitialized = false; // set the flag that we are not initialized in
        // case if something goes wrong

        // create an event that lets us know we are past FP_DOM
        m_hFPDOMEvent = ::CreateEvent(NULL, TRUE, FALSE, NULL);
        ATLASSERT(m_hFPDOMEvent);

        hr = ::CoCreateInstance(CLSID_DvdGraphBuilder, NULL, CLSCTX_INPROC, 
		    IID_IDvdGraphBuilder, (LPVOID *)&m_pDvdGB) ;

        if (FAILED(hr) || !m_pDvdGB){

    #ifdef _DEBUG
            ::MessageBox(::GetFocus(), TEXT("DirectShow DVD software not installed properly.\nPress OK to end the app."), 
                    TEXT("Error"), MB_OK | MB_ICONSTOP) ;
    #endif

            throw(hr);
        }/* end of if statement */
		
		/* Force NonExclMode (in other words: use Overlay Mixer and NOT VMR) */
		GUID IID_IDDrawNonExclModeVideo = {0xec70205c,0x45a3,0x4400,{0xa3,0x65,0xc4,0x47,0x65,0x78,0x45,0xc7}};
		
		// Set DDraw object and surface on DVD graph builder before starting to build graph    
		hr = m_pDvdGB->GetDvdInterface(IID_IDDrawNonExclModeVideo, (LPVOID *)&m_pDDEX) ;
		if (FAILED(hr) || !m_pDDEX){
			
			ATLTRACE(TEXT("ERROR: IDvdGB::GetDvdInterface(IDDrawExclModeVideo) \n"));
			ATLTRACE(TEXT("The QDVD.DLL does not support IDvdInfo2 or IID_IDvdControl2, please update QDVD.DLL\n"));
			throw(E_NO_IDVD2_PRESENT);                
		}/* end of if statement */

        if (m_bWndLess || m_fUseDDrawDirect){

            hr = SetupDDraw();

            if(FAILED(hr)){

                throw(hr);
            }/* end of if statement */

            hr = m_pDDrawDVD->HasOverlay();

            if(FAILED(hr)){

                throw(hr);
            }/* end of if statement */
            
            if(S_FALSE == hr){

                throw(E_NO_OVERLAY);
            }/* end of if statement */

            hr = m_pDDrawDVD->HasAvailableOverlay();

            if(FAILED(hr)){

                throw(hr);
            }/* end of if statement */

            hr = m_pDDrawDVD->GetOverlayMaxStretch(&m_dwOvMaxStretch);

            if(FAILED(hr)){

                throw(hr);
            }/* end of if statement */

            if(S_FALSE == hr){

                throw(E_NO_USABLE_OVERLAY);
            }/* end of if statement */

            hr = m_pDDEX->SetDDrawObject(m_pDDrawDVD->GetDDrawObj());

            if (FAILED(hr)){

                ATLTRACE(TEXT("ERROR: IDDrawExclModeVideo::SetDDrawObject()"));
                m_pDDEX.Release() ;  // release before returning
                throw(hr);
            }/* end of if statement */

            hr = m_pDDEX->SetDDrawSurface(m_pDDrawDVD->GetDDrawSurf()); // have to set the surface if NOT the IDDExcl complains    

            if (FAILED(hr)){

                m_pDDEX.Release() ;  // release before returning
                throw(hr);
            }/* end of if statement */

             //OnResize(); // set the DDRAW RECTS, we are doing it in the thread
#if 1
            hr = m_pDDEX->SetCallbackInterface(m_pDDrawDVD->GetCallbackInterface(), 0) ;
            if (FAILED(hr))
            {

                throw(hr);
            }/* end of it statement */
#endif

        }/* end of if statement */        
    
        DWORD dwRenderFlag = AM_DVD_HWDEC_PREFER; // use the hardware if possible
        AM_DVD_RENDERSTATUS  amDvdStatus;
        //Completes building a filter graph according to user specifications for 
        // playing back a default DVD-Video volume
        hr = m_pDvdGB->RenderDvdVideoVolume(NULL, dwRenderFlag, &amDvdStatus);
                
        if (FAILED(hr)){

#ifdef _DEBUG
            TCHAR  strError[1000];
            AMGetErrorText(hr, strError, sizeof(strError)) ;
            ::MessageBox(::GetFocus(), strError, TEXT("Error"), MB_OK) ;
#endif
            if(VFW_E_DVD_DECNOTENOUGH == hr){

                throw(E_NO_DECODER);
            }/* end of if statement */

            throw(hr);
        }/* end of if statement */

        HRESULT hrTmp = m_pDvdGB->GetDvdInterface(IID_IDvdControl2, (LPVOID *)&m_pDvdCtl2) ;

        if(FAILED(hrTmp)){

            ATLTRACE(TEXT("The QDVD.DLL does not support IDvdInfo2 or IID_IDvdControl2, please update QDVD.DLL\n"));
            throw(E_NO_IDVD2_PRESENT);
        }/* end of if statement */

        if (hr == S_FALSE){  // if partial success
           
            if((dvdRender_Error_On_Missing_Drive & lRender) && amDvdStatus.bDvdVolInvalid || amDvdStatus.bDvdVolUnknown){

#if 0
                TCHAR filename[MAX_PATH];
                if (OpenIFOFile(::GetDesktopWindow(), filename)){

                    USES_CONVERSION;

                    if(!m_pDvdCtl2){
            
                        throw (E_UNEXPECTED);
                    }/* end of if statement */

                    hr = m_pDvdCtl2->SetDVDDirectory(T2W(filename));                    
                }
                else{

                    hr = E_NO_DVD_VOLUME;
                }/* end of if statement */
#else
                hr = E_NO_DVD_VOLUME;
#endif

                if(FAILED(hr)){

                    throw(E_NO_DVD_VOLUME);
                }/* end of if statement */
            }/* end of if statement */

            // improve your own error handling
            if(amDvdStatus.bNoLine21Out != NULL){ // we do not care about the caption
            
    #ifdef _DEBUG
                if (::MessageBox(::GetFocus(), TEXT(" Line 21 has failed Do you still want to continue?"), TEXT("Warning"), MB_YESNO) == IDNO){
                    throw(E_FAIL);
                }/* end of if statement */
    #endif
            }/* end of if statement */
            
            if((amDvdStatus.iNumStreamsFailed > 0) && ((amDvdStatus.dwFailedStreamsFlag & AM_DVD_STREAM_VIDEO) == AM_DVD_STREAM_VIDEO)){

                throw(E_NO_VIDEO_STREAM);
            }/* end of if statement */
            // handeling this below

            if((amDvdStatus.iNumStreamsFailed > 0) && ((amDvdStatus.dwFailedStreamsFlag & AM_DVD_STREAM_SUBPIC) == AM_DVD_STREAM_SUBPIC)){
#if 0                
                TCHAR strBuffer1[MAX_PATH];
                if(!::LoadString(_Module.m_hInstResource, IDS_E_NO_SUBPICT_STREAM, strBuffer1, MAX_PATH)){

                    throw(E_UNEXPECTED);
                }/* end of if statement */

                TCHAR strBuffer2[MAX_PATH];
                if(!::LoadString(_Module.m_hInstResource, IDS_WARNING, strBuffer2, MAX_PATH)){

                    throw(E_UNEXPECTED);
                }/* end of if statement */

                ::MessageBox(::GetFocus(), strBuffer1, strBuffer2, MB_OK);    
#else
                // Will bubble up the error to the app
                m_bFireNoSubpictureStream = TRUE;
#endif
            }/* end of if statement */
        }/* end of if statement */

        // Now get all the interfaces to playback the DVD-Video volume
        hr = m_pDvdGB->GetFiltergraph(&m_pGB) ;
    
        if(FAILED(hr)){

            throw(hr);
        }/* end of if statement */

        hr = m_pGB->QueryInterface(IID_IMediaControl, (LPVOID *)&m_pMC) ;

        if(FAILED(hr)){

            throw(hr);
        }/* end of if statement */

         hr = m_pGB->QueryInterface(IID_IVideoFrameStep, (LPVOID *)&m_pVideoFrameStep);

        if(FAILED(hr)){

            // do not bail out, since frame stepping is not that important
            ATLTRACE(TEXT("Frame stepping QI failed"));
            ATLASSERT(FALSE);
        }/* end of if statement */

        hr = m_pGB->QueryInterface(IID_IMediaEventEx, (LPVOID *)&m_pME) ;

        if(FAILED(hr)){

            throw(hr);
        }/* end of if statement */

        IVideoWindow* pVW = NULL;

        if (!m_bWndLess){
    
            //
            // Also set up the event notification so that the main window gets
            // informed about all that we care about during playback.
            //
            // HAVE THREAD !!!

            INT iCount = 0;

            while(m_hWnd == NULL){


                if(iCount >10) break;

                ::Sleep(100);
                iCount ++;
            }/* end of while loop */

            if(m_hWnd == NULL){

                ATLTRACE(TEXT("Window is not active as of yet\n returning with E_PENDING\n"));
                hr = E_PENDING;
                throw(hr);
            }/* end of if statement */
            
	        hr = m_pME->SetNotifyWindow((OAHWND) m_hWnd, WM_DVDPLAY_EVENT, 0);
        
            if(FAILED(hr)){

                throw(hr);
            }/* end of if statement */

            if(!m_fUseDDrawDirect){
        
                hr = m_pDvdGB->GetDvdInterface(IID_IVideoWindow, (LPVOID *)&pVW) ;

                if(FAILED(hr)){
                  
                    throw(hr);
                }/* end of if statement */
        

                hr = pVW->put_MessageDrain((OAHWND)m_hWnd); // get our mouse messages over

                if(FAILED(hr)){

                    throw(hr);
                }/* end of if statement */
            }/* end of if statement */
        }
        else {
            // create the timer which will keep us updated
            
            m_hTimerId = ::SetTimer(NULL, 0, cdwTimeout, GetTimerProc());        
        }/* end of if statement */
                
        hr = m_pDvdGB->GetDvdInterface(IID_IDvdInfo2, (LPVOID *)&m_pDvdInfo2) ;

        if(FAILED(hr)){
            
            ATLTRACE(TEXT("The QDVD.DLL does not support IDvdInfo2 or IID_IDvdControl2, please update QDVD.DLL\n"));
            throw(E_NO_IDVD2_PRESENT);
        }/* end of if statement */
        
	    hr = SetupAudio();

        if(FAILED(hr)){

#if 1
            throw(E_NO_SOUND_STREAM);
#else
            TCHAR strBuffer1[MAX_PATH];
            if(!::LoadString(_Module.m_hInstResource, IDS_E_NO_SOUND_STREAM, strBuffer1, MAX_PATH)){

                throw(E_UNEXPECTED);
            }/* end of if statement */

            TCHAR strBuffer2[MAX_PATH];
            if(!::LoadString(_Module.m_hInstResource, IDS_WARNING, strBuffer2, MAX_PATH)){

                throw(E_UNEXPECTED);
            }/* end of if statement */

            ::MessageBox(::GetFocus(), strBuffer1, strBuffer2, MB_OK);
#endif            
        }/* end of if statement */

        hr = SetupEventNotifySink();

        #ifdef _DEBUG
            if(FAILED(hr)){
		        ATLTRACE(TEXT("Failed to setup event notify sink\n"));     
            }/* end of if statement */
        #endif

        if (!m_bWndLess && !m_fUseDDrawDirect){
            // set the window position and style
            hr =  pVW->put_Owner((OAHWND)m_hWnd); 

            RECT rc;
            ::GetWindowRect(m_hWnd, &rc);

            hr =  pVW->SetWindowPosition(0, 0, WIDTH(&rc), HEIGHT(&rc));

            LONG lStyle = GetWindowLong(GWL_STYLE);
            hr = pVW->put_WindowStyle(lStyle);
            lStyle = GetWindowLong(GWL_EXSTYLE);
            hr = pVW->put_WindowStyleEx(lStyle);

             pVW->Release();
        }/* end of if statement */

        bool fSetColorKey = false; // flag so we do not duplicate code, and simplify logic

        // case when windowless and  color key is not defined
        // then in that case get the color key from the OV mixer 
        if(m_bWndLess || m_fUseDDrawDirect){

            COLORREF clr;
            hrTmp = GetColorKey(&clr); 

            if(FAILED(hrTmp)){
#ifdef _DEBUG
                ::MessageBox(::GetFocus(), TEXT("failed to get color key"), TEXT("error"), MB_OK);
#endif
                
                throw(hrTmp);
            }/* end of if statement */
            
            if((m_clrColorKey & UNDEFINED_COLORKEY_COLOR) == UNDEFINED_COLORKEY_COLOR) {

                    m_clrColorKey = clr;
            }/* end of if statement */

            else if (clr != m_clrColorKey) {
                fSetColorKey = true;
            }

        }/* end of if statement */

        // case when color key is defined
        // if windowless set the background color at the same time
        if(fSetColorKey){

            hrTmp = put_ColorKey(m_clrColorKey);            
            
    #ifdef _DEBUG
                if(FAILED(hrTmp)){

                    ::MessageBox(::GetFocus(), TEXT("failed to set color key"), TEXT("error"), MB_OK);
                    throw(E_FAIL);
                }/* end of if statement */
    #endif                            
        }/* end of if statement */

        m_fInitialized = true;

        // turn off the closed caption. it is turned on by default
        // this code should be in the DVDNav!
        put_CCActive(VARIANT_FALSE);

        // Create the DVD administrator and set player level
        m_pDvdAdmin = new CComObject<CMSDVDAdm>;
        //m_pDvdAdmin.AddRef();        
        if(!m_pDvdAdmin){
            return E_UNEXPECTED;
        }
        RestoreDefaultSettings();       


        // disc eject and insert handler
        BSTR bstrRoot;
        hr = get_DVDDirectory(&bstrRoot);

        if (SUCCEEDED(hr)) {
            TCHAR *szRoot;
            szRoot = OLE2T(bstrRoot);
            m_mediaHandler.SetDrive(szRoot[0] );
            m_mediaHandler.SetDVD(this);
            m_mediaHandler.Open();
        }

        
        hr = m_pDvdCtl2->SetOption( DVD_HMSF_TimeCodeEvents, TRUE);

    }/* end of try statement */
    catch(HRESULT hrTmp){

        hr = hrTmp;
    }/* end of catch statement */
    catch(...){

        hr = E_UNEXPECTED;
    }/* end of catch statement */
    
    return HandleError(hr);
}/* end of function Render */

/*************************************************************************/
/* Function: Play                                                        */
/* Description: Puts the DVDNav in the run mode.                         */
/*************************************************************************/
STDMETHODIMP CMSWebDVD::Play(){

    HRESULT hr = S_OK;

    try {

        INITIALIZE_GRAPH_IF_NEEDS_TO_BE 

        if(!m_pMC){
            
            throw(E_UNEXPECTED);
        }/* end of if statement */

        if(!m_pDvdCtl2 ){
            
            throw(E_UNEXPECTED);
        }/* end of if statement */                

        OAFilterState state;

        hr = m_pMC->GetState(cgStateTimeout, &state);

        m_DVDFilterState = (DVDFilterState) state; // save the state so we can restore it if an API fails        

        if(FAILED(hr)){

            throw(hr);
        }/* end of if statement */

        bool bFireEvent = false;  // fire event only when we change the state

        if(state != dvdState_Running){

            bFireEvent = true;

            // disable the stop in case CTRL+ALT+DEL
            if(state == dvdState_Stopped){

                if(FALSE == m_fEnableResetOnStop){
                
                    hr = m_pDvdCtl2->SetOption(DVD_ResetOnStop, FALSE);

                    if(FAILED(hr)){

                        throw(hr);
                    }/* end of if statement */
                }/* end of if statement */
            }/* end of if statement */

	        hr = m_pMC->Run();  // put it into running state just in case we are not in the running 
                                // state
            if(FAILED(hr)){

                throw(hr);
            }/* end of if statement */
        }/* end of if statement */             
        
        if(bFireEvent && m_pMediaSink){

            m_pMediaSink->Notify(EC_DVD_PLAYING, 0, 0);
        }/* end of if statement */                
    
        // not collect hr
#ifdef _DEBUG
        if(m_fStillOn){

            ATLTRACE(TEXT("Not reseting the speed to 1.0 \n"));
        }/* end of if statement */
#endif
        if(false == m_fStillOn && true == m_fResetSpeed){

            // if we are in the still do not reset the speed            
            m_pDvdCtl2->PlayForwards(cgdNormalSpeed,0,0);
        }/* end of if statement */
        
    }/* end of try statement */
    catch(HRESULT hrTmp){
        hr = hrTmp;
    }/* end of catch statement */
    catch(...){
        hr = E_UNEXPECTED;
    }/* end of catch statement */

	return HandleError(hr);
}/* end of function Play */

/*************************************************************************/
/* Function: Pause                                                       */
/* Description: Pauses the filter graph just only in the case when stat  */
/* would not indicate that it was paused.                                */
/*************************************************************************/
STDMETHODIMP CMSWebDVD::Pause(){

	HRESULT hr = S_OK;

    try {
        INITIALIZE_GRAPH_IF_NEEDS_TO_BE

        if(!m_pMC){
            
            throw(E_UNEXPECTED);
        }/* end of if statement */

        OAFilterState state;

        hr = m_pMC->GetState(cgStateTimeout, &state);

        if(FAILED(hr)){

            throw(hr);
        }/* end of if statement */

        bool bFireEvent = false;  // fire event only when we change the state

        if(state != dvdState_Paused){

            bFireEvent = true;

	        hr = m_pMC->Pause();  // put it into running state just in case we are not in the running 
                                  // state
            if(FAILED(hr)){

                throw(hr);
            }/* end of if statement */

        }/* end of if statement */
#if 1
        // Fired our own paused event
        if(bFireEvent && m_pMediaSink){

            m_pMediaSink->Notify(EC_DVD_PAUSED, 0, 0);
        }/* end of if statement */                
#endif 

    }/* end of try statement */
    catch(HRESULT hrTmp){
        hr = hrTmp;
    }/* end of catch statement */
    catch(...){
        hr = E_UNEXPECTED;
    }/* end of catch statement */

	return HandleError(hr);
}/* end of function Pause */

/*************************************************************************/
/* Function: Stop                                                        */
/* Description: Stops the filter graph if the state does not indicate    */
/* it was stopped.                                                       */
/*************************************************************************/
STDMETHODIMP CMSWebDVD::Stop(){

	HRESULT hr = S_OK;

    try {

        if(!m_pMC){
            
            throw(E_UNEXPECTED);
        }/* end of if statement */

        if(!m_pDvdCtl2){

            return(E_UNEXPECTED);
        }/* end of if statement */

        OAFilterState state;

        hr = m_pMC->GetState(cgStateTimeout, &state);

        if(FAILED(hr)){

            throw(hr);
        }/* end of if statement */

        if(state != dvdState_Stopped){

            if(FALSE == m_fEnableResetOnStop){
                
                hr = m_pDvdCtl2->SetOption(DVD_ResetOnStop, TRUE);

                if(FAILED(hr)){

                    throw(hr);
                }/* end of if statement */
            }/* end of if statement */

	        hr = m_pMC->Stop();  // put it into running state just in case we are not in the running 
                                  // state
        }/* end of if statement */
    }/* end of try statement */
    catch(HRESULT hrTmp){
        hr = hrTmp;
    }/* end of catch statement */
    catch(...){
        hr = E_UNEXPECTED;
    }/* end of catch statement */

	return HandleError(hr);
}/* end of function Stop */

/*************************************************************************/
/* Function: OnDVDEvent                                                  */
/* Description: Handles the DVD events                                   */
/*************************************************************************/
LRESULT CMSWebDVD::OnDVDEvent(UINT /* uMsg */, WPARAM wParam, LPARAM lParam, BOOL& bHandled){

    if (m_bFireUpdateOverlay == TRUE) {
        if (m_fInitialized) {
            m_bFireUpdateOverlay = FALSE;
            Fire_UpdateOverlay();
        }
    }

    LONG        lEvent ;
    LONG_PTR    lParam1, lParam2 ;

    if (m_bFireNoSubpictureStream) {
        m_bFireNoSubpictureStream = FALSE;
        lEvent = EC_DVD_ERROR;
        lParam1 = DVD_ERROR_NoSubpictureStream;
        lParam2 = 0;
        VARIANT varLParam1;
        VARIANT varLParam2;

#ifdef _WIN64
        varLParam1.llVal = lParam1;
        varLParam1.vt = VT_I8;
        varLParam2.llVal = lParam2;
        varLParam2.vt = VT_I8;
#else
        varLParam1.lVal = lParam1;
        varLParam1.vt = VT_I4;
        varLParam2.lVal = lParam2;
        varLParam2.vt = VT_I4;
#endif

        // fire the event now after we have processed it internally
        Fire_DVDNotify(lEvent, varLParam1, varLParam2);
    }

    bHandled = TRUE;

    //
    //  Because the message mode for IMediaEvent may not be set before
    //  we get the first event it's important to read all the events
    //  pending when we get a window message to say there are events pending.
    //  GetEvent() returns E_ABORT when no more event is left.
    //
    while (m_pME && SUCCEEDED(m_pME->GetEvent(&lEvent, &lParam1, &lParam2, 0))){

        switch (lEvent){
            //
            // First the DVD error events
            //
            case EC_DVD_ERROR:
                switch (lParam1){

                case DVD_ERROR_Unexpected:
#ifdef _DEBUG
                    ::MessageBox(::GetFocus(),
                        TEXT("An unexpected error (possibly incorrectly authored content)")
                        TEXT("\nwas encountered.")
                        TEXT("\nCan't playback this DVD-Video disc."),
                        TEXT("Error"), MB_OK | MB_ICONINFORMATION) ;
#endif
                    //m_pMC->Stop() ;
                    break ;

                case DVD_ERROR_CopyProtectFail:
#ifdef _DEBUG
                    ::MessageBox(::GetFocus(),
                        TEXT("Key exchange for DVD copy protection failed.")
                        TEXT("\nCan't playback this DVD-Video disc."),
                        TEXT("Error"), MB_OK | MB_ICONINFORMATION) ;
#endif
                    //m_pMC->Stop() ;
                    break ;

                case DVD_ERROR_InvalidDVD1_0Disc:
#ifdef _DEBUG
                    ::MessageBox(::GetFocus(),
                        TEXT("This DVD-Video disc is incorrectly authored for v1.0  of the spec.")
                        TEXT("\nCan't playback this disc."),
                        TEXT("Error"), MB_OK | MB_ICONINFORMATION) ;
#endif
                    //m_pMC->Stop() ;
                    break ;

                case DVD_ERROR_InvalidDiscRegion:
#ifdef _DEBUG
                    ::MessageBox(::GetFocus(),
                        TEXT("This DVD-Video disc cannot be played, because it is not")
                        TEXT("\nauthored to play in the current system region.")
                        TEXT("\nThe region mismatch may be fixed by changing the")
                        TEXT("\nsystem region (with DVDRgn.exe)."),
                        TEXT("Error"), MB_OK | MB_ICONINFORMATION) ;
#endif
                    Stop();
                    // fire the region change dialog                    
                    RegionChange();
                    break ;

                case DVD_ERROR_LowParentalLevel:
#ifdef _DEBUG
                    ::MessageBox(::GetFocus(),
                        TEXT("Player parental level is set lower than the lowest parental")
                        TEXT("\nlevel available in this DVD-Video content.")
                        TEXT("\nCannot playback this DVD-Video disc."),
                        TEXT("Error"), MB_OK | MB_ICONINFORMATION) ;
#endif
                    //m_pMC->Stop() ;
                    break ;

                case DVD_ERROR_MacrovisionFail:
#ifdef _DEBUG
                    ::MessageBox(::GetFocus(),
                        TEXT("This DVD-Video content is protected by Macrovision.")
                        TEXT("\nThe system does not satisfy Macrovision requirement.")
                        TEXT("\nCan't continue playing this disc."),
                        TEXT("Error"), MB_OK | MB_ICONINFORMATION) ;
#endif
                    //m_pMC->Stop() ;
                    break ;

                case DVD_ERROR_IncompatibleSystemAndDecoderRegions:
#ifdef _DEBUG
                    ::MessageBox(::GetFocus(),
                        TEXT("No DVD-Video disc can be played on this system, because ")
                        TEXT("\nthe system region does not match the decoder region.")
                        TEXT("\nPlease contact the manufacturer of this system."),
                        TEXT("Error"), MB_OK | MB_ICONINFORMATION) ;
#endif
                    //m_pMC->Stop() ;
                    break ;

                case DVD_ERROR_IncompatibleDiscAndDecoderRegions:
#ifdef _DEBUG
                    ::MessageBox(::GetFocus(),
                        TEXT("This DVD-Video disc cannot be played on this system, because it is")
                        TEXT("\nnot authored to be played in the installed decoder's region."),
                        TEXT("Error"), MB_OK | MB_ICONINFORMATION) ;
#endif
                    //m_pMC->Stop() ;
                    break ;
                }/* end of switch case */
                break ;

            //
            // Next the normal DVD related events
            //
            case EC_DVD_VALID_UOPS_CHANGE:
            {
                VALID_UOP_SOMTHING_OR_OTHER validUOPs = (DWORD) lParam1;
                if (validUOPs&UOP_FLAG_Play_Title_Or_AtTime) {
                    Fire_PlayAtTimeInTitle(VARIANT_FALSE);
                    Fire_PlayAtTime(VARIANT_FALSE);
                }
                else {
                    Fire_PlayAtTimeInTitle(VARIANT_TRUE);
                    Fire_PlayAtTime(VARIANT_TRUE);
                }
                    
                if (validUOPs&UOP_FLAG_Play_Chapter) {
                    Fire_PlayChapterInTitle(VARIANT_FALSE);
                    Fire_PlayChapter(VARIANT_FALSE);
                }
                else {
                    Fire_PlayChapterInTitle(VARIANT_TRUE);
                    Fire_PlayChapter(VARIANT_TRUE);
                }

                if (validUOPs&UOP_FLAG_Play_Title){
                    Fire_PlayTitle(VARIANT_FALSE);
                    
                }
                else {
                    Fire_PlayTitle(VARIANT_TRUE);
                }

                if (validUOPs&UOP_FLAG_Stop)
                    Fire_Stop(VARIANT_FALSE);
                else
                    Fire_Stop(VARIANT_TRUE);

                if (validUOPs&UOP_FLAG_ReturnFromSubMenu)
                    Fire_ReturnFromSubmenu(VARIANT_FALSE);
                else
                    Fire_ReturnFromSubmenu(VARIANT_TRUE);

                
                if (validUOPs&UOP_FLAG_Play_Chapter_Or_AtTime) {
                    Fire_PlayAtTimeInTitle(VARIANT_FALSE);
                    Fire_PlayChapterInTitle(VARIANT_FALSE);
                }
                else {
                    Fire_PlayAtTimeInTitle(VARIANT_TRUE);
                    Fire_PlayChapterInTitle(VARIANT_TRUE);
                }

                if (validUOPs&UOP_FLAG_PlayPrev_Or_Replay_Chapter){

                    Fire_PlayPrevChapter(VARIANT_FALSE);
                    Fire_ReplayChapter(VARIANT_FALSE);
                }                    
                else {
                    Fire_PlayPrevChapter(VARIANT_TRUE);
                    Fire_ReplayChapter(VARIANT_TRUE);
                }/* end of if statement */

                if (validUOPs&UOP_FLAG_PlayNext_Chapter)
                    Fire_PlayNextChapter(VARIANT_FALSE);
                else
                    Fire_PlayNextChapter(VARIANT_TRUE);

                if (validUOPs&UOP_FLAG_Play_Forwards)
                    Fire_PlayForwards(VARIANT_FALSE);
                else
                    Fire_PlayForwards(VARIANT_TRUE);
                
                if (validUOPs&UOP_FLAG_Play_Backwards)
                    Fire_PlayBackwards(VARIANT_FALSE);
                else 
                    Fire_PlayBackwards(VARIANT_TRUE);
                                
                if (validUOPs&UOP_FLAG_ShowMenu_Title) 
                    Fire_ShowMenu(dvdMenu_Title, VARIANT_FALSE);
                else 
                    Fire_ShowMenu(dvdMenu_Title, VARIANT_TRUE);
                    
                if (validUOPs&UOP_FLAG_ShowMenu_Root) 
                    Fire_ShowMenu(dvdMenu_Root, VARIANT_FALSE);
                else
                    Fire_ShowMenu(dvdMenu_Root, VARIANT_TRUE);
                
                //TODO: Add the event for specific menus
                
                if (validUOPs&UOP_FLAG_ShowMenu_SubPic)
                    Fire_ShowMenu(dvdMenu_Subpicture, VARIANT_FALSE);
                else
                    Fire_ShowMenu(dvdMenu_Subpicture, VARIANT_TRUE);
                
                if (validUOPs&UOP_FLAG_ShowMenu_Audio)
                    Fire_ShowMenu(dvdMenu_Audio, VARIANT_FALSE);
                else
                    Fire_ShowMenu(dvdMenu_Audio, VARIANT_TRUE);
                    
                if (validUOPs&UOP_FLAG_ShowMenu_Angle)
                    Fire_ShowMenu(dvdMenu_Angle, VARIANT_FALSE);
                else
                    Fire_ShowMenu(dvdMenu_Angle, VARIANT_TRUE);

                    
                if (validUOPs&UOP_FLAG_ShowMenu_Chapter)
                    Fire_ShowMenu(dvdMenu_Chapter, VARIANT_FALSE);
                else
                    Fire_ShowMenu(dvdMenu_Chapter, VARIANT_TRUE);

                
                if (validUOPs&UOP_FLAG_Resume)
                    Fire_Resume(VARIANT_FALSE);
                else
                    Fire_Resume(VARIANT_TRUE);
                
                if (validUOPs&UOP_FLAG_Select_Or_Activate_Button)
                    Fire_SelectOrActivatButton(VARIANT_FALSE);
                else 
                    Fire_SelectOrActivatButton(VARIANT_TRUE);
                
                if (validUOPs&UOP_FLAG_Still_Off)
                    Fire_StillOff(VARIANT_FALSE);
                else
                    Fire_StillOff(VARIANT_TRUE);

                if (validUOPs&UOP_FLAG_Pause_On)
                    Fire_PauseOn(VARIANT_FALSE);
                else
                    Fire_PauseOn(VARIANT_TRUE);

                if (validUOPs&UOP_FLAG_Select_Audio_Stream)
                    Fire_ChangeCurrentAudioStream(VARIANT_FALSE);
                else
                    Fire_ChangeCurrentAudioStream(VARIANT_TRUE);
                
                if (validUOPs&UOP_FLAG_Select_SubPic_Stream)
                    Fire_ChangeCurrentSubpictureStream(VARIANT_FALSE);
                else
                    Fire_ChangeCurrentSubpictureStream(VARIANT_TRUE);
                
                if (validUOPs&UOP_FLAG_Select_Angle)
                    Fire_ChangeCurrentAngle(VARIANT_FALSE);
                else
                    Fire_ChangeCurrentAngle(VARIANT_TRUE);

                /*
                if (validUOPs&UOP_FLAG_Karaoke_Audio_Pres_Mode_Change)
                    ;
                if (validUOPs&UOP_FLAG_Video_Pres_Mode_Change)
                    ;
                */
                }
                break;
            case EC_DVD_STILL_ON:
		    m_fStillOn = true;    
            break ;

            case EC_DVD_STILL_OFF:                
            m_fStillOn = false;
            break ;

            case EC_DVD_DOMAIN_CHANGE:
                
                switch (lParam1){

                    case DVD_DOMAIN_FirstPlay: // = 1
                    //case DVD_DOMAIN_VideoManagerMenu:  // = 2
                        if(m_hFPDOMEvent){
                        // whenever we enter FP Domain we reset
                            ::ResetEvent(m_hFPDOMEvent);
                        }
                        else {
                            ATLTRACE(TEXT("No event initialized bug!!"));
                            ATLASSERT(FALSE);
                        }/* end of if statement */
                        break;

                    case DVD_DOMAIN_Stop:       // = 5
                    case DVD_DOMAIN_VideoManagerMenu:  // = 2                    
                    case DVD_DOMAIN_VideoTitleSetMenu: // = 3
                    case DVD_DOMAIN_Title:      // = 4
                    default:
                        if(m_hFPDOMEvent){
                         // whenever we get out of the FP Dom Set our state
                            ::SetEvent(m_hFPDOMEvent);
                        }
                        else {
                            ATLTRACE(TEXT("No event initialized bug!!"));
                            ATLASSERT(FALSE);
                        }/* end of if statement */
                        break;
                }/* end of switch case */
                break ;

            case EC_DVD_BUTTON_CHANGE:                       
                break;
    
            case EC_DVD_TITLE_CHANGE:                
                break ;

            case EC_DVD_CHAPTER_START:              
                break ;

            case EC_DVD_CURRENT_TIME: 
                //ATLTRACE(TEXT("Time event \n"));
                break;
            /**************
                DVD_TIMECODE *pTime = (DVD_TIMECODE *) &lParam1 ;
                wsprintf(m_achTimeText, TEXT("Current Time is  %d%d:%d%d:%d%d"),
                        pTime->Hours10, pTime->Hours1,
                        pTime->Minutes10, pTime->Minutes1,
                        pTime->Seconds10, pTime->Seconds1) ;
                InvalidateRect(m_hWnd, NULL, TRUE) ;
            ************************/

            case EC_DVD_CURRENT_HMSF_TIME: 
                //ATLTRACE(TEXT("New Time event \n"));                
                break;            

            //
            // Then the general DirectShow related events
            //
            case EC_COMPLETE:
            case EC_DVD_PLAYBACK_STOPPED:
                Stop() ;  // DShow doesn't stop on end; we should do that
                break;
                // fall through now...

            case EC_USERABORT:
            case EC_ERRORABORT:
            case EC_FULLSCREEN_LOST:
                //TO DO: Implement StopFullScreen() ;  // we must get out of fullscreen mode now
                break ;

            case EC_DVD_DISC_EJECTED:
                m_bEjected = true;
                break;
            case EC_DVD_DISC_INSERTED:
                m_bEjected = false;
                break;

            case EC_STEP_COMPLETE:                
                m_fStepComplete = true;
                break;

            default:
                break ;
        }/* end of switch case */

        // update for win64 since DShow uses now LONGLONG
        
        VARIANT varLParam1;
        VARIANT varLParam2;

#ifdef _WIN64
        varLParam1.llVal = lParam1;
        varLParam1.vt = VT_I8;
        varLParam2.llVal = lParam2;
        varLParam2.vt = VT_I8;
#else
        varLParam1.lVal = lParam1;
        varLParam1.vt = VT_I4;
        varLParam2.lVal = lParam2;
        varLParam2.vt = VT_I4;
#endif

        // fire the event now after we have processed it internally
        Fire_DVDNotify(lEvent, varLParam1, varLParam2);

        //
        // Remember to free the event params
        //
        m_pME->FreeEventParams(lEvent, lParam1, lParam2) ;

    }/* end of while loop  */

    return 0 ;
}/* end of function OnDVDEvent */

/*************************************************************************/
/* Function: OnButtonDown                                                */
/* Description: Selects the button.                                      */
/*************************************************************************/
LRESULT CMSWebDVD::OnButtonDown(UINT, WPARAM wParam, LPARAM lParam, BOOL& bHandled){

    try {
        if(!m_fInitialized){

            return(0);
        }/* end of if statement */

        m_bMouseDown = TRUE;
        RECT rc;

        HWND hwnd;
        
        if(m_bWndLess){
            HRESULT hr = GetParentHWND(&hwnd);
            
            if(FAILED(hr)){
                
                return(hr);
            }/* end of if statement */

            rc = m_rcPos;
        }
        else {
            hwnd = m_hWnd;
            ::GetClientRect(hwnd, &rc);
        }/* end of if statement */
        
        if(::IsWindow(hwnd)){
            
            ::MapWindowPoints(hwnd, ::GetDesktopWindow(), (LPPOINT)&rc, 2);
        }/* end of if statement */
        ::ClipCursor(&rc);

        m_LastMouse.x = GET_X_LPARAM(lParam);
        m_LastMouse.y = GET_Y_LPARAM(lParam);

        if (m_pClipRect)
            m_ClipRectDown = *m_pClipRect;
        
        m_LastMouseDown = m_LastMouse;

        if(!m_fDisableAutoMouseProcessing){
            
            SelectAtPosition(GET_X_LPARAM(lParam), GET_Y_LPARAM(lParam));
        }/* end of if statement */
    }/* end of try statement */
    catch(...){
                
    }/* end of if statement */

    bHandled = true;
    return 0;
}/* end of function OnButtonDown */

/*************************************************************************/
/* Function: OnButtonUp                                                  */
/* Description: Activates the button. The problem is that when we move   */
/* away from a button while holding left button down over some other     */
/* button then the button we are under gets activated. What should happen*/
/* is that no button gets activated.                                     */
/*************************************************************************/
LRESULT CMSWebDVD::OnButtonUp(UINT, WPARAM wParam, LPARAM lParam, BOOL& bHandled){

    try {        
        if(!m_fInitialized){

            return(0);
        }/* end of if statement */

        m_bMouseDown = FALSE;
        ::ClipCursor(NULL);
        if(!m_fDisableAutoMouseProcessing && m_nCursorType == dvdCursor_Arrow){
            
            ActivateAtPosition(GET_X_LPARAM(lParam), GET_Y_LPARAM(lParam));
        }

        else if(m_nCursorType == dvdCursor_ZoomIn ||
                m_nCursorType == dvdCursor_ZoomOut) {

            // Compute new clipping top left corner
            long x = GET_X_LPARAM(lParam);
            long y = GET_Y_LPARAM(lParam);
            POINT CenterPoint = {x, y};
            if (m_bWndLess) {
                RECT rc = {m_rcPos.left, m_rcPos.top, m_rcPos.right, m_rcPos.bottom};
                HWND hwnd;
                HRESULT hr = GetParentHWND(&hwnd);
                
                if(FAILED(hr)){
                    
                    return(hr);
                }/* end of if statement */
                
                if(::IsWindow(hwnd)){
                    
                    ::MapWindowPoints(hwnd, ::GetDesktopWindow(), &CenterPoint, 1);
                    ::MapWindowPoints(hwnd, ::GetDesktopWindow(), (LPPOINT)&rc, 2);
                }/* end of if statement */
                x = CenterPoint.x - rc.left;
                y = CenterPoint.y - rc.top;
            }
            
            CComPtr<IDVDRect> pDvdClipRect;
            HRESULT hr = GetClipVideoRect(&pDvdClipRect);
            if (FAILED(hr))
                throw(hr);
            
            // Get current clipping width and height
            long clipWidth, clipHeight;
            pDvdClipRect->get_Width(&clipWidth);
            pDvdClipRect->get_Height(&clipHeight);
            
            // Get current clipping top left corner
            long clipX, clipY;
            pDvdClipRect->get_x(&clipX);
            pDvdClipRect->get_y(&clipY);

            long newClipCenterX = x*clipWidth/RECTWIDTH(&m_rcPos) + clipX;
            long newClipCenterY = y*clipHeight/RECTHEIGHT(&m_rcPos) + clipY;
            
            if (m_nCursorType == dvdCursor_ZoomIn) {
            
                Zoom(newClipCenterX, newClipCenterY, 2.0);
            }
            else if (m_nCursorType == dvdCursor_ZoomOut) {
            
                Zoom(newClipCenterX, newClipCenterY, 0.5);
            }/* end of if statement */
        }
                
    }/* end of try statement */
    catch(...){
                
    }/* end of if statement */

    bHandled = true;
    return 0;
}/* end of function OnButtonUp */

/*************************************************************************/
/* Function: OnMouseMove                                                 */
/* Description: Selects the button.                                      */
/*************************************************************************/
LRESULT CMSWebDVD::OnMouseMove(UINT, WPARAM wParam, LPARAM lParam, BOOL& bHandled){

	try {
        if(!m_fInitialized){

            return(0);
        }/* end of if statement */

        if(!m_fDisableAutoMouseProcessing && m_nCursorType == dvdCursor_Arrow){

            SelectAtPosition(GET_X_LPARAM(lParam), GET_Y_LPARAM(lParam));
        }       

        else if (m_bMouseDown && m_nCursorType == dvdCursor_Hand) {

            CComPtr<IDVDRect> pDvdClipRect;
            CComPtr<IDVDRect> pDvdRect;
            HRESULT hr = GetVideoSize(&pDvdRect);
            if (FAILED(hr))
                throw(hr);
            hr = GetClipVideoRect(&pDvdClipRect);
            if (FAILED(hr))
                throw(hr);

            // Get video width and height
            long videoWidth, videoHeight;
            pDvdRect->get_Width(&videoWidth);
            pDvdRect->get_Height(&videoHeight);

            // Get clipping width and height;
            long clipWidth, clipHeight;
            pDvdClipRect->get_Width(&clipWidth);
            pDvdClipRect->get_Height(&clipHeight);

            if (!m_bWndLess) {

                AdjustDestRC();
            }/* end of if statement */

            double scaleFactorX = clipWidth/(double)RECTWIDTH(&m_rcPosAspectRatioAjusted);
            double scaleFactorY = clipHeight/(double)RECTHEIGHT(&m_rcPosAspectRatioAjusted);

            long xAdjustment = (long) ((GET_X_LPARAM(lParam) - m_LastMouseDown.x)*scaleFactorX);
            long yAdjustment = (long) ((GET_Y_LPARAM(lParam) - m_LastMouseDown.y)*scaleFactorY);

            RECT clipRect = m_ClipRectDown;

            ::OffsetRect(&clipRect, -xAdjustment, -yAdjustment);
            if (clipRect.left<0)
                ::OffsetRect(&clipRect, -clipRect.left, 0);
            if (clipRect.top<0)
                ::OffsetRect(&clipRect, 0, -clipRect.top);
            
            if (clipRect.right>videoWidth)
                ::OffsetRect(&clipRect, videoWidth-clipRect.right, 0);
            
            if (clipRect.bottom>videoHeight)
                ::OffsetRect(&clipRect, 0, videoHeight-clipRect.bottom);

            //ATLTRACE(TEXT("SetClipVideoRect %d %d %d %d\n"),
            //    m_pClipRect->left, m_pClipRect->top, m_pClipRect->right, m_pClipRect->bottom);
            
            pDvdClipRect->put_x(clipRect.left);
            pDvdClipRect->put_y(clipRect.top);

            hr = SetClipVideoRect(pDvdClipRect);
            if (FAILED(hr))
                throw(hr);

            m_LastMouse.x = GET_X_LPARAM(lParam);
            m_LastMouse.y = GET_Y_LPARAM(lParam);
        }/* end of if statement */ 

    }/* end of try statement */
    catch(...){
                
    }/* end of if statement */

    bHandled = true;
    return 0;
}/* end of function OnMouseMove */

/*************************************************************/
/* Function: OnSetCursor                                     */
/* Description: Sets the cursor to what we want overwrite    */
/* the default window proc.                                  */
/*************************************************************/
LRESULT CMSWebDVD::OnSetCursor(UINT, WPARAM wParam, LPARAM lParam, BOOL& bHandled){
    
    //ATLTRACE(TEXT("CMSWebDVD::OnSetCursor\n"));
    
    if (m_hCursor && m_nCursorType != dvdCursor_None){

        ::SetCursor(m_hCursor);
        //ATLTRACE(TEXT("Actually setting the cursor OnSetCursor\n"));
        return(TRUE);
    }/* end of if statement */
    
    bHandled = FALSE;
    return 0;
}/* end of function OnSetCursor */

/*************************************************************************/
/* Function: get_TitlesAvailable                                         */
/* Description: Gets the number of titles.                               */
/*************************************************************************/
STDMETHODIMP CMSWebDVD::get_TitlesAvailable(long *pVal){

    HRESULT hr = S_OK;

    try {
        if(NULL == pVal){

            throw(E_POINTER);
        }/* end of if statement */

        INITIALIZE_GRAPH_IF_NEEDS_TO_BE

        if(!m_pDvdInfo2){

            throw(E_UNEXPECTED);
        }/* end of if statement */    

        ULONG NumOfVol;
        ULONG ThisVolNum;
        DVD_DISC_SIDE Side;
        ULONG TitleCount;

        hr = m_pDvdInfo2->GetDVDVolumeInfo(&NumOfVol, &ThisVolNum, &Side, &TitleCount);

        *pVal = (LONG) TitleCount;
    }
    catch(HRESULT hrTmp){

        hr = hrTmp;
    }/* end of catch statement */
    catch(...){

        hr = E_UNEXPECTED;
    }/* end of catch statement */
    
	return HandleError(hr);
}/* end of function get_TitlesAvailable */

/*************************************************************************/
/* Function: GetNumberChapterOfChapters                                  */
/* Description: Returns the number of chapters in title.                 */
/*************************************************************************/
STDMETHODIMP CMSWebDVD::GetNumberOfChapters(long lTitle, long *pVal){

    HRESULT hr = S_OK;

    try {
        if(NULL == pVal){

            throw(E_POINTER);
        }/* end of if statement */

        INITIALIZE_GRAPH_IF_NEEDS_TO_BE

        if(!m_pDvdInfo2){

            throw(E_UNEXPECTED);
        }/* end of if statement */    
    
        hr = m_pDvdInfo2->GetNumberOfChapters(lTitle, (ULONG*)pVal);
    }
    catch(HRESULT hrTmp){

        hr = hrTmp;
    }/* end of catch statement */
    catch(...){

        hr = E_UNEXPECTED;
    }/* end of catch statement */
    
	return HandleError(hr);
}/* end of function GetNumberChapterOfChapters */

/*************************************************************************/
/* Function: get_FullScreenMode                                          */
/* Description: Gets the current fullscreen mode.                        */
/*************************************************************************/
STDMETHODIMP CMSWebDVD::get_FullScreenMode(VARIANT_BOOL *pfFullScreenMode){

    //TODO: handle the other cases when not having IVideoWindow

    HRESULT hr = S_OK;

    try {

        if(NULL == pfFullScreenMode){

            throw(E_POINTER);
        }/* end of if statement */

        INITIALIZE_GRAPH_IF_NEEDS_TO_BE

	    IVideoWindow* pVW;

        if(!m_pDvdGB){

            return(E_UNEXPECTED);
        }/* end of if statement */

        hr = m_pDvdGB->GetDvdInterface(IID_IVideoWindow, (LPVOID *)&pVW) ;

        if (SUCCEEDED(hr) && pVW != NULL){       

           long lMode;
           hr =  pVW->get_FullScreenMode(&lMode);
       
           if(SUCCEEDED(hr)){

               *pfFullScreenMode = ((lMode == OAFALSE) ? VARIANT_FALSE : VARIANT_TRUE);
           }/* end of if statement */

           pVW->Release();
        }/* end of if statement */
    }/* end of try statement */
    catch(HRESULT hrTmp){
        hr = hrTmp;
    }/* end of catch statement */
    catch(...){
        hr = E_UNEXPECTED;
    }/* end of catch statement */

	return HandleError(hr);
}/* end of function get_FullScreenMode */

/*************************************************************************/
/* Function: put_FullScreenMode                                          */
/* Description: Sets the full screen mode.                               */ 
/*************************************************************************/
STDMETHODIMP CMSWebDVD::put_FullScreenMode(VARIANT_BOOL fFullScreenMode){

    HRESULT hr = S_OK;

    try {

        INITIALIZE_GRAPH_IF_NEEDS_TO_BE

	    IVideoWindow* pVW;

        if(!m_pDvdGB){

            return(E_UNEXPECTED);
        }/* end of if statement */

        hr = m_pDvdGB->GetDvdInterface(IID_IVideoWindow, (LPVOID *)&pVW) ;

        if (SUCCEEDED(hr) && pVW != NULL){       

           hr =  pVW->put_FullScreenMode(fFullScreenMode);

           pVW->Release();
        }/* end of if statement */
    }/* end of try statement */
    catch(HRESULT hrTmp){
        hr = hrTmp;
    }/* end of catch statement */
    catch(...){
        hr = E_UNEXPECTED;
    }/* end of catch statement */

	return  HandleError(hr);
}/* end of function put_FullScreenMode */

/*************************************************************************/
/* Function: SetDDrawExcl                                                */
/* Descirption: Sets up Overlays Mixer DDraw interface. That way we avoid*/
/* drawing using IVideo Window and the control, can be windowless.       */
/*************************************************************************/
HRESULT CMSWebDVD::SetDDrawExcl(){

	HRESULT hr = S_OK;

	HWND hwndBrowser = NULL;

	hr = GetParentHWND(&hwndBrowser);

	if(FAILED(hr)){

		return(hr);
	}/* end of if statement */

	if(hwndBrowser == NULL){

		hr = E_POINTER;
		return(E_POINTER);
	}/* end of if statement */

	HDC hDC = ::GetWindowDC(hwndBrowser);

	if(hDC == NULL){

		hr = E_UNEXPECTED;	
		return(hr);
	}/* end of if statement */

	LPDIRECTDRAW pDDraw = NULL;

	hr = DirectDrawCreate(NULL, &pDDraw, NULL);

	if(FAILED(hr)){

        ::ReleaseDC(hwndBrowser, hDC);
		return(hr);
	}/* end of if statement */

	LPDIRECTDRAW4 pDDraw4 = NULL;

	hr = pDDraw->QueryInterface(IID_IDirectDraw4, (LPVOID*)&pDDraw4);

	pDDraw->Release();
		
	if(FAILED(hr)){

        ::ReleaseDC(hwndBrowser, hDC);
		return(hr);
	}/* end of if statement */

	LPDIRECTDRAWSURFACE4 pDDS4 = NULL;

	pDDraw4->GetSurfaceFromDC(hDC, &pDDS4);

	pDDraw4->Release();
    ::ReleaseDC(hwndBrowser, hDC);

	if(FAILED(hr)){

		return(hr);
	}/* end of if statement */

	LPDIRECTDRAW4 pDDrawIE = NULL;

	hr = pDDS4->GetDDInterface((LPVOID*)&pDDrawIE);

	pDDS4->Release();
	pDDrawIE->Release();

	return  HandleError(hr);
}/* end of function SetDDrawExcl */

/*************************************************************************/
/* Function: PlayBackwards                                               */
/* Description: Rewind, set to play state to start with.                 */
/*************************************************************************/
STDMETHODIMP CMSWebDVD::PlayBackwards(double dSpeed, VARIANT_BOOL fDoNotReset){

    HRESULT hr = S_OK;

    try {
        if(VARIANT_FALSE != fDoNotReset){

            m_fResetSpeed = false;
        }/* end of if statement */

        INITIALIZE_GRAPH_IF_NEEDS_TO_BE_AND_PLAY

        m_fResetSpeed = true;
        
        if(!m_pDvdCtl2){
            
            throw(E_UNEXPECTED);
        }/* end of if statement */
        
        RETRY_IF_IN_FPDOM(m_pDvdCtl2->PlayBackwards(dSpeed,0,0));
    }/* end of try statement */
    catch(HRESULT hrTmp){
        hr = hrTmp;
    }/* end of catch statement */
    catch(...){
        hr = E_UNEXPECTED;
    }/* end of catch statement */

	return  HandleError(hr);
}/* end of function BackwardScan */

/*************************************************************************/
/* Function: PlayForwards                                                */
/* Description: Set DVD in fast forward mode.                            */
/*************************************************************************/
STDMETHODIMP CMSWebDVD::PlayForwards(double dSpeed, VARIANT_BOOL fDoNotReset){

    HRESULT hr = S_OK;

    try {
        if(VARIANT_FALSE != fDoNotReset){

            m_fResetSpeed = false;
        }/* end of if statement */

        INITIALIZE_GRAPH_IF_NEEDS_TO_BE_AND_PLAY

        m_fResetSpeed = true;

        if(!m_pDvdCtl2){
        
            throw(E_UNEXPECTED);
        }/* end of if statement */                
            
        RETRY_IF_IN_FPDOM(m_pDvdCtl2->PlayForwards(dSpeed,0,0));

    }/* end of try statement */
    catch(HRESULT hrTmp){
        hr = hrTmp;
    }/* end of catch statement */
    catch(...){
        hr = E_UNEXPECTED;
    }/* end of catch statement */

    return  HandleError(hr);
}/* end of function PlayForwards */

/*************************************************************************/
/* Function: Resume                                                      */
/* Description: Resume from menu. We put our self in play state, just    */
/* in the case we were not in it. This might lead to some unexpected     */
/* behavior in case when we stopped and the tried to hit this button     */
/* but I think in this case might be appropriate as well.                */
/*************************************************************************/
STDMETHODIMP CMSWebDVD::Resume(){

    HRESULT hr = S_OK;

    try {
        hr = Play(); // put in the play mode

        if(FAILED(hr)){

            throw(hr);
        }/* end of if statement */
    
        if(!m_pDvdCtl2){
            
            throw(E_UNEXPECTED);
        }/* end of if statement */
                    
        hr = m_pDvdCtl2->Resume(cdwDVDCtrlFlags, 0);
    }/* end of try statement */
    catch(HRESULT hrTmp){
        hr = hrTmp;
    }/* end of catch statement */
    catch(...){
        hr = E_UNEXPECTED;
    }/* end of catch statement */

    return  HandleError(hr);
}/* end of function Resume */

/*************************************************************************/
/* Function: ShowMenu                                                    */
/* Description: Invokes specific menu call.                              */
/* We set our selfs to play mode so we can execute this in case we were  */
/* paused or stopped.                                                    */
/*************************************************************************/
STDMETHODIMP CMSWebDVD::ShowMenu(DVDMenuIDConstants MenuID){

    HRESULT hr = S_OK;

    try {
        INITIALIZE_GRAPH_IF_NEEDS_TO_BE_AND_PLAY

        if(!m_pDvdCtl2){
            
            throw(E_UNEXPECTED);
        }/* end of if statement */                
            
        RETRY_IF_IN_FPDOM(m_pDvdCtl2->ShowMenu((tagDVD_MENU_ID)MenuID, cdwDVDCtrlFlags, 0)); //!!keep in sync, or this cast will not work
    }/* end of try statement */
    catch(HRESULT hrTmp){
        hr = hrTmp;
    }/* end of catch statement */
    catch(...){
        hr = E_UNEXPECTED;
    }/* end of catch statement */

    return  HandleError(hr);
}/* end of function MenuCall */

/*************************************************************************/
/* Function: get_PlayState                                               */
/* Description: Needs to be expanded for DVD, using their base APIs,     */
/* get DVD specific states as well.                                      */
/*************************************************************************/
STDMETHODIMP CMSWebDVD::get_PlayState(DVDFilterState *pFilterState){

    HRESULT hr = S_OK;

    try {

	    if (NULL == pFilterState){

            throw(E_POINTER);         
        }/* end of if statement */

        if(!m_fInitialized){

           *pFilterState =  dvdState_Unitialized;
           return(hr);
        }/* end of if statement */
       
        if(!m_pMC){
            
            throw(E_UNEXPECTED);
        }/* end of if statement */                
            
        OAFilterState fs;

        hr = m_pMC->GetState(cgStateTimeout, &fs);

        *pFilterState = (DVDFilterState)fs; // !!keep in sync, or this cast will not work
    }/* end of try statement */
    catch(HRESULT hrTmp){
        hr = hrTmp;
    }/* end of catch statement */
    catch(...){
        hr = E_UNEXPECTED;
    }/* end of catch statement */

    return  HandleError(hr);
}/* end of get_PlayState */

/*************************************************************************/
/* Function: SelectUpperButton                                           */
/* Description: Selects the upper button on DVD Menu.                    */
/*************************************************************************/
STDMETHODIMP CMSWebDVD::SelectUpperButton(){

    HRESULT hr = S_OK;

    try {
        hr = Play(); // put in the play mode

        if(FAILED(hr)){

            throw(hr);
        }/* end of if statement */

        if(!m_pDvdCtl2){
            
            throw(E_UNEXPECTED);
        }/* end of if statement */                

        hr = m_pDvdCtl2->SelectRelativeButton(DVD_Relative_Upper);        
    }/* end of try statement */
    catch(HRESULT hrTmp){
        hr = hrTmp;
    }/* end of catch statement */
    catch(...){
        hr = E_UNEXPECTED;
    }/* end of catch statement */

    return  HandleError(hr);
}/* end of function SelectUpperButton */

/*************************************************************************/
/* Function: SelectLowerButton                                           */
/* Description: Selects the lower button on DVD Menu.                    */
/*************************************************************************/
STDMETHODIMP CMSWebDVD::SelectLowerButton(){

	HRESULT hr = S_OK;

    try {
        hr = Play(); // put in the play mode

        if(FAILED(hr)){

            throw(hr);
        }/* end of if statement */

        if(!m_pDvdCtl2){
            
            throw(E_UNEXPECTED);
        }/* end of if statement */                
        
        hr = m_pDvdCtl2->SelectRelativeButton(DVD_Relative_Lower);                
    }/* end of try statement */
    catch(HRESULT hrTmp){
        hr = hrTmp;
    }/* end of catch statement */
    catch(...){
        hr = E_UNEXPECTED;
    }/* end of catch statement */

    return  HandleError(hr);
}/* end of function SelectLowerButton */

/*************************************************************************/
/* Function: SelectLeftButton                                            */
/* Description: Selects the left button on DVD Menu.                     */
/*************************************************************************/
STDMETHODIMP CMSWebDVD::SelectLeftButton(){

    HRESULT hr = S_OK;

    try {
        hr = Play(); // put in the play mode

        if(FAILED(hr)){

            throw(hr);
        }/* end of if statement */

        if(!m_pDvdCtl2){
            
            throw(E_UNEXPECTED);
        }/* end of if statement */                
    
        hr = m_pDvdCtl2->SelectRelativeButton(DVD_Relative_Left);                
    }/* end of try statement */
    catch(HRESULT hrTmp){
        hr = hrTmp;
    }/* end of catch statement */
    catch(...){
        hr = E_UNEXPECTED;
    }/* end of catch statement */

    return  HandleError(hr);
}/* end of function SelectLeftButton */

/*************************************************************************/
/* Function: SelectRightButton                                           */
/* Description: Selects the right button on DVD Menu.                    */
/*************************************************************************/
STDMETHODIMP CMSWebDVD::SelectRightButton(){

	HRESULT hr = S_OK;

    try {
        hr = Play(); // put in the play mode

        if(FAILED(hr)){

            throw(hr);
        }/* end of if statement */

        if(!m_pDvdCtl2){
            
            throw(E_UNEXPECTED);
        }/* end of if statement */                

        hr = m_pDvdCtl2->SelectRelativeButton(DVD_Relative_Right);        
    }/* end of try statement */
    catch(HRESULT hrTmp){
        hr = hrTmp;
    }/* end of catch statement */
    catch(...){
        hr = E_UNEXPECTED;
    }/* end of catch statement */
    
    return  HandleError(hr);
}/* end of function SelectRightButton */

/*************************************************************************/
/* Function: ActivateButton                                              */
/* Description: Activates the selected button on DVD Menu.               */
/*************************************************************************/
STDMETHODIMP CMSWebDVD::ActivateButton(){

	HRESULT hr = S_OK;

    try {
        hr = Play(); // put in the play mode

        if(FAILED(hr)){

            throw(hr);
        }/* end of if statement */

        if(!m_pDvdCtl2){
            
            throw(E_UNEXPECTED);
        }/* end of if statement */                
            
        hr = m_pDvdCtl2->ActivateButton();
    }/* end of try statement */
    catch(HRESULT hrTmp){
        hr = hrTmp;
    }/* end of catch statement */
    catch(...){
        hr = E_UNEXPECTED;
    }/* end of catch statement */

    return  HandleError(hr);
}/* end of function ActivateButton */

/*************************************************************************/
/* Function: SelectAndActivateButton                                     */
/* Description: Selects and activates the specific button.               */
/*************************************************************************/
STDMETHODIMP CMSWebDVD::SelectAndActivateButton(long lButton){

    HRESULT hr = S_OK;

    try {
        hr = Play(); // put in the play mode

        if(FAILED(hr)){
            throw(hr);
        }

        if(lButton < 0){   
            throw(E_INVALIDARG);        
        }

        if( !m_pDvdCtl2){            
            throw(E_UNEXPECTED);
        }
            
        hr = m_pDvdCtl2->SelectAndActivateButton((ULONG)lButton);
    }
    catch(HRESULT hrTmp){
        hr = hrTmp;
    }
    catch(...){
        hr = E_UNEXPECTED;
    }

    return  HandleError(hr);
}/* end of function SelectAndActivateButton */

/*************************************************************************/
/* Function: PlayNextChapter                                             */
/* Description: Goes to next chapter                                     */
/*************************************************************************/
STDMETHODIMP CMSWebDVD::PlayNextChapter(){

    HRESULT hr = S_OK;

    try {
        INITIALIZE_GRAPH_IF_NEEDS_TO_BE_AND_PLAY

        if(!m_pDvdCtl2){
            
            throw(E_UNEXPECTED);
        }/* end of if statement */                
            
        RETRY_IF_IN_FPDOM(m_pDvdCtl2->PlayNextChapter(cdwDVDCtrlFlags, 0));
    }/* end of try statement */
    catch(HRESULT hrTmp){
        hr = hrTmp;
    }/* end of catch statement */
    catch(...){
        hr = E_UNEXPECTED;
    }/* end of catch statement */

    return  HandleError(hr);
}/* end of function PlayNextChapter */

/*************************************************************************/
/* Function: PlayPrevChapter                                             */
/* Description: Goes to previous chapter                                 */
/*************************************************************************/
STDMETHODIMP CMSWebDVD::PlayPrevChapter(){

    HRESULT hr = S_OK;

    try {
        INITIALIZE_GRAPH_IF_NEEDS_TO_BE_AND_PLAY

        if(!m_pDvdCtl2){
            
            throw(E_UNEXPECTED);
        }/* end of if statement */                
            
        RETRY_IF_IN_FPDOM(m_pDvdCtl2->PlayPrevChapter(cdwDVDCtrlFlags, 0));
    }/* end of try statement */
    catch(HRESULT hrTmp){
        hr = hrTmp;
    }/* end of catch statement */
    catch(...){
        hr = E_UNEXPECTED;
    }/* end of catch statement */

    return  HandleError(hr);
}/* end of function PlayPrevChapter */

/*************************************************************************/
/* Function: ReplayChapter                                               */
/* Description: Halts playback and restarts the playback of current      */
/* program inside PGC.                                                   */
/*************************************************************************/
STDMETHODIMP CMSWebDVD::ReplayChapter(){

    HRESULT hr = S_OK;

    try {
        INITIALIZE_GRAPH_IF_NEEDS_TO_BE_AND_PLAY

        if(!m_pDvdCtl2){
            
            throw(E_UNEXPECTED);
        }/* end of if statement */                
            
        RETRY_IF_IN_FPDOM(m_pDvdCtl2->ReplayChapter(cdwDVDCtrlFlags, 0));
    }/* end of try statement */
    catch(HRESULT hrTmp){
        hr = hrTmp;
    }/* end of catch statement */
    catch(...){
        hr = E_UNEXPECTED;
    }/* end of catch statement */

    return  HandleError(hr);
}/* end of function ReplayChapter */

/*************************************************************************/
/* Function: Return                                                      */
/* Description: Used in menu to return into prevoius menu.               */
/*************************************************************************/
STDMETHODIMP CMSWebDVD::ReturnFromSubmenu(){

    HRESULT hr = S_OK;

    try {
        INITIALIZE_GRAPH_IF_NEEDS_TO_BE_AND_PLAY

        if(!m_pDvdCtl2){
            
            throw(E_UNEXPECTED);
        }/* end of if statement */                
            
        RETRY_IF_IN_FPDOM(m_pDvdCtl2->ReturnFromSubmenu(cdwDVDCtrlFlags, 0));
    }/* end of try statement */
    catch(HRESULT hrTmp){
        hr = hrTmp;
    }/* end of catch statement */
    catch(...){
        hr = E_UNEXPECTED;
    }/* end of catch statement */

    return  HandleError(hr);
}/* end of function Return */

/*************************************************************************/
/* Function: PlayChapter                                                 */
/* Description: Does chapter search. Waits for FP_DOM to pass and initi  */
/* lizes the graph as the other smar routines.                           */
/*************************************************************************/
STDMETHODIMP CMSWebDVD::PlayChapter(LONG lChapter){

    HRESULT hr = S_OK;

    try {
	    if(lChapter < 0){

            throw(E_INVALIDARG);
        }/* end of if statement */

        INITIALIZE_GRAPH_IF_NEEDS_TO_BE_AND_PLAY

        if(!m_pDvdCtl2){

            throw(E_UNEXPECTED);
        }/* end of if statement */

        RETRY_IF_IN_FPDOM(m_pDvdCtl2->PlayChapter(lChapter, cdwDVDCtrlFlags, 0));
    }/* end of try statement */
    catch(HRESULT hrTmp){
        hr = hrTmp;
    }/* end of catch statement */
    catch(...){
        hr = E_UNEXPECTED;
    }/* end of catch statement */

	return  HandleError(hr);
}/* end of function PlayChapter */

/*************************************************************************/
/* Function: GetAudioLanguage                                            */
/* Description: Returns audio language associated with a stream.         */
/*************************************************************************/
STDMETHODIMP CMSWebDVD::GetAudioLanguage(LONG lStream, VARIANT_BOOL fFormat, BSTR *strAudioLang){

    HRESULT hr = S_OK;
    LPTSTR pszString = NULL;

    try {
        if(NULL == strAudioLang){

            throw(E_POINTER);
        }/* end of if statement */

        if(lStream < 0){

            throw(E_INVALIDARG);
        }/* end of if statement */

        INITIALIZE_GRAPH_IF_NEEDS_TO_BE

        if(!m_pDvdInfo2){

            throw(E_UNEXPECTED);
        }/* end of if statement */

        USES_CONVERSION;
        LCID lcid;                
        hr = m_pDvdInfo2->GetAudioLanguage(lStream, &lcid);
    
        if (SUCCEEDED( hr )){

            // count up the streams for the same LCID like English 2
            
            pszString = m_LangID.GetLangFromLangID((WORD)PRIMARYLANGID(LANGIDFROMLCID(lcid)));
            if (pszString == NULL) {
                
                pszString = new TCHAR[MAX_PATH];
                TCHAR strBuffer[MAX_PATH];
                if(!::LoadString(_Module.m_hInstResource, IDS_AUDIOTRACK, strBuffer, MAX_PATH)){
                    delete[] pszString;
                    throw(E_UNEXPECTED);
                }/* end of if statement */

                StringCchPrintf(pszString, MAX_PATH, strBuffer, lStream);
            }/* end of if statement */

            DVD_AudioAttributes attr;
            if(SUCCEEDED(m_pDvdInfo2->GetAudioAttributes(lStream, &attr))){
                
                // If want audio format param is set
                if (fFormat != VARIANT_FALSE) {
                    switch(attr.AudioFormat){
                    case DVD_AudioFormat_AC3: AppendString(pszString, IDS_DOLBY, MAX_PATH ); break; 
                    case DVD_AudioFormat_MPEG1: AppendString(pszString, IDS_MPEG1, MAX_PATH ); break;
                    case DVD_AudioFormat_MPEG1_DRC: AppendString(pszString, IDS_MPEG1, MAX_PATH ); break;
                    case DVD_AudioFormat_MPEG2: AppendString(pszString, IDS_MPEG2, MAX_PATH ); break;
                    case DVD_AudioFormat_MPEG2_DRC: AppendString(pszString, IDS_MPEG2, MAX_PATH); break;
                    case DVD_AudioFormat_LPCM: AppendString(pszString, IDS_LPCM, MAX_PATH ); break;
                    case DVD_AudioFormat_DTS: AppendString(pszString, IDS_DTS, MAX_PATH ); break;
                    case DVD_AudioFormat_SDDS: AppendString(pszString, IDS_SDDS, MAX_PATH ); break;
                    }/* end of switch statement */                    
                }

                switch(attr.LanguageExtension){
                case DVD_AUD_EXT_NotSpecified:
                case DVD_AUD_EXT_Captions:     break; // do not add anything
                case DVD_AUD_EXT_VisuallyImpaired:   AppendString(pszString, IDS_AUDIO_VISUALLY_IMPAIRED, MAX_PATH ); break;      
                case DVD_AUD_EXT_DirectorComments1:  AppendString(pszString, IDS_AUDIO_DIRC1, MAX_PATH ); break;
                case DVD_AUD_EXT_DirectorComments2:  AppendString(pszString, IDS_AUDIO_DIRC2, MAX_PATH ); break;
                }/* end of switch statement */

            }/* end of if statement */

            *strAudioLang = ::SysAllocString( T2W(pszString) );
            delete[] pszString;
            pszString = NULL;
        }
        else {

            *strAudioLang = ::SysAllocString( L"");

            // hr used to be not failed and return nothing 
            if(SUCCEEDED(hr)) // remove this after gets fixed in DVDNav
                hr = E_FAIL;
        }/* end of if statement */
    }/* end of try statement */
    catch(HRESULT hrTmp){

        if (pszString) {
            delete[] pszString;
            pszString = NULL;
        }

        hr = hrTmp;
    }/* end of catch statement */
    catch(...){

        if (pszString) {
            delete[] pszString;
            pszString = NULL;
        }

        hr = E_UNEXPECTED;
    }/* end of catch statement */

	return HandleError(hr);
}/* end of function GetAudioLanguage */

/*************************************************************************/
/* Function: StillOff                                                    */
/* Description: Turns the still off, what that can be used for is a      */
/* mistery to me.                                                        */
/*************************************************************************/
STDMETHODIMP CMSWebDVD::StillOff(){

	if(!m_pDvdCtl2){

        return E_UNEXPECTED;
    }/* end of if statement */

    return HandleError(m_pDvdCtl2->StillOff());
}/* end of function StillOff */

/*************************************************************************/
/* Function: PlayTitle                                                   */
/* Description: If fails waits for FP_DOM to pass and tries later.       */
/*************************************************************************/
STDMETHODIMP CMSWebDVD::PlayTitle(LONG lTitle){

    HRESULT hr = S_OK;

    try {
        if(0 > lTitle){

            throw(E_INVALIDARG);
        }/* end of if statement */

        INITIALIZE_GRAPH_IF_NEEDS_TO_BE_AND_PLAY
        
        if(!m_pDvdCtl2){

            throw(E_UNEXPECTED);
        }/* end of if statement */
        
        long lNumTitles = 0;
        hr = get_TitlesAvailable(&lNumTitles);
        if(FAILED(hr)){
            throw hr;
        }
        
        if(lTitle > lNumTitles){
            throw E_INVALIDARG;
        }
        
        RETRY_IF_IN_FPDOM(m_pDvdCtl2->PlayTitle(lTitle, cdwDVDCtrlFlags, 0));
    }/* end of try statement */
    catch(HRESULT hrTmp){
        hr = hrTmp;
    }/* end of catch statement */
    catch(...){
        hr = E_UNEXPECTED;
    }/* end of catch statement */

	return HandleError(hr);
}/* end of function PlayTitle */

/*************************************************************************/
/* Function: GetSubpictureLanguage                                       */
/* Description: Gets subpicture language.                                */
/*************************************************************************/
STDMETHODIMP CMSWebDVD::GetSubpictureLanguage(LONG lStream, BSTR* strSubpictLang){

    HRESULT hr = S_OK;
    LPTSTR pszString = NULL;

    try {
        if(NULL == strSubpictLang){

            throw(E_POINTER);
        }/* end of if statement */

        if(0 > lStream){

            throw(E_INVALIDARG);
        }/* end of if statement */

        if((lStream > cgDVD_MAX_SUBPICTURE 
            && lStream != cgDVD_ALT_SUBPICTURE)){

            throw(E_INVALIDARG);
        }/* end of if statement */

        INITIALIZE_GRAPH_IF_NEEDS_TO_BE

        if(!m_pDvdInfo2){

            throw(E_UNEXPECTED);
        }/* end of if statement */

        LCID lcid;
        hr = m_pDvdInfo2->GetSubpictureLanguage(lStream, &lcid);
        
        if (SUCCEEDED( hr )){

            pszString = m_LangID.GetLangFromLangID((WORD)PRIMARYLANGID(LANGIDFROMLCID(lcid)));
            if (pszString == NULL) {
                
                pszString = new TCHAR[MAX_PATH];
                TCHAR strBuffer[MAX_PATH];
                if(!::LoadString(_Module.m_hInstResource, IDS_SUBPICTURETRACK, strBuffer, MAX_PATH)){
                    delete[] pszString;
                    throw(E_UNEXPECTED);
                }/* end of if statement */

                StringCchPrintf(pszString, MAX_PATH, strBuffer, lStream);
            }/* end of if statement */
#if 0
            DVD_SubpictureATR attr;
            if(SUCCEEDED(m_pDvdInfo2->GetSubpictureAttributes(lStream, &attr))){

            switch(attr){
                case DVD_SP_EXT_NotSpecified:
                case DVD_SP_EXT_Caption_Normal:  break;

                case DVD_SP_EXT_Caption_Big:  AppendString(pszString, IDS_CAPTION_BIG, MAX_PATH ); break; 
                case DVD_SP_EXT_Caption_Children: AppendString(pszString, IDS_CAPTION_CHILDREN, MAX_PATH ); break; 
                case DVD_SP_EXT_CC_Normal: AppendString(pszString, IDS_CLOSED_CAPTION, MAX_PATH ); break;                 
                case DVD_SP_EXT_CC_Big: AppendString(pszString, IDS_CLOSED_CAPTION_BIG, MAX_PATH ); break; 
                case DVD_SP_EXT_CC_Children: AppendString(pszString, IDS_CLOSED_CAPTION_CHILDREN, MAX_PATH ); break; 
                case DVD_SP_EXT_Forced: AppendString(pszString, IDS_CLOSED_CAPTION_FORCED, MAX_PATH ); break; 
                case DVD_SP_EXT_DirectorComments_Normal: AppendString(pszString, IDS_DIRS_COMMNETS, MAX_PATH ); break; 
                case DVD_SP_EXT_DirectorComments_Big: AppendString(pszString, IDS_DIRS_COMMNETS_BIG, MAX_PATH ); break; 
                case DVD_SP_EXT_DirectorComments_Children: AppendString(pszString, IDS_DIRS_COMMNETS_CHILDREN, MAX_PATH ); break; 
            }/* end of switch statement */
#endif

            USES_CONVERSION;
            *strSubpictLang = ::SysAllocString( T2W(pszString) );
            delete[] pszString;
            pszString = NULL;
        }
        else {

            *strSubpictLang = ::SysAllocString( L"");

            // hr used to be not failed and return nothing 
            if(SUCCEEDED(hr)) // remove this after gets fixed in DVDNav
                hr = E_FAIL;
        }/* end of if statement */

    }/* end of try statement */
    catch(HRESULT hrTmp){

        if (pszString) {
            delete[] pszString;
            pszString = NULL;
        }

        hr = hrTmp;
    }/* end of catch statement */
    catch(...){

        if (pszString) {
            delete[] pszString;
            pszString = NULL;
        }

        hr = E_UNEXPECTED;
    }/* end of catch statement */

	return HandleError(hr);
}/* end of function GetSubpictureLanguage */

/*************************************************************************/
/* Function: PlayChapterInTitle                                          */
/* Description: Plays from the specified chapter without stopping        */
/* THIS NEEDS TO BE ENHANCED !!! Current implementation and queing       */
/* into the message loop is insufficient!!! TODO.                        */
/*************************************************************************/
STDMETHODIMP CMSWebDVD::PlayChapterInTitle(LONG lTitle, LONG lChapter){

    HRESULT hr = S_OK;

    try {
        
        if ((lTitle > cgDVDMAX_TITLE_COUNT) || (lTitle < cgDVDMIN_TITLE_COUNT)){
            
            throw(E_INVALIDARG);
        }/* end of if statement */

        if ((lChapter > cgDVDMAX_CHAPTER_COUNT) || (lChapter < cgDVDMIN_CHAPTER_COUNT)){
            
            throw(E_INVALIDARG);
        }/* end of if statement */

        INITIALIZE_GRAPH_IF_NEEDS_TO_BE_AND_PLAY

        if(!m_pDvdCtl2){
            
            throw(E_UNEXPECTED);
        }/* end of if statement */
                
        RETRY_IF_IN_FPDOM(m_pDvdCtl2->PlayChapterInTitle(lTitle, lChapter, cdwDVDCtrlFlags, 0));
    }/* end of try statement */
    catch(HRESULT hrTmp){

        hr = hrTmp;
    }
    catch(...){

        hr = E_UNEXPECTED;
    }/* end of catch statement */

	return HandleError(hr);
}/* end of function PlayChapterInTitle */

/*************************************************************************/
/* Function: PlayChapterAutoStop                                         */
/* Description: Plays set ammount of chapters.                           */
/*************************************************************************/
STDMETHODIMP CMSWebDVD::PlayChaptersAutoStop(LONG lTitle, LONG lChapter, 
                                          LONG lChapterCount){

    HRESULT hr = S_OK;

    try {        

        if ((lTitle > cgDVDMAX_TITLE_COUNT) || (lTitle < cgDVDMIN_TITLE_COUNT)){
            
            throw(E_INVALIDARG);
        }/* end of if statement */

        if ((lChapter > cgDVDMAX_CHAPTER_COUNT) || (lChapter < cgDVDMIN_CHAPTER_COUNT)){
            
            throw(E_INVALIDARG);
        }/* end of if statement */

        if ((lChapterCount > cgDVDMAX_CHAPTER_COUNT) || (lChapterCount < cgDVDMIN_CHAPTER_COUNT)){
            
            throw(E_INVALIDARG);
        }/* end of if statement */

        INITIALIZE_GRAPH_IF_NEEDS_TO_BE_AND_PLAY

        if(!m_pDvdCtl2){
            
            throw(E_UNEXPECTED);
        }/* end of if statement */
                
        RETRY_IF_IN_FPDOM(m_pDvdCtl2->PlayChaptersAutoStop(lTitle, lChapter, lChapterCount, cdwDVDCtrlFlags, 0));
    }/* end of try statement */
    catch(HRESULT hrTmp){

        hr = hrTmp;
    }
    catch(...){

        hr = E_UNEXPECTED;
    }/* end of catch statement */

	return HandleError(hr);
}/* end of function PlayChaptersAutoStop */

/*************************************************************************/
/* Function: PlayPeriodInTitleAutoStop                                   */
/* Description: Time plays, converts from hh:mm:ss:ff format             */
/*************************************************************************/
STDMETHODIMP CMSWebDVD::PlayPeriodInTitleAutoStop(long lTitle, 
                                                  BSTR strStartTime, BSTR strEndTime){

    HRESULT hr = S_OK;

    try {        
        if(NULL == strStartTime){

            throw(E_POINTER);
        }/* end of if statement */

        if(NULL == strEndTime){

            throw(E_POINTER);
        }/* end of if statement */
        
        DVD_HMSF_TIMECODE tcStartTimeCode;
        hr = Bstr2DVDTime(&tcStartTimeCode, &strStartTime);

        if(FAILED(hr)){

            throw (hr);
        }

        DVD_HMSF_TIMECODE tcEndTimeCode;

        Bstr2DVDTime(&tcEndTimeCode, &strEndTime);

        if(FAILED(hr)){

            throw(hr);
        }/* end of if statement */

        INITIALIZE_GRAPH_IF_NEEDS_TO_BE_AND_PLAY

        if(!m_pDvdCtl2){

            throw(E_UNEXPECTED);
        }/* end of if statement */

        RETRY_IF_IN_FPDOM(m_pDvdCtl2->PlayPeriodInTitleAutoStop(lTitle, &tcStartTimeCode,
                &tcEndTimeCode,  cdwDVDCtrlFlags, 0));
    }/* end of try statement */
    catch(HRESULT hrTmp){

        hr = hrTmp;
    }
    catch(...){

        hr = E_UNEXPECTED;
    }/* end of catch statement */

	return HandleError(hr);
}/* end of function PlayPeriodInTitleAutoStop */

/*************************************************************************/
/* Function: PlayAtTimeInTitle                                           */
/* Description: Time plays, converts from hh:mm:ss:ff format             */
/*************************************************************************/
STDMETHODIMP CMSWebDVD::PlayAtTimeInTitle(long lTitle, BSTR strTime){

    HRESULT hr = S_OK;

    try {        
        if(NULL == strTime){

            throw(E_POINTER);
        }/* end of if statement */
        
        DVD_HMSF_TIMECODE tcTimeCode;
        hr = Bstr2DVDTime(&tcTimeCode, &strTime);

        if(FAILED(hr)){

            throw(hr);
        }/* end of if statement */

        INITIALIZE_GRAPH_IF_NEEDS_TO_BE_AND_PLAY

        if(!m_pDvdCtl2){

            throw(E_UNEXPECTED);
        }/* end of if statement */

        RETRY_IF_IN_FPDOM(m_pDvdCtl2->PlayAtTimeInTitle(lTitle, &tcTimeCode, cdwDVDCtrlFlags, 0));

    }/* end of try statement */
    catch(HRESULT hrTmp){

        hr = hrTmp;
    }
    catch(...){

        hr = E_UNEXPECTED;
    }/* end of catch statement */

	return HandleError(hr);
}/* end of function PlayAtTimeInTitle */

/*************************************************************************/
/* Function: PlayAtTime                                                  */
/* Description: TimeSearch, converts from hh:mm:ss:ff format             */
/*************************************************************************/
STDMETHODIMP CMSWebDVD::PlayAtTime(BSTR strTime){

    HRESULT hr = S_OK;

    try {
        
        if(NULL == strTime){

            throw(E_POINTER);
        }/* end of if statement */
        
        DVD_HMSF_TIMECODE tcTimeCode;
        Bstr2DVDTime(&tcTimeCode, &strTime);

        if(FAILED(hr)){

            throw(hr);
        }/* end of if statement */

        INITIALIZE_GRAPH_IF_NEEDS_TO_BE_AND_PLAY

        if(!m_pDvdCtl2){

            throw(E_UNEXPECTED);
        }/* end of if statement */

        RETRY_IF_IN_FPDOM(m_pDvdCtl2->PlayAtTime( &tcTimeCode, cdwDVDCtrlFlags, 0));

    }/* end of try statement */
    catch(HRESULT hrTmp){

        hr = hrTmp;
    }
    catch(...){

        hr = E_UNEXPECTED;
    }/* end of catch statement */

	return HandleError(hr);
}/* end of function PlayAtTime */

/*************************************************************************/
/* Function: get_CurrentTitle                                            */
/* Description: Gets current title.                                      */
/*************************************************************************/
STDMETHODIMP CMSWebDVD::get_CurrentTitle(long *pVal){

    HRESULT hr = S_OK;

    try {        
        if(NULL == pVal){

            throw(E_POINTER);
        }/* end of if statement */

        INITIALIZE_GRAPH_IF_NEEDS_TO_BE

        if(!m_pDvdInfo2){

            throw(E_UNEXPECTED);
        }/* end of if statement */

         DVD_PLAYBACK_LOCATION2 dvdLocation;

        RETRY_IF_IN_FPDOM(m_pDvdInfo2->GetCurrentLocation(&dvdLocation));

        if(SUCCEEDED(hr)){

            *pVal = dvdLocation.TitleNum;
        }
        else {

            *pVal = 0;
        }/* end of if statement */
    }/* end of try statement */
    catch(HRESULT hrTmp){

        hr = hrTmp;
    }
    catch(...){

        hr = E_UNEXPECTED;
    }/* end of catch statement */

	return  HandleError(hr);
}/* end of function get_CurrentTitle */

/*************************************************************************/
/* Function: get_CurrentChapter                                          */
/* Description: Gets current chapter                                     */
/*************************************************************************/
STDMETHODIMP CMSWebDVD::get_CurrentChapter(long *pVal){

    HRESULT hr = S_OK;

    try {        
        if(NULL == pVal){

            throw(E_POINTER);
        }/* end of if statement */

        INITIALIZE_GRAPH_IF_NEEDS_TO_BE

        if(!m_pDvdInfo2){

            throw(E_UNEXPECTED);
        }/* end of if statement */

        DVD_PLAYBACK_LOCATION2 dvdLocation;

        RETRY_IF_IN_FPDOM(m_pDvdInfo2->GetCurrentLocation(&dvdLocation));

        if(SUCCEEDED(hr)){

            *pVal = dvdLocation.ChapterNum;
        }
        else {

            *pVal = 0;
        }/* end of if statement */
    }/* end of try statement */
    catch(HRESULT hrTmp){

        hr = hrTmp;
    }
    catch(...){

        hr = E_UNEXPECTED;
    }/* end of catch statement */

	return  HandleError(hr);
}/* end of function get_CurrentChapter */

/*************************************************************************/
/* Function: get_FramesPerSecond                                         */
/* Description: Gets number of frames per second.                        */
/*************************************************************************/
STDMETHODIMP CMSWebDVD::get_FramesPerSecond(long *pVal){

    HRESULT hr = S_OK;

    try {       
        if(NULL == pVal){

            throw(E_POINTER);
        }/* end of if statement */

        INITIALIZE_GRAPH_IF_NEEDS_TO_BE

        if(!m_pDvdInfo2){

            throw(E_UNEXPECTED);
        }/* end of if statement */

         DVD_PLAYBACK_LOCATION2 dvdLocation;

        hr = m_pDvdInfo2->GetCurrentLocation(&dvdLocation);

        // we handle right now only 25 and 30 fps at the moment
		if( dvdLocation.TimeCodeFlags & DVD_TC_FLAG_25fps ) {
			*pVal = 25;
		} else if( dvdLocation.TimeCodeFlags & DVD_TC_FLAG_30fps ) {
			*pVal = 30;
		} else {
			// unknown
			*pVal = 0;
		}/* end of if statement */

    }/* end of try statement */
    catch(HRESULT hrTmp){

        hr = hrTmp;
    }/* end of catch statement */
    catch(...){

        hr = E_UNEXPECTED;
    }/* end of catch statement */

	return HandleError(hr);
}/* end of function get_FramesPerSecond */

/*************************************************************************/
/* Function: get_CurrentTime                                             */
/* Description: Gets current time.                                       */
/*************************************************************************/
STDMETHODIMP CMSWebDVD::get_CurrentTime(BSTR *pVal){

    HRESULT hr = S_OK;

    try {       
        if(NULL == pVal){

            throw(E_POINTER);
        }/* end of if statement */

        INITIALIZE_GRAPH_IF_NEEDS_TO_BE

        if(!m_pDvdInfo2){

            throw(E_UNEXPECTED);
        }/* end of if statement */

        DVD_PLAYBACK_LOCATION2 dvdLocation;

        hr = m_pDvdInfo2->GetCurrentLocation(&dvdLocation);
        
        DVDTime2bstr(&(dvdLocation.TimeCode), pVal);          
    }/* end of try statement */
    catch(HRESULT hrTmp){

        hr = hrTmp;
    }/* end of catch statement */
    catch(...){

        hr = E_UNEXPECTED;
    }/* end of catch statement */

	return HandleError(hr);
}/* end of function get_CurrentTime */

/*************************************************************************/
/* Function: get_DVDDirectory                                            */
/* Description: Gets the root of the DVD drive.                          */
/*************************************************************************/
STDMETHODIMP CMSWebDVD::get_DVDDirectory(BSTR *pVal){

    HRESULT hr = S_OK;

    try {
        if(NULL == pVal){

            throw(E_POINTER);
        }/* end of if statement */

        INITIALIZE_GRAPH_IF_NEEDS_TO_BE   
    
        if(!m_pDvdInfo2){

            throw(E_UNEXPECTED);
        }/* end of if statement */
        
        WCHAR szRoot[MAX_PATH];
        ULONG ulActual;

        hr = m_pDvdInfo2->GetDVDDirectory(szRoot, MAX_PATH, &ulActual);

        *pVal = ::SysAllocString(szRoot);
    }
    catch(HRESULT hrTmp){

        hr = hrTmp;
    }/* end of catch statement */
    catch(...){

        hr = E_UNEXPECTED;
    }/* end of catch statement */
    
	return HandleError(hr);
}/* end of function get_DVDDirectory */

/*************************************************************************/
/* Function: put_DVDDirectory                                            */
/* Description: Sets the root for DVD control.                           */
/*************************************************************************/
STDMETHODIMP CMSWebDVD::put_DVDDirectory(BSTR bstrRoot){

    HRESULT hr = S_OK;

    try {
        INITIALIZE_GRAPH_IF_NEEDS_TO_BE   
    
        if(!m_pDvdCtl2){
            
            throw (E_UNEXPECTED);
        }/* end of if statement */

        hr = m_pDvdCtl2->SetDVDDirectory(bstrRoot);
    }
    catch(HRESULT hrTmp){

        hr = hrTmp;
    }/* end of catch statement */
    catch(...){

        hr = E_UNEXPECTED;
    }/* end of catch statement */
    
	return HandleError(hr);
}/* end of function put_DVDDirectory */

/*************************************************************************/
/* Function: get_CurrentDomain                                           */
/* Description: gets current DVD domain.                                 */
/*************************************************************************/
STDMETHODIMP CMSWebDVD::get_CurrentDomain(long *plDomain){

    HRESULT hr = S_OK;

    try {
        INITIALIZE_GRAPH_IF_NEEDS_TO_BE

        if(!m_pDvdInfo2){

            throw(E_UNEXPECTED);
        }/* end of if statement */

        if(NULL == plDomain){

            throw(E_POINTER);
        }/* end of if statememt */

        hr = m_pDvdInfo2->GetCurrentDomain((DVD_DOMAIN *)plDomain);
    }/* end of try statement */
    catch(HRESULT hrTmp){

        hr = hrTmp;
    }/* end of catch statement */
    catch(...){

        hr = E_UNEXPECTED;
    }/* end of catch statement */
    
	return  HandleError(hr);
}/* end of function get_CurrentDomain */

/*************************************************************************/
/* Function: get_CurrentDiscSide                                         */
/*************************************************************************/
STDMETHODIMP CMSWebDVD::get_CurrentDiscSide(long *plDiscSide){

    HRESULT hr = S_OK;

    try {    	

        if(NULL == plDiscSide){

            throw(E_POINTER);
        }/* end of if statement */
        
        ULONG ulNumOfVol;
        ULONG ulThisVolNum;
        DVD_DISC_SIDE discSide;
        ULONG ulNumOfTitles;

        INITIALIZE_GRAPH_IF_NEEDS_TO_BE   

        if(!m_pDvdInfo2){

            throw(E_UNEXPECTED);
        }/* end of if statement */

        hr = m_pDvdInfo2->GetDVDVolumeInfo( &ulNumOfVol, 
                                            &ulThisVolNum, 
                                            &discSide, 
                                            &ulNumOfTitles);
        *plDiscSide = discSide;
	}/* end of try statement */
    catch(HRESULT hrTmp){

        hr = hrTmp;
    }/* end of catch statement */
    catch(...){

        hr = E_UNEXPECTED;
    }/* end of catch statement */
    
	return  HandleError(hr);
}/* end of function get_CurrentDiscSide */

/*************************************************************************/
/* Function: get_CurrentVolume                                           */
/* Description: Gets current volume.                                     */
/*************************************************************************/
STDMETHODIMP CMSWebDVD::get_CurrentVolume(long *plVolume){

    HRESULT hr = S_OK;

    try {    	
        if(NULL == plVolume){

            throw(E_POINTER);
        }/* end of if statement */

        ULONG ulNumOfVol;
        DVD_DISC_SIDE discSide;
        ULONG ulNumOfTitles;

        INITIALIZE_GRAPH_IF_NEEDS_TO_BE   

        if(!m_pDvdInfo2){

            throw(E_UNEXPECTED);
        }/* end of if statement */

        hr = m_pDvdInfo2->GetDVDVolumeInfo( &ulNumOfVol, 
                                              (ULONG*)plVolume, 
                                               &discSide, 
                                               &ulNumOfTitles);
	}/* end of try statement */
    catch(HRESULT hrTmp){

        hr = hrTmp;
    }/* end of catch statement */
    catch(...){

        hr = E_UNEXPECTED;
    }/* end of catch statement */
    
	return  HandleError(hr);
}/* end of function get_CurrentVolume */

/*************************************************************************/
/* Function: get_VolumesAvailable                                        */
/* Description: Gets total number of volumes available.                  */
/*************************************************************************/
STDMETHODIMP CMSWebDVD::get_VolumesAvailable(long *plNumOfVol){

    HRESULT hr = S_OK;

    try {    	
    
        if(NULL == plNumOfVol){

            throw(E_POINTER);
        }/* end of if statement */

        ULONG ulThisVolNum;
        DVD_DISC_SIDE discSide;
        ULONG ulNumOfTitles;

        INITIALIZE_GRAPH_IF_NEEDS_TO_BE   

        if(!m_pDvdInfo2){

            throw(E_UNEXPECTED);
        }/* end of if statement */

        hr = m_pDvdInfo2->GetDVDVolumeInfo( (ULONG*)plNumOfVol, 
                                                    &ulThisVolNum, 
                                                    &discSide, 
                                                    &ulNumOfTitles);
    }/* end of try statement */
    catch(HRESULT hrTmp){

        hr = hrTmp;
    }/* end of catch statement */
    catch(...){

        hr = E_UNEXPECTED;
    }/* end of catch statement */
    
	return  HandleError(hr);
}/* end of function get_VolumesAvailable */

/*************************************************************************/
/* Function: get_CurrentSubpictureStream                                 */
/* Description: Gets the current subpicture stream.                      */
/*************************************************************************/
STDMETHODIMP CMSWebDVD::get_CurrentSubpictureStream(long *plSubpictureStream){

    HRESULT hr = S_OK;

    try {
        INITIALIZE_GRAPH_IF_NEEDS_TO_BE

        if(!m_pDvdInfo2){

            throw(E_UNEXPECTED);
        }/* end of if statement */

        ULONG ulStreamsAvailable = 0L;
        BOOL  bIsDisabled = TRUE;    

        RETRY_IF_IN_FPDOM(m_pDvdInfo2->GetCurrentSubpicture(&ulStreamsAvailable, (ULONG*)plSubpictureStream, &bIsDisabled ));
    }/* end of try statement */
    catch(HRESULT hrTmp){
        hr = hrTmp;
    }/* end of catch statement */
    catch(...){
        hr = E_UNEXPECTED;
    }/* end of catch statement */

	return  HandleError(hr);
}/* end of function get_CurrentSubpictureStream */

/*************************************************************************/
/* Function: put_CurrentSubpictureStream                                 */
/* Description: Sets the current subpicture stream.                      */
/*************************************************************************/
STDMETHODIMP CMSWebDVD::put_CurrentSubpictureStream(long lSubpictureStream){

    HRESULT hr = S_OK;

    try {
        INITIALIZE_GRAPH_IF_NEEDS_TO_BE

        if(!m_pDvdCtl2){

            throw(E_UNEXPECTED);
        }/* end of if statement */

        if(!m_pDvdInfo2){

            throw(E_UNEXPECTED);
        }/* end of if statement */

        if( lSubpictureStream < cgDVD_MIN_SUBPICTURE 
            || (lSubpictureStream > cgDVD_MAX_SUBPICTURE 
            && lSubpictureStream != cgDVD_ALT_SUBPICTURE)){

            throw(E_INVALIDARG);
        }/* end of if statement */
         
        RETRY_IF_IN_FPDOM(m_pDvdCtl2->SelectSubpictureStream(lSubpictureStream,0,0));

        if(FAILED(hr)){

            throw(hr);
        }/* end of if statement */

        // now enabled the subpicture stream if it is not enabled
        ULONG ulStraemsAvial = 0L, ulCurrentStrean = 0L;
        BOOL fDisabled = TRUE;
        hr = m_pDvdInfo2->GetCurrentSubpicture(&ulStraemsAvial, &ulCurrentStrean, &fDisabled);

        if(FAILED(hr)){

            throw(hr);
        }/* end of if statement */

        if(TRUE == fDisabled){

            hr = m_pDvdCtl2->SetSubpictureState(TRUE,0,0); //turn it on
        }/* end of if statement */
    }/* end of try statement */
    catch(HRESULT hrTmp){
        hr = hrTmp;
    }/* end of catch statement */
    catch(...){
        hr = E_UNEXPECTED;
    }/* end of catch statement */

	return  HandleError(hr);
}/* end of function put_CurrentSubpictureStream */

/*************************************************************************/
/* Function: get_SubpictureOn                                            */
/* Description: Gets the current subpicture status On or Off             */
/*************************************************************************/
STDMETHODIMP CMSWebDVD::get_SubpictureOn(VARIANT_BOOL *pfDisplay){

    HRESULT hr = S_OK;

    try {
        if(NULL == pfDisplay){

            throw(E_POINTER);
        }/* end of if statement */

        INITIALIZE_GRAPH_IF_NEEDS_TO_BE

        if(!m_pDvdInfo2){

            throw(E_UNEXPECTED);
        }/* end of if statement */
    
        ULONG ulSubpictureStream = 0L, ulStreamsAvailable = 0L;
        BOOL fDisabled = TRUE;    

        RETRY_IF_IN_FPDOM(m_pDvdInfo2->GetCurrentSubpicture(&ulStreamsAvailable, &ulSubpictureStream, &fDisabled))
    
        if(SUCCEEDED(hr)){

            *pfDisplay = fDisabled == FALSE ? VARIANT_TRUE : VARIANT_FALSE; // compensate for -1 true in OLE
        }/* end of if statement */
    }/* end of try statement */
    catch(HRESULT hrTmp){
        hr = hrTmp;
    }/* end of catch statement */
    catch(...){
        hr = E_UNEXPECTED;
    }/* end of catch statement */

    return  HandleError(hr);
}/* end of function get_SubpictureOn */

/*************************************************************************/
/* Function: put_SubpictureOn                                            */
/* Description: Turns the subpicture On or Off                           */
/*************************************************************************/
STDMETHODIMP CMSWebDVD::put_SubpictureOn(VARIANT_BOOL fDisplay){

    HRESULT hr = S_OK;

    try {
        INITIALIZE_GRAPH_IF_NEEDS_TO_BE

        if(!m_pDvdInfo2){

            throw(E_UNEXPECTED);
        }/* end of if statement */

        if(!m_pDvdCtl2){

            throw(E_UNEXPECTED);
        }/* end of if statement */
    
        ULONG ulSubpictureStream = 0L, ulStreamsAvailable = 0L;
        BOOL  bIsDisabled = TRUE;    

        RETRY_IF_IN_FPDOM(m_pDvdInfo2->GetCurrentSubpicture(&ulStreamsAvailable, &ulSubpictureStream, &bIsDisabled ));

        if(FAILED(hr)){

            throw(hr);
        }/* end of if statement */

        BOOL bDisplay = fDisplay == VARIANT_FALSE ? FALSE : TRUE; // compensate for -1 true in OLE

        hr = m_pDvdCtl2->SetSubpictureState(bDisplay,0,0);
    }/* end of try statement */
    catch(HRESULT hrTmp){
        hr = hrTmp;
    }/* end of catch statement */
    catch(...){
        hr = E_UNEXPECTED;
    }/* end of catch statement */

    return  HandleError(hr);
}/* end of function put_SubpictureOn */

/*************************************************************************/
/* Function: get_SubpictureStreamsAvailable                              */
/* Description: gets the number of streams available.                    */
/*************************************************************************/
STDMETHODIMP CMSWebDVD::get_SubpictureStreamsAvailable(long *plStreamsAvailable){

    HRESULT hr = S_OK;

    try {
	    if (NULL == plStreamsAvailable){

            throw(E_POINTER);         
        }/* end of if statement */

        INITIALIZE_GRAPH_IF_NEEDS_TO_BE

        if(!m_pDvdInfo2){

            throw(E_UNEXPECTED);
        }/* end of if statement */

        ULONG ulSubpictureStream = 0L;
        *plStreamsAvailable = 0L;
        BOOL  bIsDisabled = TRUE;    

        RETRY_IF_IN_FPDOM(m_pDvdInfo2->GetCurrentSubpicture((ULONG*)plStreamsAvailable, &ulSubpictureStream, &bIsDisabled));
    }/* end of try statement */
    catch(HRESULT hrTmp){
        hr = hrTmp;
    }/* end of catch statement */
    catch(...){
        hr = E_UNEXPECTED;
    }/* end of catch statement */

    return  HandleError(hr);
}/* end of function get_SubpictureStreamsAvailable */

/*************************************************************************/
/* Function: get_TotalTitleTime                                          */
/* Description: Gets total time in the title.                            */
/*************************************************************************/
STDMETHODIMP CMSWebDVD::get_TotalTitleTime(BSTR *pTime){

    HRESULT hr = S_OK;

    try {
        if(NULL == pTime){

            throw(E_POINTER);
        }/* end of if statement */

        INITIALIZE_GRAPH_IF_NEEDS_TO_BE

        if(!m_pDvdInfo2){

            throw(E_UNEXPECTED);
        }/* end of if statement */

        DVD_HMSF_TIMECODE tcTime;
        ULONG ulFlags;	// contains 30fps/25fps
        hr =  m_pDvdInfo2->GetTotalTitleTime(&tcTime, &ulFlags);

        if(FAILED(hr)){

            throw(hr);
        }/* end of if statement */
        
        hr = DVDTime2bstr(&tcTime, pTime);
    }/* end of try statement */
    catch(HRESULT hrTmp){

        hr = hrTmp;
    }/* end of catch statement */
    catch(...){

        hr = E_UNEXPECTED;
    }/* end of catch statement */

	return HandleError(hr);
}/* end of function get_TotalTitleTime */ 

/*************************************************************************/
/* Function: get_CurrentCCService                                        */
/* Description: Gets current closed caption service.                     */
/*************************************************************************/
STDMETHODIMP CMSWebDVD::get_CurrentCCService(long *plService){

    HRESULT hr = S_OK;

    try {
        INITIALIZE_GRAPH_IF_NEEDS_TO_BE

        if(!m_pDvdGB){

            throw(E_UNEXPECTED);
        }/* end of if statement */

        if(NULL == plService){

            throw(E_POINTER);
        }/* end of if statement */            
     
        CComPtr<IAMLine21Decoder> pLine21Dec;
        hr = m_pDvdGB->GetDvdInterface(IID_IAMLine21Decoder, (LPVOID *)&pLine21Dec);

        if (FAILED(hr)){

            throw(hr);
        }/* end of if statement */
    
        AM_LINE21_CCSERVICE Service;
        RETRY_IF_IN_FPDOM(pLine21Dec->GetCurrentService(&Service));

        if (FAILED(hr)){

            throw(hr);
        }/* end of if statement */

        *plService = (ULONG)Service;
    }/* end of try statement */
    catch(HRESULT hrTmp){

        hr = hrTmp;
    }/* end of catch statement */
    catch(...){

        hr = E_UNEXPECTED;
    }/* end of catch statement */

    return HandleError(hr);
}/* end of function get_CurrentCCService */

/*************************************************************************/
/* Function: put_CurrentCCService                                        */
/* Description: Sets current closed caption service.                     */
/*************************************************************************/
STDMETHODIMP CMSWebDVD::put_CurrentCCService(long lService){

    HRESULT hr = S_OK;

    try {        
        if(lService < 0){

            throw(E_INVALIDARG);       
        }/* end of if statement */

        INITIALIZE_GRAPH_IF_NEEDS_TO_BE

        if(!m_pDvdGB){

            throw(E_UNEXPECTED);            
        }/* end of if statement */

        CComPtr<IAMLine21Decoder> pLine21Dec;

        hr = m_pDvdGB->GetDvdInterface(IID_IAMLine21Decoder, (LPVOID *)&pLine21Dec);

        if (FAILED(hr)){

            throw(hr);
        }/* end of if statement */
    
        RETRY_IF_IN_FPDOM(pLine21Dec->SetCurrentService((AM_LINE21_CCSERVICE)lService));		
    }/* end of try statement */
    catch(HRESULT hrTmp){

        hr = hrTmp;
    }/* end of catch statement */
    catch(...){

        hr = E_UNEXPECTED;
    }/* end of catch statement */

    return HandleError(hr);
}/* end of function put_CurrentCCService */

/*************************************************************************/
/* Function: get_CurrentButton                                           */
/* Description: Gets currently selected button.                          */
/*************************************************************************/
STDMETHODIMP CMSWebDVD::get_CurrentButton(long *plCurrentButton){

    HRESULT hr = S_OK;

    try {
        if(NULL == plCurrentButton){

            throw(E_POINTER);
        }/* end of if statement */            

        if(!m_pDvdInfo2){

            throw(E_UNEXPECTED);
        }/* end of if statement */

        ULONG ulNumButtons = 0L;
        *plCurrentButton = 0;

        hr = m_pDvdInfo2->GetCurrentButton(&ulNumButtons, (ULONG*)plCurrentButton);
    }/* end of try statement */
    catch(HRESULT hrTmp){

        hr = hrTmp;
    }/* end of catch statement */
    catch(...){

        hr = E_UNEXPECTED;
    }/* end of catch statement */

    return HandleError(hr);
}/* end of function get_CurrentButton */

/*************************************************************************/
/* Function: get_ButtonsAvailable                                        */
/* Description: Gets the count of the available buttons.                 */
/*************************************************************************/
STDMETHODIMP CMSWebDVD::get_ButtonsAvailable(long *plNumButtons){

    HRESULT hr = S_OK;

    try {
        if(!m_pDvdInfo2){

            throw(E_UNEXPECTED);
        }/* end of if statement */

        ULONG ulCurrentButton = 0L;

        hr = m_pDvdInfo2->GetCurrentButton((ULONG*)plNumButtons, &ulCurrentButton);

    }/* end of try statement */
    catch(HRESULT hrTmp){

        hr = hrTmp;
    }/* end of catch statement */
    catch(...){

        hr = E_UNEXPECTED;
    }/* end of catch statement */

    return HandleError(hr);
}/* end of function get_ButtonsAvailable */

/*************************************************************************/
/* Function: get_CCActive                                                */
/* Description: Gets the state of the closed caption service.            */
/*************************************************************************/
STDMETHODIMP CMSWebDVD::get_CCActive(VARIANT_BOOL *fState){

    HRESULT hr = S_OK;

    try {        
        if(NULL == fState ){

            throw(E_POINTER);            
        }/* end of if statement */

        INITIALIZE_GRAPH_IF_NEEDS_TO_BE

        if(!m_pDvdGB){
        
            throw(E_UNEXPECTED);            
        }/* end of if statement */

        CComPtr<IAMLine21Decoder> pLine21Dec;
        hr = m_pDvdGB->GetDvdInterface(IID_IAMLine21Decoder, (LPVOID *)&pLine21Dec);
    
        if (FAILED(hr)){

            throw(hr);
        }/* end of if statement */

        AM_LINE21_CCSTATE State;
        RETRY_IF_IN_FPDOM(pLine21Dec->GetServiceState(&State));

        if (FAILED(hr)){

            throw(hr);
        }/* end of if statement */

        if(AM_L21_CCSTATE_On == State){

            *fState = VARIANT_TRUE; // OLE TRUE
        }
        else {

            *fState = VARIANT_FALSE;
        }/* end of if statement */
    }/* end of try statement */
    catch(HRESULT hrTmp){

        hr = hrTmp;
    }/* end of catch statement */
    catch(...){

        hr = E_UNEXPECTED;
    }/* end of catch statement */

	return HandleError(hr);
}/* end of function get_CCActive */

/*************************************************************************/
/* Function: put_CCActive                                                */
/* Description: Sets the ccActive state                                  */
/*************************************************************************/
STDMETHODIMP CMSWebDVD::put_CCActive(VARIANT_BOOL fState){

    HRESULT hr = S_OK;

    try {
        INITIALIZE_GRAPH_IF_NEEDS_TO_BE

        if(!m_pDvdGB){

            throw(E_UNEXPECTED);
        }/* end of if statement */

	    CComPtr<IAMLine21Decoder> pLine21Dec;
        hr = m_pDvdGB->GetDvdInterface(IID_IAMLine21Decoder, (LPVOID *)&pLine21Dec);
    
        if (FAILED(hr)){

            throw(hr);
        }/* end of if statement */

        AM_LINE21_CCSTATE ccState = (fState == VARIANT_FALSE ? AM_L21_CCSTATE_Off: AM_L21_CCSTATE_On);

        RETRY_IF_IN_FPDOM(pLine21Dec->SetServiceState(ccState));
    }/* end of try statement */
    catch(HRESULT hrTmp){

        hr = hrTmp;
    }/* end of catch statement */
    catch(...){

        hr = E_UNEXPECTED;
    }/* end of catch statement */

	return HandleError(hr);
}/* end of function put_CCActive */

/*************************************************************************/
/* Function: get_CurrentAngle                                            */
/* Description: Gets current angle.                                      */
/*************************************************************************/
STDMETHODIMP CMSWebDVD::get_CurrentAngle(long *plAngle){

    HRESULT hr = S_OK;

    try {
        if(NULL == plAngle){

            throw(E_POINTER);
        }/* end of if statement */

        INITIALIZE_GRAPH_IF_NEEDS_TO_BE

        if(!m_pDvdInfo2){

            throw(E_UNEXPECTED);
        }/* end of if statement */
        
        ULONG ulAnglesAvailable = 0;
        RETRY_IF_IN_FPDOM(m_pDvdInfo2->GetCurrentAngle(&ulAnglesAvailable, (ULONG*)plAngle));
    }/* end of try statement */
    catch(HRESULT hrTmp){

        hr = hrTmp;
    }/* end of catch statement */
    catch(...){

        hr = E_UNEXPECTED;
    }/* end of catch statement */

	return HandleError(hr);
}/* end of function get_CurrentAngle */

/*************************************************************************/
/* Function: put_CurrentAngle                                            */
/* Description: Sets the current angle (different DVD angle track.)      */
/*************************************************************************/
STDMETHODIMP CMSWebDVD::put_CurrentAngle(long lAngle){

    HRESULT hr = S_OK;

    try {
        if( lAngle < cgDVD_MIN_ANGLE || lAngle > cgDVD_MAX_ANGLE ){

            throw(E_INVALIDARG);
        }/* end of if statement */

        INITIALIZE_GRAPH_IF_NEEDS_TO_BE_AND_PLAY

        if(!m_pDvdCtl2){

            throw(E_UNEXPECTED);
        }/* end of if statement */
      
        RETRY_IF_IN_FPDOM(m_pDvdCtl2->SelectAngle(lAngle,0,0));          
    }/* end of try statement */
    catch(HRESULT hrTmp){

        hr = hrTmp;
    }/* end of catch statement */
    catch(...){

        hr = E_UNEXPECTED;
    }/* end of catch statement */

	return HandleError(hr);
}/* end of function put_CurrentAngle */

/*************************************************************************/
/* Function: get_AnglesAvailable                                         */
/* Description: Gets the number of angles available.                     */
/*************************************************************************/
STDMETHODIMP CMSWebDVD::get_AnglesAvailable(long *plAnglesAvailable){

    HRESULT hr = S_OK;

    try {
        if(NULL == plAnglesAvailable){

            throw(E_POINTER);
        }/* end of if statement */

        INITIALIZE_GRAPH_IF_NEEDS_TO_BE

        if(!m_pDvdInfo2){

            throw(E_UNEXPECTED);
        }/* end of if statement */
        
        ULONG ulCurrentAngle = 0;
        RETRY_IF_IN_FPDOM(m_pDvdInfo2->GetCurrentAngle((ULONG*)plAnglesAvailable, &ulCurrentAngle));
    }/* end of try statement */
    catch(HRESULT hrTmp){

        hr = hrTmp;
    }/* end of catch statement */
    catch(...){

        hr = E_UNEXPECTED;
    }/* end of catch statement */

	return HandleError(hr);
}/* end of function get_AnglesAvailable */

/*************************************************************************/
/* Function: get_AudioStreamsAvailable                                   */
/* Description: Gets number of available Audio Streams                   */
/*************************************************************************/
STDMETHODIMP CMSWebDVD::get_AudioStreamsAvailable(long *plNumAudioStreams){

    HRESULT hr = S_OK;

    try {
        if(NULL == plNumAudioStreams){

            throw(E_POINTER);
        }/* end of if statement */

        INITIALIZE_GRAPH_IF_NEEDS_TO_BE

        if(!m_pDvdInfo2){

            throw(E_UNEXPECTED);
        }/* end of if statement */

        ULONG ulCurrentStream;

        RETRY_IF_IN_FPDOM(m_pDvdInfo2->GetCurrentAudio((ULONG*)plNumAudioStreams, &ulCurrentStream));
    }/* end of try statement */
    catch(HRESULT hrTmp){

        hr = hrTmp;
    }/* end of catch statement */
    catch(...){

        hr = E_UNEXPECTED;
    }/* end of catch statement */

	return HandleError(hr);
}/* end of function get_AudioStreamsAvailable */

/*************************************************************************/
/* Function: get_CurrentAudioStream                                      */
/* Description: Gets current audio stream.                               */
/*************************************************************************/
STDMETHODIMP CMSWebDVD::get_CurrentAudioStream(long *plCurrentStream){

    HRESULT hr = S_OK;

    try {
        if(NULL == plCurrentStream){

            throw(E_POINTER);
        }/* end of if statement */

        INITIALIZE_GRAPH_IF_NEEDS_TO_BE

        if(!m_pDvdInfo2){

            throw(E_UNEXPECTED);
        }/* end of if statement */

        ULONG ulNumAudioStreams;

        RETRY_IF_IN_FPDOM(m_pDvdInfo2->GetCurrentAudio(&ulNumAudioStreams, (ULONG*)plCurrentStream ));
    }/* end of try statement */
    catch(HRESULT hrTmp){

        hr = hrTmp;
    }/* end of catch statement */
    catch(...){

        hr = E_UNEXPECTED;
    }/* end of catch statement */

	return HandleError(hr);
}/* end of function get_CurrentAudioStream */

/*************************************************************************/
/* Function: put_CurrentAudioStream                                      */
/* Description: Changes the current audio stream.                        */
/*************************************************************************/
STDMETHODIMP CMSWebDVD::put_CurrentAudioStream(long lAudioStream){

    HRESULT hr = S_OK;

    try {
        INITIALIZE_GRAPH_IF_NEEDS_TO_BE

        if(!m_pDvdCtl2){

            throw(E_UNEXPECTED);
        }/* end of if statement */

        RETRY_IF_IN_FPDOM(m_pDvdCtl2->SelectAudioStream(lAudioStream,0,0));            
    }/* end of try statement */
    catch(HRESULT hrTmp){

        hr = hrTmp;
    }/* end of catch statement */
    catch(...){

        hr = E_UNEXPECTED;
    }/* end of catch statement */

	return HandleError(hr);
}/* end of function put_CurrentAudioStream */

/*************************************************************************/
/* Function: get_ColorKey                                                */
/* Description: Gets the current color key. Goes to the dshow if we have */
/* a graph otherwise just gets the cached color key.                     */
/*************************************************************************/
STDMETHODIMP CMSWebDVD::get_ColorKey(long *pClr){

    HRESULT hr = S_OK;

    try {
        if( NULL == pClr ){

            throw(E_POINTER);
        }/* end of if statement */

        *pClr = 0; // cleanup the variable

        COLORREF clr;
        ::ZeroMemory(&clr, sizeof(COLORREF));
        
        hr = GetColorKey(&clr); // we get COLORREF HERE and CANNOT be palette index
        
        HWND hwnd = ::GetDesktopWindow();
        HDC hdc = ::GetWindowDC(hwnd);

        if(NULL == hdc){
            
            throw(E_UNEXPECTED);
        }/* end of if statement */

        clr = ::GetNearestColor(hdc, clr);        
        ::ReleaseDC(hwnd, hdc);
    
        // handles only case when getting RGB BACK, which is taken care of in the GetColorKey function
        *pClr = ((OLE_COLOR)(((BYTE)(GetBValue(clr))|((WORD)((BYTE)(GetGValue(clr)))<<8))|(((DWORD)(BYTE)(GetRValue(clr)))<<16)));

        if(FAILED(hr)){

            if(false == m_fInitialized){

                *pClr = ((OLE_COLOR)(((BYTE)(GetBValue(m_clrColorKey))|((WORD)((BYTE)(GetGValue(m_clrColorKey)))<<8))|(((DWORD)(BYTE)(GetRValue(m_clrColorKey)))<<16))); // give them our default value
                throw(S_FALSE); // we are not initialized yet, so probably we are called from property bag
            }/* end of if statement */
            throw(hr);
        }/* end of if statement */

        m_clrColorKey = clr; // cache up the value
    }/* end of try statement */
    catch(HRESULT hrTmp){

        hr = hrTmp;
    }/* end of catch statement */
    catch(...){

        hr = E_UNEXPECTED;
    }/* end of catch statement */

	return HandleError(hr);	
}/* end of function get_ColorKey */

/*************************************************************************/
/* Function: put_ColorKey                                                */
/* Description: Sets the color key.                                      */
/*************************************************************************/
STDMETHODIMP CMSWebDVD::put_ColorKey(long clr){

	HRESULT hr = S_OK;

    try {                    

#if 1
        HWND hwnd = ::GetDesktopWindow();
        HDC hdc = ::GetWindowDC(hwnd);

        if(NULL == hdc){

            throw(E_UNEXPECTED);
        }/* end of if statement */

        if((::GetDeviceCaps(hdc, RASTERCAPS) & RC_PALETTE) == RC_PALETTE){
            
            clr = MAGENTA_COLOR_KEY;                            
        }/* end of if statement */

        ::ReleaseDC(hwnd, hdc);
#endif        
        BYTE r = ((BYTE)((clr)>>16));
        BYTE g = (BYTE)(((WORD)(clr)) >> 8);
        BYTE b = ((BYTE)(clr));
        COLORREF clrColorKey = RGB(r, g, b); // convert to color ref

        hr = SetColorKey(clrColorKey);

        if(FAILED(hr)){
           
            if(false == m_fInitialized){

                m_clrColorKey = clrColorKey; // cache up the value for later                
                hr = S_FALSE;
            }/* end of if statement */

            throw(hr);
        }/* end of if statement */
#if 1
        hr = GetColorKey(&m_clrColorKey);
#endif

    }/* end of try statement */
    catch(HRESULT hrTmp){

        hr = hrTmp;
    }/* end of catch statement */
    catch(...){

        hr = E_UNEXPECTED;
    }/* end of catch statement */

    return HandleError(hr);
}/* end of function put_ColorKey */

/*************************************************************************/
/* Function: put_BackColor                                               */
/* Description: Put back color is sinonymous to ColorKey when in the     */
/* windowless mode.                                                      */
/*************************************************************************/
STDMETHODIMP CMSWebDVD::put_BackColor(VARIANT clrBackColor){

    HRESULT hr = S_OK;

    try {

        VARIANT dest;
        VariantInit(&dest);
        hr = VariantChangeTypeEx(&dest, &clrBackColor, 0, 0, VT_COLOR);
        if (FAILED(hr))
            throw hr;

        hr = CStockPropImpl<CMSWebDVD, IMSWebDVD, 
            &IID_IMSWebDVD, &LIBID_MSWEBDVDLib>::put_BackColor(dest.lVal);

        if(FAILED(hr)){

            throw(hr);
        }/* end of if statement */

    }/* end of try statement */
    catch(HRESULT hrTmp){

        hr = hrTmp;
    }/* end of catch statement */
    catch(...){

        hr = E_UNEXPECTED;
    }/* end of catch statement */

    return HandleError(hr);	
}/* end of function put_BackColor */

/*************************************************************************/
/* Function: get_BackColor                                               */
/* Description: Put back color is sinonymous to ColorKey when in the     */
/* windowless mode.                                                      */
/*************************************************************************/
STDMETHODIMP CMSWebDVD::get_BackColor(VARIANT* pclrBackColor){

    HRESULT hr = S_OK;

    try {

        if ( NULL == pclrBackColor) {
            throw (E_POINTER);
        }

        OLE_COLOR clrColor;

        hr = CStockPropImpl<CMSWebDVD, IMSWebDVD, 
            &IID_IMSWebDVD, &LIBID_MSWEBDVDLib>::get_BackColor(&clrColor);

        if (FAILED(hr))
            throw(hr);

        VariantInit(pclrBackColor);
        
        pclrBackColor->vt = VT_COLOR;
        pclrBackColor->lVal = clrColor;

	}/* end of try statement */
    catch(HRESULT hrTmp){

        hr = hrTmp;
    }/* end of catch statement */
    catch(...){

        hr = E_UNEXPECTED;
    }/* end of catch statement */

    return HandleError(hr);	
}/* end of function get_BackColor */

/*************************************************************************/
/* Function: get_ReadyState                                               */
/* Description: Put back color is sinonymous to ColorKey when in the     */
/* windowless mode.                                                      */
/*************************************************************************/
STDMETHODIMP CMSWebDVD::get_ReadyState(LONG *pVal){

    HRESULT hr = S_OK;

    try {

        if (NULL == pVal) {
            throw (E_POINTER);
        }

        hr = CStockPropImpl<CMSWebDVD, IMSWebDVD, 
            &IID_IMSWebDVD, &LIBID_MSWEBDVDLib>::get_ReadyState(pVal);

        if (FAILED(hr))
            throw(hr);

	}/* end of try statement */
    catch(HRESULT hrTmp){

        hr = hrTmp;
    }/* end of catch statement */
    catch(...){

        hr = E_UNEXPECTED;
    }/* end of catch statement */

    return HandleError(hr);	
}/* end of function get_ReadyState */

/*************************************************************************/
/* Function: UOPValid                                                    */
/* Description: Tells if UOP is valid or not, valid means the feature is */
/* turned on.                                                            */
/*************************************************************************/
STDMETHODIMP CMSWebDVD::UOPValid(long lUOP, VARIANT_BOOL *pfValid){

    HRESULT hr = S_OK;

    try {
        if (NULL == pfValid){
            
            throw(E_POINTER);
        }/* end of if statement */

        if ((lUOP > 24) || (lUOP < 0)){
            
            throw(E_INVALIDARG);
        }/* end of if statement */

        INITIALIZE_GRAPH_IF_NEEDS_TO_BE

        if( !m_pDvdInfo2){
            
            throw(E_UNEXPECTED);
        }/* end of if statement */
        
        ULONG ulUOPS = 0;
        hr = m_pDvdInfo2->GetCurrentUOPS(&ulUOPS);

        *pfValid = ulUOPS & (1 << lUOP) ? VARIANT_FALSE : VARIANT_TRUE;
    }/* end of try statement */
    catch(HRESULT hrTmp){

        hr = hrTmp;
    }
    catch(...){

        hr = E_UNEXPECTED;
    }/* end of catch statement */

    return HandleError(hr);	
}/* end of function UOPValid */

/*************************************************************************/
/* Function:  GetGPRM                                                    */
/* Description: Gets the GPRM at specified index                         */
/*************************************************************************/
STDMETHODIMP CMSWebDVD::GetGPRM(long lIndex, short *psGPRM){

    HRESULT hr = E_FAIL;

    try {
	    if (NULL == psGPRM){

            throw(E_POINTER);         
        }/* end of if statement */

        GPRMARRAY gprm;
        int iArraySize = sizeof(GPRMARRAY)/sizeof(gprm[0]);

        if(0 > lIndex || iArraySize <= lIndex){

            return(E_INVALIDARG);
        }/* end of if statement */
    
        INITIALIZE_GRAPH_IF_NEEDS_TO_BE
        
        if(!m_pDvdInfo2){

            throw(E_UNEXPECTED);
        }/* end of if statement */
    
        hr = m_pDvdInfo2->GetAllGPRMs(&gprm);

        if(FAILED(hr)){

            throw(hr);
        }/* end of if statement */

        *psGPRM = gprm[lIndex];        
    }/* end of try statement */
    catch(HRESULT hrTmp){

        hr = hrTmp;
    }
    catch(...){

        hr = E_UNEXPECTED;
    }/* end of catch statement */

    return HandleError(hr);
}/* end of function GetGPRM */

/*************************************************************************/
/* Function: GetDVDTextNumberOfLanguages                                 */
/* Description: Retrieves the number of languages available.             */
/*************************************************************************/
STDMETHODIMP CMSWebDVD::GetDVDTextNumberOfLanguages(long *plNumOfLangs){

    HRESULT hr = S_OK;

    try {
        if (NULL == plNumOfLangs){
            
            throw(E_POINTER);
        }/* end of if statement */

        INITIALIZE_GRAPH_IF_NEEDS_TO_BE

        if( !m_pDvdInfo2){
            
            throw(E_UNEXPECTED);
        }/* end of if statement */
        
        ULONG ulNumOfLangs;

        RETRY_IF_IN_FPDOM(m_pDvdInfo2->GetDVDTextNumberOfLanguages(&ulNumOfLangs));        

        if(FAILED(hr)){

            throw(hr);
        }/* end of if statement */

        *plNumOfLangs = ulNumOfLangs;
    }/* end of try statement */
    catch(HRESULT hrTmp){

        hr = hrTmp;
    }
    catch(...){

        hr = E_UNEXPECTED;
    }/* end of catch statement */

    return HandleError(hr);	
}/* end of function GetDVDTextNumberOfLanguages */

/*************************************************************************/
/* Function: GetDVDTextNumberOfStrings                                   */
/* Description: Gets the number of strings in the partical language.     */
/*************************************************************************/
STDMETHODIMP CMSWebDVD::GetDVDTextNumberOfStrings(long lLangIndex, long *plNumOfStrings){

HRESULT hr = S_OK;

    try {
        if (NULL == plNumOfStrings){
            
            throw(E_POINTER);
        }/* end of if statement */

        INITIALIZE_GRAPH_IF_NEEDS_TO_BE

        if( !m_pDvdInfo2){
            
            throw(E_UNEXPECTED);
        }/* end of if statement */

        LCID wLangCode;
        ULONG uNumOfStings;
        DVD_TextCharSet charSet;
        RETRY_IF_IN_FPDOM(m_pDvdInfo2->GetDVDTextLanguageInfo(lLangIndex, &uNumOfStings, &wLangCode, &charSet));        

        if(FAILED(hr)){

            throw(hr);
        }/* end of if statement */

        *plNumOfStrings = uNumOfStings;
    }/* end of try statement */
    catch(HRESULT hrTmp){

        hr = hrTmp;
    }
    catch(...){

        hr = E_UNEXPECTED;
    }/* end of catch statement */

    return HandleError(hr);	
}/* end of function GetDVDTextNumberOfStrings */

/*************************************************************/
/* Name: GetDVDTextLanguageLCID
/* Description: Get the LCID of an index of the DVD texts
/*************************************************************/
STDMETHODIMP CMSWebDVD::GetDVDTextLanguageLCID(long lLangIndex, long *lcid)
{
HRESULT hr = S_OK;

    try {
        if (NULL == lcid){
            
            throw(E_POINTER);
        }/* end of if statement */

        INITIALIZE_GRAPH_IF_NEEDS_TO_BE

        if( !m_pDvdInfo2){
            
            throw(E_UNEXPECTED);
        }/* end of if statement */

        LCID wLangCode;
        ULONG uNumOfStings;
        DVD_TextCharSet charSet;
        RETRY_IF_IN_FPDOM(m_pDvdInfo2->GetDVDTextLanguageInfo(lLangIndex, &uNumOfStings, &wLangCode, &charSet));        

        if(FAILED(hr)){

            throw(hr);
        }/* end of if statement */

        *lcid = wLangCode;
    }/* end of try statement */
    catch(HRESULT hrTmp){

        hr = hrTmp;
    }
    catch(...){

        hr = E_UNEXPECTED;
    }/* end of catch statement */

    return HandleError(hr);	
}/* end of function GetDVDTextLanguageLCID */

/*************************************************************************/
/* Function: GetDVDtextString                                            */
/* Description: Gets the DVD Text string at specific location.           */
/*************************************************************************/
STDMETHODIMP CMSWebDVD::GetDVDTextString(long lLangIndex, long lStringIndex, BSTR *pstrText){

    HRESULT hr = S_OK;

    try {
        if (NULL == pstrText){
            
            throw(E_POINTER);
        }/* end of if statement */

        INITIALIZE_GRAPH_IF_NEEDS_TO_BE

        if( !m_pDvdInfo2){
            
            throw(E_UNEXPECTED);
        }/* end of if statement */
        
        ULONG ulSize; 
        DVD_TextStringType type;
        RETRY_IF_IN_FPDOM(m_pDvdInfo2->GetDVDTextStringAsUnicode(lLangIndex, lStringIndex,  NULL, 0, &ulSize, &type));

        if(FAILED(hr)){

            throw(hr);
        }/* end of if statement */
        
        if (ulSize == 0) {
            *pstrText = ::SysAllocString(L"");
        }

        else {
            // got the length so lets allocate a buffer of that size
            WCHAR* wstrBuff = new WCHAR[ulSize];
            
            ULONG ulActualSize;
            hr = m_pDvdInfo2->GetDVDTextStringAsUnicode(lLangIndex, lStringIndex,  wstrBuff, ulSize, &ulActualSize, &type);
            
            ATLASSERT(ulActualSize == ulSize);
            
            if(FAILED(hr)){
                
                delete [] wstrBuff;
                throw(hr);
            }/* end of if statement */
            
            *pstrText = ::SysAllocString(wstrBuff);
            delete [] wstrBuff;
        }/* end of if statement */

    }/* end of try statement */
    catch(HRESULT hrTmp){

        hr = hrTmp;
    }
    catch(...){

        hr = E_UNEXPECTED;
    }/* end of catch statement */

    return HandleError(hr);	
}/* end of function GetDVDtextString */

/*************************************************************************/
/* Function: GetDVDTextStringType                                        */
/* Description: Gets the type of the string at the specified location.   */
/*************************************************************************/
STDMETHODIMP CMSWebDVD::GetDVDTextStringType(long lLangIndex, long lStringIndex, DVDTextStringType *pType){

    HRESULT hr = S_OK;

    try {
        if (NULL == pType){
            
            throw(E_POINTER);
        }/* end of if statement */

        INITIALIZE_GRAPH_IF_NEEDS_TO_BE

        if( !m_pDvdInfo2){
            
            throw(E_UNEXPECTED);
        }/* end of if statement */

        ULONG ulTheSize;
        DVD_TextStringType type;
        RETRY_IF_IN_FPDOM(m_pDvdInfo2->GetDVDTextStringAsUnicode(lLangIndex, lStringIndex,  NULL, 0, &ulTheSize, &type));

        if(SUCCEEDED(hr)){

            *pType = (DVDTextStringType) type;
        }/* end of if statement */
    }/* end of try statement */
    catch(HRESULT hrTmp){

        hr = hrTmp;
    }
    catch(...){

        hr = E_UNEXPECTED;
    }/* end of catch statement */

    return HandleError(hr);	
}/* end of function GetDVDTextStringType */

/*************************************************************************/
/* Function: GetSPRM                                                     */
/* Description: Gets SPRM at the specific index.                         */
/*************************************************************************/
STDMETHODIMP CMSWebDVD::GetSPRM(long lIndex, short *psSPRM){

    HRESULT hr = E_FAIL;

    try {
	    if (NULL == psSPRM){

            throw(E_POINTER);         
        }/* end of if statement */

        SPRMARRAY sprm;                
        int iArraySize = sizeof(SPRMARRAY)/sizeof(sprm[0]);

        if(0 > lIndex || iArraySize <= lIndex){

            return(E_INVALIDARG);
        }/* end of if statement */

        INITIALIZE_GRAPH_IF_NEEDS_TO_BE
        
        if(!m_pDvdInfo2){

            throw(E_UNEXPECTED);
        }/* end of if statement */
        
        hr = m_pDvdInfo2->GetAllSPRMs(&sprm);

        if(FAILED(hr)){

            throw(hr);
        }/* end of if statement */
        
        *psSPRM = sprm[lIndex];            
    }/* end of try statement */
    catch(HRESULT hrTmp){

        hr = hrTmp;
    }
    catch(...){

        hr = E_UNEXPECTED;
    }/* end of catch statement */

    return HandleError(hr);
}/* end of function GetSPRM */

/*************************************************************************/
/* Function: get_DVDUniqueID                                             */
/* Description: Gets the UNIQUE ID that identifies the string.           */
/*************************************************************************/
STDMETHODIMP CMSWebDVD::get_DVDUniqueID(BSTR *pStrID){

    HRESULT hr = E_FAIL;

    try {
        // TODO: Be able to get m_pDvdInfo2 without initializing the graph
	    if (NULL == pStrID){

            throw(E_POINTER);         
        }/* end of if statement */

        INITIALIZE_GRAPH_IF_NEEDS_TO_BE
        
        if(!m_pDvdInfo2){

            throw(E_UNEXPECTED);
        }/* end of if statement */

        ULONGLONG ullUniqueID;

        hr = m_pDvdInfo2->GetDiscID(NULL, &ullUniqueID);
                                 
        if(FAILED(hr)){

            throw(hr);
        }/* end of if statement */

        //TODO: Get rid of the STDLIB call!!
        // taken out of WMP

        // Script can't handle a 64 bit value so convert it to a string.
        // Doc's say _ui64tow returns 33 bytes (chars?) max.
        // we'll use double that just in case...
        //
        WCHAR wszBuffer[66];
        _ui64tow( ullUniqueID, wszBuffer, 10);
        *pStrID = SysAllocString(wszBuffer);

    }/* end of try statement */
    catch(HRESULT hrTmp){

        hr = hrTmp;
    }
    catch(...){

        hr = E_UNEXPECTED;
    }/* end of catch statement */

    return HandleError(hr);
}/* end of function get_DVDUniqueID */

/*************************************************************************/
/* Function: get_EnableResetOnStop                                      */
/* Description: Gets the flag.                                           */
/*************************************************************************/
STDMETHODIMP CMSWebDVD::get_EnableResetOnStop(VARIANT_BOOL *pVal){

    HRESULT hr = S_OK;

    try {

        if(NULL == pVal){

            throw(E_POINTER);
        }/* end of if statement */
    
        *pVal = m_fEnableResetOnStop ? VARIANT_TRUE: VARIANT_FALSE;
    }/* end of try statement */
    catch(HRESULT hrTmp){

        hr = hrTmp;
    }
    catch(...){

        hr = E_UNEXPECTED;
    }/* end of catch statement */

    return HandleError(hr);
}/* end of function get_EnableResetOnStop */

/*************************************************************************/
/* Function: put_EnableResetOnStop                                      */
/* Description: Sets the flag. The flag is used only on stop and play.   */
/* Transitions.                                                          */
/*************************************************************************/
STDMETHODIMP CMSWebDVD::put_EnableResetOnStop(VARIANT_BOOL newVal){

    HRESULT hr = S_OK;

    try {

        BOOL fEnable = (VARIANT_FALSE == newVal) ? FALSE: TRUE;
        BOOL fEnableOld = m_fEnableResetOnStop;

        m_fEnableResetOnStop = fEnable;

        if(!m_pDvdCtl2){

            throw(S_FALSE); // we might not have initialized graph as of yet, but will
            // defer this to play state
        }/* end of if statement */

        hr = m_pDvdCtl2->SetOption(DVD_ResetOnStop, fEnable);

        if(FAILED(hr)){

            m_fEnableResetOnStop = fEnableOld; // restore the old state
        }/* end of if statement */
        
    }/* end of try statement */
    catch(HRESULT hrTmp){

        hr = hrTmp;
    }
    catch(...){

        hr = E_UNEXPECTED;
    }/* end of catch statement */

    return HandleError(hr);
}/* end of function put_EnableResetOnStop */

/*************************************************************************/
/* Function: get_Mute                                                    */
/* Description: Gets the mute state.                                     */
/*************************************************************************/
STDMETHODIMP CMSWebDVD::get_Mute(VARIANT_BOOL *pfMute){

    HRESULT hr = S_OK;

    try {
        if(NULL == pfMute){

            throw(E_POINTER);
        }/* end of if statement */

        *pfMute = m_bMute ? VARIANT_TRUE: VARIANT_FALSE;
                    
    }/* end of try statement */
    catch(HRESULT hrTmp){

        hr = hrTmp;
    }
    catch(...){

        hr = E_UNEXPECTED;
    }/* end of catch statement */

    return HandleError(hr);
}/* end of function get_Mute */

/*************************************************************************/
/* Function: DShowToWaveV                                                */
/*************************************************************************/
inline DShowToWaveV(long x){

   FLOAT fy = (((FLOAT)x + (-cgVOLUME_MIN)) / (-cgVOLUME_MIN)) * cgWAVE_VOLUME_MAX;
   return((WORD)fy);
}/* end of function DShowToWaveV */

/*************************************************************************/
/* Function: WaveToDShowV                                                */ 
/*************************************************************************/
inline LONG WaveToDShowV(WORD y){

   FLOAT fx = ((FLOAT)y * (-cgVOLUME_MIN)) / cgWAVE_VOLUME_MAX + cgVOLUME_MIN;
   return((LONG)fx);
}/* end of function WaveToDShowV */

/*************************************************************************/
/* Function: MixerSetVolume                                              */
/*************************************************************************/
HRESULT MixerSetVolume(DWORD dwVolume){

    WORD wVolume = (WORD)(0xffff & dwVolume);

    HRESULT hr = S_OK;

    HMIXER hmx = NULL;

    UINT cMixer = ::mixerGetNumDevs();
    if (cMixer <= 0) {
        return E_FAIL;
    }
    
    BOOL bVolControlFound = FALSE;
    DWORD dwVolControlID = 0;

    for (UINT i=0; i<cMixer; i++) {
        
        if(::mixerOpen(&hmx, i, 0, 0, 0) != MMSYSERR_NOERROR){
            
            // Can't open device, try next device
            continue;
        }/* end of if statement */
        
        MIXERLINE mxl; 
        ::ZeroMemory(&mxl, sizeof(MIXERLINE));
        mxl.cbStruct = sizeof(MIXERLINE);
        mxl.dwComponentType = MIXERLINE_COMPONENTTYPE_DST_SPEAKERS;
        
        if(::mixerGetLineInfo((HMIXEROBJ)hmx, &mxl, MIXER_GETLINEINFOF_COMPONENTTYPE) != MMSYSERR_NOERROR){
            
            // Can't find a audio line to adjust the speakers, try next device
            ::mixerClose(hmx);
            continue;
        }
        
        MIXERLINECONTROLS mxlc;
        ::ZeroMemory(&mxlc, sizeof(MIXERLINECONTROLS));
        mxlc.cbStruct = sizeof(MIXERLINECONTROLS);
        mxlc.dwLineID = mxl.dwLineID;
        mxlc.dwControlType = MIXERCONTROL_CONTROLTYPE_VOLUME;
        mxlc.cControls = 1;
        MIXERCONTROL mxc;
        ::ZeroMemory(&mxc, sizeof(MIXERCONTROL));
        mxc.cbStruct = sizeof(MIXERCONTROL);
        mxlc.cbmxctrl = sizeof(MIXERCONTROL);
        mxlc.pamxctrl = &mxc;
        
        if(::mixerGetLineControls((HMIXEROBJ) hmx, &mxlc, MIXER_GETLINECONTROLSF_ONEBYTYPE) != MMSYSERR_NOERROR){
            
            // Can't get volume control on the audio line, try next device
            ::mixerClose(hmx);
            continue;
        }
        
        if(cgWAVE_VOLUME_MAX != mxc.Bounds.dwMaximum){
            
            ATLASSERT(FALSE); // improve algorith to take different max and min
            ::mixerClose(hmx);
            hr = E_FAIL;
            return(hr);
        }/* end of if statement */
        
        if(cgWAVE_VOLUME_MIN != mxc.Bounds.dwMinimum){
            
            ATLASSERT(FALSE); // improve algorith to take different max and min
            ::mixerClose(hmx);
            hr = E_FAIL;
            return(hr);
        }/* end of if statement */
        
        // Volume control found, break out loop
        bVolControlFound = TRUE;
        dwVolControlID = mxc.dwControlID;
        break;
    }/*end of for loop*/

    if (!bVolControlFound)
        return E_FAIL;

    MIXERCONTROLDETAILS mxcd;
    MIXERCONTROLDETAILS_SIGNED volStruct;

    ::ZeroMemory(&mxcd, sizeof(MIXERCONTROLDETAILS));
    mxcd.cbStruct = sizeof(MIXERCONTROLDETAILS);
    mxcd.cbDetails = sizeof(MIXERCONTROLDETAILS_SIGNED);
    mxcd.dwControlID = dwVolControlID;
    mxcd.paDetails = &volStruct;
    volStruct.lValue = wVolume;
    mxcd.cChannels = 1;

    if(::mixerSetControlDetails((HMIXEROBJ) hmx, &mxcd, MIXER_SETCONTROLDETAILSF_VALUE)  != MMSYSERR_NOERROR){

        ::mixerClose(hmx);
        hr = E_FAIL;
        return(hr);
    }/* end of if statement */

    ::mixerClose(hmx);
    return(hr);
}/* end of fucntion MixerSetVolume */

/*************************************************************************/
/* Function: MixerGetVolume                                              */
/*************************************************************************/
HRESULT MixerGetVolume(DWORD& dwVolume){

    HRESULT hr = S_OK;

    HMIXER hmx = NULL;

    UINT cMixer = ::mixerGetNumDevs();
    if (cMixer <= 0) {
        return E_FAIL;
    }
    
    BOOL bVolControlFound = FALSE;
    DWORD dwVolControlID = 0;

    for (UINT i=0; i<cMixer; i++) {
        
        if(::mixerOpen(&hmx, i, 0, 0, 0) != MMSYSERR_NOERROR){
            
            // Can't open device, try next device
            continue;
        }/* end of if statement */
        
        MIXERLINE mxl; 
        ::ZeroMemory(&mxl, sizeof(MIXERLINE));
        mxl.cbStruct = sizeof(MIXERLINE);
        mxl.dwComponentType = MIXERLINE_COMPONENTTYPE_DST_SPEAKERS;
        
        if(::mixerGetLineInfo((HMIXEROBJ)hmx, &mxl, MIXER_GETLINEINFOF_COMPONENTTYPE) != MMSYSERR_NOERROR){
            
            // Can't find a audio line to adjust the speakers, try next device
            ::mixerClose(hmx);
            continue;
        }
        
        MIXERLINECONTROLS mxlc;
        ::ZeroMemory(&mxlc, sizeof(MIXERLINECONTROLS));
        mxlc.cbStruct = sizeof(MIXERLINECONTROLS);
        mxlc.dwLineID = mxl.dwLineID;
        mxlc.dwControlType = MIXERCONTROL_CONTROLTYPE_VOLUME;
        mxlc.cControls = 1;
        MIXERCONTROL mxc;
        ::ZeroMemory(&mxc, sizeof(MIXERCONTROL));
        mxc.cbStruct = sizeof(MIXERCONTROL);
        mxlc.cbmxctrl = sizeof(MIXERCONTROL);
        mxlc.pamxctrl = &mxc;
        
        if(::mixerGetLineControls((HMIXEROBJ) hmx, &mxlc, MIXER_GETLINECONTROLSF_ONEBYTYPE) != MMSYSERR_NOERROR){
            
            // Can't get volume control on the audio line, try next device
            ::mixerClose(hmx);
            continue;
        }
        
        if(cgWAVE_VOLUME_MAX != mxc.Bounds.dwMaximum){
            
            ATLASSERT(FALSE); // improve algorith to take different max and min
            ::mixerClose(hmx);
            hr = E_FAIL;
            return(hr);
        }/* end of if statement */
        
        if(cgWAVE_VOLUME_MIN != mxc.Bounds.dwMinimum){
            
            ATLASSERT(FALSE); // improve algorith to take different max and min
            ::mixerClose(hmx);
            hr = E_FAIL;
            return(hr);
        }/* end of if statement */
        
        // Volume control found, break out loop
        bVolControlFound = TRUE;
        dwVolControlID = mxc.dwControlID;
        break;
    }/*end of for loop*/

    if (!bVolControlFound)
        return E_FAIL;

    MIXERCONTROLDETAILS mxcd;
    MIXERCONTROLDETAILS_SIGNED volStruct;

    ::ZeroMemory(&mxcd, sizeof(MIXERCONTROLDETAILS));
    mxcd.cbStruct = sizeof(MIXERCONTROLDETAILS);
    mxcd.cbDetails = sizeof(MIXERCONTROLDETAILS_SIGNED);
    mxcd.dwControlID = dwVolControlID;
    mxcd.paDetails = &volStruct;
    mxcd.cChannels = 1;

    if(::mixerGetControlDetails((HMIXEROBJ) hmx, &mxcd, MIXER_GETCONTROLDETAILSF_VALUE)  != MMSYSERR_NOERROR){

        ::mixerClose(hmx);
        hr = E_FAIL;
        return(hr);
    }/* end of if statement */

    // the volStruct.lValue gets initialize via call to mixerGetControlDetails with mxcd.paDetails = &volStruct;
    dwVolume = volStruct.lValue;

    ::mixerClose(hmx);
    return(hr);
}/* end of function MixerGetVolume */

/*************************************************************************/
/* Function: get_IntVolume                                               */
/*************************************************************************/
HRESULT CMSWebDVD::get_IntVolume(LONG* plVolume){

    HRESULT hr = S_OK;

    if(m_pAudio){

        hr = m_pAudio->get_Volume(plVolume); // get the volume
    }
    else {

        DWORD dwVolume;
        hr = MixerGetVolume(dwVolume);

        if(FAILED(hr)){
            
            return(hr);
        }/* end of if statement */

        *plVolume = WaveToDShowV(LOWORD(dwVolume));
    }/* end of if statememt */

    return(hr);
}/* end of function get_VolumeHelper */

/*************************************************************************/
/* Function: put_IntVolume                                               */
/*************************************************************************/
HRESULT CMSWebDVD::put_IntVolume(long lVolume){

    HRESULT hr = S_OK;

    if(m_pAudio){

        hr = m_pAudio->put_Volume(lVolume);
    }
    else {

        WORD wVolume = WORD(DShowToWaveV(lVolume));
        // set left and right volume same for now
        DWORD dwVolume;
        dwVolume = ((DWORD)(((WORD)(wVolume)) | ((DWORD)((WORD)(wVolume))) << 16));

        hr = MixerSetVolume(dwVolume);
    }/* end of if statement */

    return(hr);
}/* end of function put_IntVolume */

/*************************************************************************/
/* Function: put_Mute                                                    */
/* Description: Gets the mute state.                                     */
/*************************************************************************/
STDMETHODIMP CMSWebDVD::put_Mute(VARIANT_BOOL newVal){

	HRESULT hr = E_FAIL;

    try {
        if(VARIANT_FALSE == newVal){
            // case when we are unmutting
            LONG lVolume;

            if(TRUE != m_bMute){

                hr = get_IntVolume(&lVolume); // get the volume
                
                if(FAILED(hr)){

                    throw(hr);
                }/* end of if statement */

                if(cgVOLUME_MIN != lVolume){

                   // OK we are not really muted, so
                   // send little displesure the app
                   throw(S_FALSE);
                }/* end of if statement */

                // otherwise proceed normally and sync our flag
            }/* end of if statement */
            
            hr = put_IntVolume(m_lLastVolume);
            
            if(FAILED(hr)){

                throw(hr);
            }/* end of if statement */

            m_bMute = FALSE; // reset our flag, that we are muted

        }
        else {
            // case when we are mutting
            LONG lVolume;
            hr = get_IntVolume(&lVolume); // get the volume

            if(FAILED(hr)){

                throw(hr);
            }/* end of if statement */

            m_lLastVolume = lVolume; // store the volume  for when we are unmutting
            
            hr = put_IntVolume(cgVOLUME_MIN);
            
            if(FAILED(hr)){

                throw(hr);
            }/* end of if statement */

            m_bMute = TRUE; // set the mute flage
        }/* end of if statement */
    }/* end of try statement */
    catch(HRESULT hrTmp){

        hr = hrTmp;
    }
    catch(...){

        hr = E_UNEXPECTED;
    }/* end of catch statement */

    return HandleError(hr);
}/* end of function put_Mute */

/*************************************************************************/
/* Function: get_Volume                                                  */
/* Description: Gets the volume.                                         */
/*************************************************************************/
STDMETHODIMP CMSWebDVD::get_Volume(long *plVolume){

	HRESULT hr = E_FAIL;

    try {
        if(NULL == plVolume){

            throw(E_POINTER);
        }/* end of if statement */        
        
        if(FALSE == m_bMute){

            hr = get_IntVolume(plVolume);
        } 
        else {
            // we are in mute state so save the volume for "unmuting"

            *plVolume = m_lLastVolume;
            hr = S_FALSE; // indicate we are sort of unhappy
        }/* end of if statement */

    }/* end of try statement */
    catch(HRESULT hrTmp){

        hr = hrTmp;
    }
    catch(...){

        hr = E_UNEXPECTED;
    }/* end of catch statement */

    return HandleError(hr);
}/* end of function get_Volume */

/*************************************************************************/
/* Function: put_Volume                                                  */
/* Description: Sets the volume.                                         */
/*************************************************************************/
STDMETHODIMP CMSWebDVD::put_Volume(long lVolume){

	HRESULT hr = E_FAIL;

    try {

        // cgVOLUME_MIN is max and cgVOLUME_MAX is min by value
        if(cgVOLUME_MIN > lVolume || cgVOLUME_MAX < lVolume){

            throw(E_INVALIDARG);
        }/* end of if statement */

        if(TRUE == m_bMute){

            // unmute we are setting volume
            m_bMute = FALSE;
        }/* end of if statement */

        hr = put_IntVolume(lVolume);

        // this statement might be taken out but might prevent some error scenarious
        // when things are not working right.
        if(SUCCEEDED(hr)){

            m_lLastVolume = lVolume; // cash up the volume
        }/* end of if statement */

    }/* end of try statement */
    catch(HRESULT hrTmp){

        hr = hrTmp;
    }
    catch(...){

        hr = E_UNEXPECTED;
    }/* end of catch statement */

    return HandleError(hr);
}/* end of function put_Volume */

/*************************************************************************/
/* Function: get_Balance                                                 */
/* Description: Gets the balance.                                        */
/*************************************************************************/
STDMETHODIMP CMSWebDVD::get_Balance(long *plBalance){

	HRESULT hr = E_FAIL;

    try {
        if(NULL == plBalance){

            throw(E_POINTER);
        }/* end of if statement */

        if(!m_pAudio){

            throw(E_NOTIMPL);
        }/* end of if statement */

        hr = m_pAudio->get_Balance(plBalance);

    }/* end of try statement */
    catch(HRESULT hrTmp){

        hr = hrTmp;
    }
    catch(...){

        hr = E_UNEXPECTED;
    }/* end of catch statement */

    return HandleError(hr);
}/* end of function get_Balance */

/*************************************************************************/
/* Function: put_Balance                                                 */
/* Description: Sets the balance.                                        */
/*************************************************************************/
STDMETHODIMP CMSWebDVD::put_Balance(long lBalance){

	HRESULT hr = E_FAIL;

    try {

        if(cgBALANCE_MIN > lBalance || cgBALANCE_MAX < lBalance){

            throw(E_INVALIDARG);
        }/* end of if statement */

        if(!m_pAudio){

            throw(E_NOTIMPL);
        }/* end of if statement */

        hr = m_pAudio->put_Balance(lBalance);
    }/* end of try statement */
    catch(HRESULT hrTmp){

        hr = hrTmp;
    }
    catch(...){

        hr = E_UNEXPECTED;
    }/* end of catch statement */

    return HandleError(hr);
}/* end of function put_Balance */

#if 1 // USE TOOLTIPS

/*************************************************************************/
/* Function: OnMouseToolTip                                              */
/* Description: Check if we were captured/pushed the do not do much,     */
/* otherwise do the hit detection and see if we are in static or hower   */
/* state.                                                                */
/*************************************************************************/
LRESULT CMSWebDVD::OnMouseToolTip(UINT msg, WPARAM wParam, LPARAM lParam, BOOL& bHandled){

    bHandled = FALSE;

    if (!m_hWndTip){

        return 0;
    }/* end of if statement */

    MSG mssg;

    HWND hwnd;

    HRESULT hr = GetUsableWindow(&hwnd);

    if(FAILED(hr)){

        return(1);
    }/* end of if statement */

    if(!m_bWndLess){

        HWND hwndTmp = hwnd;
        // Get the active movie window
        hwnd = ::GetWindow(hwndTmp, GW_CHILD);

        if (!::IsWindow(hwnd)){ 
        
            return S_FALSE;
        }/* end of if statement */
    }/* end of if statement */

    mssg.hwnd = hwnd;

    ATLASSERT(mssg.hwnd);
    mssg.message = msg;
    mssg.wParam = wParam;
    mssg.lParam = lParam;    
    ::SendMessage(m_hWndTip, TTM_RELAYEVENT, 0, (LPARAM) &mssg);     
    return 0;
}/* end of function OnMouseToolTip */

/*************************************************************/
/* Name: get_ToolTip                                         */
/* Description: create a tool tip for the button             */
/*************************************************************/
STDMETHODIMP CMSWebDVD::get_ToolTip(BSTR *pVal){

    HRESULT hr = S_OK;
    try {
        if (NULL == pVal) {
            
            throw (E_POINTER);
        } /* end of if statment */
        
        *pVal = m_bstrToolTip.Copy();
    }
    
    catch(HRESULT hrTmp){

        hr = hrTmp;
    }/* end of catch statement */
    catch(...){

        hr = E_UNEXPECTED;
    }/* end of catch statement */

	return HandleError(hr);
}/* end of function get_ToolTip */

/*************************************************************/
/* Name: put_ToolTip                                         */
/* Description: create a tool tip for the button             */
/*  Cache the tooltip string if there is no window available */
/*************************************************************/
STDMETHODIMP CMSWebDVD::put_ToolTip(BSTR newVal){

    HRESULT hr = S_OK;

    try {
        if(NULL == newVal){

            throw(E_POINTER);
        }/* end of if statement */

        m_bstrToolTip = newVal;
        hr = CreateToolTip();
    }
    
    catch(HRESULT hrTmp){

        hr = hrTmp;
    }/* end of catch statement */
    catch(...){

        hr = E_UNEXPECTED;
    }/* end of catch statement */

	return HandleError(hr);
}/* end of function put_ToolTip */

/*************************************************************************/
/* Function: GetUsableWindow                                             */
/* Description:  Gets the window. If we are windowless we pass           */
/* down the parent container window, which is really in a sense parent.  */
/*************************************************************************/
HRESULT CMSWebDVD::GetUsableWindow(HWND* pWnd){

  HRESULT hr = S_OK;

    if(NULL == pWnd){

        hr = E_POINTER;
        return(hr);
    }/* end of if statement */

    *pWnd = NULL;

    HWND hwnd; // temp

    if(m_bWndLess){

        hr = GetParentHWND(&hwnd);

        if(FAILED(hr)){

            return(hr);
        }/* end of if statement */
    }
    else {

        hwnd = m_hWnd;
    }/* end of if statement */

    if(::IsWindow(hwnd)){

        *pWnd =  hwnd;
        hr = S_OK;
    }
    else {
        hr = E_UNEXPECTED;
    }/* end of if statement */

    return(hr);
}/* end of function GetUsableWindow */

/*************************************************************************/
/* Function: GetUsableWindow                                             */
/* Description:  Gets the window. If we are windowless we pass           */
/* down the parent container window, which is really in a sense parent.  */
/*************************************************************************/
HRESULT CMSWebDVD::GetClientRectInScreen(RECT* prc){

    HRESULT hr = S_OK;

    if(NULL == prc){

        hr = E_POINTER;
        return(hr);
    }/* end of if statement */

    *prc = m_rcPos; //{m_rcPos.left, m_rcPos.top, m_rcPos.right, m_rcPos.bottom};

    HWND hwnd;

    hr = GetUsableWindow(&hwnd);

    if(FAILED(hr)){

        return(hr);
    }/* end of if statement */

    ::MapWindowPoints(hwnd, ::GetDesktopWindow(), (LPPOINT)prc, 2);

    return(hr);
}/* end of function GetClientRectInScreen */

/*************************************************************/
/* Name: CreateToolTip
/* Description: create a tool tip for the button
/*************************************************************/
HRESULT CMSWebDVD::CreateToolTip(void){

    HWND hwnd;

    HRESULT hr = GetUsableWindow(&hwnd);

    if(FAILED(hr)){

        return(hr);
    }/* end of if statement */
    
    if(!m_bWndLess){

        HWND hwndTmp = hwnd;
        // Get the active movie window
        hwnd = ::GetWindow(hwndTmp, GW_CHILD);

        if (!::IsWindow(hwnd)){ 
        
            return S_FALSE;
        }/* end of if statement */
    }/* end of if statement */

 	USES_CONVERSION;
    // If tool tip is to be created for the first time
    if (m_hWndTip == (HWND) NULL) {
        // Ensure that the common control DLL is loaded, and create 
        // a tooltip control. 
        InitCommonControls(); 
        
        m_hWndTip = CreateWindow(TOOLTIPS_CLASS, (LPTSTR) NULL, TTS_ALWAYSTIP, 
            CW_USEDEFAULT, CW_USEDEFAULT, CW_USEDEFAULT, CW_USEDEFAULT, 
            hwnd, (HMENU) NULL, _Module.GetModuleInstance(), NULL); 
    }

    if (m_hWndTip == (HWND) NULL) 
        return S_FALSE; 
 
    TOOLINFO ti;    // tool information 
    ti.cbSize = sizeof(TOOLINFO); 
    ti.uFlags = 0; 
    ti.hwnd = hwnd; 
    ti.hinst = _Module.GetModuleInstance(); 
    ti.uId = (UINT) 0; 
  	ti.lpszText = OLE2T(m_bstrToolTip);

    // if the button is a windowed control, the tool tip is added to 
    // the button's own window, and the tool tip area should just be
    // the client rect of the window
    if (hwnd == m_hWnd)
        ::GetClientRect(hwnd, &ti.rect);

    // otherwise the tool tip is added to the closet windowed parent of
    // the button, and the tool tip area should be the relative postion
    // of the button in the parent window
    else {
        ti.rect.left = m_rcPos.left; 
        ti.rect.top = m_rcPos.top; 
        ti.rect.right = m_rcPos.right; 
        ti.rect.bottom = m_rcPos.bottom; 
    }

    if (!SendMessage(m_hWndTip, TTM_ADDTOOL, 0, 
        (LPARAM) (LPTOOLINFO) &ti)) 
        return S_FALSE; 

    // Set initial delay time
    put_ToolTipMaxWidth(m_nTTMaxWidth);

    VARIANT varTemp;
    VariantInit(&varTemp);

#ifdef _WIN64
    varTemp.vt = VT_I8;
#define VARTEMP_VAL  (varTemp.llVal)
#else
    varTemp.vt = VT_I4;
#define VARTEMP_VAL  (varTemp.lVal)
#endif

    VARTEMP_VAL = m_dwTTAutopopDelay;
    SetDelayTime(TTDT_AUTOPOP, varTemp); 

    VARTEMP_VAL = m_dwTTInitalDelay;
    SetDelayTime(TTDT_INITIAL, varTemp);

    VARTEMP_VAL = m_dwTTReshowDelay;
    SetDelayTime(TTDT_RESHOW, varTemp);

#undef VARTEMP_VAL

    return S_OK;
}/* end of function CreateToolTip */

/*************************************************************************/
/* Function: get_ToolTipMaxWidth                                         */
/*************************************************************************/
STDMETHODIMP CMSWebDVD::get_ToolTipMaxWidth(long *pVal){

    HRESULT hr = S_OK;

    try {
        
        if (NULL == pVal) {

            throw E_POINTER;
        } /* end of if statement */
        
        if (NULL != m_hWndTip){
            
            // Return value is width in pixels. Safe to cast to 32-bit.
            m_nTTMaxWidth = (LONG)::SendMessage(m_hWndTip, TTM_GETMAXTIPWIDTH, 0, 0);
        }/* end of if statement */

        *pVal = m_nTTMaxWidth;
    }

    catch(HRESULT hrTmp){

        hr = hrTmp;
    }/* end of catch statement */
    catch(...){

        hr = E_UNEXPECTED;
    }/* end of catch statement */

	return HandleError(hr);
}/* end of function get_ToolTipMaxWidth */

/*************************************************************************/
/* Function: put_ToolTipMaxWidth                                         */
/*************************************************************************/
STDMETHODIMP CMSWebDVD::put_ToolTipMaxWidth(long newVal){

    HRESULT hr = S_OK;

    try {
        
        if (newVal <= 0) {

            throw E_INVALIDARG;
        } /* end of if statement */
        
        m_nTTMaxWidth = newVal;
        if (m_hWndTip){
            
            ::SendMessage(m_hWndTip, TTM_SETMAXTIPWIDTH, 0, (LPARAM)(INT) newVal);
        }/* end of if statement */
        
    }
    
    catch(HRESULT hrTmp){

        hr = hrTmp;
    }/* end of catch statement */
    catch(...){

        hr = E_UNEXPECTED;
    }/* end of catch statement */

	return HandleError(hr);
}/* end of function put_ToolTipMaxWidth */

/*************************************************************/
/* Name: GetDelayTime
/* Description: Get the length of time a pointer must remain 
/* stationary within a tool's bounding rectangle before the 
/* tooltip window appears 
/* delayTypes:  TTDT_RESHOW             1
/*              TTDT_AUTOPOP            2
/*              TTDT_INITIAL            3
/*************************************************************/
STDMETHODIMP CMSWebDVD::GetDelayTime(long delayType, VARIANT *pVal){

    HRESULT hr = S_OK;
    LRESULT lDelay = 0; //BUGBUG: Is this a good initialization value?

    try {
        
        if (NULL == pVal) {

            throw E_POINTER;
        } /* end of if statement */
        
        if (delayType>TTDT_INITIAL || delayType<TTDT_RESHOW) {

            throw E_INVALIDARG;
        } /* end of if statement */
        
        if (m_hWndTip) {
            lDelay = SendMessage(m_hWndTip, TTM_GETDELAYTIME, 
            (WPARAM) (DWORD) delayType, 0);
        }  
        
        // else return cached values
        else {
            switch (delayType) {
            case TTDT_AUTOPOP:
                lDelay =  m_dwTTAutopopDelay;
                break;
            case TTDT_INITIAL:
                lDelay =  m_dwTTInitalDelay;
                break;
            case TTDT_RESHOW:
                lDelay =  m_dwTTReshowDelay;
                break;
            }
        } /* end of if statement */


        /*
         * Copy the delay to the VARIANT return variable.
         * BUGBUG: If pVal was a properly initialized variant, we should
         * call VariantClear to free any pointers. If it wasn't initialized
         * VariantInit is the right thing to call instead. I prefer a leak 
         * to a crash so I'll use VariantInit below
         */
        
        VariantInit(pVal);
        
#ifdef _WIN64
        pVal->vt = VT_I8;
        pVal->llVal = lDelay;
#else
        pVal->vt = VT_I4;
        pVal->lVal  = lDelay;
#endif

    }
    
    catch(HRESULT hrTmp){

        hr = hrTmp;
    }/* end of catch statement */
    catch(...){

        hr = E_UNEXPECTED;
    }/* end of catch statement */


	return HandleError(hr);
}/* end of function GetDelayTime */

/*************************************************************/
/* Name: SetDelayTime
/* Description: Set the length of time a pointer must remain 
/* stationary within a tool's bounding rectangle before the 
/* tooltip window appears 
/* delayTypes:  TTDT_AUTOMATIC          0
/*              TTDT_RESHOW             1
/*              TTDT_AUTOPOP            2
/*              TTDT_INITIAL            3
/*************************************************************/
STDMETHODIMP CMSWebDVD::SetDelayTime(long delayType, VARIANT newVal){

    HRESULT hr = S_OK;
    LPARAM  lNewDelay = 0;

    try {
        if (delayType>TTDT_INITIAL || delayType<TTDT_AUTOMATIC) {

            throw E_INVALIDARG;
        } /* end of if statement */

        VARIANT dest;
        VariantInit(&dest);

#ifdef _WIN64
        hr = VariantChangeTypeEx(&dest, &newVal, 0, 0, VT_I8);
        if (FAILED(hr))
            throw hr;
        lNewDelay = dest.llVal;
#else
        hr = VariantChangeTypeEx(&dest, &newVal, 0, 0, VT_I4);
        if (FAILED(hr))
            throw hr;
        lNewDelay = dest.lVal;
#endif

        if (lNewDelay < 0) {

            throw E_INVALIDARG;
        } /* end of if statement */

        if (m_hWndTip) {
            if (!SendMessage(m_hWndTip, TTM_SETDELAYTIME, 
                (WPARAM) (DWORD) delayType, 
                lNewDelay))
                return S_FALSE; 
        }

        // cache these values
        switch (delayType) {
        case TTDT_AUTOPOP:
            m_dwTTAutopopDelay = lNewDelay;
            break;
        case TTDT_INITIAL:
            m_dwTTInitalDelay = lNewDelay;
            break;
        case TTDT_RESHOW:
            m_dwTTReshowDelay = lNewDelay;
            break;
        case TTDT_AUTOMATIC:
            m_dwTTInitalDelay = lNewDelay;
            m_dwTTAutopopDelay = lNewDelay*10;
            m_dwTTReshowDelay = lNewDelay/5;
            break;
        } /* end of switch statement */
    }
    
    catch(HRESULT hrTmp){

        hr = hrTmp;
    }/* end of catch statement */
    catch(...){

        hr = E_UNEXPECTED;
    }/* end of catch statement */

	return HandleError(hr);
}/* end of function SetDelayTime */

#endif

/*************************************************************************/
/* Function: ProcessEvents                                               */
/* Description: Triggers the message, which checks if the messagess are  */
/* ready.                                                                */
/*************************************************************************/
HRESULT CMSWebDVD::ProcessEvents(){

   HRESULT hr = S_OK;

    try {
        // see if we have lost the DDraw Surf on in Windowless MODE
        if((m_pDDrawDVD) && (!::IsWindow(m_hWnd))){

            LPDIRECTDRAWSURFACE pDDPrimary = m_pDDrawDVD->GetDDrawSurf();
            if (pDDPrimary && (pDDPrimary->IsLost() == DDERR_SURFACELOST)){

                if (pDDPrimary->Restore() == DD_OK){

                    RestoreSurfaces();
                }/* end of if statement */
            }/* end of if statement */
        }/* end of if statement */
        
        // process the DVD event
        LRESULT lRes;
        ProcessWindowMessage(NULL, WM_DVDPLAY_EVENT, 0, 0, lRes);
    }/* end of try statement */
    catch(HRESULT hrTmp){

        hr = hrTmp;
    }/* end of catch statement */
    catch(...){

        hr = E_UNEXPECTED;
    }/* end of catch statement */

	return hr;
}/* end of function ProcessEvents */

/*************************************************************************/
/* Function: get_WindowlessActivation                                    */
/* Description: Gets if we we tried to be windowless activated or not.   */
/*************************************************************************/
STDMETHODIMP CMSWebDVD::get_WindowlessActivation(VARIANT_BOOL *pVal){

    HRESULT hr = S_OK;

    try {
        if(NULL == pVal){

            throw(E_POINTER);
        }/* end of if statement */

        BOOL fUserMode = FALSE;

        GetAmbientUserMode(fUserMode);

        if(READYSTATE_COMPLETE == m_nReadyState && fUserMode){
            // case when we are up and running
            *pVal = m_bWndLess == FALSE ? VARIANT_FALSE: VARIANT_TRUE; 
        }
        else {

            *pVal = m_bWindowOnly == TRUE ? VARIANT_FALSE: VARIANT_TRUE; 
        }/* end of if statement */
    }/* end of try statement */
    catch(HRESULT hrTmp){

        hr = hrTmp;
    }/* end of catch statement */
    catch(...){

        hr = E_UNEXPECTED;
    }/* end of catch statement */

	return HandleError(hr);
}/* end of function get_WindowlessActivation */

/*************************************************************************/
/* Function: put_WindowlessActivation                                    */
/* Description: This sets the windowless mode, should be set from the    */
/* property bag.                                                         */
/*************************************************************************/
STDMETHODIMP CMSWebDVD::put_WindowlessActivation(VARIANT_BOOL newVal){

    HRESULT hr = S_OK;

    try {
        if(VARIANT_FALSE == newVal){

            m_bWindowOnly = TRUE; 
            m_fUseDDrawDirect = false;
        }
        else {

            m_bWindowOnly = FALSE; 
            m_fUseDDrawDirect = true;
        }/* end of if statement */

        // TODO: This function should fail after we inplace activated !!
    }/* end of try statement */
    catch(HRESULT hrTmp){

        hr = hrTmp;
    }/* end of catch statement */
    catch(...){

        hr = E_UNEXPECTED;
    }/* end of catch statement */

	return HandleError(hr);
}/* end of function put_WindowlessActivation */

/*************************************************************************/
/* Function: get_DisableAutoMouseProcessing                              */
/* Description: Gets the current state of the mouse processing code.     */
/*************************************************************************/
STDMETHODIMP CMSWebDVD::get_DisableAutoMouseProcessing(VARIANT_BOOL *pVal){

    HRESULT hr = S_OK;

    try {
        if(NULL == pVal){

            throw(E_POINTER);
        }/* end of if statement */

        *pVal = m_fDisableAutoMouseProcessing;
    }/* end of try statement */
    catch(HRESULT hrTmp){

        hr = hrTmp;
    }/* end of catch statement */
    catch(...){

        hr = E_UNEXPECTED;
    }/* end of catch statement */

	return HandleError(hr);
}/* end of function get_DisableAutoMouseProcessing */

/*************************************************************************/
/* Function: put_DisableAutoMouseProcessing                              */
/* Description: Gets the state of the mouse processing.                  */
/*************************************************************************/
STDMETHODIMP CMSWebDVD::put_DisableAutoMouseProcessing(VARIANT_BOOL newVal){

    HRESULT hr = S_OK;

    try {
        m_fDisableAutoMouseProcessing = VARIANT_FALSE == newVal ? false : true;

    }/* end of try statement */
    catch(HRESULT hrTmp){

        hr = hrTmp;
    }/* end of catch statement */
    catch(...){

        hr = E_UNEXPECTED;
    }/* end of catch statement */

	return HandleError(hr);
}/* end of function put_DisableAutoMouseProcessing */

/*************************************************************************/
/* Function: ActivateAtPosition                                          */
/* Description: Activates a button at selected position.                 */ 
/*************************************************************************/
STDMETHODIMP CMSWebDVD::ActivateAtPosition(long xPos, long yPos){

    HRESULT hr = S_OK;

    try {
        INITIALIZE_GRAPH_IF_NEEDS_TO_BE

        if(!m_pDvdCtl2){

            throw(E_UNEXPECTED);
        }/* end of if statement */

        POINT pt = {xPos, yPos};

        hr = TransformToWndwls(pt);

        if(FAILED(hr)){

            throw(hr);
        }/* end of if statement */

        hr = m_pDvdCtl2->ActivateAtPosition(pt);

    }/* end of try statement */
    catch(HRESULT hrTmp){

        hr = hrTmp;
    }/* end of catch statement */
    catch(...){

        hr = E_UNEXPECTED;
    }/* end of catch statement */

	return HandleError(hr);
}/* end of function ActivateAtPosition */

/*************************************************************************/
/* Function: SelectAtPosition                                            */
/* Description: Selects a button at selected position.                   */ 
/*************************************************************************/
STDMETHODIMP CMSWebDVD::SelectAtPosition(long xPos, long yPos){

    HRESULT hr = S_OK;

    try {
        INITIALIZE_GRAPH_IF_NEEDS_TO_BE

        if(!m_pDvdCtl2){

            throw(E_UNEXPECTED);
        }/* end of if statement */

        POINT pt = {xPos, yPos};

        hr = TransformToWndwls(pt);

        if(FAILED(hr)){

            throw(hr);
        }/* end of if statement */
        
        hr = m_pDvdCtl2->SelectAtPosition(pt);

    }/* end of try statement */
    catch(HRESULT hrTmp){

        hr = hrTmp;
    }/* end of catch statement */
    catch(...){

        hr = E_UNEXPECTED;
    }/* end of catch statement */

	return HandleError(hr);
}/* end of function SelectAtPosition */

/*************************************************************************/
/* Function: GetButtonAtPosition                                         */
/* Description: Gets the button number associated with a position.       */
/*************************************************************************/
STDMETHODIMP CMSWebDVD::GetButtonAtPosition(long xPos, long yPos, 
                                              long *plButton)
{
	HRESULT hr = S_OK;

    try {
        INITIALIZE_GRAPH_IF_NEEDS_TO_BE;
        if(!plButton){
            throw E_POINTER;
        }
        if(!m_pDvdInfo2){

            throw(E_UNEXPECTED);
        }/* end of if statement */

        POINT pt = {xPos, yPos};

        hr = TransformToWndwls(pt);

        if(FAILED(hr)){

            throw(hr);
        }/* end of if statement */

        ULONG ulButton;
        hr = m_pDvdInfo2->GetButtonAtPosition(pt, &ulButton);

        if(SUCCEEDED(hr)){
            *plButton = ulButton;
        } 
        else {
            plButton = 0;
        }/* end of if statement */

    }/* end of try statement */
    catch(HRESULT hrTmp){

        hr = hrTmp;
    }/* end of catch statement */
    catch(...){

        hr = E_UNEXPECTED;
    }/* end of catch statement */

	return HandleError(hr);
}/* end of function GetButtonAtPosition */

/*************************************************************************/
/* Function: GetButtonRect                                               */
/* Description: Gets an button rect associated with a button ID.         */
/*************************************************************************/
STDMETHODIMP CMSWebDVD::GetButtonRect(long lButton, IDVDRect** ppRect){

    // no support in MS DVDNav
	return HandleError(E_NOTIMPL);
}/* end of function GetButtonRect */

/*************************************************************************/
/* Function: GetDVDScreenInMouseCoordinates                              */
/* Description: Gets the mouse coordinate screen.                        */
/*************************************************************************/
STDMETHODIMP CMSWebDVD::GetDVDScreenInMouseCoordinates(IDVDRect **ppRect){

    // no support in MS DVDNav
    return HandleError(E_NOTIMPL);
}/* end of function GetDVDScreenInMouseCoordinates */

/*************************************************************************/
/* Function: SetDVDScreenInMouseCoordinates                              */
/* Description: Sets the screen in mouse coordinates.                    */
/*************************************************************************/
STDMETHODIMP CMSWebDVD::SetDVDScreenInMouseCoordinates(IDVDRect *pRect){

    // no support in MS DVDNav
	return HandleError(E_NOTIMPL);
}/* end of function SetDVDScreenInMouseCoordinates */

/*************************************************************************/
/* Function: GetClipVideoRect                                            */
/* Description: Gets the source rect that is being used.                 */
/*************************************************************************/
STDMETHODIMP CMSWebDVD::GetClipVideoRect(IDVDRect **ppRect){

    HRESULT hr = S_OK;
    IBasicVideo* pIVid = NULL; 

    try {
        if(NULL == ppRect){

            throw(E_POINTER);
        }/* end of if statement */

        INITIALIZE_GRAPH_IF_NEEDS_TO_BE

        // If windowless and m_pDvdClipRect hasn't been yet, 
        // then the clipping size is the default video size
        if (m_bWndLess && !m_pClipRect) {
            
            return GetVideoSize(ppRect);
        }

        long lLeft=0, lTop=0, lWidth=0, lHeight=0;

        hr = ::CoCreateInstance(CLSID_DVDRect, NULL, CLSCTX_INPROC, IID_IDVDRect, (LPVOID*) ppRect);            
        if(FAILED(hr)){
            
            throw(hr);
        }/* end of if statement */

        IDVDRect* pIRect = *ppRect; // just to make the code esier to read

        // Windowed case, it'll be cached in m_rcvdClipRect
        if (m_bWndLess) {

            // get it from cached m_pDvdClipRect
            hr = pIRect->put_x(m_pClipRect->left);
            
            if(FAILED(hr)){
                
                throw(hr);
            }/* end of if statement */
            
            hr = pIRect->put_y(m_pClipRect->top);
            
            if(FAILED(hr)){
                
                throw(hr);
            }/* end of if statement */
            
            hr = pIRect->put_Width(RECTWIDTH(m_pClipRect));
            
            if(FAILED(hr)){
                
                throw(hr);
            }/* end of if statement */
            
            hr = pIRect->put_Height(RECTHEIGHT(m_pClipRect));
            
            if(FAILED(hr)){
                
                throw(hr);
            }/* end of if statement */    
        }

        // Windowed case, get it from IBasicVideo
        else {
            
            hr = TraverseForInterface(IID_IBasicVideo, (LPVOID*) &pIVid);
            
            if(FAILED(hr)){
                
                throw(hr);
            }/* end of if statement */
            
            hr = pIVid->GetSourcePosition(&lLeft, &lTop, &lWidth, &lHeight);
            
            pIVid->Release();
            
            if(FAILED(hr)){
                
                throw(hr);
            }/* end of if statement */
            
            hr = pIRect->put_x(lLeft);
            
            if(FAILED(hr)){
                
                throw(hr);
            }/* end of if statement */
            
            hr = pIRect->put_y(lTop);
            
            if(FAILED(hr)){
                
                throw(hr);
            }/* end of if statement */
            
            hr = pIRect->put_Width(lWidth);
            
            if(FAILED(hr)){
                
                throw(hr);
            }/* end of if statement */
            
            hr = pIRect->put_Height(lHeight);
            
            if(FAILED(hr)){
                
                throw(hr);
            }/* end of if statement */    

        }

    }/* end of try statement */
    catch(HRESULT hrTmp){

        if(NULL != pIVid){

            pIVid->Release();
            pIVid = NULL;
        }/* end of if statement */

        hr = hrTmp;
    }/* end of catch statement */
    catch(...){

        if(NULL != pIVid){

            pIVid->Release();
            pIVid = NULL;
        }/* end of if statement */

        hr = E_UNEXPECTED;
    }/* end of catch statement */

	return HandleError(hr);
}/* end of function GetClipVideoRect */

/*************************************************************************/
/* Function: GetVideoSize                                                */
/* Description: Gets the video, size. 0, 0 for origin for now.           */
/*************************************************************************/
STDMETHODIMP CMSWebDVD::GetVideoSize(IDVDRect **ppRect){

    HRESULT hr = S_OK;    
    IBasicVideo* pIVid = NULL; 

    try {
        if(NULL == ppRect){

            throw(E_POINTER);
        }/* end of if statement */

        INITIALIZE_GRAPH_IF_NEEDS_TO_BE

        // Windowless case
        if(m_bWndLess){

            if(!m_pDDEX){

                throw(E_UNEXPECTED);
            }/* end of if statement */

            DWORD dwVideoWidth, dwVideoHeight, dwAspectX, dwAspectY;

            hr = m_pDDEX->GetNativeVideoProps(&dwVideoWidth, &dwVideoHeight, &dwAspectX, &dwAspectY);

            if(FAILED(hr)){

                throw(hr);
            }/* end of if statement */

            m_dwVideoWidth = dwVideoWidth;
            m_dwVideoHeight = dwVideoWidth*3/4;
            //m_dwVideoHeight = dwVideoHeight;
            m_dwAspectX = dwAspectX;
            m_dwAspectY = dwAspectY;
            //ATLTRACE(TEXT("GetNativeVideoProps %d %d %d %d\n"), dwVideoWidth, dwVideoHeight, dwAspectX, dwAspectY);
        } 

        // Windowed case, get it from IBasicVideo
        else {

            hr = TraverseForInterface(IID_IBasicVideo, (LPVOID*) &pIVid);

            if(FAILED(hr)){

                throw(hr);
            }/* end of if statement */


            hr = pIVid->GetVideoSize((LONG*)&m_dwVideoWidth, (LONG*)&m_dwVideoHeight);

            pIVid->Release();

            if(FAILED(hr)){

                throw(hr);
            }/* end of if statement */
        }/* end of if statement */
        
        hr = ::CoCreateInstance(CLSID_DVDRect, NULL, CLSCTX_INPROC, IID_IDVDRect, (LPVOID*) ppRect);

        if(FAILED(hr)){

            throw(hr);
        }/* end of if statement */

        IDVDRect* pIRect = *ppRect; // just to make the code esier to read

        hr = pIRect->put_Width(m_dwVideoWidth);

        if(FAILED(hr)){

            throw(hr);
        }/* end of if statement */

        hr = pIRect->put_Height(m_dwVideoHeight);

        if(FAILED(hr)){

            throw(hr);
        }/* end of if statement */        
    }/* end of try statement */

    catch(HRESULT hrTmp){
        hr = hrTmp;

        if(NULL != pIVid){

            pIVid->Release();
            pIVid = NULL;
        }/* end of if statement */
    }/* end of catch statement */
    catch(...){
        hr = E_UNEXPECTED;

        if(NULL != pIVid){

            pIVid->Release();
            pIVid = NULL;
        }/* end of if statement */
    }/* end of catch statement */

	return HandleError(hr);
}/* end of function GetVideoSize */

/*************************************************************/
/* Name: AdjustDestRC
/* Description: Adjust dest RC to the right aspect ratio
/*************************************************************/
HRESULT CMSWebDVD::AdjustDestRC(){

    if(!m_fInitialized){

        return(E_FAIL);
    }/* end of if statement */
    m_rcPosAspectRatioAjusted = m_rcPos;
    RECT rc = m_rcPos;
    
    //ATLTRACE(TEXT("Dest Rect %d %d %d %d\n"), rc.left, rc.top, rc.right, rc.bottom);
    long width = RECTWIDTH(&rc);
    long height = RECTHEIGHT(&rc);
 
    // Make sure we get the right aspect ratio

    CComPtr<IDVDRect> pDvdRect;
    HRESULT hr = GetVideoSize(&pDvdRect);
    if (FAILED(hr))
        return hr;

    double aspectRatio = m_dwAspectX/(double)m_dwAspectY;

    long adjustedHeight, adjustedWidth;
    adjustedHeight = long (width / aspectRatio);

    if (adjustedHeight<=height) {
        rc.top += (height-adjustedHeight)/2;
        rc.bottom = rc.top + adjustedHeight;
    }
    
    else {
        adjustedWidth = long (height * aspectRatio);
        rc.left += (width - adjustedWidth)/2;
        rc.right = rc.left + adjustedWidth;
    }

    //ATLTRACE(TEXT("Ajusted Dest Rect %d %d %d %d\n"), rc.left, rc.top, rc.right, rc.bottom);
    m_rcPosAspectRatioAjusted = rc;
    return S_OK;
}

/*************************************************************************/
/* Function: SetClipVideoRect                                            */
/* Description: Set a video source rect. TODO: Might want to handle      */
/* preserving aspect ratio.                                              */
/*************************************************************************/
STDMETHODIMP CMSWebDVD::SetClipVideoRect(IDVDRect *pIRect){

    HRESULT hr = S_OK;
    IBasicVideo* pIVid = NULL; 

    try {
        INITIALIZE_GRAPH_IF_NEEDS_TO_BE

        long lLeft = 0, lTop = 0, lWidth = 0, lHeight = 0;
        if(NULL == pIRect){
            if (m_pClipRect) {
                delete  m_pClipRect;
                m_pClipRect = NULL;
            } /* end of if statement */
        }

        else {
            
            hr = pIRect->get_x(&lLeft);
            
            if(FAILED(hr)){
                
                throw(hr);
            }/* end of if statement */
            
            hr = pIRect->get_y(&lTop);
            
            if(FAILED(hr)){
                
                throw(hr);
            }/* end of if statement */
            
            hr = pIRect->get_Width(&lWidth);
            
            if(FAILED(hr)){
                
                throw(hr);
            }/* end of if statement */
            
            hr = pIRect->get_Height(&lHeight);
            
            if(FAILED(hr)){
                
                throw(hr);
            }/* end of if statement */
        }

        CComPtr<IDVDRect> pDvdRect;
        hr = GetVideoSize(&pDvdRect);
        if (FAILED(hr))
            throw(hr);

        // Get video width and height
        long videoWidth, videoHeight;
        pDvdRect->get_Width(&videoWidth);
        pDvdRect->get_Height(&videoHeight);

        if (lLeft < 0 || lLeft >= videoWidth || lTop < 0 || lTop >= videoHeight){

            throw(E_INVALIDARG);
        }/* end of if statement */

        if (lLeft+lWidth > videoWidth || lTop+lHeight > videoHeight){

            throw(E_INVALIDARG);
        }/* end of if statement */

        // Windowless case
        if (m_bWndLess) {
#if 0            
            hr = AdjustDestRC();

            if(FAILED(hr)){

                throw(hr);
            }/* end of if statement */

            RECT rc = m_rcPosAspectRatioAjusted;
            if (!pIRect) 
                rc = m_rcPos;
#else
            RECT rc = m_rcPos;
#endif

            HWND hwnd;

            hr = GetUsableWindow(&hwnd);

            if(FAILED(hr)){

                return(hr);
            }/* end of if statement */
                            
            ::MapWindowPoints(hwnd, ::GetDesktopWindow(), (LPPOINT)&rc, 2);
            
            //ATLTRACE(TEXT("Ajusted Dest Rect %d %d %d %d\n"), rc.left, rc.top, rc.right, rc.bottom);
            
            if(m_pDDEX){
                if (pIRect) {
                    if (!m_pClipRect) 
                        m_pClipRect = new RECT;
                    
                    m_pClipRect->left = lLeft;
                    m_pClipRect->top = lTop;
                    m_pClipRect->right = lLeft+lWidth;
                    m_pClipRect->bottom = lTop + lHeight;
                    hr = m_pDDEX->SetDrawParameters(m_pClipRect, &rc);
                }
                else {
                    hr = m_pDDEX->SetDrawParameters(NULL, &rc);
                }

            }/* end of if statement */
            
        }/* end of if statement */    

        // Windowed case, set it via IBasicVideo
        else {
            
            hr = TraverseForInterface(IID_IBasicVideo, (LPVOID*) &pIVid);
            
            if(FAILED(hr)){
                
                throw(hr);
            }/* end of if statement */
            
            if (pIRect) {
                if (!m_pClipRect) 
                    m_pClipRect = new RECT;
                
                m_pClipRect->left = lLeft;
                m_pClipRect->top = lTop;
                m_pClipRect->right = lLeft+lWidth;
                m_pClipRect->bottom = lTop + lHeight;
                
                hr = pIVid->SetSourcePosition(lLeft, lTop, lWidth, lHeight);
            }
            
            else {
                hr = pIVid->SetDefaultSourcePosition();
            }

            if(FAILED(hr)){
                
                throw(hr);
            }/* end of if statement */
            
            //hr = pIVid->SetDestinationPosition(m_rcPos.left, m_rcPos.top, WIDTH(&m_rcPos), HEIGHT(&m_rcPos));
            
            pIVid->Release();
            pIVid = NULL;
#if 0
            if(FAILED(hr)){
                
                throw(hr);
            }/* end of if statement */
#endif                            
        }

    }

    catch(HRESULT hrTmp){

        if(NULL != pIVid){

            pIVid->Release();
            pIVid = NULL;
        }/* end of if statement */

        hr = hrTmp;
    }/* end of catch statement */
    catch(...){
        if(NULL != pIVid){

            pIVid->Release();
            pIVid = NULL;
        }/* end of if statement */

        hr = E_UNEXPECTED;
    }/* end of catch statement */

    return HandleError(hr);
}/* end of function SetClipVideoRect */

/*************************************************************************/
/* Function: get_DVDAdm                                                  */
/* Description: Returns DVD admin interface.                             */
/*************************************************************************/
STDMETHODIMP CMSWebDVD::get_DVDAdm(IDispatch **pVal){

    HRESULT hr = S_OK;

    try {

        INITIALIZE_GRAPH_IF_NEEDS_TO_BE

        if (m_pDvdAdmin){

            hr = m_pDvdAdmin->QueryInterface(IID_IDispatch, (LPVOID*)pVal);
        }
        else {

            *pVal = NULL;            
            throw(E_FAIL);
        }/* end of if statement */
    
    }/* end of try statement */
    catch(HRESULT hrTmp){
        hr = hrTmp;
    }/* end of catch statement */
    catch(...){
        hr = E_UNEXPECTED;
    }/* end of catch statement */

	return HandleError(hr);
}/* end of function get_DVDAdm */

/*************************************************************************/
/* Function: GetPlayerParentalLevel                                      */
/* Description: Gets the player parental level.                          *
/*************************************************************************/
STDMETHODIMP CMSWebDVD::GetPlayerParentalLevel(long *plParentalLevel){
	HRESULT hr = S_OK;

    try {
        if(NULL == plParentalLevel){

            throw(E_POINTER);
        }/* end of if statement */

        INITIALIZE_GRAPH_IF_NEEDS_TO_BE

        if(!m_pDvdInfo2){

            throw(E_UNEXPECTED);
        }/* end of if statement */
        
        ULONG ulLevel;
        BYTE bCountryCode[2];
        hr = m_pDvdInfo2->GetPlayerParentalLevel(&ulLevel, bCountryCode); 

        if(SUCCEEDED(hr)){
            *plParentalLevel = ulLevel;
        } 
        else {
            *plParentalLevel = 0;
        }/* end of if statement */

    }/* end of try statement */
    catch(HRESULT hrTmp){

        hr = hrTmp;
    }/* end of catch statement */
    catch(...){

        hr = E_UNEXPECTED;
    }/* end of catch statement */

	return HandleError(hr);
}/* end of function GetPlayerParentalLevel */

/*************************************************************************/
/* Function: GetPlayerParentalCountry                                    */
/* Description: Gets the player parental country.                        */
/*************************************************************************/
STDMETHODIMP CMSWebDVD::GetPlayerParentalCountry(long *plCountryCode){

	HRESULT hr = S_OK;

    try {
        if(NULL == plCountryCode){

            throw(E_POINTER);
        }/* end of if statement */

        INITIALIZE_GRAPH_IF_NEEDS_TO_BE

        if(!m_pDvdInfo2){

            throw(E_UNEXPECTED);
        }/* end of if statement */

        BYTE bCountryCode[2];
        ULONG ulLevel;
        hr = m_pDvdInfo2->GetPlayerParentalLevel(&ulLevel, bCountryCode); 

        if(SUCCEEDED(hr)){

            *plCountryCode = bCountryCode[0]<<8 | bCountryCode[1];
        } 
        else {

            *plCountryCode = 0;
        }/* end of if statement */

    }/* end of try statement */
    catch(HRESULT hrTmp){

        hr = hrTmp;
    }/* end of catch statement */
    catch(...){

        hr = E_UNEXPECTED;
    }/* end of catch statement */

	return HandleError(hr);
}/* end of function GetPlayerParentalCountry */

/*************************************************************************/
/* Function: GetTitleParentalLevels                                      */
/* Description: Gets the parental level associated with a specific title.*/
/*************************************************************************/
STDMETHODIMP CMSWebDVD::GetTitleParentalLevels(long lTitle, long *plParentalLevels){

	HRESULT hr = S_OK;

    try {
        if(NULL == plParentalLevels){

            throw(E_POINTER);
        }/* end of if statement */

        INITIALIZE_GRAPH_IF_NEEDS_TO_BE

        if(!m_pDvdInfo2){

            throw(E_UNEXPECTED);
        }/* end of if statement */
        
        ULONG ulLevel;
        hr = m_pDvdInfo2->GetTitleParentalLevels(lTitle, &ulLevel); 

        if(SUCCEEDED(hr)){

            *plParentalLevels = ulLevel;
        } 
        else {

            *plParentalLevels = 0;
        }/* end of if statement */

    }/* end of try statement */
    catch(HRESULT hrTmp){

        hr = hrTmp;
    }/* end of catch statement */
    catch(...){

        hr = E_UNEXPECTED;
    }/* end of catch statement */

	return HandleError(hr);
}/* end of function GetTitleParentalLevels */

/*************************************************************************/
/* Function: SelectParentalLevel                                         */
/* Description: Selects the parental level.                              */
/*************************************************************************/
STDMETHODIMP CMSWebDVD::SelectParentalLevel(long lParentalLevel, BSTR strUserName, BSTR strPassword){

    HRESULT hr = S_OK;

    try {

        if (lParentalLevel != LEVEL_DISABLED && 
           (lParentalLevel < LEVEL_G || lParentalLevel > LEVEL_ADULT)) {

            throw (E_INVALIDARG);
        } /* end of if statement */

        INITIALIZE_GRAPH_IF_NEEDS_TO_BE

        // Confirm password first
        VARIANT_BOOL temp;
        hr = m_pDvdAdmin->_ConfirmPassword(NULL, strPassword, &temp);
        if (temp == VARIANT_FALSE)
            throw (E_ACCESSDENIED);
    
        hr = SelectParentalLevel(lParentalLevel);

    }
    catch(HRESULT hrTmp){

        hr = hrTmp;
    }
    catch(...){
        hr = E_UNEXPECTED;
    }

    return HandleError(hr);
}

/*************************************************************************/
/* Function: SelectParentalLevel                                         */
/* Description: Selects the parental level.                              */
/*************************************************************************/
HRESULT CMSWebDVD::SelectParentalLevel(long lParentalLevel){

    HRESULT hr = S_OK;
    try {

        //INITIALIZE_GRAPH_IF_NEEDS_TO_BE

        if(!m_pDvdCtl2){

            throw(E_UNEXPECTED);
        }/* end of if statement */

        hr = m_pDvdCtl2->SelectParentalLevel(lParentalLevel);
    }/* end of try statement */
    catch(HRESULT hrTmp){

        hr = hrTmp;
    }/* end of catch statement */
    catch(...){

        hr = E_UNEXPECTED;
    }/* end of catch statement */

	return (hr);
}/* end of function SelectParentalLevel */

/*************************************************************************/
/* Function: SelectParentalCountry                                       */
/* Description: Selects Parental Country.                                */
/*************************************************************************/
STDMETHODIMP CMSWebDVD::SelectParentalCountry(long lCountry, BSTR strUserName, BSTR strPassword){

    HRESULT hr = S_OK;

    try {

        if(lCountry < 0 && lCountry > 0xffff){

            throw(E_INVALIDARG);
        }/* end of if statement */

        INITIALIZE_GRAPH_IF_NEEDS_TO_BE

        // Confirm password first
        VARIANT_BOOL temp;
        hr = m_pDvdAdmin->_ConfirmPassword(NULL, strPassword, &temp);
        if (temp == VARIANT_FALSE)
            throw (E_ACCESSDENIED);

        hr = SelectParentalCountry(lCountry);

    }
    catch(HRESULT hrTmp){

        hr = hrTmp;
    }
    catch(...){
        hr = E_UNEXPECTED;
    }

    return HandleError(hr);
}

/*************************************************************************/
/* Function: SelectParentalCountry                                       */
/* Description: Selects Parental Country.                                */
/*************************************************************************/
HRESULT CMSWebDVD::SelectParentalCountry(long lCountry){

    HRESULT hr = S_OK;
    try {

        if(!m_pDvdCtl2){

            throw(E_UNEXPECTED);
        }/* end of if statement */

        BYTE bCountryCode[2];

        bCountryCode[0] = BYTE(lCountry>>8);
        bCountryCode[1] = BYTE(lCountry);

        hr = m_pDvdCtl2->SelectParentalCountry(bCountryCode);
    }/* end of try statement */
    catch(HRESULT hrTmp){

        hr = hrTmp;
    }/* end of catch statement */
    catch(...){
        
        hr = E_UNEXPECTED;
    }/* end of catch statement */

	return (hr);
}/* end of function SelectParentalCountry */

/*************************************************************************/
/* Function: put_NotifyParentalLevelChange                               */
/* Description: Sets the flag if to notify when parental level change    */
/* notification is required on the fly.                                  */
/*************************************************************************/
STDMETHODIMP CMSWebDVD::NotifyParentalLevelChange(VARIANT_BOOL fNotify){

	HRESULT hr = S_OK;

    try {
        //TODO: Add IE parantal level control
        INITIALIZE_GRAPH_IF_NEEDS_TO_BE

        if(!m_pDvdCtl2){

            throw(E_UNEXPECTED);
        }/* end of if statement */

        hr = m_pDvdCtl2->SetOption(DVD_NotifyParentalLevelChange,
                          VARIANT_FALSE == fNotify? FALSE : TRUE);
    }/* end of try statement */
    catch(HRESULT hrTmp){

        hr = hrTmp;
    }/* end of catch statement */
    catch(...){

        hr = E_UNEXPECTED;
    }/* end of catch statement */

	return HandleError(hr);
}/* end of function NotifyParentalLevelChange */

/*************************************************************************/
/* Function: AcceptParentalLevelChange                                   */
/* Description: Accepts the temprary parental level change that is       */
/* done on the fly.                                                      */
/*************************************************************************/
STDMETHODIMP CMSWebDVD::AcceptParentalLevelChange(VARIANT_BOOL fAccept, BSTR strUserName, BSTR strPassword){

    VARIANT_BOOL fRight;
    HRESULT hr = m_pDvdAdmin->_ConfirmPassword(NULL, strPassword, &fRight);

    // if password is wrong and want to accept, no 
    if (fAccept != VARIANT_FALSE && fRight == VARIANT_FALSE)
        return E_ACCESSDENIED;

    try {  
        // should not make sense to do initialization here, since this should
        // be a response to a callback
        //INITIALIZE_GRAPH_IF_NEEDS_TO_BE

        if(!m_pDvdCtl2){

            throw(E_UNEXPECTED);
        }/* end of if statement */

        hr = m_pDvdCtl2->AcceptParentalLevelChange(VARIANT_FALSE == fAccept? FALSE : TRUE);
    }/* end of try statement */
    catch(HRESULT hrTmp){

        hr = hrTmp;
    }/* end of catch statement */
    catch(...){

        hr = E_UNEXPECTED;
    }/* end of catch statement */

	return HandleError(hr);
}/* end of function AcceptParentalLevelChange */

/*************************************************************/
/* Name: Eject                                               */
/* Description: Stop DVD playback and eject DVD from drive   */
/* Inserts the disk as well.                                 */
/*************************************************************/
STDMETHODIMP CMSWebDVD::Eject(){

    HRESULT hr = S_OK;

    try {      
        USES_CONVERSION;
	    DWORD  dwHandle;
    
        BSTR root;
        hr = get_DVDDirectory(&root);
        if (FAILED(hr)) 
            throw (hr);

        LPTSTR szDriveLetter = OLE2T(root);
        ::SysFreeString(root);

	    if(m_bEjected == false){	

		    if(szDriveLetter[0] == 0){

			    throw(S_FALSE);
		    }/* end of if statement */
	    
		    DWORD dwErr;
		    dwHandle = OpenCdRom(szDriveLetter[0], &dwErr);
		    if (dwErr != MMSYSERR_NOERROR){

			    throw(S_FALSE);
		    }/* end of if statement */

		    EjectCdRom(dwHandle);
	    }
        else{
            //do uneject
		    DWORD dwErr;
		    dwHandle = OpenCdRom(szDriveLetter[0], &dwErr);
		    if (dwErr != MMSYSERR_NOERROR){

			    throw(S_FALSE);
		    }/* end of if statement */
		    UnEjectCdRom(dwHandle);

	    }/* end of if statement */
	    CloseCdRom(dwHandle);	        
    }/* end of try statement */
    catch(HRESULT hrTmp){

        hr = hrTmp;
    }/* end of catch statement */
    catch(...){

        hr = E_UNEXPECTED;
    }/* end of catch statement */

	return HandleError(hr);
}/* end of function Eject */

/*************************************************************************/
/* Function: SetGPRM                                                     */
/* Description: Sets a GPRM at index.                                    */
/*************************************************************************/
STDMETHODIMP CMSWebDVD::SetGPRM(long lIndex, short sValue){

    HRESULT hr = S_OK;

    try {
        if(lIndex < 0){

            throw(E_INVALIDARG);
        }/* end of if statement */

        INITIALIZE_GRAPH_IF_NEEDS_TO_BE

        if(!m_pDvdCtl2){

            throw(E_UNEXPECTED);
        }/* end of if statement */

        hr = m_pDvdCtl2->SetGPRM(lIndex, sValue, cdwDVDCtrlFlags, 0);
            
    }/* end of try statement */
    catch(HRESULT hrTmp){

        hr = hrTmp;
    }/* end of catch statement */
    catch(...){
        
        hr = E_UNEXPECTED;
    }/* end of catch statement */

	return HandleError(hr);
}/* end of function SetGPRM */

/*************************************************************************/
/* Function: Capture                                                     */
/* Capture a image from DVD stream, convert it to RGB, and save it       */
/* to file.                                                              */
/*************************************************************************/
STDMETHODIMP CMSWebDVD::Capture(){

    HWND hwnd = NULL;
    HRESULT hr = S_OK;
    YUV_IMAGE *lpImage = NULL;
    try {

        hr = GetUsableWindow(&hwnd);

        if(FAILED(hr)){

            throw(hr);
        }/* end of if statement */

        INITIALIZE_GRAPH_IF_NEEDS_TO_BE

        if(::IsWindow(m_hWnd)){
            
            throw(E_NO_CAPTURE_SUPPORT);
        }/* end of if statement */

        if(!m_pDDEX){

            throw(E_UNEXPECTED);    
        }/* end of if statement */

        hr = m_pDDEX->IsImageCaptureSupported();

        if(S_FALSE == hr){

            throw(E_FORMAT_NOT_SUPPORTED);
        }/* end of if statement */

        hr = m_pDDEX->GetCurrentImage(&lpImage);
        if (SUCCEEDED(hr))
        {
#if 0
            // use the GDI version first, it should work when GDI+ is installed (Millennium)
			// otherwise use the standalone version
			// 12.04.00 GDI+ interfaces have changed and the function needs to be rewritten
			// look at this for blackcomb maybe for now just do the non-GDI+ function
            hr = GDIConvertImageAndSave(lpImage, m_pClipRect, hwnd); 

            if(FAILED(hr))
#endif
            {
                hr = ConvertImageAndSave(lpImage, m_pClipRect, hwnd);   

                if(FAILED(hr)){

                    throw(hr);
                }/* end of if statement */
            }
        }
    }/* end of try statement */
    catch(HRESULT hrTmp){

        hr = hrTmp;
    }/* end of catch statement */
    catch(...){
        
        hr = E_UNEXPECTED;
    }/* end of catch statement */
	if(lpImage){
		CoTaskMemFree(lpImage);
	}
	return HandleError(hr);
}/* end of function Capture */

/*************************************************************/
/* Name: get_CursorType                                      */
/* Description: Return cursor type over video                */
/*************************************************************/
STDMETHODIMP CMSWebDVD::get_CursorType(DVDCursorType *pVal){

    HRESULT hr = S_OK;

    try {
        if(NULL == pVal){

            throw(E_POINTER);
        }/* end of if statement */

        *pVal = m_nCursorType;
    }/* end of try statement */
    catch(HRESULT hrTmp){

        hr = hrTmp;
    }/* end of catch statement */
    catch(...){
        
        hr = E_UNEXPECTED;
    }/* end of catch statement */

	return HandleError(hr);
}/* end of function get_CursorType */

/*************************************************************/
/* Name: put_CursorType                                      */
/* Description: Set cursor type over video                   */
/*************************************************************/
STDMETHODIMP CMSWebDVD::put_CursorType(DVDCursorType newVal){

    HRESULT hr = S_OK;

    try {

        if (newVal<dvdCursor_None || newVal>dvdCursor_Hand) {

            throw (E_INVALIDARG);
        } /* end of if statement */

        m_nCursorType = newVal;
        if (m_hCursor)
            ::DestroyCursor(m_hCursor);
        switch(m_nCursorType) {
        case dvdCursor_ZoomIn:
        case dvdCursor_ZoomOut:
            m_hCursor = ::LoadCursor(_Module.GetModuleInstance(), MAKEINTRESOURCE(IDC_ZOOMIN));
            break;
        case dvdCursor_Hand:
            m_hCursor = ::LoadCursor(_Module.GetModuleInstance(), MAKEINTRESOURCE(IDC_HAND));            
            break;
        case dvdCursor_Arrow:
        default:
        

            //#define OCR_ARROW_DEFAULT 100
            // need special cursor, we we do not have color key around it
            //m_hCursor  = (HCURSOR) ::LoadImage((HINSTANCE) NULL,
            //                        MAKEINTRESOURCE(OCR_ARROW_DEFAULT),
            //                       IMAGE_CURSOR,0,0,0);
        

            m_hCursor = ::LoadCursor(NULL, MAKEINTRESOURCE(OCR_ARROW_DEFAULT));
            break;
        }

        if (m_hCursor)
            ::SetCursor(m_hCursor);
    }/* end of try statement */
    catch(HRESULT hrTmp){

        hr = hrTmp;
    }/* end of catch statement */
    catch(...){
        
        hr = E_UNEXPECTED;
    }/* end of catch statement */

	return HandleError(hr);
}/* end of function put_CursorType */

/*************************************************************/
/* Name: Zoom
/* Description: Zoom in at (x, y) in original video
/*  enlarge or decrease video size by zoomRatio
/*  if zoomRatio > 1    zoom in
/*  if zoomRatio = 1
/*  if zoomRatio < 1    zoom out
/*  if zoomRatio <= 0   invalid
/*************************************************************/
STDMETHODIMP CMSWebDVD::Zoom(long x, long y, double zoomRatio){

    HRESULT hr = S_OK;

    try {
        if (zoomRatio< 0){

            throw(E_INVALIDARG);
        }/* end of if statement */

        // Can't go beyond 1.0
        if (m_dZoomRatio <= 1.0) {
            if (zoomRatio <= 1.0) {
                m_dZoomRatio = 1.0;
                throw(hr);
            }
            m_dZoomRatio = 1.0;
        }

        // Can't go beyond the max stretch factor
        if (m_dZoomRatio*zoomRatio > m_dwOvMaxStretch/1000.0)
            throw hr;

        m_dZoomRatio *= zoomRatio;

        // Can't go beyond 1.0
        if (m_dZoomRatio <= 1.0)
            m_dZoomRatio = 1.0;

        CComPtr<IDVDRect> pDvdRect;
        hr = GetVideoSize(&pDvdRect);
        if (FAILED(hr))
            throw(hr);

        if(1.0 == m_dZoomRatio){

            hr = SetClipVideoRect(NULL);

            put_CursorType(dvdCursor_Arrow);
            throw(hr);
        }/* end of if statement */

        // Get video width and height
        long videoWidth, videoHeight;
        pDvdRect->get_Width(&videoWidth);
        pDvdRect->get_Height(&videoHeight);

        if (x < 0 || x >= videoWidth || y < 0 || y >= videoHeight){

            throw(E_INVALIDARG);
        }/* end of if statement */

        // Compute new clipping width and height
        long mcd = MCD(m_dwVideoWidth, m_dwVideoHeight);
        long videoX = m_dwVideoWidth/mcd;
        long videoY = m_dwVideoHeight/mcd;

        long newClipHeight = (long) (videoHeight/m_dZoomRatio);
        newClipHeight /= videoY;
        newClipHeight *= videoY;
        if (newClipHeight < 1) newClipHeight = 1;
        long newClipWidth =  (long) (newClipHeight*videoX/videoY);
        if (newClipWidth < 1) newClipWidth = 1;

        // Can't go beyong native video size
        if (newClipWidth>videoWidth)
            newClipWidth = videoWidth;
        if (newClipHeight>videoHeight)
            newClipHeight = videoHeight;
        if (newClipWidth == videoWidth && newClipHeight == videoHeight) {
            put_CursorType(dvdCursor_Arrow);
        }
        else {
            put_CursorType(dvdCursor_Hand);
        }

        long newClipX = x - newClipWidth/2;
        long newClipY = y - newClipHeight/2;

        // Can't go outsize the native video rect
        if (newClipX < 0)
            newClipX = 0;
        else if (newClipX + newClipWidth > videoWidth)
            newClipX = videoWidth - newClipWidth;

        if (newClipY < 0)
            newClipY = 0;
        else if (newClipY + newClipHeight > videoHeight)
            newClipY = videoHeight - newClipHeight;

        CComPtr<IDVDRect> pDvdClipRect;
        hr = GetClipVideoRect(&pDvdClipRect);
        if (FAILED(hr))
            throw(hr);
        pDvdClipRect->put_x(newClipX);
        pDvdClipRect->put_y(newClipY);
        pDvdClipRect->put_Width(newClipWidth);
        pDvdClipRect->put_Height(newClipHeight);
        hr = SetClipVideoRect(pDvdClipRect);

    }
    catch(HRESULT hrTmp){
        
        hr = hrTmp;
    }/* end of catch statement */
    catch(...){
        
        hr = E_UNEXPECTED;
    }/* end of catch statement */

	return HandleError(hr);
}/* end of function Zoom */

/*************************************************************************/
/* Function: RegionChange                                                */
/* Description:Changes the region code.                                  */
/*************************************************************************/
STDMETHODIMP CMSWebDVD::RegionChange(){

    USES_CONVERSION;
    HRESULT hr = S_OK;
    typedef BOOL (APIENTRY *DVDPPLAUNCHER) (HWND HWnd, CHAR DriveLetter);


    try {
        HWND parentWnd = NULL;
        HRESULT hrTmp = GetParentHWND(&parentWnd);
        if (SUCCEEDED(hrTmp) && (NULL != parentWnd)) {
            // take the container out of the top-most mode
            ::SetWindowPos(parentWnd, HWND_NOTOPMOST, 0, 0, 0, 0, 
                SWP_NOREDRAW|SWP_NOMOVE|SWP_NOSIZE);
        }

        BOOL regionChanged = FALSE;
        OSVERSIONINFO ver;
        ver.dwOSVersionInfoSize = sizeof(OSVERSIONINFO);
        ::GetVersionEx(&ver);

        if (ver.dwPlatformId==VER_PLATFORM_WIN32_NT) {

                HINSTANCE dllInstance;
                DVDPPLAUNCHER dvdPPLauncher;
                TCHAR szCmdLine[MAX_PATH], szDriveLetter[4];
                LPSTR szDriveLetterA;

                //
                // tell the user why we are showing the dvd region property page
                //
                // DVDMessageBox(m_hWnd, IDS_REGION_CHANGE_PROMPT);

                hr = getDVDDriveLetter(szDriveLetter);

                if(FAILED(hr)){
					hr = E_UNEXPECTED;
                    throw(hr);
                }/* end of if statement */

                szDriveLetterA = T2A(szDriveLetter);

                GetSystemDirectory(szCmdLine, MAX_PATH);
                StringCchCat(szCmdLine, sizeof(szCmdLine) / sizeof(szCmdLine), _T("\\storprop.dll"));
        
                dllInstance = LoadLibrary (szCmdLine);
                if (dllInstance) {

                        dvdPPLauncher = (DVDPPLAUNCHER) GetProcAddress(
                                                            dllInstance,
                                                            "DvdLauncher");
                
                        if (dvdPPLauncher) {

                                regionChanged = dvdPPLauncher(this->m_hWnd,
                                                              szDriveLetterA[0]);
                        }

                        FreeLibrary(dllInstance);
                }

        } 
        else {
#if 0 // need to check for win9x or winnt
                INITIALIZE_GRAPH_IF_NEEDS_TO_BE

                //Get path of \windows\dvdrgn.exe and command line string
                TCHAR szCmdLine[MAX_PATH], szDriveLetter[4];
                
                hr = getDVDDriveLetter(szDriveLetter);

                if(FAILED(hr)){

                    throw(hr);
                }/* end of if statement */

                GetWindowsDirectory(szCmdLine, MAX_PATH);
                StringCchCat(szCmdLine, sizeof(szCmdLine) / sizeof(szCmdLine[0]),  _T("\\dvdrgn.exe "));
                TCHAR strModuleName[MAX_PATH];
                lstrcpyn(strModuleName, szCmdLine, sizeof(strModuleName) / sizeof(strModuleName[0]));

                TCHAR csTmp[2]; ::ZeroMemory(csTmp, sizeof(TCHAR)* 2);
                csTmp[0] = szDriveLetter[0];
                StringCchCat(szCmdLine, sizeof(szCmdLine) / sizeof(szCmdLine[0]), csTmp);
        
                //Prepare and execuate dvdrgn.exe
                STARTUPINFO StartupInfo;
                PROCESS_INFORMATION ProcessInfo;
                StartupInfo.cb          = sizeof(StartupInfo);
                StartupInfo.dwFlags     = STARTF_USESHOWWINDOW;
                StartupInfo.wShowWindow = SW_SHOW;
                StartupInfo.lpReserved  = NULL;
                StartupInfo.lpDesktop   = NULL;
                StartupInfo.lpTitle     = NULL;
                StartupInfo.cbReserved2 = 0;
                StartupInfo.lpReserved2 = NULL;
                if( ::CreateProcess(strModuleName, szCmdLine, NULL, NULL, TRUE, NORMAL_PRIORITY_CLASS,
                                                  NULL, NULL, &StartupInfo, &ProcessInfo) ){

                        //Wait dvdrgn.exe finishes.
                        WaitForSingleObject(ProcessInfo.hProcess, INFINITE);
                        DWORD dwRet = 1;
                        BOOL bRet = GetExitCodeProcess(ProcessInfo.hProcess, &dwRet);
                        if(dwRet == 0){
                            //User changed the region successfully
                            regionChanged = TRUE;
    
                        }
                        else{
                            throw(E_REGION_CHANGE_NOT_COMPLETED);
                        }
                }/* end of if statement */
#endif
        }/* end of if statement */

        if (regionChanged) {

                // start playing again
                hr = Play();                        
        } 
        else {

            throw(E_REGION_CHANGE_FAIL);
        }/* end of if statement */

	}
    catch(HRESULT hrTmp){
        
        hr = hrTmp;
    }/* end of catch statement */
    catch(...){
        
        hr = E_UNEXPECTED;
    }/* end of catch statement */

	return HandleError(hr);
}/* end of function RegionChange */

/*************************************************************************/
/* Function: getDVDDriveLetter                                           */
/* Description: Gets the first three characters that denote the DVD-ROM  */
/*************************************************************************/
HRESULT CMSWebDVD::getDVDDriveLetter(TCHAR* lpDrive) {

    HRESULT hr = E_FAIL;

	if(!m_pDvdInfo2){

        hr = E_UNEXPECTED;
        return(hr);
    }/* end of if statement */
        
    WCHAR szRoot[MAX_PATH];
    ULONG ulActual;

    hr = m_pDvdInfo2->GetDVDDirectory(szRoot, MAX_PATH, &ulActual);

    if(FAILED(hr)){

        return(hr);
    }/* end of if statement */

    USES_CONVERSION;
    
	lstrcpyn(lpDrive, OLE2T(szRoot), 3);
    if(::GetDriveType(&lpDrive[0]) == DRIVE_CDROM){
        
		return(hr);
    }
    else {
        //possibly root=c: or drive in hard disc
        hr = E_FAIL;
        return(hr);
    }/* end of if statement */


    // does not seem to make sense to loop to figure out the drive letter
#if 0
    DWORD totChrs = GetLogicalDriveStrings(MAX_PATH, szTemp); //get all drives
	ptr = szTemp;
	for(DWORD i = 0; i < totChrs; i+=4)      //look at these drives one by one
	{
		if(GetDriveType(ptr) == DRIVE_CDROM) //look only CD-ROM and see if it has a disc
		{
			TCHAR achDVDFilePath1[MAX_PATH], achDVDFilePath2[MAX_PATH];
			lstrcpyn(achDVDFilePath1, ptr, 4);
			lstrcpyn(achDVDFilePath2, ptr, 4);
			lstrcat(achDVDFilePath1, _T("Video_ts\\Video_ts.ifo"));
			lstrcat(achDVDFilePath2, _T("Video_ts\\Vts_01_0.ifo"));

			if( ((CDvdplayApp*) AfxGetApp())->DoesFileExist(achDVDFilePath1) &&
				((CDvdplayApp*) AfxGetApp())->DoesFileExist(achDVDFilePath2) )							
			{
				lstrcpyn(lpDrive, ptr, 3);
				return(hr);   //Return the first found drive which has a valid DVD disc
			}
		}
		ptr += 4; 
	}
#endif

    return(hr);
}/* end of function getDVDDriveLetter */

/*************************************************************/
/* Name: SelectDefaultAudioLanguage
/* Description: 
/*************************************************************/
STDMETHODIMP CMSWebDVD::SelectDefaultAudioLanguage(long lang, long ext){

    HRESULT hr = S_OK;
    try {
        INITIALIZE_GRAPH_IF_NEEDS_TO_BE
        if(!m_pDvdCtl2 || !m_pDvdAdmin){

            throw(E_UNEXPECTED);
        }/* end of if statement */

        hr = m_pDvdCtl2->SelectDefaultAudioLanguage(lang, (DVD_AUDIO_LANG_EXT)ext);
        if (FAILED(hr))
            throw(hr);

        // Save it with DVDAdmin
        //hr = m_pDvdAdmin->put_DefaultAudioLCID(lang);
        //if (FAILED(hr))
        //    throw(hr);
    }

    catch(HRESULT hrTmp){

        hr = hrTmp;
    }/* end of catch statement */
    catch(...){

        hr = E_UNEXPECTED;
    }/* end of catch statement */
    
    return HandleError(hr);

}

/*************************************************************/
/* Name: SelectDefaultSubpictureLanguage
/* Description: 
/*************************************************************/
STDMETHODIMP CMSWebDVD::SelectDefaultSubpictureLanguage(long lang, DVDSPExt ext){

    HRESULT hr = S_OK;
    try {
        INITIALIZE_GRAPH_IF_NEEDS_TO_BE
        if(!m_pDvdCtl2 || !m_pDvdAdmin){

            throw(E_UNEXPECTED);
        }/* end of if statement */

        hr = m_pDvdCtl2->SelectDefaultSubpictureLanguage(lang, (DVD_SUBPICTURE_LANG_EXT)ext);
        if (FAILED(hr))
            throw(hr);

        // Save it with DVDAdmin
        //hr = m_pDvdAdmin->put_DefaultSubpictureLCID(lang);
        //if (FAILED(hr))
        //    throw(hr);
    }

    catch(HRESULT hrTmp){

        hr = hrTmp;
    }/* end of catch statement */
    catch(...){

        hr = E_UNEXPECTED;
    }/* end of catch statement */
    
    return HandleError(hr);

}

/*************************************************************/
/* Name: put_DefaultMenuLanguage
/* Description: 
/*************************************************************/
STDMETHODIMP CMSWebDVD::put_DefaultMenuLanguage(long lang){

    HRESULT hr = S_OK;
    try {
        INITIALIZE_GRAPH_IF_NEEDS_TO_BE
        if(!m_pDvdCtl2 || !m_pDvdAdmin){

            throw(E_UNEXPECTED);
        }/* end of if statement */

        hr = m_pDvdCtl2->SelectDefaultMenuLanguage(lang);
        if (FAILED(hr))
            throw(hr);

        // Save it with DVDAdmin
        //hr = m_pDvdAdmin->put_DefaultMenuLCID(lang);
        //if (FAILED(hr))
        //    throw(hr);
    }

    catch(HRESULT hrTmp){

        hr = hrTmp;
    }/* end of catch statement */
    catch(...){

        hr = E_UNEXPECTED;
    }/* end of catch statement */
    
    return HandleError(hr);

}

/*************************************************************************/
/* Function: get_PreferredSubpictureStream                                    */
/* Description: Gets current audio stream.                               */
/*************************************************************************/
STDMETHODIMP CMSWebDVD::get_PreferredSubpictureStream(long *plPreferredStream){

    HRESULT hr = S_OK;

    try {
	    if (NULL == plPreferredStream){

            throw(E_POINTER);         
        }/* end of if statement */

        LCID langDefaultSP;
        m_pDvdAdmin->get_DefaultSubpictureLCID((long*)&langDefaultSP);
        
        // if none has been set
        if (langDefaultSP == (LCID) -1) {
            
            *plPreferredStream = 0;
            return hr;
        } /* end of if statement */
        
        INITIALIZE_GRAPH_IF_NEEDS_TO_BE
            
        if(!m_pDvdInfo2){
            
            throw(E_UNEXPECTED);
        }/* end of if statement */
        
        USES_CONVERSION;
        LCID lcid = 0;
        
        ULONG ulNumAudioStreams = 0;
        ULONG ulCurrentStream = 0;
        BOOL  fDisabled = TRUE;
        RETRY_IF_IN_FPDOM(m_pDvdInfo2->GetCurrentSubpicture(&ulNumAudioStreams, &ulCurrentStream, &fDisabled));
        
        *plPreferredStream = 0;
        for (ULONG i = 0; i<ulNumAudioStreams; i++) {
            hr = m_pDvdInfo2->GetSubpictureLanguage(i, &lcid);
            if (SUCCEEDED( hr ) && lcid){
                if (lcid == langDefaultSP) {
                    *plPreferredStream = i;
                }
            }
        }
    }
    
    catch(HRESULT hrTmp){
        return hrTmp;
    }/* end of catch statement */

    catch(...){
        return E_UNEXPECTED;
    }/* end of catch statement */

	return HandleError(hr);
}

/*************************************************************/
/* Name: get_AspectRatio
/* Description: 
/*************************************************************/
STDMETHODIMP CMSWebDVD::get_AspectRatio(double *pVal)
{

    HRESULT hr = S_OK;

    // Make sure we get the right aspect ratio
    try {
	    if (NULL == pVal){

            throw(E_POINTER);         
        }/* end of if statement */

        CComPtr<IDVDRect> pDvdRect;
        hr = GetVideoSize(&pDvdRect);
        if (FAILED(hr))
            throw(hr);
        
        //ATLTRACE(TEXT("get_AspectRatio, %d %d \n"), m_dwAspectX, m_dwAspectY);
        *pVal = (m_dwAspectX*1.0)/m_dwAspectY;
    }
    
    catch(HRESULT hrTmp){
        return hrTmp;
    }/* end of catch statement */
    
    catch(...){
        return E_UNEXPECTED;
    }/* end of catch statement */

	return HandleError(hr);
}

/*************************************************************************/
/* Function: CanStep                                                     */
/*************************************************************************/
STDMETHODIMP CMSWebDVD::CanStep(VARIANT_BOOL fBackwards, VARIANT_BOOL *pfCan){
   
    HRESULT hr = S_OK;
    try {
	    if (NULL == pfCan){

            throw(E_POINTER);         
        }/* end of if statement */

        INITIALIZE_GRAPH_IF_NEEDS_TO_BE

        *pfCan = VARIANT_FALSE;

        // Can't step if still is on
        if (m_fStillOn == true) {
            throw (hr);
        }/* end of if statement */

        if(!m_pVideoFrameStep){
            
            throw(E_UNEXPECTED);
        }/* end of if statement */

        if(VARIANT_FALSE != fBackwards){

            if(S_OK != CanStepBackwards()){

                // we cannot step on decodors that do not provide smooth backward playback
                //*pfCan = VARIANT_FALSE; already set above so do not have to do that any more
                hr = S_OK;
                throw(hr);
            }/* end of if statement */
        }/* end of if statement */
        
        hr = m_pVideoFrameStep->CanStep(1L, NULL);

        if(S_OK == hr){

            *pfCan = VARIANT_TRUE;
        }/* end of if statement */

        hr = S_OK;

	}
    catch(HRESULT hrTmp){

        hr = hrTmp;
    }/* end of catch statement */
    catch(...){

        hr = E_UNEXPECTED;
    }/* end of catch statement */
    
    return HandleError(hr);
}/* end of function CanStep */

/*************************************************************************/
/* Function: Step                                                        */
/* Description: Steps forwards or backwords. Mutes un umutes sound if    */
/* necessary.                                                            */
/*************************************************************************/
STDMETHODIMP CMSWebDVD::Step(long lStep){

	HRESULT hr = S_OK;
    try {
        INITIALIZE_GRAPH_IF_NEEDS_TO_BE

        if(!m_pDvdInfo2){

            throw(E_UNEXPECTED);
        }/* end of if statement */    

        if(lStep < 0){
            // going backwards so check if we can do it
            if(S_OK != CanStepBackwards()){
                
                hr = E_FAIL; // aperently we cannot on this decoder
                throw(hr);
            }/* end of if statement */
        }/* end of if statement */

        if(!m_pVideoFrameStep){
            
            throw(E_UNEXPECTED);
        }/* end of if statement */

        bool fUnMute = false;

        if(FALSE == m_bMute){
            
            hr = put_Mute(VARIANT_TRUE);
            if (SUCCEEDED(hr)){

                fUnMute = true;
            }/* end of if statement */
        }/* end if if statement */        

        ProcessEvents(); // cleanup the message queu

        m_fStepComplete = false;

        hr = m_pVideoFrameStep->Step(lStep, NULL);
        
        if(SUCCEEDED(hr)){

            HRESULT hrTmp = hr;
            hr = E_FAIL;
            for(INT i = 0; i < cgnStepTimeout; i++){


                // now wait for EC_STEP_COMPLETE flag
                ProcessEvents(); 
                if(m_fStepComplete){

                    hr = hrTmp;
                    break;
                }/* end of if statement */
                ::Sleep(cdwTimeout);
            }/* end of for loop */
        }/* end of if statement */

        if(fUnMute){

            hr = put_Mute(VARIANT_FALSE);
            if (FAILED(hr)){

                throw(hr);
            }/* end of if statement */
        }/* end if if statement */        

        if(FAILED(hr)){

            throw(hr);
        }/* end of if statement */

	}
    catch(HRESULT hrTmp){

        hr = hrTmp;
    }/* end of catch statement */
    catch(...){

        hr = E_UNEXPECTED;
    }/* end of catch statement */
    
    return HandleError(hr);
}/* end of function Step */

/*************************************************************/
/* Function: CanStepBackwards                                */
/* Description: Checks if the decoder can step backwqards    */
/* cashesh the variable.                                     */
/* Returns S_OK if can, S_FALSE otherwise                    */
/*************************************************************/
HRESULT CMSWebDVD::CanStepBackwards(){

    HRESULT hr = S_OK;

    if(m_fBackWardsFlagInitialized){
        
        // pulling out the result from the cache
        return (m_fCanStepBackwards ? S_OK : S_FALSE);
    }/* end of if statement */
    
    DVD_DECODER_CAPS dvdCaps; 
    ::ZeroMemory(&dvdCaps, sizeof(DVD_DECODER_CAPS));
    dvdCaps.dwSize = sizeof(DVD_DECODER_CAPS);

    hr = m_pDvdInfo2->GetDecoderCaps(&dvdCaps);

    if(FAILED(hr)){

        return(hr);
    }/* end of if statement */

    //dvdCaps.dBwdMaxRateVideo is zero if decoder does not support smooth reverse
    // playback that means it will not support reverse stepping mechanism as well
    if(0 == dvdCaps.dBwdMaxRateVideo){

        // we cannot step on decodors that do not provide smooth backward playback
        m_fBackWardsFlagInitialized = true;
        m_fCanStepBackwards = false;

        hr = S_FALSE;
        return(hr);
    }/* end of if statement */

    m_fBackWardsFlagInitialized = true;
    m_fCanStepBackwards = true;
    hr = S_OK;

    return(hr);
}/* end of function CanStepBackwards */

/*************************************************************/
/* Name: GetKaraokeChannelAssignment
/* Description: 
/*************************************************************/
STDMETHODIMP CMSWebDVD::GetKaraokeChannelAssignment(long lStream, long *lChannelAssignment)
{
    HRESULT hr = S_OK;

    try {
        if(!lChannelAssignment){
            return E_POINTER;
        }
        if(lStream < 0){

            throw(E_INVALIDARG);
        }/* end of if statement */

        INITIALIZE_GRAPH_IF_NEEDS_TO_BE

        if(!m_pDvdInfo2){

            throw(E_UNEXPECTED);
        }/* end of if statement */

        DVD_KaraokeAttributes attrib;
        RETRY_IF_IN_FPDOM(m_pDvdInfo2->GetKaraokeAttributes(lStream, &attrib));

        if(FAILED(hr)){

            throw(hr);
        }/* end of if statement */

        *lChannelAssignment = (long)attrib.ChannelAssignment;

    }/* end of try statement */
    catch(HRESULT hrTmp){

        hr = hrTmp;
    }/* end of catch statement */
    catch(...){

        hr = E_UNEXPECTED;
    }/* end of catch statement */

	return HandleError(hr);
}

/*************************************************************/
/* Name: GetKaraokeChannelContent
/* Description: 
/*************************************************************/
STDMETHODIMP CMSWebDVD::GetKaraokeChannelContent(long lStream, long lChan, long *lContent)
{
    HRESULT hr = S_OK;

    try {
        if(!lContent){
            return E_POINTER;
        }
        if(lStream < 0){

            throw(E_INVALIDARG);
        }/* end of if statement */

        if (lChan >=8 ) {

            throw(E_INVALIDARG);
        }/* end of if statement */

        INITIALIZE_GRAPH_IF_NEEDS_TO_BE

        if(!m_pDvdInfo2){

            throw(E_UNEXPECTED);
        }/* end of if statement */

        DVD_KaraokeAttributes attrib;
        RETRY_IF_IN_FPDOM(m_pDvdInfo2->GetKaraokeAttributes(lStream, &attrib));

        if(FAILED(hr)){

            throw(hr);
        }/* end of if statement */

        *lContent = (long)attrib.wChannelContents[lChan];

    }/* end of try statement */
    catch(HRESULT hrTmp){

        hr = hrTmp;
    }/* end of catch statement */
    catch(...){

        hr = E_UNEXPECTED;
    }/* end of catch statement */

	return HandleError(hr);
}

/*************************************************************/
/* Name: get_KaraokeAudioPresentationMode
/* Description: 
/*************************************************************/
STDMETHODIMP CMSWebDVD::get_KaraokeAudioPresentationMode(long *pVal)
{
    HRESULT hr = S_OK;

    try {

        if (NULL == pVal) {

            throw (E_POINTER);
        } /* end of if statement */

        *pVal = m_lKaraokeAudioPresentationMode;

    }/* end of try statement */
    catch(HRESULT hrTmp){

        hr = hrTmp;
    }/* end of catch statement */
    catch(...){

        hr = E_UNEXPECTED;
    }/* end of catch statement */

	return HandleError(hr);
}

/*************************************************************/
/* Name: put_KaraokeAudioPresentationMode
/* Description: 
/*************************************************************/
STDMETHODIMP CMSWebDVD::put_KaraokeAudioPresentationMode(long newVal)
{
    HRESULT hr = S_OK;

    try {

        INITIALIZE_GRAPH_IF_NEEDS_TO_BE

        if(!m_pDvdCtl2){

            throw(E_UNEXPECTED);
        }/* end of if statement */

        RETRY_IF_IN_FPDOM(m_pDvdCtl2->SelectKaraokeAudioPresentationMode((ULONG)newVal));

        if(FAILED(hr)){

            throw(hr);
        }/* end of if statement */

        // Cache the value
        m_lKaraokeAudioPresentationMode = newVal;

    }/* end of try statement */
    catch(HRESULT hrTmp){

        hr = hrTmp;
    }/* end of catch statement */
    catch(...){

        hr = E_UNEXPECTED;
    }/* end of catch statement */

	return HandleError(hr);
}

/*************************************************************/
/* Name: get_DefaultAudioLanguage
/* Description: 
/*************************************************************/
STDMETHODIMP CMSWebDVD::get_DefaultAudioLanguage(long *lang)
{
    HRESULT hr = S_OK;
    try {

        if(NULL == lang){

            throw (E_POINTER);
        }/* end of if statement */

        INITIALIZE_GRAPH_IF_NEEDS_TO_BE
        if(!m_pDvdInfo2){

            throw (E_UNEXPECTED);
        }/* end of if statement */

        long ext;
        hr = m_pDvdInfo2->GetDefaultAudioLanguage((LCID*)lang, (DVD_AUDIO_LANG_EXT*)&ext);
        if (FAILED(hr))
            throw(hr);
    }

    catch(HRESULT hrTmp){

        hr = hrTmp;
    }/* end of catch statement */
    catch(...){

        hr = E_UNEXPECTED;
    }/* end of catch statement */
    
    return HandleError(hr);
}

/*************************************************************/
/* Name: get_DefaultAudioLanguageExt
/* Description: 
/*************************************************************/
STDMETHODIMP CMSWebDVD::get_DefaultAudioLanguageExt(long *ext)
{
    HRESULT hr = S_OK;
    try {

        if(NULL == ext){

            throw (E_POINTER);
        }/* end of if statement */

        INITIALIZE_GRAPH_IF_NEEDS_TO_BE
        if(!m_pDvdInfo2){

            throw (E_UNEXPECTED);
        }/* end of if statement */

        long lang;
        hr = m_pDvdInfo2->GetDefaultAudioLanguage((LCID*)&lang, (DVD_AUDIO_LANG_EXT*)ext);
        if (FAILED(hr))
            throw(hr);
    }

    catch(HRESULT hrTmp){

        hr = hrTmp;
    }/* end of catch statement */
    catch(...){

        hr = E_UNEXPECTED;
    }/* end of catch statement */
    
    return HandleError(hr);
}

/*************************************************************/
/* Name: get_DefaultSubpictureLanguage
/* Description: 
/*************************************************************/
STDMETHODIMP CMSWebDVD::get_DefaultSubpictureLanguage(long *lang)
{
    HRESULT hr = S_OK;
    try {

        if(NULL == lang){

            throw (E_POINTER);
        }/* end of if statement */

        INITIALIZE_GRAPH_IF_NEEDS_TO_BE
        if(!m_pDvdInfo2){

            throw (E_UNEXPECTED);
        }/* end of if statement */

        long ext;
        hr = m_pDvdInfo2->GetDefaultSubpictureLanguage((LCID*)lang, (DVD_SUBPICTURE_LANG_EXT*)&ext);
        if (FAILED(hr))
            throw(hr);
    }

    catch(HRESULT hrTmp){

        hr = hrTmp;
    }/* end of catch statement */
    catch(...){

        hr = E_UNEXPECTED;
    }/* end of catch statement */
    
    return HandleError(hr);
}

/*************************************************************/
/* Name: get_DefaultSubpictureLanguageExt
/* Description: 
/*************************************************************/
STDMETHODIMP CMSWebDVD::get_DefaultSubpictureLanguageExt(DVDSPExt *ext)
{
    HRESULT hr = S_OK;
    try {

        if(NULL == ext){

            throw (E_POINTER);
        }/* end of if statement */

        INITIALIZE_GRAPH_IF_NEEDS_TO_BE
        if(!m_pDvdInfo2){

            throw (E_UNEXPECTED);
        }/* end of if statement */

        long lang;
        hr = m_pDvdInfo2->GetDefaultSubpictureLanguage((LCID*)&lang, (DVD_SUBPICTURE_LANG_EXT*)ext);
        if (FAILED(hr))
            throw(hr);
    }

    catch(HRESULT hrTmp){

        hr = hrTmp;
    }/* end of catch statement */
    catch(...){

        hr = E_UNEXPECTED;
    }/* end of catch statement */
    
    return HandleError(hr);
}

/*************************************************************/
/* Name: get_DefaultMenuLanguage
/* Description: 
/*************************************************************/
STDMETHODIMP CMSWebDVD::get_DefaultMenuLanguage(long *lang)
{
    HRESULT hr = S_OK;
    try {

        if(NULL == lang){

            throw (E_POINTER);
        }/* end of if statement */

        INITIALIZE_GRAPH_IF_NEEDS_TO_BE
        if(!m_pDvdInfo2){

            throw (E_UNEXPECTED);
        }/* end of if statement */

        hr = m_pDvdInfo2->GetDefaultMenuLanguage((LCID*)lang);
        if (FAILED(hr))
            throw(hr);
    }

    catch(HRESULT hrTmp){

        hr = hrTmp;
    }/* end of catch statement */
    catch(...){

        hr = E_UNEXPECTED;
    }/* end of catch statement */
    
    return HandleError(hr);
}

/*************************************************************/
/* Name: RestoreDefaultSettings
/* Description: 
/*************************************************************/
HRESULT CMSWebDVD::RestoreDefaultSettings()
{
    HRESULT hr = S_OK;
    try {

        INITIALIZE_GRAPH_IF_NEEDS_TO_BE
        
        if(!m_pDvdAdmin){
            
            throw (E_UNEXPECTED);
        }/* end of if statement */
        
        
        if(!m_pDvdInfo2){
            
            throw (E_UNEXPECTED);
        }/* end of if statement */
        
        // get the curent domain
        DVD_DOMAIN domain;
        
        hr = m_pDvdInfo2->GetCurrentDomain(&domain);
        
        if(FAILED(hr)){
            
            throw(hr);
        }/* end of if statement */
        
        // Have to be in the stop domain
        if(DVD_DOMAIN_Stop != domain)
            throw (VFW_E_DVD_INVALIDDOMAIN);
            
        long level;
        hr = m_pDvdAdmin->GetParentalLevel(&level);
        if (SUCCEEDED(hr))
            SelectParentalLevel(level);
        
        LCID audioLCID;
        LCID subpictureLCID;
        LCID menuLCID;
        
        hr = m_pDvdAdmin->get_DefaultAudioLCID((long*)&audioLCID);
        if (SUCCEEDED(hr))
            SelectDefaultAudioLanguage(audioLCID, 0);
        
        hr = m_pDvdAdmin->get_DefaultSubpictureLCID((long*)&subpictureLCID);
        if (SUCCEEDED(hr))
            SelectDefaultSubpictureLanguage(subpictureLCID, dvdSPExt_NotSpecified);
        
        hr = m_pDvdAdmin->get_DefaultMenuLCID((long*)&menuLCID);
        if (SUCCEEDED(hr))
            put_DefaultMenuLanguage(menuLCID);
        
    }
    
    catch(HRESULT hrTmp){
        
        hr = hrTmp;
    }/* end of catch statement */
    catch(...){
        
        hr = E_UNEXPECTED;
    }/* end of catch statement */
    
    return HandleError(hr);
}

/*************************************************************************/
/* DVD Helper Methods, used by the default interface                     */
/*************************************************************************/

/*************************************************************************/
/* Function: GetColorKey                                                 */
/* Description: Gets a colorkey via RGB filled COLORREF or palette index.*/
/* Helper function.                                                      */
/*************************************************************************/
HRESULT CMSWebDVD::GetColorKey(COLORREF* pClr)
{
    HRESULT hr = S_OK;

    if(m_pDvdGB == NULL)
        return(E_FAIL);

    CComPtr<IMixerPinConfig2> pMixerPinConfig;

    hr = m_pDvdGB->GetDvdInterface(IID_IMixerPinConfig2, (LPVOID *) &pMixerPinConfig);

    if(FAILED(hr))
        return(hr);    

    COLORKEY ck;
    DWORD    dwColor;

    hr = pMixerPinConfig->GetColorKey(&ck, &dwColor); // get the color key

    if(FAILED(hr))
        return(hr);    

    HWND hwnd = ::GetDesktopWindow();
    HDC hdc = ::GetWindowDC(hwnd);

    if(NULL == hdc){

        return(E_UNEXPECTED);
    }/* end of if statement */

    BOOL bPalette = (RC_PALETTE == (RC_PALETTE & GetDeviceCaps( hdc, RASTERCAPS )));
    
    if ((ck.KeyType & CK_INDEX)&& bPalette) {
        
        PALETTEENTRY PaletteEntry;
        UINT nTmp = GetSystemPaletteEntries( hdc, ck.PaletteIndex, 1, &PaletteEntry );
        if ( nTmp == 1 )
        {
            *pClr = RGB( PaletteEntry.peRed, PaletteEntry.peGreen, PaletteEntry.peBlue );
        }
    }
    else if (ck.KeyType & CK_RGB)
    {
        
        *pClr = ck.HighColorValue;  // set the RGB color
    }

    ::ReleaseDC(hwnd, hdc);
    return(hr);
}/* end of function GetColorKey */

/*************************************************************************/
/* Function: SetColorKey                                                 */
/* Description: Sets a colorkey via RGB filled COLORREF.                 */
/* Helper function.                                                      */
/*************************************************************************/
HRESULT CMSWebDVD::SetColorKey(COLORREF clr){
    HRESULT hr = S_OK;

    if(m_pDvdGB == NULL)
        return(E_FAIL);

    CComPtr<IMixerPinConfig2> pMixerPinConfig;
    hr = m_pDvdGB->GetDvdInterface(IID_IMixerPinConfig2, (LPVOID *) &pMixerPinConfig);

    if( SUCCEEDED( hr )){
        COLORKEY ck;

        HWND hwnd = ::GetDesktopWindow();
        HDC hdc = ::GetWindowDC(hwnd);

        if(NULL == hdc){

            return(E_UNEXPECTED);
        }/* end of if statement */

        if((::GetDeviceCaps(hdc, RASTERCAPS) & RC_PALETTE) == RC_PALETTE)
        {
            ck.KeyType = CK_INDEX|CK_RGB; // have an index to the palette
            ck.PaletteIndex = 253;
            PALETTEENTRY PaletteEntry;
            UINT nTmp = GetSystemPaletteEntries( hdc, ck.PaletteIndex, 1, &PaletteEntry );
            if ( nTmp == 1 )
            {
                ck.LowColorValue = ck.HighColorValue = RGB( PaletteEntry.peRed, PaletteEntry.peGreen, PaletteEntry.peBlue );
            }
        }
        else
        {
            ck.KeyType = CK_RGB;
            ck.LowColorValue = clr; 
            ck.HighColorValue = clr;
        }/* end of if statement */
        
        hr = pMixerPinConfig->SetColorKey(&ck);
        ::ReleaseDC(hwnd, hdc);
    }/* end of if statement */

    return hr;
}/* end of function SetColorKey */

/*************************************************************************/
/* Function: TwoDigitToByte                                              */
/*************************************************************************/
static BYTE TwoDigitToByte( const WCHAR* pTwoDigit ){

	int tens    = int(pTwoDigit[0] - L'0');
	return BYTE( (pTwoDigit[1] - L'0') + tens*10);
}/* end of function TwoDigitToByte */

/*************************************************************************/
/* Function: Bstr2DVDTime                                                */
/* Description: Converts a DVD Time info from BSTR into a TIMECODE.      */
/*************************************************************************/
HRESULT CMSWebDVD::Bstr2DVDTime(DVD_HMSF_TIMECODE *ptrTimeCode, const BSTR *pbstrTime){


    if(NULL == pbstrTime || NULL == ptrTimeCode){

        return E_INVALIDARG;
    }/* end of if statement */

    ::ZeroMemory(ptrTimeCode, sizeof(DVD_HMSF_TIMECODE));
    WCHAR *pszTime = *pbstrTime;

    ULONG lStringLength = wcslen(pszTime);

    if(0 == lStringLength){

        return E_INVALIDARG;
    }/* end of if statement */    
    TCHAR tszTimeSep[5];
    ::GetLocaleInfo(LOCALE_USER_DEFAULT, LOCALE_STIME, tszTimeSep, 5);  
    
    // If the string is two long, it is seconds only
    if(lStringLength == 2){
        ptrTimeCode->bSeconds = TwoDigitToByte( &pszTime[0] );
        return S_OK;
    }

    // Otherwise it is a normal time code of the format
    // 43:32:21:10
    // Where the ':' can be replaced with a localized string of upto 4 char in len
    // There is a possible error case where the length of the delimeter is different
    // then the current delimeter

    if(lStringLength >= (4*cgTIME_STRING_LEN)+(3 * _tcslen(tszTimeSep))){ // longest string nnxnnxnnxnn e.g. 43:23:21:10
                                                                         // where n is a number and 
                                                                         // x is a time delimeter usually ':', but can be any string upto 4 char in len)
        ptrTimeCode->bFrames    = TwoDigitToByte( &pszTime[(3*cgTIME_STRING_LEN)+(3*_tcslen(tszTimeSep))]);
    }

    if(lStringLength >= (3*cgTIME_STRING_LEN)+(2 * _tcslen(tszTimeSep))) { // string nnxnnxnn e.g. 43:23:21
        ptrTimeCode->bSeconds   = TwoDigitToByte( &pszTime[(2*cgTIME_STRING_LEN)+(2*_tcslen(tszTimeSep))] );
    }

    if(lStringLength >= (2*cgTIME_STRING_LEN)+(1 * _tcslen(tszTimeSep))) { // string nnxnn e.g. 43:23
        ptrTimeCode->bMinutes   = TwoDigitToByte( &pszTime[(1*cgTIME_STRING_LEN)+(1*_tcslen(tszTimeSep))] );
    }

    if(lStringLength >= (cgTIME_STRING_LEN)) { // string nn e.g. 43
        ptrTimeCode->bHours   = TwoDigitToByte( &pszTime[0] );
    }
    return (S_OK);
}/* end of function bstr2DVDTime */

/*************************************************************************/
/* Function: DVDTime2bstr                                                */
/* Description: Converts a DVD Time info from ULONG into a BSTR.         */
/*************************************************************************/
HRESULT CMSWebDVD::DVDTime2bstr( const DVD_HMSF_TIMECODE *pTimeCode, BSTR *pbstrTime){

    if(NULL == pTimeCode || NULL == pbstrTime) 
        return E_INVALIDARG;

    USES_CONVERSION;

    TCHAR tszTime[cgDVD_TIME_STR_LEN];
    TCHAR tszTimeSep[5];

    ::ZeroMemory(tszTime, sizeof(TCHAR)*cgDVD_TIME_STR_LEN);

    ::GetLocaleInfo(LOCALE_USER_DEFAULT, LOCALE_STIME, tszTimeSep, 5);


    StringCchPrintf( tszTime, sizeof(tszTime) / sizeof(tszTime[0]), TEXT("%02lu%s%02lu%s%02lu%s%02lu"), 
                pTimeCode->bHours,   tszTimeSep,
                pTimeCode->bMinutes, tszTimeSep,
                pTimeCode->bSeconds, tszTimeSep,
                pTimeCode->bFrames );
    
    *pbstrTime = SysAllocString(T2OLE(tszTime));
    return (S_OK);
}/* end of function DVDTime2bstr */

/*************************************************************************/
/* Function: SetupAudio                                                  */
/* Description: Initialize the audio interface.                          */
/*************************************************************************/
HRESULT CMSWebDVD::SetupAudio(){

    HRESULT hr = E_FAIL;

    try {
#if 0 // Using 
        if(!m_pDvdGB){

            throw(E_UNEXPECTED);
        }/* end of if statement */

        hr = m_pDvdGB->GetDvdInterface(IID_IBasicAudio, (LPVOID*) &m_pAudio) ;

        if(FAILED(hr)){

            ATLTRACE(TEXT("The QDVD.DLL does not support IID_IBasicAudio please update QDVD.DLL\n"));
            throw(hr);
        }/* end of if statement */

#else
        hr = TraverseForInterface(IID_IBasicAudio, (LPVOID*) &m_pAudio);

        if(FAILED(hr)){

             // might be a HW decoder
             HMIXER hmx = NULL;

             if(::mixerOpen(&hmx, 0, 0, 0, 0) != MMSYSERR_NOERROR){

                  hr = E_FAIL;
                  return(hr);
             }/* end of if statement */
             ::mixerClose(hmx);

             hr = S_OK;
        }/* end of if statement */

#endif
    }/* end of try statement */
    catch(HRESULT hrTmp){
        hr = hrTmp;
    }
    catch(...){
        hr = E_UNEXPECTED;
    }/* end of catch statement */

    return hr;
}/* end of function SetupAudio */

/*************************************************************************/
/* Function: TraverseForInterface                                        */
/* Description: Goes through the interface list and finds a desired one. */
/*************************************************************************/
HRESULT CMSWebDVD::TraverseForInterface(REFIID iid, LPVOID* ppvObject){

    HRESULT hr = E_FAIL;

    try {
        // take care and release any interface before passing
        // it over otherwise we leak

        if(!m_pDvdGB){

            throw(E_UNEXPECTED);
        }/* end of if statement */

        IGraphBuilder *pFilterGraph;

        hr = m_pDvdGB->GetFiltergraph(&pFilterGraph);

        if(FAILED(hr)){

            throw(hr);
        }/* end of if statement */

        CComPtr<IBaseFilter> pFilter;
        CComPtr<IEnumFilters> pEnum;
        
        hr = pFilterGraph->EnumFilters(&pEnum);

        pFilterGraph->Release();

        if(FAILED(hr)){

            throw(hr);
        }/* end of if statement */

        hr = E_FAIL; // set the hr to E_FAIL in case we do not find the IBasicAudio

        while(pEnum->Next(1, &pFilter, NULL) == S_OK){
            
            HRESULT hrTmp = pFilter->QueryInterface(iid, ppvObject);

            pFilter.Release();

            if(SUCCEEDED(hrTmp)){

                ATLASSERT(*ppvObject);
                // found our audio time to break
                if(*ppvObject == NULL){

                    throw(E_UNEXPECTED);
                }/* end of if statement */

                hr = hrTmp; // set the hr to SUCCEED
                break;
            }/* end of if statement */
        }/* end of while loop */
        
    }/* end of try statement */
    catch(HRESULT hrTmp){
        hr = hrTmp;
    }
    catch(...){
        hr = E_UNEXPECTED;
    }/* end of catch statement */

    return hr;
}/* end of function TraverseForInterface */
 
/*************************************************************************/
/* Function: SetupEventNotifySink                                        */
/* Description: Gets the event notify sink interface.                    */
/*************************************************************************/
HRESULT CMSWebDVD::SetupEventNotifySink(){

    HRESULT hr = E_FAIL;

    try {
        if(m_pMediaSink){

            m_pMediaSink.Release();
        }/* end of if statement */

        if(!m_pDvdGB){

            throw(E_UNEXPECTED);
        }/* end of if statement */

        IGraphBuilder *pFilterGraph;

        hr = m_pDvdGB->GetFiltergraph(&pFilterGraph);

        if(FAILED(hr)){

            throw(hr);
        }/* end of if statement */

        hr = pFilterGraph->QueryInterface(IID_IMediaEventSink, (void**)&m_pMediaSink);

        pFilterGraph->Release();
        
    }/* end of try statement */
    catch(HRESULT hrTmp){
        hr = hrTmp;
    }
    catch(...){
        hr = E_UNEXPECTED;
    }/* end of catch statement */

    return hr;
}/* end of function SetupEventNotifySink */

/*************************************************************************/
/* Function: OnPostVerbInPlaceActivate                                   */
/* Description: Creates the in place active object.                      */
/*************************************************************************/
HRESULT CMSWebDVD::OnPostVerbInPlaceActivate(){

    SetReadyState(READYSTATE_COMPLETE);

    return(S_OK);
}/* end of function OnPostVerbInPlaceActivate */

/*************************************************************************/
/* Function: RenderGraphIfNeeded                                         */
/* Description: Initializes graph if it needs to be.                     */ 
/*************************************************************************/
HRESULT CMSWebDVD::RenderGraphIfNeeded(){

    HRESULT hr = S_OK;

    try {
        m_DVDFilterState = dvdState_Undefined; // just a flag set so we can restore
                                               // graph state if the API fails
        if(!m_fInitialized){

            hr = Render(); // render the graph
        }/* end of if statement */
    }/* end of try statement */
    catch(HRESULT hrTmp){
        hr = hrTmp;
    }/* end of catch statement */
    catch(...){
        hr = E_UNEXPECTED;
    }/* end of catch statement */

	return(hr);
}/* end of function RenderGraphIfNeeded */

/*************************************************************************/
/* Function: PassFP_DOM                                                  */
/* Description: Gets into title domain, past fp domain.                  */ 
/*************************************************************************/
HRESULT CMSWebDVD::PassFP_DOM(){

    HRESULT hr = S_OK;

    try {
        // get the curent domain
        DVD_DOMAIN domain;

        //INITIALIZE_GRAPH_IF_NEEDS_TO_BE

        if(!m_pDvdInfo2){

            throw(E_UNEXPECTED);
        }/* end of if statement */

        hr = m_pDvdInfo2->GetCurrentDomain(&domain);

        if(FAILED(hr)){

            throw(hr);
        }/* end of if statement */
            
        if(DVD_DOMAIN_FirstPlay == domain /* || DVD_DOMAIN_VideoManagerMenu == domain */){
            // if the domain is FP_DOM wait a specified timeout 
            if(NULL == m_hFPDOMEvent){

                ATLTRACE(TEXT("The handle should have been already set \n"));
                throw(E_UNEXPECTED);
            }/* end of if statement */

            if(WAIT_OBJECT_0 == ::WaitForSingleObject(m_hFPDOMEvent, cdwMaxFP_DOMWait)){

                hr = S_OK;
            }
            else {

                hr = E_FAIL;
            }/* end of if statement */
        } 
        else {

            hr = E_FAIL; // we were not originally in FP_DOM so it should have worked
            // there is a potential for raice condition, when we issue the command
            // the command failed due to that we were not in FP_DOM, but after the execution
            // it has changed before we got a chance to look it up
        }/* end of if statement */        
    }/* end of try statement */
    catch(HRESULT hrTmp){
        hr = hrTmp;
    }/* end of catch statement */
    catch(...){
        hr = E_UNEXPECTED;
    }/* end of catch statement */

	return(hr);
}/* end of function PassFP_DOM */

/*************************************************************/
/* Name: OpenCdRom                                           */
/* Description: Open CDRom and return the device ID          */
/*************************************************************/
DWORD CMSWebDVD::OpenCdRom(TCHAR chDrive, LPDWORD lpdwErrCode){

	MCI_OPEN_PARMS  mciOpen;
	TCHAR           szElementName[4];
	TCHAR           szAliasName[32];
	DWORD           dwFlags;
	DWORD           dwAliasCount = GetCurrentTime();
	DWORD           dwRet;

    ZeroMemory( &mciOpen, sizeof(mciOpen) );

    mciOpen.lpstrDeviceType = (LPTSTR)MCI_DEVTYPE_CD_AUDIO;
    StringCchPrintf( szElementName, sizeof(szElementName) / sizeof(szElementName[0]), TEXT("%c:"), chDrive );
    StringCchPrintf( szAliasName, sizeof(szAliasName) / sizeof(szAliasName[0]), TEXT("SJE%lu:"), dwAliasCount );
    mciOpen.lpstrAlias = szAliasName;

    mciOpen.lpstrDeviceType = (LPTSTR)MCI_DEVTYPE_CD_AUDIO;
    mciOpen.lpstrElementName = szElementName;
    dwFlags = MCI_OPEN_ELEMENT | MCI_OPEN_ALIAS |
	      MCI_OPEN_TYPE | MCI_OPEN_TYPE_ID | MCI_WAIT;

	// send mci command
    dwRet = mciSendCommand(0, MCI_OPEN, dwFlags, reinterpret_cast<DWORD_PTR>(&mciOpen));

    if ( dwRet != MMSYSERR_NOERROR ) 
		mciOpen.wDeviceID = 0;

    if (lpdwErrCode != NULL)
		*lpdwErrCode = dwRet;

    return mciOpen.wDeviceID;
}/* end of function OpenCdRom */

/*************************************************************/
/* Name: CloseCdRom                                          */
/* Description: Close device handle for CDRom                */
/*************************************************************/
HRESULT CMSWebDVD::CloseCdRom(DWORD DevHandle){
	MCI_OPEN_PARMS  mciOpen;
    ZeroMemory( &mciOpen, sizeof(mciOpen) );
	MCIERROR theMciErr = mciSendCommand( DevHandle, MCI_CLOSE, 0L, reinterpret_cast<DWORD_PTR>(&mciOpen) );
    HRESULT hr = theMciErr ? E_FAIL : S_OK; // zero for success
    return (hr);
}/* end of function CloseCdRom */

/*************************************************************/
/* Name: EjectCdRom                                          */
/* Description: Open device door for CDRom                   */
/*************************************************************/
HRESULT CMSWebDVD::EjectCdRom(DWORD DevHandle){
	MCI_OPEN_PARMS  mciOpen;
    ZeroMemory( &mciOpen, sizeof(mciOpen) );
	MCIERROR theMciErr = mciSendCommand( DevHandle, MCI_SET, MCI_SET_DOOR_OPEN, reinterpret_cast<DWORD_PTR>(&mciOpen) );
    HRESULT hr = theMciErr ? E_FAIL : S_OK; // zero for success
    return (hr);
}/* end of function EjectCdRom */

/*************************************************************/
/* Name: UnEjectCdRom                                        */
/* Description: Close device door for CDRom                  */
/*************************************************************/
HRESULT CMSWebDVD::UnEjectCdRom(DWORD DevHandle){
	MCI_OPEN_PARMS  mciOpen;
    ZeroMemory( &mciOpen, sizeof(mciOpen) );

	MCIERROR theMciErr = mciSendCommand( DevHandle, MCI_SET, MCI_SET_DOOR_CLOSED, reinterpret_cast<DWORD_PTR>(&mciOpen) );
    HRESULT hr = theMciErr ? E_FAIL : S_OK; // zero for success
    return (hr);
}/* end of function UnEjectCdRom */

/*************************************************************************/
/* Function: SetupDDraw                                                  */
/* Description: Creates DDrawObject and Surface                          */
/*************************************************************************/
HRESULT CMSWebDVD::SetupDDraw(){

    HRESULT hr = E_UNEXPECTED;
        
    HWND hwnd;

    hr = GetUsableWindow(&hwnd);

    if(FAILED(hr)){

        return(hr);
    }/* end of if statement */

    IAMSpecifyDDrawConnectionDevice* pSDDC;
    hr = m_pDDEX->QueryInterface(IID_IAMSpecifyDDrawConnectionDevice, (LPVOID *)&pSDDC);
    if (FAILED(hr)){
        
        return(hr);
    }/* end of if statement */

    AMDDRAWGUID amGUID;
    hr = pSDDC->GetDDrawGUID(&amGUID);
    if (FAILED(hr)){

        pSDDC->Release();
        return(hr);
    }/* end of if statement */

    hr = pSDDC->GetDDrawGUIDs(&m_dwNumDevices, &m_lpInfo);
    pSDDC->Release();

    if(FAILED(hr)){

        return(hr);
    }/* end of if statement */

    UpdateCurrentMonitor(&amGUID);

    m_pDDrawDVD = new CDDrawDVD(this);

    if(NULL == m_pDDrawDVD){

        return(E_OUTOFMEMORY);
    }

    hr = m_pDDrawDVD->SetupDDraw(&amGUID, hwnd);

    return(hr);
}/* end of function SetupDDraw */

/*************************************************************************/
/* Function: TransformToWndwls                                           */
/* Description: Transforms the coordinates to screen onse.               */
/*************************************************************************/
HRESULT CMSWebDVD::TransformToWndwls(POINT& pt){

    HRESULT hr = S_FALSE;

    // we are windowless we need to map the points to screen coordinates
    if(m_bWndLess){

        HWND hwnd = NULL;

        hr = GetParentHWND(&hwnd);

        if(FAILED(hr)){

            return(hr);
        }/* end of if statement */

        if(!::IsWindow(hwnd)){

            hr = E_UNEXPECTED;
            return(hr);
        }/* end of if statement */

#ifdef _DEBUG
       // POINT ptOld = pt;
#endif

        ::MapWindowPoints(hwnd, ::GetDesktopWindow(), &pt, 1);

        hr = S_OK;

#ifdef _DEBUG
       // ATLTRACE(TEXT("Mouse Client:x= %d, y = %d, Screen: x=%d, y= %d\n"),ptOld.x, ptOld.y, pt.x, pt.y); 
#endif
    }/* end of if statement */

    return(hr);
}/* end of function TransformToWndwls */

/*************************************************************************/
/* Function: RestoreGraphState                                           */
/* Description: Restores the graph state.  Used when API fails.          */
/*************************************************************************/
HRESULT CMSWebDVD::RestoreGraphState(){

    HRESULT hr = S_OK;

    switch(m_DVDFilterState){
        case dvdState_Undefined: 
        case dvdState_Running:  // do not do anything 
            break;

        case dvdState_Unitialized:
        case dvdState_Stopped:  hr = Stop(); break;

        case dvdState_Paused: hr = Pause();		      
    }/* end of switch statement */

    return(hr);
}/* end of if statement */

/*************************************************************************/
/* Function: AppendString                                                */
/* Description: Appends a string to an existing one.                     */
/*************************************************************************/
HRESULT CMSWebDVD::AppendString(TCHAR* strDest, INT strID, LONG dwLen){

    TCHAR strBuffer[MAX_PATH];

    if(!::LoadString(_Module.m_hInstResource, strID, strBuffer, MAX_PATH)){

        return(E_UNEXPECTED);
    }/* end of if statement */

    StringCchCat(strDest, dwLen, strBuffer);

    return(S_OK);
}/* end of function AppendString */

/*************************************************************************/
/* Function: HandleError                                                 */
/* Description: Gets Error Descriptio, so we can suppor IError Info.     */
/*************************************************************************/
HRESULT CMSWebDVD::HandleError(HRESULT hr){

    try {

        if(FAILED(hr)){

            switch(hr){

                case E_REGION_CHANGE_FAIL: Error(IDS_REGION_CHANGE_FAIL);   return (hr);
                case E_NO_IDVD2_PRESENT: Error(IDS_EDVD2INT);   return (hr);
                case E_FORMAT_NOT_SUPPORTED: Error(IDS_FORMAT_NOT_SUPPORTED);   return (hr);
                case E_NO_DVD_VOLUME: Error(IDS_E_NO_DVD_VOLUME); return (hr);
                case E_REGION_CHANGE_NOT_COMPLETED: Error(IDS_E_REGION_CHANGE_NOT_COMPLETED); return(hr);
                case E_NO_SOUND_STREAM: Error(IDS_E_NO_SOUND_STREAM); return(hr);                    
                case E_NO_VIDEO_STREAM: Error(IDS_E_NO_VIDEO_STREAM); return(hr);                    
                case E_NO_OVERLAY: Error(IDS_E_NO_OVERLAY); return(hr);
                case E_NO_USABLE_OVERLAY: Error(IDS_E_NO_USABLE_OVERLAY); return(hr);
                case E_NO_DECODER: Error(IDS_E_NO_DECODER); return(hr);
                case E_NO_CAPTURE_SUPPORT: Error(IDS_E_NO_CAPTURE_SUPPORT); return(hr);
            }/* end of switch statement */

            // Ensure that the string is Null Terminated
            TCHAR strError[MAX_ERROR_TEXT_LEN+1];
            ZeroMemory(strError, MAX_ERROR_TEXT_LEN+1);


            if(AMGetErrorText(hr , strError , MAX_ERROR_TEXT_LEN)){
                USES_CONVERSION;
                Error(T2W(strError));
            } 
            else {
                ATLTRACE(TEXT("Unhandled Error Code \n")); // please add it
                ATLASSERT(FALSE);
            }/* end of if statement */
        }/* end of if statement */
    }/* end of try statement */
    catch(HRESULT hrTmp){

        hr = hrTmp;
    }/* end of catch statement */
    catch(...){
        // keep the hr same    
    }/* end of catch statement */
    
	return (hr);
}/* end of function HandleError */

/*************************************************************/
/* Name: get_ShowCursor                                      */
/*************************************************************/
STDMETHODIMP CMSWebDVD::get_ShowCursor(VARIANT_BOOL* pfShow)
{
   HRESULT hr = S_OK;

   try {

       if(NULL == pfShow){

           throw(E_POINTER);
       }/* end of if statement */

       CURSORINFO pci;
       ::ZeroMemory(&pci, sizeof(CURSORINFO));
       pci.cbSize = sizeof(CURSORINFO);

#if WINVER >= 0x0500
       if(!::GetCursorInfo(&pci)){
#else
       if(!CallGetCursorInfo(&pci)){
#endif
           throw(E_FAIL);
       }/* end of if statement */
       
       *pfShow = (pci.flags  == CURSOR_SHOWING) ? VARIANT_TRUE:VARIANT_FALSE;        
   }/* end of try statement */
    catch(HRESULT hrTmp){

        hr = hrTmp;
    }/* end of catch statement */
    catch(...){

        hr = E_UNEXPECTED;
    }/* end of catch statement */
    
	return (hr);
}/* end of function get_ShowCursor */

/*************************************************************/
/* Name: put_ShowCursor                                      */
/* Description: Shows the cursor or hides it.                */
/*************************************************************/
STDMETHODIMP CMSWebDVD::put_ShowCursor(VARIANT_BOOL fShow){

   HRESULT hr = S_OK;

   try {

        BOOL bTemp = (fShow==VARIANT_FALSE) ? FALSE:TRUE;

        if (bTemp)
            // Call ShowCursor(TRUE) until new counter is >= 0
            while (::ShowCursor(bTemp) < 0);
        else
            // Call ShowCursor(FALSE) until new counter is < 0
            while (::ShowCursor(bTemp) >= 0);

   }/* end of try statement */
    catch(HRESULT hrTmp){

        hr = hrTmp;
    }/* end of catch statement */
    catch(...){

        hr = E_UNEXPECTED;
    }/* end of catch statement */
    
	return (hr);
}/* end of function put_ShowCursor */

/*************************************************************/
/* Name: GetLangFromLangID                                   */
/*************************************************************/
STDMETHODIMP CMSWebDVD::GetLangFromLangID(long langID, BSTR* lang){

    HRESULT hr = S_OK;

    try {
        if (lang == NULL) {

            throw(E_POINTER);
        }/* end of if statement */

        USES_CONVERSION;
        if((unsigned long)langID > (WORD)langID){
            throw(E_INVALIDARG);
        }
        LPTSTR pszString = m_LangID.GetLangFromLangID((WORD)langID);
    
        if (pszString) {
            *lang = ::SysAllocString(T2OLE(pszString));
        }
        
        else {
            *lang = ::SysAllocString( L"");
            throw(E_INVALIDARG);
        }/* end of if statement */

    }/* end of try statement */
    catch(HRESULT hrTmp){

        hr = hrTmp;
    }/* end of catch statement */
    catch(...){

        hr = E_UNEXPECTED;
    }/* end of catch statement */
    
	return HandleError(hr);
}/* end of function GetLangFromLangID */

/*************************************************************/
/* Name: IsAudioStreamEnabled
/* Description: 
/*************************************************************/
STDMETHODIMP CMSWebDVD::IsAudioStreamEnabled(long lStream, VARIANT_BOOL *fEnabled)
{
    HRESULT hr = S_OK;

    try {
        if(lStream < 0){

            throw(E_INVALIDARG);
        }/* end of if statement */

        if (fEnabled == NULL) {

            throw(E_POINTER);
        }/* end of if statement */

        INITIALIZE_GRAPH_IF_NEEDS_TO_BE

        if(!m_pDvdInfo2){

            throw(E_UNEXPECTED);
        }/* end of if statement */

        BOOL temp;
        hr = m_pDvdInfo2->IsAudioStreamEnabled(lStream, &temp);
        if (FAILED(hr))
            throw hr;

        *fEnabled = temp==FALSE? VARIANT_FALSE:VARIANT_TRUE;

    }/* end of try statement */
    catch(HRESULT hrTmp){

        hr = hrTmp;
    }/* end of catch statement */
    catch(...){

        hr = E_UNEXPECTED;
    }/* end of catch statement */
    
	return HandleError(hr);
}

/*************************************************************/
/* Name: IsSubpictureStreamEnabled
/* Description: 
/*************************************************************/
STDMETHODIMP CMSWebDVD::IsSubpictureStreamEnabled(long lStream, VARIANT_BOOL *fEnabled)
{
    HRESULT hr = S_OK;

    try {
        if(lStream < 0){

            throw(E_INVALIDARG);
        }/* end of if statement */

        if (fEnabled == NULL) {

            throw(E_POINTER);
        }/* end of if statement */

        INITIALIZE_GRAPH_IF_NEEDS_TO_BE

        if(!m_pDvdInfo2){

            throw(E_UNEXPECTED);
        }/* end of if statement */

        BOOL temp;
        hr = m_pDvdInfo2->IsSubpictureStreamEnabled(lStream, &temp);
        if (FAILED(hr))
            throw hr;

        *fEnabled = temp==FALSE? VARIANT_FALSE:VARIANT_TRUE;

    }/* end of try statement */
    catch(HRESULT hrTmp){

        hr = hrTmp;
    }/* end of catch statement */
    catch(...){

        hr = E_UNEXPECTED;
    }/* end of catch statement */
    
	return HandleError(hr);
}

/*************************************************************/
/* Name: DVDTimeCode2bstr
/* Description: 
/*************************************************************/
STDMETHODIMP CMSWebDVD::DVDTimeCode2bstr(long timeCode, BSTR *pTimeStr)
{
    return DVDTime2bstr((DVD_HMSF_TIMECODE*)&timeCode, pTimeStr);
}

/*************************************************************/
/* Name: UpdateOverlay
/* Description: 
/*************************************************************/
HRESULT CMSWebDVD::UpdateOverlay()
{
    RECT rc;    
    HWND hwnd;
    
    if(m_bWndLess){
        HRESULT hr = GetParentHWND(&hwnd);
        
        if(FAILED(hr)){
            
            return(hr);
        }/* end of if statement */
        
        rc = m_rcPos;
    }
    else {
        hwnd = m_hWnd;
        ::GetClientRect(hwnd, &rc);
    }/* end of if statement */
    
    ::InvalidateRect(hwnd, &rc, FALSE);

    m_bFireUpdateOverlay = TRUE;
    return S_OK;
}

HRESULT CMSWebDVD::SetClientSite(IOleClientSite *pClientSite){
    if(!!pClientSite){
        HRESULT hr = IsSafeSite(pClientSite);
        if(FAILED(hr)){
            return hr;
        }
    }
    return IOleObjectImpl<CMSWebDVD>::SetClientSite(pClientSite);
}
/*************************************************************************/
/* End of file: msdvd.cpp                                                */
/*************************************************************************/
=== C:/Users/treeman/Desktop/windows nt source code\Source\Win2K3\NT\multimedia\dshow\mfvideo\mswebdvd\mslcid.cpp ===
/*************************************************************/
/* Name: lcid.cpp
/* Description: 
/*************************************************************/
#include <stdafx.h>
#include "mslcid.h"
#include "mswebdvd.h"
#include "msdvdadm.h"
#include "resource.h"

MSLangID::MSLangID() {
    static LanguageList LL[] = {
        { IDS_INI_LANG1, LANG_AFRIKAANS },
        { IDS_INI_LANG2, LANG_ALBANIAN },
        { IDS_INI_LANG3, LANG_ARABIC },
        { IDS_INI_LANG4, LANG_BASQUE },
        { IDS_INI_LANG5, LANG_BELARUSIAN },
        { IDS_INI_LANG6, LANG_BULGARIAN },
        { IDS_INI_LANG7, LANG_CATALAN },
        { IDS_INI_LANG8, LANG_CHINESE },
        { IDS_INI_LANG9, LANG_CROATIAN },
        { IDS_INI_LANG10, LANG_CZECH },
        { IDS_INI_LANG11, LANG_DANISH },
        { IDS_INI_LANG12, LANG_DUTCH },
        { IDS_INI_LANG13, LANG_ENGLISH },
        { IDS_INI_LANG14, LANG_ESTONIAN },
        { IDS_INI_LANG15, LANG_FAEROESE },
        { IDS_INI_LANG16, LANG_FARSI },
        { IDS_INI_LANG17, LANG_FINNISH },
        { IDS_INI_LANG18, LANG_FRENCH },
        { IDS_INI_LANG19, LANG_GERMAN },
        { IDS_INI_LANG20, LANG_GREEK },
        { IDS_INI_LANG21, LANG_HEBREW },
        { IDS_INI_LANG22, LANG_HUNGARIAN },
        { IDS_INI_LANG23, LANG_ICELANDIC },
        { IDS_INI_LANG24, LANG_INDONESIAN },
        { IDS_INI_LANG25, LANG_ITALIAN },
        { IDS_INI_LANG26, LANG_JAPANESE },
        { IDS_INI_LANG27, LANG_KOREAN },
        { IDS_INI_LANG28, LANG_LATVIAN },
        { IDS_INI_LANG29, LANG_LITHUANIAN },
        { IDS_INI_LANG30, LANG_MALAY },
        { IDS_INI_LANG31, LANG_NORWEGIAN },
        { IDS_INI_LANG32, LANG_POLISH },
        { IDS_INI_LANG33, LANG_PORTUGUESE },
        { IDS_INI_LANG34, LANG_ROMANIAN },
        { IDS_INI_LANG35, LANG_RUSSIAN },
        { IDS_INI_LANG36, LANG_SERBIAN },
        { IDS_INI_LANG37, LANG_SLOVAK },
        { IDS_INI_LANG38, LANG_SLOVENIAN },
        { IDS_INI_LANG39, LANG_SPANISH },
        { IDS_INI_LANG40, LANG_SWAHILI },
        { IDS_INI_LANG41, LANG_SWEDISH },
        { IDS_INI_LANG42, LANG_THAI },
        { IDS_INI_LANG43, LANG_TURKISH },
        { IDS_INI_LANG44, LANG_UKRAINIAN },
    };
    m_LL = LL;
    m_LLlength = sizeof(LL)/sizeof(LL[0]);
};

LPTSTR MSLangID::GetLangFromLangID(WORD langID){

    if (langID == LANG_NEUTRAL) {
        langID = (WORD)PRIMARYLANGID(::GetUserDefaultLangID());
    }

    LCID lcid =  MAKELCID(MAKELANGID(langID, SUBLANG_DEFAULT), SORT_DEFAULT);
    // Try to get it from the system first
        
    for(int i = 0; i < m_LLlength; i++) {
        if(m_LL[i].LangID == langID)
            return LoadStringFromRes(m_LL[i].ResourceID);
    }
	return NULL;
}/* end of function GetLangFromLangID */
=== C:/Users/treeman/Desktop/windows nt source code\Source\Win2K3\NT\multimedia\dshow\mfvideo\mswebdvd\msgwindow.cpp ===
// Copyright (c) 1999  Microsoft Corporation.  All Rights Reserved.
#include <stdafx.h>
#include <windows.h>

#include "msgwindow.h"
extern CComModule _Module;

// limit to this file
//
static const TCHAR szClassName[] = TEXT("CMSWEBDVDMsgWindowClass");
static const TCHAR szDefaultWindowName[] = TEXT("CMSWEBDVDMsgWindowClassName");

//
// CMessageWindow class implementation
// Generic goo to create a dummy window to handle events
//

static LRESULT CALLBACK StaticMsgWndProc(HWND hWnd, UINT uMsg, WPARAM wParam, LPARAM lParam)
{
    CMsgWindow* win = (CMsgWindow*) GetWindowLongPtr( hWnd, GWLP_USERDATA );
    if( !win ) {
        if( uMsg == WM_CREATE) {
            // on WM_CREATE messages the last parameter to CreateWindow() is returned in the lparam
            CREATESTRUCT* pCreate = (CREATESTRUCT *)lParam;
            win = (CMsgWindow*) pCreate->lpCreateParams;
            SetWindowLongPtr(hWnd, GWLP_USERDATA, (LONG_PTR)win);
            win->SetHandle(hWnd);
        } else {
            return DefWindowProc( hWnd, uMsg, wParam, lParam);
        }
    }
    return win->WndProc( uMsg, wParam, lParam );
}

CMsgWindow::CMsgWindow()
: m_hWnd( NULL )
{
    WNDCLASS wc;  // class data

    if (!GetClassInfo(_Module.GetModuleInstance(), szClassName, &wc))
    {
        //
        // Register message window class
        //
        ZeroMemory(&wc, sizeof(wc)) ;
        wc.lpfnWndProc   = StaticMsgWndProc ;
        wc.hInstance     = _Module.GetModuleInstance() ;
        wc.hbrBackground = (HBRUSH)(COLOR_WINDOW+1) ;
        wc.lpszClassName =  szClassName;
        wc.cbWndExtra = sizeof( LONG_PTR );
        if (0 == RegisterClass(&wc) ) // Oops, just leave; we'll catch later...
        {
        }
    }
}

bool CMsgWindow::Open( LPCTSTR pWindowName )
{
    if( m_hWnd ) {
        DestroyWindow( m_hWnd );
    }


    if (NULL == pWindowName) {
        pWindowName = szDefaultWindowName;
    }

    //
    // m_hWnd is assigned during WM_CREATE message processing
    //
    
    HWND hwnd =
    CreateWindowEx(WS_EX_TOOLWINDOW, szClassName, pWindowName,
        WS_ICONIC, 0, 0, 1, 1, NULL, NULL,
        GetModuleHandle(NULL),
        this );

    return (NULL != hwnd);
}

bool CMsgWindow::Close(){

    if(m_hWnd){
        DestroyWindow(m_hWnd);

        //SetWindowLongPtr(m_hWnd, GWLP_USERDATA, (LONG_PTR)0);
        //PostMessage(m_hWnd, WM_CLOSE, 0, 0);
        //m_hWnd = NULL;
    }/* end of if statement */

    return(true);
}/* end of function Close */

CMsgWindow::~CMsgWindow()
{
    SetWindowLongPtr(m_hWnd, GWLP_USERDATA, (LONG_PTR)0);
    PostMessage(m_hWnd, WM_CLOSE, 0, 0);
}

LRESULT CMsgWindow::WndProc( UINT uMsg, WPARAM wParam, LPARAM lParam )
{
    return DefWindowProc(m_hWnd, uMsg, wParam, lParam);
}
=== C:/Users/treeman/Desktop/windows nt source code\Source\Win2K3\NT\multimedia\dshow\mfvideo\mswebdvd\msdvdadm.h ===
/*************************************************************************/
/* Copyright (C) 1999 Microsoft Corporation                              */
/* File: MSDVDAdm.h                                                      */
/* Description: Declaration of the CMSDVDAdm                             */
/* Author: Fang Wang                                                     */
/*************************************************************************/

#ifndef __MSDVDADM_H_
#define __MSDVDADM_H_

#include "resource.h"       // main symbols
#include <atlctl.h>

#define MAX_PASSWD      256
#define PRE_PASSWD      20
#define MAX_SECTION     20
#define MAX_RATE        10

#define LEVEL_G		    1
#define LEVEL_PG	    3
#define LEVEL_PG13	    4
#define LEVEL_R		    6
#define LEVEL_NC17	    7
#define LEVEL_ADULT	    8
#define LEVEL_DISABLED  -1

/////////////////////////////////////////////////////////////////////////////
// CMSDVDAdm
class ATL_NO_VTABLE CMSDVDAdm : 
	public CComObjectRootEx<CComSingleThreadModel>,
	public IDispatchImpl<IMSDVDAdm, &IID_IMSDVDAdm, &LIBID_MSWEBDVDLib>,
    public IObjectWithSiteImplSec<CMSDVDAdm>,
	public CComCoClass<CMSDVDAdm, &CLSID_MSDVDAdm>,
    public ISupportErrorInfo
{
public:
	CMSDVDAdm();
    virtual ~CMSDVDAdm();

DECLARE_REGISTRY_RESOURCEID(IDR_MSDVDADM)

DECLARE_PROTECT_FINAL_CONSTRUCT()

BEGIN_COM_MAP(CMSDVDAdm)
	COM_INTERFACE_ENTRY(IMSDVDAdm)
	COM_INTERFACE_ENTRY(IDispatch)
    COM_INTERFACE_ENTRY(IObjectWithSite)
    COM_INTERFACE_ENTRY(ISupportErrorInfo)
END_COM_MAP()

BEGIN_PROP_MAP(CMSDVDAdm)
END_PROP_MAP()

// ISupportsErrorInfo
    STDMETHOD(InterfaceSupportsErrorInfo)(REFIID riid);

// IMSDVDAdm
public:
	STDMETHOD(get_DefaultMenuLCID)(/*[out, retval]*/ long *pVal);
	STDMETHOD(put_DefaultMenuLCID)(/*[in]*/ long newVal);
	STDMETHOD(get_DefaultSubpictureLCID)(/*[out, retval]*/ long *pVal);
	STDMETHOD(put_DefaultSubpictureLCID)(/*[in]*/ long newVal);
	STDMETHOD(get_DefaultAudioLCID)(/*[out, retval]*/ long *pVal);
	STDMETHOD(put_DefaultAudioLCID)(/*[in]*/ long newVal);
	STDMETHOD(GetParentalCountry)(long *lCountry);
	STDMETHOD(GetParentalLevel)(long *lLevel);
    STDMETHOD(_ConfirmPassword)(BSTR strUserName, BSTR szPassword, VARIANT_BOOL *fRight);
	STDMETHOD(get_DisableScreenSaver)(/*[out, retval]*/ VARIANT_BOOL *pVal);
	STDMETHOD(put_DisableScreenSaver)(/*[in]*/ VARIANT_BOOL newVal);
	STDMETHOD(ChangePassword)(BSTR strUserName, BSTR strOld, BSTR strNew);
    STDMETHOD(ConfirmPassword)(BSTR strUserName, BSTR szPassword, VARIANT_BOOL *fRight);
    STDMETHOD(SaveParentalLevel)(long lParentalLevel,BSTR strUserName,  BSTR strPassword);
    STDMETHOD(SaveParentalCountry)(long lCountry,BSTR strUserName,  BSTR strPassword);
	STDMETHOD(get_BookmarkOnStop)(/*[out, retval]*/ VARIANT_BOOL *pVal);
	STDMETHOD(put_BookmarkOnStop)(/*[in]*/ VARIANT_BOOL newVal);
	STDMETHOD(get_BookmarkOnClose)(/*[out, retval]*/ VARIANT_BOOL *pVal);
	STDMETHOD(put_BookmarkOnClose)(/*[in]*/ VARIANT_BOOL newVal);
    STDMETHOD(RestoreScreenSaver)();
protected:
   	long        m_lParentctrlLevel;
   	long        m_lParentctrlCountry;
    VARIANT_BOOL m_fDisableScreenSaver;
    BOOL        m_bScrnSvrOld;
    BOOL        m_bPowerlowOld;
    BOOL        m_bPowerOffOld;
    VARIANT_BOOL m_fBookmarkOnStop;
    VARIANT_BOOL m_fBookmarkOnClose;

    HRESULT EncryptPassword(LPTSTR lpPassword, BYTE **lpAssaultedHash, DWORD *dwCryptLen, DWORD *dwAssault, BOOL genAssault);
    HRESULT DisableScreenSaver();
    HRESULT SaveScreenSaver();
    HRESULT HandleError(HRESULT hr);
};

    // Lame functions that default to hklm
BOOL SetRegistryString(const TCHAR *pKey, TCHAR *szString, DWORD dwLen);
BOOL GetRegistryString(const TCHAR *pKey, TCHAR *szRet, DWORD *dwLen, TCHAR *szDefault);
BOOL SetRegistryDword(const TCHAR *pKey, DWORD dwRet);
BOOL GetRegistryDword(const TCHAR *pKey, DWORD *dwRet, DWORD dwDefault);
BOOL SetRegistryBytes(const TCHAR *pKey, BYTE *szString, DWORD dwLen);
BOOL GetRegistryBytes(const TCHAR *pKey, BYTE *szRet, DWORD *dwLen);

    // Not so lame functions that use hkcu
BOOL SetRegistryStringCU(const TCHAR *pKey, TCHAR *szString, DWORD dwLen);
BOOL GetRegistryStringCU(const TCHAR *pKey, TCHAR *szRet, DWORD *dwLen, TCHAR *szDefault);
BOOL SetRegistryDwordCU(const TCHAR *pKey, DWORD dwRet);
BOOL GetRegistryDwordCU(const TCHAR *pKey, DWORD *dwRet, DWORD dwDefault);
BOOL SetRegistryBytesCU(const TCHAR *pKey, BYTE *szString, DWORD dwLen);
BOOL GetRegistryBytesCU(const TCHAR *pKey, BYTE *szRet, DWORD *dwLen);

LPTSTR LoadStringFromRes(DWORD redId);

#endif //__MSDVDADM_H_

/*************************************************************************/
/* End of file: MSDVDAdm.h                                               */
/*************************************************************************/
=== C:/Users/treeman/Desktop/windows nt source code\Source\Win2K3\NT\multimedia\dshow\mfvideo\mswebdvd\mslcid.h ===
/*************************************************************/
/* Name: MSLCID.h
/* Description: 
/*************************************************************/
#ifndef MSLCID_H_INCLUDE
#define MSLCID_H_INCLUDE

class MSLangID  
{
public:
    virtual ~MSLangID() {};
    MSLangID();

	struct LanguageList
	{
		UINT   ResourceID;
		WORD   LangID;
	};

	int m_LLlength;
	LanguageList* m_LL;

	LPTSTR GetLangFromLangID(WORD langID);
};

#endif
=== C:/Users/treeman/Desktop/windows nt source code\Source\Win2K3\NT\multimedia\dshow\mfvideo\mswebdvd\objectwithsiteimplsec.h ===
///////////////////////////////////////////////////////////
// ObjectWithSiteImplSec.h : Secure implementation of IObjectWithSite
// Copyright (c) Microsoft Corporation 2002.

#pragma once

#ifndef OBJECTWITHSITEIMPLSEC_H
#define OBJECTWITHSITEIMPLSEC_H
#include <guiddef.h>
#include <ocidl.h>
#include <urlmon.h>

#if defined(DEBUG) || defined(W32_OBJECT_STREAMING)
#include <atlconv.h>
#endif
using namespace ::ATL;
#include <strsafe.h>

inline HRESULT IsSafeZone(DWORD dwZone) {
    switch (dwZone) {
    case URLZONE_LOCAL_MACHINE:
    case URLZONE_INTRANET:
    case URLZONE_TRUSTED:
        // the fixed list of zones we trust
        return NOERROR;
    default:  
        // everything else is untrusted
        return E_FAIL;
    }
}
inline HRESULT IsSafeSite(IUnknown* pSite) {
    CComQIPtr<IServiceProvider> psp(pSite);
    if (!psp) {
        // no service provider interface on the site implies that we're not running in IE
        // so by defn running local and trusted thus we return OK
        return NOERROR;
    }
    CComQIPtr<IInternetHostSecurityManager> pManager;
    HRESULT hr = psp->QueryService(SID_SInternetHostSecurityManager, IID_IInternetHostSecurityManager, (LPVOID *)&pManager);
    if (FAILED(hr)) {
        // no security manager interface on the site's service provider implies that we're not 
        // running in IE, so by defn running local and trusted thus we return OK
        return NOERROR;
    }
    const int MAXZONE = MAX_SIZE_SECURITY_ID+6/*scheme*/+4/*zone(dword)*/+1/*wildcard*/+1/*trailing null*/;
    char pbSecurityId[MAXZONE];
    DWORD pcbSecurityId = sizeof(pbSecurityId);
    ZeroMemory(pbSecurityId, sizeof(pbSecurityId));
    hr = pManager->GetSecurityId(reinterpret_cast<BYTE*>(pbSecurityId), &pcbSecurityId, NULL);
    if(FAILED(hr)){
        // security manager not working(unexpected). but, the site tried to provide one. thus we
        // must assume untrusted content and fail
        return E_FAIL;   
    }
    char *pbEnd = pbSecurityId + pcbSecurityId - 1;
    if (*pbEnd == '*') {  //ignore the optional wildcard flag
        pbEnd--;
    }
    pbEnd -= 3;  // point to beginning of little endian zone dword
    DWORD dwZone = *(reinterpret_cast<long *>(pbEnd));
    return IsSafeZone(dwZone);
}


template<class T> 
class ATL_NO_VTABLE IObjectWithSiteImplSec : public IObjectWithSite {

public:

    CComPtr<IUnknown> m_pSite;

// IObjectWithSite
    STDMETHOD(GetSite)(REFIID iid, void** ppvSite) {
        if (!ppvSite) {
            return E_POINTER;
        }
		T* pT = static_cast<T*>(this);

        if (!pT->m_pSite) {
            return E_NOINTERFACE;
        }
        return pT->m_pSite->QueryInterface(iid, ppvSite);
    }
    STDMETHOD(SetSite)(IUnknown* pSite) {
        HRESULT hr = IsSafeSite(pSite);
        if (SUCCEEDED(hr)) {
		    T* pT = static_cast<T*>(this);
            pT->m_pSite = pSite;
        }
        return hr;
    }

};

#endif // OBJECTWITHSITEIMPLSEC_H
// end of file objectwithsiteimplsec.h
=== C:/Users/treeman/Desktop/windows nt source code\Source\Win2K3\NT\multimedia\dshow\mfvideo\mswebdvd\mswebdvdcp.h ===
// Copyright (c) 1999  Microsoft Corporation.  All Rights Reserved.
#ifndef _MSWEBDVDCP_H_
#define _MSWEBDVDCP_H_




template <class T>
class CProxy_IMSWebDVD : public IConnectionPointImpl<T, &DIID__IMSWebDVD, CComDynamicUnkArray>
{
	//Warning this class may be recreated by the wizard.
public:
	VOID Fire_DVDNotify(long lEventCode, VARIANT lParam1, VARIANT lParam2)
	{
		T* pT = static_cast<T*>(this);
		int nConnectionIndex;
		CComVariant* pvars = new CComVariant[3];
		int nConnections = m_vec.GetSize();
		
		for (nConnectionIndex = 0; nConnectionIndex < nConnections; nConnectionIndex++)
		{
			pT->Lock();
			CComPtr<IUnknown> sp = m_vec.GetAt(nConnectionIndex);
			pT->Unlock();
			IDispatch* pDispatch = reinterpret_cast<IDispatch*>(sp.p);
			if (pDispatch != NULL)
			{
				pvars[2] = lEventCode;
				pvars[1] = lParam1;
				pvars[0] = lParam2;
				DISPPARAMS disp = { pvars, NULL, 3, 0 };
				pDispatch->Invoke(0x1, IID_NULL, LOCALE_USER_DEFAULT, DISPATCH_METHOD, &disp, NULL, NULL, NULL);
			}
		}
		delete[] pvars;
	
	}
	VOID Fire_PlayForwards(VARIANT_BOOL bEnabled)
	{
		T* pT = static_cast<T*>(this);
		int nConnectionIndex;
		CComVariant* pvars = new CComVariant[1];
		int nConnections = m_vec.GetSize();
		
		for (nConnectionIndex = 0; nConnectionIndex < nConnections; nConnectionIndex++)
		{
			pT->Lock();
			CComPtr<IUnknown> sp = m_vec.GetAt(nConnectionIndex);
			pT->Unlock();
			IDispatch* pDispatch = reinterpret_cast<IDispatch*>(sp.p);
			if (pDispatch != NULL)
			{
				pvars[0] = bEnabled;
				DISPPARAMS disp = { pvars, NULL, 1, 0 };
				pDispatch->Invoke(0x2, IID_NULL, LOCALE_USER_DEFAULT, DISPATCH_METHOD, &disp, NULL, NULL, NULL);
			}
		}
		delete[] pvars;
	
	}
	VOID Fire_PlayBackwards(VARIANT_BOOL bEnabled)
	{
		T* pT = static_cast<T*>(this);
		int nConnectionIndex;
		CComVariant* pvars = new CComVariant[1];
		int nConnections = m_vec.GetSize();
		
		for (nConnectionIndex = 0; nConnectionIndex < nConnections; nConnectionIndex++)
		{
			pT->Lock();
			CComPtr<IUnknown> sp = m_vec.GetAt(nConnectionIndex);
			pT->Unlock();
			IDispatch* pDispatch = reinterpret_cast<IDispatch*>(sp.p);
			if (pDispatch != NULL)
			{
				pvars[0] = bEnabled;
				DISPPARAMS disp = { pvars, NULL, 1, 0 };
				pDispatch->Invoke(0x3, IID_NULL, LOCALE_USER_DEFAULT, DISPATCH_METHOD, &disp, NULL, NULL, NULL);
			}
		}
		delete[] pvars;
	
	}
	VOID Fire_ShowMenu(DVDMenuIDConstants __MIDL_0011, VARIANT_BOOL bEnabled)
	{
		T* pT = static_cast<T*>(this);
		int nConnectionIndex;
		CComVariant* pvars = new CComVariant[2];
		int nConnections = m_vec.GetSize();
		
		for (nConnectionIndex = 0; nConnectionIndex < nConnections; nConnectionIndex++)
		{
			pT->Lock();
			CComPtr<IUnknown> sp = m_vec.GetAt(nConnectionIndex);
			pT->Unlock();
			IDispatch* pDispatch = reinterpret_cast<IDispatch*>(sp.p);
			if (pDispatch != NULL)
			{
				pvars[1] = __MIDL_0011;
				pvars[0] = bEnabled;
				DISPPARAMS disp = { pvars, NULL, 2, 0 };
				pDispatch->Invoke(0x4, IID_NULL, LOCALE_USER_DEFAULT, DISPATCH_METHOD, &disp, NULL, NULL, NULL);
			}
		}
		delete[] pvars;
	
	}
	VOID Fire_Resume(VARIANT_BOOL bEnabled)
	{
		T* pT = static_cast<T*>(this);
		int nConnectionIndex;
		CComVariant* pvars = new CComVariant[1];
		int nConnections = m_vec.GetSize();
		
		for (nConnectionIndex = 0; nConnectionIndex < nConnections; nConnectionIndex++)
		{
			pT->Lock();
			CComPtr<IUnknown> sp = m_vec.GetAt(nConnectionIndex);
			pT->Unlock();
			IDispatch* pDispatch = reinterpret_cast<IDispatch*>(sp.p);
			if (pDispatch != NULL)
			{
				pvars[0] = bEnabled;
				DISPPARAMS disp = { pvars, NULL, 1, 0 };
				pDispatch->Invoke(0x5, IID_NULL, LOCALE_USER_DEFAULT, DISPATCH_METHOD, &disp, NULL, NULL, NULL);
			}
		}
		delete[] pvars;
	
	}
	VOID Fire_SelectOrActivatButton(VARIANT_BOOL bEnabled)
	{
		T* pT = static_cast<T*>(this);
		int nConnectionIndex;
		CComVariant* pvars = new CComVariant[1];
		int nConnections = m_vec.GetSize();
		
		for (nConnectionIndex = 0; nConnectionIndex < nConnections; nConnectionIndex++)
		{
			pT->Lock();
			CComPtr<IUnknown> sp = m_vec.GetAt(nConnectionIndex);
			pT->Unlock();
			IDispatch* pDispatch = reinterpret_cast<IDispatch*>(sp.p);
			if (pDispatch != NULL)
			{
				pvars[0] = bEnabled;
				DISPPARAMS disp = { pvars, NULL, 1, 0 };
				pDispatch->Invoke(0x6, IID_NULL, LOCALE_USER_DEFAULT, DISPATCH_METHOD, &disp, NULL, NULL, NULL);
			}
		}
		delete[] pvars;
	
	}
	VOID Fire_StillOff(VARIANT_BOOL bEnabled)
	{
		T* pT = static_cast<T*>(this);
		int nConnectionIndex;
		CComVariant* pvars = new CComVariant[1];
		int nConnections = m_vec.GetSize();
		
		for (nConnectionIndex = 0; nConnectionIndex < nConnections; nConnectionIndex++)
		{
			pT->Lock();
			CComPtr<IUnknown> sp = m_vec.GetAt(nConnectionIndex);
			pT->Unlock();
			IDispatch* pDispatch = reinterpret_cast<IDispatch*>(sp.p);
			if (pDispatch != NULL)
			{
				pvars[0] = bEnabled;
				DISPPARAMS disp = { pvars, NULL, 1, 0 };
				pDispatch->Invoke(0x7, IID_NULL, LOCALE_USER_DEFAULT, DISPATCH_METHOD, &disp, NULL, NULL, NULL);
			}
		}
		delete[] pvars;
	
	}
	VOID Fire_PauseOn(VARIANT_BOOL bEnabled)
	{
		T* pT = static_cast<T*>(this);
		int nConnectionIndex;
		CComVariant* pvars = new CComVariant[1];
		int nConnections = m_vec.GetSize();
		
		for (nConnectionIndex = 0; nConnectionIndex < nConnections; nConnectionIndex++)
		{
			pT->Lock();
			CComPtr<IUnknown> sp = m_vec.GetAt(nConnectionIndex);
			pT->Unlock();
			IDispatch* pDispatch = reinterpret_cast<IDispatch*>(sp.p);
			if (pDispatch != NULL)
			{
				pvars[0] = bEnabled;
				DISPPARAMS disp = { pvars, NULL, 1, 0 };
				pDispatch->Invoke(0x8, IID_NULL, LOCALE_USER_DEFAULT, DISPATCH_METHOD, &disp, NULL, NULL, NULL);
			}
		}
		delete[] pvars;
	
	}
	VOID Fire_ChangeCurrentAudioStream(VARIANT_BOOL bEnabled)
	{
		T* pT = static_cast<T*>(this);
		int nConnectionIndex;
		CComVariant* pvars = new CComVariant[1];
		int nConnections = m_vec.GetSize();
		
		for (nConnectionIndex = 0; nConnectionIndex < nConnections; nConnectionIndex++)
		{
			pT->Lock();
			CComPtr<IUnknown> sp = m_vec.GetAt(nConnectionIndex);
			pT->Unlock();
			IDispatch* pDispatch = reinterpret_cast<IDispatch*>(sp.p);
			if (pDispatch != NULL)
			{
				pvars[0] = bEnabled;
				DISPPARAMS disp = { pvars, NULL, 1, 0 };
				pDispatch->Invoke(0x9, IID_NULL, LOCALE_USER_DEFAULT, DISPATCH_METHOD, &disp, NULL, NULL, NULL);
			}
		}
		delete[] pvars;
	
	}
	VOID Fire_ChangeCurrentSubpictureStream(VARIANT_BOOL bEnabled)
	{
		T* pT = static_cast<T*>(this);
		int nConnectionIndex;
		CComVariant* pvars = new CComVariant[1];
		int nConnections = m_vec.GetSize();
		
		for (nConnectionIndex = 0; nConnectionIndex < nConnections; nConnectionIndex++)
		{
			pT->Lock();
			CComPtr<IUnknown> sp = m_vec.GetAt(nConnectionIndex);
			pT->Unlock();
			IDispatch* pDispatch = reinterpret_cast<IDispatch*>(sp.p);
			if (pDispatch != NULL)
			{
				pvars[0] = bEnabled;
				DISPPARAMS disp = { pvars, NULL, 1, 0 };
				pDispatch->Invoke(0xa, IID_NULL, LOCALE_USER_DEFAULT, DISPATCH_METHOD, &disp, NULL, NULL, NULL);
			}
		}
		delete[] pvars;
	
	}
	VOID Fire_ChangeCurrentAngle(VARIANT_BOOL bEnabled)
	{
		T* pT = static_cast<T*>(this);
		int nConnectionIndex;
		CComVariant* pvars = new CComVariant[1];
		int nConnections = m_vec.GetSize();
		
		for (nConnectionIndex = 0; nConnectionIndex < nConnections; nConnectionIndex++)
		{
			pT->Lock();
			CComPtr<IUnknown> sp = m_vec.GetAt(nConnectionIndex);
			pT->Unlock();
			IDispatch* pDispatch = reinterpret_cast<IDispatch*>(sp.p);
			if (pDispatch != NULL)
			{
				pvars[0] = bEnabled;
				DISPPARAMS disp = { pvars, NULL, 1, 0 };
				pDispatch->Invoke(0xb, IID_NULL, LOCALE_USER_DEFAULT, DISPATCH_METHOD, &disp, NULL, NULL, NULL);
			}
		}
		delete[] pvars;
	
	}
	VOID Fire_PlayAtTimeInTitle(VARIANT_BOOL bEnabled)
	{
		T* pT = static_cast<T*>(this);
		int nConnectionIndex;
		CComVariant* pvars = new CComVariant[1];
		int nConnections = m_vec.GetSize();
		
		for (nConnectionIndex = 0; nConnectionIndex < nConnections; nConnectionIndex++)
		{
			pT->Lock();
			CComPtr<IUnknown> sp = m_vec.GetAt(nConnectionIndex);
			pT->Unlock();
			IDispatch* pDispatch = reinterpret_cast<IDispatch*>(sp.p);
			if (pDispatch != NULL)
			{
				pvars[0] = bEnabled;
				DISPPARAMS disp = { pvars, NULL, 1, 0 };
				pDispatch->Invoke(0xc, IID_NULL, LOCALE_USER_DEFAULT, DISPATCH_METHOD, &disp, NULL, NULL, NULL);
			}
		}
		delete[] pvars;
	
	}
	VOID Fire_PlayAtTime(VARIANT_BOOL bEnabled)
	{
		T* pT = static_cast<T*>(this);
		int nConnectionIndex;
		CComVariant* pvars = new CComVariant[1];
		int nConnections = m_vec.GetSize();
		
		for (nConnectionIndex = 0; nConnectionIndex < nConnections; nConnectionIndex++)
		{
			pT->Lock();
			CComPtr<IUnknown> sp = m_vec.GetAt(nConnectionIndex);
			pT->Unlock();
			IDispatch* pDispatch = reinterpret_cast<IDispatch*>(sp.p);
			if (pDispatch != NULL)
			{
				pvars[0] = bEnabled;
				DISPPARAMS disp = { pvars, NULL, 1, 0 };
				pDispatch->Invoke(0xd, IID_NULL, LOCALE_USER_DEFAULT, DISPATCH_METHOD, &disp, NULL, NULL, NULL);
			}
		}
		delete[] pvars;
	
	}
	VOID Fire_PlayChapterInTitle(VARIANT_BOOL bEnabled)
	{
		T* pT = static_cast<T*>(this);
		int nConnectionIndex;
		CComVariant* pvars = new CComVariant[1];
		int nConnections = m_vec.GetSize();
		
		for (nConnectionIndex = 0; nConnectionIndex < nConnections; nConnectionIndex++)
		{
			pT->Lock();
			CComPtr<IUnknown> sp = m_vec.GetAt(nConnectionIndex);
			pT->Unlock();
			IDispatch* pDispatch = reinterpret_cast<IDispatch*>(sp.p);
			if (pDispatch != NULL)
			{
				pvars[0] = bEnabled;
				DISPPARAMS disp = { pvars, NULL, 1, 0 };
				pDispatch->Invoke(0xe, IID_NULL, LOCALE_USER_DEFAULT, DISPATCH_METHOD, &disp, NULL, NULL, NULL);
			}
		}
		delete[] pvars;
	
	}
	VOID Fire_PlayChapter(VARIANT_BOOL bEnabled)
	{
		T* pT = static_cast<T*>(this);
		int nConnectionIndex;
		CComVariant* pvars = new CComVariant[1];
		int nConnections = m_vec.GetSize();
		
		for (nConnectionIndex = 0; nConnectionIndex < nConnections; nConnectionIndex++)
		{
			pT->Lock();
			CComPtr<IUnknown> sp = m_vec.GetAt(nConnectionIndex);
			pT->Unlock();
			IDispatch* pDispatch = reinterpret_cast<IDispatch*>(sp.p);
			if (pDispatch != NULL)
			{
				pvars[0] = bEnabled;
				DISPPARAMS disp = { pvars, NULL, 1, 0 };
				pDispatch->Invoke(0xf, IID_NULL, LOCALE_USER_DEFAULT, DISPATCH_METHOD, &disp, NULL, NULL, NULL);
			}
		}
		delete[] pvars;
	
	}
	VOID Fire_ReplayChapter(VARIANT_BOOL bEnabled)
	{
		T* pT = static_cast<T*>(this);
		int nConnectionIndex;
		CComVariant* pvars = new CComVariant[1];
		int nConnections = m_vec.GetSize();
		
		for (nConnectionIndex = 0; nConnectionIndex < nConnections; nConnectionIndex++)
		{
			pT->Lock();
			CComPtr<IUnknown> sp = m_vec.GetAt(nConnectionIndex);
			pT->Unlock();
			IDispatch* pDispatch = reinterpret_cast<IDispatch*>(sp.p);
			if (pDispatch != NULL)
			{
				pvars[0] = bEnabled;
				DISPPARAMS disp = { pvars, NULL, 1, 0 };
				pDispatch->Invoke(0x10, IID_NULL, LOCALE_USER_DEFAULT, DISPATCH_METHOD, &disp, NULL, NULL, NULL);
			}
		}
		delete[] pvars;
	
	}
	VOID Fire_PlayNextChapter(VARIANT_BOOL bEnabled)
	{
		T* pT = static_cast<T*>(this);
		int nConnectionIndex;
		CComVariant* pvars = new CComVariant[1];
		int nConnections = m_vec.GetSize();
		
		for (nConnectionIndex = 0; nConnectionIndex < nConnections; nConnectionIndex++)
		{
			pT->Lock();
			CComPtr<IUnknown> sp = m_vec.GetAt(nConnectionIndex);
			pT->Unlock();
			IDispatch* pDispatch = reinterpret_cast<IDispatch*>(sp.p);
			if (pDispatch != NULL)
			{
				pvars[0] = bEnabled;
				DISPPARAMS disp = { pvars, NULL, 1, 0 };
				pDispatch->Invoke(0x11, IID_NULL, LOCALE_USER_DEFAULT, DISPATCH_METHOD, &disp, NULL, NULL, NULL);
			}
		}
		delete[] pvars;
	
	}
	VOID Fire_Stop(VARIANT_BOOL bEnabled)
	{
		T* pT = static_cast<T*>(this);
		int nConnectionIndex;
		CComVariant* pvars = new CComVariant[1];
		int nConnections = m_vec.GetSize();
		
		for (nConnectionIndex = 0; nConnectionIndex < nConnections; nConnectionIndex++)
		{
			pT->Lock();
			CComPtr<IUnknown> sp = m_vec.GetAt(nConnectionIndex);
			pT->Unlock();
			IDispatch* pDispatch = reinterpret_cast<IDispatch*>(sp.p);
			if (pDispatch != NULL)
			{
				pvars[0] = bEnabled;
				DISPPARAMS disp = { pvars, NULL, 1, 0 };
				pDispatch->Invoke(0x12, IID_NULL, LOCALE_USER_DEFAULT, DISPATCH_METHOD, &disp, NULL, NULL, NULL);
			}
		}
		delete[] pvars;
	
	}
	VOID Fire_ReturnFromSubmenu(VARIANT_BOOL bEnabled)
	{
		T* pT = static_cast<T*>(this);
		int nConnectionIndex;
		CComVariant* pvars = new CComVariant[1];
		int nConnections = m_vec.GetSize();
		
		for (nConnectionIndex = 0; nConnectionIndex < nConnections; nConnectionIndex++)
		{
			pT->Lock();
			CComPtr<IUnknown> sp = m_vec.GetAt(nConnectionIndex);
			pT->Unlock();
			IDispatch* pDispatch = reinterpret_cast<IDispatch*>(sp.p);
			if (pDispatch != NULL)
			{
				pvars[0] = bEnabled;
				DISPPARAMS disp = { pvars, NULL, 1, 0 };
				pDispatch->Invoke(0x13, IID_NULL, LOCALE_USER_DEFAULT, DISPATCH_METHOD, &disp, NULL, NULL, NULL);
			}
		}
		delete[] pvars;
	
	}
	VOID Fire_PlayTitle(VARIANT_BOOL bEnabled)
	{
		T* pT = static_cast<T*>(this);
		int nConnectionIndex;
		CComVariant* pvars = new CComVariant[1];
		int nConnections = m_vec.GetSize();
		
		for (nConnectionIndex = 0; nConnectionIndex < nConnections; nConnectionIndex++)
		{
			pT->Lock();
			CComPtr<IUnknown> sp = m_vec.GetAt(nConnectionIndex);
			pT->Unlock();
			IDispatch* pDispatch = reinterpret_cast<IDispatch*>(sp.p);
			if (pDispatch != NULL)
			{
				pvars[0] = bEnabled;
				DISPPARAMS disp = { pvars, NULL, 1, 0 };
				pDispatch->Invoke(0x14, IID_NULL, LOCALE_USER_DEFAULT, DISPATCH_METHOD, &disp, NULL, NULL, NULL);
			}
		}
		delete[] pvars;
	
	}
	VOID Fire_PlayPrevChapter(VARIANT_BOOL bEnabled)
	{
		T* pT = static_cast<T*>(this);
		int nConnectionIndex;
		CComVariant* pvars = new CComVariant[1];
		int nConnections = m_vec.GetSize();
		
		for (nConnectionIndex = 0; nConnectionIndex < nConnections; nConnectionIndex++)
		{
			pT->Lock();
			CComPtr<IUnknown> sp = m_vec.GetAt(nConnectionIndex);
			pT->Unlock();
			IDispatch* pDispatch = reinterpret_cast<IDispatch*>(sp.p);
			if (pDispatch != NULL)
			{
				pvars[0] = bEnabled;
				DISPPARAMS disp = { pvars, NULL, 1, 0 };
				pDispatch->Invoke(0x15, IID_NULL, LOCALE_USER_DEFAULT, DISPATCH_METHOD, &disp, NULL, NULL, NULL);
			}
		}
		delete[] pvars;
	
	}
	VOID Fire_UpdateOverlay()
	{
		T* pT = static_cast<T*>(this);
		int nConnectionIndex;
		int nConnections = m_vec.GetSize();
		
		for (nConnectionIndex = 0; nConnectionIndex < nConnections; nConnectionIndex++)
		{
			pT->Lock();
			CComPtr<IUnknown> sp = m_vec.GetAt(nConnectionIndex);
			pT->Unlock();
			IDispatch* pDispatch = reinterpret_cast<IDispatch*>(sp.p);
			if (pDispatch != NULL)
			{
				DISPPARAMS disp = { NULL, NULL, 0, 0 };
				pDispatch->Invoke(0x16, IID_NULL, LOCALE_USER_DEFAULT, DISPATCH_METHOD, &disp, NULL, NULL, NULL);
			}
		}
	
	}
	VOID Fire_ReadyStateChange(LONG ReadyState)
	{
		T* pT = static_cast<T*>(this);
		int nConnectionIndex;
		CComVariant* pvars = new CComVariant[1];
		int nConnections = m_vec.GetSize();
		
		for (nConnectionIndex = 0; nConnectionIndex < nConnections; nConnectionIndex++)
		{
			pT->Lock();
			CComPtr<IUnknown> sp = m_vec.GetAt(nConnectionIndex);
			pT->Unlock();
			IDispatch* pDispatch = reinterpret_cast<IDispatch*>(sp.p);
			if (pDispatch != NULL)
			{
				pvars[0] = ReadyState;
				DISPPARAMS disp = { pvars, NULL, 1, 0 };
				pDispatch->Invoke(DISPID_READYSTATECHANGE, IID_NULL, LOCALE_USER_DEFAULT, DISPATCH_METHOD, &disp, NULL, NULL, NULL);
			}
		}
		delete[] pvars;
	
	}
};
#endif
=== C:/Users/treeman/Desktop/windows nt source code\Source\Win2K3\NT\multimedia\dshow\mfvideo\mswebdvd\savejpeg.cpp ===
#include <stdio.h>
#include <windows.h>
#include "capture.h"

HRESULT WriteBitmapDataToJPEGFile(char * filename, CaptureBitmapData *bm)
{
    // Function needs to be re-written to use gdi or gdi+ methods
    return E_FAIL;
}
=== C:/Users/treeman/Desktop/windows nt source code\Source\Win2K3\NT\multimedia\dshow\mfvideo\mswebdvd\mswebdvd.cpp ===
// Copyright (c) 1999  Microsoft Corporation.  All Rights Reserved.
// MSWebDVD.cpp : Implementation of DLL Exports.


// Note: Proxy/Stub Information
//      To build a separate proxy/stub DLL, 
//      run nmake -f MSWebDVDps.mk in the project directory.

#include "stdafx.h"
#include "resource.h"
#include <initguid.h>
#include "MSWebDVD.h"

#include "MSWebDVD_i.c"
#include "MSDVD.h"
#include "DVDRect.h"
#include "MSDVDAdm.h"
#include "ddrawobj.h"

CComModule _Module;

BEGIN_OBJECT_MAP(ObjectMap)
OBJECT_ENTRY(CLSID_MSWebDVD, CMSWebDVD)
OBJECT_ENTRY(CLSID_DVDRect, CDVDRect)
OBJECT_ENTRY(CLSID_MSDVDAdm, CMSDVDAdm)
OBJECT_ENTRY(CLSID_OverlayCallback, COverlayCallback)
END_OBJECT_MAP()

/////////////////////////////////////////////////////////////////////////////
// DLL Entry Point

extern "C"
BOOL WINAPI DllMain(HINSTANCE hInstance, DWORD dwReason, LPVOID /*lpReserved*/)
{
    if (dwReason == DLL_PROCESS_ATTACH)
    {
        _Module.Init(ObjectMap, hInstance, &LIBID_MSWEBDVDLib);
        DisableThreadLibraryCalls(hInstance);
    }
    else if (dwReason == DLL_PROCESS_DETACH)
        _Module.Term();
    return TRUE;    // ok
}

/////////////////////////////////////////////////////////////////////////////
// Used to determine whether the DLL can be unloaded by OLE

STDAPI DllCanUnloadNow(void)
{
    return (_Module.GetLockCount()==0) ? S_OK : S_FALSE;
}

/////////////////////////////////////////////////////////////////////////////
// Returns a class factory to create an object of the requested type

STDAPI DllGetClassObject(REFCLSID rclsid, REFIID riid, LPVOID* ppv)
{
    return _Module.GetClassObject(rclsid, riid, ppv);
}

/////////////////////////////////////////////////////////////////////////////
// DllRegisterServer - Adds entries to the system registry

STDAPI DllRegisterServer(void)
{
    // registers object, typelib and all interfaces in typelib
    return _Module.RegisterServer(TRUE);
}

/////////////////////////////////////////////////////////////////////////////
// DllUnregisterServer - Removes entries from the system registry

STDAPI DllUnregisterServer(void)
{
    return _Module.UnregisterServer(TRUE);
}
=== C:/Users/treeman/Desktop/windows nt source code\Source\Win2K3\NT\multimedia\dshow\mfvideo\mswebdvd\savebmp.cpp ===
/*************************************************************************/
/* Copyright (C) 2000 Microsoft Corporation                              */
/* File: savebmp.cpp                                                     */
/* Description: Save a CaptureBitmapData to BMP file format.             */
/* Note: This is not a general BMP encode function.                      */
/*       Special assumptions made about bitmap format:                   */
/*       RGB (3 bytes per pixel without colormap)                        */
/*                                                                       */
/* Author: Phillip Lu                                                    */
/*************************************************************************/

#include "stdafx.h"
#include <stdio.h>
#include "capture.h"


HRESULT WriteBitmapDataToBMPFile(char *filename, CaptureBitmapData *bmpdata)
{
    BITMAPFILEHEADER bfh;
    BITMAPINFOHEADER bmih;
    UINT numColors = 0; // Number of colors in bmiColors
    FILE *outfile = NULL;
    HRESULT hr = S_OK;
    BYTE *bufline = NULL;
    int bitmapStride;
    int nBytesWritten;

    // Setup BITMAPINFOHEADER

    ZeroMemory(&bmih, sizeof(bmih));
    bmih.biSize   = sizeof(bmih);
    bmih.biWidth  = bmpdata->Width;
    bmih.biHeight = bmpdata->Height;
    bmih.biPlanes = 1;
    bmih.biCompression = BI_RGB;
    bmih.biBitCount = 24;
     
    // Compute the bitmap stride

    bitmapStride = (bmpdata->Width * bmih.biBitCount + 7) / 8;
    bitmapStride = (bitmapStride + 3) & (~3);
    

    // Now fill in the BITMAPFILEHEADER

    bfh.bfType = 0x4d42;
    bfh.bfReserved1 = 0;
    bfh.bfReserved2 = 0;
    bfh.bfOffBits = sizeof(bfh) + sizeof(bmih) + numColors * sizeof(RGBQUAD);
    bfh.bfSize = bfh.bfOffBits + bitmapStride * bmpdata->Height;

    // allocate a buffer to hold one line of bitmap data

    bufline = new BYTE[bitmapStride];
    if (NULL == bufline)
    {
        hr = E_OUTOFMEMORY;
        return hr;
    }

    ZeroMemory(bufline, bitmapStride);

    if ((outfile = fopen(filename, "wb")) == NULL) 
    {
        delete[] bufline;
        hr = E_FAIL;
        return hr;
    }

    // Write the BITMAPFILEHEADER

    fwrite((void *)&bfh, sizeof(bfh), 1, outfile);

    // Write the BITMAPINFOHEADER

    fwrite((void *)&bmih, sizeof(bmih), 1, outfile);

    // Write bitmap data

    for (int iLine = bmpdata->Height-1; iLine >= 0; iLine--)
    {
        BYTE *bmpSrc = bmpdata->Scan0 + iLine*bmpdata->Stride;
        BYTE *bmpDst = bufline;

        for (int iPixel=0; iPixel<bmpdata->Width; iPixel++)
        {
            // in BMP file a pixel is in BGR order, so we have reverse it
            bmpDst[2] = *bmpSrc++;
            bmpDst[1] = *bmpSrc++;
            bmpDst[0] = *bmpSrc++;
            bmpDst += 3;
        }

        fwrite(bufline, bitmapStride, 1, outfile);
    }

    if (bufline != NULL)
    {
        delete[] bufline;
    }

    if (outfile != NULL)
    {
        fclose(outfile);
    }

    return hr;
}
=== C:/Users/treeman/Desktop/windows nt source code\Source\Win2K3\NT\multimedia\dshow\mfvideo\mswebdvd\resource.h ===
//{{NO_DEPENDENCIES}}
// Microsoft Developer Studio generated include file.
// Used by MSWebDVD.rc
//
#define IDS_PROJNAME                    100
#define IDB_MSWEBDVD                    101
#define IDS_ABOUT                       101
#define IDR_MSWEBDVD                    102
#define IDS_WEBDVD_ABOUT                102
#define IDR_DVDRECT                     103
#define IDB_MSDVDADM                    104
#define IDR_MSDVDADM                    105
#define IDR_OVERLAYCALLBACK             106
#define IDD_CAPSAVE                     200
#define IDS_EDVD2INT                    202
#define IDS_INI_RATE                    203
#define IDS_INI_RATE_G                  204
#define IDS_INI_RATE_PG                 205
#define IDS_INI_RATE_PG13               206
#define IDS_INI_RATE_R                  207
#define IDS_INI_RATE_NC17               208
#define IDS_INI_RATE_ADULT              209
#define IDS_INI_ADMINISTRATOR           210
#define IDS_INI_PASSWORD                211
#define IDS_INI_DISABLE_PARENT          212
#define IDS_INI_COUNTRY                 213
#define IDS_INI_DEFAULT_CFG             214
#define IDS_INI_DISABLE_SCRNSVR         215
#define IDS_REGION_CHANGE_FAIL          216
#define IDS_FORMAT_NOT_SUPPORTED        217
#define IDS_INI_DEFAULT_AUDIO           218
#define IDS_INI_DEFAULT_SP              219
#define IDS_INI_DEFAULT_MENU            220
#define IDS_INI_BOOKMARK                221
#define IDS_INI_ENABLE_ONSTOP           222
#define IDS_INI_ENABLE_ONCLOSE          223
#define IDS_E_NO_DVD_VOLUME             224
#define IDS_SAVE_FILE                   225
#define IDS_AUDIOTRACK                  226
#define IDS_AUDIO_VISUALLY_IMPAIRED     227
#define IDS_AUDIO_DIRC1                 228
#define IDS_AUDIO_DIRC2                 229
#define IDS_DOLBY                       230
#define IDS_MPEG1                       231
#define IDS_MPEG2                       232
#define IDS_LPCM                        233
#define IDS_DTS                         234
#define IDS_SDDS                        235
#define IDS_SUBPICTURETRACK             236
#define IDS_CAPTION_BIG                 237
#define IDS_CAPTION_CHILDREN            238
#define IDS_CLOSED_CAPTION              239
#define IDS_CLOSED_CAPTION_BIG          240
#define IDS_CLOSED_CAPTION_CHILDREN     241
#define IDS_CLOSED_CAPTION_FORCED       242
#define IDS_DIRS_COMMNETS               243
#define IDS_DIRS_COMMNETS_BIG           244
#define IDS_DIRS_COMMNETS_CHILDREN      245
#define IDS_MOVE_TO_OTHER_MON           246
#define IDS_E_REGION_CHANGE_NOT_COMPLETED 247
#define IDS_E_NO_SOUND_STREAM           248
#define IDS_WARNING                     249
#define IDS_E_NO_VIDEO_STREAM           250
#define IDS_E_NO_OVERLAY                251
#define IDS_E_NO_USABLE_OVERLAY         252
#define IDS_E_NO_DECODER                253
#define IDS_E_NO_CAPTURE_SUPPORT        254
#define IDS_E_NO_SUBPICT_STREAM         255
#define IDI_ICON1                       301
#ifndef IDC_HAND
#define IDC_HAND                        302
#endif
#define IDC_ZOOMIN                      303

#define    IDS_INI_LANGFIRST 1000
#define    IDS_INI_LANG1   1+IDS_INI_LANGFIRST
#define    IDS_INI_LANG2   2+IDS_INI_LANGFIRST
#define    IDS_INI_LANG3   3+IDS_INI_LANGFIRST
#define    IDS_INI_LANG4   4+IDS_INI_LANGFIRST
#define    IDS_INI_LANG5   5+IDS_INI_LANGFIRST
#define    IDS_INI_LANG6   6+IDS_INI_LANGFIRST
#define    IDS_INI_LANG7   7+IDS_INI_LANGFIRST
#define    IDS_INI_LANG8   8+IDS_INI_LANGFIRST
#define    IDS_INI_LANG9    9+IDS_INI_LANGFIRST
#define    IDS_INI_LANG10   10+IDS_INI_LANGFIRST
#define    IDS_INI_LANG11   11+IDS_INI_LANGFIRST
#define    IDS_INI_LANG12   12+IDS_INI_LANGFIRST
#define    IDS_INI_LANG13   13+IDS_INI_LANGFIRST
#define    IDS_INI_LANG14   14+IDS_INI_LANGFIRST
#define    IDS_INI_LANG15   15+IDS_INI_LANGFIRST
#define    IDS_INI_LANG16   16+IDS_INI_LANGFIRST
#define    IDS_INI_LANG17   17+IDS_INI_LANGFIRST
#define    IDS_INI_LANG18   18+IDS_INI_LANGFIRST
#define    IDS_INI_LANG19   19+IDS_INI_LANGFIRST
#define    IDS_INI_LANG20   20+IDS_INI_LANGFIRST
#define    IDS_INI_LANG21   21+IDS_INI_LANGFIRST
#define    IDS_INI_LANG22   22+IDS_INI_LANGFIRST
#define    IDS_INI_LANG23   23+IDS_INI_LANGFIRST
#define    IDS_INI_LANG24   24+IDS_INI_LANGFIRST
#define    IDS_INI_LANG25   25+IDS_INI_LANGFIRST
#define    IDS_INI_LANG26   26+IDS_INI_LANGFIRST
#define    IDS_INI_LANG27   27+IDS_INI_LANGFIRST
#define    IDS_INI_LANG28   28+IDS_INI_LANGFIRST
#define    IDS_INI_LANG29   29+IDS_INI_LANGFIRST
#define    IDS_INI_LANG30   30+IDS_INI_LANGFIRST
#define    IDS_INI_LANG31   31+IDS_INI_LANGFIRST
#define    IDS_INI_LANG32   32+IDS_INI_LANGFIRST
#define    IDS_INI_LANG33   33+IDS_INI_LANGFIRST
#define    IDS_INI_LANG34   34+IDS_INI_LANGFIRST
#define    IDS_INI_LANG35   35+IDS_INI_LANGFIRST
#define    IDS_INI_LANG36   36+IDS_INI_LANGFIRST
#define    IDS_INI_LANG37   37+IDS_INI_LANGFIRST
#define    IDS_INI_LANG38   38+IDS_INI_LANGFIRST
#define    IDS_INI_LANG39   39+IDS_INI_LANGFIRST
#define    IDS_INI_LANG40   40+IDS_INI_LANGFIRST
#define    IDS_INI_LANG41   41+IDS_INI_LANGFIRST
#define    IDS_INI_LANG42   42+IDS_INI_LANGFIRST
#define    IDS_INI_LANG43   43+IDS_INI_LANGFIRST
#define    IDS_INI_LANG44   44+IDS_INI_LANGFIRST

// Next default values for new objects
// 
#ifdef APSTUDIO_INVOKED
#ifndef APSTUDIO_READONLY_SYMBOLS
#define _APS_NEXT_RESOURCE_VALUE        304
#define _APS_NEXT_COMMAND_VALUE         32768
#define _APS_NEXT_CONTROL_VALUE         201
#define _APS_NEXT_SYMED_VALUE           107
#endif
#endif
=== C:/Users/treeman/Desktop/windows nt source code\Source\Win2K3\NT\multimedia\dshow\mfvideo\mswebdvd\stdafx.h ===
/*************************************************************************/
/* Copyright (C) 1999 Microsoft Corporation                              */
/* File: stdafx.h                                                        */
/* Description: include file for standard system include files,          */
/*      or project specific include files that are used frequently,      */
/*      but are changed infrequently                                     */
/* Author: David Janecek                                                 */
/*************************************************************************/
#if !defined(AFX_STDAFX_H__38EE5CE4_4B62_11D3_854F_00A0C9C898E7__INCLUDED_)
#define AFX_STDAFX_H__38EE5CE4_4B62_11D3_854F_00A0C9C898E7__INCLUDED_

#if _MSC_VER > 1000
#pragma once
#endif // _MSC_VER > 1000

#ifndef STRICT
#define STRICT
#ifndef _WIN32_WINNT
#define _WIN32_WINNT 0x0400
#endif
#endif
#define _ATL_APARTMENT_THREADED

#include <atlbase.h>
//You may derive a class from CComModule and use it if you want to override
//something, but do not change the name of _Module
extern CComModule _Module;
#include <atlcom.h>
#include <atlctl.h>
#include <strsafe.h>
#include "ObjectWithSiteImplSec.h"

//{{AFX_INSERT_LOCATION}}
// Microsoft Visual C++ will insert additional declarations immediately before the previous line.

#endif // !defined(AFX_STDAFX_H__38EE5CE4_4B62_11D3_854F_00A0C9C898E7__INCLUDED)
=== C:/Users/treeman/Desktop/windows nt source code\Source\Win2K3\NT\multimedia\dshow\mfvideo\mswebdvd\stdafx.cpp ===
// Copyright (c) 1999  Microsoft Corporation.  All Rights Reserved.
// stdafx.cpp : source file that includes just the standard includes
//  stdafx.pch will be the pre-compiled header
//  stdafx.obj will contain the pre-compiled type information

#include "stdafx.h"

#ifdef _ATL_STATIC_REGISTRY
#include <statreg.h>
#include <statreg.cpp>
#endif

#include <atlimpl.cpp>
=== C:/Users/treeman/Desktop/windows nt source code\Source\Win2K3\NT\multimedia\dshow\setup\src\setup20\runtime\actmovie\resource.h ===
#define IDS_OCXDESCRIPTION              1
#define IDS_FTAPPLET                    2
#define IDS_ACCESSORIES                 3
#define IDS_MULTIMEDIA                  4
#define IDS_EXTINFO                     6
#define IDS_PROGRAM                     7
#define IDS_CLSID                       8
#define IDS_CONTENTTYPE                 9
#define IDS_DEFAULTICON                 10
#define IDS_EXTENSION_MTYPE_BAK         11
#define IDS_EXTENSION_MIME              12
#define IDS_EXTENSION_MIME_BAK          13
#define IDS_MEDIATYPE_DESC              14
#define IDS_MEDIATYPE_DESC_BAK          15
#define IDS_MEDIATYPE_ICON              16
#define IDS_MEDIATYPE_ICON_BAK          17
#define IDS_MEDIATYPE_MTYPE             18
#define IDS_MEDIATYPE_MTYPE_BAK         19
#define IDS_MEDIATYPE_OPEN_BAK          20
#define IDS_MEDIATYPE_PLAY_BAK          21
#define IDS_MEDIATYPE_VERB_BAK          22
#define IDS_MIMECLSID_BAK               23
#define IDS_MIME_CONTENTLIST            24
#define IDS_SETUP_CLSID                 25
#define IDS_SETUP_OCX                   26
#define IDS_SHELL_OPENCMD               27
#define IDS_SHELL_PLAYCMD               28
#define IDS_SETUP_RUNDLLNT              29
#define IDS_SETUP_RUNDLL95              30
#define IDS_SHELL                       31
#define IDS_SHELL_OPEN                  32
#define IDS_SHELL_PLAY                  33
#define IDS_SENSE_AM10                  34
#define IDS_OSR2PARTIAL                 35
#define IDS_OCXPARAMETERS               37
=== C:/Users/treeman/Desktop/windows nt source code\Source\Win2K3\NT\multimedia\dshow\mfvideo\mswebdvd\thunkproc.h ===
/*************************************************************************/
/* Copyright (C) 1999 Microsoft Corporation                              */
/* File: ThunkProc.h                                                     */
/* Description: In order to get rid of the thread. Which causes problems */
/* since we have to marshal we use this timer stuff from ATL.            */
/* The basic problem is that we would like to have a timer associated    */
/* with an object and this is a way to do so                             */
/* Author: David Janecek                                                 */
/*************************************************************************/

#ifndef __THUNKPROC_H
#define __THUNKPROC_H

/////////////////////////////////////////////////////////////////////////////
// TimerProc thunks

class CTimerProcThunk
{
public:
        _AtlCreateWndData cd;
        CStdCallThunk thunk;

        void Init(TIMERPROC proc, void* pThis)
        {
            thunk.Init((DWORD_PTR)proc, pThis);
        }
};

template <class T>
class ATL_NO_VTABLE CMSDVDTimer {
private:
    CTimerProcThunk   m_TimerThunk;
    HWND            m_hwnd;

/*************************************************************************/
/* Function: FakeTimerProc                                               */
/*************************************************************************/
static void CALLBACK FakeTimerProc(HWND hwnd, UINT uMsg, UINT_PTR idEvent, DWORD dwTime){

    CMSDVDTimer* pThis = (CMSDVDTimer*)hwnd;
    pThis->RealTimerProc(pThis->m_hwnd, uMsg, idEvent, dwTime);
}/* end of function FakeTimerProc */

/*************************************************************************/
/* Function: RealTimerProc                                               */
/*************************************************************************/
void RealTimerProc(HWND hwnd, UINT uMsg, UINT_PTR idEvent, DWORD dwTime){

    T* pT = static_cast<T*>(this);

    if(NULL == pT){

        return;
    }/* end of if statement */

    pT->TimerProc();
}/* end of function RealTimerProc */

public:
/*************************************************************************/
/* Function: MyTimerClass                                                */
/*************************************************************************/
CMSDVDTimer(HWND hwnd = (HWND)NULL){

    m_hwnd = hwnd;
    m_TimerThunk.Init(FakeTimerProc, this);
}/* end of function MyTimerClass */

/*************************************************************************/
/* Function: GetTimerProc                                                */
/*************************************************************************/
TIMERPROC GetTimerProc() {

    return (TIMERPROC)(m_TimerThunk.thunk.pThunk);
}/* end of function GetTimerProc */

};

#endif // __THUNKPROC_H
=== C:/Users/treeman/Desktop/windows nt source code\Source\Win2K3\NT\multimedia\dshow\mfvideo\mswebdvd\thunkproc.cpp ===
/*************************************************************************/
/* Copyright (C) 1999 Microsoft Corporation                              */
/* File: ThunkProc.cpp                                                   */
/* Description: Implementation of timer procedure that checks if the     */
/* window has been resized.                                              */
/* Author: David Janecek                                                 */
/*************************************************************************/
#include "stdafx.h"
#include "msdvd.h"

/*************************************************************************/
/* Function: TimerProc                                                   */
/* Description: gets called every each time to figure out if we the      */
/* parent window has been moved
/*************************************************************************/
HRESULT CMSWebDVD::TimerProc(){
    
    HRESULT hr = S_OK;

    hr = ProcessEvents();

    if(FAILED(hr)){

        return(hr);
    }/* end of if statement */

    HWND hwndParent = NULL;
    hr = GetMostOuterWindow(&hwndParent);

    if(FAILED(hr)){
        
        return(hr);
    }/* end of if statement */
    
    RECT rcTmp;
    ::GetWindowRect(hwndParent, &rcTmp);        
        
    if(rcTmp.left != m_rcOldPos.left || rcTmp.top != m_rcOldPos.top || rcTmp.right != m_rcOldPos.right ||
        rcTmp.bottom != m_rcOldPos.bottom){

        hr = OnResize();  // do the initial resize

        m_rcOldPos = rcTmp; // set the value so we can remeber it
        return(hr);
    }/* end of if statement */
    
    hr = S_FALSE;
    return(hr);
}/* end of function TimerProc  */

/*************************************************************************/
/* Function: GetMostOuterWindow                                          */
/* Description: Gets the window that really contains the MSWEBDVD and is */
/* the most outer parent window.                                         */
/*************************************************************************/
HRESULT CMSWebDVD::GetMostOuterWindow(HWND* phwndParent){
   
    HRESULT hr = S_OK;

    if(NULL != m_hWndOuter){

        *phwndParent =  m_hWndOuter;
        return(S_OK);
    }/* end of if statement */

    HWND hwnd;
    hr = GetParentHWND(&hwnd);

    if(FAILED(hr)){

        return(hr);
    }/* end of if statement */

    HWND hwndParent = hwnd;

    // Get really the out most parent so we can see if the window got moved    
    for ( ;; ) {
 
        HWND hwndT = ::GetParent(hwndParent);
        if (hwndT == (HWND)NULL) break;
           hwndParent = hwndT;
    }/* end of for loop */

    *phwndParent = m_hWndOuter = hwndParent;

    return(S_OK);
}/* end of function GetMostOuterWindow */

/*************************************************************************/
/* End of file: ThunkProc.cpp                                            */
/*************************************************************************/
=== C:/Users/treeman/Desktop/windows nt source code\Source\Win2K3\NT\multimedia\dshow\setup\src\setup20\runtime\actmovie\actmovie.cpp ===
// ---------------------------------------------------------------------------------------------
// THIS CODE AND INFORMATION IS PROVIDED "AS IS" WITHOUT WARRANTY OF ANY KIND, EITHER EXPRESSED
// OR IMPLIED, INCLUDING BUT NOT LIMITED TO THE IMPLIED WARRANTIES OF MERCHANTABILITY AND/OR
// FITNESS FOR A PARTICULAR PURPOSE.
// Copyright (C) 1997  Microsoft Corporation.  All Rights Reserved.
// ---------------------------------------------------------------------------------------------

#include <windows.h>
//////////////////////////////////////////////////////////////////
WINAPI WinMain (HINSTANCE hInstance, HINSTANCE b, LPSTR c, int d)
//////////////////////////////////////////////////////////////////
{ // WinMain //

    // dummy executable to keep ActiveMovie 1.0 actmovie.exe from
    // being installed and popping up the "file associations wrong"
    // dialog every time a user logs in
    
    return 0;
} // WinMain //
=== C:/Users/treeman/Desktop/windows nt source code\Source\Win2K3\NT\multimedia\dshow\streams\ddstream\austrm.cpp ===
// Copyright (c) 1997 - 1998  Microsoft Corporation.  All Rights Reserved.
// austrm.cpp : Implementation of CAudioStream
#include "stdafx.h"
#include "project.h"
#include "austrm.h"

//  Helper
void SetWaveFormatEx(
    LPWAVEFORMATEX pFormat,
    int nChannels,
    int nBitsPerSample,
    int nSamplesPerSecond
)
{
    pFormat->wFormatTag = WAVE_FORMAT_PCM;
    pFormat->nChannels  = (WORD)nChannels;
    pFormat->nSamplesPerSec = (DWORD)nSamplesPerSecond;
    pFormat->nBlockAlign = (WORD)((nBitsPerSample * nChannels) / 8);
    pFormat->nAvgBytesPerSec = (DWORD)(nSamplesPerSecond * pFormat->nBlockAlign);
    pFormat->wBitsPerSample = (WORD)nBitsPerSample;
    pFormat->cbSize = 0;
}

HRESULT ConvertWAVEFORMATEXToMediaType(
    const WAVEFORMATEX *pFormat,
    AM_MEDIA_TYPE **ppmt
)
{
    AM_MEDIA_TYPE *pmt;
    pmt = (AM_MEDIA_TYPE *)CoTaskMemAlloc(sizeof(*pmt));
    if (pmt == NULL) {
        return E_OUTOFMEMORY;
    }
    _ASSERTE(pFormat->wFormatTag == WAVE_FORMAT_PCM);
    ZeroMemory(pmt, sizeof(*pmt));
    pmt->majortype = MEDIATYPE_Audio;
    pmt->formattype = FORMAT_WaveFormatEx;
    pmt->bFixedSizeSamples = TRUE;
    pmt->lSampleSize = pFormat->nBlockAlign;
    pmt->cbFormat = sizeof(*pFormat);
    pmt->pbFormat = (PBYTE)CoTaskMemAlloc(sizeof(*pFormat));
    if (pmt->pbFormat == NULL) {
        CoTaskMemFree(pmt);
        return E_OUTOFMEMORY;
    }
    CopyMemory(pmt->pbFormat, pFormat, sizeof(*pFormat));
    *ppmt = pmt;
    return S_OK;
}


/////////////////////////////////////////////////////////////////////////////
// CAudioStream

CAudioStream::CAudioStream() :
        m_fForceFormat(false)
{
    //  Set to mono 16bit PCM 11025Hz
    SetWaveFormatEx(&m_Format, 1, 16, 11025);
}

STDMETHODIMP
CAudioStream::ReceiveConnection(
    IPin * pConnector,
    const AM_MEDIA_TYPE *pmt
)
{
    AUTO_CRIT_LOCK;
    //
    //  This helper function in CStream checks basic parameters for the Pin such as
    //  the connecting pin's direction (we need to check this -- Sometimes the filter
    //  graph will try to connect us to ourselves!) and other errors like already being
    //  connected, etc.
    //
    HRESULT hr = CheckReceiveConnectionPin(pConnector);
    if (hr == NOERROR) {
        /*  Accept only the format we've been given.  If we
            haven't been given a format accept PCM only
        */
        if (pmt->majortype != MEDIATYPE_Audio ||
            pmt->formattype != FORMAT_WaveFormatEx ||
            pmt->cbFormat < sizeof(WAVEFORMATEX)) {
            hr = VFW_E_TYPE_NOT_ACCEPTED;
        } else {
            hr = InternalSetFormat((LPWAVEFORMATEX)pmt->pbFormat, true);
            if (SUCCEEDED(hr)) {
                CopyMediaType(&m_ConnectedMediaType, pmt);
                m_pConnectedPin = pConnector;
            }
        }
    }
    return hr;
}

STDMETHODIMP CAudioStream::SetSameFormat(IMediaStream *pStream, DWORD dwFlags)
{
    CComQIPtr<IAudioMediaStream, &IID_IAudioMediaStream> pSource(pStream);
    if (!pSource) {
        return MS_E_INCOMPATIBLE;
    }
    WAVEFORMATEX wfx;
    HRESULT hr = pSource->GetFormat(&wfx);
    if (SUCCEEDED(hr)) {
        hr = SetFormat(&wfx);
    }
    return hr;
}

STDMETHODIMP CAudioStream::AllocateSample(DWORD dwFlags, IStreamSample **ppNewSample)
{
    IAudioStreamSample *pSample = NULL;
    IAudioData *pAudioData;
    HRESULT hr = CoCreateInstance(CLSID_AMAudioData, NULL, CLSCTX_INPROC_SERVER,
                                  IID_IAudioData, (void **)&pAudioData);
    if (SUCCEEDED(hr)) {
        //  Pick a sensible buffer size - 1/10 second
        DWORD dwBufferSize = m_Format.nAvgBytesPerSec / 10 +
                             m_Format.nBlockAlign - 1;
        dwBufferSize -= dwBufferSize % m_Format.nBlockAlign;
        pAudioData->SetBuffer(dwBufferSize, NULL, 0);
        pAudioData->SetFormat(&m_Format);
        hr = CreateSample(pAudioData, 0, &pSample);
    }
    *ppNewSample = pSample;
    return hr;
}

STDMETHODIMP CAudioStream::CreateSharedSample(
    /* [in] */ IStreamSample *pExistingSample,
                DWORD dwFlags,
    /* [out] */ IStreamSample **ppNewSample
)
{
    AUTO_CRIT_LOCK;
    //  See if we can get the information we need from the existing
    //  sample
    IAudioStreamSample *pAudioSample;
    HRESULT hr = pExistingSample->QueryInterface(
                     IID_IAudioStreamSample,
                     (void **)&pAudioSample);
    if (FAILED(hr)) {
        return hr;
    }
    IAudioData *pAudioData;
    hr = pAudioSample->GetAudioData(&pAudioData);
    pAudioSample->Release();
    if (FAILED(hr)) {
        return hr;
    }
    IAudioStreamSample *pNewSample;
    hr = CreateSample(pAudioData, 0, &pNewSample);
    pAudioData->Release();
    if (FAILED(hr)) {
        return hr;
    }
    hr = pNewSample->QueryInterface(IID_IStreamSample, (void**)ppNewSample);
    pNewSample->Release();
    return hr;
}

STDMETHODIMP CAudioStream::SetFormat(const WAVEFORMATEX *pFormat)
{
    if (pFormat == NULL) {
        return E_POINTER;
    }
    AUTO_CRIT_LOCK;
    return InternalSetFormat(pFormat, false);
}
STDMETHODIMP CAudioStream::GetFormat(LPWAVEFORMATEX pFormat)
{
    if (pFormat == NULL) {
        return E_POINTER;
    }
    if (!m_pConnectedPin) {
        return MS_E_NOSTREAM;
    }

    *pFormat = m_Format;
    return S_OK;
}

STDMETHODIMP CAudioStream::CreateSample(
        /* [in] */ IAudioData *pAudioData,
        /* [in] */ DWORD dwFlags,
        /* [out] */ IAudioStreamSample **ppSample
)
{
    if (dwFlags != 0) {
        return E_INVALIDARG;
    }
    if (pAudioData == NULL || ppSample == NULL) {
        return E_POINTER;
    }
    AUTO_CRIT_LOCK;
    //  Check the format
    WAVEFORMATEX wfx;
    HRESULT hr = pAudioData->GetFormat(&wfx);
    if (FAILED(hr)) {
        return hr;
    }
    hr = CheckFormat(&wfx);
    if (FAILED(hr)) {
        return hr;
    }
    typedef CComObject<CAudioStreamSample> _AudioSample;
    _AudioSample *pSample = new _AudioSample;
    if (pSample == NULL) {
        return E_OUTOFMEMORY;
    }
    hr = pSample->Init(pAudioData);
    if (FAILED(hr)) {
        return hr;
    }
    pSample->InitSample(this, false);
    return pSample->GetControllingUnknown()->QueryInterface(
        IID_IAudioStreamSample, (void **)ppSample
    );
}

HRESULT CAudioStream::CheckFormat(const WAVEFORMATEX *lpFormat, bool bForceFormat)
{
    if (lpFormat->wFormatTag != WAVE_FORMAT_PCM ||
        lpFormat->nBlockAlign == 0) {
        return E_INVALIDARG;
    }
    if ((m_pConnectedPin || bForceFormat) &&
        0 != memcmp(lpFormat, &m_Format, sizeof(m_Format)))
    {
        //  Try reconnection!
        return E_INVALIDARG;
    }
    return S_OK;
}
HRESULT CAudioStream::InternalSetFormat(const WAVEFORMATEX *lpFormat, bool bFromPin)
{
    HRESULT hr = CheckFormat(lpFormat, m_fForceFormat);
    if (FAILED(hr)) {
        return hr;
    }
    m_Format = *lpFormat;
    m_lBytesPerSecond = m_Format.nAvgBytesPerSec;
    if(!bFromPin) {
        m_fForceFormat = true;
    }
    return S_OK;
}


//
// Special CStream methods
//
HRESULT CAudioStream::GetMediaType(ULONG Index, AM_MEDIA_TYPE **ppMediaType)
{
    if (Index != 0) {
        return S_FALSE;
    }
    return ConvertWAVEFORMATEXToMediaType(&m_Format, ppMediaType);
}

//////////////////////////////////////////////////////////////////////
//  CAudioData
CAudioData::CAudioData() :
    m_cbSize(0),
    m_pbData(0),
    m_cbData(0),
    m_bWeAllocatedData(false)
{
    //  Set to mono 16bit PCM 11025Hz
    SetWaveFormatEx(&m_Format, 1, 16, 11025);
}

CAudioData::~CAudioData()
{
    if (m_bWeAllocatedData) {
        CoTaskMemFree(m_pbData);
    }
}


STDMETHODIMP CAudioStream::GetProperties(ALLOCATOR_PROPERTIES* pProps)
{
    AUTO_CRIT_LOCK;

    //  NB TAPI relies on this number as a max for now when
    //  we're connected to the AVI Mux which uses this size to
    //  create its own samples
    pProps->cbBuffer = CAudioStream::GetChopSize();

    //  Default to 5 buffers (half a second at our default buffer size)
    pProps->cBuffers = m_lRequestedBufferCount ? m_lRequestedBufferCount : 5;
    pProps->cbAlign = 1;
    pProps->cbPrefix = 0;
    return NOERROR;
}

STDMETHODIMP CAudioStream::SetProperties(ALLOCATOR_PROPERTIES* pRequest, ALLOCATOR_PROPERTIES* pActual)
{
    HRESULT hr;

    AUTO_CRIT_LOCK;
    ZeroMemory(pActual, sizeof(*pActual));
    if (pRequest->cbAlign == 0) {
    	hr = VFW_E_BADALIGN;
    } else {
        if (m_bCommitted == TRUE) {
    	    hr = VFW_E_ALREADY_COMMITTED;
    	} else {
            m_lRequestedBufferCount = pRequest->cBuffers;
            hr = GetProperties(pActual);
    	}
    }
    return hr;
}
=== C:/Users/treeman/Desktop/windows nt source code\Source\Win2K3\NT\multimedia\dshow\streams\ddstream\austrm.h ===
// Copyright (c) 1997 - 1998  Microsoft Corporation.  All Rights Reserved.
// austrm.h : Declaration of the CAudioStream

/*
    Basic design
    ------------

    For simplification purposes we will always provide our own
    allocator buffer and copy into the application's buffer.  This
    will fix 2 problems:

    1.  Confusion caused by the filter no filling the allocator's
        buffers.

    2.  Problems when the application doesn't supply a big enough buffer.

    NOTES
    -----

    Continuous update might be a bit dumb to use for audio
*/

#ifndef __AUSTREAM_H_
#define __AUSTREAM_H_


/////////////////////////////////////////////////////////////////////////////
// CAudioStream
class ATL_NO_VTABLE CAudioStream :
	public CComCoClass<CAudioStream, &CLSID_AMAudioStream>,
        public CByteStream,
	public IAudioMediaStream
{
public:

        //
        // METHODS
        //
	CAudioStream();

        //
        //  IMediaStream
        //
        //
        // IMediaStream
        //
        // HACK HACK - the first 2 are duplicates but it won't link
        // without
        STDMETHODIMP GetMultiMediaStream(
            /* [out] */ IMultiMediaStream **ppMultiMediaStream)
        {
            return CStream::GetMultiMediaStream(ppMultiMediaStream);
        }

        STDMETHODIMP GetInformation(
            /* [optional][out] */ MSPID *pPurposeId,
            /* [optional][out] */ STREAM_TYPE *pType)
        {
            return CStream::GetInformation(pPurposeId, pType);
        }

        STDMETHODIMP SetState(
            /* [in] */ FILTER_STATE State
        )
        {
            return CByteStream::SetState(State);
        }

        STDMETHODIMP SetSameFormat(IMediaStream *pStream, DWORD dwFlags);

        STDMETHODIMP AllocateSample(
            /* [in]  */ DWORD dwFlags,
            /* [out] */ IStreamSample **ppSample
        );

        STDMETHODIMP CreateSharedSample(
            /* [in] */ IStreamSample *pExistingSample,
            /* [in] */ DWORD dwFlags,
            /* [out] */ IStreamSample **ppNewSample
        );

        STDMETHODIMP SendEndOfStream(DWORD dwFlags)
        {
            return CStream::SendEndOfStream(dwFlags);
        }
        //
        // IPin
        //
        STDMETHODIMP ReceiveConnection(IPin * pConnector, const AM_MEDIA_TYPE *pmt);

        //
        // IMemAllocator
        //
        STDMETHODIMP SetProperties(ALLOCATOR_PROPERTIES* pRequest, ALLOCATOR_PROPERTIES* pActual);
        STDMETHODIMP GetProperties(ALLOCATOR_PROPERTIES* pProps);

        //
        // IAudioMediaStream
        //
        STDMETHODIMP GetFormat(
            /* [optional][out] */ LPWAVEFORMATEX lpWaveFormatCurrent
        );

        STDMETHODIMP SetFormat(
            /* [in] */ const WAVEFORMATEX *lpWaveFormat
        );

        STDMETHODIMP CreateSample(
                /* [in] */ IAudioData *pAudioData,
                /* [in] */ DWORD dwFlags,
                /* [out] */ IAudioStreamSample **ppSample
        );



        //
        // Special CStream methods
        //
        HRESULT GetMediaType(ULONG Index, AM_MEDIA_TYPE **ppMediaType);

        LONG GetChopSize()
        {
#ifdef MY_CHOP_SIZE
            if (m_Direction == PINDIR_OUTPUT) {
                return MY_CHOP_SIZE;
            }
#endif
            return 65536;
        }

DECLARE_REGISTRY_RESOURCEID(IDR_AUDIOSTREAM)

protected:
        HRESULT InternalSetFormat(const WAVEFORMATEX *pFormat, bool bFromPin);
        HRESULT CheckFormat(const WAVEFORMATEX *pFormat, bool bForce=false);

BEGIN_COM_MAP(CAudioStream)
	COM_INTERFACE_ENTRY(IAudioMediaStream)
        COM_INTERFACE_ENTRY_CHAIN(CStream)
END_COM_MAP()

protected:
        /*  Format */
        WAVEFORMATEX    m_Format;
        bool            m_fForceFormat;
};


/////////////////////////////////////////////////////////////////////////////
// CAudioStreamSample
class ATL_NO_VTABLE CAudioStreamSample :
    public CByteStreamSample,
    public IAudioStreamSample
{
public:
        CAudioStreamSample() {}

//  DELEGATE TO BASE CLASS
        //
        //  IStreamSample
        //
        STDMETHODIMP GetMediaStream(
            /* [in] */ IMediaStream **ppMediaStream)
        {
            return CSample::GetMediaStream(ppMediaStream);
        }

        STDMETHODIMP GetSampleTimes(
            /* [optional][out] */ STREAM_TIME *pStartTime,
            /* [optional][out] */ STREAM_TIME *pEndTime,
            /* [optional][out] */ STREAM_TIME *pCurrentTime)
        {
            return CSample::GetSampleTimes(
                pStartTime,
                pEndTime,
                pCurrentTime
            );
        }

        STDMETHODIMP SetSampleTimes(
            /* [optional][in] */ const STREAM_TIME *pStartTime,
            /* [optional][in] */ const STREAM_TIME *pEndTime)
        {
            return CSample::SetSampleTimes(pStartTime, pEndTime);
        }

        STDMETHODIMP Update(
            /* [in] */           DWORD dwFlags,
            /* [optional][in] */ HANDLE hEvent,
            /* [optional][in] */ PAPCFUNC pfnAPC,
            /* [optional][in] */ DWORD_PTR dwAPCData)
        {
            return CByteStreamSample::Update(dwFlags, hEvent, pfnAPC, dwAPCData);
        }

        STDMETHODIMP CompletionStatus(
            /* [in] */ DWORD dwFlags,
            /* [optional][in] */ DWORD dwMilliseconds)
        {
            return CSample::CompletionStatus(dwFlags, dwMilliseconds);
        }

BEGIN_COM_MAP(CAudioStreamSample)
        COM_INTERFACE_ENTRY(IAudioStreamSample)
        COM_INTERFACE_ENTRY_CHAIN(CSample)
END_COM_MAP()

        //  IAudioStreamSample
        STDMETHODIMP GetAudioData(IAudioData **ppAudioData)
        {
            return m_pMemData->QueryInterface(IID_IAudioData, (void **)ppAudioData);
        }

        //  Set the pointer
        HRESULT SetSizeAndPointer(BYTE *pbData, LONG lActual, LONG lSize)
        {
            m_pbData = pbData;
            m_cbSize = (DWORD)lSize;
            m_cbData = (DWORD)lActual;
            return S_OK;
        }
};

//  Audio data object
class ATL_NO_VTABLE CAudioData :
    public CComObjectRootEx<CComMultiThreadModel>,
    public IAudioData,
    public CComCoClass<CAudioData, &CLSID_AMAudioData>
{
public:
    CAudioData();
    ~CAudioData();

DECLARE_REGISTRY_RESOURCEID(IDR_AUDIODATA)

BEGIN_COM_MAP(CAudioData)
    COM_INTERFACE_ENTRY(IAudioData)
END_COM_MAP()

    //
    //  IMemoryData
    //

    STDMETHODIMP SetBuffer(
        /* [in] */ DWORD cbSize,
        /* [in] */ BYTE * pbData,
        /* [in] */ DWORD dwFlags
    )
    {
        if (dwFlags != 0 || cbSize == 0) {
            return E_INVALIDARG;
        }
        //
        //  Free anything we allocated ourselves -- We allow multiple calls to this method
        //
        if (m_bWeAllocatedData) {
            CoTaskMemFree(m_pbData);
            m_bWeAllocatedData = false;
        }
        m_cbSize = cbSize;
        if (pbData) {
            m_pbData = pbData;
            return S_OK;
        } else {
            m_pbData = (BYTE *)CoTaskMemAlloc(cbSize);
            if (m_pbData) {
                m_bWeAllocatedData = true;
                return S_OK;
            }
            return E_OUTOFMEMORY;
        }
    }

    STDMETHODIMP GetInfo(
        /* [out] */ DWORD *pdwLength,
        /* [out] */ BYTE **ppbData,
        /* [out] */ DWORD *pcbActualData
    )
    {
        if (m_cbSize == 0) {
            return MS_E_NOTINIT;
        }
        if (pdwLength) {
            *pdwLength = m_cbSize;
        }
        if (ppbData) {
            *ppbData = m_pbData;
        }
        if (pcbActualData) {
            *pcbActualData = m_cbData;
        }
        return S_OK;
    }
    STDMETHODIMP SetActual(
        /* [in] */ DWORD cbDataValid
    )
    {
        if (cbDataValid > m_cbSize) {
            return E_INVALIDARG;
        }
        m_cbData = cbDataValid;
        return S_OK;
    }

    //
    // IAudioData
    //

    STDMETHODIMP GetFormat(
    	/* [out] [optional] */ WAVEFORMATEX *pWaveFormatCurrent
    )
    {
        if (pWaveFormatCurrent == NULL) {
            return E_POINTER;
        }
        *pWaveFormatCurrent = m_Format;
        return S_OK;
    }

    STDMETHODIMP SetFormat(
    	/* [in] */ const WAVEFORMATEX *lpWaveFormat
    )
    {
        if (lpWaveFormat == NULL) {
            return E_POINTER;
        }
        if (lpWaveFormat->wFormatTag != WAVE_FORMAT_PCM) {
            return E_INVALIDARG;
        }
        m_Format = *lpWaveFormat;
        return S_OK;
    }


protected:
    PBYTE        m_pbData;
    DWORD        m_cbSize;
    DWORD        m_cbData;
    WAVEFORMATEX m_Format;
    bool         m_bWeAllocatedData;
};

#endif // __AUSTREAM_H_
=== C:/Users/treeman/Desktop/windows nt source code\Source\Win2K3\NT\multimedia\dshow\streams\ddstream\bytestrm.cpp ===
// Copyright (c) 1997 - 1999  Microsoft Corporation.  All Rights Reserved.
// bytestrm.cpp : Implementation of CByteStream
#include "stdafx.h"
#include "project.h"

/////////////////////////////////////////////////////////////////////////////
// CByteStream

CByteStream::CByteStream() :
    m_cbData(0),
    m_lBytesPerSecond(0),
    m_bEOSPending(false)
{
}

STDMETHODIMP CByteStream::GetBuffer(
    IMediaSample **ppBuffer,
    REFERENCE_TIME * pStartTime,
    REFERENCE_TIME * pEndTime,
    DWORD dwFlags
)
{
    HRESULT hr;
    *ppBuffer = NULL;
    if (m_bStopIfNoSamples && m_cAllocated == 0) {
        return E_FAIL;
    }
    if (m_Direction == PINDIR_INPUT) {
        AtlTrace(_T("Should never get here!\n"));
        _ASSERTE(FALSE);
        hr = E_UNEXPECTED;
    } else {
        CSample *pSample;
        hr = AllocSampleFromPool(pStartTime, &pSample);
        if (hr == NOERROR) {
            pSample->m_pMediaSample->m_dwFlags = dwFlags;
            pSample->m_bReceived = false;
            pSample->m_bModified = true;
            *ppBuffer = (IMediaSample *)(pSample->m_pMediaSample);
            (*ppBuffer)->AddRef();
        }
    }
    return hr;
}

STDMETHODIMP CByteStream::BeginFlush()
{
    AUTO_CRIT_LOCK;
    m_bEOSPending = false;
    m_arSamples.RemoveAll();
    m_cbData = 0;
    m_TimeStamp.Reset();
    return CStream::BeginFlush();
}

STDMETHODIMP CByteStream::EndOfStream()
{
    HRESULT hr = S_OK;
    Lock();
    if (m_bFlushing || m_bEndOfStream || m_bEOSPending) {
        hr = E_FAIL;
    } else {
        m_bEOSPending = TRUE;
        CheckEndOfStream();
    }
    Unlock();
    return hr;
}

STDMETHODIMP CByteStream::GetAllocator(IMemAllocator ** ppAllocator)
{
    HRESULT hr;
    AUTO_CRIT_LOCK;
    if (m_Direction == PINDIR_OUTPUT) {
        hr = CStream::GetAllocator(ppAllocator);
    } else {
        if (m_pAllocator == NULL) {
            hr = CoCreateInstance(CLSID_MemoryAllocator,
                                          0,
                                          CLSCTX_INPROC_SERVER,
                                          IID_IMemAllocator,
                                          (void **)&m_pAllocator);
            if (FAILED(hr)) {
                goto Exit;
            }
        }
        m_pAllocator.p->AddRef();
        *ppAllocator = m_pAllocator;
        hr = NOERROR;
    }
Exit:
    return hr;
}

STDMETHODIMP CByteStream::Receive(IMediaSample *pSample)
{
    AUTO_CRIT_LOCK;

    if (m_bFlushing || m_bStopIfNoSamples && m_cAllocated == 0) {
        EndOfStream();
        return S_FALSE;
    }

    if(m_FilterState == State_Stopped) {
        return VFW_E_WRONG_STATE;
    }

    /*  Put it on the queue */
    if (!m_arSamples.Add(pSample)) {
        EndOfStream();
        return E_OUTOFMEMORY;
    }

    /*  Eat as much as we can, then return */
    FillSamples();
    return S_OK;
}

STDMETHODIMP CByteStream::SetState(
    /* [in] */ FILTER_STATE State
)
{
    HRESULT hr =  CStream::SetState(State);    // Must be called with the critical seciton unowned!

    Lock();
    if (State == State_Stopped) {
        m_bEOSPending = false;
        m_arSamples.RemoveAll();

        m_cbData = 0;
        m_TimeStamp.Reset();
    }
    Unlock();

    if (State == State_Stopped) {
        _ASSERTE(m_arSamples.Size() == 0);
    }

    return hr;
}


//  Fill any samples lying around
void CByteStream::FillSamples()
{
    while (m_arSamples.Size() != 0 && m_pFirstFree != NULL) {
        if (m_cbData == 0) {
            IMediaSample * const pSample = m_arSamples.Element(0);

            /*  At the start so initialize some stuff */
            pSample->GetPointer(&m_pbData);
            m_cbData = m_arSamples.Element(0)->GetActualDataLength();

            /*  See if there are any time stamps */
            REFERENCE_TIME rtStart, rtStop;
            if (SUCCEEDED(pSample->GetTime(&rtStart, &rtStop))) {
#if 0
                AtlTrace("TimeStamp current %d, new %d, length %d length(ms) %d, bytelen %d\n",
                         (long)(m_TimeStamp.TimeStamp(0, m_lBytesPerSecond) / 10000),
                         (long)(rtStart / 10000),
                         (long)((rtStop - rtStart) / 10000),
                         MulDiv(m_cbData, 1000, m_lBytesPerSecond),
                         m_cbData);
#endif
                m_TimeStamp.SetTime(rtStart);
            }
        }
        /*  Copy some data across */
        CByteStreamSample* const pStreamSample = (CByteStreamSample *)m_pFirstFree;

        /*  Do timestamps */
        if (pStreamSample->m_cbData == 0) {
            pStreamSample->m_pMediaSample->m_rtEndTime =
            pStreamSample->m_pMediaSample->m_rtStartTime =
                m_TimeStamp.TimeStamp(0, m_lBytesPerSecond);
        }
        /*  See how much we can copy */
        _ASSERTE(pStreamSample->m_cbData <= pStreamSample->m_cbSize);

        DWORD cbBytesToCopy = min(m_cbData,
                                  pStreamSample->m_cbSize -
                                  pStreamSample->m_cbData);
        CopyMemory(pStreamSample->m_pbData + pStreamSample->m_cbData,
                   m_pbData,
                   cbBytesToCopy);
        m_cbData -= cbBytesToCopy;
        m_TimeStamp.AccumulateBytes(cbBytesToCopy);

        /*  Is this  a bit expensive?  - who cares about the stop time */
        pStreamSample->m_pMediaSample->m_rtEndTime =
            m_TimeStamp.TimeStamp(0, m_lBytesPerSecond);
        if (m_cbData == 0) {
            //  This performs the Release()
            m_arSamples.Remove(0);
        }
        m_pbData += cbBytesToCopy;
        pStreamSample->m_cbData += cbBytesToCopy;

        //  Update the actual data object
        pStreamSample->m_pMemData->SetActual(pStreamSample->m_cbData);
        if (pStreamSample->m_cbData == pStreamSample->m_cbSize) {
            // this is a lot of overhead since we know
            // it's free but it's not a bug
#if 0
            AtlTrace("Sample start %dms, length %dms bytelen %dms\n",
                     (long)(pStreamSample->m_pMediaSample->m_rtEndTime / 10000),
                     (long)((pStreamSample->m_pMediaSample->m_rtEndTime -
                             pStreamSample->m_pMediaSample->m_rtStartTime) / 10000),
                     MulDiv(pStreamSample->m_cbData, 1000, m_lBytesPerSecond));
#endif
            StealSampleFromFreePool(m_pFirstFree, true);
            pStreamSample->SetCompletionStatus(S_OK);
        }
    }
    CheckEndOfStream();
}

void CByteStream::CheckEndOfStream()
{
    AUTO_CRIT_LOCK;
    if (m_bEOSPending && m_arSamples.Size() == 0) {
        m_bEOSPending = false;

        //  If the first sample contains data set the status on the
        //  next one
        if (m_pFirstFree != NULL) {
            CByteStreamSample* const pStreamSample =
            (CByteStreamSample *)m_pFirstFree;
            if (pStreamSample->m_cbData != 0) {
                StealSampleFromFreePool(m_pFirstFree, true);
                pStreamSample->SetCompletionStatus(S_OK);
            }
        }

        CStream::EndOfStream();
    }
}

#if 0
HRESULT CByteStream::InternalAllocateSample(
    IByteStreamSample **ppBSSample
)
{
    CByteStreamSample *pBSSample = new CComObject<CByteStreamSample>;
    if (pBSSample == NULL) {
        *ppBSSample = NULL;
        return E_OUTOFMEMORY;
    } else {
        return pBSSample->GetControllingUnknown()->QueryInterface(
            IID_IByteStreamSample, (void **)ppBSSample
        );
    }
}
#endif

//
//   CByteStreamSample
//

CByteStreamSample::CByteStreamSample() :
    m_pbData(NULL),
    m_cbSize(0),
    m_cbData(0)
{
}

HRESULT CByteStreamSample::InternalUpdate(
    DWORD dwFlags,
    HANDLE hEvent,
    PAPCFUNC pfnAPC,
    DWORD_PTR dwAPCData
)
{
    if (m_pMemData == NULL) {
        return MS_E_NOTINIT;
    }
    HRESULT hr =  m_pMemData->GetInfo(
                      &m_cbSize,
                      &m_pbData,
                      &m_cbData
                  );
    if (FAILED(hr)) {
        return hr;
    }

    //  InternalUpdate will check everything and add us to queues etc
    hr =  CSample::InternalUpdate(dwFlags, hEvent, pfnAPC, dwAPCData);
    if (SUCCEEDED(hr) && m_pStream->m_Direction == PINDIR_INPUT) {
        m_cbData = 0;
        m_pMemData->SetActual(0);
        CByteStream *pStream = (CByteStream *)m_pStream;
        pStream->FillSamples();
    }
    return hr;
}

STDMETHODIMP::CByteStreamSample::GetInformation(
    /* [out] */ DWORD *pdwLength,
    /* [out] */ PBYTE *ppbData,
    /* [out] */ DWORD *pcbActualData
)
{
    if (m_pbData == NULL) {
        return MS_E_NOTINIT;
    }
    if (pdwLength) {
        *pdwLength = m_cbSize;
    }
    if (ppbData) {
        *ppbData = m_pbData;
    }
    if (pcbActualData) {
        *pcbActualData = m_cbData;
    }
    return S_OK;
}


HRESULT CByteStreamSample::Init(
    IMemoryData *pMemData
)
{
    if (m_pMemData) {
        _ASSERTE(_T("Initialization called twice!"));
        return E_UNEXPECTED;
    }
    m_pMemData = pMemData;
    return S_OK;
}
=== C:/Users/treeman/Desktop/windows nt source code\Source\Win2K3\NT\multimedia\dshow\streams\ddstream\ddsample.cpp ===
// Copyright (c) 1997 - 1998  Microsoft Corporation.  All Rights Reserved.
// Sample.cpp: implementation of the DirectDraw Sample class.
//
//////////////////////////////////////////////////////////////////////

#include "stdafx.h"
#include "project.h"

#define m_pDDStream ((CDDStream *)m_pStream)

CDDSample::CDDSample() :
    m_pSurface(NULL),
    m_lLastSurfacePitch(0),
    m_bFormatChanged(false),
    m_lImageSize(0),
    m_pvLockedSurfacePtr(0)
{
}

HRESULT CDDSample::InitSample(CStream *pStream, IDirectDrawSurface *pSurface, const RECT *pRect, bool bIsProgressiveRender, bool bIsInternal,
                              bool bTemp)
{
    m_pMediaSample = new CDDMediaSample(this);
    if (!m_pMediaSample) {
        return E_OUTOFMEMORY;
    }
    HRESULT hr = CSample::InitSample(pStream, bIsInternal);
    if (FAILED(hr)) {
        return hr;
    }
    m_pSurface = pSurface;  // Auto addref since CComPtr
    m_Rect = *pRect;
    m_bProgressiveRender = bIsProgressiveRender;
    m_bTemp = bTemp;
    return S_OK;
}

//
// IDirectDrawStreamSample
//
STDMETHODIMP CDDSample::GetSurface(IDirectDrawSurface **ppDirectDrawSurface, RECT * pRect)
{
    TRACEINTERFACE(_T("IDirectDrawStreamSample::GetSurface(0x%8.8X, 0x%8.8X)\n"),
                   ppDirectDrawSurface, pRect);
    AUTO_SAMPLE_LOCK;
    if (ppDirectDrawSurface) {
        *ppDirectDrawSurface = m_pSurface;
        (*ppDirectDrawSurface)->AddRef();
    }
    if (pRect) {
        *pRect = m_Rect;
    }
    return S_OK;
}


STDMETHODIMP CDDSample::SetRect(const RECT * pRect)
{
    TRACEINTERFACE(_T("IDirectDrawStreamSample::SetRect(0x%8.8X)\n"),
                   pRect);
    HRESULT hr;
    if (!pRect) {
        hr = E_POINTER;
    } else {
        DDSURFACEDESC ddsd;
        ddsd.dwSize = sizeof(ddsd);
        hr = m_pSurface->GetSurfaceDesc(&ddsd);
        if (SUCCEEDED(hr)) {
            if (pRect->right > (LONG)ddsd.dwWidth ||
                pRect->bottom > (LONG)ddsd.dwHeight ||
                pRect->right - pRect->left != m_pDDStream->m_Width ||
                pRect->bottom - pRect->top != m_pDDStream->m_Height) {
                hr = DDERR_INVALIDRECT;
            } else {
                AUTO_SAMPLE_LOCK;
                m_Rect = *pRect;
                m_bFormatChanged = true;
                hr = S_OK;
            }
        }
    }
    return hr;
}


void CDDSample::ReleaseMediaSampleLock()
{
    AUTO_SAMPLE_LOCK;
    if (m_pvLockedSurfacePtr != NULL) {
        m_pSurface->Unlock(m_pvLockedSurfacePtr);
        m_pvLockedSurfacePtr = NULL;
    }
}

HRESULT CDDSample::LockMediaSamplePointer()
{
    HRESULT hr = S_OK;
    AUTO_SAMPLE_LOCK;
    if (m_pvLockedSurfacePtr == NULL) {
        DDSURFACEDESC ddsd;
        ddsd.dwSize = sizeof(ddsd);
        hr = m_pSurface->Lock(NULL, &ddsd, DDLOCK_SURFACEMEMORYPTR | DDLOCK_WAIT, NULL);
        if (SUCCEEDED(hr)) {
            m_pvLockedSurfacePtr = ddsd.lpSurface;
        }
    }
    return hr;
}

long CDDSample::LockAndPrepareMediaSample(long lLastPinPitch)
{
    AUTO_SAMPLE_LOCK;
    if (m_pvLockedSurfacePtr == NULL) {
        DDSURFACEDESC ddsd;
        ddsd.dwSize = sizeof(ddsd);
        if (m_pMediaSample->m_pMediaType) {
            DeleteMediaType(m_pMediaSample->m_pMediaType);	
            m_pMediaSample->m_pMediaType = NULL;
        }
        if (FAILED(m_pSurface->Lock(NULL, &ddsd, DDLOCK_SURFACEMEMORYPTR | DDLOCK_WAIT, NULL))) {
            return 0;
        }
        m_pvLockedSurfacePtr = ddsd.lpSurface;
        if (lLastPinPitch != ddsd.lPitch ||
    	    m_lLastSurfacePitch != ddsd.lPitch ||
            m_bFormatChanged) {
            ConvertSurfaceDescToMediaType(&ddsd, m_pDDStream->m_pDirectDrawPalette,
                                          &m_Rect, TRUE, &m_pMediaSample->m_pMediaType,
                                          &m_pStream->m_ConnectedMediaType);
    	    if (m_pMediaSample->m_pMediaType) {
                VIDEOINFO *pvi = (VIDEOINFO *)m_pMediaSample->m_pMediaType->pbFormat;
                m_lImageSize = pvi->bmiHeader.biSizeImage;
    	        m_lLastSurfacePitch = ddsd.lPitch;
                m_bFormatChanged = false;
    	    } else {
    	        ReleaseMediaSampleLock();
    	        return 0;
            }
    	}
        return ddsd.lPitch;
    } else {
        return lLastPinPitch;
    }
}



void CDDSample::FinalMediaSampleRelease()
{
    ReleaseMediaSampleLock();
    CSample::FinalMediaSampleRelease();
}


HRESULT CDDSample::CopyFrom(CDDSample *pSrcSample)
{
    AUTO_SAMPLE_LOCK;
    CSample::CopyFrom(pSrcSample);
    return m_pSurface->BltFast(m_Rect.left, m_Rect.top,
                               pSrcSample->m_pSurface, &pSrcSample->m_Rect,
                               DDBLTFAST_NOCOLORKEY | DDBLTFAST_WAIT);
}



//
//  Helper
//
//  ASSUMES pClip clipped to surfae
//
void CopySampleToSurface(
    IMediaSample *pSample,
    VIDEOINFO *pInfo,
    DDSURFACEDESC& ddsd,
    const RECT *pClip
)
{

    DWORD dwBytesPerPixel = pInfo->bmiHeader.biBitCount / 8;

    //  Need src pointer and stride for source and dest and
    //  number of lines

    //
    //  The source of the target is the top left-hand corner of pClip
    //  within the surface
    //

    PBYTE pbSource;
    PBYTE pbTarget;
    LONG lSourceStride;
    LONG lTargetStride;
    DWORD dwWidth;
    DWORD dwLines;


    //
    //  Target first
    //
    pbTarget = (LPBYTE)ddsd.lpSurface;
    lTargetStride = ddsd.lPitch;
    dwLines = ddsd.dwHeight;
    dwWidth = ddsd.dwWidth;
    if (pClip) {
        pbTarget += (pClip->left + pClip->top * ddsd.lPitch) * dwBytesPerPixel;
        lTargetStride -= (ddsd.dwWidth - (pClip->right - pClip->left)) *
                         dwBytesPerPixel;
        dwLines = pClip->bottom - pClip->top;
        dwWidth = pClip->right - pClip->left;
    }

    //  Now do the source
    HRESULT hr = pSample->GetPointer(&pbSource);
    _ASSERTE(SUCCEEDED(hr));

    //  Adjust to the source rect - if the height is negative
    //  it means we have a ddraw surface already, otherwise
    //  we must invert everything
    LONG lSourceHeight = (LONG)pInfo->bmiHeader.biHeight;
    lSourceStride = pInfo->bmiHeader.biWidth * dwBytesPerPixel;
    if (lSourceHeight > 0) {
        pbSource += (lSourceStride * (lSourceHeight - 1));
        lSourceStride = -lSourceStride;
    } else {
        lSourceHeight = -lSourceHeight;
    }
    if (!IsRectEmpty(&pInfo->rcSource)) {
        pbSource += (pInfo->rcSource.left +
                     pInfo->rcSource.top * lSourceStride) * dwBytesPerPixel;
        //  Now check on the width etc
        dwWidth = min(dwWidth, (DWORD)(pInfo->rcSource.right - pInfo->rcSource.left));
        dwLines = min(dwLines, (DWORD)(pInfo->rcSource.bottom - pInfo->rcSource.top));
    } else {
        dwWidth = min(dwWidth, (DWORD)pInfo->bmiHeader.biWidth);
        dwLines = min(dwLines, (DWORD)lSourceHeight);
    }

    //
    //  Now do the copy
    //

    DWORD dwWidthInBytes = dwWidth * dwBytesPerPixel;

    while (dwLines-- > 0) {
        CopyMemory(pbTarget, pbSource, dwWidthInBytes);
        pbSource += lSourceStride;
        pbTarget += lTargetStride;
    }
}



HRESULT CDDSample::CopyFrom(IMediaSample *pSrcMediaSample, const AM_MEDIA_TYPE *pmt)
{
    AUTO_SAMPLE_LOCK;
    CSample::CopyFrom(pSrcMediaSample);
    DDSURFACEDESC ddsd;
    ddsd.dwSize = sizeof(ddsd);
    HRESULT hr = m_pSurface->Lock(NULL, &ddsd, DDLOCK_SURFACEMEMORYPTR | DDLOCK_WAIT, NULL);
    if (SUCCEEDED(hr)) {
        CopySampleToSurface(pSrcMediaSample, (VIDEOINFO *)pmt->pbFormat, ddsd, &m_Rect);
        m_pSurface->Unlock(ddsd.lpSurface);
    }
    return hr;
}


CDDInternalSample::CDDInternalSample() :
    m_pBuddySample(NULL),
    m_lWaiting(0),
    m_hWaitFreeSem(NULL),
    m_bDead(false)
{
};


CDDInternalSample::~CDDInternalSample()
{
    // ATLTRACE("CDDInternalSample::~CDDInternalSample\n");
    if (m_hWaitFreeSem) {
        CloseHandle(m_hWaitFreeSem);
    }
}


HRESULT CDDInternalSample::InternalInit(void)
{
    m_hWaitFreeSem = CreateSemaphore(NULL, 0, 0x7FFFFFF, NULL);
    return m_hWaitFreeSem ? S_OK : E_OUTOFMEMORY;
}


HRESULT CDDInternalSample::JoinToBuddy(CDDSample *pBuddy)
{
    LOCK_SAMPLE;
    while (!m_bDead && m_pBuddySample) {
        m_lWaiting++;
        UNLOCK_SAMPLE;
        WaitForSingleObject(m_hWaitFreeSem, INFINITE);
        LOCK_SAMPLE;
    }
    HRESULT hr;
    if (m_bDead) {
        hr = VFW_E_NOT_COMMITTED;
    } else {
        hr = S_OK;
        m_pBuddySample = pBuddy;
        ResetEvent(m_hCompletionEvent);
        m_Status = MS_S_PENDING;
        m_bWantAbort = false;
        m_bModified = false;
        m_bContinuous = false;
        m_UserAPC = 0;
        m_hUserHandle = NULL;
    }
    UNLOCK_SAMPLE;
    return hr;
}


HRESULT CDDInternalSample::Die(void)
{
    AUTO_SAMPLE_LOCK;
    m_bDead = true;
    if (m_lWaiting) {
        ReleaseSemaphore(m_hWaitFreeSem, m_lWaiting, 0);
        m_lWaiting = 0;
    }
    return S_OK;
}

HRESULT CDDInternalSample::SetCompletionStatus(HRESULT hrStatus)
{
    if (m_pBuddySample != NULL) {
        if (hrStatus == S_OK) {
            m_pBuddySample->CopyFrom(this);
        }
        //
        //  If we're just being recycled, but our buddy wants to abort, then abort him.
        //
        m_pBuddySample->SetCompletionStatus((hrStatus == MS_S_PENDING && m_pBuddySample->m_bWantAbort) ? E_ABORT : hrStatus);
    }

    LOCK_SAMPLE;
    m_Status = S_OK;
    m_pBuddySample = NULL;
    if (m_lWaiting) {
        m_lWaiting--;
        ReleaseSemaphore(m_hWaitFreeSem, 1, 0);
    }
    UNLOCK_SAMPLE;
    GetControllingUnknown()->Release(); // May die right here
    return hrStatus;
}



//
//  Forwarded IMediaSample methods.
//
HRESULT CDDSample::MSCallback_GetPointer(BYTE ** ppBuffer)
{
    *ppBuffer = (BYTE *)m_pvLockedSurfacePtr;
    return NOERROR;
}

LONG CDDSample::MSCallback_GetSize(void)
{
    return m_lImageSize;
}

LONG CDDSample::MSCallback_GetActualDataLength(void)
{
    return m_lImageSize;
}

HRESULT CDDSample::MSCallback_SetActualDataLength(LONG lActual)
{
    if (lActual == m_lImageSize) {
	return S_OK;
    } else {
	return E_FAIL;
    }
}


STDMETHODIMP CDDMediaSample::QueryInterface(REFIID riid, void ** ppv)
{
    if (riid==IID_IDirectDrawMediaSample) {
	*ppv = (IDirectDrawMediaSample *)this;
	((LPUNKNOWN)(*ppv))->AddRef();
	return S_OK;
    }
    return CMediaSample::QueryInterface(riid, ppv);
}


#define m_pDDSample ((CDDSample *)m_pSample)

STDMETHODIMP CDDMediaSample::GetSurfaceAndReleaseLock(IDirectDrawSurface **ppDirectDrawSurface, RECT * pRect)
{
    m_pDDSample->ReleaseMediaSampleLock();
    return m_pDDSample->GetSurface(ppDirectDrawSurface, pRect);
}


STDMETHODIMP CDDMediaSample::LockMediaSamplePointer()
{
    return m_pDDSample->LockMediaSamplePointer();
}
=== C:/Users/treeman/Desktop/windows nt source code\Source\Win2K3\NT\multimedia\dshow\streams\ddstream\ddsample.h ===
// Copyright (c) 1997 - 1998  Microsoft Corporation.  All Rights Reserved.

/////////////////////////////////////////////////////////////////////////////
// CDDSample
class ATL_NO_VTABLE CDDSample :
        public CSample,
	public IDirectDrawStreamSample
{
public:
        CDDSample();

        HRESULT InitSample(CStream *pStream, IDirectDrawSurface *pSurface, const RECT *pRect, bool bIsProgressiveRender, bool bIsInternalSample,
                           bool bTemp);

        //
        //  IStreamSample
        //
        STDMETHODIMP GetMediaStream(
            /* [in] */ IMediaStream **ppMediaStream)
        {
            return CSample::GetMediaStream(ppMediaStream);
        }

        STDMETHODIMP GetSampleTimes(
            /* [optional][out] */ STREAM_TIME *pStartTime,
            /* [optional][out] */ STREAM_TIME *pEndTime,
            /* [optional][out] */ STREAM_TIME *pCurrentTime)
        {
            return CSample::GetSampleTimes(
                pStartTime,
                pEndTime,
                pCurrentTime
            );
        }

        STDMETHODIMP SetSampleTimes(
            /* [optional][in] */ const STREAM_TIME *pStartTime,
            /* [optional][in] */ const STREAM_TIME *pEndTime)
        {
            return CSample::SetSampleTimes(pStartTime, pEndTime);
        }

        STDMETHODIMP Update(
            /* [in] */           DWORD dwFlags,
            /* [optional][in] */ HANDLE hEvent,
            /* [optional][in] */ PAPCFUNC pfnAPC,
            /* [optional][in] */ DWORD_PTR dwAPCData)
        {
            return CSample::Update(dwFlags, hEvent, pfnAPC, dwAPCData);
        }

        STDMETHODIMP CompletionStatus(
            /* [in] */ DWORD dwFlags,
            /* [optional][in] */ DWORD dwMilliseconds)
        {
            return CSample::CompletionStatus(dwFlags, dwMilliseconds);
        }
        //
        // IDirectDrawStreamSample
        //
        STDMETHODIMP GetSurface(IDirectDrawSurface **ppDirectDrawSurface, RECT * pRect);
        STDMETHODIMP SetRect(const RECT * pRect);

        //
        //  Overridden virtual function for CSample
        //
        void FinalMediaSampleRelease(void);


        //
        //  Methods forwarded from MediaSample object.
        //
        HRESULT MSCallback_GetPointer(BYTE ** ppBuffer);
        LONG MSCallback_GetSize(void);
        LONG MSCallback_GetActualDataLength(void);
        HRESULT MSCallback_SetActualDataLength(LONG lActual);

        //
        // Internal methods
        //
        long LockAndPrepareMediaSample(long lLastPinPitch);
        void ReleaseMediaSampleLock(void);
        HRESULT CopyFrom(CDDSample *pSrcSample);
        HRESULT CopyFrom(IMediaSample *pSrcMediaSample, const AM_MEDIA_TYPE *pmt);
        HRESULT LockMediaSamplePointer();

BEGIN_COM_MAP(CDDSample)
	COM_INTERFACE_ENTRY(IDirectDrawStreamSample)
        COM_INTERFACE_ENTRY_CHAIN(CSample)
END_COM_MAP()

public:
        CComPtr<IDirectDrawSurface>     m_pSurface;
        RECT                            m_Rect;

        long                            m_lLastSurfacePitch;
        bool                            m_bProgressiveRender;
        bool                            m_bFormatChanged;

        LONG                            m_lImageSize;
        void *                          m_pvLockedSurfacePtr;
};



class CDDInternalSample : public CDDSample
{
public:
    CDDInternalSample();
    ~CDDInternalSample();
    HRESULT InternalInit(void);
    HRESULT SetCompletionStatus(HRESULT hrStatus);
    HRESULT Die(void);
    HRESULT JoinToBuddy(CDDSample *pBuddy);

    BOOL HasBuddy() const
    {
        return m_pBuddySample != NULL;
    }
    
private:
    CDDSample       *m_pBuddySample;    
    long            m_lWaiting;
    HANDLE          m_hWaitFreeSem;
    bool            m_bDead;
};


class CDDMediaSample : public CMediaSample, public IDirectDrawMediaSample
{
public:
    CDDMediaSample(CSample *pSample) :
      CMediaSample(pSample) {};
    STDMETHODIMP QueryInterface(REFIID riid, void ** ppv);
    STDMETHODIMP_(ULONG) AddRef() {return CMediaSample::AddRef();}
    STDMETHODIMP_(ULONG) Release() {return CMediaSample::Release();}

    STDMETHODIMP GetSurfaceAndReleaseLock(IDirectDrawSurface **ppDirectDrawSurface, RECT * pRect);
    STDMETHODIMP LockMediaSamplePointer();
};
=== C:/Users/treeman/Desktop/windows nt source code\Source\Win2K3\NT\multimedia\dshow\streams\ddstream\ddstrm.cpp ===
// Copyright (c) 1997 - 1998  Microsoft Corporation.  All Rights Reserved.
// DDStrm.cpp : Implementation of CDDStream
#include "stdafx.h"
#include "project.h"

//#define SHOWSURFACES

#ifdef SHOWSURFACES
//  See if we can blt this to the screen
void ShowSurface(IDirectDrawSurface *pSurface)
{
    CComPtr<IDirectDraw> pDDraw;
    CComPtr<IDirectDrawSurface2> pSurface2;
    DDSURFACEDESC ddsdSurf;
    ddsdSurf.dwSize = sizeof(ddsdSurf);
    HRESULT hr = pSurface->QueryInterface(IID_IDirectDrawSurface2, (void **)&pSurface2);
    if (SUCCEEDED(hr)) {
        hr = pSurface2->GetDDInterface((void **)&pDDraw);
    }
    if (SUCCEEDED(hr)) {
        hr = pSurface->GetSurfaceDesc(&ddsdSurf);
    }
    if (SUCCEEDED(hr)) {
        CComPtr<IDirectDrawSurface> pPrimary;
        DDSURFACEDESC ddsd;
        ddsd.dwSize = sizeof(ddsd);
        ddsd.dwFlags = DDSD_CAPS;
        ddsd.ddsCaps.dwCaps = DDSCAPS_PRIMARYSURFACE;
        HRESULT hr = pDDraw->CreateSurface(&ddsd, &pPrimary, NULL);
        RECT rc;
        rc.left = 0;
        rc.top = 0;
        rc.right = ddsdSurf.dwWidth;
        rc.bottom = ddsdSurf.dwHeight;
        if (SUCCEEDED(hr)) {
    	    pPrimary->Blt(&rc, pSurface, &rc, DDBLT_WAIT, NULL);
        } else {
        }
    }
}
#endif

/////////////////////////////////////////////////////////////////////////////
// CDDStream

CDDStream::CDDStream() :
    m_dwForcedFormatFlags(0),
    m_Height(0),
    m_Width(0),
    m_lLastPitch(0),
    m_pMyReadOnlySample(NULL),
    m_pDefPixelFormat(GetDefaultPixelFormatPtr(NULL))
{
}

HRESULT CDDStream::InitDirectDraw()
{
    HRESULT hr = NOERROR;
    if (!m_pDirectDraw) {
        CComPtr<IDirectDraw> pDDraw;
        hr = DirectDrawCreate(NULL, &pDDraw, NULL);
        if (SUCCEEDED(hr)) {
            hr = pDDraw->SetCooperativeLevel(NULL, DDSCL_NORMAL);
        }
        if (SUCCEEDED(hr)) {
            m_pDirectDraw = pDDraw;
        }
    }
    return hr;
}

HRESULT CDDStream::InternalAllocateSample(
    DWORD dwFlags,
    bool bIsInternalSample,
    IDirectDrawStreamSample **ppDDSample,
    bool bTemp
)
{
    AUTO_CRIT_LOCK;
    HRESULT hr = S_OK;
    CComPtr <IDirectDrawSurface> pSurface;
    CComPtr<IDirectDrawPalette> pPalette;

    //
    //  Create the direct draw object here if necessary.  It is important to call the
    //  SetDirectDraw method so it can set other member variables appropriately
    //
    if (!m_pDirectDraw) {
        hr = InitDirectDraw();
        if (FAILED(hr)) {
            goto Exit;
        }
    }

    DDSURFACEDESC ddsd;
    ddsd.dwSize = sizeof(ddsd);
    GetFormatInternal(&ddsd, &pPalette, NULL, NULL);

    hr = m_pDirectDraw->CreateSurface(&ddsd, &pSurface, NULL);
    if (SUCCEEDED(hr)) {
        if (pPalette) {
            pSurface->SetPalette(pPalette);
        }
        RECT rect = {0, 0, ddsd.dwWidth, ddsd.dwHeight};
        hr = InternalCreateSample(pSurface,
                                  &rect,
                                  dwFlags,
                                  bIsInternalSample,
                                  ppDDSample,
                                  bTemp);
        // No need to release surface if create fails since pSurface is a CComPtr

        if (SUCCEEDED(hr) && !bIsInternalSample) {
            //  Make sure the surface has a palette if the stream has one
            if (pPalette == NULL && m_pDirectDrawPalette) {
                pSurface->SetPalette(m_pDirectDrawPalette);
            }
        }
    }
Exit:
    return hr;
}


STDMETHODIMP CDDStream::SetSameFormat(IMediaStream *pStream, DWORD dwFlags)
{
    TRACEINTERFACE(_T("IDirectDrawStream::SetSameFormat(0x%8.8X, 0x%8.8X)\n"),
                   pStream, dwFlags);
    CComQIPtr<IDirectDrawMediaStream, &IID_IDirectDrawMediaStream> pSource(pStream);
    if (!pSource) {
        return MS_E_INCOMPATIBLE;
    }
    DDSURFACEDESC ddsdCurrent;
    CComPtr <IDirectDrawPalette> pPalette;
    ddsdCurrent.dwSize = sizeof(ddsdCurrent);
    HRESULT hr = pSource->GetFormat(&ddsdCurrent, &pPalette, NULL, 0);

    /*  Lock the source format */
    ddsdCurrent.dwFlags |= DDSD_WIDTH | DDSD_HEIGHT | DDSD_PIXELFORMAT;
    if (SUCCEEDED(hr)) {
        hr = pSource->SetFormat(&ddsdCurrent, pPalette);
    }
    if (SUCCEEDED(hr)) {
        hr = SetFormat(&ddsdCurrent, pPalette);
        if (SUCCEEDED(hr)) {
            CComPtr<IDirectDraw> pDD;
            hr = pSource->GetDirectDraw(&pDD);
            if (SUCCEEDED(hr)) {
                hr = SetDirectDraw(pDD);
            }
        }
    }
    return hr;
}

STDMETHODIMP CDDStream::AllocateSample(DWORD dwFlags, IStreamSample **ppSample)
{
    TRACEINTERFACE(_T("IDirectDrawStream::AllocateSample(0x%8.8X, 0x%8.8X)\n"),
                   dwFlags, ppSample);
    HRESULT hr;
    if (ppSample) {
        *ppSample = NULL;
    }
    if (!ppSample || dwFlags) {
        hr = E_INVALIDARG;
    } else {
        IDirectDrawStreamSample *pDDSample = NULL;
        hr = InternalAllocateSample(0, false, &pDDSample);
        *ppSample = pDDSample;
    }
    return hr;
}


STDMETHODIMP CDDStream::CreateSharedSample(IStreamSample *pExistingSample,
                                           DWORD dwFlags,
                                           IStreamSample **ppNewSample)
{
    TRACEINTERFACE(_T("IDirectDrawStream::CreateSharedSample(0x%8.8X, 0x%8.8X, 0x%8.8X)\n"),
                   pExistingSample, dwFlags, ppNewSample);
    *ppNewSample = NULL;
    CComQIPtr<IDirectDrawStreamSample, &IID_IDirectDrawStreamSample> pSource(pExistingSample);
    if (!pSource) {
        return MS_E_INCOMPATIBLE;
    }
    CComPtr<IDirectDrawSurface> pSurface;
    RECT rect;
    pSource->GetSurface(&pSurface, &rect);

    IDirectDrawStreamSample * pDDSample;
    HRESULT hr = CreateSample(pSurface, &rect, 0, &pDDSample);
    if (SUCCEEDED(hr)) {
        *ppNewSample = pDDSample;
    }
    return hr;
}


//
// IDirectDrawMediaStream
//

void CDDStream::InitSurfaceDesc(LPDDSURFACEDESC lpddsd)
{
    lpddsd->dwFlags = 0;
    if (m_Height) {
        lpddsd->dwHeight = m_Height;
        lpddsd->dwWidth  = m_Width;
    } else {
        lpddsd->dwHeight = lpddsd->dwWidth = 100;
    }
    if ((m_dwForcedFormatFlags & DDSD_PIXELFORMAT) || m_pConnectedPin) {
        memcpy(&lpddsd->ddpfPixelFormat, &m_PixelFormat, sizeof(m_PixelFormat));
    } else {
        memcpy(&lpddsd->ddpfPixelFormat, m_pDefPixelFormat, sizeof(m_PixelFormat));
    }
    lpddsd->ddsCaps.dwCaps = DDSCAPS_OFFSCREENPLAIN | DDSCAPS_SYSTEMMEMORY;
}


STDMETHODIMP CDDStream::GetFormat(DDSURFACEDESC *pDDSDCurrent,
                                  IDirectDrawPalette **ppDirectDrawPalette,
                                  DDSURFACEDESC *pDDSDDesired,
                                  DWORD *pdwFlags)
{
    if(!m_pConnectedPin) {
        return MS_E_NOSTREAM;
    }

    return GetFormatInternal(pDDSDCurrent, ppDirectDrawPalette, pDDSDDesired, pdwFlags);
}

STDMETHODIMP CDDStream::GetFormatInternal(DDSURFACEDESC *pDDSDCurrent,
                                  IDirectDrawPalette **ppDirectDrawPalette,
                                  DDSURFACEDESC *pDDSDDesired,
                                  DWORD *pdwFlags)
{
    TRACEINTERFACE(_T("IDirectDrawStream::GetFormat(0x%8.8X, 0x%8.8X, 0x%8.8X, 0x%8.8X)\n"),
                   pDDSDCurrent, ppDirectDrawPalette, pDDSDDesired, pdwFlags);
    //
    // If we have never connected, and the format is not set, then default
    // to returning a height and width (100 x 100) and a caps of
    // data interchange type,
    //
    // If we are connected but haven't allocated a sureface, simply return the
    // correct height and width, and a caps of data interchange type.
    //
    // If we have a set format, then return the height, width, pixel format,
    // and caps of the current surfacedesc we have.
    //
    if (pDDSDCurrent) {
        InitSurfaceDesc(pDDSDCurrent);
        pDDSDCurrent->dwFlags = DDSD_HEIGHT | DDSD_WIDTH | DDSD_CAPS | m_dwForcedFormatFlags;
        if (m_cAllocated) {
            pDDSDCurrent->dwFlags |= DDSD_PIXELFORMAT;
        }
    }
    if (pDDSDDesired) {
        InitSurfaceDesc(pDDSDDesired);
        if (m_pConnectedPin) {
            pDDSDDesired->dwFlags |= DDSD_HEIGHT | DDSD_WIDTH;
        }
    }
    if (ppDirectDrawPalette) {
        *ppDirectDrawPalette = m_pDirectDrawPalette;
        if (*ppDirectDrawPalette) {
            (*ppDirectDrawPalette)->AddRef();
        }
    }
    if (pdwFlags) {
        *pdwFlags = m_bSamplesAreReadOnly ? DDSFF_PROGRESSIVERENDER : 0;
    }
    return S_OK;
}

STDMETHODIMP CDDStream::SetFormat(const DDSURFACEDESC *lpDDSurfaceDesc,
                                  IDirectDrawPalette *pDirectDrawPalette)
{
    TRACEINTERFACE(_T("IDirectDrawStream::SetFormat(0x%8.8X, 0x%8.8X)\n"),
                   lpDDSurfaceDesc, pDirectDrawPalette);
    HRESULT hr = InternalSetFormat(lpDDSurfaceDesc, pDirectDrawPalette, false);
    if (hr == VFW_E_TYPE_NOT_ACCEPTED) {
        hr = DDERR_INVALIDSURFACETYPE;
    }
    return hr;
}


HRESULT CDDStream::RenegotiateMediaType(const DDSURFACEDESC *lpDDSurfaceDesc,
                                        IDirectDrawPalette *pPalette,
                                        const AM_MEDIA_TYPE *pmt)
{
    HRESULT hr = VFW_E_TYPE_NOT_ACCEPTED;
    //  If the type is acceptable and we're using
    //  our own allocator then QueryAccept is OK - we can
    //  just return the ne