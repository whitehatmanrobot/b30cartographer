S_ VARIANT FAR *pVariant)                                                             \
{                                                                                                  \
    HRESULT hr = S_OK;                                                                             \
                                                                                                   \
    hr = GenericNextPropertyManager(                                                               \
                    _pPropertyCache,                                                               \
                    pVariant                                                                       \
                    );                                                                             \
    RRETURN(hr);                                                                                   \
}                                                                                                  \
                                                                                                   \
                                                                                                   \
STDMETHODIMP                                                                                       \
cls::Skip(THIS_ long cElements)                                                                   \
{                                                                                                  \
    HRESULT hr = S_OK;                                                                             \
                                                                                                   \
                                                                                                   \
    hr = GenericSkipPropertyManager(                                                               \
                    _pPropertyCache,                                                               \
                    cElements                                                                      \
                    );                                                                             \
                                                                                                   \
    RRETURN(hr);                                                                                   \
                                                                                                   \
}                                                                                                  \
                                                                                                   \
                                                                                                   \
STDMETHODIMP                                                                                       \
cls::Reset()                                                                                       \
{                                                                                                  \
    HRESULT hr = S_OK;                                                                             \
                                                                                                   \
    hr = GenericResetPropertyManager(                                                              \
                _pPropertyCache                                                                    \
                );                                                                                 \
                                                                                                   \
    RRETURN(hr);                                                                                   \
                                                                                                   \
}                                                                                                  \
                                                                                                   \
STDMETHODIMP                                                                                       \
cls::ResetPropertyItem(THIS_ VARIANT varEntry)                                                                \
{                                                                                                  \
    HRESULT hr = S_OK;                                                                             \
                                                                                                   \
    hr = GenericDeletePropertyManager(                                                             \
                    _pPropertyCache,                                                               \
                    varEntry                                                                       \
                    );                                                                             \
                                                                                                   \
    RRETURN(hr);                                                                                   \
                                                                                                   \
}                                                                                                  \
STDMETHODIMP                                                                                       \
cls::GetPropertyItem(THIS_ BSTR bstrName, LONG lnADsType, VARIANT * pVariant)                      \
{                                                                                                  \
    HRESULT hr = S_OK;                                                                             \
                                                                                                   \
    hr = GenericGetPropItemPropertyManager(                                                        \
                _pPropertyCache,                                                                   \
                GetObjectState(),                                                                  \
                bstrName,                                                                          \
                lnADsType,                                                                         \
                pVariant                                                                           \
                );                                                                                 \
                                                                                                   \
                                                                                                   \
    RRETURN(hr);                                                                                   \
                                                                                                   \
}                                                                                                  \
STDMETHODIMP                                                                                       \
cls::PutPropertyItem(VARIANT varData)                     \
{                                                                                                  \
    HRESULT hr = S_OK;                                                                             \
                                                                                                   \
    hr = GenericPutPropItemPropertyManager(                                                        \
                _pPropertyCache,                                                                   \
                SchemaClassTable,                                                                  \
                dwTableSize,                                                                       \
                varData                                                                            \
                );                                                                                 \
                                                                                                   \
    RRETURN(hr);                                                                                   \
}                                                                                                  \
                                                                                                   \
STDMETHODIMP                                                                                       \
cls::PurgePropertyList(THIS_)                                                                      \
{                                                                                                  \
    HRESULT hr = S_OK;                                                                             \
                                                                                                   \
    hr = GenericPurgePropertyManager(                                                              \
                _pPropertyCache                                                                    \
                );                                                                                 \
                                                                                                   \
                                                                                                   \
    RRETURN(hr);                                                                                   \
}                                                                                                  \
STDMETHODIMP                                                                                       \
cls::Item(THIS_ VARIANT varIndex, VARIANT * pVariant)                                              \
{                                                                                                  \
    HRESULT hr = S_OK;                                                                             \
                                                                                                   \
    hr = GenericItemPropertyManager(                                                               \
                _pPropertyCache,                                                                   \
                GetObjectState(),                                                                  \
                varIndex,                                                                          \
                pVariant                                                                           \
                );                                                                                 \
                                                                                                   \
                                                                                                   \
    RRETURN(hr);                                                                                   \
}                                                                                                  \
                                                                                                   \



#define DEFINE_IDispatch_ExtMgr_Implementation(cls)                          \
STDMETHODIMP                                                          \
cls::GetTypeInfoCount(unsigned int FAR* pctinfo)                      \
{                                                                     \
        if(_pDispatch != NULL) {                                      \
            RRETURN(_pDispatch->GetTypeInfoCount(pctinfo));           \
        }                                                             \
        RRETURN(_pExtMgr->GetTypeInfoCount(pctinfo));                \
}                                                                     \
                                                                      \
STDMETHODIMP                                                          \
cls::GetTypeInfo(unsigned int itinfo, LCID lcid,                      \
        ITypeInfo FAR* FAR* pptinfo)                                  \
{                                                                     \
        if(_pDispatch != NULL) {                                      \
            RRETURN(_pDispatch->GetTypeInfo(itinfo,                   \
                                       lcid,                          \
                                       pptinfo                        \
                                       ));                            \
        }                                                             \
        RRETURN(_pExtMgr->GetTypeInfo(itinfo,                        \
                                       lcid,                          \
                                       pptinfo                        \
                                       ));                            \
}                                                                     \
STDMETHODIMP                                                          \
cls::GetIDsOfNames(REFIID iid, LPWSTR FAR* rgszNames,                 \
        unsigned int cNames, LCID lcid, DISPID FAR* rgdispid)         \
{                                                                     \
        if(_pDispatch != NULL) {                                      \
            RRETURN(_pDispatch->GetIDsOfNames(iid,                    \
                                         rgszNames,                   \
                                         cNames,                      \
                                         lcid,                        \
                                         rgdispid                     \
                                         ));                          \
        }                                                             \
        RRETURN(_pExtMgr->GetIDsOfNames(iid,                         \
                                         rgszNames,                   \
                                         cNames,                      \
                                         lcid,                        \
                                         rgdispid                     \
                                         ));                          \
}                                                                     \
                                                                      \
STDMETHODIMP                                                          \
cls::Invoke(DISPID dispidMember, REFIID iid, LCID lcid,               \
        unsigned short wFlags, DISPPARAMS FAR* pdispparams,           \
        VARIANT FAR* pvarResult, EXCEPINFO FAR* pexcepinfo,           \
        unsigned int FAR* puArgErr)                                   \
{                                                                     \
        if(_pDispatch != NULL) {                                      \
            RRETURN(_pDispatch->Invoke(dispidMember,                  \
                                   iid,                               \
                                   lcid,                              \
                                   wFlags,                            \
                                   pdispparams,                       \
                                   pvarResult,                        \
                                   pexcepinfo,                        \
                                   puArgErr                           \
                                   ));                                \
        }                                                             \
        RRETURN (_pExtMgr->Invoke(dispidMember,                      \
                                   iid,                               \
                                   lcid,                              \
                                   wFlags,                            \
                                   pdispparams,                       \
                                   pvarResult,                        \
                                   pexcepinfo,                        \
                                   puArgErr                           \
                                   ));                                \
}

#define DEFINE_IADsExtension_ExtMgr_Implementation(cls)               \
HRESULT STDMETHODCALLTYPE                                             \
cls::Operate(                                                         \
    DWORD dwCode, VARIANT varData1, VARIANT varData2,                 \
    VARIANT varData3)                                                 \
{                                                                     \
    RRETURN(S_OK);                                                    \
}                                                                     \
                                                                      \
HRESULT STDMETHODCALLTYPE                                             \
cls::PrivateGetIDsOfNames(                                            \
    REFIID riid, OLECHAR FAR* FAR* rgszNames, unsigned int cNames,    \
    LCID lcid, DISPID FAR* rgdispid)                                  \
{                                                                     \
        RRETURN(_pExtMgr->GetIDsOfNames(riid,                        \
                                         rgszNames,                   \
                                         cNames,                      \
                                         lcid,                        \
                                         rgdispid                     \
                                         ));                          \
}                                                                     \
                                                                      \
HRESULT STDMETHODCALLTYPE                                             \
cls::PrivateInvoke(                                                   \
    DISPID dispidMember, REFIID riid, LCID lcid, WORD wFlags,         \
    DISPPARAMS FAR* pdispparams, VARIANT FAR* pvarResult,             \
    EXCEPINFO FAR* pexcepinfo, unsigned int FAR* puArgErr)            \
{                                                                     \
        RRETURN (_pExtMgr->Invoke(dispidMember,                      \
                                   riid,                              \
                                   lcid,                              \
                                   wFlags,                            \
                                   pdispparams,                       \
                                   pvarResult,                        \
                                   pexcepinfo,                        \
                                   puArgErr                           \
                                   ));                                \
}


#define DEFINE_IADsExtension_Implementation(cls)                      \
HRESULT STDMETHODCALLTYPE                                             \
cls::Operate(                                                         \
    DWORD dwCode, VARIANT varData1, VARIANT varData2,                 \
    VARIANT varData3)                                                 \
{                                                                     \
    RRETURN(S_OK);                                                    \
}                                                                     \
                                                                      \
HRESULT STDMETHODCALLTYPE                                             \
cls::PrivateGetIDsOfNames(                                            \
    REFIID riid, OLECHAR FAR* FAR* rgszNames, unsigned int cNames,    \
    LCID lcid, DISPID FAR* rgdispid)                                  \
{                                                                     \
        RRETURN(_pDispMgr->GetIDsOfNames(riid,                        \
                                         rgszNames,                   \
                                         cNames,                      \
                                         lcid,                        \
                                         rgdispid                     \
                                         ));                          \
}                                                                     \
                                                                      \
HRESULT STDMETHODCALLTYPE                                             \
cls::PrivateInvoke(                                                   \
    DISPID dispidMember, REFIID riid, LCID lcid, WORD wFlags,         \
    DISPPARAMS FAR* pdispparams, VARIANT FAR* pvarResult,             \
    EXCEPINFO FAR* pexcepinfo, unsigned int FAR* puArgErr)            \
{                                                                     \
        RRETURN (_pDispMgr->Invoke(dispidMember,                      \
                                   riid,                              \
                                   lcid,                              \
                                   wFlags,                            \
                                   pdispparams,                       \
                                   pvarResult,                        \
                                   pexcepinfo,                        \
                                   puArgErr                           \
                                   ));                                \
}    


#define DEFINE_IDispatch_Delegating_Implementation(cls)               \
STDMETHODIMP                                                          \
cls::GetTypeInfoCount(unsigned int FAR* pctinfo)                      \
{                                                                     \
        if(_pDispatch != NULL) {                                      \
            RRETURN(_pDispatch->GetTypeInfoCount(pctinfo));           \
        }                                                             \
        RRETURN(_pDispMgr->GetTypeInfoCount(pctinfo));                \
}                                                                     \
                                                                      \
STDMETHODIMP                                                          \
cls::GetTypeInfo(unsigned int itinfo, LCID lcid,                      \
        ITypeInfo FAR* FAR* pptinfo)                                  \
{                                                                     \
        if(_pDispatch != NULL) {                                      \
            RRETURN(_pDispatch->GetTypeInfo(itinfo,                   \
                                       lcid,                          \
                                       pptinfo                        \
                                       ));                            \
        }                                                             \
        RRETURN(_pDispMgr->GetTypeInfo(itinfo,                        \
                                       lcid,                          \
                                       pptinfo                        \
                                       ));                            \
}                                                                     \
STDMETHODIMP                                                          \
cls::GetIDsOfNames(REFIID iid, LPWSTR FAR* rgszNames,                 \
        unsigned int cNames, LCID lcid, DISPID FAR* rgdispid)         \
{                                                                     \
        if(_pDispatch != NULL) {                                      \
            RRETURN(_pDispatch->GetIDsOfNames(iid,                    \
                                         rgszNames,                   \
                                         cNames,                      \
                                         lcid,                        \
                                         rgdispid                     \
                                         ));                          \
        }                                                             \
        RRETURN(_pDispMgr->GetIDsOfNames(iid,                         \
                                         rgszNames,                   \
                                         cNames,                      \
                                         lcid,                        \
                                         rgdispid                     \
                                         ));                          \
}                                                                     \
                                                                      \
STDMETHODIMP                                                          \
cls::Invoke(DISPID dispidMember, REFIID iid, LCID lcid,               \
        unsigned short wFlags, DISPPARAMS FAR* pdispparams,           \
        VARIANT FAR* pvarResult, EXCEPINFO FAR* pexcepinfo,           \
        unsigned int FAR* puArgErr)                                   \
{                                                                     \
        if(_pDispatch != NULL) {                                      \
            RRETURN(_pDispatch->Invoke(dispidMember,                  \
                                   iid,                               \
                                   lcid,                              \
                                   wFlags,                            \
                                   pdispparams,                       \
                                   pvarResult,                        \
                                   pexcepinfo,                        \
                                   puArgErr                           \
                                   ));                                \
        }                                                             \
        RRETURN (_pDispMgr->Invoke(dispidMember,                      \
                                   iid,                               \
                                   lcid,                              \
                                   wFlags,                            \
                                   pdispparams,                       \
                                   pvarResult,                        \
                                   pexcepinfo,                        \
                                   puArgErr                           \
                                   ));                                \
}
=== C:/Users/treeman/Desktop/windows nt source code\Source\Win2K3\NT\ds\adsi\winnt\nt2umi.cxx ===
//----------------------------------------------------------------------------
//
//  Microsoft Windows
//  Copyright (C) Microsoft Corporation, 1992 - 2000.
//
//  File:     nt2umi.cxx
//
//  Contents: Contains the routines to convert from NT objects to
//            UMI_PROPERTY structures.
//
//  History:  02-29-00    SivaramR  Created.
//
//----------------------------------------------------------------------------

#include "winnt.hxx"

//----------------------------------------------------------------------------
// Function:   WinNTTypeToUmiIntegers
//
// Synopsis:   Converts from NT object to UMI_PROPERTY structure containing
//             one of the signed/unsigned integers (1, 2, 4 or 8 bytes each).
//
// Arguments:
//
// pNtObject     Pointer to NT object
// dwNumValues   Number of values in pNtObject
// pPropArray    Pointer to UMI_PROPERTY that returns the converted values
// pExistingMem  If non-NULL, the provider does not allocate memory. Instead,
//               the memory pointed to by this argument is used.
// dwMemSize     Number of bytes of memory pointed to by pExistingMem
// UmiType       UMI type to convert the NT object to
//
// Returns:      UMI_S_NO_ERROR on success. Error code otherwise.
//
// Modifies:     *pExistingMem if pExistingMem is non-NULL
//               *pPropArray otherwise
//
//----------------------------------------------------------------------------
HRESULT WinNTTypeToUmiIntegers(
    LPNTOBJECT pNtObject,
    DWORD dwNumValues,
    UMI_PROPERTY *pPropArray,
    LPVOID pExistingMem,
    DWORD dwMemSize,
    UMI_TYPE UmiType
    )
{
    DWORD   dwSize = 0, dwMemRequired = 0, dwNtValue = 0, i = 0;
    void    *pIntArray = NULL;
    HRESULT hr = UMI_S_NO_ERROR;

    // Check if the NT type can be converted to the requested UMI type
    if(pNtObject->NTType != NT_SYNTAX_ID_DWORD)
        BAIL_ON_FAILURE(hr = UMI_E_CANT_CONVERT_DATA);

    switch(UmiType) {

        case UMI_TYPE_I1:
        case UMI_TYPE_UI1:
            dwSize = 1;
            break;

        case UMI_TYPE_I2:
        case UMI_TYPE_UI2:
            dwSize = 2;
            break;

        case UMI_TYPE_I4:
        case UMI_TYPE_UI4:
            dwSize = 4;
            break;

        case UMI_TYPE_I8:
        case UMI_TYPE_UI8:
            dwSize = 8;
            break;

        default:
            BAIL_ON_FAILURE(hr = UMI_E_CANT_CONVERT_DATA);
    }

    dwMemRequired = dwNumValues * dwSize;

    if(NULL == pExistingMem) {
    // provider has to allocate memory
        pIntArray = (void *) AllocADsMem(dwMemRequired);
        if(NULL == pIntArray)
            BAIL_ON_FAILURE(UMI_E_OUT_OF_MEMORY);
    }
    else {
    // user provided memory to return data
        if(dwMemSize < dwMemRequired)
            BAIL_ON_FAILURE(hr = UMI_E_INSUFFICIENT_MEMORY);

        pIntArray = pExistingMem;
    }

    for(i = 0; i < dwNumValues; i++) {
        dwNtValue = pNtObject[i].NTValue.dwValue;

        switch(UmiType) {

            case UMI_TYPE_I1:
            case UMI_TYPE_UI1:
                *((CHAR *)(pIntArray) + i) = (CHAR) dwNtValue;
                break;

            case UMI_TYPE_I2:
            case UMI_TYPE_UI2:
                *((WCHAR *)(pIntArray) + i) = (WCHAR) dwNtValue;
                break;

            case UMI_TYPE_I4:
            case UMI_TYPE_UI4:
                *((DWORD *)(pIntArray) + i) = dwNtValue;
                break;

            case UMI_TYPE_I8:
            case UMI_TYPE_UI8:
                *((__int64 *)(pIntArray) + i) = (__int64) dwNtValue;
                break;

            default:
                BAIL_ON_FAILURE(hr = UMI_E_CANT_CONVERT_DATA);
        } // switch
    } // for

    if(pPropArray != NULL)
        pPropArray->pUmiValue = (UMI_VALUE *) pIntArray;

    RRETURN(hr);

error:
   
    if( (pIntArray != NULL) && (NULL == pExistingMem) )
        FreeADsMem(pIntArray);

    RRETURN(hr);
} 

//----------------------------------------------------------------------------
// Function:   WinNTTypeToUmiFileTimes
//
// Synopsis:   Converts from NT object to UMI_PROPERTY structure containing
//             a filetime.
//
// Arguments:
//
// pNtObject     Pointer to NT object
// dwNumValues   Number of values in pNtObject
// pPropArray    Pointer to UMI_PROPERTY that returns the converted values
// pExistingMem  If non-NULL, the provider does not allocate memory. Instead,
//               the memory pointed to by this argument is used.
// dwMemSize     Number of bytes of memory pointed to by pExistingMem
//
// Returns:      UMI_S_NO_ERROR on success. Error code otherwise.
//
// Modifies:     *pExistingMem if pExistingMem is non-NULL
//               *pPropArray otherwise
//
//----------------------------------------------------------------------------
HRESULT WinNTTypeToUmiFileTimes(
    LPNTOBJECT pNtObject,
    DWORD dwNumValues,
    UMI_PROPERTY *pPropArray,
    LPVOID pExistingMem,
    DWORD dwMemSize
    )
{
    DWORD      dwMemRequired = 0, i = 0;
    void       *pFileTimeArray = NULL;
    HRESULT    hr = UMI_S_NO_ERROR;
    BOOL       fRetVal = FALSE;
    SYSTEMTIME LocalTime, SystemTime;
    FILETIME   LocalFileTime, FileTime;
    LARGE_INTEGER tmpTime;

    // Check if the NT type can be converted to the requested UMI type
    if(pNtObject->NTType != NT_SYNTAX_ID_SYSTEMTIME)
        BAIL_ON_FAILURE(hr = UMI_E_CANT_CONVERT_DATA);

    dwMemRequired = dwNumValues * sizeof(FILETIME);

    if(NULL == pExistingMem) {
    // provider has to allocate memory
        pFileTimeArray = (void *) AllocADsMem(dwMemRequired);
        if(NULL == pFileTimeArray)
            BAIL_ON_FAILURE(UMI_E_OUT_OF_MEMORY);
    }
    else {
    // user provided memory to return data
        if(dwMemSize < dwMemRequired)
            BAIL_ON_FAILURE(hr = UMI_E_INSUFFICIENT_MEMORY);     

        pFileTimeArray = pExistingMem;
    }

    for(i = 0; i < dwNumValues; i++) {
       if(NT_SYNTAX_ID_SYSTEMTIME == pNtObject->NTType) {
            // convert from UTC to local time
            fRetVal = SystemTimeToTzSpecificLocalTime(
                          NULL,
                          &(pNtObject[i].NTValue.stSystemTimeValue),
                          &LocalTime
                          );

            if(FALSE == fRetVal)
                BAIL_ON_FAILURE(hr = HRESULT_FROM_WIN32(GetLastError()));

            fRetVal = SystemTimeToFileTime(
                          &LocalTime,
                          &LocalFileTime
                          );

            if(FALSE == fRetVal)
                BAIL_ON_FAILURE(hr = HRESULT_FROM_WIN32(GetLastError()));
        }
        else if(NT_SYNTAX_ID_DATE == pNtObject->NTType) {
            GetSystemTime(&SystemTime);

            // only the hours and minutes are valid. Rest is no-op.
            SystemTime.wHour = (WORD) ((pNtObject[i].NTValue.dwValue)/60);    
            SystemTime.wMinute = (WORD) ((pNtObject[i].NTValue.dwValue)%60);
            SystemTime.wSecond =0;
            SystemTime.wMilliseconds = 0;

            // now convert UTC To local time
            fRetVal = SystemTimeToTzSpecificLocalTime(
                          NULL,
                          &SystemTime,
                          &LocalTime
                          );
 
            if(FALSE == fRetVal)
               BAIL_ON_FAILURE(hr = HRESULT_FROM_WIN32(GetLastError()));

            fRetVal = SystemTimeToFileTime(
                          &LocalTime,
                          &LocalFileTime
                          );

            if(FALSE == fRetVal)
                BAIL_ON_FAILURE(hr = HRESULT_FROM_WIN32(GetLastError()));
        }
        else if(NT_SYNTAX_ID_DATE_1970 == pNtObject->NTType) {
            memset(&FileTime, 0, sizeof(FILETIME));
            RtlSecondsSince1970ToTime(
                pNtObject[i].NTValue.dwSeconds1970,
                &tmpTime
                );

            FileTime.dwLowDateTime = tmpTime.LowPart;
            FileTime.dwHighDateTime = tmpTime.HighPart;

            fRetVal = FileTimeToLocalFileTime(
                          &FileTime,
                          &LocalFileTime
                          );
            if(FALSE == fRetVal)
                BAIL_ON_FAILURE(hr = HRESULT_FROM_WIN32(GetLastError()));
        }
     
        *((FILETIME *)pFileTimeArray + i) = LocalFileTime;
    }

    if(pPropArray != NULL)
        pPropArray->pUmiValue = (UMI_VALUE *) pFileTimeArray;

    RRETURN(hr);

error:

    if( (pFileTimeArray != NULL) && (NULL == pExistingMem) )
        FreeADsMem(pFileTimeArray);

    RRETURN(hr);
}

//----------------------------------------------------------------------------
// Function:   WinNTTypeToUmiSystemTimes
//
// Synopsis:   Converts from NT object to UMI_PROPERTY structure containing
//             a systemtime.
//
// Arguments:
//
// pNtObject     Pointer to NT object
// dwNumValues   Number of values in pNtObject
// pPropArray    Pointer to UMI_PROPERTY that returns the converted values
// pExistingMem  If non-NULL, the provider does not allocate memory. Instead,
//               the memory pointed to by this argument is used.
// dwMemSize     Number of bytes of memory pointed to by pExistingMem
//
// Returns:      UMI_S_NO_ERROR on success. Error code otherwise.
//
// Modifies:     *pExistingMem if pExistingMem is non-NULL
//               *pPropArray otherwise
//
//----------------------------------------------------------------------------
HRESULT WinNTTypeToUmiSystemTimes(
    LPNTOBJECT pNtObject,
    DWORD dwNumValues,
    UMI_PROPERTY *pPropArray,
    LPVOID pExistingMem,
    DWORD dwMemSize
    )
{
    DWORD      dwMemRequired = 0, i = 0;
    void       *pSysTimeArray = NULL;
    HRESULT    hr = UMI_S_NO_ERROR;
    SYSTEMTIME LocalTime, SystemTime;
    BOOL       fRetVal = FALSE;
    FILETIME   FileTime, LocalFileTime;
    LARGE_INTEGER tmpTime;

    // Check if the NT type can be converted to the requested UMI type
    if( (pNtObject->NTType != NT_SYNTAX_ID_SYSTEMTIME) &&
        (pNtObject->NTType != NT_SYNTAX_ID_DATE) &&
        (pNtObject->NTType != NT_SYNTAX_ID_DATE_1970) ) 
        BAIL_ON_FAILURE(hr = UMI_E_CANT_CONVERT_DATA);

    dwMemRequired = dwNumValues * sizeof(SYSTEMTIME);

    if(NULL == pExistingMem) {
    // provider has to allocate memory
        pSysTimeArray = (void *) AllocADsMem(dwMemRequired);
        if(NULL == pSysTimeArray)
            BAIL_ON_FAILURE(UMI_E_OUT_OF_MEMORY);
    }
    else {
    // user provided memory to return data
        if(dwMemSize < dwMemRequired)
            BAIL_ON_FAILURE(hr = UMI_E_INSUFFICIENT_MEMORY);     

        pSysTimeArray = pExistingMem;
    }

    for(i = 0; i < dwNumValues; i++) {
        if(NT_SYNTAX_ID_SYSTEMTIME == pNtObject->NTType) {
            // convert from UTC to local time
            fRetVal = SystemTimeToTzSpecificLocalTime(
                          NULL,
                          &pNtObject[i].NTValue.stSystemTimeValue,
                          &LocalTime
                          );

            if(FALSE == fRetVal)
                BAIL_ON_FAILURE(hr = HRESULT_FROM_WIN32(GetLastError()));
        }
        else if(NT_SYNTAX_ID_DATE == pNtObject->NTType) {
            GetSystemTime(&SystemTime);

            // only the hours and minutes are valid. Rest is no-op.
            SystemTime.wHour = (WORD) ((pNtObject[i].NTValue.dwValue)/60);    
            SystemTime.wMinute = (WORD) ((pNtObject[i].NTValue.dwValue)%60);
            SystemTime.wSecond =0;
            SystemTime.wMilliseconds = 0;

            // now convert UTC To local time
            fRetVal = SystemTimeToTzSpecificLocalTime(
                          NULL,
                          &SystemTime,
                          &LocalTime
                          );
 
            if(FALSE == fRetVal)
               BAIL_ON_FAILURE(hr = HRESULT_FROM_WIN32(GetLastError()));
        }
        else if(NT_SYNTAX_ID_DATE_1970 == pNtObject->NTType) {
            memset(&FileTime, 0, sizeof(FILETIME));
            RtlSecondsSince1970ToTime(
                pNtObject[i].NTValue.dwSeconds1970,
                &tmpTime
                );

            FileTime.dwLowDateTime = tmpTime.LowPart;
            FileTime.dwHighDateTime = tmpTime.HighPart;

            fRetVal = FileTimeToLocalFileTime(
                          &FileTime,
                          &LocalFileTime
                          );
            if(FALSE == fRetVal)
                BAIL_ON_FAILURE(hr = HRESULT_FROM_WIN32(GetLastError()));

            fRetVal = FileTimeToSystemTime(
                          &LocalFileTime,
                          &LocalTime
                          );

            if(FALSE == fRetVal)
                BAIL_ON_FAILURE(hr = HRESULT_FROM_WIN32(GetLastError()));

        }
   
        *((SYSTEMTIME *)pSysTimeArray + i) = LocalTime;
    }

    if(pPropArray != NULL)
        pPropArray->pUmiValue = (UMI_VALUE *) pSysTimeArray;

    RRETURN(hr);

error:

    if( (pSysTimeArray != NULL) && (NULL == pExistingMem) )
        FreeADsMem(pSysTimeArray);

    RRETURN(hr);
}

//----------------------------------------------------------------------------
// Function:   WinNTTypeToUmiBools
//
// Synopsis:   Converts from NT object to UMI_PROPERTY structure containing
//             a boolean
//
// Arguments:
//
// pNtObject     Pointer to NT object
// dwNumValues   Number of values in pNtObject
// pPropArray    Pointer to UMI_PROPERTY that returns the converted values
// pExistingMem  If non-NULL, the provider does not allocate memory. Instead,
//               the memory pointed to by this argument is used.
// dwMemSize     Number of bytes of memory pointed to by pExistingMem
//
// Returns:      UMI_S_NO_ERROR on success. Error code otherwise.
//
// Modifies:     *pExistingMem if pExistingMem is non-NULL
//               *pPropArray otherwise
//
//----------------------------------------------------------------------------
HRESULT WinNTTypeToUmiBools(
    LPNTOBJECT pNtObject,
    DWORD dwNumValues,
    UMI_PROPERTY *pPropArray,
    LPVOID pExistingMem,
    DWORD dwMemSize
    )
{
    DWORD   dwMemRequired = 0, i = 0;
    void    *pBoolArray = NULL;
    HRESULT hr = UMI_S_NO_ERROR;

    // Check if the NT type can be converted to the requested UMI type
    if(pNtObject->NTType != NT_SYNTAX_ID_BOOL)
        BAIL_ON_FAILURE(hr = UMI_E_CANT_CONVERT_DATA); 

    dwMemRequired = dwNumValues * sizeof(BOOL);

    if(NULL == pExistingMem) {
    // provider has to allocate memory
        pBoolArray = (void *) AllocADsMem(dwMemRequired);
        if(NULL == pBoolArray)
            BAIL_ON_FAILURE(UMI_E_OUT_OF_MEMORY);
    }
    else {
    // user provided memory to return data
        if(dwMemSize < dwMemRequired)
            BAIL_ON_FAILURE(hr = UMI_E_INSUFFICIENT_MEMORY);

        pBoolArray = pExistingMem;
    }

    for(i = 0; i < dwNumValues; i++) {
        if(pNtObject[i].NTValue.fValue)
            *((BOOL *)pBoolArray + i) = TRUE;
        else
            *((BOOL *)pBoolArray + i) = FALSE;
    }
     
    if(pPropArray != NULL)
        pPropArray->pUmiValue = (UMI_VALUE *) pBoolArray;

    RRETURN(hr);

error:

    if( (pBoolArray != NULL) && (NULL == pExistingMem) )
        FreeADsMem(pBoolArray);

    RRETURN(hr);
}
    
//----------------------------------------------------------------------------
// Function:   WinNTTypeToUmiLPWSTRs
//
// Synopsis:   Converts from NT object to UMI_PROPERTY structure containing
//             a string 
//
// Arguments:
//
// pNtObject     Pointer to NT object
// dwNumValues   Number of values in pNtObject
// pPropArray    Pointer to UMI_PROPERTY that returns the converted values
// pExistingMem  If non-NULL, the provider does not allocate memory. Instead,
//               the memory pointed to by this argument is used.
// dwMemSize     Number of bytes of memory pointed to by pExistingMem
//
// Returns:      UMI_S_NO_ERROR on success. Error code otherwise.
//
// Modifies:     *pExistingMem if pExistingMem is non-NULL
//               *pPropArray otherwise
//
//----------------------------------------------------------------------------
HRESULT WinNTTypeToUmiLPWSTRs(
    LPNTOBJECT pNtObject,
    DWORD dwNumValues,
    UMI_PROPERTY *pPropArray,
    LPVOID pExistingMem,
    DWORD dwMemSize
    )
{
    DWORD   dwMemRequired = 0, i = 0;
    void    *pStrArray = NULL;
    HRESULT hr = UMI_S_NO_ERROR;
    LPWSTR  pszTmpStr = NULL;
    UCHAR   Seed = UMI_ENCODE_SEED3;
    UNICODE_STRING Password;

    // Check if the NT type can be converted to the requested UMI type
    if( (pNtObject->NTType != NT_SYNTAX_ID_LPTSTR) &&
        (pNtObject->NTType != NT_SYNTAX_ID_DelimitedString) &&
        (pNtObject->NTType != NT_SYNTAX_ID_NulledString) &&
        (pNtObject->NTType != NT_SYNTAX_ID_EncryptedString) )
        BAIL_ON_FAILURE(hr = UMI_E_CANT_CONVERT_DATA); 

    dwMemRequired = dwNumValues * sizeof(LPWSTR);

    if(NULL == pExistingMem) {
    // provider has to allocate memory
        pStrArray = (void *) AllocADsMem(dwMemRequired);
        if(NULL == pStrArray)
            BAIL_ON_FAILURE(UMI_E_OUT_OF_MEMORY);
    }
    else {
    // user provided memory to return data. GetAs() will call this function
    // only if the property is single-valued. Copy the string into the
    // memory supplied y the caller.
    //
        ADsAssert(1 == dwNumValues);
        dwMemRequired = (wcslen(pNtObject->NTValue.pszValue) + 1) * 
                                                             sizeof(WCHAR);
        if(dwMemSize < dwMemRequired)
            BAIL_ON_FAILURE(hr = UMI_E_INSUFFICIENT_MEMORY);

        wcscpy((WCHAR *) pExistingMem, pNtObject->NTValue.pszValue);

        if(NT_SYNTAX_ID_EncryptedString == pNtObject->NTType) {
        // decrypt the string (typically password)

            RtlInitUnicodeString(&Password, (WCHAR *) pExistingMem);
            RtlRunDecodeUnicodeString(Seed, &Password);
        }

        RRETURN(UMI_S_NO_ERROR);
    }

    memset(pStrArray, 0, dwMemRequired);

    for(i = 0; i < dwNumValues; i++) {
        if(pNtObject[i].NTValue.pszValue != NULL) {
            pszTmpStr = AllocADsStr(pNtObject[i].NTValue.pszValue); 
            if(NULL == pszTmpStr)
                BAIL_ON_FAILURE(hr = UMI_E_OUT_OF_MEMORY);
        
            if(NT_SYNTAX_ID_EncryptedString == pNtObject->NTType) {
            // decrypt the string (typically password)
 
                RtlInitUnicodeString(&Password, pszTmpStr);
                RtlRunDecodeUnicodeString(Seed, &Password);
            }
        }

        *((LPWSTR *)pStrArray + i) = pszTmpStr;
    }
     
    if(pPropArray != NULL)
        pPropArray->pUmiValue = (UMI_VALUE *) pStrArray;

    RRETURN(hr);

error:

    if(pStrArray != NULL) {
        // free any strings allocated
        for(i = 0; i < dwNumValues; i++)
            if(((LPWSTR *) pStrArray)[i] != NULL)
                FreeADsStr(((LPWSTR *) pStrArray)[i]);

        if(NULL == pExistingMem)
        // provider allocated memory
            FreeADsMem(pStrArray);
    }

    RRETURN(hr);
}

//----------------------------------------------------------------------------
// Function:   WinNTTypeToUmiOctetStrings
//
// Synopsis:   Converts from NT object to UMI_PROPERTY structure containing
//             an octet string 
//
// Arguments:
//
// pNtObject     Pointer to NT object
// dwNumValues   Number of values in pNtObject
// pPropArray    Pointer to UMI_PROPERTY that returns the converted values
// pExistingMem  If non-NULL, the provider does not allocate memory. Instead,
//               the memory pointed to by this argument is used.
// dwMemSize     Number of bytes of memory pointed to by pExistingMem
//
// Returns:      UMI_S_NO_ERROR on success. Error code otherwise.
//
// Modifies:     *pExistingMem if pExistingMem is non-NULL
//               *pPropArray otherwise
//
//----------------------------------------------------------------------------
HRESULT WinNTTypeToUmiOctetStrings(
    LPNTOBJECT pNtObject,
    DWORD dwNumValues,
    UMI_PROPERTY *pPropArray,
    LPVOID pExistingMem,
    DWORD dwMemSize
    )
{
    DWORD   dwMemRequired = 0, i = 0;
    void    *pOctetStrArray = NULL;
    HRESULT hr = UMI_S_NO_ERROR;
    LPWSTR  pTmpOctetStr = NULL;

    // Check if the NT type can be converted to the requested UMI type
    if(pNtObject->NTType != NT_SYNTAX_ID_OCTETSTRING) 
        BAIL_ON_FAILURE(hr = UMI_E_CANT_CONVERT_DATA); 

    dwMemRequired = dwNumValues * sizeof(UMI_OCTET_STRING);

    if(NULL == pExistingMem) {
    // provider has to allocate memory
        pOctetStrArray = (void *) AllocADsMem(dwMemRequired);
        if(NULL == pOctetStrArray)
            BAIL_ON_FAILURE(UMI_E_OUT_OF_MEMORY);
    }
    else {
    // user provided memory to return data
        if(dwMemSize < dwMemRequired)
            BAIL_ON_FAILURE(hr = UMI_E_INSUFFICIENT_MEMORY);

        pOctetStrArray = pExistingMem;
    }

    memset(pOctetStrArray, 0, dwMemRequired);

    for(i = 0; i < dwNumValues; i++) {
        pTmpOctetStr = (LPWSTR) 
                         AllocADsMem(pNtObject[i].NTValue.octetstring.dwSize); 
        if(NULL == pTmpOctetStr)
            BAIL_ON_FAILURE(hr = UMI_E_OUT_OF_MEMORY);
        
        memcpy(
           pTmpOctetStr, 
           pNtObject[i].NTValue.octetstring.pByte,
           pNtObject[i].NTValue.octetstring.dwSize
           );
 
        ((UMI_OCTET_STRING *)pOctetStrArray + i)->uLength =
                            pNtObject[i].NTValue.octetstring.dwSize;
        ((UMI_OCTET_STRING *)pOctetStrArray + i)->lpValue = 
                            (BYTE *) pTmpOctetStr;
    }
     
    if(pPropArray != NULL)
        pPropArray->pUmiValue = (UMI_VALUE *) pOctetStrArray;

    RRETURN(hr);

error:

    if(pOctetStrArray != NULL) {
        // free any strings allocated
        for(i = 0; i < dwNumValues; i++)
            if(((UMI_OCTET_STRING *) pOctetStrArray)[i].lpValue != NULL)
                FreeADsMem(((UMI_OCTET_STRING *) pOctetStrArray)[i].lpValue);

        if(NULL == pExistingMem)
        // provider allocated memory
            FreeADsMem(pOctetStrArray);
    }

    RRETURN(hr);
}

//----------------------------------------------------------------------------
// Function:   WinNTTypeToUmi
//
// Synopsis:   Converts from NT object to UMI_PROPERTY structure.
//
// Arguments:
//
// pNtObject     Pointer to NT object
// dwNumValues   Number of values in pNtObject
// pPropArray    Pointer to UMI_PROPERTY that returns the converted values
// pExistingMem  If non-NULL, the provider does not allocate memory. Instead,
//               the memory pointed to by this argument is used.
// dwMemSize     Number of bytes of memory pointed to by pExistingMem
// UmiType       UMI type to convert the NT object to
//
// Returns:      UMI_S_NO_ERROR on success. Error code otherwise.
//
// Modifies:     *pExistingMem if pExistingMem is non-NULL
//               *pPropArray otherwise
//
//----------------------------------------------------------------------------
HRESULT WinNTTypeToUmi(
    LPNTOBJECT pNtObject,
    DWORD dwNumValues,
    UMI_PROPERTY *pPropArray,
    LPVOID pExistingMem,
    DWORD dwMemSize,
    UMI_TYPE UmiType
    )
{
    HRESULT hr = UMI_S_NO_ERROR;

    ADsAssert( (pNtObject != NULL) &&
              ((pPropArray != NULL) || (pExistingMem != NULL)) );
    // only one of pPropArray and pExistingMem can be non-NULL
    ADsAssert( (NULL == pPropArray) || (NULL == pExistingMem) );

    // Enclose code in try/except to catch AVs caused by the user passing in
    // a bad pointer in pExistingMem
    __try {

    switch(UmiType) {

        case UMI_TYPE_NULL:
            BAIL_ON_FAILURE(hr = UMI_E_CANT_CONVERT_DATA);

        case UMI_TYPE_I1:
        case UMI_TYPE_I2:
        case UMI_TYPE_I4:
        case UMI_TYPE_I8:
        case UMI_TYPE_UI1:
        case UMI_TYPE_UI2:
        case UMI_TYPE_UI4:
        case UMI_TYPE_UI8:
            hr = WinNTTypeToUmiIntegers(
                   pNtObject,
                   dwNumValues,
                   pPropArray,
                   pExistingMem,
                   dwMemSize,
                   UmiType
                   );
            break;

        case UMI_TYPE_R4:
        case UMI_TYPE_R8:
            BAIL_ON_FAILURE(hr = UMI_E_CANT_CONVERT_DATA);

        case UMI_TYPE_FILETIME:
            hr = WinNTTypeToUmiFileTimes(
                   pNtObject,
                   dwNumValues,
                   pPropArray,
                   pExistingMem,
                   dwMemSize
                   );
            break;

        case UMI_TYPE_SYSTEMTIME:
            hr = WinNTTypeToUmiSystemTimes(
                   pNtObject,
                   dwNumValues,
                   pPropArray,
                   pExistingMem,
                   dwMemSize
                   );
            break;

        case UMI_TYPE_BOOL:
            hr = WinNTTypeToUmiBools(
                   pNtObject,
                   dwNumValues,
                   pPropArray,
                   pExistingMem,
                   dwMemSize
                   );
            break;

        case UMI_TYPE_IDISPATCH:
        case UMI_TYPE_IUNKNOWN:
        case UMI_TYPE_VARIANT: // TODO later
            BAIL_ON_FAILURE(hr = UMI_E_CANT_CONVERT_DATA);

        case UMI_TYPE_LPWSTR:
            hr = WinNTTypeToUmiLPWSTRs(
                   pNtObject,
                   dwNumValues,
                   pPropArray,
                   pExistingMem,
                   dwMemSize
                   );
            break;

        case UMI_TYPE_OCTETSTRING:
            hr = WinNTTypeToUmiOctetStrings(
                   pNtObject,
                   dwNumValues,
                   pPropArray,
                   pExistingMem,
                   dwMemSize
                   );
            break;

        case UMI_TYPE_UMIARRAY:
        case UMI_TYPE_DISCOVERY:
        case UMI_TYPE_UNDEFINED:
        case UMI_TYPE_DEFAULT:
            BAIL_ON_FAILURE(hr = UMI_E_CANT_CONVERT_DATA);

        default:
            BAIL_ON_FAILURE(hr = UMI_E_CANT_CONVERT_DATA);
    } // switch

    } __except( EXCEPTION_EXECUTE_HANDLER ) {
        if(pExistingMem != NULL) {
        // assume this is the cause of the exception
            BAIL_ON_FAILURE(hr = UMI_E_INTERNAL_EXCEPTION);
        }
        else
        // don't mask bugs in provider
            throw;
    }

    if(pPropArray != NULL) {
        pPropArray->uType = UmiType;
        pPropArray->uCount = dwNumValues;
    }

error:    

    RRETURN(hr);

}
=== C:/Users/treeman/Desktop/windows nt source code\Source\Win2K3\NT\ds\adsi\winnt\ntcopy.cxx ===
//+---------------------------------------------------------------------------
//
//  Microsoft Windows
//  Copyright (C) Microsoft Corporation, 1992 - 1995.
//
//  File:       ntcopy.cxx
//
//  Contents:   NT Object Copy Routines
//
//  Functions:
//
//  History:      17-June-96   RamV   Created.
//                cloned off NDS copy code.
//
//
//  Issues:     Check null ptrs for AllocADsMem and AllocADsStr
//
//
//
//----------------------------------------------------------------------------

//
// NtType objects copy code
//

#include "winnt.hxx"
#pragma  hdrstop
#define INITGUID


HRESULT
NtTypeCopy(
    PNTOBJECT lpNtSrcObject,
    PNTOBJECT lpNtDestObject
    )
{
    HRESULT hr = S_OK;
    switch (lpNtSrcObject->NTType) {

    case NT_SYNTAX_ID_BOOL:

        lpNtDestObject->NTType =  NT_SYNTAX_ID_BOOL;
        (lpNtDestObject->NTValue).fValue =  (lpNtSrcObject->NTValue).fValue;
        break;

    case NT_SYNTAX_ID_SYSTEMTIME:

        lpNtDestObject->NTType =  NT_SYNTAX_ID_SYSTEMTIME;
        (lpNtDestObject->NTValue).stSystemTimeValue =
            (lpNtSrcObject->NTValue).stSystemTimeValue;
        break;


    case NT_SYNTAX_ID_DATE_1970:

        lpNtDestObject->NTType =  NT_SYNTAX_ID_DATE_1970;
        (lpNtDestObject->NTValue).dwSeconds1970 =
            (lpNtSrcObject->NTValue).dwSeconds1970;
        break;



    case NT_SYNTAX_ID_DWORD:

        lpNtDestObject->NTType =  NT_SYNTAX_ID_DWORD;
        (lpNtDestObject->NTValue).dwValue =
            (lpNtSrcObject->NTValue).dwValue;
        break;

    case NT_SYNTAX_ID_DATE:

        lpNtDestObject->NTType =  NT_SYNTAX_ID_DATE;
        (lpNtDestObject->NTValue).dwValue =
            (lpNtSrcObject->NTValue).dwValue;
        break;

    case NT_SYNTAX_ID_LPTSTR:

        lpNtDestObject->NTType =  NT_SYNTAX_ID_LPTSTR;

        if(!(lpNtSrcObject->NTValue).pszValue){
            (lpNtDestObject->NTValue).pszValue = NULL;
            hr = S_OK;
            goto error;
        }

        (lpNtDestObject->NTValue).pszValue =
            AllocADsStr((lpNtSrcObject->NTValue).pszValue);

        hr =((lpNtDestObject->NTValue).pszValue == NULL)
            ? E_OUTOFMEMORY :S_OK;

        break;

    case NT_SYNTAX_ID_DelimitedString:

        lpNtDestObject->NTType =  NT_SYNTAX_ID_DelimitedString;

        if(!(lpNtSrcObject->NTValue).pszValue){
            (lpNtDestObject->NTValue).pszValue = NULL;
            hr = S_OK;
            goto error;
        }

        (lpNtDestObject->NTValue).pszValue =
            AllocADsStr((lpNtSrcObject->NTValue).pszValue);

        hr =((lpNtDestObject->NTValue).pszValue == NULL)
            ? E_OUTOFMEMORY :S_OK;

        break;

    case NT_SYNTAX_ID_NulledString:

        lpNtDestObject->NTType =  NT_SYNTAX_ID_NulledString;

        if(!(lpNtSrcObject->NTValue).pszValue){
            (lpNtDestObject->NTValue).pszValue = NULL;
            hr = S_OK;
            goto error;
        }



        (lpNtDestObject->NTValue).pszValue =
            AllocADsStr((lpNtSrcObject->NTValue).pszValue);

        hr =((lpNtDestObject->NTValue).pszValue == NULL)
            ? E_OUTOFMEMORY :S_OK;

        break;

    case NT_SYNTAX_ID_EncryptedString:

        lpNtDestObject->NTType =  NT_SYNTAX_ID_EncryptedString;

        if(!(lpNtSrcObject->NTValue).pszValue){
            (lpNtDestObject->NTValue).pszValue = NULL;
            hr = S_OK;
            goto error;
        }

        (lpNtDestObject->NTValue).pszValue =
            AllocADsStr((lpNtSrcObject->NTValue).pszValue);

        hr =((lpNtDestObject->NTValue).pszValue == NULL)
            ? E_OUTOFMEMORY :S_OK;

        break;

    case NT_SYNTAX_ID_OCTETSTRING:

        lpNtDestObject->NTType =  NT_SYNTAX_ID_OCTETSTRING;
        (lpNtDestObject->NTValue).octetstring.dwSize = 
                        (lpNtSrcObject->NTValue).octetstring.dwSize;
                if ((lpNtSrcObject->NTValue).octetstring.dwSize == 0) {
                        (lpNtDestObject->NTValue).octetstring.pByte = NULL;
                }
                else {
                        (lpNtDestObject->NTValue).octetstring.pByte = 
                                        (BYTE*)AllocADsMem(sizeof(BYTE)*(lpNtSrcObject->NTValue).octetstring.dwSize);
                        if (!(lpNtDestObject->NTValue).octetstring.pByte) {
                                RRETURN(E_OUTOFMEMORY);
                        }
                        memcpy((lpNtDestObject->NTValue).octetstring.pByte, 
                                   (lpNtSrcObject->NTValue).octetstring.pByte,
                                   (lpNtSrcObject->NTValue).octetstring.dwSize);
                }

        break;

    default:
        hr = E_FAIL;
        break;
    }

error:

    RRETURN(hr);
}



HRESULT
NtTypeCopyConstruct(
    LPNTOBJECT pNtSrcObjects,
    DWORD dwNumObjects,
    LPNTOBJECT * ppNtDestObjects
    )
{

    DWORD i = 0;
    LPNTOBJECT pNtDestObjects = NULL;
    HRESULT hr = S_OK;

    pNtDestObjects = (LPNTOBJECT)AllocADsMem(
                                    dwNumObjects * sizeof(NTOBJECT)
                                    );

    if (!pNtDestObjects) {
        RRETURN(E_FAIL);
    }

    //
    // Zero out so we can clear the memory on an error
    //

    memset(pNtDestObjects, 0, dwNumObjects * sizeof(NTOBJECT));

    for (i = 0; i < dwNumObjects; i++ ) {
        hr = NtTypeCopy(pNtSrcObjects + i, pNtDestObjects + i);
        BAIL_ON_FAILURE(hr);
    }

    *ppNtDestObjects = pNtDestObjects;
    
    RRETURN(S_OK);

error:

    NTTypeFreeNTObjects(pNtDestObjects, dwNumObjects);
    RRETURN(hr);
}
=== C:/Users/treeman/Desktop/windows nt source code\Source\Win2K3\NT\ds\adsi\winnt\nt2var.cxx ===
//+---------------------------------------------------------------------------
//
//  Microsoft Windows
//  Copyright (C) Microsoft Corporation, 1992 - 1995.
//
//  File:       winnt2var.cxx
//
//  Contents:   WinNT Object to Variant Copy Routines
//
//  Functions:
//
//  History:      06/12/96   RamV   Created.
//                cloned off NDS conversion code.
//
//  Issues:     Check null ptrs for AllocADsMem and AllocADsStr
//
//----------------------------------------------------------------------------

//
// NTType objects copy code
//

#include "winnt.hxx"
#pragma  hdrstop
#define INITGUID

void
VarTypeFreeVarObjects(
    PVARIANT pVarObject,
    DWORD dwNumValues
    )
{
    DWORD i = 0;

    if( !pVarObject){
        return;
    }

    for (i = 0; i < dwNumValues; i++ ) {
         VariantClear(pVarObject + i);
    }

    FreeADsMem(pVarObject);

    return;
}

HRESULT
NTTypeToVarTypeCopyOctetString(
    PNTOBJECT     pNTSrcValue,
    PVARIANT lpVarDestObject
    )
{
    HRESULT hr = S_OK;

    if(!lpVarDestObject){
        RRETURN(E_POINTER);
    }

    hr = BinaryToVariant(
                (pNTSrcValue->NTValue).octetstring.dwSize,
                (pNTSrcValue->NTValue).octetstring.pByte,
                lpVarDestObject
    );

    RRETURN(hr);
}

HRESULT
NTTypeToVarTypeCopyBOOL(
    PNTOBJECT     pNTSrcValue,
    PVARIANT lpVarDestObject
    )
{
    HRESULT hr = S_OK;

    if(!lpVarDestObject){
        RRETURN(E_POINTER);
    }

    if(!pNTSrcValue){
        RRETURN(E_POINTER);
    }

    lpVarDestObject->vt = VT_BOOL;

    if((pNTSrcValue->NTValue).fValue){
        lpVarDestObject->boolVal = VARIANT_TRUE;  // notation for TRUE in V_BOOL
    } else {
        lpVarDestObject->boolVal = VARIANT_FALSE;
    }

    RRETURN(hr);
}

HRESULT
NTTypeToVarTypeCopySYSTEMTIME(
    PNTOBJECT     pNTSrcValue,
    PVARIANT lpVarDestObject
    )
{
    HRESULT hr;

    if(!pNTSrcValue){
        RRETURN(E_POINTER);
    }

    if(!lpVarDestObject){
        RRETURN(E_POINTER);
    }

   lpVarDestObject->vt = VT_DATE;

    hr = ConvertSystemTimeToDATE (pNTSrcValue->NTValue.stSystemTimeValue,
                                  &lpVarDestObject->date );


    RRETURN(hr);
}

HRESULT
NTTypeToVarTypeCopyDWORD(
    PNTOBJECT     pNTSrcValue,
    PVARIANT lpVarDestObject
    )
{
    //
    // we cast the DWORD  to a LONG
    //

    HRESULT hr = S_OK;

    if(!lpVarDestObject){
        RRETURN(E_POINTER);
    }

    if(!pNTSrcValue){
        RRETURN(E_POINTER);
    }

    lpVarDestObject->vt = VT_I4;

    lpVarDestObject->lVal = (LONG)(pNTSrcValue->NTValue).dwValue;

    RRETURN(hr);
}

HRESULT
NTTypeToVarTypeCopyDATE70(
    PNTOBJECT     pNTSrcValue,
    PVARIANT lpVarDestObject
    )
{
    //
    // we cast the DWORD  to a LONG
    //

    HRESULT hr = S_OK;

    if(!lpVarDestObject){
        RRETURN(E_POINTER);
    }

    if(!pNTSrcValue){
        RRETURN(E_POINTER);
    }

    lpVarDestObject->vt = VT_DATE;

    hr = ConvertDWORDtoDATE(
                (pNTSrcValue->NTValue).dwSeconds1970,
                &(lpVarDestObject->date)
                );

    RRETURN(hr);
}


HRESULT
NTTypeToVarTypeCopyDATE(
    PNTOBJECT     pNTSrcValue,
    PVARIANT lpVarDestObject
    )
{

    HRESULT hr = S_OK;
    SYSTEMTIME stSystemTime;
    SYSTEMTIME LocalTime;
    DATE    date;
    BOOL       fRetval;

    GetSystemTime( &stSystemTime);

    fRetval = SystemTimeToTzSpecificLocalTime(
                  NULL,
                  &stSystemTime,
                  &LocalTime
                  );
    if(!fRetval){
      RRETURN(HRESULT_FROM_WIN32(GetLastError()));
    }

    stSystemTime.wHour = (WORD)(pNTSrcValue->NTValue.dwValue)/60;
    stSystemTime.wMinute = (WORD)(pNTSrcValue->NTValue.dwValue)%60;
    stSystemTime.wSecond =0;
    stSystemTime.wMilliseconds = 0;

    if(!lpVarDestObject){
        RRETURN(E_POINTER);
    }

    if(!pNTSrcValue){
        RRETURN(E_POINTER);
    }

    lpVarDestObject->vt = VT_DATE;

    hr = ConvertSystemTimeToDATE (stSystemTime,
                                  &date );
    BAIL_ON_FAILURE(hr);

    // We are casting date to DWORD and then subtracting it from date, which is double,
    // so that we only keep hours and minutes related info from the source DATE
    lpVarDestObject->date = date - (DWORD)date;


error:

    RRETURN(hr);
}

HRESULT
NTTypeToVarTypeCopyLPTSTR(
    PNTOBJECT     pNTSrcValue,
    PVARIANT lpVarDestObject
    )
{
    HRESULT hr = S_OK;

    if(!lpVarDestObject){
        RRETURN(E_POINTER);
    }

    lpVarDestObject->vt = VT_BSTR;

    if(!(pNTSrcValue->NTValue).pszValue){
        lpVarDestObject->bstrVal = NULL;
        hr = S_OK;
        goto error;
    }


    if(!pNTSrcValue){
        lpVarDestObject->bstrVal = NULL;
    } else {
        hr =  ADsAllocString((pNTSrcValue->NTValue).pszValue,
                               &(lpVarDestObject->bstrVal));
    }

error:
    RRETURN(hr);
}


HRESULT
NtTypeToVarTypeCopy(
    PNTOBJECT lpNtSrcObject,
    PVARIANT lpVarDestObject
    )
{
    HRESULT hr = S_OK;
    switch (lpNtSrcObject->NTType) {
    case NT_SYNTAX_ID_BOOL:
        hr = NTTypeToVarTypeCopyBOOL(
                lpNtSrcObject,
                lpVarDestObject
                );
        break;

    case NT_SYNTAX_ID_SYSTEMTIME:
        hr = NTTypeToVarTypeCopySYSTEMTIME(
                lpNtSrcObject,
                lpVarDestObject
                );
        break;


    case NT_SYNTAX_ID_DWORD:
        hr = NTTypeToVarTypeCopyDWORD(
                lpNtSrcObject,
                lpVarDestObject
                );
        break;

    case NT_SYNTAX_ID_DATE:
        hr = NTTypeToVarTypeCopyDATE(
                lpNtSrcObject,
                lpVarDestObject
                );
        break;

    case NT_SYNTAX_ID_LPTSTR:
        hr = NTTypeToVarTypeCopyLPTSTR(
                lpNtSrcObject,
                lpVarDestObject
                );
        break;

    case NT_SYNTAX_ID_DelimitedString:

        hr = NTTypeToVarTypeCopyLPTSTR(
                lpNtSrcObject,
                lpVarDestObject
                );
        break;

    case NT_SYNTAX_ID_NulledString :
        hr = NTTypeToVarTypeCopyLPTSTR(
                lpNtSrcObject,
                lpVarDestObject
                );

        break;


    case NT_SYNTAX_ID_DATE_1970:
        hr = NTTypeToVarTypeCopyDATE70(
                lpNtSrcObject,
                lpVarDestObject
                );
        break;
    case NT_SYNTAX_ID_OCTETSTRING :
        hr = NTTypeToVarTypeCopyOctetString(
                lpNtSrcObject,
                lpVarDestObject
                );
        break;

    default:
        hr = E_FAIL;
        break;
    }

    RRETURN(hr);
}



HRESULT
NtTypeToVarTypeCopyConstruct(
    LPNTOBJECT pNtSrcObjects,
    DWORD dwNumObjects,
    PVARIANT pVarDestObjects
    )
{

    long i = 0;
    HRESULT hr = S_OK;

    VariantInit( pVarDestObjects );

    //
    // The following are for handling are multi-value properties
    //

    SAFEARRAY *aList = NULL;
    SAFEARRAYBOUND aBound;

    aBound.lLbound = 0;
    aBound.cElements = dwNumObjects;

    aList = SafeArrayCreate( VT_VARIANT, 1, &aBound );

    if ( aList == NULL )
    {
        hr = E_OUTOFMEMORY;
        BAIL_ON_FAILURE(hr);
    }

    for ( i = 0; i < (long) dwNumObjects; i++ )
    {
        VARIANT v;

        VariantInit(&v);
        hr = NtTypeToVarTypeCopy( pNtSrcObjects + i,
                                  &v );
        BAIL_ON_FAILURE(hr);

        hr = SafeArrayPutElement( aList, &i, &v );
        VariantClear(&v);
        BAIL_ON_FAILURE(hr);
    }

    V_VT(pVarDestObjects) = VT_ARRAY | VT_VARIANT;
    V_ARRAY(pVarDestObjects) = aList;

    RRETURN(S_OK);

error:

    if ( aList )
        SafeArrayDestroy( aList );

    RRETURN(hr);
}
=== C:/Users/treeman/Desktop/windows nt source code\Source\Win2K3\NT\ds\adsi\winnt\ntmrshl.cxx ===
//-------------------------------------------------------------------------------
//
//  Microsoft Windows
//  Copyright (C) Microsoft Corporation, 1992 - 1995.
//
//  File:       ntmrshl.cxx
//
//  Contents:
//
//  Functions:
//
//  History:      17-June-1996   RamV   Created.
//
//----------------------------------------------------------------------------

#include "winnt.hxx"
#pragma  hdrstop
#define INITGUID

HRESULT
CopyNTOBJECTToOctet(
    PNTOBJECT pNtSrcObject,
    OctetString *pOctet
    )
{
    if(!pNtSrcObject){
        RRETURN(E_POINTER);
    }

    if(!(pNtSrcObject->NTType == NT_SYNTAX_ID_OCTETSTRING)){
        RRETURN(E_ADS_CANT_CONVERT_DATATYPE);
    }

    pOctet->dwSize = (pNtSrcObject->NTValue).octetstring.dwSize;
    pOctet->pByte = (BYTE*)AllocADsMem(sizeof(BYTE) * (pNtSrcObject->NTValue).octetstring.dwSize);
    if (!pOctet->pByte) {
        RRETURN(E_OUTOFMEMORY);
    }
    memcpy(pOctet->pByte, 
           (pNtSrcObject->NTValue).octetstring.pByte, 
           (pNtSrcObject->NTValue).octetstring.dwSize);
    RRETURN(S_OK);

}

HRESULT
CopyNTOBJECTToDWORD(
    PNTOBJECT pNtSrcObject,
    PDWORD   pdwRetval
    )

{
    if(!pNtSrcObject){
        RRETURN(E_POINTER);
    }
    if(!(pNtSrcObject->NTType == NT_SYNTAX_ID_DWORD)){
        RRETURN(E_ADS_CANT_CONVERT_DATATYPE);
    }

    *pdwRetval = (pNtSrcObject->NTValue).dwValue;

    RRETURN(S_OK);

}

HRESULT
CopyNTOBJECTToDATE(
    PNTOBJECT pNtSrcObject,
    PDWORD   pdwRetval
    )

{
    if(!pNtSrcObject){
        RRETURN(E_POINTER);
    }
    if(!(pNtSrcObject->NTType == NT_SYNTAX_ID_DATE)){
        RRETURN(E_ADS_CANT_CONVERT_DATATYPE);
    }

    *pdwRetval = (pNtSrcObject->NTValue).dwValue;

    RRETURN(S_OK);

}

HRESULT
CopyNTOBJECTToDATE70(
    PNTOBJECT pNtSrcObject,
    PDWORD   pdwRetval
    )

{
    if(!pNtSrcObject){
        RRETURN(E_POINTER);
    }
    if(!(pNtSrcObject->NTType == NT_SYNTAX_ID_DATE_1970)){
        RRETURN(E_ADS_CANT_CONVERT_DATATYPE);
    }

    *pdwRetval = (pNtSrcObject->NTValue).dwSeconds1970;

    RRETURN(S_OK);

}


HRESULT
CopyNTOBJECTToBOOL(
    PNTOBJECT pNtSrcObject,
    PBOOL   pfRetval
    )

{
    if(!pNtSrcObject){
        RRETURN(E_POINTER);
    }

    if(!(pNtSrcObject->NTType == NT_SYNTAX_ID_BOOL)){
        RRETURN(E_ADS_CANT_CONVERT_DATATYPE);
    }

    *pfRetval = (pNtSrcObject->NTValue).fValue;

    RRETURN(S_OK);

}


HRESULT
CopyNTOBJECTToSYSTEMTIME(
    PNTOBJECT pNtSrcObject,
    SYSTEMTIME *pstRetVal
    )

{
    if(!pNtSrcObject){
        RRETURN(E_POINTER);
    }

    if(!(pNtSrcObject->NTType == NT_SYNTAX_ID_SYSTEMTIME)){
        RRETURN(E_ADS_CANT_CONVERT_DATATYPE);
    }

    *pstRetVal = (pNtSrcObject->NTValue).stSystemTimeValue;

    RRETURN(S_OK);

}

HRESULT
CopyNTOBJECTToLPTSTR(
    PNTOBJECT pNtSrcObject,
    LPTSTR  *ppszRetval
    )
{
    if(!pNtSrcObject){
        RRETURN(E_POINTER);
    }

    if(!(pNtSrcObject->NTType == NT_SYNTAX_ID_LPTSTR)){
        RRETURN(E_ADS_CANT_CONVERT_DATATYPE);
    }

    *ppszRetval = AllocADsStr((pNtSrcObject->NTValue).pszValue);

    if (! *ppszRetval && ((pNtSrcObject->NTValue).pszValue)){
        RRETURN(E_OUTOFMEMORY);
    }
    RRETURN(S_OK);

}

HRESULT
CopyNTOBJECTToDelimitedString(
    PNTOBJECT pNtSrcObject,
    DWORD   dwNumValues,
    LPTSTR  *ppszRetval
    )
{

    DWORD i= 0;
    HRESULT hr = S_OK;
    WCHAR szDelimStr[MAX_PATH];
    DWORD dwLength = 0;
    LPWSTR Delimiter = TEXT(",");

    if (!dwNumValues){
        *ppszRetval = NULL;
        RRETURN(S_OK);
    }

    wcscpy(szDelimStr, TEXT("")); // empty contents

    if(!pNtSrcObject){
        hr = E_POINTER;
        goto error;
    }

    if(!(pNtSrcObject->NTType == NT_SYNTAX_ID_DelimitedString)){
        hr = E_ADS_CANT_CONVERT_DATATYPE;
        goto error;
    }

    for(i=0; i<dwNumValues; i++){
        //
        // Make sure that the strings we are copying in fit into the buffer.
        //
        if ((dwLength += ((i==0)?0:1) + wcslen(pNtSrcObject[i].NTValue.pszValue)) < MAX_PATH)
        {
            if(i>0){
                wcscat(szDelimStr, Delimiter);
            }
            wcscat(szDelimStr, pNtSrcObject[i].NTValue.pszValue);
        }
        else
        {
          hr = E_ADS_BAD_PARAMETER;
          goto error;
        }
    }

    
    *ppszRetval = AllocADsStr(szDelimStr);

    if(*ppszRetval == NULL){
        hr = E_OUTOFMEMORY;
        goto error;
    }

error:
    RRETURN(hr);
}

HRESULT
CopyNTOBJECTToNulledString(
    PNTOBJECT pNtSrcObject,
    DWORD   dwNumValues,
    LPTSTR  *ppszRetval
    )
{

    DWORD i= 0;
    HRESULT hr = S_OK;
    LPWSTR pszNullStr = 0;
    DWORD dwLength = 0;
    WORD   wStrLen = 0;

    if (!dwNumValues){
        *ppszRetval = NULL;
        RRETURN(S_OK);
    }

    pszNullStr = (LPWSTR)AllocADsMem(MAX_PATH * sizeof(WCHAR)); //max length of nulled string

    if(!pszNullStr){
        hr = E_OUTOFMEMORY;
        goto error;
    }

    wcscpy(pszNullStr, TEXT("")); // empty contents

    if(!pNtSrcObject){
        hr = E_POINTER;
        goto error;
    }

    if(!(pNtSrcObject->NTType == NT_SYNTAX_ID_NulledString)){
        hr = E_ADS_CANT_CONVERT_DATATYPE;
        goto error;
    }

    for(i=0; i<dwNumValues; i++){
        //
        // Make sure the strings we are copying will fit into the buffer.
        //
        UINT uiLength = wcslen(pNtSrcObject[i].NTValue.pszValue);
        if ((wStrLen + uiLength) < MAX_PATH) 
        {
            wcscpy(pszNullStr+wStrLen, pNtSrcObject[i].NTValue.pszValue);
            wStrLen += uiLength + 1;
        } 
        else 
        {
            hr = E_ADS_BAD_PARAMETER;
            goto error;
        }
    }

    wcscpy(pszNullStr + wStrLen, TEXT(""));
    
    *ppszRetval = pszNullStr;

error:
    if (FAILED(hr))
      FreeADsMem(pszNullStr);

    RRETURN(hr);
}




/* Delete after new implementation works fully 

HRESULT
CopyNTOBJECTToNulledString(
    PNTOBJECT pNtSrcObject,
    LPTSTR  *ppszRetval
    )
{
    HRESULT hr = S_OK;

    if(!pNtSrcObject){
        RRETURN(E_POINTER);
    }

    if(!(pNtSrcObject->NTType == NT_SYNTAX_ID_NulledString)){
        RRETURN(E_ADS_CANT_CONVERT_DATATYPE);
    }

    hr = CopyNulledString((pNtSrcObject->NTValue).pszValue,
                          ppszRetval );

    if ( FAILED (hr)){
        RRETURN(hr);
    }
    RRETURN(S_OK);
}


*/


HRESULT
CopyNTOBJECTToNT(
    DWORD dwSyntaxId,
    PNTOBJECT lpNTObject,
    LPBYTE lpByte
    )
{

    HRESULT hr = S_OK;

    switch (dwSyntaxId) {
    case NT_SYNTAX_ID_BOOL:
        hr = CopyNTOBJECTToBOOL(
                         lpNTObject,
                         (PBOOL)lpByte
                         );
        break;

    case NT_SYNTAX_ID_SYSTEMTIME:
        hr = CopyNTOBJECTToSYSTEMTIME(
                         lpNTObject,
                         (PSYSTEMTIME)lpByte
                         );
        break;

    case NT_SYNTAX_ID_DWORD:
        hr = CopyNTOBJECTToDWORD(
                         lpNTObject,
                         (PDWORD)lpByte
                         );
        break;

    case NT_SYNTAX_ID_DATE:
        hr = CopyNTOBJECTToDATE(
                         lpNTObject,
                         (PDWORD)lpByte
                         );
        break;


    case NT_SYNTAX_ID_DATE_1970:
        hr = CopyNTOBJECTToDATE70(
                         lpNTObject,
                         (PDWORD)lpByte
                         );
        break;

    case NT_SYNTAX_ID_LPTSTR:
        hr = CopyNTOBJECTToLPTSTR(
                         lpNTObject,
                         (LPTSTR *)lpByte
                         );
        break;

    case NT_SYNTAX_ID_OCTETSTRING:
        hr = CopyNTOBJECTToOctet(
                         lpNTObject,
                         (OctetString *)lpByte
                         );
        break;

    default:
        break;

    }

    RRETURN(hr);
}


HRESULT
MarshallNTSynIdToNT(
    DWORD dwSyntaxId,
    PNTOBJECT pNTObject,
    DWORD dwNumValues,
    LPBYTE lpValue
    )
{

    HRESULT hr = S_OK;
    DWORD  i = 0;

    //
    // Loop below does not really handle case other than 1 value
    //

    //
    // For handling multivalued cases, the loop is unnecessary
    //

    if(dwSyntaxId == NT_SYNTAX_ID_DelimitedString)  {
        hr = CopyNTOBJECTToDelimitedString (
                 pNTObject,
                 dwNumValues,
                 (LPWSTR *)lpValue
                 );

    } else if (dwSyntaxId == NT_SYNTAX_ID_NulledString) {
        hr = CopyNTOBJECTToNulledString(
                pNTObject,
                dwNumValues,
                (LPWSTR *) lpValue
                );

    } else {
        for (i = 0; i < dwNumValues; i++) {
            
            hr  = CopyNTOBJECTToNT(
                     dwSyntaxId,
                     (pNTObject + i) ,
                     lpValue
                     );

        }
    }

        RRETURN(hr);
}
=== C:/Users/treeman/Desktop/windows nt source code\Source\Win2K3\NT\ds\adsi\winnt\nttypes.h ===
//+---------------------------------------------------------------------------
//
//  Microsoft Windows
//  Copyright (C) Microsoft Corporation, 1992 - 1995.
//
//  File:       nttypes.h
//
//  Contents:    Types for generic Get and Put
//
//  Functions:
//
//
//  History:      14-June-1996   RamV   Cloned off nds code.
//
//----------------------------------------------------------------------------

//
// various values of NT types
//

#define NT_SYNTAX_ID_BOOL                     1
#define NT_SYNTAX_ID_SYSTEMTIME               2
#define NT_SYNTAX_ID_DWORD                    3
#define NT_SYNTAX_ID_LPTSTR                   4
#define NT_SYNTAX_ID_DelimitedString          5
#define NT_SYNTAX_ID_NulledString             6
#define NT_SYNTAX_ID_DATE                     7 // internally treated as DWORD
#define NT_SYNTAX_ID_DATE_1970                8
#define NT_SYNTAX_ID_OCTETSTRING              9
#define NT_SYNTAX_ID_EncryptedString          10

typedef struct _octetstring {
    DWORD dwSize;
    BYTE *pByte;
} OctetString;

typedef struct _nttype{
    DWORD NTType;
    union {
        DWORD dwValue;
        LPTSTR pszValue;
        SYSTEMTIME stSystemTimeValue;
        BOOL       fValue;
        DWORD   dwSeconds1970;
        OctetString octetstring;
    }NTValue;

    //
    // for both Delimited and Nulled Strings we use pszValue
    //
}NTOBJECT, *PNTOBJECT, *LPNTOBJECT;
=== C:/Users/treeman/Desktop/windows nt source code\Source\Win2K3\NT\ds\adsi\winnt\libmain.cxx ===
//+---------------------------------------------------------------------------
//
//  Microsoft Windows
//  Copyright (C) Microsoft Corporation, 1992 - 1995.
//
//  File:       libmain.cxx
//
//  Contents:   LibMain for oleds.dll
//
//  Functions:  LibMain, DllGetClassObject
//
//  History:    25-Oct-94   KrishnaG   Created.
//
//----------------------------------------------------------------------------
#include "winnt.hxx"
#pragma hdrstop


HINSTANCE g_hInst = NULL;
extern HMODULE   g_hActiveDs;
WCHAR * szWinNTPrefix = L"@WinNT!";
HANDLE   FpnwLoadLibSemaphore = NULL;

//
// Strings that are loaded depending on locality
//
WCHAR g_szBuiltin[100];
WCHAR g_szNT_Authority[100];
WCHAR g_szEveryone[100];
BOOL g_fStringsLoaded = FALSE;

//
// 3rd party extension
//
extern PCLASS_ENTRY gpClassHead;
extern CRITICAL_SECTION g_ExtCritSect;

extern CRITICAL_SECTION g_TypeInfoCritSect;

//
// Disabled as it causes link warnings
// extern CRITICAL_SECTION  g_DispTypeInfoCritSect;
//

//---------------------------------------------------------------------------
// ADs debug print, mem leak and object tracking-related stuff
//---------------------------------------------------------------------------

DECLARE_INFOLEVEL(ADs)

//+---------------------------------------------------------------------------
//
//  Function:   ShutDown
//
//  Synopsis:   Function to handle printing out heap debugging display
//
//----------------------------------------------------------------------------
inline VOID ShutDown()
{
#if DBG==1
#ifndef MSVC
     DUMP_TRACKING_INFO_DELETE();
     DeleteCriticalSection(&g_csOT);
#endif  // ifndef MSVC
     DeleteCriticalSection(&g_csDP);
#endif
}

extern "C" DWORD heapInfoLevel;
extern "C" DWORD OtInfoLevel;
extern "C" DWORD ADsInfoLevel;

//+---------------------------------------------------------------------------
//
//  Function:   GetINIHeapInfoLevel
//
//  Synopsis:   Gets various infolevel values from win.ini
//
//----------------------------------------------------------------------------
inline VOID GetINIHeapInfoLevel()
{
#if DBG==1
    const INT MAXINFOLEN=11;
    WCHAR  awcs[MAXINFOLEN];

#ifndef MSVC
    if (GetProfileString(L"winnt",L"heapInfoLevel", L"00000003", awcs,MAXINFOLEN))
        heapInfoLevel = wcstoul(awcs, NULL, 16);

    if (GetProfileString(L"winnt",L"Ot", L"00000003", awcs, MAXINFOLEN))
        OtInfoLevel = wcstoul(awcs, NULL, 16);

#endif  // MSVC

    if (GetProfileString(L"winnt",L"ADsInfoLevel", L"00000003", awcs,MAXINFOLEN))
        ADsInfoLevel = wcstoul(awcs, NULL, 16);
#endif
}

//  Globals


ULONG  g_ulObjCount = 0;  // Number of objects alive in oleds.dll


//+------------------------------------------------------------------------
//
//  Macro that calculates the number of elements in a statically-defined
//  array.
//
//  Note - I swiped this from ADsary.cxx - A type-safe array class. Remember
//  to swipe the whole thing as required.
//-------------------------------------------------------------------------
#define ARRAY_SIZE(_a)  (sizeof(_a) / sizeof(_a[0]))

CWinNTProviderCF g_cfProvider;
CWinNTNamespaceCF g_cfNamespace;
CWinNTSystemInfoCF g_cfWinNTSystemInfo;
//CWinNTDomainCF g_cfDomain;


//+------------------------------------------------------------------------
//
//  oleds class factories
//
//-------------------------------------------------------------------------

struct CLSCACHE
{
    const CLSID *   pclsid;
    IClassFactory * pCF;
};



CLSCACHE g_aclscache[] =
{
    &CLSID_WinNTProvider,                        &g_cfProvider,
    &CLSID_WinNTNamespace,                       &g_cfNamespace, 
    &CLSID_WinNTSystemInfo,                      &g_cfWinNTSystemInfo    
};


//+---------------------------------------------------------------
//
//  Function:   DllGetClassObject
//
//  Synopsis:   Standard DLL entrypoint for locating class factories
//
//----------------------------------------------------------------

STDAPI
DllGetClassObject(REFCLSID clsid, REFIID iid, LPVOID FAR* ppv)
{
    HRESULT         hr;
    size_t          i;

    for (i = 0; i < ARRAY_SIZE(g_aclscache); i++)
    {
        if (IsEqualCLSID(clsid, *g_aclscache[i].pclsid))
        {
            hr = g_aclscache[i].pCF->QueryInterface(iid, ppv);
            RRETURN(hr);
        }
    }

    *ppv = NULL;

    //
    // Add Debugging Code to indicate that the oleds.DllGetClassObject has been called with an unknown CLSID.
    //

    return E_NOINTERFACE;
}

//+---------------------------------------------------------------
//
//  Function:   DllCanUnloadNow
//
//  Synopsis:   Standard DLL entrypoint to determine if DLL can be unloaded
//
//---------------------------------------------------------------

STDAPI
DllCanUnloadNow(void)
{
    HRESULT hr;

    hr = S_FALSE;

    if (AggregatorDllCanUnload() ) {
        hr = S_OK;
    }

    return hr;
}


void LoadLocalizedStrings()
{
    if (g_fStringsLoaded) {
        return;
    }

    if (!LoadStringW(
             g_hInst,
             ADS_WINNT_BUILTIN,
             g_szBuiltin,
             sizeof( g_szBuiltin ) / sizeof( WCHAR )
             )
        ) {
        wcscpy(g_szBuiltin, L"BUILTIN");
    }

    if (!LoadStringW(
             g_hInst,
             ADS_WINNT_NT_AUTHORITY,
             g_szNT_Authority,
             sizeof( g_szNT_Authority ) / sizeof( WCHAR )
             )
        ) {
        wcscpy(g_szNT_Authority, L"NT AUTHORITY");
    }

    if (!LoadStringW(
             g_hInst,
             ADS_WINNT_EVERYONE,
             g_szEveryone,
             sizeof( g_szEveryone ) / sizeof( WCHAR )
             )
        ) {
        wcscpy(g_szEveryone, L"Everyone");
    }

}
//+---------------------------------------------------------------
//
//  Function:   LibMain
//
//  Synopsis:   Standard DLL initialization entrypoint
//
//---------------------------------------------------------------

EXTERN_C BOOL __cdecl
LibMain(HINSTANCE hInst, ULONG ulReason, LPVOID pvReserved)
{
    HRESULT     hr;
    static DWORD dwCriticalSectionsInitialized = 0;

    switch (ulReason)
    {
    case DLL_PROCESS_ATTACH:
        //
        // Catch case of init crit sect failing.
        //
        __try {

            DisableThreadLibraryCalls(hInst);

            g_hInst = hInst;

            g_hActiveDs = GetModuleHandle(TEXT("activeds.dll"));

            InitializeCriticalSection(&g_TypeInfoCritSect);
            ++dwCriticalSectionsInitialized;
            //
            // If the following code is ever uncommented, then the 
            // switch statement in the DLL_PROCESS_DETACH section 
            // also needs to be updated to take this into account.
            //
            // Disabled to avoid linker warnings
            // InitializeCriticalSection(&g_DispTypeInfoCritSect);
            //

            //
            // for 3rd party extension
            //

            InitializeCriticalSection(&g_ExtCritSect);
            ++dwCriticalSectionsInitialized;

            //
            // Initialize the loadlibs critsect.
            //
            InitializeCriticalSection(&g_csLoadLibs);
            ++dwCriticalSectionsInitialized;

#if DBG==1
            InitializeCriticalSection(&g_csDP);
            ++dwCriticalSectionsInitialized;
#ifndef MSVC
            InitializeCriticalSection(&g_csOT);
            ++dwCriticalSectionsInitialized;
            InitializeCriticalSection(&g_csMem);
            ++dwCriticalSectionsInitialized;
#endif
#endif

            //
            // Load up localized strings.
            //
            LoadLocalizedStrings();

            gpClassHead = BuildClassesList();

            //
            // Build the global object class cache
            //

            hr = CObjNameCache::CreateClassCache(
                            &pgPDCNameCache
                            );
            if (FAILED(hr)) {
                return(FALSE);
            }

            //
            // create semaphore used to protect global data (DLL handles and
            // function pointers.
            //

            if ((FpnwLoadLibSemaphore = CreateSemaphore( NULL,1,1,NULL ))
                 == NULL)
            {
                return FALSE ;
            }

            g_pRtlEncryptMemory = (FRTLENCRYPTMEMORY) LoadAdvapi32Function(
                                      STRINGIZE(RtlEncryptMemory));
            g_pRtlDecryptMemory = (FRTLDECRYPTMEMORY) LoadAdvapi32Function(
                                      STRINGIZE(RtlDecryptMemory));

            if( (NULL == g_pRtlEncryptMemory) || (NULL == g_pRtlDecryptMemory) )
                g_pRtlEncryptMemory = g_pRtlDecryptMemory = NULL;                
        }
        __except (EXCEPTION_EXECUTE_HANDLER) {
            //
            // Critical failure
            //

            //
            // Delete the critical sections.  Note this must occur in reverse order
            // to the order in which they were initialized.  The fall through in 
            // each case statement is intentional.
            //
            switch(dwCriticalSectionsInitialized)
            {
#if DBG==1
#ifndef MSVC
            case 6:
                DeleteCriticalSection(&g_csMem);

            case 5:
                DeleteCriticalSection(&g_csOT);
#endif
            case 4:
                DeleteCriticalSection(&g_csDP);
#endif

            case 3:
                DeleteCriticalSection(&g_csLoadLibs);

            case 2:
                //
                // Causes link warnings if enabled
                // DeleteCriticalSection(&g_DispTypeInfoCritSect);
                //
                DeleteCriticalSection(&g_ExtCritSect);

            case 1:
                DeleteCriticalSection(&g_TypeInfoCritSect);
            }
            //
            // Reset the counts of critical sections that we have initialized, just
            // in case LibMain(DLL_PROCESS_DETACH) does get called.
            //
            dwCriticalSectionsInitialized = 0;

            return FALSE;
        }

        break;


    case DLL_PROCESS_DETACH:

        //
        // Release semaphor if applicable.
        //
        if (FpnwLoadLibSemaphore) {
            CloseHandle(FpnwLoadLibSemaphore);
            FpnwLoadLibSemaphore = NULL;
        }
        //
        // Del the name cache - delte should handle NULL btw.
        //
        delete pgPDCNameCache;
        //
        // free global list of class entries for 3rd party ext
        //

        FreeClassesList(gpClassHead);

        //
        // Delete the critical sections.  Note this must occur in reverse order
        // to the order in which they were initialized.  The fall through in 
        // each case statement is intentional.
        //
        switch(dwCriticalSectionsInitialized)
        {
#if DBG==1
#ifndef MSVC
        case 6:
            DeleteCriticalSection(&g_csMem);

        case 5:
            DeleteCriticalSection(&g_csOT);
#endif
        case 4:
            DeleteCriticalSection(&g_csDP);
#endif

        case 3:
            DeleteCriticalSection(&g_csLoadLibs);

        case 2:
            //
            // Causes link warnings if enabled
            // DeleteCriticalSection(&g_DispTypeInfoCritSect);
            //
            DeleteCriticalSection(&g_ExtCritSect);

        case 1:
            DeleteCriticalSection(&g_TypeInfoCritSect);
        }

        //
        // Free libs we may have loaded dynamically.
        //
        if (g_hDllNetapi32) {
            FreeLibrary((HMODULE) g_hDllNetapi32);
            g_hDllNetapi32 = NULL;
        }

        if (g_hDllAdvapi32) {
            FreeLibrary((HMODULE) g_hDllAdvapi32);
        }

        break;


    default:
        break;
    }

    return TRUE;
}

//+---------------------------------------------------------------------------
//
//  Function:   DllMain
//
//  Synopsis:   entry point for NT - post .546
//
//----------------------------------------------------------------------------
BOOL
DllMain(HANDLE hDll, DWORD dwReason, LPVOID lpReserved)
{
    return LibMain((HINSTANCE)hDll, dwReason, lpReserved);
}


//+------------------------------------------------------------------------
//
//  Function:   GetCachedClsidIndex
//
//  Synopsis:   Returns the index of the given CLSID in the cache, or
//              -1 if the CLSID is not present in the cache
//
//  Arguments:  [clsid]
//
//  Returns:    int
//
//-------------------------------------------------------------------------

int
GetCachedClsidIndex(REFCLSID clsid)
{
    int             i;
    CLSCACHE *      pclscache;

    for (i = 0, pclscache = g_aclscache;
         i < ARRAY_SIZE(g_aclscache);
         i ++, pclscache++)
    {
        if (IsEqualCLSID(*pclscache->pclsid, clsid))
            return i;
    }

    return -1;
}




//+------------------------------------------------------------------------
//
//  Function:   GetCachedClassFactory
//
//  Synopsis:   Returns the cached class factory with the given index.
//              The pointer returned has been AddRef'd.
//
//  Arguments:  [iclsid]
//
//  Returns:    IClassFactory *
//
//-------------------------------------------------------------------------

IClassFactory *
GetCachedClassFactory(int iclsid)
{
    IClassFactory * pCF;

    // Assert(iclsid >= 0);
    // Assert(iclsid < ARRAY_SIZE(g_aclscache));

    pCF = g_aclscache[iclsid].pCF;
    pCF->AddRef();

    return pCF;
}




//+------------------------------------------------------------------------
//
//  Function:   GetCachedClsid
//
//  Synopsis:   Returns the CLSID corresponding to the given index.
//              Normally, code should call GetCachedClassFactory to get
//              the class factory directly.
//
//  Arguments:  [iclsid]    --  Clsid index
//              [pclsid]    --  Matching clsid returned in *pclsid
//
//-------------------------------------------------------------------------

void
GetCachedClsid(int iclsid, CLSID * pclsid)
{
    // Assert(iclsid >= 0);
    // Assert(iclsid < ARRAY_SIZE(g_aclscache));

    *pclsid = *g_aclscache[iclsid].pclsid;
}
=== C:/Users/treeman/Desktop/windows nt source code\Source\Win2K3\NT\ds\adsi\winnt\ntumrshl.cxx ===
//+---------------------------------------------------------------------------
//
//  Microsoft Windows
//  Copyright (C) Microsoft Corporation, 1992 - 1995.
//
//  File:       ntumrshl.cxx
//
//  Contents:
//
//  Functions:
//
//
//  History:      17-June-1996   RamV   Created.
//
//
//  Notes :  Need to add functionality to do NulledString to NTTYPE
//           conversions
//
//
//----------------------------------------------------------------------------

#include "winnt.hxx"
#pragma  hdrstop
#define INITGUID

HRESULT
NTTypeInit(
    PNTOBJECT pNtType
    )
{
    memset(pNtType, 0, sizeof(NTOBJECT));

    RRETURN(S_OK);
}


HRESULT
NTTypeClear(
    PNTOBJECT pNtObject
    )
{
   if(!pNtObject)
        RRETURN(S_OK);

    switch (pNtObject->NTType) {
    case NT_SYNTAX_ID_LPTSTR:
    case NT_SYNTAX_ID_DelimitedString:
    case NT_SYNTAX_ID_EncryptedString:
        FreeADsStr((pNtObject->NTValue).pszValue);
        break;
    case NT_SYNTAX_ID_NulledString:
        FreeADsMem((pNtObject->NTValue).pszValue);
        break;
    case NT_SYNTAX_ID_OCTETSTRING:
        FreeADsMem((pNtObject->NTValue).octetstring.pByte);
        break;
    default:
        break;
    }
    RRETURN(S_OK);
}


void
NTTypeFreeNTObjects(
    PNTOBJECT pNtObject,
    DWORD dwNumValues
    )
{
    DWORD i = 0;

    if (!pNtObject)     // just in case
        return;

    for (i = 0; i < dwNumValues; i++ ) {
         NTTypeClear(pNtObject + i);
    }

    FreeADsMem(pNtObject);
    pNtObject = NULL;

    return;
}


HRESULT
CopyOctetToNTOBJECT(
    PBYTE   pOctetString,
    PNTOBJECT lpNtObject
    )
{

    if(!lpNtObject){
        RRETURN(E_POINTER);
    }

    lpNtObject->NTType = NT_SYNTAX_ID_OCTETSTRING;

    if(!pOctetString){
        (lpNtObject->NTValue).octetstring.dwSize = 0;
        (lpNtObject->NTValue).octetstring.pByte = NULL;
    } else {
        OctetString *pOctString = (OctetString*)pOctetString;
        (lpNtObject->NTValue).octetstring.dwSize = pOctString->dwSize;
        (lpNtObject->NTValue).octetstring.pByte = (BYTE*)AllocADsMem(sizeof(BYTE)*pOctString->dwSize);
        if (!(lpNtObject->NTValue).octetstring.pByte) {
            RRETURN(E_OUTOFMEMORY);
        }
        memcpy((lpNtObject->NTValue).octetstring.pByte, pOctString->pByte,pOctString->dwSize);
    }

    RRETURN(S_OK);
}

HRESULT
CopyDWORDToNTOBJECT(
    PDWORD pdwSrcValue,
    PNTOBJECT lpNtDestValue
    )
{
    HRESULT hr = S_OK;

    if(!lpNtDestValue){
        RRETURN(E_POINTER);
    }

    lpNtDestValue->NTType = NT_SYNTAX_ID_DWORD;
    (lpNtDestValue->NTValue).dwValue = *pdwSrcValue;

    RRETURN(hr);

}

HRESULT
CopyDATEToNTOBJECT(
    PDWORD pdwSrcValue,
    PNTOBJECT lpNtDestValue
    )
{
    HRESULT hr = S_OK;

    if(!lpNtDestValue){
        RRETURN(E_POINTER);
    }

    lpNtDestValue->NTType = NT_SYNTAX_ID_DATE;
    (lpNtDestValue->NTValue).dwValue = *pdwSrcValue;

    RRETURN(hr);

}

HRESULT
CopyBOOLToNTOBJECT(
    PBOOL pfSrcValue,
    PNTOBJECT lpNtObject
    )
{

    if(!lpNtObject){
        RRETURN(E_POINTER);
    }


    lpNtObject->NTType = NT_SYNTAX_ID_BOOL;

    (lpNtObject->NTValue).fValue = *pfSrcValue;

    RRETURN(S_OK);

}


HRESULT
CopySYSTEMTIMEToNTOBJECT(
    PSYSTEMTIME pSysTime,
    PNTOBJECT lpNtObject
    )
{

    if(!lpNtObject){
        RRETURN(E_POINTER);
    }

    (lpNtObject->NTValue).stSystemTimeValue = *pSysTime;
    lpNtObject->NTType = NT_SYNTAX_ID_SYSTEMTIME;

    RRETURN(S_OK);
}

HRESULT
CopyLPTSTRToNTOBJECT(
    LPTSTR   pszSrcValue,
    PNTOBJECT lpNtObject
    )
{
    if(!lpNtObject){
        RRETURN(E_POINTER);
    }

    lpNtObject->NTType = NT_SYNTAX_ID_LPTSTR;

    if(!pszSrcValue){
        (lpNtObject->NTValue). pszValue = NULL;
    } else {

        (lpNtObject->NTValue). pszValue = AllocADsStr(pszSrcValue);
        
        if (!((lpNtObject->NTValue). pszValue)){
            RRETURN(E_OUTOFMEMORY);
        }
    }
    RRETURN(S_OK);
}


HRESULT
CopyDelimitedStringToNTOBJECT(
    LPTSTR   pszSrcValue,
    PNTOBJECT lpNtObject,
    DWORD   dwElements
    )
{

    LPTSTR pszCurrPos = NULL;
    LONG i;
    WCHAR Delimiter = L',';
    HRESULT hr = S_OK;

    if(!pszSrcValue){
        RRETURN(E_POINTER);
    }

    if(!lpNtObject){
        RRETURN(E_POINTER);
    }

    //
    // scan string  and put the appropriate pointers
    //

    pszCurrPos = pszSrcValue;

    //
    // Fill up the NtObject structure
    //

    lpNtObject[0].NTType = NT_SYNTAX_ID_DelimitedString;
    (lpNtObject[0].NTValue).pszValue = AllocADsStr(pszCurrPos);
    
    if (!(lpNtObject[0].NTValue). pszValue){
        hr = E_OUTOFMEMORY;
        goto error;
    }

    i = 1;

    while(i < (LONG)dwElements){

        if(*pszCurrPos == TEXT('\0')){

            lpNtObject[i].NTType = NT_SYNTAX_ID_DelimitedString;
            (lpNtObject[i].NTValue).pszValue = AllocADsStr(++pszCurrPos);
            
            if (!(lpNtObject[i].NTValue).pszValue){
                hr = E_OUTOFMEMORY;
                goto error;
            }
            i++;
        }

        pszCurrPos++;
    }

error:

    RRETURN(hr);
}


HRESULT
CopyNulledStringToNTOBJECT(
    LPTSTR   pszSrcValue,
    PNTOBJECT lpNtObject,
    DWORD   dwElements
    )
{

    LPTSTR pszCurrPos = NULL;
    LONG i;
    HRESULT hr = S_OK;

    if(!pszSrcValue){
        RRETURN(E_POINTER);
    }

    if(!lpNtObject){
        RRETURN(E_POINTER);
    }

    //
    // scan string  and put the appropriate pointers
    //

    pszCurrPos = pszSrcValue;

    //
    // Fill up the NtObject structure
    //

    lpNtObject[0].NTType = NT_SYNTAX_ID_NulledString;
    (lpNtObject[0].NTValue).pszValue = AllocADsStr(pszCurrPos);
    
    if (!(lpNtObject[0].NTValue). pszValue){
        hr = E_OUTOFMEMORY;
        goto error;
    }

    i = 1;

    while(i < (LONG)dwElements){

        if(*pszCurrPos == TEXT('\0')){

            lpNtObject[i].NTType = NT_SYNTAX_ID_NulledString;
            (lpNtObject[i].NTValue).pszValue = AllocADsStr(++pszCurrPos);
            
            if (!(lpNtObject[i].NTValue).pszValue){
                hr = E_OUTOFMEMORY;
                goto error;
            }
            i++;
        }

        pszCurrPos++;
    }

error:

    RRETURN(hr);
}


HRESULT
CopySeconds70ToNTOBJECT(
    PDWORD pdwSrcValue,
    PNTOBJECT lpNtDestValue
    )
{
    HRESULT hr = S_OK;

    if(!lpNtDestValue){
        RRETURN(E_POINTER);
    }

    lpNtDestValue->NTType = NT_SYNTAX_ID_DATE_1970;
    (lpNtDestValue->NTValue).dwSeconds1970 = *pdwSrcValue;

    RRETURN(hr);

}


HRESULT
CopyNTToNTSynId(
    DWORD dwSyntaxId,
    LPBYTE lpByte,
    PNTOBJECT lpNTObject,
    DWORD dwNumValues
    )
{
    HRESULT hr = S_OK;

    switch (dwSyntaxId) {
    case NT_SYNTAX_ID_BOOL:

        hr = CopyBOOLToNTOBJECT(
                         (PBOOL)lpByte,
                         lpNTObject
                         );
        break;

    case NT_SYNTAX_ID_SYSTEMTIME:
        hr = CopySYSTEMTIMEToNTOBJECT(
                         (PSYSTEMTIME)lpByte,
                         lpNTObject
                         );
        break;

    case NT_SYNTAX_ID_DWORD:
        hr = CopyDWORDToNTOBJECT(
                         (PDWORD)lpByte,
                         lpNTObject
                         );
        break;

    case NT_SYNTAX_ID_DelimitedString:
        hr = CopyDelimitedStringToNTOBJECT(
                         (LPTSTR)lpByte,
                         lpNTObject,
                         dwNumValues
                         );
        break;

    case NT_SYNTAX_ID_NulledString:
        hr = CopyNulledStringToNTOBJECT(
                         (LPTSTR)lpByte,
                         lpNTObject,
                         dwNumValues
                         );
        break;

    case NT_SYNTAX_ID_LPTSTR:
        hr = CopyLPTSTRToNTOBJECT(
                         (LPTSTR)lpByte,
                         lpNTObject
                         );
        break;

    case NT_SYNTAX_ID_DATE_1970:
        hr = CopySeconds70ToNTOBJECT(
                         (PDWORD)lpByte,
                         lpNTObject
                         );
        break;

    case NT_SYNTAX_ID_DATE :
        hr = CopyDATEToNTOBJECT(
                         (PDWORD)lpByte,
                         lpNTObject
                         );                         
        break;

    case NT_SYNTAX_ID_OCTETSTRING:
        hr = CopyOctetToNTOBJECT(
                         lpByte,
                         lpNTObject
                         );
        break;

    default:
        break;

    }

    RRETURN(hr);
}



//
//  NT is single-valued except for Delimited and Nulled Strings
//

HRESULT
UnMarshallNTToNTSynId(
    DWORD dwSyntaxId,
    DWORD dwNumValues,
    LPBYTE lpValue,
    PNTOBJECT * ppNTObject
    )
{
    LPBYTE lpByte = lpValue;
    DWORD  i = 0;
    PNTOBJECT pNTObject = NULL;
    HRESULT hr = S_OK;

    pNTObject = (PNTOBJECT)AllocADsMem(
                            sizeof(NTOBJECT)*dwNumValues
                            );

    if (!pNTObject) {
        RRETURN(E_FAIL);
    }

    hr = CopyNTToNTSynId(
                     dwSyntaxId,
                     lpByte,
                     pNTObject,
                     dwNumValues
                     );
    BAIL_ON_FAILURE(hr);


    *ppNTObject = pNTObject;
    
    RRETURN(hr);
error:
    if(pNTObject){
        NTTypeFreeNTObjects(pNTObject, dwNumValues);
    }
    RRETURN(hr);
}
=== C:/Users/treeman/Desktop/windows nt source code\Source\Win2K3\NT\ds\adsi\winnt\ods2nt.cxx ===
//+---------------------------------------------------------------------------
//
//  Microsoft Windows
//  Copyright (C) Microsoft Corporation, 1992 - 1995.
//
//  File:       ods2nw.cxx
//
//  Contents:   NDS Object to Variant Copy Routines
//
//  Functions:
//
//  History:      25-Apr-96   KrishnaG   Created.
//
//
//  Issues:     Check null ptrs for AllocADsMem and AllocADsStr
//
//----------------------------------------------------------------------------
#include "winnt.hxx"
#pragma hdrstop



HRESULT
AdsTypeToNTTypeCopyCaseIgnoreString(
    PADSVALUE lpAdsSrcValue,
    PNTOBJECT lpNtDestObject
    )

{
    HRESULT hr = S_OK;

    if(lpAdsSrcValue->dwType != ADSTYPE_CASE_IGNORE_STRING){
        RRETURN(hr = E_ADS_CANT_CONVERT_DATATYPE);
    }

    lpNtDestObject->NTType = NT_SYNTAX_ID_LPTSTR;

    lpNtDestObject->NTValue.pszValue =
                        AllocADsStr(
                            lpAdsSrcValue->CaseIgnoreString
                        );

    RRETURN(hr);

}


HRESULT
AdsTypeToNTTypeCopyBoolean(
    PADSVALUE lpAdsSrcValue,
    PNTOBJECT lpNtDestObject
    )
{
    HRESULT hr = S_OK;

    if(lpAdsSrcValue->dwType != ADSTYPE_BOOLEAN){
        RRETURN(hr = E_ADS_CANT_CONVERT_DATATYPE);
    }

    lpNtDestObject->NTType = NT_SYNTAX_ID_BOOL;

    lpNtDestObject->NTValue.fValue =
                        lpAdsSrcValue->Boolean;

    RRETURN(hr);
}


HRESULT
AdsTypeToNTTypeCopyInteger(
    PADSVALUE lpAdsSrcValue,
    PNTOBJECT lpNtDestObject
    )
{
    HRESULT hr = S_OK;

    if(lpAdsSrcValue->dwType != ADSTYPE_INTEGER){
        RRETURN(hr = E_ADS_CANT_CONVERT_DATATYPE);
    }

    lpNtDestObject->NTType = NT_SYNTAX_ID_DWORD;

    lpNtDestObject->NTValue.dwValue =
                                lpAdsSrcValue->Integer;

    RRETURN(hr);
}

HRESULT
AdsTypeToNTTypeCopy(
    PADSVALUE lpAdsSrcValue,
    PNTOBJECT lpNtDestObject
    )
{
    HRESULT hr = S_OK;
    switch (lpAdsSrcValue->dwType){

    case ADSTYPE_CASE_IGNORE_STRING:
        hr = AdsTypeToNTTypeCopyCaseIgnoreString(
                lpAdsSrcValue,
                lpNtDestObject
                );
        break;

    case ADSTYPE_BOOLEAN:
        hr = AdsTypeToNTTypeCopyBoolean(
                lpAdsSrcValue,
                lpNtDestObject
                );
        break;

    case ADSTYPE_INTEGER:
        hr = AdsTypeToNTTypeCopyInteger(
                lpAdsSrcValue,
                lpNtDestObject
                );
        break;

    default:
        hr = E_FAIL;
        break;
    }

    RRETURN(hr);
}



HRESULT
AdsTypeToNTTypeCopyConstruct(
    LPADSVALUE pAdsSrcValues,
    DWORD dwNumObjects,
    LPNTOBJECT * ppNtDestObjects,
    PDWORD pdwNumNdsObjects,
    PDWORD pdwNdsSyntaxId
    )
{

    DWORD i = 0;
    LPNTOBJECT pNtDestObjects = NULL;
    HRESULT hr = S_OK;

    pNtDestObjects = (LPNTOBJECT)AllocADsMem(
                                    dwNumObjects * sizeof(NTOBJECT)
                                    );

    if (!pNtDestObjects) {
        RRETURN(E_FAIL);
    }

     for (i = 0; i < dwNumObjects; i++ ) {
         hr = AdsTypeToNTTypeCopy(
                    pAdsSrcValues + i,
                    pNtDestObjects + i
                    );
         BAIL_ON_FAILURE(hr);

     }

     *ppNtDestObjects = pNtDestObjects;
     *pdwNumNdsObjects = dwNumObjects;
     *pdwNdsSyntaxId = pNtDestObjects->NTType;
     RRETURN(S_OK);

error:

     NTTypeFreeNTObjects(
                pNtDestObjects,
                dwNumObjects
                );

     *ppNtDestObjects = NULL;
     *pdwNumNdsObjects = 0;

     RRETURN(hr);
}
=== C:/Users/treeman/Desktop/windows nt source code\Source\Win2K3\NT\ds\adsi\winnt\property.cxx ===
#include "winnt.hxx"
#pragma hdrstop


#define VALIDATE_PTR(pPtr) \
    if (!pPtr) { \
        hr = E_ADS_BAD_PARAMETER;\
    }\
    BAIL_ON_FAILURE(hr);




HRESULT
put_BSTR_Property(
    IADs * pADsObject,
    LPTSTR szPropertyName,
    BSTR   pSrcStringProperty
    )
{
    HRESULT hr = S_OK;
    VARIANT varInputData;
    BSTR bstrPropertyName = NULL;

    hr = PackStringinVariant(
            pSrcStringProperty,
            &varInputData
            );
    BAIL_ON_FAILURE(hr);

    hr = ADsAllocString(szPropertyName, &bstrPropertyName);
    BAIL_ON_FAILURE(hr);

    hr = pADsObject->Put(
            bstrPropertyName,
            varInputData
            );
    BAIL_ON_FAILURE(hr);


error:
    if (bstrPropertyName)
        ADsFreeString(bstrPropertyName);

    VariantClear(&varInputData);
    RRETURN(hr);
}

HRESULT
get_BSTR_Property(
    IADs * pADsObject,
    LPTSTR  szPropertyName,
    BSTR *ppDestStringProperty
    )
{
    HRESULT hr = S_OK;
    VARIANT varOutputData;
    BSTR bstrPropertyName = NULL;

    VariantInit( &varOutputData );

    if (NULL == ppDestStringProperty)
        BAIL_ON_FAILURE(hr = E_POINTER);

    hr = ADsAllocString(szPropertyName, &bstrPropertyName);
    BAIL_ON_FAILURE(hr);

    hr = pADsObject->Get(
            bstrPropertyName,
            &varOutputData
            );
    BAIL_ON_FAILURE(hr);

    hr = UnpackStringfromVariant(
            varOutputData,
            ppDestStringProperty
            );
    BAIL_ON_FAILURE(hr);


error:
    if (bstrPropertyName)
        ADsFreeString(bstrPropertyName);

    VariantClear(&varOutputData);
    RRETURN(hr);
}

HRESULT
put_LONG_Property(
    IADs * pADsObject,
    LPTSTR  szPropertyName,
    LONG   lSrcProperty
    )
{
    HRESULT hr = S_OK;
    VARIANT varInputData;
    BSTR bstrPropertyName = NULL;

    hr = PackLONGinVariant(
            lSrcProperty,
            &varInputData
            );
    BAIL_ON_FAILURE(hr);

    hr = ADsAllocString(szPropertyName, &bstrPropertyName);
    BAIL_ON_FAILURE(hr);

    hr = pADsObject->Put(
            bstrPropertyName,
            varInputData
            );
    BAIL_ON_FAILURE(hr);

error:
    if (bstrPropertyName)
        ADsFreeString(bstrPropertyName);

    VariantClear(&varInputData);
    RRETURN(hr);
}

HRESULT
get_LONG_Property(
    IADs * pADsObject,
    LPTSTR szPropertyName,
    PLONG plDestProperty
    )
{
    HRESULT hr = S_OK;
    VARIANT varOutputData;
    BSTR bstrPropertyName = NULL;

    VariantInit( &varOutputData );

    if (NULL == plDestProperty)
        BAIL_ON_FAILURE(hr = E_POINTER);

    hr = ADsAllocString(szPropertyName, &bstrPropertyName);
    BAIL_ON_FAILURE(hr);

    hr = pADsObject->Get(
            bstrPropertyName,
            &varOutputData
            );
    BAIL_ON_FAILURE(hr);

    hr = UnpackLONGfromVariant(
            varOutputData,
            plDestProperty
            );
    BAIL_ON_FAILURE(hr);


error:
    if (bstrPropertyName)
        ADsFreeString(bstrPropertyName);

    VariantClear(&varOutputData);
    RRETURN(hr);

}

HRESULT
put_DATE_Property(
    IADs * pADsObject,
    LPTSTR  szPropertyName,
    DATE   daSrcProperty
    )
{
    HRESULT hr = S_OK;
    VARIANT varInputData;
    BSTR bstrPropertyName = NULL;

    hr = PackDATEinVariant(
            daSrcProperty,
            &varInputData
            );
    BAIL_ON_FAILURE(hr);

    hr = ADsAllocString(szPropertyName, &bstrPropertyName);
    BAIL_ON_FAILURE(hr);

    hr = pADsObject->Put(
            bstrPropertyName,
            varInputData
            );
    BAIL_ON_FAILURE(hr);

error:
    if (bstrPropertyName)
        ADsFreeString(bstrPropertyName);

    VariantClear(&varInputData);
    RRETURN(hr);
}

HRESULT
get_DATE_Property(
    IADs * pADsObject,
    LPTSTR  szPropertyName,
    PDATE pdaDestProperty
    )
{
    HRESULT hr = S_OK;
    VARIANT varOutputData;
    BSTR bstrPropertyName = NULL;

    VariantInit( &varOutputData );

    if (NULL == pdaDestProperty)
        BAIL_ON_FAILURE(hr = E_POINTER);

    hr = ADsAllocString(szPropertyName, &bstrPropertyName);
    BAIL_ON_FAILURE(hr);

    hr = pADsObject->Get(
            bstrPropertyName,
            &varOutputData
            );
    BAIL_ON_FAILURE(hr);

    hr = UnpackDATEfromVariant(
            varOutputData,
            pdaDestProperty
            );
    BAIL_ON_FAILURE(hr);


error:
    if (bstrPropertyName)
        ADsFreeString(bstrPropertyName);

    VariantClear(&varOutputData);
    RRETURN(hr);
}

HRESULT
put_VARIANT_BOOL_Property(
    IADs * pADsObject,
    LPTSTR  szPropertyName,
    VARIANT_BOOL   fSrcProperty
    )
{
    HRESULT hr = S_OK;
    VARIANT varInputData;
    BSTR bstrPropertyName = NULL;

    hr = PackVARIANT_BOOLinVariant(
            fSrcProperty,
            &varInputData
            );
    BAIL_ON_FAILURE(hr);

    hr = ADsAllocString(szPropertyName, &bstrPropertyName);
    BAIL_ON_FAILURE(hr);

    hr = pADsObject->Put(
            bstrPropertyName,
            varInputData
            );
    BAIL_ON_FAILURE(hr);

error:
    if (bstrPropertyName)
        ADsFreeString(bstrPropertyName);

    VariantClear(&varInputData);
    RRETURN(hr);
}

HRESULT
get_VARIANT_BOOL_Property(
    IADs * pADsObject,
    LPTSTR  szPropertyName,
    PVARIANT_BOOL pfDestProperty
    )
{
    HRESULT hr = S_OK;
    VARIANT varOutputData;
    BSTR bstrPropertyName = NULL;

    VariantInit( &varOutputData );

    if (NULL == pfDestProperty)
        BAIL_ON_FAILURE(hr = E_POINTER);

    hr = ADsAllocString(szPropertyName, &bstrPropertyName);
    BAIL_ON_FAILURE(hr);

    hr = pADsObject->Get(
            bstrPropertyName,
            &varOutputData
            );
    BAIL_ON_FAILURE(hr);

    hr = UnpackVARIANT_BOOLfromVariant(
            varOutputData,
            pfDestProperty
            );
    BAIL_ON_FAILURE(hr);


error:
    if (bstrPropertyName)
        ADsFreeString(bstrPropertyName);

    VariantClear(&varOutputData);
    RRETURN(hr);
}

HRESULT
put_VARIANT_Property(
    IADs * pADsObject,
    LPTSTR  szPropertyName,
    VARIANT   vSrcProperty
    )
{
    HRESULT hr = S_OK;
    VARIANT varInputData;
    BSTR bstrPropertyName = NULL;

    hr = PackVARIANTinVariant(
            vSrcProperty,
            &varInputData
            );
    BAIL_ON_FAILURE(hr);

    hr = ADsAllocString(szPropertyName, &bstrPropertyName);
    BAIL_ON_FAILURE(hr);


    hr = pADsObject->Put(
            bstrPropertyName,
            varInputData
            );
    BAIL_ON_FAILURE(hr);

error:
    if (bstrPropertyName)
        ADsFreeString(bstrPropertyName);

    VariantClear(&varInputData);
    RRETURN(hr);
}

HRESULT
get_VARIANT_Property(
    IADs * pADsObject,
    LPTSTR  szPropertyName,
    PVARIANT pvDestProperty
    )
{
    HRESULT hr = S_OK;
    VARIANT varOutputData;
    BSTR bstrPropertyName = NULL;

    VariantInit( &varOutputData );

    if (NULL == pvDestProperty)
        BAIL_ON_FAILURE(hr = E_POINTER);

    hr = ADsAllocString(szPropertyName, &bstrPropertyName);
    BAIL_ON_FAILURE(hr);

    hr = pADsObject->Get(
            bstrPropertyName,
            &varOutputData
            );
    BAIL_ON_FAILURE(hr);

    hr = UnpackVARIANTfromVariant(
            varOutputData,
            pvDestProperty
            );
    BAIL_ON_FAILURE(hr);

error:
    if (bstrPropertyName)
        ADsFreeString(bstrPropertyName);

    VariantClear(&varOutputData);
    RRETURN(hr);
}
=== C:/Users/treeman/Desktop/windows nt source code\Source\Win2K3\NT\ds\adsi\winnt\printhlp.cxx ===
/*++

  Copyright (c) 1996  Microsoft Corporation

  Module Name:

  printhlp.cxx

  Abstract:
  Helper functions for printer object

  Author:

  Ram Viswanathan ( ramv)
  Revision History:


  --*/



#include "winnt.hxx"
#pragma hdrstop

/*+------------------------------------------------------------------------
 *           Helper functions follow
 *-------------------------------------------------------------------------
 */

//
// mapping WinNT Status Codes to ADs Status Codes and vice versa
//

typedef struct _PrintStatusList {
    DWORD  dwWinNTPrintStatus;
    DWORD dwADsPrintStatus;
} PRINT_STATUS_LIST, *PPRINT_STATUS_LIST;


PRINT_STATUS_LIST PrintStatusList[] =
{
{PRINTER_STATUS_PAUSED, ADS_PRINTER_PAUSED},
{PRINTER_STATUS_PENDING_DELETION, ADS_PRINTER_PENDING_DELETION}
};

BOOL PrinterStatusWinNTToADs( DWORD dwWinNTStatus,
DWORD *pdwADsStatus)

{
    BOOL found = FALSE;
    int i;

    for (i=0;i<2;i++){

        if(dwWinNTStatus == PrintStatusList[i].dwWinNTPrintStatus){
            *pdwADsStatus = PrintStatusList[i].dwADsPrintStatus;
            found = TRUE;
            break;
        }
    }
    return (found);
}


BOOL PrinterStatusADsToWinNT( DWORD dwADsStatus,
                               DWORD *pdwWinNTStatus)
{
    BOOL found = FALSE;
    int i;

    for (i=0;i<2;i++){

        if(dwADsStatus == PrintStatusList[i].dwADsPrintStatus){
            *pdwWinNTStatus = PrintStatusList[i].dwWinNTPrintStatus;
            found = TRUE;
            break;
        }
    }
    return (found);

}






BOOL
WinNTEnumPrinters(
                  DWORD  dwType,
                  LPTSTR lpszName,
                  DWORD  dwLevel,
                  LPBYTE *lplpbPrinters,
                  LPDWORD lpdwReturned
                  )
{

    BOOL    bStatus = FALSE;
    DWORD   dwPassed = 1024;
    DWORD   dwNeeded = 0;
    DWORD   dwError = 0;
    LPBYTE  pMem = NULL;


    pMem =  (LPBYTE)AllocADsMem(dwPassed);
    if (!pMem) {
        goto error;
    }

    bStatus = EnumPrinters(dwType,
                           lpszName,
                           dwLevel,
                           pMem,
                           dwPassed,
                           &dwNeeded,
                           lpdwReturned);


    if (!bStatus) {
        if ((dwError = GetLastError()) != ERROR_INSUFFICIENT_BUFFER) {
            goto error;

        }

        if (pMem) {
            FreeADsMem(pMem);
        }

        pMem = (LPBYTE)AllocADsMem(dwNeeded);

        if (!pMem) {
            goto error;
        }

        dwPassed = dwNeeded;

        bStatus = EnumPrinters(dwType,
                               lpszName,
                               dwLevel,
                               pMem,
                               dwPassed,
                               &dwNeeded,
                               lpdwReturned);

        if (!bStatus) {
            goto error;
        }
    }

    *lplpbPrinters = pMem;

    return(TRUE);


error:

    if (pMem) {
        FreeADsMem(pMem);
    }

    return(FALSE);

}


BOOL
WinNTGetPrinter(HANDLE hPrinter,
                DWORD  dwLevel,
                LPBYTE *lplpbPrinters)
{

    BOOL    bStatus = FALSE;
    DWORD   dwPassed = 1024;
    DWORD   dwNeeded = 0;
    DWORD   dwError = 0;
    LPBYTE  pMem = NULL;


    pMem =  (LPBYTE)AllocADsMem(dwPassed);
    if (!pMem) {
        goto error;
    }

    bStatus = GetPrinter(hPrinter,
                         dwLevel,
                         pMem,
                         dwPassed,
                         &dwNeeded);

    if (!bStatus) {
        if ((dwError = GetLastError()) != ERROR_INSUFFICIENT_BUFFER) {
            goto error;

        }

        if (pMem) {
            FreeADsMem(pMem);
        }

        pMem = (LPBYTE)AllocADsMem(dwNeeded);

        if (!pMem) {
            goto error;
        }

        dwPassed = dwNeeded;

        bStatus = GetPrinter(hPrinter,
                             dwLevel,
                             pMem,
                             dwPassed,
                             &dwNeeded);

        if (!bStatus) {
            goto error;
        }
    }

    *lplpbPrinters = pMem;

    return(TRUE);


error:

    if (pMem) {
        FreeADsMem(pMem);
    }

    return(FALSE);

}


HRESULT
GetPrinterInfo(
    THIS_ LPPRINTER_INFO_2 *lplpPrinterInfo2,
    LPWSTR  pszPrinterName
    )
{

    //
    // Do a GetPrinter call to pszPrinterName
    //

    BOOL fStatus = FALSE;
    PRINTER_DEFAULTS PrinterDefaults = {0, 0, PRINTER_ACCESS_USE |
                                            READ_CONTROL};
    DWORD LastError = 0;
    HANDLE hPrinter = NULL;
    LPBYTE pMem = NULL;
    HRESULT hr = S_OK;

    ADsAssert(pszPrinterName);
    fStatus = OpenPrinter(pszPrinterName,
                          &hPrinter,
                          &PrinterDefaults
                          );

    if (!fStatus) {
        LastError = GetLastError();
        switch (LastError) {

        case ERROR_ACCESS_DENIED:
        {
            PRINTER_DEFAULTS PrinterDefaults = {0, 0, PRINTER_ACCESS_USE};
            fStatus = OpenPrinter(pszPrinterName,
                                  &hPrinter,
                                  &PrinterDefaults
                                  );
            if (fStatus) {
                break;
            }
        }

        default:
            RRETURN(HRESULT_FROM_WIN32(GetLastError()));

    }
    }

    fStatus = WinNTGetPrinter(hPrinter,
                              2,
                              (LPBYTE *)&pMem
                              );
    if (!fStatus) {
        hr = HRESULT_FROM_WIN32(GetLastError());
        goto cleanup;
    }

    *lplpPrinterInfo2 = (LPPRINTER_INFO_2)pMem;

cleanup:

    if(hPrinter)
        fStatus = ClosePrinter(hPrinter);
    RRETURN(hr);
}


//+---------------------------------------------------------------------------
//
//  Function:   Set
//
//  Synopsis:   Helper function called by CADsPrintQueue:SetInfo
//
//  Arguments:
//
//  Returns:    HRESULT.
//
//  Modifies:
//
//  History:    11-08-95 RamV  Created
//
//----------------------------------------------------------------------------

HRESULT
Set(
    LPPRINTER_INFO_2 lpPrinterInfo2,
    LPTSTR   pszPrinterName
    )
{

    BOOL fStatus = FALSE;
    PRINTER_DEFAULTS PrinterDefaults = {0, 0, PRINTER_ALL_ACCESS};
    HANDLE hPrinter = NULL;
    HRESULT hr;

    ADsAssert(pszPrinterName);

    fStatus = OpenPrinter(pszPrinterName,
                          &hPrinter,
                          &PrinterDefaults
                          );

    if (!fStatus) {
        goto error;
    }

    fStatus = SetPrinter(hPrinter,
                         2,
                         (LPBYTE)lpPrinterInfo2,
                         0
                         );
    if (!fStatus) {
        goto error;
    }

    fStatus = ClosePrinter(hPrinter);

    RRETURN(S_OK);

error:
    hr = HRESULT_FROM_WIN32(GetLastError());
    if(hPrinter)
        fStatus = ClosePrinter(hPrinter);
    RRETURN(hr);

}


//+---------------------------------------------------------------------------
//
//  Function:   Unmarshall
//
//  Synopsis:   Unmarshalls information from a PRINTER_INFO_2 to a
//              WinNT Printer object.Frees PRINTER_INFO_2 object.
//
//  Arguments:  [lpPrinterInfo2] -- Pointer to a PRINTER_INFO_2 struct
//
//  Returns:    HRESULT
//
//  Modifies:   GeneralInfo and Operation Functional sets
//
//  History:    11/08/95  RamV   Created
//
//----------------------------------------------------------------------------

HRESULT
CWinNTPrintQueue::UnMarshall(
    LPPRINTER_INFO_2 lpPrinterInfo2,
    BOOL fExplicit
    )
{
    HRESULT hr;
    VARIANT vPortNames;
    PNTOBJECT pNtObject;

    hr = SetLPTSTRPropertyInCache(_pPropertyCache,
                                  TEXT("PrinterName"),
                                  lpPrinterInfo2->pPrinterName,
                                  fExplicit
                                  );

    hr = SetLPTSTRPropertyInCache(_pPropertyCache,
                                  TEXT("Model"),
                                  lpPrinterInfo2->pDriverName,
                                  fExplicit
                                  );


    hr = SetLPTSTRPropertyInCache(_pPropertyCache,
                                  TEXT("PrintProcessor"),
                                  lpPrinterInfo2->pPrintProcessor,
                                  fExplicit
                                  );


    hr = SetLPTSTRPropertyInCache(_pPropertyCache,
                                  TEXT("Location"),
                                  lpPrinterInfo2->pLocation,
                                  fExplicit
                                  );


    hr = SetLPTSTRPropertyInCache(_pPropertyCache,
                                  TEXT("Datatype"),
                                  lpPrinterInfo2->pDatatype,
                                  fExplicit
                                  );


    hr = SetLPTSTRPropertyInCache(_pPropertyCache,
                                  TEXT("BannerPage"),
                                  lpPrinterInfo2->pSepFile,
                                  fExplicit
                                  );

    hr = SetLPTSTRPropertyInCache(_pPropertyCache,
                                  TEXT("Description"),
                                  lpPrinterInfo2->pComment,
                                  fExplicit
                                  );

    hr = SetLPTSTRPropertyInCache(_pPropertyCache,
                                  TEXT("PrinterPath"),
                                  lpPrinterInfo2->pPrinterName,
                                  fExplicit
                                  );


    hr = SetDWORDPropertyInCache(_pPropertyCache,
                                  TEXT("Priority"),
                                  lpPrinterInfo2->Priority,
                                  fExplicit
                                  );


    hr = SetDelimitedStringPropertyInCache(_pPropertyCache,
                                           TEXT("PrintDevices"),
                                           lpPrinterInfo2->pPortName,
                                           fExplicit
                                           );


    hr = SetDWORDPropertyInCache(_pPropertyCache,
                                  TEXT("DefaultJobPriority"),
                                  lpPrinterInfo2->DefaultPriority,
                                  fExplicit
                                  );

    hr = SetDWORDPropertyInCache(_pPropertyCache,
                                  TEXT("JobCount"),
                                  lpPrinterInfo2->cJobs,
                                  fExplicit
                                  );

    hr = SetDWORDPropertyInCache(_pPropertyCache,
                                  TEXT("Attributes"),
                                  lpPrinterInfo2->Attributes,
                                  fExplicit
                                  );

    hr = SetDATEPropertyInCache(_pPropertyCache,
                                  TEXT("StartTime"),
                                  lpPrinterInfo2->StartTime,
                                  fExplicit
                                  );

    hr = SetDATEPropertyInCache(_pPropertyCache,
                                  TEXT("UntilTime"),
                                  lpPrinterInfo2->UntilTime,
                                  fExplicit
                                  );

    hr = SetLPTSTRPropertyInCache(
                _pPropertyCache,
                TEXT("Name"),
                _Name,
                fExplicit
                );


    RRETURN(S_OK);
}

//+---------------------------------------------------------------------------
//
//  Function:   MarshallAndSet
//
//  Synopsis:   Marshalls information from a Printer object to a
//              PRINTER_INFO_2 structure
//
//  Arguments:  [lpPrinterInfo2] -- Pointer to a PRINTER_INFO_2 struct.
//
//  Returns:    HRESULT
//
//  Modifies:
//
//  History:    11/09/95  RamV  Created
//
//----------------------------------------------------------------------------

HRESULT
CWinNTPrintQueue::MarshallAndSet(
    LPPRINTER_INFO_2 lpPrinterInfo2
    )

{
    HRESULT hr =S_OK;
    DWORD dwPriority;
    LPTSTR   pszPrinterName = NULL;
    LPTSTR   pszDriverName = NULL;
    LPTSTR   pszComment = NULL;
    LPTSTR   pszLocation = NULL;
    LPTSTR   pszDatatype = NULL;
    LPTSTR   pszPrintProcessor = NULL;
    LPTSTR   pszBannerPage = NULL;
    VARIANT vPortNames;
    PNTOBJECT  pNtObject = NULL;
    LPTSTR pszPorts = NULL;
    DWORD dwSyntaxId;
    DWORD dwTimeValue;
    DWORD dwNumValues = 0;
    DWORD dwAttributes;
    DWORD dwUpdatedProps = 0;

    //
    // We can set the update variable based on the number
    // of properties in the cache.
    //
    hr = _pPropertyCache->get_PropertyCount(&dwUpdatedProps);

    if (dwUpdatedProps != 0) {
        //
        // We can do all this to get the props
        //
        hr = GetLPTSTRPropertyFromCache(
                        _pPropertyCache,
                        TEXT("PrinterName"),
                        &pszPrinterName
                        );
        if(SUCCEEDED(hr)){
            lpPrinterInfo2->pPrinterName= pszPrinterName;
        }

        hr = GetLPTSTRPropertyFromCache(
                        _pPropertyCache,
                        TEXT("Model"),
                        &pszDriverName
                        );
        if(SUCCEEDED(hr)){
            lpPrinterInfo2->pDriverName = pszDriverName;
        }

        hr = GetLPTSTRPropertyFromCache(
                        _pPropertyCache,
                        TEXT("PrintProcessor"),
                        &pszPrintProcessor
                        );

        if(SUCCEEDED(hr)){

            lpPrinterInfo2->pPrintProcessor = pszPrintProcessor;
        }


        hr = GetLPTSTRPropertyFromCache(
                        _pPropertyCache,
                        TEXT("Description"),
                        &pszComment
                        );

        if(SUCCEEDED(hr)){

            lpPrinterInfo2->pComment = pszComment;
        }

        hr = GetLPTSTRPropertyFromCache(
                        _pPropertyCache,
                        TEXT("Location"),
                        &pszLocation
                        );

        if(SUCCEEDED(hr)){

            lpPrinterInfo2->pLocation = pszLocation;
        }

        hr = GetLPTSTRPropertyFromCache(
                        _pPropertyCache,
                        TEXT("Datatype"),
                        &pszDatatype
                        );

        if(SUCCEEDED(hr)){

            lpPrinterInfo2->pDatatype = pszDatatype;
        }

        hr = GetLPTSTRPropertyFromCache(
                        _pPropertyCache,
                        TEXT("BannerPage"),
                        &pszBannerPage
                        );

        if(SUCCEEDED(hr)){

            lpPrinterInfo2->pSepFile = pszBannerPage;
        }

        hr = GetDWORDPropertyFromCache(
                        _pPropertyCache,
                        TEXT("Priority"),
                        &dwPriority
                        );

        if(SUCCEEDED(hr)){

            lpPrinterInfo2->Priority = dwPriority;
        }

        hr = GetDWORDPropertyFromCache(
                        _pPropertyCache,
                        TEXT("DefaultJobPriority"),
                        &dwPriority
                        );

        if(SUCCEEDED(hr)){

            lpPrinterInfo2->DefaultPriority = dwPriority;
        }

        //
        // will NOT marshall or set job count on the server
        //

        hr = GetDWORDPropertyFromCache(
                        _pPropertyCache,
                        TEXT("Attributes"),
                        &dwAttributes
                        );

        if(SUCCEEDED(hr)){

            lpPrinterInfo2->Attributes = dwAttributes;
        }

        hr = GetDelimitedStringPropertyFromCache(
                        _pPropertyCache,
                        TEXT("PrintDevices"),
                        &pszPorts
                        );

        if(SUCCEEDED(hr)){

            lpPrinterInfo2->pPortName = pszPorts;
        }

        hr = GetDATEPropertyFromCache(
                        _pPropertyCache,
                        TEXT("StartTime"),
                        &dwTimeValue
                        );

        if(SUCCEEDED(hr)){

            lpPrinterInfo2->StartTime = dwTimeValue;
        }

        hr = GetDATEPropertyFromCache(
                        _pPropertyCache,
                        TEXT("UntilTime"),
                        &dwTimeValue
                        );

        if(SUCCEEDED(hr)){

            lpPrinterInfo2->UntilTime = dwTimeValue;
        }


        //
        // Need to do the set
        //

        hr = Set(lpPrinterInfo2,
                 _pszPrinterName);
        //
        // only this hr gets recorded
        //

        BAIL_IF_ERROR(hr);
    }

cleanup:
    if(pszDriverName)
        FreeADsStr(pszDriverName);
    if(pszComment)
        FreeADsStr(pszComment);
    if(pszLocation)
        FreeADsStr(pszLocation);
    if(pszDatatype)
        FreeADsStr(pszDatatype);
    if(pszPrintProcessor)
        FreeADsStr(pszPrintProcessor);
    if(pszBannerPage)
        FreeADsStr(pszBannerPage);
    if(pszPorts){
        FreeADsStr(pszPorts);
    }
    RRETURN(hr);

}

HRESULT
WinNTDeletePrinter( POBJECTINFO pObjectInfo)
{
    WCHAR szUncServerName[MAX_PATH];
    WCHAR szUncPrinterName[MAX_PATH];
    HANDLE hPrinter = NULL;
    PRINTER_DEFAULTS PrinterDefaults = {0, 0, PRINTER_ALL_ACCESS};
    BOOL fStatus = FALSE;
    HRESULT hr = S_OK;
    //
    // first open printer to get a handle to it
    //

    hr = MakeUncName(pObjectInfo->ComponentArray[1],
                      szUncServerName
                      );
    BAIL_ON_FAILURE(hr);

    //
    // Make sure we don't overrun the buffer
    // Account for both slashes and the null terminator
    //
    if (wcslen(szUncServerName) + wcslen(pObjectInfo->ComponentArray[2]) > MAX_PATH - 3)
      BAIL_ON_FAILURE(hr = E_INVALIDARG);

    wcscpy(szUncPrinterName, szUncServerName);
    wcscat(szUncPrinterName, L"\\");
    wcscat(szUncPrinterName, (LPTSTR)pObjectInfo->ComponentArray[2]);

    fStatus = OpenPrinter((LPTSTR)szUncPrinterName,
                          &hPrinter,
                          &PrinterDefaults
                          );

    if (!fStatus) {
        hr = HRESULT_FROM_WIN32(GetLastError());
        goto error;
    }

    fStatus = DeletePrinter(hPrinter);

    //
    // Always close the printer handle, even if we deleted the printer.
    //
    ClosePrinter(hPrinter);

    if (!fStatus) {
        hr = HRESULT_FROM_WIN32(GetLastError());
        goto error;

    }


error:

    RRETURN(hr);
}

HRESULT
PrinterNameFromObjectInfo(
    POBJECTINFO pObjectInfo,
    LPTSTR szUncPrinterName
    )
{
    if(!pObjectInfo){
        RRETURN(S_OK);
    }

    if(!((pObjectInfo->NumComponents == 3) ||(pObjectInfo->NumComponents == 4)) ){
        RRETURN(E_ADS_BAD_PATHNAME);
    }

        if(pObjectInfo->NumComponents == 3) {
        wcscpy(szUncPrinterName, TEXT("\\\\"));
        wcscat(szUncPrinterName, pObjectInfo->ComponentArray[1]);
        wcscat(szUncPrinterName, TEXT("\\"));
        wcscat(szUncPrinterName, pObjectInfo->ComponentArray[2]);
        } else  {
            wcscpy(szUncPrinterName, TEXT("\\\\"));
        wcscat(szUncPrinterName, pObjectInfo->ComponentArray[0]);
        wcscat(szUncPrinterName, TEXT("\\"));
        wcscat(szUncPrinterName, pObjectInfo->ComponentArray[1]);
        }

    RRETURN(S_OK);
}




#if (!defined(BUILD_FOR_NT40))


//+---------------------------------------------------------------------------
//
//  Function:   MarshallAndSet
//
//  Synopsis:   Marshalls information from a Printer object to a
//              PRINTER_INFO_7 structure
//
//  Arguments:  [lpPrinterInfo7] -- Pointer to a PRINTER_INFO_2 struct.
//
//  Returns:    HRESULT
//
//  Modifies:
//
//  History:    11/09/95  RamV  Created
//
//----------------------------------------------------------------------------

HRESULT
CWinNTPrintQueue::MarshallAndSet(
    LPPRINTER_INFO_7 lpPrinterInfo7
    )

{
    HRESULT hr =S_OK;
    DWORD dwAction;
    LPTSTR   pszObjectGUID = NULL;
    BOOL fSetInfoNeeded = FALSE;

    hr = GetLPTSTRPropertyFromCache(
                    _pPropertyCache,
                    TEXT("ObjectGUID"),
                    &pszObjectGUID
                    );
    if(SUCCEEDED(hr)){
        fSetInfoNeeded = TRUE;
        lpPrinterInfo7->pszObjectGUID = pszObjectGUID;
    }

    hr = GetDWORDPropertyFromCache(
                    _pPropertyCache,
                    TEXT("Action"),
                    &dwAction
                    );

    if(SUCCEEDED(hr)){
        fSetInfoNeeded = TRUE;
        lpPrinterInfo7->dwAction = dwAction;
    }


    //
    // Need to do the set if flag is set
    //
    if (fSetInfoNeeded) {
        hr = SetPrinter7(lpPrinterInfo7,
                 _pszPrinterName);
        //
        // only this hr gets recorded
        //

        BAIL_IF_ERROR(hr);
    }
    else {
        //
        // Need to this - if we are here it means that the hr is
        // probably set as prop was not found in cache.
        hr = S_OK;
    }


cleanup:
    if(pszObjectGUID)
        FreeADsStr(pszObjectGUID);

    RRETURN(hr);

}


HRESULT
GetPrinterInfo7(
    THIS_ LPPRINTER_INFO_7 *lplpPrinterInfo7,
    LPWSTR  pszPrinterName
    )
{

    //
    // Do a GetPrinter call to pszPrinterName
    //

    BOOL fStatus = FALSE;
    PRINTER_DEFAULTS PrinterDefaults = {0, 0, PRINTER_ACCESS_USE |
                                            READ_CONTROL};
    DWORD LastError = 0;
    HANDLE hPrinter = NULL;
    LPBYTE pMem = NULL;
    HRESULT hr = S_OK;

    ADsAssert(pszPrinterName);
    fStatus = OpenPrinter(pszPrinterName,
                          &hPrinter,
                          &PrinterDefaults
                          );

    if (!fStatus) {
        LastError = GetLastError();
        switch (LastError) {

        case ERROR_ACCESS_DENIED:
        {
            PRINTER_DEFAULTS PrinterDefaults = {0, 0, PRINTER_ACCESS_USE};
            fStatus = OpenPrinter(pszPrinterName,
                                  &hPrinter,
                                  &PrinterDefaults
                                  );
            if (fStatus) {
                break;
            }
        }

        default:
            RRETURN(HRESULT_FROM_WIN32(GetLastError()));

    }
    }

    fStatus = WinNTGetPrinter(hPrinter,
                              7,
                              (LPBYTE *)&pMem
                              );
    if (!fStatus) {
        hr = HRESULT_FROM_WIN32(GetLastError());
        goto cleanup;
    }

    *lplpPrinterInfo7 = (LPPRINTER_INFO_7)pMem;

cleanup:

    if(hPrinter)
        fStatus = ClosePrinter(hPrinter);
    RRETURN(hr);
}




HRESULT
SetPrinter7(
    LPPRINTER_INFO_7 lpPrinterInfo7,
    LPTSTR   pszPrinterName
    )
{

    BOOL fStatus = FALSE;
    PRINTER_DEFAULTS PrinterDefaults = {0, 0, PRINTER_ALL_ACCESS};
    HANDLE hPrinter = NULL;
    HRESULT hr;

    ADsAssert(pszPrinterName);

    fStatus = OpenPrinter(pszPrinterName,
                          &hPrinter,
                          &PrinterDefaults
                          );

    if (!fStatus) {
        goto error;
    }

    fStatus = SetPrinter(hPrinter,
                         7,
                         (LPBYTE)lpPrinterInfo7,
                         0
                         );
    if (!fStatus) {
        goto error;
    }

    fStatus = ClosePrinter(hPrinter);

    RRETURN(S_OK);

error:
    hr = HRESULT_FROM_WIN32(GetLastError());
    if(hPrinter)
        fStatus = ClosePrinter(hPrinter);
    RRETURN(hr);

}


//+---------------------------------------------------------------------------
//
//  Function:   Unmarshall
//
//  Synopsis:   Unmarshalls information from a PRINTER_INFO_2 to a
//              WinNT Printer object.Frees PRINTER_INFO_2 object.
//
//  Arguments:  [lpPrinterInfo2] -- Pointer to a PRINTER_INFO_2 struct
//
//  Returns:    HRESULT
//
//  Modifies:   GeneralInfo and Operation Functional sets
//
//  History:    11/08/95  RamV   Created
//
//----------------------------------------------------------------------------

HRESULT
CWinNTPrintQueue::UnMarshall7(
    LPPRINTER_INFO_7 lpPrinterInfo7,
    BOOL fExplicit
    )
{
    HRESULT hr;
    VARIANT vPortNames;
    PNTOBJECT pNtObject;

    hr = SetLPTSTRPropertyInCache(_pPropertyCache,
                                  TEXT("ObjectGUID"),
                                  lpPrinterInfo7->pszObjectGUID,
                                  fExplicit
                                  );


    hr = SetDWORDPropertyInCache(_pPropertyCache,
                                  TEXT("Action"),
                                  lpPrinterInfo7->dwAction,
                                  fExplicit
                                  );
    RRETURN(S_OK);
}


#endif
=== C:/Users/treeman/Desktop/windows nt source code\Source\Win2K3\NT\ds\adsi\winnt\servhlp.cxx ===
//---------------------------------------------------------------------------
//
//  Microsoft Windows
//  Copyright (C) Microsoft Corporation, 1995
//
//  File:  servhlp.hxx
//
//  Contents:  helper functions for winnt service object
//
//
//  History:   12/11/95     ramv (Ram Viswanathan)    Created.
//
//--------------------------------------------------------------------------

#include "winnt.hxx"
#pragma hdrstop

//
// mapping WinNT Status Codes to ADs Status Codes and vice versa
//

typedef struct _ServiceStatusList {
    DWORD  dwWinNTServiceStatus;
    DWORD  dwADsServiceStatus;
} SERVICE_STATUS_LIST, *PSERVICE_STATUS_LIST;


SERVICE_STATUS_LIST ServiceStatusList[] =
{
{SERVICE_STOPPED, ADS_SERVICE_STOPPED },
{SERVICE_START_PENDING, ADS_SERVICE_START_PENDING },
{SERVICE_STOP_PENDING, ADS_SERVICE_STOP_PENDING },
{SERVICE_RUNNING, ADS_SERVICE_RUNNING },
{SERVICE_CONTINUE_PENDING, ADS_SERVICE_CONTINUE_PENDING },
{SERVICE_PAUSE_PENDING, ADS_SERVICE_PAUSE_PENDING },
{SERVICE_PAUSED, ADS_SERVICE_PAUSED },

};


typedef struct _ServiceTypeList {
DWORD  dwWinNTServiceType;
DWORD  dwADsServiceType;
} SERVICETYPELIST, *PSERVICETYPELIST;

typedef struct _StartTypeList {
DWORD  dwWinNTStartType;
DWORD  dwADsStartType;
} STARTTYPELIST, *PSTARTTYPELIST;

typedef struct _ErrorList {
DWORD   dwWinNTErrorControl;
DWORD   dwADsErrorControl;
} ERRORLIST, *PERRORLIST;


SERVICETYPELIST ServiceTypeList[] =
{
{ SERVICE_WIN32_OWN_PROCESS,ADS_SERVICE_OWN_PROCESS },
{ SERVICE_WIN32_SHARE_PROCESS,ADS_SERVICE_SHARE_PROCESS },
{ SERVICE_KERNEL_DRIVER,ADS_SERVICE_KERNEL_DRIVER},
{ SERVICE_FILE_SYSTEM_DRIVER,ADS_SERVICE_FILE_SYSTEM_DRIVER}
};


STARTTYPELIST StartTypeList[] =
{
{SERVICE_BOOT_START,ADS_SERVICE_BOOT_START },
{SERVICE_SYSTEM_START, ADS_SERVICE_SYSTEM_START},
{SERVICE_AUTO_START,ADS_SERVICE_AUTO_START },
{SERVICE_DEMAND_START, ADS_SERVICE_DEMAND_START},
{SERVICE_DISABLED, ADS_SERVICE_DISABLED}
};

ERRORLIST ErrorList[] =
{
{SERVICE_ERROR_IGNORE,ADS_SERVICE_ERROR_IGNORE },
{SERVICE_ERROR_NORMAL,ADS_SERVICE_ERROR_NORMAL },
{SERVICE_ERROR_SEVERE,ADS_SERVICE_ERROR_SEVERE },
{SERVICE_ERROR_CRITICAL,ADS_SERVICE_ERROR_CRITICAL}
};




BOOL ServiceStatusWinNTToADs( DWORD dwWinNTStatus,
DWORD *pdwADsStatus)
{
    BOOL found = FALSE;
    int i;

    for (i=0;i<7;i++){

        if(dwWinNTStatus == ServiceStatusList[i].dwWinNTServiceStatus){
            *pdwADsStatus = ServiceStatusList[i].dwADsServiceStatus;
            found = TRUE;
            break;
        }
    }
    return (found);

}

BOOL ServiceStatusADsToWinNT( DWORD dwADsStatus,
                               DWORD *pdwWinNTStatus)
{
    BOOL found = FALSE;
    int i;

    for (i=0;i<7;i++){

        if(dwADsStatus == ServiceStatusList[i].dwADsServiceStatus){
            *pdwWinNTStatus = ServiceStatusList[i].dwWinNTServiceStatus;
            found = TRUE;
            break;
        }
    }
    return (found);

}



HRESULT
WinNTEnumServices( LPTSTR szComputerName,
                  LPDWORD pdwServiceObjectReturned,
                  LPBYTE  *ppMem
                  )

{

    SC_HANDLE    schSCManager = NULL;
    LPBYTE       pMem        = NULL;
    DWORD  dwBytesNeeded =0;
    DWORD dwBufLen = 0;
    DWORD dwResumeHandle = 0;
    BOOL fStatus;
    DWORD dwLastError = NULL;
    HRESULT hr = S_OK;

    ADsAssert(pdwServiceObjectReturned);
    ADsAssert(ppMem);

    schSCManager = OpenSCManager(szComputerName,
                                 NULL,
                                 SC_MANAGER_ENUMERATE_SERVICE
                                 );

    if(schSCManager == NULL){
        hr =HRESULT_FROM_WIN32(GetLastError());
        goto cleanup;
    }

    //
    // enumerate all win32 services
    //

    fStatus = EnumServicesStatus(schSCManager,
                                 SERVICE_WIN32,
                                 SERVICE_ACTIVE|
                                 SERVICE_INACTIVE,
                                 (LPENUM_SERVICE_STATUS)pMem,
                                 dwBufLen,
                                 &dwBytesNeeded,
                                 pdwServiceObjectReturned,
                                 &dwResumeHandle
                                 );

    if(dwBytesNeeded==0){
        hr = S_FALSE;
        goto cleanup;
    }

    if (!fStatus) {
        dwLastError = GetLastError();
        switch (dwLastError) {
        case ERROR_INSUFFICIENT_BUFFER:
        case ERROR_MORE_DATA :
            pMem = (LPBYTE)AllocADsMem(dwBytesNeeded);
            dwBufLen = dwBytesNeeded;

            if (!pMem) {
                hr = E_OUTOFMEMORY;
                break;
            }

            fStatus = EnumServicesStatus(schSCManager,
                                         SERVICE_WIN32,
                                         SERVICE_ACTIVE|
                                         SERVICE_INACTIVE,
                                         (LPENUM_SERVICE_STATUS)pMem,
                                         dwBufLen,
                                         &dwBytesNeeded,
                                         pdwServiceObjectReturned,
                                         &dwResumeHandle
                                         );

            if (!fStatus) {
                hr = HRESULT_FROM_WIN32(GetLastError());
                break;
            }

            break;

        default:
            hr = HRESULT_FROM_WIN32(GetLastError());
            break;

        }
        BAIL_IF_ERROR(hr);
    }

    *ppMem = pMem;

cleanup:
    if(FAILED(hr)){
        if(pMem){
            FreeADsMem(pMem);
        }
    }

    //
    // Close the handle to service control manager
    //
    if (schSCManager) {
        CloseServiceHandle(schSCManager);
    }

    RRETURN(hr);

}

BOOL ServiceTypeWinNTToADs(DWORD dwServiceType,
                             DWORD  *pdwADsServiceType )
{
    BOOL found = FALSE;
    int i;

    for (i=0; i<4; i++){

        if(dwServiceType == ServiceTypeList[i].dwWinNTServiceType){
            *pdwADsServiceType = ServiceTypeList[i].dwADsServiceType;
            found = TRUE;
            break;
        }
        break;
    }
    return(found);
}

BOOL StartTypeWinNTToADs(DWORD dwStartType,
                           DWORD  *pdwADsStartType )

{
    BOOL found = FALSE;
    int i;

    for (i=0; i<5; i++){

        if(dwStartType == StartTypeList[i].dwWinNTStartType){
            *pdwADsStartType = StartTypeList[i].dwADsStartType;
            found = TRUE;
            break;
        }
    }
    return(found);
}

BOOL ErrorControlWinNTToADs(DWORD dwErrorControl,
                              DWORD  *pdwADsErrorControl)

{
    BOOL found = FALSE;
    int i;

    for (i=0; i<4; i++){

        if(dwErrorControl == ErrorList[i].dwWinNTErrorControl){
            *pdwADsErrorControl = ErrorList[i].dwADsErrorControl;
            found = TRUE;
            break;
        }
    }
    return(found);

}

BOOL ServiceTypeADsToWinNT(DWORD  dwADsServiceType,
                             DWORD *pdwServiceType)
{
    BOOL found = FALSE;
    int i;

    for (i=0; i<4; i++){

        if(dwADsServiceType == ServiceTypeList[i].dwADsServiceType){
            *pdwServiceType = ServiceTypeList[i].dwWinNTServiceType;
            found = TRUE;
            break;
        }
        break;
    }
    return(found);
}


BOOL StartTypeADsToWinNT(DWORD  dwADsStartType,
                           DWORD *pdwStartType)

{
    BOOL found = FALSE;
    int i;

    for (i=0; i<5; i++){

        if(dwADsStartType == StartTypeList[i].dwADsStartType){
            *pdwStartType = StartTypeList[i].dwWinNTStartType;
            found = TRUE;
            break;
        }
    }
    return(found);

}

BOOL ErrorControlADsToWinNT(DWORD  dwADsErrorControl,
                              DWORD *pdwErrorControl )

{
    BOOL found = FALSE;
    int i;

    for (i=0; i<4; i++){

        if(dwADsErrorControl == ErrorList[i].dwADsErrorControl){
            *pdwErrorControl = ErrorList[i].dwWinNTErrorControl;
            found = TRUE;
            break;
        }
    }
    return(found);


}

HRESULT WinNTDeleteService(POBJECTINFO pObjectInfo)
{
    SC_HANDLE schService = NULL;
    SC_HANDLE schSCManager = NULL;
    HRESULT   hr = S_OK;
    BOOL fRetval = FALSE;

    schSCManager = OpenSCManager(pObjectInfo->ComponentArray[1],
                                 NULL,
                                 SC_MANAGER_ALL_ACCESS
                                 );

    if(schSCManager == NULL){
        hr = HRESULT_FROM_WIN32(GetLastError());
        goto cleanup;
    }

    schService = OpenService(schSCManager,
                             pObjectInfo->ComponentArray[2],
                             DELETE );

    if(schService == NULL){
        hr = HRESULT_FROM_WIN32(GetLastError());
        goto cleanup;
    }

    fRetval = DeleteService(schService);

    if(!fRetval){
        hr = HRESULT_FROM_WIN32(GetLastError());
        goto cleanup;
    }


cleanup:
    if(schSCManager){
        fRetval = CloseServiceHandle(schSCManager);
        if(!fRetval && SUCCEEDED(hr)){
            RRETURN(HRESULT_FROM_WIN32(GetLastError()));
        }
    }
    if(schService){
        fRetval = CloseServiceHandle(schService);
        if(!fRetval && SUCCEEDED(hr)){
            RRETURN(HRESULT_FROM_WIN32(GetLastError()));
        }
    }
    RRETURN(hr);
}
=== C:/Users/treeman/Desktop/windows nt source code\Source\Win2K3\NT\ds\adsi\winnt\object.cxx ===
//---------------------------------------------------------------------------
//
//  Microsoft Windows
//  Copyright (C) Microsoft Corporation, 1992 - 1995
//
//  File:  object.cxx
//
//  Contents:  Windows NT 3.5 Enumerator Code
//
//  History:
//----------------------------------------------------------------------------

#include "winnt.hxx"
#pragma hdrstop

HRESULT
BuildObjectArray(
    VARIANT var,
    SAFEARRAY ** ppFilter,
    DWORD * pdwNumElements
    );

HRESULT
BuildDefaultObjectArray(
    PFILTERS  pFilters,
    DWORD dwMaxFilters,
    SAFEARRAY ** ppFilter,
    DWORD * pdwNumElements
    );


ObjectTypeList::ObjectTypeList()
{
    _pObjList = NULL;
    _dwCurrentIndex = 0;
    _dwMaxElements = 0;
    _dwUBound  = 0;
    _dwLBound = 0;

}


HRESULT
ObjectTypeList::CreateObjectTypeList(
    VARIANT vFilter,
    ObjectTypeList ** ppObjectTypeList
    )
{
    ObjectTypeList * pObjectTypeList = NULL;
    HRESULT hr = S_OK;

    pObjectTypeList = new ObjectTypeList;

    if (!pObjectTypeList) {
        hr = E_OUTOFMEMORY;
        BAIL_ON_FAILURE(hr);
    }

    hr = BuildObjectArray(
            vFilter,
            &pObjectTypeList->_pObjList,
            &pObjectTypeList->_dwMaxElements
            );

    if (FAILED(hr)) {

        hr = BuildDefaultObjectArray(
                gpFilters,
                gdwMaxFilters,
                &pObjectTypeList->_pObjList,
                &pObjectTypeList->_dwMaxElements
                );

        BAIL_ON_FAILURE(hr);
    }

    hr = SafeArrayGetUBound(
                pObjectTypeList->_pObjList,
                1,
                (long FAR *)&pObjectTypeList->_dwUBound
                );
    BAIL_ON_FAILURE(hr);

    hr = SafeArrayGetLBound(
                pObjectTypeList->_pObjList,
                1,
                (long FAR *)&pObjectTypeList->_dwLBound
                );
    BAIL_ON_FAILURE(hr);

    pObjectTypeList->_dwCurrentIndex = pObjectTypeList->_dwLBound;

    *ppObjectTypeList = pObjectTypeList;

    RRETURN(S_OK);


error:
    if (pObjectTypeList) {
        delete pObjectTypeList;
    }
    RRETURN_EXP_IF_ERR(hr);

}


ObjectTypeList::~ObjectTypeList()
{
    HRESULT hr = S_OK;
    if (_pObjList) {
        hr = SafeArrayDestroy(_pObjList);
    }
}


HRESULT
ObjectTypeList::GetCurrentObject(
    PDWORD pdwObject
    )
{
    HRESULT hr = S_OK;

    if (_dwCurrentIndex > _dwUBound) {
        return(E_FAIL);
    }

    hr = SafeArrayGetElement(
                    _pObjList,
                    (long FAR *)&_dwCurrentIndex,
                    (void *)pdwObject
                    );
    RRETURN_EXP_IF_ERR(hr);
}

HRESULT
ObjectTypeList::Next()
{
    HRESULT hr = S_OK;

    _dwCurrentIndex++;

    if (_dwCurrentIndex > _dwUBound) {
        return(E_FAIL);
    }

    RRETURN_EXP_IF_ERR(hr);
}



HRESULT
ObjectTypeList::Reset()
{
    HRESULT hr = S_OK;

    _dwCurrentIndex = _dwLBound;

    return(hr);

}


HRESULT
IsValidFilter(
    LPWSTR ObjectName,
    DWORD *pdwFilterId,
    PFILTERS pFilters,
    DWORD dwMaxFilters
    )
{

    DWORD i = 0;

    for (i = 0; i < dwMaxFilters; i++) {

#ifdef WIN95
        if (!_wcsicmp(ObjectName, (pFilters + i)->szObjectName)) {
#else
        if (CompareStringW(
                LOCALE_SYSTEM_DEFAULT,
                NORM_IGNORECASE,
                ObjectName,
                -1,
                (pFilters +i)->szObjectName,
                -1
                ) == CSTR_EQUAL ) {
#endif
            *pdwFilterId = (pFilters + i)->dwFilterId;
            RRETURN(S_OK);
        }

    }
    *pdwFilterId = 0;
    RRETURN(E_FAIL);
}



HRESULT
BuildDefaultObjectArray(
    PFILTERS  pFilters,
    DWORD dwMaxFilters,
    SAFEARRAY ** ppFilter,
    DWORD * pdwNumElements
    )
{
    DWORD i;
    HRESULT hr = S_OK;
    SAFEARRAYBOUND sabNewArray;
    SAFEARRAY * pFilter = NULL;

    sabNewArray.cElements = dwMaxFilters;
    sabNewArray.lLbound =  0;

    pFilter =   SafeArrayCreate(
                        VT_I4,
                        1,
                        &sabNewArray
                        );
    if (!pFilter){
        hr = E_OUTOFMEMORY;
        BAIL_ON_FAILURE(hr);
    }

    for (i = 0; i < dwMaxFilters; i++) {

        hr = SafeArrayPutElement(
                pFilter,
                (long *)&i,
                (void *)&((pFilters + i)->dwFilterId)
            );
        BAIL_ON_FAILURE(hr);
    }

    *ppFilter = pFilter;
    *pdwNumElements = dwMaxFilters;

    RRETURN(S_OK);

error:
    if (pFilter) {
        SafeArrayDestroy(pFilter);
    }

    *ppFilter = NULL;
    *pdwNumElements = 0;
    RRETURN(hr);
}



HRESULT
BuildObjectArray(
    VARIANT var,
    SAFEARRAY ** ppFilter,
    DWORD * pdwNumElements
    )
{
    LONG uDestCount = 0;
    LONG dwSLBound = 0;
    LONG dwSUBound = 0;
    VARIANT v;
    VARIANT varDest;
    LONG i;
    HRESULT hr = S_OK;
    SAFEARRAYBOUND sabNewArray;
    DWORD dwFilterId;
    SAFEARRAY * pFilter = NULL;

    if (!(V_VT(&var) == (VT_VARIANT|VT_ARRAY))) {
        RRETURN(E_FAIL);
    }

    //
    // Check that there is only one dimension in this array
    //

    if ((V_ARRAY(&var))->cDims != 1) {
        hr = E_FAIL;
        BAIL_ON_FAILURE(hr);
    }
    //
    // Check that there is atleast one element in this array
    //

    if ((V_ARRAY(&var))->rgsabound[0].cElements == 0){
        hr = E_FAIL;
        BAIL_ON_FAILURE(hr);
    }

    //
    // We know that this is a valid single dimension array
    //

    hr = SafeArrayGetLBound(V_ARRAY(&var),
                            1,
                            (long FAR *)&dwSLBound
                            );
    BAIL_ON_FAILURE(hr);

    hr = SafeArrayGetUBound(V_ARRAY(&var),
                            1,
                            (long FAR *)&dwSUBound
                            );
    BAIL_ON_FAILURE(hr);

    sabNewArray.cElements = dwSUBound - dwSLBound + 1;
    sabNewArray.lLbound = dwSLBound;

    pFilter = SafeArrayCreate(
                    VT_I4,
                    1,
                    &sabNewArray
                    );


    if (!pFilter) {
        hr = E_OUTOFMEMORY;
        BAIL_ON_FAILURE(hr);
    }

    for (i = dwSLBound; i <= dwSUBound; i++) {
        VariantInit(&v);
        hr = SafeArrayGetElement(V_ARRAY(&var),
                                (long FAR *)&i,
                                &v
                                );
        if (FAILED(hr)) {
            continue;
        }


        hr = IsValidFilter(
                V_BSTR(&v),
                &dwFilterId,
                gpFilters,
                gdwMaxFilters
                );

        if (FAILED(hr)) {

            VariantClear(&v);
            continue;
        }

        VariantClear(&v);

        hr = SafeArrayPutElement(
                pFilter,
                (long*)&uDestCount,
                (void *)&dwFilterId
                );

        if(FAILED(hr)){
            continue;
        }

        uDestCount++;

    }

    //
    // There was nothing of value that could be retrieved from the
    // filter.
    //

    if ( !uDestCount) {
        hr = E_FAIL;
        BAIL_ON_FAILURE(hr);
    }


    *pdwNumElements  = uDestCount;
    *ppFilter = pFilter;

    RRETURN(S_OK);

error:

    if (pFilter) {

        SafeArrayDestroy(pFilter);
    }
    *ppFilter = NULL;
    *pdwNumElements = 0;
    RRETURN_EXP_IF_ERR(hr);
}
=== C:/Users/treeman/Desktop/windows nt source code\Source\Win2K3\NT\ds\adsi\winnt\system.cxx ===
//---------------------------------------------------------------------------
//
//  Microsoft Windows
//  Copyright (C) Microsoft Corporation, 1992 - 1995
//
//  File:  cPathname.cxx
//
//  Contents:  Pathname object
//
//  History:   11-1-95     krishnag    Created.
//
//----------------------------------------------------------------------------

#include "winnt.hxx"
#pragma hdrstop

extern "C" {

typedef struct _WKSTA_USER_INFO_1A {
    LPSTR  wkui1_username;
    LPSTR  wkui1_logon_domain;
    LPSTR  wkui1_oth_domains;
    LPSTR  wkui1_logon_server;
}WKSTA_USER_INFO_1A, *PWKSTA_USER_INFO_1A, *LPWKSTA_USER_INFO_1A;


NET_API_STATUS NET_API_FUNCTION
NetWkstaUserGetInfoA (
    IN  LPSTR reserved,
    IN  DWORD   level,
    OUT LPBYTE  *bufptr
    );

}

//  Class CWinNTSystemInfo

DEFINE_IDispatch_Implementation(CWinNTSystemInfo)

//+---------------------------------------------------------------------------
// Function:    CWinNTSystemInfo::CWinNTSystemInfo
//
// Synopsis:    Constructor
//
// Arguments:
//
// Returns:     HRESULT
//
// Modifies:      -
//
// History:
//
//----------------------------------------------------------------------------
CWinNTSystemInfo::CWinNTSystemInfo():
        _pDispMgr(NULL)
{
    ENLIST_TRACKING(CWinNTSystemInfo);
}


//+---------------------------------------------------------------------------
// Function:    CWinNTSystemInfo::CreateWinNTSystemInfo
//
// Synopsis:
//
// Arguments:
//
// Returns:     HRESULT
//
// Modifies:      -
//
// History:
//
//----------------------------------------------------------------------------
HRESULT
CWinNTSystemInfo::CreateWinNTSystemInfo(
    REFIID riid,
    void **ppvObj
    )
{
    CWinNTSystemInfo FAR * pWinNTSystemInfo = NULL;
    HRESULT hr = S_OK;

    hr = AllocateWinNTSystemInfoObject(&pWinNTSystemInfo);
    BAIL_ON_FAILURE(hr);

    hr = pWinNTSystemInfo->QueryInterface(riid, ppvObj);
    BAIL_ON_FAILURE(hr);

    pWinNTSystemInfo->Release();

    RRETURN(hr);

error:
    delete pWinNTSystemInfo;

    RRETURN(hr);
}


//+---------------------------------------------------------------------------
// Function:    CWinNTSystemInfo::~CWinNTSystemInfo
//
// Synopsis:
//
// Arguments:
//
// Returns:     HRESULT
//
// Modifies:      -
//
// History:
//
//----------------------------------------------------------------------------
CWinNTSystemInfo::~CWinNTSystemInfo( )
{

    delete _pDispMgr;
}

//+---------------------------------------------------------------------------
// Function:    CWinNTSystemInfo::QueryInterface
//
// Synopsis:
//
// Arguments:
//
// Returns:     HRESULT
//
// Modifies:      -
//
// History:
//
//----------------------------------------------------------------------------
STDMETHODIMP
CWinNTSystemInfo::QueryInterface(
    REFIID iid,
    LPVOID FAR* ppv
    )
{
    if (ppv == NULL) {
        RRETURN(E_POINTER);
    }

    if (IsEqualIID(iid, IID_IUnknown))
    {
        *ppv = (IADsWinNTSystemInfo FAR *) this;
    }
    else if (IsEqualIID(iid, IID_IADsWinNTSystemInfo))
    {
        *ppv = (IADsWinNTSystemInfo FAR *) this;
    }
    else if (IsEqualIID(iid, IID_IDispatch))
    {
        *ppv = (IADsWinNTSystemInfo FAR *) this;
    }
    else if (IsEqualIID(iid, IID_ISupportErrorInfo))
    {
        *ppv = (ISupportErrorInfo FAR *) this;
    }
    else
    {
        *ppv = NULL;
        return E_NOINTERFACE;
    }
    AddRef();
    return NOERROR;
}


//+---------------------------------------------------------------------------
// Function:    CWinNTSystemInfo::AllocateWinNTSystemInfoObject
//
// Synopsis:
//
// Arguments:
//
// Returns:     HRESULT
//
// Modifies:      -
//
// History:
//
//----------------------------------------------------------------------------
HRESULT
CWinNTSystemInfo::AllocateWinNTSystemInfoObject(
    CWinNTSystemInfo  ** ppWinNTSystemInfo
    )
{
    CWinNTSystemInfo FAR * pWinNTSystemInfo = NULL;
    CAggregatorDispMgr FAR * pDispMgr = NULL;
    HRESULT hr = S_OK;

    pWinNTSystemInfo = new CWinNTSystemInfo();
    if (pWinNTSystemInfo == NULL) {
        hr = E_OUTOFMEMORY;
    }
    BAIL_ON_FAILURE(hr);

    pDispMgr = new CAggregatorDispMgr;
    if (pDispMgr == NULL) {
        hr = E_OUTOFMEMORY;
    }
    BAIL_ON_FAILURE(hr);

    hr = LoadTypeInfoEntry(
                pDispMgr,
                LIBID_ADs,
                IID_IADsWinNTSystemInfo,
                (IADsWinNTSystemInfo *)pWinNTSystemInfo,
                DISPID_REGULAR
                );
    BAIL_ON_FAILURE(hr);

    pWinNTSystemInfo->_pDispMgr = pDispMgr;
    *ppWinNTSystemInfo = pWinNTSystemInfo;

    RRETURN(hr);

error:

    delete pWinNTSystemInfo;
    delete  pDispMgr;

    RRETURN_EXP_IF_ERR(hr);
}

//+---------------------------------------------------------------------------
// Function:    CWinNTSystemInfo::InterfaceSupportsErrorInfo
//
// Synopsis:
//
// Arguments:
//
// Returns:     HRESULT
//
// Modifies:      -
//
// History:
//
//----------------------------------------------------------------------------
HRESULT
CWinNTSystemInfo::InterfaceSupportsErrorInfo(THIS_ REFIID riid)
{
    if (IsEqualIID(riid, IID_IADsWinNTSystemInfo)) {
        RRETURN(S_OK);
    } else {
        RRETURN(S_FALSE);
    }
}


HRESULT
CWinNTSystemInfo::get_UserName(
    BSTR * bstrUserName
    )
{
    PWSTR pszUserName = NULL;
    ULONG uLength;
    HRESULT hr;

    //
    // Validate parameters
    //
    if ( !bstrUserName )
    {
        RRETURN(HRESULT_FROM_WIN32(ERROR_INVALID_PARAMETER));
    }

    //
    // Get length of buffer to be allocated
    //
    uLength = 0;
    GetUserName(NULL, &uLength);

    if (uLength > 0)
    {
        //
        // Allocate memory and do the real work
        //
        pszUserName = (PWSTR)AllocADsMem(uLength * sizeof(WCHAR));
        if (!pszUserName)
        {
            RRETURN(E_OUTOFMEMORY);
        }

        if (GetUserName(pszUserName, &uLength))
        {
            hr = ADsAllocString(pszUserName, bstrUserName);
            BAIL_ON_FAILURE(hr);
        }
        else
            hr = HRESULT_FROM_WIN32(GetLastError());
    }
    else
        hr = HRESULT_FROM_WIN32(GetLastError());

error:
    if (pszUserName)
    {
        FreeADsMem(pszUserName);
    }

    RRETURN(hr);
}

HRESULT
CWinNTSystemInfo::get_ComputerName(
    BSTR * bstrComputerName
    )
{
    PWSTR pszComputerName = NULL;
    ULONG uLength;
    HRESULT hr;

    //
    // Validate parameters
    //
    if (!bstrComputerName)
    {
        RRETURN(HRESULT_FROM_WIN32(ERROR_INVALID_PARAMETER));
    }

    //
    // Get length of buffer to be allocated
    //
    uLength = 0;
    GetComputerName(NULL, &uLength);

    if (uLength > 0)
    {
        //
        // Allocated memory and do the real work
        //
        pszComputerName = (PWSTR)AllocADsMem(uLength * sizeof(WCHAR));
        if (!pszComputerName)
        {
            RRETURN(E_OUTOFMEMORY);
        }

        if (GetComputerName(pszComputerName, &uLength))
        {
            hr = ADsAllocString(pszComputerName, bstrComputerName);
            BAIL_ON_FAILURE(hr);
        }
        else
            hr = HRESULT_FROM_WIN32(GetLastError());
    }
    else
        hr = HRESULT_FROM_WIN32(GetLastError());

error:
    if (pszComputerName)
    {
        FreeADsMem(pszComputerName);
    }

    RRETURN(hr);
}

HRESULT
CWinNTSystemInfo::get_DomainName(
    BSTR * bstrDomainName
    )
{
    PWKSTA_USER_INFO_1  pInfo = NULL;
    PWKSTA_USER_INFO_1A pInfoA = NULL;
    DWORD err;
    HRESULT hr = S_OK;
    PWSTR pszDomainName = NULL;

    //
    // Validate parameters
    //
    if (!bstrDomainName )
    {
        RRETURN(HRESULT_FROM_WIN32(ERROR_INVALID_PARAMETER));
    }

    //
    // Call NetWkstaUserGetInfo to find domain name
    //
#if (defined WIN95)
    err = NetWkstaUserGetInfoA(NULL, 1, (LPBYTE *) &pInfoA);
    if (err != ERROR_SUCCESS)
    {
        RRETURN(HRESULT_FROM_WIN32(err));
    }

    pszDomainName = (PWSTR)AllocADsMem((lstrlenA(pInfoA->wkui1_logon_domain) + 1) * sizeof(WCHAR));
    if (!pszDomainName)
    {
        BAIL_ON_FAILURE(hr = E_OUTOFMEMORY);
    }
    if (MultiByteToWideChar(CP_ACP,
                            MB_PRECOMPOSED,
                            pInfoA->wkui1_logon_domain,
                            -1,
                            pszDomainName,
                            lstrlenA(pInfoA->wkui1_logon_domain) + 1) == 0)
    {
        BAIL_ON_FAILURE(hr = HRESULT_FROM_WIN32(GetLastError()));
    }

    hr = ADsAllocString(pszDomainName, bstrDomainName);
    BAIL_ON_FAILURE(hr);
#else
    err = NetWkstaUserGetInfo(NULL, 1, (LPBYTE*) &pInfo);
    if (err != ERROR_SUCCESS)
    {
        RRETURN(HRESULT_FROM_WIN32(err));
    }

    hr = ADsAllocString((LPWSTR)pInfo->wkui1_logon_domain, bstrDomainName);
    BAIL_ON_FAILURE(hr);
#endif

error:
    if (pInfo)
    {
        NetApiBufferFree(pInfo);
    }

    if (pInfoA)
    {
        NetApiBufferFree(pInfoA);
    }

    if (pszDomainName)
    {
        FreeADsMem(pszDomainName);
    }

    RRETURN(hr);
}

HRESULT
CWinNTSystemInfo::get_PDC(
    BSTR * bstrPDC
    )
{
    PWSTR pszPDC = NULL;
    HRESULT hr;
    DWORD err;

    //
    // Validate parameters
    //
    if (!bstrPDC )
    {
        RRETURN(HRESULT_FROM_WIN32(ERROR_INVALID_PARAMETER));
    }

    err = NetGetDCName(NULL, NULL, (LPBYTE*)&pszPDC);

    if (err != ERROR_SUCCESS)
    {
        RRETURN(HRESULT_FROM_WIN32(GetLastError()));
    }

    hr = ADsAllocString(&pszPDC[2], bstrPDC);   // remove '\\';
    BAIL_ON_FAILURE(hr);

error:
    if (pszPDC)
    {
        NetApiBufferFree(pszPDC);
    }

    return hr;
}


STDMETHODIMP
CWinNTSystemInfoCF::CreateInstance(
    IUnknown * pUnkOuter,
    REFIID iid,
    LPVOID * ppv
    )
{
    HRESULT     hr = E_FAIL;

    if (pUnkOuter)
        RRETURN(E_FAIL);

    hr = CWinNTSystemInfo::CreateWinNTSystemInfo(
                iid,
                ppv
                );

    RRETURN(hr);
}
=== C:/Users/treeman/Desktop/windows nt source code\Source\Win2K3\NT\ds\adsi\winnt\umi_i.c ===
#pragma warning( disable: 4049 )  /* more than 64k source lines */

/* this ALWAYS GENERATED file contains the IIDs and CLSIDs */

/* link this file in with the server and any clients */


 /* File created by MIDL compiler version 6.00.0328 */
/* Compiler settings for umi.idl:
    Oicf (OptLev=i2), W1, Zp8, env=Win32 (32b run)
    protocol : dce , ms_ext, c_ext
    error checks: allocation ref bounds_check enum stub_data 
    VC __declspec() decoration level: 
         __declspec(uuid()), __declspec(selectany), __declspec(novtable)
         DECLSPEC_UUID(), MIDL_INTERFACE()
*/
//@@MIDL_FILE_HEADING(  )

#if !defined(_M_IA64) && !defined(_M_AXP64)

#ifdef __cplusplus
extern "C"{
#endif 


#include <rpc.h>
#include <rpcndr.h>

#ifdef _MIDL_USE_GUIDDEF_

#ifndef INITGUID
#define INITGUID
#include <guiddef.h>
#undef INITGUID
#else
#include <guiddef.h>
#endif

#define MIDL_DEFINE_GUID(type,name,l,w1,w2,b1,b2,b3,b4,b5,b6,b7,b8) \
        DEFINE_GUID(name,l,w1,w2,b1,b2,b3,b4,b5,b6,b7,b8)

#else // !_MIDL_USE_GUIDDEF_

#ifndef __IID_DEFINED__
#define __IID_DEFINED__

typedef struct _IID
{
    unsigned long x;
    unsigned short s1;
    unsigned short s2;
    unsigned char  c[8];
} IID;

#endif // __IID_DEFINED__

#ifndef CLSID_DEFINED
#define CLSID_DEFINED
typedef IID CLSID;
#endif // CLSID_DEFINED

#define MIDL_DEFINE_GUID(type,name,l,w1,w2,b1,b2,b3,b4,b5,b6,b7,b8) \
        const type name = {l,w1,w2,{b1,b2,b3,b4,b5,b6,b7,b8}}

#endif !_MIDL_USE_GUIDDEF_

MIDL_DEFINE_GUID(IID, LIBID_UMI_V6,0x12575a7a,0xd9db,0x11d3,0xa1,0x1f,0x00,0x10,0x5a,0x1f,0x51,0x5a);


MIDL_DEFINE_GUID(IID, IID_IUmiPropList,0x12575a7b,0xd9db,0x11d3,0xa1,0x1f,0x00,0x10,0x5a,0x1f,0x51,0x5a);


MIDL_DEFINE_GUID(IID, IID_IUmiBaseObject,0x12575a7c,0xd9db,0x11d3,0xa1,0x1f,0x00,0x10,0x5a,0x1f,0x51,0x5a);


MIDL_DEFINE_GUID(IID, IID_IUmiObject,0x5ed7ee23,0x64a4,0x11d3,0xa0,0xda,0x00,0x10,0x5a,0x1f,0x51,0x5a);


MIDL_DEFINE_GUID(IID, IID_IUmiConnection,0x5ed7ee20,0x64a4,0x11d3,0xa0,0xda,0x00,0x10,0x5a,0x1f,0x51,0x5a);


MIDL_DEFINE_GUID(IID, IID_IUmiContainer,0x5ed7ee21,0x64a4,0x11d3,0xa0,0xda,0x00,0x10,0x5a,0x1f,0x51,0x5a);


MIDL_DEFINE_GUID(IID, IID_IUmiCursor,0x5ed7ee26,0x64a4,0x11d3,0xa0,0xda,0x00,0x10,0x5a,0x1f,0x51,0x5a);


MIDL_DEFINE_GUID(IID, IID_IUmiObjectSink,0x5ed7ee24,0x64a4,0x11d3,0xa0,0xda,0x00,0x10,0x5a,0x1f,0x51,0x5a);


MIDL_DEFINE_GUID(IID, IID_IUmiURLKeyList,0xcf779c98,0x4739,0x4fd4,0xa4,0x15,0xda,0x93,0x7a,0x59,0x9f,0x2f);


MIDL_DEFINE_GUID(IID, IID_IUmiURL,0x12575a7d,0xd9db,0x11d3,0xa1,0x1f,0x00,0x10,0x5a,0x1f,0x51,0x5a);


MIDL_DEFINE_GUID(IID, IID_IUmiQuery,0x12575a7e,0xd9db,0x11d3,0xa1,0x1f,0x00,0x10,0x5a,0x1f,0x51,0x5a);


MIDL_DEFINE_GUID(IID, IID_IUmiCustomInterfaceFactory,0x14CD599E,0x2BE7,0x4c6f,0xB9,0x5B,0xB1,0x50,0xDC,0xD9,0x35,0x85);


MIDL_DEFINE_GUID(CLSID, CLSID_UmiDefURL,0xd4b21cc2,0xf2a5,0x453e,0x84,0x59,0xb2,0x7f,0x36,0x2c,0xb0,0xe0);

#undef MIDL_DEFINE_GUID

#ifdef __cplusplus
}
#endif



#endif /* !defined(_M_IA64) && !defined(_M_AXP64)*/


#pragma warning( disable: 4049 )  /* more than 64k source lines */

/* this ALWAYS GENERATED file contains the IIDs and CLSIDs */

/* link this file in with the server and any clients */


 /* File created by MIDL compiler version 6.00.0328 */
/* Compiler settings for umi.idl:
    Oicf (OptLev=i2), W1, Zp8, env=Win64 (32b run,appending)
    protocol : dce , ms_ext, c_ext, robust
    error checks: allocation ref bounds_check enum stub_data 
    VC __declspec() decoration level: 
         __declspec(uuid()), __declspec(selectany), __declspec(novtable)
         DECLSPEC_UUID(), MIDL_INTERFACE()
*/
//@@MIDL_FILE_HEADING(  )

#if defined(_M_IA64) || defined(_M_AXP64)

#ifdef __cplusplus
extern "C"{
#endif 


#include <rpc.h>
#include <rpcndr.h>

#ifdef _MIDL_USE_GUIDDEF_

#ifndef INITGUID
#define INITGUID
#include <guiddef.h>
#undef INITGUID
#else
#include <guiddef.h>
#endif

#define MIDL_DEFINE_GUID(type,name,l,w1,w2,b1,b2,b3,b4,b5,b6,b7,b8) \
        DEFINE_GUID(name,l,w1,w2,b1,b2,b3,b4,b5,b6,b7,b8)

#else // !_MIDL_USE_GUIDDEF_

#ifndef __IID_DEFINED__
#define __IID_DEFINED__

typedef struct _IID
{
    unsigned long x;
    unsigned short s1;
    unsigned short s2;
    unsigned char  c[8];
} IID;

#endif // __IID_DEFINED__

#ifndef CLSID_DEFINED
#define CLSID_DEFINED
typedef IID CLSID;
#endif // CLSID_DEFINED

#define MIDL_DEFINE_GUID(type,name,l,w1,w2,b1,b2,b3,b4,b5,b6,b7,b8) \
        const type name = {l,w1,w2,{b1,b2,b3,b4,b5,b6,b7,b8}}

#endif !_MIDL_USE_GUIDDEF_

MIDL_DEFINE_GUID(IID, LIBID_UMI_V6,0x12575a7a,0xd9db,0x11d3,0xa1,0x1f,0x00,0x10,0x5a,0x1f,0x51,0x5a);


MIDL_DEFINE_GUID(IID, IID_IUmiPropList,0x12575a7b,0xd9db,0x11d3,0xa1,0x1f,0x00,0x10,0x5a,0x1f,0x51,0x5a);


MIDL_DEFINE_GUID(IID, IID_IUmiBaseObject,0x12575a7c,0xd9db,0x11d3,0xa1,0x1f,0x00,0x10,0x5a,0x1f,0x51,0x5a);


MIDL_DEFINE_GUID(IID, IID_IUmiObject,0x5ed7ee23,0x64a4,0x11d3,0xa0,0xda,0x00,0x10,0x5a,0x1f,0x51,0x5a);


MIDL_DEFINE_GUID(IID, IID_IUmiConnection,0x5ed7ee20,0x64a4,0x11d3,0xa0,0xda,0x00,0x10,0x5a,0x1f,0x51,0x5a);


MIDL_DEFINE_GUID(IID, IID_IUmiContainer,0x5ed7ee21,0x64a4,0x11d3,0xa0,0xda,0x00,0x10,0x5a,0x1f,0x51,0x5a);


MIDL_DEFINE_GUID(IID, IID_IUmiCursor,0x5ed7ee26,0x64a4,0x11d3,0xa0,0xda,0x00,0x10,0x5a,0x1f,0x51,0x5a);


MIDL_DEFINE_GUID(IID, IID_IUmiObjectSink,0x5ed7ee24,0x64a4,0x11d3,0xa0,0xda,0x00,0x10,0x5a,0x1f,0x51,0x5a);


MIDL_DEFINE_GUID(IID, IID_IUmiURLKeyList,0xcf779c98,0x4739,0x4fd4,0xa4,0x15,0xda,0x93,0x7a,0x59,0x9f,0x2f);


MIDL_DEFINE_GUID(IID, IID_IUmiURL,0x12575a7d,0xd9db,0x11d3,0xa1,0x1f,0x00,0x10,0x5a,0x1f,0x51,0x5a);


MIDL_DEFINE_GUID(IID, IID_IUmiQuery,0x12575a7e,0xd9db,0x11d3,0xa1,0x1f,0x00,0x10,0x5a,0x1f,0x51,0x5a);


MIDL_DEFINE_GUID(IID, IID_IUmiCustomInterfaceFactory,0x14CD599E,0x2BE7,0x4c6f,0xB9,0x5B,0xB1,0x50,0xDC,0xD9,0x35,0x85);


MIDL_DEFINE_GUID(CLSID, CLSID_UmiDefURL,0xd4b21cc2,0xf2a5,0x453e,0x84,0x59,0xb2,0x7f,0x36,0x2c,0xb0,0xe0);

#undef MIDL_DEFINE_GUID

#ifdef __cplusplus
}
#endif



#endif /* defined(_M_IA64) || defined(_M_AXP64)*/
=== C:/Users/treeman/Desktop/windows nt source code\Source\Win2K3\NT\ds\adsi\winnt\parse.cxx ===
//---------------------------------------------------------------------------
//
//  Microsoft Windows
//  Copyright (C) Microsoft Corporation, 1992 - 1995
//
//  File:  parse.cxx
//
//  Contents:  Windows NT 3.5 GetObject functionality
//
//  History:
//----------------------------------------------------------------------------
#include "winnt.hxx"
#pragma hdrstop

KWDLIST KeywordList[MAX_KEYWORDS] =
{
    { TOKEN_DOMAIN, L"domain"},
    { TOKEN_USER, L"user"},
    { TOKEN_GROUP, L"group"},
    { TOKEN_LOCALGROUP, L"localgroup"},
    { TOKEN_GLOBALGROUP, L"globalgroup"},
    { TOKEN_COMPUTER, L"computer"},
    { TOKEN_PRINTER, L"printqueue"},
    { TOKEN_SERVICE, L"service"},
    { TOKEN_FILESERVICE, L"fileservice"},
    { TOKEN_SCHEMA, L"schema"},
    { TOKEN_CLASS, L"class"},
    { TOKEN_PROPERTY, L"property"},
    { TOKEN_SYNTAX, L"syntax"},
    { TOKEN_FILESHARE, L"fileshare"},
    { TOKEN_NAMESPACE, L"namespace"},
    { TOKEN_WORKGROUP, L"workgroup"}
};


// Object -> PathName, Type, eos
// Object -> PathName, eos

//+---------------------------------------------------------------------------
//  Function:
//
//  Synopsis:
//
//  Arguments:
//
//  Returns:
//
//  Modifies:
//
//  History:    11-3-95   krishnag     Created.
//
//----------------------------------------------------------------------------
HRESULT
Object(CLexer * pTokenizer, POBJECTINFO pObjectInfo)
{
    WCHAR szToken[MAX_TOKEN_LENGTH];
    DWORD dwToken;
    HRESULT hr;

    hr = ProviderName(pTokenizer, pObjectInfo);
    BAIL_IF_ERROR(hr);

    hr = pTokenizer->GetNextToken(szToken, &dwToken);
    BAIL_IF_ERROR(hr);

    switch (dwToken) {
    case TOKEN_END:
        RRETURN(S_OK);

    case TOKEN_COMMA:
        hr = Type(pTokenizer, pObjectInfo);
        BAIL_IF_ERROR(hr);
        hr = pTokenizer->GetNextToken(szToken, &dwToken);
        BAIL_IF_ERROR(hr);
        if (dwToken == TOKEN_END) {
            RRETURN(S_OK);
        }else {
            RRETURN(E_ADS_BAD_PATHNAME);
        }

    default:
        hr = pTokenizer->PushBackToken();


        hr = DsPathName(pTokenizer, pObjectInfo);
        BAIL_IF_ERROR(hr);

        hr = pTokenizer->GetNextToken(szToken, &dwToken);
        BAIL_IF_ERROR(hr);

        switch (dwToken) {
        case TOKEN_END:
            RRETURN(S_OK);

        case TOKEN_COMMA:
            hr = Type(pTokenizer, pObjectInfo);
            BAIL_IF_ERROR(hr);
            hr = pTokenizer->GetNextToken(szToken, &dwToken);
            BAIL_IF_ERROR(hr);
            if (dwToken == TOKEN_END) {
                RRETURN(S_OK);
            }else {
                RRETURN(E_ADS_BAD_PATHNAME);
            }

        default:
            RRETURN(E_FAIL);

        }

    }

cleanup:
    RRETURN(hr);
}






HRESULT
ProviderName(CLexer * pTokenizer, POBJECTINFO pObjectInfo)
{
    WCHAR szToken[MAX_TOKEN_LENGTH];
    DWORD dwToken;
    HRESULT hr;

    hr = pTokenizer->GetNextToken(szToken, &dwToken);
    BAIL_IF_ERROR(hr);

    if (dwToken == TOKEN_ATSIGN) {

        hr = pTokenizer->GetNextToken(szToken, &dwToken);
        BAIL_IF_ERROR(hr);

        if (dwToken != TOKEN_IDENTIFIER) {
            RRETURN(E_ADS_BAD_PATHNAME);
        }

        hr = AddProviderName(pObjectInfo, szToken);

        hr = pTokenizer->GetNextToken(szToken, &dwToken);
        BAIL_IF_ERROR(hr);


        if (dwToken != TOKEN_EXCLAMATION) {
            RRETURN(E_ADS_BAD_PATHNAME);
        }

    }else if (dwToken == TOKEN_IDENTIFIER) {

        hr = AddProviderName(pObjectInfo, szToken);

        hr = pTokenizer->GetNextToken(szToken, &dwToken);
        BAIL_IF_ERROR(hr);


        if (dwToken != TOKEN_COLON) {
            RRETURN(E_ADS_BAD_PATHNAME);
        }

    }else {
        RRETURN(E_ADS_BAD_PATHNAME);
    }

    //
    // You can now disable the processing for "@" and "!" treat them
    // as ordinary characters.
    //

    pTokenizer->SetAtDisabler(TRUE);

    RRETURN(S_OK);

cleanup:

    RRETURN(hr);
}


// PathName -> Component \\ PathName
// PathName -> Component


HRESULT
DsPathName(CLexer * pTokenizer, POBJECTINFO pObjectInfo)
{
    WCHAR szToken[MAX_TOKEN_LENGTH];
    DWORD dwToken;
    HRESULT hr;

    hr = pTokenizer->GetNextToken(szToken, &dwToken);
    BAIL_IF_ERROR(hr);
    if (dwToken != TOKEN_FSLASH) {
        RRETURN(E_ADS_BAD_PATHNAME);
    }


    hr = pTokenizer->GetNextToken(szToken, &dwToken);
    BAIL_IF_ERROR(hr);
    if (dwToken != TOKEN_FSLASH) {
        RRETURN(E_ADS_BAD_PATHNAME);
    }

    hr = PathName(pTokenizer, pObjectInfo);
    BAIL_IF_ERROR(hr);

    RRETURN(S_OK);

cleanup:

    RRETURN(hr);
}




//+---------------------------------------------------------------------------
// Function:
//
// Synopsis:
//
// Arguments:
//
// Returns:
//
// Modifies:
//
// History:    11-3-95   krishnag     Created.
//
//----------------------------------------------------------------------------
HRESULT
PathName(CLexer * pTokenizer, POBJECTINFO pObjectInfo)
{
    HRESULT hr;
    WCHAR szToken[MAX_TOKEN_LENGTH];
    DWORD dwToken;

    hr = Component(pTokenizer, pObjectInfo);
    BAIL_IF_ERROR(hr);

    hr = pTokenizer->GetNextToken(szToken, &dwToken);

    if (dwToken == TOKEN_FSLASH) {
        RRETURN (PathName(pTokenizer, pObjectInfo));
    }else {
        hr = pTokenizer->PushBackToken();
        RRETURN (S_OK);
    }
cleanup:
    RRETURN(hr);
}

// Component -> <identifier>





//+---------------------------------------------------------------------------
// Function:
//
// Synopsis:
//
// Arguments:
//
// Returns:
//
// Modifies:
//
// History:    11-3-95   krishnag     Created.
//
//----------------------------------------------------------------------------
HRESULT
Component(CLexer * pTokenizer, POBJECTINFO pObjectInfo)
{
    WCHAR szToken[MAX_TOKEN_LENGTH];
    WCHAR szDisplayToken[MAX_TOKEN_LENGTH];
    DWORD dwToken;
    HRESULT hr;

    hr = pTokenizer->GetNextToken(szToken, szDisplayToken, &dwToken);
    BAIL_IF_ERROR(hr);

    if (dwToken != TOKEN_IDENTIFIER) {
        RRETURN(E_ADS_BAD_PATHNAME);
    }

    hr = AddComponent(pObjectInfo, szToken, szDisplayToken);
    BAIL_IF_ERROR(hr);

    RRETURN(S_OK);
cleanup:
    RRETURN(hr);
}

// Type -> "user", "group","printer","service", "fileservice"

//+---------------------------------------------------------------------------
// Function:    Type
//
// Synopsis:    Parses Type-> "user" | "group" etc
//
// Arguments:   [CLexer * pTokenizer]
//              [POBJECTINFo pObjectInfo]
//
// Returns:     HRESULT
//
// Modifies:    -
//
// History:    11-3-95   krishnag     Created.
//
//----------------------------------------------------------------------------


HRESULT
Type(CLexer * pTokenizer, POBJECTINFO pObjectInfo)
{
    WCHAR szToken[MAX_PATH];
    DWORD dwToken;
    HRESULT hr;
    WCHAR *pszToken = szToken;

    hr = pTokenizer->GetNextToken(szToken, &dwToken);
    BAIL_IF_ERROR(hr);

    if (dwToken == TOKEN_IDENTIFIER ) {

        while (*pszToken == L' ') {
            //
            // remove leading spaces
            //
            pszToken++;
        }
    
        if (pTokenizer->IsKeyword(pszToken, &dwToken)) {
            hr = SetType(pObjectInfo, dwToken);
            RRETURN(hr);
        }
    }

    RRETURN(E_ADS_BAD_PATHNAME);

cleanup:
    RRETURN(hr);
}

//+---------------------------------------------------------------------------
// Function:
//
// Synopsis:
//
// Arguments:
//
// Returns:
//
// Modifies:
//
// History:    11-3-95   krishnag     Created.
//
//----------------------------------------------------------------------------
CLexer::CLexer(LPWSTR szBuffer):
                _ptr(NULL),
                _Buffer(NULL),
                _dwLastTokenLength(0),
                _dwLastToken(0),
                _dwEndofString(0),
                _bAtDisabled(FALSE)
{
    if (!szBuffer || !*szBuffer) {
        return;
    }
    _Buffer = AllocADsStr(szBuffer);
    _ptr = _Buffer;
}

HRESULT CLexer::SetBuffer(LPWSTR szBuffer)
{
    if (!szBuffer || !*szBuffer) {
        return E_INVALIDARG;
    }
    _Buffer = AllocADsStr(szBuffer);
    if(NULL == _Buffer)
        return E_OUTOFMEMORY;

    _ptr = _Buffer;
    return S_OK;
}    

//+---------------------------------------------------------------------------
// Function:
//
// Synopsis:
//
// Arguments:
//
// Returns:
//
// Modifies:
//
// History:    08-12-96   t-danal     Created.
//
//----------------------------------------------------------------------------
CLexer::~CLexer()
{
    if(_Buffer != NULL)
        FreeADsStr(_Buffer);
}



//+---------------------------------------------------------------------------
// Function:
//
// Synopsis:
//
// Arguments:
//
// Returns:
//
// Modifies:
//
// History:    11-3-95   krishnag     Created.
//
//----------------------------------------------------------------------------
HRESULT
CLexer::GetNextToken(LPWSTR szToken, LPWSTR szDisplayToken, LPDWORD pdwToken)
{
    WCHAR c;
    DWORD state = 0;
    LPWSTR pch = szToken;
    LPWSTR pDisplayCh = szDisplayToken;
    BOOL fEscapeOn = FALSE, fQuotingOn = FALSE;

    memset(szToken, 0, sizeof(WCHAR) * MAX_TOKEN_LENGTH);

    if (szDisplayToken) {
        memset(szDisplayToken, 0, sizeof(TCHAR) * MAX_TOKEN_LENGTH);
    }

    _dwLastTokenLength = 0;
    while (1) {
        
        //
        // if _dwLastTokenLength is greater than MAX_TOKEN_LENGTH-1,
        // then we are already at the buffer end, so return E_ADS_BAD_PARAMETER
        //

        if (_dwLastTokenLength > MAX_TOKEN_LENGTH -1 ) {
            RRETURN(E_ADS_BAD_PARAMETER);
        }
        
        c = NextChar();
        switch (state) {
        case  0:
            *pch++ = c;
            _dwLastTokenLength++;

            if (c == TEXT('"')) {
                //
                // Quoting;
                //

                fQuotingOn = TRUE;

                pch--;
                state = 1;

            }else if (c == TEXT('\\')) {
                //
                // Escaping; Ignore the '\' in the token and check to make
                // sure that the next character exists
                //
                pch--;

                fEscapeOn = TRUE;

                state = 1;

            }else if (c == L'/') {
                *pdwToken = TOKEN_FSLASH;
                _dwLastToken = *pdwToken;
                RRETURN(S_OK);
            }else if (c == L',') {
                *pdwToken = TOKEN_COMMA;
                _dwLastToken = *pdwToken;
                RRETURN(S_OK);
            }else if (c == L':'){
                if (!_bAtDisabled) {
                    *pdwToken = TOKEN_COLON;
                    _dwLastToken = *pdwToken;
                    RRETURN(S_OK);
                }else {
                    state = 1;
                }
            }else if (c == TEXT('<')) {
                RRETURN(E_FAIL);
            }else if (c == TEXT('>')) {
                RRETURN(E_FAIL);
            }else if (c == L'\0'){
                *pdwToken = TOKEN_END;
                _dwLastToken = *pdwToken;
                RRETURN(S_OK);
            }else if (c == L'@') {

                if (!_bAtDisabled) {

                    *pdwToken = TOKEN_ATSIGN;
                    _dwLastToken = *pdwToken;
                    RRETURN(S_OK);


                }else {
                    state = 1;
                }

            }else if (c == L'!'){

                if (!_bAtDisabled) {

                    *pdwToken = TOKEN_EXCLAMATION;
                    _dwLastToken = *pdwToken;
                    RRETURN(S_OK);


                }else {
                    state = 1;
                }

            }else {

                state = 1;
            }
            break;

        case 1:

            if ((fEscapeOn || fQuotingOn) && c == TEXT('\0') ) {
                RRETURN(E_FAIL);
            }
            else if (fEscapeOn) {
                fEscapeOn = FALSE;
                *pch++ = c;
                _dwLastTokenLength++;
                state = 1;
                break;
            }
            else if (fQuotingOn) {
                if (c == TEXT('"')) {
                    fQuotingOn = FALSE;
                }
                else {
                    *pch++ = c;
                }
                _dwLastTokenLength++;
                break;
            }
            else if (c == TEXT('\\') ) {
                fEscapeOn = TRUE;
                _dwLastTokenLength++;

                break;

            }
            else if (c == TEXT('"')) {
                fQuotingOn = TRUE;
                _dwLastTokenLength++;
                break;
            }
            if (c == L'\0' || c == L',' ||
                    c == L'/') {
                PushbackChar();

                *pdwToken = TOKEN_IDENTIFIER;
                _dwLastToken = *pdwToken;
                RRETURN (S_OK);
            }else if (c == L'@' || c == L'!' || c == TEXT(':')) {

                if (!_bAtDisabled) {

                    PushbackChar();

                    *pdwToken = TOKEN_IDENTIFIER;
                    _dwLastToken = *pdwToken;
                    RRETURN(S_OK);


                }else {

                    *pch++ = c;
                    _dwLastTokenLength++;
                    state = 1;
                    break;

                }

            }else {
                *pch++ = c;
                _dwLastTokenLength++;
                state = 1;
                break;
            }
        default:
            RRETURN(E_FAIL);
        }

        if (pDisplayCh) {
            *pDisplayCh++ = c;
        }

    }
}

HRESULT
CLexer::GetNextToken(LPWSTR szToken, LPDWORD pdwToken)
{
    RRETURN (GetNextToken(szToken, NULL, pdwToken));
}

//+---------------------------------------------------------------------------
// Function:
//
// Synopsis:
//
// Arguments:
//
// Returns:
//
// Modifies:
//
// History:    11-3-95   krishnag     Created.
//
//----------------------------------------------------------------------------
WCHAR
CLexer::NextChar()
{
    if (_ptr == NULL || *_ptr == L'\0') {
        _dwEndofString = TRUE;
        return(L'\0');
    }
    return(*_ptr++);
}

//+---------------------------------------------------------------------------
// Function:
//
// Synopsis:
//
// Arguments:
//
// Returns:
//
// Modifies:
//
// History:    11-3-95   krishnag     Created.
//
//----------------------------------------------------------------------------
HRESULT
CLexer::PushBackToken()
{
    if (_dwLastToken == TOKEN_END) {
        RRETURN(S_OK);
    }
    _ptr -= _dwLastTokenLength;

    RRETURN(S_OK);
}


//+---------------------------------------------------------------------------
// Function:
//
// Synopsis:
//
// Arguments:
//
// Returns:
//
// Modifies:
//
// History:    11-3-95   krishnag     Created.
//
//----------------------------------------------------------------------------
void
CLexer::PushbackChar()
{
    if (_dwEndofString) {
        return;
    }
    _ptr--;

}

//+---------------------------------------------------------------------------
// Function:
//
// Synopsis:
//
// Arguments:
//
// Returns:
//
// Modifies:
//
// History:    11-3-95   krishnag     Created.
//
//----------------------------------------------------------------------------
BOOL
CLexer::IsKeyword(LPWSTR szToken, LPDWORD pdwToken)
{
    DWORD i = 0;

    for (i = 0; i < MAX_KEYWORDS; i++) {
        if (!_wcsicmp(szToken, KeywordList[i].Keyword)) {
            *pdwToken = KeywordList[i].dwTokenId;
            return(TRUE);
        }
    }
    *pdwToken = 0;
    return(FALSE);
}


//+---------------------------------------------------------------------------
//Function:
//
//Synopsis:
//
//Arguments:
//
//Returns:
//
//Modifies:
//
//History:    11-3-95   krishnag     Created.
//
//----------------------------------------------------------------------------
HRESULT
AddComponent(POBJECTINFO pObjectInfo, LPWSTR szToken, LPWSTR szDisplayToken)
{
    if (!szToken || !*szToken || !szDisplayToken || !*szDisplayToken) {
    }

    if(pObjectInfo->NumComponents < MAXCOMPONENTS)
    {
        pObjectInfo->ComponentArray[pObjectInfo->NumComponents] =
                    AllocADsStr(szToken);

        pObjectInfo->DisplayComponentArray[pObjectInfo->NumComponents] =
                    AllocADsStr(szToken);

        pObjectInfo->NumComponents++;

        RRETURN(S_OK);
    }
    else
    {
        RRETURN(E_ADS_BAD_PATHNAME);
    }

}

HRESULT
AddProviderName(POBJECTINFO pObjectInfo, LPWSTR szToken)
{
    if (!szToken || !*szToken) {
        RRETURN(E_FAIL);
    }

    pObjectInfo->ProviderName = AllocADsStr(szToken);

    RRETURN(S_OK);
}


//+---------------------------------------------------------------------------
// Function:
//
// Synopsis:
//
// Arguments:
//
// Returns:
//
// Modifies:
//
// History:    11-3-95   krishnag     Created.
//
//----------------------------------------------------------------------------
HRESULT
SetType(POBJECTINFO pObjectInfo, DWORD dwToken)
{
    pObjectInfo->ObjectType = dwToken;
    RRETURN(S_OK);
}


void
CLexer::SetAtDisabler(
    BOOL bFlag
    )
{
    _bAtDisabled = bFlag;
}

BOOL
CLexer::GetAtDisabler()
{
    return(_bAtDisabled);
}


HRESULT
GetDisplayName(
    LPWSTR szName,
    LPWSTR *ppszDisplayName
    )
{

    HRESULT hr = S_OK;
    DWORD len = 0;
    LPWSTR pch = szName;
    LPWSTR pszDisplayCh = NULL, pszDisplay = NULL;
    BOOL fQuotingOn = FALSE;

    if (!ppszDisplayName ) {
        RRETURN (E_INVALIDARG);
    }

    *ppszDisplayName = NULL;

    if (!szName) {
        RRETURN (S_OK);
    }

    pch = szName;
    fQuotingOn = FALSE;

    for (len=0; *pch; pch++, len++) {
        // all the special characters need to be escaped here
        if (*pch == L'/' || *pch == L'<' || *pch == L'>' || *pch == L'\\' || *pch == L'\"' || *pch == L',') {
            len++;
        }
    }

    pszDisplay = (LPWSTR) AllocADsMem((len+1) * sizeof(WCHAR));

    if (!pszDisplay) {
        BAIL_ON_FAILURE(hr = E_OUTOFMEMORY);
    }

    pch = szName;
    pszDisplayCh = pszDisplay;
    fQuotingOn = FALSE;

    for (; *pch; pch++, pszDisplayCh++) {
        // all the special characters need to be escaped here
        if (*pch == L'/' || *pch == L'<' || *pch == L'>' || *pch == L'\\' || *pch == L'\"' || *pch == L',') {
            *pszDisplayCh++ = L'\\';
        }
        *pszDisplayCh = *pch;
    }

    *pszDisplayCh = L'\0';

    *ppszDisplayName = pszDisplay;

error:

    RRETURN(hr);


}
=== C:/Users/treeman/Desktop/windows nt source code\Source\Win2K3\NT\ds\adsi\winnt\common\makefile.inc ===
.SUFFIXES: .def

{..\}.def{$(O)}.def:
    $(C_PREPROCESSOR) $<  > $@
=== C:/Users/treeman/Desktop/windows nt source code\Source\Win2K3\NT\ds\adsi\winnt\umiconcf.cxx ===
//----------------------------------------------------------------------------
//
//  Microsoft Windows
//  Copyright (C) Microsoft Corporation, 1992 - 2000.
//
//  File:     umiconcf.cxx
//
//  Contents: Contains the class factory for creating UMI connection objects. 
//
//  History:  03-02-00    SivaramR  Created.
//
//----------------------------------------------------------------------------

#include "winnt.hxx"

//----------------------------------------------------------------------------
// Function:   CreateInstance 
//
// Synopsis:   Creates a connection object.
//
// Arguments:
//
// pUnkOuter   Pointer to aggregating IUnknown. UMI connection objects don't
//             support aggregation, so this has to be NULL.
// iid         Interface requested. Only interface supported is IUmiConnection.
// ppInterface Returns pointer to interface requested
//
// Returns:    S_OK on success. Error code otherwise. 
//
// Modifies:   *ppInterface to return a pointer to the interface requested
//
//----------------------------------------------------------------------------
STDMETHODIMP CUmiConnectionCF::CreateInstance(
    IUnknown * pUnkOuter,
    REFIID iid,
    LPVOID *ppInterface
    )
{
    HRESULT        hr = S_OK;

    if(pUnkOuter != NULL)
    // Umi connection object cannot be aggregated
        RRETURN(CLASS_E_NOAGGREGATION);

    if(NULL == ppInterface)
        RRETURN(E_FAIL);

    *ppInterface = NULL;

    hr = CUmiConnection::CreateConnection(iid, ppInterface);
    BAIL_ON_FAILURE(hr);

error:

    RRETURN(hr);
}
=== C:/Users/treeman/Desktop/windows nt source code\Source\Win2K3\NT\ds\adsi\winnt\umi2nt.cxx ===
//----------------------------------------------------------------------------
//
//  Microsoft Windows
//  Copyright (C) Microsoft Corporation, 1992 - 2000.
//
//  File:     umi2nt.cxx
//
//  Contents: Contains the routines to convert from UMI_PROPERTY structures to
//            NT objects that can be stored in the cache.
//
//  History:  02-28-00    SivaramR  Created.
//
//----------------------------------------------------------------------------

#include "winnt.hxx"

//----------------------------------------------------------------------------
// Function:   UmiToBooleans
//
// Synopsis:   Converts from UMI_PROPERTY structure to array of NT objects, 
//             each containing a boolean.
//
// Arguments:
//
// pPropArray  Pointer to UMI_PROPERTY structure
// pNtObjects  Array of NT objects that returns the values. 
// ulNumValues Number of values stored in pPropArray
//
// Returns:    UMI_S_NO_ERROR if successful. Error code otherwise (none now).
//
// Modifies:   *pNtObject to return the converted value. 
//
//----------------------------------------------------------------------------
HRESULT UmiToBooleans(
    UMI_PROPERTY *pPropArray,
    LPNTOBJECT   pNtObjects,
    ULONG        ulNumValues
    )
{
    ULONG ulIndex = 0;
    BOOL  bVal;

    ADsAssert( (pPropArray != NULL) && (pNtObjects != NULL) );
    ADsAssert(pPropArray->pUmiValue != NULL);

    for(ulIndex = 0; ulIndex < ulNumValues; ulIndex++)
    {
        bVal = pPropArray->pUmiValue->bValue[ulIndex];

        pNtObjects[ulIndex].NTType = NT_SYNTAX_ID_BOOL;
        if(bVal)
            pNtObjects[ulIndex].NTValue.fValue = TRUE;
        else
            pNtObjects[ulIndex].NTValue.fValue = FALSE;
    }

    RRETURN(UMI_S_NO_ERROR);
}

//----------------------------------------------------------------------------
// Function:   ConvertSystemTimeToUTCTime
//
// Synopsis:   Converts a system time structure containing a local time to a 
//             system time structure containing UTC time.  
//
// Arguments:
//
// pLocalTime  Pointer to local time
// pUTCTime    Returns UTC time
//
// Returns:    UMI_S_NO_ERROR if successful. Error code otherwise.
//
// Modifies:   *pUTCTime to contain the UTC time.
//
//----------------------------------------------------------------------------
HRESULT ConvertSystemTimeToUTCTime(
    SYSTEMTIME *pLocalTime,
    SYSTEMTIME *pUTCTime
    )
{
    HRESULT  hr = UMI_S_NO_ERROR;
    FILETIME localft, ft;
    BOOL     fRetVal;

    ADsAssert( (pLocalTime != NULL) && (pUTCTime != NULL) );

    fRetVal = SystemTimeToFileTime(pLocalTime, &localft);
    if(!fRetVal)
        BAIL_ON_FAILURE( hr = HRESULT_FROM_WIN32(GetLastError()) );

    fRetVal = LocalFileTimeToFileTime(&localft, &ft);
    if(!fRetVal)
        BAIL_ON_FAILURE( hr = HRESULT_FROM_WIN32(GetLastError()) );

    fRetVal = FileTimeToSystemTime(&ft, pUTCTime);
    if(!fRetVal)
        BAIL_ON_FAILURE( hr = HRESULT_FROM_WIN32(GetLastError()) );

    RRETURN(UMI_S_NO_ERROR);

error:
    RRETURN(hr);
}
   

//----------------------------------------------------------------------------
// Function:   UmiToSystemTimes
//
// Synopsis:   Converts from UMI_PROPERTY structure to array of NT objects,
//             each containing a system time. The time sent in by the user
//             is local time, so we need to convert it to UTC.
//
// Arguments:
//
// pPropArray  Pointer to UMI_PROPERTY structure
// pNtObjects  Array of NT objects that returns the values.
// ulNumValues Number of values stored in pPropArray
//
// Returns:    UMI_S_NO_ERROR if successful. Error code otherwise.
//
// Modifies:   *pNtObject to return the converted value.
//
//----------------------------------------------------------------------------
HRESULT UmiToSystemTimes(
    UMI_PROPERTY *pPropArray,
    LPNTOBJECT   pNtObjects,
    ULONG        ulNumValues
    )
{
    ULONG      ulIndex = 0;
    SYSTEMTIME *pSysTime, UTCTime;
    HRESULT    hr = UMI_S_NO_ERROR;

    ADsAssert( (pPropArray != NULL) && (pNtObjects != NULL) );
    ADsAssert(pPropArray->pUmiValue != NULL);

    for(ulIndex = 0; ulIndex < ulNumValues; ulIndex++)
    {
        pSysTime = &(pPropArray->pUmiValue->sysTimeValue[ulIndex]);

        hr = ConvertSystemTimeToUTCTime(pSysTime, &UTCTime);
        BAIL_ON_FAILURE(hr);

        pNtObjects[ulIndex].NTType = NT_SYNTAX_ID_SYSTEMTIME;
        pNtObjects[ulIndex].NTValue.stSystemTimeValue = UTCTime; 
    }      

    RRETURN(UMI_S_NO_ERROR);

error:
    RRETURN(hr);
}


//----------------------------------------------------------------------------
// Function:   UmiToDwords
//
// Synopsis:   Converts from UMI_PROPERTY structure to array of NT objects,
//             each containing a DWORD.
//
// Arguments:
//
// pPropArray  Pointer to UMI_PROPERTY structure
// pNtObjects  Array of NT objects that returns the values.
// ulNumValues Number of values stored in pPropArray
//
// Returns:    UMI_S_NO_ERROR if successful. Error code otherwise (none now).
//
// Modifies:   *pNtObject to return the converted value.
//
//----------------------------------------------------------------------------
HRESULT UmiToDwords(
    UMI_PROPERTY *pPropArray,
    LPNTOBJECT   pNtObjects,
    ULONG        ulNumValues
    )
{
    ULONG      ulIndex = 0;
    DWORD      dwVal;

    ADsAssert( (pPropArray != NULL) && (pNtObjects != NULL) );
    ADsAssert(pPropArray->pUmiValue != NULL);

    for(ulIndex = 0; ulIndex < ulNumValues; ulIndex++)
    {
        dwVal = pPropArray->pUmiValue->uValue[ulIndex];

        pNtObjects[ulIndex].NTType = NT_SYNTAX_ID_DWORD;
        pNtObjects[ulIndex].NTValue.dwValue = dwVal;
    }

    RRETURN(UMI_S_NO_ERROR);
}

//----------------------------------------------------------------------------
// Function:   UmiToDates
//
// Synopsis:   Converts from UMI_PROPERTY structure to array of NT objects,
//             each containing a DATE. Only the hours and minutes in the
//             system time are stored in the NT object. Again, the input
//             is local time, so it needs to be converted to UTC.
//
// Arguments:
//
// pPropArray  Pointer to UMI_PROPERTY structure
// pNtObjects  Array of NT objects that returns the values.
// ulNumValues Number of values stored in pPropArray
//
// Returns:    UMI_S_NO_ERROR if successful. Error code otherwise.
//
// Modifies:   *pNtObject to return the converted value.
//
//----------------------------------------------------------------------------
HRESULT UmiToDates(
    UMI_PROPERTY *pPropArray,
    LPNTOBJECT   pNtObjects,
    ULONG        ulNumValues
    )
{
    ULONG      ulIndex = 0;
    SYSTEMTIME *pSysTime, UTCTime;
    HRESULT    hr = UMI_S_NO_ERROR;

    ADsAssert( (pPropArray != NULL) && (pNtObjects != NULL) );
    ADsAssert(pPropArray->pUmiValue != NULL);

    for(ulIndex = 0; ulIndex < ulNumValues; ulIndex++)
    {
        pSysTime = &(pPropArray->pUmiValue->sysTimeValue[ulIndex]);

        hr = ConvertSystemTimeToUTCTime(pSysTime, &UTCTime);
        BAIL_ON_FAILURE(hr);

        pNtObjects[ulIndex].NTType = NT_SYNTAX_ID_DATE;
        pNtObjects[ulIndex].NTValue.dwValue = 
                                     UTCTime.wHour*60 + UTCTime.wMinute;
    }

    RRETURN(UMI_S_NO_ERROR);

error:
    RRETURN(hr);
}

//----------------------------------------------------------------------------
// Function:   ConvertSystemTimeToUTCFileTime
//
// Synopsis:   Converts a system time structure containing a local time to a
//             file time structure containing UTC time.
//
// Arguments:
//
// pLocalTime  Pointer to local time
// pUTCTime    Returns UTC file time
//
// Returns:    UMI_S_NO_ERROR if successful. Error code otherwise.
//
// Modifies:   *pUTCFileTime to contain the UTC file time.
//
//----------------------------------------------------------------------------
HRESULT ConvertSystemTimeToUTCFileTime(
    SYSTEMTIME *pLocalTime,
    FILETIME *pUTCFileTime
    )
{
    HRESULT  hr = UMI_S_NO_ERROR;
    FILETIME localft;
    BOOL     fRetVal;

    ADsAssert( (pLocalTime != NULL) && (pUTCFileTime != NULL) );

    fRetVal = SystemTimeToFileTime(pLocalTime, &localft);
    if(!fRetVal)
        BAIL_ON_FAILURE( hr = HRESULT_FROM_WIN32(GetLastError()) );

    fRetVal = LocalFileTimeToFileTime(&localft, pUTCFileTime);
    if(!fRetVal)
        BAIL_ON_FAILURE( hr = HRESULT_FROM_WIN32(GetLastError()) );

    RRETURN(UMI_S_NO_ERROR);

error:
    RRETURN(hr);
}

//----------------------------------------------------------------------------
// Function:   UmiToDate70s
//
// Synopsis:   Converts from UMI_PROPERTY structure to array of NT objects,
//             each containing the number of seconds from 1970 to the date
//             in UMI_PROPERTY. Again the input is local time, so it needs
//             to be converted to UTC. 
//
// Arguments:
//
// pPropArray  Pointer to UMI_PROPERTY structure
// pNtObjects  Array of NT objects that returns the values.
// ulNumValues Number of values stored in pPropArray
//
// Returns:    UMI_S_NO_ERROR if successful. Error code otherwise.
//
// Modifies:   *pNtObject to return the converted value.
//
//----------------------------------------------------------------------------
HRESULT UmiToDate70s(
    UMI_PROPERTY *pPropArray,
    LPNTOBJECT   pNtObjects,
    ULONG        ulNumValues
    )
{
    ULONG         ulIndex = 0;
    SYSTEMTIME    *pSysTime;
    FILETIME      UTCFileTime;
    HRESULT       hr = UMI_S_NO_ERROR;
    LARGE_INTEGER tmpTime;
    DWORD         dwSeconds1970 = 0;

    ADsAssert( (pPropArray != NULL) && (pNtObjects != NULL) );
    ADsAssert(pPropArray->pUmiValue != NULL);

    for(ulIndex = 0; ulIndex < ulNumValues; ulIndex++)
    {
        pSysTime = &(pPropArray->pUmiValue->sysTimeValue[ulIndex]);

        hr = ConvertSystemTimeToUTCFileTime(pSysTime, &UTCFileTime);
        BAIL_ON_FAILURE(hr);

        tmpTime.LowPart = UTCFileTime.dwLowDateTime;
        tmpTime.HighPart = UTCFileTime.dwHighDateTime;

        RtlTimeToSecondsSince1970(&tmpTime, (ULONG *) (&dwSeconds1970) );
 
        pNtObjects[ulIndex].NTType = NT_SYNTAX_ID_DATE_1970;
        pNtObjects[ulIndex].NTValue.dwSeconds1970 = dwSeconds1970;
    }

    RRETURN(UMI_S_NO_ERROR);

error:
    RRETURN(hr);
}

//----------------------------------------------------------------------------
// Function:   UmiToLPWSTRs
//
// Synopsis:   Converts from UMI_PROPERTY structure to array of NT objects,
//             each containing a string.
//
// Arguments:
//
// pPropArray  Pointer to UMI_PROPERTY structure
// pNtObjects  Array of NT objects that returns the values.
// ulNumValues Number of values stored in pPropArray
// dwSyntaxId  Syntax of the property. There are different syntaxes for
//             strings - Delimited_Strings, Nulled_Strings etc.
//
// Returns:    UMI_S_NO_ERROR if successful. Error code otherwise.
//
// Modifies:   *pNtObject to return the converted value.
//
//----------------------------------------------------------------------------
HRESULT UmiToLPWSTRs(
    UMI_PROPERTY *pPropArray,
    LPNTOBJECT   pNtObjects,
    ULONG        ulNumValues,
    DWORD        dwSyntaxId
    )
{
    ULONG   ulIndex = 0, i = 0;
    LPWSTR  pszStr = NULL; 
    HRESULT hr = UMI_S_NO_ERROR;

    ADsAssert( (pPropArray != NULL) && (pNtObjects != NULL) );
    ADsAssert(pPropArray->pUmiValue != NULL);

    for(ulIndex = 0; ulIndex < ulNumValues; ulIndex++)
    {
        pszStr = pPropArray->pUmiValue->pszStrValue[ulIndex];

        pNtObjects[ulIndex].NTType = dwSyntaxId;
        if(pszStr != NULL) {
            pNtObjects[ulIndex].NTValue.pszValue = AllocADsStr(pszStr);
            if(NULL == pNtObjects[ulIndex].NTValue.pszValue)
                BAIL_ON_FAILURE(hr = UMI_E_OUT_OF_MEMORY); 
        }
        else
            pNtObjects[ulIndex].NTValue.pszValue = NULL;
    }

    RRETURN(UMI_S_NO_ERROR);

error:

    for(i = 0; i < ulIndex; i++)
       if(pNtObjects[i].NTValue.pszValue != NULL)
           FreeADsStr(pNtObjects[i].NTValue.pszValue);
 
    RRETURN(hr);
}

//----------------------------------------------------------------------------
// Function:   UmiToOctetStrings
//
// Synopsis:   Converts from UMI_PROPERTY structure to array of NT objects,
//             each containing an octet string.
//
// Arguments:
//
// pPropArray  Pointer to UMI_PROPERTY structure
// pNtObjects  Array of NT objects that returns the values.
// ulNumValues Number of values stored in pPropArray
//
// Returns:    UMI_S_NO_ERROR if successful. Error code otherwise.
//
// Modifies:   *pNtObject to return the converted value.
//
//----------------------------------------------------------------------------
HRESULT UmiToOctetStrings(
    UMI_PROPERTY *pPropArray,
    LPNTOBJECT   pNtObjects,
    ULONG        ulNumValues
    )
{
    ULONG            ulIndex = 0, i = 0;
    UMI_OCTET_STRING *pUmiOctetStr;
    HRESULT          hr = UMI_S_NO_ERROR;

    ADsAssert( (pPropArray != NULL) && (pNtObjects != NULL) );
    ADsAssert(pPropArray->pUmiValue != NULL);

    for(ulIndex = 0; ulIndex < ulNumValues; ulIndex++)
    {
        pUmiOctetStr = &(pPropArray->pUmiValue->octetStr[ulIndex]);

        pNtObjects[ulIndex].NTType = NT_SYNTAX_ID_OCTETSTRING; 
        pNtObjects[ulIndex].NTValue.octetstring.pByte = 
            (BYTE *) AllocADsMem(pUmiOctetStr->uLength);
        if(NULL == pNtObjects[ulIndex].NTValue.octetstring.pByte)
            BAIL_ON_FAILURE(hr = UMI_E_OUT_OF_MEMORY);

        memcpy(pNtObjects[ulIndex].NTValue.octetstring.pByte,
               pUmiOctetStr->lpValue, pUmiOctetStr->uLength);
        pNtObjects[ulIndex].NTValue.octetstring.dwSize = pUmiOctetStr->uLength;
    }

    RRETURN(UMI_S_NO_ERROR);

error:

    for(i = 0; i < ulIndex; i++)
       if(pNtObjects[i].NTValue.octetstring.pByte != NULL)
           FreeADsMem(pNtObjects[i].NTValue.octetstring.pByte);

    RRETURN(hr);
}
   
//----------------------------------------------------------------------------
// Function:   UmiToEncryptedLPWSTRs
//
// Synopsis:   Converts from UMI_PROPERTY structure to array of NT objects,
//             each containing an encrypted string. Used so that passwords
//             are not stored in cleartext.
//
// Arguments:
//
// pPropArray  Pointer to UMI_PROPERTY structure
// pNtObjects  Array of NT objects that returns the values.
// ulNumValues Number of values stored in pPropArray
//
// Returns:    UMI_S_NO_ERROR if successful. Error code otherwise.
//
// Modifies:   *pNtObject to return the converted value.
//
//----------------------------------------------------------------------------
HRESULT UmiToEncryptedLPWSTRs(
    UMI_PROPERTY *pPropArray,
    LPNTOBJECT   pNtObjects,
    ULONG        ulNumValues
    )
{
    ULONG          ulIndex = 0, i = 0;
    LPWSTR         pszStr = NULL;
    HRESULT        hr = UMI_S_NO_ERROR;
    UNICODE_STRING Password;
    UCHAR          Seed = UMI_ENCODE_SEED3;

    ADsAssert( (pPropArray != NULL) && (pNtObjects != NULL) );
    ADsAssert(pPropArray->pUmiValue != NULL);

    for(ulIndex = 0; ulIndex < ulNumValues; ulIndex++)
    {
        pszStr = pPropArray->pUmiValue->pszStrValue[ulIndex];

        pNtObjects[ulIndex].NTType = NT_SYNTAX_ID_EncryptedString; 

        if(pszStr != NULL) {
            pNtObjects[ulIndex].NTValue.pszValue = AllocADsStr(pszStr);
            if(NULL == pNtObjects[ulIndex].NTValue.pszValue)
                BAIL_ON_FAILURE(hr = UMI_E_OUT_OF_MEMORY);

            RtlInitUnicodeString(&Password, 
                                 pNtObjects[ulIndex].NTValue.pszValue);
            RtlRunEncodeUnicodeString(&Seed, &Password); 
        }
        else
            pNtObjects[ulIndex].NTValue.pszValue = NULL;
    }

    RRETURN(UMI_S_NO_ERROR);

error:

    for(i = 0; i < ulIndex; i++)
       if(pNtObjects[i].NTValue.pszValue != NULL)
           FreeADsStr(pNtObjects[i].NTValue.pszValue);

    RRETURN(hr);
} 

//----------------------------------------------------------------------------
// Function:   UmiToWinNTType 
//
// Synopsis:   Converts from UMI_PROPERTY structure to NT objects that can be
//             stored in the cache. 
//
// Arguments: 
//
// dwSyntaxId  Syntax of property
// pPropArray  Pointer to UMI_PROPERTY structure
// ppNtObjects Returns a pointer to an NT object that can be stored in the
//             cache. 
//
// Returns:    UMI_S_NO_ERROR if successful. Error code otherwise. 
//
// Modifies:   *ppNtObjects to return a pointer to NT object
//
//----------------------------------------------------------------------------
HRESULT UmiToWinNTType(
    DWORD         dwSyntaxId,
    UMI_PROPERTY *pPropArray,
    LPNTOBJECT   *ppNtObjects
    )
{
    ULONG      ulNumValues = 0;
    HRESULT    hr = UMI_S_NO_ERROR;
    LPNTOBJECT pNtObjects = NULL;

    ADsAssert((pPropArray != NULL) && (ppNtObjects != NULL));

    *ppNtObjects = NULL;
    ulNumValues = pPropArray->uCount;

    pNtObjects = (LPNTOBJECT) AllocADsMem(ulNumValues * sizeof(NTOBJECT));
    if(NULL == pNtObjects)
        BAIL_ON_FAILURE(hr = UMI_E_OUT_OF_MEMORY);

    switch(dwSyntaxId) {

        case NT_SYNTAX_ID_BOOL:
            if(pPropArray->uType != UMI_TYPE_BOOL)
                BAIL_ON_FAILURE(hr = UMI_E_CANT_CONVERT_DATA);

            hr = UmiToBooleans(pPropArray, pNtObjects, ulNumValues);
            BAIL_ON_FAILURE(hr);

            break;

        case NT_SYNTAX_ID_SYSTEMTIME:
            if(pPropArray->uType != UMI_TYPE_SYSTEMTIME)
                BAIL_ON_FAILURE(hr = UMI_E_CANT_CONVERT_DATA);

            hr = UmiToSystemTimes(pPropArray, pNtObjects, ulNumValues);
            BAIL_ON_FAILURE(hr);

            break;

        case NT_SYNTAX_ID_DWORD:
            if(pPropArray->uType != UMI_TYPE_I4)
                BAIL_ON_FAILURE(hr = UMI_E_CANT_CONVERT_DATA);

            hr = UmiToDwords(pPropArray, pNtObjects, ulNumValues);
            BAIL_ON_FAILURE(hr);

            break;

        case NT_SYNTAX_ID_DATE:
            if(pPropArray->uType != UMI_TYPE_SYSTEMTIME)
                BAIL_ON_FAILURE(hr = UMI_E_CANT_CONVERT_DATA);

            hr = UmiToDates(pPropArray, pNtObjects, ulNumValues);
            BAIL_ON_FAILURE(hr);

            break;

        case NT_SYNTAX_ID_DATE_1970:
            if(pPropArray->uType != UMI_TYPE_SYSTEMTIME)
                BAIL_ON_FAILURE(hr = UMI_E_CANT_CONVERT_DATA);

            hr = UmiToDate70s(pPropArray, pNtObjects, ulNumValues);
            BAIL_ON_FAILURE(hr);

            break;

        case NT_SYNTAX_ID_LPTSTR:
            if(pPropArray->uType != UMI_TYPE_LPWSTR)
                BAIL_ON_FAILURE(hr = UMI_E_CANT_CONVERT_DATA);

            hr = UmiToLPWSTRs(pPropArray, pNtObjects, ulNumValues,
                                   NT_SYNTAX_ID_LPTSTR);
            BAIL_ON_FAILURE(hr);

            break;

        case NT_SYNTAX_ID_DelimitedString:
            if(pPropArray->uType != UMI_TYPE_LPWSTR)
                BAIL_ON_FAILURE(hr = UMI_E_CANT_CONVERT_DATA);

            hr = UmiToLPWSTRs(pPropArray, pNtObjects, ulNumValues,
                                   NT_SYNTAX_ID_DelimitedString);
            BAIL_ON_FAILURE(hr);

            break;

        case NT_SYNTAX_ID_NulledString:
            if(pPropArray->uType != UMI_TYPE_LPWSTR)
                BAIL_ON_FAILURE(hr = UMI_E_CANT_CONVERT_DATA);

            hr = UmiToLPWSTRs(pPropArray, pNtObjects, ulNumValues,
                                    NT_SYNTAX_ID_NulledString);
            BAIL_ON_FAILURE(hr);

            break;

        case NT_SYNTAX_ID_OCTETSTRING:
            if(pPropArray->uType != UMI_TYPE_OCTETSTRING)
                BAIL_ON_FAILURE(hr = UMI_E_CANT_CONVERT_DATA);

            hr = UmiToOctetStrings(pPropArray, pNtObjects, ulNumValues);

            BAIL_ON_FAILURE(hr);

            break;

        case NT_SYNTAX_ID_EncryptedString:
            if(pPropArray->uType != UMI_TYPE_LPWSTR)
                BAIL_ON_FAILURE(hr = UMI_E_CANT_CONVERT_DATA);

            hr = UmiToEncryptedLPWSTRs(pPropArray, pNtObjects, ulNumValues);
            BAIL_ON_FAILURE(hr);

            break;

        default:
            BAIL_ON_FAILURE(hr = UMI_E_CANT_CONVERT_DATA);
    } // switch

    *ppNtObjects = pNtObjects;
    RRETURN(UMI_S_NO_ERROR);

error:
    if(pNtObjects != NULL)
        FreeADsMem(pNtObjects);

    RRETURN(hr);
}
=== C:/Users/treeman/Desktop/windows nt source code\Source\Win2K3\NT\ds\adsi\winnt\winnt2.h ===
#define WINNT_LIBIID_WinNTOle              0214d870-fd16-11ce-abc4-02608c9e7553
#define WINNT_CLSID_WinNTNamespace         250e91a0-0367-11cf-abc4-02608c9e7553

#define WINNT_CLSID_WinNTDomain            01544ed0-fd16-11ce-abc4-02608c9e7553
#define WINNT_CLSID_WinNTUser              d83f1060-1e71-11cf-b1f3-02608c9e7553
#define WINNT_CLSID_WinNTGroup             d9c1aad0-1e71-11cf-b1f3-02608c9e7553
#define WINNT_CLSID_WinNTComputer          da438dc0-1e71-11cf-b1f3-02608c9e7553

#define WINNT_CLSID_WinNTService           636ec6e0-4c66-11cf-a995-00aa006bc149
#define WINNT_CLSID_WinNTFileService       881fe380-6ca1-11cf-a99b-00aa006bc149

#define WINNT_CLSID_WinNTPrintQueue        6c4a7120-4c66-11cf-a995-00aa006bc149
#define WINNT_CLSID_WinNTPrintJob          60002920-6ca1-11cf-a99b-00aa006bc149

#define WINNT_CLSID_WinNTSession           9e066670-6ca1-11cf-a99b-00aa006bc149
#define WINNT_CLSID_WinNTFileShare         b41ac100-6ca1-11cf-a99b-00aa006bc149
#define WINNT_CLSID_WinNTResource          f435bbf0-873d-11cf-a99f-00aa006bc149

#define WINNT_CLSID_WinNTSchema            6dc32210-4d19-11cf-9e74-00aa004a5691
#define WINNT_CLSID_WinNTClass             6dc32211-4d19-11cf-9e74-00aa004a5691
#define WINNT_CLSID_WinNTProperty          6dc32212-4d19-11cf-9e74-00aa004a5691
#define WINNT_CLSID_WinNTSyntax            6dc32213-4d19-11cf-9e74-00aa004a5691

#define WINNT_CLSID_FPNWFileService        a117d530-a1eb-11cf-a9a5-00aa006bc149
#define WINNT_CLSID_FPNWSession            a819cb50-a1eb-11cf-a9a5-00aa006bc149
#define WINNT_CLSID_FPNWFileShare          adf040b0-a1eb-11cf-a9a5-00aa006bc149 
#define WINNT_CLSID_FPNWResource           b381f2a0-a1eb-11cf-a9a5-00aa006bc149
=== C:/Users/treeman/Desktop/windows nt source code\Source\Win2K3\NT\ds\adsi\winnt\win95\makefile.inc ===
!INCLUDE ..\common\makefile.inc



=== C:/Users/treeman/Desktop/windows nt source code\Source\Win2K3\NT\ds\adsi\winnt\umiglob.cxx ===
//----------------------------------------------------------------------------
//
//  Microsoft Windows
//  Copyright (C) Microsoft Corporation, 1992 - 2000.
//
//  File:     umiglob.cxx
//
//  Contents: Contains definition of UMI global variables
//
//  History:  02-28-00    SivaramR  Created.
//
//----------------------------------------------------------------------------

#include "winnt.hxx"

UMI_TYPE g_mapNTTypeToUmiType[] = {
        UMI_TYPE_NULL,            // no NT_SYNTAX value of 0
        UMI_TYPE_BOOL,            // NT_SYNTAX_ID_BOOL
        UMI_TYPE_SYSTEMTIME,      // NT_SYNTAX_ID_SYSTEMTIME
        UMI_TYPE_I4,              // NT_SYNTAX_ID_DWORD
        UMI_TYPE_LPWSTR,          // NT_SYNTAX_ID_LPTSTR
        UMI_TYPE_LPWSTR,          // NT_SYNTAX_ID_DelimitedString
        UMI_TYPE_LPWSTR,          // NT_SYNTAX_ID_NulledString
        UMI_TYPE_SYSTEMTIME,      // NT_SYNTAX_ID_DATE
        UMI_TYPE_SYSTEMTIME,      // NT_SYNTAX_ID_DATE_1970
        UMI_TYPE_OCTETSTRING,     // NT_SYNTAX_ID_OCTETSTRING
        UMI_TYPE_LPWSTR           // NT_SYNTAX_ID_EncryptedString
        };

DWORD g_dwNumNTTypes = sizeof(g_mapNTTypeToUmiType) /
                                sizeof(g_mapNTTypeToUmiType[0]); 

ADSIToUMI g_IADsProps[] = 
    { { TEXT("ADsPath"), TEXT(UMIOBJ_INTF_PROP_PATH) },
      { TEXT("Class"), TEXT(UMIOBJ_INTF_PROP_CLASS) },
      { TEXT("Name"), TEXT(UMIOBJ_INTF_PROP_NAME) },
      { TEXT("Parent"), TEXT(UMIOBJ_INTF_PROP_PARENT) },
      { TEXT("Schema"), TEXT(UMIOBJ_INTF_PROP_SCHEMA) }
    };

DWORD g_dwIADsProperties = sizeof(g_IADsProps) / sizeof(ADSIToUMI);
 
    
#define UMI_MAX_STRLEN 1024
#define UMI_MAX_LONG 0x7fffffff

// interface properties on IUmiObject. 
PROPERTYINFO ObjClass[] = 
    { { TEXT(UMIOBJ_INTF_PROP_PATH), TEXT(""), TEXT("String"), 
        UMI_MAX_STRLEN, 0, FALSE, PROPERTY_READABLE, 0, NT_SYNTAX_ID_LPTSTR },
      { TEXT(UMIOBJ_INTF_PROP_CLASS), TEXT(""), TEXT("String"),
        UMI_MAX_STRLEN, 0, FALSE, PROPERTY_READABLE, 0, NT_SYNTAX_ID_LPTSTR },
      { TEXT(UMIOBJ_INTF_PROP_NAME), TEXT(""), TEXT("String"),
        UMI_MAX_STRLEN, 0, FALSE, PROPERTY_READABLE, 0, NT_SYNTAX_ID_LPTSTR },
      { TEXT(UMIOBJ_INTF_PROP_PARENT), TEXT(""), TEXT("String"),
        UMI_MAX_STRLEN, 0, FALSE, PROPERTY_READABLE, 0, NT_SYNTAX_ID_LPTSTR },
      { TEXT(UMIOBJ_INTF_PROP_SCHEMA), TEXT(""), TEXT("String"),
        UMI_MAX_STRLEN, 0, FALSE, PROPERTY_READABLE, 0, NT_SYNTAX_ID_LPTSTR }, 
      { TEXT(UMIOBJ_INTF_PROP_RELURL), TEXT(""), TEXT("String"),
        UMI_MAX_STRLEN, 0, FALSE, PROPERTY_READABLE, 0, NT_SYNTAX_ID_LPTSTR },
      { TEXT(UMIOBJ_INTF_PROP_FULLURL), TEXT(""), TEXT("String"),
        UMI_MAX_STRLEN, 0, FALSE, PROPERTY_READABLE, 0, NT_SYNTAX_ID_LPTSTR },
      { TEXT(UMIOBJ_INTF_PROP_URL), TEXT(""), TEXT("String"),
        UMI_MAX_STRLEN, 0, FALSE, PROPERTY_READABLE, 0, NT_SYNTAX_ID_LPTSTR },
      { TEXT(UMIOBJ_INTF_PROP_RELPATH), TEXT(""), TEXT("String"),
        UMI_MAX_STRLEN, 0, FALSE, PROPERTY_READABLE, 0, NT_SYNTAX_ID_LPTSTR },
      { TEXT(UMIOBJ_INTF_PROP_GENUS), TEXT(""), TEXT("Integer"),
        UMI_MAX_LONG, 0, FALSE, PROPERTY_READABLE, 0, NT_SYNTAX_ID_DWORD },
      { TEXT(UMIOBJ_INTF_PROP_SCHEMAPATH), TEXT(""), TEXT("String"),
        UMI_MAX_STRLEN, 0, FALSE, PROPERTY_READABLE, 0, NT_SYNTAX_ID_LPTSTR },
      { TEXT(UMIOBJ_INTF_PROP_KEY), TEXT(""), TEXT("String"),
        UMI_MAX_STRLEN, 0, FALSE, PROPERTY_READABLE, 0, NT_SYNTAX_ID_LPTSTR },
      { TEXT(UMIOBJ_INTF_PROP_SUPERCLASS), TEXT(""), TEXT("String"),
        UMI_MAX_STRLEN, 0, FALSE, PROPERTY_READABLE, 0, NT_SYNTAX_ID_LPTSTR },
      { TEXT(UMIOBJ_INTF_PROP_FULLRELURL), TEXT(""), TEXT("String"),
        UMI_MAX_STRLEN, 0, FALSE, PROPERTY_READABLE, 0, NT_SYNTAX_ID_LPTSTR },
      { TEXT(UMIOBJ_INTF_PROP_PROPERTY_COUNT), TEXT(""), TEXT("String"),
        UMI_MAX_STRLEN, 0, FALSE, PROPERTY_READABLE, 0, NT_SYNTAX_ID_LPTSTR }
    };
DWORD g_dwObjClassSize = sizeof(ObjClass)/sizeof(PROPERTYINFO); 

// interface properties on IUmiCOnnection.
PROPERTYINFO ConnectionClass[] =
    { { TEXT(CONN_INTF_PROP_USERNAME), TEXT(""), TEXT("String"), UMI_MAX_STRLEN,
        0, FALSE, PROPERTY_RW, 0, NT_SYNTAX_ID_LPTSTR },
      { TEXT(CONN_INTF_PROP_PASSWORD), TEXT(""), TEXT("String"), UMI_MAX_STRLEN,
        0, FALSE, PROPERTY_RW, 0, NT_SYNTAX_ID_EncryptedString },
      { TEXT(CONN_INTF_PROP_SECURE_AUTH), TEXT(""), TEXT("Boolean"), 1, 0,
        FALSE, PROPERTY_RW, 0, NT_SYNTAX_ID_BOOL },
      { TEXT(CONN_INTF_PROP_READONLY_SERVER), TEXT(""), TEXT("Boolean"), 1, 0,
        FALSE, PROPERTY_RW, 0, NT_SYNTAX_ID_BOOL } 
    };

DWORD g_dwConnectionTableSize = sizeof(ConnectionClass) /
                                            sizeof(PROPERTYINFO);

PROPERTYINFO CursorClass[] =
    { { TEXT(CURSOR_INTF_PROP_FILTER), TEXT(""), TEXT("String"), UMI_MAX_STRLEN,        0, TRUE, PROPERTY_RW, 0, NT_SYNTAX_ID_LPTSTR }
    };

DWORD g_dwCursorTableSize = sizeof(CursorClass) /
                                           sizeof(PROPERTYINFO);

PROPERTYINFO SchClassClass[] =
    { { TEXT("PrimaryInterface"), TEXT(""), TEXT("String"), UMI_MAX_STRLEN, 0, 
        FALSE, PROPERTY_READABLE, 0, NT_SYNTAX_ID_LPTSTR },
      { TEXT("CLSID"), TEXT(""), TEXT("String"), UMI_MAX_STRLEN, 0,
        FALSE, PROPERTY_READABLE, 0, NT_SYNTAX_ID_LPTSTR },
      { TEXT("OID"), TEXT(""), TEXT("String"), UMI_MAX_STRLEN, 0,
        FALSE, PROPERTY_READABLE, 0, NT_SYNTAX_ID_LPTSTR },
      { TEXT("Abstract"), TEXT(""), TEXT("Boolean"), 1, 0, FALSE, 
        PROPERTY_READABLE, 0, NT_SYNTAX_ID_BOOL },
      { TEXT("Auxiliary"), TEXT(""), TEXT("Boolean"), 1, 0, FALSE,
        PROPERTY_READABLE, 0, NT_SYNTAX_ID_BOOL },        
      { TEXT("MandatoryProperties"), TEXT(""), TEXT("String"), UMI_MAX_STRLEN, 
        0, TRUE, PROPERTY_READABLE, 0, NT_SYNTAX_ID_LPTSTR },
      { TEXT("OptionalProperties"), TEXT(""), TEXT("String"), UMI_MAX_STRLEN,
        0, TRUE, PROPERTY_READABLE, 0, NT_SYNTAX_ID_LPTSTR },
      { TEXT("PossibleSuperiors"), TEXT(""), TEXT("String"), UMI_MAX_STRLEN,
        0, TRUE, PROPERTY_READABLE, 0, NT_SYNTAX_ID_LPTSTR }, 
      { TEXT("Containment"), TEXT(""), TEXT("String"), UMI_MAX_STRLEN,
        0, TRUE, PROPERTY_READABLE, 0, NT_SYNTAX_ID_LPTSTR },
      { TEXT("Container"), TEXT(""), TEXT("Boolean"), 1, 0, FALSE,
        PROPERTY_READABLE, 0, NT_SYNTAX_ID_BOOL },
      { TEXT("HelpFileName"), TEXT(""), TEXT("String"), UMI_MAX_STRLEN, 0,
        FALSE, PROPERTY_READABLE, 0, NT_SYNTAX_ID_LPTSTR },
      { TEXT("HelpFileContext"), TEXT(""), TEXT("Integer"),
        UMI_MAX_LONG, 0, FALSE, PROPERTY_READABLE, 0, NT_SYNTAX_ID_DWORD },
      { TEXT("Name"), TEXT(""), TEXT("String"), UMI_MAX_STRLEN, 0,
        FALSE, PROPERTY_READABLE, 0, NT_SYNTAX_ID_LPTSTR }
    };

DWORD g_dwSchClassClassTableSize = sizeof(SchClassClass)/sizeof(PROPERTYINFO);

PROPERTYINFO PropertyClass[] =
    { { TEXT("OID"), TEXT(""), TEXT("String"), UMI_MAX_STRLEN, 0,
        FALSE, PROPERTY_READABLE, 0, NT_SYNTAX_ID_LPTSTR },
      { TEXT("Syntax"), TEXT(""), TEXT("String"), UMI_MAX_STRLEN, 0,
        FALSE, PROPERTY_READABLE, 0, NT_SYNTAX_ID_LPTSTR },
      { TEXT("MaxRange"), TEXT(""), TEXT("Integer"),
        UMI_MAX_LONG, 0, FALSE, PROPERTY_READABLE, 0, NT_SYNTAX_ID_DWORD },
      { TEXT("MinRange"), TEXT(""), TEXT("Integer"),
        UMI_MAX_LONG, 0, FALSE, PROPERTY_READABLE, 0, NT_SYNTAX_ID_DWORD },
      { TEXT("Multivalued"), TEXT(""), TEXT("Boolean"), 1, 0, FALSE,
        PROPERTY_READABLE, 0, NT_SYNTAX_ID_BOOL },
      { TEXT("Name"), TEXT(""), TEXT("String"), UMI_MAX_STRLEN, 0,
        FALSE, PROPERTY_READABLE, 0, NT_SYNTAX_ID_LPTSTR }
    };

DWORD g_dwPropertyClassTableSize = sizeof(PropertyClass)/sizeof(PROPERTYINFO);

PROPERTYINFO SyntaxClass[] =
    { { TEXT("OleAutoDataType"), TEXT(""), TEXT("Integer"),
        UMI_MAX_LONG, 0, FALSE, PROPERTY_READABLE, 0, NT_SYNTAX_ID_DWORD },
      { TEXT("Name"), TEXT(""), TEXT("String"), UMI_MAX_STRLEN, 0,
        FALSE, PROPERTY_READABLE, 0, NT_SYNTAX_ID_LPTSTR }
    };

DWORD g_dwSyntaxTableSize = sizeof(SyntaxClass)/sizeof(PROPERTYINFO);

PROPERTYINFO SchemaClass[] = 
    { { TEXT("Name"), TEXT(""), TEXT("String"), UMI_MAX_STRLEN, 0,
        FALSE, PROPERTY_READABLE, 0, NT_SYNTAX_ID_LPTSTR }
    };

DWORD g_dwSchemaClassTableSize = sizeof(SchemaClass)/sizeof(PROPERTYINFO);

// Unimplemented standard interface properties on IUmiObject
LPWSTR g_UmiObjUnImplProps[] = 
   { L"__GUIDURL",
     L"__SECURITY_DESCRIPTOR",
     L"__SD_ACCESS",
     L"__TIME_MODIFIED",
     L"__TIME_CREATED",
     L"__GUID",
     NULL
   };

// Unimplemented standard interface properties on IUmiConnection
LPWSTR g_UmiConUnImplProps[] =
   { L"__TIMEOUT",
     L"__ENCRYPTION_METHOD",
     L"__NO_AUTHENTICATION",
     NULL
   };
=== C:/Users/treeman/Desktop/windows nt source code\Source\Win2K3\NT\ds\adsi\winnt\winnt\makefile.inc ===
!INCLUDE ..\common\makefile.inc



=== C:/Users/treeman/Desktop/windows nt source code\Source\Win2K3\NT\ds\adsi\winnt\winntrc.h ===
#ifndef __ADSRC_H__
#define __ADSRC_H__

#define ADS_WINNT_BUILTIN           600000
#define ADS_WINNT_NT_AUTHORITY 	    600001
#define ADS_WINNT_NONE              600002
#define ADS_WINNT_EVERYONE          600003

#endif
=== C:/Users/treeman/Desktop/windows nt source code\Source\Win2K3\NT\ds\adsi\winnt\umi.cxx ===
//----------------------------------------------------------------------------
//
//  Microsoft Windows
//  Copyright (C) Microsoft Corporation, 1992 - 2000.
//
//  File:     umi.cxx
//
//  Contents: Contains miscellaneous UMI routines.
//
//  History:  02-28-00    SivaramR  Created.
//
//----------------------------------------------------------------------------

#include "winnt.hxx"

//----------------------------------------------------------------------------
// Function:   IsPreDefinedErrorCode 
//
// Synopsis:   Returns TRUE if the error code passed in is a valid UMI error
//             code i.e one that can be returned by a UMI method. Returns
//             FALSE otherwise. 
//
// Arguments:  Self explanatory
//
// Returns:    TRUE/FALSE as mentioned above 
//
// Modifies:   Nothing
//
//----------------------------------------------------------------------------
BOOL IsPreDefinedErrorCode(HRESULT hr)
{
    switch(hr) {
        case E_UNEXPECTED:
        case E_NOTIMPL:
        case E_OUTOFMEMORY:
        case E_INVALIDARG:
        case E_NOINTERFACE:
        case E_POINTER:
        case E_HANDLE:
        case E_ABORT:
        case E_FAIL:
        case E_ACCESSDENIED:
        case E_PENDING:
        case UMI_E_TYPE_MISMATCH:
        case UMI_E_NOT_FOUND:
        case UMI_E_INVALID_FLAGS:
        case UMI_E_UNSUPPORTED_OPERATION:
        case UMI_E_UNSUPPORTED_FLAGS:
        case UMI_E_SYNCHRONIZATION_REQUIRED:
        case UMI_E_UNBOUND_OBJECT:

            RRETURN(TRUE);

        default:

            RRETURN(FALSE);
    }
}

//----------------------------------------------------------------------------
// Function:   MapHrToUmiError 
//
// Synopsis:   This function returns the UMI error corresponding to a HRESULT
//             returned by the WinNT provider. The HRESULT can be retrieved
//             using GetLastStatus(), if required.
//
// Arguments:  Self explanatory
//
// Returns:    UMI error corresponding to the HRESULT 
//
// Modifies:   Nothing
//
//----------------------------------------------------------------------------
HRESULT MapHrToUmiError(HRESULT hr)
{
    if(SUCCEEDED(hr)) {
        if(S_FALSE == hr) // may be returned by end of cursor enumeration
            RRETURN(UMI_S_FALSE);
        else
            RRETURN(UMI_S_NO_ERROR);
    }

    // we had a failure
    if(TRUE == IsPreDefinedErrorCode(hr))
        RRETURN(hr); // OK to return this as a UMI error

    // Try to map ADSI errors to appropriate UMI errors. Default is to
    // map to E_FAIL.
    switch(hr) {
        case E_ADS_INVALID_DOMAIN_OBJECT:
        case E_ADS_INVALID_USER_OBJECT:
        case E_ADS_INVALID_COMPUTER_OBJECT:
        case E_ADS_UNKNOWN_OBJECT:
        
            RRETURN(UMI_E_OBJECT_NOT_FOUND);

        case E_ADS_PROPERTY_NOT_FOUND:
            RRETURN(UMI_E_PROPERTY_NOT_FOUND);

        case E_ADS_BAD_PARAMETER:
            RRETURN(UMI_E_INVALIDARG);

        case E_ADS_CANT_CONVERT_DATATYPE:
            RRETURN(UMI_E_TYPE_MISMATCH);

        case E_ADS_BAD_PATHNAME:
            RRETURN(UMI_E_INVALIDARG);

        case E_ADS_OBJECT_UNBOUND:
            RRETURN(UMI_E_UNBOUND_OBJECT);

        case HRESULT_FROM_WIN32(NERR_UserNotFound):
        case HRESULT_FROM_WIN32(NERR_GroupNotFound):
        case HRESULT_FROM_WIN32(ERROR_NO_SUCH_DOMAIN):
        case HRESULT_FROM_WIN32(ERROR_BAD_NETPATH):

            RRETURN(UMI_E_OBJECT_NOT_FOUND);

        default:
            RRETURN(UMI_E_FAIL);
    }
}

//----------------------------------------------------------------------------
// Function:   ValidateUrl 
//
// Synopsis:   This function checks to see if a UMI path has the correct
//             namespace and server.
//
// Arguments:
//
// pURL        Pointer to URL interface containing the UMI path
//
// Returns:    S_OK on success. Error code otherwise.
//
// Modifies:   Nothing 
//
//----------------------------------------------------------------------------
static HRESULT ValidateUrl(
    IUmiURL *pURL
    )
{
    HRESULT hr = S_OK;
    WCHAR   pszTmpArray[MAX_URL+1];
    ULONG   ulTmpArraySize = 0;
    ULONGLONG PathType = 0;

    hr = pURL->GetPathInfo(0, &PathType);
    BAIL_ON_FAILURE(hr);

    if(PathType & UMIPATH_INFO_RELATIVE_PATH)
    // relative paths cannot be converted to a WinNT path
        BAIL_ON_FAILURE(hr = UMI_E_INVALID_PATH);
 
    // Make sure server name is empty. WinNT does not support servername
    // in UMI path.
    ulTmpArraySize = MAX_URL;
    hr = pURL->GetLocator(
        &ulTmpArraySize,
        pszTmpArray
        );
    if(WBEM_E_BUFFER_TOO_SMALL == hr)
    // Locator is not an empty string
        hr = UMI_E_INVALID_PATH;
    BAIL_ON_FAILURE(hr);

    if(wcscmp(pszTmpArray, L""))
        BAIL_ON_FAILURE(hr = UMI_E_INVALID_PATH);

    // Make sure namespace is WinNT
    ulTmpArraySize = MAX_URL;
    hr = pURL->GetRootNamespace(
        &ulTmpArraySize,
        pszTmpArray
        );
    if(WBEM_E_BUFFER_TOO_SMALL == hr)
    // Namespace is not WinNT
        hr = UMI_E_INVALID_PATH;
    BAIL_ON_FAILURE(hr);

    if(_wcsicmp(pszTmpArray, L"WinNT"))
        BAIL_ON_FAILURE(hr = UMI_E_INVALID_PATH);

error:

    RRETURN(hr);
}


 
//----------------------------------------------------------------------------
// Function:   UmiToWinNTPath 
//
// Synopsis:   This function converts a UMI path into a native path. 
//
// Arguments: 
//
// pURL          Pointer to URL interface containing the UMI path
// ppszWinNTPath Returns the WinNT path 
// pdwNumComps   Returns the number of components in the UMI path
// pppszClasses  Returns the class of each component in the UMI path
//
// Returns:    S_OK on success. Error code otherwise. 
//
// Modifies:   *ppszWinNTPath to return the WinNT path
//             *pdwNumComps to return the number of components
//             *pppszClasses to return the class of each component
//
//----------------------------------------------------------------------------
HRESULT UmiToWinNTPath(
    IUmiURL *pURL,  
    WCHAR   **ppszWinNTPath,
    DWORD *pdwNumComps,
    LPWSTR **pppszClasses
    )
{
    HRESULT hr = S_OK;
    WCHAR   *pszWinNTPath = NULL;
    WCHAR   pszTmpArray[MAX_URL+1], pszValueArray[MAX_URL+1];
    WCHAR   *pszValuePtr = NULL, pszClassArray[MAX_URL+1];
    ULONG   ulTmpArraySize = 0, ulNumComponents = 0, ulIndex = 0;
    ULONG   ulKeyCount = 0, ulValueArraySize = 0, ulClassArraySize = 0;
    IUmiURLKeyList *pKeyList = NULL;
    LPWSTR  *ppszClasses = NULL;

    ADsAssert( (pURL != NULL) && (ppszWinNTPath != NULL) &&
               (pdwNumComps != NULL) && (pppszClasses != NULL) );

    *ppszWinNTPath = NULL;
    *pdwNumComps = 0;
    *pppszClasses = NULL;

    hr = ValidateUrl(pURL);
    BAIL_ON_FAILURE(hr);

    // Get the total length needed for the WinNT path
    ulTmpArraySize = MAX_URL;
    hr = pURL->Get(0, &ulTmpArraySize, pszTmpArray);
    if(hr != WBEM_E_BUFFER_TOO_SMALL)
        BAIL_ON_FAILURE(hr);

    pszWinNTPath = (WCHAR *) AllocADsMem(ulTmpArraySize * sizeof(WCHAR));
    if(NULL == pszWinNTPath)
        BAIL_ON_FAILURE(hr = UMI_E_OUT_OF_MEMORY);

    wsprintf(pszWinNTPath, L"%s", L"WinNT:");

    hr = pURL->GetComponentCount(&ulNumComponents);
    BAIL_ON_FAILURE(hr);

    if(0 == ulNumComponents) {
    // umi:///winnt translates to WinNT: . Nothing more to do
        *ppszWinNTPath = pszWinNTPath;
        RRETURN(S_OK);
    }

    ppszClasses = (LPWSTR *) AllocADsMem(ulNumComponents * sizeof(LPWSTR *));
    if(NULL == ppszClasses) {
        BAIL_ON_FAILURE(hr = UMI_E_OUT_OF_MEMORY);
    }
    memset(ppszClasses, 0, ulNumComponents * sizeof(LPWSTR *));

    // we have at least one component in the path
    wcscat(pszWinNTPath, L"/");

    for(ulIndex = 0; ulIndex < ulNumComponents; ulIndex++) {
        ulClassArraySize = MAX_URL;
        pKeyList = NULL;

        hr = pURL->GetComponent(
            ulIndex,
            &ulClassArraySize, 
            pszClassArray,
            &pKeyList
            );
        if(WBEM_E_BUFFER_TOO_SMALL == hr)
        // none of the WinNT classes is so long, so this has to be a bad path.
            hr = UMI_E_INVALID_PATH;
        BAIL_ON_FAILURE(hr);

        // WinNT does not supports components with an empty class name
        if(!wcscmp(pszClassArray, L""))
            BAIL_ON_FAILURE(hr = UMI_E_INVALID_PATH);

        ppszClasses[ulIndex] = AllocADsStr(pszClassArray);
        if(NULL == ppszClasses[ulIndex]) {
            BAIL_ON_FAILURE(hr = UMI_E_OUT_OF_MEMORY); 
        }

        ADsAssert(pKeyList != NULL);

        // make sure there is only one key
        hr = pKeyList->GetCount(&ulKeyCount);
        BAIL_ON_FAILURE(hr);

        if(ulKeyCount != 1)
            BAIL_ON_FAILURE(hr = UMI_E_INVALID_PATH);

        ulValueArraySize = MAX_URL;
        ulTmpArraySize = MAX_URL;
        pszValuePtr = pszValueArray;
        hr = pKeyList->GetKey(
            0,
            0,
            &ulTmpArraySize,
            pszTmpArray,
            &ulValueArraySize,
            pszValueArray
            );
        if( (WBEM_E_BUFFER_TOO_SMALL == hr) && (ulValueArraySize > MAX_URL) ) {
            pszValuePtr = (WCHAR *) AllocADsMem(ulValueArraySize);
            if(NULL == pszValuePtr)
                BAIL_ON_FAILURE(hr = UMI_E_OUT_OF_MEMORY);

            hr = pKeyList->GetKey(
                0,
                0,
                &ulTmpArraySize,
                pszTmpArray,
                &ulValueArraySize,
                pszValuePtr
                );
        }
        if(WBEM_E_BUFFER_TOO_SMALL == hr)
        // Key is always "Name" in WinNT. So, if the size required if so
        // high, it indicates a bad path
            hr = UMI_E_INVALID_PATH;

        BAIL_ON_FAILURE(hr);
       
        // Key has to be "Name" or empty in WinNT
        if( _wcsicmp(pszTmpArray, WINNT_KEY_NAME) && wcscmp(pszTmpArray, L"") )
            BAIL_ON_FAILURE(hr = UMI_E_INVALID_PATH); 

        // append the value to the WinNT path
        wcscat(pszWinNTPath, L"/");
        wcscat(pszWinNTPath, pszValuePtr);

        if(pszValuePtr != pszValueArray)
            FreeADsMem(pszValuePtr);

        pKeyList->Release();
    } // for

    // append the class to the WInNT path
    wcscat(pszWinNTPath, L",");
    wcscat(pszWinNTPath, pszClassArray);
 
    *ppszWinNTPath = pszWinNTPath;
    *pdwNumComps = ulNumComponents;
    *pppszClasses = ppszClasses;

     RRETURN(S_OK);
   
error:

    if(pszWinNTPath != NULL)
        FreeADsMem(pszWinNTPath);

    if( (pszValuePtr != NULL) && (pszValuePtr != pszValueArray) )
        FreeADsMem(pszValuePtr);

    if(ppszClasses != NULL) {
        for(ulIndex = 0; ulIndex < ulNumComponents; ulIndex++) {
            if(ppszClasses[ulIndex] != NULL)
                FreeADsStr(ppszClasses[ulIndex]);
        }

        FreeADsMem(ppszClasses);
    } 
             
    if(pKeyList != NULL)
        pKeyList->Release();

    RRETURN(hr);
}

//----------------------------------------------------------------------------
// Function:   ADsToUmiPath
//
// Synopsis:   This function converts an ADsPath to a UMI path (full, short or
//             relative depending on a flag).
//
// Arguments:
//
// bstrADsPath   ADsPath to be converted
// pObjectInfo   Contains the values of each component in the ADsPath
// CompClasses   Array containing the classes of each component of the ADsPath
// dwNumComponents  Number of classes(components) in the ADsPath 
// dwUmiPathType Specifies the format of the UMI path to be returned
// ppszUmiPath   Returns UMI path in the requested format
//
// Returns:    S_OK on success. Error code otherwise.
//
// Modifies:   *ppszUmiPath to return the UMI path
//
//----------------------------------------------------------------------------
HRESULT ADsToUmiPath(
    BSTR bstrADsPath,
    OBJECTINFO *pObjectInfo,
    LPWSTR CompClasses[],
    DWORD dwNumComponents,
    DWORD dwUmiPathType,
    LPWSTR *ppszUmiPath
    )
{
    HRESULT hr = S_OK;
    DWORD   dwBufferLen = 0, dwIndex = 0;
    LPWSTR  pszUmiPath = NULL, *pszComponents = NULL;

    ADsAssert( (bstrADsPath != NULL) && (CompClasses != NULL) && 
               (pObjectInfo != NULL) && (ppszUmiPath != NULL) );
    *ppszUmiPath = NULL;

    // calculate approximate length of buffer required to return the UMI path
    // Each component is of the form "class.name=value". "value" is already
    // part of the ADSI path. Include the size of each class and add 6 to 
    // account for "Name" and '.' and '='.
    dwBufferLen = wcslen(L"umi:///winnt/") + wcslen(bstrADsPath) +
                  dwNumComponents * (MAX_CLASS + 6) + 1;

    pszUmiPath = (LPWSTR) AllocADsMem(dwBufferLen * sizeof(WCHAR));
    if(NULL == pszUmiPath)
        BAIL_ON_FAILURE(hr = UMI_E_OUT_OF_MEMORY);

    // if ADsPath is empty and it is not a namespace object, then this must be
    // a session, resource or  printjob object. Return an empty path for these.
    // Namespace objects have no components in the ADsPath, but they have a
    // non-empty ADsPath ("WinNT:")
    if( (0 == dwNumComponents) && _wcsicmp(CompClasses[0], L"Namespace") ) {
        wcscpy(pszUmiPath, L"");
        *ppszUmiPath = pszUmiPath;
    
        RRETURN(S_OK);
    } 

    if( (RELATIVE_UMI_PATH == dwUmiPathType) || 
        (FULL_RELATIVE_UMI_PATH == dwUmiPathType) ) {
        // return the last component, if any

        if(0 == dwNumComponents) {
            *pszUmiPath = '\0';
        }
        else {
            wcscpy(pszUmiPath, 
                   CompClasses[dwNumComponents - 1]
                   );
            if(FULL_RELATIVE_UMI_PATH == dwUmiPathType)
                wcscat(pszUmiPath, L".Name=");
            else
                wcscat(pszUmiPath, L"=");
    
            pszComponents = pObjectInfo->DisplayComponentArray;        

            wcscat(pszUmiPath, pszComponents[dwNumComponents - 1]);
        }

        *ppszUmiPath = pszUmiPath;

        RRETURN(S_OK);
    }

    wcscpy(pszUmiPath, L"umi:///winnt");

    // for namespace objects, there are no components and hence the umi path
    // is completely constructed at this point.
    if(0 == dwNumComponents) {
        *ppszUmiPath = pszUmiPath;
        RRETURN(S_OK);
    }

    wcscat(pszUmiPath, L"/");

    pszComponents = pObjectInfo->DisplayComponentArray;

    for(dwIndex = 0; dwIndex < dwNumComponents; dwIndex++) {
        wcscat(pszUmiPath, CompClasses[dwIndex]);
        if(FULL_UMI_PATH == dwUmiPathType)
            wcscat(pszUmiPath, L".Name=");
        else if(SHORT_UMI_PATH == dwUmiPathType)
            wcscat(pszUmiPath, L"=");

        wcscat(pszUmiPath, pszComponents[dwIndex]);
        if(dwIndex != (dwNumComponents - 1))
            wcscat(pszUmiPath, L"/");
    }

    *ppszUmiPath = pszUmiPath;

    RRETURN(S_OK);

error:

    if(pszUmiPath != NULL)
        FreeADsMem(pszUmiPath);

    RRETURN(hr);
}
=== C:/Users/treeman/Desktop/windows nt source code\Source\Win2K3\NT\ds\adsi\winnt\var2nt.cxx ===
//+---------------------------------------------------------------------------
//
//  Microsoft Windows
//  Copyright (C) Microsoft Corporation, 1992 - 1995.
//
//  File:       var2winnt.cxx
//
//  Contents:
//
//  Functions:
//
//  History:      13-June-1996   RamV   Created.
//
//
//  Issues:     Check null ptrs for AllocADsMem and AllocADsStr
//
//----------------------------------------------------------------------------

#include "winnt.hxx"
#pragma  hdrstop
#define INITGUID


//
// WinNT objects copy code
//

HRESULT
VarTypeToWinNTTypeCopyBOOL(
    PVARIANT lpVarSrcObject,
    PNTOBJECT pNTDestValue
    )
{
    HRESULT hr = S_OK;

    if(!lpVarSrcObject){
        RRETURN(E_POINTER);
    }

    if(lpVarSrcObject->vt != VT_BOOL){
        RRETURN(hr = E_ADS_CANT_CONVERT_DATATYPE);
    }

    pNTDestValue->NTType = NT_SYNTAX_ID_BOOL;

    if(lpVarSrcObject->boolVal){
        (pNTDestValue->NTValue).fValue = TRUE;

    } else {
        (pNTDestValue->NTValue).fValue = FALSE;
    }

    RRETURN(hr);
}

HRESULT
VarTypeToWinNTTypeCopySYSTEMTIME(
    PVARIANT lpVarSrcObject,
    PNTOBJECT pNTDestValue
    )
{
    HRESULT hr = S_OK;

    if(!lpVarSrcObject){
        RRETURN(E_POINTER);
    }

    if(lpVarSrcObject->vt != VT_DATE){
        RRETURN(hr = E_ADS_CANT_CONVERT_DATATYPE);
    }

    hr = ConvertDATEToSYSTEMTIME(lpVarSrcObject->date,
                                 &(pNTDestValue->NTValue.stSystemTimeValue) );


    RRETURN( hr );
}


HRESULT
VarTypeToWinNTTypeCopyDWORD(
    PVARIANT lpVarSrcObject,
    PNTOBJECT pNTDestValue
    )
{
    HRESULT hr = S_OK;

    if(lpVarSrcObject->vt == VT_I4){

        (pNTDestValue->NTValue).dwValue =
                (DWORD)lpVarSrcObject->lVal;
    }
    else if (lpVarSrcObject->vt == VT_I2) {

        (pNTDestValue->NTValue).dwValue =
                (DWORD)lpVarSrcObject->iVal;
    }
    else {
        RRETURN(hr = E_ADS_CANT_CONVERT_DATATYPE);
    }

    pNTDestValue->NTType = NT_SYNTAX_ID_DWORD;

    RRETURN(hr);

}

HRESULT
VarTypeToWinNTTypeCopyDATE(
    PVARIANT lpVarSrcObject,
    PNTOBJECT pNTDestValue
    )
{
    HRESULT hr = S_OK;
    SYSTEMTIME stTime;

    if(lpVarSrcObject->vt != VT_DATE){
        RRETURN(hr = E_ADS_CANT_CONVERT_DATATYPE);
    }

    pNTDestValue->NTType = NT_SYNTAX_ID_DATE;


    //
    // Note carefully! date is supplied as a value which is < 1 however
    // VariantTimeToDosDateTime complains when given a value < 30000.
    // (Number of days between 1900 and 1980). So
    // we add 35000 to make it a legal value.
    //

    hr = ConvertDATEToSYSTEMTIME(lpVarSrcObject->date+ 35000,
                                 &stTime);

    BAIL_ON_FAILURE(hr);

    (pNTDestValue->NTValue).dwValue = stTime.wHour*60 + stTime.wMinute ;


error:
    RRETURN(hr);

}

HRESULT
VarTypeToWinNTTypeCopyDATE70(
    PVARIANT lpVarSrcObject,
    PNTOBJECT pNTDestValue
    )
{
    HRESULT hr = S_OK;
    SYSTEMTIME stTime;
    DWORD dwSeconds1970 = 0;

    if(lpVarSrcObject->vt != VT_DATE){
        RRETURN(hr = E_ADS_CANT_CONVERT_DATATYPE);
    }

    pNTDestValue->NTType = NT_SYNTAX_ID_DATE_1970;

    hr = ConvertDATEtoDWORD(
                lpVarSrcObject->date,
                &dwSeconds1970
                );
    BAIL_ON_FAILURE(hr);

    (pNTDestValue->NTValue).dwSeconds1970 = dwSeconds1970 ;

error:
    RRETURN(hr);

}

HRESULT
VarTypeToWinNTTypeCopyLPTSTR(
    PVARIANT lpVarSrcObject,
    PNTOBJECT   pNTDestValue
    )
{
    HRESULT hr = S_OK;

    if(lpVarSrcObject->vt != VT_BSTR){
        RRETURN(hr = E_ADS_CANT_CONVERT_DATATYPE);
    }

    pNTDestValue->NTType = NT_SYNTAX_ID_LPTSTR;

    (pNTDestValue->NTValue).pszValue =
        AllocADsStr(lpVarSrcObject->bstrVal);

    if(!(pNTDestValue->NTValue).pszValue){
        hr = E_OUTOFMEMORY;
    }

    RRETURN(hr);
}

HRESULT
VarTypeToWinNTTypeCopyOctetString(
    PVARIANT lpVarSrcObject,
    PNTOBJECT   pNTDestValue
    )
{
    HRESULT hr = S_OK;

    pNTDestValue->NTType = NT_SYNTAX_ID_OCTETSTRING;
    hr = VariantToBinary(
            lpVarSrcObject,
            &(pNTDestValue->NTValue).octetstring.dwSize,
            &(pNTDestValue->NTValue).octetstring.pByte);

    RRETURN(hr);
}


HRESULT
VarTypeToNtTypeCopy(
    DWORD dwNtType,
    PVARIANT lpVarSrcObject,
    PNTOBJECT lpNtDestObject
    )
{
    HRESULT hr = S_OK;
    switch (dwNtType){
    case NT_SYNTAX_ID_BOOL:
        hr = VarTypeToWinNTTypeCopyBOOL(
                lpVarSrcObject,
                lpNtDestObject
                );
        break;

    case NT_SYNTAX_ID_SYSTEMTIME:
        hr = VarTypeToWinNTTypeCopySYSTEMTIME(
                lpVarSrcObject,
                lpNtDestObject
                );
        break;


    case NT_SYNTAX_ID_DWORD:
        hr = VarTypeToWinNTTypeCopyDWORD(
                lpVarSrcObject,
                lpNtDestObject
                );
        break;

    case NT_SYNTAX_ID_DATE:
        hr = VarTypeToWinNTTypeCopyDATE(
                lpVarSrcObject,
                lpNtDestObject
                );
        break;


    case NT_SYNTAX_ID_DATE_1970:
        hr = VarTypeToWinNTTypeCopyDATE70(
                lpVarSrcObject,
                lpNtDestObject
                );
        break;


    case NT_SYNTAX_ID_LPTSTR:
        hr = VarTypeToWinNTTypeCopyLPTSTR(
                lpVarSrcObject,
                lpNtDestObject
                );
        break;

    case NT_SYNTAX_ID_DelimitedString:
        hr = VarTypeToWinNTTypeCopyLPTSTR(
                 lpVarSrcObject,
                 lpNtDestObject
                 );

        lpNtDestObject->NTType = NT_SYNTAX_ID_DelimitedString;
        break;

    case NT_SYNTAX_ID_NulledString:
        hr = VarTypeToWinNTTypeCopyLPTSTR(
                 lpVarSrcObject,
                 lpNtDestObject
                 );
        lpNtDestObject->NTType = NT_SYNTAX_ID_NulledString;
        break;

    case NT_SYNTAX_ID_OCTETSTRING:
        hr = VarTypeToWinNTTypeCopyOctetString(
                 lpVarSrcObject,
                 lpNtDestObject
                 );
        lpNtDestObject->NTType = NT_SYNTAX_ID_OCTETSTRING;
        break;

    default:
        hr = E_FAIL;
        break;
    }

    RRETURN(hr);
}



HRESULT
VarTypeToNtTypeCopyConstruct(
    DWORD dwNtType,
    LPVARIANT pVarSrcObjects,
    DWORD dwNumObjects,
    LPNTOBJECT * ppNtDestObjects
    )
{

    DWORD i = 0;
    LPNTOBJECT pNtDestObjects = NULL;
    HRESULT hr = S_OK;

    pNtDestObjects = (LPNTOBJECT)AllocADsMem(
                                    dwNumObjects * sizeof(NTOBJECT)
                                    );

    if (!pNtDestObjects) {
        RRETURN(E_FAIL);
    }

     for (i = 0; i < dwNumObjects; i++ ) {
         hr = VarTypeToNtTypeCopy(
                    dwNtType,
                    pVarSrcObjects + i,
                    pNtDestObjects + i
                    );
         BAIL_ON_FAILURE(hr);
     }

     *ppNtDestObjects = pNtDestObjects;

     RRETURN(S_OK);

error:

     if (pNtDestObjects) {
         //
         // Free all the objects that have already been copied.
         // NOTE: NTTypeFreeNTObjects frees the contents of each object
         // and then frees the array as well.
         //
         NTTypeFreeNTObjects(pNtDestObjects, i);
     }

     *ppNtDestObjects = NULL;

     RRETURN(hr);
}
=== C:/Users/treeman/Desktop/windows nt source code\Source\Win2K3\NT\ds\dns\dbgexts\dnsdbg.c ===
#include "header.h"
#if DBG
    char DebuggerType[] = "Checked";
#else
    char DebuggerType[] = "Free";
#endif

char COMPILED[] = "File " __FILE__ "\n"
                  "Compiled on " __DATE__ " at " __TIME__ "\n";

#if defined( _WDBGEXTS_ )

EXT_API_VERSION        ApiVersion = { 3, 5, EXT_API_VERSION_NUMBER, 0 };
WINDBG_EXTENSION_APIS  ExtensionApis;
USHORT                 SavedMajorVersion;
USHORT                 SavedMinorVersion;
BOOLEAN                ChkTarget;

void
WinDbgExtensionDllInit(
    PWINDBG_EXTENSION_APIS lpExtensionApis,
    USHORT                 MajorVersion,
    USHORT                 MinorVersion
    )
{
    ExtensionApis     = *lpExtensionApis;
    SavedMajorVersion = MajorVersion;
    SavedMinorVersion = MinorVersion;
    ChkTarget         = (SavedMajorVersion == 0x0c);
    return;
}


LPEXT_API_VERSION ExtensionApiVersion( void )
{
    return &ApiVersion;
}


DECLARE_API( version )
{
    dprintf( "%s Extension dll for Build %d debugging %s"
             "kernel for Build %d\n",

             DebuggerType,
             VER_PRODUCTBUILD,
             SavedMajorVersion == 0x0c ? "Checked" : "Free",
             SavedMinorVersion
           );
    dprintf( COMPILED );
}

#else // not _WDBGEXTS_

//
// Dummy windbg specific exports allows a common .def
// file for both ntsd and windbg.
//

NTSD_EXTENSION_APIS  ExtensionApis;
HANDLE               ExtensionCurrentProcess;

void WinDbgExtensionDllInit( void ) { return; }
void ExtensionApiVersion( void ) {    return; }

DECLARE_API( version )
{
    INIT_API();
    dprintf( "%s Extension dll for Build %d\n",
             DebuggerType, VER_PRODUCTBUILD );
    dprintf( COMPILED );
}

#endif // _WDBGEXTS

//
// Common
//

void CheckVersion( void ) {
    return;
}


DllInit( HANDLE hModule, DWORD  dwReason, DWORD  dwReserved )
{
    switch (dwReason) {
        case DLL_THREAD_ATTACH:  break;
        case DLL_THREAD_DETACH:  break;
        case DLL_PROCESS_DETACH: break;
        case DLL_PROCESS_ATTACH: break;
    }
    return TRUE;
}
=== C:/Users/treeman/Desktop/windows nt source code\Source\Win2K3\NT\ds\dns\dbgexts\export.c ===
#include "header.h"

//
//  This is the struct we want to dump.
//

//
// Dumps symbol information about Pointer.
//

void dprintSymbolPtr( void* Pointer)
{
    UCHAR SymbolName[ 80 ];
    ULONG Displacement;
    GetSymbol( Pointer, SymbolName, &Displacement );
    dprintf( "%-10lx (%s + 0x%X)%s\n", Pointer, SymbolName, Displacement );
}

// ========================================================================
// Reads the dword at p.

DWORD ReadDword( void * p )
{
    ULONG  result;
    DWORD  val;

    if ( !ReadMemory( p, &val, sizeof(DWORD), &result )){
        // dprintf( "ReadDword:Invalid DWORD * p = 0x%08x\n", p );
        val = 0;
    }
    return val;
}

WORD ReadWord( void * p )
{
    ULONG  result;
    WORD  val;

    if ( !ReadMemory( p, &val, sizeof(WORD), &result )){
        // dprintf( "ReadWord:Invalid DWORD * p = 0x%08x\n", p );
        val = 0;
    }
    return val;
}

// Read the string[n] at p, updates userstring[];
// Default len is 20 chars.

char userstring[255];

char * ReadStr( char * p, int len )
{
    ULONG  result;
    if( len <= 0 )
        len = 20;
    else if( len > sizeof( userstring ) )
        len = sizeof( userstring );

    if ( !ReadMemory( p, userstring, len, &result )){
        sprintf( userstring, "char p[%d] @ 0x%08x unreadable", len, p );
    }
    userstring[len] = '\0';
    return userstring;
}


//
// Dump the node p, and returns pointer to next node.
//

//
// Exported functions.
//

DECLARE_API( help )
{
    INIT_API();
    dprintf("Dnsapi debugger extension commands:\n\n");
    dprintf("\tdprint_CLIENT_QELEMENT <addr>   - Dump a CLIENT_QELEMENT.\n");
    dprintf("\tdprint_BUCKET <addr>   - Dump a BUCKET.\n");
    dprintf("\tdprint_ZONE_INFO <addr> \n");
    dprintf("\tdprint_SERVER_INFO <addr>   - Dump SrvCfg structure \n");
    dprintf("\tdprint_ResourceRecord <addr>   - Dump RR \n");
    return;
}

//
//  Usage: !mosh.node 002509e0
//



void print_CLIENT_QELEMENT( char* message, struct _CLIENT_QELEMENT * s );

DECLARE_API( dprint_CLIENT_QELEMENT ){    struct _CLIENT_QELEMENT * p = NULL;
    struct _CLIENT_QELEMENT   Q;    ULONG  result;    INIT_API();    if( *args )
        sscanf( args, "%lx", &p );
    if( !p || !ReadMemory( p, &Q, sizeof(Q), &result )){
       dprintf("Could not read address 0x%08x\n", p );       return;    }
    print_CLIENT_QELEMENT( "none", &Q );    return;}

// ==================================================//  _CLIENT_QELEMENTvoid

void
print_CLIENT_QELEMENT( char* message, struct _CLIENT_QELEMENT * s ){
    if(  message   ){       dprintf( "%s\n", message );    }
    if(  s == NULL ){       dprintf( "struct _CLIENT_QELEMENT is NULL.\n");
       return;    }    dprintf("struct _CLIENT_QELEMENT = {\n" );
    dprintf("  List         = 0x%08x \n", s->List );
    dprintf("  lpstrAdapterName = %s \n", ReadStr(s->lpstrAdapterName,0) );
    dprintf("  lpstrHostName = %s \n", ReadStr(s->lpstrHostName, 0) );
    dprintf("  pRegisterStatus = 0x%08x \n", ReadDword( s->pRegisterStatus ) );
    dprintf("  pHostAddrs   = 0x%08x \n", ReadDword( s->pHostAddrs ) );
    dprintf("  dwHostAddrCount = %d \n", s->dwHostAddrCount );
    dprintf("  lpstrDomainName = %s \n", ReadStr(s->lpstrDomainName, 0) );
    dprintf("  pipDnsServerList = 0x%08x \n", ReadDword( s->pipDnsServerList ) );
    dprintf("  dwDnsServerCount = %d \n", s->dwDnsServerCount );
    dprintf("  dwTTL        = %d \n", s->dwTTL );
    dprintf("  dwFlags      = %d \n", s->dwFlags );
    dprintf("  fNewElement  = 0x%08x \n", s->fNewElement );
    dprintf("  fRemove      = 0x%08x \n", s->fRemove );
    dprintf( "}; // struct _CLIENT_QELEMENT.\n");    return;
} /* print_CLIENT_QELEMENT */


void print_BUCKET( char* message, struct _BUCKET * s );
DECLARE_API( dprint_BUCKET ){    struct _BUCKET * p = NULL;
    struct _BUCKET   Q;    ULONG  result;    INIT_API();    if( *args )
        sscanf( args, "%lx", &p );
    if( !p || !ReadMemory( p, &Q, sizeof(Q), &result )){
       dprintf("Could not read address 0x%08x\n", p );       return;    }
    print_BUCKET( "none", &Q );    return;}

// ==================================================//  _BUCKETvoid
VOID
print_BUCKET( char* message, struct _BUCKET * s ){    if(  message   ){
       dprintf( "%s\n", message );    }    if(  s == NULL ){
       dprintf( "struct _BUCKET is NULL.\n");       return;    }
    dprintf("struct _BUCKET = {\n" );
    dprintf("  List         = 0x%08x \n", s->List );
    dprintf("  ppQList      = 0x%08x \n", ReadDword(s->ppQList) );
    dprintf("  dwListCount  = %d \n", s->dwListCount );
    dprintf("  dwRetryTime  = %d \n", s->dwRetryTime );
    dprintf("  HostName     = %s \n", ReadStr(s->HostName, 0) );
    dprintf("  DomainName   = %s \n", ReadStr(s->DomainName, 0));
    dprintf("  fSucceeded   = 0x%08x \n", s->fSucceeded );
    dprintf("  pRelatedBucket = 0x%08x \n", s->pRelatedBucket );
    dprintf("  fRemove      = 0x%08x \n", s->fRemove );
    dprintf("  dwRetryFactor = %d \n", s->dwRetryFactor );
    dprintf( "}; // struct _BUCKET.\n");    return;} /* print_BUCKET */

void
print_SERVER_INFO( char* message, struct _SERVER_INFO * s );

DECLARE_API( dprint_SERVER_INFO ){    struct _SERVER_INFO * p = NULL;
    struct _SERVER_INFO   Q;    ULONG  result;    INIT_API();    if( *args )
        sscanf( args, "%lx", &p );
    if( !p || !ReadMemory( p, &Q, sizeof(Q), &result )){
       dprintf("Could not read address 0x%08x\n", p );       return;    }
    print_SERVER_INFO( "none", &Q );    return;}
// ==================================================//  _SERVER_INFO
void
print_SERVER_INFO( char* message, struct _SERVER_INFO * s ){
    if(  message   ){       dprintf( "%s\n", message );    }
    if(  s == NULL ){       dprintf( "struct _SERVER_INFO is NULL.\n");
       return;    }    dprintf("struct _SERVER_INFO = {\n" );
    dprintf("  dwVersion    = %d \n", s->dwVersion );
    dprintf("  pszServerName = %s \n", ReadStr(s->pszServerName,0) );
    dprintf("  pszServerDomainName = %s \n", ReadStr(s->pszServerDomainName,0));
    dprintf("  fStarted     = 0x%08x \n", s->fStarted );
    dprintf("  fThreadAlert = 0x%08x \n", s->fThreadAlert );
    dprintf("  fServiceExit = 0x%08x \n", s->fServiceExit );
    dprintf("  hContinueEvent = 0x%08x \n", s->hContinueEvent );
    dprintf("  hShutdownEvent = 0x%08x \n", s->hShutdownEvent );
    dprintf("  fWinsInitialized = 0x%08x \n", s->fWinsInitialized );
    dprintf("  fMemoryException = 0x%08x \n", s->fMemoryException );
    dprintf("  fAVException = 0x%08x \n", s->fAVException );
    dprintf("  dwCurrentTime = %d \n", s->dwCurrentTime );
    dprintf("  fBootRegistry = %d \n", s->fBootRegistry );
    dprintf("  fBootFileDirty = %d \n", s->fBootFileDirty );
    dprintf("  cDsZones     = %d \n", s->cDsZones );
    dprintf("  fRemoteDs    = %d \n", s->fRemoteDs );
    dprintf("  fDatabaseSupported = %d \n", s->fDatabaseSupported );
    dprintf("  pszDatabaseDirectory = 0x%08x \n", s->pszDatabaseDirectory );
    dprintf("  dwRpcProtocol = %d \n", s->dwRpcProtocol );
    dprintf("  dwLogLevel   = %d \n", s->dwLogLevel );
    dprintf("  dwDebugLevel = %d \n", s->dwDebugLevel );
    dprintf("  aipServerAddrs = 0x%08x \n", ReadDword( s->aipServerAddrs ) );
    dprintf("  aipBoundAddrs = 0x%08x \n", ReadDword( s->aipBoundAddrs ) );
    dprintf("  aipListenAddrs = 0x%08x \n", ReadDword( s->aipListenAddrs ) );
    dprintf("  fListenAddrsSet = %d \n", s->fListenAddrsSet );
    dprintf("  fListenAddrsStale = %d \n", s->fListenAddrsStale );
    dprintf("  fDisjointNets = %d \n", s->fDisjointNets );
    dprintf("  fNoTcp       = %d \n", s->fNoTcp );
    dprintf("  fRecurseOnDnsPort = %d \n", s->fRecurseOnDnsPort );
    dprintf("  aipForwarders = 0x%08x \n", ReadDword( s->aipForwarders ) );
    dprintf("  dwForwardTimeout = %d \n", s->dwForwardTimeout );
    dprintf("  fSlave       = %d \n", s->fSlave );
    dprintf("  fNoRecursion = %d \n", s->fNoRecursion );
    dprintf("  fRecursionAvailable = %d \n", s->fRecursionAvailable );
    dprintf("  dwRecursionRetry = %d \n", s->dwRecursionRetry );
    dprintf("  dwRecursionTimeout = %d \n", s->dwRecursionTimeout );
    dprintf("  dwMaxCacheTtl = %d \n", s->dwMaxCacheTtl );
    dprintf("  fSecureResponses = %d \n", s->fSecureResponses );
    dprintf("  fAllowUpdate = %d \n", s->fAllowUpdate );
    dprintf("  fExtendedCharNames = %d \n", s->fExtendedCharNames );
    dprintf("  dwNameCheckFlag = %d \n", s->dwNameCheckFlag );
    dprintf("  dwCleanupInterval = %d \n", s->dwCleanupInterval );
    dprintf("  fNoAutoReverseZones = %d \n", s->fNoAutoReverseZones );
    dprintf("  fAutoCacheUpdate = %d \n", s->fAutoCacheUpdate );
    dprintf("  fRoundRobin  = %d \n", s->fRoundRobin );
    dprintf("  fLocalNetPriority = %d \n", s->fLocalNetPriority );
    dprintf("  cAddressAnswerLimit = %d \n", s->cAddressAnswerLimit );
    dprintf("  fBindSecondaries = %d \n", s->fBindSecondaries );
    dprintf("  fWriteAuthoritySoa = %d \n", s->fWriteAuthoritySoa );
    dprintf("  fWriteAuthorityNs = %d \n", s->fWriteAuthorityNs );
    dprintf("  fWriteAuthority = %d \n", s->fWriteAuthority );
    dprintf("  fStrictFileParsing = %d \n", s->fStrictFileParsing );
    dprintf("  fLooseWildcarding = %d \n", s->fLooseWildcarding );
    dprintf( "}; // struct _SERVER_INFO.\n");    return;
} /* print_SERVER_INFO */


// Generated Mon Aug 18 20:53:32 1997 on MohsinA5 1.2.13
void print_ZONE_INFO( char* message, ZONE_INFO * s );

DECLARE_API( dprint_ZONE_INFO )
{
    ZONE_INFO * p = NULL;
    ZONE_INFO   Q;
    ULONG  result;
    INIT_API();
    if( *args )
        sscanf( args, "%lx", &p );
    if( !p || !ReadMemory( p, &Q, sizeof(Q), &result )){
       dprintf("Could not read address 0x%08x\n", p );
       return;
    }
    print_ZONE_INFO( "none", &Q );
    return;
}
// ==================================================
//  ZONE_INFO

void
print_ZONE_INFO( char* message, ZONE_INFO * s )
{
    if(  message   ){
        dprintf( "%s\n", message );
    }
    if(  s == NULL ){
        dprintf( "ZONE_INFO is NULL.\n");
        return;
    }
    dprintf("ZONE_INFO = {\n" );
    dprintf("  ListEntry    = 0x%08x \n", s->ListEntry );
    dprintf("  pZoneRoot    = 0x%08x \n", ReadDword( s->pZoneRoot ) );
    dprintf("  pszZoneName  = %s \n", ReadStr(s->pszZoneName,0) );
    dprintf("  pszDataFile  = %s \n", ReadStr(s->pszDataFile,0) );
    dprintf("  pszLogFile   = %s \n", ReadStr(s->pszLogFile,0) );
    dprintf("  pszZoneDN    = %s \n", ReadStr(s->pszZoneDN,0) );
    dprintf("  dwLastUsn    = %s \n", ReadStr(s->szLastUsn,0) );
    dprintf("  ipReverse    = 0x%08x \n", s->ipReverse );
    dprintf("  ipReverseMask = 0x%08x \n", s->ipReverseMask );
    dprintf("  pSoaRR       = 0x%08x \n", ReadDword( s->pSoaRR ) );
    dprintf("  dwSerialNo   = %d \n", s->dwSerialNo );
    dprintf("  dwLoadSerialNo = %d \n", s->dwLoadSerialNo );
    dprintf("  dwLastXfrSerialNo = %d \n", s->dwLastXfrSerialNo );
    dprintf("  dwNewSerialNo = %d \n", s->dwNewSerialNo );
    dprintf("  dwDefaultTtl = %d \n", s->dwDefaultTtl );
    dprintf("  dwDefaultTtlHostOrder = %d \n", s->dwDefaultTtlHostOrder );
    dprintf("  hfileUpdateLog = 0x%08x \n", s->hfileUpdateLog );
    dprintf("  iUpdateLogCount = %d \n", s->iUpdateLogCount );
    dprintf("  UpdateList   = 0x%08x \n", s->UpdateList );
    dprintf("  iRRCount     = %d \n", s->iRRCount );
    dprintf("  aipSecondaries = 0x%08x \n", ReadDword( s->aipSecondaries ) );
    dprintf("  aipNameServers = 0x%08x \n", ReadDword( s->aipNameServers ) );
    dprintf("  dwNextTransferTime = %d \n", s->dwNextTransferTime );
    dprintf("  ipPrimary    = 0x%08x \n", s->ipPrimary );
    dprintf("  aipMasters   = 0x%08x \n", ReadDword( s->aipMasters ) );
    dprintf("  dwNextSoaCheckTime = %d \n", s->dwNextSoaCheckTime );
    dprintf("  dwExpireTime = %d \n", s->dwExpireTime );
    dprintf("  ipNotifier   = 0x%08x \n", s->ipNotifier );
    dprintf("  ipFreshMaster = 0x%08x \n", s->ipFreshMaster );
    dprintf("  pszMasterIpString = 0x%08x \n", s->pszMasterIpString );
    dprintf("  dwZoneRecvStartTime = %d \n", s->dwZoneRecvStartTime );
    dprintf("  pLocalWinsRR = 0x%08x \n", ReadDword( s->pLocalWinsRR ) );
    dprintf("  pWinsRR      = 0x%08x \n", ReadDword( s->pWinsRR ) );
    dprintf("  dwLockingThreadId = %d \n", s->dwLockingThreadId );
    dprintf("  chZoneType   = %c \n", s->chZoneType );
    dprintf("  cZoneNameLabelCount = 0x%08x \n", s->cZoneNameLabelCount );
    dprintf("  fReverse     = 0x%08x \n", s->fReverse );
    dprintf("  fDsIntegrated = 0x%08x \n", s->fDsIntegrated );
    dprintf("  fDsLoadVersion = 0x%08x \n", s->fDsLoadVersion );
    dprintf("  fUnicode     = 0x%08x \n", s->fUnicode );
    dprintf("  fAutoCreated = 0x%08x \n", s->fAutoCreated );
    dprintf("  fSecureSecondaries = 0x%08x \n", s->fSecureSecondaries );
    dprintf("  fAllowUpdate = 0x%08x \n", s->fAllowUpdate );
    dprintf("  fLogUpdates  = 0x%08x \n", s->fLogUpdates );
    dprintf("  fPaused      = 0x%08x \n", s->fPaused );
    dprintf("  fDirty       = 0x%08x \n", s->fDirty );
    dprintf("  fShutdown    = 0x%08x \n", s->fShutdown );
    dprintf("  fNotified    = 0x%08x \n", s->fNotified );
    dprintf("  fStale       = 0x%08x \n", s->fStale );
    dprintf("  fEmpty       = 0x%08x \n", s->fEmpty );
    dprintf("  fLocked      = 0x%08x \n", s->fLocked );
    dprintf("  fUpdateLock  = 0x%08x \n", s->fUpdateLock );
    dprintf("  fXfrRecvLock = 0x%08x \n", s->fXfrRecvLock );
    dprintf("  fFileWriteLock = 0x%08x \n", s->fFileWriteLock );
    dprintf("  cReaders     = 0x%08x \n", s->cReaders );
    dprintf( "}; // struct ZONE_INFO.\n");
    return;
} /* print_ZONE_INFO */




// Generated Mon Aug 18 21:22:54 1997 on MohsinA5 1.2.13
void print_ResourceRecord( char* message, struct _ResourceRecord * s );

DECLARE_API( dprint_ResourceRecord )
{
    struct _ResourceRecord * p = NULL;
    struct _ResourceRecord   Q;
    ULONG  result;
    INIT_API();
    if( *args )
        sscanf( args, "%lx", &p );
    if( !p || !ReadMemory( p, &Q, sizeof(Q), &result )){
       dprintf("Could not read address 0x%08x\n", p );
       return;
    }
    print_ResourceRecord( "none", &Q );
    return;
}
// ==================================================
//  ResourceRecord

void
print_ResourceRecord( char* message, struct _ResourceRecord * s )
{
    if(  message   ){
        dprintf( "%s\n", message );
    }
    if(  s == NULL ){
        dprintf( "struct ResourceRecord is NULL.\n");
        return;
    }
    dprintf("struct _ResourceRecord = {\n" );
    dprintf("  pRRNext      = 0x%08x \n", s->pRRNext );
    dprintf("  RecordRank   = 0x%08x \n", s->RecordRank );
    dprintf("  RRReserved   = 0x%08x \n", s->RRReserved );
    dprintf("  wRRFlags     = %d \n", s->wRRFlags );
    dprintf("  wType        = %d \n", s->wType );
    dprintf("  wDataLength  = %d \n", s->wDataLength );
    dprintf("  dwTtlSeconds = %d \n", s->dwTtlSeconds );
    dprintf("  ipAddress    = 0x%08x \n", s->Data.A.ipAddress );
    dprintf("  ipv6Address  = 0x%08x \n", s->Data.AAAA.ipv6Address );
    dprintf("  pnodePrimaryServer = 0x%08x \n", ReadDword( s->Data.SOA.pnodePrimaryServer ) );
    dprintf("  pnodeZoneAdmin = 0x%08x \n", ReadDword( s->Data.SOA.pnodeZoneAdmin ) );
    dprintf("  dwSerialNo   = %d \n", s->Data.SOA.dwSerialNo );
    dprintf("  dwRefresh    = %d \n", s->Data.SOA.dwRefresh );
    dprintf("  dwRetry      = %d \n", s->Data.SOA.dwRetry );
    dprintf("  dwExpire     = %d \n", s->Data.SOA.dwExpire );
    dprintf("  dwMinimumTtl = %d \n", s->Data.SOA.dwMinimumTtl );
    dprintf("  pnodeAddress = 0x%08x \n", ReadDword( s->Data.PTR.pnodeAddress ) );
    dprintf("  pnodeMailbox = 0x%08x \n", ReadDword( s->Data.MINFO.pnodeMailbox ) );
    dprintf("  pnodeErrorsMailbox = 0x%08x \n", ReadDword( s->Data.MINFO.pnodeErrorsMailbox ) );
    dprintf( "}; // struct ResourceRecord.\n");
    return;
} /* print_ResourceRecord */


void print_ADDITIONAL_INFO( char* message, ADDITIONAL_INFO * s );

DECLARE_API( dprint_ADDITIONAL_INFO )
{
    ADDITIONAL_INFO * p = NULL;
    ADDITIONAL_INFO   Q;
    ULONG  result;
    INIT_API();
    if( *args )
        sscanf( args, "%lx", &p );
    if( !p || !ReadMemory( p, &Q, sizeof(Q), &result )){
       dprintf("Could not read address 0x%08x\n", p );
       return;
    }
    print_ADDITIONAL_INFO( "none", &Q );
    return;
}
// ==================================================
//  _ADDITIONAL_INFO

void
print_ADDITIONAL_INFO( char* message, ADDITIONAL_INFO * s )
{
    if(  message   ){
        dprintf( "%s\n", message );
    }
    if(  s == NULL ){
        dprintf( "ADDITIONAL_INFO is NULL.\n");
        return;
    }
    dprintf("ADDITIONAL_INFO = {\n" );
    dprintf("  cMaxCount    = %d \n", s->cMaxCount );
    dprintf("  cCount       = %d \n", s->cCount );
    dprintf("  iIndex       = %d \n", s->iIndex );
    dprintf( "}; // ADDITIONAL_INFO.\n");
    return;
} /* print_ADDITIONAL_INFO */


void print_DNS_MSGINFO( char* message, struct _DNS_MSGINFO * s );

DECLARE_API( dprint_DNS_MSGINFO ){    struct _DNS_MSGINFO * p = NULL;

struct _DNS_MSGINFO   Q;    ULONG  result;    INIT_API();    if( *args )
        sscanf( args, "%lx", &p );
    if( !p || !ReadMemory( p, &Q, sizeof(Q), &result )){
       dprintf("Could not read address 0x%08x\n", p );       return;    }
    print_DNS_MSGINFO( "none", &Q );    return;}
// ==================================================//  _DNS_MSGINFO
void
print_DNS_MSGINFO( char* message, struct _DNS_MSGINFO * s ){
    if(  message   ){       dprintf( "%s\n", message );    }
    if(  s == NULL ){       dprintf( "struct _DNS_MSGINFO is NULL.\n");
       return;    }    dprintf("struct _DNS_MSGINFO = {\n" );
    dprintf("  ListEntry    = 0x%08x \n", s->ListEntry );
    dprintf("  Socket       = 0x%08x \n", s->Socket );
    dprintf("  RemoteAddressLength = %d \n", s->RemoteAddressLength );
    dprintf("  RemoteAddress = 0x%08x \n", s->RemoteAddress );
    dprintf("  BufferLength = %d \n", s->BufferLength );
    dprintf("  pBufferEnd   = %s \n", ReadStr( s->pBufferEnd, 20 ) );
    dprintf("  pCurrentCountField = %d \n", ReadDword( s->pCurrentCountField ) );
    dprintf("  pCurrent     = 0x%08x \n", ReadDword( s->pCurrent ) );
    dprintf("  pnodeCurrent = 0x%08x \n", ReadDword( s->pnodeCurrent ) );
    dprintf("  wTypeCurrent = %d \n", s->wTypeCurrent );
    dprintf("  wOffsetCurrent = %d \n", s->wOffsetCurrent );
    dprintf("  pQuestion    = 0x%08x \n", ReadDword( s->pQuestion ) );
    dprintf("  wQuestionType = %d \n", s->wQuestionType );
    dprintf("  wQueuingXid  = %d \n", s->wQueuingXid );
    dprintf("  dwQueryTime  = %d \n", s->dwQueryTime );
    dprintf("  dwQueuingTime = %d \n", s->dwQueuingTime );
    dprintf("  dwExpireTime = %d \n", s->dwExpireTime );
    dprintf("  OriginalSocket = 0x%08x \n", s->OriginalSocket );
    dprintf("  ipOriginal   = 0x%08x \n", s->ipOriginal );
    dprintf("  wOriginalPort = %d \n", s->wOriginalPort );
    dprintf("  wOriginalXid = %d \n", s->wOriginalXid );
    dprintf("  pRecurseMsg  = 0x%08x \n", s->pRecurseMsg );
    dprintf("  pnodeRecurseRetry = 0x%08x \n", ReadDword( s->pnodeRecurseRetry ) );
    dprintf("  pVisitedNs   = 0x%08x \n", ReadDword( s->pVisitedNs ) );
    dprintf("  pConnection  = 0x%08x \n", ReadDword( s->pConnection ) );
    dprintf("  pchRecv      = %s \n", ReadStr( s->pchRecv, 20 ) );
    dprintf("  pzoneCurrent = 0x%08x \n", ReadDword( s->pzoneCurrent ) );
    dprintf("  pWinsRR      = 0x%08x \n", ReadDword( s->pWinsRR ) );
    dprintf("  ipNbstat     = 0x%08x \n", s->ipNbstat );
    dprintf("  pNbstat      = 0x%08x \n", ReadDword( s->pNbstat ) );
    dprintf("  dwNbtInterfaceMask = %d \n", s->dwNbtInterfaceMask );
    dprintf("  fDelete      = 0x%08x \n", s->fDelete );
    dprintf("  fTcp         = 0x%08x \n", s->fTcp );
    dprintf("  fMessageComplete = 0x%08x \n", s->fMessageComplete );
    dprintf("  fDoAdditional = 0x%08x \n", s->fDoAdditional );
    dprintf("  fRecursePacket = 0x%08x \n", s->fRecursePacket );
    dprintf("  fRecurseIfNecessary = 0x%08x \n", s->fRecurseIfNecessary );
    dprintf("  fQuestionRecursed = 0x%08x \n", s->fQuestionRecursed );
    dprintf("  fQuestionCompleted = 0x%08x \n", s->fQuestionCompleted );
    dprintf("  fRecurseTimeoutWait = 0x%08x \n", s->fRecurseTimeoutWait );
    dprintf("  nForwarder   = %c \n", s->nForwarder );
    dprintf("  fReplaceCname = 0x%08x \n", s->fReplaceCname );
    dprintf("  cCnameAnswerCount = 0x%08x \n", s->cCnameAnswerCount );
    dprintf("  fBindTransfer = 0x%08x \n", s->fBindTransfer );
    dprintf("  fNoCompressionWrite = 0x%08x \n", s->fNoCompressionWrite );
    dprintf("  fWins        = 0x%08x \n", s->fWins );
    dprintf("  fNbstatResponded = 0x%08x \n", s->fNbstatResponded );
    dprintf("  cchWinsName  = 0x%08x \n", s->cchWinsName );
    dprintf("  pLooknameQuestion = 0x%08x \n", ReadDword( s->pLooknameQuestion ) );
    dprintf("  Additional   = 0x%08x \n", s->Additional );
    dprintf("  Compression  = 0x%08x \n", s->Compression );
    dprintf("  BytesToReceive = %d \n", s->BytesToReceive );
    dprintf("  MessageLength = %d \n", s->MessageLength );
    dprintf("  MessageHead  = 0x%08x \n", s->MessageHead );
    dprintf( "}; // struct _DNS_MSGINFO.\n");    return;
} /* print_DNS_MSGINFO */
=== C:/Users/treeman/Desktop/windows nt source code\Source\Win2K3\NT\ds\dns\dbgexts\header.h ===
//
// Define this constant so that hal.h won't be included.  This is so that
// the project will build, as someone under here has redefined some types
// that are in hal.h
//

#define _HAL_



#include <nt.h>
#include <ntrtl.h>
#include <nturtl.h>
#include <windows.h>

//  headers are screwed up
//  if you bring in nt.h, then don't bring in winnt.h and
//  then you miss these

#ifndef MAXWORD
#define MINCHAR     0x80
#define MAXCHAR     0x7f
#define MINSHORT    0x8000
#define MAXSHORT    0x7fff
#define MINLONG     0x80000000
#define MAXLONG     0x7fffffff
#define MAXBYTE     0xff
#define MAXWORD     0xffff
#define MAXDWORD    0xffffffff
#endif

#ifndef DNS_WINSOCK1
#include <winsock2.h>
#define DNS_WINSOCK2 1
#else
#include <winsock.h>
#endif

#if WINDBG
#   include <wdbgexts.h>
#else
#   include <ntsdexts.h>
#endif

#include <basetyps.h>
#include <nspapi.h>
#include <svcguid.h>

#include <stdio.h>
#include <stdlib.h>
#include <limits.h>

//#include <tcpsvcs.h>        //  tcpsvcs globals

#include <dnsapi.h>         //  DNS library routines
#include <windns.h>         //  DNS API
#include <dnsrpc.h>

//  #include <dnsapip.h>
//  #include <record.h>         //  record defs in library
//  #include "dnsrpc_s.h"       //  DNS RPC definitions

#include "srvcfg.h"
#include "dnsmsg.h"
#include "file.h"
#include "name.h"
#include "tree.h"
#include "record.h"
#include "update.h"
#include "zone.h"
#include "registry.h"
#include "zone.h"
#include "msginfo.h"
#include "tcpcon.h"
#include "packetq.h"
#include "dbase.h"

#include "recurse.h"
#include "nameutil.h"
#include "ntverp.h"
//
// RBUGBUG
// PCLIENT_QELEMENT structure and PBUCKET structure have been 
// copied from dhcpclnt.c. Make sure to copy them from wherever necessary
//
//

typedef struct _CLIENT_QELEMENT {

    LIST_ENTRY           List;
    LPSTR                lpstrAdapterName;
    LPSTR                lpstrHostName;
    PREGISTER_HOST_STATUS pRegisterStatus;
    PREGISTER_HOST_ENTRY pHostAddrs;
    DWORD                dwHostAddrCount;
    LPSTR                lpstrDomainName;
    PIP_ADDRESS          pipDnsServerList;
    DWORD                dwDnsServerCount;
    DWORD                dwTTL;
    DWORD                dwFlags;
    BOOL                 fNewElement;
    BOOL                 fRemove;

} CLIENT_QELEMENT, *PCLIENT_QELEMENT;

typedef struct _BUCKET 
{
    LIST_ENTRY        List;
    PCLIENT_QELEMENT* ppQList;
    DWORD             dwListCount;
    DWORD             dwRetryTime;
    CHAR              HostName[50];
    CHAR              DomainName[50];
    BOOL              fSucceeded;
    struct _BUCKET*   pRelatedBucket;    
    BOOL              fRemove;       // delete elements in this bucket?
    DWORD             dwRetryFactor;
} BUCKET, *PBUCKET;
=== C:/Users/treeman/Desktop/windows nt source code\Source\Win2K3\NT\ds\dns\dnsapi\config.c ===
/*++

Copyright (c) 1999-2002  Microsoft Corporation

Module Name:

    config.c

Abstract:

    Domain Name System (DNS) API 

    Configuration routines.

Author:

    Jim Gilroy (jamesg)     September 1999

Revision History:

--*/


#include "local.h"




//
//  Config mapping table.
//
//  Maps config IDs into corresponding registry lookups.
//

typedef struct _ConfigMapping
{
    DWORD       ConfigId;
    DWORD       RegId;
    BOOLEAN     fAdapterAllowed;
    BOOLEAN     fAdapterRequired;
    BYTE        CharSet;
    //BYTE        Reserved;
}
CONFIG_MAPPING, *PCONFIG_MAPPING;

//
//  Mapping table
//

CONFIG_MAPPING  ConfigMappingArray[] =
{
    //  In Win2K

    DnsConfigPrimaryDomainName_W,
        RegIdPrimaryDomainName,
        0,
        0,
        DnsCharSetUnicode,

    DnsConfigPrimaryDomainName_A,
        RegIdPrimaryDomainName,
        0,
        0,
        DnsCharSetAnsi,

    DnsConfigPrimaryDomainName_UTF8,
        RegIdPrimaryDomainName,
        0,
        0,
        DnsCharSetUtf8,

    //  Not available

    DnsConfigAdapterDomainName_W,
        RegIdAdapterDomainName,
        1,
        1,
        DnsCharSetUnicode,

    DnsConfigAdapterDomainName_A,
        RegIdAdapterDomainName,
        1,
        1,
        DnsCharSetAnsi,

    DnsConfigAdapterDomainName_UTF8,
        RegIdAdapterDomainName,
        1,
        1,
        DnsCharSetUtf8,

    //  In Win2K

    DnsConfigDnsServerList,
        RegIdDnsServers,
        1,              // adapter allowed
        0,              // not required
        0,

    //  Not available

    DnsConfigSearchList,
        RegIdSearchList,
        0,              // adapter allowed
        0,              // not required
        0,

    DnsConfigAdapterInfo,
        0,              // no reg mapping
        0,              // adapter allowed
        0,              // not required
        0,

    //  In Win2K

    DnsConfigPrimaryHostNameRegistrationEnabled,
        RegIdRegisterPrimaryName,
        1,              // adapter allowed
        0,              // not required
        0,
    DnsConfigAdapterHostNameRegistrationEnabled,
        RegIdRegisterAdapterName,
        1,              // adapter allowed
        0,              // adapter note required
        0,
    DnsConfigAddressRegistrationMaxCount,
        RegIdRegistrationMaxAddressCount,
        1,              // adapter allowed
        0,              // not required
        0,

    //  In WindowsXP

    DnsConfigHostName_W,
        RegIdHostName,
        0,
        0,
        DnsCharSetUnicode,

    DnsConfigHostName_A,
        RegIdHostName,
        0,
        0,
        DnsCharSetAnsi,

    DnsConfigHostName_UTF8,
        RegIdHostName,
        0,
        0,
        DnsCharSetUtf8,

    //  In WindowsXP



    //
    //  System Public -- Windows XP
    //

    DnsConfigRegistrationEnabled,
        RegIdRegistrationEnabled,
        1,              // adapter allowed
        0,              // not required
        0,

    DnsConfigWaitForNameErrorOnAll,
        RegIdWaitForNameErrorOnAll,
        0,              // no adapter
        0,              // not required
        0,

    //  These exist in system-public space but are
    //  not DWORDs and table is never used for them
    //
    //  DnsConfigNetworkInformation:
    //  DnsConfigSearchInformation:
    //  DnsConfigNetInfo:

};

#define LAST_CONFIG_MAPPED      (DnsConfigHostName_UTF8)

#define CONFIG_TABLE_LENGTH     (sizeof(ConfigMappingArray) / sizeof(CONFIG_MAPPING))



PCONFIG_MAPPING
GetConfigToRegistryMapping(
    IN      DNS_CONFIG_TYPE     ConfigId,
    IN      PCWSTR              pwsAdapterName,
    IN      BOOL                fCheckAdapter
    )
/*++

Routine Description:

    Get registry enum type for config enum type.

    Purpose of this is to do mapping -- thus hiding internal
    registry implemenation -- AND to do check on whether
    adapter info is allowed or required for the config type.

Arguments:

    ConfigId  -- config type

    pwsAdapterName -- adapter name

Return Value:

    Ptr to config to registry mapping -- if found.

--*/
{
    DWORD           iter = 0;
    PCONFIG_MAPPING pfig;

    //
    //  find config
    //
    //  note, using loop through config IDs;  this allows
    //  use to have gap in config table allowing private
    //  ids well separated from public id space
    //

    while ( iter < CONFIG_TABLE_LENGTH )
    {
        pfig = & ConfigMappingArray[ iter ];
        if ( pfig->ConfigId != (DWORD)ConfigId )
        {
            iter++;
            continue;
        }
        goto Found;
    }
    goto Invalid;


Found:

    //
    //  verify adapter info is appropriate to config type
    //

    if ( fCheckAdapter )
    {
        if ( pwsAdapterName )
        {
            if ( !pfig->fAdapterAllowed )
            {
                goto Invalid;
            }
        }
        else
        {
            if ( pfig->fAdapterRequired )
            {
                goto Invalid;
            }
        }
    }
    return pfig;


Invalid:

    DNS_ASSERT( FALSE );
    SetLastError( ERROR_INVALID_PARAMETER );
    return  NULL;
}



DNS_STATUS
LookupDwordConfigValue(
    OUT     PDWORD              pResult,
    IN      DNS_CONFIG_TYPE     ConfigId,
    IN      PWSTR               pwsAdapter
    )
/*++

Routine Description:

    Get registry enum type for config enum type.

    Purpose of this is to do mapping -- thus hiding internal
    registry implemenation -- AND to do check on whether
    adapter info is allowed or required for the config type.

Arguments:

    pResult -- address to recv DWORD result

    ConfigId  -- config type

    pwsAdapter -- adapter name

Return Value:

    ERROR_SUCCESS on successful read.
    ErrorCode on failure.

--*/
{
    PCONFIG_MAPPING pfig;
    DNS_STATUS      status;

    //
    //  verify config is known and mapped
    //

    pfig = GetConfigToRegistryMapping(
                ConfigId,
                pwsAdapter,
                TRUE            // check adapter validity
                );
    if ( !pfig )
    {
        return  ERROR_INVALID_PARAMETER;
    }

    //
    //  lookup in registry
    //

    status = Reg_GetDword(
                NULL,               // no session
                NULL,               // no key given
                pwsAdapter,
                pfig->RegId,        // reg id for config type
                pResult );
#if DBG
    if ( status != NO_ERROR )
    {
        if ( status == ERROR_FILE_NOT_FOUND )
        {
            DNSDBG( REGISTRY, (
                "Reg_GetDword() defaulted for config lookup!\n"
                "\tConfigId     = %d\n"
                "\tRedId        = %d\n"
                "\tpwsAdapter   = %S\n"
                "\tValue        = %d\n",
                ConfigId,
                pfig->RegId,
                pwsAdapter,
                *pResult ));
        }
        else
        {
            DNSDBG( ANY, (
                "Reg_GetDword() failed for config lookup!\n"
                "\tstatus       = %d\n"
                "\tConfigId     = %d\n"
                "\tRedId        = %d\n"
                "\tpwsAdapter   = %S\n",
                status,
                ConfigId,
                pfig->RegId,
                pwsAdapter ));
    
            ASSERT( status == NO_ERROR );
        }
    }
#endif
    return( status );
}



//
//  Public Configuration API
//

DNS_STATUS
DnsQueryConfig(
    IN      DNS_CONFIG_TYPE     ConfigId,
    IN      DWORD               Flag,
    IN      PWSTR               pwsAdapterName,
    IN      PVOID               pReserved,
    OUT     PVOID               pBuffer,
    IN OUT  PDWORD              pBufferLength
    )
/*++

Routine Description:

    Get DNS configuration info.

Arguments:

    ConfigId -- type of config info desired

    Flag -- flags to query

    pAdapterName -- name of adapter;  NULL if no specific adapter

    pReserved -- reserved parameter, should be NULL

    pBuffer -- buffer to receive config info

    pBufferLength -- addr of DWORD containing buffer length;  on return
        contains length

Return Value:

    ERROR_SUCCESS -- if query successful
    ERROR_MORE_DATA -- if not enough space in buffer

--*/
{
    DNS_STATUS  status = ERROR_SUCCESS;
    DWORD       bufLength = 0;
    DWORD       resultLength = 0;
    PBYTE       presult;
    PBYTE       pallocResult = NULL;
    BOOL        boolData;
    DWORD       dwordData;


    DNSDBG( TRACE, (
        "DnsQueryConfig()\n"
        "\tconfig   = %d\n"
        "\tconfig   = %08x\n"
        "\tflag     = %08x\n"
        "\tadapter  = %S\n"
        "\tpBuffer  = %p\n",
        ConfigId,
        ConfigId,
        Flag,
        pwsAdapterName,
        pBuffer
        ));

    //
    //  check out param setup
    //

    if ( !pBufferLength )
    {
        return  ERROR_INVALID_PARAMETER;
    }
    if ( pBuffer )
    {
        bufLength = *pBufferLength;
    }

    //
    //  find specific configuration data requested
    //

    switch( ConfigId )
    {

    case DnsConfigPrimaryDomainName_W:

        presult = (PBYTE) Reg_GetPrimaryDomainName( DnsCharSetUnicode );
        goto  WideString;

    case DnsConfigPrimaryDomainName_A:

        presult = (PBYTE) Reg_GetPrimaryDomainName( DnsCharSetAnsi );
        goto  NarrowString;

    case DnsConfigPrimaryDomainName_UTF8:

        presult = (PBYTE) Reg_GetPrimaryDomainName( DnsCharSetUtf8 );
        goto  NarrowString;


    case DnsConfigDnsServerList:

        presult = (PBYTE) Config_GetDnsServerListIp4(
                                pwsAdapterName,
                                TRUE    // force registry read
                                );
        if ( !presult )
        {
            status = GetLastError();
            if ( status == NO_ERROR )
            {
                DNS_ASSERT( FALSE );
                status = DNS_ERROR_NO_DNS_SERVERS;
            }
            goto Done;
        }
        pallocResult = presult;
        resultLength = Dns_SizeofIpArray( (PIP4_ARRAY)presult );
        goto Process;


    case DnsConfigDnsServers:
    case DnsConfigDnsServersIp4:
    case DnsConfigDnsServersIp6:

        {
            DWORD   family = 0;

            if ( ConfigId == DnsConfigDnsServersIp4 )
            {
                family = AF_INET;
            }
            else if ( ConfigId == DnsConfigDnsServersIp6 )
            {
                family = AF_INET6;
            }
    
            presult = (PBYTE) Config_GetDnsServerList(
                                    pwsAdapterName,
                                    family, // desired address family
                                    TRUE    // force registry read
                                    );
            if ( !presult )
            {
                status = GetLastError();
                if ( status == NO_ERROR )
                {
                    DNS_ASSERT( FALSE );
                    status = DNS_ERROR_NO_DNS_SERVERS;
                }
                goto Done;
            }
            pallocResult = presult;
            resultLength = DnsAddrArray_Sizeof( (PDNS_ADDR_ARRAY)presult );
            goto Process;
        }

    case DnsConfigPrimaryHostNameRegistrationEnabled:
    case DnsConfigAdapterHostNameRegistrationEnabled:
    case DnsConfigAddressRegistrationMaxCount:

        goto Dword;

    //case DnsConfigAdapterDomainName:
    //case DnsConfigAdapterInfo:
    //case DnsConfigSearchList:

    case DnsConfigHostName_W:

        presult = (PBYTE) Reg_GetHostName( DnsCharSetUnicode );
        goto  WideString;

    case DnsConfigHostName_A:

        presult = (PBYTE) Reg_GetHostName( DnsCharSetAnsi );
        goto  NarrowString;

    case DnsConfigHostName_UTF8:

        presult = (PBYTE) Reg_GetHostName( DnsCharSetUtf8 );
        goto  NarrowString;

    case DnsConfigFullHostName_W:

        presult = (PBYTE) Reg_GetFullHostName( DnsCharSetUnicode );
        goto  WideString;

    case DnsConfigFullHostName_A:

        presult = (PBYTE) Reg_GetFullHostName( DnsCharSetAnsi );
        goto  NarrowString;

    case DnsConfigFullHostName_UTF8:

        presult = (PBYTE) Reg_GetFullHostName( DnsCharSetUtf8 );
        goto  NarrowString;

    default:

        return  ERROR_INVALID_PARAMETER;
    }


    //
    //  setup return info for common types
    //
    //  this just avoids code duplication above
    //

Dword:

    status = LookupDwordConfigValue(
                & dwordData,
                ConfigId,
                pwsAdapterName );

    if ( status != NO_ERROR )
    {
        goto Done;
    }
    presult = (PBYTE) &dwordData;
    resultLength = sizeof(DWORD);
    goto  Process;


NarrowString:

    if ( !presult )
    {
        status = DNS_ERROR_NO_MEMORY;
        goto Done;
    }
    pallocResult = presult;
    resultLength = strlen( (PSTR)presult ) + 1;
    goto  Process;


WideString:

    if ( !presult )
    {
        status = DNS_ERROR_NO_MEMORY;
        goto Done;
    }
    pallocResult = presult;
    resultLength = (wcslen( (PWSTR)presult ) + 1) * sizeof(WCHAR);
    goto  Process;


Process:

    //
    //  return results -- three basic programs
    //      - no buffer         => only return length required
    //      - allocate          => return allocated result
    //      - supplied buffer   => copy result into buffer
    //
    //  note, this section only handles simple flag datablobs to aVOID
    //  duplicating code for specific config types above;
    //  when we add config types that require nested pointers, they must
    //  roll their own return-results code and jump to Done
    //

    //
    //  no buffer
    //      - no-op, length is set below

    if ( !pBuffer )
    {
    }

    //
    //  allocated result
    //      - return buffer gets ptr
    //      - allocate copy of result if not allocated
    //

    else if ( Flag & DNS_CONFIG_FLAG_ALLOC )
    {
        PBYTE   pheap;

        if ( bufLength < sizeof(PVOID) )
        {
            resultLength = sizeof(PVOID);
            status = ERROR_MORE_DATA;
            goto Done;
        }

        //  create local alloc buffer

        pheap = LocalAlloc( 0, resultLength );
        if ( !pheap )
        {
            status = DNS_ERROR_NO_MEMORY;
            goto Done;
        }
        RtlCopyMemory(
            pheap,
            presult,
            resultLength );
        
        //  return ptr to allocated result

        * (PVOID*) pBuffer = pheap;
    }

    //
    //  allocated result -- but dnsapi alloc
    //

    else if ( Flag & DNS_CONFIG_FLAG_DNSAPI_ALLOC )
    {
        if ( bufLength < sizeof(PVOID) )
        {
            resultLength = sizeof(PVOID);
            status = ERROR_MORE_DATA;
            goto Done;
        }

        //  if result not allocated, alloc and copy it

        if ( ! pallocResult )
        {
            pallocResult = ALLOCATE_HEAP( resultLength );
            if ( !pallocResult )
            {
                status = DNS_ERROR_NO_MEMORY;
                goto Done;
            }

            RtlCopyMemory(
                pallocResult,
                presult,
                resultLength );
        }

        //  return ptr to allocated result

        * (PVOID*) pBuffer = pallocResult;

        //  clear pallocResult, so not freed in generic cleanup

        pallocResult = NULL;
    }

    //
    //  copy result to caller buffer
    //

    else
    {
        if ( bufLength < resultLength )
        {
            status = ERROR_MORE_DATA;
            goto Done;
        }
        RtlCopyMemory(
            pBuffer,
            presult,
            resultLength );
    }


Done:

    //
    //  set result length
    //  cleanup any allocated (but not returned) data
    //

    *pBufferLength = resultLength;

    if ( pallocResult )
    {
        FREE_HEAP( pallocResult );
    }

    return( status );
}




//
//  System Public Configuration API
//

PVOID
WINAPI
DnsQueryConfigAllocEx(
    IN      DNS_CONFIG_TYPE     ConfigId,
    IN      PWSTR               pwsAdapterName,
    IN      BOOL                fLocalAlloc
    )
/*++

Routine Description:

    Get DNS configuration info.

    Allocate DNS configuration info.
    This is the cover API both handling the system public API
    DnsQueryConfigAlloc() below and the backward compatible
    macros for the old hostname and PDN alloc routines (see dnsapi.h)

Arguments:

    ConfigId -- type of config info desired

    pAdapterName -- name of adapter;  NULL if no specific adapter

    fLocalAlloc -- allocate with LocalAlloc

Return Value:

    ERROR_SUCCESS -- if query successful
    ERROR_MORE_DATA -- if not enough space in buffer

--*/
{
    DNS_STATUS  status = ERROR_SUCCESS;
    DWORD       bufLength = sizeof(PVOID);
    PBYTE       presult = NULL;

    DNSDBG( TRACE, (
        "DnsQueryConfigAllocEx()\n"
        "\tconfig   = %d\n"
        "\tconfig   = %08x\n"
        "\tadapter  = %S\n"
        "\tflocal   = %d\n",
        ConfigId,
        ConfigId,
        pwsAdapterName,
        fLocalAlloc
        ));


    //
    //  DCR:  flags on config reading (resolver, cached, etc.)
    //


    //
    //  SDK-public types
    //

    if ( ConfigId < DnsConfigSystemBase )
    {
        //
        //  DCR:  could screen here for alloc types
        //
        //    DnsConfigPrimaryDomainName_W:
        //    DnsConfigPrimaryDomainName_A:
        //    DnsConfigPrimaryDomainName_UTF8:
        //    DnsConfigHostname_W:
        //    DnsConfigHostname_A:
        //    DnsConfigHostname_UTF8:
        //    DnsConfigDnsServerList:
        //
        
        status = DnsQueryConfig(
                    ConfigId,
                    fLocalAlloc
                        ? DNS_CONFIG_FLAG_LOCAL_ALLOC
                        : DNS_CONFIG_FLAG_DNSAPI_ALLOC,
                    pwsAdapterName,
                    NULL,               // reserved
                    & presult,
                    & bufLength );
        
        if ( status != NO_ERROR )
        {
            SetLastError( status );
            return  NULL;
        }
        return  presult;
    }

    //
    //  System public types
    //

    if ( fLocalAlloc )
    {
        goto Invalid;
    }

    switch ( ConfigId )
    {

    //  old public config blobs

    case    DnsConfigNetworkInformation:

        return  DnsNetworkInformation_Get();

    case    DnsConfigSearchInformation:

        return  DnsSearchInformation_Get();

    //  new public config blobs

    case    DnsConfigNetworkInfoA:

        return  DnsNetworkInfo_Get( DnsCharSetAnsi );

    case    DnsConfigSearchListA:

        return  DnsSearchList_Get( DnsCharSetAnsi );

    case    DnsConfigNetworkInfoW:

        return  DnsNetworkInfo_Get( DnsCharSetUnicode );

    case    DnsConfigSearchListW:

        return  DnsSearchList_Get( DnsCharSetUnicode );

    case    DnsConfigDwordGlobals:

        //
        //  DCR:  flags on config reading (resolver, cached, etc.)
        //

        //
        //  get globals
        //      not forcing registry read
        //      using from resolver if found
        //      then current (if netinfo blob cached)
        //
        //  note, that whatever we return, even if from resolver, is
        //  (becomes) the current set for dnsapi.dll
        //

        return  Config_GetDwordGlobals(
                    ( NIFLAG_READ_RESOLVER_FIRST | NIFLAG_READ_PROCESS_CACHE ),
                    0       // default cache timeout
                    );

#if 0
    case    DnsConfigNetInfo:

        return  NetInfo_Get(
                    TRUE,       // force
                    TRUE        // include IP addresses
                    );
#endif

    case    DnsConfigIp4AddressArray:

        //  this called by gethostname( NULL ) => myhostent()
        //      - so handle cluster based on environment varaible

        return  NetInfo_GetLocalAddrArrayIp4(
                    pwsAdapterName,
                    DNS_CONFIG_FLAG_ADDR_PUBLIC |
                        DNS_CONFIG_FLAG_ADDR_PRIVATE |
                        DNS_CONFIG_FLAG_READ_CLUSTER_ENVAR,
                    FALSE           // no force, accept from resolver
                    );

    case    DnsConfigLocalAddrsIp6:
    case    DnsConfigLocalAddrsIp4:
    case    DnsConfigLocalAddrs:

        {
            DWORD   family = 0;

            if ( ConfigId == DnsConfigLocalAddrsIp6 )
            {
                family = AF_INET6;
            }
            else if ( ConfigId == DnsConfigLocalAddrsIp4 )
            {
                family = AF_INET;
            }

            return  NetInfo_GetLocalAddrArray(
                        NULL,                               // no existing netinfo
                        pwsAdapterName,
                        family,                             // address family
                        DNS_CONFIG_FLAG_ADDR_ALL,           // all addrs
                        TRUE                                // force rebuild
                        );
        }

    //  unknown falls through to invalid
    }

Invalid:

    DNS_ASSERT( FALSE );
    SetLastError( ERROR_INVALID_PARAMETER );
    return( NULL );
}




//
//  DWORD system-public config
//

DWORD
DnsQueryConfigDword(
    IN      DNS_CONFIG_TYPE     ConfigId,
    IN      PWSTR               pwsAdapter
    )
/*++

Routine Description:

    Get DNS DWORD configuration value.

    This is system public routine.

Arguments:

    ConfigId -- type of config info desired

    pwsAdapter -- name of adapter;  NULL if no specific adapter

Return Value:

    DWORD config value.
    Zero if no such config.

--*/
{
    DNS_STATUS  status;
    DWORD       value = 0;

    DNSDBG( TRACE, (
        "DnsQueryConfigDword()\n"
        "\tconfig   = %d\n"
        "\tadapter  = %S\n",
        ConfigId,
        pwsAdapter
        ));

    status = LookupDwordConfigValue(
                & value,
                ConfigId,
                pwsAdapter );

#if DBG
    if ( status != NO_ERROR &&
         status != ERROR_FILE_NOT_FOUND )
    {
        DNSDBG( ANY, (
            "LookupDwordConfigValue() failed for config lookup!\n"
            "\tstatus       = %d\n"
            "\tConfigId     = %d\n"
            "\tpwsAdapter   = %S\n",
            status,
            ConfigId,
            pwsAdapter ));

        DNS_ASSERT( status == NO_ERROR );
    }
#endif

    DNSDBG( TRACE, (
        "Leave DnsQueryConfigDword() => %08x (%d)\n"
        "\tconfig   = %d\n"
        "\tadapter  = %S\n",
        value,
        value,
        ConfigId,
        pwsAdapter
        ));

    return( value );
}



DNS_STATUS
DnsSetConfigDword(
    IN      DNS_CONFIG_TYPE     ConfigId,
    IN      PWSTR               pwsAdapter,
    IN      DWORD               NewValue
    )
/*++

Routine Description:

    Set DNS DWORD configuration value.

    This is system public routine.

Arguments:

    ConfigId -- type of config info desired

    pwsAdapter -- name of adapter;  NULL if no specific adapter

    NewValue -- new value for parameter

Return Value:

    DWORD config value.
    Zero if no such config.

--*/
{
    PCONFIG_MAPPING pfig;

    DNSDBG( TRACE, (
        "DnsSetConfigDword()\n"
        "\tconfig   = %d\n"
        "\tadapter  = %S\n"
        "\tvalue    = %d (%08x)\n",
        ConfigId,
        pwsAdapter,
        NewValue, NewValue
        ));

    //
    //  verify config is known and mapped
    //

    pfig = GetConfigToRegistryMapping(
                ConfigId,
                pwsAdapter,
                TRUE            // check adapter validity
                );
    if ( !pfig )
    {
        return  ERROR_INVALID_PARAMETER;
    }

    //
    //  set in registry
    //

    return  Reg_SetDwordPropertyAndAlertCache(
                    pwsAdapter,     // adapter name key (if any)
                    pfig->RegId,
                    NewValue );
}



//
//  Config data free
//

VOID
WINAPI
DnsFreeConfigStructure(
    IN OUT  PVOID           pData,
    IN      DNS_CONFIG_TYPE ConfigId
    )
/*++

Routine Description:

    Free config data

    This routine simply handles the mapping between config IDs
    and the free type.

Arguments:

    pData -- data to free

    ConfigId -- config id

Return Value:

    None

--*/
{
    DNS_FREE_TYPE   freeType = DnsFreeFlat;

    DNSDBG( TRACE, (
        "DnsFreeConfigStructure( %p, %d )\n",
        pData,
        ConfigId ));

    //
    //  find any unflat config types
    //
    //  note:  currently all config types that are not flat
    //      are system-public only and the config ID is also
    //      the free type (for convenience);  if we start
    //      exposing some of these bringing them into the low
    //      space, then this will change
    //
    //  unfortunately these types can NOT be identical because
    //  the space conflicts in shipped Win2K  (FreeType==1 is
    //  record list)
    //

    if ( ConfigId > DnsConfigSystemBase  &&
         (
            ConfigId == DnsConfigNetworkInfoW       ||
            ConfigId == DnsConfigSearchListW        ||
            ConfigId == DnsConfigAdapterInfoW       ||
            ConfigId == DnsConfigNetworkInfoA       ||
            ConfigId == DnsConfigSearchListA        ||
            ConfigId == DnsConfigAdapterInfoA       ||

            // ConfigId == DnsConfigNetInfo            ||

            ConfigId == DnsConfigNetworkInformation  ||
            ConfigId == DnsConfigSearchInformation   ||
            ConfigId == DnsConfigAdapterInformation
            ) )
    {
        freeType = (DNS_FREE_TYPE) ConfigId;
    }

    DnsFree(
        pData,
        freeType );
}




//
//  Config routines for specific types
//

PADDR_ARRAY
Config_GetDnsServerList(
    IN      PWSTR           pwsAdapterName,
    IN      DWORD           AddrFamily,
    IN      BOOL            fForce
    )
/*++

Routine Description:

    Get DNS server list as IP array.

Arguments:

    fForce -- force reread from registry

Return Value:

    ERROR_SUCCESS if successful.
    Error code on failure.

--*/
{
    PDNS_NETINFO    pnetInfo = NULL;
    PADDR_ARRAY     parray = NULL;
    DNS_STATUS      status = NO_ERROR;

    DNSDBG( TRACE, (
        "Config_GetDnsServerList()\n"
        "\tadapter  = %S\n"
        "\tfamily   = %d\n"
        "\tforce    = %d\n",
        pwsAdapterName,
        AddrFamily,
        fForce
        ));

    //
    //  get network info to make list from
    //      - don't need IP address lists
    //
    //  DCR:  force reread for DNS servers unnecessary once notify on it
    //

    pnetInfo = NetInfo_Get(
                    NIFLAG_FORCE_REGISTRY_READ,
                    0
                    );
    if ( !pnetInfo )
    {
        status = DNS_ERROR_NO_DNS_SERVERS;
        goto Done;
    }

    //
    //  convert network info to IP4_ARRAY
    //

    parray = NetInfo_ConvertToAddrArray(
                pnetInfo,
                pwsAdapterName,
                AddrFamily );

    if ( !parray )
    {
        status = GetLastError();
        goto Done;
    }

    //  if no servers read, return

    if ( parray->AddrCount == 0 )
    {
        DNS_PRINT((
            "Dns_GetDnsServerList() failed:  no DNS servers found\n"
            "\tstatus = %d\n" ));
        status = DNS_ERROR_NO_DNS_SERVERS;
        goto Done;
    }

    IF_DNSDBG( NETINFO )
    {
        DNS_PRINT(( "Leaving Config_GetDnsServerList()\n" ));
        DnsDbg_DnsAddrArray(
            "DNS server list",
            "server",
            parray );
    }

Done:

    NetInfo_Free( pnetInfo );

    if ( status != NO_ERROR )
    {
        FREE_HEAP( parray );
        parray = NULL;
        SetLastError( status );
    }

    return( parray );
}



PIP4_ARRAY
Config_GetDnsServerListIp4(
    IN      PWSTR           pwsAdapterName,
    IN      BOOL            fForce
    )
/*++

Routine Description:

    Get DNS server list as IP array.

Arguments:

    fForce -- force reread from registry

Return Value:

    ERROR_SUCCESS if successful.
    Error code on failure.

--*/
{
    PADDR_ARRAY parray;
    PIP4_ARRAY  parray4 = NULL;
    DNS_STATUS  status = NO_ERROR;

    DNSDBG( TRACE, ( "Config_GetDnsServerListIp4()\n" ));

    //
    //  get DNS server list
    //

    parray = Config_GetDnsServerList(
                pwsAdapterName,
                AF_INET,
                fForce );
    if ( !parray )
    {
        goto Done;
    }

    //
    //  convert array to IP4 array
    //

    parray4 = DnsAddrArray_CreateIp4Array( parray );
    if ( !parray4 )
    {
        status = DNS_ERROR_NO_MEMORY;
        goto Done;
    }

    DNS_ASSERT( parray4->AddrCount > 0 );

    IF_DNSDBG( NETINFO )
    {
        DnsDbg_Ip4Array(
            "DNS server list",
            "server",
            parray4 );
    }

Done:

    DnsAddrArray_Free( parray );

    if ( status != NO_ERROR )
    {
        SetLastError( status );
    }
    return( parray4 );
}



PDNS_GLOBALS_BLOB
Config_GetDwordGlobals(
    IN      DWORD           Flag,
    IN      DWORD           AcceptLocalCacheTime   OPTIONAL
    )
/*++

Routine Description:

    Read DNS network info from registry.

    This is in process, limited caching version.
    Note, this is macro'd as GetNetworkInfo() with parameters
        NetInfo_Get( FALSE, TRUE ) throughout dnsapi code.

Arguments:

    Flag -- flag;  read order and IP
        NIFLAG_GET_LOCAL_ADDRS
        NIFLAG_FORCE_REGISTRY_READ
        NIFLAG_READ_RESOLVER_FIRST
        NIFLAG_READ_RESOLVER
        NIFLAG_READ_PROCESS_CACHE

    AcceptLocalCacheTime -- acceptable cache time on in process copy

Return Value:

    ERROR_SUCCESS if successful.
    Error code on failure.

--*/
{
    DNS_STATUS          status = ERROR_SUCCESS;
    PDNS_NETINFO        pnetInfo = NULL;
    PDNS_GLOBALS_BLOB   pblob = NULL;

    DNSDBG( TRACE, (
        "Config_GetDwordGlobals( %08x %08x)\n",
        Flag,
        AcceptLocalCacheTime ));


    //
    //  read info -- from resolver or locally
    //      reading netinfo will force update of globals
    //
    //  DCR:  extra work being done here;
    //      if UpdateNetworkInfo() fails to contact resolver
    //      or if resolver not trusted, can get away with simple
    //      reg read, don't need entire network info deal
    //

    pnetInfo = NetInfo_Get(
                    Flag,
                    AcceptLocalCacheTime );

    //
    //  global info now up to date
    //
    //  note, that whatever we return, even if from resolver, is
    //  (becomes) the current set for dnsapi.dll
    //
    //  DCR:  copy outside of API?
    //

    pblob = ALLOCATE_HEAP( sizeof(*pblob) );
    if ( pblob )
    {
        RtlCopyMemory(
            pblob,
            & DnsGlobals,
            sizeof(DnsGlobals) );
    }

    //
    //  cleanup netinfo
    //

    NetInfo_Free( pnetInfo );

    return  pblob;
}

//
//  End config.c
//
=== C:/Users/treeman/Desktop/windows nt source code\Source\Win2K3\NT\ds\dns\dnsapi\asyncreg.c ===
/*++

Copyright (c) 1996-2002  Microsoft Corporation

Module Name:

    asyncreg.c

Abstract:

    Domain Name System (DNS) API

    Client IP/PTR dynamic update.

Author:

    Glenn Curtis (GlennC)   Feb-16-1998

Revision History:

    Jim Gilroy (jamesg)     May\June 2001
                            - eliminate duplicate code
                            - simplify lines
                            - PTR reg only if forward successful
                            - alternate names

--*/


#include "local.h"
#include <netevent.h>

#define ENABLE_DEBUG_LOGGING 1

#include "logit.h"


//
//  Flags for debugging for this module
//

#define DNS_DBG_DHCP            DNS_DBG_UPDATE
#define DNS_DBG_DHCP2           DNS_DBG_UPDATE2

//
//  Registry values
//
//  Note regvalue name definitions are also in registry.h
//  registry.h should be the ongoing location of all reg names
//  used in dnsapi.dll
//

#if 0
#define REGISTERED_HOST_NAME        L"HostName"
#define REGISTERED_DOMAIN_NAME      L"DomainName"
#define SENT_UPDATE_TO_IP           L"SentUpdateToIp"
#define SENT_PRI_UPDATE_TO_IP       L"SentPriUpdateToIp"
#define REGISTERED_TTL              L"RegisteredTTL"
#define REGISTERED_FLAGS            L"RegisteredFlags"
#define REGISTERED_SINCE_BOOT       L"RegisteredSinceBoot"
#define DNS_SERVER_ADDRS            L"DNSServerAddresses"
#define DNS_SERVER_ADDRS_COUNT      L"DNSServerAddressCount"
#define REGISTERED_ADDRS            L"RegisteredAddresses"
#define REGISTERED_ADDRS_COUNT      L"RegisteredAddressCount"
#endif

#define ADAPTER_NAME_CLASS          L"AdapterNameClass"
#define DYN_DNS_ROOT_CLASS          L"DynDRootClass"
#define DHCP_CLIENT_REG_LOCATION    L"System\\CurrentControlSet\\Services\\Tcpip\\Parameters\\DNSRegisteredAdapters"
#define NT_INTERFACE_REG_LOCATION   L"System\\CurrentControlSet\\Services\\Tcpip\\Parameters\\Interfaces\\"
#define TCPIP_REG_LOCATION          L"System\\CurrentControlSet\\Services\\Tcpip\\Parameters"

//
//  Registry state flags
//

#define REGISTERED_FORWARD          0x00000001
#define REGISTERED_PRIMARY          0x00000002
#define REGISTERED_POINTER          0x00000004


//
//  Update type
//
//  Multiple types of updates for a given entry.
//  These identify which type (which name) being updated.
//

typedef enum _UpType
{
    UPTYPE_PRIMARY  = 1,
    UPTYPE_ADAPTER,
    UPTYPE_ALTERNATE,
    UPTYPE_PTR
}
UPTYPE, *PUPTYPE;

#define IS_UPTYPE_PRIMARY(UpType)       ((UpType)==UPTYPE_PRIMARY)
#define IS_UPTYPE_ADAPTER(UpType)       ((UpType)==UPTYPE_ADAPTER)
#define IS_UPTYPE_ALTERNATE(UpType)     ((UpType)==UPTYPE_ALTERNATE)
#define IS_UPTYPE_PTR(UpType)           ((UpType)==UPTYPE_PTR)


//
// definition of client list element
//

#define DNS_SIG_TOP        0x123aa321
#define DNS_SIG_BOTTOM     0x321bb123

typedef struct _DnsUpdateEntry
{
    LIST_ENTRY              List;
    DWORD                   SignatureTop;

    PWSTR                   AdapterName;
    PWSTR                   HostName;
    PWSTR                   PrimaryDomainName;
    PWSTR                   DomainName;
    PWSTR                   AlternateNames;

    PWSTR                   pPrimaryFQDN;
    PWSTR                   pAdapterFQDN;
    PWSTR                   pUpdateName;

    DWORD                   HostAddrCount;
    PREGISTER_HOST_ENTRY    HostAddrs;
    PIP4_ARRAY              DnsServerList;
    IP4_ADDRESS             SentUpdateToIp;
    IP4_ADDRESS             SentPriUpdateToIp;
    DWORD                   TTL;
    DWORD                   Flags;
    BOOL                    fNewElement;
    BOOL                    fFromRegistry;
    BOOL                    fRemove;
    BOOL                    fRegisteredPRI;
    BOOL                    fRegisteredFWD;
    BOOL                    fRegisteredALT;
    BOOL                    fRegisteredPTR;
    DNS_STATUS              StatusPri;
    DNS_STATUS              StatusFwd;
    DNS_STATUS              StatusPtr;
    BOOL                    fDisableErrorLogging;
    DWORD                   RetryCount;
    DWORD                   RetryTime;
    DWORD                   BeginRetryTime;
    PREGISTER_HOST_STATUS   pRegisterStatus;
    DWORD                   SignatureBottom;
}
UPDATE_ENTRY, *PUPDATE_ENTRY;



//
//  Waits \ Timeouts
//

//  On unjoin, deregistration wait no more than two minutes
//      to clean up -- then just get outta Dodge
//

#if DBG
#define REMOVE_REGISTRATION_WAIT_LIMIT  (0xffffffff)
#else
#define REMOVE_REGISTRATION_WAIT_LIMIT  (120000)    // 2 minutes in ms
#endif


#define FIRST_RETRY_INTERVAL        5*60        // 5 minutes
#define SECOND_RETRY_INTERVAL       10*60       // 10 minutes
#define FAILED_RETRY_INTERVAL       60*60       // 1 hour

#define WAIT_ON_BOOT                60          // 1 minute

#define RETRY_COUNT_RESET           (86400)     // 1 day


//
//  Globals
//

//
// the behavior of the system at boot differs from when it is not at
// boot. At boot time we collect a bunch of requests and register them
// in one shot. One thread does this. After boot, we register them
// as requests come in, one at a time.
//

BOOL    g_fAtBoot = TRUE;


//
//  Registration globals
//

BOOL        g_RegInitialized = FALSE;

BOOL        g_DhcpListCsInitialized = FALSE;
BOOL        g_DhcpThreadCsInitialized = FALSE;

CRITICAL_SECTION    g_DhcpListCS;
CRITICAL_SECTION    g_DhcpThreadCS;

#define LOCK_REG_LIST()     EnterCriticalSection( &g_DhcpListCS );
#define UNLOCK_REG_LIST()   LeaveCriticalSection( &g_DhcpListCS );

#define LOCK_REG_THREAD()     EnterCriticalSection( &g_DhcpThreadCS );
#define UNLOCK_REG_THREAD()   LeaveCriticalSection( &g_DhcpThreadCS );

HKEY        g_hDhcpRegKey = NULL;
LIST_ENTRY  g_DhcpRegList;

HANDLE      g_hDhcpThread = NULL;
HANDLE      g_hDhcpWakeEvent = NULL;

//  Thread state

BOOL        g_fDhcpThreadRunning = FALSE;
BOOL        g_fDhcpThreadStop = FALSE;
BOOL        g_fDhcpThreadCheckBeforeExit = FALSE;
INT         g_DhcpThreadWaitCount = 0;

//  Registration state

BOOL        g_fNoMoreDhcpUpdates = FALSE;
BOOL        g_fPurgeRegistrations = FALSE;
BOOL        g_fPurgeRegistrationsInitiated = FALSE;



//
//  Reg list search results
//

#define REG_LIST_EMPTY  (0)
#define REG_LIST_WAIT   (1)
#define REG_LIST_FOUND  (2)


//
//  Private heap
//

HANDLE      g_DhcpRegHeap;

#define     PHEAP_ALLOC_ZERO( s )   HeapAlloc( g_DhcpRegHeap, HEAP_ZERO_MEMORY, (s) )
#define     PHEAP_ALLOC( s )        HeapAlloc( g_DhcpRegHeap, HEAP_ZERO_MEMORY, (s) )
#define     PHEAP_FREE( p )         HeapFree( g_DhcpRegHeap, 0, (p) )

#define     INITIAL_DHCP_HEAP_SIZE  (16*1024)


//
//  Alternate names checking stuff
//

PWSTR   g_pmszAlternateNames = NULL;

HKEY    g_hCacheKey = NULL;

HANDLE  g_hRegChangeEvent = NULL;



//
//  Private protos
//

DNS_STATUS
AllocateUpdateEntry(
    IN  PWSTR                   AdapterName,
    IN  PWSTR                   HostName,
    IN  PWSTR                   DomainName,
    IN  PWSTR                   PrimaryDomainName,
    IN  PWSTR                   AlternateNames,
    IN  DWORD                   HostAddrCount,
    IN  PREGISTER_HOST_ENTRY    HostAddrs,
    IN  DWORD                   DnsServerCount,
    IN  PIP4_ADDRESS            DnsServerList,
    IN  IP4_ADDRESS             SentUpdateToIp,
    IN  IP4_ADDRESS             SentPriUpdateToIp,
    IN  DWORD                   TTL,
    IN  DWORD                   Flags,
    IN  DWORD                   RetryCount,
    IN  DWORD                   RetryTime,
    IN  PREGISTER_HOST_STATUS   RegisterStatus,
    OUT PUPDATE_ENTRY *         ppUpdateEntry
    );

VOID
FreeUpdateEntry(
    IN OUT  PUPDATE_ENTRY   pUpdateEntry
    );

VOID
FreeUpdateEntryList(
    IN      PLIST_ENTRY     pUpdateEntry
    );

DWORD
WINAPI
dhcp_RegistrationThread(
    VOID
    );

VOID
WriteUpdateEntryToRegistry(
    IN      PUPDATE_ENTRY   pUpdateEntry
    );

PUPDATE_ENTRY
ReadUpdateEntryFromRegistry(
    IN      PWSTR           pAdapterName
    );

VOID
MarkAdapterAsPendingUpdate(
    IN      PWSTR           pAdapterName
    );

DWORD
dhcp_GetNextUpdateEntryFromList(
    OUT     PUPDATE_ENTRY * ppUpdateEntry,
    OUT     PDWORD          pdwWaitTime
    );

VOID
ProcessUpdateEntry(
    IN OUT  PUPDATE_ENTRY   pUpdateEntry,
    IN      BOOL            fPurgeMode
    );

DNS_STATUS
ModifyAdapterRegistration(
    IN OUT  PUPDATE_ENTRY   pUpdateEntry,
    IN OUT  PUPDATE_ENTRY   pRegistryEntry,
    IN      PDNS_RECORD     pUpdateRecord,
    IN      PDNS_RECORD     pRegRecord,
    IN      UPTYPE          UpType
    );

VOID
ResetAdaptersInRegistry(
    VOID
    );

VOID
DeregisterUnusedAdapterInRegistry(
    IN      BOOL            fPurgeMode
    );

PDNS_RECORD
GetPreviousRegistrationInformation(
    IN      PUPDATE_ENTRY   pUpdateEntry,
    IN      UPTYPE          UpType,
    OUT     PIP4_ADDRESS    pServerIp
    );

PDNS_RECORD
CreateDnsRecordSetUnion(
    IN      PDNS_RECORD     pSet1,
    IN      PDNS_RECORD     pSet2
    );

DNS_STATUS
alertOrStartRegistrationThread(
    VOID
    );

VOID
registerUpdateStatus(
    IN OUT  PREGISTER_HOST_STATUS   pRegStatus,
    IN      DNS_STATUS              Status
    );

VOID
enqueueUpdate(
    IN OUT  PUPDATE_ENTRY   pUpdate
    );

VOID
enqueueUpdateMaybe(
    IN OUT  PUPDATE_ENTRY   pUpdate
    );

PLIST_ENTRY
dequeueAndCleanupUpdate(
    IN OUT  PLIST_ENTRY     pUpdateEntry
    );

BOOL
searchForOldUpdateEntriesAndCleanUp(
    IN      PWSTR           pAdapterName,
    IN      PUPDATE_ENTRY   pUpdateEntry OPTIONAL,
    IN      BOOL            fLookInRegistry
    );

BOOL
compareUpdateEntries(
    IN      PUPDATE_ENTRY   pUdapteEntry1,
    IN      PUPDATE_ENTRY   pUpdateEntry2
    );

BOOL
compareHostEntryAddrs(
    IN      PREGISTER_HOST_ENTRY    Addrs1,
    IN      PREGISTER_HOST_ENTRY    Addrs2,
    IN      DWORD                   Count
    );

BOOL
compareServerLists(
    IN  PIP4_ARRAYList1,
    IN  PIP4_ARRAYList2
    );

#define USE_GETREGVAL 0

#if USE_GETREGVAL
DWORD
GetRegistryValue(
    HKEY    KeyHandle,
    DWORD   Id,
    PWSTR   ValueName,
    DWORD   ValueType,
    PBYTE   BufferPtr
    );
#else

#define GetRegistryValue( h, id, name, type, p )    \
        Reg_GetValueEx( NULL, h, NULL, id, type, 0, (PBYTE *)p )

#endif
        

//
//  Debug logging
//

#if 1 // DBG
VOID 
LogHostEntries(
    IN  DWORD                dwHostAddrCount,
    IN  PREGISTER_HOST_ENTRY pHostAddrs
    );

VOID 
LogIp4Address(
    IN  DWORD           dwServerListCount,
    IN  PIP4_ADDRESS    pServers
    );

VOID 
LogIp4Array(
    IN  PIP4_ARRAY  pServers
    );

#define DNSLOG_HOST_ENTRYS( a, b )  LogHostEntries( a, b )
#define DNSLOG_IP4_ADDRESS( a, b )  LogIp4Address( a, b )
#define DNSLOG_IP4_ARRAY( a )       LogIp4Array( a )

#else

#define DNSLOG_HOST_ENTRYS( a, b )
#define DNSLOG_IP4_ADDRESS( a, b )
#define DNSLOG_IP4_ARRAY( a )

#endif


//
//  Jim routines
//

VOID
LogRegistration(
    IN      PUPDATE_ENTRY   pUpdateEntry,
    IN      DNS_STATUS      Status,
    IN      DWORD           UpType,
    IN      BOOL            fDeregister,
    IN      IP4_ADDRESS     DnsIp,
    IN      IP4_ADDRESS     UpdateIp
    );

VOID
AsyncLogUpdateEntry(
    IN      PSTR            pszHeader,
    IN      PUPDATE_ENTRY   pEntry
    );

#define ASYNCREG_UPDATE_ENTRY(h,p)      AsyncLogUpdateEntry(h,p)

VOID
DnsPrint_UpdateEntry(
    IN      PRINT_ROUTINE   PrintRoutine,
    IN      PPRINT_CONTEXT  PrintContext,
    IN      PSTR            pszHeader,
    IN      PUPDATE_ENTRY   pUpdateEntry
    );

#if DBG
#define DnsDbg_UpdateEntry(h,p)     DnsPrint_UpdateEntry(DnsPR,NULL,h,p)
#else
#define DnsDbg_UpdateEntry(h,p)
#endif

PDNS_RECORD
CreateForwardRecords(
    IN      PUPDATE_ENTRY   pUpdateEntry,
    IN      BOOL            fUsePrimaryName
    );

PDNS_RECORD
CreatePtrRecord(
    IN      PWSTR           pszHostName,
    IN      PWSTR           pszDomainName,
    IN      IP4_ADDRESS     Ip4Addr,
    IN      DWORD           Ttl
    );

VOID
UpdatePtrRecords(
    IN OUT  PUPDATE_ENTRY   pUpdateEntry,
    IN      BOOL            fAdd
    );

VOID
SetUpdateStatus(
    IN OUT  PUPDATE_ENTRY   pUpdateEntry,
    IN      PDNS_EXTRA_INFO pResults,
    IN      BOOL            fPrimary
    );


DNS_STATUS
InitAlternateNames(
    VOID
    );

VOID
CleanupAlternateNames(
    VOID
    );

BOOL
CheckForAlternateNamesChange(
    VOID
    );

BOOL
IsAnotherUpdateName(
    IN      PUPDATE_ENTRY   pUpdateEntry,
    IN      PWSTR           pwsName,
    IN      UPTYPE          UpType
    );


//
//  Initialization, globals, thread control
//

VOID
dhcp_CleanupGlobals(
    VOID
    )
/*++

Routine Description:

    Cleanup registration globals.

    Note locking is the responsibility of the caller.

Arguments:

    None.

Return Value:

    None

--*/
{
    if ( g_hDhcpWakeEvent )
    {
        CloseHandle(g_hDhcpWakeEvent);
        g_hDhcpWakeEvent = NULL;
    }

    if ( g_hDhcpThread )
    {
        CloseHandle( g_hDhcpThread );
        g_hDhcpThread = NULL;
    }

    if ( g_hDhcpRegKey )
    {
        RegCloseKey( g_hDhcpRegKey );
        g_hDhcpRegKey = NULL;
    }

    if ( g_DhcpRegHeap &&
         g_DhcpRegHeap != GetProcessHeap() )
    {
        HeapDestroy( g_DhcpRegHeap );
        g_DhcpRegHeap = NULL;
    }

    g_RegInitialized = FALSE;
}



DNS_STATUS
alertOrStartRegistrationThread(
    VOID
    )
/*++

Routine Description:

    Alerts registration thread of new update, starting thread if necessary.

    This is called in registration\deregistration functions to ensure
    thread has been started.

Arguments:

    None

Return Value:

    ERROR_SUCCESS if successful.
    Error code on failure.

--*/
{
    DWORD       threadId;
    DNS_STATUS  status = ERROR_SUCCESS;

    ASYNCREG_F1( "Inside alertOrStartRegistrationThread()\n" );
    DNSDBG( TRACE, (
        "alertOrStartRegistrationThread()\n" ));

    //
    //  must lock to insure single reg thread
    //      - avoids multiple async start
    //      - g_DhcpThreadCheckBeforeExit avoids race with exiting thread
    //      (when flag is TRUE, reg thread must recheck exit conditions
    //      before exiting)
    //

    LOCK_REG_THREAD();

    if ( g_fDhcpThreadStop )
    {
        DNSDBG( ANY, (
            "ERROR:  Dhcp reg thread start called after stop!\n" ));
        DNS_ASSERT( FALSE );
        status = ERROR_INTERNAL_ERROR;
        goto Unlock;
    }

    //
    //  wake thread, if running
    //

    if ( g_hDhcpThread )
    {
        if ( g_fDhcpThreadRunning )
        {
            g_fDhcpThreadCheckBeforeExit = TRUE;
            PulseEvent( g_hDhcpWakeEvent );
            goto Unlock;
        }

        DNSDBG( ANY, (
            "ERROR:  Dhcp reg thread start called during thread shutdown.\n" ));
        DNS_ASSERT( FALSE );
        status = ERROR_INTERNAL_ERROR;
        goto Unlock;
    }

    //
    //  if not started, fire it up
    //

    DNSDBG( TRACE, ( "Starting DHCP registration thread.\n" ));

    g_fDhcpThreadCheckBeforeExit = FALSE;
    g_DhcpThreadWaitCount = 0;
    ResetEvent( g_hDhcpWakeEvent );

    g_hDhcpThread = CreateThread(
                        NULL,
                        0,
                        (LPTHREAD_START_ROUTINE)
                        dhcp_RegistrationThread,
                        NULL,
                        0,
                        & threadId );
    if ( !g_hDhcpThread )
    {
        status = GetLastError();
    }
    g_fDhcpThreadRunning = TRUE;

Unlock:

    UNLOCK_REG_THREAD();

    DNSDBG( TRACE, (
        "Leave  alertOrStartRegistrationThread()\n"
        "\tCreateThread() => %d\n",
        status ));

    return( status );
}


//
//  DHCP client (asyncreg.c)
//

VOID
Dhcp_RegCleanupForUnload(
    VOID
    )
/*++

Routine Description:

    Cleanup for dll unload.

    This is NOT MT safe and does NOT re-init globals.
    It is for dll unload ONLY.

Arguments:

    None.

Return Value:

    None.

--*/
{
    //
    //  note:  at some level this function is pointless;
    //  the service with the DHCP client process is statically linked
    //  and will NOT unload dnsapi.dll;  however, there is test code
    //  that may use it, we'll be a good citizen and provide the basics
    //
    //  but i'm not going to bother with the thread shutdown, as we
    //  assume we can't be unloaded while code is running in the dll;
    //  it's the callers job to terminate first

    //
    //  close global handles
    //

    if ( g_RegInitialized )
    {
        dhcp_CleanupGlobals();
    }

    //
    //  delete CS
    //      - these stay up once initialized, so are not in dhcp_CleanupGlobals()
    //

    if ( g_DhcpThreadCsInitialized )
    {
        DeleteCriticalSection( &g_DhcpThreadCS );
    }
    if ( g_DhcpListCsInitialized )
    {
        DeleteCriticalSection( &g_DhcpListCS );
    }
}


//
//  Public functions
//

DNS_STATUS
WINAPI
DnsDhcpRegisterInit(
   VOID
   )
/*++

Routine Description:

    Initialize asynchronous DNS registration.

    Process must call (one time) before calling DnsDhcpRegisterHostAddrs.

Arguments:

    None.

Return Value:

    DNS or Win32 error code.

--*/
{
    DWORD   status = ERROR_SUCCESS;
    DWORD   disposition;
    DWORD   disallowUpdate;

    DNSDBG( TRACE, ( "DnsDhcpRegisterInit()\n" ));

    //
    //  lock init
    //      - lock with general CS until have reg list lock up
    //      - then reg thread lock locks init
    //
    //  this keeps general CS lock "light" -- keeps it from being
    //  held through registry operations
    //  note that this REQUIRES us to keep the g_DhcpThreadCS up once
    //  initialized or we have no protection
    //

    LOCK_GENERAL();
    if ( g_RegInitialized )
    {
        UNLOCK_GENERAL();
        return  NO_ERROR;
    }

    if ( !g_DhcpThreadCsInitialized )
    {
        status = RtlInitializeCriticalSection( &g_DhcpThreadCS );
        if ( status != ERROR_SUCCESS )
        {
            UNLOCK_GENERAL();
            return  status;
        }
        g_DhcpThreadCsInitialized = TRUE;
    }

    UNLOCK_GENERAL();

    //
    //  rest of init under reg list CS
    //

    LOCK_REG_THREAD();
    if ( g_RegInitialized )
    {
        goto Unlock;
    }

    //
    //  Initialize debug logging funtion
    //

    ASYNCREG_INIT();
    ASYNCREG_F1( "Inside function DnsDhcpRegisterInit" );
    ASYNCREG_TIME();

    //
    //  list lock
    //

    if ( !g_DhcpListCsInitialized )
    {
        status = RtlInitializeCriticalSection( &g_DhcpListCS );
        if ( status != ERROR_SUCCESS )
        {
            goto ErrorExit;
        }
        g_DhcpListCsInitialized = TRUE;
    }

    //
    //  create private heap
    //

    g_DhcpRegHeap = HeapCreate( 0, INITIAL_DHCP_HEAP_SIZE, 0 );
    if ( g_DhcpRegHeap == NULL )
    {
        ASYNCREG_F1( "ERROR: DnsDhcpRegisterInit function failed to create heap" );
        status = DNS_ERROR_NO_MEMORY;
        goto ErrorExit;
    }

    //
    //  get registration configuration info
    //      - just insure we have the latest copy
    //
    //  DCR_FIX:  when available get latest copy from resolver
    //      does not need to be done on init, may be done on call
    //

    Reg_ReadGlobalsEx( 0, NULL );

    //
    //  open the reg location for info
    //
    
    status = RegCreateKeyExW(
                    HKEY_LOCAL_MACHINE,
                    DHCP_CLIENT_REG_LOCATION,
                    0,                         // reserved
                    DYN_DNS_ROOT_CLASS,
                    REG_OPTION_NON_VOLATILE,   // options
                    KEY_READ | KEY_WRITE,      // desired access
                    NULL,
                    &g_hDhcpRegKey,
                    &disposition
                    );

    if ( status != NO_ERROR )
    {
        goto ErrorExit;
    }
                                  

    g_hDhcpWakeEvent = CreateEvent(
                            NULL,
                            TRUE,
                            FALSE,
                            NULL );
    if ( !g_hDhcpWakeEvent )
    {
        status = GetLastError();
        goto ErrorExit;
    }

    //
    //  reset registration globals
    //

    InitializeListHead( &g_DhcpRegList );

    g_fDhcpThreadRunning = FALSE;
    g_fDhcpThreadStop = FALSE;
    g_fDhcpThreadCheckBeforeExit = FALSE;
    g_DhcpThreadWaitCount = 0;

    g_fNoMoreDhcpUpdates = FALSE;
    g_fPurgeRegistrations = FALSE;
    g_fPurgeRegistrationsInitiated = FALSE;

    ResetAdaptersInRegistry();

    g_RegInitialized = TRUE;

Unlock:

    UNLOCK_REG_THREAD();

    DNSDBG( TRACE, ( "Leave DnsDhcpRegisterInit() => Success!\n" ));
    return NO_ERROR;


ErrorExit:

    dhcp_CleanupGlobals();

    UNLOCK_REG_THREAD();

    DNSDBG( TRACE, (
        "Failed DnsDhcpRegisterInit() => status = %d\n",
        status ));

    if ( status != ERROR_SUCCESS )
    {
        status = DNS_ERROR_NO_MEMORY;
    }
    return( status );
}




DNS_STATUS
WINAPI
DnsDhcpRegisterTerm(
   VOID
   )
/*++

Routine Description:

    Stop DNS registration.  Shutdown DNS registration thread.

    Initialization routine each process should call exactly on exit after
    using DnsDhcpRegisterHostAddrs. This will signal to us that if our
    thread is still trying to talk to a server, we'll stop trying.

Arguments:

    None.

Return Value:

    DNS or Win32 error code.

--*/
{
    DWORD   waitResult;

    DNSDBG( TRACE, ( "DnsDhcpRegisterTerm()\n" ));

    if ( !g_RegInitialized )
    {
        DNS_ASSERT(FALSE) ;
        return ERROR_INTERNAL_ERROR ;
    }

    ASYNCREG_F1( "Inside function DnsDhcpRegisterTerm" );
    ASYNCREG_TIME();
    ASYNCREG_F1( "" );

    //
    //  if thread is running, wait for stop
    //

    LOCK_REG_THREAD();

    if ( g_hDhcpThread )
    {
        g_fDhcpThreadStop = TRUE;
        g_DhcpThreadWaitCount++;

        //  note, it's possible (if there's a race with the thread shutting down)
        //      for event to be gone

        if ( g_hDhcpWakeEvent )
        {
            SetEvent( g_hDhcpWakeEvent );
        }
        UNLOCK_REG_THREAD();

        waitResult = WaitForSingleObject(
                            g_hDhcpThread,
                            INFINITE );
        switch ( waitResult )
        {
        case WAIT_OBJECT_0:

            ASYNCREG_F1( "DNSAPI.DLL: Registration thread signaled it was finished" );
            ASYNCREG_F1( "" );
            break;

        default:

            ASYNCREG_F1( "DNSAPI.DLL: Registration thread won't stop! " );
            ASYNCREG_F1( "" );
            DNS_ASSERT( FALSE );
            break;
        }

        LOCK_REG_THREAD();
        g_DhcpThreadWaitCount--;
        if ( g_DhcpThreadWaitCount == 0 )
        {
            CloseHandle( g_hDhcpThread );
            g_hDhcpThread = NULL;
        }
        if ( g_fDhcpThreadRunning )
        {
            ASYNCREG_F1( "DNSAPI.DLL: Registration thread wasn't stopped! " );
            ASYNCREG_F1( "" );
            DNS_ASSERT( FALSE );

            UNLOCK_REG_THREAD();
            return ERROR_INTERNAL_ERROR;
        }
    }

    Dns_TimeoutSecurityContextList( TRUE );
    dhcp_CleanupGlobals();

    UNLOCK_REG_THREAD();

    return NO_ERROR;
}



DNS_STATUS
WINAPI
DnsDhcpRemoveRegistrations(
   VOID
   )
/*++

Routine Description:

    Remove DNS host registrations for this machine.

    This will be called by DHCP client on domain unjoin.  Removes DNS
    registrations for the box, then terminates the registration thread
    to disable further registrations.

    Registrations can only be reenabled by calling DnsDhcpRegisterInit()
    again.

Arguments:

    None.

Return Value:

    ERROR_SUCCESS if successful.
    ErrorCode on failure.

--*/
{
    PLIST_ENTRY pListEntry;
    PLIST_ENTRY pTopOfList;

    ASYNCREG_F1( "Inside function DnsDhcpRemoveRegistrations" );
    ASYNCREG_TIME();
    DNSDBG( TRACE, ( "DnsDhcpRemoveRegistrations()\n" ));

    if ( !g_RegInitialized )
    {
        ASYNCREG_F1( "DnsDhcpRemoveRegistrations returning ERROR_SERVICE_NOT_ACTIVE" );
        ASYNCREG_F1( "This is an error in DHCP client code, it forgot to call DnsDhcpRegisterInit()" );
        return ERROR_SERVICE_NOT_ACTIVE;
    }

    //
    // Set a global flag to disable any further adapter registration calls
    //

    g_fNoMoreDhcpUpdates = TRUE;

    //
    // Get the Registration list lock
    //
    LOCK_REG_LIST();

    //
    // Mark any and all adapter registration information in the registry
    // as non-registered. These will be later interpreted as non-existant
    // and deregistered by the dhcp_RegistrationThread.
    //
    ResetAdaptersInRegistry();

    //
    // Walk the list of pending update entries and clear out the
    // non-neccessary updates.
    //

    pTopOfList = &g_DhcpRegList;
    pListEntry = pTopOfList->Flink;

    while ( pListEntry != pTopOfList )
    {
        if ( ((PUPDATE_ENTRY) pListEntry)->SignatureTop !=
             DNS_SIG_TOP ||
             ((PUPDATE_ENTRY) pListEntry)->SignatureBottom !=
             DNS_SIG_BOTTOM )
        {
            //
            // Someone trashed our registration list!
            //
            DNS_ASSERT( FALSE );

            //
            // We'll reset it and try to move on . . .
            //
            InitializeListHead( &g_DhcpRegList );
            pTopOfList = &g_DhcpRegList;
            pListEntry = pTopOfList->Flink;
            continue;
        }

        if ( !((PUPDATE_ENTRY) pListEntry)->fRemove )
        {
            //
            // There is an update entry in the registration list
            // that has not yet been processed. Since it is an
            // add update, we'll blow it away.
            //

            pListEntry = dequeueAndCleanupUpdate( pListEntry );
            continue;
        }
        else
        {
            ((PUPDATE_ENTRY) pListEntry)->fNewElement = TRUE;
            ((PUPDATE_ENTRY) pListEntry)->fRegisteredFWD = FALSE;
            ((PUPDATE_ENTRY) pListEntry)->fRegisteredPRI = FALSE;
            ((PUPDATE_ENTRY) pListEntry)->fRegisteredPTR = FALSE;
            ((PUPDATE_ENTRY) pListEntry)->fDisableErrorLogging = FALSE;
            ((PUPDATE_ENTRY) pListEntry)->RetryCount = 0;
            ((PUPDATE_ENTRY) pListEntry)->RetryTime = Dns_GetCurrentTimeInSeconds();

            pListEntry = pListEntry->Flink;
        }
    }

    UNLOCK_REG_LIST();

    g_fPurgeRegistrations = TRUE;


    //
    //  start async registration thread if not started
    //

    LOCK_REG_THREAD();

    alertOrStartRegistrationThread();

    //
    //  wait for async registration thread to terminate
    //
    //  however we'll bag it after a few minutes -- a robustness check
    //  to avoid long hang;  Generally the machine will be rebooted
    //  so failure to cleanup the list and terminate is not critical;
    //  Registrations will have to be cleaned up by admin action or
    //  aging on the DNS server
    //

    if ( g_hDhcpThread )
    {
        DWORD   waitResult;

        g_DhcpThreadWaitCount++;
        UNLOCK_REG_THREAD();

        waitResult = WaitForSingleObject(
                            g_hDhcpThread,
                            REMOVE_REGISTRATION_WAIT_LIMIT );

        if ( waitResult != WAIT_OBJECT_0 )
        {
            ASYNCREG_F1(
                "ERROR:  RemoveRegistration() wait expired before async thread\n"
                "\ttermination!\n" );
            DNSDBG( ANY, (
                "ERROR:  RemoveRegistration() wait completed without thread stop.\n"
                "\tWaitResult = %d\n",
                waitResult ));
        }

        LOCK_REG_THREAD();
        g_DhcpThreadWaitCount--;
        if ( g_DhcpThreadWaitCount == 0 )
        {
            CloseHandle( g_hDhcpThread );
            g_hDhcpThread = NULL;
        }

    }
    UNLOCK_REG_THREAD();

    return NO_ERROR;
}



DNS_STATUS
WINAPI
DnsDhcpRegisterHostAddrs(
    IN  PWSTR                   pszAdapterName,
    IN  PWSTR                   pszHostName,
    IN  PREGISTER_HOST_ENTRY    pHostAddrs,
    IN  DWORD                   dwHostAddrCount,
    IN  PIP4_ADDRESS            pipDnsServerList,
    IN  DWORD                   dwDnsServerCount,
    IN  PWSTR                   pszDomainName,
    IN  PREGISTER_HOST_STATUS   pRegisterStatus,
    IN  DWORD                   dwTTL,
    IN  DWORD                   dwFlags
    )
/*++

Routine Description:

    Registers host address with DNS server.

    This is called by DHCP client to register a particular IP.

Arguments:

Return Value:

    ERROR_SUCCESS if successful.
    Error code on failure.

--*/
{
    DWORD               status = NO_ERROR;
    PUPDATE_ENTRY       pupEntry = NULL;
    PWSTR               padapterDN = NULL;
    PWSTR               pprimaryDN = NULL;
    REG_UPDATE_INFO     updateInfo;
    BOOL                fcleanupUpdateInfo = FALSE;
    PSTR                preason = NULL;

    DNSDBG( DHCP, (
        "\n\n"
        "DnsDhcpRegisterHostAddrs()\n"
        "\tadapter name     = %S\n"
        "\thost name        = %S\n"
        "\tadapter domain   = %S\n"
        "\tAddr count       = %d\n"
        "\tpHostAddrs       = %p\n"
        "\tDNS count        = %d\n"
        "\tDNS list         = %p\n",
        pszAdapterName,
        pszHostName,
        pszDomainName,
        dwHostAddrCount,
        pHostAddrs,
        dwDnsServerCount,
        pipDnsServerList ));

    DnsDbg_Flush();

    ASYNCREG_F1( "Inside function DnsDhcpRegisterHostAddrs, parameters are:" );
    ASYNCREG_F2( "    pszAdapterName   : %S", pszAdapterName );
    ASYNCREG_F2( "    pszHostName      : %S", pszHostName );
    ASYNCREG_F2( "    pszDomainName    : %S", pszDomainName );
    ASYNCREG_F2( "    dwHostAddrCount  : %d", dwHostAddrCount );
    DNSLOG_HOST_ENTRYS( dwHostAddrCount, pHostAddrs );
    ASYNCREG_F2( "    dwDnsServerCount : %d", dwDnsServerCount );
    if ( dwDnsServerCount && pipDnsServerList )
    {
        DNSLOG_IP4_ADDRESS( dwDnsServerCount, pipDnsServerList );
    }
    ASYNCREG_F2( "    dwTTL            : %d", dwTTL );
    ASYNCREG_F2( "    dwFlags          : %d", dwFlags );
    ASYNCREG_F1( "" );
    ASYNCREG_TIME();


    //
    // first things first, need to inform underlying code that something
    // has changed in the list of net adapters. Glenn is going to be called
    // now so that he can re read the registry (or do any appropriate query)
    // to now note the changed state.
    //

    if ( !(dwFlags & DYNDNS_DEL_ENTRY) )
    {
        DnsNotifyResolver( 0, NULL );
    }

    if ( !g_RegInitialized )
    {
        DNSDBG( ANY, (
            "ERROR:  AsyncRegisterHostAddrs called before Init routine!!!\n" ));
        status = ERROR_SERVICE_NOT_ACTIVE;
        goto Exit;
    }
    if ( g_fNoMoreDhcpUpdates || g_fDhcpThreadStop )
    {
        DNSDBG( ANY, (
            "ERROR:  AsyncRegisterHostAddrs called after RemoveRegistrations()!!!\n" ));
        status = ERROR_SERVICE_NOT_ACTIVE;
        goto Exit;
    }

    //
    //  Validate parameters
    //

    if ( !pszAdapterName || !(*pszAdapterName) )
    {
        DNSDBG( ANY, ( "ERROR:  RegisterHostAddrs invalid adaptername!\n" ));
        status = ERROR_INVALID_PARAMETER;
        goto Exit;
    }
    if ( ( !pszHostName || !(*pszHostName) ) &&
         !( dwFlags & DYNDNS_DEL_ENTRY ) )
    {
        DNSDBG( ANY, ( "ERROR:  RegisterHostAddrs invalid hostname!\n" ));
        status = ERROR_INVALID_PARAMETER;
        goto Exit;
    }
    if ( dwHostAddrCount && !pHostAddrs )
    {
        DNSDBG( ANY, ( "ERROR:  RegisterHostAddrs invalid host addresses!\n" ));
        status = ERROR_INVALID_PARAMETER;
        goto Exit;
    }

    //
    //  get adapter update configuration
    //

    status = Reg_ReadUpdateInfo(
                pszAdapterName,
                & updateInfo );
    if ( status != ERROR_SUCCESS )
    {
        DNSDBG( DHCP, (
            "Update registry read failure %d\n",
            status ));
        goto Exit;
    }
    fcleanupUpdateInfo = TRUE;


    //
    //  skip WAN, if not doing WAN by policy
    //

    if ( (dwFlags & DYNDNS_REG_RAS) && !g_RegisterWanAdapters )
    {
        preason = "because WAN adapter registrations are disabled";
        goto NoActionExit;
    }

    //
    //  policy DNS servers, override passed in list
    //

    if ( updateInfo.pDnsServerArray )
    {
        pipDnsServerList = updateInfo.pDnsServerArray->AddrArray;
        dwDnsServerCount = updateInfo.pDnsServerArray->AddrCount;
    }

    //
    //  must have DNS servers to update adapter
    //      - don't update IP on one interface starting with DNS servers
    //      from another
    //

    if ( dwDnsServerCount && !pipDnsServerList )
    {
        preason = "no DNS servers";
        status = ERROR_INVALID_PARAMETER;
        goto Exit;
    }
    if ( ! dwDnsServerCount &&
         ! (dwFlags & DYNDNS_DEL_ENTRY) )
    {
        preason = "no DNS servers";
        status = ERROR_INVALID_PARAMETER;
        goto Exit;
    }

    //
    //  no update on adpater => delete outstanding updates
    //      note, we do before delete check below for event check
    //

    if ( !updateInfo.fRegistrationEnabled )
    {
        preason = "because adapter is disabled";

        if ( pRegisterStatus )
        {
            pRegisterStatus->dwStatus = NO_ERROR;
            SetEvent( pRegisterStatus->hDoneEvent );
        }
        if ( searchForOldUpdateEntriesAndCleanUp(
                    pszAdapterName,
                    NULL,
                    TRUE ) )
        {
            goto CheckThread;
        }
        status = NO_ERROR;
        goto Exit;
        //goto NoActionExit;
    }

    //
    //  delete update -- cleanup and delete
    //      - delete outstanding update in list
    //      - cleanup registry
    //      - do delete
    //

    if ( dwFlags & DYNDNS_DEL_ENTRY )
    {
        DNSDBG( DHCP, ( "Do delete entry ...\n" ));

        if ( searchForOldUpdateEntriesAndCleanUp(
                pszAdapterName,
                NULL,
                TRUE ) )
        {
            goto CheckThread;
        }
    }

    //
    //  limit IP registration count
    //      if doing registration and no addresses -- bail
    //

    if ( updateInfo.RegistrationMaxAddressCount < dwHostAddrCount )
    {
        dwHostAddrCount = updateInfo.RegistrationMaxAddressCount;

        DNSDBG( DHCP, (
            "Limiting DHCP registration to %d addrs.\n",
            dwHostAddrCount ));
        ASYNCREG_F2(
            "Restricting adapter registration to the first %d addresses",
            dwHostAddrCount );
    }
    if ( dwHostAddrCount == 0 )
    {
        preason = "done -- there are no addresses to register in DNS";
        goto NoActionExit;
    }

    //
    //  no\empty host name or zero IP => bogus
    //

    if ( !pszHostName ||
         !(*pszHostName) ||
         ( dwHostAddrCount && ( pHostAddrs[0].Addr.ipAddr == 0 ) ) )
    {
        preason = "invalid (or no) hostname or zero IP address";
        status = ERROR_INVALID_PARAMETER;
        goto Exit;
    }

    //
    //  determine domain names to update
    //      - get PDN
    //      - adapter name
    //          - none if adapter name registration off
    //          - else check policy override
    //          - else name passed in
    //          - but treat empty as NULL
    //

    pprimaryDN = updateInfo.pszPrimaryDomainName;

    if ( updateInfo.fRegisterAdapterName )
    {
        if ( updateInfo.pszAdapterDomainName )
        {
            padapterDN = updateInfo.pszAdapterDomainName;
        }
        else
        {
            padapterDN = pszDomainName;
        }
        if ( padapterDN &&
             !(*padapterDN) )
        {
            padapterDN = NULL;
        }
    }

    //
    //  no domains => nothing to register, we're done
    //

    if ( !padapterDN &&
         !pprimaryDN )
    {
        preason = "no adapter name and no PDN";
        goto NoActionExit;
    }

    //  if adapter name same as PDN -- just one update

    if ( pprimaryDN &&
         padapterDN &&
         Dns_NameCompare_W( pprimaryDN, padapterDN ) )
    {
        DNSDBG( DHCP, (
            "Adapter name same as PDN -- no separate adapter update.\n" ));
        padapterDN = NULL;
    }

    //  build update

    status = AllocateUpdateEntry(
                    pszAdapterName,
                    pszHostName,
                    padapterDN,
                    pprimaryDN,
                    updateInfo.pmszAlternateNames,
                    dwHostAddrCount,
                    pHostAddrs,
                    dwDnsServerCount,
                    pipDnsServerList,
                    0,      // No particular server IP at this time
                    0,      // No particular server IP at this time
                    (dwTTL == 0xffffffff || dwTTL == 0)
                            ? g_RegistrationTtl
                            : dwTTL,
                    dwFlags,
                    0,
                    Dns_GetCurrentTimeInSeconds(),
                    pRegisterStatus,
                    &pupEntry );

    if ( status != NO_ERROR )
    {
        goto Exit;
    }

    //
    // More WAN adapter hacks . . .
    // If DDNS is not disabled for WAN adapters, then the default
    // behavior for logging update events is disabled on these type
    // adapters. There is a registry key that can turn on the logging
    // of WAN adapter updates if such a user is interested. We configure
    // those settings here.
    //

    if ( dwFlags & DYNDNS_REG_RAS )
    {
        pupEntry->fDisableErrorLogging = TRUE;
    }

    //
    // When adding an entry to the registration list, first walk the
    // list to look for any other updates for the same adapter.
    // If there is already an add update in the list, blow it away.
    // If there is already a delete update in the list with the same
    // information, blow it away.
    //
    // Then put update into registration list.
    //

    searchForOldUpdateEntriesAndCleanUp(
        pupEntry->AdapterName,
        pupEntry,
        FALSE );

    //
    // Since we are about to queue up an update entry for a given
    // adapter, we need to mark any possible previous registration
    // information that could be in the registry as pending. This
    // marking will prevent the old data from being incorrectly
    // queued as a disabled adapter if any errors are encountered
    // on the update attempts. i.e failed update attempts on a given
    // adapter should not be regarded as a disabled adapter that needs
    // to have it's stale records cleaned up.
    //
    MarkAdapterAsPendingUpdate( pszAdapterName );

    DNSDBG( DHCP, (
        "Queuing update %p to registration list.\n",
        pupEntry ));

    LOCK_REG_LIST();
    InsertTailList( &g_DhcpRegList, (PLIST_ENTRY) pupEntry );
    UNLOCK_REG_LIST();

CheckThread:

    //
    //  DCR:  do we need cleanup if thread is dead?
    //

    alertOrStartRegistrationThread();
    status = NO_ERROR;
    goto Exit;


NoActionExit:

    //
    //  exit for no-action no-error exit
    //

    DNSDBG( DHCP, (
        "DnsDhcpRegisterHostAddrs()\n"
        "\tno-update no-error exit\n" ));

    status = NO_ERROR;

    if ( pRegisterStatus )
    {
        pRegisterStatus->dwStatus = NO_ERROR;
        SetEvent( pRegisterStatus->hDoneEvent );
    }

Exit:

    //
    //  cleanup allocated update info
    //

    if ( fcleanupUpdateInfo )
    {
        Reg_FreeUpdateInfo(
            &updateInfo,
            FALSE           // no free struct, it's on stack
            );
    }

    ASYNCREG_F2( "DnsDhcpRegisterHostAddrs returning %d", status );
    if ( preason )
    {
        ASYNCREG_F1( preason );
    }

    DNSDBG( DHCP, (
        "Leaving DnsDhcpRegisterHostAddrs()\n"
        "\tstatus = %d\n"
        "\treason = %s\n",
        status,
        preason ));

    return( status );
}



//
//  Async registration utilities
//

PSTR
CreateNarrowStringCopy(
    IN      PSTR            pString
    )
{
    PSTR    pnew = NULL;

    if ( pString )
    {
        pnew = HeapAlloc(
                    g_DhcpRegHeap,
                    0,
                    strlen(pString) + 1 );
        if ( pnew )
        {
            strcpy( pnew, pString );
        }
    }

    return  pnew;
}

PWSTR
CreateWideStringCopy(
    IN      PWSTR           pString
    )
{
    PWSTR   pnew = NULL;

    if ( pString )
    {
        pnew = HeapAlloc(
                    g_DhcpRegHeap,
                    0,
                    (wcslen(pString) + 1) * sizeof(WCHAR) );
        if ( pnew )
        {
            wcscpy( pnew, pString );
        }
    }

    return  pnew;
}

VOID
PrivateHeapFree(
    IN      PVOID           pVal
    )
{
    if ( pVal )
    {
        HeapFree(
             g_DhcpRegHeap,
             0,
             pVal );
    }
}



DNS_STATUS
AllocateCombinedName(
    IN      PWSTR           pHostName,
    IN      PWSTR           pDomainName,
    OUT     PWSTR *         ppFQDN,
    OUT     PWSTR *         ppDomain
    )
{
    DWORD       hostlen;
    PWSTR       pname;
    WCHAR       nameBuffer[ DNS_MAX_NAME_BUFFER_LENGTH ];

    DNSDBG( TRACE, ( "AllocateCombinedName()\n" ));

    if ( !pHostName || !pDomainName )
    {
        DNS_ASSERT( FALSE );
        return  ERROR_INVALID_NAME;
    }

    //
    //  include hostname -- if exists
    //

    hostlen = wcslen( pHostName );

    if ( !Dns_NameAppend_W(
            nameBuffer,
            DNS_MAX_NAME_BUFFER_LENGTH,
            pHostName,
            pDomainName ) )
    {
        return  ERROR_INVALID_NAME;
    }
    
    //
    //  allocate name
    //

    pname = CreateWideStringCopy( nameBuffer );
    if ( !pname )
    {
        return  DNS_ERROR_NO_MEMORY;
    }

    //
    //  domain name starts immediately after hostname
    //      - test first in case hostname was given with terminating dot
    //

    if ( pname[ hostlen ] == L'.' )
    {
        hostlen++;
    }
    *ppDomain = pname + hostlen;
    *ppFQDN = pname;

    return  NO_ERROR;
}



DNS_STATUS
AllocateUpdateEntry(
    IN  PWSTR                   AdapterName,
    IN  PWSTR                   HostName,
    IN  PWSTR                   DomainName,
    IN  PWSTR                   PrimaryDomainName,
    IN  PWSTR                   AlternateNames,
    IN  DWORD                   HostAddrCount,
    IN  PREGISTER_HOST_ENTRY    HostAddrs,
    IN  DWORD                   DnsServerCount,
    IN  PIP4_ADDRESS            DnsServerList,
    IN  IP4_ADDRESS             SentUpdateToIp,
    IN  IP4_ADDRESS             SentPriUpdateToIp,
    IN  DWORD                   TTL,
    IN  DWORD                   Flags,
    IN  DWORD                   RetryCount,
    IN  DWORD                   RetryTime,
    IN  PREGISTER_HOST_STATUS   Registerstatus,
    OUT PUPDATE_ENTRY *         ppUpdateEntry
    )
/*++

Routine Description:

    Create update info blob.

Arguments:

Return Value:

    ERROR_SUCCESS if successful.
    Error code on failure.

--*/
{
    PUPDATE_ENTRY   pupEntry = NULL;
    DWORD           status = ERROR_SUCCESS;
    PWSTR           ptempDomain = DomainName;
    PWSTR           ptempPrimaryDomain = PrimaryDomainName;

    if ( ptempDomain && !(*ptempDomain) )
    {
        ptempDomain = NULL;
    }
    if ( ptempPrimaryDomain && !(*ptempPrimaryDomain) )
    {
        ptempPrimaryDomain = NULL;
    }
    if ( AdapterName && !(*AdapterName) )
    {
        AdapterName = NULL;
    }
    if ( HostName && !(*HostName) )
    {
        HostName = NULL;
    }

    DNSDBG( TRACE, ( "AllocateUpdateEntry()\n" ));
    DNSDBG( DHCP, (
        "AllocateUpdateEntry()\n"
        "\tAdapterName          = %S\n"
        "\tHostName             = %S\n"
        "\tPrimaryDomain        = %S\n"
        "\tAdapterDomain        = %S\n"
        "\tAlternateNames       = %S\n"
        "\tHostAddrCount        = %d\n"
        "\tpHostAddrs           = %p\n"
        "\tTTL                  = %d\n"
        "\tFlags                = %08x\n"
        "\tHostAddrCount        = %d\n"
        "\tTime                 = %d\n",
        AdapterName,
        HostName,
        PrimaryDomainName,
        DomainName,
        AlternateNames,
        HostAddrCount,
        HostAddrs,
        TTL,
        Flags,
        RetryTime
        ));

    if ( !AdapterName ||
         !HostName ||
         !HostAddrCount )
    {
        ASYNCREG_F1( "AllocateUpdateEntry returing error : ERROR_INVALID_PARAMETER" );
        ASYNCREG_F1( "" );
        status = ERROR_INVALID_PARAMETER;
        goto Exit;
    }

    pupEntry = PHEAP_ALLOC_ZERO( sizeof(UPDATE_ENTRY) );
    if ( !pupEntry )
    {
        status = DNS_ERROR_NO_MEMORY;
        goto Exit;
    }

    InitializeListHead( &(pupEntry->List) );

    pupEntry->SignatureTop = DNS_SIG_TOP;
    pupEntry->SignatureBottom = DNS_SIG_BOTTOM;

    //
    //  copy strings
    //

    pupEntry->AdapterName = CreateWideStringCopy( AdapterName );
    if ( !pupEntry->AdapterName )
    {
        status = DNS_ERROR_NO_MEMORY;
        goto Exit;
    }

    pupEntry->HostName = CreateWideStringCopy( HostName );
    if ( !pupEntry->HostName )
    {
        status = DNS_ERROR_NO_MEMORY;
        goto Exit;
    }
    
    if ( ptempDomain )
    {
        status = AllocateCombinedName(
                    HostName,
                    ptempDomain,
                    & pupEntry->pAdapterFQDN,
                    & pupEntry->DomainName );

        if ( status != NO_ERROR )
        {
            goto Exit;
        }
    }

    if ( ptempPrimaryDomain )
    {
        status = AllocateCombinedName(
                    HostName,
                    ptempPrimaryDomain,
                    & pupEntry->pPrimaryFQDN,
                    & pupEntry->PrimaryDomainName );

        if ( status != NO_ERROR )
        {
            goto Exit;
        }
    }

    if ( AlternateNames )
    {
        pupEntry->AlternateNames = MultiSz_Copy_W( AlternateNames );
        if ( !pupEntry->AlternateNames )
        {
            status = DNS_ERROR_NO_MEMORY;
            goto Exit;
        }
    }

    if ( HostAddrCount )
    {
        pupEntry->HostAddrs = PHEAP_ALLOC( sizeof(REGISTER_HOST_ENTRY) * HostAddrCount );

        if ( !pupEntry->HostAddrs )
        {
            status = DNS_ERROR_NO_MEMORY;
            goto Exit;
        }
        memcpy(
            pupEntry->HostAddrs,
            HostAddrs,
            sizeof(REGISTER_HOST_ENTRY) * HostAddrCount );
    }
    pupEntry->HostAddrCount = HostAddrCount;

    if ( DnsServerCount )
    {
        pupEntry->DnsServerList = Dns_BuildIpArray(
                                        DnsServerCount,
                                        DnsServerList );
        if ( !pupEntry->DnsServerList )
        {
            status = DNS_ERROR_NO_MEMORY;
            goto Exit;
        }
    }

    //  should have valid server addresses -- or zero

    if ( SentPriUpdateToIp == INADDR_NONE )
    {
        DNS_ASSERT( SentPriUpdateToIp != INADDR_NONE );
        SentPriUpdateToIp = 0;
    }
    if ( SentUpdateToIp == INADDR_NONE )
    {
        DNS_ASSERT( SentUpdateToIp != INADDR_NONE );
        SentUpdateToIp = 0;
    }

    pupEntry->SentUpdateToIp = SentUpdateToIp;
    pupEntry->SentPriUpdateToIp = SentPriUpdateToIp;
    pupEntry->pRegisterStatus = Registerstatus;
    pupEntry->TTL = TTL;
    pupEntry->Flags = Flags;
    pupEntry->fRemove = Flags & DYNDNS_DEL_ENTRY ? TRUE : FALSE;
    pupEntry->fNewElement = TRUE;
    pupEntry->RetryCount = RetryCount;
    pupEntry->RetryTime = RetryTime;

Exit:

    if ( status!=ERROR_SUCCESS && pupEntry )
    {
        FreeUpdateEntry( pupEntry );
        pupEntry = NULL;
    }

    *ppUpdateEntry = pupEntry;

    return (status);
}



VOID
FreeUpdateEntry(
    IN OUT  PUPDATE_ENTRY   pUpdateEntry
    )
/*++

Routine Description:

    Free update blob entry.

Arguments:

    pUpdateEntry -- update entry blob to free

Return Value:

    None

--*/
{
    DNSDBG( DHCP, (
        "FreeUpdateEntry( %p )\n",
        pUpdateEntry ));

    //
    //  deep free the update entry
    //

    if ( pUpdateEntry )
    {
        PrivateHeapFree( pUpdateEntry->AdapterName );
        PrivateHeapFree( pUpdateEntry->HostName );
        PrivateHeapFree( pUpdateEntry->pAdapterFQDN );
        PrivateHeapFree( pUpdateEntry->pPrimaryFQDN );
        PrivateHeapFree( pUpdateEntry->HostAddrs );

        //  alternate names created by MultiSz_Copy_A() in dnslib
        //      - free with dnslib free routine

        Dns_Free( pUpdateEntry->AlternateNames );

        //  server list is created by Dns_BuildIpArray() (uses dnslib heap)
        //      - free with dnslib free routine

        Dns_Free( pUpdateEntry->DnsServerList );

        PrivateHeapFree( pUpdateEntry );
    }
}



VOID
FreeUpdateEntryList(
    IN OUT  PLIST_ENTRY     pUpdateEntry
    )
/*++

Routine Description:

    Free all updates in update list.

Arguments:

    pUpdateEntry -- update list head

Return Value:

    None

--*/
{
    PLIST_ENTRY     pentry = NULL;

    DNSDBG( DHCP, (
        "FreeUpdateEntryList( %p )\n",
        pUpdateEntry ));

    while ( !IsListEmpty( pUpdateEntry ) )
    {
        pentry = RemoveHeadList( pUpdateEntry );
        if ( pentry )
        {
            FreeUpdateEntry( (PUPDATE_ENTRY) pentry );
        }
    }
}



DWORD
WINAPI
dhcp_RegistrationThread(
    VOID
    )
/*++

Routine Description:

    Registration thread.

    This thread does actual updates, and stays alive until they are
    completed, allowing registration API calls to return.

    This thread is created at boot time as soon as the first register
    request comes in. The thread simply waits for a certain amount of time
    given by boot time or be signaled by DnsDhcpRegisterHostEntries.

    This function collects all the requests and does the appropriate
    aggregation of requests and sends off the modify/add/delete commands
    to the DNS Server. When the call is successful, it makes a note of
    this in the registry

Arguments:

    None

Return Value:

    ERROR_SUCCESS if successful.
    ErrorCode on failure.

--*/
{
    DWORD   waitResult = NO_ERROR;
    DWORD   status = NO_ERROR;
    DWORD   waitTime = WAIT_ON_BOOT;
    BOOL    fthreadLock = FALSE;
    DWORD   endBootTime;

    DNSDBG( DHCP, (
        "dhcp_RegistrationThread() start!\n" ));

    if ( !g_hDhcpRegKey )
    {
        return( ERROR_INVALID_PARAMETER );
    }

    //
    //  Note that this thread is running by setting a global flag
    //

    g_fDhcpThreadRunning = TRUE;

    //
    //  wait for small interval at boot
    //
    //  this allows all adapters to come up, so we can do single updates
    //  and not register, then whack registration with new data seconds later
    //

    waitTime = 0;

    if ( g_fAtBoot && !g_fPurgeRegistrations )
    {
        waitTime = WAIT_ON_BOOT;
        endBootTime = Dns_GetCurrentTimeInSeconds() + waitTime;
    }

    //
    //  loop through update list, doing any update
    //      - do new updates
    //      - do retries that have reached retry time
    //      - when list empty, terminate thread
    //

    while ( 1 )
    {
        //
        //  if shutdown -- shutdown
        //

        if ( g_fDhcpThreadStop )
        {
            goto Termination;
        }

        //
        //  check zero wait
        //
        //  except for first time through (waitResult==NO_ERROR)
        //  we should NEVER have zero wait
        //

        if ( waitTime == 0 )
        {
            if ( waitResult != NO_ERROR )
            {
                DNSDBG( ANY, (
                    "ERROR:  DHCP thread with zero wait time!!!\n" ));
                DNS_ASSERT( FALSE );
                waitTime = 3600;
            }
        }

        waitResult = WaitForSingleObject(
                        g_hDhcpWakeEvent,
                        waitTime * 1000 );

        DNSDBG( DHCP, (
            "Dhcp reg thread wakeup => %d\n"
            "\tstop         = %d\n"
            "\tno more      = %d\n"
            "\tpurge        = %d\n"
            "\twait count   = %d\n",
            waitResult,
            g_fDhcpThreadStop,
            g_fNoMoreDhcpUpdates,
            g_fPurgeRegistrations,
            g_DhcpThreadWaitCount ));

        //
        //  wait for small interval at boot
        //
        //  this allows all adapter info to collect before we
        //  start doing updates -- saving us from whacking and
        //  rewhacking
        //

        if ( g_fAtBoot && !g_fPurgeRegistrations )
        {
            waitTime = endBootTime - Dns_GetCurrentTimeInSeconds();
            if ( (LONG)waitTime > 0 )
            {
                continue;
            }
        }

        //
        //  loop getting "updateable" update from list (if any)
        //
        //      REG_LIST_FOUND -- "ready update" either new or past retry time
        //          => execute update
        //
        //      REG_LIST_WAIT -- list has only "not ready" retries
        //          => wait
        //
        //      REG_LIST_EMPTY -- list empty
        //          => exit thread
        //

        while ( 1 )
        {
            PUPDATE_ENTRY   pupEntry = NULL;
            BOOL            fattemptSelfExit = FALSE;
            DWORD           listState;

            if ( g_fDhcpThreadStop )
            {
                goto Termination;
            }

            listState = dhcp_GetNextUpdateEntryFromList(
                            &pupEntry,
                            &waitTime );
    
            if ( g_fDhcpThreadStop )
            {
                FreeUpdateEntry( pupEntry );
                goto Termination;
            }
    
            //
            //  executable update => process it
            //
            //  DCR_QUESTION:  not clear that this terminates updates in the
            //                  purging updates case
            //
    
            if ( listState == REG_LIST_FOUND )
            {
                ProcessUpdateEntry( pupEntry, g_fPurgeRegistrations );
                continue;
            }
    
            //
            //  wait for queued retry 
            //      - break dequeue loop, and wait for wait time
            //
    
            else if ( listState == REG_LIST_WAIT
                    &&
                      ! g_fAtBoot &&
                      ! g_fPurgeRegistrations )
            {
                DNS_ASSERT( waitTime != 0 );
                break;
            }
    
            //
            //  falls here on:
            //  list empty
            //      OR
            //  retry wait, but still booting or purging
            //

            //  
            //  booting or purging
            //
            //  booting
            //      - do deregistrations of old adapters
            //      note that we won't get here until we've after we
            //      satisfy the initial boot wait AND we have made any
            //      initial update attempts and are either empty or
            //      have queued updates with retry timeouts
            //
            //  purging
            //      - whack old registrations
            //      - do deregistrations
            //
    
            else if ( (g_fAtBoot || g_fPurgeRegistrations)
                        &&
                      !g_fPurgeRegistrationsInitiated )
            {
                if ( g_fPurgeRegistrations )
                {
                    ResetAdaptersInRegistry();
                }
    
                //
                //  Remove any adapter configurations from the registry
                //  that were not processed. Do this by attempting to
                //  remove the related DNS records from the DNS server(s).
                //
    
                DeregisterUnusedAdapterInRegistry( g_fPurgeRegistrations );
    
                if ( g_fPurgeRegistrations )
                {
                    g_fPurgeRegistrationsInitiated = TRUE;
                }
                g_fAtBoot = FALSE;
                continue;
            }

            //
            //  self termination
            //      - emtpy
            //      - or purging and done purging
            //
            //  however we retry IF a queuing thread has set the "CheckBeforeExit"
            //  flag;  this prevents us from exiting with queuing thread thinking
            //  we will process the udpate
            //
            //  queuing thread
            //      - queues item (or sets some flag)
            //      - locks thread
            //      - set "check-before-exit" flag
            //      - sets wakeup event
            //      - unlocks
            //
            //  reg thread
            //      - checks queue
            //      - determines self-exit condition
            //      - locks
            //      - checks "check-before-exit" flag
            //          - if clear => exit (under thread lock)
            //          - if set => loop for retry (giving up lock)
            //
            //  this keeps us from proceeding directly to exit on empty queue and missing
            //  a queued update, which didn't start a new thread because we were still
            //  running;  essentially it's linking the queueing and thread issues which are
            //  otherwise under separate locks
            //

            LOCK_REG_THREAD();
            fthreadLock = TRUE;

            DNSDBG( DHCP, ( "dhcp_RegistrationThread - check self-exit\n" ));

            if ( g_fDhcpThreadStop ||
                 !g_fDhcpThreadCheckBeforeExit )
            {
                goto Termination;
            }

            g_fDhcpThreadCheckBeforeExit = FALSE;
            UNLOCK_REG_THREAD();
            fthreadLock = FALSE;
            continue;
        }
    }

Termination:

    DNSDBG( DHCP, ( "DHCP dhcp_RegistrationThread - terminating\n" ));
    ASYNCREG_F1( "dhcp_RegistrationThread - terminating" );
    ASYNCREG_F1( "" );

    if ( !fthreadLock )
    {
        LOCK_REG_THREAD();
    }

    g_fDhcpThreadRunning = FALSE;

    //
    //  cleanup update list
    //

    LOCK_REG_LIST();

    g_fAtBoot = FALSE;
    g_fPurgeRegistrations = FALSE;
    g_fPurgeRegistrationsInitiated = FALSE;

    FreeUpdateEntryList( &g_DhcpRegList );
    InitializeListHead( &g_DhcpRegList );

    UNLOCK_REG_LIST();

    //
    //  dump any cached security handles
    //

    Dns_TimeoutSecurityContextList( TRUE );

    //
    //  close thread handle if no one waiting
    //

    if ( g_hDhcpThread && g_DhcpThreadWaitCount == 0 )
    {
        CloseHandle( g_hDhcpThread );
        g_hDhcpThread = NULL;
    }

    //
    // Note that this thread is NOT running by setting a global flag
    //


    //
    // Now signal that we've finished
    //

    DNSDBG( DHCP, ( "DHCP dhcp_RegistrationThread - signalling ThreadDead event\n" ));
    ASYNCREG_F1( "dhcp_RegistrationThread - Signaling ThreadDeadEvent" );
    ASYNCREG_F1( "" );

    //  clear purge incase of later restart
    //g_fPurgeRegistrations = FALSE;
    // currently must go through Init routine which clears this flag

    UNLOCK_REG_THREAD();

    DNSDBG( DHCP, ( "DHCP dhcp_RegistrationThread - Finish" ));
    ASYNCREG_F1( "dhcp_RegistrationThread - Finished" );
    ASYNCREG_F1( "" );

    return NO_ERROR;
}


VOID
WriteUpdateEntryToRegistry(
    IN      PUPDATE_ENTRY   pUpdateEntry
    )
{
    HKEY    hkeyAdapter = NULL;
    DWORD   disposition;
    DWORD   status = ERROR_SUCCESS;
    DWORD   fregistered = 0;
    DWORD   flags = 0;
    PWSTR   pname;


    ASYNCREG_UPDATE_ENTRY(
        "Inside function WriteUpdateEntryToRegistry",
        pUpdateEntry );

    DNSDBG( TRACE, (
        "WriteUpdateEntryToRegistry( %p )\n",
        pUpdateEntry ));

    //
    //  write only add update
    //
    //  remove's should not be non-volatile as don't know anything
    //      about state when come back up
    //

    if ( !pUpdateEntry->fRemove )
    {
        if ( pUpdateEntry->fRegisteredFWD )
        {
            flags |= REGISTERED_FORWARD;
        }
        if ( pUpdateEntry->fRegisteredPRI )
        {
            flags |= REGISTERED_PRIMARY;
        }
        if ( pUpdateEntry->fRegisteredPTR )
        {
            flags |= REGISTERED_POINTER;
        }
        if ( flags )
        {
            fregistered = 1;
        }

        status = RegCreateKeyExW(
                        g_hDhcpRegKey,
                        pUpdateEntry->AdapterName,
                        0,
                        ADAPTER_NAME_CLASS,
                        REG_OPTION_NON_VOLATILE,   // options
                        KEY_READ | KEY_WRITE, // desired access
                        NULL,
                        &hkeyAdapter,
                        &disposition );
        if ( status )
        {
            goto Exit;
        }

        //  hostname

        pname = pUpdateEntry->HostName;
        if ( !pname )
        {
            DNS_ASSERT( FALSE );
            status = DNS_ERROR_INVALID_NAME;
            goto Exit;
        }

        status = RegSetValueExW(
                        hkeyAdapter,
                        DHCP_REGISTERED_HOST_NAME,
                        0,
                        REG_SZ,
                        (PBYTE) pname,
                        (wcslen(pname) + 1) * sizeof(WCHAR) );
        if ( status )
        {
            goto Exit;
        }

        //  adapter domain name

        pname = pUpdateEntry->DomainName;

        if ( !pname || !pUpdateEntry->fRegisteredFWD )
        {
            pname = L"";
        }

        status = RegSetValueExW(
                        hkeyAdapter,
                        DHCP_REGISTERED_DOMAIN_NAME,
                        0,
                        REG_SZ,
                        (PBYTE) pname,
                        (wcslen(pname) + 1) * sizeof(WCHAR)
                        );
        if ( status )
        {
            goto Exit;
        }

        //  primary domain name

        pname = pUpdateEntry->PrimaryDomainName;

        if ( !pname || !pUpdateEntry->fRegisteredPRI )
        {
            pname = L"";
        }

        status = RegSetValueExW(
                        hkeyAdapter,
                        PRIMARY_DOMAIN_NAME,
                        0,
                        REG_SZ,
                        (PBYTE) pname,
                        (wcslen(pname) + 1) * sizeof(WCHAR)
                        );
        if ( status )
        {
            goto Exit;
        }

        //  IP info

        RegSetValueExW(
                hkeyAdapter,
                DHCP_SENT_UPDATE_TO_IP,
                0,
                REG_DWORD,
                (PBYTE)&pUpdateEntry->SentUpdateToIp,
                sizeof(DWORD) );

        RegSetValueExW(
                hkeyAdapter,
                DHCP_SENT_PRI_UPDATE_TO_IP,
                0,
                REG_DWORD,
                (PBYTE)&pUpdateEntry->SentPriUpdateToIp,
                sizeof(DWORD) );

        RegSetValueExW(
                hkeyAdapter,
                DHCP_REGISTERED_TTL,
                0,
                REG_DWORD,
                (PBYTE)&pUpdateEntry->TTL,
                sizeof(DWORD) );

        RegSetValueExW(
                hkeyAdapter,
                DHCP_REGISTERED_FLAGS,
                0,
                REG_DWORD,
                (PBYTE) &flags,
                sizeof(DWORD) );

        //
        //  ignore error on the last two. Non critical
        //

        status = RegSetValueExW(
                        hkeyAdapter,
                        DHCP_REGISTERED_ADDRS,
                        0,
                        REG_BINARY,
                        (PBYTE) pUpdateEntry->HostAddrs,
                        pUpdateEntry->HostAddrCount *
                        sizeof(REGISTER_HOST_ENTRY) );
        if ( status )
        {
            goto Exit;
        }

        status = RegSetValueExW(
                        hkeyAdapter,
                        DHCP_REGISTERED_ADDRS_COUNT,
                        0,
                        REG_DWORD,
                        (PBYTE)&pUpdateEntry->HostAddrCount,
                        sizeof(DWORD) );
        if ( status )
        {
            goto Exit;
        }

        status = RegSetValueExW(
                        hkeyAdapter,
                        DHCP_REGISTERED_SINCE_BOOT,
                        0,
                        REG_DWORD,
                        (PBYTE)&fregistered,
                        sizeof(DWORD) );
        if ( status )
        {
            goto Exit;
        }

        if ( pUpdateEntry->DnsServerList )
        {
            status = RegSetValueExW(
                        hkeyAdapter,
                        DHCP_DNS_SERVER_ADDRS,
                        0,
                        REG_BINARY,
                        (PBYTE) pUpdateEntry->DnsServerList->AddrArray,
                        pUpdateEntry->DnsServerList->AddrCount * sizeof(IP4_ADDRESS)
                        );
            if ( status )
            {
                goto Exit;
            }

            status = RegSetValueExW(
                            hkeyAdapter,
                            DHCP_DNS_SERVER_ADDRS_COUNT,
                            0,
                            REG_DWORD,
                            (PBYTE) &pUpdateEntry->DnsServerList->AddrCount,
                            sizeof(DWORD) );
            if ( status )
            {
                goto Exit;
            }
        }
        else
        {
            DWORD count = 0;

            status = RegSetValueExW(
                            hkeyAdapter,
                            DHCP_DNS_SERVER_ADDRS_COUNT,
                            0,
                            REG_DWORD,
                            (PBYTE) &count,
                            sizeof(DWORD) );
            if ( status )
            {
                goto Exit;
            }

            status = RegSetValueExW(
                            hkeyAdapter,
                            DHCP_DNS_SERVER_ADDRS,
                            0,
                            REG_BINARY,
                            (PBYTE) NULL,
                            0 );
            if ( status )
            {
                goto Exit;
            }
        }

        RegCloseKey( hkeyAdapter );
        return;
    }

Exit:

    //
    //  remove or failure -- kill adapter key
    //

    RegDeleteKeyW( g_hDhcpRegKey, pUpdateEntry->AdapterName );

    if ( hkeyAdapter )
    {
        RegCloseKey( hkeyAdapter );
    }
}


PUPDATE_ENTRY
ReadUpdateEntryFromRegistry(
    IN      PWSTR           AdapterName
    )
{
    PREGISTER_HOST_ENTRY pHostAddrs = NULL;
    PUPDATE_ENTRY   pupEntry = NULL;
    DWORD           status = NO_ERROR;
    PWSTR           pregHostName = NULL;
    PWSTR           pregDomain = NULL;
    PWSTR           pregPrimary = NULL;
    IP4_ADDRESS     ipSentUpdateTo = 0;
    IP4_ADDRESS     ipSentPriUpdateTo = 0;
    DWORD           dwTTL = 0;
    DWORD           dwFlags = 0;
    DWORD           dwHostAddrCount = 0;
    DWORD           dwServerAddrCount = 0;
    PIP4_ADDRESS    pServerList = NULL;
    PWSTR           pdomain;
    PWSTR           pprimary;
    HKEY            hkeyAdapter = NULL;
    DWORD           dwType;
    DWORD           dwBytesRead = MAX_PATH -1;
    DWORD           dwBufferSize = 2048;
    BOOL            fRegFWD = FALSE;
    BOOL            fRegPRI = FALSE;
    BOOL            fRegPTR = FALSE;


    DNSDBG( TRACE, (
        "ReadUpdateEntryFromRegistry( %S )\n",
        AdapterName ));

    //
    //  implementation note
    //
    //  two different heaps here
    //      - g_DhcpRegHeap specific for this module
    //      - general DnsApi heap which all the stuff which is
    //      allocated by GetRegistryValue() is using
    //
    //  GetRegistryValue() uses ALLOCATE_HEAP() (general dnsapi heap)
    //  so all the stuff it creates must be freed by FREE_HEAP()
    //

    pHostAddrs = (PREGISTER_HOST_ENTRY) PHEAP_ALLOC( dwBufferSize );
    if ( !pHostAddrs )
    {
        goto Exit;
    }

    pServerList = (PIP4_ADDRESS) PHEAP_ALLOC( dwBufferSize );
    if ( !pServerList )
    {
        goto Exit;
    }

    status = RegOpenKeyExW(
                    g_hDhcpRegKey,
                    AdapterName,
                    0,
                    KEY_ALL_ACCESS,
                    &hkeyAdapter );
    if ( status )
    {
        hkeyAdapter = NULL;
        goto Exit;
    }

    //
    //  read each value in turn
    //

    //  note that registry flags are not the API flags but the
    //  flags denoting successful registration

    status = GetRegistryValue(
                    hkeyAdapter,
                    RegIdDhcpRegisteredFlags,
                    DHCP_REGISTERED_FLAGS,
                    REG_DWORD,
                    (PBYTE)&dwFlags );
    if ( status )
    {
        goto Exit;
    }
    fRegPRI = !!( dwFlags & REGISTERED_PRIMARY );
    fRegFWD = !!( dwFlags & REGISTERED_FORWARD );
    fRegPTR = !!( dwFlags & REGISTERED_POINTER );


    status = GetRegistryValue(
                    hkeyAdapter,
                    RegIdHostName,
                    DHCP_REGISTERED_HOST_NAME,
                    REG_SZ,
                    (PBYTE)&pregHostName );
    if ( status )
    {
        goto Exit;
    }

    if ( fRegPRI )
    {
        status = GetRegistryValue(
                        hkeyAdapter,
                        RegIdPrimaryDomainName,
                        PRIMARY_DOMAIN_NAME,
                        REG_SZ,
                        (PBYTE)&pregPrimary );
        if ( status )
        {
            goto Exit;
        }
    }

    if ( fRegFWD )
    {
        status = GetRegistryValue(
                        hkeyAdapter,
                        RegIdDhcpRegisteredDomainName,
                        DHCP_REGISTERED_DOMAIN_NAME,
                        REG_SZ,
                        (PBYTE)&pregDomain );
        if ( status )
        {
            goto Exit;
        }
    }


    status = GetRegistryValue(
                    hkeyAdapter,
                    RegIdDhcpSentUpdateToIp,
                    DHCP_SENT_UPDATE_TO_IP,
                    REG_DWORD,
                    (PBYTE)&ipSentUpdateTo );
    if ( status )
    {
        goto Exit;
    }

    status = GetRegistryValue(
                    hkeyAdapter,
                    RegIdDhcpSentPriUpdateToIp,
                    DHCP_SENT_PRI_UPDATE_TO_IP,
                    REG_DWORD,
                    (PBYTE)&ipSentPriUpdateTo );
    if ( status )
    {
        goto Exit;
    }

    status = GetRegistryValue(
                    hkeyAdapter,
                    RegIdDhcpRegisteredTtl,
                    DHCP_REGISTERED_TTL,
                    REG_DWORD,
                    (PBYTE)&dwTTL );
    if ( status )
    {
        goto Exit;
    }

    status = GetRegistryValue(
                    hkeyAdapter,
                    RegIdDhcpRegisteredAddressCount,
                    DHCP_REGISTERED_ADDRS_COUNT,
                    REG_DWORD,
                    (PBYTE)&dwHostAddrCount );
    if ( status )
    {
        goto Exit;
    }

    dwBytesRead = dwBufferSize;
    status = RegQueryValueEx(
                    hkeyAdapter,
                    DHCP_REGISTERED_ADDRS,
                    0,
                    &dwType,
                    (PBYTE)pHostAddrs,
                    &dwBytesRead );

    if ( status == ERROR_MORE_DATA )
    {
        PrivateHeapFree( pHostAddrs );

        pHostAddrs = (PREGISTER_HOST_ENTRY) PHEAP_ALLOC( dwBytesRead );
        if ( !pHostAddrs )
        {
            goto Exit;
        }
        status = RegQueryValueExW(
                        hkeyAdapter,
                        DHCP_REGISTERED_ADDRS,
                        0,
                        &dwType,
                        (PBYTE)pHostAddrs,
                        &dwBytesRead );
    }
    if ( status )
    {
        goto Exit;
    }

    if ( dwBytesRead/sizeof(REGISTER_HOST_ENTRY) < dwHostAddrCount )
    {
        goto Exit;
    }

    status = GetRegistryValue(
                    hkeyAdapter,
                    RegIdDhcpDnsServerAddressCount,
                    DHCP_DNS_SERVER_ADDRS_COUNT,
                    REG_DWORD,
                    (PBYTE)&dwServerAddrCount );
    if ( status )
    {
        dwServerAddrCount = 0;
    }

    if ( dwServerAddrCount )
    {
        dwBytesRead = dwBufferSize;

        status = RegQueryValueEx(
                    hkeyAdapter,
                    DHCP_DNS_SERVER_ADDRS,
                    0,
                    &dwType,
                    (PBYTE)pServerList,
                    &dwBytesRead );

        if ( status == ERROR_MORE_DATA )
        {
            PHEAP_FREE( pServerList );

            pServerList = (PIP4_ADDRESS) PHEAP_ALLOC( dwBytesRead );
            if ( !pServerList )
            {
                goto Exit;
            }
            status = RegQueryValueEx(
                        hkeyAdapter,
                        DHCP_DNS_SERVER_ADDRS,
                        0,
                        &dwType,
                        (PBYTE)pServerList,
                        &dwBytesRead );
        }
        if ( status )
        {
            goto Exit;
        }

        if ( dwBytesRead/sizeof(IP4_ADDRESS) < dwServerAddrCount )
        {
            goto Exit;
        }
    }
    else
    {
        pServerList = NULL;
    }

    //
    //  validate domain names non-empty
    //

    pdomain = pregDomain;
    if ( pdomain &&
         wcslen( pdomain ) == 0 )
    {
        pdomain = NULL;
    }

    pprimary = pregPrimary;
    if ( pprimary &&
         wcslen( pprimary ) == 0 )
    {
        pprimary = NULL;
    }

    status = AllocateUpdateEntry(
                    AdapterName,
                    pregHostName,
                    pdomain,
                    pprimary,
                    NULL,           // no alternate names
                    dwHostAddrCount,
                    pHostAddrs,
                    dwServerAddrCount,
                    pServerList,
                    ipSentUpdateTo,
                    ipSentPriUpdateTo,
                    dwTTL,
                    ( fRegPTR ) ? DYNDNS_REG_PTR : 0,
                    0,
                    Dns_GetCurrentTimeInSeconds(),
                    NULL,
                    &pupEntry );
    if ( status )
    {
        DNS_ASSERT( pupEntry == NULL );
        pupEntry = NULL;
        goto Exit;
    }

    pupEntry->fFromRegistry     = TRUE;
    pupEntry->fRegisteredFWD    = fRegFWD;
    pupEntry->fRegisteredPRI    = fRegPRI;
    pupEntry->fRegisteredPTR    = fRegPTR;


Exit:

    //
    //  cleanup
    //      - close registry
    //      - dump local data
    //

    if ( hkeyAdapter )
    {
        RegCloseKey( hkeyAdapter );
    }

    PrivateHeapFree( pHostAddrs );
    PrivateHeapFree( pServerList );

    FREE_HEAP( pregHostName );
    FREE_HEAP( pregDomain );
    FREE_HEAP( pregPrimary );
    
    //  set return value

    ASYNCREG_UPDATE_ENTRY(
        "Leaving ReadUpdateEntryFromRegistry:",
        pupEntry );

    IF_DNSDBG( TRACE )
    {
        DnsDbg_UpdateEntry(
            "Leave ReadUpdateEntryFromRegistry():",
            pupEntry );
    }

    return  pupEntry;
}


VOID
MarkAdapterAsPendingUpdate(
    IN      PWSTR           AdapterName
    )
{
    DWORD   status = NO_ERROR;
    DWORD   fregistered = 1;
    HKEY    hkeyAdapter = NULL;

    DNSDBG( TRACE, (
        "MarkAdapterAsPendingUpdate( %S )\n",
        AdapterName ));

    status = RegOpenKeyExW(
                g_hDhcpRegKey,
                AdapterName,
                0,
                KEY_ALL_ACCESS,
                &hkeyAdapter );
    if ( status )
    {
        return;
    }

    RegSetValueExW(
        hkeyAdapter,
        DHCP_REGISTERED_SINCE_BOOT,
        0,
        REG_DWORD,
        (PBYTE) &fregistered,
        sizeof(DWORD) );

    RegCloseKey( hkeyAdapter );
}



//
//  Update entry processing
//

DNS_STATUS
DoRemoveUpdate(
    IN OUT  PUPDATE_ENTRY   pRemoveEntry,
    IN OUT  PDNS_RECORD     pRemoveRecord,
    IN      UPTYPE          UpType
    )
/*++

Routine Description:

    Do a remove update.

    Helper routine for DoUpdate().
    Routine simply avoids duplicate code as this is called
    with both registry entry and with update entry.

Arguments:

    pRemoveEntry -- entry to remove, from update or registry

    pRemoveRecord -- record to remove

    fPrimary -- TRUE for primary update;  FALSE otherwise

Return Value:

    DNS or Win32 error code.

--*/
{
    DNS_STATUS      status = NO_ERROR;
    DNS_EXTRA_INFO  results;

    DNSDBG( TRACE, (
        "DoRemoveUpdate( %p, %p, %d )\n",
        pRemoveEntry,
        pRemoveRecord,
        UpType
        ));

    //
    //  try remove
    //      - don't track failure, this is a one shot deal before
    //      adapter goes down
    //

    RtlZeroMemory( &results, sizeof(results) );
    results.Id = DNS_EXINFO_ID_RESULTS_BASIC;

    status = DnsModifyRecordsInSet_W(
                    NULL,               // no add records
                    pRemoveRecord,      // delete records
                    DNS_UPDATE_CACHE_SECURITY_CONTEXT,
                    NULL,               // no context handle
                    (PIP4_ARRAY) pRemoveEntry->DnsServerList,
                    & results
                    );

    SetUpdateStatus(
        pRemoveEntry,
        & results,
        UpType );

    if ( IS_UPTYPE_PRIMARY(UpType) )
    {
        LogRegistration(
            pRemoveEntry,
            status,
            UpType,
            TRUE,       // deregistration
            0,          // default server IP
            0           // default update IP
            );
    }

#if 0
    //  doing entire update entry PTR dereg at once
    //  in ProcessUpdate() once done
    //
    //  deregister the PTR records
    //

    if ( (pRemoveEntry->Flags & DYNDNS_REG_PTR) &&
         g_RegisterReverseLookup )
    {
        UpdatePtrRecords(
            pRemoveEntry,
            FALSE           // remove records
            );
    }
#endif

    return  status;
}



DNS_STATUS
ModifyAdapterRegistration(
    IN      PUPDATE_ENTRY   pUpdateEntry,
    IN      PUPDATE_ENTRY   pRegistryEntry,
    IN      PDNS_RECORD     pUpdateRecord,
    IN      PDNS_RECORD     pRegRecord,
    IN      UPTYPE          UpType
    )
{
    DNS_STATUS      status = NO_ERROR;
    PDNS_RECORD     potherRecords = NULL;
    PDNS_RECORD     pupdateRecords = NULL;
    IP4_ADDRESS     serverIp = 0;
    DNS_EXTRA_INFO  results;

    DNSDBG( TRACE, (
        "ModifyAdapterRegistration()\n"
        "\tpUpdateEntry     = %p\n"
        "\tpUpdateRecords   = %p\n"
        "\tpRegistryEntry   = %p\n"
        "\tpRegistryRecords = %p\n"
        "\tfPrimary         = %d\n",
        pUpdateEntry,
        pRegistryEntry,
        pUpdateRecord,
        pRegRecord,
        UpType ));

    //
    //  multi-adapter registration test
    //
    //  check other adapters for registrations on the same name
    //  if found, include in updates
    //

    potherRecords = GetPreviousRegistrationInformation(
                        pUpdateEntry,
                        UpType,
                        &serverIp );
    if ( potherRecords )
    {
        DNSDBG( DHCP, (
            "Have registry update data for other adapters!\n"
            "\tCreating combined update record sets.\n" ));

        pupdateRecords = CreateDnsRecordSetUnion(
                                pUpdateRecord,
                                potherRecords );
        if ( !pupdateRecords )
        {
            DNSDBG( ANY, (
                "ERROR:  failed to build combined record set for update!\n" ));
            status = DNS_ERROR_NO_MEMORY;
            goto Exit;
        }

        //  DCR:  temp hack to avoid multiple updates

        serverIp = 0;
    }
    else
    {
        DNS_ASSERT( serverIp == 0 );
        serverIp = 0;
    }

    //
    //  check if registry info is stale and needs delete
    //      - name has changed and not to another name that we register
    //          (this protects against adapter\primary change or
    //          primary\alternate change on domain rename)
    //      - update was to different set of servers than we'd hit this time
    //      (HMM -- should i even care?)
    //

    if ( pRegRecord
            &&
         (  ( ! Dns_NameCompare_W(
                    pRegRecord->pName,
                    pUpdateRecord->pName )
                    &&
              ! IsAnotherUpdateName(
                    pUpdateEntry,
                    pRegRecord->pName,
                    UpType ) )
                ||
            ! CompareMultiAdapterSOAQueries(
                pUpdateRecord->pName,
                pUpdateEntry->DnsServerList,
                pRegistryEntry->DnsServerList ) ) )
    {
        //
        // The record found in the registry for this adapter
        // is stale and should be deleted. Otherwise we set the
        // current list of records to only that of potherRecords.
        //
        ASYNCREG_F1( "DoUpdateForPrimaryName - Found stale registry entry:" );
        ASYNCREG_F2( "   Name : %S", pRegRecord->pName );
        ASYNCREG_F1( "   Address :" );
        DNSLOG_IP4_ADDRESS( 1, &(pRegRecord->Data.A.IpAddress) );
        ASYNCREG_F1( "" );
        ASYNCREG_F1( "   Calling DnsRemoveRecords_W to get rid of it" );

        status = DnsModifyRecordsInSet_W(
                        NULL,           // no add records
                        pRegRecord,     // delete records
                        DNS_UPDATE_CACHE_SECURITY_CONTEXT,
                        NULL,           // no context handle
                        (PIP4_ARRAY) pRegistryEntry->DnsServerList,
                        NULL            // reserved
                        );

        ASYNCREG_F3( "   DnsModifyRecordsInSet_W delete returned: 0x%x\n\t%s",
                     status,
                     Dns_StatusString( status ) );
    }

    //
    //  replace records with new data
    //
    //  replace in loop
    //      - first try specific servers (if have any)
    //      - then try adapters servers
    //

    ASYNCREG_F1( "ModifyAdapterRegistration - Calling DnsReplaceRecordSet_W" );
    ASYNCREG_F1( "    (current update + previous records)" );

    status = NO_ERROR;

    while ( 1 )
    {
        IP4_ARRAY   ipArray;
        PIP4_ARRAY  pservList;

        if ( serverIp )
        {
            ASYNCREG_F1( "    (sending update to specific server)" );

            ipArray.AddrCount = 1;
            ipArray.AddrArray[0] = serverIp;
            pservList = &ipArray;
        }
        else
        {
            ASYNCREG_F1( "    (sending update to adapter server list)" );

            pservList = (PIP4_ARRAY) pUpdateEntry->DnsServerList;
        }
        DNSLOG_IP4_ARRAY( pservList );

        //  setup update results blob

        RtlZeroMemory( &results, sizeof(results) );
        results.Id = DNS_EXINFO_ID_RESULTS_BASIC;

        status = DnsReplaceRecordSetW(
                        pupdateRecords ? pupdateRecords : pUpdateRecord,
                        DNS_UPDATE_CACHE_SECURITY_CONTEXT,
                        NULL,                   // no security context
                        pservList,
                        & results
                        );

        ASYNCREG_F3( "   DnsReplaceRecordSet_W returned: 0x%x\n\t%s",
                     status,
                     Dns_StatusString( status ) );

        if ( !serverIp || status != ERROR_TIMEOUT )
        {
            break;
        }
        //  clear serverIp to do update to adapter servers
        //  serverIp serves as flag to terminate loop

        serverIp = 0;
    }

    //
    //  save success info
    //

    SetUpdateStatus(
        pUpdateEntry,
        & results,
        UpType );

Exit:

    Dns_RecordListFree( potherRecords );
    Dns_RecordListFree( pupdateRecords );

    return status;
}



DNS_STATUS
DoModifyUpdate(
    IN OUT  PUPDATE_ENTRY   pUpdateEntry,
    IN OUT  PDNS_RECORD     pUpdateRecord,
    IN      PUPDATE_ENTRY   pRegistryEntry,     OPTIONAL
    IN OUT  PDNS_RECORD     pRegRecord,         OPTIONAL
    IN      UPTYPE          UpType
    )
/*++

Routine Description:

    Standard modify registration.

    Helper routine for DoUpdate.
    This handles modify for typical non-remove case.
        - Forward records updated
        - Old PTR removed if new address.
        - New PTR added (or name modified).

Arguments:

    pUpdateEntry    -- update entry

    pUpdateRecord   -- records for update

    pRegistryEntry  -- registry entry

    pRegRecord      -- records from registry entry

    UpType          -- update type

Return Value:

    DNS or Win32 error code.

--*/
{
    DNS_STATUS      status = NO_ERROR;
    IP4_ADDRESS     ip = 0;
    BOOL            fregistered = FALSE;

    DNSDBG( TRACE, (
        "DoModifyUpdate()\n"
        "\tUpdateEntry  = %p\n"
        "\tUpType       = %d\n",
        pUpdateEntry,
        UpType ));

    DNS_ASSERT( pUpdateEntry != NULL );
    DNS_ASSERT( pUpdateRecord != NULL );

    //
    //  do forward registration modify
    //
    //  DCR:  multi-adapter alternates will require pass

    status = ModifyAdapterRegistration(
                    pUpdateEntry,       // add
                    pRegistryEntry,     // remove
                    pUpdateRecord,
                    pRegRecord,
                    UpType
                    );

    //
    //  PTR records
    //
    //  deregister previous PTR registration
    //      - registry entry indicates previous registration
    //      - not the same address as current (otherwise it's an update)
    //
    //  note:  adding new registration takes place in DoUpdate() once
    //      ALL forward updates are complete
    //

    if ( g_RegisterReverseLookup )
    {
        if ( pRegistryEntry &&
             (pRegistryEntry->Flags & DYNDNS_REG_PTR) &&
             !compareUpdateEntries( pRegistryEntry, pUpdateEntry ) )
        {
            UpdatePtrRecords(
                pRegistryEntry,
                FALSE           // remove previous PTR
                );
        }
    }

    //
    //  Log registration status in EventLog
    //

    if ( pUpdateEntry->RetryCount == 0 )
    {
        LogRegistration(
            pUpdateEntry,
            status,
            UpType,
            FALSE,      // registration
            0,          // default server IP
            0           // default update IP
            );
    }

    DNSDBG( TRACE, (
        "Leave DoModifyUpdate() => %d\n",
        status ));

    return status;
}



DNS_STATUS
DoUpdate(
    IN OUT  PUPDATE_ENTRY   pRegistryEntry  OPTIONAL,
    IN OUT  PUPDATE_ENTRY   pUpdateEntry,
    IN      UPTYPE          UpType
    )
/*++

Routine Description:

    Do update for a particular name.

    Helper routine for ProcessUpdate().
    Handles one name, called separately for AdapaterDomainName and
    PrimaryDomainName.

Arguments:

    pUpdateEntry    -- update entry

    pRegistryEntry  -- registry entry

    fPrimary        -- TRUE if update for primary domain name
                       FALSE for adapter domain name

Return Value:

    DNS or Win32 error code.

--*/
{
    PDNS_RECORD     prrRegistry = NULL;
    PDNS_RECORD     prrUpdate = NULL;
    DNS_STATUS      status = NO_ERROR;

    ASYNCREG_UPDATE_ENTRY(
        "DoUpdate() -- UpdateEntry:",
        pUpdateEntry );
    ASYNCREG_UPDATE_ENTRY(
        "DoUpdate() -- RegistryEntry:",
        pRegistryEntry );

    DNSDBG( TRACE, (
        "DoUpdate() type = %d\n",
        UpType ));

    IF_DNSDBG( TRACE )
    {
        DnsDbg_UpdateEntry(
            "DoUpdate() -- UpdateEntry:",
            pUpdateEntry );
        DnsDbg_UpdateEntry(
            "DoUpdate() -- RegistryEntry:",
            pRegistryEntry );
    }
    DNS_ASSERT( pUpdateEntry != NULL );

    //
    //  build records from update entrys
    //

    prrUpdate = CreateForwardRecords(
                        pUpdateEntry,
                        UpType
                        );
    if ( ! prrUpdate )
    {
        DNSDBG( TRACE, (
            "No forward records created for update entry (%p) for update type %d!",
            pUpdateEntry,
            UpType ));
        return NO_ERROR;
    }

    if ( pRegistryEntry )
    {
        prrRegistry = CreateForwardRecords(
                            pRegistryEntry,
                            UpType
                            );
        DNS_ASSERT( !IS_UPTYPE_ALTERNATE(UpType) || prrRegistry==NULL );
    }

    //
    //  remove?
    //      - remove previous registry entry if exists
    //      - remove update entry
    //

    if ( pUpdateEntry->fRemove )
    {
        if ( prrRegistry )
        {
            //  we don't lookup registry entries on fRemove updates, so i
            //      don't see how we'd get here

            DNS_ASSERT( FALSE );

            DoRemoveUpdate(
                pRegistryEntry,
                prrRegistry,
                UpType );
        }
        status = DoRemoveUpdate(
                    pUpdateEntry,
                    prrUpdate,
                    UpType );
    }

    //
    //  add\modify registration
    //

    else
    {
        status = DoModifyUpdate(
                    pUpdateEntry,
                    prrUpdate,
                    pRegistryEntry,
                    prrRegistry,
                    UpType
                    );
    }

    //
    //  cleanup records
    //

    Dns_RecordListFree( prrRegistry );
    Dns_RecordListFree( prrUpdate );

    return  status;
}



BOOL
IsQuickRetryError(
    IN      DNS_STATUS      Status
    )
{
    return( Status != NO_ERROR
                &&
            (   Status == DNS_ERROR_RCODE_REFUSED ||
                Status == DNS_ERROR_RCODE_BADSIG ||
                Status == DNS_ERROR_RCODE_SERVER_FAILURE ||
                Status == DNS_ERROR_TRY_AGAIN_LATER ||
                Status == DNS_ERROR_NO_DNS_SERVERS ||
                Status == WSAECONNREFUSED ||
                Status == WSAETIMEDOUT ||
                Status == ERROR_TIMEOUT ) );

}



VOID
ProcessUpdateEntry(
    IN OUT  PUPDATE_ENTRY   pUpdateEntry,
    IN      BOOL            fPurgeMode
    )
/*++

Routine Description:

    Main routine processing an update.

Arguments:

    pUpdateEntry    -- update entry to execute
        note:  this routine frees pUpdateEntry when complete

    fPurgeMode      -- TRUE if purging update queue

Return Value:

    DNS or Win32 error code.

--*/
{
    DNS_STATUS      status;
    DNS_STATUS      statusPri = NO_ERROR;
    DNS_STATUS      statusAdp = NO_ERROR;
    DNS_STATUS      statusAlt = NO_ERROR;
    PUPDATE_ENTRY   pregEntry = NULL;


    DNSDBG( TRACE, (
        "\n\n"
        "ProcessUpdateEntry( %p, purge=%d )\n",
        pUpdateEntry,
        fPurgeMode ));

    IF_DNSDBG( DHCP )
    {
        DnsDbg_UpdateEntry(
            "Entering ProcessUpdateEntry():",
            pUpdateEntry );
    }

    //
    //  add (not remove)
    //

    if ( !pUpdateEntry->fRemove )
    {
        //  no adds during purge mode

        if ( fPurgeMode )
        {
            goto Cleanup;
        }

        //
        //  get any prior update info from registry
        //
        //  if hostname change, then delete on prior update
        //

        pregEntry = ReadUpdateEntryFromRegistry( pUpdateEntry->AdapterName );
        if ( pregEntry )
        {
            if ( ! Dns_NameCompare_W(
                        pregEntry->HostName,
                        pUpdateEntry->HostName ) )
            {
                DNSDBG( TRACE, (
                    "Prior registry data with non-matching hostname!\n"
                    "\tqueuing delete for prior data and doing standard add.\n" ));

                //
                //  create delete update for old info
                //

                pregEntry->fRemove = TRUE;
                pregEntry->Flags |= DYNDNS_DEL_ENTRY;
                pregEntry->fRegisteredFWD = FALSE;
                pregEntry->fRegisteredPRI = FALSE;
                pregEntry->fRegisteredPTR = FALSE;

                if ( fPurgeMode )
                {
                    pregEntry->RetryCount = 0;
                    pregEntry->RetryTime = Dns_GetCurrentTimeInSeconds();
                }

                //  clear registry entry

                WriteUpdateEntryToRegistry( pregEntry );

                //
                //  equeue remote update
                //      - clear registry entry PTR so not used below
                //
                //  but ONLY if old name(s) are NOT in alternate names
                //      (in rename scenario it can end up there)
                //

                if ( pUpdateEntry->AlternateNames
                        &&
                     ( IsAnotherUpdateName(
                          pUpdateEntry,
                          pregEntry->pAdapterFQDN,
                          UPTYPE_ADAPTER )
                            ||
                       IsAnotherUpdateName(
                          pUpdateEntry,
                          pregEntry->pPrimaryFQDN,
                          UPTYPE_PRIMARY ) ) )
                {
                    FreeUpdateEntry( pregEntry );
                }
                else
                {
                    enqueueUpdate( pregEntry );
                }
                pregEntry = NULL;

                //  fall through to do standard add update with no prior data
            }
        }
    }

    //
    //  do updates
    //      - primary
    //      - adapter domain
    //      - alternate name
    //

    if ( ! pUpdateEntry->fRegisteredFWD )
    {
        pUpdateEntry->pUpdateName = pUpdateEntry->pAdapterFQDN;

        statusAdp = DoUpdate(
                        pregEntry,
                        pUpdateEntry,
                        UPTYPE_ADAPTER
                        );
    }
    if ( ! pUpdateEntry->fRegisteredPRI )
    {
        pUpdateEntry->pUpdateName = pUpdateEntry->pPrimaryFQDN;

        statusPri = DoUpdate(
                        pregEntry,
                        pUpdateEntry,
                        UPTYPE_PRIMARY  // primary update
                        );
    }
    if ( ! pUpdateEntry->fRegisteredALT )
    {
        PWSTR       pname = pUpdateEntry->AlternateNames;
        DNS_STATUS  statusTmp;

        //
        //  update each alternate name in MULTISZ
        //      - must set index in update blob to use correct name in
        //          record building
        //      - any failure fails ALT names
        //

        statusAlt = NO_ERROR;

        while ( pname )
        {
            DNSDBG( DHCP, (
                "Update with alternate name %S\n",
                pname ));

            pUpdateEntry->pUpdateName = pname;

            statusTmp = DoUpdate(
                            NULL,           // not saving alternate info in registry
                            //  pregEntry,
                            pUpdateEntry,
                            UPTYPE_ALTERNATE
                            );
            if ( statusTmp != NO_ERROR )
            {
                statusAlt = statusTmp;
            }
            pname = MultiSz_NextString_W( pname );
        }
        pUpdateEntry->fRegisteredALT = (statusAlt == NO_ERROR);
    }

    pUpdateEntry->pUpdateName = NULL;

    //
    //  update PTRs once forward done
    //
    //  doing this outside DoUpdate() because will ONLY do PTRs
    //  for forwards that succeed, so want all forward updates
    //  completed first;  but this also helps in that it combines
    //  the reverse updates
    //

    if ( (pUpdateEntry->Flags & DYNDNS_REG_PTR) &&
         g_RegisterReverseLookup )
    {
        UpdatePtrRecords(
            pUpdateEntry,
            !pUpdateEntry->fRemove  // add update
            );
    }

    //
    //  write completed update info to registry
    //

    if ( !pUpdateEntry->fRemove )
    {
        WriteUpdateEntryToRegistry( pUpdateEntry );
    }

    //
    //  setup retry on failure
    //

    if ( statusPri != NO_ERROR )
    {
        status = statusPri;
        goto ErrorRetry;
    }
    else if ( statusAdp != NO_ERROR )
    {
        status = statusAdp;
        goto ErrorRetry;
    }
    else if ( statusAlt != NO_ERROR )
    {
        status = statusAlt;
        goto ErrorRetry;
    }

    //
    //  successful update
    //      - signal update event (if given)
    //      - cleanup if remove or purging
    //      - requeue if add
    //

    if ( pUpdateEntry->pRegisterStatus )
    {
        registerUpdateStatus( pUpdateEntry->pRegisterStatus, ERROR_SUCCESS );
    }

    if ( pUpdateEntry->fRemove || fPurgeMode || g_fPurgeRegistrations )
    {
        DNSDBG( TRACE, (
            "Leaving ProcessUpdate() => successful remove\\purge.\n" ));
        goto Cleanup;
    }
    else
    {
        pUpdateEntry->fNewElement           = FALSE;
        pUpdateEntry->fRegisteredFWD        = FALSE;
        pUpdateEntry->fRegisteredPRI        = FALSE;
        pUpdateEntry->fRegisteredPTR        = FALSE;
        pUpdateEntry->RetryCount            = 0;
        pUpdateEntry->RetryTime             = Dns_GetCurrentTimeInSeconds() +
                                                g_RegistrationRefreshInterval;
        if ( pUpdateEntry->pRegisterStatus )
        {
            pUpdateEntry->pRegisterStatus = NULL;
        }
        enqueueUpdate( pUpdateEntry );

        DNSDBG( TRACE, (
            "Leaving ProcessUpdate( %p ) => successful => requeued.\n",
            pUpdateEntry ));

        pUpdateEntry = NULL;
        goto Cleanup;
    }


ErrorRetry:


    //  failures during purge mode are not retried
    //  just free entry and bail

    if ( fPurgeMode || g_fPurgeRegistrations )
    {
        DNSDBG( TRACE, (
            "Leaving ProcessUpdate() => failed purging.\n" ));
        goto Cleanup;
    }

    //
    //  set retry time
    //
    //  less than two retries and more transient errors
    //      => short retry
    //
    //  third failure or longer term error code
    //      => push retry back to an hour
    //

    {
        DWORD   retryInterval;
        DWORD   currentTime = Dns_GetCurrentTimeInSeconds();
        DWORD   retryCount = pUpdateEntry->RetryCount;
    
        if ( retryCount < 2
                &&
             (  IsQuickRetryError(statusAdp) ||
                IsQuickRetryError(statusPri) ||
                IsQuickRetryError(statusAlt) ) )
        {
            retryInterval = (pUpdateEntry->RetryCount == 1)
                                ? FIRST_RETRY_INTERVAL
                                : SECOND_RETRY_INTERVAL;
        }
        else
        {
            retryInterval = FAILED_RETRY_INTERVAL;
    
            if ( pUpdateEntry->pRegisterStatus )
            {
                registerUpdateStatus( pUpdateEntry->pRegisterStatus, status );
                pUpdateEntry->pRegisterStatus = NULL;
            }
        }

        //
        //  reset retry time and count
        //
        //  count goes up, BUT reset count once a day, so that error logging can
        //  be done once a day, if you're still failing
        //
        //  DCR:  better retry tracking
        //      obvious retry\logging fixup is to have necessary info kept per
        //      update name\type (PDN, Adapter, Alt, Ptr), tracking failure
        //      status, retry info for each so can determine when to retry
        //      and what to log
        //

        if ( retryCount == 0 )
        {
            pUpdateEntry->BeginRetryTime = currentTime;
        }
        retryCount++;
    
        if ( pUpdateEntry->BeginRetryTime + RETRY_COUNT_RESET < currentTime )
        {
            pUpdateEntry->BeginRetryTime = currentTime;
            retryCount = 0;
        }
        pUpdateEntry->RetryCount = retryCount;
        pUpdateEntry->RetryTime = currentTime + retryInterval;
        pUpdateEntry->fNewElement = FALSE;
    }

    //
    //  requeue
    //      - entry dumped if another update for adapter already queued
    //

    enqueueUpdateMaybe( pUpdateEntry );

    DNSDBG( TRACE, (
        "Leaving ProcessUpdate( %p ) => failed => requeued.\n",
        pUpdateEntry ));

    pUpdateEntry = NULL;


Cleanup:

    //
    //  cleanup
    //      - registry entry
    //      - update entry if not requeued
    //

    FreeUpdateEntry( pregEntry );
    FreeUpdateEntry( pUpdateEntry );
}


VOID
ResetAdaptersInRegistry(
    VOID
    )
{
    DWORD   retVal = NO_ERROR;
    DWORD   status = NO_ERROR;
    WCHAR   szName[ MAX_PATH ];
    HKEY    hkeyAdapter = NULL;
    DWORD   dwType;
    INT     index;
    DWORD   dwBytesRead = MAX_PATH -1;
    DWORD   fregistered = 0;

    ASYNCREG_F1( "Inside function ResetAdaptersInRegistry" );
    ASYNCREG_F1( "" );

    index = 0;

    while ( !retVal )
    {
        dwBytesRead = MAX_PATH - 1;

        retVal = RegEnumKeyEx(
                        g_hDhcpRegKey,
                        index,
                        szName,
                        &dwBytesRead,
                        NULL,
                        NULL,
                        NULL,
                        NULL );
        if ( retVal )
        {
            goto Exit;
        }

        status = RegOpenKeyEx( g_hDhcpRegKey,
                               szName,
                               0,
                               KEY_ALL_ACCESS,
                               &hkeyAdapter );
        if ( status )
        {
            goto Exit;
        }

        //
        // Found an adapter in the registry, set registered since
        // boot to FALSE.
        //
        status = RegSetValueEx(
                        hkeyAdapter,
                        DHCP_REGISTERED_SINCE_BOOT,
                        0,
                        REG_DWORD,
                        (PBYTE)&fregistered, // 0 - False
                        sizeof(DWORD) );
        if ( status )
        {
            goto Exit;
        }

        RegCloseKey( hkeyAdapter );
        hkeyAdapter = NULL;
        index++;
    }

Exit :

    if ( hkeyAdapter )
    {
        RegCloseKey( hkeyAdapter );
    }
}


VOID
DeregisterUnusedAdapterInRegistry(
    IN      BOOL            fPurgeMode
    )
{
    DWORD           retVal = NO_ERROR;
    DWORD           status = NO_ERROR;
    WCHAR           szName[MAX_PATH];
    HKEY            hkeyAdapter = NULL;
    INT             index;
    DWORD           dwBytesRead = MAX_PATH -1;
    DWORD           fregistered = 0;
    PUPDATE_ENTRY   pregEntry = NULL;

    ASYNCREG_F1( "Inside function DeregisterUnusedAdapterInRegistry" );
    ASYNCREG_F1( "" );

    index = 0;

    while ( !retVal )
    {
        dwBytesRead = MAX_PATH - 1;
        retVal = RegEnumKeyExW(
                        g_hDhcpRegKey,
                        index,
                        szName,
                        &dwBytesRead,
                        NULL,
                        NULL,
                        NULL,
                        NULL );

        if ( retVal != ERROR_SUCCESS )
        {
            goto Exit;
        }

        status = RegOpenKeyExW(
                        g_hDhcpRegKey,
                        szName,
                        0,
                        KEY_ALL_ACCESS,
                        &hkeyAdapter );

        if ( status != ERROR_SUCCESS )
        {
            goto Exit;
        }

        //
        // Found an adapter in the registry, read registered since
        // boot value to see if FALSE.
        //
        status = GetRegistryValue(
                        hkeyAdapter,
                        RegIdDhcpRegisteredSinceBoot,
                        DHCP_REGISTERED_SINCE_BOOT,
                        REG_DWORD,
                        (PBYTE)&fregistered );

        RegCloseKey( hkeyAdapter );
        hkeyAdapter = NULL;

        if ( status != ERROR_SUCCESS )
        {
            goto Exit;
        }

        if ( fregistered == 0 &&
             (pregEntry = ReadUpdateEntryFromRegistry( szName )) )
        {
            if ( pregEntry->fRegisteredFWD ||
                 pregEntry->fRegisteredPRI ||
                 pregEntry->fRegisteredPTR )
            {
                ASYNCREG_F2( "Found unused adapter: %S", szName );
                ASYNCREG_F1( "Removing entry from registry and adding" );
                ASYNCREG_F1( "delete entry to registration list" );

                //
                // This adapter has not been configured since boot time,
                // create delete update entry for registry information
                // and add to registration list. Clear registry in the
                // mean time.
                //
                pregEntry->fRemove = TRUE;
                pregEntry->Flags |= DYNDNS_DEL_ENTRY;

                pregEntry->fRegisteredFWD = FALSE;
                pregEntry->fRegisteredPRI = FALSE;
                pregEntry->fRegisteredPTR = FALSE;

                if ( fPurgeMode )
                {
                    pregEntry->RetryCount = 0;
                    pregEntry->RetryTime = Dns_GetCurrentTimeInSeconds();
                }

                //
                // Clear registry key for adapter
                //
                WriteUpdateEntryToRegistry( pregEntry );
                index--;

                //
                // Put update in registration list
                //
                enqueueUpdate( pregEntry );

                PulseEvent( g_hDhcpWakeEvent );
            }
            else
            {
                ASYNCREG_F2( "Found unused adapter: %S", szName );
                ASYNCREG_F1( "This adapter is still pending an update, ignoring . . ." );

                //
                // We are only just starting to try to update this entry.
                // Do not queue up a delete for it since the entry shows
                // that no records have been registered anyhow.
                //

                FreeUpdateEntry( pregEntry );
                pregEntry = NULL;
            }
        }

        index++;
    }

Exit :

    if ( hkeyAdapter )
    {
        RegCloseKey( hkeyAdapter );
    }
}


PDNS_RECORD
GetPreviousRegistrationInformation(
    IN      PUPDATE_ENTRY   pUpdateEntry,
    IN      UPTYPE          UpType,
    OUT     PIP4_ADDRESS    pServerIp
    )
{
    DWORD           retVal = NO_ERROR;
    DWORD           status = NO_ERROR;
    WCHAR           szName[ MAX_PATH+1 ];
    INT             index;
    DWORD           bytesRead = MAX_PATH;
    DWORD           fregistered = 0;
    PUPDATE_ENTRY   pregEntry = NULL;
    PDNS_RECORD     precords = NULL;
    PWSTR           pdomain = NULL;

    DNSDBG( TRACE, (
        "GetPreviousRegistrationInformation( %p )\n",
        pUpdateEntry ));


    //
    //  determine desired domain name to use
    //
    //  DCR:  to handle multi-adapter alternate names, this
    //      would have to be updated to handle FQDN
    //

    if ( IS_UPTYPE_PRIMARY(UpType) )
    {
        pdomain = pUpdateEntry->PrimaryDomainName;
    }
    else if ( IS_UPTYPE_ADAPTER(UpType) )
    {
        pdomain = pUpdateEntry->DomainName;
    }
    else
    {
        //  currently no-op
    }
    if ( !pdomain )
    {
        goto Exit;
    }

    index = 0;

    while ( !retVal )
    {
        BOOL    fdomainMatch = FALSE;
        BOOL    fprimaryMatch = FALSE;

        bytesRead = MAX_PATH;

        retVal = RegEnumKeyEx(
                        g_hDhcpRegKey,
                        index,
                        szName,
                        & bytesRead,
                        NULL,
                        NULL,
                        NULL,
                        NULL );
        if ( retVal )
        {
            goto Exit;
        }
        index++;

        //
        //  read adapter's reg info
        //      - skip this adapter's info
        //

        if ( !_wcsicmp( szName, pUpdateEntry->AdapterName ) )
        {
            continue;
        }

        pregEntry = ReadUpdateEntryFromRegistry( szName );
        if ( !pregEntry )
        {
            DNSDBG( DHCP, (
                "ERROR:  unable to get registry update info for %S\n",
                szName ));
            continue;  
        }

        //
        //  check for register name match
        //      - same hostname and
        //      - either domain or PDN
        //

        if ( Dns_NameCompare_W(
                    pregEntry->HostName,
                    pUpdateEntry->HostName ) )
        {
            fdomainMatch = Dns_NameCompare_W(
                                pregEntry->DomainName,
                                pdomain );
            if ( !fdomainMatch )
            {
                fprimaryMatch = Dns_NameCompare_W(
                                    pregEntry->PrimaryDomainName,
                                    pdomain );
            }
        }

        if ( fdomainMatch || fprimaryMatch )
        {
            //
            // PHASE 1 - COMPARE SOAS FROM REGISTRY AND UPDATE ENTRIES
            //           IF SAME, ADD TO LIST. ELSE, TOSS.
            //
            // PHASE 2 - COMPARE NS RECORDS FROM BOTH ENTRIES
            //           IF SAME ZONE AND SERVER, ADD TO LIST. ELSE, TOSS.
            //
            // PHASE 3 - COMPARE NS RECORDS FROM BOTH ENTRIES
            //           IF SAME ZONE AND THERE IS AN INTERSECTION OF
            //           SERVERS, ADD TO LIST. ELSE, TOSS.
            //           NOTE: FOR THIS PHASE, THERE HAD BETTER BE ALL
            //                 SOAS RETURNED TO TEST INTERSECTION?
            //

            if ( CompareMultiAdapterSOAQueries(
                        pdomain,
                        pUpdateEntry->DnsServerList,
                        pregEntry->DnsServerList ) )
            {
                PDNS_RECORD prr;

                //
                // Convert registered entry to a PDNS_RECORD and
                // add to current list
                //
                prr = CreateForwardRecords(
                                pregEntry,
                                fprimaryMatch
                                    ? UPTYPE_PRIMARY
                                    : UPTYPE_ADAPTER );
                if ( prr )
                {
                    precords = Dns_RecordListAppend(
                                    precords,
                                    prr );
                    if ( pServerIp &&
                         *pServerIp == 0 &&
                         pUpdateEntry->RetryCount == 0 &&
                         pregEntry->SentUpdateToIp )
                    {
                        *pServerIp = pregEntry->SentUpdateToIp;
                    }
                }
            }
        }

        FreeUpdateEntry( pregEntry );
    }

Exit:

    DNSDBG( TRACE, (
        "Leave  GetPreviousRegistrationInformation()\n"
        "\tprevious records = %p\n",
        precords ));

    return( precords );
}



PDNS_RECORD
CreateDnsRecordSetUnion(
    IN      PDNS_RECORD     pSet1,
    IN      PDNS_RECORD     pSet2
    )
{
    PDNS_RECORD pSet1Copy = NULL;
    PDNS_RECORD pSet2Copy = NULL;

    pSet1Copy = Dns_RecordSetCopyEx(
                    pSet1,
                    DnsCharSetUnicode,
                    DnsCharSetUnicode );
    if ( !pSet1Copy )
    {
        return NULL;
    }
    pSet2Copy = Dns_RecordSetCopyEx(
                    pSet2,
                    DnsCharSetUnicode,
                    DnsCharSetUnicode );
    if ( !pSet2Copy )
    {
        Dns_RecordListFree( pSet1Copy );
        return NULL;
    }

    return Dns_RecordListAppend( pSet1Copy, pSet2Copy );
}



//
//  Logging
//


#if 1 // DBG

VOID 
LogHostEntries(
    IN  DWORD                dwHostAddrCount,
    IN  PREGISTER_HOST_ENTRY pHostAddrs
    )
{
    DWORD iter;

    for ( iter = 0; iter < dwHostAddrCount; iter++ )
    {
        ASYNCREG_F3( "    HostAddrs[%d].dwOptions : 0x%x",
                     iter,
                     pHostAddrs[iter].dwOptions );

        if ( pHostAddrs->dwOptions & REGISTER_HOST_A )
        {
            ASYNCREG_F6( "    HostAddrs[%d].Addr.ipAddr : %d.%d.%d.%d",
                         iter,
                         ((BYTE *) &pHostAddrs[iter].Addr.ipAddr)[0],
                         ((BYTE *) &pHostAddrs[iter].Addr.ipAddr)[1],
                         ((BYTE *) &pHostAddrs[iter].Addr.ipAddr)[2],
                         ((BYTE *) &pHostAddrs[iter].Addr.ipAddr)[3] );
        }
        else if ( pHostAddrs->dwOptions & REGISTER_HOST_AAAA )
        {
            ASYNCREG_F6( "    HostAddrs[%d].Addr.ipV6Addr : %d.%d.%d.%d",
                         iter,
                         ((DWORD *) &pHostAddrs[iter].Addr.ipV6Addr)[0],
                         ((DWORD *) &pHostAddrs[iter].Addr.ipV6Addr)[1],
                         ((DWORD *) &pHostAddrs[iter].Addr.ipV6Addr)[2],
                         ((DWORD *) &pHostAddrs[iter].Addr.ipV6Addr)[3] );
        }
        else
        {
            ASYNCREG_F1( "ERROR: HostAddrs[%d].Addr UNKNOWN ADDRESS TYPE!" );
        }
    }
}

#endif


#if 1 // DBG


VOID 
LogIp4Address(
    IN  DWORD           dwServerListCount,
    IN  PIP4_ADDRESS    pServers
    )
{
    DWORD iter;

    for ( iter = 0; iter < dwServerListCount; iter++ )
    {
        ASYNCREG_F6( "    Server [%d] : %d.%d.%d.%d",
                     iter,
                     ((BYTE *) &pServers[iter])[0],
                     ((BYTE *) &pServers[iter])[1],
                     ((BYTE *) &pServers[iter])[2],
                     ((BYTE *) &pServers[iter])[3] );
    }
}

#endif


#if 1 // DBG


VOID 
LogIp4Array(
    IN  PIP4_ARRAY  pServers
    )
{
    DWORD count;
    DWORD iter;

    if ( pServers )
    {
        count = pServers->AddrCount;
    }
    else
    {
        return;
    }

    for ( iter = 0; iter < count; iter++ )
    {
        ASYNCREG_F6( "    Server [%d] : %d.%d.%d.%d",
                     iter,
                     ((BYTE *) &pServers->AddrArray[iter])[0],
                     ((BYTE *) &pServers->AddrArray[iter])[1],
                     ((BYTE *) &pServers->AddrArray[iter])[2],
                     ((BYTE *) &pServers->AddrArray[iter])[3] );
    }
}

#endif




VOID
registerUpdateStatus(
    IN OUT  PREGISTER_HOST_STATUS   pRegstatus,
    IN      DNS_STATUS              Status
    )
/*++

Routine Description:

    Set Status and signal completion.

Arguments:

    pRegstatus -- registration Status block to indicate

    Status -- Status to indicate

Return Value:

    None

--*/
{
    //  test for existence and event

    if ( !pRegstatus || !pRegstatus->hDoneEvent )
    {
        return;
    }

    //  set return Status
    //  signal event

    pRegstatus->dwStatus = Status;

    SetEvent( pRegstatus->hDoneEvent );
}



VOID
enqueueUpdate(
    IN OUT  PUPDATE_ENTRY   pUpdate
    )
/*++

Routine Description:

    Queue update on registration queue.

Arguments:

    pUpdate -- update completed

Return Value:

    None

--*/
{
    LOCK_REG_LIST();
    InsertTailList( &g_DhcpRegList, (PLIST_ENTRY)pUpdate );
    UNLOCK_REG_LIST();
}



VOID
enqueueUpdateMaybe(
    IN OUT  PUPDATE_ENTRY   pUpdate
    )
/*++

Routine Description:

    Queue update on registration queue, only if there does not exist
    any updates in the queue already for the given adapter.

Arguments:

    pUpdate -- update completed

Return Value:

    None

--*/
{
    PLIST_ENTRY       plistHead;
    PLIST_ENTRY       pentry;
    BOOL              fAdd = TRUE;

    LOCK_REG_LIST();

    plistHead = &g_DhcpRegList;
    pentry = plistHead->Flink;

    while ( pentry != plistHead )
    {
        if ( !_wcsicmp( ((PUPDATE_ENTRY) pentry)->AdapterName,
                        pUpdate->AdapterName ) )
        {
            fAdd = FALSE;
            break;
        }

        pentry = pentry->Flink;
    }

    if ( fAdd )
    {
        InsertTailList( &g_DhcpRegList, (PLIST_ENTRY)pUpdate );
    }
    else
    {
        FreeUpdateEntry( pUpdate );
    }

    UNLOCK_REG_LIST();
}



PLIST_ENTRY
dequeueAndCleanupUpdate(
    IN OUT  PLIST_ENTRY     pUpdateEntry
    )
/*++

Routine Description:

    Dequeue and free update.

    Includes any registration Status setting.

Arguments:

    pUpdateEntry -- pUpdateEntry

Return Value:

    Ptr to next update in queue.

--*/
{
    PLIST_ENTRY pnext = pUpdateEntry->Flink;

    RemoveEntryList( pUpdateEntry );

    if ( ((PUPDATE_ENTRY)pUpdateEntry)->pRegisterStatus )
    {
        registerUpdateStatus(
            ((PUPDATE_ENTRY)pUpdateEntry)->pRegisterStatus,
            ERROR_SUCCESS );
    }

    FreeUpdateEntry( (PUPDATE_ENTRY) pUpdateEntry );

    return( pnext );
}



BOOL
searchForOldUpdateEntriesAndCleanUp(
    IN      PWSTR           pszAdapterName,
    IN      PUPDATE_ENTRY   pUpdateEntry,    OPTIONAL
    IN      BOOL            fLookInRegistry
    )
/*++

Routine Description:

    Searches registry for any previous registrations for a given adapter
    name and queues up a delete update entry for it. Then walks the update
    registration list to remove any add updates for the given adapter.

Arguments:

    pszAdapterName -- name of adapters that is going away (disabled for
    DDNS or now removed).

Return Value:

    Flag to indicate whether a delete update has been queued up ready to
    be processed.

--*/
{
    PUPDATE_ENTRY pregEntry = NULL;
    BOOL              fReturn = FALSE;
    PLIST_ENTRY       plistHead;
    PLIST_ENTRY       pentry;

    //
    // See if this adapter has been previously registered
    //
    if ( fLookInRegistry &&
         (pregEntry = ReadUpdateEntryFromRegistry( pszAdapterName )) )
    {
        pregEntry->fRemove = TRUE;
        pregEntry->Flags |= DYNDNS_DEL_ENTRY;

        pregEntry->fRegisteredFWD = FALSE;
        pregEntry->fRegisteredPRI = FALSE;
        pregEntry->fRegisteredPTR = FALSE;

        //
        // Clear registry key for adapter
        //
        WriteUpdateEntryToRegistry( pregEntry );

        //
        // Put update in registration list
        //
        enqueueUpdate( pregEntry );

        fReturn = TRUE; // We have queued a delete update to process.
    }

    //
    // Now walk the pending update list looking for updates that should
    // be removed for the given adapter name.
    //
    LOCK_REG_LIST();

    plistHead = &g_DhcpRegList;
    pentry = plistHead->Flink;

    while ( pentry != plistHead )
    {
        if ( !_wcsicmp( ((PUPDATE_ENTRY) pentry)->AdapterName,
                        pszAdapterName ) &&
             !((PUPDATE_ENTRY) pentry)->fRemove )
        {
            //
            // There is an update entry in the registration list
            // that has the same adapter name. We need to get rid of
            // this entry since the adapter is being deleted.
            //

            if ( pUpdateEntry &&
                 compareUpdateEntries( (PUPDATE_ENTRY) pentry,
                                       pUpdateEntry ) )
            {
                //
                // The adapter entry in the queue is the same as the
                // one being being processed. i.e. All of the adapter
                // information seems to be the same and we must have
                // just been called to refresh the adapter info in DNS.
                // Since they are the same, if we have previously tried
                // an update with these settings and failed and have
                // already logged an event, then there is no reason to
                // repeat the error event in the retries to follow
                // on the new pUpdateEntry. That said, we'll copy over
                // the flag from the queued update to the new one . . .
                //

                pUpdateEntry->fDisableErrorLogging =
                    ((PUPDATE_ENTRY) pentry)->fDisableErrorLogging;
            }

            pentry = dequeueAndCleanupUpdate( pentry );
            continue;
        }
        else if ( !_wcsicmp( ((PUPDATE_ENTRY) pentry)->AdapterName,
                             pszAdapterName ) )
        {
            if ( !fLookInRegistry &&
                 pUpdateEntry &&
                 compareUpdateEntries( (PUPDATE_ENTRY) pentry,
                                       pUpdateEntry ) )
            {
                //
                // There is a delete update entry in the registration list
                // that has the same adapter data. Get rid of this delete
                // entry since the adapter is being updated again.
                //

                pentry = dequeueAndCleanupUpdate( pentry );
                continue;
            }
            else
            {
                //
                // There is a delete update entry in the registration list for
                // the same adapter that contains different data, have the
                // delete update set to new with a retry count of 2.
                //
                ((PUPDATE_ENTRY) pentry)->fNewElement = TRUE;
                ((PUPDATE_ENTRY) pentry)->fRegisteredFWD = FALSE;
                ((PUPDATE_ENTRY) pentry)->fRegisteredPRI = FALSE;
                ((PUPDATE_ENTRY) pentry)->fRegisteredPTR = FALSE;
                ((PUPDATE_ENTRY) pentry)->fDisableErrorLogging = FALSE;
                ((PUPDATE_ENTRY) pentry)->RetryCount = 0;
                ((PUPDATE_ENTRY) pentry)->RetryTime =
                Dns_GetCurrentTimeInSeconds();

                pentry = pentry->Flink;
            }
        }
        else
        {
            pentry = pentry->Flink;
        }
    }

    UNLOCK_REG_LIST();

    return fReturn;
}



BOOL
compareHostEntryAddrs(
    IN      PREGISTER_HOST_ENTRY    Addrs1,
    IN      PREGISTER_HOST_ENTRY    Addrs2,
    IN      DWORD                   Count
    )
{
    DWORD iter;

    for ( iter = 0; iter < Count; iter++ )
    {
        if ( ( Addrs1[iter].dwOptions & REGISTER_HOST_A ) &&
             ( Addrs2[iter].dwOptions & REGISTER_HOST_A ) )
        {
            if ( memcmp( &Addrs1[iter].Addr.ipAddr,
                         &Addrs2[iter].Addr.ipAddr,
                         sizeof( IP4_ADDRESS) ) )
            {
                return FALSE;
            }
        }
        else if ( ( Addrs1[iter].dwOptions & REGISTER_HOST_AAAA ) &&
                  ( Addrs2[iter].dwOptions & REGISTER_HOST_AAAA ) )
        {
            if ( memcmp( &Addrs1[iter].Addr.ipV6Addr,
                         &Addrs2[iter].Addr.ipV6Addr,
                         sizeof( IP6_ADDRESS  ) ) )
            {
                return FALSE;
            }
        }
        else
        {
            return FALSE;
        }
    }

    return TRUE;
}



//
//  Routines for update entry comparison
//

BOOL
compareServerLists(
    IN      PIP4_ARRAY      List1,
    IN      PIP4_ARRAY      List2
    )
{
    if ( List1 && List2 )
    {
        if ( List1->AddrCount != List2->AddrCount )
        {
            return FALSE;
        }

        if ( memcmp( List1->AddrArray,
                     List2->AddrArray,
                     sizeof( IP4_ADDRESS) * List1->AddrCount ) )
        {
            return FALSE;
        }
    }

    return TRUE;
}



BOOL
compareUpdateEntries(
    IN      PUPDATE_ENTRY   pUpdateEntry1,
    IN      PUPDATE_ENTRY   pUpdateEntry2
    )
/*++

Routine Description:

    Compares to update entries to see if they are describing the same
    adapter configuration settings. Tests the domain names, the IP
    address(es), host names, and the DNS server lists.

Arguments:

    pUdapteEntry1 - one of the update entries to compare against the other.
    pUdapteEntry2 - one of the update entries to compare against the other.

Return Value:

    Flag to indicate whether a the two updates are the same.

--*/
{
    if ( !pUpdateEntry1 || !pUpdateEntry2 )
    {
        return FALSE;
    }

    if ( ( pUpdateEntry1->HostName || pUpdateEntry2->HostName ) &&
         !Dns_NameCompare_W( pUpdateEntry1->HostName,
                                pUpdateEntry2->HostName ) )
    {
        return FALSE;
    }

    if ( ( pUpdateEntry1->DomainName || pUpdateEntry2->DomainName ) &&
         !Dns_NameCompare_W( pUpdateEntry1->DomainName,
                                pUpdateEntry2->DomainName ) )
    {
        return FALSE;
    }

    if ( ( pUpdateEntry1->PrimaryDomainName || pUpdateEntry2->PrimaryDomainName )
            &&
           ! Dns_NameCompare_W(
                pUpdateEntry1->PrimaryDomainName,
                pUpdateEntry2->PrimaryDomainName ) )
    {
        return FALSE;
    }

    if ( pUpdateEntry1->HostAddrCount != pUpdateEntry2->HostAddrCount ||
         ! compareHostEntryAddrs(
                pUpdateEntry1->HostAddrs,
                pUpdateEntry2->HostAddrs,
                pUpdateEntry1->HostAddrCount ) )
    {
        return FALSE;
    }

    if ( pUpdateEntry1->DnsServerList &&
         pUpdateEntry2->DnsServerList &&
         ! compareServerLists(
                pUpdateEntry1->DnsServerList,
                pUpdateEntry2->DnsServerList ) )
    {
        return FALSE;
    }

    return TRUE;
}



//
//  Jim Utils
//

DWORD
dhcp_GetNextUpdateEntryFromList(
    OUT     PUPDATE_ENTRY * ppUpdateEntry,
    OUT     PDWORD          pdwWaitTime
    )
/*++

Routine Description:

    Dequeue next update to be executed from list.

Arguments:

    ppUpdateEntry -- addr to receive ptr to entry to execute

    pdwWaitTime -- addr to receive wait time (in seconds)

Return Value:

    REG_LIST_FOUND -- returning entry in ppUpdateEntry
            - new entry if found
            - retry which is past its retry time

    REG_LIST_WAIT -- only entries still waiting for retry
            - set pdwWaitTime to remaining time to first retry

    REG_LIST_EMPTY -- list is empty

--*/
{
    PLIST_ENTRY     plistHead;
    PUPDATE_ENTRY   pbest = NULL;
    PUPDATE_ENTRY   pentry;
    DWORD           bestWaitTime = 0xffffffff;
    DWORD           retval;


    DNSDBG( TRACE, ( "dhcp_GetNextUpdateEntryFromList()\n" ));

    //
    //  find best entry
    //  ranking:
    //      - new delete
    //      - new update
    //      - lowest wait of anything left
    //

    LOCK_REG_LIST();

    pentry = (PUPDATE_ENTRY) g_DhcpRegList.Flink;

    while ( pentry != (PUPDATE_ENTRY)&g_DhcpRegList )
    {
        if ( pentry->fNewElement )
        {
            bestWaitTime = 0;

            if ( pentry->fRemove )
            {
                pbest = pentry;
                break;
            }
            else if ( !pbest )
            {
                pbest = pentry;
            }
        }

        else if ( pentry->RetryTime < bestWaitTime )
        {
            bestWaitTime = pentry->RetryTime;
            pbest = pentry;
        }

        pentry = (PUPDATE_ENTRY) ((PLIST_ENTRY)pentry)->Flink;
        DNS_ASSERT( pbest );
    }

    //
    //  found best entry
    //      - found new or past retry =>    return entry;  (no wait)
    //      - wait till next entry =>       return wait time (s);  (no entry)
    //      - queue empty =>                (no entry, wait time ignored)
    //

    retval = REG_LIST_EMPTY;

    if ( pbest )
    {
        if ( bestWaitTime )
        {
            //  calc time to expiration
            //  if not at expiration, no dequeue, return wait time

            bestWaitTime -= Dns_GetCurrentTimeInSeconds();
            if ( (INT)bestWaitTime > 0 )
            {
                pbest = NULL;
                retval = REG_LIST_WAIT;
                goto Done;
            }
        }
        RemoveEntryList( (PLIST_ENTRY)pbest );
        bestWaitTime = 0;
        retval = REG_LIST_FOUND;
    }

Done:

    UNLOCK_REG_LIST();

    *ppUpdateEntry = pbest;
    *pdwWaitTime = (DWORD) bestWaitTime;

    DNSDBG( TRACE, (
        "Leave dhcp_GetNextUpdateEntryFromList() => %d\n"
        "\tpFound   = %p\n"
        "\tWait     = %d\n",
        retval,
        pbest,
        bestWaitTime ));

    return  retval;
}



PDNS_RECORD
CreatePtrRecord(
    IN      PWSTR           pszHostName,
    IN      PWSTR           pszDomainName,
    IN      IP4_ADDRESS     Ip4Addr,
    IN      DWORD           Ttl
    )
/*++

Routine Description:

    Create PTR record for update from IP and host and domain names.

Arguments:


Return Value:

    PTR record to use in update.

--*/
{
    DNS_ADDR    addr;

    DNSDBG( TRACE, (
        "CreatePtrRecord( %S, %S, %s )\n",
        pszHostName,
        pszDomainName,
        IP4_STRING( Ip4Addr ) ));

    DnsAddr_BuildFromIp4(
        &addr,
        Ip4Addr,
        0       // no port
        );

    return  Dns_CreatePtrRecordExEx(
                    & addr,
                    (PSTR) pszHostName,
                    (PSTR) pszDomainName,
                    Ttl,
                    DnsCharSetUnicode,
                    DnsCharSetUnicode
                    );
}



VOID
UpdatePtrRecords(
    IN OUT  PUPDATE_ENTRY   pUpdateEntry,
    IN      BOOL            fAdd
    )
/*++

Routine Description:

    Register PTR records for an update entry.

Arguments:

    pUpdateEntry -- update being processed

    fAdd -- TRUE for add;  FALSE for delete

Return Value:

    PTR record to use in update.

--*/
{
    DWORD           iter;
    PDNS_RECORD     prr = NULL;
    DNS_STATUS      status = NO_ERROR;
    IP4_ADDRESS     ipServer;
    DNS_RRSET       rrset;
    PWSTR           pdomain = NULL;
    PWSTR           pprimary = NULL;
    DWORD           ttl = pUpdateEntry->TTL;
    PWSTR           phostname = pUpdateEntry->HostName;
    DNS_EXTRA_INFO  results;


    DNSDBG( TRACE, (
        "UpdatePtrRecords( %p, fAdd=%d )\n",
        pUpdateEntry,
        fAdd ));

    IF_DNSDBG( TRACE )
    {
        DnsDbg_UpdateEntry(
            "Entering UpdatePtrRecords:",
            pUpdateEntry );
    }

    if ( !g_RegisterReverseLookup )
    {
        return;
    }

    //
    //  make sure we have update to do
    //  only do ADD updates if forward registrations were successful
    //      but special case if DNS server as MS DNS may reject
    //      forward update in favor of it's self-created records
    //

    pdomain  = pUpdateEntry->DomainName;
    pprimary = pUpdateEntry->PrimaryDomainName;

    if ( fAdd && !g_IsDnsServer )
    {
        if ( !pUpdateEntry->fRegisteredFWD )
        {
            pdomain = NULL;
        }
        if ( !pUpdateEntry->fRegisteredPRI )
        {
            pprimary = NULL;
        }
    }
    if ( !pdomain && !pprimary )
    {
        DNSDBG( TRACE, (
            "UpdatePtrRecords() => no forward registrations"
            "-- skipping PTR update.\n" ));
        return;
    }

    //
    //  build PTR (or set) for each IP in update entry
    //

    for ( iter = 0; iter < pUpdateEntry->HostAddrCount; iter++ )
    {
        IP4_ADDRESS ip = pUpdateEntry->HostAddrs[iter].Addr.ipAddr;

        if ( ip == 0 || ip == DNS_NET_ORDER_LOOPBACK )
        {
            DNS_ASSERT( FALSE );
            continue;
        }

        //
        //   build update PTR set
        //      - primary name
        //      - adapter name
        //

        DNS_RRSET_INIT( rrset );

        if ( pprimary )
        {
            prr = CreatePtrRecord(
                        phostname,
                        pprimary,
                        ip,
                        ttl );
            if ( prr )
            {
                DNS_RRSET_ADD( rrset, prr );
            }
        }
        if ( pdomain )
        {
            prr = CreatePtrRecord(
                        phostname,
                        pdomain,
                        ip,
                        ttl );
            if ( prr )
            {
                DNS_RRSET_ADD( rrset, prr );
            }
        }
        prr = rrset.pFirstRR;
        if ( !prr )
        {
            continue;
        }

        //
        //  do update
        //
        //  for ADD     => replace, we own the IP address now
        //  for REMOVE  => modify, as another update might have already
        //                  written correct info
        //

        RtlZeroMemory( &results, sizeof(results) );
        results.Id = DNS_EXINFO_ID_RESULTS_BASIC;

        if ( fAdd )
        {
            status = DnsReplaceRecordSetW(
                            prr,                    // update set
                            DNS_UPDATE_CACHE_SECURITY_CONTEXT,
                            NULL,                   // no security context
                            (PIP4_ARRAY) pUpdateEntry->DnsServerList,
                            & results
                            );
        }
        else
        {
            status = DnsModifyRecordsInSet_W(
                            NULL,           // no add records
                            prr,            // delete records
                            DNS_UPDATE_CACHE_SECURITY_CONTEXT,
                            NULL,           // no context handle
                            pUpdateEntry->DnsServerList,
                            & results
                            );
        }
        DNSDBG( TRACE, (
            "%s on PTRs for IP %s => %d (%s)\n",
            fAdd
                ? "Replace"
                : "Modify (remove)",
            IP4_STRING(ip),
            status,
            Dns_StatusString(status) ));

        if ( !fAdd || pUpdateEntry->RetryCount == 0 )
        {
            LogRegistration(
                pUpdateEntry,
                status,
                UPTYPE_PTR,
                !fAdd,
                DnsAddr_GetIp4( (PDNS_ADDR)&results.ResultsBasic.ServerAddr ),
                ip );
        }

        //  note successful PTR registrations (adds)

        if ( fAdd && status==NO_ERROR )
        {
            pUpdateEntry->fRegisteredPTR = TRUE;
        }
        Dns_RecordListFree( prr );
    }

    DNSDBG( TRACE, (
        "Leave UpdatePtrRecords()\n" ));
}



PDNS_RECORD
CreateForwardRecords(
    IN      PUPDATE_ENTRY   pUpdateEntry,
    IN      UPTYPE          UpType
    )
/*++

Routine Description:

    Create A records for update.

Arguments:

    pUpdateEntry -- update entry

    UpType -- update type
        UPTYPE_ADAPTER
        UPTYPE_PRIMARY
        UPTYPE_ALTERNATE

Return Value:

    Ptr to list of A records.

--*/
{
    PDNS_RECORD prr = NULL;
    PWSTR       pname;
    DWORD       iter;
    WCHAR       nameBuffer[ DNS_MAX_NAME_BUFFER_LENGTH ];
    DNS_RRSET   rrset;


    DNSDBG( TRACE, (
        "CreateForwardRecords( %p, %d )\n",
        pUpdateEntry,
        UpType ));

    //
    //  for current updates -- get update name directly
    //

    pname = pUpdateEntry->pUpdateName;

    //
    //  registry updates -- get FQDN for update type
    //

    if ( !pname )
    {
        if ( IS_UPTYPE_PRIMARY(UpType) )
        {
            pname = pUpdateEntry->pPrimaryFQDN;
        }
        else if ( IS_UPTYPE_ADAPTER(UpType) )
        {
            pname = pUpdateEntry->pAdapterFQDN;
        }
    }
    if ( !pname )
    {
        return  NULL;
    }

    //
    //  create records for name
    //

    DNS_RRSET_INIT( rrset );

    for ( iter = 0; iter < pUpdateEntry->HostAddrCount; iter++ )
    {
        if ( !(pUpdateEntry->HostAddrs[iter].dwOptions & REGISTER_HOST_A) )
        {
            continue;
        }

        prr = Dns_CreateARecord(
                    (PDNS_NAME) pname,
                    pUpdateEntry->HostAddrs[iter].Addr.ipAddr,
                    pUpdateEntry->TTL,
                    DnsCharSetUnicode,
                    DnsCharSetUnicode );
        if ( !prr )
        {
            SetLastError( DNS_ERROR_NO_MEMORY );
            Dns_RecordListFree( rrset.pFirstRR );
            return  NULL;
        }

        DNS_RRSET_ADD( rrset, prr );
    }

    DNSDBG( TRACE, (
        "Leave CreateForwardRecords() => %p\n",
        rrset.pFirstRR ));

    return rrset.pFirstRR;
}



VOID
SetUpdateStatus(
    IN OUT  PUPDATE_ENTRY   pUpdateEntry,
    IN      PDNS_EXTRA_INFO pResults,
    IN      UPTYPE          UpType
    )
/*++

Routine Description:

    Set update Status info in update entry.

Arguments:

    pUpdateEntry -- entry to set Status in

    Status -- result of update

    fPrimary -- TRUE if update was for primary name; FALSE otherwise

Return Value:

    None

--*/
{
    IP4_ADDRESS     ipServer;
    BOOL            fregistered;

    DNSDBG( TRACE, ( "SetUpdateStatus()\n" ));

    DNS_ASSERT( pUpdateEntry != NULL );
    DNS_ASSERT( pResults != NULL );
    DNS_ASSERT( pResults->Id == DNS_EXINFO_ID_RESULTS_BASIC );

    //
    //  save results info
    //

    ipServer = DnsAddr_GetIp4( (PDNS_ADDR)&pResults->ResultsBasic.ServerAddr );
    if ( ipServer == INADDR_NONE )
    {
        DNSDBG( ANY, (
            "WARNING:  update results has no IP!\n"
            "\tnote:  this may be appropriate for non-wire update failures\n"
            "\tresult status = %d\n",
            pResults->ResultsBasic.Status ));

        ipServer = 0;
    }
    fregistered = ( pResults->ResultsBasic.Status == NO_ERROR );

    if ( IS_UPTYPE_PRIMARY(UpType) )
    {
        pUpdateEntry->SentPriUpdateToIp = ipServer;
        pUpdateEntry->fRegisteredPRI = fregistered;
    }
    else if ( IS_UPTYPE_ADAPTER(UpType) )
    {
        pUpdateEntry->SentUpdateToIp = ipServer;
        pUpdateEntry->fRegisteredFWD = fregistered;
    }
}



VOID
DnsPrint_UpdateEntry(
    IN      PRINT_ROUTINE   PrintRoutine,
    IN OUT  PPRINT_CONTEXT  pContext,
    IN      PSTR            pszHeader,
    IN      PUPDATE_ENTRY   pEntry
    )
/*++

Routine Description:

    Print update entry.

Arguments:

    PrintRoutine - routine to print with

    pszHeader   - header

    pEntry      - ptr to update entry

Return Value:

    None.

--*/
{
    DWORD   i;

    if ( !pszHeader )
    {
        pszHeader = "Update Entry:";
    }

    if ( !pEntry )
    {
        PrintRoutine(
            pContext,
            "%s %s\r\n",
            pszHeader,
            "NULL Update Entry ptr." );
        return;
    }

    //  print the struct

    PrintRoutine(
        pContext,
        "%s\r\n"
        "\tPtr                  = %p\n"
        "\tSignatureTop         = %08x\n"
        "\tAdapterName          = %S\n"
        "\tHostName             = %S\n"
        "\tPrimaryDomainName    = %S\n"
        "\tDomainName           = %S\n"
        "\tAlternateName        = %S\n"
        "\tpUpdateName          = %S\n"
        "\tHostAddrCount        = %d\n"
        "\tHostAddrs            = %p\n"
        "\tDnsServerList        = %p\n"
        "\tSentUpdateToIp       = %s\n"
        "\tSentPriUpdateToIp    = %s\n"
        "\tTTL                  = %d\n"
        "\tFlags                = %08x\n"
        "\tfNewElement          = %d\n"
        "\tfFromRegistry        = %d\n"
        "\tfRemove              = %d\n"
        "\tfRegisteredFWD       = %d\n"
        "\tfRegisteredPRI       = %d\n"
        "\tfRegisteredPTR       = %d\n"
        "\tfDisableLogging      = %d\n"
        "\tRetryCount           = %d\n"
        "\tRetryTime            = %d\n"
        "\tBeginRetryTime       = %d\n"
        "\tpRegisterStatus      = %p\n"
        "\tSignatureBottom      = %08x\n",
        pszHeader,
        pEntry,
        pEntry->SignatureTop,        
        pEntry->AdapterName,         
        pEntry->HostName,            
        pEntry->PrimaryDomainName,   
        pEntry->DomainName,          
        pEntry->AlternateNames,
        pEntry->pUpdateName,
        pEntry->HostAddrCount,       
        pEntry->HostAddrs,           
        pEntry->DnsServerList,       
        IP4_STRING( pEntry->SentUpdateToIp ),      
        IP4_STRING( pEntry->SentPriUpdateToIp ),   
        pEntry->TTL,                 
        pEntry->Flags,               
        pEntry->fNewElement,         
        pEntry->fFromRegistry,
        pEntry->fRemove,             
        pEntry->fRegisteredFWD,      
        pEntry->fRegisteredPRI,      
        pEntry->fRegisteredPTR,      
        pEntry->fDisableErrorLogging,
        pEntry->RetryCount,          
        pEntry->RetryTime,           
        pEntry->BeginRetryTime,           
        pEntry->pRegisterStatus,     
        pEntry->SignatureBottom     
        );
}



VOID
AsyncLogUpdateEntry(
    IN      PSTR            pszHeader,
    IN      PUPDATE_ENTRY   pEntry
    )
{
    if ( !pEntry )
    {
        return;
    }

    ASYNCREG_F2( "    %s", pszHeader );
    ASYNCREG_F1( "    Update Entry" );
    ASYNCREG_F1( "    ______________________________________________________" );
    ASYNCREG_F2( "      AdapterName       : %S", pEntry->AdapterName );
    ASYNCREG_F2( "      HostName          : %S", pEntry->HostName );
    ASYNCREG_F2( "      DomainName        : %S", pEntry->DomainName );
    ASYNCREG_F2( "      PrimaryDomainName : %S", pEntry->PrimaryDomainName );
    ASYNCREG_F2( "      HostAddrCount     : %d", pEntry->HostAddrCount );
    DNSLOG_HOST_ENTRYS( pEntry->HostAddrCount,
                        pEntry->HostAddrs );
    if ( pEntry->DnsServerList )
    {
        DNSLOG_IP4_ARRAY( pEntry->DnsServerList );
    }
    ASYNCREG_F2( "      TTL               : %d", pEntry->TTL );
    ASYNCREG_F2( "      Flags             : %d", pEntry->Flags );
    ASYNCREG_F2( "      fNewElement       : %d", pEntry->fNewElement );
    ASYNCREG_F2( "      fRemove           : %d", pEntry->fRemove );
    ASYNCREG_F2( "      fRegisteredFWD    : %d", pEntry->fRegisteredFWD );
    ASYNCREG_F2( "      fRegisteredPRI    : %d", pEntry->fRegisteredPRI );
    ASYNCREG_F2( "      fRegisteredPTR    : %d", pEntry->fRegisteredPTR );
    ASYNCREG_F2( "      RetryCount        : %d", pEntry->RetryCount );
    ASYNCREG_F2( "      RetryTime         : %d", pEntry->RetryTime );
    ASYNCREG_F1( "" );
}



//
//  Logging
//

DWORD   RegistrationEventArray[6][6] =
{
    EVENT_DNSAPI_REGISTRATION_FAILED_TIMEOUT,
    EVENT_DNSAPI_REGISTRATION_FAILED_SERVERFAIL,
    EVENT_DNSAPI_REGISTRATION_FAILED_NOTSUPP,
    EVENT_DNSAPI_REGISTRATION_FAILED_REFUSED,
    EVENT_DNSAPI_REGISTRATION_FAILED_SECURITY,
    EVENT_DNSAPI_REGISTRATION_FAILED_OTHER,

    EVENT_DNSAPI_DEREGISTRATION_FAILED_TIMEOUT,
    EVENT_DNSAPI_DEREGISTRATION_FAILED_SERVERFAIL,
    EVENT_DNSAPI_DEREGISTRATION_FAILED_NOTSUPP,
    EVENT_DNSAPI_DEREGISTRATION_FAILED_REFUSED,
    EVENT_DNSAPI_DEREGISTRATION_FAILED_SECURITY,
    EVENT_DNSAPI_DEREGISTRATION_FAILED_OTHER,

    EVENT_DNSAPI_REGISTRATION_FAILED_NOTSUPP_PRIMARY_DN,
    EVENT_DNSAPI_REGISTRATION_FAILED_REFUSED_PRIMARY_DN,
    EVENT_DNSAPI_REGISTRATION_FAILED_TIMEOUT_PRIMARY_DN,
    EVENT_DNSAPI_REGISTRATION_FAILED_SERVERFAIL_PRIMARY_DN,
    EVENT_DNSAPI_REGISTRATION_FAILED_SECURITY_PRIMARY_DN,
    EVENT_DNSAPI_REGISTRATION_FAILED_OTHER_PRIMARY_DN,

    EVENT_DNSAPI_DEREGISTRATION_FAILED_NOTSUPP_PRIMARY_DN,
    EVENT_DNSAPI_DEREGISTRATION_FAILED_REFUSED_PRIMARY_DN,
    EVENT_DNSAPI_DEREGISTRATION_FAILED_TIMEOUT_PRIMARY_DN,
    EVENT_DNSAPI_DEREGISTRATION_FAILED_SERVERFAIL_PRIMARY_DN,
    EVENT_DNSAPI_DEREGISTRATION_FAILED_SECURITY_PRIMARY_DN,
    EVENT_DNSAPI_DEREGISTRATION_FAILED_OTHER_PRIMARY_DN,

    EVENT_DNSAPI_PTR_REGISTRATION_FAILED_TIMEOUT,
    EVENT_DNSAPI_PTR_REGISTRATION_FAILED_SERVERFAIL,
    EVENT_DNSAPI_PTR_REGISTRATION_FAILED_NOTSUPP,
    EVENT_DNSAPI_PTR_REGISTRATION_FAILED_REFUSED,
    EVENT_DNSAPI_PTR_REGISTRATION_FAILED_SECURITY,
    EVENT_DNSAPI_PTR_REGISTRATION_FAILED_OTHER,

    EVENT_DNSAPI_PTR_DEREGISTRATION_FAILED_TIMEOUT,
    EVENT_DNSAPI_PTR_DEREGISTRATION_FAILED_SERVERFAIL,
    EVENT_DNSAPI_PTR_DEREGISTRATION_FAILED_NOTSUPP,
    EVENT_DNSAPI_PTR_DEREGISTRATION_FAILED_REFUSED,
    EVENT_DNSAPI_PTR_DEREGISTRATION_FAILED_SECURITY,
    EVENT_DNSAPI_PTR_DEREGISTRATION_FAILED_OTHER
};

//
//  Map update status to index into table
//
//  This is the outside -- fast varying -- index
//

#define EVENTINDEX_TIMEOUT      (0)
#define EVENTINDEX_SERVFAIL     (1)
#define EVENTINDEX_NOTSUPP      (2)
#define EVENTINDEX_REFUSED      (3)
#define EVENTINDEX_SECURITY     (4)
#define EVENTINDEX_OTHER        (5)

//
//  Map adapter, primary, PTR registration into index into table
//
//  This index +0 for reg, +1 for dereg gives inside index into
//  event table.
//

#define EVENTINDEX_ADAPTER      (0)
#define EVENTINDEX_PRIMARY      (2)
#define EVENTINDEX_PTR          (4)



DWORD
GetUpdateEventId(
    IN      DNS_STATUS      Status,
    IN      UPTYPE          UpType,
    IN      BOOL            fDeregister,
    OUT     PDWORD          pdwLevel
    )
/*++

Routine Description:

    Get event ID.

Arguments:

    Status -- status from update call

    fDeregister -- TRUE if deregistration, FALSE for registration

    fPtr -- TRUE if PTR, FALSE for forward

    fPrimary -- TRUE for primary domain name

Return Value:

    Event Id.
    Zero if no event.

--*/
{
    DWORD   level = EVENTLOG_WARNING_TYPE;
    DWORD   statusIndex;
    DWORD   typeIndex;

    //
    //  find status code
    //

    switch ( Status )
    {
    case NO_ERROR :

        //  success logging in disabled
        return  0;

    case ERROR_TIMEOUT:

        statusIndex = EVENTINDEX_TIMEOUT;
        break;

    case DNS_ERROR_RCODE_SERVER_FAILURE:

        statusIndex = EVENTINDEX_SERVFAIL;
        break;

    case DNS_ERROR_RCODE_NOT_IMPLEMENTED:

        //  NOT_IMPL means no update on DNS server, not a client
        //      specific problem so informational level

        statusIndex = EVENTINDEX_NOTSUPP;
        level = EVENTLOG_INFORMATION_TYPE;
        break;

    case DNS_ERROR_RCODE_REFUSED:

        statusIndex = EVENTINDEX_REFUSED;
        break;

    case DNS_ERROR_RCODE_BADSIG:
    case DNS_ERROR_RCODE_BADKEY:
    case DNS_ERROR_RCODE_BADTIME:

        statusIndex = EVENTINDEX_SECURITY;
        break;

    default:

        statusIndex = EVENTINDEX_OTHER;
        break;
    }

    //
    //  determine interior index for type of update
    //      - all PTR logging is at informational level
    //      - dereg events are one group behind registration events
    //          in table;  just inc index

    if ( IS_UPTYPE_PTR(UpType) )
    {
        typeIndex = EVENTINDEX_PTR;
        level = EVENTLOG_INFORMATION_TYPE;
    }
    else if ( IS_UPTYPE_PRIMARY(UpType) )
    {
        typeIndex = EVENTINDEX_PRIMARY;
    }
    else
    {
        typeIndex = EVENTINDEX_ADAPTER;
    }

    if ( fDeregister )
    {
        typeIndex++;
    }

    //
    //  get event from table
    //

    *pdwLevel = level;

    return  RegistrationEventArray[ typeIndex ][ statusIndex ];
}



VOID
LogRegistration(
    IN      PUPDATE_ENTRY   pUpdateEntry,
    IN      DNS_STATUS      Status,
    IN      DWORD           UpType,
    IN      BOOL            fDeregister,
    IN      IP4_ADDRESS     DnsIp,
    IN      IP4_ADDRESS     UpdateIp
    )
/*++

Routine Description:

    Log register\deregister failure.

Arguments:

    pUpdateEntry -- update entry being executed

    Status -- status from update call

    Type -- UPTYPE  (PRIMARY, ADAPTER, PTR)

    fDeregister -- TRUE if deregistration, FALSE for registration

    DnsIp -- DNS server IP that failed update

    UpdateIp -- IP we tried to update

Return Value:

    None

--*/
{
    PWSTR       insertStrings[ 7 ];
    WCHAR       serverIpBuffer[ IP4_ADDRESS_STRING_BUFFER_LENGTH ];
    WCHAR       serverListBuffer[ (IP4_ADDRESS_STRING_BUFFER_LENGTH+2)*9 ];
    WCHAR       ipListBuffer[ (IP4_ADDRESS_STRING_BUFFER_LENGTH+2)*9 ];
    WCHAR       hostnameBuffer[ DNS_MAX_NAME_BUFFER_LENGTH ];
    WCHAR       domainBuffer[ DNS_MAX_NAME_BUFFER_LENGTH*2 ];
    WCHAR       errorCodeBuffer[ 25 ];
    DWORD       iter;
    IP4_ADDRESS ip;
    PWSTR       pname;
    DWORD       eventId;
    DWORD       level;
    DNS_STATUS  prevStatus;


    DNSDBG( TRACE, (
        "LogRegistration()\n"
        "\tpEntry       = %p\n"
        "\tStatus       = %d\n"
        "\tUpType       = %d\n"
        "\tfDereg       = %d\n"
        "\tDNS IP       = %s\n"
        "\tUpdate IP    = %s\n",
        pUpdateEntry,
        Status,
        UpType,
        fDeregister,
        IP4_STRING( DnsIp ),
        IP4_STRING( UpdateIp ) ));

    //
    //  not logging?
    //      - disabled
    //      - on DNS server (which registers itself)
    //      - success on deregistration
    //

    if ( pUpdateEntry->fDisableErrorLogging ||
         g_IsDnsServer ||
         (fDeregister && Status == NO_ERROR) )
    {
        DNSDBG( DHCP, ( "NoLogging -- disabled or DNS server or success deregistration.\n" ));
        return;
    }

    //
    //  adapter name
    //

    insertStrings[0] = pUpdateEntry->AdapterName;

    //
    //  hostname
    //

    insertStrings[1] = pUpdateEntry->HostName;

    //
    //  domain name based on update type
    //      - name depends on type
    //      - if no name, no logging
    //      - note alternate name is FQDN
    //
    //  get previous logged status
    //  

    if ( IS_UPTYPE_PTR(UpType) )
    {
        pname = pUpdateEntry->PrimaryDomainName;
        if ( !pname )
        {
            pname = pUpdateEntry->DomainName;
        }
        prevStatus = pUpdateEntry->StatusPtr;
        pUpdateEntry->StatusPtr = Status;
    }
    else if ( IS_UPTYPE_PRIMARY(UpType) )
    {
        pname = pUpdateEntry->PrimaryDomainName;
        prevStatus = pUpdateEntry->StatusPri;
        pUpdateEntry->StatusPri = Status;
    }
    else if ( IS_UPTYPE_ADAPTER(UpType) )
    {
        pname = pUpdateEntry->DomainName;
        prevStatus = pUpdateEntry->StatusFwd;
        pUpdateEntry->StatusFwd = Status;
    }
    else if ( IS_UPTYPE_ALTERNATE(UpType) )
    {
        if ( Status == NO_ERROR )
        {
            DNSDBG( DHCP, ( "NoLogging -- no alternate name success logging.\n" ));
            return;
        }
        pname = pUpdateEntry->pUpdateName;
    }
    else
    {
        DNS_ASSERT( FALSE );
        return;
    }

    if ( !pname )
    {
        DNSDBG( DHCP, ( "NoLogging -- no domain name.\n" ));
        return;
    }

    //
    //  no success logging, unless immediate previous attempt was failure
    //

    if ( Status == NO_ERROR  &&  prevStatus == NO_ERROR )
    {
        DNSDBG( DHCP, ( "NoLogging -- no success logging unless after failure.\n" ));
        return;
    }

    insertStrings[2] = pname;

    //
    //  DNS server list
    //      - layout comma separated, four per line, limit 8

    {
        PWCHAR      pch = serverListBuffer;
        DWORD       count = 0;

        *pch = 0;

        if ( pUpdateEntry->DnsServerList )
        {
            count = pUpdateEntry->DnsServerList->AddrCount;
        }

        for ( iter=0; iter < count; iter++ )
        {
            if ( iter == 0 )
            {
                wcscpy( pch, L"\t" );
                pch++;
            }
            else
            {
                *pch++ = L',';
                *pch++ = L' ';

                if ( iter == 4 )
                {
                    wcscpy( pch, L"\r\n\t" );
                    pch += 3;
                }              
                else if ( iter > 8 )
                {
                    wcscpy( pch, L"..." );
                    break;
                }
            }
            pch = Dns_Ip4AddressToString_W(
                        pch,
                        & pUpdateEntry->DnsServerList->AddrArray[iter]
                        );
        }

        if ( pch == serverListBuffer )
        {
            wcscpy( serverListBuffer, L"\t<?>" );
        }
        insertStrings[3] = serverListBuffer;
    }

    //
    //  DNS server IP
    //

    ip = DnsIp;
    if ( ip == 0 )
    {
        if ( IS_UPTYPE_PRIMARY(UpType) )
        {
            ip = pUpdateEntry->SentPriUpdateToIp;
        }
        else
        {
            ip = pUpdateEntry->SentUpdateToIp;
        }
    }
    if ( ip )
    {
        Dns_Ip4AddressToString_W(
              serverIpBuffer,
              & ip );
    }
    else
    {
        wcscpy( serverIpBuffer, L"<?>" );
    }

    insertStrings[4] = serverIpBuffer;

    //
    //  Update IP
    //      - passed in (for PTR)
    //      - OR get IP list from update entry
    //      - layout comma separated, four per line, limit 8
    //

    ip = UpdateIp;
    if ( ip )
    {
        Dns_Ip4AddressToString_W(
              ipListBuffer,
              & ip );
    }
    else
    {
        DWORD   count = pUpdateEntry->HostAddrCount;
        PWCHAR  pch = ipListBuffer;

        *pch = 0;

        for ( iter=0; iter < count; iter++ )
        {
            if ( iter > 0 )
            {
                *pch++ = L',';
                *pch++ = L' ';

                if ( iter == 4 )
                {
                    wcscpy( pch, L"\r\n\t" );
                    pch += 3;
                }              
                else if ( iter > 8 )
                {
                    wcscpy( pch, L"..." );
                    break;
                }
            }
            pch = Dns_Ip4AddressToString_W(
                        pch,
                        & pUpdateEntry->HostAddrs[iter].Addr.ipAddr );
        }

        if ( pch == ipListBuffer )
        {
            wcscpy( ipListBuffer, L"<?>" );
        }
    }
    insertStrings[5] = ipListBuffer;

    //  terminate insert string array

    insertStrings[6] = NULL;

    //
    //  get event ID for type of update and update status
    //

    eventId = GetUpdateEventId(
                    Status,
                    UpType,
                    fDeregister,
                    & level );
    if ( !eventId )
    {
        DNS_ASSERT( FALSE );
        return;
    }

    //
    //  log the event
    //

    DNSDBG( TRACE, (
        "Logging registration event:\n"
        "\tid           = %d\n"
        "\tlevel        = %d\n"
        "\tstatus       = %d\n"
        "\tfor uptype   = %d\n",
        eventId,
        level,
        Status,
        UpType ));

    DnsLogEvent(
        eventId,
        (WORD) level,
        7,
        insertStrings,
        Status );
}




//
//  Alternate names checking stuff
//

DNS_STATUS
InitAlternateNames(
    VOID
    )
/*++

Routine Description:

    Setup alternate names monitoring.

Arguments:

    None

Globals:

    g_pmszAlternateNames -- set with current alternate names value

    g_hCacheKey -- cache reg key is opened

    g_hRegChangeEvent -- creates event to be signalled on change notify

Return Value:

    ERROR_SUCCESS if successful.
    Error code on failure.

--*/
{
    DNS_STATUS          status;

    DNSDBG( TRACE, (
        "InitAlternateNames()\n" ));

    //
    //  open monitoring regkey at DnsCache\Parameters
    //      set on parameters key which always exists rather than
    //      explicitly on alternate names key, which may not
    //

    status = RegOpenKeyExW(
                HKEY_LOCAL_MACHINE,
                DNS_CACHE_KEY,
                0,
                KEY_READ,
                & g_hCacheKey );
    if ( status != NO_ERROR )
    {
        goto Failed;
    }

    g_hRegChangeEvent = CreateEvent(
                            NULL,       // no security
                            FALSE,      // auto-reset
                            FALSE,      // start non-signalled
                            NULL        // no name
                            );
    if ( !g_hRegChangeEvent )
    {
        status = GetLastError();
        goto Failed;
    }

    //
    //  set change notify
    //

    status = RegNotifyChangeKeyValue(
                g_hCacheKey,
                TRUE,       // watch subtree
                REG_NOTIFY_CHANGE_NAME | REG_NOTIFY_CHANGE_LAST_SET,
                g_hRegChangeEvent,
                TRUE        // async, func doesn't block
                );
    if ( status != NO_ERROR )
    {
        goto Failed;
    }

    //
    //  read alternate computer names
    //      - need value to compare when we get a hit on change-notify
    //      - read can fail -- value stays NULL
    //

    Reg_GetValue(
       NULL,                // no session
       g_hCacheKey,         // cache key
       RegIdAlternateNames,
       REGTYPE_ALTERNATE_NAMES,
       (PBYTE *) &g_pmszAlternateNames
       );

    goto Done;

Failed:

    //
    //  cleanup
    //

    CleanupAlternateNames();

Done:

    DNSDBG( TRACE, (
        "Leave InitAlternateNames() => %d\n"
        "\tpAlternateNames  = %p\n"
        "\thChangeEvent     = %p\n"
        "\thCacheKey        = %p\n",
        status,
        g_pmszAlternateNames,
        g_hRegChangeEvent,
        g_hCacheKey
        ));

    return  status;
}



VOID
CleanupAlternateNames(
    VOID
    )
/*++

Routine Description:

    Cleanup alternate names data.

Arguments:

    None

Globals:

    g_pmszAlternateNames -- is freed

    g_hCacheKey -- cache reg key is closed

    g_hRegChangeEvent -- is closed

Return Value:

    None

--*/
{
    DNS_STATUS  status;

    DNSDBG( TRACE, (
        "CleanupAlternateNames()\n" ));

    FREE_HEAP( g_pmszAlternateNames );
    g_pmszAlternateNames = NULL;

    RegCloseKey( g_hCacheKey );
    g_hCacheKey = NULL;

    CloseHandle( g_hRegChangeEvent );
    g_hRegChangeEvent = NULL;
}



BOOL
CheckForAlternateNamesChange(
    VOID
    )
/*++

Routine Description:

    Check for change in alternate names.

Arguments:

    None

Globals:

    g_pmszAlternateNames -- read

    g_hCacheKey -- used for read

    g_hRegChangeEvent -- used to restart change-notify

Return Value:

    TRUE if alternate names has changed.
    FALSE otherwise.

--*/
{
    DNS_STATUS  status;
    BOOL        fcheck = TRUE;
    PWSTR       palternateNames = NULL;

    DNSDBG( TRACE, (
        "CheckForAlternateNamesChange()\n" ));

    //
    //  sanity check
    //

    if ( !g_hCacheKey || !g_hRegChangeEvent )
    {
        ASSERT( g_hCacheKey && g_hRegChangeEvent );
        return  FALSE;
    }

    //
    //  read alternate computer names
    //      - need value to compare when we get a hit on change-notify
    //      - read can fail -- value stays NULL
    //

    Reg_GetValue(
       NULL,            // no session
       g_hCacheKey,     // cache key
       RegIdAlternateNames,
       REGTYPE_ALTERNATE_NAMES,
       (PBYTE *) &palternateNames
       );

    //
    //  detect alternate names change
    //

    if ( palternateNames || g_pmszAlternateNames )
    {
        if ( !palternateNames || !g_pmszAlternateNames )
        {
            goto Cleanup;
        }
        if ( !MultiSz_Equal_W(
                palternateNames,
                g_pmszAlternateNames ) )
        {
            goto Cleanup;
        }
    }

    fcheck = FALSE;

    //
    //  restart change notify
    //

    status = RegNotifyChangeKeyValue(
                g_hCacheKey,
                TRUE,       // watch subtree
                REG_NOTIFY_CHANGE_NAME | REG_NOTIFY_CHANGE_LAST_SET,
                g_hRegChangeEvent,
                TRUE        // async, func doesn't block
                );
    if ( status != NO_ERROR )
    {
        DNSDBG( ANY, (
            "RegChangeNotify failed! %d\n",
            status ));
        ASSERT( FALSE );
    }

Cleanup:

    FREE_HEAP( palternateNames );

    DNSDBG( TRACE, (
        "Leave CheckForAlternateNamesChange() => %d\n",
        fcheck ));

    return  fcheck;
}



BOOL
IsAnotherUpdateName(
    IN      PUPDATE_ENTRY   pUpdateEntry,
    IN      PWSTR           pwsName,
    IN      UPTYPE          UpType
    )
/*++

Routine Description:

    Check if name is to be updated in another part of update.

Arguments:

    pUpdateEntry -- update to be executed

    pwsName -- name to check

    UpType -- update type about to be executed

Return Value:

    TRUE if name matches name for another update type in update.
    FALSE otherwise

--*/
{
    DNS_STATUS  status;
    BOOL        fcheck = TRUE;
    PWSTR       palternateNames = NULL;

    DNSDBG( TRACE, (
        "IsUpdateName( %p, %S, %d )\n",
        pUpdateEntry,
        pwsName,
        UpType ));

    if ( !pwsName || !pUpdateEntry )
    {
        return  FALSE;
    }

    //
    //  check other names in update
    //
    //  for primary name
    //      - check adapter name and alternate names
    //  for adapter name
    //      - check primary name and alternate names
    //  for alternate names
    //      - check primary and adapter names
    //

    if ( UpType != UPTYPE_PRIMARY )
    {
        if ( Dns_NameCompare_W(
                pwsName,
                pUpdateEntry->pPrimaryFQDN ) )
        {
            goto Matched;
        }
    }

    if ( UpType != UPTYPE_ADAPTER )
    {
        if ( Dns_NameCompare_W(
                pwsName,
                pUpdateEntry->pAdapterFQDN ) )
        {
            goto Matched;
        }
    }

    if ( UpType != UPTYPE_ALTERNATE )
    {
        PWSTR   pname = pUpdateEntry->AlternateNames;

        while ( pname )
        {
            if ( Dns_NameCompare_W(
                    pwsName,
                    pname ) )
            {
                goto Matched;
            }
            pname = MultiSz_NextString_W( pname );
        }
    }

    //  no match to other update names

    return  FALSE;

Matched:

    DNSDBG( TRACE, (
        "Found another update name matching type %d update name %S\n"
        "\tdelete for this update name will be skipped!\n",
        UpType,
        pwsName ));

    return  TRUE;
}

//
//  End asyncreg.c
//
=== C:/Users/treeman/Desktop/windows nt source code\Source\Win2K3\NT\ds\dns\dnsapi\dll.c ===
/*++

Copyright (c) 2000-2001 Microsoft Corporation

Module Name:

    dll.c

Abstract:

    Domain Name System (DNS) API

    Dnsapi.dll basic DLL infrastructure (init, shutdown, etc)

Author:

    Jim Gilroy (jamesg)     April 2000

Revision History:

--*/


#include "local.h"

#include <overflow.h>


//
//  Global Definitions
//

HINSTANCE   g_hInstanceDll;

//
//  Initialization level
//

DWORD       g_InitLevel = 0;

//
//  General purpose CS
//  Protects init and any other small scale uses
//

CRITICAL_SECTION    g_GeneralCS;


//
//  Private protos
//

VOID
cleanupForExit(
    VOID
    );




//
//  Initialization and cleanup
//

BOOL
startInit(
    VOID
    )
/*++

Routine Description:

    Minimum DLL init at process attach.

Arguments:

    None

Return Value:

    TRUE if successful.
    FALSE otherwise.

--*/
{
    BOOL        retval;
    DNS_STATUS  status;

    //
    //  DCR_PERF:  simplified init -- simple Interlock
    //      then all external calls, must test the flag
    //      if not set do the real init (then set flag)
    //
    //      note:  init function itself must have a dumb
    //      wait to avoid race;  this can be as simple
    //      as sleep\test loop
    //
    //  multilevel init:
    //      have a bunch of levels of init
    //          - query (registry stuff)
    //          - update
    //          - secure update
    //
    //      call would add the init for the level required
    //      this would need to be done under a lock to
    //      test, take lock, retest
    //
    //      could either take one CS on all inits (simple)
    //      or init only brings stuff on line
    //

    g_InitLevel = 0;

    status = RtlInitializeCriticalSection( &g_GeneralCS );
    if ( status != NO_ERROR )
    {
        return  FALSE;
    }
    g_InitLevel = INITLEVEL_BASE;


    //  tracing init

    Trace_Initialize();

    //
    //  DCR_PERF:  fast DLL init
    //
    //  currently initializing everything -- like we did before
    //  once we get init routines (macro'd) in interfaces we
    //  can drop this
    //

    retval = DnsApiInit( INITLEVEL_ALL );

    if ( !retval )
    {
        cleanupForExit();
    }

    return  retval;
}



BOOL
DnsApiInit(
    IN      DWORD           InitLevel
    )
/*++

Routine Description:

    Initialize the DLL for some level of use.

    The idea here is to avoid all the init and registry
    reading for processes that don't need it.
    Only insure initialization to the level required.

Arguments:

    InitLevel -- level of initialization required.

Return Value:

    TRUE if desired initialization is successful.
    FALSE otherwise.

--*/
{
    DNS_STATUS  status;

    //
    //  DCR_PERF:  simplified init -- simple Interlock
    //      then all external calls, must test the flag
    //      if not set do the real init (then set flag)
    //
    //      note:  init function itself must have a dumb
    //      wait to avoid race;  this can be as simple
    //      as sleep\test loop
    //
    //  multilevel init:
    //      have a bunch of levels of init
    //          - query (registry stuff)
    //          - update
    //          - secure update
    //
    //      call would add the init for the level required
    //      this would need to be done under a lock to
    //      test, take lock, retest
    //
    //      could either take one CS on all inits (simple)
    //      or init only brings stuff on line
    //


    //
    //  check if already initialized to required level
    //      => if there we're done
    //
    //  note:  could check after lock for MT, but not
    //      unlikely and not much perf benefit over
    //      individual checks
    //

    if ( (g_InitLevel & InitLevel) == InitLevel )
    {
        return( TRUE );
    }

    EnterCriticalSection( &g_GeneralCS );

    //
    //  heap
    //

    status = Heap_Initialize();
    if ( status != NO_ERROR )
    {
        goto Failed;
    }

#if DBG
    //
    //  init debug logging
    //      - do for any process beyond simple attach
    //
    //  start logging with log filename generated to be
    //      unique for this process
    //
    //  do NOT put drive specification in the file path
    //  do NOT set the debug flag -- the flag is read from the dnsapi.flag file
    //

    if ( !(g_InitLevel & INITLEVEL_DEBUG) )
    {
        CHAR    szlogFileName[ 30 ];

        sprintf(
            szlogFileName,
            "dnsapi.%d.log",
            GetCurrentProcessId() );

        Dns_StartDebug(
            0,
            "dnsapi.flag",
            NULL,
            szlogFileName,
            2000000             // 2mb wrap
            );

        g_InitLevel |= INITLEVEL_DEBUG;
    }
#endif

    //
    //  general query service
    //      - need registry info
    //      - need adapter list info (servlist.c)
    //
    //  DCR:  even query level doesn't need full registry info
    //          if either queries through cache OR gets netinfo from cache
    //
    //  note:  do NOT initialize winsock here
    //      WSAStartup() in dll init routine is strictly verboten
    //

    if ( (InitLevel & INITLEVEL_QUERY) &&
         !(g_InitLevel & INITLEVEL_QUERY) )
    {
        //
        //  Init registry lookup
        //

        status = Reg_ReadGlobalsEx( 0, NULL );
        if ( status != ERROR_SUCCESS )
        {
            ASSERT( FALSE );
            goto Failed;
        }

        //
        //  net failure caching
        //

        g_NetFailureTime = 0;
        g_NetFailureStatus = ERROR_SUCCESS;

        //
        //  init CS to protect adapter list global
        //

        InitNetworkInfo();
        
        //
        //  set the query timeouts
        //

        Dns_InitQueryTimeouts();


        //  indicate query init complete

        g_InitLevel |= INITLEVEL_QUERY;

        DNSDBG( INIT, ( "Query\\Config init is complete.\n" ));
    }

    //
    //  secure update?
    //      - init security CS
    //  note, this already has built in protection -- it doesn't init
    //  the package, just the CS, which protects package init
    //

    if ( (InitLevel & INITLEVEL_SECURE_UPDATE) &&
         !(g_InitLevel & INITLEVEL_SECURE_UPDATE ) )
    {
        Dns_StartSecurity(
            TRUE    // process attach
            );
        g_InitLevel |= INITLEVEL_SECURE_UPDATE;

        DNSDBG( INIT, ( "Secure update init is complete.\n" ));
    }

    //
    //  clear global CS
    //

    LeaveCriticalSection( &g_GeneralCS );

    return( TRUE );

Failed:

    LeaveCriticalSection( &g_GeneralCS );

    return( FALSE );
}



VOID
cleanupForExit(
    VOID
    )
/*++

Routine Description:

    Cleanup for DLL unload.
    Cleanup memory and handles dnsapi.dll allocated.

Arguments:

    None.

Return Value:

    None.

--*/
{
    //
    //  unload security packages used by secure dynamic update.
    //

    if ( g_InitLevel & INITLEVEL_SECURE_UPDATE )
    {
        Dns_TerminateSecurityPackage();
    }

    //
    //  registration stuff
    //

    Dhcp_RegCleanupForUnload();
    DhcpSrv_Cleanup();

    //
    //  query stuff
    //

    if ( g_InitLevel & INITLEVEL_QUERY )
    {
        //
        //  clean up Server/Net Adapter lists
        //
    
        CleanupNetworkInfo();

        Socket_CacheCleanup();

        Socket_CleanupWinsock();

#if 0
        if ( g_pwsRemoteResolver )
        {
            FREE_HEAP( g_pwsRemoteResolver );
        }
#endif
    }

    //
    //  unload IP Help
    //

    IpHelp_Cleanup();

    //
    //  tracing
    //

    Trace_Cleanup();

    //
    //  cleanup heap
    //

    Heap_Cleanup();

    //
    //  kill general CS
    //

    if ( g_InitLevel & INITLEVEL_BASE )
    {
        DeleteCriticalSection( &g_GeneralCS );
    }

    g_InitLevel = 0;
}



//
//  Main dnsapi.dll routines
//

__declspec(dllexport)
BOOL
WINAPI
DnsDllInit(
    IN      HINSTANCE       hInstance,
    IN      DWORD           Reason,
    IN      PVOID           pReserved
    )
/*++

Routine Description:

    Dll attach entry point.

Arguments:

    hinstDll -- instance handle of attach

    Reason -- reason for attach
        DLL_PROCESS_ATTACH, DLL_PROCESS_DETACH, etc.

    Reserved -- unused

Return Value:

    TRUE if successful.
    FALSE on error.

--*/
{
    //
    //  on process attach
    //      - disable thread notifications
    //      - save instance handle
    //      - do minimum DLL initialization
    //

    if ( Reason == DLL_PROCESS_ATTACH )
    {
        if ( ! DisableThreadLibraryCalls( hInstance ) )
        {
            return( FALSE );
        }
        g_hInstanceDll = hInstance;

        return startInit();
    }

    //
    //  on process detach
    //      - cleanup IF pReserved==NULL which indicates detach due
    //      to FreeLibrary
    //      - if process is exiting do nothing
    //

    if ( Reason == DLL_PROCESS_DETACH
            &&
         pReserved == NULL )
    {
        cleanupForExit();
    }

    return TRUE;
}

//
//  End dll.c
//
=== C:/Users/treeman/Desktop/windows nt source code\Source\Win2K3\NT\ds\dns\dnsapi\dnsmem.h ===
/*++

Copyright (c) 1997 Microsoft Corporation

Module Name:

    dnsmem.h

Abstract:

    Domain Name System (DNS) Library

    Memory routines declarations.

Author:

    Jim Gilroy (jamesg)     January 1997

Revision History:

--*/

#ifndef _DNS_MEMORY_INCLUDED_
#define _DNS_MEMORY_INCLUDED_



//
//  Ram's leak tracking debug routines
//  Changes made here to be exportable to dns server end

LPVOID
DnsApiAlloc(
    DWORD cb
    );

#if  DBG
LPVOID
DebugDnsApiAlloc(
    CHAR*,
    int,
    DWORD cb
);
#endif

#if  DBG
BOOL
DebugDnsApiFree(
    LPVOID
    );
#endif

BOOL
DnsApiFree(
    LPVOID pMem
    );

//
// Dont care about ReAlloc because it is not exported to server
// side. May need to fix this if this is changed at a future point
//

#if  DBG
LPVOID
DebugDnsApiReAlloc(
    CHAR*,
    int,
    LPVOID pOldMem,
    DWORD cbOld,
    DWORD cbNew
    );
#define  DnsApiReAlloc( pOldMem, cbOld, cbNew ) DebugDnsApiReAlloc( __FILE__, __LINE__, pOldMem, cbOld, cbNew )
#else
LPVOID
DnsApiReAlloc(
    LPVOID pOldMem,
    DWORD cbOld,
    DWORD cbNew
    );
#endif


#if DBG

extern LIST_ENTRY DnsMemList ;
extern CRITICAL_SECTION DnsMemCritSect ;

VOID InitDnsMem(
    VOID
    );

VOID AssertDnsMemLeaks(
    VOID
    );

VOID
DumpMemoryTracker(
    VOID
    );


#else
//
//  non-debug, macroize away heap tracking
//
#define InitDnsMem()
#define AssertDnsMemLeaks()
#define DumpMemoryTracker()
#endif


//
//  DCR:  a better idea is just to call DnsApiHeapReset (if necessary)
//      to install any underlying allocators you want
//
//      then just cover the standard macros for your debug builds
//

#define DNS_ALLOCATE_HEAP(size)              DnsApiAlloc(size)
#define DNS_FREE_HEAP(p)                     DnsApiFree(p)


#endif  //  _DNS_MEMORY_INCLUDED_
=== C:/Users/treeman/Desktop/windows nt source code\Source\Win2K3\NT\ds\dns\dnsapi\dnsapip.h ===
/*++

Copyright (c) 1996-2002  Microsoft Corporation

Module Name:

    dnsapip.h

Abstract:

    Domain Name System (DNS) API

    DNS API Private routines.

    These are internal routines for dnsapi.dll AND some exported
    routines for private use by DNS components which need not or
    should not be exposed in public dnsapi.h header.

Author:

    Jim Gilroy (jamesg)     December 7, 1996

Revision History:

--*/


#ifndef _DNSAPIP_INCLUDED_
#define _DNSAPIP_INCLUDED_

#include <winsock2.h>
#include <ws2tcpip.h>
#include <iptypes.h>
#include <dnsapi.h>
#include <dnslib.h>
#include <iphlpapi.h>
#include <align.h>
#define  DNS_ADDR_DEFINED_IP6 1
#include "dnsip.h"


#ifdef __cplusplus
extern "C"
{
#endif  // __cplusplus


//
//  DCR:   add to winerror.h
//

#define DNS_ERROR_REFERRAL_RESPONSE     9506L


//
//  Service stuff
//

//  defined in resrpc.h
//#define DNS_RESOLVER_SERVICE    L"dnscache"
#define DNS_SERVER_SERVICE      L"dns"


//
//  Multicast address defs
//

#define MCAST_PORT_NET_ORDER    (0x3535)        // 5353

#define MCAST_IP4_ADDRESS       (0xfb0000e0)    // 224.0.0.251. 


//
//  Internal address defs
//      - using DNS_ADDR

typedef DNS_ADDR_ARRAY  ADDR_ARRAY, *PADDR_ARRAY;


//
//  Address flag mappings
//      - currently carrying IP help flags directly

#define DNSADDR_FLAG_PUBLIC             IP_ADAPTER_ADDRESS_DNS_ELIGIBLE
#define DNSADDR_FLAG_TRANSIENT          IP_ADAPTER_ADDRESS_TRANSIENT

#define DNSADDR_FLAG_TYPE_MASK          (DNSADDR_FLAG_PUBLIC | DNSADDR_FLAG_TRANSIENT)

//
//  Default matching for our addr operations is just IP address.
//      - not sockaddr fields, not port, not subnet.
//

#define DAMT    DNSADDR_MATCH_IP

#define DAddr_IsEqual(a,b)                          DnsAddr_IsEqual( a, b, DAMT )

#define AddrArray_ContainsAddr( a, pa )             DnsAddrArray_ContainsAddr( a, pa, DAMT )

#define AddrArray_AddAddr( a, pa )                  DnsAddrArray_AddAddr( a, pa, 0, DAMT )                
#define AddrArray_AddSockaddr( a, pa, fam )         DnsAddrArray_AddSockaddr( a, pa, fam, DAMT )                
#define AddrArray_DeleteAddr( a, pa )               DnsAddrArray_DeleteAddr( a, p, DAMT )
#define AddrArray_DeleteIp6( a, p6 )                DnsAddrArray_DeleteIp6( a, p6, DAMT )                
#define AddrArray_DeleteIp4( a, ip4 )               DnsAddrArray_DeleteIp4( a, ip4, DAMT )               

#define AddrArray_Diff( a1, a2, oa1, oa2, oai )     DnsAddrArray_Diff( a1, a2, DAMT, oa1, oa2, oai )
#define AddrArray_IsIntersection( a1, a2 )          DnsAddrArray_IsIntersection( a1, a2, DAMT )          
#define AddrArray_IsEqual( a1, a2 )                 DnsAddrArray_IsEqual( a1, a2, DAMT )                 


//
//  Message Addressing
//

#define MSG_SOCKADDR_IS_IP4(pMsg)   DNS_ADDR_IS_IP4( &(pMsg)->RemoteAddress )
#define MSG_SOCKADDR_IS_IP6(pMsg)   DNS_ADDR_IS_IP6( &(pMsg)->RemoteAddress )

#define MSG_REMOTE_FAMILY(pMsg)  \
        ( (pMsg)->RemoteAddress.Sockaddr.sa_family )

#define MSG_REMOTE_IP_PORT(pMsg)  \
        ( (pMsg)->RemoteAddress.SockaddrIn.sin_port )
        
#define MSG_REMOTE_IPADDR_STRING(pMsg)  \
        DnsAddr_Ntoa( &(pMsg)->RemoteAddress )


//
//  Callback function defs
//
//  These allow dnsapi.dll code to be executed with callbacks
//  into the resolver where behavior should differ for
//  execution in resolver context.
//

typedef BOOL (* QUERY_CACHE_FUNC)( PVOID );

//
//  Private query flags
//

#define DNSP_QUERY_NO_GENERIC_NAMES     0x08000000
#define DNSP_QUERY_INCLUDE_CLUSTER      0x10000000



//
//  Results info
//

typedef struct  _BasicResults
{
    DNS_STATUS      Status;
    DWORD           Rcode;
    DNS_ADDR        ServerAddr;
}
BASIC_RESULTS, *PBASIC_RESULTS;

typedef struct _DnsResults
{
    DNS_STATUS          Status;
    WORD                Rcode;
    DNS_ADDR            ServerAddr;

    PDNS_RECORD         pAnswerRecords;
    PDNS_RECORD         pAliasRecords;
    PDNS_RECORD         pAuthorityRecords;
    PDNS_RECORD         pAdditionalRecords;
    PDNS_RECORD         pSigRecords;

    PDNS_MSG_BUF        pMessage;
}
DNS_RESULTS, *PDNS_RESULTS;

typedef struct _ResultBlob
{
    DNS_STATUS          Status;
    WORD                Rcode;
    DNS_ADDR            ServerAddr;

    PDNS_RECORD         pRecords;
    PDNS_MSG_BUF        pMessage;
    BOOL                fHaveResponse;
}
RESULT_BLOB, *PRESULT_BLOB;


//
//  Send info
//

typedef struct _SendBlob
{
    PDNS_NETINFO        pNetInfo;
    PDNS_ADDR_ARRAY     pServerList;
    PIP4_ARRAY          pServ4List;
    PDNS_MSG_BUF        pSendMsg;
    PDNS_MSG_BUF        pRecvMsgBuf;

    DWORD               Flags;
    BOOL                fSaveResponse;
    BOOL                fSaveRecords;

    RESULT_BLOB         Results;
}
SEND_BLOB, *PSEND_BLOB;


//
//  Query blob
//

#ifdef PQUERY_BLOB    
#undef PQUERY_BLOB    
#endif

typedef struct _QueryBlob
{
    //  query data

    PWSTR               pNameOrig;
    PWSTR               pNameQuery;
    WORD                wType;
    WORD                Reserved1;
    DWORD               Flags;
    //16

    //  query name info

    DWORD               NameLength;
    DWORD               NameAttributes;
    DWORD               QueryCount;
    DWORD               NameFlags;
    //32
    BOOL                fAppendedName;

    //  return info

    DWORD               Status;
    WORD                Rcode;
    WORD                Reserved2;
    DWORD               NetFailureStatus;
    //48
    BOOL                fCacheNegative;
    BOOL                fNoIpLocal;

    //  remove these once results fixed up

    PDNS_RECORD         pRecords;
    PDNS_RECORD         pLocalRecords;
    //64

    //  control info

    PDNS_NETINFO        pNetInfo;
    PDNS_ADDR_ARRAY     pServerList;
    PIP4_ARRAY          pServerList4;
    HANDLE              hEvent;
    //80

    QUERY_CACHE_FUNC    pfnQueryCache;
    //IS_CLUSTER_IP_FUNC  pfnIsClusterIp;
    BOOL                fFilterCluster;

    //  result info

    PDNS_MSG_BUF        pSendMsg;
    PDNS_MSG_BUF        pRecvMsg;

    DNS_RESULTS         Results;
    DNS_RESULTS         BestResults;

    //  buffers

    WCHAR               NameBuffer[ DNS_MAX_NAME_BUFFER_LENGTH ];
    CHAR                NameBufferAnsi[ DNS_MAX_NAME_BUFFER_LENGTH ];

    //  DCR:  could do a message here
}
QUERY_BLOB, *PQUERY_BLOB;


//
//  System event notification routine (PnP) (svccntl.c)
//

DWORD
_fastcall
SendServiceControl(
    IN  PWSTR   pszServiceName,
    IN  DWORD   dwControl
    );

//
//  Poke ops
//

#define POKE_OP_UPDATE_NETINFO      (0x2f0d7831)

#define POKE_COOKIE_UPDATE_NETINFO  (0x4598efab)


//
//  Network Info
//

//
//  Static netinfo flags
//

#define NINFO_FLAG_DUMMY_SEARCH_LIST        (0x00000001)
#define NINFO_FLAG_ALLOW_MULTICAST          (0x00000100)
#define NINFO_FLAG_MULTICAST_ON_NAME_ERROR  (0x00000200)
#define NINFO_FLAG_NO_DNS_SERVERS           (0x10000000)

//
//  Static adapter info flags
//

#define AINFO_FLAG_IS_WAN_ADAPTER           (0x00000002)
#define AINFO_FLAG_IS_AUTONET_ADAPTER       (0x00000004)
#define AINFO_FLAG_IS_DHCP_CFG_ADAPTER      (0x00000008)

#define AINFO_FLAG_REGISTER_DOMAIN_NAME     (0x00000010)
#define AINFO_FLAG_REGISTER_IP_ADDRESSES    (0x00000020)

#define AINFO_FLAG_AUTO_SERVER_DETECTED     (0x00000400)

#define AINFO_FLAG_SERVERS_UNREACHABLE      (0x00001000)
#define AINFO_FLAG_SERVERS_AUTO_LOOPBACK    (0x00010000)
#define AINFO_FLAG_SERVERS_IP6_DEFAULT      (0x00100000)
#define AINFO_FLAG_IGNORE_ADAPTER           (0x01000000)


//
//  Runtime netinfo flags
//
//  These flags are mostly for adapter info.
//  Exceptions:
//      - RESET_SERVER_PRIORITY is overloaded, used
//      on both netinfo and adapter
//      - NETINFO_PREPARED only on netinfo to indicate
//      it is ready
//
//  DCR:  no runtime ignore\disable
//      not yet using runtime ignore disable flag
//      when do should create combined
//

#define RUN_FLAG_SENT_THIS_RETRY            (0x00000001)
#define RUN_FLAG_SENT                       (0x00000010)
#define RUN_FLAG_HAVE_VALID_RESPONSE        (0x00000100)
#define RUN_FLAG_STOP_QUERY_ON_ADAPTER      (0x00001000)
#define RUN_FLAG_NETINFO_PREPARED           (0x00010000)

#define RUN_FLAG_QUERIED_ADAPTER_DOMAIN     (0x00100000)
#define RUN_FLAG_RESET_SERVER_PRIORITY      (0x01000000)
#define RUN_FLAG_IGNORE_ADAPTER             (0x10000000)

#define RUN_FLAG_RETRY_MASK                 (0x0000000f)
#define RUN_FLAG_SINGLE_NAME_MASK           (0x000fffff)
#define RUN_FLAG_QUERY_MASK                 (0x0fffffff)


//  Create cleanup "levels" as mask of bits to keep
//  These are the params to NetInfo_Clean()

#define CLEAR_LEVEL_ALL                     (0)
#define CLEAR_LEVEL_QUERY                   (~RUN_FLAG_QUERY_MASK)
#define CLEAR_LEVEL_SINGLE_NAME             (~RUN_FLAG_SINGLE_NAME_MASK)
#define CLEAR_LEVEL_RETRY                   (~RUN_FLAG_RETRY_MASK)
        
        
VOID
NetInfo_Free(
    IN OUT  PDNS_NETINFO    pNetInfo
    );

PDNS_NETINFO     
NetInfo_Copy(
    IN      PDNS_NETINFO    pNetInfo
    );

PDNS_NETINFO     
NetInfo_Build(
    IN      BOOL            fGetIpAddrs
    );

VOID
NetInfo_Clean(
    IN OUT  PDNS_NETINFO    pNetInfo,
    IN      DWORD           ClearLevel
    );
        
VOID
NetInfo_ResetServerPriorities(
    IN OUT  PDNS_NETINFO    pNetInfo,
    IN      BOOL            fLocalDnsOnly
    );


#define NetInfo_GetAdapterByIndex(pni,i)    (&(pni)->AdapterArray[i])



//
//  Query (query.c)
//

#define DNS_ERROR_NAME_NOT_FOUND_LOCALLY    DNS_ERROR_RECORD_DOES_NOT_EXIST


//
//  Main query routine to DNS servers
//
//  Called both internally and from resolver
//

DNS_STATUS
Query_Main(
    IN OUT  PQUERY_BLOB     pBlob
    );

DNS_STATUS
Query_SingleName(
    IN OUT  PQUERY_BLOB     pBlob
    );

VOID
CombineRecordsInBlob(
    IN      PDNS_RESULTS    pResults,
    OUT     PDNS_RECORD *   ppRecords
    );

VOID
BreakRecordsIntoBlob(
    OUT     PDNS_RESULTS    pResults,
    IN      PDNS_RECORD     pRecords,
    IN      WORD            wType
    );

DNS_STATUS
Local_GetRecordsForLocalName(
    IN OUT  PQUERY_BLOB     pBlob
    );


//
//  Called by dnsup.c
//

DNS_STATUS
QueryDirectEx(
    IN OUT  PDNS_MSG_BUF *      ppMsgResponse,
    OUT     PDNS_RECORD *       ppResponseRecords,
    IN      PDNS_HEADER         pHeader,
    IN      BOOL                fNoHeaderCounts,
    IN      PSTR                pszQuestionName,
    IN      WORD                wQuestionType,
    IN      PDNS_RECORD         pRecords,
    IN      DWORD               dwFlags,
    IN      PIP4_ARRAY          aipDnsServers,
    IN OUT  PDNS_NETINFO        pNetworkInfo
    );


//
//  Update (update.c)
//

//
//  Private update blob
//

typedef struct _UpdateBlob
{
    //  update request

    PDNS_RECORD         pRecords;
    DWORD               Flags;
    BOOL                fUpdateTestMode;
    BOOL                fSaveRecvMsg;
    BOOL                fSavedResults;

    HANDLE              hCreds;
    PDNS_EXTRA_INFO     pExtraInfo;

    PDNS_NETINFO        pNetInfo;
    PWSTR               pszZone;
    PWSTR               pszServerName;
    PDNS_ADDR_ARRAY     pServerList;
    PIP4_ARRAY          pServ4List;

    PDNS_MSG_BUF        pMsgRecv;

    DNS_ADDR            FailedServer;
    BASIC_RESULTS       Results;
}
UPDATE_BLOB, *PUPDATE_BLOB;


//
//  Called by dnsup.exe
//

DNS_STATUS
DnsUpdate(
    IN      PDNS_RECORD         pRecord,
    IN      DWORD               dwFlags,
    IN      PDNS_NETINFO        pNetworkInfo,
    IN      HANDLE              hCreds,
    OUT     PDNS_MSG_BUF *      ppMsgRecv       OPTIONAL
    );


//
//  Sockets (socket.c)
//

DNS_STATUS
Socket_InitWinsock(
    VOID
    );

VOID
Socket_CleanupWinsock(
    VOID
    );

SOCKET
Socket_Create(
    IN      INT             Family,
    IN      INT             SockType,
    IN      PDNS_ADDR       pBindAddr,
    IN      USHORT          Port,
    IN      DWORD           dwFlags
    );

SOCKET
Socket_CreateMulticast(
    IN      INT             SockType,
    IN      PDNS_ADDR       pAddr,
    IN      WORD            Port,
    IN      BOOL            fSend,
    IN      BOOL            fReceive
    );

DNS_STATUS
Socket_CacheInit(
    IN      DWORD           MaxSocketCount
    );

VOID
Socket_CacheCleanup(
    VOID
    );

VOID
Socket_ClearMessageSockets(
    IN OUT  PDNS_MSG_BUF    pMsg
    );

VOID
Socket_CloseMessageSockets(
    IN OUT  PDNS_MSG_BUF    pMsg
    );

VOID
Socket_CloseEx(
    IN      SOCKET          Socket,
    IN      BOOL            fShutdown
    );

#define Socket_CloseConnection( sock )  Socket_CloseEx( sock, TRUE )
#define Socket_Close( sock )            Socket_CloseEx( sock, FALSE )


//
//  Send\recv (send.c)
//

DNS_STATUS
Send_AndRecvUdpWithParam(
    IN OUT  PDNS_MSG_BUF    pMsgSend,
    OUT     PDNS_MSG_BUF    pMsgRecv,
    IN      DWORD           dwFlags,
    IN      PDNS_ADDR_ARRAY pServerList,
    IN OUT  PDNS_NETINFO    pNetInfo
    );

DNS_STATUS
Send_OpenTcpConnectionAndSend(
    IN OUT  PDNS_MSG_BUF    pMsg,
    IN      PDNS_ADDR       pIpServer,
    IN      BOOL            fBlocking
    );

DNS_STATUS
Send_AndRecvTcp(
    IN OUT  PSEND_BLOB      pBlob
    );

DNS_STATUS
Send_AndRecv(
    IN OUT  PSEND_BLOB      pBlob
    );

DNS_STATUS
Send_MessagePrivate(
    IN OUT  PDNS_MSG_BUF    pMsg,
    IN      PDNS_ADDR       pSendAddr,
    IN      BOOL            fNoOpt
    );


//
//  Host file (hostfile.c)
//

#define MAXALIASES                  (8)
#define MAX_HOST_FILE_LINE_SIZE     (1000)     

typedef struct _HostFileInfo
{
    FILE *          hFile;
    PSTR            pszFileName;

    //  build records

    BOOL            fBuildRecords;

    //  record results

    PDNS_RECORD     pForwardRR;
    PDNS_RECORD     pReverseRR;
    PDNS_RECORD     pAliasRR;

    //  line data

    PCHAR           pAddrString;
    PCHAR           pHostName;
    PCHAR           AliasArray[ MAXALIASES+1 ];
    DNS_ADDR        Addr;

    CHAR            HostLineBuf[ MAX_HOST_FILE_LINE_SIZE+1 ];
}
HOST_FILE_INFO, *PHOST_FILE_INFO;


BOOL
HostsFile_Open(
    IN OUT  PHOST_FILE_INFO pHostInfo
    );

VOID
HostsFile_Close(
    IN OUT  PHOST_FILE_INFO pHostInfo
    );

BOOL
HostsFile_ReadLine(
    IN OUT  PHOST_FILE_INFO pHostInfo
    );


//
//  Debug sharing 
//

PDNS_DEBUG_INFO
DnsApiSetDebugGlobals(
    IN OUT  PDNS_DEBUG_INFO pInfo
    );


//
//  Utils (util.c)

BOOL
Util_IsIp6Running(
    VOID
    );



//
//  Dnsapi.h publics restricted by netinfo def
//

//  Used in resolver

DNS_STATUS
Dns_FindAuthoritativeZoneLib(
    IN      PDNS_NAME       pszName,
    IN      DWORD           dwFlags,
    IN      PIP4_ARRAY      aipQueryServers,
    OUT     PDNS_NETINFO *  ppNetworkInfo
    );

DNS_STATUS
Dns_UpdateLib(
    IN      PDNS_RECORD     pRecord,
    IN      DWORD           dwFlags,
    IN      PDNS_NETINFO    pNetworkInfo,
    IN      HANDLE          hCreds,         OPTIONAL
    OUT     PDNS_MSG_BUF *  ppMsgRecv       OPTIONAL
    );

//  Used in dnslib (security.c)





//
//  DnsLib routines
//
//  dnslib.lib routines that depend on client only definitions
//  and hence not defined in server space.
//  Note, these could be moved to dnslibp.h with some sort of
//  #define for client only builds, or #define that the type
//  definition has been picked up from resrpc.h
//

//
//  Printing of private dnsapi types (dnslib\print.c)
//

VOID
DnsPrint_NetworkInfo(
    IN      PRINT_ROUTINE   PrintRoutine,
    IN OUT  PVOID           pContext,
    IN      LPSTR           pszHeader,
    IN      PDNS_NETINFO    pNetworkInfo
    );

VOID
DnsPrint_AdapterInfo(
    IN      PRINT_ROUTINE   PrintRoutine,
    IN OUT  PPRINT_CONTEXT  pContext,
    IN      LPSTR           pszHeader,
    IN      PDNS_ADAPTER    pAdapterInfo
    );

VOID
DnsPrint_SearchList(
    IN      PRINT_ROUTINE   PrintRoutine,
    IN OUT  PPRINT_CONTEXT  pContext,
    IN      LPSTR           pszHeader,
    IN      PSEARCH_LIST    pSearchList
    );

VOID
DnsPrint_SendBlob(
    IN      PRINT_ROUTINE   PrintRoutine,
    IN OUT  PPRINT_CONTEXT  pContext,
    IN      PSTR            pszHeader,
    IN      PSEND_BLOB      pBlob
    );

VOID
DnsPrint_QueryBlob(
    IN      PRINT_ROUTINE   PrintRoutine,
    IN OUT  PPRINT_CONTEXT  pContext,
    IN      PSTR            pszHeader,
    IN      PQUERY_BLOB     pQueryBlob
    );

VOID
DnsPrint_QueryInfo(
    IN      PRINT_ROUTINE   PrintRoutine,
    IN OUT  PPRINT_CONTEXT  pContext,
    IN      PSTR            pszHeader,
    IN      PDNS_QUERY_INFO pQueryInfo
    );

VOID
DnsPrint_ExtraInfo(
    IN      PRINT_ROUTINE       PrintRoutine,
    IN OUT  PPRINT_CONTEXT      pContext,
    IN      PSTR                pszHeader,
    IN      PDNS_EXTRA_INFO     pInfo
    );

VOID
DnsPrint_ResultsBasic(
    IN      PRINT_ROUTINE       PrintRoutine,
    IN OUT  PPRINT_CONTEXT      pContext,
    IN      PSTR                pszHeader,
    IN      PBASIC_RESULTS      pResults
    );

VOID
DnsPrint_UpdateBlob(
    IN      PRINT_ROUTINE       PrintRoutine,
    IN OUT  PPRINT_CONTEXT      pContext,
    IN      PSTR                pszHeader,
    IN      PUPDATE_BLOB        pBlob
    );

#if DBG

#define DnsDbg_NetworkInfo(a,b)         DnsPrint_NetworkInfo(DnsPR,NULL,(a),(b))
#define DnsDbg_AdapterInfo(a,b)         DnsPrint_AdapterInfo(DnsPR,NULL,(a),(b))
#define DnsDbg_SearchList(a,b)          DnsPrint_SearchList(DnsPR,NULL,(a),(b))
#define DnsDbg_Addr4Array(a,b)          DnsPrint_Addr4Array(DnsPR,NULL,a,b)

#define DnsDbg_ResultsBasic(a,b)        DnsPrint_ResultsBasic(DnsPR,NULL,(a),(b))
#define DnsDbg_ExtraInfo(a,b)           DnsPrint_ExtraInfo(DnsPR,NULL,(a),(b))
#define DnsDbg_SendBlob(a,b)            DnsPrint_SendBlob(DnsPR,NULL,(a),(b))
#define DnsDbg_QueryBlob(a,b)           DnsPrint_QueryBlob(DnsPR,NULL,(a),(b))
#define DnsDbg_QueryInfo(a,b)           DnsPrint_QueryInfo(DnsPR,NULL,(a),(b))
#define DnsDbg_UpdateBlob(a,b)          DnsPrint_UpdateBlob(DnsPR,NULL,(a),(b))

#else   // retail

#define DnsDbg_NetworkInfo(a,b)
#define DnsDbg_AdapterInfo(a,b)
#define DnsDbg_SearchList(a,b)
#define DnsDbg_Addr4Array(a,b)

#define DnsDbg_ResultsBasic(a,b)
#define DnsDbg_ExtraInfo(a,b)
#define DnsDbg_SendBlob(a,b)
#define DnsDbg_QueryBlob(a,b)
#define DnsDbg_QueryInfo(a,b)
#define DnsDbg_UpdateBlob(a,b)

#endif


//
//  Debugging flags private to resolver\dnsapi
//
//  Note:  other private flags should be moved here
//

#define DNS_DBG_MCAST           0x00008000


#ifdef __cplusplus
}
#endif  // __cplusplus

#endif // _DNSAPIP_INCLUDED_
=== C:/Users/treeman/Desktop/windows nt source code\Source\Win2K3\NT\ds\dns\dnsapi\dnsapi.c ===
/*++

Copyright (c) 1996-2002 Microsoft Corporation

Module Name:

    dnsapi.c

Abstract:

    Domain Name System (DNS) API

    Random DNS API routines.

Author:

    GlennC      22-Jan-1997

Revision History:

    Jim Gilroy (jamesg)     March 2000      cleanup
    Jim Gilroy (jamesg)     May 2002        security\robustness fixups

--*/


#include "local.h"
#include <lmcons.h>


#define DNS_NET_FAILURE_CACHE_TIME      30  // Seconds


//
//  Globals
//

DWORD               g_NetFailureTime;
DNS_STATUS          g_NetFailureStatus;

IP4_ADDRESS         g_LastDNSServerUpdated = 0;



//
//  Net failure caching
//

BOOL
IsKnownNetFailure(
    VOID
    )
/*++

Routine Description:

    None.

Arguments:

    None.

Return Value:

    None.

--*/
{
    BOOL flag = FALSE;

    DNSDBG( TRACE, ( "IsKnownNetFailure()\n" ));

    LOCK_GENERAL();

    if ( g_NetFailureStatus )
    {
        if ( g_NetFailureTime < Dns_GetCurrentTimeInSeconds() )
        {
            g_NetFailureTime = 0;
            g_NetFailureStatus = ERROR_SUCCESS;
            flag = FALSE;
        }
        else
        {
            SetLastError( g_NetFailureStatus );
            flag = TRUE;
        }
    }

    UNLOCK_GENERAL();

    return flag;
}


VOID
SetKnownNetFailure(
    IN      DNS_STATUS      Status
    )
/*++

Routine Description:

    None.

Arguments:

    None.

Return Value:

    None.

--*/
{
    DNSDBG( TRACE, ( "SetKnownNetFailure()\n" ));

    LOCK_GENERAL();

    g_NetFailureTime = Dns_GetCurrentTimeInSeconds() +
                       DNS_NET_FAILURE_CACHE_TIME;
    g_NetFailureStatus = Status;

    UNLOCK_GENERAL();
}


BOOL
WINAPI
DnsGetCacheDataTable(
    OUT     PDNS_CACHE_TABLE *  ppTable
    )
/*++

Routine Description:

    Get cache data table.

Arguments:

    ppTable -- address to receive ptr to cache data table

Return Value:

    ERROR_SUCCES if successful.
    Error code on failure.

--*/
{
    DNS_STATUS           status = ERROR_SUCCESS;
    DWORD                rpcStatus = ERROR_SUCCESS;
    PDNS_RPC_CACHE_TABLE pcacheTable = NULL;

    DNSDBG( TRACE, ( "DnsGetCacheDataTable()\n" ));

    if ( ! ppTable )
    {
        return FALSE;
    }

    RpcTryExcept
    {
        status = CRrReadCache( NULL, &pcacheTable );
    }
    RpcExcept( DNS_RPC_EXCEPTION_FILTER )
    {
        status = RpcExceptionCode();
    }
    RpcEndExcept

    //  set out param

    *ppTable = (PDNS_CACHE_TABLE) pcacheTable;

#if DBG
    if ( status != ERROR_SUCCESS )
    {
        DNSDBG( RPC, (
            "DnsGetCacheDataTable()  status = %d\n",
            status ));
    }
#endif

    return( pcacheTable && status == ERROR_SUCCESS );
}

//
//  End dnsapi.c
//
=== C:/Users/treeman/Desktop/windows nt source code\Source\Win2K3\NT\ds\dns\dnsapi\event.c ===
/*++

Copyright (c) 1996-1999  Microsoft Corporation

Module Name:

    event.c

Abstract:

    DNS event logging.

Author:

    Ramv      June-02-1997

Revision History:

--*/


#include "local.h"

#define  DNSAPI_LOG_SOURCE  (L"DnsApi")


//
//  Globals to suppress event logging
//

DWORD   g_TimeLastDnsEvent = 0;
DWORD   g_DnsEventCount = 0;

#define DNS_EVENTS_MAX_COUNT                (5)
#define DNS_EVENT_LOG_BLOCK_INTERVAL        (1800)      // 30 minutes



VOID
DnsLogEvent(
    IN      DWORD           MessageId,
    IN      WORD            EventType,
    IN      DWORD           NumberOfSubStrings,
    IN      PWSTR *         SubStrings,
    IN      DWORD           ErrorCode
    )
{
    HANDLE  logHandle;
    DWORD   dataLength = 0;
    PVOID   pdata = NULL;

    //
    //  protect against log spin
    //
    //  we'll allow a few events to log, then slam the door for
    //  a while to avoid filling event log
    //
    //  note:  none of these protection structures are MT safe, but
    //  there's no issue here, the failure mode is allowing an additional
    //  log entry or denying one that should now be allowed;  I don't
    //  believe there's any failure mode that permanently turns logging
    //  to always on or always off
    //

    if ( g_DnsEventCount > DNS_EVENTS_MAX_COUNT )
    {
        DWORD   currentTime = Dns_GetCurrentTimeInSeconds();
        if ( g_TimeLastDnsEvent + DNS_EVENT_LOG_BLOCK_INTERVAL > currentTime )
        {
            DNS_PRINT((
                "DNSAPI:  Refusing event logging!\n"
                "\tevent count  = %d\n"
                "\tlast time    = %d\n"
                "\tcurrent time = %d\n",
                g_DnsEventCount,
                g_TimeLastDnsEvent,
                currentTime ));
            return;
        }

        //  interval has elapsed, clear counters and continue logging

        g_DnsEventCount = 0;
    }

    //
    //  open event log
    //

    logHandle = RegisterEventSourceW(
                    NULL,
                    DNSAPI_LOG_SOURCE
                    );
    if ( logHandle == NULL )
    {
        DNS_PRINT(("DNSAPI : RegisterEventSourceA failed %lu\n",
                 GetLastError()));
        return;
    }

    //
    //  log the event
    //      - get ptr and sizeof data
    //

    if ( ErrorCode != NO_ERROR )
    {
        dataLength = sizeof(DWORD);
        pdata = (PVOID) &ErrorCode;
    }

    ReportEventW(
        logHandle,
        EventType,
        0,            // event category
        MessageId,
        (PSID) NULL,
        (WORD) NumberOfSubStrings,
        dataLength,
        SubStrings,
        pdata );

    DeregisterEventSource( logHandle );

    //
    //  successful logging spin protection
    //      - inc count
    //      - if at max, save last logging time
    //

    if ( ++g_DnsEventCount >= DNS_EVENTS_MAX_COUNT )
    {
        g_TimeLastDnsEvent = Dns_GetCurrentTimeInSeconds();
    }
}

//
//  End of event.c
//
=== C:/Users/treeman/Desktop/windows nt source code\Source\Win2K3\NT\ds\dns\dnsapi\dynreg.c ===
/*++

Copyright (c) 1997-2001 Microsoft Corporation

Module Name:

    dynreg.c

Abstract:

    Domain Name System (DNS) API 

    Dynamic registration implementation

Author:

    Ram Viswanathan (ramv)  March 27 1997

Revision History:

    Jim Gilroy (jamesg)     May 2001    proper cred handling

    Jim Gilroy (jamesg)     Dec 2001    init,shutdown,race protection

--*/

#include "local.h"

#define ENABLE_DEBUG_LOGGING 0

#include "logit.h"


//  hQuitEvent
//  hSem
//  handles
//  hConsumerThread
//  fStopNotify

HANDLE      g_DhcpSrvQuitEvent = NULL;
HANDLE      g_DhcpSrvSem = NULL;
HANDLE      g_DhcpSrvWaitHandles[2] = { NULL, NULL};
HANDLE      g_hDhcpSrvRegThread = NULL;
BOOL        g_fDhcpSrvStop = FALSE;

//  g_pdnsQueue
//  g_pDhcpSrvTimedOutQueue
//  g_QueueCount
//  g_MainQueueCount

PDYNDNSQUEUE    g_pDhcpSrvQueue = NULL;
PDYNDNSQUEUE    g_pDhcpSrvTimedOutQueue = NULL;
DWORD           g_DhcpSrvRegQueueCount = 0;
DWORD           g_DhcpSrvMainQueueCount = 0;
BOOL            g_fDhcpSrvQueueCsCreated = FALSE;

#define MAX_QLEN        0xFFFF
#define MAX_RETRIES     0x3

//
//  Max queue size
//      - configurable in init
//      - default 1K
//      - max 64K
//  

#define DHCPSRV_DEFAULT_MAX_QUEUE_SIZE      0x0400
#define DHCPSRV_MAX_QUEUE_SIZE              0xffff

DWORD           g_DhcpSrvMaxQueueSize = DHCPSRV_DEFAULT_MAX_QUEUE_SIZE;



//
//  protection for init\shutdown
//

BOOL                g_fDhcpSrvCsCreated = FALSE;
CRITICAL_SECTION    g_DhcpSrvCS;

#define DHCP_SRV_STATE_LOCK()       LockDhcpSrvState()
#define DHCP_SRV_STATE_UNLOCK()     LeaveCriticalSection( &g_DhcpSrvCS )


#define DNS_DHCP_SRV_STATE_UNINIT           0
#define DNS_DHCP_SRV_STATE_INIT_FAILED      1
#define DNS_DHCP_SRV_STATE_SHUTDOWN         2
#define DNS_DHCP_SRV_STATE_INITIALIZING     5
#define DNS_DHCP_SRV_STATE_SHUTTING_DOWN    6
#define DNS_DHCP_SRV_STATE_RUNNING          10
#define DNS_DHCP_SRV_STATE_QUEUING          11

DWORD   g_DhcpSrvState = DNS_DHCP_SRV_STATE_UNINIT;


//
//  Credentials for updates
//

PSEC_WINNT_AUTH_IDENTITY_W  g_pIdentityCreds = NULL;

//CredHandle g_CredHandle;

HANDLE  g_UpdateCredContext = NULL;


//
//  Queue allocations in dnslib heap
//

#define QUEUE_ALLOC_HEAP(Size)      Dns_Alloc(Size)
#define QUEUE_ALLOC_HEAP_ZERO(Size) Dns_AllocZero(Size)
#define QUEUE_FREE_HEAP(pMem)       Dns_Free(pMem)



//
// local helper functions
//

BOOL
LockDhcpSrvState(
    VOID
    );

DNS_STATUS
DynDnsRegisterEntries(
    VOID
    );




DNS_STATUS
DynDnsAddForward(
    IN OUT  REGISTER_HOST_ENTRY HostAddr,
    IN      LPWSTR              pszName,
    IN      DWORD               dwTTL,
    IN      PIP4_ARRAY          DnsServerList
    )
{
    DNS_STATUS  status = 0;
    DNS_RECORD  record;

    DYNREG_F1( "Inside function DynDnsAddForward" );

    RtlZeroMemory( &record, sizeof(DNS_RECORD) );

    record.pName = (PTCHAR) pszName;
    record.wType = DNS_TYPE_A;
    record.dwTtl = dwTTL;
    record.wDataLength = sizeof(record.Data.A);
    record.Data.A.IpAddress = HostAddr.Addr.ipAddr;

    DYNREG_F1( "DynDnsAddForward - Calling DnsReplaceRecordSet_W for A record:" );
    DYNREG_F2( "  Name: %S", record.pName );
    DYNREG_F2( "  Address: 0x%x", record.Data.A.IpAddress );

    status = DnsReplaceRecordSetW(
                & record,
                DNS_UPDATE_CACHE_SECURITY_CONTEXT,
                NULL,               // no security context
                (PIP4_ARRAY) DnsServerList,
                NULL                // reserved
                );

    DYNREG_F2( "DynDnsAddForward - DnsReplaceRecordSet returned status: 0%x", status );

    return( status );
}


DNS_STATUS
DynDnsDeleteForwards(
    IN      PDNS_RECORD     pDnsList,
    IN      IP4_ADDRESS     ipAddr,
    IN      PIP4_ARRAY      DnsServerList
    )
{
    DNS_STATUS  status = 0;
    PDNS_RECORD prr;
    DNS_RECORD  record;

    DYNREG_F1( "Inside function DynDnsDeleteForwards" );

    //
    // the list pointed to by pDnsList is a set of PTR records.
    //

    RtlZeroMemory( &record, sizeof(DNS_RECORD) );

    prr = pDnsList;

    for ( prr = pDnsList;
          prr;
          prr = prr->pNext )
    {
        if ( prr->wType != DNS_TYPE_PTR )
        {
            //
            // should not happen
            //
            continue;
        }

        //
        // As far as the DHCP server is concerned, when timeout happens
        // or when client releases an address, It can update the
        // address lookup to clean up turds left over by say, a roaming
        // laptop
        //

        record.pName = prr->Data.Ptr.pNameHost;
        record.wType = DNS_TYPE_A;
        record.wDataLength = sizeof(DNS_A_DATA);
        record.Data.A.IpAddress = ipAddr ;

        //
        // make the appropriate call and return the first failed error
        //

        DYNREG_F1( "DynDnsDeleteForwards - Calling ModifyRecords(Remove) for A record:" );
        DYNREG_F2( "  Name: %S", record.pName );
        DYNREG_F2( "  Address: 0x%x", record.Data.A.IpAddress );

        status = DnsModifyRecordsInSet_W(
                        NULL,                       // no add records
                        & record,                   // delete record
                        DNS_UPDATE_CACHE_SECURITY_CONTEXT,
                        NULL,                       // no security context
                        (PIP4_ARRAY) DnsServerList, // DNS servers
                        NULL                        // reserved
                        );

        if ( status != ERROR_SUCCESS )
        {
            //
            //  DCR_QUESTION:  do we really want to stop on failure?
            break;
        }
        DYNREG_F2( "DynDnsDeleteForwards - ModifyRecords(Remove) returned status: 0%x", status );
    }

    return( status );
}


DNS_STATUS
DynDnsAddEntry(
    REGISTER_HOST_ENTRY HostAddr,
    LPWSTR              pszName,
    DWORD               dwRegisteredTTL,
    BOOL                fDoForward,
    PDWORD              pdwFwdErrCode,
    PIP4_ARRAY          DnsServerList
    )
{
    DNS_STATUS  status = 0;
    DWORD       returnCode = 0;
    DNS_RECORD  record;
    WCHAR       reverseNameBuf[DNS_MAX_REVERSE_NAME_BUFFER_LENGTH];
    DWORD       cch;

    DYNREG_F1( "Inside function DynDnsAddEntry" );

    *pdwFwdErrCode = 0;

    if ( !(HostAddr.dwOptions & REGISTER_HOST_PTR) )
    {
        status = ERROR_INVALID_PARAMETER;
        goto Exit;
    }

    //
    //  create reverse lookup name for IP address
    //

    Dns_Ip4AddressToReverseName_W(
        reverseNameBuf,
        HostAddr.Addr.ipAddr );


    if ( fDoForward )
    {
        DYNREG_F1( "DynDnsAddEntry - Calling DynDnsAddForward" );

        //
        // we simply make a best case effort to do the forward add
        // if it fails, we simply ignore
        //

        returnCode = DynDnsAddForward(
                        HostAddr,
                        pszName,
                        dwRegisteredTTL,
                        DnsServerList );

        DYNREG_F2( "DynDnsAddEntry - DynDnsAddForward returned: 0%x",
                   returnCode );

        *pdwFwdErrCode = returnCode;
    }

    RtlZeroMemory( &record, sizeof(DNS_RECORD) );

    record.pName =  (PDNS_NAME) reverseNameBuf;
    record.dwTtl =  dwRegisteredTTL;
    record.wType =  DNS_TYPE_PTR;
    record.Data.Ptr.pNameHost = (PDNS_NAME)pszName;
    record.wDataLength = sizeof(record.Data.Ptr.pNameHost);

    DYNREG_F1( "DynDnsAddEntry - Calling DnsAddRecords_W for PTR record:" );
    DYNREG_F2( "  Name: %S", record.pName );
    DYNREG_F2( "  Ptr: %S", record.Data.Ptr.pNameHost );

    status = DnsModifyRecordsInSet_W(
                    & record,                   // add record
                    NULL,                       // no delete records
                    DNS_UPDATE_CACHE_SECURITY_CONTEXT,
                    NULL,                       // no context handle
                    (PIP4_ARRAY) DnsServerList, // DNS servers
                    NULL                        // reserved
                    );

    DYNREG_F2( "DynDnsAddEntry - DnsAddRecords_W returned status: 0%x", status );

Exit:

    return( status );
}


DNS_STATUS
DynDnsDeleteEntry(
    REGISTER_HOST_ENTRY HostAddr,
    LPWSTR              pszName,
    BOOL                fDoForward,
    PDWORD              pdwFwdErrCode,
    PIP4_ARRAY          DnsServerList
    )
{
    //
    // Brief Synopsis of functionality:
    // On DoForward try deleting the forward mapping. Ignore failure
    // Then try deleting the PTR record. If that fails
    // because server is down, try again, if it fails because the
    // operation was refused, then dont retry
    //

    DWORD       status = 0;
    DWORD       returnCode = 0;
    DNS_RECORD  recordPtr;
    DNS_RECORD  recordA;
    WCHAR       reverseNameBuf[DNS_MAX_REVERSE_NAME_BUFFER_LENGTH] ;
    INT         i;
    INT         cch;
    PDNS_RECORD precord = NULL;

    DYNREG_F1( "Inside function DynDnsDeleteEntry" );

    *pdwFwdErrCode = 0;

    //
    //  build reverse lookup name for IP
    //

    Dns_Ip4AddressToReverseName_W(
        reverseNameBuf,
        HostAddr.Addr.ipAddr);


    if ( fDoForward )
    {
        if ( pszName && *pszName )
        {
            //
            // we delete a specific forward. not all forwards as we do
            // when we do a query
            //

            RtlZeroMemory( &recordA, sizeof(DNS_RECORD) );

            recordA.pName = (PDNS_NAME) pszName;
            recordA.wType = DNS_TYPE_A;
            recordA.wDataLength = sizeof(DNS_A_DATA);
            recordA.Data.A.IpAddress = HostAddr.Addr.ipAddr;

            DYNREG_F1( "DynDnsDeleteEntry - Calling ModifyRecords(Remove) for A record:" );
            DYNREG_F2( "  Name: %S", recordA.pName );
            DYNREG_F2( "  Address: 0x%x", recordA.Data.A.IpAddress );

            //
            // make the appropriate call
            //

            returnCode = DnsModifyRecordsInSet_W(
                                NULL,                       // no add records
                                &recordA,                   // delete record
                                DNS_UPDATE_CACHE_SECURITY_CONTEXT,
                                NULL,                       // no security context
                                (PIP4_ARRAY) DnsServerList, // DNS servers
                                NULL                        // reserved
                                );

            DYNREG_F2( "DynDnsDeleteEntry - ModifyRecords(Remove) returned status: 0%x", returnCode );

            *pdwFwdErrCode = returnCode;
        }
        else
        {
            DYNREG_F1( "DynDnsDeleteEntry - Name not specified, going to query for PTR" );

            //
            //name not specified
            //
            status = DnsQuery_W(
                            reverseNameBuf,
                            DNS_TYPE_PTR,
                            DNS_QUERY_BYPASS_CACHE,
                            DnsServerList,
                            &precord,
                            NULL );

            DYNREG_F2( "DynDnsDeleteEntry - DnsQuery_W returned status: 0%x", status );

            switch ( status )
            {
                case DNS_ERROR_RCODE_NO_ERROR:

                    DYNREG_F1( "DynDnsDeleteEntry - Calling DynDnsDeleteForwards" );

                    returnCode = DynDnsDeleteForwards(
                                        precord,
                                        HostAddr.Addr.ipAddr,
                                        DnsServerList );

                    DYNREG_F2( "DynDnsDeleteEntry - DynDnsDeleteForwards returned status: 0%x", returnCode );

                    *pdwFwdErrCode = returnCode;

#if 0
                    switch ( returnCode )
                    {
                        case DNS_ERROR_RCODE_NO_ERROR:
                            //
                            // we succeeded, break out
                            //
                            break;

                        case DNS_ERROR_RCODE_REFUSED:
                            //
                            // nothing can be done
                            //
                            break;

                        case DNS_ERROR_RCODE_SERVER_FAILURE:
                        case ERROR_TIMEOUT:
                            //
                            // need to retry this again
                            //
                            // goto Exit; // if uncommented will force retry
                            break;

                        case DNS_ERROR_RCODE_NOT_IMPLEMENTED:
                        default:
                            //
                            // query itself failed. Nothing can be done
                            //
                            break;
                    }
#endif

                    break;

                default:
                    //
                    // caller takes care of each situation in turn
                    // PTR record cannot be queried for and hence
                    // cant be deleted
                    //
                    goto Exit;
            }
        }
    }

    //
    // delete PTR Record
    //

    if ( pszName && *pszName )
    {
        //
        // name is known
        //

        RtlZeroMemory( &recordPtr, sizeof(DNS_RECORD) );

        recordPtr.pName = (PDNS_NAME) reverseNameBuf;
        recordPtr.wType = DNS_TYPE_PTR;
        recordPtr.wDataLength = sizeof(DNS_PTR_DATA);
        recordPtr.Data.Ptr.pNameHost = (PDNS_NAME) pszName;

        DYNREG_F1( "DynDnsDeleteEntry - Calling ModifyRecords(Remove) for PTR record:" );
        DYNREG_F2( "  Name: %S", recordPtr.pName );
        DYNREG_F2( "  PTR : 0%x", recordPtr.Data.Ptr.pNameHost );

        status = DnsModifyRecordsInSet_W(
                            NULL,           // no add records
                            &recordPtr,     // delete record
                            DNS_UPDATE_CACHE_SECURITY_CONTEXT,
                            NULL,           // no security context
                            (PIP4_ARRAY) DnsServerList, // DNS servers
                            NULL            // reserved
                            );

        DYNREG_F2( "DynDnsDeleteEntry - ModifyRecords(Remove) returned status: 0%x", status );
    }
    else
    {
        DYNREG_F1( "DynDnsDeleteEntry - Calling ModifyRecords(Remove) for PTR record:" );

        if ( fDoForward && precord )
        {
            //
            //  remove record from the earlier query that you made
            //

            status = DnsModifyRecordsInSet_W(
                                NULL,           // no add records
                                precord,        // delete record from query
                                DNS_UPDATE_CACHE_SECURITY_CONTEXT,
                                NULL,           // no security context
                                (PIP4_ARRAY) DnsServerList,
                                NULL            // reserved
                                );
    
            DYNREG_F2( "DynDnsDeleteEntry - ModifyRecords(Remove) returned status: 0%x", status );
        }
        else
        {
            //
            //  name is NOT known
            //
            //  remove ALL records of PTR type
            //      - zero datalength indicates type delete
            //

            RtlZeroMemory( &recordPtr, sizeof(DNS_RECORD) );

            recordPtr.pName = (PDNS_NAME) reverseNameBuf;
            recordPtr.wType = DNS_TYPE_PTR;
            recordPtr.Data.Ptr.pNameHost = (PDNS_NAME) NULL;

            DYNREG_F1( "DynDnsDeleteEntry - Calling ModifyRecords(Remove) for ANY PTR records:" );
            DYNREG_F2( "  Name: %S", recordPtr.pName );
            DYNREG_F2( "  PTR : 0%x", recordPtr.Data.Ptr.pNameHost );

            status = DnsModifyRecordsInSet_W(
                                NULL,           // no add records
                                &recordPtr,     // delete record
                                DNS_UPDATE_CACHE_SECURITY_CONTEXT,
                                NULL,           // no security context
                                (PIP4_ARRAY) DnsServerList,
                                NULL            // reserved
                                );
    
            DYNREG_F2( "DynDnsDeleteEntry - ModifyRecords(Remove) returned status: 0%x", status );
        }
    }

Exit:

    if ( precord )
    {
        //  DCR:  need to fix this in Win2K
        //  
        //QUEUE_FREE_HEAP( precord );

        DnsRecordListFree(
            precord,
            DnsFreeRecordListDeep );
    }

    return( status );
}


DNS_STATUS
DynDnsRegisterEntries(
    VOID
    )

/*
  DynDnsRegisterEntries()

      This is the thread that dequeues the appropriate parameters
      from the main queue and starts acting upon it. This is where
      the bulk of the work gets done. Note that this function
      gets called in an endless loop

      Briefly, this is what the function does.

      a) Find PTR corresponding to the Host Addr passed in.
      b) If this is the same as the Address name passed in, then leave as is,
         Otherwise delete and add new PTR record.
      c) Follow forward and delete if possible from the forward's
         dns server.
      d) If DoForward then do what the client would've done in an NT5.0 case,
         i.e. Try to write a new forward lookup.


  Arguments:

      No arguments

  Return Value:

  is 0 if Success. and (DWORD)-1 if failure.

*/

{
    /*
      cases to be considered here.

      DYNDNS_ADD_ENTRY:
      First query for the lookup
      For each of the PTR records that come back, you need to check
      against the one you are asked to register. If there is a match,
      exit with success. If not add this entry for the PTR

      if downlevel, then we need to add this entry to forward A record
      as well.

      DYNDNS_DELETE_ENTRY
      Delete the entry that corresponds to the pair that you have specified
      here. If it does not exist then do nothing about it.

      If downlevel here, then go to the A record correspond to this and
      delete the forward entry as well.

    */

    DWORD               status, dwWaitResult;
    PQELEMENT           pQElement = NULL;
    PWSTR               pszName = NULL;
    BOOL                fDoForward;
    PQELEMENT           pBackDependency = NULL;
    REGISTER_HOST_ENTRY HostAddr ;
    DWORD               dwOperation;
    DWORD               dwCurrTime;
    DWORD               dwTTL;
    DWORD               dwWaitTime = INFINITE;
    DWORD               dwFwdAddErrCode = 0;
    DHCP_CALLBACK_FN    pfnDhcpCallBack = NULL;
    PVOID               pvData = NULL;

    DYNREG_F1( "Inside function DynDnsRegisterEntries" );

    //
    // call back function
    //

    //
    // check to see if there is any item in the timed out queue
    // that has the timer gone out and so you can start processing
    // that element right away
    //

    dwCurrTime = Dns_GetCurrentTimeInSeconds();

    if ( g_pDhcpSrvTimedOutQueue &&
         g_pDhcpSrvTimedOutQueue->pHead &&
         (dwCurrTime > g_pDhcpSrvTimedOutQueue->pHead->dwRetryTime) )
    {
        //
        // dequeue an element from the timed out queue and process it
        //
        DYNREG_F1( "DynDnsRegisterEntries - Dequeue element from timed out list" );

        pQElement = Dequeue( g_pDhcpSrvTimedOutQueue );
        if ( !pQElement )
        {
            status = ERROR_SUCCESS;
            goto Exit;
        }

        pfnDhcpCallBack = pQElement->pfnDhcpCallBack;
        pvData = pQElement->pvData;

        //
        // now determine if we have processed this element way too many
        // times
        //

        if ( pQElement->dwRetryCount >= MAX_RETRIES )
        {
            DYNREG_F1( "DynDnsRegisterEntries - Element has failed too many times, calling DHCP callback function" );
            if (pQElement->fDoForwardOnly)
            {
                if ( pfnDhcpCallBack )
                    (*pfnDhcpCallBack)(DNSDHCP_FWD_FAILED, pvData);
            }
            else
            {
                if ( pfnDhcpCallBack )
                    (*pfnDhcpCallBack)(DNSDHCP_FAILURE, pvData);
            }

            DhcpSrv_FreeQueueElement( pQElement );
            status = ERROR_SUCCESS;
            goto Exit;
        }
    }
    else
    {
        DWORD dwRetryTime = GetEarliestRetryTime (g_pDhcpSrvTimedOutQueue);

        DYNREG_F1( "DynDnsRegisterEntries - No element in timed out queue." );
        DYNREG_F1( "                        Going to wait for next element." );

        dwWaitTime = dwRetryTime != (DWORD)-1 ?
            (dwRetryTime > dwCurrTime? (dwRetryTime - dwCurrTime) *1000: 0)
            : INFINITE;

        dwWaitResult = WaitForMultipleObjects(
                            2,
                            g_DhcpSrvWaitHandles,
                            FALSE,
                            dwWaitTime );

        switch ( dwWaitResult )
        {

        case WAIT_OBJECT_0:
            //
            // quit event, return and let caller take care
            //
            return(0);

        case WAIT_OBJECT_0 + 1 :

            //
            // dequeue an element from the main queue and process
            //

            pQElement = Dequeue(g_pDhcpSrvQueue);
            if ( !pQElement )
            {
                status = NO_ERROR;  // Note: This actually does happen
                                    // because when Ram adds a new
                                    // entry, he may put it in the
                                    // timed out queue instead of the
                                    // g_pDhcpSrvQueue when there is a related
                                    // item pending a retry time. Assert
                                    // removed and error code changed to
                                    // to success by GlennC - 3/6/98.
                goto Exit;
            }

            EnterCriticalSection(&g_QueueCS);
            g_DhcpSrvMainQueueCount--;
            LeaveCriticalSection(&g_QueueCS);
            break;

        case WAIT_TIMEOUT:
            //
            // Let us exit the function this time around. We will catch the
            // timed out element the next time around
            //
            return  ERROR_SUCCESS;

        default:

            ASSERT( FALSE );
            return  dwWaitResult;
        }
    }

    //
    // safe to make a call since you are not dependent on anyone
    //

    DYNREG_F1( "DynDnsRegisterEntries - Got an element to process!" );

    pszName = pQElement->pszName;
    fDoForward = pQElement->fDoForward;
    HostAddr = pQElement->HostAddr;
    dwOperation = pQElement->dwOperation;
    dwTTL = pQElement->dwTTL;
    pfnDhcpCallBack = pQElement->pfnDhcpCallBack;
    pvData = pQElement->pvData;

    if ( dwOperation == DYNDNS_ADD_ENTRY )
    {
        //
        // make the appropriate API call to add an entry
        //

        if (pQElement->fDoForwardOnly )
        {
            DYNREG_F1( "DynDnsRegisterEntries - Calling DynDnsAddForward" );
            status = DynDnsAddForward ( HostAddr,
                                         pszName,
                                         dwTTL,
                                         pQElement->DnsServerList );
            DYNREG_F2( "DynDnsRegisterEntries - DynDnsAddForward returned status: 0%x", status );
        }
        else
        {
            DYNREG_F1( "DynDnsRegisterEntries - Calling DynDnsAddEntry" );
            status = DynDnsAddEntry( HostAddr,
                                      pszName,
                                      dwTTL,
                                      fDoForward,
                                      &dwFwdAddErrCode,
                                      pQElement->DnsServerList );
            DYNREG_F2( "DynDnsRegisterEntries - DynDnsAddEntry returned status: 0%x", status );
        }
    }
    else
    {
        //
        // make the appropriate call to delete here
        //

        if ( pQElement->fDoForwardOnly )
        {
            DNS_RECORD record;

            RtlZeroMemory( &record, sizeof(DNS_RECORD) );

            record.pName = (PTCHAR) pszName;
            record.wType = DNS_TYPE_A;
            record.wDataLength = sizeof(DNS_A_DATA);
            record.Data.A.IpAddress = HostAddr.Addr.ipAddr ;

            status = DNS_ERROR_RCODE_NO_ERROR;

            DYNREG_F1( "DynDnsRegisterEntries - Calling ModifyRecords(Remove)" );

            dwFwdAddErrCode = DnsModifyRecordsInSet_W(
                                    NULL,           // no add records
                                    & record,       // delete record
                                    DNS_UPDATE_CACHE_SECURITY_CONTEXT,
                                    NULL,           // no security context
                                    (PIP4_ARRAY) pQElement->DnsServerList,
                                    NULL            // reserved
                                    );
    
            DYNREG_F2( "DynDnsRegisterEntries - ModifyRecords(Remove) returned status: 0%x", dwFwdAddErrCode );
        }
        else
        {
            DYNREG_F1( "DynDnsRegisterEntries - Calling DynDnsDeleteEntry" );
            status = DynDnsDeleteEntry( HostAddr,
                                         pszName,
                                         fDoForward,
                                         &dwFwdAddErrCode,
                                         pQElement->DnsServerList );
            DYNREG_F2( "DynDnsRegisterEntries - DynDnsDeleteEntry returned status: 0%x", status );
        }
    }

    if (status == DNS_ERROR_RCODE_NO_ERROR &&
        dwFwdAddErrCode == DNS_ERROR_RCODE_NO_ERROR )
    {
        if ( pfnDhcpCallBack )
            (*pfnDhcpCallBack) (DNSDHCP_SUCCESS, pvData);

        DhcpSrv_FreeQueueElement( pQElement );

    }
    else if ( status == DNS_ERROR_RCODE_NO_ERROR &&
              dwFwdAddErrCode != DNS_ERROR_RCODE_NO_ERROR )
    {
        //
        // adding reverse succeeded but adding forward failed
        //

        dwCurrTime = Dns_GetCurrentTimeInSeconds();

        pQElement->fDoForwardOnly = TRUE;

        if ( pQElement->dwRetryCount >= MAX_RETRIES )
        {
            //
            // clean up pQElement and stop retrying
            //
            if ( pfnDhcpCallBack )
                (*pfnDhcpCallBack)(DNSDHCP_FWD_FAILED, pvData);

            DhcpSrv_FreeQueueElement( pQElement );
            status = ERROR_SUCCESS;
            goto Exit;
        }

        //
        // we may need to retry this guy later
        //

        switch ( dwFwdAddErrCode )
        {
            case DNS_ERROR_RCODE_SERVER_FAILURE:

                status = AddToTimedOutQueue(
                              pQElement,
                              g_pDhcpSrvTimedOutQueue,
                              dwCurrTime + RETRY_TIME_SERVER_FAILURE );
                break;

            case ERROR_TIMEOUT:

                status = AddToTimedOutQueue(
                              pQElement,
                              g_pDhcpSrvTimedOutQueue,
                              dwCurrTime + RETRY_TIME_TIMEOUT );
                break;

            default:

                //
                // different kind of error on attempting to add forward.
                // like connection refused etc.
                // call the callback to indicate that you failed on
                // forward only

                DhcpSrv_FreeQueueElement( pQElement );

                if ( pfnDhcpCallBack )
                    (*pfnDhcpCallBack)(DNSDHCP_FWD_FAILED, pvData);
        }
    }
    else if ( status != DNS_ERROR_RCODE_NO_ERROR &&
              dwFwdAddErrCode == DNS_ERROR_RCODE_NO_ERROR )
    {
        //
        // adding forward succeeded but adding reverse failed
        //

        dwCurrTime = Dns_GetCurrentTimeInSeconds();

        pQElement->fDoForwardOnly = FALSE;
        pQElement->fDoForward = FALSE;

        if ( pQElement->dwRetryCount >= MAX_RETRIES )
        {
            //
            // clean up pQElement and stop retrying
            //
            if ( pfnDhcpCallBack )
                (*pfnDhcpCallBack)(DNSDHCP_FAILURE, pvData);

            DhcpSrv_FreeQueueElement( pQElement );
            status = ERROR_SUCCESS;
            goto Exit;
        }

        //
        // we may need to retry this guy later
        //

        switch ( status )
        {
            case DNS_ERROR_RCODE_SERVER_FAILURE:

                status = AddToTimedOutQueue(
                              pQElement,
                              g_pDhcpSrvTimedOutQueue,
                              dwCurrTime + RETRY_TIME_SERVER_FAILURE );
                break;

            case ERROR_TIMEOUT:

                status = AddToTimedOutQueue(
                              pQElement,
                              g_pDhcpSrvTimedOutQueue,
                              dwCurrTime + RETRY_TIME_TIMEOUT );
                break;

            default:

                //
                // different kind of error on attempting to add forward.
                // like connection refused etc.
                // call the callback to indicate that you at least succeeded
                // with the forward registration

                DhcpSrv_FreeQueueElement( pQElement );

                if ( pfnDhcpCallBack )
                    (*pfnDhcpCallBack)(DNSDHCP_FAILURE, pvData);
        }
    }
    else if (status == DNS_ERROR_RCODE_SERVER_FAILURE ||
             status == DNS_ERROR_TRY_AGAIN_LATER ||
             status == ERROR_TIMEOUT )
    {
        //
        // we need to retry this guy later
        //
        dwCurrTime = Dns_GetCurrentTimeInSeconds();

        switch (status)
        {
            case DNS_ERROR_RCODE_SERVER_FAILURE:

                status = AddToTimedOutQueue(
                              pQElement,
                              g_pDhcpSrvTimedOutQueue,
                              dwCurrTime + RETRY_TIME_SERVER_FAILURE );
                break;

            case ERROR_TIMEOUT:

                status = AddToTimedOutQueue(
                              pQElement,
                              g_pDhcpSrvTimedOutQueue,
                              dwCurrTime + RETRY_TIME_TIMEOUT );
                break;
        }
    }
    else
    {
        //
        // a different kind of error, really nothing can be done
        // free memory and get the hell out
        // call the callback to say that registration failed
        //

        DhcpSrv_FreeQueueElement( pQElement );

        if ( pfnDhcpCallBack )
            (*pfnDhcpCallBack)(DNSDHCP_FAILURE, pvData);
    }

Exit:

    return( status );
}


//
//  Main registration thread
//

VOID
DynDnsConsumerThread(
    VOID
    )
{
    DWORD dwRetval;

    DYNREG_F1( "Inside function DynDnsConsumerThread" );

    while ( ! g_fDhcpSrvStop )
    {
        dwRetval = DynDnsRegisterEntries();
        if ( !dwRetval )
        {
            //
            //  Ram note: get Munil/Ramesh to implement call back function
            //
        }
    }

    //  exiting thread
    //ExitThread(0); // This sets the handle in the waitforsingleobject for
}


//
//  Init\Cleanup routines
//


BOOL
LockDhcpSrvState(
    VOID
    )
/*++

Routine Description:

    Lock the state to allow state change.

Arguments:

    None

Return Value:

    TRUE if locked the state for state change.
    FALSE otherwise.

--*/
{
    BOOL    retval = TRUE;   

    //
    //  protect init of DHCP server lock with general CS
    //

    if ( !g_fDhcpSrvCsCreated )
    {
        LOCK_GENERAL();
        if ( !g_fDhcpSrvCsCreated )
        {
            retval = RtlInitializeCriticalSection( &g_DhcpSrvCS ) == NO_ERROR;
            g_fDhcpSrvCsCreated = retval;
        }
        UNLOCK_GENERAL();
        if ( !retval )
        {
            return retval;
        }
    }

    //
    //  grab DHCP server lock
    //

    EnterCriticalSection( &g_DhcpSrvCS );

    return  retval;
}


VOID
DhcpSrv_Cleanup(
    VOID
    )
/*++

Routine Description:

    Cleanup CS created for DHCP server registration.

    This is ONLY called from process detach.  Should be safe.

Arguments:

    None

Return Value:

    None

--*/
{
    if ( g_fDhcpSrvCsCreated )
    {
        DeleteCriticalSection( &g_DhcpSrvCS );
    }
    g_fDhcpSrvCsCreated = FALSE;
}


VOID
DhcpSrv_PrivateCleanup(
    VOID
    )
/*++

Routine Description:

    Common cleanup between failed init and terminate.

    Function exists just to kill off common code.

Arguments:

    None.

Return Value:

    None.

--*/
{
    //
    //  common cleanup
    //      - queues
    //      - queue CS itself
    //      - semaphore
    //      - event
    //      - security credential info
    //

    if ( g_fDhcpSrvQueueCsCreated )
    {
        if ( g_pDhcpSrvQueue )
        {
            FreeQueue( g_pDhcpSrvQueue );
            g_pDhcpSrvQueue = NULL;
        }
    
        if ( g_pDhcpSrvTimedOutQueue )
        {
            FreeQueue( g_pDhcpSrvTimedOutQueue );
            g_pDhcpSrvTimedOutQueue = NULL;
        }
        g_DhcpSrvMainQueueCount = 0;

        DeleteCriticalSection( &g_QueueCS );
        g_fDhcpSrvQueueCsCreated = FALSE;
    }

    if ( g_DhcpSrvSem )
    {
        CloseHandle( g_DhcpSrvSem );
        g_DhcpSrvSem = NULL;
    }

    if ( g_DhcpSrvQuitEvent )
    {
        CloseHandle( g_DhcpSrvQuitEvent );
        g_DhcpSrvQuitEvent = NULL;
    }

    if ( g_pIdentityCreds )
    {
        Dns_FreeAuthIdentityCredentials( g_pIdentityCreds );
        g_pIdentityCreds = NULL;
    }

    if ( g_UpdateCredContext )
    {
        DnsReleaseContextHandle( g_UpdateCredContext );
        g_UpdateCredContext = NULL;
    }

}


DNS_STATUS
WINAPI
DnsDhcpSrvRegisterInit(
    IN      PDNS_CREDENTIALS    pCredentials,
    IN      DWORD               MaxQueueSize
    )
/*++

Routine Description:

    Initialize DHCP server DNS registration.

Arguments:

    pCredentials -- credentials to do registrations under (if any)

    MaxQueueSize -- max size of registration queue

Return Value:

    DNS or Win32 error code.

--*/
{
    INT             i;
    DWORD           threadId;
    DNS_STATUS      status = NO_ERROR;
    BOOL            failed = TRUE;

    //
    //  protection for init\shutdown
    //      - lock out possibility of race condition
    //      - skip init if already running
    //      - set state to indicate initializing (informational only)
    //

    if ( !DHCP_SRV_STATE_LOCK() )
    {
        ASSERT( FALSE );
        return  DNS_ERROR_NO_MEMORY;
    }

    if ( g_DhcpSrvState == DNS_DHCP_SRV_STATE_RUNNING )
    {
        status = NO_ERROR;
        goto Unlock;
    }

    ASSERT( g_DhcpSrvState == DNS_DHCP_SRV_STATE_UNINIT ||
            g_DhcpSrvState == DNS_DHCP_SRV_STATE_INIT_FAILED ||
            g_DhcpSrvState == DNS_DHCP_SRV_STATE_SHUTDOWN );

    g_DhcpSrvState = DNS_DHCP_SRV_STATE_INITIALIZING;


    //
    //  init globals
    //      - also init debug logging
    //

    DYNREG_INIT();

    DNS_ASSERT(!g_DhcpSrvQuitEvent && !g_DhcpSrvSem);

    g_fDhcpSrvStop = FALSE;

    g_DhcpSrvQuitEvent = CreateEvent( NULL, TRUE, FALSE, NULL );
    if ( !g_DhcpSrvQuitEvent )
    {
        goto Exit;
    }

    g_DhcpSrvSem = CreateSemaphore( NULL, 0, MAX_QLEN, NULL );
    if ( ! g_DhcpSrvSem )
    {
        goto Exit;
    }

    g_DhcpSrvWaitHandles[0] = g_DhcpSrvQuitEvent;
    g_DhcpSrvWaitHandles[1] = g_DhcpSrvSem;

    Dns_InitializeSecondsTimer();

    //
    //  init queuing stuff
    //

    status = RtlInitializeCriticalSection( &g_QueueCS );
    if ( status != NO_ERROR )
    {
        goto Exit;
    }
    g_fDhcpSrvQueueCsCreated = TRUE;

    status = InitializeQueues( &g_pDhcpSrvQueue, &g_pDhcpSrvTimedOutQueue );
    if ( status != NO_ERROR )
    {
        g_pDhcpSrvQueue = NULL;
        g_pDhcpSrvTimedOutQueue = NULL;
        goto Exit;
    }

    g_DhcpSrvMainQueueCount = 0;

    //
    //  have creds?
    //      - create global credentials
    //      - acquire a valid SSPI handle using these creds
    //
    //  DCR:  global cred handle not MT safe
    //      here we are in the DHCP server process and don't have
    //      any reason to use another update context;  but if
    //      shared with some other service this breaks
    //
    //      fix should be to have separate
    //          - creds
    //          - cred handle
    //      that is kept here (not cached) and pushed down
    //      on each update call
    //

    if ( pCredentials )
    {
        DNS_ASSERT( g_pIdentityCreds == NULL );

        g_pIdentityCreds = Dns_AllocateCredentials(
                                pCredentials->pUserName,
                                pCredentials->pDomain,
                                pCredentials->pPassword );
        if ( !g_pIdentityCreds )
        {
            goto Exit;
        }

        //  DCR:  this won't work if creds will expire
        //      but it seems like they autorefresh

        status = Dns_StartSecurity(
                    FALSE       // not process attach
                    );
        if ( status != NO_ERROR )
        {
            status = ERROR_CANNOT_IMPERSONATE;
            goto Exit;
        }

        status = Dns_RefreshSSpiCredentialsHandle(
                    FALSE,                      // client
                    (PCHAR) g_pIdentityCreds    // creds
                    );
        if ( status != NO_ERROR )
        {
            status = ERROR_CANNOT_IMPERSONATE;
            goto Exit;
        }
#if 0
        DNS_ASSERT( g_UpdateCredContext == NULL );

        status = DnsAcquireContextHandle_W(
                    0,                      // flags
                    g_pIdentityCreds,        // creds
                    & g_UpdateCredContext   // set handle
                    );
        if ( status != NO_ERROR )
        {
            goto Exit;
        }
#endif
    }

    //
    //  fire up registration thread
    //      - pass creds as start param
    //      - if thread start fails, free creds
    //

    g_hDhcpSrvRegThread = CreateThread(
                            NULL,
                            0,
                            (LPTHREAD_START_ROUTINE)DynDnsConsumerThread,
                            NULL,
                            0,
                            &threadId );

    if ( g_hDhcpSrvRegThread == NULL )
    {
        goto Exit;
    }

    //
    //  set queue size -- if given
    //      - but put cap to avoid runaway memory
    //

    if ( MaxQueueSize != 0 )
    {
        if ( MaxQueueSize > DHCPSRV_MAX_QUEUE_SIZE )
        {
            MaxQueueSize = DHCPSRV_MAX_QUEUE_SIZE;
        }
        g_DhcpSrvMaxQueueSize = MaxQueueSize;
    }

    failed = FALSE;

Exit:

    //
    //  if failed, clean up globals
    //

    if ( failed )
    {
        //  fix up return code

        if ( status == NO_ERROR )
        {
            status = GetLastError();
            if ( status == NO_ERROR )
            {
                status = DNS_ERROR_NO_MEMORY;
            }
        }

        //  global cleanup
        //      - shared between failure case here and term function

        DhcpSrv_PrivateCleanup();

        //  indicate unitialized

        g_DhcpSrvState = DNS_DHCP_SRV_STATE_INIT_FAILED;
    }
    else    
    {
        g_DhcpSrvState = DNS_DHCP_SRV_STATE_RUNNING;
        status = NO_ERROR;
    }

Unlock:

    //  unlock -- allow queuing or reinit

    DHCP_SRV_STATE_UNLOCK();

    return  status;
}



DNS_STATUS
WINAPI
DnsDhcpSrvRegisterTerm(
   VOID
   )
/*++

Routine Description:

    Initialization routine each process should call exactly on exit after
    using DnsDhcpSrvRegisterHostAddrs. This will signal to us that if our
    thread is still trying to talk to a server, we'll stop trying.

Arguments:

    None.

Return Value:

    DNS or Win32 error code.

--*/
{
    DNS_STATUS  status = NO_ERROR;
    DWORD       waitResult;

    DYNREG_F1( "Inside function DnsDhcpSrvRegisterTerm" );


    //
    //  lock to eliminate race condition
    //      - verify that we're running
    //      - indicate in process of shutdown (purely informational)
    //

    if ( !DHCP_SRV_STATE_LOCK() )
    {
        ASSERT( FALSE );
        return  DNS_ERROR_NO_MEMORY;
    }

    if ( g_DhcpSrvState != DNS_DHCP_SRV_STATE_RUNNING )
    {
        ASSERT( g_DhcpSrvState == DNS_DHCP_SRV_STATE_UNINIT ||
                g_DhcpSrvState == DNS_DHCP_SRV_STATE_INIT_FAILED ||
                g_DhcpSrvState == DNS_DHCP_SRV_STATE_SHUTDOWN );
        goto Unlock;
    }
    g_DhcpSrvState = DNS_DHCP_SRV_STATE_SHUTTING_DOWN;


    //
    //  signal consummer thread for shutdown
    //

    g_fDhcpSrvStop = TRUE;
    SetEvent( g_DhcpSrvQuitEvent );

    waitResult = WaitForSingleObject( g_hDhcpSrvRegThread, INFINITE );

    switch( waitResult )
    {
        case WAIT_OBJECT_0:
            //
            // client thread terminated
            //
            CloseHandle(g_hDhcpSrvRegThread);
            g_hDhcpSrvRegThread = NULL;
            break;

        case WAIT_TIMEOUT:
            if ( g_hDhcpSrvRegThread )
            {
                //
                // Why hasn't this thread stopped?
                //
                DYNREG_F1( "DNSAPI: DHCP Server DNS registration thread won't stop!" );
                DNS_ASSERT( FALSE );
            }
            break;

        default:
            DNS_ASSERT( FALSE );
    }

    //
    //  cleanup globals
    //      - queues
    //      - event
    //      - semaphore
    //      - update security cred info
    //

    DhcpSrv_PrivateCleanup();

    //
    // Blow away any cached security context handles
    //
    //  DCR:  security context dump is not multi-service safe
    //      should have this cleanup just the context's associated
    //      with DHCP server service;
    //      either need some key or use cred handle
    //

    Dns_TimeoutSecurityContextList( TRUE );

Unlock:

    //  unlock -- returning to uninitialized state

    g_DhcpSrvState = DNS_DHCP_SRV_STATE_SHUTDOWN;
    DHCP_SRV_STATE_UNLOCK();

    return  status;
}



DNS_STATUS
WINAPI
DnsDhcpSrvRegisterHostName(
    IN  REGISTER_HOST_ENTRY HostAddr,
    IN  PWSTR               pwsName,
    IN  DWORD               dwTTL,
    IN  DWORD               dwFlags, // An entry you want to blow away
    IN  DHCP_CALLBACK_FN    pfnDhcpCallBack,
    IN  PVOID               pvData,
    IN  PIP4_ADDRESS        pipDnsServerList,
    IN  DWORD               dwDnsServerCount
    )
/*++

  DnsDhcpSrvRegisterHostName()

    The main DHCP registration thread calls this function each time a
    registration needs to be done.

    Brief Synopsis of the working of this function

    This function creates a queue object of the type given in queue.c
    and enqueues the appropriate object after grabbing hold of the
    critical section.

  Arguments:

     HostAddr  ---  The Host Addr you wish to register
     pszName   ---  The Host Name to be associated with the address
     dwTTL     ---   Time to Live.
     dwOperation    --   The following flags are valid

     DYNDNS_DELETE_ENTRY -- Delete the entry being referred to.
     DYNDNS_ADD_ENTRY    -- Register the new entry.
     DYNDNS_REG_FORWARD  -- Register the forward as well

  Return Value:

  is 0 if Success. and (DWORD)-1 if failure.

--*/
{
    PQELEMENT   pQElement = NULL;
    DWORD       status = ERROR_SUCCESS;
    BOOL        fSem = FALSE;
    BOOL        fRegForward =  dwFlags & DYNDNS_REG_FORWARD ? TRUE: FALSE ;

    DYNREG_F1( "Inside function DnsDhcpSrvRegisterHostName_W" );

    // RAMNOTE:  parameter checking on queuing

    if ( g_fDhcpSrvStop ||
         ! g_pDhcpSrvTimedOutQueue ||
         ! g_pDhcpSrvQueue )
    {
        DYNREG_F1( "g_fDhcpSrvStop || ! g_pDhcpSrvTimedOutQueue || ! g_pDhcpSrvQueue" );
        DYNREG_F1( "DnsDhcpSrvRegisterHostName_W - Returning ERROR_INVALID_PARAMETER" );
        return ERROR_INVALID_PARAMETER;
    }

    if ( !(dwFlags & DYNDNS_DELETE_ENTRY) && ( !pwsName || !*pwsName ) )
    {
        DYNREG_F1( "!(dwFlags & DYNDNS_DELETE_ENTRY) && ( !pwsName || !*pwsName )" );
        DYNREG_F1( "DnsDhcpSrvRegisterHostName_W - Returning ERROR_INVALID_PARAMETER" );
        //
        // Null parameter for name can be specified only when operation
        // is to do a delete
        //
        return ERROR_INVALID_PARAMETER;
    }

    if ( ! (dwFlags & DYNDNS_ADD_ENTRY || dwFlags & DYNDNS_DELETE_ENTRY ) )
    {
        DYNREG_F1( "! (dwFlags & DYNDNS_ADD_ENTRY || dwFlags & DYNDNS_DELETE_ENTRY )" );
        DYNREG_F1( "DnsDhcpSrvRegisterHostName_W - Returning ERROR_INVALID_PARAMETER" );
        return ERROR_INVALID_PARAMETER;
    }

    if ( (dwFlags & DYNDNS_DELETE_ENTRY) && (dwFlags & DYNDNS_ADD_ENTRY) )
    {
        DYNREG_F1( "(dwFlags & DYNDNS_DELETE_ENTRY) && (dwFlags & DYNDNS_ADD_ENTRY)" );
        DYNREG_F1( "DnsDhcpSrvRegisterHostName_W - Returning ERROR_INVALID_PARAMETER" );
        //
        // you cant ask me to both add and delete an entry
        //
        return ERROR_INVALID_PARAMETER;
    }

    if ( ! (HostAddr.dwOptions & REGISTER_HOST_PTR) )
    {
        DYNREG_F1( "! (HostAddr.dwOptions & REGISTER_HOST_PTR)" );
        DYNREG_F1( "DnsDhcpSrvRegisterHostName_W - Returning ERROR_INVALID_PARAMETER" );
        return ERROR_INVALID_PARAMETER;
    }

    if ( g_DhcpSrvMainQueueCount > g_DhcpSrvMaxQueueSize )
    {
        return DNS_ERROR_TRY_AGAIN_LATER;
    }

    //
    //  create a queue element
    //

    pQElement = (PQELEMENT) QUEUE_ALLOC_HEAP_ZERO(sizeof(QELEMENT) );
    if ( !pQElement )
    {
        DYNREG_F1( "DnsDhcpSrvRegisterHostName_W - Failed to create element!" );
        status = DNS_ERROR_NO_MEMORY;
        goto Exit;
    }

    RtlCopyMemory(
        & pQElement->HostAddr,
        &HostAddr,
        sizeof(REGISTER_HOST_ENTRY));

    pQElement->pszName = NULL;

    if ( pwsName )
    {
        pQElement->pszName = (LPWSTR) QUEUE_ALLOC_HEAP_ZERO(wcslen(pwsName)*2+ 2 );
        if ( !pQElement->pszName )
        {
            DYNREG_F1( "DnsDhcpSrvRegisterHostName_W - Failed to allocate name buffer!" );
            status = DNS_ERROR_NO_MEMORY;
            goto Exit;
        }
        wcscpy(pQElement->pszName, pwsName);
    }

    if ( dwDnsServerCount )
    {
        pQElement->DnsServerList = Dns_BuildIpArray(
                                        dwDnsServerCount,
                                        pipDnsServerList );
        if ( !pQElement->DnsServerList )
        {
            status = DNS_ERROR_NO_MEMORY;
            goto Exit;
        }
    }

    pQElement->dwTTL = dwTTL;
    pQElement->fDoForward = fRegForward;

    //
    // callback function
    //

    pQElement->pfnDhcpCallBack = pfnDhcpCallBack;
    pQElement->pvData = pvData;  // parameter to callback function

    if (dwFlags & DYNDNS_ADD_ENTRY)
        pQElement->dwOperation = DYNDNS_ADD_ENTRY;
    else
        pQElement->dwOperation = DYNDNS_DELETE_ENTRY;

    //
    // Set all the other fields to NULLs
    //

    pQElement->dwRetryTime = 0;
    pQElement->pFLink = NULL;
    pQElement->pBLink = NULL;
    pQElement->fDoForwardOnly = FALSE;

    //
    //  lock out terminate while queuing
    //      - and verify that properly initialized
    //

    if ( !DHCP_SRV_STATE_LOCK() )
    {
        status = DNS_ERROR_NO_MEMORY;
        goto Exit;
    }
    if ( g_DhcpSrvState != DNS_DHCP_SRV_STATE_RUNNING )
    {
        status = DNS_ERROR_NO_MEMORY;
        ASSERT( FALSE );
        DHCP_SRV_STATE_UNLOCK();
        goto Exit;
    }

    //  indicate queuing state
    //      - note this is entirely informational

    g_DhcpSrvState = DNS_DHCP_SRV_STATE_QUEUING;


    //
    //  put this element in the queue
    //

    DYNREG_F1( "DnsDhcpSrvRegisterHostName_W - Put queue element in list" );

    status = Enqueue( pQElement, g_pDhcpSrvQueue, g_pDhcpSrvTimedOutQueue);
    if ( status != NO_ERROR )
    {
        DYNREG_F1( "DnsDhcpSrvRegisterHostName_W - Failed to queue element in list!" );
    }

    //
    //  signal the semaphore the consumer may be waiting on
    //

    else
    {
        fSem = ReleaseSemaphore(
                    g_DhcpSrvSem,
                    1,
                    &g_DhcpSrvRegQueueCount );
        if ( !fSem )
        {
            DNS_ASSERT( fSem );  // assert and say that something weird happened
        }
    }

    //  unlock -- returning to running state

    g_DhcpSrvState = DNS_DHCP_SRV_STATE_RUNNING;
    DHCP_SRV_STATE_UNLOCK();

Exit:

    if ( status )
    {
        //
        // something failed. Free all alloc'd memory
        //

        DhcpSrv_FreeQueueElement( pQElement );
    }

    return( status );
}

//
//  End dynreg.c
//
=== C:/Users/treeman/Desktop/windows nt source code\Source\Win2K3\NT\ds\dns\dnsapi\export.c ===
/*++

Copyright (c) 1997-2001  Microsoft Corporation

Module Name:

    export.c

Abstract:

    Domain Name System (DNS) API

    Covering functions for exported routines that are actually in
    dnslib.lib.

Author:

    Jim Gilroy (jamesg)     November, 1997

Environment:

    User Mode - Win32

Revision History:

--*/

#include "local.h"

#define DNSAPI_XP_ENTRY 1


//
//  SDK routines
//

//
//  Name comparison
//

BOOL
WINAPI
DnsNameCompare_A(
    IN      LPSTR           pName1,
    IN      LPSTR           pName2
    )
{
    return Dns_NameCompare_A( pName1, pName2 );
}

BOOL
WINAPI
DnsNameCompare_UTF8(
    IN      LPSTR           pName1,
    IN      LPSTR           pName2
    )
{
    return Dns_NameCompare_UTF8( pName1, pName2 );
}

BOOL
WINAPI
DnsNameCompare_W(
    IN      LPWSTR          pName1,
    IN      LPWSTR          pName2
    )
{
    return Dns_NameCompare_W( pName1, pName2 );
}


DNS_NAME_COMPARE_STATUS
DnsNameCompareEx_A(
    IN      LPCSTR          pszLeftName,
    IN      LPCSTR          pszRightName,
    IN      DWORD           dwReserved
    )
{
    return Dns_NameCompareEx(
                pszLeftName,
                pszRightName,
                dwReserved,
                DnsCharSetAnsi );
}

DNS_NAME_COMPARE_STATUS
DnsNameCompareEx_UTF8(
    IN      LPCSTR          pszLeftName,
    IN      LPCSTR          pszRightName,
    IN      DWORD           dwReserved
    )
{
    return Dns_NameCompareEx(
                pszLeftName,
                pszRightName,
                dwReserved,
                DnsCharSetUtf8 );
}

DNS_NAME_COMPARE_STATUS
DnsNameCompareEx_W(
    IN      LPCWSTR         pszLeftName,
    IN      LPCWSTR         pszRightName,
    IN      DWORD           dwReserved
    )
{
    return Dns_NameCompareEx(
                (LPSTR) pszLeftName,
                (LPSTR) pszRightName,
                dwReserved,
                DnsCharSetUnicode );
}


//
//  Name validation
//

DNS_STATUS
DnsValidateName_UTF8(
    IN      LPCSTR          pszName,
    IN      DNS_NAME_FORMAT Format
    )
{
    return Dns_ValidateName_UTF8( pszName, Format );
}


DNS_STATUS
DnsValidateName_W(
    IN      LPCWSTR         pszName,
    IN      DNS_NAME_FORMAT Format
    )
{
    return Dns_ValidateName_W( pszName, Format );
}

DNS_STATUS
DnsValidateName_A(
    IN      LPCSTR          pszName,
    IN      DNS_NAME_FORMAT Format
    )
{
    return Dns_ValidateName_A( pszName, Format );
}


//
//  Record List 
//

BOOL
DnsRecordCompare(
    IN      PDNS_RECORD     pRecord1,
    IN      PDNS_RECORD     pRecord2
    )
{
    return Dns_RecordCompare(
                pRecord1,
                pRecord2 );
}

BOOL
WINAPI
DnsRecordSetCompare(
    IN OUT  PDNS_RECORD     pRR1,
    IN OUT  PDNS_RECORD     pRR2,
    OUT     PDNS_RECORD *   ppDiff1,
    OUT     PDNS_RECORD *   ppDiff2
    )
{
    return  Dns_RecordSetCompare(
                pRR1,
                pRR2,
                ppDiff1,
                ppDiff2
                );
}

PDNS_RECORD
WINAPI
DnsRecordCopyEx(
    IN      PDNS_RECORD     pRecord,
    IN      DNS_CHARSET     CharSetIn,
    IN      DNS_CHARSET     CharSetOut
    )
{
    return Dns_RecordCopyEx( pRecord, CharSetIn, CharSetOut );
}

PDNS_RECORD
WINAPI
DnsRecordSetCopyEx(
    IN      PDNS_RECORD     pRecordSet,
    IN      DNS_CHARSET     CharSetIn,
    IN      DNS_CHARSET     CharSetOut
    )
{
    return Dns_RecordSetCopyEx( pRecordSet, CharSetIn, CharSetOut );
}


PDNS_RECORD
WINAPI
DnsRecordSetDetach(
    IN OUT  PDNS_RECORD pRR
    )
{
    return Dns_RecordSetDetach( pRR );
}


//
//  Backward compatibility
//

#undef DnsRecordListFree

VOID
WINAPI
DnsRecordListFree(
    IN OUT  PDNS_RECORD     pRecordList,
    IN      DNS_FREE_TYPE   FreeType
    )
{
    Dns_RecordListFreeEx(
        pRecordList,
        (BOOL)FreeType );
}



//
//  Timer (timer.c)
//

DWORD
GetCurrentTimeInSeconds(
    VOID
    )
{
    return Dns_GetCurrentTimeInSeconds();
}




//
//  Resource record type utilities (record.c)
//

BOOL _fastcall
DnsIsAMailboxType(
    IN      WORD        wType
    )
{
    return Dns_IsAMailboxType( wType );
}

WORD
DnsRecordTypeForName(
    IN      PCHAR       pszName,
    IN      INT         cchNameLength
    )
{
    return Dns_RecordTypeForName( pszName, cchNameLength );
}

PCHAR
DnsRecordStringForType(
    IN      WORD        wType
    )
{
    return Dns_RecordStringForType( wType );
}

PCHAR
DnsRecordStringForWritableType(
    IN  WORD    wType
    )
{
    return Dns_RecordStringForWritableType( wType );
}

BOOL
DnsIsStringCountValidForTextType(
    IN  WORD    wType,
    IN  WORD    StringCount )
{
    return Dns_IsStringCountValidForTextType( wType, StringCount );
}


//
//  DCR_CLEANUP:  these probably don't need exporting
//

DWORD
DnsWinsRecordFlagForString(
    IN      PCHAR           pchName,
    IN      INT             cchNameLength
    )
{
    return Dns_WinsRecordFlagForString( pchName, cchNameLength );
}

PCHAR
DnsWinsRecordFlagString(
    IN      DWORD           dwFlag,
    IN OUT  PCHAR           pchFlag
    )
{
    return Dns_WinsRecordFlagString( dwFlag, pchFlag );
}




//
//  DNS utilities (dnsutil.c)
//
//  DCR_DELETE:  DnsStatusString routines should be able to use win32 API
//

//
//  Remove marco definitions so we can compile
//  The idea here is we can have the entry points in the Dll
//  for any old code, BUT the macros (dnsapi.h) point at new entry points
//  for freshly built modules.
//

#ifdef DnsStatusToErrorString_A
#undef DnsStatusToErrorString_A
#endif

LPSTR
_fastcall
DnsStatusString(
    IN      DNS_STATUS      Status
    )
{
    return Dns_StatusString( Status );
}


DNS_STATUS
_fastcall
DnsMapRcodeToStatus(
    IN      BYTE            ResponseCode
    )
{
    return Dns_MapRcodeToStatus( ResponseCode );
}

BYTE
_fastcall
DnsIsStatusRcode(
    IN      DNS_STATUS      Status
    )
{
    return Dns_IsStatusRcode( Status );
}



//
//  Name routines (string.c and dnsutil.c)
//

LPSTR
_fastcall
DnsGetDomainName(
    IN      LPSTR           pszName
    )
{
    return Dns_GetDomainNameA( pszName );
}



//
//  String routines (string.c)
//

LPSTR
DnsCreateStringCopy(
    IN      PCHAR       pchString,
    IN      DWORD       cchString
    )
{
    return Dns_CreateStringCopy(
                pchString,
                cchString );
}

DWORD
DnsGetBufferLengthForStringCopy(
    IN      PCHAR       pchString,
    IN      DWORD       cchString,
    IN      BOOL        fUnicodeIn,
    IN      BOOL        fUnicodeOut
    )
{
    return (WORD) Dns_GetBufferLengthForStringCopy(
                        pchString,
                        cchString,
                        fUnicodeIn ? DnsCharSetUnicode : DnsCharSetUtf8,
                        fUnicodeOut ? DnsCharSetUnicode : DnsCharSetUtf8
                        );
}

//
//  Need to
//      - get this unexported or
//      - real verions or
//      - explicit UTF8-unicode converter if thats what's desired
//

PVOID
DnsCopyStringEx(
    OUT     PBYTE       pBuffer,
    IN      PCHAR       pchString,
    IN      DWORD       cchString,
    IN      BOOL        fUnicodeIn,
    IN      BOOL        fUnicodeOut
    )
{
    DWORD   resultLength;

    resultLength =
        Dns_StringCopy(
                pBuffer,
                NULL,
                pchString,
                cchString,
                fUnicodeIn ? DnsCharSetUnicode : DnsCharSetUtf8,
                fUnicodeOut ? DnsCharSetUnicode : DnsCharSetUtf8
                );

    return( pBuffer + resultLength );
}

PVOID
DnsStringCopyAllocateEx(
    IN      PCHAR       pchString,
    IN      DWORD       cchString,
    IN      BOOL        fUnicodeIn,
    IN      BOOL        fUnicodeOut
    )
{
    return Dns_StringCopyAllocate(
                pchString,
                cchString,
                fUnicodeIn ? DnsCharSetUnicode : DnsCharSetUtf8,
                fUnicodeOut ? DnsCharSetUnicode : DnsCharSetUtf8
                );
}

//
// The new and improved string copy routines . . .
//

DWORD
DnsNameCopy(
    OUT     PBYTE           pBuffer,
    IN OUT  PDWORD          pdwBufLength,
    IN      PCHAR           pchString,
    IN      DWORD           cchString,
    IN      DNS_CHARSET     CharSetIn,
    IN      DNS_CHARSET     CharSetOut
    )
{
    return Dns_NameCopy( pBuffer,
                         pdwBufLength,
                         pchString,
                         cchString,
                         CharSetIn,
                         CharSetOut );
}

PVOID
DnsNameCopyAllocate(
    IN      PCHAR           pchString,
    IN      DWORD           cchString,
    IN      DNS_CHARSET     CharSetIn,
    IN      DNS_CHARSET     CharSetOut
    )
{
    return Dns_NameCopyAllocate ( pchString,
                                  cchString,
                                  CharSetIn,
                                  CharSetOut );
}



//
//  String\Address mapping
//
//  DCR:  eliminate these exports
//  DCR:  fix these to SDK the real deal
//
//  DCR:  probably shouldn't expose alloc -- easy workaround for caller
//

PCHAR
DnsWriteReverseNameStringForIpAddress(
    OUT     PCHAR           pBuffer,
    IN      IP4_ADDRESS     Ip4Addr
    )
{
    return  Dns_Ip4AddressToReverseName_A(
                pBuffer,
                Ip4Addr );
}

PCHAR
DnsCreateReverseNameStringForIpAddress(
    IN      IP4_ADDRESS     Ip4Addr
    )
{
    return  Dns_Ip4AddressToReverseNameAlloc_A( Ip4Addr );
}


//
//  DCR_CLEANUP:  pull these in favor of winsock IPv6 string routines
//

BOOL
DnsIpv6StringToAddress(
    OUT     PIP6_ADDRESS    pIp6Addr,
    IN      PCHAR           pchString,
    IN      DWORD           dwStringLength
    )
{
    return Dns_Ip6StringToAddressEx_A(
                pIp6Addr,
                pchString,
                dwStringLength );
}

VOID
DnsIpv6AddressToString(
    OUT     PCHAR           pchString,
    IN      PIP6_ADDRESS    pIp6Addr
    )
{
    Dns_Ip6AddressToString_A(
            pchString,
            pIp6Addr );
}



DNS_STATUS
DnsValidateDnsString_UTF8(
    IN      LPCSTR      pszName
    )
{
    return Dns_ValidateDnsString_UTF8( pszName );
}

DNS_STATUS
DnsValidateDnsString_W(
    IN      LPCWSTR     pszName
    )
{
    return Dns_ValidateDnsString_W( pszName );
}



//
//  Resource record utilities (rr*.c)
//

PDNS_RECORD
WINAPI
DnsAllocateRecord(
    IN      WORD        wBufferLength
    )
{
    return Dns_AllocateRecord( wBufferLength );
}


PDNS_RECORD
DnsRecordBuild_UTF8(
    IN OUT  PDNS_RRSET  pRRSet,
    IN      LPSTR       pszOwner,
    IN      WORD        wType,
    IN      BOOL        fAdd,
    IN      UCHAR       Section,
    IN      INT         Argc,
    IN      PCHAR *     Argv
    )
{
    return Dns_RecordBuild_A(
                pRRSet,
                pszOwner,
                wType,
                fAdd,
                Section,
                Argc,
                Argv );
}

PDNS_RECORD
DnsRecordBuild_W(
    IN OUT  PDNS_RRSET  pRRSet,
    IN      LPWSTR      pszOwner,
    IN      WORD        wType,
    IN      BOOL        fAdd,
    IN      UCHAR       Section,
    IN      INT         Argc,
    IN      PWCHAR *    Argv
    )
{
    return Dns_RecordBuild_W(
                pRRSet,
                pszOwner,
                wType,
                fAdd,
                Section,
                Argc,
                Argv );
}

//
//  Message processing
//

DNS_STATUS
WINAPI
DnsExtractRecordsFromMessage_W(
    IN  PDNS_MESSAGE_BUFFER pDnsBuffer,
    IN  WORD                wMessageLength,
    OUT PDNS_RECORD *       ppRecord
    )
/*++

Routine Description:

    None.

Arguments:

    None.

Return Value:

    None.

--*/
{
    return Dns_ExtractRecordsFromBuffer(
                pDnsBuffer,
                wMessageLength,
                TRUE,
                ppRecord );
}


DNS_STATUS
WINAPI
DnsExtractRecordsFromMessage_UTF8(
    IN  PDNS_MESSAGE_BUFFER pDnsBuffer,
    IN  WORD                wMessageLength,
    OUT PDNS_RECORD *       ppRecord
    )
/*++

Routine Description:

    None.

Arguments:

    None.

Return Value:

    None.

--*/
{
    return Dns_ExtractRecordsFromBuffer(
                pDnsBuffer,
                wMessageLength,
                FALSE,
                ppRecord );
}


//
//  Debug sharing
//

PDNS_DEBUG_INFO
DnsApiSetDebugGlobals(
    IN OUT  PDNS_DEBUG_INFO pInfo
    )
{
    return  Dns_SetDebugGlobals( pInfo );
}



//  
//  Config UI, ipconfig backcompat
//
//  DCR_CLEANUP:  Backcompat query config stuff -- yank once clean cycle
//


//
//  DCR:  Questionable exports
//

LPSTR
DnsCreateStandardDnsNameCopy(
    IN      PCHAR       pchName,
    IN      DWORD       cchName,
    IN      DWORD       dwFlag
    )
{
    return  Dns_CreateStandardDnsNameCopy(
                pchName,
                cchName,
                dwFlag );
}


//
//  DCR_CLEANUP:  who is using this?
//

DWORD
DnsDowncaseDnsNameLabel(
    OUT     PCHAR       pchResult,
    IN      PCHAR       pchLabel,
    IN      DWORD       cchLabel,
    IN      DWORD       dwFlags
    )
{
    return Dns_DowncaseNameLabel(
                pchResult,
                pchLabel,
                cchLabel,
                dwFlags );
}

//
//  DCR_CLEANUP:  who is using my direct UTF8 conversions AS API!
//

DWORD
_fastcall
DnsUnicodeToUtf8(
    IN      PWCHAR      pwUnicode,
    IN      DWORD       cchUnicode,
    OUT     PCHAR       pchResult,
    IN      DWORD       cchResult
    )
{
    return Dns_UnicodeToUtf8(
                pwUnicode,
                cchUnicode,
                pchResult,
                cchResult );
}

DWORD
_fastcall
DnsUtf8ToUnicode(
    IN      PCHAR       pchUtf8,
    IN      DWORD       cchUtf8,
    OUT     PWCHAR      pwResult,
    IN      DWORD       cwResult
    )
{
    return  Dns_Utf8ToUnicode(
                pchUtf8,
                cchUtf8,
                pwResult,
                cwResult );
}

DNS_STATUS
DnsValidateUtf8Byte(
    IN      BYTE        chUtf8,
    IN OUT  PDWORD      pdwTrailCount
    )
{
    return Dns_ValidateUtf8Byte(
                chUtf8,
                pdwTrailCount );
}


//
//  Old cluster call
//
//  DCR:  cleanup -- remove once cluster fixed up
//

VOID
DnsNotifyResolverClusterIp(
    IN      IP4_ADDRESS     ClusterIp,
    IN      BOOL            fAdd
    )
/*++

Routine Description:

    Notify resolver of cluster IP coming on\offline.

Arguments:

    ClusterIp -- cluster IP

    fAdd -- TRUE if coming online;  FALSE if offline.

Return Value:

    None

--*/
{
    //  dumb stub
    //  cluster folks need to call RegisterCluster() to do anything useful
}


//
//  backcompat for macros
//      - DNS server list
//
//  this is called without dnsapi.h include somewhere in IIS
//  search and try and find it
//

#undef DnsGetDnsServerList

DWORD
DnsGetDnsServerList(
    OUT     PIP4_ARRAY *    ppDnsArray
    )
{
    *ppDnsArray = Config_GetDnsServerListIp4(
                        NULL,   // no adapter name
                        TRUE    // force reread
                        );

    //  if no servers read, return

    if ( !*ppDnsArray )
    {
        return 0;
    }

    return( (*ppDnsArray)->AddrCount );
}

//
//  Config UI, ipconfig backcompat
//
//  DCR_CLEANUP:  this is called without dnsapi.h include somewhere in DHCP
//  search and try and find it
//

#undef  DnsGetPrimaryDomainName_A

#define PrivateQueryConfig( Id )      DnsQueryConfigAllocEx( Id, NULL, FALSE )

PSTR 
WINAPI
DnsGetPrimaryDomainName_A(
    VOID
    )
{
    return  PrivateQueryConfig( DnsConfigPrimaryDomainName_A );
}




//
//  Delete once clear
//

#ifndef DEFINED_DNS_FAILED_UPDATE_INFO
typedef struct _DnsFailedUpdateInfo
{
    IP4_ADDRESS     Ip4Address;
    IP6_ADDRESS     Ip6Address;
    DNS_STATUS      Status;
    DWORD           Rcode;
}
DNS_FAILED_UPDATE_INFO, *PDNS_FAILED_UPDATE_INFO;
#endif

VOID
DnsGetLastFailedUpdateInfo(
    OUT     PDNS_FAILED_UPDATE_INFO     pInfo
    )
{
    //  fill in last info

    RtlZeroMemory(
        pInfo,
        sizeof(*pInfo) );
}

//
//  End export.c
//


BOOL
ConvertAnsiToUnicodeInPlace(
    IN OUT  PWCHAR          pString,
    IN      DWORD           BufferSize
    )
/*++

Routine Description:

    Convert ANSI string in buffer to unicode in place.

Arguments:

    pString     -- buffer with ANSI string

    BufferSize  -- size of buffer

Return Value:

    TRUE if successful.
    FALSE on error.

--*/
{
    DWORD   size;
    DWORD   length;
    PSTR    pansiString = NULL;

    //
    //  make string copy
    //

    size = strlen( (PSTR)pString ) + 1;

    pansiString = ALLOCATE_HEAP( size );
    if ( !pansiString )
    {
        return  FALSE;
    }
    RtlCopyMemory(
        pansiString,
        pString,
        size );

    //
    //  convert to unicode
    //
    //  DCR:  MBTWC might take size that includes NULL and return that size
    //

    size--;

    length = MultiByteToWideChar(
                CP_ACP,
                0,                  // no flags
                (PCHAR) pansiString,
                (INT) size,
                pString,
                BufferSize          // assuming adequate length
                );

    pString[length] = 0;

    //  cleanup

    FREE_HEAP( pansiString );

    //  return
    //      - length == 0 is failure unless input length was zero
    //          unless input length was zero

    return( length != 0 || size==0 );
}


INT
WSAAPI
getnameinfoW(
    IN      const struct sockaddr * pSockaddr,
    IN      socklen_t               SockaddrLength,
    OUT     PWCHAR                  pNodeName,
    IN      DWORD                   NodeBufferSize,
    OUT     PWCHAR                  pServiceName,
    IN      DWORD                   ServiceBufferSize,
    IN      INT                     Flags
    )
/*++

Routine Description:

    Unicode version of getnameinfo()

    Protocol independent address-to-name translation routine.
    Spec'd in RFC 2553, section 6.5.

Arguments:

    pSockaddr           - sockaddr to translate

    SockaddrLength      - length of sockaddr

    pNodeName           - ptr to buffer to recv node name

    NodeBufferSize      - size of NodeName buffer

    pServiceName        - ptr to buffer to recv the service name.

    ServiceBufferSize   - size of ServiceName buffer

    Flags               - flags of type NI_*.

Return Value:

    ERROR_SUCCESS if successful.
    Winsock error code on failure.

--*/
{
    INT     status;

    //
    //  zero result buffers
    //
    //  this is a multi-step call, so some buffers may be filled
    //  in even if there is an error doing the second call
    //

    if ( pNodeName )
    {
        *pNodeName = 0;
    }
    if ( pServiceName )
    {
        *pServiceName = 0;
    }

    //
    //  call ANSI getnameinfo()
    //

    status = getnameinfo(
                pSockaddr,
                SockaddrLength,
                (PCHAR) pNodeName,
                NodeBufferSize,
                (PCHAR) pServiceName,
                ServiceBufferSize,
                Flags );

    if ( pNodeName && *pNodeName != 0 )
    {
        if ( ! ConvertAnsiToUnicodeInPlace(
                    pNodeName,
                    NodeBufferSize ) )
        {
            if ( status == NO_ERROR )
            {
                status = WSAEFAULT;
            }
        }
    }

    if ( pServiceName && *pServiceName != 0 )
    {
        if ( ! ConvertAnsiToUnicodeInPlace(
                    pServiceName,
                    ServiceBufferSize ) )
        {
            if ( status == NO_ERROR )
            {
                status = WSAEFAULT;
            }
        }
    }

    return  status;
}



//
//  DCR_CLEANUP:  who is using this?
//  No longer used in netdiag
//  May delete if not used by test
//

DNS_STATUS
DnsFindAuthoritativeZone(
    IN      PDNS_NAME       pszName,
    IN      DWORD           dwFlags,
    IN      PIP4_ARRAY      pIp4Servers,
    OUT     PDNS_NETINFO *  ppNetworkInfo
    )
/*++

Routine Description:

    Find name of authoritative zone.

    Result of FAZ:
        - zone name
        - primary DNS server name
        - primary DNS IP list

    EXPORTED function!

Arguments:

    pszName         -- name to find authoritative zone for

    dwFlags         -- flags to use for DnsQuery

    aipQueryServers -- servers to query, defaults used if NULL

    ppNetworkInfo   -- ptr to adapter list built for FAZ

Return Value:

    ERROR_SUCCESS if successful.
    Error code on failure.

--*/
{
    PDNS_ADDR_ARRAY parray = NULL;

    if ( pIp4Servers )
    {
        parray = DnsAddrArray_CreateFromIp4Array( pIp4Servers );
        if ( !parray )
        {
            return  DNS_ERROR_NO_MEMORY;
        }
    }

    return   Faz_Private(
                pszName,
                dwFlags,
                parray,
                ppNetworkInfo );
}

//
//  DCR_CLEANUP:  who is using this?
//  May delete if not used in test
//

DNS_STATUS
Dns_FindAuthoritativeZoneLib(
    IN      PDNS_NAME       pszName,
    IN      DWORD           dwFlags,
    IN      PIP4_ARRAY      aipQueryServers,
    OUT     PDNS_NETINFO *  ppNetworkInfo
    )
{
    return  DnsFindAuthoritativeZone(
                pszName,
                dwFlags,
                aipQueryServers,
                ppNetworkInfo );
}



//
//  DHCP backcompat -- really only for test dll;  kill after clean build propagates
//
#if DNSAPI_XP_ENTRY

DNS_STATUS
WINAPI
DnsAsyncRegisterInit(
   IN   PSTR                pszIgnored
   )
{
    return  DnsDhcpRegisterInit();
}

DNS_STATUS
WINAPI
DnsAsyncRegisterTerm(
   VOID
   )
{
    return  DnsDhcpRegisterTerm();
}


DNS_STATUS
WINAPI
DnsRemoveRegistrations(
   VOID
   )
{
    return  DnsDhcpRemoveRegistrations();
}


DNS_STATUS
WINAPI
DnsAsyncRegisterHostAddrs(
    IN  PWSTR                   pszAdapterName,
    IN  PWSTR                   pszHostName,
    IN  PREGISTER_HOST_ENTRY    pHostAddrs,
    IN  DWORD                   dwHostAddrCount,
    IN  PIP4_ADDRESS            pipDnsServerList,
    IN  DWORD                   dwDnsServerCount,
    IN  PWSTR                   pszDomainName,
    IN  PREGISTER_HOST_STATUS   pRegisterStatus,
    IN  DWORD                   dwTTL,
    IN  DWORD                   dwFlags
    )
{
    return DnsDhcpRegisterHostAddrs(
                pszAdapterName,
                pszHostName,
                pHostAddrs,
                dwHostAddrCount,
                pipDnsServerList,
                dwDnsServerCount,
                pszDomainName,
                pRegisterStatus,
                dwTTL,
                dwFlags );
}

DNS_STATUS
WINAPI
DnsDhcpSrvRegisterInitialize(
    IN      PDNS_CREDENTIALS    pCredentials
    )
{
    return  DnsDhcpSrvRegisterInit(
                pCredentials,
                0               // default queue length
                );
}
#endif




#if DNSAPI_XP_ENTRY
//
//  Socket routines
//
//  Note:  i don't believe these were used outside dns (resolver, dnslib, dnsup)
//      so could probably delete
//

DNS_STATUS
Dns_InitializeWinsock(
    VOID
    )
{
    return  Socket_InitWinsock();
}


DNS_STATUS
Dns_InitializeWinsockEx(
    IN      BOOL            fForce
    )
{
    return  Socket_InitWinsock();
}


VOID
Dns_CleanupWinsock(
    VOID
    )
{
    Socket_CleanupWinsock();
}


#undef Dns_CloseSocket
#undef Dns_CloseConnection

VOID
Dns_CloseConnection(
    IN      SOCKET          Socket
    )
{
    Socket_CloseEx( Socket, TRUE );
}

VOID
Dns_CloseSocket(
    IN      SOCKET          Socket
    )
{
    Socket_CloseEx( Socket, FALSE );
}


SOCKET
Dns_CreateSocketEx(
    IN      INT             Family,
    IN      INT             SockType,
    IN      IP4_ADDRESS     IpAddress,
    IN      USHORT          Port,
    IN      DWORD           dwFlags
    )
/*++

Routine Description:

    Create socket.

    EXPORTED  (ICS?)  Dns_CreateSocket -- needs removal

Arguments:

    Family -- socket family AF_INET or AF_INET6

    SockType -- SOCK_DGRAM or SOCK_STREAM

    IpAddress -- IP address to listen on (net byte order)

    Port -- desired port in net order
                - NET_ORDER_DNS_PORT for DNS listen sockets
                - 0 for any port

    dwFlags -- specifiy the attributes of the sockets

Return Value:

    Socket if successful.
    Otherwise INVALID_SOCKET.

--*/
{
    SOCKET          sock;
    DNS_ADDR        addr;
    PDNS_ADDR       paddr = NULL;

    //  if address, convert

    if ( IpAddress )
    {
        paddr = &addr;
        DnsAddr_BuildFromIp4(
            paddr,
            IpAddress,
            0 );
    }

    //  real call
    //      - map error back into INVALID_SOCKET

    sock = Socket_Create(
                Family,
                SockType,
                paddr,
                Port,
                dwFlags );

    if ( sock == 0 )
    {
        sock = INVALID_SOCKET;
    }
    return  sock;
}


SOCKET
Dns_CreateSocket(
    IN      INT             SockType,
    IN      IP4_ADDRESS     IpAddress,
    IN      USHORT          Port
    )
/*++

Routine Description:

    Wrapper function for CreateSocketEx. Passes in 0 for dwFlags (as opposed
    to Dns_CreateMulticastSocket, which passes in flags to specify that
    the socket is to be used for multicasting).

    EXPORTED (ICS)!   Delete Dns_CreateSocket() when clear.

Arguments:

    SockType -- SOCK_DGRAM or SOCK_STREAM

    IpAddress -- IP address to listen on (net byte order)

    Port -- desired port in net order
                - NET_ORDER_DNS_PORT for DNS listen sockets
                - 0 for any port

Return Value:

    socket if successful.
    Otherwise INVALID_SOCKET.

--*/
{
    return  Dns_CreateSocketEx(
                AF_INET,
                SockType,
                IpAddress,
                Port,
                0           // no flags
                );
}

//
//  Dummy -- here only to keep same def file
//      delete once clean build world
//
//  Note:  do not believe this was used period in XP
//
//  Once verify can delete
//

SOCKET
Dns_CreateMulticastSocket(
    IN      INT             SockType,
    IN      IP4_ADDRESS     ipAddress,
    IN      USHORT          Port,
    IN      BOOL            fSend,
    IN      BOOL            fReceive
    )
{
    return  (SOCKET) INVALID_SOCKET;
}

#endif

//
//  End export.c
//
=== C:/Users/treeman/Desktop/windows nt source code\Source\Win2K3\NT\ds\dns\dnsapi\hostfile.c ===
/*++

Copyright (c) 2000-2001  Microsoft Corporation

Module Name:

    hostfile.c

Abstract:

    Read host file data.

Author:

    Jim Gilroy (jamesg)     October 2000

Revision History:

--*/


#include "local.h"

//  sockreg.h includes "etc" directory file opens
//  sockreg.h is NT file so must define NTSTATUS first

#ifndef NTSTATUS
#define NTSTATUS LONG
#endif

#include <sockreg.h>

//
//  Host file defs
//  Note, HOST_FILE_INFO blob defined in dnsapip.h
//

#define HOST_FILE_PATH_LENGTH  (MAX_PATH + sizeof("\\hosts") + 1)

//
//  Host file record TTL
//      (use a week)
//

#define HOSTFILE_RECORD_TTL  (604800)




BOOL
HostsFile_Open(
    IN OUT  PHOST_FILE_INFO pHostInfo
    )
/*++

Routine Description:

    Open hosts file or rewind existing file to beginning.

Arguments:

    pHostInfo - ptr to host info;

        hFile - must be NULL if file not previously opened
            otherwise hFile is assumed to be existing FILE pointer

        pszFileName - NULL to open "hosts" file
            otherwise is name of file to open

Return Value:

    None.

--*/
{
    CHAR    hostFileNameBuffer[ HOST_FILE_PATH_LENGTH ];

    DNSDBG( TRACE, (
        "HostsFile_Open()\n" ));

    //
    //  open host file OR rewind if already open
    //

    if ( pHostInfo->hFile == NULL )
    {
        PSTR  pnameFile = pHostInfo->pszFileName;

        if ( !pnameFile )
        {
            pnameFile = "hosts";
        }

        pHostInfo->hFile = SockOpenNetworkDataBase(
                                pnameFile,
                                hostFileNameBuffer,
                                HOST_FILE_PATH_LENGTH,
                                "r" );
    }
    else
    {
        rewind( pHostInfo->hFile );
    }

    return ( pHostInfo->hFile ? TRUE : FALSE );
}



VOID
HostsFile_Close(
    IN OUT  PHOST_FILE_INFO pHostInfo
    )
/*++

Routine Description:

    Close hosts file.

Arguments:

    pHostInfo -- ptr to host info;  hFile assumed to contain file pointer

Return Value:

    None.

--*/
{
    DNSDBG( TRACE, (
        "HostsFile_Close()\n" ));

    if ( pHostInfo->hFile )
    {
        fclose( pHostInfo->hFile );
        pHostInfo->hFile = NULL;
    }
}



VOID
BuildHostfileRecords(
    IN OUT  PHOST_FILE_INFO pHostInfo
    )
/*++

Routine Description:

    Build records from hostfile line.

Arguments:

    pHostInfo -- ptr to host info

Return Value:

    TRUE if successful.
    FALSE on error.

--*/
{
    DNS_LIST    aliasList;
    PCHAR *     paliasEntry;
    PCHAR       palias;
    PDNS_RECORD prr;

    DNSDBG( TRACE, (
        "BuildHostfileRecords()\n" ));

    //
    //  create all the records
    //      - A or AAAA for name
    //      - CNAMEs for aliases
    //      - PTR
    //
    //  for hosts file records
    //      - section == ANSWER
    //      - hostsfile flag set
    //

    prr = Dns_CreateForwardRecord(
                (PDNS_NAME) pHostInfo->pHostName,
                0,                      // any type
                & pHostInfo->Addr,
                HOSTFILE_RECORD_TTL,
                DnsCharSetAnsi,
                DnsCharSetUnicode );

    pHostInfo->pForwardRR = prr;
    if ( prr )
    {
        SET_RR_HOSTS_FILE( prr );
        prr->Flags.S.Section = DnsSectionAnswer;
    }

    //
    //  build aliases into list of CNAME records
    //      - append forward lookup answer with each CNAME  
    //

    DNS_LIST_STRUCT_INIT( aliasList );

    for( paliasEntry = pHostInfo->AliasArray;
         palias = *paliasEntry;
         paliasEntry++ )
    {
        PDNS_RECORD prrForward = pHostInfo->pForwardRR;
        PDNS_RECORD prrAnswer;

        DNSDBG( INIT, (
            "Building for alias %s for hostname %s\n",
            palias,
            pHostInfo->pHostName ));

        prr = Dns_CreatePtrTypeRecord(
                    (PDNS_NAME) palias,
                    TRUE,                   // make name copy
                    (PDNS_NAME) pHostInfo->pHostName,
                    DNS_TYPE_CNAME,
                    HOSTFILE_RECORD_TTL,
                    DnsCharSetAnsi,
                    DnsCharSetUnicode );
        if ( prr )
        {
            SET_RR_HOSTS_FILE( prr );
            prr->Flags.S.Section = DnsSectionAnswer;
            DNS_LIST_STRUCT_ADD( aliasList, prr );

            //  append forward record

            if ( prrForward &&
                 (prrAnswer = Dns_RecordCopy_W(prrForward)) )
            {
                DNS_LIST_STRUCT_ADD( aliasList, prrAnswer );
            }
        }
    }

    pHostInfo->pAliasRR = aliasList.pFirst;

    //
    //  PTR points only to name
    //

    prr = Dns_CreatePtrRecordEx(
                & pHostInfo->Addr,
                (PDNS_NAME) pHostInfo->pHostName,   // target name
                HOSTFILE_RECORD_TTL,
                DnsCharSetAnsi,
                DnsCharSetUnicode );

    pHostInfo->pReverseRR = prr;
    if ( prr )
    {
        SET_RR_HOSTS_FILE( prr );
        prr->Flags.S.Section = DnsSectionAnswer;
    }

    IF_DNSDBG( QUERY )
    {
        DnsDbg_RecordSet(
            "HostFile forward record:",
            pHostInfo->pForwardRR );

        DnsDbg_RecordSet(
            "HostFile reverse record:",
            pHostInfo->pReverseRR );

        if ( pHostInfo->pAliasRR )
        {
            DnsDbg_RecordSet(
                "HostFile alias records:",
                pHostInfo->pAliasRR );
        }
    }
}



BOOL
TokenizeHostFileLine(
    IN OUT  PHOST_FILE_INFO pHostInfo
    )
/*++

Routine Description:

    Reads an entry from hosts file.

Arguments:

    pHostInfo -- ptr to host info;
        if hFile is NULL, first attempts host file open
        other fields are filled with info from next hostfile line

Return Value:

    TRUE if successfully tokenized line.
    FALSE on empty or bad line

--*/
{
    PCHAR       pch;
    PCHAR       ptoken;
    DWORD       countAlias = 0;
    DWORD       count = 0;

    DNSDBG( TRACE, ( "TokenizeHostFileLine()\n" ));

    //
    //  tokenize line
    //

    pch = pHostInfo->HostLineBuf;

    while( pch )
    {
        //  strip leading whitespace

        while( *pch == ' ' || *pch == '\t' )
        {
            pch++;
        }
        ptoken = pch;

        //
        //  NULL terminate token
        //      - NULL pch serves as signal to stop after this token
        //

        pch = strpbrk( pch, " \t#\n\r" );
        if ( pch != NULL )
        {
            //  empty (zero-length) token => done now

            if ( pch == ptoken )
            {
                break;
            }

            //  terminated by whitespace -- may be another token

            if ( *pch == ' ' || *pch == '\t' )
            {
                *pch++ = '\0';
            }

            //  terminated by EOL -- no more tokens

            else    // #\r\n
            {
                *pch = '\0';
                pch = NULL;
            }
        }
        count++;

        //
        //  save address, name or alias
        //

        if ( count == 1 )
        {
            pHostInfo->pAddrString = ptoken;
        }
        else if ( count == 2 )
        {
            pHostInfo->pHostName = ptoken;
        }
        else
        {
            if ( countAlias >= MAXALIASES )
            {
                break;
            }
            pHostInfo->AliasArray[ countAlias++ ] = ptoken;
        }
    }

    //  NULL terminate alias array

    pHostInfo->AliasArray[ countAlias ] = NULL;

    IF_DNSDBG( INIT )
    {
        if ( count >= 2 )
        {
            PSTR    palias;

            DnsDbg_Printf(
                "Parsed host file line:\n"
                "\tAddress  = %s\n"
                "\tHostname = %s\n",
                pHostInfo->pAddrString,
                pHostInfo->pHostName );

            countAlias = 0;
            while ( palias = pHostInfo->AliasArray[countAlias] )
            {
                DnsDbg_Printf(
                    "\tAlias    = %s\n",
                    palias );
                countAlias++;
            }
        }
    }

    return( count >= 2 );
}



BOOL
HostsFile_ReadLine(
    IN OUT  PHOST_FILE_INFO pHostInfo
    )
/*++

Routine Description:

    Reads an entry from hosts file.

Arguments:

    pHostInfo -- ptr to host info;
        if hFile is NULL, first attempts host file open
        other fields are filled with info from next hostfile line

Return Value:

    TRUE if successfully reads a host entry.
    FALSE if on EOF or no hosts file found.

--*/
{
    IP4_ADDRESS     ip4;
    IP6_ADDRESS     ip6;

    DNSDBG( TRACE, (
        "HostsFile_ReadLine()\n" ));

    //
    //  open hosts file if not open
    //

    if ( pHostInfo->hFile == NULL )
    {
        HostsFile_Open( pHostInfo );
        if ( pHostInfo->hFile == NULL )
        {
            return  FALSE;
        }
    }

    //
    //  loop until successfully read IP address
    //

    while( 1 )
    {
        //  setup for next line

        pHostInfo->pForwardRR   = NULL;
        pHostInfo->pReverseRR   = NULL;
        pHostInfo->pAliasRR     = NULL;

        //  read line, quit on EOF

        if ( ! fgets(
                    pHostInfo->HostLineBuf,
                    sizeof(pHostInfo->HostLineBuf) - 1,
                    pHostInfo->hFile ) )
        {
            return FALSE;
        }

        //  tokenize line

        if ( !TokenizeHostFileLine( pHostInfo ) )
        {
            continue;
        }

        //
        //  read address
        //      - try IP4
        //      - try IP6
        //      - otherwise skip
        //

        if ( Dns_StringToDnsAddr_A(
                &pHostInfo->Addr,
                pHostInfo->pAddrString
                ) )
        {
            break;
        }

        //  invalid address, ignore line

        DNSDBG( INIT, (
            "Error parsing host file address %s\n",
            pHostInfo->pAddrString ));
        continue;
    }

    //
    //  build records for line if desired
    //

    if ( pHostInfo->fBuildRecords )
    {
        BuildHostfileRecords( pHostInfo );
    }

    return TRUE;
}



BOOL
HostsFile_Query(
    IN OUT  PQUERY_BLOB         pBlob
    )
/*++

Routine Description:

    Lookup query in host file.

Arguments:

Return Value:

    TRUE if found host file entry.
    FALSE otherwise.

--*/
{
    HOST_FILE_INFO  hostInfo;
    BOOL            fptr = FALSE;
    DNS_ADDR        reverseAddr;
    WORD            wtype;
    WORD            buildType;
    PCHAR           pcnameHost = NULL;
    PDNS_RECORD     prrAlias = NULL;
    PDNS_RECORD     prr = NULL;
    DNS_LIST        forwardList;
    DWORD           bufLength;
    PSTR            pnameAnsi = (PCHAR) pBlob->NameBufferAnsi;


    DNSDBG( INIT, ( "QueryHostFile()\n" ));

    //
    //  determine if host file type
    //

    wtype = pBlob->wType;

    if ( wtype == DNS_TYPE_A ||
         wtype == DNS_TYPE_AAAA ||
         wtype == DNS_TYPE_PTR ||
         wtype == DNS_TYPE_ALL )
    {
        // no op
    }
    else
    {
        return  FALSE;
    }

    //
    //  open hosts file -- if fails, we're done
    //

    RtlZeroMemory(
        &hostInfo,
        sizeof(hostInfo) );

    if ( !HostsFile_Open( &hostInfo ) )
    {
        return( FALSE );
    }

    //
    //  convert name to ANSI
    //      - validate and select IP4\IP6 for PTR
    //

    bufLength = DNS_MAX_NAME_BUFFER_LENGTH;

    if ( ! Dns_NameCopy(
                pnameAnsi,
                & bufLength,
                (PCHAR) pBlob->pNameQuery,
                0,
                DnsCharSetUnicode,
                DnsCharSetAnsi ) )
    {
        goto Cleanup;
    }

    //
    //  reverse name check
    //      - validate and select IP 4\6
    //      - PTR lookup MUST be valid reverse name
    //      - ALL may be reverse name
    //

    if ( wtype == DNS_TYPE_PTR ||
         wtype == DNS_TYPE_ALL )
    {
        DWORD   bufferLength = sizeof(IP6_ADDRESS);
        BOOL    family = 0;

        if ( Dns_ReverseNameToDnsAddr_A(
                &reverseAddr,
                pnameAnsi
                ) )
        {
            fptr = TRUE;
        }
        else if ( wtype == DNS_TYPE_PTR )
        {
            //  bad reverse name
            goto Cleanup;
        }
    }

    //
    //  forward build type
    //      - matches query type
    //      - EXCEPT all which currently builds
    //          AAAA for IP6, A for IP4
    //

    if ( !fptr )
    {
        buildType = wtype;
        DNS_LIST_STRUCT_INIT( forwardList );
    }

    //
    //  read entries from host file until exhausted
    //      - cache A record for each name and alias
    //      - cache PTR to name
    //

    while ( HostsFile_ReadLine( &hostInfo ) )
    {
        //
        //  reverse
        //      - match IP
        //      - success is terminal as reverse mapping is one-to-one
        //
        //  DCR_QUESTION:  parse hosts for multiple reverse mappings?
        //

        if ( fptr )
        {
            if ( ! DnsAddr_IsEqual(
                        &reverseAddr,
                        &hostInfo.Addr,
                        DNSADDR_MATCH_IP ) )
            {
                continue;
            }

            //  create RR
            //      - don't need to use IP conversion version
            //      as we already have reverse lookup name

            DNSDBG( QUERY, (
                "Build PTR record for name %s to %s\n",
                pnameAnsi,
                hostInfo.pHostName ));

            prr = Dns_CreatePtrTypeRecord(
                    (PDNS_NAME) pnameAnsi,
                    TRUE,       // copy name
                    (PDNS_NAME) hostInfo.pHostName,
                    DNS_TYPE_PTR,
                    HOSTFILE_RECORD_TTL,
                    DnsCharSetAnsi,
                    DnsCharSetUnicode );

            if ( !prr )
            {
                SetLastError( DNS_ERROR_NO_MEMORY );
            }
            break;
        }

        //
        //  forward lookup
        //

        else
        {
            PCHAR   pnameHost;

            //  type ALL builds on any match
            //      - build type appropriate for IP
            //
            //  other query types must match address type

            buildType = DnsAddr_DnsType( &hostInfo.Addr );

            if ( wtype != buildType     &&
                 wtype != DNS_TYPE_ALL )
            {
                continue;
            }

            //
            //  check name match
            //
            //  DCR:  use unicode name?
            //

            pnameHost = NULL;

            if ( Dns_NameCompare_A(
                    hostInfo.pHostName,
                    pnameAnsi ) )
            {
                pnameHost = pnameAnsi;
            }

            //
            //  check match to previous CNAME
            //

            else if ( pcnameHost )
            {
                if ( Dns_NameCompare_A(
                        hostInfo.pHostName,
                        pcnameHost ) )
                {
                    pnameHost = pcnameHost;
                }
            }

            //
            //  aliases
            //
            //  DCR_QUESTION:  build aliases even if name hit?
            //
            //  currently:
            //      - don't allow alias if already have direct record
            //      - limit to one alias (CNAME)
            //
            //  if find alias:
            //      - build CNAME record
            //      - save CNAME target (in ANSI for faster compares)
            //      - check CNAME target for subsequent address records (above)
            //

            else if ( IS_DNS_LIST_STRUCT_EMPTY( forwardList )
                        &&
                      !prrAlias )
            {
                PCHAR * paliasEntry;
                PCHAR   palias;

                for( paliasEntry = hostInfo.AliasArray;
                     palias = *paliasEntry;
                     paliasEntry++ )
                {
                    if ( Dns_NameCompare_A(
                            palias,
                            pnameAnsi ) )
                    {
                        DNSDBG( QUERY, (
                            "Build CNAME record for name %s to CNAME %s\n",
                            pnameAnsi,
                            hostInfo.pHostName ));

                        prrAlias = Dns_CreatePtrTypeRecord(
                                        (PDNS_NAME) pnameAnsi,
                                        TRUE,       // copy name
                                        (PDNS_NAME) hostInfo.pHostName,
                                        DNS_TYPE_CNAME,
                                        HOSTFILE_RECORD_TTL,
                                        DnsCharSetAnsi,
                                        DnsCharSetUnicode );
    
                        if ( prrAlias )
                        {
                            pcnameHost = Dns_NameCopyAllocate(
                                            hostInfo.pHostName,
                                            0,
                                            DnsCharSetAnsi,
                                            DnsCharSetAnsi );

                            pnameHost = pcnameHost;
                        }
                        break;
                    }
                }
            }

            //  add address record for this hostline

            if ( pnameHost )
            {
                DNSDBG( QUERY, (
                    "Build address record for name %s\n",
                    pnameHost ));

                prr = Dns_CreateForwardRecord(
                            (PDNS_NAME) pnameHost,
                            buildType,
                            & hostInfo.Addr,
                            HOSTFILE_RECORD_TTL,
                            DnsCharSetAnsi,
                            DnsCharSetUnicode );
                if ( prr )
                {
                    DNS_LIST_STRUCT_ADD( forwardList, prr );
                }
            }
        }
    }

    //
    //  build response
    //
    //  DCR:  new multiple section response
    //

    if ( !fptr )
    {
        prr = forwardList.pFirst;
        if ( prrAlias )
        {
            prrAlias->pNext = prr;
            prr = prrAlias;
        }
    }

    IF_DNSDBG( QUERY )
    {
        DnsDbg_RecordSet(
            "HostFile Answers:",
            prr );
    }
    pBlob->pRecords = prr;


Cleanup:

    //
    //  cleanup
    //

    HostsFile_Close( &hostInfo );

    if ( pcnameHost )
    {
        FREE_HEAP( pcnameHost );
    }

    DNSDBG( TRACE, (
        "Leave  QueryHostFile() -> %d\n"
        "\tprr  = %p\n",
        prr ? TRUE : FALSE,
        prr ));

    return( prr ? TRUE : FALSE );
}

//
//  End hostfile.c
//
=== C:/Users/treeman/Desktop/windows nt source code\Source\Win2K3\NT\ds\dns\dnsapi\iphelp.c ===
/*++

Copyright (c) 2001-2001   Microsoft Corporation

Module Name:

    iphelp.c

Abstract:

    IP help API routines.

Author:

    Jim Gilroy (jamesg)     January 2001

Revision History:

--*/


#include "local.h"



BOOL
IpHelp_Initialize(
    VOID
    )
/*++

Routine Description:

    Startup IP Help API

Arguments:

    None

Return Value:

    TRUE if started successfully.
    FALSE on error.

--*/
{
    return  TRUE;
}



VOID
IpHelp_Cleanup(
    VOID
    )
/*++

Routine Description:

    Cleanup IP Help API

Arguments:

    None

Return Value:

    None

--*/
{
}



DNS_STATUS
IpHelp_GetAdaptersInfo(
    OUT     PIP_ADAPTER_INFO *  ppAdapterInfo
    )
/*++

Routine Description:

    Call IP Help GetAdaptersInfo()

Arguments:

    ppAdapterInfo -- addr to receive pointer to adapter info retrieved

Return Value:

    None

--*/
{
    DNS_STATUS          status = NO_ERROR;
    DWORD               bufferSize;
    INT                 fretry;
    PIP_ADAPTER_INFO    pbuf;


    DNSDBG( TRACE, (
        "GetAdaptersInfo( %p )\n",
        ppAdapterInfo ));

    //
    //  init IP Help (no-op) if already done
    //  

    *ppAdapterInfo = NULL;

    //
    //  call down to get buffer size
    //
    //  start with reasonable alloc, then bump up if too small
    //

    fretry = 0;
    bufferSize = 1000;

    while ( fretry < 2 )
    {
        pbuf = (PIP_ADAPTER_INFO) ALLOCATE_HEAP( bufferSize );
        if ( !pbuf )
        {
            status = DNS_ERROR_NO_MEMORY;
            goto  Unlock;
        }
    
        status = (DNS_STATUS) GetAdaptersInfo(
                                    pbuf,
                                    &bufferSize );
        if ( status == NO_ERROR )
        {
            break;
        }

        FREE_HEAP( pbuf );
        pbuf = NULL;

        //  if buf too small on first try,
        //  continue to retry with suggested buffer size

        if ( status == ERROR_BUFFER_OVERFLOW ||
             status == ERROR_INSUFFICIENT_BUFFER )
        {
            fretry++;
            continue;
        }

        //  any other error is terminal

        DNSDBG( ANY, (
            "ERROR:  GetAdapterInfo() failed with error %d\n",
            status ));
        status = DNS_ERROR_NO_DNS_SERVERS;
        break;
    }

    DNS_ASSERT( !pbuf || status==NO_ERROR );

    if ( status == NO_ERROR )
    {
        *ppAdapterInfo = pbuf;
    }

Unlock:

    DNSDBG( TRACE, (
        "Leave GetAdaptersInfo() => %d\n",
        status ));

    return  status;
}



DNS_STATUS
IpHelp_GetPerAdapterInfo(
    IN      DWORD                   AdapterIndex,
    OUT     PIP_PER_ADAPTER_INFO  * ppPerAdapterInfo
    )
/*++

Routine Description:

    Call IP Help GetPerAdapterInfo()

Arguments:

    AdapterIndex -- index of adapter to get info for

    ppPerAdapterInfo -- addr to receive pointer to per adapter info

Return Value:

    None

--*/
{
    DNS_STATUS              status = NO_ERROR;
    DWORD                   bufferSize;
    INT                     fretry;
    PIP_PER_ADAPTER_INFO    pbuf;


    DNSDBG( TRACE, (
        "GetPerAdapterInfo( %d, %p )\n",
        AdapterIndex,
        ppPerAdapterInfo ));

    //
    //  init IP Help (no-op) if already done
    //  

    *ppPerAdapterInfo = NULL;

    //
    //  call down to get buffer size
    //
    //  start with reasonable alloc, then bump up if too small
    //

    fretry = 0;
    bufferSize = 1000;

    while ( fretry < 2 )
    {
        pbuf = (PIP_PER_ADAPTER_INFO) ALLOCATE_HEAP( bufferSize );
        if ( !pbuf )
        {
            status = DNS_ERROR_NO_MEMORY;
            goto Unlock;
        }
    
        status = (DNS_STATUS) GetPerAdapterInfo(
                                    AdapterIndex,
                                    pbuf,
                                    &bufferSize );
        if ( status == NO_ERROR )
        {
            break;
        }

        FREE_HEAP( pbuf );
        pbuf = NULL;

        //  if buf too small on first try,
        //  continue to retry with suggested buffer size

        if ( status == ERROR_BUFFER_OVERFLOW ||
             status == ERROR_INSUFFICIENT_BUFFER )
        {
            fretry++;
            continue;
        }

        //  any other error is terminal

        DNSDBG( ANY, (
            "ERROR:  GetAdapterInfo() failed with error %d\n",
            status ));
        status = DNS_ERROR_NO_DNS_SERVERS;
        break;
    }

    DNS_ASSERT( !pbuf || status==NO_ERROR );

    if ( status == NO_ERROR )
    {
        *ppPerAdapterInfo = pbuf;
    }

Unlock:

    DNSDBG( TRACE, (
        "Leave GetPerAdapterInfo() => %d\n",
        status ));

    return  status;
}




DNS_STATUS
IpHelp_GetBestInterface(
    IN      IP4_ADDRESS     Ip4Addr,
    OUT     PDWORD          pdwInterfaceIndex
    )
/*++

Routine Description:

    Call IP Help GetBestInterface()

Arguments:

    Ip4Addr -- IP address to check

    pdwInterfaceIndex -- addr to recv interface index

Return Value:

    ERROR_SUCCESS if successful.
    ErrorCode on failure.

--*/
{
    DNS_STATUS  status;

    DNSDBG( TRACE, (
        "GetBestInterface( %08x, %p )\n",
        Ip4Addr,
        pdwInterfaceIndex ));

    //
    //  init IP Help (no-op) if already done
    //  

    status = (DNS_STATUS) GetBestInterface(
                                Ip4Addr,
                                pdwInterfaceIndex );
    
    DNSDBG( TRACE, (
        "Leave GetBestInterface() => %d\n"
        "\tip        = %s\n"
        "\tinterface = %d\n",
        status,
        IP4_STRING( Ip4Addr ),
        *pdwInterfaceIndex ));

    return  status;
}



DNS_STATUS
IpHelp_ParseIpAddressString(
    IN OUT  PIP4_ARRAY          pIpArray,
    IN      PIP_ADDR_STRING     pIpAddrString,
    IN      BOOL                fGetSubnetMask,
    IN      BOOL                fReverse
    )
/*++

Routine Description:

    Build IP array from IP help IP_ADDR_STRING structure.

Arguments:

    pIpArray -- IP array of DNS servers

    pIpAddrString -- pointer to address info with address data

    fGetSubnetMask -- get subnet masks

    fReverse -- reverse the IP array

Return Value:

    ERROR_SUCCESS if successful.
    DNS_ERROR_NO_DNS_SERVERS if nothing parsed.

--*/
{
    PIP_ADDR_STRING pipBlob = pIpAddrString;
    IP4_ADDRESS     ip;
    DWORD           countServers = pIpArray->AddrCount;

    DNSDBG( TRACE, (
        "IpHelp_ParseIpAddressString()\n"
        "\tout IP array = %p\n"
        "\tIP string    = %p\n"
        "\tsubnet?      = %d\n"
        "\treverse?     = %d\n",
        pIpArray,
        pIpAddrString,
        fGetSubnetMask,
        fReverse ));

    //
    //  loop reading IP or subnet
    //
    //  DCR_FIX0:  address and subnet will be misaligned if read separately
    //
    //  DCR:  move to count\allocate model and if getting subnets get together
    //

    while ( pipBlob &&
            countServers < DNS_MAX_IP_INTERFACE_COUNT )
    {
        if ( fGetSubnetMask )
        {
            ip = inet_addr( pipBlob->IpMask.String );

            if ( ip != INADDR_ANY )
            {
                pIpArray->AddrArray[ countServers ] = ip;
                countServers++;
            }
        }
        else
        {
            ip = inet_addr( pipBlob->IpAddress.String );

            if ( ip != INADDR_ANY && ip != INADDR_NONE )
            {
                pIpArray->AddrArray[ countServers ] = ip;
                countServers++;
            }
        }

        pipBlob = pipBlob->Next;
    }

    //  reset IP count

    pIpArray->AddrCount = countServers;

    //  reverse array if desired

    if ( fReverse )
    {
        Dns_ReverseOrderOfIpArray( pIpArray );
    }

    DNSDBG( NETINFO, (
        "Leave IpHelp_ParseIpAddressString()\n"
        "\tcount    = %d\n"
        "\tfirst IP = %s\n",
        countServers,
        countServers
            ? IP_STRING( pIpArray->AddrArray[0] )
            : "" ));

    return  ( pIpArray->AddrCount ) ? ERROR_SUCCESS : DNS_ERROR_NO_DNS_SERVERS;
}



PIP_ADAPTER_ADDRESSES
IpHelp_GetAdaptersAddresses(
    IN      ULONG           Family,
    IN      DWORD           Flags
    )
/*++

Routine Description:

    Call IP Help GetAdaptersAddresses

Arguments:

    Family -- address family

    Flags -- flags

Return Value:

    None

--*/
{
    DNS_STATUS              status = NO_ERROR;
    INT                     retry;
    PIP_ADAPTER_ADDRESSES   pbuf = NULL;
    DWORD                   bufSize = 0x1000;   // start with 4K
    HMODULE                 hlib = NULL;
    FARPROC                 proc;


    DNSDBG( TRACE, (
        "GetAdaptersAddresses()\n"
        "\tFamily   = %d\n"
        "\tFlags    = %08x\n",
        Family,
        Flags ));

    //
    //  init IP Help (no-op) if already done
    //  

    hlib = LoadLibrary( L"iphlpapi.dll" );
    if ( !hlib )
    {
        goto Failed;
    }
    proc = GetProcAddress( hlib, "GetAdaptersAddresses" );
    if ( !proc )
    {
        goto Failed;
    }

    //
    //  call down in loop to allow one buffer resizing
    //

    retry = 0;

    while ( 1 )
    {
        //  allocate a buffer to hold results

        if ( pbuf )
        {
            FREE_HEAP( pbuf );
        }
        pbuf = ALLOCATE_HEAP( bufSize );
        if ( !pbuf )
        {
            goto Failed;
        }

        //  call down

        status = (DNS_STATUS) (*proc)(
                                Family,
                                Flags,
                                NULL,   // no reserved,
                                pbuf,
                                & bufSize );

        if ( status == NO_ERROR )
        {
            break;
        }
        else if ( status != ERROR_BUFFER_OVERFLOW )
        {
            goto Failed;
        }

        DNSDBG( NETINFO, (
            "Retrying GetAdaptersAddresses() with buffer length %d\n",
            bufSize ));

        if ( retry != 0 )
        {
            DNS_ASSERT( FALSE );
            goto Failed;
        }
        continue;
    }

    //  success

    DNSDBG( TRACE, (
        "Leave GetAdaptersAddresses() = %p\n",
        pbuf ));

    IF_DNSDBG( NETINFO )
    {
        DnsDbg_IpAdapterList(
            "IP Help Adapter List",
            pbuf,
            TRUE,   // print addrs
            TRUE    // print list
            );
    }

    return  pbuf;

Failed:

    FREE_HEAP( pbuf );

    if ( status == NO_ERROR )
    {
        status = GetLastError();
    }
    DNSDBG( ANY, (
        "Failed GetAdaptersAddresses() => %d\n",
        status ));

    SetLastError( status );
    return( NULL );
}



DNS_STATUS
IpHelp_ReadAddrsFromList(
    IN      PVOID               pAddrList,
    IN      BOOL                fUnicast,
    IN      DWORD               ScreenMask,         OPTIONAL
    IN      DWORD               ScreenFlags,        OPTIONAL
    OUT     PDNS_ADDR_ARRAY *   ppComboArray,       OPTIONAL
    OUT     PDNS_ADDR_ARRAY *   pp6OnlyArray,       OPTIONAL
    OUT     PDNS_ADDR_ARRAY *   pp4OnlyArray,       OPTIONAL
    OUT     PDWORD              pCount6,            OPTIONAL
    OUT     PDWORD              pCount4             OPTIONAL
    )
/*++

Routine Description:

    Read IP addres from IP help IP_ADAPTER_XXX_ADDRESS list.

Arguments:

    pAddrList -- any IP address list
        PIP_ADAPTER_UNICAST_ADDRESS
        PIP_ADAPTER_ANYCAST_ADDRESS   
        PIP_ADAPTER_MULTICAST_ADDRESS 
        PIP_ADAPTER_DNS_SERVER_ADDRESS

    fUnicast -- this is unicast address list

    ScreenMask -- mask of address flags we care about
        example:
            IP_ADAPTER_ADDRESS_DNS_ELIGIBLE | IP_ADAPTER_ADDRESS_TRANSIENT

    ScreenFlags -- required state of flags within mask
        example:
            IP_ADAPTER_ADDRESS_DNS_ELIGIBLE
        this (with above mask) would screen for eligible non-cluster addresses


Return Value:

    NO_ERROR if successful.
    ErrorCode on failure.

--*/
{
    PIP_ADAPTER_UNICAST_ADDRESS pnextAddr;
    PIP_ADAPTER_UNICAST_ADDRESS paddr;
    DNS_STATUS                  status = NO_ERROR;
    DWORD                       count4 = 0;
    DWORD                       count6 = 0;
    DWORD                       countAll = 0;
    PADDR_ARRAY                 parrayCombo = NULL;
    PADDR_ARRAY                 parray6 = NULL;
    PADDR_ARRAY                 parray4 = NULL;
    DNS_ADDR                    dnsAddr;


    DNSDBG( TRACE, (
        "IpHelp_ReadAddrsFromList( %p )\n",
        pAddrList ));

    //
    //  count
    //  

    pnextAddr = (PIP_ADAPTER_UNICAST_ADDRESS) pAddrList;

    while ( paddr = pnextAddr )
    {
        PSOCKADDR psa;

        pnextAddr = paddr->Next;

        if ( ScreenMask &&
             (ScreenMask & paddr->Flags) != ScreenFlags )
        {
            continue;
        }
        
        //  screen off expired, invalid, bogus

        if ( fUnicast  &&  paddr->DadState != IpDadStatePreferred )
        {
            continue;
        }

        psa = paddr->Address.lpSockaddr;
        if ( !psa )
        {
            DNS_ASSERT( FALSE );
            continue;
        }
#if 0
        //  DCR:  temphack -- screen link-local
        if ( SOCKADDR_IS_IP6(psa) )
        {
            if ( IP6_IS_ADDR_LINKLOCAL( (PIP6_ADDRESS)&((PSOCKADDR_IN6)psa)->sin6_addr ) )
            {
                continue;
            }
        }
#endif
        if ( fUnicast && SOCKADDR_IS_LOOPBACK(psa) )
        {
            continue;
        }
        else if ( SOCKADDR_IS_IP6(psa) )
        {
            count6++;
            countAll++;
        }
        else if ( SOCKADDR_IS_IP4(psa) )
        {
            count4++;
            countAll++;
        }
        ELSE_ASSERT_FALSE;
    }

    //
    //  alloc arrays
    //

    status = DNS_ERROR_NO_MEMORY;

    if ( ppComboArray )
    {
        if ( countAll )
        {
            parrayCombo = DnsAddrArray_Create( countAll );
        }
        *ppComboArray = parrayCombo;
        if ( !parrayCombo && (countAll) )
        {
            goto Failed;
        }
    }
    if ( pp6OnlyArray )
    {
        if ( count6 )
        {
            parray6 = DnsAddrArray_Create( count6 );
        }
        *pp6OnlyArray = parray6;
        if ( !parray6 && count6 )
        {
            goto Failed;
        }
    }
    if ( pp4OnlyArray )
    {
        if ( count4 )
        {
            parray4 = DnsAddrArray_Create( count4 );
        }
        *pp4OnlyArray = parray4;
        if ( !parray4 && count4 )
        {
            goto Failed;
        }
    }

    //
    //  read addrs into array
    //  

    pnextAddr = (PIP_ADAPTER_UNICAST_ADDRESS) pAddrList;

    while ( paddr = pnextAddr )
    {
        PSOCKADDR   psa;
        DWORD       flags = 0;
        DWORD       subnetLen = 0;

        pnextAddr = paddr->Next;

        if ( ScreenMask &&
             (ScreenMask & paddr->Flags) != ScreenFlags )
        {
            continue;
        }

        //  screen off expired, invalid, bogus

        if ( fUnicast  &&  paddr->DadState != IpDadStatePreferred )
        {
            continue;
        }

        psa = paddr->Address.lpSockaddr;
        if ( !psa )
        {
            DNS_ASSERT( FALSE );
            continue;
        }

#if 0
        //  DCR:  temphack -- screen link local

        if ( SOCKADDR_IS_IP6(psa) &&
             IP6_IS_ADDR_LINKLOCAL( (PIP6_ADDRESS)&((PSOCKADDR_IN6)psa)->sin6_addr ) )
        {
            continue;
        }
#endif
        //  screen off loopback

        if ( fUnicast && SOCKADDR_IS_LOOPBACK(psa) )
        {
            continue;
        }

        //
        //  build DNS_ADDR
        //
        //  DCR:  FIX6:  fix subnet length once DaveThaler is in
        //

        if ( fUnicast )
        {
            flags = paddr->Flags;
            subnetLen = 0;
#if 0
            //  TEST HACK:  make transients
            if ( g_DnsTestMode )
            {
                flags |= IP_ADAPTER_ADDRESS_TRANSIENT;
            }
#endif
        }

        if ( !DnsAddr_Build(
                & dnsAddr,
                psa,
                0,          // any family
                subnetLen,
                flags ) )
        {
            DNS_ASSERT( FALSE );
            continue;
        }

        //
        //  AddrArray_AddSockaddrEx() with flag to choose types to add
        //
        //  DCR:  not sure we want local IP6 array as DNS_ADDR --
        //      maybe just plain IP6
        //

        if ( parrayCombo )
        {
            DnsAddrArray_AddAddr(
                parrayCombo,
                & dnsAddr,
                0,          // any family
                0           // no dup screen
                );
        }
        if ( parray6 )
        {
            DnsAddrArray_AddAddr(
                parray6,
                & dnsAddr,
                AF_INET6,   // any family
                0           // no dup screen
                );
        }
        if ( parray4 )
        {
            DnsAddrArray_AddAddr(
                parray4,
                & dnsAddr,
                AF_INET,    // any family
                0           // no dup screen
                );
        }
    }

    //
    //  set counts
    //

    if ( pCount6 )
    {
        *pCount6 = count6;
    }
    if ( pCount4 )
    {
        *pCount4 = count4;
    }

    return  NO_ERROR;


Failed:

    //
    //  cleanup any partial allocs
    //

    DnsAddrArray_Free( parrayCombo );
    DnsAddrArray_Free( parray6 );
    Dns_Free( parray4 );

    DNS_ASSERT( status != NO_ERROR );

    return  status;
}

//
//  End iphelp.c
//
=== C:/Users/treeman/Desktop/windows nt source code\Source\Win2K3\NT\ds\dns\dnsapi\faz.c ===
/*++

Copyright (c) 1997-2002  Microsoft Corporation

Module Name:

    faz.c

Abstract:

    Domain Name System (DNS) API 

    Find Authoritative Zone (FAZ) routines

Author:

    Jim Gilroy (jamesg)     January, 1997

Revision History:

--*/


#include "local.h"


//
//  Max number of server's we'll ever bother to extract from packet
//  (much more and you're out of UDP packet space anyway)
//

#define MAX_NAME_SERVER_COUNT (20)

//
//  Private protos
//

BOOL
IsRootServerAddressIp4(
    IN      IP4_ADDRESS     Ip
    );


//
//  Private utilities
//

PDNS_NETINFO     
buildUpdateNetworkInfoFromFAZ(
    IN      PWSTR           pszZone,
    IN      PWSTR           pszPrimaryDns,
    IN      PDNS_RECORD     pRecord,
    IN      BOOL            fIp4,
    IN      BOOL            fIp6
    )
/*++

Routine Description:

    Build new DNS server list from record list.

Arguments:

    pszZone -- zone name

    pszPrimaryDns -- DNS server name

    pRecord -- record list from FAZ or other lookup that contain DNS server
        host records

    fIp4 -- running IP4

    fIp6 -- running IP6

Return Value:

    ERROR_SUCCESS if successful.
    Error code on failure.

--*/
{
    CHAR            buffer[ MAX_NAME_SERVER_COUNT*sizeof(DNS_ADDR) + sizeof(DNS_ADDR_ARRAY) ];
    PDNS_ADDR_ARRAY parray = (PDNS_ADDR_ARRAY)buffer;
    BOOL            fmatch = FALSE;
    WORD            wtype;

    DNSDBG( TRACE, (
        "buildUpdateNetworkInfoFromFAZ( %S )\n",
        pszZone ));

    //
    //  DNS hostname unknown, extract from SOA or NS records
    //

    if ( !pszPrimaryDns || !pRecord )
    {
        return( NULL );
    }

    //
    //  init IP array
    //

    DnsAddrArray_Init( parray, MAX_NAME_SERVER_COUNT );

    //
    //  find IP addresses of primary DNS server
    //

    while ( pRecord )
    {
        //  if not A record
        //      - we're done if already read records, otherwise continue

        wtype = pRecord->wType;

        if ( wtype != DNS_TYPE_AAAA  &&  wtype != DNS_TYPE_A )
        {
            if ( parray->AddrCount != 0 )
            {
                break;
            }
            fmatch = FALSE;
            pRecord = pRecord->pNext;
            continue;
        }

        //  if record has name, check it
        //  otherwise match is the same as previous record

        if ( pRecord->pName )
        {
            fmatch = Dns_NameCompare_W(
                        pRecord->pName,
                        pszPrimaryDns );
        }
        if ( fmatch )
        {
            if ( wtype == DNS_TYPE_AAAA )
            {
                if ( fIp6 )
                {
                    DnsAddrArray_AddIp6(
                        parray,
                        & pRecord->Data.AAAA.Ip6Address,
                        0,      // no scope
                        DNSADDR_MATCH_ADDR
                        );
                }
            }
            else if ( wtype == DNS_TYPE_A )
            {
                if ( fIp4 &&
                     !IsRootServerAddressIp4( pRecord->Data.A.IpAddress ) )
                {
                    DnsAddrArray_AddIp4(
                        parray,
                        pRecord->Data.A.IpAddress,
                        DNSADDR_MATCH_ADDR
                        );
                }
            }
        }
        pRecord = pRecord->pNext;
        continue;
    }

    if ( parray->AddrCount == 0 )
    {
        return( NULL );
    }

    //
    //  convert into UPDATE adapter list
    //

    return  NetInfo_CreateForUpdate(
                pszZone,
                pszPrimaryDns,
                parray,
                0 );
}



BOOL
ValidateZoneNameForUpdate(
    IN      PWSTR           pszZone
    )
/*++

Routine Description:

    Check if zone is valid for update.

Arguments:

    pszZone -- zone name

Return Value:

    TRUE    -- zone is valid for update
    FALSE   -- zone is invalid, should NOT send update to this zone

--*/
{
    PWSTR       pzoneExclusions = NULL;
    PWSTR       pch;
    PWSTR       pnext;
    DNS_STATUS  status;
    DWORD       length;
    BOOL        returnVal = TRUE;
    DWORD       labelCount;

    DNSDBG( TRACE, (
        "ValidateZoneNameForUpdate( %S )\n",
        pszZone ));

    //
    //  never update the root
    //

    if ( !pszZone || *pszZone==L'.' )
    {
        return( FALSE );
    }

    //
    //  never update TLD
    //      - except config override in case someone
    //      gave themselves a single label domain name
    //

    if ( g_UpdateTopLevelDomains )
    {
        return( TRUE );
    }

    labelCount = Dns_NameLabelCountW( pszZone );

    if ( labelCount > 2 )
    {
        return( TRUE );
    }
    if ( labelCount < 2 )
    {
        return( FALSE );
    }

    //
    //  screen out
    //      - "in-addr.arpa"
    //      - "ip6.arpa"
    //

    if ( Dns_NameCompare_W(
            L"in-addr.arpa",
            pszZone ) )
    {
        return( FALSE );
    }
    if ( Dns_NameCompare_W(
            L"ip6.arpa",
            pszZone ) )
    {
        return( FALSE );
    }

    return( TRUE );

#if 0
    //
    //  DCR:  "update zone allowed" list?
    //
    //  note:  this is complicated as need to test
    //      SECOND label because tough cases are
    //      "co.uk" -- difficult to test first label  
    //

    //
    //  read exclusion list from registry
    //

    status = DnsRegGetValueEx(
                NULL,               // no session
                NULL,               // no adapter
                NULL,               // no adapter name
                DnsRegUpdateZoneExclusions,
                REGTYPE_UPDATE_ZONE_EXCLUSIONS,
                DNSREG_FLAG_DUMP_EMPTY,         // dump empty string
                (PBYTE *) &pzoneExclusions
                );

    if ( status != ERROR_SUCCESS ||
         !pzoneExclusions )
    {
        ASSERT( pzoneExclusions == NULL );
        return( TRUE );
    }

    //
    //  check all exclusion zones   
    //

    pch = pzoneExclusions;

    while ( 1 )
    {
        //  check for termination
        //  or find next string

        length = wcslen( pch );
        if ( length == 0 )
        {
            break;
        }
        pnext = pch + length + 1;

        //
        //  check this string
        //

        DNSDBG( TRACE, (
            "Update zone compare to %S\n",
            pch ));

        if ( Dns_NameCompare_W(
                pch,
                pszZone ) )
        {
            returnVal = FALSE;
            break;
        }

        pch = pnext;
    }

    //  if no match, zone is valid

    FREE_HEAP( pzoneExclusions );

    return( returnVal );
#endif
}



DNS_STATUS
Faz_Private(
    IN      PWSTR           pszName,
    IN      DWORD           dwFlags,
    IN      PADDR_ARRAY     pServArray,
    OUT     PDNS_NETINFO *  ppNetworkInfo
    )
/*++

Routine Description:

    Find name of authoritative zone.

    Result of FAZ:
        - zone name
        - primary DNS server name
        - primary DNS IP list

Arguments:

    pszName         -- name to find authoritative zone for

    dwFlags         -- flags to use for DnsQuery

    pServArray      -- servers to query, defaults used if NULL

    ppNetworkInfo   -- ptr to adapter list built for FAZ

Return Value:

    ERROR_SUCCESS if successful.
    Error code on failure.

--*/
{
    DNS_STATUS          status;
    PDNS_RECORD         precord = NULL;
    PDNS_RECORD         precordPrimary = NULL;
    PDNS_RECORD         precordSOA = NULL;
    PWSTR               pszdnsHost = NULL;
    PDNS_NETINFO        pnetInfo = NULL;
    PWSTR               pzoneName;
    BOOL                fip4;
    BOOL                fip6;
    BOOL                queriedA = FALSE;
    BOOL                queriedAAAA = FALSE;

    DNSDBG( QUERY, (
        "Faz_Private()\n"
        "\tname         %S\n"
        "\tflags        %08x\n"
        "\tserver list  %p\n"
        "\tnetinfo addr %p\n",
        pszName,
        dwFlags,
        pServArray,
        ppNetworkInfo ));


    //
    //  query until find name with SOA record -- the zone root
    //
    //  note, MUST check that actually get SOA record
    //      - servers may return referral
    //      - lame server might return CNAME to name
    //

    pzoneName = pszName;

    while ( pzoneName )
    {
        if ( precord )
        {
            Dns_RecordListFree( precord );
            precord = NULL;
        }

        status = Query_Private(
                        pzoneName,
                        DNS_TYPE_SOA,
                        dwFlags |
                            DNS_QUERY_TREAT_AS_FQDN |
                            DNS_QUERY_ALLOW_EMPTY_AUTH_RESP,
                        pServArray,
                        & precord );

        //
        //  find SOA and possibly primary name A
        //
        //  test for ERROR_SUCCESS, AUTH_EMPTY or NAME_ERROR
        //  in all cases first record should be SOA
        //      ERROR_SUCCESS -- answer section
        //      NAME_ERROR or AUTH_EMPTY -- authority section
        //  all MAY also have additional record for SOA primary server
        //

        if ( status == ERROR_SUCCESS ||
             status == DNS_INFO_NO_RECORDS ||
             status == DNS_ERROR_RCODE_NAME_ERROR )
        {
            if ( precord && precord->wType == DNS_TYPE_SOA )
            {
                //  received SOA
                //  devolve name to zone name

                DNSDBG( QUERY, (
                    "FAZ found SOA (section %d) at zone %S\n",
                    precord->Flags.S.Section,
                    precord->pName ));

                while( pzoneName &&
                    ! Dns_NameCompare_W( pzoneName, precord->pName ) )
                {
                    pzoneName = Dns_GetDomainNameW( pzoneName );
                }
                precordSOA = precord;
                status = ERROR_SUCCESS;
                break;
            }
            //  this could be because server no-recurse or
            //  bum server (BIND) that CNAMEs even when type=SOA
            //      drop down to devolve name and continue

            DNSDBG( ANY, (
                "ERROR:  response from FAZ query with no SOA records.\n" ));
        }

        //
        //  other errors besides
        //      - name error
        //      - no records
        //  indicate terminal problem
        //

        else
        {
            DNS_ASSERT( precord == NULL );
            goto Cleanup;
        }

        //
        //  name error or empty response, continue with next higher domain
        //

        pzoneName = Dns_GetDomainNameW( pzoneName );
    }

    //
    //  if reached root or TLD -- no update
    //      - note currently returning SERVFAIL because of
    //      screwy netlogon logic
    //

    if ( !ValidateZoneNameForUpdate(pzoneName) )
    {
        //status = DNS_ERROR_INVALID_ZONE_OPERATION;
        status = DNS_ERROR_RCODE_SERVER_FAILURE;
        //status = DNS_ERROR_RCODE_REFUSED;
        goto Cleanup;
    }

    //
    //  determine required protocol for update
    //
    //  need to insure we get server address records for protocol that is
    //  reachable from this client;
    //
    //  more specifically the ideal protocol for the update is a protocol
    //  that the target DNS server supports and that the client also supports
    //  ON THE ADAPTER that the server is reached through;
    //  this is close to being the protocol that the FAZ went over -- but
    //  if from the cache, we don't have (can't yet get) that info;  and that
    //  is a sufficient but not necessary condition;
    //
    //  furthermore we can't even make the global determination that we don't
    //  support IP4, because we can always open an IP4 socket (on loopback interface)
    //
    //  solution:
    //      - IP4 only => trivial done
    //      - IP6 =>
    //          - try to build from FAZ, insisting on IP6
    //          -
    //
    //  note, even here we're assuming 
    //

    //
    //  get supported protocol info
    //

    Util_GetActiveProtocols(
        & fip6,
        & fip4 );

    //
    //  have SOA record
    //
    //  if primary server A record in the packet, use it
    //  otherwise query for primary DNS A record
    //

    DNS_ASSERT( precordSOA );
    DNS_ASSERT( status == ERROR_SUCCESS );

    pszdnsHost = precordSOA->Data.SOA.pNamePrimaryServer;

    //
    //  check additional for primary A\AAAA record
    //      if found, build network info blob for update
    //      that points only to update server
    //

    pnetInfo = buildUpdateNetworkInfoFromFAZ(
                        pzoneName,
                        pszdnsHost,
                        precordSOA,
                        fip4,
                        fip6 );
    if ( pnetInfo )
    {
        goto Cleanup;
    }

    //
    //  if no primary server A\AAAA record found -- must query
    //

    DNSDBG( QUERY, (
        "WARNING:  FAZ making additional query for primary!\n"
        "\tPrimary (%S) address record should have been in additional section!\n",
        pszdnsHost ));


    while ( 1 )
    {
        WORD    wtype;

        //
        //  protocol order IP6 first
        //
        //  this protects us in the IP6 only scenario from getting IP4
        //  DNS address when in fact we can't use it because of no IP4
        //  binding;  the reverse issue is not much of a problem, the
        //  autoconfig IP6 address works and we probably won't be
        //  getting an IP6 address, unless IP6 DNS is desired
        //
        //  DCR:  update address\protocol problem
        //      ultimately should either
        //      A) verify received address is reachable
        //      if not direct from IpHlpApi, then find adapter and verify
        //      we have address of requeried protocol on the adapter
        //      B) get addresses for any protocols we have, and make sure
        //      send code uses them
        //

        if ( fip6 && !queriedAAAA )
        {
            wtype = DNS_TYPE_AAAA;
            queriedAAAA = TRUE;
        }
        else if ( fip4 && !queriedA )
        {
            wtype = DNS_TYPE_A;
            queriedA = TRUE;
        }
        else
        {
            DNSDBG( FAZ, (
                "No more protocols for FAZ server address query!\n"
                "\tserver       = %S\n"
                "\tqueried AAAA = %d\n"
                "\tqueried A    = %d\n",
                pszdnsHost,
                queriedAAAA,
                queriedA ));

            status = DNS_ERROR_RCODE_SERVER_FAILURE;
            goto Cleanup;
        }
        
        status = Query_Private(
                        pszdnsHost,
                        wtype,
                        dwFlags |
                            DNS_QUERY_TREAT_AS_FQDN |
                            DNS_QUERY_ALLOW_EMPTY_AUTH_RESP,
                        pServArray,
                        & precordPrimary );

        if ( status == ERROR_SUCCESS )
        {
            pnetInfo = buildUpdateNetworkInfoFromFAZ(
                                pzoneName,
                                pszdnsHost,
                                precordPrimary,
                                fip4,
                                fip6 );
            if ( pnetInfo )
            {
                goto Cleanup;
            }
        }

        DNSDBG( FAZ, (
            "FAZ server address query failed to produce records!\n"
            "\tserver       = %S\n"
            "\ttype         = %d\n"
            "\tstatus       = %d\n"
            "\tprecords     = %p\n",
            pszdnsHost,
            wtype,
            status,
            precordPrimary ));

        Dns_RecordListFree( precordPrimary );
        precordPrimary = NULL;
        continue;
    }

Cleanup:

    Dns_RecordListFree( precord );
    Dns_RecordListFree( precordPrimary );

    *ppNetworkInfo = pnetInfo;

    DNSDBG( QUERY, (
        "Leaving Faz_Private()\n"
        "\tstatus   = %d\n"
        "\tzone     = %S\n",
        status,
        pzoneName ));

    return( status );
}



DNS_STATUS
DoQuickFAZ(
    OUT     PDNS_NETINFO *      ppNetworkInfo,
    IN      PWSTR               pszName,
    IN      PADDR_ARRAY         aipServerList OPTIONAL
    )
/*++

Routine Description:

    FAZ to build network info from FAZ result

    Result of FAZ:
        - zone name
        - primary DNS server name
        - primary DNS IP list

    This routine is cheap shell around real FAZ to handle
    network failure issue, speeding things in net down
    condition.

Arguments:

    ppNetworkInfo -- addr to recv ptr to network info

    pszName -- name for update

    aipServerList -- IP array of DNS servers to contact

Return Value:

    ERROR_SUCCESS if successful.
    ErrorCode on failure

--*/
{
    DNS_STATUS  status;

    DNSDBG( TRACE, ( "DoQuickFAZ( %S )\n", pszName ));

    if ( IsKnownNetFailure() )
    {
        return GetLastError();
    }

    //
    //  call real FAZ
    //      - get results as adapter list struct
    //

    status = Faz_Private(
                    pszName,
                    aipServerList ? DNS_QUERY_BYPASS_CACHE : 0,
                    aipServerList,
                    ppNetworkInfo       // build adapter list from results
                    );

    //
    //  if unsuccessful, check if network failure
    //

    if ( status != ERROR_SUCCESS && !aipServerList )
    {
        if ( status == WSAEFAULT ||
             status == WSAENOTSOCK ||
             status == WSAENETDOWN ||
             status == WSAENETUNREACH ||
             status == WSAEPFNOSUPPORT ||
             status == WSAEAFNOSUPPORT ||
             status == WSAEHOSTDOWN ||
             status == WSAEHOSTUNREACH ||
             status == ERROR_TIMEOUT )
        {
            SetKnownNetFailure( status );
            return status;
        }
    }
    return status;
}




//
//  Update network info preparation
//

DWORD
GetDnsServerListsForUpdate(
    IN OUT  PDNS_ADDR_ARRAY *   DnsServerListArray,
    IN      DWORD               ArrayLength,
    IN      DWORD               Flags
    )
/*++

Routine Description:

    Get DNS server lists for update.

    One DNS server list returned for each valid updateable adapter.

Arguments:

    DnsServerListArray -- array to hold DNS server lists found

    ArrayLength -- length of array

    Flags -- update flags

Return Value:

    Count of DNS server lists found.

--*/
{
    PDNS_NETINFO      pnetInfo;
    DWORD             iter1;
    DWORD             iter2;
    DWORD             countNets = 0;

    //  clear server list array

    RtlZeroMemory(
        DnsServerListArray,
        sizeof(PADDR_ARRAY) * ArrayLength );


    //  build list from current netinfo

    pnetInfo = GetNetworkInfo();
    if ( ! pnetInfo )
    {
        return 0;
    }

    //
    //  check if update is disabled
    //      - update dependent on registration state
    //      - global registration state is OFF
    //      => then skip
    //

    if ( (Flags & DNS_UPDATE_SKIP_NO_UPDATE_ADAPTERS)
            &&
         ! g_RegistrationEnabled )              
    {
        return 0;
    }

    //
    //  build DNS server list for each updateable adapter
    //

    for ( iter1 = 0; iter1 < pnetInfo->AdapterCount; iter1++ )
    {
        PDNS_ADAPTER        padapter;
        DWORD               serverCount;
        PDNS_ADDR_ARRAY     parray;

        if ( iter1 >= ArrayLength )
        {
            break;
        }

        padapter = NetInfo_GetAdapterByIndex( pnetInfo, iter1 );
        if ( !padapter )
        {
            continue;
        }

        //  skip if no DNS servers

        if ( !padapter->pDnsAddrs )
        {
            continue;
        }

        //  skip "no-update" adapter?
        //      - if skip-disabled flag set for this update
        //      - and no-update flag on adapter

        if ( (Flags & DNS_UPDATE_SKIP_NO_UPDATE_ADAPTERS) &&
                !(padapter->InfoFlags & AINFO_FLAG_REGISTER_IP_ADDRESSES) )
        {
            continue;
        }

        //
        //  valid update adapter
        //      - create\save DNS server list
        //      - bump count of lists
        //
        //  DCR:  functionalize adapter DNS list to IP array
        //
        //  DCR_PERF:  collapse DNS server lists in netinfo BEFORE allocating them
        //      in other words bring this function into collapse and fix
        //

        parray = DnsAddrArray_CreateCopy( padapter->pDnsAddrs );
        if ( ! parray )
        {
            goto Exit;
        }
        DnsServerListArray[countNets] = parray;
        countNets++;
    }

Exit:

    //  free network info
    //  return count of DNS server lists found

    NetInfo_Free( pnetInfo );

    return countNets;
}



DWORD
cleanDeadAdaptersFromArray(
    IN OUT  PADDR_ARRAY *   IpArrayArray,
    IN OUT  PDNS_NETINFO *  NetworkInfoArray,   OPTIONAL
    IN      DWORD           Count
    )
/*++

Routine Description:

    Cleanup and remove from array(s) adapter info, when an
    adapter is determined to be dead, useless or duplicate for
    the update.

Arguments:

    IpArrayArray -- array of IP array pointers

    NetworkInfoArray -- array of ptrs to network info structs

    Count -- length arrays (current adapter count)

Return Value:

    New adapter count.

--*/
{
    register DWORD iter;

    //
    //  remove useless adapters
    //  useless means no DNS server list
    //

    for ( iter = 0;  iter < Count;  iter++ )
    {
        PADDR_ARRAY parray = IpArrayArray[iter];

        if ( !parray || parray->AddrCount==0 )
        {
            if ( parray )
            {
                DnsAddrArray_Free( parray );
                IpArrayArray[ iter ] = NULL;
            }
            Count--;
            IpArrayArray[ iter ]   = IpArrayArray[ Count ];
            IpArrayArray[ Count ]  = NULL;

            //  if have corresponding NetworkInfo array, clean it in same fashion

            if ( NetworkInfoArray )
            {
                if ( NetworkInfoArray[iter] )
                {
                    NetInfo_Free( NetworkInfoArray[iter] );
                    NetworkInfoArray[iter] = NULL;
                }
                NetworkInfoArray[ iter ]    = NetworkInfoArray[ Count ];
                NetworkInfoArray[ Count ]   = NULL;
            }
        }
    }

    //  return count of cleaned list

    return  Count;
}



DWORD
eliminateDuplicateAdapterFromArrays(
    IN OUT  PADDR_ARRAY*     IpArrayArray,
    IN OUT  PDNS_NETINFO *  NetworkInfoArray,
    IN OUT  PDNS_RECORD *   NsRecordArray,
    IN      DWORD           Count,
    IN      DWORD           DuplicateIndex
    )
/*++

Routine Description:

    Cleanup and remove from array(s) adapter info, when an
    adapter is determined to be dead, useless or duplicate for
    the update.

Arguments:

    IpArrayArray -- array of IP array pointers

    NetworkInfoArray -- array of ptrs to network info structs

    NsRecordArray -- array of NS record lists for FAZed zone

    Count -- length arrays (current adapter count)

    DuplicateIndex -- index of duplicate

Return Value:

    New adapter count.

--*/
{
    ASSERT( DuplicateIndex < Count );

    DNSDBG( TRACE, (
        "eliminateDuplicateAdapterFromArrays( dup=%d, max=%d )\n",
        DuplicateIndex,
        Count ));

    //
    //  free any info on duplicate adapter
    //

    FREE_HEAP( IpArrayArray[DuplicateIndex] );
    NetInfo_Free( NetworkInfoArray[DuplicateIndex] );
    Dns_RecordListFree( NsRecordArray[DuplicateIndex] );

    //
    //  copy top entry to this spot
    //

    Count--;

    if ( Count != DuplicateIndex )
    {
        IpArrayArray[DuplicateIndex]     = IpArrayArray[Count];
        NetworkInfoArray[DuplicateIndex] = NetworkInfoArray[Count];
        NsRecordArray[DuplicateIndex]    = NsRecordArray[Count];
    }

    return Count;
}



DWORD
combineDnsServerListsForTwoAdapters(
    IN OUT  PADDR_ARRAY*    IpArrayArray,
    IN      DWORD           Count,
    IN      DWORD           Index1,
    IN      DWORD           Index2
    )
/*++

Routine Description:

    Combine DNS server lists for two adapters.

    Note, this unions the DNS server lists for the two
    adapters and eliminates the higher indexed adapter
    from the list.

Arguments:

    IpArrayArray -- array of IP array pointers

    Count -- length of pointer array

    Index1 -- low index to union

    Index2 -- high index to union

Return Value:

    New adapter count.

--*/
{
    PADDR_ARRAY punionArray = NULL;

    DNSDBG( TRACE, (
        "combineDnsServerListsForTwoAdapters( count=%d, i1=%d, i2=%d )\n",
        Count,
        Index1,
        Index2 ));

    ASSERT( Index1 < Count );
    ASSERT( Index2 < Count );
    ASSERT( Index1 < Index2 );

    //
    //  union the arrays
    //
    //  if unable to allocate union, then just use list in first array
    //  and dump second
    //

    DnsAddrArray_Union( IpArrayArray[Index1], IpArrayArray[Index2], &punionArray );

    if ( punionArray )
    {
        FREE_HEAP( IpArrayArray[Index1] );
        IpArrayArray[Index1] = punionArray;
    }

    FREE_HEAP( IpArrayArray[Index2] );
    IpArrayArray[Index2] = NULL;

    //
    //  swap deleted entry with last entry in list
    //

    Count--;
    IpArrayArray[Index2] = IpArrayArray[ Count ];

    return( Count );
}



DNS_STATUS
CollapseDnsServerListsForUpdate(
    IN OUT  PADDR_ARRAY*    DnsServerListArray,
    OUT     PDNS_NETINFO *  NetworkInfoArray,
    IN OUT  PDWORD          pNetCount,
    IN      PWSTR           pszUpdateName
    )
/*++

Routine Description:

    Builds update network info blob for each unique name space.

    This essentially starts with DNS server list for each adapter
    and progressively detects adapters pointing at same name space
    until down minimum number of name spaces.

Arguments:

    DnsServerListArray -- array of ptrs to DNS server lists for each adapter

    NetworkInfoArray -- array to hold pointer to update network info for each
        adapter on return contains ptr to network info for each unique name
        space update should be sent to

    dwNetCount -- starting count of individual adapters networks

    pszUpdateName -- name to update

Return Value:

    Count of unique name spaces to update.
    NetworkInfoArray contains update network info blob for each name space.

--*/
{
    PDNS_RECORD     NsRecordArray[ UPDATE_ADAPTER_LIMIT ];
    PADDR_ARRAY     parray1;
    DWORD           iter1;
    DWORD           iter2;
    DWORD           maxCount = *pNetCount;
    DNS_STATUS      status = DNS_ERROR_NO_DNS_SERVERS;


    DNSDBG( TRACE, (
        "collapseDnsServerListsForUpdate( count=%d )\n"
        "\tupdate name = %S\n",
        maxCount,
        pszUpdateName ));

    //
    //  clean list of any useless adapters
    //

    maxCount = cleanDeadAdaptersFromArray(
                    DnsServerListArray,
                    NULL,                   // no network info yet
                    maxCount );

    //
    //  if only one adapter -- nothing to compare
    //      - do FAZ to build update network info, if
    //      successful, we're done
    //

    if ( maxCount <= 1 )
    {
        if ( maxCount == 1 )
        {
            NetworkInfoArray[0] = NULL;

            status = DoQuickFAZ(
                        &NetworkInfoArray[0],
                        pszUpdateName,
                        DnsServerListArray[0] );

            if ( NetworkInfoArray[0] )
            {
                goto Done;
            }
            FREE_HEAP( DnsServerListArray[0] );
            maxCount = 0;
            goto Done;
        }
        goto Done;
    }

    //
    //  clear NetworkInfo
    //

    RtlZeroMemory(
        NetworkInfoArray,
        maxCount * sizeof(PVOID) );

    //
    //  loop through combining adapters with shared DNS servers
    //
    //  as we combine entries we shrink the list
    //

    for ( iter1 = 0; iter1 < maxCount; iter1++ )
    {
        parray1 = DnsServerListArray[ iter1 ];

        for ( iter2=iter1+1;  iter2 < maxCount;  iter2++ )
        {
            if ( AddrArray_IsIntersection(
                    parray1,
                    DnsServerListArray[iter2] ) )
            {
                DNSDBG( UPDATE, (
                    "collapseDSLFU:  whacking intersecting DNS server lists\n"
                    "\tadapters %d and %d (max =%d)\n",
                    iter1,
                    iter2,
                    maxCount ));

                maxCount = combineDnsServerListsForTwoAdapters(
                                DnsServerListArray,
                                maxCount,
                                iter1,
                                iter2 );
                iter2--;
                parray1 = DnsServerListArray[ iter1 ];
            }
        }
    }

    DNSDBG( TRACE, (
        "collapseDSLFU:  count after dup server whack = %d\n",
        maxCount ));


#if 0
    //  clean again, in case we missed something

    maxCount = cleanDeadAdaptersFromArray(
                    DnsServerListArray,
                    NULL,                   // no network info yet
                    maxCount );
#endif

    //
    //  FAZ remaining adapters
    //
    //  save result NetworkInfo struct
    //      => for comparison to determine adapters that share DNS name space
    //      => to return to caller to do actual update
    //
    //  if FAZ fails this adapter is useless for update -- dead issue
    //      adapter is removed and replaced by highest array entry
    //

    for ( iter1 = 0; iter1 < maxCount; iter1++ )
    {
        status = Faz_Private(
                    pszUpdateName,
                    DNS_QUERY_BYPASS_CACHE,
                    DnsServerListArray[ iter1 ],
                    & NetworkInfoArray[ iter1 ] );

        if ( status != ERROR_SUCCESS )
        {
            FREE_HEAP( DnsServerListArray[ iter1 ] );
            DnsServerListArray[ iter1 ] = NULL;
            maxCount--;
            DnsServerListArray[ iter1 ] = DnsServerListArray[ maxCount ];
            iter1--;
            continue;
        }
    }

#if 0
    //  clean out failed FAZ entries

    maxCount = cleanDeadAdaptersFromArray(
                    DnsServerListArray,
                    NetworkInfoArray,
                    maxCount );
#endif

    //  if only able to FAZ one adapter -- we're done
    //      only point here is to skip a bunch of unnecessary
    //      stuff in the most typical case multi-adapter case

    if ( maxCount <= 1 )
    {
        DNSDBG( TRACE, (
            "collapseDSLFU:  down to single FAZ adapter\n" ));
        goto Done;
    }

    //
    //  compare FAZ results to see if adapters are in same name space
    //
    //  do two passes
    //  -  on first pass only compare based on FAZ results, if successful
    //      we eliminate duplicate adapter
    //
    //  -  on second pass, adapters that are still separate are compared;
    //      if they don't fail FAZ matches (which are retried) then NS queries
    //      are used to determine if separate nets;
    //      note that NS query results are saved, so NS query is order N, even
    //      though we are in N**2 loop
    //

    RtlZeroMemory(
        NsRecordArray,
        maxCount * sizeof(PVOID) );

    for ( iter1=0;  iter1 < maxCount;  iter1++ )
    {
        for ( iter2=iter1+1;  iter2 < maxCount;  iter2++ )
        {
            if ( Faz_CompareTwoAdaptersForSameNameSpace(
                        DnsServerListArray[iter1],
                        NetworkInfoArray[iter1],
                        NULL,               // no NS list
                        DnsServerListArray[iter2],
                        NetworkInfoArray[iter2],
                        NULL,               // no NS list
                        FALSE               // don't use NS queries
                        ) )
            {
                DNSDBG( UPDATE, (
                    "collapseDSLFU:  whacking same-FAZ adapters\n"
                    "\tadapters %d and %d (max =%d)\n",
                    iter1,
                    iter2,
                    maxCount ));

                eliminateDuplicateAdapterFromArrays(
                    DnsServerListArray,
                    NetworkInfoArray,
                    NsRecordArray,
                    maxCount,
                    iter2 );

                maxCount--;
                iter2--;
            }
        }
    }

    DNSDBG( TRACE, (
        "collapseDSLFU:  count after dup FAZ whack = %d\n",
        maxCount ));


    //  second pass using NS info
    //  if NS info is created, we save it to avoid requery

    for ( iter1=0;  iter1 < maxCount;  iter1++ )
    {
        for ( iter2=iter1+1;  iter2 < maxCount;  iter2++ )
        {
            if ( Faz_CompareTwoAdaptersForSameNameSpace(
                        DnsServerListArray[iter1],
                        NetworkInfoArray[iter1],
                        & NsRecordArray[iter1],
                        DnsServerListArray[iter2],
                        NetworkInfoArray[iter2],
                        & NsRecordArray[iter2],
                        TRUE                // follow up with NS queries
                        ) )
            {
                DNSDBG( UPDATE, (
                    "collapseDSLFU:  whacking same-zone-NS adapters\n"
                    "\tadapters %d and %d (max =%d)\n",
                    iter1,
                    iter2,
                    maxCount ));

                eliminateDuplicateAdapterFromArrays(
                    DnsServerListArray,
                    NetworkInfoArray,
                    NsRecordArray,
                    maxCount,
                    iter2 );

                maxCount--;
                iter2--;
            }
        }
    }

    //
    //  kill off any NS records found
    //

    for ( iter1=0;  iter1 < maxCount;  iter1++ )
    {
        Dns_RecordListFree( NsRecordArray[iter1] );
    }

Done:

    //
    //  set count of remaining adapters (update DNS server lists)
    //
    //  return status
    //      - success if have any update adapter
    //      - on failure bubble up FAZ error
    //  

    DNSDBG( TRACE, (
        "Leave CollapseDnsServerListsForUpdate( collapsed count=%d )\n",
        maxCount ));

    *pNetCount = maxCount;

    if ( maxCount > 0 )
    {
        status = ERROR_SUCCESS;
    }
    return status;
}



BOOL
WINAPI
Faz_CompareTwoAdaptersForSameNameSpace(
    IN      PDNS_ADDR_ARRAY     pDnsServerList1,
    IN      PDNS_NETINFO        pNetInfo1,
    IN OUT  PDNS_RECORD *       ppNsRecord1,
    IN      PDNS_ADDR_ARRAY     pDnsServerList2,
    IN      PDNS_NETINFO        pNetInfo2,
    IN OUT  PDNS_RECORD *       ppNsRecord2,
    IN      BOOL                bDoNsCheck
    )
/*++

Routine Description:

    Compare two adapters to see if in same name space for update.

Arguments:

    pDnsServerList1 -- IP array of DNS servers for first adapter

    pNetInfo1   -- update netinfo for first adapter

    ppNsRecord1     -- addr of ptr to NS record list of update zone done on
                        first adapter;  NULL if no NS check required;  if
                        NS check required and *ppNsRecord1 is NULL, NS query
                        is made and results returned

    pDnsServerList2 -- IP array of DNS servers for second adapter

    pNetInfo2   -- update netinfo for second adapter

    ppNsRecord2     -- addr of ptr to NS record list of update zone done on
                        second adapter;  NULL if no NS check required;  if
                        NS check required and *ppNsRecord2 is NULL, NS query
                        is made and results returned

    bDoNsCheck      -- include update-zone NS check compare;  if NS overlap then
                        name spaces assumed to be the same

Return Value:

    ERROR_SUCCESS if successful.
    Error status on failure.

--*/
{
    DNS_STATUS      status = NO_ERROR;
    BOOL            fsame = FALSE;
    PDNS_ADAPTER    padapter1;
    PDNS_ADAPTER    padapter2;
    PDNS_RECORD     pns1 = NULL;
    PDNS_RECORD     pns2 = NULL;
    PDNS_RECORD     pnotUsed = NULL;
    PWSTR           pzoneName;


    //
    //  done if bad params
    //

    if ( !pDnsServerList1 || !pDnsServerList2 )
    {
        return FALSE;
    }

    //
    //  validity check
    //      - note:  could probably be just ASSERT()
    //

    if ( ! NetInfo_IsForUpdate(pNetInfo1) ||
         ! NetInfo_IsForUpdate(pNetInfo2) )
    {
        ASSERT( FALSE );
        return( FALSE );
    }

    //
    //  compare FAZ results
    //
    //  first compare zone names
    //  if FAZ returns different zone names, then clearly
    //  have disjoint name spaces
    //

    pzoneName = NetInfo_UpdateZoneName( pNetInfo1 );

    if ( ! Dns_NameCompare_W(
                pzoneName,
                NetInfo_UpdateZoneName( pNetInfo2 ) ) )
    {
        return FALSE;
    }

    //
    //  check if pointing at same server:
    //      - if have same update DNS server -- have a match
    //      - if same server name -- have a match
    //

    padapter1 = NetInfo_GetAdapterByIndex( pNetInfo1, 0 );
    padapter2 = NetInfo_GetAdapterByIndex( pNetInfo2, 0 );

    if ( DnsAddrArray_IsEqual(
            padapter1->pDnsAddrs,
            padapter2->pDnsAddrs,
            DNSADDR_MATCH_ADDR ) )
    {
        return TRUE;
    }
    else
    {
        fsame = Dns_NameCompare_W(
                    NetInfo_UpdateServerName( pNetInfo1 ),
                    NetInfo_UpdateServerName( pNetInfo2 ) );
    }

    //
    //  if matched or not doing NS check => then done
    //

    if ( fsame || !bDoNsCheck )
    {
        return( fsame );
    }

    //
    //  NS check
    //
    //  if not pointing at same server, may be two multimaster primaries
    //
    //  use NS queries to determine if NS lists for same servers are in
    //  fact a match
    //

    if ( ppNsRecord1 )
    {
        pns1 = *ppNsRecord1;
    }
    if ( !pns1 )
    {
        status = Query_Private(
                        pzoneName,
                        DNS_TYPE_NS,
                        DNS_QUERY_BYPASS_CACHE,
                        pDnsServerList1,
                        &pns1 );

        if ( status != ERROR_SUCCESS )
        {
            goto Done;
        }
        pnotUsed = DnsRecordSetDetach( pns1 );
        if ( pnotUsed )
        {
            Dns_RecordListFree( pnotUsed );
            pnotUsed = NULL;
        }
    }

    if ( ppNsRecord2 )
    {
        pns2 = *ppNsRecord2;
    }
    if ( !pns2 )
    {
        status = Query_Private(
                        pzoneName,
                        DNS_TYPE_NS,
                        DNS_QUERY_BYPASS_CACHE,
                        pDnsServerList2,
                        &pns2 );

        if ( status != ERROR_SUCCESS )
        {
            goto Done;
        }
        pnotUsed = DnsRecordSetDetach( pns2 );
        if ( pnotUsed )
        {
            Dns_RecordListFree( pnotUsed );
            pnotUsed = NULL;
        }
    }

    //
    //  if NS lists the same -- same namespace
    //

    fsame = Dns_RecordSetCompareForIntersection( pns1, pns2 );

Done:

    //
    //  cleanup or return NS lists
    //
    //  note, purpose of returning is so caller can avoid requerying
    //      NS if must make compare against multiple other adapters
    //

    if ( ppNsRecord1 )
    {
        *ppNsRecord1 = pns1;
    }
    else
    {
        Dns_RecordListFree( pns1 );
    }

    if ( ppNsRecord2 )
    {
        *ppNsRecord2 = pns2;
    }
    else
    {
        Dns_RecordListFree( pns2 );
    }

    return fsame;
}



BOOL
WINAPI
Faz_AreServerListsInSameNameSpace(
    IN      PWSTR               pszDomainName,
    IN      PADDR_ARRAY         pServerList1,
    IN      PADDR_ARRAY         pServerList2
    )
/*++

Routine Description:

    Compare two adapters to see if in same name space for update.

Arguments:

    pszDomainName   -- domain name to update

    pServerList1 -- IP array of DNS servers for first adapter

    pServerList2 -- IP array of DNS servers for second adapter

Return Value:

    TRUE -- if adapters are found to be on same net
    FALSE -- otherwise (definitely NOT or unable to determine)

--*/
{
    DNS_STATUS          status;
    BOOL                fsame = FALSE;
    PDNS_NETINFO        pnetInfo1 = NULL;
    PDNS_NETINFO        pnetInfo2 = NULL;


    DNSDBG( TRACE, (
        "Faz_AreServerListsInSameNameSpace()\n" ));


    //  bad param screening

    if ( !pServerList1 || !pServerList2 || !pszDomainName )
    {
        return FALSE;
    }

    //
    //  compare DNS server lists
    //  if any overlap, them effectively in same DNS namespace
    //

    if ( AddrArray_IsIntersection( pServerList1, pServerList2 ) )
    {
        return TRUE;
    }

    //
    //  if no DNS server overlap, must compare FAZ results
    //
    //  note:  FAZ failures interpreted as FALSE response
    //      required for callers in asyncreg.c
    //

    status = Faz_Private(
                pszDomainName,
                DNS_QUERY_BYPASS_CACHE,
                pServerList1,
                &pnetInfo1 );

    if ( status != ERROR_SUCCESS )
    {
        goto Cleanup;
    }

    status = Faz_Private(
                pszDomainName,
                DNS_QUERY_BYPASS_CACHE,
                pServerList2,
                &pnetInfo2 );

    if ( status != ERROR_SUCCESS )
    {
        goto Cleanup;
    }

    //
    //  call the comparison routine
    //

    fsame = Faz_CompareTwoAdaptersForSameNameSpace(
                pServerList1,
                pnetInfo1,
                NULL,               // no NS record list
                pServerList2,
                pnetInfo2,
                NULL,               // no NS record list
                TRUE                // follow up with NS queries
                );

Cleanup:

    NetInfo_Free( pnetInfo1 );
    NetInfo_Free( pnetInfo2 );

    return fsame;
}



BOOL
WINAPI
CompareMultiAdapterSOAQueries(
    IN      PWSTR           pszDomainName,
    IN      PIP4_ARRAY      pServerList1,
    IN      PIP4_ARRAY      pServerList2
    )
/*++

Routine Description:

    Compare two adapters to see if in same name space for update.

    Note, IP4 routine called by asyncreg.c code.
    The working routine is Faz_CompareServerListsForSameNameSpace().

Arguments:

    pszDomainName   -- domain name to update

    pServerList1 -- IP array of DNS servers for first adapter

    pServerList2 -- IP array of DNS servers for second adapter

Return Value:

    TRUE -- if adapters are found to be on same net
    FALSE -- otherwise (definitely NOT or unable to determine)

--*/
{
    PADDR_ARRAY parray1;
    PADDR_ARRAY parray2;
    BOOL        bresult;

    DNSDBG( TRACE, (
        "CompareMultiAdapterSOAQueries()\n" ));

    parray1 = DnsAddrArray_CreateFromIp4Array( pServerList1 );
    parray2 = DnsAddrArray_CreateFromIp4Array( pServerList2 );

    bresult = Faz_AreServerListsInSameNameSpace(
                pszDomainName,
                parray1,
                parray2 );

    DnsAddrArray_Free( parray1 );
    DnsAddrArray_Free( parray2 );

    return  bresult;
}



//
//  DCR:  IP6 support for FAZ NS list address grab
//

IP4_ADDRESS
FindHostIpAddressInRecordList(
    IN      PDNS_RECORD     pRecordList,
    IN      PWSTR           pszHostName
    )
/*++

Routine Description:

    Find IP for hostname, if its A record is in list.

    NOTE: This code was borrowed from \dns\dnslib\query.c!  ;-)

Arguments:

    pRecordList - incoming RR set

    pszHostName - hostname to find 

Return Value:

    IP address matching hostname, if A record for hostname found.
    Zero if not found.

--*/
{
    register PDNS_RECORD prr = pRecordList;

    //
    //  loop through all records until find IP matching hostname
    //

    while ( prr )
    {
        if ( prr->wType == DNS_TYPE_A &&
                Dns_NameCompare_W(
                    prr->pName,
                    pszHostName ) )
        {
            return( prr->Data.A.IpAddress );
        }
        prr = prr->pNext;
    }

    return( 0 );
}



PADDR_ARRAY
GetNameServersListForDomain(
    IN      PWSTR           pDomainName,
    IN      PADDR_ARRAY     pServerList
    )
/*++

Routine Description:

    Get IPs for all DNS servers for zone.

Arguments:

    pDomainName -- zone name

    pServerList -- server list to query

Return Value:

    IP array of IPs of DNS servers for zone.
    NULL if error.

--*/
{
    DNS_STATUS      status = NO_ERROR;
    PDNS_RECORD     prrQuery = NULL;
    PADDR_ARRAY     pnsArray = NULL;
    DWORD           countAddr = 0;

    DNSDBG( TRACE, (
        "GetNameServersListForDomain()\n"
        "\tdomain name %S\n"
        "\tserver list %p\n",
        pDomainName,
        pServerList ));

    status = Query_Private(
                pDomainName,
                DNS_TYPE_NS,
                DNS_QUERY_BYPASS_CACHE,
                pServerList,
                &prrQuery );

    if ( status == NO_ERROR )
    {
        PDNS_RECORD pTemp = prrQuery;
        DWORD       dwCount = 0;

        while ( pTemp )
        {
            dwCount++;
            pTemp = pTemp->pNext;
        }

        pnsArray = DnsAddrArray_Create( dwCount );

        if ( pnsArray )
        {
            pTemp = prrQuery;

            while ( pTemp )
            {
                if ( pTemp->wType == DNS_TYPE_NS )
                {
                    IP4_ADDRESS ip = 0;

                    ip = FindHostIpAddressInRecordList(
                             pTemp,
                             pTemp->Data.NS.pNameHost );

                    if ( !ip )
                    {
                        PDNS_RECORD pARecord = NULL;

                        //
                        //  Query again to get the server's address
                        //

                        status = Query_Private(
                                    pTemp->Data.NS.pNameHost,
                                    DNS_TYPE_A,
                                    DNS_QUERY_BYPASS_CACHE,
                                    pServerList,
                                    &pARecord );

                        if ( status == NO_ERROR &&
                             pARecord )
                        {
                            ip = pARecord->Data.A.IpAddress;
                            Dns_RecordListFree( pARecord );
                        }
                    }
                    if ( ip )
                    {
                        DnsAddrArray_AddIp4(
                            pnsArray,
                            ip,
                            TRUE );
                    }
                }

                pTemp = pTemp->pNext;
            }
        }
    }

    if ( prrQuery )
    {
        Dns_RecordListFree( prrQuery );
    }

    return pnsArray;
}



//
//  Root server screening
//
//  Root servers as of .net 2003 ship:
//      198.41.0.4
//      128.9.0.107
//      192.33.4.12
//      128.8.10.90
//      192.203.230.10
//      192.5.5.241
//      192.112.36.4
//      128.63.2.53
//      192.36.148.17
//      192.58.128.30
//      193.0.14.129 
//      198.32.64.12
//      202.12.27.33
//

IP4_ADDRESS g_RootServers4[] =
{
    0x040029c6,
    0x6b000980,
    0x0c0421c0,
    0x5a0a0880,
    0x0ae6cbc0,
    0xf10505c0,
    0x042470c0,
    0x35023f80,
    0x119424c0,
    0x1e803ac0,
    0x810e00c1,
    0x0c4020c6,
    0x211b0cca,
    0
};


BOOL
IsRootServerAddressIp4(
    IN      IP4_ADDRESS     Ip
    )
/*++

Routine Description:

    Determine if address is root server address.

Arguments:

    Ip -- IP to screen

Return Value:

    TRUE if root server address.
    FALSE otherwise.

--*/
{
    DWORD       iter;
    IP4_ADDRESS rootIp;

    //
    //  check against all root servers
    //

    iter = 0;

    while ( (rootIp = g_RootServers4[iter++]) != 0 )
    {
        if ( rootIp == Ip )
        {
            return  TRUE;
        }
    }
    return  FALSE;
}

//
//  End of faz.c
//
=== C:/Users/treeman/Desktop/windows nt source code\Source\Win2K3\NT\ds\dns\dnsapi\local.h ===
/*++

Copyright (c) 1997-2001  Microsoft Corporation

Module Name:

    local.h

Abstract:

    Domain Name System (DNS) API

    Dns API local include file

Author:

    Jim Gilroy (jamesg)     May 1997

Revision History:

--*/


#ifndef _DNSAPILOCAL_INCLUDED_
#define _DNSAPILOCAL_INCLUDED_

#define UNICODE 1
#define _UNICODE 1

#include <nt.h>           // build for Win95 compatibility
#include <ntrtl.h>
#include <nturtl.h>
#include <windows.h>

//  headers are messed up
//  neither ntdef.h nor winnt.h brings in complete set, so depending
//  on whether you include nt.h or not you end up with different set

#define MINCHAR     0x80
#define MAXCHAR     0x7f
#define MINSHORT    0x8000
#define MAXSHORT    0x7fff
#define MINLONG     0x80000000
#define MAXLONG     0x7fffffff
#define MAXBYTE     0xff
#define MAXUCHAR    0xff
#define MAXWORD     0xffff
#define MAXUSHORT   0xffff
#define MAXDWORD    0xffffffff
#define MAXULONG    0xffffffff


#include <winsock2.h>
#include <ws2tcpip.h>
#include <iptypes.h>
#include <basetyps.h>
#include <stdio.h>
#include <stdlib.h>
#include <limits.h>
#include <align.h>          //  Alignment macros
#include <windns.h>         //  SDK DNS definitions

#define  DNS_INTERNAL
#define  DNSAPI_INTERNAL
#define  DNSAPI_NETDIAG
#include <dnsapi.h>
#include "dnsrslvr.h"       //  Resolver RPC definitions
#include <rpcasync.h>       //  Exception filter
#include "dnslibp.h"        //  DNS library

#include "registry.h"
#include "message.h"        //  dnslib message def

//#include "dnsrslvr.h"     //  Resolver RPC definitions
#include "dnsapip.h"        //  Private DNS definitions
#include "queue.h"
#include "rtlstuff.h"       //  Handy macros from NT RTL
#include "trace.h"
#include "heapdbg.h"        //  dnslib debug heap


//
//  Use winsock2
//

#define DNS_WINSOCK_VERSION    (0x0202)    //  Winsock 2.2


//
//  Dll instance handle
//

extern HINSTANCE    g_hInstanceDll;

//
//  General CS
//  protects initialization and available for other random needs
//

CRITICAL_SECTION    g_GeneralCS;

#define LOCK_GENERAL()      EnterCriticalSection( &g_GeneralCS )
#define UNLOCK_GENERAL()    LeaveCriticalSection( &g_GeneralCS )


//
//  Init Levels
//

#define INITLEVEL_ZERO              (0)
#define INITLEVEL_BASE              (0x00000001)
#define INITLEVEL_DEBUG             (0x00000010)
#define INITLEVEL_QUERY             (0x00000100)
#define INITLEVEL_REGISTRATION      (0x00001000)
#define INITLEVEL_SECURE_UPDATE     (0x00010000)

//  Combined

#define INITLEVEL_ALL               (0xffffffff)


//
//  Limit on update adapters
//

#define UPDATE_ADAPTER_LIMIT        (100)

//
//  Limit on search list entries
//

#define MAX_SEARCH_LIST_ENTRIES     (50)


//
//  Event logging
//      - currently set to disable in any code we pick up from server
//

VOID
DnsLogEvent(
    IN      DWORD           MessageId,
    IN      WORD            EventType,
    IN      DWORD           NumberOfSubStrings,
    IN      PWSTR *         SubStrings,
    IN      DWORD           ErrorCode
    );

#define DNS_LOG_EVENT(a,b,c,d)

//
//  Debug
//

#ifdef ASSERT
#undef ASSERT
#endif
#define ASSERT(a)  DNS_ASSERT(a)

//  standard -- unflagged ASSERT()
//      - defintion directly from ntrtl.h
//      this should have been plain vanilla ASSERT(), but
//      it is used too often

#if DBG
#define RTL_ASSERT(exp)  \
        ((!(exp)) ? \
            (RtlAssert( #exp, __FILE__, __LINE__, NULL ),FALSE) : \
            TRUE)
#else
#define RTL_ASSERT(exp)
#endif

//
//  IP6 support
//

#define RUNNING_IP6()  (TRUE)

//
//  Handy hack
//

#define SOCKADDR_IS_LOOPBACK(psa)   DnsAddr_IsLoopback( (PDNS_ADDR)(psa), 0 )


//
//  Single async socket for internal use
//
//  If want async socket i/o then can create single async socket, with
//  corresponding event and always use it.  Requires winsock 2.2
//

extern  SOCKET      DnsSocket;
extern  OVERLAPPED  DnsSocketOverlapped;
extern  HANDLE      hDnsSocketEvent;


//
//  App shutdown flag
//

extern  BOOLEAN     fApplicationShutdown;


//
//  Global config -- From DnsLib
//      -- set in DnsRegInit()
//          OR in DnsReadRegistryGlobals()
//      -- declaration in registry.h
//


//
//  Runtime globals (dnsapi.c)
//

extern  DWORD           g_NetFailureTime;
extern  DNS_STATUS      g_NetFailureStatus;

//extern  IP4_ADDRESS     g_LastDNSServerUpdated;


//
//  Heap operations
//

#define ALLOCATE_HEAP(size)         Dns_AllocZero( size )
#define ALLOCATE_HEAP_ZERO(size)    Dns_AllocZero( size )
#define REALLOCATE_HEAP(p,size)     Dns_Realloc( (p), (size) )
#define FREE_HEAP(p)                Dns_Free( p )


//
//  RPC Exception filters
//

#define DNS_RPC_EXCEPTION_FILTER    I_RpcExceptionFilter( RpcExceptionCode() )


//
//  During setup need to cleanup after winsock
//

#define GUI_MODE_SETUP_WS_CLEANUP( _mode )  \
        {                                   \
            if ( _mode )                    \
            {                               \
                Socket_CleanupWinsock();    \
            }                               \
        }

//
//  Server status
//

#define SRVSTATUS_NEW       ((DNS_STATUS)(-1))

#define TEST_SERVER_VALID_RECV(pserver)     ((LONG)(pserver)->Status >= 0 )


//
//  Server state
//
//  Note, server state is currently completely "per query", meaning
//  only pertaining to a particular name query.
//
//  As such it has two components:
//      1)  query -- state for entire query
//      2)  retry -- state only valid for given retry
//


#define SRVFLAG_NEW                 (0x00000000)
#define SRVFLAG_SENT                (0x00000001)
#define SRVFLAG_RECV                (0x00000002)

#define SRVFLAG_SENT_OPT            (0x00000011)
#define SRVFLAG_RECV_OPT            (0x00000020)
#define SRVFLAG_TIMEOUT_OPT         (0x00000040)
#define SRVFLAG_SENT_NON_OPT        (0x00000101)
#define SRVFLAG_RECV_NON_OPT        (0x00000200)
#define SRVFLAG_TIMEOUT_NON_OPT     (0x00000400)

#define SRVFLAG_QUERY_MASK          (0x0000ffff)

#define SRVFLAG_SENT_THIS_RETRY     (0x00010000)
#define SRVFLAG_RETRY_MASK          (0x00010000)

#define SRVFLAG_RUNTIME_MASK        (0x000fffff)

#define TEST_SERVER_STATE(pserver, state)   (((pserver)->Flags & (state)) == (state))
#define SET_SERVER_STATE(pserver, state)    ((pserver)->Flags |= state)
#define CLEAR_SERVER_STATE(pserver, state)  ((pserver)->Flags &= ~(state))

#define TEST_SERVER_NEW(pserver)            ((pserver)->Flags == SRVFLAG_NEW)
#define CLEAR_SERVER_RETRY_STATE( pserver ) CLEAR_SERVER_STATE( pserver, SRVFLAG_RETRY_MASK )


//
//  Server priority
//
//  Note, these values are tuned to do the following
//      => loopback DNS keeps getting action through a fair amount of
//      timeouts, but is pushed aside if no DNS
//      => otherwise response priority beats default setup
//      => IP6 default DNS are assumed to be non-functional relative to
//      other DNS servers, several timeouts on other servers before they
//      go first
//      

#define SRVPRI_LOOPBACK                 (200)
#define SRVPRI_RESPONSE                 (10)
#define SRVPRI_DEFAULT                  (0)
#define SRVPRI_IP6_DEFAULT              (-30)
#define SRVPRI_NO_DNS                   (-200)

#define SRVPRI_SERVFAIL_DROP            (1)
#define SRVPRI_TIMEOUT_DROP             (10)
#define SRVPRI_NO_DNS_DROP              (200)


//
//  Local Prototypes
//
//  Routines shared between dnsapi.dll modules, but not exported
//
//  Note, i've included some other functions in here because the external
//  definition seems help "encourage" the creation of symbols in retail
//  builds
//


//
//  Config stuff
//

BOOL
DnsApiInit(
    IN      DWORD           InitLevel
    );

DWORD
Reg_ReadRegistryGlobal(
    IN      DNS_REGID       GlobalId
    );

//
//  DHCP server (dynreg.c)
//

VOID
DhcpSrv_Cleanup(
    VOID
    );

//
//  DHCP client (asyncreg.c)
//

VOID
Dhcp_RegCleanupForUnload(
    VOID
    );

//
//  Query (query.c)
//

DNS_STATUS
WINAPI
Query_PrivateExW(
    IN      PCWSTR          pwsName,
    IN      WORD            wType,
    IN      DWORD           Options,
    IN      PADDR_ARRAY     pServerList         OPTIONAL,
    IN      PIP4_ARRAY      pServerList4        OPTIONAL,
    OUT     PDNS_RECORD *   ppResultSet         OPTIONAL,
    IN OUT  PDNS_MSG_BUF *  ppMessageResponse   OPTIONAL
    );

DNS_STATUS
WINAPI
Query_Private(
    IN      PCWSTR          pszName,
    IN      WORD            wType,
    IN      DWORD           Options,
    IN      PADDR_ARRAY     pServerList         OPTIONAL,
    OUT     PDNS_RECORD *   ppResultSet         OPTIONAL
    );

BOOL
IsEmptyDnsResponse(
    IN      PDNS_RECORD     pRecordList
    );

BOOL
ValidateQueryTld(
    IN      PWSTR           pTld
    );

BOOL
ValidateQueryName(
    IN      PQUERY_BLOB     pBlob,
    IN      PWSTR           pName,
    IN      PWSTR           pDomain
    );

PWSTR
getNextQueryName(
    OUT     PWSTR           pNameBuffer,
    IN      DWORD           QueryCount,
    IN      PWSTR           pszName,
    IN      DWORD           NameLength,
    IN      DWORD           NameAttributes,
    IN      PDNS_NETINFO    pNetInfo,
    OUT     PDWORD          pSuffixFlags
    );

PWSTR
Query_GetNextName(
    IN OUT  PQUERY_BLOB     pBlob
    );



//
//  FAZ (faz.c)
//

DNS_STATUS
Faz_Private(
    IN      PWSTR           pszName,
    IN      DWORD           dwFlags,
    IN      PADDR_ARRAY     pServers,           OPTIONAL
    OUT     PDNS_NETINFO *  ppNetworkInfo
    );

DNS_STATUS
DoQuickFAZ(
    OUT     PDNS_NETINFO *  ppNetworkInfo,
    IN      PWSTR           pszName,
    IN      PADDR_ARRAY     pServers
    );

DWORD
GetDnsServerListsForUpdate(
    IN OUT  PADDR_ARRAY*    DnsServerListArray,
    IN      DWORD           ArrayLength,
    IN      DWORD           Flags
    );

DNS_STATUS
CollapseDnsServerListsForUpdate(
    IN OUT  PADDR_ARRAY*    DnsServerListArray,
    OUT     PDNS_NETINFO *  NetworkInfoArray,
    IN OUT  PDWORD          pNetCount,
    IN      PWSTR           pszUpdateName
    );

PADDR_ARRAY
GetNameServersListForDomain(
    IN      PWSTR           pDomainName,
    IN      PADDR_ARRAY     pServerList
    );

BOOL
ValidateZoneNameForUpdate(
    IN      PWSTR           pszZone
    );

BOOL
WINAPI
Faz_AreServerListsInSameNameSpace(
    IN      PWSTR               pszDomainName,
    IN      PADDR_ARRAY         pServerList1,
    IN      PADDR_ARRAY         pServerList2
    );

BOOL
WINAPI
CompareMultiAdapterSOAQueries(
    IN      PWSTR           pszDomainName,
    IN      PIP4_ARRAY      pDnsServerList1,
    IN      PIP4_ARRAY      pDnsServerList2
    );

BOOL
WINAPI
Faz_CompareTwoAdaptersForSameNameSpace(
    IN      PADDR_ARRAY     pDnsServerList1,
    IN      PDNS_NETINFO    pNetworkInfo1,
    IN OUT  PDNS_RECORD *   ppNsRecord1,
    IN      PADDR_ARRAY     pDnsServerList2,
    IN      PDNS_NETINFO    pNetworkInfo2,
    IN OUT  PDNS_RECORD *   ppNsRecord2,
    IN      BOOL            bDoNsCheck
    );


//
//  Status (dnsapi.c)
//

BOOL
IsKnownNetFailure(
    VOID
    );

VOID
SetKnownNetFailure(
    IN      DNS_STATUS      Status
    );

BOOL
IsLocalIpAddress(
    IN      IP4_ADDRESS     IpAddress
    );

PDNS_NETINFO     
GetAdapterListFromCache(
    VOID
    );


//
//  IP Help API (iphelp.c)
//

VOID
IpHelp_Cleanup(
    VOID
    );

PIP_ADAPTER_ADDRESSES
IpHelp_GetAdaptersAddresses(
    IN      ULONG           Family,
    IN      DWORD           Flags
    );

DNS_STATUS
IpHelp_ReadAddrsFromList(
    IN      PVOID               pAddrList,
    IN      BOOL                fUnicast,
    IN      DWORD               ScreenMask,         OPTIONAL
    IN      DWORD               ScreenFlags,        OPTIONAL
    OUT     PDNS_ADDR_ARRAY *   ppComboArray,       OPTIONAL
    OUT     PDNS_ADDR_ARRAY *   pp6OnlyArray,       OPTIONAL
    OUT     PDNS_ADDR_ARRAY *   pp4OnlyArray,       OPTIONAL
    OUT     PDWORD              pCount6,            OPTIONAL
    OUT     PDWORD              pCount4             OPTIONAL
    );

DNS_STATUS
IpHelp_GetAdaptersInfo(
    OUT     PIP_ADAPTER_INFO *  ppAdapterInfo
    );

DNS_STATUS
IpHelp_GetPerAdapterInfo(
    IN      DWORD                   AdapterIndex,
    OUT     PIP_PER_ADAPTER_INFO  * ppPerAdapterInfo
    );

DNS_STATUS
IpHelp_GetBestInterface(
    IN      IP4_ADDRESS     Ip4Addr,
    OUT     PDWORD          pdwInterfaceIndex
    );

DNS_STATUS
IpHelp_ParseIpAddressString(
    IN OUT  PIP4_ARRAY      pIpArray,
    IN      PIP_ADDR_STRING pIpAddrString,
    IN      BOOL            fGetSubnetMask,
    IN      BOOL            fReverse
    );


//
//  Private registry\config (regfig.c)
//

BOOL
Reg_ReadDwordEnvar(
    IN      DWORD               dwFlag,
    OUT     PENVAR_DWORD_INFO   pEnvar
    );

DNS_STATUS
Reg_DefaultAdapterInfo(
    OUT     PREG_ADAPTER_INFO       pBlob,
    IN      PREG_GLOBAL_INFO        pRegInfo,
    IN      PIP_ADAPTER_ADDRESSES   pIpAdapter
    );


//
//  Hosts file reading (hostfile.c)
//

BOOL
HostsFile_Query(
    IN OUT  PQUERY_BLOB     pBlob
    );

//
//  Heap (memory.c)
//

DNS_STATUS
Heap_Initialize(
    VOID
    );

VOID
Heap_Cleanup(
    VOID
    );


//
//  Type specific config routines (config.c)
//

PADDR_ARRAY
Config_GetDnsServerList(
    IN      PWSTR           pwsAdapterName,
    IN      DWORD           AddrFamily,
    IN      BOOL            fForce
    );

PIP4_ARRAY
Config_GetDnsServerListIp4(
    IN      PWSTR           pwsAdapterName,
    IN      BOOL            fForce
    );

PDNS_GLOBALS_BLOB
Config_GetDwordGlobals(
    IN      DWORD           Flag,
    IN      DWORD           AcceptLocalCacheTime   OPTIONAL
    );

//
//  Network info (netinfo.c)
//

BOOL
InitNetworkInfo(
    VOID
    );

VOID
CleanupNetworkInfo(
    VOID
    );

PWSTR
SearchList_GetNextName(
    IN OUT  PSEARCH_LIST    pSearchList,
    IN      BOOL            fReset,
    OUT     PDWORD          pdwSuffixFlags  OPTIONAL
    );

PADDR_ARRAY
NetInfo_ConvertToAddrArray(
    IN      PDNS_NETINFO    pNetInfo,
    IN      PWSTR           pwsAdapterName,
    IN      DWORD           Family      OPTIONAL
    );

PDNS_NETINFO     
NetInfo_CreateForUpdate(
    IN      PWSTR           pszZone,
    IN      PWSTR           pszServerName,
    IN      PDNS_ADDR_ARRAY pServerArray,
    IN      DWORD           dwFlags
    );

PDNS_NETINFO     
NetInfo_CreateFromAddrArray(
    IN      PADDR_ARRAY     pDnsServers,
    IN      PDNS_ADDR       pServerIp,
    IN      BOOL            fSearchInfo,
    IN      PDNS_NETINFO    pNetInfo        OPTIONAL
    );

PWSTR
NetInfo_UpdateZoneName(
    IN      PDNS_NETINFO    pNetInfo
    );

PWSTR
NetInfo_UpdateServerName(
    IN      PDNS_NETINFO    pNetInfo
    );

BOOL
NetInfo_IsForUpdate(
    IN      PDNS_NETINFO    pNetInfo
    );

VOID
NetInfo_MarkDirty(
    VOID
    );


//
//  Adapter access
//

PDNS_ADAPTER
NetInfo_GetNextAdapter(
    IN OUT  PDNS_NETINFO    pNetInfo 
    );

#define NetInfo_AdapterLoopStart( pni )     ((pni)->AdapterIndex = 0)


//
//  Netinfo_Get flags
//

#define NIFLAG_GET_LOCAL_ADDRS      (0x10000000) 
#define NIFLAG_FORCE_REGISTRY_READ  (0x00000001)
#define NIFLAG_READ_RESOLVER_FIRST  (0x00000010)
#define NIFLAG_READ_RESOLVER        (0x00000020)
#define NIFLAG_READ_PROCESS_CACHE   (0x00000100)

PDNS_NETINFO     
NetInfo_Get(
    IN      DWORD           Flags,
    IN      DWORD           AcceptLocalCacheTime   OPTIONAL
    );

//  Default Use
//      - need local addrs
//      - accept from cache
//      - try resolver

#define GetNetworkInfo()    \
        NetInfo_Get(        \
            NIFLAG_GET_LOCAL_ADDRS |        \
                NIFLAG_READ_RESOLVER |      \
                NIFLAG_READ_PROCESS_CACHE,  \
            0 )



//  Delete
PIP4_ARRAY
NetInfo_ConvertToIp4Array(
    IN      PDNS_NETINFO    pNetInfo
    );

//  Delete
PDNS_NETINFO     
NetInfo_CreateFromIp4Array(
    IN      PIP4_ARRAY      pDnsServers,
    IN      IP4_ADDRESS     ServerIp,
    IN      BOOL            fSearchInfo,
    IN      PDNS_NETINFO    pNetInfo        OPTIONAL
    );

//  Delete
PDNS_NETINFO     
NetInfo_CreateForUpdateIp4(
    IN      PWSTR           pszZone,
    IN      PWSTR           pszServerName,
    IN      PIP4_ARRAY      pServ4Array,
    IN      DWORD           dwFlags
    );


//
//  Local address config from netinfo
//

#define DNS_CONFIG_FLAG_ADDR_PUBLIC         (0x00000001)
#define DNS_CONFIG_FLAG_ADDR_PRIVATE        (0x00000002)
#define DNS_CONFIG_FLAG_ADDR_CLUSTER        (0x00000004)

#define DNS_CONFIG_FLAG_ADDR_NON_CLUSTER    (0x00000003)
#define DNS_CONFIG_FLAG_ADDR_ALL            (0x00000007)

#define DNS_CONFIG_FLAG_READ_CLUSTER_ENVAR  (0x00100000)


PADDR_ARRAY
NetInfo_CreateLocalAddrArray(
    IN      PDNS_NETINFO    pNetInfo,
    IN      PWSTR           pwsAdapterName, OPTIONAL
    IN      PDNS_ADAPTER    pAdapter,       OPTIONAL
    IN      DWORD           Family,         OPTIONAL
    IN      DWORD           AddrFlags       OPTIONAL
    );

PDNS_ADDR_ARRAY
NetInfo_GetLocalAddrArray(
    IN      PDNS_NETINFO    pNetInfo,
    IN      PWSTR           pwsAdapterName, OPTIONAL
    IN      DWORD           Family,         OPTIONAL
    IN      DWORD           AddrFlags,      OPTIONAL
    IN      BOOL            fForce
    );

PIP4_ARRAY
NetInfo_GetLocalAddrArrayIp4(
    IN      PWSTR           pwsAdapterName, OPTIONAL
    IN      DWORD           AddrFlags,
    IN      BOOL            fForce
    );


//  Private but used in servlist.c

DNS_STATUS
AdapterInfo_Copy(
    OUT     PDNS_ADAPTER    pCopy,
    IN      PDNS_ADAPTER    pAdapter
    );

PDNS_NETINFO
NetInfo_Alloc(
    IN      DWORD           AdapterCount
    );

BOOL
NetInfo_AddAdapter(
    IN OUT  PDNS_NETINFO    pNetInfo,
    IN      PDNS_ADAPTER    pAdapter
    );


//
//  Public config blob routines
//

VOID
DnsSearchList_Free(
    IN      PDNS_SEARCH_LIST    pSearchList
    );

PDNS_SEARCH_LIST
DnsSearchList_Get(
    IN      DNS_CHARSET         CharSet
    );

VOID
DnsAdapterInfo_Free(
    IN OUT  PDNS_ADAPTER_INFO   pAdapter,
    IN      BOOL                fFreeAdapter
    );

VOID
DnsNetworkInfo_Free(
    IN OUT  PDNS_NETWORK_INFO   pNetInfo
    );

PDNS_NETWORK_INFO
DnsNetworkInfo_Get(
    IN      DNS_CHARSET         CharSet
    );

//
//  Routine for the old public structures:
//      DNS_NETWORK_INFORMATION
//      DNS_SEARCH_INFORMATION
//      DNS_ADAPTER_INFORMATION 
//

VOID
DnsSearchInformation_Free(
    IN      PDNS_SEARCH_INFORMATION     pSearchList
    );

PDNS_SEARCH_INFORMATION
DnsSearchInformation_Get(
    VOID
    );

VOID
DnsAdapterInformation_Free(
    IN OUT  PDNS_ADAPTER_INFORMATION    pAdapter
    );

VOID
DnsNetworkInformation_Free(
    IN OUT  PDNS_NETWORK_INFORMATION    pNetInfo
    );

PDNS_NETWORK_INFORMATION
DnsNetworkInformation_Get(
    VOID
    );


//
//  local IP info (localip.c)
//

PIP4_ARRAY
LocalIp_GetIp4Array(
    VOID
    );

PADDR_ARRAY
LocalIp_GetArray(
    VOID
    );

BOOL
LocalIp_IsAddrLocal(
    IN      PDNS_ADDR           pAddr,
    IN      PDNS_ADDR_ARRAY     pLocalArray,    OPTIONAL
    IN      PDNS_NETINFO        pNetInfo        OPTIONAL
    );


//
//  send utils (send.c)
//

VOID
Send_CleanupOptList(
    VOID
    );

//
//  socket utils (socket.c)
//

SOCKET
Socket_CreateMessageSocket(
    IN OUT  PDNS_MSG_BUF    pMsg
    );

SOCKET
Socket_GetUdp(
    IN      INT             Family
    );

VOID
Socket_ReturnUdp(
    IN      SOCKET          Socket,
    IN      INT             Family
    );

//
//  Message parsing (packet.c)
//

VOID
Dns_FreeParsedMessageFields(
    IN OUT  PDNS_PARSED_MESSAGE pParse
    );


//
//  Extra info (util.c)
//

PDNS_EXTRA_INFO
ExtraInfo_FindInList(
    IN OUT  PDNS_EXTRA_INFO     pExtraList,
    IN      DWORD               Id
    );

BOOL
ExtraInfo_SetBasicResults(
    IN OUT  PDNS_EXTRA_INFO     pExtraList,
    IN      PBASIC_RESULTS      pResults
    );

PDNS_ADDR_ARRAY
ExtraInfo_GetServerList(
    IN      PDNS_EXTRA_INFO     pExtraList
    );

PDNS_ADDR_ARRAY
ExtraInfo_GetServerListPossiblyImbedded(
    IN      PIP4_ARRAY          pList
    );

VOID
Util_SetBasicResults(
    OUT     PBASIC_RESULTS      pResults,
    IN      DWORD               Status,
    IN      DWORD               Rcode,
    IN      PDNS_ADDR           pServerAddr
    );

PDNS_ADDR_ARRAY
Util_GetAddrArray(
    OUT     PDWORD              fCopy,
    IN      PDNS_ADDR_ARRAY     pServList,
    IN      PIP4_ARRAY          pServList4,
    IN      PDNS_EXTRA_INFO     pExtra
    );

VOID
Util_GetActiveProtocols(
    OUT     PBOOL           pfRunning6,
    OUT     PBOOL           pfRunning4
    );

#endif //   _DNSAPILOCAL_INCLUDED_
=== C:/Users/treeman/Desktop/windows nt source code\Source\Win2K3\NT\ds\dns\dnsapi\logit.h ===
/*
 -  L O G I T . H
 -
 *  Purpose:
 *      Function and Macro definitions for logging module activity.
 *
 *  Author: Glenn A. Curtis
 *
 *  Comments:
 *      10/28/93    glennc     original file.
 *
 */

#ifndef LOGIT_H
#define LOGIT_H

#include <stdio.h>
#include <string.h>
#include <stdarg.h>
#include <time.h>

// #if DBG
   void  LogInit(LPSTR Filename);
   void  CDECL LogIt( LPSTR Filename, char *, ... );
   void  LogTime(LPSTR Filename);
   DWORD LogIn( LPSTR Filename, char * );
   void  LogOut( LPSTR Filename, char *, DWORD );
// #else
// #undef ENABLE_DEBUG_LOGGING
// #endif // DBG


/***********************************************************************
 *              Logging macros for source file dnsapi.c                *
 ***********************************************************************/

#ifdef ENABLE_DEBUG_LOGGING
#define DNSAPI_INIT() LogInit( "dnsapi.log" )
#else
#define DNSAPI_INIT() 
#endif                 

#ifdef ENABLE_DEBUG_LOGGING
#define DNSAPI_TIME() LogTime( "dnsapi.log" )
#else
#define DNSAPI_TIME() 
#endif                 

#ifdef ENABLE_DEBUG_LOGGING
#define DNSAPI_F1( a ) LogIt( "dnsapi.log", a )
#else
#define DNSAPI_F1( a )
#endif                 

#ifdef ENABLE_DEBUG_LOGGING
#define DNSAPI_F2( a, b ) LogIt( "dnsapi.log", a, b )
#else
#define DNSAPI_F2( a, b )
#endif                 

#ifdef ENABLE_DEBUG_LOGGING
#define DNSAPI_F3( a, b, c ) LogIt( "dnsapi.log", a, b, c )
#else
#define DNSAPI_F3( a, b, c )
#endif                 

#ifdef ENABLE_DEBUG_LOGGING
#define DNSAPI_F4( a, b, c, d ) LogIt( "dnsapi.log", a, b, c, d )
#else
#define DNSAPI_F4( a, b, c, d ) 
#endif                 

#ifdef ENABLE_DEBUG_LOGGING
#define DNSAPI_F5( a, b, c, d, e ) LogIt( "dnsapi.log", a, b, c, d, e )
#else
#define DNSAPI_F5( a, b, c, d, e ) 
#endif                 

#ifdef ENABLE_DEBUG_LOGGING
#define DNSAPI_F6( a, b, c, d, e, f ) LogIt( "dnsapi.log", a, b, c, d, e, f )
#else
#define DNSAPI_F6( a, b, c, d, e, f )
#endif                 

#ifdef ENABLE_DEBUG_LOGGING
#define DNSAPI_IN( a ) LogIn( "dnsapi.log", a )
#else
#define DNSAPI_IN( a )
#endif                 

#ifdef ENABLE_DEBUG_LOGGING
#define DNSAPI_OUT( a, b ) LogOut( "dnsapi.log", a, b )
#else
#define DNSAPI_OUT( a, b )
#endif                 


/***********************************************************************
 *             Logging macros for source file asyncreg.c               *
 ***********************************************************************/

#ifdef ENABLE_DEBUG_LOGGING
#define ASYNCREG_INIT() LogInit( "asyncreg.log" )
#else
#define ASYNCREG_INIT()
#endif

#ifdef ENABLE_DEBUG_LOGGING
#define ASYNCREG_TIME() LogTime( "asyncreg.log" )
#else
#define ASYNCREG_TIME()
#endif

#ifdef ENABLE_DEBUG_LOGGING
#define ASYNCREG_F1( a ) LogIt( "asyncreg.log", a )
#else
#define ASYNCREG_F1( a )
#endif

#ifdef ENABLE_DEBUG_LOGGING
#define ASYNCREG_F2( a, b ) LogIt( "asyncreg.log", a, b )
#else
#define ASYNCREG_F2( a, b )
#endif

#ifdef ENABLE_DEBUG_LOGGING
#define ASYNCREG_F3( a, b, c ) LogIt( "asyncreg.log", a, b, c )
#else
#define ASYNCREG_F3( a, b, c )
#endif

#ifdef ENABLE_DEBUG_LOGGING
#define ASYNCREG_F4( a, b, c, d ) LogIt( "asyncreg.log", a, b, c, d )
#else
#define ASYNCREG_F4( a, b, c, d )
#endif

#ifdef ENABLE_DEBUG_LOGGING
#define ASYNCREG_F5( a, b, c, d, e ) LogIt( "asyncreg.log", a, b, c, d, e )
#else
#define ASYNCREG_F5( a, b, c, d, e )
#endif

#ifdef ENABLE_DEBUG_LOGGING
#define ASYNCREG_F6( a, b, c, d, e, f ) LogIt( "asyncreg.log", a, b, c, d, e, f )
#else
#define ASYNCREG_F6( a, b, c, d, e, f )
#endif

#ifdef ENABLE_DEBUG_LOGGING
#define ASYNCREG_IN( a ) LogIn( "asyncreg.log", a )
#else
#define ASYNCREG_IN( a )
#endif

#ifdef ENABLE_DEBUG_LOGGING
#define ASYNCREG_OUT( a, b ) LogOut( "asyncreg.log", a, b )
#else
#define ASYNCREG_OUT( a, b )
#endif


/***********************************************************************
 *              Logging macros for source file dynreg.c                *
 ***********************************************************************/

#ifdef ENABLE_DEBUG_LOGGING
#define DYNREG_INIT() LogInit( "dynreg.log" )
#else
#define DYNREG_INIT()
#endif

#ifdef ENABLE_DEBUG_LOGGING
#define DYNREG_TIME() LogTime( "dynreg.log" )
#else
#define DYNREG_TIME()
#endif

#ifdef ENABLE_DEBUG_LOGGING
#define DYNREG_F1( a ) LogIt( "dynreg.log", a )
#else
#define DYNREG_F1( a )
#endif

#ifdef ENABLE_DEBUG_LOGGING
#define DYNREG_F2( a, b ) LogIt( "dynreg.log", a, b )
#else
#define DYNREG_F2( a, b )
#endif

#ifdef ENABLE_DEBUG_LOGGING
#define DYNREG_F3( a, b, c ) LogIt( "dynreg.log", a, b, c )
#else
#define DYNREG_F3( a, b, c )
#endif

#ifdef ENABLE_DEBUG_LOGGING
#define DYNREG_F4( a, b, c, d ) LogIt( "dynreg.log", a, b, c, d )
#else
#define DYNREG_F4( a, b, c, d )
#endif

#ifdef ENABLE_DEBUG_LOGGING
#define DYNREG_F5( a, b, c, d, e ) LogIt( "dynreg.log", a, b, c, d, e )
#else
#define DYNREG_F5( a, b, c, d, e )
#endif

#ifdef ENABLE_DEBUG_LOGGING
#define DYNREG_F6( a, b, c, d, e, f ) LogIt( "dynreg.log", a, b, c, d, e, f )
#else
#define DYNREG_F6( a, b, c, d, e, f )
#endif

#ifdef ENABLE_DEBUG_LOGGING
#define DYNREG_IN( a ) LogIn( "dynreg.log", a )
#else
#define DYNREG_IN( a )
#endif

#ifdef ENABLE_DEBUG_LOGGING
#define DYNREG_OUT( a, b ) LogOut( "dynreg.log", a, b )
#else
#define DYNREG_OUT( a, b )
#endif


#endif
=== C:/Users/treeman/Desktop/windows nt source code\Source\Win2K3\NT\ds\dns\dnsapi\logit.c ===
/*****************************************\
 *        Data Logging -- Debug only      *
\*****************************************/

//
//  Precompiled header
//  Note -- this is not required for this modules.
//  It is included only to allow use of precompiled header.
//

#include "local.h"

#if 0
#include <nt.h>
#include <ntrtl.h>
#include <nturtl.h>
#include <windows.h>
#endif


#pragma  hdrstop

#include "logit.h"

// #if DBG

int LoggingMode;
time_t  long_time;      // has to be in DS, assumed by time() funcs
int LineCount;

char    *month[] =
{
    "January",
    "February",
    "March",
    "April",
    "May",
    "June",
    "July",
    "August",
    "September",
    "October",
    "November",
    "December"
} ;


/*
 -  LogInit
 -
 *  Purpose:
 *  Determines if logging is desired and if so, adds a header to log file.
 *
 *  Parameters:
 *
 */
void LogInit( LPSTR Filename )
{
    FILE    *fp;
    struct  tm  *newtime;
    char    am_pm[] = "a.m.";

    LoggingMode = 0;
    LineCount = 0;

    if ( fp = fopen( Filename, "r+" ) )
    {
        LoggingMode = 1;
        fclose( fp );

        // Get time and date information

        long_time = time( NULL);        /* Get time as long integer. */
        newtime = localtime( &long_time ); /* Convert to local time. */

        if( newtime->tm_hour > 12 )    /* Set up extension. */
            am_pm[0] = 'p';
        if( newtime->tm_hour > 12 )    /* Convert from 24-hour */
            newtime->tm_hour -= 12;    /*   to 12-hour clock.  */
        if( newtime->tm_hour == 0 )    /*Set hour to 12 if midnight. */
            newtime->tm_hour = 12;

        // Write out a header to file

        fp = fopen(Filename, "a" );

        fprintf( fp, "Logging information for DNS API source file\n" );
        fprintf( fp, "****************************************************\n" );
        fprintf( fp, "\tTime: %d:%02d %s\n\tDate: %s %d, 19%d\n", 
                 newtime->tm_hour, newtime->tm_min, am_pm,
                 month[newtime->tm_mon], newtime->tm_mday,
                 newtime->tm_year );
        fprintf( fp, "****************************************************\n\n" );
        fclose( fp );
    }
}


/*
 -  LogIt
 -
 *  Purpose:
 *  Formats a string and prints it to a log file with handle hLog.
 *
 *  Parameters:
 *  LPSTR - Pointer to string to format
 *  ...   - variable argument list
 */

void CDECL LogIt( LPSTR Filename, char * lpszFormat, ... )
{
    FILE *  fp;
    va_list pArgs;
    char    szLogStr[1024];    
    int     i;

    if ( !LoggingMode )
        return;
    
    va_start( pArgs, lpszFormat);
    vsprintf(szLogStr, lpszFormat, pArgs);
    va_end(pArgs);

    i = strlen( szLogStr);
    szLogStr[i] = '\n';
    szLogStr[i+1] = '\0';


    if ( LineCount > 50000 )
    {
        fp = fopen( Filename, "w" );
        LineCount = 0;
    }
    else
    {
        fp = fopen( Filename, "a" );
    }
    if ( fp )
    {
        fputs( szLogStr, fp );
        LineCount++;
        fclose( fp );
    }
}


void LogTime( LPSTR Filename )
{
    struct  tm  *newtime;
    char    am_pm[] = "a.m.";

    if ( !LoggingMode )
        return;

    // Get time and date information

    long_time = time( NULL);        /* Get time as long integer. */
    newtime = localtime( &long_time ); /* Convert to local time. */

    if ( !newtime )
        return;

    if( newtime->tm_hour > 12 )    /* Set up extension. */
        am_pm[0] = 'p';
    if( newtime->tm_hour > 12 )    /* Convert from 24-hour */
        newtime->tm_hour -= 12;    /*   to 12-hour clock.  */
    if( newtime->tm_hour == 0 )    /*Set hour to 12 if midnight. */
        newtime->tm_hour = 12;

    // Write out a header to file

    LogIt( Filename, "DNS CLIENT API" );
    LogIt( Filename, "System Time Information" );
    LogIt( Filename, "****************************************************" );
    LogIt( Filename, "\tTime: %d:%02d %s\n\tDate: %s %d, 19%d",
           newtime->tm_hour, newtime->tm_min, am_pm,
           month[newtime->tm_mon], newtime->tm_mday,
           newtime->tm_year );
    LogIt( Filename, "****************************************************" );
    LogIt( Filename, "" );
}


DWORD LogIn( LPSTR Filename, char * string )
{
    LogIt( Filename, "%s", string );
    return GetTickCount();
}


void LogOut( LPSTR Filename, char * string, DWORD InTime )
{
    LogIt( Filename, "%s  ---  Duration: %ld milliseconds",
           string, GetTickCount() - InTime );
}


// #endif
=== C:/Users/treeman/Desktop/windows nt source code\Source\Win2K3\NT\ds\dns\dnsapi\localip.c ===
/*++

Copyright (c) 2000-2002  Microsoft Corporation

Module Name:

    localip.c

Abstract:

    Local IP address routines.

Author:

    Jim Gilroy      October 2000

Revision History:

--*/


#include "local.h"

//
//  TTL on local records
//
//  Use registration TTL
//

#define LOCAL_IP_TTL    (g_RegistrationTtl)



//
//  Test locality.
//

BOOL
LocalIp_IsAddrLocal(
    IN      PDNS_ADDR           pAddr,
    IN      PDNS_ADDR_ARRAY     pLocalArray,    OPTIONAL
    IN      PDNS_NETINFO        pNetInfo        OPTIONAL
    )
/*++

Routine Description:

    Determine if IP is local.

Arguments:

    pAddr -- ptr to IP to test

    pLocalArray -- local addresses to check

    pNetInfo -- network info to check

Return Value:

    TRUE if local IP
    FALSE if remote

--*/
{
    BOOL        bresult = FALSE;
    PADDR_ARRAY parray;

    //
    //  test for loopback
    //

    if ( DnsAddr_IsLoopback(
            pAddr,
            0   // any family
            ) )
    {
        return  TRUE; 
    }

    //
    //  test against local addrs
    //      - use addr list if provided
    //      - use netinfo if provided
    //      - otherwise query to get it
    //

    parray = pLocalArray;
    if ( !parray )
    {
        parray = NetInfo_GetLocalAddrArray(
                        pNetInfo,
                        NULL,       // no specific adapter
                        0,          // no specific family
                        0,          // no flags
                        FALSE       // no force
                        );
    }

    bresult = DnsAddrArray_ContainsAddr(
                    parray,
                    pAddr,
                    DNSADDR_MATCH_IP );

    if ( parray != pLocalArray )
    {
        DnsAddrArray_Free( parray );
    }
    
    return  bresult;
}



//
//  Local address list
//

BOOL
local_ScreenLocalAddrNotCluster(
    IN      PDNS_ADDR       pAddr,
    IN      PDNS_ADDR       pScreenAddr     OPTIONAL
    )
/*++

Routine Description:

    Screen cluster out of local addrs.

    This is DnsAddrArray_ContainsAddrEx() screening function
    for use by GetLocalPtrRecord() to avoid matching cluster
    addresses.

Arguments:

    pAddr -- address to screen

    pScreenAddr -- screening info;  ignored for this function

Return Value:

    TRUE if local addr passes screen -- is not cluster IP.
    FALSE if cluster.

--*/
{
    //  screen flags
    //      - exact match on address type flag bits

    return  ( !(pAddr->Flags & DNSADDR_FLAG_TRANSIENT) );
}



PDNS_RECORD
local_GetLocalPtrRecord(
    IN OUT  PQUERY_BLOB     pBlob
    )
/*++

Routine Description:

    Get pointer record for local IP.

Arguments:

    pBlob -- query blob

    Uses:
        pNameOrig
        wType
        pNetInfo

    Sets:
        NameBufferWide -- used as local storage

Return Value:

    Ptr to record for query, if query name\type is IP.
    NULL if query not for IP.

--*/
{
    DNS_ADDR        addr;
    PDNS_ADDR       paddr = &addr;
    PDNS_RECORD     prr;
    PWSTR           pnameHost = NULL;
    PWSTR           pnameDomain;
    PDNS_ADAPTER    padapter = NULL;
    DWORD           iter;
    PWSTR           pnameQuery = pBlob->pNameOrig;
    PDNS_NETINFO    pnetInfo = pBlob->pNetInfo;


    DNSDBG( TRACE, (
        "\nlocal_GetLocalPtrRecord( %S )\n",
        pnameQuery ));

    if ( !pnameQuery )
    {
        return  NULL;
    }

    //
    //  convert reverse name to IP
    //

    if ( ! Dns_ReverseNameToDnsAddr_W(
                paddr,
                pnameQuery ) )
    {
        DNSDBG( ANY, (
            "WARNING:  Ptr lookup name %S is not reverse name!\n",
            pnameQuery ));
        return   NULL;
    }

    //
    //  check for generic IP match
    //      - skip for mcast response
    //      - accept loopback or any on normal query
    //

    if ( !(pBlob->Flags & DNSP_QUERY_NO_GENERIC_NAMES) )
    {
        if ( DnsAddr_IsLoopback( paddr, 0 ) )
        {
            DNSDBG( QUERY, (
                "Local PTR lookup matched loopback.\n" ));
            goto Matched;
        }
        else if ( DnsAddr_IsUnspec( paddr, 0 ) )
        {
            DNSDBG( QUERY, (
                "Local PTR lookup matched unspec.\n" ));
            goto Matched;
        }
    }

    //
    //  check for specific IP match
    //

    NetInfo_AdapterLoopStart( pnetInfo );

    while( padapter = NetInfo_GetNextAdapter( pnetInfo ) )
    {
        //
        //  have address match?
        //  if server must use screening function to skip cluster IPs
        //
        //  note:  cluster IPs will be mapped back to virtual cluster
        //      name by cache

        if ( DnsAddrArray_ContainsAddrEx(
                padapter->pLocalAddrs,
                paddr,
                DNSADDR_MATCH_IP,
                g_IsServer
                    ? local_ScreenLocalAddrNotCluster
                    : NULL,
                NULL            // no screen address required
                ) )
        {
            goto Matched;
        }
    }

    //  
    //  no IP match
    //

    DNSDBG( QUERY, (
        "Leave local PTR lookup.  No local IP match.\n"
        "\treverse name = %S\n",
        pnameQuery ));

    return  NULL;

Matched:

    //
    //  create hostname
    //  preference order:
    //      - full PDN
    //      - full adapter domain name from adapter with IP
    //      - hostname (single label)
    //      - "localhost"
    //

    {
        PWCHAR  pnameBuf = pBlob->NameBuffer;

        pnameHost = pnetInfo->pszHostName;
        if ( !pnameHost )
        {
            pnameHost = L"localhost";
            goto Build;
        }
        
        pnameDomain = pnetInfo->pszDomainName;
        if ( !pnameDomain )
        {
            //  use the adapter name even if NOT set for registration
            // if ( !padapter ||
            //     !(padapter->InfoFlags & AINFO_FLAG_REGISTER_DOMAIN_NAME) )
            if ( !padapter )
            {
                goto Build;
            }
            pnameDomain = padapter->pszAdapterDomain;
            if ( !pnameDomain )
            {
                goto Build;
            }
        }
        
        if ( ! Dns_NameAppend_W(
                    pnameBuf,
                    DNS_MAX_NAME_BUFFER_LENGTH,
                    pnameHost,
                    pnameDomain ) )
        {
            DNS_ASSERT( FALSE );
            goto Build;
        }
        pnameHost = pnameBuf;
        

Build:
        //
        //  create record
        //
        
        prr = Dns_CreatePtrRecordEx(
                    paddr,
                    (PDNS_NAME) pnameHost,
                    LOCAL_IP_TTL,
                    DnsCharSetUnicode,
                    DnsCharSetUnicode );
        if ( !prr )
        {
            DNSDBG( ANY, (
                "Local PTR record creation failed for name %S!\n",
                pnameHost ));
            return  NULL;
        }
    }

    DNSDBG( QUERY, (
        "Created local PTR record %p with hostname %S.\n"
        "\treverse name = %S\n",
        prr,
        pnameHost,
        pnameQuery ));

    return  prr;
}



VOID
localip_BuildRRListFromArray(
    IN OUT  PDNS_RRSET          pRRSet,
    IN      PWSTR               pNameRecord,
    IN      WORD                wType,
    IN      PDNS_ADDR_ARRAY     pAddrArray
    )
/*++

Routine Description:

    Build address record lists for local IP.

    Helper function as this same logic is in multiple places
    due to the tedious way we must put this together.

Arguments:

Return Value:

--*/
{
    DWORD           jter;
    PDNS_RECORD     prr;
    INT             fpass;


    DNSDBG( TRACE, (
        "localip_BuildRRListFromArray()\n"
        "\tpname    = %S\n"
        "\twtype    = %d\n"
        "\tparray   = %p\n",
        pNameRecord,
        wType,
        pAddrArray ));

    //
    //  validate array
    //

    if ( !pAddrArray )
    {
        DNSDBG( QUERY, (
            "No addrs for record build -- NULL array!!!\n" ));
        return;
    }

    //
    //  loop through adapter addresses
    //

    if ( pRRSet->pFirstRR != NULL )
    {
        pNameRecord = NULL;
    }

    for ( jter = 0;
          jter < pAddrArray->AddrCount;
          jter++ )
    {
        prr = Dns_CreateForwardRecord(
                    pNameRecord,
                    wType,
                    &pAddrArray->AddrArray[jter],
                    LOCAL_IP_TTL,
                    DnsCharSetUnicode,
                    DnsCharSetUnicode );
        if ( prr )
        {
            DNS_RRSET_ADD( *pRRSet, prr );
            pNameRecord = NULL;
        }
    }
}



PDNS_RECORD
local_GetLocalAddressRecord(
    IN OUT  PQUERY_BLOB     pBlob
    )
/*++

Routine Description:

    Get address record for local IP.

Arguments:

    pBlob -- query blob

    Uses:
        pNameOrig
        wType
        pNetInfo
        fNoGenericNames

    Sets:
        fNoIpLocal
            TRUE -- no IP of type found, defaulted record
            FALSE -- records valid

        NameBuffer -- used as local storage

    fGenericNames -- accept local generic names (NULL, loopback, localhost)
        TRUE for DnsQuery() path
        FALSE for mcast queries

Return Value:

    Ptr to record for query, if query name\type is IP.
    NULL if query not for IP.

--*/
{
    DNS_ADDR        addr;
    IP4_ADDRESS     ip4;
    IP6_ADDRESS     ip6;
    PDNS_ADDR_ARRAY parray = NULL;
    DWORD           addrFlag;
    DWORD           family;
    PDNS_RECORD     prr;
    BOOL            fmatchedName = FALSE;
    PWSTR           pnameRecord = NULL;
    DWORD           iter;
    DWORD           bufLength;
    PWSTR           pnameDomain;
    DNS_RRSET       rrset;
    WORD            wtype = pBlob->wType;
    PWSTR           pnameBuf = pBlob->NameBuffer;
    PWSTR           pnameQuery = pBlob->pNameOrig;
    PDNS_NETINFO    pnetInfo = pBlob->pNetInfo;
    PDNS_ADAPTER    padapter;


    DNSDBG( TRACE, (
        "local_GetLocalAddressRecord( %S, %d )\n",
        pnameQuery,
        wtype ));

    //  clear out param

    pBlob->fNoIpLocal = FALSE;

    //  address types to include

    addrFlag = DNS_CONFIG_FLAG_ADDR_NON_CLUSTER;

    family = Family_GetFromDnsType( wtype );
    if ( !family )
    {
        DNS_ASSERT( FALSE );
        return  NULL;
    }

    //  init record builder

    DNS_RRSET_INIT( rrset );

    //
    //  generic local names
    //      - skip for doing MCAST matching
    //      - NULL, empty, loopback, localhost accepted for regular query
    //

    if ( pBlob->Flags & DNSP_QUERY_NO_GENERIC_NAMES )
    {
        if ( !pnameQuery )
        {
            return  NULL;
        }
    }
    else
    {
        //
        //  NULL treated as local PDN
        //
    
        if ( !pnameQuery || !*pnameQuery )
        {
            DNSDBG( QUERY, ( "Local lookup -- no query name, treat as PDN.\n" ));
            goto MatchedPdn;
        }

        //
        //  "*" treated as all machine records
        //

        if ( Dns_NameCompare_W(
                pnameQuery,
                L"..localmachine" ) )
        {
            DNSDBG( QUERY, ( "Local lookup -- * query name.\n" ));
            addrFlag |= DNS_CONFIG_FLAG_ADDR_CLUSTER;
            goto MatchedPdn;
        }

        //
        //  loopback or localhost
        //
    
        if ( Dns_NameCompare_W(
                pnameQuery,
                L"loopback" )
                ||
             Dns_NameCompare_W(
                pnameQuery,
                L"localhost" ) )
        {
            pnameRecord = pnameQuery,
            IP6_SET_ADDR_LOOPBACK( &ip6 );
            ip4 = DNS_NET_ORDER_LOOPBACK;
            goto SingleIp;
        }
    }

    //
    //  if no hostname -- done
    //

    if ( !pnetInfo->pszHostName )
    {
        DNSDBG( QUERY, ( "No hostname configured!\n" ));
        return  NULL;
    }

    //
    //  copy name
    //

    if ( ! Dns_NameCopyStandard_W(
                pnameBuf,
                pBlob->pNameOrig ) )
    {
        DNSDBG( ANY, (
            "Invalid name %S to local address query.\n",
            pnameQuery ));
        return  NULL;
    }

    //  split query name into hostname and domain name

    pnameDomain = Dns_SplitHostFromDomainNameW( pnameBuf );

    //  must have hostname match

    if ( !Dns_NameCompare_W(
            pnameBuf,
            pnetInfo->pszHostName ) )
    {
        DNSDBG( ANY, (
            "Local lookup, failed hostname match!\n",
            pnameQuery ));
        return  NULL;
    }

    //
    //  hostname's match
    //      - no domain name => PDN equivalent
    //      - match PDN => all addresses
    //      - match adapter name => adapter addresses
    //      - no match
    //

    //  check PDN match

    if ( !pnameDomain )
    {
        DNSDBG( QUERY, ( "Local lookup -- no domain, treat as PDN!\n" ));
        goto MatchedPdn;
    }
    if ( Dns_NameCompare_W(
            pnameDomain,
            pnetInfo->pszDomainName ) )
    {
        DNSDBG( QUERY, ( "Local lookup -- matched PDN!\n" ));
        goto MatchedPdn;
    }

    //
    //  NO PDN match -- check adapter name match
    //

    for ( iter=0; iter<pnetInfo->AdapterCount; iter++ )
    {
        padapter = NetInfo_GetAdapterByIndex( pnetInfo, iter );

        if ( !(padapter->InfoFlags & AINFO_FLAG_REGISTER_DOMAIN_NAME) ||
             ! padapter->pLocalAddrs ||
             ! Dns_NameCompare_W(
                    pnameDomain,
                    padapter->pszAdapterDomain ) )
        {
            continue;
        }

        //  build name if we haven't built it before
        //  we stay in the loop in case more than one
        //  adapter has the same domain name

        if ( !fmatchedName )
        {
            DNSDBG( QUERY, (
                "Local lookup -- matched adapter name %S\n",
                padapter->pszAdapterDomain ));

            if ( ! Dns_NameAppend_W(
                        pnameBuf,
                        DNS_MAX_NAME_BUFFER_LENGTH,
                        pnetInfo->pszHostName,
                        padapter->pszAdapterDomain ) )
            {
                DNS_ASSERT( FALSE );
                return  NULL;
            }
            pnameRecord = pnameBuf;
            fmatchedName = TRUE;
        }

        //
        //  build forward records for all IPs in adapter
        //
        //  note:  we do NOT include cluster addrs for adapter name match
        //      as we only must be able to provide in the
        //      gethostbyname(NULL) type cases, which use PDN
        //
        //  DCR:  mem alloc failures building local records
        //      getting no records built mapped properly to NO_MEMORY error
        //

        parray = NetInfo_CreateLocalAddrArray(
                    pnetInfo,
                    NULL,       // no adapter name
                    padapter,   // just this adapter
                    family,
                    addrFlag );
        if ( !parray )
        {
            continue;
        }

        localip_BuildRRListFromArray(
                &rrset,
                pnameRecord,
                wtype,
                parray
                );

        DnsAddrArray_Free( parray );
        parray = NULL;
    }

    //
    //  done with adapter name match
    //  either
    //      - no match
    //      - match but didn't get IPs
    //      - match

    if ( !fmatchedName )
    {
        DNSDBG( QUERY, (
            "Leave local_GetLocalAddressRecord() => no domain name match.\n" ));
        return  NULL;
    }

    prr = rrset.pFirstRR;
    if ( prr )
    {
        DNSDBG( QUERY, (
            "Leave local_GetLocalAddressRecord() => %p matched adapter name.\n",
            prr ));
        return  prr;
    }
    goto NoIp;


MatchedPdn:

    //  
    //  matched PDN
    //
    //  for gethostbyname() app-compat, must build in specific order
    //      - first IP in each adapter
    //      - remainder of IPs on adapters
    //

    if ( pnetInfo->pszHostName )
    {
        if ( ! Dns_NameAppend_W(
                    pnameBuf,
                    DNS_MAX_NAME_BUFFER_LENGTH,
                    pnetInfo->pszHostName,
                    pnetInfo->pszDomainName ) )
        {
            DNS_ASSERT( FALSE );
            return  NULL;
        }
        pnameRecord = pnameBuf;
    }
    else
    {
        pnameRecord = L"localhost";
    }

    //
    //  read addrs
    //
    //  note:  we don't add cluster flag above, as cluster addrs
    //      not used on adapter name matches, just PDN for gethostbyname()
    //      compat
    //

    if ( g_IsServer &&
         (pBlob->Flags & DNSP_QUERY_INCLUDE_CLUSTER) )
    {
        addrFlag |= DNS_CONFIG_FLAG_ADDR_CLUSTER;
    }

    //  DCR:  mem alloc failures building local records
    //      getting no records built mapped properly to NO_MEMORY error
    //

    parray = NetInfo_CreateLocalAddrArray(
                pnetInfo,
                NULL,       // no adapter name
                NULL,       // no specific adatper
                family,
                addrFlag );
    if ( !parray )
    {
        return  NULL;
    }

    localip_BuildRRListFromArray(
            &rrset,
            pnameRecord,
            wtype,
            parray
            );

    DnsAddrArray_Free( parray );

    //  if successfully built -- done

    prr = rrset.pFirstRR;
    if ( prr )
    {
        DNSDBG( QUERY, (
            "Leave local_GetLocalAddressRecord() => %p matched PDN name.\n",
            prr ));
        return  prr;
    }

    //  matched name but found no records
    //  fall through to NoIp section
    //
    //goto NoIp;

NoIp:

    //
    //  matched name -- but no IP
    //      use loopback address;  assume this is a lookup prior to
    //      connect which happens to be the local name, rather than an
    //      explict local lookup to get binding IPs
    //

    DNSDBG( ANY, (
        "WARNING:  local name match but no IP -- using loopback\n" ));

    IP6_SET_ADDR_LOOPBACK( &ip6 );
    ip4 = DNS_NET_ORDER_LOOPBACK;
    pBlob->fNoIpLocal = TRUE;

    //  fall through to single IP

SingleIp:

    //  single IP
    //      - loopback address and be unicode queried name

    if ( wtype == DNS_TYPE_A )
    {
        DnsAddr_BuildFromIp4(
            &addr,
            ip4,
            0   // no port
            );
    }
    else
    {
        DnsAddr_BuildFromIp6(
            &addr,
            & ip6,
            0,  // no scope
            0   // no port
            );
    }

    prr = Dns_CreateForwardRecord(
                (PDNS_NAME) pnameRecord,
                wtype,
                & addr,
                LOCAL_IP_TTL,
                DnsCharSetUnicode,
                DnsCharSetUnicode );

    return  prr;
}



DNS_STATUS
Local_GetRecordsForLocalName(
    IN OUT  PQUERY_BLOB     pBlob
    )
/*++

Routine Description:

    Get local address info array.

    EXPORTED:   called by resolver for MCAST

Arguments:

    pBlob -- query blob

    Uses:
        pNameOrig
        wType
        pNetInfo

    Sets:
        pLocalRecords
        fNoIpLocal if local name without records

Return Value:

    ERROR_SUCCESS if successful.
    DNS_ERROR_RCODE_NAME_ERROR on failure.

--*/
{
    WORD            wtype = pBlob->wType;
    PDNS_RECORD     prr = NULL;

    if ( wtype == DNS_TYPE_A ||
         wtype == DNS_TYPE_AAAA )
    {
        prr = local_GetLocalAddressRecord( pBlob );
    }

    else if ( wtype == DNS_TYPE_PTR )
    {
        prr = local_GetLocalPtrRecord( pBlob );
    }

    //  set local records
    //      - if not NO IP situation then this
    //      is final query result also

    if ( prr )
    {
        pBlob->pLocalRecords = prr;
        if ( !pBlob->fNoIpLocal )
        {
            pBlob->pRecords = prr;
        }
        return  ERROR_SUCCESS;
    }

    return  DNS_ERROR_RCODE_NAME_ERROR;
}

//
//  End localip.c
//
=== C:/Users/treeman/Desktop/windows nt source code\Source\Win2K3\NT\ds\dns\dnsapi\memory.c ===
/*++

Copyright (c) 1997-2001  Microsoft Corporation

Module Name:

    memory.c

Abstract:

    Domain Name System (DNS) Library

    Memory allocation routines for DNS library.

Author:

    Jim Gilroy (jamesg)    January, 1997

Revision History:

--*/


#include "local.h"


//
//  Private default dnsapi heap.
//
//  Use non-process heap just so i don't have to debug a stress
//  failure every time some yahoo corrupts their heap.
//

#define PRIVATE_DNSHEAP     1

HEAP_BLOB   g_DnsApiHeap;


//
//  Heap flags
//

#if DBG
#define DNS_HEAP_FLAGS                          \
            (   HEAP_GROWABLE |                 \
                HEAP_TAIL_CHECKING_ENABLED |    \
                HEAP_FREE_CHECKING_ENABLED |    \
                HEAP_CREATE_ALIGN_16 |          \
                HEAP_CLASS_1 )
#else
#define DNS_HEAP_FLAGS                          \
            (   HEAP_GROWABLE |                 \
                HEAP_CREATE_ALIGN_16 |          \
                HEAP_CLASS_1 )
#endif



DNS_STATUS
Heap_Initialize(
    VOID
    )
/*++

Routine Description:

    Initialize heap routines.

    MUST call this in dnsapi.dll attach.
    Note this doesn't actually create the heap.  For perf, don't
    do that until we actually get called.

Arguments:

    None.

Return Value:

    None.

--*/
{
    DNS_STATUS  status = NO_ERROR;

#ifdef PRIVATE_DNSHEAP

    //
    //  use dnslib debug heap as private heap
    //

    LOCK_GENERAL();

    status = Dns_HeapInitialize(
                & g_DnsApiHeap,
                NULL,               // no existing heap handle
                DNS_HEAP_FLAGS,     // create flags
#if DBG
                TRUE,               // use debug headers
#else
                FALSE,              // no debug headers
#endif
                TRUE,               // dnslib uses this heap
                TRUE,               // full heap checks
                0,                  // no exception
                0,                  // no default flags
                "dnslib",           // bogus file
                0                   // bogus line no
                );

    UNLOCK_GENERAL();
#endif

    return  status;
}



VOID
Heap_Cleanup(
    VOID
    )
/*++

Routine Description:

    Delete heap.

    Need this to allow restart.

Arguments:

    None.

Return Value:

    None.

--*/
{
#ifdef PRIVATE_DNSHEAP
    //
    //  delete private heap
    //

    DNSDBG( ANY, ( "Heap_Cleanup()\n" ));

    Dns_HeapCleanup( &g_DnsApiHeap );
#endif
}




//
//  Exported routines
//

VOID
DnsApiHeapReset(
    IN  DNS_ALLOC_FUNCTION      pAlloc,
    IN  DNS_REALLOC_FUNCTION    pRealloc,
    IN  DNS_FREE_FUNCTION       pFree
    )
/*++

Routine Description:

    Resets heap routines used by dnsapi.dll routines.

    DnsApi.dll allocates memory using the dnslib.lib heap
    routines.  This simply resets those routines to use pointers
    to users heap routines.

Arguments:

    pAlloc      -- ptr to desired alloc function
    pRealloc    -- ptr to desired realloc function
    pFree       -- ptr to desired free function

Return Value:

    None.

--*/
{
    //  redirect heap for dnslib

    Dns_LibHeapReset( pAlloc, pRealloc, pFree );
}



//
//  External access to DNS memory routines.
//
//  Modules that use DNS API memory and can be called in the context
//  of DNS server or other process which points dnsapi.dll at another
//  heap, should use these routines rather than LocalAlloc\Free().
//
//  Note:  that these routines can simply call the dnslib routines.
//  This is because dnsapi ALWAYS keeps its heap in sync with dnslib
//  whether it is default heap or has been redirected.  Since dnslib
//  heap routines have the redirection check, we can just call them
//  and they'll do the right thing, we don't need a redirection check
//  ourselves.
//

PVOID
DnsApiAlloc(
    IN      INT             iSize
    )
{
    return  Dns_Alloc( iSize );
}

PVOID
DnsApiAllocZero(
    IN      INT             iSize
    )
{
    return  Dns_AllocZero( iSize );
}

PVOID
DnsApiRealloc(
    IN OUT  PVOID           pMem,
    IN      INT             iSize
    )
{
    return  Dns_Realloc( pMem, iSize );
}

VOID
DnsApiFree(
    IN OUT  PVOID           pMem
    )
{
    Dns_Free( pMem );
}



//
//  SDK public free
//
//  Extensions to DNS_FREE_TYPE enum in windns.h to handle
//  system-public structures.
//  These are only used if freeing with DnsFree(), if using
//  DnsFreeConfigStructure() then use the ConfigId directly.
//
//  For convenience free type is the same as the config id.
//  If this changes must change DnsFreeConfigStructure()
//  to do mapping.
//

//  These conflict with old function defs, so must undef
#undef  DnsFreeNetworkInformation
#undef  DnsFreeSearchInformation
#undef  DnsFreeAdapterInformation


#define DnsFreeNetworkInformation   (DNS_FREE_TYPE)DnsConfigNetworkInformation
#define DnsFreeAdapterInformation   (DNS_FREE_TYPE)DnsConfigAdapterInformation
#define DnsFreeSearchInformation    (DNS_FREE_TYPE)DnsConfigSearchInformation
//#define DnsFreeNetInfo              (DNS_FREE_TYPE)DnsConfigNetInfo

#define DnsFreeNetworkInfoW         (DNS_FREE_TYPE)DnsConfigNetworkInfoW
#define DnsFreeAdapterInfoW         (DNS_FREE_TYPE)DnsConfigAdapterInfoW
#define DnsFreeSearchListW          (DNS_FREE_TYPE)DnsConfigSearchListW
#define DnsFreeNetworkInfoA         (DNS_FREE_TYPE)DnsConfigNetworkInfoA
#define DnsFreeAdapterInfoA         (DNS_FREE_TYPE)DnsConfigAdapterInfoA
#define DnsFreeSearchListA          (DNS_FREE_TYPE)DnsConfigSearchListA



VOID
WINAPI
DnsFree(
    IN OUT  PVOID           pData,
    IN      DNS_FREE_TYPE   FreeType
    )
/*++

Routine Description:

    Generic DNS data free.

Arguments:

    pData -- data to free

    FreeType -- free type

Return Value:

    None

--*/
{
    DNSDBG( TRACE, (
        "DnsFree( %p, %d )\n",
        pData,
        FreeType ));

    if ( !pData )
    {
        return;
    }

    //
    //  free appropriate type
    //

    switch ( FreeType )
    {

    //
    //  Public SDK 
    //

    case  DnsFreeFlat:

        DnsApiFree( pData );
        break;

    case  DnsFreeRecordList:

        Dns_RecordListFree( (PDNS_RECORD)pData );
        break;

    //
    //  Public windns.h, but type only exposed in dnsapi.h
    //

    //  .net server

    case  DnsFreeParsedMessageFields:

        Dns_FreeParsedMessageFields( (PDNS_PARSED_MESSAGE)pData );
        break;

    //
    //  Public -- dnsapi.h
    //  

    //  new config blobs

    case  DnsFreeNetworkInfoW:
    case  DnsFreeNetworkInfoA:

        DnsNetworkInfo_Free( pData );
        break;

    case  DnsFreeSearchListW:
    case  DnsFreeSearchListA:

        DnsSearchList_Free( pData );
        break;

    case  DnsFreeAdapterInfoW:
    case  DnsFreeAdapterInfoA:

        DnsAdapterInfo_Free( pData, TRUE );
        break;

    //  old config blobs

    case  DnsFreeNetworkInformation:

        DnsNetworkInformation_Free( pData );
        break;

    case  DnsFreeSearchInformation:

        DnsSearchInformation_Free( pData );
        break;

    case  DnsFreeAdapterInformation:

        DnsAdapterInformation_Free( pData );
        break;

    default:

        ASSERT( FALSE );
        DnsApiFree( pData );
        break;
    }
}

//
//  End memory.c
//
=== C:/Users/treeman/Desktop/windows nt source code\Source\Win2K3\NT\ds\dns\dnsapi\netinfo.c ===
/*++

Copyright (c) 2000-2001 Microsoft Corporation

Module Name:

    netinfo.c

Abstract:

    Domain Name System (DNS) API

    DNS network info routines.

Author:

    Jim Gilroy (jamesg)     March 2000

Revision History:

--*/


#include "local.h"
#include "registry.h"       // Registry reading definitions



//  Netinfo cache
//
//  Do in process caching of netinfo for brief period for perf
//  Currently cache for only 10s
//  Locking currently just using general CS
//

PDNS_NETINFO    g_pNetInfo = NULL;

#define NETINFO_CACHE_TIMEOUT   (15)    // 15 seconds

BOOL                g_NetInfoCacheLockInitialized = FALSE;
CRITICAL_SECTION    g_NetInfoCacheLock;

#define LOCK_NETINFO_CACHE()    EnterCriticalSection( &g_NetInfoCacheLock );
#define UNLOCK_NETINFO_CACHE()  LeaveCriticalSection( &g_NetInfoCacheLock );

//
//  Netinfo build requires drop into other services
//  which could
//      a) be waiting
//      b) have dependencies back on DNS
//  so we protect with timed lock -- failing if not complete in a few seconds.
//  

BOOL            g_NetInfoBuildLockInitialized = FALSE;
TIMED_LOCK      g_NetInfoBuildLock;

#define LOCK_NETINFO_BUILD()    TimedLock_Enter( &g_NetInfoBuildLock, 5000 );
#define UNLOCK_NETINFO_BUILD()  TimedLock_Leave( &g_NetInfoBuildLock );


//
//  DNS_ADDR screening
//
//  Use a user-defined field in DNS_ADDR as screening mask, in screening function.
//  Mask is set in screening address.

#define DnsAddrFlagScreeningMask    DnsAddrUser1Dword1





VOID
AdapterInfo_Free(
    IN OUT  PDNS_ADAPTER    pAdapter,
    IN      BOOL            fFreeAdapterStruct
    )
/*++

Routine Description:

    Free DNS_ADAPTER structure.

Arguments:

    pAdapter -- pointer to adapter blob to free

Return Value:

    None.

--*/
{
    DNSDBG( TRACE, ( "AdapterInfo_Free( %p, %d )\n", pAdapter, fFreeAdapterStruct ));

    if ( !pAdapter )
    {
        return;
    }

    if ( pAdapter->pszAdapterGuidName )
    {
        FREE_HEAP( pAdapter->pszAdapterGuidName );
    }
    if ( pAdapter->pszAdapterDomain )
    {
        FREE_HEAP( pAdapter->pszAdapterDomain );
    }
    if ( pAdapter->pLocalAddrs )
    {
        FREE_HEAP( pAdapter->pLocalAddrs );
    }
    if ( pAdapter->pDnsAddrs )
    {
        FREE_HEAP( pAdapter->pDnsAddrs );
    }

    if ( fFreeAdapterStruct )
    {
        FREE_HEAP( pAdapter );
    }
}



VOID
AdapterInfo_Init(
    OUT     PDNS_ADAPTER    pAdapter,
    IN      BOOL            fZeroInit,
    IN      DWORD           InfoFlags,
    IN      PWSTR           pszGuidName,
    IN      PWSTR           pszDomain,
    IN      PDNS_ADDR_ARRAY pLocalAddrs,
    IN      PDNS_ADDR_ARRAY pDnsAddrs
    )
/*++

Routine Description:

    Init adapter info blob.

    This sets the blob DIRECTLY with these pointers,
    no reallocation.

Arguments:

    pAdapter -- adapter blob to fill in

    fZeroInit -- clear to zero

    InfoFlags -- flags

    pszGuidName -- GUID name

    pszAdapterDomain -- adapter domain name

    pLocalAddrs -- local addrs

    pDnsAddrs -- DNS server addrs

Return Value:

    Ptr to adapter info, if successful
    NULL on failure.

--*/
{
    DNSDBG( TRACE, ( "AdapterInfo_Init()\n" ));

    //
    //  setup adapter info blob
    //

    if ( fZeroInit )
    {
        RtlZeroMemory(
            pAdapter,
            sizeof( *pAdapter ) );
    }

    //  names

    pAdapter->pszAdapterGuidName    = pszGuidName;
    pAdapter->pszAdapterDomain      = pszDomain;
    pAdapter->pLocalAddrs           = pLocalAddrs;
    pAdapter->pDnsAddrs             = pDnsAddrs;

    //  if no DNS servers -- set ignore flag

    if ( fZeroInit && !pDnsAddrs )
    {
        InfoFlags |= AINFO_FLAG_IGNORE_ADAPTER;
    }

    pAdapter->InfoFlags = InfoFlags;
}



DNS_STATUS
AdapterInfo_Create(
    OUT     PDNS_ADAPTER    pAdapter,
    IN      BOOL            fZeroInit,
    IN      DWORD           InfoFlags,
    IN      PWSTR           pszGuidName,
    IN      PWSTR           pszDomain,
    IN      PDNS_ADDR_ARRAY pLocalAddrs,
    IN      PDNS_ADDR_ARRAY pDnsAddrs
    )
/*++

Routine Description:

    Create adapter info blob.

    This initializes blob with copies of names and addr arrays
    provided.

Arguments:

    pAdapter -- adapter blob to fill in

    fZeroInit -- clear to zero

    InfoFlags -- flags

    pszGuidName -- GUID name

    pszAdapterDomain -- adapter domain name

    pLocalAddrs -- local addrs

    pDnsAddrs -- DNS server addrs

Return Value:

    Ptr to adapter info, if successful
    NULL on failure.

--*/
{
    PDNS_ADDR_ARRAY paddrs;
    PWSTR           pname;

    DNSDBG( TRACE, ( "AdapterInfo_Create()\n" ));

    //
    //  setup adapter info blob
    //

    if ( fZeroInit )
    {
        RtlZeroMemory(
            pAdapter,
            sizeof( *pAdapter ) );
    }

    //  names

    if ( pszGuidName )
    {
        pname = Dns_CreateStringCopy_W( pszGuidName );
        if ( !pname )
        {
            goto Failed;
        }
        pAdapter->pszAdapterGuidName = pname;
    }
    if ( pszDomain )
    {
        pname = Dns_CreateStringCopy_W( pszDomain );
        if ( !pname )
        {
            goto Failed;
        }
        pAdapter->pszAdapterDomain = pname;
    }

    //  addresses

    if ( pLocalAddrs )
    {
        paddrs = DnsAddrArray_CreateCopy( pLocalAddrs );
        if ( !paddrs )
        {
            goto Failed;
        }
        pAdapter->pLocalAddrs = paddrs;
    }
    if ( pDnsAddrs )
    {
        paddrs = DnsAddrArray_CreateCopy( pDnsAddrs );
        if ( !paddrs )
        {
            goto Failed;
        }
        pAdapter->pDnsAddrs = paddrs;
    }

    //  if no DNS servers -- set ignore flag

    if ( fZeroInit && !paddrs )
    {
        InfoFlags |= AINFO_FLAG_IGNORE_ADAPTER;
    }

    pAdapter->InfoFlags = InfoFlags;

    return  NO_ERROR;

Failed:

    AdapterInfo_Free(
        pAdapter,
        FALSE       // no structure free
        );

    return  DNS_ERROR_NO_MEMORY;
}



DNS_STATUS
AdapterInfo_Copy(
    OUT     PDNS_ADAPTER    pCopy,
    IN      PDNS_ADAPTER    pAdapter
    )
/*++

Routine Description:

    Create copy of DNS adapter info.

Arguments:

    pAdapter -- DNS adapter to copy

Return Value:

    Ptr to DNS adapter info copy, if successful
    NULL on failure.

--*/
{
    DNS_STATUS  status;

    DNSDBG( TRACE, ( "AdapterInfo_Copy( %p )\n", pAdapter ));

    if ( !pAdapter || !pCopy )
    {
        return ERROR_INVALID_PARAMETER;
    }

    //
    //  copy all fields
    //

    RtlCopyMemory(
        pCopy,
        pAdapter,
        sizeof( *pAdapter ) );

    pCopy->pszAdapterGuidName = NULL;
    pCopy->pszAdapterDomain = NULL;
    pCopy->pLocalAddrs = NULL;
    pCopy->pDnsAddrs = NULL;
    
    //
    //  do create copy
    //

    return AdapterInfo_Create(
                pCopy,
                FALSE,                  // no zero init
                pAdapter->InfoFlags,
                pAdapter->pszAdapterGuidName,
                pAdapter->pszAdapterDomain,
                pAdapter->pLocalAddrs,
                pAdapter->pDnsAddrs );
}



DNS_STATUS
AdapterInfo_CreateFromIp4Array(
    OUT     PDNS_ADAPTER    pAdapter,
    IN      PIP4_ARRAY      pServerArray,
    IN      DWORD           Flags,
    IN      PWSTR           pszDomainName,
    IN      PWSTR           pszGuidName
    )
/*++

Routine Description:

    Create copy of IP address array as a DNS Server list.

Arguments:

    pIpArray    -- IP address array to convert

    Flags       -- Flags that describe the adapter

    pszDomainName -- The default domain name for the adapter

    pszGuidName -- The registry GUID name for the adapter (if NT)

Return Value:

    ERROR_SUCCESS if successful.
    ErrorCode on error.

--*/
{
    DNS_STATUS      status;
    PDNS_ADDR_ARRAY pdnsArray;
    DWORD           i;
    DWORD           count;

    DNSDBG( TRACE, ( "AdapterInfo_CreateFromIp4Array()\n" ));

    //
    //  get count of DNS servers
    //

    if ( !pServerArray )
    {
        count = 0;
    }
    else
    {
        count = pServerArray->AddrCount;
    }

    //
    //  copy DNS server IPs
    //

    pdnsArray = DnsAddrArray_CreateFromIp4Array( pServerArray );
    if ( !pdnsArray )
    {
        status = DNS_ERROR_NO_MEMORY;
        goto Done;
    }

    //
    //  build adapter info
    //

    status = AdapterInfo_Create(
                    pAdapter,
                    TRUE,       // zero init
                    Flags,
                    pszDomainName,
                    pszGuidName,
                    NULL,
                    pdnsArray );

Done:

    DnsAddrArray_Free( pdnsArray );

    return  status;
}




//
//  Search list routines
//

PSEARCH_LIST    
SearchList_Alloc(
    IN      DWORD           MaxNameCount
    )
/*++

Routine Description:

    Create uninitialized search list.

Arguments:

    NameCount -- count of search names list will hold

Return Value:

    Ptr to uninitialized DNS search list, if successful
    NULL on failure.

--*/
{
    PSEARCH_LIST    psearchList = NULL;
    DWORD           length;

    DNSDBG( TRACE, ( "SearchList_Alloc()\n" ));

    //
    //  note:  specifically allowing alloc even if no name count
    //      or domain name as could have no PDN and still need
    //      search list referenced in query
    //
#if 0
    if ( MaxNameCount == 0 )
    {
        return NULL;
    }
#endif

    //
    //  allocate for max entries
    //

    length = sizeof(SEARCH_LIST)
                    - sizeof(SEARCH_NAME)
                    + ( sizeof(SEARCH_NAME) * MaxNameCount );

    psearchList = (PSEARCH_LIST) ALLOCATE_HEAP_ZERO( length );
    if ( ! psearchList )
    {
        return NULL;
    }

    psearchList->MaxNameCount = MaxNameCount;

    return psearchList;
}



VOID
SearchList_Free(
    IN OUT  PSEARCH_LIST    pSearchList
    )
/*++

Routine Description:

    Free SEARCH_LIST structure.

Arguments:

    pSearchList -- ptr to search list to free

Return Value:

    None

--*/
{
    DWORD i;

    DNSDBG( TRACE, ( "SearchList_Free( %p )\n", pSearchList ));

    //
    //  free all search names, then list itself
    //

    if ( pSearchList )
    {
        for ( i=0; i < pSearchList->NameCount; i++ )
        {
            PWSTR   pname = pSearchList->SearchNameArray[i].pszName;
            if ( pname )
            {
                FREE_HEAP( pname );
            }
        }
        FREE_HEAP( pSearchList );
    }
}



PSEARCH_LIST    
SearchList_Copy(
    IN      PSEARCH_LIST    pSearchList
    )
/*++

Routine Description:

    Create copy of search list.

Arguments:

    pSearchList -- search list to copy

Return Value:

    Ptr to DNS Search list copy, if successful
    NULL on failure.

--*/
{
    PSEARCH_LIST    pcopy;
    DWORD           i;

    DNSDBG( TRACE, ( "SearchList_Copy()\n" ));

    if ( ! pSearchList )
    {
        return NULL;
    }

    //
    //  create DNS Search list of desired size
    //
    //  since we don't add and delete from search list once
    //  created, size copy only for actual name count
    //

    pcopy = SearchList_Alloc( pSearchList->NameCount );
    if ( ! pcopy )
    {
        return NULL;
    }

    for ( i=0; i < pSearchList->NameCount; i++ )
    {
        PWSTR   pname = pSearchList->SearchNameArray[i].pszName;

        if ( pname )
        {
            pname = Dns_CreateStringCopy_W( pname );
            if ( pname )
            {
               pcopy->SearchNameArray[i].pszName = pname;
               pcopy->SearchNameArray[i].Flags = pSearchList->SearchNameArray[i].Flags;
               pcopy->NameCount++;
            }
        }
    }

    return pcopy;
}



BOOL
SearchList_ContainsName(
    IN      PSEARCH_LIST    pSearchList,
    IN      PWSTR           pszName
    )
/*++

Routine Description:

    Check if name is in search list.

Arguments:

    pSearchList -- ptr to search list being built

    pszName -- name to check

Return Value:

    TRUE if name is in search list.
    FALSE otherwise.

--*/
{
    DWORD   count = pSearchList->NameCount;

    //
    //  check every search list entry for this name
    //

    while ( count-- )
    {
        if ( Dns_NameCompare_W(
                pSearchList->SearchNameArray[ count ].pszName,
                pszName ) )
        {
            return( TRUE );
        }
    }
    return( FALSE );
}



VOID
SearchList_AddName(
    IN OUT  PSEARCH_LIST    pSearchList,
    IN      PWSTR           pszName,
    IN      DWORD           Flag
    )
/*++

Routine Description:

    Add name to search list.

Arguments:

    pSearchList -- ptr to search list being built

    pszName -- name to add to search list

    Flag -- flag value

Return Value:

    None.  Name is added to search list, unless memory alloc failure.

--*/
{
    DWORD   count = pSearchList->NameCount;
    PWSTR   pallocName;

    DNSDBG( TRACE, ( "Search_AddName()\n" ));

    //
    //  ignore name is already in list
    //  ignore if at list max
    //

    if ( SearchList_ContainsName(
            pSearchList,
            pszName )
                ||
         count >= pSearchList->MaxNameCount )
    {
        return;
    }

    //  copy name and put in list

    pallocName = Dns_CreateStringCopy_W( pszName );
    if ( !pallocName )
    {
        return;
    }
    pSearchList->SearchNameArray[count].pszName = pallocName;

    //
    //  set flag -- but first flag always zero (normal timeouts)
    //      this protects against no PDN situation where use adapter
    //      name as PDN;

    if ( count == 0 )
    {
        Flag = 0;
    }
    pSearchList->SearchNameArray[count].Flags = Flag;
    pSearchList->NameCount = ++count;
}



DNS_STATUS
SearchList_Parse(
    IN OUT  PSEARCH_LIST    pSearchList,
    IN      PWSTR           pszList
    )
/*++

Routine Description:

    Parse registry search list string into SEARCH_LIST structure.

Arguments:

    pSearchList -- search list array

    pszList -- registry list of search names;
        names are comma or white space separated

Return Value:

    ERROR_SUCCESS if successful.
    Error code on failure.

--*/
{
    register    PWCHAR pch = pszList;
    WCHAR       ch;
    PWCHAR      pnameStart;
    PWSTR       pname;
    DWORD       countNames = pSearchList->NameCount;

    DNSDBG( NETINFO, (
        "SearchList_Parse( %p, %S )\n",
        pSearchList,
        pszList ));

    //
    //  extract each domain name string in buffer,
    //  and add to search list array
    //

    while( ch = *pch && countNames < MAX_SEARCH_LIST_ENTRIES )
    {
        //  skip leading whitespace, find start of domain name string

        while( ch == ' ' || ch == '\t' || ch == ',' )
        {
            ch = *++pch;
        }
        if ( ch == 0 )
        {
            break;
        }
        pnameStart = pch;

        //
        //  find end of string and NULL terminate
        //

        ch = *pch;
        while( ch != L' ' && ch != L'\t' && ch != L'\0' && ch != L',' )
        {
            ch = *++pch;
        }
        *pch = L'\0';

        //
        //  end of buffer?
        //

        if ( pch == pnameStart )
        {
            break;
        }

        //
        //  whack any trailing dot on name
        //

        pch--;
        if ( *pch == L'.' )
        {
            *pch = L'\0';
        }
        pch++;

        //
        //  make copy of the name
        //

        pname = Dns_CreateStringCopy_W( pnameStart );
        if ( pname )
        {
            pSearchList->SearchNameArray[ countNames ].pszName = pname;
            pSearchList->SearchNameArray[ countNames ].Flags = 0;
            countNames++;
        }

        //  if more continue

        if ( ch != 0 )
        {
            pch++;
            continue;
        }
        break;
    }

    //  reset name count

    pSearchList->NameCount = countNames;

    return( ERROR_SUCCESS );
}



PSEARCH_LIST    
SearchList_Build(
    IN      PWSTR           pszPrimaryDomainName,
    IN      PREG_SESSION    pRegSession,
    IN      HKEY            hKey,
    IN OUT  PDNS_NETINFO    pNetInfo,
    IN      BOOL            fUseDomainNameDevolution
    )
/*++

Routine Description:

    Build search list.

Arguments:

    pszPrimaryDomainName -- primary domain name

    pRegSession -- registry session

    hKey -- registry key

Return Value:

    Ptr to search list.
    NULL on error or no search list.

--*/
{
    PSEARCH_LIST    ptempList;
    PWSTR           pregList = NULL;
    DWORD           status;


    DNSDBG( TRACE, ( "Search_ListBuild()\n" ));

    ASSERT( pRegSession || hKey );

    //
    //  create search list using PDN
    //

    ptempList = SearchList_Alloc( MAX_SEARCH_LIST_ENTRIES );
    if ( !ptempList )
    {
        return( NULL );
    }

    //
    //  read search list from registry
    //

    status = Reg_GetValue(
                    pRegSession,
                    hKey,
                    RegIdSearchList,
                    REGTYPE_SEARCH_LIST,
                    (PBYTE*) &pregList
                    );

    if ( status == ERROR_SUCCESS )
    {
        ASSERT( pregList != NULL );

        SearchList_Parse(
            ptempList,
            pregList );

        FREE_HEAP( pregList );
    }
    else if ( status == DNS_ERROR_NO_MEMORY )
    {
        FREE_HEAP( ptempList );
        return  NULL;
    }

    //
    //  if no registry search list -- build one
    //
    //  DCR:  eliminate autobuilt search list
    //

    if ( ! ptempList->NameCount )
    {
        //
        //  use PDN in first search list slot
        //

        if ( pszPrimaryDomainName )
        {
            SearchList_AddName(
                ptempList,
                pszPrimaryDomainName,
                0 );
        }

        //
        //  add devolved PDN if have NameDevolution
        //
        //  note, we devolve only down to second level
        //  domain name "microsoft.com" NOT "com";
        //  to avoid being fooled by name like "com."
        //  also check that last dot is not terminal
        //      

        if ( pszPrimaryDomainName && fUseDomainNameDevolution )
        {
            PWSTR   pname = pszPrimaryDomainName;

            while ( pname )
            {
                PWSTR   pnext = wcschr( pname, '.' );

                if ( !pnext )
                {
                    break;
                }
                pnext++;
                if ( !*pnext )
                {
                    //DNS_ASSERT( FALSE );
                    break;
                }

                //  add name, but not on first pass
                //      - already have PDN in first slot

                if ( pname != pszPrimaryDomainName )
                {
                    SearchList_AddName(
                        ptempList,
                        pname,
                        DNS_QUERY_USE_QUICK_TIMEOUTS );
                }
                pname = pnext;
            }
        }

        //  indicate this is dummy search list

        if ( pNetInfo )
        {
            pNetInfo->InfoFlags |= NINFO_FLAG_DUMMY_SEARCH_LIST;
        }
    }

    return ptempList;
}



PWSTR
SearchList_GetNextName(
    IN OUT  PSEARCH_LIST    pSearchList,
    IN      BOOL            fReset,
    OUT     PDWORD          pdwSuffixFlags  OPTIONAL
    )
/*++

Routine Description:

    Gets the next name from the search list.

Arguments:

    pSearchList -- search list

    fReset -- TRUE to reset to beginning of search list

    pdwSuffixFlags -- flags associate with using this suffix

Return Value:

    Ptr to the next search name.  Note, this is a pointer
    to a name in the search list NOT an allocation.  Search
    list structure must stay valid during use.

    NULL when out of search names.

--*/
{
    DWORD   flag = 0;
    PWSTR   pname = NULL;
    DWORD   index;


    DNSDBG( TRACE, ( "SearchList_GetNextName()\n" ));

    //  no list

    if ( !pSearchList )
    {
        goto Done;
    }

    //
    //  reset?
    //

    if ( fReset )
    {
        pSearchList->CurrentNameIndex = 0;
    }

    //
    //  if valid name -- retrieve it
    //

    index = pSearchList->CurrentNameIndex;

    if ( index < pSearchList->NameCount )
    {
        pname = pSearchList->SearchNameArray[index].pszName;
        flag = pSearchList->SearchNameArray[index].Flags;
        pSearchList->CurrentNameIndex = ++index;
    }

Done:

    if ( pdwSuffixFlags )
    {
        *pdwSuffixFlags = flag;
    }
    return pname;
}



//
//  Net info routines
//

PDNS_NETINFO
NetInfo_Alloc(
    IN      DWORD           AdapterCount
    )
/*++

Routine Description:

    Allocate network info.

Arguments:

    AdapterCount -- count of net adapters info will hold

Return Value:

    Ptr to uninitialized DNS network info, if successful
    NULL on failure.

--*/
{
    PDNS_NETINFO    pnetInfo;
    DWORD           length;

    DNSDBG( TRACE, ( "NetInfo_Alloc()\n" ));

    //
    //  alloc
    //      - zero to avoid garbage on early free
    //

    length = sizeof(DNS_NETINFO)
                - sizeof(DNS_ADAPTER)
                + (sizeof(DNS_ADAPTER) * AdapterCount);

    pnetInfo = (PDNS_NETINFO) ALLOCATE_HEAP_ZERO( length );
    if ( ! pnetInfo )
    {
        return NULL;
    }

    pnetInfo->MaxAdapterCount = AdapterCount;

    return( pnetInfo );
}



VOID
NetInfo_Free(
    IN OUT  PDNS_NETINFO    pNetInfo
    )
/*++

Routine Description:

    Free DNS_NETINFO structure.

Arguments:

    pNetInfo -- ptr to netinfo to free

Return Value:

    None

--*/
{
    DWORD i;

    DNSDBG( TRACE, ( "NetInfo_Free( %p )\n", pNetInfo ));

    if ( ! pNetInfo )
    {
        return;
    }
    IF_DNSDBG( OFF )
    {
        DnsDbg_NetworkInfo(
            "Network Info before free: ",
            pNetInfo );
    }

    //
    //  free
    //      - search list
    //      - domain name
    //      - all the adapter info blobs
    //

    SearchList_Free( pNetInfo->pSearchList );

    if ( pNetInfo->pszDomainName )
    {
        FREE_HEAP( pNetInfo->pszDomainName );
    }
    if ( pNetInfo->pszHostName )
    {
        FREE_HEAP( pNetInfo->pszHostName );
    }

    for ( i=0; i < pNetInfo->AdapterCount; i++ )
    {
        AdapterInfo_Free(
            NetInfo_GetAdapterByIndex( pNetInfo, i ),
            FALSE       // no structure free
            );
    }

    FREE_HEAP( pNetInfo );
}



PDNS_NETINFO     
NetInfo_Copy(
    IN      PDNS_NETINFO    pNetInfo
    )
/*++

Routine Description:

    Create copy of DNS Network info.

Arguments:

    pNetInfo -- DNS Network info to copy

Return Value:

    Ptr to DNS Network info copy, if successful
    NULL on failure.

--*/
{
    PDNS_NETINFO    pcopy;
    PDNS_ADAPTER    padapter;
    DWORD           adapterCount;
    DNS_STATUS      status;
    DWORD           iter;

    DNSDBG( TRACE, ( "NetInfo_Copy( %p )\n", pNetInfo ));

    if ( ! pNetInfo )
    {
        return NULL;
    }

    IF_DNSDBG( OFF )
    {
        DnsDbg_NetworkInfo(
            "Netinfo to copy: ",
            pNetInfo );
    }

    //
    //  create network info struct of desired size
    //

    pcopy = NetInfo_Alloc( pNetInfo->AdapterCount );
    if ( ! pcopy )
    {
        return NULL;
    }

    //
    //  copy flat fields
    //      - must reset MaxAdapterCount to actual allocation
    //      - AdapterCount reset below
    //

    RtlCopyMemory(
        pcopy,
        pNetInfo,
        (PBYTE) &pcopy->AdapterArray[0] - (PBYTE)pcopy );

    pcopy->MaxAdapterCount = pNetInfo->AdapterCount;
    pcopy->AdapterCount = 0;

    //
    //  copy subcomponents
    //      - domain name
    //      - search list
    //

    pcopy->pszDomainName = Dns_CreateStringCopy_W( pNetInfo->pszDomainName );
    pcopy->pszHostName = Dns_CreateStringCopy_W( pNetInfo->pszHostName );

    pcopy->pSearchList = SearchList_Copy( pNetInfo->pSearchList );

    if ( (!pcopy->pszDomainName && pNetInfo->pszDomainName) ||
         (!pcopy->pszHostName   && pNetInfo->pszHostName) ||
         (!pcopy->pSearchList   && pNetInfo->pSearchList) )
    {
        status = DNS_ERROR_NO_MEMORY;
        goto Failed;
    }

    //
    //  copy adapter info
    //

    adapterCount = 0;

    for ( iter=0; iter<pNetInfo->AdapterCount; iter++ )
    {
        padapter = NetInfo_GetAdapterByIndex( pNetInfo, iter );

        status = AdapterInfo_Copy(
                    &pcopy->AdapterArray[ adapterCount ],
                    padapter
                    );
        if ( status == NO_ERROR )
        {
            pcopy->AdapterCount = ++adapterCount;
            continue;
        }
        goto Failed;
    }

    IF_DNSDBG( OFF )
    {
        DnsDbg_NetworkInfo(
            "Netinfo copy: ",
            pcopy );
    }
    return pcopy;


Failed:

    NetInfo_Free( pcopy );
    SetLastError( status );
    return  NULL;
}



VOID
NetInfo_Clean(
    IN OUT  PDNS_NETINFO    pNetInfo,
    IN      DWORD           ClearLevel
    )
/*++

Routine Description:

    Clean network info.

    Removes all query specific info and restores to
    state that is "fresh" for next query.

Arguments:

    pNetInfo -- DNS network info

    ClearLevel -- level of runtime flag cleaning
        
Return Value:

    None

--*/
{
    PDNS_ADAPTER    padapter;
    DWORD           iter;

    DNSDBG( TRACE, (
        "Enter NetInfo_Clean( %p, %08x )\n",
        pNetInfo,
        ClearLevel ));

    IF_DNSDBG( NETINFO2 )
    {
        DnsDbg_NetworkInfo(
            "Cleaning network info:",
            pNetInfo
            );
    }

    //
    //  clean up info
    //      - clear status fields
    //      - clear RunFlags
    //      - clear temp bits on InfoFlags
    //
    //  note, runtime flags are wiped depending on level
    //      specified in call
    //      - all (includes disabled\timedout adapter info)
    //      - query (all query info)
    //      - name (all info for single name query)
    //
    //  finally we set NETINFO_PREPARED flag so that we can
    //  can check for and do this initialization in the send
    //  code if not previously done;
    //
    //  in the standard query path we can
    //      - do this init
    //      - disallow adapters based on query name
    //      - send without the info getting wiped
    //
    //  in other send paths
    //      - send checks that NETINFO_PREPARED is not set
    //      - does basic init
    //

    pNetInfo->ReturnFlags &= ClearLevel;
    pNetInfo->ReturnFlags |= RUN_FLAG_NETINFO_PREPARED;

    for ( iter=0; iter<pNetInfo->AdapterCount; iter++ )
    {
        DWORD           j;
        PDNS_ADDR_ARRAY pserverArray;

        padapter = NetInfo_GetAdapterByIndex( pNetInfo, iter );

        pserverArray = padapter->pDnsAddrs;
        if ( !pserverArray )
        {
            continue;
        }

        padapter->Status = 0;
        padapter->RunFlags &= ClearLevel;

        //  clear server status fields

        for ( j=0; j<pserverArray->AddrCount; j++ )
        {
            pserverArray->AddrArray[j].Flags = SRVFLAG_NEW;
            pserverArray->AddrArray[j].Status = SRVSTATUS_NEW;
        }
    }
}



VOID
NetInfo_ResetServerPriorities(
    IN OUT  PDNS_NETINFO    pNetInfo,
    IN      BOOL            fLocalDnsOnly
    )
/*++

Routine Description:

    Resets the DNS server priority values for the DNS servers.

Arguments:

    pNetInfo -- pointer to a DNS network info structure.

    fLocalDnsOnly - TRUE to reset priority ONLY on local DNS servers
        Note that this requires that the network info contain the IP address
        list for each adapter so that the IP address list can be compared
        to the DNS server list.

Return Value:

    Nothing

--*/
{
    PDNS_ADAPTER    padapter;
    DWORD           iter;

    DNSDBG( TRACE, ( "NetInfo_ResetServerPriorities( %p )\n", pNetInfo ));

    if ( !pNetInfo )
    {
        return;
    }

    //
    //  reset priorities on server
    //  when
    //      - not do local only OR
    //      - server IP matches one of adapter IPs
    //
    //  FIX6:  local DNS check needs IP6 fixups
    //  DCR:  encapsulate as "NetInfo_IsLocalAddress

    for ( iter=0; iter<pNetInfo->AdapterCount; iter++ )
    {
        DWORD           j;
        PDNS_ADDR_ARRAY pserverArray;

        padapter = NetInfo_GetAdapterByIndex( pNetInfo, iter );

        pserverArray = padapter->pDnsAddrs;
        if ( !pserverArray )
        {
            continue;
        }

        for ( j=0; j < pserverArray->AddrCount; j++ )
        {
            PDNS_ADDR   pserver = &pserverArray->AddrArray[j];

            //  loopback goes first
            //      - we plumb it in for specific AD scenarios
            //      - the cost of failure is low (should just generate
            //      ICMP -- CONNRESET -- if server not running)

            if ( DnsAddr_IsLoopback(pserver, 0) )
            {
                pserver->Priority = SRVPRI_LOOPBACK;
                continue;
            }

            if ( !fLocalDnsOnly )
            {
                if ( DnsAddr_IsIp6DefaultDns( pserver ) )
                {
                    pserver->Priority = SRVPRI_IP6_DEFAULT;
                    continue;
                }
                else
                {
                    pserver->Priority = SRVPRI_DEFAULT;
                    continue;
                }
            }

            //  pull this into local test

            if ( LocalIp_IsAddrLocal(
                    pserver,
                    NULL,       // no local array
                    pNetInfo    // use netinfo to screen local addrs
                    ) )
            {
                pserver->Priority = SRVPRI_DEFAULT;
                continue;
            }
        }
    }
}



PDNS_ADAPTER
NetInfo_GetNextAdapter(
    IN OUT  PDNS_NETINFO    pNetInfo
    )
/*++

Routine Description:

    Get next adapter.

    Note, this must be preceeded by a call to macro
    NetInfo_StartAdapterLoop()

Arguments:

    pNetInfo -- netinfo to get adapter from
        note, internal index is incremented

Return Value:

    Ptr to next DNS_ADAPTER
    NULL when out of adapters.

--*/
{
    DWORD           index;
    PDNS_ADAPTER    padapter = NULL;

    //
    //  get next adapter if still in range
    //

    index = pNetInfo->AdapterIndex;

    if ( index < pNetInfo->AdapterCount )
    {
        padapter = &pNetInfo->AdapterArray[ index++ ];

        pNetInfo->AdapterIndex = index;
    }

    return  padapter;
}



PDNS_ADAPTER
NetInfo_GetAdapterByName(
    IN      PDNS_NETINFO    pNetInfo,
    IN      PWSTR           pwsAdapterName
    )
/*++

Routine Description:

    Find adapter in netinfo by name.

Arguments:

    pNetInfo -- DNS net adapter list to convert

    pAdapterName -- adapter name

Return Value:

    Ptr to adapter, if adapter name found.
    NULL on failure.

--*/
{
    PDNS_ADAPTER    padapterFound = NULL;
    PDNS_ADAPTER    padapter;
    DWORD           iter;


    DNSDBG( TRACE, ( "NetInfo_GetAdapterByName( %p )\n", pNetInfo ));

    if ( !pNetInfo || !pwsAdapterName )
    {
        SetLastError( ERROR_INVALID_PARAMETER );
        return NULL;
    }

    //
    //  find matching adapter
    //

    for ( iter=0; iter<pNetInfo->AdapterCount; iter++ )
    {
        padapter = NetInfo_GetAdapterByIndex( pNetInfo, iter );

        if ( wcscmp( padapter->pszAdapterGuidName, pwsAdapterName ) == 0 )
        {
            padapterFound = padapter;
            break;
        }
    }

    return( padapterFound );
}



PDNS_ADDR_ARRAY
NetInfo_ConvertToAddrArray(
    IN      PDNS_NETINFO    pNetInfo,
    IN      PWSTR           pwsAdapterName,
    IN      DWORD           Family      OPTIONAL
    )
/*++

Routine Description:

    Create IP array of DNS servers from network info.

Arguments:

    pNetInfo -- DNS net adapter list to convert

    pwsAdapterName -- specific adapter

    Family -- required specific address family

Return Value:

    Ptr to IP array, if successful
    NULL on failure.

--*/
{
    PDNS_ADDR_ARRAY parray = NULL;
    DWORD           countServers = 0;
    PDNS_ADAPTER    padapter;
    PDNS_ADAPTER    padapterSingle = NULL;
    DNS_STATUS      status = NO_ERROR;
    DWORD           iter;

    DNSDBG( TRACE, ( "NetInfo_ConvertToAddrArray( %p )\n", pNetInfo ));

    //
    //  get count
    //

    if ( ! pNetInfo )
    {
        return NULL;
    }

    if ( pwsAdapterName )
    {
        padapterSingle = NetInfo_GetAdapterByName( pNetInfo, pwsAdapterName );
        if ( !padapterSingle )
        {
            goto Done;
        }
        countServers = DnsAddrArray_GetFamilyCount(
                            padapterSingle->pDnsAddrs,
                            Family );
    }
    else
    {
        for ( iter=0; iter<pNetInfo->AdapterCount; iter++ )
        {
            padapter = NetInfo_GetAdapterByIndex( pNetInfo, iter );

            countServers += DnsAddrArray_GetFamilyCount(
                                padapter->pDnsAddrs,
                                Family );
        }
    }

    //
    //  allocate required array
    //

    parray = DnsAddrArray_Create( countServers );
    if ( !parray )
    {
        status = DNS_ERROR_NO_MEMORY;
        goto Done;
    }
    DNS_ASSERT( parray->MaxCount == countServers );

    //
    //  read all servers into IP array
    //

    for ( iter=0; iter<pNetInfo->AdapterCount; iter++ )
    {
        padapter = NetInfo_GetAdapterByIndex( pNetInfo, iter );

        if ( !padapterSingle ||
             padapterSingle == padapter )
        {
            status = DnsAddrArray_AppendArrayEx(
                        parray,
                        padapter->pDnsAddrs,
                        0,              //  append all
                        Family,         //  family screen
                        0,              //  no dup screen
                        NULL,           //  no other screening
                        NULL            //  no other screening
                        );

            DNS_ASSERT( status == NO_ERROR );
        }
    }

Done:

    if ( status != NO_ERROR )
    {
        SetLastError( status );
    }

    return( parray );
}



PDNS_NETINFO     
NetInfo_CreateForUpdate(
    IN      PWSTR           pszZone,
    IN      PWSTR           pszServerName,
    IN      PDNS_ADDR_ARRAY pServerArray,
    IN      DWORD           dwFlags
    )
/*++

Routine Description:

    Create network info suitable for update.

Arguments:

    pszZone -- target zone name

    pszServerName -- target server name

    pServerArray -- IP array with target server IP

    dwFlags -- flags


Return Value:

    Ptr to resulting update compatible network info.
    NULL on failure.

--*/
{
    PDNS_ADAPTER    padapter;
    PDNS_NETINFO    pnetInfo;

    DNSDBG( TRACE, ( "NetInfo_CreateForUpdate()\n" ));

    //
    //  allocate
    //

    pnetInfo = NetInfo_Alloc( 1 );
    if ( !pnetInfo )
    {
        return NULL;
    }

    //
    //  save zone name
    //

    if ( pszZone )
    {
        pnetInfo->pszDomainName = Dns_CreateStringCopy_W( pszZone );
        if ( !pnetInfo->pszDomainName )
        {
            goto Fail;
        }
    }

    //
    //  convert IP array and server name to server list
    //

    if ( NO_ERROR != AdapterInfo_Create(
                        &pnetInfo->AdapterArray[0],
                        TRUE,               // zero init
                        dwFlags,
                        NULL,               // no GUID
                        pszServerName,      // use as domain name
                        NULL,               // no local addrs
                        pServerArray
                        ) )
    {
        goto Fail;
    }
    pnetInfo->AdapterCount = 1;

    IF_DNSDBG( NETINFO2 )
    {
        DnsDbg_NetworkInfo(
            "Update network info is: ",
            pnetInfo );
    }
    return pnetInfo;

Fail:

    DNSDBG( TRACE, ( "Failed NetInfo_CreateForUpdate()!\n" ));
    NetInfo_Free( pnetInfo );
    return NULL;
}



#if 0
PDNS_NETINFO     
NetInfo_CreateForUpdateIp4(
    IN      PWSTR           pszZone,
    IN      PWSTR           pszServerName,
    IN      PIP4_ARRAY      pServ4Array,
    IN      DWORD           dwFlags
    )
/*++

Routine Description:

    Create network info suitable for update -- IP4 version.

    DCR:  Used only by Dns_UpdateLib() once killed, kill this.

Arguments:

    pszZone -- target zone name

    pszServerName -- target server name

    pServ4Array -- IP$ array with target server IP

    dwFlags -- flags

Return Value:

    Ptr to resulting update compatible network info.
    NULL on failure.

--*/
{
    PADDR_ARRAY     parray;
    PDNS_NETINFO    pnetInfo;

    //
    //  convert 4 to 6, then call real routine
    //

    parray = DnsAddrArray_CreateFromIp4Array( pServ4Array );

    pnetInfo = NetInfo_CreateForUpdate(
                    pszZone,
                    pszServerName,
                    parray,
                    dwFlags );

    DnsAddrArray_Free( parray );

    return  pnetInfo;
}
#endif



PWSTR
NetInfo_UpdateZoneName(
    IN      PDNS_NETINFO    pNetInfo
    )
/*++

Routine Description:

    Retrieve update zone name.

Arguments:

    pNetInfo -- blob to check

Return Value:

    Ptr to update zone name.
    NULL on error.

--*/
{
    return  pNetInfo->pszDomainName;
}



PWSTR
NetInfo_UpdateServerName(
    IN      PDNS_NETINFO    pNetInfo
    )
/*++

Routine Description:

    Retrieve update servere name.

Arguments:

    pNetInfo -- blob to check

Return Value:

    Ptr to update zone name.
    NULL on error.

--*/
{
    return  pNetInfo->AdapterArray[0].pszAdapterDomain;
}



BOOL
NetInfo_IsForUpdate(
    IN      PDNS_NETINFO    pNetInfo
    )
/*++

Routine Description:

    Check if network info blob if "update capable".

    This means whether it is the result of a FAZ and
    can be used to send updates.

Arguments:

    pNetInfo -- blob to check

Return Value:

    TRUE if update network info.
    FALSE otherwise.

--*/
{
    DNSDBG( TRACE, ( "NetInfo_IsForUpdate()\n" ));

    return  (   pNetInfo &&
                pNetInfo->pszDomainName &&
                pNetInfo->AdapterCount == 1 );
}



PDNS_NETINFO     
NetInfo_CreateFromAddrArray(
    IN      PADDR_ARRAY     pDnsServers,
    IN      PDNS_ADDR       pServerIp,
    IN      BOOL            fSearchInfo,
    IN      PDNS_NETINFO    pNetInfo        OPTIONAL
    )
/*++

Routine Description:

    Create network info given DNS server list.

Arguments:

    pDnsServers -- IP array of DNS servers

    ServerIp -- single IP in list

    fSearchInfo -- TRUE if need search info

    pNetInfo -- current network info blob to copy search info
        from;  this field is only relevant if fSearchInfo is TRUE

Return Value:

    Ptr to resulting network info.
    NULL on failure.

--*/
{
    PDNS_NETINFO    pnetInfo;
    ADDR_ARRAY      ipArray;
    PADDR_ARRAY     parray = pDnsServers;   
    PSEARCH_LIST    psearchList;
    PWSTR           pdomainName;
    DWORD           flags = 0;

    //
    //  DCR:  eliminate search list form this routine
    //      i believe this routine is only used for query of
    //      FQDNs (usually in update) and doesn't require
    //      any default search info
    //
    //  DCR:  possibly combine with "BuildForUpdate" routine
    //      where search info included tacks this on
    //

    //
    //  if given single IP, ONLY use it
    //

    if ( pServerIp )
    {
        DnsAddrArray_InitSingleWithAddr(
            & ipArray,
            pServerIp );

        parray = &ipArray;
    }

    //
    //  convert server IPs into network info blob
    //      - simply use update function above to avoid duplicate code
    //

    pnetInfo = NetInfo_CreateForUpdate(
                    NULL,           // no zone
                    NULL,           // no server name
                    parray,
                    0               // no flags
                    );
    if ( !pnetInfo )
    {
        return( NULL );
    }

    //
    //  get search list and primary domain info
    //      - copy from passed in network info
    //          OR
    //      - cut directly out of new netinfo
    //

    if ( fSearchInfo )
    {
        if ( pNetInfo )
        {
            flags       = pNetInfo->InfoFlags;
            psearchList = SearchList_Copy( pNetInfo->pSearchList );
            pdomainName = Dns_CreateStringCopy_W( pNetInfo->pszDomainName );
        }
        else
        {
            PDNS_NETINFO    ptempNetInfo = GetNetworkInfo();
    
            if ( ptempNetInfo )
            {
                flags       = ptempNetInfo->InfoFlags;
                psearchList = ptempNetInfo->pSearchList;
                pdomainName = ptempNetInfo->pszDomainName;
    
                ptempNetInfo->pSearchList = NULL;
                ptempNetInfo->pszDomainName = NULL;
                NetInfo_Free( ptempNetInfo );
            }
            else
            {
                psearchList = NULL;
                pdomainName = NULL;
            }
        }

        //  plug search info into new netinfo blob

        pnetInfo->pSearchList   = psearchList;
        pnetInfo->pszDomainName = pdomainName;
        pnetInfo->InfoFlags    |= (flags & NINFO_FLAG_DUMMY_SEARCH_LIST);
    }
    
    return( pnetInfo );
}



#if 0
PDNS_NETINFO     
NetInfo_CreateFromIp4Array(
    IN      PIP4_ARRAY      pDnsServers,
    IN      IP4_ADDRESS     ServerIp,
    IN      BOOL            fSearchInfo,
    IN      PDNS_NETINFO    pNetInfo        OPTIONAL
    )
/*++

Routine Description:

    Create network info given DNS server list.

    Used only in Glenn update routines -- kill when they are deleted.

Arguments:

    pDnsServers -- IP array of DNS servers

    ServerIp -- single IP in list

    fSearchInfo -- TRUE if need search info

    pNetInfo -- current network info blob to copy search info
        from;  this field is only relevant if fSearchInfo is TRUE

Return Value:

    Ptr to resulting network info.
    NULL on failure.

--*/
{
    PDNS_NETINFO    pnetInfo;
    IP4_ARRAY       ipArray;
    PIP4_ARRAY      parray = pDnsServers;   
    PSEARCH_LIST    psearchList;
    PWSTR           pdomainName;
    DWORD           flags = 0;

    //
    //  DCR:  eliminate search list form this routine
    //      i believe this routine is only used for query of
    //      FQDNs (usually in update) and doesn't require
    //      any default search info
    //
    //  DCR:  possibly combine with "BuildForUpdate" routine
    //      where search info included tacks this on
    //

    //
    //  if given single IP, ONLY use it
    //

    if ( ServerIp )
    {
        ipArray.AddrCount = 1;
        ipArray.AddrArray[0] = ServerIp;
        parray = &ipArray;
    }

    //
    //  convert server IPs into network info blob
    //      - simply use update function above to avoid duplicate code
    //

    pnetInfo = NetInfo_CreateForUpdateIp4(
                    NULL,           // no zone
                    NULL,           // no server name
                    parray,
                    0               // no flags
                    );
    if ( !pnetInfo )
    {
        return( NULL );
    }

    //
    //  get search list and primary domain info
    //      - copy from passed in network info
    //          OR
    //      - cut directly out of new netinfo
    //

    if ( fSearchInfo )
    {
        if ( pNetInfo )
        {
            flags       = pNetInfo->InfoFlags;
            psearchList = SearchList_Copy( pNetInfo->pSearchList );
            pdomainName = Dns_CreateStringCopy_W( pNetInfo->pszDomainName );
        }
        else
        {
            PDNS_NETINFO    ptempNetInfo = GetNetworkInfo();
    
            if ( ptempNetInfo )
            {
                flags       = ptempNetInfo->InfoFlags;
                psearchList = ptempNetInfo->pSearchList;
                pdomainName = ptempNetInfo->pszDomainName;
    
                ptempNetInfo->pSearchList = NULL;
                ptempNetInfo->pszDomainName = NULL;
                NetInfo_Free( ptempNetInfo );
            }
            else
            {
                psearchList = NULL;
                pdomainName = NULL;
            }
        }

        //  plug search info into new netinfo blob

        pnetInfo->pSearchList   = psearchList;
        pnetInfo->pszDomainName = pdomainName;
        pnetInfo->InfoFlags    |= (flags & NINFO_FLAG_DUMMY_SEARCH_LIST);
    }
    
    return( pnetInfo );
}
#endif



//
//  NetInfo building utilities
//
//  DNS server reachability routines
//
//  These are used to build netinfo that has unreachable DNS
//  servers screened out of the list.
//

BOOL
IsReachableDnsServer(
    IN      PDNS_NETINFO    pNetInfo,
    IN      PDNS_ADAPTER    pAdapter,
    IN      IP4_ADDRESS     Ip4Addr
    )
/*++

Routine Description:

    Determine if DNS server is reachable.

Arguments:

    pNetInfo -- network info blob

    pAdapter -- struct with list of DNS servers

    Ip4Addr -- DNS server address to test for reachability

Return Value:

    TRUE if DNS server is reachable.
    FALSE otherwise.

--*/
{
    DWORD       interfaceIndex;
    DNS_STATUS  status;

    DNSDBG( NETINFO, (
        "Enter IsReachableDnsServer( %p, %p, %08x )\n",
        pNetInfo,
        pAdapter,
        Ip4Addr ));

    DNS_ASSERT( pNetInfo && pAdapter );

    //
    //  DCR:  should do reachablity once on netinfo build
    //
    //  DCR:  reachability test can be smarter
    //      - reachable if same subnet as adapter IP
    //      question:  multiple IPs?
    //      - reachable if same subnet as previous reachable IP
    //      question:  can tell if same subnet?
    //
    //  DCR:  reachability on multi-homed connected
    //      - if send on another interface, does that interface
    //      "seem" to be connected
    //      probably see if
    //          - same subnet as this inteface
    //          question:  multiple IPs
    //          - or share DNS servers in common
    //          question:  just let server go, this doesn't work if
    //          the name is not the same
    //


    //
    //  if only one interface, assume reachability
    //

    if ( pNetInfo->AdapterCount <= 1 )
    {
        DNSDBG( SEND, (
            "One interface, assume reachability!\n" ));
        return( TRUE );
    }

    //
    //  check if server IP is reachable on its interface
    //

    status = IpHelp_GetBestInterface(
                Ip4Addr,
                & interfaceIndex );

    if ( status != NO_ERROR )
    {
        DNS_ASSERT( FALSE );
        DNSDBG( ANY, (
            "GetBestInterface() failed! %d\n",
            status ));
        return( TRUE );
    }

    if ( pAdapter->InterfaceIndex != interfaceIndex )
    {
        DNSDBG( NETINFO, (
            "IP %s on interface %d is unreachable!\n"
            "\tsend would be on interface %d\n",
            IP_STRING( Ip4Addr ),
            pAdapter->InterfaceIndex,
            interfaceIndex ));

        return( FALSE );
    }

    return( TRUE );
}



BOOL
IsDnsReachableOnAlternateInterface(
    IN      PDNS_NETINFO    pNetInfo,
    IN      DWORD           InterfaceIndex,
    IN      PDNS_ADDR       pAddr
    )
/*++

Routine Description:

    Determine if IP address is reachable on adapter.

    This function determines whether DNS IP can be reached
    on the interface that the stack indicates, when that
    interface is NOT the one containing the DNS server.

    We need this so we catch the multi-homed CONNECTED cases
    where a DNS server is still reachable even though the
    interface the stack will send on is NOT the interface for
    the DNS server.

Arguments:

    pNetInfo -- network info blob

    Interface -- interface stack will send to IP on

    pAddr -- DNS server address to test for reachability

Return Value:

    TRUE if DNS server is reachable.
    FALSE otherwise.

--*/
{
    PDNS_ADAPTER    padapter = NULL;
    PDNS_ADDR_ARRAY pserverArray;
    DWORD           i;
    PIP4_ARRAY      pipArray;
    PIP4_ARRAY      psubnetArray;
    DWORD           ipCount;
    IP4_ADDRESS     ip4;

    DNSDBG( NETINFO, (
        "Enter IsDnsReachableOnAlternateInterface( %p, %d, %08x )\n",
        pNetInfo,
        InterfaceIndex,
        pAddr ));

    //
    //  find DNS adapter for interface
    //

    for( i=0; i<pNetInfo->AdapterCount; i++ )
    {
        padapter = NetInfo_GetAdapterByIndex( pNetInfo, i );

        if ( padapter->InterfaceIndex != InterfaceIndex )
        {
            padapter = NULL;
            continue;
        }
        break;
    }

    if ( !padapter )
    {
        DNSDBG( ANY, (
            "WARNING:  indicated send inteface %d NOT in netinfo!\n",
            InterfaceIndex ));
        return  FALSE;
    }

    //
    //  success conditions:
    //      1)  DNS IP matches IP of DNS server for send interface
    //      2)  DNS IP is on subnet of IP of send interface
    //      3)  DNS IP4 is same default class subnet of send interface
    //
    //  if either of these is TRUE then either
    //      - there is misconfiguration (not our problem)
    //      OR
    //      - there's a somewhat unlikely condition of a default network address
    //      being subnetted in such a way that it appears on two adapters for
    //      the machine but is not connected and routeable
    //      OR
    //      - these interfaces are connected and we can safely send on them
    //
    //
    //  #3 is the issue of multiple adapters in the same (corporate) name space
    //  example:
    //      adapter 1 -- default gateway
    //          IP  157.59.1.1
    //          DNS 158.10.1.1
    //
    //      adapter 2
    //          IP  157.59.7.9
    //          DNS 159.65.7.8 -- send interface adapter 1
    //
    //      adapter 3
    //          IP  159.57.12.3
    //          DNS 157.59.134.7 -- send interface adapter 1
    //
    //      adapter 4
    //          IP  196.12.13.3
    //          DNS 200.59.73.2
    //
    //  From GetBestInterface, adapter 1, (default gateway) is given as send interface
    //  for adapter 2 and 3's DNS servers.
    //
    //  For adapter #2, it's DNS is NOT in adapter1's list, but it's IP shares the same
    //  class B network as adapter 1.  It is unlikely that the subnetting is such that
    //  it's DNS is not reachable through adapter 1.
    //
    //  For adapter #3, it's DNS is NOT in adapter1's list, but it's DNS is on the same
    //  class B network as adapter 1's interface.  Again it's extremely unlikely it is
    //  not reachable.
    //
    //  For adapter #4, however, it's plain that there's no connection.  Neither it's IP
    //  nor DNS share default network with adapter 1.   So send -- which will go out -- adapter
    //  #1 has a high likelyhood of being to a disjoint network and being unreturnable.
    //
    //


    if ( DnsAddrArray_ContainsAddr(
            padapter->pDnsAddrs,
            pAddr,
            DNSADDR_MATCH_ADDR ) )
    {
        DNSDBG( NETINFO, (
            "DNS server %p also DNS server on send interface %d\n",
            pAddr,
            InterfaceIndex ));
        return( TRUE );
    }

    //
    //  DCR:  should do subnet matching on IPs
    //      if DNS server is for one interface with IP on same subnet as IP
    //      of the interface you'll send on, then it should be kosher
    //

    //
    //  test for subnet match for IP4 addrs
    //
    //  FIX6:  subnet matching fixup for new subnet info
    //  DCR:  encapsulate subnet matching -- local subnet test
    //
    //  FIX6:  local subnet matching on IP6
    //      

#if SUB4NET
    ip4 = DnsAddr_GetIp4( pAddr );
    if ( ip4 != BAD_IP4_ADDR )
    {
        pipArray = padapter->pIp4Addrs;
        psubnetArray = padapter->pIp4SubnetMasks;
    
        if ( !pipArray ||
             !psubnetArray ||
             (ipCount = pipArray->AddrCount) != psubnetArray->AddrCount )
        {
            DNSDBG( ANY, ( "WARNING:  missing or invalid interface IP\\subnet info!\n" ));
            DNS_ASSERT( FALSE );
            return( FALSE );
        }
    
        for ( i=0; i<ipCount; i++ )
        {
            IP4_ADDRESS subnet = psubnetArray->AddrArray[i];
    
            if ( (subnet & ip4) == (subnet & pipArray->AddrArray[i]) )
            {
                DNSDBG( NETINFO, (
                    "DNS server %08x on subnet of IP for send interface %d\n"
                    "\tip = %08x, subnet = %08x\n",
                    ip4,
                    InterfaceIndex,
                    pipArray->AddrArray[i],
                    subnet ));
    
                return( TRUE );
            }
        }
    }
#endif

    return( FALSE );
}



DNS_STATUS
StrikeOutUnreachableDnsServers(
    IN OUT  PDNS_NETINFO    pNetInfo
    )
/*++

Routine Description:

    Eliminate unreachable DNS servers from the list.

Arguments:

    pNetInfo    -- DNS netinfo to fix up

Return Value:

    ERROR_SUCCESS if successful

--*/
{
    DNS_STATUS      status;
    DWORD           validServers;
    PDNS_ADAPTER    padapter;
    PDNS_ADDR_ARRAY pserverArray;
    DWORD           adapterIfIndex;
    DWORD           serverIfIndex;
    DWORD           i;
    DWORD           j;


    DNSDBG( NETINFO, (
        "Enter StrikeOutUnreachableDnsServers( %p )\n",
        pNetInfo ));

    DNS_ASSERT( pNetInfo );

    //
    //  if only one interface, assume reachability
    //

    if ( pNetInfo->AdapterCount <= 1 )
    {
        DNSDBG( NETINFO, (
            "One interface, assume reachability!\n" ));
        return( TRUE );
    }

    //
    //  loop through adapters
    //

    for( i=0; i<pNetInfo->AdapterCount; i++ )
    {
        BOOL    found4;
        BOOL    found6;
        BOOL    found6NonDefault;

        padapter = NetInfo_GetAdapterByIndex( pNetInfo, i );

        //  ignore this adapter because there are no DNS
        //      servers configured?

        if ( padapter->InfoFlags & AINFO_FLAG_IGNORE_ADAPTER )
        {
            continue;
        }

        //
        //  test all adapter's DNS servers for reachability
        //      
        //  note:  currently save no server specific reachability,
        //      so if any server reachable, proceed;
        //  also if iphelp fails just assume reachability and proceed,
        //      better timeouts then not reaching server we can reach
        //

        adapterIfIndex = padapter->InterfaceIndex;
        validServers = 0;

        //
        //  FIX6:  need GetBestInteface for IP6
        //

        found4 = FALSE;
        found6 = FALSE;
        found6NonDefault = FALSE;

        pserverArray = padapter->pDnsAddrs;

        for ( j=0; j<pserverArray->AddrCount; j++ )
        {
            PDNS_ADDR       paddr = &pserverArray->AddrArray[j];
            IP4_ADDRESS     ip4;

            ip4 = DnsAddr_GetIp4( paddr );

            //
            //  IP6
            //

            if ( ip4 == BAD_IP4_ADDR )
            {
                found6 = TRUE;

                if ( !DnsAddr_IsIp6DefaultDns( paddr ) )
                {
                    found6NonDefault = TRUE;
                }
                continue;
            }

            //
            //  IP4 server
            //

            found4 = TRUE;
            serverIfIndex = 0;      // prefix happiness

            status = IpHelp_GetBestInterface(
                            ip4,
                            & serverIfIndex );
        
            if ( status == ERROR_NETWORK_UNREACHABLE )
            {
                DNSDBG( NETINFO, (
                    "GetBestInterface() NETWORK_UNREACH for server %s\n",
                    IP_STRING(ip4) ));
                continue;
            }

            if ( status != NO_ERROR )
            {
                DNSDBG( ANY, (
                    "GetBestInterface() failed! %d\n",
                    status ));
                //DNS_ASSERT( FALSE );
                validServers++;
                break;
                //continue;
            }

            //  server is reachable
            //      - queried on its adapter?
            //      - reachable through loopback
            //
            //  DCR:  tag unreachable servers individually

            if ( serverIfIndex == adapterIfIndex ||
                 serverIfIndex == 1 )
            {
                validServers++;
                break;
                //continue;
            }

            //  server can be reached on query interface

            if ( IsDnsReachableOnAlternateInterface(
                    pNetInfo,
                    serverIfIndex,
                    paddr ) )
            {
                validServers++;
                break;
                //continue;
            }
        }

        //
        //  mark adapter if no reachable servers found
        //
        //  => if no servers or IP4 tested and failed, ignore the adapter
        //  => if only IP6 default server, mark, we'll use but not
        //      continue on adapter after NAME_ERROR
        //  => 
        //      
        //      - any IP6 will be considered "found" (until get explicit test)
        //      BUT if we test IP4 on that interface, then it's status wins
        //
        //  DCR:  alternative to ignoring unreachable
        //      - tag as unreachable
        //      - don't send to it on first pass
        //      - don't continue name error on unreachable
        //          (it would count as "heard from" when send.c routine
        //          works back through)

        if ( validServers == 0 )
        {
            if ( found4 || !found6 )
            {
                padapter->InfoFlags |= (AINFO_FLAG_IGNORE_ADAPTER |
                                        AINFO_FLAG_SERVERS_UNREACHABLE);
                DNSDBG( NETINFO, (
                    "No reachable servers on interface %d\n"
                    "\tthis adapter (%p) ignored in DNS list!\n",
                    adapterIfIndex,
                    padapter ));
            }
            else if ( !found6NonDefault )
            {
                padapter->InfoFlags |= AINFO_FLAG_SERVERS_IP6_DEFAULT;

                DNSDBG( NETINFO, (
                    "Only IP6 default servers on interface %d\n"
                    "\twill not continue on this adapter after response.\n",
                    adapterIfIndex,
                    padapter ));
            }
        }
    }

    return  ERROR_SUCCESS;
}



//
//  Network info caching\state routines
//

BOOL
InitNetworkInfo(
    VOID
    )
/*++

Routine Description:

    Initialize network info.

Arguments:

    None

Return Value:

    None

--*/
{
    //
    //  standard up-n-running path -- allows cheap runtime check
    //

    if ( g_NetInfoCacheLockInitialized &&
         g_NetInfoBuildLockInitialized )
    {
        return  TRUE;
    }

    //
    //  if netinfo not initialzied
    //

    LOCK_GENERAL();

    g_pNetInfo = NULL;

    if ( !g_NetInfoCacheLockInitialized )
    {
        g_NetInfoCacheLockInitialized =
            ( RtlInitializeCriticalSection( &g_NetInfoCacheLock ) == NO_ERROR );
    }
    
    if ( !g_NetInfoBuildLockInitialized )
    {
        g_NetInfoBuildLockInitialized =
            ( TimedLock_Initialize( &g_NetInfoBuildLock, 5000 ) == NO_ERROR );
    }

    UNLOCK_GENERAL();

    return  ( g_NetInfoCacheLockInitialized && g_NetInfoBuildLockInitialized );
}


VOID
CleanupNetworkInfo(
    VOID
    )
/*++

Routine Description:

    Initialize network info.

Arguments:

    None

Return Value:

    None

--*/
{
    LOCK_GENERAL();

    NetInfo_MarkDirty();

    if ( g_NetInfoBuildLockInitialized )
    {
        TimedLock_Cleanup( &g_NetInfoBuildLock );
    }
    if ( g_NetInfoCacheLockInitialized )
    {
        DeleteCriticalSection( &g_NetInfoCacheLock );
    }

    UNLOCK_GENERAL();
}



//
//  Read config from resolver
//

PDNS_NETINFO         
UpdateDnsConfig(
    VOID
    )
/*++

Routine Description:

    Update DNS configuration.

    This includes entire config
        - flat registry DWORD\BOOL globals
        - netinfo list

Arguments:

    None

Return Value:

    Ptr to network info blob.

--*/
{
    DNS_STATUS          status = ERROR_SUCCESS;
    PDNS_NETINFO        pnetworkInfo = NULL;
    PDNS_GLOBALS_BLOB   pglobalsBlob = NULL;

    DNSDBG( TRACE, ( "UpdateDnsConfig()\n" ));


    //  DCR_CLEANUP:  RPC TryExcept should be in RPC client library

    RpcTryExcept
    {
        R_ResolverGetConfig(
            NULL,               // default handle
            g_ConfigCookie,
            & pnetworkInfo,
            & pglobalsBlob
            );
    }
    RpcExcept( DNS_RPC_EXCEPTION_FILTER )
    {
        status = RpcExceptionCode();
    }
    RpcEndExcept

    if ( status != ERROR_SUCCESS )
    {
        DNSDBG( RPC, (
            "R_ResolverGetConfig()  RPC failed status = %d\n",
            status ));
        return  NULL;
    }

    //
    //  DCR:  save other config info here
    //      - flat memcpy of DWORD globals
    //      - save off cookie (perhaps include as one of them
    //      - save global copy of pnetworkInfo?
    //          (the idea being that we just copy it if
    //          RPC cookie is valid)
    //
    //      - maybe return flags?
    //          memcpy is cheap but if more expensive config
    //          then could alert what needs update?
    //

    //
    //  DCR:  once move, single "update global network info"
    //      then call it here to save global copy
    //      but global copy doesn't do much until RPC fails
    //      unless using cookie
    //


    //  QUESTION:  not sure about forcing global build here
    //      q:  is this to be "read config" all
    //          or just "update config" and then individual
    //          routines for various pieces of config can
    //          determine what to do?
    //
    //      note, doing eveything is fine if going to always
    //      read entire registry on cache failure;  if so
    //      reasonable to push here
    //
    //      if cache-on required for "real time" config, then
    //      should protect registry DWORD read with reasonable time
    //      (say read every five\ten\fifteen minutes?)
    //
    //      perhaps NO read here, but have DWORD reg read update
    //      routine that called before registry reread when
    //      building adapter list in registry;  then skip this
    //      step in cache
    //

    //
    //  copy in config
    //

    if ( pglobalsBlob )
    {
        RtlCopyMemory(
            & DnsGlobals,
            pglobalsBlob,
            sizeof(DnsGlobals) );

        MIDL_user_free( pglobalsBlob );
    }
    
    IF_DNSDBG( RPC )
    {
        DnsDbg_NetworkInfo(
            "Network Info returned from cache:",
            pnetworkInfo );
    }

    return  pnetworkInfo;
}



//
//  Public netinfo routine
//

PDNS_NETINFO     
NetInfo_Get(
    IN      DWORD           Flag,
    IN      DWORD           AcceptLocalCacheTime   OPTIONAL
    )
/*++

Routine Description:

    Read DNS network info from registry.

    This is in process, limited caching version.
    Note, this is macro'd as GetNetworkInfo() with parameters
        NetInfo_Get( FALSE, TRUE ) throughout dnsapi code.

Arguments:

    Flag -- flag;  read order and IP
        NIFLAG_GET_LOCAL_ADDRS
        NIFLAG_FORCE_REGISTRY_READ
        NIFLAG_READ_RESOLVER_FIRST
        NIFLAG_READ_RESOLVER
        NIFLAG_READ_PROCESS_CACHE

    AcceptLocalCacheTime -- acceptable cache time on in process copy

Return Value:

    ERROR_SUCCESS if successful.
    Error code on failure.

--*/
{
    PDNS_NETINFO    pnetInfo = NULL;
    PDNS_NETINFO    poldNetInfo = NULL;
    BOOL            fcacheLock = FALSE;
    BOOL            fbuildLock = FALSE;
    BOOL            fcacheable = TRUE;

    DNSDBG( NETINFO, (
        "NetInfo_Get( %08x, %d )\n",
        Flag,
        AcceptLocalCacheTime ));

    //
    //  init netinfo locks\caching
    //

    if ( !InitNetworkInfo() )
    {
        return  NULL;
    }

    //
    //  get netinfo from one of several sources
    //  try
    //      - very recent local cached copy
    //      - RPC copy from resolver
    //      - build new
    //
    //  note the locking model
    //  two SEPARATE locks
    //      - cache lock, for very quick, very local access
    //      to cached copy
    //      - build lock, for remote process access to cached (resolver)
    //      or newly built netinfo
    //
    //  the locking hierarchy
    //      - build lock
    //      - cache lock (maybe taken inside build lock)
    //
    //
    //  Locking implementation note:
    //
    //  The reason for the two locks is that when calling down for netinfo
    //  build it is possible to have a circular dependency.
    //
    //  Here's the deadlock scenario if we have a single lock handling
    //  build and caching:
    //  -   call into resolver and down to iphlpapi
    //  -   iphlpapi RPC's into MPR (router service)
    //  -   RtrMgr calls GetHostByName() which ends up in a
    //      iphlpapi!GetBestInterface call which in turn calls
    //      Mprapi!IsRouterRunning (which is an RPC to mprdim).
    //  -   Mprdim is blocked on a CS which is held by a thread waiting
    //      for a demand-dial disconnect to complete - this is completely
    //      independent of 1.
    //  -   Demand-dial disconnect is waiting for ppp to finish graceful
    //      termination.
    //  -   PPP is waiting for dns to return from DnsSetConfigDword
    //  -   DnsSetConfigDword, sets, alerts the cache, then calls
    //      NetInfo_MarkDirty()
    //  -   NetInfo_MarkDirty() is waiting on CS to access the netinfo global.
    //
    //  Now, this could be avoided by changing MarkDirty() to safely set some
    //  dirty bit (interlock).  The build function would have to check the bit
    //  and go down again if it was set.
    //
    //  However, there'd still be a chance that the call down to iphlpapi, could
    //  depend under some odd circumstance on some service that came back through
    //  the resolver.  And the bottom line is that the real distinction is not
    //  between caching and marking cache dirty.  It's between completely local
    //  cache get\set\clear activity, which can be safely overloaded on the general CS,
    //  AND the longer time, multi-service dependent building operation.  So
    //  separate CS for both is correct.
    //


    if ( !(Flag & NIFLAG_FORCE_REGISTRY_READ)
            &&
         !g_DnsTestMode )
    {
        //
        //  RPC to resolver
        //

        if ( Flag & NIFLAG_READ_RESOLVER_FIRST )
        {
            //  DCR:  this could present "cookie" of existing netinfo
            //      and only get new if "cookie" is old, though the
            //      cost of that versus local copy seems small since
            //      still must do RPC and allocations -- only the copy
            //      for RPC on the resolver side is saved
    
            fbuildLock = LOCK_NETINFO_BUILD();
            if ( !fbuildLock )
            {
                goto Unlock;
            }

            pnetInfo = UpdateDnsConfig();
            if ( pnetInfo )
            {
                DNSDBG( TRACE, (
                    "Netinfo read from resolver.\n" ));
                goto CacheCopy;
            }
        }

        //
        //  use in-process cached copy?
        //

        if ( Flag & NIFLAG_READ_PROCESS_CACHE )
        {
            DWORD   timeout = NETINFO_CACHE_TIMEOUT;

            LOCK_NETINFO_CACHE();
            fcacheLock = TRUE;
    
            if ( AcceptLocalCacheTime )
            {
                timeout = AcceptLocalCacheTime;
            }

            //  check if valid copy cached in process
    
            if ( g_pNetInfo &&
                (g_pNetInfo->TimeStamp + timeout > Dns_GetCurrentTimeInSeconds()) )
            {
                pnetInfo = NetInfo_Copy( g_pNetInfo );
                if ( pnetInfo )
                {
                    DNSDBG( TRACE, (
                        "Netinfo found in process cache.\n" ));
                    goto Unlock;
                }
            }

            UNLOCK_NETINFO_CACHE();
            fcacheLock = FALSE;
        }

        //
        //  last chance on resolver
        //

        if ( !fbuildLock && (Flag & NIFLAG_READ_RESOLVER) )
        {
            fbuildLock = LOCK_NETINFO_BUILD();
            if ( !fbuildLock )
            {
                goto Unlock;
            }

            pnetInfo = UpdateDnsConfig();
            if ( pnetInfo )
            {
                DNSDBG( TRACE, (
                    "Netinfo read from resolver.\n" ));
                goto CacheCopy;
            }
        }
    }

    //
    //  build fresh network info
    //

    DNS_ASSERT( !fcacheLock );

    if ( !fbuildLock )
    {
        fbuildLock = LOCK_NETINFO_BUILD();
        if ( !fbuildLock )
        {
            goto Unlock;
        }
    }

    fcacheable = (Flag & NIFLAG_GET_LOCAL_ADDRS);

    pnetInfo = NetInfo_Build( fcacheable );
    if ( !pnetInfo )
    {
        goto Unlock;
    }

CacheCopy:

    //
    //  update cached copy
    //      - but not if built without local IPs;
    //      resolver copy always contains local IPs
    //

    if ( fcacheable )
    {
        if ( !fcacheLock )
        {
            LOCK_NETINFO_CACHE();
            fcacheLock = TRUE;
        }
        poldNetInfo = g_pNetInfo;
        g_pNetInfo = NetInfo_Copy( pnetInfo );
    }


Unlock:

    if ( fcacheLock )
    {
        UNLOCK_NETINFO_CACHE();
    }
    if ( fbuildLock )
    {
        UNLOCK_NETINFO_BUILD();
    }

    NetInfo_Free( poldNetInfo );

    DNSDBG( TRACE, (
        "Leave:  NetInfo_Get( %p )\n",
        pnetInfo ));

    return( pnetInfo );
}



VOID
NetInfo_MarkDirty(
    VOID
    )
/*++

Routine Description:

    Mark netinfo dirty so force reread.

Arguments:

    None

Return Value:

    None

--*/
{
    PDNS_NETINFO    pold;

    DNSDBG( NETINFO, ( "NetInfo_MarkDirty()\n" ));


    //
    //  init netinfo locks\caching
    //

    if ( !InitNetworkInfo() )
    {
        return;
    }

    //
    //  dump global network info to force reread
    //
    //  since the resolve is always notified by DnsSetDwordConfig()
    //  BEFORE entering this function, the resolve should always be
    //  providing before we are in this function;  all we need to do
    //  is insure that cached copy is dumped
    //

    LOCK_NETINFO_CACHE();

    pold = g_pNetInfo;
    g_pNetInfo = NULL;

    UNLOCK_NETINFO_CACHE();

    NetInfo_Free( pold );
}



PDNS_NETINFO     
NetInfo_Build(
    IN      BOOL            fGetIpAddrs
    )
/*++

Routine Description:

    Build network info blob from registry.

    This is the FULL recreate function.

Arguments:

    fGetIpAddrs -- TRUE to include local IP addrs for each adapter
        (currently ignored -- always get all the info)

Return Value:

    ERROR_SUCCESS if successful.
    Error code on failure.

--*/
{
    REG_SESSION             regSession;
    PREG_SESSION            pregSession = NULL;
    PDNS_NETINFO            pnetInfo = NULL;
    PDNS_ADAPTER            pdnsAdapter = NULL;
    DNS_STATUS              status = NO_ERROR;
    DWORD                   count;
    DWORD                   createdAdapterCount = 0;
    BOOL                    fuseIp;
    PIP_ADAPTER_ADDRESSES   padapterList = NULL;
    PIP_ADAPTER_ADDRESSES   padapter = NULL;
    DWORD                   value;
    PREG_GLOBAL_INFO        pregInfo = NULL;
    REG_GLOBAL_INFO         regInfo;
    REG_ADAPTER_INFO        regAdapterInfo;
    DWORD                   flag;
    BOOL                    fhaveDnsServers = FALSE;


    DNSDBG( TRACE, ( "\n\n\nNetInfo_Build()\n\n" ));

    //
    //  open the registry
    //

    pregSession = &regSession;

    status = Reg_OpenSession(
                pregSession,
                0,
                0 );
    if ( status != ERROR_SUCCESS )
    {
        status = DNS_ERROR_NO_DNS_SERVERS;
        goto Cleanup;
    }

    //
    //  read global registry info
    //

    pregInfo = &regInfo;

    status = Reg_ReadGlobalInfo(
                pregSession,
                pregInfo
                );
    if ( status != ERROR_SUCCESS )
    {
        status = DNS_ERROR_NO_DNS_SERVERS;
        goto Cleanup;
    }

    //
    //  get adapter\address info from IP help
    //
    //  note:  always getting IP addresses
    //      - for multi-adapter need for routing
    //      - need for local lookups
    //          (might as well just include)
    //
    //  DCR:  could skip include when RPCing to client for
    //      query\update that does not require
    //

    flag = GAA_FLAG_SKIP_ANYCAST | GAA_FLAG_SKIP_MULTICAST;
#if 0
    if ( !fGetIpAddrs )
    {
        flag |= GAA_FLAG_SKIP_UNICAST;
    }
#endif

    padapterList = IpHelp_GetAdaptersAddresses(
                        PF_UNSPEC,
                        flag );
    if ( !padapterList )
    {
        status = GetLastError();
        DNS_ASSERT( status != NO_ERROR );
        goto Cleanup;
    }

    //  count up the active adapters

    padapter = padapterList;
    count = 0;

    while ( padapter )
    {
        count++;
        padapter = padapter->Next;
    }

    //
    //  allocate net info blob
    //  allocate DNS server IP array
    //

    pnetInfo = NetInfo_Alloc( count );
    if ( !pnetInfo )
    {
        status = DNS_ERROR_NO_MEMORY;
        goto Cleanup;
    }

    //
    //  loop through adapters -- build network info for each
    //

    padapter = padapterList;

    while ( padapter )
    {
        DWORD           adapterFlags = 0;
        PWSTR           pnameAdapter = NULL;
        PWSTR           padapterDomainName = NULL;
        PDNS_ADDR_ARRAY pserverArray = NULL;
        PDNS_ADDR_ARRAY plocalArray = NULL;

        //
        //  read adapter registry info
        //
        //  DCR:  can skip adapter domain name read
        //      it's in IP help adapter, just need policy override
        //  DCR:  can skip DDNS read, and register read
        //      again, except for policy overrides
        //
        //  DCR:  could just have an "ApplyPolicyOverridesToAdapterInfo()" sort
        //      of function and get the rest from 
        //

        pnameAdapter = Dns_StringCopyAllocate(
                            padapter->AdapterName,
                            0,
                            DnsCharSetAnsi,
                            DnsCharSetUnicode );
        if ( !pnameAdapter )
        {
            status = DNS_ERROR_NO_MEMORY;
            goto Cleanup;
        }

        status = Reg_ReadAdapterInfo(
                    pnameAdapter,
                    pregSession,
                    & regInfo,          // policy adapter info
                    & regAdapterInfo    // receives reg info read
                    );

        if ( status != NO_ERROR )
        {
            status = Reg_DefaultAdapterInfo(
                        & regAdapterInfo,
                        & regInfo,
                        padapter );

            if ( status != NO_ERROR )
            {
                DNS_ASSERT( FALSE );
                goto Skip;
            }
        }

        //  translate results into flags

        if ( regAdapterInfo.fRegistrationEnabled )
        {
            adapterFlags |= AINFO_FLAG_REGISTER_IP_ADDRESSES;
        }
        if ( regAdapterInfo.fRegisterAdapterName )
        {
            adapterFlags |= AINFO_FLAG_REGISTER_DOMAIN_NAME;
        }

        //  use domain name?
        //      - if disable on per adapter basis, then it's dead

        if ( regAdapterInfo.fQueryAdapterName )
        {
            padapterDomainName = regAdapterInfo.pszAdapterDomainName;
            regAdapterInfo.pszAdapterDomainName = NULL;
        }

        //  DCR:  could get DDNS and registration for adapter 

        //  set flag on DHCP adapters

        if ( padapter->Flags & IP_ADAPTER_DHCP_ENABLED )
        {
            adapterFlags |= AINFO_FLAG_IS_DHCP_CFG_ADAPTER;
        }

        //
        //  get adapter's IP addresses
        //

        fuseIp = fGetIpAddrs;
        if ( fuseIp )
        {
            status = IpHelp_ReadAddrsFromList(
                        padapter->FirstUnicastAddress,
                        TRUE,               // unicast addrs
                        0,                  // no screening
                        0,                  // no screening
                        & plocalArray,      // local addrs
                        NULL,               // IP6 only
                        NULL,               // IP4 only
                        NULL,               // no IP6 count
                        NULL                // no IP4 count
                        );
            if ( status != NO_ERROR )
            {
                goto Cleanup;
            }
        }

#if 0
        //
        //  get per-adapter information from the iphlpapi.dll.
        //      -- autonet
        //
        //  FIX6:  do we need autonet info?

        pserverArray = NULL;

        status = IpHelp_GetPerAdapterInfo(
                        padapter->Index,
                        & pperAdapterInfo );

        if ( status == NO_ERROR )
        {
            if ( pperAdapterInfo->AutoconfigEnabled &&
                 pperAdapterInfo->AutoconfigActive )
            {
                adapterFlags |= AINFO_FLAG_IS_AUTONET_ADAPTER;
            }
        }
#endif

        //
        //  build DNS list
        //

        if ( padapter->FirstDnsServerAddress )
        {
            status = IpHelp_ReadAddrsFromList(
                        padapter->FirstDnsServerAddress,
                        FALSE,              // not unicast addrs
                        0,                  // no screening
                        0,                  // no screening
                        & pserverArray,     // get combined list
                        NULL,               // no IP6 only
                        NULL,               // no IP4 only
                        NULL,               // no IP6 count
                        NULL                // no IP4 count
                        );
            if ( status != NO_ERROR )
            {
                goto Cleanup;
            }

            fhaveDnsServers = TRUE;
        }
        else
        {
#if 0
            //
            //  note:  this feature doesn't work very well
            //      it kicks in when cable unplugged and get into auto-net
            //      scenario ... and then can bring in an unconfigured
            //      DNS server and give us long timeouts
            //
            //  DCR:  pointing to local DNS server
            //      a good approach would be to point to local DNS on ALL
            //      adapters when we fail to find ANY DNS servers at all
            //

            //
            //  if no DNS servers found -- use loopback if on DNS server
            //

            if ( g_IsDnsServer )
            {
                pserverArray = DnsAddrArray_Create( 1 );
                if ( !pserverArray )
                {
                    goto Skip;
                }
                DnsAddrArray_InitSingleWithIp4(
                    pserverArray,
                    DNS_NET_ORDER_LOOPBACK );
            }
#endif
        }

        //
        //  build adapter info
        //
        //  optionally add IP and subnet list;  note this is
        //  direct add of data (not alloc\copy) so clear pointers
        //  after to skip free
        //
        //  DCR:  no failure case on adapter create failure???
        //
        //  DCR:  when do we need non-server adapters? for mcast?
        //
        //  DCR:  we could create Adapter name in unicode (above) then
        //          just copy it in;
        //  DCR:  could preserve adapter domain name in blob, and NULL
        //          out the string in regAdapterInfo 
        //

        if ( pserverArray || plocalArray )
        {
            PDNS_ADAPTER pnewAdapter = &pnetInfo->AdapterArray[ createdAdapterCount ];

            AdapterInfo_Init(
                pnewAdapter,
                TRUE,           // zero init
                adapterFlags,
                pnameAdapter,
                padapterDomainName,
                plocalArray,
                pserverArray
                );

            pnewAdapter->InterfaceIndex = padapter->IfIndex;

            pnetInfo->AdapterCount = ++createdAdapterCount;

            pnameAdapter = NULL;
            padapterDomainName = NULL;
            plocalArray = NULL;
            pserverArray = NULL;
        }

Skip:
        //
        //  cleanup adapter specific data
        //
        //  note:  no free of pserverArray, it IS the
        //      ptempArray buffer that we free at the end
        //

        Reg_FreeAdapterInfo(
            &regAdapterInfo,
            FALSE               // don't free blob, it is on stack
            );

        if ( pnameAdapter );
        {
            FREE_HEAP( pnameAdapter );
        }
        if ( padapterDomainName );
        {
            FREE_HEAP( padapterDomainName );
        }
        if ( pserverArray );
        {
            DnsAddrArray_Free( pserverArray );
        }
        if ( plocalArray )
        {
            DnsAddrArray_Free( plocalArray );
        }

        //  get next adapter
        //  reset status, so failure on the last adapter is not
        //      seen as global failure

        padapter = padapter->Next;

        status = ERROR_SUCCESS;
    }

    //
    //  no DNS servers?
    //      - use loopback if we are on MS DNS
    //      - otherwise note netinfo useless for lookup
    //
    //  when self-pointing:
    //      - setup all adapters so we preserve adapter domain names for lookup
    //      - mark adapters as auto-loopback;  send code will then avoid continuing
    //          query on other adapters
    //
    //  note, i specifically choose this approach rather than configuring on any
    //  serverless adapter even if other adapters have DNS servers
    //  this avoids two problems:
    //      - server is poorly configured but CAN answer and fast local resolution
    //      blocks resolution through real DNS servers
    //      - network edge scenarios where DNS may be out-facing, but DNS client
    //      resolution may be intentionally desired to be only internal (admin network)
    //  in both cases i don't want to "pop" local DNS into the mix when it is unintended.
    //  when it is intended the easy workaround is to configure it explicitly
    //

    if ( !fhaveDnsServers )
    {
        if ( g_IsDnsServer )
        {
            DWORD   i;

            for ( i=0; i<pnetInfo->AdapterCount; i++ )
            {
                PDNS_ADAPTER    padapt = NetInfo_GetAdapterByIndex( pnetInfo, i );
                PDNS_ADDR_ARRAY pserverArray = NULL;

                pserverArray = DnsAddrArray_Create( 1 );
                if ( !pserverArray )
                {
                    status = DNS_ERROR_NO_MEMORY;
                    goto Cleanup;
                }
                DnsAddrArray_InitSingleWithIp4(
                    pserverArray,
                    DNS_NET_ORDER_LOOPBACK );

                padapt->pDnsAddrs = pserverArray;
                padapt->InfoFlags &= ~AINFO_FLAG_IGNORE_ADAPTER;
                padapt->InfoFlags |= AINFO_FLAG_SERVERS_AUTO_LOOPBACK;
            }
        }
        else
        {
            pnetInfo->InfoFlags |= NINFO_FLAG_NO_DNS_SERVERS;
        }
    }

    //
    //  eliminate unreachable DNS servers
    //

    if ( g_ScreenUnreachableServers )
    {
        StrikeOutUnreachableDnsServers( pnetInfo );
    }

    //
    //  build search list for network info
    //      - skip if no active adapters found
    //
    //  DCR:  shouldn't build search list?
    //
    //  DCR:  only build if actually read search list 
    //

    if ( pnetInfo->AdapterCount )
    {
        pnetInfo->pSearchList = SearchList_Build(
                                        regInfo.pszPrimaryDomainName,
                                        pregSession,
                                        NULL,           // no explicit key
                                        pnetInfo,
                                        regInfo.fUseNameDevolution
                                        );
        if ( !pnetInfo->pSearchList )
        {
            status = DNS_ERROR_NO_MEMORY;
            goto Cleanup;
        }
    }

    //
    //  host and domain name info
    //

    pnetInfo->pszDomainName = Dns_CreateStringCopy_W( regInfo.pszPrimaryDomainName );
    pnetInfo->pszHostName = Dns_CreateStringCopy_W( regInfo.pszHostName );

    //  timestamp

    pnetInfo->TimeStamp = Dns_GetCurrentTimeInSeconds();

    //
    //  set default server priorities
    //

    NetInfo_ResetServerPriorities( pnetInfo, FALSE );


Cleanup:                                           

    //  free allocated reg info

    Reg_FreeGlobalInfo(
        pregInfo,
        FALSE       // don't free blob, it is on stack
        );

    if ( padapterList )
    {
        FREE_HEAP( padapterList );
    }
    if ( pnetInfo &&
         pnetInfo->AdapterCount == 0 )
    {
        status = DNS_ERROR_NO_DNS_SERVERS;
    }

    //  close registry session

    Reg_CloseSession( pregSession );

    if ( status != ERROR_SUCCESS )
    {
        NetInfo_Free( pnetInfo );

        DNSDBG( TRACE, (
            "Leave:  NetInfo_Build()\n"
            "\tstatus = %d\n",
            status ));

        SetLastError( status );
        return( NULL );
    }

    IF_DNSDBG( NETINFO2 )
    {
        DnsDbg_NetworkInfo(
            "New Netinfo:",
            pnetInfo );
    }

    DNSDBG( TRACE, (
        "\nLeave:  NetInfo_Build()\n\n\n"
        "\treturning fresh built network info (%p)\n",
        pnetInfo ));

    return( pnetInfo );
}



//
//  Local address list
//

DWORD
netinfo_AddrFlagForConfigFlag(
    IN      DWORD           ConfigFlag
    )
/*++

Routine Description:

    Build the DNS_ADDR flag for a given config flag.

Arguments:

    ConfigFlag -- config flag we're given.

Return Value:

    Flag in DNS_ADDR.  Note this covers only the bits in DNSADDR_FLAG_TYPE_MASK
    not the entire flag.

--*/
{
    DWORD   flag = 0;

    if ( ConfigFlag & DNS_CONFIG_FLAG_ADDR_PUBLIC )
    {
        flag |= DNSADDR_FLAG_PUBLIC;
    }

    if ( ConfigFlag & DNS_CONFIG_FLAG_ADDR_CLUSTER )
    {
        flag |= DNSADDR_FLAG_TRANSIENT;
    }

    return  flag;
}



BOOL
netinfo_LocalAddrScreen(
    IN      PDNS_ADDR       pAddr,
    IN      PDNS_ADDR       pScreenAddr
    )
/*++

Routine Description:

    Check DNS_ADDR against screening critera for local addr build.

Arguments:

    pAddr -- address to screen

    pScreenAddr -- screening info

Return Value:

    TRUE if local addr passes screen.
    FALSE otherwise.

--*/
{
    DWORD   family = DnsAddr_Family( pScreenAddr );
    DWORD   flags;

    //  screen family

    if ( family &&
         family != DnsAddr_Family(pAddr) )
    {
        return  FALSE;
    }

    //  screen flags
    //      - exact match on address type flag bits

    return  ( (pAddr->Flags & pScreenAddr->DnsAddrFlagScreeningMask)
                == pScreenAddr->Flags);
}



DNS_STATUS
netinfo_ReadLocalAddrs(
    IN OUT  PDNS_ADDR_ARRAY pAddrArray,
    IN      PDNS_NETINFO    pNetInfo,
    IN      PDNS_ADAPTER    pSingleAdapter,     OPTIONAL
    IN OUT  PDNS_ADDR       pScreenAddr,     
    IN      DWORD           AddrFlags,
    IN      DWORD           AddrMask,
    IN      DWORD           ReadCount
    )
/*++

Routine Description:

    Create IP array of DNS servers from network info.

Arguments:

    pAddrArray -- local address array being built

    pNetInfo -- DNS net adapter list to convert

    pSingleAdapter -- just do this one adapter

    pScreenAddr -- address screening blob;
        note:  there's no true OUT info, but the screen addr
        is altered to match AddrFlags

    AddrFlags -- addr flag we're interested in

    ReadCount -- count to read
        1 -- just one
        MAXDWORD -- all
        0 -- all on second pass

Return Value:

    NO_ERROR if successful.
    Otherwise error code from add.

--*/
{
    PDNS_ADDR_ARRAY     parray = NULL;
    PDNS_ADAPTER        padapter;
    DNS_STATUS          status = NO_ERROR;
    DWORD               dupFlag = 0;
    DWORD               screenMask;
    DWORD               iter;

    DNSDBG( TRACE, (
        "netinfo_ReadLocalAddrs( %p, %p, %p, %08x, %08x, %d )\n",
        pNetInfo,
        pSingleAdapter,
        pScreenAddr,
        AddrFlags,
        AddrMask,
        ReadCount ));

    //
    //  get DNS_ADDR flag for the address type we're reading
    //
    //  note we have the classic and\or problem
    //  the addresses are denoted by two flags (from iphelp):
    //      DNSADDR_FLAG_PUBLIC   
    //      DNSADDR_FLAG_TRANSIENT
    //
    //  but we need both flags and mask to determine all the possible gatherings
    //  we want to do
    //
    //  right now the DNS_CONFIG_FLAG_X are ORd together to get UNIONS of addresses
    //  we are willing to accept, but we go through the list multiple times to build
    //  the list favoring the public over private, non-cluster over cluster
    //
    //  so currently when say you want DNS_CONFIG_PUBLIC you mean public and not-cluster;
    //  ditto for private;  on the other hand when you say DNS_CONFIG_CLUSTER you are
    //  asking for all cluster (though we could screen on whether PUBLIC, PRIVATE both or
    //  neither were specified
    //

    pScreenAddr->Flags = netinfo_AddrFlagForConfigFlag( AddrFlags );

    screenMask = DNSADDR_FLAG_TYPE_MASK;
    if ( AddrMask != 0 )
    {
        screenMask = netinfo_AddrFlagForConfigFlag( AddrMask );
    }
    pScreenAddr->DnsAddrFlagScreeningMask = screenMask;

    //
    //  read count
    //      = 0 means second pass on list
    //      -> read all, but do full duplicate screen to skip the
    //          addresses read on the first pass

    if ( ReadCount == 0 )
    {
        ReadCount = MAXDWORD;
        dupFlag = DNSADDR_MATCH_ALL;
    }

    //
    //  loop through all adapters
    //

    for ( iter=0; iter<pNetInfo->AdapterCount; iter++ )
    {
        padapter = NetInfo_GetAdapterByIndex( pNetInfo, iter );

        if ( !pSingleAdapter ||
             pSingleAdapter == padapter )
        {
            status = DnsAddrArray_AppendArrayEx(
                        pAddrArray,
                        padapter->pLocalAddrs,
                        ReadCount,          // read address count
                        0,                  // family check handled by screening
                        dupFlag,
                        netinfo_LocalAddrScreen,
                        pScreenAddr
                        );
        }
        //DNS_ASSERT( status == NO_ERROR );
    }

    return  status;
}



PADDR_ARRAY
NetInfo_CreateLocalAddrArray(
    IN      PDNS_NETINFO    pNetInfo,
    IN      PWSTR           pwsAdapterName, OPTIONAL
    IN      PDNS_ADAPTER    pAdapter,       OPTIONAL
    IN      DWORD           Family,         OPTIONAL
    IN      DWORD           AddrFlags       OPTIONAL
    )
/*++

Routine Description:

    Create IP array of DNS servers from network info.

Arguments:

    pNetInfo -- DNS net adapter list to convert

    pwsAdapterName -- specific adapter;  NULL for all adapters

    pAdapter -- specific adapter;  NULL for all adapters

    Family -- required specific address family;  0 for any family

    AddrFlags -- address selection flags
        DNS_CONFIG_FLAG_INCLUDE_CLUSTER

    AddrFlagsMask -- mask on selecting flags

Return Value:

    Ptr to IP array, if successful
    NULL on failure.

--*/
{
    PADDR_ARRAY         parray = NULL;
    DWORD               iter;
    DWORD               countAddrs = 0;
    PDNS_ADAPTER        padapter;
    PDNS_ADAPTER        padapterSingle = NULL;
    DNS_STATUS          status = NO_ERROR;
    DNS_ADDR            screenAddr;

    DNSDBG( TRACE, (
        "NetInfo_CreateLocalAddrArray( %p, %S, %p, %d, %08x )\n",
        pNetInfo,
        pwsAdapterName,
        pAdapter,      
        Family,        
        AddrFlags ));

    //
    //  get count
    //

    if ( ! pNetInfo )
    {
        return NULL;
    }

    padapterSingle = pAdapter;
    if ( pwsAdapterName && !padapterSingle )
    {
        padapterSingle = NetInfo_GetAdapterByName( pNetInfo, pwsAdapterName );
        if ( !padapterSingle )
        {
            goto Done;
        }
    }

    //
    //  setup screening addr
    //
    //  if not address flag -- get all types
    //

    if ( AddrFlags == 0 )
    {
        AddrFlags = (DWORD)(-1);
    }

    RtlZeroMemory( &screenAddr, sizeof(screenAddr) );
    screenAddr.Sockaddr.sa_family = (WORD)Family;

    //
    //  count addrs
    //
    //  DCR:  could count with based on addr info
    //

    for ( iter=0; iter<pNetInfo->AdapterCount; iter++ )
    {
        padapter = NetInfo_GetAdapterByIndex( pNetInfo, iter );

        if ( !padapterSingle ||
             padapterSingle == padapter )
        {
            countAddrs += DnsAddrArray_GetFamilyCount(
                                padapter->pLocalAddrs,
                                Family );
        }
    }

    //
    //  allocate required array
    //

    parray = DnsAddrArray_Create( countAddrs );
    if ( !parray )
    {
        status = DNS_ERROR_NO_MEMORY;
        goto Done;
    }
    DNS_ASSERT( parray->MaxCount == countAddrs );


    //
    //  read addrs "in order"
    //
    //  historically gethostbyname() presented addrs
    //      - one from each adapter
    //      - then the rest from all adapters
    //
    //  we preserve this, plus order by type
    //      - public DNS_ELIGIBLE first
    //      - private (autonet, IP6 local scope stuff)
    //      - cluster\transient last
    //

    //
    //  public (DNS_ELIGIBLE) addrs
    //      - screen on all flags, specifically don't pick up public cluster addrs
    //

    if ( AddrFlags & DNS_CONFIG_FLAG_ADDR_PUBLIC )
    {
        //  read first "public" addr of each (or single) adapter

        status = netinfo_ReadLocalAddrs(
                    parray,
                    pNetInfo,
                    padapterSingle,
                    & screenAddr,
                    DNS_CONFIG_FLAG_ADDR_PUBLIC,
                    0,                  // exact match on all flags
                    1                   // read only one address
                    );
    
        //  read the rest of "public" addrs
    
        status = netinfo_ReadLocalAddrs(
                    parray,
                    pNetInfo,
                    padapterSingle,
                    & screenAddr,
                    DNS_CONFIG_FLAG_ADDR_PUBLIC,
                    0,                  // exact match on all flags
                    0                   // read the rest
                    );
    }

    //
    //  private (non-DNS-publish) addrs (autonet, IP6 local, sitelocal, etc.)
    //      - screen on all flags, specifically don't pick up private cluster addrs
    //

    if ( AddrFlags & DNS_CONFIG_FLAG_ADDR_PRIVATE )
    {
        status = netinfo_ReadLocalAddrs(
                    parray,
                    pNetInfo,
                    padapterSingle,
                    & screenAddr,
                    DNS_CONFIG_FLAG_ADDR_PRIVATE,
                    0,                  // exact match on all flags
                    MAXDWORD            // read all addrs
                    );
    }

    //
    //  cluster at end
    //      - only screen on cluster flag as public flag may
    //      also be set\clear
    //

    if ( AddrFlags & DNS_CONFIG_FLAG_ADDR_CLUSTER )
    {
        status = netinfo_ReadLocalAddrs(
                    parray,
                    pNetInfo,
                    padapterSingle,
                    & screenAddr,
                    DNS_CONFIG_FLAG_ADDR_CLUSTER,
                    DNS_CONFIG_FLAG_ADDR_CLUSTER,   // any cluster match
                    MAXDWORD                        // read all addrs
                    );
    }

Done:

    if ( status != NO_ERROR )
    {
        SetLastError( status );
    }

    return( parray );
}




//
//  Local address list presentation
//

PDNS_ADDR_ARRAY
NetInfo_GetLocalAddrArray(
    IN      PDNS_NETINFO    pNetInfo,
    IN      PWSTR           pwsAdapterName, OPTIONAL
    IN      DWORD           AddrFamily,     OPTIONAL
    IN      DWORD           AddrFlags,      OPTIONAL
    IN      BOOL            fForce
    )
/*++

Routine Description:

    Get local addrs as array.

    This is a combination NetInfo_Get\ConvertToLocalAddrArray routine.
    It's purpose is to simplify getting local address info, while avoiding
    costly NetInfo rebuilds where they are unnecessary.

Arguments:

    pNetInfo -- existing netinfo to use

    pwsAdapterName -- specific adapter name;  NULL for all adapters

    AddrFamily -- specific address family;  0 for all

    AddrFlags -- flags to indicate addrs to consider
        DNS_CONFIG_FLAG_INCLUDE_CLUSTER

    fForce -- force reread from registry

Return Value:

    ERROR_SUCCESS if successful.
    Error code on failure.

--*/
{
    PDNS_NETINFO    pnetInfo = NULL;
    PADDR_ARRAY     parray = NULL;
    DNS_STATUS      status = NO_ERROR;

    DNSDBG( TRACE, (
        "NetInfo_GetLocalAddrArray()\n"
        "\tpnetinfo = %p\n"
        "\tadapter  = %S\n"
        "\tfamily   = %d\n"
        "\tflags    = %08x\n"
        "\tforce    = %d\n",
        pNetInfo,
        pwsAdapterName,
        AddrFamily,
        AddrFlags,
        fForce
        ));

    //
    //  get network info to make list from
    //      - if force, full reread
    //      - otherwise gethostbyname() scenario
    //          - accept local caching for very short interval just for perf
    //          - accept resolver
    //
    //  DCR:  force first gethostbyname() call to resolver\registry?
    //      have to define "first", in a way that's different from netinfo()
    //      in last second
    //

    pnetInfo = pNetInfo;

    if ( !pnetInfo )
    {
        DWORD   getFlag = NIFLAG_GET_LOCAL_ADDRS;
        DWORD   timeout;

        if ( fForce )
        {
            getFlag |= NIFLAG_FORCE_REGISTRY_READ;
            timeout = 0;
        }
        else
        {
            getFlag |= NIFLAG_READ_RESOLVER;
            getFlag |= NIFLAG_READ_PROCESS_CACHE;
            timeout = 1;
        }
    
        pnetInfo = NetInfo_Get(
                        getFlag,
                        timeout
                        );
        if ( !pnetInfo )
        {
            status = DNS_ERROR_NO_TCPIP;
            goto Done;
        }
    }

    //
    //  cluster filter info
    //      -- check environment variable
    //
    //  DCR:  once RnR no longer using myhostent() for gethostbyname()
    //          then can remove

    if ( g_IsServer &&
         (AddrFlags & DNS_CONFIG_FLAG_READ_CLUSTER_ENVAR) &&
         !(AddrFlags & DNS_CONFIG_FLAG_ADDR_CLUSTER) ) 
    {
        ENVAR_DWORD_INFO    filterInfo;
    
        Reg_ReadDwordEnvar(
           RegIdFilterClusterIp,
           &filterInfo );
        
        if ( !filterInfo.fFound ||
             !filterInfo.Value )
        {
            AddrFlags |= DNS_CONFIG_FLAG_ADDR_CLUSTER;
        }
    }

    //
    //  convert network info to IP4_ARRAY
    //

    parray = NetInfo_CreateLocalAddrArray(
                pnetInfo,
                pwsAdapterName,
                NULL,           // no specific adapter ptr
                AddrFamily,
                AddrFlags
                );

    if ( !parray )
    {
        status = GetLastError();
        goto Done;
    }

    //  if no IPs found, return

    if ( parray->AddrCount == 0 )
    {
        DNS_PRINT((
            "NetInfo_GetLocalAddrArray() failed:  no addrs found\n"
            "\tstatus = %d\n" ));
        status = DNS_ERROR_NO_TCPIP;
        goto Done;
    }

    IF_DNSDBG( NETINFO )
    {
        DNS_PRINT(( "Leaving Netinfo_GetLocalAddrArray()\n" ));
        DnsDbg_DnsAddrArray(
            "Local addr list",
            "server",
            parray );
    }

Done:

    //  free netinfo built here

    if ( pnetInfo != pNetInfo )
    {
        NetInfo_Free( pnetInfo );
    }

    if ( status != NO_ERROR )
    {
        FREE_HEAP( parray );
        parray = NULL;
        SetLastError( status );
    }

    return( parray );
}



PIP4_ARRAY
NetInfo_GetLocalAddrArrayIp4(
    IN      PWSTR           pwsAdapterName, OPTIONAL
    IN      DWORD           Flags,
    IN      BOOL            fForce
    )
/*++

Routine Description:

    Get DNS server list as IP array.

Arguments:

    pwsAdapterName -- specific adapter name;  NULL for all adapters

    Flags -- flags to indicate addrs to consider
        DNS_CONFIG_FLAG_X 

    fForce -- force reread from registry

Return Value:

    ERROR_SUCCESS if successful.
    Error code on failure.

--*/
{
    PADDR_ARRAY parray;
    PIP4_ARRAY  parray4 = NULL;
    DNS_STATUS  status = NO_ERROR;

    DNSDBG( TRACE, ( "NetInfo_GetLocalAddrArrayIp4()\n" ));

    //
    //  get DNS server list
    //

    parray = NetInfo_GetLocalAddrArray(
                NULL,           // no existing netinfo
                pwsAdapterName,
                AF_INET,
                Flags,
                fForce );
    if ( !parray )
    {
        goto Done;
    }

    //
    //  convert array to IP4 array
    //

    parray4 = DnsAddrArray_CreateIp4Array( parray );
    if ( !parray4 )
    {
        status = DNS_ERROR_NO_MEMORY;
        goto Done;
    }

    DNS_ASSERT( parray4->AddrCount > 0 );

Done:

    DnsAddrArray_Free( parray );

    if ( status != NO_ERROR )
    {
        SetLastError( status );
    }
    return( parray4 );
}

//
//  End netinfo.c
//
=== C:/Users/treeman/Desktop/windows nt source code\Source\Win2K3\NT\ds\dns\dnsapi\queue.h ===
/*++

Copyright (c) 1997 Microsoft Corporation

Module Name:

    queue.h

Abstract:

    Domain Name System (DNS) Server

    Queue functionality specific to Dynamic DNS registration.
    
Author:

    Ram Viswanathan (ramv)  March 27 1997

Revision History:

    Ram Viswanathan (ramv) March 27 1997   Created

--*/


//
//  Queue CS is also used in dynreg.c
//

extern  CRITICAL_SECTION    g_QueueCS;


typedef struct _QELEMENT {
    REGISTER_HOST_ENTRY  HostAddr;
    LPWSTR               pszName;
    DWORD                dwTTL;
    BOOL                 fDoForward;
    BOOL                 fDoForwardOnly;
    DWORD                dwOperation; // what operation needs to be performed
    DWORD                dwRetryTime; //used by timed out queue (in secs)
    DWORD                dwRetryCount;
    DHCP_CALLBACK_FN     pfnDhcpCallBack; // call back function to call
    PVOID                pvData;
    PIP4_ARRAY           DnsServerList;
    struct _QELEMENT*    pFLink;
    struct _QELEMENT*    pBLink;     //doubly linked list

}  QELEMENT, *PQELEMENT;


typedef struct _DynDnsQueue {
    PQELEMENT  pHead;  // pointer to the queue Head, where you take elements
    // off of the queue

    PQELEMENT pTail;  // pointer to tail, where producer adds elements
    
} DYNDNSQUEUE, *PDYNDNSQUEUE;

//
// methods to manipulate queue
//

DWORD 
InitializeQueues(
    PDYNDNSQUEUE * ppQueue,
    PDYNDNSQUEUE * ppTimedOutQueue
    );
/*
  InitializeQueue()

  This function initializes the queue object. This is invoked for the first
  time when you create the main queue and timed out queue

  Allocates appropriate memory variables etc

*/


DWORD 
FreeQueue(
    PDYNDNSQUEUE  pqueue
    );
/*
  FreeQueue()

  Frees the queue object. If there exist any entries in the queue, we
  just blow them away

*/

DWORD 
Enqueue(
    PQELEMENT     pNewElement,
    PDYNDNSQUEUE  pQueue,
    PDYNDNSQUEUE  pTimedOutQueue
    );


/*
   Enqueue()

   Adds new element to queue. If there is a dependency, this moves into
   the timedout queue.

   Arguments:

   Return Value:

    is 0 if Success. and (DWORD)-1 if failure.

*/
    


PQELEMENT 
Dequeue(
    PDYNDNSQUEUE  pQueue
    );


/*
   Dequeue()

   Removes an element from a queue, either the main queue or the timed
   out queue

   Arguments:

   Return Value:

    is the element at head of queue if Success. and NULL if failure.

*/
  
DWORD
AddToTimedOutQueue(    
    PQELEMENT     pNewElement,
    PDYNDNSQUEUE  pRetryQueue,
    DWORD         dwRetryTime
    );


/*
   AddToTimedOutQueue()

   Adds new element to timedout queue. Now the new element is added in a list
   of elements sorted according to decreasing order of Retry Times. An
   insertion sort type of algorithm is used.

   Arguments:

   dwRetryTime is in seconds
   Return Value:

    is 0 if Success. and (DWORD)-1 if failure.

*/
    
DWORD
GetEarliestRetryTime(
    PDYNDNSQUEUE pRetryQueue
    );

/*

   GetEarliestRetryTime()

   Checks to see if there is any element at the head of the queue
   and gets the retry time for this element

   Arguments:

   Return Value:

    is retrytime if success and INFINITE if there is no element or other
    failure

*/

/*
VOID
ProcessMainQDependencies(
    PDYNDNSQUEUE pQueue,
    PQELEMENT    pQElement
    );

    */
DWORD
ProcessQDependencies(
    PDYNDNSQUEUE pTimedOutQueue,
    PQELEMENT    pQElement
    );


VOID
DhcpSrv_FreeQueueElement(
    IN OUT  PQELEMENT       pQElement
    );


//
//  End queue.h
//
=== C:/Users/treeman/Desktop/windows nt source code\Source\Win2K3\NT\ds\dns\dnsapi\regfig.c ===
/*++

Copyright (c) 1999-2001  Microsoft Corporation

Module Name:

    regfig.c

Abstract:

    Domain Name System (DNS) API 

    Configuration routines.

Author:

    Jim Gilroy (jamesg)     September 1999

Revision History:

--*/


#include "local.h"


//
//  Table for quick lookup of DWORD\BOOL reg values
//
//  DCR:  read directly to config BLOB with regID indexes
//      you can't screw that up
//      

#define     DWORD_PTR_ARRAY_END   ((PDWORD) (DWORD_PTR)(-1))

PDWORD RegDwordPtrArray[] =
{
    //  basic -- not DWORDs

    NULL,
    NULL,
    NULL,
    NULL,
    NULL,
    NULL,
    NULL,
    NULL,
    NULL,
    NULL,

    //  query

    (PDWORD) &g_QueryAdapterName,
    (PDWORD) &g_UseNameDevolution,
    (PDWORD) &g_PrioritizeRecordData,
    (PDWORD) &g_AllowUnqualifiedQuery,
    (PDWORD) &g_AppendToMultiLabelName,
    (PDWORD) &g_ScreenBadTlds,
    (PDWORD) &g_ScreenUnreachableServers,
    (PDWORD) &g_FilterClusterIp,
    (PDWORD) &g_WaitForNameErrorOnAll,
    (PDWORD) &g_UseEdns,
    (PDWORD) &g_QueryIpMatching,

    //  update

    (PDWORD) &g_RegistrationEnabled,
    (PDWORD) &g_RegisterPrimaryName,
    (PDWORD) &g_RegisterAdapterName,
    (PDWORD) &g_RegisterReverseLookup,
    (PDWORD) &g_RegisterWanAdapters,
    (PDWORD) &g_RegistrationTtl,
    (PDWORD) &g_RegistrationRefreshInterval,
    (PDWORD) &g_RegistrationMaxAddressCount,
    (PDWORD) &g_UpdateSecurityLevel,
    (PDWORD) &g_UpdateZoneExcludeFile,
    (PDWORD) &g_UpdateTopLevelDomains,

    //  backcompat

    NULL,
    NULL,
    NULL,
    NULL,
    NULL,
    NULL,
    NULL,
    NULL,
    NULL,

    //  micellaneous

    NULL,   //g_InNTSetupMode,      // not in standard location
    (PDWORD) &g_DnsTestMode,
    NULL,                           // remote resolver not a DWORD

    //  resolver

    (PDWORD) &g_MaxCacheSize,
    (PDWORD) &g_MaxCacheTtl,
    (PDWORD) &g_MaxNegativeCacheTtl,
    (PDWORD) &g_AdapterTimeoutLimit,
    (PDWORD) &g_ServerPriorityTimeLimit,
    (PDWORD) &g_MaxCachedSockets,

    //  multicast resolver

    (PDWORD) &g_MulticastListenLevel,
    (PDWORD) &g_MulticastSendLevel,

    //  termination

    DWORD_PTR_ARRAY_END
};

//
//  Array indicating which registry values
//      were read versus defaulted
//

DWORD   RegValueWasReadArray[ RegIdValueCount ];


//
//  Check for empty reg value (string)
//
//  DCR:  consider more detailed white space check
//

#define IS_EMPTY_STRING(psz)            (*(psz)==0)




//
//  General registry\config utils
//

VOID
PrintConfigGlobals(
    IN      PSTR            pszHeader
    )
/*++

Routine Description:

    Print config globals.

Arguments:

    pszHeader -- header to print with

Return Value:

    ERROR_SUCCESS if successful.
    ErrorCode on failure.

--*/
{
    DWORD   propId;

    //
    //  print each property
    //

    DnsDbg_Lock();

    DnsDbg_Printf(
        "%s\n",
        pszHeader ? pszHeader : "Registry Globals:" );

    propId = 0;

    for( propId=0; propId<=RegIdValueGlobalMax; propId++ )
    {
        PDWORD  pdword = RegDwordPtrArray[propId];

        //  separators

        if ( propId == RegIdQueryAdapterName )
        {
            DnsDbg_Printf( "\t-- Query:\n" );
        }
        else if ( propId == RegIdRegistrationEnabled )
        {
            DnsDbg_Printf( "\t-- Update:\n" );
        }
        else if ( propId == RegIdSetupMode )
        {
            DnsDbg_Printf( "\t-- Miscellaneous:\n" );
        }
        else if ( propId == RegIdMaxCacheSize )
        {
            DnsDbg_Printf( "\t-- Resolver\n" );
        }

        //  NULL indicates not DWORD or not standard

        if ( !pdword )
        {
            continue;
        }

        //  terminate on bogus ptr

        if ( pdword == DWORD_PTR_ARRAY_END )
        {
            ASSERT( FALSE );
            break;
        }

        DnsDbg_Printf(
            "\t%-36S= %8d (read=%d)\n",
            REGPROP_NAME( propId ),
            * pdword,
            RegValueWasReadArray[ propId ] );
    }

    DnsDbg_Printf(
        "\t-- Random:\n"
        "\tIsDnsServer                      = %d\n"
        "\tInNTSetupMode                    = %d\n"
        "\tDnsTestMode                      = %08x\n\n",
        g_IsDnsServer,
        g_InNTSetupMode,
        g_DnsTestMode
        );

    DnsDbg_Unlock();
}



DNS_STATUS
Reg_ReadGlobalsEx(
    IN      DWORD           dwFlag,
    IN      PVOID           pRegSession     OPTIONAL
    )
/*++

Routine Description:

    Read globals from registry.

Arguments:

    dwFlag -- flag indicating read level

    //
    //  DCR:  reg read flag unimplemented
    //
    //  note:  should have option to NOT read some registry
    //          values for case when cache off, then could
    //          skip useless cache info when building local
    //          networkinfo blob
    //

    pRegSession -- ptr to existing registry session

Return Value:

    ERROR_SUCCESS if successful.
    ErrorCode on failure.

--*/
{
    DWORD               propId;
    REG_SESSION         regSession;
    PREG_SESSION        psession;
    DNS_STATUS          status;


    DNSDBG( TRACE, (
        "Reg_ReadGlobalsEx( %08x, %p )\n",
        dwFlag,
        pRegSession ));

    //
    //  basic registry init
    //      - includes system global
    //

    Reg_Init();

    //
    //  code validity check
    //  property table should have entry for every reg value plus an
    //      extra one for the terminator
    //

#if DBG
    DNS_ASSERT( (RegIdValueCount+1)*sizeof(PDWORD) ==
                sizeof(RegDwordPtrArray) );
#endif

    //
    //  open registry session -- if not passed in
    //

    psession = (PREG_SESSION) pRegSession;

    if ( !psession )
    {
        psession = &regSession;
        status = Reg_OpenSession( psession, 0, 0 );
        if ( status != ERROR_SUCCESS )
        {
            return( status );
        }
    }

    //
    //  clear "value was read" array
    //

    RtlZeroMemory(
        RegValueWasReadArray,
        sizeof( RegValueWasReadArray ) );

    //
    //  MS DNS?
    //

    g_IsDnsServer = Reg_IsMicrosoftDnsServer();

    //
    //  remote resolver?
    //      - not currently enabled
    //

    //g_pwsRemoteResolver = DnsGetResolverAddress();
    g_pwsRemoteResolver = NULL;


    //
    //  read\set each DWORD\BOOL registry value
    //      

    propId = 0;

    for( propId=0; propId<=RegIdValueGlobalMax; propId++ )
    {
        PDWORD  pdword = RegDwordPtrArray[propId];

        //  NULL indicates not DWORD or not standard

        if ( !pdword )
        {
            continue;
        }

        //  terminate on bogus ptr

        if ( pdword == DWORD_PTR_ARRAY_END )
        {
            ASSERT( FALSE );
            break;
        }

        status = Reg_GetDword(
                    psession,       // reg session
                    NULL,           // no key
                    NULL,           // standard location
                    propId,         // index is property id
                    pdword );

        //  set fRead flag if value found in registry

        if ( status == ERROR_SUCCESS )
        {
            RegValueWasReadArray[propId] = TRUE;
        }
    }

    //
    //  registration refresh defaults are different for DC
    //

    if ( !RegValueWasReadArray[ RegIdRegistrationRefreshInterval ] )
    {
        if ( g_IsDomainController )
        {
            g_RegistrationRefreshInterval = REGDEF_REGISTRATION_REFRESH_INTERVAL_DC;
        }
        ELSE_ASSERT( g_RegistrationRefreshInterval == REGDEF_REGISTRATION_REFRESH_INTERVAL );
    }

    //
    //  non-standard registry values
    //      - setup mode
    //

    Reg_GetDword(
        psession,
        NULL,               // no key
        REGKEY_SETUP_MODE_LOCATION,
        RegIdSetupMode,
        (PDWORD) &g_InNTSetupMode );

    //
    //  DCR:  flip in policy globals and do single read here
    //      or since they are only relevant to adapter
    //      list and registration, keep separate
    //
    //      fundamentally the question is how separate is the
    //      adapter list read from other globals?
    //


    //  close local session registry handles

    if ( psession == &regSession )
    {
        Reg_CloseSession( psession );
    }

    IF_DNSDBG( INIT )
    {
        PrintConfigGlobals( "Read Registry Globals" );
    }

    return( ERROR_SUCCESS );
}



DNS_STATUS
Reg_RefreshUpdateConfig(
    VOID
    )
/*++

Routine Description:

    Read\refresh update config.

    This routine encapsulates getting all update config info
    current before any update operation.

Arguments:

    None

Return Value:

    ERROR_SUCCESS if successful.
    Error code on failure.

--*/
{
    //
    //  read all global DWORDs if haven't been read "recently"
    //
    //  note:  adapter specific stuff is read building network config;
    //      here were are just insuring that we have top level globals
    //      current;  specifically test was blocked because the
    //      update TLD flag was not being reread
    //
    //  DCR:  when have change\notify this should just tie into
    //          global config read
    //

    return  Reg_ReadGlobalsEx( 0, NULL );
}



//
//  Special DNS property routines
//

DNS_STATUS
Reg_ReadPrimaryDomainName(
    IN      PREG_SESSION    pRegSession,    OPTIONAL
    IN      HKEY            hRegKey,        OPTIONAL
    OUT     PWSTR *         ppPrimaryDomainName
    )
/*++

Routine Description:

    Read primary domain name.

Arguments:


    pRegSession -- ptr to registry session, OPTIONAL

    hRegKey     -- handle to open regkey OPTIONAL (currently unimplemented)

    ppPrimaryDomainName -- addr to recv ptr to PDN

Return Value:

    ERROR_SUCCESS if successful.
    Error code on failure.

--*/
{
    DNS_STATUS      status;
    REG_SESSION     session;
    PREG_SESSION    psession = NULL;
    PWSTR           pdomainName = NULL;
    HKEY            holdPolicyKey = NULL;
    HKEY            hkeyPolicy;

    DNSDBG( TRACE, ( "Reg_ReadPrimaryDomainName()\n" ));

    ASSERT( !hRegKey );

    //
    //  open reg handle if not open
    //
    //  note:  worth doing here, because if we default the open
    //      in the calls below, we will make unnecessary reg calls
    //      -- won't be able to screen for policy existence
    //          so policy PDN name will be looked for in TCPIP
    //      -- the second call for the TCPIP domain name, will also
    //          check in the policy area (if exists)
    //      

    psession = pRegSession;

    if ( !psession )
    {
        psession = &session;
        status = Reg_OpenSession(
                        psession,
                        0,          // standard level
                        0           // no specific value, open both
                        );
        if ( status != ERROR_SUCCESS )
        {
            goto Done;
        }
    }

    //
    //  try policy
    //      - no policy pickup for DCs
    //      - first try new WindowsNT policy
    //      - if not found, try policy used in Win2K
    //

    hkeyPolicy = psession->hPolicy;

    if ( hkeyPolicy )
    {
        status = Reg_GetValue(
                    NULL,                   // don't send whole session
                    hkeyPolicy,             // use explicit policy key
                    RegIdPrimaryDomainName,
                    REGTYPE_DNS_NAME,
                    (PBYTE *) &pdomainName
                    );
        if ( pdomainName )
        {
            goto Found;
        }
    }

    //
    //  not found in new, open old policy
    //
          
    status = RegOpenKeyExW(
                HKEY_LOCAL_MACHINE,
                DNS_POLICY_WIN2K_KEY,
                0,
                KEY_QUERY_VALUE,
                & holdPolicyKey );

    if ( holdPolicyKey )
    {
        status = Reg_GetValue(
                    NULL,               // don't send whole session
                    holdPolicyKey,      // use explicit policy key
                    RegIdPrimaryDnsSuffix,
                    REGTYPE_DNS_NAME,
                    (PBYTE *) &pdomainName
                    );

        RegCloseKey( holdPolicyKey );
        if ( pdomainName )
        {
            goto Found;
        }
    }
    
    //
    //  no policy name
    //      - try DNS client
    //      - try standard TCPIP location
    //          note under TCPIP it's "Domain"
    //

#ifdef DNSCLIENTKEY
    if ( psession->hClient )
    {
        status = Reg_GetValue(
                    NULL,                       // don't send whole session
                    psession->hClient,          // send client key explicitly
                    RegIdPrimaryDomainName,
                    REGTYPE_DNS_NAME,
                    (PBYTE *) &pdomainName );
        if ( pdomainName )
        {
            goto Found;
        }
    }
#endif

    status = Reg_GetValue(
                NULL,                       // don't send whole session
                psession->hTcpip,           // send TCPIP key explicitly
                RegIdDomainName,
                REGTYPE_DNS_NAME,
                (PBYTE *) &pdomainName );


Found:

    //  dump name if empty\useless

    if ( pdomainName &&
         ( wcslen( pdomainName ) == 0 ) )
    {
        FREE_HEAP( pdomainName );
        pdomainName = NULL;
    }


Done:

    DNSDBG( TRACE, ( "Read PDN = %S\n", pdomainName ));

    //  set domain name OUT param

    *ppPrimaryDomainName = pdomainName;

    //  cleanup any regkey's opened

    if ( psession == &session )
    {
        Reg_CloseSession( psession );
    }

    return( status );
}



BOOL
Reg_IsMicrosoftDnsServer(
    VOID
    )
/*++

Routine Description:

    Read registry to determine if MS DNS server.

Arguments:

    None

Return Value:

    ERROR_SUCCESS if successful.
    Error code on failure.

--*/
{
    DWORD   status = NO_ERROR;
    HKEY    hkey = NULL;

    //
    //  open services key to determine whether the DNS server is installed.
    //
    //  DCR:  read DNS server only once
    //      - however need some sort of callback so we can pick this up
    //      after install
    //

    status = RegOpenKeyExW(
                HKEY_LOCAL_MACHINE,
                DNS_SERVER_KEY,
                0,
                KEY_QUERY_VALUE,
                &hkey );

    if ( status != ERROR_SUCCESS )
    {
        return FALSE;
    }

    RegCloseKey( hkey );

    return TRUE;
}



//
//  Reg info read.
//  These are read routines for info beyond flat globals.
//
//  Three types of info:
//      - global
//      - adapter specific
//      - update
//

DNS_STATUS
Reg_ReadGlobalInfo(
    IN      PREG_SESSION        pRegSession,
    OUT     PREG_GLOBAL_INFO    pRegInfo
    )
/*++

Routine Description:

    Read DNS registry info, not read in flat read.

    This covers all the allocated stuff, plus policy
    stuff for adapter info.

        -- primary domain name
        -- adapter policy
            - domain name
            - DNS servers
            - flag overrides

Arguments:

    pRegSession -- registry session

    pRegInfo -- blob to hold reg info

Return Value:

    ERROR_SUCCESS if successful.
    Error code on failure.

--*/
{
    DNS_STATUS          status;
    REG_SESSION         regSession;
    PREG_SESSION        pregSession = pRegSession;
    HKEY                hkeyPolicy = NULL;

    DNSDBG( TRACE, (
        "Reg_ReadGlobalInfo( %p, %p )\n",
        pRegSession,
        pRegInfo ));

    //
    //  clear reg info blob
    //

    RtlZeroMemory(
        pRegInfo,
        sizeof( *pRegInfo ) );

    //
    //  open the registry
    //

    if ( !pregSession )
    {
        pregSession = &regSession;
    
        status = Reg_OpenSession(
                    pregSession,
                    0,
                    0 );
        if ( status != ERROR_SUCCESS )
        {
            return( status );
        }
    }

    //
    //  if not read force registry read
    //

    status = Reg_ReadGlobalsEx(
                0,              // no flag, read it all
                pregSession
                );

    //
    //  primary domain name
    //

    Reg_ReadPrimaryDomainName(
        pregSession,
        NULL,           // no specific key
        & pRegInfo->pszPrimaryDomainName
        );

    //
    //  host name
    //

    Reg_GetValue(
        pregSession,
        NULL,           // no key
        RegIdHostName,
        REGTYPE_DNS_NAME,
        (PBYTE *) &pRegInfo->pszHostName
        );

    //
    //  pick up required registry values from globals
    //

    pRegInfo->fUseNameDevolution = g_UseNameDevolution;

    //
    //  policy overrides for adapter info
    //      - enable adapter registration
    //      - DNS servers
    //      - domain name
    //
    //  note, we need both value and found\not-found flag
    //      as value overrides only when it exists
    //

    hkeyPolicy = pregSession->hPolicy;
    if ( !hkeyPolicy )
    {
        goto Done;
    }

    //
    //  policy for register adapter name?
    //

    status = Reg_GetDword(
                NULL,                   // no session
                hkeyPolicy,             // policy
                NULL,                   // no adapter
                RegIdRegisterAdapterName,
                & pRegInfo->fRegisterAdapterName
                );
    if ( status == ERROR_SUCCESS )
    {
        pRegInfo->fPolicyRegisterAdapterName = TRUE;
    }

    //
    //  policy for adapter domain name?
    //

    status = Reg_GetValue(
                NULL,                   // no session
                hkeyPolicy,
                RegIdAdapterDomainName,
                REGTYPE_DNS_NAME,
                (PBYTE *) &pRegInfo->pszAdapterDomainName
                );

    //
    //  policy for adapter DNS server lists
    //

    status = Reg_GetIpArray(
                NULL,                   // no session
                hkeyPolicy,
                NULL,                   // no adapter
                RegIdDnsServers,
                REG_SZ,
                &pRegInfo->pDnsServerArray
                );

Done:

    //  if opened session -- close

    if ( pregSession  &&  !pRegSession )
    {
        Reg_CloseSession( pregSession );
    }

    DNSDBG( TRACE, (
        "Leave Reg_ReadGlobalInfo()\n"
        "\tPDN          = %S\n"
        "\tPolicy:\n"
        "\t\tRegister Adapter   = %d\n"
        "\t\tAdapterName        = %S\n"
        "\t\tDNS servers        = %p\n",
        pRegInfo->pszPrimaryDomainName,
        pRegInfo->fRegisterAdapterName,
        pRegInfo->pszAdapterDomainName,
        pRegInfo->pDnsServerArray
        ));

    return  ERROR_SUCCESS;
}



VOID
Reg_FreeGlobalInfo(
    IN OUT  PREG_GLOBAL_INFO    pRegInfo,
    IN      BOOL                fFreeBlob
    )
/*++

Routine Description:

    Free registry adapter policy info blob.

Arguments:

    pRegInfo -- adapter policy blob to free

    fFreeBlob -- flag to free blob itself
        FALSE -- just free allocated data fields
        TRUE  -- also free blob itself

Return Value:

    ERROR_SUCCESS if successful.
    Error code on failure.

--*/
{
    DNSDBG( TRACE, (
        "Reg_FreeGlobalInfo( %p )\n",
        pRegInfo ));

    //  allow sloppy cleanup

    if ( !pRegInfo )
    {
        return;
    }

    //
    //  free data
    //      - primary DNS name
    //      - policy adapter name
    //      - policy DNS server list
    //

    if ( pRegInfo->pszPrimaryDomainName )
    {
        FREE_HEAP( pRegInfo->pszPrimaryDomainName );
    }
    if ( pRegInfo->pszHostName )
    {
        FREE_HEAP( pRegInfo->pszHostName );
    }
    if ( pRegInfo->pszAdapterDomainName )
    {
        FREE_HEAP( pRegInfo->pszAdapterDomainName );
    }
    if ( pRegInfo->pDnsServerArray )
    {
        FREE_HEAP( pRegInfo->pDnsServerArray );
    }

    //  free blob itself

    if ( fFreeBlob )
    {
        FREE_HEAP( pRegInfo );
    }
}



DNS_STATUS
Reg_ReadAdapterInfo(
    IN      PWSTR                   pszAdapterName,
    IN      PREG_SESSION            pRegSession,
    IN      PREG_GLOBAL_INFO        pRegInfo,
    OUT     PREG_ADAPTER_INFO       pBlob
    )
/*++

Routine Description:

    Read adapter registry info.

Arguments:

    pszAdapterName -- adapter name (registry name)

    pRegSession -- registry session

    pRegInfo    -- registry global info

    pBlob       -- adapter info blob to fill in

Return Value:

    ERROR_SUCCESS if successful.
    Error code on failure.

--*/
{
    DNS_STATUS  status;
    HKEY        hkeyAdapter = NULL;
    PWSTR       padapterDomainName = NULL;
    WCHAR       adapterParamKey[ MAX_PATH+1 ];

    DNSDBG( TRACE, (
        "ReadRegAdapterInfo( %S, %p, %p, %p )\n",
        pszAdapterName,
        pRegSession,
        pRegInfo,
        pBlob ));

    //
    //  clear adapter blob
    //

    RtlZeroMemory(
        pBlob,
        sizeof(*pBlob) );

    //
    //  bail if no adapter
    //
    //  note:  this check\bail is only in place to allow call to
    //      Reg_ReadUpdateInfo() to be made in asyncreg.c without
    //      specifying an adapter;  this allows us to make the call
    //      before the adapter check and therefore skip a separate
    //      registry op to get current g_IsDnsServer global; 
    //      no actual use will be made of REG_ADAPTER_INFO blob

    if ( !pszAdapterName )
    {
        return  ERROR_SUCCESS;
    }

    //
    //  open adapter key for read
    //
    //  DCR:  fail on adapter key name overflow
    //  DCR:  this may be backwards -- ie need %s%s
    //

    _snwprintf(
        adapterParamKey,
        MAX_PATH,
        L"%s%s",
        TCPIP_INTERFACES_KEY,
        pszAdapterName );

    adapterParamKey[ MAX_PATH ] = 0;

    status = RegOpenKeyExW(
                HKEY_LOCAL_MACHINE,
                adapterParamKey,
                0,
                KEY_READ,
                &hkeyAdapter );

    if ( status != NO_ERROR )
    {
        DNSDBG( ANY, (
            "Failed open of adapter key %S!\n",
            adapterParamKey ));
        return( status );
    }

    //
    //  query with adapter name
    //      - OFF global overrides
    //

    pBlob->fQueryAdapterName = g_QueryAdapterName;

    if ( g_QueryAdapterName )
    {
        Reg_GetDword(
            NULL,           // no session,
            hkeyAdapter,    // explicit key
            NULL,           // no adapter name
            RegIdQueryAdapterName,
            & pBlob->fQueryAdapterName );
    }

    //
    //  check if adapter IPs get registered
    //      - OFF global overrides
    //

    pBlob->fRegistrationEnabled = g_RegistrationEnabled;

    if ( g_RegistrationEnabled )
    {
        Reg_GetDword(
            NULL,           // no session,
            hkeyAdapter,    // explicit key
            NULL,           // no adapter name
            RegIdRegistrationEnabled,
            & pBlob->fRegistrationEnabled );
    }

    //
    //  adapter name registration
    //      - policy may override
    //      - OFF global overrides
    //      - then adapter
    //

    if ( pRegInfo->fPolicyRegisterAdapterName )
    {
        pBlob->fRegisterAdapterName = pRegInfo->fRegisterAdapterName;
    }
    else
    {
        pBlob->fRegisterAdapterName = g_RegisterAdapterName;

        if ( g_RegisterAdapterName )
        {
            Reg_GetDword(
                NULL,               // no open session,
                hkeyAdapter,        // open key
                NULL,               // no adapter name
                RegIdRegisterAdapterName,
                & pBlob->fRegisterAdapterName );
        }
    }

    //
    //  max addresses to register
    //
    //  DCR:  RegistrationAddrCount -- adapter or global sets high\low?
    //

    if ( pBlob->fRegistrationEnabled )
    {
        Reg_GetDword(
            NULL,           // no session,
            hkeyAdapter,    // explicit key
            NULL,           // no adapter name
            RegIdRegistrationMaxAddressCount,
            & pBlob->RegistrationMaxAddressCount );
#if 0
        if ( g_RegistrationMaxAddressCount >
             pBlob->RegistrationMaxAddressCount )
        {
            pBlob->RegistrationMaxAddressCount = g_RegistrationMaxAddressCount;
        }
#endif
    }

    //
    //  get adapter name
    //     - policy may override AND
    //     allow policy to override with NULL string to kill domain name
    //

    padapterDomainName = pRegInfo->pszAdapterDomainName;

    if ( padapterDomainName )
    {
        if ( IS_EMPTY_STRING( padapterDomainName ) )
        {
            padapterDomainName = NULL;
        }
        else
        {
            padapterDomainName = Dns_CreateStringCopy_W( padapterDomainName );
        }
    }
    else
    {
        //
        //  static domain name set on adapter?
        //

        status = Reg_GetValueEx(
                    NULL,               // no session
                    hkeyAdapter,
                    NULL,               // no adapter name
                    RegIdStaticDomainName,
                    REGTYPE_DNS_NAME,
                    DNSREG_FLAG_DUMP_EMPTY,     // dump empty string
                    (PBYTE *) &padapterDomainName
                    );
    
        if ( status != ERROR_SUCCESS )
        {
            DNS_ASSERT( padapterDomainName == NULL );
            padapterDomainName = NULL;
        }

        //
        //  if no static name, use DHCP name
        //
    
        if ( ! padapterDomainName )
        {
            status = Reg_GetValueEx(
                            NULL,           // no session
                            hkeyAdapter,
                            NULL,           // no adapter
                            RegIdDhcpDomainName,
                            REGTYPE_DNS_NAME,
                            DNSREG_FLAG_DUMP_EMPTY,     // dump if empty string
                            (PBYTE *) &padapterDomainName );
    
            if ( status != ERROR_SUCCESS )
            {
                DNS_ASSERT( padapterDomainName == NULL );
                padapterDomainName = NULL;
            }
        }
    }

    //
    //  set adapter name in info blob
    //

    pBlob->pszAdapterDomainName = padapterDomainName;

    //
    //  cleanup
    //

    if ( hkeyAdapter )
    {
        RegCloseKey( hkeyAdapter );
    }

    DNSDBG( TRACE, (
        "Leave Reg_ReadAdapterInfo()\n"
        "\tDomainName           = %S\n"
        "\tQueryAdapterName     = %d\n"
        "\tRegistrationEnabled  = %d\n"
        "\tRegisterAdapterName  = %d\n"
        "\tRegisterAddrCount    = %d\n",
        pBlob->pszAdapterDomainName,
        pBlob->fQueryAdapterName,
        pBlob->fRegistrationEnabled,
        pBlob->fRegisterAdapterName,
        pBlob->RegistrationMaxAddressCount
        ));

    return  ERROR_SUCCESS;
}



DNS_STATUS
Reg_DefaultAdapterInfo(
    OUT     PREG_ADAPTER_INFO       pBlob,
    IN      PREG_GLOBAL_INFO        pRegInfo,
    IN      PIP_ADAPTER_ADDRESSES   pIpAdapter
    )
/*++

Routine Description:

    Default adapter info, when reg read fails.

    Use for building netinfo on IP6 only adapters that
    don't show in TCPIP adapters.

Arguments:

    pBlob       -- adapter info blob to fill in

    pRegInfo    -- registry global info

    pIPAdapter  -- IP help adapter info

Return Value:

    ERROR_SUCCESS if successful.
    Error code on failure.

--*/
{
    PWSTR       padapterDomainName = NULL;

    DNSDBG( TRACE, (
        "Reg_DefaultAdapterInfo( %p, %p, %p )\n",
        pBlob,
        pRegInfo,
        pIpAdapter ));

    if ( !pBlob || !pRegInfo || !pIpAdapter )
    {
        return  ERROR_INVALID_PARAMETER;
    }

    //
    //  clear adapter blob
    //

    RtlZeroMemory(
        pBlob,
        sizeof(*pBlob) );


    //
    //  query with adapter name
    //      - OFF global overrides
    //

    pBlob->fQueryAdapterName = g_QueryAdapterName;

    //
    //  check if adapter IPs get registered
    //      - OFF global overrides
    //

    pBlob->fRegistrationEnabled = g_RegistrationEnabled;

    //
    //  adapter name registration
    //      - policy may override
    //      - OFF global overrides
    //      - then adapter
    //

    if ( pRegInfo->fPolicyRegisterAdapterName )
    {
        pBlob->fRegisterAdapterName = pRegInfo->fRegisterAdapterName;
    }
    else
    {
        pBlob->fRegisterAdapterName = g_RegisterAdapterName;
    }

    //
    //  max addresses to register
    //

    if ( pBlob->fRegistrationEnabled )
    {
        pBlob->RegistrationMaxAddressCount = g_RegistrationMaxAddressCount;
    }

    //
    //  get adapter name
    //     - policy may override AND
    //     allow policy to override with NULL string to kill domain name
    //

    padapterDomainName = pRegInfo->pszAdapterDomainName;

    if ( !padapterDomainName )
    {
        padapterDomainName = pIpAdapter->DnsSuffix;
    }

    if ( padapterDomainName )
    {
        if ( IS_EMPTY_STRING( padapterDomainName ) )
        {
            padapterDomainName = NULL;
        }
        else
        {
            padapterDomainName = Dns_CreateStringCopy_W( padapterDomainName );
        }
        pBlob->pszAdapterDomainName = padapterDomainName;
    }

    DNSDBG( TRACE, (
        "Leave Reg_DefaultAdapterInfo()\n"
        "\tDomainName           = %S\n"
        "\tQueryAdapterName     = %d\n"
        "\tRegistrationEnabled  = %d\n"
        "\tRegisterAdapterName  = %d\n"
        "\tRegisterAddrCount    = %d\n",
        pBlob->pszAdapterDomainName,
        pBlob->fQueryAdapterName,
        pBlob->fRegistrationEnabled,
        pBlob->fRegisterAdapterName,
        pBlob->RegistrationMaxAddressCount
        ));

    return  ERROR_SUCCESS;
}



DNS_STATUS
Reg_ReadAdapterInfoA(
    IN      PSTR                    pszAdapterName,
    IN      PREG_SESSION            pRegSession,
    IN      PREG_GLOBAL_INFO        pRegInfo,
    OUT     PREG_ADAPTER_INFO       pBlob
    )
/*++

Routine Description:

    Read adapter registry info.  ANSI version.

    This is available simply for use with IPHelp
    PIP_ADAPTER_ADDRESSES  structure which has
    ANSI adapter name (for some reason).

Arguments:

    pszAdapterName -- adapter name (registry name)

    pRegSession -- registry session

    pRegInfo    -- registry global info

    pBlob       -- adapter info blob to fill in

Return Value:

    ERROR_SUCCESS if successful.
    Error code on failure.

--*/
{
    DWORD       nameBufLength = MAX_PATH * sizeof(WCHAR);
    WCHAR       wideName[ MAX_PATH ];

    DNSDBG( TRACE, (
        "ReadRegAdapterInfoA( %s, %p, %p, %p )\n",
        pszAdapterName,
        pRegSession,
        pRegInfo,
        pBlob ));

    //
    //  convert adapter name to unicode
    //

    if ( ! pszAdapterName ||
         ! Dns_StringCopy(
                (PCHAR) wideName,
                & nameBufLength,
                pszAdapterName,
                0,
                DnsCharSetAnsi,
                DnsCharSetUnicode ) )
    {
        return  ERROR_INVALID_PARAMETER;
    }

    return  Reg_ReadAdapterInfo(
                wideName,
                pRegSession,
                pRegInfo,
                pBlob );
}



VOID
Reg_FreeAdapterInfo(
    IN OUT  PREG_ADAPTER_INFO   pRegAdapterInfo,
    IN      BOOL                fFreeBlob
    )
/*++

Routine Description:

    Free registry adapter info blob.

Arguments:

    pRegAdapterInfo -- adapter registry info blob to free

    fFreeBlob -- flag to free blob itself
        FALSE -- just free allocated data fields
        TRUE  -- also free blob itself

Return Value:

    ERROR_SUCCESS if successful.
    Error code on failure.

--*/
{
    DNSDBG( TRACE, (
        "FreeRegAdapterInfo( %p )\n",
        pRegAdapterInfo ));

    //
    //  free data
    //      - adapter domain name
    //

    if ( pRegAdapterInfo->pszAdapterDomainName )
    {
        FREE_HEAP( pRegAdapterInfo->pszAdapterDomainName );
        pRegAdapterInfo->pszAdapterDomainName = NULL;
    }

    //  free blob itself

    if ( fFreeBlob )
    {
        FREE_HEAP( pRegAdapterInfo );
    }
}



DNS_STATUS
Reg_ReadUpdateInfo(
    IN      PWSTR               pszAdapterName,
    OUT     PREG_UPDATE_INFO    pUpdateInfo
    )
/*++

Routine Description:

    Read update info.

    //
    //  DCR:  shouldn't need this routine, just get NETINFO
    //      this blob is just mix of global stuff and
    //      mostly adapter stuff
    //      even if want in single blob for update routines --
    //      ok, but not ideal -- 
    //      should be getting blob from resolver and reformatting
    //      info;
    //      reg read should happen just once producing network
    //      info in resolver
    //

Arguments:

    pszAdapterName -- adapter name

    pUpdateInfo -- blob to hold reg info

Return Value:

    ERROR_SUCCESS if successful.
    Error code on failure.

--*/
{
    DNS_STATUS          status;
    REG_SESSION         regSession;
    PREG_SESSION        pregSession;
    REG_GLOBAL_INFO     regInfo;
    REG_ADAPTER_INFO    regAdapterInfo;
    BOOL                freadRegInfo = FALSE;
    BOOL                freadRegAdapterInfo = FALSE;

    DNSDBG( TRACE, (
        "Reg_ReadUpdateInfo( %S, %p )\n",
        pszAdapterName,
        pUpdateInfo ));

    //
    //  clear update info blob
    //

    RtlZeroMemory(
        pUpdateInfo,
        sizeof( *pUpdateInfo ) );

    //
    //  open the registry
    //

    pregSession = &regSession;
    
    status = Reg_OpenSession(
                pregSession,
                0,
                0 );
    if ( status != ERROR_SUCCESS )
    {
        return( status );
    }

    //
    //  read registry
    //      - global DWORDs
    //      - global info
    //      - adapter specific info
    //
    //  DCR_PERF:  global read should be RPC
    //  DCR_REG:  fix this with reg read
    //      have flag for IN caching resolver process (skip RPC)
    //      have cookie for last read
    //

#if 0
    //  Reg_ReadGlobalInfo() calls Reg_ReadGlobalsEx()
    status = Reg_ReadGlobalsEx(
                0,              // no flag, update variables desired
                pregSession
                );
#endif

    status = Reg_ReadGlobalInfo(
                pregSession,
                & regInfo );

    if ( status != ERROR_SUCCESS )
    {
        goto Done;
    }
    freadRegInfo = TRUE;

    status = Reg_ReadAdapterInfo(
                pszAdapterName,
                pregSession,
                & regInfo,
                & regAdapterInfo );

    if ( status != ERROR_SUCCESS )
    {
        goto Done;
    }
    freadRegAdapterInfo = TRUE;

    //
    //  alternate computer name
    //

    Reg_GetValue(
        pregSession,
        NULL,           // no key
        RegIdAlternateNames,
        REGTYPE_ALTERNATE_NAMES,
        (PBYTE *) &pUpdateInfo->pmszAlternateNames
        );

    //
    //  set update results
    //      - PDN always needed
    //      - adapter domain if policy override
    //      - DNS servers if policy override
    //
    //  note, in all cases we don't realloc, we steal the
    //  info and NULL it out so not freed on cleanup
    //

    pUpdateInfo->pszPrimaryDomainName = regInfo.pszPrimaryDomainName;
    regInfo.pszPrimaryDomainName = NULL;

    pUpdateInfo->pszAdapterDomainName = regInfo.pszAdapterDomainName;
    regInfo.pszAdapterDomainName = NULL;
                
    pUpdateInfo->pDnsServerArray = regInfo.pDnsServerArray;
    regInfo.pDnsServerArray = NULL;

    pUpdateInfo->pDnsServerIp6Array = regInfo.pDnsServerIp6Array;
    regInfo.pDnsServerIp6Array = NULL;

    //  update flags

    pUpdateInfo->fRegistrationEnabled = regAdapterInfo.fRegistrationEnabled;
    pUpdateInfo->fRegisterAdapterName = regAdapterInfo.fRegisterAdapterName;
    pUpdateInfo->RegistrationMaxAddressCount =
                                regAdapterInfo.RegistrationMaxAddressCount;

Done:

    //
    //  cleanup
    //

    if ( pregSession )
    {
        Reg_CloseSession( pregSession );
    }

    //  don't free blobs -- they're on stack

    if ( freadRegInfo )
    {
        Reg_FreeGlobalInfo( &regInfo, FALSE );
    }
    if ( freadRegAdapterInfo )
    {
        Reg_FreeAdapterInfo( &regAdapterInfo, FALSE );
    }

    DNSDBG( TRACE, (
        "Leave Reg_ReadUpdateInfo( %S )\n"
        "\tPDN                  = %S\n"
        "\tAlternateNames       = %S\n"
        "\tAdapterDomainName    = %S\n"
        "\tDNS servers          = %p\n"
        "\tDNS servers IP6      = %p\n"
        "\tRegister             = %d\n"
        "\tRegisterAdapterName  = %d\n"
        "\tRegisterAddrCount    = %d\n",
        pszAdapterName,
        pUpdateInfo->pszPrimaryDomainName,
        pUpdateInfo->pmszAlternateNames,
        pUpdateInfo->pszAdapterDomainName,
        pUpdateInfo->pDnsServerArray,
        pUpdateInfo->pDnsServerIp6Array,
        pUpdateInfo->fRegistrationEnabled,
        pUpdateInfo->fRegisterAdapterName,
        pUpdateInfo->RegistrationMaxAddressCount
        ));

    return  ERROR_SUCCESS;
}



VOID
Reg_FreeUpdateInfo(
    IN OUT  PREG_UPDATE_INFO    pUpdateInfo,
    IN      BOOL                fFreeBlob
    )
/*++

Routine Description:

    Free registry update info blob.

Arguments:

    pUpdateInfo -- update registry info blob to free

    fFreeBlob -- flag to free blob itself
        FALSE -- just free allocated data fields
        TRUE  -- also free blob itself

Return Value:

    ERROR_SUCCESS if successful.
    Error code on failure.

--*/
{
    DNSDBG( TRACE, (
        "FreeRegUpdateInfo( %p )\n",
        pUpdateInfo ));

    //
    //  free data
    //      - PDN
    //      - adapter domain name
    //      - DNS server lists
    //

    if ( pUpdateInfo->pszPrimaryDomainName )
    {
        FREE_HEAP( pUpdateInfo->pszPrimaryDomainName );
    }
    if ( pUpdateInfo->pmszAlternateNames )
    {
        FREE_HEAP( pUpdateInfo->pmszAlternateNames );
    }
    if ( pUpdateInfo->pszAdapterDomainName )
    {
        FREE_HEAP( pUpdateInfo->pszAdapterDomainName );
    }
    if ( pUpdateInfo->pDnsServerArray )
    {
        FREE_HEAP( pUpdateInfo->pDnsServerArray );
    }
    if ( pUpdateInfo->pDnsServerIp6Array )
    {
        FREE_HEAP( pUpdateInfo->pDnsServerIp6Array );
    }

    //  free blob itself

    if ( fFreeBlob )
    {
        FREE_HEAP( pUpdateInfo );
    }
}



//
//  Special
//

DNS_STATUS
Reg_WriteLoopbackDnsServerList(
    IN      PWSTR           pszAdapterName,
    IN      PREG_SESSION    pRegSession
    )
/*++

Routine Description:

    Write loopback IP as DNS server list.

Arguments:

    pszAdapterName -- adapter name (registry name)

    pRegSession -- registry session

Return Value:

    ERROR_SUCCESS if successful.
    Error code on failure.

--*/
{
    DNS_STATUS  status;
    HKEY        hkeyAdapter = NULL;
    WCHAR       adapterParamKey[ MAX_PATH+1 ];
    PWSTR       pstring;

    DNSDBG( TRACE, (
        "Reg_WriteLookupbackDnsServerList( %S )\n",
        pszAdapterName ));

    //
    //  open adapter key for write
    //
    //  DCR:  fail on adapter key name overflow
    //

    if ( !pszAdapterName )
    {
        return  ERROR_INVALID_NAME;
    }

    _snwprintf(
        adapterParamKey,
        MAX_PATH,
        L"%s%s",
        TCPIP_INTERFACES_KEY,
        pszAdapterName );

    adapterParamKey[ MAX_PATH ] = 0;

    status = RegOpenKeyExW(
                HKEY_LOCAL_MACHINE,
                adapterParamKey,
                0,
                KEY_READ | KEY_WRITE,
                & hkeyAdapter );

    if ( status != NO_ERROR )
    {
        return( status );
    }

    //
    //  write loopback address
    //

    pstring = L"127.0.0.1";

    status = RegSetValueExW(
                    hkeyAdapter,
                    DNS_SERVERS,
                    0,
                    REGTYPE_DNS_SERVER,
                    (PBYTE) pstring,
                    (wcslen(pstring)+1) * sizeof(WCHAR) );

    RegCloseKey( hkeyAdapter );

    return( status );
}



//
//  PDN Query
//

PSTR 
WINAPI
Reg_GetPrimaryDomainName(
    IN      DNS_CHARSET     CharSet
    )
/*++

Routine Description:

    Get primary domain name (PDN).

Arguments:

    CharSet -- desired char set.

Return Value:

    Ptr to primary domain name in desired charset.

--*/
{
    DNS_STATUS  status;
    PWSTR       pnameW = NULL;
    PSTR        pnameReturn;

    status = Reg_ReadPrimaryDomainName(
                NULL,           // no session
                NULL,           // no regkey
                &pnameW );

    if ( !pnameW )
    {
        SetLastError( status );
        return  NULL;
    }

    //
    //  convert to desired char set
    //

    if ( CharSet == DnsCharSetUnicode )
    {
        return  (PSTR) pnameW;
    }
    else
    {
        pnameReturn = Dns_NameCopyAllocate(
                            (PBYTE) pnameW,
                            0,
                            DnsCharSetUnicode,
                            CharSet );

        FREE_HEAP( pnameW );
        return  pnameReturn;
    }
}



//
//  Hostname query
//

PSTR 
WINAPI
Reg_GetHostName(
    IN      DNS_CHARSET     CharSet
    )
/*++

Routine Description:

    Get host name.

Arguments:

    CharSet -- desired char set.

Return Value:

    Ptr to host name in desired charset.

--*/
{
    PWSTR       pnameW = NULL;
    PSTR        pnameReturn;
    DNS_STATUS  status;

    //
    //  get hostname from registry
    //

    status = Reg_GetValue(
                NULL,           // no session
                NULL,           // no key
                RegIdHostName,
                REGTYPE_DNS_NAME,
                (PBYTE *) &pnameW
                );

    if ( !pnameW )
    {
        SetLastError( status );
        return  NULL;
    }

    //
    //  convert to desired char set
    //

    if ( CharSet == DnsCharSetUnicode )
    {
        return  (PSTR) pnameW;
    }
    else
    {
        pnameReturn = Dns_NameCopyAllocate(
                            (PBYTE) pnameW,
                            0,
                            DnsCharSetUnicode,
                            CharSet );

        FREE_HEAP( pnameW );
        return  pnameReturn;
    }
}



PSTR 
WINAPI
Reg_GetFullHostName(
    IN      DNS_CHARSET     CharSet
    )
/*++

Routine Description:

    Get full host name.

Arguments:

    CharSet -- desired char set.

Return Value:

    Ptr to full host name in desired charset.

--*/
{
    PWSTR       pnameW = NULL;
    PWSTR       pdomainW = NULL;
    PSTR        presult = NULL;
    DNS_STATUS  status;
    WCHAR       nameBuffer[ DNS_MAX_NAME_BUFFER_LENGTH+4 ];

    //
    //  get hostname from registry
    //

    status = Reg_GetValue(
                NULL,           // no session
                NULL,           // no key
                RegIdHostName,
                REGTYPE_DNS_NAME,
                (PBYTE *) &pnameW
                );
    if ( !pnameW )
    {
        SetLastError( status );
        return  NULL;
    }

    //
    //  get domain name from registry
    //

    status = Reg_ReadPrimaryDomainName(
                NULL,           // no session
                NULL,           // no regkey
                &pdomainW );

    if ( status != ERROR_SUCCESS )
    {
        SetLastError( status );
        return  NULL;
    }

    //
    //  create appended name
    //      - wire format is narrow
    //
    //  allocate result in desired char set
    //

    if ( pdomainW )
    {
        if ( Dns_NameAppend_W(
                nameBuffer,
                DNS_MAX_NAME_BUFFER_LENGTH,
                pnameW,
                pdomainW ) )
        {
            presult = Dns_NameCopyAllocate(
                        (PBYTE) nameBuffer,
                        0,
                        DnsCharSetUnicode,
                        CharSet );
        }
    }
    else
    {
        presult = Dns_NameCopyAllocate(
                    (PBYTE) pnameW,
                    0,
                    DnsCharSetUnicode,
                    CharSet );
    }    
    
    //
    //  free registry allocations
    //

    FREE_HEAP( pnameW );
    FREE_HEAP( pdomainW );

    return  presult;
}



//
//  DWORD Get\Set
//

DWORD
Reg_ReadDwordValueFromGlobal(
    IN      DWORD           PropId
    )
/*++

Routine Description:

    Read DWORD from global.

    This is direct access to global through RegId,
    rather than by name.  

Arguments:

    PropId -- property ID of desired value

Return Value:

    ERROR_SUCCESS if successful.
    ErrorCode on failure.

--*/
{
    PDWORD  pdword;

    //
    //  validate PropId -- within DWORD array
    //

    if ( PropId > RegIdValueGlobalMax )
    {
        DNS_ASSERT( FALSE );
        return( 0 );
    }

    //
    //  get DWORD ptr and read value (if exists)
    //      

    pdword = RegDwordPtrArray[ PropId ];

    if ( !pdword )
    {
        DNS_ASSERT( FALSE );
        return( 0 );
    }

    return( *pdword );
}



DWORD
Reg_ReadDwordProperty(
    IN      DNS_REGID       RegId,
    IN      PWSTR           pwsAdapterName  OPTIONAL
    )
/*++

Routine Description:

    Read through to registry for DWORD\BOOL value.

    Simplified interface for DWORD reads.

Arguments:

    RegId -- registry ID of value

    pwsAdapterName -- adapter name if adapter specific registration
        value is desired
                              
Return Value:

    Value for global -- from registry or defaulted

--*/
{
    DWORD   value;

    //
    //  read value
    //

    Reg_GetDword(
        NULL,               // no session
        NULL,               // no key given
        pwsAdapterName,
        RegId,
        & value );

    return( value );
}



DNS_STATUS
WINAPI
Reg_SetDwordPropertyAndAlertCache(
    IN      PWSTR           pwsKey,
    IN      DWORD           RegId,
    IN      DWORD           dwValue
    )
/*++

Routine Description:

    Write DWORD property -- cause cache to reload config.

Arguments:

    pwsRey -- key or adapater name to set

    RegId -- reg id

    dwValue -- value to set

Return Value:

    None.

--*/
{
    DNS_STATUS  status;

    //  set value

    status = Reg_SetDwordValue(
                NULL,       // reserved
                NULL,       // no open key
                pwsKey,
                RegId,
                dwValue );

    //
    //  if reg write successful
    //      - poke cache
    //      - mark any local netinfo dirty
    //      

    if ( status == NO_ERROR )
    {
        DnsNotifyResolverEx(
            POKE_OP_UPDATE_NETINFO,
            0,
            POKE_COOKIE_UPDATE_NETINFO,
            NULL );

        NetInfo_MarkDirty();
    }

    return  status;
}



//
//  Environment variable configuration
//

BOOL
Reg_ReadDwordEnvar(
    IN      DWORD               Id,
    OUT     PENVAR_DWORD_INFO   pEnvar
    )
/*++

Routine Description:

    Read DWORD environment variable.

    Note:  this function read environment variables that allow
    per process control of registry configurable params.
    The environment variable is assumed to be the same
    as the regkey with Dns prepended ( Dns<regvalue name> ).

    Ex.  FilterClusterIp controlled with envar DnsFilterClusterIp.

Arguments:

    Id -- registry ID (registry.h) of environment value to read

    pEnvar -- ptr to blob to hold results

Return Value:

    ERROR_SUCCESS if successful.
    ErrorCode on failure.

--*/
{
    DWORD   count;
    PWSTR   pnameBuffer;
    PWSTR   pvarBuffer;
    BOOL    found = FALSE;

    DNSDBG( TRACE, (
        "Reg_ReadDwordEnvar( %d, %p )\n",
        Id,
        pEnvar ));

    if ( Id > RegIdValueGlobalMax )
    {
        DNS_ASSERT( FALSE );
        return  FALSE;
    }

    //
    //  init struct (for not found)
    //

    pEnvar->Id      = Id;
    pEnvar->Value   = 0;
    pEnvar->fFound  = FALSE;

    //
    //  prepend "Dns" to reg value name to create environment var name
    //

    pnameBuffer = (PWSTR) ALLOCATE_HEAP( 2 * (sizeof(WCHAR) * MAX_PATH) );
    if ( !pnameBuffer )
    {
        return  FALSE;
    }

    pvarBuffer = pnameBuffer + MAX_PATH;

    wcscpy( pnameBuffer, L"Dns" );
    wcscpy( &pnameBuffer[3], REGPROP_NAME(Id) );

    //
    //  lookup 
    //
    //  note:  no handling of values greater than MAX_PATH
    //      assuming busted string
    //
    //  DCR:  could add base discrimination (scan for non-digit)
    //      or try decimal first
    //      

    DNSDBG( TRACE, (
        "Reg_ReadDwordEnvar() looking up %S.\n",
        pnameBuffer ));

    count = GetEnvironmentVariableW(
                pnameBuffer,
                pvarBuffer,
                MAX_PATH );

    if ( count && count < MAX_PATH )
    {
        pEnvar->Value = wcstoul( pvarBuffer, NULL, 10 );
        found = TRUE;
    }

    pEnvar->fFound = found;

    DNSDBG( TRACE, (
        "Leave Reg_ReadDwordEnvar() %S found=%d, value=%d.\n",
        pnameBuffer,
        pEnvar->fFound,
        pEnvar->Value ));

    FREE_HEAP( pnameBuffer );

    return  found;
}



#if 0
//
//  Remote resolver not currently supported
//

PWSTR
Reg_GetResolverAddress(
    VOID
    )
/*++

Routine Description:

    Get address (string form) of remote resolver.

Arguments:

    None

Return Value:

    Ptr to string of remote resolver name.

--*/
{
    PWSTR pnameResolver = NULL;

    Reg_GetValueEx(
        NULL,                   // no session
        NULL,                   // no key
        NULL,                   // no adapter
        RegIdRemoteResolver,
        REGTYPE_DNS_NAME,
        DNSREG_FLAG_GET_UNICODE | DNSREG_FLAG_DUMP_EMPTY,
        (PBYTE *) &pnameResolver
        );

    return pnameResolver;
}
#endif

//
//  End regfig.c
//
=== C:/Users/treeman/Desktop/windows nt source code\Source\Win2K3\NT\ds\dns\dnsapi\queue.c ===
/*++

Copyright (c) 1997-2000  Microsoft Corporation

Module Name:

    queue.c

Abstract:

    Domain Name System (DNS) Server
    Queue functionality specific to Dynamic DNS registration.

Author:

    Ram Viswanathan (ramv)  March 27 1997

Revision History:

--*/


#include "local.h"


extern DWORD g_DhcpSrvMainQueueCount;

//
//  Queue CS also used in dynreg.c
//

CRITICAL_SECTION    g_QueueCS;

//
//  Queue allocations in dnslib heap
//

#define QUEUE_ALLOC_HEAP(Size)      Dns_Alloc(Size)
#define QUEUE_ALLOC_HEAP_ZERO(Size) Dns_AllocZero(Size)
#define QUEUE_FREE_HEAP(pMem)       Dns_Free(pMem)


//
//  Protos
//

PQELEMENT
DequeueNoCrit(
    PDYNDNSQUEUE  pQueue
    );

DWORD
AddToTimedOutQueueNoCrit(
    PQELEMENT     pNewElement,
    PDYNDNSQUEUE  pRetryQueue,
    DWORD         dwRetryTime
    );

VOID
DeleteListEntry(
    PDYNDNSQUEUE  pQueue,
    PQELEMENT*    ppQElement
    );



VOID
DhcpSrv_FreeQueueElement(
    IN OUT  PQELEMENT       pQElement
    )
/*++

Routine Description:

    Deep free of queue element.

Arguments:

    pQElement -- ptr to queue element

Return Value:

    None

--*/
{
    if ( pQElement )
    {
        if ( pQElement->pszName )
        {
            QUEUE_FREE_HEAP( pQElement->pszName );
        }
        if ( pQElement->DnsServerList )
        {
            QUEUE_FREE_HEAP( pQElement->DnsServerList );
        }
        QUEUE_FREE_HEAP( pQElement );
    }
}


DWORD
HostAddrCmp(
    REGISTER_HOST_ENTRY HostAddr1,
    REGISTER_HOST_ENTRY HostAddr2
    )
{
    //
    //  DCR:  Ram's HostAddrCmp will need update for IPv6
    //
    //  returns 0 if the two hostaddresses are the same. Else we simply
    //  return (DWORD)-1
    //

    if ( (HostAddr1.dwOptions == HostAddr2.dwOptions)  &&
         (HostAddr1.Addr.ipAddr == HostAddr2.Addr.ipAddr))
    {
        return(0);
    }

    return( (DWORD)-1 );
}



DWORD
InitializeQueues(
    PDYNDNSQUEUE * ppQueue,
    PDYNDNSQUEUE * ppTimedOutQueue
    )
/*
  InitializeQueue()

  This function initializes the queue system. This is invoked for the first
  time when you create the main queue and timed out queue

  Allocates appropriate memory etc

*/
{

    DWORD  dwRetval = ERROR_SUCCESS;

    *ppQueue = (PDYNDNSQUEUE) QUEUE_ALLOC_HEAP_ZERO( sizeof(DYNDNSQUEUE) );

    if (!*ppQueue)
    {
        dwRetval = GetLastError();
        goto Exit;
    }

    *ppTimedOutQueue = (PDYNDNSQUEUE) QUEUE_ALLOC_HEAP_ZERO( sizeof(DYNDNSQUEUE) );
    if (!*ppTimedOutQueue)
    {
        dwRetval = GetLastError();
        goto Exit;
    }


    (*ppQueue)->pHead = NULL;
    (*ppQueue)->pTail = NULL;

    (*ppTimedOutQueue)->pHead = NULL;
    (*ppTimedOutQueue)->pTail = NULL;

Exit:

    if ( dwRetval )
    {
        FreeQueue( *ppQueue );
        FreeQueue( *ppTimedOutQueue );
    }
    return(dwRetval);
}


DWORD
FreeQueue(
    PDYNDNSQUEUE  pQueue
    )
/*
  FreeQueue()

  Frees the queue object. If there exist any entries in the queue, we
  just blow them away

*/
{
    PQELEMENT pQElement;
    DWORD dwRetval = ERROR_SUCCESS;

    EnterCriticalSection(&g_QueueCS);

    if ( !pQueue )
    {
        dwRetval = ERROR_SUCCESS;
        goto Exit;
    }

    while ( pQueue->pHead )
    {
        pQElement = DequeueNoCrit(pQueue);
        DNS_ASSERT(pQElement);

        DhcpSrv_FreeQueueElement( pQElement );
    }

    QUEUE_FREE_HEAP( pQueue );

Exit:

    LeaveCriticalSection(&g_QueueCS);
    return(ERROR_SUCCESS);
}


DWORD
Enqueue(
    PQELEMENT     pNewElement,
    PDYNDNSQUEUE  pQueue,
    PDYNDNSQUEUE  pTimedOutQueue
    )
/*
   Enqueue()

   Adds new element to queue

   Arguments:

   Return Value:

    is 0 if Success. and (DWORD)-1 if failure.

*/
{
    PQELEMENT  pIterator = NULL;
    DWORD      dwRetval = 0;
    DWORD      dwRetryTime = 0;

    pNewElement->pFLink = NULL;
    pNewElement->pBLink = NULL;
    pNewElement->dwRetryTime = 0;
    pNewElement->dwRetryCount = 0;

    EnterCriticalSection(&g_QueueCS);

    if (!pQueue || !pTimedOutQueue)
    {
        dwRetval = (DWORD)-1;
        goto Exit;
    }

    // add to tail of queue

    dwRetryTime = ProcessQDependencies(pTimedOutQueue, pNewElement);

    if (dwRetryTime)
    {
        //
        // we have dependents in timed out queue. Add to timed out queue
        // insert this element at the appropriate position
        //

        AddToTimedOutQueueNoCrit(pNewElement, pTimedOutQueue, dwRetryTime+1);
    }
    else
    {
        ProcessQDependencies(pQueue, pNewElement);

        if ( pQueue->pTail )
        {
            DNS_ASSERT(!pQueue->pTail->pBLink);
            pQueue->pTail->pBLink = pNewElement;
            pNewElement->pFLink = pQueue->pTail;
            pNewElement->pBLink = NULL;
            pQueue->pTail = pNewElement;
        }
        else
        {
            //
            // no tail element means no head element either
            //
            pQueue->pTail = pNewElement;
            pQueue->pHead = pNewElement;
            pNewElement->pBLink = NULL;
            pNewElement->pFLink = NULL;
        }

        g_DhcpSrvMainQueueCount++;
    }

Exit:

    LeaveCriticalSection(&g_QueueCS);

    return (dwRetval);

}

PQELEMENT
DequeueNoCrit(
    PDYNDNSQUEUE  pQueue
    )
/*
   DequeueNoCrit()

   Removes an element from a queue. No Critical Section Used by freequeue
   and by Dequeue

   Arguments:

   Return Value:

    is the element at head of queue if Success. and NULL if failure.

*/
{

    PQELEMENT  pQueuePtr = NULL;
    PQELEMENT  pRet = NULL;

    if (!pQueue || !pQueue->pHead){
        goto Exit;
    }

    pRet = pQueue->pHead;

    pQueuePtr= pRet->pBLink;

    if (pQueuePtr){

        pQueuePtr->pFLink = NULL;
        pQueue->pHead = pQueuePtr;
    } else {
        //
        // no more elements in the Queue
        //

        pQueue->pHead = pQueue->pTail = NULL;
    }

    pRet->pFLink = NULL;
    pRet->pBLink = NULL;

Exit:
    return (pRet);

}


PQELEMENT
Dequeue(
    PDYNDNSQUEUE  pQueue
    )
/*
   Dequeue()

   Removes an element from a queue.

   Arguments:

   Return Value:

    is the element at head of queue if Success. and NULL if failure.

*/
{
    PQELEMENT pQElement = NULL;

    EnterCriticalSection(&g_QueueCS);

    pQElement = DequeueNoCrit(pQueue);

    LeaveCriticalSection(&g_QueueCS);

    return (pQElement);
}



DWORD
AddToTimedOutQueueNoCrit(
    PQELEMENT     pNewElement,
    PDYNDNSQUEUE  pRetryQueue,
    DWORD         dwRetryTime
    )
/*
   AddToTimedOutQueueNoCrit()

   Adds new element to timedout queue. Now the new element is added in a list
   of elements sorted according to decreasing order of Retry Times. An
   insertion sort type of algorithm is used.

   Arguments:

   Return Value:

   is 0 if Success. and (DWORD)-1 if failure.

*/
{
    DWORD       dwRetval = ERROR_SUCCESS;
    PQELEMENT   pTraverse = NULL;
    DWORD       dwVal = 0;
    //
    // parameter validation
    //

    if(!pNewElement || !pRetryQueue){
        dwRetval = (DWORD)-1;
        goto Exit;
    }

    // retry again in dwRetryTime
    pNewElement->dwRetryTime = dwRetryTime;

    pNewElement->dwRetryCount++;

    //
    // check to see if there are any dependencies
    //

    dwVal = ProcessQDependencies (
                pRetryQueue,
                pNewElement
                );

    //
    // ignore return values because we are inserting in the new queue
    // at a position determined by dwRetryTime
    //
    if (!pRetryQueue->pTail){
        //
        // the queue has no elements
        // no tail element means no head element either
        //
        pRetryQueue->pTail = pNewElement;
        pRetryQueue->pHead = pNewElement;
        dwRetval = 0;
        goto Exit;
    }


    //
    // elements must be added in decreasing order of timeouts.
    // go in and scan the list from the head.
    //

    pTraverse = pRetryQueue->pHead;

    while ( pTraverse !=NULL &&
            pTraverse->dwRetryTime <= pNewElement->dwRetryTime)
    {
        pTraverse = pTraverse->pBLink;
    }

    if (pTraverse == NULL)
    {
        // Now adding to the tail of the list

        pNewElement->pFLink = pRetryQueue->pTail;
        pNewElement->pBLink = NULL;
        pRetryQueue->pTail->pBLink = pNewElement;
        pRetryQueue->pTail = pNewElement;
    }
    else
    {
        // insert in place

        pNewElement->pBLink = pTraverse;
        pNewElement->pFLink = pTraverse->pFLink;
        if (pTraverse->pFLink)
        {
            pTraverse->pFLink->pBLink = pNewElement;
        }
        pTraverse->pFLink = pNewElement;
    }


Exit:
    return (dwRetval);
}



DWORD
AddToTimedOutQueue(
    PQELEMENT     pNewElement,
    PDYNDNSQUEUE  pRetryQueue,
    DWORD         dwRetryTime
    )

{
    DWORD dwRetval = ERROR_SUCCESS;

    EnterCriticalSection(&g_QueueCS);

    dwRetval = AddToTimedOutQueueNoCrit(
                   pNewElement,
                   pRetryQueue,
                   dwRetryTime
                   );

    LeaveCriticalSection(&g_QueueCS);

    return (dwRetval);

}


DWORD
GetEarliestRetryTime(
    PDYNDNSQUEUE pRetryQueue
    )

/*
   GetEarliestRetryTime()

   Checks to see if there is any element at the head of the queue
   and gets the retry time for this element

   Arguments:

   Return Value:

    is retrytime if success and DWORD(-1) if there is no element or other
    failure

*/
{
    DWORD dwRetryTime ;

    EnterCriticalSection(&g_QueueCS);


    dwRetryTime = pRetryQueue && pRetryQueue->pHead ?
        (pRetryQueue->pHead->dwRetryTime):
        (DWORD)-1;

    LeaveCriticalSection(&g_QueueCS);

    return dwRetryTime;

}

/*
VOID
ProcessMainQDependencies(
    PDYNDNSQUEUE pQueue,
    PQELEMENT    pQElement
    )
{

    //
    // when you are adding an element to a main queue, you
    // just care about the case where all elements aren't
    // FORWARD_ONLY
    //

    BOOL fDelThisTime = FALSE;
    PQELEMENT pIterator = pQueue->pTail;

    while (pIterator!= NULL){

        fDelThisTime = FALSE;
        if (!HostAddrCmp(pIterator->HostAddr, pQElement->HostAddr)){
            //
            // ip addresses matched
            //

            if ((pIterator->dwOperation & DYNDNS_ADD_ENTRY) &&
                (pQElement->dwOperation & DYNDNS_DELETE_ENTRY)) {

                if ( pIterator->pszName &&
                     pQElement->pszName &&
                     !wcsicmp_ThatWorks( pIterator->pszName,
                                         pQElement->pszName ) )
                {
                    //
                    // blow away earlier entry entirely
                    //

                    DeleteListEntry(pQueue, &pIterator);
                    fDelThisTime = TRUE;

                }
                //
                // if names are not the same do nothing.
                // Issue:  Will we hit this code at all? Put
                // soft ASSERTS in this.
                //
            }
            else if ((pIterator->dwOperation & DYNDNS_DELETE_ENTRY) &&
                (pQElement->dwOperation & DYNDNS_ADD_ENTRY)) {


                if ( pIterator->pszName &&
                     pQElement->pszName &&
                     !wcsicmp_ThatWorks( pIterator->pszName,
                                         pQElement->pszName ) )
                {
                    //
                    // blow away earlier entry entirely
                    //
                    DeleteListEntry(pQueue, &pIterator);
                    fDelThisTime = TRUE;
                } else {
                    //
                    // replace iterator element with just the forward
                    // delete

                    if (!pIterator->fDoForward) {
                        //
                        // there is no forward that is requested
                        // blow away this entry
                        //

                        DeleteListEntry(pQueue, &pIterator);
                        fDelThisTime = TRUE;
                    } else {
                        //
                        // if you want to do a forward. Then just do
                        // the forward. Ignore reverses
                        //
                        pIterator ->fDoForwardOnly = TRUE;
                    }
                }

            }
            else if ((pIterator->dwOperation & DYNDNS_ADD_ENTRY) &&
                     (pQElement->dwOperation & DYNDNS_ADD_ENTRY)) {

                // replace the old entry with a forward delete.
                // this is an error. Need to replace earlier add
                // forward with an explicit Delete
                //

                if ( pIterator->pszName &&
                     pQElement->pszName &&
                     !wcsicmp_ThatWorks( pIterator->pszName,
                                         pQElement->pszName ) )
                {
                    DeleteListEntry(pQueue, &pIterator);
                    fDelThisTime = TRUE;
                } else {
                    //
                    // Log entries into this area. This should
                    // be a soft assert if you are here
                    // Names dont match, so you need to replace earlier
                    // add with a delete forward only
                    //

                    if (!pIterator->fDoForward) {
                        //
                        // there is no forward add requested
                        // blow away this entry
                        //

                        DeleteListEntry(pQueue, &pIterator);
                        fDelThisTime = TRUE;
                    } else {
                        //
                        // if you want to *explicitly* delete old
                        // forward and then add the new forward/reverse.
                        //
                        pIterator ->fDoForwardOnly = TRUE;
                        pIterator ->dwOperation &=
                            ~(DYNDNS_ADD_ENTRY) & DYNDNS_DELETE_ENTRY;
                    }

                }
            }
            else if ((pIterator->dwOperation & DYNDNS_DELETE_ENTRY) &&
                     (pQElement->dwOperation & DYNDNS_DELETE_ENTRY)) {

                //
                // if both are deletes.
                //

                if ( pIterator->pszName &&
                     pQElement->pszName &&
                     !wcsicmp_ThatWorks( pIterator->pszName,
                                         pQElement->pszName ) )
                {
                    //
                    // blow away earlier entry. An optimization
                    //
                    DeleteListEntry(pQueue, &pIterator);
                    fDelThisTime = TRUE;
                }
                //
                // if names dont match, do nothing. (To paraphrase,
                // the DNS Server needs to do both!!
                //

            }
        }

        if (pIterator && !fDelThisTime) {

            // pIterator may have changed because of blowing away an entry

            pIterator = pIterator->pFLink;
        }
    }
}

*/

DWORD
ProcessQDependencies(
    PDYNDNSQUEUE pTimedOutQueue,
    PQELEMENT    pQElement
    )

/*
  This function returns the retry time of the last element that you
  needed to blow out, 0 if no element needed to be removed

*/
{
    PQELEMENT pIterator = pTimedOutQueue->pTail;
    DWORD   dwRetryTime = 0;
    BOOL    fDelThisTime = FALSE;

    while (pIterator) {

        fDelThisTime = FALSE;

        if (!pIterator->fDoForwardOnly && !pQElement->fDoForwardOnly){
            //
            // both elements are not forward only, check on ip addresses
            //
            if (!HostAddrCmp(pIterator->HostAddr, pQElement->HostAddr)){
                //
                // ip addresses matched
                //

                if ((pIterator->dwOperation & DYNDNS_ADD_ENTRY) &&
                    (pQElement->dwOperation & DYNDNS_DELETE_ENTRY)) {

                    if ( pIterator->pszName &&
                         pQElement->pszName &&
                         !wcsicmp_ThatWorks( pIterator->pszName,
                                             pQElement->pszName ) )
                    {
                        //
                        // blow away earlier entry entirely
                        //
                        dwRetryTime = pIterator -> dwRetryTime;
                        DeleteListEntry(pTimedOutQueue, &pIterator);
                        fDelThisTime = TRUE;
                    }
                    //
                    // if names are not the same do nothing.
                    //
                    // Issue:  Will we hit this code at all? Put
                    // soft ASSERTS in this.
                    //

                }else if ((pIterator->dwOperation & DYNDNS_DELETE_ENTRY) &&
                         (pQElement->dwOperation & DYNDNS_ADD_ENTRY)) {


                    if ( pIterator->pszName &&
                         pQElement->pszName &&
                         !wcsicmp_ThatWorks( pIterator->pszName,
                                             pQElement->pszName ) )
                    {
                        //
                        // blow away earlier entry entirely
                        //
                        dwRetryTime = pIterator -> dwRetryTime;
                        DeleteListEntry(pTimedOutQueue, &pIterator);
                        fDelThisTime = TRUE;
                    } else {

                        // replace iterator element with just the forward

                        dwRetryTime = pIterator -> dwRetryTime;
                        pIterator -> fDoForwardOnly = TRUE;
                    }

                }else if ((pIterator->dwOperation & DYNDNS_ADD_ENTRY) &&
                         (pQElement->dwOperation & DYNDNS_ADD_ENTRY)) {

                    // replace the old entry with a forward delete.
                    // this is an error. Need to replace earlier add
                    // forward with an explicit Delete
                    //

                    if ( pIterator->pszName &&
                         pQElement->pszName &&
                         !wcsicmp_ThatWorks( pIterator->pszName,
                                             pQElement->pszName ) )
                    {
                        DeleteListEntry(pTimedOutQueue, &pIterator);
                        fDelThisTime = TRUE;
                    } else {
                        //
                        // Log entries into this area. This should
                        // be a soft assert if you are here
                        // Names dont match, so you need to replace earlier
                        // add with a delete forward only
                        //

                        if (!pIterator->fDoForward) {
                            //
                            // there is no forward add requested
                            // blow away this entry
                            //

                            DeleteListEntry(pTimedOutQueue, &pIterator);
                            fDelThisTime = TRUE;
                        } else {
                            //
                            // if you want to *explicitly* delete old
                            // forward and then add the new forward/reverse.
                            //
                            pIterator ->fDoForwardOnly = TRUE;
                            pIterator ->dwOperation &=
                                ~(DYNDNS_ADD_ENTRY) & DYNDNS_DELETE_ENTRY;
                        }
                    }

                }

                else if ((pIterator->dwOperation & DYNDNS_DELETE_ENTRY) &&
                         (pQElement->dwOperation & DYNDNS_DELETE_ENTRY)) {

                    //
                    // if both are deletes.
                    //

                    if ( pIterator->pszName &&
                         pQElement->pszName &&
                         !wcsicmp_ThatWorks( pIterator->pszName,
                                             pQElement->pszName ) )
                    {
                        //
                        // blow away earlier entry. An optimization
                        //
                        DeleteListEntry(pTimedOutQueue, &pIterator);
                        fDelThisTime = TRUE;
                    }
                    //
                    // if names dont match, do nothing. (To paraphrase,
                    // the DNS Server needs to do both!!
                    //

                }
            }
        } else if (pIterator->fDoForwardOnly) {

            if ( pIterator->pszName &&
                 pQElement->pszName &&
                 !wcsicmp_ThatWorks( pIterator->pszName,
                                     pQElement->pszName ) )
            {
                if ((pIterator->dwOperation & DYNDNS_ADD_ENTRY) &&
                    (pQElement->dwOperation & DYNDNS_ADD_ENTRY)) {

                    if (!HostAddrCmp(pIterator->HostAddr, pQElement->HostAddr))
                    {
                        //
                        // optimization blow away earlier entry
                        //
                        DeleteListEntry(pTimedOutQueue, &pIterator);
                        fDelThisTime = TRUE;
                    }
                    //
                    // if names dont match, do nothing
                    //
                }
                else if ((pIterator->dwOperation & DYNDNS_ADD_ENTRY) &&
                         (pQElement->dwOperation & DYNDNS_DELETE_ENTRY)) {

                    if (!HostAddrCmp(pIterator->HostAddr, pQElement->HostAddr)){
                        //
                        // blow away earlier entry
                        //
                        dwRetryTime = pIterator -> dwRetryTime;
                        DeleteListEntry(pTimedOutQueue, &pIterator);
                        fDelThisTime = TRUE;

                    }
                    //
                    // if addresses dont match, do nothing
                    //

                } else if ((pIterator->dwOperation & DYNDNS_DELETE_ENTRY) &&
                           (pQElement->dwOperation & DYNDNS_ADD_ENTRY)) {


                    if (!HostAddrCmp(pIterator->HostAddr, pQElement->HostAddr)){
                        //
                        // blow away earlier entry
                        //

                        dwRetryTime = pIterator -> dwRetryTime;
                        DeleteListEntry(pTimedOutQueue, &pIterator);
                        fDelThisTime = TRUE;

                    }
                    //
                    // if addresses dont match, then dont do anything
                    //
                } else {
                    // both are deletes
                    // do nothing here. i.e. DNS Server does both
                }
            }
        } else if (!pIterator->fDoForwardOnly && pQElement->fDoForwardOnly) {

            //
            // new element is forward only
            //

            //
            // if both elements are forwards, we cannot whack anything
            // out in any case, do nothing
            //

        }

        if (!fDelThisTime && pIterator){
            pIterator = pIterator ->pFLink;
        }

    }
    return (dwRetryTime);
}




VOID
DeleteListEntry(
    PDYNDNSQUEUE  pQueue,
    PQELEMENT*    ppIterator
    )
{

    PQELEMENT        pPrev, pNext;
    PQELEMENT        pIterator = *ppIterator;
    DHCP_CALLBACK_FN pfnDhcpCallBack = NULL;
    PVOID            pvData = NULL;

    pPrev = pIterator ->pBLink;
    pNext = pIterator ->pFLink;

    if (pPrev) {
        pPrev->pFLink = pNext;
    }

    if (pNext) {
        pNext ->pBLink = pPrev;
    }

    if (pIterator == pQueue ->pHead) {
        pQueue->pHead = pIterator ->pBLink;
    }

    if (pIterator == pQueue ->pTail) {
        pQueue->pTail = pIterator ->pFLink;
    }

    *ppIterator = pIterator ->pFLink;

    pfnDhcpCallBack = pIterator->pfnDhcpCallBack;
    pvData = pIterator->pvData;

    // blow away entry

    if ( pIterator -> pszName )
        QUEUE_FREE_HEAP( pIterator->pszName );

    if ( pIterator -> DnsServerList )
        QUEUE_FREE_HEAP( pIterator->DnsServerList );

    if ( pfnDhcpCallBack )
        (*pfnDhcpCallBack)(DNSDHCP_SUPERCEDED, pvData);
    
    QUEUE_FREE_HEAP( pIterator );
}


//
//  End queue.c
//
=== C:/Users/treeman/Desktop/windows nt source code\Source\Win2K3\NT\ds\dns\dnsapi\packet.c ===
/*++

Copyright (c) 1996-2001  Microsoft Corporation

Module Name:

    packet.c

Abstract:

    Domain Name System (DNS) API

    Packet writing utilities.

Author:

    Jim Gilroy (jamesg)     October, 1996

Environment:

    User Mode - Win32

Revision History:

--*/


#include "local.h"


//
//  Receive buffer size
//      - use 16K, max size where compression useful
//      other choices would be ethernet UDP frag size
//          (1472 or 1280 depending on who you talk to)
//

DWORD   g_RecvBufSize = 0x4000;


//
//  Class values for UPDATE packets
//  (Key concept here -- designed by committee)
//
//  These arrays are indexed by
//      !wDataLength -- row
//      Delete flag -- column
//

WORD    PrereqClassArray[2][2] =
{
    DNS_RCLASS_INTERNET,    //  data != 0, no delete
    0,                      //  data != 0, delete => ERROR
    DNS_RCLASS_ANY,         //  no data, no delete
    DNS_RCLASS_NONE,        //  no data, delete
};

WORD    UpdateClassArray[2][2] =
{
    DNS_RCLASS_INTERNET,    //  data != 0, no delete
    DNS_RCLASS_NONE,        //  data != 0, delete
    0,                      //  no data, no delete => ERROR
    DNS_RCLASS_ANY,         //  no data, delete
};



PDNS_MSG_BUF
Dns_AllocateMsgBuf(
    IN      WORD            wBufferLength   OPTIONAL
    )
/*++

Routine Description:

    Allocate message buffer.

Arguments:

    wBufferLength - optional length of message buffer;  default is MAX
        UDP size

Return Value:

    Ptr to message buffer.
    NULL on error.

--*/
{
    PDNS_MSG_BUF    pmsg;
    BOOL            ftcp = FALSE;
    WORD            allocLength;

    //
    //  default allocation to "classical" UDP max buffer length
    //      this is good enough for writing questions
    //      recv size buffers should request larger size
    //

    if ( wBufferLength < DNS_RFC_MAX_UDP_PACKET_LENGTH )
    {
        allocLength = DNS_RFC_MAX_UDP_PACKET_LENGTH;
    }
    else if ( wBufferLength == MAXWORD )
    {
        allocLength = (WORD) g_RecvBufSize;
    }
    else
    {
        allocLength = wBufferLength;
        ftcp = TRUE;
    }

    pmsg = ALLOCATE_HEAP( SIZEOF_MSG_BUF_OVERHEAD + allocLength );
    if ( !pmsg )
    {
        return( NULL );
    }

    //
    //  limit UDP sends to classical RFC UDP limit (512 bytes)
    //      regardless of actual allocation
    //  write routines use pBufferEnd to determine writeability
    //
    //  DCR:  allow big UDP send buffers for update?
    //      problem is that must roll back NOT just OPT, but also
    //      big buffer
    //
    //  DCR:  not really necessary as if write exceeds 512, can
    //      just flip to TCP anyway
    //

    pmsg->BufferLength = allocLength;

    if ( !ftcp )
    {
        allocLength = DNS_RFC_MAX_UDP_PACKET_LENGTH;
    }
    pmsg->pBufferEnd = (PCHAR)&pmsg->MessageHead + allocLength;
    pmsg->fTcp = (BOOLEAN)ftcp;

    //
    //  init -- this follows fTcp set as flag is used to set fields
    //

    Dns_InitializeMsgBuf( pmsg );

    return( pmsg );
}



VOID
Dns_InitializeMsgBuf(
    IN OUT  PDNS_MSG_BUF    pMsg
    )
/*++

Routine Description:

    Initialize message buffer to "clean" state.

Arguments:

    pMsg -- message to init

Return Value:

    Ptr to message buffer.
    NULL on error.

--*/
{
    //  clear info + header
    //
    //  DCR_CLEANUP:  can't take this approach without reworking Allocate
    //      function which sets BufferLength and pBufferEnd
    //      if this function is NOT independently used, then we can fix
    //      it to clean and completely
    //
    // RtlZeroMemory(
    //    pMsg,
    //    ((PBYTE)&pMsg->MessageBody - (PBYTE)pMsg) );


    //  setup addressing info

    pMsg->Socket    = 0;
    pMsg->Socket4   = 0;
    pMsg->Socket6   = 0;

    //  set for packet reception

    if ( pMsg->fTcp )
    {
        SET_MESSAGE_FOR_TCP_RECV( pMsg );
    }
    else
    {
        SET_MESSAGE_FOR_UDP_RECV( pMsg );
    }

    //  clear header

    RtlZeroMemory(
        (PBYTE) &pMsg->MessageBody,
        sizeof(DNS_HEADER) );

    //  set for rewriting

    pMsg->pCurrent = pMsg->MessageBody;
    pMsg->pPreOptEnd = NULL;
}



//
//  Writing to packet
//

PCHAR
_fastcall
Dns_WriteDottedNameToPacket(
    IN OUT  PCHAR           pch,
    IN      PCHAR           pchStop,
    IN      PSTR            pszName,
    IN      PSTR            pszDomain,      OPTIONAL
    IN      WORD            wDomainOffset,  OPTIONAL
    IN      BOOL            fUnicodeName
    )
/*++

Routine Description:

    Write lookup name to packet.

Arguments:

    pch -- ptr to current position in packet buffer

    pchStop -- end of packet buffer

    pszName - dotted FQDN to write

    pszDomain - domain name already in packet (OPTIONAL);  note this is
        a fragment of the SAME STRING as pszName;  i.e. ptr compare
        NOT strcmp is done to determine if at domain name

    wDomainOffset - offset in packet of domain name;  MUST include this
        if pszDomain is given

    fUnicodeName -- pszName is unicode string
        TRUE -- name is unicode
        FALSE -- name is UTF8

Return Value:

    Ptr to next position in packet buffer.
    NULL on error.

--*/
{
    CHAR    ch;
    PCHAR   pchlabelStart;
    UCHAR   countLabel = 0;
    ULONG   countName = 0;
    PSTR    pnameWire;
    PWSTR   pnameUnicode;
    CHAR    nameBuffer[ DNS_MAX_NAME_BUFFER_LENGTH ];
    WCHAR   nameWideBuffer[ DNS_MAX_NAME_BUFFER_LENGTH ];


    //  protect message buffer overrun

    if ( pch >= pchStop )
    {
        return( NULL );
    }

    //  allow root to be indicated by NULL

    if ( !pszName )
    {
        *pch++ = 0;
        return( pch );
    }

    //
    //  protect stack buffers from bogus names
    //

    if ( fUnicodeName )
    {
        countName = wcslen( (LPWSTR) pszName );
    }
    else
    {
        countName = strlen( pszName );
    }
    if ( countName >= DNS_MAX_NAME_BUFFER_LENGTH )
    {
        return NULL;
    }
    countName = 0;

    //
    //  UTF8 name with extended chars?
    //      - then must go up to unicode for canonicalizing
    //
    //  DCR:  shouldn't be sending in un-canonical UTF8
    //      should
    //          - stay in unicode all the way
    //          - using canon unicode all the way
    //          - use canon wire names all the way
    //

    if ( !fUnicodeName )
    {
        if ( !Dns_IsStringAscii( pszName ) )
        {
            DWORD bufLength = DNS_MAX_NAME_BUFFER_LENGTH_UNICODE;

            if ( ! Dns_NameCopy(
                        (PCHAR) nameWideBuffer,
                        & bufLength,
                        pszName,
                        0,          // length unknown
                        DnsCharSetUtf8,
                        DnsCharSetUnicode
                        ) )
            {
                return( NULL );
            }
            if ( ! Dns_MakeCanonicalNameInPlaceW(
                        nameWideBuffer,
                        0 ) )
            {
                return( NULL );
            }
            pnameUnicode = (PWSTR) nameWideBuffer;
            fUnicodeName = TRUE;
        }
    }

    //
    //  unicode name -- if extended, canonicalize first
    //
    //  DCR_FIX0:  should functionalize -- raw unicode to wire
    //

    else
    {
        pnameUnicode = (PWSTR) pszName;

        if ( !Dns_IsWideStringAscii( pnameUnicode ) )
        {
            if ( ! Dns_MakeCanonicalNameW(
                        nameWideBuffer,
                        //DNS_MAX_NAME_BUFFER_LENGTH_UNICODE,
                        DNS_MAX_NAME_BUFFER_LENGTH,
                        pnameUnicode,
                        0 ) )
            {
                return  NULL;
            }
            pnameUnicode = nameWideBuffer;
        }
    }

    //
    //  convert unicode name to UTF8
    //      - if extended chars, then downcase before hit the wire
    //

    if ( fUnicodeName )
    {
        if ( ! Dns_NameCopyUnicodeToWire(
                    nameBuffer,
                    pnameUnicode ) )
        {
            return( NULL );
        }
        pnameWire = nameBuffer;
    }
    else
    {
        pnameWire = pszName;
    }

    //
    //  special case "." root name
    //      - allows us to fail all other zero length labels cleanly
    //

    if ( *pnameWire == '.' )
    {
        if ( *(pnameWire+1) != 0 )
        {
            return( NULL );
        }
        *pch++ = 0;
        return( pch );
    }

    //
    //  write lookup name
    //      - leave

    pchlabelStart = pch++;

    while( ch = *pnameWire++ )
    {
        //  out of space

        if ( pch >= pchStop )
        {
            return( NULL );
        }

        //  not at end of label -- just copy character

        if ( ch != '.' )
        {
            *pch++ = ch;
            countLabel++;
            countName++;
            continue;
        }

        //
        //  at end of label
        //      - write label count
        //      - reset counter
        //      - if reached domain name, write compression and quit
        //

        if ( countLabel > DNS_MAX_LABEL_LENGTH ||
             countLabel == 0 ||
             countName > DNS_MAX_NAME_LENGTH )
        {
            return( NULL );
        }
        *pchlabelStart = countLabel;
        countLabel = 0;
        countName++;
        pchlabelStart = pch++;

        if ( pnameWire == pszDomain )
        {
            if ( ++pch >= pchStop )
            {
                return( NULL );
            }
            *(UNALIGNED WORD *)pchlabelStart =
                    htons( (WORD)(wDomainOffset | (WORD)0xC000) );
            return( pch );
        }
    }

    if ( countLabel > DNS_MAX_LABEL_LENGTH ||
         countName > DNS_MAX_NAME_LENGTH )
    {
        return( NULL );
    }

    //
    //  NULL terminate
    //      - if no terminating ".", do end of label processing also
    //      - return ptr to char after terminating NULL

    if ( countLabel )
    {
        *pchlabelStart = countLabel;
        *pch++ = 0;
    }
    else
    {
        DNS_ASSERT( pch == pchlabelStart + 1 );
        *pchlabelStart = 0;
    }
    return( pch );
}



PCHAR
_fastcall
Dns_WriteStringToPacket(
    IN OUT  PCHAR           pch,
    IN      PCHAR           pchStop,
    IN      PSTR            pszString,
    IN      BOOL            fUnicodeString
    )
/*++

Routine Description:

    Write string to packet.

Arguments:

    pch -- ptr to current position in packet buffer

    pchStop -- end of packet buffer

    pszString - string to write

    fUnicodeString -- pszString is unicode string

Return Value:

    Ptr to next position in packet buffer.
    NULL on error.

--*/
{
    DWORD    length;

    //
    //  handle NULL string
    //

    if ( !pszString )
    {
        if ( pch >= pchStop )
        {
            return( NULL );
        }
        *pch++ = 0;
        return( pch );
    }

    //
    //  get string length
    //      - get required buf length, then whack whack off space
    //      for terminating NULL
    //      - zero error case, becomes very large number and is
    //      caught by length>MAXCHAR test
    //

    length = Dns_GetBufferLengthForStringCopy(
                pszString,
                0,
                fUnicodeString ? DnsCharSetUnicode : DnsCharSetUtf8,
                DnsCharSetUtf8 );
    length--;

    //
    //  set length byte
    //

    if ( length > MAXUCHAR )
    {
        SetLastError( ERROR_INVALID_DATA );
        return( NULL );
    }
    *pch++ = (UCHAR) length;

    if ( pch + length > pchStop )
    {
        SetLastError( ERROR_MORE_DATA );
        return( NULL );
    }

    //
    //  copy string
    //
    //  note unicode conversion will write NULL terminator, so
    //  test again for space in packet
    //

    if ( fUnicodeString )
    {
        if ( pch + length + 1 > pchStop )
        {
            SetLastError( ERROR_MORE_DATA );
            return( NULL );
        }
        Dns_StringCopy(
            pch,
            NULL,
            pszString,
            length,
            DnsCharSetUnicode,
            DnsCharSetUtf8 );
    }
    else
    {
        memcpy(
            pch,
            pszString,
            length );
    }

    return( pch+length );
}



PCHAR
Dns_WriteQuestionToMessage(
    IN OUT  PDNS_MSG_BUF    pMsg,
    IN      PDNS_NAME       pszName,
    IN      WORD            wType,
    IN      BOOL            fUnicodeName
    )
/*++

Routine Description:

    Write question to packet.

    Note:  Routine DOES NOT clear message info or message header.
    This is optimized for use immediately following Dns_CreateMessage().

Arguments:

    pMsg - message info

    pszName - DNS name of question

    wType - question type

    fUnicodeName - name is in unicode

Return Value:

    Ptr to next char in buffer, if successful.
    NULL if error writing question name.

--*/
{
    PCHAR   pch;

    //  use recursion, as default

    pMsg->MessageHead.RecursionDesired = TRUE;

    //  restart write at message header

    pch = pMsg->MessageBody;

    //  write question name

    pch = Dns_WriteDottedNameToPacket(
                pch,
                pMsg->pBufferEnd,
                (PCHAR) pszName,
                NULL,
                0,
                fUnicodeName );
    if ( !pch )
    {
        return( NULL );
    }

    //  write question structure

    *(UNALIGNED WORD *) pch = htons( wType );
    pch += sizeof(WORD);
    *(UNALIGNED WORD *) pch = DNS_RCLASS_INTERNET;
    pch += sizeof(WORD);

    //  set question RR section count

    pMsg->MessageHead.QuestionCount = 1;

    //  header fields in host order

    pMsg->fSwapped = FALSE;

    //  reset current ptr

    pMsg->pCurrent = pch;

    IF_DNSDBG( INIT )
    {
        DnsDbg_Message(
            "Packet after question write:",
            pMsg );
    }
    return( pch );
}



DNS_STATUS
Dns_WriteRecordStructureToMessage(
    IN OUT  PDNS_MSG_BUF    pMsg,
    IN      WORD            wType,
    IN      WORD            wClass,
    IN      DWORD           dwTtl,
    IN      WORD            wDataLength
    )
/*++

Routine Description:

    No data RR cases:

    This includes prereqs and deletes except for specific record cases.

Arguments:

    pch - ptr to next byte in packet buffer

    pchStop - end of packet buffer

    wClass - class

    wType - desired RR type

    dwTtl - time to live

    wDataLength - data length

Return Value:

    Ptr to next postion in buffer, if successful.
    NULL on error.

--*/
{
    PDNS_WIRE_RECORD    pdnsRR;
    PCHAR               pchdata;

    IF_DNSDBG( WRITE2 )
    {
        DNS_PRINT(( "Dns_WriteRecordStructureToMessage(%p).\n", pMsg ));
    }

    //
    //  out of space
    //

    pdnsRR = (PDNS_WIRE_RECORD) pMsg->pCurrent;
    pchdata = (PCHAR) pdnsRR + sizeof( DNS_WIRE_RECORD );

    if ( pchdata + wDataLength >= pMsg->pBufferEnd )
    {
        DNS_PRINT(( "ERROR  out of space writing record to packet.\n" ));
        return( ERROR_MORE_DATA );
    }

    //
    //  write RR wire structure
    //

    *(UNALIGNED WORD *) &pdnsRR->RecordType  = htons( wType );
    *(UNALIGNED WORD *) &pdnsRR->RecordClass = htons( wClass );
    *(UNALIGNED DWORD *) &pdnsRR->TimeToLive = htonl( dwTtl );
    *(UNALIGNED WORD *) &pdnsRR->DataLength  = htons( wDataLength );

    //
    //  update current ptr
    //

    pMsg->pCurrent = pchdata;

    return( ERROR_SUCCESS );
}



DNS_STATUS
Dns_WriteRecordStructureToPacket(
    IN OUT  PCHAR           pchBuf,
    IN      PDNS_RECORD     pRecord,
    IN      BOOL            fUpdatePacket
    )
/*++

Routine Description:

    Write wire record structure for given record.

Arguments:

    pchBuf - ptr to next byte in packet buffer

    pRecord - record to write

    fUpdatePacket -- TRUE if building update message;
        for update the section flags in the pRecords are interpreted
        for update;  otherwise query semantics are used

Return Value:

    None

--*/
{
    PDNS_WIRE_RECORD    pwireRecord;
    WORD                class;
    DWORD               ttl;

    IF_DNSDBG( WRITE2 )
    {
        DNS_PRINT((
            "Writing RR struct (%p) to packet buffer at %p.\n",
            pRecord,
            pchBuf
            ));
        DnsDbg_Record(
            "Record being written:",
            pRecord );
    }

    //
    //  get TTL, it will be set to zero for several of the update cases
    //

    ttl = pRecord->dwTtl;

    //
    //  determine class
    //      - class variable is in net order (for perf)
    //      - default is class IN, but may be ANY or NONE for certain updates
    //

    if ( fUpdatePacket )
    {
        switch( pRecord->Flags.S.Section )
        {
        case DNSREC_PREREQ:

            class = PrereqClassArray
                    [ pRecord->wDataLength == 0 ][ pRecord->Flags.S.Delete ];
            ttl = 0;
            break;

        case DNSREC_UPDATE:
        case DNSREC_ADDITIONAL:

            class = UpdateClassArray
                    [ pRecord->wDataLength == 0 ][ pRecord->Flags.S.Delete ];

            if ( class != DNS_RCLASS_INTERNET )
            {
                ttl = 0;
            }
            break;

        default:
            DNS_PRINT(( "ERROR:  invalid RR section.\n" ));
            return( ERROR_INVALID_DATA );
        }
        if ( class == 0 )
        {
            DNS_PRINT(( "ERROR:  no update class corresponding to RR flags.\n" ));
            return( ERROR_INVALID_DATA );
        }
    }
    else
    {
        class = DNS_RCLASS_INTERNET;
    }

    //
    //  write RR wire structure
    //      - zero datalength to handle no data case
    //

    pwireRecord = (PDNS_WIRE_RECORD) pchBuf;

    *(UNALIGNED WORD *) &pwireRecord->RecordType  = htons( pRecord->wType );
    *(UNALIGNED WORD *) &pwireRecord->RecordClass = class;
    *(UNALIGNED DWORD *) &pwireRecord->TimeToLive = htonl( ttl );
    *(UNALIGNED WORD *) &pwireRecord->DataLength = 0;

    return( ERROR_SUCCESS );
}



PCHAR
Dns_WriteRecordStructureToPacketEx(
    IN OUT  PCHAR           pchBuf,
    IN      WORD            wType,
    IN      WORD            wClass,
    IN      DWORD           dwTtl,
    IN      WORD            wDataLength
    )
/*++

Routine Description:

    Write wire record structure for given record.

Arguments:

    pchBuf - ptr to next byte in packet buffer

Return Value:

    Ptr to data section of record.

--*/
{
    PDNS_WIRE_RECORD    pwireRecord;

    //  DCR_PERF:  optimize RR write to packet?

    pwireRecord = (PDNS_WIRE_RECORD) pchBuf;

    *(UNALIGNED WORD *) &pwireRecord->RecordType  = htons( wType );
    *(UNALIGNED WORD *) &pwireRecord->RecordClass = htons( wClass );
    *(UNALIGNED DWORD *) &pwireRecord->TimeToLive = htonl( dwTtl );
    *(UNALIGNED WORD *) &pwireRecord->DataLength  = htons( wDataLength );

    return( pchBuf + sizeof(DNS_WIRE_RECORD) );
}



VOID
Dns_SetRecordDatalength(
    IN OUT  PDNS_WIRE_RECORD    pRecord,
    IN      WORD                wDataLength
    )
/*++

Routine Description:

    Reset record datalength.

Arguments:

    pRecord - wire record to reset

    wDataLength - data length

Return Value:

    Ptr to data section of record.

--*/
{
    WORD  flippedWord;

    INLINE_WORD_FLIP( flippedWord, wDataLength );

    *(UNALIGNED WORD *) &pRecord->DataLength = flippedWord;
}



DNS_STATUS
Dns_WriteOptToMessage(
    IN OUT  PDNS_MSG_BUF    pMsg,
    IN      WORD            wPayload,
    IN      DWORD           Rcode,
    IN      BYTE            Version,
    IN      PBYTE           pData,
    IN      WORD            wDataLength
    )
/*++

Routine Description:

    Write OPT record to message.

Arguments:

    pMsg        -- message

    wPayload    -- max length client can receive in UDP

    Rcode       -- RCODE, if extended some of this ends up in OPT

    Version     -- EDNS version

    pData       -- ptr to data buffer of OPT data

    wDataLength -- length of pData

Return Value:

    ERROR_SUCCESS if successfully writen.
    ErrorCode on failure.

--*/
{
    DNS_STATUS  status;
    PCHAR       pstart;

    //
    //  DCR:  use variable OPT fields
    //

    //
    //  save existing pCurrent
    //      - this allows dual wire write
    //

    ASSERT( !pMsg->pPreOptEnd );

    pstart = pMsg->pCurrent;

    //
    //  write OPT record name (root)
    //

    *pstart = 0;
    pMsg->pCurrent++;

    //
    //  write OPT -- basic info, no options
    //      - if OPT didn't fit, clear pPreOptEnd pointer
    //      which serves as signal that OPT exists
    //

    status = Dns_WriteRecordStructureToMessage(
                    pMsg,
                    DNS_TYPE_OPT,
                    (WORD) g_RecvBufSize,   //  recv buffer size (in Class)
                    0,                      //  no flags\extended RCODE (in TTL)
                    0                       //  no data length
                    );

    if ( status == ERROR_SUCCESS )
    {
        //  increment message record count

        SET_TO_WRITE_ADDITIONAL_RECORDS(pMsg);
        CURRENT_RR_COUNT_FIELD(pMsg)++;

        pMsg->pPreOptEnd = pstart;
    }
    else
    {
        //  on failure, reset current

        pMsg->pCurrent = pstart;
    }

    return( status );
}



DNS_STATUS
Dns_WriteStandardRequestOptToMessage(
    IN OUT  PDNS_MSG_BUF    pMsg
    )
/*++

Routine Description:

    Write standard OPT record to message.

    This contains just the buffer size and version info,
    no error code or options.

Arguments:

    pMsg -- message

Return Value:

    ERROR_SUCCESS if successfully writen.
    ErrorCode on failure.

--*/
{
    if ( g_UseEdns == 0 )
    {
        return( ERROR_REQUEST_REFUSED );
    }

    return  Dns_WriteOptToMessage(
                pMsg,
                (WORD) g_RecvBufSize,
                0,              // no rcode
                0,              // standard version
                NULL,           // no data
                0               // no data length
                );
}



DNS_STATUS
Dns_AddRecordsToMessage(
    IN OUT  PDNS_MSG_BUF    pMsg,
    IN      PDNS_RECORD     pRecord,
    IN      BOOL            fUpdateMessage
    )
/*++

Routine Description:

    Add record or list of records to message.No data RR cases:

    This includes prereqs and deletes except for specific record cases.

    EXPORTED:   resolver, mcast

Arguments:

    pMsg - message buffer to write to

    pRecord - ptr to record (or first of list of records) to write to packet

    fUpdateMessage -- If TRUE, the message is going to contain an update.
                      Therefore the section flags in the pRecord
                      should be interpreted for update. Otherwise this is
                      for a query message and section flags should be
                      interpreted for query.

Return Value:

    ERROR_SUCCESS if successful.
    Error code on failure.

--*/
{
    PCHAR               pch = pMsg->pCurrent;
    PCHAR               pendBuffer = pMsg->pBufferEnd;
    WORD                currentSection = 0;
    WORD                section;
    PSTR                pnamePrevious = NULL;
    PSTR                pnameRecord;
    WORD                compressedPreviousName;
    WORD                offsetPreviousName;
    PDNS_WIRE_RECORD    pwireRecord;
    PCHAR               pchnext;
    WORD                index;
    DNS_STATUS          status = ERROR_SUCCESS;
    BOOL                funicode = FALSE;

    //
    //  write each record in list
    //

    while ( pRecord )
    {
        //
        //  determine section for record
        //      - may not write to previous section

        section = (WORD) pRecord->Flags.S.Section;
        if ( section < currentSection )
        {
            DNS_PRINT((
                "ERROR:  Attempt to write record at %p, with section %d\n"
                "\tless than previous section written %d.\n",
                pRecord,
                pRecord->Flags.S.Section,
                currentSection ));
            return( ERROR_INVALID_DATA );
        }
        else if ( section > currentSection )
        {
            currentSection = section;
            SET_CURRENT_RR_COUNT_SECTION( pMsg, section );
        }

        //
        //  write record name
        //      - if same as previous, write compressed name
        //      - if first write from pRecord
        //          - write full name
        //          - clear reserved field for offsetting
        //

        pnameRecord = (PCHAR) pRecord->pName;

        if ( pnamePrevious &&
             ( !pnameRecord ||
               ( funicode
                    ?   !wcscmp( (PWSTR)pnamePrevious, (PWSTR)pnameRecord )
                    :   !strcmp( pnamePrevious, pnameRecord ) ) ) )
        {
            //  compression should always be BACK ptr

            DNS_ASSERT( offsetPreviousName < pch - (PCHAR)&pMsg->MessageHead );

            if ( pendBuffer <= pch + sizeof(WORD) )
            {
                return( ERROR_MORE_DATA );
            }
            if ( ! compressedPreviousName )
            {
                compressedPreviousName = htons( (WORD)(0xC000 | offsetPreviousName) );
            }
            *(UNALIGNED WORD *)pch = compressedPreviousName;
            pch += sizeof( WORD );
        }
        else
        {
            offsetPreviousName = (WORD)(pch - (PCHAR)&pMsg->MessageHead);
            compressedPreviousName = 0;
            pnamePrevious = pnameRecord;
            funicode = (RECORD_CHARSET(pRecord) == DnsCharSetUnicode);

            pch = Dns_WriteDottedNameToPacket(
                        pch,
                        pendBuffer,
                        pnamePrevious,
                        NULL,
                        0,
                        funicode );

            if ( !pch )
            {
                //  DCR:  distinguish out of space errors from name errors during write
                return( DNS_ERROR_INVALID_NAME );
            }
        }

        //
        //  write record structure
        //

        if ( pch + sizeof(DNS_WIRE_RECORD) >= pendBuffer )
        {
            return( ERROR_MORE_DATA );
        }

        status = Dns_WriteRecordStructureToPacket(
                    pch,
                    pRecord,
                    fUpdateMessage );
        if ( status != ERROR_SUCCESS )
        {
            return( status );
        }

        pwireRecord = (PDNS_WIRE_RECORD) pch;
        pch += sizeof( DNS_WIRE_RECORD );

        //
        //  record data
        //

        if ( pRecord->wDataLength )
        {
            index = INDEX_FOR_TYPE( pRecord->wType );
            DNS_ASSERT( index <= MAX_RECORD_TYPE_INDEX );

            if ( index && RR_WriteTable[ index ] )
            {
                pchnext = RR_WriteTable[ index ](
                                pRecord,
                                pch,
                                pendBuffer
                                );
                if ( ! pchnext )
                {
                    status = GetLastError();
                    DNS_PRINT((
                        "ERROR:  Record write routine failure for record type %d.\n\n"
                        "\tstatus = %d\n",
                        pRecord->wType,
                        status ));
                    return( status );
                }
            }
            else
            {
                //  write unknown types -- as RAW data only

                DNS_PRINT((
                    "WARNING:  Writing unknown type %d to message\n",
                    pRecord->wType ));

                if ( pendBuffer - pch <= pRecord->wDataLength )
                {
                    return( ERROR_MORE_DATA );
                }
                memcpy(
                    pch,
                    (PCHAR) &pRecord->Data,
                    pRecord->wDataLength );
                pchnext = pch + pRecord->wDataLength;
            }

            //
            //  set packet record data length
            //

            DNS_ASSERT( (pchnext - pch) < MAXWORD );
            *(UNALIGNED WORD *) &pwireRecord->DataLength =
                                                htons( (WORD)(pchnext - pch) );
            pch = pchnext;
        }

        //  increment message record count

        CURRENT_RR_COUNT_FIELD(pMsg)++;

        pRecord = pRecord->pNext;
    }

    //
    //  resest message current ptr
    //

    pMsg->pCurrent = pch;

    IF_DNSDBG( INIT )
    {
        DnsDbg_Message(
            "Packet after adding records:",
            pMsg );
    }

    return( status );
}



PDNS_MSG_BUF
Dns_BuildPacket(
    IN      PDNS_HEADER     pHeader,
    IN      BOOL            fNoHeaderCounts,
    IN      PDNS_NAME       pszQuestionName,
    IN      WORD            wQuestionType,
    IN      PDNS_RECORD     pRecords,
    IN      DWORD           dwFlags,
    IN      BOOL            fUpdatePacket
    )
/*++

Routine Description:

    Build packet.

Arguments:

    pHeader -- DNS header to send

    fNoHeaderCounts - do NOT include record counts in copying header

    pszName -- DNS name to query

    wType -- query type

    pRecords -- address to receive ptr to record list returned from query

    dwFlags -- query flags

    fUpdatePacket -- If TRUE, the packet is going to contain an update.
                     Therefore the section flags in the pRecords
                     should be interpreted for update. Otherwise this is
                     for a query and section flags will be interpreted for
                     query.

Return Value:

    ERROR_SUCCESS if successful.
    Error code on failure.

--*/
{
    PDNS_MSG_BUF    pmsg;
    DWORD           length;
    DNS_STATUS      status;

    DNSDBG( WRITE, (
        "Dns_BuildPacket()\n"
        "\tname          %s\n"
        "\ttype          %d\n"
        "\theader        %p\n"
        "\t - counts     %d\n"
        "\trecords       %p\n"
        "\tflags         %08x\n"
        "\tfUpdatePacket %d\n",
        pszQuestionName,
        wQuestionType,
        pHeader,
        fNoHeaderCounts,
        pRecords,
        dwFlags,
        fUpdatePacket ));

    //
    //  allocate packet
    //      - if just a question, standard UDP will do it
    //      - if contains records, then use TCP buffer
    //

    length = 0;
    if ( pRecords )
    {
        length = DNS_TCP_DEFAULT_PACKET_LENGTH;
    }
    pmsg = Dns_AllocateMsgBuf( (WORD)length );
    if ( !pmsg )
    {
        status = DNS_ERROR_NO_MEMORY;
        goto Failed;
    }

    //
    //  write question?
    //

    if ( pszQuestionName )
    {
        if ( ! Dns_WriteQuestionToMessage(
                    pmsg,
                    (PDNS_NAME) pszQuestionName,
                    wQuestionType,
                    (BOOL)!!(dwFlags & DNSQUERY_UNICODE_NAME)
                    ) )
        {
            status = ERROR_INVALID_NAME;
            goto Failed;
        }
    }

    //
    //  build packet records
    //

    if ( pRecords )
    {
        status = Dns_AddRecordsToMessage(
                    pmsg,
                    pRecords,
                    fUpdatePacket );
        if ( status != ERROR_SUCCESS )
        {
            DNS_PRINT((
                "ERROR:  failure writing records to message.\n" ));
            goto Failed;
        }
    }

    //
    //  append standard request OPT -- if possible
    //
    //  DCR:  currently no OPT for update
    //

    if ( !fUpdatePacket )
    {
        Dns_WriteStandardRequestOptToMessage( pmsg );
    }

    //
    //  overwrite header?
    //

    if ( pHeader )
    {
        length = sizeof(DNS_HEADER);
        if ( fNoHeaderCounts )
        {
            length = sizeof(DWORD);
        }
        RtlCopyMemory(
            & pmsg->MessageHead,
            pHeader,
            length );
    }

    //  override recursion default, if desired

    if ( dwFlags & DNS_QUERY_NO_RECURSION )
    {
        pmsg->MessageHead.RecursionDesired = FALSE;
    }

    //  init XID if not set

    if ( pmsg->MessageHead.Xid == 0 )
    {
        pmsg->MessageHead.Xid = Dns_GetRandomXid( pmsg );
    }

    return( pmsg );

Failed:

    SetLastError( status );
    FREE_HEAP( pmsg );
    return( NULL );
}



//
//  Reading from packet
//

PCHAR
_fastcall
Dns_SkipPacketName(
    IN      PCHAR       pch,
    IN      PCHAR       pchEnd
    )
/*++

Routine Description:

    Skips over name in packet

Arguments:

    pch - ptr to start of name to skip

    pchEnd - ptr to byte after end of packet

Return Value:

    Ptr to next byte in buffer
    NULL if bad name

--*/
{
    register UCHAR  cch;
    register UCHAR  cflag;

    //
    //  Loop until end of name
    //

    while ( pch < pchEnd )
    {
        cch = *pch++;
        cflag = cch & 0xC0;

        //
        //  normal label
        //      - skip to next label and continue
        //      - stop only if at 0 (root) label
        //

        if ( cflag == 0 )
        {
            if ( cch )
            {
                pch += cch;
                continue;
            }
            return( pch );
        }

        //
        //  compression
        //      - skip second byte in compression and return
        //

        else if ( cflag == 0xC0 )
        {
            pch++;
            return( pch );
        }
        else
        {
            DNSDBG( READ, (
                "ERROR:  bad packet name label byte %02 at 0x%p\n",
                cch,
                pch - 1 ));

            return( NULL );
        }
    }

    DNSDBG( READ, (
        "ERROR:  packet name at %p reads past end of packet at %p\n",
        pch,
        pchEnd ));

    return( NULL );
}



BOOL
Dns_IsSamePacketQuestion(
    IN      PDNS_MSG_BUF    pMsg1,
    IN      PDNS_MSG_BUF    pMsg2
    )
/*++

Routine Description:

    Compares questions in two messages.

Arguments:

    pMsg1 -- first message

    pMsg2 -- second message

Return Value:

    TRUE if message questions equal.
    FALSE if questions not equal.

--*/
{
    PCHAR   pquestion1;
    PCHAR   pquestion2;
    PCHAR   pnameEnd;
    DWORD   questionLength;

    //
    //  validate and size the question fields
    //      - size must match
    //

    pquestion1 = pMsg1->MessageBody;

    pnameEnd = Dns_SkipPacketName(
                    pquestion1,
                    pMsg1->pBufferEnd );
    if ( !pnameEnd )
    {
        return  FALSE;
    }
    questionLength = (DWORD)( pnameEnd - pquestion1 );

    pquestion2 = pMsg2->MessageBody;

    pnameEnd = Dns_SkipPacketName(
                    pquestion2,
                    pMsg2->pBufferEnd );

    if ( !pnameEnd ||
         questionLength != (DWORD)(pnameEnd - pquestion2) )
    {
        return  FALSE;
    }

    //
    //  for speed, first do flat mem compare
    //      - this will hit 99% case as rarely would
    //      a server rewrite the question name
    //

    if ( RtlEqualMemory(
            pquestion1,
            pquestion2,
            questionLength ) )
    {
        return  TRUE;
    }

    //
    //  then do case sensitive compare
    //      - note, we do simple ANSI casing
    //      assume UTF8 extended chars MUST be downcased on the
    //      wire per spec
    //

    return  !_strnicmp( pquestion1, pquestion2, questionLength );
}



PCHAR
_fastcall
Dns_SkipPacketRecord(
    IN      PCHAR           pchRecord,
    IN      PCHAR           pchMsgEnd
    )
/*++

Routine Description:

    Skips over packet RR.
    This is RR structure and data, not the owner name.

Arguments:

    pchRecord - ptr to start of RR structure.

    pchMsgEnd - end of message

Return Value:

    Ptr to next record in packet.
    NULL if RR outside packet or invalid.

--*/
{
    //
    //  skip RR struct
    //

    pchRecord += sizeof(DNS_WIRE_RECORD);
    if ( pchRecord > pchMsgEnd )
    {
        return( NULL );
    }

    //  read datalength and skip data
    //  datalength field is a WORD, at end of record header

    pchRecord += InlineFlipUnalignedWord( pchRecord - sizeof(WORD) );

    if ( pchRecord > pchMsgEnd )
    {
        return( NULL );
    }

    return( pchRecord );
}



PCHAR
Dns_SkipToRecord(
    IN      PDNS_HEADER     pMsgHead,
    IN      PCHAR           pMsgEnd,
    IN      INT             iCount
    )
/*++

Routine Description:

    Skips over some number of DNS records.

Arguments:

    pMsgHead    -- ptr to begining of DNS message.

    pMsgEnd     -- ptr to end of DNS message

    iCount      -- if > 0, number of records to skip
                    if <= 0, number of records from end of packet

Return Value:

    Ptr to next
    NULL if bad packet.

--*/
{
    PCHAR   pch;
    INT     i;
    WORD    recordCount;

    //
    //  determine how many records to skip
    //

    recordCount = pMsgHead->QuestionCount
                + pMsgHead->AnswerCount
                + pMsgHead->NameServerCount
                + pMsgHead->AdditionalCount;

    //  iCount > 0 is skip count, MUST not be larger than
    //      actual count

    if ( iCount > 0 )
    {
        if ( iCount > recordCount )
        {
            return( NULL );
        }
    }

    //  iCount <= 0 then (-iCount) is number of records
    //  from the last record

    else
    {
        iCount += recordCount;
        if ( iCount < 0 )
        {
            return( NULL );
        }
    }

    //  skip message header

    pch = (PCHAR) (pMsgHead + 1);
    if ( iCount == 0 )
    {
        return( pch );
    }

    //
    //  skip records
    //

    for ( i=0; i<iCount; i++ )
    {
        pch = Dns_SkipPacketName( pch, pMsgEnd );
        if ( !pch )
        {
            return pch;
        }

        //  skip question or RR

        if ( i < pMsgHead->QuestionCount )
        {
            pch += sizeof(DNS_WIRE_QUESTION);
            if ( pch > pMsgEnd )
            {
                return( NULL );
            }
        }
        else
        {
            pch = Dns_SkipPacketRecord( pch, pMsgEnd );
            if ( !pch )
            {
                return pch;
            }
        }
    }

    DNSDBG( READ, (
        "Leaving SkipToRecord, current ptr = %p, offset = %04x\n"
        "\tskipped %d records\n",
        pch,
        (WORD) (pch - (PCHAR)pMsgHead),
        iCount ));

    return( pch );
}



PCHAR
_fastcall
Dns_ReadPacketName(
    IN OUT  PCHAR       pchNameBuffer,
    OUT     PWORD       pwNameLength,
    IN OUT  PWORD       pwNameOffset,           OPTIONAL
    OUT     PBOOL       pfNameSameAsPrevious,   OPTIONAL
    IN      PCHAR       pchName,
    IN      PCHAR       pchStart,
    IN      PCHAR       pchEnd
    )
/*++

Routine Description:

    Reads packet name and converts it to DNS-dotted format.

Arguments:

    pchNameBuffer - buffer to write name into;  contains previous name, if any

    pwNameLength - length of name written to buffer;  does not include
        terminating NULL

    pwNameOffset - addr with previous names offset (zero if no previous name);
        on return, contains this name's offset
        OPTIONAL but must exist if fNameSameAsPrevious exists

    pfNameSameAsPrevious - addr of flag set if this name is same as previous;
        OPTIONAL but must exist if pwNameOffset exists

    pchName  - ptr to name in packet

    pchStart - start of DNS message

    pchEnd   - ptr to byte after end of DNS message

Return Value:

    Ptr to next byte in packet.
    NULL on error.

--*/
{
    register PUCHAR pch = pchName;
    register UCHAR  cch;
    register UCHAR  cflag;
    PCHAR           pchdotted;
    PCHAR           pbufferEnd;
    PCHAR           pchreturn = NULL;

    DNS_ASSERT( pch > pchStart && pchEnd > pchStart );
    DNS_ASSERT( (pwNameOffset && pfNameSameAsPrevious) ||
            (!pwNameOffset && !pfNameSameAsPrevious) );


    //
    //  read through labels and/or compression until reach end of name
    //

    pbufferEnd = pchNameBuffer + DNS_MAX_NAME_LENGTH;
    pchdotted = pchNameBuffer;

    while ( pch < pchEnd )
    {
        cch = *pch++;

        //
        //  at root label
        //      - if root name, write single '.'
        //      - otherwise strip trailing dot from last label
        //      - save length written
        //      - NULL teminate name
        //      - set same as previous FALSE
        //      - save packet offset to this name
        //      - return next byte in buffer
        //

        if ( cch == 0 )
        {
            if ( pchdotted == pchNameBuffer )
            {
                *pchdotted++ = '.';
            }
            else
            {
                pchdotted--;
            }
            *pwNameLength = (WORD)(pchdotted - pchNameBuffer);
            *pchdotted = 0;
            if ( pwNameOffset )
            {
                *pfNameSameAsPrevious = FALSE;
                *pwNameOffset = (WORD)(pchName - pchStart);
            }
            return( pchreturn ? pchreturn : pch );
        }

        cflag = cch & 0xC0;

        //
        //  regular label
        //      - copy label to buffer
        //      - jump to next label

        if ( cflag == 0 )
        {
            PCHAR   pchnext = pch + cch;

            if ( pchnext >= pchEnd )
            {
                DNS_PRINT((
                    "ERROR:  Packet name at %p extends past end of buffer\n",
                    pchName ));
                goto Failed;
            }
            if ( pchdotted + cch + 1 >= pbufferEnd )
            {
                DNS_PRINT((
                    "ERROR:  Packet name at %p exceeds max length\n",
                    pchName ));
                goto Failed;
            }
            memcpy(
                pchdotted,
                pch,
                cch );

            pchdotted += cch;
            *pchdotted++ = '.';
            pch = pchnext;
            continue;
        }

        //
        //  offset
        //      - get offset
        //      - if offset at start of name compare to previous name offset
        //      - otherwise follow offset to build new name
        //

        if ( cflag == 0xC0 )
        {
            WORD    offset;
            PCHAR   pchoffset;

            offset = (cch ^ 0xC0);
            offset <<= 8;
            offset |= *pch;
            pchoffset = --pch;

            //
            //  first offset
            //      - save return pointer
            //
            //  if name is entirely offset
            //      - same as previous offset -- done
            //      - if not still save this offset rather than offset
            //      to name itself (first answer is usually just offset
            //      to question, subsequent answer RRs continue to reference
            //      question offset, not first answer)
            //

            if ( !pchreturn )
            {
                DNS_ASSERT( pch >= pchName );
                pchreturn = pch+2;

                if ( pchoffset == pchName && pwNameOffset )
                {
                    if ( *pwNameOffset == offset )
                    {
                        *pfNameSameAsPrevious = TRUE;
                        return( pchreturn );
                    }
                    else
                    {
                        //  save offset that comprises name
                        //  then kill out copy of return ptr so don't
                        //  return offset to pchName when finish copy

                        *pwNameOffset = offset;
                        *pfNameSameAsPrevious = FALSE;
                        pwNameOffset = NULL;
                    }
                }
            }

            //
            //  make jump to new bytes and continue
            //      - verify offset is BEFORE current name
            //          and BEFORE current ptr

            pch = pchStart + offset;

            if ( pch >= pchName || pch >= pchoffset )
            {
                DNS_PRINT((
                    "ERROR:  Bogus name offset %d, encountered at %p\n"
                    "\tto location %p past current position or original name.\n",
                    offset,
                    pchoffset,
                    pch ));
                goto Failed;
            }
            continue;
        }

        //  any other label byte is bogus

        else
        {
            DNS_PRINT((
                "ERROR:  bogus name label byte %02x at %p\n",
                cch,
                pch - 1 ));
            goto Failed;
        }
    }

    DNS_PRINT((
        "ERROR:  packet name at %p reads to ptr %p past end of packet at %p\n",
        pchName,
        pch,
        pchEnd ));

    //
    //  failed
    //      - return NULL
    //      - set OUT params, keeps prefix happy on higher level calls
    //

Failed:

    *pwNameLength = 0;
    if ( pwNameOffset )
    {
        *pwNameOffset = 0;
    }
    if ( pfNameSameAsPrevious )
    {
        *pfNameSameAsPrevious = FALSE;
    }
    return ( NULL );
}



PCHAR
_fastcall
Dns_ReadPacketNameAllocate(
    IN OUT  PCHAR *         ppchName,
    OUT     PWORD           pwNameLength,
    IN OUT  PWORD           pwPrevNameOffset,       OPTIONAL
    OUT     PBOOL           pfNameSameAsPrevious,   OPTIONAL
    IN      PCHAR           pchPacketName,
    IN      PCHAR           pchStart,
    IN      PCHAR           pchEnd
    )
/*++

Routine Description:

    Reads packet name and creates (allocates) a copy in DNS-dotted format.

Arguments:

    ppchName - addr to recv resulting name ptr

    pwNameLength - length of name written to buffer

    pwNameOffset - addr with previous names offset (zero if no previous name);
        on return, contains this name's offset
        OPTIONAL but must exist if fNameSameAsPrevious exists

    fNameSameAsPrevious - addr of flag set if this name is same as previous;
        OPTIONAL but must exist if pwNameOffset exists

    pchPacketName - pch to name in packet

    pchStart - start of DNS message

    pchEnd - ptr to byte after end of DNS message

Return Value:

    Ptr to next byte in packet.
    NULL on error.

--*/
{
    PCHAR   pch;
    PCHAR   pallocName;
    CHAR    nameBuffer[ DNS_MAX_NAME_BUFFER_LENGTH ];
    WORD    nameLength = DNS_MAX_NAME_BUFFER_LENGTH;

    //
    //  read packet name into buffer
    //

    pch = Dns_ReadPacketName(
            nameBuffer,
            & nameLength,
            pwPrevNameOffset,
            pfNameSameAsPrevious,
            pchPacketName,
            pchStart,
            pchEnd );
    if ( !pch )
    {
        return( pch );
    }

    //
    //  allocate buffer for packet name
    //      - nameLength does not include terminating NULL
    //

    nameLength++;
    pallocName = (PCHAR) ALLOCATE_HEAP( nameLength );
    if ( !pallocName )
    {
        return( NULL );
    }

    RtlCopyMemory(
        pallocName,
        nameBuffer,
        nameLength );

    *ppchName = pallocName;
    *pwNameLength = --nameLength;

    DNSDBG( READ, (
        "Allocated copy of packet name %s length %d\n",
        pallocName,
        nameLength ));

    return( pch );
}



DNS_STATUS
Dns_ExtractRecordsFromMessage(
    IN      PDNS_MSG_BUF    pMsg,
    IN      BOOL            fUnicode,
    OUT     PDNS_RECORD *   ppRecord
    )
/*++

Routine Description:

    Extract records from packet.

Arguments:

    pMsg - message buffer to write to

    fUnicode - flag indicating strings in record should be unicode

Return Value:

    Ptr to parsed record list if any.
    NULL if no record list or error.

--*/
{
    PDNS_MESSAGE_BUFFER pDnsBuffer = (PDNS_MESSAGE_BUFFER) &pMsg->MessageHead;

    return Dns_ExtractRecordsFromBuffer(
                pDnsBuffer,
                pMsg->MessageLength,
                fUnicode,
                ppRecord );
}



DNS_STATUS
Dns_ParseMessage(
    OUT     PDNS_PARSED_MESSAGE pParse,
    IN      PDNS_MESSAGE_BUFFER pDnsBuffer,
    IN      WORD                wMessageLength,
    IN      DWORD               Flags,
    IN      DNS_CHARSET         OutCharSet
    )
/*++

Routine Description:

    Parse DNS message.

Arguments:

    pParse - ptr to blob to receive parsed message

    pDnsBuffer - message buffer to read from

    wMessageLength -- message length

    Flags - parsing options

    OutCharSet - DNS character set;  only UTF8 and unicode supported

Return Value:

    RCODE error status on successful parse (including NO_ERROR)
    DNS_INFO_NO_RECORDS -- on auth-empty response
    //  referral
    DNS_ERROR_BAD_PACKET -- on bad packet

    Note:  even on failure caller must free data

--*/
{
    register PCHAR      pch;
    PDNS_HEADER         pwireMsg = (PDNS_HEADER) pDnsBuffer;
    PCHAR               pchpacketEnd;
    DNS_PARSED_RR       parsedRR;
    PSTR                pnameOwner;
    PSTR                pnameNew = NULL;
    PWORD               pCurrentCountField = NULL;
    WORD                countRR;
    WORD                countSection;
    WORD                typePrevious = 0;
    WORD                nameOffset = 0;
    WORD                nameLength;
    WORD                type;
    WORD                index;
    BYTE                section;
    BOOL                fnameSameAsPrevious;
    PDNS_RECORD         pnewRR;
    DNS_RRSET           rrset;
    DNS_RRSET           rrsetAlias;
    DNS_RRSET           rrsetSig;
    DNS_STATUS          status;
    DNS_STATUS          rcodeStatus;
    CHAR                nameBuffer[ DNS_MAX_NAME_BUFFER_LENGTH ];
    DNS_RECORD          recordTemp;

    DNSDBG( READ, (
        "Dns_ParseMessage( %p, len=%d )\n",
        pDnsBuffer,
        wMessageLength
        ));

    //
    //  clear parsing blob
    //

    RtlZeroMemory(
        pParse,
        sizeof(DNS_PARSED_MESSAGE) );

    //
    //  only UTF8 or unicode is supported directly
    //

    if ( OutCharSet != DnsCharSetUnicode &&
         OutCharSet != DnsCharSetUtf8 )
    {
        ASSERT( FALSE );
        return( ERROR_INVALID_PARAMETER );
    }

    //
    //  error code
    //      - map RCODE to DNS error
    //      - if other than NAME_ERROR, don't bother parsing
    //
    //  DCR:  option to parse with other errors
    //

    rcodeStatus = pwireMsg->ResponseCode;
    if ( rcodeStatus != 0 )
    {
        rcodeStatus = Dns_MapRcodeToStatus( pwireMsg->ResponseCode );

        if ( rcodeStatus != DNS_ERROR_RCODE_NAME_ERROR  &&
             !(Flags & DNS_PARSE_FLAG_RCODE_ALL) )
        {
            DNSDBG( READ, (
                "No records extracted from response\n"
                "\tresponse code = %d\n",
                pwireMsg->ResponseCode ));
            return( rcodeStatus );
        }
    }

    //
    //  clear record holders
    //      - do now so safe in bad packet cleanup
    //

    DNS_RRSET_INIT( rrset );
    DNS_RRSET_INIT( rrsetAlias );
    DNS_RRSET_INIT( rrsetSig );

    //
    //  copy message header
    //

    RtlCopyMemory(
        & pParse->Header,
        pwireMsg,
        sizeof(DNS_HEADER) );

    //
    //  read RRs in list of records
    //
    //  loop through all resource records
    //      - skip question
    //      - build DNS_RECORD structure for other records
    //

    pchpacketEnd = (PCHAR)pwireMsg + wMessageLength;
    pch = pDnsBuffer->MessageBody;

    section = DNSREC_QUESTION;
    pCurrentCountField = &pwireMsg->QuestionCount;
    countSection = pwireMsg->QuestionCount;
    countRR = 0;

    while( 1 )
    {
        //
        //  changing sections
        //  save section number and RR count for current section
        //  note need immediate loop back to handle empty section
        //

        countRR++;
        if ( countRR > countSection )
        {
            if ( section == DNSREC_QUESTION )
            {
                // no-op
            }
            else if ( section == DNSREC_ANSWER )
            {
                pParse->pAnswerRecords = rrset.pFirstRR;
            }
            else if ( section == DNSREC_AUTHORITY )
            {
                pParse->pAuthorityRecords = rrset.pFirstRR;
            }
            else if ( section == DNSREC_ADDITIONAL )
            {
                pParse->pAdditionalRecords = rrset.pFirstRR;
                break;
            }
            section++;
            pCurrentCountField++;
            countSection = *(pCurrentCountField);
            countRR = 0;
            typePrevious = 0;       // force new RR set
            DNS_RRSET_INIT( rrset );
            continue;
        }

        //  validity check next RR

        if ( pch >= pchpacketEnd )
        {
            DNS_PRINT((
                "ERROR:  reading bad packet %p.\n"
                "\tat end of packet length with more records to process\n"
                "\tpacket length = %ld\n"
                "\tcurrent offset = %ld\n",
                wMessageLength,
                pch - (PCHAR)pwireMsg
                ));
            goto PacketError;
        }

        //
        //  read name, determining if same as previous name
        //

        IF_DNSDBG( READ2 )
        {
            DnsDbg_Lock();
            DNS_PRINT((
                "Reading record at offset %x\n",
                (WORD)(pch - (PCHAR)pwireMsg) ));

            DnsDbg_PacketName(
                "Record name ",
                pch,
                pwireMsg,
                pchpacketEnd,
                "\n" );
            DnsDbg_Unlock();
        }
        pch = Dns_ReadPacketName(
                    nameBuffer,
                    & nameLength,
                    & nameOffset,
                    & fnameSameAsPrevious,
                    pch,
                    (PCHAR) pwireMsg,
                    pchpacketEnd );
        if ( ! pch )
        {
            DNS_PRINT(( "ERROR:  bad packet name.\n" ));
            goto PacketError;
        }
        IF_DNSDBG( READ2 )
        {
            DNS_PRINT((
                "Owner name of record %s\n"
                "\tlength = %d\n"
                "\toffset = %d\n"
                "\tfSameAsPrevious = %d\n",
                nameBuffer,
                nameLength,
                nameOffset,
                fnameSameAsPrevious ));
        }

        //
        //  question
        //

        if ( section == DNSREC_QUESTION )
        {
            PSTR pnameQuestion = NULL;

            if ( !(Flags & DNS_PARSE_FLAG_NO_QUESTION) )
            {
                pnameQuestion = Dns_NameCopyAllocate(
                                        nameBuffer,
                                        (UCHAR) nameLength,
                                        DnsCharSetUtf8,     // UTF8 in
                                        OutCharSet
                                        );
            }
            pParse->pQuestionName = (LPTSTR) pnameQuestion;

            if ( pch + sizeof(DNS_WIRE_QUESTION) > pchpacketEnd )
            {
                DNS_PRINT(( "ERROR:  question exceeds packet length.\n" ));
                goto PacketError;
            }
            pParse->QuestionType = InlineFlipUnalignedWord( pch );
            pch += sizeof(WORD);
            pParse->QuestionClass = InlineFlipUnalignedWord( pch );
            pch += sizeof(WORD);

            if ( Flags & DNS_PARSE_FLAG_ONLY_QUESTION )
            {
                break;
            }
            continue;
        }

        //
        //  extract RR info, type, datalength
        //      - verify RR within message
        //

        pch = Dns_ReadRecordStructureFromPacket(
                   pch,
                   pchpacketEnd,
                   & parsedRR );
        if ( !pch )
        {
            DNS_PRINT(( "ERROR:  bad RR struct out of packet.\n" ));
            goto PacketError;
        }
        type = parsedRR.Type;

        //
        //  type change -- then have new RR set
        //      - setup for new name
        //      - check and see if first non-alias answer
        //

        if ( type != typePrevious )
        {
            fnameSameAsPrevious = FALSE;
            typePrevious = type;
        }

        //
        //  screen out OPT
        //
        //  DCR:  make screening configurable for API
        //

        if ( type == DNS_TYPE_OPT )
        {
            continue;
        }

        //
        //  screen out SIGs -- if not desired
        //
#if 0
        if ( type == DNS_TYPE_SIG &&
             flag & NOSIG )
        {
            continue;
        }
#endif

        //
        //  make copy of new name
        //
        //  DCR_FIX0:   name same as previous
        //      flag indicates only that name not compressed to previous
        //      name (or previous compression)
        //      actually need abolute ingnore case compare
        //      with last records name to be sure that name not previous
        //

        if ( !fnameSameAsPrevious )
        {
            pnameNew = Dns_NameCopyAllocate(
                            nameBuffer,
                            (UCHAR) nameLength,
                            DnsCharSetUtf8,     // UTF8 string in
                            OutCharSet
                            );
            if ( !pnameNew )
            {
                status = DNS_ERROR_NO_MEMORY;
                goto Failed;
            }
            pnameOwner = pnameNew;
            DNSDBG( OFF, (
                "Copy of owner name of record being read from packet %s\n",
                nameBuffer ));
        }
        DNS_ASSERT( pnameOwner );
        DNS_ASSERT( pnameNew || fnameSameAsPrevious );

        //
        //  TSIG record requires owner name for versioning
        //

        recordTemp.pName = (PTCHAR) pnameOwner;

        //
        //  read RR data for type
        //

        index = INDEX_FOR_TYPE( type );
        DNS_ASSERT( index <= MAX_RECORD_TYPE_INDEX );

        if ( !index || !RR_ReadTable[ index ] )
        {
            //  unknown types -- index to NULL type to use
            //  FlatRecordRead()

            DNS_PRINT((
                "WARNING:  Reading unknown record type %d from message\n",
                parsedRR.Type ));

            index = DNS_TYPE_NULL;
        }

        pnewRR = RR_ReadTable[ index ](
                        &recordTemp,
                        OutCharSet,
                        (PCHAR) pDnsBuffer,
                        parsedRR.pchData,
                        pch                 // end of record data
                        );
        if ( ! pnewRR )
        {
            status = GetLastError();
            ASSERT( status != ERROR_SUCCESS );

            DNS_PRINT((
                "ERROR:  RR_ReadTable routine failure for type %d.\n"
                "\tstatus   = %d\n"
                "\tpchdata  = %p\n"
                "\tpchend   = %p\n",
                parsedRR.Type,
                status,
                parsedRR.pchData,
                pch ));

            if ( status == ERROR_SUCCESS )
            {
                status = DNS_ERROR_NO_MEMORY;
            }
            goto Failed;
        }

        //
        //  write record info
        //      - first RR in set gets new name allocation
        //      and is responsible for cleanup
        //      - no data cleanup necessary as all data is
        //      contained in the RR allocation
        //

        pnewRR->pName = (PTCHAR) pnameOwner;
        pnewRR->wType = type;
        pnewRR->dwTtl = parsedRR.Ttl;
        pnewRR->Flags.S.Section = section;
        pnewRR->Flags.S.CharSet = OutCharSet;
        FLAG_FreeOwner( pnewRR ) = !fnameSameAsPrevious;
        FLAG_FreeData( pnewRR ) = FALSE;

        //
        //  add RR to list
        //

        if ( type == DNS_TYPE_SIG &&
             pParse->QuestionType != DNS_TYPE_SIG )
        {
            DNS_RRSET_ADD( rrsetSig, pnewRR );
        }
        else if ( type == DNS_TYPE_CNAME &&
                  pParse->QuestionType != DNS_TYPE_ALL &&
                  pParse->QuestionType != DNS_TYPE_CNAME &&
                  section == DNSREC_ANSWER )
        {
            DNS_RRSET_ADD( rrsetAlias, pnewRR );
        }
        else
        {
            DNS_RRSET_ADD( rrset, pnewRR );
        }

        //  clear new ptr, as name now part of record
        //  this is strictly used to determine when pnameOwner
        //  must be cleaned up on failure

        pnameNew = NULL;

    }   //  end loop through packet's records

    //
    //  set response info
    //
    //  DCR:  if don't want single SIG, easy to break out by section
    //

    pParse->pAliasRecords = rrsetAlias.pFirstRR;

    pParse->pSigRecords = rrsetSig.pFirstRR;

    //
    //  break out various query NO_ERROR responses
    //      - empty response
    //      - referral
    //      - garbage
    //

    if ( pwireMsg->AnswerCount == 0  &&
         rcodeStatus == 0  &&
         pwireMsg->Opcode == DNS_OPCODE_QUERY &&
         pwireMsg->IsResponse )
    {
        PDNS_RECORD prrAuth = pParse->pAuthorityRecords;

        if ( (prrAuth && prrAuth->wType == DNS_TYPE_SOA) ||
             (!prrAuth && pwireMsg->Authoritative) )
        {
            rcodeStatus = DNS_INFO_NO_RECORDS;
            DNSDBG( READ, ( "Empty-auth response at %p.\n", pwireMsg ));
        }
        else if ( prrAuth &&
                  prrAuth->wType == DNS_TYPE_NS &&
                  !pwireMsg->Authoritative &&
                  (!pwireMsg->RecursionAvailable || !pwireMsg->RecursionDesired) )
        {
            rcodeStatus = DNS_ERROR_REFERRAL_RESPONSE;
            DNSDBG( READ, ( "Referral response at %p.\n", pwireMsg ));
        }
        else
        {
            rcodeStatus = DNS_ERROR_BAD_PACKET;
            DNSDBG( ANY, ( "Bogus NO_ERROR response at %p.\n", pwireMsg ));
            DNS_ASSERT( FALSE );
        }
    }

    //  verify never turn RCODE result into SUCCESS

    ASSERT( pwireMsg->ResponseCode == 0 || rcodeStatus != ERROR_SUCCESS );
    ASSERT( pnameNew == NULL );

    pParse->Status = rcodeStatus;

    IF_DNSDBG( RECV )
    {
        DnsDbg_ParsedMessage(
            "Parsed message:\n",
            pParse );
    }
    return( rcodeStatus );


PacketError:

    DNS_PRINT(( "ERROR:  bad packet in buffer.\n" ));
    status = DNS_ERROR_BAD_PACKET;

Failed:

    FREE_HEAP( pnameNew );

    Dns_RecordListFree( rrset.pFirstRR );
    Dns_RecordListFree( rrsetAlias.pFirstRR );
    Dns_RecordListFree( rrsetSig.pFirstRR );

    pParse->Status = status;

    return( status );
}



VOID
Dns_FreeParsedMessageFields(
    IN OUT  PDNS_PARSED_MESSAGE pParse
    )
/*++

Routine Description:

    Free a parsed DNS message struct.

Arguments:

    pParse - ptr to blob to receive parsed message

Return Value:

    None

--*/
{
    DNSDBG( TRACE, (
        "Dns_FreeParsedMessageFields( %p )\n",
        pParse ));

    //  question name

    FREE_HEAP( pParse->pQuestionName );

    //  records

    Dns_RecordListFree( pParse->pAliasRecords );
    Dns_RecordListFree( pParse->pAnswerRecords );
    Dns_RecordListFree( pParse->pAdditionalRecords );
    Dns_RecordListFree( pParse->pAuthorityRecords );
    Dns_RecordListFree( pParse->pSigRecords );

    //  clear to avoid confusion or double free

    RtlZeroMemory(
        pParse,
        sizeof(DNS_PARSED_MESSAGE) );
}



DNS_STATUS
Dns_ExtractRecordsFromBuffer(
    IN      PDNS_MESSAGE_BUFFER pDnsBuffer,
    IN      WORD                wMessageLength,
    IN      BOOL                fUnicode,
    OUT     PDNS_RECORD *       ppRecord
    )
/*++

Routine Description:

    Extract records from packet buffer.

Arguments:

    pDnsBuffer - message buffer to read from

    fUnicode - flag indicating strings in record should be unicode

Return Value:

    Ptr to parsed record list if any.
    NULL if no record list or error.

--*/
{
    PDNS_RECORD         prr;
    DNS_STATUS          status;
    DNS_PARSED_MESSAGE  parseBlob;

    DNSDBG( READ, (
        "Dns_ExtractRecordsFromBuffer( %p, len=%d )\n",
        pDnsBuffer,
        wMessageLength
        ));

    //
    //  call real parsing function
    //

    status = Dns_ParseMessage(
                & parseBlob,
                pDnsBuffer,
                wMessageLength,
                DNS_PARSE_FLAG_NO_QUESTION,
                fUnicode
                    ? DnsCharSetUnicode
                    : DnsCharSetUtf8
                );

    //
    //  concatentate into one blob
    //      - work backwards so only touch each record once
    //
    //  DCR:  we have no real support for returning SIG records
    //  DCR:  should append SIGs also?
    //

    prr = Dns_RecordListAppend(
            parseBlob.pAuthorityRecords,
            parseBlob.pAdditionalRecords
            );

    prr = Dns_RecordListAppend(
            parseBlob.pAnswerRecords,
            prr
            );

    prr = Dns_RecordListAppend(
            parseBlob.pAliasRecords,
            prr
            );

    *ppRecord = prr;

    //
    //  cleanup
    //      - clear what we pick up
    //      - then free rest of blob
    //

    parseBlob.pAuthorityRecords     = NULL;
    parseBlob.pAdditionalRecords    = NULL;
    parseBlob.pAnswerRecords        = NULL;
    parseBlob.pAliasRecords         = NULL;

    Dns_FreeParsedMessageFields( &parseBlob );

    IF_DNSDBG( RECV )
    {
        DnsDbg_RecordSet(
            "Extracted records:\n",
            prr );
    }

    return( status );
}




#if 0
DNS_STATUS
Dns_ExtractRecordsFromBuffer(
    IN      PDNS_MESSAGE_BUFFER pDnsBuffer,
    IN      WORD                wMessageLength,
    IN      BOOL                fUnicode,
    OUT     PDNS_RECORD *       ppRecord
    )
/*++

Routine Description:

    Extract records from packet buffer.

Arguments:

    pDnsBuffer - message buffer to read from

    fUnicode - flag indicating strings in record should be unicode

Return Value:

    Ptr to parsed record list if any.
    NULL if no record list or error.

--*/
{
    register PCHAR      pch;
    PDNS_HEADER         pwireMsg = (PDNS_HEADER) pDnsBuffer;
    PCHAR               pchpacketEnd;
    DNS_PARSED_RR       parsedRR;
    PSTR                pnameOwner;
    PSTR                pnameNew = NULL;
    DNS_CHARSET         outCharSet;
    WORD                countRR;
    WORD                countSection;
    WORD                typePrevious = 0;
    WORD                nameOffset = 0;
    WORD                nameLength;
    WORD                index;
    BYTE                section;
    BOOL                fnameSameAsPrevious;
    PDNS_RECORD         pnewRR;
    DNS_RRSET           rrset;
    DNS_STATUS          status;
    DNS_STATUS          rcodeStatus;
    CHAR                nameBuffer[ DNS_MAX_NAME_BUFFER_LENGTH ];
    DNS_RECORD          recordTemp;
    PWORD               pCurrentCountField = NULL;

    DNSDBG( READ, (
        "Dns_ExtractRecordsFromBuffer( %p, len=%d )\n",
        pDnsBuffer,
        wMessageLength
        ));

    //
    //  error code
    //      - map RCODE to DNS error
    //      - if other than NAME_ERROR, don't bother parsing
    //

    rcodeStatus = pwireMsg->ResponseCode;
    if ( rcodeStatus != 0 )
    {
        rcodeStatus = Dns_MapRcodeToStatus( pwireMsg->ResponseCode );
        if ( rcodeStatus != DNS_ERROR_RCODE_NAME_ERROR )
        {
            DNSDBG( READ, (
                "No records extracted from response\n"
                "\tresponse code = %d\n",
                pwireMsg->ResponseCode ));
            return( rcodeStatus );
        }
    }

    DNS_RRSET_INIT( rrset );

    //
    //  detemine char set
    //

    if ( fUnicode )
    {
        outCharSet = DnsCharSetUnicode;
    }
    else
    {
        outCharSet = DnsCharSetUtf8;
    }

    //
    //  read RRs in list of records
    //
    //  loop through all resource records
    //      - skip question
    //      - build DNS_RECORD structure for other records
    //

    pchpacketEnd = (PCHAR)pwireMsg + wMessageLength;
    pch = pDnsBuffer->MessageBody;

    section = DNSREC_QUESTION;
    pCurrentCountField = &pwireMsg->QuestionCount;
    countSection = pwireMsg->QuestionCount;
    countRR = 0;

    while( 1 )
    {
        //
        //  changing sections
        //  save section number and RR count for current section
        //  note need immediate loop back to handle empty section
        //

        countRR++;
        if ( countRR > countSection )
        {
            if ( section == DNSREC_ADDITIONAL )
            {
                break;
            }
            section++;
            pCurrentCountField++;
            countSection = *(pCurrentCountField);
            countRR = 0;
            continue;
        }

        //  validity check next RR

        if ( pch >= pchpacketEnd )
        {
            DNS_PRINT((
                "ERROR:  reading bad packet %p.\n"
                "\tat end of packet length with more records to process\n"
                "\tpacket length = %ld\n"
                "\tcurrent offset = %ld\n",
                pDnsBuffer,
                wMessageLength,
                pch - (PCHAR)pwireMsg
                ));
            goto PacketError;
        }

        //
        //  skip question
        //

        if ( section == DNSREC_QUESTION )
        {
            pch = Dns_SkipPacketName(
                        pch,
                        pchpacketEnd );
            if ( !pch )
            {
                DNS_PRINT(( "ERROR:  bad question name.\n" ));
                goto PacketError;
            }
            pch += sizeof(DNS_WIRE_QUESTION);
            if ( pch > pchpacketEnd )
            {
                DNS_PRINT(( "ERROR:  question exceeds packet length.\n" ));
                goto PacketError;
            }
            continue;
        }

        //
        //  read name, determining if same as previous name
        //

        IF_DNSDBG( READ2 )
        {
            DnsDbg_Lock();
            DNS_PRINT((
                "Reading record at offset %x\n",
                (WORD)(pch - (PCHAR)pwireMsg) ));

            DnsDbg_PacketName(
                "Record name ",
                pch,
                pwireMsg,
                pchpacketEnd,
                "\n" );
            DnsDbg_Unlock();
        }
        pch = Dns_ReadPacketName(
                    nameBuffer,
                    & nameLength,
                    & nameOffset,
                    & fnameSameAsPrevious,
                    pch,
                    (PCHAR) pwireMsg,
                    pchpacketEnd );
        if ( ! pch )
        {
            DNS_PRINT(( "ERROR:  bad packet name.\n" ));
            goto PacketError;
        }
        IF_DNSDBG( READ2 )
        {
            DNS_PRINT((
                "Owner name of record %s\n"
                "\tlength = %d\n"
                "\toffset = %d\n"
                "\tfSameAsPrevious = %d\n",
                nameBuffer,
                nameLength,
                nameOffset,
                fnameSameAsPrevious ));
        }

        //
        //  extract RR info, type, datalength
        //      - verify RR within message
        //

        pch = Dns_ReadRecordStructureFromPacket(
                   pch,
                   pchpacketEnd,
                   & parsedRR );
        if ( !pch )
        {
            DNS_PRINT(( "ERROR:  bad RR struct out of packet.\n" ));
            goto PacketError;
        }

        //
        //  on type change, always have new RR set
        //      - setup for new name
        //

        if ( parsedRR.Type != typePrevious )
        {
            fnameSameAsPrevious = FALSE;
            typePrevious = parsedRR.Type;
        }

        //
        //  screen out OPT
        //
        //  DCR:  make screening configurable for API
        //

        if ( parsedRR.Type == DNS_TYPE_OPT )
        {
            continue;
        }

        //
        //  make copy of new name
        //
        //  DCR_FIX0:   name same as previous
        //      flag indicates only that name not compressed to previous
        //      name (or previous compression)
        //      actually need abolute ingnore case compare
        //      with last records name to be sure that name not previous
        //

        if ( !fnameSameAsPrevious )
        {
            pnameNew = Dns_NameCopyAllocate(
                            nameBuffer,
                            (UCHAR) nameLength,
                            DnsCharSetUtf8,     // UTF8 string in
                            outCharSet
                            );
            pnameOwner = pnameNew;
            DNSDBG( READ2, (
                "Copy of owner name of record being read from packet %s\n",
                pnameOwner ));
        }
        DNS_ASSERT( pnameOwner );
        DNS_ASSERT( pnameNew || fnameSameAsPrevious );

        //
        //  TSIG record requires owner name for versioning
        //

        recordTemp.pName = pnameOwner;

        //
        //  read RR data for type
        //

        index = INDEX_FOR_TYPE( parsedRR.Type );
        DNS_ASSERT( index <= MAX_RECORD_TYPE_INDEX );

        if ( !index || !RR_ReadTable[ index ] )
        {
            //  unknown types -- index to NULL type to use
            //  FlatRecordRead()

            DNS_PRINT((
                "WARNING:  Reading unknown record type %d from message\n",
                parsedRR.Type ));

            index = DNS_TYPE_NULL;
        }

        pnewRR = RR_ReadTable[ index ](
                        &recordTemp,
                        outCharSet,
                        (PCHAR) pDnsBuffer,
                        parsedRR.pchData,
                        pch                 // end of record data
                        );
        if ( ! pnewRR )
        {
            status = GetLastError();
            ASSERT( status != ERROR_SUCCESS );

            DNS_PRINT((
                "ERROR:  RR_ReadTable routine failure for type %d.\n"
                "\tstatus   = %d\n"
                "\tpchdata  = %p\n"
                "\tpchend   = %p\n",
                parsedRR.Type,
                status,
                parsedRR.pchData,
                pch ));

            if ( status == ERROR_SUCCESS )
            {
                status = DNS_ERROR_NO_MEMORY;
            }
            goto Failed;
        }

        //
        //  write record info
        //      - first RR in set gets new name allocation
        //      and is responsible for cleanup
        //      - no data cleanup necessary as all data is
        //      contained in the RR allocation
        //

        pnewRR->pName = pnameOwner;
        pnewRR->wType = parsedRR.Type;
        pnewRR->dwTtl = parsedRR.Ttl;
        pnewRR->Flags.S.Section = section;
        pnewRR->Flags.S.CharSet = outCharSet;
        FLAG_FreeOwner( pnewRR ) = !fnameSameAsPrevious;
        FLAG_FreeData( pnewRR ) = FALSE;

        //  add RR to list

        DNS_RRSET_ADD( rrset, pnewRR );

        //  clear new ptr, as name now part of record
        //  this is strictly used to determine when pnameOwner
        //  must be cleaned up on failure

        pnameNew = NULL;

    }   //  end loop through packet's records

    //
    //  return parsed record list
    //      - return DNS error for RCODE
    //      - set special return code to differentiate empty response
    //
    //  DCR:  should have special REFERRAL response
    //      - could overload NOTAUTH rcode
    //  DCR:  should have special EMPTY_AUTH response
    //      - could have empty-auth overload NXRRSET
    //
    //  DCR:  best check on distinguishing EMPTY_AUTH from REFERRAL
    //

    if ( pwireMsg->AnswerCount == 0  &&  rcodeStatus == 0 )
    {
        if ( !rrset.pFirstRR || rrset.pFirstRR->wType == DNS_TYPE_SOA )
        {
            rcodeStatus = DNS_INFO_NO_RECORDS;
            DNSDBG( READ, ( "Empty-auth response at %p.\n", pwireMsg ));
        }
#if 0
        else if ( rrset.pFirstRR->wType == DNS_TYPE_NS &&
                !pwireMsg->Authoritative )
        {
            rcodeStatus = DNS_INFO_REFERRAL;
            DNSDBG( READ, ( "Referral response at %p.\n", pwireMsg ));
        }
        else
        {
            rcodeStatus = DNS_ERROR_BAD_PACKET;
            DNSDBG( READ, ( "Bogus NO_ERROR response at %p.\n", pwireMsg ));
        }
#endif
    }

    //  verify never turn RCODE result into SUCCESS

    ASSERT( pwireMsg->ResponseCode == 0 || rcodeStatus != ERROR_SUCCESS );
    ASSERT( pnameNew == NULL );

    *ppRecord = rrset.pFirstRR;

    IF_DNSDBG( RECV )
    {
        DnsDbg_RecordSet(
            "Extracted records:\n",
            *ppRecord );
    }
    return( rcodeStatus );


PacketError:

    DNS_PRINT(( "ERROR:  bad packet in buffer.\n" ));
    status = DNS_ERROR_BAD_PACKET;

Failed:

    FREE_HEAP( pnameNew );

    Dns_RecordListFree( rrset.pFirstRR );

    return( status );
}
#endif



VOID
Dns_NormalizeAllRecordTtls(
    IN OUT  PDNS_RECORD         pRecord
    )
/*++

Routine Description:

    Finds the lowest TTL value in RR set and the sets all
    records to that value.

Arguments:

    pRecord - record set to normalize ttl values of.

Return Value:

    None

--*/
{
    PDNS_RECORD pTemp = pRecord;
    DWORD       dwTtl;
    WORD        wType;

    //
    // Get the Ttl of the first record (if there is one)
    //
    if ( pTemp )
    {
        dwTtl = pTemp->dwTtl;
        wType = pTemp->wType;
        pTemp = pTemp->pNext;
    }

    //
    // Walk any remaining records looking for an even lower ttl value
    //
    while ( pTemp &&
            pTemp->wType == wType &&
            pTemp->Flags.S.Section == DNSREC_ANSWER )
    {
        if ( pTemp->dwTtl < dwTtl )
        {
            dwTtl = pTemp->dwTtl;
        }

        pTemp = pTemp->pNext;
    }

    //
    // Set all records to this lowest ttl value
    //
    pTemp = pRecord;

    while ( pTemp &&
            pTemp->wType == wType &&
            pTemp->Flags.S.Section == DNSREC_ANSWER )
    {
        pTemp->dwTtl = dwTtl;
        pTemp = pTemp->pNext;
    }
}



PCHAR
Dns_ReadRecordStructureFromPacket(
    IN      PCHAR           pchPacket,
    IN      PCHAR           pchMsgEnd,
    IN OUT  PDNS_PARSED_RR  pParsedRR
    )
/*++

Routine Description:

    Read record structure from packet.

Arguments:

    pchPacket - ptr to record structure in packet

    pchMsgEnd - end of message

    pParsedRR - ptr to struct to receive parsed RR

Return Value:

    Ptr to next record in packet -- based on datalength.
    Null on error.

--*/
{
    PCHAR   pch = pchPacket;

    DNSDBG( READ2, (
        "Dns_ReadRecordStructureFromPacket(%p).\n",
        pch ));

    //
    //  verify record structure within packet
    //

    if ( pch + sizeof(DNS_WIRE_RECORD) > pchMsgEnd )
    {
        DNS_PRINT((
            "ERROR:  record structure at %p is not within packet!.\n",
            pchPacket ));
        return( 0 );
    }

    //
    //  flip fields and write to aligned struct
    //

    pParsedRR->pchRR = pch;

    pParsedRR->Type       = InlineFlipUnalignedWord( pch );
    pch += sizeof(WORD);
    pParsedRR->Class      = InlineFlipUnalignedWord( pch );
    pch += sizeof(WORD);
    pParsedRR->Ttl        = InlineFlipUnalignedDword( pch );
    pch += sizeof(DWORD);
    pParsedRR->DataLength = InlineFlipUnalignedWord( pch );
    pch += sizeof(WORD);

    pParsedRR->pchData = pch;

    //
    //  verify datalength does not extend beyond packet end
    //

    pch += pParsedRR->DataLength;
    pParsedRR->pchNextRR = pch;

    if ( pch > pchMsgEnd )
    {
        DNS_PRINT((
            "ERROR:  record data at %p (length %d) is not within packet!.\n",
            pch - pParsedRR->DataLength,
            pParsedRR->DataLength ));
        return( 0 );
    }

    //
    //  return ptr to next record in packet
    //

    return( pch );
}



PCHAR
Dns_ParsePacketRecord(
    IN      PCHAR           pchPacket,
    IN      PCHAR           pchMsgEnd,
    IN OUT  PDNS_PARSED_RR  pParsedRR
    )
/*++

Routine Description:

    Read record from packet.

Arguments:

    pchPacket - ptr to record structure in packet

    pchMsgEnd - end of message

    pParsedRR - ptr to struct to receive parsed RR

Return Value:

    Ptr to next record in packet -- based on datalength.
    Null on error.

--*/
{
    PCHAR   pch;

    DNSDBG( READ2, (
        "Dns_ParsePacketRecord().\n"
        "\tpRecordStart = %p\n"
        "\tpMsgEnd      = %p\n",
        pchPacket,
        pchMsgEnd ));

    //
    //  save and skip name
    //

    pch = Dns_SkipPacketName(
                pchPacket,
                pchMsgEnd );
    if ( !pch )
    {
        return( pch );
    }
    pParsedRR->pchName = pchPacket;

    //
    //  parse record structure
    //

    pch = Dns_ReadRecordStructureFromPacket(
                pch,
                pchMsgEnd,
                pParsedRR );

    return( pch );
}



//
//  XID utilities
//

//  Max increase in XID space, used in mod() op
//  so pick nice prime number

#define MAX_XID_BUMP    (487)

//  XID seed

WORD    g_XidSeed = 0;

//  last XID for process

WORD    g_LastXid = 0;

//  XID mask

WORD    g_XidMask = 0;


WORD
Dns_GetRandomXid(
    IN      PVOID           pSeed
    )
/*++

Routine Description:

    Generate "random" XID.

    By "random" what we really mean is an XID that's not the same as previous XIDs
    and is not immediately guessable from the outside.

Arguments:

    pSeed -- seed ptr;  from stack or heap, provides differentiation beyond time

Return Value:

    XID generated

--*/
{
    WORD    xid;

    //
    //  build "bump" off
    //
    //  may have multiple sessions to different processes\threads
    //
    //  use tick count (unpredictability)
    //  seed counter (non-repetition of jumps and MT separation)
    //  seed ptr (MT separation) 
    //      note, ptr is first pushed down to count 64-bit boundaries, so lack of
    //      randomness in last 6bits is not preserved
    //

    xid = (WORD) (GetTickCount() + (PtrToUlong(pSeed) >> 6) + g_XidSeed++);
    if ( g_XidMask == 0 )
    {
        g_XidMask = xid ;
    }

    //
    //  XID is bump off last XID
    //      - the limiting this bump limits possibility of XID reuse
    //      in less than 64K/max-bump XIDs
    //      - don't use zero XID
    //      - flip just to generate more confusion, hackers will have the code
    //      and can generate XIDs so the real protection here is the MAX_XID_BUMP
    //      which means MAX_XID_BUMP packets need to be generated -- it's not 64K
    //      but it's a bunch
    //      

    xid = (xid % MAX_XID_BUMP) + 1 + g_LastXid;
    if ( xid == 0 )
    {
        xid = 5;
    }
    g_LastXid = xid;

    return  htons( xid ^ g_XidMask );
}

//
//  End packet.c
//
=== C:/Users/treeman/Desktop/windows nt source code\Source\Win2K3\NT\ds\dns\dnsapi\netpub.c ===
/*++

Copyright (c) 2002-2002 Microsoft Corporation

Module Name:

    netinfo.c

Abstract:

    Domain Name System (DNS) API

    Public DNS network info routines.

Author:

    Jim Gilroy (jamesg)     April 2002

Revision History:

--*/


#include "local.h"


//
//  Private protos
//

PDNS_SEARCH_LIST
DnsSearchList_CreateFromPrivate(
    IN      PDNS_NETINFO        pNetInfo,
    IN      DNS_CHARSET         CharSet
    );


//
//  Character set for old DNS_NETWORK_INFORMATION
//
//  DCR:  netdiag should move to new routine and unicode
//

#define NICHARSET   DnsCharSetUtf8



//
//  Routines for the old public structures:
//      DNS_NETWORK_INFORMATION
//      DNS_SEARCH_INFORMATION
//      DNS_ADAPTER_INFORMATION 
//

//
//  Adapter Information
//

VOID
DnsAdapterInformation_Free(
    IN OUT  PDNS_ADAPTER_INFORMATION    pAdapter
    )
/*++

Routine Description:

    Free public adapter info struct.

Arguments:

    pAdapter -- adapter info to free

Return Value:

    None

--*/
{
    if ( pAdapter )
    {
        FREE_HEAP( pAdapter->pszAdapterGuidName );
        FREE_HEAP( pAdapter->pszDomain );
        FREE_HEAP( pAdapter->pIPAddresses );
        FREE_HEAP( pAdapter->pIPSubnetMasks );
        FREE_HEAP( pAdapter );
    }
}



PDNS_ADAPTER_INFORMATION
DnsAdapterInformation_CreateFromPrivate(
    IN      PDNS_ADAPTER    pAdapter
    )
/*++

Routine Description:

    Create public DNS adapter info.

Arguments:

    pAdapter -- private adapter info.

Return Value:

    None.

--*/
{
    PDNS_ADAPTER_INFORMATION    pnew = NULL;
    PDNS_ADDR_ARRAY             pserverArray;
    DWORD                       iter;
    DWORD                       count = 0;
    PWSTR                       pnameIn;
    PSTR                        pname;
    DWORD                       serverCount;

    //
    //  validate and unpack
    //

    if ( ! pAdapter )
    {
        return NULL;
    }

    pserverArray = pAdapter->pDnsAddrs;
    serverCount = 0;
    if ( pserverArray )
    {
        serverCount = pserverArray->AddrCount;
    }

    //
    //  alloc
    //

    pnew = (PDNS_ADAPTER_INFORMATION) ALLOCATE_HEAP_ZERO(
                                    sizeof(DNS_ADAPTER_INFORMATION) -
                                    sizeof(DNS_SERVER_INFORMATION) +
                                    ( sizeof(DNS_SERVER_INFORMATION) * serverCount )
                                    );
    if ( !pnew )
    {
        return NULL;
    }

    //
    //  copy flags and names
    //

    pnew->InfoFlags = pAdapter->InfoFlags;

    pnameIn = pAdapter->pszAdapterGuidName;
    if ( pnameIn )
    {
        pname = Dns_NameCopyAllocate(
                        (PSTR) pnameIn,
                        0,
                        DnsCharSetUnicode,
                        NICHARSET );
        if ( !pname )
        {
            goto Failed;
        }
        pnew->pszAdapterGuidName = pname;
    }

    pnameIn = pAdapter->pszAdapterDomain;
    if ( pnameIn )
    {
        pname = Dns_NameCopyAllocate(
                        (PSTR) pnameIn,
                        0,
                        DnsCharSetUnicode,
                        NICHARSET );
        if ( !pname )
        {
            goto Failed;
        }
        pnew->pszDomain = pname;
    }

    //  address info

    pnew->pIPAddresses = DnsAddrArray_CreateIp4Array( pAdapter->pLocalAddrs );
    pnew->pIPSubnetMasks = NULL;

    //
    //  server info
    //

    for ( iter=0; iter < serverCount;  iter++ )
    {
        PDNS_ADDR   pserver = &pserverArray->AddrArray[iter];

        if ( DnsAddr_IsIp4( pserver ) )
        {
            pnew->aipServers[iter].ipAddress = DnsAddr_GetIp4( pserver );
            pnew->aipServers[iter].Priority = pserver->Priority;
            count++;
        }
    }

    pnew->cServerCount = count;

    return pnew;

Failed:

    DnsAdapterInformation_Free( pnew );
    return NULL;
}



//
//  Search List
//

VOID
DnsSearchInformation_Free(
    IN      PDNS_SEARCH_INFORMATION     pSearchInfo
    )
/*++

Routine Description:

    Free public search list struct.

Arguments:

    pSearchInfo -- search list to free

Return Value:

    None

--*/
{
    DWORD   iter;

    if ( pSearchInfo )
    {
        FREE_HEAP( pSearchInfo->pszPrimaryDomainName );

        for ( iter=0; iter < pSearchInfo->cNameCount; iter++ )
        {
            FREE_HEAP( pSearchInfo->aSearchListNames[iter] );
        }
        FREE_HEAP( pSearchInfo );
    }
}



#if 0
PDNS_SEARCH_INFORMATION
DnsSearchInformation_CreateFromPrivate(
    IN      PSEARCH_LIST        pSearchList
    )
/*++

Routine Description:

    Create public search list from private.

Arguments:

    pSearchList -- private search list

Return Value:

    Ptr to new search list, if successful.
    NULL on error.

--*/
{
    PDNS_SEARCH_INFORMATION pnew;
    DWORD   iter;
    DWORD   nameCount;
    PWSTR   pname;
    PSTR    pnewName;


    if ( !pSearchList )
    {
        return NULL;
    }
    nameCount = pSearchList->NameCount;

    //
    //  alloc
    //

    pnew = (PDNS_SEARCH_INFORMATION) ALLOCATE_HEAP_ZERO(
                                        sizeof( DNS_SEARCH_INFORMATION ) -
                                        sizeof(PSTR) +
                                        ( sizeof(PSTR) * nameCount ) );
    if ( !pnew )
    {
        return NULL;
    }

    //
    //  copy name
    //

    pname = pSearchList->pszDomainOrZoneName;
    if ( pname )
    {
        pnewName = Dns_NameCopyAllocate(
                        (PSTR) pname,
                        0,
                        DnsCharSetUnicode,
                        NICHARSET );
        if ( !pnewName )
        {
            goto Failed;
        }
        pnew->pszPrimaryDomainName = pnewName;
    }

    //
    //  copy search names
    //

    for ( iter=0; iter < nameCount; iter++ )
    {
        pname = pSearchList->SearchNameArray[iter].pszName;

        if ( pname )
        {
            pnewName = Dns_NameCopyAllocate(
                            (PSTR) pname,
                            0,
                            DnsCharSetUnicode,
                            NICHARSET );
            if ( !pnewName )
            {
                goto Failed;
            }
            pnew->aSearchListNames[iter] = pnewName;
            pnew->cNameCount++;
        }
    }

    return pnew;

Failed:

    DnsSearchInformation_Free( pnew );
    return  NULL;
}
#endif



PDNS_SEARCH_INFORMATION
DnsSearchInformation_CreateFromPrivate(
    IN      PDNS_NETINFO        pNetInfo
    )
/*++

Routine Description:

    Create public search list from private.

Arguments:

    pNetInfo -- private netinfo

Return Value:

    Ptr to new search list, if successful.
    NULL on error.

--*/
{
    //
    //  call new function -- specifying ANSI char set
    //
    //  DCR:  note this assumes mapping with DNS_SEARCH_LIST
    //  note UTF8 -- so this only relevant to netdiag and ipconfig
    //

    return (PDNS_SEARCH_INFORMATION)
                DnsSearchList_CreateFromPrivate(
                    pNetInfo,
                    NICHARSET
                    );
}



PDNS_SEARCH_INFORMATION
DnsSearchInformation_Get(
    VOID
    )
/*++

Routine Description:

    Get search list info.

Arguments:

    None

Return Value:

    Ptr to search list.
    NULL on error.

--*/
{
    PDNS_NETINFO            pnetInfo = GetNetworkInfo();
    PDNS_SEARCH_INFORMATION pnew;

    DNSDBG( TRACE, ( "DnsSearchInformation_Get()\n" ));

    if ( !pnetInfo )
    {
        return NULL;
    }

    pnew = DnsSearchInformation_CreateFromPrivate( pnetInfo );

    NetInfo_Free( pnetInfo );

    return pnew;
}



//
//  Network Information
//

VOID
DnsNetworkInformation_Free(
    IN OUT  PDNS_NETWORK_INFORMATION  pNetInfo
    )
/*++

Routine Description:

    Free network info blob.

Arguments:

    pNetInfo -- blob to free

Return Value:

    None

--*/
{
    DWORD iter;

    DNSDBG( TRACE, ( "DnsNetworkInformation_Free()\n" ));

    if ( pNetInfo )
    {
        DnsSearchInformation_Free( pNetInfo->pSearchInformation );

        for ( iter = 0; iter < pNetInfo->cAdapterCount; iter++ )
        {
            DnsAdapterInformation_Free( pNetInfo->aAdapterInfoList[iter] );
        }

        FREE_HEAP( pNetInfo );
    }
}



PDNS_NETWORK_INFORMATION
DnsNetworkInformation_CreateFromPrivate(
    IN      PDNS_NETINFO    pNetInfo,
    IN      BOOL            fSearchList
    )
/*++

Routine Description:

    Create public DNS_NETWORK_INFORMATION from private DNS_NETINFO.

Arguments:

    pNetInfo -- private blob

    fSearchList -- TRUE to force search list;  FALSE otherwise

Return Value:

    Ptr to new network info, if successful.
    Null on error -- allocation failure.

--*/
{
    PDNS_NETWORK_INFORMATION    pnew = NULL;
    PSEARCH_LIST                psearchList;
    DWORD                       iter;

    DNSDBG( TRACE, ( "DnsNetworkInformation_CreateFromPrivate()\n" ));

    if ( !pNetInfo )
    {
        return  NULL;
    }

    //
    //  alloc
    //

    pnew = (PDNS_NETWORK_INFORMATION)
                ALLOCATE_HEAP_ZERO(
                    sizeof( DNS_NETWORK_INFORMATION) -
                    sizeof( PDNS_ADAPTER_INFORMATION) +
                    ( sizeof(PDNS_ADAPTER_INFORMATION) * pNetInfo->AdapterCount )
                    );
    if ( !pnew )
    {
        goto Failed;
    }

    //
    //  no search list if neither name or count
    //

    if ( fSearchList )
    {
        PDNS_SEARCH_INFORMATION psearch;

        psearch = DnsSearchInformation_CreateFromPrivate( pNetInfo );
        if ( !psearch )
        {
            goto Failed;
        }
        pnew->pSearchInformation = psearch;
    }

    //
    //  copy adapter blobs
    //

    for ( iter = 0; iter < pNetInfo->AdapterCount; iter++ )
    {
        PDNS_ADAPTER_INFORMATION padapter;

        padapter = DnsAdapterInformation_CreateFromPrivate(
                        & pNetInfo->AdapterArray[iter] );
        if ( !padapter )
        {
            goto Failed;
        }
        pnew->aAdapterInfoList[iter] = padapter;
        pnew->cAdapterCount++;
    }
    return  pnew;

Failed:

    DnsNetworkInformation_Free( pnew );
    return  NULL;
}



PDNS_NETWORK_INFORMATION
DnsNetworkInformation_Get(
    VOID
    )
/*++

Routine Description:

    Get DNS network info.

Arguments:

    None.

Return Value:

    Ptr to DNS network info, if successful.
    NULL on error.

--*/
{
    PDNS_NETWORK_INFORMATION    pnew = NULL;
    PDNS_NETINFO                pnetInfo;

    DNSDBG( TRACE, ( "DnsNetworkInformation_Get()\n" ));

    //  grab current network info

    pnetInfo = GetNetworkInfo();
    if ( !pnetInfo )
    {
        return NULL;
    }

    //  copy to public structure

    pnew = DnsNetworkInformation_CreateFromPrivate(
                pnetInfo,
                TRUE        // include search list
                );

    NetInfo_Free( pnetInfo );
    return pnew;
}



//
//  Netdiag public network info routines
//

DNS_STATUS
DnsNetworkInformation_CreateFromFAZ(
    IN      PCSTR                           pszName,
    IN      DWORD                           dwFlags,
    IN      PIP4_ARRAY                      pIp4Servers,
    OUT     PDNS_NETWORK_INFORMATION *      ppNetworkInformation
    )
/*++

Routine Description:

    Get network info blob result from FAZ

    EXPORTED function.  (Used in netdiag.exe)

Arguments:

Return Value:

--*/
{
    PDNS_NETWORK_INFORMATION    pnew = NULL;
    PDNS_ADDR_ARRAY             parray = NULL;
    PDNS_NETINFO                pnetInfo = NULL;
    PWSTR                       pname = NULL;
    DNS_STATUS                  status;

    DNSDBG( TRACE, (
        "DnsNetworkInformation_CreateFromFAZ()\n"
        "\tpszName      = %s\n"
        "\tFlags        = %08x\n"
        "\tpIp4Servers  = %p\n"
        "\tppResults    = %p\n",
        pszName,
        dwFlags,
        pIp4Servers,
        ppNetworkInformation
        ));

    //  convert to DNS_ADDR_ARRAY

    if ( pIp4Servers )
    {
        parray = DnsAddrArray_CreateFromIp4Array( pIp4Servers );
        if ( !parray )
        {
            status = DNS_ERROR_NO_MEMORY;
            goto Done;
        }
    }

    //  convert name to unicode
    //  DCR:  remove when netdiag unicode

    pname = Dns_StringCopyAllocate(
                (PCHAR) pszName,
                0,              // null terminated
                NICHARSET,
                DnsCharSetUnicode
                );
    //  FAZ

    status = Faz_Private(
                (PWSTR) pname,
                dwFlags,
                parray,
                & pnetInfo );

    if ( status != ERROR_SUCCESS )
    {
        goto Done;
    }

    //  convert FAZ results to DNS_NETWORK_INFORMATION

    pnew = DnsNetworkInformation_CreateFromPrivate(
                    pnetInfo,
                    TRUE        // include search list
                    );
    if ( !pnew )
    {
        status = DNS_ERROR_NO_MEMORY;
    }
    else if ( !pnew->pSearchInformation ||
              !pnew->pSearchInformation->pszPrimaryDomainName ||
               pnew->cAdapterCount != 1 ||
              !pnew->aAdapterInfoList[0] )
    {
        DNS_ASSERT( FALSE );
        DnsNetworkInformation_Free( pnew );
        pnew = NULL;
        status = DNS_ERROR_NO_MEMORY;
    }

Done:

    *ppNetworkInformation = pnew;

    NetInfo_Free( pnetInfo );
    DnsAddrArray_Free( parray );
    Dns_Free( pname );

    DNSDBG( TRACE, (
        "Leave DnsNetworkInformation_CreateFromFAZ()\n"
        "\tstatus       = %d\n"
        "\tpNetInfo     = %p\n",
        status,
        pnew ));
    
    return  status;
}




//
//  Routines for the new public structures:
//      DNS_SEARCH_LIST
//      DNS_NETWORK_INFO
//      DNS_ADAPTER_INFO
//

//
//  Adapter Info
//

VOID
DnsAdapterInfo_Free(
    IN OUT  PDNS_ADAPTER_INFO   pAdapter,
    IN      BOOL                fFreeAdapter
    )
/*++

Routine Description:

    Free public adapter info struct.

Arguments:

    pAdapter -- adapter info to free

Return Value:

    None

--*/
{
    if ( pAdapter )
    {
        FREE_HEAP( pAdapter->pszAdapterGuidName );
        FREE_HEAP( pAdapter->pszAdapterDomain );
        DnsAddrArray_Free( pAdapter->pIpAddrs );
        DnsAddrArray_Free( pAdapter->pDnsAddrs );

        if ( fFreeAdapter )
        {
            FREE_HEAP( pAdapter );
        }
        else
        {
            RtlZeroMemory( pAdapter, sizeof(*pAdapter) );
        }
    }
}



BOOL
DnsAdapterInfo_CopyFromPrivate(
    IN      PDNS_ADAPTER_INFO   pCopy,
    IN      PDNS_ADAPTER        pAdapter,
    IN      DNS_CHARSET         CharSet
    )
/*++

Routine Description:

    Create public DNS adapter info.

Arguments:

    pAdapter -- private adapter info.

    CharSet -- desired char set

Return Value:

    None.

--*/
{
    DWORD           iter;
    DWORD           count = 0;
    PWSTR           pnameIn;
    PWSTR           pname;
    DWORD           serverCount;
    PDNS_ADDR_ARRAY parray;

    //
    //  validate and clear
    //

    if ( !pAdapter || !pCopy )
    {
        return  FALSE;
    }

    RtlZeroMemory(
        pCopy,
        sizeof( *pCopy ) );

    //
    //  copy flags and names
    //

    pCopy->Flags = pAdapter->InfoFlags;

    pnameIn = pAdapter->pszAdapterGuidName;
    if ( pnameIn )
    {
        pname = (PWSTR) Dns_NameCopyAllocate(
                            (PSTR) pnameIn,
                            0,
                            DnsCharSetUnicode,
                            CharSet );
        if ( !pname )
        {
            goto Failed;
        }
        pCopy->pszAdapterGuidName = pname;
    }

    pnameIn = pAdapter->pszAdapterDomain;
    if ( pnameIn )
    {
        pname = (PWSTR) Dns_NameCopyAllocate(
                            (PSTR) pnameIn,
                            0,
                            DnsCharSetUnicode,
                            CharSet );
        if ( !pname )
        {
            goto Failed;
        }
        pCopy->pszAdapterDomain = pname;
    }

    //
    //  address info
    //  

    parray = DnsAddrArray_CreateCopy( pAdapter->pLocalAddrs );
    if ( !parray && pAdapter->pLocalAddrs )
    {
        goto Failed;
    }
    pCopy->pIpAddrs = parray;

    //
    //  server info
    //

    parray = DnsAddrArray_CreateCopy( pAdapter->pDnsAddrs );
    if ( !parray && pAdapter->pDnsAddrs )
    {
        goto Failed;
    }
    pCopy->pDnsAddrs = parray;

    return  TRUE;

Failed:

    DnsAdapterInfo_Free(
        pCopy,
        FALSE       // don't free struct
        );
    return  FALSE;
}



PDNS_ADAPTER_INFO
DnsAdapterInfo_CreateFromPrivate(
    IN      PDNS_ADAPTER    pAdapter,
    IN      DNS_CHARSET     CharSet
    )
/*++

Routine Description:

    Create public DNS adapter info.

Arguments:

    pAdapter -- private adapter info.

    CharSet -- desired char set

Return Value:

    None.

--*/
{
    PDNS_ADAPTER_INFO   pnew = NULL;

    //
    //  validate and unpack
    //

    if ( ! pAdapter )
    {
        return NULL;
    }

    //
    //  alloc
    //

    pnew = (PDNS_ADAPTER_INFO) ALLOCATE_HEAP_ZERO( sizeof(DNS_ADAPTER_INFO) );
    if ( !pnew )
    {
        return NULL;
    }

    //
    //  copy adapter info
    //

    if ( !DnsAdapterInfo_CopyFromPrivate(
            pnew,
            pAdapter,
            CharSet ) )
    {
        goto Failed;
    }

    return  pnew;

Failed:

    DnsAdapterInfo_Free( pnew, TRUE );
    return  NULL;
}



//
//  Search List
//

VOID
DnsSearchList_Free(
    IN      PDNS_SEARCH_LIST    pSearchList
    )
/*++

Routine Description:

    Free public search list struct.

Arguments:

    pSearchList -- search list to free

Return Value:

    None

--*/
{
    DWORD   iter;

    if ( pSearchList )
    {
        FREE_HEAP( pSearchList->pszPrimaryDomainName );

        for ( iter=0; iter < pSearchList->NameCount; iter++ )
        {
            FREE_HEAP( pSearchList->SearchNameArray[iter] );
        }
        FREE_HEAP( pSearchList );
    }
}



BOOL
dnsSearchList_AddName(
    IN OUT  PDNS_SEARCH_LIST    pSearchList,
    IN      DWORD               MaxCount,
    IN      PWSTR               pName,
    IN      DNS_CHARSET         CharSet,
    IN      BOOL                fDupCheck
    )
/*++

Routine Description:

    Add name to search list.

    Private util for building search list.

Arguments:

    pSearchList -- new search list

    MaxCount -- OPTIONAL count of max entries in list;
        if zero assume adequate space

    pName -- name to add

    CharSet -- desired char set

    fDupCheck -- check if duplicate


Return Value:

    TRUE if successful or space constraint.
    FALSE only on allocation failure.
    NULL on error.

--*/
{
    PWSTR   pnewName;
    DWORD   nameCount;

    //
    //  validity test
    //
    //  note, failing ONLY on memory allocation failure
    //  as that's the ONLY failure that results in failed build
    //

    nameCount = pSearchList->NameCount;

    if ( !pName ||
         ( MaxCount!=0  &&  MaxCount<=nameCount ) )
    {
        return  TRUE;
    }

    //
    //  copy into desired char set
    //      - then place in search list
    //
    
    pnewName = Dns_NameCopyAllocate(
                    (PSTR) pName,
                    0,
                    DnsCharSetUnicode,
                    CharSet );
    if ( !pnewName )
    {
        return  FALSE;
    }

    //
    //  duplicate check
    //

    if ( fDupCheck )
    {
        DWORD   iter;

        for ( iter=0; iter < nameCount; iter++ )
        {
            if ( Dns_NameComparePrivate(
                    (PCSTR) pnewName,
                    (PCSTR) pSearchList->SearchNameArray[iter],
                    CharSet ) )
            {
                FREE_HEAP( pnewName );
                return  TRUE;
            }
        }
    }

    //
    //  put new name in list
    //

    pSearchList->SearchNameArray[nameCount] = pnewName;
    pSearchList->NameCount = ++nameCount;

    return  TRUE;
}



PDNS_SEARCH_LIST
DnsSearchList_CreateFromPrivate(
    IN      PDNS_NETINFO        pNetInfo,
    IN      DNS_CHARSET         CharSet
    )
/*++

Routine Description:

    Create public search list from private.

Arguments:

    pSearchList -- private search list

    CharSet -- desired char set

Return Value:

    Ptr to new search list, if successful.
    NULL on error.

--*/
{
    PDNS_SEARCH_LIST    pnew = NULL;
    DWORD               iter;
    DWORD               nameCount;
    PWSTR               pname;
    PWSTR               pdn = pNetInfo->pszDomainName;
    PSEARCH_LIST        psearch = NULL;


    DNSDBG( TRACE, (
        "DnsSearchList_CreateFromPrivate( %p, %d )\n",
        pNetInfo,
        CharSet ));

    //
    //  count names
    //      - real search list -- done
    //      - dummy list -- must add in adapter names
    //

    nameCount = MAX_SEARCH_LIST_ENTRIES;

    if ( !(pNetInfo->InfoFlags & NINFO_FLAG_DUMMY_SEARCH_LIST) &&
         (psearch = pNetInfo->pSearchList) )
    {
        nameCount = psearch->NameCount;
    }

    //
    //  alloc
    //

    pnew = (PDNS_SEARCH_LIST) ALLOCATE_HEAP_ZERO(
                                    sizeof( DNS_SEARCH_LIST ) -
                                    sizeof(PSTR) +
                                    ( sizeof(PSTR) * nameCount ) );
    if ( !pnew )
    {
        return  NULL;
    }

    //
    //  copy existing search list
    //

    if ( psearch )
    {
#if 0
        //  primary\zone name
        //  note:  this is used only for update netinfo
        //      only current public customer is netdiag.exe
        
        pname = psearch->pszDomainName;
        if ( pname )
        {
            pnewName = Dns_NameCopyAllocate(
                            (PSTR) pName,
                            0,
                            DnsCharSetUnicode,
                            CharSet );
            if ( !pnewName )
            {
                goto Failed;
            }
            pnew->pszPrimaryDomainName = pnewName;
        }
#endif

        for ( iter=0; iter < nameCount; iter++ )
        {
            if ( !dnsSearchList_AddName(
                        pnew,
                        0,      // adequate space
                        psearch->SearchNameArray[iter].pszName,
                        CharSet,
                        FALSE   // no duplicate check
                        ) )
            {
                goto Failed;
            }
        }
    }

    //
    //  otherwise build search list
    //

    else
    {
        PDNS_ADAPTER    padapter;

        //
        //  use PDN in first search list slot
        //
    
        if ( pdn )
        {
            if ( !dnsSearchList_AddName(
                        pnew,
                        0,      // adequate space
                        pdn,
                        CharSet,
                        FALSE   // no duplicate check
                        ) )
            {
                goto Failed;
            }
        }

        //
        //  add adapter domain names
        //
        //  note:  currently presence of adapter name signals it's
        //      use in queries
        //

        NetInfo_AdapterLoopStart( pNetInfo );

        while ( padapter = NetInfo_GetNextAdapter( pNetInfo ) )
        {
            pname = padapter->pszAdapterDomain;
            if ( pname )
            {
                if ( !dnsSearchList_AddName(
                            pnew,
                            nameCount,
                            pname,
                            CharSet,
                            TRUE        // duplicate check
                            ) )
                {
                    goto Failed;
                }
            }
        }

        //
        //  add devolved primary name
        //      - must have following label
        //      do NOT include TLDs in search list
        //

        if ( pdn && g_UseNameDevolution )
        {
            PWSTR   pnext;

            pname = Dns_GetDomainNameW( pdn );

            while ( pname &&
                    (pnext = Dns_GetDomainNameW(pname)) )
            {
                if ( !dnsSearchList_AddName(
                            pnew,
                            nameCount,
                            pname,
                            CharSet,
                            FALSE       // no duplicate check
                            ) )
                {
                    goto Failed;
                }
                pname = pnext;
            }
        }
    }

    //
    //  copy PDN
    //
    //  currently required
    //      - netdiag references it (as zone for update check)
    //      - ipconfig may use it, not sure
    //

    if ( pdn )
    {
        pname = Dns_NameCopyAllocate(
                        (PSTR) pdn,
                        0,
                        DnsCharSetUnicode,
                        CharSet );
        if ( !pname )
        {
            goto Failed;
        }
        pnew->pszPrimaryDomainName = pname;
    }

    return pnew;

Failed:

    DnsSearchList_Free( pnew );
    return  NULL;
}



PDNS_SEARCH_LIST
DnsSearchList_Get(
    IN      DNS_CHARSET     CharSet
    )
/*++

Routine Description:

    Get search list info.

Arguments:

    CharSet -- desired char set

Return Value:

    Ptr to search list.
    NULL on error.

--*/
{
    PDNS_NETINFO        pnetInfo = GetNetworkInfo();
    PDNS_SEARCH_LIST    pnew;

    if ( !pnetInfo )
    {
        return NULL;
    }

    pnew = DnsSearchList_CreateFromPrivate(
                pnetInfo,
                CharSet );

    NetInfo_Free( pnetInfo );

    return pnew;
}



//
//  Network Info
//

VOID
DnsNetworkInfo_Free(
    IN OUT  PDNS_NETWORK_INFO   pNetInfo
    )
/*++

Routine Description:

    Free network info blob.

Arguments:

    pNetInfo -- blob to free

Return Value:

    None

--*/
{
    DWORD iter;

    if ( pNetInfo )
    {
        DnsSearchList_Free( pNetInfo->pSearchList );
        FREE_HEAP( pNetInfo->pszPrimaryDomainName );
        FREE_HEAP( pNetInfo->pszHostName );

        for ( iter = 0; iter < pNetInfo->AdapterCount; iter++ )
        {
            DnsAdapterInfo_Free(
                & pNetInfo->AdapterArray[iter],
                FALSE   // don't free structure
                );
        }
        FREE_HEAP( pNetInfo );
    }
}



PDNS_NETWORK_INFO
DnsNetworkInfo_CreateFromPrivate(
    IN      PDNS_NETINFO    pNetInfo,
    IN      DNS_CHARSET     CharSet,
    IN      BOOL            fSearchList
    )
/*++

Routine Description:

    Create public DNS_NETWORK_INFO from private DNS_NETINFO.

Arguments:

    pNetInfo -- private blob

    CharSet -- char set of results

    fSearchList -- TRUE to include search list;  FALSE otherwise

Return Value:

    Ptr to new network info, if successful.
    Null on error -- allocation failure.

--*/
{
    PDNS_NETWORK_INFO   pnew = NULL;
    PSEARCH_LIST        psearchList;
    DWORD               iter;
    PSTR                pnewName;
    PWSTR               pname;


    if ( !pNetInfo )
    {
        return  NULL;
    }

    //
    //  alloc
    //

    pnew = (PDNS_NETWORK_INFO)
                ALLOCATE_HEAP_ZERO(
                        sizeof( DNS_NETWORK_INFO ) -
                        sizeof( DNS_ADAPTER_INFO ) +
                        ( sizeof(DNS_ADAPTER_INFO) * pNetInfo->AdapterCount )
                        );
    if ( !pnew )
    {
        goto Failed;
    }

    //
    //  hostname and PDN
    //

    pname = pNetInfo->pszHostName;
    if ( pname )
    {
        pnewName = Dns_NameCopyAllocate(
                        (PSTR) pname,
                        0,
                        DnsCharSetUnicode,
                        CharSet );
        if ( !pnewName )
        {
            goto Failed;
        }
        pnew->pszHostName = (PWSTR) pnewName;
    }

    pname = pNetInfo->pszDomainName;
    if ( pname )
    {
        pnewName = Dns_NameCopyAllocate(
                        (PSTR) pname,
                        0,
                        DnsCharSetUnicode,
                        CharSet );
        if ( !pnewName )
        {
            goto Failed;
        }
        pnew->pszPrimaryDomainName = (PWSTR) pnewName;
    }

    //
    //  search list
    //

    if ( fSearchList )
    {
        PDNS_SEARCH_LIST    psearch;

        psearch = DnsSearchList_CreateFromPrivate(
                        pNetInfo,
                        CharSet );
        if ( !psearch )
        {
            goto Failed;
        }
        pnew->pSearchList = psearch;
    }

    //
    //  copy adapter blobs
    //

    for ( iter = 0; iter < pNetInfo->AdapterCount; iter++ )
    {
        if ( ! DnsAdapterInfo_CopyFromPrivate(
                        & pnew->AdapterArray[iter],
                        & pNetInfo->AdapterArray[iter],
                        CharSet ) )
        {
            goto Failed;
        }
        pnew->AdapterCount++;
    }
    return  pnew;

Failed:

    DnsNetworkInfo_Free( pnew );
    return  NULL;
}



PDNS_NETWORK_INFO
DnsNetworkInfo_Get(
    IN      DNS_CHARSET         CharSet
    )
/*++

Routine Description:

    Get DNS network info.

Arguments:

    None.

Return Value:

    Ptr to DNS network info, if successful.
    NULL on error.

--*/
{
    PDNS_NETWORK_INFO   pnew = NULL;
    PDNS_NETINFO        pnetInfo;

    //  grab current network info

    pnetInfo = GetNetworkInfo();
    if ( !pnetInfo )
    {
        return NULL;
    }

    //  copy to public structure

    pnew = DnsNetworkInfo_CreateFromPrivate(
                pnetInfo,
                CharSet,
                TRUE        // include search list
                );

    NetInfo_Free( pnetInfo );
    return pnew;
}



//
//  Netdiag public network info routines
//

#if 1
//
//  This routine can be brought in when netdiag can be brought
//  onto new structures.
//  Currently netdiag uses the old structure DNS_NETWORK_INFORMATION
//  and uses the routine above.
//

DNS_STATUS
DnsNetworkInfo_CreateFromFAZ(
    //IN      PCWSTR                  pszName,
    IN      PCSTR                   pszName,
    IN      DWORD                   dwFlags,
    IN      PIP4_ARRAY              pIp4Servers,
    IN      DNS_CHARSET             CharSet,
    OUT     PDNS_NETWORK_INFOA *    ppNetworkInfo
    )
/*++

Routine Description:

    Get network info blob result from FAZ

    EXPORTED function.  (Used in netdiag.exe)

Arguments:

Return Value:

--*/
{
    DNS_STATUS          status;
    PDNS_ADDR_ARRAY     parray = NULL;
    PDNS_NETINFO        pnetInfo = NULL;
    PDNS_NETWORK_INFO   pnew = NULL;
    PWSTR               pname = NULL;
    PWSTR               pnameAlloc = NULL;

    DNSDBG( TRACE, (
        "DnsNetworkInfo_CreateFromFAZ( %s )\n", pszName ));

    //  convert to DNS_ADDR_ARRAY

    if ( pIp4Servers )
    {
        parray = DnsAddrArray_CreateFromIp4Array( pIp4Servers );
        if ( !parray )
        {
            status = DNS_ERROR_NO_MEMORY;
            goto Done;
        }
    }

    //  convert name to unicode
    //  DCR:  remove when netdiag unicode

    pname = (PWSTR) pszName;

    if ( CharSet != DnsCharSetUnicode )
    {
        pname = Dns_StringCopyAllocate(
                    (PCHAR) pszName,
                    0,              // null terminated
                    CharSet,
                    DnsCharSetUnicode
                    );
        pnameAlloc = pname;
    }

    //  FAZ

    status = Faz_Private(
                (PWSTR) pname,
                dwFlags,
                parray,
                & pnetInfo );

    if ( status != ERROR_SUCCESS )
    {
        goto Done;
    }

    //  convert FAZ results to DNS_NETWORK_INFO

    pnew = DnsNetworkInfo_CreateFromPrivate(
                    pnetInfo,
                    CharSet,
                    FALSE                   // no search list built
                    );
    if ( !pnew )
    {
        status = DNS_ERROR_NO_MEMORY;
    }
    else if ( !pnew->pszPrimaryDomainName ||
              pnew->AdapterCount != 1 ||
              !pnew->AdapterArray[0].pszAdapterDomain )
    {
        DNS_ASSERT( FALSE );
        DnsNetworkInfo_Free( pnew );
        pnew = NULL;
        status = DNS_ERROR_NO_MEMORY;
    }

Done:

    //  DCR:  remove cast once netdiag is in unicode
    *ppNetworkInfo = (PDNS_NETWORK_INFOA) pnew;

    NetInfo_Free( pnetInfo );
    DnsAddrArray_Free( parray );
    Dns_Free( pnameAlloc );

    return  status;
}
#endif

//
//  End netpub.c
//
=== C:/Users/treeman/Desktop/windows nt source code\Source\Win2K3\NT\ds\dns\dnsapi\query.c ===
/*++

Copyright (c) 1997-2001 Microsoft Corporation

Module Name:

    query.c

Abstract:

    Domain Name System (DNS) API

    Query routines.

Author:

    Jim Gilroy (jamesg)     January, 1997

Revision History:

--*/


#include "local.h"


//
//  TTL for answering IP string queries
//      (use a week)
//

#define IPSTRING_RECORD_TTL  (604800)


//
//  Max number of server's we'll ever bother to extract from packet
//  (much more and you're out of UDP packet space anyway)
//

#define MAX_NAME_SERVER_COUNT (20)

            
            

//
//  Query utilities
//
//  DCR:  move to library packet stuff
//

BOOL
IsEmptyDnsResponse(
    IN      PDNS_RECORD     pRecordList
    )
/*++

Routine Description:

    Check for no-answer response.

Arguments:

    pRecordList -- record list to check

Return Value:

    TRUE if no-answers
    FALSE if answers

--*/
{
    PDNS_RECORD prr = pRecordList;
    BOOL        fempty = TRUE;

    while ( prr )
    {
        if ( prr->Flags.S.Section == DNSREC_ANSWER )
        {
            fempty = FALSE;
            break;
        }
        prr = prr->pNext;
    }

    return fempty;
}



BOOL
IsEmptyDnsResponseFromResolver(
    IN      PDNS_RECORD     pRecordList
    )
/*++

Routine Description:

    Check for no-answer response.

Arguments:

    pRecordList -- record list to check

Return Value:

    TRUE if no-answers
    FALSE if answers

--*/
{
    PDNS_RECORD prr = pRecordList;
    BOOL        fempty = TRUE;

    //
    //  resolver sends every thing back as ANSWER section
    //      or section==0 for host file
    //
    //
    //  DCR:  this is lame because the query interface to the
    //          resolver is lame
    //

    while ( prr )
    {
        if ( prr->Flags.S.Section == DNSREC_ANSWER ||
             prr->Flags.S.Section == 0 )
        {
            fempty = FALSE;
            break;
        }
        prr = prr->pNext;
    }

    return fempty;
}



VOID
FixupNameOwnerPointers(
    IN OUT  PDNS_RECORD     pRecord
    )
/*++

Routine Description:

    None.

Arguments:

    None.

Return Value:

    None.

--*/
{
    PDNS_RECORD prr = pRecord;
    PTSTR       pname = pRecord->pName;

    DNSDBG( TRACE, ( "FixupNameOwnerPointers()\n" ));

    while ( prr )
    {
        if ( prr->pName == NULL )
        {
            prr->pName = pname;
        }
        else
        {
            pname = prr->pName;
        }

        prr = prr->pNext;
    }
}



BOOL
IsCacheableNameError(
    IN      PDNS_NETINFO        pNetInfo
    )
/*++

Routine Description:

    Determine if name error is cacheable.

    To this is essentially a check that DNS received results on
    all networks.

Arguments:

    pNetInfo -- pointer to network info used in query

Return Value:

    TRUE if name error cacheable.
    FALSE otherwise (some network did not respond)

--*/
{
    DWORD           iter;
    PDNS_ADAPTER    padapter;

    DNSDBG( TRACE, ( "IsCacheableNameError()\n" ));

    if ( !pNetInfo )
    {
        ASSERT( FALSE );
        return TRUE;
    }

    //
    //  check each adapter
    //      - any that are capable of responding (have DNS servers)
    //      MUST have responded in order for response to be
    //      cacheable
    //
    //  DCR:  return flags DCR
    //      - adapter queried flag
    //      - got response flag (valid response flag?)
    //      - explict negative answer flag
    //
    //  DCR:  cachable negative should come back directly from query
    //      perhaps in netinfo as flag -- "negative on all adapters"
    //

    NetInfo_AdapterLoopStart( pNetInfo );

    while( padapter = NetInfo_GetNextAdapter( pNetInfo ) )
    {
        if ( ( padapter->InfoFlags & AINFO_FLAG_IGNORE_ADAPTER ) ||
             ( padapter->RunFlags & RUN_FLAG_STOP_QUERY_ON_ADAPTER ) )
        {
            continue;
        }

        //  if negative answer on adapter -- fine

        if ( padapter->Status == DNS_ERROR_RCODE_NAME_ERROR ||
             padapter->Status == DNS_INFO_NO_RECORDS )
        {
            ASSERT( padapter->RunFlags & RUN_FLAG_STOP_QUERY_ON_ADAPTER );
            continue;
        }

        //  note, the above should map one-to-one with query stop

        ASSERT( !(padapter->RunFlags & RUN_FLAG_STOP_QUERY_ON_ADAPTER) );

        //  if adapter has no DNS server -- fine
        //      in this case PnP before useful, and the PnP event
        //      will flush the cache

        if ( !padapter->pDnsAddrs )
        {
            continue;
        }

        //  otherwise, this adapter was queried but could not produce a response

        DNSDBG( TRACE, (
            "IsCacheableNameError() -- FALSE\n"
            "\tadapter %d (%S) did not receive response\n"
            "\treturn status = %d\n"
            "\treturn flags  = %08x\n",
            padapter->InterfaceIndex,
            padapter->pszAdapterGuidName,
            padapter->Status,
            padapter->RunFlags ));

        return FALSE;
    }
    
    return TRUE;
}



VOID
query_PrioritizeRecords(
    IN OUT  PQUERY_BLOB     pBlob
    )
/*++

Routine Description:

    Prioritize records in query result.

Arguments:

    pBlob -- query info blob

Return Value:

    None

--*/
{
    PDNS_RECORD prr;

    DNSDBG( TRACE, (
        "query_PrioritizeRecords( %p )\n",
        pBlob
        ));

    //
    //  to prioritize
    //      - prioritize is set
    //      - have more than one A record
    //      - can get IP list
    //
    //  note:  need the callback because resolver uses directly
    //      local copy of IP address info, whereas direct query
    //      RPC's a copy over from the resolver
    //
    //      alternative would be some sort of "set IP source"
    //      function that resolver would call when there's a
    //      new list;  then could have common function that
    //      picks up source if available or does RPC
    //
    //  DCR:  FIX6:  don't prioritize local results
    //  DCR:  FIX6:  prioritize ONLY when SETS in list > 1 record
    //

    if ( !g_PrioritizeRecordData )
    {
        return;
    }

    prr = pBlob->pRecords;

    if ( Dns_RecordListCount( prr, DNS_TYPE_A ) > 1 )
    {
        PDNS_ADDR_ARRAY paddrArray;

        //  create local addr array from netinfo blob

        paddrArray = NetInfo_CreateLocalAddrArray(
                            pBlob->pNetInfo,
                            NULL,       // no specific adapter name
                            NULL,       // no specific adapter
                            AF_INET,
                            FALSE       // no cluster addrs
                            );

        //  prioritize against local addrs

        pBlob->pRecords = Dns_PrioritizeRecordList(
                                prr,
                                paddrArray );
        FREE_HEAP( paddrArray );
    }
}



//
//  Query name building utils
//

BOOL
ValidateQueryTld(
    IN      PWSTR           pTld
    )
/*++

Routine Description:

    Validate query TLD

Arguments:

    pTld -- TLD to validate

Return Value:

    TRUE if valid
    FALSE otherwise

--*/
{
    //
    //  numeric
    //

    if ( g_ScreenBadTlds & DNS_TLD_SCREEN_NUMERIC )
    {
        if ( Dns_IsNameNumericW( pTld ) )
        {
            return  FALSE;
        }
    }

    //
    //  bogus TLDs
    //

    if ( g_ScreenBadTlds & DNS_TLD_SCREEN_WORKGROUP )
    {
        if ( Dns_NameCompare_W(
                L"workgroup",
                pTld ))
        {
            return  FALSE;
        }
    }

    //  not sure about these
    //  probably won't turn on screening by default

    if ( g_ScreenBadTlds & DNS_TLD_SCREEN_DOMAIN )
    {
        if ( Dns_NameCompare_W(
                L"domain",
                pTld ))
        {
            return  FALSE;
        }
    }
    if ( g_ScreenBadTlds & DNS_TLD_SCREEN_OFFICE )
    {
        if ( Dns_NameCompare_W(
                L"office",
                pTld ))
        {
            return  FALSE;
        }
    }
    if ( g_ScreenBadTlds & DNS_TLD_SCREEN_HOME )
    {
        if ( Dns_NameCompare_W(
                L"home",
                pTld ))
        {
            return  FALSE;
        }
    }

    return  TRUE;
}



BOOL
ValidateQueryName(
    IN      PQUERY_BLOB     pBlob,
    IN      PWSTR           pName,
    IN      PWSTR           pDomain
    )
/*++

Routine Description:

    Validate name for wire query.

Arguments:

    pBlob -- query blob

    pName -- name;  may be any sort of name

    pDomain -- domain name to append

Return Value:

    TRUE if name query will be valid.
    FALSE otherwise.

--*/
{
    WORD    wtype;
    PWSTR   pnameTld;
    PWSTR   pdomainTld;

    //  no screening -- bail

    if ( g_ScreenBadTlds == 0 )
    {
        return  TRUE;
    }

    //  only screening for standard types
    //      - A, AAAA, SRV

    wtype = pBlob->wType;
    if ( wtype != DNS_TYPE_A    &&
         wtype != DNS_TYPE_AAAA &&
         wtype != DNS_TYPE_SRV )
    {
        return  TRUE;
    }

    //  get name TLD

    pnameTld = Dns_GetTldForNameW( pName );

    //
    //  if no domain appended
    //      - exclude single label
    //      - exclude bad TLD (numeric, bogus domain)
    //      - but allow root queries
    //
    //  DCR:  MS DCS screening
    //  screen
    //      _msdcs.<name>
    //      will probably be unappended query
    //

    if ( !pDomain )
    {
        if ( !pnameTld ||
             !ValidateQueryTld( pnameTld ) )
        {
            goto Failed;
        }
        return  TRUE;
    }

    //
    //  domain appended
    //      - exclude bad TLD (numeric, bogus domain)
    //      - exclude matching TLD 
    //

    pdomainTld = Dns_GetTldForNameW( pDomain );
    if ( !pdomainTld )
    {
        pdomainTld = pDomain;
    }

    if ( !ValidateQueryTld( pdomainTld ) )
    {
        goto Failed;
    }

    //  screen repeated TLD

    if ( g_ScreenBadTlds & DNS_TLD_SCREEN_REPEATED )
    {
        if ( Dns_NameCompare_W(
                pnameTld,
                pdomainTld ) )
        {
            goto Failed;
        }
    }

    return  TRUE;

Failed:

    DNSDBG( QUERY, (
        "Failed invalid query name:\n"
        "\tname     %S\n"
        "\tdomain   %S\n",
        pName,
        pDomain ));

    return  FALSE;
}



PWSTR
GetNextAdapterDomainName(
    IN OUT  PDNS_NETINFO        pNetInfo
    )
/*++

Routine Description:

    Get next adapter domain name to query.

Arguments:

    pNetInfo -- DNS Network info for query;
        adapter data will be modified (InfoFlags field)
        to indicate which adapter to query and which
        to skip query on

Return Value:

    Ptr to domain name (UTF8) to query.
    NULL if no more domain names to query.

--*/
{
    DWORD           iter;
    PWSTR           pqueryDomain = NULL;
    PDNS_ADAPTER    padapter;

    DNSDBG( TRACE, ( "GetNextAdapterDomainName()\n" ));

    if ( ! pNetInfo )
    {
        ASSERT( FALSE );
        return NULL;
    }

    IF_DNSDBG( OFF )
    {
        DnsDbg_NetworkInfo(
            "Net info to get adapter domain name from: ",
            pNetInfo );
    }

    //
    //  check each adapter
    //      - first unqueried adapter with name is chosen
    //      - other adapters with
    //          - matching name => included in query
    //          - non-matching => turned OFF for query
    //
    //  DCR:  query on\off should use adapter dynamic flags
    //

    NetInfo_AdapterLoopStart( pNetInfo );

    while( padapter = NetInfo_GetNextAdapter( pNetInfo ) )
    {
        PWSTR   pdomain;

        //
        //  clear single-name-query-specific flags
        //      these flags are set for each name, determining
        //      whether adapter participates
        //

        padapter->RunFlags &= ~RUN_FLAG_SINGLE_NAME_MASK;

        //
        //  ignore
        //      - ignored adapter OR
        //      - previously queried adapter domain
        //      note:  it can't match any "fresh" domain we come up with
        //      as we always collect all matches
        //
        //  DCR:  problem with adapter domain names on "ignored adapters"
        //      - we'd like to keep adapter in query if other adapter has the name
        //      - we'd like to query name on this adapter if we absolutely run
        //      out of other names to query
        //

        if ( (padapter->InfoFlags & AINFO_FLAG_IGNORE_ADAPTER)
                ||
             (padapter->RunFlags & RUN_FLAG_QUERIED_ADAPTER_DOMAIN) )
        {
            padapter->RunFlags |= RUN_FLAG_STOP_QUERY_ON_ADAPTER;
            continue;
        }

        //  no domain name -- always off

        pdomain = padapter->pszAdapterDomain;
        if ( !pdomain )
        {
            padapter->RunFlags |= (RUN_FLAG_QUERIED_ADAPTER_DOMAIN |
                                   RUN_FLAG_STOP_QUERY_ON_ADAPTER);
            continue;
        }

        //  first "fresh" domain name -- save, turn on and flag as used

        if ( !pqueryDomain )
        {
            pqueryDomain = pdomain;
            padapter->RunFlags |= RUN_FLAG_QUERIED_ADAPTER_DOMAIN;
            continue;
        }

        //  other "fresh" domain names
        //      - if matches query domain => on for query
        //      - no match => off

        if ( Dns_NameCompare_W(
                pqueryDomain,
                pdomain ) )
        {
            padapter->RunFlags |= RUN_FLAG_QUERIED_ADAPTER_DOMAIN;
            continue;
        }
        else
        {
            padapter->RunFlags |= RUN_FLAG_STOP_QUERY_ON_ADAPTER;
            continue;
        }
    }

    //
    //  if no adapter domain name -- clear STOP flag
    //      - all adapters participate in other names (name devolution)
    //

    if ( !pqueryDomain )
    {
        NetInfo_AdapterLoopStart( pNetInfo );
    
        while( padapter = NetInfo_GetNextAdapter( pNetInfo ) )
        {
            padapter->RunFlags &= (~RUN_FLAG_SINGLE_NAME_MASK );
        }

        DNSDBG( INIT2, (
            "GetNextAdapterDomainName out of adapter names.\n" ));

        pNetInfo->ReturnFlags |= RUN_FLAG_QUERIED_ADAPTER_DOMAIN;
    }

    IF_DNSDBG( INIT2 )
    {
        if ( pqueryDomain )
        {
            DnsDbg_NetworkInfo(
                "Net info after adapter name select: ",
                pNetInfo );
        }
    }

    DNSDBG( INIT2, (
        "Leaving GetNextAdapterDomainName() => %S\n",
        pqueryDomain ));

    return pqueryDomain;
}



PWSTR
GetNextDomainNameToAppend(
    IN OUT  PDNS_NETINFO        pNetInfo,
    OUT     PDWORD              pSuffixFlags
    )
/*++

Routine Description:

    Get next adapter domain name to query.

Arguments:

    pNetInfo -- DNS Network info for query;
        adapter data will be modified (RunFlags field)
        to indicate which adapter to query and which
        to skip query on

    pSuffixFlags -- flags associated with the use of this suffix

Return Value:

    Ptr to domain name (UTF8) to query.
    NULL if no more domain names to query.

--*/
{
    PWSTR   psearchName;
    PWSTR   pdomain;

    //
    //  search list if real search list  
    //
    //  if suffix flags zero, then this is REAL search list
    //  or is PDN name
    //

    psearchName = SearchList_GetNextName(
                        pNetInfo->pSearchList,
                        FALSE,              // not reset
                        pSuffixFlags );

    if ( psearchName && (*pSuffixFlags == 0) )
    {
        //  found regular search name -- done

        DNSDBG( INIT2, (
            "getNextDomainName from search list => %S, %d\n",
            psearchName,
            *pSuffixFlags ));
        return( psearchName );
    }

    //
    //  try adapter domain names
    //
    //  but ONLY if search list is dummy;  if real we only
    //  use search list entries
    //
    //  DCR_CLEANUP:  eliminate bogus search list
    //

    if ( pNetInfo->InfoFlags & NINFO_FLAG_DUMMY_SEARCH_LIST
            &&
         ! (pNetInfo->ReturnFlags & RUN_FLAG_QUERIED_ADAPTER_DOMAIN) )
    {
        pdomain = GetNextAdapterDomainName( pNetInfo );
        if ( pdomain )
        {
            *pSuffixFlags = DNS_QUERY_USE_QUICK_TIMEOUTS;
    
            DNSDBG( INIT2, (
                "getNextDomainName from adapter domain name => %S, %d\n",
                pdomain,
                *pSuffixFlags ));

            //  back the search list up one tick
            //  we queried through it above, so if it was returing
            //  a name, we need to get that name again on next query

            if ( psearchName )
            {
                ASSERT( pNetInfo->pSearchList->CurrentNameIndex > 0 );
                pNetInfo->pSearchList->CurrentNameIndex--;
            }
            return( pdomain );
        }
    }

    //
    //  DCR_CLEANUP:  remove devolution from search list and do explicitly
    //      - its cheap (or do it once and save, but store separately)
    //

    //
    //  finally use and devolved search names (or other nonsense)
    //

    *pSuffixFlags = DNS_QUERY_USE_QUICK_TIMEOUTS;

    DNSDBG( INIT2, (
        "getNextDomainName from devolution\\other => %S, %d\n",
        psearchName,
        *pSuffixFlags ));

    return( psearchName );
}



PWSTR
GetNextQueryName(
    IN OUT  PQUERY_BLOB         pBlob
    )
/*++

Routine Description:

    Get next name to query.

Arguments:

    pBlob - blob of query information

    Uses:
        NameOriginalWire
        NameAttributes
        QueryCount
        pNetworkInfo

    Sets:
        NameWire -- set with appended wire name
        pNetworkInfo -- runtime flags set to indicate which adapters are
            queried
        NameFlags -- set with properties of name
        fAppendedName -- set when name appended

Return Value:

    Ptr to name to query with.
        - will be orginal name on first query if name is multilabel name
        - otherwise will be NameWire buffer which will contain appended name
            composed of pszName and some domain name
    NULL if no more names to append

--*/
{
    PWSTR   pnameOrig   = pBlob->pNameOrig;
    PWSTR   pdomainName = NULL;
    PWSTR   pnameBuf;
    DWORD   queryCount  = pBlob->QueryCount;
    DWORD   nameAttributes = pBlob->NameAttributes;


    DNSDBG( TRACE, (
        "GetNextQueryName( %p )\n",
        pBlob ));


    //  default suffix flags

    pBlob->NameFlags = 0;


    //
    //  DCR:  cannonical name
    //      probably should canonicalize original name first\once
    //
    //  DCR:  multiple checks on original name
    //      the way this works we repeatedly get the TLD and do
    //      check on orginal name
    //
    //  DCR:  if fail to validate\append ANY domain, then will
    //      fail -- should make sure INVALID_NAME is the result
    //


    //
    //  FQDN
    //      - send FQDN only
    //

    if ( nameAttributes & DNS_NAME_IS_FQDN )
    {
        if ( queryCount == 0 )
        {
#if 0
            //  currently won't even validate FQDN
            if ( ValidateQueryName(
                    pBlob,
                    pnameOrig,
                    NULL ) )
            {
                return  pnameOrig;
            }
#endif
            return  pnameOrig;
        }
        DNSDBG( QUERY, (
            "No append for FQDN name %S -- end query.\n",
            pnameOrig ));
        return  NULL;
    }

    //
    //  multilabel
    //      - first pass on name itself -- if valid
    //
    //  DCR:  intelligent choice on multi-label whether append first
    //      or go to wire first  (example foo.ntdev) could append
    //      first
    //

    if ( nameAttributes & DNS_NAME_MULTI_LABEL )
    {
        if ( queryCount == 0 )
        {
            if ( ValidateQueryName(
                    pBlob,
                    pnameOrig,
                    NULL ) )
            {
                return  pnameOrig;
            }
        }

        if ( !g_AppendToMultiLabelName )
        {
            DNSDBG( QUERY, (
                "No append allowed on multi-label name %S -- end query.\n",
                pnameOrig ));
            return  NULL;
        }

        //  falls through to appending on multi-label names
    }

    //
    //  not FQDN -- append a domain name
    //      - next search name (if available)
    //      - otherwise next adapter domain name
    //

    pnameBuf = pBlob->NameBuffer;

    while ( 1 )
    {
        pdomainName = GetNextDomainNameToAppend(
                            pBlob->pNetInfo,
                            & pBlob->NameFlags );
        if ( !pdomainName )
        {
            DNSDBG( QUERY, (
                "No more domain names to append -- end query\n" ));
            return  NULL;
        }

        if ( !ValidateQueryName(
                pBlob,
                pnameOrig,
                pdomainName ) )
        {
            continue;
        }

        //  append domain name to name

        if ( Dns_NameAppend_W(
                pnameBuf,
                DNS_MAX_NAME_BUFFER_LENGTH,
                pnameOrig,
                pdomainName ) )
        {
            pBlob->fAppendedName = TRUE;
            break;
        }
    }

    DNSDBG( QUERY, (
        "GetNextQueryName() result => %S\n",
        pnameBuf ));

    return pnameBuf;
}



DNS_STATUS
QueryDirectEx(
    IN OUT  PDNS_MSG_BUF *      ppMsgResponse,
    OUT     PDNS_RECORD *       ppResponseRecords,
    IN      PDNS_HEADER         pHeader,
    IN      BOOL                fNoHeaderCounts,
    IN      PCHAR               pszQuestionName,
    IN      WORD                wQuestionType,
    IN      PDNS_RECORD         pRecords,
    IN      DWORD               dwFlags,
    IN      PIP4_ARRAY          aipServerList,
    IN OUT  PDNS_NETINFO        pNetInfo
    )
/*++

Routine Description:

    Query.

    DCR:  remove EXPORTED:  QueryDirectEx  (dnsup.exe)

Arguments:

    ppMsgResponse -- addr to recv ptr to response buffer;  caller MUST
        free buffer

    ppResponseRecord -- address to receive ptr to record list returned from query

    pHead -- DNS header to send

    fNoHeaderCounts - do NOT include record counts in copying header

    pszQuestionName -- DNS name to query;
        Unicode string if dwFlags has DNSQUERY_UNICODE_NAME set.
        ANSI string otherwise.

    wType -- query type

    pRecords -- address to receive ptr to record list returned from query

    dwFlags -- query flags

    aipServerList -- specific DNS servers to query;
        OPTIONAL, if specified overrides normal list associated with machine

    pDnsNetAdapters -- DNS servers to query;  if NULL get current list


Return Value:

    ERROR_SUCCESS if successful.
    Error code on failure.

--*/
{
    PDNS_MSG_BUF    psendMsg;
    DNS_STATUS      status = DNS_ERROR_NO_MEMORY;

    DNSDBG( QUERY, (
        "QueryDirectEx()\n"
        "\tname         %s\n"
        "\ttype         %d\n"
        "\theader       %p\n"
        "\t - counts    %d\n"
        "\trecords      %p\n"
        "\tflags        %08x\n"
        "\trecv msg     %p\n"
        "\trecv records %p\n"
        "\tserver IPs   %p\n"
        "\tadapter list %p\n",
        pszQuestionName,
        wQuestionType,
        pHeader,
        fNoHeaderCounts,
        pRecords,
        dwFlags,
        ppMsgResponse,
        ppResponseRecords,
        aipServerList,
        pNetInfo ));

    //
    //  build send packet
    //

    psendMsg = Dns_BuildPacket(
                    pHeader,
                    fNoHeaderCounts,
                    (PDNS_NAME) pszQuestionName,
                    wQuestionType,
                    pRecords,
                    dwFlags,
                    FALSE       // query, not an update
                    );
    if ( !psendMsg )
    {
        status = ERROR_INVALID_NAME;
        goto Cleanup;
    }

#if MULTICAST_ENABLED

    //
    //  QUESTION:  mcast test is not complete here
    //      - should first test that we actually do it
    //      including whether we have DNS servers
    //  FIXME:  then when we do do it -- encapsulate it
    //      ShouldMulicastQuery()
    //
    // Check to see if name is for something in the multicast local domain.
    // If so, set flag to multicast this query only.
    //

    if ( Dns_NameCompareEx( pszQuestionName,
                            ( dwFlags & DNSQUERY_UNICODE_NAME ) ?
                              (LPSTR) MULTICAST_DNS_LOCAL_DOMAIN_W :
                              MULTICAST_DNS_LOCAL_DOMAIN,
                            0,
                            ( dwFlags & DNSQUERY_UNICODE_NAME ) ?
                              DnsCharSetUnicode :
                              DnsCharSetUtf8 ) ==
                            DnsNameCompareRightParent )
    {
        dwFlags |= DNS_QUERY_MULTICAST_ONLY;
    }
#endif

    //
    //  send query and receive response
    //

    Trace_LogQueryEvent(
        psendMsg,
        wQuestionType );

    {
        SEND_BLOB   sendBlob;

        RtlZeroMemory( &sendBlob, sizeof(sendBlob) );

        sendBlob.pSendMsg           = psendMsg;
        sendBlob.pServ4List         = aipServerList;
        sendBlob.Flags              = dwFlags;
        sendBlob.fSaveResponse      = (ppMsgResponse != NULL);
        sendBlob.fSaveRecords       = (ppResponseRecords != NULL);
        sendBlob.Results.pMessage   = (ppMsgResponse) ? *ppMsgResponse : NULL;

        status = Send_AndRecv( &sendBlob );

        if ( ppMsgResponse )
        {
            *ppMsgResponse = sendBlob.Results.pMessage;
        }
        if ( ppResponseRecords )
        {
            *ppResponseRecords = sendBlob.Results.pRecords;
        }
    }

    Trace_LogResponseEvent(
        psendMsg,
        ( ppResponseRecords && *ppResponseRecords )
            ? (*ppResponseRecords)->wType
            : 0,
        status );

Cleanup:

    FREE_HEAP( psendMsg );

    DNSDBG( QUERY, (
        "Leaving QueryDirectEx(), status = %s (%d)\n",
        Dns_StatusString(status),
        status ));

    return( status );
}



DNS_STATUS
Query_SingleName(
    IN OUT  PQUERY_BLOB         pBlob
    )
/*++

Routine Description:

    Query single name.

Arguments:

    pBlob - query blob

Return Value:

    ERROR_SUCCESS if successful.
    Error code on failure.

--*/
{
    PDNS_MSG_BUF    psendMsg = NULL;
    DNS_STATUS      status = DNS_ERROR_NO_MEMORY;
    DWORD           flags = pBlob->Flags;

    DNSDBG( QUERY, (
        "Query_SingleName( %p )\n",
        pBlob ));

    IF_DNSDBG( QUERY )
    {
        DnsDbg_QueryBlob(
            "Enter Query_SingleName()",
            pBlob );
    }

    //
    //  cache\hostfile callback on appended name
    //      - note that queried name was already done
    //      (in resolver or in Query_Main())
    //

    if ( pBlob->pfnQueryCache  &&  pBlob->fAppendedName )
    {
        if ( (pBlob->pfnQueryCache)( pBlob ) )
        {
            status = pBlob->Status;
            goto Cleanup;
        }
    }

    //
    //  if wire disallowed -- stop here
    //

    if ( flags & DNS_QUERY_NO_WIRE_QUERY )
    {
        status = DNS_ERROR_NAME_NOT_FOUND_LOCALLY;
        pBlob->Status = status;
        goto Cleanup;
    }

    //
    //  build send packet
    //

    psendMsg = Dns_BuildPacket(
                    NULL,           // no header
                    0,              // no header counts
                    (PDNS_NAME) pBlob->pNameQuery,
                    pBlob->wType,
                    NULL,           // no records
                    flags | DNSQUERY_UNICODE_NAME,
                    FALSE           // query, not an update
                    );
    if ( !psendMsg )
    {
        status = DNS_ERROR_INVALID_NAME;
        goto Cleanup;
    }


#if MULTICAST_ENABLED

    //
    //  QUESTION:  mcast test is not complete here
    //      - should first test that we actually do it
    //      including whether we have DNS servers
    //  FIXME:  then when we do do it -- encapsulate it
    //      ShouldMulicastQuery()
    //
    // Check to see if name is for something in the multicast local domain.
    // If so, set flag to multicast this query only.
    //

    if ( Dns_NameCompareEx(
                pBlob->pName,
                ( flags & DNSQUERY_UNICODE_NAME )
                    ? (LPSTR) MULTICAST_DNS_LOCAL_DOMAIN_W
                    : MULTICAST_DNS_LOCAL_DOMAIN,
                0,
                ( flags & DNSQUERY_UNICODE_NAME )
                    ? DnsCharSetUnicode
                    : DnsCharSetUtf8 )
            == DnsNameCompareRightParent )
    {
        flags |= DNS_QUERY_MULTICAST_ONLY;
    }
#endif

    //
    //  send query and receive response
    //

    Trace_LogQueryEvent(
        psendMsg,
        pBlob->wType );

    {
        SEND_BLOB   sendBlob;

        RtlZeroMemory( &sendBlob, sizeof(sendBlob) );

        sendBlob.pSendMsg       = psendMsg;
        sendBlob.pNetInfo       = pBlob->pNetInfo;
        sendBlob.pServerList    = pBlob->pServerList;
        sendBlob.pServ4List     = pBlob->pServerList4;
        sendBlob.Flags          = flags;
        sendBlob.fSaveResponse  = (flags & DNS_QUERY_RETURN_MESSAGE);
        sendBlob.fSaveRecords   = TRUE;

        status = Send_AndRecv( &sendBlob );

        pBlob->pRecvMsg = sendBlob.Results.pMessage;
        pBlob->pRecords = sendBlob.Results.pRecords;
    }

    Trace_LogResponseEvent(
        psendMsg,
        ( pBlob->pRecords )
            ? (pBlob->pRecords)->wType
            : 0,
        status );

Cleanup:

    FREE_HEAP( psendMsg );

    DNSDBG( QUERY, (
        "Leaving Query_SingleName(), status = %s (%d)\n",
        Dns_StatusString(status),
        status ));

    IF_DNSDBG( QUERY )
    {
        DnsDbg_QueryBlob(
            "Blob leaving Query_SingleName()",
            pBlob );
    }
    return( status );
}



DNS_STATUS
Query_Main(
    IN OUT  PQUERY_BLOB     pBlob
    )
/*++

Routine Description:

    Main query routine.

    Does all the query processing
        - local lookup
        - name appending
        - cache\hostfile lookup on appended name
        - query to server

Arguments:

    pBlob -- query info blob

Return Value:

    ERROR_SUCCESS if successful response.
    DNS_INFO_NO_RECORDS on no records for type response.
    DNS_ERROR_RCODE_NAME_ERROR on name error.
    DNS_ERROR_INVALID_NAME on bad name.
    None

--*/
{
    DNS_STATUS          status = DNS_ERROR_NAME_NOT_FOUND_LOCALLY;
    PWSTR               pdomainName = NULL;
    PDNS_RECORD         precords;
    DWORD               queryFlags;
    DWORD               suffixFlags = 0;
    DWORD               nameAttributes;
    DNS_STATUS          bestQueryStatus = ERROR_SUCCESS;
    BOOL                fcacheNegative = TRUE;
    DWORD               flagsIn = pBlob->Flags;
    PDNS_NETINFO        pnetInfo = pBlob->pNetInfo;
    DWORD               nameLength;
    DWORD               bufLength;
    DWORD               queryCount;


    DNSDBG( TRACE, (
        "\n\nQuery_Main( %p )\n"
        "\t%S, f=%08x, type=%d, time = %d\n",
        pBlob,
        pBlob->pNameOrig,
        flagsIn,
        pBlob->wType,
        Dns_GetCurrentTimeInSeconds()
        ));

    //
    //  clear out params
    //

    pBlob->pRecords         = NULL;
    pBlob->pLocalRecords    = NULL;
    pBlob->fCacheNegative   = FALSE;
    pBlob->fNoIpLocal       = FALSE;
    pBlob->NetFailureStatus = ERROR_SUCCESS;

    //
    //  DCR:  canonicalize original name?
    //

#if 0
    bufLength = DNS_MAX_NAME_BUFFER_LENGTH;

    nameLength = Dns_NameCopy(
                    pBlob->NameOriginalWire,
                    & bufLength,
                    (PSTR) pBlob->pNameOrig,
                    0,                  // name is NULL terminated
                    DnsCharSetUnicode,
                    DnsCharSetWire );

    if ( nameLength == 0 )
    {
        return DNS_ERROR_INVALID_NAME;
    }
    nameLength--;
    pBlob->NameLength = nameLength;
    pBlob->pNameOrigWire = pBlob->NameOriginalWire;
#endif

    //
    //  determine name properties
    //      - determines number and order of name queries
    //

    nameAttributes = Dns_GetNameAttributesW( pBlob->pNameOrig );

    if ( flagsIn & DNS_QUERY_TREAT_AS_FQDN )
    {
        nameAttributes |= DNS_NAME_IS_FQDN;
    }
    pBlob->NameAttributes = nameAttributes;

    //
    //  hostfile lookup
    //      - called in process
    //      - hosts file lookup allowed
    //      -> then must do hosts file lookup before appending\queries
    //
    //  note:  this matches the hostsfile\cache lookup in resolver
    //      before call;  hosts file queries to appended names are
    //      handled together by callback in Query_SingleName()
    //
    //      we MUST make this callback here, because it must PRECEDE
    //      the local name call, as some customers specifically direct
    //      some local mappings in the hosts file
    //

    if ( pBlob->pfnQueryCache == HostsFile_Query
            &&
         ! (flagsIn & DNS_QUERY_NO_HOSTS_FILE) )
    {
        pBlob->pNameQuery = pBlob->pNameOrig;

        if ( HostsFile_Query( pBlob ) )
        {
            status = pBlob->Status;
            goto Done;
        }
    }

    //
    //  check for local name
    //      - if successful, skip wire query
    //

    if ( ! (flagsIn & DNS_QUERY_NO_LOCAL_NAME) )
    {
        status = Local_GetRecordsForLocalName( pBlob );

        if ( status == ERROR_SUCCESS  &&
             !pBlob->fNoIpLocal )
        {
            DNS_ASSERT( pBlob->pRecords &&
                        pBlob->pRecords == pBlob->pLocalRecords );
            goto Done;
        }
    }

    //
    //  query until
    //      - successfull
    //      - exhaust names to query with
    //

    queryCount = 0;

    while ( 1 )
    {
        PWSTR   pqueryName;

        //  clean name specific info from list

        if ( queryCount != 0 )
        {
            NetInfo_Clean(
                pnetInfo,
                CLEAR_LEVEL_SINGLE_NAME );
        }

        //
        //  next query name
        //

        pqueryName = GetNextQueryName( pBlob );
        if ( !pqueryName )
        {
            if ( queryCount == 0 )
            {
                status = DNS_ERROR_INVALID_NAME;
            }
            break;
        }
        pBlob->QueryCount = ++queryCount;
        pBlob->pNameQuery = pqueryName;

        DNSDBG( QUERY, (
            "Query %d is for name %S\n",
            queryCount,
            pqueryName ));

        //
        //  set flags
        //      - passed in flags
        //      - unicode results
        //      - flags for this particular suffix

        pBlob->Flags = flagsIn | pBlob->NameFlags;

        //
        //  clear any previously received records (shouldn't be any)
        //

        if ( pBlob->pRecords )
        {
            DNS_ASSERT( FALSE );
            Dns_RecordListFree( pBlob->pRecords );
            pBlob->pRecords = NULL;
        }

        //
        //  do the query for name
        //  includes
        //      - cache or hostfile lookup
        //      - wire query
        //

        status = Query_SingleName( pBlob );

        //
        //  clean out records on "non-response"
        //
        //  DCR:  need to fix record return
        //      - should keep records on any response (best response)
        //      just make sure NO_RECORDS rcode is mapped
        //
        //  the only time we keep them is FAZ
        //      - ALLOW_EMPTY_AUTH flag set
        //      - sending FQDN (or more precisely doing single query)
        //

        precords = pBlob->pRecords;

        if ( precords )
        {
            if ( IsEmptyDnsResponse( precords ) )
            {
                if ( (flagsIn & DNS_QUERY_ALLOW_EMPTY_AUTH_RESP)
                        &&
                     ( (nameAttributes & DNS_NAME_IS_FQDN)
                            ||
                       ((nameAttributes & DNS_NAME_MULTI_LABEL) &&
                            !g_AppendToMultiLabelName ) ) )
                {
                    //  stop here as caller (probably FAZ code)
                    //  wants to get the authority records

                    DNSDBG( QUERY, (
                        "Returning empty query response with authority records.\n" ));
                    break;
                }
                else
                {
                    Dns_RecordListFree( precords );
                    pBlob->pRecords = NULL;
                    if ( status == NO_ERROR )
                    {
                        status = DNS_INFO_NO_RECORDS;
                    }
                }
            }
        }

        //  successful query -- done

        if ( status == ERROR_SUCCESS )
        {
            RTL_ASSERT( precords );
            break;
        }

#if 0
        //
        //  DCR_FIX0:  lost adapter timeout from early in multi-name query
        //      - callback here or some other approach
        //
        //  this is resolver version
        //

        //  reset server priorities on failures
        //  do here to avoid washing out info in retry with new name
        //

        if ( status != ERROR_SUCCESS &&
             (pnetInfo->ReturnFlags & RUN_FLAG_RESET_SERVER_PRIORITY) )
        {
            if ( g_AdapterTimeoutCacheTime &&
                 Dns_DisableTimedOutAdapters( pnetInfo ) )
            {
                fadapterTimedOut = TRUE;
                SetKnownTimedOutAdapter();
            }
        }

        //
        //  DCR_CLEANUP:  lost intermediate timed out adapter deal
        //

        if ( status != NO_ERROR &&
             (pnetInfo->ReturnFlags & RUN_FLAG_RESET_SERVER_PRIORITY) )
        {
            Dns_DisableTimedOutAdapters( pnetInfo );
        }
#endif

        //
        //  save first query error (for some errors)
        //

        if ( queryCount == 1 &&
             ( status == DNS_ERROR_RCODE_NAME_ERROR ||
               status == DNS_INFO_NO_RECORDS ||
               status == DNS_ERROR_INVALID_NAME ||
               status == DNS_ERROR_RCODE_SERVER_FAILURE ||
               status == DNS_ERROR_RCODE_FORMAT_ERROR ) )
        {
            DNSDBG( QUERY, (
                "Saving bestQueryStatus %d\n",
                status ));
            bestQueryStatus = status;
        }

        //
        //  continue with other queries on some errors
        //
        //  on NAME_ERROR or NO_RECORDS response
        //      - check if this negative result will be
        //      cacheable, if it holds up
        //
        //  note:  the reason we check every time is that when the
        //      query involves several names, one or more may fail
        //      with one network timing out, YET the final name
        //      queried indeed is a NAME_ERROR everywhere;  hence
        //      we can not do the check just once on the final
        //      negative response;
        //      in short, every negative response must be determinative
        //      in order for us to cache
        //
    
        if ( status == DNS_ERROR_RCODE_NAME_ERROR ||
             status == DNS_INFO_NO_RECORDS )
        {
            if ( fcacheNegative )
            {
                fcacheNegative = IsCacheableNameError( pnetInfo );
            }
            if ( status == DNS_INFO_NO_RECORDS )
            {
                DNSDBG( QUERY, (
                    "Saving bestQueryStatus %d\n",
                    status ));
                bestQueryStatus = status;
            }
            continue;
        }
    
        //  server failure may indicate intermediate or remote
        //      server timeout and hence also makes any final
        //      name error determination uncacheable
    
        else if ( status == DNS_ERROR_RCODE_SERVER_FAILURE )
        {
            fcacheNegative = FALSE;
            continue;
        }
    
        //  busted name errors
        //      - just continue with next query
    
        else if ( status == DNS_ERROR_INVALID_NAME ||
                  status == DNS_ERROR_RCODE_FORMAT_ERROR )
        {
            continue;
        }
        
        //
        //  other errors -- ex. timeout and winsock -- are terminal
        //

        else
        {
            fcacheNegative = FALSE;
            break;
        }
    }


    DNSDBG( QUERY, (
        "Query_Main() -- name loop termination\n"
        "\tstatus       = %d\n"
        "\tquery count  = %d\n",
        status,
        queryCount ));

    //
    //  if no queries then invalid name
    //      - either name itself is invalid
    //      OR
    //      - single part name and don't have anything to append
    //

    DNS_ASSERT( queryCount != 0 ||
                status == DNS_ERROR_INVALID_NAME );

    //
    //  success -- prioritize record data
    //
    //  to prioritize
    //      - prioritize is set
    //      - have more than one A record
    //      - can get IP list
    //
    //  note:  need the callback because resolver uses directly
    //      local copy of IP address info, whereas direct query
    //      RPC's a copy over from the resolver
    //
    //      alternative would be some sort of "set IP source"
    //      function that resolver would call when there's a
    //      new list;  then could have common function that
    //      picks up source if available or does RPC
    //

    if ( status == ERROR_SUCCESS )
    {
        query_PrioritizeRecords( pBlob );
    }

#if 0
    //
    //  no-op common negative response
    //  doing this for perf to skip extensive status code check below
    //

    else if ( status == DNS_ERROR_RCODE_NAME_ERROR ||
              status == DNS_INFO_NO_RECORDS )
    {
        // no-op
    }

    //
    //  timeout indicates possible network problem
    //  winsock errors indicate definite network problem
    //

    else if (
        status == ERROR_TIMEOUT     ||
        status == WSAEFAULT         ||
        status == WSAENOTSOCK       ||
        status == WSAENETDOWN       ||
        status == WSAENETUNREACH    ||
        status == WSAEPFNOSUPPORT   ||
        status == WSAEAFNOSUPPORT   ||
        status == WSAEHOSTDOWN      ||
        status == WSAEHOSTUNREACH )
    {
        pBlob->NetFailureStatus = status;
    }
#endif

#if 0
        //
        //  DCR:  not sure when to free message buffer
        //
        //      - it is reused in Dns_QueryLib call, so no leak
        //      - point is when to return it
        //      - old QuickQueryEx() would dump when going around again?
        //          not sure of the point of that
        //

        //
        //   going around again -- free up message buffer
        //

        if ( ppMsgResponse && *ppMsgResponse )
        {
            FREE_HEAP( *ppMsgResponse );
            *ppMsgResponse = NULL;
        }
#endif

    //
    //  use NO-IP local name?
    //
    //  if matched local name but had no IPs (IP6 currently)
    //  then use default here if not successful wire query
    //

    if ( pBlob->fNoIpLocal )
    {
        if ( status != ERROR_SUCCESS )
        {
            Dns_RecordListFree( pBlob->pRecords );
            pBlob->pRecords = pBlob->pLocalRecords;
            status = ERROR_SUCCESS;
            pBlob->Status = status;
        }
        else
        {
            Dns_RecordListFree( pBlob->pLocalRecords );
            pBlob->pLocalRecords = NULL;
        }
    }

    //
    //  if error, use "best" error
    //  this is either
    //      - original query response
    //      - or NO_RECORDS response found later
    //

    if ( status != ERROR_SUCCESS  &&  bestQueryStatus )
    {
        status = bestQueryStatus;
        pBlob->Status = status;
    }

    //
    //  set negative response cacheability
    //

    pBlob->fCacheNegative = fcacheNegative;


Done:

    DNS_ASSERT( !pBlob->pLocalRecords ||
                pBlob->pLocalRecords == pBlob->pRecords );

    //
    //  check no-servers failure
    //

    if ( status != ERROR_SUCCESS  &&
         pnetInfo &&
         (pnetInfo->InfoFlags & NINFO_FLAG_NO_DNS_SERVERS) )
    {
        DNSDBG( TRACE, (
            "Replacing query status %d with NO_DNS_SERVERS.\n",
            status ));
        status = DNS_ERROR_NO_DNS_SERVERS;
        pBlob->Status = status;
        pBlob->fCacheNegative = FALSE;
    }

    DNSDBG( TRACE, (
        "Leave Query_Main()\n"
        "\tstatus       = %d\n"
        "\ttime         = %d\n",
        status,
        Dns_GetCurrentTimeInSeconds()
        ));
    IF_DNSDBG( QUERY )
    {
        DnsDbg_QueryBlob(
            "Blob leaving Query_Main()",
            pBlob );
    }

    //
    //  DCR_HACK:  remove me
    //
    //  must return some records on success query
    //
    //  not sure this is true on referral -- if so it's because we flag
    //      as referral
    //

    ASSERT( status != ERROR_SUCCESS || pBlob->pRecords != NULL );

    return status;
}



DNS_STATUS
Query_InProcess(
    IN OUT  PQUERY_BLOB     pBlob
    )
/*++

Routine Description:

    Main direct in-process query routine.

Arguments:

    pBlob -- query info blob

Return Value:

    ERROR_SUCCESS if successful.
    DNS RCODE error for RCODE response.
    DNS_INFO_NO_RECORDS for no records response.
    ERROR_TIMEOUT on complete lookup failure.
    ErrorCode on local failure.

--*/
{
    DNS_STATUS          status = NO_ERROR;
    PDNS_NETINFO        pnetInfo;
    PDNS_NETINFO        pnetInfoLocal = NULL;
    PDNS_NETINFO        pnetInfoOriginal;
    DNS_STATUS          statusNetFailure = NO_ERROR;
    PDNS_ADDR_ARRAY     pservArray = NULL;
    PDNS_ADDR_ARRAY     pallocServArray = NULL;


    DNSDBG( TRACE, (
        "Query_InProcess( %p )\n",
        pBlob ));

    //
    //  get network info
    //

    pnetInfo = pnetInfoOriginal = pBlob->pNetInfo;

    //
    //  skip queries in "net down" situation
    //

    if ( IsKnownNetFailure() )
    {
        status = GetLastError();
        goto Cleanup;
    }

    //
    //  explicit DNS server list -- build into network info
    //      - requires info from current list for search list or PDN
    //      - then dump current list and use private version
    //
    //  DCR:  could functionalize -- netinfo, right from server lists
    //

    pservArray = pBlob->pServerList;

    if ( !pservArray )
    {
        pallocServArray = Util_GetAddrArray(
                            NULL,               // no copy issue
                            NULL,               // no addr array
                            pBlob->pServerList4,
                            NULL                // no extra info
                            );
        pservArray = pallocServArray;
    }

    if ( pservArray )
    {
        pnetInfo = NetInfo_CreateFromAddrArray(
                            pservArray,
                            0,          // no specific server
                            TRUE,       // build search info
                            pnetInfo    // use existing netinfo
                            );
        if ( !pnetInfo )
        {
            status = DNS_ERROR_NO_MEMORY;
            goto Cleanup;
        }
        pnetInfoLocal = pnetInfo;
    }

    //
    //  no network info -- get it
    //

    else if ( !pnetInfo )
    {
        pnetInfoLocal = pnetInfo = GetNetworkInfo();
        if ( ! pnetInfo )
        {
            status = DNS_ERROR_NO_DNS_SERVERS;
            goto Cleanup;
        }
    }

    //
    //  make actual query to DNS servers
    //
    //  note: at this point we MUST have network info
    //      and resolved any server list issues
    //      (including extracting imbedded extra info)
    //

    pBlob->pNetInfo     = pnetInfo;
    pBlob->pServerList  = NULL;
    pBlob->pServerList4 = NULL;

    pBlob->pfnQueryCache = HostsFile_Query;

    status = Query_Main( pBlob );

    //
    //  save net failure
    //      - but not if passed in network info
    //      only meaningful if its standard info
    //

    if ( pBlob->NetFailureStatus &&
         !pBlob->pServerList )
    {
        SetKnownNetFailure( status );
    }

    //
    //  cleanup
    //

Cleanup:

    DnsAddrArray_Free( pallocServArray );
    NetInfo_Free( pnetInfoLocal );
    pBlob->pNetInfo = pnetInfoOriginal;

    GUI_MODE_SETUP_WS_CLEANUP( g_InNTSetupMode );

    return status;
}



//
//  Query utilities
//

DNS_STATUS
GetDnsServerRRSet(
    OUT     PDNS_RECORD *   ppRecord,
    IN      BOOLEAN         fUnicode
    )
/*++

Routine Description:

    Create record list of None.

Arguments:

    None.

Return Value:

    None.

--*/
{
    PDNS_NETINFO    pnetInfo;
    PDNS_ADAPTER    padapter;
    DWORD           iter;
    PDNS_RECORD     prr;
    DNS_RRSET       rrSet;
    DNS_CHARSET     charSet = fUnicode ? DnsCharSetUnicode : DnsCharSetUtf8;


    DNSDBG( QUERY, (
        "GetDnsServerRRSet()\n" ));

    DNS_RRSET_INIT( rrSet );

    pnetInfo = GetNetworkInfo();
    if ( !pnetInfo )
    {
        goto Done;
    }

    //
    //  loop through all adapters build record for each DNS server
    //

    NetInfo_AdapterLoopStart( pnetInfo );

    while( padapter = NetInfo_GetNextAdapter( pnetInfo ) )
    {
        PDNS_ADDR_ARRAY pserverArray;
        PWSTR           pname;
        DWORD           jiter;

        pserverArray = padapter->pDnsAddrs;
        if ( !pserverArray )
        {
            continue;
        }

        //  DCR:  goofy way to expose aliases
        //
        //  if register the adapter's domain name, make it record name
        //  this
        //
        //  FIX6:  do we need to expose IP6 DNS servers this way?
        //

        pname = padapter->pszAdapterDomain;
        if ( !pname ||
             !( padapter->InfoFlags & AINFO_FLAG_REGISTER_DOMAIN_NAME ) )
        {
            pname = L".";
        }

        for ( jiter = 0; jiter < pserverArray->AddrCount; jiter++ )
        {
            prr = Dns_CreateForwardRecord(
                        (PDNS_NAME) pname,
                        DNS_TYPE_A,
                        & pserverArray->AddrArray[jiter],
                        0,                  //  no TTL
                        DnsCharSetUnicode,  //  name is unicode
                        charSet             //  result set
                        );
            if ( prr )
            {
                prr->Flags.S.Section = DNSREC_ANSWER;
                DNS_RRSET_ADD( rrSet, prr );
            }
        }
    }

Done:

    NetInfo_Free( pnetInfo );

    *ppRecord = prr = rrSet.pFirstRR;

    DNSDBG( QUERY, (
        "Leave  GetDnsServerRRSet() => %d\n",
        (prr ? ERROR_SUCCESS : DNS_ERROR_NO_DNS_SERVERS) ));

    return (prr ? ERROR_SUCCESS : DNS_ERROR_NO_DNS_SERVERS);
}



DNS_STATUS
Query_CheckIp6Literal(
    IN      PCWSTR          pwsName,
    IN      WORD            wType,
    OUT     PDNS_RECORD *   ppResultSet
    )
/*++

Routine Description:

    Check for\handle UPNP literal hack.

Arguments:

Return Value:

    NO_ERROR if not literal.
    DNS_ERROR_RCODE_NAME_ERROR if literal but bad type.
    DNS_INFO_NUMERIC_NAME if good data -- convert this to NO_ERROR
        for response.
    ErrorCode if have literal, but can't build record.

--*/
{
    SOCKADDR_IN6    sockAddr;
    DNS_STATUS      status;

    DNSDBG( QUERY, (
        "Query_CheckIp6Literal( %S, %d )\n",
        pwsName,
        wType ));

    //
    //  check for literal
    //

    if ( ! Dns_Ip6LiteralNameToAddress(
                & sockAddr,
                pwsName ) )
    {
        return NO_ERROR;
    }

    //
    //  if found literal, but not AAAA query -- done
    //

    if ( wType != DNS_TYPE_AAAA )
    {
        status = DNS_ERROR_RCODE_NAME_ERROR;
        goto Done;
    }

    //
    //  build AAAA record
    //

    status = DNS_ERROR_NUMERIC_NAME;

    if ( ppResultSet )
    {
        PDNS_RECORD prr;

        prr = Dns_CreateAAAARecord(
                    (PDNS_NAME) pwsName,
                    * (PIP6_ADDRESS) &sockAddr.sin6_addr,
                    IPSTRING_RECORD_TTL,
                    DnsCharSetUnicode,
                    DnsCharSetUnicode );
        if ( !prr )
        {
            status = DNS_ERROR_NO_MEMORY;
        }
        *ppResultSet = prr;
    }

Done:

    DNSDBG( QUERY, (
        "Leave  Query_CheckIp6Literal( %S, %d ) => %d\n",
        pwsName,
        wType,
        status ));

    return  status;
}



//
//  DNS Query API
//

DNS_STATUS
WINAPI
Query_PrivateExW(
    IN      PCWSTR          pwsName,
    IN      WORD            wType,
    IN      DWORD           Options,
    IN      PADDR_ARRAY     pServerList         OPTIONAL,
    IN      PIP4_ARRAY      pServerList4        OPTIONAL,
    OUT     PDNS_RECORD *   ppResultSet         OPTIONAL,
    IN OUT  PDNS_MSG_BUF *  ppMessageResponse   OPTIONAL
    )
/*++

Routine Description:

    Private query interface.

    This working code for the DnsQuery() public API

Arguments:

    pszName -- name to query

    wType -- type of query

    Options -- flags to query

    pServersIp6 -- array of DNS servers to use in query

    ppResultSet -- addr to receive result DNS records

    ppMessageResponse -- addr to receive resulting message

Return Value:

    ERROR_SUCCESS on success.
    DNS RCODE error on query with RCODE
    DNS_INFO_NO_RECORDS on no records response.
    ErrorCode on failure.

--*/
{
    DNS_STATUS          status = NO_ERROR;
    PDNS_NETINFO        pnetInfo = NULL;
    PDNS_RECORD         prpcRecord = NULL;
    DWORD               rpcStatus = NO_ERROR;
    PQUERY_BLOB         pblob;
    PWSTR               pnameLocal = NULL;
    BOOL                femptyName = FALSE;


    DNSDBG( TRACE, (
        "\n\nQuery_PrivateExW()\n"
        "\tName         = %S\n"
        "\twType        = %d\n"
        "\tOptions      = %08x\n"
        "\tpServerList  = %p\n"
        "\tpServerList4 = %p\n"
        "\tppMessage    = %p\n",
        pwsName,
        wType,
        Options,
        pServerList,
        pServerList4,
        ppMessageResponse ));


    //  clear OUT params

    if ( ppResultSet )
    {
        *ppResultSet = NULL;
    }

    if ( ppMessageResponse )
    {
        *ppMessageResponse = NULL;
    }

    //
    //  must ask for some kind of results
    //

    if ( !ppResultSet && !ppMessageResponse )
    {
        return ERROR_INVALID_PARAMETER;
    }

    //
    //  map WIRE_ONLY flag
    //

    if ( Options & DNS_QUERY_WIRE_ONLY )
    {
        Options |= DNS_QUERY_BYPASS_CACHE;
        Options |= DNS_QUERY_NO_HOSTS_FILE;
        Options |= DNS_QUERY_NO_LOCAL_NAME;
    }

    //
    //  NULL name indicates localhost lookup
    //
    //  DCR:  NULL name lookup for localhost could be improved
    //      - support NULL all the way through to wire
    //      - have local IP routines just accept it
    //

    //
    //  empty string name
    //
    //  empty type A query get DNS servers
    //
    //  DCR_CLEANUP:  DnsQuery empty name query for DNS servers?
    //      need better\safer approach to this
    //      is this SDK doc'd?  (hope not!)
    //

    if ( pwsName )
    {
        femptyName = !wcscmp( pwsName, L"" );

        if ( !(Options & DNSQUERY_NO_SERVER_RECORDS) &&
             ( femptyName ||
               !wcscmp( pwsName, DNS_SERVER_QUERY_NAME ) ) &&
             wType == DNS_TYPE_A &&
             !ppMessageResponse &&
             ppResultSet )
        {
            status = GetDnsServerRRSet(
                        ppResultSet,
                        TRUE    // unicode
                        );
            goto Done;
        }
    }

    //
    //  NULL or empty treated as local host
    //

    if ( !pwsName || femptyName )
    {
        pnameLocal = (PWSTR) Reg_GetHostName( DnsCharSetUnicode );
        if ( !pnameLocal )
        {
            return  DNS_ERROR_NAME_NOT_FOUND_LOCALLY;
        }
        pwsName = (PCWSTR) pnameLocal;
        Options |= DNS_QUERY_CACHE_ONLY;
        goto SkipLiterals;
    }

    //
    //  IP string queries
    //
    
    if ( ppResultSet )
    {
        PDNS_RECORD prr;
    
        prr = Dns_CreateRecordForIpString_W(
                    pwsName,
                    wType,
                    IPSTRING_RECORD_TTL );
        if ( prr )
        {
            *ppResultSet = prr;
            status = ERROR_SUCCESS;
            goto Done;
        }
    }
    
    //
    //  UPNP IP6 literal hack
    //
    
    status = Query_CheckIp6Literal(
                pwsName,
                wType,
                ppResultSet );
    
    if ( status != NO_ERROR )
    {
        if ( status == DNS_ERROR_NUMERIC_NAME )
        {
            DNS_ASSERT( wType == DNS_TYPE_AAAA );
            DNS_ASSERT( !ppResultSet || *ppResultSet );
            status = NO_ERROR;
        }
        goto Done;
    }

SkipLiterals:

    //
    //  cluster filtering?
    //

    if ( g_IsServer &&
         (Options & DNSP_QUERY_INCLUDE_CLUSTER) )
    {
        ENVAR_DWORD_INFO    filterInfo;

        Reg_ReadDwordEnvar(
           RegIdFilterClusterIp,
           &filterInfo );

        if ( filterInfo.fFound && filterInfo.Value )
        {
            Options &= ~DNSP_QUERY_INCLUDE_CLUSTER;
        }
    }

    //
    //  BYPASS_CACHE
    //      - required if want message buffer or specify server
    //          list -- just set flag
    //      - incompatible with CACHE_ONLY
    //      - required to get EMPTY_AUTH_RESPONSE
    //

    if ( ppMessageResponse  ||
         pServerList        ||
         pServerList4       ||
         (Options & DNS_QUERY_ALLOW_EMPTY_AUTH_RESP) )
    {
        Options |= DNS_QUERY_BYPASS_CACHE;
        //Options |= DNS_QUERY_NO_CACHE_DATA;
    }

    //
    //  do direct query?
    //      - not RPC-able type
    //      - want message buffer
    //      - specifying DNS servers
    //      - want EMPTY_AUTH response records
    //
    //  DCR:  currently by-passing for type==ALL
    //      this may be too common to do that;   may want to
    //      go to cache then determine if security records
    //      or other stuff require us to query in process
    //
    //  DCR:  not clear what the EMPTY_AUTH benefit is
    //
    //  DCR:  currently BYPASSing whenever BYPASS is set
    //      because otherwise we miss the hosts file
    //      if fix so lookup in cache, but screen off non-hosts
    //      data, then could resume going to cache
    //

    if ( !Dns_IsRpcRecordType(wType) &&
         !(Options & DNS_QUERY_CACHE_ONLY) )
    {
        goto  InProcessQuery;
    }

    if ( Options & DNS_QUERY_BYPASS_CACHE )
#if 0
    if ( (Options & DNS_QUERY_BYPASS_CACHE) &&
         ( ppMessageResponse ||
           pServerList ||
           (Options & DNS_QUERY_ALLOW_EMPTY_AUTH_RESP) ) )
#endif
    {
        if ( Options & DNS_QUERY_CACHE_ONLY )
        {
            status = ERROR_INVALID_PARAMETER;
            goto Done;
        }
        goto  InProcessQuery;
    }


    //
    //  querying through cache
    //

    rpcStatus = NO_ERROR;

    RpcTryExcept
    {
        status = R_ResolverQuery(
                    NULL,
                    (PWSTR) pwsName,
                    wType,
                    Options,
                    &prpcRecord );
        
    }
    RpcExcept( DNS_RPC_EXCEPTION_FILTER )
    {
        rpcStatus = RpcExceptionCode();
    }
    RpcEndExcept

    //
    //  cache unavailable
    //      - bail if just querying cache
    //      - otherwise query direct

    if ( rpcStatus != NO_ERROR )
    {
        DNSDBG( TRACE, (
            "Query_PrivateExW()  RPC failed status = %d\n",
            rpcStatus ));
        goto InProcessQuery;
    }
    if ( status == DNS_ERROR_NO_TCPIP )
    {
        DNSDBG( TRACE, (
            "Query_PrivateExW()  NO_TCPIP error!\n"
            "\tassume resolver security problem -- query in process!\n"
            ));
        RTL_ASSERT( !prpcRecord );
        goto InProcessQuery;
    }

    //
    //  return records
    //      - screen out empty-auth responses
    //
    //  DCR_FIX1:  cache should convert and return NO_RECORDS response
    //      directly (no need to do this here)
    //
    //  DCR:  UNLESS we allow return of these records
    //

    if ( prpcRecord )
    {
        FixupNameOwnerPointers( prpcRecord );

        if ( IsEmptyDnsResponseFromResolver( prpcRecord ) )
        {
            Dns_RecordListFree( prpcRecord );
            prpcRecord = NULL;
            if ( status == NO_ERROR )
            {
                status = DNS_INFO_NO_RECORDS;
            }
        }
        *ppResultSet = prpcRecord;
    }
    RTL_ASSERT( status!=NO_ERROR || prpcRecord );
    goto Done;

    //
    //  query directly -- either skipping cache or it's unavailable
    //

InProcessQuery:

    DNSDBG( TRACE, (
        "Query_PrivateExW()  -- doing in process query\n"
        "\tpname = %S\n"
        "\ttype  = %d\n",
        pwsName,
        wType ));

    //
    //  load query blob
    //
    //  DCR:  set some sort of "want message buffer" flag if ppMessageResponse
    //          exists
    //

    pblob = ALLOCATE_HEAP_ZERO( sizeof(*pblob) );
    if ( !pblob )
    {
        status = DNS_ERROR_NO_MEMORY;
        goto Done;
    }

    pblob->pNameOrig    = (PWSTR) pwsName;
    pblob->wType        = wType;
    //pblob->Flags        = Options | DNSQUERY_UNICODE_OUT;
    pblob->Flags        = Options;
    pblob->pServerList  = pServerList;
    pblob->pServerList4 = pServerList4;

    //  
    //  query
    //      - then set OUT params

    status = Query_InProcess( pblob );

    if ( ppResultSet )
    {
        *ppResultSet = pblob->pRecords;
        RTL_ASSERT( status!=NO_ERROR || *ppResultSet );
    }
    else
    {
        Dns_RecordListFree( pblob->pRecords );
    }

    if ( ppMessageResponse )
    {
        *ppMessageResponse = pblob->pRecvMsg;
    }

    FREE_HEAP( pblob );

Done:

    //  sanity check

    if ( status==NO_ERROR &&
         ppResultSet &&
         !*ppResultSet )
    {
        RTL_ASSERT( FALSE );
        status = DNS_INFO_NO_RECORDS;
    }

    if ( pnameLocal )
    {
        FREE_HEAP( pnameLocal );
    }

    DNSDBG( TRACE, (
        "Leave Query_PrivateExW()\n"
        "\tstatus       = %d\n"
        "\tresult set   = %p\n\n\n",
        status,
        *ppResultSet ));

    return( status );
}




DNS_STATUS
WINAPI
Query_Shim(
    IN      DNS_CHARSET     CharSet,
    IN      PCSTR           pszName,
    IN      WORD            wType,
    IN      DWORD           Options,
    IN      PDNS_ADDR_ARRAY pServList           OPTIONAL,
    IN      PIP4_ARRAY      pServList4          OPTIONAL,
    OUT     PDNS_RECORD *   ppResultSet         OPTIONAL,
    IN OUT  PDNS_MSG_BUF *  ppMessageResponse   OPTIONAL
    )
/*++

Routine Description:

    Convert narrow to wide query.

    This routine handles narron-to-wide conversions to calling
    into Query_PrivateExW() which does the real work.

Arguments:

    CharSet -- char set of original query

    pszName -- name to query

    wType -- type of query

    Options -- flags to query

    pServList -- array of DNS servers to use in query

    pServList4 -- array of DNS servers to use in query

    ppResultSet -- addr to receive result DNS records

    ppMessageResponse -- addr to receive response message

Return Value:

    ERROR_SUCCESS on success.
    DNS RCODE error on query with RCODE
    DNS_INFO_NO_RECORDS on no records response.
    ErrorCode on failure.

--*/
{
    DNS_STATUS      status = NO_ERROR;
    PDNS_RECORD     prrList = NULL;
    PWSTR           pwideName = NULL;
    WORD            nameLength;

    if ( !pszName )
    {
        return ERROR_INVALID_PARAMETER;
    }

    //
    //  name conversion
    //

    if ( CharSet == DnsCharSetUnicode )
    {
        pwideName = (PWSTR) pszName;
    }
    else
    {
        nameLength = (WORD) strlen( pszName );
    
        pwideName = ALLOCATE_HEAP( (nameLength + 1) * sizeof(WCHAR) );
        if ( !pwideName )
        {
            return DNS_ERROR_NO_MEMORY;
        }
    
        if ( !Dns_NameCopy(
                    (PSTR) pwideName,
                    NULL,
                    (PSTR) pszName,
                    nameLength,
                    CharSet,
                    DnsCharSetUnicode ) )
        {
            status = ERROR_INVALID_NAME;
            goto Done;
        }
    }

    status = Query_PrivateExW(
                    pwideName,
                    wType,
                    Options,
                    pServList,
                    pServList4,
                    ppResultSet ? &prrList : NULL,
                    ppMessageResponse
                    );

    //
    //  convert result records back to ANSI (or UTF8)
    //

    if ( ppResultSet && prrList )
    {
        if ( CharSet == DnsCharSetUnicode )
        {
            *ppResultSet = prrList;
        }
        else
        {
            *ppResultSet = Dns_RecordSetCopyEx(
                                    prrList,
                                    DnsCharSetUnicode,
                                    CharSet
                                    );
            if ( ! *ppResultSet )
            {
                status = DNS_ERROR_NO_MEMORY;
            }
            Dns_RecordListFree( prrList );
        }
    }

    //
    //  cleanup
    //

Done:

    if ( pwideName != (PWSTR)pszName )
    {
        FREE_HEAP( pwideName );
    }

    return status;
}



DNS_STATUS
WINAPI
Query_Private(
    IN      PCWSTR          pszName,
    IN      WORD            wType,
    IN      DWORD           Options,
    IN      PADDR_ARRAY     pServerList,        OPTIONAL
    OUT     PDNS_RECORD *   ppResultSet         OPTIONAL
    )
/*++

Routine Description:

    Dnsapi internal query routine for update\FAZ routines.

    Thin wrapper on Query_Shim.

--*/
{
    return  Query_Shim(
                DnsCharSetUnicode,
                (PCHAR) pszName,
                wType,
                Options,
                pServerList,
                NULL,       // no IP4 list
                ppResultSet,
                NULL        // no message
                );
}



//
//  SDK query API
//

DNS_STATUS
WINAPI
DnsQuery_UTF8(
    IN      PCSTR           pszName,
    IN      WORD            wType,
    IN      DWORD           Options,
    IN      PIP4_ARRAY      pDnsServers         OPTIONAL,
    OUT     PDNS_RECORD *   ppResultSet         OPTIONAL,
    IN OUT  PDNS_MSG_BUF *  ppMessageResponse   OPTIONAL
    )
/*++

Routine Description:

    Public UTF8 query.

Arguments:

    pszName -- name to query

    wType -- type of query

    Options -- flags to query

    pDnsServers -- array of DNS servers to use in query

    ppResultSet -- addr to receive result DNS records

    ppMessageResponse -- addr to receive response message

Return Value:

    ERROR_SUCCESS on success.
    DNS RCODE error on query with RCODE
    DNS_INFO_NO_RECORDS on no records response.
    ErrorCode on failure.

--*/
{
    return  Query_Shim(
                DnsCharSetUtf8,
                pszName,
                wType,
                Options,
                NULL,       // no non-IP4 server list support
                pDnsServers,
                ppResultSet,
                ppMessageResponse
                );
}



DNS_STATUS
WINAPI
DnsQuery_A(
    IN      PCSTR           pszName,
    IN      WORD            wType,
    IN      DWORD           Options,
    IN      PIP4_ARRAY      pDnsServers         OPTIONAL,
    OUT     PDNS_RECORD *   ppResultSet         OPTIONAL,
    IN OUT  PDNS_MSG_BUF *  ppMessageResponse   OPTIONAL
    )
/*++

Routine Description:

    Public ANSI query.

Arguments:

    pszName -- name to query

    wType -- type of query

    Options -- flags to query

    pDnsServers -- array of DNS servers to use in query

    ppResultSet -- addr to receive result DNS records

    ppMessageResponse -- addr to receive resulting message

Return Value:

    ERROR_SUCCESS on success.
    DNS RCODE error on query with RCODE
    DNS_INFO_NO_RECORDS on no records response.
    ErrorCode on failure.

--*/
{
    return  Query_Shim(
                DnsCharSetAnsi,
                pszName,
                wType,
                Options,
                NULL,       // no non-IP4 server list support
                pDnsServers,
                ppResultSet,
                ppMessageResponse
                );
}



DNS_STATUS
WINAPI
DnsQuery_W(
    IN      PCWSTR          pwsName,
    IN      WORD            wType,
    IN      DWORD           Options,
    IN      PIP4_ARRAY      pDnsServers         OPTIONAL,
    IN OUT  PDNS_RECORD *   ppResultSet         OPTIONAL,
    IN OUT  PDNS_MSG_BUF *  ppMessageResponse   OPTIONAL
    )
/*++

Routine Description:

    Public unicode query API

    Note, this unicode version is the main routine.
    The other public API call back through it.

Arguments:

    pszName -- name to query

    wType -- type of query

    Options -- flags to query

    pDnsServers -- array of DNS servers to use in query

    ppResultSet -- addr to receive result DNS records

    ppMessageResponse -- addr to receive resulting message

Return Value:

    ERROR_SUCCESS on success.
    DNS RCODE error on query with RCODE
    DNS_INFO_NO_RECORDS on no records response.
    ErrorCode on failure.

--*/
{
    return  Query_PrivateExW(
                pwsName,
                wType,
                Options,
                NULL,       // no non-IP4 server list support
                pDnsServers,
                ppResultSet,
                ppMessageResponse
                );
}



//
//  DnsQueryEx()  routines
//

DNS_STATUS
WINAPI
ShimDnsQueryEx(
    IN OUT  PDNS_QUERY_INFO pQueryInfo
    )
/*++

Routine Description:

    Query DNS -- shim for main SDK query routine.

Arguments:

    pQueryInfo -- blob describing query

Return Value:

    ERROR_SUCCESS if successful query.
    Error code on failure.

--*/
{
    PDNS_RECORD prrResult = NULL;
    WORD        type = pQueryInfo->Type;
    DNS_STATUS  status;
    DNS_LIST    listAnswer;
    DNS_LIST    listAlias;
    DNS_LIST    listAdditional;
    DNS_LIST    listAuthority;

    DNSDBG( TRACE, ( "ShimDnsQueryEx()\n" ));

    //
    //  DCR:  temp hack -- pass to private query routine
    //

    status = Query_PrivateExW(
                (PWSTR) pQueryInfo->pName,
                type,
                pQueryInfo->Flags,
                pQueryInfo->pServerList,
                pQueryInfo->pServerListIp4,
                & prrResult,
                NULL );

    pQueryInfo->Status = status;

    //
    //  cut result records appropriately
    //

    pQueryInfo->pAnswerRecords      = NULL;
    pQueryInfo->pAliasRecords       = NULL;
    pQueryInfo->pAdditionalRecords  = NULL;
    pQueryInfo->pAuthorityRecords   = NULL;

    if ( prrResult )
    {
        PDNS_RECORD     prr;
        PDNS_RECORD     pnextRR;

        DNS_LIST_STRUCT_INIT( listAnswer );
        DNS_LIST_STRUCT_INIT( listAlias );
        DNS_LIST_STRUCT_INIT( listAdditional );
        DNS_LIST_STRUCT_INIT( listAuthority );

        //
        //  break list into section specific lists
        //      - section 0 for hostfile records
        //      - note, this does pull RR sets apart, but
        //      they, being in same section, should immediately
        //      be rejoined
        //

        pnextRR = prrResult;
        
        while ( prr = pnextRR )
        {
            pnextRR = prr->pNext;
            prr->pNext = NULL;
        
            if ( prr->Flags.S.Section == 0 ||
                 prr->Flags.S.Section == DNSREC_ANSWER )
            {
                if ( prr->wType == DNS_TYPE_CNAME &&
                     type != DNS_TYPE_CNAME )
                {
                    DNS_LIST_STRUCT_ADD( listAlias, prr );
                    continue;
                }
                else
                {
                    DNS_LIST_STRUCT_ADD( listAnswer, prr );
                    continue;
                }
            }
            else if ( prr->Flags.S.Section == DNSREC_ADDITIONAL )
            {
                DNS_LIST_STRUCT_ADD( listAdditional, prr );
                continue;
            }
            else
            {
                DNS_LIST_STRUCT_ADD( listAuthority, prr );
                continue;
            }
        }

        //  pack stuff back into blob

        pQueryInfo->pAnswerRecords      = listAnswer.pFirst;
        pQueryInfo->pAliasRecords       = listAlias.pFirst;
        pQueryInfo->pAuthorityRecords   = listAuthority.pFirst;
        pQueryInfo->pAdditionalRecords  = listAdditional.pFirst;
        //pQueryInfo->pSigRecords         = listSig.pFirst;

        //
        //  convert result records back to ANSI (or UTF8)
        //      - convert each result set
        //      - then paste back into query blob
        //
        //  DCR_FIX0:  handle issue of failure on conversion
        //

        if ( pQueryInfo->CharSet != DnsCharSetUnicode )
        {
            PDNS_RECORD *   prrSetPtr;

            prrSetPtr = & pQueryInfo->pAnswerRecords;
        
            for ( prrSetPtr = & pQueryInfo->pAnswerRecords;
                  prrSetPtr <= & pQueryInfo->pAdditionalRecords;
                  prrSetPtr++ )
            {
                prr = *prrSetPtr;
        
                *prrSetPtr = Dns_RecordSetCopyEx(
                                    prr,
                                    DnsCharSetUnicode,
                                    pQueryInfo->CharSet
                                    );
        
                Dns_RecordListFree( prr );
            }
        }
    }

    //
    //  replace name for originally narrow queries
    //

    if ( pQueryInfo->CharSet != DnsCharSetUnicode )
    {
        ASSERT( pQueryInfo->CharSet != 0 );
        ASSERT( pQueryInfo->pReservedName != NULL );

        FREE_HEAP( pQueryInfo->pName );
        pQueryInfo->pName = (LPTSTR) pQueryInfo->pReservedName;
        pQueryInfo->pReservedName = NULL;
    }

    //
    //  indicate return if async
    //

    if ( pQueryInfo->hEvent )
    {
        SetEvent( pQueryInfo->hEvent );
    }

    return( status );
}



DNS_STATUS
WINAPI
CombinedQueryEx(
    IN OUT  PDNS_QUERY_INFO pQueryInfo,
    IN      DNS_CHARSET     CharSet
    )
/*++

Routine Description:

    Convert narrow to wide query.

    This routine simple avoids duplicate code in ANSI
    and UTF8 query routines.

Arguments:

    pQueryInfo -- query info blob

    CharSet -- char set of original query

Return Value:

    ERROR_SUCCESS on success.
    DNS RCODE error on query with RCODE
    DNS_INFO_NO_RECORDS on no records response.
    ErrorCode on failure.

--*/
{
    DNS_STATUS      status = NO_ERROR;
    PWSTR           pwideName = NULL;
    HANDLE          hthread;
    DWORD           threadId;

    DNSDBG( TRACE, (
        "CombinedQueryEx( %S%s, type=%d, flag=%08x, event=%p )\n",
        PRINT_STRING_WIDE_CHARSET( pQueryInfo->pName, CharSet ),
        PRINT_STRING_ANSI_CHARSET( pQueryInfo->pName, CharSet ),
        pQueryInfo->Type,
        pQueryInfo->Flags,
        pQueryInfo->hEvent ));

    //
    //  set CharSet
    //

    pQueryInfo->CharSet = CharSet;

    if ( CharSet == DnsCharSetUnicode )
    {
        pQueryInfo->pReservedName = 0;
    }

    //
    //  if narrow name
    //      - allocate wide name copy
    //      - swap in wide name and make query wide
    //
    //  DCR:  allow NULL name?  for local machine name?
    //

    else if ( CharSet == DnsCharSetAnsi ||
              CharSet == DnsCharSetUtf8 )
    {
        WORD    nameLength;
        PSTR    pnameNarrow;

        pnameNarrow = (PSTR) pQueryInfo->pName;
        if ( !pnameNarrow )
        {
            return ERROR_INVALID_PARAMETER;
        }
    
        nameLength = (WORD) strlen( pnameNarrow );
    
        pwideName = ALLOCATE_HEAP( (nameLength + 1) * sizeof(WCHAR) );
        if ( !pwideName )
        {
            return DNS_ERROR_NO_MEMORY;
        }
    
        if ( !Dns_NameCopy(
                    (PSTR) pwideName,
                    NULL,
                    pnameNarrow,
                    nameLength,
                    CharSet,
                    DnsCharSetUnicode ) )
        {
            status = ERROR_INVALID_NAME;
            goto Failed;
        }

        pQueryInfo->pName = (LPTSTR) pwideName;
        pQueryInfo->pReservedName = pnameNarrow;
    }

    //
    //  async?
    //      - if event exists we are async
    //      - spin up thread and call it
    //

    if ( pQueryInfo->hEvent )
    {
        hthread = CreateThread(
                        NULL,           // no security
                        0,              // default stack
                        ShimDnsQueryEx,
                        pQueryInfo,     // param
                        0,              // run immediately
                        & threadId
                        );
        if ( !hthread )
        {
            status = GetLastError();

            DNSDBG( ANY, (
                "Failed to create thread = %d\n",
                status ));

            if ( status == ERROR_SUCCESS )
            {
                status = DNS_ERROR_NO_MEMORY;
            }
            goto Failed;
        }

        CloseHandle( hthread );
        return( ERROR_IO_PENDING );
    }

    //      
    //  otherwise make direct async call
    //

    return   ShimDnsQueryEx( pQueryInfo );


Failed:

    FREE_HEAP( pwideName );
    return( status );
}



DNS_STATUS
WINAPI
DnsQueryExW(
    IN OUT  PDNS_QUERY_INFO pQueryInfo
    )
/*++

Routine Description:

    Query DNS -- main SDK query routine.

Arguments:

    pQueryInfo -- blob describing query

Return Value:

    ERROR_SUCCESS if successful query.
    ERROR_IO_PENDING if successful async start.
    Error code on failure.

--*/
{
    DNSDBG( TRACE, (
        "DnsQueryExW( %S, type=%d, flag=%08x, event=%p )\n",
        pQueryInfo->pName,
        pQueryInfo->Type,
        pQueryInfo->Flags,
        pQueryInfo->hEvent ));

    return  CombinedQueryEx( pQueryInfo, DnsCharSetUnicode );
}



DNS_STATUS
WINAPI
DnsQueryExA(
    IN OUT  PDNS_QUERY_INFO pQueryInfo
    )
/*++

Routine Description:

    Query DNS -- main SDK query routine.

Arguments:

    pQueryInfo -- blob describing query

Return Value:

    ERROR_SUCCESS if successful query.
    ERROR_IO_PENDING if successful async start.
    Error code on failure.

--*/
{
    DNSDBG( TRACE, (
        "DnsQueryExA( %s, type=%d, flag=%08x, event=%p )\n",
        pQueryInfo->pName,
        pQueryInfo->Type,
        pQueryInfo->Flags,
        pQueryInfo->hEvent ));

    return  CombinedQueryEx( pQueryInfo, DnsCharSetAnsi );
}



DNS_STATUS
WINAPI
DnsQueryExUTF8(
    IN OUT  PDNS_QUERY_INFO pQueryInfo
    )
/*++

Routine Description:

    Query DNS -- main SDK query routine.

Arguments:

    pQueryInfo -- blob describing query

Return Value:

    ERROR_SUCCESS if successful query.
    ERROR_IO_PENDING if successful async start.
    Error code on failure.

--*/
{
    DNSDBG( TRACE, (
        "DnsQueryExUTF8( %s, type=%d, flag=%08x, event=%p )\n",
        pQueryInfo->pName,
        pQueryInfo->Type,
        pQueryInfo->Flags,
        pQueryInfo->hEvent ));

    return  CombinedQueryEx( pQueryInfo, DnsCharSetUtf8 );
}



//
//  Roll your own query utilities
//

BOOL
WINAPI
DnsWriteQuestionToBuffer_W(
    IN OUT  PDNS_MESSAGE_BUFFER pDnsBuffer,
    IN OUT  LPDWORD             pdwBufferSize,
    IN      PWSTR               pszName,
    IN      WORD                wType,
    IN      WORD                Xid,
    IN      BOOL                fRecursionDesired
    )
/*++

Routine Description:

    None.

Arguments:

    None.

Return Value:

    None.

--*/
{
    //
    //  DCR_CLEANUP:  duplicate code with routine below ... surprise!
    //      - eliminate duplicate
    //      - probably can just pick up library routine
    //

    PCHAR pch;
    PCHAR pbufferEnd = NULL;

    if ( *pdwBufferSize >= DNS_MAX_UDP_PACKET_BUFFER_LENGTH )
    {
        pbufferEnd = (PCHAR)pDnsBuffer + *pdwBufferSize;

        //  clear header

        RtlZeroMemory( pDnsBuffer, sizeof(DNS_HEADER) );

        //  set for rewriting

        pch = pDnsBuffer->MessageBody;

        //  write question name

        pch = Dns_WriteDottedNameToPacket(
                    pch,
                    pbufferEnd,
                    (PCHAR) pszName,
                    NULL,
                    0,
                    TRUE );

        if ( !pch )
        {
            return FALSE;
        }

        //  write question structure

        *(UNALIGNED WORD *) pch = htons( wType );
        pch += sizeof(WORD);
        *(UNALIGNED WORD *) pch = DNS_RCLASS_INTERNET;
        pch += sizeof(WORD);

        //  set question RR section count

        pDnsBuffer->MessageHead.QuestionCount = htons( 1 );
        pDnsBuffer->MessageHead.RecursionDesired = (BOOLEAN)fRecursionDesired;
        pDnsBuffer->MessageHead.Xid = htons( Xid );

        *pdwBufferSize = (DWORD)(pch - (PCHAR)pDnsBuffer);

        return TRUE;
    }
    else
    {
        *pdwBufferSize = DNS_MAX_UDP_PACKET_BUFFER_LENGTH;
        return FALSE;
    }
}



BOOL
WINAPI
DnsWriteQuestionToBuffer_UTF8(
    IN OUT  PDNS_MESSAGE_BUFFER pDnsBuffer,
    IN OUT  PDWORD              pdwBufferSize,
    IN      PSTR                pszName,
    IN      WORD                wType,
    IN      WORD                Xid,
    IN      BOOL                fRecursionDesired
    )
/*++

Routine Description:

    None.

Arguments:

    None.

Return Value:

    None.

--*/
{
    PCHAR pch;
    PCHAR pbufferEnd = NULL;

    if ( *pdwBufferSize >= DNS_MAX_UDP_PACKET_BUFFER_LENGTH )
    {
        pbufferEnd = (PCHAR)pDnsBuffer + *pdwBufferSize;

        //  clear header

        RtlZeroMemory( pDnsBuffer, sizeof(DNS_HEADER) );

        //  set for rewriting

        pch = pDnsBuffer->MessageBody;

        //  write question name

        pch = Dns_WriteDottedNameToPacket(
                    pch,
                    pbufferEnd,
                    pszName,
                    NULL,
                    0,
                    FALSE );

        if ( !pch )
        {
            return FALSE;
        }

        //  write question structure

        *(UNALIGNED WORD *) pch = htons( wType );
        pch += sizeof(WORD);
        *(UNALIGNED WORD *) pch = DNS_RCLASS_INTERNET;
        pch += sizeof(WORD);

        //  set question RR section count

        pDnsBuffer->MessageHead.QuestionCount = htons( 1 );
        pDnsBuffer->MessageHead.RecursionDesired = (BOOLEAN)fRecursionDesired;
        pDnsBuffer->MessageHead.Xid = htons( Xid );

        *pdwBufferSize = (DWORD)(pch - (PCHAR)pDnsBuffer);

        return TRUE;
    }
    else
    {
        *pdwBufferSize = DNS_MAX_UDP_PACKET_BUFFER_LENGTH;
        return FALSE;
    }
}



//
//  Record list to\from results
//

VOID
CombineRecordsInBlob(
    IN      PDNS_RESULTS    pResults,
    OUT     PDNS_RECORD *   ppRecords
    )
/*++

Routine Description:

    Query DNS -- shim for main SDK query routine.

Arguments:

    pQueryInfo -- blob describing query

Return Value:

    ERROR_SUCCESS if successful query.
    Error code on failure.

--*/
{
    PDNS_RECORD prr;

    DNSDBG( TRACE, ( "CombineRecordsInBlob()\n" ));

    //
    //  combine records back into one list
    //
    //  note, working backwards so only touch records once
    //

    prr = Dns_RecordListAppend(
            pResults->pAuthorityRecords,
            pResults->pAdditionalRecords
            );

    prr = Dns_RecordListAppend(
            pResults->pAnswerRecords,
            prr
            );

    prr = Dns_RecordListAppend(
            pResults->pAliasRecords,
            prr
            );

    *ppRecords = prr;
}



VOID
BreakRecordsIntoBlob(
    OUT     PDNS_RESULTS    pResults,
    IN      PDNS_RECORD     pRecords,
    IN      WORD            wType
    )
/*++

Routine Description:

    Break single record list into results blob.

Arguments:

    pResults -- results to fill in

    pRecords -- record list

Return Value:

    None

--*/
{
    PDNS_RECORD     prr;
    PDNS_RECORD     pnextRR;
    DNS_LIST        listAnswer;
    DNS_LIST        listAlias;
    DNS_LIST        listAdditional;
    DNS_LIST        listAuthority;

    DNSDBG( TRACE, ( "BreakRecordsIntoBlob()\n" ));

    //
    //  clear blob
    //

    RtlZeroMemory(
        pResults,
        sizeof(*pResults) );

    //
    //  init building lists
    //

    DNS_LIST_STRUCT_INIT( listAnswer );
    DNS_LIST_STRUCT_INIT( listAlias );
    DNS_LIST_STRUCT_INIT( listAdditional );
    DNS_LIST_STRUCT_INIT( listAuthority );

    //
    //  break list into section specific lists
    //      - note, this does pull RR sets apart, but
    //      they, being in same section, should immediately
    //      be rejoined
    //
    //      - note, hostfile records made have section=0
    //      this is no longer the case but preserve until
    //      know this is solid and determine what section==0
    //      means
    //

    pnextRR = pRecords;
    
    while ( prr = pnextRR )
    {
        pnextRR = prr->pNext;
        prr->pNext = NULL;
    
        if ( prr->Flags.S.Section == 0 ||
             prr->Flags.S.Section == DNSREC_ANSWER )
        {
            if ( prr->wType == DNS_TYPE_CNAME &&
                 wType != DNS_TYPE_CNAME )
            {
                DNS_LIST_STRUCT_ADD( listAlias, prr );
                continue;
            }
            else
            {
                DNS_LIST_STRUCT_ADD( listAnswer, prr );
                continue;
            }
        }
        else if ( prr->Flags.S.Section == DNSREC_ADDITIONAL )
        {
            DNS_LIST_STRUCT_ADD( listAdditional, prr );
            continue;
        }
        else
        {
            DNS_LIST_STRUCT_ADD( listAuthority, prr );
            continue;
        }
    }

    //  pack stuff into blob

    pResults->pAnswerRecords      = listAnswer.pFirst;
    pResults->pAliasRecords       = listAlias.pFirst;
    pResults->pAuthorityRecords   = listAuthority.pFirst;
    pResults->pAdditionalRecords  = listAdditional.pFirst;
}



//
//  Name collision API
//
//  DCR_QUESTION:  name collision -- is there any point to this?
//  DCR:   eliminate NameCollision_UTF8()
//

DNS_STATUS
WINAPI
DnsCheckNameCollision_W(
    IN      PCWSTR          pszName,
    IN      DWORD           Options
    )
/*++

Routine Description:

    None.

    DCR:  Check name collision IP4 only

Arguments:

    None.

Return Value:

    None.

--*/
{
    DNS_STATUS      status = NO_ERROR;
    PDNS_RECORD     prrList = NULL;
    PDNS_RECORD     prr = NULL;
    DWORD           iter;
    BOOL            fmatch = FALSE;
    WORD            wtype = DNS_TYPE_A;
    PDNS_NETINFO    pnetInfo = NULL;
    PDNS_ADDR_ARRAY plocalArray = NULL;

    if ( !pszName )
    {
        return ERROR_INVALID_PARAMETER;
    }

    if ( Options == DNS_CHECK_AGAINST_HOST_ANY )
    {
        wtype = DNS_TYPE_ANY;
    }

    //
    //  query against name
    //

    status = DnsQuery_W(
                    pszName,
                    wtype,
                    DNS_QUERY_BYPASS_CACHE,
                    NULL,
                    &prrList,
                    NULL );

    if ( status != NO_ERROR )
    {
        if ( status == DNS_ERROR_RCODE_NAME_ERROR ||
             status == DNS_INFO_NO_RECORDS )
        {
            status = NO_ERROR;
        }
        goto Done;
    }

    //
    //  HOST_ANY -- fails if any records
    //

    if ( Options == DNS_CHECK_AGAINST_HOST_ANY )
    {
        status = DNS_ERROR_RCODE_YXRRSET;
        goto Done;
    }

    //
    //  DCR:  eliminate CheckNameCollision with DNS_CHECK_AGAINST_HOST_DOMAIN_NAME flag?
    //
    //  not sure there are ANY callers with this flag as
    //  the flag is always TRUE in NT5->today and no one has complained
    //

    if ( Options == DNS_CHECK_AGAINST_HOST_DOMAIN_NAME )
    {
        WCHAR   nameFull[ DNS_MAX_NAME_BUFFER_LENGTH ];
        PWSTR   phostName = (PWSTR) Reg_GetHostName( DnsCharSetUnicode );
        PWSTR   pprimaryName = (PWSTR) Reg_GetPrimaryDomainName( DnsCharSetUnicode );
        PWSTR   pdomainName = pprimaryName;

        //  DCR:  busted test both here and in NT5
        fmatch = TRUE;

        if ( Dns_NameCompare_W( phostName, pszName ) )
        {
            fmatch = TRUE;
        }

        //  check against full primary name

        else if ( pdomainName
                    &&
                Dns_NameAppend_W(
                    nameFull,
                    DNS_MAX_NAME_BUFFER_LENGTH,
                    phostName,
                    pdomainName )
                    &&
                Dns_NameCompare_W( nameFull, pszName ) )
        {
            fmatch = TRUE;
        }

        //
        //  DCR:  if save this, functionalize as name check against netinfo
        //      could use in local ip
        //      could just return rank\adapter
        //

        if ( !fmatch )
        {
            pnetInfo = GetNetworkInfo();
            if ( pnetInfo )
            {
                PDNS_ADAPTER    padapter;

                NetInfo_AdapterLoopStart( pnetInfo );
            
                while( padapter = NetInfo_GetNextAdapter( pnetInfo ) )
                {
                    pdomainName = padapter->pszAdapterDomain;
                    if ( pdomainName
                            &&
                        Dns_NameAppend_W(
                            nameFull,
                            DNS_MAX_NAME_BUFFER_LENGTH,
                            phostName,
                            pdomainName )
                            &&
                        Dns_NameCompare_W( nameFull, pszName ) )
                    {
                        fmatch = TRUE;
                        break;
                    }
                }
            }
        }

        FREE_HEAP( phostName );
        FREE_HEAP( pprimaryName );

        if ( fmatch )
        {
            status = DNS_ERROR_RCODE_YXRRSET;
            goto Done;
        }
    }

    //
    //  checking against local address records
    //

    plocalArray = NetInfo_GetLocalAddrArray(
                        pnetInfo,
                        NULL,   // no specific adapter
                        0,      // no specific family
                        0,      // no flags
                        FALSE   // no force
                        );
    if ( !plocalArray )
    {
        status = DNS_ERROR_RCODE_YXRRSET;
        goto Done;
    }

    prr = prrList;

    while ( prr )
    {
        if ( prr->Flags.S.Section != DNSREC_ANSWER )
        {
            prr = prr->pNext;
            continue;
        }

        if ( prr->wType == DNS_TYPE_CNAME )
        {
            status = DNS_ERROR_RCODE_YXRRSET;
            goto Done;
        }

        if ( prr->wType == DNS_TYPE_A &&
             !DnsAddrArray_ContainsIp4(
                plocalArray,
                prr->Data.A.IpAddress ) )
        {
            status = DNS_ERROR_RCODE_YXRRSET;
            goto Done;
        }

        prr = prr->pNext;
    }

    //  matched all address

Done:

    Dns_RecordListFree( prrList );
    NetInfo_Free( pnetInfo );
    DnsAddrArray_Free( plocalArray );

    return status;
}



DNS_STATUS
WINAPI
DnsCheckNameCollision_A(
    IN      PCSTR           pszName,
    IN      DWORD           Options
    )
/*++

Routine Description:

    None.

Arguments:

    None.

Return Value:

    None.

--*/
{
    PWSTR      pname;
    DNS_STATUS status = NO_ERROR;

    //
    //  convert to unicode and call
    //

    if ( !pszName )
    {
        return ERROR_INVALID_PARAMETER;
    }

    pname = Dns_NameCopyAllocate(
                    (PSTR) pszName,
                    0,
                    DnsCharSetAnsi,
                    DnsCharSetUnicode );
    if ( !pname )
    {
        return DNS_ERROR_NO_MEMORY;
    }

    status = DnsCheckNameCollision_W( pname, Options );

    FREE_HEAP( pname );

    return status;
}



DNS_STATUS
WINAPI
DnsCheckNameCollision_UTF8(
    IN      PCSTR           pszName,
    IN      DWORD           Options
    )
/*++

Routine Description:

    None.

Arguments:

    None.

Return Value:

    None.

--*/
{
    PWSTR      pname;
    DNS_STATUS status = NO_ERROR;

    //
    //  convert to unicode and call
    //

    if ( !pszName )
    {
        return ERROR_INVALID_PARAMETER;
    }

    pname = Dns_NameCopyAllocate(
                    (PSTR) pszName,
                    0,
                    DnsCharSetUtf8,
                    DnsCharSetUnicode );
    if ( !pname )
    {
        return DNS_ERROR_NO_MEMORY;
    }

    status = DnsCheckNameCollision_W( pname, Options );

    FREE_HEAP( pname );

    return status;
}

//
//  End query.c
//
=== C:/Users/treeman/Desktop/windows nt source code\Source\Win2K3\NT\ds\dns\dnsapi\registry.c ===
/*++

Copyright (c) 2000-2001  Microsoft Corporation

Module Name:

    registry.c

Abstract:

    Domain Name System (DNS) API 

    Registry management routines.

Author:

    Jim Gilroy (jamesg)     March, 2000

Revision History:

--*/


#include "local.h"
#include "registry.h"


//
//  Globals
//
//  DWORD globals blob
//
//  g_IsRegReady protects needs init and protects (requires)
//  global init.
//
//  See registry.h for discussion of how these globals are
//  exposed both internal to the DLL and external.
//

DNS_GLOBALS_BLOB    DnsGlobals;

BOOL    g_IsRegReady = FALSE;

PWSTR   g_pwsRemoteResolver = NULL;


//
//  Property table
//

//
//  WARNING:  table must be in sync with DNS_REGID definitions
//
//  For simplicity I did not provide a separate index field and
//  a lookup function (or alternatively a function that returned
//  all the properties or a property pointer).
//
//  The DNS_REGID values ARE the INDEXES!
//  Hence the table MUST be in sync or the whole deal blows up
//  If you make a change to either -- you must change the other!
//

REG_PROPERTY    RegPropertyTable[] =
{
    //  Basic

    HOST_NAME                                   ,
        0                                       ,   // Default FALSE
            0                                   ,   // No policy
            1                                   ,   // Client
            1                                   ,   // TcpIp 
            0                                   ,   // No Cache

    DOMAIN_NAME                                 ,
        0                                       ,   // Default FALSE
            1                                   ,   // Policy
            0                                   ,   // No Client
            1                                   ,   // TcpIp 
            0                                   ,   // No Cache

    DHCP_DOMAIN_NAME                            ,
        0                                       ,   // Default FALSE
            1                                   ,   // Policy
            0                                   ,   // No Client
            1                                   ,   // TcpIp 
            0                                   ,   // No Cache

    ADAPTER_DOMAIN_NAME                         ,
        0                                       ,   // Default FALSE
            1                                   ,   // Policy
            1                                   ,   // Client
            0                                   ,   // No TcpIp 
            0                                   ,   // No Cache

    PRIMARY_DOMAIN_NAME                         ,
        0                                       ,   // Default FALSE
            1                                   ,   // Policy
            1                                   ,   // Client
            0                                   ,   // No TcpIp 
            0                                   ,   // No Cache

    PRIMARY_SUFFIX                              ,
        0                                       ,   // Default FALSE
            1                                   ,   // Policy
            1                                   ,   // Client
            1                                   ,   // TcpIp 
            0                                   ,   // No Cache

    ALTERNATE_NAMES                             ,
        0                                       ,   // Default NULL
            0                                   ,   // No Policy
            0                                   ,   // No Client
            0                                   ,   // No TcpIp 
            1                                   ,   // Cache

    DNS_SERVERS                                 ,
        0                                       ,   // Default FALSE
            0                                   ,   // Policy
            0                                   ,   // Client
            0                                   ,   // TcpIp 
            0                                   ,   // No Cache

    SEARCH_LIST_KEY                             ,
        0                                       ,   // Default FALSE
            1                                   ,   // Policy
            1                                   ,   // Client
            1                                   ,   // TcpIp 
            0                                   ,   // No Cache

    //  not in use
    UPDATE_ZONE_EXCLUSIONS                      ,
        0                                       ,   // Default 
            1                                   ,   // Policy
            1                                   ,   // Client
            0                                   ,   // No TcpIp 
            1                                   ,   // Cache

    //  Query

    QUERY_ADAPTER_NAME                          ,
        1                                       ,   // Default TRUE
            1                                   ,   // Policy
            1                                   ,   // Client
            0                                   ,   // No TcpIp 
            1                                   ,   // Cache
    USE_DOMAIN_NAME_DEVOLUTION                  ,
        1                                       ,   // Default TRUE
            1                                   ,   // Policy
            1                                   ,   // Client
            1                                   ,   // TcpIp 
            1                                   ,   // Cache
    PRIORITIZE_RECORD_DATA                      ,
        1                                       ,   // Default TRUE
            1                                   ,   // Policy
            1                                   ,   // Client
            1                                   ,   // TcpIp 
            1                                   ,   // Cache
    ALLOW_UNQUALIFIED_QUERY                     ,
        0                                       ,   // Default FALSE
            1                                   ,   // Policy
            1                                   ,   // Client
            1                                   ,   // TcpIp 
            1                                   ,   // Cache
    APPEND_TO_MULTI_LABEL_NAME                  ,
        1                                       ,   // Default TRUE
            1                                   ,   // Policy
            1                                   ,   // Client
            0                                   ,   // No TcpIp 
            1                                   ,   // Cache
    SCREEN_BAD_TLDS                             ,
        DNS_TLD_SCREEN_DEFAULT                  ,   // Default
            1                                   ,   // Policy
            1                                   ,   // Client
            0                                   ,   // No TcpIp 
            1                                   ,   // Cache
    SCREEN_UNREACHABLE_SERVERS                  ,
        1                                       ,   // Default TRUE
            1                                   ,   // Policy
            1                                   ,   // Client
            0                                   ,   // No TcpIp 
            1                                   ,   // Cache
    FILTER_CLUSTER_IP                           ,
        0                                       ,   // Default FALSE
            1                                   ,   // Policy
            1                                   ,   // Client
            0                                   ,   // No TcpIp 
            1                                   ,   // Cache
    WAIT_FOR_NAME_ERROR_ON_ALL                  ,
        1                                       ,   // Default TRUE
            1                                   ,   // Policy
            1                                   ,   // Client
            0                                   ,   // No TcpIp 
            1                                   ,   // Cache
    USE_EDNS                                    ,
        //REG_EDNS_TRY                            ,   // Default TRY EDNS
        0                                       ,   // Default FALSE
            1                                   ,   // Policy
            1                                   ,   // Client
            0                                   ,   // No TcpIp 
            1                                   ,   // Cache
    QUERY_IP_MATCHING                           ,
        1                                       ,   // Default TRUE
            1                                   ,   // Policy
            1                                   ,   // Client
            1                                   ,   // TcpIp  (in Win2k)
            1                                   ,   // Cache

    //  Update

    REGISTRATION_ENABLED                        ,
        1                                       ,   // Default TRUE
            1                                   ,   // Policy
            1                                   ,   // Client
            0                                   ,   // No TcpIp 
            1                                   ,   // Cache
    REGISTER_PRIMARY_NAME                       ,
        1                                       ,   // Default TRUE
            1                                   ,   // Policy
            1                                   ,   // Client
            0                                   ,   // No TcpIp 
            1                                   ,   // Cache
    REGISTER_ADAPTER_NAME                       ,
        1                                       ,   // Default TRUE
            1                                   ,   // Policy
            1                                   ,   // Client
            0                                   ,   // No TcpIp 
            1                                   ,   // Cache
    REGISTER_REVERSE_LOOKUP                     ,
        1                                       ,   // Default TRUE
            1                                   ,   // Policy
            1                                   ,   // Client
            0                                   ,   // No TcpIp 
            1                                   ,   // Cache
    REGISTER_WAN_ADAPTERS                       ,
        1                                       ,   // Default TRUE
            1                                   ,   // Policy
            1                                   ,   // Client
            0                                   ,   // No TcpIp 
            1                                   ,   // Cache
    REGISTRATION_TTL                            ,
        REGDEF_REGISTRATION_TTL                 ,
            1                                   ,   // Policy
            1                                   ,   // Client
            0                                   ,   // No TcpIp 
            1                                   ,   // Cache
    REGISTRATION_REFRESH_INTERVAL               ,
        REGDEF_REGISTRATION_REFRESH_INTERVAL    ,
            1                                   ,   // Policy
            1                                   ,   // Client
            0                                   ,   // No TcpIp 
            1                                   ,   // Cache
    REGISTRATION_MAX_ADDRESS_COUNT              ,
        1                                       ,   // Default register 1 address
            1                                   ,   // Policy
            1                                   ,   // Client
            0                                   ,   // No TcpIp 
            1                                   ,   // Cache
    UPDATE_SECURITY_LEVEL                       ,
        DNS_UPDATE_SECURITY_USE_DEFAULT         ,
            1                                   ,   // Policy
            1                                   ,   // Client
            1                                   ,   // TcpIp 
            1                                   ,   // Cache

    //  not in use
    UPDATE_ZONE_EXCLUDE_FILE                    ,
        0                                       ,   // Default OFF
            1                                   ,   // Policy
            1                                   ,   // Client
            0                                   ,   // No TcpIp 
            1                                   ,   // Cache
    UPDATE_TOP_LEVEL_DOMAINS                    ,
        0                                       ,   // Default OFF
            1                                   ,   // Policy
            1                                   ,   // Client
            0                                   ,   // No TcpIp 
            1                                   ,   // Cache

    //
    //  Backcompat
    //
    //  DCR:  once policy fixed, policy should be OFF on all backcompat
    //

    DISABLE_ADAPTER_DOMAIN_NAME                 ,
        0                                       ,   // Default FALSE
            0                                   ,   // Policy
            0                                   ,   // Client
            1                                   ,   // TcpIp 
            0                                   ,   // No Cache
    DISABLE_DYNAMIC_UPDATE                      ,
        0                                       ,   // Default FALSE
            0                                   ,   // Policy
            0                                   ,   // Client
            1                                   ,   // TcpIp 
            0                                   ,   // No Cache
    ENABLE_ADAPTER_DOMAIN_NAME_REGISTRATION     ,
        0                                       ,   // Default TRUE
            0                                   ,   // Policy
            0                                   ,   // Client
            1                                   ,   // TcpIp 
            0                                   ,   // No Cache
    DISABLE_REVERSE_ADDRESS_REGISTRATIONS       ,
        0                                       ,   // Default FALSE
            0                                   ,   // Policy
            0                                   ,   // Client
            1                                   ,   // TcpIp 
            0                                   ,   // No Cache
    DISABLE_WAN_DYNAMIC_UPDATE                  ,
        0                                       ,   // Default FALSE
            0                                   ,   // Policy OFF
            0                                   ,   // Client
            1                                   ,   // TcpIp 
            0                                   ,   // No Cache
    ENABLE_WAN_UPDATE_EVENT_LOG                 ,
        0                                       ,   // Default FALSE
            0                                   ,   // Policy OFF
            0                                   ,   // Client
            1                                   ,   // TcpIp 
            0                                   ,   // No Cache
    DEFAULT_REGISTRATION_TTL                    ,
        REGDEF_REGISTRATION_TTL                 ,
            0                                   ,   // Policy OFF
            0                                   ,   // Client
            1                                   ,   // TcpIp 
            0                                   ,   // No Cache
    DEFAULT_REGISTRATION_REFRESH_INTERVAL       ,
        REGDEF_REGISTRATION_REFRESH_INTERVAL    ,
            0                                   ,   // Policy
            0                                   ,   // Client
            1                                   ,   // TcpIp 
            0                                   ,   // No Cache
    MAX_NUMBER_OF_ADDRESSES_TO_REGISTER         ,
        1                                       ,   // Default register 1 address
            0                                   ,   // Policy
            0                                   ,   // Client
            1                                   ,   // TcpIp 
            0                                   ,   // No Cache


    //  Micellaneous

    NT_SETUP_MODE                               ,
        0                                       ,   // Default FALSE
            0                                   ,   // No policy
            0                                   ,   // Client
            0                                   ,   // No TcpIp 
            0                                   ,   // No Cache

    DNS_TEST_MODE                               ,
        0                                       ,   // Default FALSE
            0                                   ,   // No policy
            0                                   ,   // No Client
            0                                   ,   // No TcpIp 
            1                                   ,   // In Cache

    REMOTE_DNS_RESOLVER                         ,
        0                                       ,   // Default FALSE
            1                                   ,   // Policy
            1                                   ,   // Client
            0                                   ,   // No TcpIp 
            1                                   ,   // In Cache

    //  Resolver

    MAX_CACHE_SIZE                              ,
        1000                                    ,   // Default 1000 record sets
            1                                   ,   // Policy
            1                                   ,   // Client
            0                                   ,   // No TcpIp 
            1                                   ,   // Cache

    MAX_CACHE_TTL                               ,
        86400                                   ,   // Default 1 day
            1                                   ,   // Policy
            1                                   ,   // Client
            0                                   ,   // No TcpIp 
            1                                   ,   // Cache

    MAX_NEGATIVE_CACHE_TTL                      ,
        900                                     ,   // Default 15 minutes
            1                                   ,   // Policy
            1                                   ,   // Client
            0                                   ,   // No TcpIp 
            1                                   ,   // Cache

    ADAPTER_TIMEOUT_LIMIT                       ,
        600                                     ,   // Default 10 minutes
            1                                   ,   // Policy
            1                                   ,   // Client
            0                                   ,   // No TcpIp 
            1                                   ,   // Cache

    SERVER_PRIORITY_TIME_LIMIT                  ,
        300                                     ,   // Default 5 minutes
            1                                   ,   // Policy
            1                                   ,   // Client
            0                                   ,   // No TcpIp 
            1                                   ,   // Cache

    MAX_CACHED_SOCKETS                          ,
        10                                      ,   // Default 10
            1                                   ,   // Policy
            1                                   ,   // Client
            0                                   ,   // No TcpIp 
            1                                   ,   // Cache

    //  Multicast

    MULTICAST_LISTEN_LEVEL                      ,
        MCAST_LISTEN_FULL_IP6_ONLY              ,   // Default IP6 only
            1                                   ,   // Policy
            0                                   ,   // No Client
            0                                   ,   // No TcpIp 
            1                                   ,   // Cache

    MULTICAST_SEND_LEVEL                        ,
        MCAST_SEND_FULL_IP6_ONLY                ,   // Default IP6 only
            1                                   ,   // Policy
            0                                   ,   // No Client
            0                                   ,   // No TcpIp 
            1                                   ,   // Cache

    //
    //  DHCP registration regkeys
    //
    //  note, these are not part of the normal DNS client\resolver
    //  registry settings;  they are only here to provide the
    //  regid to regname mapping so they can be read and written
    //  with the standard registry functions
    //

    DHCP_REGISTERED_DOMAIN_NAME                 ,
        0                                       ,   // No Default
            0                                   ,   // No Policy
            0                                   ,   // No Client
            0                                   ,   // No TcpIp 
            0                                   ,   // No Cache

    DHCP_SENT_UPDATE_TO_IP                      ,
        0                                       ,   // No Default
            0                                   ,   // No Policy
            0                                   ,   // No Client
            0                                   ,   // No TcpIp 
            0                                   ,   // No Cache

    DHCP_SENT_PRI_UPDATE_TO_IP                  ,
        0                                       ,   // No Default
            0                                   ,   // No Policy
            0                                   ,   // No Client
            0                                   ,   // No TcpIp 
            0                                   ,   // No Cache

    DHCP_REGISTERED_TTL                         ,
        0                                       ,   // No Default
            0                                   ,   // No Policy
            0                                   ,   // No Client
            0                                   ,   // No TcpIp 
            0                                   ,   // No Cache

    DHCP_REGISTERED_FLAGS                       ,
        0                                       ,   // No Default
            0                                   ,   // No Policy
            0                                   ,   // No Client
            0                                   ,   // No TcpIp 
            0                                   ,   // No Cache

    DHCP_REGISTERED_SINCE_BOOT                  ,
        0                                       ,   // No Default
            0                                   ,   // No Policy
            0                                   ,   // No Client
            0                                   ,   // No TcpIp 
            0                                   ,   // No Cache

    DHCP_DNS_SERVER_ADDRS                       ,
        0                                       ,   // No Default
            0                                   ,   // No Policy
            0                                   ,   // No Client
            0                                   ,   // No TcpIp 
            0                                   ,   // No Cache

    DHCP_DNS_SERVER_ADDRS_COUNT                 ,
        0                                       ,   // No Default
            0                                   ,   // No Policy
            0                                   ,   // No Client
            0                                   ,   // No TcpIp 
            0                                   ,   // No Cache

    DHCP_REGISTERED_ADDRS                       ,
        0                                       ,   // No Default
            0                                   ,   // No Policy
            0                                   ,   // No Client
            0                                   ,   // No TcpIp 
            0                                   ,   // No Cache

    DHCP_REGISTERED_ADDRS_COUNT                 ,
        0                                       ,   // No Default
            0                                   ,   // No Policy
            0                                   ,   // No Client
            0                                   ,   // No TcpIp 
            0                                   ,   // No Cache

    //  Termination

    NULL,  0,  0, 0, 0, 0
};


//
//  Backward compatibility list
//
//  Maps new reg id to old reg id.
//  Flag fReverse indicates need to reverse (!) the value.
//

#define NO_BACK_VALUE   ((DWORD)(0xffffffff))

typedef struct _Backpat
{
    DWORD       NewId;
    DWORD       OldId;
    BOOL        fReverse;
}
BACKPAT;

BACKPAT BackpatArray[] =
{
    RegIdQueryAdapterName,
    RegIdDisableAdapterDomainName,
    TRUE,

    RegIdRegistrationEnabled,
    RegIdDisableDynamicUpdate,
    TRUE,

    RegIdRegisterAdapterName,
    RegIdEnableAdapterDomainNameRegistration,
    FALSE,
    
    RegIdRegisterReverseLookup,
    RegIdDisableReverseAddressRegistrations,
    TRUE,

    RegIdRegisterWanAdapters,
    RegIdDisableWanDynamicUpdate,
    TRUE,

    RegIdRegistrationTtl,
    RegIdDefaultRegistrationTTL,
    FALSE,
    
    RegIdRegistrationRefreshInterval,
    RegIdDefaultRegistrationRefreshInterval,
    FALSE,

    RegIdRegistrationMaxAddressCount,
    RegIdMaxNumberOfAddressesToRegister,
    FALSE,

    NO_BACK_VALUE, 0, 0
};





VOID
Reg_Init(
    VOID
    )
/*++

Routine Description:

    Init DNS registry stuff.

    Essentially this means get system version info.

Arguments:

    None.

Globals:

    Sets the system info globals above:
        g_IsWorkstation
        g_IsServer
        g_IsDomainController
        g_IsRegReady

Return Value:

    None.

--*/
{
    OSVERSIONINFOEX osvi;
    BOOL            bversionInfoEx;

    //
    //  do this just once
    //

    if ( g_IsRegReady )
    {
        return;
    }

    //
    //  code validity check
    //  property table should have entry for every reg value plus an
    //      extra one for the terminator
    //

    DNS_ASSERT( (RegIdMax+2)*sizeof(REG_PROPERTY) ==
                sizeof(RegPropertyTable) );

    //
    //  clear globals blob
    //
    //  DCR:  warning clearing DnsGlobals but don't read them all
    //      this is protected by read-once deal but still kind of
    //

    RtlZeroMemory(
        & DnsGlobals,
        sizeof(DnsGlobals) );

    //
    //  get version info
    //

    g_IsWin2000 = TRUE;

    ZeroMemory( &osvi, sizeof(OSVERSIONINFOEX) );

    osvi.dwOSVersionInfoSize = sizeof(OSVERSIONINFOEX);

    bversionInfoEx = GetVersionEx( (OSVERSIONINFO*) &osvi );
    if ( !bversionInfoEx)
    {
        osvi.dwOSVersionInfoSize = sizeof(OSVERSIONINFO);

        if ( ! GetVersionEx( (OSVERSIONINFO *) &osvi ) )
        {
            DNS_ASSERT( FALSE );
            return;
        }
    }

    //
    //  get system type -- workstation, server, DC
    //

    if ( bversionInfoEx )
    {
        if ( osvi.wProductType == VER_NT_WORKSTATION )
        {
            g_IsWorkstation = TRUE;
        }
        else if ( osvi.wProductType == VER_NT_SERVER )
        {
            g_IsServer = TRUE;
        }
        else if ( osvi.wProductType == VER_NT_DOMAIN_CONTROLLER )
        {
            g_IsServer = TRUE;
            g_IsDomainController = TRUE;
        }
        ELSE_ASSERT( FALSE );
    }

    g_IsRegReady = TRUE;

    DNSDBG( REGISTRY, (
        "DNS registry init:\n"
        "\tWorksta  = %d\n"
        "\tServer   = %d\n"
        "\tDC       = %d\n",
        g_IsWorkstation,
        g_IsServer,
        g_IsDomainController ));
}





//
//  Registry table routines
//

PWSTR 
regValueNameForId(
    IN      DWORD           RegId
    )
/*++

Routine Description:

    Return registry value name for reg ID

Arguments:

    RegId     -- ID for value

Return Value:

    Ptr to reg value name.
    NULL on error.

--*/
{
    DNSDBG( REGISTRY, (
        "regValueNameForId( id=%d )\n",
        RegId ));

    //
    //  validate ID
    //

    if ( RegId > RegIdMax )
    {
        return( NULL );
    }

    //
    //  index into table
    //

    return( REGPROP_NAME(RegId) );
}


DWORD
checkBackCompat(
    IN      DWORD           NewId,
    OUT     PBOOL           pfReverse
    )
/*++

Routine Description:

    Check if have backward compatible regkey.

Arguments:

    NewId -- id to check for old backward compatible id

    pfReverse -- addr to receive reverse flag

Return Value:

    Reg Id of old backward compatible value.
    NO_BACK_VALUE if no old value.

--*/
{
    DWORD   i = 0;
    DWORD   id;

    //
    //  loop through backcompat list looking for value
    //

    while ( 1 )
    {
        id = BackpatArray[i].NewId;

        if ( id == NO_BACK_VALUE )
        {
            return( NO_BACK_VALUE );
        }
        if ( id != NewId )
        {
            i++;
            continue;    
        }

        //  found value in backcompat array

        break;
    }

    *pfReverse = BackpatArray[i].fReverse;

    return  BackpatArray[i].OldId;
}



//
//  Registry session handle
//

DNS_STATUS
WINAPI
Reg_OpenSession(
    OUT     PREG_SESSION    pRegSession,
    IN      DWORD           Level,
    IN      DWORD           RegId
    )
/*++

Routine Description:

    Open registry for DNS client info.

Arguments:

    pRegSession -- ptr to unitialize reg session blob

    Level -- level of access to get

    RegId -- ID of value we're interested in

Return Value:

    None.

--*/
{
    DWORD           status = NO_ERROR;
    HKEY            hkey = NULL;
    DWORD           disposition;

    //  auto init

    Reg_Init();

    //
    //  clear handles
    //

    RtlZeroMemory(
        pRegSession,
        sizeof( REG_SESSION ) );


    //
    //  DCR:  handle multiple access levels   
    //
    //  For know assume that if getting access to "standard"
    //  section we'll need both policy and regular.
    //  

    //
    //  NT
    //  - Win2000
    //      - open TCPIP
    //      note, always open TCPIP as may not be any policy
    //      for some or all of our desired reg values, even
    //      if policy key is available
    //      - open policy (only if standard successful)
    //

    status = RegCreateKeyExW(
                    HKEY_LOCAL_MACHINE,
                    TCPIP_PARAMETERS_KEY,
                    0,
                    L"Class",
                    REG_OPTION_NON_VOLATILE,
                    KEY_READ,
                    NULL,
                    &hkey,
                    &disposition );

    if ( status != ERROR_SUCCESS )
    {
        goto Done;
    }

#ifdef DNSCLIENTKEY
    //  open DNS client key
    //
    //  DCR:  currently no DNSClient regkey

    RegOpenKeyExW(
        HKEY_LOCAL_MACHINE,
        DNS_CLIENT_KEY,
        0,
        KEY_READ,
        & pRegSession->hClient );
#endif

    //  open DNS cache key

    RegOpenKeyExW(
        HKEY_LOCAL_MACHINE,
        DNS_CACHE_KEY,
        0,
        KEY_READ,
        & pRegSession->hCache );

    //  open DNS policy key

    RegOpenKeyExW(
        HKEY_LOCAL_MACHINE,
        DNS_POLICY_KEY,
        0,
        KEY_READ,
        & pRegSession->hPolicy );
    

Done:

    //
    //  all OS versions return TCP/IP key
    //

    if ( status == ERROR_SUCCESS )
    {
        pRegSession->hTcpip = hkey;
    }
    else
    {
        Reg_CloseSession( pRegSession );
    }

    DNSDBG( TRACE, (
        "Leave:  Reg_OpenSession( s=%d, t=%p, p=%p, c=%p )\n",
        status,
        pRegSession->hTcpip,
        pRegSession->hPolicy,
        pRegSession->hClient ));

    return( status );
}



VOID
WINAPI
Reg_CloseSession(
    IN OUT  PREG_SESSION    pRegSession
    )
/*++

Routine Description:

    Close registry session handle.

    This means close underlying regkeys.

Arguments:

    pSessionHandle -- ptr to registry session handle

Return Value:

    None.

--*/
{
    //
    //  allow sloppy cleanup
    //

    if ( !pRegSession )
    {
        return;
    }

    //
    //  close any non-NULL handles
    //

    if ( pRegSession->hPolicy )
    {
        RegCloseKey( pRegSession->hPolicy );
    }
    if ( pRegSession->hTcpip )
    {
        RegCloseKey( pRegSession->hTcpip );
    }
#ifdef DNSCLIENTKEY
    if ( pRegSession->hClient )
    {
        RegCloseKey( pRegSession->hClient );
    }
#endif
    if ( pRegSession->hCache )
    {
        RegCloseKey( pRegSession->hCache );
    }

    //
    //  clear handles (just for safety)
    //

    RtlZeroMemory(
        pRegSession,
        sizeof(REG_SESSION) );
}



//
//  Registry reading routines
//

DNS_STATUS
Reg_GetDword(
    IN      PREG_SESSION    pRegSession,    OPTIONAL
    IN      HKEY            hRegKey,        OPTIONAL
    IN      PWSTR           pwsKeyName,     OPTIONAL
    IN      DWORD           RegId,
    OUT     PDWORD          pResult
    )
/*++

Routine Description:

    Read REG_DWORD value from registry.

    //
    //  DCR:  do we need to expose location result?
    //      (explicit, policy, defaulted)
    //

Arguments:

    pRegSession -- ptr to reg session already opened (OPTIONAL)

    hRegKey     -- explicit regkey

    pwsKeyName  -- key name OR dummy key 

    RegId     -- ID for value

    pResult     -- addr of DWORD to recv result

    pfRead      -- addr to recv result of how value read
                0 -- defaulted
                1 -- read
        Currently just use ERROR_SUCCESS to mean read rather
        than defaulted.

Return Value:

    ERROR_SUCCESS on success.
    ErrorCode on failure -- value is then defaulted.

--*/
{
    DNS_STATUS      status;
    REG_SESSION     session;
    PREG_SESSION    psession = pRegSession;
    PWSTR           pname;
    DWORD           regType = REG_DWORD;
    DWORD           dataLength = sizeof(DWORD);
    HKEY            hkey;
    HKEY            hlocalKey = NULL;


    DNSDBG( REGISTRY, (
        "Reg_GetDword( s=%p, k=%p, a=%p, id=%d )\n",
        pRegSession,
        hRegKey,
        pwsKeyName,
        RegId ));

    //  auto init

    Reg_Init();

    //
    //  clear result for error case
    //

    *pResult = 0;

    //
    //  get proper regval name
    //      - wide for NT
    //      - narrow for 9X
    //

    pname = regValueNameForId( RegId );
    if ( !pname )
    {
        DNS_ASSERT( FALSE );
        return( ERROR_INVALID_PARAMETER );
    }

    //
    //  DCR:  can use function pointers for wide narrow
    //

    //
    //  three paradigms
    //
    //  1) specific key (adapter or something else)
    //      => use it
    //
    //  2) specific key name (adapter or dummy key location)
    //      => open key
    //      => use it
    //      => close 
    //
    //  3) session -- passed in or created (default)
    //      => use pRegSession or open new
    //      => try policy first then TCPIP parameters
    //      => close if open
    //

    if ( hRegKey )
    {
        hkey = hRegKey;
    }

    else if ( pwsKeyName )
    {
        hkey = Reg_CreateKey(
                    pwsKeyName,
                    FALSE       // read access
                    );
        if ( !hkey )
        {
            status = GetLastError();
            goto Done;
        }
        hlocalKey = hkey;
    }

    else
    {
        //  open reg handle if not open
    
        if ( !psession )
        {
            status = Reg_OpenSession(
                            &session,
                            0,              // standard level
                            RegId         // target key
                            );
            if ( status != ERROR_SUCCESS )
            {
                goto Done;
            }
            psession = &session;
        }

        //  try policy section -- if available

        hkey = psession->hPolicy;

        if ( hkey && REGPROP_POLICY(RegId) )
        {
            status = RegQueryValueExW(
                        hkey,
                        pname,
                        0,
                        & regType,
                        (PBYTE) pResult,
                        & dataLength
                        );
            if ( status == ERROR_SUCCESS )
            {
                goto DoneSuccess;
            }
        }

        //  unsuccessful -- try DnsClient

#ifdef DNSCLIENTKEY
        hkey = psession->hClient;
        if ( hkey && REGPROP_CLIENT(RegId) )
        {
            status = RegQueryValueExW(
                        hkey,
                        pname,
                        0,
                        & regType,
                        (PBYTE) pResult,
                        & dataLength
                        );
            if ( status == ERROR_SUCCESS )
            {
                goto DoneSuccess;
            }
        }
#endif

        //  unsuccessful -- try DnsCache

        hkey = psession->hCache;
        if ( hkey && REGPROP_CACHE(RegId) )
        {
            status = RegQueryValueExW(
                        hkey,
                        pname,
                        0,
                        & regType,
                        (PBYTE) pResult,
                        & dataLength
                        );
            if ( status == ERROR_SUCCESS )
            {
                goto DoneSuccess;
            }
        }

        //  unsuccessful -- try TCPIP key
        //      - if have open session it MUST include TCPIP key

        hkey = psession->hTcpip;
        if ( hkey && REGPROP_TCPIP(RegId) )
        {
            status = RegQueryValueExW(
                        hkey,
                        pname,
                        0,
                        & regType,
                        (PBYTE) pResult,
                        & dataLength
                        );
            if ( status == ERROR_SUCCESS )
            {
                goto DoneSuccess;
            }
        }

        status = ERROR_FILE_NOT_FOUND;
        goto Done;
    }

    //
    //  explict key (passed in or from name)
    //

    if ( hkey )
    {
        status = RegQueryValueExW(
                    hkey,
                    pname,
                    0,
                    & regType,
                    (PBYTE) pResult,
                    & dataLength
                    );
    }
    ELSE_ASSERT_FALSE;

Done:

    //
    //  if value not found, check for backward compatibility value
    //

    if ( status != ERROR_SUCCESS )
    {
        DWORD   oldId;
        BOOL    freverse;

        oldId = checkBackCompat( RegId, &freverse );

        if ( oldId != NO_BACK_VALUE )
        {
            DWORD   backValue;

            status = Reg_GetDword(
                        psession,
                        ( psession ) ? NULL : hkey,
                        ( psession ) ? NULL : pwsKeyName,
                        oldId,
                        & backValue );

            if ( status == ERROR_SUCCESS )
            {
                if ( freverse )
                {
                    backValue = !backValue;
                }
                *pResult = backValue;
            }
        }
    }

    //  default the value if read failed
    
    if ( status != ERROR_SUCCESS )
    {
        *pResult = REGPROP_DEFAULT( RegId );
    }

DoneSuccess:

    //  cleanup any regkey's opened

    if ( psession == &session )
    {
        Reg_CloseSession( psession );
    }

    else if ( hlocalKey )
    {
        RegCloseKey( hlocalKey );
    }

    return( status );
}



//
//  Reg utilities
//

DNS_STATUS
privateRegReadValue(
    IN      HKEY            hKey,
    IN      DWORD           RegId,
    IN      DWORD           Flag,
    OUT     PBYTE *         ppBuffer,
    OUT     PDWORD          pBufferLength
    )
/*++

Routine Description:

    Main registry reading routine.
    Handles sizing, allocations and conversions as necessary.

Arguments:

    hKey -- handle of the key whose value field is retrieved.

    RegId -- reg value ID, assumed to be validated (in table)

    Flag -- reg flags
        DNSREG_FLAG_DUMP_EMPTY
        DNSREG_FLAG_GET_UTF8

    ppBuffer -- ptr to address to receive buffer ptr

    pBufferLength -- addr to receive buffer length

Return Value:

    ERROR_SUCCESS if successful.
    ErrorCode on failure.

--*/
{
    DWORD   status;
    PWSTR   pname;
    DWORD   valueType = 0;      // prefix
    DWORD   valueSize = 0;      // prefix
    PBYTE   pdataBuffer;
    PBYTE   pallocBuffer = NULL;


    //
    //  query for buffer size
    //

    pname = REGPROP_NAME( RegId );

    status = RegQueryValueExW(
                hKey,
                pname,
                0,
                &valueType,
                NULL,
                &valueSize );
    
    if ( status != ERROR_SUCCESS )
    {
        return( status );
    }

    //
    //  setup result buffer   
    //

    switch( valueType )
    {
    case REG_DWORD:
        pdataBuffer = (PBYTE) ppBuffer;
        break;

    case REG_SZ:
    case REG_MULTI_SZ:
    case REG_EXPAND_SZ:
    case REG_BINARY:

        //  if size is zero, still allocate empty string
        //      - min alloc DWORD
        //          - can't possibly alloc smaller
        //          - good clean init to zero includes MULTISZ zero
        //          - need at least WCHAR string zero init
        //          and much catch small regbinary (1,2,3)
        
        if ( valueSize <= sizeof(DWORD) )
        {
            valueSize = sizeof(DWORD);
        }

        pallocBuffer = pdataBuffer = ALLOCATE_HEAP( valueSize );
        if ( !pdataBuffer )
        {
            return( DNS_ERROR_NO_MEMORY );
        }

        *(PDWORD)pdataBuffer = 0;
        break;

    default:
        return( ERROR_INVALID_PARAMETER );
    }

    //
    //  query for data
    //

    status = RegQueryValueExW(
                hKey,
                pname,
                0,
                &valueType,
                pdataBuffer,
                &valueSize );

    if ( status != ERROR_SUCCESS )
    {
        goto Cleanup;
    }

    //
    //  setup return buffer
    //

    switch( valueType )
    {
    case REG_DWORD:
    case REG_BINARY:
        break;

    case REG_SZ:
    case REG_EXPAND_SZ:
    case REG_MULTI_SZ:

        //
        //  dump empty strings?
        //
        //  note:  we always allocate at least a DWORD and
        //  set it NULL, so rather than a complex test for
        //  different reg types and char sets, can just test
        //  if that DWORD is still NULL
        //
        //  DCR:  do we want to screen whitespace-empty strings
        //      - example blank string
        //

        if ( Flag & DNSREG_FLAG_DUMP_EMPTY )
        {
            if ( valueSize==0 ||
                 *(PDWORD)pdataBuffer == 0 )
            {
                status = ERROR_INVALID_DATA;
                goto Cleanup;
            }
        }

        //
        //  force NULL termination
        //      - during security push, someone raised the question of whether
        //      the registry guarantees NULL termination on corrupted data
        //

        if ( valueSize == 0 )
        {
            *(PDWORD)pdataBuffer = 0;
        }
        else
        {
            INT lastChar = valueSize/sizeof(WCHAR) - 1;
            if ( lastChar >= 0 )
            {
                ((PWSTR)pdataBuffer)[ lastChar ] = 0;
            }
        }

        //
        //  by default we return strings as unicode
        //
        //  if flagged, return in UTF8
        //

        if ( Flag & DNSREG_FLAG_GET_UTF8 )
        {
            PBYTE putf8Buffer = ALLOCATE_HEAP( valueSize * 2 );
            if ( !putf8Buffer )
            {
                status = DNS_ERROR_NO_MEMORY;
                goto Cleanup;
            }

            if ( !Dns_UnicodeToUtf8(
                        (PWSTR) pdataBuffer,
                        valueSize / sizeof(WCHAR),
                        putf8Buffer,
                        valueSize * 2 ) )
            {
                FREE_HEAP( putf8Buffer );
                status = ERROR_INVALID_DATA;
                goto Cleanup;
            }

            FREE_HEAP( pallocBuffer );
            pallocBuffer = NULL;
            pdataBuffer = putf8Buffer;
        }
        break;

    default:
        break;
    }

Cleanup:

    //
    //  set return
    //      - REG_DWORD writes DWORD to ppBuffer directly
    //      - otherwise ppBuffer set to allocated buffer ptr
    //  or cleanup
    //      - on failure dump allocated buffer
    //

    if ( status == ERROR_SUCCESS )
    {
        if ( valueType != REG_DWORD )
        {
            *ppBuffer = pdataBuffer;
        }
        *pBufferLength = valueSize;
    }
    else
    {
        if ( valueType != REG_DWORD )
        {
            *ppBuffer = NULL;
        }
        else
        {
            *(PDWORD)ppBuffer = 0;
        }
        *pBufferLength = 0;
        FREE_HEAP( pallocBuffer );
    }

    return( status );
}



DNS_STATUS
Reg_GetValueEx(
    IN      PREG_SESSION    pRegSession,    OPTIONAL
    IN      HKEY            hRegKey,        OPTIONAL
    IN      PWSTR           pwsAdapter,     OPTIONAL
    IN      DWORD           RegId,
    IN      DWORD           ValueType,
    IN      DWORD           Flag,
    OUT     PBYTE *         ppBuffer
    )
/*++

Routine Description:

Arguments:

    pRegSession -- ptr to registry session, OPTIONAL

    hRegKey     -- handle to open regkey OPTIONAL

    pwsAdapter  -- name of adapter to query under OPTIONAL

    RegId     -- value ID

    ValueType   -- reg type of value

    Flag        -- flags with tweaks to lookup

    ppBuffer    -- addr to receive buffer ptr

        Note, for REG_DWORD, DWORD data is written directly to this
        location instead of a buffer being allocated and it's ptr
        being written.

Return Value:

    ERROR_SUCCESS if successful.
    Registry error code on failure.

--*/
{
    DNS_STATUS      status = ERROR_FILE_NOT_FOUND;
    REG_SESSION     session;
    PREG_SESSION    psession = pRegSession;
    PWSTR           pname;
    DWORD           regType = REG_DWORD;
    DWORD           dataLength;
    HKEY            hkey;
    HKEY            hadapterKey = NULL;


    DNSDBG( REGISTRY, (
        "Reg_GetValueEx( s=%p, k=%p, id=%d )\n",
        pRegSession,
        hRegKey,
        RegId ));

    ASSERT( !pwsAdapter );

    //  auto init

    Reg_Init();

    //
    //  get regval name
    //

    pname = regValueNameForId( RegId );
    if ( !pname )
    {
        DNS_ASSERT( FALSE );
        status = ERROR_INVALID_PARAMETER;
        goto FailedDone;
    }

    //
    //  two paradigms
    //
    //  1) specific key (adapter or something else)
    //      => use it
    //      => open adapter subkey if necessary
    //
    //  2) standard
    //      => try policy first, then DNSCache, then TCPIP
    //      => use pRegSession or open it
    //

    if ( hRegKey )
    {
        hkey = hRegKey;

        //  need to open adapter subkey

        if ( pwsAdapter )
        {
            status = RegOpenKeyExW(
                        hkey,
                        pwsAdapter,
                        0,
                        KEY_QUERY_VALUE,
                        & hadapterKey );

            if ( status != ERROR_SUCCESS )
            {
                goto FailedDone;
            }
            hkey = hadapterKey;
        }
    }

    else
    {
        //  open reg handle if not open
    
        if ( !pRegSession )
        {
            status = Reg_OpenSession(
                            &session,
                            0,            // standard level
                            RegId         // target key
                            );
            if ( status != ERROR_SUCCESS )
            {
                goto FailedDone;
            }
            psession = &session;
        }

        //  try policy section -- if available

        hkey = psession->hPolicy;

        if ( hkey && REGPROP_POLICY(RegId) )
        {
            status = privateRegReadValue(
                            hkey,
                            RegId,
                            Flag,
                            ppBuffer,
                            & dataLength
                            );
            if ( status == ERROR_SUCCESS )
            {
                goto Done;
            }
        }

        //  try DNS cache -- if available

        hkey = psession->hCache;

        if ( hkey && REGPROP_CACHE(RegId) )
        {
            status = privateRegReadValue(
                            hkey,
                            RegId,
                            Flag,
                            ppBuffer,
                            & dataLength
                            );
            if ( status == ERROR_SUCCESS )
            {
                goto Done;
            }
        }

        //  unsuccessful -- use TCPIP key

        hkey = psession->hTcpip;
        if ( !hkey )
        {
            goto Done;
        }
    }

    //
    //  explict key OR standard key case
    //

    status = privateRegReadValue(
                    hkey,
                    RegId,
                    Flag,
                    ppBuffer,
                    & dataLength
                    );
    if ( status == ERROR_SUCCESS )
    {
        goto Done;
    }

FailedDone:

    //
    //  if failed
    //      - for REG_DWORD, default the value
    //      - for strings, ensure NULL return buffer
    //      this takes care of cases where privateRegReadValue()
    //      never got called
    //

    if ( status != ERROR_SUCCESS )
    {
        if ( ValueType == REG_DWORD )
        {
            *(PDWORD) ppBuffer = REGPROP_DEFAULT( RegId );
        }
        else
        {
            *ppBuffer = NULL;
        }
    }

Done:

    //  cleanup any regkey's opened

    if ( psession == &session )
    {
        Reg_CloseSession( psession );
    }

    if ( hadapterKey )
    {
        RegCloseKey( hadapterKey );
    }

    return( status );
}




DNS_STATUS
Reg_GetIpArray(
    IN      PREG_SESSION    pRegSession,    OPTIONAL
    IN      HKEY            hRegKey,        OPTIONAL
    IN      PWSTR           pwsAdapter,     OPTIONAL
    IN      DWORD           RegId,
    IN      DWORD           ValueType,
    OUT     PIP4_ARRAY *    ppIpArray
    )
/*++

Routine Description:

Arguments:

    pRegSession -- ptr to registry session, OPTIONAL

    hRegKey     -- handle to open regkey OPTIONAL

    pwsAdapter  -- name of adapter to query under OPTIONAL

    RegId     -- value ID

    ValueType   -- currently ignored, but could later use
                    to distinguish REG_SZ from REG_MULTI_SZ
                    processing

    ppIpArray   -- addr to receive IP array ptr
                    - array is allocated with Dns_Alloc(),
                    caller must free with Dns_Free()

Return Value:

    ERROR_SUCCESS if successful.
    Registry error code on failure.

--*/
{
    DNS_STATUS      status;
    PSTR            pstring = NULL;

    DNSDBG( REGISTRY, (
        "Reg_GetIpArray( s=%p, k=%p, id=%d )\n",
        pRegSession,
        hRegKey,
        RegId ));

    //
    //  make call to get IP array as string
    //

    status = Reg_GetValueEx(
                pRegSession,
                hRegKey,
                pwsAdapter,
                RegId,
                REG_SZ,                 // only supported type is REG_SZ
                DNSREG_FLAG_GET_UTF8,   // get as narrow
                & pstring );

    if ( status != ERROR_SUCCESS )
    {
        ASSERT( pstring == NULL );
        return( status );
    }

    //
    //  convert from string to IP array
    //
    //  note:  this call is limited to a parsing limit
    //      but it is a large number suitable for stuff
    //      like DNS server lists
    //
    //  DCR:  use IP array builder for local IP address
    //      then need Dns_CreateIpArrayFromMultiIpString()
    //      to use count\alloc method when buffer overflows
    //

    status = Dns_CreateIpArrayFromMultiIpString(
                    pstring,
                    ppIpArray );

    //  cleanup

    if ( pstring )
    {
        FREE_HEAP( pstring );
    }

    return( status );
}




//
//  Registry writing routines
//

HKEY
WINAPI
Reg_CreateKey(
    IN      PWSTR           pwsKeyName,
    IN      BOOL            bWrite
    )
/*++

Routine Description:

    Open registry key.

    The purpose of this routine is simply to functionalize
    opening with\without an adapter name.
    So caller can pass through adapter name argument instead
    of building key name or doing two opens for adapter
    present\absent.

    This is NT only.

Arguments:

    pwsKeyName -- key "name"
        this is one of the REGKEY_X from registry.h
        OR
        adapter name

    bWrite -- TRUE for write access, FALSE for read

Return Value:

    New opened key.

--*/
{
    HKEY    hkey = NULL;
    DWORD   disposition;
    DWORD   status;
    PWSTR   pnameKey;
    WCHAR   nameBuffer[ MAX_PATH+1 ];

    //
    //  determine key name
    //
    //  this is either DNSKEY_X dummy pointer from registry.h
    //      OR
    //  is an adapter name; 
    //
    //      - if adapter given, open under it
    //          adapters are under TCPIP\Interfaces
    //      - any other specific key
    //      - default is TCPIP params key
    //
    //  note:  if if grows too big, turn into table
    //

    if ( pwsKeyName <= REGKEY_DNS_MAX )
    {
        if ( pwsKeyName == REGKEY_TCPIP_PARAMETERS )
        {
            pnameKey = TCPIP_PARAMETERS_KEY;
        }
        else if ( pwsKeyName == REGKEY_DNS_CACHE )
        {
            pnameKey = DNS_CACHE_KEY;
        }
        else if ( pwsKeyName == REGKEY_DNS_POLICY )
        {
            pnameKey = DNS_POLICY_KEY;
        }
        else if ( pwsKeyName == REGKEY_SETUP_MODE_LOCATION )
        {
            pnameKey = NT_SETUP_MODE_KEY;
        }
        else
        {
            pnameKey = TCPIP_PARAMETERS_KEY;
        }
    }

    else    // adapter name
    {
        _snwprintf(
            nameBuffer,
            MAX_PATH,
            L"%s%s",
            TCPIP_INTERFACES_KEY,
            pwsKeyName );

        pnameKey = nameBuffer;
    }

    //
    //  create\open key
    //

    if ( bWrite )
    {
        status = RegCreateKeyExW(
                        HKEY_LOCAL_MACHINE,
                        pnameKey,
                        0,
                        L"Class",
                        REG_OPTION_NON_VOLATILE,
                        KEY_WRITE,
                        NULL,
                        & hkey,
                        & disposition );
    }
    else
    {
        status = RegOpenKeyExW(
                    HKEY_LOCAL_MACHINE,
                    pnameKey,
                    0,
                    KEY_QUERY_VALUE,
                    & hkey );
    }

    if ( status != ERROR_SUCCESS )
    {
        SetLastError( status );
    }
    ELSE_ASSERT( hkey != NULL );

    return( hkey );
}



DNS_STATUS
WINAPI
Reg_SetDwordValueByName(
    IN      PVOID           pReserved,
    IN      HKEY            hRegKey,
    IN      PWSTR           pwsNameKey,     OPTIONAL
    IN      PWSTR           pwsNameValue,   OPTIONAL
    IN      DWORD           dwValue
    )
/*++

Routine Description:

    Set DWORD regkey.

Arguments:

    pReserved   -- reserved (may become session)

    hRegKey     -- existing key to set under OPTIONAL

    pwsNameKey  -- name of key or adapter to set under

    pwsNameValue -- name of reg value to set

    dwValue     -- value to set

Return Value:

    ERROR_SUCCESS if successful.
    ErrorCode on failure.

--*/
{
    HKEY        hkey;
    DNS_STATUS  status;

    //
    //  open key, if not provided
    //      - if adapter given, open under it
    //      - otherwise TCPIP params key
    //

    hkey = hRegKey;

    if ( !hkey )
    {
        hkey = Reg_CreateKey(
                    pwsNameKey,
                    TRUE            // open for write
                    );
        if ( !hkey )
        {
            return( GetLastError() );
        }
    }

    //
    //  write back value
    //

    status = RegSetValueExW(
                hkey,
                pwsNameValue,
                0,
                REG_DWORD,
                (LPBYTE) &dwValue,
                sizeof(DWORD) );

    if ( !hRegKey )
    {
        RegCloseKey( hkey );
    }

    return  status;
}



DNS_STATUS
WINAPI
Reg_SetDwordValue(
    IN      PVOID           pReserved,
    IN      HKEY            hRegKey,
    IN      PWSTR           pwsNameKey,     OPTIONAL
    IN      DWORD           RegId,
    IN      DWORD           dwValue
    )
/*++

Routine Description:

    Set DWORD regkey.

Arguments:

    pReserved   -- reserved (may become session)

    hRegKey     -- existing key to set under OPTIONAL

    pwsNameKey  -- name of key or adapter to set under

    RegId     -- id of value to set

    dwValue     -- value to set

Return Value:

    ERROR_SUCCESS if successful.
    ErrorCode on failure.

--*/
{
    //
    //  write back value using name of id
    //

    return  Reg_SetDwordValueByName(
                pReserved,
                hRegKey,
                pwsNameKey,
                REGPROP_NAME( RegId ),
                dwValue );
}

//
//  End registry.c
//
=== C:/Users/treeman/Desktop/windows nt source code\Source\Win2K3\NT\ds\dns\dnsapi\registry.h ===
/*++

Copyright (c) 2000-2001  Microsoft Corporation

Module Name:

    registry.h

Abstract:

    Domain Name System (DNS) API 

    Registry routines header.

Author:

    Jim Gilroy (jamesg)     March, 2000

Revision History:

--*/


#ifndef _DNSREGISTRY_INCLUDED_
#define _DNSREGISTRY_INCLUDED_


//
//  Registry keys
//

#define TCPIP_PARAMETERS_KEY        L"System\\CurrentControlSet\\Services\\Tcpip\\Parameters"
#define TCPIP_RAS_KEY               L"System\\CurrentControlSet\\Services\\Tcpip\\Parameters\\Transient"
#define TCPIP_INTERFACES_KEY        L"System\\CurrentControlSet\\Services\\Tcpip\\Parameters\\Interfaces\\"

#define DNS_POLICY_KEY              L"Software\\Policies\\Microsoft\\Windows NT\\DnsClient"
#define DNS_POLICY_WIN2K_KEY        L"Software\\Policies\\Microsoft\\System\\DNSClient"

//#define DNS_POLICY_INTERFACES_KEY   L"Software\\Policies\\Microsoft\\Windows NT\\DNS Client\\Interfaces"
#define POLICY_INTERFACES_SUBKEY    L"Interfaces"

#define DNS_CLIENT_KEY              L"Software\\Microsoft\\Windows NT\\CurrentVersion\\DNSClient"
#define DNS_CACHE_KEY               L"System\\CurrentControlSet\\Services\\DnsCache\\Parameters"
#define DNS_SERVER_KEY              L"System\\CurrentControlSet\\Services\\DNS"

#define NT_SETUP_MODE_KEY           L"System\\Setup"


//
//  Registry values
//
//  note:  _KEY appended on SEARCH_LIST_KEY to avoid conflicting
//      with structure name -- don't remove
//

#define HOST_NAME                                   L"Hostname"
#define DOMAIN_NAME                                 L"Domain"
#define DHCP_DOMAIN_NAME                            L"DhcpDomain"
#define ADAPTER_DOMAIN_NAME                         L"AdapterDomainName"
#define PRIMARY_DOMAIN_NAME                         L"PrimaryDomainName"
#define PRIMARY_SUFFIX                              L"PrimaryDNSSuffix"
#define ALTERNATE_NAMES                             L"AlternateComputerNames"
#define DNS_SERVERS                                 L"NameServer"
#define SEARCH_LIST_KEY                             L"SearchList"
#define UPDATE_ZONE_EXCLUSIONS                      L"UpdateZoneExclusions"

//  Query

#define QUERY_ADAPTER_NAME                          L"QueryAdapterName"
#define USE_DOMAIN_NAME_DEVOLUTION                  L"UseDomainNameDevolution"
#define PRIORITIZE_RECORD_DATA                      L"PrioritizeRecordData"
#define ALLOW_UNQUALIFIED_QUERY                     L"AllowUnqualifiedQuery"
#define APPEND_TO_MULTI_LABEL_NAME                  L"AppendToMultiLabelName"
#define SCREEN_BAD_TLDS                             L"ScreenBadTlds"
#define SCREEN_UNREACHABLE_SERVERS                  L"ScreenUnreachableServers"
#define FILTER_CLUSTER_IP                           L"FilterClusterIp"
#define WAIT_FOR_NAME_ERROR_ON_ALL                  L"WaitForNameErrorOnAll"
#define USE_EDNS                                    L"UseEdns"
#define QUERY_IP_MATCHING                           L"QueryIpMatching"

//  Update

#define REGISTRATION_ENABLED                        L"RegistrationEnabled"
#define REGISTER_PRIMARY_NAME                       L"RegisterPrimaryName"
#define REGISTER_ADAPTER_NAME                       L"RegisterAdapterName"
#define REGISTER_REVERSE_LOOKUP                     L"RegisterReverseLookup"
#define REGISTER_WAN_ADAPTERS                       L"RegisterWanAdapters"
#define REGISTRATION_OVERWRITES_IN_CONFLICT         L"RegistrationOverwritesInConflict"
#define REGISTRATION_TTL                            L"RegistrationTtl"
#define REGISTRATION_REFRESH_INTERVAL               L"RegistrationRefreshInterval"
#define REGISTRATION_MAX_ADDRESS_COUNT              L"RegistrationMaxAddressCount"
#define UPDATE_SECURITY_LEVEL                       L"UpdateSecurityLevel"
#define UPDATE_ZONE_EXCLUDE_FILE                    L"UpdateZoneExcludeFile"
#define UPDATE_TOP_LEVEL_DOMAINS                    L"UpdateTopLevelDomainZones"

//  Backcompat

#define DISABLE_ADAPTER_DOMAIN_NAME                 L"DisableAdapterDomainName"
#define DISABLE_DYNAMIC_UPDATE                      L"DisableDynamicUpdate"
#define ENABLE_ADAPTER_DOMAIN_NAME_REGISTRATION     L"EnableAdapterDomainNameRegistration"
#define DISABLE_REVERSE_ADDRESS_REGISTRATIONS       L"DisableReverseAddressRegistrations"
#define DISABLE_WAN_DYNAMIC_UPDATE                  L"DisableWanDynamicUpdate"
#define ENABLE_WAN_UPDATE_EVENT_LOG                 L"EnableWanDynamicUpdateEventLog"
#define DISABLE_REPLACE_ADDRESSES_IN_CONFLICTS      L"DisableReplaceAddressesInConflicts"
#define DEFAULT_REGISTRATION_TTL                    L"DefaultRegistrationTTL"
#define DEFAULT_REGISTRATION_REFRESH_INTERVAL       L"DefaultRegistrationRefreshInterval"
#define MAX_NUMBER_OF_ADDRESSES_TO_REGISTER         L"MaxNumberOfAddressesToRegister"

//  Micellaneous

#define NT_SETUP_MODE                               L"SystemSetupInProgress"
#define DNS_TEST_MODE                               L"DnsTest"
#define REMOTE_DNS_RESOLVER                         L"RemoteDnsResolver"

//  Cache

#define MAX_CACHE_SIZE                              L"MaxCacheSize"
#define MAX_CACHE_TTL                               L"MaxCacheTtl"
#define MAX_NEGATIVE_CACHE_TTL                      L"MaxNegativeCacheTtl"
#define ADAPTER_TIMEOUT_LIMIT                       L"AdapterTimeoutLimit"
#define SERVER_PRIORITY_TIME_LIMIT                  L"ServerPriorityTimeLimit"
#define MAX_CACHED_SOCKETS                          L"MaxCachedSockets"

#define MULTICAST_LISTEN_LEVEL                      L"MulticastListenLevel"
#define MULTICAST_SEND_LEVEL                        L"MulticastSendLevel"

//  DHCP client registrations

#define DHCP_REGISTERED_HOST_NAME                   L"HostName"
#define DHCP_REGISTERED_DOMAIN_NAME                 L"DomainName"
#define DHCP_SENT_UPDATE_TO_IP                      L"SentUpdateToIp"
#define DHCP_SENT_PRI_UPDATE_TO_IP                  L"SentPriUpdateToIp"
#define DHCP_REGISTERED_TTL                         L"RegisteredTTL"
#define DHCP_REGISTERED_FLAGS                       L"RegisteredFlags"
#define DHCP_REGISTERED_SINCE_BOOT                  L"RegisteredSinceBoot"
#define DHCP_DNS_SERVER_ADDRS                       L"DNSServerAddresses"
#define DHCP_DNS_SERVER_ADDRS_COUNT                 L"DNSServerAddressCount"
#define DHCP_REGISTERED_ADDRS                       L"RegisteredAddresses"
#define DHCP_REGISTERED_ADDRS_COUNT                 L"RegisteredAddressCount"


//
//  ANSI keys and values
//

#if 0
#define STATIC_NAME_SERVER_VALUE_A      "NameServer"
#define PRIMARY_DOMAIN_NAME_A           "PrimaryDomainName"

//  Value

#define USE_DOMAIN_NAME_DEVOLUTION_A    "UseDomainNameDevolution"

//  More

#define DHCP_NAME_SERVER_VALUE_A        "DhcpNameServer"
#define SEARCH_LIST_VALUE_A             "SearchList"
#define DHCP_DOMAIN_NAME_VALUE_A        "DhcpDomain"
#define DOMAIN_NAME_VALUE_A             "Domain"
#define STATIC_DOMAIN_NAME_VALUE_A      "Domain"
#define DHCP_IP_ADDRESS_VALUE_WIN95_A   "DhcpIPAddress"
#define DHCP_INFO_VALUE_A               "DhcpInfo"
#define DHCP_OPTION_INFO_VALUE_A        "OptionInfo"
#endif


//
//  Reg types of keys
//

#define REGTYPE_BIND                        REG_MULTI_SZ
#define REGTYPE_EXPORT                      REG_MULTI_SZ

#define REGTYPE_STATIC_IP_ADDRESS           REG_MULTI_SZ
#define REGTYPE_STATIC_SUBNET_MASK          REG_MULTI_SZ
#define REGTYPE_UPDATE_ZONE_EXCLUSIONS      REG_MULTI_SZ
#define REGTYPE_ALTERNATE_NAMES             REG_MULTI_SZ

#define REGTYPE_DNS_NAME                    REG_SZ
#define REGTYPE_SEARCH_LIST                 REG_SZ
#define REGTYPE_DNS_SERVER                  REG_SZ

#define REGTYPE_DHCP_IP_ADDRESS             REG_SZ
#define REGTYPE_DHCP_SUBNET_MASK            REG_SZ
#define REGTYPE_DHCP_INFO                   REG_BINARY
#define REGTYPE_DHCP_OPTION_INFO            REG_BINARY
#define REGTYPE_DHCP_IP_ADDRESS_WIN95       REG_DWORD




//
//  Registry key dummy ptrs
//
//  Use these when we want to access registry at
//      EITHER adapter name
//      OR one of these default locations
//

#define REGKEY_TCPIP_PARAMETERS     ((PWSTR)(UINT_PTR)(0x1))
#define REGKEY_DNS_CACHE            ((PWSTR)(UINT_PTR)(0x2))
#define REGKEY_DNS_POLICY           ((PWSTR)(UINT_PTR)(0x3))
#define REGKEY_SETUP_MODE_LOCATION  ((PWSTR)(UINT_PTR)(0x4))

#define REGKEY_DNS_MAX              REGKEY_SETUP_MODE_LOCATION


//
//  Registry value IDs
//

typedef enum
{
    //  basic
    RegIdHostName = 0,
    RegIdDomainName,
    RegIdDhcpDomainName,
    RegIdAdapterDomainName,
    RegIdPrimaryDomainName,
    RegIdPrimaryDnsSuffix,
    RegIdAlternateNames,
    RegIdDnsServers,
    RegIdSearchList,
    RegIdUpdateZoneExclusions,

    //  query
    RegIdQueryAdapterName,
    RegIdUseNameDevolution,
    RegIdPrioritizeRecordData,
    RegIdAllowUnqualifiedQuery,
    RegIdAppendToMultiLabelName,
    RegIdScreenBadTlds,
    RegIdScreenUnreachableServers,
    RegIdFilterClusterIp,
    RegIdWaitForNameErrorOnAll,
    RegIdUseEdns,
    RegIdQueryIpMatching,

    //  update
    RegIdRegistrationEnabled,
    RegIdRegisterPrimaryName,
    RegIdRegisterAdapterName,
    RegIdRegisterReverseLookup,
    RegIdRegisterWanAdapters,
    RegIdRegistrationTtl,
    RegIdRegistrationRefreshInterval,
    RegIdRegistrationMaxAddressCount,
    RegIdUpdateSecurityLevel,
    RegIdUpdateZoneExcludeFile,
    RegIdUpdateTopLevelDomains,

    //  backcompat
    RegIdDisableAdapterDomainName,
    RegIdDisableDynamicUpdate,                
    RegIdEnableAdapterDomainNameRegistration, 
    RegIdDisableReverseAddressRegistrations,  
    RegIdDisableWanDynamicUpdate,             
    RegIdEnableWanDynamicUpdateEventLog,      
    RegIdDefaultRegistrationTTL,              
    RegIdDefaultRegistrationRefreshInterval,  
    RegIdMaxNumberOfAddressesToRegister,

    //  micellaneous
    RegIdSetupMode,
    RegIdTestMode,
    RegIdRemoteResolver,

    //  resolver
    RegIdMaxCacheSize,
    RegIdMaxCacheTtl,
    RegIdMaxNegativeCacheTtl,
    RegIdAdapterTimeoutLimit,
    RegIdServerPriorityTimeLimit,
    RegIdMaxCachedSockets,

    //  multicast resolver
    RegIdMulticastListen,
    RegIdMulticastSend,

    //  DHCP registration info
    //
    //  these are not properties to read

    //RegIdDhcpRegisteredHostName,        // use RegIdHostname
    RegIdDhcpRegisteredDomainName,
    RegIdDhcpSentUpdateToIp,
    RegIdDhcpSentPriUpdateToIp,
    RegIdDhcpRegisteredTtl,
    RegIdDhcpRegisteredFlags,
    RegIdDhcpRegisteredSinceBoot,
    RegIdDhcpDnsServerAddresses,
    RegIdDhcpDnsServerAddressCount,
    RegIdDhcpRegisteredAddresses,
    RegIdDhcpRegisteredAddressCount
}
DNS_REGID;

//
//  ID validity mark -- keep in sync
//

#define RegIdValueGlobalMax     RegIdMulticastSend
#define RegIdValueCount         (RegIdValueGlobalMax+1)

#define RegIdMax                RegIdDhcpRegisteredAddressCount

//
//  Duplicates -- lots reads are just for "Domain"
//
//  Note:  can make separate entries for these if the
//      flags need to be different
//

#define RegIdStaticDomainName          RegIdDomainName
#define RegIdRasDomainName             RegIdDomainName


//
//  Default values
//
//  Note, put here as non-fixed default like refresh interval
//  is reset in config.c
//

#define REGDEF_REGISTRATION_TTL                 (1200)      // 20 minutes

#define REGDEF_REGISTRATION_REFRESH_INTERVAL    (86400)     // 1 day
#define REGDEF_REGISTRATION_REFRESH_INTERVAL_DC (86400)     // 1 day

//
//  EDNS values
//

#define REG_EDNS_OFF    (0)
#define REG_EDNS_TRY    (1)
#define REG_EDNS_ALWAYS (2)

//
//  TLD screening values
//      - these are bit flags
//  

#define DNS_TLD_SCREEN_NUMERIC      (0x00000001)
#define DNS_TLD_SCREEN_REPEATED     (0x00000010)
#define DNS_TLD_SCREEN_BAD_MSDC     (0x00000100)

#define DNS_TLD_SCREEN_TOO_LONG     (0x10000000)
#define DNS_TLD_SCREEN_WORKGROUP    (0x00100000)
#define DNS_TLD_SCREEN_DOMAIN       (0x00200000)
#define DNS_TLD_SCREEN_HOME         (0x00400000)
#define DNS_TLD_SCREEN_OFFICE       (0x00800000)
#define DNS_TLD_SCREEN_LOCAL        (0x01000000)

#define DNS_TLD_SCREEN_BOGUS_ALL    (0xfff00000)

#define DNS_TLD_SCREEN_DEFAULT      \
        (   DNS_TLD_SCREEN_NUMERIC   | \
            DNS_TLD_SCREEN_REPEATED  )

//
//  Multicast values
//

#define MCAST_SEND_OFF                  (0)
#define MCAST_SEND_IP4                  (0x00000001)
#define MCAST_SEND_NO_DNS               (0x00000010)
#define MCAST_SEND_INTERFACE_NO_DNS     (0x00000020)
#define MCAST_SEND_NEGATIVE_RESPONSE    (0x00000100)
#define MCAST_SEND_FULL                 (0xffffffff)

#define MCAST_SEND_FULL_IP6_ONLY        (0xfffffff0)


#define MCAST_LISTEN_OFF                (0)
#define MCAST_LISTEN_IP4                (0x00000001)
#define MCAST_LISTEN_NO_DNS             (0x00000010)
#define MCAST_LISTEN_ALWAYS             (0x00000100)
#define MCAST_LISTEN_FULL               (0xffffffff)

#define MCAST_LISTEN_FULL_IP6_ONLY      (0xfffffff0)

//
//  Test mode flags
//

#define TEST_MODE_READ_REG      (0x00000001)
#define TEST_MODE_SOCK_FAIL     (0x00100000)


//
//  Access to registry property table (registry.c)
//

typedef struct _RegProperty
{
    PWSTR       pwsName;
    DWORD       dwDefault;
    BOOLEAN     bPolicy;
    BOOLEAN     bClient;
    BOOLEAN     bTcpip;
    BOOLEAN     bCache;
}
REG_PROPERTY;

extern REG_PROPERTY    RegPropertyTable[];

#define REGPROP_NAME(index)         (RegPropertyTable[index].pwsName)
#define REGPROP_DEFAULT(index)      (RegPropertyTable[index].dwDefault)
#define REGPROP_POLICY(index)       (RegPropertyTable[index].bPolicy)
#define REGPROP_CLIENT(index)       (RegPropertyTable[index].bClient)
#define REGPROP_CACHE(index)        (RegPropertyTable[index].bCache)
#define REGPROP_TCPIP(index)        (RegPropertyTable[index].bTcpip)




//
//  Config globals as structure for RPC 
//

typedef struct _DnsGlobals
{
    DWORD       ConfigCookie;
    DWORD       TimeStamp;

    BOOL        InResolver;
    BOOL        IsWin2000;                       
    BOOL        IsWorkstation;                   
    BOOL        IsServer;                        
    BOOL        IsDnsServer;                     
    BOOL        IsDomainController;              
    BOOL        InNTSetupMode;                   
    DWORD       DnsTestMode;
                                                 
    BOOL        QueryAdapterName;                
    BOOL        UseNameDevolution;               
    BOOL        PrioritizeRecordData;            
    BOOL        AllowUnqualifiedQuery;           
    BOOL        AppendToMultiLabelName;
    BOOL        ScreenBadTlds;
    BOOL        ScreenUnreachableServers;
    BOOL        FilterClusterIp;
    BOOL        WaitForNameErrorOnAll;
    DWORD       UseEdns;
    BOOL        QueryIpMatching;
                                                 
    BOOL        RegistrationEnabled;             
    BOOL        RegisterPrimaryName;             
    BOOL        RegisterAdapterName;             
    BOOL        RegisterReverseLookup;           
    BOOL        RegisterWanAdapters;             
    BOOL        RegistrationOverwritesInConflict;
    DWORD       RegistrationMaxAddressCount;     
    DWORD       RegistrationTtl;                 
    DWORD       RegistrationRefreshInterval;     
    DWORD       UpdateSecurityLevel;             
    BOOL        UpdateZoneExcludeFile;           
    BOOL        UpdateTopLevelDomains;

    //
    //  Cache stuff
    //
    //  Not needed unless switch to this for actual registry read,
    //  but convient to just export one global rather than several.
    //  This way it's all the same.
    //

    DWORD       MaxCacheSize;                    
    DWORD       MaxCacheTtl;                     
    DWORD       MaxNegativeCacheTtl;             
    DWORD       AdapterTimeoutLimit;             
    DWORD       ServerPriorityTimeLimit;
    DWORD       MaxCachedSockets;
    DWORD       MulticastListenLevel;
    DWORD       MulticastSendLevel;

}
DNS_GLOBALS_BLOB, *PDNS_GLOBALS_BLOB;


//
//  no MIDL pass on rest of file
//
//  This file is included in MIDL pass for resolver
//  in order to pick up the DNS_GLOBALS_BLOB defintion
//  on the theory that it is better to have it right
//  here with the other registry config.  But all the
//  function definitions and other struct defs are
//  of no interest during the pass.
//

#ifndef MIDL_PASS



//
//  Config globals -- macros for globals
//
//  There are two basic approaches here:
//
//  1) Single config blob -- but no fixed memory.
//  All callers must drop down blob to receive config blob.
//  Note, that this still requires macros for each individual global
//  but the form can be the same inside and outside the dll, and
//  nothing need be exported.
//  
//  2) Create a single config blob and export that.
//  Individual globals then become macros into the blob.  Still the
//  form of the macro will be different inside and outside the
//  dll.
//
//  3) Use macros to expose each individual global.
//  Form of macro will be different inside versus outside the dll.
//  Advantage here is that globals are preserved and available for
//  symbolic debugging.
//


#ifdef DNSAPI_INTERNAL

//
//  Internal to dnsapi.dll
//
    
extern  DNS_GLOBALS_BLOB    DnsGlobals;
    
#else
    
//
//  External to dnsapi.dll
//
    
__declspec(dllimport)   DNS_GLOBALS_BLOB    DnsGlobals;

#endif

//
//  Macros to globals
//

#define g_ConfigCookie                      (DnsGlobals.ConfigCookie)
#define g_InResolver                        (DnsGlobals.InResolver)
#define g_IsWin2000                         (DnsGlobals.IsWin2000)                        
#define g_IsWin9X                           (DnsGlobals.IsWin9X)                          
#define g_IsNT4                             (DnsGlobals.IsNT4)                            
#define g_IsWorkstation                     (DnsGlobals.IsWorkstation)                    
#define g_IsServer                          (DnsGlobals.IsServer)                         
#define g_IsDnsServer                       (DnsGlobals.IsDnsServer)                      
#define g_IsDomainController                (DnsGlobals.IsDomainController)               
#define g_InNTSetupMode                     (DnsGlobals.InNTSetupMode)                    
#define g_DnsTestMode                       (DnsGlobals.DnsTestMode)                    
#define g_QueryAdapterName                  (DnsGlobals.QueryAdapterName)                 
#define g_UseNameDevolution                 (DnsGlobals.UseNameDevolution)                
#define g_PrioritizeRecordData              (DnsGlobals.PrioritizeRecordData)             
#define g_AllowUnqualifiedQuery             (DnsGlobals.AllowUnqualifiedQuery)            
#define g_AppendToMultiLabelName            (DnsGlobals.AppendToMultiLabelName)           
#define g_ScreenBadTlds                     (DnsGlobals.ScreenBadTlds)
#define g_ScreenUnreachableServers          (DnsGlobals.ScreenUnreachableServers)
#define g_FilterClusterIp                   (DnsGlobals.FilterClusterIp)           
#define g_WaitForNameErrorOnAll             (DnsGlobals.WaitForNameErrorOnAll)           
#define g_UseEdns                           (DnsGlobals.UseEdns)                          
#define g_QueryIpMatching                   (DnsGlobals.QueryIpMatching)                          
#define g_RegistrationEnabled               (DnsGlobals.RegistrationEnabled)              
#define g_RegisterPrimaryName               (DnsGlobals.RegisterPrimaryName)              
#define g_RegisterAdapterName               (DnsGlobals.RegisterAdapterName)              
#define g_RegisterReverseLookup             (DnsGlobals.RegisterReverseLookup)            
#define g_RegisterWanAdapters               (DnsGlobals.RegisterWanAdapters)              
#define g_RegistrationOverwritesInConflict  (DnsGlobals.RegistrationOverwritesInConflict) 
#define g_RegistrationMaxAddressCount       (DnsGlobals.RegistrationMaxAddressCount)      
#define g_RegistrationTtl                   (DnsGlobals.RegistrationTtl)                  
#define g_RegistrationRefreshInterval       (DnsGlobals.RegistrationRefreshInterval)      
#define g_UpdateSecurityLevel               (DnsGlobals.UpdateSecurityLevel)              
#define g_UpdateZoneExcludeFile             (DnsGlobals.UpdateZoneExcludeFile)            
#define g_UpdateTopLevelDomains             (DnsGlobals.UpdateTopLevelDomains)
#define g_MaxCacheSize                      (DnsGlobals.MaxCacheSize)                     
#define g_MaxCacheTtl                       (DnsGlobals.MaxCacheTtl)                      
#define g_MaxNegativeCacheTtl               (DnsGlobals.MaxNegativeCacheTtl)              
#define g_AdapterTimeoutLimit               (DnsGlobals.AdapterTimeoutLimit)              
#define g_ServerPriorityTimeLimit           (DnsGlobals.ServerPriorityTimeLimit)          
#define g_MaxCachedSockets                  (DnsGlobals.MaxCachedSockets)                     
#define g_MulticastListenLevel              (DnsGlobals.MulticastListenLevel)                     
#define g_MulticastSendLevel                (DnsGlobals.MulticastSendLevel)                     


//
//  Non-exported config globals
//

extern PWSTR    g_pwsRemoteResolver;


//
//  Registry call flags
//

#define DNSREG_FLAG_GET_UTF8        (0x0001)    // return string in UTF8
#define DNSREG_FLAG_DUMP_EMPTY      (0x0010)    // dump empty data\strings -- return NULL


//
//  Registry Session
//

typedef struct _RegSession
{
    HKEY        hPolicy;
    HKEY        hClient;
    HKEY        hTcpip;
    HKEY        hCache;
}
REG_SESSION, *PREG_SESSION;



//
//  Policy adapter info read
//
//  DCR:  might be better to just include in config and
//      bring the whole baby across
//
//  DCR:  get to global\per adapter reads with reg_blob
//      then build global blob (flat) and network info(allocated)
//
//  DCR:  exposed config info should provide levels
//          - all
//          - adapter info (given domain name)
//          - global info
//

typedef struct _RegGlobalInfo
{
    //  Global data

    PWSTR       pszPrimaryDomainName;
    PWSTR       pszHostName;

    //  Global flags needed to build network info

    BOOL        fUseNameDevolution;

    //  Adapter policy overrides

    PIP4_ARRAY  pDnsServerArray;
    PVOID       pDnsServerIp6Array;
    PWSTR       pszAdapterDomainName;
    BOOL        fRegisterAdapterName;

    //  Read\not-read from policy

    BOOL        fPolicyRegisterAdapterName;

    //  DCR:  DWORD blob read here
}
REG_GLOBAL_INFO, *PREG_GLOBAL_INFO;


//
//  Registry adapter info read
//

typedef struct _RegAdapterInfo
{
    PWSTR       pszAdapterDomainName;
    BOOL        fQueryAdapterName;
    BOOL        fRegistrationEnabled;
    BOOL        fRegisterAdapterName;
    DWORD       RegistrationMaxAddressCount;
}
REG_ADAPTER_INFO, *PREG_ADAPTER_INFO;  


//
//  Registry update info
//
//  DCR:  should be able to get from global read
//

typedef struct _RegUpdateInfo
{
    PWSTR       pszPrimaryDomainName;
    PWSTR       pmszAlternateNames;

    //  policy overrides

    PWSTR       pszAdapterDomainName;
    PIP4_ARRAY  pDnsServerArray;
    PVOID       pDnsServerIp6Array;

    //  update flags (policy, global or adapter)

    BOOL        fRegistrationEnabled;
    BOOL        fRegisterAdapterName;
    DWORD       RegistrationMaxAddressCount;
}
REG_UPDATE_INFO, *PREG_UPDATE_INFO;  


//
//  Registry routines
//

VOID
Reg_Init(
    VOID
    );


//
//  Query routines
//

DNS_STATUS
WINAPI
Reg_OpenSession(
    OUT     PREG_SESSION    pRegSession,
    IN      DWORD           Level,
    IN      DWORD           ValueId
    );

VOID
WINAPI
Reg_CloseSession(
    IN OUT  PREG_SESSION    pRegSession
    );

DNS_STATUS
Reg_GetDword(
    IN      PREG_SESSION    pRegSession,    OPTIONAL
    IN      HKEY            hRegKey,        OPTIONAL
    IN      PWSTR           pwsKeyName,     OPTIONAL
    IN      DWORD           ValueId,
    OUT     PDWORD          pResult
    );

DNS_STATUS
Reg_GetValueEx(
    IN      PREG_SESSION    pRegSession,    OPTIONAL
    IN      HKEY            hRegKey,        OPTIONAL
    IN      PWSTR           pwsAdapter,     OPTIONAL
    IN      DWORD           ValueId,
    IN      DWORD           ValueType,
    IN      DWORD           Flag,
    OUT     PBYTE *         ppBuffer
    );

#define Reg_GetValue(s, k, id, t, pb ) \
        Reg_GetValueEx(s, k, NULL, id, t, 0, pb )

DNS_STATUS
Reg_GetIpArray(
    IN      PREG_SESSION    pRegSession,    OPTIONAL
    IN      HKEY            hRegKey,        OPTIONAL
    IN      PWSTR           pwsAdapter,     OPTIONAL
    IN      DWORD           ValueId,
    IN      DWORD           ValueType,
    OUT     PIP4_ARRAY *    ppIpArray
    );

//
//  Set routines
//

HKEY
WINAPI
Reg_CreateKey(
    IN      PWSTR           pwsKeyName,
    IN      BOOL            bWrite
    );

DNS_STATUS
WINAPI
Reg_SetDwordValueByName(
    IN      PVOID           pReserved,
    IN      HKEY            hKey,
    IN      PWSTR           pwsNameKey,     OPTIONAL
    IN      PWSTR           pwsNameValue,   OPTIONAL
    IN      DWORD           dwValue
    );

DNS_STATUS
WINAPI
Reg_SetDwordValue(
    IN      PVOID           pReserved,
    IN      HKEY            hRegKey,
    IN      PWSTR           pwsNameKey,     OPTIONAL
    IN      DWORD           ValueId,
    IN      DWORD           dwValue
    );

//
//  Special type routines (regfig.c)
//

DNS_STATUS
Reg_ReadPrimaryDomainName(
    IN      PREG_SESSION    pRegSession,    OPTIONAL
    IN      HKEY            hRegKey,        OPTIONAL
    OUT     PWSTR *         ppPrimaryDomainName
    );

BOOL
Reg_IsMicrosoftDnsServer(
    VOID
    );

DNS_STATUS
Reg_WriteLoopbackDnsServerList(
    IN      PWSTR           pszAdapterName,
    IN      PREG_SESSION    pRegSession
    );

//
//  Main reg config read (config.c)
//

DNS_STATUS
Reg_ReadGlobalsEx(
    IN      DWORD           dwFlag,
    IN      PVOID           pRegSession
    );

//
//  DNS Config info access (regfig.c)
//

DNS_STATUS
Reg_ReadGlobalInfo(
    IN      PREG_SESSION        pRegSession,
    OUT     PREG_GLOBAL_INFO    pRegInfo
    );

VOID
Reg_FreeGlobalInfo(
    IN OUT  PREG_GLOBAL_INFO    pRegInfo,
    IN      BOOL                fFreeBlob
    );

DNS_STATUS
Reg_ReadAdapterInfo(
    IN      PWSTR               pszAdapterName,
    IN      PREG_SESSION        pRegSession,
    IN      PREG_GLOBAL_INFO    pRegInfo,
    OUT     PREG_ADAPTER_INFO   pBlob
    );

DNS_STATUS
Reg_ReadAdapterInfoA(
    IN      PSTR                    pszAdapterName,
    IN      PREG_SESSION            pRegSession,
    IN      PREG_GLOBAL_INFO        pRegInfo,
    OUT     PREG_ADAPTER_INFO       pBlob
    );

VOID
Reg_FreeAdapterInfo(
    IN OUT  PREG_ADAPTER_INFO   pRegAdapterInfo,
    IN      BOOL                fFreeBlob
    );

DNS_STATUS
Reg_ReadUpdateInfo(
    IN      PWSTR               pszAdapterName,
    OUT     PREG_UPDATE_INFO    pUpdateInfo
    );

VOID
Reg_FreeUpdateInfo(
    IN OUT  PREG_UPDATE_INFO    pUpdateInfo,
    IN      BOOL                fFreeBlob
    );

//
//  Insure fressh update config (regfig.c)
//

DNS_STATUS
Reg_RefreshUpdateConfig(
    VOID
    );


//
//  Simplified special type access
//

PSTR 
WINAPI
Reg_GetPrimaryDomainName(
    IN      DNS_CHARSET     CharSet
    );

PSTR 
WINAPI
Reg_GetHostName(
    IN      DNS_CHARSET     CharSet
    );

PSTR 
WINAPI
Reg_GetFullHostName(
    IN      DNS_CHARSET     CharSet
    );


//
//  Simple reg DWORD access
//

DWORD
Reg_ReadDwordProperty(
    IN      DNS_REGID       RegId,
    IN      PWSTR           pwsAdapterName  OPTIONAL
    );

DNS_STATUS
WINAPI
Reg_SetDwordPropertyAndAlertCache(
    IN      PWSTR           pwsKey,
    IN      DWORD           RegId,
    IN      DWORD           dwValue
    );

#endif  // no MIDL_PASS

#endif  _DNSREGISTRY_INCLUDED_

//
//  End registry.h
//
=== C:/Users/treeman/Desktop/windows nt source code\Source\Win2K3\NT\ds\dns\dnsapi\socket.c ===
/*++

Copyright (c) 1996-2000  Microsoft Corporation

Module Name:

    socket.c

Abstract:

    Domain Name System (DNS) API

    Socket setup.

Author:

    Jim Gilroy (jamesg)     October, 1996

Revision History:

--*/


#include "local.h"


//
//  Winsock startup
//

LONG        g_WinsockStartCount = 0;


//
//  Async i/o
//
//  If want async socket i/o then can create single async socket, with
//  corresponding event and always use it.  Requires winsock 2.2
//

SOCKET      DnsSocket = 0;

OVERLAPPED  DnsSocketOverlapped;
HANDLE      hDnsSocketEvent = NULL;

//
//  App shutdown flag
//

BOOLEAN     fApplicationShutdown = FALSE;




DNS_STATUS
Socket_InitWinsock(
    VOID
    )
/*++

Routine Description:

    Initialize winsock for this process.

    Currently, assuming process must do WSAStartup() before
    calling any dnsapi.dll entry point.

    EXPORTED (resolver)

Arguments:

    None

Return Value:

    ERROR_SUCCESS if successful.
    ErrorCode on failure.

--*/
{
    DNSDBG( SOCKET, ( "Socket_InitWinsock()\n" ));

    //
    //  start winsock, if not already started
    //

    if ( g_WinsockStartCount == 0 )
    {
        DNS_STATUS  status;
        WSADATA     wsaData;


        DNSDBG( TRACE, (
            "InitWinsock() version %x\n",
            DNS_WINSOCK_VERSION ));

        status = WSAStartup( DNS_WINSOCK_VERSION, &wsaData );
        if ( status != ERROR_SUCCESS )
        {
            DNS_PRINT(( "ERROR:  WSAStartup failure %d.\n", status ));
            return( status );
        }

        DNSDBG( TRACE, (
            "Winsock initialized => wHighVersion=0x%x, wVersion=0x%x\n",
            wsaData.wHighVersion,
            wsaData.wVersion ));

        InterlockedIncrement( &g_WinsockStartCount );
    }
    return( ERROR_SUCCESS );
}



VOID
Socket_CleanupWinsock(
    VOID
    )
/*++

Routine Description:

    Cleanup winsock if it was initialized by dnsapi.dll

    EXPORTED (resolver)

Arguments:

    None.

Return Value:

    None.

--*/
{
    DNSDBG( SOCKET, ( "Socket_CleanupWinsock()\n" ));

    //
    //  WSACleanup() for value of ref count
    //      - ref count pushed down to one below real value, but
    //      fixed up at end
    //      - note:  the GUI_MODE_SETUP_WS_CLEANUP deal means that
    //      we can be called other than process detach, making
    //      interlock necessary
    //      

    while ( InterlockedDecrement( &g_WinsockStartCount ) >= 0 )
    {
        WSACleanup();
    }

    InterlockedIncrement( &g_WinsockStartCount );
}



SOCKET
Socket_Create(
    IN      INT             Family,
    IN      INT             SockType,
    IN      PDNS_ADDR       pBindAddr,      OPTIONAL
    IN      USHORT          Port,
    IN      DWORD           dwFlags
    )
/*++

Routine Description:

    Create socket.

    EXPORTED function (resolver)

Arguments:

    Family -- socket family AF_INET or AF_INET6

    SockType -- SOCK_DGRAM or SOCK_STREAM

    pBindAddr -- addr to bind to

    Port -- desired port in net order
                - NET_ORDER_DNS_PORT for DNS listen sockets
                - 0 for any port

    dwFlags -- specify the attributes of the sockets

Return Value:

    Socket if successful.
    Otherwise zero.

--*/
{
    SOCKET          s;
    INT             err;
    INT             val;
    DNS_STATUS      status;
    BOOL            fretry = FALSE;

    DNSDBG( SOCKET, (
        "Socket_Create( fam=%d, type=%d, addr=%p, port=%d, flag=%08x )\n",
        Family,
        SockType,
        pBindAddr,
        Port,
        dwFlags ));

    //
    //  create socket
    //      - try again if winsock not initialized

    while( 1 )
    {
        s = WSASocket(
                Family,
                SockType,
                0,
                NULL,
                0, 
                dwFlags );
     
        if ( s != INVALID_SOCKET )
        {
            break;
        }

        status = GetLastError();

        DNSDBG( SOCKET, (
            "ERROR:  Failed to open socket of type %d.\n"
            "\terror = %d.\n",
            SockType,
            status ));

        if ( status != WSANOTINITIALISED || fretry )
        {
            SetLastError( DNS_ERROR_NO_TCPIP );
            return  0;
        }

        //
        //  initialize Winsock if not already started
        //
        //  note:  do NOT automatically initialize winsock
        //      init jacks ref count and will break applications
        //      which use WSACleanup to close outstanding sockets;
        //      we'll init only when the choice is that or no service;
        //      apps can still cleanup with WSACleanup() called
        //      in loop until WSANOTINITIALISED failure
        //

        fretry = TRUE;
        status = Socket_InitWinsock();
        if ( status != NO_ERROR )
        {
            SetLastError( DNS_ERROR_NO_TCPIP );
            return  0;
        }
    }

    //
    //  bind socket
    //      - only if specific port given, this keeps remote winsock
    //      from grabbing it if we are on the local net
    //

    if ( pBindAddr || Port )
    {
        SOCKADDR_IN6    sockaddr;
        INT             sockaddrLength;

        if ( !pBindAddr )
        {
            RtlZeroMemory(
                &sockaddr,
                sizeof(sockaddr) );

            ((PSOCKADDR)&sockaddr)->sa_family = (USHORT)Family;

            sockaddrLength = sizeof(SOCKADDR_IN);
            if ( Family == AF_INET6 )
            {
                sockaddrLength = sizeof(SOCKADDR_IN6);
            }
        }
        else
        {
            sockaddrLength = DnsAddr_WriteSockaddr(
                                (PSOCKADDR) &sockaddr,
                                sizeof( sockaddr ),
                                pBindAddr );

            DNS_ASSERT( Family == (INT)((PSOCKADDR)&sockaddr)->sa_family );
        }

        //
        //  bind port
        //      - set in sockaddr
        //      (note it's in the same place for either protocol)
        //

        if ( Port > 0 )
        {
            sockaddr.sin6_port = Port;
        }

        //
        //  bind -- try exclusive first, then fail to non-exclusive
        //

        val = 1;
        setsockopt(
            s,
            SOL_SOCKET,
            SO_EXCLUSIVEADDRUSE,
            (const char *)&val,
            sizeof(val) );

        do
        {
            err = bind(
                    s,
                    (PSOCKADDR) &sockaddr,
                    sockaddrLength );
    
            if ( err == 0 )
            {
                goto Done;
            }

            DNSDBG( SOCKET, (
                "Failed to bind() socket %d, (fam=%d) to port %d, address %s.\n"
                "\terror = %d.\n",
                s,
                Family,
                ntohs(Port),
                DNSADDR_STRING( pBindAddr ),
                GetLastError() ));
    
            //
            //  retry with REUSEADDR
            //      - if port and exclusive
            //      - otherwise we're done
    
            if ( val == 0 || Port == 0 )
            {
                closesocket( s );
                SetLastError( DNS_ERROR_NO_TCPIP );
                return  0;
            }

            val = 0;
            setsockopt(
                s,
                SOL_SOCKET,
                SO_EXCLUSIVEADDRUSE,
                (const char *)&val,
                sizeof(val) );

            val = 1;
            setsockopt(
                s,
                SOL_SOCKET,
                SO_REUSEADDR,
                (const char *)&val,
                sizeof(val) );

            val = 0;
            continue;
        }
        while ( 1 );
    }

Done:

    DNSDBG( SOCKET, (
        "Created socket %d, family %d, type %d, address %s, port %d.\n",
        s,
        Family,
        SockType,
        DNSADDR_STRING( pBindAddr ),
        ntohs(Port) ));

    return s;
}



SOCKET
Socket_CreateMulticast(
    IN      INT             SockType,
    IN      PDNS_ADDR       pAddr,
    IN      WORD            Port,
    IN      BOOL            fSend,
    IN      BOOL            fReceive
    )
/*++

Routine Description:

    Create socket and join it to the multicast DNS address.

Arguments:

    pAddr -- binding address

    SockType -- SOCK_DGRAM or SOCK_STREAM

    Port -- port to use;  note, if zero, port in pAddr still used by Socket_Create()

Return Value:

    Socket if successful.
    Zero on error.

--*/
{
    DWORD       byteCount;
    BOOL        bflag;
    SOCKET      s;
    SOCKET      sjoined;
    INT         err;


    DNSDBG( SOCKET, (
        "Socket_CreateMulticast( %d, %p, %d, %d, %d )\n",
        SockType,
        pAddr,
        Port,
        fSend,
        fReceive ));

    s = Socket_Create(
            pAddr->Sockaddr.sa_family,
            SockType,
            pAddr,
            Port,
            WSA_FLAG_MULTIPOINT_C_LEAF |
                WSA_FLAG_MULTIPOINT_D_LEAF |
                WSA_FLAG_OVERLAPPED );

    if ( s == 0 )
    {
        return 0;
    }

    //  set loopback

    bflag = TRUE;

    err = WSAIoctl(
            s,
            SIO_MULTIPOINT_LOOPBACK,    // loopback iotcl
            & bflag,                    // turn on
            sizeof(bflag),
            NULL,                       // no output
            0,                          // no output size
            &byteCount,                 // bytes returned
            NULL,                       // no overlapped
            NULL                        // no completion routine
            );

    if ( err == SOCKET_ERROR )
    {
        DNSDBG( ANY, (
            "Unable to turn multicast loopback on for socket %d; error = %d.\n",
            s,
            GetLastError()
            ));
    }

    //
    //  join socket to multicast group
    //

    sjoined = WSAJoinLeaf(
                s,
                (PSOCKADDR) pAddr,
                pAddr->SockaddrLength,
                NULL,                                   // caller data buffer
                NULL,                                   // callee data buffer
                NULL,                                   // socket QOS setting
                NULL,                                   // socket group QOS
                ((fSend && fReceive) ? JL_BOTH :        // send and/or receive
                    (fSend ? JL_SENDER_ONLY : JL_RECEIVER_ONLY))
                );
            
    if ( sjoined == INVALID_SOCKET )
    {
        DNSDBG( ANY, (
           "Unable to join socket %d to multicast address, error = %d.\n",
           s,
           GetLastError() ));

        Socket_Close( s );
        sjoined = 0;
    }
    
    return sjoined;
}



VOID
Socket_CloseEx(
    IN      SOCKET          Socket,
    IN      BOOL            fShutdown
    )
/*++

Routine Description:

    Close DNS socket.

Arguments:

    Socket -- socket to close

    fShutdown -- do a shutdown first

Return Value:

    None.

--*/
{
    if ( Socket == 0 || Socket == INVALID_SOCKET )
    {
        DNS_PRINT(( "WARNING:  Socket_Close() called on invalid socket %d.\n", Socket ));
        return;
    }

    if ( fShutdown )
    {
        shutdown( Socket, 2 );
    }

    DNSDBG( SOCKET, (
        "%sclosesocket( %d )\n",
        fShutdown ? "shutdown and " : "",
        Socket ));

    closesocket( Socket );
}



#if 0
//
//  Global async socket routines
//

DNS_STATUS
Socket_SetupGlobalAsyncSocket(
    VOID
    )
/*++

Routine Description:

    Create global async UDP socket.

Arguments:

    SockType -- SOCK_DGRAM or SOCK_STREAM

    IpAddress -- IP address to listen on (net byte order)

    Port -- desired port in net order
                - NET_ORDER_DNS_PORT for DNS listen sockets
                - 0 for any port

Return Value:

    socket if successful.
    Otherwise INVALID_SOCKET.

--*/
{
    DNS_STATUS  status;
    INT         err;
    SOCKADDR_IN sockaddrIn;

    //
    //  start winsock, need winsock 2 for async
    //

    if ( ! fWinsockStarted )
    {
        WSADATA wsaData;

        status = WSAStartup( DNS_WINSOCK_VERSION, &wsaData );
        if ( status != ERROR_SUCCESS )
        {
            DNS_PRINT(( "ERROR:  WSAStartup failure %d.\n", status ));
            return( status );
        }
        if ( wsaData.wVersion != DNS_WINSOCK2_VERSION )
        {
            WSACleanup();
            return( WSAVERNOTSUPPORTED );
        }
        fWinsockStarted = TRUE;
    }

    //
    //  setup socket
    //      - overlapped i\o with event so can run asynchronously in
    //      this thread and wait with queuing event
    //

    DnsSocket = WSASocket(
                    AF_INET,
                    SOCK_DGRAM,
                    0,
                    NULL,
                    0,
                    WSA_FLAG_OVERLAPPED );
    if ( DnsSocket == INVALID_SOCKET )
    {
        status = GetLastError();
        DNS_PRINT(( "\nERROR:  Async socket create failed.\n" ));
        goto Error;
    }

    //
    //  bind socket
    //

    RtlZeroMemory( &sockaddrIn, sizeof(sockaddrIn) );
    sockaddrIn.sin_family = AF_INET;
    sockaddrIn.sin_port = 0;
    sockaddrIn.sin_addr.s_addr = INADDR_ANY;

    err = bind( DnsSocket, (PSOCKADDR)&sockaddrIn, sizeof(sockaddrIn) );
    if ( err == SOCKET_ERROR )
    {
        status = GetLastError();
        DNSDBG( SOCKET, (
            "Failed to bind() DnsSocket %d.\n"
            "\terror = %d.\n",
            DnsSocket,
            status ));
        goto Error;
    }

    //
    //  create event to signal on async i/o completion
    //

    hDnsSocketEvent = CreateEvent(
                        NULL,       // Security Attributes
                        TRUE,       // create Manual-Reset event
                        FALSE,      // start unsignalled -- paused
                        NULL        // event name
                        );
    if ( !hDnsSocketEvent )
    {
        status = GetLastError();
        DNS_PRINT(( "Failed event creation\n" ));
        goto Error;
    }
    DnsSocketOverlapped.hEvent = hDnsSocketEvent;

    DNSDBG( SOCKET, (
        "Created global async UDP socket %d.\n"
        "\toverlapped at %p\n"
        "\tevent handle %p\n",
        DnsSocket,
        DnsSocketOverlapped,
        hDnsSocketEvent ));

    return ERROR_SUCCESS;

Error:

    DNS_PRINT((
        "ERROR:  Failed async socket creation, status = %d\n",
        status ));
    closesocket( DnsSocket );
    DnsSocket = INVALID_SOCKET;
    WSACleanup();
    return( status );
}

#endif




//
//  Socket caching
//
//  Doing limited caching of UDP unbound sockets used for standard
//  DNS lookups in resolver.  This allows us to prevent denial of
//  service attack by using up all ports on the machine.
//  Resolver is the main customer for this, but we'll code it to
//  be useable by any process.
//
//  Implementation notes:
//
//  There are a couple specific goals to this implementation:
//      - Minimal code impact;  Try NOT to change the resolver
//      code.
//      - Usage driven caching;  Don't want to create on startup
//      "cache sockets" that we don't use;  Instead have actual usage
//      drive up the cached socket count.
//
//  There are several approaches here.
//
//      1) explicit resolver cache -- passed down sockets
//      
//      2) add caching seamlessly into socket open and close
//      this was my first choice, but the problem here is that on
//      close we must either do additional calls to winsock to determine
//      whether cachable (UDP-unbound) socket OR cache must include some
//      sort of "in-use" tag and we trust that socket is never closed
//      outside of path (otherwise handle reuse could mess us up)
//
//      3) new UDP-unbound open\close function
//      this essentially puts the "i-know-i'm-using-UDP-unbound-sockets"
//      burden on the caller who must switch to this new API;
//      fortunately this meshes well with our "SendAndRecvUdp()" function;
//      this approach still allows a caller driven ramp up we desire,
//      so i'm using this approach
//
//  DCR:  FIX6:  no cached UDP IP6 sockets
//

//
//  Keep array of sockets
//
//  Dev note:  the Array and MaxCount MUST be kept in sync, no
//  independent check of array is done, it is assumed to exist when
//  MaxCount is non-zero, so they MUST be in sync when lock released
//

SOCKET *    g_pCacheSocketArray = NULL;

DWORD       g_CacheSocketMaxCount = 0;
DWORD       g_CacheSocketCount = 0;


//  Hard limit on what we'll allow folks to keep awake

#define MAX_SOCKET_CACHE_LIMIT  (100)


//  Lock access with generic lock
//  This is very short\fast CS, contention will be minimal

#define LOCK_SOCKET_CACHE()     LOCK_GENERAL()
#define UNLOCK_SOCKET_CACHE()   UNLOCK_GENERAL()



DNS_STATUS
Socket_CacheInit(
    IN      DWORD           MaxSocketCount
    )
/*++

Routine Description:

    Initialize socket caching.

    EXPORTED (resolver):  Socket_CacheInit() 

Arguments:

    MaxSocketCount -- max count of sockets to cache

Return Value:

    ERROR_SUCCESS if successful.
    DNS_ERROR_NO_MEMORY on alloc failure.
    ERROR_INVALID_PARAMETER if already initialized or bogus count.

--*/
{
    SOCKET *    parray;
    DNS_STATUS  status = NO_ERROR;

    DNSDBG( SOCKET, ( "Dns_CacheSocketInit()\n" ));

    //
    //  validity check
    //      - note, one byte of the apple, we don't let you raise
    //      count, though we later could;  i see this as at most a
    //      "configure for machine use" kind of deal
    //

    LOCK_SOCKET_CACHE();

    if ( MaxSocketCount == 0 || g_CacheSocketMaxCount != 0 )
    {
        status = ERROR_INVALID_PARAMETER;
        goto Done;
    }

    //
    //  allocate
    //

    if ( MaxSocketCount > MAX_SOCKET_CACHE_LIMIT )
    {
        MaxSocketCount = MAX_SOCKET_CACHE_LIMIT;
    }

    parray = (SOCKET *) ALLOCATE_HEAP_ZERO( sizeof(SOCKET) * MaxSocketCount );
    if ( !parray )
    {
        status = DNS_ERROR_NO_MEMORY;
        goto Done;
    }

    //  set globals

    g_pCacheSocketArray     = parray;
    g_CacheSocketMaxCount   = MaxSocketCount;
    g_CacheSocketCount      = 0;

Done:

    UNLOCK_SOCKET_CACHE();

    return  status;
}



VOID
Socket_CacheCleanup(
    VOID
    )
/*++

Routine Description:

    Cleanup socket caching.

    EXPORTED (resolver):  Socket_CacheCleanup()

Arguments:

    None

Return Value:

    None

--*/
{
    DWORD   i;
    SOCKET  sock;

    DNSDBG( SOCKET, ( "Dns_CacheSocketCleanup()\n" ));

    //
    //  close cached sockets
    //

    LOCK_SOCKET_CACHE();

    for ( i=0;  i<g_CacheSocketMaxCount;  i++ )
    {
        sock = g_pCacheSocketArray[i];
        if ( sock )
        {
            Socket_Close( sock );
            g_CacheSocketCount--;
        }
    }

    DNS_ASSERT( g_CacheSocketCount == 0 );

    //  dump socket array memory

    FREE_HEAP( g_pCacheSocketArray );

    //  clear globals

    g_pCacheSocketArray     = NULL;
    g_CacheSocketMaxCount   = 0;
    g_CacheSocketCount      = 0;

    UNLOCK_SOCKET_CACHE();
}



SOCKET
Socket_GetUdp(
    IN      INT             Family
    )
/*++

Routine Description:

    Get a cached socket.

Arguments:

    Family -- address family

Return Value:

    Socket handle if successful.
    Zero if no cached socket available.

--*/
{
    SOCKET  sock;
    DWORD   i;

    //
    //  quick return if nothing available
    //      - do outside lock so function can be called cheaply
    //      without other checks
    //

    if ( g_CacheSocketCount == 0 )
    {
        goto Open;
    }

    //
    //  get a cached socket
    //

    LOCK_SOCKET_CACHE();

    for ( i=0;  i<g_CacheSocketMaxCount;  i++ )
    {
        sock = g_pCacheSocketArray[i];
        if ( sock != 0 )
        {
            g_pCacheSocketArray[i] = 0;
            g_CacheSocketCount--;
            UNLOCK_SOCKET_CACHE();

            //
            //  DCR:  clean out any data on cached socket
            //      it would be cool to cheaply dump useless data
            //
            //  right now we just let XID match, then question match
            //  dump data on recv
            //

            DNSDBG( SOCKET, (
                "Returning cached socket %d.\n",
                sock ));
            return  sock;
        }
    }

    UNLOCK_SOCKET_CACHE();

Open:

    //
    //  not found in list -- create
    //      - set exclusive
    //

    sock = Socket_Create(
                Family,
                SOCK_DGRAM,
                NULL,       // ANY addr binding
                0,          // ANY port binding
                0           // no special flags
                );

    if ( sock )
    {
        INT val = 1;

        setsockopt(
            sock,
            SOL_SOCKET,
            SO_EXCLUSIVEADDRUSE,
            (const char *)&val,
            sizeof(val) );
    }

    return  sock;
}



VOID
Socket_ReturnUdp(
    IN      SOCKET          Socket,
    IN      INT             Family
    )
/*++

Routine Description:

    Return UDP socket for possible caching.

Arguments:

    Socket -- socket handle

    Family -- family of socket

Return Value:

    None

--*/
{
    SOCKET  sock;
    DWORD   i;

    //
    //  return on bogus sockets to avoid caching them
    //

    if ( Socket == 0 )
    {
        DNSDBG( SOCKET, (
            "Warning:  returning zero socket\n" ));
        return;
    }

    //
    //  DCR:  currently no IP6 socket list
    //

    if ( Family != AF_INET )
    {
        goto Close;
    }

    //
    //  quick return if not caching
    //      - do outside lock so function can be called cheaply
    //      without other checks
    //

    if ( g_CacheSocketMaxCount == 0 ||
         g_CacheSocketMaxCount == g_CacheSocketCount )
    {
        goto Close;
    }

    //
    //  return cached socket
    //

    LOCK_SOCKET_CACHE();

    for ( i=0;  i<g_CacheSocketMaxCount;  i++ )
    {
        if ( g_pCacheSocketArray[i] )
        {
            continue;
        }
        g_pCacheSocketArray[i] = Socket;
        g_CacheSocketCount++;
        UNLOCK_SOCKET_CACHE();

        DNSDBG( SOCKET, (
            "Returned socket %d to cache.\n",
            Socket ));
        return;
    }

    UNLOCK_SOCKET_CACHE();

    DNSDBG( SOCKET, (
        "Socket cache full, closing socket %d.\n"
        "WARNING:  should only see this message on race!\n",
        Socket ));

Close:

    Socket_Close( Socket );
}



//
//  Message socket routines
//

SOCKET
Socket_CreateMessageSocket(
    IN OUT  PDNS_MSG_BUF    pMsg
    )
/*++

Routine Description:

    Set the remote address in a message.

Arguments:

    pMsg - message to send

Return Value:

    Socket handle if successful.
    Zero on error.

--*/
{
    BOOL    is6;
    SOCKET  sock;
    INT     family;

    DNSDBG( SOCKET, (
        "Socket_CreateMessageSocket( %p )\n", pMsg ));

    //
    //  determine 4/6
    //

    is6 = MSG_SOCKADDR_IS_IP6( pMsg );

    //
    //  check for existing socket
    //

    if ( is6 )
    {
        sock    = pMsg->Socket6;
        family  = AF_INET6;
    }
    else
    {
        sock    = pMsg->Socket4;
        family  = AF_INET;
    }

    if ( sock )
    {
        DNSDBG( SEND, (
            "Setting message to use existing IP%c socket %d\n",
            is6 ? '6' : '4',
            sock ));
        goto Done;
    }

    //
    //  not existing -- open new (or cached)
    //

    if ( pMsg->fTcp )
    {
        sock = Socket_Create(
                    family,
                    SOCK_STREAM,
                    NULL,       // ANY addr binding
                    0,          // ANY port binding
                    0           // no flags
                    );
    }
    else
    {
        sock = Socket_GetUdp( family );
    }

    //
    //  save socket to message
    //

    if ( is6 )
    {
        pMsg->Socket6 = sock;
    }
    else
    {
        pMsg->Socket4 = sock;
    }

Done:

    pMsg->Socket = sock;
    return  sock;
}



VOID
Socket_ClearMessageSockets(
    IN OUT  PDNS_MSG_BUF    pMsg
    )
/*++

Routine Description:

    Close message sockets.

Arguments:

    pMsg - ptr message

Return Value:

    None

--*/
{
    pMsg->Socket    = 0;
    pMsg->Socket4   = 0;
    pMsg->Socket6   = 0;
}



VOID
Socket_CloseMessageSockets(
    IN OUT  PDNS_MSG_BUF    pMsg
    )
/*++

Routine Description:

    Close message sockets.

Arguments:

    pMsg - ptr message

Return Value:

    Socket handle if successful.
    Zero on error.

--*/
{
    DNSDBG( SOCKET, (
        "Socket_CloseMessageSockets( %p )\n", pMsg ));

    //
    //  TCP -- single connection at a time
    //  UDP -- may have both IP4 and IP6 sockets open
    //

    if ( pMsg->fTcp )
    {
        Socket_CloseConnection( pMsg->Socket );
    }
    else
    {
        Socket_ReturnUdp( pMsg->Socket4, AF_INET );
        Socket_ReturnUdp( pMsg->Socket6, AF_INET6 );
    }

    Socket_ClearMessageSockets( pMsg );
}

//
//  End socket.c
//
=== C:/Users/treeman/Desktop/windows nt source code\Source\Win2K3\NT\ds\dns\dnsapi\trace.c ===
/*++

Copyright (c) 2000-2001  Microsoft Corporation

Module Name:

    trace.c

Abstract:

    Domain Name System ( DNS ) API 

    DNS performance tracing functions.

Author:

    Inder Sethi (bsethi)    December, 2000

Revision History:

    Jim Gilroy (jamesg)     January 2001    cleanup, format, integrate, checkin

--*/


#include "local.h"
#include "trace.h"

#include <tchar.h>
#include <wmistr.h>
#include <guiddef.h>
#include <evntrace.h>


//
//  FIX6:  No IP6 support

//
//  Message address extraction IP4
//

#define MSG_REMOTE_IP4(pMsg) \
        ( (pMsg)->RemoteAddress.SockaddrIn.sin_addr.s_addr )


//
//  Tracing definitions
//

#define EVENT_TRACE_TYPE_UDP    9
#define EVENT_TRACE_TYPE_TCP    10

typedef struct _DnsSendEvent
{
    EVENT_TRACE_HEADER  EventHeader;
    DNS_HEADER          DnsHeader;
    IP4_ADDRESS         DnsServer;
    DNS_STATUS          ReturnStatus;
}
DNS_SEND_EVENT, *PDNS_SEND_EVENT;

typedef struct _DnsRecvEvent
{
    EVENT_TRACE_HEADER  EventHeader;
    DNS_HEADER          DnsHeader;
    IP4_ADDRESS         DnsServer;
    DNS_STATUS          ReturnStatus;
}
DNS_RECV_EVENT, *PDNS_RECV_EVENT;

typedef struct _DnsQueryEvent
{
    EVENT_TRACE_HEADER  EventHeader;
    WORD                Xid;
    WORD                QueryType;
    CHAR                Query[256];
}
DNS_QUERY_EVENT, *PDNS_QUERY_EVENT;

typedef struct _DnsResponseEvent
{
    EVENT_TRACE_HEADER  EventHeader;
    WORD                Xid;
    WORD                RespType;
    DNS_STATUS          ReturnStatus;
}
DNS_RESPONSE_EVENT, *PDNS_RESPONSE_EVENT;


//
//  Tracing globals
//

TRACEHANDLE     g_LoggerHandle;
TRACEHANDLE     g_TraceRegHandle;

BOOL            g_TraceOn;
BOOL            g_TraceInit;
BOOL            g_TraceInitInProgress;
DWORD           g_TraceLastInitAttempt;

ULONG           g_NumEventGuids = 4;

//
//  Allow retry on init every minute
//

#define TRACE_INIT_RETRY_TIME   (60)


//
//  MAX ???
//

#define MAXSTR 1024


//
//  GUIDs 
//
//  Provider Guid: 1540ff4c-3fd7-4bba-9938-1d1bf31573a7

GUID    ProviderGuid =
{0x1540ff4c, 0x3fd7, 0x4bba, 0x99, 0x38, 0x1d, 0x1b, 0xf3, 0x15, 0x73, 0xa7};

//
//  Event Guids:
//      cc0c571b-d5f2-44fd-8b7f-de7770cc1984
//      6ddef4b8-9c60-423e-b1a6-deb9286fff1e
//      75f0c316-7bab-4e66-bed1-24091b1ac49e
//      9929b1c7-9e6a-4fc9-830a-f684e64f8aab
//

GUID    DnsSendGuid =
{0xcc0c571b, 0xd5f2, 0x44fd, 0x8b, 0x7f, 0xde, 0x77, 0x70, 0xcc, 0x19, 0x84};

GUID    DnsRecvGuid =
{0x6ddef4b8, 0x9c60, 0x423e, 0xb1, 0xa6, 0xde, 0xb9, 0x28, 0x6f, 0xff, 0x1e};

GUID    DnsQueryGuid =
{0x75f0c316, 0x7bab, 0x4e66, 0xbe, 0xd1, 0x24, 0x09, 0x1b, 0x1a, 0xc4, 0x9e};

GUID    DnsResponseGuid =
{0x9929b1c7, 0x9e6a, 0x4fc9, 0x83, 0x0a, 0xf6, 0x84, 0xe6, 0x4f, 0x8a, 0xab};

TRACE_GUID_REGISTRATION TraceGuidReg[] =
{
    { &DnsSendGuid , NULL},
    { &DnsRecvGuid , NULL},
    { &DnsQueryGuid   , NULL},
    { &DnsResponseGuid, NULL}
};



ULONG
ControlCallback( 
    IN      WMIDPREQUESTCODE    RequestCode,
    IN      PVOID               Context,
    IN OUT  ULONG *             InOutBufferSize,
    IN OUT  PVOID               Buffer
    )
/*++

Routine Description:

    ControlCallback is the callback which ETW will call to enable or disable
    logging. This is called by the caller in a thread-safe manner ( only one
    call at any time ).

Meaning of arguments in MSDN.

--*/
{
    ULONG   Status;

    Status = ERROR_SUCCESS;

    switch ( RequestCode )
    {
        case WMI_ENABLE_EVENTS:
        {
            g_LoggerHandle = GetTraceLoggerHandle( Buffer );
            g_TraceOn  = TRUE;
            break;
        }
        case WMI_DISABLE_EVENTS:
        {
            g_TraceOn      = FALSE;
            g_LoggerHandle = 0;
            break;
        }
        default:
        {
            Status = ERROR_INVALID_PARAMETER;
            break;
        }
    }
    return( Status );
}



VOID
Trace_Initialize(
    VOID
    )
/*++

Routine Description:

    Init DNS client tracing for DLL process attach.

    Note, does not actually init the tracing, just inits
    tracing variables.

Arguments:

    None.

Return Value:

    None.

--*/
{
    g_TraceOn               = FALSE;
    g_TraceInit             = FALSE;
    g_TraceInitInProgress   = FALSE;
    g_TraceLastInitAttempt  = 0;
}


VOID
Trace_Cleanup(
    VOID
    )
/*++

Routine Description:

    Cleaning tracing for DLL process detach.

Arguments:

    None.

Return Value:

    None.

--*/
{
    if ( g_TraceInit )
    {
        UnregisterTraceGuids( g_TraceRegHandle );
    }
}



VOID
InitializeTracePrivate(
    VOID
    )
/*++

Routine Description:

    Real tracing init.

Arguments:

    None

Globals:

    g_TraceInit -- is set if successful

    g_TraceLastInitAttempt -- is set with timestamp (in secs) if
        init attempt is made

    g_TraceRegHandle -- if set if init was successful

Return Value:

    None.

--*/
{
    ULONG   status;
    TCHAR   imagePath[MAXSTR];
    DWORD   currentTime;
    HMODULE hModule;

    //
    //  don't try init if recently tried
    //

    currentTime = GetCurrentTimeInSeconds();

    if ( currentTime < g_TraceLastInitAttempt + TRACE_INIT_RETRY_TIME )
    {
        return;
    }

    //
    //  protect init attempts
    //
    //  note:  use separate flag for interlock
    //      since the actual use of tracing is protected by a separate
    //      flag (g_TraceOn), it looks like we could directly use g_TraceInit
    //      as lock, as it can safely be set even when not initialize;
    //      however the cleanup function will attempt cleanup of g_TraceRegHandle
    //      and i'm using g_TraceInit to protect that; 
    //      in theory we shouldn't get to cleanup function with a thread
    //      still active attempting this init, but better to lock it down
    //

    if ( InterlockedIncrement( &g_TraceInitInProgress ) != 1 )
    {
        goto Unlock;
    }

    g_TraceLastInitAttempt = currentTime;

    hModule = GetModuleHandle(L"dnsapi.dll");

    status = GetModuleFileName(
                    hModule,
                    &imagePath[0],
                    MAXSTR);

    if ( status == 0 )
    {
        status = GetLastError();
        DNSDBG( INIT, (
            "Trace init failed GetModuleFileName() => %d\n",
            status ));
        goto Unlock;
    }

    __try
    {
        status = RegisterTraceGuids( 
                    (WMIDPREQUEST) ControlCallback,   //use same callback function
                    NULL,
                    (LPCGUID ) &ProviderGuid,
                    g_NumEventGuids,
                    &TraceGuidReg[0],
                    (LPCTSTR) &imagePath[0],
                    (LPCTSTR) _T( "MofResource" ),
                    &g_TraceRegHandle
                    );

        if ( status == ERROR_SUCCESS )
        {
            g_TraceInit = TRUE;
        }
    }
    __except ( EXCEPTION_EXECUTE_HANDLER )
    {
        status = GetExceptionCode();
    }

Unlock:

    //  clear init lockout

    InterlockedDecrement( &g_TraceInitInProgress );
}



//
//  Public DNS trace functions
//

VOID 
Trace_LogQueryEvent( 
    IN      PDNS_MSG_BUF    pMsg, 
    IN      WORD            wQuestionType
    )
/*++

Routine Description:

    Logs query attempts.

Arguments:

    pMsg -- Ptr to query sent

    wQuestionType -- Query type

Return:

    None

--*/
{
    DNS_QUERY_EVENT queryEvent;

    if ( !g_TraceInit )
    {
        InitializeTracePrivate();
    }

    if ( g_TraceOn )
    {
        INT i;
        INT j;
        INT k;

        RtlZeroMemory(
            &queryEvent,
            sizeof(DNS_QUERY_EVENT) );

        queryEvent.EventHeader.Class.Type = 1;
        queryEvent.EventHeader.Guid  = DnsQueryGuid;
        queryEvent.EventHeader.Flags = WNODE_FLAG_TRACED_GUID;
        queryEvent.Xid               = pMsg->MessageHead.Xid;
        queryEvent.QueryType         = wQuestionType;

        i = 0;
        j = pMsg->MessageBody[i];
        i++;

        while ( j != 0 )
        {
            for( k = 0; k < j; k++, i++ )
            {
                queryEvent.Query[i-1] = pMsg->MessageBody[i];
            }
            j = pMsg->MessageBody[i];
            queryEvent.Query[i-1] = '.';
            i++;
        }
        queryEvent.Query[i-1] = '\0';

        queryEvent.EventHeader.Size =
            sizeof(DNS_QUERY_EVENT) + strlen( queryEvent.Query ) - 255;

        TraceEvent(
            g_LoggerHandle,
            (PEVENT_TRACE_HEADER) &queryEvent );
    }
}



VOID
Trace_LogResponseEvent( 
    IN      PDNS_MSG_BUF    pMsg, 
    IN      WORD            wRespType,
    IN      DNS_STATUS      Status
    )
/*++

Routine Description:

    Used to log information about the final response of a DNS query.

Arguments:

    pMsg        -- Address of the DNS_MSG_BUF containing response

    wRespType   -- Type of the first response record

    Status      -- Status returned

Return:

    None

--*/
{
    DNS_RESPONSE_EVENT respEvent;

    if ( !g_TraceInit )
    {
        InitializeTracePrivate();
    }

    if ( g_TraceOn )
    {
        RtlZeroMemory(
            &respEvent,
            sizeof(DNS_RESPONSE_EVENT) );

        respEvent.EventHeader.Class.Type = 1;
        respEvent.EventHeader.Size  = sizeof(DNS_RESPONSE_EVENT);
        respEvent.EventHeader.Guid  = DnsResponseGuid;
        respEvent.EventHeader.Flags = WNODE_FLAG_TRACED_GUID;
        respEvent.Xid               = pMsg->MessageHead.Xid;
        respEvent.RespType          = wRespType;
        respEvent.ReturnStatus      = Status;

        TraceEvent(
            g_LoggerHandle,
            (PEVENT_TRACE_HEADER) &respEvent );
    }
}



VOID
Trace_LogSendEvent( 
    IN      PDNS_MSG_BUF    pMsg,
    IN      DNS_STATUS      Status
    )
/*++

Routine Description:

    Logs a TCP or UDP send event.

Arguments:

    pMsg    - message sent

    Status  - status of the send attempt

Return Value:

    None

--*/
{
    DNS_SEND_EVENT sendEvent;

    if ( !g_TraceInit )
    {
        InitializeTracePrivate();
    }

    if ( g_TraceOn )
    {
        UCHAR   eventType = EVENT_TRACE_TYPE_UDP;

        if ( pMsg->fTcp )
        {
            eventType = EVENT_TRACE_TYPE_TCP;
        }

        RtlZeroMemory(
            &sendEvent,
            sizeof(DNS_SEND_EVENT) );

        sendEvent.EventHeader.Class.Type    = eventType;
        sendEvent.EventHeader.Size          = sizeof(DNS_SEND_EVENT);
        sendEvent.EventHeader.Guid          = DnsSendGuid;
        sendEvent.EventHeader.Flags         = WNODE_FLAG_TRACED_GUID;
        sendEvent.DnsServer                 = MSG_REMOTE_IP4(pMsg);
        sendEvent.ReturnStatus              = Status;

        RtlCopyMemory(
            & sendEvent.DnsHeader,
            & pMsg->MessageHead,
            sizeof(DNS_HEADER) );

        TraceEvent(
            g_LoggerHandle,
            (PEVENT_TRACE_HEADER) &sendEvent );
    }
}



VOID 
Trace_LogRecvEvent( 
    IN      PDNS_MSG_BUF    pMsg,
    IN      DNS_STATUS      Status,
    IN      BOOL            fTcp
    )
/*++

Routine Description:

    Logs information about a receive event.

Arguments:

    pMsg    - message received

    Status  - status returned from receive call

    fTcp    - TRUE for TCP recv;  FALSE for UDP

Return Value:

    None

--*/
{
    DNS_RECV_EVENT recvEvent;

    if ( !g_TraceInit )
    {
        InitializeTracePrivate();
    }

    if ( g_TraceOn )
    {
        IP4_ADDRESS ipAddr = 0;
        UCHAR       eventType = EVENT_TRACE_TYPE_UDP;

        if ( fTcp )
        {
            eventType = EVENT_TRACE_TYPE_TCP;
        }
        if ( pMsg )
        {

            ipAddr = MSG_REMOTE_IP4(pMsg);
        }

        RtlZeroMemory(
            & recvEvent,
            sizeof(DNS_RECV_EVENT) );

        recvEvent.EventHeader.Class.Type    = eventType;
        recvEvent.EventHeader.Size          = sizeof(DNS_RECV_EVENT);
        recvEvent.EventHeader.Guid          = DnsRecvGuid;
        recvEvent.EventHeader.Flags         = WNODE_FLAG_TRACED_GUID;
        recvEvent.DnsServer                 = ipAddr;
        recvEvent.ReturnStatus              = Status;

        if ( pMsg )
        {
            RtlCopyMemory(
                & recvEvent.DnsHeader,
                & pMsg->MessageHead,
                sizeof(DNS_HEADER) );
        }

        TraceEvent(
            g_LoggerHandle,
            (PEVENT_TRACE_HEADER) &recvEvent );
    }
}

//
//  End trace.c
//
=== C:/Users/treeman/Desktop/windows nt source code\Source\Win2K3\NT\ds\dns\dnsapi\resolver.c ===
/*++

Copyright (c) 2000-2001  Microsoft Corporation

Module Name:

    resolver.c

Abstract:

    Domain Name System (DNS) API

    Resolver control.

Author:

    Jim Gilroy (jamesg)     March 2000

Revision History:

--*/


#include "local.h"



//
//  Flush cache routines
//

BOOL
WINAPI
DnsFlushResolverCache(
    VOID
    )
/*++

Routine Description:

    Flush resolver cache.

Arguments:

    None

Return Value:

    TRUE if successful.
    FALSE otherwise.

--*/
{
    DNS_STATUS  status = ERROR_SUCCESS;

    DNSDBG( TRACE, ( "DnsFlushResolverCache()\n" ));

    RpcTryExcept
    {
        R_ResolverFlushCache( NULL );
    }
    RpcExcept( DNS_RPC_EXCEPTION_FILTER )
    {
        status = RpcExceptionCode();
    }
    RpcEndExcept

    if ( status )
    {
        DNSDBG( RPC, (
            "DnsFlushResolverCache()  RPC failed status = %d\n",
            status ));
        return FALSE;
    }
    return TRUE;
}



BOOL
WINAPI
DnsFlushResolverCacheEntry_W(
    IN      PWSTR           pszName
    )
/*++

Routine Description:

    Flush resolver cache entry.

Arguments:

    pszName -- name of entry to flush in unicode

Return Value:

    TRUE if entry non-existant or flushed.
    FALSE on error.

--*/
{
    DWORD   status;

    DNSDBG( TRACE, (
        "DnsFlushResolverCacheEntry_W( %S )\n",
        pszName ));

    if ( !pszName )
    {
        return FALSE;
    }

    RpcTryExcept
    {
        status = R_ResolverFlushCacheEntry(
                    NULL,       // dummy handle
                    pszName,
                    0           // flush all types
                    );
    }
    RpcExcept( DNS_RPC_EXCEPTION_FILTER )
    {
        status = RpcExceptionCode();
    }
    RpcEndExcept

    if ( status != ERROR_SUCCESS )
    {
        DNSDBG( RPC, (
            "DnsFlushResolverCacheEntry()  RPC failed status = %d\n",
            status ));
        return FALSE;
    }
    
    return TRUE;
}



BOOL
WINAPI
FlushResolverCacheEntryNarrow(
    IN      PSTR            pszName,
    IN      DNS_CHARSET     CharSet
    )
/*++

Routine Description:

    Flush resolver cache entry with narrow string name.

    Handles flush for _A and _UTF8

Arguments:

    pszName -- name of entry to flush

    CharSet -- char set of name

Return Value:

    TRUE if entry non-existant or flushed.
    FALSE on error.

--*/
{
    WCHAR   wideNameBuffer[ DNS_MAX_NAME_BUFFER_LENGTH ];
    DWORD   bufLength = DNS_MAX_NAME_BUFFER_LENGTH * sizeof(WCHAR);
    BOOL    flag = TRUE;

    DNSDBG( TRACE, (
        "FlushResolverCacheEntryNarrow( %s )\n",
        pszName ));

    //  must have name

    if ( !pszName )
    {
        //  return  ERROR_INVALID_NAME;
        return FALSE;
    }

    //
    //  convert name to unicode
    //      - bail if name too long or conversion error

    if ( ! Dns_NameCopy(
                (PBYTE) wideNameBuffer,
                & bufLength,
                pszName,
                0,              // name is string
                CharSet,
                DnsCharSetUnicode ))
    {
        //  return  ERROR_INVALID_NAME;
        return  FALSE;
    }

    //  flush cache entry

    return  DnsFlushResolverCacheEntry_W( wideNameBuffer );
}


BOOL
WINAPI
DnsFlushResolverCacheEntry_A(
    IN      PSTR            pszName
    )
{
    return  FlushResolverCacheEntryNarrow(
                pszName,
                DnsCharSetAnsi );
}

BOOL
WINAPI
DnsFlushResolverCacheEntry_UTF8(
    IN      PSTR            pszName
    )
{
    return  FlushResolverCacheEntryNarrow(
                pszName,
                DnsCharSetUtf8 );
}



//
//  Resolver poke
//

VOID
DnsNotifyResolverEx(
    IN      DWORD           Id,
    IN      DWORD           Flag,
    IN      DWORD           Cookie,
    IN      PVOID           pReserved
    )
/*++

Routine Description:

    Notify resolver of cluster IP coming on\offline.

Arguments:

    ClusterIp -- cluster IP

    fAdd -- TRUE if coming online;  FALSE if offline.

Return Value:

    None

--*/
{
    RpcTryExcept
    {
        R_ResolverPoke(
                NULL,           // RPC handle
                Cookie,
                Id );
    }
    RpcExcept( DNS_RPC_EXCEPTION_FILTER )
    {
    }
    RpcEndExcept
}



//
//  Cluster interface
//

DNS_STATUS
DnsRegisterClusterAddress(
    IN      DWORD           Tag,
    IN      PWSTR           pwsName,
    IN      PSOCKADDR       pSockaddr,
    IN      DWORD           Flag
    )
/*++

Routine Description:

    Register cluster addresses with resolver.

Arguments:

    pwsName -- cluster name

    pSockaddr -- sockaddr for cluster address

    fAdd -- TRUE if coming online;  FALSE if offline.

    Tag -- cluster add tag

Return Value:

    None

--*/
{
    DNS_ADDR    addr;
    DNS_STATUS  status;

    DNSDBG( TRACE, (
        "DnsRegisterClusterAddress()\n"
        "\tTag          = %08x\n"
        "\tpName        = %S\n"
        "\tpSockaddr    = %p (fam=%d)\n"
        "\tFlag         = %d\n",
        Tag,
        pwsName,
        pSockaddr,  pSockaddr->sa_family,
        Flag ));

    //
    //  DCR:  write cluster key
    //
    //  DCR:  check that we are on cluster machime
    //

    if ( !g_IsServer )
    {
        return  ERROR_ACCESS_DENIED;
    }

    //
    //  convert to our private IP union
    //

    if ( ! DnsAddr_Build(
                &addr,
                pSockaddr,
                0,          // default family
                0,          // no subnet info
                0           // no flags 
                ) )
    {
        DNSDBG( ANY, (
            "ERROR:  failed converting sockaddr to DNS_ADDR!\n" ));
        return  ERROR_INVALID_PARAMETER;
    }

    //
    //  notify resolver of cluster IP
    //

    RpcTryExcept
    {
        status = R_ResolverRegisterCluster(
                    NULL,           // RPC handle
                    Tag,
                    pwsName,
                    & addr,
                    Flag );
    }
    RpcExcept( DNS_RPC_EXCEPTION_FILTER )
    {
        status = RpcExceptionCode();
    }
    RpcEndExcept


    DNSDBG( TRACE, (
        "Leave  DnsRegisterClusterAddress( %S ) => %d\n",
        pwsName,
        status ));

    return  status;
}

//
//  End resolver.c
//
=== C:/Users/treeman/Desktop/windows nt source code\Source\Win2K3\NT\ds\dns\dnsapi\rtlstuff.h ===
/*++

Copyright (c) 1997 Microsoft Corporation

Module Name:

    rtlstuff.h

Abstract:

    Domain Name System (DNS) Libary

    Macros from NT RTL headers.
    Copied here from ntrtl.h so we can build free of any NT specific headers.

Author:

    Jim Gilroy (jamesg)     May 1997

Revision History:

--*/


#ifndef _RTLSTUFF_INCLUDED_
#define _RTLSTUFF_INCLUDED_


//
//  Doubly-linked list manipulation routines.
//  Implemented as macros but logically these are procedures.
//

//
//  VOID
//  InitializeListHead(
//      PLIST_ENTRY ListHead
//      );
//

#define InitializeListHead(ListHead) (\
    (ListHead)->Flink = (ListHead)->Blink = (ListHead))

//
//  BOOLEAN
//  IsListEmpty(
//      PLIST_ENTRY ListHead
//      );
//

#define IsListEmpty(ListHead) \
    ((ListHead)->Flink == (ListHead))

//
//  PLIST_ENTRY
//  RemoveHeadList(
//      PLIST_ENTRY ListHead
//      );
//

#define RemoveHeadList(ListHead) \
    (ListHead)->Flink;\
    {RemoveEntryList((ListHead)->Flink)}

//
//  PLIST_ENTRY
//  RemoveTailList(
//      PLIST_ENTRY ListHead
//      );
//

#define RemoveTailList(ListHead) \
    (ListHead)->Blink;\
    {RemoveEntryList((ListHead)->Blink)}

//
//  VOID
//  RemoveEntryList(
//      PLIST_ENTRY Entry
//      );
//

#define RemoveEntryList(Entry) {\
    PLIST_ENTRY _EX_Blink;\
    PLIST_ENTRY _EX_Flink;\
    _EX_Flink = (Entry)->Flink;\
    _EX_Blink = (Entry)->Blink;\
    _EX_Blink->Flink = _EX_Flink;\
    _EX_Flink->Blink = _EX_Blink;\
    }

//
//  VOID
//  InsertTailList(
//      PLIST_ENTRY ListHead,
//      PLIST_ENTRY Entry
//      );
//

#define InsertTailList(ListHead,Entry) {\
    PLIST_ENTRY _EX_Blink;\
    PLIST_ENTRY _EX_ListHead;\
    _EX_ListHead = (ListHead);\
    _EX_Blink = _EX_ListHead->Blink;\
    (Entry)->Flink = _EX_ListHead;\
    (Entry)->Blink = _EX_Blink;\
    _EX_Blink->Flink = (Entry);\
    _EX_ListHead->Blink = (Entry);\
    }

//
//  VOID
//  InsertHeadList(
//      PLIST_ENTRY ListHead,
//      PLIST_ENTRY Entry
//      );
//

#define InsertHeadList(ListHead,Entry) {\
    PLIST_ENTRY _EX_Flink;\
    PLIST_ENTRY _EX_ListHead;\
    _EX_ListHead = (ListHead);\
    _EX_Flink = _EX_ListHead->Flink;\
    (Entry)->Flink = _EX_Flink;\
    (Entry)->Blink = _EX_ListHead;\
    _EX_Flink->Blink = (Entry);\
    _EX_ListHead->Flink = (Entry);\
    }

//
//
//  PSINGLE_LIST_ENTRY
//  PopEntryList(
//      PSINGLE_LIST_ENTRY ListHead
//      );
//

#define PopEntryList(ListHead) \
    (ListHead)->Next;\
    {\
        PSINGLE_LIST_ENTRY FirstEntry;\
        FirstEntry = (ListHead)->Next;\
        if (FirstEntry != NULL) {     \
            (ListHead)->Next = FirstEntry->Next;\
        }                             \
    }


//
//  VOID
//  PushEntryList(
//      PSINGLE_LIST_ENTRY ListHead,
//      PSINGLE_LIST_ENTRY Entry
//      );
//

#define PushEntryList(ListHead,Entry) \
    (Entry)->Next = (ListHead)->Next; \
    (ListHead)->Next = (Entry)


//
//  RTL memory routines
//

#if !defined(_WIN64)
#define RtlEqualMemory(Destination,Source,Length) (!memcmp((Destination),(Source),(Length)))
#endif

#define RtlCompareMemory(Destination,Source,Length) memcmp((Destination),(Source),(Length))

#define RtlMoveMemory(Destination,Source,Length) memmove((Destination),(Source),(Length))
#define RtlCopyMemory(Destination,Source,Length) memcpy((Destination),(Source),(Length))

#define RtlFillMemory(Destination,Length,Fill) memset((Destination),(Fill),(Length))
#define RtlZeroMemory(Destination,Length) memset((Destination),0,(Length))


#endif  // RTLSTUFF_INCLUDED
=== C:/Users/treeman/Desktop/windows nt source code\Source\Win2K3\NT\ds\dns\dnsapi\servlist.c ===
/*++

Copyright (c) 1997-2001 Microsoft Corporation

Module Name:

    servlist.c

Abstract:

    Domain Name System (DNS) API

    DNS network info routines.

Author:

    Jim Gilroy (jamesg)     January, 1997
    Glenn Curtis (glennc)   May, 1997

Revision History:

    Jim Gilroy (jamesg)     March 2000      slowly cleaning up

--*/


#include "local.h"
#include "registry.h"       // Registry reading definitions


//
//  Keep copy of DNS server/network info
//


#define CURRENT_ADAPTER_LIST_TIMEOUT    (10)    // 10 seconds


//
//  Registry info
//

#define DNS_REG_READ_BUF_SIZE       (1000)

#define LOCALHOST                   "127.0.0.1"


//
//  Protos
//

BOOL
Dns_PingAdapterServers(
    IN      PDNS_ADAPTER        pAdapterInfo
    );




DNS_STATUS
ParseNameServerList(
    IN OUT  PIP4_ARRAY      aipServers,
    IN      LPSTR           pBuffer,
    IN      BOOL            IsMultiSzString
    )
/*++

Routine Description:

    Parse DNS server list from registry into IP address array.

Arguments:

    aipServers -- IP array of DNS servers

    pBuffer -- buffer with IP addresses in dotted format

    IsMultiSzString -- Determines how to interpret data in buffer

Return Value:

    ERROR_SUCCESS if successful.
    Error code on failure.

--*/
{
    DWORD       stringLength;
    LPSTR       pstring;
    DWORD       cchBufferSize = 0;
    CHAR        ch;
    PUCHAR      pchIpString;
    IP4_ADDRESS ip;
    DWORD       countServers = aipServers->AddrCount;

    DNSDBG( NETINFO, (
        "Parsing name server list %s\n",
        pBuffer ));

    //
    //  MULTI_SZ string
    //
    //  IPs are given as individual strings with double NULL termination
    //

    if ( IsMultiSzString )
    {
        pstring = pBuffer;

        while ( ( stringLength = strlen( pstring ) ) != 0 &&
                countServers < DNS_MAX_NAME_SERVERS )
        {
            ip = inet_addr( pstring );

            if ( ip != INADDR_ANY && ip != INADDR_NONE )
            {
                aipServers->AddrArray[ countServers ] = ip;
                countServers++;
            }
            pstring += (stringLength + 1);
        }
    }
    else
    {
        //
        //  extract each IP string in buffer, convert to IP address,
        //  and add to server IP array
        //

        cchBufferSize = strlen( pBuffer );

        while( ch = *pBuffer && countServers < DNS_MAX_NAME_SERVERS )
        {
            //  skip leading whitespace, find start of IP string

            while( cchBufferSize > 0 &&
                   ( ch == ' ' || ch == '\t' || ch == ',' ) )
            {
                ch = *++pBuffer;
                cchBufferSize--;
            }
            pchIpString = pBuffer;

            //
            //  find end of string and NULL terminate
            //

            ch = *pBuffer;
            while( cchBufferSize > 0 &&
                   ( ch != ' ' && ch != '\t' && ch != '\0' && ch != ',' ) )
            {
                ch = *++pBuffer;
                cchBufferSize--;
            }
            *pBuffer = '\0';

            //  at end of buffer

            if ( pBuffer == pchIpString )
            {
                DNS_ASSERT( cchBufferSize == 1 || cchBufferSize == 0 );
                break;
            }

            //
            //  get IP address for string
            //      - zero or broadcast addresses are bogus
            //

            ip = inet_addr( pchIpString );
            if ( ip == INADDR_ANY || ip == INADDR_NONE )
            {
                break;
            }
            aipServers->AddrArray[ countServers ] = ip;
            countServers++;

            //  if more continue

            if ( cchBufferSize > 0 )
            {
                pBuffer++;
                cchBufferSize--;
                continue;
            }
            break;
        }
    }

    //  reset server count

    aipServers->AddrCount = countServers;

    if ( aipServers->AddrCount )
    {
        return( ERROR_SUCCESS );
    }
    else
    {
        return( DNS_ERROR_NO_DNS_SERVERS );
    }
}



//
//  Network info structure routines
//

#if 0
PSEARCH_LIST
Dns_GetDnsSearchList(
    IN      LPSTR             pszPrimaryDomainName,
    IN      HKEY              hKey,
    IN      PDNS_NETINFO      pNetworkInfo,
    IN      BOOL              fUseDomainNameDevolution,
    IN      BOOL              fUseDotLocalDomain
    )
/*++

    Dumb stub because this function is exposed in dnslib.h
        and in stmpdns\servlist.cpp in iis project

    DCR:  eliminate this routine (stupid)

--*/
{
    return  SearchList_Build(
                pszPrimaryDomainName,
                NULL,       // no reg session
                hKey,
                pNetworkInfo,
                fUseDomainNameDevolution,
                fUseDotLocalDomain );
}
#endif


VOID
Dns_ResetNetworkInfo(
    IN      PDNS_NETINFO      pNetworkInfo
    )
/*++

Routine Description:

    Clear the flags for each adapter.

Arguments:

    pNetworkInfo -- pointer to a DNS network info structure.

Return Value:

    Nothing

--*/
{
    DWORD iter;

    DNSDBG( TRACE, ( "Dns_ResetNetworkInfo()\n" ));

    if ( ! pNetworkInfo )
    {
        return;
    }

    for ( iter = 0; iter < pNetworkInfo->AdapterCount; iter++ )
    {
        pNetworkInfo->AdapterArray[iter].RunFlags = 0;
    }

    pNetworkInfo->ReturnFlags = 0;
}



BOOL
Dns_DisableTimedOutAdapters(
    IN OUT  PDNS_NETINFO        pNetworkInfo
    )
/*++

Routine Description:

    For each adapter with status ERROR_TIMEOUT, disable it from
    further retry queries till Dns_ResetNetworkInfo is called.

Arguments:

    pNetworkInfo -- pointer to a DNS network info structure.

Return Value:

    True if a timed out adapter was found and disabled

--*/
{
    DWORD             iter;
    PDNS_ADAPTER      padapter;
    BOOL              fSetAdapter = FALSE;

    DNSDBG( TRACE, ( "Dns_DisableTimedOutAdapters()\n" ));

    if ( ! pNetworkInfo )
    {
        return FALSE;
    }

    for ( iter = 0; iter < pNetworkInfo->AdapterCount; iter++ )
    {
        padapter = NetInfo_GetAdapterByIndex( pNetworkInfo, iter );

        if ( padapter->Status == ERROR_TIMEOUT )
        {
            //
            // See if the given adapters are really timing out or not.
            // 
            // Sometimes a given name query will take a long time and
            // we timeout waiting for the response, though the server
            // will quicky respond to other name queries. Other times
            // the default gateway doesn't let us reach the DNS servers
            // on a given adapter, or they are plain dead.
            //
            // Pinging the given DNS servers to see if they can respond
            // to a simple query helps to avoid the confusion.
            //

            if ( !Dns_PingAdapterServers( padapter ) )
            {
                padapter->RunFlags |= RUN_FLAG_IGNORE_ADAPTER;
                padapter->RunFlags |= RUN_FLAG_RESET_SERVER_PRIORITY;
                fSetAdapter = TRUE;
            }
        }
    }

    if ( fSetAdapter )
    {
        pNetworkInfo->ReturnFlags = RUN_FLAG_RESET_SERVER_PRIORITY;
    }

    return fSetAdapter;
}


BOOL
Dns_ShouldNameErrorBeCached(
    IN      PDNS_NETINFO      pNetworkInfo
    )
/*++

Routine Description:

    This routine is used in conjuction with a given query's NAME_ERROR
    response to see if the error was one that occured on all adapters.
    This is used to decide if the name error response should be cached
    or not. If the machine was multihomed, and one of the adapters had
    a timeout error, then the name error should not be cached as a
    negative response.

Arguments:

    pNetworkInfo -- pointer to a DNS network info structure.

Return Value:

    False if a timed out adapter was found, and name error should not
    be negatively cached.

--*/
{
    DWORD             iter;
    PDNS_ADAPTER      padapter;

    DNSDBG( TRACE, ( "Dns_DidNameErrorOccurEverywhere()\n" ));

    if ( ! pNetworkInfo )
    {
        return TRUE;
    }

    if ( pNetworkInfo->ReturnFlags & RUN_FLAG_RESET_SERVER_PRIORITY )
    {
        for ( iter = 0; iter < pNetworkInfo->AdapterCount; iter++ )
        {
            padapter = NetInfo_GetAdapterByIndex( pNetworkInfo, iter );

            if ( !( padapter->InfoFlags & AINFO_FLAG_IGNORE_ADAPTER ) &&
                 padapter->Status == ERROR_TIMEOUT )
            {
                return FALSE;
            }
        }
    }

    return TRUE;
}


BOOL
Dns_PingAdapterServers(
    IN      PDNS_ADAPTER        pAdapterInfo
    )
//
//  DCR:  Dns_PingAdapterServers() is stupid
//          why are we doing this?
//
{
    BOOL              fping = TRUE;
    PDNS_NETINFO      pnetInfo = NULL;
    PDNS_ADAPTER      padapterCopy = NULL;
    DNS_STATUS        status = NO_ERROR;

    DNSDBG( TRACE, ( "PingAdapterServers()\n" ));

    pnetInfo = NetInfo_Alloc( 1 );
    if ( !pnetInfo )
    {
        return FALSE;
    }

    padapterCopy = NetInfo_GetAdapterByIndex( pnetInfo, 0 );

    status = AdapterInfo_Copy(
                padapterCopy,
                pAdapterInfo );
    if ( status != NO_ERROR )
    {
        fping = FALSE;
        goto Done;
    }

    padapterCopy->InfoFlags = AINFO_FLAG_IS_AUTONET_ADAPTER;

    //
    //  query adapter's DNS servers
    //      - query for loopback which always exists
    //

    status = QueryDirectEx(
                    NULL,       // no message
                    NULL,       // no results
                    NULL,       // no header
                    0,          // no header counts
                    "1.0.0.127.in-addr.arpa.",
                    DNS_TYPE_PTR,
                    NULL,       // no input records
                    DNS_QUERY_ACCEPT_PARTIAL_UDP |
                        DNS_QUERY_NO_RECURSION,
                    NULL,       // no server list
                    pnetInfo );

    if ( status == ERROR_TIMEOUT )
    {
        fping = FALSE;
    }

Done:

    NetInfo_Free( pnetInfo );

    return fping;
}



#if 0
    //
    //  this is some stuff Glenn wrote for the case where you
    //      don't have a DNS server list and will get it through mcast
    //
    //  it was in the middle of the NetworkInfo building routine
    //
    else
    {
        //
        //  DCR:  functionalize multicast query attempt
        //
        //
        // See if we can find a DNS server address to put on this
        // adapter by multicasting for it . . .
        //

        // LevonE is still debating this method for
        // server detection. If this is ultimately utilized, it
        // might be better to direct the multicast query out the
        // specific adapter IP address to try to get an address
        // relevant to the specific adapter's network. This
        // could be done by building a dummy pNetworkInfo
        // parameter to pass down to Dns_QueryLib. The helper
        // routine Dns_SendAndRecvMulticast could be revised to
        // support specific adapter multicasting, etc.

        PDNS_RECORD pServer = NULL;

        status = Dns_QueryLib(
                    NULL,
                    &pServer,
                    (PDNS_NAME) MULTICAST_DNS_SRV_RECORD_NAME,
                    DNS_TYPE_SRV,
                    DNS_QUERY_MULTICAST_ONLY,
                    NULL,
                    NULL, // May want to specify network!
                    0 );

        if ( status )
        {
            //
            // This adapter is not going to have any configured
            // DNS servers. No point trying any DNS queries on
            // it then.
            //
            adapterFlags |= AINFO_FLAG_IGNORE_ADAPTER;
        }
        else
        {
            if ( pServer &&
                 pServer->Flags.S.Section == DNSREC_ANSWER &&
                 pServer->wType == DNS_TYPE_SRV &&
                 pServer->Data.SRV.wPort == DNS_PORT_HOST_ORDER )
            {
                PDNS_RECORD pNext = pServer->pNext;

                while ( pNext )
                {
                    if ( pNext->Flags.S.Section == DNSREC_ADDITIONAL &&
                         pNext->wType == DNS_TYPE_A &&
                         Dns_NameCompare( pServer ->
                                          Data.SRV.pNameTarget,
                                          pNext->pName ) )
                    {
                        pserverIpArray->AddrCount = 1;
                        pserverIpArray->AddrArray[0] = 
                            pNext->Data.A.IpAddress;
                        adapterFlags |= AINFO_FLAG_AUTO_SERVER_DETECTED;
                        break;
                    }

                    pNext = pNext->pNext;
                }
            }

            Dns_RecordListFree( pServer );

            if ( pserverIpArray->AddrCount == 0 )
            {
                //
                // This adapter is not going to have any configured
                // DNS servers. No point trying any DNS queries on
                // it then.
                //
                adapterFlags |= AINFO_FLAG_IGNORE_ADAPTER;
            }
        }
    }
#endif      //  multicast attempt

//
//  End servlist.c
//
=== C:/Users/treeman/Desktop/windows nt source code\Source\Win2K3\NT\ds\dns\dnsapi\send.c ===
/*++

Copyright (c) 1996-2001  Microsoft Corporation

Module Name:

    send.c

Abstract:

    Domain Name System (DNS) API

    Send response routines.

Author:

    Jim Gilroy (jamesg)     October, 1996

Revision History:

--*/


#include "local.h"


//
//  Disjoint name space
//
//  If DNS name space is disjoint then NAME_ERROR response from one
//  adapter does NOT necessarily mean that name does not exist.  Rather
//  must continue on other adapters.
//
//  This flag should be set if name space is disjoint, off otherwise.
//
//  DCR_PERF:  auto-detect disjoint name space (really cool)
//  DCR_ENHANCE:  auto-detect disjoint name space (really cool)
//      initially continue trying on other adapters and if they always
//      coincide, then conclude non-disjoint (and turn off)
//
//  DCR_ENHANCE:  registry turn off of disjoint name space
//
//  Note:  should consider that name spaces often disjoint in that
//  Intranet is hidden from Internet
//

BOOL fDisjointNameSpace = TRUE;

//
//  Query \ response IP matching.
//
//  Some resolvers (Win95) have required matching between DNS server IP
//  queried and response.  This flag allows this matching to be turned on.
//  Better now than requiring SP later.
//
//  DCR_ENHANCE:  registry enable query\response IP matching.
//

BOOL fQueryIpMatching = FALSE;


//
//  Timeouts
//

#define HARD_TIMEOUT_LIMIT      16    // 16 seconds, total of 31 seconds
#define INITIAL_UPDATE_TIMEOUT   2    // 3 seconds
#define MAX_UPDATE_TIMEOUT      24    // 24 seconds
#define DNS_MAX_QUERY_TIMEOUTS  10    // 10
#define ONE_HOUR_TIMEOUT        60*60 // One hour

//  TCP timeout 10 seconds to come back

#define DEFAULT_TCP_TIMEOUT     10


//  Retry limits

#define MAX_SINGLE_SERVER_RETRY     (3)


#define NT_TCPIP_REG_LOCATION           "System\\CurrentControlSet\\Services\\Tcpip\\Parameters"
#define DNS_QUERY_TIMEOUTS              "DnsQueryTimeouts"
#define DNS_QUICK_QUERY_TIMEOUTS        "DnsQuickQueryTimeouts"
#define DNS_MULTICAST_QUERY_TIMEOUTS    "DnsMulticastQueryTimeouts"

//
//  Timeouts
//  MUST have terminating 0, this signals end of timeouts.
//  This is better than a timeout limit as different query types can
//  have different total retries.
//

DWORD   QueryTimeouts[] =
{
    1,      //  NT5 1,
    1,      //      2,
    2,      //      2,
    4,      //      4,
    7,      //      8,
    0       
};

DWORD   RegistryQueryTimeouts[DNS_MAX_QUERY_TIMEOUTS + 1];
LPDWORD g_QueryTimeouts = QueryTimeouts;

DWORD   QuickQueryTimeouts[] =
{
    1,
    2,
    2,
    0
};

DWORD   RegistryQuickQueryTimeouts[DNS_MAX_QUERY_TIMEOUTS + 1];
LPDWORD g_QuickQueryTimeouts = QuickQueryTimeouts;

//
//  Update timeouts.
//  Must be long enough to handle zone lock on primary for XFR
//  or time required for DS write.
//

DWORD   UpdateTimeouts[] =
{
    5,
    10,
    20,
    0
};

//
//  Multicast Query timeouts.
//  Local only.  1sec timeout, three retries.
//

DWORD   MulticastQueryTimeouts[] =
{
    1,
    1,
    1,
    0
};

DWORD   RegistryMulticastQueryTimeouts[DNS_MAX_QUERY_TIMEOUTS + 1];
LPDWORD g_MulticastQueryTimeouts = MulticastQueryTimeouts;


//
//  Query flag
//
//  Flags that terminate query on adapter

#define RUN_FLAG_COMBINED_IGNORE_ADAPTER \
        (RUN_FLAG_IGNORE_ADAPTER | RUN_FLAG_STOP_QUERY_ON_ADAPTER)


//
//  Authoritative empty response
//      - map to NXRRSET for tracking in send code
//

#define DNS_RCODE_AUTH_EMPTY_RESPONSE       (DNS_RCODE_NXRRSET)




//
//  Dummy no-send-to-this-server error code
//

#define DNS_ERROR_NO_SEND   ((DWORD)(-100))



//
//  OPT failure tracking
//

BOOL
Send_IsServerOptExclude(
    IN      PDNS_ADDR       pAddr
    );

VOID
Send_SetServerOptExclude(
    IN      PDNS_ADDR       pAddr
    );



//
//  Netinfo send\recv utils
//

VOID
serverPriorityChange(
    IN OUT  PDNS_NETINFO        pNetInfo,
    IN OUT  PDNS_ADAPTER        pAdapter,
    IN OUT  PDNS_ADDR           pServer,
    IN      DWORD               NewPriority
    )
/*++

Routine Description:

    Changing server priority.

Arguments:

    pNetInfo -- netinfo

    pAdapter -- server's adapter

    pServer -- server

    NewPriority -- new priority

Return Value:

    None.

--*/
{
    //
    //  priority change
    //      - no change if loopback
    //      - otherwise
    //          - set priority
    //          - mark netinfo\adapter to save change
    //

    if ( !DnsAddr_IsLoopback( pServer, 0 ) )
    {
        pServer->Priority       = NewPriority;
        pAdapter->RunFlags      |= RUN_FLAG_RESET_SERVER_PRIORITY;
        pNetInfo->ReturnFlags   |= RUN_FLAG_RESET_SERVER_PRIORITY;
    }
}



VOID
timeoutDnsServers(
    IN      PDNS_NETINFO        pNetInfo,
    IN      DWORD               dwTimeout
    )
/*++

Routine Description:

    Mark a DNS server that timed out.

Arguments:

    pNetInfo -- struct with list of DNS servers

    dwTimeout -- timeout in seconds

Return Value:

    None.

--*/
{
    PDNS_ADAPTER        padapter;
    PDNS_ADDR_ARRAY     pserverArray;
    PDNS_ADDR           pserver;
    DWORD               lastSendIndex;
    DWORD               i;
    DWORD               j;

    DNSDBG( SEND, (
        "Enter timeoutDnsServers( %p, timeout=%d )\n",
        pNetInfo,
        dwTimeout ));

    DNS_ASSERT( pNetInfo );

    //
    //  find DNS server in list,
    //      -- drop its priority based on timeout
    //      -- if already has RCODE, then did not time out
    //
    //  if change a priority, then set flag at top of adapter list, so
    //  that global copy may be updated
    //

    for ( i=0; i<pNetInfo->AdapterCount; i++ )
    {
        padapter = NetInfo_GetAdapterByIndex( pNetInfo, i );

        //  no sends on this adapter?

        if ( !(padapter->RunFlags & RUN_FLAG_SENT_THIS_RETRY) )
        {
            DNSDBG( SEND, (
                "No sends this retry on adapter %d\n",
                padapter->InterfaceIndex ));
            continue;
        }
        pserverArray = padapter->pDnsAddrs;
        if ( !pserverArray )
        {
            DNSDBG( SEND, (
                "WARNING:  Adapter %d -- no DNS servers!\n",
                padapter->InterfaceIndex ));
            continue;
        }

        //
        //  find DNS servers sent to
        //
        //      - if it responded with status, then it didn't timeout
        //      (if responded with success, then query completed and
        //      we wouldn't be in this function)
        //
        //      - go "easy" on OPT sends;
        //          don't drop priority, just note timeout
        //

        for ( j=0; j<pserverArray->AddrCount; j++ )
        {
            pserver = &pserverArray->AddrArray[j];
    
            if ( TEST_SERVER_STATE(pserver, SRVFLAG_SENT_THIS_RETRY) )
            {
                DNSDBG( SEND, (
                    "Timeout on server %p (padapter=%p)\n",
                    pserver,
                    padapter ));
    
                if ( TEST_SERVER_STATE(pserver, SRVFLAG_SENT_NON_OPT) )
                {
                    SET_SERVER_STATE( pserver, SRVFLAG_TIMEOUT_NON_OPT );
    
                    serverPriorityChange(
                        pNetInfo,
                        padapter,
                        pserver,
                        pserver->Priority - dwTimeout - SRVPRI_TIMEOUT_DROP );
                }
                else
                {
                    DNSDBG( SEND, (
                        "Timeout on server %p OPT only\n",
                        pserver ));
    
                    SET_SERVER_STATE( pserver, SRVFLAG_TIMEOUT_OPT );
                }
            }
        }
    }
}



VOID
resetOnFinalTimeout(
    IN      PDNS_NETINFO        pNetInfo
    )
/*++

Routine Description:

    Markup network info on final timeout.

Arguments:

    pNetInfo -- struct with list of DNS servers

    dwTimeout -- timeout in seconds

Return Value:

    None.

--*/
{
    DWORD         i;
    PDNS_ADAPTER  padapter;

    //
    // We've timed out against all DNS server for a least
    // one of the adapters. Update adapter status to show
    // time out error.
    //
    //  DCR:  is final timeout correct
    //      - worried about timeout on some but not all servers
    //      case;  adapter shouldn't show timeout should it?
    //

    for ( i=0; i<pNetInfo->AdapterCount; i++ )
    {
        padapter = NetInfo_GetAdapterByIndex( pNetInfo, i );

        if ( padapter->Status == NO_ERROR &&
             padapter->RunFlags & (RUN_FLAG_RESET_SERVER_PRIORITY | RUN_FLAG_SENT) )
        {
            padapter->Status = ERROR_TIMEOUT;
        }
    }
}



BOOL
verifyValidServer(
    IN      PDNS_NETINFO    pNetInfo,
    IN      PDNS_ADDR       pAddr
    )
/*++

Routine Description:

    Verify valid server IP.

    DCR:  we have no way to do this for IP6 yet.

Arguments:

    pNetInfo -- struct with list of DNS servers

    pAddr -- address of responding server

Return Value:

    TRUE -- valid server.
    FALSE -- bad \ unknown server.

--*/
{
    PDNS_ADAPTER    padapter;
    DWORD           i;

    DNSDBG( SEND, (
        "Enter verifyValidServer( %p, %s )\n",
        pNetInfo,
        DNSADDR_STRING(pAddr) ));

    DNS_ASSERT( pNetInfo );

    //
    //  accept any IP6 response
    //
    //  DCR:  IP6 server validity
    //      will need to determine
    //      - when we have fixed (global) IP6 address only
    //      - or have locked down default addresses already
    //      - otherwise will have to accept reponses to default
    //      query ... but even there could screen on interface
    //

    if ( DnsAddr_IsIp6(pAddr) )
    {
        DNSDBG( SEND, ( "Accepting IP6 address as valid server address.\n" ));
        return  TRUE;
    }

    //
    //  find DNS server in list
    //

    for ( i=0; i<pNetInfo->AdapterCount; i++ )
    {
        padapter = NetInfo_GetAdapterByIndex( pNetInfo, i );

        if ( DnsAddrArray_ContainsAddr(
                padapter->pDnsAddrs,
                pAddr,
                DNSADDR_MATCH_ADDR ) )
        {
            return  TRUE;
        }
    }

    DNSDBG( SEND, (
        "WARNING:  address %s NOT found in network info!!!\n",
        DNSADDR_STRING(pAddr) ));

    return  FALSE;
}



DNS_STATUS
resetServerAfterRecv(
    IN      PDNS_NETINFO    pNetInfo,
    IN      PDNS_ADDR       pAddr,
    IN      DNS_STATUS      Status
    )
/*++

Routine Description:

    Reset priority on DNS server that sent response.

Arguments:

    pNetInfo -- struct with list of DNS servers

    pAddr -- address of responding server

    Status -- RCODE of response

Return Value:

    ERROR_SUCCESS if continue query.
    DNS_ERROR_RCODE_NAME_ERROR if all (valid) adapters have name-error or auth-empty response.

--*/
{
    DWORD           i;
    DNS_STATUS      result = DNS_ERROR_RCODE_NAME_ERROR;
    BOOL            fterminalNameError = FALSE;
#if DBG
    BOOL            freset = FALSE;
#endif

    DNSDBG( SEND, (
        "Enter resetServerAfterRecv( %p, %s rcode=%d)\n",
        pNetInfo,
        DNSADDR_STRING(pAddr),
        Status ));

    DNS_ASSERT( pNetInfo );

    //
    //  find DNS server in list, clear its priority field
    //
    //  note:  going through full list here after found DNS
    //  as no guarantee that lists do not overlap (IP6 default
    //  servers almost certainly do);
    //
    //  this avoids
    //      - starving DNS by failing to update priority
    //      - avoids unnecessary sends when NAME_ERROR would terminate
    //      send on adapter with duplicate DNS
    //

    for ( i=0; i<pNetInfo->AdapterCount; i++ )
    {
        PDNS_ADAPTER    padapter;
        PDNS_ADDR_ARRAY pserverArray;
        DWORD           j;
        PDNS_ADDR       pserver;
        DWORD           newPriority;
        BOOL            fpriReset = FALSE;

        padapter = NetInfo_GetAdapterByIndex( pNetInfo, i );

        pserverArray = padapter->pDnsAddrs;
        if ( !pserverArray )
        {
            DNSDBG( SEND, (
                "WARNING:  Adapter %d -- no DNS servers!\n",
                padapter->InterfaceIndex ));
            continue;
        }

        for ( j=0; j<pserverArray->AddrCount; j++ )
        {
            pserver = &pserverArray->AddrArray[j];

            if ( !DnsAddr_IsEqual( pAddr, pserver, DNSADDR_MATCH_ADDR ) )
            {
                continue;
            }
            pserver->Status = Status;
#if DBG
            freset = TRUE;
#endif
            //
            //  no DNS running
            //
            //  WSAECONNRESET reported for reception of ICMP unreachable, so
            //  no DNS is currently running on the IP;  that's a severe
            //  priority drop, worse than just TIMEOUT
            //

            if ( Status == WSAECONNRESET )
            {
                newPriority = pserver->Priority - SRVPRI_NO_DNS_DROP;
                fpriReset = TRUE;
                break;
            }

            //  if SERVER_FAILURE rcode, may or may not indicate problem,
            //      (may be simply unable to contact remote DNS)
            //      but it certainly suggests trying other DNS servers in
            //      the list first
            //
            //  DCR_FIX:  SEVRFAIL response priority reset
            //      the explicitly correct approach would be to flag the
            //      SERVER_FAILURE error, but NOT reset the priority unless
            //      at the end of the query, we find another server in the list
            //      got a useful response

            if ( Status == DNS_ERROR_RCODE_SERVER_FAILURE )
            {
                newPriority = pserver->Priority - SRVPRI_SERVFAIL_DROP;
                fpriReset = TRUE;
                break;
            }

            //
            //  other status code indicates functioning DNS server,
            //      - reset the server's priority

            if ( (LONG)pserver->Priority < SRVPRI_RESPONSE )
            {
                newPriority = SRVPRI_RESPONSE;
                fpriReset = TRUE;
            }

            //
            //  NAME_ERROR or AUTH-EMPTY response
            //      - save to server list for adapter to eliminate all
            //        further retries on this adapter's list
            //      - if not waiting for all adapters, then
            //        NAME_ERROR or no-records is terminal

            if ( Status == DNS_ERROR_RCODE_NAME_ERROR ||
                 Status == DNS_INFO_NO_RECORDS )
            {
                padapter->Status = Status;
                padapter->RunFlags |= RUN_FLAG_STOP_QUERY_ON_ADAPTER;
                pNetInfo->ReturnFlags |= RUN_FLAG_HAVE_VALID_RESPONSE;

                if ( !g_WaitForNameErrorOnAll )
                {
                    fterminalNameError = TRUE;
                }
            }
            break;
        }

        //
        //  priority reset?
        //      - never reset loopback -- this keeps this first
        //      - other

        if ( fpriReset )
        {
            serverPriorityChange(
                pNetInfo,
                padapter,
                pserver,
                newPriority );
        }

        //
        //  end immediately on terminal NAME_ERROR
        //      - jumping here rather than above only to simplify
        //      handling of pri-rest (special casing of loopback, etc.)
        //

        if ( fterminalNameError )
        {
            goto Done;
        }

        //
        //  do running check that still adapter worth querying
        //      - not ignoring in first place
        //      - hasn't received NAME_ERROR or AUTH_EMPTY response
        //
        //  this is "at recv" check -- only trying to determine if we
        //  should stop query RIGHT NOW as a result of this receive;
        //  this does NOT check on whether there are any other servers
        //  worth querying as that is done when go back for next send
        //
        //  note how this works -- result starts as NAME_ERROR, when find
        //      ANY adapter that hasn't gotten terminal response, then
        //      result shifts (and stays) at ERROR_SUCCESS
        //
        //  note, if we fix the twice through list issue above, then have to
        //  change this so don't skip adapter lists after IP is found
        //

        if ( !(padapter->RunFlags & RUN_FLAG_COMBINED_IGNORE_ADAPTER) )
        {
            result = ERROR_SUCCESS;
        }
    }

Done:

#if DBG
    if ( !freset )
    {
        DNSDBG( ANY, (
            "ERROR:  DNS server %s not in list.\n",
            DNSADDR_STRING( pAddr ) ));
        DNS_ASSERT( FALSE );
    }
#endif
    return( result );
}



PDNS_ADDR
bestDnsServerForNextSend(
    IN      PDNS_ADAPTER     pAdapter
    )
/*++

Routine Description:

    Get best DNS server IP address from list.

Arguments:

    pAdapter -- struct with list of DNS servers

Return Value:

    Ptr to server info of best send.
    NULL if no server on adapter is worth sending to;  this is
        the case if all servers have received a response.

--*/
{
    PDNS_ADDR       pserver;
    PDNS_ADDR_ARRAY pserverArray;
    PDNS_ADDR       pbestServer = NULL;
    DWORD           j;
    DWORD           status;
    LONG            priority;
    LONG            priorityBest = MINLONG;
    DWORD           sent;
    DWORD           sentBest = MAXDWORD;


    DNSDBG( SEND, (
        "Enter bestDnsServerForNextSend( %p )\n",
        pAdapter ));

    if ( !pAdapter || !(pserverArray = pAdapter->pDnsAddrs) )
    {
        DNSDBG( SEND, (
            "WARNING:  Leaving bestDnsServerForNextSend, no server list\n" ));
        return( NULL );
    }

    //
    //  if already received name error on server in this list, done
    //
    //  DCR:  single flag test for no further query on this adapter
    //

    if ( pAdapter->Status == DNS_ERROR_RCODE_NAME_ERROR ||
         pAdapter->Status == DNS_INFO_NO_RECORDS )
    {
        DNSDBG( SEND, (
            "Leaving bestDnsServerForNextSend, NAME_ERROR already received\n"
            "\ton server in server list %p\n",
            pAdapter ));
        return( NULL );
    }

    //
    //  check each server in list
    //

    for ( j=0; j<pserverArray->AddrCount; j++ )
    {
        pserver = &pserverArray->AddrArray[j];

        //
        //  skip server?
        //      - already recieved a response
        //      - or failed in send
        //      - or already sent in current retry
        //

        if ( TEST_SERVER_VALID_RECV(pserver) )
        {
            //  NAME_ERROR or EMPTY_AUTH then adapter should have been
            //      marked as "done" and we shouldn't be here
            //  NO_ERROR should have exited immediately

            DNS_ASSERT( pserver->Status != NO_ERROR &&
                        pserver->Status != DNS_ERROR_RCODE_NAME_ERROR &&
                        pserver->Status != DNS_INFO_NO_RECORDS );
            continue;
        }
        if ( TEST_SERVER_STATE( pserver, SRVFLAG_SENT_THIS_RETRY ) )
        {
            continue;
        }

        //
        //  check for best priority
        //      - ideal is unsent, high priority server
        //
        //  DCR:  skip NO_DNS server for a while
        //        skip timeout server for a little while
        //      perhaps this should be done be ignoring these
        //      when list is sent down?
        //
        //  three cases based on sent\not:
        //      - server not sent, best has been sent
        //          => become best unless priority at NO_DNS level
        //      - sent levels equal
        //          => become best based on best priority
        //      - server has sent, best has not
        //          => become best only if current best at NO_DNS level, and
        //          we're higher
        //          

        priority = (LONG) pserver->Priority;
        sent = TEST_SERVER_STATE( pserver, SRVFLAG_SENT );

        if ( !pbestServer )
        {
            //  no-op, we become the best
        }
        else if ( sent < sentBest )
        {
            if ( priority < SRVPRI_NO_DNS )
            {
                continue;
            }
        }
        else if ( sent == sentBest )
        {
            if ( priority < priorityBest )
            {
                continue;
            }
        }
        else    // sent already, best has not
        {
            if ( priority < priorityBest ||
                 priorityBest > SRVPRI_NO_DNS )
            {
                continue;
            }
        }

        //  found new best server
        //      - save "best" info for comparison
        //      - declare immediate victory if unsent and high priority

        pbestServer = pserver;
        priorityBest = priority;
        sentBest = sent;

        if ( priority >= 0 && !sent )
        {
            break;
        }
    }

    return( pbestServer );
}



VOID
markDuplicateSends(
    IN OUT  PDNS_NETINFO        pNetInfo,
    IN      PDNS_ADDR           pSendServer
    )
/*++

Routine Description:

    Mark any matching servers to avoid duplicate sends.

Arguments:

    pNetInfo    -- network info blob for send

    pSendServer -- DNS server being sent to

Return Value:

    None

--*/
{
    DWORD   i;

    DNSDBG( SEND, (
        "Enter markDuplicateSends( %p, %p )\n",
        pNetInfo,
        pSendServer ));

    if ( !pNetInfo )
    {
        DNS_ASSERT( FALSE );
        return;
    }

    //
    //  find matching DNS servers
    //      - note check MUST include scope as different scope
    //      is different DNS
    //
    //  mark matches as sent, sent this pass
    //  note:  currently there is no reason that flags should not
    //      exactly match, so just copy flags
    //

    for ( i=0; i<pNetInfo->AdapterCount; i++ )
    {
        PDNS_ADAPTER    padapter;
        PDNS_ADDR_ARRAY pserverArray;
        DWORD           j;

        padapter = NetInfo_GetAdapterByIndex( pNetInfo, i );
    
        pserverArray = padapter->pDnsAddrs;
        if ( !pserverArray )
        {
            continue;
        }
        for ( j=0; j<pserverArray->AddrCount; j++ )
        {
            PDNS_ADDR   pserver = &pserverArray->AddrArray[j];

            if ( DnsAddr_IsEqual(
                    pserver,
                    pSendServer,
                    DNSADDR_MATCH_ADDR ) )
            {
                if ( pserver != pSendServer )
                {
                    DNSDBG( SEND, (
                        "Marking duplicate server %p on adapter %d\n",
                        pserver,
                        padapter->InterfaceIndex ));

                    pserver->Flags = pSendServer->Flags;
                    DNS_ASSERT( pserver->Status == pSendServer->Status );
                }
                padapter->RunFlags |= (RUN_FLAG_SENT | RUN_FLAG_SENT_THIS_RETRY);
            }
        }
    }
}



DNS_STATUS
sendUsingServerInfo(
    IN OUT  PDNS_MSG_BUF    pMsg,
    IN OUT  PDNS_NETINFO    pNetInfo,
    IN OUT  PDNS_ADDR       pServInfo
    )
/*++

Routine Description:

    Send DNS message using server info.

    This function encapsulates the process of checking
    server info for validity, sending (as appropriate)
    and marking server, netinfo info.

    Note:  right now this is UDP only

Arguments:

    pMsg - message info for message to send

    pNetInfo - netinfo blob for send

    pServInfo - info of server to send to

Return Value:

    ERROR_SUCCESS if successful.
    ErrorCode on send failure.

--*/
{
    DNS_STATUS      status;
    BOOL            fnoOpt;

    DNSDBG( SEND, (
        "sendUsingServerInfo( msg=%p, ni=%p, servinfo=%p )\n",
        pMsg,
        pNetInfo,
        pServInfo ));

    //
    //  check that haven't
    //      - already completed send\recv
    //      - sent this pass
    //

    if ( TEST_SERVER_VALID_RECV( pServInfo ) ||
         TEST_SERVER_STATE( pServInfo, SRVFLAG_SENT_THIS_RETRY ) )
    {
        DNSDBG( SEND, (
            "Skipping send on server %p -- %s.\n",
            pServInfo,
            ( TEST_SERVER_VALID_RECV( pServInfo ) )
                ? "has valid recv"
                : "already sent this retry" ));
        return  DNS_ERROR_NO_SEND;
    }

    //
    //  check OPT status
    //      - previous OPT send that timed OUT, then send non-OPT
    //
    //  DCR:  known OPT-ok list could screen wasted send

    fnoOpt = TEST_SERVER_STATE( pServInfo, SRVFLAG_SENT_OPT );

    //
    //  send
    //

    status = Send_MessagePrivate(
                pMsg,
                pServInfo,
                fnoOpt );

    if ( status == ERROR_SUCCESS )
    {
        DNS_ASSERT( !fnoOpt || !pMsg->fLastSendOpt );

        SET_SERVER_STATE(
            pServInfo,
            pMsg->fLastSendOpt
                ? (SRVFLAG_SENT_OPT | SRVFLAG_SENT_THIS_RETRY)
                : (SRVFLAG_SENT_NON_OPT | SRVFLAG_SENT_THIS_RETRY)
            );

        //  screen out duplicate sends

        markDuplicateSends( pNetInfo, pServInfo );
    }
    else
    {
        pServInfo->Status = status;
    }

    return  status;
}



DNS_STATUS
SendUdpToNextDnsServers(
    IN OUT  PDNS_MSG_BUF        pMsgSend,
    IN OUT  PDNS_NETINFO        pNetInfo,
    IN      DWORD               cRetryCount,
    IN      DWORD               dwTimeout,
    OUT     PDWORD              pSendCount
    )
/*++

Routine Description:

    Sends to next DNS servers in list.

Arguments:

    pMsgSend    -- message to send

    pNetInfo    -- per adapter DNS info

    cRetryCount -- retry for this send

    dwTimeout   -- timeout on last send, if timed out

    pSendCount  -- addr to receive send count

Return Value:

    ERROR_SUCCESS if successful send.
    ERROR_TIMEOUT if no DNS servers left to send to.
    Winsock error code on send failure.

--*/
{
    DWORD               i;
    DWORD               j;
    DWORD               sendCount = 0;
    BOOL                fignoredAdapter = FALSE;
    PDNS_ADAPTER        padapter;
    PDNS_ADDR_ARRAY     pserverArray;
    PDNS_ADDR           pserver;
    DNS_STATUS          status = ERROR_TIMEOUT;

    DNSDBG( SEND, (
        "Enter SendUdpToNextDnsServers()\n"
        "\tretry = %d\n",
        cRetryCount ));


    //
    //  if netinfo not initialized for send, init
    //

    if ( !(pNetInfo->ReturnFlags & RUN_FLAG_NETINFO_PREPARED) )
    {
        DNSDBG( SEND, ( "Netinfo not prepared for send -- preparing now.\n" ));

        NetInfo_Clean(
            pNetInfo,
            CLEAR_LEVEL_QUERY );
    }

#if DBG
    //
    //  verify i'm getting a clean list on start
    //

    if ( cRetryCount == 0 )
    {
        for ( i=0; i<pNetInfo->AdapterCount; i++ )
        {
            padapter = NetInfo_GetAdapterByIndex( pNetInfo, i );

            //  ignore this adapter because there are no DNS
            //  servers configured?

            if ( padapter->InfoFlags & AINFO_FLAG_IGNORE_ADAPTER )
            {
                continue;
            }
            DNS_ASSERT( !(padapter->RunFlags &
                            (   RUN_FLAG_SENT_THIS_RETRY |
                                RUN_FLAG_SENT |
                                RUN_FLAG_HAVE_VALID_RESPONSE ) ) );
            DNS_ASSERT( padapter->Status == 0 );

            pserverArray = padapter->pDnsAddrs;
            if ( !pserverArray )
            {
                continue;
            }
            for ( j=0; j<pserverArray->AddrCount; j++ )
            {
                DNS_ASSERT( pserverArray->AddrArray[j].Status == SRVSTATUS_NEW );
                DNS_ASSERT( pserverArray->AddrArray[j].Flags == SRVFLAG_NEW );
            }
        }
    }
#endif

    //
    //  if previous send timed out, update adapter list
    //      - but ONLY do this when sending to individual servers in list
    //      - timeout on all servers just produces an unnecessary copy and
    //      can only change ordering relative to servers which have already
    //      responded with RCODE;  since its a timeout, this isn't going to
    //      lower these server's priority so no point
    //

    if ( dwTimeout  &&  cRetryCount  &&  cRetryCount < MAX_SINGLE_SERVER_RETRY )
    {
        timeoutDnsServers( pNetInfo, dwTimeout );
    }

    //
    //  clean "sent this retry" bit on all servers
    //
    //  this allows us to track when server has already been
    //      sent to on this pass and avoid duplicate send
    //

    for ( i=0; i<pNetInfo->AdapterCount; i++ )
    {
        padapter = NetInfo_GetAdapterByIndex( pNetInfo, i );

        padapter->RunFlags &= CLEAR_LEVEL_RETRY;

        pserverArray = padapter->pDnsAddrs;
        if ( !pserverArray )
        {
            continue;
        }
        for ( j=0; j<pserverArray->AddrCount; j++ )
        {
            CLEAR_SERVER_RETRY_STATE( & pserverArray->AddrArray[j] );
        }
    }

    //
    //  send on DNS server(s) for adapter(s)
    //

    for ( i=0; i<pNetInfo->AdapterCount; i++ )
    {
        padapter = NetInfo_GetAdapterByIndex( pNetInfo, i );

        //
        //  skip this adapter
        //      - no servers
        //      - not querying this adapter name
        //      - already responded to this name
        //      or
        //      - unreachable DNS servers and either of
        //          - have at least some response (NAME_ERROR) from another
        //              adapter's DNS server
        //          - first try on this query;  in this case, note skipping the
        //          adapter so we can use it, if no valid DNS are found
        //
        //  note, the goal here is to keep adapters with "unreachable" DNS servers
        //  around to resolve, but NOT wait for timeouts on them if other adapter's
        //  servers have already NAME_ERROR'd
        //
        //  DCR:  go back to simple IGNORE check on unreachable adapter IF
        //          - could verify unreachability of DNS server
        //          but want to do this at run time, when other DNS servers are
        //          not coming through,  rather than when we build netinfo list itself
        //
    
        pserverArray = padapter->pDnsAddrs;
        if ( !pserverArray )
        {
            continue;
        }
        if ( padapter->RunFlags & RUN_FLAG_STOP_QUERY_ON_ADAPTER )
        {
            continue;
        }
    
        if ( padapter->InfoFlags &
                (AINFO_FLAG_IGNORE_ADAPTER |
                 AINFO_FLAG_SERVERS_IP6_DEFAULT |
                 AINFO_FLAG_SERVERS_AUTO_LOOPBACK ) )
        {
            if ( pNetInfo->ReturnFlags & RUN_FLAG_HAVE_VALID_RESPONSE )
            {
                continue;
            }
            if ( cRetryCount == 0 )
            {
                 fignoredAdapter = TRUE;
                 continue;
            }
        }
    
        //
        //  first three attempts, we only go to one DNS on a given adapter
        //
        //      - first time through ONLY to first server in first adapter list
        //      - on subsequent tries go to best server in all lists
        //
    
        if ( cRetryCount < MAX_SINGLE_SERVER_RETRY )
        {
            //
            //  do this in loop, in case send to "best" server fails
            //
    
            while ( 1 )
            {
                pserver = bestDnsServerForNextSend( padapter );
                if ( !pserver )
                {
                    break;      // no more unsent servers
                }
                status = sendUsingServerInfo(
                            pMsgSend,
                            pNetInfo,
                            pserver );
    
                if ( status == ERROR_SUCCESS )
                {
                    sendCount++;
                    if ( cRetryCount == 0 )
                    {
                        goto Done;
                    }
                    break;      //  continue with next adapter
                }
                //  send failed on server, try another
            }
        }
    
        //
        //  after first three tries, send to all servers that
        //  have not already responded (have RCODE, as if NO_ERROR) we
        //  already finished
        //
    
        else
        {
            for ( j=0; j<pserverArray->AddrCount; j++ )
            {
                status = sendUsingServerInfo(
                            pMsgSend,
                            pNetInfo,
                            &pserverArray->AddrArray[j] );

                if ( status == ERROR_SUCCESS )
                {
                    sendCount++;
                }
            }
        }
    }

    //
    //  no reachable DNS servers -- but possibly reachable ones?
    //
    //  if first pass and we found NO reachable DNS servers, BUT
    //  we skipped over some unreachable ones -- use them
    //
    //  note that fignoreAdapter is sufficient test, because it can
    //  only be set on cRetryCount == 0, which will jump directly to
    //  Done:  label on a successful send
    //
    //  note that we are doing this by tail recursion (just to keep it
    //  simple) and the recursion termination is guaranteed by bumping
    //  the retry count
    //

    if ( fignoredAdapter )
    {
        return  SendUdpToNextDnsServers(
                    pMsgSend,
                    pNetInfo,
                    1,      // bump retry count to 1
                    dwTimeout,
                    pSendCount );
    }

Done:

    //
    //  if sent packet, success
    //

    *pSendCount = sendCount;

    DNSDBG( SEND, (
        "Leave SendUdpToNextDnsServers()\n"
        "\tsends = %d\n",
        sendCount ));

    if ( sendCount )
    {
        return( ERROR_SUCCESS );
    }

    //  if no packets sent, alert caller we're done
    //      - this is possible if servers have responded uselessly
    //      (NAME_ERROR, SERVER_FAILURE)

    if ( status == ERROR_SUCCESS )
    {
        status = ERROR_TIMEOUT;
    }
    return( status );
}




//
//  Message addressing routines
//

VOID
Send_SetMsgRemoteSockaddr(
    IN OUT  PDNS_MSG_BUF    pMsg,
    IN      PDNS_ADDR       pAddr
    )
/*++

Routine Description:

    Initialize remote sockaddr.

Arguments:

    pMsg - message to send

    pAddr - IP address to send

Return Value:

    None.

--*/
{
    //
    //  fill in sockaddr for IP4 or IP6
    //

    DnsAddr_Copy(
        & pMsg->RemoteAddress,
        pAddr );

    pMsg->RemoteAddress.SockaddrIn.sin_port = DNS_PORT_NET_ORDER;
}



VOID
Send_SetMessageForRecv(
    IN OUT  PDNS_MSG_BUF    pMsgRecv,
    IN      PDNS_MSG_BUF    pMsgSend
    )
/*++

Routine Description:

    Set message for recv.

Arguments:

    pMsgRecv - ptr message to recv

    pMsgSend - ptr to message sent

Return Value:

    None

--*/
{
    DNSDBG( SOCKET, (
        "Send_SetMessageForRecv( %p, %p )\n", pMsgRecv, pMsgSend ));

    //
    //  TCP -- single connection at a time
    //      -- sockaddr not filled in during recv(), so fill it in now
    //

    if ( pMsgSend->fTcp )
    {
        pMsgRecv->fTcp;
        pMsgRecv->Socket = pMsgSend->Socket;

        RtlCopyMemory(
            & pMsgRecv->RemoteAddress,
            & pMsgSend->RemoteAddress,
            sizeof(DNS_ADDR) );
    }

    //
    //  UDP -- can recv on either 4 or 6 socket
    //      -- sockaddr buffer must accomodate either
    //

    else
    {
        pMsgRecv->Socket  = 0;
        pMsgRecv->Socket4 = pMsgSend->Socket4;
        pMsgRecv->Socket6 = pMsgSend->Socket6;

        pMsgRecv->RemoteAddress.SockaddrLength = DNS_ADDR_MAX_SOCKADDR_LENGTH;
    }
}



PDNS_ADDR   
Send_CopyRecvIp(
    OUT     PDNS_ADDR       pAddr,
    IN      PDNS_MSG_BUF    pMsg
    )
/*++

Routine Description:

    Copy address from recv.

Arguments:

    pAddr - addr of IP address to recv copy

    pMsg - message to send

Return Value:

    Ptr to addr written -- if successful.
    NULL on bad recv addr.

--*/
{
    INT family;

    DnsAddr_Copy(
        pAddr,
        & pMsg->RemoteAddress );

    if ( DnsAddr_Family(pAddr) )
    {
        return  pAddr;
    }
    else
    {
        DnsAddr_Clear( pAddr );

        DNSDBG( ANY, (
            "ERROR:  invalid recv sockaddr (family %d) for message %p!\n",
            pMsg->RemoteAddress.Sockaddr.sa_family,
            pMsg ));
        return  NULL;
    }
}



//
//  Send routines
//

DNS_STATUS
Send_MessagePrivate(
    IN OUT  PDNS_MSG_BUF    pMsg,
    IN      PDNS_ADDR       pSendAddr,
    IN      BOOL            fNoOpt
    )
/*++

Routine Description:

    Send a DNS packet.

    This is the generic send routine used for ANY send of a DNS message.

    It assumes nothing about the message type, but does assume:
        - pCurrent points at byte following end of desired data
        - RR count bytes are in HOST byte order

Arguments:

    pMsg - message info for message to send

    pSendAddr - ptr to IP address to send to
        OPTIONAL, required only if UDP and message sockaddr not set

    fIp4 -- TRUE if IP4, FALSE for IP6

    fNoOpt - TRUE if OPT send is forbidden

Return Value:

    TRUE if successful.
    FALSE on send error.

--*/
{
    PDNS_HEADER pmsgHead;
    INT         err;
    WORD        sendLength;
    BOOL        fexcludedOpt = FALSE;

    DNSDBG( SEND, (
        "Send_MessagePrivate()\n"
        "\tpMsg         = %p\n"
        "\tpSendAddr    = %p\n"
        "\tNo OPT       = %d\n",
        pMsg,
        pSendAddr,
        fNoOpt ));

    //
    //  set header flags
    //
    //  note:  since route sends both queries and responses
    //      caller must set these flags
    //

    pmsgHead = &pMsg->MessageHead;
    pmsgHead->Reserved = 0;

    //
    //  set send IP (if given)
    //

    if ( pSendAddr )
    {
        Send_SetMsgRemoteSockaddr(
            pMsg,
            pSendAddr );
    }

    //
    //  set message length and OPT inclusion
    //
    //  OPT approach is
    //      - write to pCurrent packet end
    //          - handles NO OPT written and using OPT
    //      - unless HAVE written OPT, and specifically excluding
    //          note, that zero IP (TCP previously connected) gets
    //          excluded
    //
    //  DCR:  we haven't handled OPT for TCP connected and not-aware of IP
    //      case here
    //
    //  DCR:  for now excluding OPT on updates, because harder to detect on
    //      the recv end why the reason for the failure
    //

    {
        PCHAR   pend = pMsg->pCurrent;

        if ( pMsg->pPreOptEnd
                &&
             ( fNoOpt 
                    ||
               g_UseEdns == 0
                    ||
               pMsg->MessageHead.Opcode == DNS_OPCODE_UPDATE
                    ||
               //Send_IsServerOptExclude( &pMsg->RemoteIp ) ) )
               ( pSendAddr && Send_IsServerOptExclude( pSendAddr ) ) ) )

        {
            ASSERT( pMsg->pPreOptEnd > (PCHAR)pmsgHead );
            ASSERT( pMsg->pPreOptEnd < pend );

            pend = pMsg->pPreOptEnd;
            pmsgHead->AdditionalCount--;
            fexcludedOpt = TRUE;
        }

        sendLength = (WORD)(pend - (PCHAR)pmsgHead);

        pMsg->fLastSendOpt = (pMsg->pPreOptEnd && (pend != pMsg->pPreOptEnd));
    }

    IF_DNSDBG( SEND )
    {
        pMsg->MessageLength = sendLength;
        DnsDbg_Message(
            "Sending packet",
            pMsg );
    }

    //
    //  flip header count bytes
    //

    DNS_BYTE_FLIP_HEADER_COUNTS( pmsgHead );

    //
    //  TCP -- send until all info transmitted
    //

    if ( pMsg->fTcp )
    {
        PCHAR   psend;

        //
        //  TCP message always begins with bytes being sent
        //
        //      - send length = message length plus two byte size
        //      - flip bytes in message length
        //      - send starting at message length
        //

        pMsg->MessageLength = htons( sendLength );

        sendLength += sizeof(WORD);

        psend = (PCHAR) &pMsg->MessageLength;

        while ( sendLength )
        {
            err = send(
                    pMsg->Socket,
                    psend,
                    (INT) sendLength,
                    0 );

            if ( err == 0 || err == SOCKET_ERROR )
            {
                err = GetLastError();

                //
                //  WSAESHUTDOWN is ok, client got timed out connection and
                //      closed
                //
                //  WSAENOTSOCK may also occur if FIN recv'd and connection
                //      closed by TCP receive thread before the send
                //

                if ( err == WSAESHUTDOWN )
                {
                    IF_DNSDBG( ANY )
                    {
                        DNS_PRINT((
                            "WARNING:  send() failed on shutdown socket %d.\n"
                            "\tpMsgInfo at %p\n",
                            pMsg->Socket,
                            pMsg ));
                    }
                }
                else if ( err == WSAENOTSOCK )
                {
                    IF_DNSDBG( ANY )
                    {
                        DNS_PRINT((
                            "ERROR:  send() on closed socket %d.\n"
                            "\tpMsgInfo at %p\n",
                            pMsg->Socket,
                            pMsg ));
                    }
                }
                else
                {
                    DNS_LOG_EVENT(
                        DNS_EVENT_SEND_CALL_FAILED,
                        0,
                        NULL,
                        err );

                    IF_DNSDBG( ANY )
                    {
                        DNS_PRINT(( "ERROR:  TCP send() failed, err = %d.\n" ));
                    }
                }
                goto Done;
            }
            sendLength -= (WORD)err;
            psend += err;
        }
    }

    //
    //  UDP
    //

    else
    {
        //
        //  get socket for send
        //
        //  note UDP sockets may or may not be open before send as
        //  don't know whether we need to do send on specific protocols
        //  until sending to address of given protocol
        //

        if ( !Socket_CreateMessageSocket(pMsg) )
        {
            err = GetLastError();
            if ( err == NO_ERROR )
            {
                DNS_ASSERT( err != NO_ERROR );
                err = WSAEPROTONOSUPPORT;
            }
            goto Done;
        }
        DNS_ASSERT( pMsg->Socket != 0 );
        DNS_ASSERT( sendLength <= DNS_RFC_MAX_UDP_PACKET_LENGTH );

        err = sendto(
                    pMsg->Socket,
                    (PCHAR) pmsgHead,
                    sendLength,
                    0,                      
                    (PSOCKADDR) &pMsg->RemoteAddress.Sockaddr,
                    pMsg->RemoteAddress.SockaddrLength
                    );

        if ( err == SOCKET_ERROR )
        {
            err = GetLastError();

            DNS_LOG_EVENT(
                DNS_EVENT_SENDTO_CALL_FAILED,
                0,
                NULL,
                err );

            IF_DNSDBG( ANY )
            {
                DNS_PRINT((
                    "ERROR:  UDP sendto() failed => %d.\n",
                    err ));

                DnsDbg_DnsAddr(
                    "sendto() failed sockaddr",
                    &pMsg->RemoteAddress );

                DnsDbg_Message(
                    "sendto() failed message",
                    pMsg );
            }
            goto Done;
        }
    }

    err = ERROR_SUCCESS;

Done:

    DNS_BYTE_FLIP_HEADER_COUNTS( pmsgHead );

    //  restore OPT in count if required

    if ( fexcludedOpt )
    {
        pmsgHead->AdditionalCount++;
    }

    Trace_LogSendEvent( pMsg, err );

    return( (DNS_STATUS)err );
}



//
//  UDP
//

DNS_STATUS
Recv_Udp(
    IN OUT  PDNS_MSG_BUF    pMsg
    )
/*++

Routine Description:

    Receives DNS message

Arguments:

    pMsg - message buffer for recv

Return Value:

    ERROR_SUCCESS if successful.
    Error status on failure.

--*/
{
    PDNS_HEADER     pdnsHeader;
    LONG            err = ERROR_SUCCESS;
    struct timeval  selectTimeout;
    struct fd_set   fdset;

    DNSDBG( RECV, (
        "Enter Recv_Udp( %p )\n",
        pMsg ));

    DNS_ASSERT( !pMsg->fTcp );

    //
    //  setup recv set
    //

    FD_ZERO( &fdset );

    if ( pMsg->Socket6 )
    {
        FD_SET( pMsg->Socket6, &fdset );
    }
    if ( pMsg->Socket4 )
    {
        FD_SET( pMsg->Socket4, &fdset );
    }
    if ( fdset.fd_count == 0 )
    {
        DNSDBG( ANY, (
            "ERROR:  UDP recv on msg %p with no sockets!\n",
            pMsg ));
        return( ERROR_INVALID_PARAMETER );
    }

    //  set timeout

    if ( pMsg->Timeout > HARD_TIMEOUT_LIMIT &&
         pMsg->Timeout != ONE_HOUR_TIMEOUT )
    {
        DNSDBG( RECV, (
            "ERROR:  timeout %d, exceeded hard limit.\n",
            pMsg->Timeout ));

        return( ERROR_TIMEOUT );
    }
    selectTimeout.tv_usec = 0;
    selectTimeout.tv_sec = pMsg->Timeout;

    pdnsHeader = &pMsg->MessageHead;


    //
    //  wait for stack to indicate packet reception
    //

    err = select( 0, &fdset, NULL, NULL, &selectTimeout );

    if ( err <= 0 )
    {
        if ( err < 0 )
        {
            //  select error
            err = WSAGetLastError();
            DNS_PRINT(( "ERROR:  select() error = %d\n", err ));
            return( err );
        }
        else
        {
            DNS_PRINT(( "ERROR:  timeout on response %p\n", pMsg ));
            return( ERROR_TIMEOUT );
        }
    }

    //
    //  receive
    //

    if ( fdset.fd_count != 1 )
    {
        if ( fdset.fd_count == 0 )
        {
            DNS_ASSERT( FALSE );
            return( ERROR_TIMEOUT );
        }
        DNS_PRINT((
            "WARNING:  Recv_Udp on multiple sockets!\n" ));
    }

    pMsg->Socket = fdset.fd_array[0];

    err = recvfrom(
                pMsg->Socket,
                (PCHAR) pdnsHeader,
                DNS_MAX_UDP_PACKET_BUFFER_LENGTH,
                0,
                &pMsg->RemoteAddress.Sockaddr,
                &pMsg->RemoteAddress.SockaddrLength );

    if ( err == SOCKET_ERROR )
    {
        err = GetLastError();

        Trace_LogRecvEvent(
            pMsg,
            err,
            FALSE       // UDP
            );

        if ( err == WSAECONNRESET )
        {
            DNSDBG( RECV, (
                "Leave Recv_Udp( %p ) with CONNRESET\n",
                pMsg ));
            return( err );
        }

        //  message sent was too big
        //  sender was in error -- should have sent TCP

        if ( err == WSAEMSGSIZE )
        {
            pMsg->MessageLength = DNS_MAX_UDP_PACKET_BUFFER_LENGTH;

            DnsDbg_Message(
                "ERROR:  Recv UDP packet over 512 bytes.\n",
                pMsg );
        }
        IF_DNSDBG( ANY )
        {
            DnsDbg_Lock();
            DNS_PRINT((
                "ERROR:  recvfrom(sock=%d) of UDP request failed.\n"
                "\tGetLastError() = 0x%08lx.\n",
                socket,
                err ));
            DnsDbg_DnsAddr(
                "recvfrom failed sockaddr\n",
                & pMsg->RemoteAddress );
            DnsDbg_Unlock();
        }
        return( err );
    }

    //
    //  successful receive
    //      - save remote IP
    //      - set message length
    //      - flip header fields
    //

    DNS_ASSERT( err <= DNS_MAX_UDP_PACKET_BUFFER_LENGTH );
    pMsg->MessageLength = (WORD)err;
    DNS_BYTE_FLIP_HEADER_COUNTS( &pMsg->MessageHead );

    err = ERROR_SUCCESS;

    Trace_LogRecvEvent(
        pMsg,
        0,
        FALSE       // UDP
        );

    IF_DNSDBG( RECV )
    {
        DnsDbg_Message(
            "Received message",
            pMsg );
    }
    return( err );
}



DNS_STATUS
Send_AndRecvUdpWithParam(
    IN OUT  PDNS_MSG_BUF    pMsgSend,
    OUT     PDNS_MSG_BUF    pMsgRecv,
    IN      DWORD           dwFlags,
    IN      PADDR_ARRAY     pServerList,
    IN OUT  PDNS_NETINFO    pNetInfo
    )
/*++

Routine Description:

    Sends to and waits to recv from remote DNS.

    DCR:  move to use send blob

Arguments:

    pMsgSend - message to send

    ppMsgRecv - and reuse

    dwFlags -- query flags

    pServerList -- list of server to use;  overrides adapter info

    pNetInfo -- adapter list DNS server info

Return Value:

    ERROR_SUCCESS if successful response.
    Error status for "best RCODE" response if rcode.
    ERROR_TIMEOUT on timeout.
    Error status on send\recv failure.

--*/
{
    INT             retry;
    DWORD           timeout;
    DNS_STATUS      status = ERROR_TIMEOUT;
    DNS_ADDR        recvIp;
    PDNS_ADDR       precvIp = NULL;
    DWORD           rcode = 0;
    DWORD           ignoredRcode = 0;
    DWORD           sendCount;
    DWORD           sentCount;
    DWORD           sendTime;
    BOOL            frecvRetry;
    BOOL            fupdate = FALSE;    // prefix
    PDNS_NETINFO    ptempNetInfo = NULL;


    DNSDBG( SEND, (
        "Enter Send_AndRecvUdpWithParam()\n"
        "\ttime             %d\n"
        "\tsend msg at      %p\n"
        "\tsocket           %d\n"
        "\trecv msg at      %p\n"
        "\tflags            %08x\n"
        "\tserver IP array  %p\n"
        "\tadapter info at  %p\n",
        Dns_GetCurrentTimeInSeconds(),
        pMsgSend,
        pMsgSend->Socket,
        pMsgRecv,
        dwFlags,
        pServerList,
        pNetInfo ));

    //  verify params

    if ( !pMsgSend || !pMsgRecv || (!pNetInfo && !pServerList) )
    {
        return( ERROR_INVALID_PARAMETER );
    }

    //
    //  server IP array?
    //      - if given overrides netinfo
    //

    //  should be able to just use update netinfo
    //if ( aipServers && !pNetInfo )
    if ( pServerList )
    {
        ptempNetInfo = NetInfo_CreateFromAddrArray(
                                pServerList,
                                0,          // no single IP
                                FALSE,      // no search info
                                NULL );
        if ( !ptempNetInfo )
        {
            return( DNS_ERROR_NO_MEMORY );
        }
        pNetInfo = ptempNetInfo;
    }

    //
    //  DCR:  allow sockets sent into send functions
    //      - then must know initial state to avoid close
    //

    //
    //  if already have TCP socket -- invalid
    //

    if ( pMsgSend->fTcp && pMsgSend->Socket )
    {
        status = ERROR_INVALID_PARAMETER;
        goto Done;
    }

    pMsgSend->fTcp = FALSE;
    pMsgRecv->Socket = 0;
    pMsgRecv->fTcp = FALSE;

    //  determine UPDATE or standard QUERY

    fupdate = ( pMsgSend->MessageHead.Opcode == DNS_OPCODE_UPDATE );

    //
    //  loop sending until
    //      - receive successful response
    //      or
    //      - receive errors response from all servers
    //      or
    //      - reach final timeout on all servers
    //
    //
    //  DCR:  should support setting of timeouts on individual queries
    //

    retry = 0;
    sendCount = 0;

    while ( 1 )
    {
        if ( fupdate )
        {
            timeout = UpdateTimeouts[retry];
        }
        else
        {
            if ( dwFlags & DNS_QUERY_USE_QUICK_TIMEOUTS )
            {
                timeout = g_QuickQueryTimeouts[retry];
            }
            else
            {
                timeout = g_QueryTimeouts[retry];
            }
        }

        //
        //  zero timeout indicates end of retries for this query type
        //

        if ( timeout == 0 )
        {
            //  save timeout for adapter?
            //
            //  if multiple adapters and some timed out and some
            //  didn't then saving timeout is relevant
            //
            //  DCR:  this doesn't make much sense
            //      the actual test i moved inside the function
        
            if ( pNetInfo &&
                 pNetInfo->AdapterCount > 1 &&
                 ignoredRcode &&
                 status == ERROR_TIMEOUT )
            {
                resetOnFinalTimeout( pNetInfo );
            }
            break;
        }

        //
        //  send to best DNS servers in adapter list
        //      - servers sent to varies according to retry
        //      - send in previous timeout, if some servers did not respond
        //

        status = SendUdpToNextDnsServers(
                    pMsgSend,
                    pNetInfo,
                    retry,
                    sendCount ? pMsgRecv->Timeout : 0,
                    & sendCount );

        sentCount = sendCount;

        if ( status != ERROR_SUCCESS )
        {
            //  if no more servers to send to, done
            DNSDBG( RECV, (
                "No more DNS servers to send message %p\n"
                "\tprevious RCODE = %d\n",
                pMsgSend,
                ignoredRcode ));
            goto ErrorReturn;
        }
        retry++;
        precvIp = NULL;
        rcode = DNS_RCODE_NO_ERROR;
        pMsgRecv->Timeout = timeout;
        DNS_ASSERT( sendCount != 0 );

        frecvRetry = FALSE;
        sendTime = GetCurrentTimeInSeconds();

        //
        //  receive response
        //
        //  note:  the loop is strictly to allow us to drop back into
        //  receive if one server is misbehaving;
        //  in that case we go back into the receive without resending
        //  to allow other servers to respond
        //

        while ( sendCount )
        {
            //
            //  if have to retry recv, adjust down timeout
            //      - note, one second granularity is handled by
            //      rounding up at zero so we wait 0-1s beyond official
            //      timeout value
            //
            //  DCR:  calculate timeouts in ms?
            //

            if ( frecvRetry )
            {
                DWORD  timeLeft;

                timeLeft = timeout + sendTime - GetCurrentTimeInSeconds();

                if ( (LONG)timeLeft < 0 )
                {
                    status = ERROR_TIMEOUT;
                    break;
                }
                else if ( timeLeft == 0 )
                {
                    timeLeft = 1;
                }
                pMsgRecv->Timeout = timeLeft;
            }
            frecvRetry = TRUE;

            Send_SetMessageForRecv( pMsgRecv, pMsgSend );

            status = Recv_Udp( pMsgRecv );

            precvIp = Send_CopyRecvIp( &recvIp, pMsgRecv );

            //  recv wait completed
            //      - if timeout, commence next retry
            //      - if CONNRESET
            //          - indicate NO server on IP
            //          - back to recv if more DNS servers outstanding,
            //      - if success, verify packet

            if ( status != ERROR_SUCCESS )
            {
                if ( status == ERROR_TIMEOUT )
                {
                    break;
                }
                if ( status == WSAECONNRESET )
                {
                    resetServerAfterRecv(
                        pNetInfo,
                        precvIp,
                        status );

                    sendCount--;
                    continue;
                }
            }

            //  no recv
            //      - unexpected winsock errors not handled above
            //      - should always have remote IP on success recv

            if ( !precvIp )
            {
                DNSDBG( ANY, (
                    "Recv error %d -- no recv IP\n",
                    status ));
                DNS_ASSERT( status != ERROR_SUCCESS );
                continue;
            }

            //  check XID match

            if ( pMsgRecv->MessageHead.Xid != pMsgSend->MessageHead.Xid )
            {
                DNS_PRINT(( "WARNING:  Incorrect XID in response. Ignoring.\n" ));
                continue;
            }

            //
            //  check DNS server IP match
            //

            if ( g_QueryIpMatching &&
                 !verifyValidServer( pNetInfo, precvIp ) )
            {
                DNS_PRINT((
                    "WARNING:  Ignoring response from %s to query %p\n"
                    "\tIP does not match valid server\n",
                    DNSADDR_STRING(precvIp),
                    pMsgSend ));
                continue;
            }

            //  valid receive, drop outstanding send count

            sendCount--;

            //
            //  check question match
            //      - this is "Maggs Bug" check
            //      - ASSERT here just to investigate issue locally
            //      and make sure check is not bogus
            //      - specifically doing after sendCount decrement
            //      as this server will NOT send us a valid response
            //      - some servers don't reply with question so ignore
            //      if QuestionCount == 0
            //      

            if ( pMsgRecv->MessageHead.QuestionCount != 0
                    &&
                 !Dns_IsSamePacketQuestion(
                    pMsgRecv,
                    pMsgSend ))
            {
                DNS_PRINT((
                    "ERROR:  Bad question response from server %08x!\n"
                    "\tXID match, but question does not match question sent!\n",
                    recvIp ));
                DNS_ASSERT( FALSE );
                continue;
            }

            //  suck out RCODE

            rcode = pMsgRecv->MessageHead.ResponseCode;

            //
            //  good response?
            //
            //  special case AUTH-EMPTY and delegations
            //
            //      - AUTH-EMPTY gets similar treatment to name error
            //      (this adapter can be considered to be finished)
            //
            //      - referrals can be treated like SERVER_FAILURE
            //      (avoid this server for rest of query;  server may
            //      be fine for direct lookup, so don't drop priority)
            //

            //
            //  DCR_CLEANUP:   functionalize packet-categorization
            //      this would be standard errors
            //      plus AUTH-EMPTY versus referral
            //      plus OPT issues, etc
            //      could be called from TCP side also
            //
            //      then would have separate determination about whether
            //      packet was terminal (below)
            //

            if ( rcode == DNS_RCODE_NO_ERROR )
            {
                if ( pMsgRecv->MessageHead.AnswerCount != 0 || fupdate )
                {
                    goto GoodRecv;
                }

                //
                //  auth-empty
                //      - authoritative
                //      - or from cache, recursive response (hence not delegation)
                //
                //  note:  using dummy RCODE here as "ignored RCODE" serves
                //      the role of "best saved status" and roughly
                //      prioritizes in the way we want
                //
                //  DCR:  could change to "best saved status" as mapping is
                //      pretty much the same;  would explicitly have to
                //      check 

                if ( pMsgRecv->MessageHead.Authoritative == 1 ||
                     ( pMsgRecv->MessageHead.RecursionAvailable == 1 &&
                       pMsgRecv->MessageHead.RecursionDesired ) )
                {
                    DNSDBG( RECV, (
                        "Recv AUTH-EMPTY response from %s\n",
                        DNSADDR_STRING(precvIp) ));
                    rcode = DNS_RCODE_AUTH_EMPTY_RESPONSE;
                    status = DNS_INFO_NO_RECORDS;
                }

                //  referral

                else if ( pMsgRecv->MessageHead.RecursionAvailable == 0 )
                {
                    DNSDBG( RECV, (
                        "Recv referral response from %s\n",
                        DNSADDR_STRING(precvIp) ));

                    rcode = DNS_RCODE_SERVER_FAILURE;
                    status = DNS_ERROR_REFERRAL_RESPONSE;
                }

                //  bogus (bad packet) response

                else
                {
                    rcode = DNS_RCODE_SERVER_FAILURE;
                    status = DNS_ERROR_BAD_PACKET;
                }
            }
            else
            {
                status = Dns_MapRcodeToStatus( (UCHAR)rcode );
            }

            //
            //  OPT failure screening
            //
            //  DCR:  FORMERR overload on OPT for update
            //      unless we read result to see if OPT, no way
            //      to determine if this is update problem or
            //      OPT problem
            //
            //      - note, that checking if in list doesn't work because
            //      of MT issue (another query adds setting)
            //
            //      - could be fixed by setting flag in network info
            //      

            if ( rcode == DNS_RCODE_FORMAT_ERROR &&
                 !fupdate )
            {
                Send_SetServerOptExclude( precvIp );

                //  redo send but explicitly force OPT excluse

                Send_MessagePrivate(
                    pMsgSend,
                    precvIp,
                    TRUE        // exclude OPT
                    );

                sendCount++;
                continue;
            }

            //
            //  error RCODE do NOT terminate query
            //      - SERVER_FAILUREs
            //      - malfunctioning server
            //      - disjoint nets \ DNS namespace issues
            //
            //  RCODE error removes particular server from further consideration
            //  during THIS query
            //
            //  generally the higher RCODEs are more interesting
            //      NAME_ERROR > SERVER_FAILURE
            //      and
            //      update RCODEs > NAME_ERROR
            //  save the highest as return when no ERROR_SUCCESS response
            //
            //  however for query NAME_ERROR is the highest RCODE,
            //  IF it is received on all adapters (if not REFUSED on one
            //  adapter may indicate that there really is a name)
            //
            //  for UPDATE, REFUSED and higher are terminal RCODEs.
            //  downlevel servers (non-UPDATE-aware) servers would give
            //  FORMERR or NOTIMPL, so these are either valid responses or
            //  the zone has a completely busted server which must be detected
            //  and removed
            //
            //
            //  DCR_CLEANUP:   functionalize packet-termination
            //      essentially is this type of packet terminal for
            //      this query;
            //      could be called from TCP side also
            //

            if ( rcode > ignoredRcode )
            {
                ignoredRcode = rcode;
            }

            //
            //  reset server priority for good recv
            //      - return ERROR_SUCCESS unless all adapters
            //      are 
            //      

            status = resetServerAfterRecv(
                        pNetInfo,
                        precvIp,
                        status );

            //
            //  if all adapters are done (NAME_ERROR or NO_RECORDS)
            //      - return NAME_ERROR\NO_RECORDS rcode
            //          NO_RECORDS highest priority
            //          then NAME_ERROR
            //          then anything else

            if ( status == DNS_ERROR_RCODE_NAME_ERROR )
            {
                if ( !fupdate && ignoredRcode != DNS_RCODE_AUTH_EMPTY_RESPONSE )
                {
                    ignoredRcode = DNS_RCODE_NAME_ERROR;
                }
                goto ErrorReturn;
            }

            //
            //  update RCODEs are terminal
            //

            if ( fupdate && rcode >= DNS_RCODE_REFUSED )
            {
                goto ErrorReturn;
            }

            // continue wait for any other outstanding servers
        }

        DNSDBG( RECV, (
            "Failed retry = %d for message %p\n"
            "\tstatus           = %d\n"
            "\ttimeout          = %d\n"
            "\tservers out      = %d\n"
            "\tlast rcode       = %d\n"
            "\tignored RCODE    = %d\n\n",
            (retry - 1),
            pMsgSend,
            status,
            timeout,
            sendCount,
            rcode,
            ignoredRcode ));
        continue;

    }   //  end loop sending/recving packets

    //  
    //  falls here on retry exhausted
    //
    //  note that any ignored RCODE takes precendence over failing
    //  status (which may be winsock error, timeout, or bogus
    //  NAME_ERROR from resetServerPriorities())
    //

ErrorReturn:

    //  this can also hit on winsock error in DnsSend()
    //
    //DNS_ASSERT( ignoredRcode  ||  status == ERROR_TIMEOUT );

    //
    //  error responses from all servers or timeouts
    //

    DNSDBG( RECV, (
        "Error or timeouts from all servers for message %p\n"
        "\treturning RCODE = %d\n",
        pMsgSend,
        ignoredRcode ));

    if ( ignoredRcode )
    {
        //  empty-auth reponse is tracked with bogus RCODE,
        //  switch to status code -- DNS_INFO_NO_RECORDS

        if ( !fupdate && ignoredRcode == DNS_RCODE_AUTH_EMPTY_RESPONSE )
        {
            status = DNS_INFO_NO_RECORDS;
        }
        else
        {
            status = Dns_MapRcodeToStatus( (UCHAR)ignoredRcode );
        }
    }
    goto Done;


GoodRecv:

    resetServerAfterRecv(
        pNetInfo,
        precvIp,
        rcode );

    DNSDBG( RECV, (
        "Recv'd response for query at %p from DNS %s\n",
        pMsgSend,
        DNSADDR_STRING(precvIp) ));

Done:

    //
    //  close UDP sockets
    //
    //  DCR_ENHANCE:  allow for possibility of keeping socket alive
    //

    Socket_CloseMessageSockets( pMsgSend );
    Socket_ClearMessageSockets( pMsgRecv );

    IF_DNSDBG( RECV )
    {
        DNSDBG( SEND, (
            "Leave Send_AndRecvUdp()\n"
            "\tstatus       = %d\n"
            "\ttime         = %d\n"
            "\tsend msg     = %p\n"
            "\trecv msg     = %p\n",
            status,
            Dns_GetCurrentTimeInSeconds(),
            pMsgSend,
            pMsgRecv ));

        DnsDbg_NetworkInfo(
            "Network info after UDP recv\n",
            pNetInfo );
    }

    //  if allocated adapter list free it

    if ( ptempNetInfo )
    {
        NetInfo_Free( ptempNetInfo );
    }

    //  should not return NXRRSET except on update

    ASSERT( fupdate || status != DNS_ERROR_RCODE_NXRRSET );

    return( status );
}



DNS_STATUS
Send_AndRecvMulticast(
    IN OUT  PDNS_MSG_BUF        pMsgSend,
    OUT     PDNS_MSG_BUF        pMsgRecv,
    IN OUT  PDNS_NETINFO        pNetInfo OPTIONAL
    )
/*++

Routine Description:

    Sends to and waits to recv from remote DNS.

Arguments:

    pMsgSend - message to send

    ppMsgRecv - and reuse

    pNetInfo -- adapter list DNS server info

    DCR -   pNetInfo parameter could be leveraged to
            identify specific networks to target a multicast
            query against. For example, there could be a multihomed
            machine that is configured to only multicast on one
            of many adapters, thus filtering out useless mDNS packets.

Return Value:

    ERROR_SUCCESS if successful response.
    NAME_ERROR on timeout.
    Error status on send\recv failure.

--*/
{
#if 1
    return  DNS_ERROR_RCODE_NAME_ERROR;
#else
    SOCKET      s;
    INT         fcreatedSocket = FALSE;
    INT         retry;
    DWORD       timeout;
    DNS_STATUS  status = ERROR_TIMEOUT;
    IP4_ADDRESS recvIp = 0;
    DWORD       rcode = 0;
    DWORD       ignoredRcode = 0;

    DNSDBG( SEND, (
        "Enter Send_AndRecvMulticast()\n"
        "\tsend msg at      %p\n"
        "\tsocket           %d\n"
        "\trecv msg at      %p\n",
        pMsgSend,
        pMsgSend->Socket,
        pMsgRecv ));

    //  verify params

    if ( !pMsgSend || !pMsgRecv )
    {
        return( ERROR_INVALID_PARAMETER );
    }

    if ( pMsgSend->MessageHead.Opcode == DNS_OPCODE_UPDATE )
    {
        return( ERROR_INVALID_PARAMETER );
    }

    //
    //  TCP invalid -- invalid
    //
    //  problem is we either leak TCP socket, or we close
    //  it here and may screw things up at higher level
    //

    if ( pMsgSend->fTcp &&
         (pMsgSend->Socket4 || pMsgSend->Socket6) )
    {
        status = ERROR_INVALID_PARAMETER;
        goto Done;
    }

    pMsgSend->fTcp      = FALSE;
    pMsgRecv->fTcp      = FALSE;
    pMsgRecv->Socket    = 0;
    pMsgRecv->Socket6   = 0;
    pMsgRecv->Socket4   = 0;

    //
    //  loop sending until
    //      - receive successful response
    //      or
    //      - receive errors response from all servers
    //      or
    //      - reach final timeout on all servers
    //

    retry = 0;

    while ( 1 )
    {
        timeout = g_MulticastQueryTimeouts[retry];

        //
        // zero timeout indicates end of retries for this query type
        //

        if ( timeout == 0 )
        {
            break;
        }

        //
        //  send to multicast DNS address
        //

        if ( retry == 0 )
        {       //
    //  setup mcast address
    //

    status = DnsAddr_BuildMcast(
                &addr,
                Family,
                pName
                );
    if ( status != NO_ERROR )
    {
        goto Failed;
    }

    //
    //  create multicast socket
    //      - bound to this address and DNS port
    //

    sock = Socket_Create(
                Family,
                SOCK_DGRAM,
                &addr,
                MCAST_PORT_NET_ORDER,
                FALSE,
                TRUE );

    if ( sock == 0 )
    {
        goto Failed;
    }



            Dns_InitializeMsgRemoteSockaddr( pMsgSend, MCAST_DNS_RADDR );
        }

        Dns_Send( pMsgSend );

        retry++;
        rcode = DNS_RCODE_NO_ERROR;
        pMsgRecv->Timeout = timeout;

        //
        //  receive response
        //
        //  note:  the loop is strictly to allow us to drop back into
        //  receive if one server is misbehaving;
        //  in that case we go back into the receive without resending
        //  to allow other servers to respond
        //

        Send_SetMessageForRecv( pMsgRecv, pMsgSend );

        status = Recv_Udp( pMsgRecv );

        //  recv wait completed
        //      - if timeout, commence next retry
        //      - if CONNRESET
        //          - back to recv if more DNS servers outstanding,
        //          - otherwise equivalent treat as timeout, except with
        //          very long timeout
        //      - if success, verify packet

        if ( status != ERROR_SUCCESS )
        {
            if ( status == ERROR_TIMEOUT )
            {
                continue;
            }
            if ( status == WSAECONNRESET )
            {
                pMsgRecv->Timeout = NO_DNS_PRIORITY_DROP;
                status = ERROR_TIMEOUT;
                continue;
            }
            goto Done;
        }

        //  check XID match

        if ( pMsgRecv->MessageHead.Xid != pMsgSend->MessageHead.Xid )
        {
            DNS_PRINT(( "WARNING:  Incorrect XID in response. Ignoring.\n" ));
            continue;
        }

        //
        //  good response?
        //
        //  special case AUTH-EMPTY and delegations
        //
        //      - AUTH-EMPTY gets similar treatment to name error
        //      (this adapter can be considered to be finished)
        //
        //      - referrals can be treated like SERVER_FAILURE
        //      (avoid this server for rest of query;  server may
        //      be fine for direct lookup, so don't drop priority)
        //

        rcode = pMsgRecv->MessageHead.ResponseCode;

        if ( rcode == DNS_RCODE_NO_ERROR )
        {
            if ( pMsgRecv->MessageHead.AnswerCount != 0 )
            {
                goto Done;
            }

            //  auth-empty

            if ( pMsgRecv->MessageHead.Authoritative == 1 )
            {
                DNSDBG( RECV, (
                    "Recv AUTH-EMPTY response from %s\n",
                    MSG_REMOTE_IPADDR_STRING(pMsgRecv) ));
                rcode = DNS_RCODE_AUTH_EMPTY_RESPONSE;
            }
        }
    }   //  end loop sending/recving packets

Done:

    //
    //  if created socket -- close it
    //
    //  DCR_ENHANCE:  allow for possibility of keeping socket alive
    //

    Socket_CloseMessageSockets( pMsgSend );
    Socket_ClearMessageSockets( pMsgRecv );

    IF_DNSDBG( RECV )
    {
        DNSDBG( SEND, (
            "Leave Send_AndRecvMulticast()\n"
            "\tstatus     = %d\n"
            "\ttime       = %d\n"
            "\tsend msg at  %p\n"
            "\trecv msg at  %p\n",
            status,
            Dns_GetCurrentTimeInSeconds(),
            pMsgSend,
            pMsgRecv ));
    }

    if ( status == ERROR_TIMEOUT )
    {
        status = DNS_ERROR_RCODE_NAME_ERROR;
    }

    return( status );
#endif
}



//
//  TCP routines
//

DNS_STATUS
Send_OpenTcpConnectionAndSend(
    IN OUT  PDNS_MSG_BUF    pMsg,
    IN      PDNS_ADDR       pServAddr,
    IN      BOOL            fBlocking
    )
/*++

Routine Description:

    Connect via TCP to desired server.

Arguments:

    pMsg -- message info to set with connection socket

    pServAddr -- IP of DNS server to connect to

    fBlocking -- blocking connection

Return Value:

    TRUE if successful.
    FALSE on connect error.

--*/
{
    SOCKET  s;
    INT     err;

    //
    //  setup a TCP socket
    //      - INADDR_ANY -- let stack select source IP
    //

    s = Socket_Create(
            DnsAddr_Family( pServAddr ),
            SOCK_STREAM,
            NULL,           // default binding
            0,              // any port
            0               // no flags
            );

    if ( s == 0 )
    {
        DNS_PRINT((
            "ERROR:  unable to create TCP socket to create TCP"
            "\tconnection to %s.\n",
            DNSADDR_STRING( pServAddr ) ));

        pMsg->Socket = 0;
        err = WSAGetLastError();
        if ( !err )
        {
            DNS_ASSERT( FALSE );
            err = WSAENOTSOCK;
        }
        return( err );
    }

    //
    //  set TCP params
    //      - do before connect(), so can directly use sockaddr buffer
    //

    pMsg->fTcp = TRUE;
    Send_SetMsgRemoteSockaddr( pMsg, pServAddr );

    //
    //  connect
    //

    err = connect(
            s,
            & pMsg->RemoteAddress.Sockaddr,
            pMsg->RemoteAddress.SockaddrLength
            );
    if ( err )
    {
        PCHAR   pchIpString;

        err = GetLastError();
        pchIpString = MSG_REMOTE_IPADDR_STRING( pMsg );

        DNS_LOG_EVENT(
            DNS_EVENT_CANNOT_CONNECT_TO_SERVER,
            1,
            &pchIpString,
            err );

        DNSDBG( TCP, (
            "Unable to establish TCP connection to %s.\n"
            "\tstatus = %d\n",
            pchIpString,
            err ));

        Socket_Close( s );
        pMsg->Socket = 0;
        if ( !err )
        {
            err = WSAENOTCONN;
        }
        return( err );
    }

    DNSDBG( TCP, (
        "Connected to %s for message at %p.\n"
        "\tsocket = %d\n",
        MSG_REMOTE_IPADDR_STRING( pMsg ),
        pMsg,
        s ));

    pMsg->Socket = s;

    //
    //  send desired packet
    //

    err = Send_MessagePrivate(
                pMsg,
                NULL,       // no address
                TRUE        // no OPT
                );

    return( (DNS_STATUS)err );

}   // Send_OpenTcpConnectionAndSend



DNS_STATUS
Dns_RecvTcp(
    IN OUT  PDNS_MSG_BUF    pMsg
    )
/*++

Routine Description:

    Receive TCP DNS message.

    EXPORTED (security.c):  Dns_RecvTcp
    EXPORTED rename Recv_Tcp

Arguments:

    pMsg - message info buffer to receive packet;  must contain connected
            TCP socket

Return Value:

    ERROR_SUCCESS if successfully receive a message.
    Error code on failure.

--*/
{
    PCHAR   pchrecv;        // ptr to recv location
    INT     recvLength;     // length left to recv()
    SOCKET  socket;
    INT     err = NO_ERROR;
    WORD    messageLength;
    struct timeval  selectTimeout;
    struct fd_set   fdset;

    DNS_ASSERT( pMsg );

    socket = pMsg->Socket;

    DNSDBG( RECV, (
        "Enter Dns_RecvTcp( %p )\n"
        "\tRecv on socket = %d.\n"
        "\tBytes left to receive = %d\n"
        "\tTimeout = %d\n",
        pMsg,
        socket,
        pMsg->BytesToReceive,
        pMsg->Timeout
        ));

    //
    //  verify socket, setup fd_set and select timeout
    //

    if ( socket == 0 || socket == INVALID_SOCKET )
    {
        return( ERROR_INVALID_PARAMETER );
    }

    FD_ZERO( &fdset );
    FD_SET( socket, &fdset );

    selectTimeout.tv_usec = 0;
    selectTimeout.tv_sec = pMsg->Timeout;

    //
    //  new message -- set to receive message length
    //      - reusing buffer
    //      - new buffer
    //
    //  continuing receive of message
    //

    if ( !pMsg->pchRecv )
    {
        DNS_ASSERT( pMsg->fMessageComplete || pMsg->MessageLength == 0 );

        pchrecv = (PCHAR) &pMsg->MessageLength;
        recvLength = (INT) sizeof( WORD );
    }
    else
    {
        pchrecv = (PCHAR) pMsg->pchRecv;
        recvLength = (INT) pMsg->BytesToReceive;
    }
    DNS_ASSERT( recvLength );


    //
    //  loop until receive the entire message
    //

    while ( 1 )
    {
        //
        //  wait for stack to indicate packet reception
        //

        err = select( 0, &fdset, NULL, NULL, &selectTimeout );
        if ( err <= 0 )
        {
            if ( err < 0 )
            {
                //  select error
                err = WSAGetLastError();
                DNS_PRINT(( "ERROR:  select() error = %p\n", err ));
                return( err );
            }
            else
            {
                Trace_LogRecvEvent(
                    pMsg,
                    ERROR_TIMEOUT,
                    TRUE        // TCP
                    );

                DNS_PRINT(( "ERROR:  timeout on response %p\n", pMsg ));
                return( ERROR_TIMEOUT );
            }
        }

        //
        //  Only recv() exactly as much data as indicated.
        //  Another message could follow during zone transfer.
        //

        err = recv(
                socket,
                pchrecv,
                recvLength,
                0 );

        DNSDBG( TCP, (
            "\nRecv'd %d bytes on TCP socket %d\n",
            err,
            socket ));

        //
        //  TCP FIN received -- error in the middle of a message.
        //

        if ( err == 0 )
        {
            goto FinReceived;
        }

        //
        //  recv error
        //      - perfectly reasonable if shutting down
        //      - otherwise actual recv() error
        //

        if ( err == SOCKET_ERROR )
        {
            goto SockError;
        }

        //
        //  update buffer params
        //

        recvLength -= err;
        pchrecv += err;

        DNS_ASSERT( recvLength >= 0 );

        //
        //  received message or message length
        //

        if ( recvLength == 0 )
        {
            //  done receiving message

            if ( pchrecv > (PCHAR)&pMsg->MessageHead )
            {
                break;
            }

            //
            //  recv'd message length, setup to recv() message
            //      - byte flip length
            //      - continue reception with this length
            //

            DNS_ASSERT( pchrecv == (PCHAR)&pMsg->MessageHead );

            messageLength = pMsg->MessageLength;
            pMsg->MessageLength = messageLength = ntohs( messageLength );
            if ( messageLength < sizeof(DNS_HEADER) )
            {
                DNS_PRINT((
                    "ERROR:  Received TCP message with bad message"
                    " length %d.\n",
                    messageLength ));

                goto BadTcpMessage;
            }
            recvLength = messageLength;

            DNSDBG( TCP, (
                "Received TCP message length %d, on socket %d,\n"
                "\tfor msg at %p.\n",
                messageLength,
                socket,
                pMsg ));

            //  starting recv of valid message length

            if ( messageLength <= pMsg->BufferLength )
            {
                continue;
            }

            //  note:  currently do not realloc

            goto BadTcpMessage;
#if 0
            //
            //  DCR:  allow TCP realloc
            //      - change call signature OR
            //      - return pMsg with ptr to realloced
            //      perhaps better to ignore and do 64K buffer all the time
            //
            //  realloc, if existing message too small
            //

            pMsg = Dns_ReallocateTcpMessage( pMsg, messageLength );
            if ( !pMsg )
            {
                return( GetLastError() );
            }
#endif
        }
    }

    //
    //  Message received
    //  recv ptr serves as flag, clear to start new message on reuse
    //

    pMsg->fMessageComplete = TRUE;
    pMsg->pchRecv = NULL;

    //
    //  return message information
    //      - flip count bytes
    //

    DNS_BYTE_FLIP_HEADER_COUNTS( &pMsg->MessageHead );

    Trace_LogRecvEvent(
        pMsg,
        0,
        TRUE        // TCP
        );

    IF_DNSDBG( RECV )
    {
        DnsDbg_Message(
            "Received TCP packet",
            pMsg );
    }
    return( ERROR_SUCCESS );


SockError:

    err = GetLastError();

#if 0
    //
    //  note:  want non-blocking sockets if doing full async
    //
    //  WSAEWOULD block is NORMAL return for message not fully recv'd.
    //      - save state of message reception
    //
    //  We use non-blocking sockets, so bad client (that fails to complete
    //  message) doesn't hang TCP receiver.
    //

    if ( err == WSAEWOULDBLOCK )
    {
        pMsg->pchRecv = pchrecv;
        pMsg->BytesToReceive = recvLength;

        DNSDBG( TCP, (
            "Leave ReceiveTcpMessage() after WSAEWOULDBLOCK.\n"
            "\tSocket=%d, Msg=%p\n"
            "\tBytes left to receive = %d\n",
            socket,
            pMsg,
            pMsg->BytesToReceive
            ));
        goto CleanupConnection;
    }
#endif

    //
    //  cancelled connection
    //      -- perfectly legal, question is why
    //

    if ( pchrecv == (PCHAR) &pMsg->MessageLength
            &&
          ( err == WSAESHUTDOWN ||
            err == WSAECONNABORTED ||
            err == WSAECONNRESET ) )
    {
        DNSDBG( TCP, (
            "WARNING:  Recv RESET (%d) on socket %d\n",
            err,
            socket ));
        goto CleanupConnection;
    }

    //  anything else is our problem

    DNS_LOG_EVENT(
        DNS_EVENT_RECV_CALL_FAILED,
        0,
        NULL,
        err );

    DNSDBG( ANY, (
        "ERROR:  recv() of TCP message failed.\n"
        "\t%d bytes recvd\n"
        "\t%d bytes left\n"
        "\tGetLastError = 0x%08lx.\n",
        pchrecv - (PCHAR)&pMsg->MessageLength,
        recvLength,
        err ));
    DNS_ASSERT( FALSE );

    goto CleanupConnection;

FinReceived:

    //
    //  valid FIN -- if recv'd between messages (before message length)
    //

    DNSDBG( TCP, (
        "ERROR:  Recv TCP FIN (0 bytes) on socket %d\n",
        socket,
        recvLength ));

    if ( !pMsg->MessageLength && pchrecv == (PCHAR)&pMsg->MessageLength )
    {
        err = DNS_ERROR_NO_PACKET;
        goto CleanupConnection;
    }

    //
    //  FIN during message -- invalid message
    //

    DNSDBG( ANY, (
        "ERROR:  TCP message received has incorrect length.\n"
        "\t%d bytes left when recv'd FIN.\n",
        recvLength ));
    goto BadTcpMessage;


BadTcpMessage:
    {
        PCHAR pchServer = MSG_REMOTE_IPADDR_STRING(pMsg);

        DNS_LOG_EVENT(
            DNS_EVENT_BAD_TCP_MESSAGE,
            1,
            & pchServer,
            0 );
    }
    err = DNS_ERROR_BAD_PACKET;

CleanupConnection:

    //  note:  don't actually close socket
    //      the socket is usually still referenced by the send message
    //      buffer and is closed when the calling function cleans it up

    return  err ? err : DNS_ERROR_BAD_PACKET;
}



DNS_STATUS
Send_AndRecvTcp(
    IN OUT  PSEND_BLOB      pBlob
    )
/*++

Routine Description:

    Sends to and waits to recv from remote DNS.

    INTERNAL public function.

Arguments:

    pBlob -- send info

Return Value:

    ERROR_SUCCESS if successful packet reception.
    Error status on failure.

--*/
{
    DNS_STATUS      status = DNS_ERROR_NO_DNS_SERVERS;
    DWORD           rcode;
    DWORD           i;
    PDNS_NETINFO    pnetInfo;
    PADDR_ARRAY     pallocServerArray = NULL;
    PADDR_ARRAY     pservArray;
    PIP4_ARRAY      pserv4Array;
    PDNS_MSG_BUF    psendMsg;
    PDNS_MSG_BUF    precvMsg;

    DNSDBG( SEND, (
        "Enter Send_AndRecvTcp( %p )\n",
        pBlob ));

    //
    //  unpack
    //

    pnetInfo    = pBlob->pNetInfo;
    pservArray  = pBlob->pServerList;
    pserv4Array = pBlob->pServ4List;
    psendMsg    = pBlob->pSendMsg;
    precvMsg    = pBlob->Results.pMessage;

    //
    //  verify params
    //

    if ( !psendMsg || !precvMsg || (!pnetInfo && !pservArray && !pserv4Array) )
    {
        return( ERROR_INVALID_PARAMETER );
    }

    //
    //  build server IP array?
    //
    //  DCR:  should use netinfo priorities in TCP also
    //  DCR:  need TCP netinfo for IP6
    //  DCR:  handle IP4 array -- here or ABOVE here
    //

    if ( !pservArray )
    {
        //  FIX6:  convert IP4 array here???

        pallocServerArray = NetInfo_ConvertToAddrArray(
                                pnetInfo,
                                NULL,       // all adapters
                                0           // no addr family
                                );
        if ( !pallocServerArray )
        {
            return( DNS_ERROR_NO_MEMORY );
        }
        pservArray = pallocServerArray;
    }

    //
    //  init messages for TCP
    //

    DNS_ASSERT( psendMsg->Socket == 0 );

    psendMsg->fTcp = TRUE;
    psendMsg->Socket = 0;
    SET_MESSAGE_FOR_TCP_RECV( precvMsg );

    //
    //  loop sending until
    //      - receive successful response
    //      or
    //      - receive errors response from all servers
    //      or
    //      - reach final timeout on all servers
    //

    if ( precvMsg->Timeout == 0 )
    {
        precvMsg->Timeout = DEFAULT_TCP_TIMEOUT;
    }

    for( i=0; i<pservArray->AddrCount; i++ )
    {
        //
        //  close any previous connection
        //

        if ( psendMsg->Socket )
        {
            Socket_CloseMessageSockets( psendMsg );
            Socket_ClearMessageSockets( precvMsg );
        }

        //
        //  connect and send to next server
        //

        status = Send_OpenTcpConnectionAndSend(
                    psendMsg,
                    &pservArray->AddrArray[i],
                    TRUE
                    );
        if ( status != ERROR_SUCCESS )
        {
            continue;
        }
        DNS_ASSERT( psendMsg->Socket != INVALID_SOCKET && psendMsg->Socket != 0 );

        //
        //  receive response
        //      - if successful receive, done
        //      - if timeout continue
        //      - other errors indicate some setup or system level problem
        //  note: Dns_RecvTcp will close and zero msg->socket on error!
        //

        Send_SetMessageForRecv( precvMsg, psendMsg );

        status = Dns_RecvTcp( precvMsg );

        //
        //  timed out (or error)
        //      - if end of timeout, quit
        //      - otherwise double timeout and resend
        //

        switch( status )
        {
        case ERROR_SUCCESS:
            break;

        case ERROR_TIMEOUT:

            DNS_PRINT((
                "ERROR:  connected to server at %s\n"
                "\tbut no response to packet at %p\n",
                MSG_REMOTE_IPADDR_STRING( psendMsg ),
                psendMsg
                ));
            continue;

        default:

            DNS_PRINT((
                "ERROR:  connected to server at %s to send packet %p\n"
                "\tbut error %d encountered on receive.\n",
                MSG_REMOTE_IPADDR_STRING( psendMsg ),
                psendMsg,
                status
                ));
            continue;
        }

        //
        //  verify XID match
        //

        if ( precvMsg->MessageHead.Xid != psendMsg->MessageHead.Xid )
        {
            DNS_PRINT((
                "ERROR:  Incorrect XID in response. Ignoring.\n" ));
            continue;
        }

        //
        //  verify question match
        //      - this is "Maggs Bug" check
        //      - ASSERT here just to investigate issue locally
        //      and make sure check is not bogus
        //

        if ( !Dns_IsSamePacketQuestion(
                precvMsg,
                psendMsg ))
        {
            DNS_PRINT((
                "ERROR:  Bad question response from server %s!\n"
                "\tXID match, but question does not match question sent!\n",
                MSG_REMOTE_IPADDR_STRING( psendMsg ) ));

            DNS_ASSERT( FALSE );
            continue;
        }

        //
        //  check response code
        //      - some move to next server, others terminal
        //
        //  DCR_FIX1:  bring TCP RCODE handling in-line with UDP
        //
        //  DCR_FIX:  save best TCP RCODE
        //      preserve RCODE (and message) for useless TCP response
        //      would need to then reset TIMEOUT to success at end
        //      or use these RCODEs as status returns
        //

        rcode = precvMsg->MessageHead.ResponseCode;

        switch( rcode )
        {
        case DNS_RCODE_SERVER_FAILURE:
        case DNS_RCODE_NOT_IMPLEMENTED:
        case DNS_RCODE_REFUSED:

            DNS_PRINT((
                "WARNING:  Servers have responded with failure.\n" ));
            continue;

        default:

            break;
        }
        break;

    }   //  end loop sending/recving UPDATEs

    //
    //  close up final connection
    //      unless set to keep open for reuse
    //

    Socket_CloseMessageSockets( psendMsg );
    Socket_ClearMessageSockets( precvMsg );

    //  if allocated adapter list free it

    if ( pallocServerArray )
    {
        FREE_HEAP( pallocServerArray );
    }

    DNSDBG( SEND, (
        "Leaving Send_AndRecvTcp()\n"
        "\tstatus = %d\n",
        status ));

    return( status );
}



#if 0
DNS_STATUS
Dns_AsyncRecv(
    IN OUT  PDNS_MSG_BUF    pMsgRecv
    )
/*++

Routine Description:

    Drop recv on async socket.

Arguments:

    pMsgRecv - message to receive;  OPTIONAL, if NULL message buffer
        is allocated;
        in either case global pDnsAsyncRecvMsg points at buffer

Return Value:

    ERROR_SUCCESS if successful.
    Error status on failure.

--*/
{
    WSABUF      wsabuf;
    DWORD       bytesRecvd;
    DWORD       flags = 0;

    IF_DNSDBG( RECV )
    {
        DNS_PRINT((
            "Enter Dns_AsyncRecv( %p )\n",
            pMsgRecv ));
    }

    //
    //  allocate buffer if none given
    //

    if ( !pMsgRecv )
    {
        pMsgRecv = Dns_AllocateMsgBuf( MAXWORD );
        if ( !pMsgRecv )
        {
            return( GetLastError() ):
        }
    }
    pDnsAsyncRecvMsg = pMsgRecv;


    //
    //  reset i/o completion event
    //

    ResetEvent( hDnsSocketEvent );
    DNS_ASSERT( hDnsSocketEvent == Dns_SocketOverlapped.hEvent );

    //
    //  drop down recv
    //

    status = WSARecvFrom(
                DnsSocket,
                & wsabuf,
                1,
                & bytesRecvd,           // dummy
                & flags,
                & pMsgRecv->RemoteAddress.Sockaddr,
                & pMsgRecv->RemoteAddress.SockaddrLength,
                & DnsSocketOverlapped,
                NULL                    //  no completion routine
                );


    return( ERROR_SUCCESS );

Failed:

    return( status );
}

#endif



VOID
Dns_InitQueryTimeouts(
    VOID
    )
{
    HKEY  hKey = NULL;
    DWORD status;
    DWORD dwType;
    DWORD ValueSize;
    LPSTR lpTimeouts = NULL;

    g_QueryTimeouts = QueryTimeouts;
    g_QuickQueryTimeouts = QuickQueryTimeouts;
    g_MulticastQueryTimeouts = MulticastQueryTimeouts;

    status = RegOpenKeyExA(
                HKEY_LOCAL_MACHINE,
                NT_TCPIP_REG_LOCATION,
                0,
                KEY_QUERY_VALUE,
                &hKey );

    if ( status )
        return;

    if ( !hKey )
        return;

    status = RegQueryValueExA(
                hKey,
                DNS_QUERY_TIMEOUTS,
                NULL,
                &dwType,
                NULL,
                &ValueSize );

    if ( !status )
    {
        if ( ValueSize == 0 )
        {
            goto GetQuickQueryTimeouts;
        }

        lpTimeouts = ALLOCATE_HEAP( ValueSize );

        if ( lpTimeouts )
        {
            LPSTR StringPtr;
            DWORD StringLen;
            DWORD Timeout;
            DWORD Count = 0;

            status = RegQueryValueExA( hKey,
                                      DNS_QUERY_TIMEOUTS,
                                      NULL,
                                      &dwType,
                                      lpTimeouts,
                                      &ValueSize );

            if ( status ||
                 dwType != REG_MULTI_SZ )
            {
                FREE_HEAP( lpTimeouts );
                goto GetQuickQueryTimeouts;
            }

            StringPtr = lpTimeouts;

            while ( ( StringLen = strlen( StringPtr ) ) != 0 &&
                    Count < DNS_MAX_QUERY_TIMEOUTS )
            {
                Timeout = atoi( StringPtr );

                if ( Timeout )
                    RegistryQueryTimeouts[Count++] = Timeout;

                StringPtr += (StringLen + 1);
            }

            RegistryQueryTimeouts[Count] = 0;
            g_QueryTimeouts = RegistryQueryTimeouts;
            FREE_HEAP( lpTimeouts );
        }
    }

GetQuickQueryTimeouts:

    status = RegQueryValueExA( hKey,
                              DNS_QUICK_QUERY_TIMEOUTS,
                              NULL,
                              &dwType,
                              NULL,
                              &ValueSize );

    if ( !status )
    {
        if ( ValueSize == 0 )
        {
            goto GetMulticastTimeouts;
        }

        lpTimeouts = ALLOCATE_HEAP( ValueSize );

        if ( lpTimeouts )
        {
            LPSTR StringPtr;
            DWORD StringLen;
            DWORD Timeout;
            DWORD Count = 0;

            status = RegQueryValueExA( hKey,
                                      DNS_QUICK_QUERY_TIMEOUTS,
                                      NULL,
                                      &dwType,
                                      lpTimeouts,
                                      &ValueSize );

            if ( status ||
                 dwType != REG_MULTI_SZ )
            {
                FREE_HEAP( lpTimeouts );
                goto GetMulticastTimeouts;
            }

            StringPtr = lpTimeouts;

            while ( ( StringLen = strlen( StringPtr ) ) != 0 &&
                    Count < DNS_MAX_QUERY_TIMEOUTS )
            {
                Timeout = atoi( StringPtr );

                if ( Timeout )
                    RegistryQuickQueryTimeouts[Count++] = Timeout;

                StringPtr += (StringLen + 1);
            }

            RegistryQuickQueryTimeouts[Count] = 0;
            g_QuickQueryTimeouts = RegistryQuickQueryTimeouts;
            FREE_HEAP( lpTimeouts );
        }
    }

GetMulticastTimeouts:

    status = RegQueryValueExA( hKey,
                              DNS_MULTICAST_QUERY_TIMEOUTS,
                              NULL,
                              &dwType,
                              NULL,
                              &ValueSize );

    if ( !status )
    {
        if ( ValueSize == 0 )
        {
            RegCloseKey( hKey );
            return;
        }

        lpTimeouts = ALLOCATE_HEAP( ValueSize );

        if ( lpTimeouts )
        {
            LPSTR StringPtr;
            DWORD StringLen;
            DWORD Timeout;
            DWORD Count = 0;

            status = RegQueryValueExA( hKey,
                                      DNS_MULTICAST_QUERY_TIMEOUTS,
                                      NULL,
                                      &dwType,
                                      lpTimeouts,
                                      &ValueSize );

            if ( status ||
                 dwType != REG_MULTI_SZ )
            {
                FREE_HEAP( lpTimeouts );
                RegCloseKey( hKey );
                return;
            }

            StringPtr = lpTimeouts;

            while ( ( StringLen = strlen( StringPtr ) ) != 0 &&
                    Count < DNS_MAX_QUERY_TIMEOUTS )
            {
                Timeout = atoi( StringPtr );

                if ( Timeout )
                    RegistryMulticastQueryTimeouts[Count++] = Timeout;

                StringPtr += (StringLen + 1);
            }

            RegistryMulticastQueryTimeouts[Count] = 0;
            g_MulticastQueryTimeouts = RegistryMulticastQueryTimeouts;
            FREE_HEAP( lpTimeouts );
        }
    }

    RegCloseKey( hKey );
}



//
//  OPT selection
//
//  These routines track DNS server OPT awareness.
//
//  The paradigm here is to default to sending OPTs, then track
//  OPT non-awareness.
//
//  DCR:  RPC over OPT config info
//      - either two lists (local and from-resolver in process)
//      OR
//      - RPC back OPT failures to resolver
//      OR
//      - flag network info blobs to RPC back to resolver
//
//      security wise, prefer not to get info back
//
//
//  DCR:  OPT info in network info
//      - then don't have to traverse locks
//      - save is identical to current
//      - could exclude OPT on any non-cache sends to
//          handle problem of not saving OPT failures
//

//
//  Global IP array of OPT-failed DNS servers
//

PADDR_ARRAY g_OptFailServerList = NULL;

//  Allocation size for OptFail IP array.
//  Ten servers nicely covers the typical case.

#define OPT_FAIL_LIST_SIZE      10


//
//  Use global lock for OPT list
//

#define LOCK_OPT_LIST()     LOCK_GENERAL()
#define UNLOCK_OPT_LIST()   UNLOCK_GENERAL()



BOOL
Send_IsServerOptExclude(
    IN      PDNS_ADDR       pAddr
    )
/*++

Routine Description:

    Determine if particular server is not OPT aware.

Arguments:

    pAddr -- IP address of DNS server

Return Value:

    TRUE if server should NOT get OPT send.
    FALSE if server should can send OPT

--*/
{
    BOOL    retval;

    //
    //  zero IP -- meaning TCP connect to unknown
    //      => must exclude OPT to allow success, otherwise
    //      we can't retry non-OPT
    //

    if ( !pAddr || DnsAddr_IsEmpty(pAddr) )
    {
        return  TRUE;
    }

    //
    //  no exclusions?
    //      - doing outside lock for perf once we get to
    //      the "fully-deployed" case
    //

    if ( !g_OptFailServerList )
    {
        return  FALSE;
    }
            
    //
    //  see if IP is in OPT list
    //      - only if found do we exclude
    //

    LOCK_OPT_LIST();

    retval = FALSE;

    if ( g_OptFailServerList
            &&
         AddrArray_ContainsAddr(
            g_OptFailServerList,
            pAddr ) )
    {
        retval = TRUE;
    }
    UNLOCK_OPT_LIST();

    return  retval;
}



VOID
Send_SetServerOptExclude(
    IN      PDNS_ADDR        pAddr
    )
/*++

Routine Description:

    Set server for OPT exclusion.

Arguments:

    IpAddress -- IP address of DNS server that failed OPT

Return Value:

    None

--*/
{
    //
    //  screen zero IP (TCP connect to unknown IP)
    //

    if ( !pAddr ||  DnsAddr_IsEmpty(pAddr) )
    {
        return;
    }

    //
    //  put IP in OPT-fail list
    //      - create if doesn't exist
    //      - resize if won't fit
    //          note:  add failure means "won't fit"
    //
    //  note:  only safe to reset global if allocation successful
    //  note:  only one retry to protect alloc failure looping
    //

    LOCK_OPT_LIST();

    if ( ! g_OptFailServerList
            ||
         ! AddrArray_AddAddr(
                g_OptFailServerList,
                pAddr
                ) )
    {
        PADDR_ARRAY pnewList;

        pnewList = DnsAddrArray_CopyAndExpand(
                        g_OptFailServerList,
                        OPT_FAIL_LIST_SIZE,
                        TRUE        // free current
                        );
        if ( pnewList )
        {
            g_OptFailServerList = pnewList;

            AddrArray_AddAddr(
                g_OptFailServerList,
                pAddr
                );
        }
    }

    UNLOCK_OPT_LIST();
}



VOID
Send_CleanupOptList(
    VOID
    )
/*++

Routine Description:

    Dump OPT list for process detach.

Arguments:

    None

Return Value:

    None

--*/
{
    LOCK_OPT_LIST();

    DnsAddrArray_Free( g_OptFailServerList );
    g_OptFailServerList = NULL;

    UNLOCK_OPT_LIST();
}



//
//  Main send routine
//

DNS_STATUS
Send_AndRecv(
    IN OUT  PSEND_BLOB      pBlob
    )
/*++

Routine Description:

    Send message, receive response.

Arguments:

    pBlob -- send blob

Return Value:

    ERROR_SUCCESS if successful.
    Error code on failure.

--*/
{
    PDNS_NETINFO    pnetInfo;
    PIP4_ARRAY      pserv4Array;
    PADDR_ARRAY     pservArray;
    PADDR_ARRAY     pservArrayIn = NULL;
    PADDR_ARRAY     pservArrayAlloc = NULL;
    DWORD           flags;
    PDNS_MSG_BUF    psendMsg;
    PDNS_MSG_BUF    precvMsg;
    PDNS_MSG_BUF    psavedUdpResponse = NULL;
    DNS_STATUS      statusFromUdp = ERROR_SUCCESS;
    DNS_STATUS      status = ERROR_TIMEOUT;
    DNS_STATUS      parseStatus;
    BOOL            ftcp;
    ADDR_ARRAY      tempArray;

    //
    //  unpack
    //

    pnetInfo    = pBlob->pNetInfo;
    pservArray  = pBlob->pServerList;
    pserv4Array = pBlob->pServ4List;
    flags       = pBlob->Flags;
    psendMsg    = pBlob->pSendMsg;
    precvMsg    = pBlob->Results.pMessage;

    pservArrayIn = pservArray;


    DNSDBG( QUERY, (
        "Send_AndRecv( %p )\n",
        pBlob ));

    IF_DNSDBG( QUERY )
    {
        DnsDbg_SendBlob(
            "Send_AndRecv()",
            pBlob );
    }

    //
    //  response buf passed in?
    //  if not allocate one -- big enough for TCP
    //

    if ( !precvMsg )
    {
        precvMsg = pBlob->pRecvMsgBuf;
        if ( !precvMsg )
        {
            precvMsg = Dns_AllocateMsgBuf( DNS_TCP_DEFAULT_PACKET_LENGTH );
            if ( !precvMsg )
            {
                status = DNS_ERROR_NO_MEMORY;
                goto Cleanup;
            }
        }
    }

    //
    //  send packet and get response
    //      - try UDP first unless TCP only
    //

    ftcp = ( flags & DNS_QUERY_USE_TCP_ONLY ) ||
           ( DNS_MESSAGE_CURRENT_OFFSET(psendMsg) >= DNS_RFC_MAX_UDP_PACKET_LENGTH );

    if ( !ftcp )
    {
        if ( flags & DNS_QUERY_MULTICAST_ONLY )
        {
            //
            // If the multicast query fails, then ERROR_TIMEOUT will
            // be returned
            //
            goto DoMulticast;
        }

        if ( pserv4Array && !pservArray )
        {
            pservArrayAlloc = DnsAddrArray_CreateFromIp4Array( pserv4Array );
            pservArray = pservArrayAlloc;
        }

        status = Send_AndRecvUdpWithParam(
                    psendMsg,
                    precvMsg,
                    flags,
                    pservArray,
                    pnetInfo );

        statusFromUdp = status;

        if ( status != ERROR_SUCCESS &&
             status != DNS_ERROR_RCODE_NAME_ERROR &&
             status != DNS_INFO_NO_RECORDS )
        {
            //
            //  DCR:  this multicast ON_NAME_ERROR test is bogus
            //      this isn't NAME_ERROR this is pretty much any error
            //

            if ( pnetInfo &&
                 pnetInfo->InfoFlags & NINFO_FLAG_MULTICAST_ON_NAME_ERROR )
            {
                goto DoMulticast;
            }
            else
            {
                goto Cleanup;
            }
        }

        //  if truncated response switch to TCP

        if ( precvMsg->MessageHead.Truncation &&
            ! (flags & DNS_QUERY_ACCEPT_PARTIAL_UDP) )
        {
            ftcp = TRUE;
            pservArrayIn = pservArray;
            pservArray = &tempArray;
            pBlob->pServerList = pservArray;

            DnsAddrArray_InitSingleWithSockaddr(
                pservArray,
                &precvMsg->RemoteAddress.Sockaddr );

            psavedUdpResponse = precvMsg;
            precvMsg = NULL;
        }
    }

    //
    //  TCP send
    //      - for TCP queries
    //      - or truncation on UDP unless accepting partial response
    //
    //  DCR_FIX:  this precvMsg Free is bad
    //      if message was passed in we shouldn't have it, we should
    //      just do our own thing and ignore this recv buffer somehow
    //      ideally that buffer action is at much higher level
    //      

    if ( ftcp )
    {
        if ( precvMsg &&
             precvMsg->BufferLength < DNS_TCP_DEFAULT_PACKET_LENGTH )
        {
            if ( precvMsg != pBlob->pRecvMsgBuf )
            {
                FREE_HEAP( precvMsg );
            }
            precvMsg = NULL;
        }
        if ( !precvMsg )
        {
            precvMsg = Dns_AllocateMsgBuf( DNS_TCP_DEFAULT_PACKET_LENGTH );
            if ( !precvMsg )
            {
                status = DNS_ERROR_NO_MEMORY;
                goto Cleanup;
            }
        }
        psendMsg->fTcp = TRUE;
        precvMsg->fTcp = TRUE;
#if 0
        if ( flags & DNS_QUERY_SOCKET_KEEPALIVE )
        {
            precvMsg->fSocketKeepalive = TRUE;
        }
#endif
        pBlob->Results.pMessage = precvMsg;

        status = Send_AndRecvTcp( pBlob );

        //
        //  if recursing following truncated UDP query, then
        //      must make sure we actually have better data
        //      - if successful, but RCODE is different and bad
        //          => use UDP response
        //      - if failed TCP => use UDP
        //      - successful with good RCODE => parse TCP response
        //

        if ( psavedUdpResponse )
        {
            if ( status == ERROR_SUCCESS )
            {
                DWORD   rcode = precvMsg->MessageHead.ResponseCode;

                if ( rcode == ERROR_SUCCESS ||
                     rcode == psavedUdpResponse->MessageHead.ResponseCode ||
                     (  rcode != DNS_RCODE_SERVER_FAILURE &&
                        rcode != DNS_RCODE_FORMAT_ERROR &&
                        rcode != DNS_RCODE_REFUSED ) )
                {
                    goto Parse;
                }
            }

            //  TCP failed or returned bum error code

            FREE_HEAP( precvMsg );
            precvMsg = psavedUdpResponse;
            psavedUdpResponse = NULL;
        }

        //  direct TCP query
        //      - cleanup if failed

        else if ( status != ERROR_SUCCESS )
        {
            goto Cleanup;
        }
    }

    //
    //  DCR:  this multicast test is bogus (too wide open)
    //      essentially ANY error sends us on to multicast
    //      even INFO_NO_RECORDS
    //
    //  multicast test should be intelligent
    //      - adpater with no DNS servers, or NO_RESPONSE
    //      from any DNS server
    //  multicast test also has to be skipped for update
    //

    if ( status == ERROR_SUCCESS )
    {
        DWORD   rcode = precvMsg->MessageHead.ResponseCode;

        if ( rcode == ERROR_SUCCESS ||
             ( rcode != DNS_RCODE_SERVER_FAILURE &&
               rcode != DNS_RCODE_FORMAT_ERROR &&
               rcode != DNS_RCODE_REFUSED ) )
        {
            goto Parse;
        }
    }

    //
    //  multicast?
    //

DoMulticast:

    if ( ( pnetInfo &&
           pnetInfo->InfoFlags & NINFO_FLAG_ALLOW_MULTICAST )
         ||
         ( ( flags & DNS_QUERY_MULTICAST_ONLY ) &&
           ! pnetInfo ) )
    {
        if ( !psendMsg ||
             ( psendMsg &&
               ( psendMsg->MessageHead.Opcode == DNS_OPCODE_UPDATE ) ) )
        {
            if ( statusFromUdp )
            {
                status = statusFromUdp;
            }
            else
            {
                status = DNS_ERROR_NO_DNS_SERVERS;
            }
            goto Cleanup;
        }

        status = Send_AndRecvMulticast(
                        psendMsg,
                        precvMsg,
                        pnetInfo );

        if ( status != ERROR_SUCCESS &&
            status != DNS_ERROR_RCODE_NAME_ERROR &&
            status != DNS_INFO_NO_RECORDS )
        {
            if ( statusFromUdp )
            {
                status = statusFromUdp;
            }
            goto Cleanup;
        }
    }

    //
    //  parse response (if desired)
    //
    //  DCR:  this is busted, should have one parsing function to handle
    //      taking fSaveRecords as param
    //      specifically need to tease out NO_RECORDS response even if
    //      not parsing records
    //

Parse:

    if ( pBlob->fSaveRecords )
    {
        parseStatus = Dns_ExtractRecordsFromMessage(
                            precvMsg,
                            //(flags & DNSQUERY_UNICODE_OUT),
                            TRUE,       // unicode results
                            & pBlob->Results.pRecords );

        if ( !(flags & DNS_QUERY_DONT_RESET_TTL_VALUES ) )
        {
            Dns_NormalizeAllRecordTtls( pBlob->Results.pRecords );
        }
    }

    //  not parsing -- just return RCODE as status

    else
    {
        parseStatus = Dns_MapRcodeToStatus( precvMsg->MessageHead.ResponseCode );
    }

    //
    //  get "best" status
    //      - no-records response beats NAME_ERROR (or other error)
    //      dump bogus records from error response
    //
    //  DCR:  multi-adapter NXDOMAIN\no-records response broken
    //      note, here we'd give back a packet with NAME_ERROR
    //      or another error
    //

    if ( status != parseStatus )
    {
        //  save previous NO_RECORDS response, from underlying query
        //  this trumps other errors (FORMERR, SERVFAIL, NXDOMAIN);
        //
        //  note, that parsed message shouldn't be HIGHER level RCODE
        //  as these should beat out NO_RECORDS in original parsing

        if ( status == DNS_INFO_NO_RECORDS &&
             parseStatus != ERROR_SUCCESS )
        {
            ASSERT( precvMsg->MessageHead.ResponseCode <= DNS_RCODE_NAME_ERROR );

            if ( pBlob->Results.pRecords )
            {
                Dns_RecordListFree( pBlob->Results.pRecords );
                pBlob->Results.pRecords = NULL;
            }
        }
        else
        {
            status = parseStatus;
        }
    }


Cleanup:

    //  cleanup recv buffer?
    //
    //  DCR:  should have more definitive "have-response" test

    if ( pBlob->fSaveResponse &&
         (status == ERROR_SUCCESS || Dns_IsStatusRcode(status)) )
    {
        pBlob->Results.pMessage = precvMsg;
    }
    else
    {
        if ( precvMsg != pBlob->pRecvMsgBuf )
        {
            FREE_HEAP( precvMsg );
        }
        pBlob->Results.pMessage = NULL;
    }
    if ( psavedUdpResponse )
    {
        FREE_HEAP( psavedUdpResponse );
    }

    //  set response status

    pBlob->Results.Status = status;

    //  replace original server array, if created
    //      new in TCP fallover

    pBlob->pServerList = pservArrayIn;

    if ( pservArrayAlloc )
    {
        DnsAddrArray_Free( pservArrayAlloc );
    }

    DNSDBG( RECV, (
        "Leaving Send_AndRecv(), status = %s (%d)\n",
        Dns_StatusString(status),
        status ));

    return( status );
}




//
//  Obsolete exported crap
//
//  May be here for ICS
//

DNS_STATUS
Dns_SendEx(
    IN OUT  PDNS_MSG_BUF    pMsg,
    IN      IP4_ADDRESS     IpAddr,     OPTIONAL
    IN      BOOL            fNoOpt
    )
/*++

Routine Description:

    Send a DNS packet.

    This is the generic send routine used for ANY send of a DNS message.

    It assumes nothing about the message type, but does assume:
        - pCurrent points at byte following end of desired data
        - RR count bytes are in HOST byte order

    Note:  EXPORTED function Dns_SendEx(), remove when clear
                now an IP4 shim

    DCR:  Remove Dns_SendEx() from export when ICS fixed

Arguments:

    pMsg - message info for message to send

    IpAddr - IP to send to;  OPTIONAL, required only if UDP
             and message sockaddr not set

    fNoOpt - TRUE if OPT send is forbidden

Return Value:

    TRUE if successful.
    FALSE on send error.

--*/
{
    DNS_ADDR    addr;

    if ( IpAddr )
    {
        DnsAddr_BuildFromIp4(
            &addr,
            IpAddr,
            0 );
    }

    return Send_MessagePrivate(
                pMsg,
                IpAddr ? &addr : NULL,
                fNoOpt
                );
}



VOID
Dns_InitializeMsgRemoteSockaddr(
    IN OUT  PDNS_MSG_BUF    pMsg,
    IN      IP4_ADDRESS     IpAddr
    )
/*++

Routine Description:

    Initialize remote sockaddr.

    Note:  EXPORTED function -- IP4 shim

    //  DCR:  EXPORTED may remove when clean

Arguments:

    pMsg - message to send

    IpAddr - IP4 address to send to

Return Value:

    None.

--*/
{
    DNS_ADDR    addr;

    DnsAddr_BuildFromIp4(
        &addr,
        IpAddr,
        0 );

    Send_SetMsgRemoteSockaddr(
        pMsg,
        &addr );
}



DNS_STATUS
Dns_OpenTcpConnectionAndSend(
    IN OUT  PDNS_MSG_BUF    pMsg,
    IN      IP4_ADDRESS     IpAddr,
    IN      BOOL            fBlocking
    )
/*++

Routine Description:

    Connect via TCP to desired server.

    EXPORTED function!  IP4 shim.  Dns_OpenTcpConnectionAndSend()  remove when clear

    //  DCR:  EXPORTED may remove when clean

Arguments:

    pMsg -- message info to set with connection socket

    ipServer -- IP of DNS server to connect to

    fBlocking -- blocking connection

Return Value:

    TRUE if successful.
    FALSE on connect error.

--*/
{
    DNS_ADDR    addr;

    DnsAddr_BuildFromIp4(
        &addr,
        IpAddr,
        0 );

    return  Send_OpenTcpConnectionAndSend(
                pMsg,
                &addr,
                fBlocking );
}



DNS_STATUS
Dns_SendAndRecvUdp(
    IN OUT  PDNS_MSG_BUF    pMsgSend,
    OUT     PDNS_MSG_BUF    pMsgRecv,
    IN      DWORD           dwFlags,
    IN      PIP4_ARRAY      pServ4List,
    IN OUT  PDNS_NETINFO    pNetInfo
    )
/*++

Routine Description:

    Sends to and waits to recv from remote DNS.

    EXPORTED function!  Dns_SendAndRecvUdp()  Kill once clear.

Arguments:

    pMsgSend - message to send

    ppMsgRecv - and reuse

    dwFlags -- query flags

    pServ4List -- list of server to use (IP4);  overrides adapter info

    pNetInfo -- adapter list DNS server info

Return Value:

    ERROR_SUCCESS if successful response.
    Error status for "best RCODE" response if rcode.
    ERROR_TIMEOUT on timeout.
    Error status on send\recv failure.

--*/
{
    DNS_STATUS  status;
    PADDR_ARRAY parray;

    //
    //  convert 4 to 6
    //

    parray = DnsAddrArray_CreateFromIp4Array( pServ4List );

    status = Send_AndRecvUdpWithParam(
                    pMsgSend,
                    pMsgRecv,
                    dwFlags,
                    parray,
                    pNetInfo );

    DnsAddrArray_Free( parray );

    return  status;
}
=== C:/Users/treeman/Desktop/windows nt source code\Source\Win2K3\NT\ds\dns\dnsapi\svccntl.c ===
/*++

Copyright (c) 1994-2001  Microsoft Corporation

Module Name:

    svccntl.c

Abstract:

    Domain Name System (DNS) API 

    Service control routines.

Author:

    Glenn Curtis (glennc) 05-Jul-1997

Revision History:

    Jim Gilroy (jamesg)     March 2000  -- resolver notify 

--*/


#include "local.h"


//
//  DCR_CLEANUP:  identical ServiceControl routine is in resolver
//      - should either expose in dnsapi.dll or in dnslib.h
//

DNS_STATUS
Dns_SendServiceControl(
    IN      PWSTR           pwsServiceName,
    IN      DWORD           Access,
    IN      DWORD           Control
    )
{
    DWORD            status = ERROR_INVALID_PARAMETER;
    SC_HANDLE        hmanager = NULL;
    SC_HANDLE        hservice = NULL;
    SERVICE_STATUS   serviceStatus;


    DNSDBG( ANY, (
        "Dns_SendServiceControl( %S, %08x, %08x )\n",
        pwsServiceName,
        Access,
        Control ));

    hmanager = OpenSCManagerW(
                    NULL,
                    NULL,
                    SC_MANAGER_CONNECT );
    if ( !hmanager )
    {
        DNSDBG( ANY, (
            "ERROR:  OpenSCManager( SC_MANAGER_CONNECT ) failed %d\n",
            GetLastError() ));
        goto Cleanup;
    }

    hservice = OpenServiceW(
                    hmanager,
                    pwsServiceName,
                    Access );
    if ( !hservice )
    {
        DNSDBG( ANY, (
            "ERROR:  OpenService( %S, %08x ) failed %d\n",
            pwsServiceName,
            Access,
            GetLastError() ));
        goto Cleanup;
    }

    if ( !ControlService(
                hservice,
                Control,
                &serviceStatus ) )
    {
        DNSDBG( ANY, (
            "ERROR:  ControlService( %08x ) failed %d\n",
            Control,
            GetLastError() ));
        goto Cleanup;
    }
    status = NO_ERROR;


Cleanup:

    if ( status != NO_ERROR )
    {
        status = GetLastError();
    }

    if ( hservice )
    {
        CloseServiceHandle( hservice );
    }
    if ( hmanager )
    {
        CloseServiceHandle( hmanager );
    }

    DNSDBG( ANY, (
        "Leave Dns_SendServiceControl( %S, %08x, %08x ) => %d\n",
        pwsServiceName,
        Access,
        Control,
        status ));

    return status;
}



VOID
DnsNotifyResolver(
    IN      DWORD           Flag,
    IN      PVOID           pReserved
    )
/*++

Routine Description:

    Notify resolver of configuration change.

    This allows it to wakeup and refresh its informatio and\or dump
    the cache and rebuild info.

Arguments:

    Flag -- unused

    pReserved -- unused

Return Value:

    None

--*/
{
    UNREFERENCED_PARAMETER( Flag );
    UNREFERENCED_PARAMETER( pReserved );

    DNSDBG( ANY, (
        "\nDnsNotifyResolver()\n"
        "\tFlag         = %08x\n"
        "\tpReserved    = %p\n"
        "\tTickCount    = %d\n",
        Flag,
        pReserved,
        GetTickCount() ));

    //
    //  wake the resolver
    //

    Dns_SendServiceControl(
        DNS_RESOLVER_SERVICE,
        SERVICE_USER_DEFINED_CONTROL,
        SERVICE_CONTROL_PARAMCHANGE );

    //
    //  DCR:  hack for busted resolver permissions
    //
    //  DCR:  network change notifications
    //      this is a poor mechanism for handling notification
    //          - this should happen directly through SCM
    //          - it won't work for IPv6 or anything else
    //      probably need to move to IPHlpApi
    //
    //  notify resolver
    //  also notify DNS server, but wait briefly to allow resolver
    //      to handle the changes as i'm not sure that the server
    //      doesn't call a resolver API to do it's read
    //      note, the reason the resolver doesn't notify the DNS
    //      server is that since Jon Schwartz moved the resolver to
    //      NetworkService account, attempts to open the SCM to
    //      notify the DNS server all fail
    //
    //  DCR:  make sure server calls directly to avoid race
    //  DCR:  make sure g_IsDnsServer is current
    //  

    g_IsDnsServer = Reg_IsMicrosoftDnsServer();
    if ( g_IsDnsServer )
    {
        Sleep( 1000 );

        Dns_SendServiceControl(
            DNS_SERVER_SERVICE,
            SERVICE_USER_DEFINED_CONTROL,
            SERVICE_CONTROL_PARAMCHANGE );
    }
}


//
//  End srvcntl.c
//
=== C:/Users/treeman/Desktop/windows nt source code\Source\Win2K3\NT\ds\dns\dnsapi\trace.h ===
/*++

Copyright (c) 2000-2001  Microsoft Corporation

Module Name:

    trace.h

Abstract:

    Domain Name System (DNS) API 

    Header for DNS performance tracing functions.

Author:

    Inder Sethi     December, 2000

Revision History:

    Jim Gilroy      January 2001    cleanup, format, integrate, checkin

--*/


#ifndef _DNSAPI_TRACE_INCLUDED_
#define _DNSAPI_TRACE_INCLUDED_

//
//  Tracing functions
//

VOID
Trace_Initialize(
    VOID
    );

VOID
Trace_Cleanup(
    VOID
    );

VOID 
Trace_LogQueryEvent( 
    IN      PDNS_MSG_BUF    pMsg, 
    IN      WORD            wQuestionType
    );

VOID
Trace_LogResponseEvent( 
    IN      PDNS_MSG_BUF    pMsg, 
    IN      WORD            wRespType,
    IN      DNS_STATUS      Status
    );

VOID
Trace_LogSendEvent( 
    IN      PDNS_MSG_BUF    pMsg,
    IN      DNS_STATUS      Status
    );

VOID 
Trace_LogRecvEvent( 
    IN      PDNS_MSG_BUF    pMsg,
    IN      DNS_STATUS      Status,
    IN      BOOL            fTcp
    );

#endif  // _DNSAPI_TRACE_INCLUDED_

//
//  End trace.h
//
=== C:/Users/treeman/Desktop/windows nt source code\Source\Win2K3\NT\ds\dns\dnsapi\util.c ===
/*++

Copyright (c) 2001-2002  Microsoft Corporation

Module Name:

    util.c

Abstract:

    Domain Name System (DNS) API

    General utils.
    Includes:
        Extra info processing.

Author:

    Jim Gilroy (jamesg)     October, 1996

Revision History:

--*/


#include "local.h"


//
//  Extra info routines.
//

PDNS_EXTRA_INFO
ExtraInfo_FindInList(
    IN OUT  PDNS_EXTRA_INFO     pExtraList,
    IN      DWORD               Id
    )
/*++

Routine Description:

    Get extra info blob from extra list.

Arguments:

    pExtra -- ptr to extra info

    Id -- ID to find

Return Value:

    Ptr to extra info of ID type -- if found.
    NULL if not found.

--*/
{
    PDNS_EXTRA_INFO pextra = pExtraList;

    //
    //  find and set extra info result blob (if any)
    //

    while ( pextra )
    {
        if ( pextra->Id == Id )
        {
            break;
        }
        pextra = pextra->pNext;
    }

    return  pextra;
}



BOOL
ExtraInfo_SetBasicResults(
    IN OUT  PDNS_EXTRA_INFO     pExtraList,
    IN      PBASIC_RESULTS      pResults
    )
/*++

Routine Description:

    Get extra info blob from extra list.

Arguments:

    pExtraList -- ptr to extra info

    pResults to write.

Return Value:

    TRUE if found, wrote results extra info.
    FALSE otherwise.

--*/
{
    PDNS_EXTRA_INFO pextra;

    //
    //  find results extra
    //

    pextra = ExtraInfo_FindInList(
                pExtraList,
                DNS_EXINFO_ID_RESULTS_BASIC );

    if ( pextra )
    {
        RtlCopyMemory(
            & pextra->ResultsBasic,
            pResults,
            sizeof( pextra->ResultsBasic ) );
    }

    return( pextra != NULL );
}



PDNS_ADDR_ARRAY
ExtraInfo_GetServerList(
    IN      PDNS_EXTRA_INFO     pExtraList
    )
/*++

Routine Description:

    Get server list from extra info.

Arguments:

    pExtraList -- ptr to extra info

    pResults to write.

Return Value:

    Allocated DNS_ADDR_ARRAY server list if found.
    NULL if not found or error.

--*/
{
    PDNS_EXTRA_INFO pextra;
    PDNS_ADDR_ARRAY parray = NULL;

    //
    //  find server list
    //

    pextra = ExtraInfo_FindInList(
                pExtraList,
                DNS_EXINFO_ID_SERVER_LIST );

    if ( pextra && pextra->pServerList )
    {
        parray = DnsAddrArray_CreateCopy( pextra->pServerList );
        if ( parray )
        {
            goto Done;
        }
    }

    //
    //  check IP4
    //

    pextra = ExtraInfo_FindInList(
                pExtraList,
                DNS_EXINFO_ID_SERVER_LIST_IP4 );

    if ( pextra && pextra->pServerList4 )
    {
        parray = DnsAddrArray_CreateFromIp4Array( pextra->pServerList4 );
        if ( parray )
        {
            goto Done;
        }
    }

#if 0
    //
    //  check IP6
    //

    pextra = ExtraInfo_FindInList(
                pExtraList,
                DNS_EXINFO_ID_SERVER_LIST_IP6 );

    if ( pextra && pextra->pServerList6 )
    {
        parray = DnsAddrArray_CreateFromIp6Array( pextra->pServerList6 );
        if ( parray )
        {
            goto Done;
        }
    }
#endif

Done:

    return( parray );
}




PDNS_ADDR_ARRAY
ExtraInfo_GetServerListPossiblyImbedded(
    IN      PIP4_ARRAY          pList
    )
/*++

Routine Description:

    Get server list from extra info.

Arguments:

    pExtraList -- ptr to extra info

    pResults to write.

Return Value:

    Allocated DNS_ADDR_ARRAY server list if found.
    NULL if not found or error.

--*/
{
    if ( !pList )
    {
        return  NULL;
    }

    //
    //  check for imbedded 
    //

    if ( pList->AddrCount == DNS_IMBEDDED_EXTRA_INFO_TAG )
    {
        return  ExtraInfo_GetServerList(
                    ((PDNS_IMBEDDED_EXTRA_INFO)pList)->pExtraInfo );
    }

    //
    //  check IP4 directly
    //

    return  DnsAddrArray_CreateFromIp4Array( pList );
}



//
//  Random utils
//

VOID
Util_SetBasicResults(
    OUT     PBASIC_RESULTS      pResults,
    IN      DWORD               Status,
    IN      DWORD               Rcode,
    IN      PDNS_ADDR           pServerAddr
    )
/*++

Routine Description:

    Save basic result info.

Arguments:

    pResults -- results

    Status -- update status

    Rcode -- returned RCODE

    pServerAddr -- ptr to DNS_ADDR of server

Return Value:

    None

--*/
{
    pResults->Rcode     = Rcode;
    pResults->Status    = Status;

    if ( pServerAddr )
    {
        DnsAddr_Copy(
            (PDNS_ADDR) &pResults->ServerAddr,
            pServerAddr );
    }
    else
    {
        DnsAddr_Clear( (PDNS_ADDR)&pResults->ServerAddr );
    }
}




PDNS_ADDR_ARRAY
Util_GetAddrArray(
    OUT     PDWORD              fCopy,
    IN      PDNS_ADDR_ARRAY     pServList,
    IN      PIP4_ARRAY          pServList4,
    IN      PDNS_EXTRA_INFO     pExtraInfo
    )
/*++

Routine Description:

    Build combined server list.

Arguments:

    fCopy -- currently ignored (idea is to grab without copy)

    pServList -- input server list

    pServList4 -- IP4 server list

    pExtraInfo -- ptr to extra info

Return Value:

    Allocated DNS_ADDR_ARRAY server list if found.
    NULL if not found or error.

--*/
{
    PDNS_ADDR_ARRAY parray = NULL;

    //
    //  explicit list
    //

    if ( pServList )
    {
        parray = DnsAddrArray_CreateCopy( pServList );
        if ( parray )
        {
            goto Done;
        }
    }

    //
    //  IP4 list
    //

    if ( pServList4 )
    {
        parray = ExtraInfo_GetServerListPossiblyImbedded( pServList4 );
        if ( parray )
        {
            goto Done;
        }
    }

    //
    //  check extra info
    //

    if ( pExtraInfo )
    {
        parray = ExtraInfo_GetServerList( pExtraInfo );
        if ( parray )
        {
            goto Done;
        }
    }

Done:

    return  parray;
}




//
//  IP6 active test
//

VOID
Util_GetActiveProtocols(
    OUT     PBOOL           pfRunning6,
    OUT     PBOOL           pfRunning4
    )
/*++

Routine Description:

    Determine protocols running.

Arguments:

    pfRunning6 -- addr to hold running IP6 flag

    pfRunning4 -- addr to hold running IP4 flag

Return Value:

    None

--*/
{
    SOCKET  sock;

    //
    //  open IP6 socket
    //

    sock = Socket_Create(
                AF_INET6,
                SOCK_DGRAM,
                NULL,
                0,
                0 );

    *pfRunning6 = ( sock != 0 );

    Socket_Close( sock );

    sock = Socket_Create(
                AF_INET,
                SOCK_DGRAM,
                NULL,
                0,
                0 );

    *pfRunning4 = ( sock != 0 );

    Socket_Close( sock );
}



BOOL
Util_IsIp6Running(
    VOID
    )
/*++

Routine Description:

    Determine if IP6 running.

Arguments:

Return Value:

    None

--*/
{
    SOCKET  sock;

    //
    //  open IP6 socket
    //

    sock = Socket_Create(
                AF_INET6,
                SOCK_DGRAM,
                NULL,
                0,
                0 );

    Socket_Close( sock );

    return ( sock != 0 );
}

//
//  End util.c
//
=== C:/Users/treeman/Desktop/windows nt source code\Source\Win2K3\NT\ds\dns\dnsapi\test\dhcpreg\dhcpreg.c ===
/*++

Copyright (c) 1997 Microsoft Corporation

Module Name:

    adddom.c

Abstract:

    Domain Name System (DNS) Server

    Test Code for adding a Zone

Author:

    Ram Viswanathan (ramv) 14th March 1997

Revision History:

    Ram Viswanathan (ramv) 14th March 1997   Created

                           5th May 1997  Added Callback function testing
--*/



#include <windows.h>

//
// ********* CRunTime Includes
//

#include <stdlib.h>
#include <limits.h>
#include <io.h>
#include <stdio.h>
#include "dns.h"
#include "dnsapi.h"
#include "dnslib.h"


VOID 
CallBack (
    DWORD     dwStatus,
    LPVOID    pvData
    );


INT __cdecl
main (int argc, char *argv[])
{
    DWORD  dwRes;

    DWORD               iter;
    BOOL                fRegisterForwards = FALSE;
    DWORD               dwOperation = DYNDNS_ADD_ENTRY;
    DWORD               StartPart1, StartPart2, StartPart3, StartPart4;
    DWORD               EndPart1, EndPart2, EndPart3, EndPart4;
    DWORD               StartIPReversed, EndIPReversed;
    REGISTER_HOST_ENTRY HostAddr;
    LPSTR               lpTemp = NULL;
    LPSTR               pszDomainName = NULL;
    LPSTR               pszAddressStart = NULL;
    LPSTR               pszAddressEnd = NULL;
    CHAR                c;

    if ( argc < 4 )
    {
        printf( "\nUsage: dhcpreg <DNS Domain Name> <IP Address Range> [/f /d]\n" );
        printf( "\nWhere:\n" );
        printf( "    DNS Domain Name   - ntdev.microsoft.com\n" );
        printf( "    IP Address Range - 1.2.0.0 1.2.50.255\n" );
        printf( "    Options:\n" );
        printf( "       /f - Register forward addresses\n" );
        printf( "       /d - Delete registered records\n" );
        return(-1);
    }

    pszDomainName = argv[1];
    pszAddressStart = argv[2];
    pszAddressEnd = argv[3];

    if ( argc > 4 )
    {
        if ( !strcmp( argv[4], "/f" ) )
            fRegisterForwards = TRUE;
        else if ( !strcmp( argv[4], "/d" ) )
            dwOperation = DYNDNS_DELETE_ENTRY;

        if ( argc > 5 )
        {
            if ( !strcmp( argv[5], "/f" ) )
                fRegisterForwards = TRUE;
            else if ( !strcmp( argv[5], "/d" ) )
                dwOperation = DYNDNS_DELETE_ENTRY;
        }
    }

    lpTemp = strtok( pszAddressStart, "." );
    StartPart1 = atoi( lpTemp );
    lpTemp = strtok( NULL, "." );
    StartPart2 = atoi( lpTemp );
    lpTemp = strtok( NULL, "." );
    StartPart3 = atoi( lpTemp );
    lpTemp = strtok( NULL, "." );
    StartPart4 = atoi( lpTemp );

    lpTemp = strtok( pszAddressEnd, "." );
    EndPart1 = atoi( lpTemp );
    lpTemp = strtok( NULL, "." );
    EndPart2 = atoi( lpTemp );
    lpTemp = strtok( NULL, "." );
    EndPart3 = atoi( lpTemp );
    lpTemp = strtok( NULL, "." );
    EndPart4 = atoi( lpTemp );

    if ( dwOperation == DYNDNS_DELETE_ENTRY )
    {
        printf( "\nDeregistering DNS records with:\n" );
        printf( "Domain Name:    %s\n", pszDomainName );
        printf( "Address range: %d.%d.%d.%d to %d.%d.%d.%d\n",
                StartPart1, StartPart2, StartPart3, StartPart4,
                EndPart1, EndPart2, EndPart3, EndPart4 );
        printf( "Register forwards: %s\n", fRegisterForwards ? "TRUE" : "FALSE" );
    }
    else
    {
        printf( "\nRegistering DNS records with:\n" );
        printf( "Domain Name:    %s\n", pszDomainName );
        printf( "Address range: %d.%d.%d.%d to %d.%d.%d.%d\n",
                StartPart1, StartPart2, StartPart3, StartPart4,
                EndPart1, EndPart2, EndPart3, EndPart4 );
        printf( "Register forwards: %s\n", fRegisterForwards ? "TRUE" : "FALSE" );
    }

    StartIPReversed = (DWORD)(StartPart4) + (DWORD)(StartPart3 << 8) + 
                      (DWORD)(StartPart2 << 16) + (DWORD)(StartPart1 << 24);

    EndIPReversed = (DWORD)(EndPart4) + (DWORD)(EndPart3 << 8) + 
                    (DWORD)(EndPart2 << 16) + (DWORD)(EndPart1 << 24);

    //
    // set up stuff for registration
    //

    dwRes = DnsDhcpSrvRegisterInit();

    if ( dwRes )
        printf("Init failed with %x\n", dwRes);


    for ( iter = StartIPReversed; iter < EndIPReversed; iter++ )
    {
        CHAR  szName[260];
        DWORD IP = iter;
        BYTE  Temp;
        DWORD dwFlags = 0;
        LPSTR pszAddr = LocalAlloc( LPTR, 20 );

        Temp = ((LPBYTE)&IP)[3];
        ((LPBYTE)&IP)[3] = ((LPBYTE)&IP)[0];
        ((LPBYTE)&IP)[0] = Temp;

        Temp = ((LPBYTE)&IP)[2];
        ((LPBYTE)&IP)[2] = ((LPBYTE)&IP)[1];
        ((LPBYTE)&IP)[1] = Temp;

        if ( dwOperation == DYNDNS_DELETE_ENTRY )
            printf( "\nDeregistering DNS record for:\n" );
        else
            printf( "\nRegistering DNS record for:\n" );

        if ( pszAddr )
        {
            sprintf( pszAddr, "%d.%d.%d.%d",
                     ((LPBYTE)&IP)[0],
                     ((LPBYTE)&IP)[1],
                     ((LPBYTE)&IP)[2],
                     ((LPBYTE)&IP)[3] );
        }

        sprintf( szName, "%d-%d-%d-%d.%s",
                 ((LPBYTE)&IP)[0],
                 ((LPBYTE)&IP)[1],
                 ((LPBYTE)&IP)[2],
                 ((LPBYTE)&IP)[3],
                 pszDomainName );

        if ( pszAddr )
            printf( "Address: %s\n", pszAddr );

        printf( "Name:    %s\n", szName );


        HostAddr.dwOptions = REGISTER_HOST_PTR;
        HostAddr.Addr.ipAddr = IP;

        if ( fRegisterForwards )
            dwFlags = DYNDNS_REG_FORWARD;

        dwFlags |= dwOperation;

        dwRes = DnsDhcpSrvRegisterHostName_A (
                    HostAddr,
                    szName,
                    600,   //10 mins of Time to live
                    dwFlags,
                    (DHCP_CALLBACK_FN)&CallBack,
                    (PVOID) pszAddr
                    );

        if ( dwRes )
            printf("Host Name registration failed with %x\n", dwRes);

        Sleep( 1000 );
    }

    c = getchar();
    dwRes = DnsDhcpSrvRegisterTerm();

    if ( dwRes )
        printf("Termination failed with %x\n", dwRes);

    c = getchar();
error:
    return(1);

}


VOID 
CallBack (
    DWORD     dwStatus,
    LPVOID    pvData
    )

{

    //
    // callback functionality testing
    //

    LPSTR pszData = (LPSTR)pvData;

    printf("Registration of %s returned with Error Code %x \n", pszData,
           dwStatus );

    LocalFree(pszData);

}
=== C:/Users/treeman/Desktop/windows nt source code\Source\Win2K3\NT\ds\dns\dnsapi\update.c ===
/*++

Copyright (c) 1996-2002  Microsoft Corporation

Module Name:

    update.c

Abstract:

    Domain Name System (DNS) API

    Update client routines.

Author:

    Jim Gilroy (jamesg)     October, 1996

Revision History:

--*/


#include "local.h"
#include "dnssec.h"


//
//  Security flag check
//

#define UseSystemDefaultForSecurity(flag)   \
        ( ((flag) & DNS_UPDATE_SECURITY_CHOICE_MASK) \
            == DNS_UPDATE_SECURITY_USE_DEFAULT )

//
//  Local update flag
//  - must make sure this is in UPDATE_RESERVED space
//

#define DNS_UPDATE_LOCAL_COPY       (0x00010000)

//
//  DCR_DELETE:  this is stupid
//

#define DNS_UNACCEPTABLE_UPDATE_OPTIONS \
        (~                                      \
          ( DNS_UPDATE_SECURITY_OFF           | \
            DNS_UPDATE_CACHE_SECURITY_CONTEXT | \
            DNS_UPDATE_SECURITY_ON            | \
            DNS_UPDATE_FORCE_SECURITY_NEGO    | \
            DNS_UPDATE_TRY_ALL_MASTER_SERVERS | \
            DNS_UPDATE_REMOTE_SERVER          | \
            DNS_UPDATE_LOCAL_COPY             | \
            DNS_UPDATE_SECURITY_ONLY ))


//
//  Update Timeouts
//
//  note, max is a little longer than might be expected as DNS server
//  may have to contact primary and wait for primary to do update (inc.
//  disk access) then response
//

#define INITIAL_UPDATE_TIMEOUT  (4)     // 4 seconds
#define MAX_UPDATE_TIMEOUT      (60)    // 60 seconds


//
//  Private prototypes
//

DNS_STATUS
Dns_DoSecureUpdate(
    IN      PDNS_MSG_BUF        pMsgSend,
    OUT     PDNS_MSG_BUF        pMsgRecv,
    IN OUT  PHANDLE             phContext,
    IN      DWORD               dwFlag,
    IN      PDNS_NETINFO        pNetworkInfo,
    IN      PADDR_ARRAY         pServerList,
    IN      PWSTR               pszNameServer,
    IN      PCHAR               pCreds,
    IN      PCHAR               pszContext
    );




//
//  Update execution routines
//

VOID
Update_SaveResults(
    IN OUT  PUPDATE_BLOB        pBlob,
    IN      DWORD               Status,
    IN      DWORD               Rcode,
    IN      PDNS_ADDR           pServerAddr
    )
/*++

Routine Description:

    Save update results.

Arguments:

    pBlob -- update info blob

    Status -- update status

    Rcode -- returned RCODE

    ServerIp -- server attempted update at

Return Value:

    ERROR_SUCCESS if successful.
    Error status on failure.

--*/
{
    PDNS_EXTRA_INFO pextra = (PDNS_EXTRA_INFO) pBlob->pExtraInfo;

    //
    //  results - save to blob
    //

    pBlob->fSavedResults = TRUE;

    Util_SetBasicResults(
        & pBlob->Results,
        Status,
        Rcode,
        pServerAddr );

    //
    //  find and set extra info result blob (if any)
    //

    ExtraInfo_SetBasicResults(
        pBlob->pExtraInfo,
        & pBlob->Results );

    //
    //  backward compat update results
    //

    if ( pServerAddr )
    {
        pextra = ExtraInfo_FindInList(
                    pBlob->pExtraInfo,
                    DNS_EXINFO_ID_RESULTS_V1 );
        if ( pextra )
        {
            pextra->ResultsV1.Rcode   = (WORD)Rcode;
            pextra->ResultsV1.Status  = Status;
    
            if ( DnsAddr_IsIp4( pServerAddr ) )
            {
                pextra->ResultsV1.ServerIp4 = DnsAddr_GetIp4( pServerAddr );
            }
            else
            {
                DNS_ASSERT( DnsAddr_IsIp6( pServerAddr ) );
    
                DnsAddr_WriteIp6(
                    & pextra->ResultsV1.ServerIp6,
                    pServerAddr );
            }
        }
    }
}



DNS_STATUS
Update_Send(
    IN OUT  PUPDATE_BLOB        pBlob
    )
/*++

Routine Description:

    Send DNS update.

    This is the core update send routine that does
        - packet build
        - send
        - secure fail over
        - result data (if required)

    This routine does NOT do FAZ or cache cleanup (see Update_FazSendFlush()).

Arguments:

    pBlob -- update info blob

Return Value:

    ERROR_SUCCESS if successful.
    Error status on failure.

--*/
{
    PDNS_MSG_BUF    pmsgSend = NULL;
    PDNS_MSG_BUF    pmsgRecv = NULL;
    DNS_STATUS      status = NO_ERROR;
    WORD            length;
    PWSTR           pzone;
    PWSTR           pserverName;
    PCHAR           pcreds = NULL;
    BOOL            fsecure = FALSE;
    BOOL            fswitchToTcp = FALSE;
    DNS_HEADER      header;
    BYTE            rcode = 0;
    DNS_ADDR        servAddr;
    PDNS_ADDR       pservAddr = NULL;
    PADDR_ARRAY     pserverArray = NULL;
    PDNS_NETINFO    pnetInfo = NULL;
    PDNS_NETINFO    pnetInfoLocal = NULL;
    SEND_BLOB       sendBlob;


    DNSDBG( UPDATE, (
        "Update_Send( %p )\n",
        pBlob ));

    IF_DNSDBG( UPDATE )
    {
        DnsDbg_UpdateBlob( "Entering Update_Send", pBlob );
    }

    //
    //  build netinfo if missing
    //

    pnetInfo = pBlob->pNetInfo;
    if ( !pnetInfo )
    {
        if ( pBlob->pServerList )
        {
            pnetInfoLocal = NetInfo_CreateForUpdate(
                                pBlob->pszZone,
                                pBlob->pszServerName,
                                pBlob->pServerList,
                                0 );
            if ( !pnetInfoLocal )
            {
                status = ERROR_INVALID_PARAMETER;
                goto Cleanup;
            }
        }
        pnetInfo = pnetInfoLocal;
    }

    //
    //  get info from netinfo
    //      - must be update netinfo blob
    //

    if ( ! NetInfo_IsForUpdate(pnetInfo) )
    {
        status = ERROR_INVALID_PARAMETER;
        goto Cleanup;
    }

    pzone = NetInfo_UpdateZoneName( pnetInfo );
    pserverArray = NetInfo_ConvertToAddrArray(
                        pnetInfo,
                        NULL,       // all adapters
                        0           // no addr family
                        );
    pserverName = NetInfo_UpdateServerName( pnetInfo );

    if ( !pzone || !pserverArray )
    {
        status = ERROR_INVALID_PARAMETER;
        goto Cleanup;
    }

    //
    //  build recv message buffer
    //      - must be big enough for TCP
    //

    pmsgRecv = Dns_AllocateMsgBuf( DNS_TCP_DEFAULT_PACKET_LENGTH );
    if ( !pmsgRecv )
    {
        status = DNS_ERROR_NO_MEMORY;
        goto Cleanup;
    }

    //
    //  build update packet
    //  note currently this function allocates TCP sized buffer if records
    //      given;  if this changes need to alloc TCP buffer here
    //

    CLEAR_DNS_HEADER_FLAGS_AND_XID( &header );
    header.Opcode = DNS_OPCODE_UPDATE;

    pmsgSend = Dns_BuildPacket(
                    &header,                // copy header
                    TRUE,                   //  ... but not header counts
                    (PDNS_NAME) pzone,      // question zone\type SOA
                    DNS_TYPE_SOA,
                    pBlob->pRecords,
                    DNSQUERY_UNICODE_NAME,  // no other flags
                    TRUE                    // building an update packet
                    );
    if ( !pmsgSend )
    {
        DNS_PRINT(( "ERROR:  failed send buffer allocation.\n" ));
        status = DNS_ERROR_NO_MEMORY;
        goto Cleanup;
    }

    //
    //  init send blob
    //
    //  note:  do NOT set server array here as update
    //      network info blob (from FAZ or built
    //      from passed in array ourselves) takes precedence
    //    

    RtlZeroMemory( &sendBlob, sizeof(sendBlob) );

    sendBlob.pSendMsg           = pmsgSend;
    sendBlob.pNetInfo           = pnetInfo;
    //sendBlob.pServerArray       = pserverArray;
    sendBlob.Flags              = pBlob->Flags;
    sendBlob.fSaveResponse      = TRUE;
    sendBlob.Results.pMessage   = pmsgRecv;
    sendBlob.pRecvMsgBuf        = pmsgRecv;

    //
    //  try non-secure first unless explicitly secure only
    //

    fsecure = (pBlob->Flags & DNS_UPDATE_SECURITY_ONLY);

    if ( !fsecure )
    {
        status = Send_AndRecv( &sendBlob );

        //  QUESTION:  is this adequate to preserve precon fail RCODEs
        //      does Send_AndRecv() always give success to valid response

        if ( status == ERROR_SUCCESS )
        {
            rcode = pmsgRecv->MessageHead.ResponseCode;
            status = Dns_MapRcodeToStatus( rcode );
        }

        if ( status != DNS_ERROR_RCODE_REFUSED ||
            pBlob->Flags & DNS_UPDATE_SECURITY_OFF )
        {
            goto Cleanup;
        }

        DNSDBG( UPDATE, (
            "Failed unsecure update, switching to secure!\n"
            "\tcurrent time (ms) = %d\n",
            GetCurrentTime() ));
        fsecure = TRUE;
    }

    //
    //  security
    //      - must have server name
    //      - must start package
    //

    if ( fsecure )
    {
        if ( !pserverName )
        {
            status = ERROR_INVALID_PARAMETER;
            goto Cleanup;
        }
        status = Dns_StartSecurity( FALSE );
        if ( status != ERROR_SUCCESS )
        {
            goto Cleanup;
        }

        //
        //  DCR:  hCreds doesn't return security context
        //      - idea of something beyond just standard security
        //      credentials was we'd been able to return the context
        //      handle
        //
        //  DCR_FIX0:  Secure update needs to be non-IP4_ARRAY
        //

        pcreds = Dns_GetApiContextCredentials( pBlob->hCreds );

        status = Dns_DoSecureUpdate(
                    pmsgSend,
                    pmsgRecv,
                    NULL,
                    pBlob->Flags,
                    pnetInfo,
                    pserverArray,
                    pserverName,
                    pcreds,         // initialized in DnsAcquireContextHandle
                    NULL            // default context name
                    );
        if ( status == ERROR_SUCCESS )
        {
            rcode = pmsgRecv->MessageHead.ResponseCode;
            status = Dns_MapRcodeToStatus( rcode );
        }
    }


Cleanup:

    //
    //  result info
    //
    //  DCR:  note not perfect info on whether actually got to send
    //
    //  DCR:  could be a case with UDP where receive message is NOT
    //      the message we sent to
    //      would only occur if non-FAZ server array of multiple entries
    //      and timeout on first
    //
    //  FIX6:  serverIP and rcode should be handled in send code
    //

    if ( pmsgSend && pmsgRecv )
    {
        pservAddr = &servAddr;
        DnsAddr_Copy( pservAddr, &pmsgSend->RemoteAddress );

        rcode = pmsgRecv->MessageHead.ResponseCode;
#if 0
        if ( (rcode || status==NO_ERROR) && !pmsgRecv->fTcp )
        {
            DnsAddr_Copy( pservAddr, &pmsgRecv->RemoteAddress );
        }
#endif
    }

    //  save results

    Update_SaveResults(
        pBlob,
        status,
        rcode,
        pservAddr );

    //  return recv message buffer

    if ( pBlob->fSaveRecvMsg )
    {
        pBlob->pMsgRecv = pmsgRecv;
    }
    else
    {
        FREE_HEAP( pmsgRecv );
        pBlob->pMsgRecv = NULL;
    }
    FREE_HEAP( pmsgSend);
    FREE_HEAP( pserverArray );
    NetInfo_Free( pnetInfoLocal );

    //  winsock cleanup if we started

    GUI_MODE_SETUP_WS_CLEANUP( g_InNTSetupMode );

    DNSDBG( UPDATE, (
        "Leave Update_Send() => %d %s.\n\n",
        status,
        Dns_StatusString(status) ));

    return( status );
}



DNS_STATUS
Update_FazSendFlush(
    IN OUT  PUPDATE_BLOB        pBlob
    )
/*++

Routine Description:

    Send DNS update.

Arguments:

    pBlob   -- update info blob

Return Value:

    ERROR_SUCCESS if successful.
    Error status on failure.

--*/
{
    DNS_STATUS          status;
    PDNS_NETINFO        plocalNetworkInfo = NULL;
    PDNS_NETINFO        pnetInfo = pBlob->pNetInfo;

    DNSDBG( TRACE, ( "Update_FazSendFlush( %p )\n", pBlob ));

    IF_DNSDBG( UPDATE )
    {
        DnsDbg_UpdateBlob( "Entering Update_FazSendFlush", pBlob );
    }

    //
    //  read update config
    //

    Reg_RefreshUpdateConfig();

    //
    //  need to build update adapter list from FAZ
    //      - only pass on BYPASS_CACHE flag
    //      - note FAZ will append DNS_QUERY_ALLOW_EMPTY_AUTH_RESP
    //          flag yet DnsQuery() will fail on that flag without
    //          BYPASS_CACHE also set
    //

    if ( ! NetInfo_IsForUpdate(pnetInfo) )
    {
        status = Faz_Private(
                    pBlob->pRecords->pName,
                    DNS_QUERY_BYPASS_CACHE,
                    NULL,                   // no specified servers
                    & plocalNetworkInfo );

        if ( status != ERROR_SUCCESS )
        {
            return( status );
        }
        pnetInfo = plocalNetworkInfo;
        pBlob->pNetInfo = pnetInfo;
    }

    //
    //  call update send routine
    //

    status = Update_Send( pBlob );

    //
    //  if updated name -- flush cache entry for name
    //

    if ( status == ERROR_SUCCESS )
    {
        DnsFlushResolverCacheEntry_W(
            pBlob->pRecords->pName );
    }

    //
    //  if there was an error sending the update, flush the resolver
    //  cache entry for the zone name to possibly pick up an alternate
    //  DNS server for the next retry attempt of a similar update.
    //
    //  DCR_QUESTION:  is this the correct error code?
    //      maybe ERROR_TIMED_OUT?
    //
    //  DCR:  update flushes don't make sense
    //      1) FAZ bypasses cache, so comment really isn't the problem
    //      2) ought to flush name itself anytime we can
    //

    if ( status == DNS_ERROR_RECORD_TIMED_OUT )
    {
        PWSTR   pzoneName;

        if ( pnetInfo &&
             (pzoneName = NetInfo_UpdateZoneName( pnetInfo )) )
        {
            DnsFlushResolverCacheEntry_W( pzoneName );
            DnsFlushResolverCacheEntry_W( pBlob->pRecords->pName );
        }
    }


    //  cleanup local adapter list if used

    if ( plocalNetworkInfo )
    {
        NetInfo_Free( plocalNetworkInfo );
        if ( pBlob->pNetInfo == plocalNetworkInfo )
        {
            pBlob->pNetInfo = NULL;
        }
    }

    DNSDBG( TRACE, (
        "Leave Update_FazSendFlush( %p ) => %d\n",
        pBlob,
        status ));

    return( status );
}



DNS_STATUS
Update_MultiMaster(
    IN OUT  PUPDATE_BLOB    pBlob
    )
/*++

Routine Description:

    Do multi-master update.

Arguments:

    pBlob -- update info blob
        note:  IP4 array ignored, must be converted to DNS_ADDR higher.

Return Value:

    ERROR_SUCCESS if successful.
    ErrorCode on failure.

--*/
{
    PDNS_NETINFO    pnetInfo = NULL;
    PADDR_ARRAY     pnsList = NULL;
    PADDR_ARRAY     pbadServerList = NULL;
    PADDR_ARRAY     plocalAddrs = NULL;
    DNS_STATUS      status = DNS_ERROR_NO_DNS_SERVERS;
    DWORD           iter;
    PDNS_ADDR       pfailedAddr;
    BOOL            fremoteUpdate = (pBlob->Flags & DNS_UPDATE_REMOTE_SERVER);
    DWORD           savedStatus;
    BASIC_RESULTS   savedRemoteResults;
    BASIC_RESULTS   savedLocalResults;
    BOOL            isLocal = FALSE;
    BOOL            fdoneLocal = FALSE;
    BOOL            fdoneRemote = FALSE;
    BOOL            fdoneRemoteSuccess = FALSE;


    DNSDBG( UPDATE, (
        "\nUpdate_MultiMaster( %p )\n", pBlob ));
    IF_DNSDBG( UPDATE )
    {
        DnsDbg_UpdateBlob( "Entering Update_MultiMaster", pBlob );
    }

    DNS_ASSERT( !pBlob->fSaveRecvMsg );
    pBlob->fSaveRecvMsg = FALSE;

    //
    //  read NS list for zone
    //

    pnsList = GetNameServersListForDomain(
                    pBlob->pszZone,
                    pBlob->pServerList );
    if ( !pnsList )
    {
        return status;
    }

    //
    //  validate failed IP
    //

    pfailedAddr = &pBlob->FailedServer;

    if ( DnsAddr_IsEmpty(pfailedAddr) )
    {
        pfailedAddr = NULL;
    }

    if ( pfailedAddr &&
         pnsList->AddrCount == 1 &&
         DAddr_IsEqual(
            pfailedAddr,
            & pnsList->AddrArray[0] ) )
    {
        status = ERROR_TIMEOUT;
        goto Done;
    }

    //
    //  create bad server list
    //      - init with any previous failed DNS server
    //

    pbadServerList = DnsAddrArray_Create( pnsList->AddrCount + 1 );
    if ( !pbadServerList )
    {
        status = DNS_ERROR_NO_MEMORY;
        goto Done;
    }
    if ( pfailedAddr )
    {
        DnsAddrArray_AddAddr(
            pbadServerList,
            pfailedAddr,
            0,      // no family screen
            0       // no dup screen
            );
    }

    //
    //  get local IP list
    //

    if ( fremoteUpdate )
    {
        plocalAddrs = NetInfo_GetLocalAddrArray(
                            pBlob->pNetInfo,
                            NULL,       // no specific adapter
                            0,          // no specific family
                            0,          // no flags
                            FALSE       // no force, should have recent copy
                            );
    }

    //
    //  init results
    //

    RtlZeroMemory( &savedRemoteResults, sizeof(savedRemoteResults) );
    RtlZeroMemory( &savedLocalResults, sizeof(savedLocalResults) );

    //
    //  attempt update against each multi-master DNS server
    //
    //  identify multi-master servers as those which return their themselves
    //  as the authoritative server when do FAZ query
    //

    for ( iter = 0; iter < pnsList->AddrCount; iter++ )
    {
        PDNS_ADDR       pservAddr = &pnsList->AddrArray[iter];
        PDNS_ADDR       pfazAddr;
        ADDR_ARRAY      ipArray;

        //
        //  already attempted this server?
        //

        if ( AddrArray_ContainsAddr( pbadServerList, pservAddr ) )
        {
            DNSDBG( UPDATE, (
                "MultiMaster skip update to bad IP %s.\n",
                DNSADDR_STRING(pservAddr) ));
            continue;
        }

        //
        //  if require remote, screen out local server
        //
        //  note:  currently updating both local and one remote
        //          could do just remote
        //

        if ( fremoteUpdate )
        {
            isLocal = LocalIp_IsAddrLocal( pservAddr, plocalAddrs, NULL );
            if ( isLocal )
            {
                DNSDBG( UPDATE, (
                    "MultiMaster local IP %s -- IsDns %d.\n",
                    DNSADDR_STRING( pservAddr ),
                    g_IsDnsServer ));

                if ( fdoneLocal )
                {
                    DNSDBG( UPDATE, (
                        "MultiMaster skip local IP %s after local.\n",
                        DNSADDR_STRING( pservAddr ) ));
                    continue;
                }
            }
            else if ( fdoneRemoteSuccess )
            {
                DNSDBG( UPDATE, (
                    "MultiMaster skip remote IP %s after success remote.\n",
                    DNSADDR_STRING( pservAddr ) ));
                continue;
            }
        }

        //
        //  FAZ to get primary "seen" by this NS
        //

        DnsAddrArray_InitSingleWithAddr(
            & ipArray,
            pservAddr );

        DNSDBG( UPDATE, (
            "MultiMaster FAZ to %s.\n",
            DNSADDR_STRING( pservAddr ) ));

        status = DoQuickFAZ(
                    &pnetInfo,
                    pBlob->pszZone,
                    &ipArray );

        if ( status != ERROR_SUCCESS )
        {
            DNSDBG( UPDATE, (
                "MultiMaster skip IP %s on FAZ failure => %d.\n",
                DNSADDR_STRING( pservAddr ),
                status ));
            continue;
        }

        DNS_ASSERT( pnetInfo->AdapterCount == 1 );
        DNS_ASSERT( pnetInfo->AdapterArray[0].pDnsAddrs );

        //
        //  check FAZ result IP
        //      - if different from server, use it
        //      - but verify not in bad\previous list
        //

        pfazAddr = &pnetInfo->AdapterArray[0].pDnsAddrs->AddrArray[0];

        if ( !DnsAddr_IsEqual( pservAddr, pfazAddr, DNSADDR_MATCH_ADDR ) )
        {
            if ( DnsAddrArray_ContainsAddr(
                    pbadServerList,
                    pfazAddr,
                    DNSADDR_MATCH_ADDR ) )
            {
                DNSDBG( UPDATE, (
                    "MultiMaster skip FAZ result IP %s -- bad list.\n",
                    DNSADDR_STRING( pservAddr ) ));
                NetInfo_Free( pnetInfo );
                pnetInfo = NULL;
                continue;
            }
            pservAddr = pfazAddr;
        }

        DNSDBG( UPDATE, (
            "MultiMaster update to %s.\n",
            DNSADDR_STRING( pservAddr ) ));

        pBlob->pNetInfo = pnetInfo;

        status = Update_FazSendFlush( pBlob );

        pBlob->pNetInfo = NULL;

        //
        //  save results
        //      - save local result (we assume there should only be one and
        //          if more than one result should be the same)
        //      - save best remote result;  NO_ERROR tops, otherwise highest
        //          error is best
        //

        if ( isLocal )
        {
            fdoneLocal = TRUE;
            RtlCopyMemory(
                &savedLocalResults,
                &pBlob->Results,
                sizeof( savedLocalResults ) );
        }
        else
        {
            BOOL    fsaveResults = FALSE;

            if ( status == ERROR_SUCCESS )
            {
                fsaveResults = !fdoneRemoteSuccess;
                fdoneRemoteSuccess = TRUE;
            }
            else
            {
                fsaveResults = !fdoneRemoteSuccess &&
                               status > savedRemoteResults.Status;
            }
            if ( fsaveResults )
            {
                fdoneRemote = TRUE;
                RtlCopyMemory(
                    &savedRemoteResults,
                    &pBlob->Results,
                    sizeof( savedRemoteResults ) );
            }
        }

        //
        //  check for continue
        //      - timeouts
        //      - all-master updates
        //      - require remote server update (but we save success IP
        //          and screen above)
        //
        //  other cases stop once a single update completes
        //
        //  DCR:  continue multi-master-update until success?
        //  DCR:  not supporting some servers update-on others off
        //      you can have case here where some servers are configured to
        //      accept update and some are not

        if ( status == ERROR_TIMEOUT ||
             status == DNS_RCODE_SERVER_FAILURE )
        {
        }
        else if ( fremoteUpdate ||
                ( pBlob->Flags & DNS_UPDATE_TRY_ALL_MASTER_SERVERS ) )
        {
        }
        else
        {
            break;
        }

        //  continue -- screen off this IP

        AddrArray_AddAddr(
            pbadServerList,
            pservAddr );

        //  cleanup FAZ netinfo
        //      - doing this last as FAZ IP is pointer into this struct

        NetInfo_Free( pnetInfo );
        pnetInfo = NULL;
        continue;
    }


Done:

    //
    //  set best results
    //

    {
        PBASIC_RESULTS presults = NULL;

        if ( fdoneRemote )
        {
            presults = &savedRemoteResults;
        }
        else if ( fdoneLocal ) 
        {
            presults = &savedLocalResults;
        }
        if ( presults )
        {
            Update_SaveResults(
                pBlob,
                presults->Status,
                presults->Rcode,
                &presults->ServerAddr );

            status = presults->Status;
        }
    }

    FREE_HEAP( pnsList );
    FREE_HEAP( pbadServerList );
    FREE_HEAP( plocalAddrs );
    NetInfo_Free( pnetInfo );
    return status;
}



DNS_STATUS
Update_Private(
    IN OUT  PUPDATE_BLOB    pBlob
    )
/*++

Routine Description:

    Main private update routine.

    Do FAZ and determines
        - multi-homing
        - multi-master
    before handing over to next level.

Arguments:

    pBlob -- update info blob

Return Value:

    ERROR_SUCCESS if successful.
    ErrorCode on failure.

--*/
{
    DNS_STATUS      status = NO_ERROR;
    PWSTR           pzoneName;
    PWSTR           pname;
    PADDR_ARRAY     pserverList;
    PADDR_ARRAY     pserverListCopy = NULL;
    PADDR_ARRAY     poriginalServerList;
    PIP4_ARRAY      pserv4List;
    PDNS_NETINFO    pnetInfo = NULL;
    DWORD           flags = pBlob->Flags;


    DNSDBG( UPDATE, (
        "Update_Private( blob=%p )\n",
        pBlob ));

    IF_DNSDBG( UPDATE )
    {
        DnsDbg_UpdateBlob( "Entering Update_Private", pBlob );
    }

    //
    //  get record name
    //

    if ( !pBlob->pRecords )
    {
        status = ERROR_INVALID_PARAMETER;
        goto Done;
    }
    pname = pBlob->pRecords->pName;

    //
    //  unpack to locals
    //

    pserverList = pBlob->pServerList;
    pserv4List  = pBlob->pServ4List;

    poriginalServerList = pserverList;

    //
    //  caller has particular server list
    //      - convert IP4 list
    //

    pserverListCopy = Util_GetAddrArray(
                            NULL,
                            pserverList,
                            pserv4List,
                            pBlob->pExtraInfo );

    //
    //  update with particular server list
    //

    if ( pserverListCopy )
    {
        //
        //  FAZ to create update network info
        //

        status = DoQuickFAZ(
                    &pnetInfo,
                    pname,
                    pserverListCopy );

        if ( status != ERROR_SUCCESS )
        {
            DnsAddrArray_Free( pserverListCopy );
            goto Done;
        }

        DNS_ASSERT( NetInfo_IsForUpdate(pnetInfo) );
        pzoneName = NetInfo_UpdateZoneName( pnetInfo );

        pBlob->pszZone      = pzoneName;
        pBlob->pNetInfo     = pnetInfo;

        //
        //  update scale
        //      - directly multimaster
        //      OR
        //      - single, but fail over to multi-master attempt if timeout
        //

        if ( flags & (DNS_UPDATE_TRY_ALL_MASTER_SERVERS | DNS_UPDATE_REMOTE_SERVER) )
        {
            pBlob->pServerList = pserverListCopy;

            status = Update_MultiMaster( pBlob );
        }
        else
        {
            status = Update_FazSendFlush( pBlob );

            if ( status == ERROR_TIMEOUT )
            {
                pBlob->pServerList = pserverListCopy;
                status = Update_MultiMaster( pBlob );
            }
        }

        //  cleanup
        
        NetInfo_Free( pnetInfo );
        DnsAddrArray_Free( pserverListCopy );

        pBlob->pNetInfo     = NULL;
        pBlob->pServerList  = poriginalServerList;
        pBlob->pszZone      = NULL;
        DnsAddr_Clear( &pBlob->FailedServer );

        goto Done;
    }

    //
    //  server list unspecified
    //      - use FAZ to figure it out
    //

    else
    {
        PADDR_ARRAY     serverListArray[ UPDATE_ADAPTER_LIMIT ];
        PDNS_NETINFO    networkInfoArray[ UPDATE_ADAPTER_LIMIT ];
        DWORD           netCount = UPDATE_ADAPTER_LIMIT;
        DWORD           iter;
        BOOL            bsuccess = FALSE;

        //
        //  build server list for update
        //      - collapse adapters on same network into single adapter
        //      - FAZ to find update servers
        //      - collapse results from same network into single target
        //

        netCount = GetDnsServerListsForUpdate(
                        serverListArray,
                        netCount,
                        pBlob->Flags
                        );

        status = CollapseDnsServerListsForUpdate(
                        serverListArray,
                        networkInfoArray,
                        & netCount,
                        pname );

        DNS_ASSERT( netCount <= UPDATE_ADAPTER_LIMIT );

        if ( netCount == 0 )
        {
            if ( status == ERROR_SUCCESS )
            {
                status = DNS_ERROR_NO_DNS_SERVERS;
            }
            goto Done;
        }

        //
        //  do update on all distinct (disjoint) networks
        //

        for ( iter = 0;
              iter < netCount;
              iter++ )
        {
            PADDR_ARRAY  pdnsArray = serverListArray[ iter ];

            pnetInfo = networkInfoArray[ iter ];
            if ( !pnetInfo )
            {
                ASSERT( FALSE );
                FREE_HEAP( pdnsArray );
                continue;
            }

            DNS_ASSERT( NetInfo_IsForUpdate(pnetInfo) );
            pzoneName = NetInfo_UpdateZoneName( pnetInfo );

            pBlob->pszZone  = pzoneName;
            pBlob->pNetInfo = pnetInfo;
    
            //
            //  multimater update?
            //      - if flag set
            //      - or simple update (best net) times out
            //

            if ( flags & (DNS_UPDATE_TRY_ALL_MASTER_SERVERS | DNS_UPDATE_REMOTE_SERVER) )
            {
                pBlob->pServerList = pdnsArray;

                status = Update_MultiMaster( pBlob );
            }
            else
            {
                status = Update_FazSendFlush( pBlob );

                if ( status == ERROR_TIMEOUT )
                {
                    pBlob->pServerList = pdnsArray;
                    status = Update_MultiMaster( pBlob );
                }
            }

            //  cleanup current network's info
            //  reset blob

            NetInfo_Free( pnetInfo );
            FREE_HEAP( pdnsArray );

            pBlob->pNetInfo     = NULL;
            pBlob->pServerList  = NULL;
            pBlob->pszZone      = NULL;
            DnsAddr_Clear( &pBlob->FailedServer );

            if ( status == NO_ERROR ||
                 ( pBlob->fUpdateTestMode &&
                   ( status == DNS_ERROR_RCODE_YXDOMAIN ||
                     status == DNS_ERROR_RCODE_YXRRSET  ||
                     status == DNS_ERROR_RCODE_NXRRSET  ) ) )
            {
                bsuccess = TRUE;
            }
        }

        //
        //  successful update on any network counts as success
        //
        //  DCR_QUESTION:  not sure why don't just NO_ERROR all bsuccess,
        //      only case would be this fUpdateTestMode thing above
        //      on single network
        //

        if ( bsuccess )
        {
            if ( netCount != 1 )
            {
                status = NO_ERROR;
            }
        }
    }

Done:

    //
    //  force result blob setting for failure cases
    //

    if ( !pBlob->fSavedResults )
    {
        Update_SaveResults(
            pBlob,
            status,
            0,
            NULL );
    }

    DNSDBG( TRACE, (
        "Leaving Update_Private() => %d\n",
        status ));

    IF_DNSDBG( UPDATE )
    {
        DnsDbg_UpdateBlob( "Leaving Update_Private", pBlob );
    }

    return status;
}




//
//  Update credentials
//

//
//  Credentials are an optional future parameter to allow the caller
//  to set the context handle to that of a given NT account. This
//  structure will most likely be the following as defined in rpcdce.h:
//
//  #define SEC_WINNT_AUTH_IDENTITY_ANSI    0x1
//
//  typedef struct _SEC_WINNT_AUTH_IDENTITY_A {
//        unsigned char __RPC_FAR *User;
//        unsigned long UserLength;
//        unsigned char __RPC_FAR *Domain;
//        unsigned long DomainLength;
//        unsigned char __RPC_FAR *Password;
//        unsigned long PasswordLength;
//        unsigned long Flags;
//  } SEC_WINNT_AUTH_IDENTITY_A, *PSEC_WINNT_AUTH_IDENTITY_A;
//
//  #define SEC_WINNT_AUTH_IDENTITY_UNICODE 0x2
//  
//  typedef struct _SEC_WINNT_AUTH_IDENTITY_W {
//    unsigned short __RPC_FAR *User;
//    unsigned long UserLength;
//    unsigned short __RPC_FAR *Domain;
//    unsigned long DomainLength;
//    unsigned short __RPC_FAR *Password;
//    unsigned long PasswordLength;
//    unsigned long Flags;
//  } SEC_WINNT_AUTH_IDENTITY_W, *PSEC_WINNT_AUTH_IDENTITY_W;
//


DNS_STATUS
WINAPI
DnsAcquireContextHandle_W(
    IN      DWORD           CredentialFlags,
    IN      PVOID           Credentials     OPTIONAL,
    OUT     PHANDLE         pContext
    )
/*++

Routine Description:

    Get credentials handle to security context for update.

    The handle can for the default process credentials (user account or
    system machine account) or for a specified set of credentials
    identified by Credentials.

Arguments:

    CredentialFlags -- flags

    Credentials -- a PSEC_WINNT_AUTH_IDENTITY_W
        (explicit definition skipped to avoid requiring rpcdec.h)

    pContext -- addr to receive credentials handle

Return Value:

    ERROR_SUCCESS if successful.
    ErrorCode on failure.

--*/
{
    if ( ! pContext )
    {
        return ERROR_INVALID_PARAMETER;
    }

    *pContext = Dns_CreateAPIContext(
                    CredentialFlags,
                    Credentials,
                    TRUE        // unicode
                    );
    if ( ! *pContext )
    {
        return DNS_ERROR_NO_MEMORY;
    }
    else
    {
        return NO_ERROR;
    }
}



DNS_STATUS
WINAPI
DnsAcquireContextHandle_A(
    IN      DWORD           CredentialFlags,
    IN      PVOID           Credentials     OPTIONAL,
    OUT     PHANDLE         pContext
    )
/*++

Routine Description:

    Get credentials handle to security context for update.

    The handle can for the default process credentials (user account or
    system machine account) or for a specified set of credentials
    identified by Credentials.

Arguments:

    CredentialFlags -- flags

    Credentials -- a PSEC_WINNT_AUTH_IDENTITY_A
        (explicit definition skipped to avoid requiring rpcdec.h)

    pContext -- addr to receive credentials handle

Return Value:

    ERROR_SUCCESS if successful.
    ErrorCode on failure.

--*/
{
    if ( ! pContext )
    {
        return ERROR_INVALID_PARAMETER;
    }

    *pContext = Dns_CreateAPIContext(
                    CredentialFlags,
                    Credentials,
                    FALSE );
    if ( ! *pContext )
    {
        return DNS_ERROR_NO_MEMORY;
    }
    else
    {
        return NO_ERROR;
    }
}



VOID
WINAPI
DnsReleaseContextHandle(
    IN      HANDLE          ContextHandle
    )
/*++

Routine Description:

    Frees context handle created by DnsAcquireContextHandle_X() routines.

Arguments:

    ContextHandle - Handle to be closed.

Return Value:

    None.

--*/
{
    if ( ContextHandle )
    {
        //
        //  free any cached security context handles
        //
        //  DCR_FIX0:  should delete all contexts associated with this
        //      context (credentials handle) not all
        //
        //  DCR:  to be robust, user "ContextHandle" should be ref counted
        //      it should be set one on create;  when in use, incremented
        //      then dec when done;  then this Free could not collide with
        //      another thread's use
        //

        //Dns_TimeoutSecurityContextListEx( TRUE, ContextHandle );

        Dns_TimeoutSecurityContextList( TRUE );

        Dns_FreeAPIContext( ContextHandle );
    }
}



//
//  Utilities
//

DWORD
prepareUpdateRecordSet(
    IN OUT  PDNS_RECORD     pRRSet,
    IN      BOOL            fClearTtl,
    IN      BOOL            fSetFlags,
    IN      WORD            wFlags
    )
/*++

Routine Description:

    Validate and prepare record set for update.
        - record set is single RR set
        - sets record flags for update

Arguments:

    pRRSet -- record set (always in unicode)
        note:  pRRSet is not touched (not OUT param)
        IF fClearTtl AND fSetFlags are both FALSE

    fClearTtl -- clear TTL in records;  TRUE for delete set

    fSetFlags -- set section and delete flags

    wFlags -- flags field to set
            (should contain desired section and delete flags)

Return Value:

    ERROR_SUCCESS if successful.
    ERROR_INVALID_PARAMETER if record set is not acceptable.

--*/
{
    PDNS_RECORD prr;
    PWSTR       pname;
    WORD        type;

    DNSDBG( TRACE, ( "prepareUpdateRecordSet()\n" ));

    //  validate

    if ( !pRRSet )
    {
        return ERROR_INVALID_PARAMETER;
    }

    type = pRRSet->wType;

    //
    //  note:  could do an "update-type" check here, but that just
    //      A) burns unnecessary memory and cycles
    //      B) makes it harder to test bogus records sent in updates
    //          to the server
    //

    pname = pRRSet->pName;
    if ( !pname )
    {
        return ERROR_INVALID_PARAMETER;
    }

    //
    //  check each RR in set
    //      - validate RR is in set
    //      - set RR flags
    //

    prr = pRRSet;

    while ( prr )
    {
        if ( fSetFlags )
        {
            prr->Flags.S.Section = 0;
            prr->Flags.S.Delete = 0;
            prr->Flags.DW |= wFlags;
        }
        if ( fClearTtl )
        {
            prr->dwTtl = 0;
        }

        //  check current RR in set
        //      - matches name and type

        if ( prr != pRRSet )
        {
            if ( prr->wType != type ||
                 ! prr->pName ||
                 ! Dns_NameCompare_W( pname, prr->pName ) )
            {
                return ERROR_INVALID_PARAMETER;
            }
        }

        prr = prr->pNext;
    }

    return  ERROR_SUCCESS;
}



PDNS_RECORD
buildUpdateRecordSet(
    IN OUT  PDNS_RECORD     pPrereqSet,
    IN OUT  PDNS_RECORD     pAddSet,
    IN OUT  PDNS_RECORD     pDeleteSet
    )
/*++

Routine Description:

    Build combined record list for update.
    Combines prereq, delete and add records.

    Note:  records sets always in unicode.

Arguments:

    pPrereqSet -- prerequisite records;  note this does NOT
        include delete preqs (see note below)

    pAddSet -- records to add

    pDeleteSet -- records to delete

Return Value:

    Ptr to combined record list for update.

--*/
{
    PDNS_RECORD plast = NULL;
    PDNS_RECORD pfirst = NULL;


    DNSDBG( TRACE, ( "buildUpdateRecordSet()\n" ));

    //
    //  append prereq set
    //
    //  DCR:  doesn't handle delete prereqs
    //      this is fine because we roll our own, but if
    //      later expand the function, then need them
    //
    //      note, I could add flag==PREREQ datalength==0
    //      test in prepareUpdateRecordSet() function, then
    //      set Delete flag;  however, we'd still have the
    //      question of how to distinguish existence (class==ANY)
    //      prereq from delete (class==NONE) prereq -- without
    //      directly exposing the record Delete flag
    //

    if ( pPrereqSet )
    {
        plast = pPrereqSet;
        pfirst = pPrereqSet;

        prepareUpdateRecordSet(
            pPrereqSet,
            FALSE,          // no TTL clear
            TRUE,           // set flags
            DNSREC_PREREQ   // prereq section
            );

        while ( plast->pNext )
        {
            plast = plast->pNext;
        }
    }

    //
    //  append delete records
    //      do before Add records so that delete\add of same record
    //      leaves it in place
    //

    if ( pDeleteSet )
    {
        if ( !plast )
        {
            plast = pDeleteSet;
            pfirst = pDeleteSet;
        }
        else
        {
            plast->pNext = pDeleteSet;
        }

        prepareUpdateRecordSet(
             pDeleteSet,
             TRUE,                          //  clear TTL
             TRUE,                          //  set flags
             DNSREC_UPDATE | DNSREC_DELETE  //  update section, delete bit
             );

        while ( plast->pNext )
        {
            plast = plast->pNext;
        }
    }

    //
    //  append add records
    //

    if ( pAddSet )
    {
        if ( !plast )
        {
            plast = pAddSet;
            pfirst = pAddSet;
        }
        else
        {
            plast->pNext = pAddSet;
        }
        prepareUpdateRecordSet(
            pAddSet,
            FALSE,              // no TTL change
            TRUE,               // set flags
            DNSREC_UPDATE       // update section
            );
    }

    return pfirst;
}


BOOL
IsPtrUpdate(
    IN      PDNS_RECORD     pRecordList
    )
/*++

Routine Description:

    Check if update is PTR update.

Arguments:

    pRecordList -- update record list

Return Value:

    TRUE if PTR update.
    FALSE otherwise.

--*/
{
    PDNS_RECORD prr = pRecordList;
    BOOL        bptrUpdate = FALSE;

    //
    //  find, then test first record in update section
    //

    while ( prr )
    {
        if ( prr->Flags.S.Section == DNSREC_UPDATE )
        {
            if ( prr->wType == DNS_TYPE_PTR )
            {
                bptrUpdate = TRUE;
            }
            break;
        }
        prr = prr->pNext;
    }

    return bptrUpdate;
}




//
//  Replace functions
//

DNS_STATUS
WINAPI
replaceRecordSetPrivate(
    IN      PDNS_RECORD     pReplaceSet,
    IN      DWORD           Options,
    IN      HANDLE          hCredentials,   OPTIONAL
    IN      PIP4_ARRAY      pServ4List,     OPTIONAL
    IN      PVOID           pExtraInfo,
    IN      DNS_CHARSET     CharSet
    )
/*++

Routine Description:

    Replace record set routine handling all character sets.

Arguments:

    pReplaceSet     - replacement record set

    Options         -  update options

    pServerList     -  list of DNS servers to go to;  if not given, machines
        default servers are queried to find correct servers to send update to

    hCredentials    - handle to credentials to be used for update;  optional,
        if not given security credentials of this process are used in update

    pReserved       - ptr to blob

    CharSet         - character set of incoming records

Return Value:

    ERROR_SUCCESS if update successful.
    ErrorCode from server if server rejects update.
    ERROR_INVALID_PARAMETER if bad param.

--*/
{
    DNS_STATUS      status;
    PDNS_RECORD     preplaceCopy = NULL;
    PDNS_RECORD     pupdateList = NULL;
    BOOL            btypeDelete;
    DNS_RECORD      rrNoCname;
    DNS_RECORD      rrDeleteType;
    BOOL            fcnameUpdate;
    UPDATE_BLOB     blob;
    PDNS_ADDR_ARRAY pservArray = NULL;


    DNSDBG( TRACE, (
        "\n\nDnsReplaceRecordSet()\n"
        "replaceRecordSetPrivate()\n"
        "\tpReplaceSet  = %p\n"
        "\tOptions      = %08x\n"
        "\thCredentials = %p\n"
        "\tpServ4List   = %p\n"
        "\tpExtra       = %p\n"
        "\tCharSet      = %d\n",
        pReplaceSet,
        Options,
        hCredentials,
        pServ4List,
        pExtraInfo,
        CharSet
        ));

    //
    //  read update config
    //

    Reg_RefreshUpdateConfig();

    //
    //  make local record set copy in unicode
    //

    if ( !pReplaceSet )
    {
        status = ERROR_INVALID_PARAMETER;
        goto Cleanup;
    }

    preplaceCopy = Dns_RecordSetCopyEx(
                        pReplaceSet,
                        CharSet,
                        DnsCharSetUnicode );
    if ( !preplaceCopy )
    {
        status = ERROR_INVALID_PARAMETER;
        goto Cleanup;
    }

    //
    //  validate arguments
    //      - must have single RR set
    //      - mark them for update
    //

    status = prepareUpdateRecordSet(
                preplaceCopy,
                FALSE,          // no TTL clear
                TRUE,           // set flags
                DNSREC_UPDATE   // flag as update
                );

    if ( status != ERROR_SUCCESS )
    {
        status = ERROR_INVALID_PARAMETER;
        goto Cleanup;
    }

    //
    //  check if simple type delete
    //

    btypeDelete = ( preplaceCopy->wDataLength == 0 &&
                    preplaceCopy->pNext == NULL );


    //
    //  set security for update
    //

    if ( UseSystemDefaultForSecurity( Options ) )
    {
        Options |= g_UpdateSecurityLevel;
    }
    if ( hCredentials )
    {
        Options |= DNS_UPDATE_CACHE_SECURITY_CONTEXT;
    }

    //
    //  type delete record
    //
    //  if have replace records -- this goes in front
    //  if type delete -- then ONLY need this record
    //

    RtlZeroMemory( &rrDeleteType, sizeof(DNS_RECORD) );
    rrDeleteType.pName          = preplaceCopy->pName;
    rrDeleteType.wType          = preplaceCopy->wType;
    rrDeleteType.wDataLength    = 0;
    rrDeleteType.Flags.DW       = DNSREC_UPDATE | DNSREC_DELETE | DNSREC_UNICODE;

    if ( btypeDelete )
    {
        rrDeleteType.pNext = NULL;
    }
    else
    {
        rrDeleteType.pNext = preplaceCopy;
    }

    pupdateList = &rrDeleteType;

    //
    //  CNAME does not exist precondition record
    //      - for all updates EXCEPT CNAME
    //

    fcnameUpdate = ( preplaceCopy->wType == DNS_TYPE_CNAME );

    if ( !fcnameUpdate )
    {
        RtlZeroMemory( &rrNoCname, sizeof(DNS_RECORD) );
        rrNoCname.pName             = preplaceCopy->pName;
        rrNoCname.wType             = DNS_TYPE_CNAME;
        rrNoCname.wDataLength       = 0;
        rrNoCname.Flags.DW          = DNSREC_PREREQ | DNSREC_NOEXIST | DNSREC_UNICODE;
        rrNoCname.pNext             = &rrDeleteType;

        pupdateList = &rrNoCname;
    }

    //
    //  do the update
    //

    RtlZeroMemory( &blob, sizeof(blob) );

    blob.pRecords       = pupdateList;
    blob.Flags          = Options;
    blob.pServ4List     = pServ4List;
    blob.pExtraInfo     = pExtraInfo;
    blob.hCreds         = hCredentials;

    status = Update_Private( &blob );

    //
    //  CNAME collision test
    //
    //  if replacing CNAME may have gotten silent ignore
    //      - first check if successfully replaced CNAME
    //      - if still not sure, check that no other records
    //      at name -- if NON-CNAME found then treat silent ignore
    //      as YXRRSET error
    //

    if ( fcnameUpdate &&
         ! btypeDelete &&
         status == NO_ERROR )
    {
        PDNS_RECORD     pqueryRR = NULL;
        BOOL            fsuccess = FALSE;

        //
        //  build addr array
        //

        pservArray = Util_GetAddrArray(
                        NULL,           // no copy issue
                        NULL,           // no addr array
                        pServ4List,
                        pExtraInfo );

        //  DCR:  need to query update server list here to
        //      avoid intermediate caching

        status = Query_Private(
                        preplaceCopy->pName,
                        DNS_TYPE_CNAME,
                        DNS_QUERY_BYPASS_CACHE,
                        pservArray,
                        & pqueryRR );

        if ( status == NO_ERROR &&
             Dns_RecordCompare(
                    preplaceCopy,
                    pqueryRR ) )
        {
            fsuccess = TRUE;
        }
        Dns_RecordListFree( pqueryRR );

        if ( fsuccess )
        {
            goto Cleanup;
        }

        //  query for any type at CNAME
        //  if found then assume we got a silent update
        //      success

        status = Query_Private(
                        preplaceCopy->pName,
                        DNS_TYPE_ALL,
                        DNS_QUERY_BYPASS_CACHE,
                        pservArray,
                        & pqueryRR );
    
        if ( status == ERROR_SUCCESS )
        {
            PDNS_RECORD prr = pqueryRR;
    
            while ( prr )
            {
                if ( pReplaceSet->wType != prr->wType &&
                     Dns_NameCompare_W(
                            preplaceCopy->pName,
                            prr->pName ) )
                {
                    status = DNS_ERROR_RCODE_YXRRSET;
                    break;
                }
                prr = prr->pNext;
            }
        }
        else
        {
            status = ERROR_SUCCESS;
        }
    
        Dns_RecordListFree( pqueryRR );
    }


Cleanup:

    Dns_RecordListFree( preplaceCopy );
    DnsAddrArray_Free( pservArray );

    DNSDBG( TRACE, (
        "Leave replaceRecordSetPrivate() = %d\n"
        "Leave DnsReplaceRecordSet()\n\n\n",
        status
        ));

    return status;
}



DNS_STATUS
WINAPI
DnsReplaceRecordSetUTF8(
    IN      PDNS_RECORD     pReplaceSet,
    IN      DWORD           Options,
    IN      HANDLE          hCredentials    OPTIONAL,
    IN      PIP4_ARRAY      aipServers      OPTIONAL,
    IN      PVOID           pReserved
    )
/*++

Routine Description:

    Dynamic update routine to replace record set on DNS server.

Arguments:

    pReplaceSet - new record set for name and type

    Options     -  update options

    pServerList -  list of DNS servers to go to;  if not given, machines
        default servers are queried to find correct servers to send update to

    hCredentials - handle to credentials to be used for update;  optional,
        if not given securit5y credentials of this process are used in update

    pReserved   - ptr to blob

Return Value:

    None.

--*/
{
    return replaceRecordSetPrivate(
                pReplaceSet,
                Options,
                hCredentials,
                aipServers,
                pReserved,
                DnsCharSetUtf8
                );
}



DNS_STATUS
WINAPI
DnsReplaceRecordSetW(
    IN      PDNS_RECORD     pReplaceSet,
    IN      DWORD           Options,
    IN      HANDLE          hCredentials    OPTIONAL,
    IN      PIP4_ARRAY      aipServers      OPTIONAL,
    IN      PVOID           pReserved
    )
/*++

Routine Description:

    Dynamic update routine to replace record set on DNS server.

Arguments:

    pReplaceSet - new record set for name and type

    Options     -  update options

    pServerList -  list of DNS servers to go to;  if not given, machines
        default servers are queried to find correct servers to send update to

    hCredentials - handle to credentials to be used for update;  optional,
        if not given security credentials of this process are used in update

    pReserved   - ptr to blob

Return Value:

    None.

--*/
{
    return replaceRecordSetPrivate(
                pReplaceSet,
                Options,
                hCredentials,
                aipServers,
                pReserved,
                DnsCharSetUnicode
                );
}



DNS_STATUS
WINAPI
DnsReplaceRecordSetA(
    IN      PDNS_RECORD     pReplaceSet,
    IN      DWORD           Options,
    IN      HANDLE          hCredentials    OPTIONAL,
    IN      PIP4_ARRAY      aipServers      OPTIONAL,
    IN      PVOID           pReserved
    )
/*++

Routine Description:

    Dynamic update routine to replace record set on DNS server.

Arguments:

    pReplaceSet - new record set for name and type

    Options     -  update options

    pServerList -  list of DNS servers to go to;  if not given, machines
        default servers are queried to find correct servers to send update to

    hCredentials - handle to credentials to be used for update;  optional,
        if not given security credentials of this process are used in update

    pReserved   - ptr to blob

Return Value:

    None.

--*/
{
    return replaceRecordSetPrivate(
                pReplaceSet,
                Options,
                hCredentials,
                aipServers,
                pReserved,
                DnsCharSetAnsi
                );
}



//
//  Modify functions
//

DNS_STATUS
WINAPI
modifyRecordsInSetPrivate(
    IN      PDNS_RECORD     pAddRecords,
    IN      PDNS_RECORD     pDeleteRecords,
    IN      DWORD           Options,
    IN      HANDLE          hCredentials,   OPTIONAL
    IN      PADDR_ARRAY     pServerList,    OPTIONAL
    IN      PIP4_ARRAY      pServ4List,     OPTIONAL
    IN      PVOID           pReserved,
    IN      DNS_CHARSET     CharSet
    )
/*++

Routine Description:

    Dynamic update routine to replace record set on DNS server.

Arguments:

    pAddRecords - records to register on server

    pDeleteRecords - records to remove from server

    Options     -  update options

    pServerList -  list of DNS servers to go to;  if not given, machines
        default servers are queried to find correct servers to send update to

    hCredentials - handle to credentials to be used for update;  optional,
        if not given security credentials of this process are used in update

    pReserved   - ptr to blob

    CharSet - character set of incoming records

Return Value:

    ERROR_SUCCESS if update successful.
    ErrorCode from server if server rejects update.
    ERROR_INVALID_PARAMETER if bad param.

--*/
{
    DNS_STATUS      status;
    PDNS_RECORD     paddCopy = NULL;
    PDNS_RECORD     pdeleteCopy = NULL;
    PDNS_RECORD     pupdateSet = NULL;
    UPDATE_BLOB     blob;

    DNSDBG( TRACE, (
        "\n\nDns_ModifyRecordsInSet()\n"
        "modifyRecordsInSetPrivate()\n"
        "\tpAddSet      = %p\n"
        "\tpDeleteSet   = %p\n"
        "\tOptions      = %08x\n"
        "\thCredentials = %p\n"
        "\tpServerList  = %p\n"
        "\tpServ4List   = %p\n"
        "\tCharSet      = %d\n",
        pAddRecords,
        pDeleteRecords,
        Options,
        hCredentials,
        pServerList,
        pServ4List,
        CharSet
        ));

    //
    //  read update config
    //

    Reg_RefreshUpdateConfig();

    //
    //  make local copy in unicode
    //

    if ( pAddRecords )
    {
        paddCopy = Dns_RecordSetCopyEx(
                        pAddRecords,
                        CharSet,
                        DnsCharSetUnicode );
    }
    if ( pDeleteRecords )
    {
        pdeleteCopy = Dns_RecordSetCopyEx(
                        pDeleteRecords,
                        CharSet,
                        DnsCharSetUnicode );
    }

    //
    //  validate arguments
    //      - add and delete must be for single RR set
    //      and must be for same RR set
    //

    if ( !paddCopy && !pdeleteCopy )
    {
        return ERROR_INVALID_PARAMETER;
    }

    if ( paddCopy )
    {
        status = prepareUpdateRecordSet(
                    paddCopy,
                    FALSE,          // no TTL clear
                    FALSE,          // no flag clear
                    0               // no flags to set
                    );
        if ( status != ERROR_SUCCESS )
        {
            status = ERROR_INVALID_PARAMETER;
            goto Cleanup;
        }
    }
    if ( pdeleteCopy )
    {
        status = prepareUpdateRecordSet(
                    pdeleteCopy,
                    FALSE,          // no TTL clear
                    FALSE,          // no flag clear
                    0               // no flags to set
                    );
        if ( status != ERROR_SUCCESS )
        {
            status = ERROR_INVALID_PARAMETER;
            goto Cleanup;
        }
    }

    if ( paddCopy &&
         pdeleteCopy &&
         ! Dns_NameCompare_W( paddCopy->pName, pdeleteCopy->pName ) )
    {
        status = ERROR_INVALID_PARAMETER;
        goto Cleanup;
    }

    //
    //  set security for update
    //

    if ( UseSystemDefaultForSecurity( Options ) )
    {
        Options |= g_UpdateSecurityLevel;
    }
    if ( hCredentials )
    {
        Options |= DNS_UPDATE_CACHE_SECURITY_CONTEXT;
    }

    //
    //  create update RRs
    //      - no prereqs
    //      - delete RRs set for delete
    //      - add RRs appended
    //

    pupdateSet = buildUpdateRecordSet(
                        NULL,           // no precons
                        paddCopy,
                        pdeleteCopy );

    //
    //  do the update
    //

    RtlZeroMemory( &blob, sizeof(blob) );

    blob.pRecords       = pupdateSet;
    blob.Flags          = Options;
    blob.pServerList    = pServerList;
    blob.pServ4List     = pServ4List;
    blob.pExtraInfo     = pReserved;
    blob.hCreds         = hCredentials;

    status = Update_Private( &blob );

    //
    //  cleanup local copy
    //

    Dns_RecordListFree( pupdateSet );

    goto Exit;


Cleanup:

    //
    //  cleanup copies on failure before combined list
    //

    Dns_RecordListFree( paddCopy );
    Dns_RecordListFree( pdeleteCopy );

Exit:

    DNSDBG( TRACE, (
        "Leave modifyRecordsInSetPrivate() => %d\n"
        "Leave Dns_ModifyRecordsInSet()\n\n\n",
        status ));

    return status;
}



DNS_STATUS
WINAPI
DnsModifyRecordsInSet_W(
    IN      PDNS_RECORD     pAddRecords,
    IN      PDNS_RECORD     pDeleteRecords,
    IN      DWORD           Options,
    IN      HANDLE          hCredentials,   OPTIONAL
    IN      PIP4_ARRAY      pServerList,    OPTIONAL
    IN      PVOID           pReserved
    )
/*++

Routine Description:

    Dynamic update routine to modify record set on DNS server.

Arguments:

    pAddRecords - records to register on server

    pDeleteRecords - records to remove from server

    Options     -  update options

    pServerList -  list of DNS servers to go to;  if not given, machines
        default servers are queried to find correct servers to send update to

    hCredentials - handle to credentials to be used for update;  optional,
        if not given security credentials of this process are used in update

    pReserved   - ptr to blob

Return Value:

    ERROR_SUCCESS if update successful.
    ErrorCode from server if server rejects update.
    ERROR_INVALID_PARAMETER if bad param.

--*/
{
    return  modifyRecordsInSetPrivate(
                pAddRecords,
                pDeleteRecords,
                Options,
                hCredentials,
                NULL,       // no IP6 servers
                pServerList,
                pReserved,
                DnsCharSetUnicode
                );
}



DNS_STATUS
WINAPI
DnsModifyRecordsInSet_A(
    IN      PDNS_RECORD     pAddRecords,
    IN      PDNS_RECORD     pDeleteRecords,
    IN      DWORD           Options,
    IN      HANDLE          hCredentials,   OPTIONAL
    IN      PIP4_ARRAY      pServerList,    OPTIONAL
    IN      PVOID           pReserved
    )
/*++

Routine Description:

    Dynamic update routine to modify record set on DNS server.

Arguments:

    pAddRecords - records to register on server

    pDeleteRecords - records to remove from server

    Options     -  update options

    pServerList -  list of DNS servers to go to;  if not given, machines
        default servers are queried to find correct servers to send update to

    hCredentials - handle to credentials to be used for update;  optional,
        if not given security credentials of this process are used in update

    pReserved   - ptr to blob

Return Value:

    ERROR_SUCCESS if update successful.
    ErrorCode from server if server rejects update.
    ERROR_INVALID_PARAMETER if bad param.

--*/
{
    return  modifyRecordsInSetPrivate(
                pAddRecords,
                pDeleteRecords,
                Options,
                hCredentials,
                NULL,       // no IP6 servers
                pServerList,
                pReserved,
                DnsCharSetAnsi
                );
}



DNS_STATUS
WINAPI
DnsModifyRecordsInSet_UTF8(
    IN      PDNS_RECORD     pAddRecords,
    IN      PDNS_RECORD     pDeleteRecords,
    IN      DWORD           Options,
    IN      HANDLE          hCredentials,   OPTIONAL
    IN      PIP4_ARRAY      pServerList,    OPTIONAL
    IN      PVOID           pReserved
    )
/*++

Routine Description:

    Dynamic update routine to modify record set on DNS server.

Arguments:

    pAddRecords - records to register on server

    pDeleteRecords - records to remove from server

    Options     -  update options

    pServerList -  list of DNS servers to go to;  if not given, machines
        default servers are queried to find correct servers to send update to

    hCredentials - handle to credentials to be used for update;  optional,
        if not given security credentials of this process are used in update

    pReserved   - ptr to blob

Return Value:

    ERROR_SUCCESS if update successful.
    ErrorCode from server if server rejects update.
    ERROR_INVALID_PARAMETER if bad param.

--*/
{
    return  modifyRecordsInSetPrivate(
                pAddRecords,
                pDeleteRecords,
                Options,
                hCredentials,
                NULL,       // no IP6 servers
                pServerList,
                pReserved,
                DnsCharSetUtf8
                );
}




//
//  Update test functions are called by system components
//

DNS_STATUS
WINAPI
DnsUpdateTest_UTF8(
    IN      HANDLE          hCredentials OPTIONAL,
    IN      PCSTR           pszName,
    IN      DWORD           Flags,
    IN      PIP4_ARRAY      pServerList  OPTIONAL
    )
/*++

Routine Description:

    Dynamic DNS routine to test whether the caller can update the
    records in the DNS domain name space for the given record name.

Arguments:

    hCredentials - handle to credentials to be used for update.

    pszName -  the record set name that the caller wants to test.

    Flags - the Dynamic DNS update options that the caller may wish to
               use (see dnsapi.h).

    pServerList -  a specific list of servers to goto to figure out the
                  authoritative DNS server(s) for the given record set
                  domain zone name.

Return Value:

    None.

--*/
{
    PWSTR       pnameWide = NULL;
    DNS_STATUS  status = NO_ERROR;

    DNSDBG( TRACE, (
        "\n\nDnsUpdateTest_UTF8( %s )\n",
        pszName ));


    if ( !pszName )
    {
        return ERROR_INVALID_PARAMETER;
    }

    pnameWide = Dns_NameCopyAllocate(
                    (PCHAR) pszName,
                    0,
                    DnsCharSetUtf8,
                    DnsCharSetUnicode );
    if ( !pnameWide )
    {
        return ERROR_INVALID_NAME;
    }

    status = DnsUpdateTest_W(
                hCredentials,
                (PCWSTR) pnameWide,
                Flags,
                pServerList );

    FREE_HEAP( pnameWide );

    return  status;
}


DNS_STATUS
WINAPI
DnsUpdateTest_A(
    IN      HANDLE          hCredentials OPTIONAL,
    IN      PCSTR           pszName,
    IN      DWORD           Flags,
    IN      PIP4_ARRAY      pServerList  OPTIONAL
    )
/*++

Routine Description:

    Dynamic DNS routine to test whether the caller can update the
    records in the DNS domain name space for the given record name.

Arguments:

    hCredentials - handle to credentials to be used for update.

    pszName -  the record set name that the caller wants to test.

    Flags - the Dynamic DNS update options that the caller may wish to
               use (see dnsapi.h).

    pServerList -  a specific list of servers to goto to figure out the
                  authoritative DNS server(s) for the given record set
                  domain zone name.

Return Value:

    None.

--*/
{
    PWSTR       pnameWide = NULL;
    DNS_STATUS  status = NO_ERROR;

    DNSDBG( TRACE, (
        "\n\nDnsUpdateTest_UTF8( %s )\n",
        pszName ));


    if ( !pszName )
    {
        return ERROR_INVALID_PARAMETER;
    }

    pnameWide = Dns_NameCopyAllocate(
                    (PCHAR) pszName,
                    0,
                    DnsCharSetUtf8,
                    DnsCharSetUnicode );
    if ( !pnameWide )
    {
        return ERROR_INVALID_NAME;
    }

    status = DnsUpdateTest_W(
                hCredentials,
                (PCWSTR) pnameWide,
                Flags,
                pServerList );

    FREE_HEAP( pnameWide );

    return  status;
}


DNS_STATUS
WINAPI
DnsUpdateTest_W(
    IN      HANDLE          hCredentials    OPTIONAL,
    IN      PCWSTR          pszName,
    IN      DWORD           Flags,
    IN      PIP4_ARRAY      pServerList     OPTIONAL
    )
/*++

Routine Description:

    Dynamic DNS routine to test whether the caller can update the
    records in the DNS domain name space for the given record name.

Arguments:

    hCredentials - handle to credentials to be used for update.

    pszName -  the record set name that the caller wants to test.

    Flags - the Dynamic DNS update options that the caller may wish to
               use (see dnsapi.h).

    pServerList -  a specific list of servers to goto to figure out the
                  authoritative DNS server(s) for the given record set
                  domain zone name.

Return Value:

    None.

--*/
{
    DNS_STATUS      status = NO_ERROR;
    DNS_RECORD      record;
    DWORD           flags = Flags;
    UPDATE_BLOB     blob;

    DNSDBG( TRACE, (
        "\n\nDnsUpdateTest_W( %S )\n",
        pszName ));

    //
    //  validation
    //

    if ( flags & DNS_UNACCEPTABLE_UPDATE_OPTIONS )
    {
        status = ERROR_INVALID_PARAMETER;
        goto Exit;
    }
    if ( !pszName )
    {
        status = ERROR_INVALID_PARAMETER;
        goto Exit;
    }

    //
    //  read update config
    //

    Reg_RefreshUpdateConfig();

    if ( UseSystemDefaultForSecurity( flags ) )
    {
        flags |= g_UpdateSecurityLevel;
    }
    if ( hCredentials )
    {
        flags |= DNS_UPDATE_CACHE_SECURITY_CONTEXT;
    }

    //
    //  build record
    //      - NOEXIST prerequisite
    //

    RtlZeroMemory( &record, sizeof(DNS_RECORD) );
    record.pName = (PWSTR) pszName;
    record.wType = DNS_TYPE_ANY;
    record.wDataLength = 0;
    record.Flags.DW = DNSREC_PREREQ | DNSREC_NOEXIST | DNSREC_UNICODE;

    //
    //  do the prereq update
    //

    RtlZeroMemory( &blob, sizeof(blob) );
    blob.pRecords           = &record;
    blob.Flags              = flags;
    blob.fUpdateTestMode    = TRUE;
    blob.pServ4List         = pServerList;
    blob.hCreds             = hCredentials;

    status = Update_Private( &blob );

Exit:

    DNSDBG( TRACE, (
        "Leave DnsUpdateTest_W() = %d\n\n\n",
        status ));

    return status;
}



//
//  Old routines -- exported and used in dnsup.exe
//
//  DCR:  Work toward removing these old update functions.
//

DNS_STATUS
Dns_UpdateLib(
    IN      PDNS_RECORD         pRecord,
    IN      DWORD               dwFlags,
    IN      PDNS_NETINFO        pNetworkInfo,
    IN      HANDLE              hCreds          OPTIONAL,
    OUT     PDNS_MSG_BUF *      ppMsgRecv       OPTIONAL
    )
/*++

Routine Description:

    Interface for dnsup.exe.

Arguments:

    pRecord -- list of records to send in update

    dwFlags -- update flags;  primarily security

    pNetworkInfo -- adapter list with necessary info for update
                        - zone name
                        - primary name server name
                        - primary name server IP

    hCreds -- credentials handle returned from


    ppMsgRecv -- OPTIONAL addr to recv ptr to response message

Return Value:

    ERROR_SUCCESS if successful.
    Error status on failure.

--*/
{
    return  ERROR_INVALID_PARAMETER;
#if 0
    DNS_STATUS  status;
    UPDATE_BLOB blob;

    DNSDBG( UPDATE, (
        "Dns_UpdateLib()\n"
        "\tflags        = %08x\n"
        "\tpRecord      = %p\n"
        "\t\towner      = %S\n",
        dwFlags,
        pRecord,
        pRecord ? pRecord->pName : NULL ));

    //
    //  create blob
    //

    RtlZeroMemory( &blob, sizeof(blob) );

    blob.pRecords   = pRecord;
    blob.Flags      = dwFlags;
    blob.pNetInfo   = pNetworkInfo;
    blob.hCreds     = hCreds;

    if ( ppMsgRecv )
    {
        blob.fSaveRecvMsg = TRUE;
    }

    status = Update_FazSendFlush( &blob );

    if ( ppMsgRecv )
    {
        *ppMsgRecv = blob.pMsgRecv;
    }

    DNSDBG( UPDATE, (
        "Leave Dns_UpdateLib() => %d %s.\n\n",
        status,
        Dns_StatusString(status) ));

    return( status );
#endif
}



DNS_STATUS
Dns_UpdateLibEx(
    IN      PDNS_RECORD         pRecord,
    IN      DWORD               dwFlags,
    IN      PWSTR               pszZone,
    IN      PWSTR               pszServerName,
    IN      PIP4_ARRAY          aipServers,
    IN      HANDLE              hCreds          OPTIONAL,
    OUT     PDNS_MSG_BUF *      ppMsgRecv       OPTIONAL
    )
/*++

Routine Description:

    Send DNS update.

    This routine builds an UPDATE compatible pNetworkInfo from the
    information given.  Then calls Dns_Update().

Arguments:

    pRecord -- list of records to send in update

    pszZone -- zone name for update

    pszServerName -- server name

    aipServers -- DNS servers to send update to

    hCreds -- Optional Credentials info

    ppMsgRecv -- addr for ptr to recv buffer, if desired

Return Value:

    ERROR_SUCCESS if successful.
    Error status on failure.

--*/
{
    return  ERROR_INVALID_PARAMETER;
#if 0
    PDNS_NETINFO        pnetInfo;
    DNS_STATUS          status = NO_ERROR;

    DNSDBG( UPDATE, ( "Dns_UpdateLibEx()\n" ));

    //
    //  convert params into UPDATE compatible adapter list
    //

    pnetInfo = NetInfo_CreateForUpdateIp4(
                        pszZone,
                        pszServerName,
                        aipServers,
                        0 );
    if ( !pnetInfo )
    {
        return( ERROR_INVALID_PARAMETER );
    }

    //
    //  call real update function
    //

    status = Dns_UpdateLib(
                pRecord,
                dwFlags,
                pnetInfo,
                hCreds,
                ppMsgRecv );

    NetInfo_Free( pnetInfo );


    DNSDBG( UPDATE, (
        "Leave Dns_UpdateLibEx() => %d\n",
        status ));

    return status;
#endif
}



DNS_STATUS
DnsUpdate(
    IN      PDNS_RECORD         pRecord,
    IN      DWORD               dwFlags,
    IN      PDNS_NETINFO        pNetworkInfo,
    IN      HANDLE              hCreds,         OPTIONAL
    OUT     PDNS_MSG_BUF *      ppMsgRecv       OPTIONAL
    )
/*++

Routine Description:

    Send DNS update.

    Note if pNetworkInfo is not specified or not a valid UPDATE adapter list,
    then a FindAuthoritativeZones (FAZ) query is done prior to the update.

Arguments:

    pRecord         -- list of records to send in update

    dwFlags         -- flags to update

    pNetworkInfo    -- DNS servers to send update to

    ppMsgRecv       -- addr for ptr to recv buffer, if desired

Return Value:

    ERROR_SUCCESS if successful.
    Error status on failure.

--*/
{
    return  ERROR_INVALID_PARAMETER;
#if 0
    DNS_STATUS      status;
    PDNS_NETINFO    plocalNetworkInfo = NULL;
    UPDATE_BLOB     blob;

    DNSDBG( TRACE, ( "DnsUpdate()\n" ));

    //
    //  create blob
    //

    RtlZeroMemory( &blob, sizeof(blob) );

    blob.pRecords   = pRecord;
    blob.Flags      = dwFlags;
    blob.pNetInfo   = pNetworkInfo;
    blob.hCreds     = hCreds;

    if ( ppMsgRecv )
    {
        blob.fSaveRecvMsg = TRUE;
    }

    status = Update_FazSendFlush( &blob );

    if ( ppMsgRecv )
    {
        *ppMsgRecv = blob.pMsgRecv;
    }

    DNSDBG( UPDATE, (
        "Leave DnsUpdate() => %d\n",
        status ));

    return  status;
#endif
}

//
//  End update.c
//
=== C:/Users/treeman/Desktop/windows nt source code\Source\Win2K3\NT\ds\dns\dnsapi\test\clntreg\clntreg.c ===
/*++

Copyright (c) 1997 Microsoft Corporation

Module Name:

    adddom.c

Abstract:

    Domain Name System (DNS) Server

    Test Code for adding a Zone

Author:

    Ram Viswanathan (ramv) 14th March 1997

Revision History:

    Ram Viswanathan (ramv) 14th March 1997   Created

                           5th May 1997  Added Callback function testing
--*/



#include <windows.h>

//
// ********* CRunTime Includes
//

#include <stdlib.h>
#include <limits.h>
#include <io.h>
#include <stdio.h>
#include "dns.h"
#include "dnsapi.h"
#include "dnslib.h"

INT __cdecl
main (int argc, char *argv[])
{
    DWORD  dwRes;

    LPSTR  pszMapFile = NULL;
    INT    i;
    BOOL   fDownLevel =FALSE;
    DWORD  dwOperation = DYNDNS_ADD_ENTRY;
    LPSTR  lpTemp = NULL;
    DWORD   Part1, Part2, Part3, Part4;
    FILE *fp = NULL;
    CHAR   szInputString[MAX_PATH];
    CHAR   szAddr[20];
    LPSTR pszAddr = NULL;
    CHAR   szName[50];
    CHAR    c;
    DWORD dwFlags = 0;
    char seps[]=" ,\t\n";
    CHAR AdapterName[50];
    CHAR HostName[50];
    CHAR DomainName[50];
    INT  ipAddrCount;
    REGISTER_HOST_ENTRY HostAddrs[5];
    char *token;

    //
    // 1st argument is a/d (for add or delete)
    // 2nd argument is f/n (register forwards/not register forwards)
    // 3rd argument is filename

    // Note that no optional parameters are set
    //

    if (argc != 2){
        
        printf("Usage is %s filename \n", argv[0]);
        exit(-1);
    }

        
    pszMapFile  = argv[1];

    //
    // set up stuff for registration
    //

    dwRes = DnsAsyncRegisterInit(NULL);

    if (dwRes){
        printf("Init failed with %x\n", dwRes);
    }


    if (!(fp = fopen (pszMapFile, "r+"))){
        printf(" Could not open map file %s \n", pszMapFile);
    }

    while (fgets (szInputString, MAX_PATH, fp) != NULL){
        //
        // parse the input string
        //
        token = strtok(szInputString, seps);

        strcpy (AdapterName, token);

        token =strtok(NULL, seps);
        strcpy (HostName, token);
            
        token =strtok(NULL, seps);
        strcpy (DomainName, token);

        ipAddrCount = 0;

        token =strtok(NULL, seps);
        while ( token != NULL){
            strcpy (szAddr, token);

            lpTemp = strtok( szAddr, "." );
            Part1 = atoi( lpTemp );
            lpTemp = strtok( NULL, "." );
            Part2 = atoi( lpTemp );
            lpTemp = strtok( NULL, "." );
            Part3 = atoi( lpTemp );
            lpTemp = strtok( NULL, "." );
            Part4 = atoi( lpTemp );


            printf( "\nRegistering DNS record for:\n" );
            printf("AdapterName = %s\n", AdapterName);
            printf("HostName = %s\n", HostName);
            printf("DomainName = %s\n", DomainName);
            
            printf( "Address: %d.%d.%d.%d\n", Part1, Part2, Part3, Part4 );

            HostAddrs[ipAddrCount].dwOptions = REGISTER_HOST_PTR;

            HostAddrs[ipAddrCount].Addr.ipAddr = (DWORD)(Part1) + (DWORD)(Part2 << 8) + 
                (DWORD)(Part3 << 16) + (DWORD)(Part4 << 24);


            ipAddrCount++;
            token =strtok(NULL, seps);  

        }


        dwRes = DnsAsyncRegisterHostAddrs_A (
                    AdapterName,
                    HostName,
                    HostAddrs,
                    ipAddrCount,
                    NULL,
                    0,
                    DomainName,
                    NULL,
                    40,
                    0
                    );

        if (dwRes){
            printf("Host Name registration failed with %x\n", dwRes);
        }
                
    }

    fclose(fp);
    
    printf("Hit Enter to do the ipconfig /release now! \n");
    c = getchar();


    //
    // do the releases now
    //

    
    if (!(fp = fopen (pszMapFile, "r+"))){
        printf(" Could not open map file %s \n", pszMapFile);
    }

    while (fgets (szInputString, MAX_PATH, fp) != NULL){
        //
        // parse the input string
        //
        token = strtok(szInputString, seps);

        strcpy (AdapterName, token);

        token =strtok(NULL, seps);
        strcpy (HostName, token);
            
        token =strtok(NULL, seps);
        strcpy (DomainName, token);

        ipAddrCount = 0;

        token =strtok(NULL, seps);
        while ( token != NULL){
            strcpy (szAddr, token);

            lpTemp = strtok( szAddr, "." );
            Part1 = atoi( lpTemp );
            lpTemp = strtok( NULL, "." );
            Part2 = atoi( lpTemp );
            lpTemp = strtok( NULL, "." );
            Part3 = atoi( lpTemp );
            lpTemp = strtok( NULL, "." );
            Part4 = atoi( lpTemp );


            printf( "\nRegistering DNS record for:\n" );
            printf("AdapterName = %s\n", AdapterName);
            printf("HostName = %s\n", HostName);
            printf("DomainName = %s\n", DomainName);
            
            printf( "Address: %d.%d.%d.%d\n", Part1, Part2, Part3, Part4 );

            HostAddrs[ipAddrCount].dwOptions = REGISTER_HOST_PTR;

            HostAddrs[ipAddrCount].Addr.ipAddr = (DWORD)(Part1) + (DWORD)(Part2 << 8) + 
                (DWORD)(Part3 << 16) + (DWORD)(Part4 << 24);


            ipAddrCount++;
            token =strtok(NULL, seps);  

        }


        dwRes = DnsAsyncRegisterHostAddrs_A (
                    AdapterName,
                    HostName,
                    HostAddrs,
                    ipAddrCount,
                    NULL,
                    0,
                    DomainName,
                    NULL,
                    40,
                    DYNDNS_DEL_ENTRY
                    );

        if (dwRes){
            printf("Host Name registration failed with %x\n", dwRes);
        }
                
    }

    fclose(fp);     

    printf("Hit Enter to do the ipconfig /renew now! \n");
    c = getchar();



    if (!(fp = fopen (pszMapFile, "r+"))){
        printf(" Could not open map file %s \n", pszMapFile);
    }

    while (fgets (szInputString, MAX_PATH, fp) != NULL){
        //
        // parse the input string
        //
        token = strtok(szInputString, seps);

        strcpy (AdapterName, token);

        token =strtok(NULL, seps);
        strcpy (HostName, token);
            
        token =strtok(NULL, seps);
        strcpy (DomainName, token);

        ipAddrCount = 0;

        token =strtok(NULL, seps);
        while ( token != NULL){
            strcpy (szAddr, token);

            lpTemp = strtok( szAddr, "." );
            Part1 = atoi( lpTemp );
            lpTemp = strtok( NULL, "." );
            Part2 = atoi( lpTemp );
            lpTemp = strtok( NULL, "." );
            Part3 = atoi( lpTemp );
            lpTemp = strtok( NULL, "." );
            Part4 = atoi( lpTemp );


            printf( "\nRegistering DNS record for:\n" );
            printf("AdapterName = %s\n", AdapterName);
            printf("HostName = %s\n", HostName);
            printf("DomainName = %s\n", DomainName);
            
            printf( "Address: %d.%d.%d.%d\n", Part1, Part2, Part3, Part4 );

            HostAddrs[ipAddrCount].dwOptions = REGISTER_HOST_PTR;

            HostAddrs[ipAddrCount].Addr.ipAddr = (DWORD)(Part1) + (DWORD)(Part2 << 8) + 
                (DWORD)(Part3 << 16) + (DWORD)(Part4 << 24);


            ipAddrCount++;
            token =strtok(NULL, seps);  

        }


        dwRes = DnsAsyncRegisterHostAddrs_A (
                    AdapterName,
                    HostName,
                    HostAddrs,
                    ipAddrCount,
                    NULL,
                    0,
                    DomainName,
                    NULL,
                    40,
                    0
                    );

        if (dwRes){
            printf("Host Name registration failed with %x\n", dwRes);
        }
                
    }

    fclose(fp);
    
    c = getchar();
    dwRes = DnsAsyncRegisterTerm();

    if (dwRes){
        printf("Termination failed with %x\n", dwRes);
    }

    c = getchar();
error:
    return(1);

}
=== C:/Users/treeman/Desktop/windows nt source code\Source\Win2K3\NT\ds\dns\dnsexts\common.h ===
/*******************************************************************
*
*    File        : common.h
*    Author      : Eyal Schwartz
*    Copyrights  : Microsoft Corp (C) 1996
*    Date        : 9/17/1996
*    Description : common declarations
*
*    Revisions   : <date> <name> <description>
*******************************************************************/



#ifndef COMMON_H
#define COMMON_H



#ifdef __cplusplus
extern "C" {
#endif
// include //
#include <nt.h>
#include <ntrtl.h>
#include <nturtl.h>
#ifdef __cplusplus
}
#endif

#include <tchar.h>
#include <windows.h>
#include <assert.h>
#include <stdio.h>
#include <ntsdexts.h>
// #include <crtdbg.h>


// defines //

// defaults
#define MAXSTR			   1024
#define MAXLIST            256
#define MAX_TINY_LIST      32



// ntsd extensions
// Macros to easily access extensions helper routines for printing, etc.
// In particular, Printf() takes the same arguments as the CRT printf().
//

#define ASSIGN_NTSDEXTS_GLOBAL(api, str, proc)  \
{                                         \
   glpExtensionApis = api;                \
   glpArgumentString = str;               \
   ghCurrentProcess = proc;               \
}


extern PNTSD_EXTENSION_APIS glpExtensionApis;
extern LPSTR glpArgumentString;
extern LPVOID ghCurrentProcess;

#define Printf          (glpExtensionApis->lpOutputRoutine)
#define GetSymbol       (glpExtensionApis->lpGetSymbolRoutine)
#define GetExpr         (glpExtensionApis->lpGetExpressionRoutine)
#define CheckC          (glpExtensionApis->lpCheckControlCRoutine)



#ifdef DEBUG
#define DEBUG0(str)           Printf(str)
#define DEBUG1(format, arg1)  Printf(format, arg1)
#define DEBUG2(format, arg1, arg2)  Printf(format, arg1, arg2)
#else
#define DEBUG0(str)
#define DEBUG1(format, arg1)
#define DEBUG2(format, arg1, arg2)
#endif



#endif

/******************* EOF *********************/


=== C:/Users/treeman/Desktop/windows nt source code\Source\Win2K3\NT\ds\dns\dnsexts\dump.cxx ===
/*******************************************************************
*
*    File        : dump.cxx
*    Author      : Eyal Schwartz
*    Copyrights  : Microsoft Corp (C) 1996
*    Date        : 7/15/1998
*    Description : implentation of dump routines
*
*    Revisions   : <date> <name> <description>
*******************************************************************/



#ifndef DUMP_CXX
#define DUMP_CXX



// include //
// common
#include "common.h"
#include "util.hxx"
#include <winsock2.h>
#include <winldap.h>
#include <windns.h>
// dns structures
#include "dns.h"
#include "tree.h"
// Ignore zero sized array warnings.
#pragma warning (disable : 4200)
#include "dnsrpc.h"
#include "name.h"
#include "record.h"
#include "update.h"
#include "dpart.h"
#include "EventControl.h"
#include "zone.h"
#include "msginfo.h"
// local
#include "dump.hxx"



// types //

//
//  Protos for exported functions
//

DECLARE_DUMPFUNCTION( Dump_DNS_MSGINFO );
DECLARE_DUMPFUNCTION( Dump_DS_SEARCH );
DECLARE_DUMPFUNCTION( Dump_Help );
DECLARE_DUMPFUNCTION( Dump_SockAddr );
DECLARE_DUMPFUNCTION( Dump_DB_NODE );
DECLARE_DUMPFUNCTION( Dump_COUNT_NAME );
DECLARE_DUMPFUNCTION( Dump_ZONE_INFO );
DECLARE_DUMPFUNCTION( Dump_DB_RECORD );
DECLARE_DUMPFUNCTION( Dump_IP_ARRAY );
DECLARE_DUMPFUNCTION( Dump_UPDATE );
DECLARE_DUMPFUNCTION( Dump_UPDATE_LIST );
DECLARE_DUMPFUNCTION( Dump_DNS_WIRE_QUESTION );
DECLARE_DUMPFUNCTION( Dump_LOOKUP_NAME );
DECLARE_DUMPFUNCTION( Dump_DNS_HEADER );
DECLARE_DUMPFUNCTION( Dump_HEAP_HEADER );

//
//  Private protos
//

DECLARE_DUMPFUNCTION( Dump_ADDITIONAL_INFO );
DECLARE_DUMPFUNCTION( Dump_COMPRESSION_INFO );
DECLARE_DUMPFUNCTION( Dump_Record_SOA );
DECLARE_DUMPFUNCTION( Dump_SID );

VOID
DumpBuffer(
    PVOID Buffer,
    DWORD BufferSize );


//
//  Dispatch table
//

DUMPENTRY gfDumpTable[] =
{
    "COUNT_NAME"    ,   Dump_COUNT_NAME,
    "DB_NODE"       ,   Dump_DB_NODE,
    "DB_RECORD"     ,   Dump_DB_RECORD,
    "DNS_HEADER"    ,   Dump_DNS_HEADER,
    "DNS_WIRE_QUESTION"  ,   Dump_DNS_WIRE_QUESTION,
    "DS_SEARCH"     ,   Dump_DS_SEARCH,
    "HEAP_HEADER"   ,   Dump_HEAP_HEADER,
    "HELP"          ,   Dump_Help,
    "IP_ARRAY"      ,   Dump_IP_ARRAY,
    "LOOKUP_NAME"   ,   Dump_LOOKUP_NAME,
    "MSGINFO"       ,   Dump_DNS_MSGINFO,
    "SOCKADDR"      ,   Dump_SockAddr,
    "UPDATE"        ,   Dump_UPDATE,
    "UPDATE_LIST"   ,   Dump_UPDATE_LIST,
    "ZONE_INFO"     ,   Dump_ZONE_INFO,
    "SID"           ,   Dump_SID
};

const INT gcbDumpTable = (sizeof(gfDumpTable) / sizeof(DUMPENTRY) );


// functions //

/*+++
Function   : Dump_Help
Description: print out dump usage
Parameters : none.
Return     :
Remarks    : none.
---*/

DECLARE_DUMPFUNCTION( Dump_Help)
{
    Printf( "dnsexts.dump <DATATYPE> <ADDRESS>\n  <ADDRESS> := any hex debugger valid address\n" );
    Printf( "  <DATATYPE> :=\n" );
    Printf( "\tCOUNT_NAME: Counted name definition.\n" );
    Printf( "\tDB_NODE: Tree node definition.\n" );
    Printf( "\tDB_RECORD: RR structure.\n" );
    Printf( "\tDNS_HEADER: DNS Header.\n" );
    Printf( "\tDNS_WIRE_QUESTION: DNS Question.\n" );
    Printf( "\tHEAP_HEADER: DNS heap header.\n" );
    Printf( "\tHELP: print this screen.\n" );
    Printf( "\tIP_ARRAY: IP Address Array type.\n" );
    Printf( "\tLOCK_TABLE: Debug lock tracking table.\n" );
    Printf( "\tLOOKUP_NAME: Lookup name definition.\n" );
    Printf( "\tMSGINFO: DNS Server Message Info structure.\n" );
    Printf( "\tSOCKADDR: Winsock address.\n" );
    Printf( "\tUPDATE: Update list entry.\n" );
    Printf( "\tUPDATE_LIST: Update list table.\n" );
    Printf( "\tZONE_INFO: Zone information type.\n" );
    Printf( "\tSID: Dump given SID.\n" );
    Printf( "---\n" );

    return TRUE;
}

/*+++
Function   : Dump_DNS_MSGINFO
Description: dumps out message info
Parameters :
Return     :
Remarks    : none.
---*/

DECLARE_DUMPFUNCTION( Dump_DNS_MSGINFO )
{
    Printf( "DNS_MSGINFO(0x%p):\n", lpVoid );

    if ( !lpVoid )
    {
        Printf( "Cannot process [%p] pointer\n", lpVoid );
        return FALSE;
    }

    //
    //  DNS_MSGINFO header
    //

    PDNS_MSGINFO pMsg = (PDNS_MSGINFO) PushMemory( lpVoid, sizeof(DNS_MSGINFO) );;

    Printf( " ListEntry = {Flink=0x%p, Blink=0x%p}\n", pMsg->ListEntry.Flink, pMsg->ListEntry.Blink );
    Printf( " Socket = 0x%x\n", (DWORD)pMsg->Socket );
#if 0
    Printf( " RemoteAddressLength = 0x%x (%d)\n", pMsg->RemoteAddressLength, pMsg->RemoteAddressLength );
    Printf( " RemoteAddress -- " );
    Dump_SockAddr((LPVOID)&(pMsg->RemoteAddress) );
#endif
    Printf( " BufferLength = 0x%x\n", pMsg->BufferLength );
    Printf( " pBufferEnd = 0x%p\n", pMsg->pBufferEnd );
    Printf( " pCurrent = 0x%p\n", pMsg->pCurrent );
    Printf( " pnodeCurrent = 0x%p\n", pMsg->pnodeCurrent );
    Printf( " pzoneCurrent = 0x%p\n", pMsg->pzoneCurrent );
    Printf( " pnodeDelegation = 0x%p\n", pMsg->pnodeDelegation );
    Printf( " wTypeCurrent = 0x%x\n", pMsg->wTypeCurrent );
    Printf( " wOffsetCurrent = 0x%x\n", pMsg->wOffsetCurrent );
    Printf( " pNodeQuestion = 0x%p\n", pMsg->pNodeQuestion );
    Printf( " pNodeNodeQuestionClosest = 0x%p\n", pMsg->pNodeQuestionClosest );
    Printf( " pQuestion = 0x%p\n", pMsg->pQuestion );
    Printf( " wQuestionType = 0x%x\n", pMsg->wQuestionType );
    Printf( " wQueuingXid = 0x%x\n", pMsg->wQueuingXid );
    Printf( " dwQueryTime = 0x%x\n", pMsg->dwQueryTime );
    Printf( " dwQueuingTime = 0x%x\n", pMsg->dwQueuingTime );
    Printf( " dwExpireTime = 0x%x\n", pMsg->dwExpireTime );
    Printf( " pRecurseMsg = 0x%p\n", pMsg->pRecurseMsg );
    Printf( " pnodeRecurseRetry = 0x%p\n", pMsg->pnodeRecurseRetry );
    Printf( " pNsList = 0x%p\n", pMsg->pNsList );
    Printf( " pConnection = 0x%p\n", pMsg->pConnection );
    Printf( " pchRecv = 0x%p\n", pMsg->pchRecv );
    Printf( " UnionMarker = 0x%x\n", pMsg->UnionMarker );

    //
    //   Union -- should get a union tag
    //

    {
        //
        // For now, print both Nbstat & Xfr images
        //

        Printf( " Union:\n" );

        //
        //  WINS info
        //

        {
            Printf( " (U.Wins):\n" );
            Printf( " pWinsRR = 0x%x\n",        pMsg->U.Wins.pWinsRR );
            Printf( " WinsNameBuffer = 0x%x\n", RELATIVE_ADDRESS(lpVoid, pMsg, pMsg->U.Wins.pWinsRR) );
            Printf( " cchWinsName = %d\n",      pMsg->U.Wins.cchWinsName );
        }

        //
        //  Nbstat info
        //

        {
            Printf( " (U.Nbstat):\n" );
            Printf( " pRR = 0x%p\n",                pMsg->U.Nbstat.pRR );
            Printf( " pNbstat = 0x%p\n",            pMsg->U.Nbstat.pNbstat );
            Printf( " ipNbstat = 0x%x\n",           pMsg->U.Nbstat.ipNbstat );
            Printf( " dwNbtInterfaceMask = 0x%x\n", pMsg->U.Nbstat.dwNbtInterfaceMask );
            Printf( " fNbstatResponded = %s\n",     pMsg->U.Nbstat.fNbstatResponded? "TRUE" : "FALSE" );
        }

        //
        //  Xfr
        //

        {
            Printf( " (U.Xfr):\n" );
            Printf( " dwMessageNumber = 0x%x\n",    pMsg->U.Xfr.dwMessageNumber );
            Printf( " dwSecondaryVersion = 0x%x\n", pMsg->U.Xfr.dwSecondaryVersion );
            Printf( " dwMasterVersion = 0x%x\n",    pMsg->U.Xfr.dwMasterVersion );
            Printf( " dwLastSoaVersion = 0x%x\n",   pMsg->U.Xfr.dwLastSoaVersion );
            Printf( " fReceivedStartSoa = %s\n",    pMsg->U.Xfr.fReceivedStartSoa?"TRUE":"FALSE" );
            Printf( " fBindTransfer = %s\n",        pMsg->U.Xfr.fBindTransfer?"TRUE":"FALSE" );
            Printf( " fMsTransfer = %s\n",          pMsg->U.Xfr.fMsTransfer?"TRUE":"FALSE" );
            Printf( " fLastPassAdd = %s\n",         pMsg->U.Xfr.fLastPassAdd?"TRUE":"FALSE" );
        }

        //
        //  Forward
        //

        {
            Printf( " (U.Forward):\n" );
            Printf( " OriginalSocket = 0x%x\n",    pMsg->U.Forward.OriginalSocket );
            Printf( " ipOriginal = 0x%x\n",        pMsg->U.Forward.ipOriginal );
            Printf( " wOriginalPort = 0x%x\n",     pMsg->U.Forward.wOriginalPort );
            Printf( " wOriginalXid = 0x%x\n",      pMsg->U.Forward.wOriginalXid );
        }
    }

    Printf( " pLooknameQuestion = 0x%p\n",pMsg->pLooknameQuestion );
    Printf( " FlagMarker = 0x%x\n", pMsg->FlagMarker );
    Printf( " fDelete = 0x%x\n", pMsg->fDelete );
    Printf( " fTcp = 0x%x\n", pMsg->fTcp );
    Printf( " fMessageComplete = 0x%x\n", pMsg->fMessageComplete );
    Printf( " Section = %d\n", pMsg->Section );
    Printf( " fDoAdditional = 0x%x\n", pMsg->fDoAdditional );
    Printf( " fRecurseIfNecessary = 0x%x\n", pMsg->fRecurseIfNecessary );
    Printf( " fRecursePacket = 0x%x\n", pMsg->fRecursePacket );
    Printf( " fQuestionRecursed = 0x%x\n", pMsg->fQuestionRecursed );
    Printf( " fQuestionCompleted = 0x%x\n", pMsg->fQuestionCompleted );
    Printf( " fRecurseQuestionSent = 0x%x\n", pMsg->fRecurseQuestionSent );
    Printf( " fRecurseTimeoutWait = 0x%x\n", pMsg->fRecurseTimeoutWait );
    Printf( " nForwarder = 0x%x\n", pMsg->nForwarder );
    Printf( " fReplaceCname = 0x%x\n", pMsg->fReplaceCname );
    Printf( " cCnameAnswerCount = %d\n", pMsg->cCnameAnswerCount );
    Printf( " fNoCompressionWrite = 0x%x\n", pMsg->fNoCompressionWrite );
    Printf( " fWins = 0x%x\n", pMsg->fWins );
    Printf( " fQuestionWildcard = 0x%x\n", pMsg->fQuestionWildcard );

    Printf( " Additional --\n" );
    Dump_ADDITIONAL_INFO( (LPVOID)&pMsg->Additional );

    Printf( " Compression --\n" );
    Dump_COMPRESSION_INFO( (LPVOID)&pMsg->Compression );
#if DBG
    Printf( " DbgListEntry = {Flink=0x%p; Blink=0x%p}\n", pMsg->DbgListEntry.Flink, pMsg->DbgListEntry.Blink );
#endif
    Printf( " dwForceAlignment = 0x%x\n", pMsg->dwForceAlignment );
    Printf( " BytesToReceive = 0x%x\n", pMsg->BytesToReceive );
    Printf( " MessageLength = 0x%x\n", pMsg->MessageLength );

    Printf( " Head --\n" );
    Dump_DNS_HEADER((LPVOID)&pMsg->Head );

    Printf( " MessageBody -- " );
    DumpBuffer((LPVOID)RELATIVE_ADDRESS(lpVoid, pMsg, pMsg->MessageBody), pMsg->MessageLength );

    PopMemory( (PVOID)pMsg );

    return TRUE;
}



/*+++
Function   : DumpSockAddr
Description: dumps sockaddr structure
Parameters :
Return     :
Remarks    : none.
---*/
DECLARE_DUMPFUNCTION( Dump_SockAddr)
{
    Printf( "SockAddr(0x%p):\n", lpVoid );

    if( !lpVoid )
    {
        Printf( "Cannot process [%p] pointer\n", lpVoid );
        return FALSE;
    }

    //
    //  print sockaddr structure
    //

    PSOCKADDR_IN paddr = (PSOCKADDR_IN) PushMemory( lpVoid, sizeof(SOCKADDR_IN) );;

    Printf(
        " family = %d, port = %d, address = [%d:%d:%d:%d]\n",
        paddr->sin_family, paddr->sin_port,
        paddr->sin_addr.S_un.S_un_b.s_b1,
        paddr->sin_addr.S_un.S_un_b.s_b2,
        paddr->sin_addr.S_un.S_un_b.s_b3,
        paddr->sin_addr.S_un.S_un_b.s_b4 );

    PopMemory( (PVOID)paddr );

    return TRUE;
}


/*+++
Function   : Dump_DB_NODE
Description:
Parameters :
Return     :
Remarks    : none.
---*/
DECLARE_DUMPFUNCTION( Dump_DB_NODE)
{
    Printf( "DB_NODE(0x%p):\n", lpVoid );

    if ( !lpVoid )
    {
        Printf( "Cannot process [%p] pointer\n", lpVoid );
        return FALSE;
    }

    //
    //  print node structure
    //

    PDB_NODE pnode = (PDB_NODE) PushMemory( lpVoid, sizeof(DB_NODE) );;

    Printf( " pParent = 0x%p\n", pnode->pParent );
    Printf( " pSibUp = 0x%p\n", pnode->pSibUp );
    Printf( " pSibLeft = 0x%p\n", pnode->pSibLeft );
    Printf( " pSibRight = 0x%p\n", pnode->pSibRight );
    Printf( " cChildren = %lu\n", pnode->cChildren );
    Printf( " pChildren = 0x%p\n", pnode->pChildren );
    Printf( " pZone = 0x%p\n", pnode->pZone );
    Printf( " pRRList = 0x%p\n", pnode->pRRList );
    Printf( " dwCompare = 0x%x\n", pnode->dwCompare );
    Printf( " cReferenceCount = %lu\n", pnode->cReferenceCount );
    Printf( " dwNodeFlags = 0x%x\n", pnode->dwNodeFlags );
    Printf( " uchAuthority = 0x%x\n", pnode->uchAuthority );
    Printf( " uchAccessbin = %d\n", (INT)pnode->uchAccessBin );
    Printf( " cchLabelLength = %d\n", (INT)pnode->cchLabelLength );
    Printf( " szLabel -- \n" );

    //  JBUGBUG:  this looks dubious if node bad\broken

    DumpBuffer(
        (LPVOID)RELATIVE_ADDRESS( lpVoid, pnode, pnode->szLabel ),
        ((INT)pnode->cchLabelLength < DNS_MAX_LABEL_LENGTH)
            ? (INT)pnode->cchLabelLength
            : DNS_MAX_LABEL_LENGTH );

    PopMemory( (PVOID)pnode );

    return TRUE;
}

/*+++
Function   : Dump_COUNT_NAME
Description:
Parameters :
Return     :
Remarks    : none.
---*/
DECLARE_DUMPFUNCTION( Dump_COUNT_NAME)
{
    Printf( "COUNT_NAME(0x%p):\n", lpVoid );

    if ( !lpVoid )
    {
        Printf( "Cannot process [%p] pointer\n", lpVoid );
        return FALSE;
    }

    //
    //  print count name
    //

    PCOUNT_NAME pname = (PCOUNT_NAME) PushMemory( lpVoid, sizeof(COUNT_NAME) );

    Printf( " Length = %d\n", pname->Length );
    Printf( " LabelCount = %d\n", pname->LabelCount );
    Printf( " RawName -- \n" );

    DumpBuffer(
        (LPVOID)RELATIVE_ADDRESS(lpVoid, pname, pname->RawName),
        pname->Length > DNS_MAX_NAME_LENGTH
            ? DNS_MAX_NAME_LENGTH
            : pname->Length );

    PopMemory( (PVOID)pname );

    return TRUE;
}



/*+++
Function   : Dump_ZONE_INFO
Description:
Parameters :
Return     :
Remarks    : none.
---*/

DECLARE_DUMPFUNCTION( Dump_ZONE_INFO )
{
    Printf( "ZONE_INFO(0x%p):\n", lpVoid );

    if ( !lpVoid )
    {
        Printf( "Cannot process [%p] pointer\n", lpVoid );
        return FALSE;
    }

    //
    // print structure
    //

    PZONE_INFO pzone = (PZONE_INFO) PushMemory( lpVoid, sizeof(ZONE_INFO) );

    Printf( " ListEntry           = [Flink=%p, Blink=%p]\n",
                                                pzone->ListEntry.Flink,
                                                pzone->ListEntry.Blink );
    Printf( " pszZoneName         = %p\n",      pzone->pszZoneName );
    Printf( " pwsZoneName         = %p\n",      pzone->pwsZoneName );
    Printf( " pCountName          = %p\n",      pzone->pCountName );
    Printf( " pZoneRoot           = %p\n",      pzone->pZoneRoot );
    Printf( " pTreeRoot           = %p\n",      pzone->pTreeRoot );
    Printf( " pZoneTreeLink       = %p\n",      pzone->pZoneTreeLink );
    Printf( " pLoadZoneRoot       = %p\n",      pzone->pLoadZoneRoot );
    Printf( " pLoadTreeRoot       = %p\n",      pzone->pLoadTreeRoot );
    Printf( " pLoadOrigin         = %p\n",      pzone->pLoadOrigin );
    Printf( " pOldTree            = %p\n",      pzone->pOldTree );
    Printf( " ---\n" );
    Printf( " pszDataFile         = %p\n",      pzone->pszDataFile );
    Printf( " pwzDataFile         = %p\n",      pzone->pwsDataFile );
    Printf( " pDelayedUpdateList  = %p\n",      pzone->pDelayedUpdateList );
    Printf( " pSoaRR              = %p\n",      pzone->pSoaRR );
    Printf( " pWinsRR             = %p\n",      pzone->pWinsRR );
    Printf( " pLocalWInsRR        = %p\n",      pzone->pLocalWinsRR );
    Printf( " pSD                 = %p\n",      pzone->pSD );
    Printf( " ---\n" );
    Printf( " fZoneType           = %d\n",      pzone->fZoneType );
    Printf( " fDsIntegrated       = %s\n",      pzone->fDsIntegrated ? "TRUE" : "FALSE" );
    Printf( " fAllowUpdate        = %d\n",      pzone->fAllowUpdate );
    Printf( " iRRCount            = %d\n",      pzone->iRRCount );
    Printf( " ---\n" );
#if 0
    Printf( " ipReverse           = 0x%x\n",    pzone->ipReverse );
    Printf( " ipReverseMask       = 0x%x\n",    pzone->ipReverseMask );
#endif
    Printf( " dwSerialNo          = %lu\n",     pzone->dwSerialNo );
    Printf( " dwLoadSerialNo      = %lu\n",     pzone->dwLoadSerialNo );
    Printf( " dwLastXfrSerialNo   = %lu\n",     pzone->dwLastXfrSerialNo );
    Printf( " dwNewSerialNo       = %lu\n",     pzone->dwNewSerialNo );
    Printf( " dwDefaultTtl        = 0x%x\n",    pzone->dwDefaultTtl );
    Printf( " dwDefTtlHostOrder   = %lu\n",     pzone->dwDefaultTtlHostOrder );
    Printf( " ---\n" );

    Printf( " Master Info:\n" );
    Printf( " aipSecondaries      = %p\n",      pzone->aipSecondaries );
    Printf( " aipNotify           = %p\n",      pzone->aipNotify );
    Printf( " aipNameServers      = %p\n",      pzone->aipNameServers );
    Printf( " ---\n" );

    Printf( " Primary Info:\n" );
    Printf( " pwzLogFile          = %p\n",      pzone->pwsLogFile );
    Printf( " hfileUpdateLog      = 0x%x\n",    pzone->hfileUpdateLog );
    Printf( " iUpdateLogCount     = %d\n",      pzone->iUpdateLogCount );
    Printf( " bAging              = %s\n",      pzone->bAging ? "TRUE" : "FALSE" );
    Printf( " dwNoRefreshInterval = %lu\n",     pzone->dwNoRefreshInterval );
    Printf( " dwRefreshInterval   = %lu\n",     pzone->dwRefreshInterval );
    Printf( " dwRefreshTime       = %lu\n",     pzone->dwRefreshTime );
    Printf( " dwAgingEnabledTime  = %lu\n",     pzone->dwAgingEnabledTime );
    Printf( " aipScavengeServers  = %p\n",      pzone->aipScavengeServers );

    Printf( " DS Primary Info:\n" );
    Printf( " pwsZoneDN           = %p\n",      pzone->pwszZoneDN );
    //  FIXME
    Printf( " llSecureUpdateTime  = %p\n",      pzone->llSecureUpdateTime );
    Printf( " fDsRelaod           = %s\n",      pzone->fDsReload ? "TRUE" : "FALSE"  );
    Printf( " fInDsWrite          = %s\n",      pzone->fInDsWrite ? "TRUE" : "FALSE"  );
    Printf( " ucDsRecordVersion   = %d\n",      pzone->ucDsRecordVersion );
    Printf( " fLogUpdates         = %d\n",      pzone->fLogUpdates ? "TRUE" : "FALSE"  );
    Printf( " szLastUsn           = %p\n",      RELATIVE_ADDRESS(lpVoid, pzone, pzone->szLastUsn) );
    Printf( " ---\n" );

    Printf( " Secondary Info:\n" );
    Printf( " aipMasters          = %p\n",      pzone->aipMasters );
    //  Printf( " MasterInfoArray     = %p\n",      pzone->MasterInfoArray );
    Printf( " pszMasterIpString   = %p\n",      pzone->pszMasterIpString );
    Printf( " ipPrimary           = 0x%x\n",    pzone->ipPrimary );
    Printf( " ipNotifier          = 0x%x\n",    pzone->ipNotifier );
    Printf( " ipFreshMaster       = 0x%x\n",    pzone->ipFreshMaster );
    Printf( " ipXfrBind           = 0x%x\n",    pzone->ipXfrBind );
    Printf( " ipLastAxfrMaster    = 0x%x\n",    pzone->ipLastAxfrMaster );
    Printf( " dwLastSoaCheckTime  = %d\n",      pzone->dwLastSoaCheckTime );
    Printf( " dwNextSoaCheckTime  = %d\n",      pzone->dwNextSoaCheckTime );
    Printf( " dwExpireTime        = %d\n",      pzone->dwExpireTime );
    Printf( " dwZoneRecvStartTime = %d\n",      pzone->dwZoneRecvStartTime );
    Printf( " dwBadMasterCount    = %d\n",      pzone->dwBadMasterCount );
    Printf( " dwNextTranserTime   = %d\n",      pzone->dwNextTransferTime  );
    Printf( " fStale              = %s\n",      pzone->fStale ? "TRUE" : "FALSE"  );
    Printf( " fNotified           = %s\n",      pzone->fNotified ? "TRUE" : "FALSE"  );
    Printf( " fNeedAxfr           = %s\n",      pzone->fNeedAxfr ? "TRUE" : "FALSE"  );
    Printf( " fSkipIxfr           = %s\n",      pzone->fSkipIxfr ? "TRUE" : "FALSE"  );
    Printf( " fSlowRetry          = %s\n",      pzone->fSlowRetry ? "TRUE" : "FALSE"  );
    Printf( " cIxfrAttempts       = %d\n",      (INT)pzone->cIxfrAttempts );
    Printf( " fEmpty              = %s\n",      pzone->fEmpty ? "TRUE" : "FALSE"  );
    Printf( " ---\n" );

    Printf( " Locking:\n" );
    Printf( " dwLockingThreadId   = 0x%x\n",    pzone->dwLockingThreadId );
    Printf( " fLocked             = %d\n",      (INT)pzone->fLocked );
    Printf( " fUpdateLock         = %d\n",      pzone->fUpdateLock );
    Printf( " fXfrRecvLock        = %d\n",      pzone->fXfrRecvLock );
    Printf( " fFileWriteLock      = %d\n",      pzone->fFileWriteLock );
    Printf( " ---\n" );

    Printf( " Flags:\n" );
    Printf( " cZoneNameLabelCount = %d\n",  (INT)pzone->cZoneNameLabelCount );
    Printf( " fReverse            = %s\n",  pzone->fReverse ? "TRUE" : "FALSE"  );
    Printf( " fAutoCreated        = %s\n",  pzone->fAutoCreated ? "TRUE" : "FALSE"  );
    Printf( " fSecureSecondaries  = %d\n",  pzone->fSecureSecondaries  );
    Printf( " fNotifyLevel        = %d\n",  pzone->fNotifyLevel  );
    Printf( " fPaused             = %s\n",  pzone->fPaused ? "TRUE" : "FALSE"  );
    Printf( " fShutdown           = %s\n",  pzone->fShutdown ? "TRUE" : "FALSE"  );
    Printf( " fDirty              = %s\n",  pzone->fDirty ? "TRUE" : "FALSE"  );
    Printf( " fRootDirty          = %s\n",  pzone->fRootDirty ? "TRUE" : "FALSE"  );
    Printf( " fLocalWins          = %s\n",  pzone->fLocalWins ? "TRUE" : "FALSE"  );
    Printf( " ---\n" );

    Printf( " UpdateList          = %p\n", pzone->UpdateList );

    PopMemory( (PVOID)pzone );

    return TRUE;
}


/*+++
Function   : Dump_DB_RECORD
Description:
Parameters :
Return     :
Remarks    : none.
---*/
DECLARE_DUMPFUNCTION( Dump_DB_RECORD)
{
    Printf( "DB_RECORD(0x%p):\n", lpVoid );

    if ( !lpVoid )
    {
        Printf( "Cannot process [%p] pointer\n", lpVoid );
        return FALSE;
    }

    //
    //  print record
    //

    PDB_RECORD prr = (PDB_RECORD) PushMemory( lpVoid, sizeof(DB_RECORD) );

    Printf( " pRRNext       = 0x%p\n",  prr->pRRNext );
    Printf( " RecordRank    = %d\n",    prr->RecordRank );
    Printf( " Reserved      = 0x%x\n",  (BYTE)( prr->Reserved.Source|
                                                prr->Reserved.Reserved|
                                                prr->Reserved.StandardAlloc) );
    Printf( " wRRFlags      = 0x%x\n",  prr->wRRFlags );
    Printf( " wType         = 0x%x\n",  prr->wType );
    Printf( " wDataLength   = 0x%x\n",  prr->wDataLength );
    Printf( " dwTtlSeconds  = 0x%x\n",  prr->dwTtlSeconds );
    Printf( " dwTimeStamp   = %lu\n",   prr->dwTimeStamp );

    Printf( " Data ---" );
    switch (prr->wType) {

    case DNS_TYPE_A:
        Printf( " (DNS_TYPE_A):\n" );
        Printf( " IpAddr = 0x%x\n", (DWORD)prr->Data.A.ipAddress );
        break;

    case DNS_TYPE_AAAA:
        Printf( " (DNS_TYPE_AAAA):\n" );
        Printf( " IP6Addr = [%x:%x:%x:%x;%x;%x;%x;%x]\n",
            prr->Data.AAAA.Ip6Addr.IP6Word[0],
            prr->Data.AAAA.Ip6Addr.IP6Word[1],
            prr->Data.AAAA.Ip6Addr.IP6Word[2],
            prr->Data.AAAA.Ip6Addr.IP6Word[3],
            prr->Data.AAAA.Ip6Addr.IP6Word[4],
            prr->Data.AAAA.Ip6Addr.IP6Word[5],
            prr->Data.AAAA.Ip6Addr.IP6Word[6],
            prr->Data.AAAA.Ip6Addr.IP6Word[7] );
       break;

    case DNS_TYPE_SOA:
        Printf( " (DNS_TYPE_SOA):\n" );
        Dump_Record_SOA( (LPVOID)&(prr->Data.SOA) );
        break;

    case DNS_TYPE_PTR:
        Printf( " (DNS_TYPE_PTR):\n" );
        Printf( " nameTarget = 0x%p\n", (LPVOID)RELATIVE_ADDRESS(lpVoid, prr, &prr->Data.PTR.nameTarget) );
        break;

    case DNS_TYPE_NS:
        Printf( " (DNS_TYPE_NS):\n" );
        Printf( " nameTarget = 0x%p\n", (LPVOID)RELATIVE_ADDRESS(lpVoid, prr, &prr->Data.NS.nameTarget) );
        break;

    case DNS_TYPE_CNAME:
        Printf( " (DNS_TYPE_CNAME):\n" );
        Printf( " nameTarget = 0x%p\n", (LPVOID)RELATIVE_ADDRESS(lpVoid, prr, &prr->Data.CNAME.nameTarget) );
        break;

    case DNS_TYPE_MB:
        Printf( " (DNS_TYPE_MB):\n" );
        Printf( " nameTarget = 0x%p\n", (LPVOID)RELATIVE_ADDRESS(lpVoid, prr, &prr->Data.MB.nameTarget) );
        break;
    case DNS_TYPE_MD:
        Printf( " (DNS_TYPE_MD):\n" );
        Printf( " nameTarget = 0x%p\n", (LPVOID)RELATIVE_ADDRESS(lpVoid, prr, &prr->Data.MD.nameTarget) );
        break;
    case DNS_TYPE_MF:
        Printf( " (DNS_TYPE_MF):\n" );
        Printf( " nameTarget = 0x%p\n", (LPVOID)RELATIVE_ADDRESS(lpVoid, prr, &prr->Data.MF.nameTarget) );
        break;
    case DNS_TYPE_MG:
        Printf( " (DNS_TYPE_MG):\n" );
        Printf( " nameTarget = 0x%p\n", (LPVOID)RELATIVE_ADDRESS(lpVoid, prr, &prr->Data.MG.nameTarget) );
        break;
    case DNS_TYPE_MR:
        Printf( " (DNS_TYPE_MR):\n" );
        Printf( " nameTarget = 0x%p\n", (LPVOID)RELATIVE_ADDRESS(lpVoid, prr, &prr->Data.MR.nameTarget) );
        break;

    case DNS_TYPE_MINFO:
        Printf( " (DNS_TYPE_MINFO):\n" );
        Printf( " nameMailbox = 0x%p\n", (LPVOID)RELATIVE_ADDRESS(lpVoid, prr, &prr->Data.MINFO.nameMailbox) );
        break;
    case DNS_TYPE_RP:
        Printf( " (DNS_TYPE_RP):\n" );
        Printf( " nameMailbox = 0x%p\n", (LPVOID)RELATIVE_ADDRESS(lpVoid, prr, &prr->Data.RP.nameMailbox) );
        break;

    case DNS_TYPE_MX:
        Printf( " (DNS_TYPE_MX):\n" );
        Printf( " wPreference = 0x%x\n", prr->Data.MX.wPreference );
        Printf( " nameExchange = 0x%p\n", (LPVOID)RELATIVE_ADDRESS(lpVoid, prr, &prr->Data.MX.nameExchange) );
        break;
    case DNS_TYPE_AFSDB:
        Printf( " (DNS_TYPE_AFSDB):\n" );
        Printf( " wPreference = 0x%x\n", prr->Data.AFSDB.wPreference );
        Printf( " nameExchange = 0x%p\n", (LPVOID)RELATIVE_ADDRESS(lpVoid, prr, &prr->Data.AFSDB.nameExchange) );
        break;
    case DNS_TYPE_RT:
        Printf( " (DNS_TYPE_RT):\n" );
        Printf( " wPreference = 0x%x\n", prr->Data.RT.wPreference );
        Printf( " nameExchange = 0x%p\n", (LPVOID)RELATIVE_ADDRESS(lpVoid, prr, &prr->Data.RT.nameExchange) );
        break;

    case DNS_TYPE_HINFO:
        Printf( " (DNS_TYPE_HINFO):\n" );
        Printf( " chData = 0x%p\n", (LPVOID)RELATIVE_ADDRESS(lpVoid, prr, prr->Data.HINFO.chData) );
        break;
    case DNS_TYPE_ISDN:
        Printf( " (DNS_TYPE_ISDN):\n" );
        Printf( " chData = 0x%p\n", (LPVOID)RELATIVE_ADDRESS(lpVoid, prr, prr->Data.ISDN.chData) );
        break;
    case DNS_TYPE_TEXT:
        Printf( " (DNS_TYPE_TEXT):\n" );
        Printf( " chData = 0x%p\n", (LPVOID)RELATIVE_ADDRESS(lpVoid, prr, prr->Data.TXT.chData) );
        break;
    case DNS_TYPE_NULL:
        Printf( " (DNS_TYPE_NULL):\n" );
        Printf( " chData = 0x%p\n", (LPVOID)RELATIVE_ADDRESS(lpVoid, prr, prr->Data.Null.chData) );
        break;

    case DNS_TYPE_WKS:
        Printf( " (DNS_TYPE_WKS):\n" );
        Printf( " ipAddress = 0x%x\n", prr->Data.WKS.ipAddress );
        Printf( " chProtocol = 0x%x\n", prr->Data.WKS.chProtocol );
        Printf( " bBitMask = @ 0x%p\n", RELATIVE_ADDRESS(lpVoid, prr, prr->Data.WKS.bBitMask) );
        break;

    case DNS_TYPE_SIG:
        Printf( " (DNS_TYPE_SIG):\n" );
        Printf( " nameSigner = 0x%p\n", (LPVOID)RELATIVE_ADDRESS(lpVoid, prr, &prr->Data.SIG.nameSigner) );
        Printf( " wTypeCovered = 0x%x\n", prr->Data.SIG.wTypeCovered );
        Printf( " chAlgorithm = 0x%x\n", prr->Data.SIG.chAlgorithm );
        Printf( " chLabelCount = 0x%x\n", prr->Data.SIG.chLabelCount );
        Printf( " dwOriginalTtl = 0x%x\n", prr->Data.SIG.dwOriginalTtl );
        Printf( " dwSigExpiration = 0x%x\n", prr->Data.SIG.dwSigExpiration );
        Printf( " dwSigInception = 0x%x\n", prr->Data.SIG.dwSigInception );
        Printf( " wKeyTag = 0x%x\n", prr->Data.SIG.wKeyTag );
        Printf( " Signature = 0x%p\n", RELATIVE_ADDRESS(lpVoid, prr,
            ( PBYTE ) &prr->Data.SIG.nameSigner +
            DBASE_NAME_SIZE( &prr->Data.SIG.nameSigner ) ) );
        break;

    case DNS_TYPE_KEY:
        Printf( " (DNS_TYPE_KEY):\n" );
        Printf( " wFlags = 0x%x\n", prr->Data.KEY.wFlags );
        Printf( " chProtocol = 0x%x\n", prr->Data.KEY.chProtocol );
        Printf( " chAlgorithm = 0x%x\n", prr->Data.KEY.chAlgorithm );
        Printf( " Key = 0x%p\n", RELATIVE_ADDRESS(lpVoid, prr, prr->Data.KEY.Key) );
        break;

    case DNS_TYPE_LOC:
        Printf( " (DNS_TYPE_LOC):\n" );
        Printf( " wVersion = 0x%x\n", prr->Data.LOC.wVersion );
        Printf( " wSize = 0x%x\n", prr->Data.LOC.wSize );
        Printf( " wHorPrec = 0x%x\n", prr->Data.LOC.wHorPrec );
        Printf( " wVerPrec = 0x%x\n", prr->Data.LOC.wVerPrec );
        Printf( " dwLatitude = 0x%x\n", prr->Data.LOC.dwLatitude );
        Printf( " dwLongitude = 0x%x\n", prr->Data.LOC.dwLongitude );
        Printf( " dwAltitude = 0x%x\n", prr->Data.LOC.dwAltitude );
        break;

    case DNS_TYPE_NXT:
        Printf( " (DNS_TYPE_NXT):\n" );
        Printf( " nameNext = 0x%p\n", (LPVOID)RELATIVE_ADDRESS(lpVoid, prr, &prr->Data.NXT.nameNext) );
        Printf( " bTypeBitMap = @ 0x%p\n", RELATIVE_ADDRESS(lpVoid, prr, prr->Data.NXT.bTypeBitMap) );
        break;

    case DNS_TYPE_SRV:
        Printf( " (DNS_TYPE_SRV):\n" );
        Printf( " wPriority = 0x%x\n", prr->Data.SRV.wPriority );
        Printf( " wWeight = 0x%x\n", prr->Data.SRV.wWeight );
        Printf( " wPort = 0x%x\n", prr->Data.SRV.wPort );
        Printf( " nameTarget = 0x%p\n", (LPVOID)RELATIVE_ADDRESS(lpVoid, prr, &prr->Data.SRV.nameTarget) );
        break;

    case DNS_TYPE_TSIG:
        Printf( " (DNS_TYPE_TSIG):\n" );
        Printf( " dwTimeSigned = 0x%x\n", prr->Data.TSIG.dwTimeSigned );
        Printf( " dwTimeExpire = 0x%x\n", prr->Data.TSIG.dwTimeExpire );
        Printf( " wSigLength = 0x%x\n", prr->Data.TSIG.wSigLength );
        Printf( " bSignature = @ 0x%x\n", RELATIVE_ADDRESS(lpVoid, prr, prr->Data.TSIG.bSignature) );
        Printf( " nameAlgorithm = @ 0x%p\n", RELATIVE_ADDRESS(lpVoid, prr, &prr->Data.TSIG.nameAlgorithm) );
        break;

    case DNS_TYPE_TKEY:
        Printf( " (DNS_TYPE_TKEY):\n" );
        Printf( " wKeyLength = 0x%x\n", prr->Data.TKEY.wKeyLength );
        Printf( " bKey = @ 0x%p\n", RELATIVE_ADDRESS(lpVoid, prr, prr->Data.TKEY.bKey) );
        break;

    case DNS_TYPE_WINS:
        Printf( " (DNS_TYPE_WINS):\n" );
        Printf( " dwMappingFlag = 0x%x\n", prr->Data.WINS.dwMappingFlag );
        Printf( " dwLookupTimeout = 0x%x\n", prr->Data.WINS.dwLookupTimeout );
        Printf( " dwCacheTimeout = 0x%x\n", prr->Data.WINS.dwCacheTimeout );
        Printf( " cWinsServerCount = 0x%x\n", prr->Data.WINS.cWinsServerCount );
        Printf( " aipWinsServers = 0x%x\n", prr->Data.WINS.aipWinsServers );
        break;

    case DNS_TYPE_WINSR:
        Printf( " (DNS_TYPE_WINSR):\n" );
        Printf( " dwMappingFlag = 0x%x\n", prr->Data.WINSR.dwMappingFlag );
        Printf( " dwLookupTimeout = 0x%x\n", prr->Data.WINSR.dwLookupTimeout );
        Printf( " dwCacheTimeout = 0x%x\n", prr->Data.WINSR.dwCacheTimeout );
        Printf( " nameResultDomain = 0x%p\n", (LPVOID)RELATIVE_ADDRESS(lpVoid, prr, &prr->Data.WINSR.nameResultDomain) );
        break;

    default:
        Printf( "\n  Error: Unknown wType value (0x%x).\n", prr->wType );
    }

    PopMemory( (PVOID)prr );

    return TRUE;
}



/*+++
Function   : Dump_IP_ARRAY
Description:
Parameters :
Return     :
Remarks    : none.
---*/
DECLARE_DUMPFUNCTION( Dump_IP_ARRAY)
{
    Printf( "IP_ARRAY(0x%p):\n", lpVoid );

    if ( !lpVoid )
    {
        Printf( "Cannot process [%p] pointer\n", lpVoid );
        return FALSE;
    }

   //
   // print structure
   //
   PIP_ARRAY pIp = (PIP_ARRAY) PushMemory( lpVoid, sizeof(IP_ARRAY) );
   INT iMax= pIp->AddrCount > MAX_TINY_LIST ? MAX_TINY_LIST : (INT)pIp->AddrCount;

    Printf( " AddrCount = 0x%x\n", pIp->AddrCount );

   PIP_ADDRESS addr = (PIP_ADDRESS) PushMemory( (LPVOID)RELATIVE_ADDRESS(lpVoid, pIp, pIp->AddrArray), sizeof(IP_ADDRESS)*iMax );
   for(INT i=0; i< iMax; i++){
       Printf( " AddrArray[%2d] = 0x%x\n", addr[i] );
   }
   PopMemory( (PVOID)addr );

   if(pIp->AddrCount > MAX_TINY_LIST){
       Printf( " (truncated)...\n" );
   }

   PopMemory( (PVOID)pIp );

   return TRUE;
}


/*+++
Function   : Dump_UPDATE
Description:
Parameters :
Return     :
Remarks    : none.
---*/
DECLARE_DUMPFUNCTION( Dump_UPDATE)
{
    Printf( "UPDATE(0x%p):\n", lpVoid );

    if ( !lpVoid )
    {
        Printf( "Cannot process [%p] pointer\n", lpVoid );
        return FALSE;
    }
   //
   // print structure
   //
   PUPDATE p = (PUPDATE) PushMemory( lpVoid, sizeof(UPDATE) );

    Printf( " pNext = 0x%x\n", p->pNext );
    Printf( " pNode = 0x%p\n", p->pNode );
    Printf( " pAddRR = 0x%p\n", p->pAddRR );
    Printf( " pDeleteRR =0x%p\n", p->pDeleteRR );
    Printf( " dwVersion = 0x%x\n", p->dwVersion );
    Printf( " wDeleteType = 0x%x\n", p->wDeleteType );
    Printf( " wAddType = 0x%x\n", p->wAddType );

   PopMemory( (PVOID)p );

   return TRUE;
}


/*+++
Function   : Dump_UPDATE_LIST
Description:
Parameters :
Return     :
Remarks    : none.
---*/
DECLARE_DUMPFUNCTION( Dump_UPDATE_LIST)
{
    Printf( "UPDATE_LIST(0x%p):\n", lpVoid );

    if ( !lpVoid )
    {
        Printf( "Cannot process [%p] pointer\n", lpVoid );
        return FALSE;
    }
   PUPDATE_LIST p = (PUPDATE_LIST) PushMemory( lpVoid, sizeof(UPDATE_LIST) );

    Printf( " pListHead = 0x%p\n", p->pListHead );
    Printf( " pCurrent = 0x%p\n", p->pCurrent );
    Printf( " pTempNodeList = 0x%p\n", p->pTempNodeList );
    Printf( " pNodeFailed = 0x%p\n", p->pNodeFailed );
    Printf( " pMsg = 0x%x\n", p->pMsg );
    Printf( " Flag = 0x%x\n", p->Flag );
    Printf( " dwCount = 0x%x\n", p->dwCount );
    Printf( " dwStartVersion = 0x%x\n", p->dwStartVersion );
    Printf( " dwHighDsVersion = 0x%x\n", p->dwHighDsVersion );

   PopMemory( (PVOID)p );

   return TRUE;
}





/*+++
Function   : Dump_DNS_WIRE_QUESTION
Description:
Parameters :
Return     :
Remarks    : none.
---*/
DECLARE_DUMPFUNCTION( Dump_DNS_WIRE_QUESTION)
{
    Printf( "DNS_WIRE_QUESTION(0x%p):\n", lpVoid );

    if ( !lpVoid )
    {
        Printf( "Cannot process [%p] pointer\n", lpVoid );
        return FALSE;
    }
   PDNS_WIRE_QUESTION p = (PDNS_WIRE_QUESTION) PushMemory( lpVoid, sizeof(DNS_WIRE_QUESTION) );

    Printf( " QuestionType = 0x%x\n", p->QuestionType );
    Printf( " QuestionClass = 0x%x\n", p->QuestionClass );

   PopMemory( (PVOID)p );

   return TRUE;
}



/*+++
Function   : Dump_DNS_HEADER
Description: dumps sockaddr structure
Parameters :
Return     :
Remarks    : none.
---*/
DECLARE_DUMPFUNCTION( Dump_DNS_HEADER)
{
    Printf( "DNS_HEADER(0x%p):\n", lpVoid );

    if ( !lpVoid )
    {
        Printf( "Cannot process [%p] pointer\n", lpVoid );
        return FALSE;
    }

    PDNS_HEADER p = (PDNS_HEADER) PushMemory( lpVoid, sizeof(DNS_HEADER) );

    Printf( " Xid = 0x%x\n", p->Xid );
    Printf( " RecursionDesired = 0x%x\n", p->RecursionDesired );
    Printf( " Truncation = 0x%x\n", p->Truncation );
    Printf( " Authoritative = 0x%x\n", p->Authoritative );
    Printf( " Opcode = 0x%x\n", p->Opcode );
    Printf( " IsResponse = 0x%x\n", p->IsResponse );
    Printf( " ResponseCode = 0x%x\n", p->ResponseCode );
    Printf( " Reserved = 0x%x\n", p->Reserved );
    Printf( " RecursionAvailable = 0x%x\n", p->RecursionAvailable );
    Printf( " QuestionCount = 0x%x\n", p->QuestionCount );
    Printf( " AnswerCount = 0x%x\n", p->AnswerCount );
    Printf( " NameServerCount = 0x%x\n", p->NameServerCount );
    Printf( " AdditionalCount = 0x%x\n", p->AdditionalCount );


   PopMemory( (PVOID)p );

   return TRUE;
}



/*+++
Function   : HEAP_HEADER
Description: dumps out additional message info
Parameters :
Return     :
Remarks    : none.
---*/
DECLARE_DUMPFUNCTION( Dump_HEAP_HEADER)
{
   // from heapdbg.h

#define HEAP_HEADER_FILE_SIZE   (16)

   struct _HEAP_HEADER
   {
        //
        //  Note, if move or add fields, MUST update list entry offset below
        //

        ULONG       HeapCodeBegin;
        ULONG       AllocCount;
        ULONG       RequestSize;
        ULONG       AllocSize;

        //
        //  Put LIST_ENTRY in middle of header
        //      - keep begin code at front
        //      - less likely to be corrupted
        //

        LIST_ENTRY  ListEntry;

        DWORD       AllocTime;
        DWORD       LineNo;
        CHAR        FileName[ HEAP_HEADER_FILE_SIZE ];

        ULONG       TotalAlloc;
        ULONG       CurrentAlloc;
        ULONG       FreeCount;
        ULONG       CurrentAllocCount;
        ULONG       HeapCodeEnd;
    };

    Printf( "HEAP_HEADER(0x%p):\n", lpVoid );

    if ( !lpVoid )
    {
        Printf( "Cannot process [%p] pointer\n", lpVoid );
        return FALSE;
    }

    _HEAP_HEADER *p = (_HEAP_HEADER*) PushMemory( lpVoid, sizeof(_HEAP_HEADER) );

    Printf( " HeapCodeBegin = 0x%x\n", p->HeapCodeBegin );
    Printf( " AllocCount = 0x%x\n", p->AllocCount );
    Printf( " RequestSize = 0x%x\n", p->RequestSize );
    Printf( " AllocSize = 0x%x\n", p->AllocSize );

   //
   //  Put LIST_ENTRY in middle of header
   //      - keep begin code at front
   //      - less likely to be corrupted
   //

    Printf( " ListEntry = 0x%x\n", p->ListEntry );
    Printf( " AllocTime = 0x%x\n", p->AllocTime );
    Printf( " LineNo = %lu\n", p->LineNo );
    Printf( " FileName -- \n", p->FileName );
   DumpBuffer((LPVOID)RELATIVE_ADDRESS(lpVoid, p, p->FileName), HEAP_HEADER_FILE_SIZE  );
    Printf( " TotalAlloc = 0x%x\n", p->TotalAlloc );
    Printf( " CurrentAlloc = 0x%x\n", p->CurrentAlloc );
    Printf( " FreeCount = 0x%x\n", p->FreeCount );
    Printf( " CurrentAllocCount = 0x%x\n", p->CurrentAllocCount );
    Printf( " HeapCodeEnd = 0x%x\n", p->HeapCodeEnd );

   PopMemory( (PVOID)p );

   return TRUE;
}





/*+++
Function   : Dump_Record_SOA
Description:
Parameters :
Return     :
Remarks    : none.
---*/
DECLARE_DUMPFUNCTION( Dump_LOOKUP_NAME){
    Printf( "LOOKUP_NAME(0x%p):\n", lpVoid );

    if ( !lpVoid )
    {
        Printf( "Cannot process [%p] pointer\n", lpVoid );
        return FALSE;
    }

    PLOOKUP_NAME p = (PLOOKUP_NAME) PushMemory( lpVoid, sizeof(LOOKUP_NAME) );

    Printf( " cLabelCount = %d\n", p->cLabelCount );
    Printf( " cchNameLength = %d\n", p->cchNameLength );
    Printf( " pchLabelArray --\n" );

    // if cLableCountis bad, forget about it.

    INT iMax;
    iMax  = p->cLabelCount < DNS_MAX_NAME_LABELS ? p->cLabelCount : 0;
    INT i;

    for(i=0;i<iMax;i++)
    {
        Printf( " [%d] 0x%p\n", i, p->pchLabelArray[i] );
    }
    Printf( " cchLabelArray -- \n" );
    iMax  = p->cchNameLength < DNS_MAX_NAME_LABELS ? p->cchNameLength : DNS_MAX_NAME_LABELS;
    DumpBuffer((LPVOID)RELATIVE_ADDRESS(lpVoid, p, p->cchLabelArray), iMax );

    PopMemory( (PVOID)p );

    return TRUE;
}



/*+++
Function   : Dump_SID
Description:
Parameters :
Return     :
Remarks    : none.
---*/

DECLARE_DUMPFUNCTION( Dump_SID)
{

#define MAX_SID_STR_LENGTH          1024

    Printf( "SID(0x%p):\n", lpVoid );

    if ( !lpVoid )
    {
        Printf( "Cannot process [%p] pointer\n", lpVoid );
        return FALSE;
    }

    PSID pSid = (PSID) PushMemory( lpVoid, sizeof(SID) );
    CHAR szSid [ MAX_SID_STR_LENGTH ];
    DWORD cbSid = GetLengthSid(pSid );

    if ( !cbSid ||
         !IsValidSid(pSid) )
    {
         Printf( "Formatting aborted. Invalid SID\n" );
    }
    else
    {
        CHAR buffer[ 1024 ];

        UCHAR authCount = *GetSidSubAuthorityCount(pSid );


        strcpy ( szSid, "S-"  );

        for (INT i=0; i<(INT)authCount; i++)
        {
            DWORD dwAuth = *GetSidSubAuthority(pSid,
                                               i );
            sprintf( buffer, "%X", dwAuth  );

            if ( strlen(szSid) + strlen(buffer) > MAX_SID_STR_LENGTH - 5 )
            {
                strcat ( szSid, "..."  );
                 break;
            }
            strcat ( szSid, buffer  );
            if (i < (INT)authCount-1)
            {
                strcat ( szSid, "-"  );
            }
        }
    }

    Printf ( "SID = %s\n", szSid  );

    PopMemory( (PVOID)pSid );

    return TRUE;

#undef  MAX_SID_STR_LENGTH
}




/*+++
Function   : Dump_ADDITIONAL_INFO
Description: dumps out additional message info
Parameters :
Return     :
Remarks    : none.
---*/
DECLARE_DUMPFUNCTION( Dump_ADDITIONAL_INFO)
{
    Printf( "ADDITIONAL_INFO(0x%p):\n", lpVoid );

    if ( !lpVoid )
    {
        Printf( "Cannot process [%p] pointer\n", lpVoid );
        return FALSE;
    }
   if(!lpVoid){
       Printf( "Cannot process [%p] pointer\n", lpVoid );
      return FALSE;
   }
   //
   // print structure
   //

   PADDITIONAL_INFO p = (PADDITIONAL_INFO) PushMemory( lpVoid, sizeof(ADDITIONAL_INFO) );
   INT i=0, iMax=0;

    Printf( "   cMaxCount = 0x%x\n", p->cMaxCount );
    Printf( "   cCount = 0x%x\n", p->cCount );
    Printf( "   iIndex = 0x%x\n", p->iIndex );

   iMax = p->cCount <= MAX_ADDITIONAL_RECORD_COUNT? p->cCount : MAX_ADDITIONAL_RECORD_COUNT;

   PDB_NAME* pnames = (PDB_NAME*) PushMemory(
                                    (LPVOID) RELATIVE_ADDRESS(lpVoid, p, p->pNameArray),
                                    sizeof(PDB_NAME)*iMax  );
   for(i=0; i<iMax; i++){
       Printf( "    pNameArray[%d] = 0x%p\n", i, pnames[i] );
   }
   PopMemory( (PVOID)pnames );
   if(i > MAX_TINY_LIST){
       Printf( "    (truncated)...\n" );
   }

   WORD* poffsets = (WORD*) PushMemory(
                                  (LPVOID)RELATIVE_ADDRESS(lpVoid, p, p->wOffsetArray),
                                  sizeof(WORD)*iMax );
   for(i=0; i<iMax; i++){
       Printf( "    wOffsetArray[%d] = 0x%x\n", i, poffsets[i] );
   }
   PopMemory( (PVOID)poffsets );
   if(i > MAX_ADDITIONAL_RECORD_COUNT){
       Printf( "    (truncated)...\n" );
   }

   PopMemory( (PVOID)p );

   return TRUE;
}




/*+++
Function   : Dump_COMPRESSION_INFO
Description: dumps out additional message info
Parameters :
Return     :
Remarks    : none.
---*/
DECLARE_DUMPFUNCTION( Dump_COMPRESSION_INFO)
{
    Printf( "COMPRESSION_INFO(0x%p):\n", lpVoid );

    if ( !lpVoid )
    {
        Printf( "Cannot process [%p] pointer\n", lpVoid );
        return FALSE;
    }
   if(!lpVoid){
       Printf( "Cannot process [%p] pointer\n", lpVoid );
      return FALSE;
   }
   //
   // print structure
   //
   PCOMPRESSION_INFO p = (PCOMPRESSION_INFO) PushMemory( lpVoid, sizeof(COMPRESSION_INFO) );
   INT i=0, iMax=0;

    Printf( " cCount = 0x%x\n", p->cCount );

   PDB_NODE* pnodes = (PDB_NODE*) PushMemory( (LPVOID)RELATIVE_ADDRESS(lpVoid, p, p->pNodeArray), sizeof(PDB_NODE)*iMax );
   iMax = p->cCount <= MAX_COMPRESSION_COUNT? p->cCount : MAX_COMPRESSION_COUNT;
   for(i=0; i<iMax; i++){
       Printf( " pNodeArray[%d] = 0x%p\n", i, pnodes[i] );
   }
   PopMemory( (PVOID)pnodes );
   if(i > MAX_COMPRESSION_COUNT){
       Printf( " (truncated)...\n" );
   }
   WORD* poffsets = (WORD*) PushMemory( (LPVOID)RELATIVE_ADDRESS(lpVoid, p, p->wOffsetArray), sizeof(WORD)*iMax );
   for(i=0; i<iMax; i++){
       Printf( " wOffsetArray[%d] = 0x%p\n", i, poffsets[i] );
   }
   PopMemory( (PVOID)poffsets );
   if(i > MAX_COMPRESSION_COUNT){
       Printf( " (truncated)...\n" );
   }



   PopMemory( (PVOID)p );

   return TRUE;
}





/*+++
Function   : Dump_DS_SEARCH
Description:
Parameters :
Return     :
Remarks    : none.
---*/
DECLARE_DUMPFUNCTION( Dump_DS_SEARCH)
{
   // from DS.c
   struct _DnsDsEnum
   {
       PLDAPSearch     pSearchBlock;           // ldap search result on zone
       PLDAPMessage    pResultMessage;         // current page of message
       PLDAPMessage    pNodeMessage;           // message for current node
       PZONE_INFO      pZone;
       LONGLONG        SearchTime;
       LONGLONG        TombstoneExpireTime;
       DWORD           dwSearchFlag;
       DWORD           dwLookupFlag;
       DWORD           dwHighestVersion;
       DWORD           dwTotalNodes;
       DWORD           dwTotalTombstones;
       DWORD           dwTotalRecords;
   #if 0
       DWORD           dwHighUsnLength;
       CHAR            szHighUsn[ MAX_USN_LENGTH ];    // largest USN in enum
   #endif
       CHAR            szStartUsn[ MAX_USN_LENGTH ];   // USN at search start

       //  node record data

       PLDAP_BERVAL *  ppBerval;           // the values in the array
       PDB_RECORD      pRecords;
       DWORD           dwRecordCount;
       DWORD           dwNodeVersion;
       DWORD           dwTombstoneVersion;
   };


    Printf( "DS_SEARCH(0x%p):\n", lpVoid );

    if ( !lpVoid )
    {
        Printf( "Cannot process [%p] pointer\n", lpVoid );
        return FALSE;
    }

   //
   // print structure
   //
   struct _DnsDsEnum *p = (struct _DnsDsEnum*) PushMemory( lpVoid, sizeof(struct _DnsDsEnum) );

    Printf( " pSearchBlock = 0x%p\n", p->pSearchBlock );
    Printf( " pResultMessage = 0x%p\n", p->pResultMessage );
    Printf( " pNodeMessage = 0x%p\n", p->pNodeMessage );
    Printf( " pZone = 0x%p\n", p->pZone );
    Printf( " SearchTime = 0x%x:0x%x\n", (DWORD)(p->SearchTime>>32), (DWORD)(p->SearchTime & 0x00000000ffffffff) );
    Printf( " TombstoneExpireTime = 0x%x:0x%x\n", (DWORD)(p->TombstoneExpireTime>>32),(DWORD)(p->TombstoneExpireTime & 0x00000000ffffffff) );
    Printf( " dwSearchFlag = 0x%x\n", p->dwSearchFlag );
    Printf( " dwLookupFlag = 0x%x\n", p->dwLookupFlag );
    Printf( " dwHighestVersion = 0x%x\n", p->dwHighestVersion );
    Printf( " dwTotalNodes = 0x%x\n", p->dwTotalNodes );
    Printf( " dwTotalTombstones = 0x%x\n", p->dwTotalTombstones );
    Printf( " dwTotalRecords = 0x%x\n", p->dwTotalRecords );
#if 0
    Printf( " dwHighUsnLength = 0x%x\n", p->dwHighUsnLength );
    Printf( " szHighUsn = 0x%p\n", RELATIVE_ADDRESS(lpVoid, p, p->szHighUsn) );
#endif
    Printf( " szStartUsn = 0x%p\n", RELATIVE_ADDRESS(lpVoid, p, p->szStartUsn) );

   //  node record data

    Printf( " ppBerval = 0x%p\n", p->ppBerval );
    Printf( " pRecords = 0x%p\n", p->pRecords );
    Printf( " dwRecordCount = 0x%x\n", p->dwRecordCount );
    Printf( " dwNodeVersion = 0x%x\n", p->dwNodeVersion );
    Printf( " dwTombstoneVersion = 0x%x\n", p->dwTombstoneVersion );

   PopMemory( (PVOID)p );

   return TRUE;
}

/*+++
Function   : Dump_Record_SOA
Description:
Parameters :
Return     :
Remarks    : none.
---*/
DECLARE_DUMPFUNCTION( Dump_Record_SOA)
{
    struct SOA
    {
        PDB_NODE        pnodePrimaryServer;
        PDB_NODE        pnodeZoneAdmin;
        DWORD           dwSerialNo;
        DWORD           dwRefresh;
        DWORD           dwRetry;
        DWORD           dwExpire;
        DWORD           dwMinimumTtl;
    };

    Printf( "DB_RECORD.SOA(0x%p):\n", lpVoid );

    if ( !lpVoid )
    {
        Printf( "Cannot process [%p] pointer\n", lpVoid );
        return FALSE;
    }

    struct SOA *psoa = (struct SOA*) PushMemory( lpVoid, sizeof(struct SOA) );

    Printf( " pnodePrimaryServer    = 0x%p\n",  psoa->pnodePrimaryServer );
    Printf( " pnodeZoneAdmin        = 0x%p\n",  psoa->pnodeZoneAdmin );
    Printf( " dwSerialNo            = 0x%x\n",  psoa->dwSerialNo );
    Printf( " dwRefresh             = 0x%x\n",  psoa->dwRefresh );
    Printf( " dwRetry               = 0x%x\n",  psoa->dwRetry );
    Printf( " dwExpire              = 0x%x\n",  psoa->dwExpire );
    Printf( " dwMinimumTtl          = 0x%x\n",  psoa->dwMinimumTtl );

    PopMemory( (PVOID)psoa );

    return TRUE;
}


/*++
Routine Description: Dumps the buffer content on to the debugger output.
Arguments:
    Buffer: buffer pointer.
    BufferSize: size of the buffer.
Return Value: none
Author: borrowed from MikeSw
--*/
VOID DumpBuffer(PVOID Buffer, DWORD BufferSize){
#define DUMPBUFFER_NUM_CHARS 16

    DWORD i, limit;
    CHAR TextBuffer[DUMPBUFFER_NUM_CHARS + 1];
    LPBYTE BufferPtr = (LPBYTE) PushMemory( Buffer, BufferSize );


     Printf( "----------------(0x%p)--------------\n", Buffer );

    //
    // Hex dump of the bytes
    //
    limit = ((BufferSize - 1) / DUMPBUFFER_NUM_CHARS + 1) * DUMPBUFFER_NUM_CHARS;

    for (i = 0; i < limit; i++) {

        if (i < BufferSize) {

             Printf( "%02x ", BufferPtr[i] );

            if (BufferPtr[i] < 31 ) {
                TextBuffer[i % DUMPBUFFER_NUM_CHARS] = '.';
            } else if (BufferPtr[i] == '\0') {
                TextBuffer[i % DUMPBUFFER_NUM_CHARS] = ' ';
            } else {
                TextBuffer[i % DUMPBUFFER_NUM_CHARS] = (CHAR) BufferPtr[i];
            }

        } else {

             Printf( "  " );
            TextBuffer[i % DUMPBUFFER_NUM_CHARS] = ' ';

        }

        if ((i + 1) % DUMPBUFFER_NUM_CHARS == 0) {
            TextBuffer[DUMPBUFFER_NUM_CHARS] = 0;
             Printf( "  %s\n", TextBuffer );
        }

    }

     Printf( "------------------------------------\n" );

    PopMemory( (PVOID)BufferPtr );

#define DUMPBUFFER_NUM_CHARS 16
}

#endif  // DUMP_CXX
=== C:/Users/treeman/Desktop/windows nt source code\Source\Win2K3\NT\ds\dns\dnsexts\dnsexts.cxx ===
/*******************************************************************
*
*    File        : dnsexts.cxx
*    Author      : Eyal Schwartz
*    Copyrights  : Microsoft Corp (C) 1996
*    Date        : 7/14/1998
*    Description : dnsext.dll debugger extension.
*
*    Revisions   : <date> <name> <description>
*******************************************************************/



#ifndef DNSEXTS_CXX
#define DNSEXTS_CXX



// include //
// #include <dns.h>
#include "common.h"
#include "dump.hxx"
#include "util.hxx"
#include <ntverp.h>
#include <string.h>



// defines //

// types //


// global variables //

PNTSD_EXTENSION_APIS glpExtensionApis=NULL;
LPSTR glpArgumentString=NULL;
HANDLE ghCurrentProcess=NULL;
LPVOID gCurrentAllocation=NULL;

// prototypes //
INT GetDumpTableIndex(LPSTR szName);
DWORD ExceptionHandler(DWORD dwException);



// functions //

/*+++
Function   : DllAttach
Description: initializes the library upon attach
Parameters : none.
Return     :
Remarks    : none.
---*/
BOOL DllAttach(void)
{
   INT i=0;
   BOOL bRet=TRUE;

   //
   // Nothing to do yet
   //
   return bRet;
}


/*+++
Function   : DllDetach
Description: initializes the library upon attach
Parameters : none.
Return     :
Remarks    : none.
---*/
BOOL DllDetach(void)
{
   BOOL bRet=TRUE;

   //
   // Nothing to do yet
   //

   return bRet;
}


/*+++
Function   : ExceptionHandler
Description:
Parameters :
Return     :
Remarks    : none.
---*/
DWORD ExceptionHandler(DWORD dwException){

   Printf("Exception 0x%x: dnsexts exception failure\n", dwException);
   CleanMemory();

   return EXCEPTION_EXECUTE_HANDLER;
}





/*+++
Function   : help
Description: dump usage
Parameters : as specified in ntdsexts.h
Return     :
Remarks    : none.
---*/
PNTSD_EXTENSION_ROUTINE (help)(
                               HANDLE hCurrentProcess,
                               HANDLE hCurrentThread,
                               DWORD dwCurrentPc,
                               PNTSD_EXTENSION_APIS lpExtensionApis,
                               LPSTR lpArgumentString
                               )
{

   ASSIGN_NTSDEXTS_GLOBAL(lpExtensionApis, lpArgumentString, hCurrentProcess);
   Printf("dnsexts usage (version %s):\n", VER_PRODUCTVERSION_STR);
   Printf(" help: this help screen.\n");
   Printf(" dump <DATATYPE> <ADDRESS>: dumps structure at <address> in <DATATYPE> format.\n");
   Printf("---\n");

   return 0;
}



/*+++
Function   : GetDumpTableIndex
Description: Get index into dump table if the entry by that name exist
Parameters : szName: function name to find
Return     : -1 if failed, otherwise index value
Remarks    : none.
---*/
INT GetDumpTableIndex(LPSTR szName)
{
   INT i=0;

   for(i=0;i<gcbDumpTable; i++){
      if(!_stricmp(szName,gfDumpTable[i].szName)){
         return i;
      }
   }

   return -1;
}

/*+++
Function   : dump
Description: dumps give data structure
Parameters :  as specified in ntdsexts.h
Return     :
Remarks    : command line gives structure name & hex value
---*/
PNTSD_EXTENSION_ROUTINE (dump)(
                               HANDLE hCurrentProcess,
                               HANDLE hCurrentThread,
                               DWORD dwCurrentPc,
                               PNTSD_EXTENSION_APIS lpExtensionApis,
                               LPSTR lpArgumentString
                               )
{


   __try{

   INT i=0;       // generic index
   //
   // make interface availabe globally
   //

   ASSIGN_NTSDEXTS_GLOBAL(lpExtensionApis, lpArgumentString, hCurrentProcess);

   DEBUG1("DEBUG: Argstring=[%s]\n", lpArgumentString);
   //
   // process argument string
   //


   //
   // Format: DATATYPE ADDRESS
   //
   LPVOID lpVoid=0x0;
   const LPSTR cDelimiters=" \t";
   LPSTR szDataType = NULL, szAddress=NULL;

   if(NULL != (szDataType = strtok(lpArgumentString, cDelimiters)) &&
      NULL != (szAddress = strtok(NULL, cDelimiters)) &&
      NULL == strtok(NULL, cDelimiters) ||
      ((szDataType != NULL && szAddress == NULL && !_stricmp(szDataType,"HELP")))){
      //
      // Got all arguments
      //
      if(szAddress != NULL){
         lpVoid = (LPVOID)GetExpr(szAddress);
      }

      //
      // BUGBUG: DEBUG!
      //
      DEBUG1("DEBUG: szDataType=[%s]\n", szDataType);
      DEBUG1("DEBUG: szAddress=[%s]\n", szAddress);
      DEBUG1("DEBUG: lpVoid =[%p]\n", lpVoid);
      //
      // find in function table & call function
      //

      if(0 > (i = GetDumpTableIndex(szDataType))){
         Printf("Usage error: Cannot find function %s. Type dnsexts.dump help.\n", szDataType);
      }
      else{
         //
         // call function
         //
         BOOL bRet=TRUE;
         bRet = gfDumpTable[i].function(lpVoid);
         if(!bRet){
            Printf("Error: function %s failed\n", szDataType);
         }
      }
   }
   else{
      //
      // error
      //
      Printf("Usage error (2). Type dnsexts.dump help.\n");
   }


   }  // try-except
   __except(ExceptionHandler(GetExceptionCode())){
      Printf("Aborting dump funtion\n");
   }


   return 0;
}




////////////////////// ENTRY POINT //////////////////////

/*+++
Function   : DllMain
Description: <<<DLL entry point>>>
Parameters : standard DllMain
Return     : init success bool
Remarks    : none.
---*/





BOOL APIENTRY DllMain(HANDLE hModule,
                      DWORD  ul_reason_for_call,
                      LPVOID lpReserved)
{

   BOOL bRet = TRUE;

   switch( ul_reason_for_call ) {
   case DLL_PROCESS_ATTACH:
      bRet = DllAttach();
      break;

   case DLL_THREAD_ATTACH:
      break;

   case DLL_THREAD_DETACH:
      break;

   case DLL_PROCESS_DETACH:
      bRet = DllDetach();
      break;

   }


   return bRet;
}













#endif

/******************* EOF *********************/
=== C:/Users/treeman/Desktop/windows nt source code\Source\Win2K3\NT\ds\dns\dnsexts\util.cxx ===
/*******************************************************************
*
*    File        : util.cxx
*    Author      : Eyal Schwartz
*    Copyrights  : Microsoft Corp (C) 1996
*    Date        : 7/21/1998
*    Description :
*
*    Revisions   : <date> <name> <description>
*******************************************************************/



#ifndef UTIL_CXX
#define UTIL_CXX



// include //
#include "common.h"
#include "util.hxx"


// defines //
#define DNSEXT_CUSTOMER_CODE 0xD0000000
#define STACK_OVERFLOW     STATUS_STACK_OVERFLOW | DNSEXT_CUSTOMER_CODE


// types //


// global variables //
PVOID gAllocationStack[MAXLIST];

// local variables //
static INT iStackSize=0;


// prototypes //
PVOID
ReadMemory(
    IN PVOID  pvAddr,
    IN DWORD  dwSize);
VOID
FreeMemory(
    IN PVOID pv);







// functions //

PVOID PushMemory(
                 IN PVOID  pvAddr,
                 IN DWORD  dwSize)
/*++

Routine Description:

   Shells on read memory to remember the pointer in a local stack

Arguments:

    pvAddr - Address of memory block to read in the address space of the
        process being debugged.

    dwSize - Count of bytes to read/allocate/copy.

Return Value:

    Pointer to debugger local memory.

--*/

{

   if(iStackSize == MAXLIST-1){
      Printf("Exception: No more allocation stack memory\n");
      RaiseException(STACK_OVERFLOW, 0, 0, NULL);
   }

   PVOID pv = ReadMemory(pvAddr, dwSize);
   if(!pv){
      Printf("Exception: No memory\n");
      RaiseException(STACK_OVERFLOW, 0, 0, NULL);
   }

   return gAllocationStack[iStackSize++] = pv;

}



VOID
PopMemory(
    IN PVOID pv)

/*++

Routine Description:

    Frees memory returned by PushMemory.

Arguments:

    pv - Address of debugger local memory to free.

Return Value:

    None.

--*/

{
   FreeMemory(pv);
   if(0 == iStackSize){
      Printf("Exception: Invalid stack operation (iStackSize == 0).\n");
      RaiseException(STACK_OVERFLOW, 0, 0, NULL);
   }
   gAllocationStack[iStackSize--] = NULL;
}



VOID
CleanMemory( VOID)

/*++

Routine Description:

    Frees all stack memory returned by PushMemory.

Arguments:



Return Value:

    None.

--*/

{
   for (INT i=0; i<MAXLIST; i++) {
      if(gAllocationStack[i]){
         FreeMemory(gAllocationStack[i]);
      }
   }
}



//
// NOTE: The following mem utils were copied & modified from dsexts.dll code base
//

PVOID
ReadMemory(
    IN PVOID  pvAddr,
    IN DWORD  dwSize)

/*++

Routine Description:

    This function reads memory from the address space of the process
    being debugged and copies its contents to newly allocated memory
    in the debuggers address space.  NULL is returned on error. Returned
    memory should be deallocated via FreeMemory().

Arguments:

    pvAddr - Address of memory block to read in the address space of the
        process being debugged.

    dwSize - Count of bytes to read/allocate/copy.

Return Value:

    Pointer to debugger local memory.

--*/

{
    SIZE_T cRead;
    PVOID pv;

    DEBUG1("HeapAlloc(0x%x)\n", dwSize);

    if ( NULL == (pv = HeapAlloc(GetProcessHeap(), 0, dwSize)) )
    {
        Printf("Memory allocation error for %x bytes\n", dwSize);
        return(NULL);
    }

    DEBUG2("ReadProcessMemory(0x%x @ %p)\n", dwSize, pvAddr);

    if ( !ReadProcessMemory(ghCurrentProcess, pvAddr, pv, dwSize, &cRead) )
    {
        FreeMemory(pv);
        Printf("ReadProcessMemory error %x (%x@%p)\n",
               GetLastError(),
               dwSize,
               pvAddr);
        return(NULL);
    }

    if ( dwSize != ( DWORD ) cRead )
    {
        FreeMemory(pv);
        Printf("ReadProcessMemory size error - off by %x bytes\n",
               ( dwSize > ( DWORD ) cRead ) ?
               dwSize - ( DWORD ) cRead :
               ( DWORD ) cRead - dwSize );
        return(NULL);
    }

    return(pv);
}





VOID
FreeMemory(
    IN PVOID pv)

/*++

Routine Description:

    Frees memory returned by ReadMemory.

Arguments:

    pv - Address of debugger local memory to free.

Return Value:

    None.

--*/

{

    DEBUG1("HeapFree(%p)\n", pv);

    if ( NULL != pv )
    {
        if ( !HeapFree(GetProcessHeap(), 0, pv) )
        {
            Printf("Error %x freeing memory at %p\n", GetLastError(), pv);
        }
    }
}







#endif

/******************* EOF *********************/



=== C:/Users/treeman/Desktop/windows nt source code\Source\Win2K3\NT\ds\dns\dnslib\debug.c ===
/*++

Copyright (c) 1995-2001  Microsoft Corporation

Module Name:

    debug.c

Abstract:

    Domain Name System (DNS) Library

    Debug routines.

Author:

    Jim Gilroy (jamesg)    January 31, 1995

Revision History:

--*/


#include "local.h"


#define DNSDBG_CONTEXT_SWITCH_LOGGING   1

#define DNSDBG_DEFAULT_WRAP_SIZE        (2000000)       // 2mb


//
//  DCR:  Temp hack while debugging print lock jam
//      - cuts off lock printing to avoid recursive spin
//

extern  PCRITICAL_SECTION   pDnsAtomicPrintCs;


//
//  Debug globals
//

DNS_DEBUG_INFO  g_DnsDbgInfo = { 0 };

PDNS_DEBUG_INFO g_pDbgInfo = &g_DnsDbgInfo;

//  Redirected

BOOL    g_DbgRedirected = FALSE;

//
//  Debug flag -- exposed as pointer in dnslib.h
//
//  By default use DnsDebugFlag, but actual debug printing is
//  switched by *pDnsDebugFlag, which caller may point at local
//  flag if desired.
//

PDWORD  pDnsDebugFlag = (PDWORD)&g_DnsDbgInfo;

//
//  Note that in all functions below, we use the universal
//  check IS_DNSDBG_ON(), which is defined for debug AND retail.
//  Do NOT use any of the debug macros, as we want the code to
//  work equally well in retail versions of dnsapi.dll, so that
//  debug versions of calling modules can use these functions.
//

//
//  Print buffer sizes
//      - small default stack buffer
//      - large buffer on heap to handle any print
//
//  NOTE:  MUST have stack buffer of sufficient size to
//          handle any message we print on memory allocation
//          failure;  otherwise we get into the obvious loop
//          of alloc failure causing print, which causes attempted
//          alloc and another print
//

#define DNS_STACK_PRINT_BUFFER_LENGTH   (0x300)     // 768 covers 99%
#define DNS_HEAP_PRINT_BUFFER_LENGTH    (0x4000)    // 16K will cover anything



//
//  Public debug routines
//

VOID
Dns_Assert(
    IN      LPSTR           pszFile,
    IN      INT             LineNo,
    IN      LPSTR           pszExpr
    )
{
    DnsDbg_Printf(
        "ASSERTION FAILED: %s\n"
        "  %s, line %d\n",
        pszExpr,
        pszFile,
        LineNo );

    DnsDbg_Flush();

    //  always print to debugger, even if debugger print flag not set

    if ( ! IS_DNSDBG_ON( DEBUGGER ) )
    {
        DnsDbg_PrintfToDebugger(
            "ASSERTION FAILED: %s\n"
            "  %s, line %d\n",
            pszExpr,
            pszFile,
            LineNo );
    }

    if ( IS_DNSDBG_ON( BREAKPOINTS ) )
    {
        DebugBreak();
    }
    else
    {
        DnsDbg_Printf( "Skipping DNS_ASSERT, debug flag = %lx\n", *pDnsDebugFlag );
    }
}



#if 0
typedef struct _DnsDebugInit
{
    DWORD       Flag;
    PSTR        pszFlagFile;
    PDWORD      pDebugFlag;
    PSTR        pszLogFile;
    DWORD       WrapSize;
    BOOL        fUseGlobalFile;
    BOOL        fUseGlobalFlag;
    BOOL        fSetGlobals;
}
DNS_DEBUG_INIT, *PDNS_DEBUG_INIT;
#endif


VOID
Dns_StartDebugEx(
    IN      DWORD           DebugFlag,
    IN      PSTR            pszFlagFile,
    IN OUT  PDWORD          pDebugFlag,
    IN      PSTR            pszLogFile,
    IN      DWORD           WrapSize,
    IN      BOOL            fUseGlobalFile,
    IN      BOOL            fUseGlobalFlag,
    IN      BOOL            fSetGlobals
    )
/*++

Routine Description:

    Initialize debugging.
    Only current task is to read and set debug flags.

Arguments:

    includes:
        dwFlag      -- debug flags
        pszFlagFile -- name of file containing debug flags
        pdwFlag     -- ptr to DWORD to receive debug flags
        pszLogFile  -- log file name
        dwWrapSize  -- log file wrap size

    fUseGlobalFile -- 

    fUseGlobalFlag --

    fSetGlobals --

Return Value:

    None.

--*/
{
    HANDLE  hfile;
    DWORD   freadFlag = FALSE;
    BOOL    fretry = FALSE;
    CHAR    prevName[ MAX_PATH+10 ];
    DWORD   debugFlag;

    PDNS_DEBUG_INFO     pinfoGlobal = NULL;

    //
    //  use external flag?
    //      - save ptr to it
    //
    //  allow use of external flag so callers -- eg. DNS server --
    //  can easily manipulate flag during run time and still keep
    //  their checking macros simple
    //

    if ( pDebugFlag )
    {
        pDnsDebugFlag       = pDebugFlag;
        g_DnsDbgInfo.Flag   = *pDnsDebugFlag;
    }

    //
    //  get piggyback info
    //

    if ( fUseGlobalFlag || fUseGlobalFile )
    {
        pinfoGlobal = DnsApiSetDebugGlobals( NULL );
    }

    //
    //  skip debug flag setup if piggybacking
    //      - use the existing flag value
    //      - but not safe to grab pointer which
    //          may go away on dll unload
    //
    //  DCR:  safe way to use existing flags?
    //  DCR:  need to be able to get "last" debug flag set
    //      without blowing up
    //

    if ( fUseGlobalFlag &&
         pinfoGlobal &&
         pinfoGlobal->hFile )
    {
        goto Done;
    }

    //
    //  setup debug flag
    //

    debugFlag = DebugFlag;
    if ( debugFlag )
    {
        freadFlag = TRUE;
    }
    else if ( pszFlagFile )
    {
        //  read debug flag in file

        hfile = CreateFile(
                    pszFlagFile,
                    GENERIC_READ,
                    FILE_SHARE_READ,
                    NULL,
                    OPEN_EXISTING,
                    0,
                    NULL
                    );
        if ( hfile == (HANDLE)INVALID_HANDLE_VALUE )
        {
            //  if file specified and not found, then quit if explicit value
            //  not given

            if ( debugFlag == 0 )
            {
                return;
            }
        }
        else
        {
            DWORD bytesRead;
            CHAR buffer[100];

            RtlZeroMemory( buffer, sizeof(buffer) );

            if ( ReadFile( hfile, buffer, 100, &bytesRead, NULL ) )
            {
                buffer[bytesRead] = '\0';
                debugFlag = strtoul( buffer, NULL, 16 );
                freadFlag = TRUE;
            }
            else
            {
                DnsDbg_Printf( "read file failed: %ld\n", GetLastError( ) );
                if ( debugFlag == 0 )
                {
                    CloseHandle( hfile );
                    return;
                }
            }
            CloseHandle( hfile );
        }
    }

    //
    //  save any flag read
    //      - reset global (internal or external) to it
    //

    if ( freadFlag )
    {
        g_DnsDbgInfo.Flag   = debugFlag;
        *pDnsDebugFlag      = debugFlag;
    }

    //
    //  skip debug file open if piggybacking
    //
    //  two levels
    //      - only using file
    //      - using file and debug flags

    if ( fUseGlobalFile &&
         pinfoGlobal &&
         pinfoGlobal->hFile )
    {
        goto Done;
    }

    //
    //  open debug logfile
    //

    fretry = 0;

    while ( pszLogFile )
    {
        PCHAR   pnameBuf = g_DnsDbgInfo.FileName;

        //  heap may not be initialized, copy filename to static buffer
        //
        //  note:  if we fail on first pass we try again but open directly
        //      at file system root;  given simply filename, applications
        //      run from system32 and services (resolver) will attempt open
        //      in system32 and some (resolver) do not by default have
        //      permissions to create files there

        if ( fretry == 0 )
        {
            strncpy( pnameBuf, pszLogFile, MAX_PATH );
        }
        else
        {
            pnameBuf[0] = '\\';
            strncpy( pnameBuf+1, pszLogFile, MAX_PATH-1 );
        }
        pnameBuf[MAX_PATH-1] = 0;

#if 0
        //      jeff changes -- don't have time to fix up now
        //      file wrapping should handle this sort of thing

        //
        //  Save off the current copy as ".prev"
        //

        strncpy( prevName, DnsDebugFileName, MAX_PATH );
        strcat( prevName, ".prev" );

        MoveFileEx(
            DnsDebugFileName,
            prevName,
            MOVEFILE_REPLACE_EXISTING );

        DnsDebugFileHandle = CreateFile(
                                DnsDebugFileName,
                                GENERIC_READ | GENERIC_WRITE,
                                FILE_SHARE_READ,
                                NULL,
                                CREATE_ALWAYS,
                                0,
                                NULL
                                );
#endif
        hfile = CreateFile(
                    pnameBuf,
                    GENERIC_READ | GENERIC_WRITE,
                    FILE_SHARE_READ,
                    NULL,
                    CREATE_ALWAYS,
                    0,
                    NULL
                    );

        //  on failure, retry once

        if ( hfile == NULL || hfile == (HANDLE)INVALID_HANDLE_VALUE )
        {
            if ( !fretry )
            {
                fretry++;
                continue;
            }
            hfile = NULL;
        }

        g_DnsDbgInfo.hFile = hfile;
        g_DnsDbgInfo.FileWrapSize = WrapSize;
        break;
    }

    //
    //  initialize console
    //

    if ( IS_DNSDBG_ON( CONSOLE ) )
    {
        CONSOLE_SCREEN_BUFFER_INFO csbi;
        COORD coord;

        AllocConsole();
        GetConsoleScreenBufferInfo(
            GetStdHandle(STD_OUTPUT_HANDLE),
            &csbi
            );
        coord.X = (SHORT)(csbi.srWindow.Right - csbi.srWindow.Left + 1);
        coord.Y = (SHORT)((csbi.srWindow.Bottom - csbi.srWindow.Top + 1) * 20);
        SetConsoleScreenBufferSize(
            GetStdHandle(STD_OUTPUT_HANDLE),
            coord
            );

        g_DnsDbgInfo.fConsole = TRUE;
    }

    //
    //  set "global" debug file info
    //
    //  dnsapi.dll serves as storage for common dns client
    //  debug file if that is desired;  this lets applications
    //  push all dns debug output into a single file
    //
    //  currently push both file and debug flag value
    //  note, we don't push debug file ptr as don't know
    //  whose memory becomes invalid first
    //

    if ( fSetGlobals && g_DnsDbgInfo.hFile )
    {
        DnsApiSetDebugGlobals( 
            &g_DnsDbgInfo    // set our info as global
            );
    }

Done:

    //
    //  use "global" (dnsapi.dll) debugging
    //      - copy in our info if no existing info
    //      - set to use global info blob
    //
    //  two levels
    //      - only using file
    //      - using file and debug flags

    if ( fUseGlobalFile &&
         pinfoGlobal )
    {
        //  copy in our new info if no global info exists

        if ( !pinfoGlobal->hFile &&
             g_DnsDbgInfo.hFile )
        {
            DnsApiSetDebugGlobals( &g_DnsDbgInfo );
        }

        //  point at global info

        g_pDbgInfo = pinfoGlobal;
        g_DbgRedirected = TRUE;

        if ( fUseGlobalFlag )
        {
            pDnsDebugFlag = (PDWORD) pinfoGlobal;
        }

        //  avoid double cleanup
        //      - clear the handle in your modules blob

        g_DnsDbgInfo.hFile = NULL;
    }

    //
    //  use print locking for debug locking
    //

    DnsPrint_InitLocking( NULL );

    DNSDBG( ANY, (
        "Initialized debugging:\n"
        "\tpDbgInfo         %p\n"
        "\t&DnsDbgInfo      %p\n"
        "\tfile (param)     %s\n"
        "\thFile            %p\n"
        "\tpDbgInfo->Flag   %08x\n"
        "\tpDnsDebugFlag    %p\n"
        "\t*pDnsDebugFlag   %08x\n"
        "DnsLib compiled on %s at %s\n",
        g_pDbgInfo,
        &g_DnsDbgInfo,
        pszLogFile,
        g_pDbgInfo->hFile,
        g_pDbgInfo->Flag,
        pDnsDebugFlag,
        *pDnsDebugFlag,
        __DATE__,
        __TIME__  ));

}   //  Dns_StartDebug



#if 0
VOID
Dns_StartDebugEx(
    IN      DWORD           dwFlag,
    IN      PSTR            pszFlagFile,
    IN OUT  PDWORD          pdwFlag,
    IN      PSTR            pszLogFile,
    IN      DWORD           dwWrapSize,
    IN      BOOL            fUseGlobalFile,
    IN      BOOL            fUseGlobalFlag,
    IN      BOOL            fSetGlobals
    )
/*++

Routine Description:

    Initialize debugging.
    Only current task is to read and set debug flags.

Arguments:

    dwFlag      -- debug flags
    pszFlagFile -- name of file containing debug flags
    pdwFlag     -- ptr to DWORD to receive debug flags
    pszLogFile  -- log file name
    dwWrapSize  -- log file wrap size

Return Value:

    None.

--*/
{
    DNS_DEBUG_INIT  info;

    RtlZeroMemory
        &info,
        sizeof(info) );

    info.pszFlagFile  = pszFlagFile;
    info.DebugFlags   = dwFlag;
    info.pDebugFlags  = pdwFlag;
    info.pszLogFile   = pszLogFile;
    info.dwWrapSize   = dwWrapSize;

    info.fUseGlobalFile = fUseGlobalFile;
    info.fUseGlobalFlag = fUseGlobalFlag;
    info.fSetGlobals    = fSetGlobals;

    privateStartDebug( &info );
}
#endif



VOID
Dns_StartDebug(
    IN      DWORD           dwFlag,
    IN      PSTR            pszFlagFile,
    IN OUT  PDWORD          pdwFlag,
    IN      PSTR            pszLogFile,
    IN      DWORD           dwWrapSize
    )
/*++

Routine Description:

    Initialize debugging.
    Only current task is to read and set debug flags.

Arguments:

    dwFlag      -- debug flags
    pszFlagFile -- name of file containing debug flags
    pdwFlag     -- ptr to DWORD to receive debug flags
    pszLogFile  -- log file name
    dwWrapSize  -- log file wrap size

Return Value:

    None.

--*/
{
    Dns_StartDebugEx(
            dwFlag,
            pszFlagFile,
            pdwFlag,
            pszLogFile,
            dwWrapSize,
            FALSE,
            FALSE,
            FALSE );
}



VOID
Dns_EndDebug(
    VOID
    )
/*++

Routine Description:

    Terminate DNS debugging for shutdown.

    Close debug file.

Arguments:

    None.

Return Value:

    None.

--*/
{
    //  close file
    //      - but only your dnslib instance
    //      - shared global file is closed by dnsapi

    if ( g_DnsDbgInfo.hFile )
    {
        CloseHandle( g_DnsDbgInfo.hFile );
        g_DnsDbgInfo.hFile = NULL;
    }
}



PDNS_DEBUG_INFO
Dns_SetDebugGlobals(
    IN OUT  PDNS_DEBUG_INFO pInfo
    )
/*++

Routine Description:

    Exposure of debug globals.

    The purpose of this is to allow dnsapi.dll to use it's globals
    to allow common debug file.  I'm using one routine for both
    get and set to mimize the interfaces.

    Note however, that this is NOT the routine that routines in
    this module use to get cross-module debugging.  They MUST call
    the actual dnsapi.dll routine so that they are attaching
    to the dnsapi's dnslib debugging globls not the ones with the
    dnslib statically linked into their module.

Arguments:

    pInfo -- local info to use as global info

Return Value:

    Ptr to global info

--*/
{
    //
    //  verify valid info coming in
    //      - must have file handle
    //


    //
    //  Implementation note:
    //
    //  There are several issues to deal with when doing this
    //      - multiple redirection
    //      getting everyone to point at same blob
    //      solutions:
    //          - either double pointer (they read dnsapi.dll
    //          pointer
    //          - copy into dnsapi.dll the info
    //      - locking
    //          - broad scale print of structs
    //      - cleanup
    //          - no double close of handle
    //          - memory sections disappearing while some dll
    //          or exe still printing
    //
    //  Approachs:
    //      1) redirect blob pointer
    //          blob could expand to include actual print locks
    //      2) copy info into single blob
    //      3) expose debug routines
    //
    //
    //  Perhaps best approach might be to expose the dnsapi.dll
    //  printing
    //      - solves locking (at detail level), doesn't prevent breakup
    //          of high level printing unless it also redirected
    //      - can be done at the private level after parsing to va_arg
    //      - solves all the cleanup
    //      - they can be dumb stubs in non-debug binary, and dnslib
    //      routines can default to self if can't call dnsapi.dll
    //      routines
    //
    //  Then redirection is simply
    //      - yes i use it -- redirection on each use
    //      - i want my file (and params) to BE used
    //

#if 1
    //
    //  copy over "i-want-to-be-global" callers context
    //
    //  note:  we're in dnsapi.dll here and should always be
    //      pointed at our own context -- we can change that
    //      later if desired
    //
    //  note
    //      - lock during copy to be safe
    //      - don't leak existing handle
    //      - protect global handle from double close
    //     

    if ( pInfo )
    {
        DnsPrint_Lock();

        DNS_ASSERT( g_pDbgInfo == &g_DnsDbgInfo );

        if ( pInfo->hFile )
        {
            HANDLE  htemp = g_pDbgInfo->hFile;

            RtlCopyMemory(
                & g_DnsDbgInfo,
                pInfo,
                sizeof(*pInfo) );

            g_pDbgInfo = &g_DnsDbgInfo;
            pDnsDebugFlag = (PDWORD)&g_DnsDbgInfo;

            CloseHandle( htemp );
        }
        DnsPrint_Unlock();
    }
#else

    //
    //  point dnsapi.dll debugging global at this context
    //  which becomes "global"
    //  note:  essential this is last writer wins, but this
    //      should be fine for our purpuse (dnsup and resolver)
    //      as these processes init the debug after the
    //      dll loads
    //
    //  problem with this approach is that folks redirected
    //      onto dnsapi.dll do not get new info when it is
    //      redirected (into dnsup)

    if ( pInfo && pInfo->hFile )
    {
        g_pDbgInfo      = pInfo;
        pDnsDebugFlag   = (PDWORD)pInfo;
    }
#endif

    return  g_pDbgInfo;
}



#if 0
VOID
privateSyncGlobalDebug(
    VOID
    )
/*++

Routine Description:

    Sync up with global debug.

    Get dnslib debugging in line with "global" debugging if
    that is desired for this dnslib instance.

Arguments:

    None.

Return Value:

    None

--*/
{
    if ( !g_DbgRedirected )
    {
        return;
    }

    //  sync with global values
}
#endif



VOID
DnsDbg_WrapLogFile(
    VOID
    )
/*++

Routine Description:

    Wrap the log file.

Arguments:

    None.

Return Value:

    None.

--*/
{
    CHAR    backupName[ MAX_PATH+10 ];
    HANDLE  hfile;

    //
    //  note, need to lock as file handle used in DnsDbg_Flush()
    //      outside print routine
    //  

    DnsPrint_Lock();

    hfile = g_pDbgInfo->hFile;
    if ( hfile )
    {
        FlushFileBuffers( hfile );
        CloseHandle( hfile );
    }

    strcpy( backupName, g_pDbgInfo->FileName );

    if ( g_pDbgInfo->FileWrapCount == 0 )
    {
        strcat( backupName, ".first" );
    }
    else
    {
        strcat( backupName, ".last" );
    }
    MoveFileEx(
        g_pDbgInfo->FileName,
        backupName,
        MOVEFILE_REPLACE_EXISTING
        );

    hfile = CreateFile(
                g_pDbgInfo->FileName,
                GENERIC_READ | GENERIC_WRITE,
                FILE_SHARE_READ,
                NULL,
                CREATE_ALWAYS,
                0,
                NULL
                );
    if ( hfile == (HANDLE)INVALID_HANDLE_VALUE )
    {
        hfile = NULL;
    }
    g_pDbgInfo->hFile = hfile;
    g_pDbgInfo->FileWrapCount++;
    g_pDbgInfo->FileCurrentSize = 0;

    DnsPrint_Unlock();
}



VOID
privateDnsDebugPrint(
    IN      PBYTE           pOutputBuffer,
    IN      BOOL            fPrintContext
    )
/*++

Routine Description:

    Private DNS debug print that does actual print.

    May print to any of
        - debugger
        - console window
        - debug log file

Arguments:

    pOutputBuffer -- bytes to print

    fPrintContext
        - TRUE to print thread context
        - FALSE otherwise

Return Value:

    None.

--*/
{
    DWORD           length;
    BOOL            ret;

    //
    //  DCR:  nice to automatically shut down console print when debugging
    //      it would be cool to be able to have all flags on, and detect
    //      when in ntsd, so that we don't get duplicated output
    //

    //
    //  lock print to keep atomic even during wrap
    //      - note use Print lock, which exists even in retail builds
    //      Dbg lock is defined away
    //

    DnsPrint_Lock();

    //
    //  catch and timestamp thread context switches
    //

    if ( fPrintContext )
    {
        DWORD       threadId = GetCurrentThreadId();
        BOOL        fcontextSwitch = (g_pDbgInfo->LastThreadId != threadId);
        SYSTEMTIME  st;
        BOOL        fdoPrint = FALSE;

        //  get time
        //      - if have context switch
        //      - or putting in debug timestamps
        //
        //  DCR:  maybe have global that set to put in timestamps and
        //      can set interval
        //
        //  DCR:  lock safe timestamps
        //      better would be "lock-safe" timestamps that are printed
        //      only when take the print lock -- then they would never
        //      interrupt the a multi-part print
        //      one way might be to test recursive depth of print CS
        //      otherwise must change to lock that includes this
        //      code

        if ( fcontextSwitch
                ||
            (pDnsDebugFlag && (*pDnsDebugFlag & DNS_DBG_TIMESTAMP)) )
        {
            GetLocalTime( &st );

            if ( g_pDbgInfo->LastSecond != st.wSecond )
            {
                fdoPrint = TRUE;
            }
        }

        if ( fcontextSwitch || fdoPrint )
        {
            CHAR    printBuffer[ 200 ];

            length = sprintf(
                        printBuffer,
                        fcontextSwitch ?
                            "\n%02d:%02d:%02d:%03d DBG switch from thread %X to thread %X\n" :
                            "%02d:%02d:%02d:%03d DBG tick\n",
                        st.wHour,
                        st.wMinute,
                        st.wSecond,
                        st.wMilliseconds,
                        g_pDbgInfo->LastThreadId,
                        threadId );

            g_pDbgInfo->LastSecond = st.wSecond;
            g_pDbgInfo->LastThreadId = threadId;

            //  print context
            //      - suppress context even through thread test
            //      would break recursion
    
            privateDnsDebugPrint(
                printBuffer,
                FALSE       // suppress context
                );
        }
    }

    //
    //  output -- to debugger, console, file
    //

    if ( IS_DNSDBG_ON( DEBUGGER ) )
    {
        OutputDebugString( pOutputBuffer );
    }

    if ( IS_DNSDBG_ON( CONSOLE ) )
    {
        if ( g_pDbgInfo->fConsole )
        {
            length = strlen( pOutputBuffer );

            ret = WriteFile(
                        GetStdHandle(STD_OUTPUT_HANDLE),
                        (PVOID) pOutputBuffer,
                        length,
                        &length,
                        NULL
                        );
#if 0
            if ( !ret )
            {
                DnsDbg_PrintfToDebugger(
                    "DnsDbg_Printf: console WriteFile failed: %ld\n",
                    GetLastError() );
            }
#endif
        }
    }

    //
    //  write to debug log
    //

    if ( IS_DNSDBG_ON( FILE ) )
    {
        if ( g_pDbgInfo->hFile )
        {
            length = strlen( pOutputBuffer );

            ret = WriteFile(
                        g_pDbgInfo->hFile,
                        (PVOID) pOutputBuffer,
                        length,
                        &length,
                        NULL
                        );
            if ( !ret )
            {
                DnsDbg_PrintfToDebugger(
                    "DnsDbg_Printf: file WriteFile failed: %ld\n",
                    GetLastError() );
            }

            //
            //  if wrapping debug log file
            //      - move current log to backup file
            //          <file>.first on first wrap
            //          <file>.last on subsequent wraps
            //      - reopen current file name
            //

            g_pDbgInfo->FileCurrentSize += length;

            if ( g_pDbgInfo->FileWrapSize  &&
                 g_pDbgInfo->FileWrapSize <= g_pDbgInfo->FileCurrentSize )
            {
                DnsDbg_WrapLogFile();
            }
            else if ( IS_DNSDBG_ON( FLUSH ) )
            {
                FlushFileBuffers( g_pDbgInfo->hFile );
            }
        }
    }

    DnsPrint_Unlock();

}   //  privateDnsDebugPrint



VOID
privateFormatAndPrintBuffer(
    IN      LPSTR           Format,
    IN      va_list         ArgList
    )
/*++

Routine Description:

    Arguments to formatted buffer print.

    This helper routine exists to avoid duplicating buffer
    overflow logic in DnsDbg_Printf() and DnsDbg_PrintRoutine()

    The overflow logic is required because the default stack size
    has been chopped down in whistler making is easy to generate
    stack expansion exceptions under stress.  And of course this
    means the stress guys send me these B.S. stress failures.

    Solution is to put a small buffer on the stack for perf, then
    allocate a larger buffer if the print doesn't fit into the
    stack buffer.

Arguments:

    Format -- standard C format string

    ArgList -- standard arg list

Return Value:

    None.

--*/
{
    CHAR    stackBuffer[ DNS_STACK_PRINT_BUFFER_LENGTH ];
    ULONG   bufLength;
    DWORD   lastError;
    INT     count;
    PCHAR   pprintBuffer;
    PCHAR   pheapBuffer = NULL;

    //
    //  save last error so any WriteFile() failures don't mess it up
    //

    lastError = GetLastError();

    //
    //  write formatted print buffer
    //
    //      - first try stack buffer
    //      - if fails, try heap buffer
    //      - use best, always NULL terminate
    //

    bufLength = DNS_STACK_PRINT_BUFFER_LENGTH;
    pprintBuffer = stackBuffer;

    do
    {
#if 0
        //  code for debugging print lock problems
        PBYTE   ptemp = pprintBuffer;

        if ( pDnsAtomicPrintCs )
        {
            ptemp += sprintf(
                        ptemp,
                        "(%d) ",
                        pDnsAtomicPrintCs->RecursionCount
                        );
        }

        count = _vsnprintf(
                    ptemp,
                    bufLength-1-(ptemp-pprintBuffer),
                    Format,
                    ArgList );
#else
        count = _vsnprintf(
                    pprintBuffer,
                    bufLength-1,
                    Format,
                    ArgList );
#endif
    
        pprintBuffer[ bufLength-1 ] = 0;

        if ( count > 0 || pheapBuffer )
        {
            break;
        }

        //  try again with heap buffer

        pheapBuffer = ALLOCATE_HEAP( DNS_HEAP_PRINT_BUFFER_LENGTH );
        if ( !pheapBuffer )
        {
            break;
        }
        pprintBuffer = pheapBuffer;
        bufLength = DNS_HEAP_PRINT_BUFFER_LENGTH;
    }
    while( 1 );

    va_end( ArgList );

    //  do the real print

    privateDnsDebugPrint( pprintBuffer, TRUE );

    if ( pheapBuffer )
    {
        FREE_HEAP( pheapBuffer );
    }

    //  restore LastError() if changed

    if ( lastError != GetLastError() )
    {
        SetLastError( lastError );
    }
}



VOID
DnsDbg_Printf(
    IN      LPSTR           Format,
    ...
    )
/*++

Routine Description:

    DNS debug print with printf semantics.

    May print to any of
        - debugger
        - console window
        - debug log file

Arguments:

    pContext -- dummny context to match signature of PRINT_ROUTINE function

    Format -- standard C format string

    ... -- standard arg list

Return Value:

    None.

--*/
{
    va_list arglist;

    va_start( arglist, Format );

    privateFormatAndPrintBuffer(
        Format,
        arglist );
}



VOID
DnsDbg_PrintRoutine(
    IN OUT  PPRINT_CONTEXT  pContext,
    IN      LPSTR           Format,
    ...
    )
/*++

Routine Description:

    DNS debug print with PRINT_ROUTINE semantics.

Arguments:

    pContext -- dummny context to match signature of PRINT_ROUTINE function

    Format -- standard C format string

    ... -- standard arg list

Return Value:

    None.

--*/
{
    va_list arglist;

    va_start( arglist, Format );

    privateFormatAndPrintBuffer(
        Format,
        arglist );
}



VOID
DnsDbg_Flush(
    VOID
    )
/*++

Routine Description:

    Flushes DNS debug printing to disk.

Arguments:

    None

Return Value:

    None.

--*/
{
    //
    //  need to lock to protect handle as this maybe called
    //      1) directly as this is exposed in dnslib.h
    //      2) from hard ASSERT()
    //  and a print which wraps may be ongoing
    //

    if ( g_pDbgInfo->hFile )
    {
        HANDLE  hfile;

        DnsPrint_Lock();

        if ( hfile = g_pDbgInfo->hFile )
        {
            FlushFileBuffers( hfile );
        }
        DnsPrint_Unlock();
    }
}



VOID
DnsDbg_PrintfToDebugger(
    IN      LPSTR           Format,
    ...
    )
/*++

Routine Description:

    Print to debugger.  Win95 has no DbgPrint().

Arguments:

    Format -- standard C format string

    ... -- standard arg list

Return Value:

    None.

--*/
{
    va_list arglist;
    CHAR    outputBuffer[ DNS_STACK_PRINT_BUFFER_LENGTH+1 ];
    ULONG   length;
    BOOL    ret;

    va_start( arglist, Format );

    _vsnprintf( outputBuffer, DNS_STACK_PRINT_BUFFER_LENGTH, Format, arglist );

    va_end( arglist );

    outputBuffer[ DNS_STACK_PRINT_BUFFER_LENGTH ] = 0;

    OutputDebugString( outputBuffer );
}



//
//  Debug utilities
//
//  Other debug routines are coded generically as print routines (print.c)
//  and are macroed to debug routines by choosing DnsDbg_Printf() as the
//  print function.
//

#if DBG

VOID
DnsDbg_CSEnter(
    IN      PCRITICAL_SECTION   pLock,
    IN      LPSTR               pszLockName,
    IN      LPSTR               pszFile,
    IN      INT                 LineNo
    )
{
    DnsDbg_Printf(
        "\nENTERING %s lock %p in %s, line %d.\n",
        pszLockName,
        pLock,
        pszFile,
        LineNo );
    EnterCriticalSection( pLock );
    DnsDbg_Printf(
        "\nHOLDING %s lock %p in %s, line %d.\n",
        pszLockName,
        pLock,
        pszFile,
        LineNo );
}


VOID
DnsDbg_CSLeave(
    IN      PCRITICAL_SECTION   pLock,
    IN      LPSTR               pszLockName,
    IN      LPSTR               pszFile,
    IN      INT                 LineNo
    )
{
    DnsDbg_Printf(
        "\nRELEASING %s lock %p in %s, line %d.\n",
        pszLockName,
        pLock,
        pszFile,
        LineNo );
    LeaveCriticalSection( pLock );
}

#endif

//
//  End of debug.c
//
=== C:/Users/treeman/Desktop/windows nt source code\Source\Win2K3\NT\ds\dns\dnslib\dnsaddr.c ===
/*++

Copyright (c) 2001-2002 Microsoft Corporation

Module Name:

    dnsaddr.c

Abstract:

    Domain Name System (DNS) Library

    DNS_ADDR routines.

Author:

    Jim Gilroy (jamesg)     November 2001

Revision History:

--*/


#include "local.h"




//
//  DNS_ADDR routines
//

WORD
DnsAddr_DnsType(
    IN      PDNS_ADDR       pAddr
    )
/*++

Routine Description:

    Get DNS type corresponding to DNS_ADDR.

    DCR:  DnsAddr_DnsType could be a macro
        currently a function simply because Family_X
        are in lower-pri header file;  once determine
        if Family_X available everywhere we want DNS_ADDR
        routines, then can macroize

Arguments:

    pAddr -- first addr

Return Value:

    TRUE if loopback.
    FALSE otherwise.

--*/
{
    return  Family_DnsType( DnsAddr_Family(pAddr) );
}



BOOL
DnsAddr_IsEqual(
    IN      PDNS_ADDR       pAddr1,
    IN      PDNS_ADDR       pAddr2,
    IN      DWORD           MatchFlag
    )
/*++

Routine Description:

    Test if DNS_ADDRs are equal.

Arguments:

    pAddr1 -- first addr

    pAddr2 -- second addr

    MatchFlag -- level of match

Return Value:

    TRUE if loopback.
    FALSE otherwise.

--*/
{
    if ( MatchFlag == 0 ||
         MatchFlag == DNSADDR_MATCH_ALL )
    {
        return RtlEqualMemory(
                    pAddr1,
                    pAddr2,
                    sizeof(*pAddr1) );
    }

    else if ( MatchFlag == DNSADDR_MATCH_SOCKADDR )
    {
        return RtlEqualMemory(
                    pAddr1,
                    pAddr2,
                    DNS_ADDR_MAX_SOCKADDR_LENGTH );
    }

    //
    //  DCR:  currently no separate match to include scope
    //      could dispatch to separate match routines for AF
    //      compare families, then dispatch
    //

    else if ( MatchFlag & DNSADDR_MATCH_IP )
    // else if ( MatchFlag == DNSADDR_MATCH_IP )
    {
        if ( DnsAddr_IsIp4( pAddr1 ) )
        {
            return( DnsAddr_IsIp4( pAddr2 )
                        &&
                    DnsAddr_GetIp4(pAddr1) == DnsAddr_GetIp4(pAddr2) );
        }
        else if ( DnsAddr_IsIp6( pAddr1 ) )
        {
            return( DnsAddr_IsIp6( pAddr2 )
                        &&
                    IP6_ARE_ADDRS_EQUAL(
                        DnsAddr_GetIp6Ptr(pAddr1),
                        DnsAddr_GetIp6Ptr(pAddr2) ) );
        }   
        return  FALSE;
    }
    ELSE_ASSERT_FALSE;

    return RtlEqualMemory(
                pAddr1,
                pAddr2,
                DNS_ADDR_MAX_SOCKADDR_LENGTH );
}



BOOL
DnsAddr_MatchesIp4(
    IN      PDNS_ADDR       pAddr,
    IN      IP4_ADDRESS     Ip4
    )
/*++

Routine Description:

    Test if DNS_ADDR is a given IP4.

Arguments:

    pAddr -- first addr

    Ip4 -- IP4 address

Return Value:

    TRUE if loopback.
    FALSE otherwise.

--*/
{
    return  ( DnsAddr_IsIp4( pAddr )
                &&
            Ip4 == DnsAddr_GetIp4(pAddr) );
}



BOOL
DnsAddr_MatchesIp6(
    IN      PDNS_ADDR       pAddr,
    IN      PIP6_ADDRESS    pIp6
    )
/*++

Routine Description:

    Test if DNS_ADDR is a given IP6.

Arguments:

    pAddr -- first addr

    pIp6 -- IP6 address

Return Value:

    TRUE if loopback.
    FALSE otherwise.

--*/
{
    return  ( DnsAddr_IsIp6( pAddr )
                &&
            IP6_ARE_ADDRS_EQUAL(
                DnsAddr_GetIp6Ptr(pAddr),
                pIp6 ) );
}



BOOL
DnsAddr_IsLoopback(
    IN      PDNS_ADDR       pAddr,
    IN      DWORD           Family
    )
/*++

Routine Description:

    Test if DNS_ADDR is loopback.

Arguments:

    pAddr -- addr to set with IP6 address

    Family --
        AF_INET6 to only accept if 6
        AF_INET4 to only accept if 4
        0 to extract always

Return Value:

    TRUE if loopback.
    FALSE otherwise.

--*/
{
    DWORD   addrFam = DnsAddr_Family(pAddr);

    if ( Family == 0 ||
         Family == addrFam )
    {
        if ( addrFam == AF_INET6 )
        {
            return  IP6_IS_ADDR_LOOPBACK(
                        (PIP6_ADDRESS)&pAddr->SockaddrIn6.sin6_addr );
        }
        else if ( addrFam == AF_INET )
        {
            return  (pAddr->SockaddrIn.sin_addr.s_addr == DNS_NET_ORDER_LOOPBACK);
        }
    }

    return  FALSE;
}



BOOL
DnsAddr_IsUnspec(
    IN      PDNS_ADDR       pAddr,
    IN      DWORD           Family
    )
/*++

Routine Description:

    Test if DNS_ADDR is unspecied.

Arguments:

    pAddr -- addr to test

    Family --
        AF_INET6 to only accept if 6
        AF_INET4 to only accept if 4
        0 to extract always

Return Value:

    TRUE if unspecified.
    FALSE otherwise.

--*/
{
    DWORD   family = DnsAddr_Family(pAddr);

    if ( Family == 0 ||
         Family == family )
    {
        if ( family == AF_INET6 )
        {
            return  IP6_IS_ADDR_ZERO( (PIP6_ADDRESS)&pAddr->SockaddrIn6.sin6_addr );
        }
        else if ( family == AF_INET )
        {
            return  (pAddr->SockaddrIn.sin_addr.s_addr == 0);
        }
    }

    return  FALSE;
}



BOOL
DnsAddr_IsClear(
    IN      PDNS_ADDR       pAddr
    )
/*++

Routine Description:

    Test if DNS_ADDR is clear. This is similar to unspecified but includes
    invalid addresses (where family is zero) also.

Arguments:

    pAddr -- addr test

Return Value:

    TRUE if clear.
    FALSE otherwise.

--*/
{
    DWORD   family = DnsAddr_Family( pAddr );

    if ( family == AF_INET6 )
    {
        return  IP6_IS_ADDR_ZERO( (PIP6_ADDRESS)&pAddr->SockaddrIn6.sin6_addr );
    }
    else if ( family == AF_INET )
    {
        return  pAddr->SockaddrIn.sin_addr.s_addr == 0;
    }
    else if ( family == 0 )
    {
        return  TRUE;
    }

    ASSERT( FALSE );    //  Family is invalid - not good.
    
    return FALSE;
}



BOOL
DnsAddr_IsIp6DefaultDns(
    IN      PDNS_ADDR       pAddr
    )
/*++

Routine Description:

    Test if DNS_ADDR is IP6 default DNS addr.

Arguments:

    pAddr -- addr to check

Return Value:

    TRUE if IP6 default DNS.
    FALSE otherwise.

--*/
{
    if ( !DnsAddr_IsIp6( pAddr ) )
    {
        return  FALSE;
    }
    return  IP6_IS_ADDR_DEFAULT_DNS( (PIP6_ADDRESS)&pAddr->SockaddrIn6.sin6_addr );
}




//
//  DNS_ADDR to other types
//

DWORD
DnsAddr_WriteSockaddr(
    OUT     PSOCKADDR       pSockaddr,
    IN      DWORD           SockaddrLength,
    IN      PDNS_ADDR       pAddr
    )
/*++

Routine Description:

    Write sockaddr with IP6 or IP4 address.

Arguments:

    pSockaddr -- ptr to sockaddr

    pSockaddrLength -- ptr to DWORD
        input:      holds length of pSockaddr buffer
        output:     set to sockaddr length

    pAddr -- addr

Return Value:

    Sockaddr length written.
    Zero if unable to write (bad sockaddr or inadequate length.

--*/
{
    DWORD       length;

    DNSDBG( SOCKET, (
        "DnsAddr_WriteSockaddr( %p, %u, %p )\n",
        pSockaddr,
        SockaddrLength,
        pAddr ));

    //  out length

    length = pAddr->SockaddrLength;

    //  zero

    RtlZeroMemory( pSockaddr, SockaddrLength );

    //
    //  fill in sockaddr for IP4 or IP6
    //

    if ( SockaddrLength >= length )
    {
        RtlCopyMemory(
            pSockaddr,
            & pAddr->Sockaddr,
            length );
    }
    else
    {
        length = 0;
    }

    return  length;
}



BOOL
DnsAddr_WriteIp6(
    OUT     PIP6_ADDRESS    pIp,
    IN      PDNS_ADDR       pAddr
    )
/*++

Routine Description:

    Write IP6 address.

Arguments:

    pIp -- addr to write IP6 to

    pAddr -- DNS addr

Return Value:

    TRUE if successful.
    FALSE on bad DNS_ADDR for IP6 write.

--*/
{
    WORD        family;
    DWORD       len;

    DNSDBG( SOCKET, (
        "DnsAddr_WriteIp6Addr( %p, %p )\n",
        pIp,
        pAddr ));

    //
    //  check family
    //

    if ( DnsAddr_IsIp6(pAddr) )
    {
        IP6_ADDR_COPY(
            pIp,
            (PIP6_ADDRESS) &pAddr->SockaddrIn6.sin6_addr );

        return  TRUE;
    }

    return  FALSE;
}



IP4_ADDRESS
DnsAddr_GetIp4(
    IN      PDNS_ADDR       pAddr
    )
/*++

Routine Description:

    Write IP4 address.

Arguments:

    pAddr -- DNS addr

Return Value:

    IP4 address if successful.
    INADDR_NONE if not valid IP4

--*/
{
    //
    //  check family
    //

    if ( DnsAddr_IsIp4(pAddr) )
    {
        return  (IP4_ADDRESS) pAddr->SockaddrIn.sin_addr.s_addr;
    }

    return  INADDR_NONE;
}



//
//  Build DNS_ADDRs
//

BOOL
DnsAddr_Build(
    OUT     PDNS_ADDR       pAddr,
    IN      PSOCKADDR       pSockaddr,
    IN      DWORD           Family,         OPTIONAL
    IN      DWORD           SubnetLength,
    IN      DWORD           Flags
    )
/*++

Routine Description:

    Build from sockaddr

Arguments:

    pAddr -- addr to set with IP6 address

    pSockaddr -- ptr to sockaddr

    Family --
        AF_INET6 to only extract if 6
        AF_INET4 to only extract if 4
        0 to extract always

    SubnetLength -- length to set subnet

Return Value:

    TRUE if successful.
    FALSE on bad sockaddr.

--*/
{
    WORD        family;
    DWORD       len;
    IP4_ADDRESS ip4;

    DNSDBG( TRACE, (
        "DnsAddr_Build( %p, %p, %u, %u, 08x )\n",
        pAddr,
        pSockaddr,
        Family,
        SubnetLength,
        Flags ));

    //  zero

    RtlZeroMemory(
        pAddr,
        sizeof(*pAddr) );

    //
    //  verify adequate length
    //  verify family match (if desired)
    //

    len = Sockaddr_Length( pSockaddr );

    if ( len > DNS_ADDR_MAX_SOCKADDR_LENGTH )
    {
        return  FALSE;
    }
    if ( Family  &&  Family != pSockaddr->sa_family )
    {
        return  FALSE;
    }

    //
    //  write sockaddr
    //  write length fields
    //

    RtlCopyMemory(
        & pAddr->Sockaddr,
        pSockaddr,
        len );

    pAddr->SockaddrLength = len;

    //
    //  extra fields
    //

    pAddr->SubnetLength = SubnetLength;
    pAddr->Flags        = Flags;

    return  TRUE;
}



VOID
DnsAddr_BuildFromIp4(
    OUT     PDNS_ADDR       pAddr,
    IN      IP4_ADDRESS     Ip4,
    IN      WORD            Port
    )
/*++

Routine Description:

    Build from IP4

Arguments:

    pAddr -- addr to set with IP6 address

    Ip4 -- IP4 to build

Return Value:

    None

--*/
{
    SOCKADDR_IN sockaddr;

    DNSDBG( TRACE, (
        "DnsAddr_BuildFromIp4( %p, %s, %u )\n",
        pAddr,
        IP4_STRING( Ip4 ),
        Port ));

    //  zero

    RtlZeroMemory(
        pAddr,
        sizeof(*pAddr) );

    //
    //  fill in for IP4
    //

    pAddr->SockaddrIn.sin_family        = AF_INET;
    pAddr->SockaddrIn.sin_port          = Port;
    pAddr->SockaddrIn.sin_addr.s_addr   = Ip4;

    pAddr->SockaddrLength = sizeof(SOCKADDR_IN);
}



VOID
DnsAddr_BuildFromIp6(
    OUT     PDNS_ADDR       pAddr,
    IN      PIP6_ADDRESS    pIp6,
    IN      DWORD           ScopeId,
    IN      WORD            Port
    )
/*++

Routine Description:

    Build from IP6

Arguments:

    pAddr -- addr to set with IP6 address

    pIp6 -- IP6

    ScopeId -- scope id

    Port -- port

Return Value:

    None

--*/
{
    DNSDBG( TRACE, (
        "DnsAddr_BuildFromIp6( %p, %s, %u, %u )\n",
        pAddr,
        IPADDR_STRING( pIp6 ),
        ScopeId,
        Port ));

    //
    //  DCR:  IP6 with V4 mapped
    //      could use build sockaddr from IP6, then
    //      call generic build
    //

    //  zero

    RtlZeroMemory(
        pAddr,
        sizeof(*pAddr) );

    //
    //  fill in for IP4
    //

    pAddr->SockaddrIn6.sin6_family      = AF_INET6;
    pAddr->SockaddrIn6.sin6_port        = Port;
    pAddr->SockaddrIn6.sin6_scope_id    = ScopeId;

    IP6_ADDR_COPY(
        (PIP6_ADDRESS) &pAddr->SockaddrIn6.sin6_addr,
        pIp6 );

    pAddr->SockaddrLength = sizeof(SOCKADDR_IN6);
}



VOID
DnsAddr_BuildFromAtm(
    OUT     PDNS_ADDR       pAddr,
    IN      DWORD           AtmType,
    IN      PCHAR           pAtmAddr
    )
/*++

Routine Description:

    Build from ATM address.

    Note, this is not a full SOCKADDR_ATM, see note below.
    This is a useful hack for bringing ATMA record info into
    DNS_ADDR format for transfer from DNS to RnR.

Arguments:

    pAddr -- addr to set with IP6 address

    AtmType -- ATM address type

    pAtmAddr -- ATM address;  ATM_ADDR_SIZE (20) bytes in length

Return Value:

    None

--*/
{
    ATM_ADDRESS atmAddr;

    DNSDBG( TRACE, (
        "DnsAddr_BuildFromAtm( %p, %d, %p )\n",
        pAddr,
        AtmType,
        pAtmAddr ));

    //
    //  clear
    //

    RtlZeroMemory(
        pAddr,
        sizeof(*pAddr) );

    //
    //  fill in address
    //
    //  note:  we are simply using DNS_ADDR sockaddr portion as a
    //         blob to hold ATM_ADDRESS;   this is NOT a full
    //         SOCKADDR_ATM structure which contains additional fields
    //         and is larger than what we support in DNS_ADDR
    //         
    //  DCR:  functionalize ATMA to ATM conversion
    //      not sure this num of digits is correct
    //      may have to actually parse address
    //
    //  DCR:  not filling satm_blli and satm_bhil fields
    //      see RnR CSADDR builder for possible default values
    //

    pAddr->Sockaddr.sa_family = AF_ATM;
    pAddr->SockaddrLength = sizeof(ATM_ADDRESS);

    atmAddr.AddressType = AtmType;
    atmAddr.NumofDigits = ATM_ADDR_SIZE;

    RtlCopyMemory(
        & atmAddr.Addr,
        pAtmAddr,
        ATM_ADDR_SIZE );

    RtlCopyMemory(
        & ((PSOCKADDR_ATM)pAddr)->satm_number,
        & atmAddr,
        sizeof(ATM_ADDRESS) );
}



BOOL
DnsAddr_BuildFromDnsRecord(
    OUT     PDNS_ADDR       pAddr,
    IN      PDNS_RECORD     pRR
    )
/*++

Routine Description:

    Build from DNS_RECORD

Arguments:

    pAddr -- addr to set with IP6 address

    pRR -- DNS record to use

Return Value:

    TRUE if successful.
    FALSE if unknown family.

--*/
{
    BOOL    retval = TRUE;

    switch ( pRR->wType )
    {
    case  DNS_TYPE_A:

        DnsAddr_BuildFromIp4(
            pAddr,
            pRR->Data.A.IpAddress,
            0 );
        break;

    case  DNS_TYPE_AAAA:

        DnsAddr_BuildFromIp6(
            pAddr,
            &pRR->Data.AAAA.Ip6Address,
            pRR->dwReserved,
            0 );
        break;

    case  DNS_TYPE_ATMA:

        DnsAddr_BuildFromAtm(
            pAddr,
            pRR->Data.ATMA.AddressType,
            pRR->Data.ATMA.Address );
        break;

    default:

        retval = FALSE;
        break;
    }

    return  retval;
}



BOOL
DnsAddr_BuildFromFlatAddr(
    OUT     PDNS_ADDR       pAddr,
    IN      DWORD           Family,
    IN      PCHAR           pFlatAddr,
    IN      WORD            Port
    )
/*++

Routine Description:

    Build from IP4

Arguments:

    pAddr -- addr to set with IP6 address

    Family -- address family

    pFlatAddr -- ptr to flat IP4 or IP6 address

    Port -- port

Return Value:

    TRUE if successful.
    FALSE if unknown family.

--*/
{
    //
    //  check IP4
    //

    if ( Family == AF_INET )
    {
        DnsAddr_BuildFromIp4(
            pAddr,
            * (PIP4_ADDRESS) pFlatAddr,
            Port );
    }
    else if ( Family == AF_INET6 )
    {
        DnsAddr_BuildFromIp6(
            pAddr,
            (PIP6_ADDRESS) pFlatAddr,
            0,  // scope less
            Port );
    }
    else
    {
        return  FALSE;
    }

    return  TRUE;
}



BOOL
DnsAddr_BuildMcast(
    OUT     PDNS_ADDR       pAddr,
    IN      DWORD           Family,
    IN      PWSTR           pName
    )
/*++

Routine Description:

    Build from sockaddr

Arguments:

    pAddr -- addr to set with IP6 address

    Family --
        AF_INET6 for IP6 mcast
        AF_INET for IP4 mcast

    pName -- published record name;  required for IP6 only

Return Value:

    TRUE if successful.
    FALSE on bad sockaddr.

--*/
{
    WORD        family;
    DWORD       len;
    IP4_ADDRESS ip4;

    DNSDBG( TRACE, (
        "DnsAddr_BuildMcast( %p, %d, %s )\n",
        pAddr,
        Family,
        pName ));

    //
    //  zero

    RtlZeroMemory(
        pAddr,
        sizeof(*pAddr) );

    //
    //  IP4 has single mcast address
    //

    if ( Family == AF_INET )
    {
        DnsAddr_BuildFromIp4(
            pAddr,
            MCAST_IP4_ADDRESS,
            MCAST_PORT_NET_ORDER );
    }

    //
    //  IP6 address includes name hash
    //

    else if ( Family == AF_INET6 )
    {
        IP6_ADDRESS mcastAddr;

        Ip6_McastCreate(
            & mcastAddr,
            pName );

        DnsAddr_BuildFromIp6(
            pAddr,
            & mcastAddr,
            0,      // no scope
            MCAST_PORT_NET_ORDER );

#if 0
        CHAR        label[ DNS_MAX_LABEL_BUFFER_LENGTH ];
        CHAR        downLabel[ DNS_MAX_LABEL_BUFFER_LENGTH ];
        CHAR        md5Hash[ 16 ];   // 128bit hash

        //  hash of downcased label

        Dns_CopyNameLabel(
            label,
            pName );

        Dns_DowncaseNameLabel(
            downLabel,
            label,
            0,      // null terminated
            0       // no flags
            );

        Dns_Md5Hash(
            md5Hash,
            downLabel );

        //   mcast addr
        //      - first 12 bytes are fixed
        //      - last 4 bytes are first 32bits of hash

        IP6_ADDR_COPY(
            & mcastAddr,
            & g_Ip6McastBaseAddr );

        RtlCopyMemory(
            & mcastAddr[12],
            & md5Hash,
            sizeof(DWORD) );
#endif
    }

    return  TRUE;
}



//
//  Printing\string conversion
//

PCHAR
DnsAddr_WriteIpString_A(
    OUT     PCHAR           pBuffer,
    IN      PDNS_ADDR       pAddr
    )
/*++

Routine Description:

    Write DNS_ADDR IP address to string.

    Note:  Does NOT write entire DNS_ADDR or sockaddr.

Arguments:

    pBuffer -- buffer to write to

    pAddr -- addr to write

Return Value:

    Ptr to next char in buffer (ie the terminating NULL)
    NULL on invalid address.  However, invalid address message is
        written to the buffer and it's length can be determined.

--*/
{
    if ( DnsAddr_IsIp4(pAddr) )
    {
        pBuffer += sprintf(
                    pBuffer,
                    "%s",
                    inet_ntoa( pAddr->SockaddrIn.sin_addr ) );
    }
    else if ( DnsAddr_IsIp6(pAddr) )
    {
        pBuffer = Dns_Ip6AddressToString_A(
                    pBuffer,
                    (PIP6_ADDRESS) &pAddr->SockaddrIn6.sin6_addr );
    }
    else
    {
        sprintf(
            pBuffer,
            "Invalid DNS_ADDR at %p",
            pAddr );
        pBuffer = NULL;
    }

    return  pBuffer;
}



PCHAR
DnsAddr_Ntoa(
    IN      PDNS_ADDR       pAddr
    )
/*++

Routine Description:

    Get IP address string for DNS_ADDR.

    Note:  Does NOT write entire DNS_ADDR or sockaddr.

Arguments:

    pAddr -- addr to convert

Return Value:

    Ptr to TLS blob with address string.

--*/
{
    if ( !pAddr )
    {
        return  "Null Address";
    }
    else if ( DnsAddr_IsIp4(pAddr) )
    {
        return  inet_ntoa( pAddr->SockaddrIn.sin_addr );
    }
    else if ( DnsAddr_IsIp6(pAddr) )
    {
        return  Ip6_TempNtoa( (PIP6_ADDRESS)&pAddr->SockaddrIn6.sin6_addr );
    }
    else
    {
        return  NULL;
    }
}



PSTR
DnsAddr_WriteStructString_A(
    OUT     PCHAR           pBuffer,
    IN      PDNS_ADDR       pAddr
    )
/*++

Routine Description:

    Write DNS_ADDR as string.

Arguments:

    pAddr -- ptr to IP to get string for

Return Value:

    Ptr to next char in buffer (terminating NULL).

--*/
{
    CHAR    ipBuffer[ DNS_ADDR_STRING_BUFFER_LENGTH ];
    //BOOL    finValid;

    //  write address portion

    //finValid = !DnsAddr_WriteIpString_A(
    DnsAddr_WriteIpString_A(
        ipBuffer,
        pAddr );

    //
    //  write struct including address
    //

    pBuffer += sprintf(
                pBuffer,
                "af=%d, salen=%d, [sub=%d, flag=%08x] p=%u, addr=%s",
                pAddr->Sockaddr.sa_family,
                pAddr->SockaddrLength,
                pAddr->SubnetLength,
                pAddr->Flags,
                pAddr->SockaddrIn.sin_port,
                ipBuffer );

    return  pBuffer;
}




//
//  DNS_ADDR_ARRAY routines
//

DWORD
DnsAddrArray_Sizeof(
    IN      PDNS_ADDR_ARRAY     pArray
    )
/*++

Routine Description:

    Get size in bytes of address array.

Arguments:

    pArray -- address array to find size of

Return Value:

    Size in bytes of IP array.

--*/
{
    if ( ! pArray )
    {
        return 0;
    }
    return  (pArray->AddrCount * sizeof(DNS_ADDR)) + sizeof(DNS_ADDR_ARRAY) - sizeof(DNS_ADDR);
}



#if 0
BOOL
DnsAddrArray_Probe(
    IN      PDNS_ADDR_ARRAY     pArray
    )
/*++

Routine Description:

    Touch all entries in IP array to insure valid memory.

Arguments:

    pArray -- ptr to address array

Return Value:

    TRUE if successful.
    FALSE otherwise

--*/
{
    DWORD   i;
    BOOL    result;

    if ( ! pArray )
    {
        return( TRUE );
    }
    for ( i=0; i<pArray->AddrCount; i++ )
    {
        result = IP6_IS_ADDR_LOOPBACK( &pArray->AddrArray[i] );
    }
    return( TRUE );
}
#endif


#if 0

BOOL
DnsAddrArray_ValidateSizeOf(
    IN      PDNS_ADDR_ARRAY     pArray,
    IN      DWORD               dwMemoryLength
    )
/*++

Routine Description:

    Check that size of IP array, corresponds to length of memory.

Arguments:

    pArray -- ptr to address array

    dwMemoryLength -- length of IP array memory

Return Value:

    TRUE if IP array size matches memory length
    FALSE otherwise

--*/
{
    return( DnsAddrArray_SizeOf(pArray) == dwMemoryLength );
}
#endif



VOID
DnsAddrArray_Init(
    IN OUT  PDNS_ADDR_ARRAY     pArray,
    IN      DWORD               MaxCount
    )
/*++

Routine Description:

    Init memory as DNS_ADDR_ARRAY array.

Arguments:

    pArray -- array to init

    MaxCount -- count of addresses

Return Value:

    None

--*/
{
    pArray->MaxCount = MaxCount;
    pArray->AddrCount = 0;
}



VOID
DnsAddrArray_Free(
    IN      PDNS_ADDR_ARRAY     pArray
    )
/*++

Routine Description:

    Free IP array.
    Only for arrays created through create routines below.

Arguments:

    pArray -- IP array to free.

Return Value:

    None

--*/
{
    FREE_HEAP( pArray );
}



PDNS_ADDR_ARRAY
DnsAddrArray_Create(
    IN      DWORD               MaxCount
    )
/*++

Routine Description:

    Create uninitialized address array.

Arguments:

    AddrCount -- count of addresses array will hold

Return Value:

    Ptr to uninitialized address array, if successful
    NULL on failure.

--*/
{
    PDNS_ADDR_ARRAY  parray;

    DNSDBG( IPARRAY, ( "DnsAddrArray_Create() of count %d\n", MaxCount ));

    parray = (PDNS_ADDR_ARRAY) ALLOCATE_HEAP_ZERO(
                        (MaxCount * sizeof(DNS_ADDR)) +
                        sizeof(DNS_ADDR_ARRAY) - sizeof(DNS_ADDR) );
    if ( ! parray )
    {
        return( NULL );
    }

    //
    //  initialize IP count
    //

    parray->MaxCount = MaxCount;

    DNSDBG( IPARRAY, (
        "DnsAddrArray_Create() new array (count %d) at %p\n",
        MaxCount,
        parray ));

    return( parray );
}



PDNS_ADDR_ARRAY
DnsAddrArray_CreateFromIp4Array(
    IN      PIP4_ARRAY      pArray4
    )
/*++

Routine Description:

    Create DNS_ADDR_ARRAY from IP4 array.

Arguments:

    pAddr4Array -- IP4 array

Return Value:

    Ptr to uninitialized address array, if successful
    NULL on failure.

--*/
{
    PDNS_ADDR_ARRAY parray;
    DWORD           i;

    DNSDBG( IPARRAY, (
        "DnsAddrArray_CreateFromIp4Array( %p )\n",
        pArray4 ));

    if ( ! pArray4 )
    {
        return( NULL );
    }

    //
    //  allocate the array
    //

    parray = DnsAddrArray_Create( pArray4->AddrCount );
    if ( !parray )
    {
        return  NULL;
    }

    //
    //  fill the array
    //

    for ( i=0; i<pArray4->AddrCount; i++ )
    {
        DnsAddrArray_AddIp4(
            parray,
            pArray4->AddrArray[i],
            0           // no duplicate screen
            );
    }

    DNSDBG( IPARRAY, (
        "Leave DnsAddrArray_CreateFromIp4Array() new array (count %d) at %p\n",
        parray->AddrCount,
        parray ));

    return( parray );
}



PDNS_ADDR_ARRAY
DnsAddrArray_CopyAndExpand(
    IN      PDNS_ADDR_ARRAY     pArray,
    IN      DWORD               ExpandCount,
    IN      BOOL                fDeleteExisting
    )
/*++

Routine Description:

    Create expanded copy of address array.

Arguments:

    pArray -- address array to copy

    ExpandCount -- number of IP to expand array size by

    fDeleteExisting -- TRUE to delete existing array;
        this is useful when function is used to grow existing
        IP array in place;  note that locking must be done
        by caller

        note, that if new array creation FAILS -- then old array
        is NOT deleted

Return Value:

    Ptr to IP array copy, if successful
    NULL on failure.

--*/
{
    PDNS_ADDR_ARRAY pnewArray;
    DWORD           newCount;

    //
    //  no existing array -- just create desired size
    //

    if ( ! pArray )
    {
        if ( ExpandCount )
        {
            return  DnsAddrArray_Create( ExpandCount );
        }
        return( NULL );
    }

    //
    //  create IP array of desired size
    //  then copy any existing addresses
    //

    pnewArray = DnsAddrArray_Create( pArray->AddrCount + ExpandCount );
    if ( ! pnewArray )
    {
        return( NULL );
    }

    newCount = pnewArray->MaxCount;

    RtlCopyMemory(
        (PBYTE) pnewArray,
        (PBYTE) pArray,
        DnsAddrArray_Sizeof(pArray) );

    pnewArray->MaxCount = newCount;

    //
    //  delete existing -- for "grow mode"
    //

    if ( fDeleteExisting )
    {
        FREE_HEAP( pArray );
    }

    return( pnewArray );
}



PDNS_ADDR_ARRAY
DnsAddrArray_CreateCopy(
    IN      PDNS_ADDR_ARRAY     pArray
    )
/*++

Routine Description:

    Create copy of address array.

Arguments:

    pArray -- address array to copy

Return Value:

    Ptr to address array copy, if successful
    NULL on failure.

--*/
{
    //
    //  call essentially "CopyEx" function
    //
    //  note, not macroing this because this may well become
    //      a DLL entry point
    //

    return  DnsAddrArray_CopyAndExpand(
                pArray,
                0,          // no expansion
                0           // don't delete existing array
                );
}



//
//  Tests
//

DWORD
DnsAddrArray_GetFamilyCount(
    IN      PDNS_ADDR_ARRAY     pArray,
    IN      DWORD               Family
    )
/*++

Routine Description:

    Get count of addrs of a particular family.

Arguments:

    pArray -- address array

    Family -- family to count

Return Value:

    Count of addrs of a particular family.

--*/
{
    DWORD   i;
    DWORD   count;
    WORD    arrayFamily;

    if ( !pArray )
    {
        return  0;
    }

    //  no family specified -- all addrs count

    if ( Family == 0 )
    {
        return pArray->AddrCount;
    }

    //
    //  array family is specified -- so either all or none
    //

    if ( arrayFamily = pArray->Family ) 
    {
        if ( arrayFamily == Family )
        {
            return pArray->AddrCount;
        }
        else
        {
            return 0;
        }
    }

    //
    //  family specified and array family unspecified -- must count
    //

    count = 0;

    for (i=0; i<pArray->AddrCount; i++)
    {
        if ( DnsAddr_Family( &pArray->AddrArray[i] ) == Family )
        {
            count++;
        }
    }

    return( count );
}



BOOL
DnsAddrArray_ContainsAddr(
    IN      PDNS_ADDR_ARRAY     pArray,
    IN      PDNS_ADDR           pAddr,
    IN      DWORD               MatchFlag
    )
/*++

Routine Description:

    Check if IP array contains desired address.

Arguments:

    pArray -- address array to copy

    pAddr -- IP to check for

    MatchFlag -- level of match required

Return Value:

    TRUE if address in array.
    Ptr to address array copy, if successful
    NULL on failure.

--*/
{
    DWORD i;

    if ( ! pArray )
    {
        return( FALSE );
    }
    for (i=0; i<pArray->AddrCount; i++)
    {
        if ( DnsAddr_IsEqual(
                pAddr,
                &pArray->AddrArray[i],
                MatchFlag ) )
        {
            return( TRUE );
        }
    }
    return( FALSE );
}



BOOL
DnsAddrArray_ContainsAddrEx(
    IN      PDNS_ADDR_ARRAY     pArray,
    IN      PDNS_ADDR           pAddr,
    IN      DWORD               MatchFlag,      OPTIONAL
    IN      DNSADDR_SCREEN_FUNC pScreenFunc,    OPTIONAL
    IN      PDNS_ADDR           pScreenAddr     OPTIONAL
    )
/*++

Routine Description:

    Check if IP array contains desired address.

Arguments:

    pArray -- address array to copy

    pAddr -- IP to check for

    MatchFlag -- match level for screening dups;  zero for no dup screening

    pScreenFunc -- screen function (see header def for explanation)

    pScreenAddr -- screening addr param to screen function

Return Value:

    TRUE if address in array.
    Ptr to address array copy, if successful
    NULL on failure.

--*/
{
    DWORD i;

    DNSDBG( IPARRAY, (
        "DnsAddrArray_ContainsAddrEx( %p, %p, %08x, %p, %p )\n",
        pArray,
        pAddr,
        MatchFlag,
        pScreenFunc,
        pScreenAddr ));

    if ( ! pArray )
    {
        return( FALSE );
    }

    for (i=0; i<pArray->AddrCount; i++)
    {
        if ( DnsAddr_IsEqual(
                pAddr,
                &pArray->AddrArray[i],
                MatchFlag ) )
        {
            //
            //  do advanced screening here -- if any
            //
    
            if ( !pScreenFunc ||
                 pScreenFunc(
                    &pArray->AddrArray[i],
                    pScreenAddr ) )
            {
                return  TRUE;
            }
        }
    }
    return( FALSE );
}



BOOL
DnsAddrArray_ContainsIp4(
    IN      PDNS_ADDR_ARRAY     pArray,
    IN      IP4_ADDRESS         Ip4
    )
{
    DNS_ADDR    addr;

    //  read IP into addr

    DnsAddr_BuildFromIp4(
        & addr,
        Ip4,
        0 );

    //  with only IP, only match IP

    return  DnsAddrArray_ContainsAddr(
                pArray,
                & addr,
                DNSADDR_MATCH_IP );
}


BOOL
DnsAddrArray_ContainsIp6(
    IN      PDNS_ADDR_ARRAY     pArray,
    IN      PIP6_ADDRESS        pIp6
    )
{
    DNS_ADDR    addr;

    //  read IP into addr

    DnsAddr_BuildFromIp6(
        & addr,
        pIp6,
        0,      // no scope
        0 );

    //  with only IP, only match IP

    return  DnsAddrArray_ContainsAddr(
                pArray,
                & addr,
                DNSADDR_MATCH_IP );
}



//
//  Add \ Delete operations
//

BOOL
DnsAddrArray_AddAddr(
    IN OUT  PDNS_ADDR_ARRAY     pArray,
    IN      PDNS_ADDR           pAddr,
    IN      DWORD               Family,
    IN      DWORD               MatchFlag  OPTIONAL
    )
/*++

Routine Description:

    Add IP address to IP array.

    Allowable "slot" in array, is any zero IP address.

Arguments:

    pArray -- address array to add to

    pAddr -- IP address to add to array

    Family -- optional, only add if match this family

    MatchFlag -- flags for matching if screening dups

Return Value:

    TRUE if successful.
    FALSE if array full.

--*/
{
    DWORD   count;

    //
    //  screen for existence
    //
    //  this check makes it easy to write code that does
    //  Add\Full?=>Expand loop without having to write
    //  startup existence\create code
    //  

    if ( !pArray )
    {
        return  FALSE;
    }

    //
    //  check family match
    //
    //  DCR:  error codes on DnsAddrArray_AddAddrEx()?
    //      - then can have found dup and bad family
    //      errors
    //

    if ( Family &&
         DnsAddr_Family(pAddr) != Family )
    {
        return  TRUE;
    }

    //
    //  check for duplicates
    //

    if ( MatchFlag )
    {
        if ( DnsAddrArray_ContainsAddr( pArray, pAddr, MatchFlag ) )
        {
            return  TRUE;
        }
    }

    count = pArray->AddrCount;
    if ( count >= pArray->MaxCount )
    {
        return  FALSE;
    }

    DnsAddr_Copy(
        &pArray->AddrArray[ count ],
        pAddr );

    pArray->AddrCount = ++count;
    return  TRUE;
}



BOOL
DnsAddrArray_AddSockaddr(
    IN OUT  PDNS_ADDR_ARRAY     pArray,
    IN      PSOCKADDR           pSockaddr,
    IN      DWORD               Family,
    IN      DWORD               MatchFlag
    )
/*++

Routine Description:

    Add IP address to IP array.

    Allowable "slot" in array, is any zero IP address.

Arguments:

    pArray -- address array to add to

    pAddIp -- IP address to add to array

    Family -- required family to do add;  0 for add always

    MatchFlag -- match flags if screening duplicates

Return Value:

    TRUE if successful.
    FALSE if array full.

--*/
{
    DNS_ADDR    addr;

    if ( !DnsAddr_Build(
            & addr,
            pSockaddr,
            Family,
            0,      // no subnet length info
            0       // no flags 
            ) )
    {
        return  FALSE;
    }

    return  DnsAddrArray_AddAddr(
                pArray,
                &addr,
                0,      // family screen done in build routine
                MatchFlag );
}



BOOL
DnsAddrArray_AddIp4(
    IN OUT  PDNS_ADDR_ARRAY     pArray,
    IN      IP4_ADDRESS         Ip4,
    IN      DWORD               MatchFlag
    )
/*++

Routine Description:

    Add IP4 address to IP array.

Arguments:

    pArray -- address array to add to

    Ip4 -- IP4 address to add to array

    MatchFlag -- match flags if screening duplicates

Return Value:

    TRUE if successful.
    FALSE if array full.

--*/
{
    DNS_ADDR    addr;

    DnsAddr_BuildFromIp4(
        &addr,
        Ip4,
        0 );

    return  DnsAddrArray_AddAddr(
                pArray,
                &addr,
                0,          // no family screen
                MatchFlag );
}



BOOL
DnsAddrArray_AddIp6(
    IN OUT  PDNS_ADDR_ARRAY     pArray,
    IN      PIP6_ADDRESS        pIp6,
    IN      DWORD               ScopeId,
    IN      DWORD               MatchFlag
    )
/*++

Routine Description:

    Add IP4 address to IP array.

Arguments:

    pArray -- address array to add to

    pIp6 -- IP6 address to add to array

    MatchFlag -- match flags if screening duplicates

Return Value:

    TRUE if successful.
    FALSE if array full.

--*/
{
    DNS_ADDR    addr;

    DnsAddr_BuildFromIp6(
        &addr,
        pIp6,
        ScopeId,    // no scope
        0 );

    return  DnsAddrArray_AddAddr(
                pArray,
                &addr,
                0,          // no family screen
                MatchFlag );
}



DWORD
DnsAddrArray_DeleteAddr(
    IN OUT  PDNS_ADDR_ARRAY     pArray,
    IN      PDNS_ADDR           pAddrDelete,
    IN      DWORD               MatchFlag
    )
/*++

Routine Description:

    Delete IP address from IP array.

Arguments:

    pArray -- address array to add to

    pAddrDelete -- IP address to delete from array

Return Value:

    Count of instances of IpDelete found in array.

--*/
{
    DWORD   found = 0;
    INT     i;
    INT     currentLast;

    i = currentLast = pArray->AddrCount-1;

    //
    //  check each IP for match to delete IP
    //      - go backwards through array
    //      - swap in last IP in array
    //

    while ( i >= 0 )
    {
        if ( DnsAddr_IsEqual(
                &pArray->AddrArray[i],
                pAddrDelete,
                MatchFlag ) )
        {
            DnsAddr_Copy(
                & pArray->AddrArray[i],
                & pArray->AddrArray[ currentLast ] );

            DnsAddr_Clear( &pArray->AddrArray[ currentLast ] );

            currentLast--;
            found++;
        }
        i--;
    }

    pArray->AddrCount = currentLast + 1;

    return( found );
}



DWORD
DnsAddrArray_DeleteIp4(
    IN OUT  PDNS_ADDR_ARRAY     pArray,
    IN      IP4_ADDRESS         Ip4
    )
{
    DNS_ADDR    addr;

    //  read IP into addr

    DnsAddr_BuildFromIp4(
        & addr,
        Ip4,
        0 );

    //  with only IP, only match IP

    return  DnsAddrArray_DeleteAddr(
                pArray,
                & addr,
                DNSADDR_MATCH_IP );
}


DWORD
DnsAddrArray_DeleteIp6(
    IN OUT  PDNS_ADDR_ARRAY     pArray,
    IN      PIP6_ADDRESS        Ip6
    )
{
    DNS_ADDR    addr;

    //  read IP into addr

    DnsAddr_BuildFromIp6(
        & addr,
        Ip6,
        0,      // no scope
        0 );

    //  with only IP, only match IP

    return  DnsAddrArray_DeleteAddr(
                pArray,
                & addr,
                DNSADDR_MATCH_IP );
}



//
//  Array operations
//

VOID
DnsAddrArray_Clear(
    IN OUT  PDNS_ADDR_ARRAY     pArray
    )
/*++

Routine Description:

    Clear memory in IP array.

Arguments:

    pArray -- address array to clear

Return Value:

    None.

--*/
{
    //  clear just the address list, leaving count intact

    RtlZeroMemory(
        pArray->AddrArray,
        pArray->AddrCount * sizeof(DNS_ADDR) );
}



VOID
DnsAddrArray_Reverse(
    IN OUT  PDNS_ADDR_ARRAY     pArray
    )
/*++

Routine Description:

    Reorder the list of IPs in reverse.

Arguments:

    pArray -- address array to reorder

Return Value:

    None.

--*/
{
    DNS_ADDR    tempAddr;
    DWORD       i;
    DWORD       j;

    //
    //  swap IPs working from ends to the middle
    //

    if ( pArray &&
         pArray->AddrCount )
    {
        for ( i = 0, j = pArray->AddrCount - 1;
              i < j;
              i++, j-- )
        {
            DnsAddr_Copy(
                & tempAddr,
                & pArray->AddrArray[i] );

            DnsAddr_Copy(
                & pArray->AddrArray[i],
                & pArray->AddrArray[j] );

            DnsAddr_Copy(
                & pArray->AddrArray[j],
                & tempAddr );
        }
    }
}



DNS_STATUS
DnsAddrArray_AppendArrayEx(
    IN OUT  PDNS_ADDR_ARRAY     pArray,
    IN      PDNS_ADDR_ARRAY     pAppendArray,
    IN      DWORD               AppendCount,
    IN      DWORD               Family,         OPTIONAL
    IN      DWORD               MatchFlag,      OPTIONAL
    IN      DNSADDR_SCREEN_FUNC pScreenFunc,    OPTIONAL
    IN      PDNS_ADDR           pScreenAddr     OPTIONAL
    )
/*++

Routine Description:

    Append entries from another array.

Arguments:

    pArray -- existing array

    pAppendArray -- array to append

    AppendCount -- number of addrs to append;  MAXDWORD for entire array

    Family -- family, if screening family;  zero for no screening

    MatchFlag -- match level for screening dups;  zero for no dup screening

    pScreenFunc -- screen function (see header def for explanation)

    pScreenAddr -- screening addr param to screen function

Return Value:

    NO_ERROR if successful.
    ERROR_MORE_DATA -- inadequate space in target array

--*/
{
    DWORD           i;
    DNS_STATUS      status = NO_ERROR;

    DNSDBG( IPARRAY, (
        "DnsAddrArray_AppendArrayEx( %p, %p, %d, %d, %08x, %p, %p )\n",
        pArray,
        pAppendArray,
        AppendCount,
        Family,
        MatchFlag,
        pScreenFunc,
        pScreenAddr ));

    if ( ! pAppendArray )
    {
        return( NO_ERROR );
    }

    //
    //  read from append array
    //

    for ( i=0; i<pAppendArray->AddrCount; i++ )
    {
        PDNS_ADDR   paddr = &pAppendArray->AddrArray[i];

        //
        //  do advanced screening here -- if any
        //

        if ( pScreenAddr )
        {
            if ( !pScreenFunc(
                    paddr,
                    pScreenAddr ) )
            {
                continue;
            }
        }

        //
        //  attempt the add
        //

        if ( DnsAddrArray_AddAddr(
                pArray,
                paddr,
                Family,
                MatchFlag
                ) )
        {
            if ( --AppendCount > 0 )
            {
                continue;
            }
            break;
        }
        else
        {
            //
            //  add failed
            //      - break if array is full
            //
            //  DCR:  should really only ERROR_MORE_DATA if there is more data
            //      separate error codes on _AddAddr would fix this
            //

            if ( pArray->AddrCount == pArray->MaxCount )
            {
                status = ERROR_MORE_DATA;
                break;
            }
        }
    }

    return( status );
}



DNS_STATUS
DnsAddrArray_AppendArray(
    IN OUT  PDNS_ADDR_ARRAY     pArray,
    IN      PDNS_ADDR_ARRAY     pAppendArray
    )
/*++

Routine Description:

    Create DNS_ADDR_ARRAY from IP4 array.

Arguments:

    pArray -- existing array

    pAppendArray -- array to append

Return Value:

    NO_ERROR if successful.
    ERROR_MORE_DATA -- inadequate space in target array

--*/
{
    //
    //  append with Ex version
    //
    //  note, if EX is expensive, could do simple
    //      check\RtlCopyMemory type append
    //

    return  DnsAddrArray_AppendArrayEx(
                pArray,
                pAppendArray,
                MAXDWORD,   // append entire array
                0,          // no family screen
                0,          // no dup detection
                NULL,       // no screen func
                NULL        // no screen addr
                );
}



//
//  Set operations
//

DNS_STATUS
DnsAddrArray_Diff(
    IN      PDNS_ADDR_ARRAY     pArray1,
    IN      PDNS_ADDR_ARRAY     pArray2,
    IN      DWORD               MatchFlag,  OPTIONAL
    OUT     PDNS_ADDR_ARRAY*    ppOnlyIn1,
    OUT     PDNS_ADDR_ARRAY*    ppOnlyIn2,
    OUT     PDNS_ADDR_ARRAY*    ppIntersect
    )
/*++

Routine Description:

    Computes differences and intersection of two IP arrays.

    Out arrays are allocated with DnsAddrArray_Alloc(), caller must free with DnsAddrArray_Free()

Arguments:

    pArray1 -- IP array

    pArray2 -- IP array

    MatchFlag -- flags for determining match

    ppOnlyIn1 -- addr to recv IP array of addresses only in array 1 (not in array2)

    ppOnlyIn2 -- addr to recv IP array of addresses only in array 2 (not in array1)

    ppIntersect -- addr to recv IP array of intersection addresses

Return Value:

    ERROR_SUCCESS if successful.
    DNS_ERROR_NO_MEMORY if unable to allocate memory for IP arrays.

--*/
{
    DWORD           j;
    PDNS_ADDR       paddr;
    PDNS_ADDR_ARRAY intersectArray = NULL;
    PDNS_ADDR_ARRAY only1Array = NULL;
    PDNS_ADDR_ARRAY only2Array = NULL;

    //
    //  create result IP arrays
    //

    if ( ppIntersect )
    {                                 
        intersectArray = DnsAddrArray_CreateCopy( pArray1 );
        if ( !intersectArray )
        {
            goto NoMem;
        }
        *ppIntersect = intersectArray;
    }
    if ( ppOnlyIn1 )
    {
        only1Array = DnsAddrArray_CreateCopy( pArray1 );
        if ( !only1Array )
        {
            goto NoMem;
        }
        *ppOnlyIn1 = only1Array;
    }
    if ( ppOnlyIn2 )
    {
        only2Array = DnsAddrArray_CreateCopy( pArray2 );
        if ( !only2Array )
        {
            goto NoMem;
        }
        *ppOnlyIn2 = only2Array;
    }

    //
    //  clean the arrays
    //

    for ( j=0;   j< pArray1->AddrCount;   j++ )
    {
        paddr = &pArray1->AddrArray[j];

        //  if IP in both arrays, delete from "only" arrays

        if ( DnsAddrArray_ContainsAddr( pArray2, paddr, MatchFlag ) )
        {
            if ( only1Array )
            {
                DnsAddrArray_DeleteAddr( only1Array, paddr, MatchFlag );
            }
            if ( only2Array )
            {
                DnsAddrArray_DeleteAddr( only2Array, paddr, MatchFlag );
            }
        }

        //  if IP not in both arrays, delete from intersection
        //      note intersection started as IpArray1

        else if ( intersectArray )
        {
            DnsAddrArray_DeleteAddr(
                intersectArray,
                paddr,
                MatchFlag );
        }
    }

    return( ERROR_SUCCESS );

NoMem:

    if ( intersectArray )
    {
        FREE_HEAP( intersectArray );
    }
    if ( only1Array )
    {
        FREE_HEAP( only1Array );
    }
    if ( only2Array )
    {
        FREE_HEAP( only2Array );
    }
    if ( ppIntersect )
    {
        *ppIntersect = NULL;
    }
    if ( ppOnlyIn1 )
    {
        *ppOnlyIn1 = NULL;
    }
    if ( ppOnlyIn2 )
    {
        *ppOnlyIn2 = NULL;
    }
    return( DNS_ERROR_NO_MEMORY );
}



BOOL
DnsAddrArray_IsIntersection(
    IN      PDNS_ADDR_ARRAY     pArray1,
    IN      PDNS_ADDR_ARRAY     pArray2,
    IN      DWORD               MatchFlag  OPTIONAL
    )
/*++

Routine Description:

    Determine if there's intersection of two IP arrays.

Arguments:

    pArray1 -- IP array

    pArray2 -- IP array

    MatchFlag -- flags for determining match


Return Value:

    TRUE if intersection.
    FALSE if no intersection or empty or NULL array.

--*/
{
    DWORD   count;
    DWORD   j;

    //
    //  protect against NULL
    //  this is called from the server on potentially changing (reconfigurable)
    //      IP array pointers;  this provides cheaper protection than
    //      worrying about locking
    //

    if ( !pArray1 || !pArray2 )
    {
        return( FALSE );
    }

    //
    //  same array
    //

    if ( pArray1 == pArray2 )
    {
        return( TRUE );
    }

    //
    //  test that at least one IP in array 1 is in array 2
    //

    count = pArray1->AddrCount;

    for ( j=0;  j < count;  j++ )
    {
        if ( DnsAddrArray_ContainsAddr(
                pArray2,
                &pArray1->AddrArray[j],
                MatchFlag ) )
        {
            return( TRUE );
        }
    }

    //  no intersection

    return( FALSE );
}



BOOL
DnsAddrArray_IsEqual(
    IN      PDNS_ADDR_ARRAY     pArray1,
    IN      PDNS_ADDR_ARRAY     pArray2,
    IN      DWORD               MatchFlag
    )
/*++

Routine Description:

    Determines if IP arrays are equal.

Arguments:

    pArray1 -- IP array

    pArray2 -- IP array

    MatchFlag -- level of match

Return Value:

    TRUE if arrays equal.
    FALSE otherwise.

--*/
{
    DWORD   j;
    DWORD   count;

    //
    //  same array?  or missing array?
    //

    if ( pArray1 == pArray2 )
    {
        return( TRUE );
    }
    if ( !pArray1 || !pArray2 )
    {
        return( FALSE );
    }

    //
    //  arrays the same length?
    //

    count = pArray1->AddrCount;

    if ( count != pArray2->AddrCount )
    {
        return( FALSE );
    }

    //
    //  test that each IP in array 1 is in array 2
    //
    //  test that each IP in array 2 is in array 1
    //      - do second test in case of duplicates
    //      that fool equal-lengths check
    //

    for ( j=0;  j < count;  j++ )
    {
        if ( !DnsAddrArray_ContainsAddr(
                pArray2,
                &pArray1->AddrArray[j],
                MatchFlag ) )
        {
            return( FALSE );
        }
    }
    for ( j=0;  j < count;  j++ )
    {
        if ( !DnsAddrArray_ContainsAddr(
                pArray1,
                &pArray2->AddrArray[j],
                MatchFlag ) )
        {
            return( FALSE );
        }
    }

    //  equal arrays

    return( TRUE );
}



DNS_STATUS
DnsAddrArray_Union(
    IN      PDNS_ADDR_ARRAY     pArray1,
    IN      PDNS_ADDR_ARRAY     pArray2,
    OUT     PDNS_ADDR_ARRAY*    ppUnion
    )
/*++

Routine Description:

    Computes the union of two IP arrays.

    Out array is allocated with DnsAddrArray_Alloc(), caller must free with DnsAddrArray_Free()

Arguments:

    pArray1 -- IP array

    pArray2 -- IP array

    ppUnion -- addr to recv IP array of addresses in array 1 and in array2

Return Value:

    ERROR_SUCCESS if successful.
    DNS_ERROR_NO_MEMORY if unable to allocate memory for IP array.

--*/
{
    PDNS_ADDR_ARRAY punionArray = NULL;
    DWORD           j;

    //
    //  create result IP arrays
    //

    if ( !ppUnion )
    {
        return( ERROR_INVALID_PARAMETER );
    }

    punionArray = DnsAddrArray_Create(
                        pArray1->AddrCount +
                        pArray2->AddrCount );
    if ( !punionArray )
    {
        goto NoMem;
    }
    *ppUnion = punionArray;


    //
    //  create union from arrays
    //

    for ( j = 0; j < pArray1->AddrCount; j++ )
    {
        DnsAddrArray_AddAddr(
            punionArray,
            & pArray1->AddrArray[j],
            0,                  // no family screen
            DNSADDR_MATCH_ALL   // screen out dups
            );
    }

    for ( j = 0; j < pArray2->AddrCount; j++ )
    {
        DnsAddrArray_AddAddr(
            punionArray,
            & pArray2->AddrArray[j],
            0,                  // no family screen
            DNSADDR_MATCH_ALL   // screen out dups
            );
    }
    return( ERROR_SUCCESS );

NoMem:

    if ( punionArray )
    {
        FREE_HEAP( punionArray );
        *ppUnion = NULL;
    }
    return( DNS_ERROR_NO_MEMORY );
}



BOOL
DnsAddrArray_CheckAndMakeSubset(
    IN OUT  PDNS_ADDR_ARRAY     pArraySub,
    IN      PDNS_ADDR_ARRAY     pArraySuper
    )
/*++

Routine Description:

    Clear entries from IP array until it is subset of another IP array.

Arguments:

    pArraySub -- addr array to make into subset

    pArraySuper -- addr array superset

Return Value:

    TRUE if pArraySub is already subset.
    FALSE if needed to nix entries to make IP array a subset.

--*/
{
    DWORD   i;
    DWORD   newCount;

    //
    //  check each entry in subset IP array,
    //  if not in superset IP array, eliminate it
    //

    newCount = pArraySub->AddrCount;

    for (i=0; i < newCount; i++)
    {
        if ( ! DnsAddrArray_ContainsAddr(
                    pArraySuper,
                    & pArraySub->AddrArray[i],
                    DNSADDR_MATCH_ALL ) )
        {
            //  remove this IP entry and replace with
            //  last IP entry in array

            newCount--;
            if ( i >= newCount )
            {
                break;
            }
            DnsAddr_Copy(
                & pArraySub->AddrArray[i],
                & pArraySub->AddrArray[newCount] );
        }
    }

    //  if eliminated entries, reset array count

    if ( newCount < pArraySub->AddrCount )
    {
        pArraySub->AddrCount = newCount;
        return( FALSE );
    }
    return( TRUE );
}



//
//  Special case initializations
//

VOID
DnsAddrArray_InitSingleWithAddr(
    IN OUT  PDNS_ADDR_ARRAY     pArray,
    IN      PDNS_ADDR           pAddr
    )
/*++

Routine Description:

    Init array to contain single address.

    This is for single address passing in array -- usually stack array.

    Note, that this assumes uninitialized array unlike DnsAddrArray_AddIp()
    and creates single IP array.

Arguments:

    pArray -- array, at least of length 1

    pAddr -- ptr to DNS address

Return Value:

    None

--*/
{
    pArray->AddrCount = 1;
    pArray->MaxCount = 1;

    DnsAddr_Copy(
        &pArray->AddrArray[0],
        pAddr );
}



VOID
DnsAddrArray_InitSingleWithIp6(
    IN OUT  PDNS_ADDR_ARRAY     pArray,
    IN      PIP6_ADDRESS        pIp6
    )
/*++

Routine Description:

    Init array to contain single IP6 address.

    This is for single address passing in array -- usually stack array.

    Note, that this assumes uninitialized array unlike DnsAddrArray_AddIp()
    and creates single IP array.

Arguments:

    pArray -- array, at least of length 1

    pIp6 -- IP6 address

Return Value:

    None

--*/
{
    pArray->AddrCount = 1;
    pArray->MaxCount = 1;

    DnsAddr_BuildFromIp6(
        &pArray->AddrArray[0],
        pIp6,
        0,      // no scope
        0       // no port info
        );
}



VOID
DnsAddrArray_InitSingleWithIp4(
    IN OUT  PDNS_ADDR_ARRAY     pArray,
    IN      IP4_ADDRESS         Ip4Addr
    )
/*++

Routine Description:

    Init IP array to contain single IP4 address.

    This is for single address passing in array -- usually stack array.

    Note, that this assumes uninitialized array unlike DnsAddrArray_AddIp()
    and creates single IP array.

Arguments:

    pArray -- DNS_ADDR_ARRAY, at least of length 1

    Ip4Addr -- IP4 address

Return Value:

    None

--*/
{
    pArray->AddrCount = 1;
    pArray->MaxCount = 1;

    DnsAddr_BuildFromIp4(
        &pArray->AddrArray[0],
        Ip4Addr,
        0       // no port info
        );
}



DWORD
DnsAddrArray_InitSingleWithSockaddr(
    IN OUT  PDNS_ADDR_ARRAY     pArray,
    IN      PSOCKADDR           pSockAddr
    )
/*++

Routine Description:

    Init IP array to contain single address.

    This is for single address passing in array -- usually stack array.

    Note, that this assumes uninitialized array unlike DnsAddrArray_AddIp()
    and creates single IP array.

Arguments:

    pArray -- DNS_ADDR_ARRAY, at least of length 1

    pSockaddr -- ptr to sockaddr

Return Value:

    Family of sockaddr (AF_INET or AF_INET6) if successful.
    Zero on error.

--*/
{
    pArray->AddrCount = 1;
    pArray->MaxCount = 1;

    return  DnsAddr_Build(
                &pArray->AddrArray[0],
                pSockAddr,
                0,      // any family
                0,      // no subnet length info
                0       // no flags 
                );
}



//
//  Write other types
//

PIP4_ARRAY
DnsAddrArray_CreateIp4Array(
    IN      PDNS_ADDR_ARRAY     pArray
    )
/*++

Routine Description:

    Create IP4 array from address array.

Arguments:

    pArray -- array to make into IP4 array.

Return Value:

    Ptr to IP4_ARRAY with all IP4 addrs in input array.
    NULL if no IP4 in array.
    NULL on failure.

--*/
{
    PIP4_ARRAY  parray4 = NULL;
    DWORD       i;
    DWORD       count4 = 0;

    DNSDBG( IPARRAY, (
        "DnsAddrArray_CreateIp4Array( %p )\n",
        pArray ));

    if ( ! pArray )
    {
        goto Done;
    }

    //
    //  count IP4
    //

    count4 = DnsAddrArray_GetFamilyCount( pArray, AF_INET );

    //
    //  allocate the array
    //

    parray4 = Dns_CreateIpArray( count4 );
    if ( !parray4 )
    {
        goto Done;
    }

    //
    //  fill the array
    //

    for ( i=0; i<pArray->AddrCount; i++ )
    {
        IP4_ADDRESS ip4;

        ip4 = DnsAddr_GetIp4( &pArray->AddrArray[i] );
        if ( ip4 != BAD_IP4_ADDR )
        {
            Dns_AddIpToIpArray(
                parray4,
                ip4 );
        }
    }

    //
    //  reset to eliminate zero's which may be left by duplicate entries
    //
    //  note, this does whack zeros, but that happens in Dns_AddIpToIpArray()
    //  above also, as zero's are taken to be "empty slots" in array;
    //  this is an artifact of the IP4_ARRAY being used both as a fixed
    //  object (where any value would be ok) and dynamically (where the
    //  zeros are treated as empty, because we don't have independent size
    //  and length fields)
    //  

    Dns_CleanIpArray( parray4, DNS_IPARRAY_CLEAN_ZERO );


Done:

    DNSDBG( IPARRAY, (
        "Leave DnsAddrArray_CreateIp4Array() => %p\n"
        "\tIP4 count %d\n"
        "\tnew array count %d\n",
        parray4,
        parray4 ? parray4->AddrCount : 0,
        count4 ));

    return( parray4 );
}



DWORD
DnsAddrArray_NetworkMatchIp4(
    IN      PDNS_ADDR_ARRAY     pArray,
    IN      IP4_ADDRESS         IpAddr,
    OUT     PDNS_ADDR *         ppAddr
    )
/*++

Routine Description:

    Check through array for best network match.

Arguments:

    pArray -- existing array

    IpAddr -- IP4 addr to check

    ppAddr -- addr to receive ptr to best match element

Return Value:

    DNSADDR_NETMATCH_NONE
    DNSADDR_NETMATCH_CLASSA
    DNSADDR_NETMATCH_CLASSB
    DNSADDR_NETMATCH_CLASSC
    DNSADDR_NETMATCH_SUBNET

--*/
{
    DWORD           i;
    IP4_ADDRESS     classMask;
    DWORD           fmatch = DNSADDR_NETMATCH_NONE;
    PDNS_ADDR       paddrMatch = NULL;


    DNSDBG( IPARRAY, (
        "DnsAddrArray_NetworkMatchIp( %p, %s, %p )\n",
        pArray,
        IP4_STRING( IpAddr ),
        ppAddr ));

    if ( ! pArray )
    {
        goto Done;
    }

    //
    //  DCR:  subnet matching improvements
    //      - use length throughout
    //      - return bits matched
    //      - 32 for identical addrs
    //      - 31 for subnet match
    //      - 0 no match in class
    //
    //      separate matching function with optional
    //      IN param of class subnet length of IP
    //


    //
    //  get class subnet mask
    //

    classMask = Dns_GetNetworkMask( IpAddr );

    //
    //  check each element in array
    //

    for ( i=0; i<pArray->AddrCount; i++ )
    {
        DWORD           classMatchLevel;
        IP4_ADDRESS     subnet;
        IP4_ADDRESS     ip;
        PDNS_ADDR       paddr = &pArray->AddrArray[i];

        ip = DnsAddr_GetIp4( paddr );
        if ( ip == BAD_IP4_ADDR )
        {
            continue;
        }

        //  xor to nix any common network bits

        ip = ip ^ IpAddr;

        //  check subnet match (if subnet given)
        //  note shift bits up, as in network order

        subnet = (IP4_ADDRESS)(-1);

        if ( paddr->SubnetLength )
        {
            subnet >>= (32 - paddr->SubnetLength);
    
            if ( (ip & subnet) == 0 )
            {
                fmatch = DNSADDR_NETMATCH_SUBNET;
                paddrMatch = paddr;
                break;
            }
        }

        //
        //  try class match
        //      - stop if have previous match at this level
        //      - otherwise always do class C
        //      - stop if reach class subnet for IpAddr
        //      example, we do NOT return NETMATCH_CLASSB for
        //      a class C address -- it's meaningless
        //

        classMatchLevel = DNSADDR_NETMATCH_CLASSC;
        subnet = SUBNET_MASK_CLASSC;

        while ( fmatch < classMatchLevel )
        {
            if ( (ip & subnet) == 0 )
            {
                fmatch = classMatchLevel;
                paddrMatch = paddr;
                break;
            }

            classMatchLevel--;
            subnet >>= 8;
            if ( classMask > subnet )
            {
                break;
            }
        }
    }

Done:

    //
    //  set return addr
    //

    if ( ppAddr )
    {
        *ppAddr = paddrMatch;
    }

    DNSDBG( IPARRAY, (
        "Leave DnsAddrArray_NetworkMatchIp( %p, %s, %p )\n"
        "\tMatch Level  = %d\n"
        "\tMatch Addr   = %s (subnet len %d)\n",
        pArray,
        IP4_STRING( IpAddr ),
        ppAddr,
        paddrMatch ? DNSADDR_STRING(paddrMatch) : NULL,
        paddrMatch ? paddrMatch->SubnetLength : 0 ));

    return( fmatch );
}

//
//  End dnsaddr.c
//
=== C:/Users/treeman/Desktop/windows nt source code\Source\Win2K3\NT\ds\dns\dnslib\addr.c ===
/*++

Copyright (c) 2000-2001  Microsoft Corporation

Module Name:

    addr.c

Abstract:

    Domain Name System (DNS) Library

    IP address routines

Author:

    Jim Gilroy (jamesg)     June 2000

Revision History:

--*/


#include "local.h"
#include "ws2atm.h"     // ATM addressing


//
//  Address info table
//

FAMILY_INFO AddrFamilyTable[] =
{
    AF_INET,
        DNS_TYPE_A,
        sizeof(IP4_ADDRESS),
        sizeof(SOCKADDR_IN),
        (DWORD) FIELD_OFFSET( SOCKADDR_IN, sin_addr ),

    AF_INET6,
        DNS_TYPE_AAAA,
        sizeof(IP6_ADDRESS),
        sizeof(SOCKADDR_IN6),
        (DWORD) FIELD_OFFSET( SOCKADDR_IN6, sin6_addr ),

    AF_ATM,
        DNS_TYPE_ATMA,
        sizeof(ATM_ADDRESS),
        sizeof(SOCKADDR_ATM),
        sizeof(DWORD),
        (DWORD) FIELD_OFFSET( SOCKADDR_ATM, satm_number ),
};



PFAMILY_INFO
FamilyInfo_GetForFamily(
    IN      DWORD           Family
    )
/*++

Routine Description:

    Get address family info for family.

Arguments:

    Family -- address family

Return Value:

    Ptr to address family info for family.
    NULL if family is unknown.

--*/
{
    PFAMILY_INFO    pinfo = NULL;

    //  switch on type

    if ( Family == AF_INET )
    {
        pinfo = pFamilyInfoIp4;
    }
    else if ( Family == AF_INET6 )
    {
        pinfo = pFamilyInfoIp6;
    }
    else if ( Family == AF_ATM )
    {
        pinfo = pFamilyInfoAtm;
    }

    return  pinfo;
}



DWORD
Family_SockaddrLength(
    IN      WORD            Family
    )
/*++

Routine Description:

    Extract info for family.

Arguments:

    Family -- address family

Return Value:

    Length of sockaddr for address family.
    Zero if unknown family.

--*/
{
    PFAMILY_INFO    pinfo;

    //  get family -- extract info

    pinfo = FamilyInfo_GetForFamily( Family );
    if ( pinfo )
    {
        return  pinfo->LengthSockaddr;
    }
    return  0;
}



WORD
Family_DnsType(
    IN      WORD            Family
    )
/*++

Routine Description:

    Extract info for family.

Arguments:

    Family -- address family

Return Value:

    Length of sockaddr for address family.
    Zero if unknown family.

--*/
{
    PFAMILY_INFO    pinfo;

    //  get family -- extract info

    pinfo = FamilyInfo_GetForFamily( Family );
    if ( pinfo )
    {
        return  pinfo->DnsType;
    }
    return  0;
}



DWORD
Family_GetFromDnsType(
    IN      WORD            wType
    )
/*++

Routine Description:

    Get address family for a given DNS type.

Arguments:

    wType -- DNS type

Return Value:

    Address family if found.
    Zero if wType doesn't map to known family.

--*/
{
    //  switch on type

    if ( wType == DNS_TYPE_A )
    {
        return  AF_INET;
    }
    if ( wType == DNS_TYPE_AAAA )
    {
        return  AF_INET6;
    }
    if ( wType == DNS_TYPE_ATMA )
    {
        return  AF_ATM;
    }
    return  0;
}



//
//  Sockaddr
//

DWORD
Sockaddr_Length(
    IN      PSOCKADDR       pSockaddr
    )
/*++

Routine Description:

    Get length of sockaddr.

Arguments:

    pSockaddr -- sockaddr buffer to recv address

Return Value:

    Length of sockaddr for address family.
    Zero if unknown family.

--*/
{
    return  Family_SockaddrLength( pSockaddr->sa_family );
}



IP6_ADDRESS
Sockaddr_GetIp6(
    IN      PSOCKADDR       pSockaddr
    )
/*++

Routine Description:

    Get IP6 address from sockaddr.

    If IP4 sockaddr, IP6 address is mapped.

Arguments:

    pSockaddr -- any kind of sockaddr
        must have actual length for sockaddr family

Return Value:

    IP6 address corresponding to sockaddr.
    If IP4 sockaddr it's IP4_MAPPED address.
    If not IP4 or IP6 sockaddr IP6 addresss is zero.

--*/
{
    IP6_ADDRESS ip6;

    //
    //  switch on family
    //      - IP6 gets copy
    //      - IP4 gets IP4_MAPPED
    //      - bogus gets zero
    //

    switch ( pSockaddr->sa_family )
    {
    case AF_INET:

        IP6_SET_ADDR_V4MAPPED(
            & ip6,
            ((PSOCKADDR_IN)pSockaddr)->sin_addr.s_addr );
        break;

    case AF_INET6:

        RtlCopyMemory(
            &ip6,
            & ((PSOCKADDR_IN6)pSockaddr)->sin6_addr,
            sizeof(IP6_ADDRESS) );
        break;

    default:

        RtlZeroMemory(
            &ip6,
            sizeof(IP6_ADDRESS) );
        break;
    }

    return  ip6;
}



VOID
Sockaddr_BuildFromIp6(
    OUT     PSOCKADDR       pSockaddr,
    IN      IP6_ADDRESS     Ip6Addr,
    IN      WORD            Port
    )
/*++

Routine Description:

    Write IP6 address (straight 6 or v4 mapped) to sockaddr.

Arguments:

    pSockaddr -- ptr to sockaddr to write to;
        must be at least size of SOCKADDR_IN6

    Ip6Addr -- IP6 addresss being written

    Port -- port in net byte order

Return Value:

    None

--*/
{
    //  zero

    RtlZeroMemory(
        pSockaddr,
        sizeof(SOCKADDR_IN6) );
        
    //
    //  determine whether IP6 or IP4
    //

    if ( IP6_IS_ADDR_V4MAPPED( &Ip6Addr ) )
    {
        PSOCKADDR_IN    psa = (PSOCKADDR_IN) pSockaddr;

        psa->sin_family = AF_INET;
        psa->sin_port   = Port;

        psa->sin_addr.s_addr = IP6_GET_V4_ADDR( &Ip6Addr );
    }
    else    // IP6
    {
        PSOCKADDR_IN6   psa = (PSOCKADDR_IN6) pSockaddr;

        psa->sin6_family = AF_INET6;
        psa->sin6_port   = Port;

        RtlCopyMemory(
            &psa->sin6_addr,
            &Ip6Addr,
            sizeof(IP6_ADDRESS) );
    }
}



DNS_STATUS
Sockaddr_BuildFromFlatAddr(
    OUT     PSOCKADDR       pSockaddr,
    IN OUT  PDWORD          pSockaddrLength,
    IN      BOOL            fClearSockaddr,
    IN      PBYTE           pAddr,
    IN      DWORD           AddrLength,
    IN      DWORD           AddrFamily
    )
/*++

Routine Description:

    Convert address in ptr\family\length to sockaddr.

Arguments:

    pSockaddr -- sockaddr buffer to recv address

    pSockaddrLength -- addr with length of sockaddr buffer
        receives the actual sockaddr length

    fClearSockaddr -- start with zero buffer

    pAddr -- ptr to address

    AddrLength -- address length

    AddrFamily -- address family (AF_INET, AF_INET6)

Return Value:

    NO_ERROR if successful.
    ERROR_INSUFFICIENT_BUFFER -- if buffer too small
    WSAEAFNOSUPPORT -- if invalid family

--*/
{
    PFAMILY_INFO    pinfo;
    DWORD           lengthIn = *pSockaddrLength;
    DWORD           lengthSockAddr;


    //  clear to start

    if ( fClearSockaddr )
    {
        RtlZeroMemory(
            pSockaddr,
            lengthIn );
    }

    //  switch on type

    if ( AddrFamily == AF_INET )
    {
        pinfo = pFamilyInfoIp4;
    }
    else if ( AddrFamily == AF_INET6 )
    {
        pinfo = pFamilyInfoIp6;
    }
    else if ( AddrFamily == AF_ATM )
    {
        pinfo = pFamilyInfoAtm;
    }
    else
    {
        return  WSAEAFNOSUPPORT;
    }

    //  validate lengths

    if ( AddrLength != pinfo->LengthAddr )
    {
        return  DNS_ERROR_INVALID_IP_ADDRESS;
    }

    lengthSockAddr = pinfo->LengthSockaddr;
    *pSockaddrLength = lengthSockAddr;

    if ( lengthIn < lengthSockAddr )
    {
        return  ERROR_INSUFFICIENT_BUFFER;
    }

    //
    //  fill out sockaddr
    //      - set family
    //      - copy address to sockaddr
    //      - return length was set above
    //

    RtlCopyMemory(
        (PBYTE)pSockaddr + pinfo->OffsetToAddrInSockaddr,
        pAddr,
        AddrLength );

    pSockaddr->sa_family = (WORD)AddrFamily;

    return  NO_ERROR;
}


//
//  End addr.c
//
=== C:/Users/treeman/Desktop/windows nt source code\Source\Win2K3\NT\ds\dns\dnslib\dnslibp.h ===
/*++

Copyright (c) 1996-2001  Microsoft Corporation

Module Name:

    dnslibp.h

Abstract:

    Domain Name System (DNS) Library

    Private DNS Library Routines

Author:

    Jim Gilroy (jamesg)     December 7, 1996

Revision History:

--*/


#ifndef _DNSLIBP_INCLUDED_
#define _DNSLIBP_INCLUDED_

#include <winsock2.h>
#include <ws2tcpip.h>
#include <ws2atm.h>
#include <windns.h>
#include <dnsapi.h>
#include <dnslib.h>
#include <dnsip.h>


#ifdef __cplusplus
extern "C"
{
#endif  // __cplusplus


//  headers are screwed up
//  neither ntdef.h nor winnt.h brings in complete set, so depending
//  on whether you include nt.h or not you end up with different set

#define MINCHAR     0x80
#define MAXCHAR     0x7f
#define MINSHORT    0x8000
#define MAXSHORT    0x7fff
#define MINLONG     0x80000000
#define MAXLONG     0x7fffffff
#define MAXBYTE     0xff
#define MAXUCHAR    0xff
#define MAXWORD     0xffff
#define MAXUSHORT   0xffff
#define MAXDWORD    0xffffffff
#define MAXULONG    0xffffffff

//
//  Handy bad ptr
//

#define DNS_BAD_PTR     ((PVOID)(-1))

//
//  "Wire" char set
//
//  Explicitly create wire char set in case the ACE format
//  wins out.
//

#define DnsCharSetWire  DnsCharSetUtf8


//
//  DCR:  move these to windns.h
//

#define DNS_IP4_REVERSE_DOMAIN_STRING_W (L"in-addr.arpa.")
#define DNS_IP6_REVERSE_DOMAIN_STRING_W (L"ip6.arpa.")




//
//  Private DNS_RECORD Flag field structure definition and macros
//

typedef struct _PrivateRecordFlags
{
    DWORD   Section     : 2;
    DWORD   Delete      : 1;
    DWORD   CharSet     : 2;

    DWORD   Cached      : 1;        // or maybe a "Source" field
    DWORD   HostsFile   : 1;
    DWORD   Cluster     : 1;

    DWORD   Unused      : 3;
    DWORD   Matched     : 1;
    DWORD   FreeData    : 1;
    DWORD   FreeOwner   : 1;

    DWORD   Reserved    : 18;
}
PRIV_RR_FLAGS, *PPRIV_RR_FLAGS;


#define RRFLAGS( pRecord )          ((PPRIV_RR_FLAGS)&pRecord->Flags.DW)

//  Defined in dnslib.h  too late to pull now
//#define FLAG_Section( pRecord )     (RRFLAGS( pRecord )->Section)
//#define FLAG_Delete( pRecord )      (RRFLAGS( pRecord )->Delete)
//#define FLAG_CharSet( pRecord )     (RRFLAGS( pRecord )->CharSet)
//#define FLAG_FreeData( pRecord )    (RRFLAGS( pRecord )->FreeData)
//#define FLAG_FreeOwner( pRecord )   (RRFLAGS( pRecord )->FreeOwner)
//#define FLAG_Matched( pRecord )     (RRFLAGS( pRecord )->Matched)

//#define FLAG_Cached( pRecord )      (RRFLAGS( pRecord )->Cached)
#define FLAG_HostsFile( pRecord )   (RRFLAGS( pRecord )->HostsFile)
#define FLAG_Cluster( pRecord )     (RRFLAGS( pRecord )->Cluster)

//#define SET_FREE_OWNER(pRR)         (FLAG_FreeOwner(pRR) = TRUE)
//#define SET_FREE_DATA(pRR)          (FLAG_FreeData(pRR) = TRUE)
//#define SET_RR_MATCHED(pRR)         (FLAG_Matched(pRR) = TRUE)
#define SET_RR_HOSTS_FILE(pRR)      (FLAG_HostsFile(pRR) = TRUE)
#define SET_RR_CLUSTER(pRR)         (FLAG_Cluster(pRR) = TRUE)

//#define CLEAR_FREE_OWNER(pRR)       (FLAG_FreeOwner(pRR) = FALSE)
//#define CLEAR_FREE_DATA(pRR)        (FLAG_FreeData(pRR) = FALSE)
//#define CLEAR_RR_MATCHED(pRR)       (FLAG_Matched(pRR) = FALSE)

#define CLEAR_RR_HOSTS_FILE(pRR)    (FLAG_HostsFile(pRR) = FALSE)

//#define IS_FREE_OWNER(pRR)          (FLAG_FreeOwner(pRR))
//#define IS_FREE_DATA(pRR)           (FLAG_FreeData(pRR))
//#define IS_RR_MATCHED(pRR)          (FLAG_Matched(pRR))
#define IS_HOSTS_FILE_RR(pRR)       (FLAG_HostsFile(pRR))
#define IS_CLUSTER_RR(pRR)          (FLAG_Cluster(pRR))

//#define IS_ANSWER_RR(pRR)           (FLAG_Section(pRR) == DNSREC_ANSWER)
//#define IS_AUTHORITY_RR(pRR)        (FLAG_Section(pRR) == DNSREC_AUTHORITY)
//#define IS_ADDITIONAL_RR(pRR)       (FLAG_Section(pRR) == DNSREC_ADDITIONAL)


//
//  DWORD flag definitions
//  #defines to match the windns.h ones for private fields

//  Charset

#define     DNSREC_CHARSET      (0x00000018)        // bits 4 and 5
#define     DNSREC_UNICODE      (0x00000008)        // DnsCharSetUnicode = 1
#define     DNSREC_UTF8         (0x00000010)        // DnsCharSetUtf8 = 2
#define     DNSREC_ANSI         (0x00000018)        // DnsCharSetAnsi = 3






//
//  Address family info (addr.c)
//

typedef struct _AddrFamilyInfo
{
    WORD    Family;
    WORD    DnsType;
    DWORD   LengthAddr;
    DWORD   LengthSockaddr;
    DWORD   OffsetToAddrInSockaddr;
}
FAMILY_INFO, *PFAMILY_INFO;

extern  FAMILY_INFO AddrFamilyTable[];

#define FamilyInfoIp4   (AddrFamilyTable[0])
#define FamilyInfoIp6   (AddrFamilyTable[1])
#define FamilyInfoAtm   (AddrFamilyTable[2])

#define pFamilyInfoIp4  (&AddrFamilyTable[0])
#define pFamilyInfoIp6  (&AddrFamilyTable[1])
#define pFamilyInfoAtm  (&AddrFamilyTable[2])


PFAMILY_INFO
FamilyInfo_GetForFamily(
    IN      DWORD           Family
    );

#define FamilyInfo_GetForSockaddr(pSA)  \
        FamilyInfo_GetForFamily( (pSA)->sa_family )

WORD
Family_DnsType(
    IN      WORD            Family
    );

DWORD
Family_SockaddrLength(
    IN      WORD            Family
    );

DWORD
Family_GetFromDnsType(
    IN      WORD            wType
    );


//
//  Sockaddr
//

DWORD
Sockaddr_Length(
    IN      PSOCKADDR       pSockaddr
    );

IP6_ADDRESS
Sockaddr_GetIp6(
    IN      PSOCKADDR       pSockaddr
    );

VOID
Sockaddr_BuildFromIp6(
    OUT     PSOCKADDR       pSockaddr,
    IN      IP6_ADDRESS     Ip6Addr,
    IN      WORD            Port
    );

DNS_STATUS
Sockaddr_BuildFromFlatAddr(
    OUT     PSOCKADDR       pSockaddr,
    IN OUT  PDWORD          pSockaddrLength,
    IN      BOOL            fClearSockaddr,
    IN      PBYTE           pAddr,
    IN      DWORD           AddrLength,
    IN      DWORD           AddrFamily
    );

//
//  Hostents (hostent.c)
//  (used by sablob.c)
//

PHOSTENT
Hostent_Init(
    IN OUT  PBYTE *         ppBuffer,
    IN      INT             Family,
    IN      INT             AddrLength,
    IN      DWORD           AddrCount,
    IN      DWORD           AliasCount
    );

VOID
Hostent_ConvertToOffsets(
    IN OUT  PHOSTENT        pHostent
    );



//
//  Sting to address (straddr.c)
//

//
//  Need for hostent routine which doesn't unicode\ANSI.
//

BOOL
Dns_StringToAddressEx(
    OUT     PCHAR           pAddrBuf,
    IN OUT  PDWORD          pBufLength,
    IN      PCSTR           pString,
    IN OUT  PDWORD          pAddrFamily,
    IN      BOOL            fUnicode,
    IN      BOOL            fReverse
    );

BOOL
Dns_StringToDnsAddrEx(
    OUT     PDNS_ADDR       pAddr,
    IN      PCSTR           pString,
    IN      DWORD           Family,     OPTIONAL
    IN      BOOL            fUnicode,
    IN      BOOL            fReverse
    );

//
//  Handle non-NULL terminated strings for DNS server file load.
//

BOOL
Dns_Ip4StringToAddressEx_A(
    OUT     PIP4_ADDRESS    pIp4Addr,
    IN      PCSTR           pchString,
    IN      DWORD           StringLength
    );

BOOL
Dns_Ip6StringToAddressEx_A(
    OUT     PIP6_ADDRESS    pIp6Addr,
    IN      PCSTR           pchString,
    IN      DWORD           StringLength
    );

//
//  Random
//

BOOL
Dns_ReverseNameToSockaddrPrivate(
    OUT     PSOCKADDR       pSockaddr,
    IN OUT  PDWORD          pSockaddrLength,
    IN      PCSTR           pString,
    IN      BOOL            fUnicode
    );

//
//  UPNP IP6 literal hack
//

VOID
Dns_Ip6AddressToLiteralName(
    OUT     PWCHAR          pBuffer,
    IN      PIP6_ADDRESS    pIp6
    );

BOOL
Dns_Ip6LiteralNameToAddress(
    OUT     PSOCKADDR_IN6   pSockAddr,
    IN      PCWSTR          pwsString
    );


//
//  Mcast address build (dnsaddr.c)
//

BOOL
DnsAddr_BuildMcast(
    OUT     PDNS_ADDR       pAddr,
    IN      DWORD           Family,
    IN      PWSTR           pName
    );

//
//  IP6 mcast address (ip6.c)
//

BOOL
Ip6_McastCreate(
    OUT     PIP6_ADDRESS    pIp,
    IN      PWSTR           pName
    );

//
//  IP4 networking (dnsutil.c)
//

BOOL
Dns_AreIp4InSameDefaultNetwork(
    IN      IP4_ADDRESS     IpAddr1,
    IN      IP4_ADDRESS     IpAddr2
    );


//
//  RPC-able type (record.c)
//

BOOL
Dns_IsRpcRecordType(
    IN      WORD            wType
    );


//
//  Record copy (rrcopy.c)
//

PDNS_RECORD
WINAPI
Dns_RecordCopy_W(
    IN      PDNS_RECORD     pRecord
    );

PDNS_RECORD
WINAPI
Dns_RecordCopy_A(
    IN      PDNS_RECORD     pRecord
    );

PDNS_RECORD
Dns_RecordListCopyEx(
    IN      PDNS_RECORD     pRR,
    IN      DWORD           ScreenFlag,
    IN      DNS_CHARSET     CharSetIn,
    IN      DNS_CHARSET     CharSetOut
    );


//
//  Record list routines (rrlist.c)
//

//
//  Record screening (rrlist.c)
//

#define SCREEN_OUT_ANSWER           (0x00000001)
#define SCREEN_OUT_AUTHORITY        (0x00000010)
#define SCREEN_OUT_ADDITIONAL       (0x00000100)
#define SCREEN_OUT_NON_RPC          (0x00100000)

#define SCREEN_OUT_SECTION  \
        (SCREEN_OUT_ANSWER | SCREEN_OUT_AUTHORITY | SCREEN_OUT_ADDITIONAL)


BOOL
Dns_ScreenRecord(
    IN      PDNS_RECORD     pRR,
    IN      DWORD           ScreenFlag
    );

PDNS_RECORD
Dns_RecordListScreen(
    IN      PDNS_RECORD     pRR,
    IN      DWORD           ScreenFlag
    );

DWORD
Dns_RecordListGetMinimumTtl(
    IN      PDNS_RECORD     pRRList
    );

//
//  Record priorities (rrlist.c)
//

PDNS_RECORD
Dns_PrioritizeSingleRecordSet(
    IN OUT  PDNS_RECORD     pRecordSet,
    IN      PDNS_ADDR_ARRAY pArray
    );

PDNS_RECORD
Dns_PrioritizeRecordList(
    IN OUT  PDNS_RECORD     pRecordList,
    IN      PDNS_ADDR_ARRAY pArray
    );


//
//  Record comparison (rrcomp.c)
//

BOOL
WINAPI
Dns_DeleteRecordFromList(
    IN OUT  PDNS_RECORD *   ppRRList,
    IN      PDNS_RECORD     pRRDelete
    );


//
//  New free
//  DCR:  switch to dnslib.h when world builds clean
//

#undef  Dns_RecordListFree

VOID
WINAPI
Dns_RecordListFree(
    IN OUT  PDNS_RECORD     pRRList
    );


//
//  String (string.c)
//

DWORD
MultiSz_Size_A(
    IN      PCSTR           pmszString
    );

PSTR
MultiSz_NextString_A(
    IN      PCSTR           pmszString
    );

PSTR
MultiSz_Copy_A(
    IN      PCSTR           pmszString
    );

BOOL
MultiSz_Equal_A(
    IN      PCSTR           pmszString1,
    IN      PCSTR           pmszString2
    );

DWORD
MultiSz_Size_W(
    IN      PCWSTR          pmszString
    );

PWSTR
MultiSz_NextString_W(
    IN      PCWSTR          pmszString
    );

PWSTR
MultiSz_Copy_W(
    IN      PCWSTR          pmszString
    );

BOOL
MultiSz_Equal_W(
    IN      PCWSTR          pmszString1,
    IN      PCWSTR          pmszString2
    );

BOOL
MultiSz_ContainsName_W(
    IN      PCWSTR          pmszString,
    IN      PCWSTR          pString
    );


DWORD
String_ReplaceCharW(
    IN OUT  PWSTR           pwsString,
    IN      WCHAR           TargetChar,
    IN      WCHAR           ReplaceChar
    );

DWORD
String_ReplaceCharA(
    IN OUT  PSTR            pszString,
    IN      CHAR            TargetChar,
    IN      CHAR            ReplaceChar
    );

PSTR *
Argv_CopyEx(
    IN      DWORD           Argc,
    IN      PCHAR *         Argv,
    IN      DNS_CHARSET     CharSetIn,
    IN      DNS_CHARSET     CharSetOut
    );

VOID
Argv_Free(
    IN OUT  PSTR *          Argv
    );


//
//  Timed locks (locks.c)
//

typedef struct _TimedLock
{
    HANDLE  hEvent;
    DWORD   ThreadId;
    LONG    RecursionCount;
    DWORD   WaitTime;
}
TIMED_LOCK, *PTIMED_LOCK;

#define TIMED_LOCK_DEFAULT_WAIT     (0xf0000000)


DWORD
TimedLock_Initialize(
    OUT     PTIMED_LOCK     pTimedLock,
    IN      DWORD           DefaultWait
    );

BOOL
TimedLock_Enter(
    IN OUT  PTIMED_LOCK     pTimedLock,
    IN      DWORD           WaitTime
    );

VOID
TimedLock_Leave(
    IN OUT  PTIMED_LOCK     pTimedLock
    );

VOID
TimedLock_Cleanup(
    IN OUT  PTIMED_LOCK     pTimedLock
    );



//
//  Name utilities (name.c)
//

DWORD
Dns_MakeCanonicalNameW(
    OUT     PWSTR           pBuffer,
    IN      DWORD           BufLength,
    IN      PWSTR           pwsString,
    IN      DWORD           StringLength
    );

DWORD
Dns_MakeCanonicalNameInPlaceW(
    IN      PWCHAR          pwString,
    IN      DWORD           StringLength
    );

INT
Dns_DowncaseNameLabel(
    OUT     PCHAR           pchResult,
    IN      PCHAR           pchLabel,
    IN      DWORD           cchLabel,
    IN      DWORD           dwFlags
    );


//
//  Name checking -- server name checking levels
//

#define DNS_ALLOW_RFC_NAMES_ONLY    (0)
#define DNS_ALLOW_NONRFC_NAMES      (1)
#define DNS_ALLOW_MULTIBYTE_NAMES   (2)
#define DNS_ALLOW_ALL_NAMES         (3)


PCHAR
_fastcall
Dns_GetDomainNameA(
    IN      PCSTR           pszName
    );

PWSTR
_fastcall
Dns_GetDomainNameW(
    IN      PCWSTR          pwsName
    );

PSTR
_fastcall
Dns_GetTldForNameA(
    IN      PCSTR           pszName
    );

PWSTR
_fastcall
Dns_GetTldForNameW(
    IN      PCWSTR          pszName
    );

BOOL
_fastcall
Dns_IsNameShortA(
    IN      PCSTR           pszName
    );

BOOL
_fastcall
Dns_IsNameShortW(
    IN      PCWSTR          pszName
    );

BOOL
_fastcall
Dns_IsNameNumericA(
    IN      PCSTR           pszName
    );

BOOL
_fastcall
Dns_IsNameNumericW(
    IN      PCWSTR          pszName
    );

BOOL
_fastcall
Dns_IsNameFQDN_A(
    IN      PCSTR           pszName
    );

BOOL
_fastcall
Dns_IsNameFQDN_W(
    IN      PCWSTR          pszName
    );

DWORD
_fastcall
Dns_GetNameAttributesA(
    IN      PCSTR           pszName
    );

DWORD
_fastcall
Dns_GetNameAttributesW(
    IN      PCWSTR          pszName
    );

DNS_STATUS
Dns_ValidateAndCategorizeDnsNameA(
    IN      PCSTR           pszName,
    OUT     PDWORD          pLabelCount
    );

DNS_STATUS
Dns_ValidateAndCategorizeDnsNameW(
    IN      PCWSTR          pszName,
    OUT     PDWORD          pLabelCount
    );

DWORD
Dns_NameLabelCountA(
    IN      PCSTR           pszName
    );

DWORD
Dns_NameLabelCountW(
    IN      PCWSTR          pszName
    );

PSTR
Dns_NameAppend_A(
    OUT     PCHAR           pNameBuffer,
    IN      DWORD           BufferLength,
    IN      PSTR            pszName,
    IN      PSTR            pszDomain
    );

PWSTR
Dns_NameAppend_W(
    OUT     PWCHAR          pNameBuffer,
    IN      DWORD           BufferLength,
    IN      PWSTR           pwsName,
    IN      PWSTR           pwsDomain
    );

PSTR
Dns_SplitHostFromDomainNameA(
    IN      PSTR            pszName
    );

PWSTR
Dns_SplitHostFromDomainNameW(
    IN      PWSTR           pszName
    );

BOOL
Dns_CopyNameLabelA(
    OUT     PCHAR           pBuffer,
    IN      PCSTR           pszName
    );

BOOL
Dns_CopyNameLabelW(
    OUT     PWCHAR          pBuffer,
    IN      PCWSTR          pszName
    );


//
//  Common name transformations
//

DWORD
Dns_NameCopyWireToUnicode(
    OUT     PWCHAR          pBufferUnicode,
    IN      PCSTR           pszNameWire
    );

DWORD
Dns_NameCopyUnicodeToWire(
    OUT     PCHAR           pBufferWire,
    IN      PCWSTR          pwsNameUnicode
    );

DWORD
Dns_NameCopyStandard_W(
    OUT     PWCHAR          pBuffer,
    IN      PCWSTR          pwsNameUnicode
    );

DWORD
Dns_NameCopyStandard_A(
    OUT     PCHAR           pBuffer,
    IN      PCSTR           pszName
    );



//
//  Special record creation (rralloc.c)
//

PDNS_RECORD
Dns_CreateFlatRecord(
    IN      PDNS_NAME       pOwnerName,
    IN      WORD            wType,
    IN      PCHAR           pData,
    IN      DWORD           DataLength,
    IN      DWORD           Ttl,
    IN      DNS_CHARSET     NameCharSet,
    IN      DNS_CHARSET     RecordCharSet
    );

PDNS_RECORD
Dns_CreatePtrTypeRecord(
    IN      PDNS_NAME       pOwnerName,
    IN      BOOL            fCopyName,
    IN      PDNS_NAME       pTargetName,
    IN      WORD            wType,
    IN      DWORD           Ttl,
    IN      DNS_CHARSET     NameCharSet,
    IN      DNS_CHARSET     RecordCharSet
    );

PDNS_RECORD
Dns_CreatePtrRecordEx(
    IN      PDNS_ADDR       pAddr,
    IN      PDNS_NAME       pszHostName,
    IN      DWORD           Ttl,
    IN      DNS_CHARSET     NameCharSet,
    IN      DNS_CHARSET     RecordCharSet
    );

PDNS_RECORD
Dns_CreatePtrRecordExEx(
    IN      PDNS_ADDR       pAddr,
    IN      PSTR            pszHostName,
    IN      PSTR            pszDomainName,
    IN      DWORD           Ttl,
    IN      DNS_CHARSET     NameCharSet,
    IN      DNS_CHARSET     RecordCharSet
    );

PDNS_RECORD
Dns_CreateARecord(
    IN      PDNS_NAME       pOwnerName,
    IN      IP4_ADDRESS     Ip4Address,
    IN      DWORD           Ttl,
    IN      DNS_CHARSET     NameCharSet,
    IN      DNS_CHARSET     RecordCharSet
    );

PDNS_RECORD
Dns_CreateAAAARecord(
    IN      PDNS_NAME       pOwnerName,
    IN      IP6_ADDRESS     Ip6Address,
    IN      DWORD           Ttl,
    IN      DNS_CHARSET     NameCharSet,
    IN      DNS_CHARSET     RecordCharSet
    );

PDNS_RECORD
Dns_CreateForwardRecord(
    IN      PDNS_NAME       pOwnerName,
    IN      WORD            wType,          OPTIONAL
    IN      PDNS_ADDR       pAddr,
    IN      DWORD           Ttl,
    IN      DNS_CHARSET     NameCharSet,
    IN      DNS_CHARSET     RecordCharSet
    );

PDNS_RECORD
Dns_CreateForwardRecordFromIp6(
    IN      PDNS_NAME       pOwnerName,
    IN      PIP6_ADDRESS    pIp,
    IN      DWORD           Ttl,
    IN      DNS_CHARSET     NameCharSet,
    IN      DNS_CHARSET     RecordCharSet
    );

PDNS_RECORD
Dns_CreateForwardRecordFromSockaddr(
    IN      PDNS_NAME       pOwnerName,
    IN      PSOCKADDR       pSockaddr,
    IN      DWORD           Ttl,
    IN      DNS_CHARSET     NameCharSet,
    IN      DNS_CHARSET     RecordCharSet
    );

PDNS_RECORD
Dns_CreateRecordForIpString_W(
    IN      PCWSTR          pwsName,
    IN      WORD            wType,
    IN      DWORD           Ttl
    );


//
//  Record read\write (rrwrite.c rrread.c)
//
//  Need here to export to dnsapi\packet.c
//

typedef PCHAR (* RR_WRITE_FUNCTION)(
                            PDNS_RECORD,
                            PCHAR,
                            PCHAR );

extern  RR_WRITE_FUNCTION   RR_WriteTable[];


typedef PDNS_RECORD (* RR_READ_FUNCTION)(
                            PDNS_RECORD,
                            DNS_CHARSET,
                            PCHAR,
                            PCHAR,
                            PCHAR );

extern  RR_READ_FUNCTION   RR_ReadTable[];




//
//  Security stuff (security.c)
//

#define SECURITY_WIN32
#include <sspi.h>

#define DNS_SPN_SERVICE_CLASS       "DNS"
#define DNS_SPN_SERVICE_CLASS_W     L"DNS"

//
//  Some useful stats
//

extern  DWORD   SecContextCreate;
extern  DWORD   SecContextFree;
extern  DWORD   SecContextQueue;
extern  DWORD   SecContextQueueInNego;
extern  DWORD   SecContextDequeue;
extern  DWORD   SecContextTimeout;
extern  DWORD   SecPackAlloc;
extern  DWORD   SecPackFree;

//  Security packet verifications

extern  DWORD   SecTkeyInvalid;
extern  DWORD   SecTkeyBadTime;
extern  DWORD   SecTsigFormerr;
extern  DWORD   SecTsigEcho;
extern  DWORD   SecTsigBadKey;
extern  DWORD   SecTsigVerifySuccess;
extern  DWORD   SecTsigVerifyOldSig;
extern  DWORD   SecTsigVerifyFailed;

//  Hacks
//  Allowing old TSIG off by default, server can turn on.
//  Big Time skew on by default

extern BOOL    SecAllowOldTsig;
extern DWORD   SecTsigVerifyOldSig;
extern DWORD   SecTsigVerifyOldFailed;
extern DWORD   SecBigTimeSkew;
extern DWORD   SecBigTimeSkewBypass;

//
//  Security globals
//      expose some of these which may be accessed by update library
//

extern BOOL     g_fSecurityPackageInitialized;
extern DWORD    g_SecurityTokenMaxLength;

//
//  Security context cache
//

VOID
Dns_TimeoutSecurityContextList(
    IN      BOOL            fClearList
    );

//
//  Security API
//

BOOL
Dns_DnsNameToKerberosTargetName(
    IN      LPSTR           pszDnsName,
    IN      LPSTR           pszKerberosTargetName
    );

DNS_STATUS
Dns_StartSecurity(
    IN      BOOL            fProcessAttach
    );

DNS_STATUS
Dns_StartServerSecurity(
    VOID
    );

VOID
Dns_TerminateSecurityPackage(
    VOID
    );

HANDLE
Dns_CreateAPIContext(
    IN      DWORD           Flags,
    IN      PVOID           Credentials,    OPTIONAL
    IN      BOOL            fUnicode
    );

VOID
Dns_FreeAPIContext(
    IN OUT  HANDLE          hContextHandle
    );

PVOID
Dns_GetApiContextCredentials(
    IN      HANDLE          hContextHandle
    );

DWORD
Dns_GetCurrentRid(
    VOID
    );

BOOL
Dns_CreateUserCredentials(
    IN      PCHAR           pszUser,
    IN      DWORD           dwUserLength,
    IN      PCHAR           pszDomain,
    IN      DWORD           dwDomainLength,
    IN      PCHAR           pszPassword,
    IN      DWORD           dwPasswordLength,
    IN      BOOL            FromWide,
    OUT     PCHAR *         ppCreds
    );


PSEC_WINNT_AUTH_IDENTITY_W
Dns_AllocateAndInitializeCredentialsW(
    IN      PSEC_WINNT_AUTH_IDENTITY_W  pAuthIn
    );

PSEC_WINNT_AUTH_IDENTITY_A
Dns_AllocateAndInitializeCredentialsA(
    IN      PSEC_WINNT_AUTH_IDENTITY_A  pAuthIn
    );

VOID
Dns_FreeAuthIdentityCredentials(
    IN      PVOID  pAuthIn
    );


DNS_STATUS
Dns_SignMessageWithGssTsig(
    IN      HANDLE          hContext,
    IN      PDNS_HEADER     pMsgHead,
    IN      PCHAR           pMsgBufEnd,
    IN OUT  PCHAR *         ppCurrent
    );

#if 1
DNS_STATUS
Dns_RefreshSSpiCredentialsHandle(
    IN      BOOL bDnsSvr,
    IN      PCHAR pCreds );
#endif

VOID
Dns_FreeSecurityContextList(
    VOID
    );



//
//  Server security routines
//

DNS_STATUS
Dns_FindSecurityContextFromAndVerifySignature(
    OUT     PHANDLE         phContext,
    IN      PDNS_ADDR       pRemoteAddr,
    IN      PDNS_HEADER     pMsgHead,
    IN      PCHAR           pMsgEnd
    );

DNS_STATUS
Dns_FindSecurityContextFromAndVerifySignature_Ip4(
    IN      PHANDLE         phContext,
    IN      IP4_ADDRESS     IpRemote,
    IN      PDNS_HEADER     pMsgHead,
    IN      PCHAR           pMsgEnd
    );

DNS_STATUS
Dns_ServerNegotiateTkey(
    IN      PDNS_ADDR       pRemoteAddr,
    IN      PDNS_HEADER     pMsgHead,
    IN      PCHAR           pMsgEnd,
    IN      PCHAR           pMsgBufEnd,
    IN      BOOL            fBreakOnAscFailure,
    OUT     PCHAR *         ppCurrent
    );

DNS_STATUS
Dns_ServerNegotiateTkey_Ip4(
    IN      IP4_ADDRESS     IpRemote,
    IN      PDNS_HEADER     pMsgHead,
    IN      PCHAR           pMsgEnd,
    IN      PCHAR           pMsgBufEnd,
    IN      BOOL            fBreakOnAscFailure,
    OUT     PCHAR *         ppCurrent
    );

DNS_STATUS
Dns_SrvImpersonateClient(
    IN      HANDLE          hContext
    );

DNS_STATUS
Dns_SrvRevertToSelf(
    IN      HANDLE          hContext
    );

VOID
Dns_CleanupSessionAndEnlistContext(
    IN OUT  HANDLE          hSession
    );

DWORD
Dns_GetKeyVersion(
    IN      LPSTR           pszContext
    );

//
//  Security utilities
//

DNS_STATUS
Dns_CreateSecurityDescriptor(
    OUT     PSECURITY_DESCRIPTOR *  ppSD,
    IN      DWORD                   AclCount,
    IN      PSID *                  SidPtrArray,
    IN      DWORD *                 AccessMaskArray
    );



//
//  Security credentials
//

//  Only defined if WINNT_AUTH_IDENTITY defined

#ifdef __RPCDCE_H__

PSEC_WINNT_AUTH_IDENTITY_W
Dns_AllocateCredentials(
    IN      PWSTR           pwsUserName,
    IN      PWSTR           pwsDomain,
    IN      PWSTR           pwsPassword
    );
#endif

DNS_STATUS
Dns_ImpersonateUser(
    IN      PDNS_CREDENTIALS    pCreds
    );

VOID
Dns_FreeCredentials(
    IN      PDNS_CREDENTIALS    pCreds
    );

PDNS_CREDENTIALS
Dns_CopyCredentials(
    IN      PDNS_CREDENTIALS    pCreds
    );



//
//  Debug globals
//
//  Expose here to allow debug file sharing
//

typedef struct _DnsDebugInfo
{
    DWORD       Flag;
    HANDLE      hFile;

    DWORD       FileCurrentSize;
    DWORD       FileWrapCount;
    DWORD       FileWrapSize;

    DWORD       LastThreadId;
    DWORD       LastSecond;

    BOOL        fConsole;

    CHAR        FileName[ MAX_PATH ];
}
DNS_DEBUG_INFO, *PDNS_DEBUG_INFO;

//  WANING:  MUST ONLY be called in dnsapi.dll

PDNS_DEBUG_INFO
Dns_SetDebugGlobals(
    IN OUT  PDNS_DEBUG_INFO pInfo
    );


#ifdef __cplusplus
}
#endif  // __cplusplus

#endif // _DNSLIBP_INCLUDED_
=== C:/Users/treeman/Desktop/windows nt source code\Source\Win2K3\NT\ds\dns\dnslib\dnsip.h ===
/*++

Copyright (c) 2001-2002  Microsoft Corporation

Module Name:

    dnsip.h

Abstract:

    Domain Name System (DNS) Library

    DNS IP addressing stuff.

Author:

    Jim Gilroy (jamesg)     November 13, 2001

Revision History:

--*/


#ifndef _DNSIP_INCLUDED_
#define _DNSIP_INCLUDED_


#include <winsock2.h>

#ifndef MIDL_PASS
#include <ws2tcpip.h>
#endif


#ifdef __cplusplus
extern "C"
{
#endif  // __cplusplus


//
//  Return for none\bad IP4
//

#define BAD_IP4_ADDR    INADDR_NONE


//
//  Subnetting
//

#define SUBNET_MASK_CLASSC      (0x00ffffff)
#define SUBNET_MASK_CLASSB      (0x0000ffff)
#define SUBNET_MASK_CLASSA      (0x000000ff)



//
//  IP6_ADDRESS macros
//
//  ws2tcpip.h macros converted to IP6_ADDRESS
//

#ifndef MIDL_PASS

WS2TCPIP_INLINE
BOOL
IP6_ARE_ADDRS_EQUAL(
    IN      const IP6_ADDRESS * pIp1,
    IN      const IP6_ADDRESS * pIp2
    )
{
    return RtlEqualMemory( pIp1, pIp2, sizeof(IP6_ADDRESS) );
}

#define IP6_ADDR_EQUAL(a,b) IP6_ARE_ADDRS_EQUAL(a,b)

WS2TCPIP_INLINE
BOOL
IP6_IS_ADDR_ZERO(
    IN      const IP6_ADDRESS * pIpAddr
    )
{
    return ((pIpAddr->IP6Dword[3] == 0)             &&
            (pIpAddr->IP6Dword[2] == 0)             &&
            (pIpAddr->IP6Dword[1] == 0)             &&
            (pIpAddr->IP6Dword[0] == 0) );
}

WS2TCPIP_INLINE
BOOL
IP6_IS_ADDR_LOOPBACK(
    IN      const IP6_ADDRESS * pIpAddr
    )
{
    return ((pIpAddr->IP6Dword[3] == 0x01000000)    &&
            (pIpAddr->IP6Dword[2] == 0)             &&
            (pIpAddr->IP6Dword[1] == 0)             &&
            (pIpAddr->IP6Dword[0] == 0) );
}

WS2TCPIP_INLINE
BOOL
IP6_IS_ADDR_V4MAPPED_LOOPBACK(
    IN      const IP6_ADDRESS * pIpAddr
    )
{
    return ((pIpAddr->IP6Dword[3] == DNS_NET_ORDER_LOOPBACK)    &&
            (pIpAddr->IP6Dword[2] == 0xffff0000)                &&
            (pIpAddr->IP6Dword[1] == 0)                         &&
            (pIpAddr->IP6Dword[0] == 0) );
}

WS2TCPIP_INLINE
BOOL
IP6_IS_ADDR_V4_LOOPBACK(
    IN      const IP6_ADDRESS * pIpAddr
    )
{
    return ((pIpAddr->IP6Dword[3] == DNS_NET_ORDER_LOOPBACK)    &&
            ( (pIpAddr->IP6Dword[2] == 0xffff0000) ||
              (pIpAddr->IP6Dword[2] == 0) )                     &&
            (pIpAddr->IP6Dword[1] == 0)                         &&
            (pIpAddr->IP6Dword[0] == 0) );
}

WS2TCPIP_INLINE
BOOL
IP6_IS_ADDR_MULTICAST(
    IN      const IP6_ADDRESS * pIpAddr
    )
{
    return( pIpAddr->IP6Byte[0] == 0xff );
}

WS2TCPIP_INLINE
BOOL
IP6_IS_ADDR_LINKLOCAL(
    IN      const IP6_ADDRESS * pIpAddr
    )
{
    return( (pIpAddr->IP6Byte[0] == 0xfe) &&
            ((pIpAddr->IP6Byte[1] & 0xc0) == 0x80) );
}

WS2TCPIP_INLINE
BOOL
IP6_IS_ADDR_SITELOCAL(
    IN      const IP6_ADDRESS * pIpAddr
    )
{
    return ((pIpAddr->IP6Byte[0] == 0xfe) &&
            ((pIpAddr->IP6Byte[1] & 0xc0) == 0xc0));
}

WS2TCPIP_INLINE
BOOL
IP6_IS_ADDR_V4MAPPED(
    IN      const IP6_ADDRESS * pIpAddr
    )
{
    return ((pIpAddr->IP6Dword[2] == 0xffff0000)    &&
            (pIpAddr->IP6Dword[1] == 0)             && 
            (pIpAddr->IP6Dword[0] == 0) );
}

WS2TCPIP_INLINE
BOOL
IP6_IS_ADDR_V4COMPAT(
    IN      const IP6_ADDRESS * pIpAddr
    )
{
    //  IP6 address has only last DWORD
    //      and is NOT any or loopback

    return ((pIpAddr->IP6Dword[0] == 0) && 
            (pIpAddr->IP6Dword[1] == 0) &&
            (pIpAddr->IP6Dword[2] == 0) &&
            (pIpAddr->IP6Dword[3] != 0) && 
            (pIpAddr->IP6Dword[3] != 0x01000000) );
}

WS2TCPIP_INLINE
BOOL
IP6_IS_ADDR_EQUAL_V4MAPPED(
    IN      const IP6_ADDRESS * pIpAddr,
    IN      IP4_ADDRESS         Ip4
    )
{
    return ((pIpAddr->IP6Dword[3] == Ip4)           &&
            (pIpAddr->IP6Dword[2] == 0xffff0000)    &&
            (pIpAddr->IP6Dword[1] == 0)             && 
            (pIpAddr->IP6Dword[0] == 0) );
}

WS2TCPIP_INLINE
BOOL
IP6_IS_ADDR_EQUAL_V4COMPAT(
    IN      const IP6_ADDRESS * pIpAddr,
    IN      IP4_ADDRESS         Ip4
    )
{
    return ((pIpAddr->IP6Dword[3] == Ip4)           &&
            (pIpAddr->IP6Dword[2] == 0)             &&
            (pIpAddr->IP6Dword[1] == 0)             && 
            (pIpAddr->IP6Dword[0] == 0) );
}

WS2TCPIP_INLINE
BOOL
IP6_IS_ADDR_DEFAULT_DNS(
    IN      const IP6_ADDRESS * pIpAddr
    )
{
    //  IP6 default DNS of the form
    //      0xfec0:0:0:ffff::1,2,or 3

    return ((pIpAddr->IP6Dword[0] == 0x0000c0fe) && 
            (pIpAddr->IP6Dword[1] == 0xffff0000) &&
            (pIpAddr->IP6Dword[2] == 0) &&
            ( pIpAddr->IP6Dword[3] == 0x01000000 ||
              pIpAddr->IP6Dword[3] == 0x02000000 ||
              pIpAddr->IP6Dword[3] == 0x03000000 ) );
}

//
//  More IP6 extensions missing from ws2tcpip.h
//

WS2TCPIP_INLINE
VOID
IP6_SET_ADDR_ANY(
    OUT     PIP6_ADDRESS    pIn6Addr
    )
{
    RtlZeroMemory( pIn6Addr, sizeof(*pIn6Addr) );
}

#define IP6_SET_ADDR_ZERO(pIp)   IP6_SET_ADDR_ANY(pIp)

WS2TCPIP_INLINE
VOID
IP6_SET_ADDR_LOOPBACK(
    OUT     PIP6_ADDRESS    pIn6Addr
    )
{
    pIn6Addr->IP6Dword[0]  = 0;
    pIn6Addr->IP6Dword[1]  = 0;
    pIn6Addr->IP6Dword[2]  = 0;
    pIn6Addr->IP6Dword[3]  = 0x01000000;
}

WS2TCPIP_INLINE
VOID
IP6_SET_ADDR_V4COMPAT(
    OUT     PIP6_ADDRESS    pIn6Addr,
    IN      IP4_ADDRESS     Ip4
    )
{
    pIn6Addr->IP6Dword[0]  = 0;
    pIn6Addr->IP6Dword[1]  = 0;
    pIn6Addr->IP6Dword[2]  = 0;
    pIn6Addr->IP6Dword[3]  = Ip4;
}

WS2TCPIP_INLINE
VOID
IP6_SET_ADDR_V4MAPPED(
    OUT     PIP6_ADDRESS    pIn6Addr,
    IN      IP4_ADDRESS     Ip4
    )
{
    pIn6Addr->IP6Dword[0]  = 0;
    pIn6Addr->IP6Dword[1]  = 0;
    pIn6Addr->IP6Dword[2]  = 0xffff0000;
    pIn6Addr->IP6Dword[3]  = Ip4;
}

WS2TCPIP_INLINE
VOID
IP6_ADDR_COPY(
    OUT     PIP6_ADDRESS    pIp1,
    IN      PIP6_ADDRESS    pIp2
    )
{
    RtlCopyMemory(
        pIp1,
        pIp2,
        sizeof(IP6_ADDRESS) );
}

WS2TCPIP_INLINE
IP4_ADDRESS
IP6_GET_V4_ADDR(
    IN      const IP6_ADDRESS * pIn6Addr
    )
{
    return( pIn6Addr->IP6Dword[3] );
}

WS2TCPIP_INLINE
IP4_ADDRESS
IP6_GET_V4_ADDR_IF_MAPPED(
    IN      const IP6_ADDRESS * pIn6Addr
    )
{
    if ( IP6_IS_ADDR_V4MAPPED(pIn6Addr) )
    {
        return( pIn6Addr->IP6Dword[3] );
    }
    else
    {
        return( BAD_IP4_ADDR );
    }
}

#endif  // MIDL_PASS



//
//  IP6 addressing routines
//

DWORD
Ip6_CopyFromSockaddr(
    OUT     PIP6_ADDRESS    pIp,
    IN      PSOCKADDR       pSockAddr,
    IN      INT             Family
    );

INT
Ip6_Family(
    IN      PIP6_ADDRESS    pIp
    );

INT
Ip6_WriteSockaddr(
    OUT     PSOCKADDR       pSockaddr,
    OUT     PDWORD          pSockaddrLength,    OPTIONAL
    IN      PIP6_ADDRESS    pIp,
    IN      WORD            Port                OPTIONAL
    );

INT
Ip6_WriteDnsAddr(
    OUT     PDNS_ADDR       pDnsAddr,
    IN      PIP6_ADDRESS    pIp,
    IN      WORD            Port        OPTIONAL
    );

PSTR
Ip6_AddrStringForSockaddr(
    IN      PSOCKADDR       pSockaddr
    );

//
//  IP6 Array
//

#ifndef DEFINED_IP6_ARRAY
typedef struct _Ip6Array
{
    DWORD           MaxCount;
    DWORD           AddrCount;
    IP6_ADDRESS     AddrArray[1];
}
IP6_ARRAY, *PIP6_ARRAY;
#endif


DWORD
Ip6Array_Sizeof(
    IN      PIP6_ARRAY      pIpArray
    );

BOOL
Ip6Array_Probe(
    IN      PIP6_ARRAY      pIpArray
    );

VOID
Ip6Array_Init(
    IN OUT  PIP6_ARRAY      pIpArray,
    IN      DWORD           MaxCount
    );

VOID
Ip6Array_Free(
    IN OUT  PIP6_ARRAY      pIpArray
    );

PIP6_ARRAY
Ip6Array_Create(
    IN      DWORD           MaxCount
    );

PIP6_ARRAY
Ip6Array_CreateFromIp4Array(
    IN      PIP4_ARRAY      pIp4Array
    );

PIP6_ARRAY
Ip6Array_CreateFromFlatArray(
    IN      DWORD           AddrCount,
    IN      PIP6_ADDRESS    pIpAddrs
    );

PIP6_ARRAY
Ip6Array_CopyAndExpand(
    IN OUT  PIP6_ARRAY      pIpArray,
    IN      DWORD           ExpandCount,
    IN      BOOL            fDeleteExisting
    );

PIP6_ARRAY
Ip6Array_CreateCopy(
    IN      PIP6_ARRAY      pIpArray
    );

BOOL
Ip6Array_ContainsIp(
    IN      PIP6_ARRAY      pIpArray,
    IN      PIP6_ADDRESS    pIp
    );

BOOL
Ip6Array_AddIp(
    IN OUT  PIP6_ARRAY      pIpArray,
    IN      PIP6_ADDRESS    pAddIp,
    IN      BOOL            fScreenDups
    );

BOOL
Ip6Array_AddIp4(
    IN OUT  PIP6_ARRAY      pIpArray,
    IN      IP4_ADDRESS     Ip4,
    IN      BOOL            fScreenDups
    );

BOOL
Ip6Array_AddSockaddr(
    IN OUT  PIP6_ARRAY      pIpArray,
    IN      PSOCKADDR       pSockaddr,
    IN      DWORD           Family,
    IN      BOOL            fScreenDups
    );

DWORD
Ip6Array_DeleteIp(
    IN OUT  PIP6_ARRAY      pIpArray,
    IN      PIP6_ADDRESS    pIpDelete
    );

DNS_STATUS
Ip6Array_Diff(
    IN      PIP6_ARRAY      pIpArray1,
    IN      PIP6_ARRAY      pIpArray2,
    OUT     PIP6_ARRAY*     ppOnlyIn1,
    OUT     PIP6_ARRAY*     ppOnlyIn2,
    OUT     PIP6_ARRAY*     ppIntersect
    );

BOOL
Ip6Array_IsIntersection(
    IN      PIP6_ARRAY      pIpArray1,
    IN      PIP6_ARRAY      pIpArray2
    );

BOOL
Ip6Array_IsEqual(
    IN      PIP6_ARRAY      pIpArray1,
    IN      PIP6_ARRAY      pIpArray2
    );

DNS_STATUS
Ip6Array_Union(
    IN      PIP6_ARRAY      pIpArray1,
    IN      PIP6_ARRAY      pIpArray2,
    OUT     PIP6_ARRAY*     ppUnion
    );

VOID
Ip6Array_InitSingleWithIp(
    IN OUT  PIP6_ARRAY      pArray,
    IN      PIP6_ADDRESS    pIp
    );

VOID
Ip6Array_InitSingleWithIp4(
    IN OUT  PIP6_ARRAY      pArray,
    IN      IP4_ADDRESS     Ip4Addr
    );

DWORD
Ip6Array_InitSingleWithSockaddr(
    IN OUT  PIP6_ARRAY      pArray,
    IN      PSOCKADDR       pSockAddr
    );


//
//  DCR:  build inet6_ntoa
//  FIX6:  build inet6_ntoa
//

PSTR
Ip6_TempNtoa(
    IN      PIP6_ADDRESS    pIp
    );

#define IPADDR_STRING( pIp )    Ip6_TempNtoa( pIp )
#define IP6_STRING( pIp )       Ip6_TempNtoa( pIp )



//
//  Matching levels in DNS_ADDR comparisons
//
//  Because these are sockaddrs, they may match in IP address
//  but not in other fields -- port, scope (for IP6), subnet length.
//  When doing comparison must specify level of match.
//  If unspecified, entire blob must match.
//
//  Note, these are setup as bit fields, to allow extensibility for
//  address types, but when matching addresses, they should be used
//  as match LEVELS:
//      - ALL
//      - the sockaddr (inc. port)
//      - the address (don't include port)
//      - just the IP
//
//  When screening addresses for inclusion \ exclusion from address
//  array then flags can be applied to match specific pieces (family,
//  IP, port, subnet, flags, etc) of a "template" DNS_ADDR.
//
//  Example:
//      - want IP6 addresses with particular flag bits (ex cluster bit)
//      - build DNS_ADDR with AF_INET6 and desired flag bit
//      - build screening flag with MATCH_FAMILY and MATCH_FLAG_SET
//

#define DNSADDR_MATCH_FAMILY        (0x00000001)
#define DNSADDR_MATCH_IP            (0x00000003)
#define DNSADDR_MATCH_SCOPE         (0x00000010)
#define DNSADDR_MATCH_ADDR          (0x000000ff)

#define DNSADDR_MATCH_PORT          (0x00000100)
#define DNSADDR_MATCH_SOCKADDR      (0x0000ffff)

#define DNSADDR_MATCH_SUBNET        (0x00010000)
#define DNSADDR_MATCH_FLAG          (0x00100000)
#define DNSADDR_MATCH_ALL           (0xffffffff)


//
//  Address screening callback function.
//
//  This allows user to setup their own screening for addresses
//  in array that does detailed checking.
//  Allows:
//      1) checking user defined fields
//      2) checking against flags field, which has multiple possible
//      checks (equal, set, and, and=value, nand, etc) or even
//      more complicated ones
//      3) checking across different families (example IP6 in this
//      subnet or IP4 in that) analogous to DnsAddr_IsLoopback check
//      

typedef BOOL (* DNSADDR_SCREEN_FUNC)(
                    IN      PDNS_ADDR       pAddrToCheck,
                    IN      PDNS_ADDR       pScreenAddr     OPTIONAL
                    );


//
//  Network matching levels
//

#define DNSADDR_NETMATCH_NONE       (0)
#define DNSADDR_NETMATCH_CLASSA     (1)
#define DNSADDR_NETMATCH_CLASSB     (2)
#define DNSADDR_NETMATCH_CLASSC     (3)
#define DNSADDR_NETMATCH_SUBNET     (4)



//
//  DNS_ADDR routines
//

#define DnsAddr_Copy( pd, ps )              RtlCopyMemory( (pd), (ps), sizeof(DNS_ADDR) )
#define DnsAddr_Clear( p )                  RtlZeroMemory( (p), sizeof(DNS_ADDR) )

#define DnsAddr_Family( p )                 ((p)->Sockaddr.sa_family)
#define DnsAddr_IsEmpty( p )                (DnsAddr_Family(p) == 0)
#define DnsAddr_IsIp4( p )                  (DnsAddr_Family(p) == AF_INET)
#define DnsAddr_IsIp6( p )                  (DnsAddr_Family(p) == AF_INET6)
#define DnsAddr_MatchesType( p, t )         (DnsAddr_DnsType(p) == (t))

#define DnsAddr_GetIp6Ptr( p )              ((PIP6_ADDRESS)&(p)->SockaddrIn6.sin6_addr)
#define DnsAddr_GetIp4Ptr( p )              ((PIP4_ADDRESS)&(p)->SockaddrIn.sin_addr.s_addr)

#define DnsAddr_GetPort( p )                ((p)->SockaddrIn6.sin6_port )
#define DnsAddr_SetPort( p, port )          ((p)->SockaddrIn6.sin6_port = (port) )

#define DnsAddr_SetSockaddrRecvLength( p )  ((p)->SockaddrLength = sizeof((p)->MaxSa))

WORD
DnsAddr_DnsType(
    IN      PDNS_ADDR       pAddr
    );

BOOL
DnsAddr_IsLoopback(
    IN      PDNS_ADDR       pAddr,
    IN      DWORD           Family
    );

BOOL
DnsAddr_IsUnspec(
    IN      PDNS_ADDR       pAddr,
    IN      DWORD           Family
    );

BOOL
DnsAddr_IsClear(
    IN      PDNS_ADDR       pAddr
    );

BOOL
DnsAddr_IsEqual(
    IN      PDNS_ADDR       pAddr1,
    IN      PDNS_ADDR       pAddr2,
    IN      DWORD           MatchLevel
    );

BOOL
DnsAddr_IsIp6DefaultDns(
    IN      PDNS_ADDR       pAddr
    );

BOOL
DnsAddr_MatchesIp4(
    IN      PDNS_ADDR       pAddr,
    IN      IP4_ADDRESS     Ip4
    );

BOOL
DnsAddr_MatchesIp6(
    IN      PDNS_ADDR       pAddr,
    IN      PIP6_ADDRESS    pIp6
    );


DWORD
DnsAddr_WriteSockaddr(
    OUT     PSOCKADDR       pSockaddr,
    IN      DWORD           SockaddrLength,
    IN      PDNS_ADDR       pAddr
    );

BOOL
DnsAddr_WriteIp6(
    OUT     PIP6_ADDRESS    pIp,
    IN      PDNS_ADDR       pAddr
    );

IP4_ADDRESS
DnsAddr_GetIp4(
    IN      PDNS_ADDR       pAddr
    );

BOOL
DnsAddr_Build(
    OUT     PDNS_ADDR       pAddr,
    IN      PSOCKADDR       pSockaddr,
    IN      DWORD           Family,         OPTIONAL
    IN      DWORD           SubnetLength,   OPTIONAL
    IN      DWORD           Flags           OPTIONAL
    );

VOID
DnsAddr_BuildFromIp4(
    OUT     PDNS_ADDR       pAddr,
    IN      IP4_ADDRESS     Ip4,
    IN      WORD            Port
    );

VOID
DnsAddr_BuildFromIp6(
    OUT     PDNS_ADDR       pAddr,
    IN      PIP6_ADDRESS    pIp6,
    IN      DWORD           ScopeId,
    IN      WORD            Port
    );

BOOL
DnsAddr_BuildFromDnsRecord(
    OUT     PDNS_ADDR       pAddr,
    IN      PDNS_RECORD     pRR
    );

BOOL
DnsAddr_BuildFromFlatAddr(
    OUT     PDNS_ADDR       pAddr,
    IN      DWORD           Family,
    IN      PCHAR           pFlatAddr,
    IN      WORD            Port
    );

PCHAR
DnsAddr_WriteIpString_A(
    OUT     PCHAR           pBuffer,
    IN      PDNS_ADDR       pAddr
    );

PCHAR
DnsAddr_Ntoa(
    IN      PDNS_ADDR       pAddr
    );

PSTR
DnsAddr_WriteStructString_A(
    OUT     PCHAR           pBuffer,
    IN      PDNS_ADDR       pAddr
    );

#define DNSADDR_STRING(p)   DnsAddr_Ntoa(p)




//
//  DNS_ADDR_ARRAY routines
//

DWORD
DnsAddrArray_Sizeof(
    IN      PDNS_ADDR_ARRAY     pArray
    );

DWORD
DnsAddrArray_GetFamilyCount(
    IN      PDNS_ADDR_ARRAY     pArray,
    IN      DWORD               Family
    );

VOID
DnsAddrArray_Init(
    IN OUT  PDNS_ADDR_ARRAY     pArray,
    IN      DWORD               MaxCount
    );

VOID
DnsAddrArray_Free(
    IN      PDNS_ADDR_ARRAY     pArray
    );

PDNS_ADDR_ARRAY
DnsAddrArray_Create(
    IN      DWORD               MaxCount
    );

PDNS_ADDR_ARRAY
DnsAddrArray_CreateFromIp4Array(
    IN      PIP4_ARRAY          pArray4
    );

PDNS_ADDR_ARRAY
DnsAddrArray_CopyAndExpand(
    IN      PDNS_ADDR_ARRAY     pArray,
    IN      DWORD               ExpandCount,
    IN      BOOL                fDeleteExisting
    );

PDNS_ADDR_ARRAY
DnsAddrArray_CreateCopy(
    IN      PDNS_ADDR_ARRAY     pArray
    );

VOID
DnsAddrArray_Clear(
    IN OUT  PDNS_ADDR_ARRAY     pArray
    );

VOID
DnsAddrArray_Reverse(
    IN OUT  PDNS_ADDR_ARRAY     pArray
    );

DNS_STATUS
DnsAddrArray_AppendArrayEx(
    IN OUT  PDNS_ADDR_ARRAY     pArray,
    IN      PDNS_ADDR_ARRAY     pAppendArray,
    IN      DWORD               AppendCount,
    IN      DWORD               Family,         OPTIONAL
    IN      DWORD               MatchFlag,      OPTIONAL
    IN      DNSADDR_SCREEN_FUNC pScreenFunc,    OPTIONAL
    IN      PDNS_ADDR           pScreenAddr     OPTIONAL
    );

DNS_STATUS
DnsAddrArray_AppendArray(
    IN OUT  PDNS_ADDR_ARRAY     pArray,
    IN      PDNS_ADDR_ARRAY     pAppendArray
    );

//
//  Address test
//

BOOL
DnsAddrArray_ContainsAddr(
    IN      PDNS_ADDR_ARRAY     pArray,
    IN      PDNS_ADDR           pAddr,
    IN      DWORD               MatchFlag
    );

BOOL
DnsAddrArray_ContainsAddrEx(
    IN      PDNS_ADDR_ARRAY     pArray,
    IN      PDNS_ADDR           pAddr,
    IN      DWORD               MatchFlag,      OPTIONAL
    IN      DNSADDR_SCREEN_FUNC pScreenFunc,    OPTIONAL
    IN      PDNS_ADDR           pScreenAddr     OPTIONAL
    );

BOOL
DnsAddrArray_ContainsIp4(
    IN      PDNS_ADDR_ARRAY     pArray,
    IN      IP4_ADDRESS         Ip4
    );

BOOL
DnsAddrArray_ContainsIp6(
    IN      PDNS_ADDR_ARRAY     pArray,
    IN      PIP6_ADDRESS        pIp6
    );

//
//  Add \ delete
//

BOOL
DnsAddrArray_AddAddr(
    IN OUT  PDNS_ADDR_ARRAY     pArray,
    IN      PDNS_ADDR           pAddr,
    IN      DWORD               Family,
    IN      DWORD               MatchFlag  OPTIONAL
    );

BOOL
DnsAddrArray_AddSockaddr(
    IN OUT  PDNS_ADDR_ARRAY     pArray,
    IN      PSOCKADDR           pSockaddr,
    IN      DWORD               Family,
    IN      DWORD               MatchFlag   OPTIONAL
    );

BOOL
DnsAddrArray_AddIp4(
    IN OUT  PDNS_ADDR_ARRAY     pArray,
    IN      IP4_ADDRESS         Ip4,
    IN      DWORD               MatchFlag   OPTIONAL
    );

BOOL
DnsAddrArray_AddIp6(
    IN OUT  PDNS_ADDR_ARRAY     pArray,
    IN      PIP6_ADDRESS        pIp6,
    IN      DWORD               ScopeId,
    IN      DWORD               MatchFlag
    );

DWORD
DnsAddrArray_DeleteAddr(
    IN OUT  PDNS_ADDR_ARRAY     pArray,
    IN      PDNS_ADDR           pAddrDelete,
    IN      DWORD               MatchFlag   OPTIONAL
    );

DWORD
DnsAddrArray_DeleteIp4(
    IN OUT  PDNS_ADDR_ARRAY     pArray,
    IN      IP4_ADDRESS         Ip4
    );

DWORD
DnsAddrArray_DeleteIp6(
    IN OUT  PDNS_ADDR_ARRAY     pArray,
    IN      PIP6_ADDRESS        Ip6
    );


//
//  Set operations
//

BOOL
DnsAddrArray_CheckAndMakeSubset(
    IN OUT  PDNS_ADDR_ARRAY     pArraySub,
    IN      PDNS_ADDR_ARRAY     pArraySuper
    );

DNS_STATUS
DnsAddrArray_Diff(
    IN      PDNS_ADDR_ARRAY     pArray1,
    IN      PDNS_ADDR_ARRAY     pArray2,
    IN      DWORD               MatchFlag,  OPTIONAL
    OUT     PDNS_ADDR_ARRAY*    ppOnlyIn1,
    OUT     PDNS_ADDR_ARRAY*    ppOnlyIn2,
    OUT     PDNS_ADDR_ARRAY*    ppIntersect
    );

BOOL
DnsAddrArray_IsIntersection(
    IN      PDNS_ADDR_ARRAY     pArray1,
    IN      PDNS_ADDR_ARRAY     pArray2,
    IN      DWORD               MatchFlag   OPTIONAL
    );

BOOL
DnsAddrArray_IsEqual(
    IN      PDNS_ADDR_ARRAY     pArray1,
    IN      PDNS_ADDR_ARRAY     pArray2,
    IN      DWORD               MatchFlag   OPTIONAL
    );

DNS_STATUS
DnsAddrArray_Union(
    IN      PDNS_ADDR_ARRAY     pArray1,
    IN      PDNS_ADDR_ARRAY     pArray2,
    OUT     PDNS_ADDR_ARRAY*    ppUnion
    );


//
//  Special case initializations
//

VOID
DnsAddrArray_InitSingleWithAddr(
    IN OUT  PDNS_ADDR_ARRAY     pArray,
    IN      PDNS_ADDR           pAddr
    );

DWORD
DnsAddrArray_InitSingleWithSockaddr(
    IN OUT  PDNS_ADDR_ARRAY     pArray,
    IN      PSOCKADDR           pSockAddr
    );

VOID
DnsAddrArray_InitSingleWithIp6(
    IN OUT  PDNS_ADDR_ARRAY     pArray,
    IN      PIP6_ADDRESS        pIp6
    );

VOID
DnsAddrArray_InitSingleWithIp4(
    IN OUT  PDNS_ADDR_ARRAY     pArray,
    IN      IP4_ADDRESS         Ip4Addr
    );

//
//  Other
//

PIP4_ARRAY
DnsAddrArray_CreateIp4Array(
    IN      PDNS_ADDR_ARRAY     pArray
    );

DWORD
DnsAddrArray_NetworkMatchIp4(
    IN      PDNS_ADDR_ARRAY     pArray,
    IN      IP4_ADDRESS         IpAddr,
    OUT     PDNS_ADDR *         ppAddr
    );


//
//  String to\from DNS_ADDR conversions
//

BOOL
Dns_StringToDnsAddr_W(
    OUT     PDNS_ADDR       pAddr,
    IN      PCWSTR          pString
    );

BOOL
Dns_StringToDnsAddr_A(
    OUT     PDNS_ADDR       pAddr,
    IN      PCSTR           pString
    );

BOOL
Dns_ReverseNameToDnsAddr_W(
    OUT     PDNS_ADDR       pAddr,
    IN      PCWSTR          pString
    );

BOOL
Dns_ReverseNameToDnsAddr_A(
    OUT     PDNS_ADDR       pAddr,
    IN      PCSTR           pString
    );


#ifdef __cplusplus
}
#endif  // __cplusplus

#endif // _DNSIP_INCLUDED_
=== C:/Users/treeman/Desktop/windows nt source code\Source\Win2K3\NT\ds\dns\dnslib\dnssec.h ===
/*++

Copyright (c) 1997-2001 Microsoft Corporation

Module Name:

    dnssec.h

Abstract:

    Domain Name System (DNS) Library

    Private security definitions.
    This header necessary to provide defs to client secure update
    routines which are in dnsapi (update.c).

Author:

    Jim Gilroy (jamesg)     November 1997

Revision History:

--*/


#ifndef _DNS_DNSSEC_INCLUDED_
#define _DNS_DNSSEC_INCLUDED_


#define SECURITY_WIN32
#include "sspi.h"
#include "issperr.h"


//
//  Context "key" for TKEYs
//

typedef struct _DNS_SECCTXT_KEY
{
    DNS_ADDR        RemoteAddr;
    PSTR            pszTkeyName;
    PSTR            pszClientContext;
    PWSTR           pwsCredKey;
}
DNS_SECCTXT_KEY, *PDNS_SECCTXT_KEY;

//
//  Security context
//

typedef struct _DnsSecurityContext
{
    struct _DnsSecurityContext * pNext;

    struct _SecHandle   hSecHandle;

    DNS_SECCTXT_KEY     Key;
    CredHandle          CredHandle;

    //  context info

    DWORD               Version;
    WORD                TkeySize;

    //  context state

    BOOL                fClient;
    BOOL                fHaveCredHandle;
    BOOL                fHaveSecHandle;
    BOOL                fNegoComplete;
    DWORD               UseCount;

    //  timeout

    DWORD               dwCreateTime;
    DWORD               dwCleanupTime;
    DWORD               dwExpireTime;
}
SEC_CNTXT, *PSEC_CNTXT;


//
//  Security session info.
//  Held only during interaction, not cached
//

typedef struct _SecPacketInfo
{
    PSEC_CNTXT          pSecContext;

    SecBuffer           RemoteBuf;
    SecBuffer           LocalBuf;

    PDNS_HEADER         pMsgHead;
    PCHAR               pMsgEnd;

    PDNS_RECORD         pTsigRR;
    PDNS_RECORD         pTkeyRR;
    PCHAR               pszContextName;

    DNS_PARSED_RR       ParsedRR;

    //  client must save signature of query to verify sig on response

    PCHAR               pQuerySig;
    WORD                QuerySigLength;

    WORD                ExtendedRcode;

    //  version on TKEY \ TSIG

    DWORD               TkeyVersion;
}
SECPACK, *PSECPACK;


#endif  // _DNS_DNSSEC_INCLUDED_
=== C:/Users/treeman/Desktop/windows nt source code\Source\Win2K3\NT\ds\dns\dnslib\dnsutil.c ===
/*++

Copyright (c) 1996-2001  Microsoft Corporation

Module Name:

    dnsutil.c

Abstract:

    Domain Name System (DNS) Library

    General DNS utilities.

Author:

    Jim Gilroy (jamesg)     Decemeber 1996

Revision History:

--*/


#include "local.h"



IP4_ADDRESS
Dns_GetNetworkMask(
    IN      IP4_ADDRESS     IpAddr
    )
/*++

Routine Description:

    Gets network mask for IP address.
    Note, this is standard IP network mask for address type,
    obviously subnetting is unknown.

Arguments:

    IpAddr -- IP to get mask for

Return Value:

    Network mask in network byte order.

--*/
{
    //  note addresses and masks are in netbyte order
    //  which we are treating as byte flipped and hence
    //  test the high bits in the low byte

    //  class A?

    if ( ! (0x80 & IpAddr) )
    {
        return( 0x000000ff );
    }

    //  class B?

    if ( ! (0x40 & IpAddr) )
    {
        return( 0x0000ffff );
    }

    //  then class C
    //  yes, there's some multicast BS out there, I don't
    //  believe it requires any special handling

    return( 0x00ffffff );
}



BOOL
Dns_AreIp4InSameDefaultNetwork(
    IN      IP4_ADDRESS     IpAddr1,
    IN      IP4_ADDRESS     IpAddr2
    )
/*++

Routine Description:

    Check if two IP4 addresses are in same default network.

    Note:  this is strictly DEFAULT network info.  It is NOT
    a statement of subnet match, but of default network match
    which will in general -- but not necessarily -- suggest
    the addresses are in a connected network.

Arguments:

    IpAddr1 -- first IP

    IpAddr2 -- second IP

Return Value:

    TRUE if in same default network.
    FALSE otherwise.

--*/
{
    IP4_ADDRESS mask;

    //
    //  note that due to the default IP classes, the mask
    //      need only be gotten for ONE IP, because there is no
    //      way to screen with the WRONG class mask on an IP
    //      and produce network address that is valid for the
    //      class
    //

    mask = Dns_GetNetworkMask( IpAddr1 );

    return( (IpAddr1 & mask) == (IpAddr2 & mask) );
}




//
//  DNS status\error mappings
//
//  DCR:  investigate tossing error mappings
//      and have all errors in Win32 system
//

typedef struct _DnsStatusStringMap
{
    DNS_STATUS  Status;
    PCHAR       String;
}
DNS_STATUS_STRING_MAP;

#define DNS_MAP_END     ((DWORD)(-1))

#define DNS_MAP_ENTRY( _ErrorCode )   _ErrorCode, #_ErrorCode


DNS_STATUS_STRING_MAP DnsStatusStringMappings[] =
{
    //
    //  Response codes
    //

    DNS_ERROR_RCODE_NO_ERROR                ,"ERROR_SUCCESS",
    DNS_ERROR_RCODE_FORMAT_ERROR            ,"RCODE_FORMAT_ERROR",
    DNS_ERROR_RCODE_SERVER_FAILURE          ,"RCODE_SERVER_FAILURE",
    DNS_ERROR_RCODE_NAME_ERROR              ,"RCODE_NAME_ERROR",
    DNS_ERROR_RCODE_NOT_IMPLEMENTED         ,"RCODE_NOT_IMPLEMENTED",
    DNS_ERROR_RCODE_REFUSED                 ,"RCODE_REFUSED",
    DNS_ERROR_RCODE_YXDOMAIN                ,"RCODE_YXDOMAIN",
    DNS_ERROR_RCODE_YXRRSET                 ,"RCODE_YXRRSET",
    DNS_ERROR_RCODE_NXRRSET                 ,"RCODE_NXRRSET",
    DNS_ERROR_RCODE_NOTAUTH                 ,"RCODE_NOTAUTH",
    DNS_ERROR_RCODE_NOTZONE                 ,"RCODE_NOTZONE",
    DNS_ERROR_RCODE_BADSIG                  ,"RCODE_BADSIG",
    DNS_ERROR_RCODE_BADKEY                  ,"RCODE_BADKEY",
    DNS_ERROR_RCODE_BADTIME                 ,"RCODE_BADTIME",

    //
    //  Packet format
    //

    DNS_INFO_NO_RECORDS                     ,"DNS_INFO_NO_RECORDS",
    DNS_ERROR_BAD_PACKET                    ,"DNS_ERROR_BAD_PACKET",
    DNS_ERROR_NO_PACKET                     ,"DNS_ERROR_NO_PACKET",
    DNS_ERROR_RCODE                         ,"DNS_ERROR_RCODE",
    DNS_ERROR_UNSECURE_PACKET               ,"DNS_ERROR_UNSECURE_PACKET",

    //
    //  General API errors
    //

    DNS_ERROR_INVALID_NAME                  ,"ERROR_INVALID_NAME",
    DNS_ERROR_INVALID_DATA                  ,"ERROR_INVALID_DATA",
    DNS_ERROR_INVALID_TYPE                  ,"ERROR_INVALID_TYPE",
    DNS_ERROR_NOT_ALLOWED_UNDER_DELEGATION  ,"DNS_ERROR_NOT_ALLOWED_UNDER_DELEGATION",
    DNS_ERROR_INVALID_IP_ADDRESS            ,"DNS_ERROR_INVALID_IP_ADDRESS",
    DNS_ERROR_INVALID_PROPERTY              ,"DNS_ERROR_INVALID_PROPERTY",
    DNS_ERROR_TRY_AGAIN_LATER               ,"DNS_ERROR_TRY_AGAIN_LATER",
    DNS_ERROR_NOT_UNIQUE                    ,"DNS_ERROR_NOT_UNIQUE",
    DNS_ERROR_NON_RFC_NAME                  ,"DNS_ERROR_NON_RFC_NAME",
    DNS_STATUS_FQDN                         ,"DNS_STATUS_FQDN",
    DNS_STATUS_DOTTED_NAME                  ,"DNS_STATUS_DOTTED_NAME",
    DNS_STATUS_SINGLE_PART_NAME             ,"DNS_STATUS_SINGLE_PART_NAME",
    DNS_ERROR_INVALID_NAME_CHAR             ,"DNS_ERROR_INVALID_NAME_CHAR",
    DNS_ERROR_NUMERIC_NAME                  ,"DNS_ERROR_NUMERIC_NAME",

    DNS_MAP_ENTRY( DNS_ERROR_CANNOT_FIND_ROOT_HINTS ),
    DNS_MAP_ENTRY( DNS_ERROR_INCONSISTENT_ROOT_HINTS ),

    //
    //  Server errors
    //

    DNS_MAP_ENTRY( DNS_ERROR_NOT_ALLOWED_ON_ROOT_SERVER ),

    //
    //  Zone errors
    //

    DNS_ERROR_ZONE_DOES_NOT_EXIST           ,"DNS_ERROR_ZONE_DOES_NOT_EXIST",
    DNS_ERROR_NO_ZONE_INFO                  ,"DNS_ERROR_NO_ZONE_INFO",
    DNS_ERROR_INVALID_ZONE_OPERATION        ,"DNS_ERROR_INVALID_ZONE_OPERATION",
    DNS_ERROR_ZONE_CONFIGURATION_ERROR      ,"DNS_ERROR_ZONE_CONFIGURATION_ERROR",
    DNS_ERROR_ZONE_HAS_NO_SOA_RECORD        ,"DNS_ERROR_ZONE_HAS_NO_SOA_RECORD",
    DNS_ERROR_ZONE_HAS_NO_NS_RECORDS        ,"DNS_ERROR_ZONE_HAS_NO_NS_RECORDS",
    DNS_ERROR_ZONE_LOCKED                   ,"DNS_ERROR_ZONE_LOCKED",

    DNS_ERROR_ZONE_CREATION_FAILED          ,"DNS_ERROR_ZONE_CREATION_FAILED",
    DNS_ERROR_ZONE_ALREADY_EXISTS           ,"DNS_ERROR_ZONE_ALREADY_EXISTS",
    DNS_ERROR_AUTOZONE_ALREADY_EXISTS       ,"DNS_ERROR_AUTOZONE_ALREADY_EXISTS",
    DNS_ERROR_INVALID_ZONE_TYPE             ,"DNS_ERROR_INVALID_ZONE_TYPE",
    DNS_ERROR_SECONDARY_REQUIRES_MASTER_IP  ,"DNS_ERROR_SECONDARY_REQUIRES_MASTER_IP",

    DNS_MAP_ENTRY( DNS_ERROR_ZONE_REQUIRES_MASTER_IP ),
    DNS_MAP_ENTRY( DNS_ERROR_ZONE_IS_SHUTDOWN ),

    DNS_ERROR_ZONE_NOT_SECONDARY            ,"DNS_ERROR_ZONE_NOT_SECONDARY",
    DNS_ERROR_NEED_SECONDARY_ADDRESSES      ,"DNS_ERROR_NEED_SECONDARY_ADDRESSES",
    DNS_ERROR_WINS_INIT_FAILED              ,"DNS_ERROR_WINS_INIT_FAILED",
    DNS_ERROR_NEED_WINS_SERVERS             ,"DNS_ERROR_NEED_WINS_SERVERS",
    DNS_ERROR_NBSTAT_INIT_FAILED            ,"DNS_ERROR_NBSTAT_INIT_FAILED",
    DNS_ERROR_SOA_DELETE_INVALID            ,"DNS_ERROR_SOA_DELETE_INVALID",

    DNS_MAP_ENTRY( DNS_ERROR_FORWARDER_ALREADY_EXISTS ),

    //
    //  Datafile errors
    //

    DNS_ERROR_PRIMARY_REQUIRES_DATAFILE     ,"DNS_ERROR_PRIMARY_REQUIRES_DATAFILE",
    DNS_ERROR_INVALID_DATAFILE_NAME         ,"DNS_ERROR_INVALID_DATAFILE_NAME",
    DNS_ERROR_DATAFILE_OPEN_FAILURE         ,"DNS_ERROR_DATAFILE_OPEN_FAILURE",
    DNS_ERROR_FILE_WRITEBACK_FAILED         ,"DNS_ERROR_FILE_WRITEBACK_FAILED",
    DNS_ERROR_DATAFILE_PARSING              ,"DNS_ERROR_DATAFILE_PARSING",

    //
    //  Database errors
    //

    DNS_ERROR_RECORD_DOES_NOT_EXIST         ,"DNS_ERROR_RECORD_DOES_NOT_EXIST",
    DNS_ERROR_RECORD_FORMAT                 ,"DNS_ERROR_RECORD_FORMAT",
    DNS_ERROR_NODE_CREATION_FAILED          ,"DNS_ERROR_NODE_CREATION_FAILED",
    DNS_ERROR_UNKNOWN_RECORD_TYPE           ,"DNS_ERROR_UNKNOWN_RECORD_TYPE",
    DNS_ERROR_RECORD_TIMED_OUT              ,"DNS_ERROR_RECORD_TIMED_OUT",

    DNS_ERROR_NAME_NOT_IN_ZONE              ,"DNS_ERROR_NAME_NOT_IN_ZONE",
    DNS_ERROR_CNAME_LOOP                    ,"DNS_ERROR_CNAME_LOOP",
    DNS_ERROR_NODE_IS_CNAME                 ,"DNS_ERROR_NODE_IS_CNAME",
    DNS_ERROR_CNAME_COLLISION               ,"DNS_ERROR_CNAME_COLLISION",
    DNS_ERROR_RECORD_ONLY_AT_ZONE_ROOT      ,"DNS_ERROR_RECORD_ONLY_AT_ZONE_ROOT",
    DNS_ERROR_RECORD_ALREADY_EXISTS         ,"DNS_ERROR_RECORD_ALREADY_EXISTS",
    DNS_ERROR_SECONDARY_DATA                ,"DNS_ERROR_SECONDARY_DATA",
    DNS_ERROR_NO_CREATE_CACHE_DATA          ,"DNS_ERROR_NO_CREATE_CACHE_DATA",
    DNS_ERROR_NAME_DOES_NOT_EXIST           ,"DNS_ERROR_NAME_DOES_NOT_EXIST",

    DNS_WARNING_PTR_CREATE_FAILED           ,"DNS_WARNING_PTR_CREATE_FAILED",
    DNS_WARNING_DOMAIN_UNDELETED            ,"DNS_WARNING_DOMAIN_UNDELETED",

    DNS_ERROR_DS_UNAVAILABLE                ,"DNS_ERROR_DS_UNAVAILABLE",
    DNS_ERROR_DS_ZONE_ALREADY_EXISTS        ,"DNS_ERROR_DS_ZONE_ALREADY_EXISTS",

    DNS_MAP_ENTRY( ERROR_DS_COULDNT_CONTACT_FSMO ),

    //
    //  Operation errors
    //

    DNS_INFO_AXFR_COMPLETE                  ,"DNS_INFO_AXFR_COMPLETE",
    DNS_ERROR_AXFR                          ,"DNS_ERROR_AXFR",
    DNS_INFO_ADDED_LOCAL_WINS               ,"DNS_INFO_ADDED_LOCAL_WINS",

    //
    //  Secure update
    //
    DNS_STATUS_CONTINUE_NEEDED              ,"DNS_STATUS_CONTINUE_NEEDED",

    //
    //  Client setup errors
    //

    DNS_ERROR_NO_TCPIP                      ,"DNS_ERROR_NO_TCPIP",
    DNS_ERROR_NO_DNS_SERVERS                ,"DNS_ERROR_NO_DNS_SERVERS",

    //
    //  Directory partition errors
    //

    DNS_MAP_ENTRY( DNS_ERROR_DP_DOES_NOT_EXIST ),
    DNS_MAP_ENTRY( DNS_ERROR_DP_ALREADY_EXISTS ),
    DNS_MAP_ENTRY( DNS_ERROR_DP_NOT_ENLISTED ),
    DNS_MAP_ENTRY( DNS_ERROR_DP_ALREADY_ENLISTED ),
    DNS_MAP_ENTRY( DNS_ERROR_DP_NOT_AVAILABLE ),
    DNS_MAP_ENTRY( DNS_ERROR_DP_FSMO_ERROR ),

    //
    //  Throw in common Win32 errors
    //

    ERROR_FILE_NOT_FOUND                    ,"ERROR_FILE_NOT_FOUND",
    ERROR_ACCESS_DENIED                     ,"ERROR_ACCESS_DENIED",
    ERROR_NOT_ENOUGH_MEMORY                 ,"ERROR_NOT_ENOUGH_MEMORY",
    ERROR_BAD_FORMAT                        ,"ERROR_BAD_FORMAT",
    ERROR_INVALID_DATA                      ,"ERROR_INVALID_DATA",
    ERROR_OUTOFMEMORY                       ,"ERROR_OUTOFMEMORY",
    ERROR_SHARING_VIOLATION                 ,"ERROR_SHARING_VIOLATION",
    ERROR_NOT_SUPPORTED                     ,"ERROR_NOT_SUPPORTED",
    ERROR_INVALID_PARAMETER                 ,"ERROR_INVALID_PARAMETER",
    ERROR_INVALID_NAME                      ,"ERROR_INVALID_NAME",
    ERROR_BAD_ARGUMENTS                     ,"ERROR_BAD_ARGUMENTS",
    ERROR_BUSY                              ,"ERROR_BUSY",
    ERROR_ALREADY_EXISTS                    ,"ERROR_ALREADY_EXISTS",
    ERROR_LOCKED                            ,"ERROR_LOCKED",
    ERROR_MORE_DATA                         ,"ERROR_MORE_DATA",
    ERROR_INVALID_FLAGS                     ,"ERROR_INVALID_FLAGS",
    ERROR_FILE_INVALID                      ,"ERROR_FILE_INVALID",
    ERROR_TIMEOUT                           ,"ERROR_TIMEOUT",

    //
    //  RPC errors
    //

    RPC_S_SERVER_UNAVAILABLE                ,"RPC_S_SERVER_UNAVAILABLE",
    RPC_S_INVALID_NET_ADDR                  ,"RPC_S_INVALID_NET_ADDR",
    EPT_S_NOT_REGISTERED                    ,"EPT_S_NOT_REGISTERED",
    EPT_S_NOT_REGISTERED                    ,"EPT_S_NOT_REGISTERED",

    DNS_MAP_ENTRY( RPC_S_CALL_CANCELLED ),

    //
    //  others:
    //

    ERROR_PATH_NOT_FOUND                    ,"ERROR_PATH_NOT_FOUND",
    ERROR_INVALID_ACCESS                    ,"ERROR_INVALID_ACCESS",
    ERROR_INVALID_DRIVE                     ,"ERROR_INVALID_DRIVE",
    ERROR_WRITE_PROTECT                     ,"ERROR_WRITE_PROTECT",
    ERROR_SHARING_VIOLATION                 ,"ERROR_SHARING_VIOLATION",
    ERROR_HANDLE_DISK_FULL                  ,"ERROR_HANDLE_DISK_FULL",
    ERROR_NOT_SUPPORTED                     ,"ERROR_NOT_SUPPORTED",
    ERROR_REM_NOT_LIST                      ,"ERROR_REM_NOT_LIST",
    ERROR_DUP_NAME                          ,"ERROR_DUP_NAME",
    ERROR_NETNAME_DELETED                   ,"ERROR_NETNAME_DELETED",
    ERROR_FILE_EXISTS                       ,"ERROR_FILE_EXISTS",
    ERROR_NET_WRITE_FAULT                   ,"ERROR_NET_WRITE_FAULT",
    ERROR_INVALID_SECURITY_DESCR            ,"ERROR_INVALID_SECURITY_DESCR",

    //
    // winsock
    //

    WSAEINTR                     ,"WSAEINTR                   ",
    WSAEBADF                     ,"WSAEBADF                   ",
    WSAEACCES                    ,"WSAEACCES                  ",
    WSAEFAULT                    ,"WSAEFAULT                  ",
    WSAEINVAL                    ,"WSAEINVAL                  ",
    WSAEMFILE                    ,"WSAEMFILE                  ",
    WSAEWOULDBLOCK               ,"WSAEWOULDBLOCK             ",
    WSAEINPROGRESS               ,"WSAEINPROGRESS             ",
    WSAEALREADY                  ,"WSAEALREADY                ",
    WSAENOTSOCK                  ,"WSAENOTSOCK                ",
    WSAEDESTADDRREQ              ,"WSAEDESTADDRREQ            ",
    WSAEMSGSIZE                  ,"WSAEMSGSIZE                ",
    WSAEPROTOTYPE                ,"WSAEPROTOTYPE              ",
    WSAENOPROTOOPT               ,"WSAENOPROTOOPT             ",
    WSAEPROTONOSUPPORT           ,"WSAEPROTONOSUPPORT         ",
    WSAESOCKTNOSUPPORT           ,"WSAESOCKTNOSUPPORT         ",
    WSAEOPNOTSUPP                ,"WSAEOPNOTSUPP              ",
    WSAEPFNOSUPPORT              ,"WSAEPFNOSUPPORT            ",
    WSAEAFNOSUPPORT              ,"WSAEAFNOSUPPORT            ",
    WSAEADDRINUSE                ,"WSAEADDRINUSE              ",
    WSAEADDRNOTAVAIL             ,"WSAEADDRNOTAVAIL           ",
    WSAENETDOWN                  ,"WSAENETDOWN                ",
    WSAENETUNREACH               ,"WSAENETUNREACH             ",
    WSAENETRESET                 ,"WSAENETRESET               ",
    WSAECONNABORTED              ,"WSAECONNABORTED            ",
    WSAECONNRESET                ,"WSAECONNRESET              ",
    WSAENOBUFS                   ,"WSAENOBUFS                 ",
    WSAEISCONN                   ,"WSAEISCONN                 ",
    WSAENOTCONN                  ,"WSAENOTCONN                ",
    WSAESHUTDOWN                 ,"WSAESHUTDOWN               ",
    WSAETOOMANYREFS              ,"WSAETOOMANYREFS            ",
    WSAETIMEDOUT                 ,"WSAETIMEDOUT               ",
    WSAECONNREFUSED              ,"WSAECONNREFUSED            ",
    WSAELOOP                     ,"WSAELOOP                   ",
    WSAENAMETOOLONG              ,"WSAENAMETOOLONG            ",
    WSAEHOSTDOWN                 ,"WSAEHOSTDOWN               ",
    WSAEHOSTUNREACH              ,"WSAEHOSTUNREACH            ",
    WSAENOTEMPTY                 ,"WSAENOTEMPTY               ",
    WSAEPROCLIM                  ,"WSAEPROCLIM                ",
    WSAEUSERS                    ,"WSAEUSERS                  ",
    WSAEDQUOT                    ,"WSAEDQUOT                  ",
    WSAESTALE                    ,"WSAESTALE                  ",
    WSAEREMOTE                   ,"WSAEREMOTE                 ",
    WSASYSNOTREADY               ,"WSASYSNOTREADY             ",
    WSAVERNOTSUPPORTED           ,"WSAVERNOTSUPPORTED         ",
    WSANOTINITIALISED            ,"WSANOTINITIALISED          ",
    WSAEDISCON                   ,"WSAEDISCON                 ",
    WSAENOMORE                   ,"WSAENOMORE                 ",
    WSAECANCELLED                ,"WSAECANCELLED              ",
    WSAEINVALIDPROCTABLE         ,"WSAEINVALIDPROCTABLE       ",
    WSAEINVALIDPROVIDER          ,"WSAEINVALIDPROVIDER        ",
    WSAEPROVIDERFAILEDINIT       ,"WSAEPROVIDERFAILEDINIT     ",
    WSASYSCALLFAILURE            ,"WSASYSCALLFAILURE          ",
    WSASERVICE_NOT_FOUND         ,"WSASERVICE_NOT_FOUND       ",
    WSATYPE_NOT_FOUND            ,"WSATYPE_NOT_FOUND          ",
    WSA_E_NO_MORE                ,"WSA_E_NO_MORE              ",
    WSA_E_CANCELLED              ,"WSA_E_CANCELLED            ",
    WSAEREFUSED                  ,"WSAEREFUSED                ",
    WSAHOST_NOT_FOUND            ,"WSAHOST_NOT_FOUND          ",
    WSATRY_AGAIN                 ,"WSATRY_AGAIN               ",
    WSANO_RECOVERY               ,"WSANO_RECOVERY             ",
    WSANO_DATA                   ,"WSANO_DATA                 ",
    WSA_QOS_RECEIVERS            ,"WSA_QOS_RECEIVERS          ",
    WSA_QOS_SENDERS              ,"WSA_QOS_SENDERS            ",
    WSA_QOS_NO_SENDERS           ,"WSA_QOS_NO_SENDERS         ",
    WSA_QOS_NO_RECEIVERS         ,"WSA_QOS_NO_RECEIVERS       ",
    WSA_QOS_REQUEST_CONFIRMED    ,"WSA_QOS_REQUEST_CONFIRMED  ",
    WSA_QOS_ADMISSION_FAILURE    ,"WSA_QOS_ADMISSION_FAILURE  ",
    WSA_QOS_POLICY_FAILURE       ,"WSA_QOS_POLICY_FAILURE     ",
    WSA_QOS_BAD_STYLE            ,"WSA_QOS_BAD_STYLE          ",
    WSA_QOS_BAD_OBJECT           ,"WSA_QOS_BAD_OBJECT         ",
    WSA_QOS_TRAFFIC_CTRL_ERROR   ,"WSA_QOS_TRAFFIC_CTRL_ERROR ",
    WSA_QOS_GENERIC_ERROR        ,"WSA_QOS_GENERIC_ERROR      ",
    WSA_QOS_ESERVICETYPE         ,"WSA_QOS_ESERVICETYPE       ",
    WSA_QOS_EFLOWSPEC            ,"WSA_QOS_EFLOWSPEC          ",
    WSA_QOS_EPROVSPECBUF         ,"WSA_QOS_EPROVSPECBUF       ",
    WSA_QOS_EFILTERSTYLE         ,"WSA_QOS_EFILTERSTYLE       ",
    WSA_QOS_EFILTERTYPE          ,"WSA_QOS_EFILTERTYPE        ",
    WSA_QOS_EFILTERCOUNT         ,"WSA_QOS_EFILTERCOUNT       ",
    WSA_QOS_EOBJLENGTH           ,"WSA_QOS_EOBJLENGTH         ",
    WSA_QOS_EFLOWCOUNT           ,"WSA_QOS_EFLOWCOUNT         ",
    WSA_QOS_EUNKOWNPSOBJ         ,"WSA_QOS_EUNKOWNPSOBJ       ",
    WSA_QOS_EPOLICYOBJ           ,"WSA_QOS_EPOLICYOBJ         ",
    WSA_QOS_EFLOWDESC            ,"WSA_QOS_EFLOWDESC          ",
    WSA_QOS_EPSFLOWSPEC          ,"WSA_QOS_EPSFLOWSPEC        ",
    WSA_QOS_EPSFILTERSPEC        ,"WSA_QOS_EPSFILTERSPEC      ",
    WSA_QOS_ESDMODEOBJ           ,"WSA_QOS_ESDMODEOBJ         ",
    WSA_QOS_ESHAPERATEOBJ        ,"WSA_QOS_ESHAPERATEOBJ      ",
    WSA_QOS_RESERVED_PETYPE      ,"WSA_QOS_RESERVED_PETYPE    ",

    //
    //  RPC errors
    //

    RPC_S_SERVER_TOO_BUSY        ,"RPC_S_SERVER_TOO_BUSY      ",

    DNS_MAP_END                  ,"UNKNOWN",
};



PCHAR
_fastcall
Dns_StatusString(
    IN  DNS_STATUS  Status
    )
/*++

Routine Description:

    Map DNS error code to status string.

Arguments:

    Status -- status code to check

Return Value:

    DNS error string for error code.

--*/
{
    INT         i = 0;
    DNS_STATUS  mappedStatus;

    while ( 1 )
    {
        mappedStatus = DnsStatusStringMappings[i].Status;
        if ( mappedStatus == Status || mappedStatus == DNS_MAP_END )
        {
            return( DnsStatusStringMappings[i].String );
        }
        i++;
    }

    DNS_ASSERT( FALSE );
    return( NULL );     // make compiler happy
}



DNS_STATUS
_fastcall
Dns_MapRcodeToStatus(
    IN  BYTE    ResponseCode
    )
/*++

Routine Description:

    Map response code to DNS error code.

Arguments:

    ResponseCode - response code to get error for

Return Value:

    DNS error code for response code.

--*/
{
    if ( !ResponseCode )
    {
        return( ERROR_SUCCESS );
    }
    else
    {
        return( DNS_ERROR_MASK + ((DWORD) ResponseCode) );
    }
}



BYTE
_fastcall
Dns_IsStatusRcode(
    IN  DNS_STATUS  Status
    )
/*++

Routine Description:

    Determine if status is RCODE and if so return it.

Arguments:

    Status -- status code to check

Return Value:

    Response code corresponding to status, if found.
    Zero otherwise.

--*/
{
    if ( Status >= DNS_ERROR_RCODE_FORMAT_ERROR &&
        Status <= DNS_ERROR_RCODE_LAST )
    {
        return( (BYTE) (DNS_ERROR_MASK ^ Status) );
    }
    else
    {
        return( 0 );
    }
}



DNS_STATUS
Dns_CreateTypeArrayFromMultiTypeString(
    IN      LPSTR           pchMultiTypeString,
    OUT     INT *           piTypeCount,
    OUT     PWORD *         ppwTypeArray
    )
/*++

Routine Description:

    Allocates an array of types from a string containing DNS types
    in numeric and/or string format separated by whitespace.

Arguments:

    pBuffer -- string buffer with list of numeric or alpha types

    piTypeCount -- number of types parsed written here

    ppwTypeArray -- ptr to allocated array of types written here
        this ptr must be freed even if the number of types returned
        is zero

Return Value:

    ERROR_SUCCESS

--*/
{
    PCHAR       psz;
    DWORD       argc;
    PCHAR       argv[ 50 ];
    DWORD       idx;

    ASSERT( pchMultiTypeString );
    ASSERT( piTypeCount );
    ASSERT( ppwTypeArray );

    *piTypeCount = 0;

    //
    //  Allocate array: be cheap and assume max # of types in string
    //  is twice the length of the string, e.g. "1 2 3 4 5".
    //

    *ppwTypeArray = ALLOCATE_HEAP(
        ( strlen( pchMultiTypeString ) / 2 + 2 ) * sizeof( WORD ) );
    if ( !*ppwTypeArray )
    {
        return DNS_ERROR_NO_MEMORY;
    }

    //
    //  Parse the string.
    //

    argc = Dns_TokenizeStringA(
                pchMultiTypeString,
                argv,
                sizeof( argv ) / sizeof( PCHAR ) );

    for ( idx = 0; idx < argc; ++idx )
    {
        if ( isdigit( argv[ idx ][ 0 ] ) )
        {
            ( *ppwTypeArray )[ *piTypeCount ] =
                ( WORD ) strtol( argv[ idx ], NULL, 0 );
        }
        else
        {
            ( *ppwTypeArray )[ *piTypeCount ] = Dns_RecordTypeForName(
                                                    argv[ idx ],
                                                    0 );    //  string length
        }
        if ( ( *ppwTypeArray )[ *piTypeCount ] != 0 )
        {
            ++*piTypeCount;
        }
    }

    return ERROR_SUCCESS;
}   //  Dns_CreateTypeArrayFromMultiTypeString
                                    


LPSTR
Dns_CreateMultiTypeStringFromTypeArray(
    IN      INT             iTypeCount,
    IN      PWORD           ppwTypeArray,
    IN      CHAR            chSeparator     OPTIONAL
    )
/*++

Routine Description:

    Allocate a string and write the types in the array in string format
    separated by the specified separator or by a space char.

Arguments:

    iTypeCount -- number of types in the array

    ppwTypeArray -- ptr to array of types 

    chSeparator -- string separator or zero for the default separator


Return Value:

    ERROR_SUCCESS

--*/
{
    LPSTR       pszTypes;
    INT         idx;
    LPSTR       psz;

    ASSERT( ppwTypeArray );

    //
    //  Allocate array: be cheap and assume 10 chars per element.
    //

    psz = pszTypes = ALLOCATE_HEAP( iTypeCount * 10 * sizeof( CHAR ) );
    if ( !psz )
    {
        return NULL;
    }

    //
    //  Output type strings.
    //

    for ( idx = 0; idx < iTypeCount; ++idx )
    {
        PCHAR   pszThisType;
        
        pszThisType = Dns_RecordStringForType( ppwTypeArray[ idx ] );
        if ( !pszThisType )
        {
            continue;
        }

        strcpy( psz, pszThisType );
        psz += strlen( pszThisType );
        *psz++ = chSeparator ? chSeparator : ' ';
    }

    *psz = '\0';    //  NULL terminate the string
    return pszTypes;
}   //  Dns_CreateMultiTypeStringFromTypeArray
                                    
//
//  End dnsutil.c
//
=== C:/Users/treeman/Desktop/windows nt source code\Source\Win2K3\NT\ds\dns\dnslib\heapdbg.c ===
/*++

Copyright (c) 1995-2001 Microsoft Corporation

Module Name:

    heapdbg.c

Abstract:

    Domain Name System (DNS) Library

    Heap debugging routines.

Author:

    Jim Gilroy (jamesg)    January 31, 1995

Revision History:

--*/


#include "local.h"
#include "heapdbg.h"


//
//  locking
//

#define LOCK_HEAP(p)    EnterCriticalSection( &p->ListCs )
#define UNLOCK_HEAP(p)  LeaveCriticalSection( &p->ListCs )


//
//  Heap
//
//  Debug heap routines allow heap to be specified by caller of
//  each routine, or by having heap global.
//  If global, the heap handle may be supplied to initialization
//  routine OR created internally.
//

#define HEAP_DBG_DEFAULT_CREATE_FLAGS   \
            (   HEAP_GROWABLE |                 \
                HEAP_GENERATE_EXCEPTIONS |      \
                HEAP_TAIL_CHECKING_ENABLED |    \
                HEAP_FREE_CHECKING_ENABLED |    \
                HEAP_CREATE_ALIGN_16 |          \
                HEAP_CLASS_1 )

//
//  Dnslib using this heap
//

PHEAP_BLOB  g_pDnslibHeapBlob;

HEAP_BLOB   g_DnslibHeapBlob;


//
//  Heap Header / Trailer Flags
//

#define HEAP_CODE          0xdddddddd
#define HEAP_CODE_ACTIVE   0xaaaaaaaa
#define HEAP_CODE_FREE     0xeeeeeeee

//
//  Heap Trailer from Header
//

#define HEAP_TRAILER(_head_)            \
    ( (PHEAP_TRAILER) (                 \
            (PCHAR)(_head_)             \
            + (_head_)->AllocSize       \
            - sizeof(HEAP_TRAILER) ) )


//
//  Private protos
//

VOID
DbgHeapValidateHeader(
    IN      PHEAP_HEADER    h
    );



//
//  Private utilities
//

INT
DbgHeapFindAllocSize(
    IN      INT             iRequestSize
    )
/*++

Routine Description:

    Determines actual size of debug alloc.

    Adds in sizes of DWORD aligned header and trailer.

Arguments:

    iRequestSize   - requested allocation size

Return Value:

    None

--*/
{
    register INT imodSize;

    //
    //  find DWORD multiple size of original alloc,
    //  this is required so debug trailer will be DWORD aligned
    //

    imodSize = iRequestSize % sizeof(DWORD);
    if ( imodSize )
    {
        imodSize = sizeof(DWORD) - imodSize;
    }

    imodSize += iRequestSize + sizeof(HEAP_HEADER) + sizeof(HEAP_TRAILER);

    ASSERT( ! (imodSize % sizeof(DWORD)) );

    return( imodSize );
}



PVOID
DbgHeapSetHeaderAlloc(
    IN OUT  PHEAP_BLOB      pHeap,
    IN OUT  PHEAP_HEADER    h,
    IN      INT             iSize,
    IN      LPSTR           pszFile,
    IN      DWORD           dwLine
    )
/*++

Routine Description:

    Sets/Resets heap globals and heap header info.

Arguments:

    h       - ptr to new memory block

    iSize   - size allocated

Return Value:

    None

--*/
{
    PHEAP_TRAILER   t;
    INT             allocSize;

    ASSERT( iSize > 0 );

    //
    //  determine actual alloc
    //

    allocSize = DbgHeapFindAllocSize( iSize );

    //
    //  update heap info globals
    //

    pHeap->AllocMem   += allocSize;
    pHeap->CurrentMem += allocSize;
    pHeap->AllocCount++;
    pHeap->CurrentCount++;

    //
    //  fill in header
    //

    h->HeapCodeBegin    = HEAP_CODE;
    h->AllocCount       = pHeap->AllocCount;
    h->AllocSize        = allocSize;
    h->RequestSize      = iSize;

    h->LineNo           = dwLine;
    h->FileName         = pszFile;

#if 0
    allocSize = strlen(pszFile) - HEAP_HEADER_FILE_SIZE;
    if ( allocSize > 0 )
    {
        pszFile = &pszFile[ allocSize ];
    }
    strncpy(
        h->FileName,
        pszFile,
        HEAP_HEADER_FILE_SIZE );
#endif

    h->AllocTime        = GetCurrentTime();
    h->CurrentMem       = pHeap->CurrentMem;
    h->CurrentCount     = pHeap->CurrentCount;
    h->HeapCodeEnd      = HEAP_CODE_ACTIVE;

    //
    //  fill in trailer
    //

    t = HEAP_TRAILER( h );
    t->HeapCodeBegin    = h->HeapCodeBegin;
    t->AllocCount       = h->AllocCount;
    t->AllocSize        = h->AllocSize;
    t->HeapCodeEnd      = h->HeapCodeEnd;

    //
    //  attach to alloc list
    //

    LOCK_HEAP(pHeap);
    InsertTailList( &pHeap->ListHead, &h->ListEntry );
    UNLOCK_HEAP(pHeap);

    //
    //  return ptr to user memory
    //      - first byte past header
    //

    return( h+1 );
}



PHEAP_HEADER
DbgHeapSetHeaderFree(
    IN OUT  PHEAP_BLOB      pHeap,
    IN OUT  PVOID           pMem
    )
/*++

Routine Description:

    Resets heap globals and heap header info for free.

Arguments:

    pMem - ptr to user memory to free

Return Value:

    Ptr to block to be freed.

--*/
{
    register PHEAP_HEADER h;

    //
    //  validate memory block -- get ptr to header
    //

    h = Dns_DbgHeapValidateMemory( pMem, TRUE );

    //
    //  get blob if not passed in
    //

    if ( !pHeap )
    {
        pHeap = h->pHeap;
    }

    //
    //  remove from current allocs list
    //

    LOCK_HEAP(pHeap);

    RemoveEntryList( &h->ListEntry );

    UNLOCK_HEAP(pHeap);

    //
    //  update heap info globals
    //

    pHeap->CurrentMem      -= h->AllocSize;
    pHeap->FreeMem    += h->AllocSize;
    pHeap->FreeCount++;
    pHeap->CurrentCount--;

    //
    //  reset header
    //

    h->HeapCodeEnd = HEAP_CODE_FREE;
    HEAP_TRAILER(h)->HeapCodeBegin = HEAP_CODE_FREE;

    //
    //  return ptr to block to be freed
    //

    return( h );
}



//
//  Heap Init\Cleanup
//

DNS_STATUS
Dns_HeapInitialize(
    OUT     PHEAP_BLOB      pHeap,
    IN      HANDLE          hHeap,
    IN      DWORD           dwCreateFlags,
    IN      BOOL            fUseHeaders,
    IN      BOOL            fResetDnslib,
    IN      BOOL            fFullHeapChecks,
    IN      DWORD           dwException,
    IN      DWORD           dwDefaultFlags,
    IN      PSTR            pszDefaultFileName,
    IN      DWORD           dwDefaultFileLine
    )
/*++

Routine Description:

    Initialize heap debugging.

    MUST call this routine before using DbgHeapMessage routines.

Arguments:

    pHeap -- heap blob to setup

    hHeap -- heap to use

    dwCreateFlags   -- flags to RtlCreateHeap() if creating

    fUseHeaders     -- use headers and trailers for full debug

    fResetDnslib    -- reset dnslib heap to use these routines

    fFullHeapChecks -- flag, TRUE for full heap checks

    dwException     -- exception to raise if out of heap

    dwDefaultFlags  -- heap flags for simple alloc\free

    pszDefaultFileName -- file name for simple alloc\free

    dwDefaultFileLine -- file line# for simple alloc\free

Return Value:

    None.

--*/
{
    DNSDBG( TRACE, (
        "Dns_DbgHeapInit( %p )\n",
        pHeap ));

    //
    //  zero heap blob
    //

    RtlZeroMemory(
        pHeap,
        sizeof(*pHeap) );

    //  alloc list
    //      - alloc list head
    //      - critical section to protect list operations

    InitializeListHead( &pHeap->ListHead );
    if ( fUseHeaders )
    {
        DNS_STATUS  status = RtlInitializeCriticalSection( &pHeap->ListCs );
        if ( status != NO_ERROR )
        {
            return  status;
        }
    }

    //
    //  heap
    //  can either
    //      - always get heap in each call
    //      - use heap caller supplies here
    //      - create a heap here
    //
    //  to use simple dnslib compatible calls we must have
    //  a known heap, so must get one created here
    //  DCR:  not sure this is TRUE, process heap may work
    //      g_hDnsHeap left NULL
    //

    if ( hHeap )
    {
        pHeap->hHeap = hHeap;
    }
    else
    {
        pHeap->hHeap = RtlCreateHeap(
                            dwCreateFlags
                                ? dwCreateFlags
                                : HEAP_DBG_DEFAULT_CREATE_FLAGS,
                            NULL,           // no base specified
                            0,              // default reserve size
                            0,              // default commit size
                            NULL,           // no lock
                            NULL            // no parameters
                            );
        if ( !pHeap->hHeap )
        {
            return  DNS_ERROR_NO_MEMORY;
        }
        pHeap->fCreated = TRUE;
    }
    pHeap->Tag = HEAP_CODE_ACTIVE;

    //  set globals
    //      - full heap checks before all heap operations?
    //      - raise exception on alloc failure?

    pHeap->fHeaders         = fUseHeaders;
    pHeap->fCheckAll        = fFullHeapChecks;
    pHeap->FailureException = dwException;

    //  set globals for simple allocator

    pHeap->DefaultFlags     = dwDefaultFlags;
    pHeap->pszDefaultFile   = pszDefaultFileName;
    pHeap->DefaultLine      = dwDefaultFileLine;

    //  reset dnslib heap routines to use debug heap

    if ( fResetDnslib )
    {
        if ( fUseHeaders )
        {
            Dns_LibHeapReset(
                Dns_DbgHeapAlloc,
                Dns_DbgHeapRealloc,
                Dns_DbgHeapFree );
        }
        else
        {
            Dns_LibHeapReset(
                Dns_HeapAlloc,
                Dns_HeapRealloc,
                Dns_HeapFree );
        }

        g_pDnslibHeapBlob = pHeap;
    }

    return  NO_ERROR;
}



VOID
Dns_HeapCleanup(
    IN OUT  PHEAP_BLOB      pHeap
    )
/*++

Routine Description:

    Cleanup.

Arguments:

    None.

Return Value:

    None.

--*/
{
    DNSDBG( TRACE, ( "Dns_HeapCleanup( %p )\n", pHeap ));

    //  if not initialized -- do nothing

    if ( !pHeap )
    {
        return;
    }
    if ( pHeap->Tag != HEAP_CODE_ACTIVE )
    {
        DNS_ASSERT( pHeap->Tag == HEAP_CODE_ACTIVE );
        return;
    }
    DNS_ASSERT( pHeap->hHeap );

    //  if created heap, destroy it

    if ( pHeap->fCreated )
    {
        RtlDestroyHeap( pHeap->hHeap );
    }

    //  cleanup critical section

    if ( pHeap->fHeaders )
    {
        RtlDeleteCriticalSection( &pHeap->ListCs );
    }

    //  tag as invalid

    pHeap->Tag = HEAP_CODE_FREE;
}



//
//  Heap Validation
//

VOID
DbgHeapValidateHeader(
    IN      PHEAP_HEADER    h
    )
/*++

Routine Description:

    Validates heap header.

Arguments:

    h - ptr to header of block

Return Value:

    None.

--*/
{
    register PHEAP_TRAILER t;

    //
    //  extract trailer
    //

    t = HEAP_TRAILER( h );

    //
    //  verify header
    //

    if ( h->HeapCodeBegin != HEAP_CODE
            ||
        h->HeapCodeEnd != HEAP_CODE_ACTIVE )
    {
        DNSDBG( HEAPDBG, (
            "Invalid memory block at %p -- invalid header.\n",
            h ));

        if ( h->HeapCodeEnd == HEAP_CODE_FREE )
        {
            DNSDBG( HEAPDBG, (
                "ERROR:  Previous freed memory.\n" ));
        }
        goto Invalid;
    }

    //
    //  match header, trailer alloc number
    //

    if ( h->HeapCodeBegin != t->HeapCodeBegin
            ||
        h->AllocCount != t->AllocCount
            ||
        h->AllocSize != t->AllocSize
            ||
        h->HeapCodeEnd != t->HeapCodeEnd )
    {
        DNSDBG( HEAPDBG, (
            "Invalid memory block at %p -- header / trailer mismatch.\n",
            h ));
        goto Invalid;
    }
    return;


Invalid:

    DNSDBG( ANY, (
        "Validation failure, in heap blob %p\n",
        h->pHeap ));

    Dns_DbgHeapHeaderPrint( h, t );
    ASSERT( FALSE );
    Dns_DbgHeapGlobalInfoPrint( h->pHeap );
    Dns_DbgHeapDumpAllocList( h->pHeap );
    ASSERT( FALSE );
    return;
}



PHEAP_HEADER
Dns_DbgHeapValidateMemory(
    IN      PVOID           pMem,
    IN      BOOL            fAtHeader
    )
/*++

Routine Description:

    Validates users heap pointer, and returns actual.

    Note:  This memory MUST have been allocated by THESE MEMORY routines.

Arguments:

    pMem - ptr to memory to validate

    fAtHeader - TRUE if pMem is known to be immediately after a head header,
        otherwise this function will search backwards through memory starting
        at pMem looking for a valid heap header

Return Value:

    Pointer to actual heap pointer.

--*/
{
    register PHEAP_HEADER   pheader;

    //
    //  Get pointer to heap header.
    //

    pheader = (PHEAP_HEADER) pMem - 1;
    if ( !fAtHeader )
    {
        int     iterations = 32 * 1024;

        //
        //  Back up from pMem a DWORD at a time looking for HEAP_CODE.
        //  If we don't find one, eventually we will generate an exception,
        //  which will be interesting. This could be handled, but for now
        //  this loop will just walk to past the start of valid memory.
        //

        while ( 1 )
        {
            //
            //  Break if we've found the heap header.
            //

            if ( pheader->HeapCodeBegin == HEAP_CODE &&
                ( pheader->HeapCodeEnd == HEAP_CODE_ACTIVE ||
                    pheader->HeapCodeEnd == HEAP_CODE_FREE ) )
            {
                break;
            }

            //
            //  Sanity check: too many iterations?
            //

            if ( ( --iterations ) == 0 )
            {
                ASSERT( iterations > 0 );
                return NULL;
            }

            //
            //  Back up another DWORD.
            //

            pheader = ( PHEAP_HEADER ) ( ( PBYTE ) pheader - 4 );
        }
    }

    //
    //  Verify header and trailer.
    //

    DbgHeapValidateHeader( pheader );

    return pheader;
}



VOID
Dns_DbgHeapValidateAllocList(
    IN OUT  PHEAP_BLOB      pHeap
    )
/*++

Routine Description:

    Dumps header information for all nodes in alloc list.

Arguments:

    None

Return Value:

    None

--*/
{
    PLIST_ENTRY pentry;

    DNSDBG( TRACE, (
        "Dns_DbgHeapValidateAllocList( %p )\n",
        pHeap ));

    if ( !pHeap->fHeaders )
    {
        DNS_ASSERT( pHeap->fHeaders );
        return;
    }

    //
    //  loop through all outstanding alloc's, validating each one
    //

    LOCK_HEAP(pHeap);

    pentry = pHeap->ListHead.Flink;

    while( pentry != &pHeap->ListHead )
    {
        DbgHeapValidateHeader( HEAP_HEADER_FROM_LIST_ENTRY(pentry) );

        pentry = pentry->Flink;
    }
    UNLOCK_HEAP(pHeap);
}



//
//  Heap Printing
//

VOID
Dns_DbgHeapGlobalInfoPrint(
    IN      PHEAP_BLOB      pHeap
    )
/*++

Routine Description:

    Prints global heap info.

Arguments:

    None

Return Value:

    None

--*/
{
    DNS_PRINT((
        "Debug Heap Information:\n"
        "\tHeap Blob        = %p\n"
        "\tHandle           = %p\n"
        "\tDebug headers    = %d\n"
        "\tDnslib redirect  = %d\n"
        "\tFull checks      = %d\n"
        "\tFlags            = %08x\n"
        "\tStats ---------------\n"
        "\tMemory Allocated = %d\n"
        "\tMemory Freed     = %d\n"
        "\tMemory Current   = %d\n"
        "\tAlloc Count      = %d\n"
        "\tFree Count       = %d\n"
        "\tCurrent Count    = %d\n",

        pHeap,
        pHeap->hHeap,
        pHeap->fHeaders,
        pHeap->fDnsLib,
        pHeap->fCheckAll,
        pHeap->DefaultFlags,

        pHeap->AllocMem,
        pHeap->FreeMem,
        pHeap->CurrentMem,
        pHeap->AllocCount,
        pHeap->FreeCount,
        pHeap->CurrentCount
        ));
}



VOID
Dns_DbgHeapHeaderPrint(
    IN      PHEAP_HEADER    h,
    IN      PHEAP_TRAILER   t
    )
/*++

Routine Description:

    Prints heap header and trailer.

Arguments:

    None

Return Value:

    None

--*/
{
    if ( h )
    {
        DNSDBG( HEAPDBG, (
            "Heap Header at %p:\n"
            "\tHeapCodeBegin     = %08lx\n"
            "\tAllocCount        = %d\n"
            "\tAllocSize         = %d\n"
            "\tRequestSize       = %d\n"
            "\tHeapBlob          = %p\n"
            "\tFileName          = %s\n"
            "\tLineNo            = %d\n"
            "\tAllocTime         = %d\n"
            "\tCurrentMem        = %d\n"
            "\tCurrentCount      = %d\n"
            "\tHeapCodeEnd       = %08lx\n",
            h,
            h->HeapCodeBegin,
            h->AllocCount,
            h->AllocSize,
            h->RequestSize,
            h->pHeap,
            h->FileName,
            h->LineNo,
            h->AllocTime / 1000,
            h->CurrentMem,
            h->CurrentCount,
            h->HeapCodeEnd
            ));
    }

    if ( t )
    {
        DNSDBG( HEAPDBG, (
            "Heap Trailer at %p:\n"
            "\tHeapCodeBegin     = %08lx\n"
            "\tAllocCount        = %d\n"
            "\tAllocSize         = %d\n"
            "\tHeapCodeEnd       = %08lx\n",
            t,
            t->HeapCodeBegin,
            t->AllocCount,
            t->AllocSize,
            t->HeapCodeEnd
            ));
    }
}



VOID
Dns_DbgHeapDumpAllocList(
    IN      PHEAP_BLOB      pHeap
    )
/*++

Routine Description:

    Dumps header information for all nodes in alloc list.

Arguments:

    None

Return Value:

    None

--*/
{
    PLIST_ENTRY     pentry;
    PHEAP_HEADER    phead;

    if ( !pHeap->fHeaders )
    {
        DNSDBG( HEAPDBG, ( "Non-debug heap -- no alloc list!\n" ));
        return;
    }

    //
    //  loop through all outstanding alloc's, dumping output
    //

    LOCK_HEAP(pHeap);
    DNSDBG( HEAPDBG, ( "Dumping Alloc List:\n" ));

    pentry = pHeap->ListHead.Flink;

    while( pentry != &pHeap->ListHead )
    {
        phead = HEAP_HEADER_FROM_LIST_ENTRY( pentry );

        Dns_DbgHeapHeaderPrint(
                phead,
                HEAP_TRAILER( phead )
                );
        pentry = pentry->Flink;
    }

    DNSDBG( HEAPDBG, ( "End Dump of Alloc List.\n" ));
    UNLOCK_HEAP(pHeap);
}



//
//  Full debug heap routines
//

PVOID
Dns_DbgHeapAllocEx(
    IN OUT  PHEAP_BLOB      pHeap,
    IN      DWORD           dwFlags,
    IN      INT             iSize,
    IN      LPSTR           pszFile,
    IN      DWORD           dwLine
    )
/*++

Routine Description:

    Allocates memory.

Arguments:

    iSize   - number of bytes to allocate

Return Value:

    Pointer to memory allocated.
    NULL if allocation fails.

--*/
{
    register PHEAP_HEADER h;
    INT allocSize;

    DNSDBG( HEAP2, (
        "Dns_DbgHeapAlloc( %p, %d )\n",
        pHeap, iSize ));

    //
    //  full heap check?
    //

    IF_DNSDBG( HEAP_CHECK )
    {
        Dns_DbgHeapValidateAllocList( pHeap );
    }

    if ( iSize <= 0 )
    {
        DNSDBG( ANY, ( "Invalid alloc size = %d\n", iSize ));
        DNS_ASSERT( FALSE );
        return( NULL );
    }

    //
    //  allocate memory
    //
    //  first add heap header to size
    //

    allocSize = DbgHeapFindAllocSize( iSize );

    h = (PHEAP_HEADER) RtlAllocateHeap(
                            pHeap->hHeap,
                            dwFlags
                                ? dwFlags
                                : pHeap->DefaultFlags,
                            allocSize );
    if ( ! h )
    {
        Dns_DbgHeapGlobalInfoPrint( pHeap );
        return NULL;
    }

    //
    //  setup header / globals for new alloc
    //
    //  return ptr to first byte after header
    //

    return  DbgHeapSetHeaderAlloc(
                pHeap,
                h,
                iSize,
                pszFile,
                dwLine
                );
}



PVOID
Dns_DbgHeapReallocEx(
    IN OUT  PHEAP_BLOB      pHeap,
    IN      DWORD           dwFlags,
    IN OUT  PVOID           pMem,
    IN      INT             iSize,
    IN      LPSTR           pszFile,
    IN      DWORD           dwLine
    )
/*++

Routine Description:

    Reallocates memory

Arguments:

    pMem    - ptr to existing memory to reallocated
    iSize   - number of bytes to reallocate

Return Value:

    Pointer to memory allocated.
    NULL if allocation fails.

--*/
{
    register PHEAP_HEADER h;
    register PHEAP_HEADER pnew;
    INT     previousSize;
    INT     allocSize;

    //
    //  full heap check?
    //

    IF_DNSDBG( HEAP_CHECK )
    {
        Dns_DbgHeapValidateAllocList( pHeap );
    }

    if ( iSize <= 0 )
    {
        DNSDBG( HEAPDBG, ( "Invalid realloc size = %d\n", iSize ));
        return( NULL );
    }

    //
    //  validate memory
    //
    //  extract pointer to actual alloc'd block
    //  mark as free, and reset globals appropriately
    //

    h = DbgHeapSetHeaderFree( pHeap, pMem );

    //
    //  reallocate memory
    //
    //  first add heap header to size
    //

    allocSize = DbgHeapFindAllocSize( iSize );

    pnew = (PHEAP_HEADER) RtlReAllocateHeap(
                            pHeap->hHeap,
                            dwFlags
                                ? dwFlags
                                : pHeap->DefaultFlags,
                            h,
                            allocSize );
    if ( ! pnew )
    {
        Dns_DbgHeapGlobalInfoPrint( pHeap );
        return( NULL );
    }

    //
    //  setup header / globals for realloc
    //
    //  return ptr to first byte after header
    //

    return  DbgHeapSetHeaderAlloc(
                pHeap,
                pnew,
                iSize,
                pszFile,
                dwLine
                );
}



VOID
Dns_DbgHeapFreeEx(
    IN OUT  PHEAP_BLOB      pHeap,
    IN      DWORD           dwFlags,
    IN OUT  PVOID           pMem
    )
/*++

Routine Description:

    Frees memory

    Note:  This memory MUST have been allocated by DbgHeap routines.

Arguments:

    pMem - ptr to memory to be freed

Return Value:

    None.

--*/
{
    register PHEAP_HEADER h;

    DNSDBG( HEAP2, (
        "Dns_DbgHeapFreeEx( %p, %p )\n",
        pHeap, pMem ));

    //
    //  validate header
    //
    //  reset heap header / globals for free
    //

    h = DbgHeapSetHeaderFree( pHeap, pMem );

    //
    //  get blob
    //

    if ( !pHeap )
    {
        pHeap = h->pHeap;
    }

    //
    //  full heap check?
    //

    IF_DNSDBG( HEAP_CHECK )
    {
        Dns_DbgHeapValidateAllocList( pHeap );
    }

    RtlFreeHeap(
        pHeap->hHeap,
        dwFlags
            ? dwFlags
            : pHeap->DefaultFlags,
        h );
}



//
//  Dnslib memory compatible versions
//
//  Heap routines with simple function signature that matches
//  the dnslib routines and allows DnsLib memory routines to
//  be redirected to these routines through Dns_LibHeapReset().
//
//  Note:  to use these functions, must have specified at particular
//      heap to use.
//

PVOID
Dns_DbgHeapAlloc(
    IN      INT             iSize
    )
{
    return  Dns_DbgHeapAllocEx(
                g_pDnslibHeapBlob,
                0,
                iSize,
                NULL,
                0 );
}

PVOID
Dns_DbgHeapRealloc(
    IN OUT  PVOID           pMem,
    IN      INT             iSize
    )
{
    return  Dns_DbgHeapReallocEx(
                g_pDnslibHeapBlob,
                0,
                pMem,
                iSize,
                NULL,
                0
                );
}

VOID
Dns_DbgHeapFree(
    IN OUT  PVOID   pMem
    )
{
    Dns_DbgHeapFreeEx(
        g_pDnslibHeapBlob,
        0,
        pMem );
}




//
//  Non debug header versions
//
//  These allow you to use a private heap with some of the features
//  of the debug heap
//      - same initialization
//      - specifying individual heap
//      - redirection of dnslib (without building your own routines)
//      - alloc and free counts
//  but without the overhead of the headers.
//

PVOID
Dns_HeapAllocEx(
    IN OUT  PHEAP_BLOB      pHeap,
    IN      DWORD           dwFlags,
    IN      INT             iSize
    )
/*++

Routine Description:

    Allocates memory.

Arguments:

    pHeap   - heap to use

    dwFlags - flags

    iSize   - number of bytes to allocate

Return Value:

    Pointer to memory allocated.
    NULL if allocation fails.

--*/
{
    PVOID   p;

    DNSDBG( HEAP2, (
        "Dns_HeapAlloc( %p, %d )\n",
        pHeap, iSize ));

    //
    //  allocate memory
    //

    p = (PHEAP_HEADER) RtlAllocateHeap(
                            pHeap->hHeap,
                            dwFlags
                                ? dwFlags
                                : pHeap->DefaultFlags,
                            iSize );
    if ( p )
    {
        pHeap->AllocCount++;
        pHeap->CurrentCount++;
    }
    return  p;
}



PVOID
Dns_HeapReallocEx(
    IN OUT  PHEAP_BLOB      pHeap,
    IN      DWORD           dwFlags,
    IN OUT  PVOID           pMem,
    IN      INT             iSize
    )
/*++

Routine Description:

    Reallocates memory

Arguments:

    pMem    - ptr to existing memory to reallocated
    iSize   - number of bytes to reallocate

Return Value:

    Pointer to memory allocated.
    NULL if allocation fails.

--*/
{
    PVOID   p;
    INT     previousSize;
    INT     allocSize;

    //
    //  reallocate memory
    //
    //  first add heap header to size
    //

    p = RtlReAllocateHeap(
            pHeap->hHeap,
            dwFlags
                ? dwFlags
                : pHeap->DefaultFlags,
            pMem,
            iSize );
    if ( p )
    {
        pHeap->AllocCount++;
        pHeap->FreeCount++;
    }
    return  p;
}



VOID
Dns_HeapFreeEx(
    IN OUT  PHEAP_BLOB      pHeap,
    IN      DWORD           dwFlags,
    IN OUT  PVOID           pMem
    )
/*++

Routine Description:

    Frees memory

    Note:  This memory MUST have been allocated by DbgHeap routines.

Arguments:

    pMem - ptr to memory to be freed

Return Value:

    None.

--*/
{
    DNSDBG( HEAP2, (
        "Dns_HeapFreeEx( %p, %p )\n",
        pHeap, pMem ));

    RtlFreeHeap(
        pHeap->hHeap,
        dwFlags
            ? dwFlags
            : pHeap->DefaultFlags,
        pMem );

    pHeap->FreeCount++;
    pHeap->CurrentCount--;
}



//
//  Dnslib memory compatible versions
//
//  Heap routines with simple function signature that matches
//  the dnslib routines and allows DnsLib memory routines to
//  be redirected to these routines through Dns_LibHeapReset().
//
//  Note:  to use these functions, must have specified at particular
//      heap to use.
//

PVOID
Dns_HeapAlloc(
    IN      INT             iSize
    )
{
    return  Dns_HeapAllocEx(
                g_pDnslibHeapBlob,
                0,
                iSize );
}

PVOID
Dns_HeapRealloc(
    IN OUT  PVOID           pMem,
    IN      INT             iSize
    )
{
    return  Dns_HeapReallocEx(
                g_pDnslibHeapBlob,
                0,
                pMem,
                iSize );
}

VOID
Dns_HeapFree(
    IN OUT  PVOID   pMem
    )
{
    Dns_HeapFreeEx(
        g_pDnslibHeapBlob,
        0,
        pMem );
}

//
//  End heapdbg.c
//
=== C:/Users/treeman/Desktop/windows nt source code\Source\Win2K3\NT\ds\dns\dnslib\flatbuf.c ===
/*++

Copyright (c) 2000-2000 Microsoft Corporation

Module Name:

    flatbuf.c

Abstract:

    Domain Name System (DNS) Library

    Flat buffer sizing routines.

Author:

    Jim Gilroy (jamesg)     December 22, 2000

Revision History:

--*/


#include "local.h"



//
//  Flat buffer routines -- argument versions
//
//  These versions have the actual code so that we can
//  easily use this stuff with existing code that has
//  independent pCurrent and BytesLeft variables.
//
//  FLATBUF structure versions just call these inline.
//

PBYTE
FlatBuf_Arg_Reserve(
    IN OUT  PBYTE *         ppCurrent,
    IN OUT  PINT            pBytesLeft,
    IN      DWORD           Size,
    IN      DWORD           Alignment
    )
/*++

Routine Description:

    Reserve space in a flat buffer -- properly aligned.

Arguments:

    ppCurrent -- address of buffer current pointer
        updated with buf pointer after reservation

    pBytesLeft -- address of buf bytes left
        updated with bytes left after reservation

    Size -- size required

    Alignment -- alignment (size in bytes) required

Return Value:

    Ptr to aligned spot in buffer reserved for write.
    NULL on error.

--*/
{
    register    PBYTE   pb = *ppCurrent;
    register    INT     bytesLeft = *pBytesLeft;
    register    PBYTE   pstart;
    register    PBYTE   palign;

    //
    //  align pointer
    //

    pstart = pb;

    if ( Alignment )
    {
        Alignment--;
        pb = (PBYTE) ( (UINT_PTR)(pb + Alignment) & ~(UINT_PTR)Alignment );
    }
    palign = pb;

    //
    //  reserve space
    //

    pb += Size;

    bytesLeft -= (INT) (pb - pstart);

    *pBytesLeft = bytesLeft;
    *ppCurrent  = pb;

    //
    //  indicate space adequate\not
    //

    if ( bytesLeft < 0 )
    {
        palign = NULL;
    }
    return palign;
}



PBYTE
FlatBuf_Arg_WriteString(
    IN OUT  PBYTE *         ppCurrent,
    IN OUT  PINT            pBytesLeft,
    IN      PSTR            pString,
    IN      BOOL            fUnicode
    )
/*++

Routine Description:

    Write string to flat buffer.

Arguments:

    ppCurrent -- address of buffer current pointer
        updated with buf pointer after reservation

    pBytesLeft -- address of buf bytes left
        updated with bytes left after reservation

    pString -- ptr to string to write

    fUnicode -- TRUE for unicode string

Return Value:

    Ptr to location string was written in buffer.
    NULL on error.

--*/
{
    register    PBYTE   pwrite;
    register    DWORD   length;
    register    DWORD   align;

    //
    //  determine length
    //

    if ( fUnicode )
    {
        length = (wcslen( (PWSTR)pString ) + 1) * sizeof(WCHAR);
        align = sizeof(WCHAR);
    }
    else
    {
        length = strlen( pString ) + 1;
        align = 0;
    }

    //
    //  reserve space and copy string
    //

    pwrite = FlatBuf_Arg_Reserve(
                ppCurrent,
                pBytesLeft,
                length,
                align );

    if ( pwrite )
    {
        RtlCopyMemory(
            pwrite,
            pString,
            length );
    }

    return  pwrite;
}



PBYTE
FlatBuf_Arg_CopyMemory(
    IN OUT  PBYTE *         ppCurrent,
    IN OUT  PINT            pBytesLeft,
    IN      PVOID           pMemory,
    IN      DWORD           Length,
    IN      DWORD           Alignment
    )
/*++

Routine Description:

    Write memory to flat buffer.

Arguments:

    ppCurrent -- address of buffer current pointer
        updated with buf pointer after reservation

    pBytesLeft -- address of buf bytes left
        updated with bytes left after reservation

    pMemory -- memory to copy

    Length -- length to copy

    Alignment -- alignment (size in bytes) required

Return Value:

    Ptr to location string was written in buffer.
    NULL on error.

--*/
{
    register    PBYTE   pwrite;

    //
    //  reserve space and copy memory
    //

    pwrite = FlatBuf_Arg_Reserve(
                ppCurrent,
                pBytesLeft,
                Length,
                Alignment );

    if ( pwrite )
    {
        RtlCopyMemory(
            pwrite,
            pMemory,
            Length );
    }

    return  pwrite;
}


#if 0
//
//  Flatbuf inline functions -- defined in dnslib.h
//

__inline
PBYTE
FlatBuf_Arg_ReserveAlignPointer(
    IN OUT  PBYTE *         ppCurrent,
    IN OUT  PINT            pBytesLeft,
    IN      DWORD           Size
    )
{
    return FlatBuf_Arg_Reserve(
                ppCurrent,
                pBytesLeft,
                Size,
                sizeof(PVOID) );
}

__inline
PBYTE
FlatBuf_Arg_ReserveAlignQword(
    IN OUT  PBYTE *         ppCurrent,
    IN OUT  PINT            pBytesLeft,
    IN      DWORD           Size
    )
{
    return FlatBuf_Arg_Reserve(
                ppCurrent,
                pBytesLeft,
                Size,
                sizeof(QWORD) );
}

__inline
PBYTE
FlatBuf_Arg_ReserveAlignDword(
    IN OUT  PBYTE *         ppCurrent,
    IN OUT  PINT            pBytesLeft,
    IN      DWORD           Size
    )
{
    return FlatBuf_Arg_Reserve(
                ppCurrent,
                pBytesLeft,
                Size,
                sizeof(DWORD) );
}

__inline
PBYTE
FlatBuf_Arg_ReserveAlignWord(
    IN OUT  PBYTE *         ppCurrent,
    IN OUT  PINT            pBytesLeft,
    IN      DWORD           Size
    )
{
    return FlatBuf_Arg_Reserve(
                ppCurrent,
                pBytesLeft,
                Size,
                sizeof(WORD) );
}


__inline
PBYTE
FlatBuf_Arg_ReserveAlignByte(
    IN OUT  PBYTE *         ppCurrent,
    IN OUT  PINT            pBytesLeft,
    IN      DWORD           Size
    )
{
    return FlatBuf_Arg_Reserve(
                ppCurrent,
                pBytesLeft,
                Size,
                0 );
}



PBYTE
__inline
FlatBuf_Arg_WriteString_A(
    IN OUT  PBYTE *         ppCurrent,
    IN OUT  PINT            pBytesLeft,
    IN      PSTR            pString
    )
{
    return  FlatBuf_Arg_WriteString(
                ppCurrent,
                pBytesLeft,
                pString,
                FALSE       // not unicode
                );
}


PBYTE
__inline
FlatBuf_Arg_WriteString_W(
    IN OUT  PBYTE *         ppCurrent,
    IN OUT  PINT            pBytesLeft,
    IN      PWSTR           pString
    )
{
    return  FlatBuf_Arg_WriteString(
                ppCurrent,
                pBytesLeft,
                (PSTR) pString,
                TRUE        // unicode
                );
}
#endif



//
//  Flat buffer routines -- structure versions
//

VOID
FlatBuf_Init(
    IN OUT  PFLATBUF        pFlatBuf,
    IN      PBYTE           pBuffer,
    IN      INT             Size
    )
/*++

Routine Description:

    Init a FLATBUF struct with given buffer and size.

    Note, ok to init to zero for size determination.

Arguments:

    pFlatBuf -- ptr to FLATBUF to init

    pBuffer -- buffer ptr

    Size -- size required

Return Value:

    None

--*/
{
    pFlatBuf->pBuffer   = pBuffer;
    pFlatBuf->pCurrent  = pBuffer;
    pFlatBuf->pEnd      = pBuffer + Size;
    pFlatBuf->Size      = Size;
    pFlatBuf->BytesLeft = Size;
}





#if 0
//
//  Flatbuf inline functions -- defined in dnslib.h
//

__inline
PBYTE
FlatBuf_Reserve(
    IN OUT  PFLATBUF        pBuf,
    IN      DWORD           Size,
    IN      DWORD           Alignment
    )
{
    return FlatBuf_Arg_Reserve(
                & pBuf->pCurrent,
                & pBuf->BytesLeft,
                Size,
                Alignment );
}

__inline
PBYTE
FlatBuf_ReserveAlignPointer(
    IN OUT  PFLATBUF        pBuf,
    IN      DWORD           Size
    )
{
    return FlatBuf_Arg_Reserve(
                & pBuf->pCurrent,
                & pBuf->BytesLeft,
                Size,
                sizeof(PVOID) );
}

__inline
PBYTE
FlatBuf_ReserveAlignQword(
    IN OUT  PFLATBUF        pBuf,
    IN      DWORD           Size
    )
{
    return FlatBuf_Arg_Reserve(
                & pBuf->pCurrent,
                & pBuf->BytesLeft,
                Size,
                sizeof(QWORD) );
}

__inline
PBYTE
FlatBuf_ReserveAlignDword(
    IN OUT  PFLATBUF        pBuf,
    IN      DWORD           Size
    )
{
    return FlatBuf_Arg_Reserve(
                & pBuf->pCurrent,
                & pBuf->BytesLeft,
                Size,
                sizeof(DWORD) );
}

__inline
PBYTE
FlatBuf_ReserveAlignWord(
    IN OUT  PFLATBUF        pBuf,
    IN      DWORD           Size
    )
{
    return FlatBuf_Arg_Reserve(
                & pBuf->pCurrent,
                & pBuf->BytesLeft,
                Size,
                sizeof(WORD) );
}

__inline
PBYTE
FlatBuf_ReserveAlignByte(
    IN OUT  PFLATBUF        pBuf,
    IN      DWORD           Size
    )
{
    return FlatBuf_Arg_Reserve(
                & pBuf->pCurrent,
                & pBuf->BytesLeft,
                Size,
                0 );
}


PBYTE
__inline
FlatBuf_WriteString(
    IN OUT  PFLATBUF        pBuf,
    IN      PSTR            pString,
    IN      BOOL            fUnicode
    )
{
    return  FlatBuf_Arg_WriteString(
                & pBuf->pCurrent,
                & pBuf->BytesLeft,
                pString,
                fUnicode
                );
}


PBYTE
__inline
FlatBuf_WriteString_A(
    IN OUT  PFLATBUF        pBuf,
    IN      PSTR            pString
    )
{
    return  FlatBuf_Arg_WriteString(
                & pBuf->pCurrent,
                & pBuf->BytesLeft,
                pString,
                FALSE       // not unicode
                );
}


PBYTE
__inline
FlatBuf_WriteString_W(
    IN OUT  PFLATBUF        pBuf,
    IN      PWSTR           pString
    )
{
    return  FlatBuf_Arg_WriteString(
                & pBuf->pCurrent,
                & pBuf->BytesLeft,
                (PSTR) pString,
                TRUE        // unicode
                );
}


PBYTE
__inline
FlatBuf_CopyMemory(
    IN OUT  PFLATBUF        pBuf,
    IN      PVOID           pMemory,
    IN      DWORD           Length,
    IN      DWORD           Alignment
    )
{
    return FlatBuf_Arg_CopyMemory(
                & pBuf->pCurrent,
                & pBuf->BytesLeft,
                pMemory,
                Length,
                Alignment );
}
#endif

//
//  End flatbuf.c
//
=== C:/Users/treeman/Desktop/windows nt source code\Source\Win2K3\NT\ds\dns\dnslib\heapdbg.h ===
/*++

Copyright (c) 1995-2001 Microsoft Corporation

Module Name:

    heapdbg.h

Abstract:

    Domain Name System (DNS) Library

    Heap debugging definitions and declarations.

Author:

    Jim Gilroy (jamesg)    January 31, 1995

Revision History:

--*/


#ifndef _HEAPDBG_INCLUDED_
#define _HEAPDBG_INCLUDED_


//
//  Heap blob
//

typedef struct _HeapBlob
{
    HANDLE      hHeap;

    LIST_ENTRY  ListHead;

    //  flags
    BOOL        fCreated;
    BOOL        fHeaders;
    DWORD       Tag;
    BOOL        fDnsLib;
    BOOL        fCheckAll;
    DWORD       FailureException;
    DWORD       AllocFlags;
    DWORD       DefaultFlags;

    //  stats
    DWORD       AllocMem;
    DWORD       FreeMem;
    DWORD       CurrentMem;
    DWORD       AllocCount;
    DWORD       FreeCount;
    DWORD       CurrentCount;

    PSTR        pszDefaultFile;
    DWORD       DefaultLine;

    CRITICAL_SECTION    ListCs;
}
HEAP_BLOB, *PHEAP_BLOB;



//
//  Heap Header
//

#define HEAP_HEADER_FILE_SIZE   (16)

typedef struct _HEAP_HEADER
{
    //
    //  Note, if move or add fields, MUST update list entry offset below
    //

    ULONG       HeapCodeBegin;
    ULONG       AllocCount;
    ULONG       AllocSize;
    ULONG       RequestSize;

    //
    //  Put LIST_ENTRY in middle of header
    //      - keep begin code at front
    //      - less likely to be corrupted
    //

    LIST_ENTRY  ListEntry;

    PHEAP_BLOB  pHeap;
    PSTR        FileName;
    DWORD       LineNo;

    DWORD       AllocTime;
    ULONG       CurrentMem;
    ULONG       CurrentCount;
    ULONG       HeapCodeEnd;
}
HEAP_HEADER, * PHEAP_HEADER;

//
//  Heap Trailer
//

typedef struct _HEAP_TRAILER
{
    ULONG       HeapCodeBegin;
    ULONG       AllocCount;
    ULONG       AllocSize;
    ULONG       HeapCodeEnd;
}
HEAP_TRAILER, * PHEAP_TRAILER;


//
//  Header from list entry
//

#define HEAP_HEADER_LIST_ENTRY_OFFSET   (16)

#define HEAP_HEADER_FROM_LIST_ENTRY( pList )    \
            ( (PHEAP_HEADER)( (PCHAR)pList - HEAP_HEADER_LIST_ENTRY_OFFSET ))


//
//  Validation
//

PHEAP_HEADER
Dns_DbgHeapValidateMemory(
    IN      PVOID           pMem,
    IN      BOOL            fAtHeader
    );

VOID
Dns_DbgHeapValidateAllocList(
    IN      PHEAP_BLOB      pHeap
    );

//
//  Debug print
//

VOID
Dns_DbgHeapGlobalInfoPrint(
    IN      PHEAP_BLOB      pHeap
    );

VOID
Dns_DbgHeapHeaderPrint(
    IN      PHEAP_HEADER    h,
    IN      PHEAP_TRAILER   t
    );

VOID
Dns_DbgHeapDumpAllocList(
    IN      PHEAP_BLOB      pHeap
    );

//
//  Init\cleanup
//

DNS_STATUS
Dns_HeapInitialize(
    IN OUT  PHEAP_BLOB      pHeap,
    IN      HANDLE          hHeap,
    IN      DWORD           dwCreateFlags,
    IN      BOOL            fUseHeaders,
    IN      BOOL            fResetDnslib,
    IN      BOOL            fFullHeapChecks,
    IN      DWORD           dwException,
    IN      DWORD           dwDefaultFlags,
    IN      PSTR            pszDefaultFileName,
    IN      DWORD           dwDefaultFileLine
    );

VOID
Dns_HeapCleanup(
    IN OUT  PHEAP_BLOB      pHeap
    );


//
//  Full debug heap routines
//

PVOID
Dns_DbgHeapAllocEx(
    IN OUT  PHEAP_BLOB      pHeap,
    IN      DWORD           dwFlags,
    IN      INT             iSize,
    IN      LPSTR           pszFile,
    IN      DWORD           dwLine
    );

PVOID
Dns_DbgHeapReallocEx(
    IN OUT  PHEAP_BLOB      pHeap,
    IN      DWORD           dwFlags,
    IN OUT  PVOID           pMem,
    IN      INT             iSize,
    IN      LPSTR           pszFile,
    IN      DWORD           dwLine
    );

VOID
Dns_DbgHeapFreeEx(
    IN OUT  PHEAP_BLOB      pHeap,
    IN      DWORD           dwFlags,
    IN OUT  PVOID           pMem
    );

//
//  Dnslib compatible versions of full debug versions
//

PVOID
Dns_DbgHeapAlloc(
    IN      INT             iSize
    );                      
                            
PVOID                       
Dns_DbgHeapRealloc(         
    IN OUT  PVOID           pMem,
    IN      INT             iSize
    );                      
                            
VOID                        
Dns_DbgHeapFree(            
    IN OUT  PVOID           pMem
    );



//
//  Non-debug-header versions
//
//  These allow you to use a private heap with some of the features
//  of the debug heap
//      - same initialization
//      - specifying individual heap
//      - redirection of dnslib (without building your own routines)
//      - alloc and free counts
//  but without the overhead of the headers.
//

PVOID
Dns_HeapAllocEx(
    IN OUT  PHEAP_BLOB      pHeap,
    IN      DWORD           dwFlags,
    IN      INT             iSize
    );

PVOID
Dns_HeapReallocEx(
    IN OUT  PHEAP_BLOB      pHeap,
    IN      DWORD           dwFlags,
    IN OUT  PVOID           pMem,
    IN      INT             iSize
    );

VOID
Dns_HeapFreeEx(
    IN OUT  PHEAP_BLOB      pHeap,
    IN      DWORD           dwFlags,
    IN OUT  PVOID           pMem
    );

//
//  Dnslib compatible versions of non-debug-header versions
//

PVOID
Dns_HeapAlloc(
    IN      INT             iSize
    );

PVOID
Dns_HeapRealloc(
    IN OUT  PVOID           pMem,
    IN      INT             iSize
    );

VOID
Dns_HeapFree(
    IN OUT  PVOID           pMem
    );


#endif  //  _HEAPDBG_INCLUDED_
=== C:/Users/treeman/Desktop/windows nt source code\Source\Win2K3\NT\ds\dns\dnslib\hostent.c ===
/*++

Copyright (c) 2000-2001 Microsoft Corporation

Module Name:

    hostent.c

Abstract:

    Domain Name System (DNS) Library

    Hostent routines.

Author:

    Jim Gilroy (jamesg)     December 4, 2000

Revision History:

--*/


#include "local.h"
#include "ws2atm.h"     // ATM address


//
//  Max number of aliases
//

#define DNS_MAX_ALIAS_COUNT     (8)

//
//  Min size of hostent address buffer
//      - enough for one address of largest type
//

#define MIN_ADDR_BUF_SIZE   (sizeof(ATM_ADDRESS))


//
//  String alignment in buffer
//
//  DCR:  string buffer alignment exposed globally
//
//  Since address and string DATA (not ptrs) can be intermixed
//  as we build, we MUST size strings for DWORD (at minimum) so
//  to that addresses may be DWORD aligned.
//  However, when we build we can pack as tightly as desired
//  though obviously unicode strings must WCHAR align.
//  

#define HOSTENT_STRING_ALIGN_DWORD(size)    DWORD_ALIGN_DWORD(size)
#define HOSTENT_STRING_ALIGN_PTR(ptr)       DWORD_ALIGN(ptr)

#define REQUIRED_HOSTENT_STRING_ALIGN_DWORD(size)   WORD_ALIGN_DWORD(size)
#define REQUIRED_HOSTENT_STRING_ALIGN_PTR(ptr)      WORD_ALIGN(ptr)


//
//  Hostent utilities
//


BOOL
Hostent_IsSupportedAddrType(
    IN      WORD            wType
    )
/*++

Routine Description:

    Is this a supported address type for hostent.

Arguments:

    wType -- type in question

Return Value:

    TRUE if type supported
    FALSE otherwise

--*/
{
    return ( wType == DNS_TYPE_A ||
             wType == DNS_TYPE_AAAA ||
             wType == DNS_TYPE_ATMA );
}



DWORD
Hostent_Size(
    IN      PHOSTENT        pHostent,
    IN      DNS_CHARSET     CharSetExisting,
    IN      DNS_CHARSET     CharSetTarget,
    IN      PDWORD          pAliasCount,
    IN      PDWORD          pAddrCount
    )
/*++

Routine Description:

    Find size of hostent.

Arguments:

    pHostent -- hostent

    CharSetExisting -- char set of pHostent

    CharSetTarget -- char set to size to

    pAliasCount -- count of aliases

    pAddrCount -- count of addrs

Return Value:

    Size in bytes of hostent.

--*/
{
    DWORD   sizeName = 0;
    DWORD   sizeAliasNames = 0;
    DWORD   sizeAliasPtr;
    DWORD   sizeAddrPtr;
    DWORD   sizeAddrs;
    DWORD   sizeTotal;
    PCHAR   palias;
    DWORD   addrCount = 0;
    DWORD   aliasCount = 0;


    DNSDBG( HOSTENT, (
        "Hostent_Size( %p, %d, %d )\n",
        pHostent,
        CharSetExisting,
        CharSetTarget ));

    //
    //  name
    //

    if ( pHostent->h_name )
    {
        sizeName = Dns_GetBufferLengthForStringCopy(
                        pHostent->h_name,
                        0,
                        CharSetExisting,
                        CharSetTarget );

        sizeName = HOSTENT_STRING_ALIGN_DWORD( sizeName );
    }

    //
    //  aliases
    //

    if ( pHostent->h_aliases )
    {
        while ( palias = pHostent->h_aliases[aliasCount] )
        {
            sizeAliasNames += Dns_GetBufferLengthForStringCopy(
                                palias,
                                0,
                                CharSetExisting,
                                CharSetTarget );
    
            sizeAliasNames = HOSTENT_STRING_ALIGN_DWORD( sizeAliasNames );
            aliasCount++;
        }
    }
    sizeAliasPtr = (aliasCount+1) * sizeof(PCHAR);

    //
    //  addresses
    //

    if ( pHostent->h_addr_list )
    {
        while ( pHostent->h_addr_list[addrCount] )
        {
            addrCount++;
        }
    }
    sizeAddrPtr = (addrCount+1) * sizeof(PCHAR);
    sizeAddrs = addrCount * pHostent->h_length;

    //
    //  calc total size
    //
    //  note:  be careful of alignment issues
    //  our layout is
    //      - hostent struct
    //      - ptr arrays
    //      - address + string data
    //
    //  since address and string DATA (not ptrs) can be intermixed
    //  as we build, we MUST size strings for DWORD (at minimum) so
    //  to that addresses may be DWORD aligned
    //
    //  in copying we can copy all addresses first and avoid intermix
    //  but DWORD string alignment is still safe
    //

    sizeTotal = POINTER_ALIGN_DWORD( sizeof(HOSTENT) ) +
                sizeAliasPtr +
                sizeAddrPtr +
                sizeAddrs +
                sizeName +
                sizeAliasNames;

    if ( pAddrCount )
    {
        *pAddrCount = addrCount;
    }
    if ( pAliasCount )
    {
        *pAliasCount = aliasCount;
    }

    DNSDBG( HOSTENT, (
        "Hostent sized:\n"
        "\tname         = %d\n"
        "\talias ptrs   = %d\n"
        "\talias names  = %d\n"
        "\taddr ptrs    = %d\n"
        "\taddrs        = %d\n"
        "\ttotal        = %d\n",
        sizeName,
        sizeAliasPtr,
        sizeAliasNames,
        sizeAddrPtr,
        sizeAddrs,
        sizeTotal ));

    return  sizeTotal;
}



PHOSTENT
Hostent_Init(
    IN OUT  PBYTE *         ppBuffer,
    //IN OUT  PINT            pBufSize,
    IN      INT             Family,
    IN      INT             AddrLength,
    IN      DWORD           AddrCount,
    IN      DWORD           AliasCount
    )
/*++

Routine Description:

    Init hostent struct.

    Assumes length is adequate.

Arguments:

    ppBuffer -- addr to ptr to buffer to write hostent;
        on return contains next location in buffer

    Family -- address family

    AddrLength -- address length

    AddrCount -- address count

    AliasCount -- alias count

Return Value:

    Ptr to hostent.

--*/
{
    PBYTE       pbuf = *ppBuffer;
    PHOSTENT    phost;
    DWORD       size;

    //
    //  hostent
    //      - must be pointer aligned
    //

    phost = (PHOSTENT) POINTER_ALIGN( pbuf );

    phost->h_name       = NULL;
    phost->h_length     = (SHORT) AddrLength;
    phost->h_addrtype   = (SHORT) Family;

    pbuf = (PBYTE) (phost + 1);

    //
    //  init alias array
    //      - set hostent ptr
    //      - clear entire alias array;
    //      since this count is often defaulted nice to clear it just
    //      to avoid junk
    //  

    pbuf = (PBYTE) POINTER_ALIGN( pbuf );
    phost->h_aliases = (PCHAR *) pbuf;

    size = (AliasCount+1) * sizeof(PCHAR);

    RtlZeroMemory(
        pbuf,
        size );

    pbuf += size;

    //
    //  init addr array
    //      - set hostent ptr
    //      - clear first address entry
    //      callers responsibility to NULL last addr pointer when done
    //

    *(PCHAR *)pbuf = NULL;
    phost->h_addr_list = (PCHAR *) pbuf;

    pbuf += (AddrCount+1) * sizeof(PCHAR);

    //
    //  return next position in buffer
    //

    *ppBuffer = pbuf;

    return  phost;
}



VOID
Dns_PtrArrayToOffsetArray(
    IN OUT  PCHAR *         PtrArray,
    IN      PCHAR           pBase
    )
/*++

Routine Description:

    Change an array of pointers into array of offsets.

    This is used to convert aliases lists to offsets.

Arguments:

    pPtrArray -- addr of ptr to array of pointers to convert to offsets
        the array must be terminated by NULL ptr

    pBase -- base address to offset from

Return Value:

    None

--*/
{
    PCHAR * pptr = PtrArray;
    PCHAR   pdata;

    DNSDBG( TRACE, ( "Dns_PtrArrayToOffsetArray()\n" ));

    //
    //  turn each pointer into offset
    //

    while( pdata = *pptr )
    {
        *pptr++ = (PCHAR)( (PCHAR)pdata - (PCHAR)pBase );
    }
}



VOID
Hostent_ConvertToOffsets(
    IN OUT  PHOSTENT        pHostent
    )
/*++

Routine Description:

    Convert hostent to offsets.

Arguments:

    pHostent -- hostent to convert to offsets

Return Value:

    None

--*/
{
    PBYTE   ptr;

    DNSDBG( TRACE, ( "Hostent_ConvertToOffsets()\n" ));

    //
    //  convert
    //      - name
    //      - alias array pointer
    //      - address array pointer
    //

    if ( ptr = pHostent->h_name )
    {
        pHostent->h_name = (PCHAR) (ptr - (PBYTE)pHostent);
    }

    //  alias array
    //      - convert array pointer
    //      - convert pointers in array

    if ( ptr = (PBYTE)pHostent->h_aliases )
    {
        pHostent->h_aliases = (PCHAR *) (ptr - (PBYTE)pHostent);

        Dns_PtrArrayToOffsetArray(
            (PCHAR *) ptr,
            (PCHAR) pHostent );
    }

    //  address array
    //      - convert array pointer
    //      - convert pointers in array

    if ( ptr = (PBYTE)pHostent->h_addr_list )
    {
        pHostent->h_addr_list = (PCHAR *) (ptr - (PBYTE)pHostent);

        Dns_PtrArrayToOffsetArray(
            (PCHAR *) ptr,
            (PCHAR) pHostent );
    }

    DNSDBG( TRACE, ( "Leave Hostent_ConvertToOffsets()\n" ));
}



PHOSTENT
Hostent_Copy(
    IN OUT  PBYTE *         ppBuffer,
    IN OUT  PINT            pBufferSize,
    OUT     PINT            pHostentSize,
    IN      PHOSTENT        pHostent,
    IN      DNS_CHARSET     CharSetIn,
    IN      DNS_CHARSET     CharSetTarget,
    IN      BOOL            fOffsets,
    IN      BOOL            fAlloc
    )
/*++

Routine Description:

    Copy a hostent.

Arguments:

    ppBuffer -- addr with ptr to buffer to write to;
        if no buffer then hostent is allocated
        updated with ptr to position in buffer after hostent

    pBufferSize -- addr containing size of buffer;
        updated with bytes left after hostent written
        (even if out of space, it contains missing number of
        bytes as negative number)

    pHostentSize -- addr to recv total size of hostent written

    pHostent -- existing hostent to copy

    CharSetIn -- charset of existing hostent

    CharSetTarget -- charset of target hostent

    fOffsets -- write hostent with offsets

    fAlloc -- allocate copy

Return Value:

    Ptr to new hostent.
    NULL on error.  See GetLastError().

--*/
{
    PBYTE       pch;
    PHOSTENT    phost = NULL;
    DWORD       size;
    DWORD       sizeTotal;
    DWORD       bytesLeft;
    DWORD       aliasCount;
    DWORD       addrCount;
    DWORD       addrLength;
    PCHAR *     pptrArrayIn;
    PCHAR *     pptrArrayOut;
    PCHAR       pdataIn;


    DNSDBG( HOSTENT, (
        "Hostent_Copy()\n" ));

    //
    //  determine required hostent size
    //      - allow sizing skip for already allocated buffers only
    //

    sizeTotal = Hostent_Size(
                    pHostent,
                    CharSetIn,
                    CharSetTarget,
                    & aliasCount,
                    & addrCount );
    
    //
    //  alloc or reserve size in buffer
    //

    if ( fAlloc )
    {
        pch = ALLOCATE_HEAP( sizeTotal );
        if ( !pch )
        {
            goto Failed;
        }
    }
    else
    {
        pch = FlatBuf_Arg_ReserveAlignPointer(
                    ppBuffer,
                    pBufferSize,
                    sizeTotal
                    );
        if ( !pch )
        {
            goto Failed;
        }
    }

    //
    //  note:  assuming from here on down that we have adequate space
    //
    //  reason we aren't building with FlatBuf routines is that
    //      a) i wrote this first
    //      b) we believe we have adequate space
    //      c) i haven't built FlatBuf string conversion routines
    //      which we need below (for RnR unicode to ANSI)
    //
    //  we could reset buf pointers here and build directly with FlatBuf
    //  routines;  this isn't directly necessary
    //

    //
    //  init hostent struct 
    //

    addrLength = pHostent->h_length;

    phost = Hostent_Init(
                & pch,
                pHostent->h_addrtype,
                addrLength,
                addrCount,
                aliasCount );

    DNS_ASSERT( pch > (PBYTE)phost );

    //
    //  copy addresses
    //      - no need to align as previous is address
    //

    pptrArrayIn     = pHostent->h_addr_list;
    pptrArrayOut    = phost->h_addr_list;

    if ( pptrArrayIn )
    {
        while( pdataIn = *pptrArrayIn++ )
        {
            *pptrArrayOut++ = pch;

            RtlCopyMemory(
                pch,
                pdataIn,
                addrLength );

            pch += addrLength;
        }
    }
    *pptrArrayOut = NULL;

    //
    //  copy the aliases
    //

    pptrArrayIn     = pHostent->h_aliases;
    pptrArrayOut    = phost->h_aliases;

    if ( pptrArrayIn )
    {
        while( pdataIn = *pptrArrayIn++ )
        {
            pch = REQUIRED_HOSTENT_STRING_ALIGN_PTR( pch );

            *pptrArrayOut++ = pch;

            size = Dns_StringCopy(
                        pch,
                        NULL,       // infinite size
                        pdataIn,
                        0,          // unknown length
                        CharSetIn,
                        CharSetTarget
                        );
            pch += size;
        }
    }
    *pptrArrayOut = NULL;

    //
    //  copy the name
    //

    if ( pHostent->h_name )
    {
        pch = REQUIRED_HOSTENT_STRING_ALIGN_PTR( pch );

        phost->h_name = pch;

        size = Dns_StringCopy(
                    pch,
                    NULL,       // infinite size
                    pHostent->h_name,
                    0,          // unknown length
                    CharSetIn,
                    CharSetTarget
                    );
        pch += size;
    }

    //
    //  copy is complete
    //      - verify our write functions work
    //

    ASSERT( (DWORD)(pch-(PBYTE)phost) <= sizeTotal );

    if ( pHostentSize )
    {
        *pHostentSize = (INT)( pch - (PBYTE)phost );
    }

    if ( !fAlloc )
    {
        PBYTE   pnext = *ppBuffer;

        //  if we sized too small --
        //  fix up the buf pointer and bytes left

        if ( pnext < pch )
        {
            ASSERT( FALSE );
            *ppBuffer = pch;
            *pBufferSize -= (INT)(pch - pnext);
        }
    }

    IF_DNSDBG( HOSTENT )
    {
        DnsDbg_Hostent(
            "Hostent copy:",
            phost,
            (CharSetTarget == DnsCharSetUnicode) );
    }

    //
    //  convert to offsets?
    //

    if ( fOffsets )
    {
        Hostent_ConvertToOffsets( phost );
    }


Failed:

    DNSDBG( TRACE, (
        "Leave Hostent_Copy() => %p\n",
        phost ));

    return  phost;
}




DWORD
Hostent_WriteIp4Addrs(
    IN OUT  PHOSTENT        pHostent,
    OUT     PCHAR           pAddrBuf,
    IN      DWORD           MaxBufCount,
    IN      PIP4_ADDRESS    Ip4Array,
    IN      DWORD           ArrayCount,
    IN      BOOL            fScreenZero
    )
/*++

Routine Description:

    Write IP4 addresses to hostent.

Arguments:

    pHostent -- hostent

    pAddrBuf -- buffer to hold addresses

    MaxBufCount -- max IPs buffer can hold

    Ip4Array -- array of IP4 addresses

    ArrayCount -- array count

    fScreenZero -- screen out zero addresses?

Return Value:

    Count of addresses written

--*/
{
    DWORD           i = 0;
    DWORD           stopCount = MaxBufCount;
    PIP4_ADDRESS    pip = (PIP4_ADDRESS) pAddrBuf;
    PIP4_ADDRESS *  pipPtr = (PIP4_ADDRESS *) pHostent->h_addr_list;

    //
    //  write IP addresses OR loopback if no IPs 
    //

    if ( Ip4Array )
    {
        if ( ArrayCount < stopCount )
        {
            stopCount = ArrayCount;
        }

        for ( i=0; i < stopCount; ++i )
        {
            IP4_ADDRESS ip = Ip4Array[i];
            if ( ip != 0  ||  !fScreenZero )
            {
                *pip = ip;
                *pipPtr++ = pip++;
            }
        }
    }
    
    *pipPtr = NULL;

    //  count of addresses written

    return( i );
}



DWORD
Hostent_WriteLocalIp4Array(
    IN OUT  PHOSTENT        pHostent,
    OUT     PCHAR           pAddrBuf,
    IN      DWORD           MaxBufCount,
    IN      PIP4_ARRAY      pIpArray
    )
/*++

Routine Description:

    Write local IP list into hostent.

Arguments:

    pHostent -- hostent

    pAddrBuf -- buffer to hold addresses

    MaxBufCount -- max IPs buffer can hold

    pIpArray -- IP4 array of local addresses

Return Value:

    Count of addresses written

--*/
{
    DWORD   count = 0;

    //
    //  write array
    //

    if ( pIpArray )
    {
        count = Hostent_WriteIp4Addrs(
                    pHostent,
                    pAddrBuf,
                    MaxBufCount,
                    pIpArray->AddrArray,
                    pIpArray->AddrCount,
                    TRUE        // screen out zeros
                    );
    }

    //
    //  if no addresses written, write loopback
    //

    if ( count==0 )
    {
        pHostent->h_addr_list[0] = pAddrBuf;
        pHostent->h_addr_list[1] = NULL;
        *((IP4_ADDRESS*)pAddrBuf) = DNS_NET_ORDER_LOOPBACK;
        count = 1;
    }

    //  count of addresses written

    return( count );
}



BOOL
Hostent_SetToSingleAddress(
    IN OUT  PHOSTENT        pHostent,
    IN      PCHAR           pAddr,
    IN      DWORD           AddrLength
    )
/*++

Routine Description:

    Set address in hostent.

Arguments:

    pHostent -- hostent to check

    pAddr -- ptr to address to check

    AddrLength -- address length

Return Value:

    TRUE if address successfully copied into hostent.
    FALSE otherwise (no hostent, wrong length, hostent empty)

--*/
{
    PCHAR   paddrHostent;

    //
    //  validate
    //      - must have hostent
    //      - length must match
    //

    if ( !pHostent ||
         AddrLength != (DWORD)pHostent->h_length )
    {
        return FALSE;
    }

    //
    //  slam address in on top of existing
    //      - NULL 2nd addr pointer to terminate list
    //

    paddrHostent = pHostent->h_addr_list[0];
    if ( !paddrHostent )
    {
        return FALSE;
    }

    RtlCopyMemory(
        paddrHostent,
        pAddr,
        AddrLength );

    pHostent->h_addr_list[1] = NULL;

    return  TRUE;
}



BOOL
Hostent_IsAddressInHostent(
    IN OUT  PHOSTENT        pHostent,
    IN      PCHAR           pAddr,
    IN      DWORD           AddrLength,
    IN      INT             Family          OPTIONAL
    )
/*++

Routine Description:

    Does hostent contain this address.

Arguments:

    pHostent -- hostent to check

    pAddr -- ptr to address to check

    AddrLength -- address length

    Family -- address family

Return Value:

    TRUE if address is in hostent.
    FALSE otherwise.

--*/
{
    BOOL    freturn = FALSE;
    DWORD   i;
    PCHAR   paddrHostent;

    //
    //  validate
    //      - must have hostent
    //      - must have address
    //      - if family given, must match
    //      - length must match
    //

    if ( !pHostent ||
         !pAddr    ||
         AddrLength != (DWORD)pHostent->h_length ||
         ( Family && Family != pHostent->h_addrtype ) )
    {
        return freturn;
    }

    //
    //  search for address -- if found return TRUE
    //

    i = 0;

    while ( paddrHostent = pHostent->h_addr_list[i++] )
    {
        freturn = RtlEqualMemory(
                        paddrHostent,
                        pAddr,
                        AddrLength );
        if ( freturn )
        {
            break;
        }
    }

    return  freturn;
}



BOOL
Hostent_IsIp4AddressInHostent(
    IN OUT  PHOSTENT        pHostent,
    IN      IP4_ADDRESS     Ip4Addr
    )
/*++

Routine Description:

    Does hostent contain this address.

Arguments:

    pHostent -- hostent to check

    pAddr -- ptr to address to check

    AddrLength -- address length

    Family -- address family

Return Value:

    TRUE if address is in hostent.
    FALSE otherwise.

--*/
{
    DWORD   i;
    PCHAR   paddrHostent;

    //
    //  validate
    //      - must have hostent
    //      - length must match
    //

    if ( !pHostent ||
         sizeof(IP4_ADDRESS) != (DWORD)pHostent->h_length )
    {
        return FALSE;
    }

    //
    //  search for address -- if found return TRUE
    //

    i = 0;

    while ( paddrHostent = pHostent->h_addr_list[i++] )
    {
        if ( Ip4Addr == *(PIP4_ADDRESS)paddrHostent )
        {
            return  TRUE;
        }
    }
    return  FALSE;
}




//
//  Hostent building utilities
//

DNS_STATUS
HostentBlob_Create(
    IN OUT  PHOSTENT_BLOB * ppBlob,
    IN      PHOSTENT_INIT   pReq
    )
/*++

Routine Description:

    Initialize hostent (extending buffers as necessary)

    May allocate hostent buffer if existing too small.
    Returns required size.

Arguments:

    ppBlob -- addr containing or to recv hostent object

    pReq -- hostent init request

Return Value:

--*/
{
    PHOSTENT_BLOB   pblob = *ppBlob;
    PHOSTENT    phost;
    PCHAR       pbuf;
    BOOL        funicode = FALSE;
    DWORD       bytesLeft;
    DWORD       addrSize;
    DWORD       addrType;
    DWORD       countAlias;
    DWORD       countAddr;

    DWORD       sizeChar;
    DWORD       sizeHostent = 0;
    DWORD       sizeAliasPtr;
    DWORD       sizeAddrPtr;
    DWORD       sizeAddrs;
    DWORD       sizeName;
    DWORD       sizeAliasNames;
    DWORD       sizeTotal;

    DNSDBG( HOSTENT, ( "HostentBlob_Create()\n" ));


    //
    //  calculate required size
    //

    //  size for all char allocs
    //
    //  note, we save CharSet info, if known, but the real
    //  action in sizing or building or printing strings is simply
    //  unicode\not-unicode

    sizeChar = sizeof(CHAR);
    if ( pReq->fUnicode || pReq->CharSet == DnsCharSetUnicode )
    {
        sizeChar = sizeof(WCHAR);
        funicode = TRUE;
    }

    //  limit alias count

    countAlias = pReq->AliasCount;
    if ( countAlias > DNS_MAX_ALIAS_COUNT )
    {
        countAlias = DNS_MAX_ALIAS_COUNT;
    }
    sizeAliasPtr = (countAlias+1) * sizeof(PCHAR);

    //  size address pointer array
    //  - always size for at least one address
    //      - write PTR address after record write
    //      - write loopback or other local address
    //          into local hostent

    countAddr = pReq->AddrCount;
    if ( countAddr == 0 )
    {
        countAddr = 1;
    }
    sizeAddrPtr = (countAddr+1) * sizeof(PCHAR);

    //
    //  determine address size and type
    //      - may be specified directly
    //      - or picked up from DNS type
    //
    //  DCR:  functionalize type-to\from-family and addr size
    //

    addrType = pReq->AddrFamily;

    if ( !addrType )
    {
        WORD wtype = pReq->wType;

        if ( wtype == DNS_TYPE_A )
        {
            addrType = AF_INET;
        }
        else if ( wtype == DNS_TYPE_AAAA ||
                  wtype == DNS_TYPE_A6 )
        {
            addrType = AF_INET6;
        }
        else if ( wtype == DNS_TYPE_ATMA )
        {
            addrType = AF_ATM;
        }
    }

    if ( addrType == AF_INET )
    {
        addrSize = sizeof(IP4_ADDRESS);
    }
    else if ( addrType == AF_INET6 )
    {
        addrSize = sizeof(IP6_ADDRESS    );
    }
    else if ( addrType == AF_ATM )
    {
        addrSize = sizeof(ATM_ADDRESS);
    }
    else
    {
        //  should have type and count or neither
        DNS_ASSERT( pReq->AddrCount == 0 );
        addrSize = 0;
    }

    sizeAddrs = countAddr * addrSize;

    //  always have buffer large enough for one
    //  address of largest type

    if ( sizeAddrs < MIN_ADDR_BUF_SIZE )
    {
        sizeAddrs = MIN_ADDR_BUF_SIZE;
    }

    //
    //  namelength
    //      - if actual name use it
    //          (charset must match type we're building)
    //      - if size, use it
    //      - if absent use MAX
    //      - round to DWORD

    if ( pReq->pName )
    {
        if ( funicode )
        {
            sizeName = wcslen( (PWSTR)pReq->pName );
        }
        else
        {
            sizeName = strlen( pReq->pName );
        }
    }
    else
    {
        sizeName = pReq->NameLength;
    }

    if ( sizeName )
    {
        sizeName++;
    }
    else
    {
        sizeName = DNS_MAX_NAME_BUFFER_LENGTH;
    }
    sizeName = HOSTENT_STRING_ALIGN_DWORD( sizeChar*sizeName );

    //
    //  alias name lengths
    //      - if absent use MAX for each string
    //      - round to DWORD
    //

    sizeAliasNames = pReq->AliasNameLength;

    if ( sizeAliasNames )
    {
        sizeAliasNames += pReq->AliasCount;
    }
    else
    {
        sizeAliasNames = DNS_MAX_NAME_BUFFER_LENGTH;
    }
    sizeAliasNames = HOSTENT_STRING_ALIGN_DWORD( sizeChar*sizeAliasNames );


    //
    //  calc total size
    //
    //  note:  be careful of alignment issues
    //  our layout is
    //      - hostent struct
    //      - ptr arrays
    //      - address + string data
    //
    //  since address and string DATA (not ptrs) can be intermixed
    //  as we build, we MUST size strings for DWORD (at minimum) so
    //  to that addresses may be DWORD aligned
    //

    sizeTotal = POINTER_ALIGN_DWORD( sizeof(HOSTENT) ) +
                sizeAliasPtr +
                sizeAddrPtr +
                sizeAddrs +
                sizeName +
                sizeAliasNames;

    //
    //  if no blob, allocate one along with buffer
    //

    if ( !pblob )
    {
        pblob = (PHOSTENT_BLOB) ALLOCATE_HEAP( sizeTotal + sizeof(HOSTENT_BLOB) );
        if ( !pblob )
        {
            goto Failed;
        }
        RtlZeroMemory( pblob, sizeof(*pblob) );

        pbuf = (PCHAR) (pblob + 1);
        pblob->pBuffer = pbuf;
        pblob->BufferLength = sizeTotal;
        pblob->fAllocatedBlob = TRUE;
        pblob->fAllocatedBuf = FALSE;
    }

    //
    //  check existing buffer for size
    //      - allocate new buffer if necessary
    //

    else
    {
        pbuf = pblob->pBuffer;
    
        if ( !pbuf  ||  pblob->BufferLength < sizeTotal )
        {
            if ( pbuf && pblob->fAllocatedBuf )
            {
                FREE_HEAP( pbuf );
            }
        
            pbuf = ALLOCATE_HEAP( sizeTotal );
            pblob->pBuffer = pbuf;
        
            if ( pbuf )
            {
                pblob->BufferLength = sizeTotal;
                pblob->fAllocatedBuf = TRUE;
            }
    
            //
            //  DCR:  alloc failure handling
            //    - possibly keep previous buffers limitations
            //
    
            else    // alloc failed
            {
                pblob->fAllocatedBuf = FALSE;
                return( DNS_ERROR_NO_MEMORY );
            }
        }
    }

    //
    //  init hostent and buffer subfields
    //

    bytesLeft = pblob->BufferLength;

    //
    //  hostent
    //

    phost = (PHOSTENT) pbuf;
    pbuf += sizeof(HOSTENT);
    bytesLeft -= sizeof(HOSTENT);

    pblob->pHostent = phost;

    phost->h_name       = NULL;
    phost->h_addr_list  = NULL;
    phost->h_aliases    = NULL;
    phost->h_length     = (SHORT) addrSize;
    phost->h_addrtype   = (SHORT) addrType;

    pblob->fWroteName   = FALSE;
    pblob->AliasCount   = 0;
    pblob->AddrCount    = 0;
    pblob->CharSet      = pReq->CharSet;
    pblob->fUnicode     = funicode;
    if ( funicode )
    {
        pblob->CharSet  = DnsCharSetUnicode;
    }

    //
    //  init alias array
    //      - set hostent ptr
    //      - clear entire alias array;
    //      since this count is often defaulted nice to clear it just
    //      to avoid junk
    //
    //  

#if 0
    pwrite = FlatBuf_ReserveAlignPointer(
                & pbuf,
                & bytesLeft,
                sizeAliasPtr );
#endif

    if ( bytesLeft < sizeAliasPtr )
    {
        DNS_ASSERT( FALSE );
        goto Failed;
    }
    RtlZeroMemory(
        pbuf,
        sizeAliasPtr );

    phost->h_aliases = (PCHAR *) pbuf;

    pbuf += sizeAliasPtr;
    bytesLeft -= sizeAliasPtr;

    pblob->MaxAliasCount = countAlias;
    
    //
    //  init addr array
    //      - set hostent ptr
    //      - clear first address entry
    //      callers responsibility to NULL last addr pointer when done
    //

    if ( bytesLeft < sizeAddrPtr )
    {
        DNS_ASSERT( FALSE );
        goto Failed;
    }
    * (PCHAR *)pbuf = NULL;
    phost->h_addr_list = (PCHAR *) pbuf;

    pbuf += sizeAddrPtr;
    bytesLeft -= sizeAddrPtr;

    pblob->MaxAddrCount = countAddr;

    //
    //  set remaining buffer info
    //      - save current buffer space
    //      - save data on part of buffer available
    //      for use by data
    //

    pblob->pAvailBuffer  = pbuf;
    pblob->AvailLength   = bytesLeft;

    pblob->pCurrent      = pbuf;
    pblob->BytesLeft     = bytesLeft;

    *ppBlob = pblob;

    IF_DNSDBG( HOSTENT )
    {
        DnsDbg_HostentBlob(
            "HostentBlob After Create:",
            pblob );
    }

    return( ERROR_SUCCESS );


Failed:

    *ppBlob = pblob;

    if ( pblob && pblob->pBuffer && pblob->fAllocatedBuf )
    {
        FREE_HEAP( pblob->pBuffer );
        pblob->pBuffer = NULL;
        pblob->fAllocatedBuf = FALSE;
    }

    DNSDBG( HOSTENT, ( "Hostent Blob create failed!\n" ));

    return( DNS_ERROR_NO_MEMORY );
}



PHOSTENT_BLOB
HostentBlob_CreateAttachExisting(
    IN      PHOSTENT        pHostent,
    IN      BOOL            fUnicode
    )
/*++

Routine Description:

    Create hostent blob for existing hostent.

    This is a hack to allow existing RnR TLS hostents to
    be attached to hostent-blobs to smooth code transition.

    A full version would obviously require init structure and
    separate the sizing\init function from the creation
    function.

Arguments:

    pHostent -- existing hostent

    fUnicode -- is unicode

Return Value:

    Ptr to new hostent blob.
    NULL on alloc failure.  GetLastError() has error.

--*/
{
    PHOSTENT_BLOB   pblob;

    DNSDBG( HOSTENT, ( "HostentBlob_CreateAttachExisting()\n" ));

    //
    //  alloc
    //

    pblob = (PHOSTENT_BLOB) ALLOCATE_HEAP_ZERO( sizeof(HOSTENT_BLOB) );
    if ( !pblob )
    {
        SetLastError( DNS_ERROR_NO_MEMORY );
        return  NULL;
    }

    //
    //  attach existing hostent
    //

    pblob->pHostent = pHostent;
    pblob->fUnicode = fUnicode;

    IF_DNSDBG( HOSTENT )
    {
        DnsDbg_HostentBlob(
            "Leaving AttachExisting:",
            pblob );
    }

    return  pblob;
}



VOID
HostentBlob_Free(
    IN OUT  PHOSTENT_BLOB   pBlob
    )
/*++

Routine Description:

    Free hostent blob.

Arguments:

    pBlob -- blob to free

Return Value:

    None

--*/
{
    //
    //  free buffer?
    //

    if ( !pBlob )
    {
        return;
    }
    if ( pBlob->fAllocatedBuf )
    {
        FREE_HEAP( pBlob->pBuffer );
        pBlob->pBuffer = NULL;
        pBlob->fAllocatedBuf = FALSE;
    }

    //
    //  free blob itself?
    //

    if ( pBlob->fAllocatedBlob )
    {
        FREE_HEAP( pBlob );
    }
}



DNS_STATUS
HostentBlob_WriteAddress(
    IN OUT  PHOSTENT_BLOB   pBlob,
    IN      PVOID           pAddress,
    IN      DWORD           AddrSize,
    IN      DWORD           AddrType
    )
/*++

Routine Description:

    Write IP4 address to hostent blob.

Arguments:

    pBlob -- hostent build blob

    pAddress - address to write

    AddrSize - address size

    AddrType - address type (hostent type, e.g. AF_INET)

Return Value:

    ERROR_SUCCESS if successful.
    ERROR_MORE_DATA if out of buffer space
    ERROR_INVALID_DATA if address doesn't match hostent

--*/
{
    DWORD       count = pBlob->AddrCount;
    PHOSTENT    phost = pBlob->pHostent;
    PCHAR       pcurrent;
    DWORD       bytesLeft;

    //  verify type
    //      - set if empty or no addresses written

    if ( phost->h_addrtype != (SHORT)AddrType )
    {
        if ( phost->h_addrtype != 0 )
        {
            return( ERROR_INVALID_DATA );
        }
        phost->h_addrtype   = (SHORT) AddrType;
        phost->h_length     = (SHORT) AddrSize;
    }

    //  verify space

    if ( count >= pBlob->MaxAddrCount )
    {
        return( ERROR_MORE_DATA );
    }

    //  align - to DWORD

    pcurrent = DWORD_ALIGN( pBlob->pCurrent );
    bytesLeft = pBlob->BytesLeft;
    bytesLeft -= (DWORD)(pcurrent - pBlob->pCurrent);

    if ( bytesLeft < AddrSize )
    {
        return( ERROR_MORE_DATA );
    }

    //  copy
    //      - copy address to buffer
    //      - set pointer in addr list
    //      NULL following pointer

    RtlCopyMemory(
        pcurrent,
        pAddress,
        AddrSize );

    phost->h_addr_list[count++] = pcurrent;
    phost->h_addr_list[count]   = NULL;
    pBlob->AddrCount = count;

    pBlob->pCurrent = pcurrent + AddrSize;
    pBlob->BytesLeft = bytesLeft - AddrSize;

    return( NO_ERROR );
}



DNS_STATUS
HostentBlob_WriteAddressArray(
    IN OUT  PHOSTENT_BLOB   pBlob,
    IN      PVOID           pAddrArray,
    IN      DWORD           AddrCount,
    IN      DWORD           AddrSize,
    IN      DWORD           AddrType
    )
/*++

Routine Description:

    Write address array to hostent blob.

Arguments:

    pBlob -- hostent build blob

    pAddrArray - address array to write

    AddrCount - address count

    AddrSize - address size

    AddrType - address type (hostent type, e.g. AF_INET)

Return Value:

    ERROR_SUCCESS if successful.
    ERROR_MORE_DATA if out of buffer space
    ERROR_INVALID_DATA if address doesn't match hostent

--*/
{
    DWORD       count = AddrCount;
    PHOSTENT    phost = pBlob->pHostent;
    PCHAR       pcurrent;
    DWORD       totalSize;
    DWORD       i;
    DWORD       bytesLeft;

    //  verify type
    //      - set if empty or no addresses written

    if ( phost->h_addrtype != (SHORT)AddrType )
    {
        if ( phost->h_addrtype != 0 )
        {
            return( ERROR_INVALID_DATA );
        }
        phost->h_addrtype   = (SHORT) AddrType;
        phost->h_length     = (SHORT) AddrSize;
    }

    //  verify space

    if ( count > pBlob->MaxAddrCount )
    {
        return( ERROR_MORE_DATA );
    }

    //  align - to DWORD
    //
    //  note:  we are assuming that pAddrArray is internally
    //      aligned adequately, otherwise we wouldn't be
    //      getting an intact array and would have to add serially
    
    pcurrent = DWORD_ALIGN( pBlob->pCurrent );
    bytesLeft = pBlob->BytesLeft;
    bytesLeft -= (DWORD)(pcurrent - pBlob->pCurrent);

    totalSize = count * AddrSize;

    if ( bytesLeft < totalSize )
    {
        return( ERROR_MORE_DATA );
    }

    //  copy
    //      - copy address array to buffer
    //      - set pointer to each address in array
    //      - NULL following pointer

    RtlCopyMemory(
        pcurrent,
        pAddrArray,
        totalSize );

    for ( i=0; i<count; i++ )
    {
        phost->h_addr_list[i] = pcurrent;
        pcurrent += AddrSize;
    }
    phost->h_addr_list[count] = NULL;
    pBlob->AddrCount = count;

    pBlob->pCurrent = pcurrent;
    pBlob->BytesLeft = bytesLeft - totalSize;

    return( NO_ERROR );
}



DNS_STATUS
HostentBlob_WriteNameOrAlias(
    IN OUT  PHOSTENT_BLOB   pBlob,
    IN      PSTR            pszName,
    IN      BOOL            fAlias,
    IN      BOOL            fUnicode
    )
/*++

Routine Description:

    Write name or alias to hostent

Arguments:

    pBlob -- hostent build blob

    pszName -- name to write

    fAlias -- TRUE for alias;  FALSE for name

    fUnicode -- name is unicode

Return Value:

    ERROR_SUCCESS if successful.
    ERROR_MORE_DATA if out of buffer space
    ERROR_INVALID_DATA if address doesn't match hostent

--*/
{
    DWORD       count = pBlob->AliasCount;
    PHOSTENT    phost = pBlob->pHostent;
    DWORD       length;
    PCHAR       pcurrent;
    DWORD       bytesLeft;

    //
    //  check length
    //

    if ( fUnicode )
    {
        length = (wcslen( (PCWSTR)pszName ) + 1) * sizeof(WCHAR);
    }
    else
    {
        length = strlen( pszName ) + 1;
    }

    //
    //  verify space
    //  included ptr space
    //      - skip if already written name
    //      or exhausted alias array
    //      

    if ( fAlias )
    {
        if ( count >= pBlob->MaxAliasCount )
        {
            return( ERROR_MORE_DATA );
        }
    }
    else if ( pBlob->fWroteName )
    {
        return( ERROR_MORE_DATA );
    }

    //  align
    
    pcurrent = REQUIRED_HOSTENT_STRING_ALIGN_PTR( pBlob->pCurrent );
    bytesLeft = pBlob->BytesLeft;
    bytesLeft -= (DWORD)(pcurrent - pBlob->pCurrent);

    if ( bytesLeft < length )
    {
        return( ERROR_MORE_DATA );
    }

    //  copy
    //      - copy address to buffer
    //      - set pointer in addr list
    //      NULL following pointer

    RtlCopyMemory(
        pcurrent,
        pszName,
        length );

    if ( fAlias )
    {
        phost->h_aliases[count++]   = pcurrent;
        phost->h_aliases[count]     = NULL;
        pBlob->AliasCount = count;
    }
    else
    {
        phost->h_name = pcurrent;
        pBlob->fWroteName = TRUE;
    }

    length = REQUIRED_HOSTENT_STRING_ALIGN_DWORD( length );
    pBlob->pCurrent = pcurrent + length;
    pBlob->BytesLeft = bytesLeft - length;

    return( NO_ERROR );
}



DNS_STATUS
HostentBlob_WriteRecords(
    IN OUT  PHOSTENT_BLOB   pBlob,
    IN      PDNS_RECORD     pRecords,
    IN      BOOL            fWriteName
    )
/*++

Routine Description:

    Write name or alias to hostent

Arguments:

    pBlob -- hostent build blob

    pRecords -- records to convert to hostent

    fWriteName -- write name

Return Value:

    ERROR_SUCCESS if successful.
    ERROR_MORE_DATA if out of buffer space
    ERROR_INVALID_DATA if address doesn't match hostent

--*/
{
    DNS_STATUS  status = NO_ERROR;
    PDNS_RECORD prr = pRecords;

    DNSDBG( HOSTENT, (
        "HostentBlob_WriteRecords( %p, %p, %d )\n",
        pBlob,
        pRecords,
        fWriteName ));

    //
    //  write each record in turn to hostent
    //

    while ( prr )
    {
        WORD wtype;

        if ( prr->Flags.S.Section != DNSREC_ANSWER &&
             prr->Flags.S.Section != 0 )
        {
            prr = prr->pNext;
            continue;
        }

        wtype = prr->wType;

        switch( wtype )
        {
        case DNS_TYPE_A:

            status = HostentBlob_WriteAddress(
                            pBlob,
                            &prr->Data.A.IpAddress,
                            sizeof(IP4_ADDRESS),
                            AF_INET );
            break;

        case DNS_TYPE_AAAA:

            status = HostentBlob_WriteAddress(
                            pBlob,
                            &prr->Data.AAAA.Ip6Address,
                            sizeof(IP6_ADDRESS),
                            AF_INET6 );
            break;

        case DNS_TYPE_ATMA:
        {
            ATM_ADDRESS atmAddr;

            //  DCR:  functionalize ATMA to ATM conversion
            //      not sure this num of digits is correct
            //      may have to actually parse address

            atmAddr.AddressType = prr->Data.ATMA.AddressType;
            atmAddr.NumofDigits = ATM_ADDR_SIZE;
            RtlCopyMemory(
                & atmAddr.Addr,
                prr->Data.ATMA.Address,
                ATM_ADDR_SIZE );

            status = HostentBlob_WriteAddress(
                            pBlob,
                            & atmAddr,
                            sizeof(ATM_ADDRESS),
                            AF_ATM );
            break;
        }

        case DNS_TYPE_CNAME:

            //  record name is an alias

            status = HostentBlob_WriteNameOrAlias(
                        pBlob,
                        prr->pName,
                        TRUE,       // alias
                        (prr->Flags.S.CharSet == DnsCharSetUnicode)
                        );
            break;

        case DNS_TYPE_PTR:

            //  target name is the hostent name
            //  but if already wrote name, PTR target becomes alias

            status = HostentBlob_WriteNameOrAlias(
                        pBlob,
                        prr->Data.PTR.pNameHost,
                        pBlob->fWroteName
                            ? TRUE          // alias
                            : FALSE,        // name
                        (prr->Flags.S.CharSet == DnsCharSetUnicode)
                        );
            break;

        default:

            DNSDBG( ANY, (
                "Error record of type = %d while building hostent!\n",
                wtype ));
            status = ERROR_INVALID_DATA;
        }

        if ( status != ERROR_SUCCESS )
        {
            DNSDBG( ANY, (
                "ERROR:  failed writing record to hostent!\n"
                "\tprr      = %p\n"
                "\ttype     = %d\n"
                "\tstatus   = %d\n",
                prr,
                wtype,
                status ));
        }

        prr = prr->pNext;
    }

    IF_DNSDBG( HOSTENT )
    {
        DnsDbg_HostentBlob(
            "HostentBlob after WriteRecords():",
            pBlob );
    }

    return( status );
}



DNS_STATUS
HostentBlob_CreateFromRecords(
    IN OUT  PHOSTENT_BLOB * ppBlob,
    IN      PDNS_RECORD     pRecords,
    IN      BOOL            fWriteName,
    IN      INT             AddrFamily,     OPTIONAL
    IN      WORD            wType           OPTIONAL
    )
/*++

Routine Description:

    Create hostent from records

Arguments:

    ppBlob -- ptr with or to recv hostent blob

    pRecords -- records to convert to hostent

    fWriteName -- write name to hostent

    AddrFamily -- addr family use if PTR records and no addr

    wType  -- query type, if known

Return Value:

    Ptr to blob if successful.
    NULL on error;  GetLastError() has error.

--*/
{
    DNS_STATUS      status = NO_ERROR;
    PDNS_RECORD     prrFirstAddr = NULL;
    PDNS_RECORD     prr;
    DWORD           addrCount = 0;
    WORD            addrType = 0;
    HOSTENT_INIT    request;
    PHOSTENT_BLOB   pblob = *ppBlob;

    DNSDBG( HOSTENT, (
        "HostentBlob_CreateFromRecords()\n"
        "\tpblob    = %p\n"
        "\tprr      = %p\n",
        pblob,
        pRecords ));

    //
    //  count addresses
    //
    //  DCR:  fix up section hack when hosts file records get ANSWER section
    //

    prr = pRecords;

    while ( prr )
    {
        if ( ( prr->Flags.S.Section == 0 ||
               prr->Flags.S.Section == DNSREC_ANSWER )
                &&
             Hostent_IsSupportedAddrType( prr->wType ) )
        {
            addrCount++;
            if ( !prrFirstAddr )
            {
                prrFirstAddr = prr;
                addrType = prr->wType;
            }
        }
        prr = prr->pNext;
    }

    //          
    //  create or reinit hostent blob
    //

    RtlZeroMemory( &request, sizeof(request) );
    
    request.AliasCount  = DNS_MAX_ALIAS_COUNT;
    request.AddrCount   = addrCount;
    request.wType       = addrType;
    if ( !addrType )
    {
        request.AddrFamily = AddrFamily;
    }
    request.CharSet     = (pRecords)
                                ? pRecords->Flags.S.CharSet
                                : DnsCharSetUnicode;
    
    status = HostentBlob_Create(
                & pblob,
                & request );
    
    if ( status != NO_ERROR )
    {
        goto Done;
    }

    //
    //  build hostent from answer records
    //
    //  note:  if manage to extract any useful data => continue
    //  this protects against new unwriteable records breaking us
    //

    status = HostentBlob_WriteRecords(
                pblob,
                pRecords,
                TRUE        // write name
                );

    if ( status != NO_ERROR )
    {
        if ( pblob->AddrCount ||
             pblob->AliasCount ||
             pblob->fWroteName )
        {
            status = NO_ERROR;
        }
        else
        {
            goto Done;
        }
    }

    //
    //  write address from PTR record
    //      - first record PTR
    //      OR
    //      - queried for PTR and got CNAME answer, which can happen
    //      in classless reverse lookup case
    //  
    //  DCR:  add PTR address lookup to HostentBlob_WriteRecords()
    //      - natural place
    //      - but would have to figure out handling of multiple PTRs
    //

    if ( pRecords &&
         (  pRecords->wType == DNS_TYPE_PTR ||
            ( wType == DNS_TYPE_PTR &&
              pRecords->wType == DNS_TYPE_CNAME &&
              pRecords->Flags.S.Section == DNSREC_ANSWER ) ) )
    {
        IP6_ADDRESS     ip6;
        DWORD           addrLength = sizeof(IP6_ADDRESS);
        INT             family = 0;
    
        DNSDBG( HOSTENT, (
            "Writing address for PTR record %S\n",
            pRecords->pName ));
    
        //  convert reverse name to IP
    
        if ( Dns_StringToAddressEx(
                    (PCHAR) & ip6,
                    & addrLength,
                    (PCSTR) pRecords->pName,
                    & family,
                    IS_UNICODE_RECORD(pRecords),
                    TRUE            //  reverse lookup name
                    ) )
        {
            status = HostentBlob_WriteAddress(
                        pblob,
                        (PCHAR) &ip6,
                        addrLength,
                        family );

            ASSERT( status == NO_ERROR );
            status = ERROR_SUCCESS;
        }
    }

    //
    //  write name?
    //      - write name from first address record
    // 

    if ( !pblob->fWroteName &&
         fWriteName &&
         prrFirstAddr )
    {
        status = HostentBlob_WriteNameOrAlias(
                    pblob,
                    prrFirstAddr->pName,
                    FALSE,          // name
                    (prrFirstAddr->Flags.S.CharSet == DnsCharSetUnicode)
                    );
    }

    IF_DNSDBG( HOSTENT )
    {
        DnsDbg_HostentBlob(
            "HostentBlob after CreateFromRecords():",
            pblob );
    }

Done:

    if ( status != NO_ERROR  &&  pblob )
    {
        HostentBlob_Free( pblob );
        pblob = NULL;
    }

    *ppBlob = pblob;

    DNSDBG( HOSTENT, (
        "Leave HostentBlob_CreateFromRecords() => status = %d\n",
        status ));

    return( status );
}



//
//  Hostent Query
//

PHOSTENT_BLOB
HostentBlob_Query(
    IN      PWSTR           pwsName,
    IN      WORD            wType,
    IN      DWORD           Flags,
    IN OUT  PVOID *         ppMsg,      OPTIONAL
    IN      INT             AddrFamily  OPTIONAL
    )
/*++

Routine Description:

    Query DNS to create hostent.

Arguments:

    pwsName -- name to query

    wType -- query type

    Flags -- query flags

    ppMsg -- addr to recv ptr to message

    AddrType -- address type (family) to reserve space for if querying
        for PTR records

Return Value:

    Ptr to blob if successful.
    NULL on error;  GetLastError() has error.

--*/
{
    DNS_STATUS      status = NO_ERROR;
    PDNS_RECORD     prrQuery = NULL;
    PHOSTENT_BLOB   pblob = NULL;


    DNSDBG( HOSTENT, (
        "HostentBlob_Query()\n"
        "\tname     = %S\n"
        "\ttype     = %d\n"
        "\tflags    = %08x\n"
        "\tmsg out  = %p\n",
        pwsName,
        wType,
        Flags,
        ppMsg ));


    //
    //  query
    //      - if fails, dump any message before return
    //

    status = DnsQuery_W(
                pwsName,
                wType,
                Flags,
                NULL,
                &prrQuery,
                ppMsg );

    //  if failed, dump any message

    if ( status != NO_ERROR )
    {
        if ( ppMsg && *ppMsg )
        {
            DnsApiFree( *ppMsg );
            *ppMsg = NULL;
        }
        if ( status == RPC_S_SERVER_UNAVAILABLE )
        {
            status = WSATRY_AGAIN;
        }
        goto Done;
    }

    if ( !prrQuery )
    {
        ASSERT( FALSE );
        status = DNS_ERROR_RCODE_NAME_ERROR;
        goto Done;
    }

    //
    //  build hostent
    //

    status = HostentBlob_CreateFromRecords(
                & pblob,
                prrQuery,
                TRUE,       // write name from first answer
                AddrFamily,
                wType
                );
    if ( status != NO_ERROR )
    {
        goto Done;
    }

    //
    //  failed name write
    //      - PTR queries that CNAME but don't find a PTR can hit here
    //  

    if ( !pblob->fWroteName )
    {
        DNS_ASSERT( wType == DNS_TYPE_PTR );
        status = DNS_INFO_NO_RECORDS;
        goto Done;
    }

    //
    //  for address query must get answer
    //
    //  DCR:  DnsQuery() should convert to no-records on empty CNAME chain?
    //  DCR:  should we go ahead and build hostent?
    //

    if ( pblob->AddrCount == 0  &&  Hostent_IsSupportedAddrType(wType) )
    {
        status = DNS_INFO_NO_RECORDS;
    }

Done:

    if ( prrQuery )
    {
        DnsRecordListFree(
            prrQuery,
            DnsFreeRecordListDeep );
    }

    if ( status != NO_ERROR  &&  pblob )
    {
        HostentBlob_Free( pblob );
        pblob = NULL;
    }

    DNSDBG( HOSTENT, (
        "Leave HostentBlob_Query()\n"
        "\tpblob    = %p\n"
        "\tstatus   = %d\n",
        pblob,
        status ));

    SetLastError( status );

    return( pblob );
}




//
//  Special hostents
//

PHOSTENT_BLOB
HostentBlob_Localhost(
    IN      INT             Family
    )
/*++

Routine Description:

    Create hostent from records

Arguments:

    AddrFamily -- address family

Return Value:

    Ptr to blob if successful.
    NULL on error;  GetLastError() has error.

--*/
{
    DNS_STATUS      status = NO_ERROR;
    PDNS_RECORD     prrFirstAddr = NULL;
    PDNS_RECORD     prr;
    DWORD           addrCount = 0;
    DWORD           addrSize;
    CHAR            addrBuf[ sizeof(IP6_ADDRESS    ) ];
    HOSTENT_INIT    request;
    PHOSTENT_BLOB   pblob = NULL;

    DNSDBG( HOSTENT, ( "HostentBlob_Localhost()\n" ));

    //
    //  create hostent blob
    //

    RtlZeroMemory( &request, sizeof(request) );

    request.AliasCount  = 1;
    request.AddrCount   = 1;
    request.AddrFamily  = Family;
    request.fUnicode    = TRUE;

    status = HostentBlob_Create(
                & pblob,
                & request );

    if ( status != NO_ERROR )
    {
        goto Done;
    }

    //
    //  write in loopback address
    //

    if ( Family == AF_INET )
    {
        * (PIP4_ADDRESS) addrBuf = DNS_NET_ORDER_LOOPBACK;
        addrSize = sizeof(IP4_ADDRESS);
    }
    else if ( Family == AF_INET6 )
    {
        IP6_SET_ADDR_LOOPBACK( (PIP6_ADDRESS)addrBuf );
        addrSize = sizeof(IN6_ADDR);
    }
    else
    {
        status = DNS_ERROR_INVALID_DATA;
        goto Done;
    }

    status = HostentBlob_WriteAddress(
                pblob,
                addrBuf,
                addrSize,
                Family );

    if ( status != NO_ERROR )
    {
        goto Done;
    }

    //
    //  write localhost
    //

    status = HostentBlob_WriteNameOrAlias(
                pblob,
                (PSTR) L"localhost",
                FALSE,          // name
                TRUE            // unicode
                );

    IF_DNSDBG( HOSTENT )
    {
        DnsDbg_HostentBlob(
            "HostentBlob after localhost create:",
            pblob );
    }

Done:

    if ( status != NO_ERROR  &&  pblob )
    {
        HostentBlob_Free( pblob );
        pblob = NULL;
    }

    SetLastError( status );

    DNSDBG( HOSTENT, (
        "Leave Hostent_Localhost() => status = %d\n",
        status ));

    return( pblob );
}



DNS_STATUS
HostentBlob_CreateFromIpArray(
    IN OUT  PHOSTENT_BLOB * ppBlob,
    IN      INT             AddrFamily,
    IN      INT             AddrSize,
    IN      INT             AddrCount,
    IN      PCHAR           pArray,
    IN      PSTR            pName,
    IN      BOOL            fUnicode
    )
/*++

Routine Description:

    Create hostent from records

Arguments:

    ppBlob -- ptr with or to recv hostent blob

    AddrFamily -- addr family use if PTR records and no addr

    pArray -- array of addresses

    pName -- name for hostent

    fUnicode --
        TRUE if name is and hostent will be in unicode
        FALSE for narrow name and hostent

Return Value:

    Ptr to blob if successful.
    NULL on error;  GetLastError() has error.

--*/
{
    DNS_STATUS      status = NO_ERROR;
    HOSTENT_INIT    request;
    PHOSTENT_BLOB   pblob = *ppBlob;

    DNSDBG( HOSTENT, (
        "HostentBlob_CreateFromIpArray()\n"
        "\tppBlob   = %p\n"
        "\tfamily   = %d\n"
        "\tsize     = %d\n"
        "\tcount    = %d\n"
        "\tpArray   = %p\n",
        ppBlob,
        AddrFamily,
        AddrSize,
        AddrCount,
        pArray ));


    //          
    //  create or reinit hostent blob
    //

    RtlZeroMemory( &request, sizeof(request) );
    
    request.AliasCount  = DNS_MAX_ALIAS_COUNT;
    request.AddrCount   = AddrCount;
    request.AddrFamily  = AddrFamily;
    request.fUnicode    = fUnicode;
    request.pName       = pName;

    status = HostentBlob_Create(
                & pblob,
                & request );
    
    if ( status != NO_ERROR )
    {
        goto Done;
    }

    //
    //  write in array
    //

    if ( AddrCount )
    {
        status = HostentBlob_WriteAddressArray(
                    pblob,
                    pArray,
                    AddrCount,
                    AddrSize,
                    AddrFamily
                    );
        if ( status != NO_ERROR )
        {
            goto Done;
        }
    }

    //
    //  write name?
    //

    if ( pName )
    {
        status = HostentBlob_WriteNameOrAlias(
                    pblob,
                    pName,
                    FALSE,          // name not alias
                    fUnicode
                    );
    }

    IF_DNSDBG( HOSTENT )
    {
        DnsDbg_HostentBlob(
            "Leaving HostentBlob_CreateFromIpArray():",
            pblob );
    }

Done:

    if ( status != NO_ERROR  &&  pblob )
    {
        HostentBlob_Free( pblob );
        pblob = NULL;
    }

    *ppBlob = pblob;

    DNSDBG( HOSTENT, (
        "Leave HostentBlob_CreateFromIpArray() => status = %d\n",
        status ));

    return( status );
}



DNS_STATUS
HostentBlob_CreateLocal(
    IN OUT  PHOSTENT_BLOB * ppBlob,
    IN      INT             AddrFamily,
    IN      BOOL            fLoopback,
    IN      BOOL            fZero,
    IN      BOOL            fHostnameOnly
    )
/*++

Routine Description:

    Create hostent from records

Arguments:

    ppBlob -- ptr with or to recv hostent blob

    AddrFamily -- addr family use if PTR records and no addr

Return Value:

    Ptr to blob if successful.
    NULL on error;  GetLastError() has error.

--*/
{
    DNS_STATUS      status = NO_ERROR;
    PHOSTENT_BLOB   pblob = NULL;
    WORD            wtype;
    INT             size;
    IP6_ADDRESS     ip;


    DNSDBG( HOSTENT, (
        "HostentBlob_CreateLocal()\n"
        "\tppBlob       = %p\n"
        "\tfamily       = %d\n"
        "\tfLoopback    = %d\n"
        "\tfZero        = %d\n"
        "\tfHostname    = %d\n",
        ppBlob,
        AddrFamily,
        fLoopback,
        fZero,
        fHostnameOnly
        ));

    //
    //  get family info
    //      - start with override IP = 0
    //      - if loopback switch to appropriate loopback
    //

    RtlZeroMemory(
        &ip,
        sizeof(ip) );

    if ( AddrFamily == AF_INET )
    {
        wtype   = DNS_TYPE_A;
        size    = sizeof(IP4_ADDRESS);

        if ( fLoopback )
        {
            * (PIP4_ADDRESS) &ip = DNS_NET_ORDER_LOOPBACK;
        }
    }
    else if ( AddrFamily == AF_INET6 )
    {
        wtype   = DNS_TYPE_AAAA;
        size    = sizeof(IP6_ADDRESS);

        if ( fLoopback )
        {
            IP6_SET_ADDR_LOOPBACK( &ip );
        }
    }
    else
    {
        status = ERROR_INVALID_PARAMETER;
        goto Done;
    }

    //
    //  query for local host info
    //

    pblob = HostentBlob_Query(
                NULL,           // NULL name gets local host data
                wtype,
                0,              // standard query
                NULL,           // no message
                AddrFamily );
    if ( !pblob )
    {
        DNS_ASSERT( FALSE );
        status = GetLastError();
        goto Done;
    }

    //
    //  overwrite with specific address
    //

    if ( fLoopback || fZero )
    {
        if ( ! Hostent_SetToSingleAddress(
                    pblob->pHostent,
                    (PCHAR) &ip,
                    size ) )
        {
            DNS_ASSERT( pblob->AddrCount == 0 );

            pblob->AddrCount = 0;

            status = HostentBlob_WriteAddress(
                        pblob,
                        & ip,
                        size,
                        AddrFamily );
            if ( status != NO_ERROR )
            {
                DNS_ASSERT( status!=NO_ERROR );
                goto Done;
            }
        }
    }

    //
    //  for gethostname()
    //      - chop name down to just hostname
    //      - kill off aliases
    //

    if ( fHostnameOnly )
    {
        PWSTR   pname = (PWSTR) pblob->pHostent->h_name;
        PWSTR   pdomain;

        DNS_ASSERT( pname );
        if ( pname )
        {
            pdomain = Dns_GetDomainNameW( pname );
            if ( pdomain )
            {
                DNS_ASSERT( pdomain > pname+1 );
                DNS_ASSERT( *(pdomain-1) == L'.' );

                *(pdomain-1) = 0;
            }
        }                     
        pblob->pHostent->h_aliases = NULL;
    }

    IF_DNSDBG( HOSTENT )
    {
        DnsDbg_HostentBlob(
            "Leaving HostentBlob_CreateLocal():",
            pblob );
    }

Done:

    if ( status != NO_ERROR  &&  pblob )
    {
        HostentBlob_Free( pblob );
        pblob = NULL;
    }

    *ppBlob = pblob;

    DNSDBG( HOSTENT, (
        "Leave HostentBlob_CreateLocal() => status = %d\n",
        status ));

    return( status );
}

//
//  End hostent.c
//
=== C:/Users/treeman/Desktop/windows nt source code\Source\Win2K3\NT\ds\dns\dnslib\ip6.c ===
/*++

Copyright (c) 1995-2001 Microsoft Corporation

Module Name:

    ip6.c

Abstract:

    Domain Name System (DNS) Library

    IP6 address array routines.

Author:

    Jim Gilroy (jamesg)     October 2001

Revision History:

--*/


#include "local.h"

//
//  Max IP count when doing IP array to\from string conversions
//

#define MAX_PARSE_IP    (1000)

//
//  For IP6 debug string writing.
//

CHAR g_Ip6StringBuffer[ IP6_ADDRESS_STRING_BUFFER_LENGTH ];

//
//  IP6 Mcast address base
//      FF02:0:0:0:0:2::/96 base plus 32bits of hash
//

// IP6_ADDRESS g_Ip6McastBaseAddr = {0xFF,2, 0,0, 0,0, 0,0, 0,0, 0,2, 0,0, 0,0};




//
//  General IP6 routines.
//

VOID
Dns_Md5Hash(
    OUT     PBYTE           pHash,
    IN      PSTR            pName
    )
/*++

Routine Description:

    Create MD5 hash of name.

Arguments:

    pHash -- 128bit (16 byte) buffer to recv hash

    pName -- name to hash

Return Value:

    None

--*/
{
    DNSDBG( TRACE, (
        "Dns_Md5Hash( %p, %s )\n",
        pHash,
        pName ));

    //
    //  DCR: FIX0:  need real MD5 hash -- ask Lars, Scott
    //

    {
        DWORD   sum = 0;
    
        RtlZeroMemory(
            pHash,
            16 );
    
        while ( *pName )
        {
            sum += *pName++;
        }
    
        * (PDWORD)pHash = sum;
    }
}


BOOL
Ip6_McastCreate(
    OUT     PIP6_ADDRESS    pIp,
    IN      PWSTR           pName
    )
/*++

Routine Description:

    Create mcast IP6 address.

Arguments:

    pIp -- address to set with mcast address

    pName -- DNS name mcast address is for

Return Value:

    TRUE if made mcast address for name.
    FALSE on error.

--*/
{
    WCHAR       label[ DNS_MAX_LABEL_BUFFER_LENGTH ];
    WCHAR       downLabel[ DNS_MAX_LABEL_BUFFER_LENGTH ];
    CHAR        utf8Label[ DNS_MAX_LABEL_BUFFER_LENGTH ];
    CHAR        md5Hash[ 16 ];   // 128bit hash
    IP6_ADDRESS mcastAddr;
    DWORD       bufLength;


    DNSDBG( TRACE, (
        "Ip6_McastCreate( %p, %S )\n",
        pIp,
        pName ));

    //
    //  hash of downcased label
    //

    Dns_CopyNameLabelW(
        label,
        pName );

    Dns_MakeCanonicalNameW(
        downLabel,
        DNS_MAX_LABEL_BUFFER_LENGTH,
        label,
        0       // null terminated
        );

    bufLength = DNS_MAX_LABEL_BUFFER_LENGTH;

    if ( !Dns_StringCopy(
            utf8Label,
            & bufLength,
            (PCHAR) downLabel,
            0,                  // null terminated
            DnsCharSetUnicode,
            DnsCharSetUtf8 ) )
    {
        DNS_ASSERT( FALSE );
        return  FALSE;
    }

    //
    //  hash
    //

    Dns_Md5Hash(
        md5Hash,
        utf8Label );

    //   mcast addr
    //      - first 12 bytes are fixed
    //      - last 4 bytes are first 32bits of hash

#if 0
    IP6_ADDR_COPY(
        pIp,
        & g_Ip6McastBaseAddr );
#else
    RtlZeroMemory(
        pIp,
        sizeof(IP6_ADDRESS) );

    pIp->IP6Byte[0]   = 0xff;
    pIp->IP6Byte[1]   = 2;
    pIp->IP6Byte[11]  = 2;

#endif
    RtlCopyMemory(
        & pIp->IP6Dword[3],
        md5Hash,
        sizeof(DWORD) );

    return  TRUE;
}



DWORD
Ip6_CopyFromSockaddr(
    OUT     PIP6_ADDRESS    pIp,
    IN      PSOCKADDR       pSockAddr,
    IN      INT             Family
    )
/*++

Routine Description:

    Extract IP from sockaddr.

Arguments:

    pIp -- addr to set with IP6 address

    pSockaddr -- ptr to sockaddr

    Family --
        AF_INET6 to only extract if 6
        AF_INET4 to only extract if 4
        0 to extract always

Return Value:

    Family extracted (AF_INET) or (AF_INET6) if successful.
    Zero on bad sockaddr family.

--*/
{
    DWORD   saFamily = pSockAddr->sa_family;

    if ( Family &&
         saFamily != Family )
    {
        return 0;
    }

    if ( saFamily == AF_INET6 )
    {
        IP6_ADDR_COPY(
            pIp,
            (PIP6_ADDRESS) &((PSOCKADDR_IN6)pSockAddr)->sin6_addr );
    }
    else if ( saFamily == AF_INET )
    {
        IP6_SET_ADDR_V4MAPPED(
            pIp,
            ((PSOCKADDR_IN)pSockAddr)->sin_addr.s_addr );
    }
    else
    {
        saFamily = 0;
    }

    return  saFamily;
}



INT
Ip6_Family(
    IN      PIP6_ADDRESS    pIp
    )
/*++

Routine Description:

    Get IP6 family
        AF_INET if V4MAPPED
        AF_INET6 otherwise

Arguments:

    pIp -- addr

Return Value:

    AF_INET if address is V4MAPPED
    AF_INET6 otherwise

--*/
{
    return  IP6_IS_ADDR_V4MAPPED(pIp) ? AF_INET : AF_INET6;
}



INT
Ip6_WriteSockaddr(
    OUT     PSOCKADDR       pSockaddr,
    OUT     PDWORD          pSockaddrLength,    OPTIONAL
    IN      PIP6_ADDRESS    pIp,
    IN      WORD            Port                OPTIONAL
    )
/*++

Routine Description:

    Write sockaddr with IP6 or IP4 address.

Arguments:

    pSockaddr -- ptr to sockaddr, must be at least SOCKADDR_IN6 size

    pSockaddrLength -- ptr to DWORD to set be with sockaddr length

    pIp -- addr to set with IP6 address

    Port -- port to write

Return Value:

    Family written (AF_INET) or (AF_INET6) if successful.
    Zero on bad sockaddr family.

--*/
{
    WORD        family;
    DWORD       length;
    IP4_ADDRESS ip4;

    DNSDBG( SOCKET, (
        "Ip6_WriteSockaddr( %p, %p, %p, %d )\n",
        pSockaddr,
        pSockaddrLength,
        pIp,
        Port ));

    //  zero

    RtlZeroMemory(
        pSockaddr,
        sizeof( SOCKADDR_IN6 ) );

    //
    //  fill in sockaddr for IP4 or IP6
    //

    ip4 = IP6_GET_V4_ADDR_IF_MAPPED( pIp );

    if ( ip4 != BAD_IP4_ADDR )
    {
        family = AF_INET;
        length = sizeof(SOCKADDR_IN);

        ((PSOCKADDR_IN)pSockaddr)->sin_addr.s_addr = ip4;
    }
    else
    {
        family = AF_INET6;
        length = sizeof(SOCKADDR_IN6);

        RtlCopyMemory(
            (PIP6_ADDRESS) &((PSOCKADDR_IN6)pSockaddr)->sin6_addr,
            pIp,
            sizeof(IP6_ADDRESS) );
    }

    //  fill family and port -- same position for both type

    pSockaddr->sa_family = family;
    ((PSOCKADDR_IN)pSockaddr)->sin_port = Port;

    //  return length if requested

    if ( pSockaddrLength )
    {
        *pSockaddrLength = length;
    }

    return  family;
}



INT
Ip6_WriteDnsAddr(
    OUT     PDNS_ADDR       pDnsAddr,
    IN      PIP6_ADDRESS    pIp,
    IN      WORD            Port        OPTIONAL
    )
/*++

Routine Description:

    Write DNS_ADDR      with IP6 or IP4 address.

Arguments:

    pSockaddr -- ptr to sockaddr blob

    pIp -- addr to set with IP6 address

    Port -- port to write

Return Value:

    Family written (AF_INET) or (AF_INET6) if successful.
    Zero on bad sockaddr family.

--*/
{
    return  Ip6_WriteSockaddr(
                & pDnsAddr->Sockaddr,
                & pDnsAddr->SockaddrLength,
                pIp,
                Port );
}



PSTR
Ip6_TempNtoa(
    IN      PIP6_ADDRESS    pIp
    )
/*++

Routine Description:

    Get string for IP6 address.

    This is temp inet6_ntoa() until i get that built.
    This will work for all IP4 addresses and will (we presume)
    only rarely collide on IP6.

Arguments:

    pIp -- ptr to IP to get string for

Return Value:

    Address string.

--*/
{
    //  make life simple

    if ( !pIp )
    {
        return  NULL;
    }

    //  if IP4, use existing inet_ntoa()

    if ( IP6_IS_ADDR_V4MAPPED( pIp ) )
    {
        return  inet_ntoa( *(IN_ADDR *) &pIp->IP6Dword[3] );
    }

    //  if IP6 write into global buffer
    //      - until inet6_ntoa() which will use existing TLS block

    g_Ip6StringBuffer[0] = 0;

    RtlIpv6AddressToStringA(
        (PIN6_ADDR) pIp,
        g_Ip6StringBuffer );

    return  g_Ip6StringBuffer;
}



PSTR
Ip6_AddrStringForSockaddr(
    IN      PSOCKADDR       pSockaddr
    )
/*++

Routine Description:

    Get string for sockaddr.

Arguments:

    pSockaddr -- ptr to sockaddr

Return Value:

    Address string.

--*/
{
    IP6_ADDRESS ip6;

    if ( ! pSockaddr ||
         ! Ip6_CopyFromSockaddr(
             & ip6,
             pSockaddr,
             0 ) )
    {
        return  NULL;
    }

    return  Ip6_TempNtoa( &ip6 );
}



//
//  Routines to handle actual array of IP addresses.
//

PIP6_ADDRESS  
Ip6_FlatArrayCopy(
    IN      PIP6_ADDRESS    AddrArray,
    IN      DWORD           Count
    )
/*++

Routine Description:

    Create copy of IP address array.

Arguments:

    AddrArray -- array of IP addresses

    Count -- count of IP addresses

Return Value:

    Ptr to IP address array copy, if successful
    NULL on failure.

--*/
{
    PIP6_ADDRESS   parray;

    //  validate

    if ( ! AddrArray || Count == 0 )
    {
        return( NULL );
    }

    //  allocate memory and copy

    parray = (PIP6_ADDRESS) ALLOCATE_HEAP( Count*sizeof(IP6_ADDRESS) );
    if ( ! parray )
    {
        return( NULL );
    }

    memcpy(
        parray,
        AddrArray,
        Count*sizeof(IP6_ADDRESS) );

    return( parray );
}



#if 0
BOOL
Dns_ValidateIp6Array(
    IN      PIP6_ADDRESS    AddrArray,
    IN      DWORD           Count,
    IN      DWORD           dwFlag
    )
/*++

Routine Description:

    Validate IP address array.

    Current checks:
        - existence
        - non-broadcast
        - non-lookback

Arguments:

    AddrArray -- array of IP addresses

    Count -- count of IP addresses

    dwFlag -- validity tests to do;  currently unused

Return Value:

    TRUE if valid IP addresses.
    FALSE if invalid address found.

--*/
{
    DWORD   i;

    //
    //  protect against bad parameters
    //

    if ( Count && ! AddrArray )
    {
        return( FALSE );
    }

    //
    //  check each IP address
    //

    for ( i=0; i < Count; i++)
    {
        //  DCR:  need IP6 validations
        if( AddrArray[i] == INADDR_ANY
                ||
            AddrArray[i] == INADDR_BROADCAST
                ||
            AddrArray[i] == INADDR_LOOPBACK )
        {
            return( FALSE );
        }
    }
    return( TRUE );
}
#endif



//
//  IP6_ARRAY routines
//

DWORD
Ip6Array_Sizeof(
    IN      PIP6_ARRAY      pIpArray
    )
/*++

Routine Description:

    Get size in bytes of IP address array.

Arguments:

    pIpArray -- IP address array to find size of

Return Value:

    Size in bytes of IP array.

--*/
{
    if ( ! pIpArray )
    {
        return 0;
    }
    return  (pIpArray->AddrCount * sizeof(IP6_ADDRESS)) + 2*sizeof(DWORD);
}



BOOL
Ip6Array_Probe(
    IN      PIP6_ARRAY      pIpArray
    )
/*++

Routine Description:

    Touch all entries in IP array to insure valid memory.

Arguments:

    pIpArray -- ptr to IP address array

Return Value:

    TRUE if successful.
    FALSE otherwise

--*/
{
    DWORD   i;
    BOOL    result;

    if ( ! pIpArray )
    {
        return( TRUE );
    }
    for ( i=0; i<pIpArray->AddrCount; i++ )
    {
        result = IP6_IS_ADDR_LOOPBACK( &pIpArray->AddrArray[i] );
    }
    return( TRUE );
}


#if 0

BOOL
Ip6Array_ValidateSizeOf(
    IN      PIP6_ARRAY      pIpArray,
    IN      DWORD           dwMemoryLength
    )
/*++

Routine Description:

    Check that size of IP array, corresponds to length of memory.

Arguments:

    pIpArray -- ptr to IP address array

    dwMemoryLength -- length of IP array memory

Return Value:

    TRUE if IP array size matches memory length
    FALSE otherwise

--*/
{
    return( Ip6Array_SizeOf(pIpArray) == dwMemoryLength );
}
#endif



VOID
Ip6Array_Init(
    IN OUT  PIP6_ARRAY      pIpArray,
    IN      DWORD           MaxCount
    )
/*++

Routine Description:

    Init memory as IP6 array.

Arguments:

    pArray -- array to init

    MaxCount -- count of addresses

Return Value:

    None

--*/
{
    pIpArray->MaxCount = MaxCount;
    pIpArray->AddrCount = 0;
}



VOID
Ip6Array_Free(
    IN      PIP6_ARRAY      pIpArray
    )
/*++

Routine Description:

    Free IP array.
    Only for arrays created through create routines below.

Arguments:

    pIpArray -- IP array to free.

Return Value:

    None

--*/
{
    FREE_HEAP( pIpArray );
}



PIP6_ARRAY
Ip6Array_Create(
    IN      DWORD           MaxCount
    )
/*++

Routine Description:

    Create uninitialized IP address array.

Arguments:

    AddrCount -- count of addresses array will hold

Return Value:

    Ptr to uninitialized IP address array, if successful
    NULL on failure.

--*/
{
    PIP6_ARRAY  parray;

    DNSDBG( IPARRAY, ( "Ip6Array_Create() of count %d\n", MaxCount ));

    parray = (PIP6_ARRAY) ALLOCATE_HEAP_ZERO(
                        (MaxCount * sizeof(IP6_ADDRESS)) +
                        sizeof(IP6_ARRAY) - sizeof(IP6_ADDRESS) );
    if ( ! parray )
    {
        return( NULL );
    }

    //
    //  initialize IP count
    //

    parray->MaxCount = MaxCount;

    DNSDBG( IPARRAY, (
        "Ip6Array_Create() new array (count %d) at %p\n",
        MaxCount,
        parray ));

    return( parray );
}



PIP6_ARRAY
Ip6Array_CreateFromIp4Array(
    IN      PIP4_ARRAY      pIp4Array
    )
/*++

Routine Description:

    Create IP6 array from IP4 array.

Arguments:

    pIp4Array -- IP4 array

Return Value:

    Ptr to uninitialized IP address array, if successful
    NULL on failure.

--*/
{
    PIP6_ARRAY  parray;
    DWORD       i;

    DNSDBG( IPARRAY, (
        "Ip6Array_CreateFromIp4Array( %p )\n",
        pIp4Array ));

    if ( ! pIp4Array )
    {
        return( NULL );
    }

    //
    //  allocate the array
    //

    parray = Ip6Array_Create( pIp4Array->AddrCount );
    if ( !parray )
    {
        return  NULL;
    }

    //
    //  fill the array
    //

    for ( i=0; i<pIp4Array->AddrCount; i++ )
    {
        Ip6Array_AddIp4(
            parray,
            pIp4Array->AddrArray[i],
            FALSE       // no duplicate screen
            );
    }

    DNSDBG( IPARRAY, (
        "Leave Ip6Array_CreateFromIp4Array() new array (count %d) at %p\n",
        parray->AddrCount,
        parray ));

    return( parray );
}



PIP6_ARRAY
Ip6Array_CreateFromFlatArray(
    IN      DWORD           AddrCount,
    IN      PIP6_ADDRESS    pipAddrs
    )
/*++

Routine Description:

    Create IP address array structure from existing array of IP addresses.

Arguments:

    AddrCount -- count of addresses in array
    pipAddrs -- IP address array

Return Value:

    Ptr to IP address array.
    NULL on failure.

--*/
{
    PIP6_ARRAY  parray;

    if ( ! pipAddrs || ! AddrCount )
    {
        return( NULL );
    }

    //  create IP array of desired size
    //  then copy incoming array of addresses

    parray = Ip6Array_Create( AddrCount );
    if ( ! parray )
    {
        return( NULL );
    }

    memcpy(
        parray->AddrArray,
        pipAddrs,
        AddrCount * sizeof(IP6_ADDRESS) );

    parray->AddrCount = AddrCount;

    return( parray );
}



PIP6_ARRAY
Ip6Array_CopyAndExpand(
    IN      PIP6_ARRAY      pIpArray,
    IN      DWORD           ExpandCount,
    IN      BOOL            fDeleteExisting
    )
/*++

Routine Description:

    Create expanded copy of IP address array.

Arguments:

    pIpArray -- IP address array to copy

    ExpandCount -- number of IP to expand array size by

    fDeleteExisting -- TRUE to delete existing array;
        this is useful when function is used to grow existing
        IP array in place;  note that locking must be done
        by caller

        note, that if new array creation FAILS -- then old array
        is NOT deleted

Return Value:

    Ptr to IP array copy, if successful
    NULL on failure.

--*/
{
    PIP6_ARRAY  pnewArray;
    DWORD       newCount;

    //
    //  no existing array -- just create desired size
    //

    if ( ! pIpArray )
    {
        if ( ExpandCount )
        {
            return  Ip6Array_Create( ExpandCount );
        }
        return( NULL );
    }

    //
    //  create IP array of desired size
    //  then copy any existing addresses
    //

    pnewArray = Ip6Array_Create( pIpArray->AddrCount + ExpandCount );
    if ( ! pnewArray )
    {
        return( NULL );
    }

    RtlCopyMemory(
        (PBYTE) pnewArray->AddrArray,
        (PBYTE) pIpArray->AddrArray,
        pIpArray->AddrCount * sizeof(IP6_ADDRESS) );

    //
    //  delete existing -- for "grow mode"
    //

    if ( fDeleteExisting )
    {
        FREE_HEAP( pIpArray );
    }

    return( pnewArray );
}



PIP6_ARRAY
Ip6Array_CreateCopy(
    IN      PIP6_ARRAY      pIpArray
    )
/*++

Routine Description:

    Create copy of IP address array.

Arguments:

    pIpArray -- IP address array to copy

Return Value:

    Ptr to IP address array copy, if successful
    NULL on failure.

--*/
{
#if 0
    PIP6_ARRAY  pIpArrayCopy;

    if ( ! pIpArray )
    {
        return( NULL );
    }

    //  create IP array of desired size
    //  then copy entire structure

    pIpArrayCopy = Ip6Array_Create( pIpArray->AddrCount );
    if ( ! pIpArrayCopy )
    {
        return( NULL );
    }

    memcpy(
        pIpArrayCopy,
        pIpArray,
        Ip6Array_Sizeof(pIpArray) );

    return( pIpArrayCopy );
#endif

    //
    //  call essentially "CopyEx" function
    //
    //  note, not macroing this because this may well become
    //      a DLL entry point
    //

    return  Ip6Array_CopyAndExpand(
                pIpArray,
                0,          // no expansion
                0           // don't delete existing array
                );
}



BOOL
Ip6Array_ContainsIp(
    IN      PIP6_ARRAY      pIpArray,
    IN      PIP6_ADDRESS    pIp
    )
/*++

Routine Description:

    Check if IP array contains desired address.

Arguments:

    pIpArray -- IP address array to copy

    pIp -- IP to check for

Return Value:

    TRUE if address in array.
    Ptr to IP address array copy, if successful
    NULL on failure.

--*/
{
    DWORD i;

    if ( ! pIpArray )
    {
        return( FALSE );
    }
    for (i=0; i<pIpArray->AddrCount; i++)
    {
        if ( IP6_ADDR_EQUAL( pIp, &pIpArray->AddrArray[i] ) )
        {
            return( TRUE );
        }
    }
    return( FALSE );
}



BOOL
Ip6Array_AddIp(
    IN OUT  PIP6_ARRAY      pIpArray,
    IN      PIP6_ADDRESS    pAddIp,
    IN      BOOL            fScreenDups
    )
/*++

Routine Description:

    Add IP address to IP array.

    Allowable "slot" in array, is any zero IP address.

Arguments:

    pIpArray -- IP address array to add to

    pAddIp -- IP address to add to array

    fScreenDups -- screen out duplicates

Return Value:

    TRUE if successful.
    FALSE if array full.

--*/
{
    DWORD   count;

    //
    //  screen for existence
    //
    //  this check makes it easy to write code that does
    //  Add\Full?=>Expand loop without having to write
    //  startup existence\create code
    //  

    if ( !pIpArray )
    {
        return  FALSE;
    }

    //
    //  check for duplicates
    //

    if ( fScreenDups )
    {
        if ( Ip6Array_ContainsIp( pIpArray, pAddIp ) )
        {
            return  TRUE;
        }
    }

    count = pIpArray->AddrCount;
    if ( count >= pIpArray->MaxCount )
    {
        return  FALSE;
    }

    IP6_ADDR_COPY(
        &pIpArray->AddrArray[ count ],
        pAddIp );

    pIpArray->AddrCount = ++count;
    return  TRUE;
}



BOOL
Ip6Array_AddSockaddr(
    IN OUT  PIP6_ARRAY      pIpArray,
    IN      PSOCKADDR       pSockaddr,
    IN      DWORD           Family,
    IN      BOOL            fScreenDups
    )
/*++

Routine Description:

    Add IP address to IP array.

    Allowable "slot" in array, is any zero IP address.

Arguments:

    pIpArray -- IP address array to add to

    pAddIp -- IP address to add to array

    Family -- required family to do add;  0 for add always

    fScreenDups -- screen out duplicates

Return Value:

    TRUE if successful.
    FALSE if array full.

--*/
{
    IP6_ADDRESS ip6;

    if ( !Ip6_CopyFromSockaddr(
            & ip6,
            pSockaddr,
            Family ) )
    {
        return  FALSE;
    }

    return  Ip6Array_AddIp(
                pIpArray,
                &ip6,
                fScreenDups );
}



BOOL
Ip6Array_AddIp4(
    IN OUT  PIP6_ARRAY      pIpArray,
    IN      IP4_ADDRESS     Ip4,
    IN      BOOL            fScreenDups
    )
/*++

Routine Description:

    Add IP4 address to IP array.

Arguments:

    pIpArray -- IP address array to add to

    Ip4 -- IP4 address to add to array

    fScreenDups -- screen out duplicates

Return Value:

    TRUE if successful.
    FALSE if array full.

--*/
{
    IP6_ADDRESS ip6;

    IP6_SET_ADDR_V4MAPPED(
        &ip6,
        Ip4 );

    return  Ip6Array_AddIp(
                pIpArray,
                &ip6,
                fScreenDups );
}



VOID
Ip6Array_Clear(
    IN OUT  PIP6_ARRAY      pIpArray
    )
/*++

Routine Description:

    Clear memory in IP array.

Arguments:

    pIpArray -- IP address array to clear

Return Value:

    None.

--*/
{
    //  clear just the address list, leaving count intact

    RtlZeroMemory(
        pIpArray->AddrArray,
        pIpArray->AddrCount * sizeof(IP6_ADDRESS) );
}



VOID
Ip6Array_Reverse(
    IN OUT  PIP6_ARRAY      pIpArray
    )
/*++

Routine Description:

    Reorder the list of IPs in reverse.

Arguments:

    pIpArray -- IP address array to reorder

Return Value:

    None.

--*/
{
    IP6_ADDRESS tempIp;
    DWORD       i;
    DWORD       j;

    //
    //  swap IPs working from ends to the middle
    //

    if ( pIpArray &&
         pIpArray->AddrCount )
    {
        for ( i = 0, j = pIpArray->AddrCount - 1;
              i < j;
              i++, j-- )
        {
            IP6_ADDR_COPY(
                & tempIp,
                & pIpArray->AddrArray[i] );

            IP6_ADDR_COPY(
                & pIpArray->AddrArray[i],
                & pIpArray->AddrArray[j] );

            IP6_ADDR_COPY(
                & pIpArray->AddrArray[j],
                & tempIp );
        }
    }
}



BOOL
Ip6Array_CheckAndMakeIpArraySubset(
    IN OUT  PIP6_ARRAY      pIpArraySub,
    IN      PIP6_ARRAY      pIpArraySuper
    )
/*++

Routine Description:

    Clear entries from IP array until it is subset of another IP array.

Arguments:

    pIpArraySub -- IP array to make into subset

    pIpArraySuper -- IP array superset

Return Value:

    TRUE if pIpArraySub is already subset.
    FALSE if needed to nix entries to make IP array a subset.

--*/
{
    DWORD   i;
    DWORD   newCount;

    //
    //  check each entry in subset IP array,
    //  if not in superset IP array, eliminate it
    //

    newCount = pIpArraySub->AddrCount;

    for (i=0; i < newCount; i++)
    {
        if ( ! Ip6Array_ContainsIp(
                    pIpArraySuper,
                    & pIpArraySub->AddrArray[i] ) )
        {
            //  remove this IP entry and replace with
            //  last IP entry in array

            newCount--;
            if ( i >= newCount )
            {
                break;
            }
            IP6_ADDR_COPY(
                & pIpArraySub->AddrArray[i],
                & pIpArraySub->AddrArray[ newCount ] );
        }
    }

    //  if eliminated entries, reset array count

    if ( newCount < pIpArraySub->AddrCount )
    {
        pIpArraySub->AddrCount = newCount;
        return( FALSE );
    }
    return( TRUE );
}



DWORD
WINAPI
Ip6Array_DeleteIp(
    IN OUT  PIP6_ARRAY      pIpArray,
    IN      PIP6_ADDRESS    pIpDelete
    )
/*++

Routine Description:

    Delete IP address from IP array.

Arguments:

    pIpArray -- IP address array to add to

    pIpDelete -- IP address to delete from array

Return Value:

    Count of instances of IpDelete found in array.

--*/
{
    DWORD   found = 0;
    INT     i;
    INT     currentLast;

    i = currentLast = pIpArray->AddrCount-1;

    //
    //  check each IP for match to delete IP
    //      - go backwards through array
    //      - swap in last IP in array
    //

    while ( i >= 0 )
    {
        if ( IP6_ADDR_EQUAL( &pIpArray->AddrArray[i], pIpDelete ) )
        {
            IP6_ADDR_COPY(
                & pIpArray->AddrArray[i],
                & pIpArray->AddrArray[ currentLast ] );

            IP6_SET_ADDR_ANY( &pIpArray->AddrArray[ currentLast ] );

            currentLast--;
            found++;
        }
        i--;
    }

    pIpArray->AddrCount = currentLast + 1;

    return( found );
}



#if 0
INT
WINAPI
Ip6Array_Clean(
    IN OUT  PIP6_ARRAY      pIpArray,
    IN      DWORD           Flag
    )
/*++

Routine Description:

    Clean IP array.

    Remove bogus stuff from IP Array:
        -- Zeros
        -- Loopback
        -- AutoNet

Arguments:

    pIpArray -- IP address array to add to

    Flag -- which cleanups to make

Return Value:

    Count of instances cleaned from array.

--*/
{
    DWORD       found = 0;
    INT         i;
    INT         currentLast;
    IP6_ADDRESS ip;

    i = currentLast = pIpArray->AddrCount-1;

    while ( i >= 0 )
    {
        ip = pIpArray->AddrArray[i];

        if (
            ( (Flag & DNS_IPARRAY_CLEAN_LOOPBACK) && ip == DNS_NET_ORDER_LOOPBACK )
                ||
            ( (Flag & DNS_IPARRAY_CLEAN_ZERO) && ip == 0 )
                ||
            ( (Flag & DNS_IPARRAY_CLEAN_AUTONET) && DNS_IS_AUTONET_IP(ip) ) )
        {
            //  remove IP from array

            pIpArray->AddrArray[i] = pIpArray->AddrArray[ currentLast ];
            currentLast--;
            found++;
        }
        i--;
    }

    pIpArray->AddrCount -= found;
    return( found );
}
#endif



DNS_STATUS
WINAPI
Ip6Array_Diff(
    IN       PIP6_ARRAY     pIpArray1,
    IN       PIP6_ARRAY     pIpArray2,
    OUT      PIP6_ARRAY*    ppOnlyIn1,
    OUT      PIP6_ARRAY*    ppOnlyIn2,
    OUT      PIP6_ARRAY*    ppIntersect
    )
/*++

Routine Description:

    Computes differences and intersection of two IP arrays.

    Out arrays are allocated with Ip6Array_Alloc(), caller must free with Ip6Array_Free()

Arguments:

    pIpArray1 -- IP array

    pIpArray2 -- IP array

    ppOnlyIn1 -- addr to recv IP array of addresses only in array 1 (not in array2)

    ppOnlyIn2 -- addr to recv IP array of addresses only in array 2 (not in array1)

    ppIntersect -- addr to recv IP array of intersection addresses

Return Value:

    ERROR_SUCCESS if successful.
    DNS_ERROR_NO_MEMORY if unable to allocate memory for IP arrays.

--*/
{
    DWORD       j;
    PIP6_ADDRESS   pip;
    PIP6_ARRAY  intersectArray = NULL;
    PIP6_ARRAY  only1Array = NULL;
    PIP6_ARRAY  only2Array = NULL;

    //
    //  create result IP arrays
    //

    if ( ppIntersect )
    {                                 
        intersectArray = Ip6Array_CreateCopy( pIpArray1 );
        if ( !intersectArray )
        {
            goto NoMem;
        }
        *ppIntersect = intersectArray;
    }
    if ( ppOnlyIn1 )
    {
        only1Array = Ip6Array_CreateCopy( pIpArray1 );
        if ( !only1Array )
        {
            goto NoMem;
        }
        *ppOnlyIn1 = only1Array;
    }
    if ( ppOnlyIn2 )
    {
        only2Array = Ip6Array_CreateCopy( pIpArray2 );
        if ( !only2Array )
        {
            goto NoMem;
        }
        *ppOnlyIn2 = only2Array;
    }

    //
    //  clean the arrays
    //

    for ( j=0;   j< pIpArray1->AddrCount;   j++ )
    {
        pip = &pIpArray1->AddrArray[j];

        //  if IP in both arrays, delete from "only" arrays

        if ( Ip6Array_ContainsIp( pIpArray2, pip ) )
        {
            if ( only1Array )
            {
                Ip6Array_DeleteIp( only1Array, pip );
            }
            if ( only2Array )
            {
                Ip6Array_DeleteIp( only2Array, pip );
            }
        }

        //  if IP not in both arrays, delete from intersection
        //      note intersection started as IpArray1

        else if ( intersectArray )
        {
            Ip6Array_DeleteIp( intersectArray, pip );
        }
    }

    return( ERROR_SUCCESS );

NoMem:

    if ( intersectArray )
    {
        FREE_HEAP( intersectArray );
    }
    if ( only1Array )
    {
        FREE_HEAP( only1Array );
    }
    if ( only2Array )
    {
        FREE_HEAP( only2Array );
    }
    if ( ppIntersect )
    {
        *ppIntersect = NULL;
    }
    if ( ppOnlyIn1 )
    {
        *ppOnlyIn1 = NULL;
    }
    if ( ppOnlyIn2 )
    {
        *ppOnlyIn2 = NULL;
    }
    return( DNS_ERROR_NO_MEMORY );
}



BOOL
WINAPI
Ip6Array_IsIntersection(
    IN       PIP6_ARRAY     pIpArray1,
    IN       PIP6_ARRAY     pIpArray2
    )
/*++

Routine Description:

    Determine if there's intersection of two IP arrays.

Arguments:

    pIpArray1 -- IP array

    pIpArray2 -- IP array

Return Value:

    TRUE if intersection.
    FALSE if no intersection or empty or NULL array.

--*/
{
    DWORD   count;
    DWORD   j;

    //
    //  protect against NULL
    //  this is called from the server on potentially changing (reconfigurable)
    //      IP array pointers;  this provides cheaper protection than
    //      worrying about locking
    //

    if ( !pIpArray1 || !pIpArray2 )
    {
        return( FALSE );
    }

    //
    //  same array
    //

    if ( pIpArray1 == pIpArray2 )
    {
        return( TRUE );
    }

    //
    //  test that at least one IP in array 1 is in array 2
    //

    count = pIpArray1->AddrCount;

    for ( j=0;  j < count;  j++ )
    {
        if ( Ip6Array_ContainsIp( pIpArray2, &pIpArray1->AddrArray[j] ) )
        {
            return( TRUE );
        }
    }

    //  no intersection

    return( FALSE );
}



BOOL
WINAPI
Ip6Array_IsEqual(
    IN       PIP6_ARRAY     pIpArray1,
    IN       PIP6_ARRAY     pIpArray2
    )
/*++

Routine Description:

    Determines if IP arrays are equal.

Arguments:

    pIpArray1 -- IP array

    pIpArray2 -- IP array

Return Value:

    TRUE if arrays equal.
    FALSE otherwise.

--*/
{
    DWORD   j;
    DWORD   count;

    //
    //  same array?  or missing array?
    //

    if ( pIpArray1 == pIpArray2 )
    {
        return( TRUE );
    }
    if ( !pIpArray1 || !pIpArray2 )
    {
        return( FALSE );
    }

    //
    //  arrays the same length?
    //

    count = pIpArray1->AddrCount;

    if ( count != pIpArray2->AddrCount )
    {
        return( FALSE );
    }

    //
    //  test that each IP in array 1 is in array 2
    //
    //  test that each IP in array 2 is in array 1
    //      - do second test in case of duplicates
    //      that fool equal-lengths check
    //

    for ( j=0;  j < count;  j++ )
    {
        if ( !Ip6Array_ContainsIp( pIpArray2, &pIpArray1->AddrArray[j] ) )
        {
            return( FALSE );
        }
    }
    for ( j=0;  j < count;  j++ )
    {
        if ( !Ip6Array_ContainsIp( pIpArray1, &pIpArray2->AddrArray[j] ) )
        {
            return( FALSE );
        }
    }

    //  equal arrays

    return( TRUE );
}



DNS_STATUS
WINAPI
Ip6Array_Union(
    IN      PIP6_ARRAY      pIpArray1,
    IN      PIP6_ARRAY      pIpArray2,
    OUT     PIP6_ARRAY*     ppUnion
    )
/*++

Routine Description:

    Computes the union of two IP arrays.

    Out array is allocated with Ip6Array_Alloc(), caller must free with Ip6Array_Free()

Arguments:

    pIpArray1 -- IP array

    pIpArray2 -- IP array

    ppUnion -- addr to recv IP array of addresses in array 1 and in array2

Return Value:

    ERROR_SUCCESS if successful.
    DNS_ERROR_NO_MEMORY if unable to allocate memory for IP array.

--*/
{
    DWORD       j;
    PIP6_ARRAY  punionArray = NULL;

    //
    //  create result IP arrays
    //

    if ( !ppUnion )
    {
        return( ERROR_INVALID_PARAMETER );
    }

    punionArray = Ip6Array_Create( pIpArray1->AddrCount +
                                   pIpArray2->AddrCount );
    if ( !punionArray )
    {
        goto NoMem;
    }
    *ppUnion = punionArray;


    //
    //  create union from arrays
    //

    for ( j = 0; j < pIpArray1->AddrCount; j++ )
    {
        Ip6Array_AddIp(
            punionArray,
            & pIpArray1->AddrArray[j],
            TRUE    // screen out dups
            );
    }

    for ( j = 0; j < pIpArray2->AddrCount; j++ )
    {
        Ip6Array_AddIp(
            punionArray,
            & pIpArray2->AddrArray[j],
            TRUE    // screen out dups
            );
    }
    return( ERROR_SUCCESS );

NoMem:

    if ( punionArray )
    {
        FREE_HEAP( punionArray );
        *ppUnion = NULL;
    }
    return( DNS_ERROR_NO_MEMORY );
}



#if 0
DNS_STATUS
Ip6Array_CreateIpArrayFromMultiIpString(
    IN      PSTR            pszMultiIpString,
    OUT     PIP6_ARRAY*     ppIpArray
    )
/*++

Routine Description:

    Create IP array out of multi-IP string.

Arguments:

    pszMultiIpString -- string containing IP addresses;
        separator is whitespace or comma

    ppIpArray -- addr to receive ptr to allocated IP array

Return Value:

    ERROR_SUCCESS if one or more valid IP addresses in string.
    DNS_ERROR_INVALID_IP6_ADDRESS   if parsing error.
    DNS_ERROR_NO_MEMORY if can not create IP array.

--*/
{
    PCHAR       pch;
    CHAR        ch;
    PCHAR       pbuf;
    PCHAR       pbufStop;
    DNS_STATUS  status = ERROR_SUCCESS;
    DWORD       countIp = 0;
    IP6_ADDRESS ip;
    CHAR        buffer[ IP6_ADDRESS_STRING_LENGTH+2 ];
    IP6_ADDRESS arrayIp[ MAX_PARSE_IP ];

    //  stop byte for IP string buffer
    //      - note we put extra byte pad in buffer above
    //      this allows us to write ON stop byte and use
    //      that to detect invalid-long IP string
    //

    pbufStop = buffer + IP6_ADDRESS_STRING_LENGTH;

    //
    //  DCR:  use IP array builder for local IP address
    //      then need Ip6Array_CreateIpArrayFromMultiIpString()
    //      to use count\alloc method when buffer overflows
    //      to do this we'd need to do parsing in loop
    //      and skip conversion when count overflow, but set
    //      flag to go back in again with allocated buffer
    //
    //  safer would be to tokenize-count, alloc, build from tokens
    //

    //
    //  loop until reach end of string
    //

    pch = pszMultiIpString;

    while ( countIp < MAX_PARSE_IP )
    {
        //  skip whitespace

        while ( ch = *pch++ )
        {
            if ( ch == ' ' || ch == '\t' || ch == ',' )
            {
                continue;
            }
            break;
        }
        if ( !ch )
        {
            break;
        }

        //
        //  copy next IP string into buffer
        //      - stop copy at whitespace or NULL
        //      - on invalid-long IP string, stop copying
        //      but continue parsing, so can still get any following IPs
        //      note, we actually write ON the buffer stop byte as our
        //      "invalid-long" detection mechanism
        //

        pbuf = buffer;
        do
        {
            if ( pbuf <= pbufStop )
            {
                *pbuf++ = ch;
            }
            ch = *pch++;
        }
        while ( ch && ch != ' ' && ch != ',' && ch != '\t' );

        //
        //  convert buffer into IP address
        //      - insure was valid length string
        //      - null terminate
        //

        if ( pbuf <= pbufStop )
        {
            *pbuf = 0;

            ip = inet_addr( buffer );
            if ( ip == INADDR_BROADCAST )
            {
                status = DNS_ERROR_INVALID_IP6_ADDRESS  ;
            }
            else
            {
                arrayIp[ countIp++ ] = ip;
            }
        }
        else
        {
            status = DNS_ERROR_INVALID_IP6_ADDRESS  ;
        }

        //  quit if at end of string

        if ( !ch )
        {
            break;
        }
    }

    //
    //  if successfully parsed IP addresses, create IP array
    //  note, we'll return what we have even if some addresses are
    //  bogus, status code will indicate the parsing problem
    //
    //  note, if explicitly passed empty string, then create
    //  empty IP array, don't error
    //

    if ( countIp == 0  &&  *pszMultiIpString != 0 )
    {
        *ppIpArray = NULL;
        status = DNS_ERROR_INVALID_IP6_ADDRESS  ;
    }
    else
    {
        *ppIpArray = Ip6Array_CreateFromFlatArray(
                        countIp,
                        arrayIp );
        if ( !*ppIpArray )
        {
            status = DNS_ERROR_NO_MEMORY;
        }
        IF_DNSDBG( IPARRAY )
        {
            DnsDbg_IpArray(
                "New Parsed IP array",
                NULL,       // no name
                *ppIpArray );
        }
    }

    return( status );
}



LPSTR
Ip6Array_CreateMultiIpStringFrom(
    IN      PIP6_ARRAY      pIpArray,
    IN      CHAR            chSeparator     OPTIONAL
    )
/*++

Routine Description:

    Create IP array out of multi-IP string.

Arguments:

    pIpArray    -- IP array to generate string for

    chSeparator -- separating character between strings;
        OPTIONAL, if not given, blank is used

Return Value:

    Ptr to string representation of IP array.
    Caller must free.

--*/
{
    PCHAR       pch;
    DWORD       i;
    PCHAR       pszip;
    DWORD       length;
    PCHAR       pchstop;
    CHAR        buffer[ IP6_ADDRESS  _STRING_LENGTH*MAX_PARSE_IP + 1 ];

    //
    //  if no IP array, return NULL string
    //  this allows this function to simply indicate when registry
    //      delete rather than write is indicated
    //

    if ( !pIpArray )
    {
        return( NULL );
    }

    //  if no separator, use blank

    if ( !chSeparator )
    {
        chSeparator = ' ';
    }

    //
    //  loop through all IPs in array, appending each
    //

    pch = buffer;
    pchstop = pch + ( IP6_ADDRESS  _STRING_LENGTH * (MAX_PARSE_IP-1) );
    *pch = 0;

    for ( i=0;  i < pIpArray->AddrCount;  i++ )
    {
        if ( pch >= pchstop )
        {
            break;
        }
        pszip = IP4_STRING( pIpArray->AddrArray[i] );
        if ( pszip )
        {
            length = strlen( pszip );

            memcpy(
                pch,
                pszip,
                length );

            pch += length;
            *pch++ = chSeparator;
        }
    }

    //  if wrote any strings, then write terminator over last separator

    if ( pch != buffer )
    {
        *--pch = 0;
    }

    //  create copy of buffer as return

    length = (DWORD)(pch - buffer) + 1;
    pch = ALLOCATE_HEAP( length );
    if ( !pch )
    {
        return( NULL );
    }

    memcpy(
        pch,
        buffer,
        length );

    DNSDBG( IPARRAY, (
        "String representation %s of IP array at %p\n",
        pch,
        pIpArray ));

    return( pch );
}
#endif



VOID
Ip6Array_InitSingleWithIp(
    IN OUT  PIP6_ARRAY      pArray,
    IN      PIP6_ADDRESS    pIp
    )
/*++

Routine Description:

    Init IP array to contain single address.

    This is for single address passing in array -- usually stack array.

    Note, that this assumes uninitialized array unlike Ip6Array_AddIp()
    and creates single IP array.

Arguments:

    pArray -- IP6 array, at least of length 1

    pIp -- ptr to IP6 address

Return Value:

    None

--*/
{
    pArray->AddrCount = 1;
    pArray->MaxCount = 1;

    IP6_ADDR_COPY(
        &pArray->AddrArray[0],
        pIp );
}



VOID
Ip6Array_InitSingleWithIp4(
    IN OUT  PIP6_ARRAY      pArray,
    IN      IP4_ADDRESS     Ip4Addr
    )
/*++

Routine Description:

    Init IP array to contain single address.

    This is for single address passing in array -- usually stack array.

    Note, that this assumes uninitialized array unlike Ip6Array_AddIp()
    and creates single IP array.

Arguments:

    pArray -- IP6 array, at least of length 1

    Ip4Addr -- IP4 address

Return Value:

    None

--*/
{
    pArray->AddrCount = 1;
    pArray->MaxCount = 1;

    IP6_SET_ADDR_V4MAPPED(
        &pArray->AddrArray[0],
        Ip4Addr );
}



DWORD
Ip6Array_InitSingleWithSockaddr(
    IN OUT  PIP6_ARRAY      pArray,
    IN      PSOCKADDR       pSockAddr
    )
/*++

Routine Description:

    Init IP array to contain single address.

    This is for single address passing in array -- usually stack array.

    Note, that this assumes uninitialized array unlike Ip6Array_AddIp()
    and creates single IP array.

Arguments:

    pArray -- IP6 array, at least of length 1

    pSockaddr -- ptr to sockaddr

Return Value:

    Family of sockaddr (AF_INET or AF_INET6) if successful.
    Zero on error.

--*/
{
    pArray->AddrCount = 1;
    pArray->MaxCount = 1;

    return  Ip6_CopyFromSockaddr(
                &pArray->AddrArray[0],
                pSockAddr,
                0 );
}



PIP4_ARRAY
Ip4Array_CreateFromIp6Array(
    IN      PIP6_ARRAY      pIp6Array,
    OUT     PDWORD          pCount6
    )
/*++

Routine Description:

    Create IP4 array from IP6 array.

Arguments:

    pIp6Array -- IP6 array

    pCount6 -- addr to receive count of IP6 addresses dropped

Return Value:

    Ptr to uninitialized IP address array, if successful
    NULL on failure.

--*/
{
    PIP4_ARRAY  parray = NULL;
    DWORD       i;
    DWORD       count6 = 0;

    DNSDBG( IPARRAY, (
        "Ip4Array_CreateFromIp6Array( %p, %p )\n",
        pIp6Array,
        pCount6 ));

    if ( ! pIp6Array )
    {
        goto Done;
    }

    //
    //  allocate the array
    //

    parray = Dns_CreateIpArray( pIp6Array->AddrCount );
    if ( !parray )
    {
        goto Done;
    }

    //
    //  fill the array
    //

    for ( i=0; i<pIp6Array->AddrCount; i++ )
    {
        IP4_ADDRESS ip4;

        ip4 = IP6_GET_V4_ADDR_IF_MAPPED( &pIp6Array->AddrArray[i] );
        if ( ip4 != BAD_IP4_ADDR )
        {
            Dns_AddIpToIpArray(
                parray,
                ip4 );
        }
        else
        {
            count6++;
        }
    }

Done:

    //  set dropped IP6 count

    if ( pCount6 )
    {
        *pCount6 = count6;
    }

    DNSDBG( IPARRAY, (
        "Leave Ip4Array_CreateFromIp6Array()\n"
        "\tnew array (count %d) at %p\n"
        "\tdropped IP6 count %d\n",
        parray ? parray->AddrCount : 0,
        parray,
        count6 ));

    return( parray );
}

//
//  End ip6.c
//
=== C:/Users/treeman/Desktop/windows nt source code\Source\Win2K3\NT\ds\dns\dnslib\iparray.c ===
/*++

Copyright (c) 1995-2000 Microsoft Corporation

Module Name:

    iparray.c

Abstract:

    Domain Name System (DNS) Library

    IP Address array routines.

Author:

    Jim Gilroy (jamesg)     October 1995

Revision History:

--*/


#include "local.h"

//
//  Max IP count when doing IP array to\from string conversions
//

#define MAX_PARSE_IP    (1000)




//
//  Routines to handle actual array of IP addresses.
//

PIP4_ADDRESS
Dns_CreateIpAddressArrayCopy(
    IN      PIP4_ADDRESS    aipAddress,
    IN      DWORD           cipAddress
    )
/*++

Routine Description:

    Create copy of IP address array.

Arguments:

    aipAddress -- array of IP addresses
    cipAddress -- count of IP addresses

Return Value:

    Ptr to IP address array copy, if successful
    NULL on failure.

--*/
{
    PIP4_ADDRESS pipArray;

    //  validate

    if ( ! aipAddress || cipAddress == 0 )
    {
        return( NULL );
    }

    //  allocate memory and copy

    pipArray = (PIP4_ADDRESS) ALLOCATE_HEAP( cipAddress*sizeof(IP4_ADDRESS) );
    if ( ! pipArray )
    {
        return( NULL );
    }

    memcpy(
        pipArray,
        aipAddress,
        cipAddress*sizeof(IP4_ADDRESS) );

    return( pipArray );
}



BOOL
Dns_ValidateIpAddressArray(
    IN      PIP4_ADDRESS    aipAddress,
    IN      DWORD           cipAddress,
    IN      DWORD           dwFlag
    )
/*++

Routine Description:

    Validate IP address array.

    Current checks:
        - existence
        - non-broadcast
        - non-lookback

Arguments:

    aipAddress -- array of IP addresses

    cipAddress -- count of IP addresses

    dwFlag -- validity tests to do;  currently unused

Return Value:

    TRUE if valid IP addresses.
    FALSE if invalid address found.

--*/
{
    DWORD   i;

    //
    //  protect against bad parameters
    //

    if ( cipAddress && ! aipAddress )
    {
        return( FALSE );
    }

    //
    //  check each IP address
    //

    for ( i=0; i < cipAddress; i++)
    {
        if( aipAddress[i] == INADDR_ANY
                ||
            aipAddress[i] == INADDR_BROADCAST
                ||
            aipAddress[i] == INADDR_LOOPBACK )
        {
            return( FALSE );
        }
    }
    return( TRUE );
}



//
//  IP4_ARRAYroutines
//

DWORD
Dns_SizeofIpArray(
    IN      PIP4_ARRAY      pIpArray
    )
/*++

Routine Description:

    Get size in bytes of IP address array.

Arguments:

    pIpArray -- IP address array to find size of

Return Value:

    Size in bytes of IP array.

--*/
{
    if ( ! pIpArray )
    {
        return 0;
    }
    return  (pIpArray->AddrCount * sizeof(IP4_ADDRESS)) + sizeof(DWORD);
}



BOOL
Dns_ProbeIpArray(
    IN      PIP4_ARRAY      pIpArray
    )
/*++

Routine Description:

    Touch all entries in IP array to insure valid memory.

Arguments:

    pIpArray -- ptr to IP address array

Return Value:

    TRUE if successful.
    FALSE otherwise

--*/
{
    DWORD   i;
    BOOL    result;

    if ( ! pIpArray )
    {
        return( TRUE );
    }
    for ( i=0; i<pIpArray->AddrCount; i++ )
    {
        result = ( pIpArray->AddrArray[i] == 0 );
    }
    return( TRUE );
}


#if 0

BOOL
Dns_ValidateSizeOfIpArray(
    IN      PIP4_ARRAY      pIpArray,
    IN      DWORD           dwMemoryLength
    )
/*++

Routine Description:

    Check that size of IP array, corresponds to length of memory.

Arguments:

    pIpArray -- ptr to IP address array

    dwMemoryLength -- length of IP array memory

Return Value:

    TRUE if IP array size matches memory length
    FALSE otherwise

--*/
{
    return( Dns_SizeOfIpArray(pIpArray) == dwMemoryLength );
}
#endif



PIP4_ARRAY
Dns_CreateIpArray(
    IN      DWORD       AddrCount
    )
/*++

Routine Description:

    Create uninitialized IP address array.

Arguments:

    AddrCount -- count of addresses array will hold

Return Value:

    Ptr to uninitialized IP address array, if successful
    NULL on failure.

--*/
{
    PIP4_ARRAY  pIpArray;

    DNSDBG( IPARRAY, ( "Dns_CreateIpArray() of count %d\n", AddrCount ));

    pIpArray = (PIP4_ARRAY) ALLOCATE_HEAP_ZERO(
                        (AddrCount * sizeof(IP4_ADDRESS)) + sizeof(DWORD) );
    if ( ! pIpArray )
    {
        return( NULL );
    }

    //
    //  initialize IP count
    //

    pIpArray->AddrCount = AddrCount;

    DNSDBG( IPARRAY, (
        "Dns_CreateIpArray() new array (count %d) at %p\n",
        AddrCount,
        pIpArray ));

    return( pIpArray );
}


PIP4_ARRAY
Dns_BuildIpArray(
    IN      DWORD           AddrCount,
    IN      PIP4_ADDRESS    pipAddrs
    )
/*++

Routine Description:

    Create IP address array structure from existing array of IP addresses.

Arguments:

    AddrCount -- count of addresses in array
    pipAddrs -- IP address array

Return Value:

    Ptr to IP address array.
    NULL on failure.

--*/
{
    PIP4_ARRAY  pIpArray;

    if ( ! pipAddrs || ! AddrCount )
    {
        return( NULL );
    }

    //  create IP array of desired size
    //  then copy incoming array of addresses

    pIpArray = Dns_CreateIpArray( AddrCount );
    if ( ! pIpArray )
    {
        return( NULL );
    }
    pIpArray->AddrCount = AddrCount;

    memcpy(
        pIpArray->AddrArray,
        pipAddrs,
        AddrCount * sizeof(IP4_ADDRESS) );

    return( pIpArray );
}



PIP4_ARRAY
Dns_CopyAndExpandIpArray(
    IN      PIP4_ARRAY      pIpArray,
    IN      DWORD           ExpandCount,
    IN      BOOL            fDeleteExisting
    )
/*++

Routine Description:

    Create expanded copy of IP address array.

Arguments:

    pIpArray -- IP address array to copy

    ExpandCount -- number of IP to expand array size by

    fDeleteExisting -- TRUE to delete existing array;
        this is useful when function is used to grow existing
        IP array in place;  note that locking must be done
        by caller

        note, that if new array creation FAILS -- then old array
        is NOT deleted

Return Value:

    Ptr to IP array copy, if successful
    NULL on failure.

--*/
{
    PIP4_ARRAY  pnewArray;
    DWORD       newCount;

    //
    //  no existing array -- just create desired size
    //

    if ( ! pIpArray )
    {
        if ( ExpandCount )
        {
            return  Dns_CreateIpArray( ExpandCount );
        }
        return( NULL );
    }

    //
    //  create IP array of desired size
    //  then copy any existing addresses
    //

    pnewArray = Dns_CreateIpArray( pIpArray->AddrCount + ExpandCount );
    if ( ! pnewArray )
    {
        return( NULL );
    }

    RtlCopyMemory(
        (PBYTE) pnewArray->AddrArray,
        (PBYTE) pIpArray->AddrArray,
        pIpArray->AddrCount * sizeof(IP4_ADDRESS) );

    //
    //  delete existing -- for "grow mode"
    //

    if ( fDeleteExisting )
    {
        FREE_HEAP( pIpArray );
    }

    return( pnewArray );
}



PIP4_ARRAY
Dns_CreateIpArrayCopy(
    IN      PIP4_ARRAY      pIpArray
    )
/*++

Routine Description:

    Create copy of IP address array.

Arguments:

    pIpArray -- IP address array to copy

Return Value:

    Ptr to IP address array copy, if successful
    NULL on failure.

--*/
{
#if 0
    PIP4_ARRAY  pIpArrayCopy;

    if ( ! pIpArray )
    {
        return( NULL );
    }

    //  create IP array of desired size
    //  then copy entire structure

    pIpArrayCopy = Dns_CreateIpArray( pIpArray->AddrCount );
    if ( ! pIpArrayCopy )
    {
        return( NULL );
    }

    memcpy(
        pIpArrayCopy,
        pIpArray,
        Dns_SizeofIpArray(pIpArray) );

    return( pIpArrayCopy );
#endif

    //
    //  call essentially "CopyEx" function
    //
    //  note, not macroing this because this may well become
    //      a DLL entry point
    //

    return  Dns_CopyAndExpandIpArray(
                pIpArray,
                0,          // no expansion
                0           // don't delete existing array
                );
}



BOOL
Dns_IsAddressInIpArray(
    IN      PIP4_ARRAY      pIpArray,
    IN      IP4_ADDRESS     ipAddress
    )
/*++

Routine Description:

    Check if IP array contains desired address.

Arguments:

    pIpArray -- IP address array to copy

Return Value:

    TRUE if address in array.
    Ptr to IP address array copy, if successful
    NULL on failure.

--*/
{
    DWORD i;

    if ( ! pIpArray )
    {
        return( FALSE );
    }
    for (i=0; i<pIpArray->AddrCount; i++)
    {
        if ( ipAddress == pIpArray->AddrArray[i] )
        {
            return( TRUE );
        }
    }
    return( FALSE );
}



BOOL
Dns_AddIpToIpArray(
    IN OUT  PIP4_ARRAY      pIpArray,
    IN      IP4_ADDRESS     NewIp
    )
/*++

Routine Description:

    Add IP address to IP array.

    Allowable "slot" in array, is any zero IP address.

Arguments:

    pIpArray -- IP address array to add to

    NewIp -- IP address to add to array

Return Value:

    TRUE if successful.
    FALSE if array full.

--*/
{
    DWORD i;

    //
    //  screen for existence
    //
    //  this check makes it easy to write code that does
    //  Add\Full?=>Expand loop without having to write
    //  startup existence\create code
    //  

    if ( !pIpArray )
    {
        return( FALSE );
    }

    for (i=0; i<pIpArray->AddrCount; i++)
    {
        if ( pIpArray->AddrArray[i] == 0 )
        {
            pIpArray->AddrArray[i] = NewIp;
            return( TRUE );
        }
        else if ( pIpArray->AddrArray[i] == NewIp )
        {
            return( TRUE );
        }
    }
    return( FALSE );
}



VOID
Dns_ClearIpArray(
    IN OUT  PIP4_ARRAY      pIpArray
    )
/*++

Routine Description:

    Clear memory in IP array.

Arguments:

    pIpArray -- IP address array to clear

Return Value:

    None.

--*/
{
    //  clear just the address list, leaving count intact

    RtlZeroMemory(
        pIpArray->AddrArray,
        pIpArray->AddrCount * sizeof(IP4_ADDRESS) );
}



VOID
Dns_ReverseOrderOfIpArray(
    IN OUT  PIP4_ARRAY      pIpArray
    )
/*++

Routine Description:

    Reorder the list of IPs in reverse.

Arguments:

    pIpArray -- IP address array to reorder

Return Value:

    None.

--*/
{
    IP4_ADDRESS tempIp;
    DWORD       i;
    DWORD       j;

    //
    //  swap IPs working from ends to the middle
    //

    if ( pIpArray &&
         pIpArray->AddrCount )
    {
        for ( i = 0, j = pIpArray->AddrCount - 1;
              i < j;
              i++, j-- )
        {
            tempIp = pIpArray->AddrArray[i];
            pIpArray->AddrArray[i] = pIpArray->AddrArray[j];
            pIpArray->AddrArray[j] = tempIp;
        }
    }
}



BOOL
Dns_CheckAndMakeIpArraySubset(
    IN OUT  PIP4_ARRAY      pIpArraySub,
    IN      PIP4_ARRAY      pIpArraySuper
    )
/*++

Routine Description:

    Clear entries from IP array until it is subset of another IP array.

Arguments:

    pIpArraySub -- IP array to make into subset

    pIpArraySuper -- IP array superset

Return Value:

    TRUE if pIpArraySub is already subset.
    FALSE if needed to nix entries to make IP array a subset.

--*/
{
    DWORD   i;
    DWORD   newIpCount;

    //
    //  check each entry in subset IP array,
    //  if not in superset IP array, eliminate it
    //

    newIpCount = pIpArraySub->AddrCount;

    for (i=0; i < newIpCount; i++)
    {
        if ( ! Dns_IsAddressInIpArray(
                    pIpArraySuper,
                    pIpArraySub->AddrArray[i] ) )
        {
            //  remove this IP entry and replace with
            //  last IP entry in array

            newIpCount--;
            if ( i >= newIpCount )
            {
                break;
            }
            pIpArraySub->AddrArray[i] = pIpArraySub->AddrArray[ newIpCount ];
        }
    }

    //  if eliminated entries, reset array count

    if ( newIpCount < pIpArraySub->AddrCount )
    {
        pIpArraySub->AddrCount = newIpCount;
        return( FALSE );
    }
    return( TRUE );
}



INT
WINAPI
Dns_ClearIpFromIpArray(
    IN OUT  PIP4_ARRAY      pIpArray,
    IN      IP4_ADDRESS     IpDelete
    )
/*++

Routine Description:

    Clear IP address from IP array.

    Note difference between this function and Dns_DeleteIpFromIpArray()
    below.

    This function leaves list size unchanged allowing new adds.  

Arguments:

    pIpArray -- IP address array to add to

    IpDelete -- IP address to delete from array

Return Value:

    Count of instances of IpDelete in array.

--*/
{
    DWORD   found = 0;
    INT     i;
    INT     currentLast;

    i = currentLast = pIpArray->AddrCount-1;

    while ( i >= 0 )
    {
        if ( pIpArray->AddrArray[i] == IpDelete )
        {
            pIpArray->AddrArray[i] = pIpArray->AddrArray[ currentLast ];
            pIpArray->AddrArray[ currentLast ] = 0;
            currentLast--;
            found++;
        }
        i--;
    }

    return( found );
}



INT
WINAPI
Dns_DeleteIpFromIpArray(
    IN OUT  PIP4_ARRAY      pIpArray,
    IN      IP4_ADDRESS     IpDelete
    )
/*++

Routine Description:

    Delete IP address from IP array.

    Note difference between this function and Dns_ClearIpFromIpArray()
    above.

    This delete leaves a SMALLER array.  The IP slot is NON_RECOVERABLE.

Arguments:

    pIpArray -- IP address array to add to

    IpDelete -- IP address to delete from array

Return Value:

    Count of instances of IpDelete in array.

--*/
{
    DWORD   found;

    found = Dns_ClearIpFromIpArray( pIpArray, IpDelete );

    pIpArray->AddrCount -= found;

    return( found );
}



INT
WINAPI
Dns_CleanIpArray(
    IN OUT  PIP4_ARRAY      pIpArray,
    IN      DWORD           Flag
    )
/*++

Routine Description:

    Clean IP array.

    Remove bogus stuff from IP Array:
        -- Zeros
        -- Loopback
        -- AutoNet

Arguments:

    pIpArray -- IP address array to add to

    Flag -- which cleanups to make

Return Value:

    Count of instances cleaned from array.

--*/
{
    DWORD       found = 0;
    INT         i;
    INT         currentLast;
    IP4_ADDRESS ip;

    i = currentLast = pIpArray->AddrCount-1;

    while ( i >= 0 )
    {
        ip = pIpArray->AddrArray[i];

        if (
            ( (Flag & DNS_IPARRAY_CLEAN_LOOPBACK) && ip == DNS_NET_ORDER_LOOPBACK )
                ||
            ( (Flag & DNS_IPARRAY_CLEAN_ZERO) && ip == 0 )
                ||
            ( (Flag & DNS_IPARRAY_CLEAN_AUTONET) && DNS_IS_AUTONET_IP(ip) ) )
        {
            //  remove IP from array

            pIpArray->AddrArray[i] = pIpArray->AddrArray[ currentLast ];
            currentLast--;
            found++;
        }
        i--;
    }

    pIpArray->AddrCount -= found;
    return( found );
}



DNS_STATUS
WINAPI
Dns_DiffOfIpArrays(
    IN       PIP4_ARRAY     pIpArray1,
    IN       PIP4_ARRAY     pIpArray2,
    OUT      PIP4_ARRAY*    ppOnlyIn1,
    OUT      PIP4_ARRAY*    ppOnlyIn2,
    OUT      PIP4_ARRAY*    ppIntersect
    )
/*++

Routine Description:

    Computes differences and intersection of two IP arrays.

    Out arrays are allocated with Dns_Alloc(), caller must free with Dns_Free()

Arguments:

    pIpArray1 -- IP array

    pIpArray2 -- IP array

    ppOnlyIn1 -- addr to recv IP array of addresses only in array 1 (not in array2)

    ppOnlyIn2 -- addr to recv IP array of addresses only in array 2 (not in array1)

    ppIntersect -- addr to recv IP array of intersection addresses

Return Value:

    ERROR_SUCCESS if successful.
    DNS_ERROR_NO_MEMORY if unable to allocate memory for IP arrays.

--*/
{
    DWORD       j;
    DWORD       ip;
    PIP4_ARRAY  intersectArray = NULL;
    PIP4_ARRAY  only1Array = NULL;
    PIP4_ARRAY  only2Array = NULL;

    //
    //  create result IP arrays
    //

    if ( ppIntersect )
    {
        intersectArray = Dns_CreateIpArrayCopy( pIpArray1 );
        if ( !intersectArray )
        {
            goto NoMem;
        }
        *ppIntersect = intersectArray;
    }
    if ( ppOnlyIn1 )
    {
        only1Array = Dns_CreateIpArrayCopy( pIpArray1 );
        if ( !only1Array )
        {
            goto NoMem;
        }
        *ppOnlyIn1 = only1Array;
    }
    if ( ppOnlyIn2 )
    {
        only2Array = Dns_CreateIpArrayCopy( pIpArray2 );
        if ( !only2Array )
        {
            goto NoMem;
        }
        *ppOnlyIn2 = only2Array;
    }

    //
    //  clean the arrays
    //

    for ( j=0;   j< pIpArray1->AddrCount;   j++ )
    {
        ip = pIpArray1->AddrArray[j];

        //  if IP in both arrays, delete from "only" arrays

        if ( Dns_IsAddressInIpArray( pIpArray2, ip ) )
        {
            if ( only1Array )
            {
                Dns_DeleteIpFromIpArray( only1Array, ip );
            }
            if ( only2Array )
            {
                Dns_DeleteIpFromIpArray( only2Array, ip );
            }
        }

        //  if IP not in both arrays, delete from intersection
        //      note intersection started as IpArray1

        else if ( intersectArray )
        {
            Dns_DeleteIpFromIpArray( intersectArray, ip );
        }
    }

    return( ERROR_SUCCESS );

NoMem:

    if ( intersectArray )
    {
        FREE_HEAP( intersectArray );
    }
    if ( only1Array )
    {
        FREE_HEAP( only1Array );
    }
    if ( only2Array )
    {
        FREE_HEAP( only2Array );
    }
    if ( ppIntersect )
    {
        *ppIntersect = NULL;
    }
    if ( ppOnlyIn1 )
    {
        *ppOnlyIn1 = NULL;
    }
    if ( ppOnlyIn2 )
    {
        *ppOnlyIn2 = NULL;
    }
    return( DNS_ERROR_NO_MEMORY );
}



BOOL
WINAPI
Dns_IsIntersectionOfIpArrays(
    IN       PIP4_ARRAY     pIpArray1,
    IN       PIP4_ARRAY     pIpArray2
    )
/*++

Routine Description:

    Determine if there's intersection of two IP arrays.

Arguments:

    pIpArray1 -- IP array

    pIpArray2 -- IP array

Return Value:

    TRUE if intersection.
    FALSE if no intersection or empty or NULL array.

--*/
{
    DWORD   count;
    DWORD   j;

    //
    //  protect against NULL
    //  this is called from the server on potentially changing (reconfigurable)
    //      IP array pointers;  this provides cheaper protection than
    //      worrying about locking
    //

    if ( !pIpArray1 || !pIpArray2 )
    {
        return( FALSE );
    }

    //
    //  same array
    //

    if ( pIpArray1 == pIpArray2 )
    {
        return( TRUE );
    }

    //
    //  test that at least one IP in array 1 is in array 2
    //

    count = pIpArray1->AddrCount;

    for ( j=0;  j < count;  j++ )
    {
        if ( Dns_IsAddressInIpArray( pIpArray2, pIpArray1->AddrArray[j] ) )
        {
            return( TRUE );
        }
    }

    //  no intersection

    return( FALSE );
}



BOOL
Dns_AreIpArraysEqual(
    IN       PIP4_ARRAY     pIpArray1,
    IN       PIP4_ARRAY     pIpArray2
    )
/*++

Routine Description:

    Determines if IP arrays are equal.

Arguments:

    pIpArray1 -- IP array

    pIpArray2 -- IP array

Return Value:

    TRUE if arrays equal.
    FALSE otherwise.

--*/
{
    DWORD   j;
    DWORD   count;

    //
    //  same array?  or missing array?
    //

    if ( pIpArray1 == pIpArray2 )
    {
        return( TRUE );
    }
    if ( !pIpArray1 || !pIpArray2 )
    {
        return( FALSE );
    }

    //
    //  arrays the same length?
    //

    count = pIpArray1->AddrCount;

    if ( count != pIpArray2->AddrCount )
    {
        return( FALSE );
    }

    //
    //  test that each IP in array 1 is in array 2
    //
    //  test that each IP in array 2 is in array 1
    //      - do second test in case of duplicates
    //      that fool equal-lengths check
    //

    for ( j=0;  j < count;  j++ )
    {
        if ( !Dns_IsAddressInIpArray( pIpArray2, pIpArray1->AddrArray[j] ) )
        {
            return( FALSE );
        }
    }
    for ( j=0;  j < count;  j++ )
    {
        if ( !Dns_IsAddressInIpArray( pIpArray1, pIpArray2->AddrArray[j] ) )
        {
            return( FALSE );
        }
    }

    //  equal arrays

    return( TRUE );
}



DNS_STATUS
WINAPI
Dns_UnionOfIpArrays(
    IN      PIP4_ARRAY      pIpArray1,
    IN      PIP4_ARRAY      pIpArray2,
    OUT     PIP4_ARRAY*     ppUnion
    )
/*++

Routine Description:

    Computes the union of two IP arrays.

    Out array is allocated with Dns_Alloc(), caller must free with Dns_Free()

Arguments:

    pIpArray1 -- IP array

    pIpArray2 -- IP array

    ppUnion -- addr to recv IP array of addresses in array 1 and in array2

Return Value:

    ERROR_SUCCESS if successful.
    DNS_ERROR_NO_MEMORY if unable to allocate memory for IP array.

--*/
{
    DWORD       j;
    DWORD       ip;
    DWORD       Count = 0;
    PIP4_ARRAY  punionArray = NULL;

    //
    //  create result IP arrays
    //

    if ( !ppUnion )
    {
        return( ERROR_INVALID_PARAMETER );
    }

    punionArray = Dns_CreateIpArray( pIpArray1->AddrCount +
                                     pIpArray2->AddrCount );
    if ( !punionArray )
    {
        goto NoMem;
    }
    *ppUnion = punionArray;


    //
    //  create union from arrays
    //

    for ( j = 0; j < pIpArray1->AddrCount; j++ )
    {
        ip = pIpArray1->AddrArray[j];

        if ( !Dns_IsAddressInIpArray( punionArray, ip ) )
        {
            Dns_AddIpToIpArray( punionArray, ip );
            Count++;
        }
    }

    for ( j = 0; j < pIpArray2->AddrCount; j++ )
    {
        ip = pIpArray2->AddrArray[j];

        if ( !Dns_IsAddressInIpArray( punionArray, ip ) )
        {
            Dns_AddIpToIpArray( punionArray, ip );
            Count++;
        }
    }

    punionArray->AddrCount = Count;

    return( ERROR_SUCCESS );

NoMem:

    if ( punionArray )
    {
        FREE_HEAP( punionArray );
        *ppUnion = NULL;
    }
    return( DNS_ERROR_NO_MEMORY );
}



DNS_STATUS
Dns_CreateIpArrayFromMultiIpString(
    IN      LPSTR           pszMultiIpString,
    OUT     PIP4_ARRAY*     ppIpArray
    )
/*++

Routine Description:

    Create IP array out of multi-IP string.

Arguments:

    pszMultiIpString -- string containing IP addresses;
        separator is whitespace or comma

    ppIpArray -- addr to receive ptr to allocated IP array

Return Value:

    ERROR_SUCCESS if one or more valid IP addresses in string.
    DNS_ERROR_INVALID_IP_ADDRESS if parsing error.
    DNS_ERROR_NO_MEMORY if can not create IP array.

--*/
{
    PCHAR       pch;
    CHAR        ch;
    PCHAR       pbuf;
    PCHAR       pbufStop;
    DNS_STATUS  status = ERROR_SUCCESS;
    DWORD       countIp = 0;
    IP4_ADDRESS ip;
    CHAR        buffer[ IP4_ADDRESS_STRING_LENGTH+2 ];
    IP4_ADDRESS arrayIp[ MAX_PARSE_IP ];

    //  stop byte for IP string buffer
    //      - note we put extra byte pad in buffer above
    //      this allows us to write ON stop byte and use
    //      that to detect invalid-long IP string
    //

    pbufStop = buffer + IP4_ADDRESS_STRING_LENGTH;

    //
    //  DCR:  use IP array builder for local IP address
    //      then need Dns_CreateIpArrayFromMultiIpString()
    //      to use count\alloc method when buffer overflows
    //      to do this we'd need to do parsing in loop
    //      and skip conversion when count overflow, but set
    //      flag to go back in again with allocated buffer
    //
    //  safer would be to tokenize-count, alloc, build from tokens
    //

    //
    //  loop until reach end of string
    //

    pch = pszMultiIpString;

    while ( countIp < MAX_PARSE_IP )
    {
        //  skip whitespace

        while ( ch = *pch++ )
        {
            if ( ch == ' ' || ch == '\t' || ch == ',' )
            {
                continue;
            }
            break;
        }
        if ( !ch )
        {
            break;
        }

        //
        //  copy next IP string into buffer
        //      - stop copy at whitespace or NULL
        //      - on invalid-long IP string, stop copying
        //      but continue parsing, so can still get any following IPs
        //      note, we actually write ON the buffer stop byte as our
        //      "invalid-long" detection mechanism
        //

        pbuf = buffer;
        do
        {
            if ( pbuf <= pbufStop )
            {
                *pbuf++ = ch;
            }
            ch = *pch++;
        }
        while ( ch && ch != ' ' && ch != ',' && ch != '\t' );

        //
        //  convert buffer into IP address
        //      - insure was valid length string
        //      - null terminate
        //

        if ( pbuf <= pbufStop )
        {
            *pbuf = 0;

            ip = inet_addr( buffer );
            if ( ip == INADDR_BROADCAST )
            {
                status = DNS_ERROR_INVALID_IP_ADDRESS;
            }
            else
            {
                arrayIp[ countIp++ ] = ip;
            }
        }
        else
        {
            status = DNS_ERROR_INVALID_IP_ADDRESS;
        }

        //  quit if at end of string

        if ( !ch )
        {
            break;
        }
    }

    //
    //  if successfully parsed IP addresses, create IP array
    //  note, we'll return what we have even if some addresses are
    //  bogus, status code will indicate the parsing problem
    //
    //  note, if explicitly passed empty string, then create
    //  empty IP array, don't error
    //

    if ( countIp == 0  &&  *pszMultiIpString != 0 )
    {
        *ppIpArray = NULL;
        status = DNS_ERROR_INVALID_IP_ADDRESS;
    }
    else
    {
        *ppIpArray = Dns_BuildIpArray(
                        countIp,
                        arrayIp );
        if ( !*ppIpArray )
        {
            status = DNS_ERROR_NO_MEMORY;
        }
        IF_DNSDBG( IPARRAY )
        {
            DnsDbg_Ip4Array(
                "New Parsed IP array",
                NULL,       // no name
                *ppIpArray );
        }
    }

    return( status );
}



LPSTR
Dns_CreateMultiIpStringFromIpArray(
    IN      PIP4_ARRAY      pIpArray,
    IN      CHAR            chSeparator     OPTIONAL
    )
/*++

Routine Description:

    Create IP array out of multi-IP string.

Arguments:

    pIpArray    -- IP array to generate string for

    chSeparator -- separating character between strings;
        OPTIONAL, if not given, blank is used

Return Value:

    Ptr to string representation of IP array.
    Caller must free.

--*/
{
    PCHAR       pch;
    DWORD       i;
    PCHAR       pszip;
    DWORD       length;
    PCHAR       pchstop;
    CHAR        buffer[ IP4_ADDRESS_STRING_LENGTH*MAX_PARSE_IP + 1 ];

    //
    //  if no IP array, return NULL string
    //  this allows this function to simply indicate when registry
    //      delete rather than write is indicated
    //

    if ( !pIpArray )
    {
        return( NULL );
    }

    //  if no separator, use blank

    if ( !chSeparator )
    {
        chSeparator = ' ';
    }

    //
    //  loop through all IPs in array, appending each
    //

    pch = buffer;
    pchstop = pch + ( IP4_ADDRESS_STRING_LENGTH * (MAX_PARSE_IP-1) );
    *pch = 0;

    for ( i=0;  i < pIpArray->AddrCount;  i++ )
    {
        if ( pch >= pchstop )
        {
            break;
        }
        pszip = IP4_STRING( pIpArray->AddrArray[i] );
        if ( pszip )
        {
            length = strlen( pszip );

            memcpy(
                pch,
                pszip,
                length );

            pch += length;
            *pch++ = chSeparator;
        }
    }

    //  if wrote any strings, then write terminator over last separator

    if ( pch != buffer )
    {
        *--pch = 0;
    }

    //  create copy of buffer as return

    length = (DWORD)(pch - buffer) + 1;
    pch = ALLOCATE_HEAP( length );
    if ( !pch )
    {
        return( NULL );
    }

    memcpy(
        pch,
        buffer,
        length );

    DNSDBG( IPARRAY, (
        "String representation %s of IP array at %p\n",
        pch,
        pIpArray ));

    return( pch );
}

//
//  End iparray.c
//
=== C:/Users/treeman/Desktop/windows nt source code\Source\Win2K3\NT\ds\dns\dnslib\local.h ===
/*++

Copyright (c) 1996-2001  Microsoft Corporation

Module Name:

    local.h

Abstract:

    Domain Name System (DNS)

    DNS Library local include file

Author:

    Jim Gilroy      December 1996

Revision History:

--*/


#ifndef _DNSLIB_LOCAL_INCLUDED_
#define _DNSLIB_LOCAL_INCLUDED_


//#pragma warning(disable:4214)
//#pragma warning(disable:4514)
//#pragma warning(disable:4152)

#include <nt.h>
#include <ntrtl.h>
#include <nturtl.h>
#include <windows.h>
#include <winsock2.h>
#include <ws2tcpip.h>
#include <iptypes.h>
#include <basetyps.h>
#include <stdio.h>
#include <stdlib.h>
#include <limits.h>
//#include <tchar.h>
#include <align.h>          //  Alignment macros

#include <windns.h>         //  Public DNS definitions

#define  DNS_INTERNAL
#include "dnslibp.h"        //  Private DNS definitions
#include "..\..\resolver\idl\resrpc.h"
#include "..\dnsapi\dnsapip.h"

#include "message.h"
//#include "..\dnsapi\registry.h"
//#include "rtlstuff.h"     //  Handy macros from NT RTL


//
//  Use winsock2
//

#define DNS_WINSOCK_VERSION    (0x0202)    //  Winsock 2.2


//
//  Debugging
//

#define DNS_LOG_EVENT(a,b,c,d)


//  use DNS_ASSERT for dnslib debugging

#undef  ASSERT
#define ASSERT(expr)    DNS_ASSERT(expr)

//
//  Single async socket for internal use
//
//  If want async socket i/o then can create single async socket, with
//  corresponding event and always use it.  Requires winsock 2.2
//

extern  SOCKET      DnsSocket;
extern  OVERLAPPED  DnsSocketOverlapped;
extern  HANDLE      hDnsSocketEvent;


//
//  App shutdown flag
//

extern  BOOLEAN     fApplicationShutdown;


//
//  Heap operations
//

#define ALLOCATE_HEAP(size)         Dns_AllocZero( size )
#define REALLOCATE_HEAP(p,size)     Dns_Realloc( (p), (size) )
#define FREE_HEAP(p)                Dns_Free( p )
#define ALLOCATE_HEAP_ZERO(size)    Dns_AllocZero( size )


//
//  RPC Exception filters
//

#define DNS_RPC_EXCEPTION_FILTER                                           \
              (((RpcExceptionCode() != STATUS_ACCESS_VIOLATION) &&         \
                (RpcExceptionCode() != STATUS_DATATYPE_MISALIGNMENT) &&    \
                (RpcExceptionCode() != STATUS_PRIVILEGED_INSTRUCTION) &&   \
                (RpcExceptionCode() != STATUS_ILLEGAL_INSTRUCTION))        \
                ? 0x1 : EXCEPTION_CONTINUE_SEARCH )

// Not defined  (RpcExceptionCode() != STATUS_POSSIBLE_DEADLOCK) &&        \
// Not defined  (RpcExceptionCode() != STATUS_INSTRUCTION_MISALIGNMENT) && \




//
//  Table lookup.
//
//  Many DNS Records have human readable mnemonics for given data values.
//  These are used for data file formats, and display in nslookup or debug
//  output or cmdline tools.
//
//  To simplify this process, have a single mapping functionality that
//  supports DWORD \ LPSTR mapping tables.   Tables for indivual types
//  may then be layered on top of this.
//
//  Support two table types.
//      VALUE_TABLE_ENTRY is simple value-string mapping
//      FLAG_TABLE_ENTRY is designed for bit field flag mappings where
//          several flag strings might be contained in flag;  this table
//          contains additional mask field to allow multi-bit fields
//          within the flag
//

typedef struct
{
    DWORD   dwValue;        //  flag value
    PCHAR   pszString;      //  string representation of value
}
DNS_VALUE_TABLE_ENTRY, *PDNS_VALUE_TABLE;

typedef struct
{
    DWORD   dwFlag;         //  flag value
    DWORD   dwMask;         //  flag value mask
    PCHAR   pszString;      //  string representation of value
}
DNS_FLAG_TABLE_ENTRY, *PDNS_FLAG_TABLE;


//  Error return on unmatched string

#define DNS_TABLE_LOOKUP_ERROR (-1)


DWORD
Dns_ValueForString(
    IN      PDNS_VALUE_TABLE    Table,
    IN      BOOL                fIgnoreCase,
    IN      PCHAR               pchName,
    IN      INT                 cchNameLength
    );

PCHAR
Dns_GetStringForValue(
    IN      PDNS_VALUE_TABLE    Table,
    IN      DWORD               dwValue
    );

VOID
DnsPrint_ValueTable(
    IN      PRINT_ROUTINE       PrintRoutine,
    IN      PPRINT_CONTEXT      pPrintContext,
    IN      LPSTR               pszHeader,
    IN      PDNS_VALUE_TABLE    Table
    );

DWORD
Dns_FlagForString(
    IN      PDNS_FLAG_TABLE     Table,
    IN      BOOL                fIgnoreCase,
    IN      PCHAR               pchName,
    IN      INT                 cchNameLength
    );

PCHAR
Dns_WriteStringsForFlag(
    IN      PDNS_FLAG_TABLE     Table,
    IN      DWORD               dwFlag,
    IN OUT  PCHAR               pchFlag
    );


//
//  Random -- back to dnslib.h when it goes private again
//
//  DCR:  return these to dnslib.h when private
//

PCHAR
Dns_ParsePacketRecord(
    IN      PCHAR           pchPacket,
    IN      PCHAR           pchMsgEnd,
    IN OUT  PDNS_PARSED_RR  pParsedRR
    );


//
//  TSIG\TKEY read from wire function (rrread.c)
//      called in security.c
//

PDNS_RECORD
Tsig_RecordRead(
    IN OUT  PDNS_RECORD     pRR,
    IN      DNS_CHARSET     OutCharSet,
    IN OUT  PCHAR           pchStart,
    IN      PCHAR           pchData,
    IN      PCHAR           pchEnd
    );

PDNS_RECORD
Tkey_RecordRead(
    IN OUT  PDNS_RECORD     pRR,
    IN      DNS_CHARSET     OutCharSet,
    IN OUT  PCHAR           pchStart,
    IN      PCHAR           pchData,
    IN      PCHAR           pchEnd
    );


//
//  Hostent stuff (hostent.c)
//      needed by sablob.c
//

PHOSTENT
Hostent_Init(
    IN OUT  PBYTE *         ppBuffer,
    IN      INT             Family,
    IN      INT             AddrLength,
    IN      DWORD           AddrCount,
    IN      DWORD           AliasCount
    );

VOID
Hostent_ConvertToOffsets(
    IN OUT  PHOSTENT        pHostent
    );

#endif //   _DNSLIB_LOCAL_INCLUDED_
=== C:/Users/treeman/Desktop/windows nt source code\Source\Win2K3\NT\ds\dns\dnslib\message.h ===
/*++

Copyright (c) 1997-2000  Microsoft Corporation

Module Name:

    message.h

Abstract:

    Domain Name System (DNS) Library

    DNS message and associated info buffer

Author:

    Jim Gilroy (jamesg)     January 1997

Revision History:

--*/


#ifndef _DNS_MESSAGE_INCLUDED_
#define _DNS_MESSAGE_INCLUDED_



#ifndef DNSSRV

//
//  Define size of allocations, beyond message buffer itself
//
//      - size of message info struct, outside of header
//
//  Note:  the lookname buffer is placed AFTER the message buffer.
//
//  This allows us to avoid STRICT overwrite checking for small
//  items writing RR to buffer:
//      - compressed name
//      - RR (or Question) struct
//      - IP address (MX preference, SOA fixed fields)
//
//  After RR write, we check whether we are over the end of the buffer
//  and if so, we send and do not use lookup name info again anyway.
//  Cool.
//

#define DNS_MESSAGE_INCLUDED_HEADER_LENGTH  \
            ( sizeof(DNS_MSG_BUF) \
            - sizeof(DNS_HEADER) \
            - 1 )


//
//  UDP allocation
//

#define DNS_UDP_ALLOC_LENGTH    \
            ( DNS_MESSAGE_INCLUDED_HEADER_LENGTH + DNS_UDP_MAX_PACKET_LENGTH )

//
//  DNS TCP allocation.
//
//  Key point, is this is used almost entirely for zone transfer.
//
//      - 16K is maximum compression offset (14bits) so a
//        good default size for sending AXFR packets
//
//      - realloc to get 64K message maximum.
//
//  Note:  Critical that packet lengths are DWORD aligned, as
//      lookname buffer follows message at packet length.
//

#define DNS_TCP_DEFAULT_PACKET_LENGTH   (0x4000)
#define DNS_TCP_DEFAULT_ALLOC_LENGTH    (0x4000 + \
                                        DNS_MESSAGE_INCLUDED_HEADER_LENGTH)

#define DNS_TCP_REALLOC_PACKET_LENGTH   (0xfffc)
#define DNS_TCP_REALLOC_LENGTH          (0xfffc + \
                                        DNS_MESSAGE_INCLUDED_HEADER_LENGTH)


//
//  Set fields for new query
//
//  Always clear suballocation ptr fields that are deallocated
//  by query free:
//      - pRecurse
//
//  Always default to deleting on send -- fDelete set TRUE.
//
//  For debugging purposes dwQueuingTime serves as flag to
//  indicate ON or OFF a packet queue.
//
//  Lookup name buffer follows message buffer.  See note above
//  for explanation of this.
//

#define SET_MESSAGE_FOR_UDP_RECV( pMsg ) \
    {                                           \
        (pMsg)->fTcp                = FALSE;    \
        (pMsg)->fSwapped            = FALSE;    \
        (pMsg)->Timeout             = 0;        \
    }

#define SET_MESSAGE_FOR_TCP_RECV( pMsg ) \
    {                                           \
        (pMsg)->fTcp                = TRUE;     \
        (pMsg)->fSwapped            = FALSE;    \
        (pMsg)->Timeout             = 0;        \
        (pMsg)->fMessageComplete    = FALSE;    \
        (pMsg)->MessageLength       = 0;        \
        (pMsg)->pchRecv             = NULL;     \
    }


//
//  RR count writing
//

#define CURRENT_RR_COUNT_FIELD( pMsg )    \
            (*(pMsg)->pCurrentCountField)

#define SET_CURRENT_RR_COUNT_SECTION( pMsg, section )    \
            (pMsg)->pCurrentCountField = \
                        &(pMsg)->MessageHead.QuestionCount + (section);


#define SET_TO_WRITE_QUESTION_RECORDS(pMsg) \
            (pMsg)->pCurrentCountField = &(pMsg)->MessageHead.QuestionCount;

#define SET_TO_WRITE_ANSWER_RECORDS(pMsg) \
            (pMsg)->pCurrentCountField = &(pMsg)->MessageHead.AnswerCount;

#define SET_TO_WRITE_NAME_SERVER_RECORDS(pMsg) \
            (pMsg)->pCurrentCountField = &(pMsg)->MessageHead.NameServerCount;
#define SET_TO_WRITE_AUTHORITY_RECORDS(pMsg) \
            SET_TO_WRITE_NAME_SERVER_RECORDS(pMsg)

#define SET_TO_WRITE_ADDITIONAL_RECORDS(pMsg) \
            (pMsg)->pCurrentCountField = &(pMsg)->MessageHead.AdditionalCount;


#define IS_SET_TO_WRITE_ANSWER_RECORDS(pMsg) \
            ((pMsg)->pCurrentCountField == &(pMsg)->MessageHead.AnswerCount)

#define IS_SET_TO_WRITE_AUTHORITY_RECORDS(pMsg) \
            ((pMsg)->pCurrentCountField == &(pMsg)->MessageHead.NameServerCount)

#define IS_SET_TO_WRITE_ADDITIONAL_RECORDS(pMsg) \
            ((pMsg)->pCurrentCountField == &(pMsg)->MessageHead.AdditionalCount)


#endif  // no DNSSRV


//
//  DNS Query info blob
//

typedef struct _QueryInfo
{
    PSTR            pName;
    WORD            wType;
    WORD            wRcode;

    DWORD           Flags;
    DNS_STATUS      Status;

    DWORD           MessageLength;
    PBYTE           pMessage;

    PDNS_RECORD     pRecordsAnswer;
    PDNS_RECORD     pRecordsAuthority;
    PDNS_RECORD     pRecordsAdditional;

    PIP4_ARRAY      pDnsServerArray;

    //  private

    PDNS_MSG_BUF            pMsgSend;
    PDNS_MSG_BUF            pMsgRecv;

    PDNS_NETINFO            pNetworkInfo;
    PVOID                   pfnGetIpAddressInfo;

    SOCKET                  Socket;
    DWORD                   ReturnFlags;

    //  maybe fold into Status
    DNS_STATUS              NetFailureStatus;

    //  maybe fold into ReturnFlags
    BOOL                    CacheNegativeResponse;
}
QUERY_INFO, *PQUERY_INFO;



#endif  // _DNS_MESSAGE_INCLUDED_
=== C:/Users/treeman/Desktop/windows nt source code\Source\Win2K3\NT\ds\dns\dnslib\name.c ===
/*++

Copyright (c) 1995-2001 Microsoft Corporation

Module Name:

    name.c

Abstract:

    Domain Name System (DNS) Library

    DNS name routines.

Author:

    Jim Gilroy (jamesg)     October 1995

Revision History:

    jamesg  Jan 1997    UTF-8, Unicode conversions

--*/


#include "local.h"


//
//  DNS name cannonicalization
//
//  Flags to form cannonical name.
//

#define DNS_CANONICALIZING_FLAGS        ( LCMAP_LOWERCASE )

//
//  Comparison flags -- args to compare string
//
//  These flags are what DS uses when calling CompareString.
//  They are defined in ntdsapi.h.
//
//  Note:  these NORM_IGNOREXYZ flags which directory uses
//  for compare, actually STOP downcasing of these in LCMapString
//  -- international folks need to give us the correct deal here
//
//  We will only use the IGNORECASE flag because this is the
//  only one which we can use in LCMapString().
//  We want to say that if two names compare equal that you
//  can register either one and lookup the other and get the
//  result.  In other words they are equal throughout the
//  client-server system.
//  

#if 0
#define DS_DEFAULT_LOCALE_COMPARE_FLAGS    (NORM_IGNORECASE     |   \
                                            NORM_IGNOREKANATYPE |   \
                                            NORM_IGNORENONSPACE |   \
                                            NORM_IGNOREWIDTH)
#endif


#define DNS_CANONICAL_COMPARE_FLAGS     ( NORM_IGNORECASE )


//
//  Locale to canonically downcase in.
//
//  Need to disambiguate to a universal standard so that every DNS
//  server interprets these the same way.
//
//  In Win2K we used US English.  
//      Sublang: US English (0x04)  Lang:  English (0x09)
//      (note sublang US english actually 0x1, but sublang starts at
//      bit 10)
//
//  #define DNS_CANONICAL_LOCALE      ( 0x0409 )
//
//  For Whistler invariant locale is created;  It is actually the
//  same as US English for downcasing -- US English has no
//  exceptions to the default case conversion table.
//

#define DNS_CANONICAL_LOCALE      ( LOCALE_INVARIANT )




//
//  DNS Character properties for validation
//
//  DCR:  combine char validation and file tables
//      Probably could be combined with file character
//      lookup, by simply merging bit fields appropriately.
//      At this point time, however, no need to disturb
//      file lookup, which is working fine.
//
//  Character attributes bitfields
//

#define B_RFC                   0x00000001
#define B_NUMBER                0x00000002
#define B_UPPER                 0x00000004
#define B_NON_RFC               0x00000008

#define B_UTF8_TRAIL            0x00000010
#define B_UTF8_FIRST_TWO        0x00000020
#define B_UTF8_FIRST_THREE      0x00000040
#define B_UTF8_PAIR             0x00000080

#define B_DOT                   0x00000800
#define B_SPECIAL               0x00001000
#define B_LEADING_ONLY          0x00004000


//
//  Generic characters
//

#define DC_RFC          (B_RFC)
#define DC_LOWER        (B_RFC)
#define DC_UPPER        (B_UPPER | B_RFC)
#define DC_NUMBER       (B_NUMBER | B_RFC)
#define DC_NON_RFC      (B_NON_RFC)

#define DC_UTF8_TRAIL   (B_UTF8_TRAIL)
#define DC_UTF8_1ST_2   (B_UTF8_FIRST_TWO)
#define DC_UTF8_1ST_3   (B_UTF8_FIRST_THREE)
#define DC_UTF8_PAIR    (B_UTF8_PAIR)

//
//  Special characters
//      * valid as single label wildcard
//      _ leading SRV record domain names
//      / in classless in-addr
//

#define DC_DOT          (B_SPECIAL | B_DOT)

#define DC_ASTERISK     (B_SPECIAL | B_LEADING_ONLY)

#define DC_UNDERSCORE   (B_SPECIAL | B_LEADING_ONLY)

#define DC_BACKSLASH    (B_SPECIAL)

//
//  More special
//  These have no special validations, but have special file
//  properties, so define to keep table in shape for merge with
//  file chars.
//

#define DC_NULL         (0)

#define DC_OCTAL        (B_NON_RFC)
#define DC_RETURN       (B_NON_RFC)
#define DC_NEWLINE      (B_NON_RFC)
#define DC_TAB          (B_NON_RFC)
#define DC_BLANK        (B_NON_RFC)
#define DC_QUOTE        (B_NON_RFC)
#define DC_SLASH        (B_NON_RFC)
#define DC_OPEN_PAREN   (B_NON_RFC)
#define DC_CLOSE_PAREN  (B_NON_RFC)
#define DC_COMMENT      (B_NON_RFC)



//
//  DNS character table
//
//  These routines handle the name conversion issues relating to
//  writing names and strings in flat ANSI files
//      -- special file characters
//      -- quoted string
//      -- character quotes for special characters and unprintable chars
//
//  The character to char properties table allows simple mapping of
//  a character to its properties saving us a bunch of compare\branch
//  instructions in parsing file names\strings.
//
//  See nameutil.h for specific properties.
//

DWORD    DnsCharPropertyTable[] =
{
    //  control chars 0-31 must be octal in all circumstances
    //  end-of-line and tab characters are special

    DC_NULL,                // zero special on read, some RPC strings NULL terminated

    DC_OCTAL,   DC_OCTAL,   DC_OCTAL,   DC_OCTAL,
    DC_OCTAL,   DC_OCTAL,   DC_OCTAL,   DC_OCTAL,

    DC_TAB,                 // tab
    DC_NEWLINE,             // line feed
    DC_OCTAL,
    DC_OCTAL,
    DC_RETURN,              // carriage return
    DC_OCTAL,
    DC_OCTAL,

    DC_OCTAL,   DC_OCTAL,   DC_OCTAL,   DC_OCTAL,
    DC_OCTAL,   DC_OCTAL,   DC_OCTAL,   DC_OCTAL,
    DC_OCTAL,   DC_OCTAL,   DC_OCTAL,   DC_OCTAL,
    DC_OCTAL,   DC_OCTAL,   DC_OCTAL,   DC_OCTAL,

    DC_BLANK,               // blank, special char but needs octal quote

    DC_NON_RFC,             // !
    DC_QUOTE,               // " always must be quoted
    DC_NON_RFC,             // #
    DC_NON_RFC,             // $
    DC_NON_RFC,             // %
    DC_NON_RFC,             // &
    DC_NON_RFC,             // '

    DC_OPEN_PAREN,          // ( datafile line extension
    DC_CLOSE_PAREN,         // ) datafile line extension
    DC_ASTERISK,            // *
    DC_NON_RFC,             // +
    DC_NON_RFC,             // ,
    DC_RFC,                 // - RFC for hostname
    DC_DOT,                 // . must quote in names
    DC_BACKSLASH,           // /

    // 0 - 9 RFC for hostname

    DC_NUMBER,  DC_NUMBER,  DC_NUMBER,  DC_NUMBER,
    DC_NUMBER,  DC_NUMBER,  DC_NUMBER,  DC_NUMBER,
    DC_NUMBER,  DC_NUMBER,

    DC_NON_RFC,             // :
    DC_COMMENT,             // ;  datafile comment
    DC_NON_RFC,             // <
    DC_NON_RFC,             // =
    DC_NON_RFC,             // >
    DC_NON_RFC,             // ?
    DC_NON_RFC,             // @

    // A - Z RFC for hostname

    DC_UPPER,   DC_UPPER,   DC_UPPER,   DC_UPPER,
    DC_UPPER,   DC_UPPER,   DC_UPPER,   DC_UPPER,
    DC_UPPER,   DC_UPPER,   DC_UPPER,   DC_UPPER,
    DC_UPPER,   DC_UPPER,   DC_UPPER,   DC_UPPER,
    DC_UPPER,   DC_UPPER,   DC_UPPER,   DC_UPPER,
    DC_UPPER,   DC_UPPER,   DC_UPPER,   DC_UPPER,
    DC_UPPER,   DC_UPPER,

    DC_NON_RFC,             // [
    DC_SLASH,               // \ always must be quoted
    DC_NON_RFC,             // ]
    DC_NON_RFC,             // ^
    DC_UNDERSCORE,          // _
    DC_NON_RFC,             // `

    // a - z RFC for hostname

    DC_LOWER,   DC_LOWER,   DC_LOWER,   DC_LOWER,
    DC_LOWER,   DC_LOWER,   DC_LOWER,   DC_LOWER,
    DC_LOWER,   DC_LOWER,   DC_LOWER,   DC_LOWER,
    DC_LOWER,   DC_LOWER,   DC_LOWER,   DC_LOWER,
    DC_LOWER,   DC_LOWER,   DC_LOWER,   DC_LOWER,
    DC_LOWER,   DC_LOWER,   DC_LOWER,   DC_LOWER,
    DC_LOWER,   DC_LOWER,

    DC_NON_RFC,             // {
    DC_NON_RFC,             // |
    DC_NON_RFC,             // }
    DC_NON_RFC,             // ~
    DC_OCTAL,               // 0x7f DEL code

    //  UTF8 trail bytes
    //      - chars   0x80 <= X < 0xc0
    //      - mask [10xx xxxx]
    //
    //  Lead UTF8 character determines count of bytes in conversion.
    //  Trail characters fill out conversion.

    DC_UTF8_TRAIL,  DC_UTF8_TRAIL,  DC_UTF8_TRAIL,  DC_UTF8_TRAIL,
    DC_UTF8_TRAIL,  DC_UTF8_TRAIL,  DC_UTF8_TRAIL,  DC_UTF8_TRAIL,
    DC_UTF8_TRAIL,  DC_UTF8_TRAIL,  DC_UTF8_TRAIL,  DC_UTF8_TRAIL,
    DC_UTF8_TRAIL,  DC_UTF8_TRAIL,  DC_UTF8_TRAIL,  DC_UTF8_TRAIL,
    DC_UTF8_TRAIL,  DC_UTF8_TRAIL,  DC_UTF8_TRAIL,  DC_UTF8_TRAIL,
    DC_UTF8_TRAIL,  DC_UTF8_TRAIL,  DC_UTF8_TRAIL,  DC_UTF8_TRAIL,
    DC_UTF8_TRAIL,  DC_UTF8_TRAIL,  DC_UTF8_TRAIL,  DC_UTF8_TRAIL,
    DC_UTF8_TRAIL,  DC_UTF8_TRAIL,  DC_UTF8_TRAIL,  DC_UTF8_TRAIL,

    DC_UTF8_TRAIL,  DC_UTF8_TRAIL,  DC_UTF8_TRAIL,  DC_UTF8_TRAIL,
    DC_UTF8_TRAIL,  DC_UTF8_TRAIL,  DC_UTF8_TRAIL,  DC_UTF8_TRAIL,
    DC_UTF8_TRAIL,  DC_UTF8_TRAIL,  DC_UTF8_TRAIL,  DC_UTF8_TRAIL,
    DC_UTF8_TRAIL,  DC_UTF8_TRAIL,  DC_UTF8_TRAIL,  DC_UTF8_TRAIL,
    DC_UTF8_TRAIL,  DC_UTF8_TRAIL,  DC_UTF8_TRAIL,  DC_UTF8_TRAIL,
    DC_UTF8_TRAIL,  DC_UTF8_TRAIL,  DC_UTF8_TRAIL,  DC_UTF8_TRAIL,
    DC_UTF8_TRAIL,  DC_UTF8_TRAIL,  DC_UTF8_TRAIL,  DC_UTF8_TRAIL,
    DC_UTF8_TRAIL,  DC_UTF8_TRAIL,  DC_UTF8_TRAIL,  DC_UTF8_TRAIL,

    //  UTF8_1ST_OF_2
    //      - chars > 0xc0 to 0xdf
    //      - mask [110x xxxx]
    //
    //  Converting unicode chars > 7 bits <= 11 bits (from 0x80 to 0x7ff)
    //  consists of first of two char followed by one trail bytes

    DC_UTF8_1ST_2,  DC_UTF8_1ST_2,  DC_UTF8_1ST_2,  DC_UTF8_1ST_2,
    DC_UTF8_1ST_2,  DC_UTF8_1ST_2,  DC_UTF8_1ST_2,  DC_UTF8_1ST_2,
    DC_UTF8_1ST_2,  DC_UTF8_1ST_2,  DC_UTF8_1ST_2,  DC_UTF8_1ST_2,
    DC_UTF8_1ST_2,  DC_UTF8_1ST_2,  DC_UTF8_1ST_2,  DC_UTF8_1ST_2,
    DC_UTF8_1ST_2,  DC_UTF8_1ST_2,  DC_UTF8_1ST_2,  DC_UTF8_1ST_2,
    DC_UTF8_1ST_2,  DC_UTF8_1ST_2,  DC_UTF8_1ST_2,  DC_UTF8_1ST_2,
    DC_UTF8_1ST_2,  DC_UTF8_1ST_2,  DC_UTF8_1ST_2,  DC_UTF8_1ST_2,
    DC_UTF8_1ST_2,  DC_UTF8_1ST_2,  DC_UTF8_1ST_2,  DC_UTF8_1ST_2,

    //  UTF8_1ST_OF_3
    //      - chars > 0xe0
    //      - mask [1110 xxxx]
    //
    //  Converting unicode > 11 bits (0x7ff)
    //  consists of first of three char followed by two trail bytes

    DC_UTF8_1ST_3,  DC_UTF8_1ST_3,  DC_UTF8_1ST_3,  DC_UTF8_1ST_3,
    DC_UTF8_1ST_3,  DC_UTF8_1ST_3,  DC_UTF8_1ST_3,  DC_UTF8_1ST_3,
    DC_UTF8_1ST_3,  DC_UTF8_1ST_3,  DC_UTF8_1ST_3,  DC_UTF8_1ST_3,
    DC_UTF8_1ST_3,  DC_UTF8_1ST_3,  DC_UTF8_1ST_3,  DC_UTF8_1ST_3,
    DC_UTF8_1ST_3,  DC_UTF8_1ST_3,  DC_UTF8_1ST_3,  DC_UTF8_1ST_3,
    DC_UTF8_1ST_3,  DC_UTF8_1ST_3,  DC_UTF8_1ST_3,  DC_UTF8_1ST_3,
    DC_UTF8_1ST_3,  DC_UTF8_1ST_3,  DC_UTF8_1ST_3,  DC_UTF8_1ST_3,
    DC_UTF8_1ST_3,  DC_UTF8_1ST_3,  DC_UTF8_1ST_3,  DC_UTF8_1ST_3
};



VOID
Dns_VerifyValidFileCharPropertyTable(
    VOID
    )
/*++

Routine Description:

    Verify haven't broken lookup table.

Arguments:

    None

Return Value:

    None

--*/
{
    ASSERT( DnsCharPropertyTable[0]       == DC_NULL        );
    ASSERT( DnsCharPropertyTable['\t']    == DC_TAB         );
    ASSERT( DnsCharPropertyTable['\n']    == DC_NEWLINE     );
    ASSERT( DnsCharPropertyTable['\r']    == DC_RETURN      );
    ASSERT( DnsCharPropertyTable[' ']     == DC_BLANK       );
    ASSERT( DnsCharPropertyTable['"']     == DC_QUOTE       );
    ASSERT( DnsCharPropertyTable['(']     == DC_OPEN_PAREN  );
    ASSERT( DnsCharPropertyTable[')']     == DC_CLOSE_PAREN );
    ASSERT( DnsCharPropertyTable['*']     == DC_ASTERISK     );
    ASSERT( DnsCharPropertyTable['-']     == DC_RFC         );
    ASSERT( DnsCharPropertyTable['.']     == DC_DOT         );
    ASSERT( DnsCharPropertyTable['/']     == DC_BACKSLASH   );
    ASSERT( DnsCharPropertyTable['0']     == DC_NUMBER      );
    ASSERT( DnsCharPropertyTable['9']     == DC_NUMBER      );
    ASSERT( DnsCharPropertyTable[';']     == DC_COMMENT     );
    ASSERT( DnsCharPropertyTable['A']     == DC_UPPER       );
    ASSERT( DnsCharPropertyTable['Z']     == DC_UPPER       );
    ASSERT( DnsCharPropertyTable['\\']    == DC_SLASH       );
    ASSERT( DnsCharPropertyTable['_']     == DC_UNDERSCORE  );
    ASSERT( DnsCharPropertyTable['a']     == DC_LOWER       );
    ASSERT( DnsCharPropertyTable['z']     == DC_LOWER       );
    ASSERT( DnsCharPropertyTable[0x7f]    == DC_OCTAL       );
    ASSERT( DnsCharPropertyTable[0x80]    == DC_UTF8_TRAIL  );
    ASSERT( DnsCharPropertyTable[0xbf]    == DC_UTF8_TRAIL  );
    ASSERT( DnsCharPropertyTable[0xc0]    == DC_UTF8_1ST_2  );
    ASSERT( DnsCharPropertyTable[0xdf]    == DC_UTF8_1ST_2  );
    ASSERT( DnsCharPropertyTable[0xe0]    == DC_UTF8_1ST_3  );
    ASSERT( DnsCharPropertyTable[0xff]    == DC_UTF8_1ST_3  );
};



//
//  Validation routine flags
//

#define DNSVAL_ALLOW_LEADING_UNDERSCORE     0x00010000
#define DNSVAL_ALLOW_ASTERISK               0x00020000
#define DNSVAL_ALLOW_BACKSLASH              0x00040000

//
//  Validation bit flags
//

#define DNS_BIT_NAME_FQDN                   0x00000001
#define DNS_BIT_NAME_SINGLE_LABEL           0x00000002
#define DNS_BIT_NAME_DOTTED                 0x00000004
#define DNS_BIT_NAME_ROOT                   0x00000008

#define DNS_BIT_NAME_CONTAINS_UPPER         0x00000010
#define DNS_BIT_NAME_NUMERIC                0x00000100
#define DNS_BIT_NAME_NUMERIC_LABEL          0x00000200
#define DNS_BIT_NAME_NUMERIC_FIRST_LABEL    0x00000400

#define DNS_BIT_NAME_UNDERSCORE             0x00001000
#define DNS_BIT_NAME_WILDCARD               0x00002000
#define DNS_BIT_NAME_BACKSLASH              0x00004000
#define DNS_BIT_NAME_NON_RFC_ASCII          0x00008000
#define DNS_BIT_NAME_MULTIBYTE              0x00010000
#define DNS_BIT_NAME_BINARY_LABEL           0x00020000

#define DNS_BIT_NAME_INVALID                0x80000000




#if 0
//
//  Old validation -- retired
//
//  Downcase and validation table
//
//  DCR:  table lookup for all DNS char properties
//        especially RFC, non-RFC, invalid
//

typedef struct _Dns_ValidationChar
{
    CHAR        chDown;
    UCHAR       fNonRfc;
}
DNS_VALIDATION_CHAR;

#define NON_RFC         (1)
#define EXTENDED_CHAR   (0x80)


DNS_VALIDATION_CHAR
Dns_ValidateDowncaseChar(
    IN      CHAR            ch
    )
/*++

Routine Description:

    Validates character

Arguments:

    ch  -- character to validate

Return Value:

    Validation character -- downcased character and flag

--*/
{
    DNS_VALIDATION_CHAR     val;

    //  default to normal character

    val.chDown = ch;
    val.fNonRfc = 0;

    //
    //  break out character tests
    //      - attempt most likely to least likely
    //      - but also working down to simplify tests
    //

    if ( (UCHAR)ch >= 'a' )
    {
        if ( (UCHAR)ch <= 'z' )
        {
            return( val );
        }
        val.fNonRfc = NON_RFC;
        if ( ch & 0x80 )
        {
            val.fNonRfc = EXTENDED_CHAR;
        }
    }

    else if ( (UCHAR)ch >= 'A' )
    {
        if ( (UCHAR)ch <= 'Z' )
        {
            val.chDown = ch + 0x20;
            return( val );
        }
        val.fNonRfc = NON_RFC;
    }

    else if ( (UCHAR)ch >= '0' )
    {
        if ( (UCHAR)ch <= '9' )
        {
            return( val );
        }
        val.fNonRfc = NON_RFC;
    }

    else if ( (UCHAR)ch > ' ' )
    {
        if ( (UCHAR)ch == '-' )
        {
            return( val );
        }
        val.fNonRfc = NON_RFC;
    }

    //  blank or below is flat error

    else
    {
        val.chDown = 0;
        val.fNonRfc = NON_RFC;
    }

    return( val );
}
#endif



//
//  Name validation
//
//  DCR:  name validation by bitfield
//
//  An interesting approach to validation, would be to expose
//  a set of properties about a name.
//  Caller could then specify allowable set (we'd give packages)
//  and we'd give back actual set.
//  Low level routines would do nothing but return bit field of
//  property set.
//
//  Properties would include:
//      - RFC
//      - contains numeric
//      - contains upper
//      - all numeric
//      - first label numeric
//
//      - utf8 multibyte
//      - underscore
//      - other non-RFC
//      - unprintable
//      - non-utf8 high (i.e. requires binary label)
//
//      - FQDN
//      - single label
//      - root
//


DNS_STATUS
validateDnsNamePrivate(
    IN      LPCSTR          pszName,
    IN      DWORD           dwFlag,
    OUT     PDWORD          pLabelCount,
    OUT     PDWORD          pResultFlag
    )
/*++

Routine Description:

    Verifies name is valid DNS name.

Arguments:

    pszName -- DNS name (standard dotted form) to check

    dwFlags -- validation flags
        - DNSVAL_ALLOW_LEADING_UNDERSCORE
        - DNSVAL_ALLOW_BACKSLASH
        - DNSVAL_ALLOW_ASTERIK

    pLabelCount -- addr to recv label count

    pResultFlag -- addr to recv result flag

Return Value:

    ERROR_SUCCESS               -- completely RFC compliant name
    DNS_ERROR_NON_RFC_NAME      -- syntax valid, but not standard RFC name
    DNS_ERROR_INVALID_NAME_CHAR -- syntax valid, but invalid characters
    ERROR_INVALID_NAME          -- name completely useless, bogus, toast

--*/
{
    PUCHAR      pch = (PUCHAR)pszName;
    UCHAR       ch;
    DWORD       charProp;
    DWORD       labelCount = 0;
    DWORD       trailCount = 0;
    INT         labelCharCount = 0;
    INT         labelNumberCount = 0;
    DWORD       flag;
    BOOL        fqdn = FALSE;
    BOOL        fnonRfc = FALSE;
    BOOL        finvalidChar = FALSE;
    BOOL        fnameNonNumeric = FALSE;
    BOOL        flabelNonNumeric = FALSE;
    DNS_STATUS  status;


    DNSDBG( TRACE, ( "validateNamePrivate()\n" ));

    if ( !pch )
    {
        goto InvalidName;
    }

    //
    //  validations
    //      - name length (255)
    //      - label length (63)
    //      - UTF8 encoding correct
    //      - no unprintable characters
    //

    while ( 1 )
    {
        //  get next character and properties

        ch = *pch++;
        charProp = DnsCharPropertyTable[ ch ];

        //  inc label count
        //      - do here for simplicity, dec in "." case below

        labelCharCount++;

        //
        //  simplify UTF8 -- just get it out of the way
        //      need to do first or else need trailCount==0 checks
        //      on all other paths
        //

        if ( ch >= 0x80 )
        {
            DWORD tempStatus;

            tempStatus = Dns_ValidateUtf8Byte(
                            ch,
                            & trailCount );
            if ( tempStatus != ERROR_SUCCESS )
            {
                DNSDBG( READ, (
                    "ERROR:  Name UTF8 trail count check at %c\n", ch ));
                goto InvalidName;
            }
            fnonRfc = TRUE;
            continue;
        }

        //
        //  trail count check
        //      - all ASCII chars, must not be in middle of UTF8
        //

        if ( trailCount )
        {
            DNSDBG( READ, (
                "ERROR:  Name failed trail count check at %c\n", ch ));
            goto InvalidName;
        }

        //
        //  full RFC -- continue
        //

        if ( charProp & B_RFC )
        {
            if ( charProp & B_NUMBER )
            {
                labelNumberCount++;
            }
            continue;
        }

        //
        //  label termination:  dot or NULL
        //

        if ( ch == '.' || ch == 0 )
        {
            labelCharCount--;

            //  FQDN termination
            //      - termination with no bytes in label
            //
            //  two cases:
            //  1) terminate on NULL char
            //      - standard FQDN "foo.bar."
            //      - but empty name invalid
            //  2) terminate on dot
            //      - only "." root valid
            //      - all other ".." or ".xyz" cases invalid

            if ( labelCharCount == 0 )
            {
                fqdn = TRUE;

                if ( ch == 0 )
                {
                    if ( labelCount )
                    {
                        goto Done;
                    }
                }
                else if ( pch == pszName+1 && *pch == 0 )
                {
                    //  root
                    //      - set flags for validity
                    //      - skip final length check

                    fnameNonNumeric = TRUE;
                    flabelNonNumeric = TRUE;
                    goto DoneRoot;
                }
                DNSDBG( READ, (
                    "ERROR:  Name (%s) failed check\n",
                    pszName ));
                goto InvalidName;
            }

            //
            //  read non-empty label
            //      - label length validity
            //      - detect non-numeric labels
            //      (easier to handle numeric name check, by detecting non-numeric)
            //

            if ( labelCharCount > DNS_MAX_LABEL_LENGTH )
            {
                DNSDBG( READ, ( "ERROR:  Name failed label count check\n" ));
                goto InvalidName;
            }

            if ( labelNumberCount != labelCharCount )
            {
                fnameNonNumeric = TRUE;
                if ( labelCount == 0 )
                {
                    flabelNonNumeric = TRUE;
                }
            }

            //  count label
            //      - stop if NULL terminator
            //      - otherwise, reset for next label and continue

            labelCount++;
            if ( ch == 0 )
            {
                break;
            }
            labelCharCount = 0;
            labelNumberCount = 0;
            continue;
        }

        //
        //  non-RFC
        //      - currently accepting only "_" as allowable as part of
        //      microsoft acceptable non-RFC set
        //
        //      however DNS server must be able to read *, \, etc
        //      it gets called through Dns_CreateStandardDnsName()
        //
        //  note, could tighten this up with special flag, but since
        //  this only speeds case with invalid chars, there's not much
        //  point;  underscore is likely to see significant use
        //

        //  underscore
        //      - can be valid as part of SRV domain name
        //      - otherwise non-RFC

        if ( ch == '_' )
        {
            if ( labelCharCount == 1 &&
                 (*pch && *pch!= '.') &&
                 (dwFlag & DNSVAL_ALLOW_LEADING_UNDERSCORE) )
            {
                continue;
            }
            fnonRfc = TRUE;
            continue;
        }

        //  backslash
        //      - used to denote classless in-addr domains
        //      - so valid even as zone name on server
        //      - otherwise completely invalid

        else if ( ch == '/' )
        {
            if ( dwFlag & DNSVAL_ALLOW_BACKSLASH )
            {
                continue;
            }
        }

        //  asterisk
        //      - valid only as single-byte first label in wildcard name
        //      - otherwise completely invalid

        else if ( ch == '*' )
        {
            if ( labelCount == 0 &&
                labelCharCount == 1 &&
                 ( *pch==0 || *pch=='.') &&
                 (dwFlag & DNSVAL_ALLOW_ASTERISK) )
            {
                continue;
            }
        }

        //  anything else is complete junk
        //
        //  JENHANCE:  if desired, could break out printable\non

        fnonRfc = TRUE;
        finvalidChar = TRUE;
        DNSDBG( READ, ( "ERROR:  Name character %c failed check\n", ch ));
        continue;
    }

Done:

    //  verify total name length
    //  to fit in wire 255 limit:
    //      - FQDN can be up to 254
    //      - non-FQDN can be up to 253

    pch--;
    DNS_ASSERT( pch > pszName );
    labelCharCount = (INT)(pch - pszName);

    if ( !fqdn )
    {
        labelCharCount++;
    }
    if ( labelCharCount >= DNS_MAX_NAME_LENGTH )
    {
        DNSDBG( READ, ( "ERROR:  Name failed final length check\n" ));
        goto InvalidName;
    }

DoneRoot:

    //
    //  return flags
    //
    //  JENHANCE:  all returns from validateNamePrivate() could come
    //      as result flag;   then charset issues could be separated
    //      out by higher level routine
    //

    *pLabelCount = labelCount;

    flag = 0;
    if ( fqdn )
    {
        flag |= DNS_BIT_NAME_FQDN;
    }
    if ( ! fnameNonNumeric )
    {
        flag |= DNS_BIT_NAME_NUMERIC;
    }
    if ( ! flabelNonNumeric )
    {
        flag |= DNS_BIT_NAME_NUMERIC_FIRST_LABEL;
    }
    *pResultFlag = flag;

    //
    //  return status
    //      ERROR_SUCCESS -- full RFC name
    //      DNS_ERROR_NON_RFC_NAME -- MS extended and '_' names
    //      DNS_ERROR_INVALID_NAME_CHAR -- syntaxtically valid, but bad chars
    //      ERROR_INVALID_NAME -- syntaxtically invalid name
    //

    status = ERROR_SUCCESS;

    if ( finvalidChar )
    {
        status = DNS_ERROR_INVALID_NAME_CHAR;
    }
    else if ( fnonRfc )
    {
        status = DNS_ERROR_NON_RFC_NAME;
    }

    DNSDBG( READ, (
        "Leave validateNamePrivate(), status = %d\n",
        status ));

    return( status );


InvalidName:

    DNSDBG( READ, (
        "Leave validateNamePrivate(), status = ERROR_INVALID_NAME\n" ));

    *pLabelCount = 0;
    *pResultFlag = 0;
    return( ERROR_INVALID_NAME );
}



DNS_STATUS
Dns_ValidateName_UTF8(
    IN      LPCSTR          pszName,
    IN      DNS_NAME_FORMAT Format
    )
/*++

Routine Description:

    Verifies name is valid DNS name.

Arguments:

    pszName -- DNS name (standard dotted form) to check

    Format -- required format of DNS name

Return Value:

    ERROR_SUCCESS               -- completely RFC compliant name
    DNS_ERROR_NON_RFC_NAME      -- syntax valid, but not standard RFC name
    DNS_ERROR_NUMERIC_NAME      -- syntax valid, but numeric label violation
    DNS_ERROR_INVALID_NAME_CHAR -- syntax valid, but invalid characters
    ERROR_INVALID_NAME          -- name completely useless, bogus, toast

--*/
{
    DNS_STATUS  status;
    DWORD       labelCount;
    BOOL        isFqdn;
    DWORD       flag = 0;
    DWORD       resultFlag = 0;


    DNSDBG( TRACE, (
        "Dns_ValidateName_UTF8()\n"
        "\tname     = %s\n"
        "\tformat   = %d\n",
        pszName,
        Format
        ));

    if ( !pszName )
    {
        return( ERROR_INVALID_NAME );
    }

    //
    //  special casing?
    //
    //  SRV records can have leading underscores
    //  wildcards can have first label "*"
    //  backslash ok in classless in-addr domains
    //

    switch( Format )
    {
#if 0
    case DnsNameServerZonePrivate:

        flag = DNSVAL_ALLOW_BACKSLASH | DNSVAL_ALLOW_LEADING_UNDERSCORE;
#endif

    case DnsNameWildcard:

        flag = DNSVAL_ALLOW_ASTERISK;
        break;

    case DnsNameSrvRecord:

        flag = DNSVAL_ALLOW_LEADING_UNDERSCORE;
        break;
    }

    //
    //  do validation
    //
    //  return immediately on invalid name, so type
    //  specific returns do not overwrite this error
    //

    status = validateDnsNamePrivate(
                pszName,
                flag,
                & labelCount,
                & resultFlag
                );
    if ( status == ERROR_INVALID_NAME )
    {
        return( status );
    }

    //
    //  do name type specific validation
    //

    switch( Format )
    {
    //  domain name -- any valid non-numeric DNS name

    case DnsNameDomain:

        if ( resultFlag & DNS_BIT_NAME_NUMERIC )
        {
            return( DNS_ERROR_NUMERIC_NAME );
        }
        return( status );

    //  domain name label -- any valid single-label DNS name

    case DnsNameDomainLabel:

        if ( labelCount != 1 || resultFlag & DNS_BIT_NAME_FQDN )
        {
            return( ERROR_INVALID_NAME );
        }
        return( status );

    //  hostname full -- non-numeric hostname label

    case DnsNameHostnameFull:

        if ( resultFlag & DNS_BIT_NAME_NUMERIC_FIRST_LABEL )
        {
            return( DNS_ERROR_NUMERIC_NAME );
        }
        return( status );

    //  hostname label -- single label and non-numeric

    case DnsNameHostnameLabel:

        if ( labelCount != 1 || resultFlag & DNS_BIT_NAME_FQDN )
        {
            return( ERROR_INVALID_NAME );
        }
        if ( resultFlag & DNS_BIT_NAME_NUMERIC_FIRST_LABEL )
        {
            return( DNS_ERROR_NUMERIC_NAME );
        }
        return( status );

    //
    //  wildcard -- single "*" as first label
    //      if *.???? then must revalidate the rest of the name as
    //          "*" has probably resulted in validation error
    //      if "*" then consider this successful
    //

    case DnsNameWildcard:

        if ( *pszName == '*' )
        {
            return( status );
        }
        return( ERROR_INVALID_NAME );

    //
    //  SRV label -- validate leading underscore
    //

    case DnsNameSrvRecord:

        if ( *pszName == '_' )
        {
            return( status );
        }
        return( ERROR_INVALID_NAME );

    //
    //  unknown format validation
    //

    default:

        return( ERROR_INVALID_PARAMETER );
    }
}


DNS_STATUS
Dns_ValidateName_W(
    IN      LPCWSTR         pwszName,
    IN      DNS_NAME_FORMAT Format
    )
/*++

Routine Description:

    Verifies name is valid DNS name.

Arguments:

    pwszName -- DNS name (standard dotted form) to check

    Format -- required format of DNS name

Return Value:

    ERROR_SUCCESS -- if completely compliant name
    DNS_ERROR_NON_RFC_NAME -- if not standard RFC name
    ERROR_INVALID_NAME -- if name completely useless, bogus, toast

--*/
{
    DWORD   nameLength = MAX_PATH;
    CHAR    nameBuffer[ MAX_PATH ] = {0};   // init for prefix

    //
    //  convert name to UTF8
    //      - if can't convert, then can't fit into buffer
    //      so must be invalid name on length grounds
    //

    if ( ! Dns_NameCopy(
                nameBuffer,
                & nameLength,       // avail buf length
                (PCHAR) pwszName,
                0,                  // unknown length
                DnsCharSetUnicode,  // unicode in
                DnsCharSetUtf8      // UTF8 out
                ) )
    {
        return( ERROR_INVALID_NAME );
    }

    //
    //  validate name in UTF8 format

    return Dns_ValidateName_UTF8(
                (LPCSTR) nameBuffer,
                Format );
}



DNS_STATUS
Dns_ValidateName_A(
    IN      LPCSTR          pszName,
    IN      DNS_NAME_FORMAT Format
    )
/*++

Routine Description:

    Verifies name is valid DNS name.

Arguments:

    pszName -- DNS name (standard dotted form) to check

    Format -- required format of DNS name

Return Value:

    ERROR_SUCCESS -- if completely compliant name
    DNS_ERROR_NON_RFC_NAME -- if not standard RFC name
    ERROR_INVALID_NAME -- if name completely useless, bogus, toast

--*/
{
    DWORD   nameLength = MAX_PATH;
    CHAR    nameBuffer[ MAX_PATH ];

    //
    //  convert name to UTF8
    //      - if can't convert, then can't fit into buffer
    //      so must be invalid name on length grounds
    //

    if ( ! Dns_NameCopy(
                nameBuffer,
                & nameLength,       // avail buf length
                (PCHAR) pszName,
                0,                  // unknown length
                DnsCharSetAnsi,     // unicode in
                DnsCharSetUtf8      // UTF8 out
                ) )
    {
        return( ERROR_INVALID_NAME );
    }

    //
    //  validate name in UTF8 format

    return Dns_ValidateName_UTF8(
                (LPCSTR) nameBuffer,
                Format );
}



DNS_STATUS
Dns_ValidateDnsString_UTF8(
    IN      LPCSTR          pszString
    )
/*++

Routine Description:

    Verifies string is valid DNS string.

Arguments:

    pszString -- DNS string (standard dotted form) to check

Return Value:

    ERROR_SUCCESS -- if completely compliant string
    ERROR_INVALID_DATA -- otherwise

--*/
{
    PUCHAR      pch = (PUCHAR) pszString;
    UCHAR       ch;
    DWORD       trailCount = 0;

    DNSDBG( TRACE, ( "Dns_ValidateDnsString_UTF8()\n" ));

    if ( !pszString )
    {
        return( ERROR_INVALID_DATA );
    }

    //
    //  validations
    //      - string length (255)
    //      - UTF8 chars valid
    //      - no unprintable characters
    //

    while ( ch = *pch++ )
    {
        if ( ch & 0x80 )
        {
            DWORD status;
            status = Dns_ValidateUtf8Byte(
                        ch,
                        & trailCount );
            if ( status != ERROR_SUCCESS )
            {
                return( status );
            }
        }

        else if ( ch < ' ' )
        {
            return( ERROR_INVALID_DATA );
        }
    }

    //  verify string length ok

    if ( pch - pszString > DNS_MAX_NAME_LENGTH )
    {
        return( ERROR_INVALID_DATA );
    }
    return( ERROR_SUCCESS );
}



DNS_STATUS
Dns_ValidateDnsString_W(
    IN      LPCWSTR     pszString
    )
/*++

Routine Description:

    Verifies string is valid DNS string.

    Not sure there's any need to UNICODE string routine.

Arguments:

    pszString -- DNS string

Return Value:

    ERROR_SUCCESS -- if completely compliant string
    ERROR_INVALID_DATA -- otherwise

--*/
{
    INT     count;
    CHAR    stringUtf8[ DNS_MAX_NAME_BUFFER_LENGTH ];
    DWORD   bufLength = DNS_MAX_NAME_BUFFER_LENGTH;

    DNSDBG( TRACE, ( "Dns_ValidateDnsString_W()\n" ));

    if ( !pszString )
    {
        return( ERROR_INVALID_DATA );
    }

    //
    //  need to convert to unicode in order to test UTF8 (wire) length
    //      - buffer (twice max length) can hold any valid
    //      coversion of unicode name within max length
    //

    count = wcslen( pszString );
    if ( count > DNS_MAX_NAME_LENGTH )
    {
        return( ERROR_INVALID_DATA );
    }

    //
    //  convert, then test
    //

    if ( ! Dns_StringCopy(
                stringUtf8,
                & bufLength,
                (LPSTR) pszString,
                (WORD) count,
                DnsCharSetUnicode,  // unicode in
                DnsCharSetUtf8      // UTF8 out
                ) )
    {
        return( ERROR_INVALID_DATA );
    }

    return  Dns_ValidateDnsString_UTF8( stringUtf8 );
}



//
//  Name cannonicalization
//
//  Currently, clients downcase (when extended) in their locale to go to wire.
//  On server end however all names are cannonicalized.
//
//  DCR:  cannonicalize completely on client end?
//      Ideally client would do complete cannonicallization on its end.
//      The only issue is whether there are locale specific issues where
//      downcasing would be different and yield substaintially different result
//

#define MAX_DNS_DOWN_CASE_BUF_LEN 512



DWORD
Dns_MakeCanonicalNameW(
    OUT     PWSTR           pBuffer,
    IN      DWORD           BufLength,
    IN      PWSTR           pwsString,
    IN      DWORD           StringLength
    )
/*++

Routine Description:

    Create cannonical unicode DNS name.

    This name is downcased and ambiguities converted to standard
    DNS characters.

Arguments:

    pBuffer -- buffer to recv canon name

    BufLength -- length of buffer;  if 0, buffer MUST have adequate length

    pwsString -- ptr to string to copy

    StringLength -- string length, if known

Return Value:

    Count of characters converted INCLUDING NULL terminator.
    Zero on error.

--*/
{
    DWORD   inLength = StringLength;

    //
    //  verify adequate buffer length
    //
    //  DCR:  should allow non-null terminated canonicalizations?
    //
    //  note:  we allow and convert non-null terminated name
    //      the result will not necessarily be NULL terminated
    //      if buffer is exactly equal to string length
    //

    if ( inLength == 0 )
    {
        inLength = wcslen( pwsString );
        inLength++;
    }

    if ( BufLength < inLength )
    {
        DNSDBG( ANY, (
            "ERROR:  insufficient cannon buffer len = %d\n"
            "\tstring = %S, len = %d\n",
            BufLength,
            pwsString,
            inLength ));
        SetLastError( ERROR_INSUFFICIENT_BUFFER );
        return( 0 );
    }

    //
    //  convert name
    //      - downcase with canonicalizing rules
    //

    inLength = LCMapStringW(
                    DNS_CANONICAL_LOCALE,
                    DNS_CANONICALIZING_FLAGS,
                    pwsString,
                    inLength,
                    pBuffer,
                    BufLength
                    );

#if DBG
    if ( inLength == 0 )
    {
        DNS_STATUS status = GetLastError();

        DNSDBG( ANY, (
            "Canonicalization failed => %d\n"
            "\tin  %S\n",
            status,
            pwsString ));

        SetLastError( status );
    }
    else
    {
        //
        //  DCR:  warning this print can blow on non-null terminated conversions
        //

        DNSDBG( READ, (
            "Canonicalized name at %p\n"
            "\tin   %S\n"
            "\tout  %S\n",
            pwsString,
            pwsString,
            (PWSTR) pBuffer ));
    }
#endif

    return( inLength );
}



DWORD
Dns_MakeCanonicalNameInPlaceW(
    IN      PWCHAR          pwString,
    IN      DWORD           StringLength
    )
/*++

Routine Description:

    In place cannonicalization of name.

Arguments:

    pwString -- ptr to string to copy

    StringLength -- length of string
        if zero string assumed to be NULL terminated, in this case
        canonicalization includes NULL terminator

Return Value:

    Count of characters converted -- including NULL terminator if
        StringLength is unspecified
    Zero on error.

--*/
{
    DWORD   nameLength = StringLength;
    WCHAR   tempBuffer[ DNS_MAX_NAME_BUFFER_LENGTH_UNICODE ] = { 0 };    // init for prefix

    DNSDBG( READ, (
        "Dns_MakeCanonicalNameInPlace()\n"
        "\tpwString = %S\n"
        "\tlength   = %d\n",
        pwString,
        StringLength ));

    //  if length unknown, must be NULL terminated string

    if ( nameLength == 0 )
    {
        nameLength = (DWORD) wcslen( pwString );
        nameLength++;
    }

    //
    //  cannonicalize (downcase and cleanup)
    //      - copy string to temp buffer
    //      - then cannonicalize into original buffer
    //

    if ( nameLength <= DNS_MAX_NAME_BUFFER_LENGTH_UNICODE )
    {
        wcsncpy( tempBuffer, pwString, nameLength );

        return  Dns_MakeCanonicalNameW(
                    pwString,       //  write back to original string
                    nameLength,     //  length of buffer
                    tempBuffer,     //  input is temp copy
                    nameLength      //  input length
                    );
    }

    return  0;
}



INT
Dns_DowncaseNameLabel(
    OUT     PCHAR           pchResult,
    //OUT     PDWORD          pNameProperty,
    IN      PCHAR           pchLabel,
    IN      DWORD           cchLabel,
    IN      DWORD           dwFlag
    )
/*++

Routine Description:

    Create a downcased version of DNS name.

    This is UTF8 only routine for use by DNS server to
    validate and downcase label during node creation.

Arguments:

    pchResult -- resulting downcased label;
        MUST have MAX_LABEL_BUFFER_LENGTH

    //pNameProperty -- name properties of result
    //    ResultLength -- ptr to DWORD to recieve resulting length

    pchLabel -- ptr to label

    cchLabel -- count of bytes in label

    dwFlag -- flag indicating what names are acceptable
        strict RFC      => DNS_ALLOW_RFC_NAMES_ONLY
        non RFC names   => DNS_ALLOW_NONRFC_NAMES
        UTF8 extended   => DNS_ALLOW_MULTIBYTE_NAMES
        anything        => DNS_ALLOW_ALL_NAMES

Return Value:

    If extended name -- length of converted name.
    Zero if success.
    (-1) on error.

--*/
{
    UCHAR       ch;
    PUCHAR      pchout = pchResult;
    PUCHAR      pch = pchLabel;
    DWORD       count = cchLabel;
    DWORD       charProp;
    DWORD       trailCount = 0;
    DWORD       property = 0;


    DNSDBG( TRACE, (
        "Dns_DowncaseNameLabel( %.*s )\n"
        "\tflag = %08x\n",
        cchLabel,
        pchLabel,
        dwFlag ));

    if ( count == 0  ||  count > DNS_MAX_LABEL_LENGTH )
    {
        goto InvalidName;
    }

    //
    //  copy each character
    //      - downcasing upper case chars
    //      - detecting invalid chars (unprintable, blank, dot)
    //

    while ( count-- )
    {
        //  get next character and properties

        ch = *pch++;
        *pchout++ = ch;
        charProp = DnsCharPropertyTable[ ch ];

        //  trail count check
        //      check this first to avoid trail count check on all
        //      other char types
        //
        //  DEVNOTE:  note this screens binary labels

        if ( trailCount )
        {
            if ( (charProp & B_UTF8_TRAIL) )
            {
                trailCount--;
                continue;
            }

            DNSDBG( READ, (
                "ERROR:  Name failed trail count check at %c\n", ch ));
            property |= DNS_BIT_NAME_BINARY_LABEL;
        }

        //  full RFC
        //      - map upper case to lower case
        //      - continue

        if ( charProp & B_RFC )
        {
            if ( charProp & B_UPPER )
            {
                --pchout;
                *pchout++ = ch + 0x20;
            }
            continue;
        }

        //
        //  check for extended chars
        //      - trail characters should have been caught above
        //      - doing this first so can make single trailCount
        //      check for all other ASCII chars

        if ( ch >= 0x80 )
        {
            DWORD tempStatus;
            tempStatus = Dns_ValidateUtf8Byte(
                            ch,
                            & trailCount );
            if ( tempStatus != ERROR_SUCCESS )
            {
                DNSDBG( READ, (
                    "ERROR:  Name UTF8 trail count check at %c\n", ch ));
                goto InvalidName;
            }
            property |= DNS_BIT_NAME_MULTIBYTE;
            continue;
        }

        //
        //  non-RFC
        //      - currently accepting only "_" as allowable as part of
        //      microsoft acceptable non-RFC set
        //
        //      however DNS server must be able to read *, \, etc
        //      as these can be part of valid label
        //
        //  note, could tighten this up with special flag, but since
        //  this only speeds case with invalid chars, there's not much
        //  point;  underscore is likely to see significant use
        //

        //  underscore
        //      - can be valid as leading label as part of SRV domain name
        //      - otherwise non-RFC

        if ( ch == '_' )
        {
            if ( count == cchLabel - 1 )
            {
                continue;
            }
            property |= DNS_BIT_NAME_UNDERSCORE;
            continue;
        }

        //  backslash
        //      - used to denote classless in-addr domains
        //          must have leading and following chars
        //      - otherwise completely invalid

        else if ( ch == '/' )
        {
            if ( count != 0 && count != cchLabel-1 )
            {
                continue;
            }
        }

        //  asterisk
        //      - valid only as single-byte first label in wildcard name
        //      - otherwise completely invalid

        else if ( ch == '*' )
        {
            if ( count == 0 )
            {
                continue;
            }
        }

        //  anything else is complete junk
        //  currently only acceptable if allow binary labels
        //
        //  JENHANCE:  could break out non-RFC (printable\non)

        property |= DNS_BIT_NAME_BINARY_LABEL;
        DNSDBG( READ, ( "ERROR:  Name character %c failed check\n", ch ));
        continue;
    }

    //
    //  fill out name properties
    //
    //  JENHANCE:  full property fill out
    //
    //  currently only property we're returning is multibyte name issue
    //  as that's all the server needs to check
    //
    //  if save more properties then test becomes something like this
    //  if ( (property & dwFlags) != (property & SUPPORTED_CHECK_FLAGS) )
    //

#if 0
    //*pNameProperty = property;

    if ( (property & dwFlags) != property )
    {
        goto InvalidName;
    }

    if ( property & DNS_BIT_NAME_MULTIBYTE )
    {
        goto Extended;
    }
#endif

    //  standard RFC name -- skip the detail parsing

    if ( property == 0 )
    {
        goto Done;
    }

    //  other chars invalid unless allowing all

    if ( property & DNS_BIT_NAME_BINARY_LABEL )
    {
        if ( dwFlag != DNS_ALLOW_ALL_NAMES )
        {
            goto InvalidName;
        }
    }

    //  multibyte
    //      - do extended downcase if multibyte
    //      - do nothing if binary
    //      - for strict this is invalid

    if ( property & DNS_BIT_NAME_MULTIBYTE )
    {
        if ( dwFlag == DNS_ALLOW_MULTIBYTE_NAMES ||
            dwFlag == DNS_ALLOW_ALL_NAMES )
        {
            goto Extended;
        }
#if 0
        if ( dwFlag != DNS_BINARY_LABELS )
        {
            goto InvalidName;
        }
#endif
        goto InvalidName;
    }

    //  underscore valid unless completely strict

    if ( property & DNS_BIT_NAME_UNDERSCORE )
    {
        if ( dwFlag == DNS_ALLOW_RFC_NAMES_ONLY )
        {
            goto InvalidName;
        }
    }

Done:

    //
    //  NULL terminate, return success.
    //

    *pchout = 0;
    return( 0 );


Extended:

    //
    //  DCR:  better approach to extended names
    //      1) cannonicalize upfront
    //          - do whole name in one pass
    //          - no need to upcase here, similar to validateName() routine
    //      2) cannonicalize here
    //          - detect extended
    //          - cannonicalize here
    //          - single recursion into routine like validateName()
    //

    //
    //  extended character encountered
    //      - convert to unicode
    //      - downcase
    //      - convert back to UTF8
    //

    //
    //  DCR_PERF:  optimize for names where extended already downcased
    //
    //  DCR_PERF:  should wrap this code into UTF8 cannon routine
    //


    //if ( ! (dwFlags & DNS_ALLOW_ALREADY_EXTENDED_DOWN) )
    {
        DWORD   length;
        WCHAR   unicodeString[ DNS_MAX_LABEL_BUFFER_LENGTH ];

        DNSDBG( READ, (
            "Extended character encountered downcasing string %*.s\n"
            "\tconverting to unicode for case conversion\n",
            cchLabel,
            pchLabel ));

        length = Dns_Utf8ToUnicode(
                     pchResult,
                     cchLabel,
                     unicodeString,
                     DNS_MAX_LABEL_BUFFER_LENGTH
                     );
        if ( length == 0 )
        {
            DNSDBG( READ, (
                "Rejecting invalid UTF8 string %.*s\n"
                "\tFailed conversion to unicode OR conversion created\n"
                "\tinvalid unicode string\n",
                cchLabel,
                pchResult ));
            goto InvalidName;
        }
        DNSDBG( READ, (
            "Unicode converted string %.*S\n"
            "\tlength = %d\n"
            "\tlast error = %d\n",
            length,
            unicodeString,
            length,
            GetLastError() ));

        //  no possible conversion of valid length UTF8, can
        //  overflow unicode buffer

        ASSERT( length <= DNS_MAX_LABEL_LENGTH );

        Dns_MakeCanonicalNameInPlaceW( unicodeString, length );
#if 1
        DNSDBG( READ, (
            "Canonical unicode name %.*S\n"
            "\tlength = %d\n",
            length,
            unicodeString,
            length ));
#endif

        //
        //  reconvert to UTF8
        //      - mapping to UTF8 is just math, so only error
        //      is possibly overflowing UTF8 max label buffer
        //      - catch this error is character count changes
        //      note, that also must catch case where write fills
        //      64 byte buffer eliminating NULL terminator
        //

        length = Dns_UnicodeToUtf8(
                     unicodeString,
                     length,
                     pchResult,
                     DNS_MAX_LABEL_BUFFER_LENGTH
                     );
        DNSDBG( READ, (
            "UTF8 downcased string %.*s\n"
            "\tlength = %d\n",
            length,
            pchResult,
            length ));

        if ( length != cchLabel )
        {
            DNSDBG( ANY, (
                "Downcasing UTF8 label %.*s, changed character count!\n"
                "\tfrom %d to %d\n"
                "\tResult name %.*s\n"
                "\tlast error = %d\n",
                cchLabel,
                pchLabel,
                cchLabel,
                length,
                length,
                pchResult,
                GetLastError() ));

            if ( length == 0 || length > DNS_MAX_LABEL_LENGTH )
            {
                DNSDBG( ANY, (
                    "Failed conversion of downcased unicode string %S\n"
                    "\tback into UTF8.\n",
                    unicodeString ));
                goto InvalidName;
            }
        }

        //
        //  NULL terminate, return length to indicate extended name
        //

        pchResult[ length ] = 0;
        return( (INT)length );
    }

    // no UTF8 multi-byte allowed -- drop through to invalid name return


InvalidName:

    //  return (-1) for error

    DNSDBG( READ, (
        "Dns_DowncaseNameLabel() found label to be invalid.\n"
        "\tlabel        = %.*s\n"
        "\tcount        = %d\n"
        "\tproperty     = %08x\n",
        cchLabel,
        pchLabel,
        count,
        property ));

    return( -1 );
}



LPSTR
Dns_CreateStandardDnsNameCopy(
    IN      PCHAR           pchName,
    IN      DWORD           cchName,
    IN      DWORD           dwFlag
    )
/*++

Routine Description:

    Makes copy of DNS name in valid "standard form"
        - downcased
        - no trailing dot (to avoid confusing DS)

Arguments:

    pchName -- ptr DNS name in UTF8

    cchName -- count of chars in name;  may be NULL

    dwFlag  -- strict checking flags;  currently ignored

Return Value:

    Ptr to copy of DNS name.
    NULL on invalid name.

--*/
{
    PCHAR       pszcopy = NULL;
    DNS_STATUS  status;
    DWORD       length;

    DNSDBG( TRACE, ( "Dns_CreateStandardDnsName()\n" ));
    DNSDBG( READ, (
        "Dns_CreateStandardDnsName()\n"
        "\tpchName = %.*s\n"
        "\tcchName = %d\n",
        cchName,
        pchName,
        cchName ));

    if ( !pchName )
    {
        status = ERROR_INVALID_NAME;
        goto Failed;
    }

    //
    //  ASCII string?
    //

    if ( Dns_IsStringAsciiEx( pchName, cchName ) )
    {
        //
        //  make copy
        //

        pszcopy = Dns_CreateStringCopy( pchName, cchName );
        if ( !pszcopy )
        {
            status = DNS_ERROR_NO_MEMORY;
            goto Failed;
        }

        //
        //  validate, check against strict criteria
        //
        //  no validation until relax criteria
        //
        //  DCR:  name validation within Dns_CreateStandardNameCopy()
        //      accept anything except INVALID_NAME
        //      flags return FQDN info
        //
#if 0
        status = Dns_ValidateName_UTF8( pszcopy, DnsNameDomain );
        if ( status == ERROR_INVALID_NAME )
        {
            goto Failed;
        }
#endif
        //
        //  downcase
        //  remove any trailing dot, except for root name
        //

        _strlwr( pszcopy );
        length = strlen( pszcopy );
        if ( length == 0 )
        {
            status = ERROR_INVALID_NAME;
            goto Failed;
        }
        length--;
        if ( length > 0 && pszcopy[length] == '.' )
        {
            pszcopy[length] = 0;
        }

        DNSDBG( READ, (
            "Standard DNS name copy of %.*s is %s\n",
            cchName,
            pchName,
            pszcopy ));
        return( pszcopy );
    }

    //
    //  unicode name
    //

    else
    {
        WCHAR   unicodeName[ DNS_MAX_NAME_BUFFER_LENGTH ];
        WCHAR   cannonicalName[ DNS_MAX_NAME_BUFFER_LENGTH ];
        DWORD   unicodeBufferLength;

        //
        //  convert to unicode
        //      - buf length is in bytes
        //

        unicodeBufferLength = DNS_MAX_NAME_BUFFER_LENGTH * 2;

        length = Dns_NameCopy(
                    (PSTR) unicodeName,
                    & unicodeBufferLength,
                    pchName,
                    cchName,
                    DnsCharSetUtf8,
                    DnsCharSetUnicode
                    );
        if ( length == 0 )
        {
            DNSDBG( ANY, (
                "ERROR conversion of name %.*s to unicode failed!\n",
                cchName,
                pchName ));
            status = ERROR_INVALID_NAME;
            goto Failed;
        }

        //
        //  make cannonical name
        //      - buf length is in unicode characters
        //      - output length is in unicode chars

        length = Dns_MakeCanonicalNameW(
                    cannonicalName,
                    length / 2,
                    unicodeName,
                    dwFlag );

        ASSERT( length != 0 );
        if ( length == 0 )
        {
            status = ERROR_INVALID_NAME;
            goto Failed;
        }

        //
        //  allocate UTF8 converted copy
        //      - this conversion should never fail
        //      - string length is unicode chars
        //

        pszcopy = Dns_StringCopyAllocate(
                    (PSTR) cannonicalName,
                    length,
                    DnsCharSetUnicode,      // unicode in
                    DnsCharSetUtf8          // UTF8 out
                    );
        if ( !pszcopy )
        {
            status = DNS_ERROR_NO_MEMORY;
            goto Failed;
        }

        //
        //  validate, check against strict criteria
        //
        //  no validation until relax criteria
        //
        //  DCR:  name validation within Dns_CreateStandardNameCopy()
        //      accept anything except INVALID_NAME
        //      flags return FQDN info
        //
#if 0
        status = Dns_ValidateName_UTF8( pszcopy, DnsNameDomain );
        if ( status == ERROR_INVALID_NAME )
        {
            goto Failed;
        }
#endif
        return( pszcopy );
    }

Failed:

    FREE_HEAP( pszcopy );
    SetLastError( status );
    return( NULL );
}



//
//  Public compare functions
//

BOOL
Dns_NameCompare_A(
    IN      PCSTR           pName1,
    IN      PCSTR           pName2
    )
/*++

Routine Description:

    Compare two DNS names.

    Can not use stricmp() because of the possiblity of names with
    trailing dots.

Arguments:

    pName1 - ptr to first DNS name string (dotted format)
    pName2 - ptr to second DNS name string (dotted format)

Return Value:

    TRUE if names equal.
    FALSE otherwise.

--*/
{
    INT len1;
    INT len2;
    INT result;

    //
    //  flat out match
    //      - this is possible with owner names and possibly other fields
    //

    if ( pName1 == pName2 )
    {
        return( TRUE );
    }

    if ( !pName1 || !pName2 )
    {
        return( FALSE );
    }

    //
    //  if lengths NOT equal, then
    //  they must be within one and longer string must have trailing dot
    //      - in this case save
    //

    len1 = strlen( pName1 );
    len2 = strlen( pName2 );

    if ( len2 != len1 )
    {
        if ( len2 == len1+1 )
        {
            if ( pName2[len1] != '.' )
            {
                return( FALSE );
            }
            //  len1 is comparable length
        }
        else if ( len2+1 == len1 )
        {
            if ( pName1[len2] != '.' )
            {
                return( FALSE );
            }
            //  len1 is set to comparable length
            len1 = len2;
        }
        else
        {
            return( FALSE );
        }
    }

    //
    //  compare only comparable length of string
    //

    result = CompareStringA(
                //LOCALE_SYSTEM_DEFAULT,
                DNS_CANONICAL_LOCALE,
                DNS_CANONICAL_COMPARE_FLAGS,
                pName1,
                len1,
                pName2,
                len1 );

    if ( result == CSTR_EQUAL )
    {
        return( TRUE );
    }

    //  not equal or error

    return( FALSE );
}



BOOL
Dns_NameCompare_W(
    IN      PCWSTR          pName1,
    IN      PCWSTR          pName2
    )
/*++

Routine Description:

    Compare two (Wide) DNS names.

    Note:  this is unicode aware, it assumes names in WCHAR string
    format. Can not use stricmp() because of the possiblity of names
    with trailing dots.

Arguments:

    pName1 - ptr to first DNS name string (dotted format)
    pName2 - ptr to second DNS name string (dotted format)

Return Value:

    TRUE if names equal.
    FALSE otherwise.

--*/
{
    INT len1;
    INT len2;
    INT result;

    //
    //  flat out match
    //      - this is possible with owner names and possibly other fields
    //

    if ( pName1 == pName2 )
    {
        return( TRUE );
    }

    if ( !pName1 || !pName2 )
    {
        return( FALSE );
    }

    //
    //  if lengths NOT equal, then
    //  they must be within one and longer string must have trailing dot
    //      - in this case save
    //

    len1 = wcslen( pName1 );
    len2 = wcslen( pName2 );

    if ( len2 != len1 )
    {
        if ( len2 == len1+1 )
        {
            if ( pName2[len1] != L'.' )
            {
                return( FALSE );
            }
            //  len1 is comparable length
        }
        else if ( len2+1 == len1 )
        {
            if ( pName1[len2] != L'.' )
            {
                return( FALSE );
            }
            //  len1 is set to comparable length
            len1 = len2;
        }
        else
        {
            return( FALSE );
        }
    }

    //
    //  compare only comparable length of string
    //

#if DNSWIN95
    //
    //  Win9x does not currently support CompareStringW()
    //

    if ( Dns_IsWin9x() )
    {
        return( !_wcsnicmp( pName1, pName2, len1 ) );
    }
#endif

    result = CompareStringW(
                //LOCALE_SYSTEM_DEFAULT,
                DNS_CANONICAL_LOCALE,
                DNS_CANONICAL_COMPARE_FLAGS,
                pName1,
                len1,
                pName2,
                len1 );

    if ( result == CSTR_EQUAL )
    {
        return( TRUE );
    }

    //  not equal or error

    return( FALSE );
}



BOOL
Dns_NameCompare_UTF8(
    IN      PCSTR           pName1,
    IN      PCSTR           pName2
    )
/*++

Routine Description:

    Compare two DNS names.

Arguments:

    pName1 - ptr to first DNS name string (dotted format)
    pName2 - ptr to second DNS name string (dotted format)

Return Value:

    TRUE if names equal.
    FALSE otherwise.

--*/
{
    WCHAR   nameBuffer1[ DNS_MAX_NAME_BUFFER_LENGTH ];
    WCHAR   nameBuffer2[ DNS_MAX_NAME_BUFFER_LENGTH ];
    DWORD   bufLen;

    //
    //  flat out match
    //      - this is possible with owner names and possibly other fields
    //

    if ( pName1 == pName2 )
    {
        return( TRUE );
    }

    if ( !pName1 || !pName2 )
    {
        return( FALSE );
    }

    //
    //  if strings pure ASCII, then use ANSI version
    //

    if ( Dns_IsStringAscii( (PCHAR)pName1 ) &&
         Dns_IsStringAscii( (PCHAR)pName2 ) )
    {
        return Dns_NameCompare_A( pName1, pName2 );
    }

    //
    //  otherwise must take names back to unicode to compare
    //

    bufLen = DNS_MAX_NAME_LENGTH;

    if ( ! Dns_NameCopy(
                (PCHAR) nameBuffer1,
                & bufLen,
                (PCHAR) pName1,
                0,              // length unknown
                DnsCharSetUtf8,
                DnsCharSetUnicode
                ) )
    {
        return( FALSE );
    }

    bufLen = DNS_MAX_NAME_LENGTH;

    if ( ! Dns_NameCopy(
                (PCHAR) nameBuffer2,
                & bufLen,
                (PCHAR) pName2,
                0,              // length unknown
                DnsCharSetUtf8,
                DnsCharSetUnicode
                ) )
    {
        return( FALSE );
    }

    return Dns_NameCompare_W( nameBuffer1, nameBuffer2 );
}



BOOL
Dns_NameComparePrivate(
    IN      PCSTR           pName1,
    IN      PCSTR           pName2,
    IN      DNS_CHARSET     CharSet
    )
/*++

Routine Description:

    Compare two DNS names.

    This is simply helpful utility to avoid coding the wide\narrow
    test in the code in a hundred different places.

Arguments:

    pName1 - ptr to first DNS name string (dotted format)
    pName2 - ptr to second DNS name string (dotted format)

Return Value:

    TRUE if names equal.
    FALSE otherwise.

--*/
{
    if ( CharSet == DnsCharSetUnicode )
    {
        return Dns_NameCompare_W(
                    (PCWSTR) pName1,
                    (PCWSTR) pName2 );
    }
    else if ( CharSet == DnsCharSetAnsi )
    {
        return Dns_NameCompare_A(
                    pName1,
                    pName2 );
    }
    else
    {
        return Dns_NameCompare_UTF8(
                    pName1,
                    pName2 );
    }
}



//
//  Advanced name comparison
//  Includes hierarchial name relationship.
//

DNS_NAME_COMPARE_STATUS
Dns_NameCompareEx(
    IN      PCSTR           pszNameLeft,
    IN      PCSTR           pszNameRight,
    IN      DWORD           dwReserved,
    IN      DNS_CHARSET     CharSet
    )
/*++

Routine Description:

    Advanced compare of DNS names, including hierarchial relationship.

Arguments:

    pszNameLeft -- left name

    pszNameRight -- right name

    dwReserved -- reserved for future use (type of comparison)

    CharSet -- char set of names

Return Value:

    DnsNameCompareInvalid       -- one of the names was invalid
    DnsNameCompareEqual         -- names are equal
    DnsNameCompareLeftParent    -- left is ancestor of right name
    DnsNameCompareRightParent   -- right is ancestor of left name
    DnsNameCompareNotEqual      -- name not equal, no hierarchial relationship

--*/
{
    DNS_NAME_COMPARE_STATUS result;
    DNS_STATUS  status;
    INT         lengthLeft;
    INT         lengthRight;
    INT         lengthDiff;
    INT         compareResult;
    DWORD       bufLength;
    WCHAR       nameLeft[ DNS_MAX_NAME_BUFFER_LENGTH ];
    WCHAR       nameRight[ DNS_MAX_NAME_BUFFER_LENGTH ];


    DNSDBG( TRACE, (
        "Dns_NameCompareEx( %s%S, %s%S )\n",
        (CharSet==DnsCharSetUnicode) ? "" : pszNameLeft,
        (CharSet==DnsCharSetUnicode) ? pszNameLeft : "",
        (CharSet==DnsCharSetUnicode) ? "" : pszNameRight,
        (CharSet==DnsCharSetUnicode) ? pszNameRight : ""
        ));

    //
    //  implementation note
    //  there's a lot of inefficiency here, because there are
    //  two different character sets required for
    //      validation -- UTF8 to check packet limits
    //      downcasing\comparison -- unicode for case insensitivity
    //
    //  obviously there are much more efficient paths through this
    //  morass for particular special cases (ASCII names:  downcase
    //  in ANSI, validate, compare);  but since this is not perf
    //  path code we'll take the approach
    //      - convert to unicode
    //      - validate (which will convert at copy to UTF8)
    //      - downcase unicode
    //      - compare unicode
    //

    //
    //  validate args
    //

    if ( ! pszNameLeft || ! pszNameRight )
    {
         goto Invalid;
    }

    //
    //  copy convert to unicode
    //      - downcasing and compare will be done in unicode
    //      - return lengths are bytes converted, convert to string lengths
    //      - Dns_NameCopy() returns zero for invalid convert
    //

    bufLength = DNS_MAX_NAME_BUFFER_LENGTH * 2;

    lengthLeft = (INT) Dns_NameCopy(
                            (PCHAR) nameLeft,
                            & bufLength,
                            (LPSTR) pszNameLeft,
                            0,                     // string NULL terminated
                            CharSet,               // char set in
                            DnsCharSetUnicode      // unicode out
                            );
    if ( lengthLeft == 0 )
    {
        goto Invalid;
    }
    lengthLeft = (lengthLeft/2) - 1;
    ASSERT( lengthLeft >= 0 );

    bufLength = DNS_MAX_NAME_BUFFER_LENGTH * 2;

    lengthRight = (INT) Dns_NameCopy(
                            (PCHAR) nameRight,
                            & bufLength,
                            (LPSTR) pszNameRight,
                            0,                     // string NULL terminated
                            CharSet,               // char set in
                            DnsCharSetUnicode      // unicode out
                            );
    if ( lengthRight == 0 )
    {
        goto Invalid;
    }
    lengthRight = (lengthRight/2) - 1;
    ASSERT( lengthRight >= 0 );

    //
    //  cannonicalize names
    //

    Dns_MakeCanonicalNameInPlaceW( nameLeft, lengthLeft );
    Dns_MakeCanonicalNameInPlaceW( nameRight, lengthRight );

    //
    //  validate names
    //      - must screen empty string or we can fault below
    //

    status = Dns_ValidateName_W( nameLeft, DnsNameDomain );
    if ( ERROR_SUCCESS != status &&
         DNS_ERROR_NON_RFC_NAME != status )
    {
        goto Invalid;
    }

    status = Dns_ValidateName_W( nameRight, DnsNameDomain );
    if ( ERROR_SUCCESS != status &&
         DNS_ERROR_NON_RFC_NAME != status )
    {
        goto Invalid;
    }

    //
    //  add trailing dots
    //
    //  we need to either add or remove trailing dots to make comparisons
    //  the advantage of adding them is that then, the root name does
    //  not require any special casing -- the root is the ancestor of
    //  every name
    //

    if ( nameLeft[ lengthLeft-1 ] != (WORD)'.')
    {
        nameLeft[ lengthLeft++ ]    = (WORD) '.';
        nameLeft[ lengthLeft ]      = (WORD) 0;
    }
    if ( nameRight[ lengthRight-1 ] != (WORD)'.')
    {
        nameRight[ lengthRight++ ]  = (WORD) '.';
        nameRight[ lengthRight ]    = (WORD) 0;
    }

    //
    //  compare equal length strings
    //

    result = DnsNameCompareNotEqual;

    lengthDiff = (INT)lengthLeft - (INT)lengthRight;

    if ( lengthLeft == lengthRight )
    {
        compareResult = wcscmp( nameLeft, nameRight );
        if ( compareResult == 0 )
        {
            result = DnsNameCompareEqual;
        }
        goto Done;
    }

    //
    //  strings not equal
    //      - compare smaller string of length X
    //      to last X characters of larger string
    //      - also must make sure starting at label boundary
    //
    //      note: strstr() is NOT useful for this work, because it
    //      compares useless for this work because it is finding the
    //      first match -- a little thought would indicate that this
    //      will fail in several obvious cases
    //

    //  right string longer
    //      - need to sign change diff to make it offset in right string

    else if ( lengthDiff < 0 )
    {
        lengthDiff = -lengthDiff;

        if ( nameRight[ lengthDiff-1 ] != L'.' )
        {
            goto Done;
        }
        compareResult = wcscmp( nameLeft, nameRight+lengthDiff );
        if ( compareResult == 0 )
        {
            result = DnsNameCompareLeftParent;
        }
        goto Done;
    }

    //  left string longer
    //      - lengthDiff is offset into left string to start compare

    else
    {
        if ( nameLeft[ lengthDiff-1 ] != L'.' )
        {
            goto Done;
        }
        compareResult = wcscmp( nameLeft+lengthDiff, nameRight );
        if ( compareResult == 0 )
        {
            result = DnsNameCompareRightParent;
        }
        goto Done;
    }

Done:

    DNSDBG( TRACE, (
        "Leave DnsNameCompareEx() result = %d\n",
        result ));

    return( result );

Invalid:

    DNSDBG( ANY, (
        "ERROR:  Invalid name to Dns_NameCompareEx()\n" ));

    return( DnsNameCompareInvalid );
}



//
//  Random name utilities
//

PCHAR
_fastcall
Dns_GetDomainNameA(
    IN      PCSTR           pszName
    )
/*++

Routine Description:

    Get domain name of DNS name.

    Note, this assumes name already in UTF-8

Arguments:

    pszName - standard dotted DNS name

Return Value:

    Ptr to domain name of pszName.
    NULL if pszName is in root domain.

--*/
{
    CHAR    ch;

    //
    //  find next "." in name, then return ptr to next character
    //

    while( ch = *pszName++ )
    {
        if ( ch == '.' )
        {
            if ( *pszName )
            {
                return( (PCHAR)pszName );
            }
            return( NULL );
        }
    }
    return( NULL );
}


PWSTR
_fastcall
Dns_GetDomainNameW(
    IN      PCWSTR          pwsName
    )
{
    PWSTR  pdomain;

    //
    //  find next "." in name, then return ptr to next character
    //

    pdomain = wcschr( pwsName, L'.' );

    if ( pdomain && *(++pdomain) )
    {
        return( pdomain );
    }
    return  NULL;
}



PSTR
_fastcall
Dns_GetTldForNameA(
    IN      PCSTR           pszName
    )
/*++

Routine Description:

    Get domain name of DNS name.

Arguments:

    pszName - standard dotted DNS name

Return Value:

    Ptr to domain name of pszName.
    NULL if pszName is in root domain.

--*/
{
    PSTR    pdomain = (PSTR) pszName;
    PSTR    ptld = NULL;

    //
    //  find last domain name in name
    //

    while ( pdomain = Dns_GetDomainNameA(pdomain) )
    {
        ptld = (PSTR) pdomain;
    }
    return  ptld;
}


PWSTR
_fastcall
Dns_GetTldForNameW(
    IN      PCWSTR          pszName
    )
{
    PWSTR   pdomain = (PWSTR) pszName;
    PWSTR   ptld = NULL;

    //
    //  find last domain name in name
    //

    while ( pdomain = Dns_GetDomainNameW(pdomain) )
    {
        ptld = pdomain;
    }
    return  ptld;
}




BOOL
_fastcall
Dns_IsNameShortA(
    IN      PCSTR           pszName
    )
/*++

Routine Description:

    Determine if a name is a multi-label DNS name.

    This is a test of whether name at least one non-terminal dot.

Arguments:

    pszName - standard dotted DNS name

Return Value:

    TRUE if multiple labels.
    FALSE otherwise.

--*/
{
    INT     nameLen;

    //  trailing domain? -- done

    if ( Dns_GetDomainNameA( pszName ) )
    {
        return  FALSE;
    }

    //  otherwise test for valid label

    nameLen = strlen( pszName );
    if ( nameLen <= DNS_MAX_LABEL_LENGTH )
    {
        return  TRUE;
    }
    nameLen--;
    if ( nameLen == DNS_MAX_LABEL_LENGTH &&
         pszName[nameLen] == '.')
    {
        return  TRUE; 
    }
    return  FALSE;
}


BOOL
_fastcall
Dns_IsNameShortW(
    IN      PCWSTR          pszName
    )
{
    INT     nameLen;

    //  trailing domain? -- done

    if ( Dns_GetDomainNameW( pszName ) )
    {
        return  FALSE;
    }

    //  otherwise test for valid label

    nameLen = wcslen( pszName );
    if ( nameLen <= DNS_MAX_LABEL_LENGTH )
    {
        return  TRUE;
    }
    nameLen--;
    if ( nameLen == DNS_MAX_LABEL_LENGTH &&
         pszName[nameLen] == L'.')
    {
        return  TRUE; 
    }
    return  FALSE;
}



BOOL
_fastcall
Dns_IsNameNumericA(
    IN      PCSTR           pszName
    )
/*++

Routine Description:

    Determine if numeric name.

    Note, this assumes name already in UTF-8

Arguments:

    pszName - standard dotted DNS name

Return Value:

    TRUE if all numeric.
    FALSE otherwise.

--*/
{
    CHAR    ch;
    BOOL    fnumeric = FALSE;

    //
    //  check if everything in name is numeric
    //      - dotted names can be numeric
    //      - "." not numeric
    //

    while( ch = *pszName++ )
    {
        if ( ch >= '0' && ch <= '9' )
        {
            fnumeric = TRUE;
            continue;
        }
        else if ( ch == '.' )
        {
            continue;
        }
        return  FALSE;
    }

    return  fnumeric;
}


BOOL
_fastcall
Dns_IsNameNumericW(
    IN      PCWSTR          pszName
    )
{
    WCHAR   ch;
    BOOL    fnumeric = FALSE;

    //
    //  check if everything in name is numeric
    //      - dotted names can be numeric
    //      - "." not numeric
    //

    while( ch = *pszName++ )
    {
        if ( ch >= '0' && ch <= '9' )
        {
            fnumeric = TRUE;
            continue;
        }
        else if ( ch == '.' )
        {
            continue;
        }
        return  FALSE;
    }

    return  fnumeric;
}



BOOL
_fastcall
Dns_IsNameFQDN_A(
    IN      PCSTR           pszName
    )
/*++

Routine Description:

    Determine if a name is a fully qualified DNS name (FQDN).

    This is a test of whether name has trailing dot.

Arguments:

    pszName - standard dotted DNS name

Return Value:

    TRUE if FQDN.
    FALSE otherwise.

--*/
{
    DWORD nameLen = strlen( pszName );

    if ( nameLen == 0 )
    {
        return FALSE;
    }

    if ( pszName[nameLen - 1] == '.' )
    {
        return TRUE;
    }
    else
    {
        return FALSE;
    }
}


BOOL
_fastcall
Dns_IsNameFQDN_W(
    IN      PCWSTR          pszName
    )
{
    DWORD nameLen = wcslen( pszName );

    if ( nameLen == 0 )
    {
        return FALSE;
    }

    if ( pszName[nameLen - 1] == L'.' )
    {
        return TRUE;
    }
    else
    {
        return FALSE;
    }
}



DWORD
_fastcall
Dns_GetNameAttributesA(
    IN      PCSTR           pszName
    )
/*++

Routine Description:

    Determine the attributes that a name has.

    Note, this assumes name already in UTF-8

Arguments:

    pszName - standard dotted DNS name

Return Value:

    DWORD with possible flags:

    DNS_NAME_IS_FQDN
    DNS_NAME_SINGLE_LABEL
    DNS_NAME_MULTI_LABEL

--*/
{
    DWORD attributes = DNS_NAME_UNKNOWN;

    if ( Dns_IsNameFQDN_A( pszName ) )
    {
        attributes = DNS_NAME_IS_FQDN;
    }

    if ( Dns_IsNameShortA( pszName ) )
    {
        attributes |= DNS_NAME_SINGLE_LABEL;
    }
    else
    {
        attributes |= DNS_NAME_MULTI_LABEL;
    }

    return attributes;
}


DWORD
_fastcall
Dns_GetNameAttributesW(
    IN      PCWSTR          pszName
    )
{
    DWORD   attributes = DNS_NAME_UNKNOWN;

    if ( Dns_IsNameFQDN_W( pszName ) )
    {
        attributes = DNS_NAME_IS_FQDN;
    }

    if ( Dns_IsNameShortW( pszName ) )
    {
        attributes |= DNS_NAME_SINGLE_LABEL;
    }
    else
    {
        attributes |= DNS_NAME_MULTI_LABEL;
    }

    return attributes;
}



DNS_STATUS
Dns_ValidateAndCategorizeDnsNameEx(
    IN      PCHAR           pchName,
    IN      DWORD           cchNameLength,
    OUT     PDWORD          pLabelCount
    )
/*++

Routine Description:

    Determine type of name.

    Three types:
        1) FQDN -- dot on end, signifies full DNS name, never appended

        2) dotted -- dot in name;  probably FQDN, but may need to be appended
            (as in file store)

        3) single part -- single part name (not FQDN), always appended with zone
            or default domain name

Arguments:

    pchName         -- ptr to name

    cchNameLength   -- name length

    pLabelCount     -- address to receive label count

Return Value:

    DNS_STATUS_FQDN
    DNS_STATUS_DOTTED_NAME
    DNS_STATUS_SINGLE_PART_NAME
    DNS_ERROR_INVALID_NAME on non-DNS name

--*/
{
    register PCHAR  pch;
    register CHAR   ch;
    PCHAR           pchstop;
    BOOL            fdotted = FALSE;
    DWORD           labelCount = 0;
    DWORD           charCount = 0;
    DNS_STATUS      status = DNS_STATUS_SINGLE_PART_NAME;

    //
    //  name length for string
    //

    if ( cchNameLength == 0 )
    {
        cchNameLength = strlen( pchName );
    }
    if ( cchNameLength > DNS_MAX_NAME_LENGTH ||
         cchNameLength == 0 )
    {
        goto InvalidName;
    }

    //
    //  run through name
    //

    pch = pchName;
    pchstop = pch + cchNameLength;

    while ( pch < pchstop )
    {
        ch = *pch++;
        if ( ch == '.' )
        {
            if ( charCount > DNS_MAX_LABEL_LENGTH )
            {
                goto InvalidName;
            }
            if ( charCount > 0 )
            {
                labelCount++;
                charCount = 0;
                status = DNS_STATUS_DOTTED_NAME;
                continue;
            }
            else
            {
                //  only valid zero label name is "."
                if ( pch == pchstop &&
                     pch-1 == pchName )
                {
                    break;
                }
                goto InvalidName;
            }
        }
        else if ( ch == 0 )
        {
            DNS_ASSERT( FALSE );
            break;
        }

        //  regular character
        charCount++;
    }

    //
    //  handle last label
    //      - if count, then boost label count
    //      - if zero and previously had dot, then string
    //          ended in dot and is FQDN
    //

    if ( charCount > 0 )
    {
        if ( charCount > DNS_MAX_LABEL_LENGTH )
        {
            goto InvalidName;
        }
        labelCount++;
    }
    else if ( status == DNS_STATUS_DOTTED_NAME )
    {
        status = DNS_STATUS_FQDN;
    }

    //  return label count

    if ( pLabelCount )
    {
        *pLabelCount = labelCount;
    }

    DNSDBG( TRACE, (
        "Leave Dns_ValidateAndCategorizeNameEx()\n"
        "\tstatus       = %d\n"
        "\tlabel count  = %d\n",
        status,
        labelCount ));

    return( status );


InvalidName:

    if ( pLabelCount )
    {
        *pLabelCount = 0;
    }

    DNSDBG( TRACE, (
        "Leave Dns_ValidateAndCategorizeNameEx()\n"
        "\tstatus = ERROR_INVALID_NAME\n" ));

    return( DNS_ERROR_INVALID_NAME );
}



DNS_STATUS
Dns_ValidateAndCategorizeDnsNameA(
    IN      PCSTR           pszName,
    OUT     PDWORD          pLabelCount
    )
/*++

Routine Description:

    Determine type of name.

    Three types:
        1) FQDN -- dot on end, signifies full DNS name, never appended

        2) dotted -- dot in name;  probably FQDN, but may need to be appended
            (as in file store)

        3) single part -- single part name (not FQDN), always appended with zone
            or default domain name

Arguments:

    pszName         -- ptr to name

    pLabelCount     -- address to receive label count

Return Value:

    DNS_STATUS_FQDN
    DNS_STATUS_DOTTED_NAME
    DNS_STATUS_SINGLE_PART_NAME
    DNS_ERROR_INVALID_NAME on non-DNS name

--*/
{
    //
    //  call real function
    //

    return  Dns_ValidateAndCategorizeDnsNameEx(
                (PCHAR) pszName,
                0,          // NULL terminated
                pLabelCount );
}



DNS_STATUS
Dns_ValidateAndCategorizeDnsNameW(
    IN      PCWSTR          pszName,
    OUT     PDWORD          pLabelCount
    )
/*++

Routine Description:

    Determine type of name.

    Three types:
        1) FQDN -- dot on end, signifies full DNS name, never appended

        2) dotted -- dot in name;  probably FQDN, but may need to be appended
            (as in file store)

        3) single part -- single part name (not FQDN), always appended with zone
            or default domain name

Arguments:

    pszName         -- ptr to name

    pLabelCount     -- address to receive label count

Return Value:

    DNS_STATUS_FQDN
    DNS_STATUS_DOTTED_NAME
    DNS_STATUS_SINGLE_PART_NAME
    DNS_ERROR_INVALID_NAME on non-DNS name

--*/
{
    register PWCHAR pch;
    register WCHAR  ch;
    PWCHAR          pchstop;
    BOOL            fdotted = FALSE;
    DWORD           nameLength;
    DWORD           labelCount = 0;
    DWORD           charCount = 0;
    DNS_STATUS      status = DNS_STATUS_SINGLE_PART_NAME;

    //
    //  name length for string
    //

    nameLength = wcslen( pszName );

    if ( nameLength > DNS_MAX_NAME_LENGTH ||
         nameLength == 0 )
    {
        goto InvalidName;
    }

    //
    //  run through name
    //

    pch = (PWSTR) pszName;
    pchstop = pch + nameLength;

    while ( pch < pchstop )
    {
        ch = *pch++;
        if ( ch == L'.' )
        {
            if ( charCount > DNS_MAX_LABEL_LENGTH )
            {
                goto InvalidName;
            }
            if ( charCount > 0 )
            {
                labelCount++;
                charCount = 0;
                status = DNS_STATUS_DOTTED_NAME;
                continue;
            }
            else
            {
                //  only valid zero label name is "."
                if ( pch == pchstop &&
                     pch-1 == pszName )
                {
                    break;
                }
                goto InvalidName;
            }
        }
        else if ( ch == 0 )
        {
            DNS_ASSERT( FALSE );
            break;
        }

        //  regular character
        charCount++;
    }

    //
    //  handle last label
    //      - if count, then boost label count
    //      - if zero and previously had dot, then string
    //          ended in dot and is FQDN
    //

    if ( charCount > 0 )
    {
        if ( charCount > DNS_MAX_LABEL_LENGTH )
        {
            goto InvalidName;
        }
        labelCount++;
    }
    else if ( status == DNS_STATUS_DOTTED_NAME )
    {
        status = DNS_STATUS_FQDN;
    }

    //  return label count

    if ( pLabelCount )
    {
        *pLabelCount = labelCount;
    }

    DNSDBG( TRACE, (
        "Leave Dns_ValidateAndCategorizeNameW()\n"
        "\tstatus       = %d\n"
        "\tlabel count  = %d\n",
        status,
        labelCount ));

    return( status );


InvalidName:

    if ( pLabelCount )
    {
        *pLabelCount = 0;
    }

    DNSDBG( TRACE, (
        "Leave Dns_ValidateAndCategorizeNameW()\n"
        "\tstatus = ERROR_INVALID_NAME\n" ));

    return( DNS_ERROR_INVALID_NAME );
}



DWORD
Dns_NameLabelCountA(
    IN      PCSTR           pszName
    )
/*++

Routine Description:

    Return name label count.

Arguments:

    pszName -- ptr to name

Return Value:

    Label count if valid name.
    Zero on root name or error.

--*/
{
    DWORD       labelCount = 0;
    DNS_STATUS  status;

    //
    //  call real routine
    //

    status = Dns_ValidateAndCategorizeDnsNameEx(
                    (PCHAR) pszName,
                    0,
                    & labelCount );

    if ( status == DNS_ERROR_INVALID_NAME )
    {
        labelCount = 0;
    }

    return( labelCount );
}



DWORD
Dns_NameLabelCountW(
    IN      PCWSTR          pszName
    )
/*++

Routine Description:

    Return name label count.

Arguments:

    pszName -- ptr to name

Return Value:

    Label count if valid name.
    Zero on root name or error.

--*/
{
    DWORD       labelCount = 0;
    DNS_STATUS  status;

    //
    //  call real routine
    //

    status = Dns_ValidateAndCategorizeDnsNameW(
                    pszName,
                    & labelCount );

    if ( status == DNS_ERROR_INVALID_NAME )
    {
        labelCount = 0;
    }

    return( labelCount );
}



PSTR
Dns_NameAppend_A(
    OUT     PCHAR           pNameBuffer,
    IN      DWORD           BufferLength,
    IN      PSTR            pszName,
    IN      PSTR            pszDomain
    )
/*++

Routine Description:

    Write appended name to buffer (ANSI or UTF8).

Arguments:

    pNameBuffer -- name buffer to write to

    BufferLength -- buffer length

    pszName -- name to append domain to

    pszDomain -- domain name

Return Value:

    Ptr to buffer with appended domain name.
    NULL on invalid (too long) name.

--*/
{
    DWORD   length1;
    DWORD   length2;
    DWORD   totalLength;

    DNSDBG( TRACE, ( "Dns_NameAppend_A( %A, %A )\n", pszName, pszDomain ));

    //
    //  appending NULL domain?
    //

    if ( !pszDomain )
    {
        totalLength = strlen( pszName );
        if ( totalLength >= BufferLength )
        {
            return( NULL );
        }
        RtlCopyMemory(
            pNameBuffer,
            pszName,
            totalLength );

        pNameBuffer[ totalLength ] = 0;
    
        return( pNameBuffer );
    }

    //
    //  get name lengths -- make sure we fit length
    //

    length1 = strlen( pszName );
    if ( !length1 )
    {
        return  NULL;
    }
    if ( pszName[ length1-1] == '.' )
    {
        length1--;
    }

    length2 = strlen( pszDomain );
    
    totalLength = length1 + length2 + 1;
    if ( totalLength >= BufferLength )
    {
        return  NULL ;
    }

    //
    //  copy to buffer
    //

    RtlCopyMemory(
        pNameBuffer,
        pszName,
        length1 );

    pNameBuffer[ length1 ] = '.';

    RtlCopyMemory(
        & pNameBuffer[length1+1],
        pszDomain,
        length2 );

    pNameBuffer[ totalLength ] = 0;

    return( pNameBuffer );
}



PWSTR
Dns_NameAppend_W(
    OUT     PWCHAR          pNameBuffer,
    IN      DWORD           BufferLength,
    IN      PWSTR           pwsName,
    IN      PWSTR           pwsDomain
    )
/*++

Routine Description:

    Write appended name to buffer (unicode).

Arguments:

    pNameBuffer -- name buffer to write to

    BufferLength -- buffer length in WCHAR

    pwsName -- name to append domain to

    pwsDomain -- domain name

Return Value:

    Ptr to buffer with appended domain name.
    NULL on invalid (too long) name.

--*/
{
    DWORD   length1;
    DWORD   length2;
    DWORD   totalLength;

    DNSDBG( TRACE, ( "Dns_NameAppend_W( %S, %S )\n", pwsName, pwsDomain ));

    //
    //  appending NULL domain?
    //

    if ( !pwsDomain )
    {
        totalLength = wcslen( pwsName );
        if ( totalLength >= BufferLength )
        {
            return( NULL );
        }
        RtlCopyMemory(
            pNameBuffer,
            pwsName,
            totalLength*sizeof(WCHAR) );

        pNameBuffer[ totalLength ] = 0;
    
        return( pNameBuffer );
    }

    //
    //  get name lengths -- make sure we fit length
    //

    length1 = wcslen( pwsName );
    if ( !length1 )
    {
        return  NULL;
    }
    if ( pwsName[ length1-1] == L'.' )
    {
        length1--;
    }

    length2 = wcslen( pwsDomain );
    
    totalLength = length1 + length2 + 1;
    if ( totalLength >= BufferLength )
    {
        return( NULL );
    }

    //
    //  copy to buffer
    //

    RtlCopyMemory(
        pNameBuffer,
        pwsName,
        length1*sizeof(WCHAR) );

    pNameBuffer[ length1 ] = L'.';

    RtlCopyMemory(
        & pNameBuffer[length1+1],
        pwsDomain,
        length2*sizeof(WCHAR) );

    pNameBuffer[ totalLength ] = 0;

    return( pNameBuffer );
}



PSTR
Dns_SplitHostFromDomainNameA(
    IN      PSTR            pszName
    )
/*++

Routine Description:

    Split host name from domain name.

    Combines getting domain name and splitting
    off host name.

Arguments:

    pszName - standard dotted DNS name

Return Value:

    Ptr to domain name of pszName.
    NULL if pszName is in root domain.

--*/
{
    PSTR    pnameDomain;

    //
    //  get domain name
    //  if exists, NULL terminate host name part
    //

    pnameDomain = Dns_GetDomainNameA( (PCSTR)pszName );
    if ( pnameDomain )
    {
        if ( pnameDomain <= pszName )
        {
            return  NULL;
        }
        *(pnameDomain-1) = 0;
    }

    return  pnameDomain;
}


PWSTR
Dns_SplitHostFromDomainNameW(
    IN      PWSTR           pszName
    )
{
    PWSTR   pnameDomain;

    //
    //  get domain name
    //  if exists, NULL terminate host name part
    //

    pnameDomain = Dns_GetDomainNameW( (PCWSTR)pszName );
    if ( pnameDomain )
    {
        if ( pnameDomain <= pszName )
        {
            return  NULL;
        }
        *(pnameDomain-1) = 0;
    }

    return  pnameDomain;
}



BOOL
Dns_CopyNameLabelA(
    OUT     PCHAR           pBuffer,
    IN      PCSTR           pszName
    )
/*++

Routine Description:

    Copy first label in name.

Arguments:

    pBuffer - buffer to hold label copy;
        must be DNS_MAX_LABEL_BUFFER_LENGTH

    pszName - standard dotted DNS name

Return Value:

    TRUE on successful copy.
    FALSE on bad name.  Copy buffer will still be valid.

--*/
{
    CHAR    ch;
    PCHAR   plabel = pBuffer;
    PCHAR   pstop;
    BOOL    retval = TRUE;

    if ( !pszName )
    {
        retval = FALSE;
        goto Done;
    }
    pstop = plabel + DNS_MAX_LABEL_LENGTH;

    //
    //  find next "." in name, then return ptr to next character
    //

    while( ch = *pszName++ )
    {
        if ( ch == '.' )
        {
            if ( plabel == pBuffer )
            {
                *plabel++ = ch;
            }
            break;
        }
        if ( plabel >= pstop )
        {
            retval = FALSE;
            break;
        }
        *plabel++ = ch;
    }

Done:

    *plabel = 0;
    return( retval );
}


BOOL
Dns_CopyNameLabelW(
    OUT     PWCHAR          pBuffer,
    IN      PCWSTR          pszName
    )
{
    WCHAR   ch;
    PWCHAR  plabel = pBuffer;
    PWCHAR  pstop;
    BOOL    retval = TRUE;

    if ( !pszName )
    {
        retval = FALSE;
        goto Done;
    }
    pstop = plabel + DNS_MAX_LABEL_LENGTH;

    //
    //  find next "." in name, then return ptr to next character
    //

    while( ch = *pszName++ )
    {
        if ( ch == '.' )
        {
            if ( plabel == pBuffer )
            {
                *plabel++ = ch;
            }
            break;
        }
        if ( plabel >= pstop )
        {
            retval = FALSE;
            break;
        }
        *plabel++ = ch;
    }

Done:

    *plabel = 0;
    return( retval );
}



//
//  Wrappers for most common name conversions
//

DWORD
Dns_NameCopyWireToUnicode(
    OUT     PWCHAR          pBufferUnicode,
    IN      PCSTR           pszNameWire
    )
/*++

Routine Description:

    Convert name from wire to unicode.

    Simple wrapper on Dns_NameCopy for common operation:
        - unicode to wire
        - NULL terminated name
        - standard length buffer

Arguments:

    pBufferUnicode -- unicode result buffer

    pszNameWire - name in wire format

Return Value:

    Count of bytes copied if successful.
    Zero on error -- name too long or conversion error.

--*/
{
    DWORD   bufferLength = DNS_MAX_NAME_BUFFER_LENGTH_UNICODE;

    //
    //  copy name back to unicode
    //

    return Dns_NameCopy(
                (PCHAR) pBufferUnicode,
                & bufferLength,
                (PCHAR) pszNameWire,
                0,                      // null terminated
                DnsCharSetWire,
                DnsCharSetUnicode );
}



DWORD
Dns_NameCopyUnicodeToWire(
    OUT     PCHAR           pBufferWire,
    IN      PCWSTR          pwsNameUnicode
    )
/*++

Routine Description:

    Convert name from unicode to wire.

    Simple wrapper on Dns_NameCopy for common operation:
        - unicode to wire
        - NULL terminated name
        - standard length buffer

Arguments:

    pBufferWire -- wire format result buffer

    pwsNameUnicode - name in unicode

Return Value:


    Count of bytes copied if successful.
    Zero on error -- name too long or conversion error.

--*/
{
    DWORD   bufferLength = DNS_MAX_NAME_BUFFER_LENGTH;

    //
    //  copy name to wire format
    //

    return Dns_NameCopy(
                pBufferWire,
                & bufferLength,
                (PCHAR) pwsNameUnicode,
                0,                      // null terminated
                DnsCharSetUnicode,
                DnsCharSetWire );
}



DWORD
Dns_NameCopyStandard_W(
    OUT     PWCHAR          pBuffer,
    IN      PCWSTR          pwsNameUnicode
    )
/*++

Routine Description:

    Copy unicode name.

    Simple wrapper on Dns_NameCopy for common operation:
        - unicode to unicode
        - NULL terminated name
        - standard length buffer

Arguments:

    pBuffer -- wire format result buffer

    pwsNameUnicode - name in unicode

Return Value:

    Count of bytes copied if successful.
    Zero on error -- name too long or conversion error.

--*/
{
    DWORD   bufferLength = DNS_MAX_NAME_BUFFER_LENGTH_UNICODE;

    //
    //  copy name
    //

    return Dns_NameCopy(
                (PCHAR) pBuffer,
                & bufferLength,
                (PCHAR) pwsNameUnicode,
                0,                      // null terminated
                DnsCharSetUnicode,
                DnsCharSetUnicode );
}



DWORD
Dns_NameCopyStandard_A(
    OUT     PCHAR           pBuffer,
    IN      PCSTR           pszName
    )
/*++

Routine Description:

    Convert name from unicode to wire.

    Simple wrapper on Dns_NameCopy for common operation:
        - unicode to wire
        - NULL terminated name
        - standard length buffer

Arguments:

    pBuffer -- wire format result buffer

    pszName - name in narrow char set

Return Value:

    Count of bytes copied if successful.
    Zero on error -- name too long or conversion error.

--*/
{
    DWORD   bufferLength = DNS_MAX_NAME_BUFFER_LENGTH;

    //
    //  copy name
    //

    return Dns_NameCopy(
                pBuffer,
                & bufferLength,
                (PCHAR) pszName,
                0,                      // null terminated
                DnsCharSetUtf8,
                DnsCharSetUtf8 );
}



//
//  Temp fix ups for functions exposed in dnslib.h
//
//  DCR:  delete when clean build with dnslib.h functions removed
//

PSTR
_fastcall
Dns_GetDomainName(
    IN      PCSTR           pszName
    )
{
    return  Dns_GetDomainNameA( pszName );
}

PWSTR
_fastcall
Dns_GetDomainName_W(
    IN      PCWSTR          pwsName
    )
{
    return  Dns_GetDomainNameW( pwsName );
}

PCHAR
_fastcall
Dns_GetTldForName(
    IN      PCSTR           pszName
    )
{
    return  Dns_GetTldForNameA( pszName );
}

BOOL
_fastcall
Dns_IsNameShort(
    IN      PCSTR           pszName
    )
{
    return  Dns_IsNameShortA( pszName );
}

BOOL
_fastcall
Dns_IsNameFQDN(
    IN      PCSTR           pszName
    )
{
    return  Dns_IsNameFQDN_A( pszName );
}

DWORD
Dns_NameLabelCount(
    IN      PCSTR           pszName
    )
{
    return  Dns_NameLabelCountA( pszName );
}

DWORD
_fastcall
Dns_GetNameAttributes(
    IN      PCSTR           pszName
    )
{
    return  Dns_GetNameAttributesA( pszName );
}

//
//  End name.c
//
=== C:/Users/treeman/Desktop/windows nt source code\Source\Win2K3\NT\ds\dns\dnslib\locks.c ===
/*++

Copyright (c) 2001-2001 Microsoft Corporation

Module Name:

    locks.c

Abstract:

    Domain Name System (DNS) Library.

    Helpful locking routines.  These are not DNS specific.

Author:

    Jim Gilroy (jamesg)     September 2001

Revision History:

--*/


#include "local.h"

//  Note:  this modules requires only windows.h.
//      local.h is included only to allow precompiled header

#include <windows.h>

//
//  Init wait spin interval
//

#define CS_PROTECTED_INIT_INTERLOCK_WAIT    (5)     // 5ms

//
//  In progress flag
//

INT g_CsInitInProgress = FALSE;




VOID
InitializeCriticalSectionProtected(
    OUT     PCRITICAL_SECTION   pCritSec,
    IN OUT  PINT                pInitialized
    )
/*++

Routine Description:

    Protected init of CS.

    Purpose here is to do dynamic "on-demand" CS init
    avoiding need to do these in dll load for CS that are
    not generally used.

Arguments:

    pCs -- ptr to CS to init

    pInitialized -- addr of init state flag;  this flag must be
        initialized to zero (by loader or dll startup routine).

Return Value:

    None

--*/
{
    //
    //  protect CS init with interlock
    //      - first thread through does CS init
    //      - any others racing, are not released until init
    //          completes
    //

    while ( ! *pInitialized )
    {
        if ( InterlockedIncrement( &g_CsInitInProgress ) == 1 )
        {
            if ( !*pInitialized )
            {
                InitializeCriticalSection( pCritSec );
                *pInitialized = TRUE;
            }
            InterlockedDecrement( &g_CsInitInProgress );
            break;
        }

        InterlockedDecrement( &g_CsInitInProgress );
        Sleep( CS_PROTECTED_INIT_INTERLOCK_WAIT );
    }

    //
    //  implementation note:  "StartLocked" feature
    //
    //  considered having a "StartLocked" feature for callers who
    //  want to follow the CS init with other initialization;
    //  however the only service we could provide that is different
    //  than calling EnterCriticalSection() after this function, is
    //  to make sure the CS init thread gets the lock first;
    //  but this only protects changes that outcome when two init
    //  threads are in an extremely close race AND the issue of
    //  which thread initialized the CS is irrelevant
    //
}




//
//  Timed lock functions
//
//  This is critical section functionality with a time-limited wait.
//
//  DCR:  timed lock
//
//  non-wait locking
//      - have a wait count, for faster locking
//      - interlock increment coming in,
//      problem is would either have to ResetEvent() -- and
//      still racing another thread
//      or other threads would have to be able to ResetEvent()
//      safely
//
//  other alternative is have non-auto-reset event
//  (global event for all locks or unique if desired for perf)
//  everyone waiting releases, and checks their individual locks
//  when leaving lock with waiters threads always SetEvent
//


#if 0
typedef struct _TimedLock
{
    HANDLE  hEvent;
    DWORD   ThreadId;
    LONG    RecursionCount;
    DWORD   WaitTime;
}
TIMED_LOCK, *PTIMED_LOCK;

#define TIMED_LOCK_DEFAULT_WAIT     (0xf0000000)
#endif



DWORD
TimedLock_Initialize(
    OUT     PTIMED_LOCK     pTimedLock,
    IN      DWORD           DefaultWait
    )
/*++

Routine Description:

    Init timed lock.

Arguments:

    pTimedLock -- ptr to timed lock

Return Value:

    ERROR_SUCCESS if successful.
    Error code on failure.

--*/
{
    HANDLE  hevent;

    RtlZeroMemory( pTimedLock, sizeof(*pTimedLock) );

    //
    //  event
    //      - autoreset (satisfies only one waiting thread when signalled)
    //      - starts signalled (open)
    //

    hevent = CreateEvent(
                NULL,       // default security
                FALSE,      // auto-reset
                TRUE,       // start signalled
                NULL        // unnamed
                );
    if ( !hevent )
    {
        return  GetLastError();
    }

    pTimedLock->hEvent = hevent;

    //
    //  default wait
    //

    pTimedLock->WaitTime = DefaultWait;

    return  NO_ERROR;
}



VOID
TimedLock_Cleanup(
    OUT     PTIMED_LOCK     pTimedLock
    )
/*++

Routine Description:

    Cleanup timed lock.

Arguments:

    pTimedLock -- ptr to timed lock

Return Value:

    None

--*/
{
    //  close event

    if ( pTimedLock->hEvent )
    {
        CloseHandle( pTimedLock->hEvent );
        pTimedLock->hEvent = NULL;
    }
}



BOOL
TimedLock_Enter(
    IN OUT  PTIMED_LOCK     pTimedLock,
    IN      DWORD           WaitTime
    )
/*++

Routine Description:

    Timed lock.

Arguments:

    pTimedLock -- ptr to timed lock

    WaitTime -- time to wait for lock

Return Value:

    None

--*/
{
    DWORD   threadId;
    DWORD   result;

    //
    //  check for recursion
    //

    threadId = GetCurrentThreadId();

    if ( pTimedLock->ThreadId == threadId )
    {
        pTimedLock->RecursionCount++;
        return  TRUE;
    }

    //
    //  if non-wait -- bail
    //      - special case just to avoid going into wait
    //      and yielding timeslice
    //

    if ( WaitTime == 0 )
    {
        return  FALSE;
    }

    //
    //  wait for event to be signalled (open)
    //

    result = WaitForSingleObject(
                pTimedLock->hEvent,
                ( WaitTime != TIMED_LOCK_DEFAULT_WAIT )
                    ? WaitTime
                    : pTimedLock->WaitTime );

    if ( result == WAIT_OBJECT_0 )
    {
        ASSERT( pTimedLock->RecursionCount == 0 );
        ASSERT( pTimedLock->ThreadId == 0 );
    
        pTimedLock->RecursionCount = 1;
        pTimedLock->ThreadId = threadId;
        return TRUE;
    }

    ASSERT( result == WAIT_TIMEOUT );
    return  FALSE;
}



VOID
TimedLock_Leave(
    IN OUT  PTIMED_LOCK     pTimedLock
    )
/*++

Routine Description:

    Leave timed lock

Arguments:

    pTimedLock -- ptr to timed lock

Return Value:

    None

--*/
{
    //
    //  validate thread ID
    //
    //  note that with this check, it's then safe to decrement the count
    //  unchecked because it can never reach zero without thread ID
    //  being cleared -- barring non-functional manipulation of structure
    //

    if ( pTimedLock->ThreadId != GetCurrentThreadId() )
    {
        ASSERT( FALSE );
        return;
    }
    ASSERT( pTimedLock->RecursionCount > 0 );

    if ( --(pTimedLock->RecursionCount) == 0 )
    {
        pTimedLock->ThreadId = 0;
        SetEvent( pTimedLock->hEvent );
    }
}

//
//  End of locks.c
//
=== C:/Users/treeman/Desktop/windows nt source code\Source\Win2K3\NT\ds\dns\dnslib\record.h ===
/*++

Copyright(c) 1996-2000 Microsoft Corporation

Module Name:

    record.h

Abstract:

    Domain Name System (DNS) Library

    Resource record definitions.

Author:

    Jim Gilroy (jamesg)     December 1996

Revision History:

--*/


#ifndef _DNS_RECORD_INCLUDED_
#define _DNS_RECORD_INCLUDED_

//
//  Temp header while changing definition of DNS_RECORD structure
//

#undef DNS_PTR_DATA
#undef PDNS_PTR_DATA

#undef DNS_SOA_DATA
#undef PDNS_SOA_DATA

#undef DNS_MINFO_DATA
#undef PDNS_MINFO_DATA

#undef DNS_MX_DATA
#undef PDNS_MX_DATA

#undef DNS_TXT_DATA
#undef PDNS_TXT_DATA

#undef DNS_SIG_DATA
#undef PDNS_SIG_DATA

#undef DNS_KEY_DATA
#undef PDNS_KEY_DATA

#undef DNS_NXT_DATA
#undef PDNS_NXT_DATA

#undef DNS_SRV_DATA
#undef PDNS_SRV_DATA

#undef DNS_TSIG_DATA
#undef PDNS_TSIG_DATA

#undef DNS_TKEY_DATA
#undef PDNS_TKEY_DATA

#undef DNS_WINSR_DATA
#undef PDNS_WINSR_DATA

//  the big one

#undef DNS_RECORD
#undef PDNS_RECORD

//  the subs

#undef DNS_TEXT
#undef DNS_NAME


//
//  Define PDNS_NAME and PDNS_TEXT to make explicit
//

#ifdef UNICODE
typedef LPWSTR  PDNS_NAME;
#else
typedef LPSTR   PDNS_NAME;
#endif

#ifdef UNICODE
typedef LPWSTR  PDNS_TEXT;
#else
typedef LPSTR   PDNS_TEXT;
#endif

//
//  Data types
//

typedef struct
{
    PDNS_NAME   pszHost;
}
DNS_PTR_DATA, *PDNS_PTR_DATA;

typedef struct
{
    PDNS_NAME   pszPrimaryServer;
    PDNS_NAME   pszAdministrator;
    DWORD       dwSerialNo;
    DWORD       dwRefresh;
    DWORD       dwRetry;
    DWORD       dwExpire;
    DWORD       dwDefaultTtl;
}
DNS_SOA_DATA, *PDNS_SOA_DATA;

typedef struct
{
    PDNS_NAME   pszMailbox;
    PDNS_NAME   pszErrorsMailbox;
}
DNS_MINFO_DATA, *PDNS_MINFO_DATA;

typedef struct
{
    PDNS_NAME   pszExchange;
    WORD        wPreference;
    WORD        Pad;        // keep ptrs DWORD aligned
}
DNS_MX_DATA, *PDNS_MX_DATA;

typedef struct
{
    DWORD       dwStringCount;
    PDNS_TEXT   pStringArray[1];
}
DNS_TXT_DATA, *PDNS_TXT_DATA;

typedef struct
{
    PDNS_NAME   pszSigner;
    WORD        wTypeCovered;
    BYTE        chAlgorithm;
    BYTE        chLabelCount;
    DWORD       dwOriginalTtl;
    DWORD       dwSigExpiration;
    DWORD       dwSigInception;
    WORD        wKeyTag;
    WORD        Pad;        // keep byte field aligned
    BYTE        Signature[1];
}
DNS_SIG_DATA, *PDNS_SIG_DATA;

typedef struct
{
    WORD        wFlags;
    BYTE        chProtocol;
    BYTE        chAlgorithm;
    BYTE        Key[1];
}
DNS_KEY_DATA, *PDNS_KEY_DATA;

typedef struct
{
    PDNS_NAME   pszNext;
    BYTE        bTypeBitMap[1];
}
DNS_NXT_DATA, *PDNS_NXT_DATA;

typedef struct
{
    PDNS_NAME   pszTarget;
    WORD        wPriority;
    WORD        wWeight;
    WORD        wPort;
    WORD        Pad;        // keep ptrs DWORD aligned
}
DNS_SRV_DATA, *PDNS_SRV_DATA;

typedef struct
{
    PDNS_NAME   pszAlgorithm;
    PBYTE       pAlgorithmPacket;
    PBYTE       pKey;
    PBYTE       pOtherData;
    DWORD       dwCreateTime;
    DWORD       dwExpireTime;
    WORD        wMode;
    WORD        wError;
    WORD        wKeyLength;
    WORD        wOtherLength;
    UCHAR       cAlgNameLength;
    BOOLEAN     fPacketPointers;
}
DNS_TKEY_DATA, *PDNS_TKEY_DATA;

typedef struct
{
    PDNS_NAME   pszAlgorithm;
    PBYTE       pAlgorithmPacket;
    PBYTE       pSignature;
    PBYTE       pOtherData;
    LONGLONG    i64CreateTime;
    WORD        wFudgeTime;
    WORD        wError;
    WORD        wSigLength;
    WORD        wOtherLength;
    UCHAR       cAlgNameLength;
    BOOLEAN     fPacketPointers;
}
DNS_TSIG_DATA, *PDNS_TSIG_DATA;


//
//  MS only types -- only hit the wire in MS-MS zone transfer
//

typedef struct
{
    DWORD       dwMappingFlag;
    DWORD       dwLookupTimeout;
    DWORD       dwCacheTimeout;
    PDNS_NAME   pszResultDomain;
}
DNS_WINSR_DATA, *PDNS_WINSR_DATA;



//
//  Record \ RR set structure
//
//  Note:   The dwReserved flag serves to insure that the substructures
//          start on 64-bit boundaries.  Since adding the LONGLONG to
//          TSIG structure the compiler wants to start them there anyway
//          (to 64-align).  This insures that no matter what data fields
//          are present we are properly 64-aligned.
//
//          Do NOT pack this structure, as the substructures to be 64-aligned
//          for Win64.
//

typedef struct _DnsRecord
{
    struct _DnsRecord * pNext;
    PDNS_NAME           pszOwner;
    WORD                wType;
    WORD                wDataLength;
    union
    {
        DWORD           W;  // flags as dword
        DNSREC_FLAGS    S;  // flags as structure

    } Flags;

    DWORD               dwTtl;
    DWORD               dwReserved;
    union
    {
        DNS_A_DATA      A;
        DNS_SOA_DATA    SOA, Soa;
        DNS_PTR_DATA    PTR, Ptr,
                        NS, Ns,
                        CNAME, Cname,
                        MB, Mb,
                        MD, Md,
                        MF, Mf,
                        MG, Mg,
                        MR, Mr;
        DNS_MINFO_DATA  MINFO, Minfo,
                        RP, Rp;
        DNS_MX_DATA     MX, Mx,
                        AFSDB, Afsdb,
                        RT, Rt;
        DNS_TXT_DATA    HINFO, Hinfo,
                        ISDN, Isdn,
                        TXT, Txt,
                        X25;
        DNS_NULL_DATA   Null;
        DNS_WKS_DATA    WKS, Wks;
        DNS_AAAA_DATA   AAAA;
        DNS_SRV_DATA    SRV, Srv;
        DNS_TKEY_DATA   TKEY, Tkey;
        DNS_TSIG_DATA   TSIG, Tsig;
        DNS_ATMA_DATA   ATMA, Atma;
        DNS_WINS_DATA   WINS, Wins;
        DNS_WINSR_DATA  WINSR, WinsR, NBSTAT, Nbstat;

    } Data;
}
DNS_RECORD, *PDNS_RECORD;



#endif // _DNS_RECORD_INCLUDED_
=== C:/Users/treeman/Desktop/windows nt source code\Source\Win2K3\NT\ds\dns\dnslib\print.c ===
/*++

Copyright (c) 1997-2001 Microsoft Corporation

Module Name:

    print.c

Abstract:

    Domain Name System (DNS) Library

    Print routines.

Author:

    Jim Gilroy (jamesg)     February 8, 1997

Revision History:

--*/


#include "local.h"
#include "svcguid.h"                    // RnR guids
#include "..\dnsapi\dnsapip.h"          // Private query stuff
#include "..\resolver\idl\resrpc.h"     // Resolver interface structs


//
//  Print globals
//

CRITICAL_SECTION    DnsAtomicPrintCs;
PCRITICAL_SECTION   pDnsAtomicPrintCs = NULL;

//
//  Empty string for simple switching of UTF-8/Unicode print
//      (macros in dnslib.h)
//

DWORD   DnsEmptyString = 0;


//
//  Indenting
//
//  Serve up as many indenting tabs as indent level indicates
//

CHAR    IndentString[] = "\t\t\t\t\t\t\t\t\t\t\t\t\t\t\t\t\t\t\t\t\t\t\t";

#define INDENT_STRING( level )  (IndentString + (sizeof(IndentString) - 1 - (level)))



//
//  Print Locking
//
//  Unless caller initilizes print locking by supplying lock,
//  print locking is disabled.
//

VOID
DnsPrint_InitLocking(
    IN      PCRITICAL_SECTION   pLock
    )
/*++

Routine Description:

    Setup DNS printing to use a lock.

    Can use already initialized lock from caller, or will
    create default lock.

Arguments:

    pLock - ptr to CS to use as lock;  if NULL, create one

Return Value:

    None

--*/
{
    if ( pLock )
    {
        pDnsAtomicPrintCs = pLock;
    }
    else if ( !pDnsAtomicPrintCs )
    {
        InitializeCriticalSection( &DnsAtomicPrintCs );
        pDnsAtomicPrintCs = &DnsAtomicPrintCs;
    }
}



VOID
DnsPrint_Lock(
    VOID
    )
/*++

Routine Description:

    Lock to get atomic DNS print.

--*/
{
    if ( pDnsAtomicPrintCs )
    {
        EnterCriticalSection( pDnsAtomicPrintCs );
    }
}


VOID
DnsPrint_Unlock(
    VOID
    )
/*++

Routine Description:

    Unlock to debug print.

--*/
{
    if ( pDnsAtomicPrintCs )
    {
        LeaveCriticalSection( pDnsAtomicPrintCs );
    }
}



//
//  Print routines for general types and structures
//

VOID
DnsPrint_String(
    IN      PRINT_ROUTINE   PrintRoutine,
    IN OUT  PPRINT_CONTEXT  pContext,
    IN      PSTR            pszHeader       OPTIONAL,
    IN      PSTR            pszString,
    IN      BOOL            fUnicode,
    IN      PSTR            pszTrailer      OPTIONAL
    )
/*++

Routine Description:

    Print DNS string given in either Unicode or UTF-8 format.

--*/
{
    if ( !pszHeader )
    {
        pszHeader = "";
    }
    if ( !pszTrailer )
    {
        pszTrailer = "";
    }

    if ( ! pszString )
    {
        PrintRoutine(
            pContext,
            "%s(NULL DNS string ptr)%s",
            pszHeader,
            pszTrailer );
    }
    else if (fUnicode)
    {
        PrintRoutine(
            pContext,
            "%s%S%s",
            pszHeader,
            (PWSTR ) pszString,
            pszTrailer );
    }
    else
    {
        PrintRoutine(
            pContext,
            "%s%s%s",
            pszHeader,
            (PSTR ) pszString,
            pszTrailer );
    }
}



VOID
DnsPrint_StringCharSet(
    IN      PRINT_ROUTINE   PrintRoutine,
    IN OUT  PPRINT_CONTEXT  pContext,
    IN      PSTR            pszHeader       OPTIONAL,
    IN      PSTR            pszString,
    IN      DNS_CHARSET     CharSet,
    IN      PSTR            pszTrailer      OPTIONAL
    )
/*++

Routine Description:

    Print string of given CHARSET.

--*/
{
    DnsPrint_String(
        PrintRoutine,
        pContext,
        pszHeader,
        pszString,
        (CharSet == DnsCharSetUnicode),
        pszTrailer );
}



VOID
DnsPrint_UnicodeStringBytes(
    IN      PRINT_ROUTINE   PrintRoutine,
    IN OUT  PPRINT_CONTEXT  pContext,
    IN      PSTR            pszHeader,
    IN      PWCHAR          pUnicode,
    IN      DWORD           Length
    )
/*++

Routine Description:

    Print chars (WORDs) of unicode string.

--*/
{
    DWORD   i;

    PrintRoutine(
        pContext,
        "%s\r\n"
        "\twide string  %S\r\n"
        "\tlength       %d\r\n"
        "\tbytes        ",
        pszHeader,
        pUnicode,
        Length );

    for ( i=0; i<Length; i++ )
    {
        PrintRoutine(
            pContext,
            "%04hx ",
            pUnicode[i] );
    }
    printf( "\r\n" );
}



VOID
DnsPrint_Utf8StringBytes(
    IN      PRINT_ROUTINE   PrintRoutine,
    IN OUT  PPRINT_CONTEXT  pContext,
    IN      PSTR            pszHeader,
    IN      PCHAR           pUtf8,
    IN      DWORD           Length
    )
/*++

Routine Description:

    Print bytes of UTF8 string.

--*/
{
    DWORD   i;

    PrintRoutine(
        pContext,
        "%s\r\n"
        "\tUTF8 string  %s\r\n"
        "\tlength       %d\r\n"
        "\tbytes        ",
        pszHeader,
        pUtf8,
        Length );

    for ( i=0; i<Length; i++ )
    {
        PrintRoutine(
            pContext,
            "%02x ",
            (UCHAR) pUtf8[i] );
    }
    printf( "\r\n" );
}



VOID
DnsPrint_StringArray(
    IN      PRINT_ROUTINE   PrintRoutine,
    IN OUT  PPRINT_CONTEXT  pContext,
    IN      PSTR            pszHeader,
    IN      PSTR *          StringArray,
    IN      DWORD           Count,          OPTIONAL
    IN      BOOL            fUnicode
    )
/*++

Routine Description:

    Print string array.

--*/
{
    DWORD   i = 0;
    PCHAR   pstr;

    if ( !pszHeader )
    {
        pszHeader = "StringArray:";
    }
    if ( !StringArray )
    {
        PrintRoutine(
            pContext,
            "%s  NULL pointer!\r\n",
            pszHeader );
    }

    DnsPrint_Lock();

    if ( Count )
    {
        PrintRoutine(
            pContext,
            "%s  Count = %d\r\n",
            pszHeader,
            Count );
    }
    else
    {
        PrintRoutine(
            pContext,
            "%s\r\n",
            pszHeader );
    }

    //
    //  print args
    //      - stop at Count (if given)
    //      OR
    //      - on NULL arg (if no count given)
    //

    while ( (!Count || i < Count) )
    {
        pstr = StringArray[i++];
        if ( !pstr && !Count )
        {
            break;
        }
        PrintRoutine(
            pContext,
            (fUnicode) ? "\t%S\r\n" : "\t%s\r\n",
            pstr );
    }

    DnsPrint_Unlock();
}



VOID
DnsPrint_Argv(
    IN      PRINT_ROUTINE   PrintRoutine,
    IN OUT  PPRINT_CONTEXT  pContext,
    IN      PSTR            pszHeader,
    IN      CHAR **         Argv,
    IN      DWORD           Argc,            OPTIONAL
    IN      BOOL            fUnicode
    )
/*++

Routine Description:

    Print Argv array.

--*/
{
    //
    //  this is just special case of string print
    //

    DnsPrint_StringArray(
        PrintRoutine,
        pContext,
        pszHeader
            ? pszHeader
            : "Argv:",
        Argv,
        Argc,
        fUnicode );
}



VOID
DnsPrint_DwordArray(
    IN      PRINT_ROUTINE   PrintRoutine,
    IN OUT  PPRINT_CONTEXT  pContext,
    IN      PSTR            pszHeader,
    IN      PSTR            pszName,
    IN      DWORD           dwCount,
    IN      PDWORD          adwArray
    )
/*++

Routine Description:

    Print DWORD array.

--*/
{
    DWORD i;

    DnsPrint_Lock();

    if ( pszHeader )
    {
        PrintRoutine(
            pContext,
            pszHeader );
    }

    if ( !pszName )
    {
        pszName = "DWORD";
    }
    PrintRoutine(
        pContext,
        "%s Array Count = %d\r\n",
        pszName,
        dwCount );

    for( i=0; i<dwCount; i++ )
    {
        PrintRoutine(
            pContext,
            "\t%s[%d] => 0x%p (%d)\r\n",
            pszName,
            i,
            adwArray[i],
            adwArray[i] );
    }

    DnsPrint_Unlock();
}



VOID
DnsPrint_Ip4AddressArray(
    IN      PRINT_ROUTINE   PrintRoutine,
    IN OUT  PPRINT_CONTEXT  pContext,
    IN      PSTR            pszHeader,
    IN      PSTR            pszName,
    IN      DWORD           dwIpAddrCount,
    IN      PIP4_ADDRESS    pIpAddrs
    )
/*++

Routine Description:

    Print IP address array.

--*/
{
    DWORD i;

    DnsPrint_Lock();

    if ( !pszName )
    {
        pszName = "IP Addr";
    }
    PrintRoutine(
        pContext,
        "%s Addr Count = %d\r\n",
        pszHeader ? pszHeader : "",
        dwIpAddrCount );

    if ( dwIpAddrCount != 0  &&  pIpAddrs != NULL )
    {
        //  print array with count
        //  use character print so works even if NOT DWORD aligned

        for( i=0; i<dwIpAddrCount; i++ )
        {
            PrintRoutine(
                pContext,
                "\t%s[%d] => %d.%d.%d.%d\r\n",
                pszName,
                i,
                * ( (PUCHAR) &pIpAddrs[i] + 0 ),
                * ( (PUCHAR) &pIpAddrs[i] + 1 ),
                * ( (PUCHAR) &pIpAddrs[i] + 2 ),
                * ( (PUCHAR) &pIpAddrs[i] + 3 ) );
        }
    }

#if 0
    //  this spins if printing zero length IP_ARRAY struct

    else if ( pIpAddrs != NULL )
    {
        //  print NULL terminated array (ex. hostents IPs)

        i = 0;
        while ( pIpAddrs[i] )
        {
            PrintRoutine(
                pContext,
                "\t%s[%d] => %s\r\n",
                pszName,
                i,
                inet_ntoa( *(struct in_addr *) &pIpAddrs[i] ) );
        }
    }
#endif

    DnsPrint_Unlock();
}



VOID
DnsPrint_Ip4Array(
    IN      PRINT_ROUTINE   PrintRoutine,
    IN OUT  PPRINT_CONTEXT  pContext,
    IN      PSTR            pszHeader,
    IN      PSTR            pszName,
    IN      PIP4_ARRAY      pIpArray
    )
/*++

Routine Description:

    Print IP address array struct

    Just pass through to more generic print routine.

--*/
{
    //  protect against NULL case

    if ( !pIpArray )
    {
        PrintRoutine(
            pContext,
            "%s\tNULL IP Array.\r\n",
            pszHeader ? pszHeader : "" );
    }

    //  call uncoupled IP array routine

    else
    {
        DnsPrint_Ip4AddressArray(
            PrintRoutine,
            pContext,
            pszHeader,
            pszName,
            pIpArray->AddrCount,
            pIpArray->AddrArray );
    }
}



VOID
DnsPrint_Ip6Address(
    IN      PRINT_ROUTINE       PrintRoutine,
    IN OUT  PPRINT_CONTEXT      pContext,
    IN      PSTR                pszHeader,
    IN      PIP6_ADDRESS        pIp6Addr,
    IN      PSTR                pszTrailer
    )
/*++

Routine Description:

    Print IP6 address.

Arguments:

    PrintRoutine -- print routine to call

    pContext -- first argument to print routine

    pszHeader -- header to print
        NOTE:  unlike other print routines this routine
        requires header to contain newline,tab, etc if
        multiline print is desired;  the reason is to allow
        use of this routine for single line print

    pIp6Address -- ptr to IP6 address to print

    pszTrailer -- trailer to print
        NOTE:  again this routine is designed to allow single
        line print;  if newline required after print, send
        newline in trailer

Return Value:

    Ptr to next location in buffer (the terminating NULL).

--*/
{
    CHAR    buffer[ IP6_ADDRESS_STRING_BUFFER_LENGTH ];

    if ( !pszHeader )
    {
        pszHeader = "IP6 Addr: ";
    }
    if ( !pszTrailer )
    {
        pszTrailer = "\r\n";
    }

    if ( !pIp6Addr )
    {
        PrintRoutine(
            pContext,
            "%s NULL IP6 address ptr.%s",
            pszHeader,
            pszTrailer );
        return;
    }

    //  convert IP6 address to string

    Dns_Ip6AddressToString_A(
           buffer,
           pIp6Addr );

    PrintRoutine(
        pContext,
        "%s%s%s",
        pszHeader,
        buffer,
        pszTrailer );
}



VOID
DnsPrint_Ip6Array(
    IN      PRINT_ROUTINE   PrintRoutine,
    IN OUT  PPRINT_CONTEXT  pContext,
    IN      PSTR            pszHeader,
    IN      PSTR            pszName,
    IN      PIP6_ARRAY      pIpArray
    )
/*++

Routine Description:

    Print IP address array struct

    Just pass through to more generic print routine.

--*/
{
    DWORD   i;
    CHAR    buffer[ IP6_ADDRESS_STRING_BUFFER_LENGTH ];

    if ( !pszName )
    {
        pszName = "IP";
    }
    if ( !pszHeader )
    {
        pszHeader = "IP Array";
    }

    //  protect against NULL case

    if ( !pIpArray )
    {
        PrintRoutine(
            pContext,
            "%s \tNULL IP Array.\n",
            pszHeader );
        return;
    }

    DnsPrint_Lock();

    PrintRoutine(
        pContext,
        "%s\n"
        "\tPtr          = %p\n"
        "\tMaxCount     = %d\n"
        "\tAddrCount    = %d\n",
        pszHeader,
        pIpArray,
        pIpArray->MaxCount,
        pIpArray->AddrCount );

    for( i=0; i<pIpArray->AddrCount; i++ )
    {
        //  convert IP6 address to string
    
        Dns_Ip6AddressToString_A(
               buffer,
               & pIpArray->AddrArray[i] );
    
        PrintRoutine(
            pContext,
            "\t%s[%d] => %s\n",
            pszName,
            i,
            buffer );
    }

    DnsPrint_Unlock();
}



//
//  Print routines for DNS types and structures
//

VOID
DnsPrint_DnsAddrLine(
    IN      PRINT_ROUTINE   PrintRoutine,
    IN OUT  PPRINT_CONTEXT  pContext,
    IN      PSTR            pszHeader,
    IN      PDNS_ADDR       pAddr,
    IN      PSTR            pszTrailer
    )
/*++

Routine Description:

    Print DNS_ADDR

Arguments:

    PrintRoutine -- print routine to call

    pContext -- first argument to print routine

    pszHeader -- header to print
        NOTE:  unlike other print routines this routine
        requires header to contain newline,tab, etc if
        multiline print is desired;  the reason is to allow
        use of this routine for single line print

    pDnsAddr -- ptr to addr to print

    pszTrailer -- trailer to print
        NOTE:  again this routine is designed to allow single
        line print;  if newline required after print, send
        newline in trailer

Return Value:

    Ptr to next location in buffer (the terminating NULL).

--*/
{
    CHAR    buffer[ DNS_ADDR_STRING_BUFFER_LENGTH ];

    if ( !pszHeader )
    {
        pszHeader = "DnsAddr: ";
    }
    if ( !pszTrailer )
    {
        pszTrailer = "\r\n";
    }

    if ( !pAddr )
    {
        PrintRoutine(
            pContext,
            "%s NULL DNS_ADDR ptr.%s",
            pszHeader,
            pszTrailer );
        return;
    }

    //  convert DNS_ADDR to string

    DnsAddr_WriteStructString_A( buffer, pAddr );

    PrintRoutine(
        pContext,
        "%s%s%s",
        pszHeader,
        buffer,
        pszTrailer );
}



VOID
DnsPrint_DnsAddr(
    IN      PRINT_ROUTINE   PrintRoutine,
    IN OUT  PPRINT_CONTEXT  pContext,
    IN      PSTR            pszHeader,
    IN      DWORD           Indent,
    IN      PDNS_ADDR       pSab
    )
/*++

Routine Description:

    Print sockaddr blob structure and length used in call.

--*/
{
    PSTR    pindent = INDENT_STRING( Indent );

    if ( !pszHeader )
    {
        pszHeader = "Sockaddr Blob:";
    }

    if ( !pSab )
    {
        PrintRoutine(
            pContext,
            "%s%s\tNULL SockaddrBlob passed to print.\r\n",
            pindent,
            pszHeader );
        return;
    }

    DnsPrint_Lock();

    DnsPrint_Sockaddr(
        PrintRout